* linux(操作系统)
** 系统管理
   分区,挂载分区
   命令行，网络配置, 显示器
   远程图像界面登录 X -query 192.168.0.2
** 内核管理
    apt install linux-head-generic linux-image-genric linux-head
    sudo update-grub
** 软件管理
*** deb软件
    安装 sudo dpkg -i *.deb  进行安装
*** apt 
    apt-get source <package> 获取源码
    apt-cache search 'expression'
    列表位于/etc/apt/sources.list
    维护好依赖, 都是 deb文件
    路径  /var/cache/apt/archives
** 任务管理
*** 任务放在前、后台
    fg bg jobs 
*** w 登录任务列表
*** ps 任务列表
   #+BEGIN_SRC conf
     -e   显示所有进程 
     -f    全格式
     -h   不显示标题
     -l    长格式
     -w     宽输出
     a    显示终端上的所有进程，包括其他用户的进程。
     r    只显示正在运行的进程。
     u 　以用户为主的格式来显示程序状况。
     x     显示所有程序，不以终端机来区分。

     ps -ef 显示出的结果：
         1.UID       用户ID
         2.PID        进程ID
         3.PPID      父进程ID
         4.C           CPU占用率
         5.STIME     开始时间
         6.TTY         开始此进程的TTY----终端设备
         7.TIME       此进程运行的总时间
         8.CMD       命令名
   #+END_SRC
   
   init init进程是所有Linux进程的父进程
*** crontab 执行周期任务
**** 命令
     crontab [ -u user ] file
     crontab [ -u user ] [ -i ] { -e | -l | -r } |
     -e 编辑crontab文件
     -l　列出crontab文件内容
     -r 删除crontab文件
**** 开启日志     
    修改rsyslog文件，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的#删掉；
    重启rsyslog服务service rsyslog restart；
    重启cron服务service cron restart；

    more /var/log/cron.log；
    就可以查看运行时的日志文件，如果在日志文件中出现：No MTA installed, discarding output

    那么就是说，crontab执行脚本时是不会直接错误的信息输出，而是会以邮件的形式发送到你的邮箱里，这时候就需要邮件服务器了，
    如果你没有安装邮件服务器，它就会报这个错。如果是测试，可以用下面的办法来解决：

    在每条定时脚本后面加入：
    ?
    001
    >/dev/null 2>&1
    就可以解决No MTA installed, discarding output的问题
**** 编辑文件, 其实编辑好后就会自动执行
    crontab -e  

    # m h  dom mon dow   command  
    */2 * * * * date >> ~/time.log  
**** 执行     
     sudo service cron restart  

     对于自己的，只要执行下自己的crontab　文件即可
     crontab -u wuming crontabfile

 | 分钟 | 0 - 59                                                                     |
 | 小时 | 0 - 23                                                                     |
 | 天   | 1 - 31                                                                     |
 | 月   | 1 - 12                                                                     |
 | 星期 | 0 - 6   0表示星期天                                                        |
 | 星号 | 表示任意值，比如在小时部分填写 * 代表任意小时（每小时）                    |
 | 逗号 | 可以允许在一个部分中填写多个值，比如在分钟部分填写 1,3 表示一分钟或三分钟  |
 | 斜线 | 一般配合 * 使用，代表每隔多长时间，比如在小时部分填写 */2 代表每隔两分钟。 |
\* * * * *                  # 每隔一分钟执行一次任务  
0 * * * *                  # 每小时的0点执行一次任务，比如6:00，10:00  
6,10 * 2 * *            # 每个月2号，每小时的6分和10分执行一次任务  
*** pkill 杀死进程按照进程名
*** 进程属性
    ls /proc/PID 
    cwd 进程运行目录
    exe 程序绝对路径
    cmdline 运行时的命令行命令
    environ 环境变量
    fd 打开或使用的文件的符号链接
** 用户管理
*** 添加用户   
     useradd -m -g users -G wheel -s /bin/bash ikke
     passwd ikke
*** sudo组
     打开 /etc/sudoers 
*** 忘记登录密码
   1,启动时在启动的linux系统（或grub到计时结束前）上按下“e”键
   2，选中类似“于kernel /boot/vmlinuz-2.4.18-14 ”按“e”键
   3,修改命令行，加入linux single，结果如下：
   kernel /vmlinuz-2.6.18-8.el5  ro root=LABEL=/ rhgb quiet linux single
   4,回车返回，按b键,进入命令行
   5, #vi /etc/shadow 编辑shadow
   将第一行，即以root开头的一行中root:后和下一个:前的内容删除，
   第一行将类似于
   root::……
   保存
   (如果保存不了，是文件属性的问题，就chmod 755 /etc/shadow，这样就OK了)
6. #reboot重启，root密码为空
* 应用软件
** 压缩
*** 7z 
    解压
    7z x  dist.7z -r -o/home/Baby/Desktop
    x 代表解压缩文件，并且是按原始目录解压
    dist.7z 是压缩文件，如果不在当前目录下要带上完整的目录
    -r 表示递归所有的子文件夹
    -o 是指定解压到的目录，（注意-o后是没有空格的直接接目录）

    压缩文件／文件夹
    7z a -t7z -r  dist.7z   /web/source/*
    a 代表添加文件／文件夹到压缩包
    -t 是指定压缩类型 
    -r 表示递归所有的子文件夹
    dist.7z 是压缩好后的压缩包名
    /web/source/* 是要压缩的目录，＊是表示该目录下所有的文件
*** unzip 
    -l     list archive files (short format)
*** gzip
** 编程
*** gcc 基于C/C++的预处理器和编译器
    -o：指定生成的输出文件,所以编译多个文件是,-o 没有意义；
    -E：仅执行编译预处理； .i
    -S：将C代码转换为汇编代码；.s
    -wall：显示警告信息；
    -c：仅执行编译操作，不进行连接操作。.o
**** 1. 预处理 gcc -E test.c -o test.i
     -C:
     -H:
     -include:
**** 2. 编译为汇编代码   gcc -S test.i -o test.s
     masm=intel	汇编代码 
     -std 指定使用的语言标准
**** 3. gas  gcc -c test.s -o test.o
     :-Wa,option
     :-llibrary 连接名为library的库文件
     :-L 指定额外路径
     :-m32
**** 4. ld  gcc test.o -o test
     :-lobjc 这个-l选项的特殊形式用于连接Objective C程序.
     :-nostartfiles 不连接系统标准启动文件,而标准库文件仍然正常使用.
     :-nostdlib 不连接系统标准启动文件和标准库文件.只把指定的文件传递给连接器.
     :-static 在支持动态连接(dynamic linking)的系统上,阻止连接共享库.该选项在其他系统上无效.
     :-shared 生成一个共享目标文件,他可以和其他目标文件连接产生可执行文件.只有部分系统支持该选项.
     :-symbolic 建立共享目标文件的时候,把引用绑定到全局符号上.对所有无法解析的引用作出警
     告(除非用连接编辑选项 `-Xlinker -z -Xlinker defs'取代).只有部分系统支持该选项.
     :-u symbol 使连接器认为取消了symbol的符号定义,从而连接库模块以取得定义.你可以使用多
     个 `-u'选项,各自跟上不同的符号,使得连接器调入附加的库模块.
     : [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
     : -lAR	在连 接文件列表中增加归档库文件AR.可以多次使用这个选项. 凡指定一项AR,ld 就会在路径列表中增加一项对libar.a的搜索.
     : -LSEARCHDIR   这个选项将路径SEARCHDIR添加到路径列表, ld在这个列表中搜索归档库.
     可以多次使用这个选项.缺省的搜索路径集(不使用-L时)取决于ld使用的
     模拟模式(emulation)及其配置.在连接脚本中,可以用SEARCH_DIR命令指定路径. 
     : -Tbss org
     : -Tdata org
     : -Ttext org
     把org作为输出文件的段起始地址 --- 特别是 --- bss,data,或text段.org必须是十六进制整数. 
     : -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
     : -x    删除 全部 局部符号. 
     : -m 指定仿真环境,这里要与gcc 的选项 -m32一致; -V显示 支持的仿真：本机支持   elf_x86_64   
     elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
     LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
     : 注意,如果连接器通过被编译器驱动来间接引用(比如gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
     gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
     : `-b INPUT-FORMAT'
     `--format=INPUT-FORMAT' [binary]
     'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
     你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
     : `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld的缺省输出格式配置
     为/各个机器上最常用的/ 格式. output-format是一个 字符串,BFD库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
     : [`-N']|[`--omagic']
     把text和data节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
     支持Unix风格的magic number, 把输出标志为'OMAGIC'. 
**** 5. 检错
     : -Wall 产生尽可能多的警告信息
     : -Werror GCC会在所有产生警告的地方停止编译
**** 6. 库文件连接 .a .so
     : 包含文件 -I /usr/dirpath    
     : 库   -L /dirpath   -llibname  不要.a 或.so 后缀
     : 强制静态库 gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
     静态库链接时搜索路径顺序：
     1. ld会去找GCC命令中的参数-L
     2. 再找gcc的环境变量LIBRARY_PATH
     3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的

     动态链接时、执行时搜索路径顺序:
     1. 编译目标代码时指定的动态库搜索路径
     2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
     3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
     4. 默认的动态库搜索路径/lib
     5. 默认的动态库搜索路径/usr/lib
     有关环境变量：
     LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径
     LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径
**** 7. 调试
     -g:
     -gstabs:
     -gcoff:
     -gdwarf:
**** 8. 优化
     -O0 不优化
     -fcaller-saves: 
**** 9. 目标机选项(Target Option) 交叉编译
     -b machine 
     -V version 哪个版本的gcc
**** 10.配置相关选项(Configuration Dependent Option)
     M680x0 选项
     i386选项
**** 11.总体选项(Overall Option)
     -x language
     明确指出后面输入文件的语言为language (而不是从文件名后缀得到的默认选择).

**** 12.目录选项(DIRECTORY OPTION)
     :-Idir 在头文件的搜索路径列表中添加dir 目录.
     :-Ldir 在`-l'选项的搜索路径列表中添加dir目录.

**** 13.C 文件与 汇编文件编译
     以下涉及到不同编译器对符号的处理问题。比如我们写个汇编文件，汇编后，汇编文件中的符号未变，但是当我们写个C文件再生成目标文件后，源文件中的符号前可能加了下划线，当两者之间发生引用关系时可能无法连接，此时我们会用到下面的命令。
     : --change-leading-char
     : --remove-leading-char
     : --prefix-symbols=string
*** ldconfig 动态链接库管理命令
*** readelf 用于显示elf格式文件的信息
    : -a       --all
**** elf header
     描述了这个elf文件的一些信息，如数据格式是big-endian 或者little-endian
     运行平台、section header 的个数等。
***** section headers是一个表，表中的每个条目描述了一个section，
      如section在文件中的偏移，大小等。
***** section中就是elf文件中"真正"的信息了。

*** objdump 显示二进制文件信息
    : -a|--archive-header 列出 archive头/列表用'ar tv'
    : -d反汇编
    : -S|--source
    : -m MACHINE| --architecture=MACHINE
    : -G|--stabs
*** gdb 功能强大的程序调试器
**** options gdb <program> [core]|[PID]
     -d 指定远程调试时串行接口的线路速度
     -batch 以批处理模式运行
     -c 指定要分析的核心转储文件
     -cd 指定工作目录
     -d 指定搜索源文件的目录
     -e 指定要执行的文件
     -f 调试时以标准格式输出文件名和行号
     -q 安静模式
     -s 指定符号的文件名
     -se 指定符号和要执行的文件名
     -tty 设置标准输出和输入设备
     -x 从指定的文件执行 gdb 命令
**** 常用的调试命令
     shell <command>
     make <make -args>

     运行参数
     set args 设定参数
     show args 查看运行参数
     运行环境
     path<dir> 设定程序的运行路径。
     show paths 查看程序的运行路径。
     set environment varname[=value]设置环境变量。如:set env USER=hchen
     show environment[varname]查看环境变量
     工作目录
     cd <dir>相当于 shell 的 cd 命令。
     pwd 显示当前的工作目录。
     程序的输入输出
     info terminal 显示程序用到的终端的模式
     使用重定向空值程序输出。如 run>outfile
     tty 命令可以指定写输入输出的终端设备。如 tty /dev/ttyb
     列出源码 ;l 3 （开始行） 根据本地文件,没有就列不出 
     设置断点 ;b filename: <行号>;break +offset -offset 当前行号前后
     b filename: <函数名称>;
     b *<函数名称>;
     b *<代码地址> 
     break...if<condition>
     调试程序 ;r 
     继续执行 ;c
     删除断点 ;clear <行号>
     删除断点 ;d <编号>
     执行一行 ;n /s
     结束循环 ;until
     p $1 ($1为历史记录变量); 
     p <数组名>显示数组元素;
     p <*数组指针>显示数组int a[N]的特定值：
     p &var 显示变量地址
     显示变量类型;    whatis p
     显示各类信息   info b 显示断点信息
     finish 退出函数
     info r 寄存器信息
     info local 当前函数中的局部变量信息;
     info prog 显示被调试程序的执行状态
     break *_start+1 由于 gnu 调试时忽略开始处断点, 需要在开始标签处执行一个空指令
     print/d 显示十进制数字
     print/t 显示二进制数字
     print/x 显示 16 进制数字

     x/FMT ADDRESS.
     ADDRESS is an expression for the memory address to examine.
     FMT is a repeat count followed by a format letter and a size letter.
     Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
     t(binary), f(float), a(address), i(instruction), c(char), s(string)
     and z(hex, zero padded on the left).
     Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
     The specified number of objects of the specified size are printed
     according to the format.
     7.0版本以上gdb的disas命令可以携带/m参数，让汇编与c源码同时显示：disas /m main

     使用 x 命令可以查看特定内存的值:
     x/nyz
     其中 n 为要显示的字段数
     y 时输出格式, 它可以是:
     c 用于字符, d 用于十进制, x 用于 16 进制
     z 是要显示的字段长度, 它可以是:
     b 用于字节, h 用于 16 字节, w 用于 32 位字
     如:
     x/42cb 用于显示前 42 字节
     print-stack      查看堆栈               
     u start end      反汇编内存                       
     trace on          反汇编每一条                    
     trace-reg on    每执行一条打印cpu               
     xp /32bx 0x90000  查询从0x90000开始的32个字节内容 
*** make GNU的工程化编译工具
*** eclipse
**** eclipse快捷键
   1. 常用快捷键
   这是使用工具的第一步，熟练使用快捷键对于我们编写程序会起到相当大帮助，所以这里笔者列出的快捷键建议大家必须都掌握。
   Ctrl + 鼠标左键（类、方法、属性的变量名词）：定位跟踪某变量声明或定义的位置
   Ctrl + S：保存当前文件
   Ctrl + X：剪切
   Ctrl + C：复制
   Ctrl + V：粘贴
   Ctrl + D：删除当前行
   Ctrl + F：查找/替换（当前编辑窗口）
   Ctrl + H：全局搜索
   Ctrl + /：注释当前行或多行代码
   Ctrl + Shift + C：注释当前行或多行代码
   Ctrl + Shift + F：格式化当前代码
   Ctrl + Shift + O：缺少的Import语句被加入，多余的Import语句被删除（先把光标定位到需导入包的类名上）
   Ctrl + Shift + S：保存所有文件
   Ctrl + Shift + X：把当前选中的文本全部变为大写
   Ctrl + Shift + Y：把当前选中的文本全部变为小写
   Alt + /：代码智能提示
   Alt + Shift + R：重命名（包括文件名、类名、方法名、变量名等等，非常好用）
   Alt + Shift + J：生成类或方法的注释
   Alt + Shift + S：打开Source窗口（生成get、set方法，实现、覆盖接口或类的方法，很常用）
   Alt + Shift + D, J：如果有main方法入口，则以Debug方式执行代码
   Alt + Shift + X, J：如果有main方法入口，则以Run方式执行代码
 
 
   2. 插件推荐
   Eclipse默认情况下是一个纯净版的，所以功能简单，而开源IDE最为强大的莫过于各种插件，通过使用插件可以帮助我们减少大量编写代码的工作量，
   也帮助我们降低了编写代码的难度，所以懂得安装必要插件，也是熟练使用IDE的鉴证。
   ① hibernate Tools
   Hibernate Tools是一套全新而且完整的面向Hibernate3的工具集合，它包含了Eclipse插件和Ant编译流程，是JBoss Tools的核心组件。使用该插件能大大减少我们
   使用Hibernate的工作量，支持自动生成全部Hibernate的xml文件、javabean、HTML表单文件等。
   安装地址：http://download.jboss.org/jbosstools/updates/development/indigo/
   ② spring IDE
   Spring IDE是Spring官方网站推荐的Eclipse插件，可提供在开发Spring时对Bean定义文件进行提示、验证并以可视化的方式查看各个Bean之间
   的依赖关系等，对基于spring框架的项目开发提供了有力的支持。
   安装地址：http://dist.springsource.com/release/TOOLS/update/e3.6/
   ③ Subclipse
   Subclipse是基于Eclipse的SVN插件，支持所有版本的Eclipse，团队开发必备插件。
   安装地址：http://subclipse.tigris.org/update_1.8.x
   ④ Findbugs
   FindBugs是一个能静态分析源代码中可能会出现Bug的Eclipse插件工具。它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。
   利用这个工具，就可以在不实际运行程序的情况对软件进行分析。它可以帮助改进代码的质量。
   安装地址：http://findbugs.cs.umd.edu/eclipse/
   ⑤ Sysdeo Tomcat Launcher Plugin
   Sysdeo Tomcat Launcher Plugin是Tomcat的Eclipse插件，帮助我们自动部署tomcat服务器。该插件不是必要插件，可以不装。
   下载地址：http://www.eclipsetotale.com/tomcatPlugin/tomcatPluginV33.zip
 
   插件安装方法
   插件大概有三种安装方法：
   第一种：知道在线安装地址。Eclipse→Help→Install New Software...→地址栏（Work with）中输入安装地址→
   勾选要安装的插件→Next→同意安装协议→Finish→等待安装完毕→按要求重启Eclipse
   第二种：手动从官网下载好插件并手动与Eclipse集成。这种方法一般的思路是：先关闭Eclipse，然后将下载好的插件解压后，复制到Eclipse安装目
   录下的plugins文件夹和features文件夹下，如果必要的话再创建一个link文件，再重新打开Eclipse。
   第三种：在线搜索安装。Eclipse→Help→Eclipse Marketplace...→在搜索栏输入要查找的插件→点击Install按钮→等待安装完毕→按要求重启Eclipse
   这里笔者推荐第一种，如果不知道安装地址，那么就用第三种，第二种方法有时操作错误的话就会出现问题，风险较大，所以不推荐。
 
   3. tomcat
   ① 配置
   Window→Preferences→Server→Runtime Environment→Add→Apache→选择tomcat版本→Next→更改显示名称（Name）
   →Browse...浏览选择事先解压好的tomcat文件夹→选择jre→Finish→OK→打开Servers窗体→右击选择New→Server→选择tomcat版本→
   选择刚配置好的tomcat→Next→选择项目→Finish
   ② 使用心得
   当我们修改某处代码后，启动tomcat发现页面没有变化时，要先关掉tomcat，右击Servers窗口中tomcat服务器图标，选择Clean...
   来清理下编译后的源码，再启动tomcat来重新编译下源码。
   而且如果部署多个，或tomcat异常时，右击Servers窗口中tomcat服务器图标，选择Properties，检查General选项右侧Location是否正确，
   如果不正确则点击Switch Location。
   虽然一个tomcat支持同时启动多个项目，但项目多启动时会很慢，所以如果不是工程项目需要的话，建议tomcat只部署启动一个项目，将暂时无用的项目移除。
   当web项目启动加载时间过长导致tomcat启动失败的话，可适当延长tomcat启动超时的时间（默认45秒），双击Servers窗口中tomcat
   服务器打开tomcat属性窗口，点击右上方Timeouts选项，修改Start(in seconds)的时间。
   eclipse默认情况下是调用tomcat接口模拟启动tomcat，而不是真正启动tomcat，所以大家经常会遇到一件怪事：启动tomcat后，虽然能正常进web项目首页，
   却仅不了tomcat小猫首页（即http://localhost:8080/），并且web项目部署编译后生成的文件也不在tomcat文件目录下的work目录下。
   解决办法：如果tomcat服务器下已经部署了项目，就先要将其全部移除，即右击Servers窗口中tomcat服务器图标，选择Add and Remove...，
   单击Remove All按钮，单击Finish按钮。之后先Clean清理下，再双击tomcat服务器图标打开属性窗口，选择左侧中间Server Locations选项，
   选择下方第二个单选按钮（Use Tomcat installation），并将Deploy path文本框中的"wtpwebapps"（默认值）改为webapps，也就是tomcat中发布
   项目所在的文件夹名字，最好再将项目重新部署到tomcat上，启动tomcat后，就可以看到熟悉的小猫页面了，同时在tomcat文件目录下的work文件夹下也能
   看见熟悉的编译后的页面文件了。
   如果代码出现引入javax.servlet.http.*报错，说明是缺少tomcat的jar包，引入即可。方法：在左侧资源管理器右击项目，选择Build Path下的
   Configure Build Path...，右侧点击Add Library...按钮，选择Server Runtime，点击Next后选择tomcat，Finish。
 
   4. eclipse常见配置
   ● 字体大小
   Window→Preferences→General→Appearance→Colors and Fonts→右侧窗口→Basic选项→双击Text Font
   ● 修改打开文件的编辑浏览器
   Window→Preferences→General→Editors→File Associations→选择要修改的文件类型→在下方选择编辑浏览器
   ● 显示/隐藏代码行号
   Window→Preferences→General→Editors→勾选Show line numbers
   ● 添加自定义jar包Libraries
   Window→Preferences→Java→Build Path→User Libraries→右侧点击New...→输入名称→点击Add JARs...→浏览选择相应的jar文件
   ● 配置tomcat等服务器
   Window→Preferences→Server→Runtime Environment→Add...→选择需要的服务器（以tomcat为例请见上面tomcat配置）
   ● 修改格式化代码的换行判定
   Window→Preferences→Java→Code Style→Formatter→右侧点击New...→输入名称→点击OK→在弹出的窗口选择Line Wrapping选项卡→修改Maixmum line width文本框的值（默认80）
   ● 添加xml的dtd、xsd等xml语法规则文件，实现代码自动提示
   Window→Preferences→XML→XML Catalog→右侧点击Add...→Key type选择Public ID→Location浏览选择你所下载的DTD文件的物理位置→Key填入xml文档头部 <!DOCTYPE sqlMapConfig PUBLIC 后面的那些url地址→OK
   ● 修改编码格式
   右击你要修改的项目/包/类→选择Properties→在Resource选项右侧的Text file encoding下选择你需要的编码格式
   ● 相同名称（包括类名、方法名、变量名等等）以不同背景色标识出来
   见下图：

   或者按快捷键：Alt + Shift + O
 
   在Window→Preferences下有许多配置，这里并不可能介绍很全，所以只列出最为常用的，大家有时间可能多进这里看看，再多点点多试试就明白了。
 
 
   5. SVN
   ● 上传项目至SVN服务器
   右击要上传的项目→Team→Share Project...→SVN→创建新的资源库位置/使用现有的资源库→Next→（输入URL地址）→Next→使用项目名称作为文件夹名→Next→Finish→（输入用户名/密码）
   注意："使用项目名称作为文件夹名"时，要保证SVN服务器端已创建与项目名称相同的文件夹，否则会导入失败。如果SVN端创建的文件夹名与项目名称不符，则在该步骤选择"使用指定的模块名"以确保SVN服务器端与项目名称一致。
   ● 下载项目从SVN服务器
   在资源管理器空白处右击→Import...→选择SVN文件夹→从SVN检出项目→创建新的资源库位置/使用现有的资源库→Next→（输入URL地址）→Next→做为新项目检出，并使用新建项目向导进行配置→Finish→Yes→配置新建项目（如输入项目名称）→OK
   注意：这个"输入URL地址"与上面上传项目的不同，这个URL地址需要输入项目具体所在的文件夹，而上一个因为有"使用项目名称作为文件夹名"这步，所以不需要带文件夹名称。
   ● 提交、更新、还原文件
   选中需要提交的文件、jar包、javabean等文件然后右击→Team→选择相应的操作。（这个基本地球人看看都会，所以就不多说了）
** xclip 独立剪切板
*** 保存到内部剪切板
   ls -al | xclip
*** 文件内容 到剪切板中
   xclip /etc/apt/sources.list
*** 输出到系统剪切板
   xclip -o
   
** 文件系统
*** umount 用于卸载已经加载的文件系统
*** mount 用于加载文件系统到指定的加载点
    mount  [-t vfstype] [-o options] device dir
    1.-t vfstype 文件系统类型
    　　光盘或光盘镜像：iso9660
    　　DOS fat16文件系统：msdos
    　　Windows 9x fat32文件系统：vfat
    　　Windows NT ntfs文件系统：ntfs
    　　Mount Windows文件网络共享：smbfs
    　　UNIX(LINUX) 文件网络共享：nfs
    2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
    　　loop：用来把一个文件当成硬盘分区挂接上系统
    　　ro：采用只读方式挂接设备
    　　rw：采用读写方式挂接设备
    　　iocharset：指定访问文件系统所用字符集,不能显示中文 iocharset=cp936
    3.device 要挂接(mount)的设备。
    4.dir设备在系统上的挂接点(mount point)。
    sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览windows 共享文件夹
** 搜索
*** grep 文本搜索
     -C 5 foo file  显示file文件中匹配foo字串那行以及上下5行
     -B 5 foo file  显示foo及前5行
     -A 5 foo file  显示foo及后5行
     －c：只输出匹配行的计数。
     －I：不区分大 小写(只适用于单字符)。
     －h：查询多文件时不显示文件名。
     －l：查询多文件时只输出包含匹配字符的文件名。
     －n：显示匹配行及 行号。
     －s：不显示不存在或无匹配文本的错误信息。
     －v：显示不包含匹配文本的所有行。
     pattern正则表达式主要参数：
     \： 忽略正则表达式中特殊字符的原有含义。
     ^：匹配正则表达式的开始行。
     $: 匹配正则表达式的结束行。
     \<：从匹配正则表达 式的行开始。
     \>：到匹配正则表达式的行结束。
     [ ]：单个字符，如[A]即A符合要求 。
     [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
     .：所有的单个字符。
     $ grep ‘test’ d*
     显示所有以d开头的文件中包含 test的行。
     $ grep ‘test’ aa bb cc
     显示在aa，bb，cc文件中匹配test的行。
     $ grep ‘[a-z]\{5\}’ aa
     显示所有包含每个字符串至少有5个连续小写字符的字符串的行。
     $ grep ‘w\(es\)t.*\1′ aa
     如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用"\"号进行转义，直接写成’w(es)t.*\1′就可以了。

     grep命令使用复杂实例
     假设您正在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件：
     $ grep magic /usr/src/Linux/Doc/*
     sysrq.txt:* How do I enable the magic SysRQ key?
     sysrq.txt:* How do I use the magic SysRQ key?
     其中文件’sysrp.txt’包含该字符串，讨论的是 SysRQ 的功能。
     默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：
     grep: sound: Is a directory
     这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：
     明确要求搜索子目录：grep -r
     或忽略子目录：grep -d skip
     如果有很多 输出时，您可以通过管道将其转到’less’上阅读：
     $ grep magic /usr/src/Linux/Documentation/* | less
     这样，您就可以更方便地阅读。

     -q 静静地 ，存在则返回 0, 不存在返回 1
     下面还有一些有意思的命令行参数：
     grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
     grep -l pattern files ：只列出匹配的文件名，
     grep -L pattern files ：列出不匹配的文件名，
     grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
     grep -C number pattern files ：匹配的上下文分别显示[number]行，
     grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，
     grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
     grep -n pattern files  即可显示行号信息
     grep -c pattern files  即可查找总行数

*** find 
    pathname -options [-print -exec -ok ...]
    关系操作
    -a and
    -or -o or
    -n not 
     : -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
     : -ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
     : -name   按照文件名查找文件。
     : -perm   按照文件权限来查找文件。
     : -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
     : -user   按照文件属主来查找文件。
     : -group  按照文件所属的组来查找文件。
     : -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距
     : 现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。
     : -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
     : -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
     : -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。
     : -iname 忽略大小写
**** -type  查找某一类型的文件，诸如：
     + b - 块设备文件。
     + d - 目录。
     + c - 字符设备文件。
     + p - 管道文件。
     + l - 符号链接文件。
     + f - 普通文件。
**** -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
**** -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
**** -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。
**** -mount：在查找文件时不跨越文件系统mount点。
**** -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
**** -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。
**** time
     : -amin n   查找系统中最后N分钟访问的文件  -n n天以内;+n n天之前
     : -atime n  查找系统中最后n*24小时访问的文件
     : -cmin n   查找系统中最后N分钟被改变文件状态的文件
     : -ctime n  查找系统中最后n*24小时被改变文件状态的文件
     : -mmin n   查找系统中最后N分钟被改变文件数据的文件
     : -mtime n  查找系统中最后n*24小时被改变文件数据的文件
     : find  ./    -mtime    -1    -type f    -ok   ls -l    {} \;  
     : find .    -perm -007    -exec ls -l {} \;  
     : ! 否定参数
*** whereis 查找二进制程序、代码等相关文件路径
** 编辑
*** sed 命令编辑器
**** 选项 
     sed [options] 'command' file(s)
     sed [options] -f scriptfile file(s)
     -e<script>或--expression=<script>：以选项中的指定的script来处理输入的文本文件；
     -f<script文件>或--file=<script文件>：以选项中指定的script文件来处理输入的文本文件；
**** 功能
     a\ 在当前行下面插入文本。
     i\ 在当前行上面插入文本。
     c\ 把选定的行改为新的文本。
     d 删除，删除选择的行。
     D 删除模板块的第一行。
     s 替换指定字符 sed 's/aa/bb/' file 注意/ 符,用来分界
     h 拷贝模板块的内容到内存中的缓冲区。
     H 追加模板块的内容到内存中的缓冲区。
     g 获得内存缓冲区的内容，并替代当前模板块中的文本。
     G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
     l 列表不能打印字符的清单。
     n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
     N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
     p 打印模板块的行。(显示两遍)
     P(大写) 打印模板块的第一行。
     q 退出Sed。
     b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
     r file 从file中读行。
     t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
     T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
     w file 写并追加模板块到file末尾。  
     W file 写并追加模板块的第一行到file末尾。  
     ! 表示后面的命令对所有没有被选定的行发生作用。  
     = 打印当前行号码。  
     # 把注释扩展到下一个换行符以前。  

     sed替换标记
     g 表示行内全面替换。  
     p 表示打印行。  
     w 表示把行写入一个文件。  
     x 表示互换模板块中的文本和缓冲区中的文本。  
     y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
     \1 子串匹配标记
     & 已匹配字符串标记

     sed元字符集
     ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
     $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
     . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
     [* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
     [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  
     [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
     \(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
     & 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
     \< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
     \> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
     x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
     x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
     x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。 

**** sed用法实例
***** 替换：s
     sed 's/book/books/' file

     -n选项和p命令一起使用表示只打印那些发生替换的行：
     sed -n 's/test/TEST/p' file

     直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换
     为books：
     sed -i 's/book/books/g' file
***** 全面替换标记g
     sed 's/book/books/g' file
***** 替换1行中第N处匹配开始替换时，可以使用 /Ng：
     echo sksksksksksk | sed 's/sk/SK/2g'
     skSKSKSKSKSK
***** 使用定界符
     sed 's:test:TEXT:g'
     sed 's|test|TEXT|g'

     定界符出现在样式内部时，需要进行转义：
     sed 's/\/bin/\/usr\/local\/bin/g'

***** 删除操作：d命令
***** 删除空白行：
     sed '/^$/d' file

***** 删除文件的第2行：
     sed '2d' file
***** 删除文件的第2行到末尾所有行：
     sed '2,$d' file
***** 删除文件最后一行：
     sed '$d' file
***** 删除文件中所有开头是test的行：
     sed '/^test/'d file
***** 已匹配字符串标记&
     正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之
     前所匹配到的单词：

     echo this is a test line | sed 's/\w\+/[&]/g'
     [this] [is] [a] [test] [line]

     所有以192.168.0.1开头的行都会被替换成它自已加localhost：

     sed 's/^192.168.0.1/&localhost/' file
     192.168.0.1localhost
***** 子串匹配标记\1
     匹配给定样式的其中一部分：
     echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
     this is 7 in a number

     命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，\(..\)
     用于匹配子串，对于匹配到的第一个子串就标记为 \1，依此类推匹
     配到的第二个结果就是 \2，例如：

     echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
     BBB aaa

     love被标记为1，所有loveable会被替换成lovers，并打印出来：

     sed -n 's/\(love\)able/\1rs/p' file
***** 组合多个表达式
     sed '表达式' | sed '表达式'

     等价于：

     sed '表达式; 表达式'

     引用

     sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字
     符串，就需要使用双引号。

     test=hello
     echo hello WORLD | sed "s/$test/HELLO"
     HELLO WORLD

     选定行的范围：,（逗号）

     所有在模板test和check所确定的范围内的行都被打印：

     sed -n '/test/,/check/p' file

     打印从第5行开始到第一个包含以test开始的行之间的所有行：

     sed -n '5,/^test/p' file

     对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：

     sed '/test/,/west/s/$/aaa bbb/' file

     多点编辑：e命令

     -e选项允许在同一行里执行多条命令：

     sed -e '1,5d' -e 's/test/check/' file

     上面sed表达式的第一条命令删除1至5行，第二条命令用check替换
     test。命令的执行顺序对结果有影响。如果两个命令都是替换命令
     ，那么第一个替换命令将影响第二个替换命令的结果。

     和 -e 等价的命令是 --expression：

     sed --expression='s/test/check/' --expression='/love/d' file

     从文件读入：r命令

     file里的内容被读进来，显示在与test匹配的行后面，如果匹配多
     行，则file的内容将显示在所有匹配行的下面：

     sed '/test/r file' filename

     写入文件：w命令  

     在example中所有包含test的行都被写入file里：

     sed -n '/test/w file' example

     追加（行下）：a\命令

     将 this is a test line 追加到以test 开头的行后面：

     sed '/^test/a\this is a test line' file

     在 test.conf 文件第2行之后插入 this is a test line：

     sed -i '2a\this is a test line' test.conf

     插入（行上）：i\命令

     将 this is a test line 追加到以test开头的行前面：

     sed '/^test/i\this is a test line' file

     在test.conf文件第5行之前插入this is a test line：

     sed -i '5i\this is a test line' test.conf

     下一个：n命令

     如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变
     为bb，并打印该行，然后继续：

     sed '/test/{ n; s/aa/bb/; }' file

     变形：y命令

     把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使
     用这个命令：

     sed '1,10y/abcde/ABCDE/' file

     退出：q命令

     打印完第10行后，退出sed

     sed '10q' file

     保持和获取：h命令和G命令

     在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓
     冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将
     打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。

     sed -e '/test/h' -e '$G' file

     在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将
     其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的
     意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它
     放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾
     。在这个例子中就是追加到最后一行。简单来说，任何包含test的
     行都被复制并追加到该文件的末尾。

     保持和互换：h命令和x命令

     互换模式空间和保持缓冲区的内容。也就是把包含test与check的行
     互换：

     sed -e '/test/h' -e '/check/x' file

     脚本scriptfile

     sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名
     。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空
     白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行
     为注释行，且不能跨行。

     sed [options] -f scriptfile file(s)

     打印奇数行或偶数行

     方法1：

     sed -n 'p;n' test.txt  #奇数行
     sed -n 'n;p' test.txt  #偶数行

     方法2：

     sed -n '1~2p' test.txt  #奇数行
     sed -n '2~2p' test.txt  #偶数行

     打印匹配字符串的下一行

     grep -A 1 SCC URFILE
     sed -n '/SCC/{n;p}' URFILE
     awk '/SCC/{getline; print}' URFILE
**** 修改 更改 
*** emacs 可视化编辑器
*** join 行号及行内文本同，则显示
    按两个文件的相同字段合并
*** tr 替换或删除字符
** 聊天
*** IRC
  /server irc.debian.org
  /join #debian
  /part #debian  离开
  /quit
  要给 foo 发送一条内容为 "Hello Mr. Foo"的私人消息,请输入
  /msg foo Hello Mr. Foo
**** irc 频道
     #linuxba 国内linux贴吧
     #c_lang_cn C语言中文irc频道
     ##g讲到这里，必须得推广下自己的频道，##g，作为一个大水比，同时也是小白，
     #archlinux-cn 
     #emacs
     #orz
     #debiancn
     #kali
     #osdev 操作系统开发频道
** 数据库
*** mysql 
***** 导出
      1、导出数据和表结构：
      mysqldump -u用户名 -p密码 数据库名 > 数据库名.sql
      #/usr/local/mysql/bin/   mysqldump -uroot -p abc > abc.sql
      
      2、只导出表结构
      mysqldump -u用户名 -p密码 -d 数据库名 > 数据库名.sql
      #/usr/local/mysql/bin/   mysqldump -uroot -p -d abc > abc.sql

***** 导入    

      1、首先建空数据库
mysql>create database abc;

2、导入数据库
方法一：
（1）选择数据库
mysql>use abc;
（2）设置数据库编码
mysql>set names utf8;
（3）导入数据（注意sql文件的路径）
mysql>source /home/abc/abc.sql;
方法二：
mysql -u用户名 -p密码 数据库名 < 数据库名.sql
#mysql -uabc_f -p abc < abc.sql

建议使用第二种方法导入。

** ssh
1、复制SSH密钥到目标主机，开启无密码SSH登录
ssh-copy-id user@host
如果还没有密钥，请使用ssh-keygen命令生成。

2、从某主机的80端口开启到本地主机2001端口的隧道
ssh -N -L2001:localhost:80 somemachine
现在你可以直接在浏览器中输入http://localhost:2001访问这个网站。

3、将你的麦克风输出到远程计算机的扬声器
dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp
这样来自你麦克风端口的声音将在SSH目标计算机的扬声器端口输出，但遗憾的是，声音质量很差，你会听到很多嘶嘶声。

4、比较远程和本地文件
ssh user@host cat /path/to/remotefile | diff /path/to/localfile –
在比较本地文件和远程文件是否有差异时这个命令很管用。

5、通过SSH挂载目录/文件系统
sshfs name@server:/path/to/folder /path/to/mount/point
从http://fuse.sourceforge.net/sshfs.html下载sshfs，它允许你跨网络安全挂载一个目录。

6、通过中间主机建立SSH连接
ssh -t reachable_host ssh unreachable_host
Unreachable_host表示从本地网络无法直接访问的主机，但可以从reachable_host所在网络访问，这个命令通过到reachable_host的"隐藏"连接，创建起到unreachable_host的连接。

7、将你的SSH公钥复制到远程主机，开启无密码登录 – 简单的方法
ssh-copy-id username@hostname

8、直接连接到只能通过主机B连接的主机A
ssh -t hostA ssh hostB
当然，你要能访问主机A才行。

9、创建到目标主机的持久化连接
ssh -MNf <user>@<host>
在后台创建到目标主机的持久化连接，将这个命令和你~/.ssh/config中的配置结合使用：

Host host
ControlPath ~/.ssh/master-%r@%h:%p
ControlMaster no

所有到目标主机的SSH连接都将使用持久化SSH套接字，如果你使用SSH定期同步文件（使用rsync/sftp/cvs/svn），这个命令将非常有用，因为每次打开一个SSH连接时不会创建新的套接字。

10、通过SSH连接屏幕
ssh -t remote_host screen –r
直接连接到远程屏幕会话（节省了无用的父bash进程）。

11、端口检测（敲门）
knock <host> 3000 4000 5000 && ssh -p <port> user@host && knock <host> 5000 4000 3000
在一个端口上敲一下打开某个服务的端口（如SSH），再敲一下关闭该端口，需要先安装knockd，下面是一个配置文件示例。

[options]
logfile = /var/log/knockd.log
[openSSH]
sequence = 3000,4000,5000
seq_timeout = 5
command = /sbin/iptables -A INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPT
tcpflags = syn
[closeSSH]
sequence = 5000,4000,3000
seq_timeout = 5
command = /sbin/iptables -D INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPT
tcpflags = syn

12、删除文本文件中的一行内容，有用的修复
ssh-keygen -R <the_offending_host>
在这种情况下，最好使用专业的工具。

13、通过SSH运行复杂的远程shell命令
ssh host -l user $(<cmd.txt)

更具移植性的版本：
ssh host -l user "`cat cmd.txt`"

14、通过SSH将MySQL数据库复制到新服务器
mysqldump –add-drop-table –extended-insert –force –log-error=error.log -uUSER -pPASS OLD_DB_NAME | ssh -C user@newhost "mysql -uUSER -pPASS NEW_DB_NAME"

通过压缩的SSH隧道Dump一个MySQL数据库，将其作为输入传递给mysql命令，我认为这是迁移数据库到新服务器最快最好的方法。

15、删除文本文件中的一行，修复"SSH主机密钥更改"的警告
sed -i 8d ~/.ssh/known_hosts

16、从一台没有SSH-COPY-ID命令的主机将你的SSH公钥复制到服务器
cat ~/.ssh/id_rsa.pub | ssh user@machine "mkdir ~/.ssh; cat >> ~/.ssh/authorized_keys"
如果你使用Mac OS X或其它没有ssh-copy-id命令的*nix变种，这个命令可以将你的公钥复制到远程主机，因此你照样可以实现无密码SSH登录。

17、实时SSH网络吞吐量测试
yes | pv | ssh $host "cat > /dev/null"

通过SSH连接到主机，显示实时的传输速度，将所有传输数据指向/dev/null，需要先安装pv。
如果是Debian：
apt-get install pv

如果是Fedora：
yum install pv
（可能需要启用额外的软件仓库）。

18、如果建立一个可以重新连接的远程GNU screen
ssh -t user@some.domain.com /usr/bin/screen –xRR

人们总是喜欢在一个文本终端中打开许多shell，如果会话突然中断，或你按下了"Ctrl-a d"，远程主机上的shell不会受到丝毫影响，你可以重新连接，其它有用的screen命令有"Ctrl-a c"（打开新的shell）和"Ctrl-a a"（在shell之间来回切换），请访问http://aperiodic.net/screen/quick_reference阅读更多关于screen命令的快速参考。

19、继续SCP大文件
rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file

它可以恢复失败的rsync命令，当你通过VPN传输大文件，如备份的数据库时这个命令非常有用，需要在两边的主机上安装rsync。

rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file local -> remote

或

rsync –partial –progress –rsh=ssh $user@$host:$remote_file $destination_file remote -> local

20、通过SSH W/ WIRESHARK分析流量
ssh root@server.com ‘tshark -f "port !22″ -w -' | wireshark -k -i –

使用tshark捕捉远程主机上的网络通信，通过SSH连接发送原始pcap数据，并在wireshark中显示，按下Ctrl+C将停止捕捉，但也会关闭wireshark窗口，可以传递一个"-c #"参数给tshark，让它只捕捉"#"指定的数据包类型，或通过命名管道重定向数据，而不是直接通过SSH传输给wireshark，我建议你过滤数据包，以节约带宽，tshark可以使用tcpdump替代：

ssh root@example.com tcpdump -w – ‘port !22′ | wireshark -k -i –

21、保持SSH会话永久打开
autossh -M50000 -t server.example.com ‘screen -raAd mysession’

打开一个SSH会话后，让其保持永久打开，对于使用笔记本电脑的用户，如果需要在Wi-Fi热点之间切换，可以保证切换后不会丢失连接。

22、更稳定，更快，更强的SSH客户端
ssh -4 -C -c blowfish-cbc
强制使用IPv4，压缩数据流，使用Blowfish加密。

23、使用cstream控制带宽
tar -cj /backup | cstream -t 777k | ssh host ‘tar -xj -C /backup’

使用bzip压缩文件夹，然后以777k bit/s速率向远程主机传输。Cstream还有更多的功能，请访问http://www.cons.org/cracauer/cstream.html#usage了解详情，例如：

echo w00t, i’m 733+ | cstream -b1 -t2

24、一步将SSH公钥传输到另一台机器
ssh-keygen; ssh-copy-id user@host; ssh user@host

这个命令组合允许你无密码SSH登录，注意，如果在本地机器的~/.ssh目录下已经有一个SSH密钥对，ssh-keygen命令生成的新密钥可能会覆盖它们，ssh-copy-id将密钥复制到远程主机，并追加到远程账号的~/.ssh/authorized_keys文件中，使用SSH连接时，如果你没有使用密钥口令，调用ssh user@host后不久就会显示远程shell。

25、将标准输入（stdin）复制到你的X11缓冲区
ssh user@host cat /path/to/some/file | xclip
你是否使用scp将文件复制到工作用电脑上，以便复制其内容到电子邮件中？xclip可以帮到你，它可以将标准输入复制到X11缓冲区，你需要做的就是点击鼠标中键粘贴缓冲区中的内容。

** softether vpn 客户端
    Please execute './vpnclient start' to run the SoftEther VPN Client Background Service.
    And please execute './vpncmd' to run the SoftEther VPN Command-Line Utility to configure SoftEther VPN Client.

  创建连接配置
  Create your connection setting using your assigned RapidVPN server details. Your file content must be similar to:
  #+BEGIN_SRC c++

  declare root
  {
  bool CheckServerCert false
  uint64 CreateDateTime 0
  uint64 LastConnectDateTime 0
  bool StartupAccount false
  uint64 UpdateDateTime 0
  declare ClientAuth
  {
  uint AuthType 1
  string Username rapidvpnusername
  }
  declare ClientOption
  {
  string AccountName rapidvpn1
  uint AdditionalConnectionInterval 1
  uint ConnectionDisconnectSpan 0
  string DeviceName se
  bool DisableQoS false
  bool HalfConnection false
  bool HideNicInfoWindow false
  bool HideStatusWindow false
  string Hostname x.x.x.x
  string HubName default
  uint MaxConnection 1
  bool NoRoutingTracking false
  bool NoTls1 false
  bool NoUdpAcceleration false
  uint NumRetry 4294967295
  uint Port 443
  uint PortUDP 0
  string ProxyName $
  byte ProxyPassword $
  uint ProxyPort 0
  uint ProxyType 0
  string ProxyUsername $
  bool RequireBridgeRoutingMode false
  bool RequireMonitorMode false
  uint RetryInterval 15
  bool UseCompress false
  bool UseEncrypt true
  }
  }

  #+END_SRC
  创建网卡
  VPN Client>remoteenable
  VPN Client>niccreate

  导入配置 VPN Client>accountimport
  配置连接名的密码 AccountUsernameSet rapidvpn1
  AccountPasswordSet rapidvpn1
  连接账号  accountconnect wum
  动态更新地址 #sudo dhclient vpn_se
  断开连接 accountdisconnect wum

  访问外网，则需要手动增加路由
  先配置 "/etc/sysctl.conf": #net.ipv4.ip_forward=1
**** 添加路由
  显示   route -n
  添加 sudo route add  -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.20.1 dev vpn_vpn_hua
  删除 route del -net  -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.20.1 dev vpn_vpn_hua

  ifup {interface}
  ifdown {interface}
** 触摸板和小红点
    关闭:sudo modprobe -r psmouse
    开启:sudo modprobe  psmouse
    只关闭触摸板: synclient touchpadoff=1
    开启:synclient touchpadoff=0
** 屏幕截图
  import -frame window.tif
*** shutter 
    1. 里面的快捷键命令用：shutter -s 或者shutter –select
    2. 截取当前活动窗口：shutter -a （a表示active）
    3. 截取拖拉区域：shutter -s （s是select之意），拖拉出矩形区域后按Enter。 

** 中文语音朗读ekho
** 网络
*** remmina 远程桌面
*** 无线网
   iwconfig ath0 essid lincoln 这样就意味着你正在加入一个ESSID为lincoln的无线网络
   nm-connection-editor
*** 网速 nload
*** 网络请求 
**** curl
     curl是一个命令行方式下传输数据的开源传输工具，支持多种协议：FTP、HTTP、HTTPS、IMAP、POP3、TELNET等，功能超级强大。
***** curl Post Json
      post  curl -i -X POST -H 'Content-type':'application/json' -d {"BTime":""$btime""} http://api.baidu.com
      $ curl -i -X POST -H "'Content-type':'application/x-www-form-urlencoded', 'charset':'utf-8', 'Accept': 'text/plain'" -d 'json_data={"a":"aaa","b":"bbb","data":[{"c":"ccc","d":"ddd","keywords":[{"e": "eee", "f":"fff", "g":"ggg"}]}]}' url
      返回信息：
     
      HTTP/1.1 200 OK
      Server: Apache-Coyote/1.1
      Set-Cookie: JSESSIONID=02565379F21852B33D0367FB7982FE1C; Path=/; HttpOnly
      Content-Type: application/json;charset=UTF-8
      Transfer-Encoding: chunked
      Date: Tue, 22 Oct 2013 10:48:24 GMT
     
      这里想要post Json数据到接口上，需要设置好Header，也就是：'Content-type':'application/x-www-form-urlencoded', 'charset':'utf-8', 'Accept': 'text/plain'。
      之前一直认为是设置好Content-Type=application/json即可，但是如果有中文就会遇到需要encode的地方了。
***** get 
      curl http://mywebsite.com/index.php?a=1&b=2&c=3
      $_GET只能获取到参数a
      由于url中有&，其他参数获取不到，在linux系统中& 会使进程系统后台运行
      必须对&进行下转义才能$_GET获取到所有参数

      curl http://mywebsite.com/index.php?a=1\&b=2\&c=3
      url 为 http://mywebsite.com/index.php?a=1&b=2&c=3
     
      或加“”
      curl  -s  "http://mywebsite.com/index.php?a=1&b=2&c=3"
***** POST提交    通过 --data/-d 方式指定使用POST方式传递数据
      curl  -d  'name=1&pagination=2' demoapp.sinap.com/worker.php
      demoapp.sinap.com 站点中的 worker.php 脚本，就能得到 $_POST['name'] 和 $_POST[''pagination] 对应的值     
***** curl获得网站信息的方法（ -s 表示静默  --head 表示取得head信息 ）
      curl  -s  --head  www.sina.com
***** 模拟form表单提交文件  --form/-F 模拟form表单提交文件
      curl -F "image=@./index.php"  www.learn.com/phptest/index.php
      "image=@./1.png"     image 相当于<input type='file' name='image'>中name的value   @后面是文件路径
*** 重启网络 
  sudo   /etc/init.d/networking restart
  systemctl status networking.server
*** 网络
  1. OSI七层网络模型
  　　TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，
  完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。
  　　1）物理层（Physical Layer）
  　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。
  物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。
  　　2）数据链路层（Data Link Layer）
  　　数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，
  数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；
  如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、
  维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
  　　有关数据链路层的重要知识点：
  　　1> 数据链路层为网络层提供可靠的数据传输；
  　　2> 基本数据单位为帧；
  　　3> 主要的协议：以太网协议；
  　　4> 两个重要设备名称：网桥和交换机。
  　　3）网络层（Network Layer）
  　　网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。
  如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。
  　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：
  无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。
  具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：
  　　1> 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；
  　　2> 基本数据单位为IP数据报；
  　　3> 包含的主要协议：
  　　IP协议（Internet Protocol，因特网互联协议）;
  　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;
  　　ARP协议（Address Resolution Protocol，地址解析协议）;
  　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。
  　　4> 重要的设备：路由器。
  　　4）传输层（Transport Layer）
  　　第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

  　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。
  　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。
  　　有关网络层的重点：
  　　1> 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；
  　　2> 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；
  　　3> 重要设备：网关。

  　　5）会话层
  　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
  　　6）表示层
  　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。

  　　7）应用层
  　　为操作系统或网络应用程序提供访问网络服务的接口。
  　　会话层、表示层和应用层重点：
  　　1> 数据传输基本单位为报文；
  　　2> 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。

  1. IP地址
  　　1）网络地址

  　　IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。

  　　2）广播地址

  　　广播地址通常称为直接广播地址，是为了区分受限广播地址。

  　　广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

  　　3）组播地址

  　　D类地址就是组播地址。

  　　先回忆下A，B，C，D类地址吧：

  　　A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)

  　　B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;

  　　C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。

  　　D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；

  　　E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。

  　　注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。

  　　4）255.255.255.255

  　　该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。

  　　注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。

  　　5）0.0.0.0

  　　常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。

  　　6）回环地址

  　　127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。

  　　7）A、B、C类私有地址

  　　私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。

  　　A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255

  　　B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255

  　　C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

  1. 子网掩码及网络划分
  　　随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。

  　　这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。

  　　什么是子网掩码？

  　　子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。

  　　在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。

  　　子网掩码的计算：

  　　对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。

  　　下面总结一下有关子网掩码和网络划分常见的面试考题：

  　　1）利用子网数来计算

  　　在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。

  　　(1) 将子网数目转化为二进制来表示;

  　　如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；

  　　(2) 取得该二进制的位数，为N；

  　　该二进制为五位数，N = 5

  　　(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。

  　　将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0

  　　2）利用主机数来计算

  　　如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：

  　　(1) 将主机数目转化为二进制来表示；

  　　700=1010111100；

  　　(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N<8。如果大于254，则 N>8，这就是说主机地址将占据不止8位；

  　　该二进制为十位数，N=10；

  　　(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。

  　　将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。

  　　3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。

  　　比如一个子网有10台主机，那么对于这个子网需要的IP地址是：

  　　10＋1＋1＋1＝13

  　　注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。

  　　因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。

  　　如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。

  回到顶部
  5. ARP/RARP协议
  　　地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。

  　　ARP工作流程举例：

  　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；
  　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；
  　　当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：
  　　（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
  　　（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。
  　　（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
  　　（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
  　　（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
  　　逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。

  　　RARP协议工作流程：

  　　（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；

  　　（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；

  　　（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
  　　（4）如果不存在，RARP服务器对此不做任何的响应；
  　　（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。
  回到顶部
  6. 路由选择协议
  　　常见的路由选择协议有：RIP协议、OSPF协议。

  　　RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。

  　　OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
  回到顶部
  7. TCP/IP协议
  　　TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。
  　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。
   　　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

  　　TCP报文首部格式：



  　　TCP协议的三次握手和四次挥手：
  　　TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

  　　TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

  　　为什么要三次挥手？

  　　在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

  　　为什么要四次挥手？

  　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

  　　使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。
  1. UDP协议　
  　　UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。
  　　UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。
  　　每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：
  　　（1）源端口号；
  　　（2）目标端口号；
  　　（3）数据报长度；
  　　（4）校验值。
  　　使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。
  　　TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。
  回到顶部
  9. DNS协议
  　　DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。
  回到顶部
  10. NAT协议
  　　NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

  回到顶部
  11. DHCP协议
  　　DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

  回到顶部
  12. HTTP协议
  　　超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
  　　HTTP 协议包括哪些请求？

  　　GET：请求读取由URL所标志的信息。

  　　POST：给服务器添加信息（如注释）。

  　　PUT：在给定的URL下存储一个文档。

  　　DELETE：删除给定的URL所标志的资源。

  　　HTTP 中， POST 与 GET 的区别

  　　1）Get是从服务器上获取数据，Post是向服务器传送数据。

  　　2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。

  　　3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。

  　　4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

  　　I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

  　　II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。

  回到顶部
  13. 一个举例
  　　在浏览器中输入 www.baidu.com  后执行的全部过程

  　　现在假设如果我们在客户端（客户端）浏览器中输入http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：

  　　1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。

  　　2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。

  　　3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

  　　4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。
*** Wget实现整站下载
**** 下载整站数据，只需一条简单的命令：
  #下面的命令会在终端所在目录创建一个www.qingsword.com目录，将网站www.qingsword.com上的数据全部下载到这个目录中
  qing@qingsword.com$ wget -rck -np www.qingsword.com
  #对应参数解释：
  #-r，递归下载
  #-c，断点续传，若网站长时间未响应或中途断开，此参数可以让数据断点续传
  #-k，转换链接为本地链接
  #-np，--no-parent不追溯至父级
**** 仅下载指定后缀的文件
  #参数-A指定，仅下载png与css后缀的文件，网站中其他类型的文件将不会被下载
  qing@qingsword.com$ wget -rck -np -A '*.png','*.css' www.qingsword.com
**** 不下载指定后缀的文件
  #参数-R指定，除了html以及css后缀的文件外，下载其余所有文件
  qing@qingsword.com$ wget -rck -np -R '*.html','*.css' www.qingsword.com
*** server
    按照man service的说明, service本身是个命令, 这个service命令是用来启动service服务的, 其语法格式为:
    service SCRIPT COMMAND [OPTIONS]
    其解释为: service运行一个位于/etc/init.d/下的脚本SCRIPT, 或者是一个位于/etc/init下upstart程序. upstart是ubuntu中用来代替以前的sysvinit的启动程序(笔者猜测可能是由于以前svsvinit中叫做startup, 所以现在较upstart).
    本文先介绍/etc/init.d下的服务, 说明一下怎么手动的添加一个服务, 并且让它自启动(如果你需要的话). 本文这是简单并且直观的介绍一下service, 并不一定所有概念都准确, 如果读者想要更加准确的概念和更加全面的方法, 可以网上自己搜, 遍地都是.
**** 手动添加一个服务
     基于上面的解释, 其实添加一个服务很简单, 只需要添加一个脚本到/etc/init.d/并赋予它可执行权限即可. 如:

  sudo touch /etc/init.d/hello
  chmod +x /etc/init.d/hello
  这是ubuntu就认为有个叫hello的服务了. 可以试试键入sudo service hell 再敲TAB键, 这时候应该就可以tab出来hello了, 这说明系统已经识别出来它是一个服务了.
   如果此时报错: hello.service not found, 则可能需要执行一下:

  sudo update-rc.d hello defaults
  下面来测试一下, 在hello中加入一行:

  #!/bin/bash
  echo "hello"
  第一行的"#!/bin/bash"一定要有, 否则有可能会报错.

  然后运行命令:

  sudo service hello start
  这时便会打印输出hello(如果没有打印可以尝试用sudo systemctl status sss.service查看). 如果hello中的命令为echo "hello" $1, 则会打印hello start. 可见, 我们平时输入的sudo service xxx start中的start, 也就是man中说的COMMAND, 只不过是service传给xxx服务的第一个参数而已.

  至此, 我们已经有了一个可以简单显示hello的服务, 但是它不会自动启动, 这就如前文所说的, 服务不一定非要随开机自启动的. 后文会介绍如何添加自启动.

  3 service start / stop
  下面我们介绍如何添加service的start / stop等, 其实很简单, 只需要在上文所建的/etc/init.d/hello加入:

  case "$1" in
      start)
          echo start
          ;;
      stop)
          echo stop
          ;;
      restart)
          echo restart
          ;;
  esac
  在对应的case中进行想要的工作即可.

**** 4 控制服务的自启动
  4.1 说明
  简单的说, 要让服务的自启动, 只需要在/etc/rc{RUNLEVEL}.d/中加入S12ServiceName的软链接, 指向/etc/init.d中对应的脚本(如本文的hello). 这里先且看说明, 稍后会介绍方法而不用手动一个个的添加:

  说明:

  S12ServiceName中:
  表示该服务随启动自动启动, 如果是K, 则表示Kill(杀死进程);
  12表示优先级, 数越小, 越是先执行.
  ServiceName即服务名, 起始叫什么都行, 真正起作用的是软链接的目标, 不过一般最好与服务同名.
  其中的RUNLEVEL为系统的运行级别, 一般的linux分8个级别: 0-6和一个'S'级别.
  0代表关机(halt);
  6代表重启(restart);
  1级别是单用户模式(single),
  2-5各有不同. 但是在userlinux(包括ubuntu)中2-5级别是毫无差别的.
  'S'级别是一个比较特殊的级别, 他应该是先于其他级别运行的级别(这一点有待考证).
  这里说明一下, 0-6级别的运行是互斥的, 而不是叠加运行, 也就是说如果进入(move into)4级别, 不是指0-3都要运行, 而只是完成4级别里所规定的服务.

  如果要查看系统当前的运行级别可以使用命令:

  runlevel
  显示的数字就是当前运行级别, 一般ubuntu桌面版在我们平时使用时进入的应该是level 2.

**** 4.2 使用update-rc.d添加自启动
  虽然可以按照上文方法来手动添加, 但是更简单的是使用update-rc.d命令来添加. 如:

  sudo update-rc.d hello defaults
  如果要删除这个服务, 则:

  sudo update-rc.d hello remove
  可以看到, 运行添加时, 终端会显示:

  update-rc.d: warning: /etc/init.d/hello missing LSB information
  update-rc.d: see <http://wiki.debian.org/LSBInitScripts>
   Adding system startup for /etc/init.d/hello ...
     /etc/rc0.d/K20hello -> ../init.d/hello
     /etc/rc1.d/K20hello -> ../init.d/hello
     /etc/rc6.d/K20hello -> ../init.d/hello
     /etc/rc2.d/S20hello -> ../init.d/hello
     /etc/rc3.d/S20hello -> ../init.d/hello
     /etc/rc4.d/S20hello -> ../init.d/hello
     /etc/rc5.d/S20hello -> ../init.d/hello
  然后就可以看到在上述列表中的各个级别下, 创建了对应的软链接.

  remove方法如果/etc/init.d/脚本还存在, 则需要使用-f参数:

  sudo update-rc.d -f hello remove
  这样会删除各个软链接, 但是并不会删除/etc/init.d/下的脚本本身.
*** samba
**** samba方式
  yum install samba-client.x86_64 #安装samba客户端
  smbclient //192.168.211.1/test_samba    #通过samba打开windows共享目录
  smbclient //192.168.1.1/smb_share/ -U smb_user  #系统提示输入smb_user_passwd
  smbclient //192.168.1.1/smb_share/ smb_user_passwd -U smb_user  #不提示输入密码
  出现提示符： 
  smb: >

  get下载文件

  put上传文件

  cd 切换windows目录

  lcd 切换本地目录

  help显示帮助

  ? 显示帮助

  ! 表示执行liunx本地的命令，如:!ls显示本地目录下的内容

  smb命令	说明	–
  ?或help [command]	提供关于帮助或某个命令的帮助	
  ![shell command]	执行所用的SHELL命令，或让用户进入 SHELL提示符	–
  cd [目录]	切换到服务器端的指定目录，如未指定，则 smbclient 返回当前本地目录	
  lcd [目录]	切换到客户端指定的目录	
  dir 或ls	列出当前目录下的文件；	
  exit 或quit	退出smbclient	
  get file1 [file2]	从服务器上下载file1，并以文件名file2存在本地机上；如果不想改名，可以把file2省略	
  mget file1 file2 file3 filen	从服务器上下载多个文件；	
  md或mkdir 目录	在服务器上创建目录	
  rd或rmdir 目录	删除服务器上的目录	
  put file1 [file2]	向服务器上传一个文件file1,传到服务器上改名为file2；	
  mput file1 file2 filen	向服务器上传多个文件	
  –	–	–
  mount方式
  yum install cifs-utils #安装cifs工具包 （用于取代被淘汰的smbfs）

  #首先创建被挂载的目录：
  $ mkdir windows

  #将共享文件夹挂载到windows文件夹：
  $ sudo mount -t cifs -o username=share,password=share //192.168.66.198/share ./windows

  mkdir /mnt/挂载点名称 #（创建一个挂载点）
  vi /etc/fstab #添加以下内容让操作系统启动后自动挂载windows机器上的共享文件夹到挂载点

  1
  //你的windows机器名/共享文件夹名 /mnt/你创建的挂载点 cifs rw,credentials=/etc/.smbpasswd 0 0

  mount -a #（让系统重新挂载所有在/etc/fstab文件里面定义的挂载点）
  cd /mnt/挂载点名称 #（进入windows机器上的共享文件夹）
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11
  12
  13
  14
  15
  16
  其中几个参数表示含义：

  –	–
  cifs	Common Internet File System，可以理解为网络文件系统
  usrname	访问共享文件夹的用户名
  password	访问密码
  //192.168.66.198/share	表示网络文件夹的地址，注意这里最后不能加/，如果是//192.168.66.198/share/则会报如下错误：mount: //192.168.66.198/share/ is not a valid block device
  Tips：使用mount挂载的方法在系统重新启动后就会失效，如果希望开机时自动挂载，将下面设置加入/etc/fstab文件最后面就可以了。

  SSH方式
  假设A机(有shell环境，linux或win下安装cygwin)想要无密码访问B机（linux），则进行如下步骤 
  1、在A机用ssh-keygen生成公钥私钥（-t RSA即可） 
  2、在A机用ssh-copyid将公钥发给B机并完成配置（用ssh-copyid要比手工配置ssh目录方便很多） 
  3、ssh username@b.ip 测试是否正常 
  4、scp 开始使用

  FTP方式
  [待补充]
**** smb
***** 安装:
      sudo apt-get insall samba
      sudo apt-get install smbfs
***** 创建共享目录:
  mkdir /home/phinecos/share
  sudo chmod 777 /home/phinecos/share
***** 创建Samba配置文件:
  保存现有的配置文件
  sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak

  修改现配置文件
  sudo gedit /etc/samba/smb.conf
  在smb.conf最后添加

  [share]
  path = /home/phinecos/share
  available = yes
  browsealbe = yes
  public = yes
  writable = yes
***** 创建samba帐户
    sudo touch /etc/samba/smbpasswd
    sudo smbpasswd -a phinecos
  然后会要求你输入samba帐户的密码

   ［如果没有第四步，当你登录时会提示 session setup failed: NT_STATUS_LOGON_FAILURE］

***** 重启samba服务器
       sudo /etc/init.d/samba restart
       后来想起来，16.04的服务是使用systemd进行管理了，查了一下相关的资料，发现重启服务的命令如下
       sudo systemctl restart  smbd.service

   或者
   Debian and debian-derivatives changed the service name from 'samba' to 'smbd'.
   Try service smbd restart.
***** 六. 测试
       smbclient -L //localhost/share
    
   win7 加个 -m SMB2
   smbclient -L //192.168.1.14/soft -m SMB2
***** 七，使用
   可以到windows下输入ip使用了，在文件夹处输入 "\\" + "Ubuntu机器的ip或主机名" + "\\" + "share"

   Linux上 smbclient 

   密码登录改配置
   主要就是把security改成user guest ok改成no
***** smbclinet 命令说明  pwd 目录必须是传文件的目录
   ?或help [command] 提供关于帮助或某个命令的帮助
   ![shell command] 执行所用的SHELL命令，或让用户进入 SHELL提示符
   cd [目录] 切换到服务器端的指定目录，如未指定，则 smbclient 返回当前本地目录
   lcd [目录] 切换到客户端指定的目录；  
   dir 或ls 列出当前目录下的文件；
   exit 或quit 退出smbclient
   get file1 file2 从服务器上下载file1，并以文件名file2存在本地机上；
   如果不想改名，可以把file2省略
   mget file1 file2 file3 filen 从服务器上下载多个文件；
   md或mkdir 目录 在服务器上创建目录
   rd或rmdir 目录 删除服务器上的目录
   put file1 [file2] 向服务器上传一个文件file1,传到服务器上改名为file2；
   put file1 file2 filen 向服务器上传多个文件
** 日志  
*** 启动日志
    /var/log/boot.log 
** 电源管理
    立刻关机：
  sudo halt
  sudo init 0
  sudo shutdown -h now
  sudo shutdown -h 0

  定时/延时关机：

  sudo shutdown -h 19:30
  sudo shutdown -h +30   ##单位为分钟
  重启：
  sudo reboot
  sudo init 6
  sudo shutdown -r now
  休眠：

  sudo pm-hibernate

  echo “disk” > /sys/power/state

  sudo hibernate-disk

  待机(挂起)：
  sudo pm-suspend
  sudo pm-suspend-hybrid

  echo “mem” > /sys/power/state

  sudo hibernate-ram
** 蓝牙连接
**** 蓝牙上电  
     [NEW] Controller 74:2F:68:6A:37:44 moon-0 [default] 
     [NEW] Device 00:07:61:76:8E:78 Logitech diNovo Edge 
     Agent registered 
     [bluetooth]# list 
     Controller 74:2F:68:6A:37:44 moon-0 [default] 
     [bluetooth]# show 
     Controller 74:2F:68:6A:37:44 
     Name: moon 
     Alias: moon-0 
     Class: 0x000000 
     Powered: no 
     Discoverable: no 
     Pairable: yes 
     UUID: PnP Information (00001200-0000-1000-8000-00805f9b34fb) 
     UUID: Generic Access Profile (00001800-0000-1000-8000-00805f9b34fb) 
     UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb) 
     UUID: A/V Remote Control (0000110e-0000-1000-8000-00805f9b34fb) 
     UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb) 
     Modalias: usb:v1D6Bp0246d0509 
     Discovering: no 
     [bluetooth]# power on 
     Failed to set power on: org.bluez.Error.Blocked 
     [bluetooth]# scan on 
     Failed to start discovery: org.bluez.Error.NotReady 
  [bluetooth]# devices 
  Device 00:07:61:76:8E:78 Logitech diNovo Edge 
  [bluetooth]# info 00:07:61:76:8E:78 
  Device 00:07:61:76:8E:78 
  Name: Logitech diNovo Edge 
  Alias: Logitech diNovo Edge 
  Class: 0x002540 
  Icon: input-keyboard 
  Paired: yes 
  Trusted: yes 
  Blocked: no 
  Connected: no 
  LegacyPairing: no 
  UUID: Human Interface Device… (00001124-0000-1000-8000-00805f9b34fb) 
  UUID: PnP Information (00001200-0000-1000-8000-00805f9b34fb) 
  Modalias: usb:v046DpB309d011B 
  [bluetooth]# connect 00:07:61:76:8E:78 
  Attempting to connect to 00:07:61:76:8E:78 
  Failed to connect: org.bluez.Error.Failed 
  原因及解决办法： 
  这是由于蓝牙设备没有上电造成的，可通过如下命令解决此问题： 
  rfkill unblock bluetooth 
  hciconfig hci0 up
** 服务
systemctl status networking.service
** traceroute 追踪数据传输路由状况。
tcpdump 命令行的抓包工具。
** 磁盘管理
   fdisk 磁盘分区命令，适用于2TB以下磁盘分区。 
parted 磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。
mkfs 格式化创建Linux文件系统。
partprobe 更新内核的硬盘分区表信息。
e2fsck 检查ext2/ext3/ext4类型文件系统。
mkswap 创建Linux交换分区。
swapon 启用交换分区。
swapoff 关闭交换分区。

** 安装包管理类
   //centos
   yum provides */libgcc_s.so.1    //根据文件名检查所属的包 
   yum search python       //查找与指定关键词相关的包
   yum info python         //查看指定包的信息
   yum list python         //查看指定包的简要信息
   yum install net-tools       //安装指定的包(net-tools包含netstat和ifconfig命令)
   yum remove libevent     //删除指定的包
   rpm -ivh xxxx.rpm --test    //安装指定的rpm包，加上--test代表只是测试
   rpm -e --nodeps openjavasdk //强行删除指定的包
   rpm -q python           //查询是否安装了该包
   rpm -ql python          //查询包安装涉及的目录
   rpm -qR python          //显示依赖项目，R=Require

   //ubuntu
   apt-cache show package  //获取包的相关信息，如说明、大小、版本等   
   apt-cache search package    //搜索软件包，同yum search
   apt-cache showpkg package_name  //显示软件包的依赖关系信息
   apt-cache depends package_name  //显示指定软件包所依赖的软件包。
   sudo dpkg -I iptux.deb#查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于--info）
   sudo dpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构（其中-c等价于--contents）
   sudo dpkg -i iptux.deb#安装iptux.deb软件包（其中-i等价于--install）
   sudo dpkg -l iptux#查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于--list）
   sudo dpkg -L iptux#查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）
   sudo dpkg -s iptux#查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于--status）
   sudo dpkg -r iptux#卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）
   注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。

** 文件管理类
   find 路径 -iname "*.jar" -exec cp {} 目标目录 \;    //find和cp联动操作
** 进程\网络查看类
   ps -aux         //查看所有进程
   pgrep cron      //查询应用是否在运行，成功则返回pid
   netstat –apn        //查看所有占用了网络端口的应用
   netstat -tl     //参数“-t”是显示tcp数据包的连接行为，参数“-l”是显示监听状态。如果"netstat -tl"输出结果如上面代码所示，则说明服务器端ssh服务已启动。
   ip addr         //查看ip地址
** 后台运行
   linux命令行重定向：在shell中，分别用0，1，2分别代表标准输入，标准输出，异常输出。 
   在linux中，有个特殊的文件/dev/null，向其写入数据都会被丢弃。
 nohup ./startWebLogic.sh &  //让程序在后台运行，输出文件为nohup.out
 nohup command > myout.file 2>&1 &   //输出文件重定向为myout.file
 nohup command >/dev/null 2>$1 &    //×××忽略所有输出，重要×××
 jobs -l               //查看当前正在运行的job
 fg %s                 //关闭指定的job
** 定时运行
   cron是linux中用于处理定时任务的工具，关键信息格式：分时日月周
   分钟　（0-59） 
   小时　（0-23） 
   日期　（1-31） 
   月份　（1-12） 
   星期　（0-7）//0 7代表星期天 #周月日不可同时存在，否则语法错误。

*/3 * * * *    ls       #   每三分钟执行一次ls

crontab -e      //编辑当前用户的cron任务
crontab -l      //列出当前用户的cron任务
crontab -r      //删除当前任务的cron任务

service crond start|stop|restart|reload //对cron服务进行控制

系统定时任务配置

目录位置	描述
/etc/cron.hourly	目录下的脚本会每个小时让执行一次，在每小时的17分钟时运行；
/etc/cron.daily	目录下的脚本会每天让执行一次，在每天的6点25分时运行；
/etc/cron.weekly	目录下的脚本会每周让执行一次，在每周第七天的6点47分时运行；
/etc/cron.mouthly	目录下的脚本会每月让执行一次，在每月1号的6点52分时运行；
** 创建快捷方式
linux的快捷方式都存放于 /usr/share/applications，后缀名为.desktop,范例如下：

[Desktop Entry]
Name=eclipse
Comment=eclipse ide
Exec=/opt/eclipse_j2ee/eclipse
Icon=/opt/eclipse_j2ee/icon.xpm
Terminal=false
Type=Application
Categories=Application;Development;
StartupNotify=true

** 清理boot 内核
   ubuntu使用时间长了后，积累了不少已经过期的内核，导致boot区不够用。

#查询
dpkg --get-selections |grep linux-image
#查看当前内核版本
uname -a
#清理指定版本内核（重要：可别把当前版本给清理了）
sudo apt-get purge linux-image-3.5.0-17-generic
#也可以使用自动删除(比较安全，定期执行下即可)
sudo apt-get autoremove

** 修改ip地址
ip addr #查看当前的ip地址
cat /etc/resolv.conf    #查看dns网络地址
vim /etc/sysconfig/network-scripts/ifcfg-exxx   #编辑网卡配置文件

BOOTPROTO="static" 网卡获得ip地址的方式，static（静态 ip地址）dhcp（通过dhcp协议获取ip）
IPADDR="192.168.211.144"
GATEWAY="192.168.211.2" #重要：虚拟机linux设静态ip必须设置Gateway，而且一定指向x.x.x.2那个地址
ONBOOT="yes" 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。默认设置为yes
** shell 
*** guake 
*** tilda  
* 常见问题
** 中文乱码  
*** unzip中文乱码 
zip中文乱码 unzip -O cp936 /-O gbk gb18030 都可以
指定目录 -d
 或 7z 或
#+BEGIN_SRC python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import zipfile

#print "Processing File " + sys.argv[1]

file=zipfile.ZipFile(sys.argv[1],"r");
for name in file.namelist():
    utf8name=name.decode('gbk')
#    print "Extracting " + utf8name
    pathname = os.path.dirname(utf8name)
    if not os.path.exists(pathname) and pathname!= "":
        os.makedirs(pathname)
    data = file.read(name)
    if not os.path.exists(utf8name):
        fo = open(utf8name, "w")
        fo.write(data)
        fo.close
file.close()
#+END_SRC

** 重启输入法
   #!/bin/sh
   pidof fcitx | xargs kill
   pidof sogou-qimpanel | xargs kill
   nohup fcitx  1>/dev/null 2>/dev/null &
   nohup sogou-qimpanel  1>/dev/null 2>/dev/null &
** xrandr 
    显示显示器 xrandr -q
    关闭笔记本，开外置：xrandr --output VGA-1-1 --auto --output LVDS-1-1 --off
** 识别usb
   最近项目需要在Android源码中进行开发，于是在Virtual Box中安装Ubuntu，郁闷的是插上usb连接线，连接上手机，Ubuntu不能自动识别连接设备。在网上搜索了很多解决办法，各抒己见，最终找到一种可行的解决方案：
 1、安装usbmount
 $ sudo apt-get install usbmount  
 2、更改usbmount配置文件
 $ sudo gedit /etc/usbmount/usbmount.conf  
 3、在打开的文件中找到FILESYSTEM，并在其中添加vfat,ntfs
 4、FS_MOUNTOPTIONS这个选项里加入”"-fstype= vfat,iocharset=utf8,codepage=936,umask=000,users”
 5、重启udev
 $sudo /etc/init.d/udev restart  
 6、重启Ubuntu
 $ sudo reboot  
 重启之后即可识别USB。
   
** 服务systemctl 
 systemctl is-enabled servicename.service #查询服务是否开机启动
 systemctl enable *.service #开机运行服务
 systemctl disable *.service #取消开机运行
 systemctl start *.service #启动服务
 systemctl stop *.service #停止服务
 systemctl restart *.service #重启服务
 systemctl reload *.service #重新加载服务配置文件
 systemctl status *.service #查询服务运行状态 
** 开机启动
   update-rc.d使用
   update-rc.d是一个Perl脚本，是用来自动升级System V类型初始化脚本，简单来说就是哪些东西是你想要在系统引导初始化的时候运行的，哪些是希望在关机或重启时候停止的，都可以用它来帮你设置。这些脚本的连接位于/etc/rcX.d/下（X代表0～6），对应脚本位于/etc/init.d/下。
   1、设置启动项：
   update-rc.d <serviceName> start <order> <runlevel>
  
 2、设置停止项：
 update-rc.d <serviceName> stop <order> <runlevel>
 设置启动和停止可以写在一起，例如：
 sudo update-rc.d <serviceName> start 20 1 2 3 4 5 . stop 60 0 6 .   
 一定要注意，写在一起的时候后面的两个“.”符号一定要有，不然报错。

 3、从所有的运行级别中删除制定的启动项
 update-rc.d -f <serviceName> remove
 示例
 根据上面的介绍，如何将一个软件安装为服务也就比较清楚了，那就是在/etc/init.d添加一个服务的启动脚本，然后在需要启动服务的对应级别中/etc/rc[0~6].d按照文件名格式添加一个指向/etc/init.d的脚本符号链接。
 以apache2为例，默认情况下，apache2编译安装在/usr/local/apache2，apache2的服务器启动脚本是/usr/local/apache2/bin/apachectl，那么安装服务就是要把此apachectl拷贝到需要启动apache2服务器的运行级别对应的/etc/rc[0~6].d目录下，一半来说ubuntu的运行级别为2，所以也就是拷贝到/etc/rc2.d下。

 sudo cp /usr/local/apache2/bin/apachectl /etc/init.d/apache2  
 如果手动添加的话：
 sudo ln -s /etc/init.d/apache2 /etc/rc2.d/S80apache2  
 重启服务器后，就可以看到apache2自动启动了。
 这时如果想要停止或重启apache2也可以使用以下命令：

 service apache2 stop  
 service apache2 restart  

** 查看错误
   vi /var/log/message
   然后查找你所需要的内容把    
   您也可以grep warning这样的条目
   使用tail和grep只是为了使您查看起来更方便简捷更有针对性而已哦
** 临时域名
    ./natapp -authtoken=e5eb817e91aeee83 
** emacs中文 
   最简单的办法是替换emacs的启动文件，就是那个.desktop文件 在/usr/share/applications/下面。
   直接改成
   Exec=env LC_CTYPE=zh_CN.UTF-8 emacs25 %F
* 应用函数
** 编辑函数  
*** 删除重复行   
   emacs delete-duplicate-lines 
*** 重复行是相互毗邻的,若要实现类似uniq的效果,可以使用C-u C-u M-x delete-duplicate-lines.
*** 若要保留重复的空白行,则需要使用C-u C-u C-u M-x delete-duplicate-lines
