函数式编程的好处 
由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。
函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。
由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称多处理器（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。
我觉得函数编程的好处就不用管 js 里面该死的 this 指向
函数式编程语言还提供惰性求值-Lazy evaluation，也称作 call-by-need，是在将表达式赋值给变量（或称作绑定）时并不计算表达式的值，而在变量第一次被使用时才进行计算。这样就可以通过避免不必要的求值提升性能。
函数式编程语言一般还提供强大的模式匹配（Pattern Match）功能。在函数式编程语言中可以定义代数数据类型（Algebraic data type），通过组合已有的数据类型形成新的数据类型，如在 Scala 中提供 case class，代数数据类型的值可以通过模式匹配进行分析。
推荐阅读《傻瓜函数式编程
面向对象式编程的好处 
面向对象程序设计（Object-oriented programming OOP）是种通过类、方法、对象和消息传递，来支持面向对象的程序设计范式。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，程序会被设计成彼此相关的对象。
面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。即把事情交给最适合的对象去做。
面向对象和面向过程的区别最直观的比喻就如：摇（狗尾巴）和 狗.摇尾巴（）的区别。


范，模范、典范也。范式即模式、方法。常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程等。
在面向对象编程的世界，程序是一系列相互作用（方法）的对象（Class Instances），而在函数式编程的世界，程序会是一个无状态的函数组合序列。
不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的，如 Smalltalk 和 Java 支持面向对象编程。而 Haskell 和 Scheme 则支持函数式编程。现代编程语言的发展趋势是支持多种范型，如 C#、Java 8+、Kotlin、 Scala、ES6+ 等等。
1.命令式编程（Imperative programming）
计算机的硬件负责运行使用命令式的风格来写的机器码。计算机硬件的工作方式基本上都是命令式的。大部分的编程语言都是基于命令式的。高级语言通常都支持四种基本的语句：
（1）运算语句
一般来说都表现了在存储器内的数据进行运算的行为，然后将结果存入存储器中以便日后使用。高阶命令式编程语言更能处理复杂的表达式，产生四则运算和函数计算的结合。
（2）循环语句
容许一些语句反复运行数次。循环可依据一个默认的数目来决定运行这些语句的次数；或反复运行它们，直至某些条件改变。
（3）条件分支
容许仅当某些条件成立时才运行某个区块。否则，这个区块中的语句会略去，然后按区块后的语句继续运行。
（4）无条件分支
容许运行顺序转移到程序的其他部分之中。包括跳跃（在很多语言中称为 Goto）、副程序和 Procedure 等。
循环、条件分支和无条件分支都是控制流程。
早期的命令式编程语言，例如汇编，都是机器指令。虽然硬件的运行更容易，却阻碍了复杂程序的设计。
1954 年开始开发的 FORTRAN，是第一个编译型的编程语言，支持命名变量、复杂表达式、副程序和其他一些功能。后来的二十年中，大量的其他高级命令式编程语言被发明出来。
在 1980 年后，面向对象编程有迅速的发展；面向对象编程语言均有着命令式的风格，但引入了类和对象的核心概念，从此编程进入了 OOP 时代。
2.面向对象编程（Object-oriented programming，OOP）
怎样为一个模糊不清的问题找到一个最恰当的描述（问题描述）？ 抽象（Abstraction）通常是我们用来简化复杂的现实问题的方法。
在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。
对象包含数据（字段、属性）与方法。
面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。
当我们提到面向对象的时候，它不仅指一种程序设计方法。它更多意义上是一种程序开发方式。在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称 OOD）方面的知识。许多流行的编程语言是面向对象的,它们的风格就是会透由对象来创出实例。
重要的面向对象编程语言包含 Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP 等。
面向对象编程中，通常利用继承父类，以实现代码重用和可扩展性。
3.声明式编程（Declarative programming）
一种编程范式，与命令式编程相对立。
它描述目标的性质，让计算机明白目标，而非具体过程。
声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。
而命令式编程则需要用算法来明确的指出每一步该怎么做。
声明式编程通常被看做是形式逻辑的理论，把计算看做推导。
声明式编程因大幅简化了并行计算的编写难度，自 2009 起备受关注。
常见的声明式编程语言有：
数据库查询语言（SQL，XQuery）
正则表达式
逻辑编程
函数式编程
组态管理系统等。
声明式编程透过函数、推论规则或项重写（term-rewriting）规则，来描述变量之间的关系。它的语言运行器（编译器或解释器）采用了一个固定的算法，以从这些关系产生结果。
很多文本标记语言例如 HTML、MXML、XAML 和 XSLT 往往是声明式的。函数式编程，特别是纯函数式编程，尝试最小化状态带来的副作用，因此被认为是声明式的。不过，大多数函数式编程语言，例如 Scheme、Clojure、Haskell、OCaml、Standard ML 和 Unlambda，允许副作用的存在。

* 面向对象 [ 便于复用(代码再利用) , 便于扩展]
  概念是这样定义的，但具体实现还是开发者的主观意愿 

- 类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。
- 对象 − 是类的实例。
  成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。
- 成员方法 − 定义在类的内部，可用于访问对象的数据。
- 继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。
- 父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。
- 子类 − 一个类继承其他类称为子类，也可称为派生类。
- 多态 − 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。
- 重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
- 抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。
- 封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。
- 构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与 new 运算符一起使用在创建对象的语句中。
- 析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做"清理善后" 的工作（例如在建立对象时用 new 开辟了一片内存空间，应在退出前在析构函数中用 delete 释放）

