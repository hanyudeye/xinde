#+TITLE: 数据结构 
#+DESCRIPTION: 数据结构 
#+TAGS: 数据结构 
#+CATEGORIES: 计算机
#+DATE: <2019-06-22 06:44:40>

* 数据结构 
** 树 
*** B 树
*** 2-3 树
* 字符串
** 字符串左旋 ( 循环方法 )
   #+BEGIN_SRC c
     #include <iostream>
     #include <string>
     using namespace std;
     void rotate(string &str, int m)
     {

       if (str.length() == 0 || m <= 0)
         return;
       int n = str.length();

       if (m % n <= 0)
         return;

       int p1 = 0, p2 = m;
       int k = (n - m) - n % m;

       // 交换 p1,p2 指向的元素,然后移动 p1,p2
       while (k --)
         {
           swap(str[p1], str[p2]);
           p1++;
           p2++;
         }

       // 重点,都在下述几行。
       // 处理尾部,r 为尾部左移次数
       int r = n - p2;
       while (r--)
         {
           int i = p2;
           while (i > p1)
             {
               swap(str[i], str[i-1]);
               i--;
             }
           p2++;
           p1++;
         }
       //比如一个例子,abcdefghijk
       //                    p1    p2
       //当执行到这里时,defghi a b c j k
       //p2+m 出界 了,
       //r=n-p2=2,所以以下过程,要执行循环俩次。

       //第一次:j 步步前移,abcjk->abjck->ajbck->jabck
       //然后,p1++,p2++,p1 指 a,p2 指 k。
       //               p1    p2
       //第二次:defghi j a b c k
       //同理,此后,k 步步前移,abck->abkc->akbc->kabc。
     }

     int main()
     {
       string ch="abcdefghijk";
       rotate(ch,3);
       cout<<ch<<endl;
       return 0;
     }
   #+END_SRC
  
** 左旋转字符串( 递归 )
   #+begin_src c
     //递归,
     #include <iostream>
     using namespace std;

     void rotate(string &str, int n, int m, int head, int tail, bool flag)
     {
       //n 待处理部分的字符串长度,m:待处理部分的旋转长度
       //head:待处理部分的头指针,tail:待处理部分的尾指针
       //flag = true 进行左旋,flag = false 进行右旋

       // 返回条件
       if (head == tail || m <= 0)
         return;

       if (flag == true)
         {
           int p1 = head;
           int p2 = head + m;  //初始化 p1,p2

           //1、左旋:对于字符串 abc def ghi gk,
           //将 abc 右移到 def ghi gk 后面,此时 n = 11,m = 3,m’ = n % m = 2;
           //abc def ghi gk -> def ghi abc gk
           //(相信,经过上文中那么多繁杂的叙述,此类的转换过程,你应该是了如指掌了。)

           int k = (n - m) - n % m;   //p1,p2 移动距离,向右移六步

           /*---------------------
             解释下上面的 k = (n - m) - n % m 的由来:
             yansha:
             以 p2 为移动的参照系:
             n-m 是开始时 p2 到末尾的长度,n%m 是尾巴长度
             (n-m)-n%m 就是 p2 移动的距离
             比如 abc def efg hi
             开始时 p2->d,那么 n-m 为 def efg hi 的长度 8,
             n%m 为尾巴 hi 的长度 2,
             因为我知道 abc 要移动到 hi 的前面,所以移动长度是
             (n-m)-n%m = 8-2 = 6。
           ,*/

           for (int i = 0; i < k; i++, p1++, p2++)
             swap(str[p1], str[p2]);
           rotate(str, n - k, n % m, p1, tail, false); //flag 标志变为 false,结 束左旋,下面,进入右旋
         }
       else
         {
           //2、右旋:问题变成 gk 左移到 abc 前面,此时 n = m’ + m = 5,m = 2, m’ = n % m 1;
           //abc gk -> a gk bc

           int p1 = tail;
           int p2 = tail - m;

           // p1,p2 移动距离,向左移俩步
           int k = (n - m) - n % m;


           for (int i = 0; i < k; i++, p1--, p2--)
             swap(str[p1], str[p2]);

           rotate(str, n - k, n % m, head, p1, true); //再次进入上面的左旋部 分,
           //3、左旋:问题变成 a 右移到 gk 后面,此时 n = m’ + m = 3,m = 1, m’ = n % m = 0;
           //a gk bc-> gk a bc。 由于此刻,n % m = 0,满足结束条件,返回结果。

         }
     }

     int main()
     {
       int i=3;
       string str = "abcdefghijk";
       int len = str.length();
       rotate(str, len, i % len, 0, len - 1, true);
       cout << str.c_str() << endl;   //转化成字符数组的形式输出
       return 0;
     }
   #+end_src  
