#+TITLE: 计算机操作系统简介
#+CATEGORIES: 软件用法 
#+TAGS: os,操作系统
#+DATE: <2019-06-22 17:39:30>

* 简介
  #+begin_verse
  根据厂里的人事组织，可以把操作系统想象成扮演着
  生产任务调度执行的生产班长
  及仓库空间整理的仓库管理员
  及配置自己的喜好的食堂阿姨
  及用户管理的人事
  及设备管理的机修
  的角色。
  #+end_verse
 
  #+HTML: <!-- more -->

  #+begin_quote
  #+begin_verse
  早期的操作系统是给高级用户用的,只有一个 *shell* 界面让用户执行软件,使用者要熟悉程序的名字和选项。
  现在的操作系统是图形化的,程序有对应的图标放在桌面上,双击一下就打开了,功能都在菜单里面，一目了然.
  #+end_verse
  #+end_quote

* 开机引导程序[ 操作系统前 ]
  : 在操作系统加载之前执行的小程序，用来检测硬件的，缺胳膊少腿的硬件就没必要加载操作系统了。
  检测完后检测磁盘 (按照检测顺序),看看磁盘是否满足启动格式，如满足就启动，不满足就黑屏报错。
** BIOS (Basic Input/Output System)
   早期 PC 机上使用的引导程序，BIOS 与 MBR 配合是 32 位计算机的主流。还提供一些 操作接口(中断接口)。
   MBR: 磁盘第一块扇区，操作系统加载程序，磁盘分区信息放在里面。
** UEFI (Unified Extensible Firmware Interface)
   BIOS 升级版，能识别 FAT 文件系统了、安全性能进一步提高 (加了点功能)
   检测内存条的时候，检测的内存范围大了，应该可以到 64 位了。
   : 看了下百科，功能还挺强的，小型操作系统了都.
* 现代操作系统
** 执行程序 
   能够执行程序是首要要求吧。
** 执行多任务程序，切换程序
   执行一个程序不够吧，起码执行两三个，来回切换才行嘛
** 进程管理 (执行多任务的具体实现)
   #+begin_verse
   进程是加载到内存执行的程序,不是在磁盘里的程序文件。
   我执行了几个任务,任务就要运行了是吧. 
   如果是单核的 ~CPU~ ,就是一次只能执行一个程序.可是我要执行多个程序呀, 所以操作系统就给每个任务一个时间段,几个程序轮流执行一个时间段.
   因为速度刷刷快,我们在切换程序的时候都感觉不到延时. 
   多核的化,可以把一些时间段给另外一些核执行,这个就是同时的了.
   #+end_verse
   
   #+begin_quote
   操作系统做了这么一件事，就是把程序进程化，那么就不会破坏磁盘上的程序文件了，然后进程也方便处理。
   #+end_quote
*** 进程的状态
    单核的化,一个任务就执行一个时间段, 那么另外的任务就只能等了. 任务的状态属性如下
    - 进程状态
      - 就绪状态（ready）：等待被调度
      - 运行状态（running）
      - 阻塞状态（waiting）：等待资源 ( 这个不会被调度, 你开了两个程序,同一时间只能操作一个程序,另一个不是那种切换后还在那放歌的程序一般就不执行了 )

      : 操作系统把任务放在一个调度列表里面的 , 就绪状态的任务才会按序执行.    
     
*** 调度算法 (任务调度的几个方法)
    - 批处理系统
      - 先来先服务
      - 短作业优先
      - 最短剩余时间优先 
    - 交互式系统
      - 时间片轮转
      - 优先级调度 (每个任务还有不同的优先级,这个有点骚)
      - 多级反馈队列
    - 实时系统
** 线程
   做多个事情，创造线程是因为进程的开销有点大。
** 内存管理 
   执行多任务,怎么分配任务的内存呢,这里要考虑下的. 要不来,瞎分配,等着死机吧.
*** 虚拟内存 (假内存, 哈,内存一直是不够用的)
    硬件的构造允许使用虚拟内存的特性, 因为硬件设计中，访问内存不是直接使用内存地址，而是用拼接成的地址。
**** 分页系统地址映射 (把内存分分块,跟磁盘的目录结构一样,方便操作)
     内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）
     存储着页（程序地址空间）和页框（物理内存空间）的映射表。

     一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

**** 分段 (每个任务一个段的内存啦)
     分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，
     并且可以动态增长。
**** 段页式
     程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的
     页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。
*** 分页与分段的比较
    - 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。
    - 地址空间的维度：分页是一维地址空间，分段是二维的。
    - 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
    - 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使
      程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
** 文件管理 
   一般文件要有自己的属性啦,什么文件所属，文件类型。   
*** 文件存储空间的管理 
    把文件的属性信息放在 inode 里面
    把文件的内容放在 data block 里面
    superblock 记录文件系统整体信息
*** 目录管理
    目录是什么结构，是单层，双层 ,还是树，图
*** 文件共享
**** 多用户 
**** 远程文件系统
*** 保护
**** 访问类型 
**** 访问控制
** I/O 系统
   怎么调节显示器亮度,怎么调节音量大小.这个不会让小学生自己弄吧,这个也要方便操作. 改改改 
  
   完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
   对于设备是否能够使用，你怎么处理
*** I/O 硬件 
**** 轮询 
**** 中断
**** 直接内存访问
*** 应用接口 
**** 块与字符设备 
**** 网络设备
**** 时钟与定时器
**** 阻塞与非阻塞 I/O
*** 设备分配
*** 磁盘管理
**** 磁盘结构 
     - 盘面（Platter）：一个磁盘有多个盘面；
     - 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
     - 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理
       储存单位，目前主要有 512 bytes 与 4 K 两种大小；
     - 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信
       号转换为盘面的磁场（写）；
     - 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
     - 主轴（Spindle）：使整个盘面转动。
**** 磁盘调度算法
     读写一个磁盘块的时间的影响因素有：
      
     - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
     - 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
     - 实际的数据传输时间

       其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。
***** 1. 先来先服务 FCFS, First Come First Served
      按照磁盘请求的顺序进行调度。
      优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。
***** 2. 最短寻道时间优先 SSTF, Shortest Seek Time First
      优先调度与当前磁头所在磁道距离最近的磁道。

      虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道
      请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的
      磁道请求更容易出现饥饿现象。
***** 3. 电梯算法 SCAN
      电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

      电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方
      向上没有未完成的磁盘请求，然后改变方向。

      因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。
**** 交换空间管理
**** 磁盘阵列
** 系统调用
   这是给软件开发人用的,小学生不用懂.
   开发人用这些来简化编程. 
   | 进程控制 | fork(); exit(); wait();     |
   | 进程通信 | pipe(); shmget(); mmap();   |
   | 文件操作 | open(); read(); write();    |
   | 设备操作 | ioctl(); read(); write();   |
   | 信息维护 | getpid(); alarm(); sleep(); |
   | 安全     | chmod(); umask(); chown();  |
** 保护和安全
   #+begin_verse
   这个一般是用来防范网络黑客的.
   我们不会发神经摔电脑吧,但联网后,黑客可能执行我们本地的程序,删除一些我们的资料.看操作系统能做什么喽.
   #+end_verse
*** 密码 
    密码复杂点
*** 系统威胁
    木马，病毒，拒绝服务
*** 入侵检测
*** 密码系统
    ssl 加密技术
* 虚拟机
  #+begin_verse
  操作系统里面再弄一个操作系统,执行别的系统的程序.
  有的虚拟机不用安装操作系统了,比如 ~Docker~ ,可以直接执行本系统不支持的程序,省去了很多空间.
  #+end_verse
* 分布式系统
  #+begin_verse
  操作系统死机了怎么办？或者活多忙不过来，就想到用多台计算机，其中有一台用来做任务分配，就是分布式计算机了。 
  那种用来做分配什么的软件就叫分布式系统。
  数据库挂了怎么办，来个分布式数据库呗，哈哈 
  用到的基础就是网络哈
  #+end_verse
** 网络
   操作系统不把网络做好,就不像话了. 基本的能不能联网的开关要有一个吧.
*** 网络分类
    小网络 (局域网)
    大网络 (广域网)
    #+begin_quote
    大小分
    #+end_quote
*** 通信
**** 命名与名字解析 (DNS 技术)
**** 路由策略(路由技术)
**** 分组策略
**** 连接策略
** 分布式文件系统
** 分布式协调
   怎么协调任务
