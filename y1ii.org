访问页面： http://hostname/index.php?r=site/say&message=Hello+World
* YII 
** 安装,启动 
*** 1.yii2
**** yii1升级
     这是升级用的插件，从版本1升级用的 composer global require "fxp/composer-asset-plugin:^1.3.1"
**** 安装
   基础版 composer create-project --prefer-dist yiisoft/yii2-app-basic basic
   开发版 composer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic
   
   安装某个版本, 转到目录即可，后面是版本号
    基础版 php composer.phar create-project yiisoft/yii2-app-basic basic 2.0.13
    高级版 php composer.phar create-project yiisoft/yii2-app-advanced advanced 2.0.13
**** 归档文件安装
    从 yiiframework.com 下载归档文件。
    将下载的文件解压缩到 Web 访问的文件夹中。
    修改 config/web.php 文件，给 cookieValidationKey 配置项 添加一个密钥
    （若你通过 Composer 安装，则此步骤会自动完成）：
    // !!! 在下面插入一段密钥（若为空） - 以供 cookie validation 的需要
    'cookieValidationKey' => '在此处输入你的密钥',
*** 2.执行初始化命令
    ./init 选择 development  或者 production 
*** 3.检测配置是否满足运行需求
   php requirements.php
*** 4.启动服务
    php yii serve 默认情况下Https-server将监听8080
    指定端口 php yii serve --port=8888
    访问 http://localhost:8080/
*** 5.配置服务器
**** apache 
#+BEGIN_SRC conf
    #设置文档根目录为 "basic/web"
  Document           Root "path/to/basic/web"
  <Directory "path/to/basic/web">
      # 开启 mod_rewrite 用于美化 URL 功能的支持（译注：对应 pretty URL 选项）
      RewriteEngine on
      # 如果请求的是真实存在的文件或目录，直接访问
      RewriteCond %{REQUEST_FILENAME} !-f
      RewriteCond %{REQUEST_FILENAME} !-d
      # 如果请求的不是真实文件或目录，分发请求至 index.php
      RewriteRule . index.php

      # ...其它设置...
  </  Directory>
#+END_SRC

**** nginx
#+BEGIN_SRC conf
server {
    charset utf-8;
    client_max_body_size 128M;

    listen 80; ## listen for ipv4
    #listen [::]:80 default_server ipv6only=on; ## listen for ipv6

    server_name mysite.local;
    root        /path/to/basic/web;
    index       index.php;

    access_log  /path/to/basic/log/access.log;
    error_log   /path/to/basic/log/error.log;

    location / {
        # Redirect everything that isn't a real file to index.php
        try_files $uri $uri/ /index.php$is_args$args;
    }

    # uncomment to avoid processing of calls to non-existing static files by Yii
    #location ~ \.(js|css|png|jpg|gif|swf|ico|pdf|mov|fla|zip|rar)$ {
    #    try_files $uri =404;
    #}
    #error_page 404 /404.html;

    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_pass 127.0.0.1:9000;
        #fastcgi_pass unix:/var/run/php5-fpm.sock;
        try_files $uri =404;
    }

    location ~* /\. {
        deny all;
    }
}
#+END_SRC
使用该配置时，你还应该在 php.ini 文件中设置 cgi.fix_pathinfo=0 ，
能避免掉很多不必要的 stat() 系统调用。
还要注意当运行一个 HTTPS 服务器时，需要添加 fastcgi_param HTTPS on; 一行，
这样 Yii 才能正确地判断连接是否安全。
** 软件结构
*** 结构概述
    入口脚本：引导文件
    应用：能全局范围内访问的对象，管理协调组件来完成请求.
    应用组件：在应用中注册的对象，提供不同的功能来完成请求。
    模块：包含完整 MVC 结构的独立包，一个应用可以由多个模块组建。
    过滤器：控制器在处理请求之前或之后需要触发执行的代码。
    小部件：可嵌入到视图中的对象，可包含控制器逻辑，可被不同视图重复调用。
*** 入口脚本
**** web端 index.php
     #+BEGIN_SRC php
       defined('YIIDEBUG') or define('YIIDEBUG', true);
       defined('YIIENV') or define('YIIENV', 'dev');
       // 注册 Composer 自动加载器 
       require DIR . '/../vendor/autoload.php';
       // 包含 Yii 类文件 
       require DIR . '/../vendor/yiisoft/yii2/Yii.php';
       // 加载应用配置 
       $config = require DIR . '/../config/web.php';
       // 创建、配置、运行一个应用 
       (new yii\web\Application($config))->run();
     #+END_SRC
**** 控制台 yii
     ./yii <route> [arguments] [options] 
*** 应用配置
    yii\web\Application 网页应用主体
    yii\console\Application 控制台应用主体
**** 必要属性 main.php
***** id属性用来区分其他应用的唯一标识ID 
***** basePath
      指定该应用的根目录。就是frontend目录。 在根目录下可以看到对应MVC设计模式的
      models, views, controllers等子目录。
      __DIR__指向的是controllers目录
**** 重要属性
***** 应用主体
      应用主体是管理 Yii 应用系统整体结构和生命周期的对象。
      每个Yii应用系统只能包含一个应用主体，应用主体在入口脚本 中创建并能通过表达式 
      Yii::$app 全局范围内访问。
****** 使用方法   
       #+BEGIN_SRC php
         function () { 
           return Yii::$app->getModule('user');
         }
       #+END_SRC
***** components
      这是最重要的属性，它允许你注册多个在其他地方使用的应用组件. 例如
 #+BEGIN_SRC php
   'components' => [ 
       'cache' => [
           'class' => 'yii\caching\FileCache', 
                   ], 
       'user' => [
           'identityClass' => 'app\models\User', 'enableAutoLogin' => true, 
                  ],
                     ], 
 #+END_SRC

   在应用中可以任意注册组件，并可以通过表达式 \Yii::$app->ComponentID 全局访问。

***** controllerMap 重新映射控制器
   默认控制器是（如post对应app\controllers\PostController）
   
   在下面的例子中，account对应到app\controllers\UserController， article 对应到 app\controllers\PostController。

   #+BEGIN_SRC php
     [ 
         'controllerMap' => [
             'account' => 'app\controllers\UserController',
             'article' => [ 
                 'class' => 'app\controllers\PostController', 
                 'enableCsrfValidation' => false,
                            ],
                             ],
       ]
   #+END_SRC

   数组的键代表控制器ID，数组的值代表对应的类名。
***** controllerNamespace
   该属性指定控制器类默认的命名空间，默认为app\controllers。比如控制器ID为 post 默认对应 
   PostController （不带命名空间）， 类全名为 app\controllers\PostController。
   
   控制器类文件可能放在这个命名空间对应目录的子目录下， 例如，控制器ID admin/post 
   对应的控制器类全名为 app\controllers\admin\PostController。

   如果你想打破上述的规则，可以配置 controllerMap 属性。
***** language
   该属性指定应用展示给终端用户的语言，默认为 en 标识英文。
   该属性影响各种 国际化 ，包括信息翻译、日期格式、数字格式等。 例如 [[yii\jui\DatePicker]] 
   小部件会根据该属性展示对应语言的日历以及日期格式。

   推荐遵循 IETF language tag 来设置语言，例如 en 代表英文， en-US 代表英文(美国).
***** modules
      该属性指定应用所包含的 模块。
      该属性使用数组包含多个模块类 配置，数组的键为模块ID，例：
 #+BEGIN_SRC php
       [ 'modules' => [ 
           // "booking" 模块以及对应的类 
           'booking' => 'app\modules\booking\BookingModule',

           // "comment" 模块以及对应的配置数组
           'comment' => [
               'class' => 'app\modules\comment\CommentModule',
               'db' => 'db',
           ],
       ],
       ]
 #+END_SRC
***** name
      该属性指定你可能想展示给终端用户的应用名称，不同于需要唯一性的id 属性，
      该属性可以不唯一，该属性用于显示应用的用途。
      如果其他地方的代码没有用到，可以不配置该属性。
***** params
   该属性为一个数组，指定可以全局访问的参数，代替程序中硬编码的数字和字符，
   应用中的参数定义到一个单独的文件并随时可以访问是一个好习惯。 例如用参数定义缩略图的长宽如下：
 #+BEGIN_SRC php
        [ 
        'params' => [
            'thumbnail.size' => [
                128, 128],
                     ], 
          ]

 #+END_SRC

   然后简单的使用如下代码即可获取到你需要的长宽参数：
 #+BEGIN_SRC php
   $size = \Yii::$app->params['thumbnail.size']; 
   $width = \Yii::$app->params['thumbnail.size'][0];
 #+END_SRC

   以后想修改缩略图长宽，只需要修改该参数而不需要相关的代码。

***** sourceLanguage
   该属性指定应用代码的语言，默认为 'en-US' 标识英文（美国），如果应用不是英文请修改该属性。
   和 语言 属性类似，配置该属性需遵循 IETF language tag. 例如 en 代表英文， en-US 代表英文(美国)。
***** timeZone
   该属性提供一种方式修改PHP运行环境中的默认时区，配置该属性本质上就是调用PHP函数
   datedefaulttimezone_set()，例如：
   获取是datedefaulttimezone_get();
 #+BEGIN_SRC php
 [ 'timeZone' => 'America/Los_Angeles', ]
 #+END_SRC

***** version
      该属性指定应用的版本，默认为'1.0'，其他代码不使用的话可以不配置。
**** 实用属性
     本小节描述的属性不经常设置，通常使用系统默认值。如果你想改变默认值，可以配置这些属性。
***** charset
   该属性指定应用使用的字符集，默认值为 'UTF-8'，绝大部分应用都在使用，
   除非已有的系统大量使用非unicode数据才需要更改该属性。
***** defaultRoute
      如果动作ID没有指定，会使用defaultAction中指定的默认值。
****** web
   对于网页应用，默认值为 'site' 对应SiteController 控制器，并使用默认的动作。 因此你不带路由的访问应用，默认会显示 
   actionIndex() 的结果。
****** console
   对于控制台应用， 默认值为 'help'对应 HelpController::actionIndex()
   因此，如果执行的命令不带参数，默认会显示帮助信息。
***** extensions
   该属性用数组列表指定应用安装和使用的扩展，默认使用@vendor/yiisoft/extensions.php
   文件返回的数组。 当你使用 Composer 安装扩展，extensions.php 会被自动生成和维护更新。
   所以大多数情况下，不需要配置该属性。

   特殊情况下你想自己手动维护扩展，可以参照如下配置该属性：
 #+BEGIN_SRC php
   [ 'extensions' => [ 
       [ 
           'name' => 'extension name',
           'version' => 'version number',
           'bootstrap' => 'BootstrapClassName',
           // 可选配，可为配置数组 
           'alias' => [
               // 可选配 
               '@alias1' => 'to/path1', 
               '@alias2' => 'to/path2',
           ],
       ],
       // ... 更多像上面的扩展 ...
   ],
   ]
 #+END_SRC
   如上所示，该属性包含一个扩展定义数组，每个扩展为一个包含 name 和 version 项的数组。
   如果扩展要在 引导启动 阶段运行，需要配置 bootstrap以及对应的引导启动类名或 configuration 数组。
  扩展也可以定义 别名
***** layout
      该属性指定渲染 视图 默认使用的布局名字，默认值为 'main' 对应布局路径下的 main.php 文件，
      如果 布局路径 和 视图路径 都是默认值，默认布局文件可以使用路径别名@app/views/layouts/main.php
      如果不想设置默认布局文件，可以设置该属性为 false，这种做法比较罕见。
***** layoutPath
   该属性指定查找布局文件的路径，默认值为 视图路径 下的 layouts 子目录。 如果 视图路径
   使用默认值，默认的布局路径别名为@app/views/layouts。

   该属性需要配置成一个目录或 路径 别名。
***** runtimePath
   该属性指定临时文件如日志文件、缓存文件等保存路径，默认值为带别名的 @app/runtime。

   可以配置该属性为一个目录或者路径 别名，注意应用运行时有对该路径的写入权限， 
   以及终端用户不能访问该路径因为临时文件可能包含一些敏感信息。

   为了简化访问该路径，Yii预定义别名 @runtime 代表该路径。
***** viewPath
   该路径指定视图文件的根目录，默认值为带别名的 @app/views，可以配置它为一个目录或者路径 别名.
***** vendorPath
   该属性指定 Composer 管理的供应商路径，该路径包含应用使用的包括Yii框架在内的所有第三方库。
   默认值为带别名的 @app/vendor 。

   可以配置它为一个目录或者路径 别名，当你修改时，务必修改对应的 Composer 配置。

   为了简化访问该路径，Yii预定义别名 @vendor 代表该路径。

***** yii\console\Application::enableCoreCommands
      该属性仅控制台应用支持，
      用来指定是否启用Yii中的核心命令，默认值为 true。

**** 应用事件
     应用在处理请求过程中会触发事件，可以在配置文件配置事件处理代码，如下所示：
     #+BEGIN_SRC php
       [ 'on beforeRequest' => function ($event) {
                                 // ... 
                               }, 
         ]
     #+END_SRC
     on eventName 语法的用法在 Configurations 一节有详细描述.
     另外，在应用主体实例化后，你可以在引导启动 阶段附加事件处理代码，例如：
 #+BEGIN_SRC php
   \Yii::$app->on(\yii\base\Application::EVENT_BEFORE_REQUEST, 
   function ($event) { 
     // ... 
   });
 #+END_SRC

***** EVENTBEFOREREQUEST
      该事件在应用处理请求before之前，实际的事件名为 beforeRequest。
      在事件触发前，应用主体已经实例化并配置好了，所以通过事件机制将你的代码嵌入到请求处理过程中非常不错。 
      例如在事件处理中根据某些参数动态设置language语言属性。
 
***** EVENTAFTERREQUEST
   该事件在应用处理请求after之后但在返回响应before之前触发，实际的事件名为afterRequest。
   该事件触发时，请求已经被处理完，可以做一些请求后处理或自定义响应。
   注意 [[response]] 组件在发送响应给终端用户时也会触发一些事件，
   这些事件都在本事件after之后触发。

***** EVENTBEFOREACTION
   该事件在每个 控制器动作 运行before之前会被触发，实际的事件名为 beforeAction.
   事件的参数为一个 [[yii\base\ActionEvent]] 实例， 事件处理中可以设置[[yii\base\ActionEvent::isValid
   ]] 为 false 停止运行后续动作，例如：
 #+BEGIN_SRC php
           [ 'on beforeAction' => function ($event) { 
                                    if (some condition) {
                                      $event->isValid = false;
                                    } else { } 
                                  }, 
             ]
 #+END_SRC

   注意 模块 和 控制器 都会触发 beforeAction 事件。 应用主体对象首先触发该事件，然后模块触发（如果存在模块），最后控制器触发。 任何一个事件处理中设置 [[yii\base\ActionEvent::isValid]] 设置为 false 会停止触发后面的事件。

***** yii\base\Application::EVENTAFTERACTION
   该事件在每个 控制器动作 运行after之后会被触发，实际的事件名为 afterAction.
   该事件的参数为 [[yii\base\ActionEvent]] 实例，通过[[yii\base\ActionEvent::result]]属性，
   事件处理可以访问和修改动作的结果。例如：
 #+BEGIN_SRC php
           [ 'on afterAction' => function ($event) { 
                                   if (some condition) {
                                     // 修改 
                                     $event->result } 
                                   else { }
                                 }, 
             ]
 #+END_SRC

   注意 模块 和 控制器 都会触发 afterAction 事件。 这些对象的触发顺序和 beforeAction 相反，也就是说，控制器最先触发，然后是模块（如果有模块），最后为应用主体。

**** 应用主体生命周期
   当运行 入口脚本 处理请求时，应用主体会经历以下生命周期:
***** 入口脚本加载应用主体配置数组。
***** 入口脚本创建一个应用主体实例：
   调用 [[preInit()]] 配置几个高级别应用主体属性，比如[[basePath]]。
   注册 [[error handler]] 错误处理方法.
   配置应用主体属性.
   调用 init()初始化，该函数会调用bootstrap()运行引导启动组件.
***** 入口脚本调用 [[run()]] 运行应用主体:
   触发 [[EVENTBEFOREREQUEST]] 事件。
   处理请求：解析请求 路由 和相关参数；创建路由指定的模块、控制器和动作对应的类，并运行动作。
   触发 EVENTAFTERREQUEST事件。
   发送响应到终端用户.
   入口脚本接收应用主体传来的退出状态并完成请求的处理。
*** 应用组件
**** 访问组件    
 #+BEGIN_SRC php
  \Yii::$app->componentID
 #+END_SRC

  例如，可以使用 \Yii::$app->db 来获取到已注册到应用的 DB connection;
  使用 \Yii::$app->cache 来获取到已注册到应用的 [[yii\caching\Cache|primary cache]]。

  第一次使用以上表达式时候会创建应用组件实例，后续再访问会返回此实例，无需再次创建。
  应用组件可以是任意对象，可以在 应用主体配置 配置components 属性 .
  例如：
  #+BEGIN_SRC php
    [ 'components' => [ // 使用类名注册 "cache" 组件 'cache' => 'yii\caching\ApcCache',

        // 使用配置数组注册 "db" 组件
        'db' => [
            'class' => 'yii\db\Connection',
            'dsn' => 'mysql:host=localhost;dbname=demo',
            'username' => 'root',
            'password' => '',
                 ],

        // 使用函数注册"search" 组件
        'search' => function () {
            return new app\components\SolrService;
                    },
                        ],
      ] 
  #+END_SRC
**** 引导启动组件
  上面提到一个应用组件只会在第一次访问时实例化，如果处理请求过程没有访问的话就不实例化。 
  有时你想在每个请求处理过程都实例化某个组件即便它不会被访问，
  可以将该组件ID加入到应用主体的 bootstrap属性中。

  例如, 如下的应用主体配置保证了 log 组件一直被加载。
  #+BEGIN_SRC php
    [ 'bootstrap' => [
     // 将 log 组件 ID 加入引导让它始终载入
        'log',
                      ],
      'components' => [
          'log' => [ 
              // "log" 组件的配置 
                     ],
                       ],
      ]
  #+END_SRC

**** 核心应用组件
     下面是预定义的核心应用组件列表，可以和普通应用组件一样配置和自定义它们。
***** [[yii\web\AssetManager]]: 管理资源包和资源发布，详情请参考 管理资源 一节。
***** [[yii\db\Connection|db]]: 代表一个可以执行数据库操作的数据库连接， 注意配置该组件时必须指定组件类名和其他相关组件属性，如[[yii\db\Connection::dsn]]。 详情请参考 数据访问对象 一节。
***** [[yii\base\Application::errorHandler]]: 处理 PHP 错误和异常， 详情请参考 错误处理 一节。
***** [[yii\i18n\Formatter]]: 格式化输出显示给终端用户的数据，例如数字可能要带分隔符， 日期使用长格式。详情请参考 格式化输出数据 一节。
***** [[yii\i18n\I18N]]: 支持信息翻译和格式化。详情请参考 国际化 一节。
***** [[yii\log\Dispatcher|log]]: 管理日志对象。详情请参考 日志 一节。
***** [[yii\swiftmailer\Mailer]]: 支持生成邮件结构并发送，详情请参考 邮件 一节。
***** [[yii\base\Application::response]]: 代表发送给用户的响应， 详情请参考 响应 一节。
***** [[yii\base\Application::request]]: 代表从终端用户处接收到的请求， 详情请参考 请求 一节。
***** [[yii\web\Session]]: 代表会话信息，仅在[[Web applications]] 网页应用中可用， 详情请参考 Sessions (会话) and Cookies 一节。
***** [[yii\web\UrlManager]]: 支持URL地址解析和创建， 详情请参考 URL 解析和生成 一节。
***** [[yii\web\User]]: 代表认证登录用户信息，仅在[[yii\web\Application|Web applications]] 网页应用中可用， 详情请参考 认证 一节。
***** [[yii\web\View]]: 支持渲染视图，详情请参考 Views 一节。
*** 控制器（Controllers）
    控制器是 MVC 模式中的一部分， 是继承[[yii\base\Controller]]类的对象，负责处理请求和生成响应。
**** 操作定义
  #+BEGIN_SRC php
    namespace app\controllers;
    use Yii;
    use app\models\Post; 
    use yii\web\Controller; 
    use yii\web\NotFoundHttpException;

    class PostController extends Controller { 
      public function actionView($id) { 
               $model = Post::findOne($id); 
               if ($model === null) { 
                 throw new NotFoundHttpException; }

               return $this->render('view', [
                 'model' => $model,
             ]);
             }

         public function actionCreate()
         {
             $model = new Post;

             if ($model->load(Yii::$app->request->post()) && $model->save()) {
                 return $this->redirect(['view', 'id' => $model->id]);
             } else {
                 return $this->render('create', [
                     'model' => $model,
                 ]);
             }
         }
    } 
  #+END_SRC
  在操作 view (定义为 actionView() 方法)中， 代码首先根据请求模型ID加载 模型， 如果加载成功，
  会渲染名称为view的视图并显示，否则会抛出一个异常。

  在操作 create (定义为 actionCreate() 方法)中, 代码相似. 先将请求数据填入模型， 然后保存模型，
  如果两者都成功，会跳转到ID为新创建的模型的view操作，否则显示提供用户输入的create视图。
**** 路由
     http://hostname/index.php/site/index
     路由格式: ControllerID/ActionID
     如果属于模块下的控制器，使用： ModuleID/ControllerID/ActionID

     如果用户的请求地址为 http://hostname/index.php?r=site/index, 
     会执行site 控制器的index 操作。
  更多关于处理路由的详情请参阅 路由 一节。
**** 创建控制器
     在网页应用中，控制器应继承[[yii\web\Controller]] 或它的子类。
     在控制台应用中，控制器继承[[yii\console\Controller]] 或它的子类。 
     
     如下代码定义一个 site 控制器:
  #+BEGIN_SRC php
     namespace app\controllers;
     use yii\web\Controller;
     class SiteController extends Controller {

     } 
  #+END_SRC
***** 控制器ID
     控制器ID应仅包含英文小写字母、数字、下划线、中横杠和正斜杠， 例如 article 和
     post-comment 是真是的控制器ID，article?, PostComment, admin\post不是控制器ID。

     控制器Id可包含子目录前缀，例如 admin/article 代表controllerNamespace控制器命名空间下 
     admin子目录中 article 控制器。 子目录前缀可为英文大小写字母、数字、下划线、正斜杠，其中正斜杠
     用来区分多级子目录(如 panels/admin)。
***** 控制器类命名
      #+BEGIN_SRC php
        article 对应 app\controllers\ArticleController;
        post-comment 对应 app\controllers\PostCommentController;
        admin/post-comment 对应 app\controllers\admin\PostCommentController;
        adminPanels/post-comment 对应 app\controllers\adminPanels\PostCommentController.
        控制器类必须能被 自动加载，所以在上面的例子中， 控制器article 类应在 别名 
        为@app/controllers/ArticleController.php的文件中定义， 控制器admin/post-comment
        应在@app/controllers/admin/PostCommentController.php文件中。

        Info: 最后一个示例 admin/post-comment 表示你可以将控制器放在
        [[yii\base\Application::controllerNamespace]]控制器命名空间下的子目录中，
        在你不想用 模块 的情况下给控制器分类，这种方式很有用。

      #+END_SRC
***** 控制器部署
  可通过配置 [[controllerMap]] 来强制上述的控制器ID和类名对应，通常用在使用第三方不能掌控类名的控制器上。

  #+BEGIN_SRC php
      [ 'controllerMap' => [ 
          // 用类名申明 "account" 控制器 
          'account' => 'app\controllers\UserController',

          // 用配置数组申明 "article" 控制器
          'article' => [
              'class' => 'app\controllers\PostController',
              'enableCsrfValidation' => false,
          ],
      ],
      ] 
  #+END_SRC

***** 默认控制器
  可以在 应用配置 中修改默认控制器，如下所示：
  #+BEGIN_SRC php
 [ 'defaultRoute' => 'main', ]
  #+END_SRC
**** 创建操作
  操作方法必须是以action开头的公有方法
  操作方法的返回值会作为响应数据发送给终端用户，如下代码定义了两个操作 index 和 hello-world:
  #+BEGIN_SRC php
    namespace app\controllers;
    use yii\web\Controller;

    class SiteController extends Controller {
      public function actionIndex() {
               return $this->render('index');
             }

        public function actionHelloWorld()
        {
            return 'Hello World';
        }
    }
  #+END_SRC

  例如index 转成 actionIndex, hello-world 转成 actionHelloWorld。
***** 独立操作
  独立操作通过继承[[yii\base\Action]]或它的子类来定义。 
  例如Yii发布的[[yii\web\ViewAction]]和[[yii\web\ErrorAction]]都是独立操作。

  要使用独立操作，需要通过在控制器中覆盖[[actions()]]方法
  #+BEGIN_SRC php
    public function actions() {
        return [ 
            // 用类来申明"error" 操作 
            'error' => 'yii\web\ErrorAction',

            // 用配置数组申明 "view" 操作
            'view' => [
                'class' => 'yii\web\ViewAction',
                'viewPrefix' => '',
            ],
        ];
    } 
  #+END_SRC
  
  如上所示， actions() 方法返回键为操作ID、值为对应操作类名或数组configurations 的数组。
  和内联操作不同，独立操作ID可包含任意字符，只要在actions() 方法中申明.

  为创建一个独立操作类，需要继承[[yii\base\Action]] 或它的子类，并实现公有的名称为run()的方法, 
  run() 方法的角色和操作方法类似，例如：

  #+BEGIN_SRC php
    use yii\base\Action;

    class HelloWorldAction extends Action {
     public function run() {
              return "Hello World"; } 
    } 
  #+END_SRC
***** 操作结果
  操作方法或独立操作的run()方法的返回值非常重要，它表示对应操作结果。

  返回值可为 响应 对象，作为响应发送给终端用户。

  对于网页应用，返回值可为任意数据, 它赋值给[[yii\web\Response::data]]， 最终转换为字符串来展示响应内容。
  对于控制台应用，返回值可为整数， 表示命令行下执行的 yii\console\Response::exitStatus退出状态。
  
 #+BEGIN_SRC php
     public function actionForward()
   {
       // 用户浏览器跳转到 http://example.com
       return $this->redirect('http://example.com');
   }

 #+END_SRC 

   返回响应对象 （因为redirect()方法返回一个响应对象）可将用户浏览器跳转到新的URL。
***** 操作参数
      对于网页应用， 每个操作参数的值从$_GET中获得，参数名作为键； 
      对于控制台应用, 操作参数对应命令行参数。

  如下例，操作view (内联操作) 申明了两个参数 $id 和 $version。
 #+BEGIN_SRC php
   namespace app\controllers;

   use yii\web\Controller;

   class PostController extends Controller { 
     public function actionView($id, $version = null)
            { 
              // ... 
            } 
   } 
 #+END_SRC
  操作参数会被不同的参数填入，如下所示：
#+BEGIN_SRC php
  http://hostname/index.php?r=post/view&id=123: $id 会填入'123'，$version 仍为 null 空因为没有version请求参数;
  http://hostname/index.php?r=post/view&id=123&version=2: $id 和 $version 分别填入 '123' 和 '2'；
  http://hostname/index.php?r=post/view: 会抛出[[yii\web\BadRequestHttpException]] 异常 因为请求没有提供参数给必须赋值参数$id；
  http://hostname/index.php?r=post/view&id[]=123: 会抛出[[yii\web\BadRequestHttpException]] 异常 因为$id 参数收到数字值 ['123']而不是字符串.
#+END_SRC

 如果想让操作参数接收数组值，需要指定$id为array，如下所示：
#+BEGIN_SRC php
public function actionView(array $id, $version = null)
{
    // ...
}
#+END_SRC

  如果请求为 http://hostname/index.php?r=post/view&id[]=123, 参数$id会使用数组值['123']
  如果请求为 http://hostname/index.php?r=post/view&id=123， 参数 $id 会获取相同数组值，因为无类型的'123'会自动转成数组。

***** 默认操作
  每个控制器都有一个由defaultAction属性指定的默认操作， 
  当路由 只包含控制器ID，会使用所请求的控制器的默认操作。

  默认操作默认为 index，如果想修改默认操作，只需简单地在控制器类中覆盖这个属性，如下所示：
 #+BEGIN_SRC php
   namespace app\controllers;

    use yii\web\Controller;

    class SiteController extends Controller {

        public $defaultAction = 'home';

        public function actionHome()
        {
            return $this->render('home');
        }
    }
 #+END_SRC
**** 控制器生命周期
     处理一个请求时，应用主体 会根据请求路由创建一个控制器，控制器经过以下生命周期来完成请求：
     在控制器创建和配置后，[[yii\base\Controller::init()]] 方法会被调用。
     控制器根据请求操作ID创建一个操作对象:
     如果操作ID没有指定，会使用[[yii\base\Controller::defaultAction]]默认操作ID；
     如果在[[yii\base\Controller::actions()]]找到操作ID，会创建一个独立操作；
     如果操作ID对应操作方法，会创建一个内联操作；
     否则会抛出[[yii\base\InvalidRouteException]]异常。
     控制器按顺序调用应用主体、模块（如果控制器属于模块）、控制器的 beforeAction() 方法；
     如果任意一个调用返回false，后面未调用的beforeAction()会跳过并且操作执行会被取消；
     默认情况下每个 beforeAction() 方法会触发一个 beforeAction 事件，
     在事件中你可以追加事件处理操作；
     控制器执行操作:
     请求数据解析和填入到操作参数；
     控制器按顺序调用控制器、模块（如果控制器属于模块）、应用主体的 afterAction() 方法；
     默认情况下每个 afterAction() 方法会触发一个 afterAction 事件，在事件中你可以追加事件处理操作；
     应用主体获取操作结果并赋值给响应.
*** 模型（Models）
    模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。
    可通过继承 [[yii\base\Model]] 或它的子类定义模型类，基类[[yii\base\Model]]支持许多实用的特性：
**** 属性
  模型通过 属性 来代表业务数据，每个属性像是模型的公有可访问属性，attributes()指定模型所拥有的属性。
***** 访问
  可像访问一个对象属性一样访问模型的属性:
  #+BEGIN_SRC php
    $model = new \app\models\ContactForm;

    // "name" 是ContactForm模型的属性 
    $model->name = 'example'; 
    echo $model->name; 
  #+END_SRC
  
  也可像访问数组单元项一样访问属性，这要感谢[[yii\base\Model]]支持 ArrayAccess 数组访问 和 
  ArrayIterator 数组迭代器:
 #+BEGIN_SRC php
 $model = new \app\models\ContactForm;

 // 像访问数组单元项一样访问属性
 $model['name'] = 'example';
 echo $model['name'];

 // 迭代器遍历模型
 foreach ($model as $name => $value) {
     echo "$name: $value\n";
 }

 #+END_SRC
***** 定义属性
      默认情况下你的模型类直接从[[yii\base\Model]]继承，所有非静态公有成员变量都是属性。
      
      例如，下述ContactForm 模型类有四个属性name, email, subject and body，
      ContactForm 模型用来代表从HTML表单获取的输入数据。
 #+BEGIN_SRC php
 namespace app\models;

 use yii\base\Model;

 class ContactForm extends Model
 {
     public $name;
     public $email;
     public $subject;
     public $body;
 }

 #+END_SRC
 
  另一种方式是可覆盖attributes()来定义属性，该方法返回模型的属性名。
  例如 [[yii\db\ActiveRecord]] 返回对应数据表列名作为它的属性名， 注意可能需要覆盖魔术方法如__get(), 
 __set()使属性像普通对象属性被访问。

***** 属性标签
  当属性显示或获取输入时，经常要显示属性相关标签，例如假定一个属性名为firstName，
  在某些地方如表单输入或错误信息处，你可能想显示对终端用户来说更友好的 First Name 标签。
****** 默认标签显示
  可以调用 [[yii\base\Model::getAttributeLabel()]] 获取属性的标签，例如：
 #+BEGIN_SRC php
    $model = new \app\models\ContactForm;

    // 显示为 "Name" 
   echo $model->getAttributeLabel('name'); 
 #+END_SRC

  默认情况下，属性标签通过[[yii\base\Model::generateAttributeLabel()]]方法自动从属性名生成.
  它会自动将驼峰式大小写变量名转换为多个首字母大写的单词，例如 username 转换为 Username，
  firstName 转换为 First Name。
****** 自定义标签显示
  如果你不想用自动生成的标签，可以覆盖 [[yii\base\Model::attributeLabels()]] 方法明确指定属性标签，例如：
  #+BEGIN_SRC php
    namespace app\models;

    use yii\base\Model;

    class ContactForm extends Model { 
        public $name; 
        public $email;
        public $subject;
        public $body;

    public function attributeLabels()
    {
        return [
            'name' => 'Your name',
            'email' => 'Your email address',
            'subject' => 'Subject',
            'body' => 'Content',
        ];
    }
    }
  #+END_SRC

***** 多语言
      应用支持多语言的情况下，可翻译属性标签， 可在attributeLabels()方法中定义，如下所示:
#+BEGIN_SRC php
public function attributeLabels()
{
    return [
        'name' => \Yii::t('app', 'Your name'),
        'email' => \Yii::t('app', 'Your email address'),
        'subject' => \Yii::t('app', 'Subject'),
        'body' => \Yii::t('app', 'Content'),
    ];
}
#+END_SRC

  甚至可以根据条件定义标签，例如通过使用模型的 scenario场景， 可对相同的属性返回不同的标签。

  Info: 属性标签是 视图一部分，但是在模型中申明标签通常非常方便，并可行程非常简洁可重用代码。
**** 场景
  模型可能在多个场景下使用，例如 User 模块可能会在收集用户登录输入，也可能会在用户注册时使用。
  在不同的场景下，模型可能会使用不同的业务规则和逻辑，例如email属性在注册时强制要求有，但在登陆时不需要。

  模型使用scenario属性保持使用场景的跟踪， 默认情况下，模型支持一个名为 default的场景，
  如下展示两种设置场景的方法:
#+BEGIN_SRC php
// 场景作为属性来设置
$model = new User;
$model->scenario = 'login';

// 场景通过构造初始化配置来设置
$model = new User(['scenario' => 'login']);

#+END_SRC

  默认情况下，模型支持的场景由模型中申明的 验证规则来决定，但你可以通过覆盖[[scenarios()]]方法来自定义行为，如下所示：
#+BEGIN_SRC php
namespace app\models;

use yii\db\ActiveRecord;

class User extends ActiveRecord
{
    public function scenarios()
    {
        return [
            'login' => ['username', 'password'],
            'register' => ['username', 'email', 'password'],
        ];
    }
}
#+END_SRC

Info: 在上述和下述的例子中，模型类都是继承[[yii\db\ActiveRecord]]， 因为多场景的使用通常发生在Active Record 类中.
scenarios() 方法返回一个数组，数组的键为场景名，值为对应的 active attributes活动属性。
活动属性可被 块赋值 并遵循验证规则 在上述例子中，username 和 password 在login场景中启用，
在 register 场景中, 除了 username and password 外 email 也被启用。

  scenarios() 方法默认实现会返回所有[[yii\base\Model::rules()]]方法申明的验证规则中的场景，
 当覆盖scenarios()时，如果你想在默认场景外使用新场景，可以编写类似如下代码：
#+BEGIN_SRC php
namespace app\models;

use yii\db\ActiveRecord;

class User extends ActiveRecord
{
    public function scenarios()
    {
        $scenarios = parent::scenarios();
        $scenarios['login'] = ['username', 'password'];
        $scenarios['register'] = ['username', 'email', 'password'];
        return $scenarios;
    }
}
#+END_SRC
场景特性主要在验证 和 属性块赋值 中使用。 你也可以用于其他目的，例如可基于不同的场景定义不同的 属性标签。

**** 验证规则
  当模型接收到终端用户输入的数据，数据应当满足某种规则(称为 验证规则, 也称为 业务规则)。
  例如假定ContactForm模型，你可能想确保所有属性不为空且 email 属性包含一个有效的邮箱地址，
  如果某个属性的值不满足对应的业务规则，相应的错误信息应显示，以帮助用户修正错误。

  可调用validate()来验证接收到的数据， 该方法使用rules()申明的验证规则来验证每个相关属性，
  如果没有找到错误，会返回 true，否则它会将错误保存在 errors属性中并返回false，例如：
#+BEGIN_SRC php
$model = new \app\models\ContactForm;

// 用户输入数据赋值到模型属性
$model->attributes = \Yii::$app->request->post('ContactForm');

if ($model->validate()) {
    // 所有输入数据都有效 all inputs are valid
} else {
    // 验证失败：$errors 是一个包含错误信息的数组
    $errors = $model->errors;
}

#+END_SRC

  通过覆盖rules()方法指定模型属性应该满足的规则来申明模型相关验证规则。 
  下述例子显示ContactForm模型申明的验证规则:
  
#+BEGIN_SRC php
public function rules()
{
    return [
        // name, email, subject 和 body 属性必须有值
        [['name', 'email', 'subject', 'body'], 'required'],

        // email 属性必须是一个有效的电子邮箱地址
        ['email', 'email'],
    ];
}
#+END_SRC

    一条规则可用来验证一个或多个属性，一个属性可对应一条或多条规则。 
    更多关于如何申明验证规则的详情请参考 验证输入 一节.

  有时你想一条规则只在某个 场景 下应用，为此你可以指定规则的 on 属性，如下所示:
#+BEGIN_SRC php
public function rules()
{
    return [
        // 在"register" 场景下 username, email 和 password 必须有值
        [['username', 'email', 'password'], 'required', 'on' => 'register'],

        // 在 "login" 场景下 username 和 password 必须有值
        [['username', 'password'], 'required', 'on' => 'login'],
    ];
}
#+END_SRC
  如果没有指定 on 属性，规则会在所有场景下应用， 在当前[[scenario]] 下应用的规则称之为 active rule活动规则。
  一个属性只会属于scenarios()中定义的活动属性且在rules()申明对应一条或多条活动规则的情况下被验证。

**** 块赋值
  块赋值只用一行代码将用户所有输入填充到一个模型，非常方便， 它直接将输入数据对应填充到attributes属性。
  以下两段代码效果是相同的，都是将终端用户输入的表单数据赋值到 ContactForm 模型的属性，
  明显地前一段块赋值的代码比后一段代码简洁且不易出错。
#+BEGIN_SRC php
$model = new \app\models\ContactForm;
$model->attributes = \Yii::$app->request->post('ContactForm');
#+END_SRC

#+BEGIN_SRC php
$model = new \app\models\ContactForm;
$data = \Yii::$app->request->post('ContactForm', []);
$model->name = isset($data['name']) ? $data['name'] : null;
$model->email = isset($data['email']) ? $data['email'] : null;
$model->subject = isset($data['subject']) ? $data['subject'] : null;
$model->body = isset($data['body']) ? $data['body'] : null;

#+END_SRC
**** 安全属性
  块赋值只应用在模型当前场景scenarios()方法 列出的称之为 安全属性 的属性上，
  例如，如果User模型申明以下场景， 当当前场景为login时候，只有username and password 
  可被块赋值，其他属性不会被赋值。
#+BEGIN_SRC php
public function scenarios()
{
    return [
        'login' => ['username', 'password'],
        'register' => ['username', 'email', 'password'],
    ];
}
#+END_SRC

  Info: 块赋值只应用在安全属性上，因为你想控制哪些属性会被终端用户输入数据所修改， 例如，如果 User
  模型有一个permission属性对应用户的权限， 你可能只想让这个属性在后台界面被管理员修改。

  由于默认scenarios()的实现会返回[[rules()]]所有属性和数据， 如果不覆盖这个方法，
表示所有只要出现在活动验证规则中的属性都是安全的。

  为此，提供一个特别的别名为 safe 的验证器来申明哪些属性是安全的不需要被验证， 如下示例的规则申明
  title 和 description 都为安全属性。
#+BEGIN_SRC php
public function rules()
{
    return [
        [['title', 'description'], 'safe'],
    ];
}
#+END_SRC

**** 非安全属性
  如上所述，scenarios()方法提供两个用处：定义哪些属性应被验证，定义哪些属性安全。
 在某些情况下，你可能想验证一个属性但不想让他是安全的，可在scenarios()方法中属性名加一个惊叹号 !。
 例如像如下的secret属性。
#+BEGIN_SRC php
public function scenarios()
{
    return [
        'login' => ['username', 'password', '!secret'],
    ];
}
#+END_SRC

  当模型在 login 场景下，三个属性都会被验证，但只有 username和 password 属性会被块赋值，
 要对secret属性赋值，必须像如下例子明确对它赋值。
#+BEGIN_SRC php
  $model->secret = $secret;
#+END_SRC
**** 数据导出
  模型通常要导出成不同格式，例如，你可能想将模型的一个集合转成JSON或Excel格式，
 导出过程可分解为两个步骤，第一步，模型转换成数组；第二步，数组转换成所需要的格式。
 你只需要关注第一步，因为第二步可被通用的数据转换器如[[JsonResponseFormatter]]来完成。

  将模型转换为数组最简单的方式是使用 [[attributes]] 属性，例如：

  #+BEGIN_SRC php
    $post = \app\models\Post::findOne(100);
    $array = $post->attributes;
  #+END_SRC

  attributes属性会返回 所有attributes()申明的属性的值。

  更灵活和强大的将模型转换为数组的方式是使用toArray()方法， 它的行为默认和
  attributes相同， 但是它允许你选择哪些称之为字段的数据项放入到结果数组中并同时被格式化。
  实际上，它是导出模型到 RESTful 网页服务开发的默认方法，详情请参阅响应格式.

**** 字段
  字段是模型通过调用toArray()生成的数组的单元名。
  默认情况下，字段名对应属性名，但是你可以通过覆盖 fields()和/或 extraFields()方法来改变这种行为，
  两个方法都返回一个字段定义列表，fields() 方法定义的字段是默认字段，表示toArray()方法默认会返回这些字段。
  extraFields()方法定义额外可用字段，通过toArray()方法指定$expand参数来返回这些额外可用字段。 
  例如如下代码会返回fields()方法定义的所有字段和extraFields()方法定义的prettyName and
  fullAddress字段。
#+BEGIN_SRC php
  $array = $model->toArray([], ['prettyName', 'fullAddress']);
#+END_SRC

  可通过覆盖 fields() 来增加、删除、重命名和重定义字段，fields() 方法返回值应为数组， 数组的键为字段名，
数组的值为对应的可为属性名或匿名函数返回的字段定义对应的值。 特使情况下，如果字段名和属性定义名相同，
可以省略数组键，例如：
#+BEGIN_SRC php
// 明确列出每个字段，特别用于你想确保数据表或模型属性改变不会导致你的字段改变(保证后端的API兼容).
public function fields()
{
    return [
        // 字段名和属性名相同
        'id',

        // 字段名为 "email"，对应属性名为 "email_address"
        'email' => 'email_address',

        // 字段名为 "name", 值通过PHP代码返回
        'name' => function () {
            return $this->first_name . ' ' . $this->last_name;
        },
    ];
}

// 过滤掉一些字段，特别用于你想继承父类实现并不想用一些敏感字段
public function fields()
{
    $fields = parent::fields();

    // 去掉一些包含敏感信息的字段
    unset($fields['auth_key'], $fields['password_hash'], $fields['password_reset_token']);

    return $fields;
}

#+END_SRC
  Warning: 由于模型的所有属性会被包含在导出数组，最好检查数据确保没包含敏感数据， 如果有敏感数据，
应覆盖 fields() 方法过滤掉，在上述列子中，我们选择过滤掉 auth_key, password_hash and 
password_reset_token。

**** 最佳实践
  模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用， 在一个设计良好的应用中，模型通常比控制器代码多。

  归纳起来，模型

  可包含属性来展示业务数据;
  可包含验证规则确保数据有效和完整;
  可包含方法实现业务逻辑;
  不应直接访问请求，session和其他环境数据，这些数据应该由控制器传入到模型;
  应避免嵌入HTML或其他展示代码，这些代码最好在 视图中处理;
  单个模型中避免太多的 场景.
  在开发大型复杂系统时应经常考虑最后一条建议， 在这些系统中，模型会很大并在很多地方使用，因此会包含需要规则集和业务逻辑， 最后维护这些模型代码成为一个噩梦，因为一个简单修改会影响好多地方， 为确保模型好维护，最好使用以下策略：

  定义可被多个 应用主体 或 模块 共享的模型基类集合。 这些模型类应包含通用的最小规则集合和逻辑。
  在每个使用模型的 应用主体 或 模块中， 通过继承对应的模型基类来定义具体的模型类，具体模型类包含应用主体或模块指定的规则和逻辑。
  例如，在高级应用模板，你可以定义一个模型基类common\models\Post， 然后在前台应用中，定义并使用一个继承common\models\Post的具体模型类frontend\models\Post， 在后台应用中可以类似地定义backend\models\Post。 通过这种策略，你清楚frontend\models\Post只对应前台应用，如果你修改它，就无需担忧修改会影响后台应用。
*** 视图（Views）
    视图是 MVC 模式中的一部分。 它是展示数据到终端用户的代码，在网页应用中，根据视图模板来创建视图，
    视图模板为PHP脚本文件， 主要包含HTML代码和展示类PHP代码，通过[[yii\web\View]]应用组件来管理，
    该组件主要提供通用方法帮助视图构造和渲染，简单起见，我们称视图模板或视图模板文件为视图。
**** 创建视图
  如前所述，视图为包含HTML和PHP代码的PHP脚本，如下代码为一个登录表单的视图， 
  可看到PHP代码用来生成动态内容如页面标题和表单，HTML代码把它组织成一个漂亮的HTML页面。
  #+BEGIN_SRC php
    <?php
    use yii\helpers\Html;
    use yii\widgets\ActiveForm;

    /* @var $this yii\web\View */
    /* @var $form yii\widgets\ActiveForm */
    /* @var $model app\models\LoginForm */

    $this->title = 'Login';
    ?>
    <h1><?= Html::encode($this->title) ?></h1>

    <p>Please fill out the following fields to login:</p>

    <?php $form = ActiveForm::begin(); ?>
        <?= $form->field($model, 'username') ?>
        <?= $form->field($model, 'password')->passwordInput() ?>
        <?= Html::submitButton('Login') ?>
    <?php ActiveForm::end(); ?>
  #+END_SRC

  在视图中，可访问 $this 指向 [[yii\web\View]] 来管理和渲染这个视图文件。
  除了 $this之外，上述示例中的视图有其他预定义变量如 $model，
  这些变量代表从控制器或其他触发视图渲染的对象 传入 到视图的数据。

  Tip: 将预定义变量列到视图文件头部注释处，这样可被IDE编辑器识别，也是生成视图文档的好方法。
***** 安全
      当创建生成HTML页面的视图时，在显示之前将用户输入数据进行转码和过滤非常重要， 
      否则，你的应用可能会被跨站脚本 攻击。

      要显示纯文本，先调用 [[yii\helpers\Html::encode()]] 进行转码，例如如下代码将用户名在显示前先转码：

  #+BEGIN_SRC php
  <?php
  use yii\helpers\Html;
  ?>

  <div class="username">
      <?= Html::encode($user->name) ?>
  </div>

  #+END_SRC

  要显示HTML内容，先调用 [[yii\helpers\HtmlPurifier]] 过滤内容，例如如下代码将提交内容在显示前先过滤
  #+BEGIN_SRC php
  <?php
  use yii\helpers\HtmlPurifier;
  ?>

  <div class="post">
      <?= HtmlPurifier::process($post->text) ?>
  </div>
  #+END_SRC
  Tip: HTMLPurifier在保证输出数据安全上做的不错，但性能不佳，如果你的应用需要高性能可考虑 缓存 
  过滤后的结果。

***** 组织视图
     与 控制器 和 模型 类似，在组织视图上有一些约定：

     控制器渲染的视图文件默认放在 @app/views/ControllerID 目录下， 其中 ControllerID 对应 
     控制器 ID, 例如控制器类为 PostController，视图文件目录应为 @app/views/post， 控制器类 
     PostCommentController对应的目录为 @app/views/post-comment， 如果是模块中的控制器，目录应为
     [[yii\base\Module::basePath|module directory]] 模块目录下的 views/ControllerID 目录；
     对于 小部件 渲染的视图文件默认放在 WidgetPath/views 目录， 其中 WidgetPath 代表小部件类文件所在的目录；
     对于其他对象渲染的视图文件，建议遵循和小部件相似的规则。
     可覆盖控制器或小部件的 [[yii\base\ViewContextInterface::getViewPath()]] 
     方法来自定义视图文件默认目录。

**** 渲染视图
     可在 控制器, 小部件, 或其他地方调用渲染视图方法来渲染视图， 该方法类似以下格式：
  #+BEGIN_SRC php
    /**
     ,* @param string $view 视图名或文件路径，由实际的渲染方法决定
     ,* @param array $params 传递给视图的数据
     ,* @return string 渲染结果
     ,*/
    methodName($view, $params = [])

  #+END_SRC
***** 控制器中渲染
     在 控制器 中，可调用以下控制器方法来渲染视图：
****** yii\base\Controller::render()
       渲染一个 视图名 并使用一个 布局 返回到渲染结果。
****** yii\base\Controller::renderPartial()
       渲染一个 视图名 并且不使用布局。
****** yii\web\Controller::renderAjax()
       渲染一个 视图名 并且不使用布局， 并注入所有注册的JS/CSS脚本和文件，通常使用在响应AJAX网页请求的情况下。
****** yii\base\Controller::renderFile()
       渲染一个视图文件目录或别名下的视图文件。
****** 例子
      #+BEGIN_SRC php
        namespace app\controllers;

        use Yii;
        use app\models\Post;
        use yii\web\Controller;
        use yii\web\NotFoundHttpException;

        class PostController extends Controller
        {
            public function actionView($id)
            {
                $model = Post::findOne($id);
                if ($model === null) {
                    throw new NotFoundHttpException;
                }

                // 渲染一个名称为"view"的视图并使用布局
                return $this->render('view', [
                    'model' => $model,
                ]);
            }
        }
      #+END_SRC 
***** 小部件中渲染
      在 小部件 中，可调用以下小部件方法来渲染视图：

****** yii\base\Widget::render()渲染一个 视图名。
****** yii\base\Widget::renderFile()
  渲染一个视图文件目录或别名下的视图文件。
****** 例如：
  #+BEGIN_SRC php
  namespace app\components;

  use yii\base\Widget; use yii\helpers\Html;

  class ListWidget extends Widget { public $items = [];

  public function run()
  {
      // 渲染一个名为 "list" 的视图
      return $this->render('list', [
          'items' => $this->items,
      ]);
  }
  }
  #+END_SRC

***** 视图中渲染
  可以在视图中渲染另一个视图，可以调用[[yii\base\View|view component]]视图组件提供的以下方法：
****** yii\base\View::render() 渲染一个 视图名.
****** yii\web\View::renderAjax()
       渲染一个 视图名 并注入所有注册的JS/CSS脚本和文件，通常使用在响应AJAX网页请求的情况下。
****** yii\base\View::renderFile()
       渲染一个视图文件目录或别名下的视图文件。
       例如，视图中的如下代码会渲染该视图所在目录下的 _overview.php 视图文件， 记住视图中 $this 对应 [[yii\base\View|view]] 组件:

  php <?= $this->render('_overview') ?>
***** 其他地方渲染
  在任何地方都可以通过表达式 Yii::$app->view 访问 [[yii\base\View|view]] 应用组件， 调用它的如前所述的方法渲染视图，例如：

  php // 显示视图文件 "@app/views/site/license.php" echo \Yii::$app->view->renderFile('@app/views/site/license.php');

***** 视图名
      渲染视图时，可指定一个视图名或视图文件路径/别名，大多数情况下使用前者因为前者简洁灵活，
      我们称用名字的视图为 视图名.

      视图名可以依据以下规则到对应的视图文件路径：

      视图名可省略文件扩展名，这种情况下使用 .php 作为扩展， 视图名 about 对应到 about.php 文件名
      视图名以双斜杠 // 开头，对应的视图文件路径为 @app/views/ViewName， 也就是说视图文件在
      [[yii\base\Application::viewPath]] 路径下找， 例如 //site/about 对应到 @app/views/site/about.php。
    
      视图名以单斜杠/开始，视图文件路径以当前使用模块 的[[yii\base\Module::viewPath]]开始，
      如果不存在模块，使用@app/views/ViewName开始，例如，如果当前模块为user， /user/create 对应成 
      @app/modules/user/views/user/create.php, 如果不在模块中，/user/create对应
      @app/views/user/create.php。
    
      如果 [[yii\base\View::context|context]] 渲染视图 并且上下文实现了
      [[yii\base\ViewContextInterface]], 视图文件路径由上下文的 [[yii\base\ViewContextInterface::getViewPath()]] 
      开始， 这种主要用在控制器和小部件中渲染视图，例如 如果上下文为控制器SiteController，site/about
      对应到 @app/views/site/about.php。
    
      如果视图渲染另一个视图，包含另一个视图文件的目录以当前视图的文件路径开始， 例如被视图@app/views/post/index.php 
      渲染的 item 对应到 @app/views/post/item。
    
      根据以上规则，在控制器中 app\controllers\PostController 调用 $this->render('view')， 实际上渲染
      @app/views/post/view.php 视图文件，当在该视图文件中调用 $this->render('_overview') 会渲染
      @app/views/post/_overview.php 视图文件。
***** 视图中访问数据
  在视图中有两种方式访问数据：推送和拉取。

****** 推送方式是通过视图渲染方法的第二个参数传递数据，数据格式应为名称-值的数组， 视图渲染时，
  调用PHP extract() 方法将该数组转换为视图可访问的变量。 例如，如下控制器的渲染视图代码推送2个变量到 
  report 视图：$foo = 1 和 $bar = 2。
  #+BEGIN_SRC php
  echo $this->render('report', [
      'foo' => 1,
      'bar' => 2,
  ]);

  #+END_SRC

****** 拉取方式可让视图从[[yii\base\View]]视图组件或其他对象中主动获得数据(如Yii::$app)，
       在视图中使用如下表达式$this->context可获取到控制器ID， 可让你在report视图中获取
  控制器的任意属性或方法，如以下代码获取控制器ID。

  #+BEGIN_SRC php
  The controller ID is: <?= $this->context->id ?>
  #+END_SRC

  推送方式让视图更少依赖上下文对象，是视图获取数据优先使用方式， 缺点是需要手动构建数组，有些繁琐，
  在不同地方渲染时容易出错。

***** 视图间共享数据
  [[yii\base\View]]视图组件提供[[yii\base\View::params]]参数属性来让不同视图共享数据。

  例如在about视图中，可使用如下代码指定当前breadcrumbs的当前部分。
  #+BEGIN_SRC php
  $this->params['breadcrumbs'][] = 'About Us';
  #+END_SRC

  在布局文件（也是一个视图）中，可使用依次加入到[[yii\base\View::params]]数组的值来 生成显示breadcrumbs:
  #+BEGIN_SRC php
  <?= yii\widgets\Breadcrumbs::widget([
      'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
  ]) ?>
  #+END_SRC

**** 布局
     布局是一种特殊的视图，代表多个视图的公共部分，例如，大多数Web应用共享相同的页头和页尾，
     在每个视图中重复相同的页头和页尾，更好的方式是将这些公共放到一个布局中，
     渲染内容视图后在合适的地方嵌入到布局中。

***** 创建布局
      由于布局也是视图，它可像普通视图一样创建，布局默认存储在`@app/views/layouts`路径下，
      模块中使用的布局应存储在[[yii\base\Module::basePath|module directory]]模块目录
      下的`views/layouts`路径下，可配置[[yii\base\Module::layoutPath]]来自定义应用或模块的布局默认路径。

  #+BEGIN_SRC php
  <?php
  use yii\helpers\Html;

  /* @var $this yii\web\View */
  /* @var $content string 字符串 */
  ?>
  <?php $this->beginPage() ?>
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8"/>
      <?= Html::csrfMetaTags() ?>
      <title><?= Html::encode($this->title) ?></title>
      <?php $this->head() ?>
  </head>
  <body>
  <?php $this->beginBody() ?>
      <header>My Company</header>
      <?= $content ?>
      <footer>&copy; 2014 by My Company</footer>
  <?php $this->endBody() ?>
  </body>
  </html>
  <?php $this->endPage() ?>

  #+END_SRC
  如上所示，布局生成每个页面通用的HTML标签，在<body>标签中，打印$content变量，

   $content变量代表当[[yii\base\Controller::render()]]控制器渲染方法调用时传递到布局的内容视图渲染结果。

   大多数视图应调用上述代码中的如下方法，这些方法触发关于渲染过程的事件，
   这样其他地方注册的脚本和标签会添加到这些方法调用的地方。

   yii\base\View::beginPage():该方法应在布局的开始处调用， 它触发表明页面开始的yii\base\View::EVENTBEGINPAGE事件。
   yii\base\View::endPage():该方法应在布局的结尾处调用， 它触发表明页面结尾的 [[yii\base\View::EVENTENDPAGE]] 时间。
   yii\web\View::head():该方法应在HTML页面的<head>标签中调用， 它生成一个占位符，在页面渲染结束时会被注册的头部HTML代码（如，link标签, meta标签）替换。
   yii\web\View::beginBody():该方法应在<body>标签的开始处调用， 它触发 [[yii\web\View::EVENTBEGINBODY]] 事件并生成一个占位符， 会被注册的HTML代码（如JavaScript）在页面主体开始处替换。
   yii\web\View::endBody():该方法应在<body>标签的结尾处调用， 它触发 yii\web\View::EVENTENDBODY事件并生成一个占位符， 会被注册的HTML代码（如JavaScript）在页面主体结尾处替换。
***** 布局中访问数据
  在布局中可访问两个预定义变量：$this 和 $content，前者对应和普通视图类似的[[yii\base\View]] 
  视图组件 后者包含调用[[yii\base\Controller::render()]]方法渲染内容视图的结果。

  如果想在布局中访问其他数据，必须使用视图中访问数据一节介绍的拉取方式， 
  如果想从内容视图中传递数据到布局，可使用视图间共享数据一节中的方法。
***** 使用布局
  如控制器中渲染一节描述，当控制器调用yii\base\Controller::render()方法渲染视图时，
  会同时使用布局到渲染结果中，默认会使用@app/views/layouts/main.php布局文件。

  可配置[[yii\base\Application::layout]] 或 [[yii\base\Controller::layout]] 使用其他布局文件， 
  前者管理所有控制器的布局，后者覆盖前者来控制单个控制器布局。 例如，如下代码使 post
  控制器渲染视图时使用 @app/views/layouts/post.php 作为布局文件， 假如 layout 属性没改变，
  控制器默认使用 @app/views/layouts/main.php 作为布局文件。

  #+BEGIN_SRC php
  namespace app\controllers;

  use yii\web\Controller;

  class PostController extends Controller
  {
      public $layout = 'post';
    
      // ...
  }
  #+END_SRC

  对于模块中的控制器，可配置模块的 [[yii\base\Module::layout]] 属性指定布局文件应用到模块的所有控制器。

  由于layout 可在不同层级（控制器、模块，应用）配置，在幕后Yii使用两步来决定控制器实际使用的布局。

****** 第一步，它决定布局的值和上下文模块：

  如果控制器的 [[yii\base\Controller::layout]] 属性不为空null，使用它作为布局的值，
   控制器的 [[yii\base\Controller::module]]模块 作为上下文模块。
  如果 [[yii\base\Controller::layout]] 为空，从控制器的祖先模块（包括应用） 开始找 
  第一个[[yii\base\Module::layout]] 属性不为空的模块，使用该模块作为上下文模块， 
  并将它的[[yii\base\Module::layout]] 的值作为布局的值， 如果都没有找到，表示不使用布局。

****** 第二步，它决定第一步中布局的值和上下文模块对应到实际的布局文件，布局的值可为：
       路径别名 (如 @app/views/layouts/main).
     
       绝对路径 (如 /main): 布局的值以斜杠开始，在应用的[[yii\base\Application::layoutPath]] 布局路径 
       中查找实际的布局文件，布局路径默认为 @app/views/layouts。
     
       相对路径 (如 main): 在上下文模块的[[yii\base\Module::layoutPath]]布局路径中查找实际的布局文件， 
       布局路径默认为[[yii\base\Module::basePath|module directory]]模块目录下的views/layouts 目录。
     
       布尔值 false: 不使用布局。
       布局的值没有包含文件扩展名，默认使用 .php作为扩展名。

***** 嵌套布局
  有时候你想嵌套一个布局到另一个，例如，在Web站点不同地方，想使用不同的布局， 同时这些布局共享相同的生成全局
  HTML5页面结构的基本布局，可以在子布局中调用 yii\base\View::beginContent()和
  yii\base\View::endContent()方法，如下所示：
  #+BEGIN_SRC php
  <?php $this->beginContent('@app/views/layouts/base.php'); ?>

  ...child layout content here...

  <?php $this->endContent(); ?>
  #+END_SRC
  如上所示，子布局内容应在 yii\base\View::beginContent()和 yii\base\View::endContent()方法之间，
  传给 yii\base\View::beginContent()的参数指定父布局，父布局可为布局文件或别名。

  使用以上方式可多层嵌套布局。
***** 使用数据块
  数据块可以在一个地方指定视图内容在另一个地方显示，通常和布局一起使用， 例如，
  可在内容视图中定义数据块在布局中显示它。

  调用 yii\base\View::beginBlock()和 yii\base\View::endBlock()来定义数据块， 
  使用 $view->blocks[$blockID] 访问该数据块，其中 $blockID 为定义数据块时指定的唯一标识ID。

  如下实例显示如何在内容视图中使用数据块让布局使用。

  首先，在内容视图中定一个或多个数据块：

  #+BEGIN_SRC php
  ...

  <?php $this->beginBlock('block1'); ?>

  ...content of block1...

  <?php $this->endBlock(); ?>

  ...

  <?php $this->beginBlock('block3'); ?>

  ...content of block3...

  <?php $this->endBlock(); ?>
  #+END_SRC

  然后，在布局视图中，数据块可用的话会渲染数据块，如果数据未定义则显示一些默认内容。
  #+BEGIN_SRC php
  ...
  <?php if (isset($this->blocks['block1'])): ?>
      <?= $this->blocks['block1'] ?>
  <?php else: ?>
      ... default content for block1 ...
  <?php endif; ?>

  ...

  <?php if (isset($this->blocks['block2'])): ?>
      <?= $this->blocks['block2'] ?>
  <?php else: ?>
      ... default content for block2 ...
  <?php endif; ?>

  ...

  <?php if (isset($this->blocks['block3'])): ?>
      <?= $this->blocks['block3'] ?>
  <?php else: ?>
      ... default content for block3 ...
  <?php endif; ?>
  ...
  #+END_SRC
**** 使用视图组件
  [[yii\base\View]]视图组件提供许多视图相关特性，可创建[[yii\base\View]]或它的子类实例来获取视图组件，
   大多数情况下主要使用 view 应用组件，可在应用配置中配置该组件， 如下所示：
  #+BEGIN_SRC php
  [
      // ...
      'components' => [
          'view' => [
              'class' => 'app\components\View',
          ],
          // ...
      ],
  ]

  #+END_SRC

  视图组件提供如下实用的视图相关特性，每项详情会在独立章节中介绍：

  主题: 允许为你的Web站点开发和修改主题；
  片段缓存: 允许你在Web页面中缓存片段；
  客户脚本处理: 支持CSS 和 JavaScript 注册和渲染；
  资源包处理: 支持 资源包的注册和渲染；
  模板引擎: 允许你使用其他模板引擎，如 Twig, Smarty。
  开发Web页面时，也可能频繁使用以下实用的小特性。

***** 设置页面标题
  每个Web页面应有一个标题，正常情况下标题的标签显示在 布局中， 但是实际上标题大多由内容视图而不是布局来决定，
  为解决这个问题， yii\web\View提供 yii\web\View::title标题属性可让标题信息从内容视图传递到布局中。

  为利用这个特性，在每个内容视图中设置页面标题，如下所示：
  #+BEGIN_SRC php
  <?php $this->title = 'My page title'; ?>
  #+END_SRC

  然后在视图中，确保在 <head> 段中有如下代码：
  #+BEGIN_SRC php
  <title><?= Html::encode($this->title) ?></title>
  #+END_SRC

***** 注册Meta元标签
  Web页面通常需要生成各种元标签提供给不同的浏览器，如<head>中的页面标题，元标签通常在布局中生成。

  如果想在内容视图中生成元标签，可在内容视图中调用[[yii\web\View::registerMetaTag()]]方法，如下所示：

  #+BEGIN_SRC php
  <?php $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']); ?>
  #+END_SRC

  以上代码会在视图组件中注册一个 "keywords" 元标签，在布局渲染后会渲染该注册的元标签， 
  然后，如下HTML代码会插入到布局中调用[[yii\web\View::head()]]方法处：

  #+BEGIN_SRC html
  <meta name="keywords" content="yii, framework, php">
  #+END_SRC

  注意如果多次调用 [[yii\web\View::registerMetaTag()]] 方法，它会注册多个元标签，注册时不会检查是否重复。

  为确保每种元标签只有一个，可在调用方法时指定键作为第二个参数，
   例如，如下代码注册两次 "description" 元标签，但是只会渲染第二个。
   #+BEGIN_SRC php
     $this->registerMetaTag(['name' => 'description', 'content' => 'This is my cool website made with Yii!'], 'description');
     $this->registerMetaTag(['name' => 'description', 'content' => 'This website is about funny raccoons.'], 'description');
   #+END_SRC

***** 注册链接标签
  和 Meta标签 类似，链接标签有时很实用，如自定义网站图标，指定Rss订阅，或授权OpenID到其他服务器。 
  可以和元标签相似的方式调用[[yii\web\View::registerLinkTag()]]，例如，在内容视图中注册链接标签如下所示：
  #+BEGIN_SRC php
  $this->registerLinkTag([
      'title' => 'Live News for Yii',
      'rel' => 'alternate',
      'type' => 'application/rss+xml',
      'href' => 'http://www.yiiframework.com/rss.xml/',
  ]);
  #+END_SRC

  上述代码会转换成
  #+BEGIN_SRC html
  <link title="Live News for Yii" rel="alternate" type="application/rss+xml" href="http://www.yiiframework.com/rss.xml/">
  #+END_SRC

  和 yii\web\View::registerMetaTag()类似， 调用yii\web\View::registerLinkTag()指定键来避免生成重复链接标签。
**** 视图事件
  yii\base\View视图组件会在视图渲染过程中触发几个事件， 可以在内容发送给终端用户前，
  响应这些事件来添加内容到视图中或调整渲染结果。

  yii\base\View::EVENTBEFORERENDER:在控制器渲染文件开始时触发， 该事件可设置
  [[yii\base\ViewEvent::isValid]] 为 false 取消视图渲染。
 
  [[yii\base\View::EVENTAFTERRENDER]]: 在布局中调用 [[yii\base\View::beginPage()]] 时触发， 
  该事件可获取[[yii\base\ViewEvent::output]]的渲染结果，可修改该属性来修改渲染结果。

  [[yii\base\View::EVENTBEGINPAGE]]: 在布局调用 [[yii\base\View::beginPage()]] 时触发；
  [[yii\base\View::EVENTENDPAGE]]: 在布局调用 [[yii\base\View::endPage()]] 是触发；
  yii\web\View::EVENTBEGINBODY:在布局调用 [[yii\web\View::beginBody()]] 时触发；
  yii\web\View::EVENTENDBODY:在布局调用 [[yii\web\View::endBody()]] 时触发。
  例如，如下代码将当前日期添加到页面结尾处：

  #+BEGIN_SRC php
    \Yii::$app->view->on(View::EVENT_END_BODY, function () { 
                                                 echo date('Y-m-d'); 
    });
  #+END_SRC

**** 渲染静态页面
  静态页面指的是大部分内容为静态的不需要控制器传递动态数据的Web页面。

  可将HTML代码放置在视图中，在控制器中使用以下代码输出静态页面：
  #+BEGIN_SRC php
       public function actionAbout() { 
                return $this->render('about');
              }
  #+END_SRC

  如果Web站点包含很多静态页面，多次重复相似的代码显得很繁琐， 为解决这个问题，可以使用一个
  在控制器中称为 [[yii\web\ViewAction]] 的独立操作。 例如：
  #+BEGIN_SRC php
  namespace app\controllers;

  use yii\web\Controller;

  class SiteController extends Controller
  {
      public function actions()
      {
          return [
              'page' => [
                  'class' => 'yii\web\ViewAction',
              ],
          ];
      }
  }

  #+END_SRC
  现在如果你在@app/views/site/pages目录下创建名为 about 的视图， 可通过如下rul显示该视图：

  http://localhost/index.php?r=site/page&view=about

  GET 中 view 参数告知 [[yii\web\ViewAction]] 操作请求哪个视图，然后操作在 @app/views/site/pages
  目录下寻找该视图，可配置 [[yii\web\ViewAction::viewPrefix]] 修改搜索视图的目录。

**** 最佳实践
  视图负责将模型的数据展示用户想要的格式，总之，视图

  应主要包含展示代码，如HTML, 和简单的PHP代码来控制、格式化和渲染数据；
  不应包含执行数据查询代码，这种代码放在模型中；
  应避免直接访问请求数据，如 $_GET, $_POST，这种应在控制器中执行， 如果需要请求数据，应由控制器推送到视图。
  可读取模型属性，但不应修改它们。
  为使模型更易于维护，避免创建太复杂或包含太多冗余代码的视图，可遵循以下方法达到这个目标：

  使用 布局 来展示公共代码（如，页面头部、尾部）；
  将复杂的视图分成几个小视图，可使用上面描述的渲染方法将这些小视图渲染并组装成大视图；
  创建并使用 小部件 作为视图的数据块；
  创建并使用助手类在视图中转换和格式化数据。
*** 模块（Modules）
    模块是独立的软件单元，由模型, 视图, 控制器和其他支持组件组成， 终端用户可以访问在应用主体中
 已安装的模块的控制器， 模块被当成小应用主体来看待，和应用主体不同的是， 模块不能单独部署，
 必须属于某个应用主体。

**** 创建模块
     模块被组织成一个称为[[yii\base\Module::basePath|base path]]的目录，
     在该目录中有子目录如controllers, models, views 分别为对应控制器，模型，视图和其他代码，
     和应用非常类似。 如下例子显示一个模型的目录结构：
    
 #+BEGIN_SRC 
 forum/
     Module.php                   模块类文件
     controllers/                 包含控制器类文件
         DefaultController.php    default 控制器类文件
     models/                      包含模型类文件
     views/                       包含控制器视图文件和布局文件
         layouts/                 包含布局文件
         default/                 包含DefaultController控制器视图文件
             index.php            index视图文件

 #+END_SRC

***** 模块类
      每个模块都有一个继承[[yii\base\Module]]的模块类，该类文件直接放在模块的[[yii\base\Module::basePath]]
      目录下， 并且能被自动加载。当一个模块被访问，和 应用主体实例 类似会创建该模块类唯一实例，
      模块实例用来帮模块内代码共享数据和组件。

      以下示例一个模块类大致定义：
 #+BEGIN_SRC php
 namespace app\modules\forum;

 class Module extends \yii\base\Module
 {
     public function init()
     {
         parent::init();

         $this->params['foo'] = 'bar';
         // ...  其他初始化代码 ...
     }
 }

 #+END_SRC
  如果 init() 方法包含很多初始化模块属性代码， 可将他们保存在配置 并在init()中使用以下代码加载：
 #+BEGIN_SRC php
 public function init()
 {
     parent::init();
     // 从config.php加载配置来初始化模块
     \Yii::configure($this, require __DIR__ . '/config.php');
 }

 #+END_SRC

  config.php配置文件可能包含以下内容，类似应用主体配置.
  #+BEGIN_SRC php
  <?php
 return [
     'components' => [
         // list of component configurations
     ],
     'params' => [
         // list of parameters
     ],
 ];
  #+END_SRC

***** 模块中的控制器
      创建模块的控制器时，惯例是将控制器类放在模块类命名空间的controllers子命名空间中， 
      也意味着要将控制器类文件放在模块[[yii\base\Module::basePath]]目录中的controllers子目录中。
      例如，上小节中要在forum模块中创建post控制器，应像如下申明控制器类：
      #+BEGIN_SRC php
        namespace app\modules\forum\controllers;

        use yii\web\Controller;

        class PostController extends Controller
        {
            // ...
        }
      #+END_SRC
     
  可配置[[yii\base\Module::controllerNamespace]]属性来自定义控制器类的命名空间， 
  如果一些控制器不再该命名空间下，可配置[[yii\base\Module::controllerMap]]属性让它们能被访问，
  这类似于 应用主体配置 所做的。

***** 模块中的视图
      视图应放在模块的[[yii\base\Module::basePath]]对应目录下的 views 目录， 
      对于模块中控制器对应的视图文件应放在 views/ControllerID 目录下， 其中ControllerID对应 
      控制器 ID. For example, if 例如，假定控制器类为PostController，目录对应模块
      [[yii\base\Module::basePath]]目录下的 views/post 目录。

      模块可指定 布局，它用在模块的控制器视图渲染。 布局文件默认放在 views/layouts 目录下，
      可配置[[yii\base\Module::layout]]属性指定布局名， 如果没有配置 layout 属性名，默认会使用应用的布局。

**** 使用模块
     要在应用中使用模块，只需要将模块加入到应用主体配置的modules属性的列表中， 如下代码的应用主体配置
     使用 forum 模块:
 #+BEGIN_SRC php
 [
     'modules' => [
         'forum' => [
             'class' => 'app\modules\forum\Module',
             // ... 模块其他配置 ...
         ],
     ],
 ]
 #+END_SRC

 yii\base\Application::modules属性使用模块配置数组，每个数组键为模块 ID， 
 它标识该应用中唯一的模块，数组的值为用来创建模块的 配置。

***** 路由
  和访问应用的控制器类似，路由 也用在模块中控制器的寻址， 模块中控制器的路由必须以模块ID开始，
  接下来为控制器ID和操作ID。 例如，假定应用使用一个名为 forum 模块，路由forum/post/index 
 代表模块中 post 控制器的 index 操作， 如果路由只包含模块ID，默认为 default 的defaultRoute
 属性来决定使用哪个控制器/操作， 也就是说路由 forum 可能代表 forum 模块的 default 控制器。

***** 访问模块
  在模块中，可能经常需要获取模块类的实例来访问模块ID，模块参数，模块组件等， 可以使用如下语句来获取：
 #+BEGIN_SRC php
  $module = MyModuleClass::getInstance();
 #+END_SRC

  其中 MyModuleClass 对应你想要的模块类，getInstance() 方法返回当前请求的模块类实例，
  如果模块没有被请求，该方法会返回空，注意不需要手动创建一个模块类，因为手动创建的和Yii处理请求时自动创建的不同。

  Info: 当开发模块时，你不能假定模块使用固定的ID，因为在应用或其他没模块中，模块可能会对应到任意的ID，
  为了获取模块ID，应使用上述代码获取模块实例，然后通过$module->id获取模块ID。

  也可以使用如下方式访问模块实例:
 #+BEGIN_SRC php
 // 获取ID为 "forum" 的模块
 $module = \Yii::$app->getModule('forum');

 // 获取处理当前请求控制器所属的模块
 $module = \Yii::$app->controller->module;
 #+END_SRC

  第一种方式仅在你知道模块ID的情况下有效，第二种方式在你知道处理请求的控制器下使用。

  一旦获取到模块实例，可访问注册到模块的参数和组件，例如：
 #+BEGIN_SRC php
   $maxPostCount = $module->params['maxPostCount'];
 #+END_SRC

***** 引导启动模块
      有些模块在每个请求下都有运行， [[yii\debug\Module|debug]] 模块就是这种， 
      为此将这种模块加入到应用主体的 [[yii\base\Application::bootstrap]] 属性中。

  例如，如下示例的应用主体配置会确保debug模块每次都被加载：
 #+BEGIN_SRC php
  [ 'bootstrap' => [ 'debug', ],

  'modules' => [
      'debug' => 'yii\debug\Module',
  ],
  ] 


 #+END_SRC
**** 模块嵌套
  模块可无限级嵌套，也就是说，模块可以包含另一个包含模块的模块，我们称前者为父模块，后者为子模块，
  子模块必须在父模块的[[yii\base\Module::modules]]属性中申明，例如：
 #+BEGIN_SRC php
   namespace app\modules\forum;

  class Module extends \yii\base\Module { public function init() { parent::init();

      $this->modules = [
          'admin' => [
              // 此处应考虑使用一个更短的命名空间
              'class' => 'app\modules\forum\modules\admin\Module',
          ],
      ];
  }
  }
 #+END_SRC
  在嵌套模块中的控制器，它的路由应包含它所有祖先模块的ID，例如forum/admin/dashboard/index 代表 
 在模块forum中子模块admin中dashboard控制器的index操作。

**** 最佳实践
     模块在大型项目中常备使用，这些项目的特性可分组，每个组包含一些强相关的特性， 
     每个特性组可以做成一个模块由特定的开发人员和开发组来开发和维护。

     在特性组上，使用模块也是重用代码的好方式，一些常用特性，如用户管理，评论管理，可以开发成模块，
     这样在相关项目中非常容易被重用。
*** 过滤器（Filters）
    过滤器是 控制器 动作 执行之前或之后执行的对象。 例如访问控制过滤器可在动作执行之前来控制特殊终端用户是否有权限执行动作，
    内容压缩过滤器可在动作执行之后发给终端用户之前压缩响应内容。

    过滤器可包含 预过滤（过滤逻辑在动作之前） 或 后过滤（过滤逻辑在动作之后），也可同时包含两者。

**** 使用过滤器
  过滤器本质上是一类特殊的 行为，所以使用过滤器和 使用 行为一样。 可以在控制器类中覆盖它的 
  yii\base\Controller::behaviors()方法来申明过滤器，如下所示：
 #+BEGIN_SRC php
 public function behaviors()
 {
     return [
         [
             'class' => 'yii\filters\HttpCache',
             'only' => ['index', 'view'],
             'lastModified' => function ($action, $params) {
                 $q = new \yii\db\Query();
                 return $q->from('user')->max('updated_at');
             },
         ],
     ];
 }

 #+END_SRC

  控制器类的过滤器默认应用到该类的 所有 动作，你可以配置[[yii\base\ActionFilter::only]]
 属性明确指定控制器应用到哪些动作。 在上述例子中，HttpCache 过滤器只应用到index和view动作。
  也可以配置[[yii\base\ActionFilter::except]]属性使一些动作不执行过滤器。

  除了控制器外，可在 模块或应用主体 中申明过滤器。 申明之后，过滤器会应用到所属该模块或应用主体的 所有
  控制器动作， 除非像上述一样配置过滤器的 [[yii\base\ActionFilter::only]] 和 [[yii\base\ActionFilter::except]] 属性。

  Info: 在模块或应用主体中申明过滤器，在[[yii\base\ActionFilter::only]] 和 yii\base\ActionFilter::except属性中使用路由 代替动作ID， 因为在模块或应用主体中只用动作ID并不能唯一指定到具体动作。.

  当一个动作有多个过滤器时，根据以下规则先后执行：

***** 预过滤
  按顺序执行应用主体中behaviors()列出的过滤器。
  按顺序执行模块中behaviors()列出的过滤器。
  按顺序执行控制器中behaviors()列出的过滤器。
  如果任意过滤器终止动作执行，后面的过滤器（包括预过滤和后过滤）不再执行。
***** 成功通过预过滤后执行动作。
***** 后过滤
  倒序执行控制器中behaviors()列出的过滤器。
  倒序执行模块中behaviors()列出的过滤器。
  倒序执行应用主体中behaviors()列出的过滤器。
**** 创建过滤器
  继承 [[yii\base\ActionFilter]] 类并覆盖 yii\base\ActionFilter::beforeAction()和/或
  yii\base\ActionFilter::afterAction()方法来创建动作的过滤器，前者在动作执行之前执行，后者在动作执行之后执行。
 yii\base\ActionFilter::beforeAction()返回值决定动作是否应该执行， 如果为false，之后的过滤器和动作不会继续执行。

  下面的例子申明一个记录动作执行时间日志的过滤器。
 #+BEGIN_SRC php
 namespace app\components;

 use Yii;
 use yii\base\ActionFilter;

 class ActionTimeFilter extends ActionFilter
 {
     private $_startTime;

     public function beforeAction($action)
     {
         $this->_startTime = microtime(true);
         return parent::beforeAction($action);
     }

     public function afterAction($action, $result)
     {
         $time = microtime(true) - $this->_startTime;
         Yii::trace("Action '{$action->uniqueId}' spent $time second.");
         return parent::afterAction($action, $result);
     }
 }
 #+END_SRC
**** 核心过滤器
  Yii提供了一组常用过滤器，在yii\filters命名空间下，接下来我们简要介绍这些过滤器。

***** [[yii\filters\AccessControl]]
      AccessControl提供基于[[yii\filters\AccessControl::rules]]规则的访问控制。 特别是在动作执行之前，
      访问控制会检测所有规则并找到第一个符合上下文的变量（比如用户IP地址、登录状态等等）的规则，
      来决定允许还是拒绝请求动作的执行，如果没有规则符合，访问就会被拒绝。

  如下示例表示表示允许已认证用户访问create 和 update 动作，拒绝其他用户访问这两个动作。
 #+BEGIN_SRC php
 use yii\filters\AccessControl;

 public function behaviors()
 {
     return [
         'access' => [
             'class' => AccessControl::className(),
             'only' => ['create', 'update'],
             'rules' => [
                 // 允许认证用户
                 [
                     'allow' => true,
                     'roles' => ['@'],
                 ],
                 // 默认禁止其他用户
             ],
         ],
     ];
 }

 #+END_SRC

  更多关于访问控制的详情请参阅 授权 一节。

***** 认证方法过滤器
      认证方法过滤器通过HTTP Basic Auth或OAuth 2 来认证一个用户，认证方法过滤器类在 
      yii\filters\auth 命名空间下。

      如下示例表示可使用[[yii\filters\auth\HttpBasicAuth]]来认证一个用户，它使用基于HTTP基础认证方法的令牌。 
      注意为了可运行，[[yii\web\User::identityClass]] 类必须 实现
      yii\web\IdentityInterface::findIdentityByAccessToken()方法。
 #+BEGIN_SRC php
 use yii\filters\auth\HttpBasicAuth;

 public function behaviors()
 {
     return [
         'basicAuth' => [
             'class' => HttpBasicAuth::className(),
         ],
     ];
 }

 #+END_SRC

  认证方法过滤器通常在实现RESTful API中使用，更多关于访问控制的详情请参阅 RESTful 认证 一节。

***** [[yii\filters\ContentNegotiator|ContentNegotiator]]
      ContentNegotiator支持响应内容格式处理和语言处理。 通过检查 GET 参数和 Accept HTTP
      头部来决定响应内容格式和语言。

  如下示例，配置ContentNegotiator支持JSON和XML响应格式和英语（美国）和德语。
  #+BEGIN_SRC php
  use yii\filters\ContentNegotiator;
 use yii\web\Response;

 public function behaviors()
 {
     return [
         [
             'class' => ContentNegotiator::className(),
             'formats' => [
                 'application/json' => Response::FORMAT_JSON,
                 'application/xml' => Response::FORMAT_XML,
             ],
             'languages' => [
                 'en-US',
                 'de',
             ],
         ],
     ];
 }
  #+END_SRC
 
  在应用主体生命周期过程中检测响应格式和语言简单很多， 因此ContentNegotiator设计可被引导启动组件调用的过滤器。
  如下例所示可以将它配置在应用主体配置。
 #+BEGIN_SRC php
 use yii\filters\ContentNegotiator;
 use yii\web\Response;

 [
     'bootstrap' => [
         [
             'class' => ContentNegotiator::className(),
             'formats' => [
                 'application/json' => Response::FORMAT_JSON,
                 'application/xml' => Response::FORMAT_XML,
             ],
             'languages' => [
                 'en-US',
                 'de',
             ],
         ],
     ],
 ];
 #+END_SRC
  Info: 如果请求中没有检测到内容格式和语言，使用[[formats]]和[[languages]]第一个配置项。

***** [[yii\filters\HttpCache|HttpCache]]
      HttpCache利用Last-Modified 和 Etag HTTP头实现客户端缓存。例如：
 #+BEGIN_SRC php
 use yii\filters\HttpCache;

 public function behaviors()
 {
     return [
         [
             'class' => HttpCache::className(),
             'only' => ['index'],
             'lastModified' => function ($action, $params) {
                 $q = new \yii\db\Query();
                 return $q->from('user')->max('updated_at');
             },
         ],
     ];
 }

 #+END_SRC

  更多关于使用HttpCache详情请参阅 HTTP 缓存 一节。

***** PageCache
      PageCache实现服务器端整个页面的缓存。如下示例所示，PageCache应用在index动作， 
      缓存整个页面60秒或post表的记录数发生变化。它也会根据不同应用语言保存不同的页面版本。
 #+BEGIN_SRC php
 use yii\filters\PageCache;
 use yii\caching\DbDependency;

 public function behaviors()
 {
     return [
         'pageCache' => [
             'class' => PageCache::className(),
             'only' => ['index'],
             'duration' => 60,
             'dependency' => [
                 'class' => DbDependency::className(),
                 'sql' => 'SELECT COUNT(*) FROM post',
             ],
             'variations' => [
                 \Yii::$app->language,
             ]
         ],
     ];
 }

 #+END_SRC

  更多关于使用PageCache详情请参阅 页面缓存 一节。

***** RateLimiter
  RateLimiter 根据 漏桶算法 来实现速率限制。 主要用在实现RESTful APIs，更多关于该过滤器详情请参阅 
 Rate Limiting 一节。

***** VerbFilter
  VerbFilter检查请求动作的HTTP请求方式是否允许执行，如果不允许，会抛出HTTP 405异常。
  如下示例，VerbFilter指定CRUD动作所允许的请求方式。
  #+BEGIN_SRC php
  use yii\filters\VerbFilter;

 public function behaviors()
 {
     return [
         'verbs' => [
             'class' => VerbFilter::className(),
             'actions' => [
                 'index'  => ['get'],
                 'view'   => ['get'],
                 'create' => ['get', 'post'],
                 'update' => ['get', 'put', 'post'],
                 'delete' => ['post', 'delete'],
             ],
         ],
     ];
 }

  #+END_SRC 
***** Cors
  跨域资源共享CORS机制允许一个网页的许多资源（例如字体、JavaScript等）这些资源可以通过其他域名访问获取。
  特别是JavaScript's AJAX 调用可使用 XMLHttpRequest 机制，由于同源安全策略该跨域请求会被网页浏览器禁止. 
 CORS定义浏览器和服务器交互时哪些跨域请求允许和禁止。

 filters 应在 授权 / 认证 过滤器之前定义，以保证CORS头部被发送。

      #+BEGIN_SRC php
        use yii\filters\Cors;
        use yii\helpers\ArrayHelper;

        public function behaviors()
        {
            return ArrayHelper::merge([
                [
                    'class' => Cors::className(),
                ],
            ], parent::behaviors());
        }

      #+END_SRC
     
  Cors 可转为使用 cors 属性。

  cors['Origin']: 定义允许来源的数组，可为['*'] (任何用户) 或 ['http://www.myserver.net', 'http://www.myotherserver.com']. 默认为 ['*'].
  cors['Access-Control-Request-Method']: 允许动作数组如 ['GET', 'OPTIONS', 'HEAD']. 默认为 ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'].
  cors['Access-Control-Request-Headers']: 允许请求头部数组，可为 ['*'] 所有类型头部 或 ['X-Request-With'] 指定类型头部. 默认为 ['*'].
  cors['Access-Control-Allow-Credentials']: 定义当前请求是否使用证书，可为 true, false 或 null (不设置). 默认为 null.
  cors['Access-Control-Max-Age']: 定义请求的有效时间，默认为 86400.
  例如，允许来源为 http://www.myserver.net 和方式为 GET, HEAD 和 OPTIONS 的CORS如下：

  #+BEGIN_SRC php
  use yii\filters\Cors;
 use yii\helpers\ArrayHelper;

 public function behaviors()
 {
     return ArrayHelper::merge([
         [
             'class' => Cors::className(),
             'cors' => [
                 'Origin' => ['http://www.myserver.net'],
                 'Access-Control-Request-Method' => ['GET', 'HEAD', 'OPTIONS'],
             ],
         ],
     ], parent::behaviors());
 }

  #+END_SRC
  可以覆盖默认参数为每个动作调整CORS 头部。例如，为login动作增加Access-Control-Allow-Credentials
  参数如下所示：
 #+BEGIN_SRC php
 use yii\filters\Cors;
 use yii\helpers\ArrayHelper;

 public function behaviors()
 {
     return ArrayHelper::merge([
         [
             'class' => Cors::className(),
             'cors' => [
                 'Origin' => ['http://www.myserver.net'],
                 'Access-Control-Request-Method' => ['GET', 'HEAD', 'OPTIONS'],
             ],
             'actions' => [
                 'login' => [
                     'Access-Control-Allow-Credentials' => true,
                 ]
             ]
         ],
     ], parent::behaviors());
 }

 #+END_SRC
*** 小部件（Widgets）
  小部件是在 视图 中使用的可重用单元，使用面向对象方式创建复杂和可配置用户界面单元。
 例如，日期选择器小部件可生成一个精致的允许用户选择日期的日期选择器， 你只需要在视图中插入如下代码：
#+BEGIN_SRC php
<?php
use yii\jui\DatePicker;
?>
<?= DatePicker::widget(['name' => 'date']) ?>

#+END_SRC

Yii提供许多优秀的小部件，比如[[yii\widgets\ActiveForm]], [[yii\widgets\Menu]], jQuery UI widgets,
Twitter Bootstrap widgets。 接下来介绍小部件的基本知识，如果你想了解某个小部件请参考对应的类API文档

**** 使用小部件
  小部件基本上在views中使用，在视图中可调用 [[yii\base\Widget()]] 方法使用小部件。
 该方法使用 配置 数组初始化小部件并返回小部件渲染后的结果。 例如如下代码插入一个日期选择器小部件，
 它配置为使用俄罗斯语，输入框内容为$model的from_date属性值。

 #+BEGIN_SRC php
 <?php
use yii\jui\DatePicker;
?>
<?= DatePicker::widget([
    'model' => $model,
    'attribute' => 'from_date',
    'language' => 'ru',
    'clientOptions' => [
        'dateFormat' => 'yy-mm-dd',
    ],
]) ?>

 #+END_SRC

  一些小部件可在[[yii\base\Widget::begin()]] 和 [[yii\base\Widget::end()]] 调用中使用数据内容。
例如如下代码使用[[yii\widgets\ActiveForm]]小部件生成一个登录表单，
小部件会在`begin()` 和0 `end()`执行处分别生成`<form>`的开始标签和结束标签，中间的任何代码也会被渲染。
#+BEGIN_SRC php
<?php
use yii\widgets\ActiveForm;
use yii\helpers\Html;
?>

<?php $form = ActiveForm::begin(['id' => 'login-form']); ?>

    <?= $form->field($model, 'username') ?>

    <?= $form->field($model, 'password')->passwordInput() ?>

    <div class="form-group">
        <?= Html::submitButton('Login') ?>
    </div>

<?php ActiveForm::end(); ?>

#+END_SRC

  注意和调用 [[yii\base\Widget::widget()]] 返回渲染结果不同， 调用 [[yii\base\Widget::begin()]] 方法返回一个可组建小部件内容的小部件实例。

  创建小部件
  Creating Widgets
  继承 [[yii\base\Widget]] 类并覆盖 [[yii\base\Widget::init()]] 和/或 [[yii\base\Widget::run()]] 方法可创建小部件。通常init() 方法处理小部件属性， run() 方法包含小部件生成渲染结果的代码。 渲染结果可在run()方法中直接"echoed"输出或以字符串返回。

  如下代码中HelloWidget编码并显示赋给message 属性的值， 如果属性没有被赋值，默认会显示"Hello World"。

  ```php namespace app\components;

  use yii\base\Widget; use yii\helpers\Html;

  class HelloWidget extends Widget { public $message;

  public function init()
  {
      parent::init();
      if ($this->message === null) {
          $this->message = 'Hello World';
      }
  }

  public function run()
  {
      return Html::encode($this->message);
  }
  } ```

  使用这个小部件只需在视图中简单使用如下代码:

  php <?php use app\components\HelloWidget; ?> <?= HelloWidget::widget(['message' => 'Good morning']) ?>

  以下是另一种可在begin() 和 end()调用中使用的HelloWidget，HTML编码内容然后显示。

  ```php namespace app\components;

  use yii\base\Widget; use yii\helpers\Html;

  class HelloWidget extends Widget { public function init() { parent::init(); ob_start(); }

  public function run()
  {
      $content = ob_get_clean();
      return Html::encode($content);
  }
  } ```

  如上所示，PHP输出缓冲在init()启动，所有在init() 和 run()方法之间的输出内容都会被获取，并在run()处理和返回。

  Info: 当你调用 [[yii\base\Widget::begin()]] 时会创建一个新的小部件实例并在构造结束时调用init()方法， 在end()时会调用run()方法并输出返回结果。

  如下代码显示如何使用这种 HelloWidget:

  ```php
  content that may contain <tag>'s
  ```

  有时小部件需要渲染很多内容，一种更好的办法是将内容放入一个视图文件， 然后调用[[yii\base\Widget::render()]]方法渲染该视图文件，例如：

  php public function run() { return $this->render('hello'); }

  小部件的视图文件默认存储在WidgetPath/views目录，WidgetPath代表小部件类文件所在的目录。 假如上述示例小部件类文件在@app/components下，会渲染@app/components/views/hello.php视图文件。 You may override 可以覆盖[[yii\base\Widget::getViewPath()]]方法自定义视图文件所在路径。

  最佳实践
  小部件是面向对象方式来重用视图代码。

  创建小部件时仍需要遵循MVC模式，通常逻辑代码在小部件类，展示内容在视图中。

  小部件设计时应是独立的，也就是说使用一个小部件时候，可以直接丢弃它而不需要额外的处理。 但是当小部件需要外部资源如CSS, JavaScript, 图片等会比较棘手， 幸运的时候Yii提供 资源包 来解决这个问题。

  当一个小部件只包含视图代码，它和视图很相似， 实际上，在这种情况下，唯一的区别是小部件是可以重用类，视图只是应用中使用的普通PHP脚本。
*** 前端资源（Assets）
    资源
  Yii中的资源是和Web页面相关的文件，可为CSS文件，JavaScript文件，图片或视频等， 资源放在Web可访问的目录下，直接被Web服务器调用。

  通过程序自动管理资源更好一点，例如，当你在页面中使用 [[yii\jui\DatePicker]] 小部件时， 它会自动包含需要的CSS和JavaScript文件，而不是要求你手工去找到这些文件并包含， 当你升级小部件时，它会自动使用新版本的资源文件，在本教程中，我们会详述Yii提供的强大的资源管理功能。

  资源包
  Yii在资源包中管理资源，资源包简单的说就是放在一个目录下的资源集合， 当在视图中注册一个资源包，在渲染Web页面时会包含包中的CSS和JavaScript文件。

  定义资源包
  资源包指定为继承[[yii\web\AssetBundle]]的PHP类，包名为可自动加载的PHP类名， 在资源包类中，要指定资源所在位置，包含哪些CSS和JavaScript文件以及和其他包的依赖关系。

  如下代码定义基础应用模板使用的主要资源包：

  ```php
  namespace app\assets;

  use yii\web\AssetBundle;

  class AppAsset extends AssetBundle { public $basePath = '@webroot'; public $baseUrl = '@web'; public $css = [ 'css/site.css', ]; public $js = [ ]; public $depends = [ 'yii\web\YiiAsset', 'yii\bootstrap\BootstrapAsset', ]; } ```

  如上AppAsset 类指定资源文件放在 @webroot 目录下，对应的URL为 @web，资源包中包含一个CSS文件 css/site.css，没有JavaScript文件， 依赖其他两个包 [[yii\web\YiiAsset]] 和 [[yii\bootstrap\BootstrapAsset]]， 关于[[yii\web\AssetBundle]] 的属性的更多详细如下所述：

  [[yii\web\AssetBundle::sourcePath|sourcePath]]: 指定包包含资源文件的根目录， 当根目录不能被Web访问时该属性应设置，否则，应设置 [[yii\web\AssetBundle::basePath|basePath]] 属性和[[yii\web\AssetBundle::baseUrl|baseUrl]]。 路径别名 可在此处使用；
  [[yii\web\AssetBundle::basePath|basePath]]: 指定包含资源包中资源文件并可Web访问的目录， 当指定[[yii\web\AssetBundle::sourcePath|sourcePath]] 属性， 资源管理器 会发布包的资源到一个可Web访问并覆盖该属性， 如果你的资源文件在一个Web可访问目录下，应设置该属性，这样就不用再发布了。 路径别名 可在此处使用。
  [[yii\web\AssetBundle::baseUrl|baseUrl]]: 指定对应到[[yii\web\AssetBundle::basePath|basePath]]目录的URL， 和 [[yii\web\AssetBundle::basePath|basePath]] 类似，如果你指定 [[yii\web\AssetBundle::sourcePath|sourcePath]] 属性， 资源管理器 会发布这些资源并覆盖该属性，路径别名 可在此处使用。
  [[yii\web\AssetBundle::js|js]]: 一个包含该资源包JavaScript文件的数组，注意正斜杠"/"应作为目录分隔符， 每个JavaScript文件可指定为以下两种格式之一：
  相对路径表示为本地JavaScript文件 (如 js/main.js)，文件实际的路径在该相对路径前加上 [[yii\web\AssetManager::basePath]]，文件实际的URL在该路径前加上[[yii\web\AssetManager::baseUrl]]。
  绝对URL地址表示为外部JavaScript文件，如 http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js 或 //ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js.
  [[yii\web\AssetBundle::css|css]]: 一个包含该资源包CSS文件的数组，该数组格式和 [[yii\web\AssetBundle::js|js]] 相同。
  [[yii\web\AssetBundle::depends|depends]]: 一个列出该资源包依赖的其他资源包（后两节有详细介绍）。
  [[yii\web\AssetBundle::jsOptions|jsOptions]]: 当调用[[yii\web\View::registerJsFile()]]注册该包 每个 JavaScript文件时， 指定传递到该方法的选项。
  [[yii\web\AssetBundle::cssOptions|cssOptions]]: 当调用[[yii\web\View::registerCssFile()]]注册该包 每个 css文件时， 指定传递到该方法的选项。
  [[yii\web\AssetBundle::publishOptions|publishOptions]]: 当调用[[yii\web\AssetManager::publish()]]发布该包资源文件到Web目录时 指定传递到该方法的选项，仅在指定了[[yii\web\AssetBundle::sourcePath|sourcePath]]属性时使用。
  资源位置
  资源根据它们的位置可以分为：

  源资源: 资源文件和PHP源代码放在一起，不能被Web直接访问，为了使用这些源资源，它们要拷贝到一个可Web访问的Web目录中 成为发布的资源，这个过程称为发布资源，随后会详细介绍。
  发布资源: 资源文件放在可通过Web直接访问的Web目录中；
  外部资源: 资源文件放在与你的Web应用不同的Web服务器上；
  当定义资源包类时候，如果你指定了[[yii\web\AssetBundle::sourcePath|sourcePath]] 属性，就表示任何使用相对路径的资源会被 当作源资源；如果没有指定该属性，就表示这些资源为发布资源（因此应指定[[yii\web\AssetBundle::basePath|basePath]] 和 [[yii\web\AssetBundle::baseUrl|baseUrl]] 让Yii知道它们的位置）。

  推荐将资源文件放到Web目录以避免不必要的发布资源过程，这就是之前的例子：指定 [[yii\web\AssetBundle::basePath|basePath]] 而不是 [[yii\web\AssetBundle::sourcePath|sourcePath]].

  对于 扩展来说，由于它们的资源和源代码都在不能Web访问的目录下， 在定义资源包类时必须指定[[yii\web\AssetBundle::sourcePath|sourcePath]]属性。

  Note: [[yii\web\AssetBundle::sourcePath|source path]] 属性不要用@webroot/assets，该路径默认为 [[yii\web\AssetManager|asset manager]]资源管理器将源资源发布后存储资源的路径，该路径的所有内容会认为是临时文件， 可能会被删除。

  资源依赖
  当Web页面包含多个CSS或JavaScript文件时，它们有一定的先后顺序以避免属性覆盖， 例如，Web页面在使用jQuery UI小部件前必须确保jQuery JavaScript文件已经被包含了， 我们称这种资源先后次序称为资源依赖。

  资源依赖主要通过[[yii\web\AssetBundle::depends]] 属性来指定， 在AppAsset 示例中，资源包依赖其他两个资源包： [[yii\web\YiiAsset]] 和 [[yii\bootstrap\BootstrapAsset]] 也就是该资源包的CSS和JavaScript文件要在这两个依赖包的文件包含 之后 才包含。

  资源依赖关系是可传递，也就是说A依赖B，B依赖C，那么A也依赖C。

  资源选项
  可指定[[yii\web\AssetBundle::cssOptions|cssOptions]] 和 [[yii\web\AssetBundle::jsOptions|jsOptions]] 属性来自定义页面包含CSS和JavaScript文件的方式， 这些属性值会分别传递给 [[yii\web\View::registerCssFile()]] 和 [[yii\web\View::registerJsFile()]] 方法， 在视图 调用这些方法包含CSS和JavaScript文件时。

  Note: 在资源包类中设置的选项会应用到该包中 每个 CSS/JavaScript 文件，如果想对每个文件使用不同的选项， 应创建不同的资源包并在每个包中使用一个选项集。

  例如，只想IE9或更高的浏览器包含一个CSS文件，可以使用如下选项：

  php public $cssOptions = ['condition' => 'lte IE9'];

  这会是包中的CSS文件使用以下HTML标签包含进来：

  html <!--[if lte IE9]> <link rel="stylesheet" href="path/to/foo.css"> <![endif]-->

  为链接标签包含<noscript>可使用如下代码：

  php public $cssOptions = ['noscript' => true];

  为使JavaScript文件包含在页面head区域（JavaScript文件默认包含在body的结束处）使用以下选项：

  php public $jsOptions = ['position' => \yii\web\View::POS_HEAD];

  Bower 和 NPM 资源
  大多数 JavaScript/CSS 包通过Bower 和/或 NPM管理， 如果你的应用或扩展使用这些包，推荐你遵循以下步骤来管理库中的资源：

  修改应用或扩展的 composer.json 文件将包列入require 中， 应使用bower-asset/PackageName (Bower包) 或 npm-asset/PackageName (NPM包)来对应库。
  创建一个资源包类并将你的应用或扩展要使用的JavaScript/CSS 文件列入到类中， 应设置 [[yii\web\AssetBundle::sourcePath|sourcePath]] 属性为@bower/PackageName 或 @npm/PackageName， 因为根据别名Composer会安装Bower或NPM包到对应的目录下。
  Note: 一些包会将它们分布式文件放到一个子目录中，对于这种情况，应指定子目录作为 [[yii\web\AssetBundle::sourcePath|sourcePath]]属性值，例如，[[yii\web\JqueryAsset]]使用 @bower/jquery/dist 而不是 @bower/jquery。

  使用资源包
  为使用资源包，在视图中调用[[yii\web\AssetBundle::register()]]方法先注册资源， 例如，在视图模板可使用如下代码注册资源包：

  php use app\assets\AppAsset; AppAsset::register($this); // $this 代表视图对象

  如果在其他地方注册资源包，应提供视图对象，如在 小部件 类中注册资源包， 可以通过 $this->view 获取视图对象。

  当在视图中注册一个资源包时，在背后Yii会注册它所依赖的资源包，如果资源包是放在Web不可访问的目录下，会被发布到可访问的目录， 后续当视图渲染页面时，会生成这些注册包包含的CSS和JavaScript文件对应的<link> 和 <script> 标签， 这些标签的先后顺序取决于资源包的依赖关系以及在 [[yii\web\AssetBundle::css]]和[[yii\web\AssetBundle::js]] 的列出来的前后顺序。

  自定义资源包
  Yii通过名为 assetManager的应用组件实现[[yii\web\AssetManager]] 来管理应用组件， 通过配置[[yii\web\AssetManager::bundles]] 属性，可以自定义资源包的行为， 例如，[[yii\web\JqueryAsset]] 资源包默认从jquery Bower包中使用jquery.js 文件， 为了提高可用性和性能，你可能需要从Google服务器上获取jquery文件，可以在应用配置中配置assetManager，如下所示：

  php return [ // ... 'components' => [ 'assetManager' => [ 'bundles' => [ 'yii\web\JqueryAsset' => [ 'sourcePath' => null, // 一定不要发布该资源 'js' => [ '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js', ] ], ], ], ], ];

  可通过类似[[yii\web\AssetManager::bundles]]配置多个资源包，数组的键应为资源包的类名（最开头不要反斜杠）， 数组的值为对应的配置数组.

  Tip: 可以根据条件判断使用哪个资源，如下示例为如何在开发环境用jquery.js，否则用jquery.min.js：

  php 'yii\web\JqueryAsset' => [ 'js' => [ YII_ENV_DEV ? 'jquery.js' : 'jquery.min.js' ] ],

  可以设置资源包的名称对应false来禁用想禁用的一个或多个资源包，当视图中注册一个禁用资源包， 视图不会包含任何该包的资源以及不会注册它所依赖的包，例如，为禁用[[yii\web\JqueryAsset]]，可以使用如下配置：

  php return [ // ... 'components' => [ 'assetManager' => [ 'bundles' => [ 'yii\web\JqueryAsset' => false, ], ], ], ];

  可设置[[yii\web\AssetManager::bundles]]为false禁用 所有 的资源包。

  资源部署
  有时你想"修复" 多个资源包中资源文件的错误/不兼容，例如包A使用1.11.1版本的jquery.min.js， 包B使用2.1.1版本的jquery.js，可自定义每个包来解决这个问题，更好的方式是使用资源部署特性来部署不正确的资源为想要的， 为此，配置[[yii\web\AssetManager::assetMap]]属性，如下所示：

  php return [ // ... 'components' => [ 'assetManager' => [ 'assetMap' => [ 'jquery.js' => '//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js', ], ], ], ];

  [[yii\web\AssetManager::assetMap|assetMap]]的键为你想要修复的资源名，值为你想要使用的资源路径， 当视图注册资源包，在[[yii\web\AssetBundle::css|css]] 和 [[yii\web\AssetBundle::js|js]] 数组中每个相关资源文件会和该部署进行对比， 如果数组任何键对比为资源文件的最后文件名（如果有的话前缀为 [[yii\web\AssetBundle::sourcePath]]），对应的值为替换原来的资源。 例如，资源文件my/path/to/jquery.js 匹配键 jquery.js.

  Note: 只有相对相对路径指定的资源对应到资源部署，替换的资源路径可以为绝对路径，也可为和[[yii\web\AssetManager::basePath]]相关的路径。

  资源发布
  如前所述，如果资源包放在Web不能访问的目录，当视图注册资源时资源会被拷贝到一个Web可访问的目录中， 这个过程称为资源发布，[[yii\web\AssetManager|asset manager]]会自动处理该过程。

  资源默认会发布到@webroot/assets目录，对应的URL为@web/assets， 可配置[[yii\web\AssetManager::basePath|basePath]] 和 [[yii\web\AssetManager::baseUrl|baseUrl]] 属性自定义发布位置。

  除了拷贝文件方式发布资源，如果操作系统和Web服务器允许可以使用符号链接，该功能可以通过设置 [[yii\web\AssetManager::linkAssets|linkAssets]] 为 true 来启用。

  php return [ // ... 'components' => [ 'assetManager' => [ 'linkAssets' => true, ], ], ];

  使用以上配置，资源管理器会创建一个符号链接到要发布的资源包源路径，这比拷贝文件方式快并能确保发布的资源一直为最新的。

  常用资源包
  Yii框架定义许多资源包，如下资源包是最常用，可在你的应用或扩展代码中引用它们。

  [[yii\web\YiiAsset]]: 主要包含yii.js 文件，该文件完成模块JavaScript代码组织功能， 也为 data-method 和 data-confirm属性提供特别支持和其他有用的功能。
  [[yii\web\JqueryAsset]]: 包含从jQuery bower 包的jquery.js文件。
  [[yii\bootstrap\BootstrapAsset]]: 包含从Twitter Bootstrap 框架的CSS文件。
  [[yii\bootstrap\BootstrapPluginAsset]]: 包含从Twitter Bootstrap 框架的JavaScript 文件来支持Bootstrap JavaScript插件。
  [[yii\jui\JuiAsset]]: 包含从jQuery UI库的CSS 和 JavaScript 文件。
  如果你的代码需要jQuery, jQuery UI 或 Bootstrap，应尽量使用这些预定义资源包而非自己创建， 如果这些包的默认配置不能满足你的需求，可以自定义配置，详情参考自定义资源包。

  资源转换
  除了直接编写CSS 和/或 JavaScript代码，开发人员经常使用扩展语法来编写，再使用特殊的工具将它们转换成CSS/Javascript。 例如，对于CSS代码可使用LESS 或 SCSS， 对于JavaScript 可使用 TypeScript。

  可将使用扩展语法的资源文件列到资源包的[[yii\web\AssetBundle::css|css]] 和 [[yii\web\AssetBundle::js|js]]中，如下所示：

  php class AppAsset extends AssetBundle { public $basePath = '@webroot'; public $baseUrl = '@web'; public $css = [ 'css/site.less', ]; public $js = [ 'js/site.ts', ]; public $depends = [ 'yii\web\YiiAsset', 'yii\bootstrap\BootstrapAsset', ]; }

  当在视图中注册一个这样的资源包，[[yii\web\AssetManager|asset manager]]资源管理器会自动运行预处理工具将使用扩展语法 的资源转换成CSS/JavaScript，当视图最终渲染页面时，在页面中包含的是CSS/Javascipt文件，而不是原始的扩展语法代码文件。

  Yii使用文件扩展名来表示资源使用哪种扩展语法，默认可以识别如下语法和文件扩展名：

  LESS: .less
  SCSS: .scss
  Stylus: .styl
  CoffeeScript: .coffee
  TypeScript: .ts
  Yii依靠安装的预处理工具来转换资源，例如，为使用LESS，应安装lessc 预处理命令。

  可配置[[yii\web\AssetManager::converter]]自定义预处理命令和支持的扩展语法，如下所示：

  php return [ 'components' => [ 'assetManager' => [ 'converter' => [ 'class' => 'yii\web\AssetConverter', 'commands' => [ 'less' => ['css', 'lessc {from} {to} --no-color'], 'ts' => ['js', 'tsc --out {to} {from}'], ], ], ], ], ];

  如上所示，通过[[yii\web\AssetConverter::commands]] 属性指定支持的扩展语法， 数组的键为文件扩展名（前面不要.），数组的值为目标资源文件扩展名和执行资源转换的命令， 命令中的标记 {from} 和{to}会分别被源资源文件路径和目标资源文件路径替代。

  Info: 除了以上方式，也有其他的方式来处理扩展语法资源，例如，可使用编译工具如grunt 来监控并自动转换扩展语法资源，此时，应使用资源包中编译后的CSS/Javascript文件而不是原始文件。

  合并和压缩资源
  一个Web页面可以包含很多CSS 和/或 JavaScript 文件，为减少HTTP 请求和这些下载文件的大小， 通常的方式是在页面中合并并压缩多个CSS/JavaScript 文件为一个或很少的几个文件，并使用压缩后的文件而不是原始文件。

  Info: 合并和压缩资源通常在应用在产品上线模式，在开发模式下使用原始的CSS/JavaScript更方便调试。

  接下来介绍一种合并和压缩资源文件而不需要修改已有代码的方式：

  找出应用中所有你想要合并和压缩的资源包，
  将这些包分成一个或几个组，注意每个包只能属于其中一个组，
  合并/压缩每个组里CSS文件到一个文件，同样方式处理JavaScript文件，
  为每个组定义新的资源包：
  设置[[yii\web\AssetBundle::css|css]] 和 [[yii\web\AssetBundle::js|js]] 属性分别为压缩后的CSS和JavaScript文件；
  自定义设置每个组内的资源包，设置资源包的[[yii\web\AssetBundle::css|css]] 和 [[yii\web\AssetBundle::js|js]] 属性为空, 并设置它们的 [[yii\web\AssetBundle::depends|depends]] 属性为每个组新创建的资源包。
  使用这种方式，当在视图中注册资源包时，会自动触发原始包所属的组资源包的注册，然后，页面就会包含以合并/压缩的资源文件， 而不是原始文件。

  示例
  使用一个示例来解释以上这种方式：

  假定你的应用有两个页面X 和 Y，页面X使用资源包A，B和C，页面Y使用资源包B，C和D。

  有两种方式划分这些资源包，一种使用一个组包含所有资源包，另一种是将（A,B,C）放在组X，（B，C，D）放在组Y， 哪种方式更好？第一种方式优点是两个页面使用相同的已合并CSS和JavaScript文件使HTTP缓存更高效，另一方面，由于单个组包含所有文件， 已合并的CSS和Javascipt文件会更大，因此会增加文件传输时间，在这个示例中，我们使用第一种方式，也就是用一个组包含所有包。

  Info: 将资源包分组并不是无价值的，通常要求分析现实中不同页面各种资源的数据量，开始时为简便使用一个组。

  在所有包中使用工具(例如 Closure Compiler, YUI Compressor) 来合并和压缩CSS和JavaScript文件， 注意合并后的文件满足包间的先后依赖关系，例如，如果包A依赖B，B依赖C和D，那么资源文件列表以C和D开始，然后为B最后为A。

  合并和压缩之后，会得到一个CSS文件和一个JavaScript文件，假定它们的名称为all-xyz.css 和 all-xyz.js， xyz 为使文件名唯一以避免HTTP缓存问题的时间戳或哈希值。

  现在到最后一步了，在应用配置中配置[[yii\web\AssetManager|asset manager]] 资源管理器如下所示：

  php return [ 'components' => [ 'assetManager' => [ 'bundles' => [ 'all' => [ 'class' => 'yii\web\AssetBundle', 'basePath' => '@webroot/assets', 'baseUrl' => '@web/assets', 'css' => ['all-xyz.css'], 'js' => ['all-xyz.js'], ], 'A' => ['css' => [], 'js' => [], 'depends' => ['all']], 'B' => ['css' => [], 'js' => [], 'depends' => ['all']], 'C' => ['css' => [], 'js' => [], 'depends' => ['all']], 'D' => ['css' => [], 'js' => [], 'depends' => ['all']], ], ], ], ];

  如自定义资源包 小节中所述，如上配置改变每个包的默认行为， 特别是包A、B、C和D不再包含任何资源文件，都依赖包含合并后的all-xyz.css 和 all-xyz.js文件的包all， 因此，对于页面X会包含这两个合并后的文件而不是包A、B、C的原始文件，对于页面Y也是如此。

  最后有个方法更好地处理上述方式，除了直接修改应用配置文件，可将自定义包数组放到一个文件，在应用配置中根据条件包含该文件，例如：

  php return [ 'components' => [ 'assetManager' => [ 'bundles' => require __DIR__ . '/' . (YII_ENV_PROD ? 'assets-prod.php' : 'assets-dev.php'), 
  ], ], ];

  如上所示，产品在上线模式时资源包配置数组存储在assets-prod.php文件中，在开发模式时存储在assets-dev.php文件中。

  使用 asset 命令
  Yii提供一个名为asset控制台命令来使上述操作自动处理。

  在使用该命令之前，先创建一个配置文件来设置要合并的资源包以及资源包的分组方式，可使用asset/template 子命令来生成一个模板， 然后修改模板成你想要的。

  yii asset/template assets.php

  该命令在当前目录下生成一个名为assets.php的文件，文件的内容类似如下：

  php <?php /** * 为控制台命令"yii asset"使用的配置文件 * 注意在控制台环境下，一些路径别名如 '@webroot' 和 '@web' 不会存在 * 请定义不存在的路径别名 */ return [ // 为JavaScript文件压缩修改 command/callback 'jsCompressor' => 'java -jar compiler.jar --js {from} --js_output_file {to}', // 为CSS文件压缩修改command/callback 'cssCompressor' => 'java -jar yuicompressor.jar --type css {from} -o {to}', // 要压缩的资源包列表 'bundles' => [ // 'yii\web\YiiAsset', // 'yii\web\JqueryAsset', ], // 资源包压缩后的输出 'targets' => [ 'all' => [ 'class' => 'yii\web\AssetBundle', 'basePath' => '@webroot/assets', 'baseUrl' => '@web/assets', 'js' => 'js/all-{hash}.js', 'css' => 'css/all-{hash}.css', ], ], // 资源管理器配置: 'assetManager' => [ ], ];

  应修改该文件的bundles的选项指定哪些包你想要合并，在targets选项中应指定这些包如何分组，如前述的可以指定一个或多个组。

  Note: 由于在控制台应用别名 @webroot and @web 不可用，应在配置中明确指定它们。

  JavaScript文件会被合并压缩后写入到js/all-{hash}.js文件，其中 {hash} 会被结果文件的哈希值替换。

  jsCompressor 和 cssCompressor 选项指定控制台命令或PHP回调函数来执行JavaScript和CSS合并和压缩， Yii默认使用Closure Compiler来合并JavaScript文件， 使用YUI Compressor来合并CSS文件， 你应手工安装这些工具或修改选项使用你喜欢的工具。

  根据配置文件，可执行asset 命令来合并和压缩资源文件并生成一个新的资源包配置文件assets-prod.php:

  yii asset assets.php config/assets-prod.php

  生成的配置文件可以在应用配置中包含，如最后一小节所描述的。

  Info: 使用asset 命令并不是唯一一种自动合并和压缩过程的方法，可使用优秀的工具grunt来完成这个过程。

  资源包分组
  上一小节，介绍了如何压缩所有的资源包到一个文件，减少对应用中引用资源文件的 http 请求数，但是在实践中很少这样做。比如，应用有一个“前端”和一个“后端”，每一个都用了一个不同js和css文件集合。在这种情况下，把所有的资源包压缩到一个文件毫无意义，“前端”不会用到“后端”的资源文件，当请求“前端”页面时，“后端”的资源文件也会被发送过来，浪费网络带宽。

  为了解决这个问题，可以吧资源包分成若干组，每个组里面有若干个资源包。下面的配置展示了如何对资源包分组：

  php return [ ... //指定分组后输出的资源包 'targets' => [ 'allShared' => [ 'js' => 'js/all-shared-{hash}.js', 'css' => 'css/all-shared-{hash}.css', 'depends' => [ // “前端”和“后端”共享的资源包： 'yii\web\YiiAsset', 'app\assets\SharedAsset', ], ], 'allBackEnd' => [ 'js' => 'js/all-{hash}.js', 'css' => 'css/all-{hash}.css', 'depends' => [ // 后端资源包： 'app\assets\AdminAsset' ], ], 'allFrontEnd' => [ 'js' => 'js/all-{hash}.js', 'css' => 'css/all-{hash}.css', 'depends' => [], // Include all remaining assets ], ], ... ];

  如上所示，资源包分成了三个组：allShared，allBackEnd 和 allFrontEnd

  他们分别依赖其他资源包，例如，allBackEnd 依赖（depends） app\assets\AdminAsset。当使用这个配置运行 asset 命令时，将会根据上面的指定组合资源包。

  Info: 其中的一个资源包depends配置选项可以留空不配置。如果这样做了的话，留空的这个资源包将会依赖剩余的没有被其他资源包所依赖的资源包。
*** 扩展（Extensions）
**** 扩展
  扩展程序是可再发行的软件包，专门设计用于Yii应用程序并提供随时可用的功能。
  例如，yiisoft / yii2-debug扩展在应用程序的每个页面底部添加了一个方便的调试工具栏，以帮助您更轻松地掌握页面的生成过程。您可以使用扩展来加速您的开发过程。您也可以将您的代码打包为扩展名，以便与其他人共享您的伟大工作。
  信息：我们使用术语“扩展”来指代Yii特定的软件包。对于可以在没有Yii的情况下使用的通用软件包，我们将使用术语“包”或“库”来引用它们。

**** 使用扩展
     要使用扩展，您需要先安装它。大多数扩展都是作为Composer 包分发的，可以通过以下两个简单的步骤进行安装：
***** 安装扩展
      修改composer.json应用程序的文件并指定要安装的扩展名（Composer包）。
      运行composer install安装指定的扩展。

      默认情况下，Composer会安装在Packagist上注册的软件包- 
      最大的开源Composer软件包库。您可以在Packagist上查找扩展。您也可以 创建自己的存储库并配置Composer来使用它。如果您正在开发已关闭的开放式扩展程序并希望在您的项目中共享，这非常有用。

      由作曲家安装的扩展存储在BasePath/vendor目录中，其中BasePath涉及到应用程序的基本路径。因为Composer是一个依赖管理器，所以当它安装一个包时，它也会安装所有的依赖包。

  例如，要安装yiisoft/yii2-imagine扩展，请修改composer.json如下所示：
  #+BEGIN_SRC json
    {
        // ...

        "require": {
            // ... other dependencies

            "yiisoft/yii2-imagine": "~2.0.0"
        }
    }
  那么 在BasePath/vendor/ 下 有 yiisoft/yii2-imagine 包
  #+END_SRC

***** 使用扩展

  #+BEGIN_SRC php
  use Yii;
  use yii\imagine\Image;

  // generate a thumbnail image
  Image::thumbnail('@webroot/img/test-image.jpg', 120, 120)
      ->save(Yii::getAlias('@runtime/thumb-test-image.jpg'), ['quality' => 50]);

  信息：扩展类由Yii类自动加载器自动加载。
  #+END_SRC

***** 手动安装扩展
  在极少数情况下，您可能需要手动安装部分或全部扩展，而不是依靠Composer。要这样做，你应该

  下载扩展档案文件并将其解压到vendor目录中。
  安装扩展提供的类自动加载器（如果有的话）。
  请按照说明下载并安装所有相关的扩展。
  如果扩展名没有类自动加载器，但是遵循PSR-4标准，则可以使用Yii提供的类自动加载器来自动加载扩展类。你所要做的只是为扩展根目录声明一个根别名。例如，假设您在目录中安装了扩展名vendor/mycompany/myext，并且扩展类位于myext命名空间下，则可以在应用程序配置中包含以下代码：

  php [ 'aliases' => [ '@myext' => '@vendor/mycompany/myext', ], ]

***** 创建扩展
      你可以考虑创建一个扩展，当你觉得需要与其他人分享你的伟大的代码。一个扩展可以包含你喜欢的任何代码，比如一个辅助类，一个控件，一个模块等等。

      建议您根据Composer软件包创建扩展，以便其他用户可以更容易地安装和使用扩展，如上一小节所述。

      以下是您可以遵循的将Composer创建为Composer包的基本步骤。

      为您的扩展创建项目并将其托管在VCS存储库（如github.com）上。关于扩展的开发和维护工作应该在这个存储库上完成。
  在项目的根目录下，创建一个命名composer.json为Composer所需的文件。有关更多详细信息，请参阅下一小节。
  将您的扩展程序注册到Composer存储库（如Packagist），以便其他用户可以使用Composer找到并安装您的扩展。
  composer.json
  每个Composer软件包composer.json的根目录中都必须有一个文件。该文件包含有关软件包的元数据。您可以在Composer手册中找到关于该文件的完整规范。以下示例显示composer.json了yiisoft/yii2-imagine扩展的文件：
  #+BEGIN_SRC json
  {
      // package name
      "name": "yiisoft/yii2-imagine",

      // package type
      "type": "yii2-extension",

      "description": "The Imagine integration for the Yii framework",
      "keywords": ["yii2", "imagine", "image", "helper"],
      "license": "BSD-3-Clause",
      "support": {
          "issues": "https://github.com/yiisoft/yii2/issues?labels=ext%3Aimagine",
          "forum": "http://www.yiiframework.com/forum/",
          "wiki": "http://www.yiiframework.com/wiki/",
          "irc": "irc://irc.freenode.net/yii",
          "source": "https://github.com/yiisoft/yii2"
      },
      "authors": [
          {
              "name": "Antonio Ramirez",
              "email": "amigo.cobos@gmail.com"
          }
      ],

      // package dependencies
      "require": {
          "yiisoft/yii2": "~2.0.0",
          "imagine/imagine": "v0.5.0"
      },

      // class autoloading specs
      "autoload": {
          "psr-4": {
              "yii\\imagine\\": ""
          }
      }
  }
  #+END_SRC
**** 包名
  每个Composer软件包都应该有一个软件包名称，用于唯一标识所有其他软件包。包名的格式是vendorName/projectName。例如，在包名称yiisoft/yii2-imagine，供应商名和项目名称是yiisoft和yii2-imagine分别。

  不要yiisoft用作供应商名称，因为它被保留供Yii核心代码使用。

  例如，我们建议您yii2-在表示Yii 2扩展的包的项目名称前面添加 前缀myname/yii2-mywidget。这将允许用户更容易地分辨一个包是否是Yii 2的扩展。

**** 包类型
  指定扩展的软件包类型非常重要，yii2-extension以便在安装时可将软件包识别为Yii扩展。

  当用户运行composer install安装扩展时，文件vendor/yiisoft/extensions.php 将自动更新以包含新扩展的信息。从这个文件中，Yii应用程序可以知道安装了哪些扩展（信息可以通过[[yii \ base \ Application :: extensions]]来访问。

**** 依赖
  你的扩展取决于Yii（当然）。所以，你应该列出来（yiisoft/yii2在）require的条目composer.json。如果您的扩展也取决于其他扩展或第三方库，您也应该列出它们。确保您还列出了每个相关软件包的相应版本限制（例如1.*，@stable）。当您的扩展程序以稳定版本发布时，请使用稳定的依赖关系。

  大多数JavaScript / CSS包使用Bower和/或NPM而不是Composer进行管理。Yii使用Composer资源插件 来通过Composer来管理这些类型的包。如果你的扩展依赖于一个Bower包，你可以简单地列出依赖关系，composer.json如下所示：

  json { // package dependencies "require": { "bower-asset/jquery": ">=1.11.*" } }

  上面的代码指出扩展取决于jqueryBower包。一般而言，您可以使用 bower-asset/PackageName参考一个Bower软件包composer.json，并用它npm-asset/PackageName 来指代一个NPM软件包。当Composer安装Bower或NPM软件包时，默认情况下软件包内容将分别安装在@vendor/bower/PackageName和@vendor/npm/Packages目录下。这两个目录也可以使用较短的别名@bower/PackageName和@npm/PackageName。

  有关资产管理的更多详情，请参阅资产部分。

***** 类自动加载
  为了让您的类自动加载Yii类自动加载器或Composer类自动加载器，您应该autoload在composer.json文件中指定条目，如下所示：

  ```json {// ...

  "autoload": {
      "psr-4": {
          "yii\\imagine\\": ""
      }
  }
  }``

  您可以列出一个或多个根名称空间及其相应的文件路径。

  当扩展程序安装在应用程序中时，Yii将为每个列出的根名称空间创建一个别名，该别名引用与名称空间相对应的目录。例如，上面的autoload声明将对应一个别名@yii/imagine。

  推荐做法
  因为扩展是为了让其他人使用，所以你经常需要额外的开发工作。下面我们介绍一些常见和推荐的做法，以创建高质量的扩展。

  命名空间
  为了避免名称冲突，并使扩展中的类自动加载，应使用命名空间并按照PSR-4标准或 PSR-0标准命名扩展中的类。

  你应该从类名称空间开始vendorName\extensionName，其中extensionName类似于包名称中的项目名称，但不应包含yii2-前缀。例如，对于yiisoft/yii2-imagine 扩展，我们使用它yii\imagine作为命名空间的类。

  不要使用yii，yii2或yiisoft作为供应商的名称。这些名字被保留供Yii核心代码使用。

  引导类
  有时，您可能希望您的扩展在 应用程序的引导过程阶段执行一些代码。例如，您的扩展可能要响应应用程序的beginRequest事件来调整一些环境设置。虽然您可以指示扩展的用户明确地将事件处理程序附加到事件的扩展中beginRequest，但更好的方法是自动执行此操作。

  为了实现这个目标，你可以通过实现[[yii \ base \ BootstrapInterface]] 来创建一个所谓的bootstrapping类。例如，

  php命名空间myname \ mywidget;

  使用yii \ base \ BootstrapInterface; 使用yii \ base \ Application;

  class MyBootstrapClass implements BootstrapInterface {public function bootstrap（$ app）{$ app-> on（Application :: EVENT BEFORE REQUEST，function（）{//在这里做某事}）; }}``

  然后composer.json，你可以像下面这样在你的扩展文件中列出这个类，

  ```json {// ...

  "extra": {
      "bootstrap": "myname\\mywidget\\MyBootstrapClass"
  }
  }``

  当扩展程序安装在应用程序中时，Yii将自动实例化引导类，并在引导过程中为每个请求调用它的[[yii \ base \ BootstrapInterface :: bootstrap（）| bootstrap（）]]方法。

  使用数据库
  您的扩展可能需要访问数据库。不要认为使用您的扩展的应用程序将始终Yii::$db用作数据库连接。相反，您应该db为需要数据库访问的类声明一个属性。该属性将允许您的扩展用户自定义哪个数据库连接，他们希望您的扩展使用。作为一个例子，你可以参考[[yii \ caching \ DbCache]]类，看看它是如何声明和使用该db属性。

  如果您的扩展需要创建特定的数据库表或更改数据库模式，您应该

  提供迁移操作数据库模式，而不是使用普通的SQL文件;
  尽量使迁移适用于不同的DBMS;
  避免在迁移中使用Active Record。
  使用资产
  如果你的扩展是一个小部件或一个模块，很可能需要一些资源才能工作。例如，一个模块可能会显示一些包含图像，JavaScript和CSS的页面。因为扩展的文件都安装在应用程序中安装的Web目录下的同一个目录下，所以有两种选择可以通过Web直接访问资源文件：

  请求扩展的用户手动将资产文件复制到特定的Web可访问文件夹;
  申报资产包，并依靠资产发布机制自动将资产包中列出的文件复制到可访问Web的文件夹中。
  我们建议您使用第二种方法，以便您的扩展程序可以被其他人更容易地使用。有关如何使用资产的更多详细信息，请参阅资产部分。

  国际化与本土化
  您的扩展可能被支持不同语言的应用程序使用！因此，如果您的扩展程序向最终用户显示内容，则应尝试对其进行国际化和本地化。尤其是，

  如果扩展程序显示给最终用户的消息，则应将消息打包，Yii::t() 以便可以进行翻译。用于开发者的信息（如内部异常信息）不需要翻译。
  如果扩展名显示数字，日期等，则应使用带有适当格式规则的[[yii \ i18n \ Formatter]]格式化。
  有关更多详细信息，请参阅国际化部分。

  测试
  你希望你的扩展能够完美运行而不会给其他人带来问题。为了实现这个目标，你应该测试你的扩展，然后才能发布给公众。

  建议您创建各种测试用例来覆盖您的扩展代码，而不是依靠手动测试。每次在您发布扩展的新版本之前，您都可以简单地运行这些测试用例，以确保一切正常。Yii提供测试支持，可以帮助您更轻松地编写单元测试，验收测试和功能测试。有关更多详细信息，请参阅测试部分。

  版本
  你应该给你的扩展版本号（例如1.0.1）。在确定应该使用什么版本号时，我们建议您遵循 语义版本管理规范。

  释放
  为了让其他人知道你的分机，你需要把它公开。

  如果这是您第一次发布扩展名，则应将其注册到Composer存储库（如 Packagist）中。之后，您只需v1.0.1在扩展的VCS存储库上创建一个发行标签（例如），并通知Composer存储库有关新版本。然后，用户将能够找到新版本，并通过Composer存储库安装或更新扩展。

  在扩展的版本中，除了代码文件外，还应该考虑包括以下内容来帮助其他人了解和使用扩展：

  软件包根目录中的自述文件：它描述了您的扩展名以及如何安装和使用它。我们建议您使用Markdown格式进行编写，并将其命名为readme.md。
  软件包根目录中的更新日志文件：它列出了每个版本中所做的更改。该文件可能以Markdown格式书写并命名为changelog.md。
  软件包根目录中的升级文件：它提供了有关如何从旧版本扩展升级的说明。该文件可能以Markdown格式书写并命名为upgrade.md。
  教程，演示，屏幕截图等：如果您的扩展程序提供了自述文件中无法完全覆盖的许多功能，则需要使用这些功能。
  API文档：您的代码应该记录良好，以便其他人更容易阅读和理解它。您可以引用BaseObject类文件 来学习如何记录您的代码。
  信息：您的代码评论可以用Markdown格式编写。该yiisoft/yii2-apidoc扩展提供了一个工具，可以根据您的代码注释生成漂亮的API文档。

  信息：虽然不是要求，我们建议您的扩展遵守某些编码风格。您可以参考核心框架代码风格。

  核心扩展
  Yii提供由Yii开发团队开发和维护的以下核心扩展。它们都在Packagist上注册，可以按照使用扩展小节中的描述轻松安装 。

  yiisoft / yii2-apidoc：提供了一个可扩展且高性能的API文档生成器。它也被用来生成核心框架API文档。
  yiisoft / yii2-authclient：提供一组常用的auth客户端，例如Facebook OAuth2客户端，GitHub OAuth2客户端。
  yiisoft / yii2-bootstrap：提供一组封装Bootstrap组件和插件的小部件。
  yiisoft / yii2-codeception：提供基于Codeception的测试支持。
  yiisoft / yii2-debug：为Yii应用程序提供调试支持。当使用此扩展名时，每个页面的底部都会出现一个调试器工具栏。该扩展还提供了一组独立的页面来显示更详细的调试信息。
  yiisoft / yii2-elasticsearch：为使用Elasticsearch提供支持。它包括基本的查询/搜索支持，还实现了Active Record模式，允许您将活动记录存储在Elasticsearch中。
  yiisoft / yii2-faker：为使用Faker生成假数据提供支持。
  yiisoft / yii2-gii：提供了一个基于Web的代码生成器，它是高度可扩展的，可用于快速生成模型，表单，模块，CRUD等。
  yiisoft / yii2-httpclient：提供一个HTTP客户端。
  yiisoft / yii2-imagine：提供基于Imagine的常用图像处理函数。
  yiisoft / yii2-jui：提供了一组封装了JQuery UI交互和小部件的小部件。
  yiisoft / yii2-mongodb：为使用MongoDB提供支持。它包括基本查询，Active Record，迁移，缓存，代码生成等功能。
  yiisoft / yii2-redis：提供使用redis的支持。它包括基本查询，活动记录，缓存等功能。
  yiisoft / yii2-smarty：提供基于Smarty的模板引擎。
  yiisoft / yii2-sphinx：提供使用Sphinx的支持。它包括基本查询，活动记录，代码生成等功能。
  yiisoft / yii2-swiftmailer：提供基于swiftmailer的邮件发送功能。
  yiisoft / yii2-twig：提供了一个基于Twig的模板引擎。
** 请求处理（Handling Requests）
*** 运行概述（Overview）
    每一次 Yii 应用开始处理 HTTP 请求时，它都会进行一个近似的流程。

   用户提交指向 入口脚本 web/index.php 的请求。
   入口脚本会加载 配置数组 并创建一个 应用 实例用于处理该请求。
   应用会通过 request（请求） 应用组件解析被请求的 路由。
   应用创建一个 controller（控制器） 实例具体处理请求。
   控制器会创建一个 action（动作） 实例并为该动作执行相关的 Filters（访问过滤器）。
   如果任何一个过滤器验证失败，该动作会被取消。
   如果全部的过滤器都通过，该动作就会被执行。
   动作会加载一个数据模型，一般是从数据库中加载。
   动作会渲染一个 View（视图），并为其提供所需的数据模型。
   渲染得到的结果会返回给 response（响应） 应用组件。
   响应组件会把渲染结果发回给用户的浏览器。
   
   [[file:image/yiiliucheng.png][流程]]


*** 启动引导（Bootstrapping）
    启动引导是指：在应用开始解析并处理新接受请求之前，一个预先准备环境的过程。
    启动引导会在两个地方具体进行：入口脚本(Entry Script) 和 应用主体（application）。

**** 在入口脚本里，需注册各个类库的类文件自动加载器（Class Autoloader，简称自动加载器）。
    这主要包括通过其 autoload.php 文件加载的 Composer 自动加载器，以及通过 Yii 类加载的 Yii
    自动加载器。之后，入口脚本会加载应用的 配置（configuration） 并创建一个 应用主体 的实例。

****  在应用主体的构造函数中，会执行以下引导工作：
     调用 preInit()(预初始化）方法，配置一些高优先级的应用属性，比如 basePath属性。
     注册错误处理器（ErrorHandler）
     通过给定的应用配置初始化应用的各属性。
     通过调用 init()方法，它会顺次调用 bootstrap()从而运行引导组件。
     加载扩展清单文件(extension manifest file) vendor/yiisoft/extensions.php。
     创建并运行各个扩展声明的 引导组件（bootstrap components）。
     创建并运行各个 应用组件 以及在应用的 Bootstrap 属性中声明的各个 模块（modules）组件（如果有）。
     
     因为引导工作必须在处理每一次请求之前都进行一遍，因此让该过程尽可能轻量化就异常重要，
     请尽可能地优化这一步骤。

     请尽量不要注册太多引导组件。只有他需要在 HTTP 请求处理的全部生命周期中都作用时才需要使用它。
     举一个用到它的范例：一个模块需要注册额外的 URL 解析规则，就应该把它列在应用的 bootstrap 
     属性之中，这样该 URL 解析规则才能在解析请求之前生效。（译注：换言之，为了性能需要，除了 URL
     解析等少量操作之外，绝大多数组件都应该按需加载，而不是都放在引导过程中。）

     在生产环境中，可以开启字节码缓存，比如 APC，来进一步最小化加载和解析 PHP 文件所需的时间。
     一些大型应用都包含有非常复杂的应用配置，它们会被分割到许多更小的配置文件中。此时，可以考虑将整个配置数组缓存起来，
     并在入口脚本创建应用实例之前直接从缓存中加载。
*** 引导（Bootstrapping）
*** 路由引导与创建URL（Routing and URL Creation）
    当入口脚本在调用 yii\web\Application::run()方法时，它进行的第一个操作就是解析输入的请求，
    然后实例化对应的控制器操作处理这个请求。该过程就被称为引导路由（routing）

**** 解析路由
  路由引导的第一步，是把传入请求解析为一个路由。如我们在 控制器（Controllers） 章节中所描述的那样，
  路由是一个用于定位控制器操作的地址。这个过程通过 request 应用组件的 yii\web\Request::resolve()方法实现，
  该方法会调用 URL 管理器 进行实质上的请求解析工作。

  默认情况下，传入请求会包含一个名为 r 的 GET 参数，它的值即被视为路由。但是如果启用 [[yii\web\UrlManager::enablePrettyUrl|美化 URL 功能]]，那么在确定请求的路由时，就会进行更多处理。具体的细节请参考 URL 的解析与生成 章节。

  假使某路由最终实在无法被确定，那么 request 组件会抛出 [[yii\web\NotFoundHttpException]] 异常（译注：大名鼎鼎的 404）。

  缺省路由
  如果传入请求并没有提供一个具体的路由，（一般这种情况多为于对首页的请求）此时就会启用由 [[yii\web\Application::defaultRoute]] 属性所指定的缺省路由。该属性的默认值为 site/index，它指向 site 控制器的 index 操作。你可以像这样在应用配置中调整该属性的值：

  php return [ // ... 'defaultRoute' => 'main/index', ];

  catchAll 路由（全拦截路由）
  有时候，你会想要将你的 Web 应用临时调整到维护模式，所有的请求下都会显示相同的信息页。当然，要实现这一点有很多种方法。这里面最简单快捷的方法就是在应用配置中设置下 [[yii\web\Application::catchAll]] 属性：

  php return [ // ... 'catchAll' => ['site/offline'], ];

  catchAll 属性需要传入一个数组做参数，该数组的第一个元素为路由，剩下的元素会（以名值对的形式）指定绑定于该操作的各个参数。

  当设置了 catchAll 属性时，它会替换掉所有从输入的请求中解析出来的路由。如果是上文的这种设置，用于处理所有传入请求的操作都会是相同的 site/offline。

  创建操作
  一旦请求路由被确定了，紧接着的步骤就是创建一个“操作（action）”对象，用以响应该路由。

  路由可以用里面的斜杠分割成多个组成片段，举个栗子，site/index 可以分解为 site 和 index 两部分。每个片段都是指向某一模块（Module）、控制器（Controller）或操作（action）的 ID。

  从路由的首个片段开始，应用会经过以下流程依次创建模块（如果有），控制器，以及操作：

  设置应用主体为当前模块。
  检查当前模块的 [[yii\base\Module::controllerMap|controller map（控制器映射表）]] 是否包含当前 ID。如果是，会根据该表中的配置创建一个控制器对象，然后跳到步骤五执行该路由的后续片段。
  检查该 ID 是否指向当前模块中 [[yii\base\Module::modules|modules]] 属性里的模块列表中的一个模块。如果是，会根据该模块表中的配置创建一个模块对象，然后会以新创建的模块为环境，跳回步骤二解析下一段路由。
  将该 ID 视为控制器 ID，并创建控制器对象。用下个步骤解析路由里剩下的片段。
  控制器会在他的 [[yii\base\Controller::actions()|action map（操作映射表）]]里搜索当前 ID。如果找得到，它会根据该映射表中的配置创建一个操作对象；反之，控制器则会尝试创建一个与该 ID 相对应，由某个 action 方法所定义的行内操作（inline action）。
  在上面的步骤里，如果有任何错误发生，都会抛出 [[yii\web\NotFoundHttpException]]，指出路由引导的过程失败了。
*** 请求（Requests）
    请求
  应用的请求使用 [[yii\web\Request]] 对象来表示，它提供了请求参数、HTTP 头、cookie 等信息。 对于一个给定的请求，你可以通过 request 应用组件 来访问，默认情况下它是 [[yii\web\Request]] 的实例。在本节中，我们将介绍如何在应用中使用此组件。

  请求参数
  你可以通过 request 组件的 [[yii\web\Request::get()|get()]] 和 [[yii\web\Request::post()|post()]] 方法来获取请求参数。 它分别返回 $_GET 和 $_POST 的值。例如:

  ```php $request = Yii::$app->request;

  $get = $request->get(); // equivalent to: $get = $_GET;

  $id = $request->get('id'); // equivalent to: $id = isset($GET['id']) ? $GET['id'] : null;

  $id = $request->get('id', 1); // equivalent to: $id = isset($GET['id']) ? $GET['id'] : 1;

  $post = $request->post(); // equivalent to: $post = $_POST;

  $name = $request->post('name'); // equivalent to: $name = isset($POST['name']) ? $POST['name'] : null;

  $name = $request->post('name', ''); // equivalent to: $name = isset($POST['name']) ? $POST['name'] : ''; ```

  Info: 推荐上面的方式使用 request 组件来获取请求参数而不是直接使用 $_GET 和 $_POST。这将使编写测试变得更容易，因为您可以创建一个带有伪造请求数据的模拟请求组件。

  在实现 RESTful APIs 是，你通常会需要获取 PUT、PATCH 或其他 请求方法 提交的参数. 你可以通过调用 [[yii\web\Request::getBodyParam()]] 方法来获取。例如:

  ```php $request = Yii::$app->request;

  // returns all parameters $params = $request->bodyParams;

  // returns the parameter "id" $param = $request->getBodyParam('id'); ```

  Info: 和 GET 参数不同，通过 POST、PUT、PATCH 等提交的参数实在请求体中发送。 当使用上述方式访问它们时, request 组件将解析这些参数。 你可以通过配置 [[yii\web\Request::parsers]] 属性来自定义解析这些参数的方式。

  请求方法
  你可以通过 Yii::$app->request->method 来获取当前请求使用的 HTTP 请求方法。 request 还提供了一组布尔属性，用来检查当前请求是否具有某种类型。例如:

  ```php $request = Yii::$app->request;

  if ($request->isAjax) { /* the request is an AJAX request / } if ($request->isGet) { / the request method is GET / } if ($request->isPost) { / the request method is POST / } if ($request->isPut) { / the request method is PUT */ } ```

  请求 URLs
  request 组件提供了许多检查当前请求地址的方法。

  如果被请求的 URL 是 http://example.com/admin/index.php/product?id=100，您可以得到以下内容的不同部分:

  [[yii\web\Request::url|url]]: 返回 /admin/index.php/product?id=100, 没有 host info 部分的 URL。
  [[yii\web\Request::absoluteUrl|absoluteUrl]]: 返回 http://example.com/admin/index.php/product?id=100，包含 host info 的完整 URL 地址。
  [[yii\web\Request::hostInfo|hostInfo]]: 返回 http://example.com，URL 的 host info 部分。
  [[yii\web\Request::pathInfo|pathInfo]]: 返回 /product，在脚本和问号(查询字符串)之间的部分。
  [[yii\web\Request::queryString|queryString]]: 返回 id=100，问号后面的部分。
  [[yii\web\Request::baseUrl|baseUrl]]: 返回 /admin，在 host info 和脚本名称之间的部分。
  [[yii\web\Request::scriptUrl|scriptUrl]]: 返回 /admin/index.php，不包含 host info 和 查询字符串的部分。
  [[yii\web\Request::serverName|serverName]]: 返回 example.com，URL 中的主机名。
  [[yii\web\Request::serverPort|serverPort]]: 返回 80，WEB 服务器使用的端口。
  HTTP 头信息
  你可以通过 [[yii\web\Request::headers]] 返回的 [[yii\web\HeaderCollection|header collection]] 属性来获取 HTTP 头信息。例如:

  ```php // $headers is an object of yii\web\HeaderCollection $headers = Yii::$app->request->headers;

  // returns the Accept header value $accept = $headers->get('Accept');

  if ($headers->has('User-Agent')) { /* there is User-Agent header */ } ```

  请求 组件还支持快速访问一些常用的头信息，包括:

  [[yii\web\Request::userAgent|userAgent]]: 返回 User-Agent 的头信息的值。
  [[yii\web\Request::contentType|contentType]]: 返回 Content-Type 的头信息的值，它表示请求请求主体中数据的 MIME 类型。
  [[yii\web\Request::acceptableContentTypes|acceptableContentTypes]]: 返回用户可以接受的内容 MIME 类型。返回类型根据它们的评分。高评分的类型首先返回。
  [[yii\web\Request::acceptableLanguages|acceptableLanguages]]: 返回用户可接受的语言。返回的语言是由它们的优先级排序的。第一个元素表示最优先的语言。
  如果您的应用支持多语言，并且你想根据是最终用户语言显示页面的语言。你可以通过语言协商方法 [[yii\web\Request::getPreferredLanguage()]] 来设置。

  此方法将你的应用支持的语言列表和 [[yii\web\Request::acceptableLanguages|acceptableLanguages]] 进行对比来返回合适的语言。

  Tip: 同样，你可以使用 [[yii\filters\ContentNegotiator|ContentNegotiator]] 过滤器来动态决定响应中应该使用的内容类型和语言。这个过滤器实现了上述属性和方法中的内容协商。

  客户端信息
  你可以分别通过 [[yii\web\Request::userHost|userHost]] 和 [[yii\web\Request::userIP|userIP]] 来获取客户端机器的机器名和 IP 地址。例如:

  php $userHost = Yii::$app->request->userHost; $userIP = Yii::$app->request->userIP;
*** 响应（Responses）
    响应
  当应用完成处理一个请求后, 会生成一个[[yii\web\Response|response]]响应对象并发送给终端用户 响应对象包含的信息有HTTP状态码，HTTP头和主体内容等, 网页应用开发的最终目的本质上就是根据不同的请求构建这些响应对象。

  在大多是情况下主要处理继承自 [[yii\web\Response]] 的 response 应用组件， 尽管如此，Yii也允许你创建你自己的响应对象并发送给终端用户，这方面后续会阐述。

  在本节，将会描述如何构建响应和发送给终端用户。

  状态码
  构建响应时，最先应做的是标识请求是否成功处理的状态，可通过设置 [[yii\web\Response::statusCode]] 属性，该属性使用一个有效的 HTTP 状态码。例如，为标识处理已被处理成功， 可设置状态码为200，如下所示：

  php Yii::$app->response->statusCode = 200;

  尽管如此，大多数情况下不需要明确设置状态码，因为 [[yii\web\Response::statusCode]] 状态码默认为200， 如果需要指定请求失败，可抛出对应的HTTP异常，如下所示：

  php throw new \yii\web\NotFoundHttpException;

  当错误处理器 捕获到一个异常，会从异常中提取状态码并赋值到响应， 对于上述的 [[yii\web\NotFoundHttpException]] 对应HTTP 404状态码，以下为Yii预定义的HTTP异常：

  [[yii\web\BadRequestHttpException]]: status code 400.
  [[yii\web\ConflictHttpException]]: status code 409.
  [[yii\web\ForbiddenHttpException]]: status code 403.
  [[yii\web\GoneHttpException]]: status code 410.
  [[yii\web\MethodNotAllowedHttpException]]: status code 405.
  [[yii\web\NotAcceptableHttpException]]: status code 406.
  [[yii\web\NotFoundHttpException]]: status code 404.
  [[yii\web\ServerErrorHttpException]]: status code 500.
  [[yii\web\TooManyRequestsHttpException]]: status code 429.
  [[yii\web\UnauthorizedHttpException]]: status code 401.
  [[yii\web\UnsupportedMediaTypeHttpException]]: status code 415.
  如果想抛出的异常不在如上列表中，可创建一个[[yii\web\HttpException]]异常，带上状态码抛出，如下：

  php throw new \yii\web\HttpException(402);

  HTTP 头部
  可在 response 组件中操控[[yii\web\Response::headers|header collection]]来发送HTTP头部信息，例如：

  ```php $headers = Yii::$app->response->headers;

  // 增加一个 Pragma 头，已存在的Pragma 头不会被覆盖。 $headers->add('Pragma', 'no-cache');

  // 设置一个Pragma 头. 任何已存在的Pragma 头都会被丢弃 $headers->set('Pragma', 'no-cache');

  // 删除Pragma 头并返回删除的Pragma 头的值到数组 $values = $headers->remove('Pragma'); ```

  Info: 头名称是大小写敏感的，在[[yii\web\Response::send()]]方法调用前新注册的头信息并不会发送给用户。

  响应主体
  大多是响应应有一个主体存放你想要显示给终端用户的内容。

  如果已有格式化好的主体字符串，可赋值到响应的[[yii\web\Response::content]]属性，例如：

  php Yii::$app->response->content = 'hello world!';

  如果在发送给终端用户之前需要格式化，应设置 [[yii\web\Response::format|format]] 和 [[yii\web\Response::data|data]] 属性，[[yii\web\Response::format|format]] 属性指定[[yii\web\Response::data|data]]中数据格式化后的样式，例如：

  php $response = Yii::$app->response; $response->format = \yii\web\Response::FORMAT_JSON; $response->data = ['message' => 'hello world'];

  Yii支持以下可直接使用的格式，每个实现了[[yii\web\ResponseFormatterInterface|formatter]] 类， 可自定义这些格式器或通过配置[[yii\web\Response::formatters]] 属性来增加格式器。

  [[yii\web\Response::FORMAT_HTML|HTML]]: 通过 [[yii\web\HtmlResponseFormatter]] 来实现.
  [[yii\web\Response::FORMAT_XML|XML]]: 通过 [[yii\web\XmlResponseFormatter]]来实现.
  [[yii\web\Response::FORMAT_JSON|JSON]]: 通过 [[yii\web\JsonResponseFormatter]]来实现.
  [[yii\web\Response::FORMAT_JSONP|JSONP]]: 通过 [[yii\web\JsonResponseFormatter]]来实现.
  上述响应主体可明确地被设置，但是在大多数情况下是通过 操作 方法的返回值隐式地设置，常用场景如下所示：

  php public function actionIndex() { return $this->render('index'); }

  上述的 index 操作返回 index 视图渲染结果，返回值会被 response 组件格式化后发送给终端用户。

  因为响应格式默认为[[yii\web\Response::FORMAT_HTML|HTML]], 只需要在操作方法中返回一个字符串， 如果想使用其他响应格式，应在返回数据前先设置格式，例如：

  php public function actionInfo() { \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON; return [ 'message' => 'hello world', 'code' => 100, ]; }

  如上所述，触雷使用默认的 response 应用组件，也可创建自己的响应对象并发送给终端用户，可在操作方法中返回该响应对象，如下所示：

  php public function actionInfo() { return \Yii::createObject([ 'class' => 'yii\web\Response', 'format' => \yii\web\Response::FORMAT_JSON, 'data' => [ 'message' => 'hello world', 'code' => 100, ], ]); }

  Note: 如果创建你自己的响应对象，将不能在应用配置中设置 response 组件，尽管如此， 可使用 依赖注入 应用通用配置到你新的响应对象。

  浏览器跳转
  浏览器跳转依赖于发送一个Location HTTP 头，因为该功能通常被使用，Yii提供对它提供了特别的支持。

  可调用[[yii\web\Response::redirect()]] 方法将用户浏览器跳转到一个URL地址，该方法设置合适的 带指定URL的 Location 头并返回它自己为响应对象，在操作的方法中，可调用缩写版[[yii\web\Controller::redirect()]]，例如：

  php public function actionOld() { return $this->redirect('http://example.com/new', 301); }

  在如上代码中，操作的方法返回redirect() 方法的结果，如前所述，操作的方法返回的响应对象会被当总响应发送给终端用户。

  除了操作方法外，可直接调用[[yii\web\Response::redirect()]] 再调用 [[yii\web\Response::send()]] 方法来确保没有其他内容追加到响应中。

  php \Yii::$app->response->redirect('http://example.com/new', 301)->send();

  Info: [[yii\web\Response::redirect()]] 方法默认会设置响应状态码为302，该状态码会告诉浏览器请求的资源 临时 放在另一个URI地址上，可传递一个301状态码告知浏览器请求的资源已经 永久 重定向到新的URId地址。

  如果当前请求为AJAX 请求，发送一个 Location 头不会自动使浏览器跳转，为解决这个问题， [[yii\web\Response::redirect()]] 方法设置一个值为要跳转的URL的X-Redirect 头， 在客户端可编写JavaScript 代码读取该头部值然后让浏览器跳转对应的URL。

  Info: Yii 配备了一个yii.js JavaScript 文件提供常用JavaScript功能，包括基于X-Redirect头的浏览器跳转， 因此，如果你使用该JavaScript 文件(通过[[yii\web\YiiAsset]] 资源包注册)，就不需要编写AJAX跳转的代码。

  发送文件
  和浏览器跳转类似，文件发送是另一个依赖指定HTTP头的功能，Yii提供方法集合来支持各种文件发送需求，它们对HTTP头都有内置的支持。

  [[yii\web\Response::sendFile()]]: 发送一个已存在的文件到客户端
  [[yii\web\Response::sendContentAsFile()]]: 发送一个文本字符串作为文件到客户端
  [[yii\web\Response::sendStreamAsFile()]]: 发送一个已存在的文件流作为文件到客户端
  这些方法都将响应对象作为返回值，如果要发送的文件非常大，应考虑使用 [[yii\web\Response::sendStreamAsFile()]] 因为它更节约内存，以下示例显示在控制器操作中如何发送文件：

  php public function actionDownload() { return \Yii::$app->response->sendFile('path/to/file.txt'); }

  如果不是在操作方法中调用文件发送方法，在后面还应调用 [[yii\web\Response::send()]] 没有其他内容追加到响应中。

  php \Yii::$app->response->sendFile('path/to/file.txt')->send();

  一些浏览器提供特殊的名为X-Sendfile的文件发送功能，原理为将请求跳转到服务器上的文件， Web应用可在服务器发送文件前结束，为使用该功能，可调用[[yii\web\Response::xSendFile()]]， 如下简要列出一些常用Web服务器如何启用X-Sendfile 功能：

  Apache: X-Sendfile
  Lighttpd v1.4: X-LIGHTTPD-send-file
  Lighttpd v1.5: X-Sendfile
  Nginx: X-Accel-Redirect
  Cherokee: X-Sendfile and X-Accel-Redirect
  发送响应
  在[[yii\web\Response::send()]] 方法调用前响应中的内容不会发送给用户，该方法默认在[[yii\base\Application::run()]] 结尾自动调用，尽管如此，可以明确调用该方法强制立即发送响应。

  [[yii\web\Response::send()]] 方法使用以下步骤来发送响应：

  触发 [[yii\web\Response::EVENTBEFORESEND]] 事件.
  调用 [[yii\web\Response::prepare()]] 来格式化 [[yii\web\Response::data|response data]] 为 [[yii\web\Response::content|response content]].
  触发 [[yii\web\Response::EVENTAFTERPREPARE]] 事件.
  调用 [[yii\web\Response::sendHeaders()]] 来发送注册的HTTP头
  调用 [[yii\web\Response::sendContent()]] 来发送响应主体内容
  触发 [[yii\web\Response::EVENTAFTERSEND]] 事件.
  一旦[[yii\web\Response::send()]] 方法被执行后，其他地方调用该方法会被忽略， 这意味着一旦响应发出后，就不能再追加其他内容。

  如你所见[[yii\web\Response::send()]] 触发了几个实用的事件，通过响应这些事件可调整或包装响应。
*** Sessions and Cookies
    Sessions 和 Cookies
  [译注：Session中文翻译为会话，Cookie有些翻译成小甜饼，不贴切，两个单词保留英文] Sessions 和 cookies 允许数据在多次请求中保持， 在纯PHP中，可以分别使用全局变量$_SESSION 和$_COOKIE 来访问，Yii将session和cookie封装成对象并增加一些功能， 可通过面向对象方式访问它们。

  Sessions
  和 请求 和 响应类似， 默认可通过为[[yii\web\Session]] 实例的session 应用组件 来访问sessions。

  开启和关闭 Sessions
  可使用以下代码来开启和关闭session。

  ```php $session = Yii::$app->session;

  // 检查session是否开启 if ($session->isActive) ...

  // 开启session $session->open();

  // 关闭session $session->close();

  // 销毁session中所有已注册的数据 $session->destroy(); ```

  多次调用[[yii\web\Session::open()|open()]] 和[[yii\web\Session::close()|close()]] 方法并不会产生错误， 因为方法内部会先检查session是否已经开启。

  访问Session数据
  To access the data stored in session, you can do the following: 可使用如下方式访问session中的数据：

  ```php $session = Yii::$app->session;

  // 获取session中的变量值，以下用法是相同的： $language = $session->get('language'); $language = $session['language']; $language = isset($SESSION['language']) ? $SESSION['language'] : null;

  // 设置一个session变量，以下用法是相同的： $session->set('language', 'en-US'); $session['language'] = 'en-US'; $_SESSION['language'] = 'en-US';

  // 删除一个session变量，以下用法是相同的： $session->remove('language'); unset($session['language']); unset($_SESSION['language']);

  // 检查session变量是否已存在，以下用法是相同的： if ($session->has('language')) ... if (isset($session['language'])) ... if (isset($_SESSION['language'])) ...

  // 遍历所有session变量，以下用法是相同的： foreach ($session as $name => $value) ... foreach ($_SESSION as $name => $value) ... ```

  Info: 当使用session组件访问session数据时候，如果session没有开启会自动开启， 这和通过$_SESSION不同，$_SESSION要求先执行session_start()。

  当session数据为数组时，session组件会限制你直接修改数据中的单元项，例如：

  ```php $session = Yii::$app->session;

  // 如下代码不会生效 $session['captcha']['number'] = 5; $session['captcha']['lifetime'] = 3600;

  // 如下代码会生效： $session['captcha'] = [ 'number' => 5, 'lifetime' => 3600, ];

  // 如下代码也会生效： echo $session['captcha']['lifetime']; ```

  可使用以下任意一个变通方法来解决这个问题：

  ```php $session = Yii::$app->session;

  // 直接使用$SESSION (确保Yii::$app->session->open() 已经调用) $SESSION['captcha']['number'] = 5; $_SESSION['captcha']['lifetime'] = 3600;

  // 先获取session数据到一个数组，修改数组的值，然后保存数组到session中 $captcha = $session['captcha']; $captcha['number'] = 5; $captcha['lifetime'] = 3600; $session['captcha'] = $captcha;

  // 使用ArrayObject 数组对象代替数组 $session['captcha'] = new \ArrayObject; ... $session['captcha']['number'] = 5; $session['captcha']['lifetime'] = 3600;

  // 使用带通用前缀的键来存储数组 $session['captcha.number'] = 5; $session['captcha.lifetime'] = 3600; ```

  为更好的性能和可读性，推荐最后一种方案，也就是不用存储session变量为数组， 而是将每个数组项变成有相同键前缀的session变量。

  自定义Session存储
  [[yii\web\Session]] 类默认存储session数据为文件到服务器上，Yii提供以下session类实现不同的session存储方式：

  [[yii\web\DbSession]]: 存储session数据在数据表中
  [[yii\web\CacheSession]]: 存储session数据到缓存中，缓存和配置中的缓存组件相关
  [[yii\redis\Session]]: 存储session数据到以redis 作为存储媒介中
  [[yii\mongodb\Session]]: 存储session数据到MongoDB.
  所有这些session类支持相同的API方法集，因此，切换到不同的session存储介质不需要修改项目使用session的代码。

  Note: 如果通过$_SESSION访问使用自定义存储介质的session，需要确保session已经用[[yii\web\Session::open()]] 开启， 这是因为在该方法中注册自定义session存储处理器。

  学习如何配置和使用这些组件类请参考它们的API文档，如下为一个示例 显示如何在应用配置中配置[[yii\web\DbSession]]将数据表作为session存储介质。

  php return [ 'components' => [ 'session' => [ 'class' => 'yii\web\DbSession', // 'db' => 'mydb', // 数据库连接的应用组件ID，默认为'db'. // 'sessionTable' => 'my_session', // session 数据表名，默认为'session'. ], ], ];

  也需要创建如下数据库表来存储session数据：

  sql CREATE TABLE session ( id CHAR(40) NOT NULL PRIMARY KEY, expire INTEGER, data BLOB )

  其中'BLOB' 对应你选择的数据库管理系统的BLOB-type类型，以下一些常用数据库管理系统的BLOB类型：

  MySQL: LONGBLOB
  PostgreSQL: BYTEA
  MSSQL: BLOB
  Note: 根据 php.ini 设置的 session.hash_function，你需要调整id列的长度， 例如，如果 session.hash_function=sha256 ，应使用长度为64而不是40的char类型。

  Flash 数据
  Flash数据是一种特别的session数据，它一旦在某个请求中设置后，只会在下次请求中有效，然后该数据就会自动被删除。 常用于实现只需显示给终端用户一次的信息，如用户提交一个表单后显示确认信息。

  可通过session应用组件设置或访问session，例如：

  ```php $session = Yii::$app->session;

  // 请求 #1 // 设置一个名为"postDeleted" flash 信息 $session->setFlash('postDeleted', 'You have successfully deleted your post.');

  // 请求 #2 // 显示名为"postDeleted" flash 信息 echo $session->getFlash('postDeleted');

  // 请求 #3 // $result 为 false，因为flash信息已被自动删除 $result = $session->hasFlash('postDeleted'); ```

  和普通session数据类似，可将任意数据存储为flash数据。

  当调用[[yii\web\Session::setFlash()]]时, 会自动覆盖相同名的已存在的任何数据， 为将数据追加到已存在的相同名flash中，可改为调用[[yii\web\Session::addFlash()]]。 例如:

  ```php $session = Yii::$app->session;

  // 请求 #1 // 在名称为"alerts"的flash信息增加数据 $session->addFlash('alerts', 'You have successfully deleted your post.'); $session->addFlash('alerts', 'You have successfully added a new friend.'); $session->addFlash('alerts', 'You are promoted.');

  // 请求 #2 // $alerts 为名为'alerts'的flash信息，为数组格式 $alerts = $session->getFlash('alerts'); ```

  Note: 不要在相同名称的flash数据中使用[[yii\web\Session::setFlash()]] 的同时也使用[[yii\web\Session::addFlash()]]， 因为后一个防范会自动将flash信息转换为数组以使新的flash数据可追加进来，因此， 当你调用[[yii\web\Session::getFlash()]]时，会发现有时获取到一个数组，有时获取到一个字符串， 取决于你调用这两个方法的顺序。

  Cookies
  Yii使用 [[yii\web\Cookie]]对象来代表每个cookie，[[yii\web\Request]] 和 [[yii\web\Response]] 通过名为'cookies'的属性维护一个cookie集合，前者的cookie 集合代表请求提交的cookies， 后者的cookie集合表示发送给用户的cookies。

  读取 Cookies
  当前请求的cookie信息可通过如下代码获取：

  ```php // 从 "request"组件中获取cookie集合(yii\web\CookieCollection) $cookies = Yii::$app->request->cookies;

  // 获取名为 "language" cookie 的值，如果不存在，返回默认值"en" $language = $cookies->getValue('language', 'en');

  // 另一种方式获取名为 "language" cookie 的值 if (($cookie = $cookies->get('language')) !== null) { $language = $cookie->value; }

  // 可将 $cookies当作数组使用 if (isset($cookies['language'])) { $language = $cookies['language']->value; }

  // 判断是否存在名为"language" 的 cookie if ($cookies->has('language')) ... if (isset($cookies['language'])) ... ```

  发送 Cookies
  You can send cookies to end users using the following code: 可使用如下代码发送cookie到终端用户：

  ```php // 从"response"组件中获取cookie 集合(yii\web\CookieCollection) $cookies = Yii::$app->response->cookies;

  // 在要发送的响应中添加一个新的cookie $cookies->add(new \yii\web\Cookie([ 'name' => 'language', 'value' => 'zh-CN', ]));

  // 删除一个cookie $cookies->remove('language'); // 等同于以下删除代码 unset($cookies['language']); ```

  除了上述例子定义的 [[yii\web\Cookie::name|name]] 和 [[yii\web\Cookie::value|value]] 属性 [[yii\web\Cookie]] 类也定义了其他属性来实现cookie的各种信息，如 [[yii\web\Cookie::domain|domain]], [[yii\web\Cookie::expire|expire]] 可配置这些属性到cookie中并添加到响应的cookie集合中。

  Note: 为安全起见[[yii\web\Cookie::httpOnly]] 被设置为true，这可减少客户端脚本访问受保护cookie（如果浏览器支持）的风险， 更多详情可阅读 httpOnly wiki article for more details.

  Cookie验证
  在上两节中，当通过request 和 response 组件读取和发送cookie时，你会喜欢扩展的cookie验证的保障安全功能，它能 使cookie不被客户端修改。该功能通过给每个cookie签发一个哈希字符串来告知服务端cookie是否在客户端被修改， 如果被修改，通过request组件的[[yii\web\Request::cookies|cookie collection]]cookie集合访问不到该cookie。

  Note: Cookie验证只保护cookie值被修改，如果一个cookie验证失败，仍然可以通过$_COOKIE来访问该cookie， 因为这是第三方库对未通过cookie验证自定义的操作方式。

  Cookie验证默认启用，可以设置[[yii\web\Request::enableCookieValidation]]属性为false来禁用它，尽管如此，我们强烈建议启用它。

  Note: 直接通过$_COOKIE 和 setcookie() 读取和发送的Cookie不会被验证。

  当使用cookie验证，必须指定[[yii\web\Request::cookieValidationKey]]，它是用来生成s上述的哈希值， 可通过在应用配置中配置request 组件。

  php return [ 'components' => [ 'request' => [ 'cookieValidationKey' => 'fill in a secret key here', ], ], ];

  Info: [[yii\web\Request::cookieValidationKey|cookieValidationKey]] 对你的应用安全很重要， 应只被你信任的人知晓，请不要将它放入版本控制中。
*** 错误处理（Handling Errors）
    错误处理
    Yii 内置了一个[[yii\web\ErrorHandler|error handler]]错误处理器，它使错误处理更方便， Yii错误处理器做以下工作来提升错误处理效果：

    所有非致命PHP错误（如，警告，提示）会转换成可获取异常；
    异常和致命的PHP错误会被显示，在调试模式会显示详细的函数调用栈和源代码行数。
    支持使用专用的 控制器操作 来显示错误；
    支持不同的错误响应格式；
    [[yii\web\ErrorHandler|error handler]] 错误处理器默认启用， 可通过在应用的入口脚本中定义常量YII_ENABLE_ERROR_HANDLER来禁用。

    使用错误处理器
    [[yii\web\ErrorHandler|error handler]] 注册成一个名称为errorHandler应用组件， 可以在应用配置中配置它类似如下：

  php return [ 'components' => [ 'errorHandler' => [ 'maxSourceLines' => 20, ], ], ];

  使用如上代码，异常页面最多显示20条源代码。

  如前所述，错误处理器将所有非致命PHP错误转换成可获取异常，也就是说可以使用如下代码处理PHP错误：

  ```php use Yii; use yii\base\ErrorException;

  try { 10/0; } catch (ErrorException $e) { Yii::warning("Division by zero."); }

  // execution continues... ```

  如果你想显示一个错误页面告诉用户请求是无效的或无法处理的，可简单地抛出一个 [[yii\web\HttpException|HTTP exception]]异常， 如 [[yii\web\NotFoundHttpException]]。错误处理器会正确地设置响应的HTTP状态码并使用合适的错误视图页面来显示错误信息。

  ```php use yii\web\NotFoundHttpException;

  throw new NotFoundHttpException(); ```

  自定义错误显示
  [[yii\web\ErrorHandler|error handler]]错误处理器根据常量YII_DEBUG的值来调整错误显示， 当YII_DEBUG 为 true (表示在调试模式)，错误处理器会显示异常以及详细的函数调用栈和源代码行数来帮助调试， 当YII_DEBUG 为 false，只有错误信息会被显示以防止应用的敏感信息泄漏。

  Info: 如果异常是继承 [[yii\base\UserException]]，不管YII_DEBUG为何值，函数调用栈信息都不会显示， 这是因为这种错误会被认为是用户产生的错误，开发人员不需要去修正。

  [[yii\web\ErrorHandler|error handler]] 错误处理器默认使用两个视图显示错误:

  @yii/views/errorHandler/error.php: 显示不包含函数调用栈信息的错误信息是使用， 当YII_DEBUG 为 false时，所有错误都使用该视图。
  @yii/views/errorHandler/exception.php: 显示包含函数调用栈信息的错误信息时使用。
  可以配置错误处理器的 [[yii\web\ErrorHandler::errorView|errorView]] 和 [[yii\web\ErrorHandler::exceptionView|exceptionView]] 属性 使用自定义的错误显示视图。

  使用错误操作
  使用指定的错误操作 来自定义错误显示更方便， 为此，首先配置errorHandler组件的 [[yii\web\ErrorHandler::errorAction|errorAction]] 属性，类似如下：

  php return [ 'components' => [ 'errorHandler' => [ 'errorAction' => 'site/error', ], ] ];

  [[yii\web\ErrorHandler::errorAction|errorAction]] 属性使用路由到一个操作， 上述配置表示不用显示函数调用栈信息的错误会通过执行site/error操作来显示。

  可以创建site/error 操作如下所示：

  ```php namespace app\controllers;

  use Yii; use yii\web\Controller;

  class SiteController extends Controller { public function actions() { return [ 'error' => [ 'class' => 'yii\web\ErrorAction', ], ]; } } ```

  上述代码定义error 操作使用[[yii\web\ErrorAction]] 类，该类渲染名为error视图来显示错误。

  除了使用[[yii\web\ErrorAction]], 可定义error 操作使用类似如下的操作方法：

  php public function actionError() { $exception = Yii::$app->errorHandler->exception; if ($exception !== null) { return $this->render('error', ['exception' => $exception]); } }

  现在应创建一个视图文件为views/site/error.php，在该视图文件中，如果错误操作定义为[[yii\web\ErrorAction]]， 可以访问该操作中定义的如下变量：

  name: 错误名称
  message: 错误信息
  exception: 更多详细信息的异常对象，如HTTP 状态码，错误码，错误调用栈等。
  Info: 如果你使用 基础应用模板 或 高级应用模板, 错误操作和错误视图已经定义好了。

  自定义错误格式
  错误处理器根据响应设置的格式来显示错误， 如果[[yii\web\Response::format|response format]] 响应格式为html, 会使用错误或异常视图来显示错误信息，如上一小节所述。 对于其他的响应格式，错误处理器会错误信息作为数组赋值给[[yii\web\Response::data]]属性，然后转换到对应的格式， 例如，如果响应格式为json，可以看到如下响应信息：

  ``` HTTP/1.1 404 Not Found Date: Sun, 02 Mar 2014 05:31:43 GMT Server: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y Transfer-Encoding: chunked Content-Type: application/json; charset=UTF-8

  { "name": "Not Found Exception", "message": "The requested resource was not found.", "code": 0, "status": 404 } ```

  可在应用配置中响应response组件的beforeSend事件来自定义错误响应格式。

  php return [ // ... 'components' => [ 'response' => [ 'class' => 'yii\web\Response', 'on beforeSend' => function ($event) { $response = $event->sender; if ($response->data !== null) { $response->data = [ 'success' => $response->isSuccessful, 'data' => $response->data, ]; $response->statusCode = 200; } }, ], ], ];

  上述代码会重新格式化错误响应，类似如下：

  ``` HTTP/1.1 200 OK Date: Sun, 02 Mar 2014 05:31:43 GMT Server: Apache/2.2.26 (Unix) DAV/2 PHP/5.4.20 mod_ssl/2.2.26 OpenSSL/0.9.8y Transfer-Encoding: chunked Content-Type: application/json; charset=UTF-8

  { "success": false, "data": { "name": "Not Found Exception", "message": "The requested resource was not found.", "code": 0, "status": 404 } } ```
*** 日志（Logging）
  
** 关键概念（Key Concepts）
*** 组件（Components）
    组件（Component）
  组件是 Yii 应用的主要基石。是 [[yii\base\Component]] 类或其子类的实例。三个用以区分它和其它类的主要功能有：

  属性（Property）
  事件（Event）
  行为（Behavior）
  或单独使用，或彼此配合，这些功能的应用让 Yii 的类变得更加灵活和易用。以小部件 [[yii\jui\DatePicker|日期选择器]] 来举例，这是个方便你在 视图 中生成一个交互式日期选择器的 UI 组件：

  ```php use yii\jui\DatePicker;

  echo DatePicker::widget([ 'language' => 'zh-CN', 'name' => 'country', 'clientOptions' => [ 'dateFormat' => 'yy-mm-dd', ], ]); ```

  这个小部件继承自 [[yii\base\Component]]，它的各项属性改写起来会很容易。

  正是因为组件功能的强大，他们比常规的对象（BaseObject）稍微重量级一点，因为他们要使用额外的内存和 CPU 时间来处理 事件 和 行为 。如果你不需要这两项功能，可以继承 [[yii\base\BaseObject]] 而不是 [[yii\base\Component]]。这样组件可以像普通 PHP 对象一样高效，同时还支持属性（Property）功能。

  当继承 [[yii\base\Component]] 或 [[yii\base\BaseObject]] 时，推荐你使用如下的编码风格：

  若你需要重写构造方法（Constructor），传入 $config 作为构造器方法最后一个参数，然后把它传递给父类的构造方法。
  永远在你重写的构造方法结尾处调用一下父类的构造方法。
  如果你重写了 [[yii\base\BaseObject::init()]] 方法，请确保你在 init 方法的开头处调用了父类的 init 方法。
  例子如下：

  ```php namespace yii\components\MyClass;

  use yii\base\BaseObject;

  class MyClass extends BaseObject { public $prop1; public $prop2;

  public function __construct($param1, $param2, $config = [])
  {
      // ... 配置生效前的初始化过程

      parent::__construct($config);
  }

  public function init()
  {
      parent::init();

      // ... 配置生效后的初始化过程
  }
  } ```

  另外，为了让组件可以在创建实例时能被正确配置，请遵照以下操作流程：

  php $component = new MyClass(1, 2, ['prop1' => 3, 'prop2' => 4]); // 方法二： $component = \Yii::createObject([ 'class' => MyClass::className(), 'prop1' => 3, 'prop2' => 4, ], [1, 2]);

  Info: 尽管调用 [[Yii::createObject()]] 的方法看起来更加复杂，但这主要因为它更加灵活强大，它是基于依赖注入容器实现的。

  [[yii\base\BaseObject]] 类执行时的生命周期如下：

  构造方法内的预初始化过程。你可以在这儿给各属性设置缺省值。
  通过 $config 配置对象。配置的过程可能会覆盖掉先前在构造方法内设置的默认值。
  在 [[yii\base\BaseObject::init()|init()]] 方法内进行初始化后的收尾工作。你可以通过重写此方法，进行一些良品检验，属性的初始化之类的工作。
  对象方法调用。
  前三步都是在对象的构造方法内发生的。这意味着一旦你获得了一个对象实例，那么它就已经初始化就绪可供使用。
*** 属性（Properties）
    属性（Property）
  在 PHP 中，类的成员变量也被称为属性（properties）。它们是类定义的一部分，用来表现一个实例的状态（也就是区分类的不同实例）。在具体实践中，常常会想用一个稍微特殊些的方法实现属性的读写。例如，如果有需求每次都要对 label 属性执行 trim 操作，就可以用以下代码实现：

  php $object->label = trim($label);

  上述代码的缺点是只要修改 label 属性就必须再次调用 trim() 函数。若将来需要用其它方式处理 label 属性，比如首字母大写，就不得不修改所有给 label 属性赋值的代码。这种代码的重复会导致 bug，这种实践显然需要尽可能避免。

  为解决该问题，Yii 引入了一个名为 [[yii\base\BaseObject]] 的基类，它支持基于类内的 getter 和 setter（读取器和设定器）方法来定义属性。如果某类需要支持这个特性，只需要继承 [[yii\base\BaseObject]] 或其子类即可。

  Info: 几乎每个 Yii 框架的核心类都继承自 [[yii\base\BaseObject]] 或其子类。这意味着只要在核心类中见到 getter 或 setter 方法，就可以像调用属性一样调用它。

  getter 方法是名称以 get 开头的方法，而 setter 方法名以 set 开头。方法名中 get 或 set 后面的部分就定义了该属性的名字。如下面代码所示，getter 方法 getLabel() 和 setter 方法 setLabel() 操作的是 label 属性，：

  ```php namespace app\components;

  use yii\base\BaseObject;

  class Foo extend BaseObject { private $_label;

  public function getLabel()
  {
      return $this->_label;
  }

  public function setLabel($value)
  {
      $this->_label = trim($value);
  }
  } ```

  （详细解释：getter 和 setter 方法创建了一个名为 label 的属性，在这个例子里，它指向一个私有的内部属性 _label。）

  getter/setter 定义的属性用法与类成员变量一样。两者主要的区别是：当这种属性被读取时，对应的 getter 方法将被调用；而当属性被赋值时，对应的 setter 方法就调用。如：

  ```php // 等效于 $label = $object->getLabel(); $label = $object->label;

  // 等效于 $object->setLabel('abc'); $object->label = 'abc'; ```

  只定义了 getter 没有 setter 的属性是只读属性。尝试赋值给这样的属性将导致 [[yii\base\InvalidCallException|InvalidCallException]] （无效调用）异常。类似的，只有 setter 方法而没有 getter 方法定义的属性是只写属性，尝试读取这种属性也会触发异常。使用只写属性的情况几乎没有。

  通过 getter 和 setter 定义的属性也有一些特殊规则和限制：

  这类属性的名字是不区分大小写的。如，$object->label 和 $object->Label 是同一个属性。因为 PHP 方法名是不区分大小写的。
  如果此类属性名和类成员变量相同，以后者为准。例如，假设以上 Foo 类有个 label 成员变量，然后给 $object->label = 'abc' 赋值，将赋给成员变量而不是 setter setLabel() 方法。
  这类属性不支持可见性（访问限制）。定义属性的 getter 和 setter 方法是 public、protected 还是 private 对属性的可见性没有任何影响。
  这类属性的 getter 和 setter 方法只能定义为非静态的，若定义为静态方法（static）则不会以相同方式处理。
  回到开头提到的问题，与其处处要调用 trim() 函数，现在我们只需在 setter setLabel() 方法内调用一次。如果 label 首字母变成大写的新要求来了，我们只需要修改setLabel() 方法，而无须接触任何其它代码。
*** 事件（Events）
    事件
  事件可以将自定义代码“注入”到现有代码中的特定执行点。附加自定义代码到某个事件，当这个事件被触发时，这些代码就会自动执行。例如，邮件程序对象成功发出消息时可触发 messageSent 事件。如想追踪成功发送的消息，可以附加相应追踪代码到 messageSent 事件。

  Yii 引入了名为 [[yii\base\Component]] 的基类以支持事件。如果一个类需要触发事件就应该继承 [[yii\base\Component]] 或其子类。

  事件处理器（Event Handlers）
  事件处理器是一个PHP 回调函数，当它所附加到的事件被触发时它就会执行。可以使用以下回调函数之一：

  字符串形式指定的 PHP 全局函数，如 'trim' ；
  对象名和方法名数组形式指定的对象方法，如 [$object, $method] ；
  类名和方法名数组形式指定的静态类方法，如 [$class, $method] ；
  匿名函数，如 function ($event) { ... } 。
  事件处理器的格式是：

  php function ($event) { // $event 是 yii\base\Event 或其子类的对象 }

  通过 $event 参数，事件处理器就获得了以下有关事件的信息：

  [[yii\base\Event::name|event name]]：事件名
  [[yii\base\Event::sender|event sender]]：调用 trigger() 方法的对象
  [[yii\base\Event::data|custom data]]：附加事件处理器时传入的数据，默认为空，后文详述
  附加事件处理器
  调用 [[yii\base\Component::on()]] 方法来附加处理器到事件上。如：

  ```php $foo = new Foo;

  // 处理器是全局函数 $foo->on(Foo::EVENTHELLO, 'functionname');

  // 处理器是对象方法 $foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

  // 处理器是静态类方法 $foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // 处理器是匿名函数 $foo->on(Foo::EVENT_HELLO, function ($event) { //事件处理逻辑 }); ```

  附加事件处理器时可以提供额外数据作为 [[yii\base\Component::on()]] 方法的第三个参数。数据在事件被触发和处理器被调用时能被处理器使用。如：

  php // 当事件被触发时以下代码显示 "abc" // 因为 $event->data 包括被传递到 "on" 方法的数据 $foo->on(Foo::EVENT_HELLO, function ($event) { echo $event->data; }, 'abc');

  事件处理器顺序
  可以附加一个或多个处理器到一个事件。当事件被触发，已附加的处理器将按附加次序依次调用。如果某个处理器需要停止其后的处理器调用，可以设置 $event 参数的 [[yii\base\Event::handled]] 属性为真，如下：

  php $foo->on(Foo::EVENT_HELLO, function ($event) { $event->handled = true; });

  默认新附加的事件处理器排在已存在处理器队列的最后。因此，这个处理器将在事件被触发时最后一个调用。在处理器队列最前面插入新处理器将使该处理器最先调用，可以传递第四个参数 $append 为假并调用 [[yii\base\Component::on()]] 方法实现：

  php $foo->on(Foo::EVENT_HELLO, function ($event) { // 这个处理器将被插入到处理器队列的第一位... }, $data, false);

  触发事件
  事件通过调用 [[yii\base\Component::trigger()]] 方法触发，此方法须传递事件名，还可以传递一个事件对象，用来传递参数到事件处理器。如：

  ```php namespace app\components;

  use yii\base\Component; use yii\base\Event;

  class Foo extends Component { const EVENT_HELLO = 'hello';

  public function bar()
  {
      $this->trigger(self::EVENT_HELLO);
  }
  } ```

  以上代码当调用 bar() ，它将触发名为 hello 的事件。

  Tip: 推荐使用类常量来表示事件名。上例中，常量 EVENT_HELLO 用来表示 hello 。这有两个好处。第一，它可以防止拼写错误并支持 IDE 的自动完成。第二，只要简单检查常量声明就能了解一个类支持哪些事件。

  有时想要在触发事件时同时传递一些额外信息到事件处理器。例如，邮件程序要传递消息信息到 messageSent 事件的处理器以便处理器了解哪些消息被发送了。为此，可以提供一个事件对象作为 [[yii\base\Component::trigger()]] 方法的第二个参数。这个事件对象必须是 [[yii\base\Event]] 类或其子类的实例。如：

  ```php namespace app\components;

  use yii\base\Component; use yii\base\Event;

  class MessageEvent extends Event { public $message; }

  class Mailer extends Component { const EVENTMESSAGESENT = 'messageSent';

  public function send($message)
  {
      // ...发送 $message 的逻辑...

      $event = new MessageEvent;
      $event->message = $message;
      $this->trigger(self::EVENT_MESSAGE_SENT, $event);
  }
  } ```

  当 [[yii\base\Component::trigger()]] 方法被调用时，它将调用所有附加到命名事件（trigger 方法第一个参数）的事件处理器。

  移除事件处理器
  从事件移除处理器，调用 [[yii\base\Component::off()]] 方法。如：

  ```php // 处理器是全局函数 $foo->off(Foo::EVENTHELLO, 'functionname');

  // 处理器是对象方法 $foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

  // 处理器是静态类方法 $foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

  // 处理器是匿名函数 $foo->off(Foo::EVENT_HELLO, $anonymousFunction); ```

  注意当匿名函数附加到事件后一般不要尝试移除匿名函数，除非你在某处存储了它。以上示例中，假设匿名函数存储为变量 $anonymousFunction 。

  移除事件的全部处理器，简单调用 [[yii\base\Component::off()]] 即可，不需要第二个参数：

  php $foo->off(Foo::EVENT_HELLO);

  类级别的事件处理器
  以上部分，我们叙述了在实例级别如何附加处理器到事件。有时想要一个类的所有实例而不是一个指定的实例都响应一个被触发的事件，并不是一个个附加事件处理器到每个实例，而是通过调用静态方法 [[yii\base\Event::on()]] 在类级别附加处理器。

  例如，活动记录对象要在每次往数据库新增一条新记录时触发一个 [[yii\db\BaseActiveRecord::EVENTAFTERINSERT|EVENTAFTERINSERT]] 事件。要追踪每个活动记录对象的新增记录完成情况，应如下写代码：

  ```php use Yii; use yii\base\Event; use yii\db\ActiveRecord;

  Event::on(ActiveRecord::className(), ActiveRecord::EVENTAFTERINSERT, function ($event) { Yii::trace(get_class($event->sender) . ' is inserted'); }); ```

  每当 [[yii\db\BaseActiveRecord|ActiveRecord]] 或其子类的实例触发 [[yii\db\BaseActiveRecord::EVENTAFTERINSERT|EVENTAFTERINSERT]] 事件时，这个事件处理器都会执行。在这个处理器中，可以通过 $event->sender 获取触发事件的对象。

  当对象触发事件时，它首先调用实例级别的处理器，然后才会调用类级别处理器。

  可调用静态方法[[yii\base\Event::trigger()]]来触发一个类级别事件。类级别事件不与特定对象相关联。因此，它只会引起类级别事件处理器的调用。如：

  ```php use yii\base\Event;

  Event::on(Foo::className(), Foo::EVENTHELLO, function ($event) { vardump($event->sender); // 显示 "null" });

  Event::trigger(Foo::className(), Foo::EVENT_HELLO); ```

  注意这种情况下 $event->sender 指向触发事件的类名而不是对象实例。

  Note: 因为类级别的处理器响应类和其子类的所有实例触发的事件，必须谨慎使用，尤其是底层的基类，如 [[yii\base\BaseObject]]。

  移除类级别的事件处理器只需调用[[yii\base\Event::off()]]，如：

  ```php // 移除 $handler Event::off(Foo::className(), Foo::EVENT_HELLO, $handler);

  // 移除 Foo::EVENTHELLO 事件的全部处理器 Event::off(Foo::className(), Foo::EVENTHELLO); ```

  全局事件
  所谓全局事件实际上是一个基于以上叙述的事件机制的戏法。它需要一个全局可访问的单例，如应用实例。

  事件触发者不调用其自身的 trigger() 方法，而是调用单例的 trigger() 方法来触发全局事件。类似地，事件处理器被附加到单例的事件。如：

  ```php use Yii; use yii\base\Event; use app\components\Foo;

  Yii::$app->on('bar', function ($event) { echo get_class($event->sender); // 显示 "app\components\Foo" });

  Yii::$app->trigger('bar', new Event(['sender' => new Foo])); ```

  全局事件的一个好处是当附加处理器到一个对象要触发的事件时，不需要产生该对象。相反，处理器附加和事件触发都通过单例（如应用实例）完成。

  然而，因为全局事件的命名空间由各方共享，应合理命名全局事件，如引入一些命名空间（例："frontend.mail.sent", "backend.mail.sent"）。
*** 行为（Behaviors）
    行为
  行为是 [[yii\base\Behavior]] 或其子类的实例。行为，也称为 mixins，可以无须改变类继承关系即可增强一个已有的 [[yii\base\Component|组件]] 类功能。当行为附加到组件后，它将“注入”它的方法和属性到组件，然后可以像访问组件内定义的方法和属性一样访问它们。此外，行为通过组件能响应被触发的事件，从而自定义或调整组件正常执行的代码。

  定义行为
  要定义行为，通过继承 [[yii\base\Behavior]] 或其子类来建立一个类。如：

  ```php namespace app\components;

  use yii\base\Behavior;

  class MyBehavior extends Behavior { public $prop1;

  private $_prop2;

  public function getProp2()
  {
      return $this->_prop2;
  }

  public function setProp2($value)
  {
      $this->_prop2 = $value;
  }

  public function foo()
  {
      // ...
  }
  } ```

  以上代码定义了行为类 app\components\MyBehavior 并为要附加行为的组件提供了两个属性 prop1 、 prop2 和一个方法 foo() 。注意属性 prop2 是通过 getter getProp2() 和 setter setProp2() 定义的。能这样用是因为 [[yii\base\BaseObject]] 是 [[yii\base\Behavior]] 的祖先类，此祖先类支持用 getter 和 setter 方法定义属性

  Tip: 在行为内部可以通过 [[yii\base\Behavior::owner]] 属性访问行为已附加的组件。

  处理事件
  如果要让行为响应对应组件的事件触发，就应覆写 [[yii\base\Behavior::events()]] 方法，如：

  ```php namespace app\components;

  use yii\db\ActiveRecord; use yii\base\Behavior;

  class MyBehavior extends Behavior { // 其它代码

  public function events()
  {
      return [
          ActiveRecord::EVENT_BEFORE_VALIDATE => 'beforeValidate',
      ];
  }

  public function beforeValidate($event)
  {
      // 处理器方法逻辑
  }
  } ```

  [[yii\base\Behavior::events()|events()]] 方法返回事件列表和相应的处理器。上例声明了 [[yii\db\ActiveRecord::EVENTBEFOREVALIDATE|EVENTBEFOREVALIDATE]] 事件和它的处理器 beforeValidate() 。当指定一个事件处理器时，要使用以下格式之一：

  指向行为类的方法名的字符串，如上例所示；
  对象或类名和方法名的数组，如 [$object, 'methodName']；
  匿名方法。
  处理器的格式如下，其中 $event 指向事件参数。关于事件的更多细节请参考事件：

  php function ($event) { }

  附加行为
  可以静态或动态地附加行为到[[yii\base\Component|组件]]。前者在实践中更常见。

  要静态附加行为，覆写行为要附加的组件类的 [[yii\base\Component::behaviors()|behaviors()]] 方法即可。[[yii\base\Component::behaviors()|behaviors()]] 方法应该返回行为配置列表。每个行为配置可以是行为类名也可以是配置数组。如：

  ```php namespace app\models;

  use yii\db\ActiveRecord; use app\components\MyBehavior;

  class User extends ActiveRecord { public function behaviors() { return [ // 匿名行为，只有行为类名 MyBehavior::className(),

          // 命名行为，只有行为类名
          'myBehavior2' => MyBehavior::className(),

          // 匿名行为，配置数组
          [
              'class' => MyBehavior::className(),
              'prop1' => 'value1',
              'prop2' => 'value2',
          ],

          // 命名行为，配置数组
          'myBehavior4' => [
              'class' => MyBehavior::className(),
              'prop1' => 'value1',
              'prop2' => 'value2',
          ]
      ];
  }
  } ```

  通过指定行为配置数组相应的键可以给行为关联一个名称。这种行为称为命名行为。上例中，有两个命名行为：myBehavior2 和 myBehavior4 。如果行为没有指定名称就是匿名行为。

  要动态附加行为，在对应组件里调用 [[yii\base\Component::attachBehavior()]] 方法即可，如：

  ```php use app\components\MyBehavior;

  // 附加行为对象 $component->attachBehavior('myBehavior1', new MyBehavior);

  // 附加行为类 $component->attachBehavior('myBehavior2', MyBehavior::className());

  // 附加配置数组 $component->attachBehavior('myBehavior3', [ 'class' => MyBehavior::className(), 'prop1' => 'value1', 'prop2' => 'value2', ]); ```

  可以通过 [[yii\base\Component::attachBehaviors()]] 方法一次附加多个行为：

  php $component->attachBehaviors([ 'myBehavior1' => new MyBehavior, // 命名行为 MyBehavior::className(), // 匿名行为 ]);

  还可以通过配置去附加行为：

  ```php [ 'as myBehavior2' => MyBehavior::className(),

  'as myBehavior3' => [
      'class' => MyBehavior::className(),
      'prop1' => 'value1',
      'prop2' => 'value2',
  ],
  ] ```

  详情请参考配置章节。

  使用行为
  使用行为，必须像前文描述的一样先把它附加到 [[yii\base\Component|component]] 类或其子类。一旦行为附加到组件，就可以直接使用它。

  行为附加到组件后，可以通过组件访问一个行为的公共成员变量或 getter 和 setter 方法定义的属性：

  php // "prop1" 是定义在行为类的属性 echo $component->prop1; $component->prop1 = $value;

  类似地也可以调用行为的公共方法：

  php // foo() 是定义在行为类的公共方法 $component->foo();

  如你所见，尽管 $component 未定义 prop1 和 foo() ，它们用起来也像组件自己定义的一样。

  如果两个行为都定义了一样的属性或方法，并且它们都附加到同一个组件，那么首先附加上的行为在属性或方法被访问时有优先权。

  附加行为到组件时的命名行为，可以使用这个名称来访问行为对象，如下所示：

  php $behavior = $component->getBehavior('myBehavior');

  也能获取附加到这个组件的所有行为：

  php $behaviors = $component->getBehaviors();

  移除行为
  要移除行为，可以调用 [[yii\base\Component::detachBehavior()]] 方法用行为相关联的名字实现：

  php $component->detachBehavior('myBehavior1');

  也可以移除全部行为：

  php $component->detachBehaviors();

  使用 TimestampBehavior
  最后以 [[yii\behaviors\TimestampBehavior]] 的讲解来结尾，这个行为支持在 [[yii\db\ActiveRecord|Active Record]] 存储时自动更新它的时间戳属性。

  首先，附加这个行为到计划使用该行为的 [[yii\db\ActiveRecord|Active Record]] 类：

  ```php namespace app\models\User;

  use yii\db\ActiveRecord; use yii\behaviors\TimestampBehavior;

  class User extends ActiveRecord { // ...

  public function behaviors()
  {
      return [
          [
              'class' => TimestampBehavior::className(),
              'attributes' => [
                  ActiveRecord::EVENT_BEFORE_INSERT => ['created_at', 'updated_at'],
                  ActiveRecord::EVENT_BEFORE_UPDATE => ['updated_at'],
              ],
          ],
      ];
  }
  } ```

  以上指定的行为数组：

  当记录插入时，行为将当前时间戳赋值给 created_at 和 updated_at 属性；
  当记录更新时，行为将当前时间戳赋值给 updated_at 属性。
  保存 User 对象，将会发现它的 created_at 和 updated_at 属性自动填充了当前时间戳：

  php $user = new User; $user->email = 'test@example.com'; $user->save(); echo $user->created_at; // 显示当前时间戳

  [[yii\behaviors\TimestampBehavior|TimestampBehavior]] 行为还提供了一个有用的方法 [[yii\behaviors\TimestampBehavior::touch()|touch()]]，这个方法能将当前时间戳赋值给指定属性并保存到数据库：

  php $user->touch('login_time');

  与 PHP traits 的比较
  尽管行为在 "注入" 属性和方法到主类方面类似于 traits ，它们在很多方面却不相同。如上所述，它们各有利弊。它们更像是互补的而不是相互替代。

  行为的优势
  行为类像普通类支持继承。另一方面，traits 可以视为 PHP 语言支持的复制粘贴功能，它不支持继承。

  行为无须修改组件类就可动态附加到组件或移除。要使用 traits，必须修改使用它的类。

  行为是可配置的而 traits 不能。

  行为以响应事件来自定义组件的代码执行。

  当不同行为附加到同一组件产生命名冲突时，这个冲突通过先附加行为的优先权自动解决。而由不同 traits 引发的命名冲突需要通过手工重命名冲突属性或方法来解决。

  traits 的优势
  traits 比起行为更高效，因为行为是对象，消耗时间和内存。

  IDE 对 traits 更友好，因为它们是语言结构。
*** 配置（Configurations）
    配置
  在 Yii 中，创建新对象和初始化已存在对象时广泛使用配置。配置通常包含被创建对象的类名和一组将要赋值给对象属性的初始值。还可能包含一组将被附加到对象事件上的句柄。和一组将被附加到对象上的行为。
  以下代码中的配置被用来创建并初始化一个数据库连接：

  ```php $config = [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=127.0.0.1;dbname=demo', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ];

  $db = Yii::createObject($config); ```

  [[Yii::createObject()]] 方法接受一个配置数组并根据数组中指定的类名创建对象。对象实例化后，剩余的参数被用来初始化对象的属性，事件处理和行为。

  对于已存在的对象，可以使用 [[Yii::configure()]] 方法根据配置去初始化其属性，就像这样：

  php Yii::configure($object, $config);

  请注意，如果配置一个已存在的对象，那么配置数组中不应该包含指定类名的 class 元素。

  配置的格式
  一个配置的格式可以描述为以下形式：

  php [ 'class' => 'ClassName', 'propertyName' => 'propertyValue', 'on eventName' => $eventHandler, 'as behaviorName' => $behaviorConfig, ]

  其中

  class 元素指定了将要创建的对象的完全限定类名。
  propertyName 元素指定了对象属性的初始值。键名是属性名，值是该属性对应的初始值。只有公共成员变量以及通过 getter/setter 定义的属性可以被配置。
  on eventName 元素指定了附加到对象事件上的句柄是什么。请注意，数组的键名由 on 前缀加事件名组成。请参考事件章节了解事件句柄格式。
  as behaviorName 元素指定了附加到对象的行为。请注意，数组的键名由 as 前缀加行为名组成。$behaviorConfig 值表示创建行为的配置信息，格式与我们之前描述的配置格式一样。
  下面是一个配置了初始化属性值，事件句柄和行为的示例：

  php [ 'class' => 'app\components\SearchEngine', 'apiKey' => 'xxxxxxxx', 'on search' => function ($event) { Yii::info("搜索的关键词： " . $event->keyword); }, 'as indexer' => [ 'class' => 'app\components\IndexerBehavior', // ... 初始化属性值 ... ], ]

  使用配置
  Yii 中的配置可以用在很多场景。本章开头我们展示了如何使用 [[Yii::createObject()]] 根据配置信息创建对象。本小节将介绍配置的两种主要用法 —— 配置应用与配置小部件。

  应用的配置
  应用的配置可能是最复杂的配置之一。因为 [[yii\web\Application|application]] 类拥有很多可配置的属性和事件。更重要的是它的 [[yii\web\Application::components|components]] 属性可以接收配置数组并通过应用注册为组件。以下是一个针对基础应用模板的应用配置概要：

  php $config = [ 'id' => 'basic', 'basePath' => dirname(__DIR__), 'extensions' => require __DIR__ . '/../vendor/yiisoft/extensions.php', 'components' => [ 'cache' => [ 'class' => 'yii\caching\FileCache', ], 'mailer' => [ 'class' => 'yii\swiftmailer\Mailer', ], 'log' => [ 'class' => 'yii\log\Dispatcher', 'traceLevel' => YII_DEBUG ? 3 : 0, 'targets' => [ [ 'class' => 'yii\log\FileTarget', ], ], ], 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=stay2', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ], ], ];

  配置中没有 class 键的原因是这段配置应用在下面的入口脚本中，类名已经指定了。

  php (new yii\web\Application($config))->run();

  更多关于应用 components 属性配置的信息可以查阅应用以及服务定位器章节。

  小部件的配置
  使用小部件时，常常需要配置以便自定义其属性。 [[yii\base\Widget::widget()]] 和 [[yii\base\Widget::begin()]] 方法都可以用来创建小部件。它们可以接受配置数组：

  ```php use yii\widgets\Menu;

  echo Menu::widget([ 'activateItems' => false, 'items' => [ ['label' => 'Home', 'url' => ['site/index']], ['label' => 'Products', 'url' => ['product/index']], ['label' => 'Login', 'url' => ['site/login'], 'visible' => Yii::$app->user->isGuest], ], ]); ```

  上述代码创建了一个小部件 Menu 并将其 activateItems 属性初始化为 false。item 属性也配置成了将要显示的菜单条目。

  请注意，代码中已经给出了类名 yii\widgets\Menu'，配置数组**不应该**再包含class` 键。

  配置文件
  当配置的内容十分复杂，通用做法是将其存储在一或多个 PHP 文件中，这些文件被称为配置文件。一个配置文件返回的是 PHP 数组。例如，像这样把应用配置信息存储在名为 web.php 的文件中：

  php return [ 'id' => 'basic', 'basePath' => dirname(__DIR__), 'extensions' => require __DIR__ . '/../vendor/yiisoft/extensions.php', 'components' => require __DIR__ . '/components.php', ];

  鉴于 components 配置也很复杂，上述代码把它们存储在单独的 components.php 文件中，并且包含在 web.php 里。components.php 的内容如下：

  php return [ 'cache' => [ 'class' => 'yii\caching\FileCache', ], 'mailer' => [ 'class' => 'yii\swiftmailer\Mailer', ], 'log' => [ 'class' => 'yii\log\Dispatcher', 'traceLevel' => YII_DEBUG ? 3 : 0, 'targets' => [ [ 'class' => 'yii\log\FileTarget', ], ], ], 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=stay2', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ], ];

  仅仅需要 “require”，就可以取得一个配置文件的配置内容，像这样：

  php $config = require 'path/to/web.php'; (new yii\web\Application($config))->run();

  默认配置
  [[Yii::createObject()]] 方法基于依赖注入容器实现。使用 [[Yii::createObject()]] 创建对象时，可以附加一系列默认配置到指定类的任何实例。默认配置还可以在入口脚本中调用 Yii::$container->set() 来定义。

  例如，如果你想自定义 [[yii\widgets\LinkPager]] 小部件，以便让分页器最多只显示 5 个翻页按钮（默认是 10 个），你可以用下述代码实现：

  php \Yii::$container->set('yii\widgets\LinkPager', [ 'maxButtonCount' => 5, ]);

  不使用默认配置的话，你就得在任何使用分页器的地方，都配置 maxButtonCount 的值。

  环境常量
  配置经常要随着应用运行的不同环境更改。例如在开发环境中，你可能使用名为 mydb_dev 的数据库，而生产环境则使用 mydb_prod 数据库。为了便于切换使用环境，Yii 提供了一个定义在入口脚本中的 YII_ENV 常量。如下：

  php defined('YII_ENV') or define('YII_ENV', 'dev');

  你可以把 YII_ENV 定义成以下任何一种值：

  prod：生产环境。常量 YII_ENV_PROD 将被看作 true。如果你没修改过，这就是 YII_ENV 的默认值。
  dev：开发环境。常量 YII_ENV_DEV 将被看作 true。
  test：测试环境。常量 YII_ENV_TEST 将被看作 true。
  有了这些环境常量，你就可以根据当下应用运行环境的不同，进行差异化配置。例如，应用可以包含下述代码只在开发环境中开启调试工具。

  ```php $config = [...];

  if (YIIENVDEV) { // 根据 dev 环境进行的配置调整 $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = 'yii\debug\Module'; }

  return $config; ```
*** 别名（Aliases）
    别名（Aliases）
  别名用来表示文件路径和 URL，这样就避免了在代码中硬编码一些绝对路径和 URL。一个别名必须以 @ 字符开头，以区别于传统的文件路径和 URL。Yii 预定义了大量可用的别名。例如，别名 @yii 指的是 Yii 框架本身的安装目录，而 @web 表示的是当前运行应用的根 URL。

  定义别名
  你可以调用 [[Yii::setAlias()]] 来给文件路径或 URL 定义别名：

  ```php // 文件路径的别名 Yii::setAlias('@foo', '/path/to/foo');

  // URL 的别名 Yii::setAlias('@bar', 'http://www.example.com'); ```

  Note: 别名所指向的文件路径或 URL 不一定是真实存在的文件或资源。

  可以通过在一个别名后面加斜杠 / 和一至多个路径分段生成新别名（无需调用 [[Yii::setAlias()]]）。我们把通过 [[Yii::setAlias()]] 定义的别名称为根别名，而用他们衍生出去的别名成为衍生别名。例如，@foo 就是根别名，而 @foo/bar/file.php 是一个衍生别名。

  你还可以用别名去定义新别名（根别名与衍生别名均可）：

  php Yii::setAlias('@foobar', '@foo/bar');

  根别名通常在引导阶段定义。比如你可以在入口脚本里调用 [[Yii::setAlias()]]。为了方便起见，应用提供了一个名为 aliases 的可写属性，你可以在应用配置中设置它，就像这样：

  php return [ // ... 'aliases' => [ '@foo' => '/path/to/foo', '@bar' => 'http://www.example.com', ], ];

  解析别名
  你可以调用 [[Yii::getAlias()]] 命令来解析根别名到对应的文件路径或 URL。同样的页面也可以用于解析衍生别名。例如：

  php echo Yii::getAlias('@foo'); // 输出：/path/to/foo echo Yii::getAlias('@bar'); // 输出：http://www.example.com echo Yii::getAlias('@foo/bar/file.php'); // 输出：/path/to/foo/bar/file.php

  由衍生别名所解析出的文件路径和 URL 是通过替换掉衍生别名中的根别名部分得到的。

  Note: [[Yii::getAlias()]] 并不检查结果路径/URL 所指向的资源是否真实存在。

  根别名可能也会包含斜杠 /。[[Yii::getAlias()]] 足够智能到判断一个别名中的哪部分是根别名，因此能正确解析文件路径/URL。例如：

  php Yii::setAlias('@foo', '/path/to/foo'); Yii::setAlias('@foo/bar', '/path2/bar'); echo Yii::getAlias('@foo/test/file.php'); // 输出：/path/to/foo/test/file.php echo Yii::getAlias('@foo/bar/file.php'); // 输出：/path2/bar/file.php

  若 @foo/bar 未被定义为根别名，最后一行语句会显示为 /path/to/foo/bar/file.php。

  使用别名
  别名在 Yii 的很多地方都会被正确识别，无需调用 [[Yii::getAlias()]] 来把它们转换为路径/URL。例如，[[yii\caching\FileCache::cachePath]] 能同时接受文件路径或是指向文件路径的别名，因为通过 @ 前缀能区分它们。

  ```php use yii\caching\FileCache;

  $cache = new FileCache([ 'cachePath' => '@runtime/cache', ]); ```

  请关注 API 文档了解特定属性或方法参数是否支持别名。

  预定义的别名
  Yii 预定义了一系列别名来简化常用路径和 URL 的使用：

  @yii - BaseYii.php 文件所在的目录（也被称为框架安装目录）
  @app - 当前运行的应用 [[yii\base\Application::basePath|根路径（base path）]]
  @runtime - 当前运行的应用的 [[yii\base\Application::runtimePath|运行环境（runtime）路径]]
  @vendor - [[yii\base\Application::vendorPath|Composer 供应商目录]]
  @webroot - 当前运行应用的 Web 入口目录
  @web - 当前运行应用的根 URL
  @yii 别名是在入口脚本里包含 Yii.php 文件时定义的，其他的别名都是在配置应用的时候，于应用的构造方法内定义的。

  扩展的别名
  每一个通过 Composer 安装的 扩展 都自动添加了一个别名。该别名会以该扩展在 composer.json 文件中所声明的根命名空间为名，且他直接代指该包的根目录。例如，如果你安装有 yiisoft/yii2-jui 扩展，会自动得到 @yii/jui 别名，它定义于引导启动阶段：

  php Yii::setAlias('@yii/jui', 'VendorPath/yiisoft/yii2-jui');
*** 类自动加载（Class Autoloading）
    类自动加载（Autoloading）
  Yii 依靠类自动加载机制来定位和包含所需的类文件。它提供一个高性能且完美支持PSR-4 标准（中文汉化）的自动加载器。该自动加载器会在引入框架文件 Yii.php 时安装好。

  Note: 为了简化叙述，本篇文档中我们只会提及类的自动加载。不过，要记得文中的描述同样也适用于接口和Trait（特质）的自动加载哦。

  使用 Yii 自动加载器
  要使用 Yii 的类自动加载器，你需要在创建和命名类的时候遵循两个简单的规则：

  每个类都必须置于命名空间之下 (比如 foo\bar\MyClass)。
  每个类都必须保存为单独文件，且其完整路径能用以下算法取得：
  php // $className 是一个开头包含反斜杠的完整类名（译注：请自行谷歌：fully qualified class name） $classFile = Yii::getAlias('@' . str_replace('\\', '/', $className) . '.php');

  举例来说，若某个类名为 foo\bar\MyClass，对应类的文件路径别名会是 @foo/bar/MyClass.php。为了让该别名能被正确解析为文件路径，@foo 或 @foo/bar 中的一个必须是根别名。

  当我们使用基本应用模版时，可以把你的类放置在顶级命名空间 app 下，这样它们就可以被 Yii 自动加载，而无需定义一个新的别名。这是因为 @app 本身是一个预定义别名，且类似于 app\components\MyClass 这样的类名，基于我们刚才所提到的算法，可以正确解析出 AppBasePath/components/MyClass.php 路径。

  在高级应用模版里，每一逻辑层级会使用他自己的根别名。比如，前端层会使用 @frontend 而后端层会使用 @backend。因此，你可以把前端的类放在 frontend 命名空间，而后端的类放在 backend。 这样这些类就可以被 Yii 自动加载了。

  类映射表（Class Map）
  Yii 类自动加载器支持类映射表功能，该功能会建立一个从类的名字到类文件路径的映射。当自动加载器加载一个文件时，他首先检查映射表里有没有该类。如果有，对应的文件路径就直接加载了，省掉了进一步的检查。这让类的自动加载变得超级快。事实上所有的 Yii 核心类都是这样加载的。

  你可以用 Yii::$classMap 方法向映射表中添加类，

  php Yii::$classMap['foo\bar\MyClass'] = 'path/to/MyClass.php';

  别名可以被用于指定类文件的路径。你应该在引导启动的过程中设置类映射表，这样映射表就可以在你使用具体类之前就准备好。

  用其他自动加载器
  因为 Yii 完全支持 Composer 管理依赖包，所以推荐你也同时安装 Composer 的自动加载器，如果你用了一些自带自动加载器的第三方类库，你应该也安装下它们。

  当你同时使用其他自动加载器和 Yii 自动加载器时，应该在其他自动加载器安装成功之后，再包含 Yii.php 文件。这将使 Yii 成为第一个响应任何类自动加载请求的自动加载器。举例来说，以下代码提取自基本应用模版的入口脚本 。第一行安装了 Composer 的自动加载器，第二行才是 Yii 的自动加载器：

  php require __DIR__ . '/../vendor/autoload.php'; require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

  你也可以只使用 Composer 的自动加载，而不用 Yii 的自动加载。不过这样做的话，类的加载效率会下降，且你必须遵循 Composer 所设定的规则，从而让你的类满足可以被自动加载的要求。

  Info: 若你不想要使用 Yii 的自动加载器，你必须创建一个你自己版本的 Yii.php 文件，并把它包含进你的入口脚本里。

  自动加载扩展类
  Yii 自动加载器支持自动加载扩展的类。唯一的要求是它需要在 composer.json 文件里正确地定义 autoload 部分。请参考 Composer 文档（英文）（中文汉化），来了解如何正确描述 autoload 的更多细节。

  在你不使用 Yii 的自动加载器时，Composer 的自动加载器仍然可以帮你自动加载扩展内的类。
*** 服务定位器（Service Locator）
    服务定位器
  服务定位器是一个了解如何提供各种应用所需的服务（或组件）的对象。在服务定位器中，每个组件都只有一个单独的实例，并通过ID 唯一地标识。用这个 ID 就能从服务定位器中得到这个组件。

  在 Yii 中，服务定位器是 [[yii\di\ServiceLocator]] 或其子类的一个实例。

  最常用的服务定位器是application（应用）对象，可以通过 \Yii::$app 访问。它所提供的服务被称为application components（应用组件），比如：request、response、urlManager 组件。可以通过服务定位器所提供的功能，非常容易地配置这些组件，或甚至是用你自己的实现替换掉他们。

  除了 application 对象，每个模块对象本身也是一个服务定位器。

  要使用服务定位器，第一步是要注册相关组件。组件可以通过 [[yii\di\ServiceLocator::set()]] 方法进行注册。以下的方法展示了注册组件的不同方法：

  ```php use yii\di\ServiceLocator; use yii\caching\FileCache;

  $locator = new ServiceLocator;

  // 通过一个可用于创建该组件的类名，注册 "cache" （缓存）组件。 $locator->set('cache', 'yii\caching\ApcCache');

  // 通过一个可用于创建该组件的配置数组，注册 "db" （数据库）组件。 $locator->set('db', [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=demo', 'username' => 'root', 'password' => '', ]);

  // 通过一个能返回该组件的匿名函数，注册 "search" 组件。 $locator->set('search', function () { return new app\components\SolrService; });

  // 用组件注册 "pageCache" 组件 $locator->set('pageCache', new FileCache); ```

  一旦组件被注册成功，你可以任选以下两种方式之一，通过它的 ID 访问它：

  php $cache = $locator->get('cache'); // 或者 $cache = $locator->cache;

  如上所示， [[yii\di\ServiceLocator]] 允许通过组件 ID 像访问一个属性值那样访问一个组件。当你第一次访问某组件时，[[yii\di\ServiceLocator]] 会通过该组件的注册信息创建一个该组件的实例，并返回它。之后，如果再次访问，则服务定位器会返回同一个实例。

  你可以通过 [[yii\di\ServiceLocator::has()]] 检查某组件 ID 是否被注册。若你用一个无效的 ID 调用 [[yii\di\ServiceLocator::get()]]，则会抛出一个异常。

  因为服务定位器，经常会在创建时附带配置信息，因此我们提供了一个可写的属性，名为 [[yii\di\ServiceLocator::setComponents()|components]]，这样就可以配置该属性，或一次性注册多个组件。下面的代码展示了如何用一个配置数组，配置一个应用并注册"db"，"cache" 和 "search" 三个组件：

  php return [ // ... 'components' => [ 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=demo', 'username' => 'root', 'password' => '', ], 'cache' => 'yii\caching\ApcCache', 'search' => function () { return new app\components\SolrService; }, ], ];
*** 依赖注入容器（Dependency Injection Container）
    依赖注入容器
  依赖注入（Dependency Injection，DI）容器就是一个对象，它知道怎样初始化并配置对象及其依赖的所有对象。Martin 的文章 已经解释了 DI 容器为什么很有用。这里我们主要讲解 Yii 提供的 DI 容器的使用方法。

  依赖注入
  Yii 通过 [[yii\di\Container]] 类提供 DI 容器特性。它支持如下几种类型的依赖注入：

  构造方法注入;
  Setter 和属性注入;
  PHP 回调注入.
  构造方法注入
  在参数类型提示的帮助下，DI 容器实现了构造方法注入。当容器被用于创建一个新对象时，类型提示会告诉它要依赖什么类或接口。容器会尝试获取它所依赖的类或接口的实例，然后通过构造器将其注入新的对象。例如：

  ```php class Foo { public function __construct(Bar $bar) { } }

  $foo = $container->get('Foo'); // 上面的代码等价于： $bar = new Bar; $foo = new Foo($bar); ```

  Setter 和属性注入
  Setter 和属性注入是通过配置提供支持的。当注册一个依赖或创建一个新对象时，你可以提供一个配置，该配置会提供给容器用于通过相应的 Setter 或属性注入依赖。例如：

  ```php use yii\base\BaseObject;

  class Foo extends BaseObject { public $bar;

  private $_qux;

  public function getQux()
  {
      return $this->_qux;
  }

  public function setQux(Qux $qux)
  {
      $this->_qux = $qux;
  }
  }

  $container->get('Foo', [], [ 'bar' => $container->get('Bar'), 'qux' => $container->get('Qux'), ]); ```

  PHP 回调注入
  这种情况下，容器将使用一个注册过的 PHP 回调创建一个类的新实例。回调负责解决依赖并将其恰当地注入新创建的对象。例如：

  ```php $container->set('Foo', function ($container, $params, $config) { return new Foo(new Bar); });

  $foo = $container->get('Foo'); ```

  注册依赖关系
  可以用 [[yii\di\Container::set()]] 注册依赖关系。注册会用到一个依赖关系名称和一个依赖关系的定义。依赖关系名称可以是一个类名，一个接口名或一个别名。依赖关系的定义可以是一个类名，一个配置数组，或者一个 PHP 回调。

  ```php $container = new \yii\di\Container;

  // 注册一个同类名一样的依赖关系，这个可以省略。 $container->set('yii\db\Connection');

  // 注册一个接口 // 当一个类依赖这个接口时，相应的类会被初始化作为依赖对象。 $container->set('yii\mail\MailInterface', 'yii\swiftmailer\Mailer');

  // 注册一个别名。 // 你可以使用 $container->get('foo') 创建一个 Connection 实例 $container->set('foo', 'yii\db\Connection');

  // 通过配置注册一个类 // 通过 get() 初始化时，配置将会被使用。 $container->set('yii\db\Connection', [ 'dsn' => 'mysql:host=127.0.0.1;dbname=demo', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ]);

  // 通过类的配置注册一个别名 // 这种情况下，需要通过一个 “class” 元素指定这个类 $container->set('db', [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=127.0.0.1;dbname=demo', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ]);

  // 注册一个 PHP 回调 // 每次调用 $container->get('db') 时，回调函数都会被执行。 $container->set('db', function ($container, $params, $config) { return new \yii\db\Connection($config); });

  // 注册一个组件实例 // $container->get('pageCache') 每次被调用时都会返回同一个实例。 $container->set('pageCache', new FileCache); ```

  Tip: 如果依赖关系名称和依赖关系的定义相同，则不需要通过 DI 容器注册该依赖关系。

  通过 set() 注册的依赖关系，在每次使用时都会产生一个新实例。可以使用 [[yii\di\Container::setSingleton()]] 注册一个单例的依赖关系：

  php $container->setSingleton('yii\db\Connection', [ 'dsn' => 'mysql:host=127.0.0.1;dbname=demo', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ]);

  解决依赖关系
  注册依赖关系后，就可以使用 DI 容器创建新对象了。容器会自动解决依赖关系，将依赖实例化并注入新创建的对象。依赖关系的解决是递归的，如果一个依赖关系中还有其他依赖关系，则这些依赖关系都会被自动解决。

  可以使用 [[yii\di\Container::get()]] 创建新的对象。该方法接收一个依赖关系名称，它可以是一个类名，一个接口名或一个别名。依赖关系名或许是通过 set() 或 setSingleton() 注册的。你可以随意地提供一个类的构造器参数列表和一个configuration 用于配置新创建的对象。例如：

  ```php // "db" 是前面定义过的一个别名 $db = $container->get('db');

  // 等价于： $engine = new \app\components\SearchEngine($apiKey, ['type' => 1]); $engine = $container->get('app\components\SearchEngine', [$apiKey], ['type' => 1]); ```

  代码背后，DI 容器做了比创建对象多的多的工作。容器首先将检查类的构造方法，找出依赖的类或接口名，然后自动递归解决这些依赖关系。

  如下代码展示了一个更复杂的示例。UserLister 类依赖一个实现了 UserFinderInterface 接口的对象；UserFinder 类实现了这个接口，并依赖于一个 Connection 对象。所有这些依赖关系都是通过类构造器参数的类型提示定义的。通过属性依赖关系的注册，DI 容器可以自动解决这些依赖关系并能通过一个简单的 get('userLister') 调用创建一个新的 UserLister 实例。

  ```php namespace app\models;

  use yii\base\BaseObject; use yii\db\Connection; use yii\di\Container;

  interface UserFinderInterface { function findUser(); }

  class UserFinder extends BaseObject implements UserFinderInterface { public $db;

  public function __construct(Connection $db, $config = [])
  {
      $this->db = $db;
      parent::__construct($config);
  }

  public function findUser()
  {
  }
  }

  class UserLister extends BaseObject { public $finder;

  public function __construct(UserFinderInterface $finder, $config = [])
  {
      $this->finder = $finder;
      parent::__construct($config);
  }
  }

  $container = new Container; $container->set('yii\db\Connection', [ 'dsn' => '...', ]); $container->set('app\models\UserFinderInterface', [ 'class' => 'app\models\UserFinder', ]); $container->set('userLister', 'app\models\UserLister');

  $lister = $container->get('userLister');

  // 等价于:

  $db = new \yii\db\Connection(['dsn' => '...']); $finder = new UserFinder($db); $lister = new UserLister($finder); ```

  实践中的运用
  当在应用程序的入口脚本中引入 Yii.php 文件时，Yii 就创建了一个 DI 容器。这个 DI 容器可以通过 [[Yii::$container]] 访问。当调用 [[Yii::createObject()]] 时，此方法实际上会调用这个容器的 [[yii\di\Container::get()|get()]] 方法创建新对象。如上所述，DI 容器会自动解决依赖关系（如果有）并将其注入新创建的对象中。因为 Yii 在其多数核心代码中都使用了 [[Yii::createObject()]] 创建新对象，所以你可以通过 [[Yii::$container]] 全局性地自定义这些对象。

  例如，你可以全局性自定义 [[yii\widgets\LinkPager]] 中分页按钮的默认数量:

  php \Yii::$container->set('yii\widgets\LinkPager', ['maxButtonCount' => 5]);

  这样如果你通过如下代码在一个视图里使用这个挂件，它的 maxButtonCount 属性就会被初始化为 5 而不是类中定义的默认值 10。

  php echo \yii\widgets\LinkPager::widget();

  然而你依然可以覆盖通过 DI 容器设置的值：

  php echo \yii\widgets\LinkPager::widget(['maxButtonCount' => 20]);

  另一个例子是借用 DI 容器中自动构造方法注入带来的好处。假设你的控制器类依赖一些其他对象，例如一个旅馆预订服务。你可以通过一个构造器参数声明依赖关系，然后让 DI 容器帮你自动解决这个依赖关系。

  ```php namespace app\controllers;

  use yii\web\Controller; use app\components\BookingInterface;

  class HotelController extends Controller { protected $bookingService;

  public function __construct($id, $module, BookingInterface $bookingService, $config = [])
  {
      $this->bookingService = $bookingService;
      parent::__construct($id, $module, $config);
  }
  } ```

  如果你从浏览器中访问这个控制器，你将看到一个报错信息，提醒你 BookingInterface 无法被实例化。这是因为你需要告诉 DI 容器怎样处理这个依赖关系。

  php \Yii::$container->set('app\components\BookingInterface', 'app\components\BookingService');

  现在如果你再次访问这个控制器，一个 app\components\BookingService 的实例就会被创建并被作为第三个参数注入到控制器的构造器中。

  什么时候注册依赖关系
  由于依赖关系在创建新对象时需要解决，因此它们的注册应该尽早完成。如下是推荐的实践：

  如果你是一个应用程序的开发者，你可以在应用程序的入口脚本或者被入口脚本引入的脚本中注册依赖关系。
  如果你是一个可再分发扩展的开发者，你可以将依赖关系注册到扩展的引导类中。
  总结
  依赖注入和服务定位器都是流行的设计模式，它们使你可以用充分解耦且更利于测试的风格构建软件。强烈推荐你阅读 Martin 的文章 ，对依赖注入和服务定位器有个更深入的理解。

  Yii 在依赖住入（DI）容器之上实现了它的服务定位器。当一个服务定位器尝试创建一个新的对象实例时，它会把调用转发到 DI 容器。后者将会像前文所述那样自动解决依赖关系。
** 配合数据库工作（Working with Databases）
*** 数据库访问（Data Access Objects）: 数据库连接、基本查询、事务和模式操作
    数据库访问 (DAO)
  Yii 包含了一个建立在 PHP PDO 之上的数据访问层 (DAO). DAO为不同的数据库提供了一套统一的API. 其中 ActiveRecord 提供了数据库与模型(MVC 中的 M,Model) 的交互, QueryBuilder 用于创建动态的查询语句. DAO提供了简单高效的SQL查询,可以用在与数据库交互的各个地方.

  Yii 默认支持以下数据库 (DBMS):

  MySQL
  MariaDB
  SQLite
  PostgreSQL: 版本 >= 8.4
  CUBRID: 版本 >= 9.3 . (由于PHP PDO 扩展的一个bug 引用值会无效,所以你需要在 CUBRID的客户端和服务端都使用 9.3 )
  Oracle
  MSSQL: 版本>=2005.
  配置
  开始使用数据库首先需要配置数据库连接组件，通过添加 db 组件到应用配置实现（"基础的" Web 应用是 config/web.php），DSN( Data Source Name )是数据源名称，用于指定数据库信息.如下所示：

  php return [ // ... 'components' => [ // ... 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=mydatabase', // MySQL, MariaDB //'dsn' => 'sqlite:/path/to/database/file', // SQLite //'dsn' => 'pgsql:host=localhost;port=5432;dbname=mydatabase', // PostgreSQL //'dsn' => 'cubrid:dbname=demodb;host=localhost;port=33000', // CUBRID //'dsn' => 'sqlsrv:Server=localhost;Database=mydatabase', // MS SQL Server, sqlsrv driver //'dsn' => 'dblib:host=localhost;dbname=mydatabase', // MS SQL Server, dblib driver //'dsn' => 'mssql:host=localhost;dbname=mydatabase', // MS SQL Server, mssql driver //'dsn' => 'oci:dbname=//localhost:1521/mydatabase', // Oracle 'username' => 'root', //数据库用户名 'password' => '', //数据库密码 'charset' => 'utf8', ], ], // ... ];

  请参考PHP manual获取更多有关 DSN 格式信息。 配置连接组件后可以使用以下语法访问：

  $connection = \Yii::$app->db;

  请参考 [[yii\db\Connection]] 获取可配置的属性列表。 如果你想通过ODBC连接数据库，则需要配置[[yii\db\Connection::driverName]] 属性，例如:

  php 'db' => [ 'class' => 'yii\db\Connection', 'driverName' => 'mysql', 'dsn' => 'odbc:Driver={MySQL};Server=localhost;Database=test', 'username' => 'root', 'password' => '', ],

  注意：如果需要同时使用多个数据库可以定义多个连接组件：

  php return [ // ... 'components' => [ // ... 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=mydatabase', 'username' => 'root', 'password' => '', 'charset' => 'utf8', ], 'secondDb' => [ 'class' => 'yii\db\Connection', 'dsn' => 'sqlite:/path/to/database/file', ], ], // ... ];

  在代码中通过以下方式使用:

  php $primaryConnection = \Yii::$app->db; $secondaryConnection = \Yii::$app->secondDb;

  如果不想定义数据库连接为全局应用组件，可以在代码中直接初始化使用：

  php $connection = new \yii\db\Connection([ 'dsn' => $dsn, 'username' => $username, 'password' => $password, ]); $connection->open();

  小提示：如果在创建了连接后需要执行额外的 SQL 查询，可以添加以下代码到应用配置文件：

  php return [ // ... 'components' => [ // ... 'db' => [ 'class' => 'yii\db\Connection', // ... 'on afterOpen' => function($event) { $event->sender->createCommand("SET time_zone = 'UTC'")->execute(); } ], ], // ... ];

  SQL 基础查询
  一旦有了连接实例就可以通过[[yii\db\Command]]执行 SQL 查询。

  SELECT 查询
  查询返回多行：

  php $command = $connection->createCommand('SELECT * FROM post'); $posts = $command->queryAll();

  返回单行：

  php $command = $connection->createCommand('SELECT * FROM post WHERE id=1'); $post = $command->queryOne();

  查询多行单值：

  php $command = $connection->createCommand('SELECT title FROM post'); $titles = $command->queryColumn();

  查询标量值/计算值：

  php $command = $connection->createCommand('SELECT COUNT(*) FROM post'); $postCount = $command->queryScalar();

  UPDATE, INSERT, DELETE 更新、插入和删除等
  如果执行 SQL 不返回任何数据可使用命令中的 execute 方法：

  php $command = $connection->createCommand('UPDATE post SET status=1 WHERE id=1'); $command->execute();

  你可以使用insert,update,delete 方法，这些方法会根据参数生成合适的SQL并执行.

  ```php // INSERT $connection->createCommand()->insert('user', [ 'name' => 'Sam', 'age' => 30, ])->execute();

  // INSERT 一次插入多行 $connection->createCommand()->batchInsert('user', ['name', 'age'], [ ['Tom', 30], ['Jane', 20], ['Linda', 25], ])->execute();

  // UPDATE $connection->createCommand()->update('user', ['status' => 1], 'age > 30')->execute();

  // DELETE $connection->createCommand()->delete('user', 'status = 0')->execute(); ```

  引用的表名和列名
  大多数时间都使用以下语法来安全地引用表名和列名：

  php $sql = "SELECT COUNT([[$column]]) FROM {{table}}"; $rowCount = $connection->createCommand($sql)->queryScalar();

  以上代码 [[$column]] 会转变为引用恰当的列名，而 {{table}} 就转变为引用恰当的表名。 表名有个特殊的变量 {{%Y}} ，如果设置了表前缀使用该变体可以自动在表名前添加前缀：

  php $sql = "SELECT COUNT([[$column]]) FROM {{%$table}}"; $rowCount = $connection->createCommand($sql)->queryScalar();

  如果在配置文件如下设置了表前缀，以上代码将在 tbl_table 这个表查询结果：

  php return [ // ... 'components' => [ // ... 'db' => [ // ... 'tablePrefix' => 'tbl_', ], ], ];

  手工引用表名和列名的另一个选择是使用[[yii\db\Connection::quoteTableName()]] 和 [[yii\db\Connection::quoteColumnName()]]：

  php $column = $connection->quoteColumnName($column); $table = $connection->quoteTableName($table); $sql = "SELECT COUNT($column) FROM $table"; $rowCount = $connection->createCommand($sql)->queryScalar();

  预处理语句
  为安全传递查询参数可以使用预处理语句,首先应当使用 :placeholder 占位，再将变量绑定到对应占位符：

  php $command = $connection->createCommand('SELECT * FROM post WHERE id=:id'); $command->bindValue(':id', $_GET['id']); $post = $command->query();

  另一种用法是准备一次预处理语句而执行多次查询：

  ```php $command = $connection->createCommand('DELETE FROM post WHERE id=:id'); $command->bindParam(':id', $id);

  $id = 1; $command->execute();

  $id = 2; $command->execute(); ```

  提示: 在执行前绑定变量，然后在每个执行中改变变量的值（一般用在循环中）比较高效.

  事务
  当你需要顺序执行多个相关的的 query 时，你可以把他们封装到一个事务中去保护数据一致性.Yii提供了一个简单的接口来实现事务操作. 如下执行 SQL 事务查询语句：

  php $transaction = $connection->beginTransaction(); try { $connection->createCommand($sql1)->execute(); $connection->createCommand($sql2)->execute(); // ... 执行其他 SQL 语句 ... $transaction->commit(); } catch(Exception $e) { $transaction->rollBack(); }

  我们通过[[yii\db\Connection::beginTransaction()|beginTransaction()]]开始一个事务，通过 try catch 捕获异常.当执行成功，通过[[yii\db\Transaction::commit()|commit()]]提交事务并结束，当发生异常失败通过[[yii\db\Transaction::rollBack()|rollBack()]]进行事务回滚.

  如需要也可以嵌套多个事务：

  ```php // 外部事务 $transaction1 = $connection->beginTransaction(); try { $connection->createCommand($sql1)->execute();

  // 内部事务
  $transaction2 = $connection->beginTransaction();
  try {
      $connection->createCommand($sql2)->execute();
      $transaction2->commit();
  } catch (Exception $e) {
      $transaction2->rollBack();
  }

  $transaction1->commit();
  } catch (Exception $e) { $transaction1->rollBack(); } ```

  注意: 你使用的数据库必须支持 Savepoints 才能正确地执行，以上代码在所有关系数据中都可以执行，但是只有支持 Savepoints 才能保证安全性。

  Yii 也支持为事务设置隔离级别 isolation levels，当执行事务时会使用数据库默认的隔离级别，你也可以为事务指定隔离级别. Yii 提供了以下常量作为常用的隔离级别

  [[\yii\db\Transaction::READ_UNCOMMITTED]] - 允许读取改变了的还未提交的数据,可能导致脏读、不可重复读和幻读
  [[\yii\db\Transaction::READ_COMMITTED]] - 允许并发事务提交之后读取，可以避免脏读，可能导致重复读和幻读。
  [[\yii\db\Transaction::REPEATABLE_READ]] - 对相同字段的多次读取结果一致，可导致幻读。
  [[\yii\db\Transaction::SERIALIZABLE]] - 完全服从ACID的原则，确保不发生脏读、不可重复读和幻读。
  你可以使用以上常量或者使用一个string字符串命令，在对应数据库中执行该命令用以设置隔离级别，比如对于 postgres 有效的命令为 SERIALIZABLE READ ONLY DEFERRABLE.

  Note: 某些数据库只能针对连接来设置事务隔离级别，所以你必须要为连接明确制定隔离级别.目前受影响的数据库: MSSQL SQLite

  Note: SQLite 只支持两种事务隔离级别，所以你只能设置 READ UNCOMMITTED 和 SERIALIZABLE.使用其他隔离级别会抛出异常.

  Note: PostgreSQL 不允许在事务开始前设置隔离级别，所以你不能在事务开始时指定隔离级别.你可以在事务开始之后调用[[yii\db\Transaction::setIsolationLevel()]] 来设置.

  关于隔离级别[isolation levels]: http://en.wikipedia.org/wiki/Isolation%28databasesystems%29#Isolation_levels

  数据库复制和读写分离
  很多数据库支持数据库复制 database replication#Database_replication) 来提高可用性和响应速度. 在数据库复制中，数据总是从主服务器 到 从服务器. 所有的插入和更新等写操作在主服务器执行，而读操作在从服务器执行.

  通过配置[[yii\db\Connection]]可以实现数据库复制和读写分离.

  ```php [ 'class' => 'yii\db\Connection',

  // 配置主服务器
  'dsn' => 'dsn for master server',
  'username' => 'master',
  'password' => '',

  // 配置从服务器
  'slaveConfig' => [
      'username' => 'slave',
      'password' => '',
      'attributes' => [
          // use a smaller connection timeout
          PDO::ATTR_TIMEOUT => 10,
      ],
  ],

  // 配置从服务器组
  'slaves' => [
      ['dsn' => 'dsn for slave server 1'],
      ['dsn' => 'dsn for slave server 2'],
      ['dsn' => 'dsn for slave server 3'],
      ['dsn' => 'dsn for slave server 4'],
  ],
  ] ```

  以上的配置实现了一主多从的结构，从服务器用以执行读查询，主服务器执行写入查询，读写分离的功能由后台代码自动完成.调用者无须关心.例如：

  ```php // 使用以上配置创建数据库连接对象 $db = Yii::createObject($config);

  // 通过从服务器执行查询操作 $rows = $db->createCommand('SELECT * FROM user LIMIT 10')->queryAll();

  // 通过主服务器执行更新操作 $db->createCommand("UPDATE user SET username='demo' WHERE id=1")->execute(); ```

  Note: 通过[[yii\db\Command::execute()]] 执行的查询被认为是写操作，所有使用[[yii\db\Command]]来执行的其他查询方法被认为是读操作.你可以通过$db->slave得到当前正在使用能够的从服务器.

  Connection 组件支持从服务器的负载均衡和故障转移，当第一次执行读查询时，会随即选择一个从服务器进行连接，如果连接失败则又选择另一个，如果所有从服务器都不可用，则会连接主服务器。你可以配置[[yii\db\Connection::serverStatusCache|server status cache]]来记住那些不能连接的从服务器，使Yii 在一段时间[[yii\db\Connection::serverRetryInterval]].内不会重复尝试连接那些根本不可用的从服务器.

  Note: 在上述配置中，每个从服务器连接超时时间被指定为10s. 如果在10s内不能连接，则被认为该服务器已经挂掉.你也可以自定义超时参数.

  你也可以配置多主多从的结构，例如:

  ```php [ 'class' => 'yii\db\Connection',

  // 配置主服务器
  'masterConfig' => [
      'username' => 'master',
      'password' => '',
      'attributes' => [
          // use a smaller connection timeout
          PDO::ATTR_TIMEOUT => 10,
      ],
  ],

  // 配置主服务器组
  'masters' => [
      ['dsn' => 'dsn for master server 1'],
      ['dsn' => 'dsn for master server 2'],
  ],

  // 配置从服务器
  'slaveConfig' => [
      'username' => 'slave',
      'password' => '',
      'attributes' => [
          // use a smaller connection timeout
          PDO::ATTR_TIMEOUT => 10,
      ],
  ],

  // 配置从服务器组
  'slaves' => [
      ['dsn' => 'dsn for slave server 1'],
      ['dsn' => 'dsn for slave server 2'],
      ['dsn' => 'dsn for slave server 3'],
      ['dsn' => 'dsn for slave server 4'],
  ],
  ] ```

  上述配置制定了2个主服务器和4个从服务器.Connection 组件也支持主服务器的负载均衡和故障转移，与从服务器不同的是，如果所有主服务器都不可用，则会抛出异常.

  Note: 当你使用[[yii\db\Connection::masters|masters]]来配置一个或多个主服务器时，Connection中关于数据库连接的其他属性（例如：dsn, username, password）都会被忽略.

  事务默认使用主服务器的连接，并且在事务执行中的所有操作都会使用主服务器的连接，例如:

  ```php // 在主服务器连接上开始事务 $transaction = $db->beginTransaction();

  try { // 所有的查询都在主服务器上执行 $rows = $db->createCommand('SELECT * FROM user LIMIT 10')->queryAll(); $db->createCommand("UPDATE user SET username='demo' WHERE id=1")->execute();

  $transaction->commit();
  } catch(\Exception $e) { $transaction->rollBack(); throw $e; } ```

  如果你想在从服务器上执行事务操作则必须要明确地指定，比如:

  php $transaction = $db->slave->beginTransaction();

  有时你想强制使用主服务器来执行读查询，你可以调用 seMaster() 方法.

  php $rows = $db->useMaster(function ($db) { return $db->createCommand('SELECT * FROM user LIMIT 10')->queryAll(); });

  你也可以设置 $db->enableSlaves 为 false 来使所有查询都在主服务器上执行.

  操作数据库模式
  获得模式信息
  你可以通过 [[yii\db\Schema]]实例来获取Schema信息:

  php $schema = $connection->getSchema();

  该实例包括一系列方法来检索数据库多方面的信息：

  php $tables = $schema->getTableNames();

  更多信息请参考[[yii\db\Schema]]

  修改模式
  除了基础的 SQL 查询，[[yii\db\Command]]还包括一系列方法来修改数据库模式：

  创建/重命名/删除/清空表
  增加/重命名/删除/修改字段
  增加/删除主键
  增加/删除外键
  创建/删除索引
  使用示例:

  php // 创建表 $connection->createCommand()->createTable('post', [ 'id' => 'pk', 'title' => 'string', 'text' => 'text', ]);

  完整参考请查看[[yii\db\Command]].
*** 查询生成器（Query Builder）: 使用简单抽象层查询数据库
  
*** 活动记录（Active Record）: 活动记录对象关系映射（ORM），检索和操作记录、定义关联关系
    Active Record
  Note: 该章节还在开发中。

  Active Record （活动记录，以下简称AR）提供了一个面向对象的接口， 用以访问数据库中的数据。一个 AR 类关联一张数据表， 每个 AR 对象对应表中的一行，对象的属性（即 AR 的特性Attribute）映射到数据行的对应列。 一条活动记录（AR对象）对应数据表的一行，AR对象的属性则映射该行的相应列。 您可以直接以面向对象的方式来操纵数据表中的数据，妈妈再不用担心我需要写原生 SQL 语句啦。

  例如，假定 Customer AR 类关联着 customer 表，且该类的 name 属性代表 customer 表的 name 列。 你可以写以下代码来哉 customer 表里插入一行新的记录:

  用 AR 而不是原生的 SQL 语句去执行数据库查询，可以调用直观方法来实现相同目标。如，调用 [[yii\db\ActiveRecord::save()|save()]] 方法将执行插入或更新轮询，将在该 AR 类关联的数据表新建或更新一行数据：

  php $customer = new Customer(); $customer->name = '李狗蛋'; $customer->save(); // 一行新数据插入 customer 表

  上面的代码和使用下面的原生 SQL 语句是等效的，但显然前者更直观， 更不易出错，并且面对不同的数据库系统（DBMS, Database Management System）时更不容易产生兼容性问题。

  php $db->createCommand('INSERT INTO customer (name) VALUES (:name)', [ ':name' => '李狗蛋', ])->execute();

  下面是所有目前被 Yii 的 AR 功能所支持的数据库列表：

  MySQL 4.1 及以上：通过 [[yii\db\ActiveRecord]]
  PostgreSQL 7.3 及以上：通过 [[yii\db\ActiveRecord]]
  SQLite 2 和 3：通过 [[yii\db\ActiveRecord]]
  Microsoft SQL Server 2010 及以上：通过 [[yii\db\ActiveRecord]]
  Oracle: 通过 [[yii\db\ActiveRecord]]
  CUBRID 9.1 及以上：通过 [[yii\db\ActiveRecord]]
  Sphinx：通过 [[yii\sphinx\ActiveRecord]]，需求 yii2-sphinx 扩展
  ElasticSearch：通过 [[yii\elasticsearch\ActiveRecord]]，需求 yii2-elasticsearch 扩展
  Redis 2.6.12 及以上：通过 [[yii\redis\ActiveRecord]]，需求 yii2-redis 扩展
  MongoDB 1.3.0 及以上：通过 [[yii\mongodb\ActiveRecord]]，需求 yii2-mongodb 扩展
  如你所见，Yii 不仅提供了对关系型数据库的 AR 支持，还提供了 NoSQL 数据库的支持。 在这个教程中，我们会主要描述对关系型数据库的 AR 用法。 然而，绝大多数的内容在 NoSQL 的 AR 里同样适用。

  声明 AR 类
  要想声明一个 AR 类，你需要扩展 [[yii\db\ActiveRecord]] 基类， 并实现 tableName 方法，返回与之相关联的的数据表的名称：

  ```php namespace app\models;

  use yii\db\ActiveRecord;

  class Customer extends ActiveRecord { /** * @return string 返回该AR类关联的数据表名 */ public static function tableName() { return 'customer'; } } ```

  访问列数据
  AR 把相应数据行的每一个字段映射为 AR 对象的一个个特性变量（Attribute） 一个特性就好像一个普通对象的公共属性一样（public property）。 特性变量的名称和对应字段的名称是一样的，且大小姓名。

  使用以下语法读取列的值：

  php // "id" 和 "mail" 是 $customer 对象所关联的数据表的对应字段名 $id = $customer->id; $email = $customer->email;

  要改变列值，只要给关联属性赋新值并保存对象即可：

  php $customer->email = '哪吒@example.com'; $customer->save();

  建立数据库连接
  AR 用一个 [[yii\db\Connection|DB connection]] 对象与数据库交换数据。 默认的，它使用 db 组件作为其连接对象。详见数据库基础章节， 你可以在应用程序配置文件中设置下 db 组件，就像这样，

  php return [ 'components' => [ 'db' => [ 'class' => 'yii\db\Connection', 'dsn' => 'mysql:host=localhost;dbname=testdb', 'username' => 'demo', 'password' => 'demo', ], ], ];

  如果在你的应用中应用了不止一个数据库，且你需要给你的 AR 类使用不同的数据库链接（DB connection） ，你可以覆盖掉 [[yii\db\ActiveRecord::getDb()|getDb()]] 方法：

  ```php class Customer extends ActiveRecord { // ...

  public static function getDb()
  {
      return \Yii::$app->db2;  // 使用名为 "db2" 的应用组件
  }
  } ```

  查询数据
  AR 提供了两种方法来构建 DB 查询并向 AR 实例里填充数据：

  [[yii\db\ActiveRecord::find()]]
  [[yii\db\ActiveRecord::findBySql()]]
  以上两个方法都会返回 [[yii\db\ActiveQuery]] 实例，该类继承自[[yii\db\Query]]， 因此，他们都支持同一套灵活且强大的 DB 查询方法，如 where()，join()，orderBy()，等等。 下面的这些案例展示了一些可能的玩法：

  ```php // 取回所有活跃客户(状态为 active 的客户）并以他们的 ID 排序： $customers = Customer::find() ->where(['status' => Customer::STATUS_ACTIVE]) ->orderBy('id') ->all();

  // 返回ID为1的客户： $customer = Customer::find() ->where(['id' => 1]) ->one();

  // 取回活跃客户的数量： $count = Customer::find() ->where(['status' => Customer::STATUS_ACTIVE]) ->count();

  // 以客户ID索引结果集： $customers = Customer::find()->indexBy('id')->all(); // $customers 数组以 ID 为索引

  // 用原生 SQL 语句检索客户： $sql = 'SELECT * FROM customer'; $customers = Customer::findBySql($sql)->all(); ```

  Tip: 在上面的代码中，Customer::STATUS_ACTIVE 是一个在 Customer 类里定义的常量。（译注：这种常量的值一般都是tinyint）相较于直接在代码中写死字符串或数字，使用一个更有意义的常量名称是一种更好的编程习惯。

  有两个快捷方法：findOne 和 findAll() 用来返回一个或者一组ActiveRecord实例。前者返回第一个匹配到的实例，后者返回所有。 例如：

  ```php // 返回 id 为 1 的客户 $customer = Customer::findOne(1);

  // 返回 id 为 1 且状态为 active 的客户 $customer = Customer::findOne([ 'id' => 1, 'status' => Customer::STATUS_ACTIVE, ]);

  // 返回id为1、2、3的一组客户 $customers = Customer::findAll([1, 2, 3]);

  // 返回所有状态为 "deleted" 的客户 $customer = Customer::findAll([ 'status' => Customer::STATUS_DELETED, ]); ```

  以数组形式获取数据
  有时候，我们需要处理很大量的数据，这时可能需要用一个数组来存储取到的数据， 从而节省内存。你可以用 asArray() 函数做到这一点：

  php // 以数组而不是对象形式取回客户信息： $customers = Customer::find() ->asArray() ->all(); // $customers 的每个元素都是键值对数组

  批量获取数据
  在 Query Builder（查询构造器） 里，我们已经解释了当需要从数据库中查询大量数据时，你可以用 batch query（批量查询）来限制内存的占用。 你可能也想在 AR 里使用相同的技巧，比如这样……

  php // 一次提取 10 个客户信息 foreach (Customer::find()->batch(10) as $customers) { // $customers 是 10 个或更少的客户对象的数组 } // 一次提取 10 个客户并一个一个地遍历处理 foreach (Customer::find()->each(10) as $customer) { // $customer 是一个 ”Customer“ 对象 } // 贪婪加载模式的批处理查询 foreach (Customer::find()->with('orders')->each() as $customer) { }

  操作数据
  AR 提供以下方法插入、更新和删除与 AR 对象关联的那张表中的某一行：

  [[yii\db\ActiveRecord::save()|save()]]
  [[yii\db\ActiveRecord::insert()|insert()]]
  [[yii\db\ActiveRecord::update()|update()]]
  [[yii\db\ActiveRecord::delete()|delete()]]
  AR 同时提供了一下静态方法，可以应用在与某 AR 类所关联的整张表上。 用这些方法的时候千万要小心，因为他们作用于整张表！ 比如，deleteAll() 会删除掉表里所有的记录。

  [[yii\db\ActiveRecord::updateCounters()|updateCounters()]]
  [[yii\db\ActiveRecord::updateAll()|updateAll()]]
  [[yii\db\ActiveRecord::updateAllCounters()|updateAllCounters()]]
  [[yii\db\ActiveRecord::deleteAll()|deleteAll()]]
  下面的这些例子里，详细展现了如何使用这些方法：

  ```php // 插入新客户的记录 $customer = new Customer(); $customer->name = 'James'; $customer->email = 'james@example.com'; $customer->save(); // 等同于 $customer->insert();

  // 更新现有客户记录 $customer = Customer::findOne($id); $customer->email = 'james@example.com'; $customer->save(); // 等同于 $customer->update();

  // 删除已有客户记录 $customer = Customer::findOne($id); $customer->delete();

  // 删除多个年龄大于20，性别为男（Male）的客户记录 Customer::deleteAll('age > :age AND gender = :gender', [':age' => 20, ':gender' => 'M']);

  // 所有客户的age（年龄）字段加1： Customer::updateAllCounters(['age' => 1]); ```

  须知：save() 方法会调用 insert() 和 update() 中的一个， 用哪个取决于当前 AR 对象是不是新对象（在函数内部，他会检查 [[yii\db\ActiveRecord::isNewRecord]] 的值）。 若 AR 对象是由 new 操作符 初始化出来的，save() 方法会在表里插入一条数据； 如果一个 AR 是由 find() 方法获取来的， 则 save() 会更新表里的对应行记录。

  数据输入与有效性验证
  由于AR继承自[[yii\base\Model]]，所以它同样也支持Model的数据输入、验证等特性。例如，你可以声明一个rules方法用来覆盖掉[[yii\base\Model::rules()|rules()]]里的；你也可以给AR实例批量赋值；你也可以通过调用[[yii\base\Model::validate()|validate()]]执行数据验证。

  当你调用 save()、insert()、update() 这三个方法时，会自动调用[[yii\base\Model::validate()|validate()]]方法。如果验证失败，数据将不会保存进数据库。

  下面的例子演示了如何使用AR 获取/验证用户输入的数据并将他们保存进数据库：

  ```php // 新建一条记录 $model = new Customer; if ($model->load(Yii::$app->request->post()) && $model->save()) { // 获取用户输入的数据，验证并保存 }

  // 更新主键为$id的AR $model = Customer::findOne($id); if ($model === null) { throw new NotFoundHttpException; } if ($model->load(Yii::$app->request->post()) && $model->save()) { // 获取用户输入的数据，验证并保存 } ```

  读取默认值
  你的表列也许定义了默认值。有时候，你可能需要在使用web表单的时候给AR预设一些值。如果你需要这样做，可以在显示表单内容前通过调用loadDefaultValues()方法来实现： php $customer = new Customer(); $customer->loadDefaultValues(); // ... 渲染 $customer 的 HTML 表单 ...

  AR的生命周期
  理解AR的生命周期对于你操作数据库非常重要。生命周期通常都会有些典型的事件存在。对于开发AR的behaviors来说非常有用。

  当你实例化一个新的AR对象时，我们将获得如下的生命周期：

  constructor
  [[yii\db\ActiveRecord::init()|init()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTINIT|EVENTINIT]] 事件
  当你通过 [[yii\db\ActiveRecord::find()|find()]] 方法查询数据时，每个AR实例都将有以下生命周期：

  constructor
  [[yii\db\ActiveRecord::init()|init()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTINIT|EVENTINIT]] 事件
  [[yii\db\ActiveRecord::afterFind()|afterFind()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTAFTERFIND|EVENTAFTERFIND]] 事件
  当通过 [[yii\db\ActiveRecord::save()|save()]] 方法写入或者更新数据时, 我们将获得如下生命周期：

  [[yii\db\ActiveRecord::beforeValidate()|beforeValidate()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTBEFOREVALIDATE|EVENTBEFOREVALIDATE]] 事件
  [[yii\db\ActiveRecord::afterValidate()|afterValidate()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTAFTERVALIDATE|EVENTAFTERVALIDATE]] 事件
  [[yii\db\ActiveRecord::beforeSave()|beforeSave()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTBEFOREINSERT|EVENTBEFOREINSERT]] 或 [[yii\db\ActiveRecord::EVENTBEFOREUPDATE|EVENTBEFOREUPDATE]] 事件
  执行实际的数据写入或更新
  [[yii\db\ActiveRecord::afterSave()|afterSave()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTAFTERINSERT|EVENTAFTERINSERT]] 或 [[yii\db\ActiveRecord::EVENTAFTERUPDATE|EVENTAFTERUPDATE]] 事件
  最后，当调用 [[yii\db\ActiveRecord::delete()|delete()]] 删除数据时, 我们将获得如下生命周期：

  [[yii\db\ActiveRecord::beforeDelete()|beforeDelete()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTBEFOREDELETE|EVENTBEFOREDELETE]] 事件
  执行实际的数据删除
  [[yii\db\ActiveRecord::afterDelete()|afterDelete()]]: 会触发一个 [[yii\db\ActiveRecord::EVENTAFTERDELETE|EVENTAFTERDELETE]] 事件
  查询关联的数据
  使用 AR 方法也可以查询数据表的关联数据（如，选出表A的数据可以拉出表B的关联数据）。 有了 AR， 返回的关联数据连接就像连接关联主表的 AR 对象的属性一样。

  建立关联关系后，通过 $customer->orders 可以获取 一个 Order 对象的数组，该数组代表当前客户对象的订单集。

  定义关联关系使用一个可以返回 [[yii\db\ActiveQuery]] 对象的 getter 方法， [[yii\db\ActiveQuery]]对象有关联上下文的相关信息，因此可以只查询关联数据。

  例如：

  ```php class Customer extends \yii\db\ActiveRecord { public function getOrders() { // 客户和订单通过 Order.customerid -> id 关联建立一对多关系 return $this->hasMany(Order::className(), ['customerid' => 'id']); } }

  class Order extends \yii\db\ActiveRecord { // 订单和客户通过 Customer.id -> customerid 关联建立一对一关系 public function getCustomer() { return $this->hasOne(Customer::className(), ['id' => 'customerid']); } } ```

  以上使用了 [[yii\db\ActiveRecord::hasMany()]] 和 [[yii\db\ActiveRecord::hasOne()]] 方法。 以上两例分别是关联数据多对一关系和一对一关系的建模范例。 如，一个客户有很多订单，一个订单只归属一个客户。 两个方法都有两个参数并返回 [[yii\db\ActiveQuery]] 对象。

  $class：关联模型类名，它必须是一个完全合格的类名。
  $link: 两个表的关联列，应为键值对数组的形式。 数组的键是 $class 关联表的列名， 而数组值是关联类 $class 的列名。 基于表外键定义关联关系是最佳方法。
  建立关联关系后，获取关联数据和获取组件属性一样简单， 执行以下相应getter方法即可：

  php // 取得客户的订单 $customer = Customer::findOne(1); $orders = $customer->orders; // $orders 是 Order 对象数组

  以上代码实际执行了以下两条 SQL 语句：

  sql SELECT * FROM customer WHERE id=1; SELECT * FROM order WHERE customer_id=1;

  Tip: 再次用表达式 $customer->orders将不会执行第二次 SQL 查询， SQL 查询只在该表达式第一次使用时执行。 数据库访问只返回缓存在内部前一次取回的结果集，如果你想查询新的 关联数据，先要注销现有结果集：unset($customer->orders);。

  有时候需要在关联查询中传递参数，如不需要返回客户全部订单， 只需要返回购买金额超过设定值的大订单， 通过以下getter方法声明一个关联数据 bigOrders ：

  php class Customer extends \yii\db\ActiveRecord { public function getBigOrders($threshold = 100) { return $this->hasMany(Order::className(), ['customer_id' => 'id']) ->where('subtotal > :threshold', [':threshold' => $threshold]) ->orderBy('id'); } }

  hasMany() 返回 [[yii\db\ActiveQuery]] 对象，该对象允许你通过 [[yii\db\ActiveQuery]] 方法定制查询。

  如上声明后，执行$customer->bigOrders 就返回 总额大于100的订单。使用以下代码更改设定值：

  php $orders = $customer->getBigOrders(200)->all();

  Note: 关联查询返回的是 [[yii\db\ActiveQuery]] 的实例，如果像特性（如类属性）那样连接关联数据， 返回的结果是关联查询的结果，即 [[yii\db\ActiveRecord]] 的实例， 或者是数组，或者是 null ，取决于关联关系的多样性。如，$customer->getOrders() 返回 ActiveQuery 实例，而 $customer->orders 返回Order 对象数组 （如果查询结果为空则返回空数组）。

  中间关联表
  有时，两个表通过中间表关联，定义这样的关联关系， 可以通过调用 [[yii\db\ActiveQuery::via()|via()]] 方法或 [[yii\db\ActiveQuery::viaTable()|viaTable()]] 方法来定制 [[yii\db\ActiveQuery]] 对象 。

  举例而言，如果 order 表和 item 表通过中间表 order_item 关联起来， 可以在 Order 类声明 items 关联关系取代中间表：

  php class Order extends \yii\db\ActiveRecord { public function getItems() { return $this->hasMany(Item::className(), ['id' => 'item_id']) ->viaTable('order_item', ['order_id' => 'id']); } }

  两个方法是相似的，除了 [[yii\db\ActiveQuery::via()|via()]] 方法的第一个参数是使用 AR 类中定义的关联名。 以上方法取代了中间表，等价于：

  ```php class Order extends \yii\db\ActiveRecord { public function getOrderItems() { return $this->hasMany(OrderItem::className(), ['order_id' => 'id']); }

  public function getItems()
  {
      return $this->hasMany(Item::className(), ['id' => 'item_id'])
          ->via('orderItems');
  }
  } ```

  延迟加载和即时加载（又称惰性加载与贪婪加载）
  如前所述，当你第一次连接关联对象时， AR 将执行一个数据库查询 来检索请求数据并填充到关联对象的相应属性。 如果再次连接相同的关联对象，不再执行任何查询语句，这种数据库查询的执行方法称为“延迟加载”。如：

  php // SQL executed: SELECT * FROM customer WHERE id=1 $customer = Customer::findOne(1); // SQL executed: SELECT * FROM order WHERE customer_id=1 $orders = $customer->orders; // 没有 SQL 语句被执行 $orders2 = $customer->orders; //取回上次查询的缓存数据

  延迟加载非常实用，但是，在以下场景中使用延迟加载会遭遇性能问题：

  ```php // SQL executed: SELECT * FROM customer LIMIT 100 $customers = Customer::find()->limit(100)->all();

  foreach ($customers as $customer) { // SQL executed: SELECT * FROM order WHERE customer_id=... $orders = $customer->orders; // ...处理 $orders... } ```

  假设数据库查出的客户超过100个，以上代码将执行多少条 SQL 语句？ 101 条！第一条 SQL 查询语句取回100个客户，然后， 每个客户要执行一条 SQL 查询语句以取回该客户的所有订单。

  为解决以上性能问题，可以通过调用 [[yii\db\ActiveQuery::with()]] 方法使用即时加载解决。

  ```php // SQL executed: SELECT * FROM customer LIMIT 100; // SELECT * FROM orders WHERE customer_id IN (1,2,...) $customers = Customer::find()->limit(100) ->with('orders')->all();

  foreach ($customers as $customer) { // 没有 SQL 语句被执行 $orders = $customer->orders; // ...处理 $orders... } ```

  如你所见，同样的任务只需要两个 SQL 语句。

  须知：通常，即时加载 N 个关联关系而通过 via() 或者 viaTable() 定义了 M 个关联关系， 将有 1+M+N 条 SQL 查询语句被执行：一个查询取回主表行数， 一个查询给每一个 (M) 中间表，一个查询给每个 (N) 关联表。 注意:当用即时加载定制 select() 时，确保连接 到关联模型的列都被包括了，否则，关联模型不会载入。如：

  php $orders = Order::find()->select(['id', 'amount'])->with('customer')->all(); // $orders[0]->customer 总是空的，使用以下代码解决这个问题： $orders = Order::find()->select(['id', 'amount', 'customer_id'])->with('customer')->all();

  有时候，你想自由的自定义关联查询，延迟加载和即时加载都可以实现，如：

  ```php $customer = Customer::findOne(1); // 延迟加载: SELECT * FROM order WHERE customer_id=1 AND subtotal>100 $orders = $customer->getOrders()->where('subtotal>100')->all();

  // 即时加载: SELECT * FROM customer LIMIT 100 // SELECT * FROM order WHERE customer_id IN (1,2,...) AND subtotal>100 $customers = Customer::find()->limit(100)->with([ 'orders' => function($query) { $query->andWhere('subtotal>100'); }, ])->all(); ```

  逆关系
  关联关系通常成对定义，如：Customer 可以有个名为 orders 关联项， 而 Order 也有个名为customer 的关联项：

  ```php class Customer extends ActiveRecord { .... public function getOrders() { return $this->hasMany(Order::className(), ['customer_id' => 'id']); } }

  class Order extends ActiveRecord { .... public function getCustomer() { return $this->hasOne(Customer::className(), ['id' => 'customer_id']); } } ```

  如果我们执行以下查询，可以发现订单的 customer 和 找到这些订单的客户对象并不是同一个。连接 customer->orders 将触发一条 SQL 语句 而连接一个订单的 customer 将触发另一条 SQL 语句。

  php // SELECT * FROM customer WHERE id=1 $customer = Customer::findOne(1); // 输出 "不相同" // SELECT * FROM order WHERE customer_id=1 // SELECT * FROM customer WHERE id=1 if ($customer->orders[0]->customer === $customer) { echo '相同'; } else { echo '不相同'; }

  为避免多余执行的后一条语句，我们可以为 customer或 orders 关联关系定义相反的关联关系，通过调用 [[yii\db\ActiveQuery::inverseOf()|inverseOf()]] 方法可以实现。

  php class Customer extends ActiveRecord { .... public function getOrders() { return $this->hasMany(Order::className(), ['customer_id' => 'id'])->inverseOf('customer'); } }

  现在我们同样执行上面的查询，我们将得到：

  php // SELECT * FROM customer WHERE id=1 $customer = Customer::findOne(1); // 输出相同 // SELECT * FROM order WHERE customer_id=1 if ($customer->orders[0]->customer === $customer) { echo '相同'; } else { echo '不相同'; }

  以上我们展示了如何在延迟加载中使用相对关联关系， 相对关系也可以用在即时加载中：

  php // SELECT * FROM customer // SELECT * FROM order WHERE customer_id IN (1, 2, ...) $customers = Customer::find()->with('orders')->all(); // 输出相同 if ($customers[0]->orders[0]->customer === $customers[0]) { echo '相同'; } else { echo '不相同'; }

  Note: 相对关系不能在包含中间表的关联关系中定义。 即是，如果你的关系是通过[[yii\db\ActiveQuery::via()|via()]] 或 [[yii\db\ActiveQuery::viaTable()|viaTable()]]方法定义的， 就不能调用[[yii\db\ActiveQuery::inverseOf()]]方法了。

  JOIN 类型关联查询
  使用关系数据库时，普遍要做的是连接多个表并明确地运用各种 JOIN 查询。 JOIN SQL语句的查询条件和参数，使用 [[yii\db\ActiveQuery::joinWith()]] 可以重用已定义关系并调用 而不是使用 [[yii\db\ActiveQuery::join()]] 来实现目标。

  php // 查找所有订单并以客户 ID 和订单 ID 排序，并贪婪加载 "customer" 表 $orders = Order::find()->joinWith('customer')->orderBy('customer.id, order.id')->all(); // 查找包括书籍的所有订单，并以 `INNER JOIN` 的连接方式即时加载 "books" 表 $orders = Order::find()->innerJoinWith('books')->all();

  以上，方法 [[yii\db\ActiveQuery::innerJoinWith()|innerJoinWith()]] 是访问 INNER JOIN 类型的 [[yii\db\ActiveQuery::joinWith()|joinWith()]] 的快捷方式。

  可以连接一个或多个关联关系，可以自由使用查询条件到关联查询， 也可以嵌套连接关联查询。如：

  php // 连接多重关系 // 找出24小时内注册客户包含书籍的订单 $orders = Order::find()->innerJoinWith([ 'books', 'customer' => function ($query) { $query->where('customer.created_at > ' . (time() - 24 * 3600)); } ])->all(); // 连接嵌套关系：连接 books 表及其 author 列 $orders = Order::find()->joinWith('books.author')->all();

  代码背后， Yii 先执行一条 JOIN SQL 语句把满足 JOIN SQL 语句查询条件的主要模型查出， 然后为每个关系执行一条查询语句， bing填充相应的关联记录。

  [[yii\db\ActiveQuery::joinWith()|joinWith()]] 和 [[yii\db\ActiveQuery::with()|with()]] 的区别是 前者连接主模型类和关联模型类的数据表来检索主模型， 而后者只查询和检索主模型类。 检索主模型

  由于这个区别，你可以应用只针对一条 JOIN SQL 语句起效的查询条件。 如，通过关联模型的查询条件过滤主模型，如前例， 可以使用关联表的列来挑选主模型数据，

  当使用 [[yii\db\ActiveQuery::joinWith()|joinWith()]] 方法时可以响应没有歧义的列名。 In the above examples, we use item.id and order.id to disambiguate the id column references 因为订单表和项目表都包括 id 列。

  当连接关联关系时，关联关系默认使用即时加载。你可以 通过传参数 $eagerLoading 来决定在指定关联查询中是否使用即时加载。

  默认 [[yii\db\ActiveQuery::joinWith()|joinWith()]] 使用左连接来连接关联表。 你也可以传 $joinType 参数来定制连接类型。 你也可以使用 [[yii\db\ActiveQuery::innerJoinWith()|innerJoinWith()]]。

  以下是 INNER JOIN 的简短例子：

  php // 查找包括书籍的所有订单，但 "books" 表不使用即时加载 $orders = Order::find()->innerJoinWith('books', false)->all(); // 等价于： $orders = Order::find()->joinWith('books', false, 'INNER JOIN')->all();

  有时连接两个表时，需要在关联查询的 ON 部分指定额外条件。 这可以通过调用 [[yii\db\ActiveQuery::onCondition()]] 方法实现：

  php class User extends ActiveRecord { public function getBooks() { return $this->hasMany(Item::className(), ['owner_id' => 'id'])->onCondition(['category_id' => 1]); } }

  在上面， [[yii\db\ActiveRecord::hasMany()|hasMany()]] 方法回传了一个 [[yii\db\ActiveQuery]] 对象， 当你用 [[yii\db\ActiveQuery::joinWith()|joinWith()]] 执行一条查询时，取决于正被调用的是哪个 [[yii\db\ActiveQuery::onCondition()|onCondition()]]， 返回 category_id 为 1 的 items

  当你用 [[yii\db\ActiveQuery::joinWith()|joinWith()]] 进行一次查询时，“on-condition”条件会被放置在相应查询语句的 ON 部分， 如：

  php // SELECT user.* FROM user LEFT JOIN item ON item.owner_id=user.id AND category_id=1 // SELECT * FROM item WHERE owner_id IN (...) AND category_id=1 $users = User::find()->joinWith('books')->all();

  注意：如果通过 [[yii\db\ActiveQuery::with()]] 进行贪婪加载或使用惰性加载的话，则 on 条件会被放置在对应 SQL语句的 WHERE 部分。 因为，此时此处并没有发生 JOIN 查询。比如：

  php // SELECT * FROM user WHERE id=10 $user = User::findOne(10); // SELECT * FROM item WHERE owner_id=10 AND category_id=1 $books = $user->books;

  关联表操作
  AR 提供了下面两个方法用来建立和解除两个关联对象之间的关系：

  [[yii\db\ActiveRecord::link()|link()]]
  [[yii\db\ActiveRecord::unlink()|unlink()]]
  例如，给定一个customer和order对象，我们可以通过下面的代码使得customer对象拥有order对象：

  php $customer = Customer::findOne(1); $order = new Order(); $order->subtotal = 100; $customer->link('orders', $order);

  [[yii\db\ActiveRecord::link()|link()]] 调用上述将设置 customer_id 的顺序是 $customer 的主键值，然后调用 [[yii\db\ActiveRecord::save()|save()]] 要将顺序保存到数据库中。

  作用域
  当你调用[[yii\db\ActiveRecord::find()|find()]] 或 [[yii\db\ActiveRecord::findBySql()|findBySql()]]方法时，将会返回一个[[yii\db\ActiveQuery|ActiveQuery]]实例。之后，你可以调用其他查询方法，如 [[yii\db\ActiveQuery::where()|where()]]，[[yii\db\ActiveQuery::orderBy()|orderBy()]], 进一步的指定查询条件。

  有时候你可能需要在不同的地方使用相同的查询方法。如果出现这种情况，你应该考虑定义所谓的作用域。作用域是本质上要求一组的查询方法来修改查询对象的自定义查询类中定义的方法。 之后你就可以像使用普通方法一样使用作用域。

  只需两步即可定义一个作用域。首先给你的model创建一个自定义的查询类，在此类中定义的所需的范围方法。例如，给Comment模型创建一个 CommentQuery类，然后在CommentQuery类中定义一个active()的方法为作用域，像下面的代码：

  ```php namespace app\models;

  use yii\db\ActiveQuery;

  class CommentQuery extends ActiveQuery { public function active($state = true) { $this->andWhere(['active' => $state]); return $this; } } ```

  重点:

  类必须继承 yii\db\ActiveQuery (或者是其他的 ActiveQuery ，比如 yii\mongodb\ActiveQuery)。
  必须是一个public类型的方法且必须返回 $this 实现链式操作。可以传入参数。
  检查 [[yii\db\ActiveQuery]] 对于修改查询条件是非常有用的方法。
  其次，覆盖[[yii\db\ActiveRecord::find()]] 方法使其返回自定义的查询对象而不是常规的[[yii\db\ActiveQuery|ActiveQuery]]。对于上述例子，你需要编写如下代码：

  ```php namespace app\models;

  use yii\db\ActiveRecord;

  class Comment extends ActiveRecord { /** * @inheritdoc * @return CommentQuery */ public static function find() { return new CommentQuery(getcalledclass()); } } ```

  就这样，现在你可以使用自定义的作用域方法了：

  php $comments = Comment::find()->active()->all(); $inactiveComments = Comment::find()->active(false)->all();

  你也能在定义的关联里使用作用域方法，比如：

  ```php class Post extends \yii\db\ActiveRecord { public function getActiveComments() { return $this->hasMany(Comment::className(), ['post_id' => 'id'])->active();

  }
  } ```

  或者在执行关联查询的时候使用（on-the-fly 是啥？）：

  php $posts = Post::find()->with([ 'comments' => function($q) { $q->active(); } ])->all();

  默认作用域
  如果你之前用过 Yii 1.1 就应该知道默认作用域的概念。一个默认的作用域可以作用于所有查询。你可以很容易的通过重写[[yii\db\ActiveRecord::find()]]方法来定义一个默认作用域，例如：

  php public static function find() { return parent::find()->where(['deleted' => false]); }

  注意，你之后所有的查询都不能用 [[yii\db\ActiveQuery::where()|where()]]，但是可以用 [[yii\db\ActiveQuery::andWhere()|andWhere()]] 和 [[yii\db\ActiveQuery::orWhere()|orWhere()]]，他们不会覆盖掉默认作用域。（译注：如果你要使用默认作用域，就不能在 xxx::find()后使用where()方法，你必须使用andXXX()或者orXXX()系的方法，否则默认作用域不会起效果，至于原因，打开where()方法的代码一看便知）

  事务操作
  当执行几个相关联的数据库操作的时候

  TODO: FIXME: WIP, TBD, https://github.com/yiisoft/yii2/issues/226

  , [[yii\db\ActiveRecord::afterSave()|afterSave()]], [[yii\db\ActiveRecord::beforeDelete()|beforeDelete()]] and/or [[yii\db\ActiveRecord::afterDelete()|afterDelete()]] 生命周期周期方法(life cycle methods 我觉得这句翻译成“模板方法”会不会更好点？)。开发者可以通过重写[[yii\db\ActiveRecord::save()|save()]]方法然后在控制器里使用事务操作，严格地说是似乎不是一个好的做法 （召回"瘦控制器 / 肥模型"基本规则）。

  这些方法在这里(如果你不明白自己实际在干什么，请不要使用他们)，Models：

  ```php class Feature extends \yii\db\ActiveRecord { // ...

  public function getProduct()
  {
      return $this->hasOne(Product::className(), ['id' => 'product_id']);
  }
  }

  class Product extends \yii\db\ActiveRecord { // ...

  public function getFeatures()
  {
      return $this->hasMany(Feature::className(), ['product_id' => 'id']);
  }
  } ```

  重写 [[yii\db\ActiveRecord::save()|save()]] 方法：

  php class ProductController extends \yii\web\Controller { public function actionCreate() { // FIXME: TODO: WIP, TBD } } (译注：我觉得上面应该是原手册里的bug)

  在控制器层使用事务：

  php class ProductController extends \yii\web\Controller { public function actionCreate() { // FIXME: TODO: WIP, TBD } }

  作为这些脆弱方法的替代，你应该使用原子操作方案特性。

  ```php class Feature extends \yii\db\ActiveRecord { // ...

  public function getProduct()
  {
      return $this->hasOne(Product::className(), ['product_id' => 'id']);
  }

  public function scenarios()
  {
      return [
          'userCreates' => [
              'attributes' => ['name', 'value'],
              'atomic' => [self::OP_INSERT],
          ],
      ];
  }
  }

  class Product extends \yii\db\ActiveRecord { // ...

  public function getFeatures()
  {
      return $this->hasMany(Feature::className(), ['id' => 'product_id']);
  }

  public function scenarios()
  {
      return [
          'userCreates' => [
              'attributes' => ['title', 'price'],
              'atomic' => [self::OP_INSERT],
          ],
      ];
  }

  public function afterValidate()
  {
      parent::afterValidate();
      // FIXME: TODO: WIP, TBD
  }

  public function afterSave($insert)
  {
      parent::afterSave($insert);
      if ($this->getScenario() === 'userCreates') {
          // FIXME: TODO: WIP, TBD
      }
  }
  } ```

  Controller里的代码将变得很简洁：

  php class ProductController extends \yii\web\Controller { public function actionCreate() { // FIXME: TODO: WIP, TBD } }

  控制器非常简洁：

  php class ProductController extends \yii\web\Controller { public function actionCreate() { // FIXME: TODO: WIP, TBD } }

  乐观锁（Optimistic Locks）
  TODO

  被污染属性
  当你调用[[yii\db\ActiveRecord::save()|save()]]用于保存活动记录(Active Record)实例时,只有被污染的属性才会被保存。一个属性是否认定为被污染取决于它的值自从最后一次从数据库加载或者最近一次保存到数据库后到现在是否被修改过。注意:无论活动记录(Active Record)是否有被污染属性，数据验证始终会执行。

  活动记录(Active Record)会自动维护一个污染数据列表。它的工作方式是通过维护一个较旧属性值版本，并且将它们与最新的进行比较。你可以通过调用[[yii\db\ActiveRecord::getDirtyAttributes()]]来获取当前的污染属性。你也可以调用[[yii\db\ActiveRecord::markAttributeDirty()]]来显示的标记一个属性为污染属性。

  如果你对最近一次修改前的属性值感兴趣，你可以调用[[yii\db\ActiveRecord::getOldAttributes()|getOldAttributes()]] 或 [[yii\db\ActiveRecord::getOldAttribute()|getOldAttribute()]]。

  另见
  模型（Model）
  [[yii\db\ActiveRecord]]
*** 数据库迁移（Migrations）: 在团体开发中对你的数据库使用版本控制
*** Sphinx
*** Redis
*** MongoDB
*** ElasticSearch
** 接收用户数据（Getting Data from Users）
*** 创建表单（Creating Forms）
*** 输入验证（Validating Input）
*** 文件上传（Uploading Files）
*** 收集列表输入（Collecting Tabular Input）
*** 多模型同时输入（Getting Data for Multiple Models）
** 显示数据（Displaying Data）
*** 格式化输出数据（Data Formatting）
*** 分页（Pagination）
*** 排序（Sorting）
*** 数据提供器（Data Providers）
*** 数据小部件（Data Widgets）
*** 操作客户端脚本（Working with Client Scripts）
*** 主题（Theming）
** 安全（Security）
*** 概述（Overview）
*** 认证（Authentication）
*** 授权（Authorization）
*** 处理密码（Working with Passwords）
*** 加密（Cryptography）
*** 视图安全（Views security）
*** 客户端认证（Auth Clients）
*** 安全领域的最佳实践（Best Practices）
** 缓存（Caching）
*** 概述（Overview）
*** 数据缓存（Data Caching）
*** 片段缓存（Fragment Caching）
*** 分页缓存（Page Caching）
*** HTTP 缓存（HTTP Caching）
** RESTful Web 服务
*** 快速入门（Quick Start）
*** 资源（Resources）
*** 控制器（Controllers）
*** 路由（Routing）
*** 格式化响应（Response Formatting）
*** 授权验证（Authentication）
*** 速率限制（Rate Limiting）
*** 版本化（Versioning）
*** 错误处理（Error Handling）
** 开发工具（Development Tools）
*** 调试工具栏和调试器（Debug Toolbar and Debugger）
*** 使用 Gii 生成代码（Generating Code using Gii）
*** TBD 生成 API 文档（Generating API Documentation）
** 测试（Testing）
*** 概述（Overview）
*** 搭建测试环境（Testing environment setup）
*** 单元测试（Unit Tests）
*** 功能测试（Functional Tests）
*** 验收测试（Acceptance Tests）
*** 测试夹具（Fixtures）
** 高级专题（Special Topics）
*** 高级应用模版（Advanced Project Template）
*** 从头构建自定义模版（Building Application from Scratch）
*** 控制台命令（Console Commands）
*** 核心验证器（Core Validators）
*** 国际化（Internationalization）
*** 收发邮件（Mailing）
*** 性能优化（Performance Tuning）
*** 共享主机环境（Shared Hosting Environment）
*** 模板引擎（Template Engines）
*** 集成第三方代码（Working with Third-Party Code）
** 小部件（Widgets）
   小部件是在[视图]中使用的可重用单元，使用面向对象方式创建复杂和可配置用户界面单元。

   例如，日期选择器小部件可生成一个精致的允许用户选择日期的日期选择器，
你只需要在视图中插入如下代码：
#+BEGIN_SRC php
<?php
use yii\jui\DatePicker;
?>
<?= DatePicker::widget(['name' => 'date']) ?>

#+END_SRC

Yii提供许多优秀的小部件，比如[[yii\widgets\ActiveForm]], [[yii\widgets\Menu]],
[jQuery UI widgets], [Twitter Bootstrap widgets]。
接下来介绍小部件的基本知识，如果你想了解某个小部件请参考对应的类API文档。

*** 使用小部件 <span id="using-widgets"></span>

小部件基本上在[views]中使用，在视图中可调用 [[yii\base\Widget::widget()]] 方法使用小部件。
该方法使用 [配置] 数组初始化小部件并返回小部件渲染后的结果。
例如如下代码插入一个日期选择器小部件，它配置为使用俄罗斯语，输入框内容为`$model`的`from_date`属性值。

#+BEGIN_SRC php
<?php
use yii\jui\DatePicker;
?>
<?= DatePicker::widget([
    'model' => $model,
    'attribute' => 'from_date',
    'language' => 'ru',
    'clientOptions' => [
        'dateFormat' => 'yy-mm-dd',
    ],
]) ?>

#+END_SRC

一些小部件可在[[yii\base\Widget::begin()]] 和 [[yii\base\Widget::end()]] 调用中使用数据内容。
例如如下代码使用[[yii\widgets\ActiveForm]]小部件生成一个登录表单，
小部件会在`begin()` 和0 `end()`执行处分别生成`<form>`的开始标签和结束标签，中间的任何代码也会被渲染。

#+BEGIN_SRC php
<?php
use yii\widgets\ActiveForm;
use yii\helpers\Html;
?>

<?php $form = ActiveForm::begin(['id' => 'login-form']); ?>

    <?= $form->field($model, 'username') ?>

    <?= $form->field($model, 'password')->passwordInput() ?>

    <div class="form-group">
        <?= Html::submitButton('Login') ?>
    </div>

<?php ActiveForm::end(); ?>
#+END_SRC

注意和调用 [[yii\base\Widget::widget()]] 返回渲染结果不同，
调用 [[yii\base\Widget::begin()]] 方法返回一个可组建小部件内容的小部件实例。


*** 创建小部件 <span id="creating-widgets"></span>
    继承 [[yii\base\Widget]] 类并覆盖 [[yii\base\Widget::init()]] 和/或
    [[yii\base\Widget::run()]] 方法可创建小部件。通常`init()` 方法处理小部件属性，
    `run()` 方法包含小部件生成渲染结果的代码。
    渲染结果可在`run()`方法中直接"echoed"输出或以字符串返回。

    如下代码中`HelloWidget`编码并显示赋给`message` 属性的值，
    如果属性没有被赋值，默认会显示"Hello World"。

#+BEGIN_SRC php
namespace app\components;

use yii\base\Widget;
use yii\helpers\Html;

class HelloWidget extends Widget
{
    public $message;

    public function init()
    {
        parent::init();
        if ($this->message === null) {
            $this->message = 'Hello World';
        }
    }

    public function run()
    {
        return Html::encode($this->message);
    }
}
#+END_SRC

使用这个小部件只需在视图中简单使用如下代码:
#+BEGIN_SRC php

<?php
use app\components\HelloWidget;
?>
<?= HelloWidget::widget(['message' => 'Good morning']) ?>

#+END_SRC

以下是另一种可在`begin()` 和 `end()`调用中使用的`HelloWidget`，HTML编码内容然后显示。
#+BEGIN_SRC php

namespace app\components;

use yii\base\Widget;
use yii\helpers\Html;

class HelloWidget extends Widget
{
    public function init()
    {
        parent::init();
        ob_start();
    }

    public function run()
    {
        $content = ob_get_clean();
        return Html::encode($content);
    }
}
#+END_SRC

如上所示，PHP输出缓冲在`init()`启动，所有在`init()` 和 `run()`方法之间的输出内容都会被获取，并在`run()`处理和返回。

> Info: 当你调用 [[yii\base\Widget::begin()]] 时会创建一个新的小部件实例并在构造结束时调用`init()`方法，
  在`end()`时会调用`run()`方法并输出返回结果。

如下代码显示如何使用这种 `HelloWidget`:

```php
<?php
use app\components\HelloWidget;
?>
<?php HelloWidget::begin(); ?>

    content that may contain <tag>'s

<?php HelloWidget::end(); ?>
```

有时小部件需要渲染很多内容，一种更好的办法是将内容放入一个[视图](structure-views.md)文件，
然后调用[[yii\base\Widget::render()]]方法渲染该视图文件，例如：

```php
public function run()
{
    return $this->render('hello');
}
```

小部件的视图文件默认存储在`WidgetPath/views`目录，`WidgetPath`代表小部件类文件所在的目录。
假如上述示例小部件类文件在`@app/components`下，会渲染`@app/components/views/hello.php`视图文件。 You may override
可以覆盖[[yii\base\Widget::getViewPath()]]方法自定义视图文件所在路径。


## 最佳实践 <span id="best-practices"></span>

小部件是面向对象方式来重用视图代码。

创建小部件时仍需要遵循MVC模式，通常逻辑代码在小部件类，展示内容在[视图](structure-views.md)中。

小部件设计时应是独立的，也就是说使用一个小部件时候，可以直接丢弃它而不需要额外的处理。
但是当小部件需要外部资源如CSS, JavaScript, 图片等会比较棘手，
幸运的时候Yii提供 [资源包](structure-asset-bundles.md) 来解决这个问题。

当一个小部件只包含视图代码，它和[视图](structure-views.md)很相似，
实际上，在这种情况下，唯一的区别是小部件是可以重用类，视图只是应用中使用的普通PHP脚本。

*** 表格视图（GridView）: TBD 链接到 demo 页
*** 列表视图（ListView）: TBD 链接到 demo 页
*** 详情视图（DetailView）: TBD 链接到 demo 页
*** 活动表单（ActiveForm）: TBD 链接到 demo 页
*** Pjax: TBD 链接到 demo 页
*** 菜单（Menu）: TBD 链接到 demo 页
*** LinkPager: TBD 链接到 demo 页
*** LinkSorter: TBD 链接到 demo 页
*** Bootstrap 小部件（Bootstrap Widgets）
*** jQuery UI 小部件（jQuery UI Widgets）
** 助手类（Helpers） ¶
*** 助手一览（Overview）
*** Array 助手（ArrayHelper）
*** Html 助手（Html）
样式表和脚本
超链接
图片
列表

任何一个 web 应用程序会生成很多 HTMl 超文本标记。如果超文本标记是静态的， 那么将 PHP 和 HTML
混合在一个文件里 这种做法是非常高效的。但是，如果这些超文本标记是动态生成的，那么如果没有额外的辅助工具，
这个过程将会变得复杂。 Yii 通过 HTML 帮助类来提供生成超文本标记的方法。这个帮助类包含有一系列的用于处理通用的
 HTML 标签和其属性以及内容的静态方法。

注意：如果你的超文本标记接近静态的，那么最好是直接使用 HTML。 没有必要把所有的超文本标记都用 HTML 
辅助类来生成。

**** 基础
     由于通过字符串连接来生成动态的 HTML 会很容易变得凌乱，Yii提供了一系列的静态方法来操作标签配置并基于这些配置来创建对应的标签。

***** 生成标签
     生成一个标签的代码类似如下：
#+BEGIN_SRC php
<?= Html::tag('p', Html::encode($user->name), ['class' => 'username']) ?>
#+END_SRC

这个方法的第一个参数是标签名称。第二个是要装入到开始和结束标签间的内容。 注意到我们使用 Html::encode 。
那是因为内容不会被自动的转码以允许在有需要的时候嵌套 HTML。 第三个参数是一个 HTML 配置数组，或者换言之，
标签属性。在这个数组中，数组的下标是属性名称， 比如 class，href 或者 target，而值则是对应属性的值。

以上代码会生成如下 HTML ：
#+BEGIN_SRC html
  <p class="username">samdark</p>
#+END_SRC

如果你只需要开启一个标签或者关闭一个标签，你可以使用 Html::beginTag() 和 Html::endTag() 方法。

标签属性（ Options ）在 Html 帮助类很多方法和大量的小部件中都有使用。在这些情况下， 有一些额外的处理我们需要知道：

如果一个值为 null ，那么对应的属性将不会被渲染。
如果是布尔类型的值的属性，将会被当做 布尔属性 来处理。
属性的值将会用 yii\helpers\Html::encode() 方法进行 HTML 转码处理。
如果一个属性的值是一个数组，那么它将会被如下处理：

如果这个属性是一个如 yii\helpers\Html::$dataAttributes 所列的数据属性， 比如 data 或者 ng，一系列的属性列表将会被渲染，每个代表值数组中的元素。 比如： 'data' => ['id' => 1, 'name' => 'yii'] 将会生成 data-id="1" data-name="yii"； 'data' => ['params' => ['id' => 1, 'name' => 'yii'], 'status' => 'ok'] 生成 data-params='{"id":1,"name":"yii"}' data-status="ok"。 注意后者 中，一个子数组被输出为 JSON 。
如果这个属性不是一个数据属性，那么值将会被 JSON-encoded。比如：['params' => ['id' => 1, 'name' => 'yii'] 生成 params='{"id":1,"name":"yii"}'。
生成 CSS 类和样式
当开始构造一个 HTML 标签的属性时，我们经常需要对默认的属性进行修改。 为了添加或者删除 CSS 类，你可以使用如下代码：

$options = ['class' => 'btn btn-default'];

if ($type === 'success') {
    Html::removeCssClass($options, 'btn-default');
    Html::addCssClass($options, 'btn-success');
}

echo Html::tag('div', 'Pwede na', $options);

// in case of $type of 'success' it will render
// <div class="btn btn-success">Pwede na</div>
基于同样的目的，针对 style 属性：

$options = ['class' => ['btn', 'btn-default']];

echo Html::tag('div', 'Save', $options);
// renders '<div class="btn btn-default">Save</div>'
While adding or removing classes you may use the array format as well:

$options = ['class' => 'btn'];

if ($type === 'success') {
    Html::addCssClass($options, ['btn-success', 'btn-lg']);
}

echo Html::tag('div', 'Save', $options);
// renders '<div class="btn btn-success btn-lg">Save</div>'
Html::addCssClass() prevents duplicating classes, so you don't need to worry that the same class may appear twice:

$options = ['class' => 'btn btn-default'];

Html::addCssClass($options, 'btn-default'); // class 'btn-default' is already present

echo Html::tag('div', 'Save', $options);
// renders '<div class="btn btn-default">Save</div>'
If the CSS class option is specified via the array format, you may use a named key to mark the logical purpose of the class. In this case, a class with the same key in the array format will be ignored in Html::addCssClass():

$options = [
    'class' => [
        'btn',
        'theme' => 'btn-default',
    ]
];

Html::addCssClass($options, ['theme' => 'btn-success']); // 'theme' key is already taken

echo Html::tag('div', 'Save', $options);
// renders '<div class="btn btn-default">Save</div>'
CSS styles can be setup in similar way using style attribute:

$options = ['style' => ['width' => '100px', 'height' => '100px']];

// gives style="width: 100px; height: 200px; position: absolute;"
Html::addCssStyle($options, 'height: 200px; position: absolute;');

// gives style="position: absolute;"
Html::removeCssStyle($options, ['width', 'height']);
当使用 yii\helpers\Html::addCssStyle() 方法时，你可以指定一个和 CSS 属性相关的名值对的数组， 也可以直接是一个类似 width: 100px; height: 200px; 的字符串。这些格式将会自动的被 yii\helpers\Html::cssStyleFromArray() 和yii\helpers\Html::cssStyleToArray() 方法进行转换。方法 yii\helpers\Html::removeCssStyle() 接收一个包含要被移除的属性数组作为参数。 如果只想移除一个属性，你可以直接传递一个字符串。

标签内容的转码和解码
为了让内容能够正确安全的显示，一些 HTML 特殊字符应该被转码。在 PHP 中， 这个操作由 htmlspecialchars 和 htmlspecialchars_decode 完成。 直接使用这些方法的问题是，你总是需要指定转码所需的额外标志。由于标志一般总是不变的，而内容转码的过程为了避免一些安全问题， 需要和应用的默认过程匹配， Yii 提供了两个简单可用的对 PHP 原生方法的封装：

$userName = Html::encode($user->name);
echo $userName;

$decodedUserName = Html::decode($userName);
表单
处理表单标签是大量的重复性劳动并且易错。因此， Yii 也提供了一系列的方法来辅助处理表单标签。

注意： 考虑在处理 models 以及需要验证的情形下，使用 ActiveForm 组件。

创建表单
表单可以用类似如下代码，使用 yii\helpers\Html::beginForm() 方法开启：

<?= Html::beginForm(['order/update', 'id' => $id], 'post', ['enctype' => 'multipart/form-data']) ?>
方法的第一个参数为表单将要被提交的 URL 地址。它可以以 Yii 路由的形式被指定，并由 yii\helpers\Url::to() 来接收处理。 第二个参数是使用的方法，默认为 post 方法。第三个参数为表单标签的属性数组。在上面的例子中， 我们把编码 POST 请求中的表单数据的方式改为 multipart/form-data。 如果是上传文件，这个调整是必须的。

关闭表单标签非常简单：

<?= Html::endForm() ?>
按钮
你可以用如下代码生成按钮：

<?= Html::button('Press me!', ['class' => 'teaser']) ?>
<?= Html::submitButton('Submit', ['class' => 'submit']) ?>
<?= Html::resetButton('Reset', ['class' => 'reset']) ?>
上述三个方法的第一个参数为按钮的标题，第二个是标签属性。标题默认没有进行转码，如果标题是由终端用输入的， 那么请自行用 yii\helpers\Html::encode() 方法进行转码。

输入栏
input 相关的方法有两组：以 active 开头的被称为 active inputs， 另一组则不以其开头。active inputs 依据指定的模型和属性获取数据， 而普通 input 则是直接指定数据。

一般用法如下：

type, input name, input value, options
<?= Html::input('text', 'username', $user->name, ['class' => $username]) ?>

type, model, model attribute name, options
<?= Html::activeInput('text', $user, 'name', ['class' => $username]) ?>
如果你知道 input 类型，更方便的做法是使用以下快捷方法：

yii\helpers\Html::buttonInput()
yii\helpers\Html::submitInput()
yii\helpers\Html::resetInput()
yii\helpers\Html::textInput(), yii\helpers\Html::activeTextInput()
yii\helpers\Html::hiddenInput(), yii\helpers\Html::activeHiddenInput()
yii\helpers\Html::passwordInput() / yii\helpers\Html::activePasswordInput()
yii\helpers\Html::fileInput(), yii\helpers\Html::activeFileInput()
yii\helpers\Html::textarea(), yii\helpers\Html::activeTextarea()
Radios 和 checkboxes 在方法的声明上有一点点不同：

<?= Html::radio('agree', true, ['label' => 'I agree']);
<?= Html::activeRadio($model, 'agree', ['class' => 'agreement'])

<?= Html::checkbox('agree', true, ['label' => 'I agree']);
<?= Html::activeCheckbox($model, 'agree', ['class' => 'agreement'])
Dropdown list 和 list box 将会如下渲染：

<?= Html::dropDownList('list', $currentUserId, ArrayHelper::map($userModels, 'id', 'name')) ?>
<?= Html::activeDropDownList($users, 'id', ArrayHelper::map($userModels, 'id', 'name')) ?>

<?= Html::listBox('list', $currentUserId, ArrayHelper::map($userModels, 'id', 'name')) ?>
<?= Html::activeListBox($users, 'id', ArrayHelper::map($userModels, 'id', 'name')) ?>
第一个参数是 input 的名称，第二个是当前选中的值，第三个则是一个下标为列表值， 值为列表标签的名值对数组。

如果你需要使用多项选择， checkbox list 应该能够符合你的需求：

<?= Html::checkboxList('roles', [16, 42], ArrayHelper::map($roleModels, 'id', 'name')) ?>
<?= Html::activeCheckboxList($user, 'role', ArrayHelper::map($roleModels, 'id', 'name')) ?>
否则，用 radio list ：

<?= Html::radioList('roles', [16, 42], ArrayHelper::map($roleModels, 'id', 'name')) ?>
<?= Html::activeRadioList($user, 'role', ArrayHelper::map($roleModels, 'id', 'name')) ?>
Labels 和 Errors
如同 inputs 一样，Yii 也提供了两个方法用于生成表单 label 。 带 ative 方法用于从 model 中取数据，另外一个则是直接接收数据。

<?= Html::label('User name', 'username', ['class' => 'label username']) ?>
<?= Html::activeLabel($user, 'username', ['class' => 'label username'])
为了从一个或者一组 model 中显示表单的概要错误，你可以使用如下方法：

<?= Html::errorSummary($posts, ['class' => 'errors']) ?>
为了显示单个错误：

<?= Html::error($post, 'title', ['class' => 'error']) ?>
Input 的名和值
Yii 提供了方法用于从 model 中获取 input 的名称，ids，值。这些主要用于内部调用， 但是有时候你也需要使用它们：

// Post[title]
echo Html::getInputName($post, 'title');

// post-title
echo Html::getInputId($post, 'title');

// my first post
echo Html::getAttributeValue($post, 'title');

// $post->authors[0]
echo Html::getAttributeValue($post, '[0]authors[0]');
在上面的例子中，第一个参数为模型，而第二个参数是属性表达式。 在最简单的表单中，这个属性表达式就是属性名称，但是在一些多行输入的时候， 它也可以是属性名以数组下标前缀或者后缀（也可能是同时）。

[0]content 代表多行输入时第一个 model 的 content 属性的数据值。
dates[0] 代表 dates 属性的第一个数组元素。
[0]dates[0] 代表多行输入时第一个 model 的 dates 属性的第一个数组元素。
为了获取一个没有前缀或者后缀的属性名称，我们可以如下做：

// dates
echo Html::getAttributeName('dates[0]');
样式表和脚本
Yii 提供两个方法用于生成包含内联样式和脚本代码的标签。

<?= Html::style('.danger { color: #f00; }') ?>

Gives you

<style>.danger { color: #f00; }</style>


<?= Html::script('alert("Hello!");', ['defer' => true]);

Gives you

<script defer>alert("Hello!");</script>
如果你想要外联 css 样式文件，可以如下做：

<?= Html::cssFile('@web/css/ie5.css', ['condition' => 'IE 5']) ?>

generates

<!--[if IE 5]>
    <link href="http://example.com/css/ie5.css" />
<![endif]-->
第一个参数是 URL。第二个参数是标签属性数组。比普通的标签配置项额外多出的是，你可以指定：

condition 来让 <link 被条件控制注释包裹（ IE hacker ）。 希望你在未来不再需要条件控制注释。
noscript 可以被设置为 true ，这样 <link就会被 <noscript>包裹，如此那么这段代码只有在浏览器不支持 JavaScript 或者被用户禁用的时候才会被引入进来。
为了外联 JavaScript 文件：

<?= Html::jsFile('@web/js/main.js') ?>
这个方法的第一个参数同 CSS 一样用于指定外联链接。第二个参数是一个标签属性数组。 同 cssFile 一样，你可以指定 condtion 配置项。

超链接
有一个方法可以用于便捷的生成超链接：

<?= Html::a('Profile', ['user/view', 'id' => $id], ['class' => 'profile-link']) ?>
第一个参数是超链接的标题。它不会被转码，所以如果是用户输入数据， 你需要使用 Html::encode() 方法进行转码。第二个参数是 <a 标签的 href 属性的值。 关于该参数能够接受的更详细的数据值，请参阅 Url::to()。第三个参数是标签的属性数组。

在需要的时候，你可以用如下代码生成 mailto 链接：

<?= Html::mailto('Contact us', 'admin@example.com') ?>
图片
为了生成图片标签，你可以如下做：

<?= Html::img('@web/images/logo.png', ['alt' => 'My logo']) ?>

generates

<img src="http://example.com/images/logo.png" alt="My logo" />
除了 aliases 之外，第一个参数可以接受 路由，查询，URLs。 同 Url::to() 一样。

列表
无序列表可以如下生成：

<?= Html::ul($posts, ['item' => function($item, $index) {
    return Html::tag(
        'li',
        $this->render('post', ['item' => $item]),
        ['class' => 'post']
    );
}]) ?>
有序列表请使用 Html::ol() 方法。
*** Url 助手（Url）
**** 
  在使用Yii2时，如果启用了美化的Url，则访问http://www.aaa.com ，不能直接显示http://www.aaa.com/site/index.html内容。 这时候需要配置rules  
  'urlManager' => [   
                          'enablePrettyUrl' => true,  
                          'showScriptName' => false,  
                          'enableStrictParsing' => true,  
                          'suffix' => ".html",  
                          'rules' => [ '' => 'site/index', // 如果没有这里，则访问域名不能直接打开默认Action  
                          ]   
                  ]   
  当然，如果使用的默认控制器、动作不是site/index，那还要设置这里：

  $config = [   
          'id' => 'basic',  
          
          //'defaultRoute'=>'site/index',  
* 第一次问候（Saying Hello）
  如何创建一个动作去响应 请求，
  如何创建一个视图去构造响应 内容，
  以及一个应用如何分派请求给动作。
  
** 创建动作 控制器
#+BEGIN_SRC php
  <?php
  namespace app\controllers;
  use yii\web\Controller;

  class SiteController extends Controller
  {
      // ...现存的代码...

      public function actionSay($message = 'Hello')
      {
          return $this->render('say', ['message' => $message]);
      }
  }
#+END_SRC

** 创建视图
视图是你用来生成响应内容的脚本。为了说 “Hello”， 你需要创建一个 say 视图，以便显示从操作方法中传来的 message 参数。
#+BEGIN_SRC php
<?php
use yii\helpers\Html;
?>
<?= Html::encode($message) ?>
#+END_SRC

** 运行
访问页面： http://hostname/index.php?r=site/say&message=Hello+World
** 共用
   头部和尾部是因为 yii\web\Controller::render() 方法会自动把 say 视图执行的结果嵌入称为布局的文件中，
   本例中是 views/layouts/main.php。

* 使用 Forms（Working with Forms）
** 模型  
模型类 EntryForm 代表从用户那请求的数据， 该类如下所示并存储在 models/EntryForm.php 文件中。 
#+BEGIN_SRC php
<?php
namespace app\models;

use Yii;
use yii\base\Model;

class EntryForm extends Model
{
    public $name;
    public $email;

    public function rules()
    {
        return [
            [['name', 'email'], 'required'],
            ['email', 'email'],
        ];
    }
}
#+END_SRC

创建动作
#+BEGIN_SRC php
<?php
namespace app\controllers;

use Yii;
use yii\web\Controller;
use app\models\EntryForm;  //注意加上这个

class SiteController extends Controller
{
    // ...现存的代码...

    public function actionEntry()
    {
        $model = new EntryForm;

        if ($model->load(Yii::$app->request->post()) && $model->validate()) {
            // 验证 $model 收到的数据

            // 做些有意义的事 ...

            return $this->render('entry-confirm', ['model' => $model]);
        } else {
            // 无论是初始化显示还是数据验证错误
            return $this->render('entry', ['model' => $model]);
        }
    }
}
#+END_SRC

该操作首先创建了一个 EntryForm 对象。然后尝试从 $_POST 搜集用户提交的数据， 由 Yii 的 yii\web\Request::post() 
方法负责搜集。 如果模型被成功填充数据（也就是说用户已经提交了 HTML 表单）， 操作将调用 validate() 去确保用户提交的是有效数据。
信息：表达式 Yii::$app 代表应用实例，它是一个全局可访问的单例。 同时它也是一个服务定位器， 能提供 request，response，db 等等特定功能的组件。 
在上面的代码里就是使用 request 组件来访问应用实例收到的 $_POST 数据。

用户提交表单后，操作将会渲染一个名为 entry-confirm 的视图去确认用户输入的数据。 如果没填表单就提交，或数据包含错误（译者：如 email 格式不对），
 entry 视图将会渲染输出，连同表单一起输出的还有验证错误的详细信息。

注意：在这个简单例子里我们只是呈现了有效数据的确认页面。 实践中你应该考虑使用 refresh() 或 redirect() 去避免表单重复提交问题。

创建视图
最后创建两个视图文件 entry-confirm 和 entry。 他们会被刚才创建的 entry 操作渲染。
entry-confirm 视图简单地显示提交的 name 和 email 数据。视图文件应该保存在 views/site/entry-confirm.php。
#+BEGIN_SRC 
<?php
use yii\helpers\Html;
?>
<p>You have entered the following information:</p>

<ul>
    <li><label>Name</label>: <?= Html::encode($model->name) ?></li>
    <li><label>Email</label>: <?= Html::encode($model->email) ?></li>
</ul>
#+END_SRC
entry 视图显示一个 HTML 表单。视图文件应该保存在 views/site/entry.php。
#+BEGIN_SRC 
<?php
use yii\helpers\Html;
use yii\widgets\ActiveForm;
?>
<?php $form = ActiveForm::begin(); ?>

    <?= $form->field($model, 'name') ?>

    <?= $form->field($model, 'email') ?>

    <div class="form-group">
        <?= Html::submitButton('Submit', ['class' => 'btn btn-primary']) ?>
    </div>

<?php ActiveForm::end(); ?>
#+END_SRC
视图使用了一个功能强大的小部件 ActiveForm 去生成 HTML 表单。 其中的 begin() 和 end() 分别用来渲染表单的开始和关闭标签。
 在这两个方法之间使用了 field() 方法去创建输入框。 第一个输入框用于 “name”，第二个输入框用于 “email”。 之后使用 yii\helpers\Html::submitButton() 方法生成提交按钮。

尝试下
用浏览器访问下面的 URL 看它能否工作：

http://hostname/index.php?r=site/entry
你会看到一个包含两个输入框的表单的页面。每个输入框的前面都有一个标签指明应该输入的数据类型。 如果什么都不填就点击提交按钮，或填入格式不正确的 email 地址，
将会看到在对应的输入框下显示错误信息。

验证错误的表单

输入有效的 name 和 email 信息并提交后， 将会看到一个显示你所提交数据的确认页面。

输入数据的确认页
效果说明
你可能会好奇 HTML 表单暗地里是如何工作的呢， 看起来它可以为每个输入框显示文字标签， 而当你没输入正确的信息时又不需要刷新页面就能给出错误提示，似乎有些神奇。

是的，其实数据首先由客户端 JavaScript 脚本验证，然后才会提交给服务器通过 PHP 验证。 yii\widgets\ActiveForm
足够智能到把你在 EntryForm 模型中声明的验证规则转化成客户端 JavaScript 脚本去执行验证。 如果用户浏览器禁用了 JavaScript，
服务器端仍然会像 actionEntry() 方法里这样验证一遍数据。这保证了任何情况下用户提交的数据都是有效的。

警告：客户端验证是提高用户体验的手段。 无论它是否正常启用，服务端验证则都是必须的，请不要忽略它。

输入框的文字标签是 field() 方法生成的，内容就是模型中该数据的属性名。 例如模型中的 name 属性生成的标签就是 Name。

你可以在视图中自定义标签 按如下方法：

<?= $form->field($model, 'name')->label('自定义 Name') ?>
<?= $form->field($model, 'email')->label('自定义 Email') ?>
信息：Yii 提供了相当多类似的小部件去帮你生成复杂且动态的视图。 在后面你还会了解到自己写小部件是多么简单。 你可能会把自己的很多视图代码转化成小部件以提高重用，加快开发效率。

总结
本章节指南中你接触了 MVC 设计模式的每个部分。 学到了如何创建一个模型代表用户数据并验证它的有效性。

你还学到了如何从用户那获取数据并在浏览器上回显给用户。 这本来是开发应用的过程中比较耗时的任务， 好在 Yii 提供了强大的小部件让它变得如此简单。

在下一章节中，你将学习如何使用数据库，几乎每个应用都需要数据库。
* Databases
  使用数据库
准备数据库
配置数据库连接
创建活动记录
创建动作
创建视图
试运行
总结
本章节将介绍如何创建一个从数据表 country 中读取国家数据并显示出来的页面。 为了实现这个目标，你将会配置一个数据库连接， 创建一个活动记录类， 并且创建一个操作及一个视图。

贯穿整个章节，你将会学到：

配置一个数据库连接
定义一个活动记录类
使用活动记录从数据库中查询数据
以分页方式在视图中显示数据
请注意，为了掌握本章你应该具备最基本的数据库知识和使用经验。 尤其是应该知道如何创建数据库，如何通过数据库终端执行 SQL 语句。

准备数据库
首先创建一个名为 yii2basic 的数据库，应用将从这个数据库中读取数据。 你可以创建 SQLite，MySQL，PostregSQL，MSSQL 或 Oracle 数据库，Yii 内置多种数据库支持。简单起见，后面的内容将以 MySQL 为例做演示。

然后在数据库中创建一个名为 country 的表并插入简单的数据。可以执行下面的语句：

CREATE TABLE `country` (
  `code` CHAR(2) NOT NULL PRIMARY KEY,
  `name` CHAR(52) NOT NULL,
  `population` INT(11) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `country` VALUES ('AU','Australia',18886000);
INSERT INTO `country` VALUES ('BR','Brazil',170115000);
INSERT INTO `country` VALUES ('CA','Canada',1147000);
INSERT INTO `country` VALUES ('CN','China',1277558000);
INSERT INTO `country` VALUES ('DE','Germany',82164700);
INSERT INTO `country` VALUES ('FR','France',59225700);
INSERT INTO `country` VALUES ('GB','United Kingdom',59623400);
INSERT INTO `country` VALUES ('IN','India',1013662000);
INSERT INTO `country` VALUES ('RU','Russia',146934000);
INSERT INTO `country` VALUES ('US','United States',278357000);
此时便有了一个名为 yii2basic 的数据库，在这个数据库中有一个包含三个字段的数据表 country，表中有十行数据。

配置数据库连接
开始之前，请确保你已经安装了 PHP PDO 扩展和你所使用的数据库的 PDO 驱动（例如 MySQL 的 pdo_mysql）。 对于使用关系型数据库来讲，这是基本要求。

驱动和扩展安装可用后，打开 config/db.php 修改里面的配置参数对应你的数据库配置。 该文件默认包含这些内容：

<?php

return [
    'class' => 'yii\db\Connection',
    'dsn' => 'mysql:host=localhost;dbname=yii2basic',
    'username' => 'root',
    'password' => '',
    'charset' => 'utf8',
];
config/db.php 是一个典型的基于文件的配置工具。 这个文件配置了数据库连接 yii\db\Connection 的创建和初始化参数， 应用的 SQL 查询正是基于这个数据库。

上面配置的数据库连接可以在应用中通过 Yii::$app->db 表达式访问。

信息：config/db.php 将被包含在应用配置文件 config/web.php 中， 后者指定了整个应用如何初始化。 请参考配置章节了解更多信息。

如果想要使用 Yii 没有捆绑支持的数据库，你可以查看以下插件：

Informix
IBM DB2
Firebird
创建活动记录
创建一个继承自活动记录类的类 Country， 把它放在 models/Country.php 文件，去代表和读取 country 表的数据。

<?php

namespace app\models;

use yii\db\ActiveRecord;

class Country extends ActiveRecord
{
}
这个 Country 类继承自 yii\db\ActiveRecord。你不用在里面写任何代码。 只需要像现在这样，Yii 就能根据类名去猜测对应的数据表名。

信息：如果类名和数据表名不能直接对应， 可以覆写 tableName() 方法去显式指定相关表名。

使用 Country 类可以很容易地操作 country 表数据，就像这段代码：

use app\models\Country;

// 获取 country 表的所有行并以 name 排序
$countries = Country::find()->orderBy('name')->all();

// 获取主键为 “US” 的行
$country = Country::findOne('US');

// 输出 “United States”
echo $country->name;

// 修改 name 为 “U.S.A.” 并在数据库中保存更改
$country->name = 'U.S.A.';
$country->save();
信息：活动记录是面向对象、功能强大的访问和操作数据库数据的方式。你可以在活动记录章节了解更多信息。 除此之外你还可以使用另一种更原生的被称做数据访问对象的方法操作数据库数据。

创建动作
为了向最终用户显示国家数据，你需要创建一个操作。相比之前小节掌握的在 site 控制器中创建操作， 在这里为所有和国家有关的数据新建一个控制器更加合理。 新控制器名为 CountryController，并在其中创建一个 index 操作， 如下：

<?php

namespace app\controllers;

use yii\web\Controller;
use yii\data\Pagination;
use app\models\Country;

class CountryController extends Controller
{
    public function actionIndex()
    {
        $query = Country::find();

        $pagination = new Pagination([
            'defaultPageSize' => 5,
            'totalCount' => $query->count(),
        ]);

        $countries = $query->orderBy('name')
            ->offset($pagination->offset)
            ->limit($pagination->limit)
            ->all();

        return $this->render('index', [
            'countries' => $countries,
            'pagination' => $pagination,
        ]);
    }
}
把上面的代码保存在 controllers/CountryController.php 文件中。

index 操作调用了活动记录 Country::find() 方法，去生成查询语句并从 country 表中取回所有数据。 为了限定每个请求所返回的国家数量，查询在 yii\data\Pagination 对象的帮助下进行分页。 Pagination 对象的使命主要有两点：

为 SQL 查询语句设置 offset 和 limit 从句， 确保每个请求只需返回一页数据（本例中每页是 5 行）。
在视图中显示一个由页码列表组成的分页器， 这点将在后面的段落中解释。
在代码末尾，index 操作渲染一个名为 index 的视图， 并传递国家数据和分页信息进去。

创建视图
在 views 目录下先创建一个名为 country 的子目录。 这个目录存储所有由 country 控制器渲染的视图。在 views/country 目录下 创建一个名为 index.php 的视图文件，内容如下：

<?php
use yii\helpers\Html;
use yii\widgets\LinkPager;
?>
<h1>Countries</h1>
<ul>
<?php foreach ($countries as $country): ?>
    <li>
        <?= Html::encode("{$country->name} ({$country->code})") ?>:
        <?= $country->population ?>
    </li>
<?php endforeach; ?>
</ul>

<?= LinkPager::widget(['pagination' => $pagination]) ?>
这个视图包含两部分用以显示国家数据。第一部分遍历国家数据并以无序 HTML 列表渲染出来。 第二部分使用 yii\widgets\LinkPager 去渲染从操作中传来的分页信息。 小部件 LinkPager 显示一个分页按钮的列表。 点击任何一个按钮都会跳转到对应的分页。

试运行
浏览器访问下面的 URL 看看能否工作：

http://hostname/index.php?r=country/index
国家列表

首先你会看到显示着五个国家的列表页面。在国家下面，你还会看到一个包含四个按钮的分页器。 如果你点击按钮 “2”，将会跳转到显示另外五个国家的页面， 也就是第二页记录。如果观察仔细点你还会看到浏览器的 URL 变成了：

http://hostname/index.php?r=country/index&page=2
在这个场景里，Pagination 提供了为数据结果集分页的所有功能：

首先 Pagination 把 SELECT 的子查询 LIMIT 5 OFFSET 0 数据表示成第一页。 因此开头的五条数据会被取出并显示。
然后小部件 LinkPager 使用 Pagination::createUrl() 方法生成的 URL 去渲染翻页按钮。 URL 中包含必要的参数 page 才能查询不同的页面编号。
如果你点击按钮 “2”，将会发起一个路由为 country/index 的新请求。 Pagination 接收到 URL 中 的 page 参数把当前的页码设为 2。 新的数据库请求将会以 LIMIT 5 OFFSET 5 查询并显示。
总结
本章节中你学到了如何使用数据库。你还学到了如何取出并使用 yii\data\Pagination 和 yii\widgets\LinkPager 显示数据。

下一章中你会学到如何使用 Yii 中强大的代码生成器 Gii， 去帮助你实现一些常用的功能需求， 例如增查改删（CRUD）数据表中的数据。 事实上你之前所写的代码全部都可以由 Gii 自动生成。
* 用 Gii 生成代码（Generating Code with Gii）
  本章将介绍如何使用 Gii 去自动生成 Web 站点常用功能的代码。使用 Gii 生成代码非常简单， 只要按照 Gii 页面上的介绍输入正确的信息即可。

贯穿本章节，你将会学到：

在你的应用中开启 Gii
使用 Gii 去生成活动记录类
使用 Gii 去生成数据表操作的增查改删（CRUD）代码
自定义 Gii 生成的代码
开始 Gii
Gii 是 Yii 中的一个模块。 可以通过配置应用的 yii\base\Application::modules 属性开启它。通常来讲在 config/web.php 文件中会有以下配置代码：

$config = [ ... ];

if (YII_ENV_DEV) {
    $config['bootstrap'][] = 'gii';
    $config['modules']['gii'] = [
        'class' => 'yii\gii\Module',
    ];
}
这段配置表明，如果当前是开发环境， 应用会包含 gii 模块，模块类是 yii\gii\Module。

如果你检查应用的入口脚本 web/index.php， 将看到这行代码将 YII_ENV_DEV 设为 true：

defined('YII_ENV') or define('YII_ENV', 'dev');
鉴于这行代码的定义，应用处于开发模式下，按照上面的配置会打开 Gii 模块。你可以直接通过 URL 访问 Gii：

http://hostname/index.php?r=gii
信息：如果你通过本机以外的机器访问 Gii，请求会被出于安全原因拒绝。 你可以配置 Gii 为其添加允许访问的 IP 地址：

'gii' => [
    'class' => 'yii\gii\Module',
    'allowedIPs' => ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // 按需调整这里
],
Gii

生成活动记录类
选择 “Model Generator” （点击 Gii 首页的链接）去生成活动记录类。并像这样填写表单：

Table Name: country
Model Class: Country
模型生成器

然后点击 “Preview” 按钮。你会看到 models/Country.php 被列在将要生成的文件列表中。可以点击文件名预览内容。

如果你已经创建过同样的文件，使用 Gii 会覆写它， 点击文件名旁边的 diff 能查看现有文件与将要 生成的文件的内容区别。

模型生成器预览

想要覆写已存在文件，选中 “overwrite” 下的复选框然后点击 “Generator”。如果是新文件，只点击 “Generator” 就好。

接下来你会看到一个包含已生成文件的说明页面。如果生成过程中覆写过文件， 还会有一条信息说明代码是重新生成覆盖的。

生成 CRUD 代码
CRUD 代表增，查，改，删操作，这是绝大多数 Web 站点常用的数据处理方式。选择 Gii 中的 “CRUD Generator” （点击 Gii 首页的链接）去创建 CRUD 功能。本例 “country” 中需要这样填写表单：

Model Class: app\models\Country
Search Model Class: app\models\CountrySearch
Controller Class: app\controllers\CountryController
CRUD 生成器

然后点击 “Preview” 按钮。你会看到下述将要生成的文件列表。

CRUD 生成器预览

如果你之前创建过 controllers/CountryController.php 和 views/country/index.php 文件（在指南的使用数据库章节）， 选中 “overwrite” 下的复选框覆写它们（之前的文件没能全部支持 CRUD）。

试运行
用浏览器访问下面的 URL 查看生成代码的运行：

http://hostname/index.php?r=country/index
可以看到一个栅格显示着从数据表中读取的国家数据。支持在列头对数据进行排序， 输入筛选条件进行筛选。

可以浏览详情，编辑，或删除栅格中的每个国家。 还可以点击栅格上方的 “Create Country” 按钮通过表单创建新国家。

国家的数据栅格

编辑一个国家

下面列出由 Gii 生成的文件，以便你研习功能和实现， 或修改它们。

控制器：controllers/CountryController.php
模型：models/Country.php 和 models/CountrySearch.php
视图：views/country/*.php
信息：Gii 被设计成高度可定制和可扩展的代码生成工具。 使用它可以大幅提高应用开发速度。 请参考 Gii 章节了解更多内容。

总结
本章学习了如何使用 Gii 去生成为数据表中 数据实现完整 CRUD 功能的代码。
* 小部件
** table  k
   /**
 * 该组件的作用主要是以表格的形式快速呈现数据.
 * 如下是一个基本的应用方式：
 *
 * ```php
 * $query = User::find();
 * $html = Table::widget([
 *     'query' => $query,
 *     'columns' => [
 *         ['type' => 'checkbox'],
 *         'id',
 *         'user.name' => ['sort' => true, 'value' => function ($value, $key) {}, 'search' => ['header' => '名称']],
 *         'state' => ['type' => 'select', 'items' => ['User', 'getStateMap'], 'search' => true],
 *         ['type' => ['edit' => 'edit-one', 'view', 'delete', 'reset']]
 *         // ...
 *     ],
 *     'searchColumns' => [
 *         'id',
 *         'name' => 'select', //指定搜索框类型，select表示下拉型，如果存在 $modelClass, 则会去对应的模型中寻找 get{field}Map()
 *         'email' => ['header' => 'EMAIL', 'type' => 'radio', 'items' => [$object, 'mapMethod']]
 *         // ...
 *     ]
 * ])
 * ```
 * 更多场景中，是使用 yii\db\Query 对象来进行查询，为方便更多情况的应用，该组件已集成进 common\traits\QueryTrait 中，以下是一个集成后的使用例子：
 * 
 * ```php
 * $query = User::find();
 * $html = $query->getTable([
 *     ['type' => 'checkbox'],
 *         'id',
 *         'user.name' => ['sort' => true, 'value' => function ($value, $key) {}, 'search' => ['header' => '名称']],
 *         'state' => ['type' => 'select', 'items' => ['User', 'getStateMap'], 'search' => true],
 *         ['type' => ['edit' => 'edit-one', 'view', 'delete', 'reset']]
 *         // ...
 *     ], [
 *     'searchColumns' => [
 *         'id',
 *         'name' => 'select', //指定搜索框类型，select表示下拉型，如果存在 $modelClass, 则会去对应的模型中寻找 get{field}Map()
 *         'email' => ['header' => 'EMAIL', 'type' => 'radio', 'items' => [$object, 'mapMethod']]
 *         // ...
 *     ]
 * ]);
 * ```
 * 
 * 必须传入的参数：$query 或 $data, 优先考虑传入 $query
 *
 * 其他主要参数说明：
 * 1.$modelClass or $model（当传入 $query 时，将会对这2个参数自动赋值）:
 * （1）可以获取到所有的关联表信息
 * （2）字段的格式化方法将会从对应模型中去寻找 get{$field}Value() 类型的方法
 * （3）表格列标题将会自动从对应模型中 attributeLabels() 去寻找
 * （4）自动识别主键字段，否则主键字段默认为id，根据实际情况必须做出手动传参调整
 * 2.$columns: 对列表显示的列进行设置，如果不传入将会获取 $query 的 model 的所有属性或 $data 的所有列
 * （1）当设置了 `type => 'select'`, 可以设置 `items => `'string'`|`callable`, 来设置下拉型修改的内容
 * （2）当设置了 `type => ['edit', 'view', ...]`, 表示设置了操作栏，内置了如下操作：'edit', 'view', 'delete', 'reset'
 *     'edit': 在操作栏中会添加一个编辑按钮，点击会出现弹窗，弹窗的链接默认为当前控制器的 actionEdit()
 *     'view': 在操作栏中会添加一个查看按钮，点击会出现弹窗，弹窗的链接默认为当前控制器的 actionView()
 *     'delete': 在操作栏中会添加一个删除按钮，点击会出现一个确认删除框
 *     'reset': 表示列表的列设置功能
 * （3） 当设置了 `search => true|[options], 可以直接快捷创建搜索框
 * 3.$searchColumns: 如果设置了该项，将会出现搜索栏
 * 4.$count（当传入 $query 时，该项将会自动赋值）: 会输出该列表的总计条目数
 * 5.$key: 当传入 $query 时，将会自动判断主键，当传入 $data 时，默认为 id，需手动传值来改变
 *
 * 新特性：
 * 1.静态资源的自动加载机制，如js、css、image将在使用到的情况下将自行载入
 * 2.规范自定义的配置，现在通过可回调的参数类型，达到动态配置的效果
 * 3.整个组件可通过模板自行调整布局
 * 4.模型关系的自动关联，现在将会自动寻找关联关系，获取各模型的标签和回调方法
 * 5.操作栏不再是内置的了，而是像普通的栏位一样可以被配置
 *
 * 当使用 $query 时，请参考以下建议：
 * 1.当需要显示其他表的字段的时，如果 $query 调用了 with() 或 joinWith()，则 $columns 配置时可以直接使用 `alias`.`field` 格式进行输出
 * 2.为正确使用排序功能，则当传入的是 $query 时，则必须使用 joinWith() 进行表的关联
 * 3.为更好使用搜索功能，请确保 $query 是通过 \common\components\ARModel::search() 获得的，因为这将自动处理大部分的搜索条件设置
 *
 * 当使用 $data 时，以下几点需要注意：
 * 1.所有列的名字不能使用别名，只能直接使用字段名
 * 2.如果不设置 $modelClass, 诸如单元格的快捷修改等功能无法使用
 *
 * 其他注意事项：
 * 1.开发时不建议直接开启列设置功能，因为有可能在调整显示的列时出现错乱现象
 * 2.当启用列设置功能时，建议字段栏的设置中，`type => 'checkbox'` 放在第一列，`type => []` 放在最后一列，否则可能导致该两列在设置会消失的情况
 * 
 * @author ChisWill
 
* 开发环境
  入口设置：
在web/index.php中：


测试环境：

[html] view plain copy
defined('YII_DEBUG') or define('YII_DEBUG', true);  
defined('YII_ENV') or define('YII_ENV', 'dev');  

生产环境：
[html] view plain copy
//defined('YII_DEBUG') or define('YII_DEBUG', true);  
defined('YII_ENV') or define('YII_ENV', 'prod');  


设置成生产环境后
/runtime/debug就不会写入debug等文件了，log中也不会继续写入文件
