* c-c++ layers
** 语法检查 flycheck with Clang
** 反汇编 disaster
** gtags
** 代码格式化 clang-format 
** Backends
   有3中后端可供选择
*** RTags ( Source code cross-referencer like ctags with a clang frontend)
    配置
    #+BEGIN_SRC emacs-lisp
  (setq-default dotspacemacs-configuration-layers
                '((c-c++ :variables
                         c-c++-backend 'rtags
                         c-c++-enable-rtags-completion nil)))
#+END_SRC

** 底部定义提示 semantic  
** 导航 cscope    还没用到
** 自动完成    当前有
1. c-c++-enable-clang-support 打开
2.ycmd 层打开
** 调试 realgud 还没用到
** 支持CMake 脚本构建
   CMake 是一个跨平台的，开源的构建系统（BuildSystem）。CMake 可以通过 CMakeLists.txt 文件来产生特定平台的标准的构建文件，
   例如：为 Unix 平台生成makefiles文件（使用GCC编译），为 Windows MSVC 生成 projects/workspaces（使用VS IDE编译）或Makefile文件（使用nmake编译）。
   CMake Hello World
   
   首先编写一个简单的程序（hello.cpp）：
   #include <stdio.h>
   int main()
   {
   printf("Hello World");
   return 0;
   }
   编写CMakeLists.txt，并与hello.cpp放在同一个目录。
   project(hello)
   cmake_minimum_required(VERSION 2.8)
   aux_source_directory(. DIR_SRCS)
   add_executable(hello ${DIR_SRCS})
   在 CMakeLists.txt 所在的目录下创建一个build目录，进入该目录执行 CMake 命令生成构建文件：
   打开Visual Studio 2008命令行提示窗口，它会执行加载一些VS的环境变量。
   mkdir build
   cd build
   cmake -G "NMake Makefiles" ../
   -- The C compiler identification is MSVC 15.0.30729.1
   -- The CXX compiler identification is MSVC15.0.30729.1
   ….
   -- Detecting CXX compiler ABI info
   -- Detecting CXX compiler ABI info - done
   -- Configuring done
   -- Generating done
   -- Build files have been written to:I:/cmake-hello/build
   这里使用的平台为 Windows 并且安装了 VS2008，CMake 为我们生成了 VS2008的构建文件Makefile，我们可以使用nmake来构建应用程序，执行：
   nmake
编译成功完成后，会当前目录下生成hello应用程序。
CMake基本语法

编写的CMakeLists.txt需要符合一定的语法规则，它主要由CMake命令组成。
1）注释的语法：在CMake中注释使用#字符开始到此行结束。
2）CMake命令：命令不区分大小写（参数会区分大小写），命令由命令、参数列表组成，参数之间使用空格进行分隔。使用一对双引号包括的字符串认为是一个参数。命令可以是一个内置命令（例如：project，add_executable等），也可以是一个用户定义的宏（macro）或者函数（function）。
3）数据类型：CMake的基本数据类型是字符串，一组字符串在一起称为列表（list），例如：
# 通过 set 命令构建一个 listVAR
set(VAR a b c)
使用语法 ${VariableName} 来访问名字为 VariableName 的变量的值（变量名区分大小写）。需要注意的是，即使在字符串中也可以使用 ${VariableName} 来访问变量的值：
set(VAR a b c)
# 输出 VAR = a;b;c
message("VAR = ${VAR}")
使用语法 $ENV{VariableName} 来访问环境变量的值（ENV{VariableName} 则表示环境变量本身）
# 输出环境变量 PATH 的值
message($ENV{PATH})
4）条件控制和循环结构
条件控制命令为 if 命令
if(expression)
    #...
elseif(expression2)
    #...
else()
    #...
endif()
对于 if(string) 来说：
如果 string 为（不区分大小写）1、ON、YES、TRUE、Y、非 0 的数则表示真
如果 string 为（不区分大小写）0、OFF、NO、FALSE、N、IGNORE、空字符串、以 -NOTFOUND 结尾的字符串则表示假
如果 string 不符合上面两种情况，则 string 被认为是一个变量的名字。变量的值为第二条所述的各值则表示假，否则表示真。
# 此策略（Policy）在 CMake2.8.0 才被引入
# 因此这里需要指定最低 CMake 版本为 2.8
cmake_minimum_required(VERSION 2.8)
set(YES 0)
 
# 输出 True
if(YES)
   message(True)
else()
   message(False)
endif()
 
# 输出 False
if(${YES})
   message(True)
else()
   message(False)
endif()
表达式中可以包含操作符，操作符包括：
一元操作符，例如：EXISTS、COMMAND、DEFINED 等
二元操作符，例如：EQUAL、LESS、GREATER、STRLESS、STRGREATER 等
NOT（非操作符）
AND（与操作符）、OR（或操作符）
操作符优先级：一元操作符 > 二元操作符 > NOT > AND、OR
常用操作符介绍：
if(NOT expression)
为真的前提是 expression 为假
if(expr1 AND expr2)
为真的前提是 expr1 和 expr2 都为真
if(expr1 OR expr2)
为真的前提是 expr1 或者 expr2 为真
if(COMMAND command-name)
为真的前提是存在 command-name 命令、宏或函数且能够被调用
if(EXISTS name)
为真的前提是存在 name 的文件或者目录（应该使用绝对路径）
if(file1 IS_NEWER_THAN file2)
为真的前提是 file1 比 file2 新或者 file1、file2 中有一个文件不存在（应该使用绝对路径）
if(IS_DIRECTORY directory-name)
为真的前提是 directory-name 表示的是一个目录（应该使用绝对路径）
if(variable|string MATCHES regex)
为真的前提是变量值或者字符串匹配 regex 正则表达式
if(variable|string LESS variable|string)
if(variable|string GREATER variable|string)
if(variable|string EQUAL variable|string)
为真的前提是变量值或者字符串为有效的数字且满足小于（大于、等于）的条件
if(variable|string STRLESS variable|string)
if(variable|string STRGREATERvariable|string)
if(variable|string STREQUALvariable|string)
为真的前提是变量值或者字符串以字典序满足小于（大于、等于）的条件
if(DEFINED variable)
为真的前提是 variable 表示的变量被定义了。
foreach 循环范例：
set(VAR a b c)
foreach(f ${VAR})
   message(${f})
endforeach()
while 循环范例：
set(VAR 5)
while(${VAR} GREATER 0)
   message(${VAR})
   math(EXPR VAR "${VAR} - 1")
endwhile()
5）函数和宏定义
函数会为变量创建一个局部作用域，而宏则使用全局作用域。范例：
# 定义一个宏 hello
macro(hello MESSAGE)
   message(${MESSAGE})
endmacro()
# 调用宏 hello
hello("hello world")
# 定义一个函数 hello
function(hello MESSAGE)
   message(${MESSAGE})
endfunction()
函数和宏可以通过命令 return() 返回，但是函数和宏的返回值必须通过参数传递出去。例如：
cmake_minimum_required(VERSION 2.8)
function(get_func RESULT)
    #RESULT 的值为实参的值，因此需要使用 ${RESULT}
    #这里使用 PARENT_SCOPE 是因为函数会构建一个局部作用域
   set(${RESULT} "Hello Function" PARENT_SCOPE)
endfunction()
 
macro(get_macro RESULT)
   set(${RESULT} "Hello Macro")
endmacro()
 
get_func(V1)
# 输出 Hello Function
message(${V1})
 
get_macro(V2)
# 输出 Hello Macro
message(${V2})
7）字符串的一些问题
字符串可跨行且支持转移字符，例如：
set(VAR "hello
world")
# 输出结果为：
# ${VAR} = hello
# world
message("\${VAR} = ${VAR}")
CMake常用命令

这里介绍一下常用的命令（CMake 2.8 的命令可以在此查询）：
http://www.cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands
1）project 命令
命令语法：project(<projectname> [languageName1 languageName2 … ] )
命令简述：用于指定项目的名称
使用范例：project(Main)
2）cmake_minimum_required命令
命令语法：cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])
命令简述：用于指定需要的 CMake 的最低版本
使用范例：cmake_minimum_required(VERSION 2.8)
3）aux_source_directory命令
命令语法：aux_source_directory(<dir> <variable>)
命令简述：用于将 dir 目录下的所有源文件的名字保存在变量 variable 中
使用范例：aux_source_directory(. DIR_SRCS)
4）add_executable 命令
命令语法：add_executable(<name> [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)
命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个可执行文件且命名为 name
使用范例：add_executable(Main ${DIR_SRCS})
5）add_library 命令
命令语法：add_library([STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1source2 … sourceN)
命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个库文件且命名为 name
使用范例：add_library(Lib ${DIR_SRCS})
6）add_dependencies 命令
命令语法：add_dependencies(target-name depend-target1 depend-target2 …)
命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。这里的目标必须是 add_executable、add_library、add_custom_target 命令创建的目标
7）add_subdirectory 命令
命令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
命令简述：用于添加一个需要进行构建的子目录
使用范例：add_subdirectory(Lib)
8）target_link_libraries命令
命令语法：target_link_libraries(<target> [item1 [item2 […]]][[debug|optimized|general] ] …)
命令简述：用于指定 target 需要链接 item1 item2 …。这里 target 必须已经被创建，链接的 item 可以是已经存在的 target（依赖关系会自动添加）
使用范例：target_link_libraries(Main Lib)
9）set 命令
命令语法：set(<variable> <value> [[CACHE <type><docstring> [FORCE]] | PARENT_SCOPE])
命令简述：用于设定变量 variable 的值为 value。如果指定了 CACHE 变量将被放入 Cache（缓存）中。
使用范例：set(ProjectName Main)
10）unset 命令
命令语法：unset(<variable> [CACHE])
命令简述：用于移除变量 variable。如果指定了 CACHE 变量将被从 Cache 中移除。
使用范例：unset(VAR CACHE)
11）message 命令
命令语法：message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…)
命令简述：用于输出信息
使用范例：message(“Hello World”)
12）include_directories 命令
命令语法：include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)
命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件
使用范例：include_directories(${PROJECT_SOURCE_DIR}/lib)
13）find_path 命令
命令语法：find_path(<VAR> name1 [path1 path2 …])
命令简述：用于查找包含文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 <VAR>-NOTFOUND。默认的情况下，VAR 会被保存在 Cache 中，这时候我们需要清除 VAR 才可以进行下一次查询（使用 unset 命令）。
使用范例：
find_path(LUA_INCLUDE_PATH lua.h${LUA_INCLUDE_FIND_PATH})
if(NOT LUA_INCLUDE_PATH)
   message(SEND_ERROR "Header file lua.h not found")
endif()
14）find_library 命令
命令语法：find_library(<VAR> name1 [path1 path2 …])
命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 <VAR>-NOTFOUND。一个类似的命令 link_directories 已经不太建议使用了
15）add_definitions 命令
命令语法：add_definitions(-DFOO -DBAR …)
命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义
使用范例：add_definitions(-D_UNICODE -DUNICODE)
16）execute_process 命令
命令语法：
execute_process(COMMAND <cmd1>[args1...]]
                  [COMMAND <cmd2>[args2...] [...]]
                  [WORKING_DIRECTORY<directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE<variable>]
                  [OUTPUT_VARIABLE<variable>]
                  [ERROR_VARIABLE<variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                 [OUTPUT_STRIP_TRAILING_WHITESPACE]
                 [ERROR_STRIP_TRAILING_WHITESPACE])
命令简述：用于执行一个或者多个外部命令。每一个命令的标准输出通过管道转为下一个命令的标准输入。WORKING_DIRECTORY 用于指定外部命令的工作目录，RESULT_VARIABLE 用于指定一个变量保存外部命令执行的结果，这个结果可能是最后一个执行的外部命令的退出码或者是一个描述错误条件的字符串，OUTPUT_VARIABLE 或者 ERROR_VARIABLE 用于指定一个变量保存标准输出或者标准错误，OUTPUT_QUIET 或者 ERROR_QUIET 用于忽略标准输出和标准错误。
使用范例：execute_process(COMMAND ls)
18）file 命令
命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）
使用范例：
# 目录的遍历
# GLOB 用于产生一个文件（目录）路径列表并保存在variable 中
# 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）
# 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径
# file(GLOB variable [RELATIVE path][globbing expressions]...)
 
# 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中
file(GLOB ALL_FILE_PATH ./*)
# 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中
# 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）
file(GLOB ALL_H_FILE RELATIVE${CMAKE_CURRENT_LIST_DIR} ${CMAKE_CURRENT_LIST_DIR}/*.h)
CMake常用变量

UNIX 如果为真，表示为 UNIX-like 的系统，包括 AppleOS X 和 CygWin
WIN32 如果为真，表示为 Windows 系统，包括 CygWin
APPLE 如果为真，表示为 Apple 系统
CMAKE_SIZEOF_VOID_P 表示 void* 的大小（例如为 4 或者 8），可以使用其来判断当前构建为 32 位还是 64 位
CMAKE_CURRENT_LIST_DIR 表示正在处理的CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）
CMAKE_ARCHIVE_OUTPUT_DIRECTORY 用于设置 ARCHIVE 目标的输出路径
CMAKE_LIBRARY_OUTPUT_DIRECTORY 用于设置 LIBRARY 目标的输出路径
CMAKE_RUNTIME_OUTPUT_DIRECTORY 用于设置 RUNTIME 目标的输出路径
构建类型

CMake 为我们提供了四种构建类型：
Debug
Release
MinSizeRel
RelWithDebInfo
如果使用 CMake 为 Windows MSVC 生成 projects/workspaces 那么我们将得到上述的 4 种解决方案配置。
 
如果使用 CMake 生成 Makefile 时，我们需要做一些不同的工作。CMake 中存在一个变量 CMAKE_BUILD_TYPE 用于指定构建类型，此变量只用于基于 make 的生成器。我们可以这样指定构建类型：
$ CMake -DCMAKE_BUILD_TYPE=Debug .
这里的 CMAKE_BUILD_TYPE 的值为上述的 4 种构建类型中的一种。
编译和链接标志

C 编译标志相关变量：
 
CMAKE_C_FLAGS
CMAKE_C_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
C++ 编译标志相关变量：
 
CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_C_FLAGS 或CMAKE_CXX_FLAGS 可以指定编译标志
CMAKE_C_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]或 CMAKE_CXX_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO] 则指定特定构建类型的编译标志，这些编译标志将被加入到 CMAKE_C_FLAGS 或 CMAKE_CXX_FLAGS 中去，例如，如果构建类型为 DEBUG，那么 CMAKE_CXX_FLAGS_DEBUG 将被加入到 CMAKE_CXX_FLAGS中去
 
链接标志相关变量：
CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
它们类似于编译标志相关变量
生成Debug和Release版本

在 Visual Studio 中我们可以生成 debug 版和 release 版的程序,使用 CMake 我们也可以达到上述效果。debug 版的项目生成的可执行文件需要有调试信息并且不需要进行优化,而 release 版的不需要调试信息但需要优化。这些特性在 gcc/g++ 中是通过编译时的参数来决定的,如果将优化程度调到最高需要设置参数-O3,最低是 -O0 即不做优化;添加调试信息的参数是 -g -ggdb ,如果不添加这个参数,调试信息就不会被包含在生成的二进制文件中。
CMake 中有一个变量CMAKE_BUILD_TYPE ,可以的取值是 Debug、Release、RelWithDebInfo 和 MinSizeRel。当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG中的字符串作为编译选项生成Makefile ,当这个变量值为 Release 的时候,工程会使用变量 CMAKE_CXX_FLAGS_RELEASE 和CMAKE_C_FLAGS_RELEASE 选项生成 Makefile。
示例：
PROJECT(main)
CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
SET(CMAKE_SOURCE_DIR .)
 
SET(CMAKE_CXX_FLAGS_DEBUG"$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
SET(CMAKE_CXX_FLAGS_RELEASE"$ENV{CXXFLAGS} -O3 -Wall")
 
AUX_SOURCE_DIRECTORY(. DIR_SRCS)
ADD_EXECUTABLE(main ${DIR_SRCS})
第 5 和 6 行设置了两个变量 CMAKE_CXX_FLAGS_DEBUG 和CMAKE_CXX_FLAGS_RELEASE, 这两个变量是分别用于 debug 和 release 的编译选项。编辑 CMakeList.txt 后需要执行 ccmake 命令生成 Makefile 。在进入项目的根目录,输入 "ccmake ." 进入一个图形化界面。
编译32位和64位程序

对于 Windows MSVC，我们可以设定 CMake Generator 来确定生成 Win32 还是 Win64 工程文件，例如：
 
# 用于生成 Visual Studio 10Win64 工程文件
CMake -G "Visual Studio 10 Win64"
# 用于生成 Visual Studio 10Win32 工程文件
CMake -G "Visual Studio 10"
我们可以通过 CMake --help 来查看当前平台可用的 Generator。
CMake .. -DUSE_32BITS=1
if(USE_32BITS)
 message(STATUS "Using 32bits")
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}-m32")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}-m32")
else()
endif(USE_32BITS)
对于 UNIX 和类 UNIX 平台，我们可以通过编译器标志（选项）来控制进行 32 位还是 64 位构建。
GCC命令行参数
32位版：加上 -m32 参数，生成32位的代码。
64位版：加上 -m64 参数，生成64位的代码。
debug版：加上 -g 参数，生成调试信息。
release版：加上 -static 参数，进行静态链接，使程序不再依赖动态库。加上 -O3 参数，进行最快速度优化。加上-DNDEBUG参数，定义NDEBUG宏，屏蔽断言。
当没有-m32或-m64参数时，一般情况下会生成跟操作系统位数一致的代码，但某些编译器存在例外，例如——
32位Linux下的GCC，默认是编译为32位代码。
64位Linux下的GCC，默认是编译为64位代码。
Window系统下的MinGW，总是编译为32位代码。因为MinGW只支持32位代码。
Window系统下的MinGW-w64（例如安装了TDM-GCC，选择MinGW-w64），默认是编译为64位代码，包括在32位的Windows系统下。
Makefile文件中的示例：
# [args] 生成模式. 0代表debug模式, 1代表release模式. makeRELEASE=1.
ifeq ($(RELEASE),0)
   CFLAGS += -g
else
    #release
   CFLAGS += -static -O3 -DNDEBUG
   LFLAGS += -static
endif
# [args] 程序位数. 32代表32位程序, 64代表64位程序, 其他默认. makeBITS=32.
ifeq ($(BITS),32)
   CFLAGS += -m32
   LFLAGS += -m32
else
    ifeq($(BITS),64)
       CFLAGS += -m64
       LFLAGS += -m64
   else
   endif
endif
多源文件目录的处理方式

我们在每一个源码目录中都会放置一个 CMakeLists.txt 文件。我们现在假定有这么一个工程：
HelloWorld
|
+------- Main.cpp
|
+------- CMakeLists.txt
|
+------- Lib
        |
        +------- Lib.cpp
        |
        +------- Lib.h
        |
        +------- CMakeLists.txt
这里 Lib 目录下的文件将被编译为一个库。首先，我们看一下 Lib 目录下的 CMakeLists.txt 文件：
aux_source_directory(. DIR_SRCS)
add_library(Lib ${DIR_SRCS})
然后，看一下 HelloWorld 目录下的 CMakeLists.txt 文件：
project(Main)
cmake_minimum_required(VERSION 2.8)
add_subdirectory(Lib)
aux_source_directory(. DIR_SRCS)
add_executable(Main ${DIR_SRCS})
target_link_libraries(Main Lib)
这里使用了 add_subdirectory 指定了需要进行构建的子目录，并且使用了 target_link_libraries 命令，表示 Main 可执行文件需要链接 Lib库。我们执行 CMake . 命令，首先会执行 HelloWorld 目录下的 CMakeLists.txt 中的命令，当执行到 add_subdirectory(Lib) 命令的时候会进入 Lib 子目录并执行其中的CMakeLists.txt 文件。
外部构建（out of source builds）

我们在 CMakeLists.txt 所在目录下执行 CMake . 会生成大量的文件，这些文件和我们的源文件混在一起不好管理，我们采用外部构建的方式来解决这个问题。以上面的 Hello World 工程来做解释：
在 HelloWorld 目录下建立一个build 目录（build目录可以建立在如何地方）
进入 build 目录并进行外部构建 CMake ..（语法为 CMake <CMakeLists.txt 的路径>，这里使用 CMake.. 表明了 CMakeLists.txt 在 Build 目录的父目录中）。这样 CMake 将在 Build 目录下生成文件。
** cmake
   ####cmake中一些预定义变量
   PROJECT_SOURCE_DIR 工程的根目录
   PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build
   CMAKE_INCLUDE_PATH 环境变量,非cmake变量
   CMAKE_LIBRARY_PATH 环境变量
CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径
CMAKE_CURRENT_BINARY_DIR target编译目录 使用ADD_SURDIRECTORY(src bin)可以更改此变量的值 SET(EXECUTABLE_OUTPUT_PATH <新路径>)并不会对此变量有影响,只是改变了最终目标文件的存储路径
CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径
CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行
CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径 SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake),然后可以用INCLUDE命令来调用自己的模块
EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置
LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置
PROJECT_NAME 返回通过PROJECT指令定义的项目名称
CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 用来控制IF ELSE语句的书写方式
系统信息

CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2
CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8
CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6
CMAKE_SYSTEM 系统名称,例如Linux-2.6.22
CAMKE_SYSTEM_NAME 不包含版本的系统名,如Linux
CMAKE_SYSTEM_VERSION 系统版本,如2.6.22
CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686
UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin
WIN32 在所有的win32平台为TRUE,包括cygwin
开关选项

BUILD_SHARED_LIBS 控制默认的库编译方式。如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）
CMAKE_C_FLAGS 设置C编译选项
CMAKE_CXX_FLAGS 设置C++编译选项
####cmake常用命令

#####基本语法规则：

cmake变量使用${}方式取值,但是在IF控制语句中是直接使用变量名

环境变量使用$ENV{}方式取值,使用SET(ENV{VAR} VALUE)赋值

指令(参数1 参数2...) 参数使用括弧括起,参数之间使用空格或分号分开。

以ADD_EXECUTABLE指令为例：
ADD_EXECUTABLE(hello main.c func.c)或者
ADD_EXECUTABLE(hello main.c;func.c)
指令是大小写无关的,参数和变量是大小写相关的。推荐你全部使用大写指令。

#####部分常用命令列表：

PROJECT PROJECT(projectname [CXX] [C] [Java]) 指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言

SET SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 定义变量(可以定义多个VALUE,如SET(SRC_LIST main.c util.c reactor.c))

MESSAGE MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display" ...) 向终端输出用户定义的信息或变量的值 SEND_ERROR, 产生错误,生成过程被跳过 STATUS, 输出前缀为--的信息 FATAL_ERROR, 立即终止所有cmake过程

ADD_EXECUTABLE ADD_EXECUTABLE(bin_file_name ${SRC_LIST}) 生成可执行文件

ADD_LIBRARY ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST) 生成动态库或静态库 SHARED 动态库 STATIC 静态库 MODULE 在使用dyld的系统有效,若不支持dyld,等同于SHARED EXCLUDE_FROM_ALL 表示该库不会被默认构建

SET_TARGET_PROPERTIES 设置输出的名称,设置动态库的版本和API版本

CMAKE_MINIMUM_REQUIRED CMAKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR]) 声明CMake的版本要求

ADD_SUBDIRECTORY ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL]) 向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置 EXCLUDE_FROM_ALL含义：将这个目录从编译过程中排除

SUBDIRS deprecated,不再推荐使用 (hello sample)相当于分别写ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)

INCLUDE_DIRECTORIES INCLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 ... ) 向工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径的后面。有如下两种方式可以控制搜索路径添加的位置：

CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面
通过AFTER或BEFORE参数,也可以控制是追加还是置前
LINK_DIRECTORIES LINK_DIRECTORIES(dir1 dir2 ...) 添加非标准的共享库搜索路径

TARGET_LINK_LIBRARIES TARGET_LINK_LIBRARIES(target lib1 lib2 ...) 为target添加需要链接的共享库

ADD_DEFINITIONS 想C/C++编译器添加-D定义 ADD_DEFINITIONS(-DENABLE_DEBUG -DABC),参数之间用空格分隔

ADD_DEPENDENCIES ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) 定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕

AUX_SOURCE_DIRECTORY AUX_SOURCE_DIRECTORY(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中 把当前目录下的所有源码文件名赋给变量DIR_HELLO_SRCS

EXEC_PROGRAM EXEC_PROGRAM(Executable [dir where to run] [ARGS <args>][OUTPUT_VARIABLE <var>] [RETURN_VALUE <value>]) 用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过OUTPUT_VARIABLE和RETURN_VALUE获取输出和返回值,如下示例

# 在src中运行ls命令,在src/CMakeLists.txt添加
EXEC_PROGRAM(ls ARGS "*.c" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)
IF (not LS_RVALUE)
    MESSAGE(STATUS "ls result: " ${LS_OUTPUT}) # 缩进仅为美观,语法无要求
ENDIF(not LS_RVALUE)
INCLUDE INCLUDE(file [OPTIONAL]) 用来载入CMakeLists.txt文件 INCLUDE(module [OPTIONAL])用来载入预定义的cmake模块 OPTIONAL参数的左右是文件不存在也不会产生错误 可以载入一个文件,也可以载入预定义模块（模块会在CMAKE_MODULE_PATH指定的路径进行搜索） 载入的内容将在处理到INCLUDE语句时直接执行

FIND_

FIND_FILE(<VAR> name path1 path2 ...) VAR变量代表找到的文件全路径,包含文件名

FIND_LIBRARY(<VAR> name path1 path2 ...) VAR变量代表找到的库全路径,包含库文件名

FIND_LIBRARY(libX X11 /usr/lib)
IF (NOT libx)
    MESSAGE(FATAL_ERROR "libX not found")
ENDIF(NOT libX)
FIND_PATH(<VAR> name path1 path2 ...) VAR变量代表包含这个文件的路径

FIND_PROGRAM(<VAR> name path1 path2 ...) VAR变量代表包含这个程序的全路径

FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets ...]]) 用来调用预定义在CMAKE_MODULE_PATH下的Find<name>.cmake模块,你也可以自己定义Find<name> 模块,通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录供工程使用

IF 语法：

IF (expression)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ELSE (expression)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDIF (expression) # 一定要有ENDIF与IF对应
IF (expression), expression不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真 IF (not exp), 与上面相反 IF (var1 AND var2) IF (var1 OR var2) IF (COMMAND cmd) 如果cmd确实是命令并可调用,为真 IF (EXISTS dir) IF (EXISTS file) 如果目录或文件存在,为真 IF (file1 IS_NEWER_THAN file2),当file1比file2新,或file1/file2中有一个不存在时为真,文件名需使用全路径 IF (IS_DIRECTORY dir) 当dir是目录时,为真 IF (DEFINED var) 如果变量被定义,为真 IF (var MATCHES regex) 此处var可以用var名,也可以用${var} IF (string MATCHES regex)

当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：
IF ("hello" MATCHES "ell")
    MESSAGE("true")
ENDIF ("hello" MATCHES "ell")
数字比较表达式 IF (variable LESS number) IF (string LESS number) IF (variable GREATER number) IF (string GREATER number) IF (variable EQUAL number) IF (string EQUAL number)

按照字母表顺序进行比较 IF (variable STRLESS string) IF (string STRLESS string) IF (variable STRGREATER string) IF (string STRGREATER string) IF (variable STREQUAL string) IF (string STREQUAL string)

一个小例子,用来判断平台差异：
IF (WIN32)
    MESSAGE(STATUS “This is windows.”)
ELSE (WIN32)
    MESSAGE(STATUS “This is not windows”)
ENDIF (WIN32)
上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,ELSE(WIN32)之类的语句很容易引起歧义。
可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
这时候就可以写成:
IF (WIN32)
ELSE ()
ENDIF ()
配合ELSEIF使用,可能的写法是这样:
IF (WIN32)
    #do something related to WIN32
ELSEIF (UNIX)
    #do something related to UNIX
ELSEIF(APPLE)
    #do something related to APPLE
ENDIF (WIN32)
WHILE 语法：

WHILE(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDWHILE(condition)
其真假判断条件可以参考IF指令

FOREACH FOREACH指令的使用方法有三种形式：

列表 语法：
FOREACH(loop_var arg1 arg2 ...)
      COMMAND1(ARGS ...)
      COMMAND2(ARGS ...)
    ...
ENDFOREACH(loop_var)
示例：

AUX_SOURCE_DIRECTORY(. SRC_LIST)
FOREACH(F ${SRC_LIST})
      MESSAGE(${F})
ENDFOREACH(F)
范围 FOREACH(loop_var RANGE total) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var)
从0到total以１为步进
FOREACH(VAR RANGE 10)
      MESSAGE(${VAR})
ENDFOREACH(VAR)
输出：
范围和步进 语法：
FOREACH(loop_var RANGE start stop [step])
       COMMAND1(ARGS ...)
       COMMAND2(ARGS ...)
       ...
ENDFOREACH(loop_var)
从start开始到stop结束,以step为步进, **注意：**直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。

FOREACH(A RANGE 5 15 3)
       MESSAGE(${A})
ENDFOREACH(A)
输出：
5
8
11
14
####cmake中如何生成动态库和静态库 参考ADD_LIBRARY和SET_TARGET_PROPERTIES用法 t3示例

####cmake中如何使用动态库和静态库（查找库的路径） 参考INCLUDE_DIRECTORIES, LINK_DIRECTORIES, TARGET_LINK_LIBRARIES用法 t4示例使用动态库或静态库 t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示) t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake) 注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分

####cmake中如何指定生成文件的输出路径

如上ADD_SUBDIRECTORY的时候指定目标二进制文件输出路径（推荐使用下面这种）
使用SET命令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量来指定最终的二进制文件的位置
SET(EXECUTABLE\_OUTPUT\_PATH ${PROJECT\_BINARY\_DIR}/bin)
SET(LIBRARY\_OUTPUT\_PATH ${PROJECT\_BINARY\_DIR}/lib)
上面的两条命令通常紧跟ADD_EXECUTABLE和ADD_LIBRARY,与其写在同一个CMakeLists.txt即可

####cmake中如何增加编译选项 使用变量CMAKE_C_FLAGS添加C编译选项 使用变量CMAKE_CXX_FLAGS添加C++编译选项 使用ADD_DEFINITION添加

####cmake中如何增加头文件路径 参考INCLUDE_DIRECTORIES命令用法

####cmake中如何在屏幕上打印信息 参考MESSAGE用法

####cmake中如何给变量赋值 参考SET和AUX_SOURCE_DIRECTORY用法

建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以
** CMake configuration
=cmake-ide= plugin works out of the box, but there are few useful configuration
options.

To configure project you need to create =.dir-locals.el= file. In case of using
make as CMake backend you can use =helm-make= to select required build target.

Here is a sample configuration. This configuration forces =cmake-ide= to use the
local directory and pass that directory to =helm-make=. Such config allows to
build your project with ~SPC c c~ key binding.
配置工程
创建 .dir-locals.el 文件
#+BEGIN_SRC emacs-lisp
((nil .
      ((cmake-ide-project-dir . "~/Project")
       (cmake-ide-build-dir . "~/Project/build")
       (cmake-ide-cmake-opts . "-DCMAKE_BUILD_TYPE=Debug")
       (helm-make-build-dir . "build")
       (helm-make-arguments . "-j7"))))
#+END_SRC
创建 CMakeLists.txt 文件
#+BEGIN_SRC cmakelist
PROJECT (LEARN)
#SET(SRC_LIST main.cpp)
SET(SRC_LIST learn.c)
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir "${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(learn ${SRC_LIST})
#+END_SRC
** Key Bindings

| Key Binding | Description                                                             |
|-------------+-------------------------------------------------------------------------|
| ~SPC m g a~ | open matching file                                                      |
|             | (e.g. switch between .cpp and .h, requires a project to work)           |
| ~SPC m g A~ | open matching file in another window                                    |
|             | (e.g. switch between .cpp and .h, requires a project to work)           |
| ~SPC m D~   | disaster: disassemble c/c++ code                                        |
| ~SPC m r~   | srefactor: refactor thing at point.                                     |
| ~SPC m p c~ | Run CMake and set compiler flags for auto-completion and flycheck       |
| ~SPC m p C~ | Run CMake if compilation database JSON file is not found                |
| ~SPC m p d~ | Remove file connected to current buffer and kill buffer, then run CMake |
| ~SPC m c c~ | Compile project                                                         |

*Note:*  [[https://github.com/tuhdo/semantic-refactor][semantic-refactor]]  is only available for Emacs 24.4+.

** Debugger (realgud)   这里能选择好几种调试器调试不同语言
我测试的是c ，我先 SPC m d d, 选择默认的 gdb 调试器，然后 用 file 读入 可执行文件 （记住!, 不是源码）
可能之前先设好断点  或之后，然后 执行 r , 不管在源码或在 gdb 中 ，可能要在执行后才可以，就OK了

 | Key Binding | Description     |
 |-------------+-----------------|
 | ~SPC m d d~ | open cmd buffer |
 | ~SPC m d e~ | eval variable   |
 | ~s~         | step over       |
 | ~i~         | step into       |
 | ~b~         | set break       |
 | ~B~         | unset break     |
 | ~o~         | step out        |
 | ~c~         | continue        |
 | ~e~         | eval variable   |
 | ~r~         | restart         |
 | ~q~         | quit debug      |
 | ~S~         | goto cmd buffer |

** Key Bindings

| Key Binding | Description                                                   |
|-------------+---------------------------------------------------------------|
| ~SPC m g a~ | open matching file                                            |
|             | (e.g. switch between .cpp and .h, requires a project to work) |
| ~SPC m g A~ | open matching file in another window                          |
|             | (e.g. switch between .cpp and .h, requires a project to work) |
| ~SPC m D~   | disaster: disassemble c/c++ code                              |
| ~SPC m r .~ | srefactor: refactor thing at point.                           |

*Note:* [[https://github.com/tuhdo/semantic-refactor][semantic-refactor]] is only available for Emacs 24.4+.

*** Formatting (clang-format)

 | Key Binding | Description                     |
 |-------------+---------------------------------|
 | ~SPC m = =~ | format current region or buffer |
 | ~SPC m = f~ | format current function         |

*** RTags

 | Key Binding | Description                     |
 |-------------+---------------------------------|
 | ~SPC m g .~ | find symbol at point            |
 | ~SPC m g ,~ | find references at point        |
 | ~SPC m g ;~ | find file                       |
 | ~SPC m g /~ | find all references at point    |
 | ~SPC m g [~ | location stack back             |
 | ~SPC m g ]~ | location stack forward          |
 | ~SPC m g >~ | c++ tags find symbol            |
 | ~SPC m g <~ | c++ tags find references        |
 | ~SPC m g B~ | show rtags buffer               |
 | ~SPC m g d~ | print dependencies              |
 | ~SPC m g D~ | diagnostics                     |
 | ~SPC m g e~ | reparse file                    |
 | ~SPC m g E~ | preprocess file                 |
 | ~SPC m g F~ | fixit                           |
 | ~SPC m g G~ | guess function at point         |
 | ~SPC m g h~ | print class hierarchy           |
 | ~SPC m g I~ | c++ tags imenu                  |
 | ~SPC m g L~ | copy and print current location |
 | ~SPC m g M~ | symbol info                     |
 | ~SPC m g O~ | goto offset                     |
 | ~SPC m g p~ | set current project             |
 | ~SPC m g R~ | rename symbol                   |
 | ~SPC m g s~ | print source arguments          |
 | ~SPC m g S~ | display summary                 |
 | ~SPC m g T~ | taglist                         |
 | ~SPC m g v~ | find virtuals at point          |
 | ~SPC m g V~ | print enum value at point       |
 | ~SPC m g X~ | fix fixit at point              |
 | ~SPC m g Y~ | cycle overlays on screen        |

* realgud
   Quick start
Use M-x load-library RET realgud RET to load RealGUD.

Launching the debugger
Open a source file, then use M-x realgud:<debugger-name> to start your favorite debugger (for example, you can use M-x realgud:pdb to launch PDB, a Python debugger). RealGUD opens two windows: the command window (showing the debugger's REPL), and the source window, showing your code (with some debuggers, such as realgud:gdb, this window does not appear until you type start in the command window). An solid arrow ▶ indicates the current line in the source window. Grayed out arrows indicate previous positions.

Using the debugger
All usual debugger commands work in the command window: for example, you can type n RET in the command window to step forward one source line. But RealGUD's power lies in the source window: in it, most single keys correspond to a debugger action. For example, you can press n in the source window to step forward.

Source window commands
Here is a quick rundown of the most useful commands. “:mouse2:” indicates mouse commands (commands that can be run by clicking on a variable or in the margins). Many of the commands are accessible from the tool bar (tool-bar-mode) and the menu (menu-bar-mode).

Motion commands

Command	Action
n, F10	Next (aka “step over”, “step through”)
s, SPC, F11	Step (aka “step into”)
f, S-F11	Finish (aka “step out”, “return”)
c, F5	Continue (run to next break point)
Using breakpoints

Command	Action
b, F9	Set breakpoint :mouse2:
D	Clear breakpoint :mouse2: (by number)
Inspecting variables

Command	Action
mouse-2 (middle button)	Inspect variable under cursor (in tooltip) :mouse2:
e	Evaluate expression
Control commands

Command	Action
q, S-F5	Quit
R, r	Run (aka “restart”)
S	Go to command window
Supported debuggers
RealGUD supports many external debuggers. Help us support even more!

Advanced topics
Extra commands
“⚙” indicates a work-in-progress (contributions welcome!)

Command	Action
U	Until (run to a greater source line)
u, >	Up stack (move to older stack frame)
d, <	Down stack (move to younger stack frame)
X	Clear breakpoint (by line)
j	Jump to current line ⚙
-	Disable breakpoint ⚙
+	Enable breakpoint ⚙
Tracking an existing debugger process
Use M-x realgud-track-mode inside an existing shell, or eshell buffer to track an already-running debugger process.

* cmake layer
  构建 SPC m c c
* C 
** 头文件(对象定义文件)  
<assert.h>               条件编译宏，将参数与零比较                       
<complex.h> (C99 起)     复数运算                                         
<ctype.h>                用来确定包含于字符数据中的类型的函数             
<errno.h>                报告错误条件的宏                                 
<fenv.h> (C99 起)        浮点数环境                                       
<float.h>                浮点数类型的极限                                 
<inttypes.h> (C99 起)    整数类型的格式转换                               
<iso646.h> (C95 起)      符号的替代写法                                   
<limits.h>               基本类型的大小                                   
<locale.h>               本地化工具                                       
<math.h>                 常用数学函数                                     
<setjmp.h>               非局部跳转                                       
<signal.h>               信号处理                                         
<stdalign.h> (C11 起)    alignas 与 alignof 便利宏                        
<stdarg.h>               可变参数                                         
<stdatomic.h> (C11 起)   原子类型                                         
<stdbool.h> (C99 起)     布尔类型                                         
<stddef.h>               常用宏定义                                       
<stdint.h> (C99 起)      定宽整数类型                                     
<stdio.h>                输入/输出                                        
<stdlib.h>               基础工具：内存管理、程序工具、字符串转换、随机数 
<stdnoreturn.h> (C11 起) noreturn 便利宏                                  
<string.h>               字符串处理                                       
<tgmath.h> (C99 起)      泛型数学（包装 math.h 和 complex.h 的宏）        
<threads.h> (C11 起)     线程库                                           
<time.h>                 时间/日期工具                                    
<uchar.h> (C11 起)       UTF-16 和 UTF-32 字符工具                        
<wchar.h> (C95 起)       扩展多字节和宽字符工具                           
<wctype.h> (C95 起)      用来确定包含于宽字符数据中的类型的函数           
** 函数
*** 输入输出函数
**** getchar() & putchar() 函数
 int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。
 int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。
**** gets() & puts() 函数
 char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。
 int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。
**** scanf() 和 printf() 函数
      int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。
      int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。
*** 内存管理 动态内存分配与管理 <stdlib.h>
**** void *calloc(int num, int size);该函数分配一个带有 num 个元素的数组，每个元素的大小为 size 字节。
**** void free(void *address);该函数释放 address 所指向的h内存块。
**** void *malloc(int num);该函数分配一个 num 字节的数组，并把它们进行初始化。
**** void *realloc(void *address, int newsize);该函数重新分配内存，把内存扩展到 newsize。
     
 对于长的 先是 l 然后是 符号位， 跟定义时一样
*** 文件
打开 FILE *fopen( const char * filename, const char * mode );
关闭 int fclose( FILE *fp );
写入 int fputc( int c, FILE *fp ); /int fputs( const char *s, FILE *fp );
读取 char *fgets( char *buf, int n, FILE *fp );
*** 字符串处理 string.h
    strlen 和 sizeof
** 错误处理
   : 大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 <error.h> 头文件中找到各种各样的错误代码。
   : 开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。
*** perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
*** strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
*** 程序退出状态
****  exit(EXIT_FAILURE) 调用系统宏
****  exit(EXIT_SUCCESS)
* Gcc使用 
基于C/C++的预处理器和编译器
  -o：指定生成的输出文件,所以编译多个文件是,-o 没有意义；
  -E：仅执行编译预处理； .i
  -S：将C代码转换为汇编代码；.s
  -wall：显示警告信息；
  -c：仅执行编译操作，不进行连接操作。.o
** 2. 编译为汇编代码   gcc -S test.i -o test.s
   masm=intel	汇编代码 
   -std 指定使用的语言标准
** 3. gas  gcc -c test.s -o test.o
   :-Wa,option
   :-llibrary 连接名为library的库文件
   :-L 指定额外路径
   :-m32
** 4. ld  gcc test.o -o test
   :-lobjc 这个-l选项的特殊形式用于连接Objective C程序.
   :-nostartfiles 不连接系统标准启动文件,而标准库文件仍然正常使用.
   :-nostdlib 不连接系统标准启动文件和标准库文件.只把指定的文件传递给连接器.
   :-static 在支持动态连接(dynamic linking)的系统上,阻止连接共享库.该选项在其他系统上无效.
   :-shared 生成一个共享目标文件,他可以和其他目标文件连接产生可执行文件.只有部分系统支持该选项.
   :-symbolic 建立共享目标文件的时候,把引用绑定到全局符号上.对所有无法解析的引用作出警
   告(除非用连接编辑选项 `-Xlinker -z -Xlinker defs'取代).只有部分系统支持该选项.
   :-u symbol 使连接器认为取消了symbol的符号定义,从而连接库模块以取得定义.你可以使用多
   个 `-u'选项,各自跟上不同的符号,使得连接器调入附加的库模块.
   : [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
   : -lAR	在连接文件列表中增加归档库文件AR.可以多次使用这个选项. 凡指定一项AR,ld 就会在路径列表中增加一项对libar.a的搜索.
   : -LSEARCHDIR   这个选项将路径SEARCHDIR添加到路径列表, ld在这个列表中搜索归档库.
   可以多次使用这个选项.缺省的搜索路径集(不使用-L时)取决于ld使用的
   模拟模式(emulation)及其配置.在连接脚本中,可以用SEARCH_DIR命令指定路径. 
   : -Tbss org
   : -Tdata org
   : -Ttext org
   把org作为输出文件的段起始地址 --- 特别是 --- bss,data,或text段.org必须是十六进制整数. 
   : -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
   : -x    删除 全部 局部符号. 
   : -m 指定仿真环境,这里要与gcc 的选项 -m32一致; -V显示 支持的仿真：本机支持   elf_x86_64   
   elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
   LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
   : 注意,如果连接器通过被编译器驱动来间接引用(比如gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
   gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
   : `-b INPUT-FORMAT'
   `--format=INPUT-FORMAT' [binary]
   'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
   你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
   : `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld的缺省输出格式配置
   为/各个机器上最常用的/ 格式. output-format是一个 字符串,BFD库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
   : [`-N']|[`--omagic']
   把text和data节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
   支持Unix风格的magic number, 把输出标志为'OMAGIC'. 
** 5. 检错
   : -Wall 产生尽可能多的警告信息
   : -Werror GCC会在所有产生警告的地方停止编译
** 6. 库文件连接 .a .so
   : 包含文件 -I /usr/dirpath    
   : 库   -L /dirpath   -llibname  不要.a 或.so 后缀
   : 强制静态库 gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
   静态库链接时搜索路径顺序：
   1. ld会去找GCC命令中的参数-L
   2. 再找gcc的环境变量LIBRARY_PATH
   3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的

   动态链接时、执行时搜索路径顺序:
   1. 编译目标代码时指定的动态库搜索路径
   2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
   3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
   4. 默认的动态库搜索路径/lib
   5. 默认的动态库搜索路径/usr/lib
   有关环境变量：
   LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径
   LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径
** 7. 调试
   -g:
   -gstabs:
   -gcoff:
   -gdwarf:
** 8. 优化
   -O0 不优化
   -fcaller-saves: 
** 9. 目标机选项(Target Option) 交叉编译
   -b machine 
   -V version 哪个版本的gcc
** 10.配置相关选项(Configuration Dependent Option)
   M680x0 选项
   i386选项
** 11.总体选项(Overall Option)
   -x language
   明确指出后面输入文件的语言为language (而不是从文件名后缀得到的默认选择).

** 12.目录选项(DIRECTORY OPTION)
   :-Idir 在头文件的搜索路径列表中添加dir 目录.
   :-Ldir 在`-l'选项的搜索路径列表中添加dir目录.
** 13.C 文件与 汇编文件编译
   以下涉及到不同编译器对符号的处理问题。比如我们写个汇编文件，汇编后，汇编文件中的符号未变，但是当我们写个C文件再生成目标文件后，源文件中的符号前可能加了下划线，当两者之间发生引用关系时可能无法连接，此时我们会用到下面的命令。
   : --change-leading-char
   : --remove-leading-char
   : --prefix-symbols=string
* UNIX环境高级编程
** UNIX基础知识 GNU/Linux
   内核提供基本功能
   登录
   shell
   输入输出
   程序和进程
   出错处理
** UNIX 标准化 POSIX /usr/include/unistd.h
** 文件I/O 这里讨论的是Unix自带的文件I/O函数
*** 文件描述符
    #define	STDIN_FILENO	0	/* Standard input.  */
    #define	STDOUT_FILENO	1	/* Standard output.  */
    #define	STDERR_FILENO	2	/* Standard error output.  */
*** open
    又读又写
    open(pathname, O_RDWR|O_TRUNC, mode);
*** create创建文件
    int create(const char * pathname, mode_t mode);
    等价于
    int open(pathname, O_WRONLY,|O_CREAT|O_TRUNC, mode);
    
*** read 
*** write
*** lseek 
*** close
    int close(int fiedes);
* c快速学习代码
** 一、获取输入
   #+BEGIN_SRC c
     #include <stdio.h>
     #include <stdlib.h>

     int main()
     {
         int dogs ,num =28;

         printf("how many dogs do you have?\n");
         scanf("%d",&dogs);        //获取输入，并赋值给变量地址

         printf("so you have %d dogs!!\n",dogs);     //格式化输出
         printf("I like number %d very much",num );
         getchar();      //等待输入字符
         return 0;
     }
   #+END_SRC

   #+BEGIN_SRC c

     //英寸换算厘米
     #include <stdio.h>
     #include <stdlib.h>
     int main()
     {
         float asc;
         while(scanf("%f",&asc)==1)
             printf("%f inches is %.2f cm\n",asc,asc*2.54);
         return 0;
     }
   #+END_SRC


 一、使用 bool 变量

 #include <stdio.h>
 #include <stdbool.h>
 int main(void)
 {
     float input;
     bool isTrue=(scanf("%f",&input)==1);
     while(isTrue){
         printf("you typed %.d\n",(int)input);    //强制类型转换
         isTrue=(scanf("%f",&input)==1);
     }
     return 0;
 }

 二、字符
 #include <stdio.h>
 #include <stdlib.h>
 int main()
 {
     char beep;    //与 int beep; 等效
     while(scanf("%c",&beep)==1){
         printf("you typed a %c \n", beep);
     }
     //scanf 会将回车符一起读进变量，最后结果不能达到预期！可采用后面一种方法
     return 0;
 }
 
 #include <stdio.h>
 #include <stdlib.h>
 int main()
 {
     char beep;
     while(gets(&beep)){
         printf("you typed a %c \n", beep);
     }
     return 0;
 }
 三、常量

 
 #include <stdio.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <float.h>
 #define PI 3.1416
 #define TEXT "hello world"
 #define HTML 'H'
 int main()
 {
     //常量定义 以及C预处理器 系统预定义常量
     const int china =345;
     printf("%d ,%d ,%d ，%d\n", INT_MAX, china, FLT_MAX_10_EXP, CHAR_MIN);
 }
 
 

 
 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
 　　 //计算利息
     float x=100.0,y=100.0;
     int n;
     for(n=1;x>=y;n++){
         x =100 +10*n;
         y =y*1.05;
     }
     printf("%f %f %d" ,x,y,n);
     return 0;
 }


 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     float x=100.0;
     int n;
     for(n=1;x>=0;n++){
         x =x*1.08;
         x -=10;
     }
     printf("%f  %d",x,n);
     return 0;
 }
 



 四、数学函数

 
 #include <stdio.h>
 #include <math.h>
 #define PI 3.1415926
 void main(void)
 {
     //i 为第几行，画余弦曲线
     int i, j, blankNUm;
     float cosValue;
     for(i=0;i<21;i++){
         cosValue =1-i/10.0;
         blankNUm =(int)(180/5/PI*acos(cosValue));

         for(j=0;j<blankNUm;j++)
             printf("");
         printf("*");
         for(j=0;j<(73-2-2*blankNUm);j++)
             printf("");
         i!=20?printf("*\n"):printf("");
     }
     return 0;
 }
 
 
 #include <stdio.h>
 int main(void)
 {
 　　//计算 e ，前50项，其实根前10项结果一样，只是为了演示，用double可以满足精度要求
     int i;
     double factorial=1.0, e=0;
     for(i=1;i<=50;i++){
         factorial*=i;
         e+=1.0/factorial;
     }
     printf("%f \n",e);
     return 0;
 }
 
 //机械设计，简单计算

 
 #include <stdio.h>
 void main(void)
 {
     // n1主动轮转速  n0转速差   a滑动率 b带传动效率
         //ft带的有效拉力 fc主动轮扭矩  fl从动轮扭矩  kg.cm
     float n1,n0,a,b,fl,fc,ft;

     while(scanf("%f %f %f %f",&n1,&n0,&fc,&fl)){
         a =n0/n1;
         b =(1-a)*fl/fc;
         ft =2*fc/92*98;
         printf("a=%.3f b=%.3f ft=%.3f\n",100*a,b,ft);
     }
     return 0;
 }
 



 五、特殊字符

 
 #include <stdio.h>
 #include <stdlib.h>
 int main()
 {
     float salary;

     printf("\aplease enter you salary by month:");    //  \a响龄，貌似
     printf(" $______\b\b\b\b\b\b");    //  \b退格
     if(scanf("%f",&salary)==1){
         printf("\t$%.2f per manth is $%.2f per year", salary, salary*12.0);
         printf("\rgEE!wa h\n");    // \r使光标移到当前行的起始位置,这里很微妙噢
     }
        
     return 0;
 }
 
 结果：

 please enter you salary by month: $23.4__
 gEE!wa h$23.40 per manth is $280.80 per year

 
 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {　　
 　　//字母金字塔
     int p,i;
     char letter;

     scanf("%c",&letter);
     for(p='A';p<=letter;p++){
         for(i=0;i<(letter-p);i++)
         {
             printf("");
         }
         for(i='A';i<p;i++){
             printf("%c",i);
         }
         for(i=p;i>='A';i--)
         {
             printf("%C",i);
         }
         printf("\n");
     }
     return 0;
 }
 



 

 六、for循环

 各种循环，各种格式

 
 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int k;
     for(k=1,printf("%d:hi \n",k);printf("k =%d \n",k),k*k<26;
         k+=2,printf("now k =%d\n",k))
     {
         printf("k is %d in the loop \n",k);
     }
     return 0;
 }



 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int i;
     int word[8];
     for(i=0;i<8;i++){
         word[i] =pow(2,i);
     }
     i =0;
     do{
         printf("%d ",word[i]);
     }while(++i<8);
     return 0;
 }


 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int i;
     double arr1[8],arr2[8];
     for(i=0;i<8;i++){
         scanf("%lf",&arr1[i]);
     }
     arr2[0] =arr1[0];
     for(i=1;i<8;i++){
         arr2[i] =arr2[i-1] +arr1[i];
     }
     for(i=0;i<8;i++){
         printf("%.2f\t",arr1[i]);
     }
     printf("\n");
     for(i=0;i<8;i++){
         printf("%.2f\t",arr2[i]);
     }
     return 0;
 }


 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int i,max;

     while(scanf("%d",&max)==1){
         double sum1=0,sum2=0;
         for(i=1;i<=max;i++){
             sum1+=1.00/i;
             i%2==0 ?(sum2-=1.0/i):(sum2+=1.0/i);
         }
         printf("sum1= %lf  sum2= %lf\n",sum1,sum2);
     }
     return 0;
 }
 
 七、函数

 
 #include <stdio.h>
 #include <stdlib.h>
 int square(int);   
 void echo(void);
 int main()
 {
     int i;
     for(i=0;i<10;i++)
     {
         printf("squire %d's value is%d\n",i,square(i));
     }
     printf("what\nNo/nBonzo?\n");
     echo();
     return 0;
 }

 int square(int s){
     return s*s;
 }
 void echo(void){
     printf("a function without input");
 }

 /*       another            */


 #include <stdio.h>
 #include <stdlib.h>
 void one_three(void);
 void two(void);
 int main()
 {
     printf("start now:\n");
     one_three();
     printf("done!");
     return 0;
 }
 void one_three(void){
     printf("one\n");
     two();
     printf("three\n");
 }
 void two(void){
     printf("two\n");
 }
 
 温度转换：

 
 #include <stdio.h>
 #include <float.h>
 void Temperatures(double);
 int main(void)
 {
     double input;
     while(scanf("%lf",&input)){
         Temperatures(input);
     }
     return 0;
 }
 void Temperatures(double h){
     const float F1 =1.8;
     const float F2 =32.0;
     const float F3 =273.16;
     float c,k;
    
     c =F1*(float)h + F2;
     k =c + F3;
     printf("%.2f fahrenheit %.2f fcelsius %.2f kelvin\n", h, c, k);
 }

 八、简单字符串操作

 //字符串翻转
 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int i;
     char word[30];
     scanf("%s",word);
     printf("%d\n",strlen(word));
     for(i=(strlen(word)-1);i>=0;i--)
     {
         printf("%c",word[i]);
     }
     printf("\n");
     return 0;
 }



 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int i;
     int word[8];
     for(i=0;i<8;i++){
         scanf("%d",&word[i]);
     }
     printf("\n");
     for(i=7;i>=0;i--)
     {
         printf("%d ",word[i]);
     }
     printf("\n");
     return 0;
 }


 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     char word[255];
     int i=0;
     while(scanf("%c",&word[i])){
         if(word[i]=='\n')
             break;
         i++;
     }
     for(i =(strlen(word)-2);i>=0;i--){
         printf("%c ",word[i]);
     }
     return 0;
 }
 

 九、杂项函数 sizeof

 
 #include <stdio.h>
 #include <float.h>
 #define TEXT "hello world"
 typedef float real;
 int main()
 {
     real n =0;
     size_t intsize;
     intsize =sizeof(int);

     printf("n =%f has %zd bytes all ints has %zd bytes\n",
            n,sizeof(n),intsize);   //%zd  指定size_t（C99）,是sizeof的返回值
     return 0;
 }
 
 十、联合与枚举

 联合所有成员存储在同一个内存块内（分配 sizeof 最大的那个数据空间），因此一次只能使用一个值，所有成员的值一样

 
 #include <stdio.h>
 void main(void){
     enum date { SUN=2, MON, TUE};
     int a = MON;
    
     union data
     {
         int year;
         float month;
     }d={34}, *pt;
     pt = &d;    
     d.year = 12;
     d.month = 5;
     printf("%d\n", pt->month);
 }
 
