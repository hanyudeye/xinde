* C 语言
** 程序结构
*** 对象结构元素  
    对象分解 预处理器指令
    对象功能分解 函数
    对象属性分解 变量,常量
    对象具体功能表示语句 & 表达式
    对象解释 注释
    对象属性  数据类型
** 对象类型属性
 | 数字(整数，小数)，字符对象                         |
 | 范围对象（枚举)                                    |
 | void  没有可用的值,对象功能(函数)占位符        |
 | 指针(对象位置),数组(对象集合),结构(复杂对象),union |

** 对象名字与值属性 变量名、变量值 常量名，常量值
   
   对象起名和赋值
   type variable_list=value;
  
   一维数组
   type arrayName [ arraySize ];
  
   对象位置 指针
   type *var-name;

   字符串
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};
  
   结构体
   struct [structure tag]
   {
    member definition;
    member definition;
    ...
    member definition;
    } [one or more structure variables];  
 structure tag 是可选的，每个 member definition 是标准的变量定义

 共用体
 union [union tag]
 {
    member definition;
    member definition;
    ...
    member definition;
 } [one or more union variables];  
 union tag 是可选的

 给类型别名
 typedef unsigned char BYTE;

   常量起名  
   使用 #define 预处理器
   使用 const 关键字

** 别名
   typedef char* String_t;
   #define String_d char *
** 对象生命期
   auto 存储类是所有局部变量默认的存储类。

   register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大
   尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没
   有内存位置）。

   static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进
   入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间
   保持局部变量的值。

 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当
 您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
** 对象的行为
   算术运算符
   关系运算符
   逻辑运算符
   位运算符
   赋值运算符
   杂项运算符
** 对象的行为扩展  函数
   return_type function_name( parameter list )
   {
   body of the function
   }

** 预处理器功能
 指令	描述
 #define	定义宏
 #include	包含一个源代码文件
 #undef	取消已定义的宏
 #ifdef	如果宏已经定义，则返回真
 #ifndef	如果宏没有定义，则返回真
 #if	如果给定条件为真，则编译下面代码
 #else	#if 的替代方案
 #elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
 #endif	结束一个 #if……#else 条件编译块
 #error	当遇到标准错误时，输出错误消息
 #pragma	使用标准化方法，向编译器发布特殊的命令到编译器中

 预定义宏
 ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。

 宏	描述
 __DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
 __TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
 __FILE__	这会包含当前文件名，一个字符串常量。
 __LINE__	这会包含当前行号，一个十进制常量。
 __STDC__	当编译器以 ANSI 标准编译时，则定义为 1。

 #+begin_src c

   #include <stdio.h>

   int main()
   {
      printf("File :%s\n", __FILE__ );
      printf("Date :%s\n", __DATE__ );
      printf("Time :%s\n", __TIME__ );
      printf("Line :%d\n", __LINE__ );
      printf("ANSI :%d\n", __STDC__ );

   }
 #+end_src

 预处理器运算符
 宏延续运算符（\）
 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：

 字符串常量化运算符（#）
 在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

 #+begin_src c

   #include <stdio.h>

   #define  message_for(a, b)  \
       printf(#a " and " #b ": We love you!\n")

   int main(void)
   {
      message_for(Carole, Debra);
      return 0;
   }

 #+end_src

 当上面的代码被编译和执行时，它会产生下列结果：

 Carole and Debra: We love you!

 标记粘贴运算符（##）
 宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：

 #+begin_src c
 #include <stdio.h>
 #define tokenpaster(n) printf ("token" #n " = %d", token##n)

 int main(void)
 {
    int token34 = 40;
   
    tokenpaster(34);
    return 0;
 }

 #+end_src
 当上面的代码被编译和执行时，它会产生下列结果：


 token34 = 40
 这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

 printf ("token34 = %d", token34);
 这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。

 defined() 运算符
 预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：

 #include <stdio.h>

 #if !defined (MESSAGE)
    #define MESSAGE "You wish!"
 #endif

 int main(void)
 {
    printf("Here is the message: %s\n", MESSAGE);  
    return 0;
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Here is the message: You wish!
 参数化的宏
 CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：

 int square(int x) {
    return x * x;
 }
 我们可以使用宏重写上面的代码，如下：

 #define square(x) ((x) * (x))
 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

 #include <stdio.h>

 #define MAX(x,y) ((x) > (y) ? (x) : (y))

 int main(void)
 {
    printf("Max between 20 and 10 is %d\n", MAX(10, 20));  
    return 0;
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Max between 20 and 10 is 20
 您的支持将鼓励我们做得更好
 赞赏支持
** 符号占位 头文件
 只引用一次头文件
 如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：

 #ifndef HEADER_FILE
 #define HEADER_FILE

 the entire header file file

 #endif
 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。

 有条件引用
 有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：

 #if SYSTEM_1
    # include "system_1.h"
 #elif SYSTEM_2
    # include "system_2.h"
 #elif SYSTEM_3
    ...
 #endif
 但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：

  #define SYSTEM_H "system_1.h"
  ...
  #include SYSTEM_H
 SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。

** 错误处理
 C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许
 您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会
 设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可
 以在 <error.h> 头文件中找到各种各样的错误代码。

 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员
 应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没
 有错误。

 errno、perror() 和 strerror()
 C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。

 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
 让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。

 #include <stdio.h>
 #include <errno.h>
 #include <string.h>

 extern int errno ;

 int main ()
 {
    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");
    if (pf == NULL)
    {
       errnum = errno;
       fprintf(stderr, "Value of errno: %d\n", errno);
       perror("Error printed by perror");
       fprintf(stderr, "Error opening file: %s\n", strerror( errnum ));
    }
    else
    {
       fclose (pf);
    }
    return 0;
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Value of errno: 2
 Error printed by perror: No such file or directory
 Error opening file: No such file or directory
 被零除的错误
 在进行除法运算时，不检查除数是否为零，这是程序员编程时常见的问题，会导致一个运行时错误。

 为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：

 #include <stdio.h>
 #include <stdlib.h>

 main()
 {
    int dividend = 20;
    int divisor = 0;
    int quotient;
 
    if( divisor == 0){
       fprintf(stderr, "Division by zero! Exiting...\n");
       exit(-1);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "Value of quotient : %d\n", quotient );

    exit(0);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Division by zero! Exiting...
 程序退出状态
 通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。

 如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：

 #include <stdio.h>
 #include <stdlib.h>

 main()
 {
    int dividend = 20;
    int divisor = 5;
    int quotient;
 
    if( divisor == 0){
       fprintf(stderr, "Division by zero! Exiting...\n");
       exit(EXIT_FAILURE);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "Value of quotient : %d\n", quotient );

    exit(EXIT_SUCCESS);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Value of quotient : 4
** 可变参数
 #+begin_src
 int func(int, ... ) 
 {
    .
    .
    .
 }

 int main()
 {
    func(1, 2, 3);
    func(1, 2, 3, 4);
 }

 #+end_src
 请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数总是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：

 定义一个函数，最后一个参数为省略号，省略号前面的那个参数总是 int，表示了参数的个数。
 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
 使用宏 va_end 来清理赋予 va_list 变量的内存。
 现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：

 #include <stdio.h>
 #include <stdarg.h>

 double average(int num,...)
 {

     va_list valist;
     double sum = 0.0;
     int i;

     /* 为 num 个参数初始化 valist */
     va_start(valist, num);

     /* 访问所有赋给 valist 的参数 */
     for (i = 0; i < num; i++)     {
         sum += va_arg(valist, int);
     }     /* 清理为 valist 保留的内存 */
     va_end(valist);
     return sum/num;
     }
 int main() {
 printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
 printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));
 } 
 当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。

 Average of 2, 3, 4, 5 = 3.500000
 Average of 5, 10, 15 = 10.000000


 您的支持将鼓励我们做得更好
 赞赏支持
** 内存管理
 本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数
 可以在 <stdlib.h> 头文件中找到。

 - void *calloc(int num, int size);
   该函数分配一个带有 function allocates an array of num 个元素的数组，每个元素的大小为 size 字节。
 - void free(void *address);
  该函数释放 address 所指向的 h 内存块。
 - void *malloc(int num);
  该函数分配一个 num 字节的数组，并把它们进行初始化。
 - void *realloc(void *address, int newsize);
  该函数重新分配内存，把内存扩展到 newsize。

 动态分配内存

 编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的
 数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：

 char name[100];

 但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在
 这里，我们需要定义一个指针，该指针指向未定义所学内存大小的字符，后续再根据需求来
 分配内存，如下所示：

 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

 int main()
 {
    char name[100];
    char *description;

    strcpy(name, "Zara Ali");

    /* 动态分配内存 */
    description = malloc( 200 * sizeof(char) );
    if( description == NULL )
    {
       fprintf(stderr, "Error - unable to allocate required memory\n");
    }
    else
    {
       strcpy( description, "Zara ali a DPS student in class 10th");
    }
    printf("Name = %s\n", name );
    printf("Description: %s\n", description );
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Name = Zara Ali
 Description: Zara ali a DPS student in class 10th
 上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：

 calloc(200, sizeof(char));

 当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数
 组，一旦定义则无法改变大小。

 重新调整内存的大小和释放内存

 当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，
 都应该调用函数 free() 来释放内存。

 或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用
 realloc() 和 free() 函数，再次查看上面的实例：

 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

 int main()
 {
    char name[100];
    char *description;

    strcpy(name, "Zara Ali");

    /* 动态分配内存 */
    description = malloc( 30 * sizeof(char) );
    if( description == NULL )
    {
       fprintf(stderr, "Error - unable to allocate required memory\n");
    }
    else
    {
       strcpy( description, "Zara ali a DPS student.");
    }
    /* 假设您想要存储更大的描述信息 */
    description = realloc( description, 100 * sizeof(char) );
    if( description == NULL )
    {
       fprintf(stderr, "Error - unable to allocate required memory\n");
    }
    else
    {
       strcat( description, "She is in class 10th");
    }
   
    printf("Name = %s\n", name );
    printf("Description: %s\n", description );

    /* 使用 free() 函数释放内存 */
    free(description);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Name = Zara Ali
 Description: Zara ali a DPS student.She is in class 10th

 您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储
 description 时可用的内存不足。

* C 标准库
** 字符类函数 ctype.h  
***  字符判断
  字母或数字 isalnum(int c) 
  字母 int isalpha(int c)
 控制字符  int iscntrl(int c)   
 十进制数字 isdigit(int c)
有图形表示法 isgraph(int c)
小写字母 islower(int c)
可打印的 isprint(int c)
标点符号字符 ispunct(int c)
空白字符 isspace(int c)
大写字母 isupper(int c)
十六进制数字 isxdigit(int c)
*** 转换
 大写字母转换为小写字母 tolower(int c)
 小写字母转换为大写字母 toupper(int c)
** errno.h
	extern int errno
 这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。
 
EDOM Domain Error
 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。
 
ERANGE Range Error

 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置
 为 ERANGE。
** float.h
*** 宏 
    FLT_ROUNDS	定义浮点加法的舍入模式，它可以是下列任何一个值：
    -1 - 无法确定
    0 - 趋向于零
    1 - 去最近的值
    2 - 趋向于正无穷
    3 - 趋向于负无穷

  FLT_RADIX 2	这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。
  FLT_MANT_DIG
  DBL_MANT_DIG
  LDBL_MANT_DIG

  这些宏定义了 FLT_RADIX 基数中的位数。
  FLT_DIG 6
  DBL_DIG 10
  LDBL_DIG 10

  这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。
  FLT_MIN_EXP
  DBL_MIN_EXP
  LDBL_MIN_EXP

  这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。
  FLT_MIN_10_EXP -37
  DBL_MIN_10_EXP -37
  LDBL_MIN_10_EXP -37

  这些宏定义了基数为 10 时的指数的最小负整数值。
  FLT_MAX_EXP
  DBL_MAX_EXP
  LDBL_MAX_EXP

  这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。
  FLT_MAX_10_EXP +37
  DBL_MAX_10_EXP +37
  LDBL_MAX_10_EXP +37

  这些宏定义了基数为 10 时的指数的最大整数值。
  FLT_MAX 1E+37
  DBL_MAX 1E+37
  LDBL_MAX 1E+37

  这些宏定义最大的有限浮点值。
  FLT_EPSILON 1E-5
  DBL_EPSILON 1E-9
  LDBL_EPSILON 1E-9

  这些宏定义了可表示的最小有效数字。
  FLT_MIN 1E-37
  DBL_MIN 1E-37
  LDBL_MIN 1E-37

  这些宏定义了最小的浮点值。
  实例
  下面的实例演示了 float.h 文件中定义的一些常量的使用。

  #include <stdio.h>
  #include <float.h>

  int main()
  {
     printf("The maximum value of float = %.10e\n", FLT_MAX);
     printf("The minimum value of float = %.10e\n", FLT_MIN);

     printf("The number of digits in the number = %.10e\n", FLT_MANT_DIG);
  }
  让我们编译和运行上面的程序，这将产生下列结果：

  The maximum value of float = 3.4028234664e+38
  The minimum value of float = 1.1754943508e-38
  The number of digits in the number = 7.2996655210e-312
** time.h
- 库变量
  - size_t 是无符号整数类型，它是 sizeof 关键字的结果。
  - clock_t 这是一个适合存储处理器时间的类型。
  - time_t 这是一个适合存储日历时间类型。
  - struct tm 这是一个用来保存时间和日期的结构。
  - 
  - tm 结构的定义如下：
   struct tm {
     int tm_sec;         /* 秒，范围从 0 到 59       */
     int tm_min;         /* 分，范围从 0 到 59      */
     int tm_hour;        /* 小时，范围从 0 到 23     */
     int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */
     int tm_mon;         /* 月，范围从 0 到 11      */
     int tm_year;        /* 自 1900 年起的年数      */
     int tm_wday;        /* 一周中的第几天，范围从 0 到 6 */
     int tm_yday;        /* 一年中的第几天，范围从 0 到 365   */
     int tm_isdst;       /* 夏令时               */
   };
  - 

 结构 timeptr 的日期和时间 char *asctime(const struct tm *timeptr)
 处理器时钟所使用的时间 clock_t clock(void)
当地时间的字符串 char *ctime(const time_t *timer)
 time1 和 time2 之间相差的秒数 double difftime(time_t time1, time_t time2)
  timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。struct tm *gmtime(const time_t *timer)
  timer 的值被分解为 tm 结构，并用本地时区表示。struct tm *localtime(const time_t *timer)
  
  把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。time_t mktime(struct tm *timeptr)
  格式化结构 timeptr 表示的时间  size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
  计算当前日历时间，并把它编码成 time_t 格式 time_t time(time_t *timer)
** stdio.h
   int printf( const char *format, ... );​
​   int printf( const char *restrict format, ... );​

   int scanf(const char *format, ...); 返回的是满足格式化的个数
   int fscanf(FILE *stream, const char *format, ...);
   int sscanf(const char *str, const char *format, ...);
** stdarg.h
   int vscanf(const char *format, va_list ap);
   int vsscanf(const char *str, const char *format, va_list ap);
   int vfscanf(FILE *stream, const char *format, va_list ap);
** unistd.h
   ssize_t write(int fd, const void *buf, size_t count);
   ssize_t read(int fd, void *buf, size_t count);

* 非 C 标准库
** conio.h
conio.h 是一个 C 头文件，用于 MS-DOS C 编译器里。此头文件宣告了数个有用的函数，提供程
序设计者主控台的输出入操作接口。

int kbhit(void)
int getch(void)
int getche(void)
int ungetch(int c)
char *cgets(char *buffer)
int cscanf(char *format, arg0,... argn)
int putch(int c)
int cputs(const char *string)
int cprintf(const char *format, arg0,... argn)
* 编译链接
**  代码都在源文件中 ，只要按序串起来
   gcc source1 source2  -o bin
** 链接
*** 静态 
**** 可重定位目标文件 
     linux ELF（可执行可链接)
     readelf
**** 静态库  libc.a
     工具 ar
*** 动态 
    创建共享库    gcc -shared -fPIC -o libvector.so a.c b.c
