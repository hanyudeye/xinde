* c-c++mode
** 语法检查 通过 flycheck
** 反汇编 disaster
** 代码格式化 clang-format
** 底部定义提示 semantic
** 导航 cscope
** 自动完成 
1. c-c++-enable-clang-support 打开
2.ycmd 层打开
** 调试 realgud
** 支持CMake 脚本构建
   CMake 是一个跨平台的，开源的构建系统（BuildSystem）。CMake 可以通过 CMakeLists.txt 文件来产生特定平台的标准的构建文件，例如：为 Unix 平台生成makefiles文件（使用GCC编译），为 Windows MSVC 生成 projects/workspaces（使用VS IDE编译）或Makefile文件（使用nmake编译）。
CMake Hello World

首先编写一个简单的程序（hello.cpp）：
#include <stdio.h>
int main()
{
   printf("Hello World");
   return 0;
}
编写CMakeLists.txt，并与hello.cpp放在同一个目录。
project(hello)
cmake_minimum_required(VERSION 2.8)
aux_source_directory(. DIR_SRCS)
add_executable(hello ${DIR_SRCS})
在 CMakeLists.txt 所在的目录下创建一个build目录，进入该目录执行 CMake 命令生成构建文件：
打开Visual Studio 2008命令行提示窗口，它会执行加载一些VS的环境变量。
mkdir build
cd build
cmake -G "NMake Makefiles" ../
-- The C compiler identification is MSVC 15.0.30729.1
-- The CXX compiler identification is MSVC15.0.30729.1
….
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to:I:/cmake-hello/build
这里使用的平台为 Windows 并且安装了 VS2008，CMake 为我们生成了 VS2008的构建文件Makefile，我们可以使用nmake来构建应用程序，执行：
nmake
 
Microsoft (R) Program Maintenance UtilityVersion 9.00.30729.01
Copyright (C) Microsoft Corporation.  All rights reserved.
 
Scanning dependencies of target hello
[100%] Building CXX objectCMakeFiles/hello.dir/hello.cpp.obj
hello.cpp
Linking CXX executable hello.exe
[100%] Built target hello
编译成功完成后，会当前目录下生成hello应用程序。
CMake基本语法

编写的CMakeLists.txt需要符合一定的语法规则，它主要由CMake命令组成。
1）注释的语法：在CMake中注释使用#字符开始到此行结束。
2）CMake命令：命令不区分大小写（参数会区分大小写），命令由命令、参数列表组成，参数之间使用空格进行分隔。使用一对双引号包括的字符串认为是一个参数。命令可以是一个内置命令（例如：project，add_executable等），也可以是一个用户定义的宏（macro）或者函数（function）。
3）数据类型：CMake的基本数据类型是字符串，一组字符串在一起称为列表（list），例如：
# 通过 set 命令构建一个 listVAR
set(VAR a b c)
使用语法 ${VariableName} 来访问名字为 VariableName 的变量的值（变量名区分大小写）。需要注意的是，即使在字符串中也可以使用 ${VariableName} 来访问变量的值：
set(VAR a b c)
# 输出 VAR = a;b;c
message("VAR = ${VAR}")
使用语法 $ENV{VariableName} 来访问环境变量的值（ENV{VariableName} 则表示环境变量本身）
# 输出环境变量 PATH 的值
message($ENV{PATH})
4）条件控制和循环结构
条件控制命令为 if 命令
if(expression)
    #...
elseif(expression2)
    #...
else()
    #...
endif()
对于 if(string) 来说：
如果 string 为（不区分大小写）1、ON、YES、TRUE、Y、非 0 的数则表示真
如果 string 为（不区分大小写）0、OFF、NO、FALSE、N、IGNORE、空字符串、以 -NOTFOUND 结尾的字符串则表示假
如果 string 不符合上面两种情况，则 string 被认为是一个变量的名字。变量的值为第二条所述的各值则表示假，否则表示真。
# 此策略（Policy）在 CMake2.8.0 才被引入
# 因此这里需要指定最低 CMake 版本为 2.8
cmake_minimum_required(VERSION 2.8)
set(YES 0)
 
# 输出 True
if(YES)
   message(True)
else()
   message(False)
endif()
 
# 输出 False
if(${YES})
   message(True)
else()
   message(False)
endif()
表达式中可以包含操作符，操作符包括：
一元操作符，例如：EXISTS、COMMAND、DEFINED 等
二元操作符，例如：EQUAL、LESS、GREATER、STRLESS、STRGREATER 等
NOT（非操作符）
AND（与操作符）、OR（或操作符）
操作符优先级：一元操作符 > 二元操作符 > NOT > AND、OR
常用操作符介绍：
if(NOT expression)
为真的前提是 expression 为假
if(expr1 AND expr2)
为真的前提是 expr1 和 expr2 都为真
if(expr1 OR expr2)
为真的前提是 expr1 或者 expr2 为真
if(COMMAND command-name)
为真的前提是存在 command-name 命令、宏或函数且能够被调用
if(EXISTS name)
为真的前提是存在 name 的文件或者目录（应该使用绝对路径）
if(file1 IS_NEWER_THAN file2)
为真的前提是 file1 比 file2 新或者 file1、file2 中有一个文件不存在（应该使用绝对路径）
if(IS_DIRECTORY directory-name)
为真的前提是 directory-name 表示的是一个目录（应该使用绝对路径）
if(variable|string MATCHES regex)
为真的前提是变量值或者字符串匹配 regex 正则表达式
if(variable|string LESS variable|string)
if(variable|string GREATER variable|string)
if(variable|string EQUAL variable|string)
为真的前提是变量值或者字符串为有效的数字且满足小于（大于、等于）的条件
if(variable|string STRLESS variable|string)
if(variable|string STRGREATERvariable|string)
if(variable|string STREQUALvariable|string)
为真的前提是变量值或者字符串以字典序满足小于（大于、等于）的条件
if(DEFINED variable)
为真的前提是 variable 表示的变量被定义了。
foreach 循环范例：
set(VAR a b c)
foreach(f ${VAR})
   message(${f})
endforeach()
while 循环范例：
set(VAR 5)
while(${VAR} GREATER 0)
   message(${VAR})
   math(EXPR VAR "${VAR} - 1")
endwhile()
5）函数和宏定义
函数会为变量创建一个局部作用域，而宏则使用全局作用域。范例：
# 定义一个宏 hello
macro(hello MESSAGE)
   message(${MESSAGE})
endmacro()
# 调用宏 hello
hello("hello world")
# 定义一个函数 hello
function(hello MESSAGE)
   message(${MESSAGE})
endfunction()
函数和宏可以通过命令 return() 返回，但是函数和宏的返回值必须通过参数传递出去。例如：
cmake_minimum_required(VERSION 2.8)
function(get_func RESULT)
    #RESULT 的值为实参的值，因此需要使用 ${RESULT}
    #这里使用 PARENT_SCOPE 是因为函数会构建一个局部作用域
   set(${RESULT} "Hello Function" PARENT_SCOPE)
endfunction()
 
macro(get_macro RESULT)
   set(${RESULT} "Hello Macro")
endmacro()
 
get_func(V1)
# 输出 Hello Function
message(${V1})
 
get_macro(V2)
# 输出 Hello Macro
message(${V2})
7）字符串的一些问题
字符串可跨行且支持转移字符，例如：
set(VAR "hello
world")
# 输出结果为：
# ${VAR} = hello
# world
message("\${VAR} = ${VAR}")
CMake常用命令

这里介绍一下常用的命令（CMake 2.8 的命令可以在此查询）：
http://www.cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands
1）project 命令
命令语法：project(<projectname> [languageName1 languageName2 … ] )
命令简述：用于指定项目的名称
使用范例：project(Main)
2）cmake_minimum_required命令
命令语法：cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])
命令简述：用于指定需要的 CMake 的最低版本
使用范例：cmake_minimum_required(VERSION 2.8)
3）aux_source_directory命令
命令语法：aux_source_directory(<dir> <variable>)
命令简述：用于将 dir 目录下的所有源文件的名字保存在变量 variable 中
使用范例：aux_source_directory(. DIR_SRCS)
4）add_executable 命令
命令语法：add_executable(<name> [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)
命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个可执行文件且命名为 name
使用范例：add_executable(Main ${DIR_SRCS})
5）add_library 命令
命令语法：add_library([STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1source2 … sourceN)
命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个库文件且命名为 name
使用范例：add_library(Lib ${DIR_SRCS})
6）add_dependencies 命令
命令语法：add_dependencies(target-name depend-target1 depend-target2 …)
命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。这里的目标必须是 add_executable、add_library、add_custom_target 命令创建的目标
7）add_subdirectory 命令
命令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
命令简述：用于添加一个需要进行构建的子目录
使用范例：add_subdirectory(Lib)
8）target_link_libraries命令
命令语法：target_link_libraries(<target> [item1 [item2 […]]][[debug|optimized|general] ] …)
命令简述：用于指定 target 需要链接 item1 item2 …。这里 target 必须已经被创建，链接的 item 可以是已经存在的 target（依赖关系会自动添加）
使用范例：target_link_libraries(Main Lib)
9）set 命令
命令语法：set(<variable> <value> [[CACHE <type><docstring> [FORCE]] | PARENT_SCOPE])
命令简述：用于设定变量 variable 的值为 value。如果指定了 CACHE 变量将被放入 Cache（缓存）中。
使用范例：set(ProjectName Main)
10）unset 命令
命令语法：unset(<variable> [CACHE])
命令简述：用于移除变量 variable。如果指定了 CACHE 变量将被从 Cache 中移除。
使用范例：unset(VAR CACHE)
11）message 命令
命令语法：message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…)
命令简述：用于输出信息
使用范例：message(“Hello World”)
12）include_directories 命令
命令语法：include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)
命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件
使用范例：include_directories(${PROJECT_SOURCE_DIR}/lib)
13）find_path 命令
命令语法：find_path(<VAR> name1 [path1 path2 …])
命令简述：用于查找包含文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 <VAR>-NOTFOUND。默认的情况下，VAR 会被保存在 Cache 中，这时候我们需要清除 VAR 才可以进行下一次查询（使用 unset 命令）。
使用范例：
find_path(LUA_INCLUDE_PATH lua.h${LUA_INCLUDE_FIND_PATH})
if(NOT LUA_INCLUDE_PATH)
   message(SEND_ERROR "Header file lua.h not found")
endif()
14）find_library 命令
命令语法：find_library(<VAR> name1 [path1 path2 …])
命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 <VAR>-NOTFOUND。一个类似的命令 link_directories 已经不太建议使用了
15）add_definitions 命令
命令语法：add_definitions(-DFOO -DBAR …)
命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义
使用范例：add_definitions(-D_UNICODE -DUNICODE)
16）execute_process 命令
命令语法：
execute_process(COMMAND <cmd1>[args1...]]
                  [COMMAND <cmd2>[args2...] [...]]
                  [WORKING_DIRECTORY<directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE<variable>]
                  [OUTPUT_VARIABLE<variable>]
                  [ERROR_VARIABLE<variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                 [OUTPUT_STRIP_TRAILING_WHITESPACE]
                 [ERROR_STRIP_TRAILING_WHITESPACE])
命令简述：用于执行一个或者多个外部命令。每一个命令的标准输出通过管道转为下一个命令的标准输入。WORKING_DIRECTORY 用于指定外部命令的工作目录，RESULT_VARIABLE 用于指定一个变量保存外部命令执行的结果，这个结果可能是最后一个执行的外部命令的退出码或者是一个描述错误条件的字符串，OUTPUT_VARIABLE 或者 ERROR_VARIABLE 用于指定一个变量保存标准输出或者标准错误，OUTPUT_QUIET 或者 ERROR_QUIET 用于忽略标准输出和标准错误。
使用范例：execute_process(COMMAND ls)
18）file 命令
命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）
使用范例：
# 目录的遍历
# GLOB 用于产生一个文件（目录）路径列表并保存在variable 中
# 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）
# 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径
# file(GLOB variable [RELATIVE path][globbing expressions]...)
 
# 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中
file(GLOB ALL_FILE_PATH ./*)
# 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中
# 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）
file(GLOB ALL_H_FILE RELATIVE${CMAKE_CURRENT_LIST_DIR} ${CMAKE_CURRENT_LIST_DIR}/*.h)
CMake常用变量

UNIX 如果为真，表示为 UNIX-like 的系统，包括 AppleOS X 和 CygWin
WIN32 如果为真，表示为 Windows 系统，包括 CygWin
APPLE 如果为真，表示为 Apple 系统
CMAKE_SIZEOF_VOID_P 表示 void* 的大小（例如为 4 或者 8），可以使用其来判断当前构建为 32 位还是 64 位
CMAKE_CURRENT_LIST_DIR 表示正在处理的CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）
CMAKE_ARCHIVE_OUTPUT_DIRECTORY 用于设置 ARCHIVE 目标的输出路径
CMAKE_LIBRARY_OUTPUT_DIRECTORY 用于设置 LIBRARY 目标的输出路径
CMAKE_RUNTIME_OUTPUT_DIRECTORY 用于设置 RUNTIME 目标的输出路径
构建类型

CMake 为我们提供了四种构建类型：
Debug
Release
MinSizeRel
RelWithDebInfo
如果使用 CMake 为 Windows MSVC 生成 projects/workspaces 那么我们将得到上述的 4 种解决方案配置。
 
如果使用 CMake 生成 Makefile 时，我们需要做一些不同的工作。CMake 中存在一个变量 CMAKE_BUILD_TYPE 用于指定构建类型，此变量只用于基于 make 的生成器。我们可以这样指定构建类型：
$ CMake -DCMAKE_BUILD_TYPE=Debug .
这里的 CMAKE_BUILD_TYPE 的值为上述的 4 种构建类型中的一种。
编译和链接标志

C 编译标志相关变量：
 
CMAKE_C_FLAGS
CMAKE_C_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
C++ 编译标志相关变量：
 
CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_C_FLAGS 或CMAKE_CXX_FLAGS 可以指定编译标志
CMAKE_C_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]或 CMAKE_CXX_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO] 则指定特定构建类型的编译标志，这些编译标志将被加入到 CMAKE_C_FLAGS 或 CMAKE_CXX_FLAGS 中去，例如，如果构建类型为 DEBUG，那么 CMAKE_CXX_FLAGS_DEBUG 将被加入到 CMAKE_CXX_FLAGS中去
 
链接标志相关变量：
CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS_[DEBUG|RELEASE|MINSIZEREL|RELWITHDEBINFO]
它们类似于编译标志相关变量
生成Debug和Release版本

在 Visual Studio 中我们可以生成 debug 版和 release 版的程序,使用 CMake 我们也可以达到上述效果。debug 版的项目生成的可执行文件需要有调试信息并且不需要进行优化,而 release 版的不需要调试信息但需要优化。这些特性在 gcc/g++ 中是通过编译时的参数来决定的,如果将优化程度调到最高需要设置参数-O3,最低是 -O0 即不做优化;添加调试信息的参数是 -g -ggdb ,如果不添加这个参数,调试信息就不会被包含在生成的二进制文件中。
CMake 中有一个变量CMAKE_BUILD_TYPE ,可以的取值是 Debug、Release、RelWithDebInfo 和 MinSizeRel。当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG中的字符串作为编译选项生成Makefile ,当这个变量值为 Release 的时候,工程会使用变量 CMAKE_CXX_FLAGS_RELEASE 和CMAKE_C_FLAGS_RELEASE 选项生成 Makefile。
示例：
PROJECT(main)
CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
SET(CMAKE_SOURCE_DIR .)
 
SET(CMAKE_CXX_FLAGS_DEBUG"$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
SET(CMAKE_CXX_FLAGS_RELEASE"$ENV{CXXFLAGS} -O3 -Wall")
 
AUX_SOURCE_DIRECTORY(. DIR_SRCS)
ADD_EXECUTABLE(main ${DIR_SRCS})
第 5 和 6 行设置了两个变量 CMAKE_CXX_FLAGS_DEBUG 和CMAKE_CXX_FLAGS_RELEASE, 这两个变量是分别用于 debug 和 release 的编译选项。编辑 CMakeList.txt 后需要执行 ccmake 命令生成 Makefile 。在进入项目的根目录,输入 "ccmake ." 进入一个图形化界面。
编译32位和64位程序

对于 Windows MSVC，我们可以设定 CMake Generator 来确定生成 Win32 还是 Win64 工程文件，例如：
 
# 用于生成 Visual Studio 10Win64 工程文件
CMake -G "Visual Studio 10 Win64"
# 用于生成 Visual Studio 10Win32 工程文件
CMake -G "Visual Studio 10"
我们可以通过 CMake --help 来查看当前平台可用的 Generator。
CMake .. -DUSE_32BITS=1
if(USE_32BITS)
 message(STATUS "Using 32bits")
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}-m32")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}-m32")
else()
endif(USE_32BITS)
对于 UNIX 和类 UNIX 平台，我们可以通过编译器标志（选项）来控制进行 32 位还是 64 位构建。
GCC命令行参数
32位版：加上 -m32 参数，生成32位的代码。
64位版：加上 -m64 参数，生成64位的代码。
debug版：加上 -g 参数，生成调试信息。
release版：加上 -static 参数，进行静态链接，使程序不再依赖动态库。加上 -O3 参数，进行最快速度优化。加上-DNDEBUG参数，定义NDEBUG宏，屏蔽断言。
当没有-m32或-m64参数时，一般情况下会生成跟操作系统位数一致的代码，但某些编译器存在例外，例如——
32位Linux下的GCC，默认是编译为32位代码。
64位Linux下的GCC，默认是编译为64位代码。
Window系统下的MinGW，总是编译为32位代码。因为MinGW只支持32位代码。
Window系统下的MinGW-w64（例如安装了TDM-GCC，选择MinGW-w64），默认是编译为64位代码，包括在32位的Windows系统下。
Makefile文件中的示例：
# [args] 生成模式. 0代表debug模式, 1代表release模式. makeRELEASE=1.
ifeq ($(RELEASE),0)
   CFLAGS += -g
else
    #release
   CFLAGS += -static -O3 -DNDEBUG
   LFLAGS += -static
endif
# [args] 程序位数. 32代表32位程序, 64代表64位程序, 其他默认. makeBITS=32.
ifeq ($(BITS),32)
   CFLAGS += -m32
   LFLAGS += -m32
else
    ifeq($(BITS),64)
       CFLAGS += -m64
       LFLAGS += -m64
   else
   endif
endif
多源文件目录的处理方式

我们在每一个源码目录中都会放置一个 CMakeLists.txt 文件。我们现在假定有这么一个工程：
HelloWorld
|
+------- Main.cpp
|
+------- CMakeLists.txt
|
+------- Lib
        |
        +------- Lib.cpp
        |
        +------- Lib.h
        |
        +------- CMakeLists.txt
这里 Lib 目录下的文件将被编译为一个库。首先，我们看一下 Lib 目录下的 CMakeLists.txt 文件：
aux_source_directory(. DIR_SRCS)
add_library(Lib ${DIR_SRCS})
然后，看一下 HelloWorld 目录下的 CMakeLists.txt 文件：
project(Main)
cmake_minimum_required(VERSION 2.8)
add_subdirectory(Lib)
aux_source_directory(. DIR_SRCS)
add_executable(Main ${DIR_SRCS})
target_link_libraries(Main Lib)
这里使用了 add_subdirectory 指定了需要进行构建的子目录，并且使用了 target_link_libraries 命令，表示 Main 可执行文件需要链接 Lib库。我们执行 CMake . 命令，首先会执行 HelloWorld 目录下的 CMakeLists.txt 中的命令，当执行到 add_subdirectory(Lib) 命令的时候会进入 Lib 子目录并执行其中的CMakeLists.txt 文件。
外部构建（out of source builds）

我们在 CMakeLists.txt 所在目录下执行 CMake . 会生成大量的文件，这些文件和我们的源文件混在一起不好管理，我们采用外部构建的方式来解决这个问题。以上面的 Hello World 工程来做解释：
在 HelloWorld 目录下建立一个build 目录（build目录可以建立在如何地方）
进入 build 目录并进行外部构建 CMake ..（语法为 CMake <CMakeLists.txt 的路径>，这里使用 CMake.. 表明了 CMakeLists.txt 在 Build 目录的父目录中）。这样 CMake 将在 Build 目录下生成文件。
** cmake
####cmake中一些预定义变量

PROJECT_SOURCE_DIR 工程的根目录
PROJECT_BINARY_DIR 运行cmake命令的目录,通常是${PROJECT_SOURCE_DIR}/build
CMAKE_INCLUDE_PATH 环境变量,非cmake变量
CMAKE_LIBRARY_PATH 环境变量
CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的路径
CMAKE_CURRENT_BINARY_DIR target编译目录 使用ADD_SURDIRECTORY(src bin)可以更改此变量的值 SET(EXECUTABLE_OUTPUT_PATH <新路径>)并不会对此变量有影响,只是改变了最终目标文件的存储路径
CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径
CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行
CMAKE_MODULE_PATH 定义自己的cmake模块所在的路径 SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake),然后可以用INCLUDE命令来调用自己的模块
EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置
LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置
PROJECT_NAME 返回通过PROJECT指令定义的项目名称
CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 用来控制IF ELSE语句的书写方式
系统信息

CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2
CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8
CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6
CMAKE_SYSTEM 系统名称,例如Linux-2.6.22
CAMKE_SYSTEM_NAME 不包含版本的系统名,如Linux
CMAKE_SYSTEM_VERSION 系统版本,如2.6.22
CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686
UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin
WIN32 在所有的win32平台为TRUE,包括cygwin
开关选项

BUILD_SHARED_LIBS 控制默认的库编译方式。如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库 （可在t3中稍加修改进行验证）
CMAKE_C_FLAGS 设置C编译选项
CMAKE_CXX_FLAGS 设置C++编译选项
####cmake常用命令

#####基本语法规则：

cmake变量使用${}方式取值,但是在IF控制语句中是直接使用变量名

环境变量使用$ENV{}方式取值,使用SET(ENV{VAR} VALUE)赋值

指令(参数1 参数2...) 参数使用括弧括起,参数之间使用空格或分号分开。

以ADD_EXECUTABLE指令为例：
ADD_EXECUTABLE(hello main.c func.c)或者
ADD_EXECUTABLE(hello main.c;func.c)
指令是大小写无关的,参数和变量是大小写相关的。推荐你全部使用大写指令。

#####部分常用命令列表：

PROJECT PROJECT(projectname [CXX] [C] [Java]) 指定工程名称,并可指定工程支持的语言。支持语言列表可忽略,默认支持所有语言

SET SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 定义变量(可以定义多个VALUE,如SET(SRC_LIST main.c util.c reactor.c))

MESSAGE MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display" ...) 向终端输出用户定义的信息或变量的值 SEND_ERROR, 产生错误,生成过程被跳过 STATUS, 输出前缀为--的信息 FATAL_ERROR, 立即终止所有cmake过程

ADD_EXECUTABLE ADD_EXECUTABLE(bin_file_name ${SRC_LIST}) 生成可执行文件

ADD_LIBRARY ADD_LIBRARY(libname [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] SRC_LIST) 生成动态库或静态库 SHARED 动态库 STATIC 静态库 MODULE 在使用dyld的系统有效,若不支持dyld,等同于SHARED EXCLUDE_FROM_ALL 表示该库不会被默认构建

SET_TARGET_PROPERTIES 设置输出的名称,设置动态库的版本和API版本

CMAKE_MINIMUM_REQUIRED CMAKE_MINIMUM_REQUIRED(VERSION version_number [FATAL_ERROR]) 声明CMake的版本要求

ADD_SUBDIRECTORY ADD_SUBDIRECTORY(src_dir [binary_dir] [EXCLUDE_FROM_ALL]) 向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制的存放位置 EXCLUDE_FROM_ALL含义：将这个目录从编译过程中排除

SUBDIRS deprecated,不再推荐使用 (hello sample)相当于分别写ADD_SUBDIRECTORY(hello),ADD_SUBDIRECTORY(sample)

INCLUDE_DIRECTORIES INCLUDE_DIRECTORIES([AFTER | BEFORE] [SYSTEM] dir1 dir2 ... ) 向工程添加多个特定的头文件搜索路径,路径之间用空格分隔,如果路径包含空格,可以使用双引号将它括起来,默认的行为为追加到当前头文件搜索路径的后面。有如下两种方式可以控制搜索路径添加的位置：

CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过SET这个cmake变量为on,可以将添加的头文件搜索路径放在已有路径的前面
通过AFTER或BEFORE参数,也可以控制是追加还是置前
LINK_DIRECTORIES LINK_DIRECTORIES(dir1 dir2 ...) 添加非标准的共享库搜索路径

TARGET_LINK_LIBRARIES TARGET_LINK_LIBRARIES(target lib1 lib2 ...) 为target添加需要链接的共享库

ADD_DEFINITIONS 想C/C++编译器添加-D定义 ADD_DEFINITIONS(-DENABLE_DEBUG -DABC),参数之间用空格分隔

ADD_DEPENDENCIES ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) 定义target依赖的其他target,确保target在构建之前,其依赖的target已经构建完毕

AUX_SOURCE_DIRECTORY AUX_SOURCE_DIRECTORY(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中 把当前目录下的所有源码文件名赋给变量DIR_HELLO_SRCS

EXEC_PROGRAM EXEC_PROGRAM(Executable [dir where to run] [ARGS <args>][OUTPUT_VARIABLE <var>] [RETURN_VALUE <value>]) 用于在指定目录运行某个程序（默认为当前CMakeLists.txt所在目录）,通过ARGS添加参数,通过OUTPUT_VARIABLE和RETURN_VALUE获取输出和返回值,如下示例

# 在src中运行ls命令,在src/CMakeLists.txt添加
EXEC_PROGRAM(ls ARGS "*.c" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)
IF (not LS_RVALUE)
    MESSAGE(STATUS "ls result: " ${LS_OUTPUT}) # 缩进仅为美观,语法无要求
ENDIF(not LS_RVALUE)
INCLUDE INCLUDE(file [OPTIONAL]) 用来载入CMakeLists.txt文件 INCLUDE(module [OPTIONAL])用来载入预定义的cmake模块 OPTIONAL参数的左右是文件不存在也不会产生错误 可以载入一个文件,也可以载入预定义模块（模块会在CMAKE_MODULE_PATH指定的路径进行搜索） 载入的内容将在处理到INCLUDE语句时直接执行

FIND_

FIND_FILE(<VAR> name path1 path2 ...) VAR变量代表找到的文件全路径,包含文件名

FIND_LIBRARY(<VAR> name path1 path2 ...) VAR变量代表找到的库全路径,包含库文件名

FIND_LIBRARY(libX X11 /usr/lib)
IF (NOT libx)
    MESSAGE(FATAL_ERROR "libX not found")
ENDIF(NOT libX)
FIND_PATH(<VAR> name path1 path2 ...) VAR变量代表包含这个文件的路径

FIND_PROGRAM(<VAR> name path1 path2 ...) VAR变量代表包含这个程序的全路径

FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED | COMPONENTS] [componets ...]]) 用来调用预定义在CMAKE_MODULE_PATH下的Find<name>.cmake模块,你也可以自己定义Find<name> 模块,通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录供工程使用

IF 语法：

IF (expression)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ELSE (expression)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDIF (expression) # 一定要有ENDIF与IF对应
IF (expression), expression不为：空,0,N,NO,OFF,FALSE,NOTFOUND或<var>_NOTFOUND,为真 IF (not exp), 与上面相反 IF (var1 AND var2) IF (var1 OR var2) IF (COMMAND cmd) 如果cmd确实是命令并可调用,为真 IF (EXISTS dir) IF (EXISTS file) 如果目录或文件存在,为真 IF (file1 IS_NEWER_THAN file2),当file1比file2新,或file1/file2中有一个不存在时为真,文件名需使用全路径 IF (IS_DIRECTORY dir) 当dir是目录时,为真 IF (DEFINED var) 如果变量被定义,为真 IF (var MATCHES regex) 此处var可以用var名,也可以用${var} IF (string MATCHES regex)

当给定的变量或者字符串能够匹配正则表达式regex时为真。比如：
IF ("hello" MATCHES "ell")
    MESSAGE("true")
ENDIF ("hello" MATCHES "ell")
数字比较表达式 IF (variable LESS number) IF (string LESS number) IF (variable GREATER number) IF (string GREATER number) IF (variable EQUAL number) IF (string EQUAL number)

按照字母表顺序进行比较 IF (variable STRLESS string) IF (string STRLESS string) IF (variable STRGREATER string) IF (string STRGREATER string) IF (variable STREQUAL string) IF (string STREQUAL string)

一个小例子,用来判断平台差异：
IF (WIN32)
    MESSAGE(STATUS “This is windows.”)
ELSE (WIN32)
    MESSAGE(STATUS “This is not windows”)
ENDIF (WIN32)
上述代码用来控制在不同的平台进行不同的控制,但是,阅读起来却并不是那么舒服,ELSE(WIN32)之类的语句很容易引起歧义。
可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
这时候就可以写成:
IF (WIN32)
ELSE ()
ENDIF ()
配合ELSEIF使用,可能的写法是这样:
IF (WIN32)
    #do something related to WIN32
ELSEIF (UNIX)
    #do something related to UNIX
ELSEIF(APPLE)
    #do something related to APPLE
ENDIF (WIN32)
WHILE 语法：

WHILE(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDWHILE(condition)
其真假判断条件可以参考IF指令

FOREACH FOREACH指令的使用方法有三种形式：

列表 语法：
FOREACH(loop_var arg1 arg2 ...)
      COMMAND1(ARGS ...)
      COMMAND2(ARGS ...)
    ...
ENDFOREACH(loop_var)
示例：

AUX_SOURCE_DIRECTORY(. SRC_LIST)
FOREACH(F ${SRC_LIST})
      MESSAGE(${F})
ENDFOREACH(F)
范围 FOREACH(loop_var RANGE total) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var)
从0到total以１为步进
FOREACH(VAR RANGE 10)
      MESSAGE(${VAR})
ENDFOREACH(VAR)
输出：
0
1
2
3
4
5
6
7
8
9
10
范围和步进 语法：
FOREACH(loop_var RANGE start stop [step])
       COMMAND1(ARGS ...)
       COMMAND2(ARGS ...)
       ...
ENDFOREACH(loop_var)
从start开始到stop结束,以step为步进, **注意：**直到遇到ENDFOREACH指令,整个语句块才会得到真正的执行。

FOREACH(A RANGE 5 15 3)
       MESSAGE(${A})
ENDFOREACH(A)
输出：
5
8
11
14
####cmake中如何生成动态库和静态库 参考ADD_LIBRARY和SET_TARGET_PROPERTIES用法 t3示例

####cmake中如何使用动态库和静态库（查找库的路径） 参考INCLUDE_DIRECTORIES, LINK_DIRECTORIES, TARGET_LINK_LIBRARIES用法 t4示例使用动态库或静态库 t5示例如何使用cmake预定义的cmake模块(以FindCURL.cmake为例演示) t6示例如何使用自定义的cmake模块(编写了自定义的FindHELLO.cmake) 注意读t5和t6的CMakeLists.txt和FindHELLO.cmake中的注释部分

####cmake中如何指定生成文件的输出路径

如上ADD_SUBDIRECTORY的时候指定目标二进制文件输出路径（推荐使用下面这种）
使用SET命令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量来指定最终的二进制文件的位置
SET(EXECUTABLE\_OUTPUT\_PATH ${PROJECT\_BINARY\_DIR}/bin)
SET(LIBRARY\_OUTPUT\_PATH ${PROJECT\_BINARY\_DIR}/lib)
上面的两条命令通常紧跟ADD_EXECUTABLE和ADD_LIBRARY,与其写在同一个CMakeLists.txt即可

####cmake中如何增加编译选项 使用变量CMAKE_C_FLAGS添加C编译选项 使用变量CMAKE_CXX_FLAGS添加C++编译选项 使用ADD_DEFINITION添加

####cmake中如何增加头文件路径 参考INCLUDE_DIRECTORIES命令用法

####cmake中如何在屏幕上打印信息 参考MESSAGE用法

####cmake中如何给变量赋值 参考SET和AUX_SOURCE_DIRECTORY用法

建议：在Project根目录先建立build,然后在build文件夹内运行cmake ..，这样就不会污染源代码, 如果不想要这些自动生成的文件了，只要简单的删除build文件夹就可以
* 什么是c 
  声明先于函数/数据定义  头文件, 搜索的当前目录, 相对路径
  函数/数据 库文件  .o  .so , 加载不用管, 自动的
  gcc -g main.c lib.o otherlib.c 
  编译 gcc -c 
** 程序结构
*** 预处理器指令
   函数
   变量
   数组 {}
   定义 int i; //声明，也是定义
   声明 extern int i; //声明，不是定义
   常量 使用 #define 预处理器。 //预处理器会处理掉,不用编译器处理 |  使用 const 关键字。
   C 存储类 定义 C 程序中变量/函数的范围（可见性）和生命周期
**** auto 存储类是所有局部变量默认的存储类
**** register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量,最大尺寸等于寄存器的大小
: 不能对它应用一元的 '&' 运算符（因为它没有内存位置
**** static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁
**** extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
语句 & 表达式
注释 /* comment */ or //
C 结构体
#+BEGIN_SRC c
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables]; 
#+END_SRC
C 共用体
#+BEGIN_SRC c
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];  
#+END_SRC
C 位域 (节省空间)
#+BEGIN_SRC c
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
#+END_SRC
C typedef (别名)
: typedef unsigned char BYTE;
*** C 输入 & 输出
**** getchar() & putchar() 函数
int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。
int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。
**** gets() & puts() 函数
char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。
int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。
**** scanf() 和 printf() 函数
     int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。
int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。
*** C 文件读写
**** 打开 FILE *fopen( const char * filename, const char * mode );
**** 关闭 int fclose( FILE *fp );
**** 写入 int fputc( int c, FILE *fp ); /int fputs( const char *s, FILE *fp );
**** 读取 char *fgets( char *buf, int n, FILE *fp );
*** 头文件
#+BEGIN_SRC c
#ifndef HEADER_FILE
#define HEADER_FILE
the entire header file file
#endif
#+END_SRC
**** 多系统
#+BEGIN_SRC c
 #define SYSTEM_H "system_1.h"
 ...
 #include SYSTEM_H
#+END_SRC
*** C 错误处理
    : 大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 <error.h> 头文件中找到各种各样的错误代码。
    : 开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。
**** perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
**** strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
**** 程序退出状态
*****  exit(EXIT_FAILURE) 调用系统宏
*****  exit(EXIT_SUCCESS)
*** 内存管理 动态内存分配与管理 <stdlib.h>
**** void *calloc(int num, int size);该函数分配一个带有 num 个元素的数组，每个元素的大小为 size 字节。
**** void free(void *address);该函数释放 address 所指向的h内存块。
**** void *malloc(int num);该函数分配一个 num 字节的数组，并把它们进行初始化。
**** void *realloc(void *address, int newsize);该函数重新分配内存，把内存扩展到 newsize。
     
对于长的 先是 l 然后是 符号位， 跟定义时一样
* 什么是gcc 基于C/C++的预处理器和编译器
  -o：指定生成的输出文件,所以编译多个文件是,-o 没有意义；
  -E：仅执行编译预处理； .i
  -S：将C代码转换为汇编代码；.s
  -wall：显示警告信息；
  -c：仅执行编译操作，不进行连接操作。.o
** 1. 预处理 gcc -E test.c -o test.i
   -C:
   -H:
   -include:
** 2. 编译为汇编代码   gcc -S test.i -o test.s
   masm=intel	汇编代码 
   -std 指定使用的语言标准
** 3. gas  gcc -c test.s -o test.o
   :-Wa,option
   :-llibrary 连接名为library的库文件
   :-L 指定额外路径
   :-m32
** 4. ld  gcc test.o -o test
   :-lobjc 这个-l选项的特殊形式用于连接Objective C程序.
   :-nostartfiles 不连接系统标准启动文件,而标准库文件仍然正常使用.
   :-nostdlib 不连接系统标准启动文件和标准库文件.只把指定的文件传递给连接器.
   :-static 在支持动态连接(dynamic linking)的系统上,阻止连接共享库.该选项在其他系统上无效.
   :-shared 生成一个共享目标文件,他可以和其他目标文件连接产生可执行文件.只有部分系统支持该选项.
   :-symbolic 建立共享目标文件的时候,把引用绑定到全局符号上.对所有无法解析的引用作出警
   告(除非用连接编辑选项 `-Xlinker -z -Xlinker defs'取代).只有部分系统支持该选项.
   :-u symbol 使连接器认为取消了symbol的符号定义,从而连接库模块以取得定义.你可以使用多
   个 `-u'选项,各自跟上不同的符号,使得连接器调入附加的库模块.
   : [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
   : -lAR	在连接文件列表中增加归档库文件AR.可以多次使用这个选项. 凡指定一项AR,ld 就会在路径列表中增加一项对libar.a的搜索.
   : -LSEARCHDIR   这个选项将路径SEARCHDIR添加到路径列表, ld在这个列表中搜索归档库.
   可以多次使用这个选项.缺省的搜索路径集(不使用-L时)取决于ld使用的
   模拟模式(emulation)及其配置.在连接脚本中,可以用SEARCH_DIR命令指定路径. 
   : -Tbss org
   : -Tdata org
   : -Ttext org
   把org作为输出文件的段起始地址 --- 特别是 --- bss,data,或text段.org必须是十六进制整数. 
   : -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
   : -x    删除 全部 局部符号. 
   : -m 指定仿真环境,这里要与gcc 的选项 -m32一致; -V显示 支持的仿真：本机支持   elf_x86_64   
   elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
   LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
   : 注意,如果连接器通过被编译器驱动来间接引用(比如gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
   gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
   : `-b INPUT-FORMAT'
   `--format=INPUT-FORMAT' [binary]
   'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
   你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
   : `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld的缺省输出格式配置
   为/各个机器上最常用的/ 格式. output-format是一个 字符串,BFD库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
   : [`-N']|[`--omagic']
   把text和data节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
   支持Unix风格的magic number, 把输出标志为'OMAGIC'. 
** 5. 检错
   : -Wall 产生尽可能多的警告信息
   : -Werror GCC会在所有产生警告的地方停止编译
** 6. 库文件连接 .a .so
   : 包含文件 -I /usr/dirpath    
   : 库   -L /dirpath   -llibname  不要.a 或.so 后缀
   : 强制静态库 gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
   静态库链接时搜索路径顺序：
   1. ld会去找GCC命令中的参数-L
   2. 再找gcc的环境变量LIBRARY_PATH
   3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的

   动态链接时、执行时搜索路径顺序:
   1. 编译目标代码时指定的动态库搜索路径
   2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
   3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
   4. 默认的动态库搜索路径/lib
   5. 默认的动态库搜索路径/usr/lib
   有关环境变量：
   LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径
   LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径
** 7. 调试
   -g:
   -gstabs:
   -gcoff:
   -gdwarf:
** 8. 优化
   -O0 不优化
   -fcaller-saves: 
** 9. 目标机选项(Target Option) 交叉编译
   -b machine 
   -V version 哪个版本的gcc
** 10.配置相关选项(Configuration Dependent Option)
   M680x0 选项
   i386选项
** 11.总体选项(Overall Option)
   -x language
   明确指出后面输入文件的语言为language (而不是从文件名后缀得到的默认选择).

** 12.目录选项(DIRECTORY OPTION)
   :-Idir 在头文件的搜索路径列表中添加dir 目录.
   :-Ldir 在`-l'选项的搜索路径列表中添加dir目录.

** 13.C 文件与 汇编文件编译
   以下涉及到不同编译器对符号的处理问题。比如我们写个汇编文件，汇编后，汇编文件中的符号未变，但是当我们写个C文件再生成目标文件后，源文件中的符号前可能加了下划线，当两者之间发生引用关系时可能无法连接，此时我们会用到下面的命令。
   : --change-leading-char
   : --remove-leading-char
   : --prefix-symbols=string
* 什么是对的C语言？ 对的数据（语言)通过编译器 输出对的数据
* 什么是文档生成工具？ 帮助文档不要了吗？
* 什么是c 的一般用途？ 用来生成中间库，用makefile管理, 不做界面这种活， 
* 什么是重构？ 后期动态修改代码的思想（比如 多次使用的数字 最后用 宏替换）
* 什么是C 仅有的四种数据类型？ 整型、浮点型、指针型和聚合类型（包含数组和结构体）
* 什么是符号？ 符号位 和 原码，反码，补码, 可以构造出有符号的数
* 什么是C 语言的 limits.h文件? 不同平台 int /char/short/long/long long 表示的值不同，所以定义了专门的最大最小宏 用来测试
  [[file:image/intmacro.png][宏定义]] 
* 什么是 limits.h 的位置？ 位置在 /usr/include下
* 什么是 溢出？ 数学符号在运算后超出限定，出错的情况
* 什么是 溢出的危害？ c语言在运行时，不会进行溢出检查，所以要特别小心
* 什么是隐式数据转换带来的溢出危害？ 类型转换后进行运算会发生错误
* 什么是预防溢出？ 避免在一个表达式中使用 有符号与无符号 运算
* 什么是char? 早期计算机使用的是ASCII码，没有中文，历史产物
* 什么是getchar()? getchar()会返回int型，因为EOF被定义为-1，如果是char，则可能是无符号型，则永不停止
* 什么是判断char 是否有符号？ 可以用CHAR_MIN 输出 printf("%d", CHAR_MIN)
* 什么是计算机小数？ 用二进制形式来表示小数的方式
* 什么是浮点数的精度？ 在 float.h文件中，FLT_MAX, FLT_MIN [[file:image/float.png][浮点]] 
* 什么是有符号浮点的printf 表示？ %f 是无符号，%e是有符号 2e+2 e表示10的2次方
* 什么是浮点的比较？ fabs()<FLT_EPSILON
* 什么是常量后缀？ 10UL 增加可读性,和编译器的解释的正确性
* 什么是sizeof ? 以字节为单位，用来跨平台，因为不同平台int不同，所以，用sizeof 能确切计算int 的值
* 什么是i++ 和++i的区别？ 只在表达式中，
前缀运算符首先增加变量的值，然后复制一份拷贝；而后缀运算符首先复制一份拷贝，再增加变量的值
m=*p++; /* 等价于下面两个语句 */
分解成*(p++) *(p+1)
因为是后缀，先求拷贝, 则成为下面的形式

m=*p;
p++;

* 什么是流？ 通过opening来关联，closing 取消关联. 用 FILE * 定义.
* 什么是getchar() putchar()? 输入一个字符, 输出一个字符
* 什么是gets() puts() ？ 字符串
* 什么是scanf? 格式化输入函数, 
当使用scanf 输入short 类型整数、long 类型整数、以及double 类型浮点数的时候，一定要使用与之对应的正确的格式修饰符，分别为“%hd”，“%ld”，以及“%lf”。
* 什么是复杂的函数？ 会写吗？ 有的函数很复杂的
* 什么是缓冲区？ 在输入中，有一块内存作为你输入东西的地方, 里面有东西在, 而scanf等输入读取的是缓冲中的内容直到缓冲空，让你重新输入
  键盘输入都被保存在输入缓冲区内，直到用户输入回车，输入函数才去缓冲区读取。输入函数从缓冲区读取时，如果缓冲区为空，程序会暂停；否则输入函数会从缓冲区读入对应的数据。
  利用gets 读入字符串时，空格和tab 都是字符串的一部分。gets 以回车和EOF 为字符串的终止符，同时把回车从缓冲区读走。
  掌握利用while 循环清空缓冲区的方法，但是不要用fflush(stdin)。
  如果你的程序要求对用户输入的各种不规范格式或错误要求有很高的容错程度，尝试一下fgets 和sscanf 的组合来完成用户输入的读取。
* 什么是溢出攻击？ 输入的对象越过边界到内存的其他区域, 
* 什么是安全的字符串输入函数？ fgets(char * str, int num, FILE * stream)
* 什么是条件编译？ 可以设定一些东西，预处理器会判断这些东西
* 什么是static? 不管在哪？都不会挂掉，相当于一直存在的东西, 但还有隐私属性
 [[file:image/static.png][static]] 
* 什么是编译器和链接器？ 编译器少做了定位的事情, 给链接器做了
* 什么是头文件？ 头文件中只应该包含那些不申请内存的声明语句, 如果包含了变量，可能会造成变量的重复定义
* 什么是name mangle（乱砍）？ C++中有
* 什么是 查找库函数？ linux 下 man, 最方便 google
* 什么是数学相关库函数？
  int        abs(int i)                      返回整型参数i的绝对值
double    cabs(struct complex znum)        返回复数znum的绝对值
double    fabs(double x)                   返回双精度参数x的绝对值
long      labs(long n)                     返回长整型参数n的绝对值
double     exp(double x)                   返回指数函数ex的值
double frexp(double value,int *eptr)     返回value=x*2n中x的值,n存贮在eptr中
double ldexp(double value,int exp);      返回value*2exp的值
double     log(double x)                   返回logex的值
double log10(double x)                   返回log10x的值
double     pow(double x,double y)          返回xy的值
double pow10(int p)                      返回10p的值
double    sqrt(double x)                   返回+√x的值
double    acos(double x)                   返回x的反余弦cos-1(x)值,x为弧度
double    asin(double x)                   返回x的反正弦sin-1(x)值,x为弧度
double    atan(double x)                   返回x的反正切tan-1(x)值,x为弧度
double atan2(double y,double x)          返回y/x的反正切tan-1(x)值,y的x为弧度
double     cos(double x)                   返回x的余弦cos(x)值,x为弧度
double     sin(double x)                   返回x的正弦sin(x)值,x为弧度
double     tan(double x)                   返回x的正切tan(x)值,x为弧度
double    cosh(double x)                   返回x的双曲余弦cosh(x)值,x为弧度
double    sinh(double x)                   返回x的双曲正弦sinh(x)值,x为弧度
double    tanh(double x)                   返回x的双曲正切tanh(x)值,x为弧度
double hypot(double x,double y)          返回直角三角形斜边的长度(z),
                                         x和y为直角边的长度,z2=x2+y2
double    ceil(double x)                   返回不小于x的最小整数
double floor(double x)                   返回不大于x的最大整数
void     srand(unsigned seed)              初始化随机数发生器
int       rand()                           产生一个随机数并返回这个数
double    poly(double x,int n,double c[])从参数产生一个多项式
double    modf(double value,double *iptr)将双精度数value分解成尾数和阶
double    fmod(double x,double y)          返回x/y的余数
double frexp(double value,int *eptr)     将双精度数value分成尾数和阶
double    atof(char *nptr)                 将字符串nptr转换成浮点数并返回这个浮点数
double    atoi(char *nptr)                 将字符串nptr转换成整数并返回这个整数
double    atol(char *nptr)                 将字符串nptr转换成长整数并返回这个整数
char     *ecvt(double value,int ndigit,int *decpt,int *sign)
           将浮点数value转换成字符串并返回该字符串
char     *fcvt(double value,int ndigit,int *decpt,int *sign)
           将浮点数value转换成字符串并返回该字符串
char     *gcvt(double value,int ndigit,char *buf)
           将数value转换成字符串并存于buf中,并返回buf的指针
char    *ultoa(unsigned long value,char *string,int radix)
           将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数
char     *ltoa(long value,char *string,int radix)
           将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数
char     *itoa(int value,char *string,int radix)
           将整数value转换成字符串存入string,radix为转换时所用基数
double atof(char *nptr) 将字符串nptr转换成双精度数,并返回这个数,错误返回0
int      atoi(char *nptr) 将字符串nptr转换成整型数,    并返回这个数,错误返回0
long     atol(char *nptr) 将字符串nptr转换成长整型数,并返回这个数,错误返回0
double strtod(char *str,char **endptr)将字符串str转换成双精度数,并返回这个数,
long     strtol(char *str,char **endptr,int base)将字符串str转换成长整型数,
                                                 并返回这个数,
int            matherr(struct exception *e)
                用户修改数学错误返回信息函数(没有必要使用)
double         _matherr(_mexcep why,char *fun,double *arg1p,
                        double *arg2p,double retval)
                  用户修改数学错误返回信息函数(没有必要使用)
unsigned int _clear87()     清除浮点状态字并返回原来的浮点状态
void           _fpreset()     重新初使化浮点数学程序包
unsigned int _status87()    返回浮点状态字

* 什么是字符串相关库函数？
* 什么是字符和数字转换库函数？
* 什么是时间函数库函数？
* 什么是 多使用库函数？ 库函数有很多复杂的功能函数，要善于利用，不用重复造轮子
* 什么是 system, signal 函数?
* 什么是 数组初始化函数？ memset(array, 0, sizeof(array))
* 什么是 memcpy? 拷贝，就不用赋值了，慢
* 什么是release 和 debug? release 通常不进行边界检查, 而debug 会
  gcc -DDBUG
* 什么是 指针 指向？ 如果还不知到指针指向哪？就指向NULL
* 什么是typedef struct? 为定义的结构赋予新名字
  #+BEGIN_SRC c
  typedef struct student{
    char *name;
    unsigned int age;
    char *address;
  } STU;
  STU student1;
  student1.name="wuming";
  student1.address="wuxi jiangyin";
  printf("%s\n",student1.address);
  #+END_SRC
  方法2:
 #+BEGIN_SRC c
   程序11-3 利用结构类型定义变量
    
   struct student{
   int num;
   char name[20];
   ...
   } student1,student2;
    
   struct student student3; /* 定义student3变量 */

 #+END_SRC 
* 什么是结构体中的洞？ 结构体是内存对齐的，所以可能会浪费内存
* 什么是assert? void assert(int expression) 判断表达式逻辑值
  #define NDEBUG 禁用 assert
* 什么是面向对象中的错误处理？ 语句 try catch
