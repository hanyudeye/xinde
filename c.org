* 编程实践中C语言的一些常见细节
　　对于C语言，不同的编译器采用了不同的实现，并且在不同平台上表现也不同。脱离具体环境探讨C的细节行为是没有意义的，以下是我所使用的环境，大部分内容都经过测试，且所有测试结果基于这个环境获得，为简化起见，省略了异常处理。我不希望读者死记硬背这些细节，而是能在自己的平台上进行实验从而获得对应的结果。另外，本文仅仅关注于C，可能会考虑C++的表现，但在C++和C#环境下的编译器所获得的看似C代码而实不同的结果不作为参考。基础的东西比如“函数参数传值”、“转义字符”、“else的最近配对”、“case的下落(fall through)”、“符号常量NULL代表常量0”、“restrict关键字”、“使用%p输出指针”、“const的指针常量和常量指针”等本文不会重复。

　　了解这些细节并在自己的平台上进行实验并不是鼓励你去写模棱两可、过于依赖平台和实现的代码（除非有非这么做不可的必要），而是对这种代码有鉴别能力和理解能力，尽量避免和修正。

　　另外，在其他平台上的不同行为欢迎列出，但不会对原文中实现相关、机器相关的细节的具体表现进行补充说明。

　　如有错误，恳请指正。由于目前时间有限，可能不能及时回复，请谅解。

 

编译器：gcc 4.4.3，默认无任何编译选项。

编译环境：Ubuntu10.04LTS,32x86

标准：默认为ISO C99的GNU方言，不使用任何-std=选项

以下是该环境中man gcc的部分结果：

-std=
Determine the language standard. This option is currently only supported when compiling C or C++.

The compiler can accept several base standards, such as c89 or c++98, and GNU dialects of those standards,
such as gnu89 or gnu++98. By specifying a base standard, the compiler will accept all programs following
that standard and those using GNU extensions that do not contradict it. For example, -std=c89 turns off
certain features of GCC that are incompatible with ISO C90, such as the "asm" and "typeof" keywords, but
not other GNU extensions that do not have a meaning in ISO C90, such as omitting the middle term of a "?:"
expression. On the other hand, by specifying a GNU dialect of a standard, all features the compiler
support are enabled, even when those features change the meaning of the base standard and some strict-
conforming programs may be rejected. The particular standard is used by -pedantic to identify which
features are GNU extensions given that version of the standard. For example -std=gnu89 -pedantic would
warn about C++ style // comments, while -std=gnu99 -pedantic would not.

A value for this option must be provided; possible values are

 

...

gnu89
GNU dialect of ISO C90 (including some C99 features). This is the default for C code.

gnu99
gnu9x
GNU dialect of ISO C99. When ISO C99 is fully implemented in GCC, this will become the default. The name gnu9x is deprecated.

...

　　gcc4.4.3是2010年发布的，编译器所采用标准的判断来自于最后一行。

　　另外，为了进行对照，个别实例会使用Clang进行补充。

 

主要参考资料：

　　为了不因不同标准而导致混淆，对于参考资料的引用都将注明出处的简称。

1.The C Programming Language 2nd edition，《C程序设计语言（英文版·第2版）》，Brian W. Kernighan & Dennis M. Ritchie 著，以下简称K&R

此书被誉为C语言圣经。第2版针对的是1988年的ANSI C，因此并没有一些后续C标准的变化细节（The C Programming Language 英文维基）。

2.C: A Reference Manual 5th edition，《C语言参考手册（原书第五版）》，Samuel Harbison III & Guy L. Steele Jr.著，徐波译，机械工业出版社，以下简称CARM

优秀的案头参考手册。涵盖了传统C、C89、C89修正案1和C99（此书译者序）。 遗憾的是中文版没有英文版的术语索引（Index）。

3.ISO/IEC 9899:1999，以下简称C99或C99标准

由于使用的编译器和环境而作为权威的参考。

 

一、编程细节：
细节1：printf的参数必须使用\n换行(newline)而不是在参数里使用回车。

来源：K&R 1.1,P7

printf("hello,world
            ");
结果：

　　编译器Error。

 

细节2：printf使用了格式化控制符%d但没有对应参数

来源：某公司面试题

printf("%d\n");
结果：

　　编译器warning: too few arguments for format

　　运行时显示一个随机值。

对照：

　　使用clang，提示 1 diagnostic generated.

　　运行时总是显示0。

分析：

　　K&R提到，如果参数不够，会FAIL。C99则把这认定为未定义行为（可参见C99标准中的fprintf部分，它的行为与printf类似）。

相关：

　　%s对于" "和""的处理演示。我不确定是否实现相关或者未定义行为。

 

printf("%s|\n%s|\n"," ","");
 

　　输出:

 |
|

 

 

细节3： getchar()返回值是int，而非char；兼谈char型是否有符号及EOF的值

分析：

　　(c  =getchar())!=EOF常用于判断输入是否结束，而char的范围不一定能容纳EOF，因此用int接收返回值。

　　C99：char用于存放基本执行字符集（basic execution character set）时，其值应（is guaranteed to）为正（但0字符应(shall)在基本执行字符集，似乎有点冲突，或许shall可以作为“可以”？）。其他存放于char的字符的值由实现定义。

　　EOF具体的值在<stdio.h>中定义，但具体数值不重要，只要和char不同即可（K&R）。C99标准将其实现为一个int型负值的宏。

　　有的实现将EOF定义为-1，这对char是unsigned时和上面的要求相同。有的编辑器将char实现为signed char（如gcc4.4.3），在这种情况下或许使用char型也可以接受getchar()的返回值，但可移植性就不如用int更好。你可以在自己的环境里试试char的是否有符号。

char c;
c = -1;
if (c<0)
    printf("oops,char is signed.\n");
else
    printf("char is unsigned.\n"); 
　　或者，你也可以使用signed char和unsigned char这样的声明来提高可移植性。（P44，K&R）

　　至于怎么输入一个无法输入的EOF？试试Ctrl+Z或者Ctrl+D吧，这也是和平台实现相关的。

 

细节4：i++,++i；副作用side effect

　　来看看K&R的英文描述：But the expression ++n increments n before its value is used, while n++ increments n after its value has been used.很清晰对不对？

 　　另外，自增和自减运算符只能用于变量，(i+j)++是非法的。

　　CARM明确说明它们的操作数必须是可修改的左值，可以是任何算术类型或指针类型。

 

细节5：char、short、int和long的精度；float、double、long double

分析：

　　标准C指定了char至少必须达到8位、short至少为16位、long至少32位、long long至少64位，int是16位还是32位以及前几个的具体精度与机器位数和实现有关，可以在<limits.h>中查看它们的范围。（CARM）

　　一些具体实现里这些数据类型的精度：将 Linux 应用程序移植到 64 位系统上，如果你之前有记住所有实现中数据长度的雄心壮志，看到这个表也会放弃吧？了解自己常用平台上的即可，而且，要非常熟悉。对自己平台都不了解，空谈标准、大小关系，没什么意思。（我以前犯过这个错误）

　　另外，short和long后面的int可以省略。（K&R）

　　 float、double、long double的大小是实现定义的，它们可能是3种、2种或者同1种类型（K&R）。

 

细节6：C中到底有没有bool型

分析：

　　C99标准提供了宏bool，它将被展开为_Bool。使用这个类型以及true和false需要<stdbool.h>的支持。其大小与实现相关，我的环境中测试的结果是1个字节。

　　使用这个宏的好处是，再也不用自己#define TRUE 1等等这样定义了。

　　当然，如果你遇到了一些死板的笔试题问你C是否有bool型？并且，恰好是单选、同时其他选项无比正确、明摆着在诱拐你选择这一项，那只好舍弃节操委曲求全地说“没有”了。

 

细节7：逻辑求值中||和&&的终止条件

分析：

　　从左往右，一旦整个表达式结果可得即停止运算（K&R）。即一系列||中有一个为真时，后续则不再计算，&&则相反。

　　顺便提一下它们的结合性都是从左到右，而&&高于||。（CARM）

　　我就不在这里刻意地构造复杂的&&和||表达式来考验自己和诸位读者的能力了。为了代码可读性，实践中我也不会刻意地把逻辑表达式弄得太复杂，看情况加括号便是。

 

细节8：函数定义中，如果返回值类型为int，那么它可以被省略。（K&R，已测）

 

细节9：extern变量

分析：

　　（K&R）

　　在函数“外部”定义的变量，定义时不需要加extern关键字。如果函数需要使用，需要一个显式或隐式的extern的声明。

　　简而言之，一种用法是在函数内使用extern声明；

　　另一种是将变量定义在源文件的所有函数之前，这时函数中使用这个变量时就不需要再进行声明，这只适用于单一文件。

　　多文件时，最好把各个文件都会用到的外部变量写入.h文件，并进行头文件包含，这时函数内使用外部变量可以省略extern声明。

　　请注意定义和声明的区别。前者指变量被创建或分配空间的位置(the place where the variable is created or assigned storage)，后者是陈述变量特性但不分配空间的代码中的地方。

 

细节10：strlen()不计算'\0'。（K&R）

 

细节11：枚举名必须不同，但值可以相同。（K&R）

 

细节12：取模%不能用于float和double。负数运算时，/的截取方向和%的符号取决于机器，其上溢和下溢时采取的动作也取决于机器。（K&R）

 

细节13：>、>=、<、<=比==和!=高一级。

 

细节14：常用的c + 'a' - 'A'这种大小写转换等类似形式在ASCII中是适用的，但在EBCDIC编码中是不适用的。（K&R）

 

细节15：移位运算

　　<<和>>的两个操作数都是整数，并且右操作数应该是(must be)非负的。（K&R）

　　事实上，C99表示，如果右操作数为负，或者移位的位数大于数据的位数，是未定义行为。更详细的规定：

　　对于E1<<E2，如果E1是无符号型，那么结果是E1 * 2E2，当超过该类型最大值时取模；如果E1是有符号型且非负，并且E1 * 2E2可以在该类型中表示，那么它就是结果，其它情况下则是未定义行为。

　　对于E1>>E2，如果E1是无符号型或者E1有符号且非负，那么结果是E1除以2的E2次幂的整数除法结果；如果E1有符号且为负值，结果值是实现定义的。

 

细节16：取反的好处——更独立于字长

分析：

　　为取得x的最低六位，与x &~077相比，x &0177700假定x是16位的，可移植性显然不如前者。

 

细节17：赋值表达式相当于自带括号，即 x *= y+1相当于x = x*(y+1)，而非x = x *y +1。赋值语句的值是左分量的值。（K&R）

 

细节18：三目表达式expr1 ?expr2 :expr3 的求值顺序和表达式的值与类型

分析：（K&R）

　　先计算，expr1 ，非0时计算expr2 ，并作为表达式的值；为0时计算expr3并作为表达式的值。

　　表达式的值的类型由expr2和expr3二者的类型共同决定，其转换规则与一般的不同类型值进行运算的转换规则一致。

　　

细节19：求值顺序与副作用

分析：

　　C并没有指定一个运算符两边运算数的计算顺序（&& ,   ||    , ?:以及','除外），即类似于x = f()+g()的表达式中，f()和g()的计算顺序未知先后。（K&R）另外，这里的','不是函数参数声明中的','，前者由左向右计算，后者不保证运算顺序。（K&R）

　　同样地，参数的计算顺序也是未知的，比如printf("%d %d\n",++n,power(2,n));它的具体结果和编译器有关。（K&R）

　　对于第二条，如果你以关键词“printf” "参数压栈"进行搜索，会发现广为流传的说法“printf参数压栈从右向左”。

　　副作用(side effect)——作为表达式的副产品，改变了变量的值。a[i]=i++，数组的下标是新值还是旧值，不同的编译器有不同的解释。标准明确规定了所有变元的副作用必须在该函数调用前生效，但对于上文printf的解释没有什么好处。（K&R）

　　不过我还是在自己的平台上测试了一下：

int i,j,k;
i=j=6;
k=2;
printf("%d %d %d\n",i++,--j,k+=j);
　　输出：6 5 8

 

细节20：switch () ... case ...语句中，switch后必须是整数表达式，case 后必须是整型常量或者常量表达式。（C99）

 

细节21：无参数的函数，其声明的参数表请用(void)，有参数就说明它们。直接用func()进行声明只是为了与较老的程序兼容，这会导致函数参数检查被关闭，最好不要这么做。（K&R）

分析：

　　以下代码运行无误（CARM）：

 

复制代码
int f() {
    printf("in f()\n");
    return 0;
}

main(){
    f(1,2);
    return 0;
}
复制代码
补充：

　　C++中int f()声明等价于int f(void)。

 

 

细节22：对于一个return值类型为double的函数func()，使用int a = (int) func()可以屏蔽warning。（K&R）

补充：

　　下面这两种编程实践哪个更好？

int*sieve = malloc(sizeof(int)*length);        //case 1
int *sieve = (int *)malloc(sizeof(int)*length);//case 2
　　比较信服的答案是，第一种更好：http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc

void会自动转换为所需类型；
如果忘记包含<stdlib.h>这会隐藏一个导致崩溃的bug；
如果指针类型比较复杂而不仅仅是int*，会导致该行过长，降低了可读性；　　
前后进行了重复，一般情况下是不好的。
　　关于第一条，K&R提到，Any pointer can be cast to void* and back again without loss of information。

　　关于第四条，K&R还有一例可证：yyval[yypv[p3+p4] + yypv[p1+p2]] += 2要强于yyval[yypv[p3+p4] + yypv[p1+p2]] =  yyval[yypv[p3+p4] + yypv[p1+p2]] + 2。虽然你在第一次编码时可以用复制粘贴的方式保证前后一致，但如果其中有错误，或者要进行修改，那么你要付出两倍的工作量。

 

细节23：C99支持变长数组，即运行时才决定大小的数组。

scanf("%d",&n);
int array2[n];
更多细节：

　　（CARM）

　　使用typedef定义变长数组时，只求值一次。 

/*假定此时n=5*/
typedef int[n] vector;
n+=1;
vector a; //a的容量是5
int b[n];  //b的容量是6
 

　　变长数组可以作为函数参数类型，但其长度参数必须先于数组名出现。

void f(int r,int c, int a[r][c]) //OK
void f(int a[r][c],int r,int c) //WRONG
 

 

细节24：static声明将变量或函数的作用域限制为它们出现的文件的其余部分。（K&R）

分析：

　　不要与C++中的static搞混，后者除了这种功能，还用于修饰静态成员变量/函数。（我的这个叙述存疑）

 

细节25：register只用于修饰自动变量和函数形参。（K&R）同时，register是函数参数中唯一可以出现的存储类指定符。

 

细节26：未显式初始化时，外部变量和静态变量都被初始化为0，而自动变量与寄存器变量中的值未定义，即“垃圾”。前两者必须用常量表达式初始化。（K&R）

 

细节27：数组初始化时，如果初始化符比数组容量小，未指定的元素在作为外部变量、静态变量、自动变量时被初始化为0。（K&R）

 

细节28：取地址运算符&只能用于内存中的对象（变量和数组元素），不能对表达式、常量或寄存器变量进行操作。（K&R）

 

细节29：标准要求main函数参数表中argv[argc]为null指针。（K&R、C99）

 

细节30：struct point *pp，可以用(*pp).x访问它的成员。（不仅限于pp->x） （K&R）

 

细节31：sizeof()不能用于#if，但可以用于#define。（K&R）

补充：

　　（CARM）





 

细节32：联合union的大小要足以容纳其最大的成员，但具体的大小是取决于实现的。联合只能用第一个成员类型初始化。（K&R）联合的尾部可能需要进行填充。（CARM）

 

细节33：字段（bit-fields）几乎所有属性都取决于实现；字段不是数组，也没有地址，不能使用&运算符。（K&R）

测试：

　　对字段使用&编译器直接报Error。

 

细节34：scanf使用%c读取下一个字符（缺省为1）存入指定位置。通常不跳过空白符（空格、制表符、换行符）。为读入下一个非空白符，使用%1s。

 

细节35：不确定输入格式时的一个小技巧（K&R）

复制代码
 while (getline(line, sizeof(line)) > 0) {
       if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
           printf("valid: %s\n", line); /* 25 Dec 1988 form */
       else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
           printf("valid: %s\n", line); /* mm/dd/yy form */
       else
           printf("invalid: %s\n", line); /* invalid form */
   }
复制代码
原理：

　　scanf函数使用完了格式输入串或当一些输入无法与控制说明相匹配时，就停止运行，并返回成功匹配和赋值的输入项的个数。

 

以下部分来自于我读CARM时的笔记，重要性个人认为不如前35条。

 

细节36：如果不发生溢出，整型常量的值总是非负数；如果前面出现符号则是对常量的一元运算符，不是常量的一部分；浮点型常量同理。

 

细节37：多字符常量，含义由实现定义。

 

细节38：标准C允许对包含相同字符的两个字符串型常量使用同一存储空间。如果在只读内存中分配，则下面赋值会产生错误。

测试：

复制代码
#include <stdio.h>

char *string1,*string2;
int main() {
    string1 = "abcd";
    string2 = "abcd";
    if (string1==string2)
        printf("Strings are shared.\n");
    else
        printf("Strings are not shared.\n");
    string1[0] = '1';
    if(*string1=='1')
        printf("Strings writable\n");
    else
        printf("Strings are not writable\n");
    return 0;
}
复制代码
输出：

Strings are shared.
段错误
　　另外可以看出，字符串常量返回的是地址：char *string1 = "abcd".

 

细节39：单字符常量在C中是int型，而C++是char型。

测试：

#include <stdio.h>

main()
{
    printf("sizeof('a'):%d\n",sizeof('a'));
}
结果：

//.c结尾，gcc编译

sizeof('a'):4

 

//.cpp结尾，g++编译

sizeof('a'):1

 

细节40：struct的指定初始化（C99新增）

分析：

struct S {int a;float b;char c[4]};
struct S s1 = {.c="abc"};
/* {0,0.0,"abc"}*/
 

细节41：标准C中，可以用void *作为通用对象指针，但没有通用函数指针。

分析：后者的区别在于，下面被注释掉的代码无法通过编译，而剩余部分无误。

复制代码
#include <stdio.h>
int f1(int a)
{
    return 1;
}

int f2(double b)
{
    return 2;
}

int main()
{
　　
    //void *p;
    //p = f1;
    //printf("%d\n",p(0));
    //p = f2;
    //printf("%d\n",p(0));

    int (*p1)(int);
    int (*p2)(double);
    p1 = f1;
    printf("%d\n",p1(0));
    p2 = f2;
    printf("%d\n",p2(0));
    return 0;
}
复制代码
 

细节42：结构不能比较相等性。如果需要，请逐个成员比较。

 

细节43：typedef名称不能与其他类型说明符一起使用

typedef long int bigint;
unsigned bigint x; /*invalid*/
但是可以与类型限制符一起使用

const bigint x; /*OK*/
 

细节44：结构类型定义或联合类型定义中类型说明符的每一次出现都引入一个新的结构类型或联合类型。

分析：以下x、y、u的类型各不同，但u和v类型相同。

struct {int a;int b;} x;
struct {int a;int b;} y;
struct S {int a;int b;} u;
struct S v;
 

细节45：如果结构和联合表达式是左值，则直接成员选择表达式的结果为左值（只有函数返回的结构和联合值才不是左值）。 

关于左值，请见第二部分。

 

细节46：如何避免放弃值的警告？

下列是虽然有效但可能引起警告消息的语句：

extern int g();
g(x); //the result of g is discarded
x+7; //Addition has no defined side effects
x + (a*=2);// "+"is discarded
为避免放弃值的警告，可以将其转化为void类型以表示故意要放弃这个值：

extern int g();
(void)g(x); //the result of g is discarded
(void)(x+7); //Addition has no defined side effects
 

细节47：C99不再允许main省略返回值类型。

测试：gcc4.4.3使用-std=c99，提示warning: return type defaults to ‘int’

 

 细节48：求值的顺序与寻常双目转换，以下两个表达式并不等价

(1.0+ -3) +(unsigned)1;//Result is -1.0
1.0 +(-3 + (unsigned)1);//Result is large
分析：

　　求值时会进行寻常双目转换，规则如下





 

细节49：当源和目的地址有公共存储空间时

　　以下函数的行为是未定义的

　　　　strcat,strncat,wcscat,wcsncat

　　　　strcpy,strncpy,wcscpy,wcsncpy

　　　　memcpy,memccpy

　　以下函数可以正常工作

　　　　memmove,wmmove

　　memmove“像”是借助了一块临时存储区，实际上它的实现不需要。

 

细节50：两字符串相等时，strcmp()返回0。因此if(!strcmp(s1,s2))表示两字符串相等时的条件。

 

细节51：逗号表达式的值是它的右操作数的值，即r = (a,b,...,c);等价于a;b;...r=c;

 

细节52：如果一个顶层声明具有类型限制符const，但没有显式的存储类别，在C中被认为是extern，C++则认为是static。

 

二、容易被忽视的定义
1.文本流(text stream)

　　一系列被分割成几行的字符序列。每行有0个或多个字符，以换行符(newline)结束。 (K&R、C99同，后者原文：A text stream is an ordered sequence of characters composed into lines , each line consisting of zero or more characters plus a terminating new-line character.）

 

2.对象和左值

　　（来自CARM）

　　对象(object)是一块内存区域，可以读取它的值或者向它存储数据。左值(lvalue)是一种表达式，可以读取或修改它所引用的对象。只有左值表达式可以作为赋值操作符的左操作数，不属于左值的表达式有时称为右值(rvalue)，因为它只能出现在赋值操作符的右边。左值可以是对象或不完整类型，但不能是void类型。

 

 说明：

　　下面的语句是没有任何问题的，尽管以前从未想过。

int a;
(a) = 1;
 

3.序列点

　　这里直接是C99的相关解释

 

Accessing a volatile object, modifying an object, modifying a file, or calling a function
that does any of those operations are all side effects ,which are changes in the state of
the execution environment. Evaluation of an expression may produce side effects. At
certain specified points in the execution sequence called sequence points , all side effects
of previous evaluations shall be complete and no side effects of subsequent evaluations
shall have taken place.

 

 　　以及所有的序列点总结（C99附录C）

 

The following are the sequence points described in 5.1.2.3:
— The call to a function, after the arguments have been evaluated (6.5.2.2).
— The end of the first operand of the following operators: logicalAND&& (6.5.13);
logical OR||(6.5.14); conditional ? (6.5.15); comma , (6.5.17).
— The end of a full declarator: declarators (6.7.5);
— The end of a full expression: an initializer (6.7.8); the expression in an expression
statement (6.8.3); the controlling expression of a selection statement (ifor switch)
(6.8.4); the controlling expression of a whileor dostatement (6.8.5); each of the
expressions of a for statement (6.8.5.3); the expression in a return statement
(6.8.6.4).
— Immediately before a library function returns (7.1.4).
— After the actions associated with each formatted input/output function conversion
specifier (7.19.6, 7.24.2).
— Immediately before and immediately after each call to a comparison function, and
also between any call to a comparison function and any movement of the objects
passed as arguments to that call (7.20.5).

 

 
三、补充
1.再谈未定义行为

　　本来是想搞一个未定义行为总收集的，但无奈实在太多，时间有限，只能作罢。有兴趣寻根问底的可以去查阅C99或最新的C11标准的附录J.2。下面收集了一些探讨常见未定义行为的文章链接，有兴趣可以去研究下：

 

 在表达式求值时，如果发生了什么意外情况，比如1/0，这在数学上就没有解释，或者求值结果不在对应类型所能表示范围内（ 1 + INT_MAX就是这种情况，两个int类型数据相加应该得到一个int类型的值，但现在这个值却超出了int类型的表示范围），那么这个表达式究竟是什么意思，C语言说它不知道。

...

这句话的意思是说，在相邻两个序点（sequence point）之间，同一个数据对象的值最多可以通过表达式求值改变一次。

    　　http://www.cnblogs.com/pmer/archive/2013/01/02/2842516.html

 

 

再比如，两个int类型数据相加，其前提条件是结果必须在int类型可以表示的范围之内，否则就成了一种未定义行为。 

 　　　　http://www.cnblogs.com/pmer/archive/2012/01/16/2324058.html

 

 

指针可以与整数做加、减运算是有前提的。前提之一是这个指针必须是指向数据对象(Object)。例如：

int i

 　　&i这个指针可以+0、+1。但是指向函数的指针或指向void类型的指针没有加减法运算。

　　前提之二是这个指针必须指向数组元素（单个Object视同一个元素的数组）或指向数组最后一个元素之后的那个位置。例如：

int a[2]

 　　&a[0]、&a[1]、&a[1]+1(即a、a+1、a+2)这些指针可以进行加减法运算。
　　第三，指针进行加减法运算的结果必须也指向数组元素或指向数组最后一个元素之后的那个位置。例如，对于指向a[0]的指针a，只能+0、+1、+2，对于a+2这个指针，只能-0、-1、-2。如果运算结果不是指向数组元素或指向数组元素最后一个元素之后的位置的情况，C语言并没有规定这种运算行为的结果是什么，换句话说这是一种未定义行为(Undefined Behavior，后面简称UB)。

 

 　　　　http://www.cnblogs.com/pmer/archive/2012/05/18/2507971.html

 

2.C99标准新增了哪些重要特性？

　　习惯于使用只支持老标准的编译器的读者不妨看看，这些新特性有的还是挺方便的。更不用说C11已经发布很长时间了。

C99的新特性（1）  

C99的新特性（2）

C99的新特性（3）  

 

3.关于二维数组

　　这个比较容易让人迷惑，旧作一篇供参考：二维数组作为函数参数传递剖析(C语言)(6.19更新第5种)

 

四、后记
　　写了几年程序，接触了一些语言；回顾下，还是C用得最多，也最熟悉。临近找工作，回顾下之前系统看过几遍的K&R以及CARM，希望能及时扫除盲点，也希望本文能对C语言的使用者有所帮助。书中还有很多优秀代码、细致的说明和程序设计思想，不过限于篇幅，以及与主题关系不大，只好割爱，建议有空一定要好好读读。
* 
  mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/home/wuming/.local/bin -DCMAKE_EXPORT_COMPILE_COMMANDS=YES
  cmake --build .
  cmake --build . --target install

  cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/home/wuming/.local/bin -DCMAKE_EXPORT_COMPILE_COMMANDS=YES
* C++调用C的静态库/动态库
C++调用C的函数比较简单，直接使用extern "C" {}告诉编译器用C的规则去调用C函数就可以了。

CAdd.h

int cadd(int x, int y);
1
CAdd.c

#include "CAdd.h"
#include <stdio.h>

int cadd(int x, int y) {
    printf("from C function.\n");
    return (x + y);
}
1
2
3
4
5
6
7
编译libCAdd.a

gcc -c CAdd.c           # 生成CAdd.o
ar -r libCAdd.a CAdd.o  # 归档生成libCAdd.a
1
2
编译动态库 libCAdd.so

gcc -shared -o libCAdd.so CAdd.c
1
cppmain.cpp

#include <stdio.h>

extern "C" {
#include "CAdd.h"
}

int main()
{
  int sum = cadd(1, 2);
  printf("1+2 = %d\n", sum);
  return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
编译main 
-l指定库名称，优先链接so动态库，没有动态库再链接.a静态库。

g++ -o cppmain cppmain.cpp -L. -lCAdd
1
运行 
如果链接的是静态库就可以直接运行了，如果链接的是动态库可能会提示 
./cppmain: error while loading shared libraries: libCAdd.so: cannot open shared object file: No such file or directory，是因为Linux系统程序和Windows不一样，Linux系统只会从系统环境变量指定的路径加载动态库，可以把生成的动态库放到系统目录，或者执行export LD_LIBRARY_PATH=./设置当前路径为系统链接库目录就可以了。

注释 
这里是在include头文件的外面包裹了extern "C" { }，是告诉编译器以C语言的命名方式去加载这个符号。还有一种比较常见的方式是在头文件中进行编译声明，如下所示，这样的话，无论C还是C++直接正常include就可以使用了。

CAdd.h

#ifdef __cplusplus
extern "C" {
#endif

int cadd(int x, int y);

#ifdef __cplusplus
}
#endif
1
2
3
4
5
6
7
8
9
C调用C++的静态库
C语言没法直接调用C++的函数，但可以使用包裹函数来实现。C++文件.cpp中可以调用C和C++的函数，但是C代码.c只能调用C的函数，所以可以用包裹函数去包裹C++函数，然后把这个包裹函数以C的规则进行编译，这样C就可以调用这个包裹函数了。

CppAdd.h

int cppadd(int x, int y);
1
CppAdd.cpp

#include "CppAdd.h"
#include <stdio.h>

int cppadd(int x, int y) {
    printf("from C++ function.\n");
    return (x + y);
}
1
2
3
4
5
6
7
编译静态库 libCppAdd.a

g++ -c CppAdd.cpp
ar -r libCppAdd.a CppAdd.o
1
2
CppAddWrapper.h

#ifdef __cplusplus
extern "C" {
#endif

int cppaddwrapper(int x, int y);

#ifdef __cplusplus
}
#endif
1
2
3
4
5
6
7
8
9
CppAddWrapper.cpp

#include "CppAddWrapper.h"
#include <stdio.h>
#include "CppAdd.h"

int cppaddwrapper(int x, int y) {
    printf("from wrapper.\n");
    int sum = cppadd(x, y);
    return sum;
}
1
2
3
4
5
6
7
8
9
编译wrapper静态库 libCppAddWrapper.a

g++ -c CppAddWrapper.cpp
ar -r libCppAddWrapper.a CppAddWrapper.o
1
2
main.c

#include "CppAddWrapper.h"
#include <stdio.h>

int main()
{
  int sum = cppaddwrapper(1, 2);
  printf("1+2 = %d\n", sum);
  return 0;
}
1
2
3
4
5
6
7
8
9
10
编译main，同时指定libCppAdd.a 和 libCppAddWrapper.a。

gcc -o main main.c -L. -lCppAddWrapper -lCppAdd
1
或者把libCppAdd.a合并到libCppAddWrapper.a中

ar -x libCppAdd.a         # 提取CppAdd.o
ar -x libCppAddWrapper.a  # 提取CppAddWrapper.o
ar -r libCppAddWrapper.a CppAdd.o CppAddWrapper.o # 打包libCppAddWrapper.a
gcc -o main main.c -L. -lCppAddWrapper  # 只需要连接libCppAddWrapper.a即可
1
2
3
4
如果是C调用C++的so动态库的话，类似于调用静态库的方法应该也是有效的，太麻烦我没试过。

总结
C/C++函数符号的区别
C++可以兼容C的语法，C/C++主要的区别是编译函数符号规则不一样，C语言代码编译后的函数名还是原来函数名，C++代码编译后的函数名带有参数信息。 
做个测试来检验一下。一个简单的函数，分别用C和C++进行编译。 
hello1.c

int test(int a, char* b){
    return a;
}
1
2
3
hello2.cpp

int test(int a, char* b){
    return a;
}
1
2
3
编译

gcc -c hello1.c     # 生成hello1.o
g++ -c hello1.cpp   # 生成hello2.o
1
2
查看符号表

$ nm hello1.o
0000000000000000 T test
$ nm hello2.o
0000000000000000 T _Z4testiPc
1
2
3
4
从上面信息可以看出，C语言编译后的函数符号还是原函数名，而C++编译后的函数符号由test变成了_Z4testiPc，从这个符号名字可以看出test前面有个数字4应该是函数名长度，test后面i Pc应该就是函数的参数签名。C++之所以这样规定编译后的函数符号是因为对面对象的C++具有函数重载功能，以此来区分不同的函数。

.so动态库、.a静态库和.o中间文件的关系
程序的运行都要经过编译和链接两个步骤。假如有文件add.c，可以使用命令gcc -c add.c进行编译，生成add.o中间文件，使用命令ar -r libadd.a add.o可以生成libadd.a静态库文件。静态库文件其实就是对.o中间文件进行的封装，使用nm libadd.a命令可以查看其中封装的中间文件以及函数符号。 
链接静态库就是链接静态库中的.o文件，这和直接编译多个文件再链接成可执行文件一样。 
动态链接库是程序执行的时候直接调用的“插件”，使用命令gcc -shared -o libadd.so add.c生成so动态库。动态库链接的时候可以像静态库一样链接，告诉编译器函数的定义在这个静态库中（避免找不到函数定义的错误），只是不把这个so打包到可执行文件中。如果没有头文件的话，可以使用dlopen/dlsum函数手动去加载相应的动态库。详细做法参考上一篇文章《C语言调用so动态库的两种方式》。
--------------------- 
作者：LemonShaw 
来源：CSDN 
原文：https://blog.csdn.net/shaosunrise/article/details/81176880 
版权声明：本文为博主原创文章，转载请附上博文链接！
* 方式1：类似静态库的调用（使用头文件）
这种方式生成的程序会在启动时候就加载so动态库。

add.h

int add(int x, int y);
1
add.c

#include "add.h"

int add(int x, int y) {
    return (x + y);
}
1
2
3
4
5
main.c

#include <stdio.h>
#include "add.h"

int main()
{
    int sum = add(7, 8);
    printf("7+8 = %d\n", sum);

    return 0;
}
1
2
3
4
5
6
7
8
9
10
编译so，生成libadd.so。

gcc -shared -o libadd.so add.c
1
编译main，使用-L./指定add库在当前目录。

gcc -o main main.c -L./ -ladd
1
方式2：使用dlopen/dlsum动态加载动态库（不使用头文件）
这种方式生成的程序会在代码执行到指定行位置加载so动态库。

add.c

int add(int x, int y) {
    return (x + y);
}
1
2
3
main.c

#include <stdio.h>
#include <dlfcn.h>

int main()
{
    /*手动加载指定位置的so动态库*/
    void* handle = dlopen("./libadd.so", RTLD_LAZY);
    int (*add)(int a, int b);

    /*根据动态链接库操作句柄与符号，返回符号对应的地址*/
    add = dlsym(handle, "add");

    int sum = add(7, 8);
    printf("7+8 = %d\n", sum);

    dlclose(handle);
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
编译so，生成libadd.so

gcc -shared -o libadd.so add.c
1
编译main，不需要指定libadd.so相关信息进行编译，执行时候会在指定目录加载so

gcc -o main main.c -ldl
1
两种调用方式总结
方式1使用头文件，所以可以直接调用头文件声明的函数。编译的时候指定了动态库位置和名称，程序启动时候系统就会自动加载相应位置的so动态库。 
方式2没有头文件，编译的时候也不需要指定动态库信息。但是需要在程序中使用dlopen函数加载相应位置的so动态库，且要使用dlsym函数根据函数符号去查找此函数的地址。



BONUS: so动态库中调用so动态库
add.h

int add(int x, int y);
1
add.c

#include "add.h"

int add(int x, int y) {
    return (x + y);
}
1
2
3
4
5
sum.h

void printsum(int a, int b);
1
sum.c

#include "sum.h"
#include <stdio.h>
#include "add.h"

void printsum(int a, int b){
    int sum = add(a, b);
    printf("%d+%d = %d\n", a, b, sum);
}
1
2
3
4
5
6
7
8
main.c

#include "sum.h"

int main()
{
    printsum(1, 3);
    return 0;
}
1
2
3
4
5
6
7
编译libadd.so

gcc -shared -o libadd.so add.c
1
编译libsum.so，需要指定libadd.so信息

gcc -shared -o libsum.so sum.c -L. -ladd
1
编译main，仅需要指定libsum.so

gcc -o main main.c -L. -lsum
1
main运行的时候同时需要libsum.so 和 linadd.so。
--------------------- 
作者：LemonShaw 
来源：CSDN 
原文：https://blog.csdn.net/shaosunrise/article/details/81161064 
版权声明：本文为博主原创文章，转载请附上博文链接！
* 深入理解C语言
置顶 2017年09月22日 10:21:02 有时需要偏执狂 阅读数：787
 版权声明：本文为博主原创文章，未经博主允许随意转载。	https://blog.csdn.net/u010710458/article/details/78060059
大型源代码里面经常出现一些晦涩的C语言及其规则。 
本贴着重记录这些代码以及支撑代码运行的C语言神奇用法。 
搞懂这些C语言面试就是无敌开挂模式了

牛人讲解的C语言为啥难。

语言的歧义 
C语言的谜题 
谁说C语言很简单？

C 语言中的指针和内存泄漏
C 语言中的指针和内存泄漏 
这篇文章简单讲解了关于动态内存的东西，这些东西一般在大型程序里面都是必须十分注意的问题。

选择整数数据类型大小
C99仅仅规定了，char至少1字节，int和short int至少2字节long int至少4字节。一些系统上面通常允许字节数超过上面规定的最小字节数。如果因为某种原因需要声明一个精确大小变量并且具有可移植性，应该使用typedef定义类型，系统变了，字节数变了，仅仅只需要修改typedef类型定义即可方便。

typedef和#define
typedef位数据类型创建别名，而不是创建新的数据类型，这是宣称这个名字是指定的类型的同义词。 
typedef是一种彻底的封装类型，宏定义仅仅是文本替换

///////////////////////////////////////////////////////////
typedef char* String_t;
#define String_d char *
String_t s1 , s2;
String_d s3 , s4;
//s1 s2 s3是指针，s4是char类型。

typedef struct{
    char *item;
    NODEPTR next;
}*NODEPTR;
//上述这种定义报错，因为声明next在typedef之前处理了。应该修改成下面这种。
typedef strcut node{
    char *item;
    struct node *next;
}*NODEPTR;//修改1

strcut node{
    char *item;
    struct node *next;
}
typedef struct node *NODEPTR;//修改2
///////////////////////////////////////////////////////////

typedef void (*func)(int);
void (*signal(int sig , void (*func)(int) ))(int);
func signal(int sig , func f);//通过tpyedef简化signal函数

#define peach int
#define int_ptr int *
typedef int banana;
typedef char * char_ptr;
unsigned peach i ;//正确
unsigned banana i ;//错误，typedef是整体类型了

int_ptr a , b;//声明a指针和b int类型
char_ptr a , b;//声明a指针和b 指针，因为typedef是类型别名，已经是类型了。
/*
不要为了方便在结构使用typedef，这样仅仅帮助你省略了关键字而已，而没有提示功能了，在大量代码中，应该使用关键字给别人以提示功能。
typedef应该使用在：
    1、数组，结构，指针以及函数的组合类型。
    2、为了可移植的数据类型。方便将代码移植到不同平台，仅仅修改typedef定义即可。
    3、为强制类型转换提供简单的名字。
    4、结构中尽量使用结构标签，让代码更加清晰。
*/

//////////////////////////////////////////////////////////
//定义两个相互引用结构
struct a;//空声明告诉编译器下面有定义
struct b;//空声明告诉编译下面有定义
typedef struct a *APTR;
typedef struct b *BPTR;
struct a{
    int afiled;
    BPTR bpointer;
}
struct b{
    int bfiled;
    BPTR apointer;
}
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
tpyedef int (*funcptr)();//定义一个新的类型，可以声明函数指针。表示指向返回值是int类型，没有参数的函数。
funcptr fp1 , fp2;//两个函数指针
//等效于
int (*fp1)() , (*fp2)();//这是晦涩写法
//////////////////////////////////////////////////////////
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
const
const修饰的变量是不可以改变的，所以定义该变量时候初始化是使该变量具有值的唯一机会。 
使用const几点作用：

向阅读代码的人传递有用的信息，告诉用户这个参数应用目的，不必担心指针指向的内容被此函数修改
合理使用const可以使编译器很自然地区保护那些不希望被改变的参数，防止被意外更改，减少bug出现。假如程序很大，万行代码，那么这种有用的声明就起到了作用。正确使用const关键字是一个良好的编程习惯，对于调试可以节省大量时间和精力。
const char *p;
char const *p;
char *const p;
//上面三个区别
1
2
3
4
一些复杂声明
超级复杂的声明在实际应用中需求很少，这里暂时先放着，以后实际工作中遇到了，需要理解，那么就再记录.通过typedef可以解决晦涩难懂类型。

//定义一个返回函数指针的函数指针。
typedef int (*funcptr)();//定义函数指针类型
typedef funcptr (*ptrfuncptr)();//定义一个返回值是函数指针的函数指针新类型。
//等效与
    int  (*(*ptrfuncptr)()) ();
1
2
3
4
5
变量初始化问题
静态变量和全局变量未初始化，编译器自动初始化为0.非静态的局部变量则里面存储垃圾数据。malloc和remalloc分配的里面也是垃圾数据，对于垃圾数据不能做任何假设。callock自动初始化为0.

char a[] = "myname";//数组
char *b = "myname";//const 指针，不能修改指向的内容，不能用于strcopy
1
2
结构、联合、枚举
结构
struct name{
    int namelen;//存储名字长度
    char namestr[1];//存储名字字符串,可使长度和名字处于同一内存块
};
struct name *makename(char *name)
{
    //这种做法可以是的名字和字符串长度存储在一块连续的存储区,但是并不是C语言标准
    struct name *ret = (struct name *)malloc(sizeof(struct name)-1 + strlen(name) +1);
    if(ret != NULL){
        ret->namelen = strlen(name);
        strcpy(ret->namestr , name);
    }
    return ret;
}
int main(void)
{
    struct name *myname;
    myname = makename("wangjun");
    printf("name is %s , len is %d\n" , myname->namestr , myname->namelen);
    exit(0);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
这种技术十分普遍，将长度和字符串保存在同一块内存中。实际上这里是将数组当作了指针来使用。但是不可靠，可靠的是使用字符指针。

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct name{
    int namelen;//存储名字长度
    char *namep;//存储名字字符指针
};
struct name *makename(char *name)
{
    //这种做法可以是的名字和字符串长度存储在一块连续的存储区,但是并不是C语言标准
    struct name *ret = (struct name *)malloc(sizeof(struct name));
    if(ret != NULL){
        ret->namelen = strlen(name);
        ret->namep = (char *)malloc(ret->namelen +1);//分配一块内存存储字符串,+1是为了存储字符串
        if(ret->namep == NULL){
            free(ret);
            return NULL;
        }
        strcpy(ret->namep , name);//将名字搬运到分配好的内存块上面,然后以后通过指针访问
    }
    return ret;
}
int main(void)
{
    struct name *myname;
    myname = makename("wangjun");
    printf("name is %s , len is %d\n" , myname->namep , myname->namelen);
    exit(0);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
用字符串指针，这是一种更加通用的方法，但是这里在堆中动态分配了两块内存。释放的时候，需要利用两次free。为了保持内存的连续性，也可以仅仅分配一块，如下面部分。

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct name{
    int namelen;//存储名字长度
    char *namep;//存储名字字符指针
};
struct name *makename(char *name)
{

    struct name *ret = (struct name *)malloc(sizeof(struct name) + strlen(name) + 1);
    if(ret != NULL){
        ret->namelen = strlen(name);
        ret->namep = (char *)ret + sizeof(struct name);//通过长度来求得偏移
        strcpy(ret->namep , name);
    }
    return ret;
}
int main(void)
{
    struct name *myname;
    myname = makename("wangjun");
    printf("name is %s , len is %d\n" , myname->namep , myname->namelen);
    exit(0);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
这种做法，使得一次malloc调用将两个区域拼接在一起，但是这里只有当第二个区域是char型的时候才可以移植。对于任何大一些的类型，对齐问题变得十分重要。这些“亲密”结构都必须十分小心的使用。因为只有程序员知道它们的大小，而编译器一无所知。

函数传入和传出大结构可能会代价很大（通常就是将整个结构都推进栈，需要多少空间，就占用多少空间），因此当不需要进行值传递的时候，我们必须考虑通过传递指针代替，减少访问的开销。
因为涉及内存对齐的问题，所以并不能用==或者！=比较结构类型。填充空洞不一样，不能进行比较。
向接收结构的参数传入常量值，建立无名结构数值
plotpoint( (struct point){.x = 1 , .y = 2} );//这种方式省略了初始化一个临时变量


void plot(struct point x)
{
    printf("%d , %d\n" , x.x , x.y);
}
int main(void)
{
    struct name *myname;
    myname = makename("wangjun");
    printf("name is %s , len is %d\n" , myname->namep , myname->namelen);
    plot( (struct point){.x =2 , .y = 3} );
    exit(0);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
结构体对齐的问题（C primer Plus）

确定结构体域中字节偏移量以及通过名字访问结构体中的域（设计内存对齐）

联合和枚举
联合本质上是一个一个成员相互重叠的结构，某一时刻只能使用一个成员。也可以从一个成员写入，然后从另外一个成员读出。联合大小是最大成员的大小。 
枚举的存在完成是为了代码可读性。变量自动赋值，服从数据块作用域，使用之后代码可读性增强。

位域
数字表示该域中用位计量的准确大小。 
单独操作变量中的位，例如设备寄存器不同位对应者不同的功能，文件相关的操作系统信息一般通过特定的位表明特定的选项。

掩码
#define MASK = (0x01>> 2)

//通过掩码打开某些位，关闭某些位
flags &= (~MASK);//清除第2位
flags |= (MASK);//设置第2位

//通过掩码切换某些位
flag ^= MASK;//将第二位翻转，为1的将翻转

//检查位的值
if( (flag & MASK) == MASK)//证明功能已经被设置
{
}

//移位，产生一个新的位值，但是不改变运算对象。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
位字段
表达式
对于复杂表达式中各个子表达式的求值顺序，编译器有相对自由选择的权利，这和操作符的优先级和结合性没有关系。如果某个变量同时受到多个副作用的影响，这种情况下的行为是未定义的。

a[i] = i++;//副作用，修改i的数值。导致a[i]引用不知道引用i++还是i。这种行为未定义。
printf("%d\n" , i++ * i++);//同样未定义，编译器并不知道选择旧值还是选择新值，出现多个副作用。

/*
括号作用:仅仅告诉哪个操作数和哪个操作数结合，并没有要求编译器先对括号内的表达式求值。
*/
f() + (g()*h());//这里并不能确定哪个优先调用，编译器会随机选择调用顺序。
(i++)*(i++);//这里结果同样是未定义的。


/*
逗号表达式，&&和||可以确保左边的表达式决定了最终结果，那么右边的子表达式不会计算，因此从左边都右边的计算可以保证。
*/
if(d != 0 && n/d > 0)
{
    ;//可以确保n/d是有定义，否则跳过，放置系统崩溃。
}
if(p == NULL || *p == '\0')
{
    ;//可以确保p是有定义指针，否则跳过，防止系统崩溃。
}

//i++和++i的唯一区别在于它们向包含它们的表达式传出的值不同，一个传原来副本，一个传最新的值。c++优先使用++i因为更加符合人们思想。

if(a<b<c);//a<b返回0或者1，然后将0和1与c进行比较，所以这是一种错误的写法。
if(a < b && b < c);

double degc , degf;
degc = 5/9*(degf - 32);//必定等于0，因为5/9=0，修改
degc = 5.0/9*(degf - 32);//degc = (double)5/9*(degf - 32);才正确
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
指针
指针是C语言最强大和最流行的功能之一。但是指向不应该指的位置，后患无穷。那么问题来了，指针到底有什么好处呢？

实现动态分配数组，利用malloc分配空间，通过指针访问，这条使用过。
对多个相似变量的一般性访问。
（模拟）按照引用传递函数参数（后续继续理解，这里不明白）
各种动态分配的数据结构，尤其是树和链表
遍历数组，利用许多处理字符串的库函数，strcpy ，memset等，都是通过指针。
高效复制数组和结构，作为函数参数，传入指针，然后直接访问内存，避免了数据结构在堆中完全拷贝。

*p++ = 22;//这种语句使用巨多，将当前位置赋值，并指向下一个位置。


int array[5] , i , *p;
p = array;
printf("%d" , *(p + 3*sizeof(int)) );
//这里指针必定溢出，因为指针加数字相当于加上数字乘以指针所指类型大小
//上述可能是array[6]或者array[12].这是老生常谈的问题，很简单

char *p;
p = p + sizeof(int);//跳过一个int类型
p = (char *)( (int *)p + 1 );//将p升级为int，然后加1跳过一个int，然后转换回来。这种做法可行，但是非常丑陋，并不提倡。

////////////////////////////////////////////////////////
//模拟引用传递参数
void f(int *ip)
{
    static int d = 5;
    ip = &d;
}
int *p;
f(p);
//这里发现拍并没有变化，因为参数都是值传递副本进去，
//要想改变一个东西，必须传递它的指针进去，然后通过指针修改指向的内容而已，或者通过参数返回。
//我们一般需要修改传入的多个形参里面的内容，一般是传递其对应的指针进去，然后通过指针直接访问内存，修改传入参数里面的内容。或者返回，但是返回仅仅只能返回一个数值。
//这里如果要修改传入的指针，那么必须传入指针的指针或者返回,如下：
void f(int **ip)
{
    static int d = 5;
    *ip = &d;
}
int *p;
f(&p);//这样就可以正确了

int *f(void)
{
    static int d = 5;
    return (&d);
}
int *ip = f();//这里返回也是正确的
////////////////////////////////////////////////////////////////

int r , (*fp)() , func();
fp = func;
r = fp();
r = (*fp)();//上面两种指针函数调用完全等效。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
空指针
C语言定义空指针，可以确保这个指针不会指向任何一个对象或函数。空指针不同于未初始化的指针。空指针可以确保不指向任何对象或函数，而未初始化的指针则可以指向任何地方。 
在C语言中空指针NULL和空指针常量0一样的效果。

//编译器会进行如下修复,
if(expr) 等效于 if( (expr) != 0 )

if(!p)等效于if(p == 0)或者if( (expr)?0:1 )
//尽量少些缩写的方法，为了让别人看清楚，尽量将条件写清楚。；
1
2
3
4
5
数组和指针
数组和指针的统一性是C语言长处之一，用指针可以很方便地访问数组和模拟动态分配的数组。只能说数组名和指针等价，可以通过指针访问数组里面的元素而已。可不能说它们一样。数组是一个由同一类型的连续元素组成的预先分配的内存块。指针是一个变量可以对任何位置数据元素进行引用而已。数组下标访问是属于指针定义的。
/*
数组并非指针，数组定义绝对不是指针的外部声明。定义只可以出现一次用于确定对象的类型并分配内存，用于创建新的对象；声明可以出现多次，用于描述对象类型，指示对象在其他地方创建的。
exten声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。由于并
未在声明中为数组分配内存，所以并不需要提供关于数组长度的信息。对于多维数组，需要提供除最左边一维之外其他维的长度-这就给编译器足够的信息产生相应的代码。
*/
char a[6];
extern char *a;//这种声明上面的a不正确，因为a是数组6个区域，而这个声明是字符指针，效果不一样。修改为 extern char a[];
1
2
3
4
5
6
7
这里写图片描述 
编译器看到a[3]的时候直接访问数据，它生成的代码从a位置开始跳过3个，然后取出指向的字符。而对于p[3]的时候间接访问数据，先找到p的位置取出其中指针值，然后在指针后面加3，取出其中的字符。数组和指针一旦在表达式中出现就会按照不同的方法计算，但是二者可以达到一样的效果。二者实现效果相同，但是实现的方式非常不一样。

//数组名不能赋值。
extern char *getpass();
char str[10];
str = getpass();//数组是二等公民，不能向他赋值。当需要从一个数组向另一个数组复制所有内容的时候。对于char型数组，strcpy ， 如果不想复制数组且希望传递，那么直接指针搞起。


/*
字符串常量放在只读数据段，将其地址返回给p。
p不可以修改文本，只读而已。
定义指针，编译器并不为指针所指向的对象分配空间,
仅仅给指针本身分配空间而已，除非定义指针的同时通过字符串常量进行初始化。
*/
char *p = "abdcfdfd";//"abdcfdfd"一般放在只读数据段，不可通过p修改。

char a[] = "abdcfdfd";//"abdcfdfd"初始化被分配内存，可通过a修改。


int a[10];
/*
a的引用类型是“int型的指针”。&a是“10个int的数组的指针”
*/
int b[2][5];
/*
b的引用类型是“5个int型数组的指针”。&b是“2个5个int的数组的数组的指针”。
*/


/*
区别指向数组的指针和指向数组某个元素的指针。通常并不需要声明数组的指针。
真正的数组指针，在使用下标或增量操作符的时候，会跳过整个数组，通常在操作数组的数组有用（二维数组）。
*/
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
二维数组的一些理解：
二维数组也叫做数组的数组，相当于一维数组里面的元素是一个数组。这样就很好理解了。例如int a[2][3],那么a[0]和a[1]就相当于对应的数组名。而a就是指向数组的指针，也就是指针的指针。再数值上a[0]和a相等，但是他们类型不一样，a[0]是指向int的指针而a是指向3维数组的指针。所以要引用a的时候，必须声明类型相匹配的指针变量。下面展示了一些用法。

#include <stdio.h>

int main ()
{
    int a1[3] = {0 , 1 , 2};//声明a1数组且里面含有3个int元素
    int a2[2][3] = { {3 , 4 , 5} 
                    ,{6 , 7 , 8}
                   };//数组的数组，可以得出里面含有a2[0]数组和a2[1]数组，所以a2表示指向数组（含有3个int类型数据）的指针。可以以此类推到三维数组。
    int *ip = a1;//声明指向int类型的指针。
    int (*ap)[3] = a2;//声明指向含有3个int型元素数组的指针，可以对二维数组引用。

    printf("%d \n" , *ip++);//引用一维数组
    printf("%d \n" , *ip);//引用一维数组

    printf("%ld \n" , ap);//数组指针地址
    printf("%ld \n" , *ap);//int型指针，a2[0]数组第一个元素的地址。ap和*ap在数值上相同，但是当二者进行算术运算时候，因为类型不同，所计算的数值也不同
    printf("sizeof(a2)=%d , sizeof(*a2)=%d\n" , sizeof(a2) , sizeof(*a2));//a2=2*4*3=24 , (*a2)=4*3=12
    printf("sizeof(ap)=%d , sizeof(*ap)=%d\n" , sizeof(ap) , sizeof(*ap));//ap = 4指针变量本来占用四字节，(*ap)数组名=3*4=12.
//演示ap和*ap类型不一样。

    printf("%d %d\n" , (*ap)[0] , (*ap)[1]);
    ap++;//跨过5个int，因为ap类型是指向数组的指针，一次跨过一个数组
    printf("%d %d\n" , (*ap)[0] , (*ap)[1]);    
    return 0;
    //对于ap[1][2] = (ap + 1*3 + 2)采用这种寻址方式。
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
这里写图片描述 
输出结果和上面描述一致。

动态分配多维数组
二维数组动态分配两步走：先分配空间存储指针数组，然后把每个指针初始化为动态分配的行。

//int **array1 和int (*array1)[ncolumns]类似
#include <stdlib.h>
#include <stdio.h>
#define nrows 2
#define ncolumns 3
int main(void)
{
    int i;
    int **array1 = (int **)malloc(nrows * sizeof(int *));//分配nrows个连续存储int *指针的空间，并返回其首地址，指针的指针。
    for(i = 0 ; i<nrows ; ++i){
        array1[i] = (int *)malloc(ncolumns * sizeof(int));//分配ncolumns个连续存储int数据的空间，并返回首地址，指针。
    }//这样就动态分配了二维数组，可以用过array1[i][j]进行访问了。
    array1[0][0] = 1;
    array1[0][1] = 2;
    array1[0][2] = 3;
    array1[1][0] = 4;
    array1[1][1] = 5;
    array1[1][2] = 6;
/*
可以通过二维数组一样索引存储区域.
这是由编译器决定的，编译之后全部替换成指针引用区域
*/ 
    for(i = 0 ; i<nrows ; ++i){
        free(array1[i]);//释放指针
    }
    free(array1);//释放指针的指针
    printf("%d\n" , array1[1][2]);
    //释放之后，对应区域还是可以访问，数据可能并没有清空，释放仅仅标记这个区域块可以重新被分配给其他对象。这就是虚拟内存达到的效果。
    //内存释放，表示这部分区域可以重新分配给其他对象，
    //但是不代表将以前的数据清0（具体实现依靠操作系统），所以这里还可以继续访问到这个区域的数据
    //因此，使用动态分配最好清0，不然数据是多少不确定，使用malloc，然后memset。
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
这里写图片描述 
这里写图片描述 
这里的访问数据，可能是6可能是其他，由具体的操作系统决定，释放后内存数据是否清空。

一些关键性得例子
一维数组和指针：

int main(void)
{
    //注意p+1相当于指向下一个同类型，地址为p + sizeof(type)*1;
    int a[] = {0 ,1 , 2 , 3 , 4};
    int i , *p;
    for(i = 0 ; i < 5 ; i++){
        printf("%d " , a[i]);//a[i]访问  0 1 2 3 4
    }
    printf("\n");

    for(p = &a[0] ; p <= &a[4] ; p++){
        printf("%d " , *p);//访问地址 0 1 2 3 4
    }
    printf("\n");

    for(p = &a[0] , i = 1 ; i <= 5 ; i++){
        printf("%d " , p[i]);//注意p[5]是未定义的数据，因为越界访问数组了 1 2 3 4 ?(随机)
    }
    printf("\n");

    for(p = a , i = 0 ; p+i <= a + 4 ; p++ , i++){
        printf("%d " , p[i]);//p[i] = *(p+i)这是编译器做的事情 0 2 4
    }
    printf("\n");

    for(p = a + 4 ; p >= a ; p--){
        printf("%d " , *p);//p[i] = *(p+i)这是编译器做的事情 4 3 2 1 0
    }
    printf("\n");

    for(p = a + 4 , i = 0 ; i <= 4 ; i++){
        printf("%d " , p[-i]);//p[-i] = *(p-i)这是编译器做的事情 4 3 2 1 0
    }
    printf("\n");

    for(p = a + 4 ; p >= a ; p--){
        printf("%d " , a[p-a]);//p-a的数值等于((long)p-(long)a)/sizeof(int) = 跨越个数，
                               //这也是编译器做的，因为p指向int类型，所以都是以sizeof(int)为单位  4 3 2 1 0
    }
    printf("\n");

    exit(0);
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
这里写图片描述

sizeof问题
sizeof在编译器期间起到作用。

int a[2][2];
int *b;
//sizeof(a) = 2 * 2 * 4 =16 数组所占用字节数
//sizeof(b) = 4   指针变量所占用字节数
1
2
3
4
指针数组和指针：

int main(void)
{
    int a[] = {0 ,1 , 2 , 3 , 4};//这种定义形式，让编译器决定数组维度，经常使用。
    int *p[] = {a , a+1 , a+2 , a+3 , a+4};
    /*根据优先级及结合性可以这样理解，
      int * (p[])，首先p是数组，数组里面元素是int *类型。所以是指针数组。
    */
    int **pp = p;//通过2级指针，引用一个地方
    /*根据优先级及结合性可以这样理解，
      int * (*pp)，首先pp是指针，指针里面元素是int *类型。所以是pp是指针的指针，
      刚刚p也是数组名，也是指针，数组里面元素也是指针，所以p也是指针的指针，刚刚和pp类型一样
      可以相互赋值。
    */

    //内存分布如示意图1：
    printf("%d %d\n" , a , *a);    //&a[0] , 0
    printf("%d %d\n" , *p , **p);  //&a[0] , 0
    printf("%d %d\n" , *pp , **pp);//&a[0] , 0

    //内存分布如示意图2：
    pp++;//指向下一个int *
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//1 1 1
    *pp++;//再指向下一个int *
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//2 2 2
    *++pp;//继续指向下一个int *
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//3 3 3
    ++*pp;//还是指向第三个int *
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//3 4 4

    //内存分布如示意图3：
    pp= p;
    **pp++;//
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//1 1 1
    *++*pp;//
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//1 2 2
    ++**pp;//
    printf("%d %d %d\n" ,pp-p , *pp - a , **pp);//1 2 3
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
这里写图片描述 
这里写图片描述
有了这个图片，那么一切都很清晰明了。

多维数组和指针：

内存分配
指针通过比较难学习，但是更加难的在于管理指针指向的内存块。很容易造成内层泄漏的问题。这种BUG最难找出问题。

char *i;
gets(i);
printf("%s" , i);
//代码希望gets的东西，存储在i执行的区域，因为i未初始化，所以这是一个错误使用。必须初始化i指针。相当于int i没有初始化一样。先要指向一片区域，然后通过gets填写指向的区域。如果不初始化指针，那么它不知道把东西搬到哪个内存区域。就算没有malloc也必须确保要使用的内存正确分配。

//上述可以修改成数组，让编译器操心内存分配
char i[100];
gets(i);
printf("%s" , i);

//strcat
char *s1 = "wang";
char *s2 = "jun";
char *s3 = strcat(s1,s2);//肯定不能得到正确的结果。
/*
字符拼接，s1中必须有足够的存储空间，容纳s1和s2指向的字符。程序员必须分配足够的空间，可以通过声明数组或者malloc完成。字符串字面量是不可以修改的。可以通过修改s1为数组
char s1[20] = "wang,";
char *s2 = "jun";
strcat(s1,s2);//这种方法就可以搞定了
*/

char *p;
strcpy(p , "abc");//这种必定错误使用，p没有初始化，那么abc将放到哪里？

char *p;
//这中声明仅仅分配了容纳存储指针本身的内存，也就是sizeof(char *)个字节内存。单没有分配指针指向任何内存（指针没有初始化）。全部可以统一到内存块上面想象。都是放在内存块上面的，指针也放在内存块，只是系统规定这个存放指针的内存块当作地址来解析处理。

//函数返回指针，必须确保指向的内存已经正确分配。
//指针必须静态分配或者调用者传入缓冲区，或者malloc分配。
char *itoa(int n)
{
    char retbuf[20];
    sprintf(retbuf , "%d" , n);
    return retbuf;
}//这个函数绝对错误，因为retbuf是局部变量，函数调用内存分配在栈，函数退出自动释放，所以返回的指针是无效的，因为指向一个已经不存在的数组了。
char *itoa(int n)
{
    static char retbuf[20];
    sprintf(retbuf , "%d" , n);
    return retbuf;
}//修改版本1，通过静态未初始化，存储在BSS段，程序结束之前retbuf一直存在，但是一直指向同一个区域，所以调用者不能多次调用这个函数并同时保存所有返回值。
char *itoa(int n  , char *retbuf)
{
    sprintf(retbuf , "%d" , n);
    return retbuf;
}//修改版本2，可以同时保存所有值，因为传入了保存的空间
char str[20];
itoa(124 , str);
char *itoa(int n)
{
    char *retbuf = (char *)malloc(20);
    sprintf(retbuf , "%d" , n);
    return retbuf;
}//通过malloc从堆（就是虚拟内存上面的一块区域而已，没啥特别之处）分配空间，并返回，但是在不使用的时候，记得释放，否则内存泄漏成为可能。

//malloc分配返回值强制转换类型的问题：标准C不建议转换，但是C++必须进行显示转换，为了C/C++兼容，所以最后转换。

//malloc十分脆弱，因为它们直接在它们返回的内存旁边存储至关重要的内部信息片段，这些信息很容易被指针破坏。（分配大小为0对象，写入比所分配还多的数据，malloc(strlen(s))而不是malloc(strlen(s) + 1 等等）

//free如何知道要释放的大小？
//通常在malloc之后，大小会记录在内存块旁边，这就是为什么越界访问会导致内存泄漏的问题，所以对超出分配内存块边界的内存哪怕是轻微的改写，也会导致严重的后果。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
字符和字符串
C语言没有内建的字符串类型，都是以’0’结尾的字符数组表示字符串。这一点是字符串操作最重要的一点。

char *mystrcat(char *s1 , const char *s2)
{
    char *s;//暂存进行拷贝作用
    for(s = s1;*s != '\0';++s)
        ;//s指向s1的结尾
    for( ; (*s = *s2) != '\0' ; ++s , ++s2)
        ;//将s2拷贝到s1末尾,直到遇到s2的结束符
    return(s1);//可以不测试返回值
}
strcat(string , '!');//错误，因为后面不是字符串常量，没有结束符号，拼接会出问题的，错误内存访问很可能发生。

char a[] = "wangjun";
char *p = "wangnjun";//二者区别巨大，前一个字符数组，后声明一个字符指针，指向一个字符串常量。并且p指向的内容不能更改，想当与const char *p;
1
2
3
4
5
6
7
8
9
10
11
12
13
C预处理器
预处理器是在正式解析和编译之前的工作，最开始进行预处理操作。
1
这里对宏定义解析比较清晰

/*书写多语句宏的最好方法,这样对于if里面使用宏定义，可以加分号也可以不加分号。
如果要使用宏定义来定义多条语句时，采用do { … } while (0) 的形式是一种较好的方法。空的宏定义避免warning；存在一个独立的block中，可以用来进行变量定义作用域是块，因此可以实现比较复杂的功能；如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现。
对于宏定义后面加分号和不加分号，都可以正常运行。
*/
#define MACRO(arg1 , arg2) do{  \
stmt1;                          \
stmt2;                          \
//....                          \
}while(0)

#define FUNC(argc1 , argc2) (expr1 , expr2 , expr3)
//expr*多条语句执行，并且返回expr3的数值给外部赋值语句。

/*放入h里面的东西
宏定义；
结构、联合和枚举声明；
typedef声明；
外部函数声明；
全局变量声明；
*/

/*
当前目录：Unix下，为包含#include指令文件所在的目录。
标准位置：编译之前人为添加的目录，编译器下可以使用环境变量或者命令行参数的方法向标准位置的搜索列表增加其他目录。如Kile/CCS里面配置增加目录方法。
< >首先在一个或多个标准位置搜索，通常保留给系统定义的头文件。
" "首先当前目录搜索，然后在标准位置搜索。
*/

//可变参数宏以及调用辅助宏定义 后面使用了之后，再次发觉效果作用。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
ANSI C标准
const int n = 5;
int a[5];//数组维度，case行标必须用真正常量，可以使用#define，而n也是变量，只是限制为只读而已。

const char *p;
char const *p;
char * const p;
//前面两个等效，都是指向字符常量的指针，也就是p值可以更改，但是p所指对象不可更改。
//后一个是指向可变字符的指针常量。也就是p值不可更改，但是p所指对象可以更改。

typedef char *charp;
const charp p;
//p被声明为const。因为typedef不完全基于文本替换。
//这里类似与const int i将i声明为const原因一样。
//因为charp已经是一个类型的别名了，这点和define差别很大。

#define Str(x) #x
char *name = Str(plus);//name = "plus"将参数扩展然后字符串化操作。##进行连接两个宏值，具体可以参见宏定义声明。

//为什么不能对void *指针进行算术运算？
//因为编译器不知道所指对象大小，不能清晰的进行汇编步骤处理。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
标准输入输出库
printf格式输出对应类型
这里写图片描述 
这里写图片描述 
printf(“%*d” , width , x);//实现可变域宽度的printf。 
未完待续，以后继续查看。

库函数
操作符优先级及求值顺序差别
这里写图片描述

优先级决定操作符和操作数绑定顺序。操作符按照优先级从高到低的顺序与操作符进行绑定。先在表达式里面找出操作符，优先级高的先绑定，加入操作符优先级相同，就按照关联规则处理。如果关联规则从左向右，那么表达式更接近左边的操作符将有着更高的优先级，否则相反。 
重要的几点： 
0、一元操作符优先级仅仅低于前述运算符，具有很高的优先级。 
1、6个关系运算符优先级高于逻辑运算符。if(a >b && c >d)这种表达合理。 
2、6个关系运算符里面==和！=低于其他关系运算符号，if(a < b == c < d)比较a与b的相对大小顺序是否和c与d相对大小顺序一样，这种写法合理。b = a>10 && c<5 ? 1:2;这种写法同样合理。 
3、*p++，优先级相同，编译器解释成*(p++)取出p所指对象然后p自增。 
4、赋值运算符优先级较低，注意这种写法if( (c = func()) != 12);

求值顺序代表对操作数进行求值的顺序，和优先级是完全不一样的规则。 
优先级将 a+b*c解释成a + (b * c),当并没有保证a 和 b*c的求值顺序。一般来说编译器随机决定求值顺序。 
1、C语言中只有四个运算符(&&、||、？：、,)。存在规定的求值顺序。&&和||先进行左侧求值，需要时候进行右侧。a？b：c中，操作数a先求值，根据a在求b或者c。逗号运算符，首先左侧操作数求值，然后丢弃该值，再对右侧操作数求值，其他求值顺序未定义。

x = 5;
z = x / ++x;//先求x，z = 5/6 = 0；先求x++，z = 6/6 = 1。
/*z结果未定义，编译器将表达式解释成 z = ( x / (++x) ),但是x或者++x求值顺序不确定,假如++x先求值（因为是++x所以求值返回结果是6）然后取出x，那么x=6。那就是z = 1。假如x先求值，那么x=5，然后++x = 6，那就是z = 0；
*/

z = x / x++;//先求x，z = 5/5 = 1；先求x++，z = 6/5 = 1。

y[i++] = x[i];//综上所述，结果同意未定义，出现很大的错误。
y[i++] = x[i];//综上所述，结果同意未定义，出现很大的错误。

x++;//规定x++返回值是x原来值，然后x+1。
++x;//规定++x返回值是x+1后的值，然后x+1。

x = 2;
y = x + x++ +2;//这种结果未定义，因为求值顺序不确定
                //先求x，y = 2 + 2 + 2 = 6;先求x++，y = 3 + 2 + 2 = 7； 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
综上所述，清楚了解操作符优先级及求值顺序的规则非常重要。

链接
to be continue

运行时的数据结构
搞懂C函数过程调用很重要 
内存分配和段定义很重要 
这里写图片描述

再论数组和指针
1、数组和指针相等情况： 
这里写图片描述 
2、作为函数参数的数组名等同于指针，仅仅将数组地址复制给子函数（在子函数里面表现为指针)，然后子函数通过指针引用实参。数组参数的地址和数组参数的第一个元素的地址不一样，并且sizeof形参和sizeof实参也不一样。

#include <stdio.h>

char ga[] = "abcdefgh";
void my_array_func(char ca[])
{
    printf("addr of array param = %#x \n" , &ca);//取指针变量地址
    printf("sizeof(ca) = %d \n" , sizeof(ca) );//指针变量占用多少字节
    printf("addr (ca[0]) = %#x \n" , &ca[0]);
    printf("addr (ca[1]) = %#x \n" , &ca[1]);
    printf("++ca = %#x \n\n" , ++ca);
}
void my_pointer_func(char *pa)
{
    printf("addr of ptr param = %#x \n" , &pa);//取指针变量地址
    printf("sizeof(pa) = %d \n" , sizeof(pa) );//指针变量占用多少字节
    printf("addr (pa[0]) = %#x \n" , &pa[0]);
    printf("addr (pa[1]) = %#x \n" , &pa[1]);
    printf("++pa = %#x \n\n" , ++pa);
}
int main () {
    printf("addr of global array = %#x \n" , ga);//取指针变量地址
    printf("sizeof(ga) = %d \n" , sizeof(ga) );//数组变量占用多少字节
    printf("addr (ga[0]) = %#x \n" , &ga[0]);
    printf("addr (ga[1]) = %#x \n\n" , &ga[1]);
    my_array_func(ga);
    my_pointer_func(ga);
    return 0;
}
/*
变量名始终表示变量的取值：char *pa = 1234，就表示一块内存上面存储了1234，char* 只是说明了1234的类型是一个指针。char ch = 12，就表示一块内存上面存储了12，char只是说明了12的类型是一个字符。所以&pa和&ch都可以得到存储内存块的首部编号，也就是首地址，而对于pa其首地址的类型就是指针的指针，ch其首地址就是指针。所有的修改都是基于内存编号及其上面所放的数值。
抽象的理解类型定义即可。不必纠结这些细节地方。
*/
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
这里写图片描述 
addr of global array = 0x601034 
sizeof(ga) = 9 
addr (ga[0]) = 0x601034 
addr (ga[1]) = 0x601035 
addr of array param = 0xb695afc8 
sizeof(ca) = 8 
addr (ca[0]) = 0x601034 
addr (ca[1]) = 0x601035 
++ca = 0x601035 
addr of ptr param = 0xb695afc8 
sizeof(pa) = 8 
addr (pa[0]) = 0x601034 
addr (pa[1]) = 0x601035 
++pa = 0x601035

3、分解多维数组 
这里写图片描述 
r++，t++将会各自指向它们下一个元素，增加的步长不一样。之所以有这么多类型，就是为了指导编译器在编译器期间，如何在内存上面取值。不同类型，取值增加的步长不一样。这就是所谓的规则，理解这些规则之后，分析代码,写代码就更加沉着稳定安心。因为理解了编译器的工作行为。

4、数组的数组和指针数组的寻址：理解这个过程有点作用。

这里写图片描述

5、数组形参被编译器如何修改 
这里写图片描述
注意数组指针是行指针，也就是二维数组名是行指针类型，和指针的指针不一样。

OOP
类
面向对象的关键就是把一些数据和对这些数据进行操作的代码组合在一起，并用某种时髦手法将它们做成一个单元。许多编程语言把这种类型的单元称为 ”class (类)“。类是一种用户定义类型，就好像是int这样的内置类型一样。内置类型己经有了­一套完善的外对它的操作(如算术运算等) ，类机制也必须允许程序员规定他所定义的类能够进行的操作。类里面的任何东西被称为类的成员。 
类经常被实现的形式是:一个包含多个数据的结构，加上对这些数据进行操作的函数的指针。编译器施行强类型一一确保这些函数只会被该类的对象调用，而且该类的对象无法调用除它们之外的其他函数。上面是一种定义，而这是定义对应的实现形式，和C语言里面函数指针类似。

/*
类定义类似结构体。
1、访问控制：
public：类外部可见，可以被按需设置调用操纵。数据应该私      有，这才符合OOP，函数应该是公用的，使得外部可用。
protected：只能由类本身函数以及派生类函数使用。
private：只能被类成员使用，对于外部可见（名字已知），但是却不能访问。
friend：每次只能声明一个变量。后面不要冒号。函数不属于类的成员函数，但可以像成员函数一样访问类的protected和private成员。friend可以是函数也可以是类。
virtual：每次只能声明一个变量。后面不要冒号。
2、声明：就是正常的C语言声明。类中的每个函数声明都需要对应一个实现，实现可以在类里面，也可以在类外面（通常）。
3、this指针，每一个成员函数都被隐式给该函数一个this指针参数指向改对象，允许对象成员函数引用对象本身。
4、构造函数：对象创建隐式被调用，负责对象初始化。很重要，因为外部函数都不能访问private成员，所以很有必要一个特权函数对其初始化。这是一个飞跃，比C语言多了一些优点。构造函数可以多个，通过参数区分。
   析构函数：对象被销毁隐式调用，每构造常用，一般用于处理特殊终止要求以及垃圾回收机制。这两个函数机制违反了C语言的哲学-一切工作自己负责的原则。
*/
class 类名{
    访问控制：声明
    访问控制：声明

};
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
对象
某个类的一个特定变量，就像j可能是int类型的一个变量一样。对象也可以被称作类的实例 (instance)。

封装
把类型、数据和函数组合在一起，组成一个类。在 C 语言中，头文件就是一个作常脆弱的封装实例。它之所以是一个微不足道的封装例子，是因为它的组合形式是纯词法意义上的，编译器并不知道头文件是一个语义单位。

继承
这是一个很大的概念一一允许类从一个更简单的基类中接收数据结构和函数。派生类获得基类的数据和操作，并可以根据需要对它们进行改写，也可以在派生类中增加新的数据和函数成员。在C语言里不存在继承的概念，没有任何东西可以模拟这个特性。

class Fruit
{
    public:
        peel();
        slice();
        juice();
    privite:
        int weight , calories_per_oz;
}
class Apple : public Fruit //从公共Fruit中派生
{
    public：
        void make_candy_apple(float weight);
}
//区别于嵌套类，狗里面不肯能嵌套哺乳动物，应该是狗继承了哺乳动物的特征。思考自己所面对的情形，选择合适用法。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
多重继承：用的灰常少，没有哪个例子证明需要用到多重继承。

重载：运行时通过参数类型确定调用哪个函数，作用于不同类型的同一操作具有相同的名字。C语言中浮点数加法，整形加法，这都是+重载例子。C++允许创建新类型，并且赋予+不同的含义。

class Fruit
{
    public:
        peel();
        slice();
        juice();
        int opetator+(Fruit &f);//提示重载+
    privite:
        int weight , calories_per_oz;
}
int Fruit::opetator+(Fruit &f)
{
    printf("calling ");
    return (weight + f.weight);
}

Apple apple;
Fruit orange;
int o = apple + orange;//apple通过this访问，orange通过引用访问。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
多态：支持相关的对象具有不同的成员函数(但原型相同) ，并允许对象与适当的成员函数进行运行时绑定。C++通过覆盖(override)支持这种机制一一所有的多态成员函数具有相同的名字，由运行时系统判断哪一个最为合适。当使用继承时就要用到这种机制:有时你无法在编译时分辨所拥有的对象到底是基类对象还是派生类对象。这个判断并调用正确的函数的过程被称为”后期绑定(late binding) “。在成员函数前面加上virtual关键字告诉编译器该成员函数是多态的(也就是虚拟函数)。 
多态非常有用，因为它意味着可以给类似的东西取相同的名字，运行时系统在几个名字相同的函数中选择了正确的一个进行调用，这就是多态。

class Fruit
{
    public:
        void peel()//水果类有去皮
        {
            printf("peeling ");
        }
        void slice();
        void juice();
    privite:
        int weight , calories_per_oz;
}
class Apple : public Fruit //从公共Fruit中派生苹果类，也有去皮操作，但是可能和水果类去皮方式不同，这就需要多态了，那么可以同名，C++使用覆盖的方法进行处理。这种抽象真是的太牛逼了，将事物高度抽象。
{
    public：
        void peel()
        {
            printf("apple peel");
        }
        void make_candy_apple(float weight);
}
Fruit banana;
banana.peel();//输出peeling,一切正常。

Fruit *p;
p = new Apple;
p->peel();
//输出peeling，为苹果量身定做的peel没有被调用。
/*
为什么会出现上述问题？
当想用派生类的成员函数取代基类的同名函数时，C++要求你必须预先通知编译器;通知的方法就是在可能会被取代的基类成员函数前面加上virtual关键字，需要许多背景知识才能理解这样问题。这才是讲解知识点嘛，外国人写书就是这么牛逼。。。娓娓道来，让人一听就明白，一听就懂。virtual含义：它的意思是不让用户看到事实上存在的东西(基类的成员函数)。换用一个更有意义的关键字(虽然长得不切实际)。在上面Apple peel前面加上virtual就可以正确输出了。

多态如何表现出来？
C++内部实现是通过函数指针向量表和一个指向这个向量的vtbl指针来实现的。
在C++里面为了满足多态、重载等等功能，C++编译器需要进行很多处理，为了在内存上面取指令的形式和这种操作对应起来，需要花费大量的精力考虑算法如何设计才可以满足多态，重载等等取得的功能。所以C++编译器必定比C编译器大的多多的。
*/
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
模版：完全为了对应泛型编程设计，让算法适用于不同的类型。 
内联函数：C++里面也有，在调用的地方展开函数，省略了过程调用开销，函数里面内容应该相对较小才可以进行内联处理。 
new和delete操作符：new可以自动sizeof对象分配需要多少，malloc不可能必须手动，为什么会出现这种功能，都是编译器设计方便了我们的操作。 
传引用：C语言中只有传值调用，C++引入传引用，可以把对象引用作为参数传递。

参考书籍：
《C专家编程》极度推荐，讲解了许多C语言里面的实现细节。 
《C陷阱与缺陷》 
《C语言解惑》 
《你必须知道的495个C语言问题》
* C 程序结构
由 authenty 创建，Alma 最后一次修改 2015-09-22
C 程序结构
在我们学习 C 语言的基本构建块之前，让我们先来看看一个最小的 C 程序结构，在接下来的章节中可以以此作为参考。

C Hello World 实例
C 程序主要包括以下部分：

预处理器指令
函数
变量
语句 & 表达式
注释
让我们看一段简单的代码，可以输出单词 "Hello World"：

#include <stdio.h>

int main()
{
   /* 我的第一个 C 程序 */
   printf("Hello, World! \n");
   
   return 0;
}
接下来我们讲解一下上面这段程序：

程序的第一行 #include <stdio.h> 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。
下一行 int main() 是主函数，程序从这里开始执行。
下一行 /*...*/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。
下一行 printf(...) 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。
下一行 return 0; 终止 main() 函数，并返回值 0。
编译 & 执行 C 程序
接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：

打开一个文本编辑器，添加上述代码。
保存文件为 hello.c。
打开命令提示符，进入到保存文件所在的目录。
键入 gcc hello.c，输入回车，编译代码。
如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。
现在，键入 a.out 来执行程序。
您可以看到屏幕上显示 "Hello World"。
$ gcc hello.c
$ ./a.out
Hello, World!
请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 hello.c 的目录中运行它。
* C 基本语法
由 authenty 创建，Loen 最后一次修改 2015-09-17
C 基本语法
我们已经看过 C 程序的基本结构，这将有助于我们理解 C 语言的其他基本的构建块。

C 的令牌（Tokens）
C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：

printf("Hello, World! \n");
这五个令牌分别是：

printf
(
"Hello, World! \n"
)
;
分号 ;
在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

例如，下面是两个不同的语句：

printf("Hello, World! \n");
return 0;
注释
注释就像是 C 程序中的帮助文本，它们会被编译器忽略。它们以 /* 开始，以字符 */ 终止，如下所示：

/* 我的第一个 C 程序 */
您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。

标识符
C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。下面列出几个有效的标识符：

mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
关键字
下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。

auto	else	long	switch
break	enum	register	typedef
case	extern	return	union
char	float	short	unsigned
const	for	signed	void
continue	goto	sizeof	volatile
default	if	static	while
do	int	struct	_Packed
double	 	 	 

C 中的空格
只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。

在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

int age;
在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

fruit = apples + oranges;   // 获取水果的总数
fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。
* C 数据类型
由 authenty 创建，Alma 最后一次修改 2015-09-22
C 数据类型
在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

序号	类型与描述
1	基本类型：
它们是算术类型，包括两种类型：整数类型和浮点类型。
2	枚举类型：
它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。
3	void 类型：
类型说明符 void 表明没有可用的值。
4	派生类型：
它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。

数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。在本章节接下来的部分我们将介绍基本类型，其他几种类型会在后边几个章节中进行讲解。

整数类型
下表列出了关于标准整数类型的存储大小和值范围的细节：

类型	存储大小	值范围
char	1 byte	-128 到 127 或 0 到 255
unsigned char	1 byte	0 到 255
signed char	1 byte	-128 到 127
int	2 或 4 bytes	-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647
unsigned int	2 或 4 bytes	0 到 65,535 或 0 到 4,294,967,295
short	2 bytes	-32,768 到 32,767
unsigned short	2 bytes	0 到 65,535
long	4 bytes	-2,147,483,648 到 2,147,483,647
unsigned long	4 bytes	0 到 4,294,967,295
为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：

#include <stdio.h>
#include <limits.h>

int main()
{
   printf("Storage size for int : %d \n", sizeof(int));
   
   return 0;
}
当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：

Storage size for int : 4
浮点类型
下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

类型	存储大小	值范围	精度
float	4 byte	1.2E-38 到 3.4E+38	6 位小数
double	8 byte	2.3E-308 到 1.7E+308	15 位小数
long double	10 byte	3.4E-4932 到 1.1E+4932	19 位小数
头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：

#include <stdio.h>
#include <float.h>

int main()
{
   printf("Storage size for float : %d \n", sizeof(float));
   printf("Minimum float positive value: %E\n", FLT_MIN );
   printf("Maximum float positive value: %E\n", FLT_MAX );
   printf("Precision value: %d\n", FLT_DIG );
   
   return 0;
}
当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：

Storage size for float : 4
Minimum float positive value: 1.175494E-38
Maximum float positive value: 3.402823E+38
Precision value: 6
void 类型
void 类型指定没有可用的值。它通常用于以下三种情况下：

序号	类型与描述
1	函数返回为空
C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);
2	函数参数为空
C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);
3	指针指向 void
类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。
如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。

您的支持将鼓励我们做得更好
赞赏支持
* C 变量
由 authenty 创建，Loen 最后一次修改 2015-09-14
C 变量
变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：

类型	描述
char	通常是一个八位字节（一个字节）。这是一个整数类型。
int	对机器而言，整数的最自然的大小。
float	单精度浮点值。
double	双精度浮点值。
void	表示类型的缺失。

C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的章节中进行讲解，本章节我们先讲解基本变量类型。

C 中的变量定义
变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

type variable_list;
在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：

int    i, j, k;
char   c, ch;
float  f, salary;
double d;
行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。

变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：

type variable_name = value;
下面列举几个实例：

extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。

C 中的变量声明
变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

实例
尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：

#include <stdio.h>

// 变量声明
extern int a, b;
extern int c;
extern float f;

int main ()
{
  /* 变量定义 */
  int a, b;
  int c;
  float f;
 
  /* 实际初始化 */
  a = 10;
  b = 20;
  
  c = a + b;
  printf("value of c : %d \n", c);

  f = 70.0/3.0;
  printf("value of f : %f \n", f);
 
  return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

value of c : 30
value of f : 23.333334
同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：

// 函数声明
int func();

int main()
{
    // 函数调用
    int i = func();
}

// 函数定义
int func()
{
    return 0;
}
C 中的左值（Lvalues）和右值（Rvalues）
C 中有两种类型的表达式：

左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。
变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

int g = 20;
但是下面这个就不是一个有效的语句，会生成编译时错误：

10 = 20;
* C 常量
由 authenty 创建，Loen 最后一次修改 2015-09-08
C 常量
常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

整数常量
整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数常量的实例：

212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
以下是各种类型的整数常量的实例：

85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
浮点常量
浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：

3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
字符常量
字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

转义序列	含义
\\	\ 字符
\'	' 字符
\"	" 字符
\?	? 字符
\a	警报铃声
\b	退格键
\f	换页符
\n	换行符
\r	回车
\t	水平制表符
\v	垂直制表符
\ooo	一到三位的八进制数
\xhh . . .	一个或多个数字的十六进制数
下面的实例显示了一些转义序列字符：

#include <stdio.h>

int main()
{
   printf("Hello\tWorld\n\n");

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Hello   World

字符串常量
字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
定义常量
在 C 中，有两种简单的定义常量的方式：

使用 #define 预处理器。
使用 const 关键字。
#define 预处理器
下面是使用 #define 预处理器定义常量的形式：

#define identifier value
具体请看下面的实例：

#include <stdio.h>

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main()
{

   int area;  
  
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

value of area : 50
const 关键字
您可以使用 const 前缀声明指定类型的常量，如下所示：

const type variable = value;
具体请看下面的实例：

#include <stdio.h>

int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

value of area : 50
请注意，把常量定义为大写字母形式，是一个很好的编程实践
* C 存储类
由 authenty 创建，youj 最后一次修改 2015-09-07
C 存储类
存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

auto
register
static
extern
auto 存储类
auto 存储类是所有局部变量默认的存储类。

{
   int mount;
   auto int month;
}
上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

register 存储类
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

{
   register int  miles;
}
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

static 存储类
static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C 编程中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

#include <stdio.h>
 
/* 函数声明 */
void func(void);
 
static int count = 5; /* 全局变量 */
 
main()
{
   while(count--)
   {
      func();
   }
   return 0;
}
/* 函数定义 */
void func( void )
{
   static int i = 5; /* 局部静态变量 */
   i++;

   printf("i is %d and count is %d\n", i, count);
}
可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：

i is 6 and count is 4
i is 7 and count is 3
i is 8 and count is 2
i is 9 and count is 1
i is 10 and count is 0
extern 存储类
extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.c

#include <stdio.h>
 
int count ;
extern void write_extern();
 
main()
{
   count = 5;
   write_extern();
}
第二个文件：support.c

#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：

 $gcc main.c support.c
这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：

count is 5
* C 运算符
由 authenty 创建，youj 最后一次修改 2015-09-19
C 运算符
运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：

算术运算符
关系运算符
逻辑运算符
位运算符
赋值运算符
杂项运算符
本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和杂项运算符。

算术运算符
下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：

运算符	描述	实例
+	把两个操作数相加	A + B 将得到 30
-	从第一个操作数中减去第二个操作数	A - B 将得到 -10
*	把两个操作数相乘	A * B 将得到 200
/	分子除以分母	B / A 将得到 2
%	取模运算符，整除后的余数	B % A 将得到 0
++	自增运算符，整数值增加 1	A++ 将得到 11
--	自减运算符，整数值减少 1	A-- 将得到 9
实例
请看下面的实例，了解 C 语言中所有可用的算术运算符：

#include <stdio.h>

int main()
{
   int a = 21;
   int b = 10;
   int c ;

   c = a + b;
   printf("Line 1 - c 的值是 %d\n", c );
   c = a - b;
   printf("Line 2 - c 的值是 %d\n", c );
   c = a * b;
   printf("Line 3 - c 的值是 %d\n", c );
   c = a / b;
   printf("Line 4 - c 的值是 %d\n", c );
   c = a % b;
   printf("Line 5 - c 的值是 %d\n", c );
   c = a++; 
   printf("Line 6 - c 的值是 %d\n", c );
   c = a--; 
   printf("Line 7 - c 的值是 %d\n", c );

}
当上面的代码被编译和执行时，它会产生下列结果：

Line 1 - c 的值是 31
Line 2 - c 的值是 11
Line 3 - c 的值是 210
Line 4 - c 的值是 2
Line 5 - c 的值是 1
Line 6 - c 的值是 21
Line 7 - c 的值是 22
以下实例演示了 a++ 与 ++a 的区别： a++ 和 ++a的相同点都是给a+1，不同点是a++是先赋值再+1，而++a则是先+1再参赋值。

实例
#include <stdio.h>
int main()
{
int c;
int a = 10;
c = a++;
printf("先赋值后运算：\n");
printf("Line 1 - c 的值是 %d\n", c );
printf("Line 2 - a 的值是 %d\n", a );
a = 10;
c = a--;
printf("Line 3 - c 的值是 %d\n", c );
printf("Line 4 - a 的值是 %d\n", a );
printf("先运算后赋值：\n");
a = 10;
c = ++a;
printf("Line 5 - c 的值是 %d\n", c );
printf("Line 6 - a 的值是 %d\n", a );
a = 10;
c = --a;
printf("Line 7 - c 的值是 %d\n", c );
printf("Line 8 - a 的值是 %d\n", a );
}

以上程序执行输出结果为：

先赋值后运算：
Line 1 - c 的值是 10
Line 2 - a 的值是 11
Line 3 - c 的值是 10
Line 4 - a 的值是 9
先运算后赋值：
Line 5 - c 的值是 11
Line 6 - a 的值是 11
Line 7 - c 的值是 9
Line 8 - a 的值是 9

关系运算符
下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：

运算符	描述	实例
==	检查两个操作数的值是否相等，如果相等则条件为真。	(A == B) 不为真。
!=	检查两个操作数的值是否相等，如果不相等则条件为真。	(A != B) 为真。
>	检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(A > B) 不为真。
<	检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(A < B) 为真。
>=	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A >= B) 不为真。
<=	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A <= B) 为真。
实例
请看下面的实例，了解 C 语言中所有可用的关系运算符：

#include <stdio.h>

int main()
{
   int a = 21;
   int b = 10;
   int c ;

   if( a == b )
   {
      printf("Line 1 - a 等于 b\n" );
   }
   else
   {
      printf("Line 1 - a 不等于 b\n" );
   }
   if ( a < b )
    { 
            printf("Line 2 - a 小于 b\n" );
    }
    else
    {
            printf("Line 2 - a 不小于 b\n" );
    }
   if ( a > b )
   {
      printf("Line 3 - a 大于 b\n" );
   }
   else
   {
      printf("Line 3 - a 不大于 b\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 5;
   b = 20;
   if ( a <= b )
    {       printf("Line 4 - a 小于或等于 b\n" );
    }
    if ( b >= a )
   {
      printf("Line 5 - b 大于或等于 b\n" );
   }
}
当上面的代码被编译和执行时，它会产生下列结果：

Line 1 - a 不等于 b
Line 2 - a 不小于 b
Line 3 - a 大于 b
Line 4 - a 小于或等于 b
Line 5 - b 大于或等于 b
逻辑运算符
下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则：

运算符	描述	实例
&&	称为逻辑与运算符。如果两个操作数都非零，则条件为真。	(A && B) 为假。
||	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(A || B) 为真。
!	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(A && B) 为真。
实例
请看下面的实例，了解 C 语言中所有可用的逻辑运算符：

#include <stdio.h>

int main()
{
   int a = 5;
   int b = 20;
   int c ;

   if ( a && b )
   {
      printf("Line 1 - 条件为真\n" );
   }
   if ( a || b )
   {
      printf("Line 2 - 条件为真\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 0;
   b = 10;
   if ( a && b )
   {
      printf("Line 3 - 条件为真\n" );
   }
   else
   {
      printf("Line 3 - 条件不为真\n" );
   }
   if ( !(a && b) )
   {
      printf("Line 4 - 条件为真\n" );
   }
}
当上面的代码被编译和执行时，它会产生下列结果：

Line 1 - 条件为真
Line 2 - 条件为真
Line 3 - 条件不为真
Line 4 - 条件为真
位运算符
位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

p	q	p & q	p | q	p ^ q
0	0	0	0	0
0	1	0	1	1
1	1	1	1	0
1	0	0	1	1
假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

A = 0011 1100

B = 0000 1101

-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A  = 1100 0011

下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：

运算符	描述	实例
&	按位与操作，按二进制位进行“与”运算。运算规则： 
0&0=0;
0&1=0;
1&0=0;
1&1=1;
(A & B) 将得到 12，即为 0000 1100
|	按位或运算符，按二进制位进行“或”运算。运算规则：
0|0=0;
0|1=1;
1|0=1;
1|1=1;
(A | B) 将得到 61，即为 0011 1101
^	异或运算符，按二进制位进行“异或”运算。运算规则：
0^0=0;
0^1=1;
1^0=1;
1^1=0
(A ^ B) 将得到 49，即为 0011 0001
~	取反运算符，按二进制位进行“取反”运算。运算规则：
~1=0;
~0=1;
(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。
<<	二进制左移运算符。左操作数的值向左移动右操作数指定的位数（左边的二进制位丢弃，右边补0）。	A << 2 将得到 240，即为 1111 0000
>>	二进制右移运算符。左操作数的值向右移动右操作数指定的位数（正数左补0，负数左补1，右边丢弃）。	A >> 2 将得到 15，即为 0000 1111
实例
请看下面的实例，了解 C 语言中所有可用的位运算符：

#include <stdio.h>

int main()
{

   unsigned int a = 60; /* 60 = 0011 1100 */  
   unsigned int b = 13; /* 13 = 0000 1101 */
   int c = 0;           

   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - c 的值是 %d\n", c );

   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - c 的值是 %d\n", c );

   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - c 的值是 %d\n", c );

   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - c 的值是 %d\n", c );

   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - c 的值是 %d\n", c );

   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - c 的值是 %d\n", c );
}
当上面的代码被编译和执行时，它会产生下列结果：

Line 1 - c 的值是 12
Line 2 - c 的值是 61
Line 3 - c 的值是 49
Line 4 - c 的值是 -61
Line 5 - c 的值是 240
Line 6 - c 的值是 15
赋值运算符
下表列出了 C 语言支持的赋值运算符：

运算符	描述	实例
=	简单的赋值运算符，把右边操作数的值赋给左边操作数	C = A + B 将把 A + B 的值赋给 C
+=	加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数	C += A 相当于 C = C + A
-=	减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数	C -= A 相当于 C = C - A
*=	乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数	C *= A 相当于 C = C * A
/=	除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数	C /= A 相当于 C = C / A
%=	求模且赋值运算符，求两个操作数的模赋值给左边操作数	C %= A 相当于 C = C % A
<<=	左移且赋值运算符	C <<= 2 等同于 C = C << 2
>>=	右移且赋值运算符	C >>= 2 等同于 C = C >> 2
&=	按位与且赋值运算符	C &= 2 等同于 C = C & 2
^=	按位异或且赋值运算符	C ^= 2 等同于 C = C ^ 2
|=	按位或且赋值运算符	C |= 2 等同于 C = C | 2
实例
请看下面的实例，了解 C 语言中所有可用的赋值运算符：

#include <stdio.h>

int main()
{
   int a = 21;
   int c ;

   c =  a;
   printf("Line 1 - =  运算符实例，c 的值 = %d\n", c );

   c +=  a;
   printf("Line 2 - += 运算符实例，c 的值 = %d\n", c );

   c -=  a;
   printf("Line 3 - -= 运算符实例，c 的值 = %d\n", c );

   c *=  a;
   printf("Line 4 - *= 运算符实例，c 的值 = %d\n", c );

   c /=  a;
   printf("Line 5 - /= 运算符实例，c 的值 = %d\n", c );

   c  = 200;
   c %=  a;
   printf("Line 6 - %= 运算符实例，c 的值 = %d\n", c );

   c <<=  2;
   printf("Line 7 - <<= 运算符实例，c 的值 = %d\n", c );

   c >>=  2;
   printf("Line 8 - >>= 运算符实例，c 的值 = %d\n", c );

   c &=  2;
   printf("Line 9 - &= 运算符实例，c 的值 = %d\n", c );

   c ^=  2;
   printf("Line 10 - ^= 运算符实例，c 的值 = %d\n", c );

   c |=  2;
   printf("Line 11 - |= 运算符实例，c 的值 = %d\n", c );

}
当上面的代码被编译和执行时，它会产生下列结果：

Line 1 - =  运算符实例，c 的值 = 21
Line 2 - += 运算符实例，c 的值 = 42
Line 3 - -= 运算符实例，c 的值 = 21
Line 4 - *= 运算符实例，c 的值 = 441
Line 5 - /= 运算符实例，c 的值 = 21
Line 6 - %= 运算符实例，c 的值 = 11
Line 7 - <<= 运算符实例，c 的值 = 44
Line 8 - >>= 运算符实例，c 的值 = 11
Line 9 - &= 运算符实例，c 的值 = 2
Line 10 - ^= 运算符实例，c 的值 = 0
Line 11 - |= 运算符实例，c 的值 = 2
杂项运算符
下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof()、&、* 和 ? :。

运算符	描述	实例
sizeof()	返回变量的大小。	sizeof(a) 将返回 4，其中 a 是整数。
&	返回变量的地址。	&a; 将给出变量的实际地址。
*	指向一个变量。	*a; 将指向一个变量。
? :	条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y
实例
请看下面的实例，了解 C 语言中所有可用的杂项运算符：

#include <stdio.h>

int main()
{
   int a = 4;
   short b;
   double c;
   int* ptr;

   /* & 和 * 运算符实例 */
   ptr = &a;    /* 'ptr' 现在包含 'a' 的地址 */
   printf("a 的值是 %d\n", a);
   printf("*ptr 是 %d\n", *ptr);

   /* 三元运算符实例 */
   a = 10;
   b = (a == 1) ? 20: 30;
   printf( "b 的值是 %d\n", b );

   b = (a == 10) ? 20: 30;
   printf( "b 的值是 %d\n", b );
}
当上面的代码被编译和执行时，它会产生下列结果：

a 的值是 4
*ptr 是 4
b 的值是 30
b 的值是 20
C 中的运算符优先级
运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。

例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

类别 	运算符 	结合性 
后缀 	() [] -> . ++ - -  	从左到右 
一元 	+ - ! ~ ++ - - (type)* & sizeof 	从右到左 
乘除 	* / % 	从左到右 
加减 	+ - 	从左到右 
移位 	<< >> 	从左到右 
关系 	< <= > >= 	从左到右 
相等 	== != 	从左到右 
位与 AND 	& 	从左到右 
位异或 XOR 	^ 	从左到右 
位或 OR 	| 	从左到右 
逻辑与 AND 	&& 	从左到右 
逻辑或 OR 	|| 	从左到右 
条件 	?: 	从右到左 
赋值 	= += -= *= /= %=>>= <<= &= ^= |= 	从右到左 
逗号 	, 	从左到右 
实例
请看下面的实例，了解 C 语言中运算符的优先级：

#include <stdio.h>

int main()
{
   int a = 20;
   int b = 10;
   int c = 15;
   int d = 5;
   int e;
 
   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   printf("(a + b) * c / d 的值是 %d\n",  e );

   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   printf("((a + b) * c) / d 的值是 %d\n" ,  e );

   e = (a + b) * (c / d);   // (30) * (15/5)
   printf("(a + b) * (c / d) 的值是 %d\n",  e );

   e = a + (b * c) / d;     //  20 + (150/5)
   printf("a + (b * c) / d 的值是 %d\n" ,  e );
  
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

(a + b) * c / d 的值是 90
((a + b) * c) / d 的值是 90
(a + b) * (c / d) 的值是 90
a + (b * c) / d 的值是 50

您的支持将鼓励我们做得更好
赞赏支持
* C 函数
由 authenty 创建，Loen 最后一次修改 2015-09-07
C 函数
函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。

C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。

定义函数
C 语言中的函数定义的一般形式如下：

return_type function_name( parameter list )
{
   body of the function
}
在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。
函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
函数主体：函数主体包含一组定义函数执行任务的语句。
实例
以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：

/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
函数声明
函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

return_type function_name( parameter list );
针对上面定义的函数 max()，以下是函数声明：

int max(int num1, int num2);
在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

int max(int, int);
当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

调用函数
创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：

#include <stdio.h>
 
/* 函数声明 */
int max(int num1, int num2);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
   int ret;
 
   /* 调用函数来获取最大值 */
   ret = max(a, b);
 
   printf( "Max value is : %d\n", ret );
 
   return 0;
}
 
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：

Max value is : 200
函数参数
如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有两种向函数传递参数的方式：

调用类型	描述
传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。
引用调用	该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。
* C 数组
由 authenty 创建，youj 最后一次修改 2015-09-22
C 数组
C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

C 中的数组



声明数组
在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

type arrayName [ arraySize ];
这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下：

double balance[10];
现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

初始化数组
在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

balance[4] = 50.0;
上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

数组表示

访问数组元素
数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

double salary = balance[9];
上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

#include <stdio.h>
 
int main ()
{
   int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */
   int i,j;
 
    /* 初始化数组元素 */         
    for ( i = 0; i < 10; i++ )    {

        n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */
    }        /* 输出数组中每个元素的值 */
    for (j = 0; j < 10; j++ )    {
        printf("Element[%d] = %d\n", j, n[j] );
    }
    return 0;
} 
当上面的代码被编译和执行时，它会产生下列结果：

Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
C 中数组详解
在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：

概念	描述
多维数组	C 支持多维数组。多维数组最简单的形式是二维数组。
传递数组给函数	您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。
从函数返回数组	C 允许从函数返回数组。
指向数组的指针	您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。
* C 指针
由 authenty 创建，Loen 最后一次修改 2015-09-19
C 指针
学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

#include <stdio.h>

int main ()
{
   int  var1;
   char var2[10];

   printf("var1 变量的地址： %x\n", &var1  );
   printf("var2 变量的地址： %x\n", &var2  );

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

var1 变量的地址： bff5a400
var2 变量的地址： bff5a3f6
通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。

什么是指针？
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type *var-name;
在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch     /* 一个字符型的指针 */
所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

#include <stdio.h>

int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */

   ip = &var;  /* 在指针变量中存储 var 的地址 */

   printf("Address of var variable: %x\n", &var  );

   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %x\n", ip );

   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20
C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。

NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

#include <stdio.h>

int main ()
{
   int  *ptr = NULL;

   printf("ptr 的值是 %x\n", ptr  );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

ptr 的值是 0
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
C 指针详解
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：

概念	描述
指针的算术运算	可以对指针进行四种算术运算：++、--、+、-
指针数组	可以定义用来存储指针的数组。
指向指针的指针	C 允许指向指针的指针。
传递指针给函数	通过引用或地址传递参数，使传递的参数在调用函数中被改变。
从函数返回指针	C 允许函数返回指针到局部变量、静态变量和动态内存分配。
* C 字符串
由 authenty 创建，Loen 最后一次修改 2015-09-19
C 字符串
在 C 语言中，字符串实际上是使用 null 字符 '' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。

下面的声明和初始化创建了一个 "Hello" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 "Hello" 的字符数多一个。

char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};
依据数组初始化规则，您可以把上面的语句写成以下语句：

char greeting[] = "Hello";
以下是 C/C++ 中定义的字符串的内存表示：

C/C++ 中的字符串表示
其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 '' 放在字符串的末尾。让我们尝试输出上面的字符串：

#include <stdio.h>

int main ()
{
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};

   printf("Greeting message: %s\n", greeting );

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Greeting message: Hello
C 中有大量操作字符串的函数：

序号	函数 & 目的
1	strcpy(s1, s2);
复制字符串 s2 到字符串 s1。
2	strcat(s1, s2);
连接字符串 s2 到字符串 s1 的末尾。
3	strlen(s1);
返回字符串 s1 的长度。
4	strcmp(s1, s2);
如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。
5	strchr(s1, ch);
返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
6	strstr(s1, s2);
返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
下面的实例使用了上述的一些函数：

#include <stdio.h>
#include <string.h>

int main ()
{
   char str1[12] = "Hello";
   char str2[12] = "World";
   char str3[12];
   int  len ;

   /* 复制 str1 到 str3 */
   strcpy(str3, str1);
   printf("strcpy( str3, str1) :  %s\n", str3 );

   /* 连接 str1 和 str2 */
   strcat( str1, str2);
   printf("strcat( str1, str2):   %s\n", str1 );

   /* 连接后，str1 的总长度 */
   len = strlen(str1);
   printf("strlen(str1) :  %d\n", len );

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

strcpy( str3, str1) :  Hello
strcat( str1, str2):   HelloWorld
strlen(str1) :  10
您可以在 C 标准库中找到更多字符串相关的函数。
* C 结构体
由 authenty 创建，Loen 最后一次修改 2015-09-08
C 结构体
C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：

Title
Author
Subject
Book ID
定义结构
为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];  
structure tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;  
访问结构成员
为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法：

#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Book */
   struct Books Book2;        /* 声明 Book2，类型为 Book */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printf( "Book 1 title : %s\n", Book1.title);
   printf( "Book 1 author : %s\n", Book1.author);
   printf( "Book 1 subject : %s\n", Book1.subject);
   printf( "Book 1 book_id : %d\n", Book1.book_id);

   /* 输出 Book2 信息 */
   printf( "Book 2 title : %s\n", Book2.title);
   printf( "Book 2 author : %s\n", Book2.author);
   printf( "Book 2 subject : %s\n", Book2.subject);
   printf( "Book 2 book_id : %d\n", Book2.book_id);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
结构作为函数参数
您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：

#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Book */
   struct Books Book2;        /* 声明 Book2，类型为 Book */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printBook( Book1 );

   /* 输出 Book2 信息 */
   printBook( Book2 );

   return 0;
}
void printBook( struct Books book )
{
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}
当上面的代码被编译和执行时，它会产生下列结果：

Book title : C Programming
Book author : Nuha Ali
Book subject : C Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
指向结构的指针
您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：

struct Books *struct_pointer;
现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：

struct_pointer = &Book1;
为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：

struct_pointer->title;
让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：

#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Book */
   struct Books Book2;        /* 声明 Book2，类型为 Book */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;

   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &Book1 );

   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &Book2 );

   return 0;
}
void printBook( struct Books *book )
{
   printf( "Book title : %s\n", book->title);
   printf( "Book author : %s\n", book->author);
   printf( "Book subject : %s\n", book->subject);
   printf( "Book book_id : %d\n", book->book_id);
}
当上面的代码被编译和执行时，它会产生下列结果：

Book title : C Programming
Book author : Nuha Ali
Book subject : C Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
位域
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

典型的实例：

用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。
读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。
位域的定义和位域变量的说明
位域定义与结构定义相仿，其形式为：

    struct 位域结构名
        { 位域列表 };
其中位域列表的形式为：

    类型说明符 位域名: 位域长度 
例如：

struct bs{
    int a:8;
    int b:2;
    int c:6;
};
位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：

struct bs{
    int a:8;
    int b:2;
    int c:6;
}data;
说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。

让我们再来看一个实例：

struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;
在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。

对于位域的定义尚有以下几点说明：

一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：

struct bs{
    unsigned a:4;
    unsigned  :4;    /* 空域 */
    unsigned b:4;    /* 从下一单元开始存放 */
    unsigned c:4
}
在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。

由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。
位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：

struct k{
    int a:1;
    int  :2;    /* 该 2 位不能使用 */
    int b:3;
    int c:2;
};
从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。

位域的使用
位域的使用和结构成员的使用相同，其一般形式为：

    位域变量名·位域名
位域允许用各种格式输出。

请看下面的实例：

main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;   /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);  /* 以整型量格式输出三个域的内容 */
    pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit->a=0;   /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit->b&=3;  /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */
    pbit->c|=1;  /* 使用了复合位运算符"|="，相当于：pbit->c=pbit->c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);    /* 用指针方式输出了这三个域的值 */
}
上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。
* C 共用体
由 authenty 创建，Loen 最后一次修改 2015-09-07
C 共用体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

定义共用体
为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：

union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];  
union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

union Data
{
   int i;
   float f;
   char  str[20];
} data;  
现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：

#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        

   printf( "Memory size occupied by data : %d\n", sizeof(data));

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Memory size occupied by data : 20
访问共用体成员
为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        

   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");

   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming
在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：

#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        

   data.i = 10;
   printf( "data.i : %d\n", data.i);
   
   data.f = 220.5;
   printf( "data.f : %f\n", data.f);
   
   strcpy( data.str, "C Programming");
   printf( "data.str : %s\n", data.str);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

data.i : 10
data.f : 220.500000
data.str : C Programming
在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。
* C typedef
由 authenty 创建，Loen 最后一次修改 2015-09-07
C typedef
C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：

typedef unsigned char BYTE;
在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：

BYTE  b1, b2;
按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：

typedef unsigned char byte;
您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型，然后使用这个新的数据类型来直接定义结构变量，如下：

#include <stdio.h>
#include <string.h>
 
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
 
   strcpy( book.title, "C Programming");
   strcpy( book.author, "Nuha Ali"); 
   strcpy( book.subject, "C Programming Tutorial");
   book.book_id = 6495407;
 
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Book  title : C Programming
Book  author : Nuha Ali
Book  subject : C Programming Tutorial
Book  book_id : 6495407
typedef vs #define
#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：

typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。
下面是 #define 的最简单的用法：

#include <stdio.h>
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   printf( "Value of TRUE : %d\n", TRUE);
   printf( "Value of FALSE : %d\n", FALSE);

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Value of TRUE : 1
Value of FALSE : 0
* C 预处理器
由 authenty 创建，Loen 最后一次修改 2015-09-24
C 预处理器
C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。

所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：

指令	描述
#define	定义宏
#include	包含一个源代码文件
#undef	取消已定义的宏
#ifdef	如果宏已经定义，则返回真
#ifndef	如果宏没有定义，则返回真
#if	如果给定条件为真，则编译下面代码
#else	#if 的替代方案
#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
#endif	结束一个 #if……#else 条件编译块
#error	当遇到标准错误时，输出错误消息
#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中

预处理器实例
分析下面的实例来理解不同的指令。

#define MAX_ARRAY_LENGTH 20
这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。

#include <stdio.h>
#include "myheader.h"
这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。

#undef  FILE_SIZE
#define FILE_SIZE 42
这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。

#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。

#ifdef DEBUG
   /* Your debugging statements here */
#endif
这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。

预定义宏
ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。

宏	描述
__DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
__TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
__FILE__	这会包含当前文件名，一个字符串常量。
__LINE__	这会包含当前行号，一个十进制常量。
__STDC__	当编译器以 ANSI 标准编译时，则定义为 1。
让我们来尝试下面的实例：

#include <stdio.h>

int main()
{
   printf("File :%s\n", __FILE__ );
   printf("Date :%s\n", __DATE__ );
   printf("Time :%s\n", __TIME__ );
   printf("Line :%d\n", __LINE__ );
   printf("ANSI :%d\n", __STDC__ );

}
当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果：

File :test.c
Date :Jun 2 2012
Time :03:36:24
Line :8
ANSI :1
预处理器运算符
C 预处理器提供了下列的运算符来帮助您创建宏：

宏延续运算符（\）
一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：

#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

字符串常量化运算符（#）
在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

#include <stdio.h>

#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")

int main(void)
{
   message_for(Carole, Debra);
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Carole and Debra: We love you!
标记粘贴运算符（##）
宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：

#include <stdio.h>

#define tokenpaster(n) printf ("token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;
   
   tokenpaster(34);
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

token34 = 40
这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

printf ("token34 = %d", token34);
这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。

defined() 运算符
预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：

#include <stdio.h>

#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

int main(void)
{
   printf("Here is the message: %s\n", MESSAGE);  
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Here is the message: You wish!
参数化的宏
CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：

int square(int x) {
   return x * x;
}
我们可以使用宏重写上面的代码，如下：

#define square(x) ((x) * (x))
在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

#include <stdio.h>

#define MAX(x,y) ((x) > (y) ? (x) : (y))

int main(void)
{
   printf("Max between 20 and 10 is %d\n", MAX(10, 20));  
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Max between 20 and 10 is 20
您的支持将鼓励我们做得更好
赞赏支持
* C 头文件
由 authenty 创建，Loen 最后一次修改 2015-09-05
C 头文件
头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。

在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。

引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。

A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。

引用头文件的语法
使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种：

#include <file>
这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。

#include "file"
这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。

引用头文件的操作
#include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：

char *test (void);
和一个使用了头文件的主程序 program.c，如下：

int x;
#include "header.h"

int main (void)
{
   puts (test ());
}
编译器会看到如下的令牌流：

int x;
char *test (void);

int main (void)
{
   puts (test ());
}
只引用一次头文件
如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：

#ifndef HEADER_FILE
#define HEADER_FILE

the entire header file file

#endif
这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。

有条件引用
有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：

#if SYSTEM_1
   # include "system_1.h"
#elif SYSTEM_2
   # include "system_2.h"
#elif SYSTEM_3
   ...
#endif
但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：

 #define SYSTEM_H "system_1.h"
 ...
 #include SYSTEM_H
SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。

您的支持将鼓励我们做得更好
赞赏支持
* C 错误处理
由 authenty 创建，Loen 最后一次修改 2015-09-10
C 错误处理
C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 <error.h> 头文件中找到各种各样的错误代码。

所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。

errno、perror() 和 strerror()
C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。

perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。

#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno ;

int main ()
{
   FILE * pf;
   int errnum;
   pf = fopen ("unexist.txt", "rb");
   if (pf == NULL)
   {
      errnum = errno;
      fprintf(stderr, "Value of errno: %d\n", errno);
      perror("Error printed by perror");
      fprintf(stderr, "Error opening file: %s\n", strerror( errnum ));
   }
   else
   {
      fclose (pf);
   }
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Value of errno: 2
Error printed by perror: No such file or directory
Error opening file: No such file or directory
被零除的错误
在进行除法运算时，不检查除数是否为零，这是程序员编程时常见的问题，会导致一个运行时错误。

为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：

#include <stdio.h>
#include <stdlib.h>

main()
{
   int dividend = 20;
   int divisor = 0;
   int quotient;
 
   if( divisor == 0){
      fprintf(stderr, "Division by zero! Exiting...\n");
      exit(-1);
   }
   quotient = dividend / divisor;
   fprintf(stderr, "Value of quotient : %d\n", quotient );

   exit(0);
}
当上面的代码被编译和执行时，它会产生下列结果：

Division by zero! Exiting...
程序退出状态
通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。

如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：

#include <stdio.h>
#include <stdlib.h>

main()
{
   int dividend = 20;
   int divisor = 5;
   int quotient;
 
   if( divisor == 0){
      fprintf(stderr, "Division by zero! Exiting...\n");
      exit(EXIT_FAILURE);
   }
   quotient = dividend / divisor;
   fprintf(stderr, "Value of quotient : %d\n", quotient );

   exit(EXIT_SUCCESS);
}
当上面的代码被编译和执行时，它会产生下列结果：

Value of quotient : 4
您的支持将鼓励我们做得更好
赞赏支持
* C 可变参数
由 authenty 创建，Loen 最后一次修改 2015-09-15
C 可变参数
有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。

int func(int, ... ) 
{
   .
   .
   .
}

int main()
{
   func(1, 2, 3);
   func(1, 2, 3, 4);
}
请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数总是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：

定义一个函数，最后一个参数为省略号，省略号前面的那个参数总是 int，表示了参数的个数。
在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
使用宏 va_end 来清理赋予 va_list 变量的内存。
现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：

#include <stdio.h>
#include <stdarg.h>

double average(int num,...)
{

    va_list valist;
    double sum = 0.0;
    int i;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++)     {
        sum += va_arg(valist, int);
    }     /* 清理为 valist 保留的内存 */
    va_end(valist);
    return sum/num;
    }
int main() {
printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));
} 
当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。

Average of 2, 3, 4, 5 = 3.500000
Average of 5, 10, 15 = 10.000000


您的支持将鼓励我们做得更好
赞赏支持
* C 内存管理
由 authenty 创建，Loen 最后一次修改 2015-09-12
C 内存管理
本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <stdlib.h> 头文件中找到。

序号	函数和描述
1	void *calloc(int num, int size);
该函数分配一个带有 function allocates an array of num 个元素的数组，每个元素的大小为 size 字节。
2	void free(void *address); 
该函数释放 address 所指向的h内存块。
3	void *malloc(int num); 
该函数分配一个 num 字节的数组，并把它们进行初始化。
4	void *realloc(void *address, int newsize); 
该函数重新分配内存，把内存扩展到 newsize。

动态分配内存
编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：

char name[100];
但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所学内存大小的字符，后续再根据需求来分配内存，如下所示：

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );
}
当上面的代码被编译和执行时，它会产生下列结果：

Name = Zara Ali
Description: Zara ali a DPS student in class 10th
上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：

calloc(200, sizeof(char));
当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。

重新调整内存的大小和释放内存
当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。

或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = malloc( 30 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = realloc( description, 100 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcat( description, "She is in class 10th");
   }
   
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );

   /* 使用 free() 函数释放内存 */
   free(description);
}
当上面的代码被编译和执行时，它会产生下列结果：

Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th
您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。

您的支持将鼓励我们做得更好
* C 命令行参数
由 authenty 创建，Loen 最后一次修改 2015-09-12
C 命令行参数
执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。

命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：

#include <stdio.h>

int main( int argc, char *argv[] )  
{
   if( argc == 2 )
   {
      printf("The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 )
   {
      printf("Too many arguments supplied.\n");
   }
   else
   {
      printf("One argument expected.\n");
   }
}
使用一个参数，编译并执行上面的代码，它会产生下列结果：

$./a.out testing
The argument supplied is testing
使用两个参数，编译并执行上面的代码，它会产生下列结果：

$./a.out testing1 testing2
Too many arguments supplied.
不传任何参数，编译并执行上面的代码，它会产生下列结果：

$./a.out
One argument expected
应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。

多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 "" 或单引号 '' 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号""""。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：

#include <stdio.h>

int main( int argc, char *argv[] )  
{
   printf("Program name %s\n", argv[0]);
 
   if( argc == 2 )
   {
      printf("The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 )
   {
      printf("Too many arguments supplied.\n");
   }
   else
   {
      printf("One argument expected.\n");
   }
}
使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果：

$./a.out "testing1 testing2"

Progranm name ./a.out
The argument supplied is testing1 testing2
* C 标准库 – <ctype.h>
由 authenty 创建，Loen 最后一次修改 2015-09-12
C 标准库 - <ctype.h>
简介
C 标准库的 ctype.h 头文件提供了一些函数，可用于测试和映射字符。

这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。

如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。

库函数
下面列出了头文件 ctype.h 中定义的函数：

序号	函数 & 描述
1	int isalnum(int c)
该函数检查所传的字符是否是字母和数字。
2	int isalpha(int c)
该函数检查所传的字符是否是字母。
3	int iscntrl(int c)
该函数检查所传的字符是否是控制字符。
4	int isdigit(int c)
该函数检查所传的字符是否是十进制数字。
5	int isgraph(int c)
该函数检查所传的字符是否有图形表示法。
6	int islower(int c)
该函数检查所传的字符是否是小写字母。
7	int isprint(int c)
该函数检查所传的字符是否是可打印的。
8	int ispunct(int c)
该函数检查所传的字符是否是标点符号字符。
9	int isspace(int c)
该函数检查所传的字符是否是空白字符。
10	int isupper(int c)
该函数检查所传的字符是否是大写字母。
11	int isxdigit(int c)
该函数检查所传的字符是否是十六进制数字。
标准库还包含了两个转换函数，它们接受并返回一个 "int"

序号	函数 & 描述
1	int tolower(int c)
该函数把大写字母转换为小写字母。
2	int toupper(int c)
该函数把小写字母转换为大写字母。
字符类
序号	字符类 & 描述
1	数字
完整的数字集合 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
2	十六进制数字
集合 { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }
3	小写字母
集合 { a b c d e f g h i j k l m n o p q r s t u v w x y z }
4	大写字母
集合 {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }
5	字母
小写字母和大写字母的集合
6	字母数字字符
数字、小写字母和大写字母的集合
7	标点符号字符
集合 ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
8	图形字符
字母数字字符和标点符号字符的集合
9	空格字符
制表符、换行符、垂直制表符、换页符、回车符、空格符的集合。
10	可打印字符
字母数字字符、标点符号字符和空格字符的集合。
11	控制字符
在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）。
12	空白字符
包括空格符和制表符。
13	字母字符
小写字母和大写字母的集合。
您的支持将鼓励我们做得更好
* C 标准库 – <errno.h>
由 authenty 创建， 最后一次修改 2015-09-24
C 标准库 - <errno.h>
简介
C 标准库的 errno.h 头文件定义了整数变量 errno，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。

在程序启动时，errno 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。

errno.h 头文件也顶了以一系列表示不同错误代码的宏，这些宏应扩展为类型为 int 的整数常量表达式。

库宏
下面列出了头文件 errno.h 中定义的宏：

序号	宏 & 描述
1	extern int errno
这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。
2	EDOM Domain Error
这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。
3	ERANGE Range Error
这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。
* C 标准库 – <float.h>
由 authenty 创建， 最后一次修改 2015-09-24
C 标准库 - <float.h>
简介
C 标准库的 float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：

组件	组件描述
S	符号 ( +/- )
b	指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...
e	指数，一个介于最小值 emin 和最大值 emax 之间的整数。
p	精度，基数 b 的有效位数
基于以上 4 个组成部分，一个浮点数的值如下：

floating-point = ( S ) p x b<sup>e</sup>

或

floating-point = (+/-) precision x base<sup>exponent</sup>
库宏
下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。

宏	描述
FLT_ROUNDS	定义浮点加法的舍入模式，它可以是下列任何一个值：
-1 - 无法确定

0 - 趋向于零

1 - 去最近的值

2 - 趋向于正无穷

3 - 趋向于负无穷

FLT_RADIX 2	这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。
FLT_MANT_DIG

DBL_MANT_DIG

LDBL_MANT_DIG

这些宏定义了 FLT_RADIX 基数中的位数。
FLT_DIG 6

DBL_DIG 10

LDBL_DIG 10

这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。
FLT_MIN_EXP

DBL_MIN_EXP

LDBL_MIN_EXP

这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。
FLT_MIN_10_EXP -37

DBL_MIN_10_EXP -37

LDBL_MIN_10_EXP -37

这些宏定义了基数为 10 时的指数的最小负整数值。
FLT_MAX_EXP

DBL_MAX_EXP

LDBL_MAX_EXP

这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。
FLT_MAX_10_EXP +37

DBL_MAX_10_EXP +37

LDBL_MAX_10_EXP +37

这些宏定义了基数为 10 时的指数的最大整数值。
FLT_MAX 1E+37

DBL_MAX 1E+37

LDBL_MAX 1E+37

这些宏定义最大的有限浮点值。
FLT_EPSILON 1E-5

DBL_EPSILON 1E-9

LDBL_EPSILON 1E-9

这些宏定义了可表示的最小有效数字。
FLT_MIN 1E-37

DBL_MIN 1E-37

LDBL_MIN 1E-37

这些宏定义了最小的浮点值。
实例
下面的实例演示了 float.h 文件中定义的一些常量的使用。

#include <stdio.h>
#include <float.h>

int main()
{
   printf("The maximum value of float = %.10e\n", FLT_MAX);
   printf("The minimum value of float = %.10e\n", FLT_MIN);

   printf("The number of digits in the number = %.10e\n", FLT_MANT_DIG);
}
让我们编译和运行上面的程序，这将产生下列结果：

The maximum value of float = 3.4028234664e+38
The minimum value of float = 1.1754943508e-38
The number of digits in the number = 7.2996655210e-312
* C 标准库 – <time.h>
由 authenty 创建，youj 最后一次修改 2015-09-26
C 标准库 - <time.h>
简介
time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。

库变量
下面是头文件 time.h 中定义的变量类型：

序号	变量 & 描述
1	size_t 
是无符号整数类型，它是 sizeof 关键字的结果。
2	clock_t 
这是一个适合存储处理器时间的类型。
3	time_t
这是一个适合存储日历时间类型。
4	struct tm 
这是一个用来保存时间和日期的结构。
tm 结构的定义如下：

struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59       */
   int tm_min;         /* 分，范围从 0 到 59      */
   int tm_hour;        /* 小时，范围从 0 到 23     */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */
   int tm_mon;         /* 月，范围从 0 到 11      */
   int tm_year;        /* 自 1900 年起的年数      */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6 */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365   */
   int tm_isdst;       /* 夏令时               */
};
库宏
下面是头文件 time.h 中定义的宏：

序号	宏 & 描述
1	NULL
这个宏是一个空指针常量的值。
2	CLOCKS_PER_SEC 
这个宏表示每秒的处理器时钟个数。
库函数
下面是头文件 time.h 中定义的函数：

序号	函数 & 描述
1	char *asctime(const struct tm *timeptr)
返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。
2	clock_t clock(void)
返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。
3	char *ctime(const time_t *timer)
返回一个表示当地时间的字符串，当地时间是基于参数 timer。
4	double difftime(time_t time1, time_t time2)
返回 time1 和 time2 之间相差的秒数 (time1-time2)。
5	struct tm *gmtime(const time_t *timer)
timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。
6	struct tm *localtime(const time_t *timer)
timer 的值被分解为 tm 结构，并用本地时区表示。
7	time_t mktime(struct tm *timeptr)
把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。
8	size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。
9	time_t time(time_t *timer)
计算当前日历时间，并把它编码成 time_t 格式。


