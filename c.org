* 预处理语言 [描述事物]
** 预定义宏
   __DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
   __TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
   __FILE__	这会包含当前文件名，一个字符串常量。
   __LINE__	这会包含当前行号，一个十进制常量。
   __STDC__	当编译器以 ANSI 标准编译时，则定义为 1。
** 预运算符
*** 宏延续运算符（\）
*** 字符串常量化运算符（#）
    在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符
  （#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

  #+begin_src c
    #include <stdio.h>

    #define  message_for(a, b)                      \
      printf(#a " and " #b ": We love you!\n")

    int main(void)
    {
      message_for(Carole, Debra);
      return 0;
    }

  #+end_src
*** 标记粘贴运算符（##）
  #+begin_src c
    #include <stdio.h>
    #define tokenpaster(n) printf ("token" #n " = %d", token##n)

    int main(void)
    {
      int token34 = 40;

      tokenpaster(34);
      return 0;
    }
  #+end_src
  当上面的代码被编译和执行时，它会产生下列结果：
  token34 = 40
   
  这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

  printf ("token34 = %d", token34);
 
  这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运
  算符（#）和标记粘贴运算符（##）。
*** defined() 运算符
  预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用
  #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未
  定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：

  #+begin_src c
    #include <stdio.h>

    #if !defined (MESSAGE)
    #define MESSAGE "You wish!"
    #endif

    int main(void)
    {
      printf("Here is the message: %s\n", MESSAGE);  
      return 0;
    }
  #+end_src
   
  当上面的代码被编译和执行时，它会产生下列结果：
  Here is the message: You wish!
*** 参数化的宏
  CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个
  数的平方：

  #+begin_src c
  int square(int x) {
  return x * x;
  }
  #+end_src
   
  我们可以使用宏重写上面的代码，如下：

  #define square(x) ((x) * (x))
 
  在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必
  须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

  #+begin_src c
    #include <stdio.h>

    #define MAX(x,y) ((x) > (y) ? (x) : (y))

    int main(void)
    {
      printf("Max between 20 and 10 is %d\n", MAX(10, 20));  
      return 0;
    }
  #+end_src
  当上面的代码被编译和执行时，它会产生下列结果：
  Max between 20 and 10 is 20
** 宏定义
   #define	定义宏
   #include	包含一个源代码文件
   #undef	取消已定义的宏
   #ifdef	如果宏已经定义，则返回真
   #ifndef	如果宏没有定义，则返回真
   #if	如果给定条件为真，则编译下面代码
   #else	#if 的替代方案
   #elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
   #endif	结束一个 #if……#else 条件编译块
   #error	当遇到标准错误时，输出错误消息
   #pragma	使用标准化方法，向编译器发布特殊的命令到编译器中
* C 语言
** 枚举
  #+begin_src c
    1、先定义枚举类型，再定义枚举变量
    enum DAY
      {
       MON=1, TUE, WED, THU, FRI, SAT, SUN
      };
    enum DAY day;

    2、定义枚举类型的同时定义枚举变量
    enum DAY
      {
       MON=1, TUE, WED, THU, FRI, SAT, SUN
      } day;

    3、省略枚举名称，直接定义枚举变量
    enum
      {
       MON=1, TUE, WED, THU, FRI, SAT, SUN
      } day;

    enum identifier(optional) { enumerator-list }		

    enum DAY
      {
       MON=1, TUE, WED, THU, FRI, SAT, SUN
      };
      #+end_src
** 结构体 [声明分号，赋值逗号]
  #+begin_src c
       struct [structure tag]
       {
        member definition;
        member definition;
        ...
        member definition;
        } [one or more structure variables];  
     structure tag 是可选的，每个 member definition 是标准的变量定义

     struct point {double x,y,z;} p = {1.2, 1.3}; // p.x=1.2, p.y=1.3, p.z=0.0
    div_t answer = {.quot = 2, .rem = -1 };      // order of elements in div_t may vary

  #+end_src
** 共用体
#+begin_src c
  union [union tag]
  {
    member definition;
    member definition;
    ...
      member definition;
  } [one or more union variables];  
  union tag 是可选的
#+end_src
 
** 别名
   typedef char* String_t;
   #define String_d char *
** 指针
学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

实例
#include <stdio.h>
 
int main ()
{
   int  var1;
   char var2[10];
 
   printf("var1 变量的地址： %p\n", &var1  );
   printf("var2 变量的地址： %p\n", &var2  );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

var1 变量的地址：0x7fff5cc109d4
var2 变量的地址：0x7fff5cc109de
通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。

什么是指针？
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type *var-name;
在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;     /* 一个字符型的指针 */
所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

实例
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("Address of var variable: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20
C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。

NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

实例
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

ptr 的地址是 0x0
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
C 指针详解
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：

概念	描述
指针的算术运算	可以对指针进行四种算术运算：++、--、+、-
指针数组	可以定义用来存储指针的数组。
指向指针的指针	C 允许指向指针的指针。
传递指针给函数	通过引用或地址传递参数，使传递的参数在调用函数中被改变。
从函数返回指针	C 允许函数返回指针到局部变量、静态变量和动态内存分配
** 函数指针
函数指针是指向函数的指针变量。

通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

函数指针可以像一般函数一样，用于调用函数、传递参数。

函数指针变量的声明：

typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
实例
以下实例声明了函数指针变量 p，指向函数 max：

实例
#include <stdio.h>
 
int max(int x, int y)
{
    return x > y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = & max; // &可以省略
    int a, b, c, d;
 
    printf("请输入三个数字:");
    scanf("%d %d %d", & a, & b, & c);
 
    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c); 
 
    printf("最大的数字是: %d\n", d);
 
    return 0;
}
编译执行，输出结果如下：

请输入三个数字:1 2 3
最大的数字是: 3
回调函数
函数指针作为某个函数的参数
函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

以下是自知乎作者常溪玲的解说：

你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

实例
实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。

实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。

populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。

实例
#include <stdlib.h>  
#include <stdio.h>
 
// 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}
 
// 获取随机值
int getNextRandomValue(void)
{
    return rand();
}
 
int main(void)
{
    int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);
    for(int i = 0; i < 10; i++) {
        printf("%d ", myarray[i]);
    }
    printf("\n");
    return 0;
}
编译执行，输出结果如下：

16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 
** 可变参数
 #+begin_src
 int func(int, ... ) 
 {
    .
    .
    .
 }

 int main()
 {
    func(1, 2, 3);
    func(1, 2, 3, 4);
 }

 #+end_src
 请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数总是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：

 定义一个函数，最后一个参数为省略号，省略号前面的那个参数总是 int，表示了参数的个数。
 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
 使用宏 va_end 来清理赋予 va_list 变量的内存。
 现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：

 #include <stdio.h>
 #include <stdarg.h>

 double average(int num,...)
 {

     va_list valist;
     double sum = 0.0;
     int i;

     /* 为 num 个参数初始化 valist */
     va_start(valist, num);

     /* 访问所有赋给 valist 的参数 */
     for (i = 0; i < num; i++)     {
         sum += va_arg(valist, int);
     }     /* 清理为 valist 保留的内存 */
     va_end(valist);
     return sum/num;
     }
 int main() {
 printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
 printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));
 } 
 当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。

 Average of 2, 3, 4, 5 = 3.500000
 Average of 5, 10, 15 = 10.000000


 您的支持将鼓励我们做得更好
 赞赏支持
** C 位域
如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下：

struct
{
  unsigned int widthValidated;
  unsigned int heightValidated;
} status;
这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：

struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念：

实例
#include <stdio.h>
#include <string.h>
 
/* 定义简单的结构 */
struct
{
  unsigned int widthValidated;
  unsigned int heightValidated;
} status1;
 
/* 定义位域结构 */
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status2;
 
int main( )
{
   printf( "Memory size occupied by status1 : %d\n", sizeof(status1));
   printf( "Memory size occupied by status2 : %d\n", sizeof(status2));
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

Memory size occupied by status1 : 8
Memory size occupied by status2 : 4
位域声明
在结构内声明位域的形式如下：

struct
{
  type [member_name] : width ;
};
下面是有关位域中变量元素的描述：

元素	描述
type	整数类型，决定了如何解释位域的值。类型可以是整型、有符号整型、无符号整型。
member_name	位域的名称。
width	位域中位的数量。宽度必须小于或等于指定类型的位宽度。
带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：

struct
{
  unsigned int age : 3;
} Age;
上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。让我们来看下面的实例：

实例
#include <stdio.h>
#include <string.h>
 
struct
{
  unsigned int age : 3;
} Age;
 
int main( )
{
   Age.age = 4;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 7;
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( "Age.age : %d\n", Age.age );
 
   return 0;
}
当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：

Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0
 C 共用体 C typedef 
2 篇笔记  写笔记
   petter

  don***anriluo@sohu.com

文中例子解析：

struct 
{
    unsigned int age : 3;
} Age;

/*age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成*/
Age.age = 4;
printf("Sizeof( Age ) : %d\n", sizeof(Age));
printf("Age.age : %d\n", Age.age);

// 二进制表示为 111 有三位，达到最大值
Age.age = 7;
printf("Age.age : %d\n", Age.age);

// 二进制表示为 1000 有四位，超出
Age.age = 8;
printf("Age.age : %d\n", Age.age);
如果超出范围，则直接丢掉了，存不进去。

petter
   petter

  don***anriluo@sohu.com

8 个月前 (07-26)
   karma

  119***7665@qq.com

结构体内存分配原则

原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。

原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。

测试实例：

#include <stdio.h>

typedef struct t1{
    char x;
    int y;
    double z;
}T1;

typedef struct t2{
    char x;
    double z;
    int y;
}T2;

int main(int argc, char* argv[])
{
    printf("sizeof(T1) = %lu\n", sizeof(T1));
    printf("sizeof(T2) = %lu\n", sizeof(T2));

    return 0;
}
输出：

sizeof(T1) = 16
sizeof(T2) = 24
解析

sizeof(T1.x) = sizeof(T2.x) = 1; 
sizeof(T1.y) = sizeof(T2.y) = 4; 
sizeof(T1.z) = sizeof(T2.z) = 8;
T1: 若从第 0 个字节开始分配内存，则 T1.x 存入第 0 字节，T1.y 占 4 个字节，由于第一的 4 字节已有数据，所以 T1.y 存入第 4-7 个字节，T1.z 占 8 个字节，由于第一个 8 字节已有数据，所以 T1.z 存入 8-15 个字节。共占有 16 个字节。

T2: 若从第 0 个字节开始分配内存，则 T1.x 存入第 0 字节，T1.z 占 8 个字节，由于第一的 8 字节已有数据，所以 T1.z 存入第 8-15 个字节，T1.y 占 4 个字节，由于前四个 4 字节已有数据，所以 T1.z 存入 16-19 个字节。共占有 20 个字节。此时所占字节不是最宽元素（double 长度为 8）的整数倍，因此将其补齐到 8 的整数倍，最终结果为 24。

karma
   karma

  119***7665@qq.com

7 个月前 (08-09)

** 内存管理
   C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <stdlib.h> 头文件中找到。

 - void *calloc(int num, int size);
   该函数分配有 num 个元素数组，每个元素的大小为 size 字节
 - void free(void *address);
  该函数释放 address 所指向的内存块
 - void *malloc(int num);
  该函数分配一个 num 字节的数组，并把它们进行初始化。
 - void *realloc(void *address, int newsize);
  该函数重新分配内存，把内存扩展到 newsize。
*** 动态分配内存( 延时绑定 )
 如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，
 我们需要定义一个指针，该指针指向未定义所学内存大小的字符，后续再根据需求来分配
 内存，如下所示：
 #+begin_src c

   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>

   int main()
   {
     char name[100];
     char *description;

     strcpy(name, "Zara Ali");

     /* 动态分配内存 */
     description = malloc( 200 * sizeof(char) );
     if( description == NULL )
       {
         fprintf(stderr, "Error - unable to allocate required memory\n");
       }
     else
       {
         strcpy( description, "Zara ali a DPS student in class 10th");
       }
     printf("Name = %s\n", name );
     printf("Description: %s\n", description );
   }
 #+end_src
 当上面的代码被编译和执行时，它会产生下列结果：

 Name = Zara Ali
 Description: Zara ali a DPS student in class 10th
 上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：

 calloc(200, sizeof(char));

 当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数
 组，一旦定义则无法改变大小。

 重新调整内存的大小和释放内存

 当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，
 都应该调用函数 free() 来释放内存。

 或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用
 realloc() 和 free() 函数，再次查看上面的实例：

 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

 int main()
 {
    char name[100];
    char *description;

    strcpy(name, "Zara Ali");

    /* 动态分配内存 */
    description = malloc( 30 * sizeof(char) );
    if( description == NULL )
    {
       fprintf(stderr, "Error - unable to allocate required memory\n");
    }
    else
    {
       strcpy( description, "Zara ali a DPS student.");
    }
    /* 假设您想要存储更大的描述信息 */
    description = realloc( description, 100 * sizeof(char) );
    if( description == NULL )
    {
       fprintf(stderr, "Error - unable to allocate required memory\n");
    }
    else
    {
       strcat( description, "She is in class 10th");
    }
   
    printf("Name = %s\n", name );
    printf("Description: %s\n", description );

    /* 使用 free() 函数释放内存 */
    free(description);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Name = Zara Ali
 Description: Zara ali a DPS student.She is in class 10th

 您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储
 description 时可用的内存不足。
** 错误处理
 C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许
 您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会
 设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可
 以在 <error.h> 头文件中找到各种各样的错误代码。

 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员
 应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没
 有错误。

 errno、perror() 和 strerror()
 C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。

 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
 
 让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错
 误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文
 件流来输出所有的错误。

 #include <stdio.h>
 #include <errno.h>
 #include <string.h>

 extern int errno ;

 int main ()
 {
    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");
    if (pf == NULL)
    {
       errnum = errno;
       fprintf(stderr, "Value of errno: %d\n", errno);
       perror("Error printed by perror");
       fprintf(stderr, "Error opening file: %s\n", strerror( errnum ));
    }
    else
    {
       fclose (pf);
    }
    return 0;
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Value of errno: 2
 Error printed by perror: No such file or directory
 Error opening file: No such file or directory
 被零除的错误
 
 在进行除法运算时，不检查除数是否为零，这是程序员编程时常见的问题，会导致一个运
 行时错误。

 为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：

 #include <stdio.h>
 #include <stdlib.h>

 main()
 {
    int dividend = 20;
    int divisor = 0;
    int quotient;
 
    if( divisor == 0){
       fprintf(stderr, "Division by zero! Exiting...\n");
       exit(-1);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "Value of quotient : %d\n", quotient );

    exit(0);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Division by zero! Exiting...
 程序退出状态
 
 通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，
 EXIT_SUCCESS 是宏，它被定义为 0。

 如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为
 -1。所以，上面的程序可以写成：

 #include <stdio.h>
 #include <stdlib.h>

 main()
 {
    int dividend = 20;
    int divisor = 5;
    int quotient;
 
    if( divisor == 0){
       fprintf(stderr, "Division by zero! Exiting...\n");
       exit(EXIT_FAILURE);
    }
    quotient = dividend / divisor;
    fprintf(stderr, "Value of quotient : %d\n", quotient );

    exit(EXIT_SUCCESS);
 }
 当上面的代码被编译和执行时，它会产生下列结果：

 Value of quotient : 4
* C 标准库[名词扩展] 
** ctype.h  
*** 字符判断
    字母或数字 isalnum(int c) 
    字母 int isalpha(int c)
    控制字符  int iscntrl(int c)   
    十进制数字 isdigit(int c)
    有图形表示法 isgraph(int c)
    小写字母 islower(int c)
    可打印的 isprint(int c)
    标点符号字符 ispunct(int c)
    空白字符 isspace(int c)
    大写字母 isupper(int c)
    十六进制数字 isxdigit(int c)
*** 转换
    大写字母转换为小写字母 tolower(int c)
    小写字母转换为大写字母 toupper(int c)
** errno.h
	extern int errno
 这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。
 
EDOM Domain Error
 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。
 
ERANGE Range Error

 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置
 为 ERANGE。
** float.h
*** 宏 
    FLT_ROUNDS	定义浮点加法的舍入模式，它可以是下列任何一个值：
    -1 - 无法确定
    0 - 趋向于零
    1 - 去最近的值
    2 - 趋向于正无穷
    3 - 趋向于负无穷

  FLT_RADIX 2	这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。
  FLT_MANT_DIG
  DBL_MANT_DIG
  LDBL_MANT_DIG

  这些宏定义了 FLT_RADIX 基数中的位数。
  FLT_DIG 6
  DBL_DIG 10
  LDBL_DIG 10

  这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。
  FLT_MIN_EXP
  DBL_MIN_EXP
  LDBL_MIN_EXP

  这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。
  FLT_MIN_10_EXP -37
  DBL_MIN_10_EXP -37
  LDBL_MIN_10_EXP -37

  这些宏定义了基数为 10 时的指数的最小负整数值。
  FLT_MAX_EXP
  DBL_MAX_EXP
  LDBL_MAX_EXP

  这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。
  FLT_MAX_10_EXP +37
  DBL_MAX_10_EXP +37
  LDBL_MAX_10_EXP +37

  这些宏定义了基数为 10 时的指数的最大整数值。
  FLT_MAX 1E+37
  DBL_MAX 1E+37
  LDBL_MAX 1E+37

  这些宏定义最大的有限浮点值。
  FLT_EPSILON 1E-5
  DBL_EPSILON 1E-9
  LDBL_EPSILON 1E-9

  这些宏定义了可表示的最小有效数字。
  FLT_MIN 1E-37
  DBL_MIN 1E-37
  LDBL_MIN 1E-37

  这些宏定义了最小的浮点值。
  实例
  下面的实例演示了 float.h 文件中定义的一些常量的使用。

  #include <stdio.h>
  #include <float.h>

  int main()
  {
     printf("The maximum value of float = %.10e\n", FLT_MAX);
     printf("The minimum value of float = %.10e\n", FLT_MIN);

     printf("The number of digits in the number = %.10e\n", FLT_MANT_DIG);
  }
  让我们编译和运行上面的程序，这将产生下列结果：

  The maximum value of float = 3.4028234664e+38
  The minimum value of float = 1.1754943508e-38
  The number of digits in the number = 7.2996655210e-312
** time.h
- 库变量
  - size_t 是无符号整数类型，它是 sizeof 关键字的结果。
  - clock_t 这是一个适合存储处理器时间的类型。
  - time_t 这是一个适合存储日历时间类型。
  - struct tm 这是一个用来保存时间和日期的结构。
  - 
  - tm 结构的定义如下：
   struct tm {
     int tm_sec;         /* 秒，范围从 0 到 59       */
     int tm_min;         /* 分，范围从 0 到 59      */
     int tm_hour;        /* 小时，范围从 0 到 23     */
     int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */
     int tm_mon;         /* 月，范围从 0 到 11      */
     int tm_year;        /* 自 1900 年起的年数      */
     int tm_wday;        /* 一周中的第几天，范围从 0 到 6 */
     int tm_yday;        /* 一年中的第几天，范围从 0 到 365   */
     int tm_isdst;       /* 夏令时               */
   };
  - 

 结构 timeptr 的日期和时间 char *asctime(const struct tm *timeptr)
 处理器时钟所使用的时间 clock_t clock(void)
当地时间的字符串 char *ctime(const time_t *timer)
 time1 和 time2 之间相差的秒数 double difftime(time_t time1, time_t time2)
  timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。struct tm *gmtime(const time_t *timer)
  timer 的值被分解为 tm 结构，并用本地时区表示。struct tm *localtime(const time_t *timer)
  
  把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。time_t mktime(struct tm *timeptr)
  格式化结构 timeptr 表示的时间  size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
  计算当前日历时间，并把它编码成 time_t 格式 time_t time(time_t *timer)
** stdio.h
*** int printf( const char *format, ... );​
*** int printf( const char *restrict format, ... );​
***  int scanf(const char *format, ...)
    ( 很复杂 )
    
    格式化输入,每段格式化 ( %X ) 以 ( RET )标示结束
    返回的是满足格式化的个数
    
    在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用
    空格，TAB 或回车作间隔。C 编译在碰到空格，TAB，回车或非法数据(如对“%d”输入
    “12A”时，A 即为非法数据)时即认为该数据结束。
    
    在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。  
    
   | 格式 | 字符意义                         |
   | d    | 输入十进制整数                   |
   | o    | 输入八进制整数                   |
   | x    | 输入十六进制整数                 |
   | u    | 输入无符号十进制整数             |
   | f 或 e | 输入实型数(用小数形式或指数形式) |
   | c    | 输入单个字符                     |
   | s    | 输入字符串                       |
    
    scanf("%c%c%c",&a,&b,&c);
    输入 d、e、f 则把'd'赋予 a，' ' 赋予 b，'e'赋予 c。只有当输入为 def 时，才能把'd'赋于 a，'e'赋予 b，'f'赋予 c。
*** int fscanf(FILE *stream, const char *format, ...);
*** int sscanf(const char *str, const char *format, ...);
** stdarg.h
   int vscanf(const char *format, va_list ap);
   int vsscanf(const char *str, const char *format, va_list ap);
   int vfscanf(FILE *stream, const char *format, va_list ap);
** unistd.h
   ssize_t write(int fd, const void *buf, size_t count);
   ssize_t read(int fd, void *buf, size_t count);
** string.h
	 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。
   strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。
   strlen(s1); 返回字符串 s1 的长度。
   strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。
   strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
   strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
* 非 C 标准库
** conio.h
   conio.h 是一个 C 头文件，用于 MS-DOS C 编译器里。此头文件宣告了数个有用的函数，提供程
   序设计者主控台的输出入操作接口。

   int kbhit(void)
   int getch(void)
   int getche(void)
   int ungetch(int c)
   char *cgets(char *buffer)
   int cscanf(char *format, arg0,... argn)
   int putch(int c)
   int cputs(const char *string)
   int cprintf(const char *format, arg0,... argn)
