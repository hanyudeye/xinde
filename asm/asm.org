#+TITLE: at&t 汇编简介
#+DESCRIPTION: at&t 汇编简介
#+TAGS: asm,at&t
#+CATEGORIES: 语言使用
#+DATE: <2019-06-23 15:20:58>

* 汇编语言 
** 简介 
   #+begin_verse
   讲完高级语言，讲点低级语言吧。 
   写汇编是很头疼的事情，那时用汇编写出那么多好程序很了不起。
   汇编是面向机器的，我们原来的数学运算什么都是抽象出来的,数据类型也是抽象出来的。 
   #+end_verse
 
  在机器层，我们能操作的是寄存器，内存，硬件设备。每种硬件处理方法也不一样，非常复杂
 #+HTML: <!-- more -->

 因为操作的是机器，就要配置好一个环境来好好展示机器各方面的数据。
 
** 计算理论
   #+begin_verse
   图灵理论
   基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：
   在纸上写上或擦除某个符号；
   把注意力从纸的一个位置移动到另一个位置；
   #+end_verse
   
   #+begin_verse
   就像我们完成一件事情一样，例如我们 盖一座房子，那我们要有一张建筑图纸。 
   建筑图纸就相当于软件，或图灵里面的纸带，我们相当于硬件，我们按照图纸一条一条解析，执行图纸上的内容，执行完，房子就造好了。
   #+end_verse
   
** 具体实现
   #+DOWNLOADED: https://upload-images.jianshu.io/upload_images/7111365-68ff109722f28e90?imageMogr2/auto-orient/ @ 2019-06-23 18:20:15
   [[file:image/liucheng.jpeg]]


   #+begin_verse
cpu 那块芯片上有这么 3 块单元
1.控制单元
2.存储单元
3.运算单元

然后

控制单元又可以分成：指令寄存器（内存里面读取到的指令会在这里），指令译码器（吧读取到指令翻译成具体操作），操作控制器。
存储单元就是寄存器，用来存放等待处理和处理过的数据，用来减少 cpu 对内存的访问次数。
运算单元的话就是进行算术运算和逻辑运算这些。

接下来说一下工作的流程
第一步：取指令，cpu 的控制器读取一条指令放到指令寄存器里面。
第二步：指令译码，对指令寄存器里面的指令进行译码，确定指令进行的操作，操作数地址。
第三步：执行指令，利用操作数地址找到操作数，进行运算。
第四步：修改指令计数器，确定下一条指令的地址。
   #+end_verse
   #+begin_quote
   跟人的计算过程差不多吧 
   #+end_quote

** 图纸结构
   #+begin_src nasm
       #显示器设备显示一行文字
     .data
     msg: .ascii "Hello world, hello AT&T asm!\n"
       len = . - msg

     .text
     .global _start
     _start:
       movl	$len,	%edx	# 显示的字符数
       movl	$msg,	%ecx	# 缓冲区指针
       movl	$1,	%ebx	# 文件描述符
       movl	$4,	%eax	# 系统调用号，_write
       int	$0x80		# 系统调用

       ## ssize_t write(int fd, const void *buf, size_t count);

       movl	%eax,	%ebx	# 传给_exit 的参数, 这里是 write 的返回值，打印的数量
       movl	$1,	%eax	# 系统调用号，_exit
       int	$0x80		# 系统调用
   #+end_src

   #+begin_src nasm
       # 显示器显示 CPUID：
     .section .data
     output:
     .ascii "The processor Vendor ID is 'XXXXXXXXXXXX'\n"

     .section .text
     .global _start

     _start:
       movl	$0,	%eax		# The CPUID output option(the Vendor ID string)	
       cpuid #cpuid 指令根据不同的 eax,输出不同的值 
       movl	$output,%edi
       movl	%ebx, 	28(%edi)
       movl	%edx,	32(%edi)
       movl	%ecx,	36(%edi)

       movl	$42,	%edx	# 显示的字符数
       movl	$output,%ecx	# 缓冲区指针
       movl	$1,	%ebx	# 文件描述符
       movl	$4,	%eax	# 系统调用号，_write
       int	$0x80		# 系统调用

       movl	$0,	%ebx	# 传给_exit 的参数
       movl	$1,	%eax	# 系统调用号，_exit
       int	$0x80		# 系统调用

   #+end_src
** 程序结构
   基本结构是有两个区块，一个区块是 数据区，放置你声明的变量
   一个区块是代码区，你的函数都放在那里。 
   数据区用 ~.data~ 表示
   代码区用 ~.text~ 表示

*** 数据放置区 .data .rodata(只读)
*** 数据定义 msg: .asciz "hello"
*** 数据类型
    .ascii 文本字符串
    .asciz 以空字符结尾的字符串
    .byte 字节值
    .double 双精度浮点值
    .float 单精度浮点值
    .int 32 位整数
    .long 32 位整数, 和 int 相同
    .octa 16 字节整数
    .quad 8 字节整数
    .short 16 位整数
    .single 单精度浮点数(和 float 相同)
       
    ages:
    .int 20, 10, 30, 40
    对象 对象类型 值    
   
    定义静态符号:
    使用.equ 命令把常量值定义为可以在文本段中使用的符号,如:
    .section .data
    .equ LINUX_SYS_CALL, 0x80
    .section .text
    movl $LINUX_SYS_CALL, %eax
*** 临时数据区 bss  .comm  .lcomm
    #+begin_verse
    .comm 声明为未初始化的通用内存区域
    .lcomm 声明为未初始化的本地内存区域
    
    .section .bss
    .lcomm buffer, 1000
 
    不占用程序空间，会在分配内存是分配空间
    #+end_verse
    
*** 代码放置区 .text
*** 代码入口处 .global
*** 寄存器
    32-bit 寄存器 %eax %ebx %ecx %edx %edi %esi %ebp %esp
    16-bit 寄存器 %ax %bx %cx %dx %di %si %bp %sp
    8-bit 寄存器 %ah,%al,%bh,%bl,%ch,%cl,%dh,%dl
    段寄存器 %cs(code),%ds(data),%ss(stack), %es,%fs,%gs
    控制寄存器 %cr0 %cr2,%cr3
    debug 寄存器 %db0 %db1,%db2,%db3,%db6,%db7
    测试寄存器 %tr6 %tr7
    浮点寄存器栈 %st(0),%st(1),%st(2),%st(3),%st(4),%st(5),%st(6),%st(7)。
*** 编译代码类型 .code16 .code32
*** 当前地址  . 
    len:  .int  .-msg
** 命令
**** 传送指令
***** move 指令
      #+begin_verse
      .section .data
      value:
      .int 100
      _start:
      movl value, %eax
      movl $value, %eax
      movl %ebx, (%edi)
      movl %ebx, 4(%edi)
         
      movl value, %eax 把标签 value 当前引用的内存值传递给 eax
     
      movl $value, %eax 把标签 value 当前引用的内存地址指针传递给 eax
       
      movl %ebx, (%edi) 如果 edi 外面没有括号那么这个指令只是把 ebx 中的值加载
      到 edi 中, 如果有了括号就表示把 ebx 中的内容传送给 edi 中包含的内存位置。
       
      movl %ebx, 4(%edi) 表示把 edi 中的值放在 edi 指向的位置之后的 4 字节内存
      位置中
       
      movl %ebx, -4(%edi) 表示把 edi 中的值放在 edi 指向的位置之前的 4 字节内存
      位置中
      #+end_verse
***** cmove 指令(条件转移):
      #+begin_verse
      cmovex 源操作数, 目的操作数. x 的取值为:
      无符号数:
      a/nbe 大于/不小于或者等于
      ae/nb 大于或者等于/不小于
      nc 无进位
      b/nae 小于/不大于等于
      c 进位
      be/na 小于或等于/不大于
      e/z 等于/零
      ne/nz 不等于/不为零
      p/pe 奇偶校验/偶校验
      np/po 非奇偶校验/奇校验
      有符号数:
      ge/nl 大于或者等于/不小于
      l/nge 小于/不大于或者等于
      le/ng 小于或者等于/不大于
      o 溢出
      no 未溢出
      s 带符号(负)
      ns 无符号(非负)
      #+end_verse
**** 交换数据
***** xchg 在两个寄存器之间或者寄存器和内存间交换值如:
      #+begin_verse
      xchg 操作数, 操作数, 要求两个操作数必须长度相同且不能同时都是内存位置其中寄
      存器可以是 32,16,8 位的 bswap 反转一个 32 位寄存器的字节顺序如: bswap %ebx
        
      xadd 交换两个值 并把两个值只和存储在目标操作数中如: xadd 源操作数,目标操作数
        
      其中源操作数必须是寄存器, 目标操作数可以是内存位置也可以是寄存器其中寄存器可
      以是 32,16,8 位的
      #+end_verse
***** cmpxchg
      #+begin_verse
      cmpxchg source, destination
        
      其中 source 必须是寄存器, destination 可以是内存或者寄存器, 用来比较两者
      的值, 如果相等,就把源操作数的值加载到目标操作数中, 如果不等就把目标操作
      数加载到源操作数中,其中寄存器可以是 32,16,8 位的, 其中源操作数是 EAX,AX
      或者 AL 寄存器中的值
      #+end_verse
***** cmpxchg8b 同 cmpxchg, 但是它处理 8 字节值, 同时它只有一个操作数
      #+begin_verse
      cmpxchg8b destination 其中 destination 引用一个内存位置, 其中的 8 字节值
      会与 EDX 和 EAX 寄存器中包含的值(EDX 高位寄存器,EAX 低位寄存器)进行比较,
      如果目标值和 EDX:EAX 对中的值相等, 就把 EDX:EAX 对中的 64 位值传递给内存
      位置, 如果不匹配就把内存地址中的值加载到 EDX:EAX 对中
      #+end_verse
***** 堆栈
      #+begin_verse
      ESP 寄存器保存了当前堆栈的起始位置, 当一个数据压入栈时, 它就会自动递减, 反之其自动递增
      压入堆栈操作:
      pushx source, x 取值为:
      l 32 位长字
      w 16 位字
      弹出堆栈操作:
      popx source
      其中 source 必须是 16 或 32 位寄存器或者内存位置, 当 pop 最后一个元素时 ESP 值应该和以前的相等
      5,压入和弹出所有寄存器
      pusha/popa 压入或者弹出所有 16 位通用寄存器
      pushad/popad 压入或者弹出所有 32 位通用寄存器
      pushf/popf 压入或者弹出 EFLAGS 寄存器的低 16 位
      pushfd/popfd 压入或者弹出 EFLAGS 寄存器的全部 32 位
      #+end_verse
***** 数据地址对齐
      #+begin_verse
      gas 汇编器支持.align 命令, 它用于在特定的内存边界对准定义的数据元素, 在
      数据段中.align 命令紧贴在数据定义的前面
      #+end_verse
**** 控制流程
***** 无条件跳转
****** 跳转
       jmp location 其中 location 为要跳转到的内存地址, 在汇编中为定义的标签
****** 调用
       #+begin_verse
       调用指令分为两个部分:
       1, 调用 call address 跳转到指定位置
       2, 返回指令 ret, 它没有参数紧跟在 call 指令后面的位置
       执行 call 指令时,它把 EIP 的值放到堆栈中, 然后修改 EIP 以指向被调用的函数地址, 当被调用函数完成后, 它从堆栈获取过去的 EIP 的
       值, 并把控制权返还给原始程序。
       #+end_verse
****** 中断
       #+begin_verse
       由硬件设备生成中断。 程序生成软件中断当一个程序产生中断调用时, 发出调用
       的程序暂停, 被调用的程序接替它运行, 指令指针被转移到被调用的函数地址,
       当调用完成时使用中断返回指令可以返回调原始程序。
       #+end_verse
***** 条件跳转
      #+begin_verse
      条件跳转按照 EFLAGS 中的值来判断是否该跳转, 格式为:
      jxx address, 其中 xx 是 1-3 个字符的条件代码, 取值如下:
        
      a 大于时跳转
      ae 大于等于
      b 小于
      be 小于等于
      c 进位
      cxz 如果 CX 寄存器为 0
      ecxz 如果 ECS 寄存器为 0
      e 相等
      na 不大于
      nae 不大于或者等于
      nb 不小于
      nbe 不小于或等于
      nc 无进位
      ne 不等于
      g 大于(有符号)
      ge 大于等于(有符号)
      l 小于(有符号)
      le 小于等于(有符号)
      ng 不大于(有符号)
      nge 不大于等于(有符号)
      nl 不小于
      nle 不小于等于
      no 不溢出
      np 不奇偶校验
      ns 无符号
      nz 非零
      o 溢出
      p 奇偶校验
      pe 如果偶校验
      po 如果奇校验
      s 如果带符号
      z 如果为零
        
      条件跳转不支持分段内存模型下的远跳转, 如果在该模式下进行程序设计必须使用
      程序逻辑确定条件是否存在, 然后实现无条件跳转, 跳转前必须设置 EFLAGS 寄存
      器
      #+end_verse
***** 比较
      #+begin_verse
      cmp operend1, operend2
      进位标志修改指令:
      CLC 清空进位标志(设置为 0)
      CMC 对进位标志求反(把它改变为相反的值)
      STC 设置进位标志(设置为 1)
      #+end_verse
***** 循环
      #+begin_verse
      loop 循环直到 ECX 寄存器为 0
      loope/loopz 循环直到 ecx 寄存器为 0 或者没有设置 ZF 标志
      loopne/loopnz 循环直到 ecx 为 0 或者设置了 ZF 标志
      指令格式为: loopxx address 注意循环指令只支持 8 位偏移地址
      #+end_verse
**** 数学运算
***** 加法
      #+begin_verse
      ADD source, destination 
      其中 source 可以是立即数内存或者寄存器, destination 可以是内存或者寄存器, 但是两者不能同时都是内存位置
      ADC 和 ADD 相似进行加法运算, 但是它把前一个 ADD 指令的产生进位标志的值包含在其中, 在处理位数大于 32(如 64)
      位的整数时, 该指令非常有用
      #+end_verse
***** 减法
      #+begin_verse
      SUB source, destination 把两个整数相减
      NEG 它生成值的补码
      SBB 指令, 和加法操作一样, 可以使用进位情况帮助执行大的无符号数值的减法运算. SBB 在多字节减法操作中利用进位和溢出标志实现跨
      数据边界的的借位特性
      #+end_verse
***** 递增和递减
      #+begin_verse
      dec destination 递减
      inc destination 递增
      其中 dec 和 inc 指令都不会影响进位标志, 所以递增或递减计数器的值都不会影响程序中涉及进位标志的其他任何运算
      #+end_verse
***** 乘法
      #+begin_verse
      mul source 进行无符号数相乘
      它使用隐含的目标操作数, 目标位置总是使用 eax 的某种形式, 这取决与源操作数的长度, 因此根据源操作数的长度,目标操作数必须放在
      AL, AX, EAX 中。 此外由于乘法可能产生很大的值, 目标位置必须是源操作数的两倍位置, 源为 8 时, 应该是 16, 源为 16 时, 应该为 32, 但
      是当源为 16 位时 intel 为了向下兼容, 目标操作数不是存放在 eax 中, 而是分别存放在 DX:AX 中, 结果高位存储在 DX 中, 地位存储在 AX 中。
      对于 32 位的源, 目标操作数存储在 EDX:EAX 中, 其中 EDX 存储的是高 32 位, EAX 存储的是低 32 位
      imul source 进行有符号数乘法运算, 其中的目标操作数和 mul 的一样
      imul source, destination 也可以执行有符号乘法运算, 但是此时可以把目标放在指定的位置, 使用这种格式的缺陷
      在与乘法的操作结果被限制为单一目标寄存器的长度.
      imul multiplier, source, destination
      其中 multiplier 是一个立即数, 这种方式允许一个值与给定的源操作数进行快速的乘法运算, 然后把结果存储在通用寄存器中
      #+end_verse
***** 除法
      #+begin_verse
      div divisor 执行无符号数除法运算
      除数的最大值取决与被除数的长度, 对于 16 位被除数 ,除数只能为 8 位, 32 或 64 位同上
      被除数 被除数长度 商 余数
      AX 16 位 AL AH
      DX:AX 32 位 AX DX
      EDX:EAX 64 位 EAX EDX
      idiv divisor 执行有符号数的除法运算, 方式和 div 一样
      #+end_verse
***** 浮点数
      #+begin_verse
      fld 指令用于把浮点数字传送入和传送出 FPU 寄存器, 格式:
      fld source
      其中 source 可以为 32 64 或者 80 位整数值
       
      IA-32 使用 FLD 指令用于把存储在内存中的单精度和双精度浮点值 FPU 寄存器堆
      栈中, 为了区分这两种长度 GNU 汇编器使用
       
      FLDS 加载单精度浮点数, FLDL 加载双精度浮点数
       
      类似 FST 用于获取 FPU 寄存器堆栈中顶部的值, 并且把这个值放到内存位置中,对
      于单精度使用 FSTS, 对于双精度使用 FSTL
      #+end_verse
***** 左移位
      #+begin_verse
      sal 向左移位
      sal destination 把 destination 向左移动 1 位
      sal %cl, destination 把 destination 的值向左移动 CL 寄存器中指定的位数
      sal shifter, destination 把 destination 的值向左移动 shifter 值指定的位数
       
      向左移位可以对带符号数和无符号数执行向左移位的操作, 移位造成的空位用零填
      充, 移位造成的超过数据长度的任何位都被存放在进位标志中, 然后在下一次移位
      操作中被丢弃
      #+end_verse
***** 右移位
      #+begin_verse
      shr 向右移位
      sar 向右移位
      SHR 指令清空移位造成的空位, 所以它只能对无符号数进行移位操作
       
      SAR 指令根据整数的符号位, 要么清空, 要么设置移位造成的空位, 对于负数, 空
      位被设置为 1
      #+end_verse
***** 循环移位
      #+begin_verse
      和移位指令类似, 只不过溢出的位被存放回值的另一端, 而不是丢弃
      ROL 向左循环移位
      ROR 向右循环移位
      RCL 向左循环移位, 并且包含进位标志
      RCR 向右循环移位, 并且包含进位标志
      #+end_verse
**** 逻辑运算
     #+begin_verse
     AND OR XOR
     这些指令使用相同的格式:
     and source, destination
       
     其中 source 可以是 8 位 16 位或者 32 位的立即值 寄存器或内存中的值,
     destination 可以是 8 位 16 位或者 32 位寄存器或内存中的值,
       
     不能同时使用内存值作为源和目标。 布尔逻辑功能对源和目标执行按位操作。
     也就是说使用指定的逻辑功能按照顺序对数据的元素的每个位进行单独比较。
     NOT 指令使用单一操作数, 它即是源值也是目标结果的位置
       
     清空寄存器的最高效方式是使用 OR 指令对寄存器和它本身进行异或操作.当和本身
     进行 XOR 操作时, 每个设置为 1 的位就变为 0, 每个设置为 0 的位也变位 0。
       
     位测试可以使用以上的逻辑运算指令, 但这些指令会修改 destination 的值, 因此
     intel 提供了 test 指令, 它不会修改目标值而是设置相应的标志
     #+end_verse
**** 字符串处理
***** 传送字符串
      #+begin_verse
      movs 有三种格式
      movsb 传送单一字节
      movsw 传送一个字
      movsl 传送双字
      movs 指令使用隐含的源和目的操作数, 隐含的源操作数是 ESI, 隐含的目的操作数是 EDI, 有两种方式加载内存地址到 ESI 和 EDI,
      第一种是使用标签间接寻址 movl $output, %ESI, 第二种是使用 lea 指令, lea 指令加载对象的地址到指定的目的操作数如 lea output,
      %esi, 每次执行 movs 指令后, 数据传送后 ESI 和 EDI 寄存器会自动改变,为另一次传送做准备, ESI 和 EDI 可能随着标志 DF 的不同自动
      递增或者自动递减, 如果 DF 标志为 0 则 movs 指令后 ESI 和 EDI 会递增, 反之会递减, 为了设置 DF 标志, 可以使用一下指令:
      CLD 将 DF 标志清零
      STD 设置 DF 标志
      #+end_verse
***** rep 前缀
      #+begin_verse
      REP 指令的特殊之处在与它不执行什么操作, 这条指令用于按照特定次数重复执行字符串指令, 有 ECX 寄存器控制,但不需要额外的 loop 指
      令, 如 rep movsl
      rep 的其他格式:
      repe 等于时重复
      repne 不等于时重复
      repnz 不为零时重复
      repz 为零时重复
      #+end_verse
***** 存储和加载字符串
      #+begin_verse
      LODS 加载字符串, ESI 为源, 当一次执行完 lods 时会递增或递减 ESI 寄存器, 然后把字符串值存放到 EAX 中
      STOS 使用 lods 把字符串值加载到 EAX 后, 可以使用它把 EAX 中的值存储到内存中去:
      stos 使用 EDI 作为目的操作数, 执行 stos 指令后, 会根据 DF 的值自动递增或者递减 EDI 中的值
      #+end_verse
***** 比较字符串
      #+begin_verse
      cmps 和其他的操作字符串的指令一样, 隐含的源和目标操作数都为 ESI 和 EDI, 每次执行时都会根据 DF 的值把
      ESI 和 EDI 递增或者递减, cmps 指令从目标字符串中减去源字符串, 执行后会设置 EFLAGS 寄存器的状态.
      #+end_verse
***** 扫描字符串
      scas 把 EDI 作为目标, 它把 EDI 中的字符串和 EAX 中的字符串进行比较 ,然后根据 DF 的值递增或者递减 EDI
**** 使用函数
     #+begin_verse
     GNU 汇编语言定义函数的语法:
     .type 标签(也就是函数名), @function
     ret 返回到调用处
     #+end_verse
**** 符号扩展指令
     #+begin_verse
     其它的 Intel 格式的符号扩展指令还有:
     cbw -- sign-extend byte in %al to word in %ax;
     cwde -- sign-extend word in %ax to long in %eax;
     cwd -- sign-extend word in %ax to long in %dx:%ax;
     cdq -- sign-extend dword in %eax to quad in %edx:%eax;
     对应的 AT&T 语法的指令为 cbtw,cwtl,cwtd,cltd。
     #+end_verse
** 高级功能
*** gnu 内联汇编的语法:
    #+begin_verse
    asm 或__asm__("汇编代码");
    指令必须包含在引号里
    如果包含的指令超过一行 必须使用新行分隔符分隔
       
    使用 c 全局变量, 不能在内联汇编中使用局部变量, 注意在汇编语言代码中值被用
    做内存位置, 而不是立即数值
    
    如果不希望优化内联汇编, 则可以 volatile 修饰符如:__asm__ volatile("code");
    #+end_verse
*** GCC 内联汇编的扩展语法
    #+begin_verse
    __asm__("assembly code":output locations:input operands:changed registers);
    第一部分是汇编代码
    第二部分是输出位置, 包含内联汇编代码的输出值的寄存器和内存位置列表
    第三部分是输入操作数,包含内联汇编代码输入值的寄存器和内存位置的列表
    第四部分是改动的寄存器, 内联汇编改变的任何其他寄存器的列表
    这几个部分可以不全有, 但是没有的还必须使用:分隔
    #+end_verse
**** 1, 指定输入值和输出值, 输入值和输出值的列表格式为:
     "constraint"(variable), 其中 variable 是程序中声明的 c 变量, 在扩展 asm
     格式中, 局部和全局变量都可以使用,使用 constrant(约束)
     
     定义把变量存放到哪(输入)或从哪里传送变量(输出)
       
     约束使用单一的字符, 如下:
     约束 描述
     a 使用%eax, %ax, %al 寄存器
     b 使用%ebx, %bx, %bl 寄存器
     c 使用%ecx, %cx, %cl 寄存器
     d 使用%edx, %dx, %dl 寄存器
     S 使用%esi, %si 寄存器
     D 使用%edi, %di 寄存器
     r 使用任何可用的通用寄存器
     q 使用%eax, %ebx, %ecx,%edx 之一
     A 对于 64 位值使用%eax, %edx 寄存器
     f 使用浮点寄存器
     t 使用第一个(顶部)的浮点寄存器
     u 使用第二个浮点寄存器
     m 使用变量的内存位置
     o 使用偏移内存位置
     V 只使用直接内存位置
     i 使用立即整数值
     n 使用值已知的立即整数值
     g 使用任何可用的寄存器和内存位置
     除了这些约束之外, 输出值还包含一个约束修饰符:
     输出修饰符 描述
     + 可以读取和写入操作数
       = 只能写入操作数
       % 如果有必要操作数可以和下一个操作数切换
       & 在内联函数完成之前, 可以删除和重新使用操作数
       如:
       __asm__("assembly code": "=a"(result):"d"(data1),"c"(data2));
       
       把 c 变量 data1 存放在 edx 寄存器中, 把 c 变量 data2 存放到 ecx 寄存器中,
       内联汇编的结果将存放在 eax 寄存器中, 然后传送给变量 result
       
       在扩展的 asm 语句块中如果要使用寄存器必须使用两个百分号符号
       
       不一定总要在内联汇编代码中指定输出值, 一些汇编指令假定输入值包含输出值,
       如 movs 指令
*** 其他扩展内联汇编知识:
**** 使用占位符
          #+begin_verse
          输入值存放在内联汇编段中声明的特定寄存器中, 并且在汇编指令中专门使用这些寄存器.虽然这种方式能够很好的处理只有几个输入值的情
          况, 但对于需要很多输入值的情况, 这中方式显的有点繁琐. 为了帮助解决这个问题, 扩展 asm 格式提供了占位符, 可以在内联汇编代码中使
          用它引用输入和输出值.
          占位符是前面加上百分号的数字, 按照内联汇编中列出的每个输入和输出值在列表中的位置,每个值被赋予从 0 开始的地方. 然后就可以在汇
          编代码中引用占位符来表示值。
          如果内联汇编代码中的输入和输出值共享程序中相同的 c 变量, 则可以指定使用占位符作为约束值, 如:
          __asm__("imull %1, %0"
          : "=r"(data2)
          : "r"(data1), "0"(data2));
          如输入输出值中共享相同的变量 data2, 而在输入变量中则可以使用标记 0 作为输入参数的约束
          #+end_verse
**** 替换占位符
          #+begin_verse
          如果处理很多输入和输出值, 数字型的占位符很快就会变的很混乱, 为了使条理清晰 ,GNU 汇编器(从版本 3.1 开始)允许声明替换的名称作为
          占位符.替换的名称在声明输入值和输出值的段中定义, 格式如下:
          %[name]"constraint"(variable)
          定义的值 name 成为内联汇编代码中变量的新的占位符号标识, 如下面的例子:
          __asm__("imull %[value1], %[value2]"
          : [value2] "=r"(data2)
          : [value1] "r"(data1), "0"(data2));
          #+end_verse
**** 改动寄存器列表
     编译器假设输入值和输出值使用的寄存器会被改动, 并且相应的作出处理。程序员
     不需要在改动的寄存器列表中包含这些值, 如果这样做了, 就
       
     会产生错误消息. 注意改动的寄存器列表中的寄存器使用完整的寄存器名称, 而不像输入和输出寄存器定义的那样仅仅是单一字母。 在寄存器
     名称前面使用百分号符号是可选的。
     改动寄存器列表的正确使用方法是, 如果内联汇编代码使用了没有被初始化地声明为输入或者输出值的其他任何寄存器 , 则要通知编译器。编
     译器必须知道这些寄存器, 以避免使用他们。如:
          #+begin_src c
            int main(void) {
              int data1 = 10;
              int result = 20;
              __asm__("movl %1, %%eax\n\t"
                      "addl %%eax, %0"
                      : "=r"(result)
                      : "r"(data1), "0"(result)
                      : "%eax");
              printf("The result is %d\n", result);
              return 0;
            }
          #+end_src
**** 使用内存位置
     虽然在内联汇编代码中使用寄存器比较快, 但是也可以直接使用 c 变量的内存
     位置。 约束 m 用于引用输入值和输出值中的内存位置。 记住, 对于要求使用
     寄存器的汇编指令, 仍然必须使用寄存器, 所以不得不定义保存数据的中间寄存
     器。如:
          #+begin_src c
          int main(void) {
          int dividentd = 20;
          int divisor = 5;
          int result;
          __asm__("divb %2\n\t"
          "movl %%eax, %0"
          : "=m"(result)
          : "a"(dividend), "m"(divisor));
          printf("The result is %d\n", result);
          return 0;
          }
          #+end_src
**** 处理跳转
          内联汇编语言代码也可以包含定义其中位置的标签。 可以实现一般的汇编条件分支和无条件分支, 如:
          #+begin_src c
            int main(void) {
              int a = 10;
              int b = 20;
              int result;
              __asm__("cmp %1, %2\n\t"
                      "jge greater\n\t"
                      "movl %1, %0\n\t"
                      "jmp end\n"
                      "greater:\n\t"
                      "movl %2, %0\n"
                      "end:"
                      :"=r"(result)
                      :"r"(a), "r"(b));
              printf("The larger value is %d\n", result);
              return 0;
            }
          #+end_src
          在内联汇编代码中使用标签时有两个限制。 第一个限制是只能跳转到相同的 asm 段内的标签,不能从一个 asm 段跳转到另一个 asm 段中的
          标签。第二个限制更加复杂一点。 以上程序使用标签 greater 和 end。 但是, 这样有个潜在的问题, 查看汇编后的代码清单, 可以发现内联
          汇编标签也被编码到了最终汇编后的代码中。 这意味着如果在 c 代码中还有另一个 asm 段, 就不能再次使用相同的标签, 否则会因为标签重
          复使用而导致错误消息。还有如果试图整合使用 c 关键字(比如函数名称或者全局变量)的标签也会导致错误。
** 优化代码
   GNU 编译器提供-O 选项供程序优化使用:
   -O 提供基础级别的优化
   -O2 提供更加高级的代码优化
   -O3 提供最高级的代码优化
*** 编译器优化级别 1
        在优化的第一个级别执行基础代码的优化。 这个级别试图执行 9 种单独的优化功能:
        -fdefer-pop: 这种优化技术与汇编语言代码在函数完成时如何进行操作有关。 一般情况下, 函数的输入值被保存在堆栈种并且被函数访问。
        函数返回时, 输入值还在堆栈种。 一般情况下, 函数返回之后, 输入值被立即弹出堆栈。这样做会使堆栈种的内容有些杂乱。
        -fmerge-constans: 使用这种优化技术, 编译器试图合并相同的常量. 这一特性有时候会导致很长的编译时间, 因为编译器必须分析 c 或者
        c++程序中用到的每个常量,并且相互比较他们.
        -fthread-jumps: 使用这种优化技术与编译器如果处理汇编代码中的条件和非条件分支有关。 在某些情况下, 一条跳转指令可能转移到另一
        条分支语句。 通过一连串跳转, 编译器确定多个跳转之间的最终目标并且把第一个跳转重新定向到最终目标。
        -floop-optimize: 通过优化如何生成汇编语言中的循环, 编译器可以在很大程序上提高应用程序的性能。 通常, 程序由很多大型且复杂的循
        环构成。 通过删除在循环内没有改变值的变量赋值操作, 可以减少循环内执行指令的数量, 在很大程度上提高性能。 此外优化那些确定何时离
        开循环的条件分支, 以便减少分支的影响。
        -fif-conversion: if-then 语句应该是应用程序中仅次于循环的最消耗时间的部分。简单的 if-then 语句可能在最终的汇编语言代码中产生众多
        的条件分支。 通过减少或者删除条件分支, 以及使用条件传送 设置标志和使用运算技巧来替换他们, 编译器可以减少 if-then 语句中花费的时
        间量。
        -fif-conversion2: 这种技术结合更加高级的数学特性, 减少实现 if-then 语句所需的条件分支。
        -fdelayed-branch: 这种技术试图根据指令周期时间重新安排指令。 它还试图把尽可能多的指令移动到条件分支前, 以便最充分的利用处理
        器的治理缓存。
        -fguess-branch-probability: 就像其名称所暗示的, 这种技术试图确定条件分支最可能的结果, 并且相应的移动指令, 这和延迟分支技术类
        似。因为在编译时预测代码的安排,所以使用这一选项两次编译相同的 c 或者 c++代码很可能会产生不同的汇编语言代码, 这取决于编译时
        编译器认为会使用那些分支。 因为这个原因, 很多程序员不喜欢采用这个特性, 并且专门地使用-fno-guess-branch-probability 选项关闭这
        个特性
        -fcprop-registers: 因为在函数中把寄存器分配给变量, 所以编译器执行第二次检查以便减少调度依赖性(两个段要求使用相同的寄存器)并
        且删除不必要的寄存器复制操作。
*** 编译器优化级别 2
        结合了第一个级别的所有优化技术, 再加上一下一些优化:
        -fforce-mem: 这种优化再任何指令使用变量前, 强制把存放再内存位置中的所有变量都复制到寄存器中。 对于只涉及单一指令的变量, 这样
        也许不会有很大的优化效果. 但是对于再很多指令(必须数学操作)中都涉及到的变量来说, 这会时很显著的优化, 因为和访问内存中的值相比 ,
        处理器访问寄存器中的值要快的多。
        -foptimize-sibling-calls: 这种技术处理相关的和/或者递归的函数调用。 通常, 递归的函数调用可以被展开为一系列一般的指令, 而不是
        使用分支。 这样处理器的指令缓存能够加载展开的指令并且处理他们, 和指令保持为需要分支操作的单独函数调用相比, 这样更快。
        -fstrength-reduce: 这种优化技术对循环执行优化并且删除迭代变量。 迭代变量是捆绑到循环计数器的变量, 比如使用变量, 然后使用循环
        计数器变量执行数学操作的 for-next 循环。
        -fgcse: 这种技术对生成的所有汇编语言代码执行全局通用表达式消除历程。 这些优化操作试图分析生成的汇编语言代码并且结合通用片段,
         消除冗余的代码段。如果代码使用计算性的 goto, gcc 指令推荐使用-fno-gcse 选项。
        -fcse-follow-jumps: 这种特别的通用子表达式消除技术扫描跳转指令, 查找程序中通过任何其他途径都不会到达的目标代码。这种情况最常
        见的例子就式 if-then-else 语句的 else 部分。
        -frerun-cse-after-loop: 这种技术在对任何循环已经进行过优化之后重新运行通用子表达式消除例程。这样确保在展开循环代码之后更进一
        步地优化还编代码。
        -fdelete-null-pointer-checks: 这种优化技术扫描生成的汇编语言代码, 查找检查空指针的代码。 编译器假设间接引用空指针将停止程序。
        如果在间接引用之后检查指针, 它就不可能为空。
        -fextensive-optimizations: 这种技术执行从编译时的角度来说代价高昂的各种优化技术,但是它可能对运行时的性能产生负面影响。
        -fregmove: 编译器试图重新分配 mov 指令中使用的寄存器, 并且将其作为其他指令操作数, 以便最大化捆绑的寄存器的数量。
        -fschedule-insns: 编译器将试图重新安排指令, 以便消除等待数据的处理器。 对于在进行浮点运算时有延迟的处理器来说, 这使处理器在
        等待浮点结果时可以加载其他指令。
        -fsched-interblock: 这种技术使编译器能够跨越指令块调度指令。 这可以非常灵活地移动指令以便等待期间完成的工作最大化。
        -fcaller-saves: 这个选项指示编译器对函数调用保存和恢复寄存器, 使函数能够访问寄存器值, 而且不必保存和恢复他们。 如果调用多个函
        数, 这样能够节省时间, 因为只进行一次寄存器的保存和恢复操作, 而不是在每个函数调用中都进行。
        -fpeephole2: 这个选项允许进行任何计算机特定的观察孔优化。
        -freorder-blocks: 这种优化技术允许重新安排指令块以便改进分支操作和代码局部性。
        -fstrict-aliasing: 这种技术强制实行高级语言的严格变量规则。 对于 c 和 c++程序来说, 它确保不在数据类型之间共享变量. 例如, 整数变
        量不和单精度浮点变量使用相同的内存位置。
         -funit-at-a-time: 这种优化技术指示编译器在运行优化例程之前读取整个汇编语言代码。 这使编译器可以重新安排不消耗大量时间的代码以
         便优化指令缓存。 但是, 这会在编译时花费相当多的内存, 对于小型计算机可能是一个问题。
         -falign-functions: 这个选项用于使函数对准内存中特定边界的开始位置。 大多数处理器按照页面读取内存,并且确保全部函数代码位于单
         一内存页面内, 就不需要叫化代码所需的页面。
         -fcrossjumping: 这是对跨越跳转的转换代码处理, 以便组合分散在程序各处的相同代码。 这样可以减少代码的长度, 但是也许不会对程
         序性能有直接影响。
*** 编译器优化级别 3
    它整合了第一和第二级别中的左右优化技巧, 还包括一下优化:
    -finline-functions: 这种优化技术不为函数创建单独的汇编语言代码, 而是把函数代码包含在调度程序的代码中。 对于多次被调用的函数
    来说, 为每次函数调用复制函数代码。 虽然这样对于减少代码长度不利, 但是通过最充分的利用指令缓存代码, 而不是在每次函数调用时进行
    分支操作, 可以提高性能。
    -fweb: 构建用于保存变量的伪寄存器网络。 伪寄存器包含数据, 就像他们是寄存器一样, 但是可以使用各种其他优化技术进行优化, 比如 cse
    和 loop 优化技术。
    -fgcse-after-reload: 这中技术在完全重新加载生成的且优化后的汇编语言代码之后执行第二次 gcse 优化,帮助消除不同优化方式创建的
    任何冗余段。
** 系统调用 
- int $0x80
- 调用号: %eax 
- 参数
  - 第一个参数 EBX 
  - 第二个参数 ECX 
  - 第三个参数  EDX 
  - 第四个参数  ESI 
  - 第五个参数  EDI 
       
    需要输入超过 6 个输入参数的系统调用, EBX 指针用于保存指向输入参数内存位置的
    指针, 输入参数按照连续的的顺序存储, 系统调用的返回值存放在 EAX 中
