* AT&A 汇编
  1.Register Reference
引用寄存器要在寄存器号前加百分号%,如“movl %eax, %ebx”。
80386 有如下寄存器:
[1] 8 个 32-bit 寄存器 %eax,%ebx,%ecx,%edx,%edi,%esi,%ebp,%esp;
( 8 个 16-bit 寄存器,它们事实上是上面 8 个 32-bit 寄存器的低 16 位:%ax,%bx,
%cx,%dx,%di,%si,%bp,%sp;
 8 个 8-bit 寄存器:%ah,%al,%bh,%bl,%ch,%cl,%dh,%dl。它们事实上
是寄存器%ax,%bx,%cx,%dx 的高 8 位和低 8 位;)
[2] 6 个段寄存器:%cs(code),%ds(data),%ss(stack), %es,%fs,%gs;
[3] 3 个控制寄存器:%cr0,%cr2,%cr3;
[4] 6 个 debug 寄存器:%db0,%db1,%db2,%db3,%db6,%db7;
[5] 2 个测试寄存器:%tr6,%tr7;
[6] 8 个浮点寄存器栈:%st(0),%st(1),%st(2),%st(3),%st(4),%st(5),%st(6),%st(7)。
2. Operator Sequence
操作数排列是从源(左)到目的(右),如“movl %eax(源), %ebx(目的)”
3. Immediately Operator
使用立即数,要在数前面加符号$, 如“movl $0x04, %ebx”
或者:
para = 0x04
movl $para, %ebx
指令执行的结果是将立即数 0x04 装入寄存器 ebx。
4. Symbol Constant
符号常数直接引用 如
value: .long 0x12a3f2de
movl value , %ebx
指令执行的结果是将常数 0x12a3f2de 装入寄存器 ebx。
引用符号地址在符号前加符号$, 如“movl $value, % ebx”则是将符号 value 的地址装入寄存器 ebx。
5. Length of Operator
操作数的长度用加在指令后的符号表示 b(byte, 8-bit), w(word, 16-bits), l(long,32-bits) ,如“movb %al, %bl” ,“movw
%ax, %bx”,“movl %eax, %ebx ”。
如 果没有指定操作数长度的话,编译器将按照目标操作数的长度来设置。比如指令“mov %ax, %bx”,由于目标操作数 bx 的长度为
word , 那 么 编 译 器 将 把 此 指 令 等 同 于 “ movw %ax,%bx” 。 同 样 道 理 , 指 令 “ mov $4, %ebx” 等 同 于 指 令 “ movl $4,
%ebx”,“push %al”等同于“pushb %al”。对于没有指定操作数长度,但编译器又无法猜测的指令,编译器将会报错,比如指令
“push $4”。
6. Sign and Zero Extension
绝大多数面向 80386 的 AT&T 汇编指令与 Intel 格式的汇编指令都是相同的,但符号扩展指令和零扩展指令有不同格式。符号扩展指令
和零扩展指令需要指定源操作数长度和目的操作数长度,即使在某些指令中这些操作数是隐含的。
    在 AT&T 语法中,符号扩展和零扩展指令的格式为,基本部分"movs"和"movz"(对应 Intel 语法的 movsx 和 movzx),后面跟
上源操作数长度和目的操作数长度。 movsbl 意味着 movs (from)byte (to)long;movbw 意味着 movs (from)byte
(to)word;movswl 意味着 movs (from)word (to)long。对于 movz 指令也一样。比如指令“movsbl %al,%edx”意味着将
al 寄存器的内容进行符号扩展后放置到 edx 寄存器中。
其它的 Intel 格式的符号扩展指令还有:
cbw -- sign-extend byte in %al to word in %ax;
cwde -- sign-extend word in %ax to long in %eax;
cwd -- sign-extend word in %ax to long in %dx:%ax;
cdq -- sign-extend dword in %eax to quad in %edx:%eax;
对应的 AT&T 语法的指令为 cbtw,cwtl,cwtd,cltd。
7. Call and Jump
段内调用和跳转指令为 "call" , "ret" 和 "jmp",段间调用和跳转指令为 "lcall" , "lret" 和 "ljmp" 。段间调用和跳转指令的格式为
“lcall/ljmp $SECTION, $OFFSET”,而段间返回指令则为“lret $STACK-ADJUST”。
8. Prefix
操作码前缀被用在下列的情况:
[1]字符串重复操作指令(rep,repne);
[2]指定被操作的段(cs,ds,ss,es,fs,gs);
[3]进行总线加锁(lock);
[4]指定地址和操作的大小(data16,addr16);
在 AT&T 汇编语法中,操作码前缀通常被单独放在一行,后面不跟任何操作数。例如,对于重复 scas 指令,其写法为:
repne
scas
上述操作码前缀的意义和用法如下:
[1]指定被操作的段前缀为 cs,ds,ss,es,fs,和 gs。在 AT&T 语法中,只需要按照
section:memory-operand 的格式就指定了相应的段前缀。比如:
lcall %cs:realmode_swtch
[2]操作数/地址大小前缀是“data16”和"addr16",它们被用来在 32-bit 操作数/地址代码中指定 16-bit 的操作数/地址。
[3]总线加锁前缀“lock”,它是为了在多处理器环境中,保证在当前指令执行期间禁止一切中断。这个前缀仅仅对 ADD, ADC, AND,
BTC, BTR, BTS, CMPXCHG,DEC,
INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,XCHG 指令有效,如果将 Lock 前
缀用在其它指令之前,将会引起异常。
[4]字符串重复操作前缀"rep","repe","repne"用来让字符串操作重复“%ecx”次。
9. Memory Reference
Intel 语法的间接内存引用的格式为:
section:[base+index*scale+displacement]
而在 AT&T 语法中对应的形式为:
section:displacement(base,index,scale)
其中,base 和 index 是任意的 32-bit base 和 index 寄存器。scale 可以取值 1,2,4,8。如果不指定 scale 值,则默认值为 1。
section 可以指定任意的段寄存器作为段前缀,默认的段寄存器在不同的情况下不一样。如果在指令中指定了默认的段前缀,则编译器在
目标代码中不会产生此段前缀代码。
下面是一些例子:
-4(%ebp):base=%ebp,displacement=-4,section 没有指定,由于 base=%ebp,所以默认的 section=%ss,index,scale
    没有指定,则 index 为 0。
    foo(,%eax,4):index=%eax,scale=4,displacement=foo。其它域没有指定。这里默认的 section=%ds。
    foo(,1):这个表达式引用的是指针 foo 指向的地址所存放的值。注意这个表达式中没有 base 和 index,并且只有一个逗号,这是一种
    异常语法,但却合法。
    %gs:foo:这个表达式引用的是放置于%gs 段里变量 foo 的值。
    如果 call 和 jump 操作在操作数前指定前缀“*”,则表示是一个绝对地址调用/跳转,也就是说 jmp/call 指令指定的是一个绝对地址。
    如果没有指定"*",则操作数是一个相对地址。
    任何指令如果其操作数是一个内存操作, 则指令必须指定它的操作尺寸
    (byte,word,long),也就是说必须带有指令后缀(b,w,l)。
     Linux 工作在保护模式下,用的是 32 位线性地址,所以在计算地址时不用考虑段基址和偏移量,而是采用如下的地
     址计算方法:
      disp + base + index * scale
     下面是一些内存操作数的例子:
      AT&T 格式
      movl -4(%ebp), %eax
      movl array(, %eax, 4), %eax
      movw array(%ebx, %eax, 4), %cx
      movb $4, %fs:(%eax)
其中下面这些省略了浮点数及 IA-32 如 SSE FPU 等特殊的指令集部分, 我觉得重要的是学习
linux 汇编的语法及编译原理和程序控制流程, 具体的指令细节就不那么重要了。
###########################################################################
#####################
# 一, IA-32 硬件特性
###########################################################################
#####################
寄存器:
1, 通用寄存器, 用于存放正在处理的数据
EAX 用于操作数和结果数的累加器
EBX 指向数据内存断中的数据的指针
ECX 字符串和循环操作的计数器
EDX IO 指针
EDI 用于字符串操作的目标的数据指针
ESI 用于字符串操作的源的数据指针
ESP 堆栈指针
EBP 堆栈数据指针
其中寄存器 EAX, EBX, ECX, EDX 又可以通过 16 位和 8 位寄存器名称引用如 EAX, AX 引用 EAX 低 16 位, AL 引用 EAX 低 8 位, AH 引用
AL 之后的高 8 位
2, 段寄存器:
IA-32 平台允许使用 3 中内存模型: 平坦内存模式 分段内存模式 实地址模式
平坦内存: 把全部的系统内存表示为连续的地址空间, 通过线性地址的特定地址访问内存位置.
分段内存: 把系统内存划分为独立的段组, 通过位于寄存器中的指针进行引用. 每个段用于包含特定类型的数据。 一个段用于包含指令码, 另
一个段包含数据元素, 第三个段包含数据堆栈。
段中的内存位置是通过逻辑地址引用的, 逻辑地址是由段地址加上偏移量构成, 处理器把逻辑地址转换为相应的线性地址以便访问。
段寄存器:
CS 代码段
DS 数据段
SS 堆栈段
ES 附加段指针
FS 附加段指针
GS 附加段指针
每个段寄存器都是 16 位的, 包含指向内存特定段起始位置的指针,程序不能显示加载或改变 CS 寄存器, DS, ES, FS, GS 都用于指向数据
段, 通过 4 个独立的段, 程序可以分隔数据元素, 确保他们不会重叠, 程序必须加载带有段的正确指针值的数据段寄存器, 并且使用偏移
值引用各个内存的位置。
SS 段寄存器用于指向堆栈段, 堆栈包含传递给函数和过程的数据值。
实地址: 如果实地址模式, 所有段寄存器都指向线性 0 地址, 并且都不会被程序改动, 所有的指令码 数据元素 堆栈元素 都是通过他们的
线性地址直接访问的。
3, 指令指针寄存器
是 EIP 寄存器, 它跟踪要执行程序的下一条指令代码, 应用程序不能修改指令指针本身,不能指定内存地址把它拖放 EIP 寄存器中,相反必须
通过一般的跳转指令来改变预存取缓存的下一条指令。
在平坦内存模型中, 指令指针包含下一条指令码的线性地址, 在分段模型中指令指针包含逻辑地址指针, 通过 CS 寄存器的内存引用。
4, 控制寄存器
CRO 控制操作模式 和 处理器当前状态的系统标志
CR1 当前没有使用
CR2 内存页面错误信息
CR3 内存页面目录信息
CR4 支持处理器特性和说明处理器特性能力的标志
不能直接访问控制寄存器, 但是能把控制寄存器中的值传递给通用寄存器,如果必须改动控制寄存器的标志, 可以改动通用寄存器的值, 然
后把内容传递给控制寄存器。
标志:
IA-32 使用单一的寄存器来包含一组状态控制和系统标志, EFLAGS 寄存器包含 32 位标志信息
1, 状态标志
标志 位 说明
CF 0 进位标志, 如果无符号数的数学操作产生最高有效位的进位或者借位, 此时值为 1
PF 2 奇偶校验标志, 用于表明数学操作的结果寄存器中的是否包含错误数据
AF 4 辅助进位标志, 用于二进制编码的 10 进制(BCD)的数学操作中, 如果用于运算的
寄存器的第三位发生进位或借位, 该值为 1
ZF 6 0 标志, 如果操作为 0, 则该值为 1
SF 7 符号标志, 设置为结果的最高有效位, 这一位是符号位表明结果是正值还是负值
OF 11 溢出标志
2, 控制标志
当前只定义了一个控制标志 DF 即方向标志, 用于控制处理器处理字符串的方式如果设置为 1, 字符串指令自动递减内存地址以便到达字符串
中的下一字节。
反之。
3, 系统标志
标志 位 说明
TF 8 陷阱标志, 设置为 1 时启用单步模式, 在单步模式下处理器每次只执行一条命令。
IF 9 中断使能标志, 控制处理器如响应从外部源接收到的信号。
IOPL 12 和 13 IO 特权级别标志, 表明当前正在运行任务的 IO 特权级别, 它定义 IO 地址空间的特权访问级别, 该值必须小于或者等于访问
I/O 地址空间的级别; 否则任何访问 IO 空间的请求都会被拒绝!
NT 14 嵌套任务标志控制当前运行的任务是否连接到前一个任务, 它用于连接被中断和被调用的任务.
RF 16 恢复标志用于控制在调试模式中如何响应异常。
VM 17 虚拟 8086 模式, 表明处理器在虚拟 8086 模式中而不是保护模式或者实模式。
AC 18 对准检查标志, 用于启用内存引用的对准检查
VIF 19 虚拟中断标志, 当处理器在虚拟模式中操作时, 该标志起 IF 标志的作用.
VIP 20 虚拟中断挂起标志, 在虚拟模式操作时用于表示一个中断正在被挂起。
ID 21 表示 CPU 是否支持 cpuid 指令, 如果处理器能够设置或者清零这个标志, 表示处理器支持该指令。
###########################################################################
#####################
# 二,GNU 汇编工具系列
###########################################################################
#####################
1, 二进制工具系列
addr2line 把地址转换成文件名或者行号
ar 创建 修改或者展开文件存档
as 把汇编语言代码汇编成目标代码
常用选项:
-a -> 指定输出中包含那些清单
-D -> 包含它用于向下兼容 但是被忽略
--defsym -> 在汇编代码之前定义符号和值
-f -> 快速汇编跳过注释和空白
--gstabs -> 包含每行源代码的调试信息
--gstats+ -> 包含 gdb 专门的调试信息
-I -> 指定包含文件的目录
-J -> 不警告带符号溢出
-L -> 在符号表中保存本地符号
-o -> 给定输出目标名
-R -> 把数据段合并进文本段
--statistics -> 显示汇编使用的最大空间和总时间
-v -> 显示 as 的版本号
-W -> 不显示警告信息
c++filt 还原 c++符号的过滤器
gprof 显示程序简档信息的程序
ld 把目标代码文件转换成可执行文件的转换器
常用选项:
-d -> 指定目标代码输入文件的格式
-Bstatic -> 只使用静态库
-Bdynamic -> 只使用动态库
-Bsymbolic-> 把引用捆绑到共享库中的全局符号
-c -> 从指定的命令文件读取命令
-cref -> 创建跨引用表
-defsym -> 在输出文件中创建指定的全局符号
-demangle -> 在错误消息中还原符号名称
-e -> 使用指定的符号作为程序的初始执行点
-E -> 对于 elf 文件把所有的符号添加到动态符号表
-share -> 创建共享库
-Ttext -> 使用指定的地址作为文本段的起始点
-Tdata -> 使用指定的地址作为数据段的起始点
-Tbss -> 使用指定的地址作为 bss 段的起始点
-L -> 把指定的路径添加到库搜索清单
-O -> 生成优化的输出文件
-o -> 指定输出名
-oformat -> 指定输出文件的二进制格式
-R -> 从指定的文件读取符号和地址
-rpath -> 把指定的位置添加到运行时库搜索路径
-rpath-link-> 指定搜索运行时共享库的路径
-X -> 删除本地所有临时符号
-x -> 删除本地所有符号
nm 列出目标文件中的符号
objcopy 复制或翻译目标文件
objdump 显示来自目标文件的信息
ranlib 生成存档文件内容的索引
readelf 按照 elf 格式显示目标文件信息
size 列出目标文件或者存档文件的段长度
strings 显示目标文件中可打印字符串
strip 丢弃符号
windres 编译 Microsoft Windows 资源文件
2, GNU 编译器
gcc
常用选项:
-c 编译或者汇编代码但不进行连接
-S 编译后停止但不进行汇编
-E 预处理后停止但不进行编译
-o 指定输出文件名
-v 显示每个编译阶段使用的命令
-std 指定使用的语言标准
-g 生成调试信息
-pg 生成 gprof 制作简档要使用的额外代码
-O 优化可执行代码
-W 设置编译器警告级别
-I 指定包含文件清单
-L 指定库文件目录
-D 预定义源代码中使用的宏
-U 取消任何定义了的宏
-f 指定控制编译器行为的选项
-m 指定与硬件相关的选项
3, GNU 调试程序
gdb
常用选项:
-d 指定远程调试时串行接口的线路速度
-batch 以批处理模式运行
-c 指定要分析的核心转储文件
-cd 指定工作目录
-d 指定搜索源文件的目录
-e 指定要执行的文件
-f 调试时以标准格式输出文件名和行号
-q 安静模式
-s 指定符号的文件名
-se 指定符号和要执行的文件名
-tty 设置标准输出和输入设备
-x 从指定的文件执行 gdb 命令
由于 gnu 调试时忽略开始处断点, 需要在开始标签处执行一个空指令
如:
.globl _start
_start:
nop
此时断点可以设置成 break *_start+1
查看寄存器状态 info registers
使用 print 命令查看特定寄存器或者变量的值, 加上修饰符可以得到不同的输出格式:
print/d 显示十进制数字
print/t 显示二进制数字
print/x 显示 16 进制数字
使用 x 命令可以查看特定内存的值:
x/nyz
其中 n 为要显示的字段数
y 时输出格式, 它可以是:
c 用于字符, d 用于十进制, x 用于 16 进制
z 是要显示的字段长度, 它可以是:
b 用于字节, h 用于 16 字节, w 用于 32 位字
如:
x/42cb 用于显示前 42 字节
###########################################################################
#####################
# 三, GNU 汇编语言结构
###########################################################################
#####################
主要包括三个常用的段:
data 数据段 声明带有初始值的元素
bss 数据段 声明使用 0 或者 null 初始化的元素
text 正文段 包含的指令, 每个汇编程序都必须包含此段
使用.section 指令定义段, 如:
.section .data
.section .bss
.section .text
起始点:
gnu 汇编器使用_start 标签表示默认的起始点, 此外如果想要汇编内部的标签能够被外部程序访问,需要使用.globl 指令,
如:.globl _start
使用通用库函数时可以使用:
ld -dynamic-linker /lib/ld-linux.so.2
###########################################################################
#####################
# 四, 数据传递
###########################################################################
#####################
1, 数据段
使用.data 声明数据段, 这个段中声明的任何数据元素都保留在内存中并可以被汇编程序的指令读取,此外还可以使用.rodata 声明只读的数据
段, 在声明一个数据元素时, 需要使用标签和命令:
标签:用做引用数据元素所使用的标记, 它和 c 语言的变量很相似, 它对于处理器是没有意义的, 它只是用做汇编器试图访问内存位置时用做
引用指针的一个位置。
指令:这个名字指示汇编器为通过标签引用的数据元素保留特定数量的内存, 声明命令之后必须给出一个或多个默认值。
声明指令:
.ascii 文本字符串
.asciz 以空字符结尾的字符串
.byte 字节值
.double 双精度浮点值
.float 单精度浮点值
.int 32 位整数
.long 32 位整数, 和 int 相同
.octa 16 字节整数
.quad 8 字节整数
.short 16 位整数
.single 单精度浮点数(和 float 相同)
例子:
output:
.ascii "hello world."
pi:
.float 2.14
声明可以在一行中定义多个值, 如:
ages:
.int 20, 10, 30, 40
定义静态符号:
使用.equ 命令把常量值定义为可以在文本段中使用的符号,如:
.section .data
.equ LINUX_SYS_CALL, 0x80
.section .text
movl $LINUX_SYS_CALL, %eax
2, bss 段
和 data 段不同, 无需声明特定的数据类型, 只需声明为所需目的保留的原始内存部分即可。
GNU 汇编器使用以下两个命令声明内存区域:
.comm 声明为未初始化的通用内存区域
.lcomm 声明为未初始化的本地内存区域
两种声明很相似, 但.lcomm 是为不会从本地汇编代码之外进行访问的数据保留的, 格式为:
.comm/.lcomm symbol, length
例子:
.section .bss
.lcomm buffer, 1000
该语句把 1000 字节的内存地址赋予标签 buffer, 在声明本地通用内存区域的程序之外的函数是不能访问他们的.(不能在.globl 命令中使用他
们)
在 bss 段声明的好处是, 数据不包含在可执行文件中。在数据段中定义数据时, 它必须被包含在可执行程序中, 因为必须使用特定值初始化它。
因为不使用数据初始化 bss 段中声明的数据区域,所以内存区域被保留在运行时使用, 并且不必包含在最终的程序中
3, 传送数据
move 指令:
格式 movex 源操作数, 目的操作数。 其中 x 为要传送数据的长度, 取值有:
l 用于 32 位的长字节
w 用于 16 位的字
b 用于 8 位的字节值
立即数前面要加一个$符号, 寄存器前面要加%符号。
8 个通用的寄存器是用于保存数据的最常用的寄存器, 这些寄存器的内容可以传递给其他的任何可用的寄存器。 和通用寄存器不同, 专用寄存
器(控制, 调试, 段)的内容只能传送给通用寄存器, 或者接收从通用寄存器传过来的内容。
在对标签进行引用时:
例:
.section .data
value:
.int 100
_start:
movl value, %eax
movl $value, %eax
movl %ebx, (%edi)
movl %ebx, 4(%edi)
其中:movl value, %eax 只是把标签 value 当前引用的内存值传递给 eax
movl $value, %eax 把标签 value 当前引用的内存地址指针传递给 eax
movl %ebx, (%edi) 如果 edi 外面没有括号那么这个指令只是把 ebx 中的
值加载到 edi 中, 如果有了括号就表示把 ebx 中的内容
传送给 edi 中包含的内存位置。
movl %ebx, 4(%edi) 表示把 edi 中的值放在 edi 指向的位置之后的 4 字节内存位置中
movl %ebx, -4(%edi) 表示把 edi 中的值放在 edi 指向的位置之前的 4 字节内存位置中
cmove 指令(条件转移):
cmovex 源操作数, 目的操作数. x 的取值为:
无符号数:
a/nbe 大于/不小于或者等于
ae/nb 大于或者等于/不小于
nc 无进位
b/nae 小于/不大于等于
c 进位
be/na 小于或等于/不大于
e/z 等于/零
ne/nz 不等于/不为零
p/pe 奇偶校验/偶校验
np/po 非奇偶校验/奇校验
有符号数:
ge/nl 大于或者等于/不小于
l/nge 小于/不大于或者等于
le/ng 小于或者等于/不大于
o 溢出
no 未溢出
s 带符号(负)
ns 无符号(非负)
交换数据:
xchg 在两个寄存器之间或者寄存器和内存间交换值如:
xchg 操作数, 操作数, 要求两个操作数必须长度相同且不能同时都是内存位置其中寄存器可以是 32,16,8 位的 bswap 反转一个 32 位寄
存器的字节顺序如: bswap %ebx
xadd 交换两个值 并把两个值只和存储在目标操作数中如: xadd 源操作数,目标操作数
其中源操作数必须是寄存器, 目标操作数可以是内存位置也可以是寄存器其中寄存器可以是 32,16,8 位的
cmpxchg
cmpxchg source, destination
其中 source 必须是寄存器, destination 可以是内存或者寄存器, 用来比较两者的值, 如果相等,就把源操作数的值加载到目标操作数中, 如
果不等就把目标操作数加载到源操作数中,其中寄存器可以是 32,16,8 位的, 其中源操作数是 EAX,AX 或者 AL 寄存器中的值
cmpxchg8b 同 cmpxchg, 但是它处理 8 字节值, 同时它只有一个操作数
cmpxchg8b destination 其中 destination 引用一个内存位置, 其中的 8 字节值会与 EDX 和 EAX 寄存器中包含的值(EDX 高位寄存器,EAX
低位寄存器)进行比较, 如果目标值和 EDX:EAX 对中的值相等, 就把 EDX:EAX 对中的 64 位值传递给内存位置, 如果不匹配就把内存地址中
的值加载到 EDX:EAX 对中
4, 堆栈
ESP 寄存器保存了当前堆栈的起始位置, 当一个数据压入栈时, 它就会自动递减, 反之其自动递增
压入堆栈操作:
pushx source, x 取值为:
l 32 位长字
w 16 位字
弹出堆栈操作:
popx source
其中 source 必须是 16 或 32 位寄存器或者内存位置, 当 pop 最后一个元素时 ESP 值应该和以前的相等
5,压入和弹出所有寄存器
pusha/popa 压入或者弹出所有 16 位通用寄存器
pushad/popad 压入或者弹出所有 32 位通用寄存器
pushf/popf 压入或者弹出 EFLAGS 寄存器的低 16 位
pushfd/popfd 压入或者弹出 EFLAGS 寄存器的全部 32 位
6,数据地址对齐
gas 汇编器支持.align 命令, 它用于在特定的内存边界对准定义的数据元素, 在数据段中.align 命令紧贴在数据定义的前面
###########################################################################
#####################
# 五,控制流程
###########################################################################
#####################
无条件跳转:
1, 跳转
jmp location 其中 location 为要跳转到的内存地址, 在汇编中为定义的标签
2,调用
调用指令分为两个部分:
1, 调用 call address 跳转到指定位置
2, 返回指令 ret, 它没有参数紧跟在 call 指令后面的位置
执行 call 指令时,它把 EIP 的值放到堆栈中, 然后修改 EIP 以指向被调用的函数地址, 当被调用函数完成后, 它从堆栈获取过去的 EIP 的
值, 并把控制权返还给原始程序。
3,中断
由硬件设备生成中断。 程序生成软件中断当一个程序产生中断调用时, 发出调用的程序暂停, 被调用的程序接替它运行, 指令指针被转移到
被调用的函数地址, 当调用完成时使用中断返回指令可以返回调原始程序。
条件跳转:
条件跳转按照 EFLAGS 中的值来判断是否该跳转, 格式为:
jxx address, 其中 xx 是 1-3 个字符的条件代码, 取值如下:
a 大于时跳转
ae 大于等于
b 小于
be 小于等于
c 进位
cxz 如果 CX 寄存器为 0
ecxz 如果 ECS 寄存器为 0
e 相等
na 不大于
nae 不大于或者等于
nb 不小于
nbe 不小于或等于
nc 无进位
ne 不等于
g 大于(有符号)
ge 大于等于(有符号)
l 小于(有符号)
le 小于等于(有符号)
ng 不大于(有符号)
nge 不大于等于(有符号)
nl 不小于
nle 不小于等于
no 不溢出
np 不奇偶校验
ns 无符号
nz 非零
o 溢出
p 奇偶校验
pe 如果偶校验
po 如果奇校验
s 如果带符号
z 如果为零
条件跳转不支持分段内存模型下的远跳转, 如果在该模式下进行程序设计必须使用程序逻辑确定条件是否存在, 然后实现无条件跳转, 跳转
前必须设置 EFLAGS 寄存器
比较:
cmp operend1, operend2
进位标志修改指令:
CLC 清空进位标志(设置为 0)
CMC 对进位标志求反(把它改变为相反的值)
STC 设置进位标志(设置为 1)
循环:
loop 循环直到 ECX 寄存器为 0
loope/loopz 循环直到 ecx 寄存器为 0 或者没有设置 ZF 标志
loopne/loopnz 循环直到 ecx 为 0 或者设置了 ZF 标志
指令格式为: loopxx address 注意循环指令只支持 8 位偏移地址
###########################################################################
#####################
# 六,数字
###########################################################################
#####################
IA-32 平台中存储超过一字节的数都被存储为小尾数的形式但是把数字传递给寄存器时, 寄存器里面保存是按照大尾数的形式存储
把无符号数转换成位数更大的值时, 必须确保所有的高位部分都被设置为零
把有符号数转换成位数更大的数时:
intel 提供了 movsx 指令它允许扩展带符号数并保留符号, 它与 movzx 相似, 但是它假设要传送的字节是带符号数形式
浮点数:
fld 指令用于把浮点数字传送入和传送出 FPU 寄存器, 格式:
fld source
其中 source 可以为 32 64 或者 80 位整数值
IA-32 使用 FLD 指令用于把存储在内存中的单精度和双精度浮点值 FPU 寄存器堆栈中, 为了区分这两种长度 GNU 汇编器使用
FLDS 加载单精度浮点数, FLDL 加载双精度浮点数
类似 FST 用于获取 FPU 寄存器堆栈中顶部的值, 并且把这个值放到内存位置中, 对于单精度使用 FSTS, 对于双精度使用 FSTL
###########################################################################
#####################
# 七,基本数学运算
###########################################################################
#####################
1, 加法
ADD source, destination 把两个整数相加
其中 source 可以是立即数内存或者寄存器, destination 可以是内存或者寄存器, 但是两者不能同时都是内存位置
ADC 和 ADD 相似进行加法运算, 但是它把前一个 ADD 指令的产生进位标志的值包含在其中, 在处理位数大于 32(如 64)
位的整数时, 该指令非常有用
2, 减法
SUB source, destination 把两个整数相减
NEG 它生成值的补码
SBB 指令, 和加法操作一样, 可以使用进位情况帮助执行大的无符号数值的减法运算. SBB 在多字节减法操作中利用进位和溢出标志实现跨
数据边界的的借位特性
3,递增和递减
dec destination 递减
inc destination 递增
其中 dec 和 inc 指令都不会影响进位标志, 所以递增或递减计数器的值都不会影响程序中涉及进位标志的其他任何运算
4, 乘法
mul source 进行无符号数相乘
它使用隐含的目标操作数, 目标位置总是使用 eax 的某种形式, 这取决与源操作数的长度, 因此根据源操作数的长度,目标操作数必须放在
AL, AX, EAX 中。 此外由于乘法可能产生很大的值, 目标位置必须是源操作数的两倍位置, 源为 8 时, 应该是 16, 源为 16 时, 应该为 32, 但
是当源为 16 位时 intel 为了向下兼容, 目标操作数不是存放在 eax 中, 而是分别存放在 DX:AX 中, 结果高位存储在 DX 中, 地位存储在 AX 中。
对于 32 位的源, 目标操作数存储在 EDX:EAX 中, 其中 EDX 存储的是高 32 位, EAX 存储的是低 32 位
imul source 进行有符号数乘法运算, 其中的目标操作数和 mul 的一样
imul source, destination 也可以执行有符号乘法运算, 但是此时可以把目标放在指定的位置, 使用这种格式的缺陷
在与乘法的操作结果被限制为单一目标寄存器的长度.
imul multiplier, source, destination
其中 multiplier 是一个立即数, 这种方式允许一个值与给定的源操作数进行快速的乘法运算, 然后把结果存储在通用寄存器中
5, 除法
div divisor 执行无符号数除法运算
除数的最大值取决与被除数的长度, 对于 16 位被除数 ,除数只能为 8 位, 32 或 64 位同上
被除数 被除数长度 商 余数
AX 16 位 AL AH
DX:AX 32 位 AX DX
EDX:EAX 64 位 EAX EDX
idiv divisor 执行有符号数的除法运算, 方式和 div 一样
6, 移位
左移位:
sal 向左移位
sal destination 把 destination 向左移动 1 位
sal %cl, destination 把 destination 的值向左移动 CL 寄存器中指定的位数
sal shifter, destination 把 destination 的值向左移动 shifter 值指定的位数
向左移位可以对带符号数和无符号数执行向左移位的操作, 移位造成的空位用零填充, 移位造成的超过数据长度的任何位都被存放在进位标志
中, 然后在下一次移位操作中被丢弃
右移位:
shr 向右移位
sar 向右移位
SHR 指令清空移位造成的空位, 所以它只能对无符号数进行移位操作
SAR 指令根据整数的符号位, 要么清空, 要么设置移位造成的空位, 对于负数, 空位被设置为 1
循环移位:
和移位指令类似, 只不过溢出的位被存放回值的另一端, 而不是丢弃
ROL 向左循环移位
ROR 向右循环移位
RCL 向左循环移位, 并且包含进位标志
RCR 向右循环移位, 并且包含进位标志
7, 逻辑运算
AND OR XOR
这些指令使用相同的格式:
and source, destination
其中 source 可以是 8 位 16 位或者 32 位的立即值 寄存器或内存中的值, destination 可以是 8 位 16 位或者 32 位寄存器或内存中的值,
不能同时使用内存值作为源和目标。 布尔逻辑功能对源和目标执行按位操作。
也就是说使用指定的逻辑功能按照顺序对数据的元素的每个位进行单独比较。
NOT 指令使用单一操作数, 它即是源值也是目标结果的位置
清空寄存器的最高效方式是使用 OR 指令对寄存器和它本身进行异或操作.当和本身进行 XOR 操作时, 每个设置为 1 的位就变为 0, 每个设
置为 0 的位也变位 0。
位测试可以使用以上的逻辑运算指令, 但这些指令会修改 destination 的值, 因此 intel 提供了 test 指令, 它不会修改目标值而是设置相应的
标志
###########################################################################
#####################
# 八,字符串处理
###########################################################################
#####################
1, 传送字符串
movs 有三种格式
movsb 传送单一字节
movsw 传送一个字
movsl 传送双字
movs 指令使用隐含的源和目的操作数, 隐含的源操作数是 ESI, 隐含的目的操作数是 EDI, 有两种方式加载内存地址到 ESI 和 EDI,
第一种是使用标签间接寻址 movl $output, %ESI, 第二种是使用 lea 指令, lea 指令加载对象的地址到指定的目的操作数如 lea output,
%esi, 每次执行 movs 指令后, 数据传送后 ESI 和 EDI 寄存器会自动改变,为另一次传送做准备, ESI 和 EDI 可能随着标志 DF 的不同自动
递增或者自动递减, 如果 DF 标志为 0 则 movs 指令后 ESI 和 EDI 会递增, 反之会递减, 为了设置 DF 标志, 可以使用一下指令:
CLD 将 DF 标志清零
STD 设置 DF 标志
2,rep 前缀
REP 指令的特殊之处在与它不执行什么操作, 这条指令用于按照特定次数重复执行字符串指令, 有 ECX 寄存器控制,但不需要额外的 loop 指
令, 如 rep movsl
rep 的其他格式:
repe 等于时重复
repne 不等于时重复
repnz 不为零时重复
repz 为零时重复
3, 存储和加载字符串
LODS 加载字符串, ESI 为源, 当一次执行完 lods 时会递增或递减 ESI 寄存器, 然后把字符串值存放到 EAX 中
STOS 使用 lods 把字符串值加载到 EAX 后, 可以使用它把 EAX 中的值存储到内存中去:
stos 使用 EDI 作为目的操作数, 执行 stos 指令后, 会根据 DF 的值自动递增或者递减 EDI 中的值
4, 比较字符串
cmps 和其他的操作字符串的指令一样, 隐含的源和目标操作数都为 ESI 和 EDI, 每次执行时都会根据 DF 的值把
ESI 和 EDI 递增或者递减, cmps 指令从目标字符串中减去源字符串, 执行后会设置 EFLAGS 寄存器的状态.
5,扫描字符串
scas 把 EDI 作为目标, 它把 EDI 中的字符串和 EAX 中的字符串进行比较 ,然后根据 DF 的值递增或者递减 EDI
###########################################################################
#####################
# 九,使用函数
###########################################################################
#####################
GNU 汇编语言定义函数的语法:
.type 标签(也就是函数名), @function
ret 返回到调用处
###########################################################################
#####################
# 十,linux 系统调用
###########################################################################
#####################
linux 系统调用的中断向量为 0x80
1, 系统调用标识存放在%eax 中
2, 系统调用输入值:
EBX 第一个参数
ECX 第二个参数
EDX 第三个参数
ESI 第四个参数
EDI 第五个参数
需要输入超过 6 个输入参数的系统调用, EBX 指针用于保存指向输入参数内存位置的指针, 输入参数按照连续的的顺序存储, 系统调用的返回
值存放在 EAX 中
###########################################################################
#####################
# 十一,汇编语言的高级功能
###########################################################################
#####################
1,gnu 内联汇编的语法:
asm 或__asm__("汇编代码");
指令必须包含在引号里
如果包含的指令超过一行 必须使用新行分隔符分隔
使用 c 全局变量, 不能在内联汇编中使用局部变量, 注意在汇编语言代码中值被用做内存位置, 而不是立即数值
如果不希望优化内联汇编, 则可以 volatile 修饰符如:__asm__ volatile("code");
2,GCC 内联汇编的扩展语法
__asm__("assembly code":output locations:input operands:changed registers);
第一部分是汇编代码
第二部分是输出位置, 包含内联汇编代码的输出值的寄存器和内存位置列表
第三部分是输入操作数,包含内联汇编代码输入值的寄存器和内存位置的列表
第四部分是改动的寄存器, 内联汇编改变的任何其他寄存器的列表
这几个部分可以不全有, 但是没有的还必须使用:分隔
1, 指定输入值和输出值, 输入值和输出值的列表格式为:
"constraint"(variable), 其中 variable 是程序中声明的 c 变量, 在扩展 asm 格式中, 局部和全局变量都可以使用,使用 constrant(约束)
定义把变量存放到哪(输入)或从哪里传送变量(输出)
约束使用单一的字符, 如下:
约束 描述
a 使用%eax, %ax, %al 寄存器
b 使用%ebx, %bx, %bl 寄存器
c 使用%ecx, %cx, %cl 寄存器
d 使用%edx, %dx, %dl 寄存器
S 使用%esi, %si 寄存器
D 使用%edi, %di 寄存器
r 使用任何可用的通用寄存器
q 使用%eax, %ebx, %ecx,%edx 之一
A 对于 64 位值使用%eax, %edx 寄存器
f 使用浮点寄存器
t 使用第一个(顶部)的浮点寄存器
u 使用第二个浮点寄存器
m 使用变量的内存位置
o 使用偏移内存位置
V 只使用直接内存位置
i 使用立即整数值
n 使用值已知的立即整数值
g 使用任何可用的寄存器和内存位置
除了这些约束之外, 输出值还包含一个约束修饰符:
输出修饰符 描述
+ 可以读取和写入操作数
= 只能写入操作数
% 如果有必要操作数可以和下一个操作数切换
& 在内联函数完成之前, 可以删除和重新使用操作数
如:
__asm__("assembly code": "=a"(result):"d"(data1),"c"(data2));
把 c 变量 data1 存放在 edx 寄存器中, 把 c 变量 data2 存放到 ecx 寄存器中, 内联汇编的结果将存放在 eax 寄存器中, 然后传送给变量
result
在扩展的 asm 语句块中如果要使用寄存器必须使用两个百分号符号
不一定总要在内联汇编代码中指定输出值, 一些汇编指令假定输入值包含输出值, 如 movs 指令
其他扩展内联汇编知识:
1, 使用占位符
输入值存放在内联汇编段中声明的特定寄存器中, 并且在汇编指令中专门使用这些寄存器.虽然这种方式能够很好的处理只有几个输入值的情
况, 但对于需要很多输入值的情况, 这中方式显的有点繁琐. 为了帮助解决这个问题, 扩展 asm 格式提供了占位符, 可以在内联汇编代码中使
用它引用输入和输出值.
占位符是前面加上百分号的数字, 按照内联汇编中列出的每个输入和输出值在列表中的位置,每个值被赋予从 0 开始的地方. 然后就可以在汇
编代码中引用占位符来表示值。
如果内联汇编代码中的输入和输出值共享程序中相同的 c 变量, 则可以指定使用占位符作为约束值, 如:
__asm__("imull %1, %0"
: "=r"(data2)
: "r"(data1), "0"(data2));
如输入输出值中共享相同的变量 data2, 而在输入变量中则可以使用标记 0 作为输入参数的约束
2, 替换占位符
如果处理很多输入和输出值, 数字型的占位符很快就会变的很混乱, 为了使条理清晰 ,GNU 汇编器(从版本 3.1 开始)允许声明替换的名称作为
占位符.替换的名称在声明输入值和输出值的段中定义, 格式如下:
%[name]"constraint"(variable)
定义的值 name 成为内联汇编代码中变量的新的占位符号标识, 如下面的例子:
__asm__("imull %[value1], %[value2]"
: [value2] "=r"(data2)
: [value1] "r"(data1), "0"(data2));
3, 改动寄存器列表
编译器假设输入值和输出值使用的寄存器会被改动, 并且相应的作出处理。程序员不需要在改动的寄存器列表中包含这些值, 如果这样做了, 就
会产生错误消息. 注意改动的寄存器列表中的寄存器使用完整的寄存器名称, 而不像输入和输出寄存器定义的那样仅仅是单一字母。 在寄存器
名称前面使用百分号符号是可选的。
改动寄存器列表的正确使用方法是, 如果内联汇编代码使用了没有被初始化地声明为输入或者输出值的其他任何寄存器 , 则要通知编译器。编
译器必须知道这些寄存器, 以避免使用他们。如:
int main(void) {
int data1 = 10;
int result = 20;
__asm__("movl %1, %%eax\n\t"
"addl %%eax, %0"
: "=r"(result)
: "r"(data1), "0"(result)
: "%eax");
printf("The result is %d\n", result);
return 0;
}
4, 使用内存位置
虽然在内联汇编代码中使用寄存器比较快, 但是也可以直接使用 c 变量的内存位置。 约束 m 用于引用输入值和输出值中的内存位置。 记住, 对
于要求使用寄存器的汇编指令, 仍然必须使用寄存器, 所以不得不定义保存数据的中间寄存器。如:
int main(void) {
int dividentd = 20;
int divisor = 5;
int result;
__asm__("divb %2\n\t"
"movl %%eax, %0"
: "=m"(result)
: "a"(dividend), "m"(divisor));
printf("The result is %d\n", result);
return 0;
}
5, 处理跳转
内联汇编语言代码也可以包含定义其中位置的标签。 可以实现一般的汇编条件分支和无条件分支, 如:
int main(void) {
int a = 10;
int b = 20;
int result;
__asm__("cmp %1, %2\n\t"
"jge greater\n\t"
"movl %1, %0\n\t"
"jmp end\n"
"greater:\n\t"
"movl %2, %0\n"
"end:"
:"=r"(result)
:"r"(a), "r"(b));
printf("The larger value is %d\n", result);
return 0;
}
在内联汇编代码中使用标签时有两个限制。 第一个限制是只能跳转到相同的 asm 段内的标签,不能从-个 asm 段跳转到另一个 asm 段中的
标签。第二个限制更加复杂一点。 以上程序使用标签 greater 和 end。 但是, 这样有个潜在的问题, 查看汇编后的代码清单, 可以发现内联
汇编标签也被编码到了最终汇编后的代码中。 这意味着如果在 c 代码中还有另一个 asm 段, 就不能再次使用相同的标签, 否则会因为标签重
复使用而导致错误消息。还有如果试图整合使用 c 关键字(比如函数名称或者全局变量)的标签也会导致错误。
###########################################################################
#####################
# 十二,优化你的代码
###########################################################################
#####################
GNU 编译器提供-O 选项供程序优化使用:
-O 提供基础级别的优化
-O2 提供更加高级的代码优化
-O3 提供最高级的代码优化
不同的优化级别使用的优化技术也可以单独的应用于代码。 可以使用-f 命令行选项引用每个单独的优化技术。
1, 编译器优化级别 1
在优化的第一个级别执行基础代码的优化。 这个级别试图执行 9 种单独的优化功能:
-fdefer-pop: 这种优化技术与汇编语言代码在函数完成时如何进行操作有关。 一般情况下, 函数的输入值被保存在堆栈种并且被函数访问。
函数返回时, 输入值还在堆栈种。 一般情况下, 函数返回之后, 输入值被立即弹出堆栈。这样做会使堆栈种的内容有些杂乱。
-fmerge-constans: 使用这种优化技术, 编译器试图合并相同的常量. 这一特性有时候会导致很长的编译时间, 因为编译器必须分析 c 或者
c++程序中用到的每个常量,并且相互比较他们.
-fthread-jumps: 使用这种优化技术与编译器如果处理汇编代码中的条件和非条件分支有关。 在某些情况下, 一条跳转指令可能转移到另一
条分支语句。 通过一连串跳转, 编译器确定多个跳转之间的最终目标并且把第一个跳转重新定向到最终目标。
-floop-optimize: 通过优化如何生成汇编语言中的循环, 编译器可以在很大程序上提高应用程序的性能。 通常, 程序由很多大型且复杂的循
环构成。 通过删除在循环内没有改变值的变量赋值操作, 可以减少循环内执行指令的数量, 在很大程度上提高性能。 此外优化那些确定何时离
开循环的条件分支, 以便减少分支的影响。
-fif-conversion: if-then 语句应该是应用程序中仅次于循环的最消耗时间的部分。简单的 if-then 语句可能在最终的汇编语言代码中产生众多
的条件分支。 通过减少或者删除条件分支, 以及使用条件传送 设置标志和使用运算技巧来替换他们, 编译器可以减少 if-then 语句中花费的时
间量。
-fif-conversion2: 这种技术结合更加高级的数学特性, 减少实现 if-then 语句所需的条件分支。
-fdelayed-branch: 这种技术试图根据指令周期时间重新安排指令。 它还试图把尽可能多的指令移动到条件分支前, 以便最充分的利用处理
器的治理缓存。
-fguess-branch-probability: 就像其名称所暗示的, 这种技术试图确定条件分支最可能的结果, 并且相应的移动指令, 这和延迟分支技术类
似。因为在编译时预测代码的安排,所以使用这一选项两次编译相同的 c 或者 c++代码很可能会产生不同的汇编语言代码, 这取决于编译时
编译器认为会使用那些分支。 因为这个原因, 很多程序员不喜欢采用这个特性, 并且专门地使用-fno-guess-branch-probability 选项关闭这
个特性
-fcprop-registers: 因为在函数中把寄存器分配给变量, 所以编译器执行第二次检查以便减少调度依赖性(两个段要求使用相同的寄存器)并
且删除不必要的寄存器复制操作。
2, 编译器优化级别 2
结合了第一个级别的所有优化技术, 再加上一下一些优化:
-fforce-mem: 这种优化再任何指令使用变量前, 强制把存放再内存位置中的所有变量都复制到寄存器中。 对于只涉及单一指令的变量, 这样
也许不会有很大的优化效果. 但是对于再很多指令(必须数学操作)中都涉及到的变量来说, 这会时很显著的优化, 因为和访问内存中的值相比 ,
处理器访问寄存器中的值要快的多。
-foptimize-sibling-calls: 这种技术处理相关的和/或者递归的函数调用。 通常, 递归的函数调用可以被展开为一系列一般的指令, 而不是
使用分支。 这样处理器的指令缓存能够加载展开的指令并且处理他们, 和指令保持为需要分支操作的单独函数调用相比, 这样更快。
-fstrength-reduce: 这种优化技术对循环执行优化并且删除迭代变量。 迭代变量是捆绑到循环计数器的变量, 比如使用变量, 然后使用循环
计数器变量执行数学操作的 for-next 循环。
-fgcse: 这种技术对生成的所有汇编语言代码执行全局通用表达式消除历程。 这些优化操作试图分析生成的汇编语言代码并且结合通用片段,
 消除冗余的代码段。如果代码使用计算性的 goto, gcc 指令推荐使用-fno-gcse 选项。
-fcse-follow-jumps: 这种特别的通用子表达式消除技术扫描跳转指令, 查找程序中通过任何其他途径都不会到达的目标代码。这种情况最常
见的例子就式 if-then-else 语句的 else 部分。
-frerun-cse-after-loop: 这种技术在对任何循环已经进行过优化之后重新运行通用子表达式消除例程。这样确保在展开循环代码之后更进一
步地优化还编代码。
-fdelete-null-pointer-checks: 这种优化技术扫描生成的汇编语言代码, 查找检查空指针的代码。 编译器假设间接引用空指针将停止程序。
如果在间接引用之后检查指针, 它就不可能为空。
-fextensive-optimizations: 这种技术执行从编译时的角度来说代价高昂的各种优化技术,但是它可能对运行时的性能产生负面影响。
-fregmove: 编译器试图重新分配 mov 指令中使用的寄存器, 并且将其作为其他指令操作数, 以便最大化捆绑的寄存器的数量。
-fschedule-insns: 编译器将试图重新安排指令, 以便消除等待数据的处理器。 对于在进行浮点运算时有延迟的处理器来说, 这使处理器在
等待浮点结果时可以加载其他指令。
-fsched-interblock: 这种技术使编译器能够跨越指令块调度指令。 这可以非常灵活地移动指令以便等待期间完成的工作最大化。
-fcaller-saves: 这个选项指示编译器对函数调用保存和恢复寄存器, 使函数能够访问寄存器值, 而且不必保存和恢复他们。 如果调用多个函
数, 这样能够节省时间, 因为只进行一次寄存器的保存和恢复操作, 而不是在每个函数调用中都进行。
-fpeephole2: 这个选项允许进行任何计算机特定的观察孔优化。
-freorder-blocks: 这种优化技术允许重新安排指令块以便改进分支操作和代码局部性。
-fstrict-aliasing: 这种技术强制实行高级语言的严格变量规则。 对于 c 和 c++程序来说, 它确保不在数据类型之间共享变量. 例如, 整数变
量不和单精度浮点变量使用相同的内存位置。
 -funit-at-a-time: 这种优化技术指示编译器在运行优化例程之前读取整个汇编语言代码。 这使编译器可以重新安排不消耗大量时间的代码以
 便优化指令缓存。 但是, 这会在编译时花费相当多的内存, 对于小型计算机可能是一个问题。
 -falign-functions: 这个选项用于使函数对准内存中特定边界的开始位置。 大多数处理器按照页面读取内存,并且确保全部函数代码位于单
 一内存页面内, 就不需要叫化代码所需的页面。
 -fcrossjumping: 这是对跨越跳转的转换代码处理, 以便组合分散在程序各处的相同代码。 这样可以减少代码的长度, 但是也许不会对程
 序性能有直接影响。
 3, 编译器优化级别 3
 它整合了第一和第二级别中的左右优化技巧, 还包括一下优化:
 -finline-functions: 这种优化技术不为函数创建单独的汇编语言代码, 而是把函数代码包含在调度程序的代码中。 对于多次被调用的函数
 来说, 为每次函数调用复制函数代码。 虽然这样对于减少代码长度不利, 但是通过最充分的利用指令缓存代码, 而不是在每次函数调用时进行
 分支操作, 可以提高性能。
 -fweb: 构建用于保存变量的伪寄存器网络。 伪寄存器包含数据, 就像他们是寄存器一样, 但是可以使用各种其他优化技术进行优化, 比如 cse
 和 loop 优化技术。
 -fgcse-after-reload: 这中技术在完全重新加载生成的且优化后的汇编语言代码之后执行第二次 gcse 优化,帮助消除不同优化方式创建的
 任何冗余段。
 二、Hello World!
       真不知道打破这个传统会带来什么样的后果,但既然所有程序设计语言的第一个例子都是在屏幕上打印一个字符串
  "Hello World!",那我们也以这种方式来开始介绍 Linux 下的汇编语言程序设计。
       在 Linux 操作系统中,你有很多办法可以实现在屏幕上显示一个字符串,但最简洁的方式是使用 Linux 内核提供的
  系统调用。使用这种方法最大的好处是可以直接和操作系统的内核进行通讯,不需要链接诸如 libc 这样的函数库,也不
  需要使用 ELF 解释器,因而代码尺寸小且执行速度快。
  Linux 是一个运行在保护模式下的 32 位操作系统,采用 flat memory 模式,目前最常用到的是 ELF 格式的二进制代码。
  一个 ELF 格式的可执行程序通常划分为如下几个部分:.text、.data 和 .bss,其中 .text 是只读的代码区,.data 是可读
  可写的数据区,而 .bss 则是可读可写且没有初始化的数据区。代码区和数据区在 ELF 中统称为 section,根据实际需要
  你可以使用其它标准的 section,也可以添加自定义 section,但一个 ELF 可执行程序至少应该有一个 .text 部分。 下
  面给出我们的第一个汇编程序,用的是 AT&T 汇编语言格式:
  例 1. AT&T 格式
#hello.s
.data                # 数据段声明
          msg : .string "Hello, world!\n" # 要输出的字符串
          len = . - msg              # 字串长度
.text               # 代码段声明
.global _start         # 指定入口函数
_start:              # 在屏幕上显示一个字符串
          movl $len, %edx # 参数三:字符串长度
          movl $msg, %ecx # 参数二:要显示的字符串
          movl $1, %ebx     # 参数一:文件描述符(stdout)
          movl $4, %eax     # 系统调用号(sys_write)
          int $0x80       # 调用内核功能
                               # 退出程序
          movl $0,%ebx       # 参数一:退出代码
          movl $1,%eax       # 系统调用号(sys_exit)
          int $0x80       # 调用内核功能
 初次接触到 AT&T 格式的汇编代码时,很多程序员都认为太晦涩难懂了,没有关系,在 Linux 平台上你同样可以使用
 Intel 格式来编写汇编程序:
 例 2. Intel 格式
; hello.asm
section .data          ; 数据段声明
          msg db "Hello, world!", 0xA   ; 要输出的字符串
          len equ $ - msg            ; 字串长度
section .text         ; 代码段声明
global _start         ; 指定入口函数
_start:            ; 在屏幕上显示一个字符串
          mov edx, len     ; 参数三:字符串长度
          mov ecx, msg       ; 参数二:要显示的字符串
          mov ebx, 1       ; 参数一:文件描述符(stdout)
          mov eax, 4       ; 系统调用号(sys_write)
          int 0x80       ; 调用内核功能
                               ; 退出程序
          mov ebx, 0       ; 参数一:退出代码
          mov eax, 1       ; 系统调用号(sys_exit)
          int 0x80       ; 调用内核功能
 上面两个汇编程序采用的语法虽然完全不同,但功能却都是调用 Linux 内核提供的 sys_write 来显示一个字符串,然后
 再调用 sys_exit 退出程序。在 Linux 内核源文件 include/asm-i386/unistd.h 中,可以找到所有系统调用的定义。
 三、Linux 汇编工具
 Linux 平台下的汇编工具虽然种类很多,但同 DOS/Windows 一样,最基本的仍然是汇编器、连接器和调试器。
 1.汇编器
 汇编器(assembler)的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。Linux 平台的标准汇编器是
 GAS,它是 GCC 所依赖的后台汇编工具,通常包含在 binutils 软件包中。GAS 使用标准的 AT&T 汇编语法,可以用来
 汇编用 AT&T 格式编写的程序:
[xiaowp@gary code]$ as -o hello.o hello.s
 Linux 平台上另一个经常用到的汇编器是 NASM,它提供了很好的宏指令功能,并能够支持相当多的目标代码格式,包
 括 bin、a.out、coff、elf、rdf 等。NASM 采用的是人工编写的语法分析器,因而执行速度要比 GAS 快很多,更重要的是它使
 用的是 Intel 汇编语法,可以用来编译用 Intel 语法格式编写的汇编程序:
[xiaowp@gary code]$ nasm -f elf hello.asm
 2.链接器
 由汇编器产生的目标代码是不能直接在计算机上运行的,它必须经过链接器的处理才能生成可执行代码。链接器通常用来
 将多个目标代码连接成一个可执行代码,这样可以先将整个程序分成几个模块来单独开发,然后才将它们组合(链接)成一
 个应用程序。 Linux 使用 ld 作为标准的链接程序,它同样也包含在 binutils 软件包中。汇编程序在成功通过 GAS 或
 NASM 的编译并生成目标代码后,就可以使用 ld 将其链接成可执行程序了:
[xiaowp@gary code]$ ld -s -o hello hello.o
 3.调试器
 有人说程序不是编出来而是调出来的,足见调试在软件开发中的重要作用,在用汇编语言编写程序时尤其如此。Linux 下
 调试汇编代码既可以用 GDB、DDD 这类通用的调试器,也可以使用专门用来调试汇编代码的 ALD(Assembly Language
 Debugger)。
 从调试的角度来看,使用 GAS 的好处是可以在生成的目标代码中包含符号表(symbol table),这样就可以使用 GDB 和
 DDD 来进行源码级的调试了。要在生成的可执行程序中包含符号表,可以采用下面的方式进行编译和链接:
[xiaowp@gary code]$ as --gstabs -o hello.o hello.s
[xiaowp@gary code]$ ld -o hello hello.o
 执行 as 命令时带上参数 --gstabs 可以告诉汇编器在生成的目标代码中加上符号表,同时需要注意的是,在用 ld 命令进
 行链接时不要加上 -s 参数,否则目标代码中的符号表在链接时将被删去。
 在 GDB 和 DDD 中调试汇编代码和调试 C 语言代码是一样的,你可以通过设置断点来中断程序的运行,查看变量和寄
 存器的当前值,并可以对代码进行单步跟踪。图 1 是在 DDD 中调试汇编代码时的情景:
 图 1 用 DDD 中调试汇编程序
 汇编程序员通常面对的都是一些比较苛刻的软硬件环境,短小精悍的 ALD 可能更能符合实际的需要,因此下面主要介绍
 一下如何用 ALD 来调试汇编程序。首先在命令行方式下执行 ald 命令来启动调试器,该命令的参数是将要被调试的可执行
 程序:
[xiaowp@gary doc]$ ald hello
Assembly Language Debugger 0.1.3
Copyright (C) 2000-2002 Patrick Alken
hello: ELF Intel 80386 (32 bit), LSB, Executable, Version 1 (current)
Loading debugging symbols...(15 symbols loaded)
ald>
当 ALD 的提示符出现之后,用 disassemble 命令对代码段进行反汇编:
ald> disassemble -s .text
Disassembling section .text (0x08048074 - 0x08048096)
08048074 BA0F000000                  mov edx, 0xf
08048079 B998900408                   mov ecx, 0x8049098
0804807E BB01000000                   mov ebx, 0x1
08048083 B804000000                   mov eax, 0x4
08048088 CD80                    int 0x80
0804808A BB00000000                   mov ebx, 0x0
0804808F B801000000                  mov eax, 0x1
08048094 CD80                    int 0x80
上述输出信息的第一列是指令对应的地址码,利用它可以设置在程序执行时的断点:
ald> break 0x08048088
Breakpoint 1 set for 0x08048088
断点设置好后,使用 run 命令开始执行程序。ALD 在遇到断点时将自动暂停程序的运行,同时会显示所有寄存器的当前值:
ald> run
Starting program: hello
Breakpoint 1 encountered at 0x08048088
eax = 0x00000004 ebx = 0x00000001 ecx = 0x08049098 edx = 0x0000000F
esp = 0xBFFFF6C0 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x08048088 eflags = 0x00000246
Flags: PF ZF IF
08048088 CD80                    int 0x80
如果需要对汇编代码进行单步调试,可以使用 next 命令:
ald> next
Hello, world!
eax = 0x0000000F ebx = 0x00000000 ecx = 0x08049098 edx = 0x0000000F
esp = 0xBFFFF6C0 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x0804808F eflags = 0x00000346
Flags: PF ZF TF IF
0804808F B801000000                  mov eax, 0x1
若想获得 ALD 支持的所有调试命令的详细列表,可以使用 help 命令:
ald> help
Commands may be abbreviated.
If a blank command is entered, the last command is repeated.
Type `help <command>' for more specific information on <command>.
General commands
attach        clear       continue      detach     disassemble
enter        examine        file       help     load
next         quit        register     run      set
step         unload        window        write
Breakpoint related commands
break         delete       disable      enable     ignore
lbreak        tbreak
 使用宏
 清单 3 演示本节讨论的概念;它接受用户名作为输入并返回一句问候语。
 清单 3. 读取字符串并向用户显示问候语的程序
 行号       NASM                                                 GAS
  001      section .data                                        .section .data
  002
  003           prompt_str db 'Enter your name: '                  prompt_str:
  004                                                                  .ascii "Enter Your Name: "
  005      ; $ is the location counter                             pstr_end:
  006           STR_SIZE equ $ - prompt_str                            .set STR_SIZE, pstr_end - prompt_str
  007
  008           greet_str db 'Hello '                              greet_str:
  009                                                                  .ascii "Hello "
  010
  011           GSTR_SIZE equ $ - greet_str                        gstr_end:
  012                                                                  .set GSTR_SIZE, gstr_end - greet_str
  013
  014      section .bss                                         .section .bss
  015
  016      ; Reserve 32 bytes of memory                         // Reserve 32 bytes of memory
  017           buff resb 32                                       .lcomm buff, 32
  018
  019      ; A macro with two parameters                        // A macro with two parameters
  020      ; Implements the write system call                   // implements the write system call
  021           %macro write 2                                     .macro write str, str_size
  022               mov eax, 4                                         movl $4, %eax
  023               mov ebx, 1                                         movl $1, %ebx
  024               mov ecx, %1                                        movl \str, %ecx
025         mov edx, %2                        movl \str_size, %edx
026         int 80h                            int $0x80
027     %endmacro                          .endm
028
029
030 ; Implements the read system call  // Implements the read system call
031     %macro read 2                      .macro read buff, buff_size
032         mov eax, 3                         movl $3, %eax
033         mov ebx, 0                         movl $0, %ebx
034         mov ecx, %1                        movl \buff, %ecx
035         mov edx, %2                        movl \buff_size, %edx
036         int 80h                            int $0x80
037     %endmacro                          .endm
038
039
040 section .text                      .section .text
041
042     global _start                      .globl _start
043
044     _start:                            _start:
045         write prompt_str, STR_SIZE         write $prompt_str, $STR_SIZE
046         read buff, 32                      read $buff, $32
047
048 ; Read returns the length in eax   // Read returns the length in eax
049         push eax                           pushl %eax
050
051 ; Print the hello text             // Print the hello text
052         write greet_str, GSTR_SIZE         write $greet_str, $GSTR_SIZE
053
054         pop edx                            popl %edx
055
056 ; edx = length returned by read    // edx = length returned by read
057         write buff, edx                write $buff, %edx
058
059     _exit:                             _exit:
060         mov eax, 1                         movl $1, %eax
061         mov ebx, 0                         movl $0, %ebx
062         int 80h                            int $0x80
本节要讨论宏以及 NASM 和 GAS 对它们的支持。但是,在讨论宏之前,先与其他几个特性做一下比较。
清单 3 演示了未初始化内存的概念,这是用 .bss 部分指令(第 14 行)定义的。BSS 代表 “block storage segment”
(原来是以一个符号开头的块),BSS 部分中保留的内存在程序启动时初始化为零。BSS 部分中的对象只有一个名称和
大小,没有值。与数据部分中不同,BSS 部分中声明的变量并不实际占用空间。
NASM 使用 resb、resw 和 resd 关键字在 BSS 部分中分配字节、字和双字空间。GAS 使用 .lcomm 关键字分配字
节级空间。请注意在这个程序的两个版本中声明变量名的方式。在 NASM 中,变量名前面加 resb(或 resw
或 resd)关键字,后面是要保留的空间量;在 GAS 中,变量名放在 .lcomm 关键字的后面,然后是一个逗号和要
保留的空间量。
NASM:varname resb size
GAS:.lcomm varname, size
清单 3 还演示了位置计数器的概念(第 6 行)。 NASM 提供特殊的变量($ 和 $$ 变量)来操作位置计数器。在 GAS
中,无法操作位置计数器,必须使用标签计算下一个存储位置(数据、指令等等)。
例如,为了计算一个字符串的长度,在 NASM 中会使用以下指令:
prompt_str db 'Enter your name: '
STR_SIZE equ $ - prompt_str      ; $ is the location counter
$ 提供位置计数器的当前值,从这个位置计数器中减去标签的值(所有变量名都是标签),就会得出标签的声明和当前位
置之间的字节数。equ 用来将变量 STR_SIZE 的值设置为后面的表达式。GAS 中使用的相似指令如下:
prompt_str:
      .ascii "Enter Your Name: "
pstr_end:
      .set STR_SIZE, pstr_end - prompt_str
末尾标签(pstr_end)给出下一个位置地址,减去启始标签地址就得出大小。还要注意,这里使用 .set 将变量
STR_SIZE 的值设置为逗号后面的表达式。也可以使用对应的 .equ。在 NASM 中,没有与 GAS 的 set 指令对应的指
令。
正如前面提到的,清单 3 使用了宏(第 21 行)。在 NASM 和 GAS 中存在不同的宏技术,包括单行宏和宏重载,但是
这里只关注基本类型。宏在汇编程序中的一个常见用途是提高代码的清晰度。通过创建可重用的宏,可以避免重复输入相
同的代码段;这不但可以避免重复,而且可以减少代码量,从而提高代码的可读性。
NASM 使用 %beginmacro 指令声明宏,用 %endmacro 指令结束声明。%beginmacro 指令后面是宏的名称。宏
名称后面是一个数字,这是这个宏需要的宏参数数量。在 NASM 中,宏参数是从 1 开始连续编号的。也就是说,宏的第
一个参数是 %1,第二个是 %2,第三个是 %3,以此类推。例如:
%beginmacro macroname 2
      mov eax, %1
      mov ebx, %2
%endmacro
这创建一个有两个参数的宏,第一个参数是 %1,第二个参数是 %2。因此,对上面的宏的调用如下所示:
macroname 5, 6
还可以创建没有参数的宏,在这种情况下不指定任何数字。
现在看看 GAS 如何使用宏。GAS 提供 .macro 和 .endm 指令来创建宏。.macro 指令后面跟着宏名称,后面可以有
参数,也可以没有参数。在 GAS 中,宏参数是按名称指定的。例如:
.macro macroname arg1, arg2
      movl \arg1, %eax
      movl \arg2, %ebx
.endm
当在宏中使用宏参数名称时,在名称前面加上一个反斜线。如果不这么做,链接器会把名称当作标签而不是参数,因此会
报告错误。
                                                                                      回页首
函数、外部例程和堆栈
本节的示例程序在一个整数数组上实现选择排序。
清单 4. 在整数数组上实现选择排序
行号   NASM                                  GAS
001   section .data                         .section .data
002
003      array db                              array:
004          89, 10, 67, 1, 4, 27, 12, 34,         .byte 89, 10, 67, 1, 4, 27, 12,
005              86, 3                                     34, 86, 3
006
007      ARRAY_SIZE equ $ - array              array_end:
008                                                .equ ARRAY_SIZE, array_end - array
009
010      array_fmt db " %d", 0                 array_fmt:
011                                                .asciz " %d"
012
013      usort_str db "unsorted array:", 0     usort_str:
014                                                .asciz "unsorted array:"
015
016      sort_str db "sorted array:", 0        sort_str:
017                                                .asciz "sorted array:"
018
019      newline db 10, 0                      newline:
020                                                .asciz "\n"
021
022
023   section .text                         .section .text
024      extern puts
025
026      global _start                         .globl _start
027
028      _start:                               _start:
029
030          push usort_str                        pushl $usort_str
031          call puts                             call puts
032          add esp, 4                            addl $4, %esp
033
034          push ARRAY_SIZE                       pushl $ARRAY_SIZE
035         push array                      pushl $array
036         push array_fmt                  pushl $array_fmt
037         call print_array10              call print_array10
038         add esp, 12                     addl $12, %esp
039
040         push ARRAY_SIZE                 pushl $ARRAY_SIZE
041         push array                      pushl $array
042         call sort_routine20             call sort_routine20
043
044 ; Adjust the stack pointer       # Adjust the stack pointer
045         add esp, 8                      addl $8, %esp
046
047         push sort_str                   pushl $sort_str
048         call puts                       call puts
049         add esp, 4                      addl $4, %esp
050
051         push ARRAY_SIZE                 pushl $ARRAY_SIZE
052         push array                      pushl $array
053         push array_fmt                  pushl $array_fmt
054         call print_array10              call print_array10
055         add esp, 12                     addl $12, %esp
056         jmp _exit                       jmp _exit
057
058         extern printf
059
060     print_array10:                  print_array10:
061         push ebp                        pushl %ebp
062         mov ebp, esp                    movl %esp, %ebp
063         sub esp, 4                      subl $4, %esp
064         mov edx, [ebp + 8]              movl 8(%ebp), %edx
065         mov ebx, [ebp + 12]             movl 12(%ebp), %ebx
066         mov ecx, [ebp + 16]             movl 16(%ebp), %ecx
067
068         mov esi, 0                      movl $0, %esi
069
070     push_loop:                      push_loop:
071         mov [ebp - 4], ecx              movl %ecx, -4(%ebp)
072         mov edx, [ebp + 8]              movl 8(%ebp), %edx
073         xor eax, eax                    xorl %eax, %eax
074         mov al, byte [ebx + esi]        movb (%ebx, %esi, 1), %al
075         push eax                        pushl %eax
076         push edx                        pushl %edx
077
078         call printf                        call printf
079         add esp, 8                         addl $8, %esp
080         mov ecx, [ebp - 4]                 movl -4(%ebp), %ecx
081         inc esi                            incl %esi
082         loop push_loop                     loop push_loop
083
084         push newline                       pushl $newline
085         call printf                        call printf
086         add esp, 4                         addl $4, %esp
087         mov esp, ebp                       movl %ebp, %esp
088         pop ebp                            popl %ebp
089         ret                                ret
090
091     sort_routine20:                    sort_routine20:
092         push ebp                           pushl %ebp
093         mov ebp, esp                       movl %esp, %ebp
094
095 ; Allocate a word of space in stack # Allocate a word of space in stack
096         sub esp, 4                         subl $4, %esp
097
098 ; Get the address of the array      # Get the address of the array
099         mov ebx, [ebp + 8]                 movl 8(%ebp), %ebx
100
101 ; Store array size                  # Store array size
102         mov ecx, [ebp + 12]                movl 12(%ebp), %ecx
103         dec ecx                            decl %ecx
104
105 ; Prepare for outer loop here       # Prepare for outer loop here
106         xor esi, esi                       xorl %esi, %esi
107
108     outer_loop:                        outer_loop:
109 ; This stores the min index         # This stores the min index
110         mov [ebp - 4], esi                 movl %esi, -4(%ebp)
111         mov edi, esi                       movl %esi, %edi
112         inc edi                            incl %edi
113
114     inner_loop:                        inner_loop:
115         cmp edi, ARRAY_SIZE                cmpl $ARRAY_SIZE, %edi
116         jge swap_vars                      jge swap_vars
117         xor al, al                         xorb %al, %al
118         mov edx, [ebp - 4]                 movl -4(%ebp), %edx
119       mov al, byte [ebx + edx]    movb (%ebx, %edx, 1), %al
120       cmp byte [ebx + edi], al    cmpb %al, (%ebx, %edi, 1)
121       jge check_next              jge check_next
122       mov [ebp - 4], edi          movl %edi, -4(%ebp)
123
124    check_next:                 check_next:
125       inc edi                     incl %edi
126       jmp inner_loop              jmp inner_loop
127
128    swap_vars:                  swap_vars:
129       mov edi, [ebp - 4]          movl -4(%ebp), %edi
130       mov dl, byte [ebx + edi]    movb (%ebx, %edi, 1), %dl
131       mov al, byte [ebx + esi]    movb (%ebx, %esi, 1), %al
132       mov byte [ebx + esi], dl    movb %dl, (%ebx, %esi, 1)
133       mov byte [ebx + edi], al    movb %al, (%ebx, %edi, 1)
134
135       inc esi                     incl %esi
136       loop outer_loop             loop outer_loop
137
138       mov esp, ebp                movl %ebp, %esp
139       pop ebp                     popl %ebp
140       ret                         ret
141
142    _exit:                      _exit:
143       mov eax, 1                  movl $1, %eax
144       mov ebx, 0                  movl 0, %ebx
145       int 80h                     int $0x80
初看起来清单 4 似乎非常复杂,实际上它是非常简单的。这个清单演示了函数、各种内存寻址方案、堆栈和库函数的使用方
法。这个程序对包含 10 个数字的数组进行排序,并使用外部 C 库函数 puts 和 printf 输出未排序数组和已排序数
组的完整内容。为了实现模块化和介绍函数的概念,排序例程本身实现为一个单独的过程,数组输出例程也是这样。我们
来逐一分析一下。
在声明数据之后,这个程序首先执行对 puts 的调用(第 31 行)。puts 函数在控制台上显示一个字符串。它惟一的参
数是要显示的字符串的地址,通过将字符串的地址压入堆栈(第 30 行),将这个参数传递给它。
在 NASM 中,任何不属于我们的程序但是需要在链接时解析的标签都必须预先定义,这就是 extern 关键字的作用
(第 24 行)。GAS 没有这样的要求。在此之后,字符串的地址 usort_str 被压入堆栈(第 30 行)。在 NASM 中,
内存变量(比如 usort_str)代表内存位置本身,所以 push usort_str 这样的调用实际上是将地址压入堆栈
的顶部。但是在 GAS 中,变量 usort_str 必须加上前缀$,这样它才会被当作地址。如果不加前缀 $,那么会将内存
变量代表的实际字节压入堆栈,而不是地址。
因为在堆栈中压入一个变量会让堆栈指针移动一个双字,所以给堆栈指针加 4(双字的大小)(第 32 行)。
现在将三个参数压入堆栈,并调用 print_array10 函数(第 37 行)。在 NASM 和 GAS 中声明函数的方法是相同
的。它们仅仅是通过 call 指令调用的标签。
在调用函数之后,ESP 代表堆栈的顶部。esp + 4 代表返回地址,esp + 8 代表函数的第一个参数。在堆栈指针上加
上双字变量的大小(即 esp + 12、esp + 16 等等),就可以访问所有后续参数。
在函数内部,通过将 esp 复制到 ebp (第 62 行)创建一个局部堆栈框架。和程序中的处理一样,还可以为局部变量
分配空间(第 63 行)。方法是从 esp 中减去所需的字节数。esp – 4 表示为一个局部变量分配 4 字节的空间,只要
堆栈中有足够的空间容纳局部变量,就可以继续分配。
清单 4 演示了基间接寻址模式(第 64 行),也就是首先取得一个基地址,然后在它上面加一个偏移量,从而到达最终
的地址。在清单的 NASM 部分中,[ebp + 8] 和 [ebp – 4](第 71 行)就是基间接寻址模式的示例。在 GAS 中,
寻址方法更简单一些:4(%ebp)和 -4(%ebp)。
在 print_array10 例程中,在 push_loop 标签后面可以看到另一种寻址模式(第 74 行)。在 NASM 和 GAS
中的表示方法如下:
NASM:mov al, byte [ebx + esi]
GAS:movb (%ebx, %esi, 1), %al
这种寻址模式称为基索引寻址模式。这里有三项数据:一个是基地址,第二个是索引寄存器,第三个是乘数。因为不可能
决定从一个内存位置开始访问的字节数,所以需要用一个方法计算访问的内存量。NASM 使用字节操作符告诉汇编器要移
动一个字节的数据。在 GAS 中,用一个乘数和助记符中的 b、w 或 l 后缀(例如 movb)来解决这个问题。初看上去
GAS 的语法似乎有点儿复杂。
GAS 中基索引寻址模式的一般形式如下:
%segment:ADDRESS (, index, multiplier)
或
%segment:(offset, index, multiplier)
或
%segment:ADDRESS(base, index, multiplier)
使用这个公式计算最终的地址:
ADDRESS or offset + base + index * multiplier.
因此,要想访问一个字节,就使用乘数 1;对于字,乘数是 2;对于双字,乘数是 4。当然,NASM 使用的语法比较简单。
上面的公式在 NASM 中表示为:
Segment:[ADDRESS or offset + index * multiplier]
为了访问 1、2 或 4 字节的内存,在这个内存地址前面分别加上 byte、word 或 dword。
其他方面
清单 5 读取命令行参数的列表,将它们存储在内存中,然后输出它们。
清单 5. 读取命令行参数,将它们存储在内存中,然后输出它们
行号    NASM                              GAS
 001   section .data                     .section .data
 002
 003   ; Command table to store at most  // Command table to store at most
 004   ; 10 command line arguments       // 10 command line arguments
 005       cmd_tbl:                         cmd_tbl:
 006          %rep 10                           .rept 10
 007              dd 0                              .long 0
 008          %endrep                           .endr
 009
 010   section .text                     .section .text
011
012     global _start                        .globl _start
013
014     _start:                              _start:
015 ; Set up the stack frame              // Set up the stack frame
016          mov ebp, esp                        movl %esp, %ebp
017 ; Top of stack contains the           // Top of stack contains the
018 ; number of command line arguments.   // number of command line arguments.
019 ; The default value is 1              // The default value is 1
020          mov ecx, [ebp]                      movl (%ebp), %ecx
021
022 ; Exit if arguments are more than 10  // Exit if arguments are more than 10
023          cmp ecx, 10                         cmpl $10, %ecx
024          jg   _exit                          jg    _exit
025
026          mov esi, 1                          movl $1, %esi
027          mov edi, 0                          movl $0, %edi
028
029 ; Store the command line arguments    // Store the command line arguments
030 ; in the command table                // in the command table
031     store_loop:                          store_loop:
032          mov eax, [ebp + esi * 4]            movl (%ebp, %esi, 4), %eax
033          mov [cmd_tbl + edi * 4], eax        movl %eax, cmd_tbl( , %edi, 4)
034          inc esi                             incl %esi
035          inc edi                             incl %edi
036          loop store_loop                     loop store_loop
037
038          mov ecx, edi                        movl %edi, %ecx
039          mov esi, 0                          movl $0, %esi
040
041          extern puts
042
043     print_loop:                          print_loop:
044 ; Make some local space               // Make some local space
045          sub esp, 4                          subl $4, %esp
046 ; puts function corrupts ecx          // puts functions corrupts ecx
047          mov [ebp - 4], ecx                  movl %ecx, -4(%ebp)
048          mov eax, [cmd_tbl + esi * 4]        movl cmd_tbl( , %esi, 4), %eax
049          push eax                            pushl %eax
050          call puts                           call puts
051          add esp, 4                          addl $4, %esp
052          mov ecx, [ebp - 4]                  movl -4(%ebp), %ecx
 053       inc esi                   incl %esi
 054       loop print_loop           loop print_loop
 055
 056       jmp _exit                 jmp _exit
 057
 058    _exit:                    _exit:
 059       mov eax, 1                movl $1, %eax
 060       mov ebx, 0                movl $0, %ebx
 061       int 80h                   int $0x80
清单 5 演示在汇编程序中重复执行指令的方法。很自然,这种结构称为重复结构。在 GAS 中,重复结构以 .rept 指令
开头(第 6 行)。用一个 .endr 指令结束这个指令(第 8 行)。.rept 后面是一个数字,它指定 .rept/.endr 结
构中表达式重复执行的次数。这个结构中的任何指令都相当于编写这个指令 count 次,每次重复占据单独的一行。
例如,如果次数是 3:
.rept 3
     movl $2, %eax
.endr
就相当于:
movl $2, %eax
movl $2, %eax
movl $2, %eax
在 NASM 中,在预处理器级使用相似的结构。它以 %rep 指令开头,以 %endrep 结尾。%rep 指令后面是一个表达式
(在 GAS 中 .rept 指令后面是一个数字):
%rep <expression>
     nop
%endrep
在 NASM 中还有另一种结构,times 指令。与 %rep 相似,它也在汇编级起作用,后面也是一个表达式。例如,上面
的 %rep 结构相当于:
times <expression> nop
以下代码:
%rep 3
     mov eax, 2
%endrep
相当于:
times 3 mov eax, 2
它们都相当于:
mov eax, 2
mov eax, 2
mov eax, 2
在清单 5 中,使用 .rept(或 %rep)指令为 10 个双字创建内存数据区。然后,从堆栈一个个地访问命令行参数,并
将它们存储在内存区中,直到命令表填满。
在这两种汇编器中,访问命令行参数的方法是相似的。ESP(堆栈顶部)存储传递给程序的命令行参数数量,默认值是
1(表示没有命令行参数)。esp + 4 存储第一个命令行参数,这总是从命令行调用的程序的名称。esp + 8、esp +
12 等存储后续命令行参数。
还要注意清单 5 中从两边访问内存命令表的方法。这里使用内存间接寻址模式(第 31 行)访问命令表,还使用了 ESI
(和 EDI)中的偏移量和一个乘数。因此,NASM 中的 [cmd_tbl + esi * 4] 相当于 GAS 中的 cmd_tbl(,
%esi, 4)。
四、系统调用
即便是最简单的汇编程序,也难免要用到诸如输入、输出以及退出等操作,而要进行这些操作则需要调用操作系统所提供
的服务,也就是系统调用。除非你的程序只完成加减乘除等数学运算,否则将很难避免使用系统调用,事实上除了系统调
用不同之外,各种操作系统的汇编编程往往都是很类似的。
在 Linux 平台下有两种方式来使用系统调用:利用封装后的 C 库(libc)或者通过汇编直接调用。其中通过汇编语言来直
接调用系统调用,是最高效地使用 Linux 内核服务的方法,因为最终生成的程序不需要与任何库进行链接,而是直接和
内核通信。
和 DOS 一样,Linux 下的系统调用也是通过中断(int 0x80)来实现的。在执行 int 80 指令时,寄存器 eax 中存放的是
系统调用的功能号,而传给系统调用的参数则必须按顺序放到寄存器 ebx,ecx,edx,esi,edi 中,当系统调用完成之
后,返回值可以在寄存器 eax 中获得。
所有的系统调用功能号都可以在文件 /usr/include/bits/syscall.h 中找到,为了便于使用,它们是用 SYS_<name> 这样的
宏来定义的,如 SYS_write、SYS_exit 等。例如,经常用到的 write 函数是如下定义的:
ssize_t write(int fd, const void *buf, size_t count);
该函数的功能最终是通过 SYS_write 这一系统调用来实现的。根据上面的约定,参数 fb、buf 和 count 分别存在寄存器
ebx、ecx 和 edx 中,而系统调用号 SYS_write 则放在寄存器 eax 中,当 int 0x80 指令执行完毕后,返回值可以从寄存
器 eax 中获得。
或许你已经发现,在进行系统调用时至多只有 5 个寄存器能够用来保存参数,难道所有系统调用的参数个数都不超过 5
吗?当然不是,例如 mmap 函数就有 6 个参数,这些参数最后都需要传递给系统调用 SYS_mmap:
void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
当一个系统调用所需的参数个数大于 5 时,执行 int 0x80 指令时仍需将系统调用功能号保存在寄存器 eax 中,所不同的
只是全部参数应该依次放在一块连续的内存区域里,同时在寄存器 ebx 中保存指向该内存区域的指针。系统调用完成之后,
返回值仍将保存在寄存器 eax 中。
由于只是需要一块连续的内存区域来保存系统调用的参数,因此完全可以像普通的函数调用一样使用栈(stack)来传递系
统调用所需的参数。但要注意一点,Linux 采用的是 C 语言的调用模式,这就意味着所有参数必须以相反的顺序进栈,即
最后一个参数先入栈,而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数,在执行 int 0x80 指令时还应该
将栈指针的当前值复制到寄存器 ebx 中。
五、命令行参数
在 Linux 操作系统中,当一个可执行程序通过命令行启动时,其所需的参数将被保存到栈中:首先是 argc,然后是指向
各个命令行参数的指针数组 argv,最后是指向环境变量的指针数据 envp。在编写汇编语言程序时,很多时候需要对这些
参数进行处理,下面的代码示范了如何在汇编代码中进行命令行参数的处理:
例 3. 处理命令行参数
# args.s
.text
.globl _start
_start:
          popl           %ecx                # argc
vnext:
          popl           %ecx                # argv
          test           %ecx, %ecx    # 空指针表明结束
          jz exit
          movl           %ecx, %ebx
          xorl           %edx, %edx
strlen:
          movb           (%ebx), %al
          inc %edx
          inc %ebx
          test           %al, %al
          jnz strlen
          movb           $10, -1(%ebx)
          movl           $4, %eax      # 系统调用号(sys_write)
          movl           $1, %ebx      # 文件描述符(stdout)
          int $0x80
          jmp            vnext
exit:
          movl           $1,%eax       # 系统调用号(sys_exit)
          xorl           %ebx, %ebx     # 退出代码
          int            $0x80
          ret
 六、GCC 内联汇编
 用汇编编写的程序虽然运行速度快,但开发速度非常慢,效率也很低。如果只是想对关键代码段进行优化,或许更好的办
 法是将汇编指令嵌入到 C 语言程序中,从而充分利用高级语言和汇编语言各自的特点。但一般来讲,在 C 代码中嵌入汇
 编语句要比"纯粹"的汇编语言代码复杂得多,因为需要解决如何分配寄存器,以及如何与 C 代码中的变量相结合等问题。
 GCC 提供了很好的内联汇编支持,最基本的格式是:
__asm__("asm statements");
 例如:
__asm__("nop");
 如果需要同时执行多条汇编语句,则应该用"\\n\\t"将各个语句分隔开,例如:
__asm__( "pushl %%eax \\n\\t"
            "movl $0, %%eax \\n\\t"
            "popl %eax");
 通常嵌入到 C 代码中的汇编语句很难做到与其它部分没有任何关系,因此更多时候需要用到完整的内联汇编格式:
__asm__("asm statements" : outputs : inputs : registers-modified);
 插入到 C 代码中的汇编语句是以":"分隔的四个部分,其中第一部分就是汇编代码本身,通常称为指令部,其格式和在汇
 编语言中使用的格式基本相同。指令部分是必须的,而其它部分则可以根据实际情况而省略。
 在将汇编语句嵌入到 C 代码中时,操作数如何与 C 代码中的变量相结合是个很大的问题。GCC 采用如下方法来解决这个
 问题:程序员提供具体的指令,而对寄存器的使用则只需给出"样板"和约束条件就可以了,具体如何将寄存器与变量结合
 起来完全由 GCC 和 GAS 来负责。
 在 GCC 内联汇编语句的指令部中,加上前缀'%'的数字(如%0,%1)表示的就是需要使用寄存器的"样板"操作数。指令部中
 使用了几个样板操作数,就表明有几个变量需要与寄存器相结合,这样 GCC 和 GAS 在编译和汇编时会根据后面给定的
 约束条件进行恰当的处理。由于样板操作数也使用'%'作为前缀,因此在涉及到具体的寄存器时,寄存器名前面应该加上两
 个'%',以免产生混淆。
 紧跟在指令部后面的是输出部,是规定输出变量如何与样板操作数进行结合的条件,每个条件称为一个"约束",必要时可
 以包含多个约束,相互之间用逗号分隔开就可以了。每个输出约束都以'='号开始,然后紧跟一个对操作数类型进行说明的
 字后,最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身,在执行完嵌入的汇
 编代码后均不保留执行之前的内容,这是 GCC 在调度寄存器时所使用的依据。
 输出部后面是输入部,输入约束的格式和输出约束相似,但不带'='号。如果一个输入约束要求使用寄存器,则 GCC 在预
 处理时就会为之分配一个寄存器,并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结合的寄存器或操
 作数本身,在执行完嵌入的汇编代码后也不保留执行之前的内容。
 有时在进行某些操作时,除了要用到进行数据输入和输出的寄存器外,还要使用多个寄存器来保存中间计算结果,这样
 就难免会破坏原有寄存器的内容。在 GCC 内联汇编格式中的最后一个部分中,可以对将产生副作用的寄存器进行说明,
 以便 GCC 能够采用相应的措施。
 下面是一个内联汇编的简单例子:
 例 4.内联汇编
/* inline.c */
int main()
{
     int a = 10, b = 0;
     __asm__ __volatile__("movl %1, %%eax;\\n\\r"
                             "movl %%eax, %0;"
                             :"=r"(b)    /* 输出 */
                             :"r"(a)    /* 输入 */
                             :"%eax");    /* 不受影响的寄存器 */
     printf("Result: %d, %d\\n", a, b);
}
 上面的程序完成将变量 a 的值赋予变量 b,有几点需要说明:
      • 变量 b 是输出操作数,通过%0 来引用,而变量 a 是输入操作数,通过%1 来引用。
      • 输入操作数和输出操作数都使用 r 进行约束,表示将变量 a 和变量 b 存储在寄存器中。输入约束和输出约束的不同
           点在于输出约束多一个约束修饰符'='。
     •   在内联汇编语句中使用寄存器 eax 时,寄存器名前应该加两个'%',即%%eax。内联汇编中使用%0、%1 等来标识
         变量,任何只带一个'%'的标识符都看成是操作数,而不是寄存器。
     • 内联汇编语句的最后一个部分告诉 GCC 它将改变寄存器 eax 中的值,GCC 在处理时不应使用该寄存器来存储任
         何其它的值。
     • 由于变量 b 被指定成输出操作数,当内联汇编语句执行完毕后,它所保存的值将被更新。
  在内联汇编中用到的操作数从输出部的第一个约束开始编号,序号从 0 开始,每个约束记数一次,指令部要引用这些操作
  数时,只需在序号前加上'%'作为前缀就可以了。需要注意的是,内联汇编语句的指令部在引用一个操作数时总是将其作为
  32 位的长字使用,但实际情况可能需要的是字或字节,因此应该在约束中指明正确的限定符:
                     限定符                                       意义
"m"、"v"、"o"                                内存单元
"r"                                        任何寄存器
"q"                                        寄存器 eax、ebx、ecx、edx 之一
"i"、"h"                                    直接操作数
"E"和"F"                                    浮点数
"g"                                        任意
"a"、"b"、"c"、"d"                            分别表示寄存器 eax、ebx、ecx 和 edx
"S"和"D"                                    寄存器 esi、edi
"I"                                        常数(0 至 31)
  Linux 中 x86 的内联汇编
  GCC 为内联汇编提供特殊结构,它具有以下格式:
  GCG 的 "asm" 结构
     asm ( assembler template
  : output operands             (optional)
  : input operands              (optional)
  : list of clobbered registers
       (optional)
  );
  本例中,汇编程序模板由汇编指令组成。输入操作数是充当指令输入操作数使用的 C 表达式。输出操作数是将对其执行汇编指令输出的 C 表
  达式。
  内联汇编的重要性体现在它能够灵活操作,而且可以使其输出通过 C 变量显示出来。因为它具有这种能力,所以 "asm" 可以用作汇编指令
  和包含它的 C 程序之间的接口。
  一个非常基本但很重要的区别在于 简单内联汇编只包括指令,而 扩展内联汇编包括操作数。要说明这一点,考虑以下示例:
  内联汇编的基本要素
{
    int a=10, b;
    asm ("movl %1, %%eax;
movl %%eax, %0;"
          :"=r"(b) /* output */
          :"r"(a)       /* input */
          :"%eax"); /* clobbered register */
}
在上例中,我们使用汇编指令使 "b" 的值等于 "a"。请注意以下几点:
     • "b" 是输出操作数,由 %0 引用,"a" 是输入操作数,由 %1 引用。
     • "r" 是操作数的约束,它指定将变量 "a" 和 "b" 存储在寄存器中。请注意,输出操作数约束应该带有一个约束修饰符 "=",指定它
          是输出操作数。
     • 要在 "asm" 内使用寄存器 %eax,%eax 的前面应该再加一个 %,换句话说就%%eax,因为 "asm" 使用 %0、%1 等来标识
          变量。任何带有一个 % 的数都看作是输入/输出操作数,而不认为是寄存器。
     • 第三个冒号后的修饰寄存器 %eax 告诉将在 "asm" 中修改 GCC %eax 的值,这样 GCC 就不使用该寄存器存储任何其它的值。
     • movl  %1, %%eax 将 "a" 的值移到 %eax 中,  movl %%eax, %0 将 %eax 的内容移到 "b" 中。因为 "b" 被指定成输出
          操作数,因此当 "asm" 的执行完成后,它将反映出更新的值。换句话说,对 "asm" 内 "b" 所做的更改将在 "asm" 外反映出来。
现在让我们更详细的了解每一项的含义。
汇编程序模板
汇编程序模板是一组插入到 C 程序中的汇编指令(可以是单个指令,也可以是一组指令)。每条指令都应该由双引号括起,或者整组指令应
该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为新行 (\n) 和分号 (;)。 '\n' 后可以跟一个 tab(\t) 作为格式化符号,
增加 GCC 在汇编文件中生成的指令的可读性。 指令通过数 %0、%1 等来引用 C 表达式(指定为操作数)。
如果希望确保编译器不会在 "asm" 内部优化指令,可以在 "asm" 后使用关键字 "volatile"。如果程序必须与 ANSI C 兼容,则应该使用
__asm__ 和 __volatile__,而不是 asm 和 volatile。
操作数
C 表达式用作 "asm" 内的汇编指令操作数。在汇编指令通过对 C 程序的 C 表达式进行操作来执行有意义的作业的情况下,操作数是内联汇
编的主要特性。
每个操作数都由操作数约束字符串指定,后面跟用括弧括起的 C 表达式,例如:"constraint" (C expression)。操作数约束的主要功能是确
定操作数的寻址方式。
可以在输入和输出部分中同时使用多个操作数。每个操作数由逗号分隔开。
在汇编程序模板内部,操作数由数字引用。如果总共有 n 个操作数(包括输入和输出),那么第一个输出操作数的编号为 0,逐项递增,最
后那个输入操作数的编号为 n -1。总操作数的数目限制在 10,如果机器描述中任何指令模式中的最大操作数数目大于 10,则使用后者作为
限制。
修饰寄存器列表
如果 "asm" 中的指令指的是硬件寄存器,可以告诉 GCC 我们将自己使用和修改它们。这样,GCC 就不会假设它装入到这些寄存器中的值
是有效值。通常不需要将输入和输出寄存器列为 clobbered,因为 GCC 知道 "asm" 使用它们(因为
它们被明确指定为约束)。不过,如果指令使用任何其它的寄存器,无论是明确的还是隐含的(,也不在输出约束列表中出现),寄存器都必
须被指定为修饰列表。修饰寄存器列在第三个冒号之后,其名称被指定为字符串。
至于关键字,如果指令以某些不可预知且不明确的方式修改了内存,则可能将 "memory" 关键字添加到修饰寄存器表中。这样就告诉 GCC
不要在不同指令之间将内存值高速缓存在寄存器中。
操作数约束
前面提到过,"asm" 中的每个操作数都应该由操作数约束字符串描述,后面跟用括弧括起的 C 表达式。操作数约束
主要是确定指令中操作数的寻址方式。约束也可以指定:
     • 是否允许操作数位于寄存器中,以及它可以包括在哪些种类的寄存器中
     • 操作数是否可以是内存引用,以及在这种情况下使用哪些种类的地址
     • 操作数是否可以是立即数
约束还要求两个操作数匹配。
常用约束
在可用的操作数约束中,只有一小部分是常用的;下面列出了这些约束以及简要描述。有关操作数约束的完整列表,请参考 GCC 和 GAS 手
册。
寄存器操作数约束 (r)
使用这种约束指定操作数时,它们存储在通用寄存器中。请看下例:
asm ("movl %%cr3, %0\n" :"=r"(cr3val));
这里,变量 cr3val 保存在寄存器中,%cr3 的值复制到寄存器上,cr3val 的值从该寄存器更新到内存中。
指定 "r" 约束时,GCC 可以将变量 cr3val 保存在任何可用的 GPR 中。要指定寄存器,必须通过使用特定的寄存器约束直接指定寄存器名。
a   %eax
b   %ebx
c   %ecx
d   %edx
S   %esi
D   %edi
内存操作数约束 (m)
当操作数位于内存中时,任何对它们执行的操作都将在内存位置中直接发生,这与寄存器约束正好相反,后者先将值存储在要修改的寄存器
中,然后将它写回内存位置中。但寄存器约束通常只在对于指令来说它们是绝对必需的,或者它们可以大大提高进程速度时使用。当需要在
"asm" 内部更新 C 变量,而您又确实不希望使用寄存器来保存其值时,使用内存约束最为有效。例如,idtr 的值存储在内存位置 loc 中:
  ("sidt %0\n" : :"m"(loc));
匹配(数字)约束
在某些情况下,一个变量既要充当输入操作数,也要充当输出操作数。可以通过使用匹配约束在 "asm" 中指定这种情况。
asm ("incl %0" :"=a"(var):"0"(var));
在匹配约束的示例中,寄存器 %eax 既用作输入变量,也用作输出变量。将 var 输入读取到 %eax,增加后将更新的 %eax 再次存储在
var 中。这里的 "0" 指定第 0 个输出变量相同的约束。即,它指定 var 的输出实例只应该存储在 %eax 中。该约束可以用于以下情况:
      • 输入从变量中读取,或者变量被修改后,修改写回到同一变量中
      • 不需要将输入操作数和输出操作数的实例分开
使用匹配约束最重要的意义在于它们可以导致有效地使用可用寄存器。
一般内联汇编用法示例
以下示例通过各种不同的操作数约束说明了用法。有如此多的约束以至于无法将它们一一列出,这里只列出了最经常使用的那些约束类型。
"asm" 和寄存器约束 "r" 让我们先看一下使用寄存器约束 r 的 "asm"。我们的示例显示了 GCC 如
何分配寄存器,以及它如何更新输出变量的值。
int main(void)
{
     int x = 10, y;
     asm ("movl %1, %%eax;
  "movl %%eax, %0;"
         :"=r"(y) /* y is output operand */
         :"r"(x)       /* x is input operand */
         :"%eax"); /* %eax is clobbered register */
}
在该例中,x 的值复制为 "asm" 中的 y。x 和 y 都通过存储在寄存器中传递给 "asm"。为该例生成的汇编代码如下:
main:
pushl %ebp
movl %esp,%ebp
subl $8,%esp
movl $10,-4(%ebp)
movl -4(%ebp),%edx /* x=10 is stored in %edx */
#APP     /* asm starts here */
movl %edx, %eax      /* x is moved to %eax */
movl %eax, %edx      /* y is allocated in edx and updated */
#NO_APP /* asm ends here */
movl %edx,-8(%ebp) /* value of y in stack is updated with
  the value in %edx */
当使用 "r" 约束时,GCC 在这里可以自由分配任何寄存器。在我们的示例中,它选择 %edx 来存储 x。在读取了 %edx 中 x 的值后,它为
y 也分配了相同的寄存器。
因为 y 是在输出操作数部分中指定的,所以 %edx 中更新的值存储在 -8(%ebp),堆栈上 y 的位置中。如果 y 是在输入部分中指定的,
那么即使它在 y 的临时寄存器存储值 (%edx) 中被更新,堆栈上 y 的值也不会更新。
因为 %eax 是在修饰列表中指定的,GCC 不在任何其它地方使用它来存储数据。
输入 x 和输出 y 都分配在同一个 %edx 寄存器中,假设输入在输出产生之前被消耗。请注意,如果您有许多指令,就不是这种情况了。要确
保输入和输出分配到不同的寄存器中,可以指定 & 约束修饰符。
下面是添加了约束修饰符的示例。
int main(void)
{
     int x = 10, y;
     asm ("movl %1, %%eax;
  "movl %%eax, %0;"
         :"=&r"(y) /* y is output operand, note the
  & constraint modifier. */
         :"r"(x)       /* x is input operand */
         :"%eax"); /* %eax is clobbered register */
}
以下是为该示例生成的汇编代码,从中可以明显地看出 x 和 y 存储在 "asm" 中不同的寄存器中。
main:
pushl %ebp
movl %esp,%ebp
subl $8,%esp
movl $10,-4(%ebp)
movl -4(%ebp),%ecx /* x, the input is in %ecx */
#APP
     movl %ecx, %eax
     movl %eax, %edx    /* y, the output is in %edx */
#NO_APP
movl %edx,-8(%ebp)
特定寄存器约束的使用
现在让我们看一下如何将个别寄存器作为操作数的约束指定。在下面的示例中,cpuid 指令采用 %eax 寄存器中的输入,然后在四个寄存器
中给出输出:%eax、%ebx、%ecx、%edx。对 cpuid 的输
入(变量 "op")传递到 "asm" 的 eax 寄存器中,因为 cpuid 希望它这样做。在输出中
使用 a、b、c 和 d 约束,分别收集四个寄存器中的值。
asm ("cpuid"
: "=a" (_eax),
"=b" (_ebx),
"=c" (_ecx),
"=d" (_edx)
: "a" (op));
在下面可以看到为它生成的汇编代码(假设 _eax、_ebx 等... 变量都存储在堆栈上):
movl -20(%ebp),%eax /* store 'op' in %eax -- input */
#APP
cpuid
#NO_APP
movl %eax,-4(%ebp) /* store  %eax in _eax -- output */
movl %ebx,-8(%ebp) /* store  other registers in
movl %ecx,-12(%ebp)
 respective output variables */
movl %edx,-16(%ebp)
strcpy 函数可以通过以下方式使用 "S" 和 "D" 约束来实现:
asm ("cld\n
rep\n
movsb"
: /* no input */
:"S"(src), "D"(dst), "c"(count));
通过使用 "S" 约束将源指针 src 放入 %esi 中,使用 "D" 约束将目的指针 dst 放入 %edi 中。
因为 rep 前缀需要 count 值,所以将它放入 %ecx 中。
在下面可以看到另一个约束,它使用两个寄存器 %eax 和 %edx 将两个 32 位的值合并在一起,
然后生成一个 64 位的值:
#define rdtscll(val) \
  __asm__ __volatile__ ("rdtsc" : "=A" (val))
The generated assembly looks like this (if val has a 64 bit memory space).
#APP
rdtsc
#NO_APP
movl %eax,-8(%ebp) /* As a result of A constraint
movl %edx,-4(%ebp)
  %eax and %edx serve as outputs */
Note here that the values in %edx:%eax serve as 64 bit output.
使用匹配约束
在下面将看到系统调用的代码,它有四个参数:
#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \
type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
: "=a" (__res) \
: "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)), \
"d" ((long)(arg3)),"S" ((long)(arg4))); \
__syscall_return(type,__res); \
}
在上例中,通过使用 b、c、d 和 S 约束将系统调用的四个自变量放入 %ebx、%ecx、%edx 和 %esi 中。
请注意,在输出中使用了 "=a" 约束,这样,位于 %eax 中的系统调用的返回值就被放入变量 __res 中。通过将匹配约束 "0" 用作输入部
分中第一个操作数约束,syscall 号 __NR_##name 被放入 %eax 中,并用作对系统调用的输入。这样,这里的 %eax 既可以用作输入
寄存器,又可以用作输出寄存器。没有其它寄存器用于这个目的。另请注意,输入(syscall 号)在产生输出(syscall 的返回值)之前被消耗
(使用)。
内存操作数约束的使用
请考虑下面的原子递减操作:
__asm__ __volatile__(
"lock; decl %0"
:"=m" (counter)
:"m" (counter));
为它生成的汇编类似于:
#APP
     lock
     decl -24(%ebp) /* counter is modified on its memory location */
#NO_APP.
您可能考虑在这里为 counter 使用寄存器约束。如果这样做,counter 的值必须先复制到寄存器,递减,然后对其内存更新。但这样您会无
法理解锁定和原子性的全部意图,这些明确显示了使用内存约束的必要性。
使用修饰寄存器
请考虑内存拷贝的基本实现。
   asm ("movl $count, %%ecx;
up: lodsl;
stosl;
loop up;"
          :           /* no output */
          :"S"(src), "D"(dst) /* input */
          :"%ecx", "%eax" ); /* clobbered list */
当 lodsl 修改 %eax 时,lodsl 和 stosl 指令隐含地使用它。%ecx 寄存器明确装入 count。但 GCC 在我们通知它以前是不知道这些的,
我们是通过将 %eax 和 %ecx 包括在修饰寄存器集中来通知 GCC 的。
在完成这一步之前,GCC 假设 %eax 和 %ecx 是自由的,它可能决定将它们用作存储其它的数据。请注意,%esi 和 %edi 由 "asm" 使
用,它们不在修饰列表中。这是因为已经声明 "asm" 将在输入操作数列表中使用它们。这里最低限度是,如果在 "asm" 内部使用寄存器(无
论是明确还是隐含地),既不出现在输入操作数列表中,也不出现在输出操作数列表中,必须将它列为修饰寄存器。

* asm
** nasm
-f [TYPE] 编译成 elf32 elf64 coff aout 等格式
-o o 输出obj文件 -l 输出列表文件
-h 帮助 -hf 针对格式的帮助
*** 寻址
mov ax,[var] 取地址  
mov ax,var 取值
** gas 
NASM 分别使用 dd、dw 和 db 指令声明 32 位、16 位和 8 位数字，而 GAS 分别使用 .long、.int 和 .byte。
GAS 还有其他指令，比如 .ascii、.asciz 和 .string。
在 GAS 中，像声明其他标签一样声明变量（使用冒号），但是在 NASM 中，只需在内存分配指令（dd、dw 等等）前面输入变量名，后面加上变量的值。
NASM 使用方括号间接引用一个内存位置指向的地址值：[var1]。
GAS 使用$引用同样的值：$var1)。 
* Linux Assembly
 The choice of a GNU generation
Linux Assembly
Some brighteyed and crazy, some frightened and lost.
Roger Waters
   document versie: 1.0, 02-03-2002
   auteur: H.P. Berends
   layout: pdfLATEX, Initworks - www.initworks.com
   copyright c 2002 H.P. Berends
Voorwoord
Dit dictaat is geschreven voor studenten met enige programmeerervaring, maar
met weinig tot geen ervaring met assembly. Aan de hand van voorbeelden worden
de beginselen van de taal gedemonstreerd; er wordt dieper ingegaan op de wer-
king van methodes achter de assembly taal.
In het bijzonder wil ik Remko de Vrijer <devrijer@initworks.com> en Marco Haze-
broek <m.hazebroek@hro.nl> bedanken voor hun medewerking bij het maken van
dit dictaat. Beiden hebben het complete manuscript verschillende malen doorge-
nomen. Hun reviews en visie zijn als uitgangspunt gebruikt bij het schrijven van dit
document.
Ook wil ik de volgende mensen bedanken voor hun bijdrage aan dit dictaat.
A.J. Schrijver <arjan@cimdroom.nl>, J. van Iersel <jurrian@cimdroom.nl>, R.A.T.M.B.M.
van Valkenburg <robrecht@qualitysnooker.com>, B. Mels <bart.mels@cmg.nl>, M.J.
Bethlehem <mjb@radon.nl>, A. Veenstra <veenstra@chello.nl>, R. Huizer <ronald@grafix.nl>,
M. Nuyten <pnuyten@concepts.nl>.
Inhoudsopgave
Voorwoord                                                                        2
1 Inleiding                                                                      7
   1.1 Opbouw dictaat . . . . . . . . . . . . . . . . . . . . . . . . . . . .    7
2 Ontstaan van assembly                                                          9
   2.1 De eerste computers . . . . . . . . . . . . . . . . . . . . . . . . .     9
   2.2 Nu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   11
3 Assembly                                                                      12
   3.1 Assembly programmeren . . . . . . . . .      . . . . . . . . . . . . . . 12
   3.2 Hello world . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . 13
   3.3 Assembly sourcecode . . . . . . . . . .      . . . . . . . . . . . . . . 14
   3.4 Kernel, system calls en interrupts in Linux  . . . . . . . . . . . . . . 16
        3.4.1 System calls in assembly . . . . .    . . . . . . . . . . . . . . 17
   3.5 Binary executables voor Linux . . . . . .    . . . . . . . . . . . . . . 19
   3.6 Sections . . . . . . . . . . . . . . . . .   . . . . . . . . . . . . . . 19
   3.7 Vragen en opdrachten . . . . . . . . . .     . . . . . . . . . . . . . . 23
4 Architectuur                                                                  26
   4.1 Historie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
   4.2 Het Hart . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . 26
   4.3 Processor onderdelen . . . . . .     . . . . . . . . . . . . . . . . . . 27
   4.4 Kenmerken . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . 29
   4.5 Geheugen . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . . 30
   4.6 CISC/RISC . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . . 30
   4.7 Endian . . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . . 31
        4.7.1 Little-endian . . . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.8 De modi van de 80x86 . . . . . .     . . . . . . . . . . . . . . . . . . 35
   4.9 Voordelen van de protected mode      . . . . . . . . . . . . . . . . . . 36
   4.10 De 80x86 CPU familie . . . . . .    . . . . . . . . . . . . . . . . . . 38
   4.11 Vragen en opdrachten . . . . . .    . . . . . . . . . . . . . . . . . . 41
INHOUDSOPGAVE                                                                     5
5 Registers                                                                      43
   5.1 Geheugencellen . . . . . . . . . .      . . . . . . . . . . . . . . . . . 43
   5.2 Intel registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
   5.3 Segment registers . . . . . . . . .     . . . . . . . . . . . . . . . . . 47
   5.4 Instructie pointer . . . . . . . . . .  . . . . . . . . . . . . . . . . . 47
   5.5 Flags register . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . 47
        5.5.1 Carry flag . . . . . . . . . .   . . . . . . . . . . . . . . . . . 47
   5.6 Sections en segment registers . . .     . . . . . . . . . . . . . . . . . 49
        5.6.1 Taken . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 50
   5.7 Jumps . . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 51
   5.8 Signed en unsigned integers . . . .     . . . . . . . . . . . . . . . . . 52
        5.8.1 Unsigned integers . . . . .      . . . . . . . . . . . . . . . . . 52
        5.8.2 Signed integers . . . . . . .    . . . . . . . . . . . . . . . . . 53
        5.8.3 Two’s complement omzetten        . . . . . . . . . . . . . . . . . 54
   5.9 Rekenen . . . . . . . . . . . . . .     . . . . . . . . . . . . . . . . . 54
        5.9.1 Increment en decrement . .       . . . . . . . . . . . . . . . . . 55
        5.9.2 Vermenigvuldigen en delen .      . . . . . . . . . . . . . . . . . 55
   5.10 Logische operatoren en maskers . .     . . . . . . . . . . . . . . . . . 57
        5.10.1 AND . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . 57
        5.10.2 OR . . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 58
        5.10.3 XOR, exclusive OR . . . . .     . . . . . . . . . . . . . . . . . 59
        5.10.4 NOT . . . . . . . . . . . . .   . . . . . . . . . . . . . . . . . 60
        5.10.5 TEST . . . . . . . . . . . .    . . . . . . . . . . . . . . . . . 61
   5.11 Vragen en opdrachten . . . . . . .     . . . . . . . . . . . . . . . . . 63
6 Taal niveaus                                                                   66
   6.1 Assembly language . . . . . . . . .       . . . . . . . . . . . . . . . . 66
   6.2 Low-level languages . . . . . . . . .     . . . . . . . . . . . . . . . . 66
   6.3 High Level Languages . . . . . . . .      . . . . . . . . . . . . . . . . 67
   6.4 Samenwerking tussen C en assembly         . . . . . . . . . . . . . . . . 68
   6.5 Low-level power! . . . . . . . . . . .    . . . . . . . . . . . . . . . . 70
   6.6 NASM . . . . . . . . . . . . . . . .      . . . . . . . . . . . . . . . . 72
        6.6.1 NASM macro’s . . . . . . . .       . . . . . . . . . . . . . . . . 72
   6.7 Vragen en opdrachten . . . . . . . .      . . . . . . . . . . . . . . . . 74
7 Programma structuur                                                            75
   7.1 Instructie executie . . . .   . . . . . . . . . . . . . . . . . . . . . . 76
   7.2 Structuur door vergelijking   . . . . . . . . . . . . . . . . . . . . . . 77
   7.3 Jumps & flags . . . . . .     . . . . . . . . . . . . . . . . . . . . . . 78
        7.3.1 Het if-statement . .   . . . . . . . . . . . . . . . . . . . . . . 79
   7.4 Jumps & loops . . . . . .     . . . . . . . . . . . . . . . . . . . . . . 81
INHOUDSOPGAVE                                                                    6
        7.4.1 Het while-statement .  . . . . . . . . . . . . . . . . . . . . .  81
        7.4.2 Het for-statement . .  . . . . . . . . . . . . . . . . . . . . .  83
   7.5 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  84
        7.5.1 POP en PUSH . . .      . . . . . . . . . . . . . . . . . . . . .  84
        7.5.2 PUSHA/POPA . . .       . . . . . . . . . . . . . . . . . . . . .  87
        7.5.3 PUSHF en POPF . .      . . . . . . . . . . . . . . . . . . . . .  87
   7.6 Vragen en opdrachten . . .    . . . . . . . . . . . . . . . . . . . . .  89
A NASM installeren                                                              90
   A.1 Downloaden van de source . . . . . . . . . . . . . . . . . . . . .       90
   A.2 ./configure && make && make install . . . . . . . . . . . . . . . . .    90
   A.3 De NASM documentatie . . . . . . . . . . . . . . . . . . . . . . .       91
B ALD installeren                                                               92
   B.1 Downloaden van de source . . . . . . . . . . . . . . . . . . . . .       92
   B.2 Configureren, compileren en installeren . . . . . . . . . . . . . . .    93
C Linux Kernel Modules in assembly                                              94
D Ascii Tabel                                                                   96
   Bibliografie                                                                100
   Index                                                                       102
Hoofdstuk 1
Inleiding
Door een betere kennis van de werking van computers, kan er productiever ge-
programmeerd worden in hogere programmeertalen zoals C en C++. Het leren
programmeren in assembly is een goede manier om dit te bereiken.
De doelstelling van dit dictaat is een introductie geven in assembly en de lezer as-
sembly te leren en het te laten schrijven. Assembly is een low-level taal en geeft
een goed beeld van de taken van het operating system.
Als platform is gekozen voor het GNU/Linux operating system; dit is een opensour-
ce UNIX systeem met goede debug mogelijkheden en beschikbare kernel source-
code. Zo kan Linux goed worden gebruikt bij de demonstratie van de werking van
software.
Dit dictaat zal ook veel ingaan op de Intel processor architectuur omdat kennis van
de werking van de processor van groot belang is bij het programmeren in assem-
bly.
Dit document is bedoeld als een inleiding in assembly, het is namelijk niet mogelijk
om alle aspecten van assembly te behandelen. Na het lezen van dit dictaat heeft
men een completer beeld van wat assembly is en kan men technische documenten
over processorarchitectuur in combinatie met assembly beter aan.
1.1      Opbouw dictaat
Hoofdstuk 2 ’Ontstaan van assembly’ beschrijft de historie van de computer en
het ontstaan van assembly.
In hoofdstuk 3 ’Assembly’ wordt de basis van het assembly programmeren behan-
deld. Hierbij wordt een inleiding gegeven in het programmeren met system calls in
assembly.
1 Opbouw dictaat                                                               8
Hoofdstuk 4 ’Architectuur’ beschrijft de architectuur van een computer. Kennis
hiervan is nodig, omdat assembly programma’s direct omgaan met hardware.
Hoofdstuk 5 ’Registers’ gaat in op registers binnen de processor. Kennis hiervan
is belangrijk omdat instructies en registers nauw verbonden zijn. Zonder gebruik
te maken van registers is het onmogelijk om in assembly te programmeren.
Hoofdstuk 6 ’Taal niveaus’ licht hogere programmeertalen en assembly toe. Het
beschrijft hoe er geprogrammeerd kan worden in verschillende talen en gaat in op
de samenwerking.
Hoofdstuk 7 ’Programma structuur’ beschrijft hoe assembly programma’s struc-
tuur krijgen.
In het dictaat wordt gebruik gemaakt van NASM en ALD, voor uitleg over de instal-
latie hiervan zie bijlage A en B.
Hoofdstuk 2
Ontstaan van assembly
Het is 1935. Duitsland wordt geregeerd door de bende van Hitler, de wereld staat
aan de vooravond van een ramp, als Konrad Zuse zijn ouders uit de woonkamer
zet. Zuse, een jonge, wat wereldvreemde ingenieur met achterovergekamd zwart
haar, die als statisticus werkzaam is bij de Henschel-Flugzeug-Werke, heeft de
ruimte nodig voor ’de constructie van het eerste mechanische brein’. In die kamer
in de Berlijnse wijk Kreuzberg wil Zuse een machine bouwen die in staat is om
gecompliceerde statistische berekeningen uit te voeren. Dan is hij daar op zijn
werk tenminste van verlost. ”Ik ben te lui om te rekenen”, had Zuse vaak bekend.
Bovendien, vindt hij, moet zijn apparaat kunnen schaken en het liefst ook tekenen.
1
2.1        De eerste computers
Zuse 2 was de bedenker van de eerste binaire computer. Het apparaat was een
wangedrocht van tandraderen, uitsteeksels en zwengels. Hij ontwierp zijn machi-
nes vóór de oorlog; pas in 1946 bouwden Mauchly en Eckert, in opdracht van het
Amerikaanse ministerie van Defensie, de ENIAC. De ENIAC was de eerste elek-
trische computer, een groot monster van 19.000 radiobuizen.
Tot die tijd waren de Amerikanen niet op het idee gekomen om te werken met bi-
naire getallenstelsels, ze werkten met decimalen. Zuse was zijn tijd ver vooruit. Hij
is er nooit rijk van geworden en zijn uitvinding heeft relatief weinig invloed gehad
op de geschiedenis van de computer. Toch komt hem alle eer toe.
De onderdelen van computers en de gebruikte technieken komen niet alleen uit
    1
      bron: Rotterdams Dagblad, Zaterdag 21 juli 2001
    2
      Voor meer informatie over de uitvindingen van Zuse en de machines die hij heeft gebouwd zie
http://irb.cs.tu-berlin.de/~zuse/hc.html.
2 De eerste computers                                                                      10
          Figuur 2.1: De ENIAC; computers van vroeger vulden hele ruimtes
deze tijd. Al vanaf de 17e eeuw zijn mensen bezig om rekenen te automatiseren.
Pas in de 20e eeuw lukte het om een bruikbare logische computer te maken. De
eerste computers voedden zich met ponskaarten. Dit zijn kaarten met gaten er-
in. De gaten in de kaarten werden omgezet naar enen en nullen; op deze manier
konden elektrische machines lezen.
In 1935 liet John von Neumann zien dat de voorlopers van de computer instructies
en data als één kon behandelen. Instructies en data konden op deze manier bin-
nen de computer gebruikt worden, zo waren er geen ponskaarten meer nodig. De
Von Neumann Architectuur is een standaard geworden voor alle moderne compu-
tersystemen. Von Neumann, die in die tijd net als Zuse in Berlijn woonde, heeft
zijn tijdgenoot nooit ontmoet.
Von Neumann’s systemen gingen om met machinetaalinstructies en dat was geen
gemakkelijke taal om in te programmeren. Alle programma’s bestonden uit bijna
onleesbare codes. In de jaren ’50 werd de ’assembly language’ ontwikkeld. Deze
’assembler talen’ gebruikten woordcodes om mee te programmeren, in plaats van
getallen. Elke woordcode 3 kwam overeen met één machinetaalinstructie. Machi-
netaal en assemblytalen worden, omdat ze relatief diep op de technische details
   3
     Deze woordcodes zijn mnemonics (zie hoofdstuk 3). Voor een programmeur is het woord ’mov’
eenvoudiger te onthouden dan de code ’B8’.
2 Nu                                                                        11
ingaan low-level languages genoemd.
2.2     Nu
In deze tijd wordt er veelal in hogere programmeertalen geprogrammeerd. Toch is
assembly onontbeerlijk, ook voor hogere programmeertaalprogrammeurs. Omdat
het programmeren in assembly inzicht geeft in de manier waarop computers wer-
ken krijgt een programmeur zicht op de mogelijkheden en de technische details
achter software. Het is in assembly mogelijk om optimaal doelmatige software te
schrijven.
In de volgende hoofdstukken wordt geprobeerd een zo goed mogelijk beeld te
schetsen over assembly. Ondanks dat veel aspecten onbehandeld blijven, wordt
er veel aandacht besteed aan de uitvoer en realisatie van hardware aangestuurd
door software. Dit kan een goede ondergrond zijn om verdere aspecten van as-
sembly te leren.
Hoofdstuk 3
Assembly
In dit hoofdstuk wordt de werking van assembly programma’s uitgelegd. Het pro-
grammeren in assembly gebeurt in dit dictaat via het operating system, die vervol-
gens de hardware aanstuurt. Aan de hand van een ’hello world’ voorbeeld leert
men hoe system calls in Linux gebruikt kunnen worden.
Er wordt een beschrijving gegeven van de opbouw van assembly sourcecode, ook
wordt er aandacht besteed aan de opbouw van assembly sourecode en de repre-
sentatie van executables in het geheugen.
3.1      Assembly programmeren
Het schrijven van programma’s in assembly kan op verschillende manieren. Er
kan gebruik worden gemaakt van allerlei service’s, bijvoorbeeld van libraries en
system calls. Libraries zijn programmabibliotheken. Ze bestaan vaak uit voor-
geprogrammeerde software routines die gebruikt kunnen worden voor generieke
taken. System calls zijn aanspreekpunten om rechtstreeks services van de kernel
te vragen.
In dit hoofdstuk wordt er geprogrammeerd aan de hand van system calls. Dit omdat
system calls de werking van het Linux operating system laten zien, in tegenstelling
tot libraries, die als een schil om system calls heen zitten.
Door assembly te programmeren wordt er achter de schermen van Linux gekeken.
De Linux kernel is geschreven in C. De architectuur afhankelijke delen zijn in as-
sembly geschreven.
De meeste softwaretools die gebruikt worden in deze handleiding staan standaard
op een GNU/Linux systeem. De gebruikte tools die niet standaard geïnstalleerd
zijn worden beschreven in de bijlages.
3 Hello world                                                                         13
                         Figuur 3.1: Protected operating system
3.2        Hello world
Door gebruik te maken van de Netwide Assembler (nasm) en GNU linker (ld) kun-
nen we assembly programma’s maken.
Als de assembly sourcecode gecompileerd is met NASM moet het worden gelinkt
door een linker. De linker maakt van de objectcode een ELF binary die op het
systeem gedraaid kan worden.
s e c t i o n . data
        h e l l o db " H e l l o w o r l d " , 0x0a
        l e n equ $ − h e l l o          ; lengte hello (12)
section . text
global _start                    ; entry point , label
_start :
; ssize_t write ( i n t          fd , c o n s t v o i d ∗ buf , s i z e _ t count ) ;
       mov eax , 4               ; system c a l l n r . van w r i t e
       mov ebx , 1               ; 1e arg : f d van s t d o u t
       mov ecx , h e l l o       ; 2e arg : p o i n t e r naar h e l l o
       mov edx , l e n           ; 3e arg : l e n g t e h e l l o
        i n t 0x80               ; c a l l kernel
3 Assembly sourcecode                                                                        14
 ; v o i d _ e x i t ( i n t status ) ;
       mov eax , 1              ; system c a l l n r . van e x i t
       mov ebx , 0              ; 1e arg : status
        i n t 0x80              ; c a l l kernel
Objectcode is het resultaat van het compileren, een gecompileerde file bevat ma-
chinetaal in plaats van assembly instructies. Om er vervolgens een executable van
te maken moet het gelinkt worden. Dit wordt gedaan met een linker (ld). Meestal
heeft een file met objectcode de .o extensie.
NASM is niet de algemeen gebruikte assembler voor UNIX systemen, dat is ’as’.
Maar de syntax van as is niet gelijk aan de Intel syntax. Voor het installeren van
NASM zie bijlage A.
Sla de gegeven assembly sourcecode op in het bestand ’hello.asm’. Er moet hier-
bij gebruik worden gemaakt van een teksteditor.
Door de volgende commando’s te geven wordt het bestand gecompileerd en gel-
inkt.
nasm -f elf hello.asm
ld hello.o -o hello
Het commando ’nasm -f elf hello.asm’ compileert het programma in objectcode en
plaats de objectcode in ’hello.o’. De optie ’-f elf’ betekent dat de output ELF ob-
jectcode is.
Het linken gebeurt met ’ld hello.o -o hello’. De optie ’-o’ (output) geeft aan waar de
gelinkte code (de executable) heen wordt geschreven.
Er bestaat nu een executable met de naam ’hello’. Dit bestand kan worden uitge-
voerd door ’./hello’. Er verschijnt ’Hello world’ op het scherm.
3.3        Assembly sourcecode
Universele assembly sourcecode bestaat uit vier velden.
De vier velden zijn: het label veld, het mnemonic 1 veld, het operand veld en het
commentaar veld.
    1. Het label veld kan worden gebruikt om het doel van een jump instructie aan
   1
     Mnemonic is een Grieks woord en wordt uitgesproken als ’neh-MAHN-ik’. Mnemonics zijn
afkortingen van woorden die voor instructies staan, ze zijn meer menslogisch dan numerieke waar-
den.
3 Assembly sourcecode                                                             15
      te geven. Een jump kan worden gezien als een goto instructie.
      Bijvoorbeeld: ’_start:’ Labels eindigen op ’:’.
   2. Het mnemonic veld bevat de mnenonic die gekoppeld is aan een processor-
      instructie. Voorbeelden van mnemonic’s zijn, add, sub, mov. Een mnemonic
      vervangt de moeilijk te onthouden processorinstructie of opcode.
      Bijvoorbeeld: ’int’ of ’mov’
   3. Het operand veld bevat de operands waarop de instructies worden uitge-
      voerd. Heeft een mnemonic meer operands dan worden ze gescheiden door
      komma’s.
      Bijvoorbeeld: ’eax, [source]’
      Er zijn drie verschillende operands:
          • Registers
             Registers kunnen waarden bevatten. Meestal heeft het gebruik van
             registers de voorkeur boven het gebruik van geheugen omdat registers
             in de processor zelf liggen, waardoor ze sneller te adresseren zijn.
             Bijvoorbeeld: ’mov eax, edx’ of ’inc ebx’
          • Immediates
             Dit zijn getallen zoals 99 of 0xc4fe.
             Bijvoorbeeld: ’mov eax, 0xb4dc0d3’
          • Geheugen
             Geheugen is in assembly gelabeld met een naam.
             Bijvoorbeeld: ’test eax, input’
             Wordt dit operand tussen vierkante haakjes gezet ([]) dan betekent dit
             dat het om de inhoud van het geheugen gaat, niet het adres (de poin-
             ter) zelf.
             Bijvoorbeeld ’mov esi, [demo]’
             Hier wordt de inhoud van het geheugen dat ’demo’ heet in het ESI-
             register gezet.
   4. Het laatste veld, het commentaar veld, wordt gescheiden door een ’;’, en is
      niet verplicht. Alles dat na de ’;’ staat wordt gezien als commentaar. Vooral
      bij low-level languages zoals assembly is commentaar zeer belangrijk. Goed
      commentaar kan sourcecode verduidelijken.
Een regel assembly sourcecode kan er bijvoorbeeld zo uitzien:
routine: mov eax, [memlocation]
Er wordt er een ’mov’-instructie uitgevoerd die inhoud van memlocation (rechts)
3 Kernel, system calls en interrupts in Linux                                       16
naar eax (links) kopiëerd. In dit dictaat wordt er gebruik gemaakt van de Intel
syntax die het source operand rechts neemt en het destination operand links.
Het statement ’routine:’ geeft het label aan. Het gebruik van labels is niet verplicht.
3.4      Kernel, system calls en interrupts in Linux
Software bestaat vaak uit de volgende onderdelen: het vragen om input, het ma-
ken van berekeningen, het geven van output, en het sluiten. Om dit te realiseren,
maakt het meestal gebruik van de services van het operating system. Assembly
kan dus niet alleen processor afhankelijk zijn maar ook nog eens operating system
afhankelijk.
                         Figuur 3.2: System call en libraries
Alle operating systemen leveren een bepaalde service aan de software; meestal
gebeurt dit via en vanuit de kernel. UNIX en varianten, waaronder Linux, hebben
een aantal entry points direct naar de kernel toe. Dit worden system calls ge-
noemd.
System calls (figuur 3.2) kunnen vanuit C worden aangesproken met behulp van
libraries, maar een applicatie kan ook direct gebruik maken van system calls.
Meestal worden system calls via de C library (libc) wrapper aangesproken.
     Het gebruik van libc in assembly is niet verplicht, het is een keuze van de
programmeur.
Libc wrappers zijn gemaakt om software af te schermen voor syntax verandering
van system calls. Maar omdat de UNIX kernel, en dus ook Linux, in hoge mate
3 Kernel, system calls en interrupts in Linux                                                17
POSIX 2 compliant is (sterker nog, system calls hebben dezelfde syntax als kernel
system calls en vice versa), heeft het vaak weinig nut om gebruik te maken van
system call wrappers, zoals printf(), scanf() enz. Daarom is het vaak makkelijker
om direct gebruik te maken van kernel calls, omdat dit de snelste manier is om
gebruik te maken van de kernel services. Het gebruik van kernel calls heeft ook
weer nadelen, omdat het per gebruikte kernel en dus operating system verschilt.
3.4.1     System calls in assembly
De werking van het assembly programma dat ’hello world’ demonstreert is niet ge-
heel duidelijk. Het lijkt in de verste verte niet op andere programmeertalen. Toch
heeft het er alles mee te maken.
In het voorbeeld wordt er ’Hello world’ op het scherm geschreven aan de hand van
system calls. System calls zijn diensten van het operating system die een bepaal-
de taak uitvoeren.
System calls worden besproken in section 2 van de man page. De manpage van
write is op te vragen door ’man 2 write’.
Daar staat de C definitie van de write system call.
ssize_t write(int fd, const void *buf, size_t count);
In assembly ziet het er anders uit, de Linux kernel gaat als volgt om met system
calls op assembly niveau.
     • ssize_write() Het EAX-register bevat het system call nummer uit het be-
       stand /usr/include/asm/unistd.h.
     • int fd Het EBX-register bevat het eerste argument, in dit geval de file descrip-
       tor voor stdout die 1 is. stdout is meestal gekoppeld aan het beeldscherm,
       waardoor berichten die naar stdout worden geschreven automatisch op het
       scherm verschijnen.
     • const void* buf Het ECX-register bevat een pointer (geheugenadres) naar
       de string die afgedrukt dient te worden.
     • size_t count Het EDX-register bevat het aantal tekens dat de af te drukken
       string lang is.
   2
     POSIX (Portable Operating System Interface) is een set standaarden voor UNIX operating sys-
tems. Er was behoefte aan standaarden binnen de verschillende UNIX stromingen.
Voor meer informatie zie de website van Open Group, www.opengroup.org, en de System V imple-
mentatie op http://stage.caldera.com/developer/devspecs/.
3 Kernel, system calls en interrupts in Linux                                                     18
Door het programma strace te gebruiken kunnen we zien welke system calls een
programma gebruikt.
strace hello
Het resultaat ziet er zo uit.
execve ( " . / h e l l o " , [ " h e l l o " ] , [ / ∗ 39 v a r s ∗ / ] ) = 0
 w r i t e ( 1 , " H e l l o w o r l d \ n " , 12 H e l l o w o r l d
                              )                  = 12
 _exit (0)                                                            = ?
Er staan nu codes op het scherm die erg op C programmatuur lijken. Om precies
te zijn staan er 3 system calls op het scherm. De eerste is execve, de tweede is
write en de derde is exit (_exit is gelijk aan exit).
De eerste is de system call die het programma laat runnen vanuit de shell, execve
draait ’./hello’. Dit staat niet in de sourcecode omdat de shell input van de user
neemt en execve uitvoert om het programma te starten. De andere system calls in
het voorbeeld staan wel in de assembly sourcecode. Write en exit worden beiden
gebruikt in het programma.
Met de opdracht ’int 0x80’ wordt de kernel 3 aangeroepen. De kernel kijkt in het
EAX register en voert aan de hand van de waarde in het EAX register een system
call uit. Bij een interrupt (’int’-instructie) wordt de CPU aangeroepen en voert deze
een bepaalde handeling uit, het programma heeft dan tijdelijk geen toegang tot de
CPU.
De system calls van Linux zijn gedefiniëerd in ’/usr/include/asm/unistd.h’. Zo komt
de system call write overeen met met 4, en exit met 1.
Als we hetzelfde programma in C hadden geschreven had het er zo uitgezien.
# i n c l u d e < u n i s t d . h>
 i n t main ( v o i d ) {
                w r i t e (1 , " Hello world \ n " , 1 2 ) ;
                exit ( 0 ) ;
}
    3
      De kernel is het operating system zonder applicaties (programma’s). Het is de interface tussen
hardware en de applicaties. Zo zorgt het ervoor dat er meerdere processen tegelijk kunnen draaien
en dat deze niet elkaars geheugen kunnen overschrijven. (Walter de Jong bedankt voor je definitie.)
3 Binary executables voor Linux                                                      19
Sla de C sourcecode op in het bestand ’hello2.c’ en compileer en link het met ’
gcc hello2.c -o hello2’. Vergelijk de uitkomst van ’hello2’ en ’hello’ door beide uit te
voeren.
Er is geen verschil in uitkomst. Betrek nu ’strace’, en ondervindt het verschil in de
binaries. Al snel blijkt dat er bij de assembly versie van ’Hello world’ twee system
calls gebruikt worden in tegenstelling tot de C versie, waar er veel meer worden
gebruikt.
Er zijn nog veel meer verschillen tussen de binaries, zoals de snelheid en grootte
van de executable. De volgende commando’s laten die verschillen zien.
ls -al hello{’ ’,2}
time hello
time hello2
Voor meer informatie over time raadpleeg de manpage.
3.5      Binary executables voor Linux
Moderne 32-bit Unices 4 , zoals Linux, draaien in protected mode en maken gebruik
van het ‘Executable and Linkable Format’ (ELF) voor executable binaries. System
calls in Linux worden gemaakt via ’int 0x80’. Het function nummer van de system
call wordt uitgelezen uit EAX en de argumenten staan in de registers, niet op de
stack. Er zijn maximaal zes argumenten mogelijk, EBX, ECX, EDX, ESI, EDI en
EBP.
3.6      Sections
Assembly sourcecode bestaat uit één of meer delen, zogenaamde sections (figuur
3.3). Deze sections komen overeen met segmenten in het geheugen. Er zijn
verschillende sections elk met een verschillend doel.
     • .data section
        Deze section wordt gebruikt om constanten te declareren, zoals file names
        en buffer groottes. Het gaat hier om geïnitialiseerde data.
        Het data segment verandert niet tijdens het draaien van het programma.
   4
     meervoud van UNIX
3 Sections                                                                    20
              Figuur 3.3: Een executable binary geladen in het geheugen
     In dit deel staan de db, dd, dw statements, het zijn directives en ze reser-
     veren data in het geheugen. De ’d’ uit deze opdrachten staat voor define.
     Een directive wordt alleen gebruikt door de assembler, na het vertalen van
     assembly naar machine code bestaan ze dan ook niet meer (alleen geheu-
     genadressen worden gebruikt in de executable).
     De opdracht equ (equate) maakt het mogelijk om symbolische namen te ge-
     ven aan getallen. Deze worden door de assembler vervangen door getallen.
     Ook is het mogelijk om via een equate de lengte van reserveerd geheugen
     te bepalen. Met ’formatlen equ $ - format’ neemt de symbolische naam ’for-
     matlen’ de lengte van de string ’format’ aan.
     Bijvoorbeeld:
      s t r i n g db " D i t i s een s t r i n g " , 0
      f o r m a t db " x=%d \ n " , 0
      f o r m a t l e n equ $ − f o r m a t
      e r r o r db " E r r o r " , 0xa
3 Sections                                                                         21
      year equ 365
      Bij strings wordt er geëindigd met een ’0’, omdat er anders niet bekend is
      waar de string eindigt. Zo is de code gelijk aan de strings of character arrays
      in C.
   • .bss section
      In dit gedeelte worden de variabelen gedeclareerd. Het gaat hier om ongeï-
      nitialiseerde data in het geheugen.
      De geheugenvelden hebben nog geen waarde; er wordt alleen nog maar
      geheugen gereserveerd. Pas als het programma draait zullen er bruikbare
      gegevens in komen te staan. Het .bss section verandert niets aan de exe-
      cutable als file. Omdat het .bss section nog geen data bevat en het wel om
      moet gaan met data is het write-enabled.
       i n p u t resb 1
       p i resq 1
   • .text section
      Dit is het gedeelte waar de assembly code wordt geschreven. Op deze plek
      staan de instructies (weergeven als mnemonics).
      Er is een label gedeclareerd dat begint met een ’_’ (underscore). Dit bete-
      kent dat hier een entry is, zodat andere software het kan starten.
      De code in het code section van een programma hoeft niet lineair uitgevoerd
      te worden; er bestaan namelijk calls en jumps die de volgorde van executie
      veranderen. Het code section of .text section is als segment in het geheu-
      gen read-only. Tenzij er een wijziging is gemaakt in de program header (ELF
      header).
       c a l l re
      mov [ i n p u t ] , eax
De opdrachten die in het het .data en .bss section staan zijn geen instructies. Ze
kunnen gezien worden als pseudo-instructies. Omdat bijvoorbeeld het reserveren
van bytes en het labelen ervan op machine niveau niet bestaat. Het label wordt in
de executable vervangen door een geheugenadres.
3 Sections                                                                                                                                                 22
Zie hier een tabel met de datatypes en de grootte ervan. Deze worden gebruikt bij
de resx en dx statements.
                            Intel datatype                  C declaratie                 Suffix            Grootte (Bytes)
                            Byte                            char                              b                        1
                            Word                            short                            w                         2
                            Double Word                     int                               d                        4
                            Quad Word                       double                            q                        8
                            Double Word                     char *                            d                        4
   Ter illustratie: Een pointer (dus ook een character pointer) is een double word (4Bytes, 32-bit). Dit omdat geheugenadressen 32-bits geadresseerd worden.
Om een indruk te krijgen van het .data en het .bss segment die in het geheugen
liggen, kan men ’hello.asm’ compileren en linken. Door het vervolgens in ALD te
laden, kan men delen van het data segment bekijken. ALD staat voor Assembly
Language Debugger, het is een assembly debugger voor de x86 die instructies in
Intel syntax weergeeft. Zie ook bijlage B.
ald hello
Typ nu twee maal ’next’ in tot dat de opdracht ’mov ecx, 0x80490a4’ verschijnt. 5
Bij deze opdracht wordt de pointer naar (of het adres van) de ’hello’ string in het
data segment naar het ECX-register geschreven. Dit betekent dat op 0x80490a4
"Hello world", 0xa staat.
Typ nu ’examine 0x80490a4’ voor een dump van 20 bytes na 0x80490a4.
...
ald> examine 0x80490a4
Dumping 20 bytes of memory starting at 0x080490A4 in hex
080490A4: 48 65 6C 6C 6F 20 77 6F 72 6C 64 0A 00 00 00 00 Hello world.....
080490B4: 00 00 00 00 ....
    5
      De waarde 0x80490a4 kan van systeem tot systeem verschillen.
3 Vragen en opdrachten                                                           23
3.7     Vragen en opdrachten
   1.   (a) Leg uit wat een system call is. Geef ook het verband aan met het
            operating system.
        (b) Wat is het verschil tussen een system call en een library functie?
        (c) Wat is een nadeel van system calls, vergeleken met andere routines?
        (d) Wat is een voordeel van system calls, ten opzichte van library calls?
   2.   (a) Assembly sourcecode bestaat uit sections, die overeen komen met de-
            len in het geheugen. Waarom zijn sommige delen read-only?
        (b) Wat zou er gebeuren als die delen write enabled zijn? Geef een aantal
            voorbeelden en geef aan wat er zou gebeuren met het programma en
            het operating system.
   3. Is het mogelijk om assembly en C in één programma te laten samenwerken.
      Waarom wel of waarom niet?
   4. Assembly programmatuur is meestal kleiner en sneller dan software ge-
      schreven in hogere programmeertalen.
        (a) Waarom is dit?
        (b) Waarom wordt er dan niet massaal in assembly geschreven?
   5. De sourcecode van het assembly programma ’hello.asm’ zet ’Hello world’ op
      het scherm. Verander de source zo dat het meerdere regels op het scherm
      zet door twee keer gebruik te maken van de system call write (let op: er moet
      twee keer een string worden gereserveerd).
   6.   (a) Waarom bestaat assembly code uit velden?
        (b) Geef de namen van de verschillende velden.
        (c) Bekijk de source code van ’hello.asm’. Uit welk veld komt ’mov’?
   7. Is het verplicht op alle regels van assembly sourcecode 4 velden te hebben?
      Licht je antwoord toe.
   8.   (a) Vraag de manpage op van de system call ’chmod’. Er zijn namelijk
            verschillende manpages van ’chmod’ omdat het ook een shell utility is.
        (b) Zoek het nummer van de system call die bij ’chmod’ hoort.
            (hint: Gebruik hierbij de includes op het Linux systeem /usr/include/as-
            m/unistd.h)
3 Vragen en opdrachten                                                                  24
   9. Schrijf een assembly programma dat input leest via de system call ’read’. Na
      het inlezen moet het programma via ’write’ de de input van ’read’ afdrukken.
      Maak gebruik van een variabele ’input’ die als volgt wordt gedeclareerd in
      assembly.
       s e c t i o n . bss
               i n p u t resd 1
      input kan bij de system call ’read’ worden gezien als ’void *buf’ (het 2e argu-
      ment) en wordt in het ECX-register gezet. Zie ook de man page van ’read’.
  10. Het onderstaande programma, ’filexs.asm’ drukt ’file.txt’ af. Verander het
      programma zo, zodat het ’/etc/inittab’ afdrukt.
      De inhoud van ’filexs.asm’.
       s e c t i o n . bss
               b u f resd 1
               count resd 1
       s e c t i o n . data
               pathname db " f i l e . t x t " , 0
       section . text
       global _start
       _start :
       ; i n t open ( c o n s t char ∗ pathname , i n t f l a g s ) ;
              mov eax , 5
              mov ebx , pathname
              mov ecx , 0 ; O_RDONLY u i t / u s r / i n c l u d e / asm / f c n t l . h
               i n t 0x80
       ; eax kan e r r o r status b e v a t t e n . D i t wordt
       ; h i e r genegeerd .
       ; open r e t u r n e d een f d i n eax
              mov ebx , eax
       ; s s i z e _ t read ( i n t fd , v o i d ∗ buf , s i z e _ t count ) ;
3 Vragen en opdrachten                                                                    25
      ; met read bepalen we h e t a a n t a l u i t t e l e z e n b y t e s
           mov eax , 3                    ; read s y s c a l l
                                          ; ebx bevat de f d d i e open r e t u r n d e
           mov ecx , b u f                ; adres b u f i n ecx
           mov edx , count                ; count i n edx
            i n t 0x80                    ; l e e s ’ count ’ a a n t a l b y t e s
      ; read r e t u r n e d h e t a a n t a l gelezen b y t e s i n eax
      ; w r i t e g e b r u i k t d i t a a n t a l a l s parameter
           mov edx , eax
      ; s s i z e _ t w r i t e ( i n t fd , c o n s t v o i d ∗ buf , s i z e _ t count ) ;
           mov eax , 4                    ; write syscall
           mov ebx , 1                    ; f d van s t d o u t
                                          ; ecx bevat h e t adres van b u f
                                          ; edx bevat count
            i n t 0x80
      ; v o i d _ e x i t ( i n t status ) ;
           mov eax , 1
           mov ebx , 0
            i n t 0x80
     De inhoud van ’file.txt’.
     Q: What ’ s a redneck f o r t u n e c o o k i e ?
     A : A p i e c e o f cornbread w i t h a food stamp baked i n s i d e .
Hoofdstuk 4
Architectuur
In dit hoofdstuk wordt de processor van een computer onder de loep genomen. Er
wordt aandacht besteed aan de werking van de processor en aan de verschillende
onderdelen in de processor. De grote verschillen tussen de processoren die er op
de markt zijn en de kenmerken hiervan worden beschreven. De Intel processor
wordt als uitgangspunt genomen.
4.1      Historie
Tijdens de late jaren ’60 werden geïntegreerde elektronische circuits geïntrodu-
ceerd. Honderden transistors, dioden, en resistoren pasten in één aparte chip.
Het gevolg was een enorme snelheidswinst, een hogere capaciteit, meer betrouw-
baarheid en het was velen malen goedkoper dan de traditionele hardware. Er was
een nieuw fenomeen: de microprocessor.
4.2      Het Hart
Het hart van de computer is de CPU. Het staat voor Central Processing Unit,
meestal is dit een andere term voor processor of microprocessor. De CPU be-
heerst alle interne en externe hardware en voert logische en rekenkundige op-
drachten uit. Het is de meest verantwoordelijke chip in het systeem en bevat een
logisch circuit dat de instructies uitvoert van de software. De instructies staan in
een instructieset die vastligt in het ROM geheugen van de processor, dat niet her-
schrijfbaar is.
De instructieset bepaalt de machinetaal van de CPU. Is een instructieset te uitge-
breid, dan heeft dat gevolgen voor de performance van het systeem. Processors
4 Processor onderdelen                                                            27
met verschillende instructiesets kunnen niet dezelfde software aan. Een gecompi-
leerd programma voor een Apple computer zal niet draaien op een Intel systeem.
     Figuur 4.1: De CPU staat tussen het geheugen en de randapparatuur in.
De CPU is de belangrijkste chip in een computer; toch is het mogelijk om er één
of meer in een systeem te hebben. Deze techniek heet SMP (Symmetric Multi-
Processing). Het zorgt er voor dat verschillende processoren het operating system
en het geheugen delen. SMP systemen presteren beter dan MMP (Mono Multi-
Processing) systemen. Het voordeel kan worden behaald door een balans van
workload (uit te voeren werk) tussen verschillende processoren.
4.3     Processor onderdelen
Een CPU bestaat uit verschillende onderdelen. Zeer vereenvoudigd zijn er de
volgende onderdelen, elk met een eigen taak (zie figuur 4.2).
   1. Control Unit
      De Control Unit regelt de activiteiten van interne en externe apparaten. Het
      interpreteert de instructies, het bepaalt welke data er nodig zijn en de plaats
      ervan. Ook houdt het zich bezig met het wegschrijven van resultaten. Het
      stuurt signalen, die de hardware devices aanzetten tot het uitvoeren van de
      instructies.
   2. ALU
      De ALU (Arithmetic and Logic Unit) is het deel van de CPU waar de reken-
      kundige bewerkingen plaatsvinden. Het bestaat uit circuits die rekenkundige
4 Processor onderdelen                                                          28
                    Figuur 4.2: Schematische weergave van CPU
      operaties kunnen uitvoeren zoals optellen, aftrekken, vermenigvuldigen en
      delen op data die verkregen zijn uit het geheugen en de registers. Ook heeft
      het de mogelijkheid data te vergelijken en met bits te schuiven.
   3. Registers
      Als de ALU taken uitvoert, heeft het tijdelijke opslagruimte nodig voor da-
      ta. Dit gebeurt in de registers. Registers zijn speciale geheugencellen in
      de processor. Ze worden gebruikt om geheugen te adresseren, data te ma-
      nipuleren en te verwerken. Sommige registers hebben een gereserveerd
      doel, terwijl andere general-purpose registers zijn. Omdat de data in de re-
      gisters telkens worden gebruikt, bestaan ze uit zeer snel geheugen dat data
      direct bewerkt en de uitkomst weer kan opslaan na een bewerking. Mocht
      de data in een register niet nodig zijn voor de volgende instructie dan wor-
      den ze naar het RAM geschreven en houden de registers zich bezig met de
      volgende instructie. Dit als een programmeur efficiënte assembly code heeft
      geschreven.
   4. Clock Unit
      De activiteiten van een processor bestaan uit verschillende instructies voor-
      gesteld in duizenden individuele stappen. De stappen moeten in de juiste
      volgorde van vaste intervallen verlopen. Het deel van de processor dat zich
      met die intervallen bezig houdt, is de Clock Unit, ook wel Timer genoemd. El-
      ke operatie in de processor vindt plaats op de puls van de Clock Unit. Geen
      enkele operatie, hoe simpel ook, kan worden gedaan in een tijd die korter
      is dan die tussen de intervallen. Maar sommige operaties kosten meer dan
      een puls. Geeft de Clock Unit kortere pulsen dan werkt de processor snel-
      ler. De kloksnelheid wordt aangeduid in MegaHertz (MHz), en tegenwoordig
      ook GigaHertz (GHz). Een processor van n MHz heeft een Clock Unit die n
4 Kenmerken                                                                                  29
        miljoen pulsen per seconde produceert.
        Processor informatie opvragen in een Linux systeem kan door het volgende
        commando 1 .
        cat /proc/cpuinfo
                                    Figuur 4.3: De CPU chip
4.4       Kenmerken
De kenmerken van een processor zijn:
    1. Het aantal uitgevoerde instructies per seconde
    2. Het aantal bits van de woordlengte
De woordlengte is het aantal bits dat een CPU kan verwerken per clockcycle.
Er zijn twee marktleidende fabrikanten van processoren: Intel en Motorola. Andere
processoren zijn meestal compatible met deze. Bijvoorbeeld AMD en Cyrix, deze
processoren gebruiken dezelfde machinetaal en instructieset als de Intel, terwijl
hun inwendige structuur verschilt.
   1
     Zie voor extra informatie over de implementatie van de processor in het operating system de
includes van de kernel: ’/usr/include/asm-i386/processor.h’
4 Geheugen                                                                       30
4.5      Geheugen
Computergeheugen bestaat uit logische circuits, dit wordt statisch geheugen of
SRAM genoemd. Geheugen circuits bestaan uit cellen; ze representeren nullen
en enen. Een verzameling van cellen noemt men een chip.
In DRAM (Dynamic RAM) liggen de geheugencellen heel erg dicht tegen elkaar
aan. Ze verliezen hun inhoud snel, daarom dient DRAM regelmatig ververst te
worden.
Bij phsysical memory, het echte (tastbare) geheugen is de omvang makkelijk te
berekenen. Dit gaat op dezelfde manier als bij rechthoeken: 2 x l x b, waar l staat
voor de lengte, oftewel het aantal words, en b staat voor de breedte, oftewel de
woordgrootte.
De volgende commando’s geven informatie over het geheugen.
cat /proc/meminfo
free
4.6      CISC/RISC
Bij het ontwerp van processoren bedacht men een techniek die CISC (Complex
Instruction Set Computer of Computing) heette. Een CISC processor is een pro-
cessor met een zeer rijke instructieset. Dit zou een betere samenwerking met
hogere programmeertalen hebben.
Dit voordeel is te weerleggen omdat hogere programmeertalen nogal verschillen
en compilers die gebruik moeten maken van de instructieset ook. Zo wordt het
onnodig ingewikkeld.
De Intel 80x86 serie maakt gebruik van deze CISC technologie.
Omdat er steeds meer in hogere programmeertalen werd geprogrammeerd en om-
dat geheugen steeds sneller werd, verdwenen de belangrijkste redenen van CISC.
Maar nog steeds hielden ontwikkelaars zich bezig met het versnellen van pro-
cessoren. Een van de technieken die werd geïntroduceerd was RISC (Reduced
Instruction Set Computer). Een RISC processor bevatte een gereduceerd aantal
simpele instructies.
Een lange reeks simpele instructies presteert uiteindelijk dan net zoveel of zelfs
beter op een RISC processor dan een enkele complexe instructie op een CISC
processor die hetzelfde doet. Het belangrijkste doel voor de ontwikkelaars was
niet het ontwikkelen van de instructieset, maar de snelheid van de chip. Bij RISC
4 Endian                                                                                         31
architecturen zijn de frequent gebruikte instructies snel. Eén van de designtech-
nieken was om meerdere instructies tegelijk uit te voeren (pipelining).
Dit heeft tot gevolg dat in het meest ideale geval de RISC processor één instructie
per kloktik kan uitvoeren. Het aantal megahertz kan zo gelijk zijn aan het aantal
instructies per seconde; dit wordt ook wel MIPS (Million Instructions Per Second)
genoemd. Dit lukt niet altijd, maar toch is er een effectieve capaciteit van zo’n 60%
tot 70% mogelijk, afhankelijk van de te verwerken taak. CISC zou zulke snelheden
niet kunnen halen; toch zijn de instructies krachtiger dan die van de RISC. RISC
is taakonafhankelijk, in tegenstelling tot CISC. Een RISC processor kan daardoor
2 tot 4 maal sneller zijn. De PowerPC van Apple en de huidige generatie van Ma-
cintosh systemen zijn gebaseerd op RISC.
De processor afhankelijke delen van de Linux kernel zijn voor een groot deel in
assembly geschreven. Het biedt meerdere assembly sourcecodes aan voor de
verschillende architecturen die het ondersteunt.
Geef het volgende commando in.
ls -l /usr/src/linux/include/ | grep asm
Dit geeft aan dat de kernel source symbolisch gelinkt is met de assembly source-
code voor de i386. Verder geeft het een lijst van alle processor architecturen aan
die ondersteund worden, zoals de de Sun Sparc, Dec Aplha en andere types. 2
4.7        Endian
"It is allowed on all Hands, that the primitive Way of breaking Eggs before we eat
them, was upon the larger End: But his present Majesty’s Grand-father, while he
was a Boy, going to eat an Egg, and breaking it according to the ancient Practice,
happened to cut one of his Fingers. Whereupon the Emperor his Father, published
an Edict, commanding all his Subjects, upon great Penalties, to break the smal-
ler End of their Eggs. The People so highly resented this Law, that our Histories
tell us, there have been six Rebellions raised on that Account;... It is computed
that eleven Thousand Persons have, at several Times, suffered Death, rather than
submit to break their Eggs at the smaller End. Many hundred large Volumes ha-
ve been published upon this Controversy: But the Books of the Big-Endians have
been long forbidden..."
Jonathan Swift’s Gulliver’s Travels
    2
      Voor meer informatie over de Linux kernel en verschillende processor architecturen zie: http:
//www.kernel.org
4 Endian                                                                                             32
De termen big-endian en little-endian zijn geleend uit Gulliver’s Travels.
In een computer staan ze voor de volgorde waarin bytes worden opgeslagen in het
geheugen (byte ordering).
Bij big-endian staat het ’big-end’, de meest significante byte vooraan en wordt het
bewaard op het laagste geheugenadres.
Little-endian is de volgorde waarbij de minst significante byte vooraan in het ge-
heugen wordt bewaard.
Bijvoorbeeld, in een big-endian computer, worden de bytes voor het hexadecimale
getal B9 62 bewaard als volgt. B9 wordt bijvoorbeeld op adres 1000 bewaard en
62 op 1001. Bij een little endian systeem gaat het net andersom. 62 zou worden
bewaard op 1000, B9 op 1001.
Nog een voorbeeld:
       • Bij little-endian wordt 0x65 66 67 68 opgeslagen als 0x68 0x67 0x66 0x65.
       • Bij big-endian wordt 0x65 66 67 68 opgeslagen als 0x65 0x66 0x67 0x68.
De meeste RISC processoren zijn big-endian. Voor Nederlanders, die graag van
links naar rechts lezen, is dit ideaal. Maar de Intel processoren en de software die
ervoor wordt geschreven is little-endian.
Little endian betekent dat het ’minst significante byte’ (LSB) wordt bewaard op het
laagste geheugenadres (vooraan). 3
Door de opdracht ’file <bestand>’ te geven kan men zien wat voor executable het
is en of het geschikt is voor het gebruikte operating system en architectuur.
Bijvoorbeeld:
file /bin/bash
Kort de voordelen van little-endian en big-endian:
       • Little-endian: makelijk implementeerbaar in hardware
       • Big-endian: begrijpelijker
4.7.1        Little-endian
Over de Intel wordt gezegd dat het een little-endian architectuur is. Dit kan worden
getest door naar de opcodes (de uit te voeren instructies in hexadecimale waar-
     3
       Bekijk de files in de directory ’/usr/include/linux/byteorder/’ voor meer informatie over big- en
little-endian.
4 Endian                                                                     33
den) te kijken.
De volgende sourcecode, ’endian.asm’, demonstreert de werking van little-endian,
door gebruikt te maken van een debugger.
section . text
global _start
_start :
            mov      eax ,      1
            mov      eax ,      0x8001
            mov      eax ,      0x00008001
            mov      eax ,      0x8001abcd
; exit
            mov      ebx ,      0
            mov      eax ,      1
            int      0x80
Figuur 4.4: De representatie van een word in het geheugen van een little-endian
systeem.
Compileer en link de sourcecode. Open het in de Assembly Language Debugger
(ALD).
4 Endian                                                                     34
ald endian
Een snapshot van de uitkomst.
...
ald> next
eax = 0x00000001 ebx = 0x00000000 ecx = 0x00000000 edx = 0x00000000
esp = 0xBFFFF970 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x08048085 eflags = 0x00200346
08048085 B801800000 mov eax, 0x8001
ald> next
eax = 0x00008001 ebx = 0x00000000 ecx = 0x00000000 edx = 0x00000000
esp = 0xBFFFF970 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x0804808A eflags = 0x00200346
0804808A B801800000 mov eax, 0x8001
ald> next
eax = 0x00008001 ebx = 0x00000000 ecx = 0x00000000 edx = 0x00000000
esp = 0xBFFFF970 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x0804808F eflags = 0x00200346
0804808F B8CDAB0180 mov eax, 0x8001abcd
ald> next
eax = 0x8001ABCD ebx = 0x00000000 ecx = 0x00000000 edx = 0x00000000
esp = 0xBFFFF970 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x08048094 eflags = 0x00200346
De debugger laat door het commando ’next’ de uitwerking zien van de instructies
op de registers.
Bekijk de dikgedrukte regel. In het geheugen wordt op het adres 0804808F een
instructie gelezen; het programma is namelijk geladen in het geheugen.
De opdracht ’mov eax, 0x8001’ wordt vertaald in B801800000 in machinecode.
Het getal 0x8001 wordt opgedeeld in delen van 2 delen van elk 1 byte, 01 en 80.
B8 staat voor de opcode (instructie) van ’mov eax’.
4 De modi van de 80x86                                                           35
De opdracht ’mov eax, 0x8001abcd’ wordt vertaald naar B8CDAB0180. Het laat-
ste gedeelte de ’abcd’ staat nu vooraan in een andere volgorde.
Ook kan de lengte van de instructies verschillen. Op een Intel systeem kan dat
liggen tussen de 1 en 15 bytes. Instructies die vaak voorkomen zijn meestal klein
en zijn daarom sneller te verwerken.
4.8     De modi van de 80x86
De Intel 80386 heeft mogelijkheden om de tekortkomingen van de oudere 8086 te-
gemoet te komen. De 8086 heeft bijna geen mogelijkheden op het gebied van het
ondersteunen van geheugen protectie, virtual memory, multitasking en de manier
om geheugen te adresseren boven de 640 KB.
Toch is de 80386 geheel backwards compatible met de 8086. De 80386, 80486
en verder worden hier als elkaars gelijken gezien. Het gaat erom dat de 80386 ge-
baseerd is op al zijn voorgangers en dat de meeste technieken gelijk zijn gebleven
bij nieuwere types in de 80386+ serie.
De 8086 werkt met de real mode. Toen de ontwerpers bij Intel de 80286 ontwier-
pen wilden ze extra mogelijkheden toevoegen aan de 8086. Maar ze wilden ook
8086 compatibiliteit. Om aan beide eisen te voldoen verzonnen ze twee modi: Real
Mode en Protected Mode. Real mode, de standaard op dat moment, maakte van
de chip een 8086 met kleine veranderingen. Veranderingen waren er in overvloed
als er gekeken wordt naar de protected mode. Bijna alle software die ontworpen
is voor de 8086 zal niet werken in de protected mode zonder aanpassingen. DOS
was in de tijd één van deze software.
De 80386 heeft meer capaciteiten dan de 8086 en de 286. De standaard mode,
zoals die bij de voorgangers was de real mode. De 286 en 386 kunnen beide ope-
reren in de protected mode. Toch is de interne structuur is totaal verschillend. De
386 heeft namelijk 32-bits registers en twee nieuwe 16-bit registers. De 386 sup-
port nog een derde mode, Virtual 8086 mode (V86). In de V86 mode handelt de
386 als in de protected mode maar behandelt het processen als in de real mode.
V86 kan worden gezien als een emulator. 4
4 Voordelen van de protected mode                                                          36
                  Figuur 4.5: Tijdelijke opslag en permanente opslag
4.9      Voordelen van de protected mode
    1. Adressering
       De 386 kan 4 GB aan geheugen adresseren, dit is het meest significante ver-
       schil tussen de protected mode en de real mode. Protected mode software
       kan zonder probleem 4 GB (232 bytes) aan geheugen voor data, code en
       stack reserveren. Door gebruik te maken van omslachtige technieken kan
       de real mode ook adresseren boven de 1 MB gebruiken om data te plaat-
       sen. Deze technieken, het lineair adresseren van de code en stack ruimte,
       is in het algemeen onhandig. Bovenal, het volledige 4 GB adresseren komt
       weinig voor bij computers van het PC kaliber.
    2. Virtual memory
       De Memory Management Unit (MMU) van de 386 kan virtual memory im-
       plementeren, dat er voor kan zorgen dat processen denken dat er 4 GB aan
       geheugen is, terwijl er in werkelijk veel minder aanwezig is. In plaats daar-
       van gebruikt het delen van de harddisk om data op te slaan.
       Computers hebben een bepaald aantal MB’s aan RAM beschikbaar voor de
   4
     Een emulator is hardware of software dat zich voordoet als iets anders, zodat de software
die gebruik maakt van de emulator op dezelfde manier werkt als in de verwachte omgeving. Deze
techniek wordt veel gebruikt bij hardware die backwards compatible moet zijn.
4 Voordelen van de protected mode                                                                   37
       CPU. Helaas is dat niet altijd voldoende om alle processen tegelijk te laten
       draaien. Als het operating system een groot aantal processen draait in het
       fysieke geheugen is het bijna niet mogelijk om alle data van de processen
       op te slaan. Kan het operating system geen virtual memory gebruiken dan
       zal het aangeven dat er niet genoeg RAM beschikbaar is en adviseren om
       bepaalde processen te beëindigen.
       Virtual memory gaat hier anders mee om. Er wordt gekeken welke delen
       van het geheugen het minst recent zijn gebruikt en kopiëert die vervolgens
       naar de harddisk. Meestal gebeurt dit in de vorm van een swap file of swap-
       partitie.
   3. Adres vertaling
       De MMU kan ook adressen vertalen voordat ze gebruikt worden. Software
       processen werken met logische adressen. De 386 converteert lineair de
       logische adressen naar 32-bit (zonder segment adres). De MMU converteert
       dan weer lineaire adressen naar fysieke adressen. fysieke adressen liggen
       op de RAM chips.
   4. Segmentatie
       In real mode zijn alle segmenten 64 KB lang en zitten op vaste locaties.
       In protected mode kunnen segmenten verschillen in lengte van 1 byte to
       4 GB. De segmenten kunnen onderverdeeld worden in 4 K pages. Pages
       vervangen de segmenten.
   5. Process protection
       Verschillende processen kunnen beveiligd worden tegen elkaar. Het ene
       proces heeft geen toegang tot de data van het andere proces. Het operating
       systeem heeft ongelimiteerd toegang tot alle processen. Maar processen
       hebben dit zeker niet, ze kunnen geen data van andere processen dwars
       zitten of sturen. Dit maakt de loop van een proces onafhankelijk van andere
       processen. 5
   6. 32-bit registers
       Registers op de 386 zijn 32-bits lang. Behalve de opgedeelde registers,
       zoals AX (16 bit) in het EAX (32 bit) register. Ook zijn er meer segment
       registers bijgekomen.
   7. Adresserings methodes
       In de real mode konden constante waarden alleen worden gebruikt in het BX,
       BP en SI, DI register. In de protected mode kunnen alle registers gebruikt
       worden.
  5
    Tenzij de kernel dit expliciet toelaat, bijvoorbeeld bij ptrace. Voor meer info ’man 2 ptrace’.
4 De 80x86 CPU familie                                                           38
   8. Multitasking
      Ook een zeer belangrijk voordeel van de 386 is dat het multitasking support.
      De 386 heeft veel snelle technieken om de huidige processor stand (alle data
      in de registers) tijdelijk op te slaan en verder te gaan met een ander proces.
      Later kan de stand van de processor weer worden opgepakt en kan er verder
      worden gegaan, net alsof er geen onderbreking heeft plaatsgevonden.
   9. Debuggen van hardware
      De 386 heeft speciale hardware voor het debuggen van data breakpoints.
      Wat wil zeggen dat op hardware niveau de data in bepaalde registers in de
      gaten kan worden gehouden.
4.10      De 80x86 CPU familie
                          Figuur 4.6: De Intel 386 processor
   1. 8088, 8086 Deze zijn als er zeer oppervlakkig wordt gekeken gelijk, intern
      verschillen ze wel degelijk. Beiden werden ze gebruikt in de eerste PC’s. Ze
      bevatten ze de volgende 16-bit registers: AX, BX, CX, DX, SI, DI, BP, SP,
4 De 80x86 CPU familie                                                           39
      CS, DS, SS, ES, IP, FLAGS. Deze processoren ondersteunen real mode. In
      deze mode kan een proces al het geheugen adresseren, inclusief dat van
      andere processen. Dit is zeer gevaarlijk en maakt debugging extra moeilijk.
      Het geheugen wordt verdeeld in segmenten van 64 KB.
   2. 80286 Deze CPU werd het eerst gebruikt in de AT-PC. Het voegt een paar
      extra instructies toe aan de 8086. Het heeft namelijk de mogelijkheid om in
      16-bit protected mode te werken. Het kan nu 16 megabytes aan geheugen
      adresseren en het beschermt processen van elkaar. Helaas zijn de segmen-
      ten verdeeld in delen van 64 KB.
   3. 80386 Deze CPU volgde de 80286 op en nam veel eigenschappen over in-
      clusief de registers en voegde daar de volgende 32-bits registers aan toe:
      EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP en twee nieuwe 16-bit seg-
      ment registers FS en GS. Ook maakt deze CPU gebruik van een nieuwe
      32-bit protected mode. In deze mode kan het tot 4 GB aan geheugen adres-
      seren. Processen worden verdeeld in segmenten, die nu pages heten en
      kunnen een lengte hebben van 1 byte tot 4 GB.
   4. 80486/Pentium/Pentium Pro Deze CPU’s voegen weinig nieuwe instructies
      toe, ze zorgen er voor dat de instructies sneller worden uitgevoerd.
   5. Pentium MMX Deze processor voegt MMX (MultiMedia, eXentions) toe aan
      de instructieset van de Pentium. De instructies zorgen er voor dat veel ge-
      bruikte grafische operaties sneller worden uitgevoerd.
   6. Pentium II/Pentium III/Pentium 4 Dit is de Pentium Pro met MMX. De Penti-
      um III/4 is eigenlijk alleen qua verwerkingssnelheid verschillend van de Pen-
      tium II.
   7. Itanium/IA-64 De Itanium is een 64-bits processor architectuur die geba-
      seerd is op EPIC (Explicitly Parallel Instruction Computing), het parallel uit-
      voeren van operaties binnen de processor. De Itanium, die in 2005 uitkomt
4 De 80x86 CPU familie                                                       40
      zal de eerste 64-bits processor zijn die Intel heeft ontworpen. Ook is de
      processor van het RISC type.
4 Vragen en opdrachten                                                           41
4.11      Vragen en opdrachten
   1.   (a) Wat is de taak van de processor (CPU)?
        (b) Waarom is de processor in een computer de belangrijkste chip?
   2.   (a) Wat is een instructieset?
        (b) Kan je een instructieset herschrijven?
   3.   (a) Leg het begrip endian uit.
        (b) Kan er worden gesteld dat little-endian systemen sneller zijn dan big-
             endian systemen? Licht toe.
        (c) Als de Intel processoren little-endian systemen zijn, kunnen klonen van
             die processor dan big-endian zijn?
             Intel is CISC, kan een AMD processor RISC zijn?
   4. De waarde van het EFLAGS register kan veranderen door bepaalde instruc-
      ties. Is het nuttig om de verandering van het gehele register in de gaten te
      houden? Licht toe.
   5. Stel er moet met getallen worden gerekend die groter zijn dan 32-bit en
      daarom niet in de registers van de 386 passen, toch moeten de waarden
      worden opgeslagen. Noem enkele methodes om hiermee om te gaan.
   6. Is het mogelijk om software die voor een Macintosh is gecompileerd te draai-
      en op een Intel computer?
      Geef aan waarom dit (niet) kan.
   7. Het produceren van hardware wordt steeds goedkoper, toch gebruiken de
      huidige processoren dezelfde technieken als oudere processoren. Waarom
      wordt er niet direct overgestapt op een totaal andere architectuur?
   8. Bekijk het volgende programma.
      s e c t i o n . bss
                    var       resd        1
      section . text
      global _start
       _start :
4 Vragen en opdrachten                                                     42
          mov ecx , 0x41424344
          mov [ v a r ] , ecx ; inhoud ecx i n v a r
          mov ecx , v a r       ; adres van v a r i n ecx
          mov eax , 4           ; sys c a l l w r i t e
          mov ebx , 1           ; 1e arg : f d van s t d o u t
                                ; ecx bevat adres v a r
          mov edx , 4           ; lengte
          i n t 0x80            ;  c a l l kernel
          mov ebx , 0           ; 1e arg : e x i t code
          mov eax , 1           ; sys c a l l e x i t
          i n t 0x80            ; c a l l kernel
     Compileer en link het bovenstaande voorbeeld, ’endian2.asm’. Run het pro-
     gramma en verklaar de output.
     Waarom is de volgorde van het resultaat totaal anders dan verwacht?
     (0x41 of 65 betekent een A)
Hoofdstuk 5
Registers
In dit hoofdstuk worden de verschillende typen registers behandeld en waarvoor
ze dienen. Er wordt een inleiding gegeven in de werking van jumps, die het mo-
gelijk maken om ’sprongen’ binnen het code segment te maken, dit beïnvloedt de
uitvoering van programma’s.
In assembly zijn er twee representaties van gehele getallen, beide worden be-
handeld. Verder wordt er aandacht besteed aan rekenkundige bewerkingen en
logische operatoren.
5.1      Geheugencellen
Registers zijn geheugencellen in een processor. Ze kunnen waarden aannemen
of bevatten pointers naar data in het geheugen, deze data kunnen bijvoorbeeld
instructies zijn voor de processor. Registers zijn meestal een veelvoud van een
byte breed, bijvoorbeeld 16, 32, 64-bit. Zo ook bij de Intel 386 die registers van 32-
bit heeft. Programmatuur krijgt een bepaalde werking door instructies die worden
uitgevoerd door de processor. De instructies in assembly stellen mnemonic’s voor
en hun operands zijn registers, geheugenadressen of immediates.
Bijvoorbeeld:
push eax                  ; eax i s een r e g i s t e r operand
mov ebx , 1               ; h e t g e t a l 1 i s een immediate operand
x o r [ memloc ] , edx ; memloc i s een memory operand
Door instructies uit te voeren veranderen de waarden in de registers. Deze ver-
anderingen kunnen worden getest, zo kan programmatuur een bepaalde volgorde
van uitvoering krijgen.
5 Intel registers                                                              44
5.2      Intel registers
Ondanks dat de 8088 8-bit registers had, waren er wel 16-bit mogelijkheden. De
processor was zodanig ontworpen dat het om kon gaan met een 16-bit adresse-
ringssysteem. Dit deed het door gebruik te maken van twee registers H en L. Beide
registers waren 8-bit en vormden samen 16-bit. De 16-bit 8086 voegde een extra
X aan de namen van de processor registers toe. De registers AX, BX, CX, en DX
zijn paren van AH en AL, van BH en BL, van CH en CL, van DH en DL. De andere
16-bit registers, SP, BP, SI en DI, hebben geen X in hun namen en vormen daarom
ook geen paren.
               Figuur 5.1: General-purpose registers van de Intel 386
De databus van de 8086 was 16-bit en het kon 65.536 (216 ) locaties adresseren in
een segment. De adresbus was 20-bit, dit was een truukje om meerdere segmen-
ten te kunnen gebruiken op hetzelfde moment. Daarom was het geheugen niet
helemaal gelimiteerd aan 64K, alleen is er geen manier om alle 220 bytes tegelijk
te adresseren.
Veel van de tekortkomingen aan de 8086 processor zijn verbeterd bij de 386. De
acht 32-bit registers die beginnen met een E (extended) zijn uitbreidingen op de
corresponderende 16-bit registers van de 8086. De databus en de adresbus van
de 386 zijn beiden 32-bit dat betekent dat het 4.294.967.296 (232 , 4GB) aan ge-
heugenlokaties kan adresseren.
De Linux kernel biedt als operating systeem de mogelijkheid om 64GB aan geheu-
5 Intel registers                                                              45
gen te adresseren, het maakt gebruik van 3-level paging dat deels wordt aangebo-
den door de IA32 (= Intel Architecture, voor 32-processoren dus de 386 en later).
Eén van de redenen waardoor de Intel x86 lijn van processoren een groot succes
werd, naast het feit dat een grote software fabrikant uit Redmond zijn software
ervoor schrijft, is dat de processoren backwards compatible zijn. Software die
draaide op voorgangers van de processoren, draait ook op nieuwere types.
De 32-bits registers van de 386 kunnen maximaal 232 verschillende waarden aan-
nemen (van 0x0000 0000 tot 0xFFFF FFFF). De 16-bit registers kunnen 216 ver-
schillende waarden aannemen (van 0x0000 tot 0xFFFF).
De 386 heeft 16 registers voor algemeen gebruik en voor het schrijven van soft-
ware. Die zijn onder te verdelen in:
                      Figuur 5.2: De registers van de Intel 386
   1. General-purpose registers. Deze acht registers worden gebruikt voor het
       opslaan van data en pointers. Ze dienen als operands voor instructies.
   2. Segment registers. Deze registers bevatten de zes segment selectors.
5 Intel registers                                                                46
    3. Status en control registers. Deze registers veranderen van waarde bij be-
        paalde voorwaarden.
De 32-bit general-purpose data registers zijn EAX, EBX, ECX, EDX, ESI, EDI, EBP
en ESP. Ze worden ondermeer gebruikt voor logische en rekenkundige bewerkin-
gen, voor het berekenen van geheugen adressen en het opslaan van geheugen
pointers. Omdat de 32-bit registers niet groot genoeg zijn om grote brokken data te
bevatten worden er pointers (verwijzingen naar geheugen adressen) gebruikt naar
data in het geheugen.
Ondanks dat alle general-purpose registers gebruikt kunnen worden, moet er toch
erg voorzichtig worden omgegaan met het ESP-register. Het ESP-register bevat
de stackpointer; het wijst naar het begin van de stack. Sommige instructies maken
altijd gebruik van bepaalde registers. Zo maken string instructies gebruik van ECX,
ESI en EDI.
Een kort overzicht van de general-purpose registers en het gebruik ervan:
    1. EAX Accumulator voor operands en het opslaan van data.
    2. EBX Pointer naar het DS segment (Base register)
    3. ECX Counter voor string en lus (loop) operaties
    4. EDX I/O (data) pointer
    5. ESI Pointer naar de data in het segment waar DS naartoe wijst, de bron van
        string operaties (source index).
    6. EDI Pointer naar data (of resultaat) in een segment waar ES naartoe wijst;
        wordt ook gebruikt als resultaat pointer voor string operaties (destination
        index).
    7. ESP Stack pointer (in het SS segment)
    8. EBP Pointer naar de data op de stack (in het SS segment) (Base pointer)
                                 8-bit   16-bit 32-bit
                                 AH      AX     EAX
                                 AL      BX     EBX
                                 BH      CX     ECX
                                 BL      DX     EDX
                                 CH      BP     EBP
                                 CL      SP     ESP
                                 DH      SI     ESI
                                 DL      DI     EDI
5 Segment registers                                                                47
5.3      Segment registers
De segment registers (CS, DS, SS, ES, FS en GS) bevatten 16-bit segment selec-
tors. Een segment selector is een speciale pointer, die wijst naar een segment in
het geheugen. In de protected mode wordt het geheugen verdeeld in segmenten.
Om een bepaald geheugensegment te kunnen aanspreken moet het bijbehorende
segment selector opgeslagen zijn in het register. Deze details zijn bij het program-
meren niet van belang omdat de assembler 1 zelf met segmenten omgaat.
5.4      Instructie pointer
De instructie pointer, EIP bevat een offset in het huidige code segment. Met behulp
van de selector uit CS (code segment) en de offset kan er naar een instructie
worden gewezen. EIP is een register dat telkens wijst naar de volgende uit te
voeren instructie. Wijzigingen aan het EIP register hebben dus direct invloed op
de volgorde van uitvoering van het programma. Op sommige systemen wordt de
instructie pointer aangeduid met program counter (PC).
5.5      Flags register
Het 32-bit EFLAGS register bevat een groep van status flags, een control flag,
en system flags. Sommige van de flags kunnen direct worden gewijzigd, andere
worden alleen door special-purpose instructies gewijzigd. Niet alle bits op het
EFLAGS register worden gebruikt. Door het aan- of uitzetten van flags kan er
gemakkelijk met voorwaarden worden omgegaan. Dit is het belangrijkste doel van
het flags register. Het kan daarom ook niet als volledig 32-bits register worden
gebruikt.
5.5.1     Carry flag
In assembly kan men voorwaarden testen aan de hand van het flags register. Toch
heeft het flag register nog andere taken. Zoals het bijhouden van een eventuele
carry. De mnenonic ’add’ en ’adc’ worden gebruikt bij het optellen van getallen in
de registers.
De mnenonic ’add’ doet het volgende.
operand1 = operand1 + operand2
   1
     Een assembler kan worden gezien als een assembly compiler, in dit geval NASM.
5 Flags register                                                             48
                         Figuur 5.3: Het EFLAGS register
De mnenonic ’adc’ werkt op een iets andere wijze. Het neemt namelijk de car-
ry flag van een eventuele vorige opdracht mee.
operand1 = operand1 + carry flag + operand2
Stel er moet een 64 bits getal opgeteld worden. Dat bestaat uit EDX:EAX (het
eerste deel staat in EDX, het tweede in EAX) en EBX:ECX.
De volgende regels assembly tellen EDX:EAX op bij EBX:ECX en schrijft het terug
in EDX:EAX.
(EDX:EAX = EDX:EAX + EBX:ECX)
add eax , ecx
adc edx , ebx
Bij aftrekken werkt het principe hetzelfde, alleen wordt er gebruik gemaakt van
’sub’ en ’sbb’ voor de carry. De volgende code trekt EBX:ECX af van EDX:EAX.
5 Sections en segment registers                                            49
De carry wordt dan gebruikt als ’borrow’ flag door sub en sbb.
sub eax , ecx
sbb edx , ebx
Beschouw het volgende assembly programma, ’carry.asm’. Het demonstreert de
werking van de CLear Carry (CLC) instructie.
section . text
global _start
 _start :
     mov        eax ,     0xffffffff
     mov        ebx ,     1
     add        eax ,     ebx         ; eax = eax + ebx , CF==1
     adc        eax ,     2           ; eax = eax + 2 + CF
     clc
     mov        eax ,     0xffffffff
     mov        ebx ,     1
     add        eax ,     ebx         ; eax = eax + ebx , CF==1
     add        eax ,     2           ; eax = eax + 2
 ; exit
     mov        ebx ,     0
     mov        eax ,     1
      int       0x80
Om de werking van het programma te begrijpen dient het gecompileerd en gelinkt
te worden en vervolgens in ALD te worden geladen.
5.6     Sections en segment registers
Assembly code bestaat uit één of meer onderdelen, die segmenten worden ge-
noemd. De segmenten kunnen benaderd worden via de segment registers (CS,
DS, SS, ES, FS en GS).
5 Sections en segment registers                                                    50
Hoe de segmentregisters precies worden gebruikt ligt aan het type memory mana-
gement model dat het operating system gebruikt. In het geval dat er geen gebruik
wordt gemaakt van flat of unsegmented memory model beginnen de adressen bij
0 en kan er lineair door worden gerekend. Een modern operating system zoals
Linux maakt gebruik van een segmented memory model. Elk segment register
bevat een andere segment selector dat verwijst naar een ander lineair geheuge-
nadres. Omdat er zes segment registers zijn kunnen er zes segmenten worden
geadresseerd.
5.6.1     Taken
Elk van de segment registers hoort bij code, data of stack. Bijvoorbeeld het CS-
register, dat de segment selector voor het code segment bevat. In het codeseg-
ment staan de instructies van het programma. De processor haalt telkens een
instructie uit het code segment. Dit doet de processor door het logische geheuge-
nadres te vinden met behulp van de waarde in CS en EIP (het instructieregister).
Het EIP-register bevat het lineaire adres van de uit te voeren instructie in het code
segment van CS. Het is niet mogelijk het CS-register te wijzigen via de assem-
bler; dit zou de loop van de software beïnvloeden. (Het operating system laat dit
niet toe, anders zouden processen in elkaars geheugen adresseren en vervolgens
toegang krijgen.) Het wordt intern door de processor gewijzigd (bijvoorbeeld door
interrupt handling en taak verwisselingen).
De registers DS, ES, FS en GS wijzen naar de vier data segmenten. Er zijn vier
data segment registers door deze te gebruiken kan er op een veilige manier met
datastructuren worden omgegaan. Dit is een tegemoetkoming van de processor
naar protected mode.
Zo kan software bijvoorbeeld tegelijk datastructuren van de huidige module ge-
bruiken in het eerste segment. Data uit een ander segment, dat door een hogere
programmeertaal gekoppeld is aan het assembly programma, kan gebruikt wor-
den in het tweede segment. Een dynamische datastructuur kan als derde, en als
vierde segment gebruikt worden.
Het SS register bevat de segment selector voor het stack segment, waar de stack
wordt opgeslagen. Alle stack operaties maken gebruik van het SS register om
data te vinden in het stack segment. Het SS register mag, in tegenstelling tot
CS, wel worden gewijzigd in assembly. Dit maakt het mogelijk meerdere stacks te
gebruiken en daartussen te switchen. (Deze techniek wordt zeer weinig gebruikt.)
5 Jumps                                                                                   51
5.7         Jumps
Jumps zijn assembly instructies die de loop van het programma veranderen. Jumps
veranderen de instructie pointer (EIP) die naar code in het code segment wijst. Er
zijn verschillende typen jumps, meestal vindt er voor een jump een test plaats.
Labels zijn punten in de code section (.text). In de vorige voorbeelden is al gebruik
gemaakt van labels, namelijk ’_start’, dat het begin van het programma aangaf.
Een jump beïnvloedt het EIP door het te laten wijzen naar een punt ergens in het
code segment. Met zogeheten far jumps kan overigens ook naar een ander adres
in een ander code segment worden gesprongen.
Labels labelen punten; ze zijn dus niets meer dan een vervanging van labels in
geheugenadressen binnen het code segment.
Het is de taak van de assembler (NASM) om de adressen van een label waarheen
gejumpt wordt te berekenen. Labels worden vervangen door geheugenadressen
in het code segment. Door executables in ALD te laden is dit goed te zien.
Het onderstaande voorbeeld springt meerdere malen naar het ’print_eax’-label.
Eerst wordt de ascii waarde van het hexadecimale getal 0x30 2 in het eax register
geladen waarnaar het wordt vergeleken met 0x3a. Verschilt het, dan wordt er een
jump gemaakt naar print_eax. Zo niet dan loopt het programma door en wordt exit
uitgevoerd.
 s e c t i o n . bss
               b u f f e r resd 1                       ; herschrijfbare buffer
 section . text
 global _start
 _start :
mov            eax , 0x30                               ; eax=0x30 , a s c i i waarde 0
 print_eax :
               mov [ b u f f e r ] , eax                ; waarde van eax i n b u f f e r
               mov     eax , 4                          ;   write syscall
               mov     ebx , 1                          ;   fd , s t d o u t
               mov     ecx , buffer                     ;   adres van b u f f e r i n ecx
               mov     edx , 1                          ;   lengte
    2
      0x30 komt overeen met getal 0, zie ascii tabel in bijlage D
5 Signed en unsigned integers                                                            52
            i n t 0x80                         ; k e r n e l c a l l , maak i n t e r r u p t
           mov eax , [ b u f f e r ]           ; inhoud v . b u f f e r i n eax
            i n c eax                          ; i n c r e m e n t eax
           cmp eax , 0x3a                      ; v e r g e l i j k eax , met 0x3a
            jnz print_eax                      ; a l s eax !=0 x3a jmp p r i n t _ e a x
 exit :
            x o r ebx , ebx
           mov eax , 1
            i n t 0x80
De werking van de ’cmp’-instructie komt in hoofdstuk 7 ’Programma structuur’ aan
de orde. Het wordt gebruikt om te vergelijken en heeft dezelfde werking als sub,
alleen brengt ’cmp’ geen wijzigingen aan in de operands maar in het ELFAGS
register.
5.8      Signed en unsigned integers
In het vorige voorbeeld werd er gebruik gemaakt van een jump. De jump werd
gemaakt aan de hand van een getal in het EAX-register, dat overeen kwam met
een waarde uit de ascii-tabel.
In assembly wordt vaak gebruik gemaakt van jumps aan de hand van voorwaarden
met getallen, maar wat als die getallen een negatieve waarde bevatten? Dit kan
vervelende gevolgen met zich meebrengen en daarom worden er twee soorten
integers (gehele getallen) gebruikt: signed integers en unsigned integers.
                    Signed integers        Unsigned integers
                    zowel pos. als neg.    altijd positief
                    two’s complement       normale representatie
5.8.1     Unsigned integers
Unsigned integers zijn integers die altijd positief of 0 zijn. Ze worden gebruikt in de
normale representatie. Dat wil zeggen dat het decimale getal 171 in hexadecimaal
0xab voorstelt, en binair 1010 1011.
Een 16-bits register zoals het AX-register bevat dus getallen van 0 tot 65535. Het
heeft een bereik van 216 of 65536.
5 Signed en unsigned integers                                                       53
In C code worden unsigned integers gedeclareerd met ’unsigned int . . . ’. Deze
mogen, net als in assembly, alleen positieve waarden bevatten.
5.8.2       Signed integers
Om gebruik te maken van negatieve getallen moeten we kunnen aangeven dat
getallen positief of negatief zijn. Er worden hier 3 coderingsmethoden uitgelegd;
de laatste, two’s complement, wordt in de huidige computers gebruikt, maar kan
gemakkelijker begrepen worden als de twee voorgangers ook duidelijk zijn.
Bij sign magnitude wordt het eerste bit, het sign bit, gebruikt om aan te geven of
een getal positief of negatief is.
Een 0 representeert een positief getal, een 1 een negatief getal. Op deze manier
kunnen er met 8 bits (1 Byte) getallen tussen de -127 en +127 gevormd worden.
                                       -127    1111 1111
                                      +127     0111 1111
en
                                        -88   1101 1000
                                       +88    0101 1000
Er is bij deze methode een nadeel omdat 0 op twee manieren gevormd kan wor-
den. Ook is het hardwarematig complex te implementeren.
Een andere methode is one’s complement.
Bij deze methode wordt er ook gebruik gemaakt van een sign bit. Alle bits worden
bij een negatief getal geïnverteerd. 3
                                        -88   1010 0111
                                       +88    0101 1000
Het blijkt dat computers, gezien als elektronische rekenapparaten erg efficiënt kun-
nen omgaan met one’s complement.
Toch is er nog steeds een probleem met de 0, er zijn nog steeds twee manieren
om 0 te vormen, namelijk 1111 1111 en 0000 0000.
Deze problemen kunnen worden opgelost door gebruik te maken van two’s com-
plement.
Bij negatieve getallen werkt dit als volgt: inverteer alle tekens en tel er vervolgens
1 bij op.
   3
     Inverteren kan worden gezien als het gebruik van de NOT operator.
5 Rekenen                                                                                     54
                            Het grootste getal   +127    0111 1111
                            Het kleinste getal   -128    1000 0000
                                        -88   1010 1111
                                       +88    0101 0001
Het voordeel van deze coderingsmethode is dat er maar één manier is om 0 te vor-
men. Ook is er een nadeel omdat het het bereik van -127 tot +128 asymmetrisch
is, maar computers hebben hier geen moeite mee. Dit is dan ook de reden dat het
in de huidige computers wordt gebruikt.
In programma’s waar gebruik wordt gemaakt van integers 4 moet worden uitge-
gaan van signed integers die dus zowel positief als negatief kunnen zijn en die
gebruik maken van two’s complement.
5.8.3      Two’s complement omzetten
Er zijn gevallen dat men een normale representatie van integers als unsigned inte-
gers om wil zetten naar signed integers die gebruik maken van two’s complement.
Dit kan worden gedaan met de instructie ’neg’. Neg zet de inhoud van de meege-
geven operand om naar een two’s complement getal. Het inverteert alle bits en telt
er daarna één bij op.
In assembly zou ’neg’ zo gebruik kunnen worden.
neg ax                                  ; ax wordt omgezet naar t c .
neg [ i n p u t f i e l d ]             ; de inhoud wordt omgezet naar t c .
neg edx                                 ; edx wordt omgezet naar t c .
5.9       Rekenen
Computers zijn niets meer of minder dan complexe tel- en rekenmachines. Reke-
nen is nog steeds de hoofdtaak. De rekenkundige instructies hebben direct invloed
op de waarden in de registers.
   4
     In C worden hoeven signed integers niet worden aangeven, in tegenstelling tot unsigned inte-
gers.
5 Rekenen                                                                           55
5.9.1       Increment en decrement
Increment en decrement zijn beide rekenkundige instructies, die men gebruikt bij
tellers en loops. 5
     • De increment instructie, ’inc’, telt één op bij de huidige waarde van het re-
       gister dat als operand is meegegeven.
       Bijvoorbeeld:
       mov ah , 12                ; ah=12
        i n c ah                  ; ah=13                 e i g e n l i j k ah=ah+1
        i n c ah                  ; ah=ah+1 o f ah++
       mov ebx , 99998
        i n c ebx                 ; ebx++      −> ebx=99999
     • De tegenhanger van increment is decrement, ’dec’, deze heeft een tegen-
       overgestelde werking en trekt één af van de huidige waarde in het register.
       mov d l , 88               ; d l =88
       dec d l                    ; d l −−      d l =87
5.9.2       Vermenigvuldigen en delen
Voor het rekenen met gehele getallen (integers) moet er in assembly rekening wor-
den gehouden met de twee verschillende representaties van integers. Daarom zijn
er bepaalde rekenkundige instructies in tweevoud.
Vermenigvuldigingen worden gemaakt met de ’mul’-instructie. De ’mul’-instructie
voert unsigned integer vermenigvuldigingen uit. Het wordt gebruikt als ’mul ope-
rand’, waarbij operand een geheugenadres of register kan zijn. Er zijn meerdere
mogelijkheden omdat de operands van grootte kunnen verschillen.
     • mul r/m8, AL Hier wordt de meegeven operand van 8 bits vermenigvuldigd
       met AL (8 bit). Het resultaat wordt in AX (16 bit) opgeslagen.
   5
     Meer over loops in het hoofdstuk 7 Programma structuur.
5 Rekenen                                                                              56
     • mul r/m16, AX De operand van 16 bit wordt vermenigvuldigd met AX (16
          bit). Het resultaat wordt opgeslagen in DX:AX.
     • mul r/m32, EAX Hierbij wordt de operand van 32 bit vermenigvuldigd met
          EAX (32 bit). Het resultaat wordt in EDX:EAX opgeslagen.
Compileer en link het onderstaande assembly voorbeeld.
Laadt het programma in ALD en bekijk het resultaat. Ga na wat er gebeurt bij de
vermenigvuldigingen en welke registers erbij betrokken zijn.
 s e c t i o n . data
                getal1    db  0x8a
                getal2    db  0x6b
                getal3    dw  0x4141
                getal4    dw  0x4545
                getal5    dd  0x8a8a8a8a
                getal6    dd  0x9c9c9c9c
 section . text
 global _start
 _start :
                nop
                mov a l , [ g e t a l 1 ]
                mul b y t e [ g e t a l 2 ]      ; AX= g e t a l 2 ∗ g e t a l 1
                mov ax , [ g e t a l 3 ]
                mul word [ g e t a l 4 ]         ; DX: AX= g e t a l 4 ∗ g e t a l 3
                mov eax , [ g e t a l 5 ]
                mul dword [ g e t a l 6 ]        ; EDX: EAX= g e t a l 6 ∗ g e t a l 5
 exit :
                mov eax , 1
                x o r ebx , ebx
                i n t 0x80
Het voorbeeld demonstreert hoe de vermenigvuldiging van unsigned integers gaat
in assembly. Het vermenigvuldigen van signed integers gaat op een andere wijze.
Hiervoor wordt de ’imul’-instructie gebruikt (NASM doc. A.76).
5 Logische operatoren en maskers                                                  57
Het delen in assembly gebeurt op bijna dezelfde wijze als vermenigvuldigen. Voor
meer informatie over delen en de manier waarop dit gebeurt zie de documentatie
bij NASM section A.25 over de ’div’-instructie voor unsigned integers en de ’idiv’-
instructie voor signed integers.
5.10       Logische operatoren en maskers
Bij het vorige voorbeeld, dat een jump demonstreerde, staat op regel 26 ’xor ebx,
ebx’, terwijl in de andere voorbeelden ’mov ebx, 0’ stond. In dit geval is de uitwer-
king van de instructies gelijk, namelijk het laden van ebx met het getal ’0’.
Assembly kent de volgende logische operatoren: XOR, OR, AND en NOT. Ze wor-
den meestal gebruikt bij het toepassen van maskers.
5.10.1      AND
Het resultaat van de AND operator bij twee bits is alleen een 1 als beide 1 zijn.
Hieronder staat de waarheidstabel van de AND operator.
                                  A    B   A AND B
                                  0    0       0
                                  0    1       0
                                  1    0       0
                                  1    1       1
    • Met AND maskers kan er getest worden op bepaalde bits. Zo kan de AND
       operator worden gebruikt bij het isoleren van bits.
                                      1111 0001
                                      1000 0000 AND
                                      1000 0000
       Dit kan als volgt in assembly worden gebruikt:
       mov          al ,      0xf1        ; a l i s een 8 b i t s r e g i s t e r
       and          al ,      0x80        ; a l i s nu 0x80
       Het resultaat is dat het AL-register de waarde 0x80 bevat. Om dit beter te
       testen kan men er een assembly programma van maken en het laden in een
       debugger.
5 Logische operatoren en maskers                                               58
    • Bij dit voorbeeld wordt hetzelfde AND masker gebruikt en het geeft aan dat
      het MSB bit een 0 is.
                                     0111 0001
                                     1000 0000 AND
                                     0000 0000
      In assembly had dit er er zo uit kunnen zien.
      mov         bl ,      0x71        ; b l bevat 0x71
       and        bl ,      0x80        ; pas een masker van 0x80 t o e
      Na het draaien van het voorbeeld bevat het BL-register de waarde 0000
      0000.
5.10.2     OR
De logische OR operator wordt vaak gebruikt om individuele bits te veranderen
zonder een bewerking uit te voeren over de andere bits.
De logische OR heeft altijd als uitkomst een 1 als één van de te testen bits 1 is.
Zijn beide een 0 dan is de uitkomst een 0, anders geeft de OR altijd een 1.
Zie hier de waarheidstabel van de logische OR.
                                  A   B   A OR B
                                  0   0      0
                                  0   1      1
                                  1   0      1
                                  1   1      1
    • Het volgende voorbeeld demonstreert het gebruik van de OR operator, die
      gezien kan worden als het tegengestelde van de AND operator.
                                      0010 1011
                                      1001 0010 OR
                                      1011 1011
      Als we dit naar assembly omzetten wordt het gelijkwaardig met.
5 Logische operatoren en maskers                                              59
      mov          cl ,       0x2b         ; c l =0x2b
       or          cl ,       0x92         ; c l i s h i e r n a 0xbb
      Door een logische OR van 0x92 op het CL-register toe te passen dat 0x2b
      bevat, verandert de waarde in 0xbb.
5.10.3     XOR, exclusive OR
De logische XOR operator is gelijk aan de OR, maar is er één verschil. Een XOR
van 2 bits is alleen 0 als beide bits gelijk zijn, anders is het resultaat 1.
Zie hier de waarheidstabel van de exclusive OR.
                                  A    B    A XOR B
                                  0    0         0
                                  0    1         1
                                  1    0         1
                                  1    1         0
    • In het volgende voorbeeld wordt een demonstratie gegeven van het gebruik
      van de XOR.
                                       0010 1010
                                       1001 1111 XOR
                                       1011 0101
      In assembly zou dit er zo uitzien.
      mov          dl ,       0x2a         ; d l =0x2a
       xor         dl ,       0x9f         ; x o r r e n van d l met 0 x 9 f
      Na het draaien van het stukje assembly code bevat het DL-register de waar-
      de 0xb5. Dit omdat 0x2a xor 0x9f gelijk is aan 0xb5.
    • De XOR kan ook gebruikt worden om bits om te draaien, 0 naar 1 en 1 naar
      0.
                                       1010 1010
                                       1111 1111 XOR
                                       0101 0101
5 Logische operatoren en maskers                                                60
   • In de sourcecode die een jump demonstreert, wordt gebruik gemaakt van
     een de XOR in plaats van de ’mov’-instructie om een register de waarde 0
     te geven. Een XOR masker van twee dezelfde waarden heeft als gevolg 0
     (zie de waarheidstabel).
     Dit is een veel voorkomend iets in assembly, het volgende voorbeeld demon-
     streert dit. Het is een logisch gevolg als je bedenkt dat de XOR altijd een 0
     geeft als beide bits gelijk zijn.
                                       1110 0101
                                       1110 0101 XOR
                                       0000 0000
     Omgezet in assembly ziet het er zo uit.
     mov a l , 0xe5          ; a l =0xe5
      x o r a l , 0xe5       ; x o r r e n van a l met 0xe5
     Of direct via de registers met.
      xor al , a l        ; a l =0
     Het AL-register is na de instructie ’xor al, al’ altijd 0.
5.10.4     NOT
De NOT operator verschilt van de andere operators. Het maakt gebruik van één
operand en wordt daarom ook wel een unary operator genoemd.
De NOT van een bit is de tegenovergestelde waarde van de huidige bit.
De waarheidstabel.
                                      A    NOT A
                                      0      1
                                      1      0
   • Een voorbeeld van het gebruik van de NOT operator.
                                       1000 1000 NOT
                                       0111 0111
5 Logische operatoren en maskers                                                   61
         In assembly code ziet het er zo uit.
         mov          cl ,         0x88        ; c l =0x88
          not         cl                       ; c l i s nu 0x77
         Het CL-register bevat na de instructie ’not cl’ de waarde 0x77 in plaats van
         0x88.
De ’not’-instructie wordt ook gebruikt bij het omzetten van getallen naar one’s com-
plement.
5.10.5         TEST
De instructie ’test’ wordt op dezelfde manier gebruikt als de AND operator en heeft
dezelfde waarheidstabel, maar het wijzigt de registers die als operands worden
gegeven niet. Het verandert alleen het EFLAGS register.
De ’test’-instructie heeft meerdere toepassingen, hier een korte demonstratie er-
van. In dit voorbeeld wordt test gebruikt om te zien of het eerste bit in het CL-
register gelijk is aan 1. Is het gelijk aan 0 dan wordt het ZF (zero flag) op 1 gezet.
Omdat 0xf0 AND 0x80 een 1 oplevert en ZF daarom 0 is, wordt er niet gejumpt
naar ’end’. De ’jz’ 6 jump wordt alleen gemaakt als JZ (Zero Flag op het EFLAGS
register) een 1 is.
s e c t i o n . data
        f o o db " t e s t −t e s t " , 0xa
        l e n equ $ − f o o
section . text
global _start
_start :
        mov c l , 0 x f 0         ; 11110000
        t e s t c l , 0x80        ; 10000000
; 1111 0000
; 1000 0000 AND
; −−−−−−−−−
   6
     In hoofdstuk 6 wordt er meer informatie gegeven over jumps.
5 Logische operatoren en maskers  62
; 1000 0000
;
; D i t i s o n g e l i j k aan 0
; Zero Flag ( ZF ) = 0
; j z jumpt a l s ZF een 1 i s .
; ZF = 0 dus geen jump
      j z end
; druk f o o a f
      mov eax , 4
      mov ebx , 1
      mov ecx , f o o
      mov edx , l e n
      i n t 0x80
end :
      mov eax , 1
      x o r ebx , ebx
      i n t 0x80
5 Vragen en opdrachten                                                          63
5.11      Vragen en opdrachten
   1.   (a) Is het mogelijk om registers in een processor direct te wijzigen?
        (b) Leg uit wat extended registers zijn.
        (c) Hoeveel bits zitten er in een byte, een word en een double word?
   2.   (a) Waar dient het CS-register voor?
        (b) Wat is de instructie pointer en waar wijst het naartoe?
        (c) Kan het EIP-register door bijvoorbeeld de ’mov’-instructie worden ge-
             wijzigd? Waarom wel/niet?
        (d) Op welke manier werkt de instructie pointer?
   3.   (a) Waarom bestaat assembly sourcecode uit meerdere segmenten/secti-
             ons?
             Maak een link naar het geheugenmodel.
        (b) Wat is het nut van segment registers?
        (c) Kan een assembly programmeur de waarden in bijvoorbeeld FS of CS
             wijzigen? Laat de assembler, in dit geval NASM, dit toe?
             Probeer dit uit.
   4. Waarom kan linux 64GB aan geheugen adresseren, terwijl dit niet mogelijk
      is als er naar de breedte van de registers wordt gekeken?
   5. Leg uit waarom het handig is om registers in twee delen te splitsen, een
      ’low’, L deel en een ’high’, H deel?
   6. Stel dat de waarde van AX wordt veranderd. Heeft dit gevolgen voor EAX en
      voor AH?
   7.   (a) Om een bepaalde structuur te krijgen binnen een programma moeten
             er voorwaarden worden getest. Hoe wordt dit gedaan in assembly?
        (b) Beschrijf de werking van de carry flag op het EFLAGS register.
        (c) Wat doet de ’clc’-instructie? Wat voor nut heeft het? Geef een source-
             code waarin een demonstratie staat met de werking ervan.
        (d) ALD laat de hexadecimale waarde zien van het EFLAGS register. Waar-
             om is dit?
   8. Software die geschreven is voor de 8086 draait ook op de 386. Leg uit
      waarom dit mogelijk is.
5 Vragen en opdrachten                                                             64
    9. De registers in een processor zijn direct verantwoordelijk voor wat er in de
        computer gebeurt. Leg uit waarom het wijzigen direct invloed heeft op de
        handelingen van de computer.
  10.     (a) Wat is de functie van de general-purpose registers?
          (b) Mogen de general-purpose registers voor andere taken worden ge-
              bruikt dan waarvoor ze zijn bedoeld?
  11.     (a) Hoeveel bit is het AX-register?
          (b) Hoeveel bit is het AL-register; en het EAX-register?
          (c) Is het BX-register in de 8086 even lang als het BX-register in de 386?
  12. Wat is het nut en de uitwerking van de nop instructie? Gebruik hierbij de
        NASM manual.
  13. De volgende sourcecode is ongeldig. Er wordt de volgende foutmelding ge-
        genereerd: ’invalid combination of opcode and operands’.
        section . text
        global _start
        _start :
              mov bx , 0x555
              mov eax , bx
        end :
              mov eax , 1
              x o r ebx , ebx
               i n t 0x80
          (a) Geef de reden van de ongeldigheid.
          (b) Vervang regel 6, ’mov eax, bx’ door ’movzx eax, bx’.
          (c) Compileer en debug het programma.
          (d) Geef een toelichting over de mnemonic ’movzx’ 7 .
   7
     Voor meer informatie over over ’movzx’ zie de NASM handleiding.
5 Vragen en opdrachten                                                          65
  14.   (a) Geef van alle vier de verschillende operatoren een voorbeeld en be-
            schrijf het nut er van.
        (b) Wat is gevolg van ’xor edx, edx’? Welke waarde bevat het EDX-register
            na deze instructie.
  15. Vul de ontbrekende waarden in.
             1010 1101
        (a)  1110 0101 AND
             ...
             1111 1101
        (b)  1010 0111 OR
             ...
             1010 1101
        (c)  1010 0000 XOR
             ...
             1100 1101 NOT
        (d)
             ...
  16.   (a) Waarom zijn er twee type integers? Geef ook aan welke coderingsme-
            thode beide gebruiken.
        (b) Leg uit hoe signed integers in moderne computers worden gebruikt.
            Licht kort het sign bit toe.
        (c) Zet het two’s complement getal 1100 1101 om naar een decimaal getal.
        (d) De ’neg’-instructie zet getallen unsigned integers om naar signed inte-
            gers in two’s complement. Bestudeer de werking van ’neg’ en schrijf
            zelf een programma dat een normale gerepresenteerde waarde van
            een register of geheugenadres omzet naar two’s complement. (hint:
            Gebruik ALD om het programma te testen en lees de bondige docu-
            mentatie over ’neg’ in de NASM handleiding.)
  17. Het delen van getallen gaat op bijna dezelfde wijze als het vermenigvuldigen
      in assembly. Schrijf een programma dat deelt aan de hand van 8, 16 en
      32-bit getallen. Deze getallen zijn unsigned integers en er moet gebruik
      gemaakt worden van de ’div’-instructie. Voor meer informatie zie de NASM
      handleiding over ’div’.
Hoofdstuk 6
Taal niveaus
Dit hoofdstuk beschrijft de verhouding van assembly ten opzichte van High Level
languages. Er wordt beschreven hoe assembly is ontstaan en waarom men nu
vooral in hogere programmeertalen programmeert. HLL en assembly zijn te com-
bineren en hier wordt dan ook een kort voorbeeld van gegeven.
Ook wordt er aandacht besteed aan assemblers, in dit geval NASM en de moge-
lijkheden ervan, zoals het schrijven van macro’s.
6.1      Assembly language
Een processor ’verstaat’ strikt gezien alleen maar machinetaal. Deze taal is niet
bruikbaar om in te programmeren. Er zou dan met geheugenadressen en instruc-
ties als numerieke waarden gewerkt moeten worden. Om toch op low-level gebied
te kunnen programmeren is er een assembly language. Assembly zorgt ervoor dat
er direct met de processor gecommuniceerd kan worden, maar wel via een taal die
voor mensen leesbaar is. Elke instructie kan naar mnemonics worden omgezet.
Iedere assembly mnemonic komt overeen met een instructie. Dit is de reden dat
assembly machinegericht is. Er zijn veel verschillende processor architecturen met
elk een eigen assembly taal.
6.2      Low-level languages
In de jaren ’50 werd de assembly language ontwikkeld, omdat het niet meer mo-
gelijk was om in machinetaal te programmeren; de software werd te complex en
bevatte te veel regels code. Alle codes werden geprogrammeerd in numerieke
waarden. Assembly loste dit op door het gebruik van mnemonic’s; dit zijn woorden
die overeenkomen met machinetaalinstructies.
6 High Level Languages                                                          67
Mnemonic’s zijn veel gemakkelijker te onthouden dan numerieke waarden. Zo is
er de mnemonic voor optellen, ’add’ en voor aftrekken ’sub’. Als bijvoorbeeld de
waarde in het register EAX en de waarde in EBX opgeteld moeten worden en weer
opgeslagen worden in EAX, dan zou dit in machinecode er bijvoorbeeld als volgt
uit zien: 03 03. In assembly kan het zo worden geschreven: ’add eax, ebx’.
Assembly languages maken gebruik van assemblers. Dit is software die assem-
bly sourcecode omzet naar machinetaal. Een processor heeft een unieke set aan
machinetaalinstructies, dit is de reden dat het ook een eigen assembly language
heeft. Dit heeft tot gevolg dat assemblyprogrammatuur alleen geschreven kan wor-
den voor een bepaald type processor.
Assembly komt programmeurs tegemoet door mnemonic’s te gebruiken voor in-
structies in plaats van numerieke representaties. Maar nog steeds bestaat een
zeer simpele handeling uit vele instructies. Dit zorgt ervoor dat het programmeren
in assembly veel tijd kost. Ondanks dat sommige programmeurs gebruik maken
van vele bibliotheken met voorgeprogrammeerde routines, neemt dit niet het ba-
sisprincipe van assembly weg. Er moet nog steeds veel tijd aan de werking van de
routines worden besteed.
6.3      High Level Languages
Op een hoger niveau staan de hogere programmeertalen, HLL (High Level Lan-
guages), die probleem gericht werken. Deze talen zijn niet machine afhankelijk.
De operaties uit de hogere programmeertalen zijn gericht op problemen die vaak
voorkomen. Denk hierbij aan tellers en andere routines voor voorwaarden en pro-
gramma flow. De problemen worden opgelost zonder specifieke machinetaal in-
structies te gebruiken.
Als er code is geschreven in een hogere programmeertaal is het de taak van een
6 Samenwerking tussen C en assembly                                              68
compiler om die om te zetten naar machinecode. Er wordt op deze manier een
uitvoerbaar binaire file gevormd met machinetaal. De compiler voor de hogere
programmeertaal leest de sourcecode en vertaalt het naar assembly die precies
doet wat er in de hogere programmeertaal was beschreven. De assembly code
bestaat nu uit veel meer regels code dan de oorspronkelijk HLL sourcecode.
High Level Languages zijn ontwikkeld in de jaren rond 1955. De eerste taal was
FORTRAN, gevolgd door Algol, Cobol en Lisp. Bekende moderne high-level lan-
guages zijn Pascal, C, C++. Deze high-level languages maken gebruik van compi-
lers. Dit is software die de sourcecode van HLL omzet in machinetaal afhankelijke
objectcode. Scripting en Virtual Machine worden hier buiten beschouwing gelaten,
omdat ze indirect naar machinecode worden omgezet.
Strikt gezien is C geen HLL omdat het in C ook mogelijk is om low-level taken uit te
voeren. Zo ondersteunt C indirect het gebruik van registers, low-level geheugen-
manipulatie, goto-statements en het schuiven van bits en dergelijke. In dit dictaat
wordt C gebruikt als HLL om bijvoorbeeld while- en for-statements te demonstreren
in assembly.
6.4         Samenwerking tussen C en assembly
Het is mogelijk om programmatuur te schrijven die deels is geschreven in een HLL
zoals C of C++ en in assembly. Omdat C het gebruik van functies aanbiedt kunnen
we sommige functies (routines) in assembly schrijven. De functies geschreven in
assembly kunnen sneller en efficiënter zijn dan die in een HLL geschreven zijn.
In de Linux kernel gebeurt hetzelfde, de machineafhankelijke taken worden uitge-
voerd door assembly functies die vanuit de C code worden aangeroepen. Omdat
een groot deel van de kernel op deze manier in C is geschreven is het in zeer
hoge mate te porten naar andere architecturen. (Alleen de machine afhankelijke
assembly functies hoeven herschreven te worden.)
Het volgende (zeer korte) voorbeeld demonstreert een functie geschreven in as-
sembly die samenwerkt met C. Omdat er mnemonics worden gebruikt die nadere
uitleg nodig hebben van begrippen die pas in de volgende hoofdstukken worden
uitgelegd is het voorbeeld beperkt.
De inhoud van de de file ’asm_code.asm’.
 section . text
 g l o b a l asmcode
6 Samenwerking tussen C en assembly                                              69
asmcode :
               enter           0 ,0
               mov             eax ,        0x12
               leave
               ret
De sourcecode van ’c_code.c’
# i n c l u d e < s t d i o . h>
 /∗
               p r o t o t y p e n van de asm f u n c t i e
               omdat anders de c o m p i l e r de
               f u n c t i e n i e t kent .
 ∗/
 e x t e r n i n t asmcode ( v o i d ) ;
 i n t main ( v o i d ) {
 i n t g e t a l =0;
               g e t a l =asmcode ( ) ;
               p r i n t f ( "%d \ n " , g e t a l ) ;
               return 0;
 }
Compileer de assembly functie met NASM met ’nasm -f elf asm_code.asm’. Dit
zorgt ervoor dat er objectcode in asm_code.o komt te staan. Deze objectcode kan
door de C compiler (GCC) worden gelinkt met een C programma.
Dit gebeurt door ’gcc asm_code.o c_code.c -o c_asm’ te geven.
GCC kan zowel objectcode (asm_code.o) als C code (c_code.c) omzetten naar
een executable. Het resultaat, een executable, wordt door de optie ’-o’ naar de file
’c_asm’ geschreven.
Deze kan uitgevoerd worden en het resultaat is 18, omdat 0x12 in decimaal 18 is.
Alle commando’s nog eens in het kort:
nasm -f elf asm_code.asm
gcc asm_code.o c_code.c -o c_asm
6 Low-level power!                                                              70
./c_asm
Dit voorbeeld demonstreert dat het mogelijk is om vanuit de ene taal functies aan
te roepen uit de andere taal.
De assembly code wordt in dit voorbeeld aangeroepen vanuit de de ’main’ functie
van het C programma. Het resultaat van het assembly programma, de return waar-
de, wordt in het EAX-register gezet en wordt in de C code in de variabele ’getal’
gezet. Vervolgens wordt deze naar het scherm geschreven.
In printf staat %d om het getal af te drukken; dit zorgt ervoor dat de decimale
waarde van het getal wordt gebruikt. (Er wordt geen gebruikt gemaakt van de ascii
waarden.)
6.5      Low-level power!
Assembly geeft de programmeur directe controle over de computer. Dit is de voor-
naamste reden dat mensen geïnteresseerd zijn in assembly.
Voor de mensen die computers alleen maar gebruiken om software op te draai-
en is software zeer abstract. Programmeurs willen het gedrag van een computer
kunnen beïnvloeden en omdat assembly platform afhankelijk is, is dit geen gemak-
kelijke taak.
De 386 is historisch gezien van redelijk groot belang. De huidige generatie pro-
cessoren van Intel zijn allemaal gericht op die 32-bits processor. De assembly
language van de 386 is een standaard geworden op assembly gebied. Dit omdat
de Intel 386 vastgeroest zit aan assembly programmeren. Omdat de 386 gebruik
maakt van protected mode kunnen er krachtigere applicaties worden geschreven
die ook nog eens 32-bit zijn.
Assembly kent geen variabelen of andere HLL principes. Toch biedt het de beste
middenweg tussen een machinetaal en een HLL. Door het gebruik van macro’s en
subroutines kan 1 regel veranderen in duizenden bytes aan machinetaal.
Er zijn legio voordelen die pleiten voor assembly. Maar het meest voor de hand
liggend is het toegang hebben tot het lage niveau van de computer, en de totale
controle over de CPU. Software die is geschreven in HLL is meestal trager dan
assembly software, omdat een compiler standaard methoden gebruikt voor lezen
en schrijven, het gebruik van variabelen en het aanroepen van routines uit eerder
gecompileerde software. Een goed voorbeeld hiervan is het gebruik van de stack.
Functies in HLL maken veelal gebruik van het stack principe. Code geschreven in
een HLL, kan er wiskundig correct en efficiënt uitzien, maar kan op een totaal on-
handige wijze omgaan met een stack. Dit kan software onnodig langzaam maken.
6 Low-level power!                                                              71
Assembly biedt de mogelijkheid om absoluut optimaal doelmatige software te schrij-
ven. Het is bij assembly namelijk mogelijk om software te maken die minder in-
structies gebruikt dan HLL, daarom zijn assembly programma’s meestal kleiner en
sneller.
De nadelen van assembly zijn: een verhoogde kans op fouten in de software
(bugs), het is processor afhankelijk, er zijn geen library-routines voor veel voor-
komende taken, zoals het afdrukken van tekenreeksen of het lezen van gegevens.
De bugs in software zijn een gevolg van onzorgvuldigheid; dit staat los van het
gebruik van de programmeertaal. Het is zeker mogelijk om bugvrije software te
schrijven in assembly. Toch is het zo dat een bug in assembly sourcecode meer
invloed heeft dan bij HLL. Om dit te voorkomen is het belangrijk assembly code
goed te ontwerpen en te debuggen.
Assembly wordt direct omgezet naar machinetaal en het is daarom vanzelfspre-
kend dat het afhangelijk is van de gebruikte processor. Dit maakt het porten van
software een zware tot onmogelijke taak.
Ook biedt assembly geen mogelijkheden zoals voorgeschreven functies voor be-
rekeningen en strings. Dit kan vervelend lijken, maar in werkelijkheid heeft het
echter grote voordelen. Dit heeft tot gevolg dat assembly code transparanter en
doelmatiger kan worden geschreven.
6 NASM                                                                             72
6.6      NASM
Assembly sourcecode wordt door een assembler omgezet naar machinecode. NA-
SM is een assembler en staat voor Netwide Assembler. Het is een assembler voor
de Intel 80x86 en die zo is ontworpen dat het gemakkelijk te porten is naar meerde-
re operating systems. Ook ondersteunt het verschillende soorten formaten, zoals
bin, aout, coff, elf, as86, obj (DOS), PE (win32), rdf (het eigen formaat van NA-
SM). NASM maakt gebruik van de Intel syntax, net als TASM en MASM. TASM
en MASM zijn beiden geen opensource en draaien niet op Unices, tenzij in een
DOS-emulator. 1
De andere assembly syntax is de AT&T syntax, die de statements net andersom
interpreteert als Intel syntax. De gebruikte syntax is niet belangrijk voor het leren
van de principes van assembly; het is alleen van belang bij het programmeren.
GAS is een AT&T syntax assembler van GNU. Het is eigenlijk een back-end van
GCC en is daarom niet echt geschikt als assembler. Toch maakt GNU gebruik van
de AT&T syntax. Dit kan nogal vervelend zijn bij het gebruik van andere GNU tools,
zoals het debugging programma GDB, waarbij alles in AT&T stijl staat. Er bestaan
software tools die de ene syntax omzetten de andere. Meestal werken deze tools
niet optimaal en is kennis van beide vereist.
6.6.1     NASM macro’s
Met NASM is het mogelijk om gebruik te maken van macro’s. Macro’s maken
het mogelijk om bijvoorbeeld files te includen en mechanismen te programmeren
voor taken die vaak voorkomen. Macro’s kunnen worden gezien als preprocessor
opdrachten.
In het onderstaande voorbeeld bevat ’syscall.mac’ alle assembly instructies die
een write en een exit system call mogelijk maken.
Het bestand ’macro.asm’ maakt gebruik van de macro’s door de file ’syscall.mac’
te includen en de code ervan te gebruiken.
De inhoud van het bestand ’syscall.mac’.
%macro w r i t e 3
 ; gebruik : write        f d message msglength
            mov eax ,    4
            mov ebx ,    %1
            mov ecx ,    %2
   1
     http://www.dosemu.org
6 NASM                                                                      73
                mov edx , %3
                 i n t 0x80
%endmacro
%macro e x i t 1
; g e b r u i k : e x i t status
                mov ebx , %1           ; e r r o r status , 0 i s success
                mov eax , 1
                 i n t 0x80
%endmacro
Zie hieronder de inhoud van ’macro.asm’. Dit bestand kan net als andere assem-
blyprogramma’s worden gecompileerd en gelinkt worden. Macro’s worden door
NASM geïnterpreteerd, ze hebben geen uitwerking op de executable die door com-
pileren en linken wordt gemaakt.
%i n c l u d e " s y s c a l l . mac "
s e c t i o n . data
msg db " W r i t e s y s c a l l u s i n g macro ’ s " , 0xa
l e n equ $ − msg
section . text
global _start
_start :
        w r i t e 1 , msg , l e n
        exit 0
Voor meer informatie over NASM macro’s zie chapter 4 van de manual.
6 Vragen en opdrachten                                                         74
6.7     Vragen en opdrachten
   1. Machinecode bevat de instructies voor de processor. Bevat de door de as-
      sembler gegenereerde machinecode nog afhankelijke delen? Delen die nog
      niet berekend en ingevuld konden worden zonder het programma te draai-
      en? Licht je antwoord toe.
   2. Wat is het verschil tussen machinetaal en assembly?
   3. Wat is het verband tussen machinetaal en assembly?
   4. Waarom kan in assembly geprogrammeerde software moeilijk worden ge-
      port?
   5. Geef twee redenen waarom er in HLL wordt geprogrammeerd door de mees-
      te programmeurs.
   6. Geef een voorbeeld van een programmeerproject dat het best in assembly
      kan worden uitgevoerd en een voorbeeld van een project dat beter in een
      HLL kan worden uitgevoerd. Onderstreep hierbij de voordelen en nadelen
      van assembly. Zou men hierbij ook een combinatie tussen HLL en assembly
      kunnen kiezen?
   7. Leg uit waarom het mogelijk is om vanuit een assembly programma een C
      functie aan te roepen of vise versa. Gebruik hierbij de term objectcode.
   8. Tekenreeksen zijn in C character arrays. Waarom bevatten ze een 0 aan
      het einde van de character array (string)? Maak de terugkoppeling naar
      assembly niveau.
Hoofdstuk 7
Programma structuur
In de vorige hoofdstukken is er een korte uitleg gegeven over de manier waarop de
processor omgaat met instructies en de manier waarop deze worden uitgelezen uit
het code (.text) segment. Ook is er aandacht besteed aan jumps om de volgorde
van executie te beïnvloeden. In dit hoofdstuk wordt hier dieper op ingegaan.
In HLL (High Level Language) zijn er statements zoals bijvoorbeeld if, else en
while. Deze worden toegepast om op een gemakkelijke manier om te gaan met
voorwaarden en programma structuur. In assembly ligt dit anders; er wordt gebruik
gemaakt van jumps en het testen van bepaalde bits op het EFLAGS register. Dit
gebeurt aan de hand van vergelijkingen door de ’cmp’-instructie.
Een HLL zoals C maakt gebruik van functies die gezien kunnen worden als jumps,
maar die na het uitvoeren van de code binnen de functie weer de oude program-
magegevens kan bevatten. Dit gebeurt met gebruik van een speciaal deel binnen
het geheugen, de stack. In dit hoofdstuk wordt hiervan een korte beschrijving
gegeven.
7 Instructie executie                                                                             76
7.1        Instructie executie
Computers kunnen met de uitvinding van Von Neumann instructies intern opslaan.
De instructies worden bewaard in het geheugen (RAM) en uitgevoerd door de pro-
cessor. Op deze manier kan men programma’s zien als een lijst van instructies,
die door de processor worden uitgevoerd. Het uitvoeren en uitlezen van instructies
                        Figuur 7.1: Een simpel uitgevoerde computer
                                                                                 1
wordt ’fetch-execute cycle’ genoemd en bestaat uit drie stappen.
     1. De processor haalt een instructie op uit het geheugen.
     2. De processor voert de instructie uit.
     3. Ga naar 1
Bijna alle computers zijn gebaseerd op deze methode met uitzondering van DNA
computers en quantum computers die alleen nog maar in onderzoekscentra wor-
den gebruikt.
    1
      De werkelijke cyclus is de ’Von Neumann-cyclus’, die uit vijf stappen bestaat, maar omdat niet
alle details direct van belang zijn bij het schrijven en begrijpen van assembly worden ze hier buiten
beschouwing gelaten.
7 Structuur door vergelijking                                                                  77
7.2       Structuur door vergelijking
Assembly kent geen geavanceerde methoden om de volgorde van executie te ver-
anderen zoals bijvoorbeeld C met if- en for-statements.
In assembly wordt er gebruik gemaakt van een elementaire manier om met struc-
tuur om te gaan. Deze manier kan worden gezien als het goto 2 statement.
Om structuur aan te brengen in programma’s moeten er data vergeleken worden
en moet aan de hand hiervan een beslissing worden gemaakt. Het vergelijken in
assembly gebeurt aan de hand van de ’cmp’-instructie. Als resultaat, het verschil
tussen de twee operands van ’cmp’, zet het bepaalde flaggen op het EFLAGS re-
gister aan of uit.
Het gebruik van de ’cmp’-instructie is als volgt:
cmp links, rechts
Links en rechts zijn operands en kunnen worden vervangen door een getal en/of
een register. 3
Het verschil van links - rechts wordt berekend en de flaggen worden gezet.
                              links = rechts    ZF = 1      CF = 0
                              links > rechts    ZF = 0      CF = 0
                              links < rechts    ZF = 0      CF = 1
Omdat er twee manieren zijn om getallen (integers) te gebruiken ligt het bij het
gebruik van signed integers (die positief en negatief kunnen zijn) anders. Hierbij
wordt gebruik gemaakt van drie flags:
     • Zero flag (ZF)
     • Overflow flag (OF)
     • Sign flag (SF)
De overflow flag wordt gezet als het resultaat overflowt of underflowt. De sign flag
wordt gezet als het resultaat van de operatie negatief is.
                            links = rechts     ZF = 1      n.v.t.
                            links > rechts     ZF = 0      SF = OF
                            links < rechts     ZF = 0      SF = OF
   2
     Het goto statement kan sourcecode onleesbaar maken en resulteren in grote onduidelijkhe-
den. Toch is het onwaar om te zeggen dat het gebruik van goto geen gestructureerde code kan
opleveren. Sterker nog, een C compiler zet statements zoals if en else ook om in assembly code!
   3
     Het gebruik van twee getallen is onmogelijk en tegelijkertijd zinloos omdat het niet aangeeft
waar het resultaat geplaats wordt.
7 Jumps & flags                                                               78
De ’cmp’-instructie brengt wijzigingen aan op het EFLAGS register. Maar er zijn
meerdere instructies die het EFLAGS register aanpassen, enige aandacht hierbij
is dus gepast.
7.3          Jumps & flags
Er zijn twee verschillende soorten jumps te onderscheiden.
      • Onvoorwaardelijke jump (zonder condities)
      • Voorwaardelijke jumps (met condities)
De onvoorwaardelijke jump gebeurt met de ’jmp’-instructie. Er vindt geen test of
andere manier om voorwaarden te testen plaats.
De voorwaardelijke jumps jumpen pas na een bepaalde conditie.
Hieronder een lijst van voorwaardelijke (conditionele) jumps.
                          Voorwaardelijke jump       jumps als . . .
                          JZ                         ZF=1
                          JN                         ZF=0
                          JS                         SF=1
                          JNS                        SF=0
                          JO                         OF=1
                          JNO                        OF=0
                          JP                         PF=1
                          JNP                        PF=0
                          JC                         CF=1
                          JNC                        CF=0
Het is belangrijk om te begrijpen dat de code na de jump niet wordt uitgevoerd,
tenzij hier naartoe wordt gejumpt.
Het volgende voorbeeld demonstreert het gebruik van een onvoorwaardelijke of
onconditionele jump. De tweede string wordt door het gebruik van de jump niet op
het scherm gezet.
 s e c t i o n . data
 s t r i n g 1 db " D i t wordt a f g e d r u k t " , 0x0a
len1           equ $     −    string1
7 Jumps & flags                                                                79
s t r i n g 2 db " D i t wordt NIET a f g e d r u k t " , 0x0a
len2            equ $     −      string2
section . text
global _start
         _start :
         mov    eax , 4           ; system   c a l l n r . van w r i t e
         mov    ebx , 1           ; 1e arg :   f i l e descriptor ( stdout )
         mov    ecx ,  string1    ; 2e arg :  p o i n t e r naar l e n 1
         mov    edx ,  len1       ; 3e arg :  l e n g t e van s t r i n g 1
          int   0x80
; de assembler v e r v a n g t end door een geheugenadres
         jmp end
; deze s t r i n g wordt n o o i t a f g e d r u k t
         mov eax , 4
         mov ebx , 1
         mov ecx , s t r i n g 2
         mov edx , l e n 2
          i n t 0x80
end :
         mov eax , 1
         x o r ebx , ebx
          i n t 0x80
7.3.1         Het if-statement
Met het gebruik van voorwaardelijke jumps kunnen we C statements zoals if en
else of for nabootsen.
De sourcecode ’jnz.asm’ heeft de volgende werking: het vergelijkt het EAX-register
met 0, bevat EAX een 0 dan voert het ’if’ uit anders ’else’.
s e c t i o n . data
i f db " I F " , 0x0a
l e n equ $          −     if
7 Jumps & flags                                                                               80
 section . text
 global _start
 _start :
        x o r eax , eax
        cmp eax , 0
        j n z else
 ; het i f deel
        mov eax , 4                ;   system c a l l n r . van w r i t e
        mov ebx , 1                ;  1e argument : f i l e d e s c r i p t o r ( s t d o u t )
        mov ecx , i f              ;  2e argument : p o i n t e r naar l e n
        mov edx , l e n            ;  3e argument : l e n g t e van i f
         i n t 0x80
        mov eax , 3
        jmp end                    ; jmp naar end , else n i e t u i t v o e r e n
 ; h e t else d e e l
else :
        mov eax , 2
end :
        mov eax , 1
        x o r ebx , ebx
         i n t 0x80
In assembly gebeurt er dit: de inhoud van EAX wordt vergeleken met 0, zijn ze
gelijk dan wordt ZF=1 en CF=0. Dus de jump, ’jnz else’, vindt niet plaats, omdat
jnz alleen jumpt als ZF=0 is.
Met ’nasm -f elf jnz.asm’ wordt het gecompileerd en met ’ld jnz.o -o jzn’ wordt het
gelinkt. Als resultaat wordt er ’IF’ op het scherm gezet.
Het assemblyvoorbeeld kan worden gezien als de volgende pseudo C-code.
 i f ( eax ==0) {
               w r i t e (3 , " IF \ n " ) ;
7 Jumps & loops                                                                                 81
              eax =3;
 }
else {
              eax =2;
 }
      • Verander op regel 8 ’xor eax, eax’ in ’mov eax, 2’ en compileer en link het
         opnieuw. Verklaar de uitkomst, maak hierbij gebruik van ALD.
7.4       Jumps & loops
Eerder dit hoofdstuk was er gesteld dat er verschillende jumps waren. De reden
hiervan is dat het mogelijk is om getallen als signed en unsigned integers te ge-
bruiken. Beiden hebben een andere representatie en hebben voor jumps daarom
andere opcodes.
De in de vorige paragraaf gegeven lijst van jumps is niet makkelijk bruikbaar en bij
geavanceerde structuren is het niet toereikend. Daarom biedt de 80x86 nog een
set van jump instructies voor signed en unsigned integers.
         Signed integers        jumps als . . .     Unsigned integers       jumps als . . .
         JE, JZ                 links = rechts      JE, JZ                  links = rechts
         JNE, JNZ               links = rechts      JNE, JNZ                links = rechts
         JL, JNGE               links < rechts      JB, JNAE                links < recht
         JLE, JNG               links ≤ rechts      JBE, JNA                links ≤ rechts
         JG, JNLE               links > rechts      JA, JNBE                links > rechts
         JGE, JNL               links ≥ rechts      JAE, JNA                links ≥ rechts
De ’jump equal’ (JE) en ’jump not equal’ (JNE) zijn voor signed en unsigned inte-
gers hetzelfde. Sterker nog, ze zijn alleen maar een andere naam voor JZ en JNZ.
Elke jump heeft meerdere mnemonics voor dezelfde instructie. Dit kan vervelend
lijken, maar is in de praktijk gemakkelijk. Zo is ’jump less equal’ (JLE) hetzelfde als
’jump not greater’ (JNG).
7.4.1      Het while-statement
De volgende sourcecode is een while-statement in assembly. Er wordt gebruik
gemaakt van een JA 4 jump naar end.
    4
      JA wordt gebruikt bij unsigned integers, zie de tabel van jumps voor signed en unsigned inte-
gers.
7 Jumps & loops                                                                       82
Sla de source op in het bestand ’while.asm’ en compileer en link het. Nu het een
executable is kan het geladen worden in ALD om de werking te laten zien.
 s e c t i o n . bss
 b u f f e r resd 1
 section . text
 global _start
 _start :
         x o r eax , eax                    ; eax=0
         i n c eax                          ; eax=1
while :
         cmp eax , 10
         j a end
         mov [ b u f f e r ] , eax          ; eax opslaan i n b u f f e r
         ;   De code d i e h i e r zou staan wordt 10x h e r h a a l d .
         ;    eax wordt opgeslagen i n b u f f e r zodat e r b i j v o o r b e e l d
         ;   een system c a l l kan worden gemaakt met g e b r u i k van
         ;    eax . Het opslaan van eax en h e t h e t aanmaken en
         ;    g e b r u i k e n van b u f f e r i s n i e t n o o d z a k e l i j k .
         mov eax , [ b u f f e r ]          ; eax t e r u g h a l e n
         i n c eax
         jmp while
end :
         mov eax , 1
         x o r ebx , ebx
          i n t 0x80
Het lijkt misschien vreemd dat er een JA jump wordt gebruik die jumpt als links >
rechts terwijl als het vertaald wordt naar pseudo C-code men een < zou gebruiken.
Dit komt omdat er normaal de ’while’ in wordt gegaan nadat de voorwaarde geldig
is. In dit voorbeeld wordt de ’while’ juist verlaten.
Wees ervan bewust dat er duizenden manieren zijn om lussen of loops te maken!
7 Jumps & loops                                                                 83
Hieronder staat de pseudo C-code van ’while.asm’, die dezelfde uitwerking heeft
maar niet op dezelfde manier werkt.
unsigned i n t eax =1;
while ( eax <10) {
             / ∗ de code d i e 10x h e r h a a l d wordt ∗ /
            eax ++;
}
7.4.2     Het for-statement
De Intel processor heeft instructies geïmplementeerd voor het maken van loops.
Deze loop-instructies kunnen onder andere worden gebruikt bij het maken van for-
statements. De loop-instructies hebben standaard één operand, dit is het label dat
herhaald dient te worden (waarheen gejumpt wordt). Het EFLAGS register wordt
bij de loop-instructies niet gewijzigd.
     • loop Verlaagt ECX met 1, als ECX = 0 wordt er naar het label gejumpt.
     • loope, loopz Verlaagt ECX met 1, als ECX = 0 en ZF = 1 wordt er naar het
       label gejumpt.
     • loopne, loopnz Verlaagt ECX met 1, als ECX = 0 en ZF = 0 wordt er naar
       het label gejumpt.
Voor meer informatie over de verschillen tussen de loop-instructies zie Section
A.99 van de NASM handleiding.
Het onderstaande assembly ’snippet’ demonstreert een for-loop.
            mov ecx , 10
enter_loop :
             ; de code d i e 10x wordt h e r h a a l d
loop enter_loop
In pseudo C-code zou het er zo uit kunnen zien.
7 Stack                                                                       84
 f o r ( ecx =10; ecx >0; ecx −−) {
              / ∗ code d i e 10x wordt h e r h a a l d ∗ /
}
7.5        Stack
De stack is een abstract datatype dat veel wordt gebruikt in de informatica. De
stack heeft de eigenschap dat het element wat er als laatste wordt opgezet er als
eerste weer wordt afgehaald. Dit wordt ook wel LIFO, Last In First Out genoemd.
Om met elementen op de stack om te gaan zijn er twee instructie; PUSH en POP.
PUSH plaats een element op de stack en POP haalt er een element af.
Met de program stack, als er over assembly wordt gesproken, bedoelen we een
aaneenschakeling van geheugenadressen die data bevatten.
Op deze stack worden vooral variabelen, return adressen van functies en parame-
ters van functies bewaard. Dit zijn vooral dingen waar hogere programmeertalen
van afhankelijk zijn, toch wordt de stack direct gebruikt bij het programmeren in
assembly. Meestal gebeurt dit als er tijdelijk data opgeslagen moet worden en er
geen registers meer voor handen zijn omdat deze gebruikt (moeten) worden.
7.5.1      POP en PUSH
POP en PUSH zijn de meest voorkomende instructies met betrekking tot de stack.
Beiden hebben als operand een register dat 16-bit (word) of 32-bit (dword) moet
zijn. Dit betekent dat bytes pushen op de stack niet mogelijk is, ook wordt het
afgeraden om words te pushen om de verwarring te voorkomen.
Het onderstaande voorbeeld pusht/popt de inhoud van het EAX-register op de
7 Stack                                                                                        85
stack. Daarna plaats het de inhoud van EBX in EAX en popt het de ’oude’ waarde
van EAX in EBX die van de stack afkomt.
De werking van het programma is hetzelfde als de xchg-instructie, namelijk het
omwisselen van de inhoud van twee registers. Om de werking van de sourcecode
beter te begrijpen kan het in ALD geladen worden.
 section . text
 global _start
 _start :
 ; w i s s e l e n met g e b r u i k vd s t a c k
       mov eax , 0 x f f e e d d
       mov ebx , 0xaabbcc
       push eax                           ; push inhoud eax op de s t a c k
       mov eax , ebx                      ; inhoud ebx naar eax
       pop ebx                            ; oude inhoud eax i n ebx v i a s t a c k
 ; w i s s e l e n met xchg
       mov ecx , 0x1
       mov edx , 0x2
       xchg ecx , edx
end :
       mov eax , 1
       x o r ebx , ebx
        i n t 0x80
De werking van PUSH en POP zijn afhankelijk van het ESP-register 5 (de stack-
pointer). ESP bevat een offset in het stacksegment (SS). 6
PUSH plaats een dword in het geheugen door 4 van de inhoud van ESP af te
trekken en het op dat geheugenadres te plaatsen. Er wordt 4 van de pointer afge-
trokken omdat ESP een geheugenadres bevat in bytes en er een dword (4 Bytes)
wordt gepushed. 7
   5
     Het ESP-register en het EBP-register worden ook gebruikt bij het maken van stackframes,
details hierover staan niet in het dictaat. In hoofdstuk 6 Taalniveaus werden hiervoor de enter en
de leave instructies gebruikt.
   6
     Vaak is het data segment hetzelfde segment als het stack segment. Dit is te zien door de
inhoud van DS en SS te bekijken in ALD .
   7
     Eerder is gesteld dat men voorzichtig moet omgaan met het handmatig veranderen van het
ESP-register. De reden daarvan is dat na het handmatig veranderen van de stack deze niet meer
functioneert zoals men zou verwachten zonder aanpassingen.
7 Stack                                                                     86
Het volgende voorbeeld ’pushpop.asm’ demonstreert de werking van het ESP-
register. Om het beter te begrijpen kan men het voorbeeld inladen in ALD. Wees
ervan bewust dat de inhoud van het ESP-register van systeem tot systeem kan
verschillen.
section . text
global _start
_start :
      mov eax , 0xa       ;  eax=0xa                         esp=0xBFFFF910
      push eax            ;  p l a a t s 0xa op 0xBFFFF90C esp=0xBFFFF90C
      push dword 0xb      ;  p l a a t s 0xb op 0xBFFFF908 esp=0xBFFFF908
      push dword 0xc      ;  p l a a t s 0xc op 0xBFFFF904 esp=0xBFFFF904
      pop eax          ; eax=0xc                      esp=0xBFFFF908
      pop ebx          ; ebx=0xb                      esp=0xBFFFF90C
      pop ecx          ; ecx=0xa                      esp=0xBFFFF910
end :
      mov eax , 1
      x o r ebx , ebx
      i n t 0x80
Als ’pushpop’ in ALD geladen is, kan men de stack na de instructie ’push 0xb’
bekijken door de inhoud van het geheugen te bekijken (waar push de waarden
neerzet), oftewel de inhoud van het ESP-register. Let wel op dat alles in het
geheugen via de little-endian manier is opgeslagen.
Hier een kort snapshot van de uitkomst in ALD.
...
...
08048086 680B000000 push 0xb
ald> next
eax = 0x0000000A ebx = 0x00000000 ecx = 0x00000000 edx = 0x00000000
esp = 0xBFFFF908 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds = 0x0000002B es = 0x0000002B fs = 0x00000000 gs = 0x00000000
ss = 0x0000002B cs = 0x00000023 eip = 0x0804808B eflags = 0x00200346
0804808B 680C000000 push 0xc
7 Stack                                                                          87
ald> examine 0xBFFFF908
Dumping 20 bytes of memory starting at 0xBFFFF908 in hex
BFFFF908: 0B 00 00 00 0A 00 00 00 01 00 00 00 1A FA FF BF ................
BFFFF918: 00 00 00 00 ....
ald>
...
...
7.5.2     PUSHA/POPA
Het komt vaak voor dat men tijdelijk de data in de registers wil opslaan om bijvoor-
beeld een routine in te gaan waar de registers veranderen. Het is dan gemakkelijk
als de registers weer in de oude staat terug gezet kunnen worden.
Met de instructies pusha en popa pusht men de inhoud van de registers op de
stack. Er zijn twee typen te onderscheiden; word registers en double word regis-
ters.
    • Pushaw en popaw worden gebruikt bij word (16-bit) registers. Ze pus-
      hen/poppen AX, CX, DX, BX, SP, BP, SI en DI op/van de stack (niet in deze
      volgorde).
    • Pushad en popad worden gebruikt bij double word (32-bit) registers. Deze
      pushen/poppen EAX, ECX, EDX, EBX, ESP, EBP, ESI en EDI op/van de
      stack (niet in deze volgorde).
Bijvoorbeeld:
             ...
            pusha
             ; code d i e general −purpose r e g i s t e r s w i j z i g t .
            popa
             ...
7.5.3     PUSHF en POPF
PUSHF en POPF werken hetzelfde als PUSHA en POPA alleen pushen of poppen
ze niet alle general-purpose registers maar het EFLAGS register. Op deze manier
7 Stack                                                                      88
kan men altijd de inhoud van het EFLAGS register behouden en het later weer
gebruiken. Het is ook mogelijk om het EFLAGS register te poppen, te wijzigen en
daarna weer te pushen.
7 Vragen en opdrachten                                                              89
7.6    Vragen en opdrachten
   1.  (a) Wat is het verschil tussen conditionele en onconditionele jumps?
       (b) Wordt een onvoorwaardelijke jump altijd uitgevoerd?
   2. Noem twee een toepassingen waarbij jumps gebruikt kunnen worden.
   3. De code na een jump wordt die nog uitgevoerd? Leg uit wanneer wel en
      wanneer niet.
   4.  (a) Welke registers zijn betrokken bij het maken van een jump?
       (b) Wat is de invloed van een jump op het instructieregister (EIP)?
   5.  (a) Schrijf een for-loop achtige constructie die 100 keer een bepaalde
            string op het scherm schrijft. Probeer hierbij zo min mogelijk instructies
            te gebruiken.
       (b) Test of het loop programma van de vorige opdracht inderdaad het
            EFLAGS register ongewijzigd laat. Doe dit door het programma in ALD
            te laden.
   6. Verander in de sourcecode van ’jnz.asm’ de jump naar een andere jump,
      maar doe het zo dat de werking exact hetzelfde blijft.
   7. Schrijf een assembly programma met een lus die van 1 tot 10 telt. Deze
      getallen worden opgeteld in een general-purpose register naar keuze. Toon
      de werking ervan aan in ALD.
   8. Leg de wijze waarop het datatype stack werkt uit.
   9. Waar dient de stack als deel van het geheugen voor?
Bijlage A
NASM installeren
NASM (Netwide Assembler) is een opensource assembler voor Intel 80x86 proces-
soren. Omdat het opensource is kunnen we een tarball downloaden met daarin de
source, die we vervolgens gaan compileren en installeren.
A.1      Downloaden van de source
Download de sourcecode van laatste versie van NASM via http van:
http://www.kernel.org/pub/software/devel/nasm/source/
De tarball met de de sourcecode heeft een naam die als volgt is opgebouwd nasm-
X.XX.tar.bz2, X.XX staat voor de versie.
Sla de tarball op in de directory ”/tmp”.
Nu het bestand ”/tmp/nasm-X.XX.tar.bz2” bestaat, kan het uit worden gepakt door
”tar xvyf nasm-X.XX.tar.bz2” in te tikken.
Door de tarball uit te pakken verschijnt er een directory ”nasm-X.XX/”.
A.2      ./configure && make && make install
Verander de de huidige directory in ”/tmp/nasm-X.XX/”.
Om de sourcecode juist in te stellen voor het gebruikte systeem moet er een
configuratie worden ingesteld. Doe dit door het volgende script te runnen.
./configure
Aan de hand van de instelling gevonden door ”./configure” wordt de Makefile
ingesteld. De Makefile dient als hulpmiddel bij het compileren. Compileer de
sourcecode door:
A De NASM documentatie                                                              91
make
Als er geen fouten zijn gevonden, is de sourcecode succesvol gecompileerd. Het
kan nu worden geïnstalleerd met (dit commando vereist root rechten):
su
make install
Nu de source gecompileerd en geïnstalleerd is kan het programma NASM worden
gestart door:
nasm -h
Er verschijnt nu een korte uitleg van de opties die mee kunnen worden gegeven
aan NASM. Voor een meer gedetailleerde uitleg over NASM kan er worden
gekeken naar de man page van NASM.
A.3      De NASM documentatie
NASM beschikt over een zeer uitgebreide documentatie die handig is bij het pro-
grammeren. Zo geeft het uitleg over alle mnemonic’s die gebruikt kunnen worden
en macro’s ed. Ga naar de directory ”/tmp/nasm-X.XX/doc/” en tik daar:
make install
De Makefile is zo ingesteld dat het de documentatie in verschillende formaten ge-
nereert. Dit is handig, er is nu documentatie in html, plain-text of in Postscript. De
documentatie in html vorm staat in ”/tmp/nasm-X.XX/doc/html/”.
Bijlage B
ALD installeren
Compile the program and run it. Make sure you include the symbol table for the
debugger or not... depending upon how macho you feel today.
Mudge, l0pht advisories
ALD (Assembly Language Debugger) is een debugging tool voor debuggen van
x86 executables op assembly niveau.
B.1     Downloaden van de source
Download de sourcecode van laatste versie van ALD via http van:
http://ellipse.mcs.drexel.edu/source/
Sla de gedownloade tarball op in de directory ”/tmp/”.
Ga naar de ”/tmp” directory door ”cd /tmp” in te geven. Het bestand ”ald-
X.X.XX.tar.gz” in de /tmp directory kan het uit worden gepakt door ”tar xvzf ald-
X.XX.tar.gz”
Er verschijnt nu een directory met de naam ”ald-X.X.XX/”.
B Configureren, compileren en installeren                                        93
B.2      Configureren, compileren en installeren
Verander de de huidige directory in ”/tmp/ald-X.X.XX/” door ”cd ald-X.X.XX/”
Configureer de software met:
./configure
De configuratie is opgeslagen in de Makefile, er kan nu gecompileerd worden met
het commando:
make
Als de sourcecode succesvol is gecompileerd kan het nu worden geïnstalleerd.
Het installeren (het kopiëren van de binairies naar ”/usr/local/bin/”) vereist root-
rechten op het systeem. Daarom moet er van gebruiker worden gewisseld (aan-
nemende dat er niet als root werd gewerkt).
su
make install
ALD is nu geïnstalleerd en kan worden gestart door ”ald”.
Bijlage C
Linux Kernel Modules in assembly
Het schrijven van kernel modules in assembly is wel degelijk mogelijk,
ondanks dat het een tijdrovend karwei kan zijn.
Zie voor meer informatie over het schrijven van kernel modules De Vrijer 2001 - C
Coding in the Linux Kernel Environment.
Het onderstaande voorbeeld demonstreert het gebruik van kernel modules in
assembly.
Het kan gecompileerd worden door de volgende opdrachten. Verander eerst het
versienummer op regel 5 naar de huidige kernel versie. 1
nasm -f elf module.asm -o module.tmp
ld -r -o module.o module.tmp
Het kan worden ingeladen en uit het geheugen worden geladen met de onder-
staande opdrachten. Hiervoor zijn root rechten op het systeem nodig.
insmod module.o
rmmod module
 s e c t i o n . data
 i n i t db " Real programmers code i n assembly " , 0xa , 0
c l e a n db " Said t h e k e r n e l " , 0xa , 0
 k e r n e l _ v e r s i o n db " 2 . 4 . 3 " , 0
 global init_module
 g l o b a l cleanup_module
     1
       Het commando ’uname -r’ toont de draaiende kernel versie.
                                                              95
global kernel_version
extern p r i n t k
section . text
init_module :
     push dword i n i t   ; z e t ’ i n i t ’ op de s t a c k
     call printk          ; roep p r i n t k aan ,
                          ; m. o . w . druk ’ i n i t ’ a f
     pop eax              ; r e t u r n waarde p r i n t k
     x o r eax , eax      ; r e t u r n moet 0 z i j n
                          ; anders kan de module
                          ; n i e t worden geladen .
     ret                  ; einde i n i t _ m o d u l e ( )
cleanup_module :
     push dword c l e a n ; z e t ’ clean ’ op de s t a c k
     call printk          ; roep p r i n t k aan
     pop eax              ; r e t u r n waarde p r i n t k
     ret                  ; einde cleanup_module ( )
                          ; en einde lkm
Bijlage D
Ascii Tabel
Decimaal Octaal Hexadecimaal Binair   Waarde
000      000    000          00000000 NUL
001      001    001          00000001 SOH
002      002    002          00000010 STX
003      003    003          00000011 ETX
004      004    004          00000100 EOT
005      005    005          00000101 ENQ
006      006    006          00000110 ACK
007      007    007          00000111 BEL
008      010    008          00001000 BS
009      011    009          00001001 HT
010      012    00A          00001010 LF
011      013    00B          00001011 VT
012      014    00C          00001100 FF
013      015    00D          00001101 CR
014      016    00E          00001110 SO
015      017    00F          00001111 SI
016      020    010          00010000 DLE
017      021    011          00010001 DC1
018      022    012          00010010 DC2
019      023    013          00010011 DC3
020      024    014          00010100 DC4
021      025    015          00010101 NAK
022      026    016          00010110 SYN
023      027    017          00010111 ETB
024      030    018          00011000 CAN
025      031    019          00011001 EM
                                             97
Decimaal Octaal Hexadecimaal Binair   Waarde
026      032    01A          00011010 SUB
027      033    01B          00011011 ESC
028      034    01C          00011100 FS
029      035    01D          00011101 GS
030      036    01E          00011110 RS
031      037    01F          00011111 US
032      040    020          00100000 SP
033      041    021          00100001 !
034      042    022          00100010 "
035      043    023          00100011 #
036      044    024          00100100 $
037      045    025          00100101 %
038      046    026          00100110 &
039      047    027          00100111 ’
040      050    028          00101000 (
041      051    029          00101001 )
042      052    02A          00101010 *
043      053    02B          00101011 +
044      054    02C          00101100 ,
045      055    02D          00101101 -
046      056    02E          00101110 .
047      057    02F          00101111 /
048      060    030          00110000 0
049      061    031          00110001 1
050      062    032          00110010 2
051      063    033          00110011 3
052      064    034          00110100 4
053      065    035          00110101 5
054      066    036          00110110 6
055      067    037          00110111 7
056      070    038          00111000 8
057      071    039          00111001 9
058      072    03A          00111010 :
059      073    03B          00111011 ;
060      074    03C          00111100 <
061      075    03D          00111101 =
062      076    03E          00111110 >
063      077    03F          00111111 ?
064      100    040          01000000 @
065      101    041          01000001 A
                                             98
Decimaal Octaal Hexadecimaal Binair   Waarde
066      102    042          01000010 B
067      103    043          01000011 C
068      104    044          01000100 D
069      105    045          01000101 E
070      106    046          01000110 F
071      107    047          01000111 G
072      110    048          01001000 H
073      111    049          01001001 I
074      112    04A          01001010 J
075      113    04B          01001011 K
076      114    04C          01001100 L
077      115    04D          01001101 M
078      116    04E          01001110 N
079      117    04F          01001111 O
080      120    050          01010000 P
081      121    051          01010001 Q
082      122    052          01010010 R
083      123    053          01010011 S
084      124    054          01010100 T
085      125    055          01010101 U
086      126    056          01010110 V
087      127    057          01010111 W
088      130    058          01011000 X
089      131    059          01011001 Y
090      132    05A          01011010 Z
091      133    05B          01011011 [
092      134    05C          01011100 \
093      135    05D          01011101 ]
094      136    05E          01011110 ˆ
095      137    05F          01011111 _
096      140    060          01100000 ‘
097      141    061          01100001 a
098      142    062          01100010 b
099      143    063          01100011 c
100      144    064          01100100 d
101      145    065          01100101 e
102      146    066          01100110 f
103      147    067          01100111 g
104      150    068          01101000 h
105      151    069          01101001 i
                                             99
Decimaal Octaal Hexadecimaal Binair   Waarde
106      152    06A          01101010 j
107      153    06B          01101011 k
108      154    06C          01101100 l
109      155    06D          01101101 m
110      156    06E          01101110 n
111      157    06F          01101111 o
112      160    070          01110000 p
113      161    071          01110001 q
114      162    072          01110010 r
115      163    073          01110011 s
116      164    074          01110100 t
117      165    075          01110101 u
118      166    076          01110110 v
119      167    077          01110111 w
120      170    078          01111000 x
121      171    079          01111001 y
122      172    07A          01111010 z
123      173    07B          01111011 {
124      174    07C          01111100 |
125      175    07D          01111101 }
126      176    07E          01111110  ̃
127      177    07F          01111111 DEL
Bibliografie
 [1] ing. R. de Vrijer.
     C coding in the linux kernel environment.
     Initworks B.V.
 [2] ir. F.J. Dijkstra.
     Computers: organisatie - architectuur - communicatie.
     EPN, 1998.
 [3] Assembly Programming Journal.
     http://asmjournal.freeservers.com.
 [4] Linux Newsgroups.
     alt.os.linux, comp.os.linux.
 [5] Linux Documentation Project.
     http://www.linuxdoc.org.
 [6] Microprocessor Resources.
     http://x86.org/.
 [7] Roelf Sluman.
     Toolbox voor machinetaalprogrammeurs.
     Kluwer PC Boeken, 1989.
 [8] Richard M. Stallman and Roland H. Pesch.
     Debugging with gdb - the gnu source-level debugger.
 [9] W. Richard Stevens.
     Advanced programming in the unix environment.
     Addison Wesley, 1993.
[10] Tom Swam.
     Werken met turbo assembler.
     Acedemic Service, 1991.
[11] Andrew S. Tanenbaum and Albert S. Woodhull.
     Operaring systems: design and implementation - second edition.
     Prentice-Hall, 1997.
BIBLIOGRAFIE                                           101
[12] Tools Interface Standards (TIS).
     Executable and linkable format.
     Portable Format Specification.
[13] Little Endian vs. Big Endian.
     http://www.noveltheory.com/techpapers/endian.asp.
[14] The x86 Assembly Language FAQ.
     http://www2.dgsys.com/ raymoon/x86faqs.html.
[15] The x86 Assembly Language Newsgroup.
     comp.lang.asm.x86.
[16] Technical x86 processor information.
     http://www.sandpile.org/.
                                     linux.org
Index
[], 15                                   Assembly, 7
_exit, 18                                assembly language, 10, 67
_start, 52                               Assembly Language Debugger, 34
32-bit registers, 38
80486/Pentium/Pentium Pro, 40            Big-endian, 33
8088, 8086, 39                           big-endian, 33
80x86, 31                                bits, 59
                                         byte ordering, 33
8086, 36
80286, 40                                C, 69
80386, 36, 40                            C of C++, 69
80486, 36                                c_code.asm, 70
                                         Central Processing Unit, 27
example, 13, 18, 19, 21, 22, 25, 26, 34, CISC, 31
         42, 44, 49, 50, 52, 55–62, 65, CLC, 50
         69, 70, 73, 74, 79–81, 83, 84, Clock Unit, 29
         86–88, 95                       clockcycle, 30
                                         cmp, 53, 76, 78, 79
adc, 48, 49                              coderingsmethoden, 54
add, 48                                  commando’s, 14
Adres vertaling, 38                      commentaar veld, 14, 15
adresbus, 45                             conditionele, 79
Adressering, 37                          const void* buf, 18
Adresserings methodes, 38                control flag, 48
ALD, 8                                   Control Unit, 28
ALU, 28                                  CPU, 27
AMD, 30                                  Cyrix, 30
AND operator, 58
Apple, 28                                data segment, 86
Architectuur, 8                          databus, 45
as, 14                                   db, 20
asm_code.asm, 69                         dd, 20
assembler, 14                            Debuggen van hardware, 39
assembler talen, 10                      debugger, 34
INDEX                                                            103
dec, 56                            general-purpose registers, 29
decrement, 56                      GHz, 30
define, 20                         GigaHertz, 30
directives, 20                     goto, 14, 78
div, 58, 66
DNA computers, 77                  hello world, 17
DOS, 36                            High Level Language, 76
DRAM, 31                           HLL, 76
DS, 86
                                   IA32, 46
dw, 20
                                   idiv, 58
EAX, 47                            if, 76, 80
EBP, 47                            Immediates, 15
EBX, 47                            imul, 57
ECX, 47                            inc, 56
EDI, 47                            Increment, 56
EDX, 47                            instructie, 67
EFLAGS, 48, 78, 79                 instructie pointer, 48, 52
EFLAGS register, 76                instructies, 27
EIP, 48, 52                        instructieset, 27
ELF, 13, 19                        int, 19
else, 76, 80                       int fd, 18
emulator, 36                       integers, 82
ENIAC, 9                           Intel, 28
enter, 86                          interrupt, 19
equ, 21                            Itanium/IA-64, 40
equate, 21
                                   JA, 82
ESI, 47
                                   JE, 82
ESP, 47, 86
                                   JLE, 82
ESP-register, 86
                                   jmp, 79
Executable and Linkable Format, 19
                                   JNE, 82
execve, 18
                                   JNG, 82
exit, 18, 19
                                   JNZ, 82
far jumps, 52                      jnz.asm, 80
fetch-execute cycle, 77            jump, 82
filexs.asm, 25                     jump instructies, 82
flat, 51                           Jumps, 52
functies, 69                       JZ, 82
                                   jz, 62
Geheugen, 15
geheugenvelden, 21                 kernel, 18
INDEX                                                            104
kloksnelheid, 29            offset, 48
                            onconditionele, 79
label, 14                   one’s complement, 54
ld, 13                      Ontstaan van assembly, 7
leave, 86                   onvoorwaardelijke, 79
LIFO, 85                    Onvoorwaardelijke jump, 79
linker, 13                  opcodes, 82
Linux, 51                   operand veld, 14
Linux kernel, 69            operating system, 38, 51
Little-endian, 33           OR operator, 59
little-endian, 33           overflowt, 78
loop, 84
loop-instructies, 84        PC, 48
loope, loopz, 84            Pentium II/Pentium III/Pentium 4, 40
loopne, loopnz, 84          Pentium MMX, 40
                            phsysical memory, 31
machinetaal, 27             pipelining, 32
Macintosh, 32               POP, 85
MegaHertz, 29               popa, 88
memory management model, 51 popad, 88
memory model, 51            popaw, 88
MHz, 29                     POPF, 89
microprocessor, 27          PowerPC, 32
MIPS, 32                    Process protection, 38
MMP, 28                     processor, 27
MMU, 37, 38                 program counter, 48
mnemonic, 14, 67            program stack, 85
mnemonics, 82               Programma structuur, 8
Motorola, 30                Protected Mode, 36
mov, 10, 15, 58             protected mode, 36, 71
mul, 56                     pseudo C-code, 81
mul r/m16, AX, 57           pseudo-instructies, 22
mul r/m32, EAX, 57          ptrace, 38
mul r/m8, AL, 56            PUSH, 85, 86
Multitasking, 39            pusha, 88
                            Pushad, 88
NASM, 8
                            Pushaw, 88
nasm, 13
                            PUSHF, 89
neg, 55
                            pushpop.asm, 87
Netwide Assembler, 13
NOT operator, 61            quantum computers, 77
INDEX                                                        105
RAM, 29, 38                     Unices, 19
real mode, 36                   unsegmented, 51
Registers, 8, 15, 29            unsigned, 82
RISC, 31                        Unsigned integers, 53
ROM geheugen, 27                unsigned integers, 53
routines, 69
                                V86 mode, 36
sbb, 49                         Virtual 8086 mode, 36
sections, 20                    Virtual memory, 37
segment selector, 51            virtual memory, 38
Segmentatie, 38                 void *buf, 25
segmenten, 20, 38               Von Neumann, 77
sign bit, 54                    Von Neumann Architectuur, 10
sign flag, 78                   Von Neumann’s, 10
sign magnitude, 54              Voorwaardelijke jumps, 79
signed, 82
signed integers, 53, 55         while, 76
size_t count, 18                while.asm, 83
SMP, 28                         Write, 18
special-purpose instructies, 48 write, 17–19
SRAM, 31
                                xor, 58
SS, 86
                                XOR operator, 60
ssize_write(), 18
                                XOR, OR, AND en NOT, 58
stack, 85
stack segment, 86               Zuse, 9
stackpointer, 86
stacksegment, 86
status flags, 48
strace, 18, 19
structuur, 78
sub, 49, 53
swap-partitie, 38
system flags, 48
Taal niveaus, 8
test, 62
time, 19
two’s complement, 54
uname -r’, 95
unary operator, 61
underflowt, 78
