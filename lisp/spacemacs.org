#+TITLE: spacemacs 简介
#+DESCRIPTION: spacemacs 用法简介
#+TAGS: spacemacs
#+CATEGORIES: 软件使用

* spacemacs 
  编辑器扩展, 把编辑器弄的 方便配置(~.spacemacs~), 操作统一 (按 ~SPC~ 就好了) ,方便扩展(~layer~)
 #+HTML: <!-- more -->
 
** layer 
** Dotfile 用法
*** 命令
    同步 dotfile 
    同步命令 ~dotspacemacs/sync-configuration-layers~  会重新执行  ~dotfile ~

    测试 dotfile : ~dotspacemacs/test-dotfile~
*** 配置 ( 按下面的执行流程 )
**** dotspacemacs/init (不能改) 
**** dotspacemacs/user-init (设置加载包前的初始化)
**** dotspacemacs/user-env (设置环境变量, 在加载图层和包前调用)
**** dotspacemacs/layers( 设置要使用的层，还可以配置使用或排除的包)
**** dotspacemacs/user-config (设置层初始化后要执行的用户配置)
**** dotspacemacs/emacs-custom-settings (在 emacs 菜单设置的变量，不用改)
*** 层的定义
** 编辑 
*** 文本操作 (start with ~x~)
*** 文本输入 (start with ~i~)
*** 数字加减 n
*** 选区 v
*** 缩放显示区域 (start with ~n~)
    | ~SPC n f~ | 显示函数            |
    | ~SPC n p~ | 显示 page           |
    | ~SPC n r~ | 显示　selected text |
    | ~SPC n w~ | 撤销，全部显示      |
*** 替换 
**** 可视化替换 iedit                                              :多行编辑:
     选中要替换的词，按 SPC s e
**** 选中替换 <>s//新词/               :多行编辑:
*** 文件重命名
    It is possible to batch rename files in a directory using =wdired= from an
    =helm= session:
    - browse for a directory using ~SPC f f~
    - enter =wdired= with ~C-c C-e~
    - edit the file names and use ~C-c C-c~ to confirm the changes
    - use ~C-c C-k~ to abort any changes
      
*** 注释 SPC c
    改变注释样式
    
    #+BEGIN_SRC emacs-lisp
      (add-hook 'c-mode-common-hook
                (lambda ()
                  ;; Preferred comment style
                  (setq comment-start "// "
                        comment-end "")))

    #+END_SRC
          
或者
    #+BEGIN_SRC emacs-lisp
      (defun my-c-mode-hook ()
        (c-set-style "bsd")
        (setq tab-width 4)
        (c-set-offset 'case-label '+)
        (setq c-basic-offset tab-width)
        (setq comment-start "//")
        (setq comment-end "")
        (setq comment-column 80))
      (add-hook 'c-mode-hook #'my-c-mode-hook)
#+END_SRC
*** 正则表达式
    Spacemacs uses the packages [[https://github.com/joddie/pcre2el][pcre2el]] to manipulate regular expressions. It is
    useful when working with =Emacs Lisp= buffers since it allows to easily converts
    =PCRE= (Perl Compatible RegExp) to Emacs RegExp or =rx=. It can also be used to
    “explain” a PCRE RegExp around point in =rx= form.

    The key bindings start with ~SPC x r~ and have the following mnemonic structure:
    - ~SPC x r <source> <target>~ convert from source to target
    - ~SPC x r~ do what I mean

    | Key Binding   | Function                                                                               |
    |---------------+----------------------------------------------------------------------------------------|
    | ~SPC x r /~   | Explain the regexp around point with =rx=                                              |
    | ~SPC x r '​~   | Generate strings given by a regexp given this list is finite                           |
    | ~SPC x r t~   | Replace regexp around point by the =rx= form or vice versa                             |
    | ~SPC x r x~   | Convert regexp around point in =rx= form  and display the result in the minibuffer     |
    | ~SPC x r c~   | Convert regexp around point to the other form and display the result in the minibuffer |
    | ~SPC x r e /~ | Explain Emacs Lisp regexp                                                              |
    | ~SPC x r e '​~ | Generate strings from Emacs Lisp regexp                                                |
    | ~SPC x r e p~ | Convert Emacs Lisp regexp to PCRE                                                      |
    | ~SPC x r e t~ | Replace Emacs Lisp regexp by =rx= form or vice versa                                   |
    | ~SPC x r e x~ | Convert Emacs Lisp regexp to =rx= form                                                 |
    | ~SPC x r p /~ | Explain PCRE regexp                                                                    |
    | ~SPC x r p '​~ | Generate strings from PCRE regexp                                                      |
    | ~SPC x r p e~ | Convert PCRE regexp to Emacs Lisp                                                      |
    | ~SPC x r p x~ | Convert PCRE to =rx= form                                                              |

    Deletion is configured to send deleted files to system trash.

    On OS X the =trash= program is required. It can be installed with [[https://brew.sh/][homebrew]] with
    the following command:

    #+BEGIN_SRC sh
      $ brew install trash
    #+END_SRC

    To disable the trash you can set the variable =delete-by-moving-to-trash= to
    =nil= in your =~/.spacemacs=.
*** 编辑 Lisp code
    Editing of lisp code is provided by [[https://github.com/syl20bnr/evil-lisp-state][evil-lisp-state]].

    Commands will set the current state to =lisp state= where different commands
    combo can be repeated without pressing on ~SPC k~.

    When in =lisp state= the color of the mode-line changes to pink.

    Examples:
    - to slurp three times while in normal state: ~SPC k 3 s~
    - to wrap a symbol in parentheses then slurp two times: ~SPC k w 2 s~

    *Note*: The =lisp state= commands are available in /any/ modes! Try it out.

**** Lisp Key Bindings
***** Lisp state key bindings
      These commands automatically switch to =lisp state=.

      | Key Binding | Function                                                            |
      |-------------+---------------------------------------------------------------------|
      | ~SPC k %~   | evil jump item                                                      |
      | ~SPC k :~   | ex command                                                          |
      | ~SPC k (~   | insert expression before (same level as current one)                |
      | ~SPC k )~   | insert expression after (same level as current one)                 |
      | ~SPC k $~   | go to the end of current sexp                                       |
      | ~SPC k ` k~ | hybrid version of push sexp (can be used in non lisp dialects)      |
      | ~SPC k ` p~ | hybrid version of push sexp (can be used in non lisp dialects)      |
      | ~SPC k ` s~ | hybrid version of slurp sexp (can be used in non lisp dialects)     |
      | ~SPC k ` t~ | hybrid version of transpose sexp (can be used in non lisp dialects) |
      | ~SPC k 0~   | go to the beginning of current sexp                                 |
      | ~SPC k a~   | absorb expression                                                   |
      | ~SPC k b~   | forward barf expression                                             |
      | ~SPC k B~   | backward barf expression                                            |
      | ~SPC k c~   | convolute expression                                                |
      | ~SPC k ds~  | delete symbol                                                       |
      | ~SPC k Ds~  | backward delete symbol                                              |
      | ~SPC k dw~  | delete word                                                         |
      | ~SPC k Dw~  | backward delete word                                                |
      | ~SPC k dx~  | delete expression                                                   |
      | ~SPC k Dx~  | backward delete expression                                          |
      | ~SPC k e~   | unwrap current expression and kill all symbols after point          |
      | ~SPC k E~   | unwrap current expression and kill all symbols before point         |
      | ~SPC k h~   | previous symbol                                                     |
      | ~SPC k H~   | go to previous sexp                                                 |
      | ~SPC k i~   | switch to =insert state=                                            |
      | ~SPC k I~   | go to beginning of current expression and switch to =insert state=  |
      | ~SPC k j~   | next closing parenthesis                                            |
      | ~SPC k J~   | join expression                                                     |
      | ~SPC k k~   | previous opening parenthesis                                        |
      | ~SPC k l~   | next symbol                                                         |
      | ~SPC k L~   | go to next sexp                                                     |
      | ~SPC k p~   | paste after                                                         |
      | ~SPC k P~   | paste before                                                        |
      | ~SPC k r~   | raise expression (replace parent expression by current one)         |
      | ~SPC k s~   | forward slurp expression                                            |
      | ~SPC k S~   | backward slurp expression                                           |
      | ~SPC k t~   | transpose expression                                                |
      | ~SPC k u~   | undo                                                                |
      | ~SPC k U~   | got to parent sexp backward                                         |
      | ~SPC k C-r~ | redo                                                                |
      | ~SPC k v~   | switch to =visual state=                                            |
      | ~SPC k V~   | switch to =visual line state=                                       |
      | ~SPC k C-v~ | switch to =visual block state=                                      |
      | ~SPC k w~   | wrap expression with parenthesis                                    |
      | ~SPC k W~   | unwrap expression                                                   |
      | ~SPC k y~   | copy expression                                                     |

***** Emacs lisp specific key bindings

      | Key Binding | Function                                   |
      |-------------+--------------------------------------------|
      | ~SPC m e $~ | go to end of line and evaluate last sexp   |
      | ~SPC m e b~ | evaluate buffer                            |
      | ~SPC m e c~ | evaluate current form (a =def= or a =set=) |
      | ~SPC m e e~ | evaluate last sexp                         |
      | ~SPC m e f~ | evaluate current defun                     |
      | ~SPC m e l~ | go to end of line and evaluate last sexp   |
      | ~SPC m e r~ | evaluate region                            |

      | Key Binding | Function                                           |
      |-------------+----------------------------------------------------|
      | ~SPC m g g~ | go to definition                                   |
      | ~SPC m g G~ | go to definition in another window                 |
      | ~SPC m h h~ | describe elisp thing at point (show documentation) |
      | ~SPC m t b~ | execute buffer tests                               |
      | ~SPC m t q~ | ask for test function to execute                   |

    There are some added mouse features set for the line number margin (if shown):
    - single click in line number margin visually selects the entire line
    - drag across line number masusually selally selrgin visually selects the region
    - double click in line numbsually seler margin visually select the current code block

*** 字符复制上面行 CTL-y   下面行 CTL-e  
** 调试
*** 加载有错误
    emacs --debug-init
*** 更新包后有错，要重新编译安装包
    spacemacs/recompile-elpa
*** 打开调试开关 
    toggle-debug-on-error
** 帮助
*** 手册 
*** spacemacs 文档
** 概念
*** 设置编辑样式 
   ~dotspacemacs-editing-style~  为 =vim=, =hybrid=, or =emacs=  
**** vim
   设置键绑定 
   #+BEGIN_SRC emacs-lisp
     (define-key evil-insert-state-map (kbd "C-]") 'forward-char)
  #+END_SRC

   默认样式
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-editing-style '(vim :variables
                                                    vim-style-visual-feedback nil
                                                    vim-style-remap-Y-to-y$ nil
                                                    vim-style-retain-visual-state-on-shift t
                                                    vim-style-visual-line-move-text nil
                                                    vim-style-ex-substitute-global nil)
   #+END_SRC

**** emacs
     键绑定
#+BEGIN_SRC emacs-lisp
  (define-key evil-emacs-state-map (kbd "C-]") 'forward-char)
#+END_SRC

**** hybrid
#+BEGIN_SRC emacs-lisp
  (define-key evil-hybrid-state-map (kbd "C-]") 'forward-char)
#+END_SRC

*** 设置 Toggles
    在 ~user-config~ 中
    设置开关  =spacemacs/toggle-NAME-on= and =spacemacs/toggle-NAME-off=
    
    设置默认开关状态
#+BEGIN_SRC emacs-lisp
  (spacemacs/toggle-nameless-on-register-hooks)
  ;; or to enable it for emacs-lips buffers only
  (spacemacs/toggle-nameless-on-register-hook-emacs-lisp-mode)
#+END_SRC

** 环境变量和 PATH
   配置环境变量 =dotspacemacs/user-env= 
   默认加载 =~/.spacemacs.env= ,通过 =spacemacs/load-spacemacs-env= 命令
   可以配置，并重新加载
   可以强制导入系统环境变量，但不推介,会覆盖
** Binding keys
   全局映射方式 
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-]") 'forward-char)
   #+END_SRC

   spacemacs 方式
   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "C-]" 'forward-char)
     (spacemacs/set-leader-keys-for-major-mode 'emacs-lisp-mode "C-]" 'forward-char)
   #+END_SRC

   声明前缀,通常先前缀，后完整
   #+BEGIN_SRC emacs-lisp
     (spacemacs/declare-prefix "o o" "file")
     (spacemacs/set-leader-keys "o o c" 'my-custom-command)
   #+END_SRC

** GUI Elements
*** 主题 
    设置默认主题
    #+BEGIN_SRC emacs-lisp
      (setq-default dotspacemacs-themes '(spacemacs-light leuven zenburn))
    #+END_SRC

    加载主题 ~load-theme~
** Layouts 和 workspaces
*** 布局 layouts 
    对缓冲区分组，一般是一个项目文件夹。也叫工程。   
    
    项目布局，项目文件夹下要包含一个 ~.projectile~ 文件，或者在 ~git~ 库, ~svn~ 库
    创建项目布局 ~helm-projectile~
    
    
    自定义布局
    
    #+BEGIN_SRC emacs-lisp
      (spacemacs|define-custom-layout "@ERC"
        :binding "E"
        :body
        (progn
          ;; hook to add all ERC buffers to the layout
          (defun spacemacs-layouts/add-erc-buffer-to-persp ()
            (persp-add-buffer (current-buffer)
                              (persp-get-by-name
                               erc-spacemacs-layout-name)))
          (add-hook 'erc-mode-hook #'spacemacs-layouts/add-erc-buffer-to-persp)
          ;; Start ERC
          (call-interactively 'erc)))
    #+END_SRC

*** 工作空间
    布局的子布局，共享父布局的 buffer
** 命令
*** Vim key bindings
*** Completion(完成)
    自动完成补全，都不用按@@html:<kbd>@@ <tab> @@html:</kbd>@@ 了 
    一种 ~helm~ , 一种 ~ivy~
*** 导航
**** 跳转
     jumping, joining and splitting 功能都由 ~SPC j~ 开头的按键提供，功能很多。
**** 窗口跳转
*** 工程管理
*** 寄存器
    | ~SPC r e~ | show evil yank and named registers |
    | ~SPC r m~ | show marks register                |
    | ~SPC r r~ | show helm register                 |
    | ~SPC r y~ | show kill ring                     |

** 服务
   服务开关 ~server-start~
   客户端连接到服务 ~emacsclient -c~
   
   保证服务不关闭
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-persistent-server t)
   #+END_SRC

* include (包含操作)
** 简单方式  (load-file "~/elisp/foo.el")
   但我们还要注意性能，一般在打开文件时加载，所以要做复杂的判断
** require 方式(lisp 文件有一个属性)
   
   #+BEGIN_SRC emacs-lisp
     ;;有此属性
     ;; Your code goes here ...

     (provide 'my-feature)
   #+END_SRC

   To have Emacs load this file, call =require=, as such:

   #+BEGIN_SRC emacs-lisp
     (require 'my-feature)
   #+END_SRC

   这种方式会做一系列判断，(在 load-path 变量)会检查 el,elc 文件，会判断是否已加载过.
   这种方式普遍，作者写的严谨，依赖都会写.

   显示路径 SPC h d v load-path
   (add-to-list 'load-path "/some/path/")
** Auto-loading
   require 列表还是很长很慢
   
   如果函数被定义为自动加载属性，那么只有函数被使用时，会被自动加载(第一次执行会轻微延时)

   当调用函数时，先执行文件  (autoload 'some-function "some-file")
   
   SPC h d f some-function 可以显示函数的属性 为 auto-loaded 函数
   
   文件样式 helm-autoloads.el
   #+BEGIN_SRC emacs-lisp
     ;;;###autoload  ;;这个是 magic 注释,自动生成
     (defun my-function ()
       ;; Source code...
       )
   #+END_SRC
   自动加载的不光函数，还有 macros, major or minor modes, groups, classes, and so on.
   还有下面的文件
   #+BEGIN_SRC emacs-lisp
     ;;;###autoload
     (require 'helm)
   #+END_SRC
*** Eval after load

    当加载后要配置变量，可以用下面的函数
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'helm
        ;; Code
        )
    #+END_SRC

*** Use-package(这个功能强大)
    https://github.com/jwiegley/use-package
    方式 1  
    #+BEGIN_SRC emacs-lisp
      (use-package helm
        :defer t
        :init
        ;; Code to execute before Helm is loaded
        :config
        ;; Code to execute after Helm is loaded
        )
    #+END_SRC

    模式场景
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-mode
        :mode "\\.rb\\'")
    #+END_SRC

* layer 
** 层的内容
   - 层定义
   - 包的列表和配置
   - 函数定义
   - 层的特定配置
   - 键盘绑定
** layers.el
   #+BEGIN_SRC emacs-lisp
     ;; 层 A 依赖层 B
     (configuration-layer/declare-layer 'B)
     ;;效果就像 B 加入了层配置变量
     ;; dotspacemacs-configuration-layers
   #+END_SRC

** packages.el
   #+BEGIN_SRC emacs-lisp
     ;; 包列表
     (defconst mylayer-packages
       '(
         ;; Get the package from MELPA, ELPA, etc.
         some-package
         (some-package :location elpa)

         ;; A local package
         (some-package :location local)

         ;; A local package to be built with Quelpa
         (some-package :location (recipe :fetcher local))

         ;; A package recipe
         (some-package :location (recipe
                                  :fetcher github
                                  :repo "some/repo"))

         ;; An excluded package
         (some-package :excluded t)
         ))
     ;; Local packages should reside at <layer>/local/<package>/
   #+END_SRC

   For each included package, you may define one or more of the following
   functions, which are called in order by Spacemacs to initialize the package.
   1. =<layer>/pre-init-<package>=
   2. =<layer>/init-<package>=
   3. =<layer>/post-init-<package>=

   *Note:* A package will not be installed unless at least one layer defines an
   =init= function for it. That is to say, in a certain sense, the =init= function
   does mandatory setup while the =pre-init= and =post-init= functions do optional
   setup. This can be used for managing cross-layer dependencies, which we will
   discuss later.

** funcs.el
   #+BEGIN_SRC emacs-lisp
     (when (configuration-layer/package-used-p 'my-package)
       (defun spacemacs/my-package-enable () ...)
       (defun spacemacs/my-package-disable () ...))
   #+END_SRC

** config.el
** keybindings.el
* Layer tips and tricks
** Cross-dependencies
   Spacemacs provides a couple of additional useful functions you can use to check
   whether other layers or packages are included.
   - check if a layer is enabled
   - check if a package is or will be installed

   These are useful in some cases, but usually you can get the desired result just
   by using =post-init= functions.

   For layers that require another layers to be enabled, use the functions
   =configuration-layer/declare-layer= and =configuration-layer/declare-layers= to
   ensure that layers are enabled even if the user has not enabled them explicitly.
   Calls to these functions must go in the =layers.el= file.

** Shadowing
   Shadowing is the operation of replacing a used layer by another one. For
   instance if a used layer A can shadow a used layer B and the layer A is listed
   after the layer B in the dotfile then the layer A replaces the layer B and it is
   like only the layer A is being used.

   Examples of this mechanism are helm/ivy layers or neotree/treemacs layers.

   A layer can shadow other layers by calling in its =layers.el= file the function
   =configuration-layer/declare-shadow-relation=. This function declares a
   =can-shadow= relation between all the layers.

   =can-shadow= is a commutative relation, if layer A can shadow layer B then layer
   B can shadow layer A.

   The =shadow= operator is a binary operator accepting two layer names, it is not
   commutative and the order of the operands is determined by the order of the
   layers in the dotfile (like the ownership stealing mechanism).

   If =:can-shadow= property is set explicitly to =nil= in the dotfile then the
   layer won’t shadow any layer.

   For instance to install both ivy and helm layer:

   #+BEGIN_SRC emacs-lisp
     (setq dotspacemacs-configuration-layers
           '(
             ivy
             (helm :can-shadow nil)
             )
   #+END_SRC

   note that due to the commutative relation =can-shadow= the above example can
   also be written like this (in this case, =:can-shadow= should be read
   =:can-be-shawdowed=):

   #+BEGIN_SRC emacs-lisp
     (setq dotspacemacs-configuration-layers
           '(
             (ivy :can-shadow nil)
             helm
             )
   #+END_SRC

   We will prefer the first form as it is more intuitive.

** Use-package init and config
   In the vast majority of cases, a package =init= function should do nothing but
   call to =use-package=. Again, in the vast majority of cases, all the
   configuration you need to do should be doable within the =:init= or =:config=
   blocks of such a call.

   What goes where? Since =:init= is executed before load and =:config= after,
   these rules of thumb apply.

   In =:config= should be
   - Anything that requires the package to be already loaded.
   - Anything that takes a long time to run, which would ruin startup performance.

   The =:init= block should contain setup for the entry points to the package. This
   includes key bindings, if the package should be loaded manually by the user, or
   hooks, if the package should be loaded upon some event. It is not unusual to
   have both!

** Use-package hooks
   Spacemacs includes a macro for adding more code to the =:init= or =:config=
   blocks of a call to =use-package=, after the fact. This is useful for =pre-init=
   or =post-init= functions to “inject” code into the =use-package= call of the
   =init= function.

   #+BEGIN_SRC emacs-lisp
     (spacemacs|use-package-add-hook helm
       :pre-init
       ;; Code
       :post-init
       ;; Code
       :pre-config
       ;; Code
       :post-config
       ;; Code
       )
   #+END_SRC

   Since a call to =use-package= may evaluate the =:init= block immediately, any
   function that wants to inject code into this block must run =before= the call to
   =use-package=. Further, since this call to =use-package= typically takes place
   in the =init-<package>= function, calls to =spacemacs|use-package-add-hook=
   *always* happen in the =pre-init-<package>= functions, and not in
   =post-init-<package>=.

** Best practices
If you break any of these rules, you should know what you are doing and have a
good reason for doing it.

*** Package ownership
Each package should be owned by one layer only. The layer that owns the
package should define its =init= function. Other layers should rely on
=pre-init= or =post-init= functions.

*** Localize your configuration
*Each function can only assume the existence of one package.* With some
exceptions, the =pre-init=, =init= and =post-init= functions can /only/
configure exactly the package they are defined for. Since the user can exclude
an arbitrary set of packages, there is no /a priori/ safe way to assume that
another package is included. Use =configuration-layer/package-usedp= if you
must.

This can be very challenging, so please take this as a guideline and not
something that is absolute. It is quite possible for the user to break her
Spacemacs installation by excluding the wrong packages, and it is not our
intention to prevent this at all costs.

*** Load ordering
In Spacemacs, layers are loaded in order of inclusion in the dotfile, and
packages are loaded in alphabetical order. In the rare cases where you make use
of this property, you should make sure to document it well. Many will assume
that layers can be included in arbitrary order (which is true in most cases),
and that packages can be renamed without problems (which is also in most cases).

Preferably, write your layer so that it is independent of load ordering. The
=pre= - and =post-init= functions are helpful, together with
=configuration-layer/package-usedp=.

*** No require
Do not use require. If you find yourself using =require=, you are almost
certainly doing something wrong. Packages in Spacemacs should be loaded through
auto-loading, and not explicitly by you. Calls to =require= in package init
functions will cause a package to be loaded upon startup. Code in an =:init=
block of =use-package= should not cause anything to be loaded, either. If you
need a =require= in a =:config= block, that is a sign that some other package is
missing appropriate auto-loads.

*** Auto-load everything
Defer everything. You should have a very good reason not to defer the loading
of a package.
