#+TITLE: layers 简介
#+DESCRIPTION: layers 简介
#+KEYWORDS: spacemacs,layer
#+CATEGORIES: 软件使用
#+DATE: <2019-06-03 14:36:36>

* layer
** auto-completion
   1. 要添加 auto-completion
   2. 还必须至少安装一个支持的语言层才能起作用

   #+begin_verse
    语法片段 *默认* 不在 *完成项* 里面。
    启用 auto-completion-enable-snippets-in-popup t

    Tooltips 更多提示 
    auto-completion-enable-help-tooltip t

    手动出来（需要手动按 *M-h* )
    auto-completion-enable-help-tooltip 'manual
    
    按使用频次排序 
    auto-completion-enable-sort-by-usage t

    *jk* 很适用完成确认如果没有的话
    auto-completion-complete-with-key-sequence "jk"
   #+end_verse

   company                     
   | ~C-d~   | 补全时按此键可以显示文档         |
   | ~C-/~   | 在 Helm 中显示补全列表           |
   | ~C-M-/~ | filter the company dropdown menu |
   | ~M-h~   | 显示候选人文档，工具提示要开启   |
   

   Yasnippet
   | ~M-/~     | Expand a snippet if text before point is a prefix of a snippet |
   | ~SPC i s~ | List all current yasnippets for inserting                      |

   Auto-yasnippet
   | ~SPC i S c~ | create a snippet from an active region                                    |
   | ~SPC i S e~ | Expand the snippet just created with ~SPC i y~                            |
   | ~SPC i S w~ | Write the snippet inside =private/snippets= directory for future sessions |

** c-c++
   反汇编 disaster
   代码格式化 clang-format
   反射 smeantic-refactor
   代码导航 cscope
   自动补全 auto-completion
   调试器 realgud 

   | ~SPC m g a~ | open matching file                   |
   | ~SPC m g A~ | open matching file in another window |
   | ~SPC m D~   | 反汇编                               |
   | ~SPC m r .~ | srefactor: refactor thing at point.  |

*** ccls 
  - M-x ccls-member-hierarchy (显示类，对象，成员列表)
  - M-x ccls-code-lens-mode
*** 通用编译 compile
** cscope  
   用法: 先要创建 *Cscope 索引文件 * ,  通过  ~SPC m g i~.
   
   | ~SPC m g =~ | Find assignments to a symbol                  |
   | ~SPC m g c~ | find which functions are called by a function |
   | ~SPC m g C~ | find where a function is called               |
   | ~SPC m g d~ | 查找定义                                      |
   | ~SPC m g e~ | search regular expression                     |
   | ~SPC m g f~ | find a file                                   |
   | ~SPC m g F~ | find which files include a file               |
   | ~SPC m g i~ | create Cscope index                           |
   | ~SPC m g r~ | find references of a symbol                   |
   | ~SPC m g x~ | search text                                   |

** debug 
   使用 realgud 包调试多种语言
   特定于语言的调试器由相应的层添加。 如果你想
   添加其他调试器，将它们添加到= debug-additional-debuggers =变量中。

   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers
                   '((debug :variables debug-additional-debuggers '("remake"))))
   #+END_SRC


   java -agentlib:jdwp=transport=dt_socket,server=y,address=<port> <class>
   | ~SPC m d d~ | open cmd buffer      |
   | ~bb~        | set break            |
   | ~bc~        | clear break          |
   | ~bd~        | delete break         |
   | ~bs~        | disable break        |
   | ~be~        | enable break         |
   | ~c~         | continue             |
   | ~i~         | step into            |
   | ~J~         | jump to current line |
   | ~o~         | step out             |
   | ~q~         | quit debug           |
   | ~r~         | restart              |
   | ~s~         | step over            |
   | ~S~         | goto cmd buffer      |
   | ~v~         | eval variable        |
** emoji 
** git
*** git 层快捷键    
    | ~SPC g /~   | open =helm-git-grep=                             |
    | ~SPC g *~   | open =helm-git-grep-at-point=                    |
    | ~SPC g b~   | 打开 blame   (版本变迁明细)                      |
    | ~SPC g f f~ | 看一些修改过的文件列表(  版本处理)               |
    | ~SPC g M~   | 显示当前行的提交信息                             |
    | ~SPC g i~   | 版本初始化                                       |
    | ~SPC g S~   | stage current file                               |
    | ~SPC g U~   | unstage current file                             |
    | ~SPC g f l~ | 当前文件的提交记录                               |
    | ~SPC g f d~ | 当前文件的版本差异                               |
    | ~SPC g H c~ | clear highlights        (高亮处理)               |
    | ~SPC g H h~ | 修改的地方高亮                                   |
    | ~SPC g H t~ | 反向高亮                                         |
    | ~SPC g I~   | open =helm-gitignore= (打开忽略文件，不起作用么) |
    | ~SPC g L~   | open magit-repolist  打开版本控制的仓库          |
    | ~SPC g t~   | 打开 git time machine                            |

*** magit 管理窗口  ~SPC g s~ 或者 ~SPC g m~
    | ~/~       | 快捷查找                                        |
    | ~$~       | 打开命令执行历史 buffer                         |
    | ~c c~     | 发布提交消息缓冲 open a =commit message buffer= |
    | ~b b~     | checkout a branch                               |
    | ~b c~     | create a branch                                 |
    | ~f f~     | fetch changes                                   |
    | ~F (r) u~ | 拉取 /变基 pull tracked branch and rebase       |
    | ~gr~      | 刷新 refresh                                    |
    | ~l l~     | 打开日志缓存 open =log buffer=                  |
    | ~o~       | 数据恢复到某个节点                              |
    | ~P u~     | 发布 push to tracked branch                     |
    | ~s~       | 暂存,在 diff 中，还能暂存特定行                 |
    | ~x~       | 丢弃更改                                        |
    | ~S~       | 暂存全部                                        |
    | ~TAB~     | 查看文件改动 (diff)                             |
    | ~u~       | 取消暂存                                        |
    | ~U~       | 取消所有的暂存                                  |
    | ~v or V~  | select multiple lines                           |
    | ~z z~     | 隐藏改动                                        |

    写提交消息的 buff 中，按 ~M-n~ ,~M-p~  可以上下遍历历史提交信息

*** 远程日志
    | ~SPC g l c~ | on a commit hash, browse to the current file at this commit                                   |
    | ~SPC g l C~ | on a commit hash, create link to the file at this commit and copy it                          |
    | ~SPC g l l~ | 在 远程（如 github) 中 打开记录行                                                             |
    | ~SPC g l L~ | 拷贝上面的远程行 链接                                                                         |
    | ~SPC g l p~ | on a region, browse to file at current lines position (using permalink link)                  |
    | ~SPC g l P~ | on a region, create a link to the file highlighting the selected lines (using permalink link) |

** github
** cmake
   此层主要 使用 *cmake-ide* 的集成功能 ，支持 cmake  项目和 非 cmake 项目，在 CMake 脚本文件是项目的依赖配置。 
  
   保存文件自动重新运行 *cmake* ，要设置 ~cmake-ide-build-dir~ 
   ~cmake-ide-delete-file~ 后需要手动运行 *cmake*
  
   默认生成的是临时目录，可以设置永久的 cmake-ide-build-pool-dir 和
   cmake-ide-build-pool-use-persistent-naming .
  
   非 cmake 项目 ，可以设置本地变量 !!!!  
   #+begin_quote
   .dir-locals.el: ((nil . ((cmake-ide-build-dir . "/path/to/build/dir") (cmake-ide-project-dir . "/path/to/project/dir"))))
   #+end_quote
   假如在 ~cmake-ide-build-dir~ 目录存在 ~compile_commands.json~ 文件 ，那么也可以
   编译。此文件可以用 ~Bear~ 工具生成。
 
   总结： 编译的化运行 ~,  c c~  
 
** google translate
   | 反向翻译 | google-translate-query-translate-reverse                                    |
   | 支持列表 | google-translate-supported-languages                                        |

   定义输出方向 
   google-translate-output-destination
   - nil  弹出缓冲区
   - echo-area
   - popup  弹出窗口
   - kill-ring 
** helm 
   调整 helm 缓冲区尺寸
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers '(
                                                       (helm :variables helm-enable-auto-resize t)))
   #+END_SRC

   #+begin_verse
   查找,@@html:<kbd>@@ SPC / @@html:</kbd>@@ 
   直接在搜索到的内容里改结果，就不用转到文件了 。 ~C-c C-e~
   到父一层目录查找，范围更广了 ~C-l~
   启动瞬态 ~M-SPC~
   #+end_verse
      
   书签管理 
   | ~C-d~ |删除|
   | ~C-e~ | 编辑                   |
   | ~C-f~ | 是否显示文件名位置                     |
   | ~C-o~ | open the selected bookmark in another window |

   helm-swoop,显示实时的搜索缓冲区, ~SPC s s~,觉得也没啥用
       
   对于通用参数，用法是,先选择函数，然后按 ~C-u~,最后按 ~RET~ 
   实例 : ~SPC SPC org-reload C-u RET~
       
   多个文件替换，只要 ~C-c C-e~,然后进入 ~iedit state~ 模式(~SPC s e~)
       
   回到 helm-buffer ,快捷键是 ~SPC r l~
   
   helm 中排除某 STRING  !STRING
** html 
   emmet-mode ，本来叫 Zen Coding(禅码)，后改叫 Emmet  (一种实用工具厂商吧)， 功能是输入缩略词自动生成补全的 html css 片段
   #+begin_quote
   感觉用 auto-complete 好些，这个要记忆
   #+end_quote
*** 编译 Less
    C-c C-c         less-css-compile
    C-M-q           prog-indent-sexp

*** 缩略补全 C-j 扩展
    - HTML abbreviations
      - Basic tags
        a                       <a href=""></a>
        a.x                    <a class="x" href=""></a>
        a#q.x               <a id="q" class="x" href=""></a>
        a#q.x.y.z          <a id="q" class="x y z" href=""></a>
        #q                     <div id="q"> </div>
        .x                       <div class="x"> </div>
        #q.x                   <div id="q" class="x"> </div>
        #q.x.y.z              <div id="q" class="x y z"> </div>
      - Empty tags
        a/                       <a href=""/>
        a/.x                     <a class="x" href=""/>
        a/#q.x                   <a id="q" class="x" href=""/>
        a/#q.x.y.z               <a id="q" class="x y z" href=""/>
        Self-closing tags
        input[type=text]         <input type="text" name="" value=""/>
        img                      <img src="" alt=""/>
        img>metadata/*2          <img src="" alt=""> <metadata/> <metadata/> </img>
      - Siblings
        a+b                      <a href=""></a> <b></b>
        a+b+c                    <a href=""></a> <b></b> <c></c>
        a.x+b                    <a class="x" href=""></a> <b></b>
        a#q.x+b                  <a id="q" class="x" href=""></a> <b></b>
        a#q.x.y.z+b              <a id="q" class="x y z" href=""></a> <b></b>
        a#q.x.y.z+b#p.l.m.n      <a id="q" class="x y z" href=""></a> <b id="p" class="l m n"></b>
      - Tag expansion
        table+                   <table> <tr> <td> </td> </tr> </table>
        dl+                      <dl> <dt></dt> <dd></dd> </dl>
        ul+                      <ul> <li></li> </ul>
        ul++ol+                  <ul> <li></li> </ul> <ol> <li></li> </ol>
        ul#q.x.y[m=l]            <ul id="q" class="x y" m="l"> <li></li> </ul>
      - Parent > child
        a>b                      <a href=""><b></b></a>
        a>b>c                    <a href=""><b><c></c></b></a>
        a.x>b                    <a class="x" href=""><b></b></a>
        a#q.x>b                  <a id="q" class="x" href=""><b></b></a>
        a#q.x.y.z>b              <a id="q" class="x y z" href=""><b></b></a>
        a#q.x.y.z>b#p.l.m.n      <a id="q" class="x y z" href=""><b id="p" class="l m n"></b></a>
        #q>.x                    <div id="q"> <div class="x"> </div> </div>
        a>b+c                    <a href=""> <b></b> <c></c> </a>
        a>b+c>d                  <a href=""> <b></b> <c><d></d></c> </a>
      - Climb-up
        a>b^c                    <a href=""><b></b></a><c></c>
        a>b>c^d                  <a href=""> <b><c></c></b> <d></d> </a>
        a>b>c^^d                 <a href=""><b><c></c></b></a> <d></d>
      - Multiplication
        a*1                      <a href=""></a>
        a*2                      <a href=""></a> <a href=""></a>
        a/*2                     <a href=""/> <a href=""/>
        a*2+b*2                  <a href=""></a> <a href=""></a> <b></b> <b></b>
        a*2>b*2                  <a href=""> <b></b> <b></b> </a> <a href=""> <b></b> <b></b> </a>
        a>b*2                    <a href=""> <b></b> <b></b> </a>
        a#q.x>b#q.x*2            <a id="q" class="x" href=""> <b id="q" class="x"></b> <b id="q" class="x"></b> </a>
        a#q.x>b/#q.x*2           <a id="q" class="x" href=""> <b id="q" class="x"/> <b id="q" class="x"/> </a>
      - Item numbering
        ul>li.item$*3            <ul> <li class="item1"></li> <li class="item2"></li> <li class="item3"></li> </ul>
        ul>li.item$$$*3          <ul> <li class="item001"></li> <li class="item002"></li> <li class="item003"></li> </ul>
        ul>li.item$@-*3          <ul> <li class="item3"></li> <li class="item2"></li> <li class="item1"></li> </ul>
        ul>li.item$@3*3          <ul> <li class="item3"></li> <li class="item4"></li> <li class="item5"></li> </ul>
        ul>li.item$@-3*3         <ul> <li class="item5"></li> <li class="item4"></li> <li class="item3"></li> </ul>
        a$b$@-/*5                <a1b5/> <a2b4/> <a3b3/> <a4b2/> <a5b1/>
        a.$*2>b.$$@-*3           <a class=\"1\" href=""> <b class=\"03\"></b> <b class=\"02\"></b> <b class=\"01\"></b> </a> <a class=\"2\" href=""> <b class=\"03\"></b> <b class=\"02\"></b> <b class=\"01\"></b> </a>
      - Properties
        b[x]                     <b x=""></b>
        b[x=]                    <b x=""></b>
        b[x=""]                  <b x=""></b>
        b[x=y]                   <b x="y"></b>
        b[x="y"]                 <b x="y"></b>
        b[x="()"]                <b x="()"></b>
        b[x m]                   <b x="" m=""></b>
        b[x= m=""]               <b x="" m=""></b>
        b[x=y m=l]               <b x="y" m="l"></b>
        b/[x=y m=l]              <b x="y" m="l"/>
        b#foo[x=y m=l]           <b id="foo" x="y" m="l"></b>
        b.foo[x=y m=l]           <b class="foo" x="y" m="l"></b>
        b#foo.bar.mu[x=y m=l]    <b id="foo" class="bar mu" x="y" m="l"></b>
        b/#foo.bar.mu[x=y m=l]   <b id="foo" class="bar mu" x="y" m="l"/>
        b[x=y]+b                 <b x="y"></b> <b></b>
        b[x=y]+b[x=y]            <b x="y"></b> <b x="y"></b>
        b[x=y]>b                 <b x="y"><b></b></b>
        b[x=y]>b[x=y]            <b x="y"><b x="y"></b></b>
        b[x=y]>b[x=y]+c[x=y]     <b x="y"> <b x="y"></b> <c x="y"></c> </b>
      - Parentheses
        (a)                      <a href=""></a>
        (a)+(b)                  <a href=""></a> <b></b>
        a>(b)                    <a href=""><b></b></a>
        (a>b)>c                  <a href=""><b></b></a>
        (a>b)+c                  <a href=""><b></b></a> <c></c>
        z+(a>b)+c+k              <z></z> <a href=""><b></b></a> <c></c> <k></k>
        (x)*2                    <x></x> <x></x>
        ((x)*2)                  <x></x> <x></x>
        ((x))*2                  <x></x> <x></x>
        (x>b)*2                  <x><b></b></x> <x><b></b></x>
        (x+b)*2                  <x></x> <b></b> <x></x> <b></b>
      - Text
        a{Click me}              <a href="">Click me</a>
        a>{Click me}*2           <a href=""> Click me Click me </a>
        x{click}+b{here}         <x>click</x> <b>here</b>
        span>{click}+b{here}     <span> click <b>here</b> </span>
        p>{Click}+span{here}+{ to continue} <p> Click <span>here</span> to continue </p>
        p{Click}+span{here}+{ to continue} <p> Click </p> <span>here</span> to continue
      - Filter: HTML with comments
        a.b|c                    <!-- .b --> <a class="b" href=""></a> <!-- /.b -->
        #a>.b|c                  <!-- #a --> <div id="a"> <!-- .b --> <div class="b"> </div> <!-- /.b --> </div> <!-- /#a -->
      - Lorem ipsum (生成一段虚拟文本)
    - CSS abbreviations
      - Basic Usage
        - p1-2!+m10e+bd1#2s        padding: 1px 2px !important; margin: 10em; border: 1px #222 solid;
      - Keywords
        m                        margin: ;
        bg+                      background: #fff url() 0 0 no-repeat;
        c                        color: #000;
** imenu-list 
** import-js  [导入模块，并导航代码]
   安装  
   #+BEGIN_SRC sh
     $ npm install -g import-js
   #+END_SRC
   如果这不起作用,可以用下面方式 
   #+BEGIN_SRC sh
     $ sudo npm install --unsafe-perm -g import-js
   #+END_SRC

   启用，在 javascript 配置 
   #+BEGIN_SRC elisp
     (javascript :variables javascript-import-tool 'import-js)
   #+END_SRC
   然后，层 ~react~  和 ~typescript~ 也有此特性

   | ~SPC m i i~ | 导入光标下变量对应的模块                 |
   | ~SPC m i f~ | 导入任何缺少的模块并删除任何未使用的模块 |
   | ~SPC m i g~ | 转到光标下的变量模块                     |

** javascript
   启用 导入帮助程序(~ImportJS~) 
   #+begin_src sh
     $ npm install -g import-js
   #+end_src
  
   flycheck 错误检查
   #+BEGIN_SRC sh
     $ npm install -g eslint
     # or
     $ npm install -g jshint
   #+END_SRC

   如果安装在非标准目录中，请添加该目录
   #+BEGIN_SRC elisp
     (add-to-list 'exec-path "/path/to/node/bins" t)
   #+END_SRC

   美化 
   添加  ~web-beautify~ ，或 ~prettier~ 层，参考层文档

   import-js，导入模块，并导航代码
   #+BEGIN_SRC elisp
     (javascript :variables javascript-import-tool 'import-js)
   #+END_SRC
   | ~SPC m i i~ | 导入光标下变量对应的模块                 |
   | ~SPC m i f~ | 导入任何缺少的模块并删除任何未使用的模块 |
   | ~SPC m g i~ | 转到光标下变量对应的模块                 |

   选择后端 
   #+BEGIN_SRC elisp
     (javascript :variables javascript-backend 'tern)
   #+END_SRC

   或者本地变量 =.dir-locals.el=
   #+BEGIN_SRC elisp
     ((js2-mode (javascript-backend . lsp)))
   #+END_SRC

   选择格式化程序
   #+BEGIN_SRC elisp
     (javascript :variables javascript-fmt-tool 'web-beautify)
   #+END_SRC

   或者本地变量 =.dir-locals.el=
   #+BEGIN_SRC elisp
     ((js2-mode (javascript-fmt-tool . prettier)))
   #+END_SRC

   调试器（dap 集成）
   安装 =M-x dap-firefox-setup= 

   调整缩进，设置变量
   #+BEGIN_SRC emacs-lisp
     (setq-default js2-basic-offset 2)
   #+END_SRC
   或者
   #+BEGIN_SRC emacs-lisp
     (javascript :variables js2-basic-offset 2)
   #+END_SRC

   同样 缩进 JSON 文件的方式,或在 层中设置
   #+BEGIN_SRC emacs-lisp
     (setq-default js-indent-level 2)
   #+END_SRC

   浏览器端 REPL 交互 ,需要开启 httpd 服务
   空白页交互 run-skewer
   页面交互,需要安装 Greasemonkey 脚本
   #+BEGIN_SRC elisp
     (setq-default dotspacemacs-configuration-layers
                   '((javascript :variables javascript-repl `skewer)))
   #+END_SRC

   服务器端 REPL 交互 
   #+BEGIN_SRC elisp
     (setq-default dotspacemacs-configuration-layers
                   '((javascript :variables javascript-repl `nodejs)))
   #+END_SRC

   node ,配置 自动把 node_modules/.bin 添加到  =exec_path=
   #+BEGIN_SRC elisp
     (setq-default dotspacemacs-configuration-layers
                   '((javascript :variables node-add-modules-path t)))
   #+END_SRC

   js2 模式
   ~SPC m w~ ,切换 js2 模式警告和错误
   ~%~,块间跳转
   
   js2 mode 补全 ~node~ 变量
   #+BEGIN_SRC elisp
     (setq-default dotspacemacs-configuration-layers
                   '((javascript :variables js2-include-node-externs t)))
   #+END_SRC

   | ~SPC m z c~ | 隐藏元素          |
   | ~SPC m z o~ | 显示元素          |
   | ~SPC m z r~ | 显示所有元素      |
   | ~SPC m z e~ | 隐藏/显示元素开关 |
   | ~SPC m z F~ | 隐藏函数开关      |
   | ~SPC m z C~ | 隐藏注释开关      |

   重构（js2-refactor）
   | ~SPC m k~     | 删除到行的末尾，但不跨越语义边界                                       |
   | ~SPC m r 3 i~ | 将三元运算符转换为 if 语句                                             |
   | ~SPC m r a g~ | 如果缺少，则创建一个= / * global * / = annotation，并添加 var 以指向它 |
   | ~SPC m r a o~ | 用对象文字命名参数   替换函数调用的参数                                |
   | ~SPC m r b a~ | 将最后一个子节点移出当前函数，if-statement，for-loop 或 while-loop     |
   | ~SPC m r c a~ | 将多行数组转换为一行                                                   |
   | ~SPC m r c o~ | 将多行对象文字转换为一行                                               |
   | ~SPC m r c u~ | 将多行函数转换为一行（期望分号作为语句分隔符）                         |
   | ~SPC m r e a~ | 将一行数组转换为多行                                                   |
   | ~SPC m r e f~ | 将标记的表达式提取到新的命名函数中                                     |
   | ~SPC m r e m~ | 将标记的表达式提取到对象文字中的新方法中                               |

   文档（js-doc）
   | ~SPC m r d b~ | 为当前文件插入 JSDoc 注释 |
   | ~SPC m r d f~ | 为函数 插入 JSDoc 注释    |
   | ~SPC m r d t~ | 给注释插入 tag|
   | ~SPC m r d h~ | 显示可用的 jsdoc tag 列表 |

   REPL（skewer-mode）

   | ~SPC m e e~ | 求值选中部分表达式               |
   | ~SPC m e E~ | 求值选区并插入结果               |
   | ~SPC m s b~ | 求值 buff                        |
   | ~SPC m s B~ | 求值选区 并 切换到 REPL buffer   |
   | ~SPC m s r~ | 将当前选区发送到 REPL            |
   | ~SPC m s s~ | 切换到 REPL                      |

** lisp
*** 调试
    #+BEGIN_SRC elisp
      (defun helloworld (name)
        (let ((n (subroutine name)))
          (message (format "Hello world, %s!" name))))

      (defun subroutine (s)
        (concat "my dear " s))

      (helloworld "Spacemacs")
    #+END_SRC

    步骤
    1. 此在文件里 按 ~, '~
    1. 把光标放在源码块， 按 ~, e f~. 每个表达式都要执行一遍 (函数的定义有了)
    2. 如果想调试某个表达式，把光标放在 ~defun~ 关键字处，按 ~, d f~, 它会放置一个 ~断点~ (断点有了)
    3. 然后在调用的地方 ， =(helloworld "Spacemacs")= 右括号尾部, 按 ~, e e~ ,求值表达式 (调试的代码有了)

*** 结构安全编辑
    保持 ~s-expressions~ 平衡
    开关 ~SPC m T s~
     
    自动开启
    #+BEGIN_SRC emacs-lisp
      (spacemacs/toggle-evil-safe-lisp-structural-editing-on-register-hook-emacs-lisp-mode)
    #+END_SRC

    or to enable it for all supported modes:

    #+BEGIN_SRC emacs-lisp
      (spacemacs/toggle-evil-safe-lisp-structural-editing-on-register-hooks)
    #+END_SRC

    模式行会显示此标记  =🆂=
*** 键绑定
    | ~SPC m g G~                | 两一个窗口打开定义                       |
    | ~SPC m h h~                | 函数简短描述                             |
    | ~SPC m c c~                | 字节编译当前文件                         |
    | ~SPC m c l~                | 弹出 compile-log buffer                  |
    | ~SPC m e $~ or ~SPC m e l~ | 跳到行尾并求值,( 这个好 )                |
    | ~SPC m e b~                | evaluate current buffer                  |
    | ~SPC m e C~                | evaluate current =defun= or =setq=       |
    | ~SPC m e e~                | 求值光标前的表达式                       |
    | ~SPC m e f~                | 求值当前函数 (好)                        |
    | ~SPC m e r~                | evaluate current region  (这个很好)      |
    | ~SPC m :~                  | toggle nameless minor mode(关闭命名空间) |
    | ~SPC k :~                  | 执行 lisp 命令                           |
    | ~SPC k (~                  | 插入同级表达式(上一行)                   |
    | ~SPC k )~                  | 插入同级表达式(下一行)                   |
    | ~SPC k $~                  | 到此表达式尾部括号                       |
    | ~SPC k 0~                  | 到此表达式开头 ( % 更好)                 |
    | ~SPC k ds~                 | 删除光标下的符号 (还行)                  |
    | ~SPC k dw~                 | 删除 word                                |
    | ~SPC k w~                  | wrap expression with parenthesis         |
    | ~SPC k W~                  | unwrap expression                        |
    | ~SPC k y~                  | copy expression (还行)                   |
*** 用 overseer 测试
    | ~SPC m t a~ | overseer test |
    | ~SPC m t A~ | test debug    |
    | ~SPC m t t~ | run test      |
    | ~SPC m t b~ | test buffer   |
    | ~SPC m t f~ | test file     |
    | ~SPC m t g~ | test tags     |
    | ~SPC m t p~ | test prompt   |
    | ~SPC m t q~ | test quiet    |
    | ~SPC m t h~ | test help     |
*** 开启 smartparens 可以求值配对函数
    | ~SPC m e c~ | evaluate sexp around point   |
    | ~SPC m e s~ | evaluate symbol around point |
*** 调试
    | ~SPC m d f~ | on a =defun= symbol toggle on the instrumentalisation of the function  |
    | ~SPC m d F~ | on a =defun= symbol toggle off the instrumentalisation of the function |
    | ~SPC m d t~ | insert =(debug)= to print the stack trace and re-evaluate the function |

** org
*** Project [ 项目支持 ]
    指定项目特定 TODOs,如果是绝对路径，那么所有项目的 TODOs 都在那个文件里，只有
    文件名的话,就存储在项目的根目录

    #+BEGIN_SRC emacs-lisp
      (setq-default dotspacemacs-configuration-layers
                    '((org :variables org-projectile-file "TODOs.org")))
    #+END_SRC

    TODO 文件不会自动加载到 agenda 中的，可以这样配置 
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'org-agenda
        (require 'org-projectile)
        (mapcar '(lambda (file)
                   (when (file-exists-p file)
                     (push file org-agenda-files)))
                (org-projectile-todo-files)))
    #+END_SRC
*** capture 模板
    #+begin_src lisp
      ("f"         ; hotkey
       "测试" ; name
       entry       ; type
       (file+headline (lambda () (concat org-directory "/work.org")) "Tasks") ;target
       "* TODO [#A] %^{Task}\n%a%i%t%U\n" ; template
       )
    #+end_src

    类型 - type

    #+begin_verse
entry 指定标题节点
item 一个简单列表中的项目。同样，这个类型的模板最终需要存储在 org 文件中。
checkitem 一个带有 checkbox 的项目。与 item 类型的模板相比，多了一个 checkbox。
table-line 在指定位置表格添加一行新的记录。
plain 一段文字。如何输入的，就如何记录下来。
    #+end_verse


    target ：

    指定文件名和文件中唯一的标题
    (file+headline "path/to/file" "node headline")

    指定文件名和完整的标题路径（如果需要存放片段的标题不唯一）
    (file+olp "path/to/file" "Level 1 heading" "Level 2" ...)

    指定日期方式的标题路径，在今天的日期下添加片段
    (file+datetree "path/to/file")

    %a          annotation, normally the link created with org-store-link (文件存储路径)
    %i          initial content, the region when capture is called with C-u. (选择的内容)
    %t          timestamp, date only (当前日期)
    %T          timestamp with date and time (当前时间)
    %u, %U      like the above, but inactive timestamps (当前日期时间)
    %[FILE] Insert the contents of the file given by FILE.
    %(EXP) 
    %<FORMAT>  The result of format-time-string on the FORMAT specification.
    %c Current kill ring head.
    %x Content of the X clipboard.
    %k Title of the currently clocked task.
    %? After completing the template, position point here
    %^g Prompt for tags, with completion on tags in target file.
    %^G Prompt for tags, with completion all tags in all agenda files.
    %^t Like ‘%t’, but prompt for date. Similarly ‘%^T’, ‘%^u’, ‘%^U’. You may define a prompt like ‘%^{Birthday}t’.
    %^C Interactive selection of which kill or clip to use.
    %^L Like ‘%^C’, but insert as link.
    %^{PROP}p Prompt the user for a value for property PROP.
*** Sticky header[ 粘性标题支持 ]
    #+BEGIN_SRC emacs-lisp
      (setq-default dotspacemacs-configuration-layers '(
                                                        (org :variables
                                                             org-enable-sticky-header t)))
    #+END_SRC
*** 快捷键
**** 开关
     | ~SPC m T c~ | org-toggle-checkbox                           |
     | ~SPC m T e~ | org-toggle-pretty-entities                    |
     | ~SPC m T i~ | org-toggle-inline-images                      |
     | ~SPC m T l~ | org-toggle-link-display                       |
     | ~SPC m T t~ | org-show-todo-tree                            |
     | ~SPC m T T~ | org-todo                                      |
     | ~SPC m T V~ | toggle =space-doc-mode= a read-only view mode |
     | ~SPC m T x~ | org-preview-latex-fragment                    |
**** agenda list (清单列表)
     SPC m a	org-agenda  执行清单命令
     SPC m C c	org-agenda-clock-cancel 取消
     SPC m C i	org-agenda-clock-in  开始计时
     SPC m C o	org-agenda-clock-out
     SPC m C p	org-pomodoro 
     SPC m d d	org-agenda-deadline 清单结束时间
     SPC m d s	org-agenda-schedule 清单开始时间
     SPC m i e	org-agenda-set-effort
     SPC m i p	org-agenda-set-property 设置清单的属性
     SPC m i P	org-agenda-priority 设置优先级
     SPC m i t	org-agenda-set-tags
     SPC m s r	org-agenda-refile
     M-j	next item 下一项  (前后清单详情)
     M-k	previous item 前项
     M-h	earlier view 早期视图
     M-l	later view 后视图
     gr	refresh 刷新
     gd	toggle grid 切换网格
     C-v	change view 变换视图
     RET	org-agenda-goto
     L    隐藏完已经成的东西  

**** evil-org-mode
     | ~gj~ / ~gk~   | 元素间导航        |
     | ~gh~ / ~gl~   | 父 /子 间导航     |
     | ~gH~          | 根节点,第一级标题 |
     | ~M-j~ / ~M-k~ | 元素移动          |
     | ~M-J~ / ~M-K~ | 元素树移动        |
     | ~M-h~ / ~M-l~ | 元素自身升降级    |
     | ~M-H~ / ~M-L~ | 元素树升降级      |
**** 表
     | ~SPC m t c~   | 把表转换为 table.el              |
     | ~SPC m t d c~ | 删除列                           |
     | ~SPC m t d r~ | 删除行                           |
     | ~SPC m t e~   | 插入计算结果                     |
     | ~SPC m t E~   | 导出表格(格式自己配)             |
     | ~SPC m t i c~ | 插入列                           |
     | ~SPC m t i h~ | 插入水平线                       |
     | ~SPC m t i r~ | 插入行                           |
     | ~SPC m t I~   | 将文件导入表格                   |
     | ~SPC m t n~   | 新建表格                         |
     | ~SPC m t N~   | 新建 table.el 格式表格           |
     | ~SPC m t p~   | 使用 org-plot / gnuplot 绘制表格 |
     | ~SPC m t r~   | 应用公式计算当前行               |
     | ~SPC m t s~   | 表格排序                         |
     | ~SPC m t t f~ | 公式调试器开关                   |
     | ~SPC m t t o~ | 行/列号的显示开关                |
     | ~SPC m t w~   | 长行截断到两行                   |
**** 元素插入
     | ~SPC m i d~   | org-insert-drawer                                |
     | ~SPC m i D s~ | 插入屏幕截图                                     |
     | ~SPC m i D y~ | 插入网络图片(图片保存在一级标题命名的文件夹下)   |
     | ~SPC m i e~   | org-set-effort                     effort        |
     | ~SPC m i f~   | org-insert-footnote              脚注            |
     | ~SPC m i h~   | org-insert-heading             标题              |
     | ~SPC m i H~   | org-insert-heading-after-current                 |
     | ~SPC m i i~   | org-insert-item 列表项                           |
     | ~SPC m i K~   | spacemacs/insert-keybinding-org         键盘按键 |
     | ~SPC m i l~   | org-insert-link        链接                      |
     | ~SPC m i L~   | 网络链接，会自动附上有标题的链接                 |
     | ~SPC m i n~   | org-add-note  插入一段 note                         |
     | ~SPC m i p~   | org-set-property    插入属性                         |
     | ~SPC m i s~   | org-insert-subheading 插入子标题                      |
     | ~SPC m i t~   | org-set-tags                  插入 tag              |
     |               |                                                  |
**** link
     打开链接 | ~SPC m x o~ | org-open-at-point |
**** Babel / Source Blocks
     | ~SPC m b .~ | 进入 Transient 状态|
     | ~SPC m b a~ | 产生一个 has 码 org-babel-sha1-hash         |
     | ~SPC m b b~ | 执行块 org-babel-execute-buffer            |
     | ~SPC m b c~ | 检查 org-babel-check-src-block              |
     | ~SPC m b d~ | 分成两段代码块 org-babel-demarcate-block      |
     | ~SPC m b e~ | 执行 org-babel-execute-maybe               |
     | ~SPC m b f~ | org-babel-tangle-file                    |
     | ~SPC m b g~ | 跳到命名代码块 org-babel-goto-named-src-block   |
     | ~SPC m b i~ | org-babel-lob-ingest                     |
     | ~SPC m b I~ | 代码块信息 org-babel-view-src-block-info      |
     | ~SPC m b j~ | 插入头部参数 org-babel-insert-header-arg        |
     | ~SPC m b l~ | org-babel-load-in-session                |
     | ~SPC m b n~ | 下一个代码块 org-babel-next-src-block         |
     | ~SPC m b o~ | 打开求值结果 buffer  org-babel-open-src-block-result |
     | ~SPC m b p~ | 上一个代码块 org-babel-previous-src-block            |
     | ~SPC m b r~ | 跳到命名结果块 org-babel-goto-named-result      |
     | ~SPC m b s~ | org-babel-execute-subtree                |
     | ~SPC m b t~ | org-babel-tangle                         |
     | ~SPC m b u~ |跳到代码块头部 org-babel-goto-src-block-head     |
     | ~SPC m b v~ |在另一个 buffer 展开代码块  org-babel-expand-src-block |
     | ~SPC m b x~ | org-babel-do-key-sequence-in-edit-buffer |
     | ~SPC m b z~ | org-babel-switch-to-session              |
     | ~SPC m b Z~ | org-babel-switch-to-session-with-code    |
**** 加强
     | ~SPC m x b~ | 粗体     |
     | ~SPC m x c~ | 代码     |
     | ~SPC m x i~ | 斜体     |
     | ~SPC m x r~ | 清除特性 |
     | ~SPC m x s~ | 删除线   |
     | ~SPC m x u~ | 下划线   |
     | ~SPC m x v~ | 等宽     |

**** 日历导航
     | ~M-l~ | 明天 |
     | ~M-h~ | 昨天 |
     | ~M-j~ | 下周 |
     | ~M-k~ | 上周 |
     | ~M-L~ | 下月 |
     | ~M-H~ | 上月 |
     | ~M-J~ | 下年 |
     | ~M-K~ | 上年 |
**** 插入日期，时间
     ‘2/5/3’	⇒ 2003-02-05 插入日期
     ‘11am-1:15pm’	⇒ 11:00-13:15 插入时间

**** Presentation [简报,放大镜]
     激活  ~SPC SPC org-present~
**** org-export
     对于报错      
     ` user-error: Unable to resolve link: "thank-you" `
     使用 
     #+OPTIONS: broken-links:t

** php 
   需要初始化工程 
   cd /root/of/project
   touch .ac-php-conf.json
   
   然后执行命令   ac-php-remake-tags-all
   
   若有项目中含有这么两个文件，那么会自动创建 .ac-php-conf.json 文件
   1. =.projectile=
   2. =vendor/autoload.php=

   | 查关键词           | php-search-documentation |
   | 浏览手册           | php-browse-manual        |
   | 标记函数           | mark-defun               |
   | 跳到定义           | ~SPC m g g~              |
   | jump back 调回返回 | ~C-t~                    |

    lsp 调用 intelephense
** project  
   配置文件 .projectile 
   排除文件 .dot
   
** python
   后端 anaconda ,lsp-python 
   自动完成
   代码导航 
   文档查找，用 pylookup
   测试 test-run
   打开虚拟环境 pyenv
   自动删除未使用的库  autoflake
   对导入库排序 isort 
   修复导入 importmagic
   pip 包管理器
   
   配置项目后端 .dir-locals.el
   #+begin_src lisp
     ((python-mode (python-backend . lsp)))
   #+end_src

   配置局部变量  ~SPC f v d~

   anaconda 对于依赖报错 
   #+BEGIN_EXAMPLE
     Blocking call to accept-process-output with quit inhibited!!
   #+END_EXAMPLE

   需要手动安装以下依赖
   #+BEGIN_SRC sh
     pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
   #+END_SRC

   如果无法运行 anaconda 服务器 ，需要配置 PYTHONPATH 环境变量 

   语法检查，安装 
   #+BEGIN_SRC sh
     pip install flake8
   #+END_SRC

   测试，安装 pytest
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers
                   '((python :variables python-test-runner 'pytest)))
   #+END_SRC

   格式化工具
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers '(
                                                       (python :variables python-formatter 'yapf)))
   #+END_SRC

   测试时自动保存缓冲区
   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers '(
                                                       (python :variables python-save-before-test nil)))
   #+END_SRC

   要使用 pylookup,帮助文档,能跳到官网
   先更新数据库 ~SPC SPC pylookup-update~.

   自动排序
   #+BEGIN_SRC elisp
     (setq-default dotspacemacs-configuration-layers
                   '((python :variables python-sort-imports-on-save t)))
   #+END_SRC

   实现 importmagic 功能需要安装 
   #+BEGIN_SRC sh
     pip install importmagic epc
   #+END_SRC

   管理虚拟环境,隔离包版本,使用的是 pyvenv 工具
   先要安装工具 virtualenvwrapper,然后配置环境变量 =WORKON_HOME= ,指定虚拟环境的目录

   #+begin_src txt
virtualenvwrapper，相较于使用 virtualenv， 好处就是把所有环境都放在同一目录下管理，以便更好的管理及切换。
环境变量 WORKON_HOME，值为你想保存 env 文件的路径

创建虚拟环境 mkvirtualenv test
可以安装包了　pip

查看可用虚拟环境 lsvirtualenv  或　workon
   #+end_src

   #+begin_src bash
     # 外部用法
     $ pip install virtualenvwrapper
     $ export WORKON_HOME=~/Envs
     $ mkdir -p $WORKON_HOME
     # $ source /usr/local/bin/virtualenvwrapper.sh
     $ source ~/.pyenv/shims/virtualenvwrapper.sh
     $ mkvirtualenv env1
   #+end_src
   | ~SPC m v a~ | 激活任何目录中的虚拟环境          |
   | ~SPC m v d~ | 停用激活的虚拟环境                |
   | ~SPC m v w~ | 在 ~WORKON_HOME~   中处理虚拟环境 |

   用 pyenv 管理多个版本的 Python,使用的是 pyenv ，！！！注意只有一字之差
   设置 pyenv 环境, ~SPC m v s~ 
   取消设置 pyenv 环境, ~SPC m v u~ 

   交互模式
   启动交互模式, ~SPC m s i~ 

   运行 python 脚本,在多个文件同时工作时有用,因为交互模式不重载更改的模块  ~SPC m c c~
   在 comint shell 中执行当前文件, ~SPC m c c~ 
   在 comint shell 中执行当前文件并切换到 =insert state= , ~SPC m c C~ 
   如果输入参数，可以先用 ~SPC u~ 按键

   测试,这里要了解下的。????
   启动项目的所有测试, ~SPC m t a~
   启动当前测试, ~SPC m t t~

   重构,反射
   修复缺少的导入语句 ~SPC m r f~
   删除未使用的导入, ~SPC m r i~
   排序导入, ~SPC m r I~

   Pip 包管理
   列出所有在当前虚拟环境中 安装的包, ~SPC m P~
   d,删除标记
   r,刷新列表
   i,提示安装
   U,更新所有标记
   u,更新标记
   x,执行

   跳转
   跳回,  ~C-o~ 
** ranger (漫游者)
 - 启用预览 ranger-show-preview t
 - 切换开关 (setq ranger-enter-with-minus t)        ~-~ 
 - 预览隐藏文件开关 (setq ranger-show-hidden t)    zh
 - 设置目录层数 (setq ranger-parent-depth 2)  根据 z-和 z + 进行调整
 - 将父窗口的大小设置为帧大小的一部分 (setq ranger-width-parents 0.12)
 - 当目录层数太多，可以设置父目录最大宽度，避免显示太小 (setq ranger-max-parent-width 0.12)
 - 预览文本显示的开关 (setq ranger-show-literal t)  zi
 - 预览窗口的大小 (setq ranger-width-preview 0.55)
 - 不预览文件类型 (setq ranger-ignored-extensions '("mkv" "iso" "mp4"))
 - 不预览文件大小 (setq ranger-max-preview-size 10)  单位为兆( MB )
   | ~SPC a t r r~   | 启动 ranger                                                |
   | ~SPC a t r d~   | 启动 deer                                                  |
   | ~C-p~           | 在 ranger 与 deer 之间切换                                 |
   | ~yy~            | copy                                            (文件操作) |
   | ~pp~            | paste                                                      |
   | ~R~             | rename                                                     |
   | ~D~             | delete                                                     |
   | ~;C~            | copy directory / copy and move directory (目录操作)        |
   | ~;+~            | create directory                                           |
   | ~f~             | 切换目录                                                   |
   | ~l~             | 进入目录                                                   |
   | ~h~             | go up directory                                            |
   | ~H~             | 在上一个导航历史中切换                                     |
   | ~i~             | 预览开关                       (预览操作)                  |
   | ~zi~            | 预览文本形式开关                                           |
   | ~C-j~           | scroll preview window down                                 |
   | ~C-k~           | scroll preview window up                                   |
   | ~zh~            | dotfiles 开关                                              |
   | ~o~             | 排序                                                       |
   | ~q~             | quit                          (ranger 操作)                |
   | ~;g~            | revert buffer                                              |
   | ~z-~            | reduce number of parents                                   |
   | ~z+~            | increment number of parents                                |
   | ~C-SPC~ / ~TAB~ | 文件标记    (mark 操作)                                    |
   | ~v~             | 标记所有                                                   |
   | ~t~             | 标记切换                                                   |
   | ~S~             | enter shell                                                |
   | ~C-n~           | 创建 Tab  (Tab 操作)                                       |
   | ~C-w~           | 关闭 Tab                                                   |
   | ~g t~     / ~C-Tab~ | 下一个 Tab  (不好使)                                            |
   | ~C-S-Tab~        |      上一个 Tab                                               |
** react
** semantic 
   底部显示定义
   顶部显示函数
   支持 refactor

   | ~SPC m r~ | srefactor: refactor thing at point. |
** sql 
    | 显示*SQL*buffer| ~SPC m b b~ |
    | 显示数据库中的表 | ~SPC m l a~ |
    | 显示表信息       | ~SPC m l t~ |
    | 发送 buffer 执行   | ~SPC m s b~ |
    | 发送选区执行     | ~SPC m s r~ |

** tern
   增加了对 JavaScript 代码分析的引擎 [ tern 引擎 ]

   安装
   #+BEGIN_SRC sh
     $ npm install -g tern
   #+END_SRC

   在多个不同的编辑会话中重用服务器
   默认不创建项目  =.tern-port= 文件
   #+BEGIN_SRC emacs-lisp
     (tern :variables tern-disable-port-files nil)
   #+END_SRC

   ~M-.~ ,上个命令

   | ~SPC m C-g~   | 带你回到你按 ~M-.~  的最后一个位置                       |
   | ~SPC m g g~   | 跳转到光标下的东西的定义处                               |
   | ~SPC m g G~   | 跳转到给定名称的定义(gtag)                               |
   | ~SPC m h d~   | 找到光标下的东西的文档, 再按一次打开关联的 URL（如果有） |
   | ~SPC m h t~   | 找到光标下的东西的类型                                   |
   | ~SPC m r r V~ | 使用 tern 重命名光标下的变量                             |
** Yasnippet 
   执行命令,用 `` 包含的代码能够执行 #+DATE: `(format-time-string "%Y-%m-%d %H:%M:%S" (current-time))`

** go
** Ruby layers
   1.打开交互模式 inf-ruby
   2.使用 ruby-send-region

** vue
   处理 vue 文件
** lsp
   相当于每个语言有每个语言的编译器一样，这种语言服务统一各个语言的差别，使用同样的功能接口，当然也有差异。 
   用此层，基本默认语言都用这个插件，除非另外说明
  
   LSP 生态系统基于两个软件包:
   - lsp-mode
   - lsp-ui

   功能
   - 交叉引用，相当于智能识别语言的语法了哇，给出上下文
   - 广泛重命名
   - 用 eldoc 显示 标签帮助
   - 用 lsp-ui-doc 在子 frame 中显示符号文档
   - lsp-describe-session 列出语言服务的功能
   - 使用 imenu 进行 导航
   - lsp-navigation 方便导航 (lsp-ui-peek 另一种)  快捷键 *SPC m g/G*
** dash
** spell checking    
 | ~SPC S a b~     | Add word to dict (buffer)              |
 | ~SPC S a g~     | Add word to dict (global)              |
 | ~SPC S a s~     | Add word to dict (session)             |
 | ~SPC S b~       | Flyspell whole buffer                  |
 | ~SPC S c~       | Flyspell correct word before point     |
 | ~SPC S s~       | Flyspell correct word at point         |
 | ~SPC u SPC S c~ | Flyspell correct all errors one by one |
 | ~SPC S d~       | Change dictionary                      |
 | ~SPC S n~       | Flyspell goto next error               |
 | ~SPC t S~       | Toggle flyspell                        |

* package
** tern
   智能的 Javascript 工具
*** 配置文件    
    工程配置文件 .tern-project 按目录树向上遍历，没有就采用默认配置
    主配置文件 .tern-config
    
    选项 
    --port <number> : 指定监听端口
    --host <host>; h 指定监听主机（默认 127.0.0.1)
*** JSON 协议
    请求方式是 ~POST~ 的 ~JSON~ 。
    
    json 文档结构包含可选的  query, files, and timeout
*** 功能
    type 查询某事物的类型。
    file，end（必填），start（可选）

    completions 向服务器询问给定点的一组完成情况集合
    接受的字段是： file，end（必填） 指定要完成的位置
    types（可选，默认 false） 是否在结果数据中包含完成的类型
    docs，urls，origins（可选，默认 false）

    documentation 获取给定表达式的文档字符串和 URL（如果有）。
    使用 file，end（必需）和 start（可选）字段来指定我们感兴趣的表达式。
    
    file 指向定义文件的位置 
    end 字段是此文件的偏移量
*** 编程接口
    基本服务功能 (不含 HTTP 或读配置文件) 的实现在 ~lib/tern.js~
   
    自带的插件有 
    CommonJS module plugin: 
    Node.js 插件 : node
    Node.js 解析插件
    RequireJS plugin
    每种插件有自己的配置方式
*** 服务器插件
    为服务器添加额外的功能
    #+begin_src json
      {
          "libs": [
              "browser",
              "jquery"
          ],
          "loadEagerly": [
              "importantfile.js"
          ],
          "plugins": {
              "requirejs": {
                  "baseURL": "./",
                  "paths": {}
              },"node":{

              }
          }
      }
    #+end_src
    
loadEagerly: 指定的文件永远加载
plugins 用于包含插件(可在里面配置插件的具体属性)
** org-web-tools
   - org-web-tools-insert-link-for-url 插入链接，会自动附上标题
   - org-web-tools-insert-web-page-as-entry 把链接处的文章转为 org 格式文件插入
   - org-web-tools-read-url-as-org 同上，只是读到不同缓冲区
   - org-web-tools-convert-links-to-page-entries 只包含链接链表可以用此命令，用来转链接到标题
   - 以下是实用函数
   - org-web-tools--dom-to-html:  (IMG 标记可能使用结束的“ / IMG”标记呈现)
   - org-web-tools--eww-readable:  返回 HTML 的“可读”部分和标题
   - org-web-tools--get-url:  以字符串形式返回 URL 的内容
   - org-web-tools--html-title:HTML 页面的返回标题
* 窗口管理 
  假设 Emacs 需要打开三个类型的窗口，1 代码，2 终端 3，文档，怎么确保代码在对应的窗口打开，可以使用 window-purpose
  
 命令 
- switch-to-buffer and display-buffer
- helm-source-buffers-list
- purpose-mode 与 pupo-mode 切换
- SPC r b 打开 buffer (同一类的)
- SPC r p 选择某类的 buffer 打开
