* Emacs Lisp Basics

This page is a short, practical, tutorial of Emacs Lisp the language.

To evaluate elisp code, for example, type =(+ 3 4)=, then move your
cursor to after the closing parenthesis, then call =eval-last-sexp=
【Ctrl+x Ctrl+e】. Emacs will evaluate the lisp expression to the left
of the cursor.

Or, you can select the lisp code, then Alt+x =eval-region=.

To find the doc string of a function, Alt+x =describe-function= 【Ctrl+h
f】. (if the function name is under cursor, you don't need to type the
name, just hit Enter.)

[[file:feed_0/article_6/images/img1_u4.png]]

eval emacs lisp code basics. [see
[[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

To turn on syntax highlight, Alt+x =emacs-lisp-mode=.

** Printing
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ; printing
    (message "hi")

    ; printing variable values
    (message "Her age is: %d" 16)        ; %d is for number
    (message "Her name is: %s" "Vicky")  ; %s is for string
    (message "My list is: %S" (list 8 2 3))  ; %S is for any lisp expression
#+END_SRC

You can see the output in the buffer named “*Messages*”. You can switch
to it by Alt+x =view-echo-area-messages= 【Ctrl+h e】.

[see [[../emacs/elisp_printing.html][Elisp: Print, Output]]]

[see [[../emacs/elisp_format.html][Elisp: Format String]]]

** Arithmetic
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (+ 4 5 1)  ; 10
    (- 9 2)    ; 7
    (- 9 2 3)  ; 4
    (* 2 3)    ; 6
    (* 2 3 2)  ; 12

    ;; integer part of quotient
    (/ 7 2)    ; 3

    ;; division
    (/ 7 2.0)  ; 3.5

    ;; mod, remainder
    (% 7 4)    ; 3

    ;; power; exponential
    (expt 2 3) ; 8
#+END_SRC

WARNING: single digit decimal number such as =2.= needs a zero after the
dot, like this: =2.0=. For example, =(/ 7 2.)= returns 3, not 3.5.

#+BEGIN_SRC emacs-lisp
    ;; 3. is a integer, 3.0 is a float
    (integerp 3.) ;  t
    (floatp 3.) ;  nil
    (floatp 3.0) ;  t
#+END_SRC

Function names that end with a “p” often means it return either true or
false. (The “p” stands for “predicate”) =t= means true; =nil= means
false.

** Convert Float/Integer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; int to float
    (float 3) ; 3.0

    (truncate 3.3) ; 3

    (floor 3.3) ; 3

    (ceiling 3.3) ; 4

    (round 3.4) ; 3
#+END_SRC

[[../emacs_manual/elisp/Numeric-Conversions.html][(info "(elisp) Numeric
Conversions")]]

*** Convert String and Number
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    (string-to-number "3")
    (number-to-string 3)
#+END_SRC

You can also use =format= to convert number to string. [see
[[../emacs/elisp_format.html][Elisp: Format String]]]

[[../emacs_manual/elisp/Numbers.html][(info "(elisp) Numbers")]]

** True, False
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In elisp, the symbol =nil= is false, anything else is true. Also, =nil=
is equivalent to the empty list =()=, so =()= is also false.

#+BEGIN_SRC emacs-lisp
    ;; all the following are false. They all evaluate to nil
    (if nil "yes" "no") ;  "no"
    (if () "yes" "no") ;  "no"
    (if '() "yes" "no") ;  "no"
    (if (list) "yes" "no") ;  "no", because (list) eval to a empty list, same as ()
#+END_SRC

By convention, the symbol =t= is used for true.

#+BEGIN_SRC emacs-lisp
    (if t "yes" "no") ;  "yes"
    (if 0 "yes" "no") ;  "yes"
    (if "" "yes" "no") ;  "yes"
    (if [] "yes" "no") ;  "yes". The [] is vector of 0 elements
#+END_SRC

There is no “boolean datatype” in elisp. Just remember that =nil= and
empty list =()= are false, anything else is true.

*** Boolean Functions
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's =and= and =or=.

#+BEGIN_SRC emacs-lisp
    (and t nil) ;  nil
    (or t nil) ;  t

    ;; can take multiple args
    (and t nil t t t t) ;  nil
#+END_SRC

Comparing numbers:

#+BEGIN_SRC emacs-lisp
    (< 3 4) ; less than
    (> 3 4) ; greater than

    (<= 3 4) ; less or equal to
    (>= 3 4) ; greater or equal to

    (= 3 3)   ;  t
    (= 3 3.00000000000000001) ;  t

    (/= 3 4) ; not equal. ⇒ t
#+END_SRC

Comparing strings:

#+BEGIN_SRC emacs-lisp
    ;; compare string
    (equal "abc" "abc") ;  t

    ;; dedicated function for comparing string
    (string-equal "abc" "abc") ;  t

    (string-equal "abc" "Abc") ;  nil. Case matters

    ;; can be used to compare string and symbol
    (string-equal "abc" 'abc) ;  t
#+END_SRC

For generic equality test, use =equal=. It tests if two values have the
same datatype and value.

#+BEGIN_SRC emacs-lisp
    ;; test if two values have the same datatype and value.

    (equal 3 3) ;  t
    (equal 3.0 3.0) ;  t

    (equal 3 3.0) ;  nil. Because datatype doesn't match.

    ;; test equality of lists
    (equal '(3 4 5) '(3 4 5))  ;  t
    (equal '(3 4 5) '(3 4 "5")) ;  nil

    ;; test equality of strings
    (equal "e" "e") ;  t

    ;; test equality of symbols
    (equal 'abc 'abc) ;  t
#+END_SRC

There's also the function =eq=, it returns =t= if the two args are the
same Lisp object. This is usually not what you want. =(eq "e" "e")=
returns =nil=.

To test for inequality, the =/== is for numbers only, and doesn't work
for strings and other lisp data. Use =not= to negate your equality test,
like this:

#+BEGIN_SRC emacs-lisp
    (not (= 3 4)) ;  t
    (/= 3 4) ;  t. “/=” is for comparing numbers only

    (not (equal 3 4)) ;  t. General way to test inequality.
#+END_SRC

- [[../emacs_manual/elisp/Comparison-of-Numbers.html][(info "(elisp)
  Comparison of Numbers")]]
- [[../emacs_manual/elisp/Equality-Predicates.html][(info "(elisp)
  Equality Predicates")]]

*** even, odd
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    (= (% n 2) 0) ; test even

    (= (% n 2) 1) ; test odd
#+END_SRC

** Variables
   :PROPERTIES:
   :CLASS: calibre17
   :END:

*** Global Variables
    :PROPERTIES:
    :CLASS: calibre14
    :END:

=setq= is used to set variables. Variables need not be declared, and is
global.

#+BEGIN_SRC emacs-lisp
    (setq x 1) ; assign 1 to x
    (setq a 3 b 2 c 7) ; multiple assignment
#+END_SRC

*** Local Variables
    :PROPERTIES:
    :CLASS: calibre14
    :END:

To define local variables, use =let=. The form is:

=(let (var1 var2 …) body)=

where body is (one or more) lisp expressions. The body's last
expression's value is returned.

#+BEGIN_SRC emacs-lisp
    (let (a b)
     (setq a 3)
     (setq b 4)
     (+ a b)
    ) ;  7
#+END_SRC

Another form of =let= is this:

=(let ((var1 val1) (var2 val2) …) body)=

#+BEGIN_SRC emacs-lisp
    (let ((a 3) (b 4))
     (+ a b)
    ) ;  7
#+END_SRC

This form lets you set values to variable without using many =setq= in
the body. This form is convenient if you just have a few simple local
vars with known values.

[[../emacs_manual/elisp/Variables.html][(info "(elisp) Variables")]]

** If Then Else
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The form for “if” expression is:

=(if test body)=

or

=(if test true_body false_body)=

#+BEGIN_SRC emacs-lisp
    (if (< 3 2) 7 8 ) ; 8

    ;; no false expression, return nil
    (if (< 3 2) (message "yes") ) ; nil
#+END_SRC

[[../emacs_manual/elisp/Control-Structures.html][(info "(elisp) Control
Structures")]]

If you do not need a “else” part, you should use the function =when=
instead, because it is more clear. The form is:

=(when test expr1 expr2 …)=

Its meaning is the same as

=(if test (progn expr1 expr2 …))=

** Block of Expressions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Sometimes you need to group several expressions together as one single
expression. This can be done with =progn=.

#+BEGIN_SRC emacs-lisp
    (progn (message "a") (message "b"))
    ;; is equivalent to
    (message "a") (message "b")
#+END_SRC

The purpose of =(progn …)= is similar to a block of code ={…}= in C-like
languages. It is used to group together a bunch of expressions into one
single parenthesized expression. Most of the time it's used inside “if”.

#+BEGIN_SRC emacs-lisp
    (if something
        (progn ; true
        …
        )
        (progn ; else
        …
        )
    )
#+END_SRC

=progn= returns the last expression in its body.

#+BEGIN_SRC emacs-lisp
    (progn 3 4 ) ; 4
#+END_SRC

[[../emacs_manual/elisp/Sequencing.html][(info "(elisp) Sequencing")]]

** Loop
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Most basic loop in elisp is with =while=.

=(while test body)=

, where body is one or more lisp expressions.

#+BEGIN_SRC emacs-lisp
    (setq x 0)

    (while (< x 4)
      (print (format "number is %d" x))
      (setq x (1+ x)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; inserts Unicode chars 32 to 126
    (let ((x 32))
      (while (< x 127)
        (insert-char x)
        (setq x (+ x 1))))
#+END_SRC

Usually it's better to use =dolist= or =dotimes=.

[see [[file:elisp_mapcar_loop.html][Elisp: Map List/Vector]]]

[[../emacs_manual/elisp/Iteration.html][(info "(elisp) Iteration")]]

*** Break/Exit a Loop
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[file:elisp_break_loop.html][Elisp: throw, catch]]

** Sequence, List, Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_list_vs_vector.html][Elisp: Sequence Type]]

[[file:elisp_vector.html][Elisp: Vector]]

[[file:elisp_list.html][Elisp: List]]

** Define a Function
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Basic function definition is of the form:

=(defun function_name (param1 param2 …) "doc_string" body)=

#+BEGIN_SRC emacs-lisp
    (defun myFunction ()
      "testing"
      (message "Yay!"))
#+END_SRC

When a function is called, the last expression in the function's
definition body is returned. (there's no “return statement”.)

[[../emacs_manual/elisp/Defining-Functions.html][(info "(elisp) Defining
Functions")]]

*** Define a Command
    :PROPERTIES:
    :CLASS: calibre14
    :END:

A command is a function that emacs user can call by
=execute-extended-command= 【Alt+x】.

When a function is also a command, we say that the function is available
for interactive use.

To make a function available for interactive use, add =(interactive)=
right after the doc string.

Evaluate the following code. Then, you can call it by
=execute-extended-command= 【Alt+x】

#+BEGIN_SRC emacs-lisp
    (defun yay ()
      "Insert “Yay!” at cursor position."
      (interactive)
      (insert "Yay!"))
#+END_SRC

[[../emacs_manual/elisp/Defining-Commands.html][(info "(elisp) Defining
Commands")]]

Here is a function definition template that majority of elisp commands
follow:

#+BEGIN_SRC emacs-lisp
    (defun myCommand ()
      "One sentence summary of what this command do.

    More detailed documentation here."
      (interactive)
      (let (localVar1 localVar2 …)
        ; do something here …
        ; …
        ; last expression is returned
      )
    )
#+END_SRC

See also:

- [[file:elisp_optional_params.html][Elisp: Function Optional
  Parameters]]
- [[file:inline_doc.html][Elisp: Doc String Markup]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_basics.html]]

\\
\\
| [[../index_u7.html#article_6][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u28.html>>

| [[../article_8/index_u11.html][下一项]] |
[[../index_u7.html#article_7][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_6/index_u1.html][上一项]] |

--------------

* Overview of Text-Processing in Emacs Lisp
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2005-10-30. Last updated: 2019-02-03.

In emacs, a user can program it using the embedded language (called
Emacs Lisp, or elisp) so that he can have custom functions to insert
texts, templates, process files, and many other features of emacs.

Emacs provides functions for text manipulation.

For example, there is a lisp function that returns the cursor position
in a buffer. A function that returns the beginning/ending position of
the text selection. Functions that move the cursor to a given position,
or delete a region of text of given positions. Functions that insert a
string at a given position. Functions that open or save files. Functions
that list opened files. Functions that list buffer names. Functions that
colors text , ... and much more.

** Example of Simple Elisp Functions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

*** Cursor Position
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; current cursor position is called “point”.
    ;; Left of first char in buffer is 1
    ;; This returns the current cursor position
    (point)

    ;; returns the position of the beginning/end of region (selection)
    (region-beginning)
    (region-end)

    ;; position for beginning/ending of current line
    (line-beginning-position)
    (line-end-position)

    ;; returns the position for the beginning/end of buffer, taking account of narrow-to-region
    (point-min)
    (point-max)
#+END_SRC

Note: position is considered between characters. The left of the first
character in buffer has position 1.

By default, cursor is shown as black square ▮ over a character, the
position is to the left of the black square.

Try this. Type

=(point)=

in a buffer. Then, place cursor after the right parenthesis, then Alt+x
=eval-last-sexp= 【Ctrl+x Ctrl+e】

The result is current cursor position.

[see [[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

*** Move Cursor, Search Text
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; move cursor to position 39
    (goto-char 39)

    ;; move cursor by 4 chars
    (forward-char 4)
    (backward-char 4)

    ;; move cursor to the location of a string
    ;; returns the new position
    (search-forward "some") ; to end of “some”
    (search-backward "some") ; to beginning of “some”

    ;; move cursor to the location matched by a regex
    ;; returns the new position
    (re-search-forward "[0-9]") ; digit
    (re-search-backward "[0-9]")

    ;; move cursor to the first char that's not “a to z”
    ;; Returns the distance traveled.
    (skip-chars-forward "a-z")
    (skip-chars-backward "a-z")
#+END_SRC

*** Delete, Insert, Change, Text
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; delete 9 chars starting at current cursor pos
    (delete-char 9)

    ;; deleting text from pos 3 to 10
    (delete-region 3 10)

    ;; insert string at current cursor position
    (insert "i ♥ cats")

    ;; get the string from pos 71 to 300
    (setq x (buffer-substring 71 300))

    ;; capitalize letters in a region
    (capitalize-region 71 300)
#+END_SRC

*** String
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; length
    (length "abc")
    ; returns 3

    ;; substring
    (substring "abcdefg" 3 4)
    ; returns "d"

    ;; change a given string using regex
    (replace-regexp-in-string "[0-9]" "X" "abc123")
    ;; returns "abcXXX"
#+END_SRC

*** Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; return the name of current buffer
    (buffer-name)

    ;; return the full path of current file
    (buffer-file-name)

    ;; switch to the buffer named xyz
    (set-buffer "xyz")

    ;; save current buffer
    (save-buffer)

    ;; close a buffer named xyz
    (kill-buffer "xyz")

    ;; temporarily sets a buffer as current to work with
    (with-current-buffer "xyz"
      ;; do something here. delete/insert text, etc.
    )
#+END_SRC

*** File
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; open a file (in a buffer)
    (find-file "~/")

    ;; same as “Save As”.
    (write-file path)

    ;; insert file into current position
    (insert-file-contents path)

    ;; append a text block to file
    (append-to-file start-pos end-pos path)

    ;; renaming file
    (rename-file file-name new-name)

    ;; copying file
    (copy-file old-name new-name)

    ;; deleting file
    (delete-file file-name)

    ;; get dir path
    (file-name-directory full-path)

    ;; get filename part
    (file-name-nondirectory full-path)

    ;; get filename's suffix
    (file-name-extension file-name)

    ;; get filename sans suffix
    (file-name-sans-extension file-name)
#+END_SRC

** A Simple Example
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This code shows how to insert a string, then position cursor somewhere
inside.

#+BEGIN_SRC emacs-lisp
    (defun insert-p-tag ()
      "Insert <p></p> at cursor point."
      (interactive)
      (insert "<p></p>")
      (backward-char 4))
#+END_SRC

Copy and paste the above into any buffer, then select the whole code,
Alt+x =eval-region=.

To call the command, Alt+x insert-p-tag.

For more simple and practical elisp examples, see
[[file:elisp_examples.html][Elisp Examples]].

** Programing a Major/Minor Mode
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Programing emacs is more than text processing. For example, all of the
following major modes are written in elisp:

- =org-mode= [see [[file:emacs_org_markup.html][Emacs: Org Mode Markup
  Cheatsheet]]]
- • =python-mode= • =js-mode= • =ruby-mode=
- Alt+x =tetris=
- [[file:file_management.html][Emacs: File Manager, dired]]
- [[file:eshell.html][Emacs: eshell]]
- [[file:emacs_eww_web_browser.html][Emacs: Eww Web Browser]]

Tasks of writing a mode is more complex, because it involves
understanding many of emacs's systems: keyboard input event, display
(windows and fonts), user interface (menu, windows, scroll bar, tool
bar), major/minor mode's structure, coloring text, package structure,
etc.

You should have some experience doing text processing in elisp before
writing a major mode.

[[file:elisp_write_major_mode_index.html][Emacs Lisp How to Write Major
Mode]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_editing_basics.html]]

\\
\\
| [[../index_u7.html#article_7][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u11.html>>

| [[../article_9/index_u17.html][下一项]] |
[[../index_u7.html#article_8][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_7/index_u28.html][上一项]] |

--------------

* Elisp: Simple Emacs Lisp Examples
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2005-11-30. Last updated: 2019-10-18.

This page shows very simple and useful emacs lisp commands that are
shorter than 10 lines. They show you the basic programing in elisp.

** Insert Text
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This code shows how to insert a string, and also position cursor after
the insertion.

#+BEGIN_SRC emacs-lisp
    (defun insert-p-tag ()
      "Insert <p></p> at cursor point."
      (interactive)
      (insert "<p></p>")
      (backward-char 4))
#+END_SRC

You can use this code to insert your {signature, template, headers,
footers, ...}.

Put cursor after the last parenthesis, then Alt+x =eval-last-sexp=
【Ctrl+x Ctrl+e】.

Then, you can call the command you just defined by name. For example,
Alt+x insert-p-tag.

[see [[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

To see a function's documentation, Alt+x =describe-function= 【Ctrl+h
f】.

[see [[file:elisp_doc_lookup.html][Elisp: Documentation Lookup]]]

** Insert Around Region
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This code shows how to place a string at the beginning and end of a
region.

#+BEGIN_SRC emacs-lisp
    (defun wrap-markup-region ()
      "Insert a markup <b></b> around a region."
      (interactive)
      (save-excursion
        (goto-char (region-end))
        (insert "</b>")
        (goto-char (region-beginning))
        (insert "<b>")))
#+END_SRC

You can use this code to add HTML begin/end tag on a selected text, or
add brackets around a selection.

Exercise: modify this do ask user what html tag use.

** Select Current Word
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This code shows you how to set a mark (select text) programmatically.

#+BEGIN_SRC emacs-lisp
    ;; turn on highlight selection
    (transient-mark-mode 1)

    (defun select-current-word ()
      "Select the word under cursor.
    “word” here is considered any alphanumeric sequence with “_” or “-”."
      (interactive)
      (let (pt)
        (skip-chars-backward "-_A-Za-z0-9")
        (setq pt (point))
        (skip-chars-forward "-_A-Za-z0-9")
        (set-mark pt)))
#+END_SRC

** Select Current Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; turn on highlight selection
    (transient-mark-mode 1)

    (defun select-current-line ()
      "Select the current line"
      (interactive)
      (let ((pos (line-beginning-position)))
        (end-of-line)
        (set-mark pos)))
#+END_SRC

See also: [[file:emacs_region.html][Elisp: Region, Active Region]].

Exercise: write a command to select current text block. (text block are
separated by empty lines.)

** Find Replace String in Region
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's how to do text replacements on a region.

#+BEGIN_SRC emacs-lisp
    (defun replace-greek-region ()
      "Replace “alpha” to “α” and other greek letters in current region."
      (interactive)
      (let (
            (p1 (region-beginning))
            (p2 (region-end)))
        (save-restriction
          (narrow-to-region p1 p2)
          (goto-char (point-min))
          (while (search-forward " alpha" nil t)
            (replace-match " α" nil t))
          (goto-char (point-min))
          (while (search-forward " beta" nil t)
            (replace-match " β" nil t))
          (goto-char (point-min))
          (while (search-forward " gamma" nil t)
            (replace-match " γ" nil t)))))
#+END_SRC

You can modify the code to do other replacements. For example, HTML XML
Entities. [see [[http://xahlee.info/js/html_xml_entities.html][HTML/XML
Entity List]]]

Exercise: make this do current buffer, or current line.

** Delete Enclosed Text
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This code shows how to delete text enclosed by any pairs of delimiters.

For example, if you are editing HTML code, suppose you have text

=<p>something something long …</p>=

and your cursor is somewhere in between the tags. You want to quickly
delete all texts inside the p tags. The following function will do. It
will also, delete any text between quotes or parenthesis.

#+BEGIN_SRC emacs-lisp
    (defun delete-enclosed-text ()
      "Delete texts between any pair of delimiters."
      (interactive)
      (save-excursion
        (let (p1 p2)
          (skip-chars-backward "^([<>“")
          (setq p1 (point))
          (skip-chars-forward "^)]<>”")
          (setq p2 (point))
          (delete-region p1 p2))))
#+END_SRC

** Delete Linebreaks
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This example shows how to temporarily change a predefined variable's
value, then call a function whose behavior depends on the var.

#+BEGIN_SRC emacs-lisp
    (defun remove-line-breaks ()
      "Remove line endings in current paragraph."
      (interactive)
      (let ((fill-column (point-max)))
        (fill-paragraph nil)))
#+END_SRC

For detail, see: [[file:emacs_unfill-paragraph.html][Emacs: Hard Wrap
Lines]].

** Inserting a Random Number
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (random t) ; seed it randomly

    (defun insert-random-number ()
      "Insert a random number between 0 to 999999."
      (interactive)
      (insert (number-to-string (random 999999))) )
#+END_SRC

For more, see: [[file:elisp_insert_random_number_string.html][Emacs:
Insert Random Number/Hex/String]]

** Reference Lookup
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This example shows the use of =thing-at-point= and =browse-url=.

It will look up the word under the cursor in a online dictionary.

#+BEGIN_SRC emacs-lisp
    (defun word-definition-lookup ()
    "Look up the word under cursor in a browser."
     (interactive)
     (browse-url
       (concat "http://www.answers.com/main/ntquery?s=" (thing-at-point 'symbol))))
#+END_SRC

For detail, see: [[file:emacs_lookup_ref.html][Emacs: Lookup Google,
Dictionary, Documentation]].

** Change Newline Character
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This example shows how to define a function that takes a file path and
process the file.

#+BEGIN_SRC emacs-lisp
    (defun to-unix-eol (fPath)
      "Change file's line ending to unix convention."
      (let ((myBuffer (find-file fPath)))
        (set-buffer-file-coding-system 'unix) ; or 'mac or 'dos
        (save-buffer)
        (kill-buffer myBuffer)))
#+END_SRC

For example, if the file =~/readme.txt= is a Windows file, you can
change its line ending by evaluating the following:

#+BEGIN_SRC emacs-lisp
    (to-unix-eol "~/readme.txt")
#+END_SRC

The following example shows how to apply a file processing function to a
list of files.

#+BEGIN_SRC emacs-lisp
    (mapc 'to-unix-eol
     (list
    "~/myfile1"
    "~/myfile2"
    "~/myfile3"
    ; …
      )
    )
#+END_SRC

The following wraps it as a command, so can be called in dired. It acts
on all marked files.

#+BEGIN_SRC emacs-lisp
    (defun dired-2unix-marked-files ()
      "Change to unix line ending for marked (or next arg) files."
      (interactive)
      (mapc 'to-unix-eol (dired-get-marked-files))
    )
#+END_SRC

** Delete Current File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This example shows command that lets you delete the current file. Note
here that elisp is used to: {manipulate buffer, manipulate file, prompt
user}.

#+BEGIN_SRC emacs-lisp
    (defun delete-current-file ()
      "Delete the file associated with the current buffer.
    Delete the current buffer too.
    If no file is associated, just close buffer without prompt for save."
      (interactive)
      (let ((currentFile (buffer-file-name)))
        (when (yes-or-no-p (concat "Delete file?: " currentFile))
          (kill-buffer (current-buffer))
          (when currentFile
            (delete-file currentFile)))))
#+END_SRC

Detail at [[file:elisp_delete-current-file.html][Emacs: Delete Current
File]].

** Highlighting Lines
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This example shows you how to make lines containing the words “ERROR:”
or “NOTE:” highlighted, whenever a file ending in “log” is opened.

#+BEGIN_SRC emacs-lisp
    (defun highlite-it ()
      "Highlight certain lines…"
      (interactive)
      (if (equal "log" (file-name-extension (buffer-file-name)))
          (progn
            (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
            (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b))))

    (add-hook 'find-file-hook 'highlite-it)
#+END_SRC

The =add-hook= line will make emacs call “highlite-it” whenever a file
is opened. It works by adding the function “highlite-it” to the list in
the variable find-file-hook.

=find-file= is the function that open files. find-file-hook is a
variable containing list of functions that will run when find-file is
run.

** Insert Vertical Column of Numbers
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This commands insert a vertical column of numbers into a block of text,
like this:

#+BEGIN_SRC emacs-lisp
    1. x
    2. x
    3. x
    4. x
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun insert-column-counter (n)
      "Insert a sequence of numbers vertically.
    For example:

    a▮b
    c d
    e f

    becomes:

    a1 b
    c2 d
    e3 f

    If there are not enough existing lines after the cursor
    when this function is called, it aborts at the last line.

    This command is conveniently used together with `kill-rectangle' and `string-rectangle'.
    Version 2019-01-27"
      (interactive "nEnter the max integer: ")
      (let ((i 1) colpos )
        (setq colpos (- (point) (line-beginning-position)))
        (while (<= i n)
          (insert (number-to-string i))
          (forward-line)
          (beginning-of-line)
          (forward-char colpos)
          (setq i (1+ i)))))
#+END_SRC

Note: Emacs 24 [see [[file:emacs24_features.html][Emacs 24.1 Features
(released 2012-06)]]] has a new command =rectangle-number-lines=.

Thanks to Marcin Milewski for correction on “wrap-markup-region”.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_examples.html]]

\\
\\
| [[../index_u7.html#article_8][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u17.html>>

| [[../article_10/index_u57.html][下一项]] |
[[../index_u7.html#article_9][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_8/index_u11.html][上一项]] |

--------------

* Emacs: Evaluate Elisp Code
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-12-30. Last updated: 2018-12-20.

To evaluate a single lisp expression, move your cursor to the right of
the last closing parenthesis, and Alt+x =eval-last-sexp= 【Ctrl+x
Ctrl+e】.

To evaluate all elisp code in a text selection, Alt+x =eval-region=.

[[file:feed_0/article_9/images/img1_u3.png]]

eval emacs lisp code basics.

Here's ways to eval elisp code, roughly in order of usefulness:

1. =eval-last-sexp= → eval lisp expression to the left of cursor.
2. =eval-region= → eval text selection.
3. =eval-buffer= → eval whole buffer.
4. =load-file= → eval a file. It prompts.
5. =eval-defun= → eval function definition block the cursor is in. (the
   elisp code must be well-indended, otherwise emacs may have problem
   finding function.) [see
   [[file:emacs_narrow-to-defun_eval-defun_bug.html][Emacs:
   narrow-to-defun, eval-defun, bug]]]
6. =eval-expression= → prompts you to type code.

** Emacs Lisp Command Line Interface (REPL)
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Alt+x =ielm= to start emacs interactive emacs lisp shell.

[[file:feed_0/article_9/images/img2.png]]

emacs lisp interactive command line interface (REPL) =ielm=

I recommend working in a buffer instead of REPL.

Working in a buffer (sometimes called notebook inteface) allows you to
use full editing power, and eval any expression, in any order, anytime,
anywhere.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_eval_lisp_code.html]]

\\
\\
| [[../index_u7.html#article_9][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u57.html>>

| [[../article_11/index_u25.html][下一项]] |
[[../index_u7.html#article_10][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_9/index_u17.html][上一项]] |

--------------

* Elisp: Documentation Lookup
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-08-31. Last updated: 2019-02-03.

** Look Up Function Doc String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The following function you will use often when you code elisp.

Alt+x =describe-function= 【Ctrl+h f】, then type the function name.

(if the function name is under cursor, you don't need to type the name,
just hit Enter.)

[[file:feed_0/article_10/images/img1_u1.png]]

emacs =describe-function= output

You can use the asterisk * as a wildcard when looking up function doc.
For example, type Ctrl+h f *file Tab and emacs will list all functions
whose name ends in “file”.

Once the function's doc string page comes up, you can jump to the
function's location in source code by clicking on underlined file name
(or press Tab to move your cursor to the link then press Enter).

** Look Up Variable Doc String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Alt+x =describe-variable= 【Ctrl+h v】 for doc string of variables.

Some words (symbols) in elisp source code are variables, not function.

For example, sentence-end-double-space is a variable.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_doc_lookup.html]]

\\
\\
| [[../index_u7.html#article_10][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u25.html>>

| [[../article_12/index_u8.html][下一项]] |
[[../index_u7.html#article_11][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_10/index_u57.html][上一项]] |

--------------

* Elisp: Search Documentation
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-08-31. Last updated: 2019-02-03.

** Search for Function
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To search command by name, Alt+x =apropos-command= 【Ctrl+h a】.

To search both function and command names, Alt+x =apropos-command= with
a empty argument, like this: Ctrl+u Ctrl+h a.

(In emacs, “commands” are a subset of “functions”. Commands are
functions that can be called interactively (by typing Alt+x).)

To search variable names, Alt+x =apropos-variable=.

To search variable values, Alt+x =apropos-value=.

To search all symbols space (commands, functions, variables, faces),
Alt+x =apropos=.

** Search in Elisp Manual
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs is bundled with emacs lisp manual in “Texinfo” format.

[see [[file:emacs_view_info_page.html][Emacs: View Info Page]]]

Alt+x =elisp-index-search= to find a function's documentation in the
emacs lisp manual.

[[../emacs_manual/elisp/index.html][(info "(elisp) index")]]

Alt+x =emacs-index-search= to find a function's documentation in the
emacs manual.

[[../emacs_manual/emacs/index.html][(info "(emacs) index")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_search_documentation.html]]

\\
\\
| [[../index_u7.html#article_11][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u8.html>>

| [[../article_13/index_u52.html][下一项]] |
[[../index_u7.html#article_12][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_11/index_u25.html][上一项]] |

--------------

* Emacs: How to Edit Lisp Code
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-12-30. Last updated: 2018-09-05.

This page shows you how to edit lisp code with plain emacs efficiently.

** Highlight Brackets: show-paren-mode
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:emacs_highlight_parenthesis.html][Emacs: Highlight Brackets
()[]{}]]

** Insert Brackets by Pair
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:emacs_insert_brackets_by_pair.html][Emacs: Auto Brackets
electric-pair-mode]]

You should ALWAYS insert brackets by pair.

** Delete Brackets by Pair
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:emacs_delete_backward_char_or_bracket_text.html][Emacs: Delete
Brackets ()[]{} by Pair]]

You should ALWAYS delete brackets by pair.

** Move Cursor to Bracket
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:emacs_navigating_keys_for_brackets.html][Emacs: Move Cursor to
Bracket/Quote]]

It's critical to have keys that move cursor to previous opening bracket
and next closing bracket.

** Navigate Lisp Code as Tree
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:emacs_navigate_lisp_code.html][Emacs: Navigate Lisp Code as
Tree]]

You can move cursor to brackets in such way as navigating a tree.

This is less useful than the freely moving to any bracket.

** Select Lisp Expression by Unit
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Alt+x =mark-sexp= 【Ctrl+Alt+Space】 to select a complete parenthesized
expression. Your cursor must be on the left bracket.

To select a complete sexp, type Ctrl+Alt+↑ (=backward-up-list=) then
Ctrl+Alt+Space.

** Xah Emacs Lisp Mode
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You may try my elisp mode. It provides better syntax coloring, and lots
abbrev and function parameter templates.

[[../emacs/xah-elisp-mode.html][Emacs: Xah Emacs Lisp Mode]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_editing_lisp.html]]

\\
\\
| [[../index_u7.html#article_12][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u52.html>>

| [[../article_14/index_u51.html][下一项]] |
[[../index_u7.html#article_13][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_12/index_u8.html][上一项]] |

--------------

* Elisp: Cursor Position Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-23. Last updated: 2020-06-10.

Here's the most useful cursor related functions.

** Get Cursor Position
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=point= → return cursor's current position.

#+BEGIN_SRC emacs-lisp
    ;; returns cursor's current position
    (point)
    ;; beginning of buffer is 1
#+END_SRC

=region-beginning= → return start position of text selection.

=region-end= → return end position of text selection.

#+BEGIN_SRC emacs-lisp
    ;; returns the position of the beginning/end of region
    (region-beginning)
    (region-end)
#+END_SRC

=point-min= → return the start position of visible buffer. (respect
=narrow-to-region=)

=point-max= → return the end position of visible buffer. (respect
=narrow-to-region=)

#+BEGIN_SRC emacs-lisp
    ;; return the beginning position of buffer
    (point-min)

    ;; returns the position for the end of buffer, respect narrow-to-region
    (point-max)
#+END_SRC

[[../emacs_manual/elisp/Positions.html][(info "(elisp) Positions")]]

** Move Cursor
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=goto-char= → move cursor to a given position.

#+BEGIN_SRC emacs-lisp
    ;; move cursor to position 392
    (goto-char 392)
#+END_SRC

=forward-char= → move cursor by given number of characters.

#+BEGIN_SRC emacs-lisp
    ;; move cursor by 9 chars
    (forward-char 9)
    (backward-char 9)
#+END_SRC

=beginning-of-line= → move cursor to beginning of physcal line.

=end-of-line= → move cursor to end of physcal line.

#+BEGIN_SRC emacs-lisp
    ;; move to beginning/end of line
    (beginning-of-line)
    (end-of-line)
#+END_SRC

[see [[file:elisp_all_about_lines.html][Elisp: Functions on Line]]]

** Search Text and Move Cursor
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=search-forward= →
=(search-forward STRING &optional BOUND NOERROR COUNT)= move cursor
forward by searching for given string. Cursor stops at end of matched
string.

Also =search-backward=. Cursor stops at beginning of matched string.

#+BEGIN_SRC emacs-lisp
    ;; move cursor to the location of string "cat"
    ;; returns the new position
    (search-forward "cat")
    (search-backward "cat")
#+END_SRC

=re-search-forward= →
=(re-search-forward REGEXP &optional BOUND NOERROR COUNT)= move cursor
forward by searching for regex pattern. Cursor stops at end of matched
pattern.

Also =re-search-backward=. Cursor stops at beginning of matched string.

#+BEGIN_SRC emacs-lisp
    ;; move cursor to the location matched by regex
    ;; returns the new position
    (re-search-forward myRegex)
    (re-search-backward myRegex)
#+END_SRC

=skip-chars-forward= → =(skip-chars-forward STRING &optional LIM)= move
cursor forward by skip a given set of characters.

Also =skip-chars-backward=.

#+BEGIN_SRC emacs-lisp
    ;; move cursor to the first char that's not a newline or tab
    ;; Returns the distance traveled
    (skip-chars-forward "\n\t")
    (skip-chars-backward "\n\t")
#+END_SRC

[[../emacs_manual/elisp/Motion.html][(info "(elisp) Motion")]]

[see [[file:emacs_regex.html][Emacs: Regex Tutorial]]]

** Save Cursor Position
   :PROPERTIES:
   :CLASS: calibre17
   :END:

When moving cursor, you often want to preserve user's original cursor
position, so the cursor won't end up somewhere unexpected when your
command finished.

=save-excursion= → =(save-excursion &rest BODY)= run BODY, and restore
cursor position and buffer to user's original.

#+BEGIN_SRC emacs-lisp
    ;; preserve {point, mark, current buffer}
    (save-excursion
      ;; lisp code here
    )
#+END_SRC

See also: [[file:elisp_narrow_to_region.html][Elisp: Save
narrow-to-region]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_cursor_position.html]]

\\
\\
| [[../index_u7.html#article_13][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u51.html>>

| [[../article_15/index_u20.html][下一项]] |
[[../index_u7.html#article_14][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_13/index_u52.html][上一项]] |

--------------

* Elisp: Text Editing Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-23. Last updated: 2018-09-10.

Here's the most used functions related to text editing.

** Insert Text
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; insert string at current cursor position
    (insert "sun and moon")
#+END_SRC

[[../emacs_manual/elisp/Text.html][(info "(elisp) Text")]]

** Delete Text
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=delete-char= → delete n characters to the right. Argument can be
negative, to delete to the left.

#+BEGIN_SRC emacs-lisp
    ;; delete 9 chars starting at cursor pos
    (delete-char 9)
#+END_SRC

=delete-region= → delete text btween 2 positions.

#+BEGIN_SRC emacs-lisp
    ;; deleting text btween positions 59 and 896
    (delete-region 59 896)
#+END_SRC

=erase-buffer= → delete all next in buffer, ignores =narrow-to-region=.

#+BEGIN_SRC emacs-lisp
    (erase-buffer)
#+END_SRC

=delete-and-extract-region= → Delete between 2 positions and return the
deleted text.

#+BEGIN_SRC emacs-lisp
    (delete-and-extract-region 3 20)
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text_editing_functions.html]]

\\
\\
| [[../index_u7.html#article_14][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u20.html>>

| [[../article_16/index_u42.html][下一项]] |
[[../index_u7.html#article_15][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_14/index_u51.html][上一项]] |

--------------

* Elisp: String Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-02-21. Last updated: 2019-06-21.

Here are the most basic string functions in elisp.

** Length
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; length
    (length "abc") ; returns 3
#+END_SRC

** Substring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; Extract a substring
    (substring myStr myStartPos myEndPos)
#+END_SRC

** Join Strings
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; join strings
    (concat "some" "thing")
#+END_SRC

** Match String by Regex
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; check if a string matches a pattern
    (string-match myRegex myStr)
#+END_SRC

See also:

- [[file:emacs_regex.html][Emacs: Regex Tutorial]]
- [[file:elisp_regex.html][Elisp: Regex Tutorial]]

** Get Captured String from Regex Match
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In emacs, most functions that take a regex argument, after being called,
will save/modify info in “match data”, such as caputured groups.

Match data can be accessed by the function =match-data=, and other
functions.

The most useful is =match-string=, which returns the captured string.

#+BEGIN_SRC emacs-lisp
    ;; get captured match
    ;; second argument is optional, but required if the last match is done by “string-match”
    (match-string 1 myStr)
#+END_SRC

** Replace in String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; change a given string using regex. Returns changed string.
    (replace-regexp-in-string myRegex myReplacement myStr)
#+END_SRC

** Split String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; split string into parts, returns a list
    (split-string "xy_007_cat" "_")
#+END_SRC

** String To/From Number
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (string-to-number "3") ; change datatype
    (number-to-string 3) ; convert to string
    (format "%d" 3) ; similar to number-to-string but with fine control
#+END_SRC

** Buffer Text to String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs/elisp_buffer_string.html][Elisp: Get Buffer String]]

** String to Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs has only a few functions that takes a string as argument. Any
non-trivial string processing is done with a buffer.

If you got a big string already somehow, you can put into a buffer by
using =with-temp-buffer=, then insert your string, process it, then use
=buffer-string= to get the whole buffer content.

#+BEGIN_SRC emacs-lisp
    ;; process string in a temp buffer

    (with-temp-buffer
      (insert bigString)

      (goto-char (point-min))

      ;; code to manipulate string. eg delete char, etc

      ;; return whole buffer string
      (buffer-string))
#+END_SRC

** Trim String and Others
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs 24.4 added many string functions. [see
[[file:emacs24.4_features.html][Emacs 24.4 Features (released
2014-10)]]]

These are new string functions:

- =string-blank-p=
- =string-empty-p=
- =string-join=
- =string-reverse=
- =string-trim-left=
- =string-trim-right=
- =string-trim=
- =string-remove-prefix=
- =string-remove-suffix=

To use them, you need to first =(require 'subr-x)=.

#+BEGIN_SRC emacs-lisp
    (require 'subr-x)
    (string-trim " abc  ")
#+END_SRC

[[../emacs_manual/elisp/Strings-and-Characters.html][(info "(elisp)
Strings and Characters")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_string_functions.html]]

\\
\\
| [[../index_u7.html#article_15][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u42.html>>

| [[../article_17/index_u40.html][下一项]] |
[[../index_u7.html#article_16][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_15/index_u20.html][上一项]] |

--------------

* Elisp: Buffer Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-23. Last updated: 2019-12-04.

Here's the most useful functions for buffer.

Most buffer functions assume the current buffer if no argument is given.
Some requires a argument. The argument can usually be a buffer's name,
or a buffer object.

** Get Buffer Name
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=buffer-name= → return the name of current buffer.

#+BEGIN_SRC emacs-lisp
    ;; return the name of current buffer
    (buffer-name)
#+END_SRC

=buffer-file-name= → return the full path of the file, or =nil= if not a
file.

#+BEGIN_SRC emacs-lisp
    ;; return the full path of the file
    (buffer-file-name)
#+END_SRC

** Switch Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=with-current-buffer= → temporarily make a buffer current.

Most of the time, you want to use this. Because it takes care of
switching back to the original buffer when the function is done.

#+BEGIN_SRC emacs-lisp
    ;; make myBuf current temporarily
    (with-current-buffer myBuf
      ;; code to edit text here
    )
#+END_SRC

=set-buffer= → switch to a given buffer. (but does not make the buffer
visible.)

#+BEGIN_SRC emacs-lisp
    (save-current-buffer

      ;; switch to myBuf
      (set-buffer myBuf)

      ;; do stuff, such as insert/delete text
      )
#+END_SRC

Note, there is also =switch-to-buffer=, but it's not designed to be used
in lisp code. Use it only if you need the buffer to be visible.

** Create Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=with-temp-buffer=

=(with-temp-buffer &rest BODY)=

Create a temporary buffer, and evaluate BODY there like =progn=.

#+BEGIN_SRC emacs-lisp
    ;; use a temp buffer to manipulate string

    (setq myStr "big text")

    (with-temp-buffer
      (insert myStr)

      ;; manipulate the string here

      ;; print whole buffer content
      (message "%s" (buffer-string)))
#+END_SRC

Note: most of the time, you should just use =with-temp-buffer= to create
new buffers. Because that saves you code of creating buffer, switching
to it, do something, possibly close it, and restore (switch back) to the
buffer that was current.

=generate-new-buffer= → create a new buffer, returns it.

=(generate-new-buffer NAME)=

Create and return a buffer with a name based on NAME. Buffer name is
created by calling =generate-new-buffer-name=.

Typically used like this:

#+BEGIN_SRC emacs-lisp
    ;; name for new buffer. If start with space, undo is disabled
    (setq newBufName " xyz")

    ;; create a new buffer, save it to a var, so later you can switch to it or kill it
    (setq newBuf (generate-new-buffer newBufName))

    ;; make it current (but does not make it visible), so all insert etc operations works on it.
    (set-buffer newBuf)
#+END_SRC

=get-buffer-create=

=(get-buffer-create BUFFER-OR-NAME)=

- Returns the buffer, but doesn't make it current. use =set-buffer= to
  make it current.
- BUFFER-OR-NAME can be a string or buffer.

If BUFFER-OR-NAME is a buffer datatype and the buffer exists, it's just
returned. if not exist, new is created. If BUFFER-OR-NAME is a string
and start with a space, undo is not enabled.

#+BEGIN_SRC emacs-lisp
    ;; create new buffer, without undo info. make sure the string passed is unique and has space in front
    (setq newBuf (get-buffer-create " xyz"))

    ;; make it current (but does not make it visible), so all insert etc operations works on it.
    (set-buffer newBuf)
#+END_SRC

** Kill Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=kill-buffer= → close current buffer or a specified buffer.

=(kill-buffer &optional BUFFER-OR-NAME)=

#+BEGIN_SRC emacs-lisp
    ;; close a given buffer
    (kill-buffer myBuffer)
#+END_SRC

[[../emacs_manual/elisp/Buffers.html][(info "(elisp) Buffers")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_buffer_file_functions.html]]

\\
\\
| [[../index_u7.html#article_16][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u40.html>>

| [[../article_18/index_u2.html][下一项]] |
[[../index_u7.html#article_17][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_16/index_u42.html][上一项]] |

--------------

* Elisp: Read/Write File
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-12-23. Last updated: 2019-01-20.

Here's the most useful functions for working with file.

Emacs work with files via buffer. Typically, read/write file is always
done via a buffer.

[see [[file:elisp_buffer_file_functions.html][Elisp: Buffer Functions]]]

** Open File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=find-file= → open a file.

=(find-file FILENAME &optional WILDCARDS)=

FILENAME can be a full path or just a file name.

#+BEGIN_SRC emacs-lisp
    ;; open a file (returns a buffer)
    (find-file "~/test.txt")
#+END_SRC

** Write File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=write-region= → the most useful function for writing buffer content to
file.

=(write-region START END FILENAME &optional APPEND VISIT LOCKNAME MUSTBENEW)=
START and END are buffer positions, and FILENAME is a file path or name
relative to default-directory.

It'll write the region text to the file.

#+BEGIN_SRC emacs-lisp
    ;; write whole buffer to a file. overwrites the file content
    (write-region (point-min) (point-max) "text.txt" )
#+END_SRC

=save-buffer= → save current buffer.

=(save-buffer &optional ARG)=

#+BEGIN_SRC emacs-lisp
    ;; save current buffer (write to the associated file)
    (save-buffer)
#+END_SRC

=write-file= → write buffer content into a new file, like “save as”, and
open that file.

=(write-file FILENAME &optional CONFIRM)=

#+BEGIN_SRC emacs-lisp
    ;; like “Save As”. Save current buffer, close it, and open the new saved
    (write-file "~/new.txt")
#+END_SRC

** Append File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=append-to-file= → append text between 2 positions in current buffer to
a file.

=(append-to-file START END FILENAME)=

#+BEGIN_SRC emacs-lisp
    ;; append text between positions 100 to 200 to file
    (append-to-file 100 200 "~/test.txt")
#+END_SRC

** Close File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=kill-buffer= → close buffer.

=(kill-buffer &optional BUFFER-OR-NAME)=

#+BEGIN_SRC emacs-lisp
    ;; close a buffer
    (kill-buffer myBuffName)
#+END_SRC

** Create New File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

There are several ways to create a file, depending on what you want to
do exactly.

=find-file= can be used to create a new file.

=(find-file FILENAME &optional WILDCARDS)=

FILENAME can be a full path. if FILENAME does not exist, a new file will
be created, but only when the buffer is saved.

#+BEGIN_SRC emacs-lisp
    ;; open a file (returns a buffer)
    (find-file "~/test.txt")
#+END_SRC

Here's another way to create a file, with more control.

To create a file, just create a buffer, and save it to a file path.

#+BEGIN_SRC emacs-lisp
    ;; name for new buffer. If start with space, undo is disabled
    (setq newBufName " xyz")

    ;; create a new buffer, save it to a var, so later you can switch to it or kill it
    (setq newBuf (generate-new-buffer newBufName))

    ;; make it current (but does not make it visible), so all insert etc operations works on it.
    (set-buffer newBuf)

    ;; like “Save As”. Save current buffer, close it, and open the new saved
    (write-file "~/new.txt")

    ;; close it
    (kill-buffer newBuf)
#+END_SRC

[see [[file:elisp_buffer_file_functions.html][Elisp: Buffer Functions]]]

** with-temp-file
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=with-temp-file= → =(with-temp-file FILE BODY).=
Create a new buffer, make it current, evaluate BODY, and write the
buffer to FILE. The value returned is the value of the last form in
BODY.

#+BEGIN_SRC emacs-lisp
    ;; create a file with text hello

    (with-temp-file "test.txt"
      (insert "hello"))
#+END_SRC

[[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_file_functions.html]]

\\
\\
| [[../index_u7.html#article_17][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u2.html>>

| [[../article_19/index_u24.html][下一项]] |
[[../index_u7.html#article_18][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_17/index_u40.html][上一项]] |

--------------

* Elisp: File and Directory Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-23. Last updated: 2020-02-04.

Here's the most useful functions for file and directory.

** Functions on File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Basic functions on file and directory.

- =file-exists-p=
- =rename-file=
- =copy-file=
- =delete-file=
- =set-file-modes=

#+BEGIN_SRC emacs-lisp
    (rename-file "/home/joe/test1.txt" "/home/joe/test2.txt")

    (copy-file "/home/joe/test1.txt" "/home/joe/test2.txt")

    (delete-file "/home/joe/test2.txt")
#+END_SRC

- [[../emacs_manual/elisp/Changing-Files.html][(info "(elisp) Changing
  Files")]]
- [[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]

** Functions on Directory
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =directory-files=
- =make-directory=
- =delete-directory=
- =copy-directory=

#+BEGIN_SRC emacs-lisp
    (copy-directory "/home/joe/stuff" "/home/joe/stuff-backup")

    ;; delete a whole dir. new in emacs 23
    (delete-directory "/home/joe/stuff" t)
#+END_SRC

[[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]

Example:

#+BEGIN_SRC emacs-lisp
    (defun make-backup ()
      "Make a backup copy of current buffer's file.
    Create a backup of current buffer's file.
    The new file name is the old file name with trailing “~”, in the same dir.
    If such a file already exist, append more “~”.
    If the current buffer is not associated with a file, its a error."
      (interactive)
      (let ((fName (buffer-file-name))
             backupName )
        (if (not fname)
            (error "current buffer is not a file." )
          (progn
            (setq backupName (concat fName "~"))
            (while (file-exists-p backupName)
              (setq backupName (concat backupName "~")))
            (copy-file fName backupName t)
            (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))))
#+END_SRC

** File Path Functions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Basic functions on file path.

- =file-name-directory=
- =file-name-nondirectory=
- =file-name-extension=
- =file-name-sans-extension=
- =file-relative-name=
- =expand-file-name=
- default-directory → variable. The current dir.

#+BEGIN_SRC emacs-lisp
    ;; get the dir path part
    (file-name-directory "/home/joe/xyz.txt") ; "/home/joe/"

    ;; get filename part
    (file-name-nondirectory "/home/joe/xyz.txt") ; "xyz.txt"

    ;; get filename's extension
    (file-name-extension "/home/joe/cat.txt.jpg") ; "jpg"

    ;; get filename without extension
    (file-name-sans-extension "/home/joe/cat.txt.jpg") ; "/home/joe/cat.txt"

    ;; get relative path
    (file-relative-name "/home/joe/b/cat.jpg" "/home/joe/") ; "b/cat.jpg"

    ;; get full path
    (expand-file-name "test.el")
    ;; sample output
    ;; "/home/joe/misc/emacs/test.el"
#+END_SRC

[[../emacs_manual/elisp/File-Names.html][(info "(elisp) File Names")]]

** Traverse Directory
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_traverse_dir.html][Elisp: Walk Directory]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_file_name_dir_name.html]]

\\
\\
| [[../index_u7.html#article_18][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u24.html>>

| [[../article_20/index_u19.html][下一项]] |
[[../index_u7.html#article_19][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_18/index_u2.html][上一项]] |

--------------

* Elisp: How to Write Commands
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-06-30. Last updated: 2019-12-10.

Here's the basics of how to write a emacs command that user can call by
Alt+x name.

** Command Template
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This is the typical template for user-defined emacs commands.

#+BEGIN_SRC emacs-lisp
    (defun my-command ()
      "One sentence summary of what this command do.

    More details here. Be sure to mention the return value if relevant.
    Lines here should not be longer than 70 chars,
    and don't indent them."
      (interactive)
      (let (var1 var2 …)
        (setq var1 …)
        (setq var2 …)
        ;; do something …
        ))
#+END_SRC

In your doc string, if you want clickable URL, or clickable reference to
other commands, etc., See: [[file:inline_doc.html][Elisp: Doc String
Markup]].

be sure to also read [[file:elisp_examples.html][Elisp: Simple Emacs
Lisp Examples]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_idioms.html]]

\\
\\
| [[../index_u7.html#article_19][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u19.html>>

| [[../article_21/index_u29.html][下一项]] |
[[../index_u7.html#article_20][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_19/index_u24.html][上一项]] |

--------------

* Elisp: Region, Active Region
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-06-30. Last updated: 2019-10-19.

Here's how to work with region, active region, and =transient-mark-mode=
in emacs lisp.

** What's Mark?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

*mark* → a position in buffer that user can set, for the purpose of
making a text selection, or jump to a position later.

Alt+x =set-mark-command= 【Ctrl+Space】 to set a mark.

In lisp code, you should call =push-mark= or =set-mark=.

** What's Region?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

*region* → The last marked position to the current cursor position.

Once a user sets a mark in a buffer, a region exists. So, *almost
always, there exists a region in a buffer.*

You can get the positions of region by the functions
{=region-beginning=, =region-end=}.

#+BEGIN_SRC emacs-lisp
    (defun ff ()
      "sample code to show region begin/end positions"
      (interactive)
      (message "begin at %s\nend at %s"
               (region-beginning)
               (region-end)))
#+END_SRC

By convention, commands ending in the word “-region” acts on the region.
Example: =kill-region=, =comment-region=, =fill-region=, =indent-region=
.

** What's Active Region?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Because a region exists once a user sets a mark, and always having a
section of text highlighted to the cursor position is annoying, so
there's a new concept of Active Region.

A Region is Active when the variable mark-active is true. (in elisp,
=nil= and =()= are false, everything else is true. True is represented
by =t= by convention.)

** Highlighting of Region: transient-mark-mode
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs has a minor mode called =transient-mark-mode=. When on, it will
highlight the region when it's active.

variable transient-mark-mode → when true, transient-mark-mode is on.

=transient-mark-mode= is introduced in emacs 19 (released in 1994).

=transient-mark-mode= is on by default since Emacs 23.1 [see
[[../emacs/emacs23_features.html][Emacs 23.1 Features (released
2009-07)]]]

*** When is a Region Active?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Typically, when =set-mark-command= is called, the region becomes active
(highlighted). When a command is called, it typically set the region
status to inactive.

This means, when you set mark using the keyboard or the mouse, text
selection become highlighted, then after you called some command, the
region returns to inactive again (and the highlighting goes away).

*** What's Text Selection?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Emacs's concept of “active region” is practically the same as the modern
term “Text Selection”.

Text Selection = when region is active, and is not empty.

When you want your command to act on a text selection when there is one,
check on =use-region-p=.

#+BEGIN_SRC emacs-lisp
    (defun my-is-region-active ()
      "print whether region is active."
      (interactive)
      (if (use-region-p)
          (message "region active")
        (message "region not active")))
#+END_SRC

The function =use-region-p= basically checks 3 things:

1. =transient-mark-mode= is on.
2. mark-active is true.
3. region isn't empty by checking use-empty-active-region.

*** Create Active Region
    :PROPERTIES:
    :CLASS: calibre14
    :END:

The following example sets a mark, and activates the region.

#+BEGIN_SRC emacs-lisp
    (defun my-select-line ()
      "Select current line."
      (interactive)
      (let (p1 p2)
        (setq p1 (line-beginning-position))
        (setq p2 (line-end-position))
        (goto-char p1)
        (push-mark p2)
        (setq mark-active t)))
#+END_SRC

Note: Emacs commands should not change/modify/activate region, unless
it's the part of the purpose of the command. Because, it's confusing to
user when a command changes text selection or mark.

** Get Active Region or Current {Word, Line, Text Block, File Path,
Buffer, etc}
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Often you want a command that automatically act on a text unit such as
current {word, line, text block, file path, buffer, etc}, when there is
no text selection, and use text selection if there is one.

Here's a example of getting current word, or active region.

#+BEGIN_SRC emacs-lisp
    (defun downcase-word-or-region ()
      "Downcase current word or region."
    (interactive)
    (let (pos1 pos2 bds)
      (if (use-region-p)
         (setq pos1 (region-beginning) pos2 (region-end))
        (progn
          (setq bds (bounds-of-thing-at-point 'symbol))
          (setq pos1 (car bds) pos2 (cdr bds))))

      ;; now, pos1 and pos2 are the starting and ending positions of the
      ;; current word, or current text selection if exist.
      (downcase-region pos1 pos2)
      ))
#+END_SRC

For detail on other text unit, see
[[file:elisp_thing-at-point.html][Elisp: Using thing-at-point]]

** Emacs 23 Changes
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Starting with Emacs 23 (released in 2009), =transient-mark-mode= is on
by default, and many command's behavior changed. If there is a text
selection, the command acts on it, else it acts on the current word,
line, paragraph, buffer (or whatever is its default input).

[see [[file:emacs23_features.html][Emacs 23.1 Features (released
2009-07)]]]

Commands with this new behavior includes: {=fill-paragraph=,
=ispell-word=, =indent-for-tab-command=, =comment-dwim=}. The number of
commands that are sensitive to existence of text selection will probably
increase.

Note that commands ending in “-region” still should act on region as
before, regardless of the region activeness status.

This change is good, because users don't need to think about which of
the region or non-region command to call.

[[../emacs_manual/elisp/The-Mark.html][(info "(elisp) The Mark")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_region.html]]

\\
\\
| [[../index_u7.html#article_20][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u29.html>>

| [[../article_22/index_u47.html][下一项]] |
[[../index_u7.html#article_21][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_20/index_u19.html][上一项]] |

--------------

* Elisp: Get Buffer String
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2017-07-13. Last updated: 2020-08-23.

** Get String from Region
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Grab text of given begin / end positions.

#+BEGIN_SRC emacs-lisp
    ;; return string between position 3 to 99
    (buffer-substring-no-properties 3 99)
#+END_SRC

** Get Text Selection
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (buffer-substring-no-properties (region-beginning) (region-end))
#+END_SRC

[see [[file:emacs_region.html][Elisp: Region, Active Region]]]

** Get Current Word
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; return the identifier under cursor
    ;; this is actually current symbol
    (current-word)
    ;; usually includes underscore _ , may include hyphen -, dollar $, etc, depending on current syntax table

    ;; return the word cursor is on, usually not including underscore _
    (current-word t t)
#+END_SRC

Exactly what characters is considered a part of word depends on current
buffer's syntax table.

For example, if you have =$ite▮m_blue-red=, and cursor is before m,
result is one of the following:

- =$item_blue-red= (include $ _ -)
- =item_blue-red= (include _ -)
- =item_blue= (include _)
- =item= (not include any $ _ -)

If you are beginner in elisp, don't worry about syntax table. The
current major mode usually sets the syntax table correctly for
programing language identifiers.

[see [[file:elisp_syntax_table.html][Elisp: Syntax Table]]]

Here's how to control exactly the sequence of string you want. Suppose,
you want any letter A to Z, a to z, 0 to 9, and including LOW LINE _,
but exclude HYPHEN-MINUS -.

#+BEGIN_SRC emacs-lisp
    (defun my-get-word ()
      "print the word under cursor.
    Word here is any A to Z, a to z, and low line _"
      (interactive)
      (let (
            p1
            p2
            (case-fold-search t))
        (save-excursion
          (skip-chars-backward "_a-z0-9" )
          (setq p1 (point))
          (skip-chars-forward "_a-z0-9" )
          (setq p2 (point))
          (message "%s" (buffer-substring-no-properties p1 p2)))))
#+END_SRC

** Get Current Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; return current line as string
    (buffer-substring-no-properties (line-beginning-position) (line-end-position) )
#+END_SRC

** Get Thing at Point
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=thing-at-point= is a way to get the “thing” under cursor.

The thing can be {word, symbol, line, sentence, URL, file name, ...}.

#+BEGIN_SRC emacs-lisp
    ;; grab a “thing” at point. The “thing” is text unit. It can be 'word 'symbol 'list 'sexp 'defun 'filename 'url 'email 'sentence 'whitespace 'line 'number 'page

    ;; grab the current filename
    (setq str (thing-at-point 'filename))
#+END_SRC

Sometimes, you need to not just grab current word, but do other things
such as delete the word. You need to know the beginning and ending
positions of the region you are interested.

Use =bounds-of-thing-at-point=

[see [[file:elisp_thing-at-point.html][Elisp: Using thing-at-point]]]

** Get Text Between Brackets
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Grab the current text between delimiters such as between angle brackets
=<…>=, parens =(…)=, double quotes ="…"=, etc.

The trick is to use =skip-chars-backward= and =skip-chars-forward=. In
the following example, the p1 is set to the position of the double quote
to the left of cursor (the first char to the right of the quote).
Similarly, for p2 to the right of cursor.

#+BEGIN_SRC emacs-lisp
    (defun my-select-inside-quotes ()
      "Select text between double straight quotes
    on each side of cursor."
      (interactive)
      (let (p1 p2)
        (skip-chars-backward "^\"")
        (setq p1 (point))
        (skip-chars-forward "^\"")
        (setq p2 (point))

        (goto-char p1)
        (push-mark p2)
        (setq mark-active t)))
#+END_SRC

More examples: [[file:modernization_mark-word.html][Emacs: Select Line,
between Quotes, Extend Selection]]

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Buffer-Contents.html][(info "(elisp) Buffer
Contents")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_buffer_string.html]]

\\
\\
| [[../index_u7.html#article_21][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u47.html>>

| [[../article_23/index_u38.html][下一项]] |
[[../index_u7.html#article_22][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_21/index_u29.html][上一项]] |

--------------

* Elisp: Functions on Line
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-06-08. Last updated: 2019-10-19.

In emacs lisp, there are lots of ways to move by line or grab lines.
Here are some functions or variables that are related to lines:

- =line-beginning-position=, =line-end-position=
- =move-beginning-of-line=, =move-end-of-line=
- =next-line=, =previous-line=
- =forward-line=
- =search-forward=. For example: =(search-forward "\n")=,
  =(search-backward "\n")=
- =line-move-visual=
- line-move-visual
- =thing-at-point=. For example: =(thing-at-point 'line)=

Do you know the differences? Also, there are issues such as:

- Is a line defined by newline char or screen line (wrapped at window
  edge)?
- When grabbing a line, does it includes the newline char?
- What happens if the line is at end of buffer and there's no newline
  char? Do you get a error?
- Which is faster?

Following are best ways to do them.

** Get Position of Beginning/End of Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; return line beginning's position
    (line-beginning-position)

    ;; return line end's position
    (line-end-position)
#+END_SRC

These are written in C.

** Move Cursor to Beginning/End of Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; move cursor to beginning/end of current line
    (beginning-of-line)
    ;; better than (goto-char (line-beginning-position))

    (end-of-line)
    ;; better than (goto-char (line-end-position))
#+END_SRC

These are written in C. So, they are much faster than other functions
that are written in elisp.

They don't have problems when the line is at the beginning/end of
buffer.

They work by newline char. That is, not soft-wrapped line.

Do not use =(search-forward "\n")= for moving cursor to end of line.
Because you'll have special cases if the line is at the end of buffer
and doesn't have a newline char. It is also slower.

Do not use =move-beginning-of-line= or =move-end-of-line=. Because these
are designed for interactive use.

** Move Cursor to Previous/Next Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; move cursor to previous/next line. Cursor will be at beginning of line
    (forward-line -1) ; prev line
    (forward-line 1)  ; next line
#+END_SRC

It is written in C. It moves the cursor to the beginning of
previous/next line.

Do not use =next-line= or =previous-line=. Because these are for
interactive use. Their behavior changes depending on the variable
line-move-visual.

** Get Current Line as String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To grab current line, use:

#+BEGIN_SRC emacs-lisp
    (setq myLine
          (buffer-substring-no-properties
           (line-beginning-position)
           (line-end-position)
           ))
#+END_SRC

Do not use =(thing-at-point 'line)=. Normally, =thing-at-point= will
include the newline char, but if the line is at the end of buffer, then
it won't. So, if you use it, you have to do extra work to detect special
cases. Also, =thing-at-point= is complex elisp code and is slower.

** Get All Lines in a File into a List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_read_file_content.html][Elisp: Read File Content as String
or List of Lines]]

See also: [[file:elisp_process_lines.html][Process a File line-by-line
in Emacs Lisp]].

** Screen Lines
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you want to move cursor across lines as defined by the screen
(wrapped at edge of screen), you can use these.

- =next-line=
- =previous-line=
- =line-move-visual=
- line-move-visual

line-move-visual is variable that controls whether =next-line= and
=previous-line= move by newline char or screen.

** What Character Does Emacs Use for Newline
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In emacs buffer, newline char is ="\n"=, in any operating system (Mac,
Linux, Microsoft Windows ). So, you can use =(search-forward "\n")=.
However, if you are on the last line, there may not be a ending ="\n"=.

~2010 Thanks to Uday S Reddy [[[http://www.cs.bham.ac.uk/~udr/]]] and
Alan Mackenzie [[[http://www.emacswiki.org/emacs/AlanMackenzie]]] for
tips.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_all_about_lines.html]]

\\
\\
| [[../index_u7.html#article_22][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u38.html>>

| [[../article_24/index_u60.html][下一项]] |
[[../index_u7.html#article_23][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_22/index_u47.html][上一项]] |

--------------

* Elisp: Cut Copy Paste to/from kill-ring
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2014-05-23. Last updated: 2019-10-19.

** Copy Region to Kill Ring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; push text between buffer positions to kill-ring
    (copy-region-as-kill 1 100)
#+END_SRC

** Kill Region to Kill Ring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; delete text between buffer positions and push to kill-ring
    (kill-region 247 528)
#+END_SRC

Note: User's kill-ring content should not change unexpectedly. Emacs
lisp function should not use the kill-ring as temp storage of text. If
your command is specifically designed to put text to the kill-ring so
that user can paste it later, then good. Else, just save text to a
variable for your elisp program's use. e.g.
=(setq x (buffer-substring-no-properties pos1 pos2))=

** String to Kill Ring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you already have a string, use =kill-new=

#+BEGIN_SRC emacs-lisp
    ;; push a string into kill-ring
    (kill-new "cute cat")
#+END_SRC

** Append String to Kill Ring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; append string to the latest in kill-ring
    (kill-append "cute cat" nil)
    ;; if second arg is t, do prepend
#+END_SRC

** Paste from Kill Ring
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; paste from kill-ring
    (yank)
#+END_SRC

** Mark a Region
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To mark a region, do =(push-mark positon)=. The current cursor positon
to positon will become the new region.

To make the region active, use =(setq mark-active t)=.

[see [[file:emacs_region.html][Elisp: Region, Active Region]]]

#+BEGIN_SRC emacs-lisp
    (defun my-select-text-in-quote ()
      "Select text between the nearest left and right quotes."
      (interactive)
      (let ($pos
            ($skipChars "^\""))
        (skip-chars-backward $skipChars)
        (setq $pos (point))
        (skip-chars-forward $skipChars)
        (push-mark $pos)
        (setq mark-active t)))
#+END_SRC

[[../emacs_manual/elisp/The-Kill-Ring.html][(info "(elisp) The Kill
Ring")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_cut_copy_yank_kill-ring.html]]

\\
\\
| [[../index_u7.html#article_23][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u60.html>>

| [[../article_25/index_u55.html][下一项]] |
[[../index_u7.html#article_24][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_23/index_u38.html][上一项]] |

--------------

* Elisp: Get User Input
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-06-30. Last updated: 2018-02-22.

** Get User Input with Name Completion and Input History
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The most useful functions for getting user input with completion or
command history support are:

- =read-string=
- =read-file-name=
- =read-directory-name=
- =read-regexp=

Command history means, user can press ↑ key to enter previous input.
(e.g. Alt+x =shell-command=) Also, some commands provide name completion
(e.g. Alt+x =dired=).

** Prompt for File Name
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=read-file-name= example:

#+BEGIN_SRC emacs-lisp
    (defun ff ()
      "Prompt user to enter a file name, with completion and history support."
      (interactive)
      (message "String is %s" (read-file-name "Enter file name:")))
#+END_SRC

Try it. You'll have file name completion feature. Pressing ↑ will show
previous file name you used.

** Prompt for Directory
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=read-directory-name= example:

#+BEGIN_SRC emacs-lisp
    (defun ff ()
      "Prompt user to enter a dir path, with path completion and input history support."
      (interactive)
      (message "Path is %s" (read-directory-name "Directory:")))
#+END_SRC

** Prompt for String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=read-string= example:

#+BEGIN_SRC emacs-lisp
    (defun ff ()
      "Prompt user to enter a string, with input history support."
      (interactive)
      (message "String is %s" (read-string "Enter your name:")))
#+END_SRC

** Prompt for Regex String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=read-regexp= example:

#+BEGIN_SRC emacs-lisp
    (defun ff ()
      "Prompt user to enter a elisp regex, with input history support."
      (interactive)
      (message "Regex is %s" (read-regexp "Type a regex:")))
#+END_SRC

The most general command is =read-from-minibuffer=. All the above are
implemented on top of it.

[[../emacs_manual/elisp/Minibuffers.html][(info "(elisp) Minibuffers")]]

** Select from a List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The best way to ask user to select from a list, is by
=ido-completing-read=.

#+BEGIN_SRC emacs-lisp
    (require 'ido)

    (defun my-pick-one ()
      "Prompt user to pick a choice from a list."
      (interactive)
      (let ((choices '("cat" "dog" "dragon" "tiger")))
        (message "%s" (ido-completing-read "Open bookmark:" choices ))))
#+END_SRC

** Query User for Yes/No
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=y-or-n-p= → Ask user a “y or n” question. Return t if answer is “y” and
nil if it is “n”.

#+BEGIN_SRC emacs-lisp
    (if (y-or-n-p "Do it?")
        (progn
          ;; code to do something here
        )
      (progn
        ;; code if user answered no.
      )
    )
#+END_SRC

[[../emacs_manual/elisp/Yes_002dor_002dNo-Queries.html][(info "(elisp)
Yes-or-No Queries")]]

** Get User Input as Function's Arguments
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_interactive_form.html][Elisp: Interactive Form]]

** Get User Input from universal-argument
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_universal_argument.html][Elisp: Get universal-argument]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_idioms_prompting_input.html]]

\\
\\
| [[../index_u7.html#article_24][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u55.html>>

| [[../article_26/index_u23.html][下一项]] |
[[../index_u7.html#article_25][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_24/index_u60.html][上一项]] |

--------------

* Elisp: Interactive Form
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-23. Last updated: 2019-10-19.

A common way of getting user input is by the “interactive” form.

=(interactive "code_letter_and_promp_string")=

The =interactive= expression must come right after the doc string.

Example:

#+BEGIN_SRC emacs-lisp
    (defun ask-name (x)
      "Ask name."
      (interactive "sEnter your name: ")
      (message "Name: %s" x))
#+END_SRC

** Purpose of Interactive Form
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The =interactive= has 2 purposes.

1. Make elisp function callable as interactive command.
2. A mechanism for passing arguments to function when called
   interactively.

A function with the =interactive= clause is called a *command*, and can
be called by =execute-extended-command= (that is, pressing Alt+x).

** Get String as Argument
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(interactive "sprompt_string")= → prompt user, pass as first argument
of function as string.

#+BEGIN_SRC emacs-lisp
    (defun ask-name (x)
      "Ask name."
      (interactive "sEnter your name: ")
      (message "Name: %s" x))
#+END_SRC

** Get Number as Argument
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(interactive "nprompt_string")= → prompt user, pass answer as first
argument of function as string.

#+BEGIN_SRC emacs-lisp
    (defun ask-age (x)
      "Ask age."
      (interactive "nEnter your age: ")
      (message "Name: %d" x))
#+END_SRC

** Get Region Begin End Positions as Argument
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(interactive "r")= → pass answer region begin and end as arguments to
function.

#+BEGIN_SRC emacs-lisp
    (defun print-region-boundary (x y)
      "Prints region start and end positions"
      (interactive "r")
      (message "Region begin at: %d, end at: %d" x y))
#+END_SRC

** Passing Interactive a List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(interactive list_expression)= → pass the list that's the value of
list_expression to function as arguments.

This is the most general way of using =interactive=. The list_expression
can be any lisp code, it just need to return a list. The lisp code can
contain prompts, such as =read-string=, =read-file-name=, etc. [see
[[file:elisp_idioms_prompting_input.html][Elisp: Get User Input]]]

#+BEGIN_SRC emacs-lisp
    (defun do-something (x y)
      "Ask name and age"
      (interactive
       ;; complex code here that returns a list
       (list "Mary" 22))
      (message "Name is: %s, Age is: %d" x y))
#+END_SRC

** Ways to Call Interactive
   :PROPERTIES:
   :CLASS: calibre17
   :END:

There are 3 forms of =interactive=:

1. =(interactive)= → No argument. This simply makes the function as
   command, and does not pass any argument to the function.
2. =(interactive string)= → The first character (or first few character
   in same cases) in string tells emacs how to interpret the user input
   (such as string, number, file name, directory name, regex, lisp
   expression, key stroke, etc) and what datatype (string, number, etc)
   it should be converted to as your function's argument. The rest of
   string are use as prompt. However, if string contains multiple lines,
   each line's beginning are taken as what-to-do code.
3. =(interactive (list …))= → This is the most general way to fill
   function arguments from user input. This list elements will be passed
   as arguments to your function. Usually, it's like this
   =(interactive some_lisp_code)= where some_lisp_code evaluates to a
   list.

There are about 30 string codes for =interactive string= , the most
useful are shown on this page.

For complete list of interactive code, see
[[../emacs_manual/elisp/Defining-Commands.html][(info "(elisp) Defining
Commands")]]

If your function takes multiple inputs, you can promp user multiple
times, using a single =interactive= call, with mulitple lines, each line
begin with a prompt code.

#+BEGIN_SRC emacs-lisp
    (defun ask-name-and-age (x y)
      "Ask name and age"
      (interactive "sEnter you name:
    nEnter your age: ")
      (message "Name is: %s, Age is: %d" x y))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_interactive_form.html]]

\\
\\
| [[../index_u7.html#article_25][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u23.html>>

| [[../article_27/index_u31.html][下一项]] |
[[../index_u7.html#article_26][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_25/index_u55.html][上一项]] |

--------------

* Elisp: Get universal-argument
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-05-27. Last updated: 2020-08-30.

This page shows you how to make your emacs command accept
=universal-argument= 【Ctrl+u】 given by user.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You have written a emacs command. You want the command's behavior to be
different if user presses Ctrl+u before calling your command.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Emacs has a mechanism for a command to have variant behavior if user
calls =universal-argument= 【Ctrl+u】.

The purpose of =universal-argument= is:

- A convenient way to let user pass numerical argument to a command.
  (What the command do with number argument depends on the command.)
- To simply have a alternate behavior of a command. (e.g. copy file name
  normally, or copy full path.)

For example:

- in dired, typing w will copy the file name
  (=dired-copy-filename-as-kill=), but if you type Ctrl+u 0 w, the
  copied name will be file full path.
- Type Ctrl+u 5 e and it'll insert e 5 times.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To make your command aware of universal argument, there are 3 simple
ways:

- The global variable current-prefix-arg holds the value of universal
  argument.
- Add =(interactive "P")= to your function. It passes the value of
  current-prefix-arg as your function's first parameter.
- Add =(interactive "p")= to your function. It passes converted
  numerical value of current-prefix-arg to your function's first
  argument.

[see [[file:elisp_interactive_form.html][Elisp: Interactive Form]]]

Example:

#+BEGIN_SRC emacs-lisp
    (defun f (x)
      "print argument received"
      (interactive "P")
      (message "%s" x)
      ;; value of x is from universal argument, or nil if universal-argument isn't called
    )
#+END_SRC

*** Possible Values of Universal Argument
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's the possible values of current-prefix-arg.

| Key Input                  | Value of current-prefix-arg   | Numerical Value   |
|----------------------------+-------------------------------+-------------------|
| No universal arg called.   | =nil=                         | 1                 |
| Ctrl+u -                   | Symbol =-=                    | -1                |
| Ctrl+u - 2                 | Number =-2=                   | -2                |
| Ctrl+u 1                   | Number =1=                    | 1                 |
| Ctrl+u 4                   | Number =4=                    | 4                 |
| Ctrl+u                     | List ='(4)=                   | 4                 |
| Ctrl+u Ctrl+u              | List ='(16)=                  | 16                |

#+BEGIN_SRC emacs-lisp
    (defun g ()
      "print `current-prefix-arg'"
      (interactive )
      (message "%s" current-prefix-arg))

    ;; try
    ;; M-x g
    ;; C-u M-x g
    ;; C-u C-u M-x g
    ;; C-u 1 M-x g
    ;; C-u 2 M-x g
#+END_SRC

** Checking current-prefix-arg
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a example that expect all possible use of =universal-argument=
values, by manually checking the value of current-prefix-arg, and feed
it to the function's arguments.

#+BEGIN_SRC emacs-lisp
    (defun utest (arg1 &optional arg2 arg3)
      "Sample command to test `universal-argument'."
      (interactive
       (cond
        ((equal current-prefix-arg nil) ; no C-u
         (list 1 nil nil))
        ((equal current-prefix-arg '(4)) ; C-u
         (list 1 2 nil))
        ((equal current-prefix-arg 2) ; C-u 2
         (list 1 2 3))
        ;; more special case here

        (t ; all other cases, prompt
         (list
          (read-string "arg1:" )
          (read-string "arg2:" )
          (read-string "arg3:" )))))

      ;; now, all the parameters of your function is filled.
      ;; code body here

      (message "args are: %s %s %s" arg1 arg2 arg3)
      ;;
      )
#+END_SRC

The =(interactive …)= is used to fill out the parameters.

[see [[file:elisp_interactive_form.html][Elisp: Interactive Form]]]

The =read-string= is to prompt user for input.

[see [[file:elisp_idioms_prompting_input.html][Elisp: Get User Input]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_universal_argument.html]]

\\
\\
| [[../index_u7.html#article_26][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u31.html>>

| [[../article_28/index_u58.html][下一项]] |
[[../index_u7.html#article_27][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_26/index_u23.html][上一项]] |

--------------

* Elisp: Find Replace String in Buffer
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-06-30. Last updated: 2016-09-27.

This page shows you how to do Find Replace in emacs lisp.

** Find Replace Text in Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; idiom for string replacement in current buffer

    (let ((case-fold-search t)) ; or nil

      (goto-char (point-min))
      (while (search-forward "myStr1" nil t)
        (replace-match "myReplaceStr1"))

      (goto-char (point-min))
      (while (search-forward "myStr2" nil t)
        (replace-match "myReplaceStr2"))

      ;; repeat for other string pairs
      )

    ;; if you need regexp, use search-forward-regexp
#+END_SRC

*** Letter Case Sensitivity in Search
    :PROPERTIES:
    :CLASS: calibre14
    :END:

To control the letter case of search, locally set case-fold-search to
=t= or =nil=. By default, it's t.

#+BEGIN_SRC emacs-lisp
    (let (
          (case-fold-search nil) ; case sensitive search
          )
      ;; find replace code here
      )
#+END_SRC

*** Letter Case Sensitivity in Replacement
    :PROPERTIES:
    :CLASS: calibre14
    :END:

To control letter case of the replacement, use the optional arguments in
=replace-match= function.

=(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)=

Use =t= for FIXEDCASE.

*** Match Data
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Whenever you use regex in emacs lisp, the captured text is stored in
=match-string=.

**** Get Match String
     :PROPERTIES:
     :CLASS: calibre34
     :END:

=match-string=

#+BEGIN_SRC emacs-lisp
    ;; the second captured string
    (match-string 2)
#+END_SRC

**** Get Boundary Positions of Match String
     :PROPERTIES:
     :CLASS: calibre34
     :END:

=match-beginning= and =match-end= returns the beginning and end
positions of the matched string.

#+BEGIN_SRC emacs-lisp
    ;; get the positions of the 2nd captured string
    (setq pos1 (match-beginning 2)
          pos2 (match-end 2))
#+END_SRC

Complete match data can be accessed by the function =match-data=.

** Find Replace in a Region Boundary
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you need to do find replace on a region only, wrap the code with
=save-restriction= and =narrow-to-region=. Example:

#+BEGIN_SRC emacs-lisp
    ;; idiom for string replacement within a region
    (save-restriction
      (narrow-to-region pos1 pos2)

      (goto-char (point-min))
      (while (search-forward "myStr1" nil t)
        (replace-match "myReplaceStr1"))

      ;; repeat for other string pairs
      )
#+END_SRC

If you need to find replace multiple pairs frequently, see:
[[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

*** WARNING: Boundary Change After Find Replace
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Whenever you work in a region, remember that the boundaries of the text
that you are interested is changed when you add or remove text in that
region. For example, suppose {p1, p2} is the boundary of some text you
are interested. After doing some change there, suppose you want to do
some more change. Don't just call =(something-region p1 p2)= again,
because p2 is no longer the correct boundary.

Use =save-restriction= and =narrow-to-region=, like this:

#+BEGIN_SRC emacs-lisp
    (save-restriction
      (narrow-to-region pos1 pos2)
      (something1-region (point-min) (point-max))
      (something2-region (point-min) (point-max))
      …
    )
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_find_replace_text.html]]

\\
\\
| [[../index_u7.html#article_27][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u58.html>>

| [[../article_29/index_u44.html][下一项]] |
[[../index_u7.html#article_28][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_27/index_u31.html][上一项]] |

--------------

* Elisp: Using thing-at-point
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-16. Last updated: 2019-10-19.

This page shows you how to use =thing-at-point= function to get text
unit such as current {word, line, text block, file path, buffer, etc}
from buffer into a string.

** thing-at-point
   :PROPERTIES:
   :CLASS: calibre17
   :END:

When writing interactive commands, one of the most useful function is
=thing-at-point=.

=thing-at-point= lets you get the current word under cursor into a
string. (or, current line, current sentence, paragraph, file, URL,
defun, etc.)

Here's a example.

#+BEGIN_SRC emacs-lisp
    (defun xx ()
      "print current word."
      (interactive)
      (message "%s" (thing-at-point 'word)))
#+END_SRC

Evaluate the code, then try it. [see
[[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

** Finding the Positions of a Thing's Boundary
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Sometimes you also need to know a thing's boundary, because you may need
to delete it (using =(delete-region position1 position2)=).

=bounds-of-thing-at-point= returns the boundary positions of the text
unit under cursor.

#+BEGIN_SRC emacs-lisp
    (defun my-get-boundary-and-thing ()
      "example of using `bounds-of-thing-at-point'"
      (interactive)
      (let (bounds pos1 pos2 mything)
        (setq bounds (bounds-of-thing-at-point 'symbol))
        (setq pos1 (car bounds))
        (setq pos2 (cdr bounds))
        (setq mything (buffer-substring-no-properties pos1 pos2))

        (message
         "thing begin at [%s], end at [%s], thing is [%s]"
         pos1 pos2 mything)))
#+END_SRC

** thing-at-point and Syntax Table
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The exact meaning of “thing”, depends on current buffer's syntax table.

[see [[file:elisp_syntax_table.html][Elisp: Syntax Table]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_thing-at-point.html]]

\\
\\
| [[../index_u7.html#article_28][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u44.html>>

| [[../article_30/index_u6.html][下一项]] |
[[../index_u7.html#article_29][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_28/index_u58.html][上一项]] |

--------------

* Elisp: Get Text Block
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2020-06-10.

Often, you want a interactive command to work on a text block, without
user having to manually select it. (text block is group of lines
separated by empty lines, similar to a paragraph.)

Commands working on text block is especially useful in programing
language source code.

Here's command that gets the beginning and ending positions of text
block the cursor is in.

#+BEGIN_SRC emacs-lisp
    (defun get-text-block-positions ()
      "Return a vector [begin end] of text block,
     Return a vector [begin end] that's the begin and end positions of text block the cursor is in.
    Text block is group of lines separated by blank lines.

    URL `http://ergoemacs.org/emacs/elisp_get_text_block.html'
    Version 2020-06-10"
      (interactive)
      (let ($p1 $p2)
        (save-excursion
          (if (re-search-backward "\n[ \t]*\n" nil "move")
              (progn (re-search-forward "\n[ \t]*\n")
                     (setq $p1 (point)))
            (setq $p1 (point)))
          (if (re-search-forward "\n[ \t]*\n" nil "move")
              (progn (re-search-backward "\n[ \t]*\n")
                     (setq $p2 (point)))
            (setq $p2 (point))))
        (vector $p1 $p2)
        (message "%s" (vector $p1 $p2))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_get_text_block.html]]

\\
\\
| [[../index_u7.html#article_29][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u6.html>>

| [[../article_31/index_u14.html][下一项]] |
[[../index_u7.html#article_30][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_29/index_u44.html][上一项]] |

--------------

* Elisp: Save narrow-to-region
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2020-06-10.

Emacs has a =narrow-to-region= command. It lets users make the buffor
show only the selected region, as if the entire buffer is just that
text. This is convenient when you want to do some editing only in this
region. Alt+x =widen= will make buffer show whole buffer again.

The =narrow-to-region= is also super useful in elisp code. However, when
you command is done, you should return to the narrow region state of the
user before the command was called. Emacs lisp provides
=save-restriction= for this purpose.

=save-restriction= → =(save-restriction &rest BODY)= Execute BODY,
saving and restoring user's =narrow-to-region= .

In elisp code, when you call =narrow-to-region=, you almost always want
to wrap it with =save-restriction=, like this:

#+BEGIN_SRC emacs-lisp
    ;; preserve user's narrow-to-region
    ;; useful when you want to narrow-to-region in your code to work in just that region
    (save-restriction
      (narrow-to-region pos1 pos2)
      ;; lisp code here
    )
#+END_SRC

[[../emacs_manual/elisp/Positions.html][(info "(elisp) Positions")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_narrow_to_region.html]]

\\
\\
| [[../index_u7.html#article_30][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u14.html>>

| [[../article_32/index_u53.html][下一项]] |
[[../index_u7.html#article_31][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_30/index_u6.html][上一项]] |

--------------

* Elisp: Run Elisp Script in Shell
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-06-30. Last updated: 2019-12-10.

You can run emacs lisp script in shell (terminal), using the =--script=
option. For example:

#+BEGIN_SRC emacs-lisp
    emacs --script process_log.el
#+END_SRC

Here's a table of most useful options for running emacs lisp as a
script.

- =--no-init-file= or =-q= :: Do not load your init files {=~/.emacs=,
  =~/.emacs.el=, =~/.emacs.d/init.el=} nor site-wide =default.el=.
- =--no-site-file= :: Do not load the site-wide =site-start.el=.
- =--batch= :: Do not launch emacs as a editor. Use it together with
  =--load= to specify a lisp file. This implies =--no-init-file= but not
  =--no-site-file=.
- =--load="path"= or =-l path= :: Execute the elisp file at path.
- =--script path= :: Run emacs like =--batch= with =--load= set to path.

For a complete list, see:

- [[../emacs_manual/emacs/Option-Index.html][(info "(emacs) Option
  Index")]]
- [[../emacs_manual/emacs/Initial-Options.html][(info "(emacs) Initial
  Options")]]
- [[../emacs_manual/elisp/Startup-Summary.html][(info "(elisp) Startup
  Summary")]]

** What's site-start.el?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The =site-start.el= is a init file for site-wide running of emacs.

It pretty much means a init file for all users of this emacs
installation. It may be added by a sys admin, or it may be part of a
particular emacs distribution (For example, Carbon Emacs, Aquamacs
Emacs, etc.).

You can usually find this file in the directory where emacs is
installed, if it exists. Typically in a directory named “site-lisp”. For
example, =~/apps/emacs-25.1/site-lisp/=. But the file can be anywhere in
emacs load-path.

[[../emacs_manual/elisp/Init-File.html][(info "(elisp) Init File")]]

[[../emacs_manual/elisp/Library-Search.html][(info "(elisp) Library
Search")]]

** Prepare Your Emacs Lisp Script to Run in Batch Mode
   :PROPERTIES:
   :CLASS: calibre17
   :END:

When you write a elisp script to run in batch, make sure your elisp file
is:

1. self-contained; Doesn't depend on anything from your emacs init file.
2. Explicitly load all libraries it needs (using =require= or =load=).
3. Has necessary load path set in the script (For example,
   =(add-to-list 'load-path lib_path)=) if it needs libs that's not part
   of standard GNU emacs install, just like you would with a Python or
   Ruby script.

** How to start emacs on a Mac from command line?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you are on a Mac, call it from the command line like this:

#+BEGIN_SRC emacs-lisp
    /Applications/Emacs.app/Contents/MacOS/Emacs --script=name.el
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_running_script_in_batch_mode.html]]

\\
\\
| [[../index_u7.html#article_31][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u53.html>>

| [[../article_33/index_u50.html][下一项]] |
[[../index_u7.html#article_32][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_31/index_u14.html][上一项]] |

--------------

* Elisp: Get Command Line Arguments
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-22. Last updated: 2018-09-04.

when you run emacs lisp script from terminal

=emacs --script do.el arg1 arg2=

[see [[../emacs/elisp_running_script_in_batch_mode.html][Elisp: Run
Elisp Script in Shell]]]

You can get the arguments in elisp from the variable argv

argv → a built-in variable. Its value is a list. Each element is a item
from the command line.

#+BEGIN_SRC emacs-lisp
    (message "argv 0: %s" (elt argv 0)) ; %s is for string
    (message "argv 1: %s" (elt argv 1))
    (message "argv 2: %s" (elt argv 2))
    (message "argv 3: %s" (elt argv 3))
#+END_SRC

Save and name the above script as =test.el= and run it like this:

#+BEGIN_SRC emacs-lisp
    emacs --script test.el uni 2 -tri
#+END_SRC

Here's the output:

#+BEGIN_SRC emacs-lisp
    $ emacs --script test.el uni 2 -tri
    argv 0: "uni"
    argv 1: "2"
    argv 2: "-tri"
    argv 3: nil
#+END_SRC

[[../emacs_manual/elisp/Command_002dLine-Arguments.html][(info "(elisp)
Command-Line Arguments")]]

2011-07-22 Thanks to Piotr Chamera 〔piotr_cham...@poczta.onet.pl〕,
Swami Tota Ram Shankar 〔tota_...@india.com〕.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_command_line_argv.html]]

\\
\\
| [[../index_u7.html#article_32][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u50.html>>

| [[../article_34/index_u21.html][下一项]] |
[[../index_u7.html#article_33][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_32/index_u53.html][上一项]] |

--------------

* Elisp: Read File
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-04. Last updated: 2018-09-06.

If you don't care about speed, use

- =find-file=
- =find-file-read-only=

to open a file into buffer. Then you can process it. and call
=save-buffer= to save, like you would with using emacs.

#+BEGIN_SRC emacs-lisp
    (find-file "~/test.html")
#+END_SRC

If the file doesn't exit, it'll be created when you save it.

Note that =find-file= has lots side-effects. It will call all functions
in find-file-hook. Many packages and major modes add stuff to that hook.
It'll load a major mode (which does syntax coloring, usually very slow),
it'll record undo for any modification in the buffer.

[see [[../emacs/elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp
Text Processing: find-file vs with-temp-buffer]]]

** Open File for Reading in Batch Script
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To process thousands of files, read only, use =with-temp-buffer=.

#+BEGIN_SRC emacs-lisp
    (defun my-process-file (fPath)
      "Process the file at path FPATH …"
      (with-temp-buffer
        (insert-file-contents fPath)
        ;; process it …
        ))
#+END_SRC

[[../emacs_manual/elisp/Current-Buffer.html][(info "(elisp) Current
Buffer")]]

** Read File as String or List of Lines
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_read_file_content.html][Elisp: Read File Content as String
or List of Lines]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_read_file.html]]

\\
\\
| [[../index_u7.html#article_33][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u21.html>>

| [[../article_35/index_u13.html][下一项]] |
[[../index_u7.html#article_34][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_33/index_u50.html][上一项]] |

--------------

* Elisp: Read File Content as String or List of Lines
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-12-05. Last updated: 2014-09-30.

** Read File Content into a String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun get-string-from-file (filePath)
      "Return filePath's file content."
      (with-temp-buffer
        (insert-file-contents filePath)
        (buffer-string)))
    ;; thanks to “Pascal J Bourguignon” and “TheFlyingDutchman 〔zzbba…@aol.com〕”. 2010-09-02
#+END_SRC

** Read File Content as List of Lines
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun read-lines (filePath)
      "Return a list of lines of a file at filePath."
      (with-temp-buffer
        (insert-file-contents filePath)
        (split-string (buffer-string) "\n" t)))
#+END_SRC

Once you have a list, you can use =mapcar= to process each element in
the list. If you don't need the resulting list, use =mapc=.

Note: in elisp, it's more efficient to process text in a buffer than
doing complicated string manipulation with string data type. But, if
your lines are all short and you don't need to know the text that comes
before or after current line, then, list of lines can be easier to work
with.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_read_file_content.html]]

\\
\\
| [[../index_u7.html#article_34][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u13.html>>

| [[../article_36/index_u26.html][下一项]] |
[[../index_u7.html#article_35][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_34/index_u21.html][上一项]] |

--------------

* Elisp: Write File
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-04. Last updated: 2018-09-10.

** Write Region to File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To write to a file in a batch script, most of the time you want
=write-region=

#+BEGIN_SRC emacs-lisp
    ;; write current buffer's content to ~/temp.el
    (write-region (point-min) (point-max) "~/temp.el")
#+END_SRC

Note: in batch script you should not use =write-file=. “write-file” is
like other editor's “Save As”. It has side-effects such as opening the
file, run its major mode and hooks, and is slow. [see
[[../emacs/elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp Text
Processing: find-file vs with-temp-buffer]]]

** Write String to File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (write-region "something something" nil "filepath")
#+END_SRC

** Open, Read, Possibly Write
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you want to write to file ONLY when you actually changed the file,
you can create flag variable and use =write-region=, like this:

#+BEGIN_SRC emacs-lisp
    (defun my-process-file (fPath)
      "Process the file at path FPATH …"
      (let ((fileChanged-p nil))
        (with-temp-buffer
          (insert-file-contents fPath)

          ;; process text
          ;; set fileChanged-p to t or nil

          (when fileChanged-p (write-region 1 (point-max) fPath)))))
#+END_SRC

** Create New File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you want to create new file, use =with-temp-file=.

=(with-temp-file path &rest body)=

it'll create a new buffer, then run body, then it'll write to file at
path. Existing file at path are overwritten.

#+BEGIN_SRC emacs-lisp
    ;; create new buffer, do things, then write to file at fpath
    (with-temp-file fpath
      (insert-file-contents fpath)

      ;; insert text here

      )
#+END_SRC

** Append to File
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(append-to-file START END FILENAME)=
#+BEGIN_SRC emacs-lisp
    ;; append whole buffer content to a file
    (append-to-file (point-min) (point-max) "filePath")
#+END_SRC

[[../emacs_manual/elisp/Writing-to-Files.html][(info "(elisp) Writing to
Files")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_write_file.html]]

\\
\\
| [[../index_u7.html#article_35][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u26.html>>

| [[../article_37/index_u9.html][下一项]] |
[[../index_u7.html#article_36][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_35/index_u13.html][上一项]] |

--------------

* Elisp: Print, Output
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-08-07. Last updated: 2018-12-01.

Here's a summary of most basic elisp printing functions:

• =message= → =(message FORMAT-STRING &rest ARGS)= print a format string
to the message buffer.

• =insert= → =(insert &rest ARGS)= instert string to current buffer, at
cursor position.

• =print= → =(print OBJECT &optional PRINTCHARFUN)= print lisp object.
Output can be read back by function =read=. Optional arg for a target
buffer, or other functions.

• =prin1= → =(prin1 OBJECT &optional PRINTCHARFUN)= like print, but does
not add newline at end.

• =princ= → =(princ OBJECT &optional PRINTCHARFUN)= print without
newline nor delimiters. For human reading.

** Simple Printing with “message”
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The most basic printing function is =message=. Here's a example:

#+BEGIN_SRC emacs-lisp
    ; printing
    (message "hi")

    ; printing variable values

    ;; %d is decimal number
    (message "age is: %d " 16)

    ;; %s is for string
    (message "name is: %s " "Joe")

    ;; %c is char by unicode codepoint in decimal
    (message "Mid init is: %c " 65)
    ;; 65 is A
#+END_SRC

You can see past output of the =message= function in the buffer named
“*Messages*”. You can view the buffer by Alt+x =view-echo-area-messages=
【Ctrl+h e】.

The “*Messages*” buffer is a special buffer, because it is the general
output destination for any messages from emacs.

For example, it automatically truncates the top entries when the buffer
reaches some size (see variable messages-buffer-max-lines). Also, when a
message is repeated many times, it automatically condenses the repeated
lines. And if a message is a huge line, the line is truncated
automatically. Here's a example.

#+BEGIN_SRC emacs-lisp
    ;; print a line many times
    (setq xx 1)
    (while (< xx 20)
      (message "yay")
      (setq xx (1+ xx))
      )
    (switch-to-buffer "*Messages*")
#+END_SRC

In the above example, it prints “yay [19 times]” instead of the “yay”
line for 19 times.

[[../emacs_manual/elisp/Displaying-Messages.html][(info
"(elisp)Displaying Messages")]]

** Print to Your Own Buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

When writing a elisp script that does batch processing, it's best to
print to your own buffer, because the Messages buffer scrolls off.

#+BEGIN_SRC emacs-lisp
    (setq xbuff (generate-new-buffer "*my output*"))

    (print "something" xbuff)

    (switch-to-buffer xbuff )
#+END_SRC

[see [[file:elisp_buffer_file_functions.html][Elisp: Buffer Functions]]]

** “print” and “prin1” function
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Elisp provides the =print= function. The basic syntax is this:

=(print OBJECT)=

The “OBJECT” is any elisp object you want to print. It can be any lisp
datatype, such as string, number, list, buffer, frame, ..., etc.

There's also a function named =prin1=. This is same as =print= except it
doesn't add a newline.

** “princ” for Human-Friendly Output
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The =princ= is similar to =print=, except that the output is meant to be
human-friendly. For example, it does not print the delimiters of
strings.

#+BEGIN_SRC emacs-lisp
    (princ '("x" "y")) ; (x y)

    (prin1 '("x" "y")) ; ("x" "y")
#+END_SRC

[[../emacs_manual/elisp/Output-Functions.html][(info "(elisp) Output
Functions")]]

** with-output-to-temp-buffer
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=with-output-to-temp-buffer= →
=(with-output-to-temp-buffer BUFNAME &rest BODY)= Bind ‘standard-output'
to buffer BUFNAME, eval BODY, then show that buffer. This construct
makes buffer BUFNAME empty before running BODY. It does not make the
buffer current for BODY. Instead it binds ‘standard-output' to that
buffer, so that output generated with ‘prin1' and similar functions in
BODY goes into the buffer.

#+BEGIN_SRC emacs-lisp
    (setq xbuff (generate-new-buffer "*my output*"))

    (with-output-to-temp-buffer xbuff

      ;; this is inserted in current buffer
      (insert "xyz")

      ;; this is printed in buffer xbuff
      (print "abc"))

    (switch-to-buffer xbuff )
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_printing.html]]

\\
\\
| [[../index_u7.html#article_36][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u9.html>>

| [[../article_38/index_u27.html][下一项]] |
[[../index_u7.html#article_37][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_36/index_u26.html][上一项]] |

--------------

* Elisp: Format String
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-04.

How a lisp object is converted to string for printing is done by the
=format= function. It takes a input string, and several other arguments
of lisp objects, and output a string. Alt+x =describe-function= to
lookup its doc string. Here's a excerpt:

#+BEGIN_SRC emacs-lisp
    (format STRING &rest OBJECTS)

    Format a string out of a format-string and arguments.
    The first argument is a format control string.
    The other arguments are substituted into it to make the result, a string.

    The format control string may contain %-sequences meaning to substitute
    the next available argument:

    %s means print a string argument.  Actually, prints any object, with `princ'.
    %d means print as number in decimal (%o octal, %x hex).
    %X is like %x, but uses upper case.
    %e means print a number in exponential notation.
    %f means print a number in decimal-point notation.
    %g means print a number in exponential notation
      or decimal-point notation, whichever uses fewer characters.
    %c means print a number as a single character.
    %S means print any object as an s-expression (using `prin1').

    …
#+END_SRC

For example, if you want to print a date format in yyyy-mm-dd, padding
with leading “0”, you can do:

#+BEGIN_SRC emacs-lisp
    ;; format yyyy-mm-dd, ISO 8601 format
    (print (format "%04d-%02d-%02d" 2012 4 10))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_format.html]]

\\
\\
| [[../index_u7.html#article_37][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u27.html>>

| [[../article_39/index_u15.html][下一项]] |
[[../index_u7.html#article_38][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_37/index_u9.html][上一项]] |

--------------

* Elisp: Get Dired Marked Files
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-12-17. Last updated: 2019-10-22.

To get marked files in dired, use =dired-get-marked-files=

Then, you can map a function to all the files.

#+BEGIN_SRC emacs-lisp
    ;; apply a function to dired's marked files

    (require 'dired)

    (defun xah-open-dired-marked ()
      "Open marked files in dired."
      (interactive)
      (mapc 'find-file (dired-get-marked-files))
    )

    ;; test
    ;; M-x dired, then mark some files, then M-x xah-open-dired-marked

    ;; replace find-file to your own function
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_dired_marked_files.html]]

\\
\\
| [[../index_u7.html#article_38][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u15.html>>

| [[../article_40/index_u45.html][下一项]] |
[[../index_u7.html#article_39][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_38/index_u27.html][上一项]] |

--------------

* Elisp: Walk Directory
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-04-14. Last updated: 2018-09-14.

Here's how to walk directory.

** List Directory
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(directory-files DIRECTORY &optional FULL MATCH NOSORT)= → Return a
list of names of files in DIRECTORY. If FULL is non-nil, return absolute
file names. If MATCH is non-nil, only return matched files. If NOSORT is
non-nil, the list is not sorted, order is unpredictable.

#+BEGIN_SRC emacs-lisp
    ;; walk dir

    (mapc
     (lambda (x) (insert x "\n"))
     (directory-files "/Users/x/em/emacs/i" nil "\.jpg$" t))

    ;; sample output

    ;; ztn_emacs_pinky_wedge_2018-02-24.jpg
    ;; xah_lee_photo_2018-06-28.jpg
    ;; xah-fly-keys_kinesis_2017-09_60363.jpg
    ;; todo_list_crossout_nothing.jpg
    ;; the_book_of_shen_lang.jpg
    ;; sun_type_6_keyboard_meta_compose_altgraph_keys.jpg
#+END_SRC

[see [[file:elisp_regex.html][Elisp: Regex Tutorial]]]

Note: in unix, directory is considered a special file. So, in emacs doc
and other unix doc, the term “file name” may also refer to directory
name.

** List Directory and All Subdir
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(directory-files-recursively DIR REGEXP &optional INCLUDE-DIRECTORIES)=

Return list of all files under DIR and all its subdir that have file
names matching REGEXP. (note, the match is done against file name only,
not full path.) Returned list elements are full path. Optional argument
INCLUDE-DIRECTORIES non-nil means also include in the output directories
whose names match REGEXP.

#+BEGIN_SRC emacs-lisp
    ;; walk dir and all subdir

    (mapc (lambda (x) (insert x "\n"))
          (directory-files-recursively "/Users/x/em/" "\.jpg$" ))

    ;; sample output

    ;; /Users/x/em/emacs/i/Apple_G4_iBook_Snow_Euro_layout_keyboard_62224.jpg
    ;; /Users/x/em/emacs/i/Apple_iBook_G4_Snow_77735.jpg
    ;; /Users/x/em/misc/i/typing_of_the_dead_36588.jpg
    ;; /Users/x/em/misc/i/vim_fitness.jpg
    ;; /Users/x/em/tn/emacs/emacs_logo/emacs_logo_large.jpg
    ;; /Users/x/em/tn/emacs/i/unicode/Carbon_emacs_22_unicode.jpg
#+END_SRC

** Skipping Subdir
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In other programing languages (perl python golang), usually the dir
walker lets you skip some specified directory. The walker calls a doFile
function you write, and pass current dir or file, so you can skip it to
prevent going into.

In elisp, there's a package find-lisp.el that lets you use a regex to
filter dir, but is very slow. I do not recommend it.
[[[../emacs/elisp_find_lisp.html][Elisp: find-lisp.el]]]

To skip some subdir, it's faster if you just use
=directory-files-recursively= then filter result.

#+BEGIN_SRC emacs-lisp
    (setq
     skipDirs
     [
      "ergoemacs_org/emacs_manual/"
      "xahlee_info/REC-SVG11-20110816/"
      "xahlee_info/clojure-doc-1.8/"
      "xahlee_info/js_es2016/"
      "xahlee_info/python_doc_3.3.3/"
      ])

    (seq-filter
     (lambda (path)
       (not (seq-some
             (lambda (x) (string-match x path))
             skipDirs )))
     (directory-files-recursively "/Users/xah/web/xahlee_info/" "\\.svg$" ))
#+END_SRC

=seq-filter= and =seq-some= are in emacs 25.

[see [[../emacs/elisp_sequence_functions.html][Elisp: Sequence
Functions]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_traverse_dir.html]]

\\
\\
| [[../index_u7.html#article_39][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u45.html>>

| [[../article_41/index_u36.html][下一项]] |
[[../index_u7.html#article_40][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_39/index_u15.html][上一项]] |

--------------

* Elisp: Call Shell Command
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-04. Last updated: 2020-06-05.

** Call Shell Command, Wait, Get Result
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =shell-command= → call a shell command, wait for it to finish.
- =shell-command-to-string= → call a shell command and get its output

#+BEGIN_SRC emacs-lisp
    ; call a shell command
    (shell-command "ls")
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ; call a shell command and get its output
    (shell-command-to-string "ls")
#+END_SRC

** Call Shell, Don't Wait
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Call a shell command, but don't wait for it to finish before continuing,
use =start-process= or =start-process-shell-command=

#+BEGIN_SRC emacs-lisp
    ;; open files in Linux desktop
    (mapc
     (lambda (x)
       (let ((process-connection-type nil))
         (start-process "" nil "xdg-open" x)) )
     filePathList)
#+END_SRC

** Call PowerShell
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a example of how to call a PowerShell Core command.

#+BEGIN_SRC emacs-lisp
    ;; on Microsoft Windows 10, call PowerShell Core to generate UUID
    (shell-command "pwsh.exe -Command [guid]::NewGuid().toString()" t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; on macOS, call PowerShell Core to generate UUID
    (shell-command "pwsh -Command '[guid]::NewGuid().toString()'" t)
#+END_SRC

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Asynchronous-Processes.html][(info "(elisp)
Asynchronous Processes")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_call_shell_command.html]]

\\
\\
| [[../index_u7.html#article_40][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u36.html>>

| [[../article_42/index_u63.html][下一项]] |
[[../index_u7.html#article_41][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_40/index_u45.html][上一项]] |

--------------

* Elisp: Get Script Name at Run Time, Call by Relative Path
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-05-28. Last updated: 2018-09-04.

** Get Current Script's Name Programmatically
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; get the current elisp script's name at run time
    (or load-file-name buffer-file-name)
#+END_SRC

Explanation: If user ran your script by =eval-buffer=, then
load-file-name's value would be nil. So, using both {load-file-name,
=buffer-file-name= } is a good way to get the script name regardless
whether the script is executed by load or eval buffer.

If you want the directory, call =file-name-directory= on the result.

** Get Full Path from Relative Path at Run Time
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you have file A, that calls =load= to load a file at B, and B calls
=load= on file C using a relative path, then Emacs will complain about
unable to find C. Because, emacs does not switch current directory with
=load=.

The following function solves this problem.

#+BEGIN_SRC emacs-lisp
    (defun xah-get-fullpath (@file-relative-path)
      "Return the full path of *file-relative-path, relative to caller's file location.

    Example: If you have this line
     (xah-get-fullpath \"../xyz.el\")
    in the file at
     /home/joe/emacs/emacs_lib.el
    then the return value is
     /home/joe/xyz.el
    Regardless how or where emacs_lib.el is called.

    This function solves 2 problems.

    ① If you have file A, that calls the `load' on a file at B, and B calls `load' on file C using a relative path, then Emacs will complain about unable to find C. Because, emacs does not switch current directory with `load'.

    To solve this problem, when your code only knows the relative path of another file C, you can use the variable `load-file-name' to get the current file's full path, then use that with the relative path to get a full path of the file you are interested.

    ② To know the current file's full path, emacs has 2 ways: `load-file-name' and `buffer-file-name'. If the file is loaded by `load', then `load-file-name' works but `buffer-file-name' doesn't. If the file is called by `eval-buffer', then `load-file-name' is nil. You want to be able to get the current file's full path regardless the file is run by `load' or interactively by `eval-buffer'."

      (concat (file-name-directory (or load-file-name buffer-file-name)) @file-relative-path)
    )
#+END_SRC

See also: [[file:elisp_library_system.html][What's the difference
between load-file, load, require, autoload?]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_relative_path.html]]

\\
\\
| [[../index_u7.html#article_41][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u63.html>>

| [[../article_43/index_u46.html][下一项]] |
[[../index_u7.html#article_42][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_41/index_u36.html][上一项]] |

--------------

* Elisp: List
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-21. Last updated: 2018-09-15.

Emacs Lisp's list datatype is known as linked list in computer science.

Here's a high-level tutorial on how to use it.

** Create List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To create a list, write it like this =(list a b …)=.

#+BEGIN_SRC emacs-lisp
    ; assign a list to a var
    (setq mylist (list 1 "b" 3))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ; prints a list
    (message "%S" mylist)
#+END_SRC

If you do not want the elements evaluated, write it like this:

='(a b …)=

This is equivalent to

=(quote (list a b …))=

#+BEGIN_SRC emacs-lisp
    ; assign a list to a var
    (setq mylist '(a b c))

    ; prints a list
    (message "%S" mylist)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; create a list of values of variables
    (let ((x 3) (y 4) (z 5))
      (message "%S" (list x y z))
      ) ; prints "(3 4 5)"
#+END_SRC

=(make-list LENGTH INIT)= → create a list of length LENGTH, and all
elements with value INIT.

#+BEGIN_SRC emacs-lisp
    (make-list 4 0) ;; (0 0 0 0)
#+END_SRC

** Empty List, nil
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In elisp, empty list is equivalent to =nil=. The following are all
equivalent.

- ='()=
- =(list)=
- =nil=

#+BEGIN_SRC emacs-lisp
    (eq '() (list ) ) ; t
    (eq '() nil); t
    (eq (list ) nil ) ; t
#+END_SRC

** List of Numbers (aka Range Function)
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(number-sequence n m step)= → returns a list of a range of numbers,
from n to m, in increment of step.

=(number-sequence n m)= → default step 1.

=(number-sequence n)= → returns a list of 1 element of value n.

#+BEGIN_SRC emacs-lisp
    ;; creating a range of numbers

    ;; just 1 element
    (number-sequence 5) ; (5)

    ;; n to m, inclusive
    (number-sequence 2 5) ; (2 3 4 5)

    ;; using 3 as step
    (number-sequence 0 9 3) ; (0 3 6 9)

    ;; step can be negative
    (number-sequence 5 0 -1) ; (5 4 3 2 1 0)

    ;; boundaries can be float but will not include
    (number-sequence 2.2 5.3) ; (2.2 3.2 4.2 5.2)
#+END_SRC

** Length
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(length list)= → return number of elements.

#+BEGIN_SRC emacs-lisp
    (length '("a" "b" "c") ) ; 3
#+END_SRC

** Get 1 Element from a List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(car list)= → first element
- =(nth n list)= → nth element
- =(car (last list))= → last element

List index count starts from 0.

#+BEGIN_SRC emacs-lisp
    (car (list "a" "b" "c") )   ; "a"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (nth 1 (list "a" "b" "c") ) ; "b"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (car (last (list "a" "b" "c")) )   ; "c"
#+END_SRC

** Get Sublist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(cdr list)= → 2nd to last elements.
- =(nthcdr n list)= → nth to last elements.
- =(butlast list n)= → without the last n elements.

#+BEGIN_SRC emacs-lisp
    (cdr (list "a" "b" "c") )   ; ("b" "c")
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (butlast (list "a" "b" "c" "d") )   ; ("a" "b" "c")
    (butlast (list "a" "b" "c" "d") 2)   ; ("a" "b")
#+END_SRC

** Prepend to list
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(cons x list)= → Return a new list, with x added to front. (prepend)

#+BEGIN_SRC emacs-lisp
    (cons "a" (list "c" "d") ) ; ("a" "c" "d")

    (cons (list "a" "b") (list "c" "d") ) ; (("a" "b") "c" "d")
#+END_SRC

** Append, Join Lists
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(append sequence1 sequence2 …)= → join any sequence types and return a
list. Warning: if you want it to return a propert list, the last element
must be a list, or nil.

#+BEGIN_SRC emacs-lisp
    (equal
     (list 1 2 3 4)
     (append (list 1 2) (list 3 4))
     )
    ;; t
#+END_SRC

** Modify List Variable
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(push list)= → Add a element to the front variable. Returns the new
  list.
- =(pop list)= → Remove first element from the variable. Returns the
  removed element.
- =(nbutlast list n)= → Remove last n elements from the variable.
  Returns the new value of the variable.
- =(setcar list x)= → replaces the first element in list with x. Returns
  x.
- =(setcdr list x)= → replaces the rest of elements in list with x.
  Returns x.

#+BEGIN_SRC emacs-lisp
    (let ((x '(1)))
      (push 2 x)
      (equal x '(2 1)) ; true
      )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (setq mylist '("a" "b" "c"))
    (pop mylist)   ; "a"
    (print mylist) ; ("b" "c")
#+END_SRC

The weird names {car, cdr, cons} are like that for historical reasons.

** List to String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Ways to convert a list to string.

#+BEGIN_SRC emacs-lisp
    ;; convert a list to string
    (mapconcat 'number-to-string '(1 2 3) ",")
    ;; "1,2,3"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; convert a list to string
    (mapconcat 'identity '("a" "b" "c") ",")
    ;; "a,b,c"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; convert list to string

    (format "%s" '(1 "two" 3))
    ;; "(1 two 3)"

    (substring (format "%s" '(1 "two" 3)) 1 -1)
    ;; "1 two 3"
#+END_SRC

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Lists.html][(info "(elisp) Lists")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_list.html]]

\\
\\
| [[../index_u7.html#article_42][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u46.html>>

| [[../article_44/index_u3.html][下一项]] |
[[../index_u7.html#article_43][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_42/index_u63.html][上一项]] |

--------------

* Elisp: Vector
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2015-04-13. Last updated: 2018-09-13.

Emacs lisp vector datatype is similar to
[[http://xahlee.info/java-a-day/arrays.html][Java's Array]].

1. Vector is a ordered sequence of values.
2. Each element can be any type.
3. Element's value can be changed.
4. Number of elements cannot change. (i.e. Vector's length is fixed.)
5. Reading/Writing a element has constant random access time.

** Create Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(make-vector 5 0)= → create a vector of length 5, value 0 for all
elements.

#+BEGIN_SRC emacs-lisp
    ;; create a vector of length 5, value 0 for all elements
    (make-vector 5 0) ;; [0 0 0 0 0]
#+END_SRC

=(vector a b …)= → create a vector with elements a b ....

#+BEGIN_SRC emacs-lisp
    ;; create a vector and set to var v
    (setq v (vector 3 4 5))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (setq x 7)

    ;; each element will be evaluated
    (setq v (vector 3 x 5))

    v ; [3 7 5]
#+END_SRC

If you do not want the elements evaluated, write it like this:

=[a b …]=

#+BEGIN_SRC emacs-lisp
    (setq n 7)

    ;; create a vector of elements 3 n 5. each element is NOT evaluated
    (setq v [3 n 5])

    v ; [3 n 5]
    ;; the n remains a symbol, not 7
#+END_SRC

** Fill Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(fillarray array val)= → make all elements of array to have value val

#+BEGIN_SRC emacs-lisp
    (setq aa [3 4 5])
    (fillarray aa nil) ;; [nil nil nil]
#+END_SRC

** Length
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (length (vector 7 4 5)) ; 3
#+END_SRC

** Get Element
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(aref array n)= → Return the element of array at index n.

=(elt sequence n)= → Return element of sequence at index n.

When emacs doc mentions “ARRAY”, you can think of it as “vector or
string”.

When emacs doc mentions “SEQUENCE”, you can think of it as “list or
array”.

#+BEGIN_SRC emacs-lisp
    ;; get a element from vector
    (aref ["a" "b" "c"] 0) ; ⇒ "a"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; get a element from vector
    (elt ["a" "b" "c"] 0) ; ⇒ "a"
#+END_SRC

*** What's the difference between =aref= and =elt=?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

=elt= is more general. It works on vector and list.

But if you know it's vector, you should use =aref=, because it's precise
and faster.

[see [[file:elisp_list_vs_vector.html][Elisp: Sequence Type]]]

** Change Element
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(aset ARRAY IDX NEWELT)= → Store into the element of ARRAY at index IDX
the value NEWELT. Return NEWELT.

#+BEGIN_SRC emacs-lisp
    (setq v [3 4 5])
    (aset v 0 "b")
    v  ; ⇒ ["b" 4 5]
#+END_SRC

** Nested Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Vector can be nested in any way, because the elements can be any type.

#+BEGIN_SRC emacs-lisp
    ;; nested vector
    [[1 2] [3 4]] ; 2 by 2 matrix
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; random nested vector
    [8 [3 [2 9] c] 7 [4 "b"]]
#+END_SRC

** Join Vectors, Convert List to Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(vconcat sequence1 sequence2 …)= → join any sequence types and return a
vector. (List and vector are both sequence types.)

#+BEGIN_SRC emacs-lisp
    ;; join any sequence types
    (vconcat [3 4] ["a" "b"]) ; ⇒ [3 4 "a" "b"]

    (vconcat [3 4] '("a" "b")) ; ⇒ [3 4 "a" "b"]

    (vconcat [3 4] "ab") ; ⇒ [3 4 97 98]
    ;; string elements are converted to char.
    ;; 97 is the codepoint for the char a
#+END_SRC

** Convert Vector to List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(append sequence1 sequence2 …)= → join any sequence types and return a
list. (List and vector are both sequence types.)

Warning: if you want it to return a propert list, the last element must
be a list, or nil.

#+BEGIN_SRC emacs-lisp
    ;; convert vector to list
    (append [1 2 3] nil)
    ; ⇒ (1 2 3)

    (append [1 2 3] [4 5] )
    ;; (1 2 3 . [4 5])
    ;; this is improper list

    (append [1 2 3] [4 5] nil)
    ;; (1 2 3 4 5)
    ;; proper list

    (append [1 2 3] [4 5] '(6))
    ;; (1 2 3 4 5 6)
    ;; proper list
#+END_SRC

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Vectors.html][(info "(elisp) Vectors")]]

[[../emacs_manual/elisp/Vector-Functions.html][(info "(elisp) Vector
Functions")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_vector.html]]

\\
\\
| [[../index_u7.html#article_43][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u3.html>>

| [[../article_45/index_u4.html][下一项]] |
[[../index_u7.html#article_44][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_43/index_u46.html][上一项]] |

--------------

* Elisp: Sequence Type
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-21. Last updated: 2020-04-19.

Here's a chart of elisp's most important list-like datatypes.

[[file:feed_0/article_44/images/img1_u2.svg]]

Most commonly used list-like data structure in elisp. (note: there's
also char-table and bool-vector datatypes, which are sub-types of of
array type. They are more specialized.)

Note: “Sequence” and “Array” are not actual datatypes in elisp. They are
grouping names for other actual datatypes.

When a function's doc says that an argument is a sequence type, it means
that it can be list, vector, or string. (e.g. =mapcar=)

When a function's doc says an argument is a array type, it means that it
can be vector, or string. (e.g. =aref=)

List and Vector both hold a ordered sequence of values, each value can
be any type.

** Differences Between List and Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the primary differences between list and vector:

- Vector, access time to any element is constant.
- Vector's length cannot change. (if you create a new copy of a vector,
  the time required is proportional to the vector's length)
- List, access time to a element is proportional to the distance of the
  element's position in the list.
- List's length can grow by prepending element, and can shorten by
  removing first element. These operations have constant time.

In short, list can grow or shorten, but if you have a long list, say 1
thousand items, accessing 900th item is slow.

Vector has fixed length. Accessing any element is fast.

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Sequences-Arrays-Vectors.html][(info "(elisp)
Sequences Arrays Vectors")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_list_vs_vector.html]]

\\
\\
| [[../index_u7.html#article_44][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u4.html>>

| [[../article_46/index_u10.html][下一项]] |
[[../index_u7.html#article_45][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_44/index_u3.html][上一项]] |

--------------

* Elisp: Sequence Functions
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-13. Last updated: 2020-09-08.

Here's a collection of functions that works on
[[../emacs/elisp_list_vs_vector.html][Sequence type]].

Note, this page does not include functions for
[[file:elisp_association_list.html][Association List]] nor
[[file:elisp_property_list.html][Property List]] .

** Create List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(number-sequence n m step)= → returns a list of a range of numbers,
  from n to m, in increment of step.

** Get Element from List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(car list)= → first element
- =(cdr list)= → rest elements
- =(nth n list)= → nth element
- =(nthcdr N LIST)= → rest starting at n.
- =(last LIST &optional N)= → last as a list. i.e. return
  =(cons lastElement nil)=. To get the actual last item of a list, do
  =(car (last list))=

** Add to List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(cons x list)= → Return a new list, with x added to left.
- =(add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FN)=
- =(add-to-ordered-list LIST-VAR ELEMENT &optional ORDER)=

** Modify List Variable
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(push list)= → Add a element to the front variable. Returns the new
  list.
- =(pop list)= → Remove first element from the variable. Returns the
  removed element.
- =(nbutlast list n)= → Remove last n elements from the variable.
  Returns the new value of the variable.
- =(setcar list x)= → replaces the first element in list with x. Returns
  x.
- =(setcdr list x)= → replaces the rest of elements in list with x.
  Returns x.

** List to Vector
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(vconcat sequence1 sequence2 …)= → join any sequence types and return
  a vector.

** Sequence to List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(append sequence1 sequence2 …)= → join any sequence types and return
  a list. Warning: if you want it to return a propert list, the last
  element must be a list, or nil.

** Sequence to String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =(format "%s" sequence)=

** Sequence Functions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

These functions work on any sequence type. (list,vector, string).

Those starting with “seq-” are new in emacs 25.1, released in 2016-09.
They are from “seq.el”, and the file is loaded when emacs starts. You
may want to explicitly declare =(require 'seq)=.

Some of these provide new functionalities, some gives a unified
interface to old functions.

- =length=
- =sequencep=
- =elt=
- =copy-sequence=
- =reverse=
- =nreverse=
- =sort=
- =seq-elt=
- =seq-length=
- =seqp=
- =seq-drop=
- =seq-take=
- =seq-take-while=
- =seq-drop-while=
- =seq-do=
- =seq-map=
- =seq-mapn=
- =seq-filter=
- =seq-remove=
- =seq-reduce=
- =seq-some=
- =seq-find=
- =seq-every-p=
- =seq-empty-p=
- =seq-count=
- =seq-sort=
- =seq-contains=
- =seq-position=
- =seq-uniq=
- =seq-subseq=
- =seq-concatenate=
- =seq-mapcat=
- =seq-partition=
- =seq-intersection=
- =seq-difference=
- =seq-group-by=
- =seq-into=
- =seq-min=
- =seq-max=
- =seq-doseq=
- =seq-let=

** Check Existence
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(member x list)= → check if x is in list. If so, return a list starting
with the first occurrence of object. Else return =nil=. Comparison done
using =equal=.

=(memq x list)= → same as =member=, but comparison done using =eq=.

=(memql x list)= → same as =member=, but comparison done using =eql=.

#+BEGIN_SRC emacs-lisp
    (member "4" '("3" "4" "5")) ;; ("4" "5")
#+END_SRC

Note: =(eq "s" "s")= is false, and =(eq 1.2 1.2)= also false.

(The difference of =eq= and =eql= is that the latter will return t for
same floating point numbers.)

=(member-ignore-case x list)= → same as =member=, except that x should
be a string, and comparison ignores letter-case.

#+BEGIN_SRC emacs-lisp
    (member-ignore-case "A" '("b" "a")) ; ("a")
#+END_SRC

** Delete All X in Sequence
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(delete x sequence)= → remove all x in sequence. The original sequence
is destroyed. Returns a new sequence. The comparison is done with
=equal=.

#+BEGIN_SRC emacs-lisp
    (setq xx '(3 4 5))

    ;; always set result to the same var. because original is usually destroyed
    (setq xx (delete 4 xx)) ; (3 5)

    ;; on vector
    (setq xx [3 4 5])
    (setq xx (delete 4 xx)) ; [3 5]
#+END_SRC

=(remove x sequence)= → same as =delete=, except sequence is not
destroyed.

#+BEGIN_SRC emacs-lisp
    (setq xx '(3 4 5))
    (remove 4 xx) ;; (3 5)
    xx ; (3 4 5)
#+END_SRC

=(delq x sequence)= → Same as =delete=, except the comparison is done
with =eq=.

#+BEGIN_SRC emacs-lisp
    (setq xx '(3 4 5))

    ;; always set result to the same var
    (setq xx (delq 4 xx)) ; (3 5)
#+END_SRC

=(remq x list)= → same as =delq=, except it does not destroy the
original list.

#+BEGIN_SRC emacs-lisp
    (setq xx '(3 4 5))
    (remq 4 xx) ; (3 5)
    xx ; (3 4 5)
#+END_SRC

** Delete Duplicates
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(delete-dups list)= → This function destructively removes all
duplicates from list, return a new list. The first one is kept among
duplicates.

#+BEGIN_SRC emacs-lisp
    (setq xx '(3 4 5 3 2))
    (setq xx (delete-dups xx)) ; (3 4 5 2)
#+END_SRC

** Misc
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- =nconc=

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Sequence-Functions.html][(info "(elisp) Sequence
Functions")]]

See also: [[../emacs_manual/elisp/Sets-And-Lists.html][(info "(elisp)
Sets And Lists")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_sequence_functions.html]]

\\
\\
| [[../index_u7.html#article_45][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u10.html>>

| [[../article_47/index.html][下一项]] |
[[../index_u7.html#article_46][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_45/index_u4.html][上一项]] |

--------------

* Elisp: Map List/Vector
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-08-30. Last updated: 2018-09-13.

** Map: mapcar
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Typical way to go thru a [[file:elisp_list_vs_vector.html][Sequence]] is
using =mapcar=. Note that it returns a list, even if input is a vector.

=(mapcar FUNCTION SEQUENCE)= → Apply FUNCTION to each element of
SEQUENCE, and make a list of the results. The result is a list, with
same length as SEQUENCE. SEQUENCE may be a list, a vector, a
bool-vector, or a string.

#+BEGIN_SRC emacs-lisp
    ;; add 1 to each vector element
    (mapcar '1+ [3 4 5] ) ; (4 5 6)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; add one to each list element
    (mapcar '1+ '(3 4 5)) ; (4 5 6)
#+END_SRC

=1+= is a lisp function. It adds 1 to argument and returns it. For
example, =(1+ 2)= returns 3.

To use a function in =mapcar=, you need to quote the function's name.

=1+= is a function, so we quote it and have ='1+= or =(quote 1+)=

Here's another example.

#+BEGIN_SRC emacs-lisp
    ; take the 1st element of each
    (mapcar 'car '((1 2) (3 4) (5 6))) ; (1 3 5)
#+END_SRC

** mapcar with lambda
   :PROPERTIES:
   :CLASS: calibre17
   :END:

mapcar is most commonly used with lambda. Here's a example:

#+BEGIN_SRC emacs-lisp
    ;; get first element of each row
    (mapcar
     (lambda (x) (elt x 0))
     [[1 2] [3 4]] ) ; ⇒ (1 3)
#+END_SRC

=lambda= means function, often known as “anonymous function”. It let you
define a function in the middle of your code.

The form is =(lambda (args) body)=.

For example, =(lambda (x y) (+ x y))= is a function that takes two
arguments, x and y, and returns their sum.

More examples with lambda:

#+BEGIN_SRC emacs-lisp
    ; add one to each list member
    (mapcar
     (lambda (x) (+ x 1))
     (list 1 2 3 4)
    ) ; (2 3 4 5)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; take the 2nd element of each
    (mapcar (lambda (x) (nth 1 x))
            '((1 2) (3 4) (5 6))) ; (2 4 6)
#+END_SRC

** mapc (foreach)
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you don't need map to return the sequence, use =mapc=.

=mapc= → like =mapcar=, but returns nil.

#+BEGIN_SRC emacs-lisp
    ;; apply a file processing function to a list of files
    (mapc 'my-update-html-footer
          (list
           "~/file1.html"
           "~/file2.html"
           "~/file3.html"
           ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; example of mapc on vector
    (mapc
     (lambda (x)
       (insert (number-to-string (aref x 0))))
     [[1 2] [3 4]] )

    ;; insert first element of each row into buffer
    ;; (it inserts 13)
    ;; returns nil
#+END_SRC

** dolist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(dolist (VAR LIST) BODY)= → Loop over a list. Evaluate BODY with VAR
bound to each element from LIST, returns nil.

=(dolist (VAR LIST RESULT) BODY)= → returns RESULT.

#+BEGIN_SRC emacs-lisp
    (let (
          (xlist (number-sequence 97 122)) ;; list 97 to 122
          )
      (dolist (n xlist) (insert n)))

    ;; inserts
    ;; abcdefghijklmnopqrstuvwxyz
#+END_SRC

The major difference between =dolist= and =mapc= is that =dolist= uses
expression, =mapc= uses a function. Also, =dolist= work with list only,
=mapc= works with list and vectors.

** dotimes
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=dotimes= is useful when you want to go thru a list by a increasing
index.

=(dotimes (VAR COUNT) BODY …)= → Loop a certain number of times.
Evaluate BODY with VAR bound to successive integers running from 0,
inclusive, to COUNT, exclusive. Returns nil

=(dotimes (VAR COUNT RESULT) BODY …)= → After loop, evaluate RESULT to
get the return value.

#+BEGIN_SRC emacs-lisp
    (dotimes (i 4)
      (insert (number-to-string i)))
    ;; inserts "0123", returns nil
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (let ((v [3 4 5]))
      (dotimes (i (length v))
        (insert
         (number-to-string
          (elt v i))))) ; inserts 345
#+END_SRC

** while Loop
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Another common form to loop thru a list is using the =while= function.
In each iteration, =pop= is used to reduce the list.

#+BEGIN_SRC emacs-lisp
    (let ((mylist '(a b c)))
      (while mylist
        (message "%s" (pop mylist))
        (sleep-for 1)))
#+END_SRC

Example with vector:

#+BEGIN_SRC emacs-lisp
    (setq v [3 4 5])
    (setq i 0)

    (while (< i (length v))
      (insert (format "%d" (elt v i)))
      (setq i (1+ i))) ; inserts "345"
#+END_SRC

** Exit Loop/Function, catch/throw
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_break_loop.html][Elisp: throw, catch]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_mapcar_loop.html]]

\\
\\
| [[../index_u7.html#article_46][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index.html>>

| [[../article_48/index_u30.html][下一项]] |
[[../index_u7.html#article_47][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_46/index_u10.html][上一项]] |

--------------

* Elisp: throw, catch
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-07-11. Last updated: 2020-04-19.

To exit a loop or exit a function:

- Use =catch= and =throw= to exit loop/function. These are like “break”,
  “goto” in other programing languages.
- Use =error= or =user-error= to signal a error and exit.

** Exit a Function
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To exit a function, put

=throw 'tagname value=

at the place you want to exit, and wrap your function body with a

=catch 'tagname=

for the target exit position.

Here's example.

#+BEGIN_SRC emacs-lisp
    (defun test-exit-f ()
      "example. using catch/throw to exit function"
      (interactive)
      (catch 'aaa
        (if (y-or-n-p "exit?")
            (progn
              (message "existing")
              (throw 'aaa 3) ; if yes, exit right away, return 3 to catch
              )
          (progn ; else, go on
            (message "went on")
            4 ; return 4
            ))))
#+END_SRC

** Exit by Error
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can exit by calling =error= or =user-error= .

#+BEGIN_SRC emacs-lisp
    (defun test-exit-f ()
      "example"
      (interactive)
      (if (y-or-n-p "invoke user-error to exit?")
          (user-error "Error, because: %s" "you said so!")
        (progn ; else, go on
          (message "went on")
          )))
#+END_SRC

** Exit a map
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can also use =throw= and =catch= to exit a map or loop.

=(catch 'tagname body)= → evaluates body and return body's last
expression, but if body contains =(throw …)= and it is called, return
the value throw passes.

=(throw tagName passValue)= → jump to a outer =(catch 'tagName)= and
continue there, passing the value of passValue to it. Both tagName
passValue are evaluated.

#+BEGIN_SRC emacs-lisp
    (setq myList [0 1 2 3 4 5])

    ;; map lambda onto a list. If value 3 is found, return 3, else nil
    (catch 'bbb
      (mapc
       (lambda (x)
         (message "%s" x)
         (when (equal x 3) (throw 'bbb x)))
       myList)
      nil
      )
#+END_SRC

[[../emacs_manual/elisp/Catch-and-Throw.html][(info "(elisp) Catch and
Throw")]]

** Exit a While Loop by Flag
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a sample of setting flag:

#+BEGIN_SRC emacs-lisp
    (let ((myList [0 1 2 3 4 5] )
          (foundFlag-p nil )
          (i 0))

      (while (and
              (not foundFlag-p)
              (<= i (length myList)))

        ;; if found, set foundFlag-p
        (when (equal (elt myList i) 3)
          (setq foundFlag-p t ))

        (message "value: %s" i)
        (setq i (1+ i))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_break_loop.html]]

\\
\\
| [[../index_u7.html#article_47][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u30.html>>

| [[../article_49/index_u54.html][下一项]] |
[[../index_u7.html#article_48][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_47/index.html][上一项]] |

--------------

* Elisp: Association List
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2017-05-15. Last updated: 2020-04-19.

Associative List (aka “alist”) is a value type in Emacs Lisp.

Alist is a list, where each element is a cons pair, like this
=(cons key value)=.

Note: =(cons a b)= can also be written as =(a . b)=.

In each cons pair, the key and value can be any value type.

Items in alist can have duplicate keys, and order is maintained.

If you have more than a thousand items, and need fast random access,
better is to use [[file:elisp_hash_table.html][Hash Table]] .

*** What's the Difference Between Alist and Hash Table?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

- Alist is ordered.
- Alist can have duplicate keys.
- Hash Table keys are unique.
- Hash Table items are not ordered.
- Hash Table is faster for random access when there are huge number of
  items (over thousands).

** Create a Alist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; set x to a alist
    (setq x
          '(("mary" . 23)
            ("john" . 24)
            ("smith" . 33)))
#+END_SRC

Note, alist is a [[file:elisp_list.html][List]] , any function that
works on list also works on alist.

[see [[file:elisp_sequence_functions.html][Elisp: Sequence Functions]]]

** Alist Functions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the most useful functions designed for working with alist.

*** Get Pair by Key
    :PROPERTIES:
    :CLASS: calibre14
    :END:

=assoc=

=(assoc key alist)= → Return the first found pair with the key. If key
do not exist, return =nil=. (key existence is checked by =equal=.)

#+BEGIN_SRC emacs-lisp
    ;; set x to a alist
    (setq x
          '(("mary" . 23)
            ("john" . 24)
            ("smith" . 33)))

    ;; get the pair with key "john"
    (assoc "john" x)
    ; returns ("john" . 24)
#+END_SRC

After you got the cons pair, you can use =car= to get the first element,
and use =cdr= to get the last element.

#+BEGIN_SRC emacs-lisp
    ;; set x to a alist
    (setq x
          '(("mary" . 23)
            ("john" . 24)
            ("smith" . 33)))

    ;; get the value with key "john"
    (cdr (assoc "john" x))
    ; returns 24
#+END_SRC

*** Get Pair by Value
    :PROPERTIES:
    :CLASS: calibre14
    :END:

You can search alist by value.

=rassq=

=(rassq value alist)= → return the first association with value value in
alist. It returns =nil= if no association in alist has a CDR =eq= to
value.

#+BEGIN_SRC emacs-lisp
    ;; set x to a alist
    (setq x
          '(("mary" . 23)
            ("john" . 24)
            ("smith" . 33)))

    ;; get the pair with value 24
    (rassoc 24 x)
    ; returns ("john" . 24)
#+END_SRC

** More Alist Functions
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Association-Lists.html][(info "(elisp)
Association Lists")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_association_list.html]]

\\
\\
| [[../index_u7.html#article_48][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u54.html>>

| [[../article_50/index_u56.html][下一项]] |
[[../index_u7.html#article_49][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_48/index_u30.html][上一项]] |

--------------

* Elisp: Property List
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-15. Last updated: 2020-04-19.

** What's Property List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Property list (in short, plist) is a list, but to be interpreted as list
of pairs, like this:

='(key1 val1 key2 val2 …)=

Property list is not supposed to have duplicate keys, and should always
have even length.

Key should be lisp symbols, value can be any lisp object.

[[../emacs_manual/elisp/Property-Lists.html][(info "(elisp) Property
Lists")]]

** Use of Property List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Property List is used as a simplest form of key/value pairs.

Property list is used extensively in emacs.

The 2 major use of property list are:

- Symbol's property list. Each symbol, is associated with a property
  list. Used primarily to store info related to the symbol, such as
  compiler info, but can be anything. [see
  [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]
- Text Properties. Any character or string in a buffer, can have a
  property list, used to store syntax color info, special keyboard
  shortcut, etc. [see [[file:elisp_text_properties.html][Elisp: Text
  Properties]]]

Property list isn't a generic data structure. If you have more than 100
items, you probably should use Association List instead. [see
[[file:elisp_association_list.html][Elisp: Association List]]]

** Get a Key's Value
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(plist-get= PLIST PROP) → return the value of key PROP from property
list PLIST. If key does not exist, return =nil=. Existence of key is
checked with =eq=.

=lax-plist-get= → similar to =plist-get=, but compare key using =equal=.

#+BEGIN_SRC emacs-lisp
    (plist-get '(x 1 y 2) 'y) ; 2
    (plist-get '(x 1 y 2) 'b) ; nil
#+END_SRC

** Add/Modify item
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(plist-put= PLIST PROP VAL) → add or change the value of key PROP in
PLIST to VAL. The new plist is returned. Use
=(setq x (plist-put x prop val))= to be sure to use the new value.
Existence of key is checked with =eq=.

=lax-plist-put= → similar to =plist-put=, but compare key using =equal=.

#+BEGIN_SRC emacs-lisp
    ;; create a property list xx
    (setq xx '(a 1 b 2))

    ;; set value to a existing key
    (setq xx (plist-put xx 'b 3))

    xx
    ;; (a 1 b 3)
#+END_SRC

** Check Key Existence
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(plist-member= PLIST PROP) → Return true if PLIST has the property
PROP. . PROP is a symbol. Unlike =plist-get=, this allows you to
distinguish between a missing property and a property with the value
=nil=. The value is actually the tail of PLIST whose car is PROP.

#+BEGIN_SRC emacs-lisp
    (setq xx '(a 1 b 2))

    ;; check if a key exist
    (plist-member xx 'b)
    ;; (b 2)
#+END_SRC

[[../emacs_manual/elisp/Plist-Access.html][(info "(elisp) Plist
Access")]]

** Symbol's Property List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Each elisp symbol, can be attached a property list. Such is called
“*symbol plist*”.

[[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]

** Text Properties
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Text in a buffer region can be attached a property list. Such is called
“*Text Properties*”.

[[file:elisp_text_properties.html][Elisp: Text Properties]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_property_list.html]]

\\
\\
| [[../index_u7.html#article_49][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u56.html>>

| [[../article_51/index_u48.html][下一项]] |
[[../index_u7.html#article_50][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_49/index_u54.html][上一项]] |

--------------

* Elisp: Symbol Property List
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-15. Last updated: 2020-04-19.

Each lisp symbol is associated with a “property list”.

[see [[file:elisp_property_list.html][Elisp: Property List]]]

This property list is stored in the symbol's property list cell. [see
[[file:elisp_symbol.html][Elisp: Lisp Symbol]]]

Emacs lisp property list is used extensively in emacs. It is also very
useful if you want to write a function with state. You can store the
state info with the symbol itself, instead of using a global variable.

** Set Whole Plist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

(=setplist= SYMBOL NEWPLIST) → Set SYMBOL's property list to NEWPLIST,
and return NEWPLIST.

#+BEGIN_SRC emacs-lisp
    ;; set the value of symbol ff's property list
    (setplist 'ff '(a 1 b 2))
#+END_SRC

** Get Whole Plist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(symbol-plist= SYMBOL) → Return SYMBOL's property list.

#+BEGIN_SRC emacs-lisp
    ;; get the value of symbol ff's property list
    (symbol-plist 'ff )
#+END_SRC

** Add/Set a Key's Value
   :PROPERTIES:
   :CLASS: calibre17
   :END:

(=put= SYMBOL PROPNAME VALUE) → Store SYMBOL's PROPNAME property with
value VALUE.

#+BEGIN_SRC emacs-lisp
    ;; set the value of key xx, of symbol ff's property list
    (put 'ff 'xx 5)
#+END_SRC

** Get a Key's Value
   :PROPERTIES:
   :CLASS: calibre17
   :END:

(=get= SYMBOL PROPNAME) → Return the value of SYMBOL's PROPNAME
property.

#+BEGIN_SRC emacs-lisp
    ;; get the value of key xx, of symbol ff's property list
    (get 'ff 'xx)
#+END_SRC

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[../emacs_manual/elisp/Symbol-Properties.html][(info "(elisp) Symbol
Properties")]]

** Example of Using Symbol Properties
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_toggle_command.html][Elisp: How to Write a Toggle Command]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_symbol_plist.html]]

\\
\\
| [[../index_u7.html#article_50][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u48.html>>

| [[../article_52/index_u59.html][下一项]] |
[[../index_u7.html#article_51][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_50/index_u56.html][上一项]] |

--------------

* Elisp: Hash Table
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-01-30. Last updated: 2020-04-20.

Emacs lisp has 2 types of collection of key/value pairs.

- [[file:elisp_association_list.html][Association List]] (aka alist). →
  a ordered list of key val pairs. Keys may repeat.
- Hash Table. → unordered set of key val pairs. No duplicate keys.
  Constant access time.

** Create Hash Table
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=(make-hash-table :test 'equal)= → returns a new hashtable.

#+BEGIN_SRC emacs-lisp
    ;; create a hash table
    (setq myHash (make-hash-table :test 'equal))
#+END_SRC

The =:test 'equal= is to specify what function to use to test key
existence. For example, if your keys are integers or lisp symbols, you
can use =:test eq=. If your keys are strings, you must use
=:test equal=, because =(eq "x" "x")= returns =nil=.

Key or Value can be any lisp object (aka datatype).

There are more options for =make-hash-table=. Alt+x =describe-function=
for detail.

** Literal Expression for Hashtable
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can create a hash table by a literal expression, like this:

#+BEGIN_SRC emacs-lisp
    (setq myHash
          #s(hash-table
             size 30
             test equal
             data (
                   "joe" 3
                   "jane" 9
                   "liz" 5 )))

    ;; test
    (gethash "joe" myHash ) ; 3
#+END_SRC

[[../emacs_manual/elisp/Creating-Hash.html][(info "(elisp) Creating
Hash")]]

** Add Entry
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (puthash "joe" 19 myHash)
#+END_SRC

** Remove Entry
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (remhash "liz" myHash)
#+END_SRC

** Get Key's Value
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (gethash "jane" myHash)
#+END_SRC

** Number of Entries
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (hash-table-count myHash)
#+END_SRC

** Remove All Entries
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (clrhash myHash)
#+END_SRC

** Check Key Exist
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=gethash=

- =(gethash key table)= → check if a key exist. If so, return the value.
  Else, return =nil=
- =(gethash key table default)= → return default if key does not exist.

#+BEGIN_SRC emacs-lisp
    (let ((myHash (make-hash-table :test 'equal)))
      (puthash 'aa 9 myHash)
      (gethash 'bb myHash)    ; ⇒ nil
      (gethash 'bb myHash 10) ; ⇒ 10
      )
#+END_SRC

** Apply a Function to All Entries
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=maphash=

=(maphash myfun myHashtable)= → apply a function to all entries in a
hash table. The function myfun must take 2 arguments, key and value.

#+BEGIN_SRC emacs-lisp
    (setq myHash (make-hash-table :test 'equal))
    (puthash "joe" 19 myHash)
    (puthash "jane" 20 myHash)
    (puthash "carrie" 17 myHash)
    (puthash "liz" 21 myHash)

    (maphash
       (lambda (k v)
         (princ (format "%s , %s" k v))
         (princ "\n"))
       myHash
       )
#+END_SRC

** Get All Keys
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=hash-table-keys=

=(require 'subr-x) (hash-table-keys hash) =

new in emacs 24.4

#+BEGIN_SRC emacs-lisp
    ;; get all keys from a hash table

    (setq myHash
          #s(hash-table
             size 30
             test equal
             data (
                   "joe" 3
                   "jane" 9
                   "liz" 5 )))

    ;; get all keys
    (require 'subr-x)
    (hash-table-keys myHash) ; ("joe" "jane" "liz")
#+END_SRC

** Get All Values
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=hash-table-values=

=(require 'subr-x) (hash-table-values hash) =

new in emacs 24.4

#+BEGIN_SRC emacs-lisp
    ;; getting all keys from a hash table.

    ;; creating a hash
    (setq myHash (make-hash-table :test 'equal))
    (puthash "joe" "19" myHash)
    (puthash "jane" "20" myHash)

    ;; get all keys.
    (require 'subr-x)          ; emacs 24.4
    (hash-table-values myHash) ; ⇒ ("20" "19")
#+END_SRC

** Hash to List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-hash-to-list (@hash-table)
      "Return a list that represent the @HASH-TABLE
    Each element is a list: '(key value).

    http://ergoemacs.org/emacs/elisp_hash_table.html
    Version 2019-06-11"
      (let ($result)
        (maphash
         (lambda (k v)
           (push (list k v) $result))
         @hash-table)
        $result))
#+END_SRC

** Print Hashtable
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (print myHash)

    ;; sample output
    ;; #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("joe" 19 "jane" 16 "carrie" 17 ...))
#+END_SRC

Here's a pretty print function:

#+BEGIN_SRC emacs-lisp
    (defun my-print-hash (hashtable)
      "Prints the hashtable, each line is key, val"
      (maphash
       (lambda (k v)
         (princ (format "%s , %s" k v))
         (princ "\n"))
       hashtable
       ))

    ;; test

    (setq myHash (make-hash-table :test 'equal))
    (puthash "joe" 19 myHash)
    (puthash "jane" 20 myHash)
    (puthash "carrie" 17 myHash)
    (puthash "liz" 21 myHash)

    (my-print-hash myHash)
#+END_SRC

** Sort Hash
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To sort, first change it to a list.

#+BEGIN_SRC emacs-lisp
    (setq myHash (make-hash-table :test 'equal))
    (puthash "joe" 19 myHash)
    (puthash "jane" 20 myHash)
    (puthash "carrie" 17 myHash)
    (puthash "liz" 21 myHash)

    ;; get the hash table into a list
    (setq myList (xah-hash-to-list myHash))

    (setq myList (sort myList (lambda (a b) (string< (car a) (car b)))))

    (print myList)
#+END_SRC

Warning: elisp's =sort= function is destructive. Once =sort= is used on
a variable, that variable's value is essentially destroyed. (the sorted
result is returned.) If you want to keep the variable, make a copy
first.

[[../emacs_manual/elisp/Rearrangement.html][(info "(elisp)
Rearrangement")]]

[[../emacs_manual/elisp/Hash-Tables.html][(info "(elisp) Hash Tables")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_hash_table.html]]

\\
\\
| [[../index_u7.html#article_51][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u59.html>>

| [[../article_53/index_u49.html][下一项]] |
[[../index_u7.html#article_52][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_51/index_u48.html][上一项]] |

--------------

* Elisp: Lisp Symbol
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-30. Last updated: 2019-01-14.

Lisp has symbols concept. Lisp's concept of “symbols” is somewhat like
identifiers in other languages, except that:

- lisp symbol can be held unevaluated, simply as itself, a inert name.
  In this sense, it's like a string.
- lisp symbol stores more than one value.

** The Concept of Symbols in Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

LISP differs from most programing languages such as C, Java, Ruby,
Python, in that it deals with symbols, as opposed to just identifiers
and values.

For example, in most languages, once you defined =x=3=, you cannot
manipulate the variable “x” because it gets evaluated to 3 right away.
If you want, you have to build a string ="x"= and manipulate this
string, then use =eval(lots string join here)= to achieve the effect.
(for example, you have a variable x, and it has integer 3 as value. you
want to rename the variable so the new name is var_name + var_value.)

In lisp, after =(setq x 3)= then =x= would evaluate to 3, but
=(quote x)= evaluates to the symbol x itself.

In practice, having a language dealing with “symbols” directly means
that transformation of expressions in source code is possible at
run-time. (In lisp, this is the lisp macro feature, which is a limited
form of term rewriting languages such as Wolfram Language.)
[[../emacs_manual/elisp/Macros.html][(info "(elisp) Macros")]]

** Symbol's Cells
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Each lisp symbol has the following “cells” to store things:

- “*print name*” cell → a string, the same as the symbol. Automatically
  set, cannot be changed.
- “*value*” cell → stores the symbol's value. When value cell is not
  void, the symbol is considered as a variable.
- “*function*” cell → stores function definition object, lisp macros, or
  other objects that can act as function.
- “*property list*” cell → hold a list of name/value pairs. Used for
  storing meta info about the symbol, such as function state, font face
  spec (for syntax coloring), deprecation flag, etc.

A symbol's value cell or function cell may be empty. If so, it's said to
be “void”. When you try to get a cell's value that's void, it's a lisp
error. (a empty cell is not the same as having value of =nil=.)

Normally, you don't need to worry about any of these tech details. The
only thing that's useful for most elisp code is property list.

[see [[file:elisp_property_list.html][Elisp: Property List]]]

[see [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]

Understanding Lisp Symbol is important when you do advanced lisp
programing. For example: macros, create and call functions at run-time,
nested functions, manipulate evaluation, implementing a language, or any
sort of meta-programing. If you don't have a need, you should not
exploit these facilities in your program. Keep your code simple.

[[../emacs_manual/elisp/Symbols.html][(info "(elisp) Symbols")]]

** Quoting Symbol
   :PROPERTIES:
   :CLASS: calibre17
   :END:

A symbol, typically gets evaluated to its value. But you can stop this,
by =quote=. e.g. =(quote x)=. You can think of =quote= as “hold
evaluation”.

=quote= has a shortcut syntax.

=(quote x)= is syntactically equivalent to ='x=

[[../emacs_manual/elisp/Quoting.html][(info "(elisp) Quoting")]]

** When to Quote Symbol?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Some functions, automatically quote the argument for you, as a
convenience.

For example, =setq= always automatically quotes its first argument.
Because you basically always want the argument passed as a symbol. So,
you write =(setq x 3)= instead of =(set 'x 3)=.

The function =set= is almost the same as =setq=, except that =set= does
not automatically quote the first argument. So, you write =(set 'x 3)=.
[[../emacs_manual/elisp/Setting-Variables.html][(info "(elisp) Setting
Variables")]]

Some functions, require you to quote the argument yourself. Because
sometimes you want a symbol's value passed, and sometimes the symbol
itself.

For example, =mapcar='s arguments are not automatically quoted. You may
or may not want to quote them, depending on your use.

Here's two examples of using mapcar, where in one example we want to
quote the argument, and in the other example we do not want to quote the
argument.

#+BEGIN_SRC emacs-lisp
    ;; suppose we have many functions
    (setq f '1+)
    (setq f 'cos)
    (setq f 'sqrt)
    ;; we use f as a wrapper because we are not sure which function we want until run time

    ;; here's our data
    (setq mylist '(1 2 3))

    ;; normally, when using mapcar, we want first arg quoted
    (mapcar '1+ mylist) ; (2 3 4)

    ;; here, we don't want first arg quoted
    (mapcar f mylist) ; (1.0 1.4142135623730951 1.7320508075688772)
#+END_SRC

** Check If a Value is Symbol
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; check if a variable eval to a lisp symbol

    ;; make symbol x1's value cell to be 123
    (setq x1 123 )

    (symbolp x1) ; nil
    ;; nil, because x1 is evaluated, and that value is 123, not a symbol

    (symbolp 'x1) ; t
#+END_SRC

** Get Value of Symbol's Cells
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's how to get various cell's values.

Here's a example of getting cell values, with symbol “sin” (=sin= is a
builtin math function).

#+BEGIN_SRC emacs-lisp
    ;; get symbol's name cell value
    (symbol-name 'sin) ; "sin"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; get symbol's value cell value
    (symbol-value 'sin) ; void-variable error
    ;; because the value cell of the symbol sin is void
    ;; or, we just say that sin isn't a variable
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; get symbol's function cell value
    (symbol-function 'sin) ;#<subr sin>
    ;; the value is a primitive function (written in C), and has print form of #<subr sin>
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; get symbol's property list cell value
    (symbol-plist 'sin) ; (side-effect-free t)
#+END_SRC

Here's another example with a user defined symbol.

#+BEGIN_SRC emacs-lisp
    ;; get symbol cell values

    ;; this makes symbol x1's value cell to contain the number 3
    (setq x1 3) ; 3

    ;; get symbol's name cell value
    (symbol-name 'x1) ; "x1"

    ;; get symbol's value cell value
    (symbol-value 'x1) ; 3

    ;; get symbol's function cell value
    (symbol-function 'x1) ; nil
    ;; in emacs 24.3.1, this is a void-function error
    ;; in emacs 25.1, this returns nil
    ;; elisp manual 24 and 25.1  say it should be error

    ;; get symbol's property list cell value
    (symbol-plist 'x1) ;nil
#+END_SRC

** Set Symbol's Name Cell
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Symbol's name cell is automatically set, as a string of the symbol name.
Symbol name cell cannot be changed.

** Set Symbol's Value Cell
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The normal way to set a symbol's value cell is using =setq=.

#+BEGIN_SRC emacs-lisp
    ;; set a symbol's value cell
    (setq y "yes yes")

    ;; get it
    (symbol-value 'y) ; "yes yes"
#+END_SRC

[[../emacs_manual/elisp/Setting-Variables.html][(info "(elisp) Setting
Variables")]]

You can also check if a symbol's value cell is not empty, by =boundp=.
(we think of it as checking if a variable is defined.)

#+BEGIN_SRC emacs-lisp
    (boundp 'h) ; nil

    (setq h 4)

    (boundp 'h) ; t
#+END_SRC

** Set Symbol's Function Cell
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The normal way to set a symbol's function cell is using =defun= or
=defmacro=.

#+BEGIN_SRC emacs-lisp
    ;; a function that returns 4
    (defun z () 4)
    ;; Note: return value of defun is not defined

    ;; get a symbol's function cell value
    (symbol-function 'z) ; (lambda nil 4)
#+END_SRC

[[../emacs_manual/elisp/Defining-Functions.html][(info "(elisp) Defining
Functions")]]

[[../emacs_manual/elisp/Function-Cells.html][(info "(elisp) Function
Cells")]]

You can check if a symbol's function cell is not empty, by =fboundp=.

#+BEGIN_SRC emacs-lisp
    (fboundp 'f) ; nil

    ;; define a function that return 3
    (defun f () 3)

    ;; now the fuction cell is filled
    (fboundp 'f) ; t
#+END_SRC

Because a symbol can both hold a value and a function, a symbol can be
both a variable and function. For example, the symbol =buffer-file-name=
is both a variable and function. (you can try =describe-function= and
=describe-variable= on it.)

** Set Symbol's Property List Cell
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]

** Convert Symbol to String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert a symbol to string
    (symbol-name 'defun)
#+END_SRC

** Convert String to Symbol
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert a string to symbol

    ;; if the symbol does not already exist in obarray, create it, put it in obarray
    (intern "x")

    ;; if the symbol does not already exist in obarray, return nil
    (intern-soft "x")
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_symbol.html]]

\\
\\
| [[../index_u7.html#article_52][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u49.html>>

| [[../article_54/index_u35.html][下一项]] |
[[../index_u7.html#article_53][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_52/index_u59.html][上一项]] |

--------------

* Elisp: Lisp Special Form
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2018-09-10.

Normally, arguments passed to a function are evaluated, in order. In
elisp, this is called *standard evaluation strategy*.

However, for some function, evaluating arguments in order does not make
sense. For example, conditional construct =if=, or local variable
construct =let=. These functions, are said to have *non-standard
evaluation strategy*.

Of functions that are non-standard evaluation, they are either *macro*
or *special form*.

Macros are defined by lisp expressions with =defmacro=. User can define
them.

Special Forms are written in C.

Example of special forms:

1.  =and=
2.  =or=
3.  =catch=
4.  =if=
5.  =while=
6.  =cond=
7.  =condition-case=
8.  =defconst=
9.  =defvar=
10. =let=
11. =let*=
12. =prog1=
13. =prog2=
14. =progn=
15. =setq=
16. =setq-default=
17. =interactive=
18. =lambda=
19. =quote=
20. =function=
21. =save-current-buffer=
22. =save-excursion=
23. =save-restriction=
24. =track-mouse=
25. =unwind-protect=

[[../emacs_manual/elisp/Macros.html][(info "(elisp) Macros")]]

[[../emacs_manual/elisp/Special-Forms.html][(info "(elisp) Special
Forms")]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_special_form.html]]

\\
\\
| [[../index_u7.html#article_53][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u35.html>>

| [[../article_55/index_u16.html][下一项]] |
[[../index_u7.html#article_54][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_53/index_u49.html][上一项]] |

--------------

* Elisp: What's Function
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-09-15. Last updated: 2017-01-04.

Emacs Lisp manual uses the following terms to distinguish different
behavior of functions. For advanced lisp programing, you need to
understand them.

1. *lambda expression* → Anonymous function. Usually temp functions.
   Usually created by =lambda=.
2. *Primitive* → (aka subr, builtin function.) elisp function
   implemented in C. For example: {=list=, =car=, =append=, =point=, ,
   ...}. Typically the most fundamental ones.
3. *special form* → a function that doesn't eval in the normal way and
   implemented in C. For example: {=if=, =cond=, =and=, =or=, =while=,
   =progn=}. (normally, arguments to a function are all evaluated
   first.)
4. *macro* → Similar to “special form”, but defined by lisp expression,
   by =defmacro=. i.e. the arguments are not eval'd, and you can
   manipulate them and eval them.
5. *command* → functions that can be called by =command-execute=.
   Typically, =defun= with =interactive= clause. All functions you can
   call by “M-x” are commands.
6. *Function* → The catch all. Lambda expression, primitive, special
   form, macro, command, are all functions. And a function not any of
   the above is also a function. Usually created by =defun=.

Note: these are not classification of functions. Most of these are not
mutually exclusive. For example, =forward-word= is a command, but is
also a primitive (that is, implemented in C.), any special form by
definition is also a primitive.

These distinction of functions are useful because they help you
understand if arguments are evaluated in standard way or not (For
example, special form and macro do not.), and whether a function is
user-oriented (For example, command), and whether a function is a
primitive, it usually means it's fast and fundamental to elisp.

Note: there are more, but the above are the basics. For detail, see
[[../emacs_manual/elisp/What-Is-a-Function.html][(info "(elisp) What Is
a Function")]]

** Classification of Symbols in Emacs Lisp Manual
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In emacs lisp manual, each symbol has one of these indicator prefix:

| Kind               | Predicate          | Example                 |
|--------------------+--------------------+-------------------------|
| *Special Form*     | =special-form-p=   | =progn=                 |
| *Macro*            | =macrop=           | =when=                  |
| *Command*          | =commandp=         | =count-words=           |
| *Prefix Command*   | none               | =help-command=          |
| *Function*         | =functionp=        | =file-name-directory=   |
| *Constant*         | none               | dir-locals-file         |
| *User Option*      | none               | after-save-hook         |
| *Variable*         | =boundp=           | buffer-file-name        |

Note: there are only 1 Prefix Command in elisp manual: =help-command=

Note: there are only 2 constants in elisp manual: • dir-locals-file •
display-buffer-fallback-action

See also: [[file:elisp_symbol.html][Elisp: Lisp Symbol]]

** How to Check a Symbol's “type”
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's how to check if a symbol is which:

#+BEGIN_SRC emacs-lisp
    ;; check if a symbol is special form
    (special-form-p 'progn)       ; t

    ;; check if a symbol is macro
    (macrop 'when )               ; t

    ;; check if a symbol is command
    (commandp 'count-words )      ; t

    ;; check if a symbol is function (this includes special form and macro). In other words, the symbol is callable
    (functionp 'buffer-file-name) ; t

    ;; check if a symbol is variable
    (boundp 'buffer-file-name)    ; t
#+END_SRC

The following doesn't have predicate to check:

1. *Prefix Command*
2. *Constant*
3. *User Option*

Moust useful are =fboundp= and =boundp=.

=fboundp= → return true if a function is defined first. (that is,
symbol's function cell is not empty. [see
[[file:elisp_symbol.html][Elisp: Lisp Symbol]]] )

=boundp= → return true if a variable is defined. (That is, symbol's
value cell is not empty) [see [[file:elisp_check_defined.html][Elisp:
Check If a {function, variable, feature} is Defined/Loaded]]]

*** How to Check for Primitive
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Use =subrp= on a symbol's function cell to check if a function is a
primitive.

#+BEGIN_SRC emacs-lisp
    ;; check if a function is a elisp primitive; i.e. a elisp function written in C
    ;; arg to subrp must be a lisp object, not symbol

    ;; these are core lisp functions, implemented in C
    (subrp (symbol-function 'list))         ;t
    (subrp (symbol-function '+))            ;t

    ;; these are special forms, implemented in C
    (subrp (symbol-function 'while))        ;t
    (subrp (symbol-function 'save-excursion)) ;t

    ;; these are commands, implemented in C
    (subrp (symbol-function 'goto-char))    ;t
    (subrp (symbol-function 'beginning-of-line)) ;t
    (subrp (symbol-function 'forward-word)) ;t

    ;; lambda is a macro.
    (subrp (symbol-function 'lambda))       ;nil

    ;; Return a symbol's function cell value
    (symbol-function 'setq)                 ;#<subr setq>
#+END_SRC

*** Command vs Non-Command
    :PROPERTIES:
    :CLASS: calibre14
    :END:

For practical emacs lisp programing, the most important concept here is
“command”. Commands are basically =(defun …)= with =(interactive …)=
clause. Function defined without the “interactive” can only be called by
other elisp functions. The “interactive” function also provide many ways
to automatically feed arguments to your function when emacs user calls
your function. [see [[file:elisp_idioms_prompting_input.html][Elisp: Get
User Input]]] ([[../emacs_manual/elisp/Defining-Commands.html][(info
"(elisp) Defining Commands")]])

When looking for a function, Alt+x =apropos-command=, with
=universal-argument= 【Ctrl+u】 first. It'll then also list functions.
[see [[file:elisp_search_documentation.html][Elisp: Search
Documentation]]]

To search all symbols, Alt+x =apropos=.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_function_types.html]]

\\
\\
| [[../index_u7.html#article_54][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u16.html>>

| [[../article_56/index_u62.html][下一项]] |
[[../index_u7.html#article_55][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_54/index_u35.html][上一项]] |

--------------

* Elisp: Check If a {function, variable, feature} is Defined/Loaded
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-30. Last updated: 2015-04-29.

This page shows you how to check if a {function, variable} is defined,
or if a “feature” is loaded, and find out what Operating System your
emacs is running on.

*** Check Function
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Check if a function is defined.

#+BEGIN_SRC emacs-lisp
    ;; check if a function is defined
    (fboundp 'info)                         ; t
    (fboundp 'setq)                         ; t

    (fboundp 'xyz)                          ; nil
#+END_SRC

*** Check Variable
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Check if a variable is defined.

#+BEGIN_SRC emacs-lisp
    ;; check if a variable is defined
    (boundp 'auto-mode-alist)               ; t
    (boundp 'default-input-method)          ; t
    (boundp 'nil)                           ; t

    (boundp 'xyz)                           ; nil
#+END_SRC

The =fboundp= actually check a symbol's function cell. Similarly, the
=boundp= checks a symbol's value cell. [see
[[file:elisp_symbol.html][Emacs Lisp Symbol]]]

*** Check Feature
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Check if a “feature” is loaded.

#+BEGIN_SRC emacs-lisp
    ;; check if a “feature” (package) has been loaded
    (featurep 'ibuffer)
#+END_SRC

[see [[file:elisp_library_system.html][Elisp: load, load-file,
autoload]]]

See also: [[file:elisp_determine_OS_version.html][Elisp: Find/Determine
OS and Emacs Version]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_check_defined.html]]

\\
\\
| [[../index_u7.html#article_55][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u62.html>>

| [[../article_57/index_u37.html][下一项]] |
[[../index_u7.html#article_56][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_55/index_u16.html][上一项]] |

--------------

* Elisp: Print Date Time
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-11-29. Last updated: 2020-09-07.

This page shows you how to print current date time in various formats.

See also: [[file:elisp_parse_time.html][Elisp: Parse Date Time]].

For a ready-to-use command, see
[[../emacs/elisp_insert-date-time.html][Emacs: Insert Date Time]]

** Format yyyy-mm-dd
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (format-time-string "%Y-%m-%d")
    ;; "2018-09-10"
#+END_SRC

*** ISO 8601 Format
    :PROPERTIES:
    :CLASS: calibre14
    :END:

ISO 8601 format, example =2018-09-10T17:39:31-07:00=

#+BEGIN_SRC emacs-lisp
    (concat
     (format-time-string "%Y-%m-%dT%T")
     ((lambda (x) (concat (substring x 0 3) ":" (substring x 3 5)))
      (format-time-string "%z")))

    ;; sample output
    ;; 2018-09-10T17:39:31-07:00
#+END_SRC

** Unix Time Format
   :PROPERTIES:
   :CLASS: calibre17
   :END:

(number of seconds since 1970-01-01.)

#+BEGIN_SRC emacs-lisp
    ;; unix time
    (format-time-string "%s") ; "1291104066"
#+END_SRC

** Names for Month and Week
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; full month name
    (format-time-string "%B") ; "November"

    ;; abbreviated month name
    (format-time-string "%b") ; "Nov"
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; full week name
    (format-time-string "%A") ; "Tuesday"

    ;; abbreviated week name
    (format-time-string "%a") ; "Tue"
#+END_SRC

** Ordinal Date Format
   :PROPERTIES:
   :CLASS: calibre17
   :END:

=format-time-string= also supports ordinal date format. For example:

- “2010 January 1st” = “2010-001”
- “2010 December 31” = “2010-365”

#+BEGIN_SRC emacs-lisp
    (format-time-string "%Y-%j") ; "2010-334" for 2010-11-30
#+END_SRC

[[../emacs_manual/elisp/Time-Parsing.html][(info "(elisp) Time
Parsing")]]

[[../emacs_manual/elisp/Time-of-Day.html][(info "(elisp) Time of Day")]]

**** Datetime
     :PROPERTIES:
     :CLASS: calibre34
     :END:

- [[file:elisp_insert-date-time.html][Insert Date Time]]
- [[file:elisp_datetime_parser.html][xah-fix-datetime]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_u_xbk17u/g37n2cgs_plumber/feed_0/article_56/elisp_datetime.xhtml][Elisp:
  Print Date Time]]
- [[file:elisp_parse_time.html][Elisp: Parse Date Time]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_datetime.html]]

\\
\\
| [[../index_u7.html#article_56][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u37.html>>

| [[../article_58/index_u33.html][下一项]] |
[[../index_u7.html#article_57][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_56/index_u62.html][上一项]] |

--------------

* Elisp: Parse Date Time
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-09-02. Last updated: 2020-09-08.

This page shows you how to parse date time string.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a elisp function. The function will take a string argument that's
any of common date time format, example

- =2011-09-02T05:29:26-07:00= (ISO 8601)
- =2011-09-02= (ISO 8601)
- =Fri, 2 Sep 2011 11:14:11 +0200= (unixy)
- =09/02/2011= (USA)
- =Sep 2, 2011=
- =2 Sep, 2011=
- =2 September, 2011=

and output a canonical form =2011-09-02T11:14:11+0200=.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Two builtin lib to parse datetime:

- =parse-time-string=, from =parse-time.el=. =(require 'parse-time)=.
- =iso8601-parse=, from =iso8601.el=. =(require 'iso8601)=. (new in
  emacs 27)

=(parse-time-string STRING)= return a list like this:
=(SEC MIN HOUR DAY MON YEAR DOW DST TZ)=

- SEC is an integer or Lisp timestamp representing a nonnegative value
  less than 60 (or less than 61 if the operating system supports leap
  seconds).
- MIN is an integer between 0 and 59.
- HOUR is an integer between 0 and 23.
- DAY is an integer between 1 and 31.
- MONTH is an integer between 1 and 12.
- YEAR is the year number, an integer; 0 represents 1 BC.
- DOW is the day of week, an integer between 0 and 6, where 0 is Sunday.
- DST is t if daylight saving time is in effect, nil if it is not in
  effect, and -1 if daylight saving information is not available.
- TZ is an integer indicating the UTC offset in seconds, i.e., the
  number of seconds east of Greenwich.

any values that are unknown are returned as nil. in emacs 27, unknown
DST value is returned as -1.

=(iso8601-parse STRING &optional FORM)= return the same format.
=iso8601-parse= is designed for parsing ISO 1601 time formats.

*** Supported Formats of parse-time-string
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; testing what time formats parse-time-string supports
    ;; As of GNU Emacs 27.1 of 2020-08-11

    (require 'parse-time)

    ;; parse-time-string returns
    ;; (SEC MIN HOUR DAY MON YEAR DOW DST TZ)
    ;; if a element is nil or -1, it means unknown

    (parse-time-string "Date: Mon, 01 Aug 2011 12:24:51 -0400")
    ;; (51 24 12 1 8 2011 1 -1 -14400)
    ;; yes

    (parse-time-string "Local: Mon, Aug 1 2011 9:24 am")
    ;; (0 24 9 1 8 2011 1 -1 nil)
    ;; yes

    (parse-time-string "2007, August 1")
    ;; (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "August 1, 2007")
    ;; (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "august 1, 2007")
    ;; (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "August 1st, 2007")
    ;; (nil nil nil nil 8 2007 nil -1 nil)
    ;; no. The date is nil

    (parse-time-string "aug 1, 2007")
    (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "1 aug, 2007")
    ;; (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "8/1/2007")
    ;; (nil nil nil 8 nil 2001 nil -1 nil)
    ;; no. Takes the 8 as date, 1 as nil

    (parse-time-string "08/01/2007")
    ;; (nil nil nil 8 nil 2001 nil -1 nil)
    ;; no. Takes the 8 as date, 1 as nil

    (parse-time-string "8,1,2007")
    (nil nil nil 8 nil 2001 nil -1 nil)
    ;; no

    (parse-time-string "2007-08-01")
    ;; (nil nil nil 1 8 2007 nil -1 nil)
    ;; yes

    (parse-time-string "2007")
    ;; (nil nil nil nil nil 2007 nil -1 nil)
    ;; yes

    (parse-time-string "2007-08")
    ;; (nil nil nil nil nil nil nil -1 nil)
    ;; no

    (parse-time-string "2011-08-01T11:55:37-07:00")
    ;; (nil nil nil nil nil nil nil -1 nil)
    ;; no
#+END_SRC

** Datetime Parser Function
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_datetime_parser.html][Elisp: xah-fix-datetime]]

**** Datetime
     :PROPERTIES:
     :CLASS: calibre34
     :END:

- [[file:elisp_insert-date-time.html][Insert Date Time]]
- [[file:elisp_datetime_parser.html][xah-fix-datetime]]
- [[file:elisp_datetime.html][Elisp: Print Date Time]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_u_xbk17u/g37n2cgs_plumber/feed_0/article_57/elisp_parse_time.xhtml][Elisp:
  Parse Date Time]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_parse_time.html]]

\\
\\
| [[../index_u7.html#article_57][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u33.html>>

| [[../article_59/index_u32.html][下一项]] |
[[../index_u7.html#article_58][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_57/index_u37.html][上一项]] |

--------------

* Elisp: Function Optional Parameters
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-04-25. Last updated: 2016-09-01.

This page shows you how to define function with optional and rest
parameters.

** Optional Parameters
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs's function parameter's features and syntax is very basic. It is
simply a list of items. If you want optional parameters, just add
=&optional=. Any parameter after that will be optional.

#+BEGIN_SRC emacs-lisp
    ;; defining a function with 2 optional params named cc and dd

    (defun myfun (aa bb &optional cc dd)
      "test optional arguments"
      (insert aa bb cc dd)
      )

    ;; call it
    (myfun "1" "2" "3" "4")
#+END_SRC

When a optional parameter is not given, its value is =nil=.

If you want to give a argument to some optional parameters but not all,
use =nil= for those you don't care. For example, to call “myfun” in the
above with a argument for “dd” but you don't care for “cc”. Example:

#+BEGIN_SRC emacs-lisp
    ;; calling a function with 3rd parameter omitted
    (myfun "myaa" "mybb" nil "mydd")
#+END_SRC

If a function received a =nil= as argument for one of its optional
parameter, there is no way for a function to know if it is specified by
user or omitted.

** Unspecified Number of Parameters (Rest Args)
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can have a function that takes unspecified any number of arguments.

Examples of builtin functions that takes rest arg include: { =+=,
=message=, =insert= =concat= }.

To specify unspecified number of parameters, add =&rest name= after the
last argument. The value of name will be a list, or =nil= if none given.

#+BEGIN_SRC emacs-lisp
    ;; defining a function with rest args

    (defun ff (aa bb &rest cc)
      "test rest arguments"
      (message "%s" cc) ; cc is a list
      )

    ;; test
    (ff "1" "2" "3" "4")
    ;; ("3" "4")
#+END_SRC

You can have both =&optional= and =&rest=, in that order.

[[../emacs_manual/elisp/Argument-List.html][(info "(elisp) Argument
List")]]

** No Named Parameter
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Emacs lisp *does not support named parameter*, nor any sort of parameter
type checking.

There's also no optional parameter with default values.

You can define your function to take a association list as argument to
emulate these features. [see [[file:elisp_association_list.html][Elisp:
Association List]]]

** Optional Parameter in Documentation
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Doc string of a function also show optional parameters the same way. For
example, Alt+x =describe-function= then give =search-forward=, and the
output is:

#+BEGIN_QUOTE
  #+BEGIN_SRC emacs-lisp
      …
      (search-forward string &optional bound noerror count)
      …
  #+END_SRC
#+END_QUOTE

This means the function takes 4 arguments, and the last 3 is optional.

Same in the elisp doc. For example, Alt+x =elisp-index-search= , then
=search-forward=. It shows:

#+BEGIN_QUOTE
  #+BEGIN_SRC emacs-lisp
       -- Command: search-forward string &optional limit noerror repeat
           This function searches forward from point for an exact match for
           STRING.  If successful, it sets point to the end of the occurrence
           found, and returns the new value of point.  If no match is found,
           the value and side effects depend on NOERROR (see below).
  #+END_SRC
#+END_QUOTE

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_optional_params.html]]

\\
\\
| [[../index_u7.html#article_58][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u32.html>>

| [[../article_60/index_u41.html][下一项]] |
[[../index_u7.html#article_59][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_58/index_u33.html][上一项]] |

--------------

* Elisp: Regex Tutorial
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2014-09-26. Last updated: 2019-09-07.

This page is a tutorial on using regex in emacs lisp code.

[[file:feed_0/article_59/images/img1_u2.png]]

emacs lisp regex toothpick syndrome

** Regex Syntax
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If you are not familiar with emacs regex syntax, first see:

[[file:emacs_regex.html][Emacs: Regex Tutorial]]

** Test Regex in Elisp Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

One simple way to test regex is to create a file with the following
content:

#+BEGIN_SRC emacs-lisp
    (re-search-forward "yourRegex")

    whatever text to search here
#+END_SRC

Then, put your cursor to the right of the closing parenthesis, then
Alt+x =eval-last-sexp= 【Ctrl+x Ctrl+e】. If your regex matches, it'll
move cursor to the last char of the matched text. If you get a lisp
error saying search failed, then your regex didn't match. If you get a
lisp syntax error, then you probably screwed up on the backslashs.

** Newline Character and Tab
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Inside elisp string, =\t= is TAB char (Unicode codepoint 9), and =\n= is
newline. You can use =[\t\n ]+= for sequence of {tab, newline, space}.

When a file is opened in Emacs, newline is always =\n=, regardless
whether your file is from {Unix, Windows, Mac}. Do NOT manually do find
replace on newline chars for changing file newline convention. [see
[[file:emacs_line_ending_char.html][Emacs: Newline Representations ^M ^J
^L]]]

** Double Backslash in Lisp Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Regex string in emacs lisp needs to have lots double backslash.

First of all, remember these:

- ="\n"= → newline. Only 1 backslash.
- ="\t"= → tab. Only 1 backslash.
- ="\""= → literal double quote

then, any other backslash needs to double.

Example,

this =\( a.d\)= for capturing group for words like “and”, “add”, “aid”.

becomes ="\\( a.d\\)"=

And, literal interpretation instead of regex (such as square bracket),
you need double backslashs in front, because double backslashs in string
represents 1 backslash.

Example:

To match any lowercase English letter, do ="[a-z]"=

But to match square bracket literally, you need: ="\\[citation\\]"=

Here's bigger example, suppose you have this text:

#+BEGIN_SRC emacs-lisp
    <img src="cat.jpg" alt="my cat" width="795" height="183" />
#+END_SRC

When you call a command such as =list-matching-lines= , you can type the
regex in the prompt. Example:

#+BEGIN_SRC emacs-lisp
    <img src="\([^"]+?\)" alt="\([^"]+?\)" width="\([0-9]+\)" height="\([0-9]+\)" />
#+END_SRC

But in lisp code, the same regex needs to have many backslash escapes,
like this:

#+BEGIN_SRC emacs-lisp
    (re-search-forward
    "<img src=\"\\([^\"]+?\\)\" alt=\"\\([^\"]+?\\)\" width=\"\\([0-9]+\\)\" height=\"\\([0-9]+\\)\" />" )
#+END_SRC

[[../emacs_manual/elisp/Regular-Expressions.html][(info "(elisp) Regular
Expressions")]]

** Use emacs to Convert Regex to Elisp Regex String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

There is a easy way to get the backslashes right.

1. First, Alt+x =list-matching-lines= to do what you want.
2. Immediately call =repeat-complex-command=. The elisp regex syntax
   will be shown in minibuffer. (with all correct backslashes if needed)

[[file:feed_0/article_59/images/img2_u2.png]]

Alt+x =list-matching-lines= , followed by Alt+x =repeat-complex-command=

** Unicode Representation in String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_unicode_representation_in_string.html][Elisp: Unicode
Escape Sequence]]

** Find Replace Text
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_find_replace_text.html][Elisp: Find Replace String in
Buffer]]

** Regex in Elisp Syntax: rx Package
   :PROPERTIES:
   :CLASS: calibre17
   :END:

There is a elisp package rx that uses lisp style syntax to represent
regex syntax.

#+BEGIN_SRC emacs-lisp
    (require 'rx)

    ;; this
    (rx (one-or-more blank) line-end)

    ;; returns this
    ;; "[[:blank:]]+$"
#+END_SRC

I do not recommend it. Because it's a middleman. Just learn and use raw
regex directly.

** Regex and Syntax Table
   :PROPERTIES:
   :CLASS: calibre17
   :END:

*Warning*: the meaning of a character class in emacs is dependent on the
current major mode's syntax table. For example, what chars are
considered “word” in =[[:word:]]= depends on how its defined in syntax
table of current major mode.

For a example showing the difference, see:
[[file:elisp_regex_and_syntax_table.html][Elisp: Regex Patterns and
Syntax Table]]

Syntax table is hard to work with, and regex using it may be
unpredictable. Best is just to put the chars you want explicitly in your
regex, for example, =[A-Za-z]=.

** Elisp Regex Video Tutorial
   :PROPERTIES:
   :CLASS: calibre17
   :END:

unicode inverted text, emacs regex and in emacs lisp 2019-09-06

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_regex.html]]

\\
\\
| [[../index_u7.html#article_59][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u41.html>>

| [[../article_61/index_u39.html][下一项]] |
[[../index_u7.html#article_60][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_59/index_u32.html][上一项]] |

--------------

* Elisp: Doc String Markup
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-01-13. Last updated: 2017-01-05.

This page shows emacs function/command's doc string convention and
markup.

[[file:feed_0/article_60/images/img1.png]]

emacs =describe-function= screen. (note the clickable links.)

When you lookup a function's doc by Alt+x =describe-function= 【Ctrl+h
f】, you'll notice these features:

- function's parameters are italicized.
- mention of other function's name can be clicked to jump to.
- URL can be clicked to jump to web browser.
- keyboard shortcuts will show correctly even if user have changed it.

To have these features, you need to put markups in your inline string.

Here's a summary:

- =ALLCAPS= → function argument.
- =`sort-lines'= → link to other function.
- =URL `http://example.org/'= → link to URL.
- =Info node `(emacs) Dired'= → link to Info doc node.
- =\\[find-file]= → keybinding of a command
- =\\<c-mode-map>= → No visible effect. Tell emacs to use this keymap
  for displaying keys in the rest of this doc string.
- =\\{c-mode-map}= → list of keybindings of a given keymap.

Example:

#+BEGIN_SRC emacs-lisp
    (defun something (arg1 arg2)
      "no more than 67 chars summary here.

    detail. Mention return value. No indentation.

    • ARG1 is…. Parameters should be all caps.

    • See URL `http://example.com/' (clickable url)

    • See `dired' (clickable function/variable name)

    • See `(emacs) Dired'. (link to info doc)

    • Type \\[dired] to go into dired. (key of a command.)

    • clickable list of all keys of a given keymap name.
    \\{c-mode-map}"
      (interactive)
      (message "%s" "do something.")
      )
#+END_SRC

The following are details of each case.

** Short Summary in First Line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The first line of your doc string should be a one sentence summary of
the function. Because, =apropos-command= 【Ctrl+h a】 will display just
that line.

The first line should be no more than 67 characters.

The doc string should be formatted into lines each about 70 chars,
instead of one long line of hundreds chars. (you can use
=fill-paragraph= for this.)

** Italized Parameter Names
   :PROPERTIES:
   :CLASS: calibre17
   :END:

When your function takes arguments, their names in the inline string
should be all CAPS. Example:

#+BEGIN_SRC emacs-lisp
    (defun read-lines (file-path)
      "Return a list of lines of a file at FILE-PATH."
      (with-temp-buffer
        (insert-file-contents file)
        (split-string (buffer-string) "\n" t)))
#+END_SRC

This way, when =describe-function= displays it, the arg will be
automatically italized.

** Clickable Function/Variable Names
   :PROPERTIES:
   :CLASS: calibre17
   :END:

If your doc mentions another function, user can click on it, so it takes
them to that function's doc string. To make it clickable, you need to
quote it with =`…'=. Example:

#+BEGIN_SRC emacs-lisp
    (defun auto-fill-mode (&optional arg)
      "Toggle Auto Fill mode.
    With ARG, turn Auto Fill mode on if and only if ARG is positive.
    In Auto Fill mode, inserting a space at a column beyond `current-fill-column'
    automatically breaks the line at a previous space.

    The value of `normal-auto-fill-function' specifies the function to use
    for `auto-fill-function' when turning Auto Fill mode on."
      ;…
        ))
#+END_SRC

Some elisp names are both function and variable. (For example,
=linum-mode=). In that case, if you want emacs to link to the function,
precede it with the word “function” or any of the word {variable,
option, command}. Example:

#+BEGIN_SRC emacs-lisp
    (defun my-linum-numbering-mode ()
      "…

    See also: command `linum-mode' and variable `linum-mode'"
      ;; …
        )
#+END_SRC

** Clickable URL
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To have a clickable URL, do like this: =URL `http://example.org/'=.
Example:

#+BEGIN_SRC emacs-lisp
    (defun xlsl-mode ()
      "See URL `http://xahsl.org/sl/ls-emacs.html'."
    )
#+END_SRC

** Links to Emacs Info Doc
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Sometimes you want clickable links to emacs's doc. You can mark it like
this: =Info node `(elisp)Font Lock Basics'=.

#+BEGIN_SRC emacs-lisp
    (defun xx ()
      "See Info node `(emacs) Dired'."
      )
#+END_SRC

Remember, each page in info doc is identified by a string, for examples:
=(emacs) Dired=, =(elisp)Font Lock Basics=. The first part in paren is
the doc name, followed by the node's name. When you are in info page,
pressing c will copy this node's id to the kill-ring.

But also note, emacs's info node may change or disappear with new emacs
versions. [see [[file:emacs_manual_persistent_nodes.html][Emacs Manual
Node Persistency Issues]]]

** Auto Generate Shortcut Keys
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In your doc string you may need to tell users about pressing a keyboard
shortcut to do something. For example, in =dired=, when you Alt+x
=describe-mode=, the doc says: “Type C to Copy files.”. If a user has
customized dired's keys, the doc string will correctly display the new
key.

To make the key of a command automatically show correctly, you need to
quote the command name by =\\[command_name]=. Here's a example from
=dired=:

#+BEGIN_SRC emacs-lisp
    (defun dired-mode (&optional dirname switches)
      "\
    Mode for \"editing\" directory listings.
    …
    Type \\[dired-do-copy] to Copy files.
    …"
    )
#+END_SRC

Sometimes the command you mentioned may have different keys in your mode
or in global mode. You can be specific by including =\\<key_map_name>=
before =\\[command_name]=.

The =\\<key_map_name>= won't be displayed, it just tells emacs what
keymap to use for processing the rest of doc string. Example:

#+BEGIN_SRC emacs-lisp
    (defun dired-mode (&optional dirname switches)
      "…

    You can move using the usual cursor motion commands.\\<dired-mode-map>
    The buffer is read-only.  Digits are prefix arguments.
    Type \\[dired-flag-file-deletion] to flag a file `D' for deletion.
    Type \\[dired-mark] to Mark a file or subdirectory for later commands.
    …"
    )
#+END_SRC

** Auto Generated Keybinding List
   :PROPERTIES:
   :CLASS: calibre17
   :END:

A major mode usually has its own set of keyboard shortcuts (its own
keymap). For example, in =c-mode=, Alt+x =describe-mode=, you'll see
this:

#+BEGIN_QUOTE
  #+BEGIN_SRC emacs-lisp
      Key bindings:
      key             binding
      ---             -------

      C-c             Prefix Command
      C-d             c-electric-delete-forward
      TAB             c-indent-line-or-region
      …
  #+END_SRC
#+END_QUOTE

This is automatically generated. You just need to quote the keymap name
by =\\{…}=. By convention, you put it at the end of your major mode's
documentation. Example:

#+BEGIN_SRC emacs-lisp
    (defun c-mode ()
      "Major mode for editing K&R and ANSI C code.
    To submit a problem report, enter `\\[c-submit-bug-report]' from a
    c-mode buffer.  This automatically sets up a mail buffer with version
    information already added.  You just need to add a description of the
    problem, including a reproducible test case, and send the message.

    To see what version of CC Mode you are running, enter `\\[c-version]'.

    The hook `c-mode-common-hook' is run with no args at mode
    initialization, then `c-mode-hook'.

    Key bindings:
    \\{c-mode-map}"
    ;…
    )
#+END_SRC

** Reference
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- [[../emacs_manual/elisp/Documentation-Tips.html][(info
  "(elisp)Documentation Tips")]]
- [[../emacs_manual/elisp/Keys-in-Documentation.html][(info "(elisp)
  Keys in Documentation")]]

2014-05-27 thanks to [[http://irreal.org/blog/?p=2715][jcs]] for tips.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/inline_doc.html]]

\\
\\
| [[../index_u7.html#article_60][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |

<<index_u39.html>>

| [[../../feed_1/index.html][下一项]] |
[[../index_u7.html#article_61][段落菜单]] |
[[../../index_u43.html#feed_0][主菜单]] |
[[../article_60/index_u41.html][上一项]] |

--------------

* Elisp: Unicode Escape Sequence
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2014-01-04. Last updated: 2016-09-01.

In emacs lisp string, you can have Unicode characters directly (For
example, ="I ♥ 😸"=), or, you can represent Unicode char by the following
syntax:

- ="\uxxxx"= → A Unicode char. xxxx must be 4 hexadecimal digits,
  representing the char's codepoint in hex. You need to pad it with 0 if
  the codepoint is less than 4 hex digits.
- ="\U00xxxxxx"= → A Unicode char. xxxxxx must be 6 hexadecimal digits,
  representing the char's codepoint in hex. You need to pad it with 0 if
  the codepoint is less than 6 hex digits.

Note: the syntax is a bit ugly. Which one to use depends on whether the
Unicode is in the range of 0 to 4 hex digits. (Each Unicode char is
given a integer id, called its “codepoint”. [see
[[file:unicode_basics.html][Unicode Basics]]])

#+BEGIN_SRC emacs-lisp
    ;; examples of Unicode char representation in string

    ;; lower case “a”
    (search-forward "\u0061" )

    ;; ♥ BLACK HEART SUIT codepoint 9829, #x2665
    (search-forward "\u2665" )

    ;; 😸 GRINNING CAT FACE WITH SMILING EYES codepoint 128568, #x1f638
    (search-forward "\U0001f638" )

    ;; ♥ 😸
#+END_SRC

in the above example, the letter a's Unicode hex is just “61”, so you
need to pad it with “00”.

in the above example, the grinning cat 😸's codepoint in hex is 5 digits.
So, you need to use the ="\U00xxxxxx"= form, and because it's less than
6 digits, so you need to pad it with “0”, resulting “000” there.

Note: you can find a Unicode char's codepoint by Alt+x =describe-char=.

[see [[file:emacs_n_unicode.html][Emacs: Unicode Tutorial]]]

** Why is Encoded Unicode Char Useful?

The use of encoded representation is useful when you want to represent
non-printable chars, such as {RIGHT-TO-LEFT MARK, ZERO WIDTH NO-BREAK
SPACE, NO-BREAK SPACE}. Example:

#+BEGIN_SRC emacs-lisp
    (defun replace-BOM-mark-etc ()
      "Query replace some invisible Unicode chars.
    The chars to be searched are:
     RIGHT-TO-LEFT MARK 8207 x200f
     ZERO WIDTH NO-BREAK SPACE 65279 xfeff

    start on cursor position to end."
      (interactive)
      (query-replace-regexp "\u200f\\|\ufeff" ""))
#+END_SRC

[[../emacs_manual/elisp/General-Escape-Syntax.html][(info "(elisp)
General Escape Syntax")]]

* Practical Emacs Tutorial
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2005-12-30. Last updated: 2020.

the church of emacs filling,\\
of chars lispy and binding,\\
buffers insert yank,\\
meta sexp add-hook,\\
Eight M-bites And C. Swapping.\\

[[file:emacs_logo.html][[[file:feed_0/article_0/emacs_logo/emacs_logo.svg]]]]

This tutorial is designed for writers, scientists, engineers, to get
started on emacs quickly. Each page teaches you something practical you
can use right away. No emacs jargons. No need programing experience.

Start at\\
[[file:which_emacs.html][Download Emacs for Windows, Mac, Linux]]

Those marked with a rocket ship 🚀 means it's a enhanced, efficient
command. They are part of [[../misc/ergoemacs_vi_mode.html][Emacs: Xah
Fly Keys]]

*** About This Tutorial
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[file:feed_0/article_0/i/learning_gnu_emacs.png]]
[[file:feed_0/article_0/images/img1.jpg]]

emacs books from 1990s.

If you were to spend 3 months reading 3 emacs books, it is more
efficient to just read Xah Emacs Tutorial for just 1 month. Xah tutorial
focus on actually using emacs in practice, and on efficiency of using
emacs, as well as efficiency of learning.

- This tutorial skips the emacs parts that are rarely used. Every single
  one thousand emacs C-x commands are looked, the practical ones are
  presented to you.
- The writing style is concrete, and example based. No story telling, no
  joke, just what you need to know to use emacs in the most efficient
  way.
- This tutorial does not force emacs jargons and emacs hacker methods.
  If you are new to emacs, you will understand it. If you are old time
  hacker, you will improve your efficiency of using emacs.
- This tutorial covers emacs lisp, more extensive than any existing
  emacs lisp book (except the elisp manual) or elisp tutorial online. A
  little elisp makes you a far better emacs user and understanding
  emacs. [see [[file:elisp.html][Practical Emacs Lisp]]]
- There are more examples and elisp code in Xah Emacs Tutorial than all
  existing emacs books or web sites combined. You do not need to read it
  all, but any time spent reading this tutorial, you'll learn more
  useful things than same amount of time spent elsewhere.

The author lives in emacs since 1999. And has been obsessively writing
emacs tutorial since 2006.

** Buy Xah Emacs Tutorial
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Buy my tutorial to support the site.

[[file:buy_xah_emacs_tutorial.html][[[file:feed_0/article_0/images/img2.jpg]]\\
Buy Xah Emacs Tutorial]]

** What Do People Say?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:user_comments.html][Testimonial on Xah Emacs Tutorial]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs.html]]

\\
\\
| [[../index_u13.html#article_0][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u8.html>>

| [[../article_2/index_u2.html][下一项]] |
[[../index_u13.html#article_1][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_0/index_u30.html][上一项]] |

--------------

* Emacs Init Setup
  :PROPERTIES:
  :CLASS: calibre9
  :END:

This sections shows you how to customize emacs by editing the init file.

Start at [[file:emacs_make_modern.html][Emacs: Init File Tutorial]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_init_index.html]]

\\
\\
| [[../index_u13.html#article_1][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u2.html>>

| [[../article_3/index_u40.html][下一项]] |
[[../index_u13.html#article_2][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_1/index_u8.html][上一项]] |

--------------

* Emacs Keys
  :PROPERTIES:
  :CLASS: calibre9
  :END:

The essence of using emacs is commands and keys.

This section shows you how to customize emacs keys. Start at\\
[[file:keyboard_shortcuts.html][Emacs: How to Define Keys]]

or watch a video:

dvorak colemak minimak layouts, ergodox, keyboard firmware, keybinding,
ergodox, programable keypads 2019-09-20

[[file:feed_0/article_2/images/img1_u1.jpg]]

“Emacs user at work”. (by
[[http://earlcolour.deviantart.com/][earlcolour.deviantart.com]])

\\

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_keys_index.html]]

\\
\\
| [[../index_u13.html#article_2][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u40.html>>

| [[../article_4/index_u29.html][下一项]] |
[[../index_u13.html#article_3][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_2/index_u2.html][上一项]] |

--------------

* Practical Emacs Lisp
  :PROPERTIES:
  :CLASS: calibre9
  :END:

[[file:lisp_logo.html][[[file:feed_0/article_3/images/img1.svg]]]]

[[file:buy_xah_emacs_tutorial.html][[[file:feed_0/article_3/i/spell_striker_79774-s250x250.jpg]]\\
Buy Xah Emacs Tutorial]]

Emacs is possible because of the embedded programing language emacs
lisp. Learning a bit emacs lisp will increase your understanding of
emacs by a lot.

This is a example based tutorial on emacs lisp, with focus on how-to.

Start at\\
[[file:elisp_basics.html][Emacs Lisp Basics]]

or watch a video:

Xah Lee Live Stream. emacs lisp for beginner.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp.html]]

\\
\\
| [[../index_u13.html#article_3][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u29.html>>

| [[../article_5/index.html][下一项]] |
[[../index_u13.html#article_4][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_3/index_u40.html][上一项]] |

--------------

* Emacs Lisp Examples
  :PROPERTIES:
  :CLASS: calibre9
  :END:

This section is collection of simple emacs lisp examples. They are great
for studying elisp but also as practical useful commands.

Start at:\\
[[file:elisp_title_case_text.html][Emacs: Change to Title Case]]

Note, you can also use other programing language and call them in emacs.
see [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands Using
Python, Ruby, ...]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_command_examples_index.html]]

\\
\\
| [[../index_u13.html#article_4][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u9.html>>

| [[../article_8/index.html][下一项]] |
[[../index_u13.html#article_7][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_6/index.html][上一项]] |

--------------

* Emacs: Change to Title Case
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-11-06. Last updated: 2017-01-11.

Here's emacs command to change letter case by title convention.

For example, “A Tale of Two Cities”, not “A Tale Of Two Cities”.

#+BEGIN_SRC emacs-lisp
    (defun xah-title-case-region-or-line (@begin @end)
      "Title case text between nearest brackets, or current line, or text selection.
    Capitalize first letter of each word, except words like {to, of, the, a, in, or, and, …}. If a word already contains cap letters such as HTTP, URL, they are left as is.

    When called in a elisp program, *begin *end are region boundaries.
    URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (let (
               $p1
               $p2
               ($skipChars "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕"))
           (progn
             (skip-chars-backward $skipChars (line-beginning-position))
             (setq $p1 (point))
             (skip-chars-forward $skipChars (line-end-position))
             (setq $p2 (point)))
           (list $p1 $p2))))
      (let* (
             ($strPairs [
                         [" A " " a "]
                         [" And " " and "]
                         [" At " " at "]
                         [" As " " as "]
                         [" By " " by "]
                         [" Be " " be "]
                         [" Into " " into "]
                         [" In " " in "]
                         [" Is " " is "]
                         [" It " " it "]
                         [" For " " for "]
                         [" Of " " of "]
                         [" Or " " or "]
                         [" On " " on "]
                         [" Via " " via "]
                         [" The " " the "]
                         [" That " " that "]
                         [" To " " to "]
                         [" Vs " " vs "]
                         [" With " " with "]
                         [" From " " from "]
                         ["'S " "'s "]
                         ["'T " "'t "]
                         ]))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (upcase-initials-region (point-min) (point-max))
            (let ((case-fold-search nil))
              (mapc
               (lambda ($x)
                 (goto-char (point-min))
                 (while
                     (search-forward (aref $x 0) nil t)
                   (replace-match (aref $x 1) "FIXEDCASE" "LITERAL")))
               $strPairs))))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_title_case_text.html]]

\\
\\
| [[../index_u13.html#article_7][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u26.html>>

| [[../article_11/index_u42.html][下一项]] |
[[../index_u13.html#article_10][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_9/index.html][上一项]] |

--------------

* Emacs: Escape Quotes Command
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-08-16. Last updated: 2017-01-11.

This page shows a emacs command to escape/unescape quotes.

For example,

#+BEGIN_SRC emacs-lisp
    "xyz"
#+END_SRC

becomes

#+BEGIN_SRC emacs-lisp
    \"xyz\"
#+END_SRC

This is very useful when coding lisp to process other languages.

For example, when you have this =x = "…"=, and you want
=(search-forward "x = \"…\"") =

Here's the code.

#+BEGIN_SRC emacs-lisp
    (defun xah-escape-quotes (@begin @end)
      "Replace 「\"」 by 「\\\"」 in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (goto-char (point-min))
            (while (search-forward "\"" nil t)
              (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-unescape-quotes (@begin @end)
      "Replace  「\\\"」 by 「\"」 in current line or text selection.
    See also: `xah-escape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (save-excursion
        (save-restriction
          (narrow-to-region @begin @end)
          (goto-char (point-min))
          (while (search-forward "\\\"" nil t)
            (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+END_SRC

You can assign keys to them. [see [[file:keyboard_shortcuts.html][Emacs:
How to Define Keys]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_escape_quotes.html]]

\\
\\
| [[../index_u13.html#article_10][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u42.html>>

| [[../article_12/index_u7.html][下一项]] |
[[../index_u13.html#article_11][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_10/index_u26.html][上一项]] |

--------------

* Emacs: Remove Accent Marks
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-03-07. Last updated: 2018-11-12.

Here's a emacs command that removes accent marks, or, convert some
Unicode characters into ASCII. (aka Zap Gremlins)

For example:

- “café” ⇒ “cafe”
- “naïve” ⇒ “naive”

#+BEGIN_SRC emacs-lisp
    (defun xah-asciify-text (&optional @begin @end)
      "Remove accents in some letters and some
    Change European language characters into equivalent ASCII ones, e.g. “café” ⇒ “cafe”.
    When called interactively, work on current line or text selection.

    URL `http://ergoemacs.org/emacs/emacs_zap_gremlins.html'
    Version 2018-11-12"
      (interactive)
      (let (($charMap
             [
              ["ß" "ss"]
              ["á\\|à\\|â\\|ä\\|ā\\|ǎ\\|ã\\|å\\|ą\\|ă\\|ạ\\|ả\\|ả\\|ấ\\|ầ\\|ẩ\\|ẫ\\|ậ\\|ắ\\|ằ\\|ẳ\\|ặ" "a"]
              ["æ" "ae"]
              ["ç\\|č\\|ć" "c"]
              ["é\\|è\\|ê\\|ë\\|ē\\|ě\\|ę\\|ẹ\\|ẻ\\|ẽ\\|ế\\|ề\\|ể\\|ễ\\|ệ" "e"]
              ["í\\|ì\\|î\\|ï\\|ī\\|ǐ\\|ỉ\\|ị" "i"]
              ["ñ\\|ň\\|ń" "n"]
              ["ó\\|ò\\|ô\\|ö\\|õ\\|ǒ\\|ø\\|ō\\|ồ\\|ơ\\|ọ\\|ỏ\\|ố\\|ổ\\|ỗ\\|ộ\\|ớ\\|ờ\\|ở\\|ợ" "o"]
              ["ú\\|ù\\|û\\|ü\\|ū\\|ũ\\|ư\\|ụ\\|ủ\\|ứ\\|ừ\\|ử\\|ữ\\|ự"     "u"]
              ["ý\\|ÿ\\|ỳ\\|ỷ\\|ỹ"     "y"]
              ["þ" "th"]
              ["ď\\|ð\\|đ" "d"]
              ["ĩ" "i"]
              ["ľ\\|ĺ\\|ł" "l"]
              ["ř\\|ŕ" "r"]
              ["š\\|ś" "s"]
              ["ť" "t"]
              ["ž\\|ź\\|ż" "z"]
              [" " " "]       ; thin space etc
              ["–" "-"]       ; dash
              ["—\\|一" "--"] ; em dash etc
              ])
            $begin $end
            )
        (if (null @begin)
            (if (use-region-p)
                (setq $begin (region-beginning) $end (region-end))
              (setq $begin (line-beginning-position) $end (line-end-position)))
          (setq $begin @begin $end @end))
        (let ((case-fold-search t))
          (save-restriction
            (narrow-to-region $begin $end)
            (mapc
             (lambda ($pair)
               (goto-char (point-min))
               (while (search-forward-regexp (elt $pair 0) (point-max) t)
                 (replace-match (elt $pair 1))))
             $charMap)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-asciify-string (@string)
      "Returns a new string. European language chars are changed ot ASCII ones e.g. “café” ⇒ “cafe”.
    See `xah-asciify-text'
    Version 2015-06-08"
      (with-temp-buffer
          (insert @string)
          (xah-asciify-text (point-min) (point-max))
          (buffer-string)))
#+END_SRC

[see [[http://wordyenglish.com/musing/diacritics.html][Accent Marks:
Trema, Umlaut, Macron, Circumflex]]]

(2015-06-08 thanks to robert_nagy for adding chars)

** Accumulator vs Parallel Programing
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This problem makes a good parallel programing exercise. See:
[[http://xahlee.info/comp/parallel_programing_exercise_asciify-string.html][Parallel
Programing Exercise: asciify-string]].

** Alternative Solution with “iconv” or perl
   :PROPERTIES:
   :CLASS: calibre17
   :END:

2011-03-08

Yuri Khan and Teemu Likonen suggested using the “iconv” shell command.
See =man iconv=. Here's Teemu's code.

#+BEGIN_SRC emacs-lisp
    (defun asciify-string (string)
    "Convert STRING to ASCII string.
    For example:
    “passé” becomes “passe”"
    ;; Code originally by Teemu Likonen
      (with-temp-buffer
        (insert string)
        (call-process-region (point-min) (point-max) "iconv" t t nil "--to-code=ASCII//TRANSLIT")
        (buffer-substring-no-properties (point-min) (point-max))))
#+END_SRC

Julian Bradfield suggested Perl. Here's his one-liner, it removes chars
with accent marks.

#+BEGIN_SRC emacs-lisp
    perl -e 'use encoding utf8; use Unicode::Normalize; while ( <> ) { $_ = NFKD($_); s/\pM//g; print; }'
#+END_SRC

[[http://groups.google.com/group/comp.emacs/msg/8d58b6e9b2bd07fd]]

Though, it would be nice to have a pure elisp solution, because “iconv”
is not in Windows or Mac OS X as of 2011-03-08.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_zap_gremlins.html]]

\\
\\
| [[../index_u13.html#article_11][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u7.html>>

| [[../article_13/index_u33.html][下一项]] |
[[../index_u13.html#article_12][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_11/index_u42.html][上一项]] |

--------------

* Emacs: Convert Straight/Curly Quotes
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2015-04-29. Last updated: 2018-03-02.

Here's a command to convert straight quote to curly quotes.

#+BEGIN_SRC emacs-lisp
    (defun xah-replace-straight-quotes (@begin @end)
      "Replace straight double quotes to curly ones, and others.
    Works on current text block or selection.

    Examples of changes:
     「\"…\"」 → 「“…”」
     「...」 → 「…」
     「I’m」 → 「I'm」
     「--」 → 「—」
     「~=」 → 「≈」

    When called in lisp code, @begin and @end are region begin/end positions.

    WARNING: this command does not guarantee 100% correct conversion of quotes, because it impossible. You should double check highlighted places after.

    URL `http://ergoemacs.org/emacs/elisp_straight_curly_quotes.html'
    Version 2018-03-02"
      ;; some examples for debug
      ;; do "‘em all -- done..."
      ;; I’am not
      ;; said "can’t have it, can’t, just can’t"
      ;; ‘I’ve can’t’
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (let ($p1 $p2)
           (save-excursion
             (if (re-search-backward "\n[ \t]*\n" nil "move")
                 (progn (re-search-forward "\n[ \t]*\n")
                        (setq $p1 (point)))
               (setq $p1 (point)))
             (if (re-search-forward "\n[ \t]*\n" nil "move")
                 (progn (re-search-backward "\n[ \t]*\n")
                        (setq $p2 (point)))
               (setq $p2 (point))))
           (list $p1 $p2))))

      (let ( (case-fold-search nil))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end )
            ;; Note: order is important since this is huristic.
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ;; dash and ellipsis etc
              ["--" " — "]
              ["—" " — "]
              ["..." "…"]
              [" & " " ＆ "]
              [" :)" " ☺"]
              [" :(" " ☹"]
              [" ;)" " 😉"]
              ["~=" "≈"]
              [" --> " " ⟶ "]
              [" , " ", "]
              ;; fix GNU style ASCII quotes
              ["``" "“"]
              ["''" "”"]
              ;; double straight quote → double curly quotes
              ["\n\"" "\n“"]
              [">\"" ">“"]
              ["(\"" "(“"]
              [" \"" " “"]
              ["\" " "” "]

              ["\", " "”, "]
              ["\",\n" "”,\n"]

              ["\". " "”. "]
              ["\".\n" "”.\n"]
              ["\"?" "”?"]
              ["\";" "”;"]
              ["\":" "”:"]
              ["\")" "”)"]
              ["\"]" "”]"]

              ;; ["\"[" "\”["]

              [".\"" ".”"]
              [",\"" ",”"]
              ["!\"" "!”"]
              ["?\"" "?”"]
              ["\"<" "”<"]
              ["\"\n" "”\n"]
              ] "REPORT" "HILIGHT")

            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ["  —  " " — "] ; rid of extra space in em-dash
              ] "REPORT" "HILIGHT")

            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              [" —-> " " ⟶ "]
              [" <= " " ≤ "]
              [" >= " " ≥ "]
              ] "REPORT" "HILIGHT")

            ;; fix straight double quotes by regex
            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["\\`\"" "“"]
              ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

            ;; fix single quotes to curly
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              [">\'" ">‘"]
              [" \'" " ‘"]
              ["\' " "’ "]
              ["\'," "’,"]
              [".\'" ".’"]
              ["!\'" "!’"]
              ["?\'" "?’"]
              ["(\'" "(‘"]
              ["\')" "’)"]
              ["\']" "’]"]
              ] "REPORT" "HILIGHT")

            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["\\bcan’t\\b" "can't"]
              ["\\bdon’t\\b" "don't"]
              ["\\bdoesn’t\\b" "doesn't"]
              ["\\bwon’t\\b" "won't"]
              ["\\bisn’t\\b" "isn't"]
              ["\\baren’t\\b" "aren't"]
              ["\\bain’t\\b" "ain't"]
              ["\\bdidn’t\\b" "didn't"]
              ["\\baren’t\\b" "aren't"]
              ["\\bwasn’t\\b" "wasn't"]
              ["\\bweren’t\\b" "weren't"]
              ["\\bcouldn’t\\b" "couldn't"]
              ["\\bshouldn’t\\b" "shouldn't"]

              ["\\b’ve\\b" "'ve"]
              ["\\b’re\\b" "'re"]
              ["\\b‘em\\b" "'em"]
              ["\\b’ll\\b" "'ll"]
              ["\\b’m\\b" "'m"]
              ["\\b’d\\b" "'d"]
              ["\\b’s\\b" "'s"]
              ["s’ " "s' "]
              ["s’\n" "s'\n"]

              ["\"$" "”"]
              ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

            ;; fix back escaped quotes in code
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ["\\”" "\\\""]
              ["\\”" "\\\""]
              ] "REPORT" "HILIGHT")

            ;; fix back. quotes in HTML code
            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["” \\([-a-z]+\\)="       "\" \\1="] ; any 「” some-thing=」
              ["=”" "=\""]
              ["/” " "/\" "]
              ["\\([0-9]+\\)” "     "\\1\" "]
              ] "FIXEDCASE" nil "HILIGHT"
             )

            ))))
#+END_SRC

You need the elisp library
[[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_straight_curly_quotes.html]]

\\
\\
| [[../index_u13.html#article_12][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u33.html>>

| [[../article_14/index_u22.html][下一项]] |
[[../index_u13.html#article_13][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_12/index_u7.html][上一项]] |

--------------

* Emacs: Convert Full-Width/Half-Width Punctuations
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-10. Last updated: 2018-08-02.

This page shows commands to convert to/from Full-Width/Half-Width
characters. (全角 半角 转换)

If you type Chinese or Japanese mixed with English, then often you'll
have mixed Asian/Western punctuations, and is hard to fix manually.

- . ↔ 。 (U+3002: IDEOGRAPHIC FULL STOP)
- , ↔ ， (U+FF0C: FULLWIDTH COMMA)
- ? ↔ ？ (U+FF1F: FULLWIDTH QUESTION MARK)
- ; ↔ ； (U+FF1B: FULLWIDTH SEMICOLON)

[see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
Full-Width Characters]]]

** Convert English Chinese Punctuation
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-convert-english-chinese-punctuation (@begin @end &optional @to-direction)
      "Convert punctuation from/to English/Chinese characters.

    When called interactively, do current line or selection. The conversion direction is automatically determined.

    If `universal-argument' is called, ask user for change direction.

    When called in lisp code, *begin *end are region begin/end positions. *to-direction must be any of the following values: 「\"chinese\"」, 「\"english\"」, 「\"auto\"」.

    See also: `xah-remove-punctuation-trailing-redundant-space'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    Version 2015-10-05"
      (interactive
       (let ($p1 $p2)
         (if (use-region-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (progn
             (setq $p1 (line-beginning-position))
             (setq $p2 (line-end-position))))
         (list
          $p1
          $p2
          (if current-prefix-arg
              (ido-completing-read
               "Change to: "
               '( "english"  "chinese")
               "PREDICATE"
               "REQUIRE-MATCH")
            "auto"
            ))))
      (let (
            ($input-str (buffer-substring-no-properties @begin @end))
            ($replacePairs
             [
              [". " "。"]
              [".\n" "。\n"]
              [", " "，"]
              [",\n" "，\n"]
              [": " "："]
              ["; " "；"]
              ["? " "？"] ; no space after
              ["! " "！"]

              ;; for inside HTML
              [".</" "。</"]
              ["?</" "？</"]
              [":</" "：</"]
              [" " "　"]
              ]
             ))

        (when (string= @to-direction "auto")
          (setq
           @to-direction
           (if
               (or
                (string-match "　" $input-str)
                (string-match "。" $input-str)
                (string-match "，" $input-str)
                (string-match "？" $input-str)
                (string-match "！" $input-str))
               "english"
             "chinese")))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (mapc
             (lambda ($x)
               (progn
                 (goto-char (point-min))
                 (while (search-forward (aref $x 0) nil "noerror")
                   (replace-match (aref $x 1)))))
             (cond
              ((string= @to-direction "chinese") $replacePairs)
              ((string= @to-direction "english") (mapcar (lambda (x) (vector (elt x 1) (elt x 0))) $replacePairs))
              (t (user-error "Your 3rd argument 「%s」 isn't valid" @to-direction))))))))
#+END_SRC

** Remove Punctuation Trailing Redundant Spaces
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's helpful command to remove redundant spaces after punctuation.

- In English text, the convention is to have 1 space after punctuation
  (sometimes 2, after the Full Stop sign).
- In Chinese text, the convention is to have no space after punctuation.

#+BEGIN_SRC emacs-lisp
    (defun xah-remove-punctuation-trailing-redundant-space (@begin @end)
      "Remove redundant whitespace after punctuation.
    Works on current line or text selection.

    When called in emacs lisp code, the *begin *end are cursor positions for region.

    See also `xah-convert-english-chinese-punctuation'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    version 2015-08-22"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (require 'xah-replace-pairs)
      (xah-replace-regexp-pairs-region
       @begin @end
       [
        ;; clean up. Remove extra space.
        [" +," ","]
        [",  +" ", "]
        ["?  +" "? "]
        ["!  +" "! "]
        ["\\.  +" ". "]

        ;; fullwidth punctuations
        ["， +" "，"]
        ["。 +" "。"]
        ["： +" "："]
        ["？ +" "？"]
        ["； +" "；"]
        ["！ +" "！"]
        ["、 +" "、"]
        ]
       "FIXEDCASE" "LITERAL"))
#+END_SRC

These commands are useful for Twitter too, for saving a few character in
Twitter's character limit. Because, English punctuation takes 2 char
each, while Chinese version needs just one char, the space is included
in the punctuation symbol.

** Convert Half-Width Full-Width Characters
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This command convert all English letters and digits and punctuations,
from/to half-width and full-width.

[see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
Full-Width Characters]]]

#+BEGIN_SRC emacs-lisp
    (defun xah-convert-fullwidth-chars (@begin @end &optional @to-direction)
      "Convert ASCII chars to/from Unicode fullwidth version.
    Works on current line or text selection.

    The conversion direction is determined like this: if the command has been repeated, then toggle. Else, always do to-Unicode direction.

    If `universal-argument' is called first:

     no C-u → Automatic.
     C-u → to ASCII
     C-u 1 → to ASCII
     C-u 2 → to Unicode

    When called in lisp code, @begin @end are region begin/end positions. @to-direction must be any of the following values: 「\"unicode\"」, 「\"ascii\"」, 「\"auto\"」.

    See also: `xah-remove-punctuation-trailing-redundant-space'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    Version 2018-08-02"
      (interactive
       (let ($p1 $p2)
         (if (use-region-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (progn
             (setq $p1 (line-beginning-position))
             (setq $p2 (line-end-position))))
         (list $p1 $p2
               (cond
                ((equal current-prefix-arg nil) "auto")
                ((equal current-prefix-arg '(4)) "ascii")
                ((equal current-prefix-arg 1) "ascii")
                ((equal current-prefix-arg 2) "unicode")
                (t "unicode")))))
      (let* (
             ($ascii-unicode-map
              [
               ["0" "０"] ["1" "１"] ["2" "２"] ["3" "３"] ["4" "４"] ["5" "５"] ["6" "６"] ["7" "７"] ["8" "８"] ["9" "９"]
               ["A" "Ａ"] ["B" "Ｂ"] ["C" "Ｃ"] ["D" "Ｄ"] ["E" "Ｅ"] ["F" "Ｆ"] ["G" "Ｇ"] ["H" "Ｈ"] ["I" "Ｉ"] ["J" "Ｊ"] ["K" "Ｋ"] ["L" "Ｌ"] ["M" "Ｍ"] ["N" "Ｎ"] ["O" "Ｏ"] ["P" "Ｐ"] ["Q" "Ｑ"] ["R" "Ｒ"] ["S" "Ｓ"] ["T" "Ｔ"] ["U" "Ｕ"] ["V" "Ｖ"] ["W" "Ｗ"] ["X" "Ｘ"] ["Y" "Ｙ"] ["Z" "Ｚ"]
               ["a" "ａ"] ["b" "ｂ"] ["c" "ｃ"] ["d" "ｄ"] ["e" "ｅ"] ["f" "ｆ"] ["g" "ｇ"] ["h" "ｈ"] ["i" "ｉ"] ["j" "ｊ"] ["k" "ｋ"] ["l" "ｌ"] ["m" "ｍ"] ["n" "ｎ"] ["o" "ｏ"] ["p" "ｐ"] ["q" "ｑ"] ["r" "ｒ"] ["s" "ｓ"] ["t" "ｔ"] ["u" "ｕ"] ["v" "ｖ"] ["w" "ｗ"] ["x" "ｘ"] ["y" "ｙ"] ["z" "ｚ"]
               ["," "，"] ["." "．"] [":" "："] [";" "；"] ["!" "！"] ["?" "？"] ["\"" "＂"] ["'" "＇"] ["`" "｀"] ["^" "＾"] ["~" "～"] ["¯" "￣"] ["_" "＿"]
               [" " "　"]
               ["&" "＆"] ["@" "＠"] ["#" "＃"] ["%" "％"] ["+" "＋"] ["-" "－"] ["*" "＊"] ["=" "＝"] ["<" "＜"] [">" "＞"] ["(" "（"] [")" "）"] ["[" "［"] ["]" "］"] ["{" "｛"] ["}" "｝"] ["(" "｟"] [")" "｠"] ["|" "｜"] ["¦" "￤"] ["/" "／"] ["\\" "＼"] ["¬" "￢"] ["$" "＄"] ["£" "￡"] ["¢" "￠"] ["₩" "￦"] ["¥" "￥"]
               ]
              )
             ($reverse-map
              (mapcar
               (lambda (x) (vector (elt x 1) (elt x 0)))
               $ascii-unicode-map))

             ($stateBefore
              (if (get 'xah-convert-fullwidth-chars 'state)
                  (get 'xah-convert-fullwidth-chars 'state)
                (progn
                  (put 'xah-convert-fullwidth-chars 'state 0)
                  0
                  )))
             ($stateAfter (if (eq $stateBefore 0) 1 0 )))

      ;"０\\|１\\|２\\|３\\|４\\|５\\|６\\|７\\|８\\|９\\|Ａ\\|Ｂ\\|Ｃ\\|Ｄ\\|Ｅ\\|Ｆ\\|Ｇ\\|Ｈ\\|Ｉ\\|Ｊ\\|Ｋ\\|Ｌ\\|Ｍ\\|Ｎ\\|Ｏ\\|Ｐ\\|Ｑ\\|Ｒ\\|Ｓ\\|Ｔ\\|Ｕ\\|Ｖ\\|Ｗ\\|Ｘ\\|Ｙ\\|Ｚ\\|ａ\\|ｂ\\|ｃ\\|ｄ\\|ｅ\\|ｆ\\|ｇ\\|ｈ\\|ｉ\\|ｊ\\|ｋ\\|ｌ\\|ｍ\\|ｎ\\|ｏ\\|ｐ\\|ｑ\\|ｒ\\|ｓ\\|ｔ\\|ｕ\\|ｖ\\|ｗ\\|ｘ\\|ｙ\\|ｚ"

        ;; (message "before %s" $stateBefore)
        ;; (message "after %s" $stateAfter)
        ;; (message "@to-direction %s" @to-direction)
        ;; (message "real-this-command  %s" real-this-command)
        ;; (message "real-last-command %s" real-last-command)
        ;; (message "this-command  %s" this-command)
        ;; (message "last-command %s" last-command)

        (let ((case-fold-search nil))
          (xah-replace-pairs-region
           @begin @end
           (cond
            ((string= @to-direction "unicode") $ascii-unicode-map)
            ((string= @to-direction "ascii") $reverse-map)
            ((string= @to-direction "auto")
             (if (eq $stateBefore 0)
                 $reverse-map
               $ascii-unicode-map )

             ;; 2018-08-02 this doesn't work when using smex
             ;; (if (eq last-command this-command)
             ;;     (progn
             ;;       (message "%s" "repeated")
             ;;       (if (eq $stateBefore 0)
             ;;           $reverse-map
             ;;         $ascii-unicode-map ))
             ;;   (progn
             ;;     (message "%s" "not repeated")
             ;;     $ascii-unicode-map))

             ;;

             )
            (t (user-error "Your 3rd argument 「%s」 isn't valid" @to-direction)))
           t t ))
        (put 'xah-convert-fullwidth-chars 'state $stateAfter)))
#+END_SRC

**** Emacs Chinese Topics
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[file:elisp_chinese_char_linkify.html][Elisp: Chinese Char To
  Reference Link]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_13/elisp_convert_chinese_punctuation.xhtml][Emacs:
  Convert Full-Width/Half-Width Punctuations]]
- [[file:emacs_chinese_input.html][Emacs Chinese Input]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html]]

\\
\\
| [[../index_u13.html#article_13][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u22.html>>

| [[../article_15/index_u16.html][下一项]] |
[[../index_u13.html#article_14][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_13/index_u33.html][上一项]] |

--------------

* Elisp: Convert Color Formats: RGB, HSL, HSV
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2013-05-27. Last updated: 2017-04-15.

The color package =color.el=, in emacs 24.1, lets you convert colors
from various models and formats. For example: RGB, HSL, HSV, named color
values, and things like finding the color complement.

This page shows you:

- How to use =color.el=.
- Command to convert color format under cursor.

** Convert RGB to HSL
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert RGB color to HSL.
    ;; all input and output are in the range {0, 1}

    (require 'color )

    (color-rgb-to-hsl 1 0 0) ; ⇒  (0.0 1 0.5) red

    (color-rgb-to-hsl 0 1 0) ; ⇒ (0.3333333333333333 1 0.5) green

    (color-rgb-to-hsl 0 0 1) ; ⇒ (0.6666666666666666 1 0.5) blue

    (color-rgb-to-hsl 1 1 1) ; ⇒ (0.0 0.0 1.0) white

    (color-rgb-to-hsl 0 0 0) ; ⇒ (0.0 0.0 0.0) black
#+END_SRC

Note that if you are converting from hex valued RGB format such as
=#aabbcc=, you must first convert the hex to integer, then re-scale from
{0 to 255} based range to {0 to 1} based range, then feed that to
=color-rgb-to-hsl=.

For explanation of the HSL color model, see:
[[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]

** Convert HSL to RGB
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert HSL color to RGB.
    ;; all input and output are in the range {0 to 1}

    (require 'color )

    (color-hsl-to-rgb 0 1 .5) ; (1.0 0.0 0.0) red

    (color-hsl-to-rgb .3 1 .5) ; ⇒ (0.19999999999999996 1.0 0.0) greenish

    (color-hsl-to-rgb .6 1 .5) ; ⇒ (0.0 0.3999999999999999 1.0) blueish

    (color-hsl-to-rgb 0 0 1) ; ⇒ (1 1 1) white

    (color-hsl-to-rgb 0 0 0) ; ⇒ (0 0 0) black
#+END_SRC

** Convert RGB Hexadecimal Format to Emacs Lisp Vector Format
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-css-convert-color-hex-to-vec (@rrggbb)
      "Convert color *rrggbb from “\"rrggbb\"” string to a elisp vector [r g b], where the values are from 0 to 1.
    Example:
     (xah-css-convert-color-hex-to-vec \"00ffcc\") ⇒ [0.0 1.0 0.8]

    Note: The input string must NOT start with “#”.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (vector
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 0 2) 16) 255)
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 2 4) 16) 255)
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 4) 16) 255)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-css-normalize-number-scale (@val @range-max)
      "Scale *val from range [0, *range-max] to [0, 1]
    The arguments can be int or float.
    Return value is float.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (/ (float @val) (float @range-max)))
#+END_SRC

** Command to Convert RGB Color to HSL
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a command that convert between CSS's RGB hexadecimal format to
HSL format. For example, =#ffefd5= → =hsl(37,100%,91%)=

It works on the word under cursor.

#+BEGIN_SRC emacs-lisp
    (defun xah-css-hex-color-to-hsl ()
      "Convert color spec under cursor from “#rrggbb” to CSS HSL format.
     e.g. #ffefd5 ⇒ hsl(37,100%,91%)
    URL `http://ergoemacs.org/emacs/elisp_convert_rgb_hsl_color.html'
    Version 2016-07-19"
      (interactive)
      (let* (
             ($bds (bounds-of-thing-at-point 'word))
             ($p1 (car $bds))
             ($p2 (cdr $bds))
             ($currentWord (buffer-substring-no-properties $p1 $p2)))
        (if (string-match "[a-fA-F0-9]\\{6\\}" $currentWord)
            (progn
              (delete-region $p1 $p2 )
              (when (equal (char-before) 35) ; 35 is #
                (delete-char -1))
              (insert (xah-css-hex-to-hsl-color $currentWord )))
          (progn
            (user-error "The current word 「%s」 is not of the form #rrggbb." $currentWord)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-css-hex-to-hsl-color (@hex-str)
      "Convert *hex-str color to CSS HSL format.
    Return a string. Example:  \"ffefd5\" ⇒ \"hsl(37,100%,91%)\"
    Note: The input string must NOT start with “#”.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (let* (
             ($colorVec (xah-css-convert-color-hex-to-vec @hex-str))
             ($R (elt $colorVec 0))
             ($G (elt $colorVec 1))
             ($B (elt $colorVec 2))
             ($hsl (color-rgb-to-hsl $R $G $B))
             ($H (elt $hsl 0))
             ($S (elt $hsl 1))
             ($L (elt $hsl 2)))
        (format "hsl(%d,%d%%,%d%%)" (* $H 360) (* $S 100) (* $L 100))))
#+END_SRC

The code is from [[file:xah-css-mode.html][Emacs: Xah CSS Mode]].

=color.el= is written by Julien Danjou
[[[https://julien.danjou.info/blog/]] ] , Drew Adams
[[[http://www.emacswiki.org/emacs/DrewAdams]] ] Thanks guys.

- [[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]
- [[file:emacs_CSS_colors.html][Emacs: Working with CSS Color Values]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_convert_rgb_hsl_color.html]]

\\
\\
| [[../index_u13.html#article_14][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u16.html>>

| [[../article_16/index_u31.html][下一项]] |
[[../index_u13.html#article_15][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_14/index_u22.html][上一项]] |

--------------

* Elisp: Convert Decimal/Hexadecimal
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-10-03. Last updated: 2020-02-17.

Here's several ways to convert between Hexadecimal to Decimal in emacs.

** Using calc
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- Alt+x =calc=.
- Type any number. For example, 10.
- Type “d6” to turn the display into hexadecimal form.
- Type “d0” to turn the display into decimal form.

To type a hex number, type =#=, then type “16#aa” for the hex “aa”.

** Using Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's how to convert decimal to hexadecimal:

#+BEGIN_SRC emacs-lisp
    ;; decimal to hex. Returns 「a」
    (format "%x" 10)
#+END_SRC

Here's how to convert hexadecimal to decimal:

#+BEGIN_SRC emacs-lisp
    ;; hex 「a」 to decimal. Returns 「10」.
    (format "%d" #xa)
#+END_SRC

Select the code, then Alt+x =eval-region=.

[see [[file:elisp_eval_lisp_code.html][Emacs: Evaluate Elisp Code]]]

** Emacs Lisp Command
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a elisp command that prints the decimal value of a hexadecimal
string under cursor.

#+BEGIN_SRC emacs-lisp
    (defun xah-show-hexadecimal-value ()
      "Prints the decimal value of a hexadecimal string under cursor.

    Samples of valid input:

      ffff → 65535
      0xffff → 65535
      #xffff → 65535
      FFFF → 65535
      0xFFFF → 65535
      #xFFFF → 65535

    more test cases
      64*0xc8+#x12c 190*0x1f4+#x258
      100 200 300   400 500 600

    URL `http://ergoemacs.org/emacs/elisp_converting_hex_decimal.html'
    Version 2020-02-17"
      (interactive )
      (let ($inputStr $tempStr $p1 $p2 )
        (if (region-active-p)
            (progn
              (setq $p1 (region-beginning))
              (setq $p2 (region-end)))
          (progn
            (save-excursion
              (skip-chars-backward "0123456789abcdefABCDEF#x")
              (setq $p1 (point))
              (skip-chars-forward "0123456789abcdefABCDEF#x" )
              (setq $p2 (point)))))
        (setq $inputStr (buffer-substring-no-properties $p1 $p2))
        (let ((case-fold-search nil))
          (setq $tempStr (replace-regexp-in-string "\\`0x" "" $inputStr )) ; C, Perl, …
          (setq $tempStr (replace-regexp-in-string "\\`#x" "" $tempStr )) ; elisp …
          (setq $tempStr (replace-regexp-in-string "\\`#" "" $tempStr )) ; CSS …
          )
        (message "input 「%s」, Hex 「%s」 is 「%d」" $inputStr $tempStr (string-to-number $tempStr 16))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_converting_hex_decimal.html]]

\\
\\
| [[../index_u13.html#article_15][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u31.html>>

| [[../article_17/index_u24.html][下一项]] |
[[../index_u13.html#article_16][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_15/index_u16.html][上一项]] |

--------------

* Emacs: Replace Greek Letter Names to Unicode
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-10-05.

[[file:feed_0/article_16/images/img1_u4.png]]

Here's a command to convert Greek to unicode symbols.

#+BEGIN_SRC emacs-lisp
    (require 'xah-replace-pairs)

    (defun xah-replace-greek-letter-name-to-symbol (@begin @end)
      "Replace alpha to α, beta to β etc in current line or selection.

    URL `http://ergoemacs.org/emacs/elisp_replace_greeks_to_symbols.html'
    Version 2016-10-05"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (let ((case-fold-search nil))
        (xah-replace-pairs-region
         @begin
         @end
         '(
           ["Alpha" "Α"]
           ["Beta" "Β"]
           ["Gamma" "Γ"]
           ["Delta" "Δ"]
           ["Epsilon" "Ε"]
           ["Zeta" "Ζ"]
           ["Eta" "Η"]
           ["Theta" "Θ"]
           ["Iota" "Ι"]
           ["Kappa" "Κ"]
           ["Lambda" "Λ"]
           ["Mu" "Μ"]
           ["Nu" "Ν"]
           ["Xi" "Ξ"]
           ["Omicron" "Ο"]
           ["Pi" "Π"]
           ["Rho" "Ρ"]
           ["Sigma" "Σ"]
           ["Tau" "Τ"]
           ["Upsilon" "Υ"]
           ["Phi" "Φ"]
           ["Chi" "Χ"]
           ["Psi" "Ψ"]
           ["Omega" "Ω"]

           ["alpha" "α"]
           ["beta" "β"]
           ["gamma" "γ"]
           ["delta" "δ"]
           ["epsilon" "ε"]
           ["zeta" "ζ"]
           ["eta" "η"]
           ["theta" "θ"]
           ["iota" "ι"]
           ["kappa" "κ"]
           ["lambda" "λ"]
           ["mu" "μ"]
           ["nu" "ν"]
           ["xi" "ξ"]
           ["omicron" "ο"]
           ["pi" "π"]
           ["rho" "ρ"]
           ["sigmaf" "ς"]
           ["sigma" "σ"]
           ["tau" "τ"]
           ["upsilon" "υ"]
           ["phi" "φ"]
           ["chi" "χ"]
           ["psi" "ψ"]
           ["omega" "ω"]
           ["thetasym" "ϑ"]
           ["upsih" "ϒ"]
           ["piv" "ϖ"]
           ) 'REPORT 'HILIGHT )))
#+END_SRC

You need the elisp library
[[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_replace_greeks_to_symbols.html]]

\\
\\
| [[../index_u13.html#article_16][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u24.html>>

| [[../article_18/index_u14.html][下一项]] |
[[../index_u13.html#article_17][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_16/index_u31.html][上一项]] |

--------------

* Elisp: Twitterfy
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2015-02-04. Last updated: 2019-01-16.

Here's a emacs lisp command that shortens text to fit twitter's 140
chars.

#+BEGIN_SRC emacs-lisp
    (defun xah-twitterfy ()
      "Shorten words for Twitter 280 char limit on current line or selection.

    If `universal-argument' is called first, ask for conversion direction (shorten/lenthen).

    Note: calling this function twice in opposite direction does not necessarily return the origial, because the map is not one-to-one.

    URL `http://ergoemacs.org/emacs/elisp_twitterfy.html'
    Version 2019-01-16"
      (interactive)
      (let (
            $p1 $p2
            $direction

            ($shorten-map
             [
              ["\\bare\\b" "r"]
              ["\\byou\\b" "u"]
              ["e.g. " "eg "]
              ["\bto\b" "2"]
              [" your" " ur "]
              ["\\band\\b" "＆"]
              ["because" "∵"]
              ["therefore " "∴"]
              [" at " " @ "]
              [" love " " ♥ "]
              [" one " " 1 "]
              [" two " " 2 "]
              [" three " " 3 "]
              [" four " " 4 "]
              [" zero " " 0 "]
              ["hexadecimal " "hex "]
              ["Emacs: " "#emacs "]
              ["JavaScript: " "#JavaScript "]
              ["Python: " "#python "]
              ["Ruby: " "#ruby "]
              ["Perl: " "#perl "]
              ["Emacs Lisp: " "#emacs #lisp "]
              ["Elisp: " "#emacs #lisp "]
              [", " "，"]
              ["\\.\\.\\." "…"]
              ["\\. " "。"]
              ["\\? " "？"]
              [": " "："]
              ["! " "！"]]
             )
            ($lengeth-map
             [
              ["\\bu\\b" "you"]
              ["\\br\\b" "are"]
              ["eg " "e.g. "]
              [" 2 " " to "]
              ["\\bur\\b" "your"]
              ["\\b＆\\b" "and"]
              ["\\bcuz\\b" "because"]
              ["\\b∴\\b" "therefore "]
              [" @ " " at "]
              [" ♥ " " love "]
              [" 1 " " one "]
              [" 2 " " two "]
              [" 3 " " three "]
              [" 4 " " four "]
              [" 0 " " zero "]
              ["hex " "hexadecimal "]
              ["，" ", "]
              ["…" "..."]
              ["。" ". "]
              ["？" "? "]
              ["：" ": "]
              ["！" "! "]
              ]
             ))
        (if (region-active-p)
            (setq $p1 (region-beginning) $p2 (region-end))
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn
                  (setq $p1 (point))
                  (re-search-forward "\n[ \t]*\n"))
              (setq $p1 (point)))
            (progn
              (re-search-forward "\n[ \t]*\n" nil "move")
              (setq $p2 (point)))))
        (setq $direction
              (if current-prefix-arg
                  (ido-completing-read
                   "Direction: "
                   '( "shorten"  "lengthen")
                   "PREDICATE"
                   "REQUIRE-MATCH")
                "auto"
                ))
        (save-restriction
          (narrow-to-region $p1 $p2)
          (when (string= $direction "auto")
            (goto-char (point-min))
            (setq $direction
                  (if (re-search-forward "。\\|，\\|？\\|！" nil t)
                      "lengthen" "shorten"
                      )))
          (let ( (case-fold-search nil))
            (mapc
             (lambda ($x)
               (goto-char (point-min))
               (while (re-search-forward (elt $x 0) nil t)
                 (replace-match (elt $x 1) "FIXEDCASE" "LITERAL")))
             (if (string= $direction "shorten")
                 $shorten-map
               $lengeth-map))
            (goto-char (point-min))
            (while (re-search-forward "  +" nil t)
              (replace-match " " "FIXEDCASE" "LITERAL")))
          (goto-char (+ (point-min) 280)))))
#+END_SRC

2019-01-16 am still refining this command. So you may see some bad code
here.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_twitterfy.html]]

\\
\\
| [[../index_u13.html#article_17][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u14.html>>

| [[../article_19/index_u5.html][下一项]] |
[[../index_u13.html#article_18][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_17/index_u24.html][上一项]] |

--------------

* Elisp: xah-fix-datetime
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2020-09-08.

Here's a command that fix datetime under cursor into yyyy-mm-dd format.

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-datetime (@begin @end)
      "Change timestamp under cursor into a yyyy-mm-dd format.
    If there's a text selection, use that as input, else use current line.
    Replace the text in selection or current line.

    Any “day of week”, or “time” info, or any other parts of the string, are discarded.
    For example:
     TUESDAY, FEB 15, 2011 05:16 ET → 2011-02-15
     November 28, 1994              → 1994-11-28
     Nov. 28, 1994                  → 1994-11-28
     11/28/1994                     → 1994-11-28
     1994/11/28                     → 1994-11-28

    URL `http://ergoemacs.org/emacs/elisp_datetime_parser.html'
    Version 2020-09-08"
      (interactive
       (list
        (if (region-active-p) (region-beginning))
        (if (region-active-p) (region-end))))
      (require 'parse-time)
      (let ($p1 $p2 $in)
        (if @begin
            (setq $p1 @begin $p2 @end)
          (setq $p1 (line-beginning-position) $p2 (line-end-position)))
        (setq $in (replace-regexp-in-string "^ *\\(.+\\) *$" "\\1" (buffer-substring-no-properties $p1 $p2)))
      ; remove white spaces

        (setq $in
              (cond

               ;; yyyy/mm/dd
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))

               ;; mm/dd/yyyy
               ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9][0-9][0-9]\\)" $in)
                (concat (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
               ;; m/dd/yyyy
               ((string-match "\\([0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9][0-9][0-9]\\)" $in)
                (concat (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

               ;; USA convention of mm/dd/yy
               ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (format-time-string "%C") (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
               ;; USA convention of m/dd/yy
               ((string-match "\\([0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (format-time-string "%C") (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

               ;; some ISO 8601. yyyy-mm-ddThh:mm
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)T[0-9][0-9]:[0-9][0-9]" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
               ;; some ISO 8601. yyyy-mm-dd
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
               ;; some ISO 8601. yyyy-mm
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in)))

               ;; else
               (t
                (progn
                  (setq $in (replace-regexp-in-string "January " "Jan. " $in))
                  (setq $in (replace-regexp-in-string "February " "Feb. " $in))
                  (setq $in (replace-regexp-in-string "March " "Mar. " $in))
                  (setq $in (replace-regexp-in-string "April " "Apr. " $in))
                  (setq $in (replace-regexp-in-string "May " "May. " $in))
                  (setq $in (replace-regexp-in-string "June " "Jun. " $in))
                  (setq $in (replace-regexp-in-string "July " "Jul. " $in))
                  (setq $in (replace-regexp-in-string "August " "Aug. " $in))
                  (setq $in (replace-regexp-in-string "September " "Sep. " $in))
                  (setq $in (replace-regexp-in-string "October " "Oct. " $in))
                  (setq $in (replace-regexp-in-string "November " "Nov. " $in))
                  (setq $in (replace-regexp-in-string "December " "Dec. " $in))

                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)st" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)nd" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)rd" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]\\)th" "\\1" $in))

                  (let ($dateList $year $month $date $yyyy $mm $dd )
                    (setq $dateList (parse-time-string $in))
                    (setq $year (nth 5 $dateList))
                    (setq $month (nth 4 $dateList))
                    (setq $date (nth 3 $dateList))

                    (setq $yyyy (number-to-string $year))
                    (setq $mm (if $month (format "%02d" $month) "" ))
                    (setq $dd (if $date (format "%02d" $date) "" ))
                    (concat $yyyy "-" $mm "-" $dd))))))
        (delete-region $p1 $p2 )
        (insert $in)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-datetime-string (@datetime)
      "Return a new string of @datetime in yyyy-mm-dd format.
    Other datetime info such as hours, minutes, time zone, are discarded. This function calls `xah-fix-datetime' to do work.

    URL `http://ergoemacs.org/emacs/elisp_datetime_parser.html'
    Version 2020-09-08"
      (with-temp-buffer
        (insert @datetime)
        (xah-fix-datetime (point-min) (point-max))
        (buffer-substring-no-properties (point-min) (point-max))))
#+END_SRC

The whole code is just one giant conditional test.

#+BEGIN_SRC emacs-lisp
    (cond
     (TEST2 BODY)
     (TEST2 BODY)
     …
     )
#+END_SRC

In the code, the first few tests are regex match of forms like
=nn/nn/nnnn= where each “n” is a digit. When any of these match, then
basically i got what i want, and the code exits.

When none of these match, then it goes to the end of the test
=(t BODY)=, where the “t” there is always true, and run a big chunk of
BODY. In the BODY, first i replace each full spelling of month names by
their abbrev using =replace-regexp-in-string=, example

#+BEGIN_SRC emacs-lisp
    (setq $str (replace-regexp-in-string "January " "Jan. " $str))
#+END_SRC

This is done because in emacs 22 the =parse-time-string= doesn't
understand fully spelled month names. (this has been fixed in 23.2.1 or
earlier.)

Then, i also replace {1st, 2nd, nth} etc by {1, 2, n}, because emacs's
=parse-time-string= doesn't understand those. Then, i simply feed it to
=parse-time-string= and get a parsed date time as a list. After that,
just extract the elements from the list and reformat the way i want
using =format=.

**** Datetime
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[file:elisp_insert-date-time.html][Insert Date Time]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_18/elisp_datetime_parser.xhtml][xah-fix-datetime]]
- [[file:elisp_datetime.html][Elisp: Print Date Time]]
- [[file:elisp_parse_time.html][Elisp: Parse Date Time]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_datetime_parser.html]]

\\
\\
| [[../index_u13.html#article_18][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u5.html>>

| [[../article_20/index_u38.html][下一项]] |
[[../index_u13.html#article_19][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_18/index_u14.html][上一项]] |

--------------

* Elisp: Count Lines, Words, Chars
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-23. Last updated: 2015-11-29.

A little emacs lisp exercise. Writing command to count words.

In emacs 23, there's =count-lines=, but no command to count words or
characters. (=count-words= is now built-in in in emacs 24. [see
[[file:emacs24_features.html][Emacs 24.1 Features (released 2012-06)]]])

Here's how to write it.

#+BEGIN_SRC emacs-lisp
    (defun my-count-words-region (posBegin posEnd)
      "Print number of words and chars in region."
      (interactive "r")
      (message "Counting …")
      (save-excursion
        (let (wordCount charCount)
          (setq wordCount 0)
          (setq charCount (- posEnd posBegin))
          (goto-char posBegin)
          (while (and (< (point) posEnd)
                      (re-search-forward "\\w+\\W*" posEnd t))
            (setq wordCount (1+ wordCount)))

          (message "Words: %d. Chars: %d." wordCount charCount)
          )))
#+END_SRC

** How It Works
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The function has this skeleton:

#+BEGIN_SRC emacs-lisp
    (defun my-count-words-region (pos1 pos2)
      "…"
      (interactive "r")
      ; …
      )
#+END_SRC

the =(interactive "r")= means emacs will automatically fill your dummy
variables {pos1, pos2} by region beginning/end positions. (region
positions are integers) [see [[file:emacs_region.html][Elisp: Region,
Active Region]]] [see [[file:elisp_interactive_form.html][Elisp:
Interactive Form]]]

The next part of the function is this:

#+BEGIN_SRC emacs-lisp
    (save-excursion
     (let (var1 var2 …))
     (setq var1 …)
     (setq var2 …)
     …
    )
#+END_SRC

The =let= is lisp's way to have a block of local variables.

The =(save-excursion …)= will run its body, then restore the cursor
position and mark position. We need it because in the code we are going
to move cursor around. When the command is finished, the cursor will be
placed back to the position when user started the command.

Now, to count the char, it is just the length of the beginning and
ending position of the region. So, it is simple, like this:

#+BEGIN_SRC emacs-lisp
    (setq charCount (- posEnd posBegin))
#+END_SRC

Now, we move the char to beginning of region, like this:
=(goto-char posBegin)=. The next part, count the words, like this:

#+BEGIN_SRC emacs-lisp
    (while (and (< (point) posEnd)
                      (re-search-forward "\\w+\\W*" posEnd t))
            (setq wordCount (1+ wordCount)))
#+END_SRC

The =(< (point) posEnd)= is for checking that the cursor havn't reached
the end of region yet.

The =(re-search-forward "\\w+\\W*" posEnd t)= means keep moving the
cursor forward by regex search a word pattern. The “posEnd” argument
there means don't search beyond the end of region. And the “t” there
means don't report error if no more found.

=search-forward= and =re-search-forward= are one of the top 10 most
useful functions in elisp for text processing. If you are not familiar
with them, lookup their doc string (with =describe-function=).

So, the above “while” block, basically means keep moving the cursor and
count words, until the cursor is at the end of region.

Finally, the program just print out the result, by:

#+BEGIN_SRC emacs-lisp
    (message "Words: %d. Chars: %d." wordCount charCount)
#+END_SRC

** Note
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The code shown on this page count words by emacs's syntax table, because
the regex for word =\\w+= is dependent on syntax table. In emacs, each
character is classified into one or more categories. For example, the
English alphabets are in the “word” class, punctuations characters are
in “punctuation” class, etc. The current syntax table often depends on
the major mode. [[../emacs_manual/elisp/Syntax-Tables.html][(info
"(elisp) Syntax Tables")]]

The disadvantage of syntax table is that, the result is unpredictable,
dependent what the current major mode (and any minor mode or lisp code
can change it). For example, this file (at this moment), is 1325 words
when in “Fundamental” mode, but 1316 words when in “text-mode”. (863 by
unix “wc” command.)

** count-words-region-or-line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a version that will count the current line, if there's no text
selection.

#+BEGIN_SRC emacs-lisp
    (defun xah-count-words-region-or-line ()
      "Print number of words and chars in text selection or line.
    In emacs 24, you can use `count-words'."
      (interactive)
      (let (p1 p2)
        (if (region-active-p)
            (progn (setq p1 (region-beginning))
                   (setq p2 (region-end)))
          (progn (setq p1 (line-beginning-position))
                 (setq p2 (line-end-position))))
        (save-excursion
          (let (wCnt charCnt)
            (setq wCnt 0)
            (setq charCnt (- p2 p1))
            (goto-char p1)
            (while (and (< (point) p2) (re-search-forward "\\w+\\W*" p2 t))
              (setq wCnt (1+ wCnt)))
            (message "Words: %d. Chars: %d." wCnt charCnt)))))
#+END_SRC

*** Introduction to Programming in Emacs Lisp by Robert J Chassell
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Note: “my-count-words-region” is largely from 〈Introduction to
Programming in Emacs Lisp〉
[[http://www.amazon.com/dp/1882114027/?tag=xahh-20][Buy at amazon]] by
Robert J Chassell.

This book is bundled with emacs since version 22. To view it in emacs,
Alt+x =info= 【Ctrl+h i】, then click on the “Emacs Lisp Intro”.

I was reading it sometimes in 2005. That tutorial is for people who
never programed before. It was quite frustrating to read, because for
every thing you learn, you have to scan some 10 pages of things you
already know about programing, such as the meaning of {variables,
assignment, syntax, ...}. In the end, i didn't really read that book.
This function is about the only thing i got out of it.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_count-region.html]]

\\
\\
| [[../index_u13.html#article_19][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u38.html>>

| [[../article_21/index_u36.html][下一项]] |
[[../index_u13.html#article_20][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_19/index_u5.html][上一项]] |

--------------

* Elisp: Python 2to3 Wrapper
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2013-02-16. Last updated: 2016-02-16.

Here's a handy emacs lisp wrapper for converting current buffer's python
2 script to python 3.

#+BEGIN_SRC emacs-lisp
    (defun xah-python-2to3-current-file ()
      "Convert current buffer from python 2 to python 3.
    This command calls python3's script 「2to3」.
    URL `http://ergoemacs.org/emacs/elisp_python_2to3.html'
    Version 2016-02-16"
      (interactive)
      (let* (
             (fName (buffer-file-name))
             (fSuffix (file-name-extension fName)))
        (when (buffer-modified-p)
          (save-buffer))
        (if (or (string-equal fSuffix "py") (string-equal fSuffix "py3"))
            (progn
              (shell-command (format "2to3 -w %s" fName))
              (revert-buffer  "IGNORE-AUTO" "NOCONFIRM" "PRESERVE-MODES"))
          (error "file 「%s」 doesn't end in “.py” or “.py3”." fName))))
#+END_SRC

A handy command to go with it is
[[file:elisp_run_current_file.html][Emacs: Run Current File]]

See also: [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands
Using Python, Ruby, ...]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_python_2to3.html]]

\\
\\
| [[../index_u13.html#article_20][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u36.html>>

| [[../article_22/index_u43.html][下一项]] |
[[../index_u13.html#article_21][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_20/index_u38.html][上一项]] |

--------------

* Elisp: Refactoring, Move Code to Files
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-05. Last updated: 2014-11-06.

This page shows a example of writing a emacs command to move a text
block into a predefined set of files.

when this command is called, it'll prompt you to select a category, then
move the current block of text into a corresponding file.

here it is:

#+BEGIN_SRC emacs-lisp
    (defun xwe-move-word-to-page (@category)
      "Take current selection or block of text, ask which page to move it to."
      (interactive
       (list (ido-completing-read "Which:" '("specialwords"
                                             "arcane"
                                             "combowords"
                                             "easy"
                                             "foreignwords"
                                             "gre"
                                             "hyphwords"
                                             "informal"
                                             "slang"
                                             "noun"
                                             "noun_things"
                                             "noun_abs"
                                             "poesy"
                                             "satwords"
                                             "writerwords"))))
      (let (
            p1
            p2
            $wordText
            ($destFile (concat @category ".html")))
        (if (use-region-p)
            (progn
              (setq p1 (region-beginning))
              (setq p2 (region-end)))
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn (re-search-forward "\n[ \t]*\n")
                       (setq p1 (point)))
              (setq p1 (point)))
            (if (re-search-forward "\n[ \t]*\n" nil "move")
                (progn (re-search-backward "\n[ \t]*\n")
                       (setq p2 (point)))
              (setq p2 (point)))))

        (setq $wordText (buffer-substring-no-properties p1 p2))
        (delete-region p1 p2 )

        (find-file (concat (xahsite-server-root-path) "wordyenglish_com/words/" $destFile))
        (goto-char 1)
        (search-forward "<section class=\"word\">") (search-backward "<")
        (insert $wordText "\n\n")
        (save-buffer )
        (kill-buffer )
        (message "Word moved to 「%s」" $destFile)

        (let*
            ;; save the working buffer, but make backup first
            (($fname (buffer-file-name))
             ($backupName (concat $fname "~" (format-time-string "%Y%m%d_%H%M%S") "~")))
          (copy-file $fname $backupName t)
          (save-buffer ))))
#+END_SRC

So now, i press a key, then the text block under cursor is moved to a
appropriate file in the appropriate location. This is used for my
vocabulary collection page:
[[http://wordyenglish.com/words/vocabulary.html][Wordy English:
Vocabulary Compilation with Usage Examples]].

Now, to move the current paragraph to a file, it takes me just 2
seconds. Otherwise, it'll take about 15 seconds (using all emacs tricks
to cut current text block, open/switch to the appropriate file, locate
the position to insert, insert, save and close).

You can use this code to refactor programing source code. You'll need to
modify the list of category, and the section of
=xahsite-server-root-path=

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_move_code_to_files.html]]

\\
\\
| [[../index_u13.html#article_21][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u43.html>>

| [[../article_23/index_u18.html][下一项]] |
[[../index_u13.html#article_22][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_21/index_u36.html][上一项]] |

--------------

* Elisp: Command to Update RSS/Atom Webfeed
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2009-01-21. Last updated: 2020-04-24.

This page shows a example of writing a emacs lisp command that updates a
web feed file (Atom/RSS) on Local file system.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a command, when called, the current text selection will be added
as a entry in a Atom webfeed file.

You'll learn how to write a command that grabs the region text, switch
buffer, search string to locate position for inserting text, insert the
text, and update date field in a file.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I run several blogs on my personal website. For example, blog on
[[file:blog.html][Emacs]],
[[http://xahlee.info/kbd/keyboard_blog.html][keyboard]]
[[http://xahlee.info/comp/blog.html][Programing]]. Each of these has a
webfeed in Atom format.

Let's take the emacs blog for example. The file name is =blog.html=.
Typically, i open that file, write there, then save. The file sits on my
local disk, and is periodically synced to my web server. For each of the
blog file, there's also a corresponding webfeed, so that readers can
subscribe to it.

To create a webfeed, i've chosen the Atom format. Basically, it is a XML
file with tags for blog entries. [see
[[http://xahlee.info/js/atom.html][Atom Webfeed Tutorial]]]

The Atom file is named =blog.xml= in the same dir.

After i wrote some entry in my blog file =blog.html=, i'd like to be
able to press a button, so the current text selection will automatically
be added into my atom webfeed file =blog.xml= as a new entry.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In the beginning few months, i just manually add the new writing from
=blog.html= into the =blog.xml= file. But after a while, the pattern is
clear, and can be automated. So, here are the major steps:

- Grab the current text selection, lets call this “inputStr”. This will
  be the main content for the webfeed entry.
- Open the Atom file corresponding to the current file.
- Update the =<updated>= tag in the Atom file.
- Insert a entry tag template into the Atom file at the right place.
- Insert the “inputStr” in the proper location in the template entry.

Here's various pieces of code that is required. I'll start to show, from
the smallest components, to the final code that makes all this work.

*** Insert Time Stamp
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's a command to insert date stamp.

#+BEGIN_SRC emacs-lisp
    (defun current-date-time-string ()
      "Returns current date-time string in full ISO 8601 format.
    Example: 「2012-04-05T21:08:24-07:00」.

    Note, for the time zone offset, both the formats 「hhmm」 and 「hh:mm」 are valid ISO 8601. However, Atom Webfeed spec seems to require 「hh:mm」."
      (concat
       (format-time-string "%Y-%m-%dT%T")
       ((lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")) )
      )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun insert-date-time ()
      "Insert current date-time string in full ISO 8601 format.
    Example: 「2010-11-29T23:23:35-08:00」.

    Replaces currents text selection if there's one.
    This function calls: `current-date-time-string'."
      (interactive)
      (when (use-region-p)
        (delete-region (region-beginning) (region-end) )
        )
      (insert (current-date-time-string)))
#+END_SRC

One returns a string, the other inserts it at current cursor position.

*** Generate a new Atom Entry ID
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Each atom entry has a “id” element like this:

#+BEGIN_SRC emacs-lisp
    <id>‹id string›</id>
#+END_SRC

This id should be unique in the world. It should be in a URI format, and
some other requirements, but otherwise there's no standardized method on
what the string should be. [see [[http://xahlee.info/js/atom.html][Atom
Webfeed Tutorial]]]

Here's the code to generate this id that i've adopted, based on domain
name, date, and unix epoch seconds.

#+BEGIN_SRC emacs-lisp
    (defun new-atom-id-tag (&optional domainName)
      "Returns a newly generated ATOM webfeed's “id” element string.
    Example of return value: 「tag:xahlee.org,2010-03-31:022128」

    If DOMAINNAME is given, use that for the domain name.
    Else, use “xahlee.org”."
        (format "tag:%s%s" (if domainName domainName "xahlee.org") (format-time-string ",%Y-%m-%d:%H%M%S" (current-time) 1)) )
#+END_SRC

*** Insert Atom Entry Template
    :PROPERTIES:
    :CLASS: calibre14
    :END:

A entry in Atom format looks like this:

#+BEGIN_SRC emacs-lisp
     <entry>
       <title>How To Insert Text In Emacs Lisp</title>
       <id>tag:xahlee.org,2010-01-02:234451</id>
       <updated>2010-01-02T15:44:51-08:00</updated>
       <summary>a short tutorial</summary>
       <content type="xhtml">
    <div xmlns="http://www.w3.org/1999/xhtml">
    <p>hi there, today i did this and that.</p>
    <p>and more HTML of the full content here …</p>
    </div>
       </content>
      <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
     </entry>
#+END_SRC

So, i need a command to insert this entry template.

#+BEGIN_SRC emacs-lisp
    (defun insert-atom-entry (altLinkUrl)
      "Insert a Atom webfeed entry template,
     in the current buffer's cursor position."
      (interactive)
      (let (textToInsert domainName )
        (setq domainName "xahlee.org")
        (insert (format "
     <entry>
       <title>�</title>
       <id>%s</id>
       <updated>%s</updated>
       <summary>�</summary>
       <content type=\"xhtml\">
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
    </div>
       </content>
      <link rel=\"alternate\" href=\"%s\"/>
     </entry>

    "
         (new-atom-id-tag domainName)
         (current-date-time-string)
         altLinkUrl
         ))
         ) )
#+END_SRC

Each Atom entry requires a link element, like this:

#+BEGIN_SRC emacs-lisp
    <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
#+END_SRC

This link element is supposed to point to the perm link of the full
article. This is set as a argument “altLinkUrl” to this function. The
caller will fill it.

The timestamp for the =<updated>= tag, and also id string for =<id>=
tag, are auto-generated from the functions we wrote before.

The content for =<title>…</title>= and =<summary>…</summary>= are not
automatically created, because usually i don't have a title or summary
for short blogs. Title and Summary are required by Atom, so i write them
on the spot. I use a Unicode symbol REPLACEMENT CHARACTER � as a
marker/reminder to fill them.

*** Updating Blog Date
    :PROPERTIES:
    :CLASS: calibre14
    :END:

In the Atom file, at top there's a tag named “updated” that looks like
this:

#+BEGIN_SRC emacs-lisp
    <updated>2010-01-02T15:44:51-08:00</updated>
#+END_SRC

This needs to be updated whenever you have a new entry. So, here's the
code for that:

#+BEGIN_SRC emacs-lisp
    (progn
          (goto-char 1)
          (search-forward "<updated>" nil t)
          (delete-char 25)
          (insert-date-time))
#+END_SRC

It uses the function =insert-date-time= that we have defined earlier.

*** Final Code
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Finally, here's the command that calls all the above functions to do
what i want.

#+BEGIN_SRC emacs-lisp
    (defun make-blog-entry (begin end)
      "Create a Atom (RSS) entry of my emacs blog webfeed.
    Using selected text as Atom entry content.

    Also update the Atom file's overall “updated” tag.

    The feed is at 〔~/web/xahlee_org/emacs/blog.xml〕."
      (interactive "r")
      (let (inputStr currentFileDir currentFileName blogFileName blogFilePath altUrl)

        (setq inputStr (buffer-substring-no-properties begin end))
        (setq currentFileName (file-name-nondirectory (buffer-file-name)))
        (setq currentFileDir (file-name-directory (buffer-file-name))) ; ends in slash
        (setq blogFileName (concat (file-name-sans-extension (file-name-nondirectory currentFileName)) ".xml"))
        (setq blogFilePath (concat currentFileDir blogFileName))
        (setq altUrl "http://xahlee.org/emacs/blog.html")

        (find-file blogFilePath)
        (goto-char 1)
        (search-forward "<entry>" nil t)
        (beginning-of-line)
        (insert-atom-entry altUrl)
        (search-backward "<div xmlns=\"http://www.w3.org/1999/xhtml\">" nil t)
        (search-forward ">" nil t)
        (insert "\n" inputStr)
        ;; update atom date
        (progn
          (goto-char 1)
          (search-forward "<updated>" nil t)
          (delete-char 25)
          (insert-date-time))
        (search-forward ">�" nil t)
    )
    )
#+END_SRC

The code is pretty simple. First, it sets the current selected text to
the variable “inputStr”, by
=(setq inputStr (buffer-substring-no-properties begin end))=.

Then, it sets several paths. The current buffer's file path, name, dir,
and the corresponding blog file's path, name.

After the several =setq=, then it opens the webfeed file, go to the
beginning of file, search for the first occurrence of =<entry>=, and
that's the point a new entry should be inserted.

It then call =(insert-atom-entry altUrl)= to insert a new entry
template.

Then, it searches backward for the string
=<div xmlns="http://www.w3.org/1999/xhtml">=. This is where the
“content” part of the entry should be. The code then insert my content
“inputStr” there.

After that, we update the blog updated date, then we just move pointer
to the next occurrence of �, so that when this code is done, the cursor
is right at the Title tag part for user to edit.

Emacs ♥

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_update_atom.html]]

\\
\\
| [[../index_u13.html#article_22][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u18.html>>

| [[../article_24/index_u17.html][下一项]] |
[[../index_u13.html#article_23][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_22/index_u43.html][上一项]] |

--------------

* Elisp: Writing a Interactive Command to Update HTML Page Tags
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-11-25. Last updated: 2015-09-04.

This page shows a example of writing a emacs lisp function that update
the page navigation tag of several files.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want to write a command, so that, when invoked, emacs will update
several HTML page's page navigation tag.

You will you learn how to grab the region text, parse them into a list,
then use the list to generate a string, then go thru the list to open
each file, insert the string, and do other modification on the file.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have a website of few thousand pages. Many of them are projects that
span several HTML pages. At the bottom of each page is a navigation bar,
like this:

[[file:feed_0/article_23/images/img1.png]]

The HTML looks like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projectB.html">1</a>,
    2,
    <a href="projectB-3.html">3</a>,
    <a href="projectB-4.html">4</a>
    </div>
#+END_SRC

If i want to add a new file for this series, let's say
=projectB-5.html=, i have to manually edit every file's page navigation
bar.

It would be nice, if i could just list the file names in the current new
page i just created, like this:

#+BEGIN_SRC emacs-lisp
    projectB.html
    projectB-2.html
    projectB-3.html
    projectB-4.html
    projectB-5.html
#+END_SRC

Then, select them, press a button, and have all the page tags of all
files updated. I decided to write this command.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the basic steps.

- Get all the files names in text selection. (they should be one file
  name per line)
- Delete this region's text.
- Generate a new page nav string base on the file names we got.
- Open each file, find the old page nav string. Delete it. Insert the
  new.
- Optionally, save and close the files.

Here's the code:

#+BEGIN_SRC emacs-lisp
    (defun xah-update-page-tag (p1 p2)
      "Update HTML page navigation tags.

    The input is a text selection.
    Each line should a file name
    Update each file's page navigation tag.

    Each file name is a file path without dir, and relative to current dir.

    Example text selection for input::

    combowords.html
    combowords-2.html
    combowords-3.html
    combowords-4.html
    "
      (interactive "r")
      (let (fileList pageNavStr (i 1))
        (setq fileList
              (split-string (buffer-substring-no-properties p1 p2) "\n" t)
              )

        (delete-region p1 p2)

        ;; generate the page nav string
        (setq pageNavStr "<div class=\"pages\">Goto Page: ")

        (while (<= i (length fileList))
          (setq pageNavStr
                (concat pageNavStr
                        "<a href=\""
                        (nth (- i 1) fileList)
                        "\">"
                        (number-to-string i)
                        "</a>, ")
                )
          (setq i (1+ i))
          )

        (setq pageNavStr (substring pageNavStr 0 -2) ) ; remove the last ", "
        (setq pageNavStr (concat pageNavStr "</div>"))

        ;; open each file, inseart the page nav string, remove link in the
        ;; nav string that's the current page
        (mapc
         (lambda (thisFile)
           (message "%s" thisFile)
           (find-file thisFile)
           (goto-char (point-min))
           (search-forward "<div class=\"pages\">")
           (beginning-of-line)
           (kill-line 1)
           (insert pageNavStr)
           (search-backward (file-name-nondirectory buffer-file-name))
           (sgml-delete-tag 1)
    ;;        (save-buffer)
    ;;        (kill-buffer)
           )
         fileList)
    ))
#+END_SRC

First, we define the function with 2 parameters named {p1, p2}, and use
=(interactive "r")=. This will automatically fill the parameters {p1,
p2} with the beginning and ending positions of text selection.

The next task is to grab this block of text, and turn it into a list,
using =split-string=. This is done like this:

#+BEGIN_SRC emacs-lisp
    (setq fileList
          (split-string (buffer-substring-no-properties p1 p2) "\n" t)
          )
#+END_SRC

Then, we want to generate the navbar string. This is done by using a
=while= loop with a counter “i”. In each iteration, a string for the
current file is generated, and is then appended to pageNavStr.

This gives us the navbar string. The value of pageNavStr may be like
this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projB.html">1</a>,
    <a href="projB-2.html">2</a>,
    <a href="projB-3.html">3</a>
    </div>
#+END_SRC

However, it is not the final form. If current page is 2, then the navbar
string should be like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projB.html">1</a>,
    2,
    <a href="projB-3.html">3</a>
    </div>
#+END_SRC

The next step is to open each file, insert the navbar string in the
proper place, then take out the link of the current page. This is done
by this code:

#+BEGIN_SRC emacs-lisp
    (mapc
     (lambda (thisFile)
       (message "%s" thisFile)
       (find-file thisFile)
       (goto-char (point-min))
       (search-forward "<div class=\"pages\">")
       (beginning-of-line)
       (kill-line 1)
       (insert pageNavStr)
       (search-backward (file-name-nondirectory buffer-file-name))
       (sgml-delete-tag 1)
       )
     fileList)
#+END_SRC

The logic is this: We map a function to each file. The function will
locate the existing navbar string, then delete that line, then insert
the new navbar string, then move back to the location where the link to
current file is at, then remove the link.

The function =mapc= has this form: =(mapc function list)=, where it will
apply function to each element in the list. =mapc= is different from
=mapcar=. If you want the result to be a list, you need to use =mapcar=.
Since we don't care for the resulting list, so we use =mapc=.

The lambda above is our function. =lambda= has the form
=(lambda (x) body)=, where x is the function's parameter, and body is
one or more lisp expressions. In the “body” part, any x will be replaced
with the argument received by lambda.

In our lambda body, first we print out a messag informing user the
current file it's working on, then we open the file, then search-forward
to move the cursor to the navbar string location, delete it, then insert
the new navbar string, then we use search-bacward to search for the
current file's name. The current file's name is generated by calling
=(file-name-nondirectory buffer-file-name)=. Once the cursor is at the
location of current file in the navbar string, we call
=sgml-delete-tag=, which will delete both the opening and closing HTML
tags the cursor is on. The =sgml-delete-tag= is defined in =html-mode=.

If we want to, we can add a =(save-buffer)= and =(kill-buffer)= to save
and close the file, but for now i decided to leave the processed files
open because sometimes i'm in the middle of editing them. It is easy to
save and close a bunch of files using =ibuffer=.

So, now with this function, suppose i created a new page =projB-5.html=.
All i have to do is to list all the relevant files in the current
buffer. This is easily done in emacs by Ctrl+u Alt+x =shell-command=,
then type =ls projB*html=. Then, emacs will insert to the current buffer
this text:

#+BEGIN_SRC emacs-lisp
    projB.html
    projB-2.html
    projB-3.html
    projB-4.html
    projB-5.html
#+END_SRC

Then, i select them, then Alt+x =xah-update-page-tag=, then all the
pages will be updated for me.

Note that my file names are not necessarily regular like {“1.html”,
“2.html”, “3.html”, ...}. Otherwise, our function doesn't need to take a
list of file names from the region. It can just take one name and
generate all others.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_update_pagetag.html]]

\\
\\
| [[../index_u13.html#article_23][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u17.html>>

| [[../article_25/index_u37.html][下一项]] |
[[../index_u13.html#article_24][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_23/index_u18.html][上一项]] |

--------------

* Emacs: Insert Random Number/Hex/String
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-27. Last updated: 2018-08-03.

This page shows emacs lisp commands to insert random {number, string,
hexadecimal}.

First, in your emacs init file, you should change the random seed, like
this:

#+BEGIN_SRC emacs-lisp
    (random t) ; seed random number
#+END_SRC

Else, every emacs restart, the sequence of random will be the same.

** Insert Random Number
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-number (NUM)
      "Insert NUM random digits.
    NUM default to 5.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2017-05-24"
      (interactive "P")
      (let (($charset "1234567890" )
            ($baseCount 10))
        (dotimes (_ (if (numberp NUM) (abs NUM) 5 ))
          (insert (elt $charset (random $baseCount))))))
#+END_SRC

** Insert Random Hexadecimal
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-hex (NUM)
      "Insert NUM random hexadecimal digits.
    NUM default to 5.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2017-08-03"
      (interactive "P")
      (let (($n (if (numberp NUM) (abs NUM) 5 )))
        (insert (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n)))))))
#+END_SRC

** Insert Random String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-string (NUM)
      "Insert a random alphanumerics string of length 5.
    The possible chars are: A to Z, a to z, 0 to 9.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2018-08-03"
      (interactive "P")
      (let* (($charset "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
             ($baseCount (length $charset)))
        (dotimes (_ (if (numberp NUM) (abs NUM) 5))
          (insert (elt $charset (random $baseCount))))))
#+END_SRC

** Insert Random UUID
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_generate_uuid.html][Elisp: Insert Random UUID]]

O emacs! ♥

2010 Thanks to Teemu Likonen [tliko...@iki.fi] for improvement.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_insert_random_number_string.html]]

\\
\\
| [[../index_u13.html#article_24][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u37.html>>

| [[../article_26/index_u19.html][下一项]] |
[[../index_u13.html#article_25][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_24/index_u17.html][上一项]] |

--------------

* Elisp: Insert Random UUID
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-11-07. Last updated: 2020-06-04.

Here's a emacs command to insert a UUID.

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-uuid ()
      "Insert a UUID.
    This commands calls “uuidgen” on MacOS, Linux, and calls PowelShell on Microsoft Windows.
    URL `http://ergoemacs.org/emacs/elisp_generate_uuid.html'
    Version 2020-06-04"
      (interactive)
      (cond
       ((string-equal system-type "windows-nt")
        (shell-command "pwsh.exe -Command [guid]::NewGuid().toString()" t))
       ((string-equal system-type "darwin") ; Mac
        (shell-command "uuidgen" t))
       ((string-equal system-type "gnu/linux")
        (shell-command "uuidgen" t))
       (t
        ;; code here by Christopher Wellons, 2011-11-18.
        ;; and editted Hideki Saito further to generate all valid variants for "N" in xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx format.
        (let ((myStr (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                                  (user-uid)
                                  (emacs-pid)
                                  (system-name)
                                  (user-full-name)
                                  (current-time)
                                  (emacs-uptime)
                                  (garbage-collect)
                                  (buffer-string)
                                  (random)
                                  (recent-keys)))))
          (insert (format "%s-%s-4%s-%s%s-%s"
                          (substring myStr 0 8)
                          (substring myStr 8 12)
                          (substring myStr 13 16)
                          (format "%x" (+ 8 (random 4)))
                          (substring myStr 17 20)
                          (substring myStr 20 32)))))))
#+END_SRC

Thanks to Christopher Wellons [[[http://nullprogram.com/]]] , Hideki
Saito [[http://hideki.hclippr.com/2014/02/02/on-generating-uuid/]] . And
[Yuri Khan +https://plus.google.com/+YuriKhan/posts+], Jon Snader
[[http://irreal.org/blog/]] for discussion about UUID.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_generate_uuid.html]]

\\
\\
| [[../index_u13.html#article_25][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u19.html>>

| [[../article_27/index_u35.html][下一项]] |
[[../index_u13.html#article_26][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_25/index_u37.html][上一项]] |

--------------

* Elisp: Write grep
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-07. Last updated: 2019-01-16.

This page shows you how to write a emacs lisp script to search files,
similar to unix grep.

Here's a very simple version. It reports number of matches.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; print file names of files that have n occurrences of a string, of a given dir
    ;; version 2019-01-13

    ;; input dir
    ;; In elisp, dir path should end with a slash
    (setq inputDir "/Users/xah/web/ergoemacs_org/" )

    (setq findStr "stuff")

    (defun my-process-file (fPath)
      "Process the file at FPATH "
      (let (myBuffer p1 p2 (ii 0) searchStr)
        (when (and (not (string-match "/xx" fPath))) ; exclude some dir

          (with-temp-buffer
            (insert-file-contents fPath nil nil nil t)

            (setq searchStr findStr  )

            (goto-char 1)
            (while (search-forward searchStr nil t)
              (setq ii (1+ ii)))

            ;; report if the occurrence is not n times
            (when (not (= ii 0))
              (princ (format "%d %s\n" ii fPath)))))))

    ;; walk the dir
    (let (outputBuffer)
      (setq outputBuffer "*my find output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\.html$" ))
        (princ "Done")))
#+END_SRC

At the bottom, the code visits every file in a dir. For each file, it
calls =my-process-file= . That function creates a temp buffer, inserts
the file content in it, then do search inside the temp buffer. We use a
temp buffer because it's faster. [see
[[file:elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp Text
Processing: find-file vs with-temp-buffer]]]

To run the file, just Alt+x =eval-buffer=. [see
[[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

On 9838 html files, the script takes 40 seconds on a “Late 2014” Mac
Mini computer, when files are not cached, on a spinning harddisk.

When running a second time, it just take 6 seconds.

*** What's wrong with unix grep command?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

See: [[file:emacs_grep_problem.html][Problems of Calling Unix grep in
Emacs]].

*** Emacs Package: xah-find.el
    :PROPERTIES:
    :CLASS: calibre14
    :END:

For the full featured version of this command, see the package
[[file:elisp-xah-find-text.html][Emacs: xah-find.el, Find Replace in
Pure Elisp]].

**** Find Replace Scripts
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[http://xahlee.info/golang/goland_find_string.html][Golang: Find
  String (grep)]]
- [[http://xahlee.info/golang/goland_find_replace.html][Golang: Find
  Replace Script]]
- [[http://xahlee.info/python/find_replace_dir.html][Python: Find
  Replace in a Dir]]
- [[http://xahlee.info/python/findreplace_regex.html][Python: Find
  Replace by Regex]]
- [[http://xahlee.info/perl/perl_find_replace_in_dir.html][Perl: Find
  Replace String Pairs in Directory]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_26/elisp_grep_script.xhtml][Elisp:
  Write grep]]
- [[http://ergoemacs.org/emacs/elisp-xah-find-text.html][Emacs:
  xah-find.el, Find Replace in Pure Elisp]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_grep_script.html]]

\\
\\
| [[../index_u13.html#article_26][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u35.html>>

| [[../article_28/index_u28.html][下一项]] |
[[../index_u13.html#article_27][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_26/index_u19.html][上一项]] |

--------------

* Elisp: Find String Inside HTML Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-27. Last updated: 2019-01-16.

This page shows a emacs lisp script that search files, similar to unix
grep, but with the condition that the string must happen inside a
specific HTML tag.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I need to list all files that contains a given string, and only if the
string is inside a given HTML tag. That is, the condition that some
strig must happen before and after the string we want.

This is something grep and linux shell commands cannot do easily, and
difficult to do even with Perl, Python, unless you use a HTML parser
(which gets complex).

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-02-25, 2019-01-13
    ;; print files that meet this condition:
    ;; contains <div class="xnote">…</div>
    ;; where the text content contains more than one bullet char •

    (setq inputDir "/Users/xah/web/wordyenglish_com/arabian_nights/" ) ; dir should end with a slash

    ;; need sgml-skip-tag-forward
    (require 'sgml-mode)

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (myBuffer
            p3 p4  (bulletCount 0) )

        ;; (print fPath)

        (when
            (and (not (string-match "/xx" fPath))) ; skip some dir

          (setq myBuffer (get-buffer-create " myTemp"))
          (set-buffer myBuffer)
          (insert-file-contents fPath nil nil nil t)

          (setq bulletCount 0 )
          (goto-char 1)
          (while
              (search-forward "<div class=\"xnote\">"  nil t)

            (setq p3 (point)) ; beginning of innerText, after <div class="xnote">
            (backward-char)
            (sgml-skip-tag-forward 1)
            (backward-char 6)
            (setq p4 (point)) ; end of innerText, before </div>

            (setq bulletCount (count-matches "•" p3 p4))

            (when (> bulletCount 1)
              (princ (format "Found: %d %s\n" bulletCount fPath))))

          (kill-buffer myBuffer))))

    (let (outputBuffer)
      (setq outputBuffer "*my output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\.html$" ))
        (princ "Done")))
#+END_SRC

** Find Replace Applications
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Find, or Find Replace, has extensive use in text processing. Here's some
examples of variations, all of which i need on weekly basis and have
several elisp scripts to do the job:

- List file that contains a string.
- Show adjacent text around a string.
- List a file only if it contains more than 1 occurence of a string. (or
  more than n, less than n, exactly n.)
- List file if it contains a given set of strings.
- Replace text based on file's name.
- List file only if its HTML title and heading doesn't match.
- Find/Report/Replace only if the string is at a particular position in
  the file. (For example, near top, near bottom.)
- List a file only if the string is inside a tag.

** Why I Wrote This Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a little story on why i wrote this one.

I have about 30 classic literature with annotations. For example:
[[http://wordyenglish.com/arabian_nights/index.html][The Arabian
Nights]].

Each annotation are in the tag =<div class="xnote">…</div>=. e.g.

#+BEGIN_SRC emacs-lisp
    <div class="xnote">• provaunt ⇒ provide. Provant is a verb meaning: To supply with provender or provisions.</div>
#+END_SRC

However, some “xnote” block is multiple annotations in one. e.g.

#+BEGIN_SRC emacs-lisp
    <div class="xnote">• stint ⇒ a fixed amount or share work.
    • might and main ⇒ with all effort and strength.
    • skein ⇒ A quantity of yarn, thread, or the like, put up together, after it is taken from the reel.
    • buffet ⇒ hit, beat, especially repeatedly.
    • fain ⇒ with joy; satisfied; contented.
    </div>
#+END_SRC

Each of the annotation are marked by a bullet “•” symbol, followed by a
word. Each word corresponds to the same word in the main text marked by
=<span class="xnt">…</span>=.

This annotation system is not perfect. It is static HTML/CSS. Recently
i've been thinking of making it more dynamic based on JavaScript. With
JavaScript, it's possible to have features such as hide/show annotation
when mouse over the the word.

[see [[http://xahlee.info/js/js.html][JavaScript in Depth]]]

To make that possible, i need to make sure of few things:

- ① My custom markup must have precise semantics.
- ② The syntax should be as simple as possible. (else the JavaScript
  will have to do more work.)
- ③ The HTML annotation markup must follow strict form. (else JavaScript
  will fail silently)

With my current system, a annotation block is contained in a “xnote”
tag, and within that block, each annotation is marked by a bullet. This
semantic is precise, but isn't simple enough. If i want JavaScript to
automatically highlight the annotation text when user mouse-over a
annotated word, the js will have to do some parsing of text in the
“xnote” block.

It would be simpler, if each “xnote” block contains just ONE annotation.
This means, i will first change all my files that contain
multi-annotation blocks to make them 1-annotation per xnote block. This
is a text processing job. (Hello emacs lisp!)

Before doing text transformation on the xnote blocks, first i need to
make sure the text has correct syntax. For example: make sure that each
“xnote” do indeed contain at least one bullet symbol, and make sure that
each =<span class="xnt">…</span>= has a corresponding
=<div class="xnote">…</div>=.

So, that's why i wrote this script. I wanted to get some idea of how
many “xnote” blocks in which files actually contain multi-annotations.

The elisp code to split xnote block to multiple is very similar to the
elisp code here.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_grep_string_inside_tag.html]]

\\
\\
| [[../index_u13.html#article_27][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u28.html>>

| [[../article_29/index.html][下一项]] |
[[../index_u13.html#article_28][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_27/index_u35.html][上一项]] |

--------------

* Emacs: Check Parenthesis/Brackets Balance
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2017-08-06. Last updated: 2018-07-03.

Here's a command to check if parentheses or brackets or curly quotes are
balanced.

#+BEGIN_SRC emacs-lisp
    (defun xah-check-parens-balance ()
      "Check if there are unbalanced parentheses/brackets/quotes in current bufffer or selection.
    If so, place cursor there, print error to message buffer.

    URL `http://ergoemacs.org/emacs/emacs_check_parens_balance.html'
    Version 2018-07-03"
      (interactive)
      (let* (
             ($bracket-alist
              '( (?“ . ?”) (?‹ . ?›) (?« . ?») (?【 . ?】) (?〖 . ?〗) (?〈 . ?〉) (?《 . ?》) (?「 . ?」) (?『 . ?』) (?{ . ?}) (?\[ . ?\]) (?\( . ?\))))
             ;; regex string of all pairs to search.
             ($bregex
              (let (($tempList nil))
                (mapc
                 (lambda (x)
                   (push (char-to-string (car x)) $tempList)
                   (push (char-to-string (cdr x)) $tempList))
                 $bracket-alist)
                (regexp-opt $tempList )))
             $p1
             $p2
             ;; each entry is a vector [char position]
             ($stack '())
             ($char nil)
             $pos
             $is-closing-char-p
             $matched-open-char
             )
        (if (region-active-p)
            (setq $p1 (region-beginning) $p2 (region-end))
          (setq $p1 (point-min) $p2 (point-max)))

        (save-excursion
          (save-restriction
            (narrow-to-region $p1 $p2)
            (progn
              (goto-char 1)
              (while (re-search-forward $bregex nil "move")
                (setq $pos (point))
                (setq $char (char-before))
                (progn
                  (setq $is-closing-char-p (rassoc $char $bracket-alist))
                  (if $is-closing-char-p
                      (progn
                        (setq $matched-open-char
                              (if $is-closing-char-p
                                  (car $is-closing-char-p)
                                (error "logic error 64823. The char %s has no matching pair."
                                       (char-to-string $char))))
                        (if $stack
                            (if (eq (aref (car $stack) 0) $matched-open-char )
                                (pop $stack)
                              (push (vector $char $pos) $stack ))
                          (progn
                            (goto-char $pos)
                            (error "First mismtach found. the char %s has no matching pair."
                                   (char-to-string $char)))))
                    (push (vector $char $pos) $stack ))))
              (if $stack
                  (progn
                    (goto-char (aref (car $stack) 1))
                    (message "Mismtach found. The char %s has no matching pair." $stack))
                (print "All brackets/quotes match.")))))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_check_parens_balance.html]]

\\
\\
| [[../index_u13.html#article_28][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index.html>>

| [[../article_30/index_u23.html][下一项]] |
[[../index_u13.html#article_29][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_28/index_u28.html][上一项]] |

--------------

* Elisp: Batch Script to Validate Matching Brackets
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-19. Last updated: 2020-04-12.

This page shows you how to write a elisp script that checks thousands of
files for mismatched brackets.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a emacs lisp script to process 5 thousands files and check for
mismatched brackets.

The matching pairs includes these: () {} [] “” ‹› «» 〈〉 《》 【】 〖〗
「」 『』. [see
[[http://xahlee.info/comp/unicode_matching_brackets.html][Unicode:
Brackets, Quotes «»「」【】《》]]]

The program should be able to check all files in a dir, and report any
file that has mismatched bracket, and also indicate the line number or
position where a mismatch occurs.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; 2011-07-15 , 2020-04-12
    ;; spec at http://xahlee.org/comp/validate_matching_brackets.html
    ;; by Xah Lee.

    ;; go thru a file, check if all brackets are properly matched.
    ;; e.g. good: (…{…}… “…”…)
    ;; bad: ( [)]
    ;; bad: ( ( )

    (setq inputFile "xx_test_file.txt" ) ; a test file.
    (setq inputDir "/Users/xah/web/ergoemacs_org/emacs/") ; must end in slash

    (defvar matchPairs '() "a alist. For each pair, the car is opening char, cdr is closing char.")
    (setq matchPairs '(
                       ;; ("(" . ")")
                       ;; ("{" . "}")
                       ;; ("[" . "]")
                       ;; ("“" . "”")
                       ;; ("‹" . "›")
                       ;; ("«" . "»")
                       ("【" . "】")
                       ;; ("〖" . "〗")
                       ;; ("〈" . "〉")
                       ;; ("《" . "》")
                       ;; ("「" . "」")
                       ;; ("『" . "』")
                       )
          )

    (defvar searchRegex "" "regex string of all pairs to search.")
    (setq searchRegex "")
    (mapc
     (lambda (mypair) ""
       (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
       )
     matchPairs)

    (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”

    (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t)) ; change | to \\| for regex “or” operation

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (myBuffer myStack $char $pos)

        (setq myStack '()) ; each entry is a vector [char position]
        (setq $char "")     ; the current char found

        (when t
          ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

          (setq myBuffer (get-buffer-create " myTemp"))
          (set-buffer myBuffer)
          (insert-file-contents fPath nil nil nil t)

          (goto-char 1)
          (while (re-search-forward searchRegex nil t)
            (setq $pos (point))
            (setq $char (buffer-substring-no-properties $pos (- $pos 1)))

            ;; (princ (format "-----------------------------\nfound char: %s\n" $char) )

            (let ((isClosingCharQ nil) (matchedOpeningChar nil))
              (setq isClosingCharQ (rassoc $char matchPairs))
              (when isClosingCharQ (setq matchedOpeningChar (car isClosingCharQ)))

              ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
              ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

              (if
                  (and
                   (car myStack) ; not empty
                   (equal (elt (car myStack) 0) matchedOpeningChar ))
                  (progn
                    ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                    (setq myStack (cdr myStack)))
                (progn
                  ;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
                  (setq myStack (cons (vector $char $pos) myStack)))))
            ;; (princ "current stack: " )
            ;; (princ myStack )
            ;; (terpri )
            )

          (when (not (equal myStack nil))
            (princ "Error file: ")
            (princ fPath)
            (print (car myStack)))
          (kill-buffer myBuffer))))

    (let (outputBuffer)
      (setq outputBuffer "*xah match pair output*" )
      (with-output-to-temp-buffer outputBuffer
        ;; (my-process-file inputFile) ; use this to test one one single file
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\\.html$" )) ; do all HTML files
        (princ "Done deal!")))
#+END_SRC

I added many comments and debug code for easy understanding. If you are
not familiar with the many elisp idioms such as opening file, buffers,
printing to output, see: [[file:elisp_idioms.html][Elisp: How to Write
Commands]] • [[file:elisp_idioms_batch.html][Text Processing with Emacs
Lisp Batch Style]].

To run the code, simply open it in emacs. Edit the line at the top for
“inputDir”. Then call =eval-buffer=.

Here's a sample output:

#+BEGIN_SRC emacs-lisp
    Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter_orig.txt
    [")" 3625]
    Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter.txt
    [")" 2338]
    Error file: c:/Users/h3/web/xahlee_org/p/arabian_nights/xx/v1fn.txt
    ["”" 185795]
    Done deal!
#+END_SRC

** Code Explanation
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

- Go thru the file char-by-char, find a bracket char.
- Check if the one on stack is a matching opening char. If so remove it.
  Else, push the current onto the stack. (think of stack as stack of
  books. You put one on top (called =push=), and take one out from top
  too (called =pop=).)
- Repeat the above till no more bracket char in the file.
- If the stack is not empty, then the file got mismatched brackets.
  Report it.
- Do the above on all files.

Here's some interesting use of lisp features to implement the above.

*** Define Matching Pair Chars as “alist”
    :PROPERTIES:
    :CLASS: calibre14
    :END:

We begin by defining the chars we want to check, as a “association
list”. Like this:

#+BEGIN_SRC emacs-lisp
    (setq matchPairs '(
                       ("(" . ")")
                       ("{" . "}")
                       ("[" . "]")
                       ("“" . "”")
                       ("‹" . "›")
                       ("«" . "»")
                       ("【" . "】")
                       ("〖" . "〗")
                       ("〈" . "〉")
                       ("《" . "》")
                       ("「" . "」")
                       ("『" . "』")
                       )
          )
#+END_SRC

[see [[file:elisp_association_list.html][Elisp: Association List]]]

If you care only to check for curly quotes, you can remove elements
above. This is convenient because some files necessarily have mismatched
pairs such as the parenthesis, because that char is used for many
non-bracketing purposes (For example, ASCII smiley).

*** Generate Regex String from alist
    :PROPERTIES:
    :CLASS: calibre14
    :END:

To search for a set of chars in emacs, we can read the buffer
char-by-char, or, we can simply use =search-forward-regexp=. To use
that, first we need to generate a regex string from our matchPairs
alist. For example, if we want to search “〈〉《》”, then our regex
string should be ="〈\\|〉\\|《\\|》"=.

First, we define/declare the string. Not a necessary step, but we do it
for clarity.

#+BEGIN_SRC emacs-lisp
    (setq searchRegex "")
#+END_SRC

Then we go thru the matchPairs alist. For each pair, we use =car= and
=cdr= to get the chars and =concat= it to the string. Like this:

#+BEGIN_SRC emacs-lisp
    (mapc
     (lambda (mypair) ""
       (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
       )
     matchPairs)
#+END_SRC

Then we remove the ending =|=.

#+BEGIN_SRC emacs-lisp
    (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”
#+END_SRC

Then, change =|= to =\\|=. In elisp regex, the =|= is literal. The
“regex or” is =\|=. Elisp does not have a special regex string syntax,
it only understands normal strings. So, to feed to regex =\|=, you need
to espace the first backslash. So, the string for regex needs to be
=\\|=. Here's how we do it:

#+BEGIN_SRC emacs-lisp
    (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t)) ; change | to \\| for regex “or” operation
#+END_SRC

See also: [[file:emacs_regex.html][emacs regex tutorial]].

*** Implement Stack Using Lisp List
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Stack is done using lisp's list. For example: ='(1 2 3)=. The top of
stack is the first element. To add to the stack, do it like this:
=(setq mystack (cons newitem mystack))=. To remove a item from stack is
this: =(setq mystack (cdr mystack))=. The stack start as a empty list:
='()=.

For each entry in the stack, we put the char and also its position, so
that we can report the position if the file does have mismatched pairs.

We use a vector as entries for the stack. Each entry is like this:
=(vector char pos)=. [see [[file:elisp_vector.html][Elisp: Vector]]]

Here's how to fetch a char from alist, and push to stack, pop from
stack.

#+BEGIN_SRC emacs-lisp
    ; check if current char is a closing char and is in our match pairs alist.
    ; use “rassoc” to check alist's set of “values”.
    ; It returns the first key/value pair found, or nil
    (rassoc char matchPairs)

    ; add to stack
    (setq myStack (cons (vector char pos) myStack) )

    ; pop stack
    (setq myStack (cdr myStack) )
#+END_SRC

*** Advantages of Emacs Lisp
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Note that the great advantage of using elisp for text processing,
instead of {Perl, Python, Ruby, ...} is that many things are taken care
by the emacs environment.

I don't need to write code to deal with file encoding (emacs
automatically does it). No reading file is involved. Just “open” or
“save” the file. Processing a file is simply moving cursor thru
characters or lines, changing parts of it. No code needed for doing
safety backup. Emacs automatically does backup if you made any changes,
and can be turned off by setting the built-in var “make-backup-files” to
nil. For file paths in the output, you can easily open it by a click or
key press. I can add just 2 lines so that clicking on the error char in
the output jumps to the location in the file.

Any elisp script you write inside emacs automatically becomes a
extension of emacs and can be used in a interactive way. Or, you could
run it in a command line shell, for example,
=emacs --script process_log.el=.

This problem is posted to a few comp.lang newsgroups as a fun challenge.
See:
[[http://xahlee.info/comp/validate_matching_brackets.html][Programing
Exercise, Validate Matching Brackets]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_validate_matching_brackets.html]]

\\
\\
| [[../index_u13.html#article_29][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u23.html>>

| [[../article_31/index_u6.html][下一项]] |
[[../index_u13.html#article_30][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_29/index.html][上一项]] |

--------------

* Elisp: Generate Web Links Report
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-01-30. Last updated: 2019-06-11.

Here's how to use elisp to process files in a directory, searching for a
text pattern, and generate a report.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You have 7 thousand HTML files. You want to generate a report that lists
all links to Wikipedia, and the file path the link is from.

In this tutorial, you'll learn:

- how to walk a directory. [see [[file:elisp_traverse_dir.html][Elisp:
  Walk Directory]]]
- how to build a hash-table. [see [[file:elisp_hash_table.html][Elisp:
  Hash Table]]]
- elisp idiom for fast opening large number of files.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here are the basic steps we need:

- Given a file, extract links and put them into a hash table.
- Use elisp to traverse a given directory, open each file.
- Some pretty printing functions. For example, convert a URL string into
  HTML link string.

Once we have the data in a hash-table, it is very flexible. We can then
generate a report in plain text or HTML, or do other processing.

*** Hash Table
    :PROPERTIES:
    :CLASS: calibre14
    :END:

First, we'll need to know how to use hash table in emacs. Here's a
simple example:

#+BEGIN_SRC emacs-lisp
    ;; create a hash table
    (setq myhash (make-hash-table :test 'equal))

    ;; add entries
    (puthash "Joe" "19" myhash)
    (puthash "Jane" "20" myhash)
    (puthash "Liz" "21" myhash)

    ;; add/modify
    (puthash "Jane" "16" myhash)

    ;; get or check existence
    (setq val (gethash "Jane" myhash))

    (message val) ; print it
#+END_SRC

[see [[file:elisp_hash_table.html][Elisp: Hash Table]]]

*** Process a Single File
    :PROPERTIES:
    :CLASS: calibre14
    :END:

we want the hash table key to be the full URL string, and the value a
list. Each element in the list is the full path of the file that
contains the link.

Here is the code that processes a single file. It opens the file, search
for URL, if found, check if it exist in hash, if not, add it, else
append to the existing entry.

#+BEGIN_SRC emacs-lisp
    (setq myfile "/Users/xah/web/ergoemacs_org/emacs/GNU_Emacs_dev_inefficiency.html")

    (setq myhash (make-hash-table :test 'equal))

    (defun ff ()
      "test code to process a single file"
      (interactive)
      (let ( myBuff url)

        (setq myBuff (find-file myfile)) ; open file

        (goto-char (point-min))

        ;; search for URL till not found
        (while
            (re-search-forward
             "href=\"\\(https://..\\.wikipedia\\.org/[^\"]+\\)\">\\([^<]+\\)</a>"
             nil t)

          (when (match-string 0)        ; if URL found
            (setq url (match-string 1)) ; set the url to matched string

            (print url)

            ;; if exist in hash, prepend to existing entry, else just add
            (if (gethash url myhash)
                (puthash url (cons myfile (gethash url myhash)) myhash)
              (puthash url (list myfile) myhash))))

        (kill-buffer myBuff) ; close file
        ))

    (ff)

    (print myhash)
#+END_SRC

*** Walk a Directory
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    (mapc
     'ff
     (directory-files-recursively "~/web/ergoemacs_org/" "\.html$" ))
#+END_SRC

[[file:elisp_traverse_dir.html][Elisp: Walk Directory]]

*** Pretty Print Helpers
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Given a Wikipedia URL, returns a HTML link string.

For example:

=http://en.wikipedia.org/wiki/Emacs=

becomes

=<a href="http://en.wikipedia.org/wiki/Emacs">Emacs</a>=

#+BEGIN_SRC emacs-lisp
    (require 'gnus-util) ; for gnus-url-unhex-string

    (defun wikipedia-url-to-link (url)
      "Return the URL as HTML link string.
    Example:
     http://en.wikipedia.org/wiki/Emacs%20Lisp
    becomes
     <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
    "
      (let ((linkText url))
        (setq linkText (gnus-url-unhex-string linkText nil)) ; decode percent encoding. For example: %20
        (setq linkText (car (last (split-string linkText "/")))  ) ; get last part
        (setq linkText (replace-regexp-in-string "_" " " linkText )  ) ; low line → space
        (format "<a href=\"%s\">%s</a>" url linkText)
        ))
#+END_SRC

Given a file path, return a link string.

For example:

=/Users/xah/web/ergoemacs_org/index.html=

becomes

=<a href="../index.html">ErgoEmacs</a>=

, where the link text came from the file's “title” tag.

#+BEGIN_SRC emacs-lisp
    (defun get-html-file-title (fName)
      "Return FNAME <title> tag's text.
    Assumes that the file contains the string
    “<title>…</title>”."
      (with-temp-buffer
          (insert-file-contents fName nil nil nil t)
          (goto-char 1)
          (buffer-substring-no-properties
           (search-forward "<title>") (- (search-forward "</title>") 8))
          ))
#+END_SRC

** Putting It All Together
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; emacs lisp.

    ;; started: 2008-01-03.
    ;; version: 2019-06-11
    ;; author: Xah Lee
    ;; url: http://ergoemacs.org/emacs/elisp_link_report.html
    ;; purpose: generate a report of wikipedia links.

    ;; traverse a given dir, visiting every html file, find links to Wikipedia in those files, collect them, and generate a html report of these links and the files they are from, then write it to a given file. (overwrite if exist)

    &#12;

    (setq InputDir "/Users/xah/web/ergoemacs_org/" )

    ;; Overwrites existing
    (setq OutputPath "/Users/xah/web/xahlee_org/wikipedia_links.html")

    &#12;

    ;; add a ending slash to InputDir if not there
    (when (not (string= "/" (substring InputDir -1) )) (setq InputDir (concat InputDir "/") ) )

    (when (not (file-exists-p InputDir)) (error "input dir does not exist: %s" InputDir))

    (setq XahHeaderText
    "<!doctype html><html><head><meta charset=\"utf-8\" />
    <title>Links to Wikipedia from Xah Sites</title>
    </head>
    <body>

    <nav class=\"n1\"><a href=\"index.html\">XahLee.org</a></nav>
    ")

    (setq XahFooterText
      "
    </body></html>
    "
    )

    &#12;

    ;; hash table. key is string Wikipedia url, value is a list of file paths.
    (setq LinksHash (make-hash-table :test 'equal :size 8000))

    &#12;

    (defun xah-add-link-to-hash (filePath hashTableVar)
      "Get links in filePath and add it to hash table at the variable hashTableVar."
      (let ( $wUrl)
        (with-temp-buffer
          (insert-file-contents filePath nil nil nil t)
          (goto-char 1)
          (while
              (re-search-forward
               "href=\"\\(https://..\\.wikipedia\\.org/[^\"]+\\)\">\\([^<]+\\)</a>"
               nil t)
            (setq $wUrl (match-string 1))
            (when (and
                   $wUrl ; if url found
                   (not (string-match "=" $wUrl )) ; do not includes links that are not Wikipedia articles. e.g. user profile pages, edit history pages, search result pages
                   (not (string-match "%..%.." $wUrl )) ; do not include links that's lots of unicode
                   )

              ;; if exist in hash, prepend to existing entry, else just add
              (if (gethash $wUrl hashTableVar)
                  (puthash $wUrl (cons filePath (gethash $wUrl hashTableVar)) hashTableVar) ; not using add-to-list because each Wikipedia URL likely only appear once per file
                (puthash $wUrl (list filePath) hashTableVar)) )) ) ) )

    (defun xah-print-each (ele)
      "Print each item. ELE is of the form (url (list filepath1 filepath2 …)).
    Print it like this:
    ‹link to url› : ‹link to file1›, ‹link to file2›, …"
      (let ($wplink $files)
        (setq $wplink (car ele))
        (setq $files (cadr ele))

        (insert "<li>")
        (insert (wikipedia-url-to-linktext $wplink))
        (insert "—")

        (dolist (xx $files nil)
          (insert
           (format "<a href=\"%s\">%s</a>•"
                   (xahsite-filepath-to-href-value xx OutputPath )
                   (xah-html-get-html-file-title xx))))
        (delete-char -1)
        (insert "</li>\n"))
      )

    &#12;

    (defun wikipedia-url-to-linktext (@url)
      "Return the title of a Wikipedia link.
    Example:
    http://en.wikipedia.org/wiki/Emacs
    becomes
    Emacs"
      (require 'url-util)
      (decode-coding-string
       (url-unhex-string
        (replace-regexp-in-string
         "_" " "
         (replace-regexp-in-string
          "&" "＆"
          (car
           (last
            (split-string
             @url "/")))))) 'utf-8))

    (defun wikipedia-url-to-link (@url)
      "Return the @url as html link string.\n
    Example:
    http://en.wikipedia.org/wiki/Emacs
    becomes
    <a href=\"http://en.wikipedia.org/wiki/Emacs\">Emacs</a>"
      (format "<a href=\"%s\">%s</a>" @url (wikipedia-url-to-linktext @url)))

    (defun xah-hash-to-list (@hash-table)
      "Return a list that represent the @HASH-TABLE
    Each element is a list: '(key value).

    http://ergoemacs.org/emacs/elisp_hash_table.html
    Version 2019-06-11"
      (let ($result)
        (maphash
         (lambda (k v)
           (push (list k v) $result))
         @hash-table)
        $result))

    &#12;
    ;;;; main

    ;; fill LinksHash
    (mapc
       (lambda ($x) (xah-add-link-to-hash $x LinksHash ))
       (directory-files-recursively InputDir  "\.html$" ))

    ;; fill LinksList
    (setq LinksList
          (sort (xah-hash-to-list LinksHash)
                ;; (hash-table-keys LinksHash)
                (lambda (a b) (string< (downcase (car a)) (downcase (car b))))))

    ;; write to file
    (with-temp-file OutputPath
      (insert XahHeaderText)
      (goto-char (point-max))

      (insert
       "<h1>Links To Wikipedia from XahLee.org</h1>\n\n"
       "<p>This page contains all existing links from xah sites to Wikipedia, as of ")

      (insert (format-time-string "%Y-%m-%d"))

      (insert
       ". There are a total of " (number-to-string (length LinksList)) " links.</p>\n\n"
       "<p>This file is automatically generated by a <a href=\"http://ergoemacs.org/emacs/elisp_link_report.html\">emacs lisp script</a>.</p>

    "
       )

      (insert "<ol>\n")

      (mapc 'xah-print-each LinksList)

      (insert "</ol>

    ")

      (insert XahFooterText)
      (goto-char (point-max)))

    ;; clear memory
    ;; (clrhash LinksHash)
    ;; (setq LinksList nil)

    ;; open the file
    (find-file OutputPath )
#+END_SRC

Emacs ♥

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_link_report.html]]

\\
\\
| [[../index_u13.html#article_30][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u6.html>>

| [[../article_32/index_u3.html][下一项]] |
[[../index_u13.html#article_31][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_30/index_u23.html][上一项]] |

--------------

* Elisp: Create Sitemap
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-07-30. Last updated: 2019-06-11.

This page shows how to use emacs lisp to create a sitemap.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a elisp script to generate a sitemap. That is: create a file of
sitemap format that lists all files in a directory.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

A sitemap is a XML file that lists URLs of all files in a website for
web crawlers to crawl.

A sitemap file looks like this:

#+BEGIN_SRC emacs-lisp
    <?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

       <url>
          <loc>http://www.example.com/</loc>
          <lastmod>2005-01-01</lastmod>
          <changefreq>monthly</changefreq>
          <priority>0.8</priority>
       </url>

       …

    </urlset>
#+END_SRC

1. The file can have many =<url>…</url>= item.
2. Each =<url>= container represent a file and other info.
3. The =<loc>= is a URL of the file.
4. The =<lastmod>=, =<changefreq>=, =<priority>= are optional.
5. A sitemap file can list a max of 50k URLs.

The purpose of sitemap file is for web crawlers to easily know all files
that exist on your site.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The general plan is very simple. Here's one way to do it.

1. Create a new file, insert XML header tags.
2. Traverse the web root dir. For each file, determine whether it should
   be listed in the sitemap.
3. If so, generate the proper URL tag and insert it into the new file.
4. When done visiting files, insert the XML footer tags. Save the file.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; version: 2019-06-11
    ;; home page: /Users/xah/web/ergoemacs_org/emacs/make_sitemap.html

    (require 'seq)

    (setq xah-web-root-path "/Users/xah/web/" )

    (defvar xahsite-external-docs nil "A vector of dir paths.")
    (setq  xahsite-external-docs
           [
            "ergoemacs_org/emacs_manual/"
            "xahlee_info/REC-SVG11-20110816/"
            "xahlee_info/clojure-doc-1.8/"
            "xahlee_info/css_2.1_spec/"
            "xahlee_info/css_transitions/"
            "xahlee_info/js_es2011/"
            "xahlee_info/js_es2015/"
            "xahlee_info/js_es2015_orig/"
            "xahlee_info/js_es2016/"
            "xahlee_info/js_es2018/"
            "xahlee_info/node_api/"
            ])

    (defun xahsite-generate-sitemap (@domain-name)
      "Generate a sitemap.xml.gz file of xahsite at doc root.
    @domain-name must match a existing one.
    Version 2018-09-17"
      (interactive
       (list (ido-completing-read "choose:" '( "ergoemacs.org" "wordyenglish.com" "xaharts.org" "xahlee.info" "xahlee.org" "xahmusic.org" "xahsl.org" ))))
      (let (
            ($sitemapFileName "sitemap.xml" )
            ($websiteDocRootPath (concat xah-web-root-path (replace-regexp-in-string "\\." "_" @domain-name "FIXEDCASE" "LITERAL") "/")))
        ;; (print (concat "begin: " (format-time-string "%Y-%m-%dT%T")))
        (let (
              ($filePath (concat $websiteDocRootPath $sitemapFileName ))
              ($sitemapBuffer (generate-new-buffer "sitemapbuff")))
          (with-current-buffer $sitemapBuffer
            (set-buffer-file-coding-system 'unix)
            (insert "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
    <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">
    "))
          (mapc
           (lambda ($f)
             (setq $pageMoved-p nil)
             (when (not (or
                         (string-match "/xx" $f) ; ; dir/file starting with xx are not public
                         (string-match "403error.html" $f)
                         (string-match "404error.html" $f)))
               (with-temp-buffer
                 (insert-file-contents $f nil 0 100)
                 (when (search-forward "page_moved_64598" nil t)
                   (setq $pageMoved-p t)))
               (when (not $pageMoved-p)
                 (with-current-buffer $sitemapBuffer
                   (insert "<url><loc>"
                           "http://" @domain-name "/" (substring $f (length $websiteDocRootPath))
                           "</loc></url>\n"
                           )))))
           (seq-filter
            (lambda (path)
              (not (seq-some
                    (lambda (x) (string-match x path))
                    xahsite-external-docs
                    )))
            (directory-files-recursively $websiteDocRootPath "\\.html$" )))
          (with-current-buffer $sitemapBuffer
            (insert "</urlset>")
            (write-region (point-min) (point-max) $filePath nil 3)
            (kill-buffer ))
          (find-file $filePath)
          )
        ;; (print (concat "done: " (format-time-string "%Y-%m-%dT%T")))
        ))

    (defun xahsite-generate-sitemap-all ()
      "do all
    2016-08-15"
      (interactive)
      (xahsite-generate-sitemap "ergoemacs.org" )
      (xahsite-generate-sitemap "wordyenglish.com" )
      (xahsite-generate-sitemap "xaharts.org" )
      (xahsite-generate-sitemap "xahlee.info" )
      (xahsite-generate-sitemap "xahlee.org" )
      (xahsite-generate-sitemap "xahmusic.org" )
      (xahsite-generate-sitemap "xahsl.org"  ))
#+END_SRC

On a site with 3515 html files (10 times more if counting image files
etc), the script takes 5 seconds to run. (e.g. timing based on running
it a second time, thus not counting disk reading time. )

See also: [[http://xahlee.info/golang/golang_gen_sitemap.html][Golang:
Generate Sitemap]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/make_sitemap.html]]

\\
\\
| [[../index_u13.html#article_31][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u3.html>>

| [[../article_33/index_u41.html][下一项]] |
[[../index_u13.html#article_32][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_31/index_u6.html][上一项]] |

--------------

* Emac Lisp: Complex HTML Processing: Creating Downloadable zip Archive
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-07-04. Last updated: 2013-05-09.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I create a downloadable version of a website for people to read offline.

This is a fairly complex text processing task. In this tutorial, you'll
learn:

- How to call shell commands to copy, delete, zip, files or dir.
- How to use nested =mapc=.
- How to traverse a directory. [see
  [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]]
- how to use regex and search-forward etc to find relative links, and
  insert, etc, to change them.
- The use of relative/full name, current file dir, etc, to help
  determine and process links.
- Efficiently open and modify thousands of files.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Consider this emacs tutorial you are reading.

One simple solution is to make a copy of the directory, zip it, and let
people download that. This won't work, because many links will be
broken.

Here's what we need to do:

- All local links, including links to CSS or inline images, need to be
  processed. If they point to a dir outside the target dir, or to the
  parent of target dir, either the parent dir must be included in
  archive, or the linked file be included in the archive and link
  changed.
- All external links need to be looked at. For example, inline images
  that uses “http://” form. The image file needs to be included, and the
  link needs to be changed to relative path.
- Remove JavaScript code for Google traffic tracker, Google Ads, web
  comment widget, etc.
- {templates, temp files, temp dir, emacs backup files, ...} need to be
  removed. For example: {.DS_Store, backup~, temp-notes.txt, scheduled
  publish log dir, ...}

It would be nice, if i could just press a button in emacs, and have this
archive generated automatically. And whenever i have updated my emacs
tutorial, i can run the script again to regenerate a fresh downloadable
version.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The general plan is simple:

1. Copy the directories into a destination directory.
2. Call shell commands to delete temp files such as emac's backup files
   in the destination dir.
3. Have a function that process each HTML, to change relative links and
   take out Google Analytics's JavaScript code.
4. Call shell commands to archive this dir.

First, we define some user input parameters for the script:

#+BEGIN_SRC emacs-lisp
    ;; web root dir
    (setq webroot "/Users/xah/web/") ; must end in slash

    ;; list of source dirs i want to make a archive
    ;; Each is relative to webroot. Must not end in slash.
    (setq sourceDirsList (list "emacs" "elisp"))

    ;; Destination dir path, relative to webroot
    ;; This is the dir i want the archive to be at
    (setq destDirRelativePath "diklo")

    ;; dest zip archive name (without the “.zip” suffix)
    ;; for example here, the download file will be xah_emacs_tutorial.zip
    (setq zipCoreName "xah_emacs_tutorial")

    ;; whether to use gzip or zip.
    (setq use-gzip-p nil)
#+END_SRC

Then, we define some convenient constant.

#+BEGIN_SRC emacs-lisp
    (setq destRoot (concat webroot destDirRelativePath "/"))
    (setq destDir (concat destRoot zipCoreName "/"))
#+END_SRC

So, destRoot would be like =/Users/xah/web/diklo/= and destDir would be
like =/Users/xah/web/diklo/xah_emacs_tutorial=. The final download
archive would be =/Users/xah/web/diklo/xah_emacs_tutorial.tar.gz=.

Now, we copy the source dirs to destination.

#+BEGIN_SRC emacs-lisp
    ;;; copy to destination
    (mapc
     (lambda (x)
       (let (fromDir toDir)
         (setq fromDir (concat webroot x))
         (setq toDir
               (drop-last-slashed-substring
                (concat webroot destDirRelativePath "/" zipCoreName "/" x)) )
         (make-directory toDir t)
         (shell-command (concat "cp -R " fromDir " " toDir))
         )
       )
     sourceDirsList)
#+END_SRC

The above code used the function =mapc=. The function has the form
“(mapc 'myfunc myList)”, where the function myfunc will be applied to
each element of myList. The function we used above is “(lambda (x)
...)”, with “x” being the argument. The source dir and dest dir's paths
are constructed inside the lambda function, then command line string is
constructed, then =make-directory= is called. It will create all parent
dirs of a given full path. Then, finally we call =shell-command= to copy
the dirs.

Also, we called “drop-last-slashed-substring”, which is defined as
follows:

#+BEGIN_SRC emacs-lisp
    (defun drop-last-slashed-substring (path)
      "Drop the last path separated by “/”.
    For example:
    “/a/b/c/d” → “/a/b/c”
    “/a/b/c/d/” → “/a/b/c/d”
    “/” → “”
    “//” → “/”
    “” → “”"
      (if (string-match "\\(.*/\\)+" path)
          (substring path 0 (1- (match-end 0)))
        path))
#+END_SRC

Copying a bunch of directories seems a trivial operation, but it
actually took me a couple hours to arrive at the final code, due to some
“smart” behavior of unix =cp -R=.

Originally, i thought the code would be something simple like several
=(shell-command (concat "cp -R " fromDir " " toDir))=, one for each
source dir, where fromDir and toDir are full paths. However, it turns
out the problem is slightly more complex. Here's a summary:

① The copying behavior depends on whether the destination node exists.
When the destination node exists, it copies the source node itself,
otherwise, it copies the source node's children (and creates the
non-existant destination node). ② However, when the destination node's
parent doesn't exist, it's a error.

Now, we copy my site's style sheets.

#+BEGIN_SRC emacs-lisp
    ;; copy the style sheets over, and icons dir
    (shell-command (concat "cp /Users/xah/web/style1.css " destDir))
    (shell-command (concat "cp /Users/xah/web/style2.css " destDir))
    (shell-command (concat "cp /Users/xah/web/style3.css " destDir))
    (shell-command (concat "cp -R /Users/xah/web/ics " destDir))
#+END_SRC

Now, do some file cleanup.

#+BEGIN_SRC emacs-lisp
    ; remove emacs backup files, temp files, mac os x files, etc.
    (shell-command (concat "find " destDir " -name \"*~\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -name \"#*#\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -name \"xx*\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -name \"\\.DS_Store\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -empty -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type d -empty -exec rmdir {} \\;"))
    (shell-command (concat "find " destDir " -type d -name \"xx*\" -exec rm -R {} \\;"))
#+END_SRC

Now, we need to modify the relative links so that, if a link pointing to
a file that is not part of the downloadable copy, change it to a
〔http://xahlee.org/...〕 based link.

For example, in my emacs tutorial at =/Users/xah/web/emacs/xxx.html= it
contains the link =<a href="../python/index.html">Python tutorial</a>=,
which points to a file outside the emacs dir. When user download my
emacs tutorial, this link will then points to a file that doesn't exist
on his disk. The link =../python/index.html= should be changed to
“http://xahlee.org/python/index.html”.

Also, in my HTML files, they contain a JavaScript for Google Analytics,
like this:
=<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript"> _uacct = "UA-104620-2"; urchinTracker();</script>=.
This allows me to see my web traffic statistics. The downloaded version
shouldn't have this line.

Here's the code to process each HTML file for the above problems:

#+BEGIN_SRC emacs-lisp
    ;;; change local links to “http://” links.
    ;;; Delete the google JavaScript snippet, and other small fixes.
    (setq make-backup-files nil)
    (require 'find-lisp)
    (mapc (lambda (x)
            (mapc
             (lambda (fPath) (clean-file fPath (concat webroot (substring fPath (length destDir)))))
             (find-lisp-find-files (concat destDir "/" x) "\\.html$"))
            )
          sourceDirsList
    )
#+END_SRC

In the above code, we use =mapc= to apply a function to all HTML files.
The “find-lisp-find-files” will generate a list of all files in a dir.
Here, we actually calls mapc twice, one inside the other.

The sourceDirsList is a list of dirs. So, the first mapc maps a function
to each of the dir. Now, for each dir, we want to apply a function to
all HTML files. That's the inner mapc is for. The function that actually
does process the HTML file is the “clean-file”. The “clean-file”
function takes 2 arguments. The first is the full path to the HTML file
to be processed, the second is a full path to the “same” file at source
dir. The second argument is necessary, because we need the original
directory structure to compute the correct URL for the relative link
that needs to be fixed. Here's the code:

#+BEGIN_SRC emacs-lisp
    (defun clean-file (fPath originalFilePath)
      "Modify the HTML file at fPath, to make it ready for download bundle.

    This function change local links to “http://” links,
    Delete the google JavaScript snippet, and other small changes,
    so that the file is nicer to be viewed offline at some computer
    without the entire xahlee.org's web dir structure.

    The google JavaScript is the Google Analytics web bug that tracks
     web stat to xahlee.org.

    fPath is the full path to the HTML file that will be processed.
    originalFilePath is full path to the “same” file in the original web structure.
    originalFilePath is used to construct new relative links."
      (let (myBuffer bds p1 p2 linkPath linkPathSansJumper)

        (setq myBuffer (find-file fPath))

        (goto-char (point-min)) ;in case buffer already open
        (while (search-forward "<script src=\"http://www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\"> _uacct = \"UA-104620-2\"; urchinTracker();</script>" nil t)
          (replace-match ""))

        (goto-char (point-min))
        (while (search-forward "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee</a>" nil t)
          (replace-match "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee↗</a>"))

        ;; go thru each link, if the link is local,
        ;;then check if the file exist.
        ;;if not, replace the link with proper http://xahlee.org/ url
        (goto-char (point-min)) ; in case buffer already open

        (while (re-search-forward "<[[:blank:]]*a[[:blank:]]+href[[:blank:]]*=[[:blank:]]*" nil t)
          (forward-char 1)
          (setq bds (bounds-of-thing-at-point 'filename))
          (setq p1 (car bds))
          (setq p2 (cdr bds))
          (setq linkPath (buffer-substring-no-properties p1 p2))

          (when (not (string-match "^http://" linkPath))

            ;; get rid of trailing jumper, for example, “Abstract-Display.html#top”
            (setq linkPathSansJumper (replace-regexp-in-string "^\\([^#]+\\)#.+" "\\1" linkPath t))

            (when (not (file-exists-p linkPathSansJumper))
              (delete-region p1 p2)
              (let (newLinkPath)
                (setq newLinkPath
                      (compute-url-from-relative-link originalFilePath linkPath webroot "xahlee.org"))
                (insert newLinkPath))
              (search-forward "</a>")
              (backward-char 4)
              (insert "↗")
              )
            )
          )
        (save-buffer)
        (kill-buffer myBuffer)))
#+END_SRC

In the above function “clean-file”, the hard part is to construct the
correct URL for a relative link.

Given a file, there are many relative links. The link may or may not be
good in the download copy version. For example, if the relative link
does not start with =../=, then it is still good. However, if it starts
with =../=, it may or may not be still good. For example, in my emacs
tutorial project, both =/Users/xah/web/emacs/= and
=/Users/xah/web/elisp/= are part of the download archive. So, if some
file under the emacs dir has a relative link starting with =../elisp/=,
then it is still a good link. We don't want to replace that with a
〔http://...〕 version. To compute the correct relative link, we
actually need to know the original dir structure.

Computing relative links is conceptually trivial. Basically, each
occurrence of =../= means one dir level up. But actually coding it
correctly took a while due to various little issues. For example, some
link will have a trailing jumper of this form
=Abstract-Display.html#top=. The trailing =#top= will need to be removed
if we want to use the string to check if file exists. Theoretically, all
it takes to determine a relative link is the file path of the file that
contains the link, the relative link string, and the dir tree structure
surrounding the file. Specifically, when we move a dir, and wish to
construct or fix relative links, we do not need to check if the linked
file still exists in the new dir. In practice, it's much simpler, to
first determine whether the relative link is still good, by checking if
the linked file exists at the new download copy's dir structure.

In the clean-file function, it first grab the relative link string from
the HTML file, then determine whether this link needs to be fixed, then
calls “compute-url-from-relative-link” that returns the proper “http://”
based URL. The function compute-url-from-relative-link takes 4
parameters: fPath, linkPath, webDocRoot, hostName. See the doc string
below:

#+BEGIN_SRC emacs-lisp
    (defun compute-url-from-relative-link (fPath linkPath webDocRoot hostName)
      "returns a “http://” based URL of a given linkPath,
    based on its fPath, webDocRoot, hostName.

    fPath is the full path to a HTML file.
    linkPath is a string that's relative path to another file,
    from a “<a href=\"…\"> tag.”
    webDocRoot is the full path to a parent dir of fPath.
    Returns a URL of the form “http://hostName/‹urlPath›”
    that points to the same file as linkPath.

    For example, if
    fPath is /Users/xah/web/Periodic_dosage_dir/t2/mirrored.html
    linkPath is ../../p/demonic_males.html
    webDocRoot is /Users/xah/web/
    hostName is xahlee.org
    then result is http://xahlee.org/p/demonic_males.html

    Note that webDocRoot may or may not end in a slash."
      (concat "http://" hostName "/"
              (substring
               (file-truename (concat (file-name-directory fPath) linkPath))
               (length (file-name-as-directory (directory-file-name webDocRoot))))))
#+END_SRC

Finally, we zip up the dest dir.

#+BEGIN_SRC emacs-lisp
    ;; zip the dir
    (let (ff)
      (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".zip"))
      (when (file-exists-p ff) (delete-file ff))
      (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".tar.gz"))
      (when (file-exists-p ff) (delete-file ff)))

    (setq default-directory (concat webroot destDirRelativePath "/"))

    (when (equal
           0
           (if use-gzip-p
               (shell-command (concat "tar cfz " zipCoreName ".tar.gz " zipCoreName))
             (shell-command (concat "zip -r " zipCoreName ".zip " zipCoreName))
             ))
      (shell-command (concat "rm -R " destDir))
    )
#+END_SRC

In the above code, first we delete the previous archive if it exists.

Now, all is done. With all the code above in a buffer, i can just
eval-buffer to generate my downloadable archive, or i can call the
script in OS's command line like =emacs --script make_download_copy.el=.
I decided to go one step further, by wrapping the whole script into a
function. Like this:

#+BEGIN_SRC emacs-lisp
    (defun make-downloadable-copy (webroot sourceDirsList destDirRelativePath
    zipCoreName &optional use-gzip-p)
      "Make a copy of web dir of XahLee.org for download.

    This function depends on the structure of XahLee.org,
    and is not useful in general.

    • webroot is the website doc root dir. (must end in slash)
    For example: <code class=\"path-abc\">/Users/xah/web/」

    • sourceDirsList is a list of dir paths relative to webroot,
    to be copied for download. Must not end in slash.
    For example: (list \"p/time_machine\")

    • destDirRelativePath is the destination dir of the download.
    it's a dir path, relative to webroot.
    For example: “diklo”

    • zipCoreName is the downloable archive name, without the suffix.
    For example: “time_machine”

    use-gzip-p means whether to use gzip, else zip for the final archive.
    If non-nil, use gzip."
      (let (…)
      ;; all the code above here except functions.
      )
    )
#+END_SRC

Here's how i call it:

#+BEGIN_SRC emacs-lisp
    ;; emacs tutorial and elisp manual in one download archive
    ;; gzip format
    (make-downloadable-copy
    "/Users/xah/web/"
    (list "emacs" "elisp")
     "diklo" "xah_emacs_tutorial" "gzip")

    ;; elisp manual. zip format.
    (make-downloadable-copy
    "/Users/xah/web/"
    (list "elisp")
     "diklo" "elisp_manual")
#+END_SRC

Emacs ♥

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/make_download_copy.html]]

\\
\\
| [[../index_u13.html#article_32][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u41.html>>

| [[../article_34/index_u20.html][下一项]] |
[[../index_u13.html#article_33][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_32/index_u3.html][上一项]] |

--------------

* Elisp: Process File line-by-line
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-12-05. Last updated: 2012-04-16.

This page gives a example of how to use emacs lisp to process a file
line by line, in a buffer, not as string of lines.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Given a file of many lines, like this:

#+BEGIN_SRC emacs-lisp
    at_target(integer tnum, vector targetpos, vector ourpos)
#+END_SRC

For each line, create a file of the same name as first part of the line.
For example: 〔at_target.txt〕

The file content should be the whole line, with other static text, like
this:

#+BEGIN_SRC emacs-lisp
    # --
    at_target(integer tnum, vector targetpos, vector ourpos)
    {
    $0
    }
#+END_SRC

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I'm writing a major mode for [[http://xahsl.org/sl/ls.html][Linden
Script Language]] (LSL). LSL is a scripting language used for the
virtual world [[http://xahsl.org/sl/index.html][Second Life]]. It has
few hundred functions, and each one has parameters that is unusual as
compared to normal programing languages. For example, this is a LSL
function:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
    // …
    }
#+END_SRC

So, i want a function template feature in my major mode. If a programer
has typed “at_rot_target”, then, he can press a button, and it expands
to:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
    ▮
    }
#+END_SRC

There is a easy-to-use template system package for emacs, called
YASnippet. [see [[file:emacs_templates.html][YASnippet tutorial]]] So, i
decided to use this instead of implementing my own template system.

With yasnippet, it uses a plain text for template definition. To define
a template, you need to create a file. For example, in LSL there's a
function named “collision” with this syntax
=collision(integer num_detected) {…}=. This means, i must have a file
named “collision” in the template dir, and the file content must be like
this:

#+BEGIN_SRC emacs-lisp
    # --
    collision(integer num_detected)
    {
    $0
    }
#+END_SRC

This means, when my mode xlsl-mode is on, and yasnippet minor mode is
on, then user can type “collision” followed by a hotkey for template
completion, then the function form will be inserted and cursor will be
placed between the braces.

I have prepared a file that is over 300 lines that are the LSL functions
and parameters. For example, part of the file looks like this:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot)
    at_target(integer tnum, vector targetpos, vector ourpos)
    attach(key id)
    changed(integer change)
    collision(integer num_detected)
    collision_end(integer num_detected)
    collision_start(integer num_detected)
    control(key id, integer held, integer change)
#+END_SRC

(Save the above text in a file name it =xx_event_forms.txt= for later
testing of elisp code.)

Now, the task is to parse this file, and for each line, create the
template file for it.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The task has these steps:

- Open the file.
- Read each line.
- Parse the line into 2 parts. The first part is everything before the
  opening paren (call it stringA). The second part is the rest of the
  line (call it stringB).
- Create a file and name it stringA.
- Insert into the file the whole line, and other text such as =# --= and
  ={ $0 }=.

These are simple tasks. There are a lot ways to do this in elisp. We can
for example grab the whole file's text, then use =split-string= by
newline char to get a list of lines. Then we loop thru the list.

*** Read File Content as List of Lines
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[file:elisp_read_file_content.html][Elisp: Read File Content as String
or List of Lines]]

*** Process Each Line in a Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Another way more idiomatic to emacs lisp, is to simply open the file in
a buffer, then move cursor one line at a time, each time grab the line
and do what we need to do.

For this task, the split lines into a list method is probably simpler.
But since we are learning emacs lisp, let's use the emacs buffer method.

First, we define few global vars.

#+BEGIN_SRC emacs-lisp
    ;; input file
    (setq inputFile "xx_event_forms.txt")

    ;; other vars
    (setq splitPos 0) ;; cursor position of split, for each line
    (setq fName "")
    (setq restLine "")
    (setq moreLines t ) ;; whether there are more lines to parse
#+END_SRC

Now, we open the file, like this:

#+BEGIN_SRC emacs-lisp
    ;; open the file
    (find-file inputFile)
    (goto-char 1) ;; needed in case the file is already open.
#+END_SRC

Now, we loop thru the lines, like this:

#+BEGIN_SRC emacs-lisp
    (while moreLines
      (search-forward "(")

      (setq splitPos (1- (point)))
      (beginning-of-line)
      (setq fName (buffer-substring-no-properties (point) splitPos))

      (end-of-line)
      (setq restLine (buffer-substring-no-properties splitPos (point) ))

      ;; create the file
      (find-file fName)
      (insert "# --\n")
      (insert fName restLine "\n{\n$0\n}" )
      (save-buffer)
      (kill-buffer (current-buffer))

      (setq moreLines (= 0 (forward-line 1)))
    )
#+END_SRC

In the above, we use =search-forward= to move cursor to the opening
paren. Then, save the position to splitPos. Everything before that
should be the template file name, so we save it in fName. Everything
after that is restLine.

Now, we create the file fName using =(find-file fName)=, then, insert
the content, save it, close it.

Lastly, we move cursor to the next line by =(forward-line 1)=. Note that
if the cursor is at the last line, and when =forward-line= is unable to
move forward, it will return a number indicating how many lines it
failed to pass. So, normally it returns 0. If not, that means we are on
the last line.

After we processed the lines, we just close the input buffer, like this:

#+BEGIN_SRC emacs-lisp
    (kill-buffer (current-buffer)) ;; close the input file
#+END_SRC

To test the above, first create a sample input file. Take the sample
input lines above and save it as =xx_event_forms.txt=. Then, grab all
the above lisp code and save it in a file =test_line_process.el=. Now,
open the lisp file and Alt+x =eval-buffer=. Then all the template files
will be created in the same dir.

Emacs ♥

See also: [[file:elisp_all_about_lines.html][Elisp: Functions on Line]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_process_lines.html]]

\\
\\
| [[../index_u13.html#article_33][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u20.html>>

| [[../article_35/index_u15.html][下一项]] |
[[../index_u13.html#article_34][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_33/index_u41.html][上一项]] |

--------------

* Emacs Lisp Power: Text-Soup Automation
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-11-03

This page showcases a example of emacs lisp power, in dealing with
text-soup processing that requires human interaction.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I have a [[http://xaharts.org/movie/best_movies.html][favorite movies
page]]. The page contain about 70 amazon links like this:

#+BEGIN_SRC emacs-lisp
    <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
#+END_SRC

It's a mystery what the link is, unless you visit the link. I want them
to have a “title” attribute, like this:

#+BEGIN_SRC emacs-lisp
    <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>
#+END_SRC

It's a thorny problem. You have to write a script to fetch the amazon
page then parse the result to get the product title then insert them at
the right place. Amazon may block crawlers, and even if not, the parsing
of the complex HTML to extract the title may take hours to code. You
don't even know if product title is clearly marked by a specific tag.

Luckily, my page is written so that for each amazon link, the movie
title is within the paragraph, preceding the link, and usually in the
form of a Wikipedia link. Here's a sample paragraph:

#+BEGIN_SRC emacs-lisp
    <p><a href="http://en.wikipedia.org/wiki/To_sleep_with_a_vampire">To sleep with a vampire</a>
     (1993) ◇ Director: Adam Friedman.
    <a class="amz" href="http://www.amazon.com/dp/B0000648YN/?tag=xahh-20">amazon</a>
    </p>
#+END_SRC

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

So, the plan is to write a elisp script. Here's the basic steps:

1. open the file
2. find a amazon link.
3. search backward for the Wikipedia link that contains the movie title.
4. insert the “title” attribute in the amazon link.
5. Repeat.

This is a job perfect for elisp, and can be done interactively,
[[file:elisp_text_processing_lang.html][far better than any Perl,
Python, Ruby]], due to emacs lisp's buffer system. I imagine it's a 20
min scripting job. Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2010-11-03
    ;; add 「title="product title"」 to amazon links on a HTML page.

    ;; rough steps:
    ;; find amazon link of the form
    ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

    ;; find a Wikipedia link above it, of this form
    ;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
    ;; extract the movie title

    ;; insert the attribute
    ;; title="…"
    ;; into the amazon link. Like this
    ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

    (setq outputBuffer "*xah output*" )
    (with-output-to-temp-buffer outputBuffer

      (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
      (goto-char 1)

      (while
          (re-search-forward "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

        (progn
          ;; set points for amazon link
          (backward-char 11)
          (setq amzLinkInsertPoint (point) )

          ;; get title from preceding Wikipedia link
          (re-search-backward "<a href=\"http://...wikipedia.org/wiki/[^\"]+?\">\\([^<]+?\\)</a>")
          (setq titleText (match-string 1 ) )

          (when (yes-or-no-p titleText)
            (goto-char amzLinkInsertPoint)
            (insert (concat " title=\"" titleText "; movie\"")) )
          )

        (progn (print "not found"))
        )

      (princ "Done deal!")
      )
#+END_SRC

Emacs is fantastic!

(In practice, the job took close to one hour to complete, counting all
mistakes, and whatnot when actually coding. For example, in the process
i noticed that 2 of the amazon links are preceded by Wikipedia links
that are not actually related to the amazon link, and this and other
miscellaneous irregularities are actually expected. The code above is
actually slightly cleaned up, but is still meant to be one-time-use
code. It always looks easy when seeing someone's published code than
actually coding from scratch.)

There are few hundred amazon links on my site of 4k pages. They all need
a similar fix. The job will be slightly different, because the links are
arbitrary product or book names. But typically, the product name is
usually marked like this 〈book title〉 or “song cd” or some other way
in the text before the link, but not always. Also, some amazon links may
already have a “title” attribute. The point is that it's a
[[file:emacs_power_story.html][text-soup situation and requires human
baby-sitting]] for correct completion, and elisp excels at this.
Tomorrow or so, i'll write a elisp script to fix these few hundred
amazon links among 4k pages. Total time for the task is expected to be 2
to 4 hours. (For a keyboard macro solution i needed to do in this, see:
[[file:emacs_macro_example2.html][Emacs Key Macro Example: Add HTML
Attribute]].)

2010-11-08

Aaron Culich wrote a elisp script that does the same thing but using
several interesting techniques, among them is using DOM/XPATH in elisp
to process HTML, and also yahoo's Yahoo Query Language (YQL), both of
which i don't have any experience with. His code can be seen here:
[[https://github.com/aculich/misc-elisp/blob/master/query-html.el]]

Here's a excerpt of his comment:

#+BEGIN_QUOTE
  I often find myself having to do some xpath myself and since want to
  do this sort of thing inside emacs myself from time to time instead of
  busting out python, so I've been playing around with your Dr.
  Strangelove movie example (a favorite movie of mine, btw) using emacs
  and xpath. You can find my results here:
  https://github.com/aculich/misc-elisp

  I tried using 3 methods.

  - ① First with pure elisp using the dom/xpath stuff on emacswiki.
    Unfortunately the processing is broken and at least in some of the
    cases I tried, gobbled up all available memory. I didn't look at it
    closely, but I have a feeling the elisp implementation would a fair
    amount of work to get working and even still would probably not be
    very fast for large documents. Also, you still probably want to run
    the input through tidy first so that you're not dealing with broken
    HTML (which it seems nearly every website in the universe has).
  - ② Using a few handy unix utilities not uncommon on most systems:
    wget, tidy, and xmlstarproc. You'll need to first install those
    before using this method.
  - ③ Yahoo's YQL web service is handy for this sort of thing. And the
    nice thing is that if you need to process a large document, all of
    it will be done remotely.

  #3 is the default method that I use in my elisp code since it only
  relies on modules that ship with most recent versions of emacs
  (specifically json.el and url.el and w3m.el) and doesn't require any
  special binaries to be installed the way #2 does.

  Also, since #1 was so broken I did not include any example
  implementation for it. Anyway, if you find the code useful, let me
  know.
#+END_QUOTE

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text-soup_automation.html]]

\\
\\
| [[../index_u13.html#article_34][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u15.html>>

| [[../article_36/index_u39.html][下一项]] |
[[../index_u13.html#article_35][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_34/index_u20.html][上一项]] |

--------------

* Elisp: HTML Processing: Split Annotation
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-08-16

This page shows a example of emacs lisp for processing HTML. The HTML
files are classic novels, with annotations. The annotation markups need
to change from one format into another. There are hundreds of such pages
that need to be processed.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For all HTML files in a directory, find any annotation markup containing
the bullet “•” symbol:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">A … • B … • C …</div>
#+END_SRC

Split the annotation into multiple markups, like this:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">A … </div>
    <div class="annotate27223">B … </div>
    <div class="annotate27223">C … </div>
#+END_SRC

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

If you are a contract web dev programer, then you know that 99.99% of
websites are a messy text soup. They are created by hundreds of tools or
languages. Word processors, HTML generators, tens of lightweight markup
languages, different frameworks from different languages PHP, Perl,
Python, from different web era, from different programers in the past.
Even emacs has several modes that generate HTML. They are not in any
consistent form. Often, they have mis-matched tags too as invalid HTML.

It is in these situations, emacs shines thru, because emacs's powerful
embedded language lisp, and its interactive nature, lets you maximize
automation. Interactively when you are still feeling the pattern, then
by [[file:emacs_macro_example.html][Keyboard Macro]] or emacs lisp for
parts that can be automated.

For my website, i take the time to make sure that all my HTML are
consistent. But still, they are written in the span of 15 years.
Periodically i take the time to improve the markup. For example, when
new versions of CSS or HTML became mature and widely adopted by web
browsers. (CSS1 to 2 to 3, HTML 3 to 4 to
[[http://xahlee.info/js/html5_tags.html][HTML5]].)

I have hundreds of pages of classic novels as HTML documents. These
documents contain annotations in a special HTML markup. For example,
here's sample annotation from
[[http://wordyenglish.com/titus/act1.html][“Titus Andronicus” Act 1
Scene 1]]:

#+BEGIN_SRC emacs-lisp
    SATURNINUS. 'Tis good, sir. You are very short with us;
      But if we live we'll be as sharp with you.
#+END_SRC

• short ⇒ rudely brief. (AHD)\\
• sharp ⇒ Fierce, impetuous, hash, severe... (AHD)

Here's the raw HTML:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">• short ⇒ rudely brief. (AHD)<br>
    • sharp ⇒ Fierce, impetuous, hash, severe… (AHD)</div>

    <pre class="text48074">SATURNINUS. 'Tis good, sir. You are very <span class="xntt">short</span> with us;
      But if we live we'll be as <span class="xntt">sharp</span> with you.
    </pre>
#+END_SRC

Here's how the tag works. Each =<span class="xntt">= markup a word in
main text. When a word is marked by “span.xntt”, that means it has a
sidebar annotation. The sidebar section is marked by
=<div class="annotate27223">=. Inside the “div.annotate27223”, there may
be more than one entries. Each entry starts with the bullet symbol “•”.
For example, in the above, the words “short” and “sharp” are both
entries inside a “div.annotate27223” sidebar.

But recently, i think it is better to have one entry per sidebar. This
way, it makes the logic simpler, and is much easier if i want to add
[[http://xahlee.info/js/js.html][JavaScript]] functionality. For
example, when mouse hovers on a word in main text, the corresponding
annotation would be highlighted.

So, i want to write a elisp script to process all my files. If you
simply read the spec for this job, of splitting a markup by a particular
character, you may think it's trivial and can be done in any language in
10 minutes. Why then the elaborate discussion about text soup situation?

The important thing is that i DO NOT know what needs to be done to begin
with. Only after having used emacs power together with lisp script i
wrote before to look at and check my existing markup in hundreds of
files, then i know what state they are and decide on what i want to do.
Also, this change must be done with the ability to visually check that
all changes are done correctly, because the input may not be in the
format i expect. (it might be missing the bullet “•”.)

For those Scheme Lisp academic computer science folks, you might wonder,
when i started with these annotations, why didn't i “design” it well to
begin with. The reason is that, when i write a blog article, or my
literature annotation project, i really want to focus on the writing
first, the content, get it done, rather than get distracted by the
CSS/HTML markup design. (one thing i do make sure is that whatever
CSS/HTML i device, i made sure that they can be easily changed
systematically later by a simple parsing.) I devote significantly more
time on design than most people, but many factors necessitate change.
For example, CSS in practice is rather complex and it takes years of
experience to learn its quirks and tricks. Similarly, the best practices
of HTML changes with time. (For example, see:
[[http://xahlee.info/UnixResource_dir/writ/html5_vs_intelligence.html][Are
You Intelligent Enough to Understand HTML5?]].) Browsers change,
standards changes (For example, HTML → XHTML → HTML5. See:
[[http://xahlee.info/js/html5_validation_doctype.html][HTML5 Doctype,
Validation, X-UA-Compatible, and Why Do I Hate Hackers]].), thoughts of
best practices change, and my needs for the annotation also changed
through-out the years.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the outline of steps:

- Open the file. Search for the tag we want.
- Check if the tag contains a bullet “•”.
- If so, replace the bullet char with new end tag and beginning tag. For
  example: =•= ⇒ =</div> <div>=
- Do this for all files in a dir. (or a given list of files)

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-08-13
    ;; process all files in a dir.
    ;; split any markup like this:
    ;; <div class="annotate27223">… • … • …</div>
    ;; by the bullet •
    ;; into several annotate27223 tags

    (setq inputDir "~/web/xahlee_org/p/" )

    ;; add a ending slash if not there
    (when (not (string= "/" (substring inputDir -1) )) (setq inputDir (concat inputDir "/") ) )

    ;; files to process
    (setq fileList
    [
    "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin4_1.html"
    "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin3.html"
    ]
    )

    (defun my-process-file-xnote (fPath)
      "Process the file at FPATH …"
      (let (myBuffer ($counter 0) p1 p2 $meat
                     $meatNew
                     (changedItems '())
                     (tagBegin "<div class=\"annotate27223\">" )
                     (tagEnd "</div>" )
                     )

        (require 'sgml-mode)
        (when t

          (setq myBuffer (find-file fPath))
          (goto-char 1)
          (while (search-forward "<div class=\"annotate27223\">" nil t)

            ;; capture the annotate27223 tag text
            (setq p1 (point))
            (backward-char 1)
            (sgml-skip-tag-forward 1)
            (backward-char 6)
            (setq p2 (point))
            (setq $meat (buffer-substring-no-properties p1 p2))

            ;; if it contains a bullet
            (when (string-match "•" $meat)
              (setq $counter (1+ $counter))

              ;; clean the text. Remove some newline and <br> that's no longer needed
              (setq $meat (replace-regexp-in-string "\n*• *" "•" $meat t t ) )
              (setq $meat (replace-regexp-in-string "\n$" "" $meat t t ) ) ; delete ending eol
              (setq $meat (replace-regexp-in-string "<br>•" "•" $meat t t ) )

              ;; put the new entries into a list, for later reporting
              (setq changedItems (split-string $meat  "•" t) )

              ;; break the bullet into new end/begin tags
              (setq $meatNew (replace-regexp-in-string "•" (concat tagEnd "\n" tagBegin) $meat t t ) )

              (goto-char p1)
              (delete-region p1 p2)
              (insert $meatNew)

              ;; remove the newline before end tag
              (when (looking-back "\n") (delete-backward-char 1))
              )
            )

          ;; report if the occurrence is not n times
          (when (not (= $counter 0))
              (princ "-------------------------------------------\n")
              (princ (format "%d %s\n\n" $counter fPath))

              (mapc (lambda ($x) (princ (format "%s\n\n" $x)) ) changedItems)
            )

            ;; close buffer if there's no change. Else leave it open.
            (when (not (buffer-modified-p myBuffer)) (kill-buffer myBuffer) )
          )
        ))

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah annotate27223 output*" )
      (with-output-to-temp-buffer outputBuffer
        ;; (mapc 'my-process-file-xnote fileList)
        (mapc 'my-process-file-xnote (find-lisp-find-files inputDir "\\.html$"))
      (princ "Done deal!")
        )
      )
#+END_SRC

Here's a sample output:
[[file:elisp_text_processing_split_annotation.txt]]

I've put lots comments in the code. It should be easy to understand. If
any part you don't understand, ask me. If you are new to elisp, checkout
the first few section of [[file:elisp.html][Emacs Lisp Tutorial]].

I ♥ emacs.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text_processing_split_annotation.html]]

\\
\\
| [[../index_u13.html#article_35][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u39.html>>

| [[../article_37/index_u10.html][下一项]] |
[[../index_u13.html#article_36][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_35/index_u15.html][上一项]] |

--------------

* Elisp: Fix Dead Links
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-09-25. Last updated: 2012-05-11.

This page shows you how to write a elisp script that checks thousands of
HTML files and fix dead links.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I have 2 thousands HTML files that contains about 70 dead local links. I
need to write a elisp script to change these links to non-links. For
example, this is a dead link:

#+BEGIN_SRC emacs-lisp
    <a href="../widget/index.html#Top">Introduction</a>
#+END_SRC

I need it to be:

#+BEGIN_SRC emacs-lisp
    <span class="εlink" title="../widget/index.html#Top">Introduction</span>
#+END_SRC

The script should run in batch. And it should generate a report of all
changed links.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have a copy of the emacs manuals, at:

- [[../emacs_manual/emacs/index.html][GNU Emacs Manual]] (~690 files)
- [[../emacs_manual/elisp/index.html][GNU Emacs Lisp Reference Manual]]
  (~900 files)

These manual sometimes have links to other info files that's not emacs.
For example, on this page
[[../emacs_manual/elisp/Changing-Files.html][Changing Files - GNU Emacs
Lisp Reference Manual]], it contains a link to GNU coreutils like this:

#+BEGIN_SRC emacs-lisp
    <a href="../coreutils/File-Permissions.html">File Permissions</a>
#+END_SRC

I need to change these links to non-links.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

1. Open each file.
2. Search for “href=”.
3. Get the link URL.
4. Check if the link is a local file and exists.
5. If not, change the entire link tag into a “span” tag.
6. Repeat the above, until no link found.

First, we start like this:

#+BEGIN_SRC emacs-lisp
    (setq inputDir "~/web/xahlee_org/emacs_manual/" )

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      …
    )

    ;; traverse the directory on all HTML files
    (require 'find-lisp)
    (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
#+END_SRC

The important part is the “my-process-file” function. Here's the basic
code:

#+BEGIN_SRC emacs-lisp
    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (…)

        ;; open file
        (setq myBuff (find-file fPath))

        (while
            ;; search local link
            (search-forward "href=\"../" nil t)

          ;; get the URL string
          (setq urlStr (thing-at-point 'filename) )

          ;; if the URL is a dead link
          (when (not (file-exists-p urlStr))
            (progn

              ;; set p1 and p2 to be the start/end of the link tag
              ;; and get the entire link string
              (sgml-skip-tag-backward 1)
              (setq p1 (point) ) ; start of link tag
              (sgml-skip-tag-forward 1)
              (setq p2 (point) ) ; end of link tag
              (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

              ;; get link text
              (search-backward "</a>")
              (setq p4 (point) ) ; end of link text
              (search-backward ">")
              (forward-char 1)
              (setq p3 (point) ) ; start of link text
              (setq linkText (buffer-substring-no-properties p3 p4) )

              ;; remove the link, replace it with a non-link span text.
              (delete-region p1 p2)
              (insert
               "<span class=\"εlink\" title=\""
               urlStr
               "\">"
               linkText
               "</span>"
               )
              )
            )
          )

        ;; close the file if no changes made
        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )
#+END_SRC

** Complete Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the complete code.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-09-25
    ;; replace dead links in emacs manual on my website
    ;;
    ;; Example. This:
    ;; <a href="../widget/index.html#Top">Introduction</a>
    ;;
    ;; should become this
    ;;
    ;; <span class="εlink" title="../widget/index.html#Top">Introduction</span>
    ;;
    ;; do this for all files in a dir.

    ;; rough steps:
    ;; go thru each file
    ;; search for link
    ;; if the link is 「../xx/」 where the file doesn't exist, then replace the whole link tag.

    (setq inputDir "~/web/xahlee_org/emacs_manual/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (
            myBuff
            urlStr
            linkText
            wholeLinkStr
            p1 p2
            p3 p4
            )
        (setq myBuff (find-file fPath))
        (widen) ; in case it's open and narrowed
        (goto-char (point-max)) ; work from bottom, so that changes in point are preserved. (actually, doesn't really matter for this script)

        (while
            (search-backward "href=\"../" nil t)
          (forward-char 7)
          (setq urlStr (replace-regexp-in-string "\\.html#.+" ".html" (thing-at-point 'filename) ) )

          (when (not (file-exists-p urlStr))
            (progn
              (sgml-skip-tag-backward 1)
              (setq p1 (point) )                      ; start of link tag
              (sgml-skip-tag-forward 1)
              (setq p2 (point) )                      ; end of link tag

              (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

              (search-backward "</a>")
              (setq p4 (point) )                      ; end of link text
              (search-backward ">")
              (forward-char 1)
              (setq p3 (point) )                      ; start of link text

              (setq linkText (buffer-substring-no-properties p3 p4) )

              (princ (buffer-file-name))
              (princ "\n")
              (princ wholeLinkStr)
              (princ "\n")
              (princ "----------------------------\n")

              (delete-region p1 p2)
              (insert
               "<span class=\"εlink\" title=\""
               urlStr
               "\">"
               linkText
               "</span>"
               )
              )
            )
          )

        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )

    (require 'find-lisp)

    (font-lock-mode 0)

    (with-output-to-temp-buffer "*xah elisp dead link replace output*"
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )

    (font-lock-mode 1)
#+END_SRC

Here's few interesting parts.

*** Turn Syntax Coloring Off
    :PROPERTIES:
    :CLASS: calibre14
    :END:

We turn font lock off, by =(font-lock-mode 0)=. When font lock is on,
processing 2 thousand HTML files will take ~50 minutes. With syntax
coloring off, it's 3 minutes.

*** Leave Changed Files Open
    :PROPERTIES:
    :CLASS: calibre14
    :END:

If there are changes in the file, we leave it open. This way, we don't
have to revert to backup files if there's a mistake. If we like the
result, just call =ibuffer= and press * u to mark all un-saved, then S
to save all. Then press D to close them all. If you do not want to save
them, simply mark all unsaved * u then press D to close all.

This is extremely useful while you are still working on the code and
doing some test runs. This interactive nature of emacs is what beats
{Perl, Python, ...} for text processing.

If you do want to save the file in the script, simply call
=(save-buffer)= or =(write-file (buffer-file-name))=

When the file is not modified, we close it. Like this:
=(when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )=.

*** Use sgml-skip-tag-forward
    :PROPERTIES:
    :CLASS: calibre14
    :END:

The =sgml-skip-tag-forward= and =sgml-skip-tag-backward= are from
=html-mode=. They move the cursor to the beginning or ending of a tag.
They are extremely useful. It saves you a lot time in writing code to
parse tags, especially when tags are nested. Here's how we used it.

Suppose there's this link in a file:

#+BEGIN_SRC emacs-lisp
    <a href="../widget/index.html#Top">Introduction</a>
#+END_SRC

After we did the search with

#+BEGIN_SRC emacs-lisp
     (while
      (search-backward "href=\"../" nil t)
      …
     )
#+END_SRC

the cursor is on the “h”. While the cursor is inside the tag, we call:

#+BEGIN_SRC emacs-lisp
    (sgml-skip-tag-backward 1)
     (setq p1 (point) ) ; start of link tag
     (sgml-skip-tag-forward 1)
     (setq p2 (point) ) ; end of link tag

     (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )
#+END_SRC

This sets the value of wholeLinkStr to the entire anchor tag
=<a …>…</a>=.

*** Print Output to Your Own Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Printing output is done here using =with-output-to-temp-buffer= and
=princ=. Like this:

#+BEGIN_SRC emacs-lisp
    (with-output-to-temp-buffer "*xah elisp dead link replace output*"
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
#+END_SRC

Inside the “my-process-file” function, we write:

#+BEGIN_SRC emacs-lisp
    (princ (buffer-file-name))
     (princ "\n")
     (princ wholeLinkStr)
     (princ "\n")
     (princ "----------------------------\n")
#+END_SRC

Here's a output from the script:
[[file:elisp_fix_dead_links_output.txt]]. It lets me easily see if there
are any errors. There are a total of 68 changes.

For detail about printing in elisp, see:
[[file:elisp_printing.html][Elisp: Print, Output]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_fix_dead_links.html]]

\\
\\
| [[../index_u13.html#article_36][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u10.html>>

| [[../article_38/index_u21.html][下一项]] |
[[../index_u13.html#article_37][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_36/index_u39.html][上一项]] |

--------------

* Emacs Lisp vs Perl: Validate Local File Links
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-04-07. Last updated: 2020-05-11.

This page shows 2 scripts to validate HTML local file links (i.e. check
file existence of local links). One written in perl, one in elisp.

The 2 script's algorithms are not artificially made to be the same, but
follow the natural style/idiom for each lang. They do the same job for
my need.

** Perl
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For each file, call “process_file”. That function then calls
=get_links($file_full_path)= to get a list of links, then print the link
if it leads to a non-existent file.

The heart of the algorithm is the “get_links” function. It reads the
whole file content as one big string, then split the string by the char
“<”, then, for each segment of text, it proceed to find a link using
regex.

#+BEGIN_SRC emacs-lisp
    # -*- coding: utf-8 -*-
    # perl
    # 2004-09-21, …, 2012-04-07

    # given a dir, check all local links and inline images in the HTML files there. Print a report.
    # XahLee.org

    use strict;
    use Data::Dumper;
    use File::Find;
    use File::Basename;

    my $inDirPath = q{c:/Users/h3/web/xahlee_org/};

    # $inDirPath = $ARGV[0]; # should give a full path; else the $File::Find::dir won't give full path.

    die qq{dir $inDirPath doesn't exist! $!} unless -e $inDirPath;

    ##################################################
    # subroutines

    # get_links($file_full_path) returns a list of values in <a href="…">. Sample elements:  q[http://xahlee.org], q[../image.png], q[ab/some.html], q[file.nb], q[mailto:xah@xahlee.org], q[#reference], q[javascript:f('pop_me.html')]
    sub get_links ($) {
      my $full_file_path = $_[0];
      my @myLinks = ();
      open (FF, "<$full_file_path") or die qq[error: can not open $full_file_path $!];

      # read each line. Split on char “<”. Then use regex on 「href=…」 or 「src=…」 to get the url. This assumes that a tag 「<…>」 is not broken into more than one line.
      while (my $fileContent = <FF>) {
        my @textSegments = ();
        @textSegments = split(m/</, $fileContent);
        for my $oneLine (@textSegments) {
          if ($oneLine =~ m{href\s*=\s*"([^"]+)".*>}i) { push @myLinks, $1; }
          if ($oneLine =~ m{src\s*=\s*\"([^"]+)".*>}i) { push @myLinks, $1; }
        } }
      close FF;
      return @myLinks;
    }

    sub process_file {
      if (
          $File::Find::name =~ m[\.html$] &&
          $File::Find::dir !~ m(/xx)
         ) {
        my @myLinks = get_links($File::Find::name);

        map {
          s/#.+//; # delete url fragment identifier, eg http://example.com/index.html#a
          s/%20/ /g; # decode percent encode url
          s/%27/'/g;
          if ((!m[^http:|^https:|^mailto:|^irc:|^ftp:|^javascript:]i) && (not -e qq[$File::Find::dir/$_]) ) { print qq[• $File::Find::name $_\n];} }
          @myLinks;
     } }

    find(\&process_file, $inDirPath);

    print "\nDone checking. (any errors are printed above.)\n";
#+END_SRC

full updated code at
[[http://xahlee.info/perl/perl_validate_local_links.html][Perl: Validate
Local Links]]

** Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For each file, call “my-process-file”. Then, the file is put into a
buffer. Then, it uses regex search, and moving cursor, etc, to make sure
that we find links we want to check.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; elisp
    ;; 2012-02-01
    ;; check links of all HTML files in a dir

    ;; check only local file links in text patterns of the form:
    ;; < … href="link" …>
    ;; < … src="link" …>

    (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let ( $url $path p1 p2 p-current p-mb (checkPathQ nil) )

        ;; open file
        ;; search for a “href=” or “src=” link
        ;; check if that link points to a existing file
        ;; if not, report it

        (when (not (string-match "/xx" fPath)) ; skip file whose name starts with “xx”
          (with-temp-buffer
            (insert-file-contents fPath)
            (while
                (re-search-forward "\\(?:href\\|src\\)[ \n]*=[ \n]*\"\\([^\"]+?\\)\"" nil t)
              (setq p-current (point) )
              (setq p-mb (match-beginning 0) )
              (setq $url (match-string 1))

              (save-excursion
                (search-backward "<" nil t)
                (setq p1 (point))
                (search-forward ">" nil t)
                (setq p2 (point))
                )

              (when (and (< p1 p-mb) (< p-current p2) ) ; the “href="…"” is inside <…>
                ;; set checkPathQ to true for non-local links and xahlee site, eg http://xahlee.info/
                (if (string-match "^http://\\|^https://\\|^mailto:\\|^irc:\\|^ftp:\\|^javascript:" $url)
                    (when (string-match "^http://xahlee\.org\\|^http://xahlee\.info\\|^http://ergoemacs\.org" $url)
                      (setq $path (xahsite-url-to-filepath (replace-regexp-in-string "#.+$" "" $url))) ; remove trailing jumper url. For example: href="…#…"
                      (setq checkPathQ t)
                      )
                  (progn
                    (setq $path (replace-regexp-in-string "%27" "'" (replace-regexp-in-string "#.+$" "" $url)) )
                    (setq checkPathQ t)
                    )
                  )

                (when checkPathQ
                  (when (not (file-exists-p (expand-file-name $path (file-name-directory fPath))))
                    (princ (format "• %s %s\n" (replace-regexp-in-string "^c:/Users/h3" "~" fPath) $url) )
                    )
                  (setq checkPathQ nil) )

                ) ) ) ) ) )

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah check links output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
      )
#+END_SRC

** What's Valid HTML
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Note that the HTML files are assumed to be W3C valid (i.e. no missing
closing tags or missing “>”). However, my code are not general enough to
cover arbitrary valid HTML. SGML based HTML are very complex, and isn't
just nested tags, but such HTML are basically never used. The perl and
elisp code here work correctly (get all links) for perhaps 99.9% HTML
files out there. (symbolic links or other alias mechanisms on file
system are not considered.)

*** Edge Case Examples
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's some edge cases. These examples show that you cannot simply use
regex to search for the pattern =<a href="…" …>=. Here's a most basic
example:

#+BEGIN_SRC emacs-lisp
    <a href="math.html" title="x > y">math</a>
#+END_SRC

Note that the above is actually valid HTML according to W3C's validator.
Also, note that pages passing W3C validator are not necessarily valid by
W3C's HTML spec. [see
[[http://xahlee.info/js/w3c_html_validator_problem.html][W3C HTML
Validator Invalid]]]

One cannot simply use regex to search for pattern =<a href="…" …>=, and
this is especially so because some HTML pages contains sample HTML code
for teaching HTML, and ohters are programing tutorials containing code
example of using regex to parse HTML. So, the HTML is sometimes HTML
embedded in HTML, or HTML code in regex in python code on a HTML page.

The following shows that patterns such as =href="…"= or =src="…"= are
not necessarily HTML links.

[[file:feed_0/article_37/images/img1_u3.png]]

HTML in HTML, and HTML in regex in python code in HTML.

** Perl vs Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

One thing interesting is to compare the approaches in perl and emacs
lisp.

For our case, regex is not powerful enough to deal with the problem by
itself, due to the nested nature of HTML. This is why, in my perl code,
i split the file by “<” into segments first, then, use regex to deal
with now the non-nested segment. This will break if you have
=<a title="x < href=z" href="math.html">math</a>=. This cannot be worked
around unless you really start to write a real parser.

The elisp here is more powerful, not because of any lisp features, but
because emacs's buffer datatype. You can think of it as a glorified
string datatype, that you can move a cursor back and forth, or use regex
to search forward or backward, or save cursor positions (index) and grab
parts of text for further analysis.

also, might checkout my perl tutorial
[[http://xahlee.info/perl/perl_basics_1.html][Learn Perl in 1 Hour]]

**** Validate HTML File Local Links
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[http://xahlee.info/golang/golang_validate_links.html][Golang]]
- [[http://xahlee.info/perl/perl_validate_local_links.html][Perl]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_37/elisp_vs_perl_validate_links.xhtml][Emacs
  Lisp]]

- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]
- [[file:elisp_basics.html][Emacs Lisp Basics]]
- [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
- [[http://xahlee.info/UnixResource_dir/writ/notations_mma.html][Intro
  to Mathematica Pattern Matching for Lisp Programers]]
- [[http://xahlee.info/UnixResource_dir/writ/Mathematica_expressiveness.html][Normalize
  Function in Haskell, Ruby, Python, Perl, Scheme Lisp, JavaScript,
  Java, C]]

**** Misc Technical Essays on Emacs Lisp
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[../misc/elisp_naming_convention.html][Emacs Lisp Naming Convention]]
- [[../misc/emacs_lisp_some_and_every.html][Elisp: Some and Every]]
- [[../misc/emacs_lisp_what_is_fn.html][Elisp: What is the Function
  fn?]]
- [[../misc/elisp_symbol_vs_string_for_non_nil.html][Emacs Lisp: Symbol
  vs String]]
- [[../misc/elisp_list_function_type_syntax_coloring.html][Meaning of
  Lisp List, Function Type, and Syntax Coloring]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_37/elisp_vs_perl_validate_links.xhtml][Emacs
  Lisp vs Perl: Validate Local File Links]]
- [[../emacs/elisp_text_processing_lang.html][Text Processing: Emacs
  Lisp vs Perl]]
- [[../emacs/elisp_namespace_solution_copying_javascript_practice.html][Can
  Emacs Lisp Fix Its Namespace Problem by Copying JavaScript Practice?]]
- [[../misc/js_tutorial_and_emacs_lisp_vs_javascript.html][Emacs Lisp vs
  JavaScript?]]
- [[../emacs/elisp_common_lisp_in_emacs.html][Controversy of Common Lisp
  Package in Emacs Lisp]]
- [[../emacs/lisp_list_problem.html][Lisp's List Problem]]
- [[../emacs/lisp1_vs_lisp2.html][Lisp-1 vs Lisp-2]]
- [[../emacs/modernization_elisp_lib_problem.html][Emacs Lisp Problems:
  Trim String, Regex Match Data, Lacking Namespace]]
- [[../emacs/thing-at-point_chaining_functions.html][Functional
  Programing: Function Output Should Always Have the Same Structure]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_vs_perl_validate_links.html]]

\\
\\
| [[../index_u13.html#article_37][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u21.html>>

| [[../article_39/index_u27.html][下一项]] |
[[../index_u13.html#article_38][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_37/index_u10.html][上一项]] |

--------------

* Elisp: Text Processing, Transforming Page Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-10-29. Last updated: 2015-05-08.

This page shows a example of using emacs lisp for text processing. It is
used to update HTML page's navigation bar.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You have hundreds of HTML pages that have a nav bar like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="1.html">1</a>,
    <a href="2.html">2</a>,
    <a href="3.html">3</a>,
    …
    </div>
#+END_SRC

It looks like this in browser (with
[[http://xahlee.info/js/css_index.html][CSS]]):

[[file:feed_0/article_38/images/img1_u1.png]]

This is the page navigation bar. Note that the page contains a link to
itself.

You want to remove the self-link. The result should look like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    1,
    <a href="2.html">2</a>,
    <a href="3.html">3</a>,
    …
    </div>
#+END_SRC

[[file:feed_0/article_38/images/img2.png]]

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here are the steps we need to do for each file:

1. open the file.
2. move cursor to the beginning of page navigation string.
3. move cursor to file name.
4. call =sgml-delete-tag= to remove the anchor tag. (=sgml-delete-tag=
   is from =html-mode=)
5. save file.
6. close buffer.

We begin by writing a test code to process a single file.

#+BEGIN_SRC emacs-lisp
    (defun my-process-file-navbar (fPath)
      "Modify the HTML file at fPath."
      (let (fName myBuffer)
        (setq fName (file-name-nondirectory fPath))
        (setq myBuffer (find-file fPath))
        (widen) ; in case buffer already open, and narrow-to-region is in effect
        (goto-char 1)
        (search-forward "<div class=\"pages\">Goto Page:")
        (search-forward fName)
        (sgml-delete-tag 1)
        (save-buffer)
        (kill-buffer myBuffer)))

    (my-process-file-navbar "~/test1.html")
#+END_SRC

For testing, create files {=test1.html=, =test2.html=, =test3.html=} in
a temp directory for testing this code. Place the following content into
each file:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page: <a href="test1.html">XYZ Overview</a>, <a href="test2.html">Second Page</a>, <a href="test3.html">Summary Z</a></div>
#+END_SRC

(note that the link text may not be 1, 2, 3.)

The elisp code above is very basic.

- =find-file= → open file. [[../emacs_manual/elisp/Files.html][(info
  "(elisp) Files")]]
- =search-forward= → move cursor.
  [[../emacs_manual/elisp/Buffers.html][(info "(elisp) Buffers")]]
- =kill-buffer= → close buffer.
  [[../emacs_manual/elisp/Searching-and-Matching.html][(info "(elisp)
  Searching and Matching")]].

=sgml-delete-tag= is from =html-mode= (which is automatically loaded
when a HTML file is opened).

=sgml-delete-tag= deletes the opening/closing tags tags the cursor is
on.

All we need to do now is to feed it a bunch of file paths.

To get the list of files that contains the page-nav tag, we can simply
use linux's “find” and “grep”, like this:

#+BEGIN_SRC emacs-lisp
    find . -name "*\.html" -exec grep -l '<div class="pages">' {} \;
#+END_SRC

From the output, we can use
[[file:emacs_string-rectangle_ascii-art.html][string-rectangle]] and
[[file:emacs_find_replace.html][query-replace]], to construct the
following code:

#+BEGIN_SRC emacs-lisp
    (mapc 'my-process-file-navbar
          [
           "~/web/cat1html"
           "~/web/dog.html"
           "~/web/something.html"
           "~/web/xyz.html"
           ]
          )
#+END_SRC

The =mapc= is a lisp idiom of looping thru a
[[file:elisp_list.html][list]] or [[file:elisp_vector.html][vector]].
The first argument is a function. The function will be applied to every
element in the list. The single quote in front of the function is
necessary. It prevents the symbol “my-process-file-navbar” from being
evaluated (as a expression of a variable).

Emacs ♥

- [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
  Transform FAQ Tags]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text_processing.html]]

\\
\\
| [[../index_u13.html#article_38][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u27.html>>

| [[../article_40/index_u4.html][下一项]] |
[[../index_u13.html#article_39][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_38/index_u21.html][上一项]] |

--------------

* Process HTML with Emacs Lisp: Transform FAQ Tags
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-11-30. Last updated: 2012-04-18.

This page shows a example of using emacs lisp to do a text processing
job; It shows how emacs buffer type has significant advantage than Perl,
Python for processing nested text.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want to write a elisp program, that process a HTML file in a somewhat
complex way. Specifically, certain strings must be replaced only if they
appear inside a tag and or only if they are first child.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have many web pages that are in Questions And Answers format. The
following is a sample screenshot.

[[file:feed_0/article_39/images/img1_u2.png]]

The following is a example of the raw HTML:

#+BEGIN_SRC emacs-lisp
    <p class="q">Q: Why …</p>
    <p class="a">A: Because …</p>
    <p class="a">You need to do …</p>
    …
    <p class="q">Q: How …</p>
    <p class="a">A: Do this …</p>
    <p class="a">And that …</p>
    …
#+END_SRC

Basically, each Question section is a paragraph of class “q”, and each
Answer section is several =<p>= tags with class “a”.

After a few years with this format, i started to use a better format.
Specifically, a Answer section should just be wrapped with a single
=<div class="a">…</div>=. And, the “Q: ” and “A: ” string are removed
from content (because CSS can insert that automatically, like this:
=p.q:before {content:"Q: "}=.). Here's a example of the new format:

#+BEGIN_SRC emacs-lisp
    <p class="q">Why?</p>

    <div class="a">
    <p>Because this.</p>
    <p>You need to that.</p>
    </div>
#+END_SRC

The task i have now, is to transform existing pages to this new format.
Here's what needs to be done precisely:

For any consecutive blocks of =<p class="a">…</p>=, wrap them with a
=<div class="a">= and =</div>=, then replace those =<p class="a">= by
=<p>=. Also, remove those “Q: ” and “A: ”.

Although this is simple in principle, but without using a HTML parser,
it's hard to code it as described. Using a HTML parser has its own
problems. The HTML/DOM model would make the code much more complex, and
the output will change the placement of whitspaces. Unless we are doing
XML transformation on a larger scale, the HTML/DOM parser is usually not
what we want. A text-based search-and-replace algorithm to achieve the
above is as follows:

For each occurrence of =<p class="q">=, do the following:

- Add a =<div class="a">= right after =<p class="q">…</p>=.
- Add a =</div>= right before =<p class="q">=.
- Replace =<p class="q">Q: = by =<p class="q">=, replace
  =<p class="a">A: = by =<p class="a">=

then:

- Replace the first occurrence of =</div>= that happens before the first
  occurrence of =<p class="q">=.
- Add a =</div>= that happens after the last =<p class="a">…</p>= tag.
- Replace all =<p class="a">= to =<p>=.

We proceed to write a elisp code to solve this problem.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The algorithm described sounds simple, but isn't trivial if you do it in
Perl or Python. For example, one of the step is:

#+BEGIN_QUOTE
  Add a =<div class="a">= right after =<p class="q">…</p>=.
#+END_QUOTE

It would involve some coding to get the meaning of “right after”
correct. Similarly, other steps involves finding a string immediately
before or after occurrences of another string, with condition such as no
more of a string comes after.

With emacs, this is much easier, because emacs has buffer representation
of files with a pointer that can move back and forth. So, we can just
search by regex forward or backward and freely move our cursor and
compare positions to locate the right piece of text.

First, we write a prototype that just works on a single file. Here's the
code:

#+BEGIN_SRC emacs-lisp
    (defun xx ()
      "temp test function"
      (interactive)
      (find-file "elisp_process_html_sample.html")
      (goto-char 1)

    ;; add opening and closing tags for answer section
    ;; this is done by locating the opening question tag,
    ;; then move to the end of tag, then insert <div class="a">
    ;; then, locate the next opening question tag but move backward to </p>,
    ;; then insert </div>
      (while (search-forward "<p class=\"q\">" nil t)
        (search-forward "<p class=\"a\">")
        (replace-match "<div class=\"a\">\n<p class=\"a\">")
        (if (search-forward "<p class=\"q\">" nil t)
            (progn
              (search-backward "</p>")
              (forward-char 4)
              (insert "\n</div>")
              )
          )
        )

    ;; add the last closing tag for answer section
      (end-of-buffer)
      (search-backward "<p class=\"a\">")
      (search-forward "</p>")
      (insert "\n</div>")

    ;; take out the “Q: ” and “A: ”
      (beginning-of-buffer)
      (while (search-forward "<p class=\"q\">Q: " nil t)
        (replace-match "<p class=\"q\">"))

    ;; replace “<p class="a">” by “<p>”.
      (beginning-of-buffer)
      (while (search-forward "<p class=\"a\">A: " nil t)
        (replace-match "<p>"))
    )
#+END_SRC

This is a simple code. It uses emac's power of buffer data structure for
files, by moving a pointer back and forth to a desired place, then do
search and replace text or insert. With the ability of moving a point to
a particular string, we are able to locate the places we want the tag
insertion to happen, without explicitly going by the DOM model of
parent-child relationship of tags.

In the above code, the =search-forward= function moves the cursor to the
end of matched text. It returns “nil” if not found. The
=search-backward= works similarly, but put the point on the beginning of
matched text.

The =replace-match= just replaces previously matched text. The
=end-of-buffer= moves the point to the end of buffer. Similarly for
=beginning-of-buffer=.

[[../emacs_manual/elisp/String-Search.html][(info "(elisp) String
Search")]]

Now, if we want to process many files, first we need to change the code
to take a file path, and add code to save buffer and close buffer. Like
this:

#+BEGIN_SRC emacs-lisp
    (defun my-process-html (fPath)
      "Process a file at FPATH…"
      (let (myBuffer)
        (setq myBuffer (find-file fPath))
        ; code body here
        (save-buffer)
        (kill-buffer myBuffer)
      )
    )
#+END_SRC

To get the list of files containing the Q and A section, we can simply
use unix's “find” and “grep”, like this:
=find . -name "*\.html" -exec grep -l '<p class="q">' {} \;=. (or just
use emacs. See: [[file:elisp_grep_script.html][Elisp: Write grep]].)

Then, place the list of files into a list and map over the list, like
this:

#+BEGIN_SRC emacs-lisp
    (mapc 'my-process-html
            (list
    "/Users/xah/web/emacs/emacs_adv_tips.html"
    "/Users/xah/web/emacs/emacs_display_faq.html"
    "/Users/xah/web/emacs/emacs_esoteric.html"
    "/Users/xah/web/emacs/emacs_html.html"
    "/Users/xah/web/emacs/emacs_n_unicode.html"
    "/Users/xah/web/emacs/emacs_unix.html"
    "/Users/xah/web/emacs/keyboard_shortcuts.html"
    "/Users/xah/web/emacs/modernization.html"
    "/Users/xah/web/img/imagemagic.html"
    "/Users/xah/web/java-a-day/abstract_class.html"
    "/Users/xah/web/sl/build_q.html"
    "/Users/xah/web/sl/q.html"
    "/Users/xah/web/UnixResource_dir/macosx.html"
    "/Users/xah/web/UnixResource_dir/writ/mshatredfaq.html"
    "/Users/xah/web/UnixResource_dir/writ/tabs_vs_spaces.html"
             )
    )
#+END_SRC

The =mapc= is a lisp idiom of applying a function to all elements in a
list. The first argument is a function. The second argument is a list.
The single quote in front of the function is necessary. It prevents the
function from being evaluated. Otherwise, normally lisp evaluates all
arguments in the expression =(f a b c …)=.

(thanks to Ivanov Dmitry for a correction in the elisp code.)

Emacs ♥

- [[file:elisp_text_processing.html][Elisp: Text Processing,
  Transforming Page Tag]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_process_html.html]]

\\
\\
| [[../index_u13.html#article_39][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u4.html>>

| [[../article_41/index_u25.html][下一项]] |
[[../index_u13.html#article_40][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_39/index_u27.html][上一项]] |

--------------

* Elisp: Process HTML, span, code, Key, Title, Markups
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-08-29. Last updated: 2014-01-05.

This page is a tutorial, showing a real-world example of using emacs
lisp to do many tag transformation.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I need to transform many HTML tags. Typically, they are of the form
=begin_delimiter…end_delimiter=, where the delimiters may be curly
quotes =“…”=, or it may be a HTML tag such as
=<span class="xyz">…</span>=.

I need to apply the transformation on over 4 thousand HTML pages, and
needs it to be accurate, mostly on a case-by-case base with human watch.

Also, the delimiters may be nested, so regex won't work. They either
getting too much text (using default greedy match) or getting not enough
text (using shy group). With a elisp script, you can use =if= and other
emacs functions, to correctly find the matching ending tag, as well
automatically skip cases that this transform should not apply, so
drastically reduce the need for human watch.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

In the past week, i spend about 2 days and done a lot text processing
with elisp on the 4 thousand files of my site. Here's the changes i've
made:

- book title. For example: “Art Of Programing” ⇒ 〈Art Of Programing〉
- article title. For example: “How to Edit Elisp Code with Emacs” ⇒
  〈How to Edit Elisp Code with Emacs〉
- computer code. For example: “(setq x 1)” ⇒ 「(setq x 1)」
- file path. For example: “~/Documents/emacs/” ⇒ 〔~/Documents/emacs/〕
- keyboard shortcut notation. For example: “Ctrl+c” ⇒ 【Ctrl+c】

The purpose of the change is to make the syntactical markup more
semantically precise. Before, they are all marked by double curly
quotes. Now, if i want to find all books i cited on my site, i can do so
easily by a simple search on a special bracket for book titles. These
changes also make the text easier to read. In the future, if i want all
book titles to be colored red for example, i can easily do that by
changing the 《》 to a HTML markup (For example,
=<span class="title">…</span>=), or use a JavaScript to do that on the
fly. Same for emacs keybinding. For example, with this clear syntax,
it's easier to write a [[http://xahlee.info/js/js.html][JavaScript]] so
that when mouse is hovering over the keybinding notation, it shows a
balloon of the command name for that key. [see
[[http://xahlee.info/js/tooltips.html][JavaScript: How to Create
Tooltip/Balloon]]]

All this is part of the
[[http://xahlee.info/js/html_microformat.html][HTML Microformat]], which
is part of semantic web concept. The basic ideas is that, the syntax
encodes semantics. This advantage is part of the major reason XML
becomes so useful. (the other reason is its regular syntax.)

For info on various brackets used, see:
[[http://wordyenglish.com/musing/chinese_punctuation.html][Intro to
Chinese Punctuation]] and
[[http://xahlee.info/comp/unicode_matching_brackets.html][Matching
Brackets in Unicode]].

Also, much of the HTML markup on my site has been cleaned up. For
example:

- =<span class="code">…</span>= ⇒ =<code>…</code>=
- =“<span class="code">…</span>”= ⇒ =<code>…</code>= (Remove the
  redundant curly quote. Was a struggle to make a decision on this. Note
  that it can be auto added with
  [[http://xahlee.info/js/index.html][Cascading Style Sheet (CSS)]] if
  needed.)
- =<span class="key">…</span>= ⇒ =<kbd>…</kbd>= (Change to standard tag;
  reduce char count.)
- =<span class="kbd">…</span>= ⇒ =…= (Remove the tag. Was designed to
  mark emacs key notation, but doesn't make much sense. Now, 【】 does
  it.)

There are several advantages in these changes. For example, =<code>= is
much shorter than =<span class="code">=, and it has a standard meaning.
It is also more unique than “span” tag, so that reduce parsing
complexity when i need to process “span” tags.

[see
[[http://xahlee.info/kbd/keyboard_notation_design_issues.html][Keyboard
Notation Design Issues]]]

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To do these tag transformations, simple cases such as

#+BEGIN_SRC emacs-lisp
    “file path” ⇒ 〔file path〕
#+END_SRC

, where the delimiters are single characters and there's no nesting,
they can be done with emacs's =dired-do-query-replace-regexp=. [see
[[file:find_replace_inter.html][Emacs: Find Replace Text in Directory]]]

More complicated cases with nested HTML tags, can be done with a elisp
script. Here's the general plan.

1. Open the file
2. Search for the tag
3. If found, move to the beginning of tag, mark positions of begin/end
   of the opening tag
4. Use =sgml-skip-tag-forward= to move to the end matching tag
5. Mark positions of begin/end of the ending tag
6. Replace the begin/end tags with new tags
7. Repeat

To open the file, we can use =find-file=.

To search for the tag, we do:

#+BEGIN_SRC emacs-lisp
    (while
     (search-forward "<span class=\"code\">"  nil t)
    …
    )
#+END_SRC

We give “t” for the third argument. It means don't complain if not
found.

The next step is to get the begin/end positions of the opening tag. The
end position is simply the current cursor position, because the
search-forward automatically place it there. To get the beginning
position, we just use search-backward on “<”

Now, we need to get the begin/end positions of the matching end tag.
This may be a problem because the tags are nested, so there may be many
=</span>= before the one we want.

The good thing is that emacs's =html-mode= has =sgml-skip-tag-forward=
function. It will move cursor from a beginning tag to its matching end
tag.

Once we got the begin/end positions for the begin/end tags, we can now
easily do replacement. Just use =delete-region=, then use =insert= to
insert the new tag we want. One thing important is that we should do
replacement with the ending tag first, because if we replace the
beginning tag first, the positions of the ending tag will be changed.

*** Complete Code
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2010-08-25

    ;; change
    ;; <span class="code">…</span>
    ;; to
    ;; 「…」

    (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "process the file at fullpath fPath …"
      (let ( myBuff changedQ p3 p4 p8 p9)

        ;; open the file
        ;; search for the tag
        ;; if found, move to the beginning of tag, mark positions of begin/end of < and >
        ;; use sgml-skip-tag-forward to move to the end matching tag </span>
        ;; mark positions of begin/end of < and >
        ;; replace them with 「 and 」
        ;; repeat
        (setq myBuff (find-file fPath ) )
        (setq changedQ nil )

        (goto-char 1)
        (while
            (search-forward "<span class=\"code\">"  nil t)
          (backward-char 1)
          (if (looking-at ">")
              (setq p4 (1+ (point)) )
            (error "expecting <" )
            )

          ;; go to beginning of "<span class="code">"
          (sgml-skip-tag-backward 1)
          (if (looking-at "<")
              (setq p3 (point) )
            (error "expecting <" )
            )
          (forward-char 2)

          ;; go to end of </span>
          (sgml-skip-tag-forward 1)
          (backward-char 1)
          (if (looking-at ">")
              (setq p9 (1+ (point)) )
            (error "expecting >" )
            )

          ;; go to beginning of </span>
          (backward-char 6)
          (if (looking-at "<")
              (setq p8 (point) )
            (error "expecting <" )
            )

          (when (y-or-n-p "change? ")
            (delete-region p8 p9  )
            (insert "」")
            (delete-region p4 p3 )
            (goto-char p3)
            (insert "「")
            (setq changedQ t )
            ))

        ;; if not changed, close it. Else, leave buffer open
        (if changedQ
            (progn (make-backup))                        ; leave it open
          (progn (kill-buffer myBuff))
          )
        ))

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*span tag to code tag*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
      )
#+END_SRC

In the code above, i also put extra checks to make sure that the
position of beginning tag is really the =<= char. Same for ending tag.
(probably redundant, but i tend to be extra careful.)

Also, i used a =y-or-n-p= function, so emacs will prompt me for each
change that i can visually check.

For those files that are changed, i leave them open. So, if i decided on
a whim i don't want all these to happen on potentially hundreds of files
that i've changed, i can simply close all the buffer with 4 keystrokes
with =ibuffer=. Same if i want to save them all. [see
[[file:emacs_buffer_management.html][Emacs: ibuffer tutorial]]]

For files that no change takes place, the buffer is simply closed.

In the above, i also called “make-backup”. I want to make a backup of
changed file, but not relying on emac's automatic backup mechanism (i
have it turned off). For the code, see:
[[file:elisp_make-backup.html][Emacs: Backup Current File]].

Emacs is fantastic!

- [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
  Transform FAQ Tags]]
- [[file:elisp_text_processing.html][Elisp: Text Processing,
  Transforming Page Tag]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_transform_html_tags.html]]

\\
\\
| [[../index_u13.html#article_40][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u25.html>>

| [[../article_42/index_u32.html][下一项]] |
[[../index_u13.html#article_41][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_40/index_u4.html][上一项]] |

--------------

* Elisp: Batch Transform HTML to HTML5 “figure” Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-03

Another triumph of using elisp for text processing over {Perl, Python}.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want batch transform the image tags in 5 thousand HTML files to use
HTML5's new “figure” and “figcaption” tags.

I want to be able to view each change interactively, while optionally
give it a “go ahead” to do the whole job in batch.

Interactive eyeball verification on many cases lets me be reasonably
sure the transform is done correctly. It also lets me see whether i want
to push forward with this change.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[http://xahlee.info/js/html5_tags.html][HTML5]] has the following new
tags: “figure” and “figcaption”. They are used like this:

#+BEGIN_SRC emacs-lisp
    <figure>
    <img src="cat.jpg" alt="my cat" width="167" height="106">
    <figcaption>my cat!</figcaption>
    </figure>
#+END_SRC

(For detail, see:
[[http://xahlee.info/js/html5_figure_figurecaption.html][HTML5 “figure”
and “figurecaption” Tags Browser Support]])

On my website, i used a similar structure. They look like this:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="cat.jpg" alt="my cat" width="167" height="106">
    <p class="cpt">my cat!</p>
    </div>
#+END_SRC

So, i want to replace them with the HTML5's new tags. This can be done
with a regex. Here's the “find” regex:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    ?<img src="\([^"]+?\)" alt="\([^"]+?\)" width="\([0-9]+?\)" height="\([0-9]+?\)">?
    <p class="cpt">\([^<]+?\)</p>
    ?</div>
#+END_SRC

Here's the replacement string:

#+BEGIN_SRC emacs-lisp
    <figure>
    <img src="\1" alt="\2" width="\3" height="\4">
    <figcaption>\5</figcaption>
    </figure>
#+END_SRC

Then, you can use =find-dired= and dired's
=dired-do-query-replace-regexp= to work on your 5 thousand pages. Nice.
[see [[file:find_replace_inter.html][Emacs: Find Replace Text in
Directory]]]

However, the problem here is more complicated. There may be more than
one image per group. Also, the caption part may also contain complicated
HTML. Here's some examples:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="cat1.jpg" alt="my cat" width="200" height="200">
    <img src="turtle.jpg" alt="my turtle" width="200" height="200">
    <p class="cpt">my cat and my turtle</p>
    </div>
#+END_SRC

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="jamie_cat.jpg" alt="jamie's cat" width="167" height="106">
    <p class="cpt">jamie's cat! Her blog is <a href="http://example.com/jamie/">http://example.com/jamie/</a></p>
    </div>
#+END_SRC

So, a solution by regex is out.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The solution is pretty simple. Here's the major steps:

1. Use =find-lisp-find-files= to traverse a dir. Needes
   =(require 'find-lisp)=.
2. For each file, open it.
3. Search for the string =<div class="img">=.
4. Use =sgml-skip-tag-forward= to jump to its closing tag.
5. Save the positions of these tag begin/end positions.
6. Ask user if she wants to replace. If so, do it. (using
   =delete-region= and =insert=)
7. Repeat.

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-07-03
    ;; replace image tags to use HTML5's “figure”  and “figcaption” tags.

    ;; Example. This:
    ;; <div class="img">…</div>
    ;; should become this
    ;; <figure>…</figure>

    ;; do this for all files in a dir.

    ;; rough steps:
    ;; find the <div class="img">
    ;; use sgml-skip-tag-forward to move to the ending tag.
    ;; save their positions.
    ;; ask user whether to replace, if so, delete them and insert new string

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (myBuff p1 p2 p3 p4 )
        (setq myBuff (find-file fPath))

        (widen)
        (goto-char 1) ;; in case buffer already open

        (while (search-forward "<div class=\"img\">" nil t)
          (progn
            (setq p2 (point) )
            (backward-char 17) ; beginning of “div” tag
            (setq p1 (point) )

            (forward-char 1)
            (sgml-skip-tag-forward 1) ; move to the closing tag
            (setq p4 (point) )
            (backward-char 6) ; beginning of the closing div tag
            (setq p3 (point) )
            (narrow-to-region p1 p4) 

            (when (y-or-n-p "replace?")
              (progn 
                (delete-region p3 p4 )
                (goto-char p3)
                (insert "</figure>")

                (delete-region p1 p2 )
                (goto-char p1)
                (insert "<figure>")
                (widen) ) ) ) )

        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah img/figure replace output*" )
      (with-output-to-temp-buffer outputBuffer 
        (mapc 'my-process-file (find-lisp-find-files "~/web/xahlee_org/emacs/" "\\.html$"))
        (princ "Done deal!")
        ) )
#+END_SRC

Seems pretty simple right?

The “p1” and “p2” variables are the positions of start/end of
=<div class="img">=. The “p3” and “p4” is the start/end of its closing
tag =</div>=.

We also used a little trick with =widen= and =narrow-to-region=. It lets
me see just the part that i'm interested. It narrows to the
beginning/end of the div.img. This makes eyeballing a bit easier.

The real time-saver is the =sgml-skip-tag-forward= function from
=html-mode=. Without that, one'd have to write a mini-parser to deal
with HTML's nested ways to be able to locate the proper ending tag.

Using the above code, i can comfortably eyeball and press “y” at the
rate of about 5 per second. That makes 300 replacements per minute. I
have 5000+ files. If we assume there are 6k replacement to be made, then
at 5 per second means 20 minutes sitting there pressing “y”. Quite
tiresome.

So, now, the next step is simply to remove the asking
=(y-or-n-p "replace?")=. Or, if i'm absolutely paranoid, i can make
emacs write into a log buffer for every replacement it makes (together
with the file path). When the batch replacement is done (probably takes
1 or 2 minutes), i can simply scan thru the log to see if any
replacement went wrong. For a example of that, see:
[[file:elisp_replace_title_tags.html][Elisp: Multi-Pair String
Replacement with Report]].

Also note that i left each changed file unsaved in emacs. If i decided i
didn't want to commit the changes, i can exit emacs without saving. Or,
i can go to =ibuffer= and press 3 keys to save and close them all * u S.
But if you want them saved with elisp, you can just add =(save-buffer)=.
Note that emacs automatically makes a backup~ of the original files if
you haven't turned that off.

But what about replacing =<p class="cpt">…</p>= with
=<figcaption>…</figcaption>=?

I simply copy-pasted the above code into a new file, and make changes in
4 places. So, the replacing figcaption part is done in a separete second
batch job. Of course, one could spend extra hour to make the code do
them both in one pass, but that extra time of thinking and coding isn't
worthwhile for this one-time job.

I ♥ Emacs, do you?

*** Change in Current Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's the code that changes both {div.img, p.cpt} to {figure,
figcaption} in one shot, on the current buffer. It output the changes to
a temp buffer, so you can scan it.

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-wrap-img-figure ()
      "Change current buffer's <div class=\"img\"> to <figure> and <p class=\"cpt\"> to <figcaption>."
      (interactive)

      (save-excursion 
        (let (p1 p2 p3 p4 
                 myStr
                 $changes
                 (changedItems '())
                 (myBuff (current-buffer))
                 )

          (goto-char (point-min)) ;; in case buffer already open
          (while (search-forward "<div class=\"img\">" nil t)
            (progn
              (setq p2 (point) )
              (backward-char 17)
              (setq p1 (point) )

              (forward-char 1)
              (sgml-skip-tag-forward 1)
              (setq p4 (point) )
              (backward-char 6)
              (setq p3 (point) )

              (when t
                (setq myStr (buffer-substring-no-properties p1 p4))
                (setq changedItems (cons myStr changedItems ) )
                
                (progn 
                  (delete-region p3 p4 )
                  (goto-char p3)
                  (insert "</figure>")

                  (delete-region p1 p2 )
                  (goto-char p1)
                  (insert "<figure>")
                   )
                ) ) )

          (goto-char (point-min)) ;; in case buffer already open
          (while (search-forward "<p class=\"cpt\">" nil t)
            (progn
              (setq p2 (point) )
              (backward-char 15)
              (setq p1 (point) )

              (forward-char 1)
              (sgml-skip-tag-forward 1)
              (setq p4 (point) )
              (backward-char 4)
              (setq p3 (point) )

              (when t
                (setq myStr (buffer-substring-no-properties p1 p4))
                (setq changedItems (cons myStr changedItems ) )
                
                (progn 
                  (delete-region p3 p4 )
                  (goto-char p3)
                  (insert "</figcaption>")

                  (delete-region p1 p2 )
                  (goto-char p1)
                  (insert "<figcaption>")
                   )
                ) ) )

          (with-output-to-temp-buffer "*changed items*" 
            (mapc (lambda ( $changes) (princ $changes) (princ "\n\n") ) changedItems)
            (set-buffer "*changed items*")
            (funcall 'html-mode)
            (set-buffer myBuff)
            ) )) )
#+END_SRC

PS if you are wondering about that weird char “ξ” in the variable name,
don't mind it, it's my personal experiment in variable naming. See:
[[http://xahlee.info/comp/programing_variable_naming.html][Variable
Naming: English Words Considered Harmful]].

- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]
- [[file:elisp_batch_html_tag_transform_bold.html][Elisp: Processing
  HTML: Transform Tags from “span.w” to “b”]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_batch_html5_tag_transform.html]]

\\
\\
| [[../index_u13.html#article_41][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u32.html>>

| [[../article_43/index_u1.html][下一项]] |
[[../index_u13.html#article_42][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_41/index_u25.html][上一项]] |

--------------

* Elisp: Transform HTML Tags from “span” to “b”
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-18. Last updated: 2017-06-17.

This page shows a simple practical elisp script for HTML tag
transformation.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want transform the HTML tag

=<span class="w">…</span>=

to

=<b>…</b>=

, for over a hundred files. Also, print a report of the changes.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

1. Open the file. Use regex to search the span markup.
2. Make the replacement.
3. Add the replacement to a list, for later report.
4. Repeat the above until no more found.
5. Use a dir traverse function to apply the above to every file. [see
   [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]]
6. When done, print the list of changes.

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-07-18
    ;; replace <span class="w">…</span> to <b>…</b>
    ;;
    ;; do this for all files in a dir.

    (setq inputDir "~/web/vocabulary/" ) ; dir should end with a slash

    (setq changedItems '())

    (defun my-process-file (fPath)
      "Process the file at FPATH …"
      (let (myBuff myWord)
        (setq myBuff (find-file fPath))

        (widen) (goto-char 1) ;; in case buffer already open

        (while (re-search-forward "<span class=\"w\">\\([^<]+?\\)</span>" nil t)
          (setq myWord (match-string 1))
          (when (< (length myWord) 15) ; a little double check in case of possible mismatched tag
            (replace-match (concat "<b>" myWord "</b>" )  t)
            (setq changedItems (cons (substring-no-properties myWord) changedItems ) )
            ) )

        ;; close buffer if there's no change. Else leave it open.
        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )
        ) )

    (require 'find-lisp)

    (setq make-backup-files t)
    (setq case-fold-search nil)
    (setq case-replace nil)

    (let (outputBuffer)
      (setq outputBuffer "*xah span.w to b replace output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (print changedItems)
        (princ "Done deal!")
        )
      )
#+END_SRC

Here's the output:
[[file:elisp_batch_html_tag_transform_bold_output.txt]].

There are over 1k changes. The output is extremely useful because i can
just take a few seconds to glance at the output to know there are no
errors. Errors are possible because whenever using regex to parse HTML,
a missing tag in HTML or even a unexpected nested tag, can mean
disaster.

The code is simple. If you don't understand it, see:

- [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
- [[file:elisp_idioms.html][Elisp: How to Write Commands]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_batch_html_tag_transform_bold.html]]

\\
\\
| [[../index_u13.html#article_42][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u1.html>>

| [[../article_44/index_u12.html][下一项]] |
[[../index_u13.html#article_43][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_42/index_u32.html][上一项]] |

--------------

* Elisp: How to Write a Toggle Command
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-20. Last updated: 2020-04-19.

This page is a tutorial on how to write a command to toggle something.

Here's a example to toggle background color.

#+BEGIN_SRC emacs-lisp
    (defun xah-toggle-background-color ()
      "Toggle background color between seashell and honeydew.
    URL `http://ergoemacs.org/emacs/elisp_toggle_command.html'
    Version 2015-12-17"
      (interactive)
      ;; use a property “state”. Value is t or nil
      (if (get 'xah-toggle-background-color 'state)
          (progn
            (set-background-color "seashell")
            (put 'xah-toggle-background-color 'state nil))
        (progn
          (set-background-color "honeydew")
          (put 'xah-toggle-background-color 'state t))))
#+END_SRC

The gist to toggle, is to have a variable that we can set as current
state.

But usually, we don't want to use a global variable.

The trick here, is to create a property for the function. In Emacs lisp,
each symbol can have one or more properties. A property is basically a
variable, but associated with the symbol only.

[see [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]

Here, we create a property named “state”. The value is =t= or =nil=.

** Cycle Among States
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can create a command that cycle between many states.

Here's a example.

#+BEGIN_SRC emacs-lisp
    (defun xah-cycle-background-color (@n)
      "Cycle background color among a preset list.

    If `universal-argument' is called first, cycle n steps. Default is 1 step.

    URL `http://ergoemacs.org/emacs/elisp_toggle_command.html'
    Version 2015-12-17"
      (interactive "p")
      ;; uses a property “state”. Value is a integer.
      (let* (
             ($values ["cornsilk" "pale green" "pale turquoise" "thistle" "seashell" "honeydew"])
             ($index-before
              (if (get 'xah-cycle-background-color 'state)
                  (get 'xah-cycle-background-color 'state)
                0))
             ($index-after (% (+ $index-before (length $values) @n) (length $values)))
             ($next-value (aref $values $index-after)))

        (put 'xah-cycle-background-color 'state $index-after)

        (set-background-color $next-value)
        (message "background color changed to %s" $next-value)))
#+END_SRC

Here, we create a property named “state”. The value is a integer.

In the function body, we have a variable that is the list of possible
values. The property “state”, is used as index to this list.

Each time the command is called, we check current state, then, use
modular arithmetic over the length of states list to get the next value
(integer index). Then, we set the value, and update the state.

To create your own cycle something command, simply change the value list
to what you want.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_toggle_command.html]]

\\
\\
| [[../index_u13.html#article_43][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u12.html>>

| [[../article_45/index_u34.html][下一项]] |
[[../index_u13.html#article_44][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_43/index_u1.html][上一项]] |

--------------

* Emacs: Uncolor Region/Buffer
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-01-09. Last updated: 2017-05-31.

Normally, you can Alt+x =font-lock-mode= to turn off syntax coloring.

But if you copied some text from another buffer into a new buffer,
turning off =font-lock-mode= won't remove existing coloring.

Here's a command that lets removes syntax coloring.

#+BEGIN_SRC emacs-lisp
    (defun xah-unfontify-region-or-buffer ()
      "Unfontify text selection or buffer.
    URL `http://ergoemacs.org/emacs/elisp_uncolor_region.html'
    Version 2017-05-31"
      (interactive)
      (if (use-region-p)
          (font-lock-unfontify-region (region-beginning) (region-end))
        (font-lock-unfontify-buffer)))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_uncolor_region.html]]

\\
\\
| [[../index_u13.html#article_44][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |

<<index_u34.html>>

| [[../../feed_1/index.html][下一项]] |
[[../index_u13.html#article_45][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
[[../article_44/index_u12.html][上一项]] |

--------------

* Emacs: Setup Mouse Click to Highlight Matching Words
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2014-03-11. Last updated: 2016-07-18.

You can set mouse right-click to call =isearch-forward-symbol-at-point=
(highlight clicked word).

Here's the command.

#+BEGIN_SRC emacs-lisp
    (defun xah-mouse-click-to-search (@click)
      "Mouse click to start `isearch-forward-symbol-at-point' (emacs 24.4) at clicked point.
    URL `http://ergoemacs.org/emacs/emacs_mouse_click_highlight_word.html'
    Version 2016-07-18"
      (interactive "e")
      (let ((p1 (posn-point (event-start @click))))
        (goto-char p1)
        (isearch-forward-symbol-at-point)))
#+END_SRC

Here's the code to set the mouse (this example is for Linux only):

#+BEGIN_SRC emacs-lisp
    ;; set mouse
    (cond
     ((string-equal system-type "windows-nt") ; Windows
      nil
      )
     ((string-equal system-type "gnu/linux")
      (global-set-key (kbd "<mouse-3>") 'xah-click-to-search) ; right button
      )
     ((string-equal system-type "darwin") ; Mac
      nil
      ) )
#+END_SRC

Note: mouse button and wheel have different syntax on {Microsoft
Windows, Mac OS X, Linux}. To find the syntax, Alt+x =describe-key=,
then press the button or wheel. [see
[[file:emacs_mouse_wheel_config.html][Emacs: Mouse Config]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_mouse_click_highlight_word.html]]

\\
\\
| [[../index_u13.html#article_45][段落菜单]] |
[[../../index_u11.html#feed_0][主菜单]] |
