* java-mode
** Ensime key bindings
*** Search

 | Key Binding | Description                                         |
 |-------------+-----------------------------------------------------|
 | ~SPC m /~   | incremental search using =ensime-scalex= major mode |
 | ~SPC m ?~   | incremental search in all live buffers              |

*** Ensime Search Mode

 | Key Binding | Description                                                       |
 |-------------+-------------------------------------------------------------------|
 | ~C-j~       | Move to next match                                                |
 | ~C-k~       | Move to previous match                                            |
 | ~C-i~       | Insert at point import of current result                          |
 | ~RET~       | Jump to the target of the currently selected ensime-search-result |
 | ~C-q~       | Quit ensime search                                                |

*** sbt

 | Key Binding | Description         |
 |-------------+---------------------|
 | ~SPC m b .~ | sbt transient state |
 | ~SPC m b b~ | sbt command         |
 | ~SPC m b c~ | compile             |
 | ~SPC m b C~ | clean command       |
 | ~SPC m b i~ | switch to sbt shell |
 | ~SPC m b p~ | package command     |
 | ~SPC m b r~ | run command         |

*** Typecheck

 | Key Binding | Description                     |
 |-------------+---------------------------------|
 | ~SPC m c t~ | type check the current file     |
 | ~SPC m c T~ | type check all the open buffers |

*** Debug

 | Key Binding | Description                 |
 |-------------+-----------------------------|
 | ~SPC m d A~ | Attach to a remote debugger |
 | ~SPC m d b~ | set breakpoint              |
 | ~SPC m d B~ | clear breakpoint            |
 | ~SPC m d C~ | clear all breakpoints       |
 | ~SPC m d c~ | continue                    |
 | ~SPC m d i~ | inspect value at point      |
 | ~SPC m d n~ | next                        |
 | ~SPC m d o~ | step out                    |
 | ~SPC m d q~ | quit                        |
 | ~SPC m d r~ | run                         |
 | ~SPC m d s~ | step                        |
 | ~SPC m d t~ | backtrace                   |

 *Note:* These key bindings need a transient-state, PR welcome :-)

*** Errors

 | Key Binding | Description                                        |
 |-------------+----------------------------------------------------|
 | ~SPC m e e~ | print error at point                               |
 | ~SPC m e l~ | show all errors and warnings                       |
 | ~SPC m e s~ | switch to buffer containing the stack trace parser |

*** Goto

 | Key Binding | Description          |
 |-------------+----------------------|
 | ~SPC m g g~ | go to definition     |
 | ~SPC m g i~ | go to implementation |
 | ~SPC m g t~ | go to test           |

*** Print and yank types

 |-------------+--------------------------------|
 | ~SPC m h T~ | print full type name at point  |
 | ~SPC m h t~ | print short type name at point |
 | ~SPC m y T~ | yank full type name at point   |
 | ~SPC m y t~ | yank short type name at point  |

*** Documentation, Inspect

 | Key Binding | Description                            |
 |-------------+----------------------------------------|
 | ~SPC m h h~ | show documentation for symbol at point |
 | ~SPC m h u~ | show uses for symbol at point          |
 | ~SPC m i i~ | inspect type at point                  |
 | ~SPC m i I~ | inspect type in other frame            |
 | ~SPC m i p~ | inspect project package                |

*** Server

 | Key Binding | Description                                            |
 |-------------+--------------------------------------------------------|
 | ~SPC m D f~ | reload open files                                      |
 | ~SPC m D r~ | regenerate the =.ensime= and restart the ensime server |
 | ~SPC m D s~ | start ensime server                                    |

*** Refactoring

 | Key Binding | Description                                                          |
 |-------------+----------------------------------------------------------------------|
 | ~SPC m r a~ | add type annotation                                                  |
 | ~SPC m r f~ | format source                                                        |
 | ~SPC m r d~ | get rid of an intermediate variable (=ensime-refactor-inline-local=) |
 | ~SPC m r D~ | get rid of an intermediate variable (=ensime-undo-peek=)             |
 | ~SPC m r i~ | organize imports                                                     |
 | ~SPC m r m~ | extract a range of code into a method                                |
 | ~SPC m r r~ | rename a symbol project wide                                         |
 | ~SPC m r t~ | import type at point                                                 |
 | ~SPC m r v~ | extract a range of code into a variable                              |
 | ~SPC m z~   | expand/contract region                                               |

*** Tests

 | Key Binding | Description              |
 |-------------+--------------------------|
 | ~SPC m t a~ | test command (sbt)       |
 | ~SPC m t r~ | test quick command (sbt) |
 | ~SPC m t t~ | test only (sbt)          |

*** REPL

 | Key Binding | Description                                                         |
 |-------------+---------------------------------------------------------------------|
 | ~SPC m s a~ | ask for a file to be loaded in the REPL                             |
 | ~SPC m s b~ | send buffer to the REPL                                             |
 | ~SPC m s B~ | send buffer to the REPL and focus the REPL buffer in =insert state= |
 | ~SPC m s i~ | start or switch to the REPL inferior process                        |
 | ~SPC m s r~ | send region to the REPL                                             |
 | ~SPC m s R~ | send region to the REPL and focus the REPL buffer in =insert state= |
** ensime java集成环境  
   1.在工程下执行 sbt ensimeConfig 生成项目
   2.emacs 打开服务并连接服务 ensime 就可以了, 多连接几次，可能在下载依赖
   3.如要要用build 功能, 需配置，可以创建一个project/build.properties
   #+BEGIN_SRC scala
   sbt.version=1.0.4  
   #+END_SRC
   查看版本，可以在 sbt 命令行下，执行 sbtVersion
  
   这样就可以 build , 和执行了
*** 什么是错误？ error 里面有 
** sbt scala 写的 交互式构建工具
   echo "deb https://dl.bintray.com/sbt/debian /" | sudo tee -a /etc/apt/sources.list.d/sbt.list
   sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823
   sudo apt-get update
   sudo apt-get install sbt
   sbt repositories
** maven 中国镜像
* java目录
** Options
   java CLASSNAME
   CLASSPATH 设置全局路径, 跟 PATH 常量差不多(编译和运行时都可用)
  指定搜索路径, 默认在当前目录 java -cp C:\workspace;C:\classes HelloWorld
  JVM 会依 CLASSPATH 路径顺序,搜索是否有对应的类文档,先找到先载入。
  java -cp C:\workspace;C:\lib\abc.jar;C:\lib\xyz.jar SomeApp
** javadoc
      The javadoc command has the following general form:
      javadoc [options...] [package names...] [source filenames...]
#+BEGIN_SRC 
      $ javadoc net.multitool.Payback
      -public -protected -package -private
      -sourcepath      and -classpath -verbose     and -quiet
      -doclet starting_class

      /* This is a C-style comment, but it
      is _not_ a Javadoc comment. */

      /** This is a C-style comment, but it
      is also a Javadoc comment. */
#+END_SRC
: 注释中可以嵌入Html tag
  *
  * @param delay - elapsed time, in milliseconds
  * @throws TakesTooLongException
  * @returns total time, in milliseconds
  *
  * @see net.multitool.util.TakesTooLongException, net.multitool.ctrl.Time#count
  *
  */
public long
addWait(long delay)
{
    // ...
}
** javah
       Example 5.7 Java application with a native method (GetUser.java)
       public class GetUser {
          static {
             System.loadLibrary("getuser");
          }
          public native String getUserName();
          public static void main(String[] args)
          {
             GetUser usr = new GetUser();
             System.out.println(usr.getUserName());
          }
       }
 
       $ javah GetUser //生成Ｃ格式的头文件/定义文件
    Example 5.8 Header file for GetUser native methods (GetUser.h)
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class GetUser */
    #ifndef _Included_GetUser
    #define _Included_GetUser
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
      * Class:       GetUser
      * Method:      getUserName
      * Signature: ()Ljava/lang/String;
      */
    JNIEXPORT jstring JNICALL Java_GetUser_getUserName
       (JNIEnv *, jobject);
    #ifdef __cplusplus
    }
    #endif
    #endif
    Example 5.9 Native method’s C implementation file (GetUser.c)
    #include "GetUser.h"
    #include <stdio.h>
    JNIEXPORT jstring JNICALL
    Java_GetUser_getUserName(JNIEnv *jenv, jobject obj)
    {
       char buffer[L_cuserid + 1];
       cuserid(buffer);
       return (*jenv)->NewStringUTF(jenv, buffer);
    }
 
      $ cc -c GetUser.c
       $ cc -shared -o libgetuser.so GetUser.o
       $ export LD_LIBRARY_PATH=.
 
** Remote Method Invocation (RMI) 相当于WEB开发
   The Session interface
        package net.multitool.RMIDemo;
        import java.rmi.*;
        public interface Session extends Remote {
           public int add(int x, int y) throws RemoteException;
        }
        The two important things to note here are that the interface must extend
        java.rmi.Remote and that any remote method must be defined as throwing
        java.rmi.RemoteException. 
The Session server implementation
        package net.multitool.RMIDemo;
        import net.multitool.RMIDemo.*;
        import java.rmi.*;
        import java.rmi.server.*;
        /** SessionImpl is the server class for the Session RMI interface.
          */
        public class
        SessionImpl
           extends UnicastRemoteObject
           implements Session
        {
           /** Constructor needed to ensure call to UnicastRemoteObject
             * constructor and to thus propagate the possible exception.
             */
           public SessionImpl() throws RemoteException {
              super();
           }
           /** A static main() for the server. */
           public static void main(String[] arglist)
           {
              if (System.getSecurityManager() == null) {
                System.setSecurityManager(new RMISecurityManager());
              }
              String rmiName = "//penfold/Session";
              try {
                Session adder = new SessionImpl();
                Naming.rebind(rmiName, adder);
              } catch (Exception e) {
                e.printStackTrace();
              }
           }
           /** Implementation of the RMI method, add. */
           public int add(int x, int y) throws java.rmi.RemoteException
           {
              return x+y;
           }
        }
       The RMI client program
        package net.multitool.RMIDemo;
        import java.rmi.*;
        public class Client {
           public static void main(String[] arglist) {
             if (System.getSecurityManager() == null) {
                System.setSecurityManager(new RMISecurityManager());
             }
             try {
                String name = "//penfold/Session";
                // Obtain reference to the remote object
                Session sess = (Session) Naming.lookup(name);
                System.out.println("Pointless RMI Client. 47 + 13 = " +
                                          sess.add(47,13) + ", right?");
             } catch (Exception e) {
                e.printStackTrace();
             }
           }
        }
 $ rmic net.multitool.RMIDemo.SessionImpl
 $ rmiregistry 21099 &
 
** The Java Debugger  
   $ jdb GetUser
   An actual jdb session, with commentary
   $ jdb
   Initializing jdb ...
   > stop in FetchURL.main (1)
   Deferring breakpoint FetchURL.main.
   It will be set after the class is loaded.
   > run FetchURL http://localhost
   run FetchURL http://localhost
   Set uncaught java.lang.Throwable
   Set deferred uncaught java.lang.Throwable
   >
   VM Started: Set deferred breakpoint FetchURL.main
   Breakpoint hit: "thread=main", FetchURL.main(), line=48 bci=0
   for (i = 0; i < args.length; i++)
   main[1] list
44         {
45           int i;
46           FetchURL f;
47
48 =>(2)       for (i = 0; i < args.length; i++)
49           {
50               System.out.println(args[i] + ":");
51               System.out.println(new FetchURL(args[i]));
52           }
53         }
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=50 bci=5
50               System.out.println(args[i] + ":");
main[1] step
> http://localhost:
Step completed: "thread=main", FetchURL.main(), line=51 bci=32
51               System.out.println(new FetchURL(args[i]));
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=8 bci=0
8        {
main[1] list
4     public class FetchURL {
5        private URL requestedURL;
5.9  The Java Debugger                                            153
6
7         public FetchURL(String urlName)
8 =>      {
9             try {
10                requestedURL = new URL(urlName);
11             } catch (Exception e) {
12                e.printStackTrace();
13             }
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=10 bci=4
10                requestedURL = new URL(urlName);
main[1] step (3)
>
Step completed: "thread=main", FetchURL.<init>(), line=11 bci=16
11             } catch (Exception e) {
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=14 bci=27
14          }
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=51 bci=45
51                System.out.println(new FetchURL(args[i]));
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=19 bci=2
19             String rc = "";
main[1] list
15
16
17          public String toString()
18          {
19 =>          String rc = "";
20             String line;
21             BufferedReader rdr;
22
23             try {
24                rdr = new BufferedReader(
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=24 bci=3
24                rdr = new BufferedReader(
154                      Chapter 5 The Sun Microsystems Java Software Development Kit
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=28
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] list
28              );
29
30              while ((line = rdr.readLine()) != null)
31              {
32 =>              rc = rc + line + "\n";
33              }
34           } catch (Exception e) {
35              e.printStackTrace();
36              rc = null;
37           }
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=55
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=55
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] dump this (4)
  this = {
     requestedURL: instance of java.net.URL(id=378)
}
main[1] dump rc     (5)
   rc = "<HTML>
           <HEAD>
5.9  The Java Debugger                                                      155
"
main[1] list 36
32                   rc = rc + line + "\n";
33                }
34             } catch (Exception e) {
35                e.printStackTrace();
36 =>             rc = null;
37             }
38
39             return rc;
40         }
41
main[1] stop at FetchURL:39        (6)
Set breakpoint FetchURL:39
main[1] cont
>
Breakpoint hit: "thread=main", FetchURL.toString(), line=39 bci=79
39             return rc;
main[1] dump rc
   rc = "<HTML>
             <HEAD>
               <TITLE>RedHat Linux Laptop</TITLE>
             </HEAD>
             <BODY>
               <H1>RedHat Linux Laptop</H1>
               <P>You have contacted Michael Schwarz's RedHat Linux Laptop.
               You would probably rather
               <A HREF="http://www.multitool.net/">see his permanent Web
               page</A> since this server goes up and down all the time, what
               with it being on a laptop.</P>
             </BODY>
          </HTML>
"
main[1] step
> <HTML>
     <HEAD>
       <TITLE>RedHat Linux Laptop</TITLE>
     </HEAD>
     <BODY>
       <H1>RedHat Linux Laptop</H1>
       <P>You have contacted Michael Schwarz's RedHat Linux Laptop.
       You would probably rather
       <A HREF="http://www.multitool.net/">see his permanent Web
       page</A> since this server goes up and down all the time, what
       with it being on a laptop.</P>
     </BODY>
   </HTML>
156                             Chapter 5    The Sun Microsystems Java Software Development Kit
Step completed: "thread=main", FetchURL.main(), line=48 bci=48
48              for (i = 0; i < args.length; i++)
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=53 bci=57
53          }
main[1] step
>
The application exited
$
** 反编译
   javap
** jar
   $ jar cvf jars/jgnash.jar jgnash/bin
$jar cmf pp.jar manifest bin/*.class
   manifest文件
#+BEGIN_SRC 
   Manifest-Version: 1.0
   Ant-Version: Apache Ant 1.5.3
   Created-By: 1.4.1_02-b06 (Sun Microsystems Inc.)
   Version: 1.0
   Main-Class: net.multitool.Payback.Payback
#+END_SRC
 
** TOOL kit
   extcheck
jarsigner
** IBM Classes
      IBM’s Eclipse project (which we begin to cover in Chapter 10) provides a large
      GUI API library called SWT  
** The GNU Compiler for Java
    (gcj)
    The GNU Compiler for Java provides a native binary compiler for Java code.
    gcj [options...] [codefile...] [@listfile...] [libraryfile...]
  : The GNU Compiler for Java (gcj) does not fully support the AWT or Swing GUIs
** build tool
  Ant:(蚂蚁) make 对java的局限
  The ANT_HOME environment variable should be set
  JAVA_HOME 也要设定
  build.xml
  <?xml version="1.0"?>
  A buildfile must contain exactly one project tag.
  The project tag contains three attributes:
  ::project::
  name The name of the project.
  default The default target (see next section).
  basedir
  ::project::
  :target:
  srcdir Location of the Java source files.
  destdir Location to store the class files.
  includes
  excludes
  classpath The classpath to use.
  sourcepath
  classpathref The classpath to use, given as a reference to a path defined elsewhere.
  extdirs Location of installed extensions.
  nowarn defaults to off (i.e., warnings are shown).
  debug
  debuglevel
  optimize
  deprecation
  verbose
  depend
  :target:

** IDE
netbean
eclipse
** 项目
   •  Requirements gathering
   •  Use case specification
   •  Class discovery and problem domain decomposition
   •  Technical requirements specification (architecturing)
   •  Testing
   •  Code and release management
   •  Production and operations support
   •  Bug and enhancement tracking

** Swing 
#+BEGIN_SRC java
import java.awt.*;
import javax.swing.*;
public class hw
{
    public static void main(String[] args)
    {
        //Create the top-level container
        JFrame frame = new JFrame();
        JLabel hi = new JLabel("Hello, world.");
        frame.getContentPane().add(hi, BorderLayout.CENTER);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack(); // kicks the UI into action
        frame.setVisible(true);
    } // main
} // class hw
#+END_SRC
** SERVLET
   • Write a Java class that extends HttpServlet
   • In that class, write the following methods:
   • init()
   • destroy()
   • doGet() and/or doPost()
#+BEGIN_SRC java
   //Example 18.1 A “Hello, world” servlet
    /*
    * HiServlet.java
    */
    package net.multitool.servlet;
    import javax.servlet.*;
    import javax.servlet.http.*;
    /**
      * Simple Servlet that generates a page of HTML
      */
    public class HiServlet extends HttpServlet
    {
       /**
         * Think of this as the constructor for the servlet.
         * We need do nothing for our example,
         * but we should call our parent object.
         */
       public void init(ServletConfig config)
       throws ServletException
       {
          super.init(config);
       } // init
       /**
       * Called when the Web server is shutting down
       * or wants to shut down this particular servlet.
       * We need do nothing.
       */
       public void destroy()
       {
       } // destroy
       /**
         * Handles the HTTP GET method.
         * @param request servlet request
         * @param response servlet response
         */
         protected void doGet(HttpServletRequest request, HttpServletResponse response)
         throws ServletException, java.io.IOException
         {
         doBoth(request, response);
         } // doGet
         /**
           * Handles the HTTP POST method.
           * @param request servlet request
           * @param response servlet response
           */
         protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, java.io.IOException
         {
         doBoth(request, response);
         } // doPost
         /**
           * Requests for both HTTP GET and POST methods come here,
           * because we're not doing anything different
           * between the two request types. This way we need only one
           * version of the code that does the real work.
           * @param request servlet request
           * @param response servlet response
           */
         protected void doBoth(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, java.io.IOException
         {
         java.io.PrintWriter out = response.getWriter();
            response.setContentType("text/html");
            /* output our page of html */
            out.println("<html>");
            out.println("<head>");
            out.println("<title>A Java Servlet</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("Hello, world.");
            out.println("</body>");
            out.println("</html>");
            out.close();
         } // doBoth
         /**
         * Returns a short description of the servlet.
         */
         public String getServletInfo()
         {
          return "Very Simple Servlet";
          } // getServletInfo()
          } // class HiServlet
 

#+END_SRC
** JSP
#+BEGIN_SRC jsp
<table border=1 width=50%>
      <tr>
      <th>Account</th>
      <th>Owner</th>
      <th>Value</th>
      </tr>
      <% // for each subaccount:
         for (Iterator actit = acct.getAllSubs(); actit.hasNext(); ) {
           Account suba = (Account) actit.next();
           %>
           <tr>
           <td><a href="BPControl?name=<%= suba.getName() %>&func=cd">
           <%= suba.getName() %>
           </a></td>
           <td>albing</td>
           <td>
           <%= suba.getTotal().toString() %>
           </td>
           </tr>
      <%
       } // next acct
      %>
      </table>
#+END_SRC
** 语言特性
   完全面向对象
   文件名要同公开类的类名相同, 一个文件只能有一个公开类
   公开方法 public static void main(String[] args)
   申明常量 final
   严格浮点计算 strictfp
   boolean 不能强制转换，但可以 int castb=b?1:0;
   类和对象
   package and import
   java.lang 会默认import
          原始码文档或位码文档都可以使用 JAR 文档封装,在“命令提示符”模式下,可以使用 JDK 的 jar 工具程序来制作 JAR 文档。可以参考以下文件:
** 库
   import static java.lang.Math.*; 
   Math.pow(2, 3)次方
   String类是一个类库实现
   S.equals(SS)
   equalsIgnoreCase
   import java.util.*; 
   new Scanner(System.in)
   nextLine, nextInt()
   System.out.print()
** ERROR
** Date
   Date类是以 UTC 为时间纪元 为状态设定的.
Date类对日期的处理有局限, 如不能表示中国的农历等日期
so, 类库实现者 将保存时间 与 给时间点命名分开. 一个 Date 类, 一个 GregorianCalendar 类
* java
** 对象   --语法
   文字
   整数
   ArrayList
   Iterator 
   小数 默认 double, float 要加个 后缀 f 
   多个数 []
** 对象操作
*** 文字
    长度  length() 
    equals
    equalsIgnoreCase
    toLowerCase
    startsWith endsWith
    substring
*** 数组
    ArrayList
    add
*** sound
*** video
*** music
*** 异常
** 流程控制 
   for(String str: args)
** 文档 
** java Date 函数
默认不带参数是 当前时间
System.out.printf("%1$tm / %1$td \n",d);
printf 函数的精致操作,%s 是输出字符串 
Wed Jan 10 12:37:55 CST 2018
** 运行在Java虚拟机上，又不像是解释型语言
   java 虚拟机为下列各项做出了定义
   指令集
   注册类
   类文件格式
   栈
垃圾收集堆
存储区
** java 运行环境执行三大任务
   加载代码
校验代码
执行代码
** 编译 javac 
   -classpath Path
   -d Dir   指定编译后的类存放路径
   -g  生成调试表
   -nowarn 关闭警告
   -verbose 打开详细信息
   -o 优化
   相对的会在 当前目录一起编译 引用的文件，或者在classpath中找
** 执行 需使用解释器 java
** 类、包
java 类库中有几个重要的包
java.lang
java.awt
java.net
java.io
java.util

类库被组织成几个包, 每个包含几个类
java.lang   中 String, Math, Integer 和 Thread
java.awt  包含图形类
java.applet  包含可执行 applet 的特殊行为的类
java.net 包含网络
java.util  包含任务设置的实用程序类，如随机数，定义系统特性 ，日历

引用其他的类 import
静态导入？ import static 可以不加类名调用对象的静态属性或方法
** appletviewer othions URL 测试 applet 的简单工具
** 文档注释
   /** 开始 */ 结束
   javadoc 文件名
   @see 放入链接
   @version 放入版本号
   @author 作者
   @param 方法参数
   @return 返回
   @throws
* 构造器的重载 可以用this([param])
* 超类 super.method, 超类的构造器 super(param..)
* 给一个合适的警告或错误提示？ 这在编译器中特别有用
* java 中没有unsigned类型? 说明都是有符号的
* 浮点的正无穷？　Double.POSITIVE_INFINITY
  Double.NEGATIVE_INFINITY
  Double.NaN 不能单纯比较
  Double.isNaN()
* boolean? 名字都变了
* 常量定义？　 final 
* 导入数学库？ import static java.lang.Math.*;
* 数学的舍入成整数？ Math.round
* 数学的向下舍入？ Math.floor 返回的是 浮点表示的整数
* 数字进制转换？
System.out.println(Integer.toBinaryString(a));
转换成八进制把Binary换成Octal
转换成十六进制把Binary换成Hex
* 枚举不能为本地变量？ 不同的函数分为不同的地域，所以不能在函数内定义，而是在大局内，类内定义
  enum Diannao{LIANXIANG,DELL,HUIPU};
* String结构？ 是一个个 unicode 代码点，所以操作时注意, 代码点是char
* substring
* 串相等 "str".equals(obj)
* java.lang 库？
java.lang.string
java.util
* java 默认导入的库
  java.awt:提交用户界面元件。
  java.io:提供与设备无关的输入，输出流支持、
  java.lang:提供支持Java的基础类、
  Java.net:提供支持联网的类。
  java.util:提供实用方法和数据结构的。
  默认导入的包
  Java.lang.*
  javax.servlet.*
  javax.servlet.jsp.*
  javax.servlet.http；
* 输入输出对象 这对象专门 细致地输入整数，整行 什么的
** 什么是 Scanner? 键盘输入对象  java.util 中
   这种函数性抽象的东西，需要参数指定输入到哪里 new Scanner(System.in) 键盘缓冲
   对于字符串类型的数字，可以用 Integer.parseInt 或Double.parseDouble转换 
   输入容易数据错误
* 退出虚拟机执行？ exit(int status)  状态表示退出码，限定的数字，难道是继承
* Date? 日期啊，时间也是日期一部分 这个类过时了, 用GregorianCalendar 格里高利
  int  year=c.get(Calendar.YEAR);//获取年份  
int  month=c.get(Calendar.MONTH);//获取月份  
int  day=c.get(Calendar.DATE);//获取日期  
int  minute=c.get(Calendar.MINUTE);//分  
int  hour=c.get(Calendar.HOUR);//小时  
int  second=c.get(Calendar.SECOND);//秒 
* 数组？ 一堆东西
排序 Array.sort  只能是数字 组, 返回为空，输出的是参数所指向的数组对象
* 命令行参数？ 用空格隔开的都是一个参数字串
* 类，对象，实例化？ 更好模块化，调试，扩展
* 构造器？ 同类名相同 ，默认构造器，没参数的类名
* 把类放在包中 package com.aa.bb; 注意匹配目录(这个在引用的时候有用），编译原包时不管什么目录
* 设置类路径 因为类可能被放在不同目录中方便调用, 为了把类集中起来， 要配置 CLASSPATH环境变量或 设定 -classpath选项, 用: 分隔
* 继承? extends 原有的字段如果相同，就不用重写了，除非不同
  类的东西 super
  数直接可用 super, 同this 调用自己的其他构造器，两个用法
* 阻止继承 final
* 抽象类？ 
* 泛型数组？ ArrayList<Classname> shuzu = new ArrayList<Classname>(); 数组要指定长度，而带指针的数组（链表）不需要指定长度.
  
  Capacity(100) 如果估算出长度
  加
  寸
  Size 内存整理
  
   obj)
  
* 异常？ 
  N_SRC java
       try {
          String name = "//penfold/Session";
          // Obtain reference to the remote object
          Session sess = (Session) Naming.lookup(name);
          System.out.println("Pointless RMI Client. 47 + 13 = " +
                                    sess.add(47,13) + ", right?");
       } catch (Exception e) {
          e.printStackTrace();
       }

  SRC
* 反射？ 用class, 返回方法，字段
  getDeclaringClass
  getExceptionTypes
  getModifiers
  getName
* iterator 迭代 ，相比数组操作简单点  ArrayList
  Iterator.next()
* eclipse
  Eclipse导入工程后工程上显示一个小红叉，但工程里没有文件错误，也没有语法错误，百思不得其解啊，
  后来在网上找了一些资料说是项目引用的类库路径有问题。【项目】->【右键】->【build path】->【configure build path】->【libraries】，
  查看一下引用的类库路径。网上都说是因为这里引用错误引起的，但是我在项目导入的时候做的第一件事情就是修改这里的library，因此不是这个原因。
  在problems中显示错误是：Target runtime Apache Tomcat 6.0 is not defined. 在网上查了一下终于找到解决方法。
  方法是：在工程目录下的.settings文件夹里，打开org.eclipse.wst.common.project.facet.core.xml文件，其内容是：

<?xmlversion="1.0"encoding="UTF-8"?> 
<faceted-project> 
<runtimename="Apache Tomcat v6.0"/> 
<fixedfacet="jst.web"/> 
<fixedfacet="jst.java"/> 
<installedfacet="jst.java"version="6.0"/> 
<installedfacet="jst.web"version="2.5"/> 
<installedfacet="wst.jsdt.web"version="1.0"/> 
</faceted-project>

将其修改为：

<?xml version="1.0" encoding="UTF-8" ?> 
<faceted-project>
</faceted-project>
PS:进行上面的修改以后虽然没有错误了，但是想发布网站demo的时候发现没有【run as】->【run on server】这个选项了。
这时候我们创建一个demo2的web project，然后查看.settings下的org.eclipse.wst.common.project.facet.core.xml，我们发现其内容是：

<?xml version="1.0" encoding="UTF-8" ?> 
 <faceted-project>
  <runtime name="Apache Tomcat v6.0.29" /> 
  <fixed facet="jst.web" /> 
  <fixed facet="java" /> 
  <fixed facet="wst.jsdt.web" /> 
  <installed facet="java" version="1.6" /> 
  <installed facet="jst.web" version="2.5" /> 
  <installed facet="wst.jsdt.web" version="1.0" /> 
  </faceted-project>
那么我们只需要将该代码拷贝到网站demo下的.settings目录下，
将原来的org.eclipse.wst.common.project.facet.core.xml覆盖即可。
覆盖以后我们在Eclipse就能够使用【run as】->【run on server】来发布demo了。
