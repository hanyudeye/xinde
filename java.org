* java
** javac options
$ javac -verbose FetchURL.java 列出调用过程
  文档目录 /usr/lib/jvm/default-java
** java Options
  java CLASSNAME

  CLASSPATH 设置全局路径
  指定搜索路径, 默认在当前目录 java -cp C:\workspace;C:\classes HelloWorld
  JVM 会依 CLASSPATH 路径顺序,搜索是否有对应的类文档,先找到先载入。
  java -cp C:\workspace;C:\lib\abc.jar;C:\lib\xyz.jar SomeApp

  
      Just as the Java compiler, the runtime program, java, takes a number of com-
      mand-line options. Here are the most commonly used ones:
      -classpath     or -cp
           Sets the runtime classpath. Overrides any value in the CLASSPATH
           environment variable.
      -Dproperty=value
           Allows a system property to be set on the command line.
      -jar
           Specifies that the first nonoption command-line argument is not a Java
           class name, but the name of a JAR file. The JAR file must have a
           Main-Class: specification in its MANIFEST (see Section 5.11). The
           main() method of the class named by the JAR’s MANIFEST Main-Class:
           specification will be called as if that class had been named on the command
           line, rather than the JAR file. This is commonly used in shell scripts and
           batch files that accompany Java applications distributed in single
           .jar files.
    
** javadoc
      The javadoc command has the following general form:
      javadoc [options...] [package names...] [source filenames...]
      $ javadoc net.multitool.Payback
 -public -protected -package -private
 -sourcepath      and -classpath -verbose     and -quiet
 -doclet starting_class
 /* This is a C-style comment, but it
 is _not_ a Javadoc comment. */
 /** This is a C-style comment, but it
 is also a Javadoc comment. */
 /**
  * addWait - adds in the given wait time to all the counters;
  * we could say much more about the method here, but let me say
  * that we sometimes include HTML tags directly in our comments.
  * Since Javadoc will run all our text together, we may need: <br>
  *          break tags <br>
  *          or paragraph tags <br>
  *          for spacing and separation.
  * <p>We also add <i>other</i> HTML tags for <b>emphasis</b>.
  * <p>You should still try to make the comment readable, though,
  * for the programmer who is editing the source, not
  * just for those looking at the formatted Javadoc.
  * @author John Q. Programmer
  * @version $Id$
  *
  * @param delay - elapsed time, in milliseconds
  * @throws TakesTooLongException
  * @returns total time, in milliseconds
  *
  * @see net.multitool.util.TakesTooLongException, net.multitool.ctrl.Time#count
  *
  */
public long
addWait(long delay)
{
    // ...
}
   
** javah
       Example 5.7 Java application with a native method (GetUser.java)
       public class GetUser {
          static {
             System.loadLibrary("getuser");
          }
          public native String getUserName();
          public static void main(String[] args)
          {
             GetUser usr = new GetUser();
             System.out.println(usr.getUserName());
          }
       }
 
       $ javah GetUser //生成Ｃ格式的头文件/定义文件
    Example 5.8 Header file for GetUser native methods (GetUser.h)
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class GetUser */
    #ifndef _Included_GetUser
    #define _Included_GetUser
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
      * Class:       GetUser
      * Method:      getUserName
      * Signature: ()Ljava/lang/String;
      */
    JNIEXPORT jstring JNICALL Java_GetUser_getUserName
       (JNIEnv *, jobject);
    #ifdef __cplusplus
    }
    #endif
    #endif
    Example 5.9 Native method’s C implementation file (GetUser.c)
    #include "GetUser.h"
    #include <stdio.h>
    JNIEXPORT jstring JNICALL
    Java_GetUser_getUserName(JNIEnv *jenv, jobject obj)
    {
       char buffer[L_cuserid + 1];
       cuserid(buffer);
       return (*jenv)->NewStringUTF(jenv, buffer);
    }
 
      $ cc -c GetUser.c
       $ cc -shared -o libgetuser.so GetUser.o
       $ export LD_LIBRARY_PATH=.
 
** Remote Method Invocation (RMI) 相当于WEB开发
   The Session interface
        package net.multitool.RMIDemo;
        import java.rmi.*;
        public interface Session extends Remote {
           public int add(int x, int y) throws RemoteException;
        }
        The two important things to note here are that the interface must extend
        java.rmi.Remote and that any remote method must be defined as throwing
        java.rmi.RemoteException. 
The Session server implementation
        package net.multitool.RMIDemo;
        import net.multitool.RMIDemo.*;
        import java.rmi.*;
        import java.rmi.server.*;
        /** SessionImpl is the server class for the Session RMI interface.
          */
        public class
        SessionImpl
           extends UnicastRemoteObject
           implements Session
        {
           /** Constructor needed to ensure call to UnicastRemoteObject
             * constructor and to thus propagate the possible exception.
             */
           public SessionImpl() throws RemoteException {
              super();
           }
           /** A static main() for the server. */
           public static void main(String[] arglist)
           {
              if (System.getSecurityManager() == null) {
                System.setSecurityManager(new RMISecurityManager());
              }
              String rmiName = "//penfold/Session";
              try {
                Session adder = new SessionImpl();
                Naming.rebind(rmiName, adder);
              } catch (Exception e) {
                e.printStackTrace();
              }
           }
           /** Implementation of the RMI method, add. */
           public int add(int x, int y) throws java.rmi.RemoteException
           {
              return x+y;
           }
        }
       The RMI client program
        package net.multitool.RMIDemo;
        import java.rmi.*;
        public class Client {
           public static void main(String[] arglist) {
             if (System.getSecurityManager() == null) {
                System.setSecurityManager(new RMISecurityManager());
             }
             try {
                String name = "//penfold/Session";
                // Obtain reference to the remote object
                Session sess = (Session) Naming.lookup(name);
                System.out.println("Pointless RMI Client. 47 + 13 = " +
                                          sess.add(47,13) + ", right?");
             } catch (Exception e) {
                e.printStackTrace();
             }
           }
        }
 $ rmic net.multitool.RMIDemo.SessionImpl
 $ rmiregistry 21099 &
 
** The Java Debugger  
   $ jdb GetUser
An actual jdb session, with commentary
$ jdb
Initializing jdb ...
> stop in FetchURL.main (1)
Deferring breakpoint FetchURL.main.
It will be set after the class is loaded.
> run FetchURL http://localhost
run FetchURL http://localhost
Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable
>
VM Started: Set deferred breakpoint FetchURL.main
Breakpoint hit: "thread=main", FetchURL.main(), line=48 bci=0
48           for (i = 0; i < args.length; i++)
main[1] list
44         {
45           int i;
46           FetchURL f;
47
48 =>(2)       for (i = 0; i < args.length; i++)
49           {
50               System.out.println(args[i] + ":");
51               System.out.println(new FetchURL(args[i]));
52           }
53         }
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=50 bci=5
50               System.out.println(args[i] + ":");
main[1] step
> http://localhost:
Step completed: "thread=main", FetchURL.main(), line=51 bci=32
51               System.out.println(new FetchURL(args[i]));
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=8 bci=0
8        {
main[1] list
4     public class FetchURL {
5        private URL requestedURL;
5.9  The Java Debugger                                            153
6
7         public FetchURL(String urlName)
8 =>      {
9             try {
10                requestedURL = new URL(urlName);
11             } catch (Exception e) {
12                e.printStackTrace();
13             }
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=10 bci=4
10                requestedURL = new URL(urlName);
main[1] step (3)
>
Step completed: "thread=main", FetchURL.<init>(), line=11 bci=16
11             } catch (Exception e) {
main[1] step
>
Step completed: "thread=main", FetchURL.<init>(), line=14 bci=27
14          }
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=51 bci=45
51                System.out.println(new FetchURL(args[i]));
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=19 bci=2
19             String rc = "";
main[1] list
15
16
17          public String toString()
18          {
19 =>          String rc = "";
20             String line;
21             BufferedReader rdr;
22
23             try {
24                rdr = new BufferedReader(
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=24 bci=3
24                rdr = new BufferedReader(
154                      Chapter 5 The Sun Microsystems Java Software Development Kit
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=28
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] list
28              );
29
30              while ((line = rdr.readLine()) != null)
31              {
32 =>              rc = rc + line + "\n";
33              }
34           } catch (Exception e) {
35              e.printStackTrace();
36              rc = null;
37           }
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=55
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=30 bci=55
30              while ((line = rdr.readLine()) != null)
main[1] step
>
Step completed: "thread=main", FetchURL.toString(), line=32 bci=31
32                 rc = rc + line + "\n";
main[1] dump this (4)
  this = {
     requestedURL: instance of java.net.URL(id=378)
}
main[1] dump rc     (5)
   rc = "<HTML>
           <HEAD>
5.9  The Java Debugger                                                      155
"
main[1] list 36
32                   rc = rc + line + "\n";
33                }
34             } catch (Exception e) {
35                e.printStackTrace();
36 =>             rc = null;
37             }
38
39             return rc;
40         }
41
main[1] stop at FetchURL:39        (6)
Set breakpoint FetchURL:39
main[1] cont
>
Breakpoint hit: "thread=main", FetchURL.toString(), line=39 bci=79
39             return rc;
main[1] dump rc
   rc = "<HTML>
             <HEAD>
               <TITLE>RedHat Linux Laptop</TITLE>
             </HEAD>
             <BODY>
               <H1>RedHat Linux Laptop</H1>
               <P>You have contacted Michael Schwarz's RedHat Linux Laptop.
               You would probably rather
               <A HREF="http://www.multitool.net/">see his permanent Web
               page</A> since this server goes up and down all the time, what
               with it being on a laptop.</P>
             </BODY>
          </HTML>
"
main[1] step
> <HTML>
     <HEAD>
       <TITLE>RedHat Linux Laptop</TITLE>
     </HEAD>
     <BODY>
       <H1>RedHat Linux Laptop</H1>
       <P>You have contacted Michael Schwarz's RedHat Linux Laptop.
       You would probably rather
       <A HREF="http://www.multitool.net/">see his permanent Web
       page</A> since this server goes up and down all the time, what
       with it being on a laptop.</P>
     </BODY>
   </HTML>
156                             Chapter 5    The Sun Microsystems Java Software Development Kit
Step completed: "thread=main", FetchURL.main(), line=48 bci=48
48              for (i = 0; i < args.length; i++)
main[1] step
>
Step completed: "thread=main", FetchURL.main(), line=53 bci=57
53          }
main[1] step
>
The application exited
$
** 反编译
RETURN TO THE SOURCE: THE JAVA DECOMPILER
javap
** 打包
   $ jar cvf jars/jgnash.jar jgnash/bin
 Manifest from the Payback sample application
 Manifest-Version: 1.0
       Ant-Version: Apache Ant 1.5.3
       Created-By: 1.4.1_02-b06 (Sun Microsystems Inc.)
       Version: 1.0
       Main-Class: net.multitool.Payback.Payback
  
** TOOL kit
   extcheck
jarsigner
** IBM Classes
      IBM’s Eclipse project (which we begin to cover in Chapter 10) provides a large
      GUI API library called SWT  
** The GNU Compiler for Java
    (gcj)
    The GNU Compiler for Java provides a native binary compiler for Java code.
    gcj [options...] [codefile...] [@listfile...] [libraryfile...]
** 语言特性
   完全面向对象
   文件名要同公开类的类名相同, 一个文件只能有一个公开类
   公开方法 public static void main(String[] args)
   申明常量 final
   严格浮点计算 strictfp
   boolean 不能强制转换，但可以 int castb=b?1:0;
   类和对象
** 库
   import static java.lang.Math.*; 
   Math.pow(2, 3)次方
   String类是一个类库实现
   S.equals(SS)
   equalsIgnoreCase
   import java.util.*; 
   new Scanner(System.in)
   nextLine, nextInt()
   System.out.print()
** ERROR
  : The GNU Compiler for Java (gcj) does not fully support the AWT or Swing GUIs
   一个 *.java 文件中,只能有一个public 的类,而且这个public修饰的这类必需要和这个文件名相同.
   //BOSS.java 
   public final class Boss extends Employee{ }
   你把public去掉就可以了.

* eclipse
* java
  Using (and Making) Java APIs 
  The package Statement 
  The import Statement 
  Encapsulation, Inheritance, and Polymorphism 
  Virtually Final 
  What You Still Don’t Know 
  A Simple Start 
  Command-Line Arguments 
  Unit Testing Made Easy 
  The System Class 
  Java and Standard I/O 
  Environment Variables 
  Java and Environment Variables 
  The Properties Class 
  The Runtime Class 
  exec() 
  Portability 
  Review 
  The Sun Microsystems Java Software Development Kit 
  What You Will Learn 
  All You Need, and Not One Thing More 
  The Java Compiler 
  Compiler Behavior, Defaults, and Environment Variables 
  javac Options 
  The Java Runtime Engine 
  The Basics 
  java Options 
  Complete, Up-to-Date Program Documentation Made Easy 
  Running javadoc 
  Javadoc Command-Line Options 
  ispensing with Applets 
  oing Native 
  ntroducing RMI 
  A Brief Introduction to RMI 
  The rmiregistry Tool 
  Setting Up Servers and Clients 
  RMI Summary 
  the Java Debugger 
  return to the Source: The Java Decompiler 
  bundling a Java Program: Put It in a JAR 
  Deploying Applications 
  Basic jar Operation 
  the Rest of the Toolkit 
  The IBM Developer Kit for Linux, Java 2 Technology Edition 
  Switching Java Versions by Symlink 
  Performance 
  Differences in the Commands 
  IBM Classes 
  The GNU Compiler for Java (gcj) 
  What You Will Learn 
  A Brand GNU Way 
  The GNU Compiler Collection 
  Compiling Our Simple Application with gcj 
  Compiling FetchURL with gcj 
  Compiling a Multiclass Program 
  Options and Switches 
  Reasons to Use gcj 
  Reasons Not to Use gcj 
  Know What You Have: CVS 
  What You Will Learn 
*** Source Control: Whys and Hows 
  Setup 
  Import 
  Normal Use 
  Update 
  Merges 
  Log 
  cvs status 
  cvs tag 
  Branching Tags 
  cvs export 
  A Quick Look behind the Scenes 
  A GUI: jCVS 
  Installing jCVS 
  Review 
  What You Still Don’t Know 
  Resources 
  Ant: An Introduction 
  What You Will Learn 
  The Need for a Different Build Tool 
  Obtaining and Installing Ant 
  Installing a Binary Tarball 
  Installing a Source Tarball 
  A Sample Ant Buildfile 
  XML for the Uninitiated 
  The Buildfile Tags 
  A Real, Live Buildfile 
  Review 
  What You Still Don’t Know 
  Resources 
  Integrated Development Environments 
  What You Will Learn 
  NetBeans: The Open Source IDE 
  A Brief History of NetBeans 
  Installing NetBeans 
  Getting Around in NetBeans 
  Integration with CVS 
  Integration with Ant 
  Other Add-on Tools 
  SunONE Studio Community Edition 
  Eclipse: The Source of SWT 
  Selecting and Installing Eclipse 
  Using Eclipse for a New Project 
  Using Eclipse for an Existing Project 
  Working with Eclipse 
  Developing Business Logic 
  Balancing Acts: An Imaginary Scenario 
  What You Will Learn 
  Statement of the Need 
  How to Develop Software 
  What Makes a Good Requirement 
  Whom to Ask for Requirements 
  Requirements for the Budget Application 
  Documenting, Prototyping, and Stakeholder Buy-In 
  What You Still Don’t Know 
  Analysis and Design: Seeking the Objects 
  What You Will Learn 
  Facing the Blank Page 
  Using CRC Cards 
  Finding the Objects 
  Finding the Methods and Attributes 
  Essential and Nonessential 
  Analysis Paralysis 
  Real Software Engineering 
  Core Classes 
  JUnit: Automating Unit Testing 
  What You Will Learn 
  JUnit: Why All the Fuss? 
  Design Then Test Then Code 
  Installing and Running JUnit 
  Downloading and Unzipping 
  Using JUnit 
  Writing Test Cases 
  JUnit Assertions 
  Running a Test Case 
  Running Test Suites 
  Storing the Data 
  What You Will Learn 
  Follow the Objects 
  Of Persistence 
  Thinking of the Future, or Painting in Corners 
  Oracle, PostgreSQL, MySQL 
  MySQL 
  PostgreSQL 
  Oracle 
  Selection Criteria 
  Being Self-Contained 
  Beyond the Basics 
  Persistence Is Not the Whole Story 
  Setting Up PostgreSQL for BudgetPro 
  Installing PostgreSQL 
  Creating a postgres User 
  Creating Our Database 
  Straight JDBC 
  Accessing the Data: An Introduction to JDBC 
  What You Will Learn 
  Introducing JDBC 
  Making Connections 
  Downloading JDBC for MySQL 
  Querying Data 
  Getting Results 
  Updates, Inserts, Deletes 
  Developing Graphical User Interfaces 
  Getting in the Swing of Things: Designing a GUI for
  BudgetPro 
  What You Will Learn 
  A Simple Swing Program 
  Stompin’ at the Savoy, or The Swing Paradigm 
  Slow, Slow, Quick-Quick, Slow: The Basic Swing Objects 
  Layout Managers 
  Beyond Arthur Murray: Actions, Listeners, Events 
  Getting Down to Cases: Designing a GUI for BudgetPro 
  Overview 
  Creating Pieces 
  Other Ways: Alternatives to Swing 
  What You Will Learn 
  The IBM SWT Toolkit 
  Another GUI Toolkit
  Duplicated Effort
  Portability: Better and Worse 
  The Rest of the Chapter 
  SWT: Close to the Metal 
  “Hello, world” SWT Style 
  Porting BudgetPro to SWT 
  Step 1: Convert the Class Members 
  Step 2: Converting the main() Method 
  Step 3: Converting the GUI build() and init()
  Methods 
  Completing the Conversion of the BudgetPro Class 
  Completing the Conversion of the Application 
  Closing Thoughts 
  SWT and gcj 
  PART IV Developing Web Interfaces 
  Servlets: Java Pressed into Service 
  What You Will Learn 
  Servlets: Program-Centric Server-Side Documents 
  Perspective 
  How to Write a Servlet 
  Input, Output 
  Matters of State: Cookies, Hidden Variables, and the Dreaded
  “Back” Button 
  Cookies 
  Designing a BudgetPro Servlet 
  Prototype 
  Design 
  Review 
  What You Still Don’t Know 
  Resources 
  Exercises 
  JSP: Servlets Turned Inside Out 
  What You Will Learn 
  Servlets Turned Inside Out: JSP 
  How to Write a JSP Application 
  Scriptlet 
  Declaration 
  Expression 
  Directive 
  New Syntax 
  JavaBeans in JSP 
  Tag Libraries 
  Using JSP with BudgetPro 
  Review 
  What You Still Don’t Know 
  Resources 
  Exercises 
  Open Source Web Application Servers 
  What You Will Learn 
  Downloading JBoss 
  Be an Enabler, or “Let’s Be Codependent!” 
  Nonroot-Installed Software 
  Finer Grained Control 
  Installing JBoss 
  Things That Make It Go 
  System V Init System 
  RedHat/Fedora chkconfig 
  Other Distributions 
  IDE Integration 
  Disposition of Forces 
  Apache Geronimo 
  Installing Geronimo 
  Running the Geronimo Server 
  Developing Enterprise Scale Software 
  Introduction to Enterprise JavaBeans 
  What You Will Learn 
  Expanding to EJBs 
  EJB Concepts 
  Bean Types 
  Under the Hood 
  What’s in a Name? An Introduction to JNDI 
  Naming and Directory System Concepts 
  Common Directory Services 
  Putting a Face to a Name: JNDI 
  Using JNDI with JBoss 
  Building an EJB 
  What You Will Learn 
  EJBs: You Don’t Know Beans? 
  SessionBean 
  EJBObject 
  EJBHome 
  Summarizing the Pieces 
  EJBLocalHome and EJBLocalObject 
  Compiling Your Beans 
  Review 
  What You Still Don’t Know 
  Resources 
  Deploying EJBs 
  What You Will Learn 
  Lend Me Your EAR: Enterprise Packaging and Deployment 
  What’s in an EJB-JAR File 
  Using Our Bean 
  Packaging the Servlet 
  Deploying the EAR 
  JBoss 
  Geronimo 
  Maintaining a Distributed Application 
  Ant and CVS 
      checkout
             The process of acquiring a copy of the source (one or more pieces) from
             the repository.
       commit
             The process of adding the changes from your sandbox into the repository.
       update
             The process of revising your sandbox with changes that have occurred in
             the repository since you last updated or created your sandbox. When you
             “update” your sandbox, other developers’ changes that have been commit-
             ted to the repository are merged into your source sandbox.
       tag
             As a noun, is a special label that you create to mark a milestone in your
             source repository; you can return to that milestone by checking out a copy
             of the source with that tag.
       tag
             As a verb, refers to creating a tag in the source repository.
192                                                 Chapter 8   Know What You Have: CVS
          Once a repository has been set up for use by a project, each developer
    would check out a copy of the source. Thereafter, the typical sequence for a
    developer would be:
      1.  Edit.
      2.  Test.
      3.  Commit.
      4.  Go to step 1.
          In some organizations, developers will commit and then test. Others will
    want to only commit changes that have been tested. Which order you choose
    is a policy decision by your project, not mandated by CVS.
          TIP
          We recommend that you test before committing because once you have com-
          mitted your changes, they become available to all others developers. The more
          people are working together on a project, the more important it is to keep the
          source base workable, that is, clean compiling at least, so others can keep
          working.
          Sometimes the developer needs to do an update step before a commit.
    Such a step is used to integrate other developers’ changes into this developer’s
    source. Sometimes this goes smoothly; other times it needs some
    additional work.
          A simple scenario might help explain these steps, too.
          Two developers, Ti and Kwan, are working on project Doh. They already
    have a repository set up with all the source for project Doh. Each developer,
    on his/her own system, checks out a copy of the source (cvs checkout doh).
    Now let’s say that part of the source is a Java class file called Account.java
    and it has had several changes made already, so Account.java is now at
    version 1.7 in CVS.
          Let’s say that Ti finds a bug in Account.java and makes a change to fix
    that problem. Ti checks in (commits) the changes to Account.java (cvs
    commit Account.java) so that the repository now contains Ti’s changes,
    which CVS keeps as version 1.8 of Account.java.
          All this time Kwan has been busy modifying Account.java (e.g., adding
    a new method). Remember that Kwan is working from the 1.7 version. When
8.2 Source Control: Whys and Hows                                                   193
       Kwan goes to commit his modified version of Account.java to the repository,
       he is notified that Account.java has been changed since his copy was checked
       out, and the commit attempt fails. So Kwan does an update which merges the
       1.8 version of Account.java in with his modified 1.7 version. If all goes well,
       the resulting file will be a 1.8 version of Account.java which includes Kwan’s
       new changes in the right place(s). Kwan just commits this to the repository,
       and Account.java then stands at version 1.9.
             Note that cautionary phrase “if all goes well.” The merge will work if Ti
       and Kwan have each modified different parts of the same file. If all Kwan did
       was add a new method, it would merge just fine. But what if they both make
       changes in the same region of the source file? It is up to the programmer to
       resolve such conflicts and commit the source once again.
             In such a situation, CVS does what it can to help out. There is an example
       of a merge conflict later in this chapter. But such conflicts require human
       intervention.
             Merging of conflicts is, undoubtedly, a very manual process, but you will
       be surprised by how infrequently you need to do this. Most changes will be
       merged clean with no manual intervention required. That’s probably because
       most often, when two or more programmers are modifying the same file, they
       are modifying different sections of it.
             With merging, you have the ability to incorporate other developer’s
       changes into your version of the source without the fear of losing your changes.
       No one’s changes get lost, no one’s files get “stepped on.”
       8.2.1     Setup
       Before you can use CVS to track your sources, you need to initialize a reposito-
       ry. You can use this repository for several different projects, so you only need
       to do this setup once.
             There are two different ways to connect to a repository—directly on a
       filesystem, or indirectly over a network. We will use the simpler filesystem
       mechanism for this discussion. The network connections are described in the
       references at the end of this chapter.
             In order for CVS to know where the repository is located and how to
       connect to it, it looks for an environment variable called CVSROOT. You can
       assign a value to CVSROOT from the command line each time you create a CVS
       project, or for more convenience, you can set it in the shell startup script
       (e.g., .bashrc) so that its ready all the time. The CVSROOT value is really only
194                                               Chapter 8  Know What You Have: CVS
    used, though, to set up the project. Once a project is established, the informa-
    tion in CVSROOT is kept, along with other data, in a directory of files (called
    CVS). From that point on, CVSROOT (the environment variable) no longer needs
    to be set. The CVS commands will always use what is in the local sandbox to
    determine where the repository is; the value of the environment variable will
    be ignored.
         It is possible to have different repositories for different projects. One
    repository might be for your personal work—revisions of memos and docu-
    ments that you create on your local machine and store in a repository also on
    your local machine. Another repository might be a shared network-based
    repository, used for a project at work. Still another might be a network-based
    project for some Open Source work that you do in your spare time. Since the
    CVS repository keeps track of whence it comes, you needn’t set a value for
    CVSROOT every time you switch projects. Instead, CVS knows from within the
    sandbox where to go for its updates, commits, and so on.
         So let’s get started and create a CVS repository on our local Linux system,
    in our own home directory. We will call the repository srcbank, as it will be
    the “bank” where we will deposit our source files.
    $ mkdir ${HOME}/srcbank
    $ export CVSROOOT="${HOME}/srcbank"
    $ cvs init
         The mkdir creates the directory named srcbank as a subdirectory of our
    home directory. The export command sets the shell variable CVSROOT to refer
    to the location of the new directory. The cvs init command initializes the
    repository with some needed directories and data files.
         Before the cvs init command, the srcbank directory is empty. After-
    ward it contains a directory called CVSROOT (literal name, not the shell variable’s
    value) which contains a variety of administrative files—most of which you need
    never worry about.
         If your are using a remote repository, that is, one that you connect to over
    a network (typical when you are sharing a repository amongst team members),
    then you need one additional step—you need to log in to the CVS repository’s
    server:
    $ cvs login
8.2 Source Control: Whys and Hows                                                      195
       which will prompt you for a password. Having logged in once, you will not
       need to log in again, even after reboots of your system, as CVS keeps the
       password (by default; it can be changed) in a file called .cvspass in your home
       directory. This makes using CVS with a remote repository (once you’ve logged
       in as simple as if the repository were local). From here on, the commands will
       all look the same. If your repository is remote, CVS will use the password from
       your .cvspass file, without asking you for it.
       8.2.2     Import
       Are you wanting to use CVS on an existing project? Have you already got your
       project at least partly underway? Let’s look at how to enter all those files into
       CVS with a single command.
             Not every file that is in a working directory needs to be kept under source
       control. Some, like .class files, are created from the .java source files. Others
       may be just scratch files that you don’t want to keep versioned.
             To automatically exclude certain files from ever being included in your
       repository, CVS uses a file called .cvsignore that lists filename patterns. Any
       filename matching a pattern will be ignored by all CVS commands.
             Here is a .cvsignore file that we recommend for Java developers:
       *.zip
       *.class
             This will exclude any file whose name ends in .class or .zip. Note that
       the comparison is strictly based on a name, not the actual contents. CVS
       doesn’t know what a “class” file is; it is only excluding a file based on its name.
             Certain files are not really source files and can’t be managed as such, but
       we would still like to keep versions and a history of changes for them. A good
       example would be an image file. For example, you may have a corporate logo
       in a file called logo.jpg and at some point you may get a new or revised ver-
       sion of that file. You can use CVS to track such files, but you need to tell CVS
       that this is a binary file, so that CVS doesn’t try to do some special substitutions
       that it does on check-in and check-out. (More about those substitutions later.)
             For now, let’s just consider how to tell CVS which files are binary. We can
       do that on the command line when we create a new file, but for importing a
       lot of files at once, and to avoid the need to remember doing that each time we
       add a file, we can put patterns for binary filenames in a CVS file called
       .cvswrappers.
196                                              Chapter 8  Know What You Have: CVS
         Here is a .cvswrappers file that we recommend for Java developers:
    #
    # A recommended .cvswrappers file
    #
    # jar files - treat as binary:
    *.jar -k 'b'
    #
    # Image file formats - treat as binary:
    *.gif -k 'b'
    *.jpg -k 'b'
    *.png -k 'b'
    *.tif -k 'b'
    #
    # Document file formats - treat as binary
    # both MSOffice and OpenOffice.org file formats:
    *.doc -k 'b'
    *.ppt -k 'b'
    *.xls -k 'b'
    *.sx? -k 'b'
         The format of the file is very UNIX-like. A leading # means that the rest
    of the line is a comment. The asterisk matches any number of any characters.
    The question mark matches a single character.
         Now we’re ready to import. The .cvsignore file should be placed in the
    topmost directory of the set of files that you want to import. Then, from that
    directory, issue the command:
    $ cvs import Project YourCo import
    where Project is whatever name you want to use for this project (or module)
    in CVS, and YourCo is the name of your company or some other designator
    to differentiate this source from other third-party packages that you may keep
    in your repository.
         Most importantly, execute the cvs import command from within the
    directory, even though the name of the project is likely (but doesn’t have to be)
    the same as the name of the directory in which you sit.
         For example, consider a fragment of the filesystem shown in Figure 8.1.
    You would want to cd into the directory coolj and then issue the import
    command:
    $ cd coolj
    $ cvs import coolj GJSinc import
8.2 Source Control: Whys and Hows                                                           197
                             mydir
           prev               coolj           misc
         FetchURL.java        Sprit.java    Tux.java
       Figure 8.1 A sample directory structure prior to import
             This will create a module named coolj in the repository, whose contents
       are all the directories and subdirectories that you see there. But you had to be
       in the coolj directory, which may seem counter-intuitive.
             Now go to some other directory, one that is not part of the coolj part of
       the tree, and check out a copy of the source. For example:
       $  cd
       $  mkdir devsrc
       $  cd devsrc
       $  cvs checkout coolj
             NOTE
             It is important to check out the source after you’ve done the import, and before
             you make any changes, because the part of the filesystem that you imported
             remains untouched. It has no CVS knowledge, so you can’t commit changes
             from that directory, unless you somehow make it CVS-aware. Since these files
             are your originals, until you’ve verified that the cvs import has gone as
             planned, it’s best not to disturb those files. Create a new directory and check
             out the module there.
             What do you see after the checkout? There should be a single directory,
       coolj,     in the directory where you did the checkout (since it was empty when
       you started). That directory contains a copy of all the files that you checked in,
       along with a directory named CVS inside that directory and every subdirectory.
       The CVS directories contain administrative files that help CVS keep track of
       things for you, which means no CVS tracking information needs to be kept in
198                                                Chapter 8   Know What You Have: CVS
    your source. You should never need to mess with the files in the CVS directory;
    see the Cederqvist reference in Section 8.6 for more information about
    these files.
    8.2.3     Normal Use
    The typical use of CVS occurs after you’ve made some changes to your source
    code. At some point, typically after the code compiles cleanly or after the
    changes have been tested to some extent, you will want to commit your changes
    to the CVS repository. When you commit one or more files, they become the
    latest version, the version that others get when they checkout or update the
    module. To say it another way, when you commit, you make those changes a
    permanent part of the source repository, available to others.
          You can commit a single file at a time, like this:
    $ cvs commit Account.java
          Or you can commit several files at a time, like this:
    $ cvs commit Account.java User.java Xyz.java
          Or you can commit all the changes from a certain point in the filesystem
    hierarchy (e.g., the current directory) on down, like this:
    $ cvs commit
    (Specifying no files implies the current directory. You can also name a directory
    explicitly.)
          When you commit changes, CVS wants you to provide a bit of commen-
    tary to explain what you’ve changed, to say something about this new version.
    The comment can be supplied on the command line, with the -m option:
    $ cvs commit -m "bug fix"
          If you don’t provide the -m parameter and its argument, CVS will invoke
    your favorite editor (as specified in the environment variable CVSEDITOR or
    VISUAL or else EDITOR, in that order of precedence). The default, on Linux
    systems, is to invoke vi (see Figure 8.2). In the editor, you can type one or more
    lines of text; when you exit, the commit will continue to completion.
8.2 Source Control: Whys and Hows                                                              199
       Figure 8.2 CVS asking for commentary as part of a commit
             NOTE
             If you quit the editor without writing your changes (in vi, that would be :q!) then
             CVS will ask if you want to abort the entire commit. If you choose to abort, no
             changes will be made to the repository. You’ll be right back to where you were
             just before typing the cvs commit command.
             You will be able to see the comments associated with each version of the
       file using the cvs log command (see Section 8.2.6).
             As you will want to provide brief but meaningful descriptions in these
       comments, it may be helpful to remind yourself what in fact has changed. You
       can see the differences between the version that you checked out and the file as
       it stands today by using the cvs diff command:
       $ cvs diff Account.java
       Here, as in commit, you can name one or more files, or even a directory. CVS
       will display what lines you’ve added, modified, or removed in each file.
200                                                  Chapter 8   Know What You Have: CVS
Example 8.1 Sample output from cvs diff
$ cvs diff Account.java
albing@cvs.multitool.net's password:
Index: Account.java
===================================================================
RCS file: /usr/lib/cvs/cvsroot/JavaAppDevLinux/majorApp/net/multitool/core/
Account.java,v
retrieving revision 1.10
diff -r1.10 Account.java
31d30
<        this.parent = null;
66a66
>     * returns an iterator
93c92
<        children.put(acct, name);
---
>        children.put(name, acct);
$
            In Example 8.1, CVS has found three differences—one line being re-
       moved, one line being added, and one line being changed. The < precedes lines
       from the repository version, and the > precedes lines from the new, that is,
       changed, version. The 31d30 shows the line numbers from both versions, sep-
       arated by a single character to indicate what difference action is being described:
       a for adding lines, d for deleting lines, and c for lines that change.
            A typical work sequence might go something like this:
         1. Edit some files.
         2. cvs diff those files.
         3. cvs commit those files.
         4. Go to 1.
            The cvs diff command is also quite useful for finding out what changed
       between some previous version of a file and the current version:
       $ cvs diff -r 1.15 Account.java
       or between two different previous versions:
       $ cvs diff -r 1.12 -r 1.15 Account.java
8.2 Source Control: Whys and Hows                                                     201
       or since a certain date:
       $ cvs diff -D 06-Sep-03 Account.java
       8.2.4     Update
       If there are other people working on this project with you, they will also be
       making changes. To bring there changes into your sandbox, run the cvs
       update command:
       $ cvs update
       cvs server: Updating .
       P Account.java
       M User.java
       cvs server: Updating subdir
             Here, P indicates CVS has patched in changes to that source file; and M
       indicates you have modified the file. Note that Xyz.java is not mentioned.
       That means there were no updates involved.
             The subdirectory subdir was also updated, but no changes were made.
       Had a change been made, you would see the modified files mentioned by name.
             You can update a single file at a time by naming that file on the command
       line, but typically you want to get the changes for all the files in a directory, or
       even all the changes throughout the project, since a change in one file may be
       dependent on changes in other files.
             Sometimes when you try to commit your changes you will be told that the
       commit did not succeed because one or more of your files was not up to date.
       Not to worry; it’s easy to bring your files up to date. This leads directly into
       our next topic. Read on!
       8.2.5     Merges
       When you commit changes, a new version of each changed file is now part of
       the repository. If someone else commits changes, that person’s changes are now
       part of the repository as well. But those changes (unlike your own local changes)
       are yet to appear in your own local copy of the files, that is your sandbox.
             The following CVS command will bring your files up to date with all the
       changes made since you checked out your copy (or last did an update):
       $ cvs update
202                                              Chapter 8  Know What You Have: CVS
         With that command all the files from the current working directory on
    down will be updated with the most recent versions of the files from the
    repository—and not just updated: changes that you have made in your local
    files will be preserved and merged with the new version of the files.
         Here’s what a successful merge looks like:
    $ cvs update Account.java
    cvs server: Updating Account.java
    M Account.java
    RCS file: /usr/local/srcbank/JavaAppDevLinux/Account.java,v
    retrieving revision 1.17
    retrieving revision 1.18
    Merging differences between 1.17 and 1.18 into Account.java
    M Account.java
    $
         Remember our scenario earlier in the chapter? Our two programmers, Ti
    and Kwan, have each modified the same file. If all Kwan changed was adding
    a new method, it would merge just fine. But what if they both made changes
    in the same region of the source file? Well, the first one to check in his changes
    will be fine. His commit will succeed. But the second person to try to commit
    changes to the file will find that CVS will report an error:
    $ cvs commit Account.java
    cvs server: Up-to-date check failed for `Account.java'
    cvs [server aborted]: correct above errors first!
    cvs commit: saving log message in /tmp/cvsQ9rk01
         Now, attempting to update will put both versions in your local file, marked
    up by certain character strings to highlight and separate the sections. It is up
    to the programmer to resolve those conflicts and commit the source once again.
         Here’s an example of how a conflict might look in a source file:
    <<<<< ver. 1.7
    for (i=0; i<20; i++) {
         myData.callSomething(dollars, time);
    }
    ======
    while (i<20) {
         myData.callOtherwise(dollars*(i++), time/60);
    }
    >>>>>
8.2 Source Control: Whys and Hows                                                   203
             In such a case, the programmer must decide which changes to keep, or
       how to combine them. After editing the file and removing the dividing lines
       (i.e., <<<<<, =====, and >>>>>), recompiling and probably a bit of testing,
       too, the programmer can now do a cvs commit to incorporate his changes in
       the repository.
       8.2.6     Log
       With each cvs commit you are prompted for a comment, to describe the
       changes that you are committing. What happens to these comments? How can
       you see them again? Use the cvs log command to show the history of a file’s
       revisions and associated comments.
             See Example 8.2 for an example of the cvs output command.
             Looking down the output of cvs log, you can see
          • The complete filename—in the repository—of the file whose log we’re
             checking out.
          • The local filename in your sandbox.
          • Which revision is the “head,” that is, the front-most or default revision.
          • Which branch, if any.
          • What kind of locking mechanism CVS uses. There are some choices, but
             most users of CVS leave this as is.
          • The access limitations. CVS can limit who can modify files (see our
             reference list if you need to use this).
          • A list of all the tags (symbolic names) for this module and to which
             revision each refers.
          • What kind of keyword substitution happens. For binary files this would
             be kb.
          • The count of revisions for this file.
             Then comes a description of each of the revisions, showing
          • The revision number.
          • Some stats on the change including the user ID of the user who committed
             the change.
          • How many lines were added and deleted compared to the previous revi-
             sion.
204                                                  Chapter 8  Know What You Have: CVS
Example 8.2 An example of running the cvs log command
$ cvs log Account.java
RCS file: /usr/local/srcbank/JavaAppDevLinux/Account.java,v
Working file: Account.java
head: 1.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4; selected revisions: 4
description:
----------------------------
revision 1.4
date: 2003/05/20 11:59:59; author: albing; state: Exp; lines: +80 -5
more comments added
----------------------------
revision 1.3
date: 2003/05/18 15:03:23; author: albing; state: Exp; lines: +3 -2
end case fixed
----------------------------
revision 1.2
date: 2003/05/17 11:05:40; author: albing; state: Exp; lines: +69 -2
actually runs - unit tested
----------------------------
revision 1.1
date: 2003/05/17 10:15:18; author: albing; state: Exp;
a rough structure
=======================================================================
          • The comment that was entered when the user committed the change.
       (For a description of state, and why you will almost always see Exp;, see the
       Cederqvist reference in Section 8.6.)
             Do you want less output from cvs log? You can restrict the information
       to cover only a certain user’s changes (-w), to a certain range of revisions (-r),
       and/or between certain dates (-d).
             For example,
       cvs -walbing -r1.2:1.4 -d05-Sep03 -d28-Sep-03 Account.java
       will list only changes committed by user albing, only in the revision range of
       1.2 through 1.4, and only between the dates of 05 and 28 September of 2003.
8.2 Source Control: Whys and Hows                                                      205
       Note: do not put a space between the -w, -r, or -d and its parameter or CVS
       will think that the parameter is the name of a source module, and you will see
       a message like this:
       $ cvs log -r 1.2:1.4 Account.java
       cvs log: nothing known about 1.2:1.4
       ...
       which will be followed by output about the Account.java module that CVS
       does know about.
             For more variations on the logging output, type:
       $ cvs log --help
       8.2.7     cvs status
       While the cvs log command will tell you about the history of all revisions of
       a file, you sometimes need to know the status of the current file in your sand-
       box: Which revision is it? From where did it come? And, most importantly, is
       it part of the head or part of a branch?
             Those questions can be answered with the cvs status command. Its
       output will show the revision number of the file in your sandbox and any
       “sticky” tags. But to understand what that means, we need to talk about tags
       first.
       8.2.8     cvs tag
       We began this chapter asking: “Can you find or create a set of sources that
       matches exactly what your customer is running? Can you then provide a mod-
       ified version that contains only the fix necessary and no other changes?” Part
       of the answers to these questions will depend on your use of the cvs tag
       command. With it, you can set down a label across all your source to mark a
       particular milestone, so that later you can recall that version of the source.
       For example,
       $ cvs tag Rel_2_4
       will put a tag (that is, a label) called Rel_2_4 on the head revision of all source
       files from the directory where this command was executed on down through
206                                                    Chapter 8  Know What You Have: CVS
    all its subdirectories. If you run this command from the uppermost directory
    in your project sandbox, it will label your entire project.
           A tag can be applied to a single file or group of files by listing them
    explicitly on the command line.
           NOTE
           Certain special characters are not allowed in CVS tags. Specifically, the charac-
           ters $,.:;@ are not allowed. So you can’t use release_2.4 as a tag.
           Too bad.
           Tags cut across the various revisions of the source. While you can specify
    that a tag goes on the same revision of all sources (e.g., cvs tag -r 1.3
    one_dot_three_tag), the more typical use is to tag different revisions of each
    module, the revisions that you’ve just been working with and testing.
           Figure 8.3 shows a tag (QA) that cuts across the various revisions of the
    different sources. With such a tag, someone can check out a copy of the sources
    to get the QA release:
    $ cvs co -r QA project
       a.java            a.java           a.java
        v. 1.1           v. 1.2           v. 1.3
       b.java            b.java           b.java           b.java
        v. 1.1           v. 1.2           v. 1.3           v. 1.4
       c.java            c.java
        v. 1.1           v. 1.2
      QA tag
    Figure 8.3 A tag across three files
8.2 Source Control: Whys and Hows                                                             207
             Since your project would likely have more than one time in its life that it
       would be handed off to QA, some people will put date information in the tag,
       for example, QA_2003_07_15. Others will use a simple tag, such as QA, but
       such a tag may need to be reused.
             If you’ve put down a tag and decide that you no longer want that tag
       (for example, your product is preparing for a new QA cycle and you want to
       reuse last cycle’s tag, or maybe you simply misspelled your tag), you can delete
       it using the -d option.
             WARNING
             Once you delete a tag, it’s gone forever. It is not available even when you recall
             earlier versions. If you reuse a deleted tag, it doesn’t remember any history from
             its first use.
             Imagine your project has just reached a milestone, like the hand-off to QA,
       so you have tagged your source accordingly. Now the QA group finds a bug and
       you fix it. What do you do with the tag? The tag will be on the unfixed version
       of source. One thing that you can do, after you commit your changes, is simply
       to move the label:
       $ cvs commit Account.java
       ...
       $ cvs tag -F QA Account.java
       This will “force” the tag on Account.java to move to the current version.
             Such a mechanism works fine for the short term, for quick changes that
       are put in shortly after the tag has been set down. But what if it takes QA several
       days to find the bug, and what if, during that time, you’ve been refactoring
       Account.java, or adding features for a future release? In those cases, what you
       really need is a branching tag.
       8.2.9       Branching Tags
       When you use the -b option with a cvs tag command, then the tag you create
       is a “branching” tag. That means that you now have two paths in your source
       repository. You can check out source from, and commit changes to, either of
       those paths. This allows you to keep moving ahead with new development on
       the head or tip of the source while providing fixes against a previous version.
208                                                   Chapter 8    Know What You Have: CVS
           a.java           a.java            a.java          a.java     Head
           v. 1.3           v. 1.4            v. 1.5          v. 1.6
                            a.java            a.java   QA
                            v. 1.4            v. 1.5
    Figure 8.4 A simple branch and merge
          Figure 8.4 shows a single source file with a single branch. The tag (QA)
    may have been applied to multiple files, typically to your entire project. The
    branched version of each file (for example, 1.3.1.1) is not created until the next
    change is checked in for that file, so many of the files with the tag may still be
    on their main source branch.
          TIP
          When do you want to create a branching tag? You can do it at any time that you
          lay down a tag. We have found it best to do it right away when you “release”
          your software, that is, whenever you hand it off to another group (e.g., QA or
          customers). This provides a label (the tag) to identify what exactly was handed
          off, but also puts the possibility for branching in place for fixes that may be
          needed on that branch.
          Let’s look briefly at the steps you would take to lay down a branching tag
    named QA, and then apply a fix to that branch.
          In the directory where you have your current source, which is what you
    just released, set down the branching tag:
    $ cvs tag -b QA
          NOTE
          You have just set down the branching label on the source but you have not
          changed your current set of sources. If you make changes in the current direc-
          tory (and subdirectories) and check those changes in, you will be making those
          changes to the head, not the branch, of the source.
8.2  Source Control: Whys and Hows                                                  209
Example 8.3 Checking out a tagged revision
$ cd
$ mkdir fixes
$ cd fixes
$ cvs co -r QA myproject
cvs checkout: Updating myproject
...
U myproject/Account.java
U myproject/Caltron.java
U myproject/Demo.java
U myproject/Employee.java
U myproject/Person.java
...
$ cd myproject
$ cvs status Account.java
===================================================================
File: Account.java           Status: Up-to-date
    Working revision:        1.2        Sat Oct 26 03:32:17 2002
    Repository revision:     1.2        /usr/local/srctree/myproject/Account.java,v
    Sticky Tag:              QA (branch: 1.2.2)
    Sticky Date:             (none)
    Sticky Options:          (none)
$
             Now that you have the label set down, you need to check out a copy of
        that version of the source. Since we are checking out a new copy, be sure that
        your CVSROOT environment variable is set appropriately (see above). Then find
        some new directory to put your source and check out a copy with the tag, as
        shown in Example 8.3.
             We did a cvs status after the checkout to show you the important dif-
        ference between this version and the other versions. These files will all show a
        Sticky Tag in their status. This is the label used to check out or update this
        version of the source. When you check in changes to these source files, the
        changes will be against that branch, and not the head.
             From there on, everything is the same. Make your changes and just check
        files in as usual. CVS will remember (via the files in the CVS directory) that
        you’re on the branch, so when you check things in, they’ll go to the branch.
             The important thing is to create the tag as a branch tag so that you can
        commit changes against that branch. The downside, however, is that you now
210                                               Chapter 8   Know What You Have: CVS
    have two different source versions; bug fixes have to be made in both sources,
    new features have to be added twice, and so on.
          The easiest way to deal with that is to keep your number of active branch
    tags small; you likely don’t want to have to apply a fix to 14 different
    branches. Also, keep the lifespan of the branches brief—which is, of course, a
    relative term.
          CVS does provide commands to merge a branch back into the source head.
    But for this, we will refer you to other CVS material. Our job is to give you an
    overview and a feel for the possibilities. For this sort of task you will want a
    complete reference manual.
          For more variations on cvs tag, type:
    $ cvs tag --help
    8.2.10 cvs export
    If you want to produce a copy of your source tree without the CVS subdirecto-
    ries—just the pure source—you can use the cvs export command. Like the
    inverse of import, it will check out a copy of the source, but will not create any
    of the CVS subdirectories that allow CVS to manage the commits, checkouts,
    logging, status, tags, and so on. In other words, the exported directories are not
    a CVS sandbox—they’re just a copy of the files.
          NOTE
          Changes made to an exported collection of files cannot be committed back to
          CVS. Of course you can get the changes back into CVS by creating a sandbox
          with a cvs checkout command, copying all or some of the exported files into
          that sandbox, and then committing the changes from there. But it’s better to
          think of export as a one-way street.
    8.2.11 A Quick Look behind the Scenes
    If you are one of those people who worry excessively about efficiency, let us re-
    assure you that CVS is OK. You could think of a CVS repository as saving each
    revision of a file (for example, versions 1.1, 1.2, and 1.3), but in fact CVS only
    keeps a single full version of a file—the latest version—and then stores the
    deltas, that is, changes required to revert back to the previous versions. So it
    keeps a full version of 1.3, but then only the differences between 1.3 and 1.2
8.3  A GUI: jCVS                                                                       211
        and the differences between 1.2 and 1.1. This means that it is always very effi-
        cient to get the latest version of any file. (Other systems have tried keeping the
        original and the deltas for each revision going forward—but that gets very ex-
        pensive to retrieve versions with hundreds of modifications. With CVS, the
        latest version is always at hand.)
              An exception to this are “binary” files, those on which CVS can’t do key-
        word substitutions. The revisions of those files, such as JPEG image files, won’t
        be stored by deltas, but by complete copies of each revision.
   8.3 A GUI: JCVS
        If you are a die-hard GUI kind of developer, and aren’t yet convinced of the
        power and convenience of the command line, then reread Section 1.3.10. If
        you are still not convinced, that’s OK—you can still use CVS with the help of
        a GUI written entirely in Java. This is an implementation of the CVS client,
        that is, the portion of the CVS system that communicates with a remote server.
        The server does the real work of managing the versions; the client collects the
        data, manages the local files, and communicates with the server.
              If you’re going to use jCVS, you will need to get a CVS server up and
        running—or maybe your project administrator has already done that. If so,
        read on.
        8.3.1     Installing jCVS
        jCVS can be downloaded from www.jcvs.org where you can get it as a zipped
        archive file. Unzip it into a directory and create a shell script to make it easy to
        invoke. Since jCVS is an actual Java program, all the shell script needs to do is
        to ensure that its JAR files are on the CLASSPATH and then invoke the jCVS
        main class.
              Here’s a straightforward shell script which will accomplish that:
        JCVS="/usr/local/jCVS-5.2.2"
        CLASSPATH="${CLASSPATH}:${JCVS}/jars/activation.jar"
        CLASSPATH="${CLASSPATH}:${JCVS}/jars/jcvsii.jar"
        CLASSPATH="${CLASSPATH}:${JCVS}/jars/jh.jar"
        CLASSPATH="${CLASSPATH}:${JCVS}/jars/js.jar"
        java -jar ${JCVS}/jars/jcvsii.jar
212                                             Chapter 8  Know What You Have: CVS
          You would need to change the definition of JCVS to match the directory
    where you unpacked the ZIP file, but the rest will work with your location. Of
    course the classpath could all be set on one longer line, but this way is more
    readable.
          Run jCVS (Figure 8.5) and navigate to the checkout page (Figure 8.6) to
    fill in the parameters for your CVS server. Then you should be able to contact
    it for checking out your sources (Figure 8.7).
    Figure 8.5 jCVS splash screen
    Figure 8.6 jCVS initial screen
8.4  Review                                                                           213
        Figure 8.7 jCVS checkout screen
             Conspicuous in its absence on the jCVS Web site is a good user manual.
        Since we’re proponents of the command line, don’t look for it here, either.
             Many, if not most, Java developers these days will be using, at least part
        of the time, an Integrated Development Environment (IDE). One of the tools
        that these IDEs integrate is a source code manager, and typically for Open
        Source tools that means CVS. So while we’re not giving you much info on
        jCVS, you will find a useful GUI for CVS inside most IDEs.
   8.4 REVIEW
        This chapter has been all about CVS, one of the great jems of the Open Source
        world. Projects all across the globe depend on CVS to track their source
        changes, as programmers half a world away collaborate and share source.
             We discussed how to import source files into CVS and how to get them
        back out. We discussed the mechanism for checking in changes and how to
        sort out collisions for the rare occasions when automatic merges don’t succeed.
        We described how to tag a set of source files for later retrieval, and how to make
214                                               Chapter 8  Know What You Have: CVS
      those tags into branches in your source tree. We also discussed how to show
      the history of those changes and the status of a source file. Finally, we took a
      quick look at a GUI for use with CVS, for those so inclined.
  8.5 WHAT YOU STILL DON’T KNOW
        • The myriad of administrative commands which help you manage and
           maintain a source library. Most of those commands you won’t need, but
           it’s nice to know that they are available, just in case. Refer to the
           Cederqvist document (Section 8.6) for all the gory details.
        • How to set up remote users for sharing a CVS repository on a network,
           especially the use of the CVS_RSH environment variable.
        • How CVS integrates into development tools. We’ll see this in the coming
           chapters; for example, CVS interaction is built into NetBeans, SunONE
           Studio, and Eclipse.
        • How good it feels to have CVS come to the rescue so you can recover a
           version of something that you thought was lost. May you never have to
           learn this the hard way.
  8.6 RESOURCES
        • Version Management with CVS by Per Cederqvist et al. is the “official”
           manual for CVS. It can be viewed as HTML or downloaded as HTML,
           PDF, or PostScript from http://www.cvshome.org/docs/manual/.
        • Chapter 6 of The LINUX Development Platform: Configuring, Using and
           Maintaining a Complete Programming Environment by Rafeeq Rehman and
           Christopher Paul (ISBN 0130826758, Prentice Hall PTR) gives a good
           introduction to CVS. They give more information, too, on jCVS as well
           as on how to integrate CVS into Emacs.
    Chapter 9
    Ant:
    An Introduction
    Ant1 is a tool for building and deploying collections of files. It is particularly
    suited to building and deploying Java applications (in no small part because it
    is written in Java). Ant is well worth knowing and using for all but the simplest
    Java applications.
9.1 WHAT YOU WILL LEARN
       •  How to install and set up Ant.
       •  Enough about XML to read an Ant buildfile.
       •  The basic tags used in most buildfiles.
       •  The extent of our remaining ignorance after completing the chapter.
    1. I must mention something about the title of this chapter: There was a Monty Python’s
    Flying Circus episode that had this title, and my inner geek couldn’t resist.
                                                                                       215
216                                                           Chapter 9   Ant: An Introduction
  9.2 THE NEED FOR A DIFFERENT BUILD TOOL
      James Duncan Davidson had a problem. Perhaps you’ve had this problem, too.
      It has to do with the building of software—compiling, copying, and otherwise
      modifying files to get all the pieces in all the right places for running a collection
      of programs.
            There are a number of ways to automate the building of software. You can
      script the compilation using shell scripts or batch jobs. That works fine, but
      there are two problems with that solution. First, scripts are generally not
      portable across very different operating systems. That’s a serious problem for a
      language like Java, which is intended to be portable across operating systems.
      Second, it is difficult if not impossible, using scripting languages, to prevent
      wasted compiles; the checking and comparing of date stamps on source and
      object files makes scripts large and difficult to maintain.
            Very well, we hear you say. There’s make. The make program has been
      around for a long time. It is available on many operating systems. It handles
      the conditional compilation of files very well. It has been around for centuries
      (it seems). It is well known and widely used. All of this is true, but even this
      venerable tool falls a bit short in the Java world. First of all, although makefiles
      are generally far more portable than other scripts, there are still considerable
      variations in details, and make does nothing to mask the differences in file,
      path, and disk designations that exist across operating systems. Moreover, both
      make and scripts suffer from a more basic problem. Although Java programs
      can execute reasonably quickly, the overhead of starting a JVM and tearing it
      down again is considerable. Since javac is written in Java, each time it is in-
      voked to compile a source file (one file at a time is the make way) this setup
      and teardown time cost is paid.
            But, we once more hear you protest, you can just use javac on the entire
      project! Doesn’t it build everything that needs to be built? In the simplest case,
      yes, it does. But as soon as you share code between projects, or use RMI which
      requires execution of the rmic compiler, or use EJBs, or link in native methods,
      then javac’s dependency resolution just will not work.
            Luckily, James Duncan Davidson had this problem. And luckily it really
      bothered him. And even more luckily for us all, he decided to share his solution.
9.3  Obtaining and Installing Ant                                                                   217
              His solution was Ant, which we will from now on refer to as ant. Why
        ant? Well, he suggests that it might be because ants are little things2 that build
        big things. He has also suggested (in his preface to the O’Reilly book Ant: The
        Definitive Guide, Jesse Tilly and Eric Burke) that it might stand for “Another
        Neato Tool.” We’re inclined to put forth the former, but believe the latter.
              James Duncan Davidson wrote ant and contributed it to the Apache
        project, so it is Free Software. And it makes the problems cited above rather
        piffling. Through the rest of this chapter we will describe how.
   9.3 OBTAINING AND INSTALLING ANT
        You can obtain ant from the Apache Web site.3 Which version you download
        will depend on your system and your needs. There are stable releases and daily
        builds. Unless you have a compelling need for a feature not yet in a stable re-
        lease, we would suggest you stick with the most recent stable release. As of this
        writing, that is version 1.5.1.
              If you are using RedHat, or another Linux distribution that uses the
        RedHat Package Manager, rpm, then the simplest way to install would be to
        download the RPMs linked from the Web site and install those:
        $ rpm -i ant-1.5.1-3jpp.noarch.rpm
              You have two other options besides the trusty old RPM method. First,
        you may download a binary tarball, a word often used for a compressed file
        created with the tar utility, or you may download and compile the ant
        source code.
              Let’s take these each in turn.
        9.3.1     Installing a Binary Tarball
        Binary distributions of ant are available in .zip, .tar.gz, and .tar.bz2
        formats. Utilities are available for all of these formats for Linux, although you
        2. Not so little anymore. As of this writing, the head of the CVS tree for ant weighs in at just
        shy of 48MB, and there are 5,239 files in there! These totals include a lot of project documen-
        tation, but even considering only the src subdirectory, we are still looking at 18MB and
        1,687 files. It is probably incorrect to call ant a “little thing” these days.
        3. http://ant.apache.org/
218                                                        Chapter 9   Ant: An Introduction
    will find that generally .zip files are intended for Windows machines and
    .tar.gz and .tar.bz2 for UNIX systems. The .gz format is decompressed
    with the gzip utility and .bz2 files with the bzip2 utility. The bzip2 compres-
    sion algorithm produces better compression, while gzip is “more common.” If
    you have a modern Linux distribution, you almost certainly have both installed
    already.
          Once you have the archive file downloaded, you should download one of
    the files linked next to it. These are cryptographic hashes of the legitimate
    archive file so you may be (more) assured that the software is the software you
    think it is. The first, PGP, is an actual digital signature. If you are already famil-
    iar with PGP or GnuPG and are comfortable with them, then by all means use
    this. It is, as you know, a superior form of validation compared to MD5. But
    explaining how to use digital signatures and GPG keys is beyond our scope
    here. As for MD5, however, this is fairly easy.
          An MD5 hash is a 128-bit value generated in such a way that it is impos-
    sible for two different files of the same length to have the same hash value (ac-
    tually, the term used in the literature is “computationally unfeasible,” but for
    our purposes that is the same thing). If you run the program md5sum with the
    tarball file as an argument and you get the same number as the one you down-
    loaded, you may be certain that the file you have is an exact match with the
    one that was used to produce the number you downloaded from the Web page.
    Remember that this is all that is proved by this. If both the file server and the
    Web page have been compromised, then the fact of a match doesn’t mean
    much. A mismatch however proves that one of the two has been compromised
    and you probably shouldn’t use the tarball.
          You should get in the habit of verifying checksums and digital signatures
    where they are supported.
          If you are still worried about the dual compromise, well, that’s where a
    PGP digital signature can help. It not only proves the integrity of the data; it
    also proves the identity of the generator. Learn more about PGP (actually, the
    Free Software version of it, called GnuPG, at the GnuPG Web site.4
          Once you have downloaded both the md5 file and the tarball, validate and
    extract the tarball (Example 9.1).
          Note that we did this in a regular user’s home directory. If you just wish
    to use ant yourself, then this is the way to go. If you wish to make ant available
    4. http://www.gnupg.org/
9.3 Obtaining and Installing Ant                                                       219
       Example 9.1 Validating and extracting the ant tarball
       $ cat jakarta-ant-1.5.1-bin.tar.gz.md5
       2be27d9e09011bf1cc3d1967ee34f7d1
       $ md5sum jakarta-ant-1.5.1-bin.tar.gz
       2be27d9e09011bf1cc3d1967ee34f7d1 jakarta-ant-1.5.1-bin.tar.gz
       $ zcat jakarta-ant-1.5.1-bin.tar.gz | tar xf -
       $ cd jakarta-ant-1.5.1
       $ ls
       bin                 docs          etc                KEYS            lib
       LICENSE             LICENSE.dom LICENSE.sax LICENSE.xerces README
       welcome.html WHATSNEW
       $
       to multiple (or all) users on the system, you will want to untar as root and
       move the resulting directories to locations convenient to other users, such as
       /usr/local.
             Whether for one user or for many, there is a handful of remaining tasks
       to make ant usable.
       9.3.1.1     Environment Variables
       The JAVA_HOME environment variable should already be set as a result of setting
       up your JDK. JAVA_HOME should point at the base of your JDK installation.
             The ANT_HOME environment variable should be set to point at the untar-
       ed installation of ant. In our sample here, it would be ~/jakarta-ant-1.5.1.
             Make sure that the bin directory of the ant installation is added to
       your PATH.
       9.3.2     Installing a Source Tarball
       We do not encourage you to install ant from source, although we do encourage
       you to download and study the ant source. It is an excellent sample Java
       application.
             If you must build from source, the start of the process is the same as above.
       You download the tarball, verify it with GPG or md5sum, then unzip and
       untar it.
220                                                                 Chapter 9   Ant: An Introduction
           It begins to differ at this point. The ant source package comes with a shell
      script, build.sh, that actually builds a minimal version of ant and then runs
      ant to complete the install.
           Make sure that the JAVA_HOME and ANT_HOME are set as you want them,
      then execute build.sh install. Unless you have installed the optional tasks,5
      you will see several warnings about missing classes. You may safely ignore these.
           As with the installation of other packages built from source, you will need
      to have appropriate permissions for the target directories. This might mean
      running the install as root, with all appropriate attention and dread.
  9.4 A SAMPLE ANT BUILDFILE
      Let’s go over the basics of creating an Ant buildfile. We’ll start with an intro-
      duction to XML, and then move on to the specific tags Ant supports and how
      you might use them to automate a build.
      9.4.1     XML for the Uninitiated
      The buildfiles of ant, usually named build.xml, are written in Extensible
      Markup Language, or XML. Some of the reasons for this are:
         • XML is hierarchical.
         • XML is standardized.
         • XML is widely used and familiar to many programmers.
         • Java has many classes for reading, parsing, and using XML.
         • XML-based representations of hierarchical data structures are easy to read
           and parse for both humans and programs.
           XML is a successor to SGML, Standard Generalized Markup Language,
      which is a language for defining markup languages. A markup document may
      be validated. A validated document is one that conforms to a structural specifi-
      cation of the markup tags in the document. Such a specification may be made
      using a Document Type Definition (DTD), which is a holdover from the way
      SGML markup languages were specified, or using one of the newer specification
      5. There is a horde of optional tasks. As the name suggests, they are optional. Include these if
      you need them. This is the only mention they will receive.
9.4 A Sample Ant Buildfile                                                           221
       standards, such as W3C’s XML Schema. In either case, the DTD or schema
       specify what tags may be used in the markup, where they may exist with respect
       to one another, what attributes tags may have, and how many times a given tag
       may appear in a given place. A document can thus be validated—that is,
       checked against the corresponding DTD or schema. It’s not necessary, however;
       in many situations, documents can also be used without validation so long as
       they are well-formed—that is, conform to the basic syntax of XML.
            HTML, with which even nonprogrammers are familiar, is an instance of
       a markup language defined in terms of SGML (and XHTML is its reformula-
       tion in terms of XML). This book itself was written in Docbook, which is
       another SGML markup language.
            So, if SGML is such a wonder, why is XML all the rage? Well, SGML is
       one of those standards that attempt to “subsume the world.” SGML has very
       complex and flexible syntax, with many different ways to represent a simple
       markup construct. Thus, to completely implement an SGML parser is difficult.
       Recognizing that 90% of the complexity of SGML is needed in only about 1%
       of cases, the designers of XML realized that they could make a markup specifi-
       cation language only 10% as complicated that would cover 99% of cases (of
       course, like 85% of statistics, we’re making these numbers up, but you get
       the point).
            Implementing an XML parser, while not exactly trivial, is much easier
       than implementing an SGML parser.
            SGML/DSSSL and XML/XSLT are efforts to make the transformation
       and presentation of hierarchical data easier and more standardized. If what
       you have read here is all that you know about XML (or SGML), you should
       certainly consider getting yourself a book on these important standards.
            For now, we can say that XML consists of tags which are set off from data
       content by the familiar less-than and greater-than brackets we are used to seeing
       in HTML:
       <samplexmltag>
            Just as in HTML, the tags may have start tag and end tag forms:
       <samplexmltag>Sample XML tagged data</samplexmltag>
            The entire construct, including the pair of matching tags and everything
       inside them, is called an element. The start tags may also, like in HTML, carry
       data inside them in the form of attributes:
222                                                             Chapter 9   Ant: An Introduction
    <samplexmltag color="blue">Sample XML tagged data</samplexmltag>
          If you have an empty element, one that that either does not or cannot have
    data between its start tag and end tag, you may “combine” the start and end
    tag by putting the slash at the end of the tag:
    <samplexmltag color="blue"/>
          Obviously, there is more to it than this, but it is enough to begin with.
          XML’s uses range from publishing to networked interprocess communica-
    tions. Our interest here is in using it to represent a model of a piece of software
    and the various ways that software might be built and deployed. So from here
    on, we will be discussing not XML in general, but the ant document type. Ac-
    tually, ant’s markup language uses unvalidated XML. In other words, there
    isn’t officially a schema for ant. Thus, the only formal definition for an ant
    XML file is what ant accepts and understands. This is more common than it
    should be. Any XML markup vocabulary really should have a schema, but often
    XML use starts with “Oh, this is just a quick thing. No one will ever read or
    write this markup. Just these two programs of mine.” These famous last words
    will one day be right up there with “I only changed one line of code!” As
    strongly as we feel about this, ant really can never have a DTD, at least not a
    complete one. The custom task feature makes this impossible.
    9.4.2      The Buildfile Tags
    The buildfile (usually named build.xml) begins with a header announcing
    that this is an XML document and specifying what version of XML is being
    used in it:
    <?xml version="1.0"?>
          The <? and ?> delimiters mark up an XML statement (as opposed to an
    XML tag).6 In this case, we are declaring that this is an XML document and
    that it is using XML version 1.0.
    6. Note that these are the terms we are using to describe XML to a new user. They are not the
    formal terms for these document elements. For the proper names, consult an XML reference.
9.4 A Sample Ant Buildfile                                                            223
       9.4.2.1     The project Tag
       Every buildfile must begin with a project tag. A buildfile must contain exactly
       one project tag.
             The project tag contains three attributes:
       name
             The name of the project.
       default
             The default target (see next section).
       basedir
             The base directory of the project. Usually this is “.” meaning the directory
             the buildfile is in.
             The project name is just a name. It is not of particular importance to ant,
       although many IDEs that integrate ant will make use of the name attribute of
       the project.
             The default attribute names a target tag that will be built by default
       if a build target is not passed to ant (see Section 9.4.2.2).
       9.4.2.2     The target Tag
       Every time you run ant, you are building a target. If you do not specify a target,
       ant will run the target named in the default attribute of the project tag.
             A project may contain any number of targets. The target tag has five
       attributes:
       depends
             The name or names of other targets that must be built before this target
             may be built.
       description
             A descriptive name for the target. Displayed when ant -projecthelp
             is run.
       if
             Specifies a property name (see Section 4.4). The target is only built if the
             named property is set.
224                                                             Chapter 9  Ant: An Introduction
    name
          The name of the target. This is the name entered as an argument to ant.
          This is also the name that may be used in the default attribute of the
          project tag.
    unless
          This is the reverse of the if attribute. The target is built unless the
          property is set.
    9.4.2.3       Properties
    There is more than one way to set what we might call variables in ant. The
    only one we will concern ourselves with here is properties. Properties are like a
    simple hash, or associative array. They associate value, which is stored as a
    String, with a name, which is also a String. They behave very much like the
    Properties class introduced earlier in this book.7 You can use buildfile prop-
    erties to associate a single name with a single value that you use in multiple
    places throughout the buildfile to make configuration changes easier and less
    error-prone. Some tasks also expect certain properties to be set, as we shall
    soon see.
          You set a property with the property tag (Example 9.2).
    Example 9.2 A useless build.xml example to demonstrate properties
    <?xml version="1.0"?>
    <project name="pointless" default="useless" basedir=".">
       <target name="useless">
          <property name="example.utility" value="nil"/>
             <echo>This example's usefulness:
             ${example.utility}. OK?</echo>
       </target>
    </project>
          Running ant with Example 9.2 gives this output:
    7. In fact, an examination of the ant source code reveals that ant properties are stored in a
    HashTable.
9.4 A Sample Ant Buildfile                                                                        225
       $ ant
       Buildfile: build.xml
       useless:
               [echo] This example's usefulness: nil.                OK?
       BUILD SUCCESSFUL
       Total time: 1 second
       9.4.2.4       Tasks
       A task is something that must be done to build the target. There is no single
       “task” tag; instead, each kind of task has its own tag8 so there are many tags
       referred to collectively as task tags.
              There are dozens of standard task tags, but only a few of them are “every-
       day.” We’ll introduce a few of them here, and then talk about the tags that
       don’t fall into the project/target/task hierarchy.
       Standard task attributes.          All ant task tags have at least the three attributes:
       id
              A unique ID for the task (not required).
       taskname
              A name for the task, used in logging (not required).
       description
              A description of the task, used for comments.
       The javac task. The javac task, not surprisingly, runs the Java compiler.
       Note that since the Java compiler is written in Java and so is ant, there is no
       VM launch overhead to running the compiler. This can make ant many times
       faster than make simply for normal compiles.
              The javac tag is one of the most complex in ant.
              The javac task tag has a very large number of attributes, and may contain
       quite a number of other tags within it. First off, it is sensitive to a property,
       build.compiler, which may be used to specify that a particular Java compiler
       version must be used. The use of this will come up later when we build part of
       8. In fact, task tag names correspond to the names of the Java classes that implement them.
       This will matter to you only if you wish to write your own ant tasks. We will not take you that
       far in this book.
226                                                                 Chapter 9     Ant: An Introduction
    our application using the GNU Compiler for Java, but for now, and in general,
    you will not set this property,9 compiling with the default compiler for the JDK
    version you are using. This is ant’s default behavior.
    srcdir
          Location of the Java source files.
    destdir
          Location to store the class files.
    includes
          Comma- or space-separated list of files (optionally using wildcards) that
          must be included; all .java files are included when this attribute is not
          specified.
    excludes
          Comma- or space-separated list of files (optionally using wildcards) that
          must be excluded; no files (except default excludes) are excluded when
          omitted.
    classpath
          The classpath to use.
    sourcepath
          The sourcepath to use; defaults to the value of the srcdir attribute or to
          nested src elements. To suppress the sourcepath switch, use
          sourcepath="".
    classpathref
          The classpath to use, given as a reference to a path defined elsewhere.
    extdirs
          Location of installed extensions.
    nowarn
          Indicates whether the -nowarn switch should be passed to the compiler;
          defaults to off (i.e., warnings are shown).
    9. The one place you are likely to need to set this is when you are using a recent JDK to compile
    applets that you wish to work in Netscape 4.0 and IE 4.0 and older browsers. But this book
    doesn’t teach you Java applets. We swear.
9.4 A Sample Ant Buildfile                                                           227
       debug
            Indicates whether the source should be compiled with debug information;
            defaults to off. If set to off, -g:none will be passed on the command
            line to compilers that support it (for other compilers, no command-line
            argument will be used). If set to true, the value of the debuglevel
            attribute determines the command-line argument.
       debuglevel
            Keyword list to be appended to the -g command-line switch. This will be
            ignored by all implementations except modern and classic (version 1.2 and
            more recent). Legal values are none or a comma-separated list of the fol-
            lowing keywords: lines, vars, and source. If debuglevel is not
            specified (by default) nothing will be appended to -g. If debug is not
            turned on, this attribute will be ignored.
       optimize
            Indicates whether compilation should include optimization; defaults
            to off.
       deprecation
            Indicates whether source should be compiled with deprecation informa-
            tion; defaults to off.
       verbose
            Asks the compiler for verbose output; defaults to no.
       depend
            Enables dependency tracking for compilers that support this (Jikes and
            classic).
       The jar task.       The jar task makes a JAR file.
       The javadoc task.        One of the greatest benefits of developing in Java is the
       nearly automatic generation of thorough and correct documentation. Javadoc
       is the tool that does the job, and the javadoc task is the way to automate
       document production in ant. This tag has a number of attributes that specify
       where the source to be documented is located, how the documentation is to be
       produced, and where the documentation is to be placed.
       The copy and mkdir tasks.           These tasks are used to copy files and make
       directories.
228                                                       Chapter 9 Ant: An Introduction
    The rmic task.          Remote Method Invocation is a distributed computing
    technology (Section 5.8). RMI requires the generation of server and stub classes
    that provide the networking support for an RMI-enabled class. This is normally
    done by the rmic compiler, and this is one of the common reasons the Java
    programmers turn to build automation tools. The rmic tag allows ant to build
    RMI classes.
    9.4.2.5     Other Tags
    So far we have ignored a major component of ant. In order to introduce it, we
    need to give you a (painfully) high-level view of how ant works “under
    the hood.”
         Task tags actually map directly to Java classes that implement the tasks.
    Each task class is an instance of the Task class (in other words, it is a Java class
    that either directly or indirectly extends the Task class). This is how you can
    write your own tasks—download the ant source code and write your classes
    that extend the Task class.
         Tasks are not, however, the only tags that map to Java classes. There is
    another category of tags that do so. They are called datatypes. These are classes
    that directly or indirectly extend the ant DataType class.
         Generally speaking, a task may require zero to many datatypes to specify
    the data with which the task works. Some such tags include the manifest tag
    used in our sample build.xml file discussed later in this chapter.
         We’ll mention a couple of the most frequently used datatype tags here and
    leave looking up the details as an exercise for you.
    The PatternSet, Include, and Exclude datatypes.                 As you may have
    noticed, the most common tags we have covered allow you to specify the files
    to be processed using the tag’s attributes. Usually, you nominate a base directo-
    ry and let the task tag process everything in that directory.
         There are times, however, when you need finer grained control than that.
    For example, you might wish to exclude all Java classes whose names end in
    “Test” (Example 9.3).
    Other datatypes. There are many other datatypes used for various purposes.
    One of them, FilterSet, is able to modify files before they are copied or
    moved. This can be useful, for example, to put build information into a source
    file for an About dialog.
9.4 A Sample Ant Buildfile                                                              229
       Example 9.3 Using the PatternSet datatype
       <patternset id="nontest.source">
          <include name="**/*.java">
          <exclude name="**/*Test.java">
       <patternset>
       <target name="build">
          <javac destdir="build">
            <src path="src"/>
            <patternset refid="nontest.source"/>
          </javac>
       </target>
            In general, datatypes give you more sophisticated control than do the at-
       tributes of a task. Take a look at the Ant User’s Manual 10 for full details on ant.
       9.4.3     A Real, Live Buildfile
       Let’s take it to the next level and examine a real working buildfile.
       9.4.3.1     Project Organization
       All but the simplest of projects will require multiple classes. Some will require
       libraries, multiple programs, binary deployment, Web deployment, enterprise
       deployment, and so on. A project will be most successful if you plan out what
       goes where in advance. We’re going to present a series of suggestions for how
       to organize the files involved in developing, building, and deploying a Java
       project with ant. By no means is this the only way it might be done, but it has
       worked well for us.
       9.4.3.2     The build.xml File for Payback
       Example 9.4 is the actual Ant buildfile for the Payback program in our source
       code examples. These examples are available on the book’s Web site.11
       10. http://ant.apache.org/manual/
       11. http://www.javalinuxbook.com/
230                                                       Chapter 9 Ant: An Introduction
    Example 9.4 The build.xml file for the Payback application
    <?xml version="1.0"?>
    <!--
      $Id: 070_antIntro.sgml,v 1.51 2004/04/13 05:10:45 mschwarz Exp $
      Buildfile for the Payback program. Payback will calculate
      the length of time and real amount of money it takes to make a
      purchase using various savings or credit accounts. -->
    <project name="Payback" default="all" basedir=".">
    <!-- The "init" target sets up properties used throughout
      the buildfile. -->
    <target name="init" description="Sets build properties">
      <echo>Running INIT</echo>
      <property name="src" value="${basedir}/src"/>
      <property name="build" value="${basedir}/build"/>
      <property name="doc" value="${basedir}/doc"/>
    </target>
    <!-- The "all" target does nothing but tie together the "jar" and
      "doc" targets. -->
    <target name="all" depends="jar,doc"
             description="Pseudo-target that builds JAR and Javadoc">
      <echo>Building ALL</echo>
    </target>
    <!-- The "build" target compiles the code in the project. -->
    <target name="build" depends="init"
             description="Compiles the classes">
      <echo>Running BUILD</echo>
      <mkdir dir="${build}"/>
      <javac destdir="${build}" srcdir="${src}" debug="true"
              deprecation="true"/>
    </target>
    <!-- The "doc" target generates Javadoc documentation of the
      project. The "author", "version", and "use" attributes set to
      true cause those Javadoc tags to be used in the final document.
      The "private" attribute set to true causes private methods and
      attributes to be included in the documentation. We tend to use
      this for projects to provide complete reference documentation.
      You would probably not want to do this for an app or lib
      distributed as a JAR file only. -->
9.4 A Sample Ant Buildfile                                              231
       <target name="doc" depends="init"
                 description="Generates Javadoc documentation">
         <echo>Running DOC</echo>
         <mkdir dir="${doc}/api"/>
         <javadoc packagenames="net.multitool.Payback.*"
                     sourcepath="${src}" destdir="${doc}/api"
                     author="true"       version="true"
                     use="true"          private="true"/>
       </target>
       <!-- The "jar" target depends on the "build" target. It places
         all of the class files in the project into a JAR file, and
         builds a manifest using the "manifest" tag. -->
       <target name="jar" depends="build"
                 description="Builds an application JAR file">
         <echo>Running JAR</echo>
         <jar basedir="${build}" jarfile="${basedir}/Payback.jar">
           <manifest>
              <attribute name="Version" value="1.0"/>
              <attribute name="Main-Class"
                           value="net.multitool.Payback.Payback"/>
           </manifest>
         </jar>
       </target>
       <!-- The "run" target depends on the "jar" target. It executes
         the class named as the "Main-Class" in the JAR's manifest. -->
       <target name="run" depends="jar" description="Runs the program">
         <echo>Running RUN</echo>
         <java jar="${basedir}/Payback.jar" fork="true">
           <arg value="${basedir}/accounts.properties"/>
         </java>
       </target>
       <!-- The "clean" target erases all files and directories that other
         Ant targets might have generated. It returns a copy of the
         project tree to a "pristine" (some might say "clean") state. -->
       <target name="clean" depends="init"
                 description="Erase all generated files and dirs">
         <echo>Running CLEAN</echo>
         <delete dir="${build}" verbose="true"/>
         <delete dir="${doc}/api" verbose="true"/>
         <delete file="Payback.jar" verbose="true"/>
       </target>
       </project>
232                                                         Chapter 9  Ant: An Introduction
  9.5 REVIEW
      We’ve taken a very quick tour through the most popular tool for building and
      deploying Java applications. We’ve shown you how to install and set up ant.
      We’ve given you enough description of XML so that you can read an ant
      buildfile. We’ve touched briefly on the basic tags used in most buildfiles.
  9.6 WHAT YOU STILL DON’T KNOW
      What we’ve covered here will probably explain most of the buildfiles you en-
      counter in the wild. It will probably also give you what you need to know to
      build most of the buildfiles you will have to build. But we have left out a
      fair amount.
            You can write your own tasks. That’s a biggie right there. There are many
      built-in tasks that we didn’t cover. Look those up. They might be just what
      you need if you find yourself saying, “Boy, ant is nice, but I wish it could
      do X.” X might already be a built-in task. And if not, you can write it.
            Ant has datatypes that can often be used in place of the simple strings al-
      lowed in task attributes. Tasks and datatypes are instances of Java base classes
      defined in the source code for ant. If you download the source, you can write
      your own classes that extend these base classes and you can thus add your own
      tags to ant.
  9.7 RESOURCES
         • The Ant User’s Manual 12 at the Ant project homepage13 (which itself is
            part of the Apache Project14 ) is the definitive resource for ant.
      12. http://ant.apache.org/manual/
      13. http://ant.apache.org/
      14. http://apache.org/
9.7 Resources                                                                    233
         • O’Reilly has also published Ant: The Definitive Guide by Jesse Tilly and
            Eric M. Burke (ISBN 0596001843), which was the first book on ant that
            we read.
         • If you are into Extreme Programming you’ll want to check out Extreme
            Programming with Ant: Building and Deploying Java Applications with JSP,
            EJB, XSLT, XDoclet, and JUnit by Glenn Niemeyer and Jeremy Poteet,
            published by SAMS (ISBN 0672325624).
Chapter 10
Integrated Development
Environments
Some people prefer glitz. The shiny sparkle has always attracted the human eye.
Sometimes that sparkle is a real gem, a treasure; sometimes it’s only a gum
wrapper on the sidewalk. Integrated Development Environments (IDEs) add
glitz to Java development. At their most basic, they combine (integrate) an
editing environment with a compiler. This gives you
   • Language-specific formatting of your Java text (different colors, comments
      in italics, and so on)
   • Quick feedback on errors (the ability to click on a compile error message
      to begin editing at the offending Java statement)
   • Automatic word completion, to help you finish typing the names of
      methods in your Java code
   • A point-and-click GUI for that all important “modern” look-and-feel
      If those were all they gave you, IDEs would be, in our opinion, leaning
toward “gum wrapper.” But a good IDE can be more than that. It can be
extended to integrate many different tools, including:
                                                                            235
236                                       Chapter 10  Integrated Development Environments
         •  Version control (e.g., CVS, see also Chapter 8)
         •  One or more Web servers (e.g., Tomcat)
         •  A build control mechanism (e.g., ant, see also Chapter 9)
         •  Other editors besides the built-in editor
         •  A specialized editor for building GUIs
         •  Other languages besides Java
 10.1 WHAT YOU WILL LEARN
      In this chapter we will examine two major Open Source IDEs, NetBeans and
      Eclipse. We will show a straightforward installation of each. We will describe
      the “operating paradigm” of each and show a few major features. It should be
      enough to get you started using them.
            There are several major commercial IDEs, including Idea by IntelliJ,
      JBuilder from Borland, WebSphere Studio from IBM, SunONE Studio (Enter-
      prise Edition) from Sun, and others. Because they are commercial, and not
      Open Source, we will not be covering them; their vendors and other experts
      can provide the documentation and training you need. Be advised, however,
      that the licenses for such commercial products typically cost anywhere from
      several hundred to a few thousand dollars per seat. That can make Open Source
      IDEs look very attractive.
 10.2 NETBEANS: THE OPEN SOURCE IDE
      NetBeans is an Open Source IDE, freely available, with full source code. It is
      also the basis for the SunONE Studio (more on that product later).
      10.2.1 A Brief History of NetBeans1
      NetBeans (originally called Xelfi) began in 1996 as a student project in the
      Czech Republic, with the goal being to write a Delphi-like Java IDE in Java.
      A company called NetBeans was formed around this project. By May of 1999,
      after two commercial releases of Developer, the company released a beta of what
      1. From the netbeans.org Web site.
10.2 NetBeans: The Open Source IDE                                                        237
       was to be Developer 3.0. In October 1999 NetBeans was acquired by Sun Mi-
       crosystems. After some additional development, Sun released the Forte for Java
       Community Edition IDE—the same IDE that had been in beta as NetBeans
       Developer 3.0. There had always been interest in going Open Source at Net-
       Beans. In June 2000, Sun open-sourced the NetBeans IDE; now it can be
       found at the netbeans.org Web site.
       10.2.2 Installing NetBeans
       NetBeans can be downloaded from the netbeans.org Web site. You will want
       the NetBeans “IDE” and not the NetBeans “platform.” The IDE is the fully
       featured Java development environment. The platform is the underlying core
       of NetBeans on top of which one can develop other tools—for example, IDEs
       for other languages. Installation of the IDE consists of only three steps:
         1. Download.
         2. Install.
         3. Execute.
       10.2.2.1 Downloading
       The first step is to get the software downloaded onto your system. From the
       netbeans.org Web site, navigate your way to a download of the latest IDE.
       The prepackaged “installers” might work—but if they fail, you have no infor-
       mation as to why, and still less as to what you can do about it. We’ll act like
       “real programmers” and download an archive file. (Here “archive” means a
       collection of software compressed for easier transmission, not “archive” in the
       sense of “old documents.”) Click on a link to begin the download
       (you’ll need to read, review, and accept the license agreement to proceed).
       The result should be a file on your system named something like
       NetBeansIDE-release35.tar.bz2.
       10.2.2.2 Installing
       The installation consists of three steps: untarring the file, adjusting a parameter
       in a configuration file, then creating a symbolic link for easy startup.2
       2. Thanks to John Zoetebier from New Zealand for his contribution on the NetBeans users
       mailing list, on which this manual installation procedure is based.
238                                     Chapter 10  Integrated Development Environments
           Uncompress the archive:
    bunzip2 NetBeansIDE-release35.tar.bz2
           This will leave the file NetBeansIDE-release35.tar in place of the
    .bz2 file.
           You can examine the contents of the TAR file with:
    tar -tvf NetBeansIDE-release35.tar | more
           Here the options (-tvf) specify to show a table of contents (-t) in ver-
    bose, that is, long, form (-v) from the specified file (-f) followed by the TAR
    filename. The output from tar here is piped into more so that you can page
    through it. Type q when you’ve seen enough, or leave off the | more to let it
    run through without pausing.
           Notice that the names of all the files in the TAR archive begin with
    netbeans/ which tells us that if we untar the file, it will put all the files into a
    directory called netbeans. Therefore, we don’t need to make such a folder
    beforehand.
           Change directory to the directory where you would like to install
    NetBeans. If you are on a system that may be used by different users, you’ll
    probably want to put it in a more public location like /usr/local or /opt. If
    it is for your personal use, you can put it anywhere—just be sure that you have
    write permissions on the directory where you want to install NetBeans.
    (Reminder: use ls -ld . to see the permissions of the current directory.)
           The tar command to untar everything in place is simple:
    tar -xf NetBeansIDE-release35.tar
           This will extract (-x) all the files that are in the TAR file (-f) named
    NetBeansIDE-release35.tar. If you’d like to see each file get named as it
    is extracted, then change the -xf to -xvf (v for verbose) and you will see a
    whole long list of filenames displayed on your screen as the file is unpacked.
           Next, we need to adjust the startup parameter in the configuration file.
    The file is in the netbeans directory that you just untarred. In there is a direc-
    tory named bin, and in there is a file called ide.cfg. Open this file with an
    editor and change the line that begins -jdkhome so that the pathname refers
    to the location of your Java Development Kit (JDK, see Chapter 5).
           Here’s an example of the contents of ide.cfg:
10.2 NetBeans: The Open Source IDE                                                239
       -J-Xms24m -J-Xmx96m
       -J-Xverify:none
       -jdkhome /usr/local/java/j2sdk1.4.1_01
            This specifies that the Java SDK is located in /usr/local/java/
       j2sdk1.4.1_01, and in that directory there is a bin directory which contains
       java, javac, javadoc, and so on.
            Finally, to make the executable easy to run, we will construct a symbolic
       link for easy access:
       $ ln -s /usr/local/netbeans/bin/runide.sh /usr/local/bin/nb
            This creates a symbolic link from the runide.sh file in the current
       directory to the /usr/local/bin directory, as a file named nb.
       10.2.2.3 Running
       Now that you have the symbolic link to the script which runs NetBeans, simply
       invoke it with nb at a shell prompt. NetBeans will start loading (Figure 10.1).
            If you get a message like “Command not found,” check to see if the shell
       knows where to look. If you used the same name and location as in the previous
       example, then make sure that /usr/local/bin is part of the search path for
       the shell. (Reminder: echo $PATH will tell you what directories are searched.
       If you need to, add /usr/local/bin to PATH, as in:
       Figure 10.1 NetBeans begins
240                                    Chapter 10  Integrated Development Environments
    Figure 10.2 NetBeans’ main window
    export PATH="${PATH}:/usr/local/bin"
    which you can type from the command line for immediate use and then put
    in the .bashrc file in your home directory to set things this way next time you
    invoke a shell.)
         Also be sure that the script runide.sh has execute permissions on it.
    (Reminder: check this with ls -l runide.sh and change with chmod a+x
    runide.sh.)
         If all goes well then after the splash screen, you should see the window
    shown in Figure 10.2.
         For more information on installing NetBeans, check out
    http://www.netbeans.org/kb/articles/install.html#unix.
         Now let’s take a look at how you might use NetBeans.
10.2 NetBeans: The Open Source IDE                                                    241
       10.2.3 Getting Around in NetBeans
       Let’s take a look, from top down, at NetBeans’ main window. First, of course,
       is the menu bar. There are lots of choices to explore there. Much of what you’ll
       do with NetBeans won’t require much use of the menus—there are so many
       shortcuts elsewhere.
             Next comes a row of icons, which are just shortcuts for menu times.
       This row of icons can be customized, and you can even add your own (see
       Section 10.2.5).
             The three tabs below the icons, labeled Editing, GUI Editing, and
       Debugging, modify the window to provide three distinct workspaces. Each
       one customizes the window environment for a specific task, but it is still
       working on the same files.
             Next, on the left, comes the Explorer, which is in many ways similar to
       the tools that you may use for traversing filesystems on a Windows or Linux
       system.
             One oddity of NetBeans is that it doesn’t just use the files as it finds them
       in the directories on your hard drive(s). Rather, is requires you to designate a
       piece of the filesystem as the part that you want to use. You can designate sev-
       eral such pieces. Each piece is “mounted” as if it were a mountable filesystem.
       (This is an operating system concept. If you’re not familiar with it, don’t worry.
       For the purposes of NetBeans, just think of the IDE as too dumb to know
       about any files until you tell it about them.)
             There are three different types of files that you can mount—local, CVS,
       or JAR. By specifying the type, NetBeans can treat each one in its special way.
           • Local files need no special treatment; they are just the local files on your
             hard drive.
           • If a filesystem is mounted under a version control system (CVS or generic
             VCS), then its files can have version control operations performed on them
             (checkin, checkout, and so on), via commands in the IDE. (More on that
             below.) Also, special directories used by the version control system (e.g.,
             CVS) are hidden from the display, as you almost never want to manipulate
             these files directly.
           • When you mount a JAR file or ZIP archive as a filesystem, NetBeans
             displays the contents of the archive as if they were just files in a
             directory—which can make them easier to manipulate. More importantly,
             the JAR is automatically added to the classpath for Java compiling.
242                                         Chapter 10  Integrated Development Environments
         Therefore, any third-party JARs that you may need for your project should
         be mounted.
         To mount a local directory as a filesystem, right-click on the little icon la-
    beled Filesystems in the Explorer [Filesystems] window. Choose Mount, then
    Local Directory, and you’ll get a filechooser to let you navigate your file
    structure and choose a directory to mount.
         IMPORTANT
         To ensure that NetBeans knows how to compile your source, you need to mount
         the directory that contains the base level of your source as a mountpoint, not
         just have that directory somewhere in a tree of directories.
               For example, let’s say that your source is kept in two packages,
         com.coolco.projecta and com.coolco.util which implies that you
         have a directory structure with those names. Let’s further assume that you keep
         them in a directory called src which is itself contained in a directory called
         brolly, as shown in Figure 10.3.
               The likely thing to do is to mount the brolly directory, since it will contain
         the source and all sorts of other project-related directories. That’s fine, as far
         as it goes. But since the mountpoints in NetBeans are also the CLASSPATH
         directories, you need to also mount brolly/src, so that directories like
         com/coolco/util are found when your Java sources have statements such
         as import com.coolco.util.*;.
               It’s OK to have the same directory show up in different mountpoints. Net-
         Beans won’t get confused, although you may. You’ll probably want to edit and
         compile from the mountpoint of, in this example, brolly/src. The src folder
         inside the brolly mountpoint would refer to the same files. Just keep the one
         always open and the other closed, and you should be able to keep them straight.
    10.2.3.1 Filesystem versus Project
    The Explorer window has tabs at the bottom which let you look at different
    aspects of your work. In some instances you’ll want the Project view. For this,
    you have to mount file’s from the already mounted filesystems in the Filesys-
    tem view. Seems redundant, no? The Project view lets you set properties for
    the project as a whole or for individual files in the project. These settings apply
    to that file only for the project. Another project, looking at the same files, might
    have different settings.
         For now, don’t worry about the difference. Many people like to work in
    the Filesystem view and never bother with projects. Others, especially those
    working on multiple products or projects, like Projects as a way to switch
10.2 NetBeans: The Open Source IDE                                                    243
                          brolly
          other             scr           build.xml
                           com
                          coolco
                   util           projecta
                  other          ProjA.java
       Figure 10.3 A simple source structure
       between tasks—you can only have one project active at a time, but when you
       switch projects, it switches all the mounted filesystems and other settings that
       you have configured.
       10.2.3.2 Editing
       Like other IDEs, NetBeans provides its own editing window. It’s a GUI point-
       and-click environment, with syntax highlighting and other helpful features for
       a programmer.
            At the top of the editing window is a toolbar (Figure 10.4). Each icon on
       the toolbar has a tooltip, a help text that pops up when you rest your mouse
       pointer over the icon, to explain the somewhat cryptic little icons. Most of the
       tools are quite handy. With the pulldown menu, you can navigate to any
       method or class variable within the class. The next four buttons deal with
       searching: Select any text in your source file, click on the magnifying glass icon,
       and the search will be performed for the next occurrence of that text. In addi-
       tion, all occurrences are highlighted. This highlighting can be toggled on or off.
244                                     Chapter 10 Integrated Development Environments
    Figure 10.4 NetBeans’ Edit screen toolbar
    Figure 10.5 NetBeans’ Find dialog
         The toolbar search only works within a single source file. If you want to
    search across multiple files, go back to the Explorer window and right-click on
    the folder containing the files you wish to search. There is a Find . . . com-
    mand in the pop-up menu. That brings up a dialog box (Figure 10.5) that has
    multiple tabs for quite extensive filtering of your search. In its simplest use, just
    type in the text you want to find, and press Enter.
         A list of the files which contain the text will appear in a different window,
    citing filename and linenumber for each file. There you can double-click on
    any citation to bring up that file in the edit window, at that location.
         If you heeded our admonition to learn vi, you’ll be glad to know that
    NetBeans can handle the fact that the source files can be modified externally
    from the IDE. Go ahead and edit any of your source files, even while the IDE
10.2 NetBeans: The Open Source IDE                                                    245
       is running. When you next touch the file from within the IDE, NetBeans will
       recognize the fact that the file has been modified and load the new version.
             If you haven’t yet learned vi, you may find yourself quite comfortable us-
       ing the NetBeans editor. If you dig deeper into NetBeans you can find how to
       map certain keystrokes to make it even more editor-like. However, mousing
       and cut-and-paste may suffice for beginners for quite some time.
       10.2.4 Integration with CVS
       NetBeans comes with a built-in CVS client, which means that you don’t need
       to install any additional features in NetBeans to get it to talk with a CVS server.
       It has all it needs to check out and commit files from and to a CVS repository.
       NetBeans can be configured to use external (i.e., outside of NetBeans) CVS
       commands, but you likely won’t need to do that.
             What you will need to do, however, is tell NetBeans that the files you are
       using are under CVS control. You do this by mounting the filesystem not as
       just a regular filesystem, but as a CVS filesystem. In the Explorer window, go
       to the Filesystem tab if you are not already there. On the Filesystem icon,
       right-click your mouse, and from the pulldown menu choose Mount, then
       Version Control, then CVS (Figure 10.6). What follows will be a wizard-like
       series of dialogs which you will fill in to describe the type and location of the
       CVS repository with which you want to work. Those choices and values are
       specific to your installation, so we’ll leave that for you to figure out with your
       network administrator or whoever has set up your repository.
             Once mounted, the CVS filesystem’s files will look much like any other
       filesystem you have mounted—except that the files will show, via their icon,
       when they have been modified and need to be committed, and will show the
       version number in parentheses after the filename. The other difference is that
       there is now a CVS command on the pulldown menu (Figure 10.7) that
       appears when you right-click on one of the filenames (or on its tab in the
       Edit view).
             Move your mouse over the CVS command; an additional pulldown menu
       appears (Figure 10.8). If you’ve used CVS at all, then you’ll recognize the list
       of commands in the cascaded menu. There are the Commit, Update, Diff,
       Log, Status, and Checkout commands that you are familiar with. The first
       item, Refresh, is likely unfamiliar, though. Not being a CVS command (it’s
       not part of the command-line syntax), it is a way for you to tell the IDE to
246                                       Chapter 10 Integrated Development Environments
    Figure 10.6 Mounting a CVS filesystem
    Figure 10.7 Right click on a CVS file
    reconsider what it thinks about the CVS-related information displayed in its
    icons and the parenthetical text.
         If you click on a folder instead of a single file, then the Refresh command
    will be followed by Refresh Recursively which will do a refresh on each file
    from there on down the tree.
10.2 NetBeans: The Open Source IDE                                                 247
       Figure 10.8 Cascaded menu with CVS commands
             Using the integrated CVS is much like using the command line. If you
       want to see the changes that you’ve made (before committing), use the Diff
       command. A window will appear showing the two different versions and
       coloring the lines that have been added, deleted, or changed.
             When you need to commit your changes, click the filename, then right-
       mouse your way to Commit. A dialog window will appear for you to type in
       the comment that you want to be associated with this change. (This comment
       will appear in the Log command display).
             To incorporate the changes others on your project may have made on the
       file, use the Update command. A dialog box will display the CVS output
       showing what was updated and if any merge conflicts occurred. (See Chapter 8
       for more on this.)
             The CVS commands in the menu, as we’ve described them so far, don’t
       allow you to add any options to the commands. They just run with the defaults.
       What if you want to use some of the options available on the CVS command
       line? Then hold down the Ctrl key just before your make your CVS choices.
       You should see an ellipsis (“...”) appear after each CVS command for which
       you can now select options (Figure 10.9).
             Of course one of the great things about knowing the command-line ver-
       sion (see Chapter 8) is that you’re not limited to what the GUI tools will do
       for you. If you can’t find the option you want, just go back to a window with
       a shell prompt, cd into the appropriate directory in your source tree, and type
       the CVS command by hand. As noted earlier, NetBeans is smart enough to
248                                     Chapter 10 Integrated Development Environments
    Figure 10.9 Cascaded menu after choosing CVS with Ctrl pressed
    catch on to the changes made outside of NetBeans to its files, though you may
    need to do a Refresh, as described above.
    10.2.5 Integration with Ant
    If you’ve already discovered ant, either by using it on a Java project or by
    reading this book in chapter order, then you’ll know that it’s a plus to have ant
    integrated into NetBeans. As of NetBeans version 3.5, ant comes bundled with
    NetBeans and you don’t need to install it separately.
         NetBeans recognizes a build.xml buildfile and gives it a special icon. If
    you click on the icon for the build.xml file in the Explorer, it will show each
    of the properties and then each of the targets (Figure 10.10). Right-click on a
    target to choose Execute to run ant with that target. As a shortcut you can ei-
    ther select that target and press the F6 key, or you can just double-click on the
    target name.
         If you are making frequent use of an ant build script in your project, you
    may want to add a shortcut—an icon that you can put on the icon panel—that
10.2 NetBeans: The Open Source IDE                                                   249
       Figure 10.10 Cascaded menu after choosing CVS
       will run a specified ant target. You can also add a keyboard shortcut, to invoke
       the target with a keystroke or two. The specific steps for doing that are found
       in the NetBeans online help. Just look for the section titled Creating a Shortcut
       to a Target.
             There is one other topic worth mentioning about integration with ant.
       Normally in NetBeans, when you compile a Java class, the IDE does the com-
       pilation. You can configure the IDE to use different types and versions of Java
       compiler, but it is the IDE which controls the compile. You can invoke a
       compile with the F9 key as a shortcut. But if you are building with ant, you
       may want ant to do the compiles for you. Fortunately, you can configure
       NetBeans to do this. Again, we’ll refer you to the NetBeans online help, to a
       section called Indirect Ant Compilation.
250                                       Chapter 10  Integrated Development Environments
    10.2.6 Other Add-on Tools
    NetBeans is built to allow other tools to be plugged into it. There is a module
    that you can add to NetBeans to support C/C++ development. But there are
    various other plug-ins available. The best reference for all of those is the
    NetBeans Web site.3 Many of the add-ons are commercial, but one notable
    tool is available, at least in its simple form, as a free download.
          Poseidon for UML Community Edition is a UML modeling tool that in-
    tegrates with NetBeans. A product of Gentleware AG, it is distributed at their
    Web site.4 The Community Edition is offered free of charge, but they have
    more advanced (professional, enterprise) versions for sale. Their Web site says
    that Poseidon for UML Community Edition has the following features:
       •  Fully implemented in Java, platform-independent
       •  All 9 diagrams of the UML supported
       •  Compliant to the UML 1.4 standard
       •  XMI supported as standard saving format
       •  Runs under Java 1.4
       •  Diagram export into GIF, PS, EPS, SVG, JPEG, and PNG
       •  Undo/redo (can be turned on in options)
       •  Copy/cut/paste within the tool
       •  Drag and drop within the tool
       •  Zooming and bird’s eye view of the diagrams
       •  Internationalization and localization for English, German, French, and
          Spanish
       •  Code generation for Java
       •  Sophisticated support of OCL
       •  Reverse engineering from Java sources
       •  Auto-layout of reverse engineered diagrams
       •  Cognitive support, critique mechanism (by default turned off)
       •  Simple install and update with JavaWebStart
    3. http://www.netbeans.org/about/third-party.html
    4. http://www.gentleware.com/
10.4 Eclipse: The Source of SWT                                                                     251
              We won’t be discussing its installation or use, but we encourage you to
       explore this option if you need a UML tool.
 10.3 SUNONE STUDIO COMMUNITY EDITION
       SunONE Studio (SOS) Community Edition was built on NetBeans and was
       distributed for free. You would even see the NetBeans logo on startup. As of
       SOS 5.0 (summer 2003), the Community Edition is no longer available—
       NetBeans is what Sun recommends for the no-cost download. (The SOS Enter-
       prise Edition is still actively developed and sold by Sun; it is licensed at a cost
       similar to other commercial packages.)
 10.4 ECLIPSE: THE SOURCE OF SWT
       Eclipse is yet another GUI IDE. The Standard Widget Toolkit (SWT) was in-
       vented as part of this project. Since Eclipse uses SWT for its graphics, it has the
       most familiar GUI look and feel, and it is the fastest performer on lower end
       hardware.5 Eclipse is built as an IDE toolkit. Although it was developed in
       Java/SWT, you can use it to develop AWT/Swing applications. It is build
       around a plug-in architecture, so it can be an IDE for virtually any language.
       To use it for Java, you must actually install the Java plug-ins.
       10.4.1 Selecting and Installing Eclipse
       The main site for obtaining Eclipse is www.eclipse.org. Installing Eclipse,
       particularly for a single user, is incredibly easy. But first, you have a few choices
       to make as to what to download. As of this writing, the current production re-
       lease of Eclipse is 2.1.2. If you follow the Downloads link from the main page
       to the 2.1.2 build, you will see a fairly lengthy list of download choices.
              The first major choice you must make is whether or not you plan to write
       your own plug-ins and extensions to Eclipse. If you do, you will probably wish
       to download the Eclipse Software Development Kit or the source code and
       build Eclipse for yourself. We strongly recommend that you choose the Eclipse
       SDK binary for GTK. The Motif UI is quite dated in comparison. The Eclipse
       5. It’s the fastest performer on high-end hardware too, but the difference is much less percepti-
       ble. Really fast and incredibly fast are hard for humans to discern.
252                                        Chapter 10  Integrated Development Environments
    SDK contains the Eclipse Platform (which you need), the Java Development
    Toolkit (which you need), and the Eclipse Platform Development Kit (which
    you need only if you plan to develop plug-ins for Eclipse). But by downloading
    the Eclipse SDK package, you get everything you need in one go. You could
    also download the Eclipse source package and build the whole thing yourself;
    save that for a spare week. For now, start with a prebuilt binary.
          If you scroll down, you will see a collection of files that have “platform”
    in their names. You will note that there are two choices of Linux binary: one
    is Motif, the other GTK. If you are not familiar with these, Motif and GTK
    are two common extensions to the X Window API that provide widgets and
    other common functions and UI features. One of these, Motif, is rather old
    and (to brashly add opinion) dated in appearance, but it is very stable and ma-
    ture. The other, GTK, stands for GIMP Toolkit and was developed to support
    the remarkable GNU Image Manipulation Program (GIMP). There are other
    widget/UI libraries that run on top of X Window, notably the Qt library used
    by KDE.
          So, which to use? If you read the documentation on the Eclipse Web site,
    you will see that the Motif version has been more heavily tested and is available
    for other platforms than Linux. This is probably because Motif is standard on
    most commercial UNIX versions, and thus is where emphasis was placed to get
    the “most bang for the buck” in development and testing.
          However, we much prefer the look of the GTK version and, to date, have
    found no major problems with it, so that is what we use for our examples.
    There should be no functional difference between the two—merely differences
    in the look and feel of menus, toolbars, and dialogs. One reason to select Motif
    might be if you are working in a mixed environment of Linux and other UNIX
    platforms, where you may be forced to use the Motif version on some plat-
    forms, and do not want the “cognitive dissonance” of switching between
    the two.6
          So, step one: Download eclipse-SDK-2.1.2-linux-gtk.zip.
          The Eclipse platform is a “generic IDE.” You will see the term perspective
    all over Eclipse. A perspective is kind of a collection of tools in the IDE. The
    package you just downloaded contains a generic perspective called Resource. A
    6. Please note that the differences are fewer and smaller than the differences involved in
    switching between any common X Window desktop and Microsoft Windows. If you can
    handle that (and many of us do every day), switching between Motif and GTK versions of
    Eclipse will be no problem for you.
10.4 Eclipse: The Source of SWT                                                        253
       perspective is a set of views, which are panes within the IDE, each having a
       specific purpose, such as editing the project contents, editing files, keeping a
       task list, and so on, as well as menus and toolbars relevant to those views. The
       Resource perspective has its uses, but it is not the main one you will be using
       as a Java programmer. As a Java programmer, you will most likely want the Java
       perspective.7
             First, you must decide if you are going to install Eclipse in a common lo-
       cation (such as /usr/local or /opt), or if you are just going to install it in
       your home directory for your own use. The answer to this question, naturally,
       depends on whether or not you have root access on the machine and whether
       or not multiple people actually use the machine.
             CAUTION
             We are assuming you already have at least one Java SDK installed. If you do
             not, refer to Chapter 6 for some tips on installing Java SDKs.
             We’re going to install in the user’s home directory. Doing this could
       hardly be simpler. So, step two: From your home directory, type:
       $ unzip eclipse-SDK-2.1.2-linux-gtk.zip
             That’s it. You’re done. Now just cd to the newly created eclipse directo-
       ry and type ./eclipse. The first time you do this, you will see a “Completing
       the install” banner (Figure 10.11).
       Figure 10.11 Running Eclipse for the first time
       7. Although you will also often be using the Debug perspective.
254                                     Chapter 10   Integrated Development Environments
    Figure 10.12 Eclipse splash screen
          During this initial run some workspace directories and data files are set
    up. These store meta-information about projects and perspectives. After a
    moment, you will get the standard splash screen (Figure 10.12).
          Following this, you will see the initial Eclipse IDE, with a welcome screen
    in the default Resource perspective (Figure 10.13).
          Eclipse works with projects. A project is a collection of files that you man-
    age as a group. Usually a project is a single program, although it need not be.
    Eclipse remembers the state of all projects. If you close Eclipse in the middle
    of a debug session on a project, the next time you open Eclipse, it will have that
    same project open in the Debug perspective. If you then switch to another
    project and switch back, you will come back to the Debug perspective. Eclipse
    remembers. But we get ahead of ourselves here. You need to create a project.
    10.4.2 Using Eclipse for a New Project
    Now that you have Eclipse up and running (Figure 10.13), you will
    want to create a Java project. Eclipse has “wizards” (to use the Microsoft
    Windows terminology) for creating projects. From the main menu, select
    File > New> Project. You will get the screen shown in Figure 10.14.
          Now, you are not an idiot. This is not “Java Applications Programming
    on Linux for People with Well Below Average Intelligence.” We’re not going
    to walk you slowly and painfully through a screenshot of every window Eclipse
10.4 Eclipse: The Source of SWT                                                        255
       Figure 10.13 The Eclipse Resource perspective
       can display and pretend that this is “educational.” We like trees too much to
       do that. So let’s pick up the pace a bit. The first screen in Figure 10.14 asks
       you to select the type of project. The next screen asks for a project name and
       it automatically chooses a directory to house the project. In Section 10.4.3 we
       will talk about changing away from this default. For now, trust Eclipse to do
       it right. Enter a project name and hit the Next button.
             The next screen shows a tabbed display. The first tab allows you to add
       folders for source code. If you have already worked out a directory structure for
       your project, you may build it here. The next tab is the Projects tab. Here you
       specify other projects on which this project depends. The next tab is the
       Libraries tab. Basically, it lets you specify the project’s classpath. Eclipse puts
       its preferred set of JARs on the classpath by default, including those that are
       standard with whichever Java runtime Eclipse found on startup. The last tab is
       called Order and Export; it allows you to specify the order in which source
256                                      Chapter 10 Integrated Development Environments
    Figure 10.14 Step one: New project
    folders should be built, as well as to specify which folders are accessible to other
    projects that name this project on their Projects tabs (in other words, this is
    the “other side” of the Projects tab).
          That’s the final wizard box. Hit the Finish button. A dialog box pops up
    to tell you that the project you just created is associated with the Java perspec-
    tive. Since you are currently in the Resource perspective, it asks you if it
    may switch you to the Java perspective. Hit the Yes button, and you will be
    rewarded with the Java perspective display (Figure 10.15).
          At this point, your exploration of the Eclipse tools would be more fruitful
    than anything we could tell you. There is a marvelous book on Eclipse, The
    Java Developer’s Guide to Eclipse by Sherry Shavor et al. from Addison-Wesley.
    We encourage you to seek out that book.
    10.4.3 Using Eclipse for an Existing Project
    In the previous section, we mentioned that the second wizard screen in setting
    up a Java project allowed you to override the default path for a project. If you
    have an existing Java program, point the project path to the directory that is
    the base for that program’s packages. When you create the project (in other
10.4 Eclipse: The Source of SWT                                                       257
       Figure 10.15 The Java perspective
       words, when you hit the Finish button in the wizard), Eclipse will scan that
       directory and analyze what it finds there. It does an excellent job of importing
       a project and “eclipsifying” it, even to the point of recognizing and analyzing
       an ant’s build.xml file.
       10.4.4 Working with Eclipse
       Eclipse is a huge topic. We can’t devote enough space to it for this chapter to
       qualify as a user guide. The best we can do is to offer you a handful of tips.
          • The Java perspective consists mainly of the Package Explorer on the left,
             the edit window in the middle, the outline view in the right, and a bottom
             window that changes based on context. Initially, it is a task list. When you
             run a Java application, the console output is displayed there, overlaying
             the task list.
258                                      Chapter 10 Integrated Development Environments
         • You can do a lot of what you need to get started on a project by right-
            clicking in the Package Explorer. For example, you can create a package
            by right-clicking and selecting New> Package. When you type a new
            package name into the resulting dialog box, all required folders are created
            under the project.
         • You can create new classes and interfaces in the same way. If you right-
            click on a package in the Package Explorer and select New>Class or
            New> Interface, an appropriate dialog box comes up, and a skeletal file is
            created in the appropriate place.
            You can compile, run, and debug programs by hitting buttons on the
      toolbar, by selecting from the menu, by right-clicking almost anywhere, and
      by keyboard shortcuts. To put it plainly: Eclipse is a modern, rich IDE that
      works like other IDEs you have seen.
            Eclipse’s real advantages lie in some of the dynamism it offers. As you
      know, the authors of this book like text mode and command line, but we must
      admit that Eclipse’s refactoring features are a great timesaver. For example,
      when you use the refactoring tools to change a method, you can be certain that
      every call to that method, everywhere in the project, is updated. Sure, we
      staunch CLI guys will tell you that you can use pipes and sed to similar effect,
      but even we must admit that you can miss some. We stand by what we have
      said: Know all the tools, and you can then choose the right one. But if all you
      have is a hammer, you’ll end up using it to repair a china cup.
 10.5 REVIEW
      We’ve given you the choice of two great development environments. With
      them you can do so much more than just edit and compile. Both are expand-
      able to include other tools, like CVS and JUnit. Each has a slightly different
      paradigm for how they manage files and projects. It seems the longer we work
      with one (either one), the more we like it. They kind of grow on you and you
      get used to some of the shortcuts that they offer. And yet, there are still those
      times when it’s handy to be back at the simple command line.
10.7 Resources                                                                          259
 10.6 WHAT YOU STILL DON’T KNOW
       NetBeans comes with a built-in version of Tomcat for serving up Web pages
       and JSP and Java Servlets. It’s very handy for developing and testing on your
       desktop. We’ll look at that more in Part IV of this book.
             In the NetBeans help file, you’ll find this intriguing note:
             Using Scripting Languages in NetBeans: NetBeans provides you with a
             scripting feature that lets you use scripts to operate the IDE remotely or
             from the Scripting Console or by using a scripting file. You can use the
             scripting languages provided in the Scripting Console, or you can create a
             scripting class through the New From Template wizard. The following
             scripting languages are provided with NetBeans: DynamicJava, BeanShell,
             and JPython. For information on the scripting languages provided, see
             DynamicJava at http://www-sop.inria.fr/koala/djava/, BeanShell at
             http://www.beanshell.org/, JPython at http://www.jpython.org/.
             We barely got you into Eclipse. Eclipse supports CVS (check out the
       Team submenu). Eclipse provides code refactoring features that allow you to
       rename classes and methods with automatic update of all affected source.
       Eclipse provides a feature to “externalize” strings (which takes all string con-
       stants out of a module and makes them into properties references, allowing for
       easy internationalization). It is a powerful Java development platform.
 10.7 RESOURCES
       NetBeans. NetBeans has some very extensive online help. There are also
       some very good Web-based documents, including the user guide which can be
       found at http://usersguide.netbeans.org/. Of particular value is the
       Getting Work Done guide at http://usersguide.netbeans.org/gwd/
       which describes itself as “a more detailed introduction to the IDE than available
       in the Getting Started tutorial.”
             Support for NetBeans, as with many other Open Source projects, happens
       online. There is no toll-free number to call. Instead you subscribe to an e-mail
       list; all messages sent to the list are then forwarded to everyone on the list.
       Anyone can respond, and you are encouraged to respond too, to share what
       you know with others. The NetBeans developers are often the ones who answer
260                                     Chapter 10   Integrated Development Environments
    the most difficult questions, but lots of times answers come from others who
    have just made it a little further up the learning curve than you.
          To subscribe to the nbusers list, send e-mail to nbusers-subscribe@
    netbeans.org. You might want to create a special mail folder for the constant
    stream of messages that you’ll get from nbusers. We’ve seen about 15–20 mes-
    sages per day, on average, over the past year. You don’t need to read them all,
    but as you scan the subject lines, see if there are ones that you might be able to
    answer. If you want others to reply to your requests for help, it would only be
    fair for you to do likewise. For a directory of the many e-mail lists related to
    NetBeans, go to http://www.netbeans.org/community/lists/.
    Eclipse. The Java Developer’s Guide to Eclipse by Sherry Shavor et al. (ISBN
    0321159640, from Addison-Wesley Professional) is an excellent book on the
    Eclipse platform, particularly from (as the title suggests) the Java developer’s
    point of view. Eclipse is, however, more than just Java. It is designed to be an
    “IDE Factory,” providing a framework for almost any task that involves an
    edit/compile/deploy kind of lifecycle.
Part II
Developing
Business Logic
     Chapter 11
     Balancing Acts:
     An Imaginary Scenario
     In this chapter, the authors wax poetic on practical software development
     methodologies, and attempt to introduce a simple, or maybe simplistic, example
     application for use in future chapters.
11.1 WHAT YOU WILL LEARN
     We want to share with you some thoughts on practical software development.
     We are not covering anything specific to Linux or Java in this chapter; there
     will be no commands to type or syntax to learn here. You may skip ahead to
     the next chapter—but at your own peril. Those who know and use good soft-
     ware process won’t need this chapter, but many programmers don’t fall in to
     that category. In fact, some who think they are using good process may be using
     too much or too little for their actual situation.
          If you are relatively new to the corporate world, or have only worked for
     one or two companies in your career to date, you may get a taste of how soft-
     ware is done in other corporate cultures. If you are a seasoned programmer with
     many such experiences, see if this doesn’t sound all too familiar.
                                                                                 263
264                                       Chapter 11  Balancing Acts: An Imaginary Scenario
            You will also see the requirements for a simple budget application that will
      be used in succeeding chapters. It has little to do with real budgets, but lots to
      do with a simple application that we can use to demonstrate various Java
      technologies.
 11.2 STATEMENT OF THE NEED
      Financial planning is something that everyone does. The basic tool of financial
      planning is the budget. But unlike the home budget, the budget of a large cor-
      poration is managed at multiple levels within the organization. Sure, at some
      level, the board, the CEO, and the CFO decide that “we will spend X million
      dollars for operations for this quarter,” but that is the start of the process, not
      the end.
            From there, the feeding frenzy of middle management begins. And keeping
      track of things becomes an important aspect of financial control and corporate
      governance.
            Realistically, any large business will already have processes and tools in
      place that meet this need. We are not expecting that what we develop here will
      be anything that a business will actually adopt to manage this process. Rather,
      our goal is to illustrate some methods of software development that actually
      work to build real Java application. The outline of methods and code could be
      used to address many classes of enterprise software.
 11.3 HOW TO DEVELOP SOFTWARE
      There is a science of Software Engineering. The development of software can
      be made an engineering discipline, with mathematical rules and metrics of
      success. Every aspect of a complete system can be worked out in detail before-
      hand so that you know, well before a line of code is written, what the outcome
      will be.
            That’s not what we’re talking about here.
            We are talking about software development not as it happens at NASA,
      medical device companies, and in factories where nuclear missiles are made. In
      those contexts, the potential costs of error are extremely high, ranging from the
      multibillion dollar loss (and public embarrassment) of crashing a spacecraft into
      Mars, on through having heart pacemakers fire off incorrectly, right to ending
      life as we know it on this planet. In such cases, no matter how much the correct
11.3 How to Develop Software                                                              265
       software costs, you pay it because the consequences of not doing it perfectly are
       far too high.
             TIP
             Our discussion is not meant to be scholarship on the topic of software develop-
             ment methodology; instead, it is meant to show simple, basic processes that
             can bring a reasonable amount of control to a software development project.
             These steps are, to name a few, requirements gathering, specification, object
             analysis, database design, development iteration (code, unit test, repeat),
             and so on.
             But most of us who write software do not deal with such consequences.
       Most of us are keeping track of purchases and payments. We’re recording pro-
       duction data. We’re tracking manifests and updating inventories. We are the
       great unwashed mass of MIS software developers. Here we, too, want to do it
       perfectly right. But every time we go to management and tell them how much
       it will cost and how long it will take, the little “mass layoff” vein throbs in their
       foreheads. We are always being told to do it faster and cheaper. And so we find
       ourselves, again and again, tilting at the windmill of quality.
             So where does that leave us? When we go to management with the text-
       books of software engineering, they either laugh or scowl. Clearly, the money
       people are not prepared to support the cost of doing it right. So what do you
       do? The best that you can. The one thing we can tell you for certain is that the
       formula for success is not “start writing code and trust to luck.”
             It is fair to say that even the minimal software development method should
       include the following steps:
          •  Requirements gathering
          •  Use case specification
          •  Class discovery and problem domain decomposition
          •  Technical requirements specification (architecturing)
          •  Testing
          •  Code and release management
          •  Production and operations support
          •  Bug and enhancement tracking
266                                          Chapter 11   Balancing Acts: An Imaginary Scenario
           This list, when done in that order, has been referred to as the classic
    “waterfall” model—each step is done in its entirety (or largely so) before
    proceeding on to the next step.
           Or at least that’s the ideal which programmers have often pursued.
           The problem is that the process involves people, and people, especially
    those responsible for the requirements, a) are sometimes unimaginative and 2)
    keep changing their minds. They start out with some requirements, based on
    what they think they’re going to need. But they just aren’t imaginative enough
    to think of how terrible their system will be for the average user. They also keep
    changing their minds as to what they want.1
           The “iterative” approach has been tried as a way to address this problem.
    Rather than wait for all requirements to be spelled out perfectly, with the itera-
    tive approach you jump right in with what you do know, build that, but expect
    changes to come. The sooner you get a working product or prototype into the
    hands of the users, the sooner you’ll get feedback on what works, what doesn’t,
    and what is really wanted (“what works” is used here not in the testing sense,
    but in the usability sense).
           Note, however, that in the iterative approach, one still gathers require-
    ments, develops designs for the code and the tests, develops them, tests (and
    fixes) the code, and releases it. It’s just that one does that on a much smaller
    and more rapid basis. You get something runnable sooner, and continue to
    modify it.
           Some people will complain that this makes for more expensive rework,
    but we (and others) would disagree. You are refining the process. Your reworks
    are less expensive than if you went to the work of building the entire system
    only to have some key requirement(s) change—there can be a lot more
    “wasteage” there.
           Be aware, however, that the iterative approach is not just “whipping the
    horses to run faster.” It is not just the waterfall model run at high speed. Rather,
    it is using the early iterations of the product as a sort of a “living” requirements
    specification, one that you can show to people and that they can try out, in real-
    world scenarios, and on which they can give feedback. Don’t expect to be able
    to compile complete requirements, but don’t give up on talking to your end
    1. Did you notice that we tried to hint at that ever-enjoyable mid-project shifting of require-
    ments as we went from a) to 2), changing our numbering scheme midway? Minimal humor,
    admittedly, but if you’ve lived it, you understand.
11.4 What Makes a Good Requirement                                                   267
      users and other stakeholders either. Requirements are still key to delivering a
      solution.
             So with either approach, you’ll start with requirements. Let’s look at the
      art of requirements.
 11.4 WHAT MAKES A GOOD REQUIREMENT
      A good requirement is one that states a need but not a solution. Sounds simple,
      but it’s easier said than done—especially with solution-oriented technical types.
             A typical first cut at a requirement might be something like “Our budget
      application should store its data in the database.” While it sounds reasonable,
      it is really a solution posing as a requirement.
             The first step in refining such a requirement is to ask the simple question:
      “Why?” The answer we’re looking for is not “Because we’ve paid so much for
      our database software,” nor is it “Because we all know SQL.” Rather, it should
      be something dealing with reliability, fault tolerance, the need for transactional
      integrity, and so on.
             Sometimes you may have to ask the “why” question more than once, to
      refine the requirement(s). “Transactional integrity” is, in a way, a solution. You
      could ask, “Why do we need that?” For some projects it may be appropriate to
      ask this, because there may not be a real need for it after all.
             But don’t overdo it. Push any requirement in a business setting far enough,
      and you could get something like “To make money.” That’s not a helpful re-
      quirement. You’ve gone too far. Part of the art of requirements is recognizing
      when to stop asking why.
             A more detailed description of a requirement is that it should be
      SMART—Specific, Measurable, Attainable,Repeatable, and Testable. Consider
      the following.
             A common concern among users of almost any application is that it be
      “fast” or “responsive.” While we can sympathize with the concern, it will need
      some refinement before it can be considered a (good) requirement. Applying
      the “Specific” and the “Measurable” aspects of SMART, we need to specify
      what constitutes “fast enough.”
             We can try “No button press in the GUI will delay more than .1 second
      before providing some evidence of activity to the user, or more than .5 second
      before completing its operation.”
268                                        Chapter 11 Balancing Acts: An Imaginary Scenario
            Sounds more formal, and more specific, but is it realistic (i.e., attainable)?
      If the “button press” is one that updates a database across a network, what effect
      will network traffic have? What about the size of the operation? If the button
      press starts an operation that is dependent on the size of some data set, what’s
      the largest it could be and how long will that take?
            Depending on how obsessive you or some colleague will be in enforcing
      these requirements, you would do well to add a few “weasel words” to give you
      some flexibility in the requirements. Phrases like “on average” or “most” will
      help. Notice, though, that such words are also the cause of much ambiguity,
      working against the “Specific” and “Measurable” aspects of good requirements.
      Use them sparingly, if at all.
            We should also consider the “testable” aspect of our requirement for speed.
      Will we be able to measure this? Can we do so repeatedly? Consider the effect
      of network traffic on response times. Under what network load will the tests
      be done and the real usage occur? If you want to test under “normal” network
      loads, how can you control this (for the sake of repeatability)?
            It really is an art to craft good requirements. Moreover, a good require-
      ment for one organization may not work well for another. Some teams, groups,
      or companies want to be very precise in their use of requirements, viewing them
      almost like legal contracts for what will be delivered. Such requirements, how-
      ever, would be greeted with derision in other, more informal, organizations.
      It’s not that the one will produce good software and the other garbage (well,
      they might). It’s more a matter of style. Excessively formal organizations will
      drown in the details and spend way too much time (and money) arguing over
      the minutiae of the requirements. Overly informal groups will get sloppy with
      their requirements and not reap the benefits of building the right thing the first
      time. As is so often the case in life, the answer lies in striking a balance between
      two forces, one pushing for exactitude and the other pulling you to get going
      and do something.
            So let’s keep going.
 11.5 WHOM TO ASK FOR REQUIREMENTS
      There are many people to ask about the requirements for a software project or
      product. Ask yourself the following questions:
          • Who is going to use the software that you develop?
11.6 Requirements for the Budget Application                                                 269
          • Who is going to use the data that comes from the use of the software (i.e.,
             who will read the reports generated from the data collected either directly
             or indirectly from the running of the software)?
          • Who is going to support the software and who will support the machines
             on which it will run?
       All these people can be considered “stakeholders” in the project.
             So where do you start? That’s a political more than a technical question.
       Start with your boss and with whoever is the major backer of the project. Then
       ask your customers. For in-house IT projects, the “customers” are usually very
       accessible; for software products, the customer’s point of view may need to be
       represented by marketing and/or customer support people who have had direct
       contact with the customer base.
 11.6 REQUIREMENTS FOR THE BUDGET APPLICATION
       Let’s take a look at how such requirements might evolve. We’ll look at the
       situation through the eyes of a fictional IT guy named Bob.2
       11.6.1 Monday Morning, 10 A.M.
       Bob gets called in to the office of his manager, Ellen. The conversation goes
       something like this:
             Bob: Yes, Ellen, you wanted to see me?
             Ellen: Come in, Bob. Yes. We’re just about to enter another budget
       planning cycle. We’ve got to propose our next year’s budget to the VP by the
       end of the quarter, and I got to thinking . . .
             Bob: Uh-oh.
             Ellen: . . . on my way to work today, I got to thinking that we ought to
       be able to develop a software tool that would help us do a better job of this
       process.
       2. We’re avoiding giving Bob a title because titles vary so much within our industry. Call
       someone an analyst and it may mean that they never code. Call someone a programmer and it
       may mean that they only code and never deal with requirements or even designs. Some use
       those terms interchangeably. We’ll just call him an IT guy.
270                                    Chapter 11  Balancing Acts: An Imaginary Scenario
          Bob: We’ve used a spreadsheet these past few years to do our budgets. You
    want us to develop another spreadsheet application?
          Ellen: No, I want a whole new application.
          Bob: You want us to reinvent the spreadsheet?
          Ellen: No, I want something simpler and more specific to the budgeting
    process.
          Bob: Tell me more. What are the key features that you see in this
    application?
          Ellen: Well, first of all it needs to be able to work concurrently with all
    the users. With our spreadsheet, we’d have to take turns with the data entry or
    we’d risk loosing each other’s changes.
          Bob: It may just be that we’re not using our spreadsheet’s advanced
    features. Shouldn’t we investigate that first?
          Ellen: No, I’d rather have us invest our time in building the tool we know
    that we need. At the end of the day your investigation may only show that we
    still need the tool, and by then it might be too late to build it.
          Bob: I hear you saying that the deadline is rapidly approaching.
          Ellen: Yes—I want to be able to use it for the budget planning at the end
    of this quarter. How long do you think it will take you to build it?
          Bob: Build what?
          Ellen: Haven’t you been listening? The budget tool!
          Bob: I know that you mean the budget tool—but you haven’t really given
    me enough requirements upon which to base an estimate. Tell me more about
    how you envision this tool being used.
          Ellen: Well, in the past we’ve taken last year’s numbers and just bumped
    them up by a few percent. Then we look at each category and tweak them. I
    want a different approach this year. I’m going to take our department’s budget,
    give it a bump, then assign a chunk to each of my reports. I want you to take
    those discretionary dollars and spell out how you would spend them.
          Bob: Shouldn’t we be providing you with estimates of what we need for
    the coming year, rather than you telling us what we have to spend?
          Ellen: In theory, perhaps so. But in practice we can only grow the budget
    by so much. I’d rather skip the charade and jump right to allocating the dollars
    we will likely be able to spend. Then as the year progresses, I’d like to use this
    tool to track our spending against this plan.
          Bob: But isn’t that why we have that big SAP application?
11.6 Requirements for the Budget Application                                                       271
             Ellen: Have you ever tried to use it?! Please! The CFO thought it looked
       great—and on paper it did. But that user interface makes it almost impossible
       to be productive. And it’s as slow as molasses.3
             Bob: But back to this new application . . . I’m assuming you’ll want a GUI
       on this?
             Ellen: Of course. Give it a standard, simple GUI. Something like this.
       (She begins to draw on her whiteboard.)
             For any given department there will be a “pool” of money. Those dollars
       are displayed and can be subdivided into smaller pools of money by creating
       subaccounts.
             But as the money is subdivided those new accounts and associated dollars
       should become visible by others. And as dollars are spent during the year, we’ll
       want to track those dollars, so those amounts should be visible, too, and
       subtracted from the overall pool of available dollars.
             Bob: Wait . . . back up. What needs to be entered to subdivide an
       account?
             Ellen: The user just picks an account, then chooses to subdivide it, enter-
       ing the amount to put in each account . . . or even just a percent of the larger
       pot of money.
             Bob: So if he picks one account to subdivide, does it split into two, or
       three or how many?
             Ellen: Let the user choose, but maybe two as a default.
             Bob: OK, but we may need to take a harder look at that interaction.
             Ellen: So how long will that take? Can you have it ready by the end of this
       month?
             Bob: I’d like to try the “spiral” approach on this project. I can have
       something for you by the end of this week— from which you can tell me if I’m
       heading in the right direction. It will just be a beginning, but you’ll be able to
       see something run. By the way, is this tool only for our group?
             Ellen: For now it is, but I could see other departments wanting to use it
       some day. Who knows how far it could go?
       3. Remember, this is a fictional account. We are providing justification for why they can’t use
       the corporate application. Anyone’s use of such a tool can be less than optimal, reflecting more
       on themselves than on the value and usability of the tool.
272                                      Chapter 11  Balancing Acts: An Imaginary Scenario
      11.6.2 Back at His Desk
      Bob is now back at his desk pondering the conversation he had with Ellen.
      “These are not like the requirements we learned about in my software engineer-
      ing courses,” he muses. “I’ve got that sketch of the UI and a brief description
      of its functionality. But there seem to be so many unanswered questions.”
            So what is Bob supposed to do? He could go back and try to get more
      “face time” with Ellen, and ask lots more questions. Sometimes that’s a smart
      thing to do. Other times such repetition is seen as annoying and a sign of a
      slow-witted analyst, never mind how obscure the initial discussions were or
      how many times someone changed their mind about what they want. You will
      have to judge each situation as you encounter it. At some point, though, you
      have to deal with whatever information you’ve been given, and try to make the
      best of it.
            So where do you turn? The next best things to do are to begin to docu-
      ment the requirements as you understand them, to prototype a solution, and
      to start getting buy-in from other stakeholders. Each of these activities may
      help bring out more requirements, but that’s not a bad side effect.
 11.7 DOCUMENTING, PROTOTYPING, AND STAKEHOLDER BUY-IN
      Once a project is started, the design must be documented. A prototype may be
      built to validate and refine the design. Finally, everyone with a stake in the
      success of the design has to be brought up to speed and needs to agree on what
      is to be built.
      11.7.1 Documenting
      After such a conversation, it’s smart to try to get your thoughts down on paper
      as soon as possible. Some of what gets said will fade with time, so work quickly
      to capture what you can of the requirements that were spoken. Even if you have
      to leave lots of blanks, keep moving and get as much of the major requirements
      written down as you can, even if they don’t sound very formal or polished.
      Then go back, revise and edit your statements, filling in the blanks where you
      can. Sometimes you will need to ask others to get the answers to fill in the
      blanks. Other times you can use your own judgment and initiative to provide
      an answer. Out of this process with its subsequent rewrites will come the
      requirements document.
11.7 Documenting, Prototyping, and Stakeholder Buy-In                               273
            Some organizations are very formal in their understanding of requirements.
       They will have company-standard formats which you must follow. But there
       is no magic format that will make for good requirements. It really all comes
       down to content.
            Here’s an informal list of the requirements for the budget application,
       based on the conversation between Bob and Ellen.
            Features:
          • Starts with a single lump sum of dollars.
               • How does this first sum get entered?
          • Each dollar amount is associated with an “account.”
          • Any account may be divided into two or more subaccounts.
          • The dollar amount associated with a subaccount is specified either in
            absolute dollars or as a percentage.
               • What if they don’t add up?
               • Can the user mix $ and %?
               • Can the user leave the last subaccount’s amount blank for “remaining
                  dollars”?
          • Tracking of the dollars—not enough info, so not in first prototype.
          • Multiple users will have access to the data.
          • Concurrent use is allowed and supported.
          • Short development time, limited resources.
          • Has a graphical user interface; earliest versions may be command-line and
            terminal interaction.
            Not all requirements will be easily forthcoming; not all can be traced back
       to an exact quote from the previous discussion. Other requirements will need
       to be inferred from the discussion or from department “culture,” or come from
       your own judgment:
          • Platform: “any” PC in Ellen’s department—but her developers are all using
            Linux platforms.
          • Future platforms: “any” PC in the company means any Windows, Linux,
            or Mac OS X.
          • Reliability: once entered, data is never lost.
          • Maintainability: the application must be easy to maintain.
274                                          Chapter 11     Balancing Acts: An Imaginary Scenario
       • Interoperability: there’s no requirement to interoperate with any other
           software but here’s an idea for a future version: export/import into CSV
           format for spreadsheets, and/or XML format for future expansion).
       • Response time: “reasonable” interactive speed; subsecond response when
           entering new accounts and values, so that the user can type quickly and
           continuously; waiting, if it occurs, should only be at button presses, not
           between data entries.
    11.7.2 Stakeholder Buy-In
    Stakeholder buy-in can be another important part of a software project. As we
    discussed in Section 11.5, stakeholders are any of those people who are touched
    in some way, direct or indirect, by this software project.
           For this simple budgeting program, there will be few stakeholders—it will
    largely be Ellen and her direct reports. The system will not likely be a large
    drain on computing resources, so system admins don’t need to be brought in
    at this point. If and when the project expands to include other users across the
    network and across the enterprise, then the system administrators should
    definitely be included. There will be few reports from this first cut of the
    project, and what few there are will only be read by Ellen and her direct reports,
    so again, there are few others that need to be consulted as stakeholders.
           The idea at this stage is to listen to other points of view—those of your
    stakeholders—to get a different perspective before charging headlong down
    one avenue of development.
           It’s not that you will be able to satisfy all points of view—it can be a wor-
    thy goal, but it is often unattainable. Rather, you need to hear from all those
    involved since your software will affect all those people, and understanding
    something about how it will fit into their roles and daily tasks will help you
    make better tradeoffs and design better software. It will likely uncover previous-
    ly unseen requirements. It also has the political benefit of those people knowing
    that you cared enough to listen to them before sending them a finished solu-
    tion. It increases the likelihood that your software will be seen as a help, not
    hinderance.4
    4. As engineering types it is difficult for us to understand and appreciate the importance of
    this, but in many ways these personal, political, and psychological factors are much more im-
    portant to the success of a project than are technical choices. It has taken us years to appreciate
11.7 Documenting, Prototyping, and Stakeholder Buy-In                                         275
       11.7.3 Prototyping
       Prototyping can be an effective way to carry on the discussion of both require-
       ments and user interface design. Given only a hypothetical or abstract descrip-
       tion of some software, it can be very difficult for people to imagine what the
       implications of its use will be. A simple prototype can immediately bring the
       discussion down to the concrete; people can point at things and say “I like this”
       and “I don’t like that” and “How would I do so-and-so” and then see whether
       or not it would work. Sometimes, ideas that sound great on paper turn out to
       be pretty poor ideas when realized. Prototypes can help you discover that
       quickly and easily.
             One very useful but inexpensive prototyping mechanism can be
       HTML—that is, creating Web pages. Simple static HTML can be fast and
       cheap to build, but can begin to approximate what the user interaction will
       look like—especially for, but not only for, Web-based solutions. It may not be
       an exact replica of the final product, but for a first step it can really get the
       discussion moving.
             If the UI is too complex for a Web page mock-up, you can still use HTML
       for prototyping by getting images (screenshots) of what you want your final
       solution to look like and then making these images clickable on Web pages, to
       simulate some simple user interaction with hyperlinked image sequences.
             The idea is to get something “tangible” in front of people as soon as possi-
       ble, to further the discussion in a way that written descriptions never can.
       (“A picture is worth a thousand words.”)
             Once you’ve built a prototype, shop it around. Hold informal meetings
       where you demonstrate the basic functions to stakeholders. We recommend,
       as much as possible, meeting with one group of stakeholders at a time. That
       way you can keep your conversations focused. If you have two different stake-
       holder groups represented and their expertise and interests are wildly different,
       you’ll be boring 1⁄2 the participants all the time. Even if their expertise is similar,
       you may have groups with competing or conflicting requirements. While you
       need to understand such conflicting requirements and eventually come to some
       detente, this meeting is not the best venue for settling those issues; it would
       more likely simply scuttle your meeting and void any value from it.
       that Dale Carnegie is as important to the software designer as Yourden or Booch. Your users
       need to be your friends if you want to succeed.
276                                      Chapter 11   Balancing Acts: An Imaginary Scenario
            After each meeting, review your requirements and see what more you need
      to add. Likely at such meetings, you’ll begin to get requests for new features.
            You have, in fact, begun the iterative process. Even the most bare-bones
      prototype that may only consist of a sequence of pictures is a first cut of your
      product. The sooner you can get to a running version, the sooner you will be
      able to respond to stakeholder suggestions by adding real features.
 11.8 REVIEW
      A good requirement is one that states a need but not a solution. Your first step
      is to uncover the needs, while listening to everyone’s solutions. These require-
      ments will develop into feature descriptions. These should be documented and
      then prototyped. The prototype, which is in effect the first release of your
      product, can then be shown to various groups—stakeholders—as a way to
      elicit their feedback. This feedback should begin to factor in to what you will
      build, so now you need to move quickly on to building the real product; do
      not get stuck enhancing the prototype.
 11.9 WHAT YOU STILL DON’T KNOW
      Writing good requirements is as much art as it is science, and it involves politi-
      cal science as well. This is not something easily taught in a book, but learned
      through hard experience.
11.10 RESOURCES
      One of the original purposes of the World Wide Web was to allow researchers
      to share their results. So, you should be able to search the Web for requirements
      documents from various projects for examples of requirements specification.
      As with any Web search, remember to consider your source. Just because
      someone has posted a requirements specification or a template doesn’t make it
      a good example.
            Here are three examples that we found on a single simple Google search.
      They may still be there by now.
11.11 Exercises                                                                       277
          • http://www.progsoc.uts.edu.au/~timj/thesis/web/srs.html
          • http://www2.ics.hawaii.edu/~johnson/413/lectures/5.2.html
          • http://www.cc.gatech.edu/people/home/tomoyo/rocky-axel.1.doc
            For those who are serious about their software development process, the
       Capability Maturity Model for Software from the Software Engineering Insti-
       tute at Carnegie Mellon University is the standard. Visit their Web site at
       http://www.sei.cmu.edu/cmm/.
            If you would like to know more about the spiral approach to software de-
       sign, you might want to start with the seminal paper on the topic, “A Spiral
       Model of Software Development and Enhancement,” in Computer 21, no. 5
       (May 1988), pages 61–72.
            To see how the director of the Software Engineering Institute views
       the spiral approach, check out the short and readable introduction at
       http://www.dacs.dtic.mil/awareness/newsletteres/technews2-1/
       disciplined.html.
            Another good look at the spiral, or iterative, approach can be found at
       http://www.stickyminds.com/se/S3420.asp which has a hyperlink for
       a PDF file of a paper by Philippe Kruchten of Rational Software. The paper
       covers some pitfalls common to the first uses of the iterative approach; worth
       the read.
            A great survey of key papers on three major approaches—spiral and related
       topics (including newer work by Boehm), aspect-oriented programming (AOP),
       and the rational unified process—is at http://www.rspa.com/reflib/
       PrescriptiveModels.html.
11.11 EXERCISES
         1. Write requirements for a simple word processor or spreadsheet. Start with
            some obvious functionality. Add only enough “bells and whistles” for it
            to be usable for beginners. Show this list to others, especially people famil-
            iar with similar applications. What features do they find missing that are
            important to them? How quickly does your list expand? What might you
            do to limit the size and the rate of growth of the features list?
278                                   Chapter 11 Balancing Acts: An Imaginary Scenario
    2. Discuss the requirements for your application with someone who has no
       experience with a similar product. How difficult is it to get useful feed-
       back? Now show them (the simple features of ) a working spreadsheet or
       word processor, as if it were your prototype. Does the conversation change?
       In what ways? Is the feedback now more or less useful than before they
       saw the prototype?
     Chapter 12
     Analysis and Design:
     Seeking the Objects
     In this chapter, we will present the barest outline of a software development
     methodology. For some readers, this will be simplistic and unsuitable. In our
     experience, however, there are many businesses out there with very small devel-
     opment teams that have very little software engineering experience, even though
     they have considerable technical and programming skill. Our goal here is to
     present a bare minimum of analysis and design method, so that we can be sure
     we have a common basis for discussing the issues of object-oriented analysis
     and design.
12.1 WHAT YOU WILL LEARN
     In this chapter you will learn a very simple method for object discovery and a
     simple method of documenting this process.
                                                                                 279
280                                   Chapter 12  Analysis and Design: Seeking the Objects
 12.2 FACING THE BLANK PAGE
      So, you have some requirements. Maybe you even have some UI prototypes.
      How do you turn that into an object-oriented design for Java classes? How do
      you confront the paralyzing blank white of your whiteboard, terminal session,
      or easel?
            The simplest way is to start with real-world objects. Stop thinking about
      everything you have read about object-oriented programming. Instead, ask
      yourself, “What are the real objects involved in this problem?”
            In our case, the more you look at it, the simpler it gets. For the moment,
      the only real objects we have are people—the users—and accounts, that is,
      named pools of money. We know that users get accounts from “above,” and
      that they may break those pools down into subaccounts, which they may own
      or delegate to other users.
            At the broadest level, then, we seem to have two “classes” or types of
      real-world objects: Accounts and Users.
 12.3 USING CRC CARDS
      So, we need two classes. But what goes into those classes? How do we go about
      putting the substance into this simplistic framework?
            In their now (semi)famous paper presented at the object-oriented program-
      ming conference OOPSLA in 1989, Kent Beck and Ward Cunningham intro-
      duced a simple, practical design tool for object-oriented design based on a
      simple, practical 3x5 file card. The CRC cards for our classes are shown in
      Figures 12.1 and 12.2.
            But we are getting a bit ahead of ourselves. These CRC cards are an end
      product of analysis. They are the starting point for coding. Let’s talk a little bit
      about what is on these cards and how we came to that content.
 12.4 FINDING THE OBJECTS
      The basic technique for doing OOA1 with CRC cards is to start with a stack
      of blank cards. Assemble a design team (this may be one person, or this may
      1. (object-oriented analysis)
12.4 Finding the Objects                                                                          281
          Account
          a pool of dollars
          members                                 collaborations
          * name - a String                       * persistence (CRUD)
          * owner - a User                        * User
          * amount - an SAMoney object
          * children - an ArrayList (of Accounts)
          * parent - an Account
       Figure 12.1 Account CRC card
          User
          someone who manages budget dollars
          members                                 collaborations
          * name - a String                       * persistence (CRUD)
          * home - an Account                     * Account
       Figure 12.2 User CRC card
       be dozens).2 The first step should always be the nomination of the real-world
       objects. Don’t edit or critique at this point. If someone says “computer” as an
       object, write “Computer” on the top of a card and put it on the table. If
       someone says “Manager” write it on a card and put it on the table.
       2. It is fun to gloss over such a complex topic with a single sentence! Obviously, the composi-
       tion of a design team is a complicated matter. At the very least, a design team must include a
       representative from the programming team and a future user of the system. On small, simple
       projects, that may be all you need. On more complex or mission-critical systems, there will
       have to be additional representatives, such as people from Operations, Support, Training,
       Quality Assurance, and so on.
282                                     Chapter 12 Analysis and Design: Seeking the Objects
          To take our example, suppose we have the following list of CRC cards
    after such an open brainstorming session:
       •  Database
       •  Capital Account
       •  Current Account
       •  CEO
       •  Computer
       •  CFO
       •  Director
       •  Keyboard
       •  Manager
          Where do you go from here? Let’s articulate a general principle.
    The first principle.        If we could teach a programmer only one thing about
    software design, it would be this idea: less is more. Or, to quote Antoine de
    Saint-Exupéry: “Perfection is achieved not when nothing can be added, but
    when nothing can be taken away.” Or, to put it yet another way, always use
    the KISS3 principle. The best object design is the smallest possible number of
    classes that model the real objects and meet all the requirements.
          You are seeking simplifying abstractions.
          First of all, all the objects that represent technologies or implementation
    details should be removed. In our list, this would include “Database,” “Com-
    puter,” and “Keyboard.” While it is likely that all three will be involved in the
    final product, they are not objects in the problem space. There is no theoretical
    reason why an OOA session cannot produce a manual, noncomputer solution.
    It is a common tendency to leap from problem analysis directly to technical
    solutions. “We can write that in Java,” “We can store those in Oracle,” “That
    could be an XML file.” Statements like these are to be avoided at this stage.
    Those are details about the implementation. You haven’t got a design to
    implement yet!
          As we said, you are seeking simplifying abstractions. The next step, after
    culling cards that do not represent real objects in the problem space, is to
    group together the cards that have any attributes in common. If we look at our
    3. An acronym for: Keep It Simple, Stupid!
12.5 Finding the Methods and Attributes                                                                283
       remaining cards, we can quickly see that we have two cards that are accounts:
       “Capital Account” and “Current Account.” These are both pools of money.
       Put them on top of one another on the table. Likewise, it is fairly obvious that
       “CEO,” “CFO,” “Director,” and “Manager” are all people. Put them together
       on the table.
              Remember that we are looking for simplifying abstractions. The grouped
       cards should all be obviously variant types of a generic class of objects. In our
       example, the one is a stack of Accounts, and the other is a stack of People, or,
       as we will call them, Users. Create new cards for these generic classes. Make a
       card with “Account” at the top and put it above the first stack. Make another
       card with “User” at the top and put it above the second stack.
              There are two ways that this might simplify your design. For now, all cards
       below the abstract cards are “on probation.” We are going to move on to define
       the attributes (data) and methods (behavior) of our abstract classes. If the ab-
       stract class can handle all use cases without having to treat any of the more
       specific classes differently, then the specific cards are discarded. If not, then all
       functionality that is common across the more specific types will be put on the
       abstract class card, and only those data and behaviors that are different will be
       put on the more detailed cards.
              In the first case, the simplification is a reduction of several potential classes
       to a single class. This is always a good thing, when it is possible. In the second
       case, you are identifying potential inheritance relationships.4
 12.5 FINDING THE METHODS AND ATTRIBUTES
       The next step is to start identifying the data and behavior that characterize your
       classes. Always put such items on the most abstract class first. The only time to
       add an attribute or method to a more specific class is when it applies to that
       class and only that class—in other words, only when it represents a difference
       between the general case and the specific case.5
       4. We’ll talk more about that later in the book. As it happens, all of our simplifications in this
       chapter are examples of the first case.
       5. In complex cases, you may find an attribute or method that applies to several, but not all,
       of the specific cases. In such a case, a new abstract class below the main abstract class, but above
       all the specific classes that share that attribute or method, may be called for.
284                                    Chapter 12   Analysis and Design: Seeking the Objects
 12.6 ESSENTIAL AND NONESSENTIAL
      So far, we have walked you through a very simple example, and we have made
      sound choices at every step. In more complex cases, even the best of us will
      make mistakes. We will head down blind alleys. We will group things together
      that might belong in separate abstract categories, but should, perhaps, share an
      interface. These are not so much errors as judgment calls, and skill at recogniz-
      ing them and making the correct decisions comes only with experience.
           For now, the most important questions to ask include:
         • Do I need this class?
                 We are often tempted to create too many inherited classes. When we
           seek more generic, higher level abstractions, it is often possible to use only
           the more abstract class. Of course, it is possible to carry that tendency too
           far. If your methods contain a lot of “if’s” to handle various subtypes, that
           might be a case where you should inherit and overload the method.
         • Should I get functionality by inheritance or composition?
                 Inheritance should be reserved only for cases where a class is a more
           specific variety of the base class. For example, you might have a Person
           class, and then you might have Employee and Customer classes inherit
           common attributes and methods from Person. This is frequently called an
           “is-a” relationship, as in “A User is a Person.” If your proposed inheritance
           relationship makes sense phrased that way, it might well be a good
           candidate for inheritance.
                 Composition is when you use a class as an attribute. To extend our
           example, you might have an Address class. You might be tempted to have
           Person inherit from Address. But a Person is not an Address. Try it: “A
           Person is an Address.” Nope. Instead, you should just have an instance of
           the Address class as an attribute of Person. Such a relationship is often
           called a “has-a” relationship, as in “A Person has an Address.” If the
           relationship makes sense phrased that way, it is a good candidate for
           composition. Another way to recognize that you’ve wrongly used inheri-
           tance is if you end up having a radically different class inherit from the
           same base class. For example, suppose you have a class, Building. Would
           it make sense for Building and Person to inherit from Address? Are
           Buildings and Persons more specific instances of the same general type of
           thing? No, they are not. Building and Person should get Address
           functionality by composition.
12.6 Essential and Nonessential                                                          285
          • Does this attribute or method belong here?
                  If you find yourself specifying nearly identical methods in more than
            one class, this should make you ask if the classes should have a common
            base class from which they should inherit, or if there should be a new
            unrelated class that they all share by composition.
                  If the functionality is the same for a set of classes, and the classes are
            specific instances of a more general type, the method should be on the
            general class. For example, a changeName() method should probably be
            on Person, not on Employee or Customer, because the functionality is the
            same for all three classes. By contrast, a changeEmployeeNumber()
            method should be only on Employee. It should not be on Person, because
            not all Persons are Employees. There may also be methods that are com-
            mon to both Employee and Customer types, but are radically different in
            implementation. For example, a changePassword() method might
            change a password in a system-wide LDAP server for an Employee, but
            might just change a record in a Web site database for a Customer. This is
            easily done by writing separate methods in each class.
                  But should you add a changePassword() method on Person? If you
            want to be able to call the method when treating either a Customer or an
            Employee as a Person, then you should. But you don’t have to implement
            the method on Person. You can declare Person.changePassword as ab-
            stract, and then, if you call the method on a Person, it will call the correct
            method based on what type of Person (Employee or Customer) the Person
            is. Note that if a class contains any abstract methods, the class itself must
            be declared abstract and it cannot then be instantiated. Also note that
            this is often best accomplished not through abstract classes, but through
            interfaces (see Eckel, pp. 321–322).
            These are by no means the only considerations that come to bear on what
       classes to create and how to arrange and implement them, but they do represent
       a good start. They are a foundation on which you can build best practices out
       of your own experience and environment.
            Whole books have been written on the topics of object-oriented analysis
       and object-oriented design. CRC cards are only one part of an array of tech-
       niques that can be applied to OOA/OOD. The Unified Modeling Language
       (UML) is popular in many MIS circles. UML consists of a variety of different
       diagrams which are used to model parts of an object-oriented design. They are:
286                               Chapter 12    Analysis and Design: Seeking the Objects
                      Am I Mature? Or Are You My Mommy?
    Let us point you at one more business buzzword link. Even though we
    think this particular site and their work are being ill-applied by many
    well-intentioned IT managers, there is still a great deal of value in the
    Carnegie Mellon Capability Maturity Model (http://www.sei.
    cmu.edu/cmm/). At the very least it provides an objective way to assess
    the level of process sophistication you have in your organization.
          The CMM defines five levels of maturity:
      1.  Initial
      2.  Repeatable
      3.  Defined
      4.  Managed
      5.  Optimizing
          If we may grossly oversimplify (and why should we stop now?),
    “Initial” means you do things differently every time. You just make your
    best guess about what the right thing to do is, and you do it. “Repeatable”
    means that you have hit upon a method that appears to work, and you
    use it consistently. “Defined” means that somebody has written it down.
    “Managed” means that the process is actively maintained and supervised
    in an effort to adapt it to changing circumstances. “Optimizing” means
    that measurements (“metrics”) are made that objectively assess the pro-
    cess, and ensure that continuous improvement takes place and can be so
    proven.*
          What we have shown you in this chapter probably falls in the Repeat-
    able category, a long way from the engineering and management nirvana
    of Optimizing.
    * The problem that seems to come up with this system is that very bad processes may
      be very mature and very good processes may be relatively immature. Obviously,
      however, an Optimizing process must be steadily moving towards the good.
12.7 Analysis Paralysis                                                             287
          •  Class Diagram
          •  Sequence Diagram
          •  Collaboration Diagram
          •  Use Case Diagram
          •  Activity Diagram
          •  Component Diagram
          •  Deployment Diagram
             Using the simple but effective technique of CRC cards can be a good place
       to start, but you may soon want to move up the OOA/OOD ladder to use tools
       like Umbrello6 to make UML diagrams, and perhaps to use the whole UML
       toolset.7 Many organizations that we know of will pick and choose various
       techniques and tools. No matter how far down the road of formal software en-
       gineering you go, you must at least make some effort to have a repeatable
       process that incorporates continuous improvement.
 12.7 ANALYSIS PARALYSIS
       The catchy phrase “analysis paralysis” has become a cliché. (And how could it
       not, being so catchy?) What it refers to, of course, is the tendency to become
       bogged down in details; or the tendency to refuse to start implementation until
       you are certain that your design is “right.”
             This is where using a “spiral” development model can pay off. By doing
       frequent small releases, you can expose subtle design flaws at an earlier stage in
       development. Often, you can (to trot out another trendy term) “refactor” a
       small part of your design or implementation. If you have clean object interfaces,
       this can often be done with minimal disruption because a good object model
       hides implementation details within classes.
             In most cases it is best, once you have the use cases and requirements, to
       proceed to a prototype object model and learn by doing.
       6. http://uml.sourceforge.net/index.php
       7. http://www.uml.org/
288                                      Chapter 12  Analysis and Design: Seeking the Objects
 12.8 REAL SOFTWARE ENGINEERING
      Let’s take a moment here and ask a fundamental question. Is this the best way
      to make software? And there is another fundamental, but subtly and important-
      ly different question: Is this the right way to make software?
            There are techniques and methods of Software Engineering that do ap-
      proach the ideal of “zero defects.” NASA uses such procedures for manned
      spacecraft. Coders for medical devices do likewise. The outline method we have
      suggested here doesn’t come close to such methods. So, is what we have de-
      scribed the best way to make software? No, it is not. So why don’t we all use
      those zero defect methods? That is easy to answer: cost. It is expensive. Virtually
      no MIS shop on the planet would be willing to pay the price it takes to get that
      stability and certainty. The price isn’t just dollar cost, either. The Space Shuttle,
      for example, has computers that still use magnetic core memory, a technology
      that was old in the 1970s. Why? Because the restrictions imposed by their
      change control systems would essentially require the entire shuttle to be
      redesigned and retested if they made such a change.8
            But this isn’t an either-or. You do not have to apply either a full-fledged
      software engineering methodology, or use nothing at all. Instead, you have to
      apply some design, development, and maintenance processes that improve the
      probability of success and reduce the cost of failure. When we recommend
      version control, requirements gathering, use cases, and CRC cards, we are giv-
      ing you a bare-bones set of methods that will help to write fairly successful
      software at reasonable cost in reasonable amounts of time.
            To some of you, this will be old news. If you are at level 2 or above on the
      Capability Maturity Model (see the sidebar in Section 12.6), then you already
      have some process. But you would be surprised how many business out there
      do not even have source code control in place. To some of you, what we suggest
      here will be primitive compared to processes you already have. The point is, no
      one’s level of control and process is “right” (to us, that means “cost-justified”)
      for all cases. But using no method at all is a risk too great for any business.
      8. An exaggeration to be sure, though maybe not as much as you might think, but you get
      our point.
12.12 Resources                                                                       289
 12.9 CORE CLASSES
       So, let’s meet our core Java classes. Here they are, in all their glory (Exam-
       ples 12.1, 12.2).
12.10 REVIEW
       We have discussed a simple approach to object-oriented analysis and design
       through the use of CRC cards. The ideal outcome is a design with the smallest
       possible number of classes that model real-world objects while meeting all the
       requirements.
12.11 WHAT YOU STILL DON’T KNOW
       We could list the names of a number of formal software engineering method-
       ologies, but we won’t bother. If this chapter has served as your only introduc-
       tion to object-oriented analysis and software engineering, let’s just say you have
       a lot of reading to do. But beyond that, there is something you need that is
       much more subtle and difficult to pin down: experience. The only way to get
       good at analysis and design is to do it. It helps to do it in conjunction with ex-
       perienced people, because they can save you time and pain in acquiring your
       experience. This chapter is the simplest of foundations. The books give you
       knowledge. Experience gives you wisdom.
12.12 RESOURCES
       Kent Beck and Ward Cunningham, “A Laboratory for Teaching Object-
       Oriented Thinking”, in OOPSLA’89 Conference Proceedings, New Orleans,
       Louisiana, October 1–6, 1989. The special issue of SIGPLAN Notices 24, no. 10
       (October 1989) is also available online at http://c2.com/doc/oopsla89/
       paper.html#cards.
            More on the Capability Maturity Model can be found at
       http://www.sei.cmu.edu/cmm/.
            Information on the Unified Modeling Language can be found at
       http://www.uml.org/.
290                                    Chapter 12  Analysis and Design: Seeking the Objects
Example 12.1 The Account class
package net.multitool.core;
import net.multitool.util.*;
import java.util.*;
import java.sql.*;
public class
Account
{
  private String name;                       // A name to identify this account
  private User owner;                        // The user assigned to this account
  private SAMoney total;                     // Total amt originally allocated to
                                             //   this account
  private SAMoney balance;                   // amt remaining unallocated to any
                                             //   subaccounts
  private Account parent;                    // The account which contains this
                                             //   account as a child
  private HashMap children;                  // The collection of subaccounts,
                                             //   by name
  private static Connection dbConn = null;   // JDBC connection
  private ArrayList payments;                // TODO: unimplemented
  private SAMoney unspent;                   // TODO: unimplemented
  /**
    * Create an account, with a pool of dollars to budget.
    * Use this constructor to create the master account.
    * Use createSub to create children of this account.
    */
  public
  Account(String name, User owner, String total)
     throws NumberFormatException
  {
     this.name = name;
     this.owner = owner;
     this.total = new SAMoney(Double.valueOf(total).doubleValue());
     this.balance = new SAMoney(Double.valueOf(total).doubleValue());
                                                // N.B. must not be the same object
     this.parent = null;
     this.children = new HashMap();
  }
  // Static that connects to the DB and either returns the top account,
  // or creates it for us.
  public static Account getTopAccount() throws SQLException {
  Account topAccount = null;
  dbConn = DriverManager.getConnection("jdbc:postgresql:budgetPro?user=mschwarz");
12.12   Resources                                                                 291
  if (dbConn != null) {
     // We have a database connection.
  } else {
     // We don't and we must create a top account.
  }
  return topAccount;
  }
  // Simple getter; returns the name.
  public String
  getName() { return name; }
  // Simple getter; returns the total pool of money that this account represents.
  public SAMoney
  getTotal() { return total; }
  // Simple getter; returns the balance.
  public SAMoney
  getBalance() { return balance; }
  // Simple getter; returns the parent account.
  public Account
  getParent() { return parent; }
  // Simple getter; returns the owner of this account, as a User object.
  public User
  getOwner() { return owner; }
  // Census - how many children.
  public int
  size() { return children.size(); }
  /**
    * Get to all the children, via an iterator.
    */
  public Iterator
  getAllSubs()
  {
     return children.values().iterator();
  }
  /**
    * Create a new subaccount (i.e., child)
    * given a name and an amount.
    * The child is connected to the parent, and
    * the parent's balance is reduced by the amount
    * allocated to the child.
    */
292                                     Chapter 12 Analysis and Design: Seeking the Objects
  public Account
  createSub(String name, String amt)
     throws NumberFormatException
  {
     Account acct = new Account(name, owner, amt);
     // Reduce the parent's unallocated funds.
     balance = balance.subtract(acct.getTotal());
     // Connect the accounts to each other.
     acct.parent = this;
     children.put(name, acct);
     return acct;
  } // createSub
  /**
    * Looks up and returns the account with the given name.
    */
  public Account
  getSub(String name)
  {
     return (Account) children.get(name);
  } // getSub
} // class Accoun
         The Umbrello UML modeller is an Open Source tool for creating the various
         UML diagrams. You can find it at http://uml.sourceforge.net/
         index.php. We also recommend their online documentation as a good brief
         introduction to UML and to Umbrello. It can be found from the main Umbrel-
         lo page, or directly at http://docs.kde.org/en/HEAD/kdesdk/umbrello/.
12.13 EXERCISES
           1. Imagine a public library. Carry out the CRC nomination process for a
              system to track library members and the collection. What list of objects
              do you come up with? What abstract classes do you find? Which did you
              discard and why?
           2. Extend the purpose of the library program to include generating mailings
              to members with overdue materials. Did you add classes? Did you add
              methods and/or members? To which classes did you add them?
12.13 Exercises                                                                 293
       Example 12.2 The User class
       package net.multitool.core;
       import net.multitool.util.*;
       import java.util.*;
       public class
       User
       {
         private String name;
         private Account home;           // TODO: implement
         public
         User(String username)
         {
             name = username;
         }
         public String
         toString()
         {
             return name;
         }
       } // class User
         3. A new requirement is added. The system must allow for books, audio
            recordings, and movies to be checked out for different lengths of time.
            Did you add classes? Did you add methods and/or members? To which
            classes did you add them?
     Chapter 13
     JUnit:
     Automating Unit Testing
     Testing may not be your favorite task as a programmer; it probably rates just
     above documentation. Yet here is a tool that has made testing more bearable
     and more productive for many Java developers—and not just because it has
     pretty colors and flashing lights.
13.1 WHAT YOU WILL LEARN
       •  What JUnit is and why it’s getting so much attention.
       •  How some people test before they start coding.
       •  How to install and invoke JUnit.
       •  The major JUnit concepts that you need to understand.
       •  What assertions are available in JUnit.
                                                                               295
296                                                   Chapter 13  JUnit: Automating Unit Testing
 13.2 JUNIT: WHY ALL THE FUSS?
      JUnit is a framework for unit tests. It consists of a handful of classes which you
      can use to build bunches of test cases for testing your application. JUnit also
      comes with three test “runners” for running your tests and reporting the test
      results. So why all the fuss? Why has JUnit been so much in the technical
      forefront the last year or two?
             Start with a straightforward idea, well executed, that can help almost any
      programmer working on any application. Make it something that can be inte-
      grated incrementally into existing projects. Make it robust enough to be used
      for projects starting “from scratch.” Give it a simple but pleasing GUI, and put
      it to work on a few high-profile projects. Give it some good press coverage. And
      you’ve got a winner: You’ve got JUnit. Besides, it really does help you get useful
      work done; it makes writing tests a little less work and a little more enjoyable.
      And working with well-tested code is its own reward—a satisfying experience.
 13.3 DESIGN THEN TEST THEN CODE
      This is the slogan of the test-oriented crowd, and if it sounds a bit impossible,
      it is. It’s hype—it got your attention, and there is a bit of truth to it, but don’t
      take it too literally.
             The approach espoused by the “Testing First” crowd is to start, like all
      good software development efforts, with design. But once you have pieces de-
      signed, move directly into testing. Now you don’t have any code that can be
      tested yet, but you can start writing your tests. Then—although the tests will
      fail, as there is no code to run yet—you can begin keeping score on your
      progress by running these tests as code gets implemented.
             NOTE
             Some people like to tout the use of JUnit as an automated tool to track progress,
             but that’s a little hard to do when you can’t compile your tests because the
             classes they need don’t yet exist. However, if you document your design of a
             class by (among other things) creating an empty version of the source, with
             Javadoc comments for the class and whatever methods you have come up with
             so far, well, then you’ve got something that will compile, and thus can be used
             for tracking progress. It also makes great, tangible documentation. Our point
             here, though, is that you are doing some coding before you begin testing. It’s
             really more of a back-and-forth between coding and testing.
13.4 Installing and Running JUnit                                                    297
              Let’s apply that approach to our previous design discussion. We’ve de-
       scribed an Account class in our design discussion. It needs a name, an owner,
       and an amount of money when created. It should have a method to create
       subaccounts, ones that are connected to this account and get allocated some or
       all of the main account’s money.
              Example 13.1 is the basic structure of our Account class.
              That’s enough to begin writing a test. We have described the constructor,
       with the three parameters that it will need. We’ve also described a method on
       the Account object, one that will create subaccounts. That gives us enough
       information to write a test that will create an account and then create subac-
       counts of that account. We can test to see if the accounts are created properly
       (i.e., are not null) and if the subaccounts use up all the money of the parent
       account.
              When you “test then code,” you begin to use the objects that you have
       designed without getting bogged down in their implementation. You are, in
       effect, describing their external interfaces without implementing them. You are
       also beginning to use the classes as a user might, though a tester’s use is a bit
       different than the way an application might use them. However, as a user of
       these classes you are beginning to test the design, by testing the results of the
       use cases—are these classes really usable?
              You may discover that you need some additional functionality. In our ex-
       ample, we can see from the description of our test that we will need a getter
       method on the account to return the amount of money that remains unallocat-
       ed to subaccounts. Then we can test to see if it gets used up properly.
              There are many more test cases that we could develop for the Account
       class, but let’s use just these for now, so that the size of our test case is
       manageable.
              Our next step is to get JUnit installed before we get too deep into
       developing our test cases. That will give us something to run these tests.
 13.4 INSTALLING AND RUNNING JUNIT
       It’s rather simple to install a standalone version of JUnit. We download a ZIP
       file from the JUnit Web site, then unzip it into a directory. Adding the JUnit
       JAR file to your CLASSPATH is all that’s needed to make JUnit available for you
       to run it.
298                                          Chapter 13 JUnit: Automating Unit Testing
    Example 13.1 The bare bones of our Account class
    package net.multitool.core;
    import net.multitool.util.*;
    import java.util.*;
    /**
      * The basic Account class for our budgeting example; this is the
      * first-cut "implementation" where we have just transferred our
      * design into Java code. We can use this much to generate Javadocs
      * and also to begin our JUnit testing (design, test, code).
      */
    public class
    Account
    {
         private String name;          // a name to identify this account
         private User owner;           // the user assigned to this account
         private SAMoney total;        // total amt allocated to this account
         private HashMap children;     // the collection of subaccounts,
                                       //   by name
         private Account parent;       // it has this account as a child
         /**
           * Create an account, with a pool of dollars to budget.
           * Use this constructor to create the master account.
           * Use "createSub" to create children of this account.
           */
         public
         Account(String name, User owner, String total)
         {
         }
         /**
           * Create a new subaccount (i.e., child), given a name
           * and an amount. The child is connected to the parent.
           */
         public Account
         createSub(String name, String amt)
         {
              return null;         // so it compiles
         } // createChild
    } // class Account
13.4 Installing and Running JUnit                                                                 299
       13.4.1 Downloading and Unzipping
       Point your browser at the site http://www.junit.org/ (Figure 13.1). From
       the main page, choose the Download heading.
              That takes you to a SourceForge site (Figure 13.2); click on one of the
       sites near you, though any will do. The download is only a few hundred
       kilobytes, so it shouldn’t take long.
              You’ll be left with a file named junitX.Y.Z.zip, where the X, Y, Z char-
       acters are the digits that tell you what release of JUnit this is. Our examples
       show the 3.8.1 release.
              NOTE
              It’s a good idea to inspect the ZIP files that you download before you actually
              unzip them. We like to know what files and especially what directories are going
              to get modified or cluttered up by the unzipping. Some ZIP files come with all
              their files inside of a single folder. Those are fine to unzip in place. Other ZIP
              files have been built from lots of pieces and unzipping them can make a mess
              of your current directory, or worse, of other directories that you may not even
              know about. Instead, play it safe and look before you leap. You can see the list
              of all the files in the JUnit ZIP file by typing this command:
              $ unzip -l junit3.8.1.zip
                     The -l option will produce a listing of the contents of the ZIP file. That
              way you can see what subdirectories it will create, that is, if it is going to unpack
              into a single directory or make a mess. The JUnit ZIP file is very well behaved
              in this respect.
       Figure 13.1 The JUnit home page
300                                                Chapter 13    JUnit: Automating Unit Testing
    Figure 13.2 The SourceForge download site
         Create a directory and unpack the JUnit ZIP file in there:
    $ mkdir ~/junit
    $ mv junit3.8.1.zip !$
    $ cd !$
    $ unzip junit3.8.1.zip
         This warning from the installation instructions is worth noting:
         IMPORTANT
         Don’t install the junit.jar into the extention directory of your JDK installation.
         If you do so the test class on the filesystem will not be found.
13.4 Installing and Running JUnit                                                             301
              The JDK installation directory has a subdirectory named jre/lib/ext.
       Don’t put the JUnit JAR file in there. If you have followed our instructions,
       you’re OK, since we had you create a new directory.
              To use JUnit, the junit.jar file needs to be in your classpath. For
       example:
       $ export CLASSPATH="${CLASSPATH}:${HOME}/junit/junit3.8.1/junit.jar"
              That’s all the installing there is. It doesn’t feel like much, because you
       haven’t done much. All it provides is a JAR file that you will use when you want
       to run tests. That’s where it gets interesting.
       13.4.2 Using JUnit
       To test out your installation, cd to the directory where you unpacked JUnit.
       If it isn’t already part of it, add the current directory (“.”) to your CLASSPATH:
       $ export CLASSPATH="${CLASSPATH}:."
              Then try:
       $ java junit.swingui.TestRunner junit.samples.AllTests
              You should see a Java Swing GUI appear, with a green bar showing the
       progress of the testing (Figure 13.3).
              NOTE
              You may see an error message like this in your terminal window:
              (data/time) java.util.prefs.FileSystemPreferences checkLock...
              WARNING: Could not lock System prefs.Unix error code 136742412
              (data/time) java.util.prefs.FileSystemPreferences syncWorld
              WARNING: Couldn't flush system prefs: java.util.prefs.Backi...
                    It will keep repeating as long as JUnit’s GUI is running. The easiest fix is
              to make the jre directory world-writable while you run the GUI the first time. It
              will create the files it needs (in a directory, .systemPrefs), and thereafter
              stop pestering you. Remember to change permissions on the directory back to
              their original value.
302                                            Chapter 13 JUnit: Automating Unit Testing
    Figure 13.3 JUnit Swing GUI running tests
          This is the GUI part of JUnit, part of what has made it so popular. By
    writing JUnit tests, you get to use their GUI. If you were to develop your own
    testing mechanism, you would also have to (re)invent a GUI.
          There is an AWT GUI for the Swing-averse, but it is less featured. There
    is also a plain command-line test case runner:
    $ java junit.textui.TestRunner junit.samples.AllTests
    .........................................
    .........................................
    .....................................
    Time: 3.834
    OK (119 tests)
    $
13.5 Writing Test Cases                                                              303
             It prints a period for each test that it runs. (Yes, there are 119 periods
      there. Go ahead; count them if you must.) The command-line version is useful
      for incorporating JUnit tests into shell scripts (e.g., for testing nightly builds,
      e-mailing the results) and is used by ant when it invokes JUnit.
 13.5 WRITING TEST CASES
      Writing a test case for your own Java code consists, at its simplest, of writing a
      new class for each class that you want to test. But this class that you create is
      built in a special way so that the test harness of JUnit can execute it. That is,
      the test case class that you create should meet certain naming conventions, so
      that the JUnit test runners can find what they need in order to run your tests.
             More specifically, your test cases will extend the JUnit class TestCase.
      Now, TestCase is an abstract class, meaning there are parts that you have to
      fill in (i.e., methods that you must write) to make it a working class. Moreover,
      TestCase implements (in the Java sense of the word) the Test interface. Can
      you begin to see how the TestCase class is a framework? It defines the rough
      outline of how the test cases will look so that a common test runner can run
      any test case, no matter who wrote it.
             Let’s look at a simple example, to see what such a test case looks like.
      Example 13.2 shows one for testing our Account class.
      Example 13.2 Simple test case
      package net.multitool.core;
      import java.util.*;                    // needed by our class
      import net.multitool.util.*;           // needed by our class
      import junit.framework.*;              // needed by JUnit
      /**
         * for JUnit testing of Account.java
         */
      public class
      AccountTest
          extends TestCase
      {
          // our test instrumentation:
          Account base;
304                                         Chapter 13  JUnit: Automating Unit Testing
       // run before each test case:
       protected void
       setUp()
       {
         base = new Account("Base", new User("testuser"), "150");
       }
       // our one test case
       public void
       testCreateSub()
       {
         // Create a subaccount, assigning $50 of our pool of $150.
         Account sub1 = base.createSub("sub1", "50");
         // Make sure that it created something.
         assertNotNull("Couldn't create sub1", sub1);
         // Now a 2nd subaccount.
         Account sub2 = base.createSub("sub2", "75");
         assertNotNull("Couldn't create sub2", sub2);
         // Now a 3rd subaccount, to use up all the $.
         Account sub3 = base.createSub("sub3", "25");
         assertNotNull("Couldn't create sub3", sub3);
         // We should have the same total that we started with.
         assertEquals(150, base.getTotal().getDollars());
         // We should have used up all our $.
         assertEquals(0, base.getBalance().getDollars());
         // Be sure the (sub)account lookup works:
         Account ex2 = base.getSub("sub2");
         assertNotNull("Couldn't find sub2", ex2);
         assertSame(sub2, ex2);
       } // testCreateSub
    } // class AccountTest
         Notice how we’ve named our test case class. We take the name of the class
    and append Test to the end. This is convenient for us—we can easily see which
    classes have test cases; but more importantly, JUnit can use this and other
    naming conventions to derive the test case names (more on that later). Notice
    also that the method in the Account class that we want to test, called
    createSub(), gets exercised by a method named testCreateSub()—we
13.5 Writing Test Cases                                                               305
      Table 13.1 JUnit Naming
                         In your original code       In your test case
        Class            MyClass                     MyClassTest
        Method           myMethod                    testMyMethod
      prepend the word “test” to the method name, and capitalize the now-no-longer-
      first letter. Again, JUnit will use this naming convention, along with
      introspection, to automatically derive the test names from the actual method
      names (more on that later, too). The naming conventions we’ve seen so far are
      summarized in Table 13.1.
             Let’s take a quick look at the code. We import the framework for JUnit
      test cases, so that the compiler can resolve the names that deal with JUnit stuff.
      The TestCase class that we extend is part of that JUnit stuff. It’s an abstract
      class that defines much of what we use for testing. We just fill in what we need.
             The TestCase class defines a method called setUp(). The setUp()
      method is called not just once, but before every test method is called. That way
      you can initialize variables and get into a known state before each test. Since
      it’s already defined in the TestCase class, we can override it (as in our example)
      to do what we want, or we can not include it in our class and get the default
      behavior from TestCase (which is to do nothing).
             There is also a method named tearDown() which you can override if you
      need to close things up at the end of a test case (e.g., close a database connec-
      tion). As with setUp(), its default behavior, as defined in TestCase, is to do
      nothing.
             The test case itself—the method where we will exercise our class—is called
      testCreateSub (since we want to test our createSub() method). Inside such
      a method (and we could have more than one) we write code which uses the
      objects in our application. Then at various junctures in the code we make asser-
      tions about the state of things—for example, this variable should be non-null,
      or this expression should have this particular value.
             Those assertions are, to our way of thinking, the tests. We’re testing to see
      if the subaccount was created, or if the main account did, indeed, use up all of
      its dollars in allocation to the subaccounts. But they are not what is called tests
      by JUnit. Rather, each individual method in a test class is considered a single
      test. Such test methods are, typically, a collection of assertions surrounding the
      use of a single (application) method. So in our example, the method
306                                               Chapter 13  JUnit: Automating Unit Testing
    testCreateSub() is a single JUnit test which asserts various conditions about
    various invocations of the createSub() method. Note that all of the assertions
    encountered in the execution of the test class must pass for the test to pass.
          So what happens if an assertion fails? The assert method will throw an ex-
    ception, reporting the failure. In JUnit terminology, a failure is a test that didn’t
    pass, whereas an error is a problem with the running of the test. A missing class
    or a null pointer exception are errors, whereas an assertNotNull() call failing
    is considered a test failure.
          The handy thing about the exceptions that the assert methods throw is
    that they are, technically speaking, not java.lang.Exception throwables but
    rather belong to the java.lang.Error type of throwable. (Don’t confuse this
    technical Java use of the word “error” with our more informal use in the previ-
    ous discussion of failure versus error.) To quote from the Javadoc page for
    java.lang.Error:
          A method is not required to declare in its throws clause any subclasses of
          Error that might be thrown during the execution of the method but not
          caught, since these errors are abnormal conditions that should never occur.
          So the use of Error by JUnit’s various assert methods is done simply as a
    convenience for us test developers, so that we don’t have to put throws ...
    clauses on all of our method declarations.
    13.5.1 JUnit Assertions
    These are the various test assertions available with JUnit:
       • assertEquals(), comparing
            • boolean with boolean
            • char with char
            • short with short
            • int with int
            • long with long
            • float with float
            • double with double
            • Object with Object
            • String with String
13.5 Writing Test Cases                                                                            307
           • assertTrue( boolean expression )
           • assertFalse( boolean expression )
           • assertNull (Object)
           • assertNotNull (Object)
           • assertSame (Object1, Object2)
           • assertNotSame (Object1, Object2)
           • fail()
             Each of the assert methods comes in two “flavors,” one with a message
      String and one without. For example, there is a method assertTrue() which
      takes a boolean as its parameter; typically it would be used with an expression,
      for example:1
      assertTrue( (sample           actual) );
             If the condition is not true, an AssertionFailedError is thrown. That
      means, among other things, that if/when your test fails, it will stop executing
      at that point. The tearDown() method, though, will still be executed before
      proceeding to the next test.
             There is also a method of the same name, assertTrue(), but with a
      slightly different signature—it adds a String as its first parameter. The string
      is the message to be included in the error report. Using this variation on
      assertTrue(), our example would become:
      assertTrue("Sample too small", (sample                   actual));
             In    the      same      way, assertFalse() has two versions—
      assertFalse(boolean)              and assertFalse(String, boolean)—and so
      on for all other assert methods.
      1. Yes, the extra parentheses are not needed; they just make the point that this is a boolean ex-
      pression being passed as the argument to assertTrue(). We could also have written it as:
      boolean result = (sample           actual);
      assertTrue(result);
      Again, the extra parentheses are used just to make it clearer.
308                                               Chapter 13   JUnit: Automating Unit Testing
          The String message is very helpful when you get large numbers of com-
    parisons and assertions inside your test cases. It can help you identify which
    assert in which test failed.
          TIP
          When writing your assertions, keep in mind the difference between
          assertEquals() and assertSame(). The latter will test if the two argu-
          ments refer to the very same instance of an object, whereas the former only
          checks to see that their values are equal. So any two references to objects that
          are the same will also be equal, but not vice versa. For example:
          String sample = "value";
          String others = "more value".substring(5);
          assertEquals(sample, others);            // will pass
          assertSame(sample, others);              // will fail
          Digging a little deeper into how all this works, it might be worth pointing
    out that the JUnit TestCase class, while an abstract class itself, is also an exten-
    sion of another class, the Assert class. The Assert class is the class that defines
    all these public static methods for asserting the various conditions (see the list
    above). That is why you don’t need any qualifiers on the various assert calls.
    They are all part of your test case by virtue of it extending TestCase. It also
    means that you could override any of them to get special behavior. This might
    be useful for assertEquals(Object, Object), to allow you to compare
    objects of your own kinds, but we don’t recommend this. You are better off
    overriding the equals() method of your own object than messing with the
    JUnit methods. And remember that if you override those behaviors, your tests
    will only be as good as your implementation of the assert mechanisms.
    13.5.2 Running a Test Case
    Recall how we ran the JUnit self-tests after installation. We can now use a
    similar command to execute our own test case. With the CLASSPATH still set
    as above, try compiling and running the test case:
    $ javac net/multitool/core/AccountTest.java
    $ java junit.textui.TestRunner net.multitool.core.AccountTest
13.6 Running Test Suites                                                               309
             The TestRunner will use introspection and reflection to dig information
       out of the AccountTest class. It will find all the public methods that begin
       with test and have no parameters. It will execute setUp(), then one of the
       test methods, then tearDown(); then setUp(), then another test method,
       then tearDown(), and so on. Our example has only one test method,
       testCreateSub(), so that will be the one test method it runs.
             The result of running the test should look like this:
       $ java junit.textui.TestRunner net.multitool.core.AccountTest
       .
       Time: 0.071
       OK (1 test)
       $
 13.6 RUNNING TEST SUITES
       Quite likely, you’ll want to run several tests, exercising the various classes that
       make up your application. Let’s see an example of how to build such a suite of
       tests (Example 13.3).
             While not defined as an interface, the convention is used by JUnit
       TestRunner classes that they will look for a public static method called
       suite() in any class that you ask a TestRunner to run. Your class, the one
       that will define the suite of tests, should return something that implements the
       Test interface. A TestSuite object is one such object, and we can fill it with
       tests gleaned automatically by JUnit from the class names that we supply.
             We’ve also added a main() that invokes the text-based user interface for
       running these tests. That way you can invoke the tests from the command line
       if you like.
             Here are the two commands to compile and execute the CoreTest suite,
       using the Swing GUI:
       $ javac test/net/multitool/core/CoreTest.java
       $ java junit.swingui.TestRunner net.multitool.core.CoreTest
             When the GUI runs, click on the Hierarchy tab and you can see the vari-
       ous tests that make up the suite. Opening the folders will show the tests inside
       of suites (Figure 13.4).
310                                      Chapter 13 JUnit: Automating Unit Testing
    Example 13.3 A suite of test cases
    package net.multitool.core;
    import junit.framework.*;
    public class
    CoreTest
    extends TestCase
    {
      public
      CoreTest(String str)
      {
         super(str);
      } // constructor CoreTest
      /**
        * Constructs a collection of tests to be run by the TestRunner.
        */
      public static Test
      suite()
      {
         /*
           * Add the results of each separate Test into a big Suite.
           */
         TestSuite suite = new TestSuite("Core Classes");
         suite.addTestSuite(net.multitool.util.SAMoneyTest.class);
         suite.addTestSuite(AccountTest.class);
         suite.addTestSuite(UserTest.class);
         return suite;
      } // suite
      public static void
      main(String [] args)
      {
         junit.textui.TestRunner.run(suite());
      } // main
    } // class CoreTest
13.6 Running Test Suites                                                               311
       Figure 13.4 The CoreTest running a suite of tests
             One last example is the SAMoneyTest.java file that was used in the
       CoreTest example (Figure 13.4). Did you notice the names displayed in the
       test hierarchy? They don’t match the method names used to run the tests in
       SAMoneyTest.java because we constructed the suite “by hand” instead of
       letting the JUnit introspection and reflection find the methods dynamically.
             Such manual approach has some advantages. You can restrict the current
       set of tests being executed to a subset of the entire set of tests. You can also, as
       this example shows, give other names to the tests. The biggest drawback,
       though, is the maintenance cost of having to add the test by hand to the
       suite() method whenever you add another test method.
312                                                Chapter 13 JUnit: Automating Unit Testing
 13.7 REVIEW
      We have shown you how to download JUnit and get it running. We have dis-
      cussed creating a test case and creating a suite of tests. We’ve looked at the
      Swing GUI for JUnit but also at the command-line interface. We have shown
      how our design translates to a minimal code implementation from which we
      can begin testing. We’ve discussed the “design, test, then code” approach, and
      how you can use it to track the progress of your implementation.
 13.8 WHAT YOU STILL DON’T KNOW
      JUnit can be invoked from ant. It is an optional task (not part of the standard
      ant release), but easy to install and get running. Both the junit.jar and ant’s
      optional tasks JAR file need to be in your classpath. That’s all it takes. See
      http://ant.apache.org/manual/OptionalTasks/junit.html for more
      details.
            JUnit integrates well with Eclipse and other IDEs. It is easy to install and
      very easy to use when it’s part of your IDE. For whichever IDE you choose,
      get the JUnit plug-in for it and use it.
            One area we haven’t yet discussed is how to do unit testing for the GUI
      portion of your application. The basic idea is the same. In order to manipulate
      your GUI from the test, you may want to investigate the java.awt.Robot
      class. It can be used to generate system input events such as mouse and
      keyboard actions.
            In fact, we’ve only begun to describe the various ways that JUnit can be
      used for all kinds of testing. Our focus has been on unit tests during code devel-
      opment, but JUnit can also be applied to integration and release testing. With
      any large Java application, it is crucial to have a good set of regression tests that
      can be rerun after features or fixes are added, or after classes have been
      refactored. JUnit has proven to be very valuable in these situations.
            Finally, remember that JUnit is only a tool. The GIGO law2 tells us not
      to expect great tests just because we know how to run a tool. Test design, like
      any good design skill, is art as well as science. Learning the art of testing will
      pay dividends in better code built faster.
      2. Garbage In, Garbage Out.
13.10 Exercises                                                                         313
 13.9 RESOURCES
       Visit http://www.junit.org/ for all things JUnit-y, including some docu-
       mentation (though it’s not the greatest) and scores of articles which provide
       tons of useful information.
             A very good article on JUnit appeared in the May/June 2003 issue of
       Oracle magazine (online at http://otn.oracle.com/oraclemagazine),
       titled “A JUnit Step-by-Step,” by Michel Casabianca.
             For more about software testing in general, there is a classic (that is, from
       early days of computing) book on the subject: Glenford J. Myers, The Art of
       Software Testing, Wiley, New York, 1979.
             You may also want to check out Just Enough Software Test Automation by
       Daniel J. Mosley and Bruce A. Posey (ISBN 0-13-008468-9, 2002). Their
       Web site3 includes a bibliography of nearly hundred articles and books on
       client-server and other software testing topics.
13.10 EXERCISES
       How many other tests can you think up to add to the AccountTest class? Did
       you include checks for bad behavior—for example, attempting to make too
       many subaccounts? Add the new asserts and rerun the test.
       3. http://www.csst-technologies.com/csstbibl.htm
     Chapter 14
     Storing the Data
     In this chapter we will very briefly introduce three database products that run
     on the Linux platform and will support our sample applications. We will also
     select one of the three and explain how to set up our database tables.
14.1 WHAT YOU WILL LEARN
     In this chapter you will learn a little bit about database server products available
     for Linux, including both commercial and Free or Open Source products. We
     will briefly discuss some factors that might enter into choosing one over the
     other. We will then describe how one might design tables to back our applica-
     tion, and how to create and implement those tables in two Open Source
     databases: MySQL and PostgreSQL.
                                                                                      315
316                                                           Chapter 14   Storing the Data
 14.2 FOLLOW THE OBJECTS
      One of the consequences of a good object design is a relatively simple database
      design. For the most part, each class will end up as a database table where each
      row represents an instance of that class. Beyond that, all that is needed are those
      tables required to represent relationships between objects.
            In this chapter we will show you examples of these relationships, and we
      will do so in a manner that should easily port to any SQL relational database.
 14.3 OF PERSISTENCE
      Programs cannot be assured of running forever. Virtually all computer main
      memory (i.e., RAM) is volatile, meaning that if the power is removed, the data
      is lost. Since computers are sometimes rebooted, and since the power sometimes
      goes out, we obviously need some place besides memory to store our class in-
      stances. We need persistent (nonvolatile) storage. This can be as simple as
      streaming our classes out to flat file, or it can be as complex as a clustered multi-
      user database. We will discuss the selection criteria and how you might choose
      your persistent storage strategy.
 14.4 THINKING OF THE FUTURE, OR PAINTING IN CORNERS
      It is important that you try, in your class design, to avoid making the persis-
      tence system dependent on a particular storage method or product. If you do
      this, you can switch storage products or solutions relatively easily.
 14.5 ORACLE, POSTGRESQL, MYSQL
      One of the first major decisions you must make is what to use as a database
      server. On Linux systems, you have both Free Software and commercial soft-
      ware options. As we have said before, we will tend to focus on Free Software
      in this text, but we cannot ignore the most popular database software package
      out there, which is, of course, Oracle.
            Let’s take a quick look at each of the “big 3” database choices on Linux
      platforms.
14.5 Oracle, PostgreSQL, MySQL                                                        317
       14.5.1 MySQL
       MySQL is a very fast but somewhat limited SQL database system. It is wildly
       popular mainly because it is simple, fast, and Free. It is everything that you
       would need to back a dynamic Web site. As of this writing, the stable produc-
       tion version of MySQL is 4.0.16, but most Linux distributions are still shipping
       something from the 3.23.x series.
             At this point, MySQL lacks some key features:
          • Stored procedures
          • Sub-SELECTs
          • Triggers
             Version 4.0.x does support some long-awaited features (if you use the
       InnoDB table type instead of the default MyISAM tables), such as row-level
       locking, foreign keys, and transactions. But InnoDB tables are not directly
       available in the 3.23.x versions still shipping with many distributions.
             MySQL is an excellent choice for designs that do not require stored proce-
       dures, triggers, or transactions. It is widely used as a back end for dynamic Web
       sites—applications with many reading users and few writing users.
             For more information on MySQL, see Core MySQL by Leon Atkinson
       (ISBN 0-13-066190-2).
       14.5.2 PostgreSQL
       PostgreSQL is a surprisingly complete and full-featured database offering.
             Not only does it fully support stored procedures, triggers, views, foreign
       keys, and transactions, but it also implements an innovative “record versioning”
       system for multiuser integrity. Unlike many other databases, readers may con-
       tinue to read consistent data during writing activity (nonblocking revisions), and
       backups may be taken while the database is still available for queries. This is a
       serious database.
             This database has excellent public documentation. Take a look at the
       PostgreSQL Documentation.1 Another useful book is PostgreSQL by Korry and
       Susan Douglas (ISBN 0-7357-1257-3).
       1. http://www.postgresql.org/docs/current/static/index.html
318                                                           Chapter 14  Storing the Data
      14.5.3 Oracle
      What can we say? In the world of databases, this is the top dog. This is the
      standard against which other database systems are measured. Oracle is the DB
      that runs the “big applications” out there in the enterprise world. It is also a
      costly piece of software when it is used for production applications. It is, how-
      ever, available for free download to use for development. It is emphatically not
      Free Software. You don’t have the source code. You don’t have the right to
      modify it, and you don’t have the right to pass it on to third parties. That may
      or may not be an issue for you.
            If you need advanced features like high-availability clustering, it is certain
      that Oracle will work for you. You may download it for evaluation and
      development from Oracle’s OTN (Oracle Technology Network)2 Web site.
      14.5.4 Selection Criteria
      For the simple application we are developing, all of these databases are suffi-
      cient. But in the real world, there could be many factors that might come to
      bear upon your selection of a database server product. These factors might
      include:
         •  Price
         •  License terms
         •  Transaction capacity (speed)
         •  Integration (does it work with or depend on other software you use?)
         •  Human resources (do you have operators and developers familiar with the
            product on your staff, or are they available for hire?)
         • Presence (does your organization already use this product?)
         • Features (do you have future plans that might require a particular
            product?)
 14.6 BEING SELF-CONTAINED
      One of the common difficulties with software that requires a database is how
      to get the database structures up and running. Database storage is often not in
      2. http://otn.oracle.com/software/products/oracle9i/htdocs/othersoft.html
14.7 Beyond the Basics                                                                 319
       files, and even when it is in files on the filesystem, you cannot, when you install
       a package like BudgetPro, simply put your database files in place, since there
       are probably other applications that have their tables in those files, and replacing
       them with yours would destroy that data.
             Often, the table creation statements and any initial table rows required are
       placed in a SQL file and that file is run against the database. Meanwhile, all of
       the database code that performs application interactions is either in the applica-
       tion code or in stored procedures called by the application code. But there is
       no fundamental reason to make this distinction. The application can see to it
       that its database and tables are created.
             Of course, you can automate this setup with a shell script, but Java is
       supposed to be cross-platform. Of course, you can write a batch file for Win-
       dows and a shell script for UNIX, but if you just put this setup into your Java
       code, you don’t have to maintain and test separate installation procedures. One
       of the areas where Java applications tend to lag behind other applications is in
       installation and setup. You can obviate this somewhat by including database
       setup in your Java code, thus eliminating the need to write platform-specific
       scripts.
             Consider including your database and table creation statements directly
       in your Java code, even if it is in a singleton setup class that only runs once.
             The basic tables should parallel the objects. So, for our classes, the SQL
       statements to build the tables might look as shown in Example 14.1.
             For the moment, we are confining our table declarations to a form that
       should work with both Open Source databases.
             These are very basic definitions. We will be talking about issues like gener-
       ating unique IDs for records as we develop the code to back these. Different
       database products have different “best” solutions, which will make the support
       for multiple databases more problematic.
 14.7 BEYOND THE BASICS
       We are going to adopt a very simple strategy for database persistence. We are
       going to read in the data structures at startup and maintain them as changes
       are made during execution. That way, any abnormal termination will leave the
       data in a recoverable state. The application will not require any “save”
       operation.
320                                                                 Chapter 14     Storing the Data
    Example 14.1 Candidate DB tables for BudgetPro
    DROP DATABASE budgetPro;
    CREATE DATABASE budgetPro;
    USE DATABASE budgetPro;
    CREATE TABLE Account (
       id INTEGER NOT NULL,
       name VARCHAR(64) NOT NULL,
       user_id INTEGER NOT NULL,
       amount DECIMAL,
       balance DECIMAL,
       parent_account_id INTEGER,
       PRIMARY KEY (id),
       FOREIGN KEY (user_id) REFERENCES User(id)
    );
    CREATE TABLE User (
       id INTEGER NOT NULL,
       name VARCHAR(64),
       PRIMARY KEY (id)
    );
          We will implement this in the simplest way possible, by directly embedded
    SQL statements in the application code. But this is far from your only choice.
          It is possible to design a “persistence framework,” such that all classes that
    inherit from a persistence base class or implement a persistence interface and
    follow certain naming conventions for member data can be automatically
    backed by persistent storage. Java’s ability to introspect, that is, to look at the
    names and structures of a class dynamically at runtime, allow one to write such
    an automatic persistence framework. Several such libraries already exist, includ-
    ing both commercial and Open Source options. This being an Open Source
    book, we’ll call you attention to the Open Source choices:3
    3. Have we tried all of these? Yeah. Sure. Why not? Of course we haven’t. Don’t read endorse-
    ment into this or any of our “here are some choices” lists. These are also not presented in any
    particular order. We tell you they exist. It is up to you to evaluate their suitability for your
    purposes.
14.7 Beyond the Basics                                                                321
       Hibernate4
             Hibernate is probably the most widely known Open Source persistence
             framework. It is released under the LGPL license.
       OJB5
             Billed as “Object Relational Bridge,” this one is from Apache. It provides
             both an ODMG (a persistence API much used in the C++ world) and a
             JDO (Java Data Objects—Sun’s object persistence API specification) API.
       Castor6
             Castor does persistence to both XML and relational databases. They call
             their RDBMS persistence framework “JDO,” but beware: It is not compat-
             ible with or identical to Sun’s JDO. They say it is better.
       pBeans7
             pBeans does fully automated persistence of JavaBeans. You have to follow
             the rules for writing beans (not EJBs, but the “classic” JavaBeans), but
             once done, this will automatically persist your instances to any JDBC-
             compatible database. No XML specification, no SQL scripting, no tem-
             plates. For the easiest “just save my instance data” type of applications,
             this can be a good choice.8 This product even automates the creation of
             tables, as we advocated above.
             Are there others? Heck, yes. Not all of them persist to relational databases.
       Some persist only to XML. Some to other databases like B-trees or the Berkeley
       DB system. We didn’t concern ourselves with those. We also left off a couple
       of libraries that appear not to have been developed for more than a couple
       of years.
       4. http://www.hibernate.org/
       5. http://db.apache.org/ojb/
       6. http://castor.exolab.org/
       7. http://pbeans.sourceforge.net/
       8. But we are not endorsing here.
322                                                                  Chapter 14     Storing the Data
 14.8 PERSISTENCE IS NOT THE WHOLE STORY
      In this chapter and throughout this book we take a practical view that a
      database is there to store an application’s data. That’s far from the intent. A
      relational database is designed to create collections of data and to perform logi-
      cal queries within and between those collections. The relational model is much
      more than application storage. It facilitates all kinds of data analysis. This is
      often ignored in enterprises these days.
             Don’t forget that designing database tables should take into account
      concerns beyond mere application storage.
 14.9 SETTING UP POSTGRESQL FOR BUDGETPRO
      Let’s turn our attention to installing and starting PostgreSQL to support the
      BudgetPro application.
      14.9.1 Installing PostgreSQL
      The simplest way to install PostgreSQL is to use precompiled binary packages.
      RedHat and Fedora have RPM packages for installing the database and client
      software (although neither distributes the client libraries for Java due to licens-
      ing issues with Java itself). The PostgreSQL project produces RPM packages
      of their own, including the Java JDBC class library. Those might be your easiest
      course. Debian packages for PostgreSQL exist, but again, they do not provide
      the JDBC library.
             For our purposes, we are going to assume that you have downloaded and
      installed the following RPM packages9 from the PostgreSQL Download page:10
         •   postgresql-server
         •   postgresql-devel
         •   postgresql-jdbc
         •   postgresql-docs          (optional)
      9. If you are a user of Debian or another Debian-based Linux distribution, you should be aware
      that there is a Debian package called alien, which can install and manage RPM packages on
      a Debian system.
      10. http://www.postgresql.org/mirrors-ftp.html
14.9 Setting Up PostgreSQL for BudgetPro                                                           323
       14.9.2 Creating a postgres User
       More than likely, installing a PostgreSQL package will create a new Linux user
       called postgres on your system. This is not a login account; it will be used by
       the database server process daemon11 (called “postmaster,” lest you think that
       it might be an e-mail server or something). Furthermore, only the postgres
       user is able to create additional database users or any databases.
              Obviously, we won’t want it to be like this forever. It has the same prob-
       lem as the root user on the OS itself: There’s one magic user with all the
       power. You’ll need to create additional users and you’ll want to limit what they
       can do. How to do it?
              First off, you can’t log in as postgres, so you will have to become root
       and then su to the postgres user:
       [mschwarz@cassidy mschwarz]$ su -
       Password:
       [root@cassidy root]# su - postgres
       -bash-2.05b$
              Note that postgres didn’t have any profile or rc script to set up prompts
       or anything.
              All PostgreSQL databases have owning users, in much the same way that
       all Linux files have owning users. But PostgreSQL users are not necessarily the
       same as Linux users.12 The only PostgreSQL user that exists “out of the box”
       is postgres. You must use the createuser command-line utility (or the
       equivalent SQL) to create a user. Here’s an example:
       11. Historically, daemon processes on UNIX systems used to be run as root. But a program
       error in a daemon would allow a malicious user to execute code as the owner of the process. If
       that owner is root, one programming mistake in a server process could give an attacker total
       control of the system. Beware of any daemon process that runs as root. Nowadays, these run
       as either a totally nonpriviledged user such as nobody, or, if they really need to write files or
       some such thing, as a catch-all user like daemon. The database is an important process and it
       needs its own security, so it runs as its own user, postgres.
       12. For most PostgreSQL command-line utilities, if no PostgreSQL username is specified, the
       current Linux username will be used. This is often a convenient choice, but you might have
       compelling reasons not to do this.
324                                                          Chapter 14    Storing the Data
    -bash-2.05b$ createuser mschwarz
    Shall the new user be allowed to create databases? (y/n) y
    Shall the new user be allowed to create more new users? (y/n) y
    CREATE USER
    -bash-2.05b$
         Here, we created the PostgreSQL user mschwarz and gave him the ability
    to create databases and new users.
    14.9.3 Creating Our Database
    Now that our username, mschwarz, has been created and is authorized to create
    databases, we use the createdb command to create our database:
    [mschwarz@cassidy mschwarz]$ createdb budgetPro
    CREATE DATABASE
         Notice that we did this as the Linux user mschwarz, so the createdb
    command used that username when it created the budgetPro database. What
    would have happened if we had used a Linux user that did not have a matching
    PostgreSQL user? Let’s see:
    [albing@cassidy albing]$ createdb budgetPro
    createdb: could not connect to database template1: \
    FATAL: user "albing" does not exist
         WARNING
         Note that we have not implemented any security yet. The user mschwarz ex-
         ists, but it does not have a password. Depending on how PostgreSQL security
         is configured, it may be possible for any user to use the -U option with the
         PostgreSQL command-line utilities to impersonate mschwarz. As packaged
         for Fedora Core 2, PostgreSQL uses ident to check authentication, so when
         albing attempts this, he gets this error:
         [albing@cassidy albing]$ createdb -U mschwarz budgetPro
         createdb: could not connect to database template1: \
         FATAL: IDENT authentication failed for user "mschwarz"
                Just remember that this behavior is dependent on the local configuration
         of PostgreSQL. You cannot assume this security is in place just because you
         are in a PostgreSQL environment. Always be aware of the security configuration
         of your production environment!
14.10 Review                                                                          325
       14.9.4 Straight JDBC
       Our application is quite simple. We’re going to directly integrate database
       access by simply calling the JDBC interface at startup and making use of that
       connection again and again for data changes.
            Our solution is more than sufficient for the standalone command-line and
       GUI versions of the application, but it will be left as an exercise for the reader
       to implement a better solution for the EJB implementation.
            What will be lacking? Well, the solution we will implement here will get
       a single database connection and use it throughout the life of the application.
       It will be assumed that a single thread is accessing the database. These are all
       bad assumptions for a multiuser and multithreaded environment such as an
       application server.
       14.9.4.1 Static Account Members
       Most of the database code is in the Account class. It consists of a static method,
       getTopAccount(), which will establish a static connection to the database,
       create the Account table if need be, and load the top level account (defined as
       the account record with a null parent) if present or create it if not present.
            The username is passed in as an argument. The username must exist in
       the User table. If it does not, an exception is thrown.
       14.9.4.2 Joining the User
       Two static methods are added that take a JDBC Connection and a String as
       arguments. They are getUserIdByName() and getUserByName(). The
       String is the username to look for. The first method returns the id column
       for that user. It returns zero (0) if the user doesn’t exist. The other returns a
       User object, or null if the user doesn’t exist.
14.10 REVIEW
       We briefly examined choices of Open Source SQL database servers. We
       described how to set up PostgreSQL.
326                                                             Chapter 14  Storing the Data
14.11 WHAT YOU STILL DON’T KNOW
      This is another chapter that represents a mere gloss of its topic. Visit your local
      book megamart and just count the number of books on Oracle, MySQL, and
      PostgreSQL. Database servers and relational database design are very large
      topics indeed. We have hardly scratched the surface. Our goal here has been
      merely to give you enough to get started. If you plan to use one of these prod-
      ucts, definitely take the time to download and read the official product docu-
      mentation (for both MySQL and PostgreSQL it is actually quite good), and
      then take your time looking for after-market books that seem to meet
      your needs.
14.12 RESOURCES
      By no means have we read all the titles available on this topic, but we have read
      and can recommend:
         • Leon Atkinson, Core MySQL, ISBN 0-13-066190-2.
         • Paul DuBois, MySQL, ISBN 0-7357-0921-1.
         • Korry Douglas and Susan Douglas, PostgreSQL, ISBN 0-7357-1257-3.
14.13 EXERCISES
      Is this database fully normalized?13 If not, what would need to be done to
      normalize it? What reasons might exist for not fully normalizing a database?
      13. “Normalization” is a process of eliminating database redundancy and of theoretical
      optimization of the data model. A decent introduction to the concepts may be found at
      http://dev.mysql.com/tech-resources/articles/intro-to-normalization.html.
     Chapter 15
     Accessing the Data:
     An Introduction to JDBC
     Java provides a back-end-independent interface to databases called Java
     DataBase Connectivity classes, or JDBC. We introduce the basics of the system
     here, and illustrate portability that makes it possible for our application to
     switch between two different database back ends.
15.1 WHAT YOU WILL LEARN
     We will cover the basics of interaction with a database in Java. This involves
        • Establishing and tearing down connections to a database
        • Querying data in the database and reading the results
        • Performing other database operations that modify data, but do not return
          data results
          We assume that you are familiar with simple SQL constructs.
                                                                                 327
328                                 Chapter 15    Accessing the Data: An Introduction to JDBC
 15.2 INTRODUCING JDBC
      For many real-world applications, there are copious amounts of data associated
      with them. Programmers first learn to store data into files, but serious applica-
      tions require a database. Java programs can connect to and query a database
      with the help of several Java classes which together make up the Java DataBase
      Connectivity API, or JDBC.
           With JDBC, your Java programs will be able to connect to databases any-
      where on the network and to query data from the database with the simple
      syntax that database programmers have been using for years—SQL.
           JDBC provides an abstraction, a way to talk about the various aspects of
      working with a database which is largely vendor-independent. Implementations
      of JDBC can be, and are, built for many different databases and even other
      data sources, such as flat files and spreadsheets.
           The Linux environment offers several choices of databases, the two most
      popular being MySQL and PostgreSQL. Both are Open Source projects avail-
      able with most major Linux distributions, as well as online for downloading.
      For many Java and Linux developers, however, the use of Java and Linux will
      include their development environment and the servers to which they deploy
      their applications, but the database to which they connect will still be the cor-
      porate database. For most commercial applications this is an Oracle database,
      the industry leader, and due to its major presence in the marketplace we will
      use Oracle in our examples as well.
           NOTE
           JDBC interfaces are available for almost any commercial database with any
           significant marketshare. See Section 15.9 for a URL that has a list of such
           choices. Most of what you will learn in this chapter will apply regardless of the
           database you connect to.
           To make even the most basic use of JDBC, you must understand three
      basic operations:
         • First, establishing and tearing down connections to your database server
         • Second, querying data
         • Finally, reading up the results of that query
15.3 Making Connections                                                            329
            These three operations correspond to JDBC objects for doing these very
      things, namely the classes Connection, PreparedStatement, and ResultSet.
            Let’s jump right in and look at some code. Example 15.1 will make a
      connection to a MySQL database, prepare a query statement, execute the query,
      then read up the results.
            Let’s also look at a similar example, but this time for an Oracle database
      (Example 15.2). Notice how much is the same between the two examples, and
      which parts are different.
            The only real difference between the two programs has to do with the
      connections. Once the connection to the database is established, the rest of the
      code is exactly the same—which is what you’d hope for in an abstraction. This
      is a good news for developers: “Learn once, use anywhere.”
 15.3 MAKING CONNECTIONS
      The most complicated part of JDBC is establishing the connection. There are
      several ways to make a connection, depending on how much information about
      the connection driver you want hard-coded into your application. We are going
      to keep it simple and describe one straightforward way to connect.
            The DriverManager class is where our application goes to get its
      connection to the database, as shown in our example. Many different JDBC
      drivers can register with the DriverManager, and it can make the
      connection to the kind of driver that you want based on the URL that you
      provide in the call to getConnection(). So where did our example register
      anything with the DriverManager? Well, it happened indirectly, via the
      Class.forName(...).newInstance(); call. That loaded the class and cre-
      ated an instance of it. The JDBC specification says that when a Driver class
      initializes it must register with the DriverManager. So it happened “under the
      covers,” in loading the driver class.
            Another difference between the two examples deals with how the username
      and password are supplied to the database. Both are supplied in the URL,
      though in different syntax. That syntax is at the discretion of those who imple-
      mented the JDBC driver for that particular flavor of database. If we were to
      construct the URL at runtime, so that the user could supply a username and
      password dynamically, we’d want to remove the difference in how the URL is
      constructed. To do that we could use a call to getConnection() with a signa-
      ture that includes the username and password as separate String parameters:
330                             Chapter 15   Accessing the Data: An Introduction to JDBC
    Example 15.1 Simple sample program using JDBC for MySQL
    import java.sql.*;
    public class
    MyCon
    {
      public static void
      main(String [] args)
      {
        try {
          // A simple connection example looks like this:
          Class.forName("com.mysql.jdbc.Driver").newInstance();
          String url = "jdbc:mysql://host.domain.com/test"+
                          "?user=blah&password=blah";
          Connection conn = DriverManager.getConnection(url);
          // query
          String mySQL = "SELECT id, pw FROM Users WHERE name = ?";
          PreparedStatement stmt = conn.prepareStatement(mySQL);
          stmt.setString(1, args[0]);
          // execute the query
          ResultSet rs = stmt.executeQuery();
          // read the results
          while(rs.next()) {
               int id = rs.getInt("id");
               String pw = rs.getString("pw");
               System.out.println("id="+id);
          }
        } catch (Exception e) {
             System.out.println("Exception: "+e);
             e.printStackTrace();
        }
      } // main
    } // class MyCon
15.3 Making Connections                                                  331
      Example 15.2 Simple sample program using JDBC for Oracle
      // import oracle.jdbc.driver.*;
      import java.sql.*;
      public class
      MyCon
      {
        public static void
        main(String [] args)
        {
          try {
             // A simple connection example looks like this:
             Class.forName("oracle.jdbc.driver.OracleDriver").newInstance();
             String url = "jdbc:oracle:thin:mydbusername/mydbpasswd"+
                           "@host.domain.com:1521:dbname";
             Connection conn = DriverManager.getConnection(url);
             // query
             String mySQL = "SELECT id, pw FROM Users WHERE name = ?";
             PreparedStatement stmt = conn.prepareStatement(mySQL);
             stmt.setString(1, args[0]);
             // execute the query
             ResultSet rs = stmt.executeQuery();
             // read the results
             while(rs.next()) {
               int id = rs.getInt("id");
               String pw = rs.getString("pw");
               System.out.println("id="+id);
             }
          } catch (Exception e) {
               System.out.println("Exception: "+e);
               e.printStackTrace();
          }
        } // main
      } // class MyCon
332                                   Chapter 15   Accessing the Data: An Introduction to JDBC
      Connection conn = DriverManager.getConnection(url, username, password);
             Getting this to compile and run requires you to have the appropriate
      JDBC JAR files available. For Oracle, see your Oracle DBA, or see pages
      228–229 of Java Oracle Database Development by David Gallardo. For MySQL,
      it’s an easy download you can install from the Internet.
      15.3.1 Downloading JDBC for MySQL
      The JDBC implementation for MySQL is available for free from
      http://www.mysql.com/downloads/api-jdbc.html.
             The current version at the time of writing was mysql-connector-java-
      3.0.9-stable.tar.gz which you can unpack as follows:
      $ gunzip mysql-connector-java-3.0.9-stable.tar.gz
      $ tar xvf mysql-connector-java-3.0.9-stable.tar
             That leaves you with a directory named mysql-connector-java-
      3.0.9-stable which contains a JAR file named mysql-connector-java-
      3.0.9-stable-bin.jar along with some directories (which are the contents
      of the JAR, unpacked) and a few miscellaneous files.
             From the readme file:
             Once you have unarchived the distribution archive, you can install the
             driver in one of two ways:
                • Either copy the com and org subdirectories and all of their contents
                  to anywhere you like, and put the directory holding the com and org
                  subdirectories in your classpath, or
                • Put mysql-connector-java-3.0.9-stable-bin.jar in your class-
                  path, either by adding the full path to it to your CLASSPATH
                  environment variable, or putting it in $JAVA_HOME/jre/lib/ext.
             Unlike JUnit, it is OK to put this JAR in the ext directory.
 15.4 QUERYING DATA
      Back to our example. Do you remember the portion that built the query? Here
      it is again:
15.4 Querying Data                                                                      333
      // query
      String mySQL = "SELECT id, pw FROM Users WHERE name = ?";
      PreparedStatement stmt = conn.prepareStatement(mySQL);
      stmt.setString(1, args[0]);
            If you’re at all familiar with SQL then you’ll recognize the SQL syntax
      within the String mySQL. Whatever you want your query to be, just build it
      as literal text. The query is “parameterized” by using the “?” character. Wher-
      ever a “?” appears in the query string, you can substitute a value with the
      setString() method on the PreparedStatement class.
            There are a variety of setXXXX() methods where XXXX stands for different
      data types. Besides setString(), the most common ones are setInt(),
      setBigDecimal(), setDouble(), and setTimestamp() which set the
      parameter from an int, BigDecimal, Double, and Timestamp classes, respec-
      tively. The java.sql.Timestamp class is basically a java.util.Date aug-
      mented for compatibility with SQL’s notion of TIMESTAMP. Read more
      about it on the Javadoc page for java.sql.Timestamp, or read the
      java.sql.PreparedStatement page for more on the other set methods
      available.
            The two arguments to each of these set methods are the index and the
      value that you want to substitute. The index is simply the count of which
      question mark gets substituted, starting with 1 for the first one. Caution: The
      parameters start at one, even though most other things in Java, such as Arrays,
      ArrayLists, and so on, are zero-based. So it’s not uncommon in code that
      uses JDBC to see something like this:
      setInt(i+1, args[i]);
            NOTE
            Building SQL queries out of String literals is made easier in Java by a conve-
            nient mismatch between the two languages. In Java, Strings are delimited
            by double quotes (") whereas in SQL literals are bounded by single quotes
            ('). Thus in Java, you can construct SQL queries that contain literal string
            references without much trouble, as in:
            String clause = "WHERE name != 'Admin'"
334                                  Chapter 15    Accessing the Data: An Introduction to JDBC
            If this all seems rather simplistic, well, it is. It may not be a very sophisti-
      cated way of blending SQL with Java, but it is very effective. Notice that you
      don’t get any syntax checking on the SQL query when you write your program,
      though it will throw an exception at runtime if you try to execute ungrammat-
      ical SQL. For this reason it is not uncommon to try out all your SQL before-
      hand, cutting and pasting the queries out of the SQL program that you use for
      directly talking with your database. Some developers even like to keep their
      queries in files, to be read at runtime. This has the added flexibility (and risk)
      of being able to change the query without recompiling the code. Since the re-
      compile doesn’t provide any syntax checking on your query string anyway, it
      seems a reasonable way to go, provided that you properly write-protect the files
      containing the queries.
 15.5 GETTING RESULTS
      Returning to our example, we see that we can execute the query on the
      Statement object and then get out the results:
      ResultSet rs = stmt.executeQuery();
      // read the results
      while(rs.next()) {
         int id = rs.getInt("id");
         String pw = rs.getString("pw");
         System.out.println("id="+id);
      }
            The results of a query are returned in a ResultSet object. The easiest way
      to think of it is to consider it an iterator over the rows that result from the
      query. In its simple form it is, like an iterator, a one-pass, once-through traversal
      of the data. Since the result set is iterating over rows, we need to get at the indi-
      vidual columns of results with a further method call on the ResultSet. You
      can see that inside the while loop of the example.
            The query was built to retrieve the columns id and pw from our table.
      The getInt() and getString() methods use those column names to retrieve
      the data from the ResultSet.
15.5 Getting Results                                                                     335
             TIP
             The case (UPPER or lower) of the column name strings is ignored, so you could
             write ID and pW and it would work fine. Some developers prefer, for example,
             to use all-uppercase names of columns. We recommend using a consistent
             case throughout to avoid confusing those who later have to read your code.
             There is another form for each of those getXXXX() calls that takes as its
      argument the column number rather than name. Since our query selected
      "id, pw", the id is column one and pw is column two, so we could have
      written:
      int id = rs.getInt(1);
      String pw = rs.getString(2);
             In addition to the get methods, ResultSet also has some boolean
      methods that will help your application figure out how far in the result set
      the iterator has reached: isBeforeFirst(), isFirst(), isLast(), and
      isAfterLast(). There is, however, no way to tell how big the result set is
      directly from this simple result set.
             More complex manipulation of the ResultSet object is possible if we
      create the PreparedStatement with a different method call, one that lets us
      provide additional parameters to specify this more complex behavior. We
      could use:
      conn.prepareStatement(mySQL,
                                     ResultSet.TYPE_SCROLL_INSENSITIVE,
                                     ResultSet.CONCUR_READ_ONLY);
      which lets us specify a type of scrollable behavior and whether
      (CONCUR_UPDATEABLE) or not (CONCUR_READ_ONLY) the results set can be
      updated.
             Once we’ve built the prepared statement this way, we can move the itera-
      tor forward or backward, to absolute (e.g., row 7) or relative (e.g., 3 rows back)
      positions. For a good discussion of this topic, see page 257 and the following
      pages in the Gallardo book.
             If you’re still hung up on the fact that you can’t get the size, in rows, of
      the result set from our first example, notice that you can now do that with this
      more flexible, “scrollable” result set. To find its size before reading any data,
336                                   Chapter 15   Accessing the Data: An Introduction to JDBC
      position it afterLast(), then getRow() to get the size, then position it back
      to beforeFirst() to be ready to read.
 15.6 UPDATES, INSERTS, DELETES
      Not every action on a database returns a ResultSet. Operations that create
      the tables in a database, or those that modify, insert, or delete rows of data don’t
      return rows of values. For those sorts of SQL statements, we don’t call
      executeQuery()—we call executeUpdate() instead. It returns an int giving
      the number of rows affected by the execution. In the case of a CREATE TABLE
      operation, it simply returns 0.
 15.7 REVIEW
      Connecting a Java application to a database is a key step in real applications.
      The mechanisms for doing that are varied and can be complicated. We’ve
      picked a single approach for connecting, to keep it simple and to highlight the
      similarities and differences between two different database implementations.
           The rest of the conversation with a database depends as much on your
      SQL skills as on Java skills. Java will take strings of SQL, which can be param-
      eterized, and, via JDBC calls, send them to be executed by the database. The
      results are like iterators; they can be retrieved, row after row, for further process-
      ing. Updates, inserts, and deletes are also easily done, with a few simple calls to
      process the SQL.
 15.8 WHAT YOU STILL DON’T KNOW
      We’ve skipped over lots of topics to keep this simple. There are a variety of
      ways to connect to a database that we haven’t covered; the most important one
      may be the use of a DataSource instead of a DriverManager. As of Java 1.4.1,
      the DataSource is the preferred means of making connections to your
      database. While it makes the code more portable (e.g., if you’re planning on
      moving around, changing databases and/or database servers), it is more compli-
      cated to set up—there are more “moving parts” to get right. If you already have
      a Java Naming and Directory Interface (JNDI) service running, thought, it’s
      very straightforward (see page 254 and the following pages of Gallardo).
15.9 Resources                                                                     337
             We haven’t covered the basic Statement class suitable for fixed queries
       with no parameters (instead we used PreparedStatement which will work
       with or without parameters), nor have we discussed the CallableStatement
       class for calling stored procedures in the database. With what you know now,
       though, you should be able to glean enough information from the Javadoc
       pages on these classes to do what you need, as they are similar to the
       PreparedStatment class.
             RowSets extend ResultSet to include mechanisms for listening for data
       changes and for JavaBeans functionality. But again, Javadoc information or a
       comprehensive book on the subject would be a good next step, now that you
       have the basics in hand.
             We haven’t covered the ResultSetMetaData class, which provides a way
       for you to get the names of the columns that come back from the query. Again,
       check the Javadoc for details on its use.
             We also haven’t said anything about transactions, a key element in many
       database applications. We’ll say more about that as we get into the enterprise-
       scale applications.
             What we have covered should enable you to connect to a database, make
       real queries, and process the results. There are more advanced techniques to
       learn for special cases, but what we’ve covered here, accompanied by the
       Javadoc pages for java.sql.* classes, should be enough to create useful, real
       applications.
             And of course there is always that other good teacher, experience. So go
       try some of what you now know.
 15.9 RESOURCES
       If you are going to use an Oracle database, we highly recommend Java Oracle
       Database Development by David Gallardo (ISBN 0130462187, Prentice Hall
       PTR), part of their Oracle Series. It includes several introductory chapters on
       database design, SQL, and even PL/SQL. It then has a much more thorough
       coverage of JDBC topics, with examples specific to Oracle, than we can cover
       in our limited space.
             A JDBC implementation for MySQL is available at
       http://www.mysql.com/downloads/api-jdbc.html.
             JDBC tutorial information, as well as lots of other JDBC information, is
       available from Sun at http://www.java.sun.com/products/jdbc/.
338                                Chapter 15  Accessing the Data: An Introduction to JDBC
           If you are working with a database other than mySQL or Oracle, you
      might want to check out http://servlet.java.sun.com/products/jdbc/
      drivers for a list of approximately two hundred JDBC implementations for
      various databases.
15.10 EXERCISES
        1. Write a program that connects to a database and, for each of the tables
           specified on the command line, prints out the table name and the number
           of rows in that table.
        2. Using what has been covered in this chapter, write a simple non-GUI SQL
           program, allowing the user to enter SQL statements, executing them, and
           showing the results (like a simplified SQL/Plus program). Can you provide
           some simple editing of the SQL? Or can you implement escaping to an
           external editor, for example, vi?
        3. Make it possible for the user of your SQL program to set and change the
           connection URL—via an environment variable, command-line parameter,
           or even from within the program. Your SQL program will then be able to
           query a variety of databases from various vendors.
Part III
Developing
Graphical User Interfaces
     Chapter 16
     Getting in the Swing of Things:
     Designing a GUI for BudgetPro
     Sometimes you gotta have a GUI; even we will admit that command lines only
     go so far. When it comes to simple interactions with casual users, a Graphical
     User Interface is a great step forward . . . if it’s done well. The toolkit for
     building such an interface with Java is called Swing. The original Java toolkit
     is AWT (A Windowing Toolkit), and is still in use, but much less attractive.
     We’ll take a quick look at some major pieces of Swing, and show a complete
     example—a GUI for our budget application. After this example, you will have
     the tools you need to construct some real GUIs on your own.
16.1 WHAT YOU WILL LEARN
        • The Swing GUI paradigm.
        • A simple standalone Swing application.
        • Some basic Swing objects—buttons and labels.
        • A bit about layout managers.
        • A more complex object—the JTable.
                                                                                 341
342                 Chapter 16     Getting in the Swing of Things: Designing a GUI for BudgetPro
 16.2 A SIMPLE SWING PROGRAM
      Let’s take a look at a very simple (in its function, not in its composition)
      Swing program—a simple “Hello, world” that will appear in a window
      (Example 16.1).
      Example 16.1 A simple Swing application
      import java.awt.*;
      import javax.swing.*;
      public class
      hw
      {
         public static void
         main(String[] args)
         {
           //Create the top-level container
           JFrame frame = new JFrame();
           JLabel hi = new JLabel("Hello, world.");
           frame.getContentPane().add(hi, BorderLayout.CENTER);
           frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
           frame.pack(); // kicks the UI into action
           frame.setVisible(true);
         } // main
      } // class hw
           Now compile this program and run it from the command line like this:
      $ javac hw.java
      $ java hw
           You should then see a small window appear, looking as in Figure 16.1.
      Figure 16.1 “Hello, world” in a Swing window
16.3 Stompin’ at the Savoy, or The Swing Paradigm                                       343
            While this may look like a lot of extra junk just to say “Hello, world,” re-
       member that a GUI is not just providing output in fancy windows, but also
       monitoring and responding to a wide variety of user inputs—a capability of
       which we make little or no use in this example. But you can see some of this
       extra capability—grab the lower left corner of the window frame and expand
       and resize the window.
 16.3 STOMPIN’ AT THE SAVOY, OR THE SWING PARADIGM
       When we say “Swing,” we generally mean the set of classes in the javax.swing
       package and its subpackages (such as javax.swing.table). The packages are
       libraries of code that give you predefined classes from which you can construct
       a GUI for your application. The programs you write will be written in Java,
       the syntax will look like Java, but there will be a lot of creation of classes, uses
       of interfaces, implementations of abstract classes, and a variety of method calls
       that all deal with these Swing classes.
            So what’s going on with all this stuff? What can we expect to do, see,
       write? In most applications that a programmer writes, it is the job of the pro-
       grammer to design and write the code for the main execution path of the pro-
       gram. “Yes, every program has a beginning, middle, and an end” (with apologies
       to “Seymour and his frozen yoghurt stand,” from Sesame Street). But it’s not
       quite the same with Swing. While it does have to have a beginning, middle,
       and end (these are, after all, basic Von Neumann architecture machines), the
       big difference is that you do not have to write most of the control logic; it
       comes as part of the Swing set.
            Look at it this way. With Swing, as with other GUI toolkits, you don’t
       have to write code to deal with the mouse, keyboard shortcuts, or painting
       characters onto a graphical screen. You don’t have to write all the code
       associated with a button press, because, while it seems simple enough, a button
       press is really a quite complex user interaction, involving repainting of the
       button’s border, possibly its shading or changing its icon, coordinating that
       with the mouse presses and releases, and deciding whether the releases happen
       within or without the boundaries of the button—all this and more, just for a
       simple button press. All this has been done for you, and packaged up into
       Swing classes.
344               Chapter 16  Getting in the Swing of Things: Designing a GUI for BudgetPro
         So what is left for you to do? You have to:
       • Construct the various items that will appear on the screen (in one or more
         windows).
       • Specify the location of these objects in the windows (layout).
       • Provide snippets of code that are the actions associated with various events
         (events happen, for example, when a button is pressed or a mouse is
         clicked). These actions are the guts of the code that make your application
         behave how you want.
         Remember, some behaviors are enforced by the GUI as part of standard
    “look and feel.” Some things, like layout, are up to you to do well so long as
    you keep within the standard UI guidelines. And some is just specific to your
    application.
         With that in mind, let’s walk through the “Hello, world” example for a
    brief description of what each line does.
         We begin with some import statements, to resolve references to both
    Swing and AWT classes. Swing is built on top of AWT, so some of the classes
    that you use will actually be AWT classes. The biggest difference this makes to
    you is in the import statements.
         We then begin our class declaration, followed by the definition of the only
    method in this class, main(). Swing applications will typically have other
    methods, but for our simple example we only need this one.
         Now comes some real Swing. The creation of a JFrame object is very im-
    portant. In Swing we need to have containers to hold the objects that we want
    to display. The JFrame is a top-level container, one specifically meant to hold
    other objects, but also meant to be the first one of a containment hierarchy.
    (There are only three such top-level containers in Swing: JFrame, JDialog,
    and JApplet.)
         Next we create a JLabel. It’s a Swing object meant to hold small amounts
    of text. The text can be either constant or changing, but it’s not user-editable
    (that would be a different kind of Swing object).
         We add the label to the frame, so that when the window (the JFrame)
    appears, it will show our text inside.
         The setDefaultCloseAction() does what you think. When you press
    the X in the upper right of the window frame (or wherever your window man-
    ager puts it), then not only will the window go away, but the program will stop
    running. (This is not the standard default value since JFrames can contain
16.4 Slow, Slow, Quick-Quick, Slow: The Basic Swing Objects                               345
       other JFrames, and for most frames you wouldn’t want closing the frame to
       quit the program.)
             When we “pack” the frame, that’s when the real magic happens. It kicks
       off the GUI activity on a separate thread, but also packs the various pieces that
       we’ve added to the frame, sizing them as best it can to fit into the frame, and
       sizing the frame to hold all the pieces. We see little of that with our example,
       which has only one label.
             As an aside, pack() is inherited from awt.Window, which describes the
       “magic” thus:
             A component is displayable when it is connected to a native screen resource.
             A component is made displayable either when it is added to a displayable
             containment hierarchy or when its containment hierarchy is made dis-
             playable. A containment hierarchy is made displayable when its ancestor
             window is either packed or made visible.
             So pack()-ing the frame connects it to a “native screen resource,” which
       effectively gets the whole GUI thing going.
             And now back to the business at hand.
             Finally, the setVisible() call makes the window appear. Then the
       main() is done. In case you’re wondering, go ahead and put a
       System.out.println() message after the setVisible(). It will be printed
       right away. The main() has ended; the GUI activity is happening on another
       thread.
 16.4 SLOW, SLOW, QUICK-QUICK, SLOW: THE BASIC SWING OBJECTS
       Let’s take a quick look at a variety of Swing objects that you can use to build a
       GUI. Like any job of craftsmanship, it helps to be familiar with your tools.
       What you can build will be aided (and limited) by the tools with which you
       build, and by how familiar you are with them. Here are some pieces which can
       be put together to make Swing GUIs:
       button
             A push button to trigger actions; can contain text and/or an icon.
       radio button
             A group of buttons where only one value can be chosen at a time.
346              Chapter 16   Getting in the Swing of Things: Designing a GUI for BudgetPro
    check box
         A choice of one or many of a small set of options.
    combo box
         A pull-down list of choices.
    menu
         A special case of a pull-down choice, a part of the border of a main
         window.
    label
         A small amount of text, typically used to label other controls.
    text field
         A simple display and/or entry of one line of text; think “fill-in-the-blank”
         kinds of forms, password entry, and the like.
    text area
         A multiline display and/or entry of text, all in a single font format.
    text pane
         Same as text area, plus multifont support, image display, and more; really
         more like a word processor in a window.
    list
         Selection from a list.
    table
         A two-dimensional display—rows and columns of data.
    tree
         A display of hierarchically-structured data.
    slider
         A graphical control for selecting a value.
    tool tip
         A bit of text that appears over objects when the mouse hovers.
    progress bar
         A graphical display of progress.
16.5 Layout Managers                                                               347
       color chooser
             A control for selecting colors from a palette.
       file chooser
             A window for interacting with the filesystem—selecting a directory or a
             filename.
             In addition to all these, there are various kinds of containers—objects
       whose job is to hold and display the other objects:
       panel
             A simple container.
       split pane
             A container divided into 2 separate parts.
       scroll pane
             A complex control with scrollbars, used to hold objects larger than the
             displayable area.
       tabbed pane
             A complex control with tab buttons to select different panels.
       toolbar
             A container for holding objects (usually buttons) which can attach to
             different sides of a window, or separate from a window and stand alone.
 16.5 LAYOUT MANAGERS
       Once you decided on all the graphical objects that you want to pack into your
       GUI, there is still one major hurdle—where to place all the objects. This can
       be one of the more challenging parts of GUI design because so many different
       screen sizes are available to the end user. How do you make your GUI look
       good to all (or most) of them?
             Beginners often want to fix their components to absolute locations—for
       example, by sketching the GUI out on a piece of graph paper and then using
       those coordinates to fix the location. But with a windowing display, the user
       can grab a corner of the window and resize it. So, consider that piece of graph
       paper—what if it just got stretched to twice the size? Do you want all the con-
       trols to just get bigger? Buttons need not grow larger, but it would be nice to
348                 Chapter 16  Getting in the Swing of Things: Designing a GUI for BudgetPro
      have additional space contributed to text areas. Consider a word processor:
      When you resize its window you only want the text area to expand, not the
      menus and icons.
           Layout managers are meant to address the issues of component placement
      and sizing. Some are very simple, others are much more complex. All have their
      advantages and disadvantages. We’ll use a few in our example to give you a taste
      of how they work.
 16.6 BEYOND ARTHUR MURRAY: ACTIONS, LISTENERS, EVENTS
      With any serious GUI comes a lot of advanced Java, especially constructs like
      anonymous inner classes. These are useful when we implement actions for our
      buttons and listeners for user selections.
           Keep in mind that there are three different time frames that we’re consid-
      ering—compile time, construction time, and event time. Compile time is obvi-
      ous, and the compiler will complain if it cannot access what it needs due to
      scoping problems. Construction time is when the program constructs the GUI
      objects for display in a window using the new and add() calls as well as layout
      managers. Event time is when the user presses a button or edits text in a field,
      or when other external events change data.
 16.7 GETTING DOWN TO CASES: DESIGNING A GUI FOR BUDGETPRO
      Our goal is a GUI for the BudgetPro application. We’ve already built a com-
      mand-line version, so we want to have the same general functions but with the
      convenience and glamour of a GUI. The GUI will need to:
         • Display the current account (name and dollars)
         • Display the list of subaccounts that are part of this account
         • Provide a way to create a new (sub)account
         • Provide a way to move down into a subaccount
         • Provide a way to move up to the parent account
           From this brief list we devise a simple display with a heading that contains
      the current account and its dollar status, a table which lists the subaccounts,
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                         349
      and, at the bottom of the window, some buttons—one for creating new ac-
      counts and one for viewing subaccounts. Of course, we’ll also need a button to
      close or exit the application. In order to move back up from a subaccount, we’ll
      add a button up in the header, an up-arrow, which will take us back to the
      parent account.
             Now we could show you a hand-drawn sketch of what this UI might look
      like, from our rough description, but we’ll cut to the chase and show you the
      finished product. This is the GUI for the BudgetPro application, in three stages.
      First comes the GUI when we first start up, with no subaccounts (Figure 16.2).
             When the New Subaccount button is pressed, a dialog will appear to
      collect the information need to create the subaccount, namely the new account’s
      name and the dollar amount to allocate to that account (Figure 16.3).
      Figure 16.2 BudgetPro GUI: top account window
      Figure 16.3 BudgetPro GUI: creating a (sub)account
350               Chapter 16 Getting in the Swing of Things: Designing a GUI for BudgetPro
    Figure 16.4 BudgetPro GUI: viewing subaccounts
         Finally, Figure 16.4 is a look at the main GUI window for BudgetPro once
    several accounts have been constructed.
         There is more to describe, but let’s walk through the code that builds this
    GUI and explain the parts as we go. The complete listing is available online at
    http://www.javalinuxbook.com. We’ll make reference to the line numbers
    of the listing in Appendix B, but sometimes we’ll show excerpts of the code as
    we go. You might find it handy to have a listing of the code (on paper or in
    your browser) as you read the next several sections.
    16.7.1 Overview
    We divide the work between two GUI classes: one for the main window and
    the other for the dialog that will appear when we want to create a new subac-
    count. All of the other GUI elements will be either existing Swing classes or
    their extensions as anonymous inner classes in our code. (More on those later.)
         So that means that we have four of our own classes that we’re working
    with: two from the core of our application, Account and User, and two from
    the GUI side of things, BudgetPro and AcctDialog. This will be reflected in
    the package structure; we’ll put BudgetPro and AcctDialog into the
    net.multitool.gui package. This will effect both the location of the source
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                             351
      (to be put into net/multitool/gui) and the package statement on line 1 of
      BudgetPro.java:
      1 package net.multitool.gui;
      16.7.1.1 Instance Variables
      Take a look at the picture of the BudgetPro GUI. Count the GUI objects that
      we need: four buttons, three labels, and let’s not forget the (empty at first) table
      of subaccounts. These are declared in lines 23–31. (Ignore lines 22 and 32
      for now, we’ll cover them later. Line 34 declares our dialog—more on that
      later, too.)
      21      // gui components
      22      private JFrame frame;        // needed by dialogs to root themselves
      23      private JLabel nam;
      24      private JLabel tot;
      25      private JLabel val;
      26      private JButton upton      = new JButton(
                                    new  ImageIcon("net/multitool/gui/back.gif"));
      27      private JButton creat      = new JButton("new subaccount");
      28      private JButton view       = new JButton("view subaccount");
      29      private JButton clos       = new JButton("quit");
      30
      31      private JTable list;
      32      private AbstractTableModel model;
      33
      34      private AcctDialog askem;          // make once, use often
      16.7.1.2 Main
      Skip all the way to the last method of the class, line 289 and following. It’s the
      main() which gets run when we run this class. If we focus on the major piece
      involved in getting our GUI together, it’s these lines:
      JFrame frame = new JFrame("BudgetPro");
      frame.getContentPane().add(status, ...);
      frame.getContentPane().add(list, ...);
      frame.getContentPane().add(buttons, ...);
             We’re leaving out lots of intermediate text to emphasize the “real” work.
      We create a JFrame, the outermost window object. We add into it all the other
352               Chapter 16   Getting in the Swing of Things: Designing a GUI for BudgetPro
    GUI pieces—the status line, the table list of accounts, and the buttons. The
    JFrame is a bit odd here, in that you have to add objects to its content pane;
    other container objects you can just add to directly. (We could have done the
    getContentPane() once, store the result in an intermediate variable, and do
    the adds to it, but the efficiency gain is unimportant here because we only need
    to do this once, to get the GUI started.)
         When we’ve got it built, we pack the frame, and make it visible:
    frame.pack();
    frame.setVisible(true);
         That’s the basic core of what you need to do with any GUI: construct its
    pieces, add them to the frame, pack the frame, and make it visible. Now you’re
    off and running. The rest is just details.
    16.7.2 Creating Pieces
    The three pieces that we create—the status, the list, and the buttons—will each
    package up their objects into an intermediate container, a JPanel, and return
    that container to main(). This not only serves to chunk the problem into
    fewer pieces (just three parts, not eight or more), but also helps with the
    formatting. Each piece can format its objects relative to each other. Then
    main() only has to lay out the three big pieces. So watch for each of the
    create...() methods to return a JPanel—a good approach when you build
    your GUIs, too.
         The JPanels returned to main() are just Swing objects. They, like the
    buttons or labels (that we will see here shortly), just get added into other con-
    tainers. For main(), that container is the JFrame, the main window. Any
    container will have a layout manager, the mechanism by which objects are
    placed in that container. For JFrame, the default is the BorderLayout manag-
    er. When you call the add() method on a container using a BorderLayout,
    you can specify (as a second parameter to the add() method) where the
    object being added will get placed. The constants defined for placing
    objects are NORTH, SOUTH, EAST, WEST, or CENTER—hence the “Border” of
    BorderLayout. There are also relative position values: PAGE_START,
    PAGE_END, LINE_START, and LINE_END which are just like north, south, west,
    and east, respectively, provided that the ComponentOrientation is set to
    LEFT_TO_RIGHT. (If you really want to know, check the Javadoc page for
    java.awt.BorderLayout.)
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                            353
             With a BorderLayout, if you put something in the NORTH section, it will
      appear across the top area of that container. If you resize the container (e.g.,
      drag the window edges), it will take extra space and use it for horizontal, but
      not vertical, stretching. That is, the objects won’t get bigger than they need to
      vertically, though they will stretch wider. The same is true for SOUTH, but the
      objects are at the bottom rather than top of the container. Putting something
      in EAST or WEST will move them to the left or right of the container. For these
      two areas, though, space when resizing a window is added to the objects verti-
      cally, but not horizontally. Putting an object in EAST or WEST will let it get
      taller, but not wider.
             The CENTER area, the default location if you use the add() method with
      no second parameter, will use extra space both vertically and horizontally.
             Adding more than one object into a region (e.g., NORTH) will result in only
      the last item added being displayed. For this reason, too, one often builds inter-
      mediate containers to hold several objects. Then the single container object is
      added to one of BorderLayout’s regions.
      16.7.2.1 Simple JLabels
      Let’s look at the simplest of the three pieces that we create for our GUI—the
      top line of information indicating the status of the account. In lines 88–107
      we create this portion of the GUI.
        88     private Component
        89     createStatus()
        90     {
        91       JPanel retval = new JPanel();           // default: flow layout
        92
        93       upton.addActionListener(upAction);
        94
        95       nam = new JLabel("Account: Name");
        96       tot = new JLabel("Total: $");
        97       val = new JLabel("Remaining: $");
        98
        99       retval.add(upton);
      100        retval.add(nam);
      101        retval.add(tot);
      102        retval.add(val);
      103
      104        setStatus();
      105
      106        return retval;
      107      } // createStatus
354               Chapter 16    Getting in the Swing of Things: Designing a GUI for BudgetPro
          It consists of three parts, one for the account name, one for the total value
    of the account, and one for the remaining value. Each part will be represented
    by its own label, using a JLabel object. (We could have done the entire line
    in one label, but this gives us a few more objects to manipulate.) Since we want
    to group the labels together, we create a JPanel, which is a Swing container,
    to hold all these objects. We’ll also add the JButton object (the variable named
    upton).
          A JLabel is a simple Swing object. You can construct an empty one with
    new JLabel(); but you can also construct a label with a String as its initial
    value, which is more useful. You can later change a label’s value with a call to
    its setText() method, as you see here from line 117:
    117        tot.setText("Total: $"+current.getTotal());
    16.7.2.2 FlowLayout
    The JLabels are added to their JPanel, but with no position argument, unlike
    the JFrame and BorderLayout used in main(). JPanel has a different default
    layout manager: It uses FlowLayout. With it, added objects are placed side by
    side according to the window size. If the window is narrowed, they will simply
    flow onto the next line. (You won’t see this behavior if you narrow the Budget-
    Pro window, but that’s because the JPanel has been added to the JFrame’s
    NORTH region, which means it’s no longer just a FlowLayout that determines
    sizes.) FlowLayout is a layout that’s easy to use, but doesn’t give you much
    control; it was just fine for our purposes here.
    16.7.2.3 BoxLayout
    Another simple layout mechanism is the BoxLayout. It allows you to place the
    objects like stacking boxes—though they can be stacked horizontally as well as
    vertically. Look at line 224:
    224        retval.setLayout(new BoxLayout(retval, BoxLayout.X_AXIS));
          Here we are creating a BoxLayout object and associating it with our
    JFrame to manage its objects. When we create a BoxLayout we can tell it that
    we want to stack our objects horizontally (using either X_AXIS or LINE_AXIS)
    or vertically (using either Y_AXIS or PAGE_AXIS). Note that the BoxLayout
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                            355
      object needs to be told about (i.e., given a reference to) the container (here,
      retval, a JPanel) whose objects it will manage, but that the container also
      needs to be told (via setLayout()) about the BoxLayout object. A bit
      confusing, perhaps.
             Another handy part of BoxLayout is the uses of rigid areas, invisible ob-
      jects that do nothing except putting some space between objects. These rigid
      areas are defined in pixels; for our GUI we create them with no height and a
      width of ten pixels. They are held together using “horizontal glue” (see line 226)
      226        retval.add(Box.createHorizontalGlue());
      so that if the window is stretched, the extra space doesn’t get added between
      the buttons, but only to the “glue” component, which absorbs all extra space.
      This keeps all the buttons to the right hand side of the window.
      16.7.2.4 JButtons
      The method named createButtons() actually packs up the buttons into a
      JPanel to return to the caller. It begins like this:
      218      private Component
      219      createButtons(JRootPane root)
      220      {
      221        JPanel retval = new JPanel();         // default: flow layout
      222
      223        //Lay out the buttons from left to right.
      224        retval.setLayout(new BoxLayout(retval, BoxLayout.X_AXIS));
      225        retval.setBorder
                         (BorderFactory.createEmptyBorder(10, 10, 10, 10));
      226        retval.add(Box.createHorizontalGlue());
      227        retval.add(creat);
      228        retval.add(Box.createRigidArea(new Dimension(10, 0)));
      229        retval.add(view);
      230        retval.add(Box.createRigidArea(new Dimension(10, 0)));
      231        retval.add(clos);
             The buttons themselves were created at the beginning of this class, in
      lines 27–29, thus:
      27      private JButton creat = new JButton("New Subaccount");
      28      private JButton view = new JButton("View Subaccount");
      29      private JButton clos = new JButton("Quit");
356                Chapter 16 Getting in the Swing of Things: Designing a GUI for BudgetPro
          Note that the constructor takes a String argument—that’s the text that
    will appear in the button. A button may also have an icon (image) in it (more
    on that in just a bit). These buttons, as created, don’t do anything. When
    clicked on by the user, they will behave as real buttons (depress, then release),
    but no action will occur. Yet.
    16.7.2.5 Actions for Buttons
    We need to attach an action to each button, which is little more than a special
    class to hold the code that you want to be run when the button is pressed. We
    can define the action as an anonymous inner class, so that the code is right
    there, inline with the rest of our code. Then we just attach that code to the
    button. Here is an example of that for our close button (the one labeled Quit):
    234        ActionListener closAction = new ActionListener()
    235        {
    236          public void
    237          actionPerformed(ActionEvent e)
    238          {
    239               System.exit(0);
    240          }
    241        } ;
          ActionListener is an interface—a very simple interface that defines just
    one method, actionPerformed(). You can take any class, have it extend
    ActionListener, and then define an actionPerformed() method for it.
    That class can then serve as the action for a button. Here we just create an in-
    line class that does nothing but the actionPerformed() method, and a pretty
    simple one at that. It simply exits.
          We could define the action elsewhere, and then just use the reference to
    the action. If we had put the declaration of closAction at a higher lexical
    scope (out at the beginning of the class definition, for example) then other UI
    elements could also use this action. Of course, if you’re going to share your
    action between GUI elements, be sure that you write the code to be reentrant.
          Lines 244–267 (still within the createButtons()method) define the
    action for the button labeled New Subaccount. Line 268 connects it to the
    button. Don’t pay attention to the specifics of this action just yet. We’ll discuss
    it in detail below, once we know more about the other objects. Here is how
    that action is built:
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                          357
      244        ActionListener creatAction = new ActionListener()
      245        {
      246           public void
      247           actionPerformed(ActionEvent e)
      248           {
      249             Account child;
      250             // get the info via a Dialog (of sorts)
      251             if (askem == null) {
      252                  askem = new AcctDialog(frame, "New Subaccount");
      253             } else {
      254                  askem.clear();
      255                  askem.setVisible(true);
      256             }
      257             String subName = askem.getName();
      258             String subAmnt = askem.getAmnt();
      259
      260             // if empty, assume the operation was cancelled, else:
      261             if ((subName != null) && (subName.length() > 0)) {
      262                  child = current.createSub(subName, subAmnt);
      263                  setStatus();
      264                  model.fireTableDataChanged(); // notify the table
      265             }
      266           }
      267        };
      268        creat.addActionListener(creatAction);
             We defined the action for the View Subaccount button (as we said you
      could) elsewhere in the program. Its action is defined in lines 54–75. Then on
      line 271 we connect the action to the button. (We’ll get back to this button’s
      action, too, once we’ve discussed the JTable.) But after we’ve attached the ac-
      tion, we also disable the button (line 273).
      270        // function is to get selection from table and cd there
      271        view.addActionListener(cdAction);
      272        // but it starts off disabled, since there is no data yet
      273        view.setEnabled(false);
             In Swing, a button is either enabled or disabled. Enabled buttons are the
      active ones on which you can click. Disabled buttons are grayed out and not
      responsive to clicks. We can make a button either active or inactive with a
      method on the button called setEnabled() whose argument is a
      boolean—true to enable the button, false to disable it. For example:
358                 Chapter 16  Getting in the Swing of Things: Designing a GUI for BudgetPro
    203                   if (lsm.isSelectionEmpty()) {
    204                        view.setEnabled(false);
    205                   } else {
    206                        view.setEnabled(true);
    207                   }
          However, we start with the View Subaccount button disabled until the
    user has created and selected some subaccounts worth viewing.
    16.7.2.6 The createStatus() Revisited
    There is one other button on the BudgetPro application, one that is not located
    in this bottom panel of buttons. It’s the one on the status line. It, too, starts up
    disabled or grayed out—but it has an image in it. Any JButton can contain
    either text or an image, or both, but we’ve chosen to do just one or the other
    in our application. We declare it like any other button:
    private JButton upton;
    but for its initialization we use a variation of the JButton constructor, one that
    takes an ImageIcon object as its parameter:
    upton = new JButton(new ImageIcon("net/multitool/gui/back.gif"));
          Why do we do that all in one line? When you read it, you can certainly
    think of it as two steps:
    ImageIcon backup = new ImageIcon("net/multitool/gui/back.gif");
    upton = new JButton(backup);
    but we have no other need for the image, so we don’t need to keep a reference
    for it in a variable. Some programmers prefer to write it out in two simple steps,
    as it is easier to read and perhaps to maintain. We’ve chosen to put it all in the
    JButton’s constructor to show that we’re making no other use of the image.
    Which style do you prefer?
          And what about a button that needs to contain both text and an image?
    There is a constructor that takes both a String and an ImageIcon. Then
    you can set certain attributes of the JButton to position the text
    relative to the image. Look in the Javadoc of JButton for the methods
    setVerticalTextPosition() and setHorizontalTextPosition().
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                            359
      16.7.2.7 JTable: The Workhorse of Data Display
      Look again at our GUI application. In its center you see the table object:
             This is a JTable. A simple way to create a JTable is by passing in two
      arrays to the constructor—first, a two-dimensional array of data objects, and
      second, a one-dimensional array of column names. Notice that we said data
      objects; you need to use Integer objects, not simple int types, and Doubles
      instead of doubles. This allows the constructor to take any Object type and
      display it in the table via the object’s toString() method.
             While this form of a table is simple to use, it usually isn’t enough for all
      the various things you’ll want to do with a table. Let’s look at the “industrial
      strength” table initialization. For that, we need to talk about a table model.
      16.7.2.8 Table Model
      If you’ve ever taken an object-oriented design class, they’ve probably talked
      about the Model/View/Controller design pattern. (If you haven’t taken such a
      class, at least read a good book or two on the subject; it will improve your Java
      programming skills.) A simpler version of this pattern is the View/Model pat-
      tern. What it describes is separating the core of the data from the frill of its
      presentation—what you want to display versus how you want to display it. The
      Model is the underlying data; the View is one particular way to show that data.
             This View versus Model distinction is used to great effect with JTable
      and TableModel objects in Swing. What you need to do is create a
      TableModel, then give that TableModel to the JTable via the JTable’s
      constructor. The TableModel will give you all sorts of control over your
      data—how, where, and when to get or update it. The JTable will display it
      and let you rearrange or resize the columns.
             Rather than implement a complete TableModel from scratch, Swing gives
      us a helping hand with its AbstractTableModel class. AbstractTableModel
      is a partially implemented class which handles most of the grundy details—it
360               Chapter 16  Getting in the Swing of Things: Designing a GUI for BudgetPro
    has most of the Table interface implemented. You only need to implement
    three methods:
    public int getRowCount();
    public int getColumnCount();
    public Object getValueAt(int row, int column);
         Together, these three methods give a pretty good definition of a table: how
    many rows it has, how many columns it has, and how to access the value at any
    (row, column) location. Notice, too, that the getValueAt() returns an
    Object, so you can’t return an int or float or double. You can only return
    an Integer, Double, and so on. Another option is to return a String value
    of the number that you want to display.
         Let’s take a look at how the AbstractTableModel was implemented in
    the BudgetPro application. We begin at line 135, inside the createList()
    method. The createList() method is going to build the central portion
    of our GUI, the table display. In order to do that, it creates an
    AbstractTableModel to give to the JTable it creates on line 193. The
    AbstractTableModel is defined inline as an anonymous inner class that
    implicitly extends AbstractTableModel. This section of code is listed in
    Example 16.2; follow along as we discuss it further.
         (An aside: We could also have defined this inner class elsewhere in the class
    file, as a class which explicitly extends AbstractTableModel. However, as
    with the icon we used in the JButton example, we have no further need of the
    object other than this single use, so we didn’t bother to create it as a standalone
    entity. Both ways work, and are more a matter of preference or of how familiar
    you are with the inline syntax.
         In our implementation of the AbstractTableModel, we are going to in-
    clude column headings, so we begin with a definition of Strings for our col-
    umn headings (line 137). Then the getColumnCount() method, one of the
    three methods that we need to implement in this class, is simply a matter of
    returning the size of this array (line 159). Lines 139–142 override the
    getColumnName() method, which isn’t one of the three that we must imple-
    ment. But if we don’t, the default behavior from AbstractTableModel will
    return nulls, so we’d get no column headings. Instead, we use the column
    number as an index to our array of column names.
         The getRowCount() method is almost as simple (lines 144–155).
    The number of rows that this table should display for any account is the
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                 361
Example 16.2 Defining our AbstractTableModel
130   private Component
131   createList()
132   {
133      JScrollPane retval;
134
135      model = new AbstractTableModel()
136        {
137           private String [] columnNames = {"Account", "Owner", "Value"};
138
139           public String
140           getColumnName(int col) {
141             return columnNames[col];
142           } // getColumnName
143
144           public int
145           getRowCount()
146           {
147             int retval;
148
149             if (current != null) {
150                  retval = current.size();
151             } else {
152                  retval = 1;         // testing only
153             }
154
155             return retval;
156
157           } // getRowCount
158
159           public int getColumnCount() { return columnNames.length; }
160
161           public Object
162           getValueAt(int row, int col) {
163             Object retval = null;
164             Account aa = null;
165             // return "---";        // rowData[row][col];
166             int count = 0;
167             for (Iterator itr=current.getAllSubs(); itr.hasNext(); )
168             {
169                count++;
170                aa = (Account) itr.next();
171                if (count > row) { break; }
172             } // next
362               Chapter 16 Getting in the Swing of Things: Designing a GUI for BudgetPro
173           switch (col) {
174           case 0:
175                   retval = aa.getName();
176                   break;
177           case 1:
178                   retval = aa.getOwner();
179                   break;
180           case 2:
181                   retval = aa.getTotal();
182                   break;
183           } // endswitch
184           return retval;
185         } // getValueAt
186
187         public boolean
188         isCellEditable(int row, int col)
189         {
190           return false;
191         } // isCellEditable
192      };
193   list = new JTable(model);
194   list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
195
196   list.getSelectionModel().addListSelectionListener(
197         new ListSelectionListener()
198         {
199           public void
200           valueChanged(ListSelectionEvent e)
201           {
202             ListSelectionModel lsm = (ListSelectionModel)e.getSource();
203             if (lsm.isSelectionEmpty()) {
204                 view.setEnabled(false);
205             } else {
206                 view.setEnabled(true);
207             }
208           } // valueChanged
209         }
210   );
211
212   retval = new JScrollPane(list);
213
214   return retval;
215
216 } // createList
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                              363
      number of subaccounts defined for the account. Since we’re defining our
      AbstractTableModel as an inner class, we have access to the data in the outer
      (BudgetPro) class. We use the instance variable current, which refers to
      whichever account we’re currently working with. A quick check of the Account
      class shows that an Account object can return the number of subaccounts
      (or “children”) via its size() method. So for our getRowCount() method we
      return current.size()—provided that current is not null. If it is null,
      we return 1 rather than 0, so that the table itself shows up and the headings
      appear. (But it also means that getValueAt() has to deal with requests for
      data from the first row when data may not exist.)
             The core of what makes our data appear is the getValueAt() method,
      lines 161–185. Since each row represents a subaccount of the current account,
      we’ll just iterate through current’s list of subaccounts until we reach the
      row-th subaccount; for example, to get the third row we iterate over this list of
      subaccounts until we get to the third one returned by the iterator’s next()
      method. This is a bit “brute force,” to keep marching over the list of accounts,
      but for our small data size it’s not bad. (Another approach would be to change
      the Account class to provide a method to return the n-th subaccount. Then it
      can use its internal knowledge of the way it stores subaccounts to provide a
      more efficient access. Alternately, our extended AbstractTableModel could
      iterate over the list once and store the subaccounts in an array, for quicker access
      later; the trick here is that the array needs to be refreshed every time the account
      changes—so we took the simple approach.)
             Once we have a row selected, we use the switch/case construct to choose
      the correct data for the requested column. (See the listing in Example 16.2,
      lines 173–183.)
             The return value for getValueAt() is an Object. Here’s one situation
      where that is very useful. Refer to the definition of the Account object and
      you’ll see that getName() returns a String, but getOwner() returns a User
      and getTotal() returns an SAMoney object. Since retval is the most generic
      type, Object, it can handle all three results.
             But how does JTable deal with these odd types? How can it display an
      SAMoney object when it doesn’t know what one is? There is both a simple and
      a complicated answer to that question; we’ll try to give you both.
      16.7.2.9 Renderers
      The simple answer is that JTable, to display the data returned by
      getValueAt(), will call the toString() method on the object. As long as we
364               Chapter 16   Getting in the Swing of Things: Designing a GUI for BudgetPro
    return an object which has a toString(), we’re fine. Both User and SAMoney
    do have such a method, so they fit fine here.
         The more complex answer has to do with why JTable calls the
    toString() method at all. The JTable uses, behind the scenes, a complex
    table cell display mechanism, called a table cell renderer. A renderer is an object
    that displays data in a certain way. Each table cell renderer returns a GUI
    component, and if you don’t want to use the default renderer, you can define
    your own table cell renderer for your table. This allows you to display almost
    anything you can imagine inside a table’s cell. The renderer acts as a template
    for those cells and will be called upon with the result of the getValueAt(),
    along with a few more parameters, so that it can build and display the
    resulting cell.
         Let’s revisit our simple explanation above, in light of the concept of a
    renderer. The default cell renderer for a JTable uses just a JLabel. When
    called upon, the default cell renderer is given the object returned by
    getValueAt() and the renderer fills its JLabel by calling its setText()
    method, passing in the result of toString() on the given object. That’s how
    toString() got called on all our results. You can explicitly set a different
    renderer using the setDefaultRenderer() method on JTable.
         In the Javadoc for Swing table objects we find this interface:
    public Component
    getTableCellRendererComponent(JTable table,
                                            Object value,
                                            boolean isSelected,
                                            boolean hasFocus,
                                            int row,
                                            int column)
         This tells us that if we want to write a class which can act as a renderer, it
    needs to implement this method. The method will be called with the value
    returned by getValueAt(), but the row and column (and table) will be
    repeated here in case your renderer cares. For example, having the row and
    column would allow you to create a table with the third column of the table
    in green—your method could check the column number, and if it is 2
    (columns are numbered 0, 1, 2, . . . ) set the background color to green for the
    Component that you would return.
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                                365
      JLabel retval = new JLabel();
      // ...
      if (row == 2) {
             retval.setBackground(Color.GREEN);
      } else {
             retval.setBackground(Color.WHITE);
      }
      return retval;
             The full implementation of a renderer can also take into account whether
      or not the cell is selected and/or has focus. This has to do with enabling mouse
      clicks to select either that particular cell or the row or column containing that
      cell. You will likely want to render the cell differently (with a darker color,
      perhaps) to show that it has been selected. Whatever the renderer, you set up
      and then return a GUI component whose attributes (font, color, size, and
      so on) are used to display that cell.
             We hope you get the idea—there is a lot more to renderers than we will
      cover here. The Java Tutorial covers them more, and the Javadoc pages have
      some introduction, too.
             Similar to renderers are editors. When a user clicks in a table cell, the table
      may allow him or her to edit its contents. A cell editor is needed to do that,
      and then your program needs to do something with the value that was entered.
      For our BudgetPro example we avoid this complexity by disallowing the user
      to enter anything into the table—our table is for display only. We do this on
      lines 187–191 by overriding the method isCellEditable() to always return
      false:
      187             public boolean
      188             isCellEditable(int row, int col)
      189             {
      190                return false;
      191             } // is CellEditable
             Notice that the method is passed the row and column means that you
      could make some cells editable and some not.
      16.7.2.10 Selection Listeners
      Let’s look at the last part of the table that we implement for BudgetPro:
      194        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
366                Chapter 16   Getting in the Swing of Things: Designing a GUI for BudgetPro
          This call tells our table (list) that we want to allow the user to select only
    a single row or column at a time. Valid options are:
    ListSelectionModel.SINGLE_SELECTION
    ListSelectionModel.SINGLE_INTERVAL_SELECTION
    ListSelectionModel.MULTIPLE_INTERVAL_SELECTION
          The latter two allow the user to select more than one row at a time; multi-
    ple intervals mean that the selected rows can be discontinuous. (Think
    “Shift+click” versus “Control+click” as the user action that selects these.)
          So what will our program do, once the user has made a selection? The se-
    lected row is a subaccount of the current account and we will allow the user to
    display that account and its subaccount, if any. Think of it as “changing
    directory” into that account, to look at or change its status.
          For a table to take an action when a selection is made you need another
    listener called a selection listener. We wrote:
    196       list.getSelectionModel().addListSelectionListener(
    197          new ListSelectionListener()
    198          {
    199             public void
    200             valueChanged(ListSelectionEvent e)
    201             {
    202               ListSelectionModel lsm =
                                                 (ListSelectionModel)e.getSource();
    203               if (lsm.isSelectionEmpty()) {
    204                     view.setEnabled(false);
    205               } else {
    206                     view.setEnabled(true);
    207               }
    208             } // valueChanged
    209          }
    210       );
          Similar to how a table has a table model behind it, it also has a selection
    model behind it. We don’t need to reimplement an entire selection model; we
    just retrieve the default one from our table (list.getSelectionModel())
    and add a listener to it so that it will notify us when something has changed.
          The javax.swing.event.ListSelectionListener is an interface with
    only one method, so it’s easy to extend and override it in place, as we do, begin-
    ning at line 197. When called, it will be handed an event (e) and we take the
    source of that event and coerce it to a ListSelectionModel. That’s safe to
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                              367
      do here because it can’t be any other type of event—or we wouldn’t have been
      called. All we’re doing with it is checking to see if the user just selected or dese-
      lected something. The only action we take is to enable or disable the view
      button.
             Deep inside the cdaction object is a line that does the real action that
      we’re after with our selection. It says:
      61          int row = list.getSelectedRow();
             This shows that a JTable (list) has a method, getSelectedRow(), which
      will return the row number of the row that the user has selected (that is,
      clicked on). This is all part of the action listener (defined on lines 54–75 of
      BudgetPro) for the View Subaccount button.
      54      private ActionListener cdAction = new ActionListener()
      55      {
      56        public void
      57        actionPerformed(ActionEvent e)
      58        {
      59          // this is the action for VIEW subdirectory;
      60          // a "cd" into the subaccount.
      61          int row = list.getSelectedRow();
      62          // System.out.println("Row="+row); // DEBUG; TODO: REMOVE
      63          if (row > -1) {                    // only if a row was selected
      64             String subname = (String) model.getValueAt(row, 0);
                                                                       // name column
      65             Account next = current.getSub(subname);
      66             if (next != null) {
      67               current = next;
      68               // System.out.println("cd to:"+current.getName());
      69               setStatus();
      70               // notify the table, too
      71               model.fireTableDataChanged();
      72             } // TODO: else infodialog or Beep.
      73          }
      74        }
      75      } ;
             With the row number in hand, the actionPerformed() method can
      then use the row number to look up the account name. Since the account name
      is in the first column (numbered 0) of our table, we call getValueAt(row, 0)
      to get that name. Then we give the name to the current account to look up the
      subaccount (line 65).
368                Chapter 16   Getting in the Swing of Things: Designing a GUI for BudgetPro
          As long as this returned Account is not null (line 66), we can make it the
    current account (line 67). At that point the display needs to be updated, so we:
    1) call our own setStatus() method, to update the upper portion of our
    GUI, and 2) tell the table that its data has changed (line 71).
    16.7.2.11 Ready, aim, fire!
    A word about the fire...() methods. They are not part of the TableModel
    interface definition. Rather, they are part of the AbstractTableModel class.
    When a Java class is declared abstract it means that some methods need to be
    implemented by those classes that use (extend) this class. An abstract class can
    still have lots of intact, completely implemented methods, and that is the case
    with AbstractTableModel.
          The TableModel interface defines methods for adding and removing lis-
    teners. Any implementation of the TableModel interface needs to support
    these, and to notify any listeners when a change occurs. Such listeners will re-
    ceive a call to their tableChanged() method when such a change occurs. But
    it doesn’t tell us how such notification is triggered. Moreover, the change event,
    when received by the listener, needs to define the extent of the change—just a
    single cell? a whole row? a column? all columns? and so on.
          The AbstractTableModel provides some methods for us to call when a
    change in the data has occurred, methods that will then notify all the registered
    listeners (Table 16.1). Moreover, it has different methods depending on the
    extent of the change, so that the TableModelEvent, sent to all
    TableModelListeners, can be constructed with the appropriate definition of
    what has changed.
          We used (line 71) the fireTableDataChanged() since the content of
    the table will change with a change of accounts, but the structure remains the
    same. It is also a handy all-purpose method for you to use if you’d rather not
    add the complexity of determining which rows have changed to your code.
          Finally, remember that anyone who uses (extends) AbstractTableModel,
    including the DefaultTableModel class, gets these methods for their use.
          There are several other interactions that are supported by JTables, ones
    that don’t require you to do anything to provide them to your application’s
    end user. When running the BudgetPro GUI, did you try to drag the column
    headings? You can also rearrange and resize columns. This is the default behav-
    ior for JTables. You can turn it off, however, if you want your columns to
    be fixed:
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                                  369
      Table 16.1 AbstractTableModel methods for data change notification
        Method                                             When to use
        fireTableCellUpdated(int row, int col)             Use when only a single cell has
                                                           changed.
        fireTableRowsUpdated(int first, int last) Use when the given range of rows
                                                           (inclusive) have changed.
        fireTableRowsDeleted(int first, int last) Use when the given range of rows
                                                           (inclusive) have been deleted.
        fireTableRowsInserted(int first, int last) Use when the given range of rows
                                                           (inclusive) have been inserted.
        fireTableDataChanged()                             Use when any/all of the row data
                                                           have changed, including the
                                                           number of rows; columns have
                                                           not changed.
        fireTableStructureChanged()                        Use when the columns have
                                                           changed—that is, when the
                                                           names, number, or types of
                                                           columns have changed.
        fireTableChanged(TableModelEvent e)                An all purpose method, where
                                                           you have to define the change in
                                                           the TableModelEvent object.
      table.getTableHeader().setResizingAllowed(false);
      table.getTableHeader().setReorderingAllowed(false);
             The call is not made on the table directly, but rather on its header. We get
      the JTableHeader object with the call to getTableHeader(). There is much
      more that could be said about JTableHeader objects, but we will leave that
      “as an exercise for the reader”; we’ve got to draw the line somewhere.
      16.7.2.12 Scrolling
      One last thing to mention about the createList() method is how we deal
      with tables that are larger than the viewing area. This is typically done with a
      scroll pane, a GUI element familiar to anyone who has used a word processing
      program. Such scrolling is accomplished in Swing by putting the potentially
      big object, such as our table, into a JScrollPane container.
370                Chapter 16    Getting in the Swing of Things: Designing a GUI for BudgetPro
          Don’t think of it as adding scrollbars to the table. Rather, we’re putting
    the table into a container that has scrollbars, and this container is smart enough
    to retrieve and display the table’s header separately from the table (thus, the
    table’s data scrolls but the header stays put).
          Here, in one step, we create the JScrollPane object and initialize it with
    the JTable that we want to be scrolled over.
    212         retval = new JScrollPane(list);
          Think of the JScrollPane as a window with scrollbars through which
    we can view the JTable. It has the convenient side effect of taking care of the
    table’s heading for us. Without the scroll pane (e.g., if we just put the JTable
    in a JPanel) we’d get only the data and no heading, unless we also did a lot of
    extra work using other objects and method calls.
          It is possible to set the JScrollPane to show horizontal as well as vertical
    scrollbars. Those scrollbars can be made to be always or never visible, or visible
    only as needed. Setting a scrollbar to “never visible” effectively turns off any
    scrolling in that direction. Use the setHorizontalScrollBarPolicy() and
    setVerticalScrollBarPolicy() methods to set the value to one of:
    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED
    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
    JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS
          Scroll panes can scroll over any GUI element—that is, any Component
    object, not just tables. For more information on scroll panes, be sure to refer
    to the Javadoc pages.
    16.7.2.13 Dialogs
    We have covered most of the code in the main GUI functionality—the way it
    initially creates its parts and lays them out for display. We have examined the
    JTable in some considerable detail and looked at a few actions associated with
    buttons. Now we need to get to the user interaction that allows us to create a
    new account.
          Lines 244–268 of BudgetPro are the action that gets attached to the
    button for creating a new subaccount.
16.7 Getting Down to Cases: Designing a GUI for BudgetPro                             371
      244         ActionListener creatAction = new ActionListener()
      245         {
      246            public void
      247            actionPerformed(ActionEvent e)
      248            {
      249              Account child;
      250              // get the info via a Dialog (of sorts)
      251              if (askem == null) {
      252                  askem = new AcctDialog(frame, "New Subaccount");
      253              } else {
      254                  askem.clear();
      255                  askem.setVisible(true);
      256              }
      257              String subName = askem.getName();
      258              String subAmnt = askem.getAmnt();
      259
      260              // if empty, assume the operation was cancelled, else:
      261              if ((subName != null) && (subName.length() > 0)) {
      262                  child = current.createSub(subName, subAmnt);
      263                  setStatus();
      264                  model.fireTableDataChanged(); // notify the table
      265              }
      266            }
      267         };
      268         creat.addActionListener(creatAction);
             Looking at the constructor for an Account, we see that we need three
      things: a User object (who will own the subaccount), a name for the new sub-
      account, and the dollars to be allocated to this subaccount. To keep our exam-
      ple simpler, we will always use the current user as the User for creating the new
      Account. That means we only need some way to get the name and dollar
      amount.
             In the GUI world, this sort of information is typically provided in a dialog
      box, a window that has blanks to be filled in (Figure 16.5). Then, when the
      dialog is closed, we can ask that dialog for the values that the user provided.
             Swing has some ready-to-use dialogs for warnings or for simple single value
      inputs. Since we want to get two pieces of data, we need to create our own
      dialog and display it.
             What may seem strange about the createAction() is that we only create
      the dialog once (line 252), when the reference to it (askem) is null (line 251).
      Thereafter, we simply clear out the previous values (line 254) and make the
      dialog visible again (line 255). That is all that it takes to use the dialog more
372               Chapter 16    Getting in the Swing of Things: Designing a GUI for BudgetPro
    Figure 16.5 Dialog for creating a new subaccount
    than once. We could throw away the dialog (or let it get garbage-collected) by
    declaring it internal to the actionPerformed() method. Then on each button
    press the dialog would need to be recreated. Well, it’s slower to do it that way,
    and for a button click we want quick response—so we keep it around from one
    use to the next. When the user closes the dialog, all that really does is makes it
    invisible; to reuse it, we make it visible again.
          Notice, too, that in either case—creating the dialog or making it visi-
    ble—control does not return to our method until the user has dismissed the
    dialog. That’s because it’s a modal dialog, one that allows no other interaction
    with the application until the user has responded to this dialog.
          The dialog is dismissed (finished, ended, put away) simply by making it
    no longer visible. For example:
    73            dialog.setVisible(false);             // go away
          New to our application, in AcctDialog, is the JTextField. On lines 22
    and 23 we declare two of them, one for the account name and the other for the
    amount.
    22       nameField = new JTextField(25);
    23       amntField = new JTextField(9);
          The size that we pass in to the constructor is the number of characters; it
    sets a maximum for that field, but also gives a clue to some layout managers as
    to how big the field needs to be.
          Speaking of layout managers, we use a few here, including a BoxLayout,
    to format the buttons relative to each other; a BorderLayout, to hold the
    overall dialog; and a newer layout manager, the SpringLayout, which is new
    as of Java 1.4. The Swing Tutorial provides a handy utility class for dealing
16.8 Review                                                                          373
       with SpringLayouts, and we make use of it to format the labels and text fields
       relative to each other.
             Similar to a JTextField is a JPasswordField. It behaves just like a
       JTextField but instead of showing the characters that the user types it shows,
       by default, an asterisk for each character typed, thereby hiding the password
       from passers-by. The character that is displayed can be changed to other than
       the asterisk—see the Javadoc page.
             We do something new with our JLabel in AcctDialog, too. We mess
       with its font:
       44       Font font = label.getFont();
       45       label.setFont(label.getFont().deriveFont(font.PLAIN, 14.0f));
             This gets the font from the label, however it might have been set, then
       creates a new value for the font, keeping whatever font family it might have
       been, but making it 14 pt plain (not italic, not bold).
             We also put HTML text in the JLabel:
       40       JLabel label = new JLabel("<html><p align=left><i>"
       41                          + "Enter the info to create a subaccount.<br>"
       42                          + "</i>");
             All but the oldest versions of Swing will display the HTML text as it would
       be formatted by a browser. Here, we make the text italic by means of the (now
       deprecated) <i> tag, thereby undoing the effort to make it plain in lines 44
       and 45.
             One of the arguments to the dialog’s constructor is the JFrame inside
       which the dialog will appear. Lines 102 and 103 round out this picture, setting
       the size of the dialog and anchoring its position relative to the parent frame.
       The last step for the constructor is to make the dialog visible, thereby passing
       control to it.
 16.8 REVIEW
       When programming in Swing, we create the GUI objects and then let Swing
       do the work of managing all the interactions. We created:
374                Chapter 16    Getting in the Swing of Things: Designing a GUI for BudgetPro
         • Containers to hold GUI objects, such as JFrame for our outermost win-
           dow, JPanel for an assortment of objects, and JScrollPane for viewing
           larger objects through a scrollable window.
         • Labels (JLabel class) to hold either a short bit of text, or an image, or
           both; it can even take snippets of HTML, for fancier formatting and
           coloring of text.
         • Buttons (JButton class) to which we attached actions—the code frag-
           ments that get called when the buttons get pushed; a button could have
           text and/or an image displayed in it.
         • Actions—whether for buttons or selections (or other triggers yet to be
           discussed), an action is the code that runs when the event (e.g., button
           press) occurs.
         • Text fields (JTextField class) to take small amounts of user input; our
           application didn’t need the other types of text fields (JTextArea and
           JTextPane) useful for much more extensive user input.
         • A JTable instance and its associated TableModel, SelectionModel, and
           TableCellRenderer which provide tremendous flexibility and control
           over table behavior and contents.
         • A JDialog instance with custom content, to allow for multiple user in-
           puts; the dialog comes and goes with its visibility; since it’s a modal dialog,
           when it is visible, it “hogs” all the user interactions; it is possible to make
           nonmodal dialogs, but our application didn’t need to.
         • LayoutManagers for our JFrame and JPanels, used to place objects
           within a container with various algorithms for placement and expansion.
 16.9 WHAT YOU STILL DON’T KNOW
      One could spend a career learning the vagaries of layout managers, especially
      the way they interact (e.g., a BoxLayout inside the various regions of a
      BorderLayout). There is still an art to getting all the interactions right; it’s
      often quickest to prototype the layout before you get too committed to a par-
      ticular layout. Also, putting objects into containers can help you subdivide the
      layout problem into more manageable pieces. You can even go so far as to write
      your own LayoutManager, a topic we do not cover in this book.
           The information that we display in the JTable in our example is hierar-
      chical. Swing provides a JTree object for displaying such information. Like a
16.11 Exercises                                                                      375
       filesystem tree familiar to many PC users, the JTree allows you to view multi-
       ple levels at once and to open and close nodes, exposing or hiding their subtrees.
       It would make more sense to use the JTree in our example, but then we
       wouldn’t have been able to describe all the ins and outs of the JTable, a class
       that is so useful in so many applications.
             There are many more Swing classes that we haven’t discussed, though
       many will behave similarly to those you have seen here. There are topics that
       we have avoided—for example, we haven’t talked about sorting JTables by
       clicking on the column headings, or about TableColumnModels which add
       another layer to JTables. Some of what you would need to know in order to
       use these Swing classes you can glean from the Javadoc pages. The information
       there should make more sense now, based on your experience with the various
       Swing mechanisms that you’ve seen in these pages. For some other Swing topics
       you will have to search farther, and there are plenty of books on the topic—the
       classic one, the The JFC Swing Tutorial from Sun, being over 900 pages long.
       Is it any wonder that we didn’t cover it all in this chapter?
16.10 RESOURCES
          • The JFC Swing Tutorial: A Guide to Constructing GUIs by Kathy Walrath
             and Mary Campione, Addison-Wesley, also available online at
             http://java.sun.com/docs/books/tutorial/uiswing/index.html.
          • Our favorite bookmark within the Swing tutorial, the visual index of the
             various Swing components, is at http://java.sun.com/docs/books/
             tutorial/uiswing/components/components.html.
          • If you want a better understanding of layout managers, we recommend
             this tutorial by Jan Newmarch at Monash University in Australia:
             http://pandonia.canberra.edu.au/java/xadvisor/geometry/
             geometry.html. Don’t let the mention of AWT scare you away. Almost
             all of the layout managers (except BoxLayout and SpringLayout) are
             actually from AWT, and they all apply to Swing.
16.11 EXERCISES
         1. Use different layout managers to create of the status area of the BudgetPro
             main window, laying out the status information differently. Make the
376             Chapter 16  Getting in the Swing of Things: Designing a GUI for BudgetPro
       button and account name information left-justified, and stack the Total
       and Remaining labels vertically on top of each other. Do you always need
       to create new intermediate containers? Can you do it just with
       GridBagLayout?
    2. Modify the BudgetPro program so that it displays a pop-up dialog when
       you try to create a subaccount with more money than is available to that
       account.
    3. Modify the dialog used for creating subaccounts, so that it also prompts
       for the owner’s name. This can get more complicated if you want to allow
       only valid user names. Instead, let any name be entered and create a User
       object for it.
    4. Modify the BudgetPro program and associated classes to allow for editing
       of the values in the accounts, so that the user can change dollar allocations.
       Start with the ability to edit the value in the table (custom editor).
    5. Replace the JTable (and the View Subaccount button) with a JTree
       object.
     Chapter 17
     Other Ways:
     Alternatives to Swing
     In which we discover that Swing is not the only GUI game in town. In so doing
     we learn the rudiments of the Standard Widget Toolkit and we describe some
     of the key limitations of this alternative toolkit.
17.1 WHAT YOU WILL LEARN
     This chapter will introduce the basic classes of SWT, the Standard Widget
     Toolkit, which is an alternative GUI library developed mainly for the Eclipse
     Java IDE.1 Development of Eclipse has been led primarily by IBM.2
     1. http://www.eclipse.org/
     2. http://www.ibm.com/
                                                                               377
378                                                   Chapter 17     Other Ways: Alternatives to Swing
 17.2 THE IBM SWT TOOLKIT
      The Standard Widget Toolkit is a complete GUI library for Java, completely
      independent of Swing and AWT. It is implemented as a library of native
      methods, so it cannot be ported to any Java runtime unless that platform has
      the native part of the SWT library implemented for it.
      17.2.1 Another GUI Toolkit. Why?
      The first question one should ask, perhaps, is why create an alternative GUI?
      Good question. The answer, according to the SWT FAQ,3 primarily has to do
      with execution speed and look-and-feel similarity to native GUI applications
      on each platform.
             If we may editorialize, we find neither reason particularly compelling, al-
      though the execution speed argument made some sense when the Eclipse
      project started. Swing is unlikely to win any performance awards, even though
      each version brings some improvements in speed.4 Still, these reasons do not
      seem particularly compelling for such a large duplication of effort and function-
      ality.
             Whatever the reason, SWT exists. SWT works by providing a thin abstrac-
      tion layer over native GUI features. It is a small GUI library. It is implemented
      using the Java Native Interface, so it requires that a native binary library be
      implemented for your platform. Fortunately, such implementations exist for
      all platforms Eclipse runs on. So if you can run Eclipse, you can write and run
      SWT applications.
      3. http://dev.eclipse.org/viewcvs/index.cgi/~checkout~/platform-swt-home/
      faq.html
      4. The question of speed in Java is a rather tired argument. If maximum speed is a primary
      concern, Java is probably not your first choice of a development language. In our experience,
      speed is something everybody says they need, but more often than not other considerations
      such as development time and error rate are much more important. Java is fast enough for vir-
      tually all MIS applications, and that is the market Java is squarely aimed at. Our computers
      keep getting faster, disk drives and memory keep getting cheaper. The “resource” and “perfor-
      mance” arguments only apply to applications where experienced designers would already have
      chosen C or assembly language. Besides, with the JIT compilers in both Sun’s and IBM’s JDKs,
      a well-written Java application is often as fast or faster than some other compiled languages, at
      least on the second run of the code.
17.2 The IBM SWT Toolkit                                                                              379
       17.2.2 Duplicated Effort. Why Cover It?
       The next logical question is, “If you think SWT is unnecessary with Swing al-
       ready there, why cover it in your book?” Also a sensible question. The answer
       is that there is very little published literature on this library (a notable exception
       being Chapter 10 of The Java Developer’s Guide to Eclipse by Shaver et al., from
       Addison-Wesley). Also, SWT provides the only fully functional GUI library
       that will work with the GNU Compiler for Java. As such, it is a major required
       component if you wish to write native compiled GUI applications on Linux
       systems.
              Of course, there is another reason. Anyone heavily into Linux is well aware
       of the political and philosophical debate about Free Software and Open Source.
       If the core values of Free Software are critical for you, you should be aware that
       the IBM Common Public License5 under which Eclipse (and thus SWT) are
       published is a Free Software license. You get the source code, you may use it
       in your own products, and it imposes obligations similar to the GNU GPL,6
       but goes even further by requiring you to grant royalty-free licenses for any
       patents you hold in derivative works.
              So you might choose SWT (or not) for political or philosophical reasons.
       Both authors still suggest Swing first because it is the official Java GUI library.
       When an employer wants to know if you can write a Java GUI application, he
       or she almost certainly means a Swing application. Philosophy is great, but it
       may not put the food on your table. You need to know that Swing is not Free
       Software (and neither is either of the major Java SDKs), and SWT is Free
       Software, but it is up to you to decide what best serves your interests.7
       5.  http://www.eclipse.org/legal/cpl-v10.html
       6.  http://www.gnu.org/licenses/gpl.html
       7. A lot of people couldn’t care less about the Free versus non-Free issue, but I must say that
       many of my most interesting workplace discussions have arisen from this issue. It is the first
       issue in my career that has had programmers talking about the balance between their personal
       interests, their employers’ interests, and the public interest. Wherever you stand philosophically,
       I think it is good that programmers are thinking about the consequences of their work at all
       of these levels. I wish there were more pressure at all levels of business to consider and balance
       all of these interests.
380                                           Chapter 17 Other Ways: Alternatives to Swing
    17.2.3 Portability: Better and Worse
    How about portability? Well, it depends on what “portability” means to you.
    If portability means “looks and runs the same on all platforms,” then Swing
    offers better portability. If portability means “runs on all platforms for which
    there is a Java runtime,” then Swing offers better portability. If portability
    means “looks like a native application on all supported platforms,” then SWT
    is your choice. Make your selection accordingly.
         TIP
         The bottom line: If you only learn one Java GUI, make it Swing.
    17.2.4 The Rest of the Chapter
    The rest of this chapter will be devoted to describing the basic classes of SWT
    by converting one of the application classes from the previous chapter from
    Swing to SWT. We will not attempt to explain the operating principles of
    GUIs. For an introduction to GUI programming, see the previous chapter on
    Swing. It introduces the concepts and programming principles for GUI
    programming in Java. SWT is functionally similar, although quite spartan,
    providing only basic windows, controls, and events.
         Eclipse also contains a family of higher level user interface classes, known
    collectively as JFace, that provide UI features such as dialogs, wizards, font
    handlers, and images. We will not cover JFace in this book.
    17.2.5 SWT: Close to the Metal
    SWT breaks some of the Java contract. For example, you cannot rely on garbage
    collection to clean up SWT objects. Any SWT object you create with new must
    be explicitly destroyed with a call to the dispose() method. Why? Since SWT
    is implemented with native methods, the low-level implementation allocates
    native OS data structures and objects that must be explicitly freed. Since the
    Java garbage collector cannot be relied upon to collect objects at a certain time
    (or ever, for that matter), these allocations can result in memory leaks and
    address space conflicts. As we shall see, however, SWT is well designed to
    minimize the amount of this that you need to worry about.
         SWT is also close to the metal in the sense that it does not abstract the
    underlying message-based event system that drives both X Window and
17.2 The IBM SWT Toolkit                                                                           381
       Microsoft Windows. If you have ever written an X Window or Microsoft
       Windows application in straight C (without a GUI framework library or class
       library), you have written a main() function that contains an event loop. SWT
       actually puts simple method calls around this core message queue event loop.
       We’ll cover the details of this in the next section where we introduce the
       Display and Shell classes.
       17.2.6 “Hello, world” SWT Style
       SWT consists mainly of classes that represent controls—such as buttons, text
       areas, scrollbars, and so on—and layout managers which are much like layout
       managers in Swing. But there are two other classes: Display, which models
       the interface between your Java application and the underlying windowing
       system, and Shell, which effectively represents a single window.
              The application in Example 17.1 is a parallel to the simple Swing program
       in the last chapter (Example 16.1).
              This simple program, like its parallel in the Swing chapter, is deceptive.
       Sure, this is a lot of code to say “Hello, world” but it is because what we are
       setting up here is an event-driven program that must respond to any valid
       user input.
       17.2.6.1 Setting Up to Run an SWT Application
       One advantage of Swing that we haven’t pointed out up to now is that it is part
       of every Java runtime (well, not gcj; more on that later), so you have all the
       classes on your classpath without any special setup. Not so with SWT. The
       exact procedure for setting up to run an SWT application depends on what
       development environment you are using.
              There is an excellent set of directions for running an SWT application
       under Eclipse in the SWT FAQ.8 No matter what your environment is, there
       is a basic series of steps:
          1. Download the Eclipse SDK.
          2. Install it.
       8. http://dev.eclipse.org/viewcvs/index.cgi/~checkout~/platform-swt-home/
       faq.html?rev=1.83content-type=text/html#standalone. Note that this link is to
       the current revision in CVS as of this writing. You should take a look at the parent page to see
       if there is a newer revision.
382                                        Chapter 17 Other Ways: Alternatives to Swing
    Example 17.1 A simple SWT application
    import org.eclipse.swt.*;
    import org.eclipse.swt.layout.*;
    import org.eclipse.swt.widgets.*;
    /**
      * @author mschwarz
      *
      * Sample SWT "Hello, world" application
      */
    public class SWTHelloWorld {
        public static void main(String[] args) {
          Display disp = new Display();
          Shell window = new Shell(disp);
          window.setLayout(new RowLayout());
          Label label = new Label(window, SWT.NONE);
          label.setText("Hello, world.");
          window.setSize(320,160);
          window.open();
          while (!window.isDisposed()) {
            if (!disp.readAndDispatch()) {
              disp.sleep();
            }
          }
          disp.dispose();
        }
    }
       3. Extract the SWT JAR files.
       4. Extract the SWT JNI files.
       5. Configure your development environment.
          Let’s go over these in a bit more detail.
          SWT was developed as a GUI library for the Eclipse project. It is distribut-
    ed as part of Eclipse. There is no official standalone SWT package. The right
    way to obtain SWT is to download and (at least temporarily) install the Eclipse
    SDK. See Section 10.4 for details.
17.2 The IBM SWT Toolkit                                                            383
       Figure 17.1 Running the SWT version of “Hello, world”
            If you have followed our sage advice and downloaded the GTK
       version of the Eclipse SDK, then you need to copy out the SWT JAR files.
       There are two files in the GTK version, and just one in the Motif version. The
       GTK version’s files are swt.jar and swt-pi.jar. They are both in the
       eclipse/plugins/org.eclipse.swt.gtk_2.1.2/ws/gtk directory. You
       will need to have both of these JAR files on the classpath of any SWT
       application you are compiling or running.
            Remember that SWT is a JNI library. You must also have the native Linux
       shared libraries. These need to be made available to the Java native loader. The
       files you need are located in the eclipse/plugins/org.eclipse.swt.
       gtk_2.1.2/os/linux/x86 directory. The .so files there must be available to
       any running SWT application. There are a couple of ways to do this. First, as
       described in Section 5.7, you can set the LD_LIBRARY_PATH environment
       variable. You also can use the -D parameter for the runtime VM to set the
       java.library.path property.
            If you want to, you can copy these files out of the eclipse directory to
       some other location and then erase the eclipse directory with the lovable old
       standby, rm -rf eclipse.
            Oh, by the way, once you have compiled the sample code above and set
       your classpath and Java library path correctly, running the application produces
       the window shown in Figure 17.1.
       17.2.6.2 Anatomy of an SWT Application
       Before we launch into this discussion, we should point out that the Javadoc
       documentation for all SWT packages is available as part of the Eclipse Platform
384                                           Chapter 17  Other Ways: Alternatives to Swing
      documentation.9 You might want to use that resource along with this
      lightweight tutorial to fill in the gaps and shortcuts.
            It should not be too surprising that there are similarities between SWT,
      AWT, and Swing. They all take different approaches to solving the same
      problem, namely how to control the complexity of a graphical event-driven
      application. Because the problem is the same, there can’t help but be similarities
      between different solutions. By now you may have deduced that the Shell
      class is an analog to the JFrame class, and that SWT uses a system of layout
      managers not too different from Swing. If so, you are on the right track and
      well on your way to using SWT.
            If we had to summarize the difference in approaches between SWT and
      Swing, it would be that SWT tries to provide a small number of complex
      classes, and Swing tries to provide a large number of simpler classes. Obviously,
      this is a generalization, but everybody generalizes. Sorry.
            The Display is a class that provides the link to the underlying GUI sys-
      tem. Think of it as an abstraction of the interface to the windowing system. In
      almost all cases, an SWT application will have exactly one instance of Display.
            The Shell class represents a window. This class descends from a series of
      abstract parent classes, so if you look at the Javadoc for Shell and think it is
      simple, be sure to drill down into those parent classes! We’ll discuss Shell quite
      a bit more as we go along.
 17.3 PORTING BUDGETPRO TO SWT
      The conversion of an existing application is a complex process. Always consider
      rewriting from scratch. Still, it is worthwhile to show an application converted
      from Swing to SWT, because it will emphasize the relationship between
      the two.
            We begin with the reobjecting. Starting with the BudgetPro class, we
      need to add an instance of the Display class. Then the JFrame becomes a
      Shell. Likewise, the JLabels become Labels. Then . . . Wait a minute. You
      don’t need a blow-by-blow account. Maybe it would be simpler to show you
      what SWT classes roughly correspond to the equivalent Swing classes
      (Table 17.1).
      9. http://download.eclipse.org/downloads/documentation/2.0/html/plugins/
      org.eclipse.platform.doc.isv/reference/api/
17.3 Porting BudgetPro to SWT                                                                   385
       Table 17.1 Major SWT widgets and their Swing equivalents
        SWT widget      Analogous Swing           Description
                        component
        Button          JButton                   Display widget that sends notification when
                                                  pressed and/or released.
        Canvas          java.awt.Canvas,          Composite widget that provides a surface for
                        but see also              drawing arbitrary graphics. May be used to
                        java.awt.Graphics2D       create custom widgets.
        Caret           javax.swing.text.Caret A cursor used as the insertion point for text.
        Combo           JComboBox                 Widget that permits the user to choose a
                                                  string from a list of strings, or to enter a new
                                                  value into a text field.
        Composite       JPanel                    Widget that is capable of containing other
                                                  widgets.
        Group           JPanel                    Composite widget that groups other widgets
                                                  and surrounds them with an etched border
                                                  and/or label.
        Label           JLabel                    Nonselectable widget that displays an image
                                                  or a string.
        List            JList                     Selectable widget to choose a string or strings
                                                  from a list of strings.
        Menu            JMenu                     User interface widget that contains menu
                                                  items.
        MenuItem        JMenuItemA,               Selectable widget that represents an item in a
                        JCheckboxMenuitem,        menu.
                        JRadioButtonMenuitem
        ProgressBar JProgressBar                  Nonelectable widget that displays progress to
                                                  the user.
        Scale           JSpinner                  Widget that represents a range of numeric
                                                  values.
        ScrollBar       JScrollPane               Widget that represents a range of positive
                                                  numeric values. Used in a Composite that
                                                  has V_SCROLL and/or H_SCROLL styles. The
                                                  mapping to Swing is not very tight here, since
                                                  JScrollPane is like a combination of
                                                  Composite and ScrollBar.
386                                       Chapter 17    Other Ways: Alternatives to Swing
    Table 17.1 (Continued)
     SWT widget      Analogous Swing        Description
                     component
     Shell           JPanel                 Window that is managed by the OS window
                                            manager. A Shell may be a child of a
                                            Display or another shell.
     Slider          JSlider                Widget that represents a range of numeric
                                            values. Differs from a Scale by having a
                                            “thumb” to change the value along the range.
     TabFolder       JTabPane               Composite widget that groups pages that can
                                            be selected by the user using labeled tabs.
     TabItem         Any JComponent         Selectable user interface object corresponding
                                            to a tab for a page in a tab folder.
     Table           JTable                 A selectable widget that displays a list of table
                                            items that can be selected by the user. Rows
                                            are items, columns are attributes of items.
     TableColumn JTableColumn               Selectable widget that represents a column in
                     or instance of         a table.
                     TableColumnModel
     TableItem       TableCellRenderer or   Selectable widget that represents an item in a
                     TableCellEditor        table.
     Text            JTextField,            Editable widget that allows the user to type
                     JPasswordField,        text into it.
                     JFormattedTextField,
                     JTextArea,
                     JEditorPane, JTextPane
     ToolBar                                Composite widget that supports the layout of
                                            selectable toolbar items.
     ToolItem        JButton                Selectable widget that represents an item in a
                                            toolbar.
     Tree            JTree                  A selectable widget that displays a hierarchical
                                            list of user-selectable tree items.
     TreeItem        MutableTreeNode        Selectable user interface object that represents
                                            a hierarchy of items in a tree.
17.3 Porting BudgetPro to SWT                                                           387
             We are going to walk you through converting only one of the GUI source
       files for the BudgetPro application. We will leave converting the rest as an exer-
       cise for you. We’ll talk about some of the entertaining differences between the
       models. As you shall see, there is no clear “winner” here between SWT and
       Swing. Almost all technical choices—SWT versus Swing, Java versus C++,
       Emacs versus vi, or for that matter UNIX versus Windows—are tradeoffs. This
       is no exception. There are things we like about SWT. For simple GUI applica-
       tions, we think it is easier to set up and use. We think it is easier to learn in its
       entirety than Swing. Swing, on the other hand, is more complete, offering
       classes that will do more than SWT. So the best solution depends (as always)
       on your requirements.
       17.3.1 Step 1: Convert the Class Members
       We are going to tackle converting BudgetPro.java from Swing to SWT. In
       real life, this is an exercise you are unlikely to have to carry out. You will more
       likely write your GUI applications from scratch. But going through the conver-
       sion provides a useful roadmap for talking about the architecture of SWT; it
       teaches you SWT in terms of a class library with which you are already familiar.
             First off, we change the packages imported at the start of the file. Remove
       all of the awt and swing packages. If you are using an IDE, this should flag
       every single line of code that touches the GUI as an error. This can be a big
       help when you are doing a mass conversion like this. When you have killed all
       the compile errors, you know you are well on your way to completing the
       conversion.
             Replace the import statements with the imports you are likely to need for
       your SWT application. These are:
       import org.eclipse.swt.*;
       // The static SWT class, which contains a number of constants.
       import org.eclipse.swt.widgets.*;
       // The widgets library. Almost all your display elements are here.
       import org.eclipse.swt.events.*;            // Event handlers
       import org.eclipse.swt.layout.*;            // Layout managers
             We will go into these families of classes in more detail as we convert the
       members and methods of BudgetPro.java.
388                                               Chapter 17  Other Ways: Alternatives to Swing
          The next step is to convert the GUI members of the class from the Swing
    classes to their SWT counterparts. Of course, SWT requires the Display class,
    which has no analog in SWT, so we add a Display type member named disp
    just ahead of the frame member.
          Next, we change the type of frame from JFrame to Shell. We could re-
    name the member,10 but why add to our typing burden? The name is still clear
    and meaningful, even if it doesn’t match the SWT name.11 There’s more to it
    than just changing the type, however. The constructor call for the JFrame
    doesn’t match any constructor for Shell. In fact, the Shell constructor re-
    quires a Display object argument, and all subsequent constructors for widgets
    and controls require a Composite as an argument.
          This is a key difference between Swing and SWT. Swing allows you to
    build GUI components in arbitrary order at arbitrary times and then join them
    up to the GUI with an add() method call. SWT instead requires that you link
    your components up to the GUI element they belong to when they are construct-
    ed. There are good reasons for this difference. Remember that SWT allocates
    native objects and memory that Java’s garbage collector cannot recover. Because
    of this, SWT makes the promise that if you call the dispose() method on any
    SWT object, it will dispose of it and everything it contains. That allows you to
    clean up all resources from an SWT program by calling dispose() on the top
    level Display object. If SWT allowed you to build GUI structures indepen-
    dently and then graft them onto the hierarchy, it could not keep this promise.
    For this reason (amongst others) SWT objects are always built in a fairly rigid
    top-down manner.12
          The most direct consequence of this is that we have to get rid of the con-
    structors on these declarations. We’ll start construction in the main(). So, away
    with the constructors for the GUI elements. We now need to change the
    JButtons to Buttons and the JLabels to Labels. Again, if you are using a
    dynamic IDE, you should see your error count skyrocket with these changes
    10. If you are using Eclipse, this is easily done throughout your code with the Refactoring
    feature.
    11. All right, I’m being lazy. Write your own book if you don’t like it.
    12. In some ways, this greatly simplifies SWT programs, but at the cost of some reusability.
    With Swing, you could construct a panel or other GUI element and reuse it in many places.
    You can achieve the same thing in SWT by encapsulating such a construct in its own class and
    passing in a parent to the constructor, but this is a bit more bulky and complex than the
    Swing way.
17.3 Porting BudgetPro to SWT                                                          389
                                    Key SWT Abstractions
           Composite is one of the key abstractions in SWT. Any control that may
           contain other controls is a Composite.
                Here’s a quick rundown of the key abstract classes and interfaces in
           SWT, along with the basics of the functionality they embody:
              • A Widget is the abstract superclass of all user interface objects in
                SWT. At this level the methods exist that create, dispose, and dis-
                patch events to listeners. Every single class we use in this chapter,
                with the exception of event handlers and layout managers, is a
                Widget.
              • A Control is the abstract superclass of all windowed user interface
                classes. This is almost all of the UI classes, either by direct descent
                or through classes such as Sash or Scrollable. All constructors
                for Control classes require a Composite parent class as a construc-
                tor argument.
              • A Composite is a Control which is capable of containing other
                Controls. One direct descendant of Control which is very similar
                to the Swing JPanel is Group.
                The relationships and the power of these abstractions will become
           clear as you work with real-life examples.
       (well, maybe not really skyrocket, since the import changes have already
       produced a lot of errors right off the bat).
             Finally, we remove the AbstractTableModel member. SWT has a
       simpler (and more limited) table functionality that we will discuss later.
       17.3.2 Step 2: Converting the main() Method
       The main (pun unintended) changes that need to be made here include allocat-
       ing the SWT Display, changing from instantiating a JFrame to a Shell,
       doing away with the Swing “look and feel” stuff (an SWT application always
       looks like a platform-native application, that’s SWT’s main selling point), and
       reworking the construction of the GUI. We’ll explain that a little bit later.
             For now, we take care of the simple changes. Remember that main() is a
       static method, so we do not have any nonstatic class members available right
390                                           Chapter 17 Other Ways: Alternatives to Swing
    now. The original BudgetPro constructor took a JFrame argument, now it
    will have to get a Display and a Shell. So we have to allocate a local Display
    and a local Shell. We also need to add the Display argument to the
    BudgetPro constructor.
          After this is done, we modify the call to the constructor to pass the local
    Display and Shell to our class instance.
          Next, we have to set a layout manager. The original application used the
    Swing BorderLayout layout manager. SWT doesn’t have such a critter.
    Fortunately, the original used only the north, center, and south positions
    of the BorderLayout. SWT has a simple layout manager called a
    FillLayout that puts its contained controls in a single row or column, equally
    sized. Putting the three controls in a column will end up looking much like
    using the north, center, and south of a BorderLayout. So we change the call
    to the frame.setLayout() to pass in a new FillLayout and add the
    SWT.VERTICAL attribute.
                                        The SWT Class
        The SWT class is pretty bare-bones. Its primary use is a library of named
        constants used for attributes to Widget (and other) constructors. You’ll
        see such SWT.xxxx constants all over your typical SWT application.
        There are a handful of methods that the SWT class provides, all of
        them static, including error(), which throws an SWTException,
        getPlatform(), which returns a string with the name of the platform
        on which SWT is running, and getVersion(), which returns an int
        version number.
             It also has a subclass, called OLE, which is a Windows-only class that
        provides ActiveX support for SWT. Obviously, such use is nonportable
        and non-Linux, so we won’t talk any more about it.
          The next block of code in main() sets the Swing look and feel. SWT has
    nothing like this. All SWT applications look like native applications (we seem
    to be saying that a lot), so all of this code may be removed.
          The next block of code calls methods on the application object (app) that,
    in the original, construct the three “chunks” of UI and add them to the frame
    using the BorderLayout attributes. Since, as we explained earlier, all SWT
    controls must be explicitly joined to a parent control when they are constructed,
17.3 Porting BudgetPro to SWT                                                         391
       the separate create-then-add semantics used in the original will not apply. In
       the next section, we will walk through converting one of these three create
       methods. For now, it is enough to know that they will be changed to be meth-
       ods that return void (no return value) and the calls to add() may be deleted.
             That completes the conversion of main().
       17.3.3 Step 3: Converting the GUI build() and init()
                  Methods
       Lest you believe that this means the application is ready to run, just try
       compiling what you have. Got a few errors yet, don’t we?
             Let’s walk through converting the createStatus() method and its relat-
       ed methods. We’ll then briefly discuss converting the createList() and
       createButtons() concentrating on the details of the unique UI widgets used
       in each.
       17.3.3.1 Converting the GUI build() Method
       In BudgetPro, the top part of the UI is the status pane. It consists, basically, of
       three labels. In the original application, this pane is constructed by the
       createStatus() method. In the original, it returns a Swing Component,
       which is then placed by calling add() on a container managed by the caller.
             In SWT, Widgets must be joined to their containers at construction, so we
       must restructure this code a little bit. We create a Group to hold our classes
       together as a unit. We attach the group directly to the parent Shell by using
       the member variable frame. We set the layout manager to be RowLayout.
             We then populate the Group. First, we add the Up button, which is only
       enabled when in a subaccount. While SWT does support image buttons, we
       take the shortcut of using the SWT.ARROW style, bitwise-or’ed with the SWT.UP
       style. Next, we populate the group with our Labels.
             Note a change we will talk about some more below: The listener for
       the Button object called upton is changed. The method is renamed from
       addActionListener() to addSelectionListener(). Event handling in
       SWT is similar to Swing/AWT, but not identical, as we will see when we go
       over the rewrite of the actual event handler code a little later on.
             These are the only changes we make to this method.
392                                               Chapter 17 Other Ways: Alternatives to Swing
          CAUTION
          If a Composite has no layout manager, each Widget in the Composite
          must have its size and position explicitly set, or else their sizes will default to
          zero, and they will all be invisible! Tremendous details on SWT layout manager
          classes can be found in the article “Understanding Layouts in SWT” by Carolyn
          MacLeod and Shantha Ramachandran on the Eclipse Web site.13
    17.3.3.2 Converting the GUI init() Method
    The setStatus() method is called whenever the data in the core model
    changes. Its job is to update the UI to reflect those changes. More specifically,
    it updates the status pane at the top of the UI. There are corresponding
    methods for the list pane and the button pane.
          Oddly, there are no changes in this particular method. The purpose of this
    method is unchanged. It updates the Labels with the new numbers and checks
    to see if the current Account is the top level Account. If it is, the Up button
    is disabled, otherwise it is enabled.
          It turns out that all of the methods called on the UI classes in this method
    have the same names and purposes in Swing and SWT. Don’t assume this will
    be true in the other cases.
    17.3.3.3 Reworking Event Handlers
    Finally, in the litany of conversion, we have to modify the event handlers. In
    this case, the only event of interest is when the Up button is pressed. Pressing
    a Button produces a Selection event.
          In SWT, there are several types of events. Generally, you specify a class
    that will handle the event by calling one of the add...Listener() methods
    on the Widget that you wish to process the event for. Examples of these
    method calls include:
       •  addSelectionListener()
       •  addControlListener()
       •  addFocusListener()
       •  addHelpListener()
    13. http://www.eclipse.org/articles/Understanding%20Layouts/Understanding%20
    Layouts.htm
17.3 Porting BudgetPro to SWT                                                            393
           • addKeyListener()
           • addMouseListener()
           • addMouseMoveListener()
           • addMouseTrackListener()
           • addPaintListener()
           • addTraverseListener()
             There are others. SWT naming conventions define an interface for
       which each add...Listener() method is named. For example, there is a
       SelectionListener interface. Many such interfaces have multiple methods,
       each to handle a distinct kind of event; for example, the MouseListener inter-
       face defines separate methods to handle a button down event, a button release
       event, and a double-click event. As in Swing, it is common to implement event
       listeners as anonymous inner classes that implement the listener interface.
       However, since it is common to be interested only in some (or even only one)
       listener event, it is annoying to have to implement the full interface, since you
       have to provide method implementations for every event. For this reason, SWT
       also provides classes called adapters that implement “do-nothing” methods for
       every listener event. These also follow a naming convention. For example, the
       adapter for the MouseListener interface is a class named MouseAdapter; the
       SelectionListener interface has an adapter named SelectionAdapter,
       and so on.
             For us, this means that we are going to create a reference to an anonymous
       inner class that implements the SelectionListener interface by extending
       the SelectionAdapter class. This is probably the weirdest common code
       construct in Java. Let’s take a direct look at that method (Example 17.2).
             If you can correctly answer the following question, then you can be reason-
       ably assured that you do, in fact, understand what is going on here. Would the
       program compile and run correctly if the type of the upAction variable were
       changed to SelectionAdapter? The answer is in the footnote.14
       14. Yes, it would. The reason is that the addSelectionListener() method takes an argu-
       ment of type SelectionListener. Both SelectionListener and SelectionAdapter
       are of that base type. Aren’t Objects wonderful?
394                                        Chapter 17  Other Ways: Alternatives to Swing
    Example 17.2 The upton Button event listener class reference declaration
    private SelectionListener upAction = new SelectionAdapter()
    {
       public void widgetSelected(SelectionEvent e)
       {
         // this is the action for UP arrow icon;
         Account next;
         next = current.getParent();
         if (next != null) {
            current = next;
            setStatus();
         }
       }
    } ;
    17.3.4 Completing the Conversion of the BudgetPro Class
    To keep this book to a reasonable size, we are always trying to avoid covering
    the same ground more than once. We won’t walk you through the details of
    converting the createList() and createButtons() methods as we did with
    the createStatus() method, but we will talk about the details of converting
    to SWT of some of the classes used in those methods.
    17.3.4.1 The Table, TableColumn, and TableItem Classes
    Without a doubt, the biggest change the BudgetPro class requires in order to
    convert from Swing to SWT lies in the table pane of the UI. The Table class
    is the root of tables in SWT. The TableColumn class defines the names and
    headers of the columns. TableColumn constructors must have a Table as their
    first argument, followed, as usual, by a numeric style specification. The
    TableItem class defines a row in the Table. As with TableColumn, the
    TableItem constructor must have a Table as its first argument, followed by
    a numeric style.
         If you think about it, this is an extension of the same design philosophy
    that requires that all constructors name their parent Composite. While Swing’s
    abstract table model permits a nice separation between the data and the presen-
    tation, implementing a similar system in SWT would violate its strict container
    semantics.
         You will need to follow the basic rewrite process outlined above and you
    will have to squish the Swing abstract table model into the simpler SWT table
17.3 Porting BudgetPro to SWT                                                        395
       model. This will be your biggest challenge. Go to it. It is a great way to learn.
       Of course, you can also just download the complete SWT application from the
       book Web site.15
       17.3.5 Completing the Conversion of the Application
       Completing the conversion of the BudgetPro class does not complete the
       conversion of the entire application. The AcctDialog class must also be con-
       verted. Use the same techniques we described here to convert that class as well.
       (Or, again, just download the complete SWT application.)
       17.3.6 Closing Thoughts
       Our overall impression is that SWT is more easily comprehended in its entirety
       than Swing. It may be easier to learn SWT first, since Swing’s core model is
       more complex but more powerful. But SWT and Swing weren’t developed in
       that order and Swing is still much more widely used.16
             For many GUI applications, our feeling is that it may be faster to write in
       the SWT idiom. The problem lies in that SWT’s model has limitations that
       Swing’s does not. Notably, SWT GUI elements are in a single rigid tree struc-
       ture. It is not possible to have a factory class that constructs a GUI element
       such as a dialog box which is passed up to the caller to be grafted into place on
       a GUI. Instead, the parent element must be passed in, so all GUI elements be-
       long to the single tree from the moment they are created. Also, by introducing
       objects that cannot be garbage-collected, SWT brings into your application the
       possibility of a class of bugs that Java otherwise eliminates.
             Moreover, while converting a Swing application helped give this chapter
       shape, we would, in general, prefer that an application be designed with its GUI
       toolkit in mind. You would likely make slightly different design decisions
       depending on which style of the GUI you choose.
       15. http://www.javalinuxbook.com/
       16. A gut feel—not based on any real statistics.
396                                                 Chapter 17    Other Ways: Alternatives to Swing
 17.4 SWT AND GCJ
      Up to now, we have told you again and again that SWT will work with gcj.
      But no Linux distribution with which we are familiar provides SWT with gcj
      out of the box. So how do you get SWT to play nice with gcj? Unfortunately,
      you have a bit of work to do. Fortunately, the work is not particularly difficult.
            Before we proceed, we must acknowledge those who have been there be-
      fore. We, too, had heard about SWT’s usability with gcj but we had never
      bothered to try it because there was no documentation on how to do it. We
      first made the attempt thanks to a great IBM developerWorks article by Kirk
      Vogen entitled “Create Native, Cross-Platform GUI Applications.” Follow the
      URL17 to the information that enabled us to write this chapter.18
            SWT source code is included in the Eclipse SDK download. See Sec-
      tion 10.4 for details on where and how to download and install Eclipse. Once
      you have Eclipse, you need to get your mits on the SWT source code. What
      we will do is compile the SWT source into a shared object file that we can link
      to any gcj application.
            We’re assuming that you’ve got gcj installed. We’re assuming that you’ve
      unzipped the Eclipse SDK. We’re assuming you’re still reading the book. We
      have to make that assumption. The first thing you need to do is to unzip the
      SWT source code. It is found in ECLIPSE_INSTALL/plugins/org.eclipse.
      platform.linux.gtk.source_2.1.2/src/org.eclipse.swt.gtk_2.1.2/
      ws/gtk. If you are using (as we recommend) the GTK version of Eclipse,19
      there are two files in there: swtsrc.zip and swt-pisrc.zip.
            Once you have these unzipped, you have to compile the code with gcj.
      There are two different patterns these files follow. Files that do not contain
      native methods are compiled with a command line that looks like this:
      17. http://www-106.ibm.com/developerworks/library/j-nativegui/
      18. Please note that Kirk’s article provides links to additional documentation and to an ant
      buildfile that automates the steps we are going to teach you manually here. We certainly didn’t
      want to steal anything from Mr. Vogen (or from IBM—scary!), so we will instead direct you
      to the (copyrighted) IBM Web resources. The article is worth checking out. It can save you
      some time over our version of the process. It is up to you.
      19. Be aware: As helpful as Kirk Vogen’s article and files are, they are written to an old version
      of gcj and they assume you are using the Motif version of Eclipse. His scripts work only with
      the Motif version.
17.4 SWT and GCJ                                                                           397
      $ gcj -c SomeClass.java -o SomeClass.o
            Files that do contain native methods are compiled with a command line
      that looks like this:
      $ gcj -fjni -c SomeClass.java -o SomeClass.o
            That said, it does no harm to compile a source file that has no native
      methods with the -fjni flag. This gives us a quick and dirty way to make our
      library file.
      $ find . -name "*.java" -exec gcj -fjni -c {} \; -print
            Remember, you are in UNIX-land. Leverage your tools! In this case, the
      advantage of using find is that, should the SWT source change (classes added
      or removed), our “compile process” will handle it. Obviously, you can take this
      in more sophisticated directions with make or ant. But this will get the job
      done for us for now.
            That will compile all of the SWT source.20 Next, we want to assemble all
      of the object files produced into a shared object.
      $ gcj -shared -o swt.so $(find . -name "*.o" -print)
            Once again, we leverage our tools. This time, we use bash execution
      quotes around our find command to get all of the .o filenames added to our
      gcj command that builds the shared library. For our final trick, we will compile
      our HelloWorld class from the start of this chapter with gcj and our new SWT
      shared library:
      20. When we did this with Eclipse 2.1 GTK and gcj version 3.2.2, we had one compile error
      where the return type of the org.eclipse.swt.custom.TableCursor.traverse()
      method was void, whereas the Control.traverse() method (from which
      TableCursor inherits) was boolean. So we hacked it. We changed the return type of
      TableCursor.traverse() to boolean and had it return true. We didn’t test to see if this
      was right! Use at your own peril!
398                                            Chapter 17   Other Ways: Alternatives to Swing
      $ gcj -classpath=~/eclipse/plugins/org.eclipse.swt/swt.jar:\
      ~/eclipse/plugins/org.eclipse.swt/swt-pi.jar -c HelloWorld.java
      $ gcj -main=HelloWorld -o HelloWorld Hello.o swt.so
      $ export LD_LIBRARY_PATH=.:~/eclipse:\
      ~/eclipse/plugins/org.eclipse.swt/ws/gtk
      $ ./HelloWorld
             Et voilà! You have the HelloWorld application! Again. But now it is an
      executable binary. Enjoy.
 17.5 REVIEW
      Compared to Swing, SWT is a somewhat simpler GUI library. Unlike Swing,
      it is Free Software and Open Source. It provides a full GUI library for use with
      gcj. It is part of the Eclipse project. It uses native methods that require calls to
      dispose of allocated objects. It has a rigid hierarchy that requires that lower
      level GUI components be linked to their parents when they are constructed.
      This means there are some limitations on how applications may be constructed.
      SWT is much less commonly used than Swing. Swing is the lingua franca of
      Java GUIs. SWT is definitely worth knowing, but if you want your skills to be
      marketable, it is probably best to start with Swing.
 17.6 WHAT YOU STILL DON’T KNOW
      We just scratched the surface of SWT Widgets. There are a bunch we haven’t
      covered.
 17.7 RESOURCES
          • SWT was written to support the Eclipse IDE. Eclipse is at
             http://www.eclipse.org/.
          • An introduction to SWT can be found at the same site:
             http://www.eclipse.org/articles/Article-SWT-Design-1/
             SWT-Design-1.html.
          • Part 2 of the same article is at http://www.eclipse.org/articles/
             swt-design-2/swt-design-2.html.
17.8 Exercises                                                                         399
          • The full list of Eclipse technical articles (including those on SWT) may
             be found at http://www.eclipse.org/articles/index.html.
          • A good introductory article can be found on the Developer.com
             Web site: http://www.developer.com/java/other/article.php/
             3330861.
          • As always, consider using Google.com to find additional information.
          • In dead-tree form, Chapter 10 of the book The Java Developer’s Guide to
             Eclipse by Sherry Shavor et al. (Addison-Wesley, ISBN 0-321-15964-0),
             also provides an introduction to SWT.
 17.8 EXERCISES
         1. Complete the conversion of the BudgetPro class.
         2. Complete the conversion of the entire BudgetPro GUI application.
         3. While you have Eclipse installed, follow the instructions to unpack the
             SWT examples. In particular, run the ControlExample. This is an appli-
             cation that demos all the major Widgets, while giving you the ability to
             apply most (if not all) of the style values to them dynamically. It is like a
             Widget browser that can get you familiar with the look and feel of SWT
             Widgets quickly. Run it. Play with it. Become friends with it. Also, remem-
             ber you have the source code for this application. Want to know how to
             code a given Widget? Look!
Part IV
Developing
Web Interfaces
     Chapter 18
     Servlets:
     Java Pressed into Service
     Java was first seen by many programmers as a way to enhance Web pages by
     adding some actual code to them, to be run in the browser. But the real power
     of Java was unleashed at the other end of the client-server connection, when
     Java was pressed into service on the Web server—to help serve up pages,
     sometimes of its own making, to Web clients all across an enterprise.
18.1 WHAT YOU WILL LEARN
        • What servlets are.
        • How to write a simple servlet.
        • More complex servlet matters (servlet state).
        • An example—our BudgetPro application as a servlet.
                                                                               403
404                                           Chapter 18 Servlets: Java Pressed into Service
 18.2 SERVLETS: PROGRAM-CENTRIC SERVER-SIDE DOCUMENTS
      Servlets are Java programs that are run by a Web server. At its simplest, a servlet
      is a Java class that is invoked by a Web server (referred to in some contexts as
      the servlet’s container). A servlet is run not from the command line as a regular
      Java program, but by visiting its URL. Point a Web browser at a servlet’s ad-
      dress and the Web server (the one which serves up that address) will run the
      servlet and send its output back to the browser (see Figure 18.1). So you can
      see that typical output for a servlet is HTML—what better thing to send to
      a browser?
            Now, more and more servlets are using XML as their output and then
      converting it to HTML via XSLT stylesheets, but we’re trying to keep things
      simple here.
            In their most generic form, servlets are classes which implement the
      Servlet interface. That means that they provide three methods:
         • init(ServletConfig config)
         • service(ServletRequest request, ServletResponse response)
         • destroy()
            The init() method gets called when the Web server starts up the class.
      (Think of the init() method as a constructor; Java doesn’t allow constructors
      to be defined for interfaces, so init() plays that role.)
            The destroy() method gets called whenever the Web server takes the
      servlet out of service. This might happen when a system administrator wants
      to shut down the system, or shut down just that particular Web service.
            Naturally, the service() method is the method that gets called whenever
      requests for this servlet arrive at the Web server. The server knows that the re-
      quested service is provided by this servlet, so it packages up certain data and
      sends it along as a request to the servlet. Thus, servlets can provide data in this
      generic request/response kind of protocol. Simple, but vague, right now.
            Servlets get a bit more interesting when we look at the HttpServlet class.
      This class extends Servlet and adds two more methods that must be
      implemented:
         • doGet(HttpServletRequest               request,      HttpServletResponse
            response)
18.3 Perspective                                                                    405
         Linux system
              Web server
                    Servlet class
          HTTP request          HTML
              PC
                    Web browser
       Figure 18.1 Servlet diagram
          • doPost(HttpServletRequest          request,      HttpServletResponse
             response)
             We hope that you’ve noticed the similarity between doGet(), doPost(),
       and the previously mentioned service() method. More on that in a minute.
 18.3 PERSPECTIVE
       To better understand the interaction with servlets, let’s consider the requests
       that come to a Web server. Web servers serve up Web pages. At first (in the
       early days of the Web) that just meant simple flat HTML files, along with a
       few image types. A Web browser would send a request to a Web server in the
       form of a URL, such as http://www.dom.com/file.html, which would be
       sent to the Web server named www at the dom.com domain. It would look up
       the file named file.html in its directory and send it back to the browser.
             That approach worked fine, and still does today. But this only covers static
       Web pages, ones whose content doesn’t change. Users want to get at lots more
       information today, not all of which has been embodied in static Web pages.
406                                       Chapter 18 Servlets: Java Pressed into Service
    Rather than require fancier browsers with more dynamic querying or other ca-
    pabilities, Web servers became smarter and were able to talk to other programs
    that would generate HTML on the fly and send it back as the response to an
    incoming request. In the Java environment, this mechanism includes the
    Servlet and related classes.
         As for requests coming from a browser, they come in two flavors—GET
    and POST. The GET request is a request via a URL. Simple URLs that appear
    as hyperlinks on a Web page are sent as GET requests. Any additional parameters
    appear at the end of the URL as name=value pairs separated by “&”. The
    parameters are separated from the URL with a “?” character:
    http://www.google.com/search?hl=en&ie=ISO-8859-1&q=java
         The example URL includes three parameters:
       • hl=en
       • ie=ISO-8859-1
       • q=java
         The POST is virtually the same, except that the name=value pairs don’t
    appear on the URL but are sent in a less visible way. The net result is the same,
    and the same methods can be used in the servlet to retrieve the parameters. The
    POST requests typically come from HTML form elements, as when you fill in
    the fields of a form and press a submit button (though forms can specify that
    the browser use GET as the submission mechanism for a particular form). The
    biggest advantage to posting the form is that the parameters don’t appear in
    the URL, which is both more aesthetically pleasing and avoids problems from
    accidentally revisited pages or user-altered parameters.
         One further twist: URLs are not necessarily literal paths to files anymore.
    The Web server can interpret parts of the URL as an alias for some other pro-
    gram. So http://www.google.com/search may not actually refer to a direc-
    tory named search on the Google site, but more likely tells the Web server to
    use its search program. We’ll discuss this more in Chapter 19.
         So servlets are given requests which have come from browsers (and other
    Web clients), and then they respond with output. In our examples, we’ll be
    sending HTML back. There are lots of other choices, too. Since browsers un-
    derstand other formats, a servlet might also send back plain text or even image
    data. Another choice gaining popularity is having the servlet generate XML and
    then using a conversion via stylesheets to produce HTML. This allows for the
18.4 How to Write a Servlet                                                            407
       formatting to be changed (e.g., to apply a new corporate look to the pages)
       without changing the content or the programs that generate the content.
             Since a Web server (e.g., Apache Tomcat) is typically configured to run
       constantly, that is, to always be around, then a servlet is also always around.
       (The Web server keeps a reference to the class, so the class is not garbage collect-
       ed—hence its persistence.) Well, “always” here means “as long as the Web
       server and the operating system are up and running.”
             An aside: Not all servlets are for Web browsing. Sometimes servlets can
       be used as daemons that hang around in the background doing other tasks
       (e.g., background processing of some database records). The browser interface,
       if any, may only be for the purpose of providing an administrative interface to
       the daemon. The administrator would then have a Web page to which to go,
       in order to see how many records have been processed. This page may also have
       buttons to reset, restart, or shut down the process. While we typically think of
       servlets being for the production of dynamic Web pages, here the Web pages
       would only be an aside to the real purpose, that of processing database records.
 18.4 HOW TO WRITE A SERVLET
       So how do you write a servlet? You may already have figured it out, from what
       we’ve described so far. You need to:
           • Write a Java class that extends HttpServlet
           • In that class, write the following methods:
               • init()
               • destroy()
               • doGet() and/or doPost()
             That’s the basic idea. There are lots of details about what arguments are
       supplied, what other resources are available, what methods can be used to get
       at parameters, and so on. We’ll discuss some of those in our example servlet.
             Let’s start with a simplistic servlet, one that will dynamically generate the
       “Hello, world” string as a Web page (Example 18.1).
408                                       Chapter 18 Servlets: Java Pressed into Service
    Example 18.1 A “Hello, world” servlet
    /*
      * HiServlet.java
      */
    package net.multitool.servlet;
    import javax.servlet.*;
    import javax.servlet.http.*;
    /**
      * Simple Servlet that generates a page of HTML
      */
    public class
    HiServlet
       extends HttpServlet
    {
       /**
         * Think of this as the constructor for the servlet.
         * We need do nothing for our example,
         * but we should call our parent object.
         */
       public void
       init(ServletConfig config)
          throws ServletException
       {
          super.init(config);
       } // init
       /**
         * Called when the Web server is shutting down
         * or wants to shut down this particular servlet.
         * We need do nothing.
         */
       public void
       destroy()
       {
       } // destroy
       /**
         * Handles the HTTP GET method.
         * @param request servlet request
         * @param response servlet response
         */
18.4 How to Write a Servlet                                              409
         protected void
         doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, java.io.IOException
         {
            doBoth(request, response);
         } // doGet
         /**
           * Handles the HTTP POST method.
           * @param request servlet request
           * @param response servlet response
           */
         protected void
         doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, java.io.IOException
         {
            doBoth(request, response);
         } // doPost
         /**
           * Requests for both HTTP GET and POST methods come here,
           * because we're not doing anything different
           * between the two request types. This way we need only one
           * version of the code that does the real work.
           * @param request servlet request
           * @param response servlet response
           */
         protected void
         doBoth(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, java.io.IOException
         {
            java.io.PrintWriter out = response.getWriter();
            response.setContentType("text/html");
            /* output our page of html */
            out.println("<html>");
            out.println("<head>");
            out.println("<title>A Java Servlet</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("Hello, world.");
            out.println("</body>");
            out.println("</html>");
            out.close();
         } // doBoth
410                                              Chapter 18 Servlets: Java Pressed into Service
       /**
         * Returns a short description of the servlet.
         */
       public String
       getServletInfo()
       {
          return "Very Simple Servlet";
       } // getServletInfo()
    } // class HiServlet
           Whew! That is a lot of code for only a simple “Hello, world,” but remem-
    ber that this is not just a run-on-your-desktop application. This is a network-
    based servlet that can respond to concurrent requests from across the network
    and talk to Web browsers. There’s a lot of plumbing that needs to be connected
    to a Web server for the servlet to run, and that’s what most of this code is—just
    the connections. The other verbose part is all of the HTML that we spit out
    around our message. You can make it even more elaborate, with background
    colors and other HTML decorations if you want to try it yourself.
           Once you’ve written a servlet, though, you can’t just run it from the
    command line like any Java class.1 Much of the work of a servlet is done behind
    the scenes by the Web server (e.g., Tomcat). The tougher question is, “How
    do you run a servlet?” That involves issues of configuring the Web server, set-
    ting up directory locations, and so forth. It’s the subject of the next chapter.
           Once you’ve deployed this servlet (by reading the next chapter and/or with
    help from your IDE), you can run the servlet and talk to it via your browser.
    We’ve pointed a browser window at one such deployment to get a highly unin-
    teresting Web page (Figure 18.2) whose HTML source (in your browser menu,
    select View > Page Source) is shown in Figure 18.3.
    1. Well, actually, you could if it had a main() method defined. Our example doesn’t, but a
    servlet class is still a Java class, and you might define a public static void main()
    method that would allow you to run it from the command line as a way to drive the rest of the
    class for simple testing. Of course, such a simple test harness wouldn’t be driving a Web
    browser, and so on but technically it is possible. We didn’t want to lie to you.
18.5 Input, Output                                                                  411
       Figure 18.2 A very simple page from our servlet
       Figure 18.3 The servlet-generated source of our simple page
 18.5 INPUT, OUTPUT
       OK, so we’ve dynamically created a Web page—but the contents of that
       page don’t change. The real use for servlets comes from having them produce
       dynamic content, not just from dynamically producing content.
             One way for the content to be dynamic is to extract it from a database.
       Using what we described in Chapter 15, you can add code to pull values from
       tables in a database. Consider a query that will return multiple rows of results.
       Each row could be displayed as a row in an HTML table for display on a Web
       page.
             Using a loop, we can generate lots of HTML with little code. This is
       handy for generating HTML tables. We would likely generate the <table> tag
       outside a for loop, but the <tr> and <td> tags would be output from within
412                                        Chapter 18 Servlets: Java Pressed into Service
    the loop, one for each iteration of the loop. (If you’re not picturing that, be
    patient. There are examples of this coming up. If you’re not conversant in
    HTML, then you better check out some of the HTML references at the end
    of this chapter. We’re going to assume that you speak HTML fluently. Come
    on—we can’t cover everything in one book.)
           The other side of dynamic content comes from variable input. Google’s
    search engine, for example, generates different pages for different search strings.
    It is the variation in user input that results in varying output pages. On a Web
    page, user input typically comes from an HTML form. The form values can
    be passed either as parameters on the URL or as POST values. URL parameters
    are also easy to generate by hand, or to code in place in <a> tags. For example,
    <a href="/servlet/doSuch?cmd=find&value=joe">
    is an HTML tag for a hyperlink which will invoke the doSuch servlet and pass
    in the parameters cmd and value. (It’s a servlet not because the pathname is
    /servlet, but we use that for illustrative purposes. In fact, the servlet invoked
    may not even be called doSuch; it all part of servlet mapping that recognizes
    certain URLs as aliases for particular servlets. See Chapter 19 for a fuller
    explanation.)
           The point is, we can invoke the same servlet repeatedly (even simultane-
    ously) but with different values for our parameters, so we can program it for
    different behaviors and different output.
           These parameters are available to the servlet via the request argument of
    the doGet() and doPost() methods. You can get an enumerator over all of
    the arguments (using getParameterNames()), or if you know it’s name (and
    you likely would, since you’re writing the program) you can ask for a particular
    argument.
           The previous example used an argument called cmd, whose value we could
    retrieve thus:
    String act = request.getParameter("cmd");
           The parameters all come as Strings. If your arguments are numeric, you’ll
    have to parse them (and error-check them—HTML forms are, understandably,
    weak on validating their input; tons of JavaScript have been written to deal
    with this, but this is beyond the scope of this book.)
           Some parameters may have embedded spaces and other special characters
    that would disrupt a URL. To deal with that, browsers encode the characters
18.6 Matters of State: Cookies, Hidden Variables, and the Dreaded “Back” Button    413
      in form fields before sending them to a Web server. You can see that in some
      URLs—space gets replaced with a “+” character, and special characters (such
      as the plus sign) get replaced with a character sequence for hexadecimal values
      (for example, “+” becomes %2B ). The getParameter() method will automat-
      ically decode those. But we need to remember this if we want to generate any
      literal URLs in the HTML that we produce. (See the URLEncoder class in the
      Javadoc documentation for servlets.)
             One more annoyance that must be dealt with: What if the URL contains
      the same argument twice—for example, www.google.com/search?
      cmd=search&cmd=bogus?
             If you make the call to getParameter() you will get the first value
      (search). If you want to handle such a situation differently, you can call
      getParameterValues() which will return an array of Strings for all the
      different values. In our example,
      String [] allofem = getParameterValues("cmd");
      will return an array such that:
      allofem[0] = "search"
      allofem[1] = "bogus"
             If there was only one value, then you get an array of one element. If the
      parameter wasn’t used in the URL, getParameterValues() returns null.
 18.6 MATTERS OF STATE: COOKIES, HIDDEN VARIABLES,
      AND THE DREADED “BACK” BUTTON
      The toughest part about working with HTML is, perhaps, its statelessness.
      HTML and browsers were not designed to keep a connection going. It’s not a
      phone call type of connection, where the line is kept open between the browser
      and the Web server. Rather, it’s a one-shot, send-me-what-you’ve-got mecha-
      nism more like postal mail (but without the stamp). Here’s the rub: Just be-
      cause you mail a letter, you can’t assume that you’ll get an answer back. There
      is no on-going connection between browser and server, except for the duration
      of the data transfer. Once you’ve got your complete page displayed, the
414                                            Chapter 18 Servlets: Java Pressed into Service
    connection is gone.2 About the best one can hope for is that you’ll use what,
    in our postal analogy, would be like a supplied reply envelope. This allows the
    servlet engine of the Web server to track requests from the same user and pro-
    vide a session capability across requests. It will use your browsers cookie mecha-
    nism to store this session’s ID used to track your session. If you don’t have
    sessions on, it will need to use URL rewriting, whereby the URLs generated
    will have an added parameter, the session ID.
          Unlike the early days in the life of the Web, nowadays virtually everyone
    has cookies enabled in their browsers—anyone who shops at amazon.com, at
    least. This makes session tracking so much easier for the servlet developer. The
    Web server handles all that automatically, and you only need to make a few
    calls to the session-related methods of the HttpRequest.
          To get a session for a user, ask for one from the HttpRequest:
    HttpSession session = request.getSession(true);
          The boolean parameter says whether (true) or not to create a session if
    one does not yet exist for this user. Once you have a session, you can store
    objects associated with that session:
    session.setAttribute("cart", shopCart);
    where shopCart is any serializable Object and "cart" could be any String
    that you want to use to later identify and retrieve this object, for example:
    Basket myCart = (Basket) session.getAttribute("cart");
          Notice that we need to explicitly cast the object type returned by
    getAttribute(), because it returns a generic Object.
    18.6.1 Cookies
    For any information that you want to save for longer than the duration of a
    session, you may want to investigate cookies—little bits of data (4K max; typi-
    cally only a few bytes) sent to the browser for it to store and send back at a later
    time. You make a cookie thus:
    2. You can go to another page, just be staring at the page for a long long time, or you might
    have shut down your browser completely—and the server-side servlet will never know.
18.6 Matters of State: Cookies, Hidden Variables, and the Dreaded “Back” Button         415
      Cookie snack = new Cookie("name", "value");
      snack.setMaxAge(36000); // lifetime in seconds (10 hours)
             Setting the maximum age of the cookie to a positive value is needed to let
      the browser know that it needs to store the cookie on disk. After that many
      seconds the cookie will be discarded by the browser as no longer relevant. No-
      tice, too, that you must send the data inside the cookie as a string, and when
      you retrieve it, you’ll have to parse that string.
             Then you can send the cookie as part of a response, along with your
      other output:
      response.addCookie(snack);
             Getting data back via cookies involves requesting data from the
      HttpServletRequest           object. All the cookies associated with your URL are
      sent with the HTTP header to this address. You make the call:
      Cookies [] allSuch = request.getCookies();
      and then you have to look through the list looking for the cookie you want:
      if (allSuch != null) {
            for(i=0; i allSuch.length; i++) {
                  Cookie c1 = allSuch[i];
                  if ("DesiredCookieName".equals(c1.getName())) {
                        String result = c1.getValue();
                        // ... now do something with it
                  } // endif
            } // next cookie
      } // endif
             While cookies have gotten a lot of press, especially in the early days of Web
      technology, we’ve found much less use for them than for session objects. Session
      objects stay on the server, cannot be modified or deleted by the user, and are
      easier to look up and use. The drawback, or course, is their limited lifespan.
      But if you really want to leave data around for the next time some user visits
      your servlet, you may be better off putting the data in your own database and
      identifying that user by means of a cookie or by some login mechanism.
             Let’s take a look at a complete servlet example.
416                                           Chapter 18 Servlets: Java Pressed into Service
 18.7 DESIGNING A BUDGETPRO SERVLET
      When designing a servlet, there are many different patterns to follow. We can’t
      hope to cover all the approaches that can be used for effective servlet program-
      ming. What we hope to do is show you our previous BudgetPro GUI applica-
      tion rewritten as a servlet, so that you can see the mechanics of a working servlet
      application. From this, you can become accustomed to the mechanics of a
      servlet so that you’ll feel comfortable with other approaches, too. All servlets
      need to use these basic mechanisms.
            Our BudgetPro GUI application was started from the command line, with
      a name for the budget and a total dollar amount. We’ll use a static HTML page
      with a form for supplying that information. That will invoke our servlet. The
      servlet will use HTML pages analogous to the windows we used in our
      GUI—there will be a main screen that shows the current account listing its
      subaccounts, and there will also be a screen for creating new subaccounts.
            One nice feature of HTML-based Web applications is that you can use
      hyperlinks as a way to both select something and take an action on it. We’ll use
      that feature in lieu of a View Subaccount button. Instead of selecting a subac-
      count and then pressing View Subaccount, the user will only have to click on
      the name of the subaccount. As a hyperlink, it will make the request to the
      servlet to view that subaccount.
            We will still use a button to send us to the screen for creating the subac-
      counts. We could have used a hyperlink, but this makes the browser page look
      a bit more like the GUI version.
      18.7.1 Prototype
      When designing servlets, it’s handy to use static HTML pages as a prototype
      for the work to be done. You can mock up the various screens using HTML,
      simulate interactions by using hyperlinks to move between the screens, and get
      a feel for what the screens and interactions will look like.
            Such a prototype also serves as a “runnable” specification. It can sometimes
      be easier to show the action than to describe it with words. And if you take care
      when you are building these static HTML pages, most of the HTML can be
      reused directly in the final product. (This will be even more true when we get
      to JSP.)
18.7 Designing a BudgetPro Servlet                                                            417
       18.7.2 Design
       Let’s review what we need our servlet application to do for us. Given an account
       name and the initial dollar amount, we need to:
          • Create a top-level account with that amount of dollars
          • Display the current account and its total and remaining dollars, along with
             a list of its subaccounts, if any
          • Create subaccounts, specifying a name and dollar amount
          • Make a selected subaccount be the current one, displayed as above
             After each or any of these actions, the servlet has to spit out the HTML
       page for the user to view. If the user wants to create a subaccount, then the
       servlet produces a form page for entering the name and dollar amount for the
       subaccount. When the user presses a Create button on that page, the browser
       tells the servlet (via the form data) that the servlet should create the subaccount
       and redisplay the current account with this new subaccount added to its list.
             TIP
             It may help to think of the servlet as a two-step process, with a current and fu-
             ture perspective. The first step is the action that the servlet must perform based
             on the supplied parameters (e.g., create a new account). The second step is
             the creation of the page allowing the user to take the next (future) action. That
             page reflects the state of things after the parameter-driven action has occurred.
             In our example, that means showing the list of subaccounts including the one
             that we just created.
             Let’s spell out in more detail what our interactions with the servlet will be,
       and describe what output we expect for each of those inputs. We will create a
       keyword to tell the servlet what function we want it to perform; we’ll call the
       parameter func. We will sometimes need two other parameters: name and
       dollars.
             Table 18.1 shows our design as a compact reference.
             The code for our servlet is at http://www.javalinuxbook.com/. Let’s
       look at some of the key parts of the servlet in more detail. We’ll look at:
       1) reading the parameters, 2) the core business logic of the servlet, as described
       in Table 18.1, and 3) how we create and output the HTML.
418                                         Chapter 18 Servlets: Java Pressed into Service
    Table 18.1 BudgetPro servlet actions
     func parameter      Other params    Action                               Next screen
     begin               name, dollars   Create a top-level account, save in  main
                                         the session.
     mkacct              none            none                                 subacct
     cancel              none            Get account from session.            main
     create              name, dollars   Get account from session; create     main
                                         subaccount.
     cd                  name            Get account from session, look up main
                                         subaccount by name, save as current
                                         in session.
     back                none            Get account from session, get        main
                                         parent from account, save as current
                                         in session.
          The parsing of the parameters is very straightforward. The request param-
    eter, part of the signature of the doGet() and doPost() methods, can be used
    to retrieve the parameters we need:
    String act = request.getParameter("func");
    String name = request.getParameter("name");
    String dollars = request.getParameter("dollars");
          Notice that we always ask for all three parameters, even though we will
    often use only one (act). Once we have the requested function in act, it’s just
    a matter of if-then-else-ing our way through the possible values and taking
    the appropriate actions. We store, or retrieve, the current account in the
    session manager, thereby providing continuity between browser requests
    (Example 18.2).
          The output is the page to send back to the browser. We create
    that page as an object, either an AccountView or a SubPage. The
    HttpServletResponse provides us with an output channel on which to write.
    java.io.PrintWriter out = response.getWriter();
    if (nextPage != null) {
         response.setContentType("text/html");
         out.println(nextPage.toString());
    }
18.7 Designing a BudgetPro Servlet                                                    419
       Example 18.2 Implementing the BudgetPro servlet actions
       if ("begin".equals(act)) {
             Account top = new Account(name, theUser, dollars);
             session.setAttribute("top", top);
             session.setAttribute("current", top);
             nextPage = new AccountView(top);
       } else if ("mkacct".equals(act)) {
             // show the subaccount creation page
             nextPage = new SubPage(null);
       } else if ("cancel".equals(act)) {
             Account current = (Account) session.getAttribute("current");
             nextPage = new AccountView(current);
       } else if ("create".equals(act)) {
             Account current = (Account) session.getAttribute("current");
             try {
                 current.createSub(name, dollars);
                 nextPage = new AccountView(current);
             } catch (NumberFormatException nfe) {
                 // show the subaccount creation page (with error message)
                 nextPage = new SubPage("Bad number format");
             }
       } else if ("cd".equals(act)) {
             Account current = (Account) session.getAttribute("current");
             Account nextAcct = current.getSub(name);
             session.setAttribute("current", nextAcct);
             nextPage = new AccountView(nextAcct);
       } else if ("back".equals(act)) {
             Account current = (Account) session.getAttribute("current");
             Account nextAcct = current.getParent();
             session.setAttribute("current", nextAcct);
             nextPage = new AccountView(nextAcct);
       } else {
             log("Unknown func=["+act+"]");
             response.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED);
       }
             The way that we construct the output, it will all get sent back to the user
       in one fell swoop. That’s fine for relatively short pages with rapid response time.
       If response time is a major concern and you are sending large quantities of data,
       you may want to change things a bit. Instead of building up the output in a
       StringBuffer and then getting it all back with a toString() call, you could
       take each of our append() calls and make them individual out.println()
420                                          Chapter 18 Servlets: Java Pressed into Service
      calls, to send each snippet of HTML separately. The output can be flushed
      explicitly, too, using
      response.flushBuffer();
            You might do such a call just before beginning a database operation, or
      place such calls at strategic points through your output.
 18.8 REVIEW
      We have seen that servlets are Java programs that are run by a Web server. They
      typically, but not necessarily, produce output intended for a browser. By imple-
      menting the HttpServlet interface, your Java class will have all the methods
      needed for it to be run by a Web server. We looked at a simple example and
      saw its output to a Web browser, then we looked at another example using our
      BudgetPro application.
 18.9 WHAT YOU STILL DON’T KNOW
      There is more that we haven’t discussed, so if you’re going to do some serious
      work with servlets, be sure to do some additional reading, especially on these
      topics:
         •  The servlet lifecycle and the need for thread safety.
         •  How to keep the servlet output from being cached.
         •  Dealing with failures.
         •  Initialization parameters.
         •  Other kinds of output.
         •  Sharing between servlets.
         •  How to configure and deploy servlets (this is coming up in the next
            chapter).
18.11 Exercises                                                                      421
18.10 RESOURCES
       The definitive place for all the details is the Java Web site at Sun,3 particularly
       the pages dealing with javax.servlet.http classes.
             Some of the best material on servlets comes from:
           • Core Servlets and JavaServer Pages by Marty Hall and Larry Brown, ISBN
             0-13-009229-0, a Prentice Hall PTR book.
           • Its sequel, More Servlets and JavaServer Pages by Marty Hall, ISBN
             0-13-067614-1, also by Prentice Hall PTR.
           • Java Servlet Programming, Second Edition by Jason Hunter and William
             Crawford, ISBN 0596000405, from O’Reilly.
18.11 EXERCISES
          1. Modify the BudgetPro servlet so that it responds differently for the
             doGet() and doPost() methods. Have doPost() continue to work as
             is, but have doGet() report the number of different users and the number
             of accounts that they have created. (You may need to “instrument” the
             code—that is, add additional statements—to start counting such things.)
          2. Change BudgetPro to do its output on the fly instead of building the entire
             page before output. Can you notice any difference in the display time?
          3. Design error handling for BudgetPro to prevent the user from allocating
             more than is available in the (sub)account. Will you use Java exceptions?
             If so, which object will throw them and which will catch them? How will
             you inform the user of the error? Implement your design.
       3. http://java.sun.com/j2ee/1.4/docs/api/
Chapter 19
JSP:
Servlets Turned Inside Out
In our last chapter, the BudgetPro servlet example spent a lot of code generating
the HTML output for the servlet to send back to the browser. If you want to
change the HTML for any page (for example, add a background color), you
would have to modify the Java code (obviously)—but you’re not really wanting
to modify the logic of the servlet, you only want to tweak its output. The
HTML that a servlet generates can be scattered among output statements, string
concatenations, classes, and method calls. Servlets, we might say, bury the
HTML deep inside the code. We’re now going to take a look at JavaServer
Pages (JSP) which do the opposite—they expose the HTML and hide the code
down inside.
     This technique has been given the fancy description, document-centric
server-side programs. They are “document-centric” because the HTML code is
so visible—JSP content looks like (and is) HTML with some additions. They
are “server-side” because all the work is done on the server and all the additions
and special features of JSP are boiled down to a simple stream of HTML by
the time it gets to the browser.
                                                                               423
424                                             Chapter 19   JSP: Servlets Turned Inside Out
 19.1 WHAT YOU WILL LEARN
         •  Theory of operation: how JSP can be thought of as servlets “inside out.”
         •  Three simple JSP directives: scriptlet, declaration, expression.
         •  Servlet variables made available: request, response, out, session.
         •  Server-side includes.
         •  A tiny bit about tags.
         •  jsp:useBean.
         •  A look at our BudgetPro using JSP.
         •  The correct spelling of JavaServer Pages.
 19.2 SERVLETS TURNED INSIDE OUT: JSP
      Take a look at the AccountView.java class in the BudgetPro servlet example.
      It consists almost entirely of
      sb.append("</a></td>");
      method calls which build up a string of HTML. Instead, this could have been
      calls to do the output right then and there:
      out.println("</a></td>");
            Either way, if we want to modify the HTML, we have to modify the Java
      code. While that’s not difficult, it can be error-prone. It would be nice to not
      have the Java syntax in the way when we want to modify the HTML. (That’s
      especially true when you want to put quotation marks in your HTML:
      out.println("<input name=\"name\" size=\"20\">");
      It’s not that it can’t be done; the \" just gets hard to read and hard to get right
      the first time.)
            One way to externalize all the HTML is to put it into a file. Then our Java
      application could read the file at runtime and send its contents to the browser.
      Not bad, but what about the dynamic parts? Remember how we generated the
      table from the for loop in AccountView.java:
19.2 Servlets Turned Inside Out: JSP                                                   425
       for (Iterator actit = acct.getAllSubs(); actit.hasNext(); ) {
             Account suba = (Account) actit.next();
             sb.append("<tr>");
             sb.append("<td><a href=\"BudgetPro?name="+suba.getName());
             sb.append("&func=cd\">");
             sb.append(suba.getName());
             sb.append("</a></td>");
             sb.append("<td>albing</td>");
             sb.append("<td>");
             sb.append(suba.getTotal().toString());
             sb.append("</td>");
             sb.append("</tr>\n");
       } // next acct
             That would be hard to do with file-based HTML.
             Another approach, the one used by JavaServer Pages, would be to use the
       HTML file as input to a converter program—one which would take each line
       of HTML, for example
       <input name="name" size="20">
       and produce a line of Java code:
       out.println("<input name=\"name\" size=\"20\">");
             Notice how the converter would be the one to handle the escape sequence
       for the quotation marks; we get to write straight HTML—it has to deal with
       the backslashes.
             This is the basic idea behind JavaServer Pages. JSP files are nothing more
       than HTML (with some additions that we’ll discuss shortly) which are com-
       piled into Java programs—servlets, to be exact—that are then run to produce
       the Web page. The conversion happens no later than the first time the Web
       server tries to serve up that JSP. If it hasn’t yet been converted, it will convert
       it into Java code and start the servlet. Thereafter, other requests to that page go
       directly to the servlet. If you modify the JSP file, then the Web server recognizes
       that the file has been modified and reconverts it.
             But why go to all this trouble? It’s not for the static HTML that we need
       JSP, but rather for the dynamic bits. Remember that for loop, above, used to
       make the HTML table of subaccounts? Let’s look at part of a JSP that does the
       same thing:
426                                            Chapter 19  JSP: Servlets Turned Inside Out
      <table border=1 width=50%>
      <tr>
      <th>Account</th>
      <th>Owner</th>
      <th>Value</th>
      </tr>
      <% // for each subaccount:
         for (Iterator actit = acct.getAllSubs(); actit.hasNext(); ) {
           Account suba = (Account) actit.next();
      %>
           <tr>
           <td><a href="BPControl?name=<%= suba.getName() %>&func=cd">
           <%= suba.getName() %>
           </a></td>
           <td>albing</td>
           <td>
           <%= suba.getTotal().toString() %>
           </td>
           </tr>
      <%
       } // next acct
      %>
      </table>
           Notice how it starts off as simply the HTML building the table
      opening. Then we encounter some Java source code, enclosed in delimiters
      (<% ... %>), then back to plain HTML. There’s even a line which intermixes
      HTML and Java:
      <td><a href="BPControl?name=<%= suba.getName() %>&func=cd">
           To understand what’s going on here, let’s take a look at four pieces of
      syntax that are the keys to JSP.
 19.3 HOW TO WRITE A JSP APPLICATION
      Writing a JSP application consists, syntax-wise, of writing your desired output
      page in HTML and, where you need the dynamic bits, putting Java code and/or
      other special syntax inside special delimiters that begin with <%.
           There are four special delimiters that we should describe if you’re going
      to work with JSP. The bulk of your JSP will likely be HTML. But interspersed
      among the HTML will be Java source or JSP directives, inside of these four
      kinds of delimiters:
19.3 How to Write a JSP Application                                                  427
          • <% code %>
          • <%= expression %>
          • <%! code %>
          • <%@ directive %>
            Let’s look at them one at a time.
       19.3.1 Scriptlet
       The code that appears between the <% and %> delimiters is called a scriptlet. By
       the way, we really hate the term “scriptlet.” It seems to imply (falsely) a com-
       pleteness that isn’t there. It is too parallel to the term “applet,” which is a
       complete Java program that runs inside a browser. A scriptlet isn’t necessarily
       a complete anything. It’s a snippet of code that gets dropped inside the code
       of the servlet generated from the JSP source.
            Recall that servlets may have a doPost() and a doGet() methods, which
       we collapsed in our example by having them both call the doBoth() method.
       Same sort of thing is happening here with the JSP, and the doBoth() ends up
       doing all the output of the HTML. Any snippets of Java code from within the
       <% and %> delimiters get dropped right in place between those output calls,
       becoming just a part of a method.
            It can be useful to keep this in mind when writing JSP. It helps you answer
       the questions of scope—who has access to what, where are variables getting
       declared and how long will they be around? (Can you answer that last question?
       Since any variable declared inside the <% and %> will be in the JSP equivalent
       of our doBoth() method, then that variable will only be around for the dura-
       tion of that one call to the doBoth(), which is the result of one GET (or POST)
       from the browser.)
            The source code snippets can be just pieces of Java, so long as it makes a
       complete construct when all is converted. For example, we can write:
       <% if (acct != null) { // acct.getParent() %>
            <a href="BudgetPro?func=back">
            <img src="/back.gif">
            </a>
       <% } else { %>
            <img src="/back.gif">
       <% } %>
428                                          Chapter 19 JSP: Servlets Turned Inside Out
         Notice how the if-else construct is broken up into three separate
    scriptlets—that is, snippets of code. Between them, in the body of the if and
    the else, is plain HTML. Here is what that will get translated into after the
    JSP conversion:
    if (acct != null) { // acct.getParent()
         out.println("<a href=\"BudgetPro?func=back\">");
         out.println("<img src=\"/back.gif\">");
         out.println("</a>");
    } else {
         out.println("<img src=\"/back.gif\">");
    }
         Do you also see why we describe it as being “turned inside out”? What
    was delimited becomes undelimited; what was straight HTML becomes
    delimited strings in output statements.
         As long as we’re on the topic of conversion, let’s consider comments.
    There are two ways to write comments in JSP, either in HTML or in Java. In
    HTML we would write:
    <!-- HTML comment format -->
    but since we can put Java inside of delimiters, we can use Java comments, too:
    <% // Java comment format %>
    or even:
    <% /*
         * Larger comments, too.
         */
    %>
         If you’ve been following what we’ve been saying about translation of JSP
    into Java code, you may have figured out the difference. The Java comments,
    when compiled, will be removed, as all comments are, from the final executable.
         The HTML-based comments, however, will be part of the final HTML
    output. This means that you’ll see the HTML comments in the HTML that
    reaches the browser. (Use the View Source command in your browser to see
    them. As HTML comments, they aren’t displayed on the page, but they are
    sent to the browser.) This is especially something to be aware of when writing
    a loop. Remember our loop for generating the table?
19.3 How to Write a JSP Application                                                       429
       <% // for each subaccount:
          for (Iterator actit = acct.getAllSubs(); actit.hasNext(); ) {
             Account suba = (Account) actit.next();
         %>
             <!-- Next Row -->
             <tr>
             <td><a href="BPControl?name=<%= suba.getName() %>&func=cd">
       ...
       <% } // next acct %>
              We’ve put a comment just prior to the <tr> tag. What will happen is that
       the comment will be part of the generated HTML, and since this is a loop, the
       comment, just like the <tr> and other tags, will be repeated for each iteration
       of the loop. Now we’re not saying this is undesirable—in fact it makes the re-
       sultant HTML more readable. But be aware that these comments will be visible
       to the end user. Be careful in what you say in them. The additional transmission
       time required for these few extra bytes is probably imperceptible, unless your
       comments are large and repeated many times.
       19.3.2 Declaration
       The other place that code can be placed is outside the doGet() and doPost().
       It is still inside the class definition for the servlet class that gets generated from
       the JSP, but it is not inside any method. Such code is delimited like this:
       <%! code %>
              The exclamation mark makes all the difference. Since it’s outside any
       method, such code typically includes things like variable declarations and
       complete method declarations. For example:
       <%! public static MyType varbl;
       public long
       countEm()
       {
             long retval = 0L;
             retval *= varbl.toLong();
             return retval;
       }
       %>
430                                             Chapter 19    JSP: Servlets Turned Inside Out
         If you tried to do something like this inside of a scriptlet, you would get
    errors when the server tries to compile your JSP. Such syntax belongs at the
    outer lexical level. The use of the <%! ... %> syntax puts it there.
    19.3.3 Expression
    This delimiter is a shorthand for getting output from a very small bit of Java
    into the output stream. It’s not a complete Java statement, only an expression
    that evaluates into a String. Here’s an example:
    <h4>As of <%= new java.util.Date() %></h4>
    which will create a Java Date object (initialized, by default, with the current
    date/time) and then call the toString() method on that object. This yields a
    date/time stamp as part of an <h4> heading.
         Any methods and variables defined inside the previously described
    delimiters are OK to use with this expression shorthand.
         There are also a few predefined servlet variables.
         We’ve described how the JSP is converted into a servlet—the HTML
    statements become println() calls. This all happens inside of an
    HttpServlet-like class, just like our BudgetProServlet extends
    HttpServlet in the previous chapter. In such a class, the method called when
    a request arrives from a browser looks very much like our doBoth() method:
    doBoth(HttpServletRequest request, HttpServletResponse response)
         TIP
         If you want to see the source for the servlet that gets generated when a JSP is
         converted, and if you’re using NetBeans, right-click on the filename (in the
         Explorer view) and, from this menu, choose Compile. Then do it again and
         you’ll notice that the second choice on the menu is View Servlet (Figure 19.1).
               If you are using Apache Tomcat as your Web server, just look in the work
         subdirectory in the directory where Tomcat is installed. In the appropriate subdi-
         rectory you will find both the .java and .class files for your converted JSP
         with the .jsp suffix converted to $jsp.java and $jsp.class respectively.
         For example, BPAcct.jsp becomes BPAcct$jsp.java and is compiled
         into BPAcct$jsp.class.
19.3 How to Write a JSP Application                                                   431
       Figure 19.1 Viewing the converted JSP in NetBeans
            The point here is that a request object and a response object are defined
       by the way the servlet is generated. They are called, oddly enough, request
       and response. In addition to these, a session is defined and initialized, just
       like we did in our servlet example. (What were we thinking?)
            There are a few other variables that the converted servlet has created that
       we can use. We’ll summarize them in Table 19.1. To read more about how to
       use them, look up the Javadoc page for their class definition.
            Remember that these can be used not only by the <%= %> expressions, but
       also by the <% %> snippets of code.
       19.3.4 Directive
       The last of the special delimiters that we will discuss is the one that doesn’t di-
       rectly involve Java code. The <%@ ... %> delimiter encompasses a wide variety
       of directives to the JSP converter. We don’t have the space or the patience to
       cover them all, so we’ll cover the few that you are most likely to need early on
432                                            Chapter 19  JSP: Servlets Turned Inside Out
    Table 19.1 JSP predefined variables
     Type                                       Variable name
     PageContext                                pageContext
     HttpSession                                session
     ServletContext                             application
     ServletConfig                              config
     JspWriter                                  out
    in your use of JSP. We have some good JSP references at the end of this chapter
    for those who want all the gory details of this feature.
    <%@page import="package.name.*" %>
    is the way to provide Java import statements for your JSP. We bet you can
    guess what that happens in the generated servlet.
         Here’s another useful page directive:
    <%@page contentType="text/html" %>
         You’ll see this as the opening line of our JSP, to identify the output MIME
    type for our servlet.
         JSP also has an include directive:
    <%@include file="relative path" %>
         This directive is, for some applications, worth the price of admission alone.
    That is, it is such a useful feature that even if they use nothing else, they could
    use JSP just for this feature. It will include the named file when converting the
    JSP—that is, at compile time.
         It can be used for common header and footer files for a family of Web
    pages. (If you’re a C programmer, think #include.) By defining one header
    file and then using this directive in each JSP, you could give all your JSP the
    same look—say, a corporate logo and title at the top of page and a standard
    copyright statement and hyperlink to your webmaster’s e-mail address at
    the bottom.
         Be aware that this inclusion happens at compile time and is a source-level
    inclusion. That is, you are inserting additional source into the JSP, so if your
19.3 How to Write a JSP Application                                                  433
       included file contains snippets of Java code, they will be part of the resulting
       program. For example, you could define a variable in the included file and
       reference in the including file.
            Also, since this inclusion happens at compile time, if you later change the
       included file, the change will not become visible until the JSP files that do the
       including are recompiled. (On Linux, this is simply a matter of touching all
       the JSP, as in:
       $ touch *.jsp
       assuming all your JSP files are in that directory. Touching them updates their
       time of last modification, so the Web server thinks they’ve been modified so
       the next access will cause them to be reconverted and their generated servlets
       reloaded. You get the idea.
            There is another way to do an include in JSP—one that happens not at
       compile time, but at runtime. The syntax is different than the directives we’ve
       seen so far, but more on that in minute. First, an example of this kind
       of include:
       <jsp:include page="URL" flush="true" />
            In this format, the page specified by the URL (relative to this Web appli-
       cation’s root) is visited and its output is included in place amongst the output
       of this JSP, the one doing the include.
            A few quick notes:
          • Be sure to include the ending “/” in the directive; it’s part of the XML
            syntax which is a shorthand for ending the element in the same tag as you
            begin—that is, <p /> instead of <p> </p>.
          • When all is working, flush being true or false doesn’t matter; when
            the included page has an error, then flush="true" causes the output to
            the browser to end at the point of the include; with flush="false", the
            rest of the page will come out despite the error in the include.
          • The page that is being included is turned into its own servlet. That is, it
            is its own JSP. You don’t have to just include static HTML, you can
            include a JSP.
          • Since this is a runtime include, all you are including is the output of that
            other page. You can’t, with this mechanism, include Java snippets or
            declarations, but only HTML output.
434                                                 Chapter 19    JSP: Servlets Turned Inside Out
    Table 19.2 New XML syntax for JSP constructs
     Standard format                New HTML format
     <% code %>                     <jsp:scriptlet> code </jsp:scriptlet>
     <%! code %>                    <jsp:declaration> code </jsp:declaration>
     <%= expr %>                    <jsp:expression> expr </jsp:expression>
    19.3.5 New Syntax
    But what about that new syntax? It’s an XML-conformant syntax, and it’s the
    syntax for all the newer features added to JSP. In fact, even the old JSP
    syntax, the statements that we’ve discussed, have an alternative new syntax
    (Table 19.2). Prior to JSP 2.0, that syntax was reserved for JSP that produce
    XML rather than HTML. (That’s a whole other can of worms that we won’t
    open now.) Now, as of JSP 2.0, both forms can be used, if your Web server is
    JSP 2.0 compliant.
          You can see that the old syntax is more compact and less distracting than
    the large tags. We suspect that means the old syntax is likely to continue to be
    used for a long time yet.1
          This new syntax is also used for the last two parts of JSP that we will cover,
    useBean and tag libraries.
    19.3.6 JavaBeans in JSP
    For those who really want to avoid doing any Java coding inside of a JSP, there
    is additional syntax that will provide for a lot of capability but without having
    to explicitly write any Java statements. Instead, you write a lot of arcane JSP
    directives, as we’ll show you in just a bit. Is this any better? In some ways yes,
    but in other ways, no, it’s just different syntax.
          What we’ll be able to do with this additional syntax is:
      1. Instantiate a Java class and specify how long it should be kept around
      2. Get values from this class
      3. Set values in this class
    1. The newer XML-style syntax would be useful if your JSP are generated by an XSLT
    stylesheet or are validated against a DTD, both topics being beyond the scope of our discussion.
19.3 How to Write a JSP Application                                                   435
             The syntax looks like this:
       <jsp:useBean id="myvar" class="net.multitool.servlet.AccountBean" />
       which will create a variable called myvar as an instance of the AccountBean
       class found in the net.multitool.servlet package. Think of this as:
       <%! import net.multitool.servlet.AccountBean; %>
       <% AccountBean myval = new AccountBean(); %>
             So can AccountBean be any class? Well, sort of. It can be any class that
       you want, as long as it is a bean. It doesn’t have to end in “Bean”, but it does
       have to be a class which has:
          • A null constructor (you may have noticed there is no syntax to support
             arguments to the constructor on the useBean statement).
          • No public instance variables.
          • Getters and setters for instance variables.
          • Getters and setters named according to a standard: getTotal() or
             isTotal() and setTotal() for a variable called total (isTotal()
             would be used if we had a boolean getter, that is, if the getter returned a
             boolean; otherwise it would expect getTotal() as the getter’s name).
             Otherwise, its a normal class. These restrictions mean that you can call the
       class a “JavaBean” or just “bean,” and there is additional JSP syntax to manipu-
       late the class. Specifically:
       <jsp:getProperty name="myvar" property="total" />
       will do, in effect, the following:
       <%= myvar.getTotal() %>
       or
       <% out.print(myvar.getTotal()); %>
             Similarly, we can set a value in the JSP with this syntax:
       <jsp:setProperty name="myvar" property="total" value="1234" />
436                                          Chapter 19  JSP: Servlets Turned Inside Out
    which will do, in effect, the following:
    <% myvar.setTotal("1234"); %>
         So this would hardly seem worth it, but there are other syntax constructs
    that make this much more powerful. Remember that we’re working with Web-
    based stuff, with a JSP that will be invoked via a URL. That URL may have
    parameters on it, and we can map those parameters onto a bean’s proper-
    ties—that is, connect the parameters to setters for a given bean. We replace the
    value attribute with a parameter attribute, for example:
    <jsp:setProperty name="myvar" property="total" parameter="newtot" />
    which works the same as:
    <% myvar.setTotal ( request.getParameter("newtot") ); %>
         We can take that one step further and map all the parameters that arrive
    in the URL to setters in one step:
    <jsp:setProperty name="myvar" parameter="*" />
         So if you design your JSP and your HTML well, you can get a lot done
    automatically for you. One other thing going on behind the scenes that we’ve
    glossed over is the type of the argument to the setter. The parameters all
    come in as Strings. However, if your setter’s type is a Java primitive, it will
    automatically convert to that type for you, instead of just passing you Strings.
         One final twist on using beans is the duration of the bean and its values.
    If you don’t specify otherwise (and we have yet to show you syntax to do other-
    wise) your bean will be around for the duration of the request, at which time
    it will be available to be garbage-collected. Any values in the bean will not be
    there on the next visit to that URL (i.e., the next call to that servlet).
         Here is the syntax to make that bean last longer:
    <jsp:useBean id="myvar" class="net.multitool.servlet.AccountBean"
                     scope="session" />
    which will make it stay for the duration of the session. You may remember (or
    you can flip back and look up) how we created and used session variables in
    the servlet. The same mechanism is at work here, but behind the scenes. You
19.3 How to Write a JSP Application                                                   437
       only use the specific syntax in the useBean tag, and it does the rest (getting
       and storing) for you.
       19.3.7 Tag Libraries
       Well, we’re almost done with JSP, but the one topic that we have yet to cover
       is huge. It’s the trap door, or the way back out, through which JSP can get to
       lots of other code without the JSP author having to write it. Tag libraries are
       specially packaged libraries of Java code that can be invoked from within the
       JSP. Just like the useBean, they can do a lot of work behind the scenes and
       just return the results.
             There are lots of available libraries, which is one reason for this topic to
       be so huge. We could spend chapters just describing all the various database
       access routines, HTML generating routines, and so on available to you. Perhaps
       the leading tag library is the JSP Standard Tag Library (JSTL).
             Here are two of the most common directives used with tag libraries. First
       is the directive that declares a library to be used:
       <%@ taglib prefix="my" uri="http://java.sun.com/jstl/core" %>
             You then use the prefix as part of the tag name on subsequent tags that
       refer to this library. For example, if we had an out directive in our library, we
       could use my as the prefix, separated by a colon: <my:out ...>.
             The second directive we will show is a for loop. The for loop mechanism
       provided by this library is in some ways simpler than using Java scriptlets. It
       comes in many forms, including one for explicit numeric values:
       <my:forEach var="i" begin="0" end="10" step="2">
             This example will loop six times with i taking on the values 0, then 2,
       then 4, and so on. Another variation of the forEach loop can also make it easy
       to set up the looping values:
       <my:forEach var="stripe" items="red,white,blue">
             In this example it will parse the items string into three values: red,
       white, and blue, assigning each, in turn, to the variable stripe. In fact the
       items attribute can also store an array, or collection, or iterator from the Java
       code that you may have declared (or that is implicit from the underlying
438                                                    Chapter 19    JSP: Servlets Turned Inside Out
      servlet). The forEach will iterate over those values without you having to code
      the explicit next() calls or index your way through an array.
             The bottom of the loop is delimited by the closing tag:
      </my:forEach>
             For more information on these and other tags, check out
         • http://java.sun.com/products/jsp/jstl
         • http://jakarta.apache.org/products/jsp/jstl
         • The references at the end of this chapter
             Beyond the standard library of tags, there are other third-party collections
      of tags; you can also create your own libraries, called custom tag libraries. While
      a useful and powerful thing to do if you have a large JSP-based application,
      such details would expand this book well beyond its scope. If you’re interested
      in this topic, please follow up with some of the excellent references at the end
      of this chapter.
 19.4 USING JSP WITH BUDGETPRO
      We could have taken the BudgetPro example from the previous chapter and
      simply translated it all into JSP files. The reason we didn’t is that it’s not how
      you are likely to find JSP used “in the wild.” Since JSP files become servlets, it
      is not uncommon to find JSP and servlets mixed together—not arbitrarily, but
      in a sensible way. Remember the Model/View/Controller (MVC) pattern from
      your readings on object-oriented programming and design patterns?2 Well, JSP
      makes for a reasonable View, and a plain servlet can act as the Controller. The
      Model is typically the database behind all this. That’s what we’ve done with
      the BudgetPro example.
             We’ve taken the two main chunks of output code—that for the main ac-
      count display and the form used for creating subaccounts—and turned those
      2. If not, then a) you should do some more reading, and b) the MVC pattern is a “classic” way
      to divide the work of a GUI into three distinct parts: Model—the data behind what you are
      doing or displaying; View—a particular way to display that data; and Controller—an object
      that acts as the “traffic cop” to various inputs and events, sending messages to either the View,
      or Model, or both.
19.5 Review                                                                          439
       into JSP files. The main servlet class (BudgetProServlet.java) is thus “gut-
       ted” of its output, and the new version (BudgetProController.java) acts
       as the controller. Requests come to it via HTTP requests, but for output, it
       redirects the browser making that request over to the appropriate JSP.
            This introduces a new bit of servlet syntax—redirecting a request to
       another URL. The action is taken by means of a method call on the HTTP
       response object:
       response.sendRedirect("BPAcct");
            Whereas in the previous, servlet version of BudgetPro, we would create an
       object that was the next page of output:
       nextPage = new AccountView(current);
            In this version, we instead redirect the response to a JSP that produces the
       output for that page.
            So how does the JSP know for which account it should display informa-
       tion? That is shared between the JSP and the controller servlet via the session
       information. As with the previous, servlet-base BudgetPro, the session is used
       to store the current account. It can be retrieved from the session information,
       as seen in line 11 of BPAcct.jsp:
       11:    <% Account acct = (Account) session.getAttribute("current");
            That variable (acct) is then used throughout the JSP to get the appropri-
       ate data for display, as in:
       21:    Account: <%= acct.getName() %>
            We could also have used a session JavaBean. Such a mechanism requires
       more setup on both sides, the controller and the JSP, but has the advantage of
       removing more literal Java code from the JSP. (“We leave this as an exercise for
       the reader!”)
 19.5 REVIEW
       We’ve looked at server-side Java processing with JavaServer Pages which can
       be thought of as servlets turned inside out. From that simple concept we looked
440                                             Chapter 19   JSP: Servlets Turned Inside Out
      at our servlet example and converted it to use JSP. We also looked briefly at
      the syntax for JSP tags and the JSTL, but encouraged you to do more reading
      on this topic.
 19.6 WHAT YOU STILL DON’T KNOW
      We didn’t yet discuss the spelling of JavaServer Pages. If you’ve read through
      this chapter, you may have noticed that there is no space between Java and
      Server but there is a space between Server and Pages. If you’ve read this chapter,
      you may also have some idea of why it’s spelled this way: It’s the JavaServer
      that’s doing the work—serving up the Pages. OK, it’s not a huge deal, but it is
      worth knowing how to spell something kerectly, rite?
            There are volumes that we could have written about tag libraries. Large
      scale projects, and any project with a database connection behind it, will find
      tag libraries invaluable at providing standard mechanisms for database access.
      Check out the resources, below, for more information on tag libraries.
 19.7 RESOURCES
      Some of the best material on JavaServer Pages comes from two of the books we
      mentioned in the previous chapter. You now understand how interrelated the
      two topics of servlets and JSP are, and these two books cover both topics
      very well:
         • Core Servlets and JavaServer Pages by Marty Hall and Larry Brown, ISBN
            0-13-009229-0, a Prentice Hall PTR book.
         • Its sequel, More Servlets and JavaServer Pages by Marty Hall, ISBN
            0-13-067614-1, also by Prentice Hall PTR.
            As we said, the topic of tag libraries is huge, and just writing about JSTL
      could fill it’s own volume. It has. We recommend:
         • Core JSTL: Mastering the JSP Standard Tag Library by David Geary, ISBN
            0-13-100153-1, Sun Microsystems Press.
19.8 Exercises                                                                        441
             To get it straight from the horse’s mouth, there is the official Sun
       specifications for JSP, available at
          • http://java.sun.com/products/jsp/ download.html#specs
 19.8 EXERCISES
         1. Convert the controller and the JSP to share their data via JavaBeans.
         2. Add a control button to each page (BPAcct.jsp) to return not just one
             level upwards, but back to the top level account. (Hint: The controller can
             store a reference to the top level account in a session variable named top.)
     Chapter 20
     Open Source
     Web Application Servers
     Servlets and JSP need to be served up by something; that something is a Web
     application server. What started as simple Web servers serving up little more
     than HTML pages developed into Java application servers—the backbone of
     the enterprise IT environment.
20.1 WHAT YOU WILL LEARN
     In this chapter, we will describe the installation of both the JBoss and Geroni-
     mo Java application servers on a Linux platform. These servers not only run
     servlets and JSP, but they are also, as we shall see in later chapters, J2EE EJB
     containers, so the installation part of this chapter is important for using the
     technologies and examples covered in the remaining chapters. We will review
     the System V init system and explain how to add JBoss to the regular system
     of services on your Linux box. We will show you how to use groups and permis-
     sions to enable a number of nonroot users to do the basic application server
     administration.
                                                                                  443
444                                            Chapter 20    Open Source Web Application Servers
 20.2 DOWNLOADING JBOSS
      JBoss1 is a complete application server. It provides a full, production-ready, J2EE
      environment. Be aware that as of this writing JBoss 4.0 has just passed the Sun
      J2EE certification tests, but even prior to the certification JBoss has been one
      of the most widely used J2EE application servers.
             A great deal of JBoss information can be found on the JBoss Web site.2
      Visit the site’s download page3 to download the product.
             NOTE
             Version 4.0 of JBoss has only just become available, so you will see us using
             the prior production stable version, 3.2.3. By the time you read this, however,
             version 4.0 will be the better choice. What we describe should apply equally
             well to both.
             First off, you must choose what form of the product to download. The
      choice is really between a binary and source distribution. Within that choice,
      you can choose between a number of compression methods. We will download
      and install a binary. Just click on jboss-3.2.3.tgz and save the file. Before
      we install, we need to consider some issues of management.
 20.3 BE AN ENABLER, OR “LET’S BE CODEPENDENT!”
      People often give inadequate consideration to the issues of management of
      software systems. This is especially true of Java systems, which are, by their na-
      ture, cross-platform. We have the luxury of dealing only with Linux systems
      here, so we can make some practical suggestions most books ignore.
      1. JBoss is actually a combination of two distinct projects: JBoss, the EJB container and JMS
      server, and Tomcat, the servlet and JSP server. You can install and use Tomcat alone. We won’t
      bother to do that in this book. We’ll install JBoss and use JBoss for everything. We are also
      lazy typists who do not like to keep typing JBoss/Tomcat, so we’ll refer to it merely as JBoss
      from now on. If you are deploying only servlets and JSP, then, by all means, download and
      install Tomcat only. It is part of the Apache Jakarta project.
      2. http://www.jboss.org/index.html
      3. http://www.jboss.org/downloads/
20.3 Be an Enabler, or “Let’s Be Codependent!”                                              445
             Up to this point, we have largely been considering a situation where the
       Java developer is working on an individual workstation where he or she has
       root access. Now that we are talking about application servers, we are dealing
       with systems where, as the software progresses from development through
       rounds of testing to production, we will want to limit the people who are able
       to change certain elements of the system. Often, the “quick and dirty” strategy
       is to share out the root password to a number of users. This is a serious security
       risk, even when all parties are trusted. Why? Because root isn’t a person. When
       someone logs in as root, we do not know who that person is. We only know
       that it is someone who knows the root password. In some businesses, this is
       an unacceptable ambiguity in audit.
             A common alternative is to restrict root login to the console only, and to
       require the use of the su (“set user”) command to promote an already logged-
       in user to root status. This provides a link back to the individual, so actions
       can be traced to single person. That improves auditability.
             This strategy is better, but since root is an all-or-nothing proposition, it
       is a fairly blunt instrument. Once someone can su to root, that someone can
       do anything. That’s a lot of power to give to someone who just needs to be able
       to install WAR files.
             Yet another strategy is to set up the sudo system.4 Using sudo, you can
       specify what people can execute which commands as root, and where they may
       do it from. In other words, you might let user alice start and stop the Web
       server and mount and unmount filesystems when she is logged in to a local
       machine, but only to start the Web server when she is logged in on a machine
       outside your network. Check out the manpage for sudo to learn more. Even
       this isn’t the best solution for the present issue.
             The best solution is not to require root power at all if you can avoid it.
       Remember that permissions on files in Linux are assigned to users, groups, and
       others. Most people do not think about the middle tier, groups. But groups are
       the best way to give control over parts of the filesystem to a collection of users
       without requiring them to share an account and password.
       20.3.1 Nonroot-Installed Software
       The problem with all of the power-sharing strategies we outlined earlier is that
       once the user escalates to root, there is no way to limit what he or she can do
       4. Some folks pronounce this “ess-you doo,” and some “pseudo.” Whatever floats your boat.
446                                      Chapter 20 Open Source Web Application Servers
    (well, sudo lets you limit it, but a mistake can be fatal—consider what happens
    if you let them run a program that lets them escape to a shell). So, for example,
    if you want to let the Web services group install and maintain JBoss, but you
    don’t want them to mess with any standard software on the system, then create
    a separate place for nonsystem software.
          Two common places for such software on Linux systems are /opt and
    /usr/local. We tend to use /usr/local mainly because this is the default
    path on an awful lot of software that uses autoconf to handle cross-platform
    compilation (it is used by the majority of Free Software programs, but excep-
    tions include what are arguably the four most widely used Free Software pack-
    ages: the Linux kernel, the Apache Web server, the Perl language, and
    XFree86). So we are going to install JBoss under /usr/local and we are going
    to give a number of users the power to install and manage software in
    /usr/local.
          You will need to be root to carry out this procedure. Here are the
    steps—but don’t worry, we’ll pad them out with a lot of ponderous
    explanation:
       1. Create the group.
                Groups are defined in the file /etc/group. Each line in that file
          defines a group. Each line is of the form:
          GroupName:x:GroupID:GroupMembers
                GroupName is the name of the group. It is the group name that shows
          up in long form ls output. The second field is for the group’s password.
          If we may confess, we don’t know if this feature works anymore. You used
          to be able to specify a group password, but this defeats the whole purpose
          of not sharing passwords. Sharing passwords is a security risk. Don’t do
          it. The third field is the group ID number. Remember that files have
          owning users and owning groups. These are both stored as numbers. User
          numbers are known as uids and group numbers as gids. These numbers
          should be unique. If you reuse a number for more than one group, the
          effect could be indeterminate, since it would depend on how a given pro-
          gram was written. Don’t reuse numbers. The final column is a comma-
          delimited list of user names. Those named users are said to belong to the
          group. We’ll talk some more about what that means as we go on.
20.3 Be an Enabler, or “Let’s Be Codependent!”                                              447
                   Imagine that user names bob, ted, carol, and alice are part of
             carl and michael’s Web development team and each has an account on
             the box on which we intend to install JBoss.
                   So, we create a group entry in the /etc/group file:
             local:x:100:carl,michael,bob,carol,ted,alice
                   If Bob later leaves to join the custodial staff, simply remove his name
             from the group and he loses his access.
             TIP
             The user’s default group is specified in the /etc/passwd file. Here’s a sample:
             mschwarz:x:500:500:Michael Schwarz:/home/mschwarz:/bin/bash
             The fields of this are:
             username:passwd:uid:gid:userinfo:homedir:loginprog
             where:
                 • username is the login name of the user.
                 • passwd is the user’s encrypted password. Or rather it used to be. Now,
                   this is usually x and the encrypted password is stored in the
                   /etc/shadow file. This is because /etc/passwd must be world-
                   readable. The shadow file is not. This prevents someone reading the
                   encrypted passwords to do an offline dictionary attack.
                 • uid is the numeric user ID associated with this username.
                 • gid is the numeric group ID of this user’s default group. Look for this
                   number in /etc/group to find the name of the default group.
                 • userinfo is additional information about this user. Sometimes called the
                   gecos field for obscure historical reasons,5 this field usually stores the
                   user’s real name and possibly other information like office location and
                   phone number.
                 • homedir is the user’s home directory.
                 • loginprog is the name of the program that will be executed when the
                   user logs in. This is usually a shell, but it may be any program.
       5. See http://www.hyperdictionary.com/dictionary/GCOS if you are dying to
       know why.
448                                       Chapter 20  Open Source Web Application Servers
       NOTE
       There are two strategies that Linux distributions follow for assigning a default
       group to a new user. One is to put all users into a group called staff or some
       such. This is widely considered a security risk since it often leads to making files
       accidentally readable or writable by all users on the system. The more common
       method is to create a group for each user when the user is created.
       TIP
       If you get in the habit of creating groups, you might want to assign the numbers
       systematically: 500–599 groups for programs, 600–699 groups for program in-
       stallation, 700–799 groups for company departments to allow them to control
       their own Web content, and so on.
    2. Change group ownership of /usr/local.
             Odds are, /usr/local already exists on your system. It may even
       have several programs installed in it. You must give the group ownership
       over everything in /usr/local and below. The chgrp command changes
       the group owner of files, and the -R argument says to do so recursively:
       # cd /usr/local
       # chgrp -R local .
             At this point, everything in /usr/local and below is group-owned
       by the local group.
    3. Set group permissions on /usr/local.
             Basically, you want the group to be able to read and write everything
       in /usr/local. To do this, you need to change the permissions on all the
       files with the chmod. As with chgrp, this command takes a -R argument
       that recursively walks the directory tree. We need to give everyone in the
       group read and write permission on all the files:
       # chmod -R g+rw .
20.3 Be an Enabler, or “Let’s Be Codependent!”                                        449
            NOTE
            We are assuming you are carrying out these steps in sequence and thus your
            current working directory is still /usr/local.
         4. Set directory permissions on /usr/local.
                  You want slightly different permissions on directories. First, you want
            the group to have execute permission on directories. This allows each
            member of the group to make each directory his or her current working
            directory. See Eric Raymond’s Unix and Internet Fundamentals6 for a good
            basic introduction to file permissions on UNIX.
                  Also, on Linux systems, when a user creates a file, that file is, by de-
            fault, group-owned by the user’s primary group,7 which is not what we
            want here. We want files created by a user in this directory to be group-
            owned by the local group. To do this, we have to set the setgid bit on all
            the directories in /usr/local and below. When a user creates a file in a
            directory that has the setgid bit set, that file will be group-owned by the
            group-owner of the directory if the user is a member of that group. If the
            user is not, it will be group-owned by the user’s default group as usual. So
            we need to set execute and setgid permissions on all the directories in
            /usr/local and below:
            # find /usr/local -type d -exec chmod g+xs {} \; -print
            /usr/local
            /usr/local/share
            /usr/local/share/bochs
            /usr/local/share/bochs/keymaps
            /usr/local/share/bochs/keymaps/CVS
            /usr/local/share/doc
            ...
            ...
            etc.
       6. http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/
       disk-layout.html#permissions
       7. Which is the group ID specified for the user in the /etc/passwd file.
450                                          Chapter 20     Open Source Web Application Servers
            With this setup, members of the local group can manage files and pro-
      grams in /usr/local and below as they wish. They have full power over the
      files and they need nothing but their own login credentials to do it. The root
      password can remain private.
      20.3.2 Finer Grained Control
      This pattern can be repeated. We can give ownership of different branches un-
      der /usr/local to other groups to allow control to be doled out in small sets.
 20.4 INSTALLING JBOSS
      Using a platform-neutral system like Java has both advantages and disadvan-
      tages. A disadvantage is that, generally, Java products don’t use the traditional
      installation mechanisms of your native platform. You don’t install an RPM or
      a DEB. But this is somewhat offset by the fact that all a Java application needs
      is for its classes to be arranged in a particular pattern on the filesystem. In other
      words, all you need to do to install JBoss is to unpack the tarball.
            You did the hard part already. Since you have created the group and made
      yourself a member of that group,8 any member of the group can install the
      product:
      $ cd /usr/local
      $ tar xzvf jboss-3.2.3.tgz
      jboss-3.2.3/lib/
      jboss-3.2.3/client/
      jboss-3.2.3/docs/
      jboss-3.2.3/docs/dtd/
      jboss-3.2.3/docs/dtd/html-svg/
      ...
      ...
      etc.
      8. Group membership is established at login. It may be necessary to log out and log back in to
      take advantage of a newly created group. There are other obscure ways, such as running a sub-
      shell with the login argument or running su -, but the simplest is to log out and log back in.
20.5 Things That Make It Go                                                                     451
             TIP
             At this point we suggest using one more Linux filesystem trick. The tarball un-
             packs into a directory whose name includes the product version—in this case,
             jboss-3.2.3. In many cases, you will want to be able to have more than one
             version of JBoss installed on a box simultaneously, either because you need to
             port projects from one version to another, or perhaps because you need to de-
             velop applications that will run on different versions on different target servers.
             To make your life easier, create a symbolic link to a generically named directory,
             such as jboss, and have that symlink point to jboss-3.2.3. Then you can
             write your startup and shutdown scripts to use the jboss pathname. You can
             then switch to another version by changing where the symlink points:
             $ cd /usr/local
             $ ln -s jboss-3.2.3 jboss
                   This process is discussed in detail in Section 6.2 in the context of switching
             between Java SDK versions.
 20.5 THINGS THAT MAKE IT GO
       In order to explain how to integrate an Open Source application server into
       your system, we have to do a little Linux Sysadmin training. We need to show
       you how server processes are generally managed on Linux systems.
       20.5.1 System V Init System
       Virtually all Linux distributions use some variant of the System V init system
       to create and customize programs and services that run at the startup of the
       box. Now, we don’t want to write a Linux system administration manual, but
       we do need to tell you enough to decide how to make JBoss available when
       needed on your server.
             The core of the System V init system is the /etc/inittab file. Everything
       else devolves from this configuration file. In the days before network services,
       the primary startup tasks were to get getty programs running and then run a
       single startup shell script. The /etc/inittab file handles these tasks beautiful-
       ly. Since then, the world of UNIX and Linux has become a complex mixture
       of client-server programs and protocols, so a complex set of conventions has
       been developed to turn the primitive /etc/inittab into a much richer set of
452                                          Chapter 20    Open Source Web Application Servers
    controls. Let’s take a very brief look at /etc/inittab and how it works; then
    we’ll move on to the extended scripts that manage server processes. That is
    where we will integrate JBoss.
            A key concept in the System V init system is the runlevel. The idea is that
    a system can have a number of “standard” configurations, numbered from 0 to
    6, where 0 is shutdown, 1 is single-user, 2 to 5 are up to the system administra-
    tor, and 6 is reboot. The init9 command can be used (by the root user) to
    change the system from its current runlevel to another:
    # init 1
            What happens when you issue such a command is determined by the
    /etc/inittab file. Let’s take a look at the out-of-the-box /etc/inittab file
    from a Fedora Core 110 system (Example 20.1).
            This is a pretty complex file, and we don’t want to bog down in it too
    much, since most of what interests us occurs outside this file.
            The basic format of a line in /etc/inittab is:
    id:runlevels:action:process
            The id is a unique 1–4 character identifier. The runlevels is a list of the
    runlevel numbers to which the record applies. The action specifies what action
    is to be taken. The process is the program to run. The respawn action, for
    example, tells init that when the process exits, it should be run again. The once
    action says it should be run once on transition to the runlevel. We won’t go
    into too much more here. See the man inittab page for details.
            The part that concerns us are the l0 through l6 entries. Note that these
    cause the /etc/rc.d/rc script to be run once, with the runlevel passed as an
    argument. This is the key to System V init system.
    9. telinit is a common alias from other UNIX implementations. Linux symlinks this to init.
    10. During the writing of this book, RedHat decided to put their completely Free Software
    OS out to a public-controlled project and to stop calling it “RedHat.” The name RedHat is
    reserved for Fedora-based Linux systems that must be purchased with support contracts. It is
    still the same system with a different name maintained by basically the same people. The key
    difference is that you cannot purchase support for Fedora (at least from RedHat, we expect
    some enterprising folks to offer Fedora support for a fee at some point).
20.5  Things That Make It Go                                              453
Example 20.1 Fedora Core 1 default /etc/inittab file
#
# inittab          This file describes how the INIT process should set up
#                  the system in a certain runlevel.
#
# Author:          Miquel van Smoorenburg, miquels@drinkel.nl.mugnet.org>
#                  Modified for RHS Linux by Marc Ewing and Donnie Barnes
#
# Default runlevel. The runlevels used by RHS are:
#    0 - halt (Do NOT set initdefault to this)
#    1 - Single user mode
#    2 - Multiuser, without NFS
#         (The same as 3, if you do not have networking)
#    3 - Full multiuser mode
#    4 - unused
#    5 - X11
#    6 - reboot (Do NOT set initdefault to this)
#
id:5:initdefault:
# System initialization.
si::sysinit:/etc/rc.d/rc.sysinit
l0:0:wait:/etc/rc.d/rc       0
l1:1:wait:/etc/rc.d/rc       1
l2:2:wait:/etc/rc.d/rc       2
l3:3:wait:/etc/rc.d/rc       3
l4:4:wait:/etc/rc.d/rc       4
l5:5:wait:/etc/rc.d/rc       5
l6:6:wait:/etc/rc.d/rc       6
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
# When our UPS tells us power has failed, assume we have a few minutes
# of power left. Schedule a shutdown for 2 minutes from now.
# This does, of course, assume you have powered installed and your
# UPS connected and working correctly.
pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"
# If power was restored before the shutdown kicked in, cancel it.
pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"
454                                             Chapter 20   Open Source Web Application Servers
# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
# Run xdm in runlevel 5
x:5:respawn:/etc/X11/prefdm -nodaemon
             NOTE
             Some Linux distributions run different scripts for each runlevel instead of passing
             the runlevel as an argument to a single script. The details are not important.
             The net effect is that a script is run for each runlevel.
             Sure, you could put the code to run JBoss directly in that script if you
       want. But these scripts have been designed to handle arbitrary sets of services
       without you having to modify those scripts directly. How? By doing what Linux
       (and its UNIX antecedents) does so well: making complex systems out of
       simple parts.
             Each service you might wish to start and stop gets a shell script that con-
       trols it. This shell script must take a command argument. The minimum set
       of commands that must be supported are start and stop. Other options such
       as restart and status are often supported, but start and stop are the
       important ones.
             The script for atd, the one-shot job scheduler, is a fine example. Let’s take
       a look at it (Example 20.2).
       Example 20.2 The atd init shell script
       #!/bin/bash
       #
       # /etc/rc.d/init.d/atd
       #
       # Starts the at daemon
       #
       # chkconfig: 345 95 5
20.5 Things That Make It Go                                               455
       # description: Runs commands scheduled by the at command at the \
       #      time specified when at was run, and runs batch commands when \
       #      the load average is low enough.
       # processname: atd
       # Source function library.
       . /etc/init.d/functions
       test -x /usr/sbin/atd || exit 0
       RETVAL=0
       #
       # See how we were called.
       #
       prog="atd"
       start() {
          # Check if atd is already running
          if [ ! -f /var/lock/subsys/atd ]; then
             echo -n $"Starting $prog: "
             daemon /usr/sbin/atd
             RETVAL=$?
             [ $RETVAL -eq 0 ] touch /var/lock/subsys/atd
             echo
          fi
          return $RETVAL
       }
       stop() {
          echo -n $"Stopping $prog: "
          killproc /usr/sbin/atd
          RETVAL=$?
          [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/atd
          echo
             return $RETVAL
       }
       restart() {
          stop
          start
       }
       reload() {
          restart
       }
456                                     Chapter 20    Open Source Web Application Servers
    status_at() {
       status /usr/sbin/atd
    }
    case "$1" in
    start)
       start
       ;;
    stop)
       stop
       ;;
    reload|restart)
       restart
       ;;
    condrestart)
       if [ -f /var/lock/subsys/atd ]; then
          restart
       fi
       ;;
    status)
       status_at
       ;;
    *)
       echo $"Usage: $0 {start|stop|restart|condrestart|status}"
       exit 1
    esac
    exit $?
    exit $RETVAL
          This script is from a RedHat Linux system. Those comments at the top
    are a magic incantation for the chkconfig program that ships with that distri-
    bution11 (and with Fedora Core). We’ll talk more about chkconfig in the next
    section.
          As you can see, the basic premise is that when a daemon is started, the
    process ID is saved into a file. If the “stop” option is passed, the PID is looked
    up and the process is killed. That’s the basic idea. But wait! There’s more!
          Each runlevel has a directory of scripts. Let’s look at the contents of such
    a directory (Example 20.3).
    11. The RedHat chkconfig program is conceptually similar to the one in the IRIX operating
    system.
20.5 Things That Make It Go                                                                   457
       Example 20.3 A directory of scripts
       [mschwarz@host238 mschwarz]$ cd /etc/rc5.d
       [mschwarz@host238 rc5.d]$ ls
       K01yum               K73ypbind                S18rpcgssd           S58ntpd
       K05saslauthd         K74nscd                  S19rpcidmapd         S80sendmail
       K11jboss             K89netplugd              S19rpcsvcgssd        S80spamassassin
       K12mysqld            S00microcode_ctl         S20random            S85gpm
       K15httpd             S04readahead_early S24pcmcia                  S90crond
       K15postgresql S05kudzu                        S25netfs             S90vmware
       K20nfs               S06cpuspeed              S26apmd              S90xfs
       K24irda              S08iptables              S28autofs            S95anacron
       K35smb               S09isdn                  S40smartd            S95atd
       K35vncserver         S10network               S44acpid             S96readahead
       K35winbind           S12syslog                S55cups              S97messagebus
       K36lisa              S13irqbalance            S55sshd              S97rhnsd
       K50snmpd             S13portmap               S56rawdevices        S99local
       K50snmptrapd         S14nfslock               S56xinetd
             Notice the file S95atd? Let’s look at the long form ls output for that file:
       [mschwarz@host238 rc5.d]$ ls -la S95atd
       lrwxrwxrwx 1 root            root     13 Feb 2 02:08 S95atd -> ../init.d/atd
             The file is a symbolic link to the file in the init.d directory! If you take
       a look at the actual script run by the /etc/inittab file on a runlevel change,
       you will notice that what it does is to pick up all the files in the rcX.d directory
       (where X is the runlevel being changed to12 ) that begin with the letter K, run
       through them in numerical order, and execute the linked scripts with stop as
       the argument. It then picks up all the files that begin with S, runs through them
       in numerical order, and executes the linked scripts with start as the argument.
             This sounds like a mess, but it is actually a very nice way to automate the
       starting and stopping of services by runlevel. Adding or removing a new service
       is simply a matter of creating the /etc/init.d script, and then adding the
       12. That phrase actually caused my high school grammar teacher to materialize in my office
       and scold me. I invite anyone who can come up with an elegant and grammatical way to phrase
       that to contact me at mschwarz@multitool.net. I’m perfectly serious.
458                                          Chapter 20   Open Source Web Application Servers
    appropriate symlinks to the rcX.d directories.13 So, first we have to take an
    init script and modify it to run JBoss.
    20.5.2 RedHat/Fedora chkconfig
    RedHat and its stepchild, Fedora, use a program called chkconfig to automate
    the setup and integration of init scripts.
          The chkconfig program has four basic functions. Two involve adding and
    removing services from management. That’s our main interest here, but we’ll
    get to that in a moment. The other two involve querying and setting the run-
    levels in which services run. That is the more common use, so we’ll look at
    those first.
    [root@host238 root]# chkconfig --list ntpd
    ntpd                 0:off     1:off       2:off      3:on       4:off     5:on        6:off
          TIP
          chkconfig --list without specifying a service name will list all the services
          managed by chkconfig, including those that are provided by xinetd, which we
          will not cover here.
          As you can see, ntpd runs at runlevels 3 and 5, and does not run at any
    others. The --list argument lets you query the runlevels.
    [root@host238 root]# chkconfig --levels 2345 ntpd on
    [root@host238 root]# chkconfig --list ntpd
    ntpd                 0:off     1:off       2:on       3:on       4:on      5:on        6:off
          The --levels argument lets you specify a list of runlevels that will apply
    to the named service. The last argument may be on or off to specify which
    setting to apply to those runlevels. The current value (on or off) for a specified
    13. Just a quick reminder that not all Linux distributions name their directories or scripts in
    precisely the same way, but they all use something similar. By examining the /etc/inittab
    file and the contents of the /etc directory, you should be able to figure out the details of any
    given distribution. Over time, more and more distributions have come to exactly match the
    naming scheme described here. RedHat, Fedora, and Debian, for example, all follow this
    naming scheme.
20.5 Things That Make It Go                                                                   459
       runlevel is overwritten by whatever you specify. There is more to this; see the
       manpage for chkconfig for details.
             Now, before we put JBoss under management, we need to make a script
       for it. Or rather, we need to modify the one provided by JBoss. In the bin
       subdirectory of JBoss, you will find a script called jboss_init_redhat.sh.
       You will notice that it has the “chkconfig mojo” in it—that is, the
       “chkconfig:” comment line. We mentioned this in passing when we looked
       at the atd init script, but we didn’t tell you what those three numbers after the
       colon actually mean. The first is the list of runlevels in which you want the
       program to run. The second is the start priority, which is the number that will
       follow the S in the rcX.d runlevel symlink directory. The third number is the
       stop priority, which is the number that will follow the K in the rcX.d runlevel
       symlink directory.
             These start and stop priority numbers can be very important indeed. Some
       services (like NFS) depend upon others (like portmap). Your JBoss server might
       depend on a service like mysqld or postgresql. Don’t toy with these orders
       lightly. You can seriously mess up your services if you don’t know what you are
       doing. Still, you will probably have to tweak things to get them completely
       right. Just be cautious and think about every change.
             Example 20.4 is the script as it comes with JBoss 3.2.3.
             There are three things we have to change here. The first are the runlevels
       in the “chkconfig:” line (we’ll show you the changed lines with a couple of
       lines of context):
       #
       # chkconfig: 345 80 20
       # description: JBoss EJB Container
       #
             Next, we may need to change the paths to JBoss and to the Java runtime.
       In our case, if you installed into /usr/local and created the symbolic link as
       we suggested, you don’t need to change the JBOSS_HOME, but you have to
       change the JAVAPTH variable:14
       14. We are assuming you have set up your Java SDK as described in Chapter 6. If your java*
       commands are located somewhere else, change this path to point at them.
460                                            Chapter 20 Open Source Web Application Servers
Example 20.4 Out-of-the-box JBoss init script for RedHat
#!/bin/sh
#
# JBoss Control Script
#
# chkconfig: 3 80 20
# description: JBoss EJB Container
#
# To use this script,
# run it as root - it will switch to the specified user.
# It loses all console output - use the log.
#
# Here is a little (and extremely primitive)
# startup/shutdown script for RedHat systems. It assumes
# that JBoss lives in /usr/local/jboss, it's run by user
# 'jboss' and JDK binaries are in /usr/local/jdk/bin. All
# this can be changed in the script itself.
# Bojan
#
# Either amend this script for your requirements
# or just ensure that the following variables are set correctly
# before calling the script.
# [ #420297 ] JBoss startup/shutdown for RedHat
# define where jboss is - this is the directory
# containing directories log, bin, conf, etc.
JBOSS_HOME=${JBOSS_HOME:-"/usr/local/jboss"}
# make sure Java is on your path
JAVAPTH=${JAVAPTH:-"/usr/local/jdk/bin"}
# define the classpath for the shutdown class
JBOSSCP=${JBOSSCP:-"$JBOSS_HOME/bin/shutdown.jar:$JBOSS_HOME/client/jnet.jar"}
# define the script to use to start jboss
JBOSSSH=${JBOSSSH:-"$JBOSS_HOME/bin/run.sh -c all"}
if [ -n "$JBOSS_CONSOLE" -a ! -d "$JBOSS_CONSOLE" ]; then
   # ensure the file exists
   touch $JBOSS_CONSOLE
fi
20.5  Things That Make It Go                                               461
if [ -n "$JBOSS_CONSOLE" -a ! -f "$JBOSS_CONSOLE" ]; then
   echo "WARNING: location for saving console log invalid: $JBOSS_CONSOLE"
   echo "WARNING: ignoring it and using /dev/null"
   JBOSS_CONSOLE="/dev/null"
fi
# define what will be done with the console log
JBOSS_CONSOLE=${JBOSS_CONSOLE:-"/dev/null"}
# define the user under which JBoss will run,
# or use RUNASIS to run as the current user
JBOSSUS=${JBOSSUS:-"jboss"}
CMD_START="cd $JBOSS_HOME/bin; $JBOSSSH"
CMD_STOP="java -classpath $JBOSSCP org.jboss.Shutdown --shutdown"
if [ "$JBOSSUS" = "RUNASIS" ]; then
   SUBIT=""
else
   SUBIT="su - $JBOSSUS -c "
fi
if [ -z "`echo $PATH | grep $JAVAPTH`" ]; then
   export PATH=$PATH:$JAVAPTH
fi
if [ ! -d "$JBOSS_HOME" ]; then
   echo JBOSS_HOME does not exist as a valid directory : $JBOSS_HOME
   exit 1
fi
echo CMD_START = $CMD_START
case "$1" in
start)
     cd $JBOSS_HOME/bin
     if [ -z "$SUBIT" ]; then
          eval $CMD_START ${JBOSS_CONSOLE} 2>1
     else
          $SUBIT "$CMD_START ${JBOSS_CONSOLE} 2>1 "
     fi
     ;;
stop)
     if [ -z "$SUBIT" ]; then
          $CMD_STOP
     else
          $SUBIT "$CMD_STOP"
     fi
     ;;
462                                         Chapter 20  Open Source Web Application Servers
restart)
     $0 stop
     $0 start
     ;;
*)
     echo "usage: $0 (start|stop|restart|help)"
esac
        # define where JBoss is - this is the directory
        # containing directories log, bin, conf, etc.
        JBOSS_HOME=${JBOSS_HOME:-"/usr/local/jboss"}
        # make sure Java is on your path
        JAVAPTH=${JAVAPTH:-"/usr/java/jdk/bin"}
             Finally, we don’t need to run the “all” configuration, we only need the
        default configuration at the moment, so we change the argument to the run.sh
        invocation:
        # define the script to use to start JBoss
        JBOSSSH=${JBOSSSH:-"$JBOSS_HOME/bin/run.sh -c default"}
                                       JBoss Configurations
           When you unpacked JBoss, it contained three predefined server configu-
           rations located in jboss/server. The three configurations are named
           all (which runs every single service JBoss supports, including RMI/IIOP
           and clustering features), default (which runs only the set needed to run
           servlets, JSP, and EJBs), and minimal (which runs just JNDI, the logger,
           and a URL deployment service; no Web container, no JMS, no EJBs).
                 In effect, the selected configuration is the server. You can, of
           course, customize any configuration, and you may create additional
           configurations.
             Now, this script allows you to run JBoss as any user. It defaults to user
        jboss if none is specified. You have to decide what to do here. Without speci-
        fying a user, it will run as root. That is a major security risk. On an out-of-the-
        box RedHat or Fedora system, there is no user called jboss. We will have to
        create one. There are a lot of security concerns to creating a special “nonlogin”
        user. The most important involve changing the user entries in /etc/passwd
20.5  Things That Make It Go                                                        463
Example 20.5 Using chkconfig to include JBoss start script
[root@cvs   root]# cd /usr/local/jboss/bin
[root@cvs   bin]# cp jboss_init_redhat.sh /etc/init.d/jboss
[root@cvs   bin]# chkconfig --add jboss
[root@cvs   bin]# chkconfig --list jboss
jboss               0:off    1:off     2:off     3:on      4:on     5:on   6:off
[root@cvs   bin]# /etc/init.d/jboss start
CMD_START   = cd /usr/local/jboss/bin; /usr/local/jboss/bin/run.sh -c default
        and /etc/shadow after you create the user. Unfortunately, the JBoss program
        needs to run a shell script, so you cannot set the shell to /sbin/nologin as is
        usual. Set the password for the user in /etc/shadow to x, which is completely
        invalid and will forbid login to the account by password.
              Finally, you will need to add the user jboss to any groups you created for
        JBoss management (such as local in our case). Truth be told, it would be a
        good idea to use the jboss user to install JBoss. It will avoid having to deal
        with some file ownership and permission issues. If you do not do this, the
        simplest way to get this init script working (you will get permission errors) is
        to run
        chmod -R g+w /usr/local/jboss
              That will make the script work with the jboss user, provided jboss be-
        longs to the group owner of the JBoss installation.
              The final step is to copy your modified script to its final destination and
        run chkconfig to install it in all the runlevels (Example 20.5).
              You now have JBoss running. You can start and stop it with the script,
        and it will come up and shut down automatically depending on the runlevel
        you switch to. Beauty, eh?
        20.5.3 Other Distributions
        You don’t need chkconfig to set up equivalent scripts. In fact, the same script
        provided by JBoss for RedHat will work with most distributions that use Sys-
        tem V init system. You will have to copy the init script and then create the
        appropriate symlinks manually, or locate the automated setup tools for your
        particular distribution (Debian, for example, has many such tools which you
        select with their package management system).
464                                             Chapter 20    Open Source Web Application Servers
      20.5.4 IDE Integration
      Another piece of software you might want to look at is JBoss-IDE,15 an Eclipse
      plug-in for JBoss. The software is not downloadable from the footnoted Web
      site, it is available only from the Eclipse Install/Update manager, so run your
      copy of Eclipse and install it. We will not cover JBoss-IDE here, but if you use
      Eclipse as your development platform, JBoss-IDE is very useful for managing
      and deploying EJB’s, servlets, and JSP.
 20.6 DISPOSITION OF FORCES
      Not to go all Sun-Tzu on you or anything, but if you want to win the war, you
      must control the initiative. In other words, move only when you are ready.
      Deploying software into JBoss could not be easier if you get everything ready
      before you begin.
            You see, the key is to create a correctly configured WAR file, as a
      build.xml file from our project does (Example 20.6).
            If you look at the deploy task, you will see that it simply copies the WAR
      file to a particular directory under the Web server16 and, it turns out, that is all
      you need to do to deploy to JBoss. JBoss will notice the new WAR file, stop
      any existing version, and start the new one. It all depends on getting the WAR
      file right.
 20.7 APACHE GERONIMO
      An up-and-coming alternative to JBoss is Apache Geronimo. Part of the Apache
      Software Foundation’s set of projects, Geronimo is an Open Source, Apache-
      licensed17 implementation of the J2EE specification. Furthermore, Geronimo
      aims to be an Open Source J2EE implementation that is J2EE-certified by
      15.   http://www.jboss.org/developers/projects/jboss/jbosside
      16. Note that that’s normal for development. For integration and production, either someone
      authorized will run the same build on the target, or (more likely) the WAR file will be “formal-
      ly” built, tagged, and copied to the test or production server. We’ll talk more about that when
      we get to application maintenance issues.
      17. Most notably, it doesn’t require anyone to open the source of their changes or customiza-
      tions if they improve on an Apache software project, unlike the GPL which does.
20.7 Apache Geronimo                                                         465
       Example 20.6 Ant build.xml for the BudgetPro servlet and JSP examples
       <!-- ================ File and Directory Names ================= -->
       <!-- ...
         app.name       The name of our application, used for file/dir names.
         build.home     The name of the directory into which the
                        "compile" target will generate its output.
         server.home The name of the directory where the Web server
                        is installed.
         deploy.home The name of the directory into which the WAR file
                        will be copied.
       -->
         <property name="server.home" value="/usr/local/jboss" />
         <property name="deploy.home"
                     value="${server.home}/server/default/deploy"/>
       <!-- ... -->
       <!-- ================ Deploy Target ============================ -->
       <!--
         The "deploy" target copies the WAR file into a location required
         (i.e., defined) by the servlet container. For some servlet
         containers, you must restart them before they will recognize our
         new/modified Web application. Others may reload automatically.
       -->
         <target name="deploy" depends="compile"
                   description="Deploy application to servlet container">
            <!-- Copy the contents of the build directory -->
            <mkdir    dir="${deploy.home}"/>
            <copy todir="${deploy.home}" file="${app.name}.war"/>
         </target>
       <!-- ... -->
       <!-- ================ Product WAR file ========================= -->
         <target name="war" depends="compile"
                   description="Create WAR file to be deployed">
            <war destfile="${app.name}.war" webxml="web/WEB-INF/web.xml">
              <fileset dir="${build.home}"/>
            </war>
         </target>
466                                            Chapter 20     Open Source Web Application Servers
    Sun.18 We will take a quick walk through the installation of the Apache
    Geronimo Java application server. Geronimo not only runs servlets and JSP,
    but it is also, as we shall see in later chapters, a J2EE EJB container, so the
    installation part of this chapter is important for using the examples and
    technologies covered in the remaining chapters.
          Geronimo is a complete application server. It provides a full, production-
    ready, J2EE environment. It is the stated goal of the Geronimo project to pass
    the Sun J2EE certification tests. Such certification will, in all probability,
    quickly make Geronimo one of the most widely used J2EE application servers.
          A great deal of Geronimo information can be found on the Geronimo
    Web site.19
          NOTE
          As of this writing, the project was just nearing the certification process. Only the
          milestone releases were available for downloading. By the time you read this,
          however, a fully certified version will likely be production-ready. There may be
          slight differences in the download and installation procedures. Be sure to follow
          the instructions from the Web site and any readme files for the most up-to-date
          information.
          First off, you must choose what form of the product to download. The
    choice is really between a binary and source distribution. Within that choice,
    you can choose between two compression methods, zip or tar/gzip. While the
    first is typical for Windows distributions and the second for Linux, you can
    choose either, as Linux has utilities for decompressing both. More importantly,
    the binaries are Java JAR files so they are not tied to a particular operating sys-
    tem. We will download and install a binary. Just click on the tar.gz filename
    and save the file.
          If you haven’t read the previous sections because you were going to skip
    JBoss and just use Geronimo, please go back and read Section 20.3. It deals
    with administration and privileges for setting up your installation, and you’ll
    want to know that for this chapter’s installation discussion, too.
    18. As of this writing, there was still a legal hurdle to overcome, since Sun requires derivative
    works to be branded and compatible, whereas the Apache license places no such requirements
    on its derivative works. This may be resolved by the time you are reading this.
    19. http://geronimo.apache.org/
20.8 Installing Geronimo                                                                         467
 20.8 INSTALLING GERONIMO
       Using a platform-neutral system like Java has both advantages and disadvan-
       tages. A disadvantage is that, generally, Java products don’t use the traditional
       installation mechanisms of your native platform. For Linux users that means
       that with Java you don’t install using an RPM or a DEB. But this is somewhat
       offset by the fact that all a Java application needs is for its classes (in JARs) to
       be arranged in a particular pattern on the filesystem. In other words, all you
       need to do to install Geronimo is to unpack the tarball.
              You did the hard part already. Since you have created the group and made
       yourself a member of that group (see Section 20.3), any member of the group
       can install the product:
       $ cd /usr/local
       $ tar xzvf geronimo.tar.gz
       ...
       $
              TIP
              At this point we suggest using one more Linux filesystem trick. The tarball
              unpacks into a directory whose name includes the product version—in this
              case, geronimo-1.0-M1. In many cases, you will want to be able to have
              more than one version of Geronimo installed on a box simultaneously, either
              because you need to port projects from one version to another, or perhaps
              because you need to develop applications that will run on different versions on
              different target servers. To make your life easier, create a symbolic link to a
              generically named directory, such as geronimo and have that symlink point
              to geronimo-1.0-M1. Then you can write your startup and shutdown scripts
              to use the geronimo pathname. You can then switch to another version by
              changing where the symlink points:
              $ cd /usr/local
              $ ln -s geronimo-1.0-M1/ geronimo
                    This process is discussed in detail in Section 6.2 in the context of switching
              between Java SDK versions.
468                                       Chapter 20 Open Source Web Application Servers
 20.9 RUNNING THE GERONIMO SERVER
      Getting the Geronimo server up and running is simply a matter of running a
      Java application contained in the server.jar file in the bin directory.
      $ cd /usr/local/geronimo
      $ java -jar bin/server.jar org/apache/geronimo/Server
           That last parameter looks like a pathname, but it isn’t. It is a configuration
      ID which just uses the pathname-like syntax as a namespace, to be unique to
      Geronimo (by virtue of the /org/apache/geronimo prefix). That name tells
      the server which of the several possible configurations you want to use. For
      more information on the other configurations, refer to the Geronimo Wiki.20
           Having once invoked a particular configuration, you need not repeat that
      configuration choice on subsequent invocations. That means that the next time
      you run Geronimo, you can just use:
      $ java -jar bin/server.jar
           If you want to put this in a startup script you’ll want to use the full
      specification, so as to be absolutely sure what you are getting.
           To stop the server invoked from a command line, simply type Control-C.
      If the server was invoked from a startup script, you will need to find its process
      ID (e.g., with the ps command) and use the Linux kill command to send it
      a signal.
20.10 REVIEW
      In this chapter we have looked at the installation of both the JBoss and
      Geronimo Java application servers on a Linux platform. For both of these Open
      Source servers installation was little more than getting the JAR files in a usable
      location. We reviewed the System V init system and explained how to add JBoss
      to the regular system of services on your Linux box. We showed you how to
      use groups and permissions to enable a number of nonroot users to do the basic
      application server administration.
      20. http://wiki.apache.org/geronimo/
20.12 Resources                                                                     469
20.11 WHAT YOU STILL DON’T KNOW
       There is configuration information about your Web applications that must be
       provided to the Web servers in XML files. A small bit of this will be discussed
       in Chapter 23, but much of this you will need to find elsewhere. Since this in-
       formation is in XML and specific to each application server, there is little of it
       that is specific to the deployment on a Linux system.
20.12 RESOURCES
       Documentation on JBoss is available from JBoss.org. They have an interest-
       ing business model in that they open-source their code but charge for the doc-
       umentation. Expect to see more third-party books on JBoss, or you may see a
       move toward Geronimo instead.
            Geronimo is, as of this writing, a bit sparse on documentation, too. There
       is a Wiki site with the beginnings of documentation. Try and hunt down what
       you need starting from http://wiki.apache.org/geronimo/ and at the
       http://geronimo.apache.org/ home page.
Part V
Developing
Enterprise Scale Software
     Chapter 21
     Introduction to
     Enterprise JavaBeans
     This chapter will serve as an almost criminally brief introduction to Enterprise
     JavaBeans, their varieties, and their uses.
21.1 WHAT YOU WILL LEARN
     You will learn the basics of Enterprise JavaBeans and the Java Naming and
     Directory Interface, which is how applications and EJB’s meet up with one
     another.
21.2 EXPANDING TO EJBS
     All right, we’ll admit it. It is a bit of a stretch to expand our sample application
     to the J2EE Enterprise JavaBean component model. The truth is, given the
     small data requirements and simplicity of our application, the Web front end
     that we put on our application in the previous chapters is probably sufficient
     to scale our application to even very large organizations.
                                                                                      473
474                                     Chapter 21   Introduction to Enterprise JavaBeans
         That confessed, we still think our example is the best way to address our
    topic. Why? Because EJBs are a large topic, worthy of several books (and we
    encourage you to read some of them, such as Enterprise JavaBeans Component
    Architecture by Gail Anderson and Paul Anderson (ISBN 0-13-035571-2). We
    simply cannot teach you all about EJBs in our book. Our goal here is to intro-
    duce the concepts, provide a working example, and explain how to deploy and
    maintain an EJB system on Linux using JBoss. Believe us, we’ll have enough
    to cover to achieve that modest goal.
    21.2.1 EJB Concepts
    In a way, the use of the term Enterprise JavaBean, with its echo of the older
    term JavaBean, is unfortunate. Apart from the similar intention of creating
    reusable components, the two technologies have little in common.
    21.2.1.1 The Life Cycle of an Enterprise JavaBean
    Most of the books on EJBs that we have seen start with the simplest type of
    bean and work their way up in complexity. We’re going to dare to be different,
    because the most complex case isn’t that hard, and once you understand it, the
    functions of all the other types of EJBs become obvious. They simply don’t
    implement what they do not need.
         For the moment, assume that an EJB is a simple class that provides a set
    of methods to clients. The methods represent business functions that clients
    want the server to carry out.
         Implementing an Enterprise JavaBean requires implementing three Java
    source files:
       • An object that represents the bean implementation
       • An interface called the home interface that represents the interface between
         the bean and the EJB container
       • An interface called the remote interface which represents the methods that
         a client may call on the bean
         We’ll get into the details of these interfaces (and the sometimes obtuse
    reasons behind) a little later on. For now, we will concentrate on the
    implementation.
         The implementation class contains methods that are there only to allow
    the container to control the bean and to inform the bean of impending changes
21.2 Expanding to EJBs                                                                  475
       to its status. Those methods are defined in the bean class that the implementa-
       tion class extends. The classes one extends to implement a bean are:
          • SessionBean
          • EntityBean
          • MessageBean
             Please forgive us right now for admitting that we will not cover message
       beans in this book beyond a brief description in the next section. For details
       on message beans, take a look at Chapter 8 of Enterprise JavaBeans Component
       Architecture by Gail Anderson and Paul Anderson (ISBN 0-13-035571-2).
             Not all of the control methods need to be implemented in all cases, but
       the full set is not that large or difficult to understand. They correspond to im-
       portant “life events” in lifetime of the bean. The primary events are: creation,
       destruction, passivation, activation, persist to DB, restore from DB, and context
       switching.
       Creation. A bean is created when its constructor is called. As we shall learn,
       the calling of the constructor has absolutely no connection with a client request.
       For session beans, the container maintains a pool of instances to handle client
       requests. For entity beans, a bean (most commonly) represents a database table,
       and the setEntityContext() method is used to move that bean from row
       (instance) to row as needed.
             In practice, this usually means that a number of instances of the bean are
       created when the application server is started. Additional instances are created
       as the demand for this bean (number of clients, number of calls per unit time)
       increases.
       Destruction.        As you know, Java objects do not have explicit destructors,
       but when a bean instance is destroyed, an explicit method in the Bean class is
       called to permit shutdown operations to take place.
             This is quite distinct from activation and passivation. Activation and pas-
       sivation are operations carried out when the application server needs to shove
       aside some Bean instances that may still be needed by clients in order to make
       room for an active request that requires more than the available system
       resources.
       Passivation and activation.           As we said above, passivation involves the
       container asking the beans that are still potentially needed to step aside to allow
476                                             Chapter 21    Introduction to Enterprise JavaBeans
    more urgent tasks (probably beans that are being actively called) to use resources
    tied up by otherwise idle beans. Think of this as like memory swap in an
    operating system. The bean will save any data and context information into
    some sort of persistent storage, which may be a database, flat files, XML files,
    whatever, when it is passivated.
    Context switching.                Since both session and entity beans may be called
    upon to service requests from multiple clients, it is necessary to provide a
    method whereby the container can notify the bean which “context” (which
    may be loosely said to be a client) is active at the moment. In stateless session
    beans this is not necessarily implemented, but in stateful session beans and in
    entity beans this activity must be supported.
          How is this distinct from passivation and activation? Passivation is the
    temporary “swapping out” of a bean to make room for something else. Context
    switching is the move of a Bean instance from client to client. Or, to put it
    another way, passivation makes room for some other bean to become active
    and serve a client.1 Context switching switches a given bean from client
    to client.2
    21.2.1.2 The EJB Container
    A J2EE application server has two containers: a Web container and an EJB
    container. You can also think of these as “servers” in the more classic sense.
    J2EE calls them containers because it emphasizes the idea that you place Java
    objects (applets, servlets, and Enterprise JavaBeans) into the container that can
    run them (a browser, a Web container, an EJB container). The J2EE specifica-
    tion specifies the exact relationship between these application objects and their
    container. For EJB’s, the container provides lifecycle control, network manage-
    ment, load management, perhaps clustering services, CMP (container-managed
    persistence) services, and so on. We’ll talk a lot more about container services
    1. This is a simplification. A container can passivate a bean to make resources available for any
    purpose, not just for another EJB. Beans might be passivated because some process on the
    server outside the application server needs resources. It is entirely dependent on how the
    application server is written. What is said here is conceptually true, if not actually true ;-)
    2. Again, saying “client-to-client” is a simplification. A single client may have multiple threads
    interacting with multiple beans, and a context switch might be performed to serve different
    requests from a single client. Again: conceptually true, if not actually true.
21.2 Expanding to EJBs                                                                  477
       as we go along. For now, be aware that the container will start, stop, instantiate,
       destroy, and provide network services to the EJBs it contains.
       21.2.2 Bean Types
       Enterprise JavaBeans come in more than one variety. Let’s take a look at those.
       21.2.2.1 Session Beans
       A session bean is a reusable component that represents a collection of server
       methods. The intention is that each such method represents some business
       process, such as addCustomer(), createShoppingCart(), and so on.
             Session beans are thus organized around business processes. Actually, a
       session bean is not much more than a facade that collects a business process
       API into a single class. But remember what EJBs give you—networked server-
       based functionality, load balancing, clustering features, reliability, failover, and
       the ability to handle increased demand by merely adding more Bean instances
       and server hardware. The power comes not from how EJBs extend the language,
       but from how they automate and hide infrastructure.
             Session beans come in two major varieties: stateless and stateful. Let’s take
       a look at what they offer and the differences between the two.
       Stateless Session Beans
       What they are. A stateless session bean is one where each method call is
       completely independent of any other method call, whether by one or many
       clients.
             An EJB application designed this way has certain advantages. Since a single
       Bean instance can be switched from client to client on demand (because no
       state information is kept between method invocations), a small number of Bean
       instances can handle a large number of clients. Compare this with stateful
       session beans described below.
       Why you would use them. In a sense, this is the optimum bean. If you can
       design your application to use nothing but stateless session beans (perhaps
       backed by entity beans), then you have a maximally flexible, extensible, and
       adaptable enterprise application—one that can be easily scaled from a single
       application server to a very large cluster. Why? Because the lack of state infor-
       mation means that any single Bean instance can serve any given client at any
478                                       Chapter 21  Introduction to Enterprise JavaBeans
    time that it is free without requiring any distribution of client information
    between Bean instances.
          From the client’s perspective, the client can connect to any instance of the
    Bean on any server at any time to get the same work done.
    Stateful Session Beans
    What they are. A stateful session bean is one that remembers its client be-
    tween method invocations. It maintains some information between calls from
    a client. Because of this, a given Bean instance can only handle one client at a
    time, and if an instance is to be switched between clients, the information
    about the previous client must be saved so that the client’s session may be
    restored later.
          An application that is designed around stateful session beans will generally
    require more resources than one designed around stateless session beans
    (described above) because each active client requires a dedicated instance of
    the Bean.
    Why you would use them. We think we’ve beaten the issue of the advan-
    tages of stateless beans into the ground. But what are the advantages of a
    stateful bean?
          Many types of client interaction require the bean to “remember” some-
    thing about the client. The classic (and, by now, almost cliché) example is a
    Web-based shopping cart application. The remote interface for a stateful
    ShoppingCart EJB might look something like this:
    createCart
          Creates a new shopping cart for the customer.
    addItem
          Adds an item to the shopping cart.
    delItem
          Removes an item from the shopping cart.
    purchaseCart
          Processes the cart; charges the credit card; generates pick list, shipping list,
          and invoice; discards cart.
    abandonCart
          Discards the cart.
21.2 Expanding to EJBs                                                                  479
             Here, items like the identity of the customer and the list of items in the
       cart must be preserved between method invocations. Obviously, it is possible
       to present such an interface through a stateless bean by creating some sort of a
       session identifier token and passing that in to every method, thus allowing the
       stateless session bean to save this data to a database and then load it back, but
       the primary advantage of a stateful session bean is that this work is done for
       you through the setting of the bean’s context.
             So, the primary advantage of stateful session beans is that the server side
       can keep track of client data for you. The primary disadvantage is that the
       container will try its best to keep an instance of the Bean around for every
       client, so it must sometimes swap an idle instance out to make room for an ac-
       tive instance, which is an expensive operation. But—and this is important to
       keep in mind—it is much less expensive than reading and writing this data on
       every call to a stateless bean! You have to understand what is happening under
       the hood if you want to produce an optimal design. If you need state between
       method calls, a stateful bean is likely to be the most effective way to go.
       21.2.2.2 Entity Beans
       What they are. An entity bean is often described as an object that represents
       a row in a database table. This is the most typical case, but it isn’t always so.
       We have worked on a J2EE application where the entity bean represented an
       XML document in the filesystem.
             The general idea is that enterprise applications tend to work on lists of
       similar things: customers, employees, locations, accounts, servers, inventory
       items, and so on. An entity bean is an object that represents a single item in
       such a list. In other words, it is an interface to a data item. And, yes, in practice
       there is one entity bean class for a table and one instance of the class for
       each row.
             Obviously, a J2EE container doesn’t maintain an in-memory instance for
       every row of every table. In fact, you can think of both entity beans and session
       beans as ways to automate keeping the optimal balance between in-memory
       instances for speed and data storage for memory utilization.
             Entity beans can be written to manage the persistent storage itself, using
       code added to the bean implementation by the bean author (this is known as
       bean-managed persistence, or BMP), or they may be written to allow the
       container to automatically manage the data in the underlying database for you
       (this is known as container-managed persistence, or CMP). Which you use may
480                                        Chapter 21  Introduction to Enterprise JavaBeans
    depend many factors, including the databases your container supports, the
    complexity of your database, the quantity of non-Java clients, or the amount
    of legacy code.
          Entity beans can be a hard sell in many development environments. We
    can see three strong reasons to resist the use of entity beans.
      1. Heterogenous environments. In many enterprises, rich and diverse sets
          of development environments exist—Windows.NET and ASP clients,
          mainframe clients, C and C++ applications, third-party applications, and
          Java. The solution many database environments adopt is to use stored
          procedures that are shared across all of these platforms to concentrate
          database access into a common set of code. Stored procedures do not tend
          to be written with the kind of strict row-to-object mapping that entity
          beans model so well; instead, they are often designed to support specific
          business processes. That fits so well with the session bean model that you
          may be tempted to implement a session bean facade in front of such stored
          procedures and leave it at that.
      2. Legacy code. A variation on the above argument exists when there is al-
          ready a considerable body of code, perhaps even Java code written directly
          using JDBC, that accesses the database and performs the common opera-
          tions. Here again, the simplest solution is to put a session bean facade on
          the already existing code.
      3. Mobile cheese. One of the trendy business books published recently is ti-
          tled Who Moved My Cheese? and it is about the negative ways in which
          people react to change. You might very well meet resistance simply because
          the technology is new and unfamiliar, and represents a change in thinking
          about data persistence from what the development staff is used to doing.
          So, where is it suitable? Entity beans are particularly well suited to environ-
    ments that are homogenous by being based either mostly on Java or on
    CORBA/IIOP. Further, they are well suited to environments where the bulk
    of the work is the editing and manipulation of small numbers of entities per
    session, as opposed to large reports or statistical queries where a session might
    want to use many or all rows in a table.
          Please note that using entity beans in such appropriate cases in no way
    precludes other types of use! You just won’t likely use entity beans for them.
    In other words, you don’t have to use it just because it is there.
21.2 Expanding to EJBs                                                              481
             One further word. This is by no means an established doctrine, but it
       seems to be common practice to keep entity beans hidden behind session beans.
       In other words, it seems to be commonplace to not allow clients (Web applica-
       tions, Java applications) to communicate directly with entity beans, but rather
       to have session beans perform all entity bean operations. This is probably be-
       cause the idea of session beans is to decouple business process from implemen-
       tation details, and entity beans, no matter how much they hide the underlying
       database, are still rather tightly coupled to the implementation of the data
       storage.
       Why you would use them. Essentially, they allow you to write your data
       access layer exactly once, and then reuse it any number times without worrying
       about capacity and management. Also, by trying to keep the most often used
       data in fast memory, they can, when running on a powerful container or cluster
       of containers, keep many client operations running much faster than a strict
       write-read update back end.
       21.2.2.3 Message Beans
       What they are. We’re going to gloss over message beans in our book, but
       you should know what they are. A message bean represents an interface to a
       message queue. An entity bean represents a transaction where completion of
       the call tells you the operation has fully completed. A message queue, on the
       other hand, is an interface where you are given the firm promise that system
       will get to this when it can. The client doesn’t know where or when the message
       will be handled. It doesn’t know if it was successful or not. But it does know
       that it is the problem of the queue reader.
             There are many such operations in large enterprises. And there are many
       products that implement such functionality. Microsoft offers Message Queue
       Server (MSMQ). IBM has MQSeries. Message queues are common with oper-
       ations that take time, or need to be batched, or require human intervention.
       Why you would use them.            Let’s go back to our shopping cart idea. Man-
       agement might want a daily sales report. You could send each and every item
       purchased to a message bean. Then a process to read that queue might be
       kicked off once a day and the report produced without hitting the database that
       supports all the current Web users. That’s a good example of how a message
       queue (and thus a message bean) might be used. Again, we’re not going to work
       with message beans here.
482                                        Chapter 21   Introduction to Enterprise JavaBeans
      21.2.3 Under the Hood
      We’re not going to take apart the source code for JBoss here, but we do want
      to spend some time talking about what is going on in an EJB container. It isn’t
      magic. The whole system is built on some familiar technologies that you can
      learn all about if you want to. First of all, the default protocol for EJB session
      and entity beans is RMI. That’s right. A major part of an EJB container is the
      code to set up RMI connections between beans and clients. RMI is an applica-
      tion protocol that defines how to encode the state of a Java class, transfer it over
      a network (using TCP/IP sockets), and restore the coded data to a local imple-
      mentation of the class (the encoding/decoding process is called marshaling/
      unmarshaling). That’s part one. Knowing where to find the appropriate bean
      is the next part.
 21.3 WHAT’S IN A NAME? AN INTRODUCTION TO JNDI
      JNDI abstracts a type of service known generically as a directory service. We
      need to introduce that concept and then describe a few common examples of
      such systems. Then we can explain how JNDI abstracts these various services.
      21.3.1 Naming and Directory System Concepts
      Directory services are one of the dark mysteries of modern computing. Why?
      Because if the people who developed these systems ever let on how simple they
      actually are, everyone would understand and be able to use them well. Then
      where would we be?
            In practice, a naming system is what we programmers call an associative
      array, or, when we are feeling less verbose, a simple hash of name/value pairs.
      That’s it. The core concept isn’t any more complicated than that. The most
      familiar naming service out there (one that we are sure you use every day)
      is the Internet Domain Name Service, or DNS. This is a system that maps
      domain names (like www.somedumbnetwork.net) to IP addresses (like
      205.117.29.1). In the world of directory services, such a name/value pair is
      called a binding.
            Of course, the devil is in the details. DNS is implemented by a complex
      network of name servers that pass requests up and down a distributed hierarchy
      of name servers. That part can get quite complex, but the core idea is that you
      have a name (the domain name) and a value (an IP address) that you join
21.3 What’s in a Name? An Introduction to JNDI                                               483
      together. DNS can actually bind other information, such multiple alias names
      for a single canonical name/IP pair, a mail handler name for a domain, and
      other general purpose data which the DNS administrator can choose to share.
             So, naming services are a way to join names and values together.
             Before we move on, let’s make sure we understand how general and uni-
      versal this concept is. A filesystem can be thought of as a naming service. A
      UNIX filename (like, say, /etc/inittab) can be thought of as a way of linking
      that name with the data it contains. So the key is the name (/etc/inittab)
      and the value could be either the data it contains, or perhaps a file handle that,
      when read, returns the data contained in the file.3
             There are some other common features of naming systems that we
      should point out. They are frequently hierarchical. A domain name such as
      www.multitool.net actually indicates the host www in the multitool domain
      within the net domain. The name www.multitool.com is not related in any
      way with the name www.multitool.net. They are contained in different top-
      level domains. They do not intersect. Likewise, the name /etc/inittab would
      be completely unrelated to, say, /tmp/inittab—because inittab is a file in
      the etc directory, and inittab is a file in the tmp directory. So, most naming
      systems are hierarchical. They differ in how the levels of the hierarchy are indi-
      cated, and in how absolute names are constructed from components of the
      hierarchy, but they share this common concept.
             So, that’s naming. Next come directory concepts.
             A naming service is good, but what happens if you don’t have the key and
      you need to go looking? That’s what directories are for. Consider the ls com-
      mand. Why do you need it? Have you ever run it? Of course you have. Why?
      Because you often don’t know the exact name of something or where exactly
      it is in a naming system. You need to be able to look for what you want. That
      is the “directory” part of naming and directory services. You want something
      that lets you query and browse the naming system to find what you want.
             The ls command will give you the complete contents of a directory, or it
      will allow you to query a directory by specifying wildcard names. These are ex-
      amples of browse and query features. We’ll talk more about these concepts in
      relation to naming and directory systems in general and to JNDI in particular.
      3. The first case would be a name/value pair, the second case would be a name/reference pair.
      The distinction is often not important, but it does exist.
484                                       Chapter 21   Introduction to Enterprise JavaBeans
          Key to directory services is the concept of a context. A context is a set of
    bindings with a common name, expressed in a common way. In our filesystem
    example, /etc is a context. A context may contain other contexts that follow
    the same naming convention. For example, /etc/sysconfig is a context that
    is a subcontext of /etc. Likewise, multitool.net is a subcontext of the
    net context.
          A context is distinguished by having a naming convention for itself and
    its subcontexts, and it must have means of creating bindings, removing
    bindings, and querying or listing bindings.
          Since JNDI is designed to operate across multiple naming and directory
    systems, it is necessary to talk about naming systems and namespaces. A naming
    system is a connected set of contexts that use the same naming convention.
    Thus, Internet domain names are a naming system, UNIX filenames are a
    naming system, and so on. A namespace is a set of names in a naming system.
    These terms will have significance later when we’ll talk about JNDI.
          A naming system binds a name to a value. Directory services bind a direc-
    tory object to one or more attributes. A naming service could be thought of as
    a simple case of a directory where “name” and “value” are the attributes of the
    directory object. A directory can store many more attributes (bindings) for a
    given name than can a naming service. Directory services also (in general)
    support the notion of searches and queries.
          A directory object represents an object in the computing environment. This
    might be a server, a printer, a user, a router, whatever. Each object would have
    a set of attributes that describe the object. A directory is a connected set of
    directory objects.
          In the directories we know about (see Sections 21.3.2.4 and 21.3.2.5 for
    the limits of our knowledge), directory objects are arranged in a hierarchy, so
    that they serve as naming contexts as well as directory objects.
    21.3.2 Common Directory Services
    Now that you have seen the concepts, we can cover a few common implemen-
    tations of naming and directory services.
    21.3.2.1 Domain Name Service (DNS)
    This is probably the most familiar naming and directory system. It is used all
    the time to resolve Internet host names to IP addresses, and it is commonly
    used to obtain the names of mail servers for domains. It also has less often used
21.3 What’s in a Name? An Introduction to JNDI                                                  485
      features to look up arbitrary data for domains. These features are not used often
      because standard DNS has no authentication and authorization controls.
      Information in DNS is, inherently, public information.
      21.3.2.2 Filesystems
      The UNIX filesystems, NTFS, FAT, and other filesystems provide name-to-
      data mappings that are compatible with JNDI. When they are combined with
      networked filesystems, such as SMB, CIFS, NFS, and even rsync and FTP,
      files can be made available over the network through JNDI.
      21.3.2.3 LDAP
      LDAP is the “Lightweight Directory Access Protocol.” There is an old joke that
      a platypus is a swan put together by a committee. If that is so, then it often
      seems that LDAP is the platypus of name and directory services.
             To be fair, LDAP has the heavy burden that goes with any standards that
      are produced by a large committee-driven process. It has to try to be all things
      to all people. LDAP is a query and transport protocol specification of the
      ISO X.500 naming and directory service standard.4 Like other ISO and ANSI
      standards, the specification is robust to the point of uselessness. LDAP is de-
      signed to allow every possible name system in the Universe to be subsumed into
      a single, uniquely addressable Directory Information Tree. Every entry in
      LDAP has a distinguished name, which is an unambiguous specification of the
      name from the root of the tree. So far, this is like the other naming systems.
      There is a root, there are nodes at each layer, and then, at the bottom, there is
      data. What makes X.500 and LDAP different is that each node consists of not
      just a name, but of a type/name pair. An example of an LDAP name might be:
      url=http://www.multitool.net/,cn=M. Schwarz,o=MAS Consulting,st=MN,c=us
      4. If you are dying to know, X.500 is a naming and directory services standard from the Inter-
      national Standards Organization (ISO), an international technical standards body. X.500 has
      a transport and query protocol specification of its own, but it uses the ISO OSI (Open Systems
      Interconnection) network protocol standard. OSI is rarely used because TCP/IP took off first
      and has been hacked and hacked again to keep it alive and well. At one time, it looked like IP
      address space limitations would push the world to OSI protocols, but hacks like CIDR, private
      subnets, and now the (less hackish) IPv6 make it look like TCP/IP will be here for quite a
      while. In a sense, then, LDAP is X.500 over TCP/IP. Or, to put it another way, LDAP is a
      TCP/IP implementation of ISO X.500.
486                                             Chapter 21    Introduction to Enterprise JavaBeans
           At each node there is a type (c, cn, url, and so on) and a name (or value)
    for that type. The definitions of these types and the lists of types permitted at
    a particular level depend on a schema which is controlled by whoever controls
    the server that serves the given level of the hierarchy. In other words, as with
    DNS, if you want to be part of the public, global namespace, you have to play
    by the rules of the ancestor nodes. You can do what you want with your point
    of control and below, but you must obey the naming schema of all of your
    ancestors.5
           This explains why so few organizations actually use LDAP globally
    (i.e., integrating directly with all other public LDAP servers in the world). In-
    stead, they tend to use LDAP by setting up schema and servers that are com-
    pletely internal and private so that they do not have to use the many required
    parent nodes it would take to hook up to the global LDAP namespace.6
           LDAP can (and does) fill books of its own. The type/name pairs are bulky
    to type and hard to remember, but they allow you to easily map in entire other
    naming systems, by simply assigning a type to a naming system and allowing
    that system’s names to be values at that level. Remember that these names are
    hierarchical, so everything under cn (normally used for “common name”) ap-
    plies to (in this case) Michael Schwarz. If I defined the schema for my space,
    I could put anything I wanted under that name.
           A common use of LDAP is for centralizing authentication and authoriza-
    tion data for users. Users authenticate to LDAP and all systems in an organiza-
    tion can validate a single credential to authenticate the user—the holy grail of
    single sign-in. Alas, doing this right is nontrivial because LDAP doesn’t specify
    any mandatory authentication and encryption scheme. (Thus it is often the
    hacker’s holy grail of single sniff-in and 0wn3d systems.)
    5. We want to be clear: You only have to do this if you wish to give those ancestors and outside
    users access to your directories. You are free to create entirely private directory structures that
    need not conform to anyone else’s schema. It all depends on the purpose and audience of your
    directory.
    6. Another reason is that LDAP itself has no cryptographically secure authentication or trans-
    port mechanisms. That means that hooking up all your directory data to the global Internet
    gives hackers a one-stop opportunity to steal your data. Not good. Of course, as with other
    protocols, there are several add-on security mechanisms for LDAP.
21.3 What’s in a Name? An Introduction to JNDI                                   487
      21.3.2.4 Novell Directory Service (NDS)
      Novell, the folks behind Netware, came up with NDS, which provides full di-
      rectory services like LDAP/X.500, but (according to the computer press—let
      us confess right now that we have never directly used NDS or Microsoft’s Ac-
      tive Directory) with a simpler API and easier administration. We don’t know
      enough about it to comment on it. But we do know that JNDI can access it.
      21.3.2.5 Microsoft’s Active Directory
      We have to do the same hand-waving here. Active Directory provides similar
      functionality to NDS and LDAP. We don’t know enough about it to comment
      on it. But, again, JNDI can talk to it.
      21.3.3 Putting a Face to a Name: JNDI
      The Java Naming and Directory Interface package is designed to provide a
      common way to access all of these disparate naming and directory services.
             The JNDI architecture consists of the JNDI API, which provides a consis-
      tent API, and a Service Provider Interface (SPI), which requires an instance
      to connect to each naming service (such as DNS, LDAP, the RMI registry,
      and so on).
             Basic naming system functionality is obtained through the javax.naming
      package. Directory services are provided by the javax.naming.directory
      package.
             Since JNDI can span multiple naming and directory systems, there are no
      absolute root contexts, so the InitialContext class exists to provide a base
      from which all other names and directories may be looked up.
      21.3.3.1 A Sample JNDI Program
      The next couple of sections describe a very simple JNDI application that uses
      the DNS Service Provider Interface to do directory operations on a DNS
      domain. The source code for the class is shown in Example 21.1.
488                                        Chapter 21 Introduction to Enterprise JavaBeans
Example 21.1 A sample JNDI application
   import java.util.*;
   import javax.naming.*;
   import javax.naming.directory.*;
 5
   public class GetDomain {
     private Hashtable env = new Hashtable();
     private DirContext dctx;
     private String domainQuery;
10
     public GetDomain(String dom2Query) throws NamingException {
       domainQuery = dom2Query;
       env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory");
       dctx = new InitialDirContext(env);
15   }
     public NamingEnumeration getDomainMembers() throws NamingException {
       return dctx.list(domainQuery);
     }
20
     public static void main(String[] args) {
       GetDomain gd = null;
       NamingEnumeration ne = null;
25     try {
         gd = new GetDomain(args[0]);
         ne = gd.getDomainMembers();
         while (ne.hasMore()) {
30         Object o = ne.next();
           System.out.println("Object ["+o+"]");
         }
       } catch (Exception e) {
35       e.printStackTrace();
       }
     }
   }
40
21.3 What’s in a Name? An Introduction to JNDI                                                 489
             Example 21.2 is what we get when we run this program against one of the
      author’s DNS domains.7
      Example 21.2 Running GetDomain against the multitool.net domain
      [mschwarz@cassidy simpleApp]$ java GetDomain multitool.net
      Object [baroni: java.lang.Object]
      Object [erik: java.lang.Object]
      Object [www: java.lang.Object]
      Object [class: java.lang.Object]
      Object [jboss: java.lang.Object]
      Object [penguin: java.lang.Object]
      Object [mail: java.lang.Object]
      Object [cvs: java.lang.Object]
      Object [stiletto: java.lang.Object]
      Object [penfold: java.lang.Object]
      Object [ns2: java.lang.Object]
      Object [ns1: java.lang.Object]
      Object [irc: java.lang.Object]
      [mschwarz@cassidy simpleApp]$
      The GetDomain main() method.                    This is another “single class” program
      example. In this case, the main() method creates an instance of the class,
      passing the first command-line argument to the constructor. We’ll cover the
      constructor in the next section. By now, you will recognize that this is one of
      the purely pedagogical examples. Note the complete lack of input validation
      and error checking on the number and content of the command-line argu-
      ments.
      Establishing an initial context. For both naming and directory services, it
      is necessary to establish an initial context. A context is a collected set of names.
      A directory system is a connected set of contexts. Our example is for DNS.
      We must set an initial context for DNS. The class constructor (lines 11–15)
      does that.
      7. Note that directory operations in the JNDI DNS Service Provider Interface are done with
      DNS zone transfers. Many domains, especially large domains, disable zone transfers either for
      security reasons, or because they generate a lot of network traffic and are a popular tool for
      Denial of Service (DoS) attacks on name servers. To put it simply: This program won’t work
      on a lot of domains, especially from outside.
490                                            Chapter 21     Introduction to Enterprise JavaBeans
           So what is going on here? This constructor is a bit unusual, isn’t it? The
    InitialDirContext is a “context factory.” It takes an “environment,” which
    is a Hashtable, that provides the information needed to make the context.
    And what is that information? At a minimum, the constant value associated
    with Context.INITIAL_CONTEXT_FACTORY must be associated with the class
    name of the real context factory for the directory system—in this case,
    com.sun.jndi.dns.DnsContextFactory. If you are from a C/C++
    background, think of this as a function pointer.8
           We now have an initial directory context, which we can use to search.
    Going from the initial context to a DNS entry.                     Let’s now consider a use
    case for this little program. The program begins at main(), line 21. We create
    an instance of our class and an instance of NamingEnumeration (which we
    will discuss in a moment). We do some very lazy error handling by enclosing
    the entire process in a simple try/catch block9 and treating all exceptions the
    same. The first thing we do is construct an instance of our class, passing in the
    first command-line argument10 as the domain name to use for setting the initial
    context.
           Next, we get an enumeration of all the names in that context. This is done
    through a method in our class that simply wraps the actual JNDI call that ob-
    tains this enumeration. The real event is on line 18. The list() method of
    the directory context returns a NamingEnumeration, which is an extension of
    the classic Enumeration Java class. With it, you can iterate over the contents
    of the context—which we do in lines 29–33. We rely on our old Object
    method, toString(), to make these names readable for us. Of course, each
    8. Of course, it is not. What really happens here is that the code in InitialDirContext
    uses the Class class to load the specified class by name. All JNDI context factory classes imple-
    ment the Context interface, so InitialDirContext uses the ability of Class to load the
    class by its name as an instance of Context.
    9. JNDI has a particularly rich collection of exceptions. When a naming or directory operation
    fails, it is usually possible to determine exactly how and why it failed from the type of
    Exception thrown. All JNDI Exceptions extend NamingException, so they also make it
    quite easy to handle them in a lazy manner. In a real production application, you should at
    least make some effort to differentiate between failures where the network is not working and
    failures where the network is working fine, but the named resource does not exist. Believe us,
    if you have to support your application in production you will care about the difference.
    10. Again, very bad production coding. Note that no attempt is made to check the number of
    arguments passed or their contents.
21.4 Review                                                                                             491
       entry in the enumeration is actually a binding that binds the name to either a
       name object or to a context object.
             If, when you encounter a context, you save the current context, set the
       current context to the new context, and make the method recursive, you would
       walk from the present context on down. In theory, you could set your initial
       context to “.” (which is the root of DNS) and this program would dump the
       whole domain name system to you.11
       21.3.3.2 Learning More about JNDI
       As with so much in this book, we have had time and space to cover only the
       basics. There is so much more to JNDI. For now we want to point you at Sun’s
       excellent JNDI Tutorial.12 JNDI is covered in more depth in many books,
       including JNDI API Tutorial and Reference: Building Directory-Enabled Java
       Applications by Rosanna Lee and Scott Seligman, ISBN 0201705028.
       21.3.4 Using JNDI with JBoss
       For our purposes, it is important to know that JBoss uses JNDI to provide
       much of the EJB container infrastructure. The primary use is to look up the
       EJBs, as we shall see in the code examples in the following chapters.
 21.4 REVIEW
       We covered the basic concepts behind the various types of EJBs. We talked
       about the events in the life of a bean. From here we will go on to describe actual
       implementations and discuss how a bean is written and deployed to a J2EE
       container.
       11. If you are a relatively unschooled net hooligan, let us assure you that this is only “in theory.”
       Before you go off and attempt a DoS attack on the entire Internet with a simple Java class like
       this, we have to tell you that JNDI DNS enumerations depend on a DNS protocol feature
       called zone transfers. Most high-level DNS servers will not do zone transfers at all, and many
       will only accept zone transfer requests from internal addresses. Sorry.
       12.  http://java.sun.com/products/jndi/tutorial
492                                        Chapter 21  Introduction to Enterprise JavaBeans
 21.5 WHAT YOU STILL DON’T KNOW
      Where to begin? Your humble authors themselves are still learning the intrica-
      cies of J2EE. We have more or less ignored message beans. We have not de-
      scribed the local and local home interfaces, concentrating instead on the remote
      access of beans. This is because remote access is what client applications will
      most often use. But entity beans, for example, can only call one another
      through the local interface, and, in practice, a session bean will likely provide
      remote access but call any other beans through a local interface.
            A quick examination of your local bookstore’s computer books section
      will reveal that J2EE is a vast topic, just by the number of books on the topic
      and their thickness. Our goal here is to give you enough to make a quick start
      in using EJBs on a Linux-hosted application server. From there—well, those
      thick books are probably your next stop.
 21.6 RESOURCES
         • http://java.sun.com/products/jndi/tutorial/trailmap.html
            is Sun’s JNDI tutorial.
         • Sun has a J2EE tutorial (http://java.sun.com/j2ee/1.4/docs/
            tutorial/doc/index.html) that is a great place to start.
     Chapter 22
     Building an EJB
     In this chapter we write a very simple EJB and compile it.
22.1 WHAT YOU WILL LEARN
        • What a simple EJB example looks like.
        • What are the several pieces that you need to make an EJB.
        • How to compile the pieces of an EJB.
          You’ll find the full text of our example on the book’s Web site at
     http://www.javalinuxbook.com/. We will only use code excerpts in this
     chapter.
22.2 EJBS: YOU DON’T KNOW BEANS?
     Enough theory about EJBs and naming services and the like. It’s time to put
     together an actual EJB so you can see one run. First we need to write our EJB
                                                                               493
494                                                          Chapter 22   Building an EJB
    classes, then compile them. Then, in the next chapter, we’ll package them,
    along with other supporting information, into an EAR file. But let’s begin by
    writing some Java classes.
          It’s not that we just write a single EJB class, say a session bean, and we’re
    done. Keep in mind that we’re going to be using these beans in a distributed
    environment, so we need a way to have an application running on one system
    find, create, look up, or otherwise access the bean running on another machine
    somewhere in our enterprise network. The job of EJBs is to simplify (up to a
    point) the efforts of the application programmer doing all this, and make it
    seem as if the bean is quite local or at least independent of location.
          Here’s how it works. Any application that wants to use the functions pro-
    vided by an EJB must first locate the bean. It uses a naming service
    (Chapter 21) for this. What it gets from the lookup is something called a home
    interface. The home interface object is in effect a factory for producing remote
    interfaces, which are the proxies for the actual service(s) that our application
    wants to use. A remote interface has the method signatures that give the func-
    tionality that the application is after, but it doesn’t do the actual work of the
    bean. Rather, it is a proxy for the bean. The remote interface’s job is to do all
    the work behind the scenes to marshal the arguments and send them off to the
    bean, and to unmarshal the results returned from the bean.
          So it’s a three step process:
      1. Do the lookup.
      2. Use the home interface to produce a remote interface.
      3. Use the remote interface to call the methods on the bean.
          What’s all this talk about interfaces? They provide a way to define the
    methods you want to use, but without having to write all the code to do it. For
    example, with the remote interface you may define a method to do something
    with several arguments, say Blah(a, b, c). Now the remote object doesn’t
    really do the Blah work; its job is to marshal the arguments (serialized a, b,
    and c) and send them off to the EJB to do whatever Blah is, and then unmar-
    shal the results. So you as an application programmer will write the guts of
    Blah in the EJB object, but for the remote object, its proxy, you only need to
    declare the method signature. Then the job of the EJB container (e.g., JBoss
    or Geronimo) is to provide the smarts of the proxy—that is, to generate a Java
    class that implements your interface, along with the code that knows how to
    contact your EJB and marshal and unmarshal the arguments and results. That’s
22.2 EJBs: You Don’t Know Beans?                                                      495
       right, the EJB container (server) makes code that uses your interfaces, along
       with its own code, to do the infrastructure work of EJBs.
             Talking about all these pieces of an EJB can be confusing, too. Sometimes
       it is helpful to think of an EJB as a single class; sometimes it’s better to think
       of it as a family of classes that act together pretending to be a single bean that
       is distributed across several hosts. This can make it a bit confusing when talking
       about an EJB—do we mean the family of interacting classes or do we mean the
       single class that provides the application functionality that we want?
             The names of EJB classes and EJB interfaces (which we will extend and
       implement) don’t help much either—they can be confusing, too. For example,
       we will extend EJBObject, but not to write an EJB session bean; no, we extend
       SessionBean for that, but EJBObject is the name for the remote interface.
       Go figure.
             A bit of perspective may help here. The names Remote, Local, and Home
       are used as modifiers on these classes. Local means “on the same host as the
       bean.” But Home and Remote don’t offer much of a clue. The home interface
       is what we get from a lookup; it produces remote objects (objects which imple-
       ment the remote interface). A remote object is what our application uses as if
       it were a Java object doing what we need, even though its application-specific
       activity will happen on a bean somewhere else on the network.
             Let’s look at a very very simple example, to see the pieces in action.
       22.2.1 SessionBean
       Let’s write a stateless session bean that will compute the time value of money.
       Why that? Well, two reasons. First, we already have an SAMoney class with a
       save() method for computing some values; and second, we need some simple,
       stateless, but somewhat computationally intensive task to make for a halfway
       reasonable example.
             The real guts of an EJB, the core of the application functionality—in our
       example, the computation of the time value of money—is the session (or entity)
       bean. For our session bean we begin by implementing the SessionBean
       interface, which means that we need to define these methods:
       public    void  setSessionContext(SessionContext context) { }
       public    void  ejbCreate() { }
       public    void  ejbRemove() { }
       public    void  ejbActivate() { }
       public    void  ejbPassivate() { }
496                                                          Chapter 22  Building an EJB
    which, for our example, we can implement as empty methods. A stateless ses-
    sion bean never needs an activation or passivation method to do anything—it
    is pointless to passivate a stateless session bean. Why? Since it’s stateless, any
    instance of it is as good as any other, so the instances are interchangeable and
    there’s no need to passivate one to get to another—just use the one available.
    It follows that if a bean is never passivated, it will never have to be activated.
          But why no body to the ejbCreate() method? Well, our bean isn’t doing
    anything extra. This would only be used if our example were more complicated
    and we needed to do application-specific initializations. For example, if the
    bean had to connect to a database (and did not use entity beans), it might es-
    tablish the JDBC connection in ejbCreate and close it in ejbRemove().
    Similarly, we can have an empty ejbRemove() method.
          Next we add our own methods, the ones that provide the application
    functionality. For our MoneyBean application, we’ll add save() and debt()
    methods which will use an SAMoney class by calling its save() and debt()
    methods. Example 22.1 is the listing of the SessionBean.
    Example 22.1 Listing of our implementation of a SessionBean
    package com.jadol.budgetpro;
    import net.multitool.util.*;
    import javax.ejb.*;
    /**
      * Actual implementation of the EJB
      */
    public class
    MoneyEJBean
       implements SessionBean
    {
       protected SessionContext sessionContext;
       // typical; just not used now
       public Cost
       save(double amt, double rate, double paymnt)
         throws java.rmi.RemoteException
       {
         return SAMoney.save(amt, rate, paymnt);
       } // save
22.2 EJBs: You Don’t Know Beans?                                                       497
          public Cost
          debt(double amt, double rate, double paymnt)
            throws java.rmi.RemoteException
          {
            return SAMoney.debt(amt, rate, paymnt);
          } // debt
          public void
          setSessionContext(SessionContext context)
          {
            sessionContext = context;
          } // setSessionContext
          public void
          ejbCreate() { }
          public void
          ejbRemove() { }
          public void
          ejbActivate() { }
          public void
          ejbPassivate() { }
       } // interface MoneyEJBean
       22.2.2 EJBObject
       At the other end of the chain of EJB objects used to accomplish all this distribut-
       ed computing is the object that our application is actually going to touch.
       When our application creates an EJB, it, acting as a client, won’t actually get
       its hands on the distant session (or entity) bean because that session bean is
       running somewhere out in the network. There will be, however, a proxy object,
       acting on behalf of the distant EJB. It is described as the remote interface, be-
       cause it is remote from the EJB (though very close to the application). It is an
       interface because J2EE supplies a class that does the hidden work of marshaling
       the data, contacting the EJB, sending the data and receiving the results; the
       application developer only adds a few additional application-specific methods,
       via this interface (Example 22.2).
498                                                        Chapter 22 Building an EJB
    Example 22.2 Sample remote interface
    package com.jadol.budgetpro;
    import javax.ejb.*;
    import java.rmi.*;
    import net.multitool.util.*;
    /**
      * Remote Interface for the Money EJB
      */
    public interface
    Money
       extends EJBObject
    {
       // the methods from the remote object which we will call
       public Cost
       save(double amt, double rate, double paymnt)
         throws java.rmi.RemoteException;
       public Cost
       debt(double amt, double rate, double paymnt)
         throws java.rmi.RemoteException;
    } // interface Money
          The crucial thing to note with this interface is that we have defined two
    methods that match the two methods in our SessionBean—the save() and
    debt() methods. These are the methods that will actually be called by our ap-
    plication, and the J2EE mechanisms will do their work behind the scenes to
    connect to the methods of our SessionBean implementation and send back
    the results.
    22.2.3 EJBHome
    Between the SessionBean and its remote interface lies the home interface, also
    called the remote home interface, since it pairs with the remote interface. An
    object that implements the home interface is the kind of object that is returned
    after the lookup() and then narrow() method calls. It is used to create a ref-
    erence to the EJB. The home interface for a stateless session bean needs only
    implement a single method, the create() method with no arguments. The
    body of the method needs do nothing. All the real work is done by the
    underlying object supplied by J2EE.
22.2 EJBs: You Don’t Know Beans?                                                     499
             Example 22.3 is a listing of our home interface. It looks like an empty
       shell, but it is all that we need. The rest is handled by J2EE.
       Example 22.3 Sample (remote) home interface
       package com.jadol.budgetpro;
       import javax.ejb.*;
       import java.rmi.*;
       /**
         * Remote Home Interface
         */
       public interface
       MoneyHome
          extends EJBHome
       {
          public Money
          create()
            throws CreateException, RemoteException
          ;
       } // interface MoneyHome
       22.2.4 Summarizing the Pieces
       With these three pieces—the session bean, the remote interface, and the home
       interface—we can see the structure of the key pieces of an EJB. Let’s review
       what we have:
        Application object         Extends/implements         Talked about as
        Money                      EJBObject                  remote interface
        MoneyHome                  EJBHome                    home interface
        MoneyBean                  SessionBean                the implementation
       22.2.5 EJBLocalHome and EJBLocalObject
       When the session or entity bean is going to be referenced by application code
       that resides on the same host as the bean, there are variations on the home and
       remote interfaces that allow for more efficient execution. When you know that
       the beans are local to this host, you should use a local interface (Example 22.4)
500                                                      Chapter 22    Building an EJB
    Example 22.4 Sample local interface
    package com.jadol.budgetpro;
    import javax.ejb.*;
    import java.rmi.*;
    /**
      * Local Interface for the Money EJB
      */
    public interface
    MoneyLocal
       extends EJBLocalObject
    {
       // the methods which we will call
    } // interface MoneyLocal
    Example 22.5 Sample local home interface
    package com.jadol.budgetpro;
    import javax.ejb.*;
    import java.rmi.*;
    /**
      * Local Home Interface
      */
    public interface
    MoneyLocalHome
       extends EJBLocalHome
    {
       public MoneyLocal
       create()
         throws CreateException;
    } // interface MoneyLocalHome
    and a local home interface (Example 22.5). The local interface is in place of the
    remote interface and extends EJBLocalObject. The local home interface is in
    place of the remote home interface and extends EJBLocalHome.
         Why bother? Well, there’s no need to marshal and unmarshal all that data
    if the calls are staying on the same host. This saves execution time. Perhaps
    more importantly, since the arguments don’t have to be marshaled and
22.2 EJBs: You Don’t Know Beans?                                                                 501
       unmarshaled, they don’t have to be serializable. For some applications, this is
       the only way that they can use beans.
             Finally, keep in mind that the choice of local versus remote interfaces is
       not necessarily an either-or choice. For our session bean we have defined both
       kinds of interfaces. Then the deployment can determine which one will be used.
       22.2.6 Compiling Your Beans
       In order to compile these bean-related Java classes, you need to have a J2EE
       JAR in your classpath. If you’ve installed JBoss into /usr/local/jboss, you
       could add the JAR to your classpath this way:
       export CLASSPATH="/usr/local/jboss/client"\
       "/jboss-j2ee.jar:.:${CLASSPATH}"
             If you have the Sun J2EE reference implementation installed on your
       system (in /usr/local), then you could use:
       export CLASSPATH="/usr/local/SUNWappserver"\
       "/lib/j2ee.jar:.:${CLASSPATH}"
             If you have Geronimo installed on your system (with an environment
       variable GHOME to hold its location), then you would use:1
       export CLASSPATH="${GHOME}/repository/geronimo-spec/jars"\
       "/geronimo-spec-j2ee-1.0-M1.jar:.:${CLASSPATH}"
             In any case, the point is to have in your classpath the JAR file which
       contains the javax/ejb/ classes, such as EJBObject.class. If you haven’t
       installed one of these containers on your machine, then download a copy of
       the JAR from the machine where that container is installed. Put your copy
       somewhere in your classpath, as in the examples above.
       1. Our JAR is named geronimo-spec-j2ee-1.0-M1.jar but yours will likely have a dif-
       ferent name by the time the J2EE-certified version of Geronimo is available. It may likely just
       have the trailing -M1 dropped from the name; check in the geronimo-spec/jars directory.
       Another option is to use any of the J2EE JARs, for example, from the Sun reference implemen-
       tation. That’s the advantage of standards. Any of them should work for this compilation step.
       The resulting compiled code should be deployable to any server. “Compile once, run
       anywhere,” right?
502                                                            Chapter 22 Building an EJB
            If you are using Ant (and why wouldn’t you be?) you will need to put the
      path to the J2EE JAR in the classpath which Ant uses. Since Ant can define its
      own classpath, you may want to define your compile task as something like this:
      <target name="compile" >
      <javac srcdir="${src}"
            destdir="${build}"
            classpath="/usr/local/SUNWappserver/lib/j2ee.jar:${stdpath}" />
      </target>
            Now it’s a simple matter to compile. The basic Java compile command:
      $ javac com/jadol/budgetpro/*.java
      will compile all the various classes and interfaces that make up the EJB. There
      may be other classes in your source tree that need to be compiled as well. With
      all that going on, you can see why so many people use Ant. With the compile
      target defined as in our example above, you would need only the command:
      $ ant compile
 22.3 REVIEW
      There are many pieces involved in the construction of an EJB. Besides writing
      the session bean implementation, there are the remote and home interfaces to
      be written. The local and local home interfaces are optional, but useful, espe-
      cially in cases where arguments cannot be serialized or where you know that
      the beans and the client will reside on the same host. Compiling an EJB is not
      different from any other Java compile, but it requires a special JAR in your
      classpath, one that contains the definitions of the J2EE objects and interfaces.
 22.4 WHAT YOU STILL DON’T KNOW
      We still haven’t shown you how to deploy the EJB, now that you have one
      compiled. In the next chapter we’ll show you how to assemble the pieces of the
      EJB into an Enterprise Archive and then deploy and run it.
            More importantly, though, we haven’t covered how to write the code for
      stateful session beans or entity beans. Stateful session beans are one-to-a-client-
      session, rather than taking all comers, so there is a little more to code, and a
22.5 Resources                                                                        503
       few small changes required in the ejb-jar.xml config file. (What is the
       ejb-jar.xml config file? It is part of the configuration information used to
       deploy your EJB, the topic of the next chapter.) But there are some serious
       complications with entity beans that involve retrieving the bean’s data from
       a “backing store”—for example, a database—and writing it back. There are
       many good references on these topics, and we mention our favorites in the
       next section.
 22.5 RESOURCES
       These are some of our favorite resources for learning about and dealing with
       EJBs. All of these give much more extensive examples that we have space for,
       and we encourage you to look at one or more of them.
          • J2EE and Beyond by Art Taylor (Prentice Hall PTR, ISBN
            0-13-141745-2) gives a very good overview of all of the pieces of J2EE.
            At over 1,000 pages, it’s no small book, but it covers a lot more than
            just EJBs.
          • Enterprise JavaBeans Component Architecture: Designing and Coding Enter-
            prise Applications by Gail Anderson and Paul Anderson, Sun Microsystems
            Press, ISBN 0-13-035571-2. At only 435 pages it is the most concise of
            the three, with the tightest focus and an emphasis on the code.
          • Applied Enterprise JavaBeans Technology by Kevin Boone, Sun Microsystems
            Press, ISBN 0-13-044915-6. At just over 700 pages, it is midway between
            the other two titles. Like the Taylor book, it covers some related technolo-
            gies, but gives more depth to EJBs than Taylor, as that is its focus. It pro-
            vides more examples than the Andersons, but its examples are not any
            deeper, just broader.
     Chapter 23
     Deploying EJBs
     In this chapter we take apart an EAR, put it together, and then send it out into
     the world.
23.1 WHAT YOU WILL LEARN
        • What is in an EAR.
        • How to build an EAR by hand.
        • How to integrate some of the tools we’ve covered before (CVS and Ant)
          to automate this and avoid having to build an EAR by hand.
        • How to deploy an EAR to JBoss.
        • How to deploy an EAR to Geronimo.
          Some people may wonder why anyone would want to describe to you how
     to build an EAR by hand. The task of constructing such things is increasingly
     automated, often performed by IDEs, Ant, or J2EE containers or related tools.
     So why the grubby details of doing it yourself? Two reasons, really. First, if you
                                                                                    505
506                                                              Chapter 23  Deploying EJBs
      hide behind the tool, you never fully understand what is happening. It looks
      too much like magic, and you’re helpless if the magic fails. Secondly, seeing
      how it works inside out gives you a better understanding of what is going on
      and even empowers you to do a custom version for your project. If this discus-
      sion sounds familiar, it may be because you read something similar about IDEs
      in Chapter 10.
 23.2 LEND ME YOUR EAR: ENTERPRISE PACKAGING AND DEPLOYMENT
      There are lots of pieces that are needed to make Enterprise JavaBeans (EJBs)
      work—not only the classes and interfaces that we have defined, but supporting
      classes and other Web application pieces (e.g., JSP files) as well. They all have
      to be in the right place. The distributed nature of EJBs means that we need a
      way to distribute them across (potentially) several machines. And its not just a
      matter of putting a single Enterprise JavaBean on a single host. A single bean
      is typically part of a larger collection of classes and other files (properties, im-
      ages, JSP, HTML) that work together to make an application. The mechanism
      to manage all this is the Enterprise Archive, or EAR file.
            Let’s take a look inside an EAR and examine its pieces. Knowing what
      it’s made of will make an EAR look less intimidating, but will also help us
      understand what we’ll need for our application.
            TIP
            An EAR file (whose name ends with .ear) is nothing more than a JAR file with
            particular expected contents. So you can easily look inside an EAR with the jar
            command. Use the -tvf options for table of contents, verbose, and file
            (meaning that the next argument is the filename).
            The budgetpro.ear file will be our example. We haven’t yet discussed
      building this file, but let’s peek ahead, to see how it will be put together
      (Example 23.1).
            Notice that, at the top level, there are two files and a directory, and inside
      the directory there are two other files (Table 23.1).
            From the standpoint of building an EAR yourself, you need to create all
      the files listed in Table 23.1 and then put them all together into a JAR file. So
      we need to understand those pieces.
23.2 Lend Me Your EAR: Enterprise Packaging and Deployment                                  507
       Example 23.1 Contents of a sample EAR file
       $ jar   -tvf budgetpro.ear
            0  Wed May 19 05:58:02       CDT  2004   META-INF/
         110   Wed May 19 05:58:00       CDT  2004   META-INF/MANIFEST.MF
         295   Wed May 19 05:58:00       CDT  2004   META-INF/application.xml
       11498   Wed May 19 05:58:02       CDT  2004   budgetpro.jar
       12626   Wed May 19 05:58:02       CDT  2004   budgetpro.war
       $
       Table 23.1 Files inside an EAR archive
        Name                  Type      Content
        budgetpro.jar         JAR       The EJB-JAR file—the JAR file that contains our EJB.
        budgetpro.war         WAR       The Web application with servlet and JSP files.
        MANIFEST.MF           text      A standard JAR manifest; at a minimum, it gives the
                                        version number of the JAR file format—for example,
                                        Manifest-Version: 1.0.
        application.xml XML             The deployment descriptor, an XML description of
                                        what’s what.
        META-INF              directory A directory with other files.
             The plain files that appear in the META-INF directory are simple. The
       MANIFEST.MF       file is like any JAR manifest and can contain simply the JAR
       version number:
       Manifest-Version: 1.0
             The application.xml file is shown in Example 23.2
             Two JAR files are mentioned in this XML description file. This tells the
       container that we have two modules, an EJB and a Web application. The Web
       module also defines a context root, which is the portion of the URL pathname
       that is intended to direct requests to this Web application. For example, if your
       host is www.bighost.com, then the context root of /budgetpro means that
       the URL you will use to access the Web application in this EAR is
       www.bighost.com/budgetpro/ followed by whatever other filename you
       might need to append, such as a JSP file—or, if left blank, the default
       index.html file.
508                                                         Chapter 23   Deploying EJBs
    Example 23.2 Sample application.xml file
    <?xml version="1.0" encoding="ISO-8859-1"?>
    <application>
      <display-name>BudgetPro</display-name>
      <module>
      <web>
         <web-uri>budgetpro.war</web-uri>
         <context-root>/budgetpro</context-root>
      </web>
      </module>
      <module>
         <ejb>budgetpro.jar</ejb>
      </module>
    </application>
         That takes care of the two plain files. Let’s also look inside the other two
    archives, the JAR file and the WAR file, and see what they hold.
    23.2.1 What’s in an EJB-JAR File
    Let’s look first at the content of the JAR file. After that we’ll look at the specifics
    of the XML descriptor files.
    $ jar xf budgetpro.ear          # unjar the EAR
    $ ls                            # see what we got
    META-INF
    budgetpro.ear
    budgetpro.jar
    budgetpro.war
    $ jar tf *.jar                  # list the JAR contents
    META-INF/
    META-INF/MANIFEST.MF
    com/
    com/jadol/
    com/jadol/budgetpro/
    net/
    net/multitool/
    net/multitool/util/
    com/jadol/budgetpro/MoneyLocal.class
    com/jadol/budgetpro/SessionTestServlet.class
23.2 Lend Me Your EAR: Enterprise Packaging and Deployment                                    509
       com/jadol/budgetpro/MoneyEJBean.class
       com/jadol/budgetpro/MoneyHome.class
       com/jadol/budgetpro/Money.class
       com/jadol/budgetpro/MoneyLocalHome.class
       com/jadol/budgetpro/TestMoneyEJBean.class
       net/multitool/util/Save.class
       net/multitool/util/Cost.class
       net/multitool/util/Debt.class
       net/multitool/util/SAMoney.class
       META-INF/ejb-jar.xml
       META-INF/jboss.xml
       $
             The EJB-JAR file contains the specifics for our EJB file (Table 23.2).
             To keep Table 23.2 simpler and shorter, we didn’t list each of the directo-
       ries in the tree of directories down to each class file. When we show, for exam-
       ple, com/jadol/budgetpro/*, realize that each directory that is part of that
       structure (com, com/jadol, and so on) is part of the JAR file. The class files
       are located in that tree.
             So what are the two XML files?
             These XML files provide the EJB container with information on how the
       bean parts are wired together. Let’s look at the contents of each.
       Table 23.2 Contents of the EJB-JAR file
        Name                         Type       Content
        MANIFEST.MF                  text       A standard JAR manifest; besides defining the
                                                JAR version it can be empty.
        ejb-jar.xml                  XML        A description of the EJB, most importantly the
                                                mapping between the name of the EJB and the
                                                actual Java class file.
        jboss.xml                    XML        This file is specific to JBoss (well, duh!). It
                                                describes a mapping between the JNDI name
                                                used in the locate() and the name of the EJB.
                                                The equivalent file for Geronimo (which uses
                                                OpenEJB) is openejb-jar.xml.
        net/multitool/util/*         class files Various classes.
        com/jadol/budgetpro/* class files        Various classes.
        META-INF                     directory  A directory with other files.
510                                                      Chapter 23  Deploying EJBs
         The ejb-jar.xml file (Example 23.3) is part of the J2EE standard. It
    specifies the names of the home and remote (and local, if any) interfaces, the
    implementation class (i.e., the real bean) and the name for the bean.
    Example 23.3 Sample ejb-jar.xml file
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE ejb-jar PUBLIC
      "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN"
      "http://java.sun.com/dtd/ejb-jar_2_0.dtd">
    <ejb-jar>
      <description>BudgetPro</description>
      <display-name>BudgetPro</display-name>
      <enterprise-beans>
         <!-- Session Beans -->
         <session id="test_Money">
           <display-name>Test Money Bean</display-name>
           <ejb-name>test/Money</ejb-name>
           <home>com.jadol.budgetpro.MoneyHome</home>
           <remote>com.jadol.budgetpro.Money</remote>
           <ejb-class>com.jadol.budgetpro.MoneyEJBean</ejb-class>
           <session-type>Stateless</session-type>
           <transaction-type>Container</transaction-type>
         </session>
      </enterprise-beans>
      <assembly-descriptor>
      </assembly-descriptor>
    </ejb-jar>
         The name of the bean defined in the ejb-jar.xml file is not, however,
    the name we will use in our JNDI lookup. Rather, there is one more level of
    mapping used by JBoss. Look at the contents of the jboss.xml file
    (Example 23.4).
23.2 Lend Me Your EAR: Enterprise Packaging and Deployment                         511
       Example 23.4 Sample jboss.xml file
       <?xml version="1.0" encoding="UTF-8"?>
       <!DOCTYPE jboss PUBLIC "-//JBoss//DTD JBOSS//EN"
          "http://www.jboss.org/j2ee/dtd/jboss.dtd">
       <jboss>
          <enterprise-beans>
            <session>
               <ejb-name>test/Money</ejb-name>
               <jndi-name>ejb/Money</jndi-name>
            </session>
          </enterprise-beans>
          <resource-managers>
          </resource-managers>
       </jboss>
             The two tags define the mapping: You use the jndi-name in the
       lookup() method and it will (try to) find the EJB named with the ejb-name
       tag. The ejb-name tag is also used in the ejb-jar.xml file. This provides the
       association between the two, and the mapping from the JNDI name to EJB is
       thereby defined.
             To summarize, if we want to build an EJB-JAR file, we will need to gather
       all the class files in their appropriate classpath directory structures. Then we
       will need to write two XML files and place them in the META-INF directory
       along with the MANIFEST.MF file. The two XML files will define the EJB pieces
       and provide a name mapping for locating this bean. Then put all these pieces
       together into a JAR file, and you have an EJB-JAR file.
       23.2.2 Using Our Bean
       We have put a lot of pieces in place to get a bean that we can call from across
       the enterprise. But what does that call look like? How might we make use of
       the bean?
             The first step is to make contact with the JNDI service and locate the
       home interface for the bean. It looks like the section of code in Example 23.5.
512                                                           Chapter 23 Deploying EJBs
Example 23.5 Locating the home interface
//Look up home interface
InitialContext initctxt = new InitialContext();
Object obj = initctxt.lookup("ejb/Money");
MoneyHome homer = (MoneyHome) PortableRemoteObject.narrow(obj, MoneyHome.class);
             We’re putting this code in the init() method of a servlet; it could also
        be in a test program, or in a JSP. It needs to happen only once for our servlet
        (which is why we put it in the init() method) and then the connection can
        be used many times, once for each contact with the bean.
             We get to the actual bean this way:
        Money mrbean;
        mrbean = homer.create();
             We then use the bean, making the calls on its remote interface (a Money
        object, that extends EJBObject) as if it were just a simple method call on an
        ordinary class:
        car = mrbean.save(20000.00, 0.04, 250.00);
             The math is done in the actual SessionBean, out there in the network,
        and the results are sent back to this application. Our application goes on to
        display this number as part of an HTML page.
             Then when we’re done with the bean, we need to clean up:
        mrbean.remove();
        23.2.3 Packaging the Servlet
        We will now package up the servlet, along with a simple startup page to invoke
        it. We’ll look at the WAR file and see how it’s built.
        23.2.3.1 What Is in the WAR File
        The other JAR-like file in the EAR is the WAR file. Let’s see what is in one of
        those (Table 23.3).
             Notice that the WAR file puts its XML descriptor not in the META-INF
        directory but in a WEB-INF directory along with the classes.
23.2 Lend Me Your EAR: Enterprise Packaging and Deployment                                       513
       Table 23.3 Contents of the WAR file
        Name                      Type      Content
        MANIFEST.MF               text      A standard JAR manifest; it can be empty or list the
                                            contents.
        web.xml                   XML       XML description of the Web application—servlet
                                            definitions, and so on.
        jboss-web.xml             XML       Empty in our example—no JBoss-specific directives
                                            are used.
        classes                   directory Directory structure for the Java class files.
        classes/.../*.class class           The various class files.
        *.jsp                     JSP       These are the JSP files that run as part of the Web
                                            application; note that they are in the top level of this
                                            directory structure, not in any subdirectory.
        *.html                    HTML      Any static HTML pages, too.
        META-INF                  directory A directory with other files.
        WEB-INF                   directory A directory with other files.
       23.2.3.2 Weaving the Web
       The web.xml file is the descriptor for the Web application part of all this.
       Using the servlet tag, it defines a servlet associating a name with this servlet
       (a name which can be used elsewhere in this XML file) and stating which
       Java class file is that servlet.
            Then the servlet-mapping tag is used to map a URL pattern to a servlet.
       The URL pattern is the portion of the URL that signals to the server that the
       request is not for a simple HTML page, but rather for our servlet.
            Example 23.6 is a sample web.xml; notice in particular how the mapping
       from URLs to the Java class is accomplished.
       23.2.3.3 Connecting the Pieces
       So now that you have seen all the pieces, know that you can edit the XML files
       with your favorite editor, and can build the JAR/WAR/EAR files with the jar
       command, it’s not that hard to put it all together. It is, however, tedious, and
       is well worth automating, at least with Ant.
            The key to making it work, whether by hand or by automation, is a
       workable directory structure. The easiest way to construct JAR files is to have
514                                                           Chapter 23 Deploying EJBs
Example 23.6 Sample web.xml file
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app PUBLIC
  "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
  "http://java.sun.com/dtd/web-app_2_3.dtd">
<web-app>
  <servlet>
    <servlet-name>SessionServlet</servlet-name>
    <display-name>Simple Session Servlet</display-name>
    <servlet-class>com.jadol.budgetpro.SessionTestServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>SessionServlet</servlet-name>
    <url-pattern>/servlet/test</url-pattern>
  </servlet-mapping>
  <session-config>
    <session-timeout>0</session-timeout>
  </session-config>
</web-app>
       a directory structure that mirrors the structure of the JARs that you are build-
       ing. But that arrangement is often not helpful for source management purposes.
       It is therefore not uncommon to have a source tree that reflects the project
       structure and a separate build directory that mirrors the JAR file directory lay-
       out. As classes are compiled, the class files are copied into the build directory
       along with copies of the XML, JSP, and other files. As a last step in the build
       process, the build directories are “jarred up” into WAR/JAR/EAR files.
 23.3 DEPLOYING THE EAR
       Deploying means getting your file(s) into the right place and dealing with the
       Web server to get your application up and running. For EJBs this includes the
23.3 Deploying the EAR                                                                 515
       automatic construction of various components by the server. It’s not as daunt-
       ing as it sounds—at least not any more.
       23.3.1 JBoss
       One of the great things about JBoss is its dynamic or “hot” deployment. The
       only work involved in deploying your application, if you have the EAR file built
       properly, is to copy the EAR file to the deployment directory. JBoss does all
       the rest.
             Here is a listing of a very simple shell script that does what is needed, fol-
       lowed by an invocation of that shell script to install our BudgetPro example
       EAR file.
       $ cat ejbinstall
       cp $* /usr/local/jboss-3.2.3/server/default/deploy
       $ ejbinstall budgetpro.ear
       $
             Of course, this assumes that execute permission has been given to the
       script and it is located in the search path. Furthermore, it assumes that JBoss
       (version 3.2.3) was installed in /usr/local.
       23.3.2 Geronimo
       Geronimo will be undergoing lots of change between the time that we write
       this and the time that you read this. Be sure to check the Geronimo Web site1
       for the latest information.
             Geronimo deployment is done as a separate executable step and is not
       folded into the server. This separation of functions keeps the server smaller and
       quicker on startup. The deployer has the smarts for reading in all the XML
       configuration information for your bean, building all the needed classes, and
       serializing it to package it up.
             To deploy our EAR, we execute the following command from the
       Geronimo home directory:
       $ java -jar bin/deployer.jar --install --module budgetpro.ear
       1. http://geronimo.apache.org/
516                                                             Chapter 23    Deploying EJBs
            Although not available in the early releases, Geronimo may add a “hot
      deploy” feature where the EAR file can just be put into a deploy directory and
      the rest will happen automatically. Even so, what will be happening behind the
      scenes is this same deploy step.
 23.4 MAINTAINING A DISTRIBUTED APPLICATION
      The deployment is easy if you have the EAR file built properly. But as you just
      saw, that can be a big “if”—the EAR consists of several layers of files that must
      be in the right place and have the right contents. There are tools to help with
      all this, though. Ant is widely used to automate many of these tasks.
      23.4.1 Ant and CVS
      In previous chapters we’ve talked about CVS for managing sources and Ant
      for automating our builds. The first step to making all this work together is
      something that we should have covered sooner—using CVS with Ant.2
            Example 23.7 is a simple Ant buildfile (build.xml) that will let you get
      the source from your CVS repository by supplying a particular CVS tag. You
      name the tag (which you would have previously applied to your sources) and
      this Ant target will check out that version. The files are put in the srctree
      directory off of the basedir of the Ant project.
            You will have to modify this script to make it fit your environment. The
      cvsRoot and csvRsh values correspond to the CVSROOT and CVS_RSH environ-
      ment variables that you would otherwise have set for working with CVS. The
      package attribute should be set to the project directory that you would specify
      when you check out sources. The directory specified by the dest attribute will
      be created if it doesn’t exist.
            The next task to accomplish with Ant is the construction of the EAR,
      WAR, and JAR files. Since all three files are essentially just JAR files, we can
      use the Ant jar task. The EAR contains a WAR and a JAR, and those in turn
      contain Java class files (and a few miscellaneous files). Using the depends
      attribute, we can build them in steps.
      2. So, aren’t you glad that you’ve kept reading and gotten this far? Ah, the rewards of
      persistence!
23.4 Maintaining a Distributed Application                                          517
      Example 23.7 An Ant target for checking out source from CVS
      <?xml version="1.0"?>
      <!-- ++++++++++++++++++++++++++++++++++++++++++++++           -->
      <!--          retrieve our sources by tag name                -->
      <!--          invoke with: ant -DTAG=puttaghere               -->
      <!-- ++++++++++++++++++++++++++++++++++++++++++++++           -->
      <project name="sources" default="src" basedir=".">
         <!-- src target -->
         <target name="src">
            <cvs cvsRoot=":ext:user@hostaddress:/usr/lib/cvs/cvsroot"
                   cvsRsh="/usr/bin/ssh"
                   package="projectdir/subproj"
                   dest="srctree"
                   tag="${TAG}">
            </cvs>
         </target>
      </project>
             Our example (see the book’s Web site3 for the full listing) only copies
      prebuilt XML files (the deployment descriptors) into place to be included in
      the JAR, WAR, and EAR files. For small examples like ours, building the de-
      ployment descriptors by hand is not a difficult task. But larger, more complex
      projects will benefit from further automation. Most J2EE servers come with
      tools to help build such things. These tools tend to be specific to the particulars
      of their products. Since the J2EE specification allows for certain vendor varia-
      tions and configuration differences, they can be helpful in configuring things
      for your specific vendor’s version. But being dependent on them for your de-
      ployment is a subtle way to become locked into their product. Another good
      choice—one that avoids this vendor lock-in—is the Open Source tool XDoclet.
      23.4.2 XDoclet
      XDoclet is an important tool to help with the automation of EJB-related tasks.
      Working in conjunction with Ant, it uses the Javadoc mechanism of Java to
      3. http://www.javalinuxbook.com/
518                                                          Chapter 23   Deploying EJBs
      automate the building of many of the EJB files and deployment descriptors.
      Recall that Java comments can include special Javadoc tags, such as @author
      and @param. Javadoc uses these tags to generate HTML files that are the docu-
      mentation of your Java classes and methods based on the text associated with
      these tags. XDoclet takes this a step further and defines tags like @ejb.bean
      and a few dozen more. Then, using the Javadoc mechanism, it can generate all
      the various pieces required for an EJB. Used this way, you can write a single
      source file for your EJB, and have XDoclet generate the various home, remote,
      and local interfaces as well as the deployment descriptors.
            So why aren’t we all using XDoclet? It has been around for a few years and
      is gaining a following in the development community. We may be moving in
      that direction, but it will take some time. It adds yet another layer to what is
      needed to build an EJB application, albeit a layer that brings some simplifica-
      tion. Later releases of EJB specifications from Sun may subsume its EJB func-
      tionality. However, it is still very important to understand the pieces that go
      together to make an EJB application. One of the favorite quotes from XDoclet
      in Action by Craig Walls and Norman Richards says it well: “Don’t generate
      what you don’t understand.”
 23.5 ABSTRACTING LEGACY APPLICATIONS
      One of the best uses of J2EE technology, particularly the EJB technology, is to
      provide a single common interface to heterogenous systems. If an application
      provides any sort of file, data, pipe, or network access to its data, you can wrap
      an EJB interface around it and make it available to an entire distributed net-
      work. This can be a powerful way to leverage investments in legacy systems
      with modern multitier architectures.
            While it is commonplace for EJB applications to interface directly to a re-
      lational database back end, there is no requirement that such a system be the
      back end. IBM, for example, provides Java interfaces to their mainframe legacy
      data systems, such as CICS.
 23.6 REVIEW
      We’ve looked at the contents of an EAR file—not that you’ll need to be digging
      inside them or even building them by hand, but you’ll want to know what’s
      inside so as to understand what it takes to put one together. We took a look at
23.8 Resources                                                                     519
       Ant and CVS and how they can be used together to make building and
       deployment easier. We even mentioned XDoclet, another tool worth knowing
       something about.
 23.7 WHAT YOU STILL DON’T KNOW
       JBoss has an IDE plug-in for Eclipse which uses XDoclet to provide an integrat-
       ed development environment for writing EJBs. If you are working with Eclipse
       and are going to be doing a lot of EJB development, you should definitely
       explore this option.
             The EJB 3.0 specification, due out within a year, promises to change all
       this, at least somewhat. With support for metadata in Java 1.5 there will be a
       standardized mechanism available for use in EJB class construction and
       deployment. Look for some significant improvements in usability.
 23.8 RESOURCES
          • Visit http://geronimo.apache.org for the latest information on
             Geronimo.
          • Visit http://www.jboss.org for the latest information on JBoss.
             For more information about all the tags that can be put into the various
       XML configuration files, look at the DTD files which define them, for example:
          • http://java.sun.com/dtd/ejb-jar_2_0.dtd
          • http://www.jboss.org/j2ee/dtd/jboss.dtd
          • http://www.jboss.org/j2ee/dtd/jboss-web.dtd
             XDoclet in Action by Craig Walls and Norman Richards (Manning Publi-
       cations, ISBN 1932394052) covers the Open Source XDoclet tool for automat-
       ing the generation of Java code and related files (e.g., deployment descriptors).
     Chapter 24
     Parting Shots
     We try to wrap this whole thing up, talk about the future, and beg for
     your help.
24.1 THE FUTURE’S SO BRIGHT, I SQUINT AND LOOK CONFUSED
     Our crystal ball is a bit foggy, though. Linux is a moving target, and so is Java.
     In a twist of fate that few could have predicted, the Mono project has a .NET
     development platform for Linux (and, in fact, for most UNIX-like operating
     systems). Sun has been talking about open-sourcing Java.1 New languages and
     tools emerge all the time. Heck, Geronimo popped up during the research and
     writing of this very book, while JBoss was the first to pass the Compatibility
     Test Suite for J2EE. Two minor and one major Java release happened during
     the writing of this book. A major Linux kernel release occurred. Naught endures
     but mutability. (The only constant is change.)
     1. And may we drop all pretense of objectivity and say “Go, Sun! Go! Open it up!”
                                                                                       521
522                                                                     Chapter 24     Parting Shots
             The three things we can say with confidence are that with Java, Linux, and
      Open Source, the platform and the tools only get better, the price doesn’t go
      up, and everyone has the chance to play on an level field.
             We wouldn’t dream of predicting the future, but we’re sure that both
      Linux and Java will have a significant place in it.
 24.2 OUR BOOK IS YOURS
      This is an Open Content book (as we explained in Preface). You will be able
      to take it and do with it what you please. We plan to keep improving the book
      online, and we’d like to invite you all to join in. The authors (who like to refer
      to themselves in the third person) have the book set up on public servers at
      http://www.javalinuxbook.com/ and we welcome comments, suggestions,
      even patch files.
             Don’t be afraid to participate. Credit of some sort will be given to every
      accepted contribution.
 24.3 CAME THE REVOLUTION
      A lot of people write about Free Software and Open Source in terms ranging
      from economic history to political revolutionary rhetoric. One of your present
      humble authors has even written the phrase “economic inevitability” in a weak
      moment. And while there is ample room to speculate on the future by looking
      at the past, and while there actually are legitimate issues of liberty, rights, and
      politics in the mix, it is always shaky when an argument veers close to tautology
      (“Free Software is right because it is right”).
             Some people will actually choose Free Software for political reasons, just
      as some Americans chose rebellion for political reasons. But the majority of
      Americans in 1776 were not revolutionaries, and the majority of people using
      Linux are not either. We have other concerns. In both cases, keeping bread on
      the table is a greater concern for most than the revolutionary issue.
             Read Richard Stallman’s writings if you are interested in the revolution.
      Read Lawrence Lessig2 if you are interested in the politics and legal issues.
      2. A Stanford Law School professor and founder of the Center for Internet and Society, Lessig
      is the author of three remarkable books: Code and Other Laws of Cyberspace, The Future of Ideas:
24.5 Resources                                                                                  523
       Most of us, however, will be asking how these technologies can put bread on
       our table.
              The key is lifelong learning. And that is where Open has a distinct advan-
       tage. You want to know how it works? Look. There is a lot of good code (and
       some very bad code) out there, free for the taking, analyzing, and for certain
       uses. One of the arguments made for closed code is a quality argument. But as
       programmers who have worked on closed systems, we can tell you that we have
       seen plenty of bad code out that is closed and proprietary. You just have to look
       at news about viruses and worms to know that. The point is that Open Source
       and Free Software are a safer investment. In closed systems there is always
       pressure to “churn” the APIs so that new OS versions and new development
       tools can be sold. There is some of that in Free Software too, but you can watch
       it as it happens, and if a program is your bread and butter, you can participate.
              In any revolution, there are the brave and foolhardy rushing to the barri-
       cades, banners in hand. But the sensible are keeping their heads down and try-
       ing to figure out how to get through it all. We hope our modest contribution
       helps the latter.
 24.4 WHAT YOU STILL DON’T KNOW
       This is a book about writing Java applications on Linux systems. We hope we’ve
       given you enough to get started, and pointed you to some tools and techniques
       that, while they’ve been around a while, may not all be well known or
       documented.
              We’ve said it before, but each of our chapters tried to cover in a small
       space what really takes volumes. Our aim has been to give you a flavor, and a
       start, and a direction.
 24.5 RESOURCES
       This book that you are reading is part of the Bruce Perens’ Open Source Series,
       “a definitive series of Linux and Open Source books” according to the publisher
       The Fate of the Commons in a Connected World, and Free Culture: How Big Media Uses Technology
       and the Law to Lock Down Culture and Control Creativity.
524                                                          Chapter 24  Parting Shots
    Prentice Hall PTR; and who are we to disagree? Seriously though, we encourage
    you to check out any or all of the titles in the series.
         We have already mentioned the more philosophical works by Stallman
    and by Lessig. As a final reference we offer one that covers not the political
    philosophy of Open Source but the practical philosophy of what makes Linux
    so successful. It’s called Linux and the UNIX Philosophy by Mike Gancarz,
    published by Digital Press (ISBN 1555582737). It gives practical examples of
    the way Linux does things, which makes it so useful, so usable, and so enduring.
    If you’re going to be developing on Linux, we encourage you to read it. It is
    easier to swim with the tide, and understanding the design approaches behind
    Linux will give you that advantage.
Appendix A
ASCII Chart
All our favorite computer books have an ASCII chart. We wanted one, too.
Int     Oct     Hex  ASCII                Int    Oct   Hex   ASCII
---    ----     ---  -----                ---   ----   ---   -----
  0     000      00   ^@                   19    023    13     ^S
  1     001      01   ^A                   20    024    14     ^T
  2     002      02   ^B                   21    025    15     ^U
  3     003      03   ^C                   22    026    16     ^V
  4     004      04   ^D                   23    027    17     ^W
  5     005      05   ^E                   24    030    18     ^X
  6     006      06   ^F                   25    031    19     ^Y
  7     007      07   ^G                   26    032    1a     ^Z
  8     010      08   ^H                   27    033    1b     ^[
  9     011      09   ^I                   28    034    1c     ^\
 10     012      0a   ^J                   29    035    1d     ^]
 11     013      0b   ^K                   30    036    1e     ^^
 12     014      0c   ^L                   31    037    1f     ^_
 13     015      0d   ^M                   32    040    20
 14     016      0e   ^N                   33    041    21     !
 15     017      0f   ^O                   34    042    22     "
 16     020      10   ^P                   35    043    23     #
 17     021      11   ^Q                   36    044    24     $
 18     022      12   ^R                   37    045    25     %
                                                                       525
526                             Appendix A   ASCII Chart
    Int  Oct Hex ASCII Int  Oct   Hex     ASCII
    --- ---- --- ----- --- ----   ---     -----
     38  046  26  &     83  123    53      S
     39  047  27  '     84  124    54      T
     40  050  28  (     85  125    55      U
     41  051  29  )     86  126    56      V
     42  052  2a  *     87  127    57      W
     43  053  2b  +     88  130    58      X
     44  054  2c  ,     89  131    59      Y
     45  055  2d  -     90  132    5a      Z
     46  056  2e  .     91  133    5b      [
     47  057  2f  /     92  134    5c      \
     48  060  30  0     93  135    5d      ]
     49  061  31  1     94  136    5e      ^
     50  062  32  2     95  137    5f      _
     51  063  33  3     96  140    60      `
     52  064  34  4     97  141    61      a
     53  065  35  5     98  142    62      b
     54  066  36  6     99  143    63      c
     55  067  37  7    100  144    64      d
     56  070  38  8    101  145    65      e
     57  071  39  9    102  146    66      f
     58  072  3a  :    103  147    67      g
     59  073  3b  ;    104  150    68      h
     60  074  3c  <    105  151    69      i
     61  075  3d  =    106  152    6a      j
     62  076  3e  >    107  153    6b      k
     63  077  3f  ?    108  154    6c      l
     64  100  40  @    109  155    6d      m
     65  101  41  A    110  156    6e      n
     66  102  42  B    111  157    6f      o
     67  103  43  C    112  160    70      p
     68  104  44  D    113  161    71      q
     69  105  45  E    114  162    72      r
     70  106  46  F    115  163    73      s
     71  107  47  G    116  164    74      t
     72  110  48  H    117  165    75      u
     73  111  49  I    118  166    76      v
     74  112  4a  J    119  167    77      w
     75  113  4b  K    120  170    78      x
     76  114  4c  L    121  171    79      y
     77  115  4d  M    122  172    7a      z
     78  116  4e  N    123  173    7b      {
     79  117  4f  O    124  174    7c      |
     80  120  50  P    125  175    7d      }
     81  121  51  Q    126  176    7e      ~
     82  122  52  R    127  177    7f     ^?
         Appendix B
         A Java Swing GUI
         for BudgetPro
This is the listing of the GUI for BudgetPro. For a discussion, see Chapter 16.
  1 package net.multitool.gui;
  2
  3 import   java.awt.*;
  4 import   java.awt.event.*;
  5 import   javax.swing.*;
  6 import   javax.swing.event.*;
  7 import   javax.swing.table.*;
  8 import   java.util.*;
  9 import   net.multitool.core.*;
 10
 11 /**
 12   * This class is the main application class for the BudgetPro gui
 13   */
 14
 15 public class
 16 BudgetPro
 17 {
 18    Account top;
 19    Account current;
 20
                                                                                527
528                                      Appendix B A Java Swing GUI for BudgetPro
 21 // gui components
 22 private JFrame frame;    // needed by dialogs to root themselves
 23 private JLabel nam;
 24 private JLabel tot;
 25 private JLabel val;
 26 private JButton upton  = new JButton(
                       new ImageIcon("net/multitool/gui/back.gif"));
 27 private JButton creat  = new JButton("New Subaccount");
 28 private JButton view   = new JButton("View Subaccount");
 29 private JButton clos   = new JButton("Quit");
 30
 31 private JTable list;
 32 private AbstractTableModel model;
 33
 34 private AcctDialog askem;    // make once, use often
 35
 36 // Set Up an Action for a Button
 37 private ActionListener upAction = new ActionListener()
 38 {
 39   public void
 40   actionPerformed(ActionEvent e)
 41   {
 42     // this is the action for UP arrow icon;
 43     Account next;
 44     next = current.getParent();
 45     if (next != null) {
 46       current = next;
 47       setStatus();
 48       // TODO: notify the table, too
 49       model.fireTableDataChanged();
 50     } // TODO: else infodialog or Beep.
 51   }
 52 } ;
 53
 54 private ActionListener cdAction = new ActionListener()
 55 {
 56   public void
 57   actionPerformed(ActionEvent e)
 58   {
 59     // this is the action for VIEW subdirectory;
 60     // a "cd" into the subaccount.
 61     int row = list.getSelectedRow();
 62     // System.out.println("Row="+row); // DEBUG; TODO: REMOVE
 63     if (row > -1) {              // only if a row was selected
 64       String subname = (String) model.getValueAt(row, 0); // name column
 65       Account next = current.getSub(subname);
 66       if (next != null) {
 67         current = next;
 68         // System.out.println("cd to:"+current.getName());
Appendix B  A Java Swing GUI for BudgetPro                         529
 69             setStatus();
 70             // notify the table, too
 71             model.fireTableDataChanged();
 72          } // TODO: else infodialog or Beep.
 73        }
 74      }
 75   } ;
 76
 77   // TEST ONLY:
 78   int testid = 0;
 79
 80   BudgetPro(JFrame frame, String username, String value)
 81   {
 82      this.frame = frame;
 83      top = new Account("TopLevel", new User(username), value);
 84      current = top;
 85
 86   } // constructor
 87
 88   private Component
 89   createStatus()
 90   {
 91      JPanel retval = new JPanel();     // default: flow layout
 92
 93      upton.addActionListener(upAction);
 94
 95      nam = new JLabel("Account: Name");
 96      tot = new JLabel("Total: $");
 97      val = new JLabel("Remaining: $");
 98
 99      retval.add(upton);
100      retval.add(nam);
101      retval.add(tot);
102      retval.add(val);
103
104      setStatus();
105
106      return retval;
107   } // createStatus
108
109   /**
110     * Set the values of the status fields,
111     * as when the account has changed.
112     */
113   private void
114   setStatus()
115   {
116      nam.setText("Account: "+current.getName());
117      tot.setText("Total: $"+current.getTotal());
530                                      Appendix B A Java Swing GUI for BudgetPro
118   // tot.setText("SubAccounts: "+current.size());
119   val.setText("Remaining: $"+current.getBalance());
120
121   // disable the button if there is no "up" to go
122   if (current.getParent() == null) {
123       upton.setEnabled(false);
124   } else {
125       upton.setEnabled(true);
126   }
127
128 } // setStatus
129
130 private Component
131 createList()
132 {
133   JScrollPane retval;
134
135   model = new AbstractTableModel()
136     {
137       private String [] columnNames = {"Account", "Owner", "Value"};
138
139       public String
140       getColumnName(int col) {
141         return columnNames[col];
142       } // getColumnName
143
144       public int
145       getRowCount()
146       {
147         int retval;
148
149         if (current != null) {
150              retval = current.size();
151         } else {
152              retval = 1;     // testing only
153         }
154
155         return retval;
156
157       } // getRowCount
158
159       public int getColumnCount() { return columnNames.length; }
160
161       public Object
162       getValueAt(int row, int col) {
163         Object retval = null;
164         Account aa = null;
165         // return "---";    // rowData[row][col];
166         int count = 0;
Appendix B   A Java Swing GUI for BudgetPro                                  531
167              for (Iterator itr=current.getAllSubs(); itr.hasNext(); )
168              {
169                count++;
170                aa = (Account) itr.next();
171                if (count > row) { break; }
172              } // next
173              switch (col) {
174              case 0:
175                       retval = aa.getName();
176                       break;
177              case 1:
178                       retval = aa.getOwner();
179                       break;
180              case 2:
181                       retval = aa.getTotal();
182                       break;
183              } // endswitch
184              return retval;
185            } // getValueAt
186
187            public boolean
188            isCellEditable(int row, int col)
189            {
190              return false;
191            } // isCellEditable
192         };
193      list = new JTable(model);
194      list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
195
196      list.getSelectionModel().addListSelectionListener(
197         new ListSelectionListener()
198         {
199            public void
200            valueChanged(ListSelectionEvent e)
201            {
202              ListSelectionModel lsm = (ListSelectionModel)e.getSource();
203              if (lsm.isSelectionEmpty()) {
204                  view.setEnabled(false);
205              } else {
206                  view.setEnabled(true);
207              }
208            } // valueChanged
209         }
210      );
211
212      retval = new JScrollPane(list);
213
214      return retval;
215
532                                      Appendix B A Java Swing GUI for BudgetPro
216 } // createList
217
218 private Component
219 createButtons(JRootPane root)
220 {
221   JPanel retval = new JPanel();    // default: flow layout
222
223   //Lay out the buttons from left to right.
224   retval.setLayout(new BoxLayout(retval, BoxLayout.X_AXIS));
225   retval.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
226   retval.add(Box.createHorizontalGlue());
227   retval.add(creat);
228   retval.add(Box.createRigidArea(new Dimension(10, 0)));
229   retval.add(view);
230   retval.add(Box.createRigidArea(new Dimension(10, 0)));
231   retval.add(clos);
232
233   // ---------------------------------------- Define some actions
234   ActionListener closAction = new ActionListener()
235   {
236     public void
237     actionPerformed(ActionEvent e)
238     {
239         System.exit(0);
240     }
241   } ;
242   clos.addActionListener(closAction);
243
244   ActionListener creatAction = new ActionListener()
245   {
246     public void
247     actionPerformed(ActionEvent e)
248     {
249       Account child;
250       // get the info via a Dialog (of sorts)
251       if (askem == null) {
252           askem = new AcctDialog(frame, "New Subaccount");
253       } else {
254           askem.clear();
255           askem.setVisible(true);
256       }
257       String subName = askem.getName();
258       String subAmnt = askem.getAmnt();
259
260       // if empty, assume the operation was cancelled, else:
261       if ((subName != null) && (subName.length() > 0)) {
262           child = current.createSub(subName, subAmnt);
263           setStatus();
264           model.fireTableDataChanged(); // notify the table
Appendix B   A Java Swing GUI for BudgetPro                                   533
265           }
266         }
267      };
268      creat.addActionListener(creatAction);
269
270      // function is to get selection from table and cd there
271      view.addActionListener(cdAction);
272      // but it starts off disabled, since there is no data yet
273      view.setEnabled(false);
274
275      // ------------------------------------------------------------
276      frame.getRootPane().setDefaultButton(creat);
277      clos.grabFocus();
278
279      return retval;
280
281   } // createButtons
282
283   public static void
284   main(String[] args)
285   {
286      BudgetPro app = null;
287
288      //Create the top-level container
289      JFrame frame = new JFrame("BudgetPro");
290
291      // ----------- set up the account/app based on the command line args
292      try {
293           String username = System.getProperty("user.name", "default");
294           if (args.length > 0) {
295                app = new BudgetPro(frame, username, args[0]);
296             } else {
297                System.err.println("usage: BudgetPro dollar_amt");
298                System.exit(1);
299             }
300      } catch (Exception e) {
301           System.err.println("Error on startup.");
302           e.printStackTrace();
303           System.exit(2);
304      }
305
306      // ----------- now set up the UI and get things going
307      try {
308           UIManager.setLookAndFeel(
309                        UIManager.getCrossPlatformLookAndFeelClassName());
310      } catch (Exception e) {
311           System.err.println("Can't set the desired look and feel.");
312           e.printStackTrace();
313           System.exit(3);
534                                        Appendix B A Java Swing GUI for BudgetPro
314      }
315
316      // build the pieces and add them to the top-level container
317
318      Component status = app.createStatus();
319      frame.getContentPane().add(status, BorderLayout.NORTH);
320
321      Component list = app.createList();
322      frame.getContentPane().add(list, BorderLayout.CENTER);
323
324      Component buttons = app.createButtons(frame.getRootPane());
325      frame.getContentPane().add(buttons, BorderLayout.SOUTH);
326
327      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
328      frame.pack();
329      frame.setVisible(true);
330   } // main
331
332 } // class BudgetPro
             Here is the code for the dialog for creating new accounts,
        AcctDialog.java:
  1 package net.multitool.gui;
  2
  3 import  java.awt.*;
  4 import  java.awt.event.*;
  5 import  javax.swing.*;
  6 import  javax.swing.table.*;
  7 import  java.util.*;
  8 import  net.multitool.core.*;
  9
 10 class
 11 AcctDialog
 12   extends JDialog
 13 {
 14   JDialog dialog;    // for reference from the buttons' actions
 15   JTextField nameField;
 16   JTextField amntField;
 17
 18   AcctDialog(JFrame frame, String title)
 19   {
 20      super(frame, title, true);
 21      dialog = this;
 22      nameField = new JTextField(25);
 23      amntField = new JTextField(9);
Appendix B   A Java Swing GUI for BudgetPro                                   535
 24
 25      // right justify the numeric field
 26      amntField.setHorizontalAlignment(JTextField.RIGHT);
 27
 28      // TODO: so that <Enter> will do a create
 29      // this.getInputMap().put(KeyStroke.getKeyStroke("Enter"), "create");
 30      /*
 31         Action myAction = new AbstractAction("doSomething") {
 32            public void actionPerformed() {
 33              doSomething();
 34            }
 35         };
 36         myComponent.getActionMap().put(myAction.get(Action.NAME), myAction);
 37        */
 38
 39      //--------------------------------------------------Label on top----
 40      JLabel label = new JLabel("<html><p align=left><i>"
 41                        + "Enter the info to create a subaccount.<br>"
 42                        + "</i>");
 43      label.setHorizontalAlignment(JLabel.LEFT);
 44      Font font = label.getFont();
 45      label.setFont(label.getFont().deriveFont(font.PLAIN, 14.0f));
 46
 47      //--------------------------------------------------Text Fields-----
 48      String[] labels = {"(Sub)Account Name: ", "Dollar Amount: "};
 49      JTextField [] fields = {nameField, amntField};
 50      int numPairs = fields.length;
 51
 52      //Create and populate the panel.
 53      JPanel textes = new JPanel(new SpringLayout());
 54      for (int i = 0; i < numPairs; i++) {
 55         JLabel l = new JLabel(labels[i], JLabel.TRAILING);
 56         textes.add(l);
 57         l.setLabelFor(fields[i]); // not nec. since we have no kb shortcuts
 58         textes.add(fields[i]);
 59      }
 60
 61      //Lay out the panel.
 62      SpringUtilities.makeCompactGrid(textes,
 63                                         numPairs, 2, //rows, cols
 64                                         6, 6,        //initX, initY
 65                                         6, 6);       //xPad, yPad
 66
 67
 68      //--------------------------------------------------Buttons on bottom
 69      JButton createButton = new JButton("Create");
 70      createButton.addActionListener(new ActionListener() {
 71         public void actionPerformed(ActionEvent e) {
 72            nameField.grabFocus(); // before leaving, ready for next time.
536                                     Appendix B A Java Swing GUI for BudgetPro
 73       dialog.setVisible(false);   // go away
 74     }
 75   });
 76
 77   JButton cancelButton = new JButton("Cancel");
 78   cancelButton.addActionListener(new ActionListener() {
 79     public void actionPerformed(ActionEvent e) {
 80       clear(); // toss out any entry
 81       dialog.setVisible(false);
 82     }
 83   });
 84   getRootPane().setDefaultButton(createButton);
 85
 86   JPanel closePanel = new JPanel();
 87   closePanel.setLayout(new BoxLayout(closePanel, BoxLayout.LINE_AXIS));
 88   closePanel.add(Box.createHorizontalGlue());
 89   closePanel.add(createButton);
 90   closePanel.add(Box.createRigidArea(new Dimension(5, 0)));
 91   closePanel.add(cancelButton);
 92   closePanel.setBorder(BorderFactory.createEmptyBorder(10,0,5,5));
 93
 94   JPanel contentPane = new JPanel(new BorderLayout());
 95   contentPane.add(label, BorderLayout.PAGE_START);
 96   contentPane.add(textes, BorderLayout.CENTER);
 97   contentPane.add(closePanel, BorderLayout.PAGE_END);
 98   contentPane.setOpaque(true);
 99   setContentPane(contentPane);
100
101   //Show it.
102   setSize(new Dimension(300, 160));
103   setLocationRelativeTo(frame);
104   setVisible(true);
105
106 } // constructor
107
108 public String
109 getName()
110 {
111   String retval = null;
112   if (nameField != null) {
113     retval = nameField.getText();
114   }
115   return retval;
116 } // getName
117
118 public String
119 getAmnt()
120 {
121   String retval = null;
Appendix B  A Java Swing GUI for BudgetPro 537
122      if (amntField != null) {
123        retval = amntField.getText();
124      }
125      return retval;
126   } // getAmnt
127
128   public void
129   clear()
130   {
131      nameField.setText(null);
132      amntField.setText(null);
133   } // clear
134
135 } // class AcctDialog
   Appendix C
   GNU
   General Public License
         Version 2, June 1991
         Copyright © 1989, 1991 Free Software Foundation, Inc.
         59 Temple Place, Suite 330, Boston, MA 02111, USA
         Everyone is permitted to copy and distribute verbatim copies
         of this license document, but changing it is not allowed.
PREAMBLE
   The licenses for most software are designed to take away your freedom to share
   and change it. By contrast, the GNU General Public License is intended to
   guarantee your freedom to share and change free software—to make sure the
   software is free for all its users. This General Public License applies to most of
   the Free Software Foundation’s software and to any other program whose au-
   thors commit to using it. (Some other Free Software Foundation software is
   covered by the GNU Library General Public License instead.) You can apply
   it to your programs, too.
                                                                                 539
540                                              Appendix C   GNU General Public License
           When we speak of free software, we are referring to freedom, not price.
     Our General Public Licenses are designed to make sure that you have the free-
     dom to distribute copies of free software (and charge for this service if you
     wish), that you receive source code or can get it if you want it, that you can
     change the software or use pieces of it in new free programs; and that you know
     you can do these things.
           To protect your rights, we need to make restrictions that forbid anyone
     to deny you these rights or to ask you to surrender the rights. These restrictions
     translate to certain responsibilities for you if you distribute copies of the
     software, or if you modify it.
           For example, if you distribute copies of such a program, whether gratis or
     for a fee, you must give the recipients all the rights that you have. You must
     make sure that they, too, receive or can get the source code. And you must show
     them these terms so they know their rights.
           We protect your rights with two steps: (1) copyright the software, and
     (2) offer you this license which gives you legal permission to copy, distribute
     and/or modify the software.
           Also, for each author’s protection and ours, we want to make certain that
     everyone understands that there is no warranty for this free software. If the
     software is modified by someone else and passed on, we want its recipients to
     know that what they have is not the original, so that any problems introduced
     by others will not reflect on the original authors’ reputations.
           Finally, any free program is threatened constantly by software patents. We
     wish to avoid the danger that redistributors of a free program will individually
     obtain patent licenses, in effect making the program proprietary. To prevent
     this, we have made it clear that any patent must be licensed for everyone’s free
     use or not licensed at all.
           The precise terms and conditions for copying, distribution, and
     modification follow.
  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION, AND
  MODIFICATION
       0. This License applies to any program or other work which contains a no-
            tice placed by the copyright holder saying it may be distributed under the
            terms of this General Public License. The “Program,” below, refers to any
            such program or work, and a “work based on the Program” means either
C.2 Terms and Conditions for Copying, Distribution, and Modification                  541
            the Program or any derivative work under copyright law: that is to say, a
            work containing the Program or a portion of it, either verbatim or with
            modifications and/or translated into another language. (Hereinafter,
            translation is included without limitation in the term “modification.”)
            Each licensee is addressed as “you.”
                  Activities other than copying, distribution and modification are not
            covered by this License; they are outside its scope. The act of running the
            Program is not restricted, and the output from the Program is covered
            only if its contents constitute a work based on the Program (independent
            of having been made by running the Program). Whether that is true
            depends on what the Program does.
        1. You may copy and distribute verbatim copies of the Program’s source
            code as you receive it, in any medium, provided that you conspicuously
            and appropriately publish on each copy an appropriate copyright notice
            and disclaimer of warranty; keep intact all the notices that refer to this
            License and to the absence of any warranty; and give any other recipients
            of the Program a copy of this License along with the Program.
                  You may charge a fee for the physical act of transferring a copy, and
            you may at your option offer warranty protection in exchange for a fee.
        2. You may modify your copy or copies of the Program or any portion of
            it, thus forming a work based on the Program, and copy and distribute
            such modifications or work under the terms of Section 1 above, provided
            that you also meet all of these conditions:
              a) You must cause the modified files to carry prominent notices stating
                  that you changed the files and the date of any change.
              b) You must cause any work that you distribute or publish, that in
                  whole or in part contains or is derived from the Program or any part
                  thereof, to be licensed as a whole at no charge to all third parties
                  under the terms of this License.
              c) If the modified program normally reads commands interactively
                  when run, you must cause it, when started running for such interac-
                  tive use in the most ordinary way, to print or display an announce-
                  ment including an appropriate copyright notice and a notice that
                  there is no warranty (or else, saying that you provide a warranty) and
                  that users may redistribute the program under these conditions, and
                  telling the user how to view a copy of this License. (Exception: if the
                  Program itself is interactive but does not normally print such an
542                                          Appendix C   GNU General Public License
             announcement, your work based on the Program is not required to
             print an announcement.)
             These requirements apply to the modified work as a whole. If iden-
       tifiable sections of that work are not derived from the Program, and can
       be reasonably considered independent and separate works in themselves,
       then this License, and its terms, do not apply to those sections when you
       distribute them as separate works. But when you distribute the same
       sections as part of a whole which is a work based on the Program, the
       distribution of the whole must be on the terms of this License, whose
       permissions for other licensees extend to the entire whole, and thus to
       each and every part regardless of who wrote it.
             Thus, it is not the intent of this section to claim rights or contest
       your rights to work written entirely by you; rather, the intent is to exercise
       the right to control the distribution of derivative or collective works based
       on the Program.
             In addition, mere aggregation of another work not based on the
       Program with the Program (or with a work based on the Program) on a
       volume of a storage or distribution medium does not bring the other work
       under the scope of this License.
    3. You may copy and distribute the Program (or a work based on it, under
       Section 2) in object code or executable form under the terms of Sections 1
       and 2 above provided that you also do one of the following:
         a) Accompany it with the complete corresponding machine-readable
             source code, which must be distributed under the terms of
             Sections 1 and 2 above on a medium customarily used for software
             interchange; or,
         b) Accompany it with a written offer, valid for at least three years, to
             give any third party, for a charge no more than your cost of
             physically performing source distribution, a complete machine-
             readable copy of the corresponding source code, to be distributed
             under the terms of Sections 1 and 2 above on a medium customarily
             used for software interchange; or,
         c) Accompany it with the information you received as to the offer to
             distribute corresponding source code. (This alternative is allowed
             only for noncommercial distribution and only if you received the
             program in object code or executable form with such an offer, in
             accord with Subsection b above.)
C.2 Terms and Conditions for Copying, Distribution, and Modification                 543
                  The source code for a work means the preferred form of the work
            for making modifications to it. For an executable work, complete source
            code means all the source code for all modules it contains, plus any asso-
            ciated interface definition files, plus the scripts used to control compila-
            tion and installation of the executable. However, as a special exception,
            the source code distributed need not include anything that is normally
            distributed (in either source or binary form) with the major components
            (compiler, kernel, and so on) of the operating system on which the
            executable runs, unless that component itself accompanies the executable.
                  If distribution of executable or object code is made by offering access
            to copy from a designated place, then offering equivalent access to copy
            the source code from the same place counts as distribution of the source
            code, even though third parties are not compelled to copy the source
            along with the object code.
        4.  You may not copy, modify, sublicense, or distribute the Program except
            as expressly provided under this License. Any attempt otherwise to copy,
            modify, sublicense or distribute the Program is void, and will automatical-
            ly terminate your rights under this License. However, parties who have
            received copies, or rights, from you under this License will not have their
            licenses terminated so long as such parties remain in full compliance.
        5.  You are not required to accept this License, since you have not signed it.
            However, nothing else grants you permission to modify or distribute the
            Program or its derivative works. These actions are prohibited by law if
            you do not accept this License. Therefore, by modifying or distributing
            the Program (or any work based on the Program), you indicate your ac-
            ceptance of this License to do so, and all its terms and conditions for
            copying, distributing or modifying the Program or works based on it.
        6.  Each time you redistribute the Program (or any work based on the Pro-
            gram), the recipient automatically receives a license from the original li-
            censor to copy, distribute or modify the Program subject to these terms
            and conditions. You may not impose any further restrictions on the recip-
            ients’ exercise of the rights granted herein. You are not responsible for
            enforcing compliance by third parties to this License.
        7.  If, as a consequence of a court judgment or allegation of patent infringe-
            ment or for any other reason (not limited to patent issues), conditions are
            imposed on you (whether by court order, agreement or otherwise) that
            contradict the conditions of this License, they do not excuse you from
544                                           Appendix C   GNU General Public License
       the conditions of this License. If you cannot distribute so as to satisfy si-
       multaneously your obligations under this License and any other pertinent
       obligations, then as a consequence you may not distribute the Program
       at all. For example, if a patent license would not permit royalty-free redis-
       tribution of the Program by all those who receive copies directly or indi-
       rectly through you, then the only way you could satisfy both it and this
       License would be to refrain entirely from distribution of the Program.
             If any portion of this section is held invalid or unenforceable under
       any particular circumstance, the balance of the section is intended to ap-
       ply and the section as a whole is intended to apply in other circumstances.
             It is not the purpose of this section to induce you to infringe any
       patents or other property right claims or to contest validity of any such
       claims; this section has the sole purpose of protecting the integrity of the
       free software distribution system, which is implemented by public license
       practices. Many people have made generous contributions to the wide
       range of software distributed through that system in reliance on consistent
       application of that system; it is up to the author/donor to decide if he or
       she is willing to distribute software through any other system and a
       licensee cannot impose that choice.
             This section is intended to make thoroughly clear what is believed
       to be a consequence of the rest of this License.
    8. If the distribution and/or use of the Program is restricted in certain
       countries either by patents or by copyrighted interfaces, the original
       copyright holder who places the Program under this License may add an
       explicit geographical distribution limitation excluding those countries, so
       that distribution is permitted only in or among countries not thus exclud-
       ed. In such case, this License incorporates the limitation as if written in
       the body of this License.
    9. The Free Software Foundation may publish revised and/or new versions
       of the General Public License from time to time. Such new versions will
       be similar in spirit to the present version, but may differ in detail to
       address new problems or concerns.
             Each version is given a distinguishing version number. If the Pro-
       gram specifies a version number of this License which applies to it and
       “any later version,” you have the option of following the terms and con-
       ditions either of that version or of any later version published by the Free
       Software Foundation. If the Program does not specify a version number
C.3 NO WARRANTY                                                                    545
            of this License, you may choose any version ever published by the Free
            Software Foundation.
        10. If you wish to incorporate parts of the Program into other free programs
            whose distribution conditions are different, write to the author to ask for
            permission. For software which is copyrighted by the Free Software
            Foundation, write to the Free Software Foundation; we sometimes make
            exceptions for this. Our decision will be guided by the two goals of
            preserving the free status of all derivatives of our free software and of
            promoting the sharing and reuse of software generally.
   NO WARRANTY
        11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE,
            THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EX-
            TENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
            OTHERWISE STATED IN WRITING THE COPYRIGHT HOLD-
            ERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS
            IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
            OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IM-
            PLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
            FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE
            QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
            YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU AS-
            SUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
            CORRECTION.
        12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR
            AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,
            OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDIS-
            TRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE
            TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPE-
            CIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
            OUT OF THE USE OR INABILITY TO USE THE PROGRAM (IN-
            CLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
            BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
            YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
            TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
546                                             Appendix C   GNU General Public License
            HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
            POSSIBILITY OF SUCH DAMAGES.
  END OF TERMS AND CONDITIONS
  HOW TO APPLY THESE TERMS TO YOUR NEW PROGRAMS
     If you develop a new program, and you want it to be of the greatest possible
     use to the public, the best way to achieve this is to make it free software which
     everyone can redistribute and change under these terms.
           To do so, attach the following notices to the program. It is safest to attach
     them to the start of each source file to most effectively convey the exclusion of
     warranty; and each file should have at least the “copyright” line and a pointer
     to where the full notice is found.
     one line to give the program's name and an idea of what it does.
     Copyright (C) year name of author
     This program is      free software; you can redistribute it and/or
     modify it under      the terms of the GNU General Public License
     as published by      the Free Software Foundation; either version 2
     of the License,      or (at your option) any later version.
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
     GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
           Also add information on how to contact you by electronic and paper mail.
           If the program is interactive, make it output a short notice like this when
     it starts in an interactive mode:
     Gnomovision version 69, Copyright (C) year name of author
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'. This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c'
     for details.
C.5 How to Apply These Terms to Your New Programs                                547
            The hypothetical commands ‘show w’ and ‘show c’ should show the ap-
      propriate parts of the General Public License. Of course, the commands you
      use may be called something other than ‘show w’ and ‘show c’; they could
      even be mouse-clicks or menu items—whatever suits your program.
            You should also get your employer (if you work as a programmer) or your
      school, if any, to sign a “copyright disclaimer” for the program, if necessary.
      Here is a sample; alter the names:
      Yoyodyne, Inc., hereby disclaims all copyright
      interest in the program `Gnomovision'
      (which makes passes at compilers) written
      by James Hacker.
      signature of Ty Coon, 1 April 1989
      Ty Coon, President of Vice
            This General Public License does not permit incorporating your program
      into proprietary programs. If your program is a subroutine library, you may
      consider it more useful to permit linking proprietary applications with the
      library. If this is what you want to do, use the GNU Lesser General Public
      License instead of this License.
Index
                                      /= operator, 56
Symbols                               . (dot)
- (minus)                                as current working directory, 12, 20, 24, 29,
   in command-line options, 26                 121, 238
   operator, 56                          in filenames, 10
   in permissions, 11                    in regular expressions, 43
   in regular expressions, 43         .. (dot-dot) parent directory, 12
   in shell pattern matching, 14      ... (ellipsis) in method declarations, 82
-- (double minus)                     ^ (hat)
   in command-line options, 26           for the Control key, 18
   operator, 56                          operator, 56
-= operator, 56                          in regular expressions, 43
_ (underscore) in filenames, 10           in shell pattern matching, 14
: (colon)                             ^= operator, 56
   in classpath, 24, 107, 119         ~ operator, 56
   in shell pattern matching, 14      ' (single quote)
   in vi, 37, 43–45                      for literals in SQL, 333
! (exclamation mark)                     in shell pattern matching, 15
   operator, 56                       " (double quote)
   in shell pattern matching, 14         for Strings in Java, 60, 333
!= operator, 56                          in shell pattern matching, 15, 108
? (question mark)                     [] (square brackets)
   as command-line option, 29            array operator, 55–56
   in shell pattern matching, 14, 196    in regular expressions, 43
   in SQL, 333                           in shell pattern matching, 14
   in URLs, 406, 412                  {} (braces)
?: operator, 56                          array operator, 55
/ (forward slash)                        for compound statements, 66–70
   as file separator, 107                 in Javadoc comments, 130
   in HTML/XML, 221–222, 433             in shell pattern matching, 108
   operator, 56                       @ (at), 181
// comments, 66                          in command-line options, 117, 123
/* ... */ comments, 66, 128              in Javadoc comments, 128
/** ... */ comments, 128
                                                                                 549
550                                                                                 Index
    $ (dollar)                                     > (greater-than)
       in format fields, 81                            operator, 56
       in regular expressions, 43                     as redirection command, 6
       in shell pattern matching, 15, 22           >= operator, 56
    $$ environment variable, 108                   >> operator, 56
    * (asterisk)                                   >>= operator, 56
       in import statements, 85–86                 >>> operator, 56
       operator, 56                                >>>= operator, 56
       in password fields, 373                      = operator, 56
       in regular expressions, 43                  == operator, 56, 61, 91
       in shell pattern matching, 13, 16, 113, 196 | operator, 56, 391
    *= operator, 56                                |= operator, 56
    \ (backslash) in shell pattern matching, 15    || operator, 56
    & (ampersand)
       operator, 56                                Numbers
       in regular expressions, 43                  0wn3d systems, 486
       in URLs, 406, 412                           2-tier systems, 138
    && operator, 56                                3-tier systems, 138
    &= operator, 56
    # (hash)
                                                   A
       in comments, 196                            a element (HTML), 412
       in properties files, 111                     A Windowing Toolkit, see AWT
    % (per cent)                                   abstract access modifier, 94
       operator, 56                                AbstractTableModel class, 359–363, 368,
       in regular expressions, 43                        389
    %= operator, 56                                access modifiers, 88–94
    + (plus)                                       ActionListener class, 356
       operator, 56, 60                            actionPerformed(), 356, 367, 371
       in permissions, 11                          ActiveX, 390
       in regular expressions, 43                  add(), 142, 352–353, 391
       in URLs, 413                                addActionListener(), 391
    ++ operator, 56                                addControlListener(), 392
    += operator, 56                                addCookie(), 415
    < (less-than)                                  addFocusListener(), 392
       operator, 56                                addHelpListener(), 392
       as redirection command, 6                   addKeyListener(), 393
    < ... >                                        addMouseListener(), 393
       in command-line syntax, 73                  addMouseMoveListener(), 393
       in HTML/XML, 221                            addMouseTrackListener(), 393
    <? ... ?>, 222                                 addPaintListener(), 393
    <% ... %>, 426–431, 434                        address space conflicts, 380
    <%! ... %>, 429–430, 434                       addSelectionListener(), 391–393
    <%@ ... %>, 431–433                            addTraverseListener(), 393
    <%= ... %>, 430–431, 434                       afterLast(), 336
    << operator, 56                                Albaugh, Tyrrell, xxv
    <<= operator, 56                               Albing, Andrew, xxv
    <= operator, 56                                algebraic expressions, 52
                                                   alien package, 322
Index                                                                                  551
      Alpha architecture, 186                 ASCII encoding, 48, 165, 525–526
      Ant, 161, 215–233, 397, 505             asedit, 49
         building JAR/WAR/EAR files, 513, 516  ASP clients, 480
         command-line options, 223            aspect-oriented programming, see AOP
         comparing with make, 225             Assert class, 308
         datatypes, 228                       assertEquals(), 306, 308
         documentation, 232–233               assertFalse(), 307
         installing, 217–220                  assertNotNull(), 306–307
         properties, 224                      assertNotSame(), 307
         targets, 223                         assertNull(), 307
         tasks, 225–228, 464, 516             assertSame(), 307–308
         using with CVS, 516–517              assertTrue(), 307
         using with EJBs, 502                 assignments, 56, 59, 66
         using with gcj, 226                  atd, 454, 459
         using with JUnit, 303, 312           authentication, 164–165, 324, 485–486
         using with NetBeans, 248–249         @author tag (Javadoc), 127–129, 518
         using with XDoclet, 517–518          autoconf, 446
      ANT_HOME environment variable, 219–220  AWT (A Windowing Toolkit), xxiii, 251, 341,
      AOP (aspect-oriented programming), 277        344–345, 384
      Apache, 217, 321, 444, 446, 464         axe, 48
      append(), 419
      applets, 131, 145, 165, 226             B
      appletviewer, 131                       backups, 190, 317
      application servers, 325, 444, 476      Barry, Dave, 17
      applications                            .bash_profile file, 173
         building, 216                        bash shell, 5, 7, 22, 397
         deploying, 160–163                   .bashrc file, 24–25, 193, 240
         developing, see software engineering bean-managed persistence, see BMP
         distributing, 157                    beans, see EJBs, JavaBeans
         Free, see Free Software              BeanShell, 259
         nonsystem, 446                       BEAWeblogic, xxviii
         Open, see Open Source                Beck, Kent, 280
         readability of source code, 70       beforeFirst(), 336
         releases, 190, 208, 210, 312         Berkeley DB, 321
         reliability, 264                     BigDecimal class, 54, 175, 333
         running, 100, 111–113                BigInteger class, 54
         testing, 103–104                     binding, 482, 484
      archives, 26                            BMP (bean-managed persistence), 479
      Array class, 333                        BNF language grammar, 65
      ArrayList class, 333                    book’s Web site, xxiv, 229, 350, 395, 417,
      arrays, 55–57                                 493, 517, 522
         associative, 482                     Boolean class, 62
         checking, 185                        boolean type, 54, 56
         multidimensional, 55                    converting to String, 80
         operators for, 56                    BorderLayout class, 352–353, 372, 374,
         ragged-edged, 57                           390
         size, 55                             Borland, 236
         zero-based, 333                      BoxLayout class, 354–355, 372, 374
552                                                                                      Index
    break statement, 67, 74–75                    characters (continued)
    browsers, 404                                    lowercase/uppercase, 61
       connecting with a server, 413                 ranges, 14–15
       plug-ins, 166                              check boxes (in GUI), 346
       sessions, 414–415                          chgrp, 11, 448
    Bruce Perens’ Open Source Series, xxii, xxiv, chkconfig, 456, 458–463
          523                                     chmod, 11, 240, 448, 463
    BSD/UNIX, 5                                   chown, 11
    B-trees, 321                                  CICS (Customer Information Control
    BudgetPro                                           System), 518
       as a servlet, 416–420, 423, 430            CIDR (Classless Inter-Domain Routing), 485
       buildfile for, 464                          CIFS filesystem, 485
       database for, 320, 324                     class statement, 86
       EAR file for, 506–512, 515                  classes, 34, 58, 86
       in JSP, 424–426, 438                          abstract, 305, 368
       in Swing, 348–373, 527–537                    base, 285
       in SWT, 387–395                               compiling, 117, 119
    buildfiles (build.xml), 220–231, 248, 257,        constructors for, 59, 140
          516                                        core language, 86
    Button class, 385, 388, 391–392                  deprecated, 120, 127, 129
    buttons (in GUI), 345, 352, 355–356, 374         documentation, 518
       actions, 356–358, 374                         extended, 87–91, 96
       enabled/disabled, 357, 392                    files, 58–59, 84–85, 117, 119
    byte type, 53–54                                    disassembling, see javap
    bzip2, 218                                       grouping, 83
                                                     inherited, 87–91, 94, 284
    C                                                inner, 59, 87, 348, 356, 360, 393
    C language, 53, 249                              instances, 58
    C++ language, 249                                names, 83–86, 119
       exceptions, 77                                referencing, 85–86
       operator overloading, 52                      RMI serial versions, 165
       templates, 94                                 scope, 59
       virtual methods, 96                           testing, 102
    CallableStatement class, 337                     without package declaration, 183
    Canvas class, 385                             classpath, 117–119, 181
    Capability Maturity Model, see CMM               bootstrap, 117
    Caret class, 385                                 runtime, 119, 121–122
    Carnegie, Dale, 274                           CLASSPATH environment variable, 84–85,
    case statement, 67                                  118, 145, 158, 184, 211, 242, 297, 301,
    Cash-Peterson, Patrick, xxiv                        308, 332, 501
    Castor, 321                                      overriding, 119, 121–122
    cat, 17                                          setting, 119
    catch statement, 76–79                        clients
    char type, 54                                    compiling, 147
    characters                                       developing, 142–143
       coding, 54                                    setting up, 144–147
       counting, in a file, 9                         working with servers, 138
       escaping, 9, 15
Index                                                                                    553
      CMM (Capability Maturity Model), 277,     context, 479, 484
            286, 288–289                           initial, 489–491
      CMP (container-managed persistence), 476,    switching, 476
            479                                 Context class, 490
      CNI (Compiled Native Interface), 186      continue statement, 74–75
      CodeCommander, 48                         Control class, 389
      collections, 70–74                        cookies, 414–415
      color choosers (in GUI), 347              copy tag (Ant), 227
      combo boxes (in GUI), 346, 385            CORBA (Common Object Request Broker
      Combo class, 385                                Architecture), 144, 165, 175, 480
      command line, 4, 151, 258, 341            CRC cards, 280–288
        options, 26, 100–102                    createAction(), 371
        standard I/O, 6                         createButtons(), 355, 391, 394
      commands                                  createdb, 324
        built-in, 24                            createList(), 360, 369, 391, 394
        documentation, 29                       createStatus(), 353, 358, 391, 394
        installing, 24                          createuser, 323
        online help, 29                         csh shell, 5, 105
        searching, 24, 29                       Cunningham, Ward, 280
      comments                                  Customer Information Control System, see
        in HTML, 428                                  CICS
        in Java, 66, 428, 518                   CVS (Concurrent Versioning System), 126,
        in Javadoc, 127–131                           189–214, 241
      commit(), 77                                 checkouts, 191, 197–198, 210, 244, 246
      Compatibility Test Suite for J2EE, 521       command-line options, 198, 204, 207, 210
      compilation, 179–188, 248                    commits, 191–194, 198–203, 244, 246
        of a multiclass application, 184           differences between versions, 199–201, 246
        cross-platform, 180, 186, 446              documentation, 214
        with debug information, 120, 227           editor invocations, 198
        speed, 348                                 exports, 210
        see also gcj, javac                        imports, 196–197
      Compiled Native Interface, see CNI           logs, 199, 203–205, 246
      Composite class, 385, 388–389, 392, 394      merging, 201–203
      Concurrent Versioning System, see CVS        repositories, 191
      conditionals, 66–67                             initializing, 193–195
      Connection class, 325, 329                      remote, 195, 214
      constants, 90–91                             sandboxes, 191, 194, 210
      constructors, 59, 140                        status, 205, 246
      cont, 156                                    tags, 191, 205–210
      container-managed persistence, see CMP          branching, 207–210
      containers                                      deleting, 207
        EJB, 444, 474, 476, 491, 495                  moving, 207
        J2EE, 479, 505                                sticky, 205, 209
        Swing, 344                                 updates, 191–194, 198, 201–202, 246
        Web, 476                                   using with Ant, 516–517
      containsKey(), 111                           using with Eclipse, 259
      containsValue(), 111                         using with NetBeans, 244–248
                                                CVS directories, 194, 197, 209–210
554                                                                                      Index
    CVS_RSH environment variable, 214, 516        directories (continued)
    CVSEDITOR environment variable, 198              listing files in, 9, 15
    .cvsignore file, 195–196                          parent, 12
    .cvspass file, 195                                permissions of, see permissions
    CVSROOT directories, 194                      directory services, 482–487, 491, 494
    CVSROOT environment variable, 193–194,        Display class, 381, 384, 386–390
          209, 516                                dispose(), 380, 388
    .cvswrappers file, 195–196                     DNS (Domain Name Service), 482–484,
                                                         487–491
    D                                             Docbook, 221
    daemons, 323, 407                             doclets, 123, 126
    data types                                    @docRoot tag (Javadoc), 130
       nonobject, 52                              Document Style Semantics and Specification
       numeric, 53–54                                    Language, see DSSSL
       object, 57–64                              Document Type Definitions, see DTDs
       wrappers for, 62                           documentation, 122–131
    databases, 138, 315–326                          comments, 127–131
       connecting to, 328–332, 336, 496              links, 127, 130–131
       creating, 324                              doGet(), 404, 407, 412, 418, 427, 429
       interaction with, 327, 480                 Domain Name Service, see DNS
       normalizing, 326                           domains, 83
       querying, 328, 332–334, 411                doPost(), 405, 407, 412, 418, 427, 429
       relational, 322, 518                       DoS (Denial of Service) attacks, 489, 491
       selection criteria, 318                    Double class, 333, 359
       setup, 318                                 double type, 53–54
       updating, 336                              do-while statement, 68–69, 75
    DataSource class, 336                         DriverManager class, 329, 336
    DataType class, 228                           DSSSL (Document Style Semantics and
    Date class, 81                                       Specification Language), 221
    Davidson, James Duncan, 216–217               DTDs (Document Type Definitions), 220,
    Debian, 47, 322, 457, 463                            222
    debugging, 91, 103, 136, 148–151              dump, 156
       adding information to class files, 120, 176 DynamicJava, 259
    declarations, in JSP, 434
    default statement, 67                         E
    DefaultTableModel class, 368                  e3, 49
    @deprecated tag (Javadoc), 120, 129           EAR files, 28, 506–514
    destroy(), 404, 407                              building with Ant, 513, 516
    dialogs (in GUI), 370–373                        deploying, 514–516
       dismissed, 372                             echo, 239
       modal, 372                                 Eclipse, 175, 251–258, 378–379, 382, 396,
    dir, 14                                              464
    directories, 483–484                             documentation, 260, 383
       current working, 12, 20, 24, 29, 107, 121,    downloading, 252
             238                                     GTK vs. Motif versions, 252, 383, 396
       home, 107                                     installing, 251–254
Index                                                                                    555
      Eclipse (continued)                         enumerated values, 90–91
         perspectives, 253                        Enumeration class, 71, 490
            Debug, 253–254                        env, 108
            Java, 256–258                         ENVFILE environment variable, 109–110
            Resource, 253–256                     .envfile file, 110
         projects, 254                            environment variables, 22–25, 104–109, 219
         refactoring, 258–259, 388                   exporting, 22, 105
         using with CVS, 259                         names, 105
         using with JUnit, 312                       passing to Java, 107
         using with XDoclet, 519                     setting, 23, 105
         views, 253                                  substituting, 15
         working with, 257–258                    environments, 104–110
      ed, 47                                      equals(), 61
      eddi, 48                                    equalsIgnoreCase(), 61
      EDITOR environment variable, 198            Error class, 306
      ejbCreate(), 496                            error handling, 75–79
      EJBHome class, 498–499                      error messages, 6–8, 112
      EJB-JAR files, 508–511                       /etc/inittab, 451–453, 457
      ejb-jar.xml, 509–511, 519                   events
      EJBLocalHome class, 499–501                    loops, 381
      EJBLocalObject class, 499–501                  time, 348
      EJBObject class, 495, 497–498, 512          ex, 37
      ejbRemove(), 496                            Exception class, 76–77, 306, 490
      EJBs (Enterprise JavaBeans), 138, 148, 216, @exception tag (Javadoc), 130
            473–492, 518                          exceptions, 75–76, 79, 130
         activating/passivating, 475–476, 496        catching, 78
         compiling, 501–502                          creating, 77
         creating, 475                               extending, 75, 77
         deploying, 505–519                          null pointer, 59
         destructing, 475                            stack trace, 77
         documentation, 503                          throwing, 76–77
         entity, 475–476, 479, 492, 499, 503      Exclude datatype (Ant), 228
         implementing, 474, 493–503               exec(), 111–113
         message, 475, 481                        executeUpdate(), 336
         session, 475–481, 492, 495, 499          exit, 24
            stateful, 476, 478–479, 502           export, 23, 105, 194
            stateless, 476–477, 495–498           expressions
         using with Ant, 502                         in Java, 66
      elvis, 34–35                                   in JSP, 434
      Emacs, 34, 48–49, 214                       .exrc file, 44–45
      encapsulation, 86–87                        ext directory, 301, 332
      endsWith(), 61                              extcheck, 164
      Enterprise Java, see J2EE                   extends statement, 87–88, 92
      Enterprise JavaBeans, see EJBs              Extensible HyperText Markup Language, see
      enterprise systems, 138                           XHTML
      EntityBean class, 475                       Extensible Markup Language, see XML
      enum statement, 91
556                                                                                     Index
                                               float type, 53–54
    F                                          FlowLayout class, 354
    fail(), 307                                folders, see directories
    false constant, 54                         for statement, 69–70
    FAT filesystem, 485                            for arrays, 74
    Fedora, 322, 324, 452–453, 456, 458–463       changing execution, 75
    FetchURL, 97, 158                             for collections, 74
       compiling, 117–118, 182–183                compared with the while loop, 70, 73
       running, 121, 148–156                      with multiple expressions, 69
    file, 16–17                                    in shell scripts, 21, 25
    file choosers (in GUI), 347                 form element (HTML), 406
    File Transfer Protocol, see FTP            format fields, 80–82
    filenames, 9–10, 168, 483–484               Formatting class, 82
       case sensitiveness, 10                  Free Software, xxiii–xxiv, xxviii, 180, 379,
       changing, 12, 25                              446, 522–523
       extensions, 10                          FSF (Free Software Foundation), xxiii, 180
       spaces in, 10                           fte, 49
    files                                       FTP (File Transfer Protocol), 142, 485
       access time, 21
       counting characters, words, lines in, 9 G
       deltas, 210                             garbage collection, 380, 388, 436
       descriptors, 102–104                    Garbage In, Garbage Out, 312
       modification time, 9, 16, 21             gcc (GNU Compiler Collection), 181, 188
       moving, 11–13                           gcc (GNU C Compiler), 180
       ownership of, see owners                gcj (GNU Compiler for Java), xxiii, xxv, 157,
       permissions of, see permissions               181–188, 379
       searching, 19–21                           command-line options, 182–185
       size, 9, 16                                documentation, 188
       temporary, 109                             installing, 144
       types, 17                                  performance, 186–187
       viewing, 18                                using with Ant, 226
    filesystems, 483, 485                          using with SWT, 396–398
       mounted, 170–171, 245                   GECOS, 447
       networked, 171                          gEdit, 48
    FillLayout class, 390                      General Public License, see GNU GPL
    FilterSet datatype (Ant), 228              generics feature, 94–95
    final access modifier, 87, 90–91, 96        Gentleware, 249
    finally statement, 78–79                   Geronimo, 464–466, 495, 501, 521
    find, 19–21, 29, 397                           deploying, 515
    fireTableCellUpdated(), 369                   documentation, 468–469, 519
    fireTableChanged(), 369                       installing, 467
    fireTableDataChanged(), 368–369               mapping, 509
    fireTableRowsDeleted(), 369                   running, 468
    fireTableRowsInserted(), 369               GET request, 406
    fireTableRowsUpdated(), 369                getAttribute(), 414
    fireTableStructureChanged(), 369           getColumnCount(), 360
    Float class, 62                            getColumnName(), 360
Index                                                                                557
      getConnection(), 329                    GTK (GIMP Toolkit), 252, 383
      getContentPane(), 352                   GUI, 151, 341
      getCookies(), 415                          and program parameters, 100
      GetDomain class, 489                       construction time, 348
      getenv(), 105–106                          designing, 347–374
      getInt(), 334–335                          graphical objects, 345–347
      getName(), 363                             native compiled, 378–379
      getOwner(), 363                            rigid areas, 355
      getParameterNames(), 412                gvim, 35
      getParameterValues(), 413               gzip, 218, 466
      getPlatform(), 390
      getProperties(), 106                    H
      getProperty element (JSP), 435          hard links, 168–171
      getProperty(), 106, 110–111             Hashtable class, 106, 111
      getRow(), 336                           Hashtables class, 70
      getRowCount(), 360                      Hayes, Andrew, xxv
      getSelectedRow(), 367                   head, 18
      getSelectionModel(), 366                header files, 133
      getSession(), 414                       “Hello, world”
      getString(), 334–335                       in Swing, 342–344
      getTableCellRendererComponent(),           in SWT, 381–384
           364                                   Web page, 407–410
      getTableHeader(), 369                   Hibernate, 321
      getTotal(), 363, 435                    HOME environment variable, 25, 105, 160
      getty, 451                              hosts, 83
      GetUser class, 132–137                  HTML (HyperText Markup Language), 221,
      getValueAt(), 360, 363–364, 367               405
      getVersion(), 390                          comments, 428
      GHOME environment variable, 501            dynamically generated, 406–407
      gid (group ID), 446–447                    forms, 406, 412
      GIGO (Garbage In, Garbage Out), 312        generated from XML, 406
      GIMP (GNU Image Manipulation Program),     hyperlinks, 416
           252                                   using for prototyping, 275
      Glimmer, 48                             HttpRequest class, 414
      GNOME, 48                               HttpServlet class, 404, 407, 430
      GNU, xxiv, 5, 26, 179–180               HttpServletRequest class, 415
      GNU C Compiler, see gcc                 HttpServletResponse class, 418
      GNU Classpath, 182                      HURD microkernel, 180
      GNU Compiler Collection, see gcc        Huseth, Steve, xxv
      GNU Compiler for Java, see gcj          hyperlinks, 416
      GNU GPL (General Public License), xxiv, HyperText Markup Language, see HTML
           180, 182, 379, 539–547
      GNU/Linux, see Linux
                                              I
      GnuPG (GNU Privacy Guard), 164, 218–219 I/O, 79
      Graphics2D class, 385                      closing, 78
      grep, 18–19, 180                           redirecting, 6, 163
      Group class, 385, 389, 391                 standard, 6–8, 102–104
558                                                                                     Index
    IBM, 236, 377, 518                           interfaces (continued)
       Common Public License, 379                   local, 492, 495, 499–501
       developerWorks, xxv, 396                     local home, 500
       Java SDK, xxiii, xxiv, 167–177, 378          remote, 144, 474, 478, 492, 494–495,
          debugging, 176                                  497–498, 512
          differences from SUN Java SDK,            remote home, 498
                174–176                          internationalization, 80–81
          installing, 173                        IP addresses, 482–484
          performance, 175                       IPv6, 485
       MQSeries, 481                             IRIX operating system, 456
       PC, 34, 48                                isAfterLast(), 335
       Web site, 176–177                         isBeforeFirst(), 335
    ide.cfg, 238                                 isCellEditable(), 365
    Idea IDE, 236                                isEmpty(), 111
    ident, 324                                   isFirst(), 335
    Identifiable class, 88                       isLast(), 335
    IDEs (Integrated Development                 ISO (International Organization for
          Environments), 213, 235–260, 505             Standardization), 485
    IDL (Interface Definition Language), 144, 165 isTotal(), 435
    if-else statement, 66–67                     iterators, 70–74
       inline, 56
       in shell scripts, 21                      J
    IIOP (Internet Inter-ORB Protocol), 144,     J2EE (Java 2 Enterprise Edition), 28, 115,
          165, 175, 480                                148, 444, 464–466, 498–499, 501, 510,
    ImageIcon class, 358                               517–518
    implements statement, 87, 92                    documentation, 492, 503
    import statement, 85–86, 90, 432             J2SE (Java 2 Standard Edition), 62, 115
    include C/C++ directive, 85                  Jakarta project, 438, 444
    Include datatype (Ant), 228                  JApplet class, 344
    IndexOutOfBounds exception, 62               jar, 28, 157–164, 506, 513
    info, 30                                        command-line options, 163–164
    init, 452                                    JAR files, 17, 28, 122, 157–164
    init(), 404, 407, 512                           building with Ant, 513, 516
    InitialContext class, 487                       digitally signed, 164–165
    InitialDirContext class, 490                    in NetBeans, 241
    initialization files, 24                      jar tag (Ant), 227
    InnoDB tables, 317                           jarsigner, 164
    int type, 53, 333                            java, 121–122, 156, 158, 175
       converting to String, 80                     command-line options, 122
    Integer class, 62, 359                       Java, 94–95, 522
    Integrated Development Environments,            and Open Source, xxiii–xxiv, 521
          see IDEs                                  comments, 66, 428, 518
    IntelliJ, 236                                   documentation, xxviii, 166
    interfaces, 87–88, 139                          performance, 378
       generating with XDoclet, 518                 portability, 53
       home, 474, 494–495, 498–499, 511–512         version 5.0, 73, 80, 90, 94
       implementating, 87–88, 91–92                 versions 1.2 and older, 105
       inherited, 88                                versions 1.3 and newer, 106
Index                                                                                    559
      Java Compiler, see javac                   javaw, 175
      Java Data Objects, see JDO                 JBoss, 495, 501, 521
      Java DataBase Connectivity, see JDBC          configurations, 462
      Java Debugger, see jdb                        deploying, 515
      Java Decompiler, see javap                    documentation, 469, 519
      JAVA_HOME environment variable, 173,          downloading, 444
            219–220, 332                            installing, 446, 450–451, 463
      Java Naming and Directory Interface, see      JBoss-IDE, 464
            JNDI                                    mapping, 509–511
      Java Native Interface, see JNI                using with JNDI, 491
      Java Runtime, see java                        using with XDoclet, 519
      Java SDKs (Software Development Kits)      JBOSS_HOME environment variable, 459, 462
         IBM, see IBM Java SDK                   jboss.xml, 509–511
         installing, 144                         JBOSSSH environment variable, 462
         Sun, see Sun Java SDK                   JBuilder IDE, 236
         switching between, 168, 173             JButton class, 354–358, 374, 385–386, 388
      Java Security Manager, 104                 JCheckboxMenuitem class, 385
      Java VMs (Virtual Machines), 95, 111, 175, JComboBox class, 385
            186–187, 383                         JComponent class, 386
      java.library.path, 383                     jCVS, 211–213
      .java.policy file, 146, 165                    documentation, 214
      JavaBeans, 321, 337, 474                   JCVS environment variable, 212
         duration, 436                           jdb (Java Debugger), 148–151
         enterprise, see EJBs                    JDBC (Java DataBase Connectivity),
         session, 439                                  321–322, 325, 327–338, 480, 496
         using with JSP, 434–437                    documentation, 337
      javac, 24, 117–120, 173, 186, 216             downloading, 332
         command-line options, 100, 119–120, 148 JDialog class, 344, 374
         debugging, 120, 148                     JDK, see Sun Java Development Kit
         diagnostics on success, 117             JDK_HOME environment variable, 173
         performance, 186–187                    JDO (Java Data Objects), 321
      javac tag (Ant), 225                       JED, 48
      Javadoc, 62–64, 114, 122–131, 227          jedit, 47
         “Use” pages, 126                        JEditorPane class, 386
         at-tags, 128, 518                       JFace class, 380
         command-line options, 123–127           JFormattedTextField class, 386
         comments, 127–131                       JFrame class, 344–345, 351–354, 373–374,
         documentation, 128                            384, 388–389
         downloading, 64                         jgnash, 158
         running, 123                            Jikes compiler, 177, 227
      javadoc tag (Ant), 227                     JITs (Just-In-Time compilers), 175, 186, 378
      javah, 132–137                             JLabel class, 344, 353–354, 364, 373–374,
      javap (Java Decompiler), 157–160                 384–385, 388
      JAVAPTH environment variable, 459, 462     JList class, 385
      JavaScript, 412                            JMenu class, 385
      JavaServer Pages, see JSP                  JMenuItemA class, 385
560                                                                                     Index
    JNDI (Java Naming and Directory Interface), JUnit (continued)
          336, 482–491, 509                         failures, 306
       contacting with, 511                         GUI version, 302
       documentation, 491–492                       installing, 297–303
       using with JBoss, 491                        test cases, 303–309
    JNI (Java Native Interface), 113, 132–137,      test suites, 309–311
          186, 378                                  using with Ant, 303, 312
    joe, 48                                         using with Eclipse, 312
    JPanel class, 352–355, 370, 374, 385–386
    JPasswordField class, 373, 386              K
    JProgressBar class, 385                     KDE, 100, 252
    JPython, 259                                Kerberos, 165
    JRadioButtonMenuitem class, 385             kernel, 4, 446
    JScrollPane class, 369, 374, 385            keytool, 165
    JSlider class, 386                          kill, 468
    JSP (JavaServer Pages), 138, 416, 423–441,  Kirsanova, Alina, xxv
          444                                   KISS principle (Keep It Simple, Stupid!), 282
       declarations, 429–430, 434               konsole, 6
       directives, 431–433                      Kumar, Deepak, xxv
       documentation, 440
       expressions, 430–431, 434
                                                L
       generated from XML, 434                  Label class, 384–385, 388, 391–392
       predefined variables, 432                 labels (in GUI), 346, 353–354, 374, 385
       scriptlets, 427–429, 434                 layout managers, 347–348, 372, 374, 392
       updating, 433                            LayoutManager class, 374
       using with JavaBeans, 434–437            LD_LIBRARY_PATH environment variable,
       using with servlets, 425, 430                   135, 383
       validating, 434                          LDAP (Lightweight Directory Access
       XML syntax for, 434                             Protocol), 140, 485–487
    JSpinner class, 385                             distinguished names, 485
    JSTL (JSP Standard Tag Library), 437–438,   ldconfig, 135
          440                                   length(), 61
    JTable class, 359–364, 367–368, 370, 374,   less, 17
          386                                   Lessig, Lawrence, 522, 524
    JTableColumn class, 386                     libgcj, 182, 188
    JTableHeader class, 369                     libraries
    JTabPane class, 386                             in command-line options, 181
    JTextArea class, 374, 386                       names, 135
    JTextField class, 372–374, 386                  shared, 135, 383
    JTextPane class, 374, 386                   @link tag (Javadoc), 130–131
    JTree class, 374, 386                       LinkedLists class, 70
    JUnit, 295–313                              Linux, xxiii, 107, 180, 522
       assertions, 305–308                          philosophy, 524
       command-line version, 303                    as programmer-friendly platform, xxi
       documentation, 313                           releases, 34
       downloading, 299–301                         tools, 5
       errors, 306                              list, 156
Index                                                                                     561
      List class, 385                             Microsoft
      list(), 110                                   Active Directory, 487
      lists (in GUI), 346, 385                      Internet Explorer, 166
      Lists class, 70                               Message Queue Server, 481
      ListSelectionListener class, 366              MS-DOS, 10, 14, 163
      ListSelectionModel class, 365–367             Windows, 161, 163, 217, 253, 255, 319,
      load(), 110                                         381
      loadLibrary(), 135                          Miller, Andy, xxv
      log files, 18, 104                           mkdir, 194
      Logajan, George, xxv                        mkdir tag (Ant), 227
      Long class, 62                              Model/View/Controller design pattern, 359,
      long type, 53                                    438
      lookup(), 142                               modularization, 9
      loops, 67–75                                MoneyBean, 496
      ls, 6, 9, 15, 24, 100, 180, 240, 446, 483   Mono project, 521
      LVM (Logical Volume Manager), 171           Monty Python, 215
                                                  Moore, Dan, xxv
      M                                           more, 17, 238
      Macromedia Flash, 166                       Motif, 47, 49, 252, 383
      main(), 100–102, 121–122, 161               MouseAdapter class, 393
          specifying on command line, 183, 185    MouseListener class, 393
      mainframe clients, 480                      Multics project, 6
      make, 216, 397                              multitier systems, 137, 143, 147, 518
          comparing with Ant, 225                 MutableTreeNode class, 386
      makefiles, 216                               mv, 11–13, 100
      man, 29–30                                  MyISAM tables, 317
      manifest files (MANIFEST.MF), 122, 161–162,  MySQL, 317, 328
             507, 511                               connecting to, 329
      marshaling/unmarshaling, 143, 482, 495, 500   documentation, 317, 326
      mbedit, 47                                    JDBC for, 332, 337
      md5sum, 218–219                             mysqld, 459
      memory leaks, 380
      Menu class, 385                             N
      MenuItem class, 385                         \n , 81, 107
      menus (in GUI), 346, 385                    namespaces, 83, 484
      MessageBean class, 475                      naming services, see directory services
      META-INF directory, 507, 511                NamingEnumeration class, 490
      methods                                     native2ascii, 165
          calls, 66                               NDS (Novell Directory Service), 487
          defining, 58                             NEdit, 47
          deprecated, 120, 127, 129               .NET development environment, 480, 521
          native, 132–137, 216                    NetBeans, 236–251
          overriding, 96                            CVS in, 244–248
          remote, 143                               documentation, 259–260
          return values, 75                         downloading, 237
          scope, 59                                 editing, 243–244
          with variable argument list length, 82    GUI, 240–244
          void, 75                                  installing, 237–239
562                                                                                   Index
    NetBeans (continued)                         OSI (Open Systems Interconnection), 485
      running, 239–240                           OTN (Oracle Technology Network), 318
      using with Ant, 248–249                    owners of files, 9–10, 16
      using with C/C++, 249                         changing, 11, 170, 448
      using with servlets, 430                      group, 10, 445–450, 463
    new statement, 56–59, 87                        other, 10
    newline characters, in output, 79               user, 10
    NewStringUTF(), 134
    next, 156                                    P
    next(), 73                                   pack(), 345, 352
    NFS (Network File System), 459, 485          package statement, 83–85, 125, 183
    nobody user, 323                             packages
    nonblocking revisions, 317                      default, 183
    Novell Directory Service, see NDS               directories, 84
    NTFS filesystem, 485                             documentation, 123
    numbers, 53–54                                  names, 83–84, 146
    nvi, 34                                         protecting, 83
                                                    size, 83
    O                                            panels (in GUI), 347
    Object class, 61, 87, 94, 359                @param tag (Javadoc), 130, 518
    objects, 57                                  Pascal, 69
      comparing, 56                              passwords, 285, 324, 373
      converting to String, 80                      root, 445–450
      creating, 56                                  sharing, 445–446
      grouping, 70                                  storing, 195, 447
      referencing, 59–60                            supplying in URL, 329
    ODMG (Object Data Management Group),         PATH environment variable, 24–25, 105, 144,
          321                                          173, 219, 239
    OJB (Object Relational Bridge), 321          pattern matching, 13–15
    OLE class, 390                               PatternSet datatype (Ant), 228
    OOA (object-oriented analysis), 279–280,     Payback, 123, 161–163
          285, 287                                  buildfile for, 229–231
    OOD (object-oriented design), 279–287, 359      compiling, 184
    OOP (object-oriented programming), xxviii,   pBeans, 321
          57                                     Perens, Bruce, xxv
    Open Publication License, The, xxiv          Perl, 44, 446
    Open Source, xxiii–xxiv, xxviii, 5, 46, 189, permissions, 10–11, 445, 463
          213, 379, 522–524                         changing, 11, 448
    openejb-jar.xml, 509                            for directories, 9, 449
    operators, 55–56                                for files, 9, 16
      overloading, 52                               for hard links, 170
      precedence, 55                             persistent storage, 316, 320–322
      unary, 55–56                               pg, 17
    Oracle, 316, 318, 328, 332                   PGP signatures, 218
      connecting to, 329                         pico, 47
      documentation, 337                         pipes, 8–9, 238, 258
    orbd, 175                                    pkzip, 163
Index                                                                                       563
      pointers, 134
         null, 59, 75                               R
      policytool, 165                               radio buttons (in GUI), 345
      polymorphism, 91–94                           RAID (Redundant Array of Inexpensive
      portability, 53, 106, 113, 186–187, 216, 319,       Disks), 171
            380                                     Raymond, Eric, xxiii, 449
      portmanteau abbreviations, 157                RealPlayer, 166
      portmap, 459                                  rebind(), 142
      Poseidon for UML, 249                         RedHat, 217, 322, 452, 456, 458–463
      POST request, 406, 412                           Package Manager, see rpm
      postgres user, 323                            regular expressions, 19, 43–44
      postgresql, 459                               RemoteException exception, 139–140
      PostgreSQL, 317, 328                          remove(), 71
         documentation, 317, 326                    repeat-until statement, 69
         installing, 322                            ResultSet class, 329, 334–337
      predicates, 20–21                             return statement, 75
      Prentice Hall PTR, xxiv, 523                  @return tag (Javadoc), 130
      PreparedStatement class, 329, 333, 335,       rigid areas (in GUI), 355
            337                                     rm, 109
      print(), 79                                   RMI (Remote Method Invocation), 137–148,
      printf(), 79–82                                     216, 482
      println(), 79, 419                               building with Ant, 228
      printStackTrace(), 77                            registry, 140, 142, 487
      PrintStream class, 79                            stubs, 138, 143–144
      private access modifier, 83, 88–89, 125        rmic, 137, 143–144, 147, 216, 228
      processes                                     rmic tag (Ant), 228
         IDs, 108                                   rmid, 165
         running, 121                               rmiregistry, 144, 148
      programs, see applications                    Robot class, 312
      progress bars (in GUI), 346, 385              rollback(), 77
      ProgressBar class, 385                        root (superuser), 11, 323, 445–450, 452, 462
      project element (Ant), 223–224                RowLayout class, 391
      Properties class, 106, 109–111, 224           RowSets class, 337
      properties files, 109–111, 113                 rpm, 217
         comments in, 111                           rsync, 485
         names, 110                                 run, 148
      property element (Ant), 224                   runlevels, 452–459
      propertyNames(), 111                          Runtime class, 111–113
      protected access modifier, 88–89, 125
      prototyping, 274–276, 416
                                                    S
      proxies, 143, 494                             Saint-Exupéry, Antoine de, 282
      ps, 468                                       SAMoney class, 496
      public access modifier, 83, 88–90, 124         Sash class, 389
      put(), 111                                    Scale class, 385
                                                    scriptlets, 427–429, 434
      Q                                             scroll panes (in GUI), 347, 369–370
      Qt library, 252                               Scrollable class, 389
564                                                                                        Index
    ScrollBar class, 385                          setenv, 105
    search engines, 412                           setgid bits, 449
    security, 165, 323–324, 486                   setHorizontalScrollBarPolicy(), 370
       and default groups for users, 448          setHorizontalTextPosition(), 358
       and root access, 445, 462                  setInt(), 333
       auditability, 445                          setLayout(), 355, 390
       checksums, 218                             setProperty element (JSP), 435
       digital signatures, 164, 218               setProperty(), 111
       passwords, 324, 446–450                    setReorderingAllowed(), 368
       policy files, 146, 165                      setResizingAllowed(), 368
    security managers, 142, 145                   Sets class, 70
    SecurityException exception, 104              setStatus(), 368, 392
    SecurityManager class, 131                    setString(), 333
    sed, 44, 47, 258                              setters, 104
    @see tag (Javadoc), 130                       setText(), 354, 364
    Selection class, 392                          setTimestamp(), 333
    selection listeners, 365–368, 393             setTotal(), 435
    SelectionAdapter class, 393                   setUp(), 305, 309
    SelectionListener class, 393                  setVerticalScrollBarPolicy(), 370
    SelectionModel class, 374                     setVerticalTextPosition(), 358
    serialver, 165                                setVisible(), 345, 352
    servers, 404–407, 410, 443–469                SGML (Standard Generalized Markup
       compiling, 146–147                               Language), 220–221
       connecting with a browser, 413             Shell class, 381, 384, 386–391
       developing, 139–142                        shell languages, 21
       setting up, 144–147                        shell scripts, 22, 319
    Service Provider Interface, see SPI              JUnit tests, 303
    service(), 404                                   loops, 25
    Servlet class, 404, 406                          parameters, 25
    servlets, 138, 403–421, 512                      running, 24, 108
       designing, 416–420                            for startup, 193
       documentation, 440                         shell variables, see environment variables
       MIME for, 432                              shells, 4, 21–26
       packaging, 512–514                         shopping cart, 477–478, 481
       session variables, 414, 431, 437, 439, 441 short type, 53
       using as daemons, 407                      short-circuiting, 56
       using with JSP, 425, 430                   Slider class, 386
    Sesame Street, 343                            sliders (in GUI), 346
    Session class, 139–142                        SMAC (SMall ANSI C Interpreter), 48
    SessionBean class, 475, 495–498, 512          SMB filesystem, 485
    setAttribute(), 414                           software, see applications
    setBigDecimal(), 333                          software engineering, 57, 263–279
    setDefaultCloseAction(), 344                     documenting, 272–274
    setDefaultRenderer(), 364                        iterative approach, 266, 277
    setDouble(), 333                                 requirements, 266–276, 288
    setEnabled(), 357                             Software Engineering Institute, 277
    setEntityContext(), 475                       sorting, 107
Index                                                                                      565
      source control, 126, 189–190, 213           Sun Microsystems, 94, 106, 166, 187, 236,
         files for, 195                                  321, 521
      SourceForge, 299                               Java SDK, xxiii, xxiv, 115–166, 378
      SPARC, 186                                        differences from IBM Java SDK,
      SPI (Service Provider Interface), 487–491               174–176
      split panes (in GUI), 347                         Enterprise Edition, see J2EE
      SpringLayout class, 372                           installing, 173
      sprintf(), 82                                     Micro Edition, 115
      SQL, 328, 333–336                                 Standard Edition, see J2SE
      Stallman, Richard, xxiii, 179–180, 522, 524    SOS (SunONE Studio), 236, 251
      standard error, 6–8                            Web site, 64–65, 98, 161, 166, 337, 375,
      Standard Generalized Markup Language, see            421, 441, 491–492
            SGML                                  superuser, see root
      standard input, 6–8, 47, 103                Swing, xxiii, 251, 309, 341–376
      standard output, 6–8, 47, 103                  compared to SWT, 379, 384–388, 395
         piping, 8, 107                              containers, 344
         reassigning, 104                            documentation, 375
         redirecting, 6, 104, 108                    graphical objects, 345–347
      Standard Widget Toolkit, see SWT               performance, 378
      startsWith(), 61                               portability, 380
      Statement class, 337                           using with HTML, 373
      statements, in Java, 64–75                  switch statement, 67
      static access modifier, 87, 90–91, 102       SWT (Standard Widget Toolkit), xxv, 175,
      static initializers, 133, 135                     251, 377–399
      status lines (in GUI), 352, 358                ActiveX support, 390
      step, 156                                      adapters, 393
      STL algorithms, 95                             and garbage collection, 380
      Stochniol, Andrzej, 49                         compared to Swing, 379, 384–388, 395
      store(), 111                                   documentation, 381, 383, 398
      stored procedures, 480                         installing, 381
      streams, 109                                   performance, 378
      strftime(), 81                                 portability, 380
      String class, 60–62, 86                        using with gcj, 396–398
      StringBuffer class, 60                      SWT class, 390
      strings                                     SWTException class, 390
         comparing, 61                            symlinks (symbolic links), 171–172, 239, 451,
         concatenating, 60, 79                          467
         length, 61                                  circular chains, 172
         searching, 18–19                            dangling, 172
         substrings, 61                           System class, 86, 102–109
      strlen(), 54                                System V init system, 451–458, 463
      StrongARM, 186
      su, 445, 450                                T
      substring(), 61                             tabbed panes (in GUI), 347
      Subversion, 189                             TabFolder class, 386
      sudo, 445–446                               TabItem class, 386
566                                                                                 Index
    Table class, 386, 394–395                ToolBar class, 386
    table element (HTML), 386, 411           toolbars (in GUI), 347, 386
    TableCellEditor class, 386               ToolItem class, 386
    TableCellRenderer class, 374, 386        toString(), 77, 80, 91, 359, 363–364, 419,
    tableChanged(), 368                            430, 490
    TableColumn class, 386, 394–395          touch, 433
    TableColumnModel class, 386              toUpperCase(), 61
    TableItem class, 386, 394–395            tr element (HTML), 411
    TableModel class, 359, 368, 374          translations, see internationalization
    TableModelEvent class, 368–369           traverse(), 397
    TableModelListener class, 368            Tree class, 386
    tables (in GUI), 346                     TreeItem class, 386
       background color, 364                 trees (in GUI), 346, 386
       editors, 365                          true constant, 54
       renderers, 363–365                    try statement, 76–79
       scrolling, 369–370
       in Swing, 352, 359–363, 374           U
       in SWT, 394–395                       uid (user ID), 446–447
    tag libraries, 437–438                   Umbrello, 287, 290
    tail, 18                                 UML (Unified Modeling Language), 249,
    tar, 26–29, 163, 217, 466                      285, 287, 289
       command-line options, 26, 238         UnicastRemoteObject class, 140
       examining contents of files, 238       Unicode, 54, 134, 165
    target element (Ant), 223–224            UNIX
    Task class, 228                             archive formats, 163, 217
    Taub, Mark, xxiv                            commercial versions, 252
    TCP/IP, 482, 485                            daemon processes, 323
    td element (HTML), 411                      filesystems, 483–485
    tearDown(), 305, 307, 309                   online manuals, 29
    TestCase class, 303–305, 308                operating system commands, 4
    TestRunner class, 309                       philosophy, 524
    TestSuite class, 309                        as programmer-friendly platform, xxi, 397
    text areas (in GUI), 346                    releases, 34
    Text class, 386                             shell scripts, 319
    text fields (in GUI), 346, 372, 374, 386     standard I/O, 6, 102
    text panes (in GUI), 346                    tools, 5
    the, 48                                     user interface, 4
    Thinking in Java, 52, 58, 60, 65, 94, 98 unzip, 27, 299
    throw statement, 76–77                      inspecting files before unzipping, 299
    throws keyword, 306                      URLEncoder class, 413
    @throws tag (Javadoc), 130               URLs, 404–406
    time value of money, 495–497                parameters in, 412–413, 436
    Timestamp class, 333                        passwords in, 329
    toLowerCase(), 61                        useBean element (JSP), 435
    Tomcat, 259, 407, 410, 430, 444          USER environment variable, 105
    tool tips (in GUI), 346                  UTF-8 encoding, 134
Index                                                                               567
                                             WebSphere Studio, xxviii, 236
      V                                      well-formedness, 221
      validation, 220                        which, 24
      variables                              while statement, 67–68
         declaring inside for loops, 69         changing execution, 75
         local, 77                              compared with the for loop, 70, 73
         of object type, 59                  whitespace
      @version tag (Javadoc), 126               in filenames, 10
      vi, 5, 34–45, 49                          trailing, 44
         case sensitiveness, 44              Widget class, 389, 391–392
         copying/pasting, 39                 windows (in GUI), resizing, 343, 353–355
         deleting, 39                        WordStar, 48–49
         exiting, 40–41
         indentation, 40, 45                 X
         modes, 35                           X Window, 47, 252, 380
            ex, 37–38, 40–44                 X.500 standard, 485
            input, 35–36, 40, 45             X11, 49
            vi, 35                           xcoral, 48
         positioning, 36–38                  XDoclet, 517–518
         repeating commands, 40                 documentation, 519
         searching, 38–39, 41–44                generating interfaces, 518
         substitutions, 41–44                   using with Ant, 517–518
         undoing/redoing, 40                    using with JBoss, 519
         using with CVS, 198                 xedit, 48
         using with NetBeans, 244            Xelfi, see NetBeans
         words in, 37                        XFree86, 446
      vim, 34–35, 40                         XHTML (Extensible HyperText Markup
      virtual access modifier (C++), 96             Language), 221
      Virtual Network Console, see VNC       xinetd, 458
      VISUAL environment variable, 198       XML (Extensible Markup Language),
      VNC (Virtual Network Console), 137           220–222
      Vogen, Kirk, xxv, 396                     using for JSP, 434
      Von Neumann architecture, 343          XML Schema, 220
                                             XSLT (XSL Transformations), 221
      W                                      xterm, 6
      WAR files, 28, 464, 512
         building with Ant, 513, 516         Y
      wc, 9                                  YaST, 47–48
      Web browsers, see browsers
      Web pages, 405                         Z
         changing, 423                       zip, 26–29, 466
         common parts, 432                   ZIP files, 17, 157
         dynamically generated, 406–407, 411    inspecting before unzipping, 299
         static, 405, 416                       in NetBeans, 241
      Web servers, see servers               Zoetebier, John, 237
      web.xml, 512–513, 519                  zone transfers, 491
      WEB-INF directory, 512
* 学习笔记
** 目录
   类型转换
   流程控制
   类与对象
   定义类

         4.1.2 使用标准类 .............................87

         4.1.3 对象指定与相等性 .................90


    4.2 基本类型打包器 ........................ 91
         4.2.1 打包基本类型 .........................91

         4.2.2 自动装箱、拆箱 .....................92

         4.2.3 装箱的内幕 .............................93

              4.3 数组对象 .................................... 96
                                                                      4.3.1 数组基础 .................................96
        2.2.1 编译程序(javac)与
        SOURCEPATH ................................... 31             4.3.2 操作数组对象 .........................99
        2.2.2 使用 package 管理类 .............. 33                        4.3.3 数组复制 .............................. 105
        2.2.3 使用 import 偷懒 .................... 36               4.4 字符串对象 .............................. 108
   2.3 使用 IDE..................................... 38                 4.4.1 字符串基础 .......................... 108
        2.3.1 IDE 项目管理基础 ................. 38                         4.4.2 字符串特性 .......................... 111
        2.3.2 使用了哪个 JRE ..................... 43                      4.4.3 字符串编码 .......................... 115
        2.3.3 类文档版本 ............................. 45             4.5 查询 Java API 文件 .................. 117
   2.4 重点复习 .................................... 48              4.6 重点复习 .................................. 119
   2.5 课后练习 .................................... 49              4.7 课后练习 .................................. 120
Chapter3 基础语法.............................. 53                Chapter5 对象封装............................ 125
   3.1 类型、变量与运算符 ................ 54                             5.1 何谓封装 .................................. 126
        3.1.1 类型 ......................................... 54         5.1.1 封装对象初始流程 .............. 126
         5.1.2 封装对象操作流程 .............. 128                    7.3 重点复习 .................................. 224
         5.1.3 封装对象内部数据 .............. 131                    7.4 课后练习 .................................. 224
     5.2 类语法细节 .............................. 134
                                                           Chapter8 异常处理............................ 231
         5.2.1 public 权限修饰 ................... 134
         5.2.2 关于构造函数 ...................... 136              8.1 语法与继承架构 ...................... 232
         5.2.3 构造函数与方法重载 .......... 137                            8.1.1  使用 try、catch .................... 232
         5.2.4 使用 this ............................... 139         8.1.2  异常继承架构 ...................... 235
         5.2.5 static 类成员......................... 142             8.1.3  要抓还是要抛 ...................... 238
         5.2.6 不定长度自变量 .................. 148                      8.1.4  认识堆栈追踪 ...................... 241
         5.2.7 内部类 .................................. 150          8.1.5  关于 assert ............................ 245
         5.2.8 传值调用 .............................. 151        8.2 异常与资源管理 ...................... 247
     5.3 重点复习 .................................. 154               8.2.1 使用 finally ........................... 247
                                                                   8.2.2 自动尝试关闭资源 .............. 249
     5.4 课后练习 .................................. 155
                                                                   8.2.3  java.lang.AutoCloseable
Chapter6 继承与多态 ........................161                                接口 ...................................... 251
     6.1 何谓继承 .................................. 162          8.3 重点复习 .................................. 255
         6.1.1 继承共同行为 ...................... 162              8.4 课后练习 .................................. 256
         6.1.2 多态与 is-a ........................... 166
         6.1.3 重新定义行为 ...................... 170           Chapter8 Collection 与 Map.............. 261
         6.1.4 抽象方法、抽象类 .............. 173                    9.1 使用 Collection 收集对象 ........ 262
     6.2 继承语法细节 .......................... 174                     9.1.1  认识 Collection 架构............ 262
         6.2.1 protected 成员 ...................... 174             9.1.2  具有索引的 List ................... 263
         6.2.2 重新定义的细节 .................. 176                      9.1.3  内容不重复的 Set ................ 266
         6.2.3 再看构造函数 ...................... 178                   9.1.4  支持队列操作的 Queue ....... 270
         6.2.4 再看 final 关键字 ................. 180                  9.1.5  访问对象的 Iterator.............. 273
         6.2.5 java.lang.Object .................... 181           9.1.6  排序收集的对象 .................. 276
         6.2.6 关于垃圾收集 ...................... 186                   9.1.7  使用泛型 .............................. 280
         6.2.7 再看抽象类 .......................... 189           9.2 键值对应的 Map ...................... 284
     6.3 重点复习 .................................. 191               9.2.1 常用 Map 操作类 ................. 284
                                                                   9.2.2 访问 Map 键值 ..................... 288
     6.4 课后练习 .................................. 192
                                                              9.3 重点复习 .................................. 291
Chapter7 接口与多态 ........................199                    9.4 课后练习 .................................. 292
     7.1 何谓接口 .................................. 200
         7.1.1 接口定义行为 ...................... 200           Chapter10 输入输出.......................... 299
         7.1.2 行为的多态 .......................... 204           10.1  InputStream 与
         7.1.3 解决需求变化 ...................... 206                    OutputStream .......................... 300
     7.2 接口语法细节 .......................... 213                      10.1.1   串流设计的概念 .............. 300
         7.2.1 接口的默认 .......................... 213                 10.1.2   串流继承架构 .................. 303
         7.2.2 匿名内部类 .......................... 217                 10.1.3   串流处理装饰器 .............. 306
         7.2.3 使用 enum 枚举常数 ........... 221                   10.2 字符处理类 ............................ 311
VIII
                                                                                                     目                录
         10.2.1       Reader 与 Writer 继承                             12.4 NIO2 文件系统 ...................... 405
                     架构 ................................. 311              12.4.1 API 架构概述 .................. 405
         10.2.2       字符处理装饰器.............. 313                            12.4.2 操作路径.......................... 406
   10.3 重点复习 ................................ 315                          12.4.3 属性读取与设定 .............. 409
   10.4 课后练习 ................................ 316                          12.4.4 操作文档与目录 .............. 412
         10.4.1       选择题 ............................. 316                12.4.5 读取、访问目录 .............. 414
         10.4.2       操作题 ............................. 317                12.4.6 过滤、搜索文档 .............. 418
                                                                     12.5 重点复习 ................................ 421
Chapter11 线程与并行 API ...............319
                                                                     12.6 课后练习 ................................ 422
   11.1 线程 ........................................ 320
         11.1.1       线程简介.......................... 320          Chapter12 窗口程序设计 .................. 425
         11.1.2       Thread 与 Runnable ......... 323                13.1 Swing 入门 ............................. 426
         11.1.3       线程生命周期.................. 324                         13.1.1 简易需求分析 .................. 426
         11.1.4       关于 ThreadGroup ........... 331                       13.1.2 Swing 组件简介............... 427
         11.1.5       synchronized 与 volatile... 334                       13.1.3 设计主窗口与菜单列 ...... 429
         11.1.6       等待与通知...................... 345                      13.1.4 关于版面管理 .................. 433
   11.2 并行 API ................................. 349                       13.1.5 事件处理.......................... 436
         11.2.1       Lock、ReadWriteLock 与                           13.2 文档打开、存储与编辑 ........ 442
                     Condition .......................... 349              13.2.1 操作打开文档 .................. 442
         11.2.2       使用 Executor .................. 357                   13.2.2 制作存储、关闭文档 ...... 445
         11.2.3       并行 Collection 简介 ....... 370                         13.2.3 文字区编辑、剪切、复制、
   11.3 重点复习 ................................ 373                                 粘贴.................................. 448
   11.4 课后练习 ................................ 375                    13.3 重点复习 ................................ 449
                                                                     13.4 课后练习 ................................ 451
Chapter12 通用 API ..........................377
   12.1 日志 ........................................ 378           Chapter14 整合数据库 ...................... 444
         12.1.1       日志 API 简介 ................. 378                14.1 JDBC 入门.............................. 454
         12.1.2       指定日志层级.................. 380                         14.1.1 JDBC 简介 ....................... 454
         12.1.3       使用 Handler 与 Formatter                               14.1.2 连接数据库 ...................... 458
        .................................................. 382
                                                                           14.1.3 使用 Statement、
         12.1.4       自定义 Handler、Formatter 与                                     ResultSet .......................... 464
                      Filter ................................ 383          14.1.4 使用 PreparedStatement、
         12.1.5       使用 logging.properties.... 385                               CallableStatement ............ 469
   12.2 国际化基础、日期 ................ 387                                14.2 JDBC 进阶.............................. 472
         12.2.1 关于 i18n ......................... 387                      14.2.1 使用 DataSource 取得
         12.2.2 使用 Date 与 DateFormat .. 390                                       联机 ................................. 472
         12.2.3 使用 Calendar .................. 393                         14.2.2 使用 ResultSet 卷动、
   12.3 规则表示式 ............................ 395                                    更新数据 ......................... 476
         12.3.1       定义规则表示式.............. 396                            14.2.3 批次更新.......................... 479
         12.3.2      Pattern 与 Matcher ........... 403                     14.2.4 Blob 与 Clob .................... 480
                                                                                                                        IX
         14.2.5 交易简介.......................... 481          16.1.3 使用 super 与? ................. 530
         14.2.6 metadata 简介 .................. 489    16.2 自定义枚举 ............................ 533
         14.2.7 RowSet 简介 .................... 492          16.2.1 了解 java.lang.Enum 类..... 533
   14.3 重点复习 ................................ 496     16.3 关于注释 ................................ 542
   14.4 课后练习 ................................ 497           16.3.1 常用标准注释 .................. 542
                                                            16.3.2 自定义注释类型 .............. 545
Chapter15 反射与类加载器 ...............499
                                                            16.3.3 执行时期读取注释信息 .. 549
   15.1 运用反射 ................................ 500
                                                      16.4 重点复习 ................................ 551
         15.1.1 Class 与.class 文档 .......... 500
                                                      16.5 课后练习 ................................ 551
         15.1.2 使用 Class.forName() ...... 502
         15.1.3 从 Class 获得信息 ........... 503       AppendixA 如何使用本书项目 .......... 553
         15.1.4 从 Class 建立对象 ........... 506          A.1 项目环境配置.......................... 554
         15.1.5 操作对象方法与成员 ...... 509
                                                      A.2 打开案例 ................................. 554
         15.1.6 动态代理.......................... 512
   15.2 了解类加载器 ........................ 515        AppendixB   MySQL 入门 ................... 557
         15.2.1 类加载器层级架构 .......... 515               B.1 安装、设定 MySQL................ 558
         15.2.2 建立 ClassLoader 实例 .... 518            B.2 MySQL 的数据类型................ 560
   15.3 重点复习 ................................ 520     B.3 建立数据库、数据表 .............. 561
   15.4 课后练习 ................................ 521     B.4 进行 CRUD 操作..................... 562
Chapter16 自定义泛型、枚举与标注 523
   16.1 自定义泛型 ............................ 524
         16.1.1 定义泛型方法.................. 524
         16.1.2 使用 extends 与? .............. 525
**  Hello World 
    可以在编译时指定 -verbose 自变量,看到编译程序进行编译时的过程,有助于了解
SOURCEPATH 与 CLASSPATH 的差别,如图 2.20 所示。
     就初学者而言,最主要看看圈住的部分,在编译时,会先搜索-sourcepath 指定的文
件夹(上例指定 src)是不是有使用到的类原始码,然后会搜索 CLASSPATH 中,是否有
已编译的类位码。你可以发现,其实默认搜索位码的路径包括许多默认的 JAR 文档,像
是 rt.jar 等,留意最后那个“.”,由于没有指定-classpath(-cp),默认会搜索目前路径。
     确认原始码与位码搜索路径之后,接着检查 CLASSPATH 中是否已经有编译完成的
Main 类,如果存在且从上次编译后,Main 类的原始码并没有改变,则无须重新编译,如果
不存在,则重新编译 Main 类。就上例而言,由于 CLASSPATH 并不包括 classes 文件夹,
所以找不到 Main 类位码,因此重新编译出 Main.class 并存放至 classes 中。
     接着检查 CLASSPATH 中是否已经有编译完成的 Console 类,如果存在且从上次编译
后,Console 类的原始码并没有改变,则无须重新编译,如果不存在,则重新编译 Console
类。就上例而言,由于 CLASSPATH 并不包括 classes 文件夹,所以找不到 Console 类位
码,因此重新编译出 Console.class 并存放至 classes 中。
     实际项目中会有数以万计的类,如果每次都要重新将.java 编译为.class,那会是非常
费时的工作,所以编译时若类路径中已存在位码,且上次编译后,原始码并没有修改,无
须重新编译会比较节省时间。因此,就上例而言,应该指定-cp 为 classes,如图 2.21 所示。
                                                          33
                          图 2.21 编译时指定-sourcepath 与-cp
    注意,这次指定了-sourcepath 为 src,而-cp 为 classes,所以会在 src 中搜索位原始
码文档,在 classes 中搜索位码文档(注意最后的 classes)。由于 CLASSPATH 中包括
classes 文件夹,所以找到 Console 类位码,因此无须重新编译 Console.class,而只编译
javac 指定的 Main.java 为 Main.class。
         JVM 默认的类搜索路径,也就是那些 JAR 文档的搜索路径,其实与类加载器有关,这是
         个进阶议题,第 15 章会加以讨论。
2.2.2     使用 package 管理类
    现在所撰写的类,.java 放在 src 文件夹中,编译出来的.class 放置在 classes 文件夹
下,就文档管理上比较好一些了,但还不是很好,就如同你会分不同文件夹来放置不同作
用的文档,类也应该分门别类加以放置。
    举例来说,一个应用程序中会有多个类彼此合作,也有可能由多个团队共同分工,完
成应用程序的某些功能块,再组合在一起。如果你的应用程序是多个团队共同合作,若不
分门别类放置.class,那么若 A 部门写了个 Util 类并编译为 Util.class,B 部门写了个 Util
类并编译为 Util.class,当他们要将应用程序整合时,就会发生文档覆盖的问题,而如果现
在要统一管理原始码,也许原始码也会发生彼此覆盖的问题。
    你要有个分门别类管理类的方式,无论实体文档上的分类管理,还是类名称上的分类
管理,在 Java 语法中,有个 package 关键词,可以协助你达到这个目的。
    请用“记事本”打开 2.2.2 中 Hello1/src 文件夹中的 Console.java,在开头输入图 2.22
所示的反白文字。
                                                                                1
                        图 2.22 将 Console 类放在 cc.openhome.util 类下
     这表示,Console 类将放在 cc.openhome.util 类下,用 Java 的术语来说,Console 这个
类将放在 cc.openhome.util 包(package)。
     请再用“记事本”打开 2.2.2 中 Hello1/src 文件夹中的 Main.java,在开头输入图 2.23
所示的反白文字,这表示 Console 类将放在 cc.openhome 类下。
                            图 2.23 将 Main 类放在 cc.openhome 类下
         包通常会用组织或单位的网址命名。举例来说,我的网址是 openhome.cc,包就会反过
         来命名为 cc.openhome,由于组织或单位的网址是独一无二的,这样的命名方式,比较
         不会与其他组织或单位的包名称发生同名冲突。
     当类原始码开始使用 package 进行分类时,就会具有 4 种管理上的意义:
       原始码文档要放置在与 package 所定义名称层级相同的文件夹层级中。
       package 所定义名称与 class 所定义名称,会结合而成类的完全吻合名称(Fully
        qualified name)。
       位码文档要放置在与 package 所定义名称层级相同的文件夹层级中。
       要在包间可以直接使用的类或方法(Method)必须声明为 public。
     关于第 4 点,牵涉包间的权限管理,将在 5.2.1 节介绍,本章先不予讨论,以下针对
前三点分别做说明。
    1. 原始码文档与包管理
    目前计划将所有原始码文档放在 src 文件夹中管理,由于 Console 类使用 package 定义
在 cc.openhome.util 包下,所以 Console.java 必须放在 src 文件夹中的 cc/openhome/util
文件夹,在没有工具辅助下,必须手动建立出文件夹。Main 类使用 package 定义在
cc.openhome 包下,所以      Main.java 必须放在 src 文件夹的 cc/openhome 文件夹中。
    这么做的好处很明显,日后若不同组织或单位的原始码要放置在一起管理,就不容易
发生原始码文档彼此覆盖的问题。
                                                                           35
    2. 完全吻合名称
    由于 Main 类是位于 cc.openhome 包分类中,其完全吻合名称是 cc.openhome.Main,而
Console 类是位于 cc.openhome.util 分类中,其完全吻合名称为 cc.openhome.util.Console。
    在原始码中指定使用某个类时,如果是相同包中的类,只要使用 class 所定义的名称
即可,而不同包的类,必须使用完全吻合名称。由于 Main 与 Console 类是位于不同的包中,
在 Main 类中要使用 Console 类,就必须使用 cc.openhome.util.Console。也就是说,Main.java
现在必须修改,如图 2.24 所示。
    这么做的好处在于,若另一个组织或单位也使用 class 定义了 Console,但其包定义为
com.abc,则其完全吻合名称为 com.abc.Console,也就不会与你的 cc.openhome.util.Console
发生名称冲突问题。
    3. 位码文档与包管理
    目前计划将所有位码文档放在 class 文件夹中管理,由于 Console 类使用 package 定义
在 cc.openhome.util 包下,所以编译出来的 Console.class 必须放在 classes 文件夹的
cc/openhome/util 文件夹中,Main 类使用 package 定义在 cc.openhome 包下,所以 Main.class
必须放在 classes 文件夹的 cc/openhome 文件夹中。
    不用手动建立对应包层级的文件夹,在编译时若有使用-d 指定位码的存放位置,就会
自动建立出对应包层级的文件夹,并将编译出来的位码文档放置至应有的位置,如图 2.25
所示。
                     图 2.25 指定-d 自变量,会建立对应包的文件夹层级
     注意,由于 Main 类位于 cc.openhome 包中,所以图 2.25 使用 java 执行程序时,必须指
定完全吻合名称,也就是指定 cc.openhome.Main 这个名称。

2.2.3      使用 import 偷懒
     使用包管理,解决了实体文档与撰写程序时类名称冲突的问题,但若每次撰写程序时,
都得输入完全吻合名称,却也是件麻烦的事。想想看,有些包定义的名称很长时,单是要
输入完全吻合名称得花多少时间。
    可以用 import 偷懒一下,如图 2.26 所示。
                                 图 2.26 使用 import 减少打字麻烦
     编译与执行时的指令方式与图 2.25 相同。当编译程序剖析 Main.java 看到 import 声明
时,会先记得 import 的名称,后续剖析程序时,若看到 Console 名称,原本会不知道 Console
是什么东西,但编译程序记得你用 import 告诉过它,如果遇到不认识的名称,可以比对一
下 import 过的名称,编译程序试着使用 cc.openhome.util.Console,结果可以在指定的类路
径中,cc/openhome/util 文件夹下找到 Console.class,于是可以进行编译。
     所以 import 只是告诉编译程序,遇到不认识的类名称,可以尝试使用 import 过的名称,
import 让你少打一些字,让编译程序多为你做一些事。
     如果同一包下会使用到多个类,你也许会多次使用 import:
     import cc.openhome.Message;
     import cc.openhome.User;
     import cc.openhome.Address;
     可以更偷懒一些,用以下的 import 语句:
     import cc.openhome.*;
     图 2.26 也可以使用以下的 import 语句,而编译与执行结果相同:
     import cc.openhome.util.*;
     当编译程序剖析 Main.java 看到 import 的声明时,会先记得有 cc.openhome.util 包名
称,在后续剖析到 Console 名称时,发现它不认识 Console 是什么东西,但编译程序记得你
用 import 告诉过它。若遇到不认识的名称,可以比对一下 import 过的名称,编译程序试着
将 cc.openhome.util 与 Console 结合为 cc.openhome.util.Console,结果可以在指定的类路径
中,cc/openhome/util 文件夹下找到 Console.class,于是可以进行编译。
     偷懒也是有个限度,如果自己写了一个 Arrays:
     package cc.openhome;
     public class Arrays {
                                                                        37
         ...
     }
     若在某个类中撰写有以下的程序代码:
     import cc.openhome.*;
     import java.util.*;
     public class Some {
         public static void main(String[] args) {
             Arrays arrays;
                  ...
        }
     }
     那么编译时,会发现有图 2.27 所示的错误信息。
                                   图 2.27 到底是用哪个 Arrays?
     当编译程序剖析 Some.java 看到 import 的声明时,会先记得有 cc.openhome 包名称,
在继续剖析至 Arrays 该行时,            发现它不认识 Arrays 是什么东西,       但编译程序记得你用 import
告诉过他。若遇到不认识的名称,可以比对 import 过的名称,编译程序试着将 cc.openhome
与 Arrays 结合在一起为 cc.openhome.Arrays,结果可以在类路径中,cc/openhome 文件夹
下找到 Arrays.class。
     然而,编译程序试着将 java.util 与 Arrays 结合在一起为 java.util.Arrays,发现也可
以在 Java SE API 的 rt.jar 中(默认的类加载路径之一,参考图 2.21),对应的 java/util 文件
夹中找到 Arrays.class ,于是编译程序困惑了,到底该使用 cc.openhome.Arrays 还是
java.util.Arrays?
     遇到这种情况时,就不能偷懒了,要使用哪个类名称,就得明确地逐字打出来:
     import cc.openhome.*;
     import java.util.*;
     public class Some {
         public static void main(String[] args) {
38
                                                                              从 JDK 到 IDE  2
                                                                                             1
             cc.openhome.Arrays arrays;
             ...
        }
     }
     这个程序就可以通过编译了。简单地说,import 是偷懒工具,不能偷懒就回归最保守的
写法。
          学过 C/C++的读者请注意, import 跟#include 一点都不像,无论原始码中有无 import,
          编译过后的 .class 都是一样的,不会影响执行效能。 import 顶多只会让编译时的时间拉
          长一些而已。
     在 Java SE API 中有许多常用类,像是写第一个 Java 程序时使用的 System 类,其实
也有使用包管理,完整名称其实是 java.lang.System,在 java.lang 包下的类由于很常用,
不用撰写 import 也可以直接使用 class 定义的名称,这也就是为何不用如下撰写程序的原
因(写了当然也没关系,只是自找麻烦):
    java.lang.System.out.println("Hello!World!");
    如果类位于同一包,彼此使用并不需要 import,当编译程序看到一个没有包管理的类名
称,会先在同一包中寻找类,如果找到就使用,若没找到,再试着从 import 描述进行比对。
java.lang 可视为预设就有 import,没有写任何 import 描述时,也会试着比对 java.lang                             的组
合,看看是否能找到对应类。
          原始码文档或位码文档都可以使用 JAR 文档封装,在“命令提示符”模式下,可以使用
          JDK 的 jar 工具程序来制作 JAR 文档。可以参考以下文件:
          http://caterpillar.onlyfun.net/Gossip/JavaEssence/SourceClassInJAR.html
2.3       使用 IDE
     在开始使用包管理原始码文档与位码文档之后,必须建立与包对应的实体文件夹层
级,编译时必须正确指定-sourcepath、-cp 等自变量,执行程序时必须使用完全吻合名称,
这实在是很麻烦。可以考虑开始使用 IDE(Integrated Development Environment),由 IDE
代劳你一些原始码文档与位码文档等资源管理工作,提升你的效率。
          除了 IDE 之外,也可以考虑使用 Ant 或 Maven 等工具提高效率,可以参考以下文件中有
          关 Ant 或 Maven 的介绍:
          http://caterpillar.onlyfun.net/Gossip/JUnit/
2.3.1      IDE 项目管理基础
     在 Java 领域中,有为数不少的 IDE,其中有不少是优秀的开放原始码产品,最为人
熟知的 IDE 有 NetBeans、Eclipse、Intellij IDEA、JDeveloper 等,不同的 IDE 会有不同
                                                                                        39
的特色,但基本概念通常相同。最重要的是,只要你了解 JDK 与相关指令操作,就不容易
被特定的 IDE 给限制住。
     在本书中,将选择 NetBeans IDE 7 进行基本介绍,必要时提示 Eclipse 对应的功能,
选择 NetBeans 的原因在于,NetBeans 直接使用你安装的 JDK,而 IDE 上显示的编译错
误信息就是 JDK 实际显示的信息,这对初学者了解 JDK 与 IDE 功能对应有帮助。提示
Eclipse 对应功能的原因在于,               它有许多外挂(plugin)可以使用,       可让你打造属于自己的 IDE,
许多商业用 IDE 也多以 Eclipse 作为基础。
     可以到以下网址下载 NetBeans IDE,就本书范围而言,只要下载 Java SE 版本即可:
     http://netbeans.org/downloads/index.html
     对 于       Windows     用 户 , 可 以 直 接 使 用 光 盘 中              tools 文 件 夹 中 的
netbeans-7.0-ml-javase-windows.exe,双击可执行文件并同意授权后,出现图 2.28 所示
画面时,选择 JDK7 安装目录,之后逐步按照指示进行安装即可。
                               图 2.28 NetBeans IDE 直接使用你安装的 JDK
           Eclipse 的下载地址如下,对本书范围而言,只要下载 Eclipse IDE for Java Developers
           即可:
           http://www.eclipse.org/downloads/
           Eclipse 无须安装,只要安装有 JRE,将下载的文档解压缩后,单击其中的 eclipse 就可
           以运行。Eclipse 不使用 JDK 的开发工具,它有自己的 Java 开发工具(Java Development
           Tools,JDT),详细信息可参考:
           http://www.eclipse.org/jdt/
     在程序规模步入必须使用包管理之后,就等于初步开始了项目资源管理。在 IDE 中要
撰写程序,通常也是从建立项目开始。在 NetBeans 中,可以这样建立项目:
    (1) 选择“文件”|“新建项目”命令,在弹出的“新建项目”对话框的“类别”列表
中选择 Java,在“项目”列表中选择“Java 应用程序”,接着单击“下一步”按钮,如
图 2.29 所示。
40
                                                 从 JDK 到 IDE  2
                                                                1
                              图 2.29 新建项目
    (2) 在“项目名称”文本框中输入项目名称 Hello2,在“项目位置”文本框中输入
C:\workspace,注意,“项目文件夹”会保存至 C:\workspace\Hello2,如图 2.30 所示。
                         图 2.30 设置项目名称和位置
    (3) 在“创建主类”文本框中输入 cc.openhome.Main,这表示会有个 Main 类放在
cc.openhome 包,其中会自动建立 main()程序进入点方法,接着单击“完成”按钮建立项目。
     项目建立后,IDE 通常会提供默认的项目检查窗格,方便你检视一些项目资源。若是
NetBeans,会提供图 2.31 所示的“项目”窗格。
                     图 2.31 NetBeans IDE 的“项目”窗格
     在图 2.31 所示的“项目”窗格中,可以看到“源包”中包含 cc.openhome,其中放
置了 Main.java,这方便你以包为单位查看原始码文档,而在“库”中可看到使用了 JDK 1.7
                                                           41
中的一些 JAR 文档,你可以回顾图 2.20 中的 CLASSPATH,就有这些 JAR 文档。“库”
中出现的 JAR 文档,表示 IDE 管理的 CLASSPATH 会包括这些 JAR 文档。
    可以在 Main.java 中这样撰写,然后执行“运行”|“生成主项目”命令,这会要求
NetBeans 进行程序编译:
    System.out.println("Hello World");
    “任务”窗格提供方便的项目资源查看,但不等于实体文档管理,有的 IDE 必须自行
打开“资源管理器”来查看项目文件夹内容,NetBeans 则可以切换至“文件”窗格直接
查看实际文档管理,如图 2.32 所示。
                               图 2.32 NetBeans IDE 的“文件”窗格
    图 2.32 就是目前项目文件夹 C:\workspace\Hello2 的实体内容,就目前来说,可先注
意“文件”窗格中的 build/classes、dist 与 src 文件夹。build/classes 就是编译出来的位
码文档(所以也是执行时会用到的 CLASSPATH),当中会自动根据 package 定义名称分门别
类放置.class 文档,dist 文件夹就是封装了位码文档的 JAR 文档,src 文件夹就是原始码文
档,当中会自动根据 package 定义名称分门别类放置.java 文档。这一切都是 IDE 代劳,毕
竟 IDE 是生产(Productivity)工具。
    如果要使用 NetBeans 执行程序进入 main()的类,可右击 Main.java 文件,在弹出的
快捷菜单中选择“运行文件”命令,会有个“输出”窗格显示执行结果,如图 2.33 所示。
                               图 2.33 NetBeans IDE 的“输出”窗格
    在 IDE 中编辑程序代码,若出现红色虚线,通常表示那是导致编译错误的语法。如果
看到红色虚线千万别发愣,把光标移至红色虚线上,就会显示编译错误信息,如果是
42
                                                    从 JDK 到 IDE  2
                                                                   1
NetBeans,会直接显示 JDK 编译工具提供的错误信息。例如,图 2.34 所示是 Main.java
中,public class 定义的名称不等于 Main(主档名)而产生的编译错误与信息。
                       图 2.34 在 IDE 中,红色虚线通常表示编译错误
    对于一些编译错误,如果 IDE 够聪明,也许会提示一些改正方式。以 NetBeans 来说,
会出现一个小电灯炮图示,这时可以单击图标显示改正提示,看看是否有合用的选项,如
图 2.35 所示。
                              图 2.35 编译错误时的改正提示
    以图 2.35 为例,是因为编译程序不认得 Scanner 类,第一个选项是因为,编译程序发
现有个 java.util.Scanner 也许是你想要的,看你是不是要 import。你也可以看到,在另一
个包分类中,也有个 Scanner。另外,还有建立类的两个选项,编译程序有提示是好事,但
你还是要判断哪个选项才是你想要的,不是单击第一个选项就没事了。
                          图 2.36 Eclipse 编译错误时的改正提示
        Eclipse 有许多操作是类似的,不过 Eclipse 使用自己的 JDT,所以编译的错误信息不是
        JDK 提供的信息。图 2.36 显示了 Eclipse 的一些基本画面。
                                                              43
    以上简单解释了 CLASSPATH、JDK 工具使用、编译相关错误信息、包管理等概念,
对应到 IDE 中哪些操作或设定,其他的功能会在之后说明相关内容时,一并说明在 IDE 中
如果操作或设定。
2.3.2    使用了哪个 JRE
    因为各种原因,你的计算机中可能不只存在一套 JRE。可以试着搜索计算机中的文档,
例如在 Windows 中搜索 java.exe,可能会发现有多个 java.exe 文档,某些程度上,可以
将找到一个 java.exe 视作就是有一套 JRE。
    在安装好 JDK 后,如果选择一并安装 Public JRE,至少会有两套 JRE 存在计算机中,
一个是 JDK 本身的 Private JRE,一个是选择安装的 Public JRE。
    既然计算机中有可能同时存在多套 JRE,那么你到底执行了哪一套 JRE?在文本模式
下 输 入 java 指 令 , 如 果 设 定 了 PATH , 会 执 行 PATH 顺 序 下 找 到 的
第一个 java 可执行文件,这个可执行文件所启动的是哪套 JRE?
    当找到 java 可执行文件并执行时,会依照以下规则来寻找可用的 JRE:
     可否在 java 可执行文件的文件夹下找到相关原生(Native)链接库。
     可否在上一层目录中找到 jre 目录。
    如果设定 PATH 包括 JDK 的 bin 目录,执行 java 指令时,因为在 JDK 的 bin 中找不
到相关原生链接库,因此找上一层文件夹的 jre 文件夹中有无原生链接库,于是找到的是
JDK 的 Private JRE。
    如果将 PATH 设定包括 C:\Program Files\Java\jre7\bin,则执行 java 指令时,因为同
一文件夹下可以找到相关原生链接库,于是就使用 C:\Program Files\Java\jre7\这个 Public
JRE。
    在执行 java 指令时,可以附带一个-version 自变量,这可以显示执行的 JRE 版本,这
是确认所执行 JRE 版本的一个方式,如图 2.37 所示。
                        图 2.37 使用-version 确认版本
    在刚到一个新开发环境时(例如到客户那边去时),先确认版本是很重要的一件事。文
本模式下若要确认 JRE,可先检查 PATH 路径中的顺序,再查看 java -version 的信息,这
些都是基本的检查动作。
44
                                                                      从 JDK 到 IDE    2
                                                                                       1
    如果有个需求是切换 JRE,文本模式下必须设定 PATH 顺序中,找到的第一个 JRE
之 bin 文件夹是你想要的 JRE,而不是设定 CLASSPATH。
   那么,如果使用 IDE 新建项目,你使用了哪个 JRE 呢?如果是 NetBeans,会以你安装
时设定的 JDK(参考图 2.28)中 Private JRE 为默认 JRE。在 NetBeans 中,如果想切换所使用
的 JDK(JRE),可以先新建 Java 平台。
   (1) 选择“工具”|“Java 平台”命令,打开“Java 平台管理器”对话框,单击“添加
平台”按钮。
   (2) 在打开的“添加 Java 平台”对话框中,选择想要的 JDK 目录,单击“下一步”
按钮。
   (3) 确认预设的“平台名称”、“平台源”和“平台 Javadoc”是你想要的设定值后,
单击“完成”按钮完成平台添加。
   (4) 在“Java 平台管理器”对话框中单击“关闭”按钮完成设定。
        如果是 Eclipse,可以执行 Windows | Preferences 命令,在 Preferences 对话框中选择
        Java | Installed JREs 选项,进行 JRE 版本的添加与新建项目时默认使用的 JRE,如图
        2.38 所示。
                                 图 2.38 在 Eclipse 中添加平台
   完成 Java 平台建立后,接下来可根据以下操作,改变项目想使用的 JDK(JRE)。
   (1) 在“项目”窗口中选择项目(如 Hello2),右击,在弹出的快捷菜单中选择“属性”
命令。
   (2) 打开“项目属性”对话框,选择“库”选项,在右边的“Java 平台”下拉列表框
中选择要使用的 JDK 版本后,单击“确定”按钮就完成设定。
   (3) 在“项目”窗口中的“库”选项下,已设定为你想要的 JDK 版本。
        在 Eclipse 中若有项目要改用别的 JRE,可以在项目上右击,在弹出的快捷菜单中选择
        Properties 命令,   在打开的 Properties 对话框中,    选择 Java Build Path 选项,选择 Libraries
        选项卡中的 JRE,单击 Edit 按钮,在 Alternate JRE 中选择要用的 JRE 版本,如图 2.39
        所示。
                                                                                  45
                               图 2.39 在 Eclipse 下改变项目的 JDK(JRE)
2.3.3     类文档版本
     如果使用新版本 JDK 编译出位码文档,在旧版本 JRE 上执行,有可能会发生图 2.40
所示的错误信息。
                                     图 2.40 不支持此版本
     图 2.40 所示是在 JDK7 下编译出位码,切换 PATH 至 JDK6,使用 Private JRE6 执
行位码,结果出现 UnsupportedClassVersionError,并指出这个位码的主版本号与次版本号
(major.minor)为 51.0。
     编译程序会在位码文档中标示主版本号与次版本号,不同的版本号,位码文件格式可
能有所不同。JVM 在加载位码文档后,会确认其版本号是否在可接受的范围,否则就不会
处理该位码文档。
     可以使用 JDK 工具程序 javap,确认位码文档的版本号,如图 2.41 所示。
     可以使 System.getProperty("java.class.version")取得 JRE 支持的位码版本号,使用
System.getProperty("java.runtime.version")取得    JRE 版本信息。
46
                                                                               从 JDK 到 IDE  2
                                                                                              1
                                   图 2.41 使用 javap 剖析位码文档
                    TM
      在 The Java       Virtual Machine Specification 中 The class File Format 说明了位码基本格式:
      http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html
      文件底 部的 注释 1 中指 出 ,Sun JDK 1.0.2 的 JVM 运行支 持的 位码 文档 版本 号 为
      45.0~45.3。1.1.X 支持 45.0~45.65535(向前兼容),Java 2 平台支持 45.0~46.0,Java SE
      5 与 6 支持 49.0~50.0,Java SE 7 则支持 51.0。
    在编译的时候,可以使用-target 指定编译出来的位码,必须符合指定平台允许的版本
号,使用-source 要求编译程序检查使用的语法,不超过指定的版本,如图 2.42 所示。
                                  图 2.42 指定-source 与-target 选项
    上面这个例子指定编译出来的位码文档必须是 1.6 平台可接受的版本号,并检查使用
语法必须是 1.6 语法。在不指定-target 与-source 的情况下,编译程序会有默认的-target
值。 例如,JDK7 默认的-target 与-source 都是 1.7,             -target 在指定时,      值必须大于或等于-source,
所以在图 2.42 中,若只指定-target 为 1.6,就会无法通过编译,因为-source 仍是默认值
1.7。
      JDK7 与 JDK6 相比,有语法上的新增,所以-source 默认为 1.7(-target 默认为 1.7)。
      JDK6(-target 默认为 1.6)与 JDK5(-target 默认为 1.5)则没有语法上的新增,所以-source
      都默认为 1.5。
                                                                                         47
    从图 2.42 中可看到,如果只指定-source 与-target 进行编译,会出现警示信息,这
是因为编译时默认的 Bootstrap 类加载器(Class loader),第 15 章会介绍 Bootstrap 类加
载器是什么。简单来说,系统默认的类加载器仍参考至 1.7 的 rt.jar(也就是 Java SE 7 API
的 JAR 文档),如果引用到一些旧版 JRE 没有的新 API,就会造成在旧版 JRE 上无法执
行,最好是编译时指定-bootclasspath,参考至旧版的 rt.jar,这样在旧版 JRE 执行时比较
不会发生问题。
    事实上,并非一定得切换 PATH 至较低版本的 JDK 或 JRE,才能测试具较低版本号
的类文档,如果已经安装有旧版 JDK 或 JRE,可以在执行时使用-version 自变量并指定版
本,如图 2.43 所示。
                          图 2.43 使用-version 指定执行版本
    图 2.43 中第一次编译时没有指定版本,也就是使用默认的 1.7 位码文档版本号,执行
时指定 1.6 版本就出现了 UnsupportedClassVersionError。第二次编译时指定编译为 1.6 位码
版本号,执行时指定 1.6 版本就没有问题。
    如果使用-version 指定的版本,实际上无法在系统上找到已安装的 JRE,则会出现图
2.44 所示的错误。
                     图 2.44 使用-version 指定时无法找到对应版本
    那么在 IDE 中如何设定-source 与-target 对应的选项呢?不同版本 IDE 中建立的项目,
默认的-source 与-target 选项并不相同。以 NetBeans 7.0 为例,如果默认使用 JDK6 的
-source 与-target,要想改变为 JDK7,可以在项目上右击,在弹出的快捷菜单中选择“属
性”命令,打开“项目属性”对话框,在“类别”列表中选择“源”,在“源代码/二进制
格式”列表框中选择 JDK7,如图 2.45 所示。
48
                                                                       从 JDK 到 IDE  2
                                                                                      1
                          图 2.45 NetBeans 中设定 JDK 的-source 与-target
        如果是 Eclipse,则可以在项目上右击,在弹出的快捷菜单中选择 Properties 命令,在 Java
        Compiler 中进行设定,如图 2.46 所示。
                              图 2.46 Eclipse 中设定 JDK 的-source 与-target
2.4     重点复习
   在正式撰写程序之前,请先确定你可以看到文档的扩展名。撰写 Java 程序时有几点
必须注意:
      扩展名是.java。
      主文档名与类名称必须相同。
      注意每个字母大小写。
      空格只能是半角空格符或 Tab 字符。
   一个.java 文档可定义多个类,但是只能有一个公开(public)类,而且主文档名必须与
公开类名称相同。规格书中规定 main()方法的形式一定得是:
   public static void main(String[] args)
                                                                                 49
    当你输入一个指令而没有指定路径信息时,操作系统会依照 PATH 环境变量中设定的
路径顺序,依序寻找各路径下是否有这个指令。若系统中安装两个以上 JDK,Path 路径中
设定的顺序,将决定执行哪个 JDK 下的工具程序,在安装了多个 JDK 或 JRE 的计算机中,
确定执行了哪个版本的 JDK 或 JRE 非常重要,确定 PATH 信息是一定要做的动作。
    在 JVM 中执行某个可执行文件(.class),就要告诉 JVM 这个虚拟操作系统到哪些路径
下寻找文档,方式是通过 CLASSPATH 指定可执行文件(.class)的路径信息。在启动 JVM
时要告知可执行文件(.class)的位置,可以使用-classpath 或-cp 自变量来指定。有的时候,
希望也从目前文件夹开始寻找类文档,则可以使用“.”指定。
    JAR 文档实际使用 ZIP 格式压缩,当中包含一堆.class 文档,设定 CLASSPATH 时可
将 JAR 文档当作特别的文件夹。如果某个文件夹中有许多.jar 文档,从 Java SE 6 开始,
可以使用“*”表示使用文件夹中所有.jar 文档。
    在使用 javac 编译程序时,如果要使用到其他类链接库时,也必须使用-cp 指定
CLASSPATH,使用-sourcepath 指定寻找原始码文档的文件夹,使用-d 指定编译完成的
位码存放文件夹,指定-verbose 自变量可看到编译程序进行编译时的过程。
    当类原始码开始使用 package 进行分类时,就会具有以下管理上的意义:
       原始码文档要放置在与 package 所定义名称层级相同的文件夹层级。
       package  所定义名称与 class 所定义名称,会结合而成类的完全吻合名称(Fully
        qualified name)。
       位码文档要放置在与 package 所定义名称层级相同的文件夹层级。
       要在包间可以直接使用的类或方法(Method)必须声明为 public。
       import 只是偷懒工具,让你在原始码中不用使用完全吻合名称。
    当找到 java 可执行文件并执行时,会依照以下规则来寻找可用的 JRE:
       可否在 java 可执行文件文件夹下找到相关原生(Native)链接库。
       可否在上一层目录中找到 jre 目录。
    在执行 java 指令时,可以附带一个-version 自变量显示执行的 JRE 版本。在编译的时
候, 可以使用-target 指定编译出来的位码,                  必须符合指定平台所允许的版本号,使用-source
要求编译程序检查使用的语法,不超过指定的版本。JDK7 默认的-target 与-source 都是
1.7,-target 在指定时,值必须大于或等于-source。
2.5      课后练习
   1. 如果在 hello.java 中撰写以下程序代码:
      public class Hello {
           public static void main(String[] args) {
               System.out.println("Hello World");
           }
      }
50
                                                             从 JDK 到 IDE      2
                                                                                1
以下描述正确的是(               )。
   A. 执行时显示 Hello World                         B. 执行时出现 NoClassDefFoundError
   C. 执行时出现找不到主要方法的错误                           D. 编译失败
2. 如果在 Main.java 中撰写以下程序代码:
   public class Main {
        public static main(String[] args) {
            System.out.println("Hello World");
        }
    }
以下描述正确的是(               )。
   A. 执行时显示 Hello World                         B. 执行时出现 NoClassDefFoundError
   C. 执行时出现找不到主要方法的错误                           D. 编译失败
3. 如果在 Main.java 中撰写以下程序代码:
   public class Main {
       public static void main() {
            System.out.println("Hello World");
       }
   }
以下描述正确的是(               )。
   A. 执行时显示 Hello World                         B. 执行时出现 NoClassDefFoundError
   C. 执行时出现找不到主要方法的错误                           D. 编译失败
4. 如果在 Main.java 中撰写以下程序代码:
   public class Main {
       public static void main(string[] args) {
            System.out.println("Hello World");
       }
   }
以下描述正确的是(               )。
   A. 执行时显示 Hello World                         B. 执行时出现 NoClassDefFoundError
   C. 执行时出现找不到主要方法的错误                           D. 编译失败
5. 如果 C:\workspace\Hello\classes 中有以下原始码编译而成的 Main.class:
   public class Main {
       public static void main(String[] args) {
            System.out.println("Hello World");
       }
   }
                                                                           51
    “命令行提示符”模式下你的工作路径是 C:\workspace,那么执行 Main 类正确的是
(  )。
       A. java C:\workspace\Hello\classes\Main       B. java Hello\classes Main
       C. java –cp Hello\classes Main                D. 以上皆非
    6. 如果 C:\workspace\Hello\classes 中有以下原始码编译而成的 Main.class:
       package cc.openhome;
       public class Main {
            public static void main(String[] args) {
                System.out.println("Hello World");
            }
       }
    “命令行提示符”模式下你的工作路径是 C:\workspace,那么执行 Main 类正确的是
(  )。
       A. java C:\workspace\Hello\classes\Main       B. java Hello\classes Main
       C. java –cp Hello\classes Main                D. 以上皆非
    7. 如果有个 Console 类的原始码开头定义如下:
       package cc.openhome;
       public class Console {
           ...
       }
    其完全吻合名称的是(                )。
       A. cc.openhome.Console                        B. package.cc.openhome.Console
       C. cc.openhome.class.Console                  D. 以上皆非
    8. 如果 C:\workspace\Hello\src 中有 Main.java 如下:
       package cc.openhome;
       public class Main {
            public static void main(String[] args) {
                System.out.println("Hello World");
            }
       }
    “命令行提示符”模式下你的工作路径是 C:\workspace\Hello,那么编译与执行 Main
类正确的是(          )。
       A. javac src\Main.java                        B. javac –d classes src\Main.java
          java C:\workspace\Hello\classes\Main          java –cp classes Main
52
                                                                       从 JDK 到 IDE   2
                                                                                       1
   C. javac –d classes src\Main.java            D. javac –d classes src\Main.java
       java –cp classes cc.openhome.Main           java –cp classes/cc/openhome Main
9. 如果有个 Console 类的原始码开头定义如下:
   package cc.openhome;
   public class Console {
       ...
   }
在另一个类中撰写 import 正确的是(                    )。
     A. import cc.openhome.Console;  B. import cc.openhome;
     C. import cc.openhome.*;        D. import Console;
10. 关于包以下描述正确的是(                   )。
    A. 要使用 Java SE API 的 System 类必须 import java.lang.System;
    B. 在程序中撰写 import java.lang.System;会发生编译错误,因为 java.lang 中的类不
        用 import
    C. import 并不影响执行效能
    D. 程序中撰写了 import cc.openhome.Main,执行 java 指令时只要下 java Main 就可
        以了
                                                                                  53
                  继承与多态 6
学习目标
 了解继承的目的
 了解继承与多态的关系
 知道如何重新定义方法
 认识 java.lang.Object
 简介垃圾收集机制
6.1       何谓继承
    面向对象中,子类继承(Inherit)父类,避免重复的行为定义,不过并非为了避免重复定
义行为就使用继承,滥用继承而导致程序维护上的问题时有所闻。如何正确判断使用继承
的时机,以及继承之后如何活用多态,才是学习继承时的重点。
6.1.1     继承共同行为
    继承基本上就是避免多个类间重复定义共同行为。以实际的例子来说明比较清楚,假
设你正在开发一款 RPG(Role-playing game)游戏,一开始设定的角色有剑士与魔法师。首
先你定义了剑士类:
    public class SwordsMan {
        private String name;   // 角色名称
        private int level;     // 角色等级
        private int blood;     // 角色血量
        public void fight() {
            System.out.println("挥剑攻击");
        }
        public int getBlood() {
            return blood;
        }
        public void setBlood(int blood) {
            this.blood = blood;
        }
        public int getLevel() {
            return level;
        }
        public void setLevel(int level) {
            this.level = level;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
    接着你为魔法师定义类:
162
                                                                6
                                                       继承与多态
     public class Magician {
         private String name;   // 角色名称
         private int level;     // 角色等级
         private int blood;     // 角色血量
         public void fight() {
             System.out.println("魔法攻击");
         }
         public void cure() {
             System.out.println("魔法治疗");
         }
         public int getBlood() {
             return blood;
         }
         public void setBlood(int blood) {
             this.blood = blood;
             }
             public int getLevel() {
                 return level;
             }
             public void setLevel(int level) {
                 this.level = level;
             }
             public String getName() {
                 return name;
             }
             public void setName(String name) {
                 this.name = name;
             }
     }
     你注意到什么呢?因为只要是游戏中的角色,都会具有角色名称、等级与血量,类中
也都为名称、等级与血量定义了取值方法与设值方法,Magician 中粗体字部分与 SwordsMan
中相对应的程序代码重复了。重复在程序设计上,就是不好的信号。举个例子来说,如果要
将 name、level、blood 改为其他名称,那就要修改 SwordsMan 与 Magician 两个类,如果有更
多类具有重复的程序代码,那就要修改更多类,造成维护上的不便。
     如果要改进,就可以把相同的程序代码提升(Pull up)为父类:
 Game1 Role.java
package cc.openhome;
                                                            163
public class Role {
    private String name;
    private int level;
    private int blood;
    public int getBlood() {
        return blood;
    }
    public void setBlood(int blood) {
        this.blood = blood;
    }
    public int getLevel() {
        return level;
    }
    public void setLevel(int level) {
        this.level = level;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
     这个类在定义上没什么特别的新语法,只不过是将 SwordsMan 与 Magician 中重复的程序
代码复制过来。接着 SwordsMan 可以如下继承 Role:
  Game1 SwordsMan.java
package cc.openhome;
public class SwordsMan extends Role {
    public void fight() {
        System.out.println("挥剑攻击");
    }
}
     在这里看到了新的关键字 extends,这表示 SwordsMan 会扩充 Role 的行为,也就是继承
Role 的行为,再扩充 Role 原本没有的 fight()行为。从程序面上来说,Role 中有定义的程序
164
                                                                  6
                                                          继承与多态
代码,SwordsMan 中都继承而拥有了,并定义了 fight()方法的程序代码。类似地,Magician
也可以如下定义继承 Role 类:
  Game1 Magician.java
package cc.openhome;
public class Magician extends Role {
    public void fight() {
        System.out.println("魔法攻击");
    }
    public void cure() {
        System.out.println("魔法治疗");
    }
}
     Magician 继承 Role 的行为,再扩充了 Role 原本没有的 fight()与 cure()行为。
          在图 6.1 所示的这个类图中,第一格中 Role 表示类名称;第二格中 name、 level、blood
          表示数据成员;:号之后为各成员类型,-号表示 private;第三格表示方法名称,+号表示
          public,:号之后表示返回类型,继承则以空心箭头表示。
                                               图 6.1 类图
     如何看出确实有继承了呢?从以下简单的程序可以看出:
  Game1 RPG.java
package cc.openhome;
public class RPG {
    public static void main(String[] args) {
        SwordsMan swordsMan = new SwordsMan();
        swordsMan.setName("Justin");
                                                              165
       swordsMan.setLevel(1);
       swordsMan.setBlood(200);
       System.out.printf("剑士:(%s, %d, %d)%n", swordsMan.getName(),
               swordsMan.getLevel(), swordsMan.getBlood());
       Magician magician = new Magician();
       magician.setName("Monica");
       magician.setLevel(1);
       magician.setBlood(100);
       System.out.printf("魔法师:(%s, %d, %d)%n", magician.getName(),
               magician.getLevel(), magician.getBlood());
    }
}
    虽然 SwordsMan 与 Magician 并没有定义 getName()、getLevel()与 getBlood()等方法,但
从 Role 继承了这些方法,所以就如范例中可以直接使用。执行的结果如下:
    剑士:(Justin, 1, 200)
    魔法师:(Monica, 1, 100)
    继承的好处之一,就是若你要将 name 、level 、 blood 改为其他名称,那就只要修改
Role.java 就可以了,只要是继承 Role 的子类都无须修改。
          有的书籍或文件会说, private 成员无法继承,那是错的。如果 private 成员无法继承,
          那为什么上面的范例 name、level、blood 记录的值会显示出来呢?private 成员会被继承,只
          不过子类无法直接存取,必须通过父类提供的方法来存取(如果父类愿意提供访问方法的话)。
6.1.2     多态与 is-a
    在 Java 中,子类只能继承一个父类,继承除了可避免类间重复的行为定义外,还有个
重要的关系,那就是子类与父类间会有 is-a 的关系,中文称为“是一种”的关系,这是什
么意思?以前面范例来说,SwordsMan 继承了 Role,所以 SwordsMan 是一种 Role(SwordsMan is
a Role),Magician 继承了 Role,所以 Magician 是一种 Role(Magician is a Role)。
    为何要知道继承时,父类与子类间会有“是一种”的关系?因为要开始理解多态
(Polymorphism),必须先知道你操作的对象是“哪一种”东西。
    来看实际的例子,以下的代码段,相信你现在可以没有问题地看懂,而且知道可以通
过编译:
    SwordsMan swordsMan = new SwordsMan();
    Magician magician = new Magician();
    那你知道以下的程序片段也可以通过编译吗?
    Role role1 = new SwordsMan();
    Role role2 = new Magician();
    那你知道以下的程序片段为何无法通过编译呢?
166
                                                                                6
                                                                    继承与多态
   SwordsMan swordsMan = new Role();
   Magician magician = new Role();
   编译程序就是语法检查器,要知道以上程序片段为何可以通过编译,为何无法通过编
译,就是将自己当作编译程序,检查语法的逻辑是否正确,方式是从=号右边往左读:右边
是不是一种左边呢(右边类是不是左边类的子类)?如图 6.2 所示。
                                          是一种
                              图 6.2 运用 is a 关系判断语法正确性
   从右往左读,SwordsMan 是不是一种 Role 呢?是的,所以编译通过。Magician 是不是一
种 Role 呢?是的,所以编译通过。同样的判断方式,可以知道为何以下编译失败:
   SwordsMan swordsMan = new Role();   // Role 是不是一种 SwordsMan?
   Magician magician = new Role();     // Role 是不是一种 Magician?
   编译程序认为第一行,Role 不一定是一种 SwordsMan,所以编译失败,对于第二行,编
译程序认为 Role 不一定是一种 Magician,所以编译失败。继续把自己当成编译程序,再来
看看以下的程序片段是否可以通过编译:
   Role role1 = new SwordsMan();
   SwordsMan swordsMan = role1;
   这个程序片段最后会编译失败,先从第一行看,SwordsMan 是一种 Role,所以这行可以
通过编译。编译程序检查这类语法,一次只看一行,就第二行而言,编译程序看到 role1
为 Role 声明的名称,于是检查 Role 是不是一种 SwordsMan,答案是不一定,所以编译失败
在第二行。
   编译程序会检查父子类间的“是一种”关系,如果你不想要编译程序啰唆,可以叫它
住嘴:
   Role role1 = new SwordsMan();
   SwordsMan swordsMan = (SwordsMan) role1;
   对于第二行,原本编译程序想啰唆地告诉你,Role 不一定是一种 SwordsMan,但你加上
了(SwordsMan)让它住嘴了,因为这表示,你就是要让 Role 扮演(CAST)SwordsMan,既然你都
明确要求编译程序别啰唆了,编译程序就让这段程序代码通过编译了,不过后果得自行负责。
   以上面这个程序片段来说,                role1 确实参考至 SwordsMan 实例,      所以在第二行让 SwordsMan
实例扮演 SwordsMan 并没有什么问题,所以执行时期并不会出错,如图 6.3 所示。
                                                                            167
                                图 6.3 判断是否可扮演(CAST)成功
    以下的程序片段,编译可以成功,但执行时期会出错:
    Role role2 = new Magician();
    SwordsMan swordsMan = (SwordsMan) role2;
    对于第一行,Magician 是一种 Role,可以通过编译,对于第二行,role2 为 Role 类型,
编译程序原本认定 Role 不一定是一种 SwordsMan 而想要啰唆,但是你明确告诉编译程序,
就是要让 Role 扮演为 SwordsMan,所以编译程序就让你通过编译了,不过后果自负。实际
上,role2 参考的是 Magician,你要让魔法师假扮为剑士,这在执行上会是个错误,JVM 会
抛出 java.lang.ClassCastException,如图 6.4 所示。
                     图 6.4 扮演(CAST)失败,执行时抛出 ClassCastException
    使用是一种(is-a)原则,就可以判断何时编译成功,何时编译失败,以及将扮演(CAST)
看做叫编译程序住嘴语法,并留意参考的对象实际类型,就可以判断何时扮演成功,何时
会抛出 ClassCastException。例如以下编译成功,执行也没问题:
    SwordsMan swordsMan = new SwordsMan();
    Role role = swordsMan;    // SwordsMan 是一种 Role
    以下程序片段会编译失败:
    SwordsMan swordsMan = new SwordsMan();
    Role role = swordsMan;         // SwordsMan 是一种 Role,这行通过编译
    SwordsMan swordsMan = role;   // Role 不一定是一种 SwordsMan,编译失败
    以下程序片段编译成功,执行时也没问题:
    SwordsMan swordsMan = new SwordsMan();
    Role role = swordsMan;      // SwordsMan 是一种 Role,这行通过编译
    // 你告诉编译程序要让 Role 扮演 SwordsMan,以下这行通过编译
    SwordsMan swordsMan = (SwordsMan) role;  // role 参考 SwordsMan 实例,执行成功
    以下程序片段编译成功,但执行时抛出 ClassCastException:
    SwordsMan swordsMan = new SwordsMan();
    Role role = swordsMan;     // SwordsMan 是一种 Role,这行通过编译
168
                                                                              6
                                                                      继承与多态
     // 你告诉编译程序要让 Role 扮演 Magician,以下这行通过编译
     Magician magician = (Magician) role; // role 参考 Magician 实例,执行失败
     经过以上这一连串的语法测试,好像只是在玩弄语法,不!你懂不懂以上这些东西,
将牵涉写出来的东西有没有弹性、好不好维护的问题。
     有这么严重吗?来出个题目给你吧。请设计 static 方法,显示所有角色的血量。OK!
上一章刚学过如何定义方法,有的人会撰写以下的方法定义:
     public static void showBlood(SwordsMan swordsMan) {
         System.out.printf("%s 血量 %d%n",
                swordsMan.getName(), swordsMan.getBlood());
     }
     public static void showBlood(Magician magician) {
         System.out.printf("%s 血量 %d%n",
                magician.getName(), magician.getBlood());
     }
     分别为 SwordsMan 与 Magician 设计 showBlood()同名方法,这是重载方法的运用,如此
就可以如下调用:
     showBlood(swordsMan);     // swordsMan 是 SwordsMan 类型
     showBlood(magician);      // magician 是 Magician 类型
     现在的问题是,目前你的游戏中是只有 SwordsMan 与 Magician 两个角色,如果有 100
个角色呢?重载出 100 个方法?这种方式显然不可能。如果所有角色都是继承自 Role,而
且你知道这些角色都是一种 Role,你就可以如下设计方法并调用:
 Game2 RPG.java
package cc.openhome;
public class RPG {
    public static void showBlood(Role role) {            声明为 Role 类
        System.out.printf("%s 血量 %d%n",
                 role.getName(), role.getBlood());
    }
    public static void main(String[] args) {
        SwordsMan swordsMan = new SwordsMan();
        swordsMan.setName("Justin");
        swordsMan.setLevel(1);
        swordsMan.setBlood(200);
        Magician magician = new Magician();
        magician.setName("Monica");
        magician.setLevel(1);
        magician.setBlood(100);
                                                                          169
         showBlood(swordsMan);       SwordsMan 是一种 Role
         showBlood(magician);        magician 是一种 Role
    }
}
     在这里仅定义了一个 showBlood()方法,              参数声明为 Role 类型。
                                                         第一次调用 showBlood()
时传入了 SwordsMan 实例,这是合法的语法,因为 SwordsMan 是一种 Role。第一次调用
showBlood()时传入了 Magician 实例也是可行,因为 Magician 是一种 Role       。执行的结果如下:
     Justin 血量 200
     Monica 血量 100
     这样的写法好处为何?就算有 100 种角色,只要它们都是继承 Role,都可以使用这个
方法显示角色的血量,而不需要像前面重载的方式,为不同角色写 100 个方法,多态的写
法显然具有更高的可维护性。
     什么叫多态?以抽象讲法解释,就是使用单一接口操作多种类型的对象。若用以上的范
例来理解,在 showBlood()方法中,既可以通过 Role 类型操作 SwordsMan 对象,也可以通过
Role 类型操作 Magician 对象。
           稍后会学到 Java 中 interface 的使用,在多态定义中,使用单一接口操作多种类型的对
           象,这里的接口并不是专指 Java 中的 interface,而是指对象上可操作的方法。
6.1.3       重新定义行为
     现在有个需求,请设计 static()方法,可以播放角色攻击动画。你也许会这么想,学
刚刚学过的多态的写法,设计个 drawFight()方法如何?如图 6.5 所示。
                               图 6.5 Role 没有定义 fight()方法
     对 drawFight()方法而言,只知道传进来的会是一种 Role 对象,所以编译程序也只能检
查你调用的方法,Role 是不是有定义,显然地,Role 目前并没有定义 fight()方法,因此编
译错误。
     然而仔细观察一下 SwordsMan 与 Magician 的 fight() 方法,它们的方法签署(method
signature)都是:
     public void fight()
     也就是说,操作接口是相同的,只是方法操作内容不同。可以将 fight()方法提升至 Role
类中定义:
170
                                                        6
                                              继承与多态
  Game3 Role.java
package cc.openhome;
public class Role {
    ...
    public void fight() {
        // 子类要重新定义 fight()的实际行为
    }
}
     在 Role 类中定义了 fight()方法,由于实际上角色如何攻击,只有子类才知道,所以
这里的 fight()方法内容是空的,没有任何程序代码执行。SwordsMan 继承 Role 之后,再对
fight()的行为进行定义:
  Game3 SwordsMan.java
package cc.openhome;
public class SwordsMan extends Role {
    public void fight() {
        System.out.println("挥剑攻击");
    }
}
     在继承父类之后,定义与父类中相同的方法部署,但执行内容不同,这称为重新定义
(Override)。因为对父类中已定义的方法执行不满意,所以在子类中重新定义执行。Magician
继承 Role 之后,也重新定义了 fight()的行为:
  Game3 Magician.java
package cc.openhome;
public class Magician extends Role {
    public void fight() {
        System.out.println("魔法攻击");
    }
    ...
}
     由于 Role 现在定义了 fight()方法(虽然方法区块中没有程序代码运行),所以编译程序
不会找不到 Role 的 fight(),因此可以如下撰写:
  Game3 RPG.java
package cc.openhome;
public class RPG {
                                                    171
    public static void drawFight(Role role) {
                                                   声明为 Role 类型
        System.out.print(role.getName());
        role.fight();
    }
    public static void main(String[] args) {
        SwordsMan swordsMan = new SwordsMan();
        swordsMan.setName("Justin");
        swordsMan.setLevel(1);
        swordsMan.setBlood(200);
        Magician magician = new Magician();
        magician.setName("Monica");
        magician.setLevel(1);
        magician.setBlood(100);
        drawFight(swordsMan);         实际操作的是 SwordsMan 实例
        drawFight(magician);          实际操作的是 Magician 实例
    }
}
     在 fight()方法声明了 Role 类型的参数,那方法中调用的,到底是 Role 中定义的
fight(),还是个别子类中定义的 fight()呢?如果传入 fight()的是 SwordsMan,role 参数参
考的就是 SwordsMan 实例,操作的就是 SwordsMan 上的方法定义,如图 6.6 所示。
                                                           挥剑攻击
                              图 6.6 role 牌子挂在 SwordsMan 实例
     这就好比 role 牌子挂在 SwordsMan 实例身上,你要求有 role 牌子的对象攻击,发动攻
击的对象就是 SwordsMan 实例。同样地,如果传入 fight()的是 Magician,role 参数参考的
就是 Magician 实例,操作的就是 Magician 上的方法定义,如图 6.7 所示。
                                                            "魔法攻击"
                               图 6.7 role 牌子挂在 Magician 实例
     所以范例最后的执行结果是:
172
                                                                     6
                                                         继承与多态
     Justin 挥剑攻击
     Monica 魔法攻击
     在重新定义父类中某个方法时,子类必须撰写与父类方法中相同的签署,然而如果疏
忽打错字了:
     public class SwordsMan extends Role {
         public void Fight() {
             System.out.println("挥剑攻击");
         }
     }
     以这里的例子来说,父类中定义的是 fight(),但子类中定义了 Fight(),这就不是重
新定义 fight()了,而是子类新定义了一个 Fight()方法。这是合法的方法定义,编译程序
并不会发出任何错误信息,你只会在运行范例时,发现为什么 SwordsMan 完全没有攻击。
     在 JDK5 之后支持标注(Annotation),其中一个内建的标准标注就是@Override,如果在
子类中某个方法前标注@Override,表示要求编译程序检查,该方法是不是真的重新定义了
父类中某个方法,如果不是的话,就会引发编译错误,如图 6.8 所示。
                          图 6.8 编译程序检查是否真的重新定义父类某方法
     如果要重新定义某方法,加上@Override,就不用担心打错字的问题了。关于标注详细
语法,会在第 16 章说明。
6.1.4       抽象方法、抽象类
     上一个范例中 Role 类的定义中,fight()方法区块中实际上没有撰写任何程序代码,虽
然满足了多态需求,            但会引发的问题是,           你没有任何方式强迫或提示子类一定要操作 fight()
方法,只能口头或在文件上告知,不过如果有人没有传达到、没有看文件或文件看漏了呢?
     如果某方法区块中真的没有任何程序代码操作,可以使用 abstract 标示该方法为抽象
方法(Abstract method),该方法不用撰写{}区块,直接“;”结束即可。例如:
  Game4 Role.java
package cc.openhome;
public abstract class Role {
    ...
    public abstract void fight();
}
                                                                173
    类中若有方法没有操作,并且标示为 abstract,表示这个类定义不完整,定义不完整的
类就不能用来生成实例,这就好比设计图不完整,不能用来生产成品一样。Java 中规定内含
抽象方法的类,一定要在 class 前标示 abstract,如上例所示,它表示这是一个定义不完整
的抽象类(Abstract class)。如果尝试用抽象类创建实例,就会引发编译错误,如图 6.9 所示。
                                    图 6.9 不能实例化抽象类
    子类如果继承抽象类,对于抽象方法有两种做法,一种做法是继续标示该方法为
abstract(该子类因此也是个抽象类,必须在 class                      前标示 abstract);另一种做法就是操作
抽象方法。如果两种做法都没有实施,就会引发编译错误,如图 6.10 所示。
                                   图 6.10 没有操作抽象方法
6.2      继承语法细节
    上一节介绍了继承的基础概念与语法,然而结合 Java 的特性,继承还有许多细节必须
明了,像是哪些成员可以限定在子类中使用、哪些方法签署算重新定义、Java 中所有对象
都是一种 java.lang.Object 等细节,这将在本节中详细说明。
6.2.1     protected 成员
    就上一节的 RPG 游戏来说,如果建立了一个角色,想显示角色的细节,则必须这样
撰写:
    SwordsMan swordsMan = new SwordsMan();
    ...
    System.out.printf("剑士 (%s, %d, %d)%n", swordsMan.getName(),
            swordsMan.getLevel(), swordsMan.getBlood());
    Magician magician = new Magician();
    ...
    System.out.printf("魔法师 (%s, %d, %d)%n", magician.getName(),
            magician.getLevel(), magician.getBlood());
    这对使用 SwordsMan 或 Magician 的客户端有点不方便,                  如果可以在 SwordsMan 或 Magician
上定义 toString()方法,返回角色的字符串描述:
    public class SwordsMan extends Role {
        ...
        public String toString() {
            return String.format("剑士 (%s, %d, %d)", this.getName(),
174
                                                                              6
                                                                      继承与多态
                     this.getLevel(), this.getBlood());
         }
     }
     public class Magician extends Role {
         ...
         public String toString() {
             return String.format("魔法师 (%s, %d, %d)", this.getName(),
                     this.getLevel(), this.getBlood());
         }
     }
     客户端就可以这样撰写:
     SwordsMan swordsMan = new SwordsMan();
     ...
     System.out.println(swordsMan.toString());
     Magician magician = new Magician();
     ...
     System.out.printf(magician.toString());
     看来客户端简洁许多。不过你定义的 toString()在取得名称、等级与血量时不是很方
便,因为 Role 中的 name、level 与 blood 被定义为 private,所以无法直接在子类中存取,
只能通过 getName()、getLevel()、getBlood()来取得。
     将 Role 中的 name、level 与 blood 定义为 public,这又会完全开放 name、level 与 blood
访问权限,你并不想这么做。只想让子类可以直接存取 name、level 与 blood 的话,可以定
义它们为 protected:
  Game5 Role.java
package cc.openhome;
public abstract class Role {
    protected String name;
    protected int level;
    protected int blood;
    ...
}
     被声明为 protected 的成员,相同包中的类可以直接存取,不同包中的类可以在继承后
的子类直接存取。现在你的 SwordsMan 可以这样定义 toString():
  Game5 SwordsMan.java
package cc.openhome;
public class SwordsMan extends Role {
    ...
                                                                          175
    public String toString() {
        return String.format("剑士 (%s, %d, %d)", this.name,
                this.level, this.blood);
    }
}
     Magician 也可以这样撰写:
  Game5 Magician.java
package cc.openhome;
public class Magician extends Role {
    ...
    public String toString() {
        return String.format("魔法师 (%s, %d, %d)", this.name,
                this.level, this.blood);
    }
}
           如果方法中没有同名参数,this 可以省略,不过基于程序可读性,多打个 this 会比较清楚。
     到这里为止,Java 中三个权限关键字你都看到了,也就是 public、protected 与 private。
虽然只有三个权限关键字,但实际上有四个权限范围,因为没有定义权限关键字,默认就
是包范围。权限关键字与权限范围的关系,如表 6.1 所示。
                                    表 6.1 权限关键字与范围
        关 键 字                  类 内 部                相 同 包 类   不 同 包 类
   public                可存取                    可存取         可存取
   protected             可存取                    可存取         子类可存取
   无                     可存取                    可存取         不可存取
   private               可存取                    不可存取        不可存取
           简单来说,依权限小至大来区分,就是 private、无关键字、 protected 与 public,设计
           时要使用哪个权限,是依经验或团队讨论而定,如果一开始不知道使用哪个权限,就先使
           用 private,以后视需求再放开权限。
6.2.2      重新定义的细节
     在 6.1.3 节已看过何谓重新定义方法与实例,有时候重新定义方法时,并非完全不满
意父类中的方法,只是希望在执行父类中方法的前、后做点加工。例如,也许 Role 类中原
本就定义了 toString()方法:
176
                                                                  6
                                                        继承与多态
  Game6 Role.java
package cc.openhome;
public abstract class Role {
    ...
    public String toString() {
        return String.format("(%s, %d, %d)", this.name,
                this.level, this.blood);
    }
}
     如果在 SwordsMan 子类中重新定义 toString()的内容时,可以执行 Role 中的 toString()
方法取得字符串结果,再连接“剑士”字样,不就是你想要的描述了吗?在 Java 中,如
果想取得父类中的方法定义,可以在调用方法前,加上 super 关键字。例如:
  Game6 SwordsMan.java
package cc.openhome;
public class SwordsMan extends Role {
    ...
    @Override
    public String toString() {
        return "剑士 " + super.toString();
    }
}
     类似地,Magician 在重新定义 toString()时,也可以如法炮制:
  Game6 Magician.java
package cc.openhome;
public class Magician extends Role {
    ...
    @Override
    public String toString() {
        return "魔法师 " + super.toString();
    }
}
     可以使用 super 关键字调用的父类方法,不能定义为 private(因为这就限定只能在类内
使用)。
     重新定义方法要注意,对于父类中的方法权限,只能扩大但不能缩小。若原来成员 public,
子类中重新定义时不可为 private 或 protected,如图 6.11 所示。
                                                              177
                               图 6.11 重新定义时不能缩小方法权限
    在 JDK5 之前,重新定义方法时除了可以定义权限较大的关键字外,其他部分必须与
父类中方法签署完全一致。例如,原先设计了一个 Bird 类:
    public class Bird {
        protected String name;
        public Bird(String name) {
            this.name = name;
        }
        public Bird copy() {
            return new Bird(name);
        }
    }
    原先 copy()返回了 Bird 类型,如果 Chicken 继承 Bird,打算让 copy()方法返回 Chicken,
那么在 JDK5 之前会发生编译错误,如图 6.12 所示。
                      图 6.12 JDK5 之前重新定义方法时,返回类型也必须一致
    在 JDK5 之后,重新定义方法时,如果返回类型是父类中方法返回类型的子类,也是可以
通过编译的。图 6.12 所示的例子,在 JDK5 中并不会出现编译错误。
          static 方法属于类拥有,如果子类中定义了相同签署的 static 成员,该成员属于子类所
          有,而非重新定义, static 方法也没有多态,因为对象不会个别拥有 static 成员。
6.2.3      再看构造函数
    如果类有继承关系,在创建子类实例后,会先进行父类定义的初始流程,再进行子类
中定义的初始流程,也就是创建子类实例后,会先执行父类构造函数定义的流程,再执行
子类构造函数定义的流程。
    构造函数可以重载,父类中可重载多个构造函数,如果子类构造函数中没有指定执行
父类中哪个构造函数,默认会调用父类中无参数构造函数。如果这样撰写程序:
    class Some {
        Some() {
            System.out.println("调用 Some()");
        }
178
                                                          6
                                                继承与多态
  }
  class Other extends Some {
      Other() {
          System.out.println("调用 Other()");
      }
  }
  如果尝试 new Other(),看来好像是先执行 Some()中的流程,再执行 Other()中的流程,
也就是先显示"调用 Some()",再显示"调用 Other()"。很奇怪是吧!先继续往下看,就知道
为什么了。如果想执行父类中某构造函数,可以使用 super()指定。例如:
  class Some {
      Some() {
          System.out.println("调用 Some()");
      }
      Some(int i) {
          System.out.println("调用 Some(int i)");
      }
  }
  class Other extends Some {
      Other() {
          super(10);
          System.out.println("调用 Other()");
      }
  }
  在这个例子中,new Other()时,先调用了 Other()版本的构造函数,super(10)表示调用
父类构造函数时传入 int 数值 10,因此就是调用了父类中 Some(int i)版本的构造函数,而
后再继续 Other()中 super(10)之后的流程。其实当你这么撰写时:
  class Some {
      Some() {
          System.out.println("调用 Some()");
      }
  }
  class Other extends Some {
      Other() {
          System.out.println("调用 Other()");
      }
  }
  前面谈过,如果子类构造函数中没有指定执行父类中哪个构造函数,默认会调用父类
中无参数构造函数,也就是等于你这么撰写:
  class Some {
      Some() {
          System.out.println("调用 Some()");
      }
                                                      179
    }
    class Other extends Some {
        Other() {
            super();
            System.out.println("调用 Other()");
        }
    }
    所以执行 new Other()时,是先执行 Other()中的流程,而 Other()中指定调用父类无参
数构造函数,而后再执行 super()之后的流程。
          this()与 super()只能择一调用,而且一定要在构造函数第一行执行。
    那么你知道图 6.13 为什么会编译错误吗?
                                  图 6.13 找不到构造函数?
    5.2.2 节谈过,编译程序会在你没有撰写任何构造函数时,自动加入没有参数的默认构
造函数(Default constructor),如果自行定义了构造函数,就不会自动加入任何构造函数了。
在图 6.13 中,    Some 定义了有参数的构造函数,              所以编译程序不会再加入默认构造函数,Other
的构造函数中没有指定调用父类中哪个构造函数,                         那就是默认调用父类中无参数构造函数,
但父类中现在哪来的无参数构造函数呢?因此编译失败了。
          因此 5.2.3 节提示过一次,有些场合建议,如果定义了有参数的构造函数,也可以加入无
          参数构造函数,即使内容为空也无所谓,这是为了日后使用上的弹性。例如,运用反射
          (Reflection)机制生成对象的需求,或者继承时调用父类构造函数时的方便。
6.2.4      再看 final 关键字
    在 3.1.2 节中谈过,如果在指定变量值之后,就不想再改变变量值,可以在声明变量
时加上 final 限定,如果后续撰写程序时,自己或别人不经意想修改 final 变量,就会出现
编译错误。
    在 5.2.4 节中也谈过,如果对象数据成员被声明为 final,但没有明确使用=指定值,
那表示延迟对象成员值的指定,在构造函数执行流程中,一定要有对该数据成员指定值的
动作,否则编译错误。
    class 前也可以加上 final 关键字,如果 class 前使用了 final 关键字定义,那么表示这
个类是最后一个了,不会再有子类,也就是不能被继承。有没有实际的例子呢?有的,String
180
                                                                     6
                                                         继承与多态
在定义时就限定为 final 了,这可以在 API 文件上得以验证,如图 6.14 所示。
                               图 6.14 String 是 final 类
   如果打算继承 final 类,则会发生编译错误,如图 6.15 所示。
                               图 6.15 不能继承 final 类
   定义方法时,也可以限定该方法为 final,这表示最后一次定义方法了,也就是子类不可
以重新定义 final 方法。        有没有实际的例子呢?有的,java.lang.Object 上有几个 final 方法,
如图 6.16 所示。
                          图 6.16 Object 类上的 final 方法之一
   如果尝试在继承父类后,重新定义 final 方法,则会发生编译错误,如图 6.17 所示。
                            图 6.17 不能重新定义 final 方法
         在 Java SE API 中会声明为 final 的类或方法,通常与 JVM 对象或操作系统资源管理有
         密切相关,因此不希望 API 用户继承或重新定义。
6.2.5     java.lang.Object
   在 Java 中,子类只能继承一个父类,如果定义类时没有使用 extends 关键字指定继承
任何类,那一定是继承 java.lang.Object。也就是说,如果这样定义类:
   public class Some {
      ...
                                                                 181
     }
     那就相当于撰写:
     public class Some extends Object {
        ...
     }
     因此在 Java 中,任何类追溯至最上层父类,一定就是 java.lang.Object,也就是 Java
中所有对象,一定“是一种”Object,所以这样撰写程序是合法的:
     Object o1 = "Justin";
     Object o2 = new Date();
     String 是一种 Object,Date 是一种 Object,任何类型的对象,都可以使用 Object 声明
的名称来参考。这有什么好处?如果有个需求是使用数组收集各种对象,那该声明为什么
类型呢?答案是 Object[]。例如:
     Object[] objs = {"Monica", new Date(), new SwordsMan()};
     String name = (String) objs[0];
     Date date = (Date) objs[1];
     SwordsMan swordsMan = (SwordsMan) objs[2];
     因为数组长度有限,使用数组来收集对象不是那么的方便,以下定义的 ArrayList 类,
可以不限长度的收集对象:
 Inheritance ArrayList.java
package cc.openhome;
import java.util.Arrays;
public class ArrayList {
    private Object[] list;          使用 Object 数组收集
    private int next;          下一个可储存对象的索引
    public ArrayList(int capacity) {          指定初始容量
         list = new Object[capacity];
    }
    public ArrayList() {
         this(16);         初始容量默认为 16
    }
    public void add(Object o) {          收集对象方法
         if(next == list.length) {         自动增长 Object 数组长度
             list = Arrays.copyOf(list, list.length * 2);
         }
         list[next++] = o;
    }
182
                                                                6
                                                        继承与多态
     public Object get(int index) {
                                            依索引取得收集的对象
          return list[index];
     }
     public int size() {         已收集的对象个数
          return next;
     }
}
      自定义的 ArrayList 类,内部使用 Object 数组来收集对象,每一次收集的对象会放在
next 指定的索引处,在创建 ArrayList 实例时,可以指定内部数组初始容量,如果使用
无参数构造函数,则默认容量为 16。
      如果要收集对象,可通过 add()方法,注意参数的类型为 Object,可以接收任何对象。
如果内部数组原长度不够,就使用 Arrays.copyOf()方法自动建立原长度两倍的数组并复制
元素。如果想取得收集的对象,可以使用 get()指定索引取得。如果想知道已收集的对
象个数,则通过 size()方法得知。
      以下使用自定义的 ArrayList 类,可收集访客名称,并将名单转为大写后显示:
  Inheritance Guest.java
package cc.openhome;
import java.util.Scanner;
public class Guest {
     public static void main(String[] args) {
          ArrayList list = new ArrayList();
          Scanner scanner = new Scanner(System.in);
          String name;
          while(true) {
              System.out.print("访客名称:");
              name = scanner.nextLine();
              if(name.equals("quit")) {
                  break;
              }
              list.add(name);
          }
          System.out.println("访客名单:");
          for(int i = 0; i < list.size(); i++) {
              String guest = (String) list.get(i);
              System.out.println(guest.toUpperCase());
          }
     }
}
                                                            183
    一个执行结果如下所示:
    访客名称:Justin
    访客名称:Monica
    访客名称:Irene
    访客名称:quit
    访客名单:
    JUSTIN
    MONICA
    IRENE
    java.lang.Object 是所有类的顶层父类,这代表了 Object 上定义的方法,所有对象都继承
下来了,只要不是被定义为 final 方法,都可以重新定义,如图 6.18 所示。
                             图 6.18 java.lang.Object 定义的方法
    1. 重新定义 toString()
    举例来说,      在 6.2.1 节的范例中,        SwordsMan 等类曾定义过 toString()方法,           其实 toString()
是 Object 上定义的方法。Object 的 toString()默认定义为:
    public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
    目前你不用特别知道这段程序代码详细内容,总之返回的字符串包括了类名称以及 16
进制哈希码,通常这并没有什么阅读上的意义。实际上 6.2.1 节的范例中,SwordsMan 等类,
是 重 新 定 义 了 toString() , 许 多 方 法 若 传 入 对 象 , 默 认 都 会 调 用 toString() , 例 如
System.out.print()等方法就会调用 toString()以取得字符串描述来显示,                           所以   6.2.1 节的这
个程序片段:
    SwordsMan swordsMan = new SwordsMan();
    ...
    System.out.println(swordsMan.toString());
    Magician magician = new Magician();
    ...
    System.out.printf(magician.toString());
184
                                                                           6
                                                               继承与多态
    实际上只要这么撰写就可以了:
     SwordsMan swordsMan = new SwordsMan();
     ...
     System.out.println(swordsMan);
     Magician magician = new Magician();
     ...
     System.out.printf(magician);
    2. 重新定义 equals()
    在 4.1.3 节谈过,在 Java 中要比较两个对象的实质相等性,并不是使用==,而是通过
equals()方法,    在后续你看过 Integer 等打包器,              以及字符串相等性比较时,都是使用 equals()
方法。
    实际上 equals()方法是 Object 类有定义的方法,其程序代码是:
    public boolean equals(Object obj) {
         return (this == obj);
    }
    如果没有重新定义 equals(),使用 equals()方法时,作用等同于==,所以要比较实质相
等性,必须自行重新定义。一个简单的例子,是比较两个 Cat 对象是否实际上代表同一只
Cat 的数据:
    public class Cat {
         ...
         public boolean equals(Object other) {
             // other 参考的就是这个对象,当然是同一对象
             if (this == other) {
                 return true;
             }
             /* other 参考的对象是不是 Cat 创建出来的
                 例如若是 Dog 创建出来的当然就不用比了 */
             if (!(other instanceof Cat)) {
                 return false;
             }
             Cat cat = (Cat) other;
             // 定义如果名称与生日,表示两个对象实质上相等
             if (!getName().equals(cat.getName())) {
                 return false;
             }
             if (!getBirthday().equals(cat.getBirthday())) {
                 return false;
             }
             return true;
         }
    }
                                                                      185
    这个程序片段示范了 equals()操作的基本概念,相关说明都以批注方式呈现了。这里
也看到了 instanceof 运算符,它可以用来判断对象是否由某个类创建,左操作数是对象,
右操作数是类,在使用 instanceof 时,编译程序还会来帮点忙,会检查左操作数类型是否
在右操作数类型的继承架构中(或界面操作架构中,下一章会说明接口),如图 6.19 所示。
                        图 6.19 String 与 Date 在继承架构上一点关系也没有
    执行时期,并非只有左操作数对象为右操作数类直接实例化才返回 true,只要左操作
数类型是右操作数类型的子类型,instanceof 也是返回 true。
    这里仅示范了 equals() 操作的基本概念,实际上操作 equals() 并非这么简单。操作
equals()时通常也会操作 hashCode(),原因是等到第                     9 章学习 Collection 时再说明。如果现
在就想知道 equals()与 hashCode()操作时要注意的一些事项,可以先参考以下文件:
     http://caterpillar.onlyfun.net/Gossip/JavaEssence/ObjectEquality.html
           2007 年研究文献 Declarative Object Identity Using Relation Types 中指出,在考察大量
           Java 程序代码之后,作者发现大部分 equals()方法都操作错误。
6.2.6       关于垃圾收集
    创建对象会占据内存,如果程序执行流程中已无法再使用某个对象,该对象就只是徒
耗内存的垃圾。
    对于不再有用的对象,JVM 有垃圾收集(Garbage Collection, GC)机制,收集到的垃圾
对象所占据的内存空间,会被垃圾收集器释放。那么,哪些会被 JVM 认定为垃圾对象?简
单地说,执行流程中,无法通过变量参考的对象,就是 GC 认定的垃圾对象。
    执行流程?具体来说就是线程(Thread)(第 11 章才会说明线程),目前你唯一接触到的
线程就是 main()程序进入点开始之后的主线程(也就是主流程)。事实上,关于垃圾收集本
身就很复杂,不同的需求也会有不同垃圾收集算法,你只需要知道基本概念即可,细节就
交给 JVM 处理。
    假设有一个类:
    public class Some {
         Some next;
    }
    若是从程序进入点开始,有段程序代码如下撰写:
    Some some1 = new Some();
    Some some2 = new Some();
    Some some1 = some2;
186
                                                      6
                                              继承与多态
  执行到第二行时,主线程可以通过参考名称所参考到的对象,如图 6.20 所示。
                          图 6.20 两个对象都有牌子
  执行到第三行时,是将 some2 参考的对象给 some1 参考,如图 6.21 所示。
                          图 6.21 没有牌子的就是垃圾
  原先 some1 参考的对象不再被任何名称参考,通过主线程也不再能参考到该对象,这
个对象就是内存中的垃圾了,GC 会自动找出这些垃圾并予以回收。
  GC 的基本概念就是这样,但可以加以变化。如果有段程序是这样:
  Some some = new Some();
  some.next = new Some();
  some = null;
  在执行到第二行时,情况如图 6.22 所示,此时还没有对象是垃圾。
                               图 6.22 链状参考
  由于从主流程开始,可以通过 some 参考至中间的对象,而 some.next 可以参考至最右
边的对象,目前没有必要回收任何对象。执行完成第三行后,情况变成如图 6.23 所示。
                          图 6.23 回收几个对象呢?
                                                  187
    由于从主流程开始,无法通过 some 参考至中间对象,也就无法再通过中间对象的 next
参考至右边对象,所以两个对象都是垃圾。同样的道理,下面程序代码中,数组参考到的
对象全部都会被回收,如图 6.24 所示。
    Some[] somes = {new Some(), new Some(), new Some};
    somes = null;
                                 图 6.24 数组参考到的对象被回收
    被回收的对象包括了数组对象本身,以及三个索引所参考的三个对象。如果是形同孤
岛的对象,例如:
    Some some = new Some();
    some.next = new Some();
    some.next.next = new Some();
    some.next.next.next = some;
    some = null;
    执行到第四行时,情况如图 6.25 所示。
                                        图 6.25 循环参考
    执行完第五行后,情况变为如图 6.26 所示。
                                        图 6.26 形成孤岛
188
                                                                                         6
                                                                             继承与多态
   这个时候形成孤岛的右边三个对象,将全部被 GC 给处理掉。
         GC 在进行回收对象前,会调用对象的 finalize()方法,这是 Object 上就定义的方法。
         如果在对象被回收前,有些事情想做,可以重新定义 finalize()方法,不过要注意的是,
         何时启动 GC,要视所采用的 GC 算法而定,也就是 finalize()被调用的时机是无法确定
         的。在 Effective Java 书中也建议,避免使用 finalize() 方法。如果对 finalize()方法有
         兴趣,可以参考:
         http://caterpillar.onlyfun.net/Gossip/JavaEssence/Finalize.html
         JWorld 上的讨论也可以参考一下:
         http://www.javaworld.com.tw/jute/post/view?bid=44&id=17264&sty=1&tpg=1&age=0
6.2.7     再看抽象类
   撰写程序常有些看似不合理但又非得完成的需求。举个例子来说,现在老板叫你开发
一个猜数字游戏,会随机产生 0~9 的数字,用户输入的数字与随机产生的数字相比,如果
相同就显示“猜中了”,如果不同就继续让用户输入数字,直到猜中为止。
   这程序有什么难的?相信现在的你也可以写出来:
   package cc.openhome;
   import java.util.Scanner;
   public class Guess {
       public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int number = (int) (Math.random() * 10);
            int guess;
            do {
                 System.out.print("输入数字:");
                 guess = scanner.nextInt();
            } while(guess != number);
            System.out.println("猜中了");
       }
   }
   圆满完成任务是吧。当你将程序交给老板后,老板皱着眉头说:“我有说要在文本模
式下执行这个游戏吗?”你就问了:“请问会在哪个环境下执行呢?”老板说:“还没决
定,也许会用窗口程序,不过改成网页也不错,唔......下个星期开会讨论一下。”你问:
“那可以下星期讨论完我再来写吗?”老板说:“不行!”你(内心 OS):“当我是哆啦 A
梦喔!我又没有时光机......”
   这个例子可笑吗?在团队合作、多个部门开发程序时,有许多时候,你不能只是等另
一个部门将程序操作出来,也许另一部门要三个月后才能完成程序操作,难道你们这个部
门要空转三个月?有些需求无法决定,却要撰写出程序的例子太多了。
                                                                                     189
      有些不合理的需求,本身确实不合理,但有些看似不合理的需求,其实可以通过设计
(Design)来解决。以上面的例子来说,取得用户输入、显示结果的环境未定,但你负责的
这部分还是可以先操作。例如:
  Inheritance GuessGame.java
package cc.openhome;
public abstract class GuessGame {
     public void go() {
          int number = (int) (Math.random() * 10);
          int guess;
          do {
              print("输入数字:");
              guess = nextInt();
          } while(guess != number);
          println("猜中了");
     }
     public abstract void print(String text);
     public abstract void println(String text);
     public abstract int nextInt();
}
      这个类的定义不完整,print()、println()与 nextInt()都是抽象方法,因为老板还没决
定在哪个环境执行猜数字游戏,所以如何显示输出、取得用户输入就不能操作。可以先操
作的是猜数字的流程,虽然是抽象方法,但在 go()方法中,还是可以调用。
      等到下星期开会决定,             终于还是在文本模式下执行猜数字游戏,        你就再撰写 ConsoleGame
类,继承抽象类 GuessGame,操作当中的抽象方法即可:
  Inheritance ConsoleGame.java
package cc.openhome;
import java.util.Scanner;
public class ConsoleGame extends GuessGame {
     private Scanner scanner = new Scanner(System.in);
     @Override
     public void print(String text) {
          System.out.print(text);
     }
     @Override
     public void println(String text) {
          System.out.println(text);
     }
190
                                                                                          6
                                                                                  继承与多态
     @Override
     public int nextInt() {
          return scanner.nextInt();
     }
}
      实际上只要创建出 ConsoleGame 实例,执行 go()方法过程中调用到 print()、nextInt()
或 println()等方法时,都是执行 ConsoleGame 中定义的流程,完整的猜数字游戏就操作出
来了。例如:
  Inheritance Guess.java
package cc.openhome;
public class Guess {
     public static void main(String[] args) {
          GuessGame game = new ConsoleGame();
          game.go();
     }
}
      一个执行的结果如下:
      输入数字:5
      输入数字:4
      输入数字:3
      猜中了
            设计上的经验,称为设计模式(Design pattern),上面的例子是 Template method 模式的
            实例。如果对其他设计模式有兴趣,可以先从这里开始:
            http://caterpillar.onlyfun.net/Gossip/DesignPattern/DesignPattern.htm
6.3         重点复习
      面向对象中,子类继承父类,避免重复的行为定义,不过并非为了避免重复定义行为
就使用继承。如何正确判断使用继承的时机,以及继承之后如何活用多态,才是学习继承
时的重点。
      程序代码重复在程序设计上,就是不好的信号,多个类间出现重复的程序代码时,设
计上可考虑的改进方式之一,就是把相同的程序代码提升为父类。
      在 Java 中,继承时使用 extends 关键字,private 成员也会被继承,只不过子类无法直
接存取,必须通过父类提供的方法来存取(如果父类愿意提供访问方法的话)。
      在 Java 中,子类只能继承一个父类,继承有个重要的关系,就是子类与父类间会有 is-a
的关系。要开始理解多态,必须先知道你操作的对象是“哪一种”东西。
                                                                                      191
    检查多态语法逻辑是否正确,方式是从=号右边往左读:右边是不是一种左边呢(右边
类型是不是左边类型的子类)?如果不是就会编译失败,如果加上扮演(CAST)语法,编译
程序就让程序代码通过编译,不过后果得自行负责,也就是扮演失败,执行时会抛出
ClassCastException。
    什么叫多态?以抽象讲法解释,就是使用单一接口操作多种类型的对象。若用 6.1.2
节的范例来理解,在 showBlood()方法中,既可以通过 Role 类型操作 SwordsMan 对象,也可
以通过 Role 类型操作 Magician 对象。
    如果某方法区块中真的没有任何程序代码操作,可以使用 abstract 标示该方法为抽象
方法,该方法不用撰写{}区块,直接“;”结束即可。类中若有方法没有操作,并且标示为
abstract,表示这个类定义不完整,定义不完整的类就不能用来生成实例。Java                  中规定内
含抽象方法的类,一定要在 class 前标示 abstract,表示这是一个定义不完整的抽象类。
    被声明为 protected 的成员,相同包中的类可以直接存取,不同包中的类可以在继承后
的子类直接存取。
    Java 中有 public、protected 与 private 三个权限关键字,但实际上有四个权限范围,
如表 6.1 所示。
    如果想取得父类中的方法定义,可以在调用方法前,加上 super 关键字。重新定义方
法要注意,对于父类中的方法权限,只能扩大但不能缩小。在 JDK5 之后,重新定义方法
时,如果返回类型是父类中方法返回类型的子类,也是可以通过编译的。
    如果子类构造函数中没有指定执行父类中哪个构造函数,默认会调用父类中无参数构
造函数。如果想执行父类中某构造函数,可以使用 super()指定。this()与 super()只能择一
调用,而且一定要在构造函数第一行执行。
    如果 class 前使用了 final 关键字定义,那么表示这个类是最后一个了,不会再有子类,
也就是不能被继承。定义方法时,也可以限定该方法为 final,这表示最后一次定义方法了,
也就是子类不可以重新定义 final 方法。
    如 果 定 义 类 时 没 有 使 用 extends 关 键 字 指 定 继 承 任 何 类 , 那 一 定 是 继 承
java.lang.Object。在    Java 中,任何类追溯至最上层父类,一定就是 java.lang.Object。
    对于不再有用的对象,JVM 有垃圾收集机制,收集到的垃圾对象所占据的内存空间,
会被垃圾收集器释放。执行流程中,无法通过变量参考的对象,就是 GC 认定的垃圾对象。
6.4      课后练习
6.4.1     选择题
    1. 如果有以下程序片段:
        class Some {
            void doService() {
                System.out.println("some service");
            }
192
                                                                              6
                                                                继承与多态
    }
    class Other extends Some {
        @Override
         void doService() {
            System.out.println("other service");
        }
    }
    public class Main {
        public static void main(String[] args) {
            Other other = new Other();
            other.doService();
        }
    }
以下描述正确的是(              )。
   A. 编译失败                          B. 显示 some service
   C. 显示 other service              D. 先显示 some service、后显示 other service
2. 承上题,如果 main()中改为:
   Some some = new Other();
   some.doService();
以下描述正确的是(              )。
   A. 编译失败                          B. 显示 some service
   C. 显示 other service              D. 先显示 some service、后显示 other service
3. 如果有以下程序片段:
    class Some {
        String ToString() {
            return "Some instance";
        }
    }
    public class Main {
        public static void main(String[] args) {
            Some some = new Some();
            System.out.println(some);
        }
    }
以下描述正确的是(              )。
   A. 显示 Some instance              B. 显示 Some@XXXX,XXXX 为 16 进制数字
   C. 发生 ClassCastException         D. 编译失败
4. 如果有以下程序片段:
    class Some {
        int hashCode() {
            return 99;
                                                                          193
           }
       }
       public class Main {
           public static void main(String[] args) {
               Some some = new Some();
               System.out.println(some.hashCode());
           }
       }
    以下描述正确的是(            )。
       A. 显示 99                         B. 显示 0
       C. 发生   ClassNotFoundException   D. 编译失败
    5. 如果有以下程序片段:
       class Some {
           @Override
           String ToString() {
               return "Some instance";
           }
       }
       public class Main {
           public static void main(String[] args) {
               Some some = new Some();
               System.out.println(some);
           }
       }
    以下描述正确的是(            )。
       A. 显示 Some instance              B. 显示 Some@XXXX,XXXX 为 16 进制数字
       C. 发生 ClassCastException         D. 编译失败
    6. 如果有以下程序片段:
       class Some {
           abstract void doService();
       }
       class Other extends Some {
           @Override
            void doService() {
               System.out.println("other service");
           }
       }
       public class Main {
           public static void main(String[] args) {
               Some some = new Other();
               some.doService();
           }
       }
    以下描述正确的是(            )。
       A. 编译失败                                      B. 显示 other service
194
                                                                           6
                                                                   继承与多态
   C. 执行时发生 ClassCastException                    D. 移除@Override 可编译成功
7. 如果有以下程序片段:
   class Some {
       protected int x;
       Some(int x) {
           this.x = x;
       }
   }
   class Other extends Some {
       Other(int x) {
           this.x = x;
       }
   }
以下描述正确的是(             )。
   A. new Other(10)后,对象成员 x 值为 10
   B. new Other(10)后,对象成员 x 值为 10
   C. Other 中无法存取 x 的编译失败
   D. Other 中无法调用父类构造函数的编译失败
8. 如果有以下程序片段:
   public class IterableString extends String {
       public IterableString(String original) {
           super(original);
       }
       public void iterate() {
            //...
       }
   }
以下描述正确的是(             )。
   A. String s = new IterableString("J")可通过编译
   B. IterableString s = new IterableString("J")可通过编译
   C. 因无法调用 super()的编译失败
   D. 因无法继承 String 的编译失败
9. 如果有以下程序片段:
   class Some {
       Some() {
           this(10);
           System.out.println("Some()");
       }
       Some(int x) {
           System.out.println("Some(int x)");
                                                                       195
            }
        }
        class Other extends Some {
            Other() {
                super(10);
                System.out.println("Other()");
            }
            Other(int y) {
                System.out.println("Other(int y)");
            }
        }
    以下描述正确的是(              )。
        A.new Other()显示"Some(int x)"、"Other()"      B. new Other(10)显示"Other(int y)"
        C. new Some()显示"Some(int x)"、"Some()"       D. 编译失败
    10. 如果有以下程序片段:
        class Some {
            Some() {
                System.out.println("Some()");
                this(10);
            }
            Some(int x) {
                System.out.println("Some(int x)");
            }
        }
        class Other extends Some {
            Other() {
                super(10);
                 System.out.println("Other()");
            }
            Other(int y) {
                System.out.println("Other(int y)");
            }
        }
    以下描述正确的是(              )。
        A. new Other()显示"Some(int x)"、"Other()"
        B. new Other(10)显示"Some()"、"Some(int x)"、"Other(int y)"
        C. new Some()显示"Some(int x)"、"Some()"
        D. 编译失败
196
                                                                  6
                                                          继承与多态
6.4.2    操作题
   1. 如果使用 6.2.5 节设计的 ArrayList 类收集对象,          想显示所收集对象的字符串描述时,
必须如下:
       ArrayList list = new ArrayList();
       //...收集对象
       for(int i = 0; i < list.size(); i++) {
           System.out.println(list.get(i));
       }
   请重新定义 ArrayList 的 toString()方法,让客户端想显示所收集对象的字符串描述时,
可以如下:
      ArrayList list = new ArrayList();
      //...收集对象
      System.out.println(list);
   2. 承上题,若想比较两个 ArrayList 实例是否相等,希望可以如下比较:
       ArrayList list1 = new ArrayList();
       //...用 list1 收集对象
       ArrayList list2 = new ArrayList();
       //...用 list2 收集对象
       System.out.println(list1.equals(list2));
   请重新定义 ArrayList 的 equals()方法,先比较收集的对象个数,再比较各索引的对象
实质上是否相等(使用各对象的 equals()比较)。
                                                              197
                     输入/输出         10
学习目标
 了解串流与输入/输出的关系
 认识 InputStream、OutputStream 继承架构
 认识 Reader、Writer 继承架构
 使用输入/输出装饰器类
10.1        InputStream 与 OutputStream
     想活用输入/输出 API,一定要先了解 Java 中如何以串流(Stream)抽象化输入/输出概
念,以及 InputStream、OutputStream 继承架构。如此一来,无论标准输入/输出、文档输入
/输出、网络输入/输出、数据库输入/输出等都可用一致的操作进行处理。
10.1.1       串流设计的概念
     Java 将输入/输出抽象化为串流,数据有来源及目的地,衔接两者的是串流对象。比喻
来说,数据就好比水,串流好比水管,通过水管的衔接,水由一端流向另一端,如图 10.1
所示。
                             目的地
                                                     串流对象
                                               数据              来源
                                  图 10.1 串流衔接来源与目的地
     从应用程序角度来看,如果要将数据从来源取出,可以使用输入串流,如果要将数据
写入目的地,可以使用输出串流。在 Java 中,输入串流代表对象为 java.io.InputStream 实
例,输出串流代表对象为 java.io.OutputStream 实例。无论数据源或目的地为何,只要设法
取得 InputStream 或 OutputStream 的实例,接下来操作输入/输出的方式都是一致,无须理会
来源或目的地的真正形式,如图 10.2 所示。
                                                  Inputstream
                                应用程序                          来源
                                     Outputstream             目的地
                       图 10.2 从应用程序看 InputStream 与 OutputStream
     来源与目的地都不知道的情况下,如何撰写程序?听来不可思议,但实际上就是会有
这类需求。举个例子来说,可以设计一个通用的 dump()方法:
 Stream IO.java
package cc.openhome;
import java.io.*;
public class IO {
    public static void dump(InputStream src, OutputStream dest)    数据来源与目的地
300
                                                                                            10
                                                                                  输入/输出
                                throws IOException {          客户端要处理异常
         try (InputStream input = src; OutputStream output = dest) {       尝试自动关闭资源
             byte[] data = new byte[1024];        尝试每次从来源读取 1024 字节
             int length = -1;
             while ((length = input.read(data)) != -1) {          读取数据
                 output.write(data, 0, length);           写出数据
             }
         }
     }
}
      dump()方法接受 InputStream       与 OutputStream 实例,分别代表读取数据的来源,以及输
出数据的目的地。在进行 InputStream 与 OutputStream 的相关操作时若发生错误,会抛出
java.io.IOException   异常,在这里不特别处理,而是在 dump()方法上声明 throws,由调用
dump()方法的客户端处理。
      在不使用 InputStream 与 OutputStream 时,必须使用 close() 方法关闭串流。由于
InputStream    与    OutputStream   操 作 了       java.io.Closeable   接 口 , 其 父 接 口 为
java.lang.AutoCloseable   接口,因此可使用 JDK7 尝试自动关闭资源语法。
            思考一下,如果不能使用 JDK7 尝试自动关闭资源语法,那使用 try、catch、finally 该
            怎么写?可以参考一下 8.2.2 节的内容。
      每次从 InputStream 读入的数据,           都会先置入 byte 数组中,            InputStream 的 read()方法,
每次会尝试读入 byte 数组长度的数据,并返回实际读入的字节,只要不是-1,就表示读取
到数据。可以使用 OutputStream 的 write()方法,指定要写出的 byte 数组、初始索引与数
据长度。
      那么这个 dump()方法的来源是什么?不知道。目的地呢。也不知道。dump()方法并没有
限定来源或目的地真实形式,而是依赖于抽象的 InputStream、OutputStream。如果要将某个
文档读入并另存为另一个文档,则可以这么使用:
  Stream Copy.java
package cc.openhome;
import java.io.*;
public class Copy {
     public static void main(String[] args) throws IOException {
         IO.dump(
               new FileInputStream(args[0]),
               new FileOutputStream(args[1])
         );
     }
}
                                                                                        301
      这个程序可以由命令行自变量指定读取的文档来源与写出的目的地,例如:
      > java cc.openhome.Copy c:\workspace\Main.java C:\workspace\Main.txt
      稍后就会介绍串流继承架构,FileInputStream 是 InputStream 的子类,用于衔接文档以
读入数据,FileOutputStream 是 OutputStream 的子类,用于衔接文档以写出数据。
      如果要从 HTTP 服务器读取某个网页,并另存为文档,也可以使用这里设计的 dump()
方法。例如:
  Stream Download.java
package cc.openhome;
import java.io.*;
import java.net.URL;
public class Download {
     public static void main(String[] args) throws IOException {
         URL url = new URL(args[0]);
         InputStream src = url.openStream();
         OutputStream dest = new FileOutputStream(args[1]);
         IO.dump(src, dest);
     }
}
      虽然没有正式介绍到网络程序设计,不过 java.net.URL 的使用很简单,只要指定网址,
URL  实例会自动进行 HTTP 协议。可以使用 openStream()方法取得 InputStream 实例,代表
与网站连接的数据串流。可以这样指定网址下载文档:
      > java cc.openhome.Download http://openhome.cc c:\workspace\index.txt
      无论来源或目的地实体形式为何,只要想办法取得 InputStream 或 OutputStream,接下
来都是调用 InputStream 或 OutputStream 的相关方法。例如,使用 java.net.ServerSocket 接
受客户端联机的例子:
      ServerSocket server = null;
      Socket client = null;
      try {
          server = new ServerSocket(port);
          while(true) {
              client = server.accept();
              InputStream input = client.getInputStream();
              OutputStream output = client.getOutputStream();
              // 接下来就是操作 InputStream、OutputStream 实例了
              ...
          }
      }
      catch(IOException ex) {
302
                                                                                  10
                                                                        输入/输出
        ...
    }
    如果将来学到 Servlet,想将文档输出至浏览器,也会有类似的操作:
    response.setContentType("application/pdf");
    InputStream in = this.getServletContext()
                         .getResourceAsStream("/WEB-INF/jdbc.pdf");
    OutputStream out = response.getOutputStream();
    byte[] data = new byte[1024];
    int length = -1;
    while((length = in.read(data)) != -1) {
        out.write(data, 0, length);
    }
10.1.2      串流继承架构
    在了解串流抽象化数据源与目的地的概念后,接下来要搞清楚 Java 中 InputStream、
OutputStream 的继承架构。首先看到 InputStream 的常用类继承架构,如图                     10.3 所示。
                              图 10.3 InputStream 常用类继承架构
    再来看 OutputStream 的常用类继承架构,如图 10.4 所示。
                             图 10.4 OutputStream 常用类继承架构
    了解 InputStream 与 OutputStream 类继承架构之后,再来逐步说明相关类的使用方式。
    1. 标准输入/输出
    还记得 System.in 与 System.out 吗?查看 API 文件的话,                会发现它们分别是 InputStream
与 PrintStream 的实例,分别代表标准输入(Standard input)与标准输出(Standard output),以
个人计算机而言,通常对应至文本模式中的输入与输出。
    以 System.in 而言,因为文本模式下通常是取得整行用户输入,因此较少直接操作
InputStream 相关方法,而是如前面章节使用 java.util.Scanner 打包 System.in ,你操作
                                                                              303
Scanner 相关方法,而 Scanner 会代你操控 System.in 取得数据,并转换为取得你想要的数据
类型。
      可以使用 System 的 setIn()方法指定 InputStream 实例,重新指定标准输入来源。例如
下面范例故意将标准输入指定为 FileInputStream,可以读取指定文档并显示在文本模式:
  Stream StandardIn.java
package cc.openhome;
import java.io.*;
import java.util.*;
public class StandardIn {
     public static void main(String[] args) throws IOException {
          System.setIn(new FileInputStream(args[0]));
          try (Scanner scanner = new Scanner(System.in)) {
              while (scanner.hasNextLine()) {
                  System.out.println(scanner.nextLine());
              }
          }
     }
}
      System.out 为 PrintStream   实例,从图 10.4 来看,它是一种 OutputStream,所以若要将
10.1.1 节的 Download 范例改为输出至标准输出,也可以这么写:
      ...
      URL url = new URL(args[0]);
      InputStream src = url.openStream();
      IO.dump(src, System.out);
      ...
      标准输出可以重新导向至文档,只要执行程序时使用>将输出结果导向至指定的文档。
例如,若 Hello 类执行了 System.out.println("HelloWorld"):
      > java Hello > Hello.txt
      那么上面的指令执行方式,将会将 HelloWorld 导向至 Hello.txt 文档,而不会显示在文
本模式中,如果使用>>则是附加信息。可以使用 System 的 setOut()方法指定 PrintStream
实例,将结果输出至指定的目的地。例如,故意将标准输出指定至文档:
  Stream StandardOut.java
package cc.openhome;
import java.io.*;
304
                                                                                 10
                                                                       输入/输出
public class StandardOut {
    public static void main(String[] args) throws IOException {
        try (PrintStream printStream = new PrintStream(
                new FileOutputStream(args[0]))) {
            System.setOut(printStream);
            System.out.println("HelloWorld");
        }
    }
}
     PrintStream 接受 InputStream 实例,     在这个范例中用 PrintStream 打包 FileOutputStream,
你操作 PrintStream 相关方法,PrintStream 会代你操作 FileOutputStream。
     除了 System.in 与 System.out 之外,还有个 System.err,为 PrintSteam 实例,称为标准
错误输出串流,它是用来立即显示错误信息。例如,在文本模式下,System.out 输出的信
息可以使用>或>>重新导向至文档,但 System.err 输出的信息一定会显示在文本模式中,
无法重新导向。也可以使用 System.setErr()指定 PrintStream,重新指定标准错误输出串流。
     2.  FileInputStream 与 FileOutputStream
     FileInputStream 是 InputStream 的子类,可以指定文件名创建实例,一旦创建文档就开
启,接着就可用来读取数据。FileOutputStream 是 OutputStream 的子类,可以指定文件名创
建实例,一旦创建文档就开启,接着就可以用来写出数据。无论 FileInputStream 还是
FileOutputStream,不使用时都要使用 close()关闭文档。
     FileInputStream 主要操作了 InputStream 的 read()抽象方法,            使之可从文档中读取数据,
FileOutputStream  主要操作了 OutputStream 的 write()抽象方法,使之可写出数据至文档,
前面的 IO.dump()方法中已示范过 read()与 write()方法。
     FileInputStream、FileOutputStream    在读取、写入文档时,是以字节为单位,通常会使
用一些高阶类加以打包,进行一些高阶操作,像是前面示范过的 Scanner 与 PrintStream 类
等 。 之 后 还 会 看 到 更 多 打 包 InputStream 、 OutpuStream 的 类 , 它 们 也 可 以 用 来 打 包
FileInputStream、FileOutputStream。
     3. ByteArrayInputStream 与 ByteArrayOutputStream
     ByteArrayInputStream  是 InputStream 的子类,可以指定 byte 数组创建实例,一旦创建
就可将 byte 数组当作数据源进行读取。ByteArrayOutputStream 是 OutputStream 的子类,可
以指定 byte 数组创建实例,一旦创建将 byte 数组当作目的地写出数据。
     ByteArrayInputStream  主要操作了 InputStream 的 read()抽象方法,使之可从 byte 数组
中读取数据。ByteArrayOutputStream 主要操作了 OutputStream 的 write()抽象方法,使之可
写出数据至 byte 数组。前面的 IO.dump() 方法中示范过的 read() 与 write() 方法,就是
ByteArrayInputStream 、 ByteArrayOutputStream    的操作范例,毕竟它们都是 InputStream 、
OutputStream 的子类。
                                                                             305
10.1.3       串流处理装饰器
     InputStream、 OutputStream 提供串流基本操作,如果想要为输入/输出的数据做加工处理,
则可以使用打包器类。前面示范过的 Scanner 类就是作为打包器,其接受 InputStream 实例,
你操作 Scanner 打包器相关方法,Scanner 会实际操作打包的 InputStream 取得数据,并转换
为你想要的数据类型。
     InputStream、OutputStream  的一些子类也具有打包器的作用,这些子类创建时,可以接
受 InputStream、  OutputStream 实例。 前面介绍的 PrintStream 就是实际例子,
                                                         你操作 PrintStream
的 print() 、 println() 等方法, PrintStream 会自动转换为 byte 数组数据,利用打包的
OutputStream 进行输出。
     常用的打包器有具备缓冲区作用的 BufferedInputStream、 BufferedOutputStream,具备数据转
换处理作用的 DataInputStream、 DataOutputStream,具备对象串行化能力的 ObjectInputStream、
ObjectOutputStream 等。
     由于这些类本身并没有改变 InputStream、OutputStream 的行为,只不过在 InputStream
取得数据之后,再做一些加工处理,或者是要输出时做一些加工处理,再交由 OutputStream
真正进行输出,因此又称它们为装饰器(Decorator)。就像照片本身装上华丽外框,就可以
让照片感觉更为华丽,或有点像小水管衔接大水管,如小水管(InputStream)读入数据,再
由大水管(如 BufferedInputStream)增加缓冲功能,如图 10.5 所示。
                                                   来源
                               应用程序
                                                   目的地
                                 图 10.5 装饰器提供高阶操作
     下面介绍几个常用的串流装饰器类。
     1. BufferedInputStream 与 BufferedOutputStream
     在前面 IO.dump()方法中,每次调用 InputStream 的 read()方法,都会直接向来源要求数
据,每次调用 OutputStream 的 write()方法时,都会直接将数据写到目的地,这并不是个有
效率的方式。
     以文档存取为例,如果传入 IO.dump()的是 FileInputStream、FileOutputStream 实例,每
次 read()时都会要求读取硬盘,每次 write()时都会要求写入硬盘,这会花费许多时间在硬
盘定位上。
     如果 InputStream 第一次 read()时可以尽量读取足够的数据至内存的缓冲区,后续调用
read()时先看看缓冲区是不是还有数据,如果有就从缓冲区读取,没有再从来源读取数据
306
                                                                                             10
                                                                                 输入/输出
至缓冲区,这样减少从来源直接读取数据的次数,对读取效率将会有帮助(毕竟内存的访问
速度较快)。
      如果 OutputStream 每次 write()时可将数据写入内存中的缓冲区,缓冲区满了再将缓冲
区的数据写入目的地,这样可减少对目的地的写入次数,对写入效率将会有帮助。
      BufferedInputStream 与 BufferedOutputStream 提供的就是前面描述的缓冲区功能,创建
BufferedInputStream、BufferedOutputStream      必须提供 InputStream、OutputStream 进行打包,
可以使用默认或自定义缓冲区大小。
      BufferedInputStream  与 BufferedOutputStream 主要在内部提供缓冲区功能,操作上与
InputStream、  OutputStream 并没有太大差别。          例如,    改写前面的 IO.dump()为 BufferedIO.dump()
方法:
  Stream BufferedIO.java
package cc.openhome;
import java.io.*;
public class BufferedIO {
     public static void dump(InputStream src, OutputStream dest)
                               throws IOException {
         try(InputStream input = new BufferedInputStream(src);
              OutputStream output = new BufferedOutputStream(dest)) {
             byte[] data = new byte[1024];
             int length = -1;
             while ((length = input.read(data)) != -1) {
                 output.write(data, 0, length);
             }
         }
     }
}
      2. DataInputStream 与 DataOutputStream
      DataInputStream、 DataOutputStream 用来装饰 InputStream、      OutputStream,DataInputStream、
DataOutputStream 提供读取、        写入   Java 基本数据类型的方法,像是读写 int、double、boolean
等的方法。这些方法会自动在指定的类型与字节间转换,不用你亲自做字节与类型转换的
动作。
      来看个实际使用 DataInputStream、DataOutputStream 的例子。下面的 Member 类可以调用
save()储存 Member 实例本身的数据,文件名为 Member 的会员号码,调用 Member.load()指定
会员号码,则可以读取文档中的会员数据,封装为 Member 实例并返回:
                                                                                         307
 Stream Member.java
package cc.openhome;
import java.io.*;
public class Member {
    private String number;
    private String name;
    private int age;
    public Member(String number, String name, int age) {
        this.number = number;
        this.name = name;
        this.age = age;
    }
    // 部分程序代码省略,因为只一些 Getter、Setter...
    @Override
    public String toString() {
        return String.format("(%s, %s, %d)", number, name, age);
    }
    public void save() {
        try(DataOutputStream output =         建立 DataOutputStream 打包 FileOutputStream
                new DataOutputStream(new FileOutputStream(number))) {
            output.writeUTF(number);
            output.writeUTF(name);
            output.writeInt(age);             根据不同的类型调用 writeXXX()方法
        } catch(IOException ex) {
            throw new RuntimeException(ex);
        }
    }
    public static Member load(String number) {
        Member member = null;
        try(DataInputStream input =        建立 DataInputStream 打包 FileInputStream
                new DataInputStream(new FileInputStream(number))) {
            member = new Member(
                    input.readUTF(), input.readUTF(), input.readInt());
        } catch(IOException ex) {
                                                                     根据不同的类型调用
            throw new RuntimeException(ex);
                                                                      readXXX()方法
        }
        return member;
    }
308
                                                                                      10
                                                                            输入/输出
}
      在 save()方法中,使用 DataOutputStream 打包 FileOutputStream,储存 Member 实例时,
会使用 writeUTF()、writeInt()方法分别储存字符串与 int 类型。在 load()方法中,则使
用 DataInputStream 打包 FileInputStream,并调用 readUTF()、readInt()分别读入字符串、
int 类型。下面是个使用 Member 类的例子:
  Stream MemberDemo.java
package cc.openhome;
public class MemberDemo {
     public static void main(String[] args) {
          Member[] members = {new Member("B1234", "Justin", 90),
                                  new Member("B5678", "Monica", 95),
                                  new Member("B9876", "Irene", 88)};
          for(Member member : members) {
              member.save();
          }
          System.out.println(Member.load("B1234"));
          System.out.println(Member.load("B5678"));
          System.out.println(Member.load("B9876"));
     }
}
      范例中准备了三个 Member 实例,分别储存为文档之后再读取回来。执行结果如下:
      (B1234, Justin, 90)
      (B5678, Monica, 95)
      (B9876, Irene, 88)
      3. ObjectInputStream 与 ObjectOutputStream
      前面的范例是取得 Member 的 number、             name、age 数据进行储存,         读回时也是先取得 number、
name、age 数据再用来创建 Member 实例。实际上,也可以将内存中的对象整个储存下来,之
后再读入还原为对象。可以使用 ObjectInputStream、ObjectOutputStream 装饰 InputStream、
OutputStream 来完成这项工作。
      ObjectInputStream  提供 readObject()方法将数据读入为对象,而 ObjectOutputStream 提
供    writeObject() 方法将对象写至目的地,可以被这两个方法处理的对象,必须操作
java.io.Serializable    接口,这个接口并没有定义任何方法,只是作为标示之用,表示这个
对象是可以串行化的(Serializable)。
      下面这个范例改写前一个范例,使用 ObjectInputStream、ObjectOutputStream 来储存、
读入数据:
                                                                                  309
  Stream Member2.java
package cc.openhome;
import java.io.*;
public class Member2 implements Serializable {           实作 Serializable
     private String number;
     private String name;
     private int age;
     public Member2(String number, String name, int age) {
         this.number = number;
         this.name = name;
         this.age = age;
     }
     // 部分程序代码省略,因为只一些 Getter、Setter...
     @Override
     public String toString() {
         return String.format("(%s, %s, %d)", number, name, age);
     }
     public void save() {
                                               建立 DataOutputStream 打包 FileOutputStream
         try(ObjectOutputStream output =
                 new ObjectOutputStream(new FileOutputStream(number))) {
             output.writeObject(this);         调用 writeObject()方法写出对象
         } catch(IOException ex) {
             throw new RuntimeException(ex);
         }
     }
     public static Member2 load(String number) {
         Member2 member = null;            建立 DataInputStream 打包 FileInputStream
         try(ObjectInputStream input =
                 new ObjectInputStream(new FileInputStream(number))) {
             member = (Member2) input.readObject();            调用 readObject()方法读入对象
         } catch(IOException | ClassNotFoundException ex) {
             throw new RuntimeException(ex);
         }
         return member;
     }
}
310
                                                                                  10
                                                                        输入/输出
      为了能够直接将对象写出或读入,Member2 操作了 Serializable,在储存对象时,使
用 ObjectOutputStream 打包 FileOutputStream,ObjectOutputStream 的 writeObject()处理内
存 中 的 对 象 数 据 , 再 交 给 FileOutputStream 写 至 文 档  。 在 读 入 对 象 时 , 使 用
ObjectInputStream   打包 FileInputStream,在 readObject()时,会用 FileInputStream 读入字
节数据,再交给           ObjectInputStream  处理,还原为 Member2 实例。
      下面的程序用来测试 Member2 类是否可正确写出与读入对象,执行结果与 MemberDemo
是相同的:
  Stream Member2Demo.java
package cc.openhome;
public class Member2Demo {
     public static void main(String[] args) {
         Member2[] members = {new Member2("B1234", "Justin", 90),
                              new Member2("B5678", "Monica", 95),
                              new Member2("B9876", "Irene", 88)};
         for(Member2 member : members) {
             member.save();
         }
         System.out.println(Member2.load("B1234"));
         System.out.println(Member2.load("B5678"));
         System.out.println(Member2.load("B9876"));
     }
}
      如果在做对象串行化时,对象中某些数据成员不希望被写出,则可以标上 transient
关键字。
10.2         字符处理类
      InputStream、OutputStream   是用来读入与写出字节数据,若实际上处理的是字符数据,
使用 InputStream、OutputStream 就得对照编码表,在字符与字节之间进行转换。所幸 Java SE
API 已提供相关输入/输出字符处理类,让你不用亲自进行字节与字符编码转换的枯燥工作。
10.2.1        Reader 与 Writer 继承架构
      针对字符数据的读取,Java SE 提供了 java.io.Reader 类,其抽象化了字符数据读入
的来源。针对字符数据的写入,则提供了 java.io.Writer 类,其抽象化了数据写出的目的地。
      举个例子来说,如果想从来源读入字符数据,或将字符数据写至目的地,都可以使用
下面的 CharUtil.dump()方法:
                                                                              311
  Stream CharUtil.java
package cc.openhome;
import java.io.*;
                                   数据来源与目的地
                                                            客户端要处理异常
public class CharUtil {
     public static void dump(Reader src, Writer dest) throws IOException {
         try(Reader input = src; Writer output = dest) {          尝试自动关闭资源
             char[] data = new char[1024];           尝试每次从来源读取 1024 字符
             int length = 0;
             while((length = input.read(data)) != -1) {          读取数据
                 output.write(data, 0, length);          写出数据
             }
         }
     }
}
      dump()方法接受 Reader      与 Writer 实例,分别代表读取数据的来源,以及输出数据的目
的地。在进行 Reader 与 Writer 的相关操作时若发生错误,会抛出 IOException 异常,在
这里不特别处理,而是在 dump()方法上声明 throws,由调用 dump()方法的客户端处理。
      在不使用 Reader 与 Writer 时,必须使用 close()方法关闭串流。由于 Reader 与 Writer
操作了 Closeable 接口,其父接口为 AutoCloseable 接口,因此可使用 JDK7 尝试自动关闭
资源语法。
      每次从 Reader 读入的数据,都会先置入 char 数组中。Reader 的 read()方法,每次会
尝试读入 char 数组长度的数据,并返回实际读入的字符数,只要不是-1,就表示读取到字
符。可以使用 Writer 的 write()方法,指定要写出的 byte 数组、初始索引与数据长度。
      同样地,了解 Reader、Writer 继承架构会有利于 API 的灵活运用。首先看 Reader 继承
架构,如图 10.6 所示。
      图 10.6 中列出了几个常用的 Reader 子类,再来看看 Writer 常用类继承架构,如图 10.7
所示。
                图 10.6 Reader 继承架构                           图 10.7 Writer 继承架构
      从图 10.6 与图 10.7 得知,FileReader 是一种 Reader,主要用于读取文档并将读到的数
312
                                                                          10
                                                                  输入/输出
据转换为字符;StringWriter 是一种 Writer,可以将字符数据写至 StringWriter,最后使用
toString()方法取得字符串,代表所有写入的字符数据。所以,若要使用 CharUtil.dump()
读入文档、转为字符串并显示在文本模式中,可以如下:
  Stream CharUtilDemo.java
package cc.openhome;
import java.io.*;
public class CharUtilDemo {
     public static void main(String[] args) throws IOException {
         FileReader reader = new FileReader(args[0]);
         StringWriter writer = new StringWriter();
         CharUtil.dump(reader, writer);
         System.out.println(writer.toString());
     }
}
      如果执行 CharUtilDemo 时,在命令行自变量指定了文档位置,若文档中实际都是字符
数据,就可以在文本模式中看到文档中的文字内容。
      稍微解释一下几个常用的 Reader、Writer 子类。StringReader 可以将字符串打包,当作
读取来源,StringWriter 则可以作为写入目的地,最后用 toString()取得所有写入的字符组
成的字符串。CharArrayReader、CharArrayWriter 则类似,将 char 数组当作读取来源以及写
入目的地。
      FileReader、FileWriter       可以对文档做读取与写入,读取或写入时默认会使用操作系统
默认编码来做字符转换。也就是说,如果你的操作系统默认编码是 GB2312,则 FileReader、
FileWriter  会以 GB2312 对你的“纯文本文档”做读取、写入的动作,如果操作系统默认
编码是 UTF-8,则 FileReader、FileWriter 就使用 UTF-8。
      在启动 JVM 时,可以指定-Dfile.encoding 来指定 FileReader、FileWriter 所使用的编码。
例如,指定使用 UTF-8:
> java –Dfile.encoding=UTF-8 cc.openhome.CharUtil sample.txt
      FileReader、FileWriter      没有可以指定编码的方法。如果在程序执行过程中想要指定编
码,则必须使用             InputStreamReader、OutputStreamWriter,这两个类实际上是作为装饰器。
在 10.2.2 节中一并说明。
           纯文本文档?编码?如果你看到这些名词不太懂的话,建议参考一下“乱码 1/2”:
           http://caterpillar.onlyfun.net/Gossip/Encoding/
10.2.2        字符处理装饰器
      正如同 InputStream、OutputStream 有一些装饰器类,可以对 InputStream、OutputStream
打包增加额外功能,Reader、Writer 也有一些装饰器类可供使用。下面介绍常用的字符处
理装饰器类。
                                                                      313
      1. InputStreamReader 与 OutputStreamWriter
      如果串流处理的字节数据,实际上代表某些字符的编码数据,而你想要将这些字节数
据转换为对应的编码字符,可以使用 InputStreamReader、OutputStreamWriter 对串流数据打包。
      在建立 InputStreamReader 与 OutputStreamWriter 时,        可以指定编码,         如果没有指定编码,
则以 JVM 启动时所获取的默认编码来做字符转换。下面将 CharUtil 的 dump()改写,提供可
指定编码的 dump()方法:
  Stream CharUtil2.java
package cc.openhome;
import java.io.*;
public class CharUtil2 {
     public static void dump(Reader src, Writer dest) throws IOException {
         try(Reader input = src; Writer output = dest) {
             char[] data = new char[1024];
             int length = 0;
             while((length = input.read(data)) != -1) {
                  output.write(data, 0, length);
             }
         }
     }
     public static void dump(InputStream src, OutputStream dest,
                               String charset) throws IOException {
         dump(
             new InputStreamReader(src, charset),
             new OutputStreamWriter(dest, charset)
         );
     }
     // 采用默认编码
     public static void dump(InputStream src, OutputStream dest)
                             throws IOException {
         dump(src, dest, System.getProperty("file.encoding"));
     }
}
      如果想以 UTF-8 处理字符数据,例如读取 UTF-8 的 Main.java 文本文件,并另存为
UTF-8 的 Main.txt 文本文件,则可以如下:
      CharUtil2.dump(
           new FileInputStream("Main.java"),
314
                                                                                           10
                                                                                输入/输出
          new FileOutputStream("Main.txt"),
          "UTF-8"
  );
     2. BufferedReader 与 BufferedWriter
     正如 BufferedInputStream、BufferedOutputStream 为 InputStream、OutputStream 提供缓冲
区作用,以改进输入/输出的效率,BufferedReader、BufferedWriter 可对 Reader、Writer 提
供缓冲区作用,在处理字符输入/输出时,对效率也会有所帮助。
     举个使用 BufferedReader 的例子。在 JDK 1.4 之前,标准 API 并没有 Scanner 类,若要
在文本模式下取得用户输入的字符串,会这样撰写:
     BufferedReader reader = new BufferedReader(
                                           new InputStreamReader(System.in));
     String name = reader.readLine();
     System.out.printf("Hello, %s!", name);
     创建 BufferedReader 时要指定被打包的 Reader,可以指定或采用默认缓冲区大小。就
API 的使用而言,System.in 是 InputStream 实例,可以指定给 InputStreamReader 创建之用,
InputStreamReader   是一种 Reader,所以可指定给 BufferedReader 创建之用。
     就装饰器的作用而言,InputStreamReader 将 System.in 读入的字节数据做编码转换,而
BufferedReader    将编码转换后的数据做缓冲处理,以增加读取效率。 BufferedReader 的
readLine()方法,可以读取一行数据(以换行字符为依据)并以字符串返回,返回的字符串不
包括换行字符。
     3. PrintWriter
     PrintWriter 与 PrintStream   使用上极为类似,不过除了可以对 OutputStream 打包之外,
PrintWriter 还可以对 Writer 进行打包,提供 print()、println()、format()等方法。
           JDK1.4 开始提供了 NIO API,提供了非阻断式 IO,并提供 Buffer、Selector、Channel、Charset 等
           进阶 API,有兴趣的话可以参考以下讨论串中的文件作为开始:
           http://www.javaworld.com.tw/jute/post/view?bid=20&id=31250&tpg=2&ppg=1&sty=0&age=0
10.3         重点复习
     从应用程序角度来看,如果要将数据从来源取出,可以使用输入串流;如果要将数据
写入目的地,可以使用输出串流。在 Java 中,输入串流代表对象为 java.io.InputStream
实例,输出串流代表对象为 java.io.OutputStream 实例。无论数据源或目的地为何,只要设
法取得 InputStream 或 OutputStream 的实例,接下来操作输入/输出的方式都是一致,无须理
会来源或目的地的真正形式。
     在不使用 InputStream 与 OutputStream 时,必须使用 close() 方法关闭串流。由于
InputStream     与   OutputStream   操 作 了       java.io.Closeable    接 口 , 其 父 接 口 为
java.lang.AutoCloseable   接口,因此可使用 JDK7 尝试自动关闭资源语法。
                                                                                       315
     FileInputStream  是 InputStream 的子类,可以指定文件名创建实例,一旦创建文档就开
启,接着就可用来读取数据。FileOutputStream 是 OutputStream 的子类,可以指定文件名创
建实例,一旦创建文档就开启,接着就可以用来写出数据。无论 FileInputStream 还是
FileOutputStream,不使用时都要使用 close()关闭文档。
     ByteArrayInputStream  是 InputStream 的子类,可以指定 byte 数组创建实例,一旦创建
就可将 byte 数组当作数据源进行读取。ByteArrayOutputStream 是 OutputStream 的子类,可
以指定 byte 数组创建实例,一旦创建将 byte 数组当作目的地写出数据。
     InputStream、OutputStream 提供串流基本操作,如果想要为输入/输出的数据做加工处理,
则 可 以 使 用 打 包 器 类 。 常 用 的 打 包 器 有 具 备 缓 冲 区 作 用 的 BufferedInputStream 、
BufferedOutputStream,具备数据转换处理作用的 DataInputStream、DataOutputStream,具备对象串行化
能力的 ObjectInputStream、 ObjectOutputStream 等。
     针对字符数据的读取,Java SE 提供了 java.io.Reader 类,其抽象化了字符数据读入
的来源。针对字符数据的写入,则提供了 java.io.Writer 类,其抽象化了数据写出的目的地。
     FileReader、FileWriter   则可以对文档做读取与写入,读取或写入时默认会使用操作系
统默认编码来做字符转换。在启动 JVM 时,可以指定-Dfile.encoding 来指定 FileReader、
FileWriter 所使用的编码。
     Reader、Writer 也有一些装饰器类可供使用。如果串流处理的字节数据,实际上代表某
些字符的编码数据,而你想要将这些字节数据转换为对应的编码字符,可以使用
InputStreamReader 、 OutputStreamWriter   对串流数据打包。 BufferedReader 、 BufferedWriter
可对 Reader、Writer 提供缓冲区作用,在处理字符输入/输出时,对效率也会有所帮助。
PrintWriter   与 PrintStream 使用上极为类似,不过除了可以对 OutputStream 打包之外,
PrintWriter 还可以对 Writer 进行打包,提供 print()、println()、format()等方法。
10.4         课后练习
10.4.1        选择题
     1. 输入/输出串流的父类是(                 )两个。
         A. InputStream          B. Reader         C. OutputStream    D. Writer
     2. 处理字符输入/输出的父类是(                   )两个。
         A. InputStream          B. Reader         C. OutputStream    D. Writer
     3. 以下(       )两个类为 InputStream、OutputStream 提供缓冲区作用。
         A. BufferedInputStream                    B. BufferedReader
         C. BufferedOutputStream                   D. BufferedWriter
     4. 以下(       )两个类为 Reader、Writer 提供缓冲区作用。
         A. BufferedInputStream                    B. BufferedReader
         C. BufferedOutputStream                   D. BufferedWriter
316
                                                                                        10
                                                                                输入/输出
   5. 如果有以下程序片段:
       ObjectInputStream input = new ObjectInputStream(new ________________);
   空白部分指定(           )类型可以通过编译。
       A. FileInputStream("Account.data")
       B. FileReader("Main.java")
       C. InputStreamReader(new FileReader("Main.java"))
       D. ObjectReader("Account.data")
   6. 如果有以下程序片段:
       BufferedReader reader = new BufferedReader(new ________________);
   空白部分指定(           )类型可以通过编译。
       A. FileInputStream("Account.data")
       B. FileReader("Main.java")
       C. InputStreamReader(new FileInputStream("Main.java"))
       D. ObjectReader("Account.data")
   7. 以下(      )两个类分别拥有 readObject()、writeObject()方法。
       A. BufferedInputStream                           B. ObjectInputStream
       C. ObjectOutputStream                            D. BufferedOutputStream
   8. 以下(      )两个类为 InputStream、OutputStream 提供编码转换作用。
       A. BufferedInputStream                           B. InputStreamReader
       C. BufferedOutputStream                          D. OutputStreamWriter
   9. 以下(      )两个类为 Reader、Writer 提供编码转换作用。
       A. BufferedInputStream                           B. InputStreamReader
       C. BufferedOutputStream                          D. 以上皆非
   10. 以下(     )类位于 java.io 包中。
       A. BufferedInputStream                           B. IOException
       C. Scanner                                       D. BufferedReader
10.4.2     操作题
   1. 在异常发生时,可以使用异常对象的 printStackTrace()显示堆栈追踪,如何改写以
下程序,使得异常发生时,可将堆栈追踪附加至 UTF-8 编码的 exception.log 文档:
  package cc.openhome;
  import java.io.*;
  public class Exercise1 {
      public static void dump(InputStream src, OutputStream dest)
                                  throws IOException {
          try (InputStream input = src; OutputStream output = dest) {
              byte[] data = new byte[1024];
                                                                                    317
              int length = -1;
              while ((length = input.read(data)) != -1) {
                  output.write(data, 0, length);
              }
          } catch(IOException ex) {
              throw ex;
          }
        }
    }
     2. 请撰写程序,可将任何编码的文本文件读入,指定文档名转存为 UTF-8 的文本
文件。
318
              整合数据库 14
学习目标
 了解 JDBC 架构
 使用 JDBC API
 了解交易与隔离层级
 认识 RowSet
14.1 JDBC 入门
    JDBC 是用于执行 SQL 的解决方案,开发人员使用 JDBC 的标准接口,数据库厂商则
对接口进行操作,开发人员无须接触底层数据库驱动程序的差异性。在本章中,会介绍一
些 JDBC 基本 API 的使用与概念,让你对 Java 如何存取数据库有所认识。
14.1.1      JDBC 简介
    在正式介绍 JDBC 前,先来认识应用程序如何与数据库进行沟通。数据库本身是个独
立运行的应用程序,你撰写的应用程序是利用通信协议对数据库进行指令交换,以进行数
据的增删查找,如图 14.1 所示。
                                            通信协议
                                                                  数据库
                     应用程序
                           图 14.1 应用程序与数据库利用通信协议沟通
    通常你的应用程序会利用一组专门与数据库进行通信协议的链接库,以简化与数据库
沟通时的程序撰写,如图 14.2 所示。
                       应用程序
                                            通信协议
                       链接库                                       资料库
                           图 14.2 应用程序调用链接库以简化程序撰写
    问题的重点在于,应用程序如何调用这组链接库?不同的数据库通常会有不同的通信
协议,用来联机不同数据库的链接库,在 API 上也会有所不同。如果你的应用程序直接使
用这些链接库,例如:
    XySqlConnection conn = new XySqlConnection("localhost", "root", "1234");
    conn.selectDB("gossip");
    XySqlQuery query = conn.query("SELECT * FROM T_USER");
    假设这段程序代码中的 API 是某 Xy 数据库厂商链接库所提供,你的应用程序中要使
用到数据库联机时,都会直接调用这些 API,若哪天应用程序打算改用 Ab 厂商数据库及
其提供的数据库联机 API,就得修改相关的程序代码。
    另一个考虑是,若 Xy 数据库厂商的链接库底层实际使用了与操作系统相依的功能,
若你只打算换个操作系统,就还得先考虑一下,是否有提供该平台的数据库链接库。
    更换数据库的需求并不是没有,应用程序跨平台也是经常的需求,JDBC 基本上就是
用来解决这些问题。JDBC 全名 Java DataBase Connectivity ,是 Java 联机数据库的标准
规范。具体而言,它定义一组标准类与接口,应用程序需要联机数据库时调用这组标准 API,
454
                                                                                        14
                                                                           整合数据库
而标准 API 中的接口会由数据库厂商操作,通常称为 JDBC 驱动程序(Driver),如图 14.3
所示。
                              应用程序
                           JDBC 标准 API       通信协议
                                                             数据库
                           JDBC 驱动程序
                                图 14.3 应用程序调用 JDBC 标准 API
     JDBC 标准主要分为两个部分: JDBC 应 用 程序开 发 者接 口 (Application Developer
Interface)以及 JDBC 驱动程序开发者接口(Driver Developer Interface)。如果你的应用程序需
要联机数据库,         就是调用 JDBC 应用程序开发者接口,                    相关 API 主要在 java.sql 与 javax.sql
两个包中,也是本章节说明的重点;JDBC 驱动程序开发者接口是数据库厂商操作驱动程
序时的规范,一般开发者并不用了解,本书不予说明,如图 14.4 所示。
                                            应用程序
                      驱动程序
                                 图 14.4 JDBC 应用程序开发者接口
     举个例子来说,你的应用程序会使用 JDBC 联机数据库:
     Connection conn = DriverManager.getConnection(...);
     Statement st = conn.createStatement();
     ResultSet rs = st.executeQuery("SELECT * FROM T_USER");
     其中粗体字部分就是标准类(像是 DriverManager)与接口(像是 Connection、Statement 、
ResultSet)等标准      API。假设这段程序代码是联机 MySQL 数据库,则需要在 CLASSPATH
中设定 JDBC 驱动程序,具体来说,就是在 CLASSPATH 中设定一个 JAR 文档,此时应
用程序、JDBC 与数据库的关系如图 14.5 所示。
                                                                                    455
                          应用程序
                                            MySQL 通信协议
                                                              MySQL 数据库
                  MySQL JDBC API 驱动程序
                               图 14.5 应用程序、JDBC 与数据库的关系
    如果将来要换为 Oracle 数据库,只要置换 Oracle 驱动程序。具体来说,就是在
CLASSPATH 改设为 Oracle 驱动程序的 JAR 文档,                      然而应用程序本身不用修改,     如图 14.6
所示。
                                     保持不变
                             应用程序
                                              Oracle 通信协议
                                                               Oracle 数据库
                      Oracle JDBC 驱动程序
                                图 14.6 置换驱动程序不用修改应用程序
    如果开发应用程序操作数据库时,是通过 JDBC 提供的接口来设计程序,理论上在必
须更换数据库时,应用程序无须进行修改,只需要更换数据库驱动程序成果,即可对另一
个数据库进行操作。
    JDBC 希望达到的目的,是让 Java 程序设计人员在撰写数据库操作程序时,可以有个
统一的接口,无须依赖特定数据库 API,希望达到“写一个 Java 程序,操作所有数据库”
的目的。
        实际上在撰写 Java 程序时,会因为使用了数据库特定功能,而在转移数据库时仍得对程
        序进行修改。例如使用了某数据库的特定 SQL 语法、数据类型或内部函数调用等。
    厂商在操作 JDBC 驱动程序时,依操作方式可将驱动程序分为四种类型。
      Type 1:JDBC-ODBC Bridge Driver。ODBC(Open DataBase Connectivity)是由
       Microsoft 主导的数据库连接标准,(基本上 JDBC 是参考 ODBC 制订而来),所以
       ODBC 在 Microsoft 系统上最为成熟,例如 Microsoft Access 数据库存取就是使用
       ODBC。
       Type 1 驱动程序会将 JDBC 调用转换为对 ODBC 驱动程序的调用,由 ODBC 驱
       动程序操作数据库,如图 14.7 所示。
                            应用程序
                         Type 1 驱动程序         通信协议
                                                                 数据库
                        ODBC 驱动程序
                                  图 14.7 JDBC-ODBC Bridge Driver
456
                                                                        14
                                                                整合数据库
  由于利用现成的 ODBC 架构,只需要将 JDBC 调用转换为 ODBC 调用,所以要操作
这种驱动程序非常简单。在 Oracle/Sun JDK 中就附带有驱动程序,包名称为 sun.jdbc.odbc
开头。
  不过由于 JDBC 与 ODBC 并非一对一的对应,所以部分调用无法直接转换,因此有些
功能受限,而多层调用转换的结果,访问速度也受到限制,ODBC 本身需在平台上先设定
好,弹性不足,ODBC 驱动程序本身也有跨平台限制。
   Type 2:Native API Driver。这个类型的驱动程序会以原生(Native)方式,调用数
    据库提供的原生链接库(通常由 C/C++操作),JDBC 的方法调用都会转换为原生链
    接库中的相关 API 调用。由于使用了原生链接库,所以驱动程序本身与平台相依,
    没有达到 JDBC 驱动程序的目标之一:                  跨平台。      不过由于直接调用数据库原生 API,
    因此在速度上,有机会成为四种类型中最快的驱动程序,如图 14.8 所示。
                    应用程序
                 Type 2 驱动程序         通信协议
                                                        数据库
                  链接库(C/C++)
                             图 14.8 Native API Driver
    Type 2 驱动程序有机会成为速度最快的驱动程序,速度的优势是在于获得数据库
    响应数据后,创建相关 JDBC API 操作对象时,然而驱动程序本身无法跨平台,
    使用前必须先在各平台进行驱动程序的安装设定(像是安装数据库专属的原生链
    接库)。
   Type 3:JDBC-Net Driver。这类型的 JDBC 驱动程序会将 JDBC 方法调用转换为
    特定的网络协议(Protocol)调用,目的是与远程与数据库特定的中介服务器或组件
    进行协议操作,而中介服务器或组件再真正与数据库进行操作,如图 14.9 所示。
                应用程序
                                 通信协议                通信协议
             Type 3 驱动程序                                    数据库
                             图 14.9 JDBC-Net Driver
  由于实际与中介服务器或组件进行沟通时,是利用网络协议的方式,所以客户端这里
安装的驱动程序,可以使用纯粹的 Java 技术来实现(基本上就是将 JDBC 调用对应至网络
协议而已),因此这种类型的驱动程序可以跨平台。使用这种类型驱动程序的弹性高,例如
可以设计一个中介组件,JDBC 驱动程序与中介组件间的协议是固定的,如果需要更换数
据库系统,则只需要更换中介组件,但客户端不受影响,驱动程序也无须更换,但由于通
过中介服务器转换,速度较慢,获得架构弹性是使用这种类型驱动程序的目的。
                                                                    457
       Type 4:Native Protocol Driver。这种类型驱动程序操作通常由数据库厂商直接提
        供,驱动程序操作会将 JDBC 调用转换为与数据库特定的网络协议,以与数据库进
        行沟通操作,如图 14.10 所示。
                         应用程序
                                           通信协议
                    Type 4 驱动程序                                数据库
                                图 14.10 Notive Protocla Driver
    由于这种类型驱动程序主要的作用,是将 JDBC 调用转换为特定网络协议,所以驱动
程序可以使用纯粹 Java 技术实现,因此这种类型驱动程序可以跨平台,在效能上也能有
不错的表现。在不需要如 Type 3 获得架构上的弹性时,通常会使用这种类型驱动程序,
算是最常见的驱动程序类型。
    在接下来的内容中,将使用 MySQL 数据库系统进行操作,并使用 Type 4 驱动程序。
可以在以下的网址取得 MySQL 的 JDBC 驱动程序:
    http://www.mysql.com/products/connector/j/index.html
          数据库系统的使用与操作是个很大的主题,本书中并不针对这方面详加探讨,请寻找相关
          的数据库系统相关书籍自行学习。为了能顺利练习这个章节的范例,附录中包括了 MySQL
          数据库系统的简介,足够让你了解本章使用的一些数据库操作指令。
14.1.2      连接数据库
    为了要连接数据库系统,必须要有厂商操作的 JDBC 驱动程序,必须在 CLASSPATH
中设定驱动程序 JAR 文档。如果使用 IDE,程序项目会有管理 CLASSPATH 的方式,通
常是“新增 JAR”之类的指令。例如 NetBeans 项目的话,可以这样新增链接库:
    (1) 在项目上的 Libraries 节点上右击,           从弹出的快捷菜单中选择 Add JAR/Folder 命令。
    (2) 在出现的 Add JAR/Folder 对话框中,选择驱动程序 JAR 文档后单击“打开”按钮。
    (3) 确认项目的 Libraries 节点上出现 JAR 文档,这表示 JAR 文档已在项目的
CLASSPATH 管理中。
    基本数据库操作相关的 JDBC 接口或类是位于 java.sql 包中。要取得数据库联机,必
须有几个动作:
       注册 Driver 操作对象。
       取得 Connection 操作对象。
       关闭 Connection 操作对象。
458
                                                                               14
                                                                       整合数据库
           IDE 也可以管理常用的 JAR 文档(有的 JAR 文档会内建),例如在 NetBeans 的“库”节
           点上右击,在弹出的快捷菜单中选择“添加库”命令,打开“添加库”对话框,此时会出
           现 NetBeans 已管理(或内建)的常用 JAR,如图 14.11 所示。
                                         图 14.11 管理常用的 JAR
     1. 注册 Driver 操作对象
     操作 Driver 接口的对象是 JDBC 进行数据库存取的起点,以 MySQL 操作的驱动程序
为例,com.mysql.jdbc.Driver 类操作了 java.sql.Driver 接口,管理 Driver 操作对象的类是
java.sql.DriverManager。基本上,必须调用其静态方法 registerDriver()进行注册:
DriverManager.registerDriver(new com.mysql.jdbc.Driver());
     不过实际上很少自行撰写程序代码进行这个动作,只要想办法加载 Driver 接口的操作
类.class 文档,就会完成注册。例如,可以通过 java.lang.Class 类的 forName()(下一章会详
细说明这个方法),动态加载驱动程序类:
     try {
         Class.forName("com.mysql.jdbc.Driver");
     }
     catch(ClassNotFoundException e) {
         throw new RuntimeException("找不到指定的类");
     }
     如果查看 MySQL 的 Driver 类操作原始码:
     package com.mysql.jdbc;
     import java.sql.SQLException;
     public class Driver extends NonRegisteringDriver
                                          implements java.sql.Driver {
                                                                           459
         static {
             try {
                 java.sql.DriverManager.registerDriver(new Driver());
             } catch (SQLException E) {
                 throw new RuntimeException("Can't register driver!");
             }
         }
         public Driver() throws SQLException {}
     }
     可以发现,在 static 区块中进行了注册 Driver 实例的动作,而 static 区块会在载
入.class 文档时执行(下一章会详细说明)。使用 JDBC 时,要求加载.class 文档的方式有四种:
     (1) 使用 Class.forName()。
     (2) 自行建立 Driver 接口操作类的实例。
     (3) 启动 JVM 时指定 jdbc.drivers 属性。
     (4) 设定 JAR 中 /services/java.sql.Driver 文档。
     第一种方式刚才已经说明。第二种方式就是直接撰写程序代码:
     java.sql.Driver driver = new com.mysql.jdbc.Driver();
     由于要建立对象,基本上就要加载.class 文档,自然也就会执行类的静态区块完成驱
动程序注册。第三种方式就是执行 java 指令时如下:
     > java –Djdbc.drivers=com.mysql.jdbc.Driver;ooo.XXXDriver YourProgram
     应用程序可能同时联机多个厂商的数据库,所以 DriverManager 也可以注册多个驱动程
序实例,以上方式如果需要指定多个驱动程序类,就用分号分隔。第四种方式则是 JDK6
之后 JDBC 4.0 新特性,只要在驱动程序操作的 JAR 文档/services 文件夹中,放置一个
java.sql.Driver 文档,当中撰写 Driver 接口的操作类名称全名,DriverManager 会自动读取这
个文档并找到指定类进行注册。
     2. 取得 Connection 操作对象
     Connection 接口的操作对象是数据库联机代表对象,要取得 Connection 操作对象,可以
通过 DriverManager 的 getConnection():
     Connection conn = DriverManager.getConnection(
                           jdbcUrl, username, password);
     除了基本的用户名称、密码之外,还必须提供 JDBC URL,其定义了连接数据库时的
协议、子协议、数据源识别:
协议:子协议:数据源识别
     除了“协议”在 JDBC URL 中总是 jdbc 开始之外,JDBC URL 格式各家数据库都不
相同,必须查询数据库产品使用手册。以下以 MySQL 为例,“子协议”是桥接的驱动程
序、数据库产品名称或联机机制,例如使用 MySQL 的话,子协议名称是 mysql。“数据
460
                                                                                               14
                                                                                 整合数据库
源识别”标出数据库的地址、端口号、名称、用户、密码等信息。举个例子来说,MySQL
的 JDBC URL 撰写方式如下:
     jdbc:mysql://主机名:端口/数据库名称?参数=值&参数=值
     主机名可以是本机(localhost)或其他联机主机名、地址,MySQL 端口默认为 3306。
例如要连接 demo 数据库,并指明用户名称与密码,可以这样指定:
     jdbc:mysql://localhost:3306/demo?user=root&password=123456
     如果要使用中文存取,还必须给定参数 useUnicode 及 characterEncoding,表明是否
使用 Unicode,并指定字符编码方式。例如(假设数据库表格编码使用 UTF8):
     jdbc:mysql://localhost:3306/demo?user=root&password=123&useUnicode=true&characterEncodin
g=UTF8
     有的时候会将 JDBC URL 撰写在 XML 配置文件中,此时不能直接在 XML 中写&符号,
而必须改写为&amp;替代字符。例如:
     jdbc:mysql://localhost:3306/demo?user=root&password=123&useUnicode=true&amp;characterEnc
oding=UTF8
     如果要直接通过 DriverManager 的 getConnection()连接数据库,一个比较完整的代码段
如下:
     String url =  "jdbc:mysql://localhost:3306/demo";
     String user = "root";
     String password = "123456";
     Connection conn = null;
     SQLException ex = null;
     try {
         conn = DriverManager.getConnection(url, user, password);
         ...
     }
     catch(SQLException e) {
         ex = e;
     }
     finally {
         if(conn != null) {
             try {
                 conn.close();
             }
             catch(SQLException e) {
                 if(ex == null) {
                     ex = e;
                 }
                 else {
                     ex.addSuppressed(e);
                 }
             }
         }
                                                                                           461
        if(ex != null) {
            throw new RuntimeException(ex);
        }
    }
    SQLException  是在处理 JDBC 时常遇到的异常对象,为数据库操作过程发生错误时的
代表对象。SQLException 是受检异常(Checked                Exception),必须使用 try...catch...finally
明确处理,在异常发生时尝试关闭相关资源。
          SQLException 有个子类 SQLWarning,如果数据库执行过程中发生了一些警示信息,会建立
          SQLWarning 但不会抛出(throw),     而是以链接方式收集起来。            可以使用 Connection、
                                                                              Statement、
          ResultSet 的 getWarnings()来取得第一个 SQLWarning,使用这个对象的 getNextWarning()
          可以取得下一个 SQLWarning,由于它是 SQLException 的子类,所以必要时也可当作异常抛出
    3. 关闭 Connection 操作对象
    取得 Connection 对象之后,可以使用 isClosed()方法测试与数据库的连接是否关闭。
在操作完数据库之后,若确定不再需要连接,则必须使用 close()来关闭与数据库的连接,
以释放连接时相关的必要资源,像是联机相关对象、授权资源等。
    除了像前一个范例代码段,自行撰写 try...catch...finally 尝试关闭 Connection 之外,
从 JDK7 之后,     JDBC 的 Connection、   Statement、 ResultSet 等接口都是 java.lang.AutoClosable
子接口,因此可以使用尝试自动关闭资源语法来简化程序撰写。例如前一个程序片段,可
以简化为以下:
    String url =  "jdbc:mysql://localhost:3306/demo";
    String user = "root";
    String password = "123456";
    try(Connection conn = DriverManager.getConnection(url, user, password)) {
        ...
    }
    catch(SQLException e) {
        throw new RuntimeException(e);
    }
    以上是撰写程序上的一些简介,然而在底层, DriverManager 如 何进行联机呢?
DriverManager 会在循环中逐一取出注册的每个 Driver 实例,使用指定的 JDBC URL 来调
用 Driver 的 connect()方法,尝试取得 Connection 实例。以下是 DriverManager 中相关原始
码的重点节录:
    SQLException reason = null;
    for (int i = 0; i < drivers.size(); i++) { // 逐一取得 Driver 实例
        ...
        DriverInfo di = (DriverInfo)drivers.elementAt(i);
        ...
        try {
            Connection result = di.driver.connect(url, info); // 尝试联机
462
                                                                                         14
                                                                             整合数据库
             if (result != null) {
                 return (result);   // 取得 Connection 就返回
             }
         } catch (SQLException ex) {
             if (reason == null) { // 记录第一个发生的异常
                    reason = ex;
            }
         }
     }
     if (reason != null)    {
         println("getConnection failed: " + reason);
         throw reason; // 如果有异常对象就抛出
     }
     throw new SQLException(  // 没有适用的 Driver 实例,抛出异常
              "No suitable driver found for "+ url, "08001");
     Driver  的 connect() 方法在无法取得 Connection 时会返回 null ,所以简单来说,
DriverManager 就是逐一使用 Driver 实例尝试联机。如果联机成功就返回 Connection                            对象,
如果当中有异常发生,DriverManager                 会记录第一个异常,并继续尝试其他的                    Driver,在所
有  Driver 都试过了也无法取得联机,若原先尝试过程中有记录异常就抛出,没有的话,也
是抛出异常告知没有适合的驱动程序。
           偶而为了除错或其他目的,也可自行建立 Driver 实例并调用其 connect() 方法以取得
           Connection 对象。例如:
           Properties props = new Properties();
           props.put("user", "root");
           props.put("password", "123456");
           Driver driver = new com.mysql.jdbc.Driver();
           conn = driver.connect(url, props);
     以下先来示范联机数据库的完整范例。假设使用了以下的指令在 MySQL 后建立了
demo 数据库:
CREATE schema demo;
     以下撰写一个简单范例,测试一下可否联机数据库并取得 Connection 实例:
 JDBCDemo ConnectionDemo.java
package cc.openhome;
import java.sql.*;
public class ConnectionDemo {
    public static void main(String[] args)
                               throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");           加载驱动程序
        String jdbcUrl = "jdbc:mysql://localhost:3306/demo";
                                                                                     463
        String user = "root";
        String passwd = "123456";
                                        取得 Connection 对象
        try(Connection conn =
                DriverManager.getConnection(jdbcUrl, user, passwd)) {
            System.out.printf("数据库已%s%n",
                               conn.isClosed() ? "关闭" : "打开");
        }
    }
}
    这个范例对 Connection 使用尝试自动关闭资源语法,                         所以执行完 try 区块后,    Connection
的  close()就会被调用。如果顺利取得联机,程序执行结果如下:
 数据库已打开
          实际上很少直接从 DriverManager 中取得 Connection 想想看,如果你在设计 API,用户
          无法提供 JDBC URL、名称、密码时,你要怎么取得 Connectioin?答案是通过稍后要介
          绍的 javax.sql.DataSource。
14.1.3       使用 Statement、ResultSet
    Connection   是 数 据 库 连 接 的 代 表 对 象 , 接 下 来 要 执 行 SQL 的 话 , 必 须 取 得
java.sql.Statement   操 作对象,它是 SQL 描述的代表对象。可以使用 Connection 的
createStatement()建立 Statement 对象:
    Statement stmt = conn.createStatement();
    取得 Statement 对象之后,         可以使用 executeUpdate()、      executeQuery()等方法来执行 SQL。
executeUpdate()主要用来执行 CREATE TABLE、INSERT、DROP TABLE、ALTER TABLE            等会改变数
据库内容的 SQL。例如,可以在 demo 数据库中建立一个 t_message 表格:
    Use demo;
    CREATE TABLE t_message (
        id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
        name CHAR(20) NOT NULL,
        email CHAR(40),
        msg TEXT NOT NULL
    ) CHARSET=UTF8;
    如果要在这个表格中插入一笔数据,可以这样使用 Statement 的 executeUpdate()方法:
    stmt.executeUpdate("INSERT INTO t_message VALUES(1, 'justin', " +
                "'justin@mail.com', 'mesage...')");
    Statement  的 executeQuery()方法用于 SELECT 等查询数据库的 SQL,executeUpdate()会
返回 int 结果,表示数据变动的笔数,executeQuery()会返回 java.sql.ResultSet 对象,代
表查询结果,查询结果会是一笔一笔的数据。可以使用 ResultSet 的 next()移动至下一笔数
464
                                                                              14
                                                                      整合数据库
据,它会返回 true 或 false 表示是否有下一笔数据,接着可以使用 getXXX()取得数据,如
getString()、getInt()、getFloat()、getDouble()等方法,分别取得相对应的字段类型数据。
getXXX()方法都提供有依域名取得数据,或是依字段顺序取得数据的方法。一个例子如下,
指定域名来取得数据:
     ResultSet result = stmt.executeQuery("SELECT * FROM t_message");
     while(result.next()) {
         int id = result.getInt("id");
         String name = result.getString("name");
         String email = result.getString("email");
         String msg = result.getString("msg");
         // ...
     }
     使用查询结果字段顺序来显示结果的方式如下(注意索引是从 1 开始):
     ResultSet result = stmt.executeQuery("SELECT * FROM t_message");
     while(result.next()) {
         int id = result.getInt(1);
         String name = result.getString(2);
         String email = result.getString(3);
         String msg = result.getString(4);
         // ...
     }
     Statement  的 execute()可以用来执行 SQL,并可以测试 SQL 是执行查询或更新,返回
true  表示 SQL 执行将返回 ResultSet 作为查询结果,此时可以使用 getResultSet()取得
ResultSet 对象。如果 execute()返回 false,表示               SQL 执行会返回更新笔数或没有结果,此
时可以使用 getUpdateCount()取得更新笔数。如果事先无法得知 SQL 是进行查询或更新,就
可以使用 execute()。例如:
     if(stmt.execute(sql)) {
         ResultSet rs = stmt.getResultSet();  // 取得查询结果 ResultSet
         ...
     }
     else { // 这是个更新操作
         int updated = stmt.getUpdateCount(); // 取得更新笔数
         ...
     }
     视需求而定,Statement 或 ResultSet 在不使用时,可以使用 close()将之关闭,以释放
相关资源。Statement 关闭时,所关联的 ResultSet 也会自动关闭。
     接下来以一个简单的留言板作为示范,首先制作一个 MessageDAO 来存取数据库:
 JDBCDemo MessageDAO.java
package cc.openhome;
import java.sql.*;
                                                                          465
import java.util.*;
public class MessageDAO {
    private String url;
    private String user;
    private String passwd;
    public MessageDAO(String url, String user, String passwd) {
        this.url = url;
        this.user = user;
        this.passwd = passwd;
    }
                                   这个方法会在数据库中新增留言
                                                    取得 Connection 对象
    public void add(Message message) {
        try(Connection conn = DriverManager.getConnection(url, user, passwd);
            Statement statement = conn.createStatement()) {          建立 Statement 对象
            statement.executeUpdate(         执行 SQL 描述句
                    "INSERT INTO t_message(name, email, msg) VALUES ('"
                      + message.getName() + "', '"
                      + message.getEmail() +"', '"
                      + message.getMsg() + "')");
        } catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
    }
    public List<Message> get() {          这个方法会从数据库中查询所有留言
        List<Message> messages = null;
        try(Connection conn = DriverManager.getConnection(url, user, passwd);
            Statement statement = conn.createStatement()) {
            ResultSet result = statement.executeQuery(
                                         "SELECT * FROM t_message");
            messages = new ArrayList<>();
            while (result.next()) {
                Message message = new Message();
                message.setId(result.getLong(1));
                message.setName(result.getString(2));
                message.setEmail(result.getString(3));
                message.setMsg(result.getString(4));
                messages.add(message);
            }
        } catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
        return messages;
    }
}
     这个对象会从 DriverManager 取得 Connection 对象。add()接受一个 Message 对象,
操作中在数据库中利用 Statement 对象,执行 SQL 描述来新增一笔留言。get ()会从数
据库中取回所有留言,并放在一个 List<Message>对象中返回。
466
                                                                    14
                                                            整合数据库
          JDBC 规范提到关闭 Connection 时,会关闭相关资源,但没有明确说明是哪些相关资源。
          通常驱动程序操作时,会在关闭 Connection 时,一并关闭关联的 Statement,但最好留意
          是否真的关闭了资源,自行关闭 Statement 是比较保险的做法。以上范例对 Connection
          与 Statement 使用了尝试自动关闭资源语法。
     范例中的 Message 只是用来封装留言信息的简单类:
 JDBCDemo Message.java
package cc.openhome;
import java.io.Serializable;
public class Message implements Serializable {
    private Long id;
    private String name;
    private String email;
    private String msg;
    public Message() {}
    public Message(String name, String email, String msg) {
        this.name = name;
        this.email = email;
        this.msg = msg;
    }
    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getMsg() {
        return msg;
    }
    public void setMsg(String msg) {
        this.msg = msg;
    }
                                                                467
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
     可以撰写一个简单的 MessageDAODemo 类来使用 MessageDAO。例如:
  JDBCDemo MessageDAODemo.java
package cc.openhome;
import java.util.Scanner;
public class MessageDAODemo {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in, "Big5");
        MessageDAO dao = new MessageDAO(
                "jdbc:mysql://localhost:3306/demo?" +
                "useUnicode=true&characterEncoding=UTF8",
                "root", "123456");
        while(true) {
            System.out.print("(1) 显示留言 (2) 新增留言:");
            switch(Integer.parseInt(scanner.nextLine())) {
                case 1:
                    for(Message message : dao.get()) {
                        System.out.printf("%d\t%s\t%s\t%s%n",
                                message.getId(),
                                message.getName(),
                                message.getEmail(),
                                message.getMsg());
                    }
                    break;
                case 2:
                    System.out.print("姓名:");
                    String name = scanner.nextLine();
                    System.out.print("邮件:");
                    String email = scanner.nextLine();
                    System.out.print("留言:");
                    String msg = scanner.nextLine();
                    dao.add(new Message(name, email, msg));
            }
        }
468
                                                                                  14
                                                                        整合数据库
  }
}
   以下是个执行的范例:
   (1) 显示留言 (2) 新增留言:2
   姓名:良葛格
   邮件:caterpillar@openhome.cc
   留言:这是一篇测试留言!
   (1) 显示留言 (2) 新增留言:1
   1        良葛格        caterpillar@openhome.cc 这是一篇测试留言!
         范例中怎么没有用 Class.forName()载入 Driver 操作类呢?别忘了,JDK6 之后支持 JDBC
         4.0,只要驱动程序 JAR 中有/services/java.sql.Driver 文档,就会自动读取当中设定的
         Driver 操作类。
14.1.4      使用 PreparedStatement、CallableStatement
   Statement 在执行 executeQuery()、executeUpdate()等方法时,如果有些部分是动态的数
据,必须使用+运算符串接字符串以组成完整的 SQL 语句,十分不方便。例如前面范例中
在新增留言时,必须这样串接 SQL 语句:
   statement.executeUpdate(
        "INSERT INTO t_message(name, email, msg) VALUES (
        '"+ message.getName() + "',
        '"+ message.getEmail() +"',
        '"+ message.getMsg() + "')");
   如果有些操作只是 SQL 语句当中某些参数会有所不同,其余的 SQL 子句皆相同,则
可以使用 java.sql.PreparedStatement。      可以使用 Connection 的 preparedStatement()方法建立
好预先编译(precompile)的 SQL 语句,当中参数会变动的部分,先指定“?”这个占位字
符。例如:
   PreparedStatement stmt = conn.prepareStatement(
                       "INSERT INTO t_message VALUES(?, ?, ?, ?)");
   等到需要真正指定参数执行时,再使用相对应的 setInt()、setString()等方法,指定
“?”处真正应该有的参数。例如:
   stmt.setInt(1, 2);
   stmt.setString(2, "momor");
   stmt.setString(3, "momor@mail.com");
   stmt.setString(4, "message2...");
   stmt.executeUpdate();
   stmt.clearParameters();
                                                                              469
     要让 SQL 执行生效,要执行 executeUpdate()或 executeQuery()方法(如果是查询的话)。
在这次的 SQL 执行完毕后,可以调用 clearParameters()清除设置的参数,之后就能再次使
用这个 PreparedStatement 实例,所以使用 PreparedStatement,可以让你先准备好一段 SQL,
并重复使用这段 SQL 语句。
     可以使用 PreparedStatement 改写前面 MessageDAO 中 add()执行 SQL 语句的部分。例如:
  JDBCDemo MessageDAO2.java
package cc.openhome;
import java.sql.*;
import java.util.*;
public class MessageDAO {
    ...
    public void add(Message message) {
        try(Connection conn = DriverManager.getConnection(url, user, passwd);
            PreparedStatement statement = conn.prepareStatement(
                  "INSERT INTO t_message(name, email, msg) VALUES (?,?,?)")) {
            statement.setString(1, message.getName());
            statement.setString(2, message.getEmail());
            statement.setString(3, message.getMsg());
            statement.executeUpdate();
        } catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
    }
    ...
}
     这样的写法显然比串接 SQL 的方式好得多。不过,使用 PreparedStatement 的好处不仅
如此,之前提过,在这次的 SQL 执行完毕后,可以调用 clearParameters()清除设置的参数,
之后就可以再次使用这个 PreparedStatement 实例,也就是说必要的话,可以考虑制作描述
句池(Statement Pool)将一些频繁使用的 PreparedStatement 重复使用,减少生成对象的负担。
     在驱动程序支持的情况下,使用 PreparedStatement,可以将 SQL 描述预编译为数据库
的执行指令。由于已经是数据库的可执行指令,执行速度可以快许多[例如若使用 Java DB,
其驱动程序可以将 SQL 预编译为位码(byte code)格式,在 JVM 中执行就快许多了],而不
像 Statement 对象,是在执行时将 SQL 直接送到数据库,由数据库做剖析、直译再执行。
     使用 PreparedStatement 在安全上也可以有点贡献。举个例子来说,如果原先使用串接
字符串的方式来执行 SQL:
     Statement statement = connection.createStatement();
     String queryString = "SELECT * FROM user_table WHERE username='" +
              username + "' AND password='" + password + "'";
470
                                                                             14
                                                                     整合数据库
    ResultSet resultSet = statement.executeQuery(queryString);
    其中 username 与 password 若是来自用户的输入字符串,原本是希望用户安分地输入名
称密码,组合之后的 SQL 应该像是这样:
    SELECT * FROM user_table
         WHERE username='caterpillar' AND password='123456'
    但如果用户在密码的部分,输入了“' OR '1'='1”这样的字符串,而你又没有针对用户
的输入进行字符检查过滤动作,这个奇怪的字符串最后组合出来的 SQL 会如下:
    SELECT * FROM user_table
         WHERE username='caterpillar' AND password='' OR '1'='1'
    方框是密码请求参数的部分,将方框拿掉会更清楚地看出这个 SQL 有什么问题!
    SELECT * FROM user_table
         WHERE username='caterpillar' AND password='' OR '1'='1'
    AND 子句之后的判断式永远成立,也就是说,用户不用输入正确的密码,也可以查询
出所有的数据,这就是 SQL Injection 的简单例子。
    以串接的方式组合 SQL 描述基本上就会有 SQL Injection 的隐忧,如果这样改用
    PreparedStatement  的话:
    PreparedStatement stmt = conn.prepareStatement(
        "SELECT * FROM user_table WHERE username=? AND password=?");
    stmt.setString(1, username);
    stmt.setString(2, password);
    在这里 username 与 password 将被视作是 SQL 中纯粹的字符串,而不会被当作 SQL 语
法来解释,所以就可避免这个例子的 SQL Injection 问题。
    其实问题不仅是在串接字符串本身麻烦,以及 SQL Injection 发生的可能性。由于+串
接字符串会产生新的 String 对象,如果串接字符串动作经常进行(例如在循环中进行 SQL
串接的动作),那会是效能负担上的隐忧(如果真的非得串接 SQL ,至少要考虑使用
StringBuffer 或  JDK 5.0 之后的 StringBuilder)。
    如果撰写数据库的预存程序(Stored Procedure),并想使用 JDBC 来调用,则可使用
java.sql.CallableStatement 。调用的基本语法如下:
    {?= call <程序名称>[<自变量 1>,<自变量 2>, ...]}
    {call <程序名称>[<自变量 1>,<自变量 2>, ...]}
    CallableStatement  的 API 使用,基本上与 PreparedStatement 差别不大,除了必须调用
prepareCall()建立 CallableStatement     异常外,一样是使用 setXXX()设定参数,如果是查询
操作,使用 executeQuery() ,如果是更新操作,使用 executeUpdate() 。另外,可以使用
registerOutParameter()注册输出参数等。
          使用 JDBC 的 CallableStatement 调用预存程序,重点是在于了解各个数据库的预存程序
          如何撰写及相关事宜,用 JDBC 调用预存程序,也表示应用程序将与数据库产生直接的相
          依性。
                                                                         471
    在使用 PreparedStatement 或 CallableStatement 时,必须注意 SQL 类型与 Java 数据类
型的对应,因为两者本身并不是一对一对应,java.sql.Types 定义了一些常数代表 SQL 类
型。表 14.1 所示为 JDBC 规范建议的 SQL 类型与 Java 类型的对应。
                          表 14.1 Java 类型与 SQL 类型对应
                  Java 类型                                 SQL 类型
  boolean                                 BIT
  byte                                    TINYINT
  short                                   SMALLINT
  int                                     INTEGER
  long                                    BIGINT
  float                                   FLOAT
  double                                  DOUBLE
  byte[]                                  BINARY、VARBINARY、LONGBINARY
  java.lang.String                        CHAR、VARCHAR、LONGVARCHAR
  java.math.BigDecimal                    NUMERIC、DECIMAL
  java.sql.Date                           DATE
  java.sql.Time                           TIME
  java.sql.Timestamp                      TIMESTAMP
    其中要注意的是,日期时间在 JDBC 中,并不是使用 java.util.Date,这个对象可代表
的日期时间格式是“年、月、日、时、分、秒、毫秒”。在 JDBC 中要表示日期,是使用
java.sql.Date,其日期格式是“年、月、日”,要表示时间的话则是使用 java.sql.Time,
其时间格式为“时、分、秒”,如果要表示“时、分、秒、微秒”的格式,则是使用
java.sql.Timestamp。
14.2       JDBC 进阶
    上一节介绍了 JDBC 入门概念与相关 API,在这一节,将说明更多进阶 API 的使用,
像是使用 DataSource 取得 Connection、使用 PreparedStatement、使用 ResultSet 进行更新操
作等。
14.2.1      使用 DataSource 取得联机
    前面的 MessageDAO 范例必须告知 DriverManager 有关 JDBC URL、用户名称、密码等信
息,以取得 Connection 对象,然而实际应用程序开发时,JDBC URL、用户名称、密码等
信息是很敏感的信息,有些开发人员根本无从得知,如果 MessageDAO 的用户无法告知这些
信息,你如何改写 MessageDAO?
472
                                                                                       14
                                                                               整合数据库
     答案是可以让 MessageDAO 依赖于 javax.sql.DataSource 接口,可以通过其定义的
getConnection()方法取得 Connection。例如:
  JDBCDemo MessageDAO3.java
package cc.openhome;
import java.sql.*;
import java.util.*;
import javax.sql.DataSource;
public class MessageDAO3 {
    private DataSource dataSource;
    public MessageDAO3(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    public void add(Message message) {
        try(Connection conn = dataSource.getConnection();
            PreparedStatement statement = conn.prepareStatement(
                  "INSERT INTO t_message(name, email, msg) VALUES (?,?,?)")) {
            ...
        } catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
    }
    public List<Message> get() {
        List<Message> messages = null;
        try(Connection conn =  dataSource.getConnection();
            Statement statement = conn.createStatement()) {
            ...
        } catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
        return messages;
    }
}
     单看这个 MessageDAO3,并不会知道 DataSource 操作对象是从哪个 URL、使用哪个名称、
密码、内部如何建立 Connection,日后要修改数据库服务器主机位置,或者是为了打算重
复利用 Connection 对象而想要加入联机池(Connection Pool)机制等情况,这个 MessageDAO3
都不用修改。
          要取得数据库联机,必须打开网络联机(中间经过实体网络),连接至数据库服务器后,进
          行协议交换(当然也就是数次的网络数据往来)以进行验证名称、密码等确认动作。也就是
                                                                                   473
          取得数据库联机事件耗时间及资源的动作。尽量利用已打开的联机,也就是重复利用取得
          的 Connection 实例,是改善数据库联机效能的一个方式。采用联机池是基本做法。
     例 如以 下范 例操作 具有简 单连 接池 的 DataSource , 示 范如 何重 复使 用已取 得 的
Connection:
 JDBCDemo SimpleConnectionPoolDataSource.java
package cc.openhome;
import java.util.*;
import java.io.*;
import java.sql.*;
import java.util.concurrent.Executor;
import java.util.logging.Logger;
import javax.sql.DataSource;
                                                              操作 DataSource
public class SimpleConnectionPoolDataSource implements DataSource {
    private Properties props;
    private String url;
    private String user;
    private String passwd;
    private int max; // 连接池中最大 Connection 数目
    private List<Connection> conns;         维护可重用的 Connection 对象
    public SimpleConnectionPoolDataSource()
            throws IOException, ClassNotFoundException {
        this("jdbc.properties");
    }
                                                  可指定.properties 文档
    public SimpleConnectionPoolDataSource(String configFile)
                           throws IOException, ClassNotFoundException {
        props = new Properties();
        props.load(new FileInputStream(configFile));
        url = props.getProperty("cc.openhome.url");
        user = props.getProperty("cc.openhome.user");
        passwd = props.getProperty("cc.openhome.password");
        max = Integer.parseInt(props.getProperty("cc.openhome.poolmax"));
        conns = Collections.synchronizedList(new ArrayList<Connection>());
    }
    public synchronized Connection getConnection() throws SQLException {
        if(conns.isEmpty()) {         如果 List 为空就建立新的 ConnectionWrapper
            return new ConnectionWrapper(
474
                                                                                       14
                                                                            整合数据库
                  DriverManager.getConnection(url, user, passwd),
                  conns,
                  max
          );
      }
      else {        否则返回 List 中一个 Connection
          return conns.remove(conns.size() - 1);
      }
  }                                            ConnectionWrapper 操作 Connection 界面
  private class ConnectionWrapper implements Connection {
      private Connection conn;
      private List<Connection> conns;
      private int max;
      public ConnectionWrapper(Connection conn,
                           List<Connection> conns, int max) {
          this.conn = conn;
          this.conns = conns;
          this.max = max;
      }
      @Override
      public void close() throws SQLException {
          if(conns.size() == max) {         如果超出最大可维护 Connection 数
              conn.close();                  量就关闭 Connection
          }
          else {
              conns.add(this);         否则放入 List 中以备重用
          }
      }
      @Override
      public Statement createStatement() throws SQLException {
          return conn.createStatement();
      }
      ...
  }
  ...
}
   SimpleConnectionPoolDataSource   操作了 DataSource 接口,其中使用 List<Connection>
实例维护可重用的          Connection,联机相关信息可以使用.properties                设定。如果客户端调
                                                                                   475
用 getConnection()方法尝试取得联机,若 List<Connection>为空,则建立新的 Connection 并
打包在 ConnectionWrapper 后返回,如果不为空就直接从 List<Connection>移出返回。
     ConnectionWrapper 操作了 Connection 接口,        大部分方法操作时都是直接委托给被打包
的 Connection 实例。ConnectionWrapper 操作 close() 方法时,会看看维护 Connection 的
List<Connection>容量是否到了最大值,如果是就直接关闭被打包的 Connection,否则就
将自己置入 List<Connection>以备重用。
     如果准备一个 jdbc.properties 如下:
  JDBCDemo jdbc.properties
cc.openhome.url=jdbc:mysql://localhost:3306/demo
cc.openhome.user=root
cc.openhome.password=123456
cc.openhome.poolmax=10
     那么就可以这样使用 SimpleConnectionPoolDataSource 与 MessageDAO3:
  JDBCDemo MessageDAODemo3.java
package cc.openhome;
import java.util.Scanner;
public class MessageDAODemo3 {
    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in, "Big5");
        MessageDAO3 dao =
             new MessageDAO3(new SimpleConnectionPoolDataSource());
        while(true) {
             ...
        }
    }
}
          实际上应用程序经常通过 JNDI,从服务器上取得设定好的 DataSource,再从 DataSource
          取得 Connection,将来你接触到 Servlet/JSP 或其他 Java EE 应用领域,就会看到相关设
          定方式。
14.2.2       使用 ResultSet 卷动、更新数据
     在 ResultSet 时,默认可以使用 next()移动数据光标至下一笔数据,而后使用 getXXX()
方法来取得数据。实际上,从 JDBC 2.0 开始,ResultSet 不仅可以使用 previous()、first()、
last()等方法前后移动数据光标,还可以调用 updateXXX()、updateRow()等方法进行数据修改。
     在使用 Connection 的 createStatement()或 prepareStatement()方法建立 Statement 或
PreparedStatement  实例时,可以指定结果集类型与并行方式:
476
                                                                                  14
                                                                         整合数据库
    createStatement(int resultSetType, int resultSetConcurrency)
    prepareStatement(String sql,
                        int resultSetType, int resultSetConcurrency)
    结果集类型可以指定三种设定:
       ResultSet.TYPE_FORWARD_ONLY(默认)
       ResultSet.TYPE_SCROLL_INSENSITIVE
       ResultSet.TYPE_SCROLL_SENSITIVE
    指 定 为       TYPE_FORWARD_ONLY  , ResultSet     就 只 能 前 进 数 据 光 标 。 指 定
TYPE_SCROLL_INSENSITIVE  或 TYPE_SCROLL_SENSITIVE,则 ResultSet 可以前后移动数据光标,
两者差别在于         TYPE_SCROLL_INSENSITIVE  设定下,取得的 ResultSet 不会反映数据库中的数据
修改,而 TYPE_SCROLL_SENSITIVE 会反映数据库中的数据修改。
    更新设定可以有两种指定:
       ResultSet.CONCUR_READ_ONLY (默认)
       ResultSet.CONCUR_UPDATABLE
    指定为 CONCUR_READ_ONLY,则只能用 ResultSet 进行数据读取,无法进行更新。指定为
CONCUR_UPDATABLE,就可以使用 ResultSet 进行数据更新。
    在使用 Connection 的 createStatement()或 prepareStatement()方法建立 Statement 或
PreparedStatement 实例时,若没有指定结果集类型与并行方式,默认就是 TYPE_FORWARD_ONLY
与  CONCUR_READ_ONLY。如果想前后移动数据光标并想使用 ResultSet                        进行更新,则以下是个
Statement 指定的例子:
    Statement stmt = conn.createStatement(
                             ResultSet.TYPE_SCROLL_INSENSITIVE,
                         ResultSet.CONCUR_UPDATEABLE);
    以下是个 PreparedStatement 指定的例子:
    PreparedStatement stmt = conn.prepareStatement(
                             "SELECT * FROM t_message",
                             ResultSet.TYPE_SCROLL_INSENSITIVE,
                             ResultSet.CONCUR_UPDATEABLE);
    在数据光标移动的 API 上,可以使用 absolute()、afterLast()、beforeFirst()、first()、last()
进行绝对位置移动,使用 relative()、previous()、next()进行相对位置移动。这些方法如果成功
移动就会返回 true,也可以使用 isAfterLast()、isBeforeFirst()、isFirst()、isLast()判断目前位
置。以下是个简单的程序范例片段:
    Statement stmt = conn.createStatement("SELECT * FROM t_message",
                       ResultSet.TYPE_SCROLL_INSENSITIVE,
                       ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery();
    rs.absolute(2);                     // 移至第 2 列
    rs.next();                          // 移至第 3 列
                                                                              477
    rs.first();                         // 移至第 1 列
    boolean b1 = rs.isFirst();          // b1 是 true
    如果要使用 ResultSet 进行数据修改,则有些条件限制:
       必须选取单一表格。
       必须选取主键。
       必须选取所有 NOT NULL 的值。
    在取得 ResultSet 之后要进行数据更新,                 必须移动至要更新的列(Row),         调用 updateXxx()
方法(Xxx 是类型),而后调用 updateRow()方法完成更新。如果调用 cancelRowUpdates()可取
消更新,但必须在调用 updateRow()前进行更新的取消。一个使用 ResultSet 更新数据的例
子如下:
    Statement stmt = conn.prepareStatement("SELECT * FROM t_message",
                       ResultSet.TYPE_SCROLL_INSENSITIVE,
                       ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery();
    rs.next();
    rs.updateString(3, "caterpillar@openhome.cc");
    rs.updateRow();
    如果取得 ResultSet 后想直接进行数据的新增,则要先调用 moveToInsertRow(),之后调
用 updateXXX() 设定要新增的数据各个字段,然后调用 insertRow() 新增数据。一个使用
ResultSet 新增数据的例子如下:
    Statement stmt = conn.prepareStatement("SELECT * FROM t_message",
                       ResultSet.TYPE_SCROLL_INSENSITIVE,
                       ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery();
    rs.moveToInsertRow();
    rs.updateString(2, "momor");
    rs.updateString(3, "momor@openhome.cc");
    rs.updateString(4, "blah...blah");
    rs.insertRow();
    rs.moveToCurrentRow();
    如果取得 ResultSet 后想直接进行数据的删除,则要移动数据光标至想删除的列,调用
deleteRow()删除数据列。一个使用 ResultSet 删除数据的例子如下:
    Statement stmt = conn.prepareStatement("SELECT * FROM t_message",
                       ResultSet.TYPE_SCROLL_INSENSITIVE,
                       ResultSet.CONCUR_READ_ONLY);
    ResultSet rs = stmt.executeQuery();
    rs.absolute(3);
    rs.deleteRow();
478
                                                                                    14
                                                                           整合数据库
14.2.3       批次更新
    如果必须对数据库进行大量数据更新,单纯使用类似以下的程序片段并不适当:
    Statement stmt = conn.createStatement();
    while(someCondition) {
        stmt.executeUpdate(
          "INSERT INTO t_message(name,email,msg) VALUES('...','...','...')");
    }
    每一次执行 executeUpdate(),其实都会向数据库发送一次 SQL,如果大量更新的 SQL 有
一万笔,就等于通过网络进行了一万次的信息传送,网络传送信息实际上必须打开 I/O、进行
路由等动作。如此进行大量更新,效能上其实不好。
    可以使用 addBatch()方法来收集 SQL,并使用 executeBatch()方法将所收集的 SQL 传
送出去。例如:
    Statement stmt = conn.createStatement();
    while(someCondition) {
        stmt.addBatch(
          "INSERT INTO t_message(name,email,msg) VALUES('...','...','...')");
    }
    stmt.executeBatch();
    以 MySQL 驱动程序的 Statement 操作为例,                其 addBatch()使用了 ArrayList 来收集 SQL,
其原始码如下所示:
    public synchronized void addBatch(String sql) throws SQLException {
        if (this.batchedArgs == null) {
            this.batchedArgs = new ArrayList();
        }
        if (sql != null) {
            this.batchedArgs.add(sql);
        }
    }
    所有收集的 SQL,最后会串为一句 SQL,然后传送给数据库。也就是说,假设大量更
新的 SQL 有一万笔,这一万笔 SQL 会连接为一句 SQL,再通过一次网络传送给数据库,
节省了 I/O、网络路由等动作所耗费的时间。
    既然是使用批次更新,顾名思义,就是仅用在更新操作,所以批次更新的限制是,SQL
不能是 SELECT,否则会抛出异常。
    使用 executeBatch()时,SQL 的执行顺序就是 addBatch()时的顺序。executeBatch()会
返回 int[],代表每笔 SQL 造成的数据异动列数,执行 executeBatch()时,前面已打开的
ResultSet 会被关闭,执行过后收集 SQL 用的 List 会被清空,任何的 SQL 错误,会抛出
BatchUpdateException,可以使用这个对象的 getUpdateCounts()取得 int[],代表前面执行成
功的 SQL 所造成的异动笔数。
                                                                                479
    前面举的是 Statement 的例子,          如果是 PreparedStatement 要使用批次更新,      以下是个范例:
    PreparedStatement stmt = conn.prepareStatement(
           "INSERT INTO t_message(name,email,msg) VALUES(?, ?, ?)");
    while(someCondition) {
        stmt.setString(1, "...");
        stmt.setString(2, "...");
        stmt.setString(3, "...");
        stmt.addBatch();  // 收集参数
    }
    stmt.executeBatch();  // 送出所有参数
    PreparedStatement   的 addBatch() 会 收 集 占 位 字 符 真 正 的 数 值 。 以 MySQL 的
PreparedStatement 操作类为例,其 addBatch()原始码如下:
    public void addBatch() throws SQLException {
        if (this.batchedArgs == null) {
            this.batchedArgs = new ArrayList();
        }
        this.batchedArgs.add(new BatchParams(this.parameterValues,
            this.parameterStreams, this.isStream, this.streamLengths,
            this.isNull));
    }
    可以看到,内部是使用 ArrayList 来收集占位字符实际的数值。
          除了在 API 上使用 addBatch()、executeBatch() 等方法以进行批次更新之外,通常也会
          搭配关闭自动提交(auto commit),在效能上也会有所影响,这在稍后说明交易时就会提到。
          驱动程序本身是否支持批次更新也要注意一下。以 MySQL 为例,要支持批次更新,必须
          在 JDBC URL 上附加 rewriteBatchedStatements=true 参数才有实际的作用。
14.2.4      Blob 与 Clob
    如果要将文档写入数据库,可以在数据库表格字段上使用 BLOB 或 CLOB 数据类型。
BLOB 全名 Binary Large Object ,用于存储大量的二进制数据,像是图档、影音档等,CLOB
全名 Character Large Object,用于存储大量的文字数据。
    在 JDBC 中提供了 java.sql.Blob 与 java.sql.Clob 两个类分别代表 BLOB 与 CLOB 数
据。以 Blob 为例,写入数据时,可以通过 PreparedStatement 的 setBlob()来设定 Blob 对象,
读取数据时,可以通过 ResultSet 的 getBlob()取得 Blob 对象。
    Blob 拥有 getBinaryStream()、getBytes()等方法,可以取得代表字段来源的 InputStream
或字段的 byte[]数据。Blob 拥有 getCharacterStream()、getAsciiStream()等方法,可以取得
Reader 或 InputStream  等数据。可以查看 API 文件来获得更详细的信息。
    实际也可以把 BLOB 字段对应 byte[] 或输入/输出串流。在写入数据时,可以使用
PreparedStatement 的 setBytes()来设定要存入的 byte[]数据,使用 setBinaryStream()来设定
480
                                                                  14
                                                     整合数据库
代表输入来源的 InputStream。在读取数据时,可以使用 ResultSet 的 getBytes()以 byte[]
取得字段中存储的数据,或以 getBinaryStream()取得代表字段来源的 InputStream。
    以下是取得代表文档来源的 InputStream 后,进行数据库存储的片段:
    InputStream in = readFileAsInputStream("...");
    PreparedStatement stmt = conn.prepareStatement(
        "INSERT INTO IMAGES(src, img) VALUE(?, ?)");
    stmt.setString(1, "...");
    stmt.setBinaryStream(2, in);
    stmt.executeUpdate();
    以下是取得代表字段数据源的 InputStream 片段:
    PreparedStatement stmt = conn.prepareStatement(
        "SELECT img FROM IMAGES");
    ResultSet rs = stmt.executeQuery();
    while(rs.next()) {
        InputStream in = rs.getBinaryStream(1);
        //使用 InputStream 作数据读取
    }
14.2.5      交易简介
    交易的四个基本要求是 原子性(Atomicity) 、 一致性(Consistency) 、 隔离行为(Isolation
behavior)与持续性(Durability),依英文字母首字母简称为 ACID。
       原子性:一个交易是一个单元工作(Unit of work),当中可能包括数个步骤,这些
        步骤必须全部执行成功,若有一个失败,则整个交易声明失败。交易中其他步骤
        必须撤销曾经执行过的动作,回到交易前的状态。
        在数据库上执行单元工作为数据库交易(Database transaction),单元中每个步骤
        就是每一句 SQL 的执行,你要定义开始一个交易边界(通常是以一个 BEGIN 的指
        令开始),所有 SQL 语句下达之后,COMMIT 确认所有操作变更,此时交易成功,
        或者因为某个 SQL 错误,ROLLBACK 进行撤销动作,此时交易失败。
       一致性:交易作用的数据集合在交易前后必须一致。若交易成功,整个数据集合
        都必须是交易操作后的状态;若交易失败,整个数据集合必须与开始交易前一样
        没有变更,不能发生整个数据集合,部分有变更,部分没变更的状态。
        例如转账行为,数据集合涉及 A、B 两个账户,A 原有 20000,B 原有 10000,A
        转 10000 给 B,交易成功的话,最后 A 必须变成 10000,B 变成 20000,交易失
        败的话,A 必须为 20000,B 为 10000,而不能发生 A 为 20000(未扣款),B 也为
        20000(已入款)的情况。
       隔离行为:在多人使用的环境下,每个用户可能进行自己的交易,交易与交易之
        间,必须互不干扰,用户不会意识到别的用户正在进行交易,就好像只有自己在
        进行操作一样。
                                                             481
       持续性:交易一旦成功,所有变更必须保存下来,即使系统挂了,交易的结果也
        不能遗失,这通常需要系统软、硬件架构的支持。
    在原子性的要求上,在 JDBC 可以操作 Connection 的 setAutoCommit()方法,给它 false
自变量,提示数据库开始交易,在下达一连串的 SQL 语句后,自行调用 Connection 的
commit(),提示数据库确认(COMMIT)操作。如果中间发生错误,则调用 rollback(),提示
数据库撤销(ROLLBACK)所有的执行。一个示范的流程如下所示:
    Connection conn = null;
    try {
        conn = dataSource.getConnection();
        conn.setAutoCommit(false); // 取消自动提交
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("INSERT INTO ...");
        stmt.executeUpdate("INSERT INTO ...");
        conn.commit(); // 提交
    }
    catch(SQLException e) {
        e.printStackTrace();
        if(conn != null) {
            try {
                conn.rollback(); // 撤回
            }
            catch(SQLException ex) {
                ex.printStackTrace();
            }
        }
    }
    finally {
        ...
        if(conn != null) {
            try {
                conn.setAutoCommit(true); // 回复自动提交
                conn.close();
            }
            catch(SQLException ex) {
                ex.printStackTrace();
            }
        }
    }
    如果在交易管理时,仅想要撤回某个 SQL 执行点,则可以设定存储点(Save point)。例
如:
    Savepoint point = null;
    try {
        conn.setAutoCommit(false);
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("INSERT INTO ...");
        ...
        point = conn.setSavepoint(); // 设定存储点
        stmt.executeUpdate("INSERT INTO ...");
482
                                                                  14
                                                          整合数据库
    ...
    conn.commit();
}
catch(SQLException e) {
    e.printStackTrace();
    if(conn != null) {
        try {
            if(point == null) {
                conn.rollback();
            }
            else {
                conn.rollback(point);         // 撤回存储点
                conn.releaseSavepoint(point);    // 释放存储点
            }
        }
        catch(SQLException ex) {
            ex.printStackTrace();
        }
    }
}
finally {
    ...
    if(conn != null) {
        try {
            conn.setAutoCommit(true);
            conn.close();
        }
        catch(SQLException ex) {
            ex.printStackTrace();
        }
    }
}
在批次更新时,不用每一笔都确认的话,也可以搭配交易管理。例如:
try {
    conn.setAutoCommit(false);
    stmt = conn.createStatement();
    while(someCondition) {
        stmt.addBatch("INSERT INTO ...");
    }
    stmt.executeBatch();
    conn.commit();
} catch(SQLException ex) {
    ex.printStackTrace();
    if(conn != null) {
                                                              483
             try {
                 conn.rollback();
             } catch(SQLException e) {
                 e.printStackTrace();
             }
        }
    } finally {
        ...
        if(conn != null) {
             try {
                 conn.setAutoCommit(true);
                 conn.close();
             }
             catch(SQLException ex) {
                 ex.printStackTrace();
             }
        }
    }
          数据表格必须支持交易,才可以执行以上所提到的功能。例如,在 MySQL 中可以建立
          InnoDB 类型的表格:
          CREATE TABLE t_xxx (
               ...
          ) Type = InnoDB;
    至于在隔离行为的支持上,JDBC 可以通过 Connection 的 getTransactionIsolation()取
得数据库目前的隔离行为设定,通过 setTransactionIsolation()可提示数据库设定指定的隔
离行为。可设定常数是定义在 Connection 上,如下所示:
       TRANSACTION_NONE
       TRANSACTION_UNCOMMITTED
       TRANSACTION_COMMITTED
       TRANSACTION_REPEATABLE_READ
       TRANSACTION_SERIALIZABLE
    其中 TRANSACTION_NONE 表示对交易不设定隔离行为,仅适用于没有交易功能、以只读功
能为主、不会发生同时修改字段的数据库。有交易功能的数据库,可能不理会
TRANSACTION_NONE 的设定提示。
    要了解其他隔离行为设定的影响,首先要了解多个交易并行时,可能引发的数据不一
致问题有哪些。以下逐一举例说明。
484
                                                                              14
                                                                     整合数据库
   1. 更新遗失(Lost update)
   基本上就是指某个交易对字段进行更新的信息,因另一个交易的介入而遗失更新效力。
举例来说,若某个字段数据原为 ZZZ,用户 A、B 分别在不同的时间点对同一字段进行更
新交易,如图 14.12 所示。
              用户 A                                              用户 B
                 1:开始()
                                交易 A
                                                         2:开始()
                                              交易 B
                    3:更新为 000()
                                                   4:更新为×××()
                    5:确认()
                                                     6:撤销()
                                    图 14.12 更新遗失
   单就用户 A 的交易而言,最后字段应该是 OOO,单就用户 B 的交易而言,最后字段
应该是 ZZZ。在完全没有隔离两者交易的情况下,由于用户 B 撤销操作时间在用户 A 确认
之后,最后字段结果会是 ZZZ,用户 A 看不到他更新确认的 OOO 结果,用户 A 发生更新
遗失问题。
       可想象有两个用户,若 A 用户打开文件之后,后续又允许 B 用户打开文件,一开始 A、B
       用户看到的文件都有 ZZZ 文字,A 修改 ZZZ 为 OOO 后存储,B 修改 ZZZ 为 XXX 后又还
       原为 ZZZ 并存储,最后文件就为 ZZZ,A 用户的更新遗失。
   如果要避免更新遗失问题,可以设定隔离层级为“可读取未确认”(Read uncommited),
也就是 A 交易已更新但未确认的数据,                  B 交易仅可做读取动作,           但不可做更新的动作。  JDBC
可通过 Connection 的 setTransactionIsolation()设定为 TRANSACTION_UNCOMMITTED 来提示数据
库确定此隔离行为。
   数据库对此隔离行为的基本做法是,A 交易在更新但未确认,延后 B 交易的更新需求
至 A 交易确认之后。以上例而言,交易顺序结果会变成如图 14.13 所示。
       可想象有两个用户,若 A 用户打开文件之后,后续只允许 B 用户以只读方式打开文件,B 用
       户若要能够写入,至少得等 A 用户修改完成关闭文档后。
   提示数据库“可读取未确认”的隔离层次之后,数据库至少得保证交易要避免更新遗失
问题,通常这也是具备交易功能的数据库引擎会采取的最低隔离层级。不过这个隔离层级
读取错误数据的机率太高,一般不会采用这种隔离层级。
                                                                          485
                 用户 A                                                    用户 A
                     1:开始()
                                    交易 A
                                                                2:开始()
                                                   交易 B
                       3:更新为 000()
                          4:确认()
                                                         5:更新为×××()
                                                            6:撤销()
                               图 14.13 “可读取未确认”避免更新遗失
    2. 脏读(Dirty read)
    两个交易同时进行,其中一个交易更新数据但未确认,另一个交易就读取数据,就有
可能发生脏读问题,也就是读到所谓脏数据(Dirty data)、不干净、不正确的数据,如图 14.14
所示。
                   用户 A                                                  用户 B
                         1:开始()
                                       交易 A
                                                                  2:开始()
                                                    交易 B
                        3:更新为 000()
                                                         4:查询字段为×××()
                                                              5:确认()
                             6:撤销()
                                          图 14.14 脏读
    用户 B 在 A 交易撤销前读取了字段数据为 OOO,如果 A 交易撤销了交易,那用户 B
读取的数据就是不正确的。
         可想象有两个用户,若 A 用户打开文件并仍在修改期间,B 用户打开文件所读到的数据,
         就有可能是不正确的。
    如果要避免脏读问题,可以设定隔离层级为“可读取确认”(Read commited),也就是
交 易 读 取 的 数 据 必 须 是 其 他 交 易 已 确 认 的 数 据 。 JDBC 可 通 过 Connection 的
setTransactionIsolation() 设定为 TRANSACTION_COMMITTED 来提示数据库确定此隔离行为。
486
                                                                               14
                                                                       整合数据库
   数据库对此隔离行为的基本做法之一是,读取的交易不会阻止其他交易,未确认的更
新交易会阻止其他交易。若是这个做法,交易顺序结果会变成如图 14.15 所示(若原字段为
ZZZ)。
            用户 A                                                  用户 B
                    1:开始()
                                 交易 A
                                                           2:开始()
                                            交易 B
                  3:更新字段为 000()
                       4:撤销()
                                                  5:查询字段为×××()
                                                      6:确认()
                           图 14.15 “可读取确认”避免脏读
       可想象有两个用户,若 A 用户打开文件并仍在修改期间,B 用户就不能打开文件。但在数
       据库上这个做法影响效能较大,另一个基本做法是交易正在更新但尚未确定前先操作暂存
       表格,其他交易就不至于读取到不正确的数据。JDBC 隔离层级的设定提示,实际在数据
       库上如何操作,主要得以各家数据库在效能的考虑而定。
   提示数据库“可读取确认” 的隔离层次之后,数据库至少得保证交易要避免脏读与更
新遗失问题。
   3. 无法重复的读取 (Unrepeatable read)
   某个交易两次读取同一字段的数据并不一致。例如,交易 A 在交易 B 更新前后进行数
据的读取,则 A 交易会得到不同的结果,如图 14.16 所示(若原字段为 ZZZ)。
          用户 A                                                 用户 B
               1:开始()
                              交易 A
                                                        2:开始()
                                          交易 B
              3:查询字段为 ZZZ()
                                               4:更新字段为 OOO()
                                                    5:确认()
              6:查询字段为 OOO()
                    7:确认()
                               图 14.16 无法重复的读取
                                                                           487
     如果要避免无法重复的读取问题,可以设定隔离层级为 “可重复读取”(Repeatable
read) , 也 就 是 同 一 交 易 内 两 次 读 取 的 数 据 必 须 相 同 。 JDBC 可 通过 Connection 的
setTransactionIsolation()设定为 TRANSACTION_REPEATABLE_READ 来提示数据库确定此隔离行为。
     数据库对此隔离行为的基本做法之一是,读取交易在确认前不阻止其他读取交易,但
会阻止其他更新交易。若是这个做法,交易顺序结果会变成如图 14.17 所示(若原字段为
ZZZ)。
                    用户 A                                             用户 B
                           1:开始()
                                       交易 A
                                                              2:开始()
                                                  交易 B
                         3:查询字段为 ZZZ()
                         4:查询字段为 ZZZ()
                              5:确认()
                                                      6:更新字段为 OOO()
                                                          7:确认()
                                       图 14.17 可重复读取
          在数据库上这个做法影响效能较大,另一个基本做法是交易正在读取但尚未确认前,另一
          交易会在暂存表格上更新。
     提示数据库“可重复读取” 的隔离层次之后,数据库至少得保证交易要避免无法重复
读取、脏读与更新遗失问题。
     4. 幻读(Phantom read)
     同一交易期间,读取到的数据笔数不一致。例如,交易 A 第一次读取得到五笔数据,
此时交易 B 新增了一笔数据,导致交易 B 再次读取得到六笔数据。
     如果隔离行为设定为可重复读取,但发生幻读现象,可以设定隔离层级为“可循序”
(Serializable),也就是在有交易时若有数据不一致的疑虑,交易必须可以照顺序逐一进行。
JDBC 可通过 Connection 的 setTransactionIsolation()设定为 TRANSACTION_SERIALIZABLE 来提
示数据库确定此隔离行为。
          交易若真的一个一个循序进行,对数据库的影响效能过于巨大,实际也许未必直接阻止其
          他交易或真的循序进行,例如采取暂存表格方式。事实上,只要能符合四个交易隔离要求,
          各家数据库会寻求最有效能的解决方式。
     表 14.2 整理了各个隔离行为可预防的问题。
488
                                                                                     14
                                                                            整合数据库
                                 表 14.2 隔离行为与可预防的问题
      隔离行为              更新遗失                脏读            无法重复的读取             幻读
  可读取未确认             预防
  可读取确认              预防                 预防
  可重复读取              预防                 预防              预防
  可循序                预防                 预防              预防                 预防
     如果想通过 JDBC 得知数据库是否支持某个隔离行为设定,可以通过 Connection 的
getMetaData()取得 DatabaseMetadata      对象,通过 DatabaseMetadata 的 supportsTransaction-
IsolationLevel()得知是否支持某个隔离行为。例如:
     DatabaseMetadata meta = conn.getMetaData();
     boolean isSupported = meta.supportsTransactionIsolationLevel(
                Connection.TRANSACTION_READ_COMMITTED);
14.2.6       metadata 简介
     Metadata 即“诠读数据的数据”(Data about data)。例如,数据库是用来存储数据的
地方,然而数据库本身产品名称为何?数据库中有几个数据表格?表格名称为何?表格中
有几个字段等?这些信息就是所谓的 metadata。
     在 JDBC 中,可以通过 Connection 的 getMetaData()方法取得 DatabaseMetaData 对象,
通过这个对象提供的各个方法,                   可以取得数据库整体信息,                而 ResultSet 表示查询到的数据,
而数据 本身的字段、 类型等信 息,可以通过 ResultSet 的 getMetaData() 方法, 取得
ResultSetMetaData 对象,通过这个对象提供的相关方法,就可以取得域名、字段类型等信息。
           DatabaseMetaData 或 ResultSetMetaData 本身 API 使用上不难,问题点在于各家数据库
           对某些名词的定义不同,必须查阅数据库厂商手册搭配对应的 API,才可以取得想要的
           信息。
     以下举个例子,利用 JDBC 的 metadata 相关 API,取得前面文档管理范例 t_message
表格相关信息:
 JDBCDemo TMessageInfo.java
package cc.openhome;
import java.sql.*;
import java.util.*;
import javax.sql.DataSource;
public class TMessageInfo {
    private DataSource dataSource;
                                                                                 489
    public TMessageInfo(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    public List<ColumnInfo> getAllColumnInfo() {
        List<ColumnInfo> infos = null;                             查询 t_files
        try(Connection conn = dataSource.getConnection()) {
                                                                    表格所有字段
            DatabaseMetaData meta = conn.getMetaData();
            ResultSet crs = meta.getColumns("demo", null, "t_message", null);
            infos =  new ArrayList<>();          用来收集字段信息
            while(crs.next()) {
                ColumnInfo info = new ColumnInfo();
                info.setName(crs.getString("COLUMN_NAME"));
                info.setType(crs.getString("TYPE_NAME"));
                                                                       封装字段名称、类
                info.setSize(crs.getInt("COLUMN_SIZE"));
                                                                        型、大小、可否为
                info.setNullable(crs.getBoolean("IS_NULLABLE"));
                                                                        空、默认值等信息
                info.setDef(crs.getString("COLUMN_DEF"));
                infos.add(info);
            }
        }
        catch(SQLException ex) {
            throw new RuntimeException(ex);
        }
        return infos;
    }
}
     在调用 getAllColumnInfo()时,会先从 Connection 上取得 DatabaseMetaData,以查询数据
库中指定表格的字段,这会取得一个 ResultSet。接着从 ResultSet 上,逐一取得各个想
要的信息,封装为 ColumnInfo 对象,并收集在 List 中返回。
     ColumnInfo 只是自定义的简单类,用来封装字段各个信息:
  JDBCDemo ColumnInfo.java
package cc.openhome;
import java.io.Serializable;
public class ColumnInfo implements Serializable {
    private String name;
    private String type;
    private int size;
    private boolean nullable;
    private String def;
    public String getName() {
490
                                                                                        14
                                                                              整合数据库
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getType() {
        return type;
    }
    public void setType(String type) {
        this.type = type;
    }
    public int getSize() {
        return size;
    }
    public void setSize(int size) {
        this.size = size;
    }
    public boolean isNullable() {
        return nullable;
    }
    public void setNullable(boolean nullable) {
        this.nullable = nullable;
    }
    public String getDef() {
        return def;
    }
    public void setDef(String def) {
        this.def = def;
    }
}
     可以使用以下范例来运用 TMessageInfo 取得字段信息:
  JDBCDemo TMessageInfoDemo.java
package cc.openhome;
import java.io.IOException;
public class TMessageInfoDemo {
    public static void main(String[] args)
            throws IOException, ClassNotFoundException {
                                                               查询 t_files 表格所有字段
        TMessageInfo tMessageInfo =
                new TMessageInfo(new SimpleConnectionPoolDataSource());
        System.out.println("名称\t 类型\t 为空\t 默认");                             用来收集字段信息
        for(ColumnInfo columnInfo : tMessageInfo.getAllColumnInfo()) {
                                                                                    491
            System.out.printf("%s\t%s\t%s\t%s%n",
                    columnInfo.getName(),
                    columnInfo.getType(),
                                                          用来收集字段信息
                    columnInfo.isNullable(),
                    columnInfo.getDef());
        }
     }
}
     一个执行参考结果如下所示:
 名称       类型        为空        默认
 id       INT       false     null
 name     CHAR      false     null
 email    CHAR      true      null
 msg      TEXT      false     null
14.2.7        RowSet 简介
     JDBC 定义了 javax.sql.RowSet 接口,用以代表数据的列集合。这里的数据并不一定是
数据库中的数据,可以是电子表格数据、XML 数据或任何具有列集合概念的数据源。
     RowSet 是 ResultSet 的子接口,所以具有 ResultSet 的行为,可以使用 RowSet 对列集合
进行增删查改。RowSet 也新增了一些行为,像是通过 setCommand() 设定查询指令、通过
execute()执行查询指令以填充数据等。
           在 Sun 的 JDK 中附有 RowSet 的非标准操作,其包名称是 com.sun.rowset。
     RowSet  定义了列集合基本行为,其下有 JdbcRowSet 、CachedRowSet 、FilteredRowSet 、
JoinRowSet  与 WebRowSet 五个标准列集合子接口,定义在 javax.sql.rowset 包中。其继承关
系如图 14.18 所示。
                                  图 14.18 RowSet 接口继承架构
492
                                                                                         14
                                                                           整合数据库
     JdbcRowSet 是联机式(Connected)的 RowSet,也就是操作 JdbcRowSet 期间,会保持与数
据库的联机,可视为取得、操作 ResultSet 的行为封装,可简化 JDBC 程序的撰写,或作
为 JavaBean 使用。
     CachedRowSet 则为脱机式(Disconnected)的 RowSet(其子接口当然也是),在查询并填充完
数据后,就会断开与数据源的联机,而不用占据相关联机资源,必要的也可以再与数据源
联机进行数据同步。
     以下先以 JdbcRowSet 为例,介绍 RowSet 的基本操作。在这里使用的成果是 Oracle/Sun
JDK 附带的 JdbcRowSetImpl。在 JDK6 之前,可以这样建立 JdbcRowSet 实例:
JdbcRowSet rowset = new JdbcRowSetImpl();
     在 JDK7 之后,    新增了 javax.sql.rowset.RowSetFactory 接口与 javax.sql.rowset.RowSetProvider
类 , 可 以 使 用 RowSetProvider.newFactory() 取 得 RowSetFactory 操 作 对 象 , 再 利 用
RowSetFactory 的 createJdbcRowSet()、createCachedRowSet()等方法,建立 RowSet 实例。例如
建立 JdbcRowSet 实例:
     RowSetFactory rowSetFactory = RowSetProvider.newFactory();
     JdbcRowSet rowset = rowSetFactory.createJdbcRowSet();
     如果使用 Oracle/Sun JDK,以上程序片段会取得 JdbcRowSetImpl 实例,若有其他厂商
成果,可以在启动 JVM 时,利用系统属性 javax.sql.rowset.RowSetFactory 指定,例如
-Djavax.sql.rowset.RowSetFactory=com.other.rowset.RowSetFactoryImpl。
     要使用 RowSet 查询数据,基本上可以这样:
     rowset.setUrl("jdbc:mysql://localhost:3306/demo");
     rowset.setUsername("root");
     rowset.setPassword("123456");
     rowset.setCommand("SELECT * FROM t_messages WHERE id = ?");
     rowset.setInt(1, 1);
     rowset.execute();
     可以使用 setUrl()设定 JDBC URL,           使用 setUsername()设定用户名称,       使用 setPassword()
设定密码,使用 setCommand()设定查询 SQL。JdbcRowSet 也有 setAutocommit()与 commit()
方法,可以进行交易控制。
     由于 RowSet 是 ResultSet 的子接口,要取得各字段数据,只要如 ResultSet 操作即可,
若要使用 RowSet 进行增删改的动作,也是与 ResultSet 相同。例如,下例使用 JdbcRowSet
改写 14.1.3 节中的 MessageDAO,可以比较使用 JdbcRowSet 之后的差别:
 JDBCDemo MessageDAO4.java
package cc.openhome;
import java.sql.*;
import java.util.*;
import javax.sql.rowset.*;
public class MessageDAO4 {
                                                                                     493
    private JdbcRowSet rowset;
    public MessageDAO4(
            String url, String user, String passwd) throws SQLException {
        JdbcRowSet rowset = RowSetProvider.newFactory().createJdbcRowSet();
        rowset.setUrl(url);
        rowset.setUsername(user);
        rowset.setPassword(passwd);
        rowset.setCommand("SELECT * FROM t_message");
        rowset.execute();
    }
    public void add(Message message) throws SQLException {
        rowset.moveToInsertRow();
        rowset.updateString(2, message.getName());
        rowset.updateString(3, message.getEmail());
        rowset.updateString(4, message.getMsg());
        rowset.insertRow();
    }
    public List<Message> get() throws SQLException {
        List<Message> messages = new ArrayList<>();
        rowset.beforeFirst();
        while (rowset.next()) {
            Message message = new Message();
            message.setId(rowset.getLong(1));
            message.setName(rowset.getString(2));
            message.setEmail(rowset.getString(3));
            message.setMsg(rowset.getString(4));
            messages.add(message);
        }
        return messages;
    }
    public void close() throws SQLException {
        if (rowset != null) {
            rowset.close();
        }
    }
}
     在这个 MessageDAO4 会重复使用已建立的 JdbcRowSet 操作对象,如果不需要使用
JdbcRowSet 了,可以调用 MessageDAO4 的 close()方法,当中会使用 JdbcRowSet 的 close()方
法关闭 JdbcRowSet。
     如果在查询之后,想要脱机进行操作,则可以使用 CachedRowSet 或其子接口操作对象,
查询数据之后可以直接使用 close()关闭联机。若在相关更新操作之后,想再与数据源进行
同步,则可以调用 acceptChanges()方法。例如:
494
                                                                                     14
                                                                             整合数据库
     conn.setAutoCommit(false);  // conn 是 Connection
     rowSet.acceptChanges(conn); // rowSet 是 CachedRowSet
     conn.setAutoCommit(true);
     WebRowSet 是 CachedRowSet   的子接口,其不仅具备脱机操作,还能进行 XML 读写。例如
以 下 的 TMessageUtil.writeXml() 方 法 , 可 以 读 取 数 据 库 的 表 格 数 据 , 然 后 对 指 定 的
OutputStream 写出     XML:
  JDBCDemo TMessageUtil.java
package cc.openhome;
import java.io.*;
import javax.sql.rowset.*;
public class TMessageUtil {
    public static void writeXml(OutputStream outputStream)
                                 throws Exception {
         try(WebRowSet rowset =
                            RowSetProvider.newFactory().createWebRowSet()) {
             rowset.setUrl("jdbc:mysql://localhost:3306/demo");
             rowset.setUsername("root");
             rowset.setPassword("123456");
             rowset.setCommand("SELECT * FROM t_message");
             rowset.execute();
             rowset.writeXml(outputStream);
         }
    }
    public static void main(String[] args) throws Exception {
         TMessageUtil.writeXml(System.out);
    }
}
     从 JDK7 之后,RowSet 都是 java.lang.AutoCloseable 的子接口,可以使用尝试自动关闭
资源语法。范例中使用 WebRowSet 中的 writeXML(),可以将 WebRowSet 的 Metadata、属性与数
据以 XML 格式写出。一个执行结果如下所示:
     ...
       <data>
         <currentRow>
           <columnValue>1</columnValue>
           <columnValue>良葛格</columnValue>
           <columnValue>caterpillar@openhome.cc</columnValue>
           <columnValue>这是一篇测试留言!</columnValue>
         </currentRow>
         <currentRow>
           <columnValue>2</columnValue>
           <columnValue>毛美眉</columnValue>
           <columnValue>momor@openhome.cc</columnValue>
           <columnValue>我来留言啰!</columnValue>
         </currentRow>
       </data>
                                                                                 495
    </webRowSet>
    只要 TMessageUtil.writeXml()指定的目的地,有办法处理 XML,就可以自行组织出想
要的信息或画面。
    FilteredRowSet    可以对列集合进行过滤,实现类似 SQL 中 WHERE 等条件式的功能。
可以通过 setFilter()方法,指定操作 javax.sql.rowset.Predicate 的对象。其定义如下:
    boolean       evaluate(Object value, int column)
    boolean       evaluate(Object value, String columnName)
    boolean       evaluate(RowSet rs)
    Predicate 的 evaluate()方法返回 true,表示该列要包括在过滤后的列集合中。
    JoinRowSet 则可以让你结合两个 RowSet 对象,实现类似                       SQL 中 JOIN 的功能。可以通
过  setMatchColumn()指定要结合的行,然后使用 addRowSet()来加入 RowSet 进行结合。例如:
    rs1.setMatchColumn(1);
    rs2.setMatchColumn(2);
    JoinRowSet jrs = JoinRowSet jrs = new JoinRowSetImpl();
    jrs.addRowSet(rs1);
    jrs.addRowSet(rs2);
    在这个范例片段执行过后,JoinRowSet 中就会是原本两个 RowSet 结合的结果。也可以
通过 setJoinType()指定结合的方式,可指定的常数定义在 JoinRowSet 中,包括 CROSS_JOIN、
FULL_JOIN、INNER_JOIN、LEFT_OUTER_JOIN 与 RIGHT_OUTER_JOIN。
          API 文件对 RowSet 的文件说明蛮清楚的,更多有关 RowSet 的说明,也可以参考:
          http://java.sun.com/developer/Books/JDBCTutorial/chapter5.html
14.3        重点复习
    JDBC(Java DataBase Connectivity)是用于执行 SQL 的解决方案,开发人员使用
JDBC 的标准接口,数据库厂商则对接口进行操作,开发人员无须接触底层数据库驱动程
序的差异性。
    厂商在操作 JDBC 驱动程序时,依方式可将驱动程序分为四种类型:
       Type 1:JDBC-ODBC Bridge Driver
       Type 2:Native API Driver
       Type 3:JDBC-Net Driver
       Type 4:Native Protocol Driver
    数据库操作相关的 JDBC 接口或类都位于 java.sql 包中。要连接数据库,可以向
DriverManager 取得 Connection 对象。Connection 是数据库联机的代表对象,一个 Connection
对象就代表一个数据库联机。SQLException 是在处理 JDBC 时经常遇到的一个异常对象,
为数据库操作过程发生错误时的代表对象。
496
                                                                                 14
                                                                      整合数据库
    取得联机等与数据库来源相关的行为规范在 javax.sql.DataSource 接口,实际如何取得
Connection 则由操作接口的对象来负责。
    Connection  是 数 据 库 连 接 的 代 表 对 象 , 接 下 来 要 执 行 SQL 的 话 , 必 须 取 得
java.sql.Statement   对 象 , 它 是 SQL 描 述 的 代 表 对 象 。 可 以 使 用 Connection 的
createStatement()来建立 Statement  对象。
    Statement  的 executeQuery() 方 法 则 是 用 于 SELECT 等 查 询 数 据 库 的 SQL ,
executeUpdate() 会 返 回 int 结 果 , 表 示 数 据 变 动 的 笔 数 , executeQuery() 会 返 回
java.sql.ResultSet  对象,代表查询的结果,查询的结果会是一笔一笔的数据。可以使用
ResultSet 的 next()来移动至下一笔数据,它会返回 true             或 false 表示是否有下一笔数据,
接着可以使用 getXXX()来取得数据。
    在 使 用 Connection 、 Statement 或 ResultSet 时 , 要 将 之 关 闭 以 释 放 相 关
资源。
    如果有些操作只是 SQL 语句当中某些参数会有所不同,其余的 SQL 子句皆相同,则
可以使用 java.sql.PreparedStatement。    可以使用 Connection 的 preparedStatement()方法建立
好一个预先编译(precompile)的 SQL 语句,当中参数会变动的部分,先指定“?”这个占位
字符。等到需要真正指定参数执行时,再使用相对应的 setInt()、setString()等方法,指
定“?”处真正应该有的参数。
14.4        课后练习
14.4.1      选择题
    1. JDBC 驱动程序有跨平台特性的是(                   )。
        A. TYPE 1            B.TYPE 2           C. TYPE 3              D. TYPE 4
    2. JDBC 驱动程序是基于数据库所提供的 API 来进行操作的是(                          )。
        A. TYPE 1            B. TYPE 2          C. TYPE 3              D. TYPE 4
    3. JDBC 相关接口或类是放在(              )包之下加以管理。
        A. java.lang         B. javax.sql       C. java.sql            D.
          java.util
    4. 使用 JDBC 时,通常会需要处理(                 )受检异常(Checked Exception)。
        A. RuntimeException                     B. SQLException
        C. DBException                          D. DataException
    5. 关于 Connection 的描述,正确的是(             )。
        A. 可以从 DriverManager 上取得 Connection
        B. 可以从 DataSource 上取得 Connection
        C. 在方法结束之后 Connection 会自动关闭
        D. Connection 是线程安全(Thread-safe)
                                                                             497
     6. 使用 Statement 来执行 SELECT 等查询用的 SQL 指令时,应使用下列(                                )方法。
         A. executeSQL()                                  B. executeQuery()
         C. executeUpdate()                               D. executeFind()
     7. (   )对象正确使用下,可以适当地避免 SQL Injection 的问题。
         A. Statement            B. ResultSet             C. PreparedStatement     D. Command
     8. 取得 Connection 之后,取得 Statement 对象的方法是(                    )。
         A. conn.createStatement()                        B. conn.buildStatement()
         C. conn.getStatement()                           D. conn.createSQLStatement()
     9. 以下描述有误的是(               )。
         A. 使用 Statement 一定会发生 SQL Injection
         B. 使用 PreparedStatement 就不会发生 SQL Injection
         C. 不使用 Connection 时必须加以关闭               D. ResultSet 代表查询的结果集合
     10. 使用 Statement 的 executeQuery()方法,会返回(              )类型。
         A. int                  B. Boolean               C. ResultSet             D. Table
14.4.2       操作题
     请尝试撰写一个 JdbcTemplate 类封装 JDBC 更新操作,可以这样使用其 update()方法:
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
    jdbcTemplate.update(
         "INSERT INTO t_message(name, email, msg) VALUES (?,?,?)",
         "测试员", "tester@openhome.cc", "这是一个测试留言");
     其中 dataSource 参考至 DataSource 操作对象,update()第一个参数接受更新 SQL,之后
的不定长度自变量可接受 SQL 中占位字符?实际数据,不定长度自变量部分不一定是字符
串,也可接受表 14.1 列出的数据类型。
          思考一下,如果不能使用 JDK7 尝试自动关闭资源语法,那使用 try、catch、finally 该
          怎么写?可以参考一下 8.2.2 节的内容。
498
