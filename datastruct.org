* 数据结构
** Lists, Stacks, And Queues 
3.1. Abstract Data Types (ADTs) 
3.2. The List ADT 
3.2.1. Simple Array Implementation of Lists 
3.2.2. Linked Lists 
3.2.3. Programming Details 
3.2.4. Common Errors 
3.2.5. Doubly Linked Lists 
3.2.6. Circularly Linked Lists 
3.2.7. Examples 
3.2.8. Cursor Implementation of Linked Lists 
3.3. The Stack ADT 
3.3.1. Stack Model 
3.3.2. Implementation of Stacks 
3.3.3. Applications 
3.4. The Queue ADT 
3.4.1. Queue Model 
3.4.2. Array Implementation of Queues 
3.4.3. Applications of Queues 
Exercises 
** Trees 
4.1. Preliminaries 
4.1.1. Implementation of Trees 
4.1.2. Tree Traversals with an Application 
4.2. Binary Trees 
4.2.1. Implementation 
4.2.2. Expression Trees 
4.3. The Search Tree ADT-Binary Search Trees 
4.3.1. Make_null 
4.3.2. Find 
4.3.3. Find_min and find_max 
4.3.4. Insert 
4.3.5. Delete 
4.3.6. Average-Case Analysis 
4.4. 
4.4.1. Single Rotation 
4.4.2. Double Rotation 
4.5. Splay Trees 
4.5.1. A Simple Idea (That Does Not Work) 
4.5.2. Splaying 
4.6. Tree Traversals (Revisited) 
4.7. B-Trees 
Exercises 
** Hashing 
5.1. General Idea 
5.2. Hash Function 
5.3. Open Hashing (Separate Chaining) 
5.4. Closed Hashing (Open Addressing) 
5.4.1. Linear Probing 
5.4.2. Quadratic Probing 
5.4.3. Double Hashing 
5.5. Rehashing 
5.6. Extendible Hashing 
Exercises 
** Priority Queues (Heaps) 
6.1.
6.2.lementations 
6.3.p 
6.3.e Property 
6.3.er Property 
6.3.ap Operations 
6.3.ap Operations 
6.4.ns of Priority Queues 
6.4.ction Problem 
6.4.mulation 
6.5.
6.6.aps 
6.6.Heap Property 
6.6.Heap Operations 
6.7. 
6.8.ueues 
6.8. Queue Structure 
6.8. Queue Operations 
6.8.tation of Binomial Queues 
Exer
** Sorting 
7.1. Preliminaries 
7.2. Insertion Sort 
7.2.1. The Algorithm 
7.2.2. Analysis of Insertion Sort 
7.3. A Lower Bound for Simple Sorting Algorithms 
7.4. Shellsort 
7.4.1. Worst-Case Analysis of Shellsort 
7.5. Heapsort 
7.6. Mergesort 
7.6.1. Analysis of Mergesort 
7.7. Quicksort 
7.7.1. Picking the Pivot 
7.7.2. Partitioning Strategy 
7.7.3. Small Files 
7.7.4. Actual Quicksort Routines 
7.7.5. Analysis of Quicksort 
7.7.6. A Linear-Expected-Time Algorithm for Selection 
7.8. Sorting Large Structures 
7.9. A General Lower Bound for Sorting 
7.9.1 Decision Trees 
7.10. Bucket Sort 
7.11. External Sorting 
7.11.1. Why We Need New Algorithms 
7.11.2. Model for External Sorting 
7.11.3. The Simple Algorithm 
7.11.4. Multiway Merge 
7.11.5. Polyphase Merge 
7.11.6. Replacement Selection 
Exercises 
** The Disjoint Set Adt 
8.1.e Relations 
8.2.c Equivalence Problem 
8.3. Structure 
8.4.n Algorithms 
8.5.ession 
8.6. for Union-by-Rank 
8.6.of the Union/Find Algorithm 
8.7.tion 
Exer
** Graph Algorithms 
9.1 Definitions 
9.1.1. Representation of Graphs 
9.2. Topological Sort 
9.3. Shortest-Path Algorithms 
9.3.1. Unweighted Shortest Paths 
9.3.2. Dijkstra's Algorithm 
9.3.3. Graphs with Negative Edge Costs 
9.3.4. Acyclic Graphs 
9.3.5. All-Pairs Shortest Path 
9.4. Network Flow Problems 
9.4.1. A Simple Maximum-Flow Algorithm 
9.5. Minimum Spanning Tree 
9.5.1. Prim's Algorithm 
9.5.2. Kruskal's Algorithm 
9.6. Applications of Depth-First Search 
9.6.1 Undirected Graphs 
9.6.2. Biconnectivity 
9.6.3. Euler Circuits 
9.6.4. Directed Graphs 
9.6.5. Finding Strong Components 
9.7. Introduction to NP-Completeness 
9.7.1. Easy vs. Hard 
9.7.2. The Class NP 
9.7.3. NP-Complete Problems 
Exercises 
** Algorithm Design Techniques 
10.1. Greedy Algorithms 
10.1.1. A Simple Scheduling Problem 
10.1.2. Huffman Codes 
10.1.3. Approximate Bin Packing 
10.2. Divide and Conquer 
10.2.1. Running Time of Divide and Conquer Algorithms 
10.2.2. Closest-Points Problem 
10.2.3. The Selection Problem 
10.2.4. Theoretical Improvements for Arithmetic Problems 
10.3. Dynamic Programming 
10.3.1. Using a Table Instead of Recursion 
10.3.2. Ordering Matrix Multiplications 
10.3.3. Optimal Binary Search Tree 
10.3.4. All-Pairs Shortest Path 
10.4. Randomized Algorithms 
10.4.1. Random Number Generators 
10.4.2. Skip Lists 
10.4.3. Primality Testing 
10.5. Backtracking Algorithms 
10.5.1. The Turnpike Reconstruction Problem 
10.5.2. Games 
Exercises 
** Amortized Analysis 
11.1. An Unrelated Puzzle 
11.2. Binomial Queues 
11.3. Skew Heaps 
11.4. Fibonacci Heaps 
11.4.1. Cutting Nodes in Leftist Heaps 
11.4.2. Lazy Merging for Binomial Queues 
11.4.3. The Fibonacci Heap Operations 
11.4.4. Proof of the Time Bound 
11.5. Splay Trees 
* 数据
** 线性表 链条
   顺序存储方式 数组 最大的缺点就是插入和删除时需要移动大量元素
   线性表链式存储结构(单链表。双向链表.循环链表）
   #+BEGIN_SRC c
     /* 重置为空表 */
     Status ClearList(LinkList *L)
     {
         LinkList p, q;
         /* p指向第一个结点 */
         p = (*L)->next;       
         /* 没到表尾 */
         while (p)             
         {
             q = p->next;
             free(p);
             p=q;
         }
         /* 头结点指针域为空 */
         (*L)->next = NULL;    
         return OK;
     }


   #+END_SRC
** 栈与队列
   栈的应用——递归
   #+BEGIN_SRC c 
   
   ADT 栈(stack)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitStack(*S):    初始化操作，建立一个空栈S。
    DestroyStack(*S): 若栈存在，则销毁它。
    ClearStack(*S):   将栈清空。
    StackEmpty(S):    若栈为空，返回true，否则返回false。
    GetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。
    Push(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。
    Pop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。
    StackLength(S):   返回栈S的元素个数。
endADT
   #+END_SRC
   
#+BEGIN_SRC c
   ADT 队列(Queue)
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q):    初始化操作，建立一个空队列Q。
    DestroyQueue(*Q): 若队列Q存在，则销毁它。
    ClearQueue(*Q):   将队列Q清空。
    QueueEmpty(Q):    若队列Q为空，返回true，否则返回false。
    GetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。
    EnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
    DeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。
    QueueLength(Q):   返回队列Q的元素个数
endADT

#+END_SRC

** string
   #+BEGIN_SRC 
ADT 串(string)
Data
    串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
    StrAssign(T, *chars):        生成一个其值等于字符串常量chars的串T。
    StrCopy(T, S):               串S存在，由串S复制得串T。
    ClearString(S):              串S存在，将串清空。
    StringEmpty(S):              若串S为空，返回true，否则返回false。
    StrLength(S):                返回串S的元素个数，即串的长度。
    StrCompare(S, T):            若S>T，返回值>0，若S=T，返回0，若S<T，返回值<0。
    Concat(T, S1, S2):           用T返回由S1和S2联接而成的新串。
    SubString(Sub, S, pos, len): 串S存在，1≤pos≤StrLength(S)，
                                 且0≤len≤StrLength(S)-pos+1，用Sub返
                                 回串S的第pos个字符起长度为len的子串。
    Index(S, T, pos):            串S和T存在，T是非空串，1≤pos≤StrLength(S)。
                                 若主串S中存在和串T值相同的子串，则返回它在主串S中
                                 第pos个字符之后第一次出现的位置，否则返回0。
    Replace(S, T, V):            串S、T和V存在，T是非空串。用V替换主串S中出现的所有
                                 与T相等的不重叠的子串。
    StrInsert(S, pos, T):        串S和T存在，1≤pos≤StrLength(S)+1。
                                 在串S的第pos个字符之前插入串T。
    StrDelete(S, pos, len):      串S存在，1≤pos≤StrLength(S)-len+1。
                                 从串S中删除第pos个字符起长度为len的子串。
endADT

   #+END_SRC
#+BEGIN_SRC c
/* 返回子串T在主串S中第pos个字符之后的位置。
若不存在，则函数返回值为0。 */
/* T非空，1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos)
{
    /* i用于主串S中当前位置下标，若pos不为1 */
    /* 则从pos位置开始匹配 */
    int i = pos;                      
    /* j用于子串T中当前位置下标值 */
    int j = 1;                        
    /* 若i小于S长度且j小于T的长度时循环 */
    while (i <= S[0] && j <= T[0])    
    {
        /* 两字母相等则继续 */
        if (S[i] == T[j])             
        {
            ++i;
            ++j;
        }
        /* 指针后退重新开始匹配 */
        else                          
        {
            /* i退回到上次匹配首位的下一位 */
            i = i - j + 2;            
            /* j退回到子串T的首位 */
            j = 1;                    
        }
    }
    if (j = T[0])
        return i - T[0];
    else
        return 0;
}


#+END_SRC
