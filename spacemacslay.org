* emacs 加载程序(加载 lisp 执行文件)
** 简单方式  (load-file "~/elisp/foo.el")
 但我们还要注意性能，一般在打开文件时加载，所以要做复杂的判断
** require 方式(lisp 文件有一个属性)
   
#+BEGIN_SRC emacs-lisp
  ;;有此属性
  ;; Your code goes here ...

  (provide 'my-feature)
#+END_SRC

To have Emacs load this file, call =require=, as such:

#+BEGIN_SRC emacs-lisp
  (require 'my-feature)
#+END_SRC

这种方式会做一系列判断，(在 load-path 变量)会检查 el,elc 文件，会判断是否已加载过.
这种方式普遍，作者写的严谨，依赖都会写.

显示路径 SPC h d v load-path
(add-to-list 'load-path "/some/path/")
** Auto-loading
   require 列表还是很长很慢
   
   如果函数被定义为自动加载属性，那么只有函数被使用时，会被自动加载(第一次执行会轻微延时)

   当调用函数时，先执行文件  (autoload 'some-function "some-file")
   
   SPC h d f some-function 可以显示函数的属性 为 auto-loaded 函数
   
   文件样式 helm-autoloads.el
#+BEGIN_SRC emacs-lisp
  ;;;###autoload  ;;这个是 magic 注释,自动生成
  (defun my-function ()
    ;; Source code...
    )
#+END_SRC
自动加载的不光函数，还有 macros, major or minor modes, groups, classes, and so on.
还有下面的文件
#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (require 'helm)
#+END_SRC
*** Eval after load

当加载后要配置变量，可以用下面的函数
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'helm
       ;; Code
       )
#+END_SRC

*** Use-package(这个功能强大)
    https://github.com/jwiegley/use-package
   方式 1  
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :defer t
    :init
    ;; Code to execute before Helm is loaded
    :config
    ;; Code to execute after Helm is loaded
    )
#+END_SRC

模式场景
#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :mode "\\.rb\\'")
#+END_SRC

* layer (联合包,扩展包的功能)
** 层的内容
- declare additional layers 层定义
- the packages list and configuration  包的列表和配置
- all functions used in the layer should be declared here  函数定义
- layer specific configuration 层的特定配置
- general key bindings 键盘绑定

** 1.layers.el
   #+BEGIN_SRC emacs-lisp
     ;; 层 A 依赖层 B
     (configuration-layer/declare-layer 'B)
     ;;效果就像 B 加入了层配置变量
     ;; dotspacemacs-configuration-layers
#+END_SRC

** 2.packages.el
#+BEGIN_SRC emacs-lisp
    ;; 包列表
      (defconst mylayer-packages
        '(
          ;; Get the package from MELPA, ELPA, etc.
          some-package
          (some-package :location elpa)

          ;; A local package
          (some-package :location local)

          ;; A local package to be built with Quelpa
          (some-package :location (recipe :fetcher local))

          ;; A package recipe
          (some-package :location (recipe
                                   :fetcher github
                                   :repo "some/repo"))

          ;; An excluded package
          (some-package :excluded t)
          ))
  ;; Local packages should reside at <layer>/local/<package>/
#+END_SRC

For each included package, you may define one or more of the following
functions, which are called in order by Spacemacs to initialize the package.
1. =<layer>/pre-init-<package>=
2. =<layer>/init-<package>=
3. =<layer>/post-init-<package>=

*Note:* A package will not be installed unless at least one layer defines an
=init= function for it. That is to say, in a certain sense, the =init= function
does mandatory setup while the =pre-init= and =post-init= functions do optional
setup. This can be used for managing cross-layer dependencies, which we will
discuss later.

** 3.funcs.el
#+BEGIN_SRC emacs-lisp
  (when (configuration-layer/package-used-p 'my-package)
    (defun spacemacs/my-package-enable () ...)
    (defun spacemacs/my-package-disable () ...))
#+END_SRC

** 4.config.el
** 5.keybindings.el
* 实例学习 Case study: auto-completion
Spacemacs provides a layer called =auto-completion= which provides
auto-completion features in many modes. It does this using the package
=company=. This layer owns the =company= package, so it defines a function
called =auto-completion/init-company=.

When a user enables the =auto-completion= layer, Spacemacs locates it and finds
=company= in the list of packages. Provided that =company= is not excluded,
either by the user or another layer, Spacemacs then locates and runs the =init=
function for =company=. This function includes a call to =use-package= that sets
up the basic configuration.

However, auto-completion is a two-horse game. By its very nature, it is specific
to the major mode in question. It is pointless to expect the =auto-completion=
layer to include configuration for each conceivable major mode, and equally
futile to expect each programming language layer (python, ruby, etc.) to fully
configure =company= on their own.

This is solved using the =post-init= functions. The Python layer, for example,
includes the =company= package and defines a function called
=python/post-init-company=. This function is called after
=auto-completion/init-company=, but it is not called if
- the =auto-completion= layer is not enabled, in which case no =init= function
  for =company= will be found, or
- the =company= package is excluded either by the user or another layer

As such, =python/post-init-company= is the /only/ safe place to put
configuration related to =company= in Python mode.

If the Python layer had defined an =init= function for =company=, that package
would have been installed even if the =auto-completion= layer had been disabled,
which is not what we want.

* Layer tips and tricks
** Cross-dependencies
Spacemacs provides a couple of additional useful functions you can use to check
whether other layers or packages are included.
- check if a layer is enabled
- check if a package is or will be installed

These are useful in some cases, but usually you can get the desired result just
by using =post-init= functions.

For layers that require another layers to be enabled, use the functions
=configuration-layer/declare-layer= and =configuration-layer/declare-layers= to
ensure that layers are enabled even if the user has not enabled them explicitly.
Calls to these functions must go in the =layers.el= file.

** Shadowing
Shadowing is the operation of replacing a used layer by another one. For
instance if a used layer A can shadow a used layer B and the layer A is listed
after the layer B in the dotfile then the layer A replaces the layer B and it is
like only the layer A is being used.

Examples of this mechanism are helm/ivy layers or neotree/treemacs layers.

A layer can shadow other layers by calling in its =layers.el= file the function
=configuration-layer/declare-shadow-relation=. This function declares a
=can-shadow= relation between all the layers.

=can-shadow= is a commutative relation, if layer A can shadow layer B then layer
B can shadow layer A.

The =shadow= operator is a binary operator accepting two layer names, it is not
commutative and the order of the operands is determined by the order of the
layers in the dotfile (like the ownership stealing mechanism).

If =:can-shadow= property is set explicitly to =nil= in the dotfile then the
layer won’t shadow any layer.

For instance to install both ivy and helm layer:

#+BEGIN_SRC emacs-lisp
  (setq dotspacemacs-configuration-layers
   '(
     ivy
     (helm :can-shadow nil)
     )
#+END_SRC

note that due to the commutative relation =can-shadow= the above example can
also be written like this (in this case, =:can-shadow= should be read
=:can-be-shawdowed=):

#+BEGIN_SRC emacs-lisp
  (setq dotspacemacs-configuration-layers
  '(
    (ivy :can-shadow nil)
    helm
    )
#+END_SRC

We will prefer the first form as it is more intuitive.

** Use-package init and config
In the vast majority of cases, a package =init= function should do nothing but
call to =use-package=. Again, in the vast majority of cases, all the
configuration you need to do should be doable within the =:init= or =:config=
blocks of such a call.

What goes where? Since =:init= is executed before load and =:config= after,
these rules of thumb apply.

In =:config= should be
- Anything that requires the package to be already loaded.
- Anything that takes a long time to run, which would ruin startup performance.

The =:init= block should contain setup for the entry points to the package. This
includes key bindings, if the package should be loaded manually by the user, or
hooks, if the package should be loaded upon some event. It is not unusual to
have both!

** Use-package hooks
Spacemacs includes a macro for adding more code to the =:init= or =:config=
blocks of a call to =use-package=, after the fact. This is useful for =pre-init=
or =post-init= functions to “inject” code into the =use-package= call of the
=init= function.

#+BEGIN_SRC emacs-lisp
  (spacemacs|use-package-add-hook helm
    :pre-init
    ;; Code
    :post-init
    ;; Code
    :pre-config
    ;; Code
    :post-config
    ;; Code
    )
#+END_SRC

Since a call to =use-package= may evaluate the =:init= block immediately, any
function that wants to inject code into this block must run =before= the call to
=use-package=. Further, since this call to =use-package= typically takes place
in the =init-<package>= function, calls to =spacemacs|use-package-add-hook=
*always* happen in the =pre-init-<package>= functions, and not in
=post-init-<package>=.

** Best practices
If you break any of these rules, you should know what you are doing and have a
good reason for doing it.

*** Package ownership
Each package should be owned by one layer only. The layer that owns the
package should define its =init= function. Other layers should rely on
=pre-init= or =post-init= functions.

*** Localize your configuration
*Each function can only assume the existence of one package.* With some
exceptions, the =pre-init=, =init= and =post-init= functions can /only/
configure exactly the package they are defined for. Since the user can exclude
an arbitrary set of packages, there is no /a priori/ safe way to assume that
another package is included. Use =configuration-layer/package-usedp= if you
must.

This can be very challenging, so please take this as a guideline and not
something that is absolute. It is quite possible for the user to break her
Spacemacs installation by excluding the wrong packages, and it is not our
intention to prevent this at all costs.

*** Load ordering
In Spacemacs, layers are loaded in order of inclusion in the dotfile, and
packages are loaded in alphabetical order. In the rare cases where you make use
of this property, you should make sure to document it well. Many will assume
that layers can be included in arbitrary order (which is true in most cases),
and that packages can be renamed without problems (which is also in most cases).

Preferably, write your layer so that it is independent of load ordering. The
=pre= - and =post-init= functions are helpful, together with
=configuration-layer/package-usedp=.

*** No require
Do not use require. If you find yourself using =require=, you are almost
certainly doing something wrong. Packages in Spacemacs should be loaded through
auto-loading, and not explicitly by you. Calls to =require= in package init
functions will cause a package to be loaded upon startup. Code in an =:init=
block of =use-package= should not cause anything to be loaded, either. If you
need a =require= in a =:config= block, that is a sign that some other package is
missing appropriate auto-loads.

*** Auto-load everything
Defer everything. You should have a very good reason not to defer the loading
of a package.
* lsp java
  Supported commands
LSP Mode commands
lsp-execute-code-action - Execute code action.
lsp-rename - Rename symbol at point
lsp-describe-thing-at-point - Display help for the thing at point.
lsp-goto-type-definition - Go to type definition
lsp-goto-implementation - Go to implementation
lsp-restart-workspace - Restart project
lsp-format-buffer - Format current buffer
lsp-symbol-highlight - Highlight all relevant references to the symbol under point.
lsp-workspace-folders-add - Add workspace folder
lsp-workspace-folders-remove - Remove workspace folder
lsp-workspace-folders-switch - Switch workspace folder
LSP Java commands
lsp-java-organize-imports - Organize imports
lsp-java-build-project - Perform partial or full build for the projects
lsp-java-update-project-configuration - Update project configuration
lsp-java-actionable-notifications - Resolve actionable notifications
lsp-java-update-user-settings - Update user settings (Check the options in the table bellow.)
lsp-java-update-server - Update server instalation.
Refactoring
LSP Java provides rich set of refactorings via Eclipse JDT Language Server code actions and some of them are bound to Emacs commands:

lsp-java-extract-to-constant - Extract constant refactoring
lsp-java-add-unimplemented-methods - Extract constant refactoring
lsp-java-create-parameter - Create parameter refactoring
lsp-java-create-field - Create field refactoring
lsp-java-create-local - Create local refactoring
lsp-java-extract-method - Extract method refactoring
lsp-java-add-import - Add missing import
Treemacs
lsp-java provides experimental integration with treemacs which provides option to navigate through package dependecies, namespaces, classes and resources.

lsp-java-treemacs-register activates lsp-java/treemacs integration.
lsp-java-treemacs-unregister deactivates lsp-java/treemacs integration.
lsp-java-update-project-uris refresh the project URIs.
Classpath browsing
lsp-java the command lsp-java-classpath-browse which allows users to browse the structure of current projects classpath. From that view the users could go to the particular item. Classpath

Spring Initializr

lsp-java provides a frontend for Spring Initializr which simplifies the creation
of Spring Boot projects directly from Emacs via lsp-java-spring-initializr.
Create Spring boot project

Supported settings
lsp-java-server-install-dir - Install directory for eclipsejdtls-server
lsp-java-java-path - Path of the java executable
lsp-java-workspace-dir - LSP java workspace directory
lsp-java-workspace-cache-dir - LSP java workspace cache directory
lsp-java-vmargs - Specifies extra VM arguments used to launch the Java Language Server
lsp-java-incomplete-classpath - Specifies the severity of the message when the classpath is incomplete for a Java file
lsp-java-update-build-configuration - Specifies how modifications on build files update the Java classpath/configuration
lsp-java-import-exclusions - Configure glob patterns for excluding folders
lsp-java-favorite-static-members - Defines a list of static members or types with static members
lsp-java-import-order - Defines the sorting order of import statements
lsp-java-trace-server - Traces the communication between Emacs and the Java language server
lsp-java-enable-file-watch - Defines whether the client will monitor the files for changes
lsp-java-format-enabled - Specifies whether or not formatting is enabled on the language server
lsp-java-format-settings-url - Specifies the file path to the formatter xml url
lsp-java-format-settings-profile - Specifies the formatter profile name
lsp-java-format-comments-enabled - Preference key used to include the comments during the formatting
lsp-java-save-action-organize-imports - Organize imports on save
lsp-java-bundles - List of bundles that will be loaded in the JDT server
lsp-java-import-gradle-enabled - Enable/disable the Gradle importer
lsp-java-import-maven-enabled - Enable/disable the Maven importer
lsp-java-auto-build - Enable/disable the 'auto build'
lsp-java-progress-report - [Experimental] Enable/disable progress reports from background processes on the server
lsp-java-completion-guess-arguments - When set to true, method arguments are guessed when a method is selected from as list of code assist proposals.
Additional packages
lsp-ui : Flycheck, documentation and code actions support.
company-lsp : LSP company backend.
treemacs : Project viewer.
FAQ
LSP Java is showing to many debug messages, how to stop that? Add the following configuration.
(setq lsp-inhibit-message t)
lsp-ui does not display all of the actions on the current point(e. g "Extract constant")? LSP UI by default sends current line bounds for action region which breaks forces JDT server to return only "Extract method action."
(setq lsp-ui-sideline-update-mode 'point)
LSP Java does not provide completion, go to definition for some of the files?
When particular file is not part of imported project Eclipse JDT Language Server could not calculate the current classpath.
