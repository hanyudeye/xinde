* javascript
** 运行
   nodejs js.js 
   浏览器 
** 输出
   window.alert()
   document.write()
   innerHTML
   console.log
** 对象
   Document, Element, Function, Array ,Boolean ,Date , String  , Number
   Math , Object, RegExp
** 对象构造器
   #+BEGIN_SRC javascript
     function person(firstname,lastname,age,eyecolor)
     {
         this.firstname=firstname;
         this.lastname=lastname;
         this.age=age;
         this.eyecolor=eyecolor;
     }
   #+END_SRC

   #+BEGIN_SRC 
  JavaScript for...in 语句循环遍历对象的属性, 数组。
  数组 concat() join() sort() Array()
  RegExp 对象有 3 个方法：test()、exec() 以及 compile()。
  #+END_SRC
** 事件, 对象对于外部反应的属性
   document.getElementById("btnTest").onclick=thisTest; //给button的onclick事件注册一个函数
*** 事件类型
 #+BEGIN_SRC 
   页面或图像载入
  鼠标悬浮于页面的某个热点之上
  在表单中选取输入框
  确认表单
  键盘按键
  onload 和 onUnload 当用户进入或离开页面时就会触发 onload 和 onUnload 事件。
  onFocus, onBlur 和 onChange onFocus、onBlur 和 onChange 事件通常相互配合用来验证表单。
  onSubmit onSubmit 用于在提交表单之前验证所有的表单域。
  onMouseOver 和 onMouseOut onMouseOver 和 onMouseOut 用来创建“动态的”按钮。
 #+END_SRC 
** Try...Catch 语句
   #+BEGIN_SRC js
     try
     {
         //在此运行代码
     }
     catch(err)
     {
         //在此处理错误
     }
   #+END_SRC
下面的例子原本用在用户点击按钮时显示 "Welcome guest!" 这个消息。不过 message() 函数中的 alert() 被误写为 adddlert()。这时错误发生了：
<html>
<head>
<script type="text/javascript">
function message()
{
adddlert("Welcome guest!")
}
</script>
</head>

<body>
<input type="button" value="View message" onclick="message()" />
</body>

</html>
我们可以添加 try...catch 语句，这样当错误发生时可以采取更适当的措施。
下面的例子用 try...catch 语句重新修改了脚本。由于误写了 alert()，所以错误发生了。不过这一次，catch 部分捕获到了错误，并用一段准备好的代码来处理这个错误。这段代码会显示一个自定义的出错信息来告知用户所发生的事情。
<html>
<head>
<script type="text/javascript">
var txt=""
function message()
{
try
  {
  adddlert("Welcome guest!")
  }
catch(err)
  {
  txt="此页面存在一个错误。\n\n"
  txt+="错误描述: " + err.description + "\n\n"
  txt+="点击OK继续。\n\n"
  alert(txt)
  }
}
</script>
</head>

<body>
<input type="button" value="View message" onclick="message()" />
</body>

</html>
实例 2
下一个例子会显示一个确认框，让用户来选择在发生错误时点击确定按钮来继续浏览网页，还是点击取消按钮来回到首页。如果 confirm 方法的返回值为 false，代码会把用户重定向到其他的页面。如果 confirm 方法的返回值为 true，那么代码什么也不会做。
<html>
<head>
<script type="text/javascript">
var txt=""
function message()
{
try
  {
  adddlert("Welcome guest!")
  }
  catch(err)
  {
  txt="There was an error on this page.\n\n"
  txt+="Click OK to continue viewing this page,\n"
  txt+="or Cancel to return to the home page.\n\n"
  if(!confirm(txt))
    {
    document.location.href="http://www.w3school.com.cn/"
    }
  }
}
</script>
</head>

<body>
<input type="button" value="View message" onclick="message()" />
</body>

</html>
onerror 事件
我们马上会讲解 onerror 事件。但首先您需要学习如何使用 throw 语句来创建异常。throw 语句可以与 try...catch 语句一起使用。
** json
   JSON用于描述数据结构，有以下形式存在。
   对象（object）：一个对象以{开始，并以}结束。一个对象包含一系列非排序的名称／值对，每个名称／值对之间使用,分区。
   名称／值（collection）：名称和值之间使用：隔开，一般的形式是：
   {name:value}
   一个名称是一个字符串； 一个值可以是一个字符串，一个数值，一个对象，一个布尔值，一个有序列表，或者一个null值。
   值的有序列表（Array）：一个或者多个值用,分区后，使用[，]括起来就形成了这样的列表，形如：
   [collection, collection]
   字符串：以""括起来的一串字符。
   数值：一系列0-9的数字组合，可以为负数或者小数。还可以用e或者E表示为指数形式。
   布尔值：表示为true或者false。
  
 #+BEGIN_SRC json
 {
       "firstName": "John",
       "lastName": "Smith",
       "sex": "male",
       "age": 25,
       "address": 
       {
           "streetAddress": "21 2nd Street",
           "city": "New York",
           "state": "NY",
           "postalCode": "10021"
       },
       "phoneNumber": 
       [
           {
             "type": "home",
             "number": "212 555-1234"
           },
           {
             "type": "fax",
             "number": "646 555-4567"
           }
       ]
   }
 [
 {
      "text":"This is the text","color":"dark_red","bold":"true","strikethough":"true","clickEvent":
           {"action":"open_url","value":"zh.wikipedia.org"},
      "hoverEvent":
           {"action":"show_text","value":
                {"extra":"something"}
           }
 },
 {
      "translate":"item.dirt.name","color":"blue","italic":"true"
 }
 ]

 #+END_SRC
** 定时器 
 执行一次 setTimeout
 重复执行 setInterval
 #+BEGIN_SRC html 
   <html>
     <head>
       <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
       <title>无标题文档</title>
       <script language="JavaScript" type="text/javascript">
         var str = "这个是测试用的范例文字";
         var seq = 0;
         var second=1000; //间隔时间1秒钟
         function scroll() {
         msg = str.substring(0, seq+1);
         document.getElementByIdx_x_x('word').innerHTML = msg;
         seq++;
         if (seq >= str.length) seq = 0;
         }
       </script>
     </head>
     <body onload="setInterval('scroll()',second)">
       <div id="word"></div><br/><br/>
     </body>
   </html>
 <p>页面上显示时钟：</p>
 <p id="demo"></p>
 <button onclick="myStopFunction()">停止时钟</button>
 <script>
 var myVar=setInterval(function(){myTimer()},1000);
 function myTimer(){
	 var d=new Date();
	 var t=d.toLocaleTimeString();
	 document.getElementById("demo").innerHTML=t;
 }
 function myStopFunction(){
	 clearInterval(myVar);
 }
 </script>


 #+END_SRC
** 原型
#+BEGIN_SRC js
  小写转大写
    Array.prototype.myUcase=function(){
        for (i=0;i<this.length;i++){
            this[i]=this[i].toUpperCase();
        }
    }
#+END_SRC
** 函数库(对象库)
*** Date对象
 #+BEGIN_SRC js
         日期 Date() getTime() setFullYear() toUTString getDay()
         new Date() // 当前日期和时间
         new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数
         new Date(dateString)
         new Date(year, month, day, hours, minutes, seconds, milliseconds)

      milliseconds 毫秒（0-999） 1秒=1000毫秒
         var today = new Date()
         var d1 = new Date("October 13, 1975 11:13:00")
         var d2 = new Date(79,5,24)
         var d3 = new Date(79,5,24,11,33,0)
          设置日期
         var myDate=new Date();
         myDate.setFullYear(2010,0,14);

         设置日期为5天后
         var myDate=new Date();
         myDate.setDate(myDate.getDate()+5);
   getTime 获取毫秒时间
 #+END_SRC
*** Math
    abs 绝对值
    E 自然对数
    LN2 2的自然对数
    PI 圆周率
    Math.SQRT2 2的平方根
    sqrt 平方根
    pow(x, y) x的y次方
    max
    min
    ceil 上
    floor 下
    round 四舍五入
*** json 函数
   var strify = JSON.stringify(arr);
   var arrParse = JSON.parse(strify);
*** 正则 search replace
    #+BEGIN_SRC js
           var s="helo world";
           var i=s.search(/wo/i);
      i: 不区分大小写
    #+END_SRC

* DOM
*** window
**** 属性
***** closed 	      返回窗口是否已被关闭
***** defaultStatus 	设置或返回窗口状态栏中的默认文本
***** innerheight 	  返回窗口的文档显示区的高度。
***** innerwidth 	  返回窗口的文档显示区的宽度。
***** length 	      设置或返回窗口中的框架数量。
***** location 	    用于窗口或框架的 Location 对象。请参阅 Location 对象。 
***** name 	        设置或返回窗口的名称。
***** outerheight 	  返回窗口的外部高度。 
***** outerwidth 	  返回窗口的外部宽度。 
***** pageXOffset 	  设置或返回当前页面相对于窗口显示区左上角的 X 位置。
***** pageYOffset 	  设置或返回当前页面相对于窗口显示区左上角的 Y 位置。
***** parent 	      返回父窗口。 	
***** self 	        返回对当前窗口的引用。等价于 Window 属性。 	
***** status 	      设置窗口状态栏的文本。
***** top 	          返回最顶层的先辈窗口。
***** screenLeft     IE、Safari 和 Opera 支持 screenLeft 和 screenTop
***** screenTop
***** screenX        Firefox 和 Safari 支持 screenX 和 screenY。   
***** screenY        只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。
***** onload
**** 方法
***** alert() 	           显示带有一段消息和一个确认按钮的警告框。
***** blur() 	           把键盘焦点从顶层窗口移开。
***** clearInterval() 	   取消由 setInterval() 设置的 timeout。 
***** clearTimeout()      取消由 setTimeout() 方法设置的 timeout。
***** close() 	           关闭浏览器窗口。 
***** confirm() 	         显示带有一段消息以及确认按钮和取消按钮的对话框。
***** createPopup() 	     创建一个 pop-up 窗口
***** focus() 	           把键盘焦点给予一个窗口
***** moveBy() 	         可相对窗口的当前坐标把它移动指定的像素
***** moveTo() 	         把窗口的左上角移动到一个指定的坐标。
***** open() 	           打开一个新的浏览器窗口或查找一个已命名的窗口
     window.open("http://www.baidu.com", "_blank");
***** opener 访问打开的原窗口
***** print()    	       打印当前窗口的内容。(打印机）
***** prompt() 	         显示可提示用户输入的对话框。 
***** resizeBy() 	       按照指定的像素调整窗口的大小。
***** resizeTo() 	       把窗口的大小调整到指定的宽度和高度。
***** scrollBy() 	       按照指定的像素值来滚动内容。 
***** scrollTo() 	       把内容滚动到指定的坐标。
***** setInterval() 	     按照指定的周期（以毫秒计）来调用函数或计算表达式。
***** setTimeout() 	     在指定的毫秒数后调用函数或计算表达式。
*** navigator 浏览器
**** 属性
***** appCodeName 	        返回浏览器的代码名。 
***** appMinorVersion 	    返回浏览器的次级版本。
***** appName 	            返回浏览器的名称。 
***** appVersion 	        返回浏览器的平台和版本信息。
***** browserLanguage 	    返回当前浏览器的语言。
***** cookieEnabled 	      返回指明浏览器中是否启用 cookie 的布尔值。
***** cpuClass 	          返回浏览器系统的 CPU 等级。 
***** onLine 	            返回指明系统是否处于脱机模式的布尔值。
***** platform 	          返回运行浏览器的操作系统平台。 
***** systemLanguage 	    返回 OS 使用的默认语言。
***** language
***** userAgent 	          返回由客户机发送服务器的 user-agent 头部的值。 
***** userLanguage 	      返回 OS 的自然语言设置。
**** 方法
***** javaEnabled() 	      规定浏览器是否启用 Java。
***** taintEnabled() 	    规定浏览器是否启用数据污点 (data tainting)
*** screen
**** 属性
***** availHeight 	     返回显示屏幕的高度 (除 Windows 任务栏之外)。
***** availWidth 	     返回显示屏幕的宽度 (除 Windows 任务栏之外)。 
***** bufferDepth 	     设置或返回在 off-screen bitmap buffer 中调色板的比特深度。
***** colorDepth 	     返回目标设备或缓冲器上的调色板的比特深度。
***** deviceYDPI 	     返回显示屏幕的每英寸垂直点数。 
***** height 	         返回显示屏幕的高度。 
***** pixelDepth 	     返回显示屏幕的颜色分辨率（比特每像素）
***** width 	           返回显示器屏幕的宽度。 
*** history
**** 属性
***** length            返回浏览器历史列表中的 URL 数量
**** 方法
***** back() 	          加载 history 列表中的前一个 URL 	
***** forward() 	        加载 history 列表中的下一个 URL 
***** go() 	            加载 history 列表中的某个具体页面 [Num|URL] e: -1 前一个页面	
*** location 跟浏览器url 相关
**** 属性
***** hash 	            设置或返回从井号 (#) 开始的 URL（锚）。
***** host 	            设置或返回主机名和当前 URL 的端口号。 
***** hostname 	        设置或返回当前 URL 的主机名。 
***** href 	            设置或返回完整的 URL。
***** pathname 	        设置或返回当前 URL 的路径部分。 
***** port 	            设置或返回当前 URL 的端口号。
***** protocol 	        设置或返回当前 URL 的协议。 
***** search           	设置或返回从问号 (?) 开始的 URL（查询部分）。
**** 方法
***** assign() 	        加载新的文档。 
***** reload() 	        重新加载当前文档。
***** replace() 	        用新的文档替换当前文档。 
*** document
**** 集合
***** all[]       	      提供对文档中所有 HTML 元素的访问。 document.all[0],不会用样式,script
***** anchors[] 	        返回对文档中所有 Anchor 对象的引用。 
***** applets 	          返回对文档中所有 Applet 对象的引用。
***** forms[] 	          返回对文档中所有 Form 对象引用。
***** images[] 	        返回对文档中所有 Image 对象引用。
***** links[] 	          返回对文档中所有 Area 和 Link 对象引用。
**** 属性
***** body    	          提供对 <body> 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 <frameset>。 	  	  	  	 
***** cookie 	          设置或返回与当前文档有关的所有 cookie。
***** domain 	          返回当前文档的域名。 	
***** lastModified 	    返回文档被最后修改的日期和时间。 该值来自于 Last-Modified HTTP 头部，它是由 Web 服务器发送的可选项	
***** referrer 	        返回载入当前文档的文档的 URL。
***** title 	            返回当前文档的标题。 
***** URL 	              返回当前文档的 URL。 
**** 方法
***** close() 	             关闭用 document.open() 方法打开的输出流，并显示选定的数据。 
***** getElementById() 	   返回对拥有指定 id 的第一个对象的引用。
***** getElementsByName()   返回带有指定名称的对象集合。 	
***** getElementsByTagName()返回带有指定标签名的对象集合。
***** getElementsByClassName()返回带有指定 class 的对象集合。
***** open() 	             打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。
***** write()    	         向文档写 HTML 表达式 或 JavaScript 代码。 
***** writeln() 	           等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 
#+BEGIN_SRC javascript
<script type="text/javascript">
function createNewDoc()
  {
  var newDoc=document.open("text/html","replace");
  var txt="<html><body>学习 DOM 非常有趣！</body></html>";
  newDoc.write(txt);
  newDoc.close();
  }
</script>
#+END_SRC
*** 公共属性
***** className 	           Sets or returns the class attribute of an element
***** dir 	                 (设置文字方向) ltr默认。从左向右的文本方向。rtl 	从右向左的文本方向。	
***** lang 	                 Sets or returns the language code for an element
***** title 	               Sets or returns an element's advisory title 
*** Style
***** document.getElementById("id").style.property="值"
**** 属性
***** 背景
****** background 	          在一行中设置所有的背景属性 
****** backgroundAttachment 	设置背景图像是否固定或随页面滚动 
****** backgroundColor 	    设置元素的背景颜色 
****** backgroundImage 	    设置元素的背景图像 
****** backgroundPosition 	  设置背景图像的起始位置 
****** backgroundPositionX 	设置backgroundPosition属性的X坐标 
****** backgroundPositionY 	设置backgroundPosition属性的Y坐标 
****** backgroundRepeat 	    设置是否及如何重复背景图像
***** 边框和边距
      border             	在一行设置四个边框的所有属性 	
      borderBottom  	    在一行设置底边框的所有属性 
      borderBottomColor 	设置底边框的颜色 	
      borderBottomStyle 	设置底边框的样式 	
      borderBottomWidth 	设置底边框的宽度 	
      borderColor     	  设置所有四个边框的颜色 (可设置四种颜色) 	
      borderLeft       	  在一行设置左边框的所有属性 
      borderLeftColor 	  设置左边框的颜色 	
      borderLeftStyle 	  设置左边框的样式 	
      borderLeftWidth 	  设置左边框的宽度 	
      borderRight 	      在一行设置右边框的所有属性
      borderRightColor 	  设置右边框的颜色 	
      borderRightStyle 	  设置右边框的样式 	
      borderRightWidth 	  设置右边框的宽度 	
      borderStyle 	      设置所有四个边框的样式 (可设置四种样式) 
      borderTop 	        在一行设置顶边框的所有属性 
      borderTopColor 	    设置顶边框的颜色 		
      borderTopStyle 	    设置顶边框的样式 		
      borderTopWidth 	    设置顶边框的宽度 		
      borderWidth 	      设置所有四条边框的宽度 (可设置四种宽度) 
      margin 	            设置元素的边距 (可设置四个值)
      marginBottom        设置元素的底边距
      marginLeft 	        设置元素的左边距 	
      marginRight 	      设置元素的右边据
      marginTop 	        设置元素的顶边距 	
      outline 	          在一行设置所有的outline属性 
      outlineColor 	      设置围绕元素的轮廓颜色 	
      outlineStyle 	      设置围绕元素的轮廓样式 	
      outlineWidth 	      设置围绕元素的轮廓宽度 	
      padding 	          设置元素的填充 (可设置四个值)
      paddingBottom       设置元素的下填充
      paddingLeft 	      设置元素的左填充
      paddingRight 	      设置元素的右填充
      paddingTop 	        设置元素的顶填充 	
***** 布局
      clear    	        设置在元素的哪边不允许其他的浮动元素 	
      clip      	      设置元素的形状 	
      content 	        设置元信息 	
      counterIncrement 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器的增量。默认是1。
      counterReset 	    设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器被设置的值。默认是0。
      cssFloat 	        设置图像或文本将出现（浮动）在另一元素中的何处。 	
      cursor   	        设置显示的指针类型 
      direction 	      设置元素的文本方向 	
      display 	        设置元素如何被显示 	inherit父的属性继承
      height 	          设置元素的高度 
      markerOffset 	    设置marker box的principal box距离其最近的边框边缘的距离
      marks 	          设置是否cross marks或crop marks应仅仅被呈现于page box边缘之外 	
      maxHeight 	      设置元素的最大高度 	
      maxWidth 	        设置元素的最大宽度 	
      minHeight 	      设置元素的最小高度 	
      minWidth 	        设置元素的最小宽度 	
****** overflow 	规定如何处理不适合元素盒的内容 	
       overflow-x:      hidden;隐藏水平滚动条
       verticalAlign 	  设置对元素中的内容进行垂直排列 
       visibility 	    设置元素是否可见 
       width 	          设置元素的宽度
***** 列表
      listStyle 	在一行设置列表的所有属性 
      listStyleImage 	把图像设置为列表项标记 
      listStylePosition改变列表项标记的位置 	
      listStyleType 	设置列表项标记的类型
***** 定位
      bottom 	设置元素的底边缘距离父元素底边缘的之上或之下的距离 	
      left       	置元素的左边缘距离父元素左边缘的左边或右边的距离 	
      position 	把元素放置在static, relative, absolute 或 fixed 的位置 	
      right 	            置元素的右边缘距离父元素右边缘的左边或右边的距离 	
      top 	            设置元素的顶边缘距离父元素顶边缘的之上或之下的距离 	
      zIndex 	设置元素的堆叠次序
***** 文本
      color 	设置文本的颜色 
      font 	在一行设置所有的字体属性 
      fontFamily 	设置元素的字体系列。
      fontSize 	设置元素的字体大小。
      fontSizeAdjust 	设置/调整文本的尺寸 
      fontStretch 	设置如何紧缩或伸展字体
      fontStyle 	设置元素的字体样式 
      fontVariant 	用小型大写字母字体来显示文本 
      fontWeight 	设置字体的粗细 
      letterSpacing 	设置字符间距 
      lineHeight 	设置行间距 
      quotes 	设置在文本中使用哪种引号 
      textAlign 	排列文本 
      textDecoration 	设置文本的修饰 
      textIndent 	缩紧首行的文本 
      textShadow 	设置文本的阴影效果
      textTransform 	对文本设置大写效果 
      whiteSpace 	设置如何设置文本中的折行和空白符 	
      wordSpacing 	设置文本中的词间距 
***** Table 
      borderCollapse 	设置表格边框是否合并为单边框，或者像在标准的HTML中那样分离。 
      borderSpacing 	设置分隔单元格边框的距离 
      captionSide 	设置表格标题的位置 	
      emptyCells 	设置是否显示表格中的空单元格
      tableLayout 	设置用来显示表格单元格、行以及列的算法
*** node
**** 节点属性
***** innerHTML: 获取元素内容,很多东西
***** nodeName 规定节点的名称
***** nodeValue 规定节点的值 (文本节点有值)
***** nodeType 返回节点的类型。nodeType 是只读的
      #+BEGIN_SRC 
      元素 	1
      属性 	2
      文本 	3
      注释 	8
文档 	9
      #+END_SRC
      : 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
**** 修改
***** 创建新的 HTML 元素
      var para=document.createElement("p");
      var node=document.createTextNode("This is new.");
      para.appendChild(node);
**** HTML DOM - 元素
***** 创建新的 HTML 元素 - appendChild()您首先必须创建该元素，然后把它追加到已有的元素上。
***** 创建新的HTML元素 - insertBefore()
***** 删除已有的HTML元素
      #+BEGIN_SRC 
      var child=document.getElementById("p1");
      child.parentNode.removeChild(child);
      #+END_SRC
***** 替换 HTML 元素
      : 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：
      #+BEGIN_SRC 
      var parent=document.getElementById("div1");
      var child=document.getElementById("p1");
      parent.replaceChild(para,child);
      #+END_SRC
**** HTML DOM事件
***** window 事件属性
      onload    页面结束加载之后触发。   
      onresize  当浏览器窗口被调整大小时触发。 
***** FORM 事件
      onselect      script 在元素中文本被选中后触发。            
      onsubmit      script 在提交表单时触发。                   
***** 键盘事件
      onkeydown  script 在用户按下按键时触发。
      onkeypress script 在用户敲击按钮时触发。
      onkeyup    script 当用户释放按键时触发。
***** Mouse事件
      onclick
      ondblclick
      onmousedown
      onscroll
***** Media事件
      onabort
      onplay
***** onmousedown、onmouseup 以及 onclick 事件
* source code 
  #+BEGIN_SRC javascript
  var a=35;
var b=53;
var c=a+b; 
var str='a,b,c';
var myarr = ['a', 'b', 'c'];

var mutou="mutou";
var zuozi={
    'color':'black',  
    'cailiao':mutou,  
    'chang':123  
};

var d='2017-8-8';
var e='2017-8-7';
var timestamp = Date.parse(new Date(d));
var timestamp2 = Date.parse(new Date(e));
//timestamp = timestamp / 1000;

//console.log(timestamp);         // 
//console.log(timestamp2);

//console.log(timestamp>timestamp2);
var diannao = new Object();

diannao.display='led';
diannao.keyboard='leven';
var copydian=diannao;
copydian.display='eld';
//console.log(diannao.display);
//console.log(diannao.display);

function f(arg){
    arg.name='bbb'; 
}

var arg= new Object();

arg.name='cc';
f(arg);

//console.log(arg.name);

//基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。因为访问变量有按值和按引用两种方式，而参数只能按值传递。
//理解在做什么和说什么。这样会对事物的理解有所加强。
//在向参数 被传递的值会被复制给一个局部变量。即命名参数，或者用  就是arguments  对象中的一个元素。在向参数传递引用类型的值时，会把这个值在内存中的地址
//复制给一个局部变量, 因此这个局部变量的变化会反映在函数的外部。


function addTen(num){
    num +=10;
    return num;
}

//console.log(typeof(addTen));

var nul=null;
//console.log(typeof(nul));

var stri="este";
var num=23.1234;

//console.log(typeof(stri));
//console.log(typeof(num));

var o= new Object();
//console.log(o instanceof Object);
//执行环境定义了变量或者函数有访问的其他数据。每个执行环境都有一个与之关联的变量对象。环境中定义的所有变量和函数
//在web浏览器中，全局环境被认为是window对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，//
//保存在其中的所有变量和函数定义也随之销毁
// 每个函数都有自己的执行环境。。 k

for(var i=0;i<11;i++){
    
}

var person={
    name:"wuming",
    age: 30
};
function niaoyuhuaxiang(bird){
    var output="";
    if(typeof bird.name == "string"){
        output+='bird name is '+bird.name;
    }

    if(typeof bird.age=="number"){
        output+='bird age is '+bird.age;
    }
    return output;
}
//console.log(person.age);

var birdinstance={
    "name":"xiaoniao"
};

var arr=['a', 'b'];

//console.log(arr.join('||'));
////console.log(Array.isArray(arr));
//console.log( arr instanceof Array);
//console.log(niaoyuhuaxiang(birdinstance));
// console.log(arr.valueOf());


var person1={
    name:"wuming", 
    toLocaleString: function(){
        return "wuming";
    }, 

    toString: function(){
        return "wuming";
    }
};


var person2={
    toLocaleString: function(){
        return "xiaoming";
    }, 

    toString: function(){
        return "xm";
    }
};

var people=[person1, person2];
//console.log(people.toString());
//console.log(people.toLocaleString());

var colors= new Array();
var count=colors.push('red', 'blue', 'green');
var result=colors.every(function(item, index, array){
    
    return index;
});
//console.log(result);
//var index=colors.indexOf("reda")==-1;
//console.log(index);
//console.log(colors);
//colors.reverse();
//console.log(colors);

//var color1=colors.slice(1, 2);

//console.log(color1);

//var col1=colors.splice(0, 2);
var col1=colors.splice(2, 0, "Green", "yellow", 'black' );
//console.log(col1);
//console.log(colors);
//插入，可以向指定位置插入任意数量的项，只需提供3个参数：启示位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五、以至任意多个项。

//splice 始终返回一个数组，如果没有删除的项，则返回一个空数组

var number=[1, 2,3, 4, 5, 6];
var sum=number.reduce(function(prev, cur, index, array){
    return prev+cur;
});
//console.log(sum);
//console.log(number);


var everyResult = number.some(function(item, index, array){
    return item>6;
});

//console.log(everyResult);
number.forEach(function(item, index){
  //  console.log(item);
  //  console.log(index);
});

var result = number.map(function(item){
    return item*2;
});


//console.log(number);
//console.log(result);


var now1 = new Date(Date.now());
//console.log("start");
//console.log("end");
var now2 = Date.now();
var now=now2-now1;
//console.log("time is");
//console.log(now);

//console.log(now1.getFullYear());


var text="hell bge lo age world";
var pattern1=/[ab]ge/g;
var t=pattern1.exec(text);
//console.log(pattern1.lastIndex);
//input 最近一次要匹配的字符串。
//lastMatch 最近一次的匹配项。
// var text = "this has been a short summer";
// var pattern = /(.)hort/g;
// if(pattern.text(text)){
//alert(RegExp.$_);
//alert(RegExp["$`"]);
//}

//但相对于perl所支持的高级正则表达式。  匹配字符串开始和结尾的|A和\Z 锚点 , 但支持^ 和$符号表示开头和结尾
//lookahead 向后查找jjJKJJKJj

var xiaoqing = function(arg1, arg2){
    return arg1+arg2;
};

//最后一种定义函数的方式是使用Function构造函数。最后一个参数被看作是函数体
//var sum = new Function("num1", "num2", "return num1+num2");
//函数申明 解析器n 函数的名字仅仅是 脱缰的野马，伴随着疼痛，驶入远方的田野。 这个属性中保存着调用当前函数的函数的引用 caller 如果没有删除的项
//是在全局作用域

function outer(){
    inner();
}

function inner(){
    console.log("inner");
    console.log(arguments.callee.caller);
}

function sayName(name){
    console.log(name); 
}

//console.log(sayName.length);

//prototype 是保存他们所有实例方法的真正所在。诸如toString() 和valueOf() 等的方法实际上都保存在prototype, prototype属性
//是不可枚举的，因此使用for in 无法发现
//apply() 和call(). 一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments 对象。j

function sum1(num1, num2){
    return num1+num2;
}

function callSum1(num1, num2){
    return sum1.apply(this, arguments);
}
//console.log(callSum1(3, 4));

var stringValue="ahello world";
//console.log(stringValue.charCodeAt(0));
//console.log(stringValue.localeCompare("ahello world"));
//localCompare, 最好判断小于0 determine
//使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。 fromCharCode().这个方法的任务是接收一或者多个字符编码，然后将他们转换成一个字符串。
//charCodeAt相反的过程。
var strs=String.fromCharCode(97, 98, 99);
//console.log(strs);
//
//Global 和Math
//global 对象可以说是最特别的一个对象了，因为不管你从什么角度，这个对象都是不存在的。Ecmascript 中的Global 对象在某种意义上说是作为一个终极的“兜底儿对象”。
//isNaN(), isFinite parseInt parseFloat
//enableURI 不会对本身属于URI 的特殊字符进行编码，例如冒号，正斜杠, 而encodeURIComponent()则会对它发现的任何非标准字符进行编码。

var uri="http://www.wrox.com/illegal value.html#start";
//console.log(encodeURI(uri));
//console.log(encodeURIComponent(uri));
//对应的是decodeURI 和decodeURIComponent
//eval().只接受一个参数
//eval("console.log('a')");
//console.log(Math.E);
//console.log(Math.PI);
//console.log(Math.LN10);

var afloat=2.12;
//console.log(Math.ceil(afloat));
///console.log(Math.floor(afloat));
//console.log(Math.round(afloat));
//console.log(Math.floor(Math.random()*100));

//理解对象
//创建自定义对象的最简单方式就是创建一个Object实例，然后再为它添加属性和方法，
var person = new Object();
person.name="wuming";
person.age=23;
person.job = "Software Engineer";

person.sayName=function(){
    //console.log("my name is wuming");
    console.log("my name is "+this.name);
};


//person.sayName();


var book = {
    _year:2017,
    edition:1
};



Object.defineProperty(book, "year", {
    get:function(){
        return this._year;
    }, 
    set:function(newValue){
        if(newValue> 2017){
            this._year = newValue;
            this.edition += newValue - 2017;
        } 
    }
});


book.year = 2019;
//console.log(book);


//工厂模式，这种模式抽象了创建具体对象的过程。
function createPerson(name, age, job){
    var o= new Object();
    o.name=name;
    o.age= age;
    o.job= job;

    o.sayName=function(){
        console.log("myname is "+ this.name);
    };

    return o;
}

var p1=createPerson("wuming", 30, "shiye");
var p2=createPerson("mingming", 30, "shiye");
//console.log(p1);
//p1.sayName();
//函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个汉素，而每次它都会返回一个包含三个属性的一个方法
//的对象, 这就是工厂模式，相当于类的概念。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决识别的问题（即怎样知道一个对象的类别）。随着JavaScript
//的发展，又一个新模式出现了。
//构造函数模式
//

function Person2(name, age, job){
    this.name = name; 
    this.age = age;
    this.job = job;

    this.sayName = function(){
        console.log(this.name);
    };
}


var pp1=new Person2("wm", 39, "shiye");
//console.log(pp1.constructor == Person2);
//在这个例子中，person2()函数取代了createPerson函数，不同是没有显示创建对象;直接将属性和方法赋给了this对象。没有return 语句。
//按照惯例，构造函数始终都应该以一个大写字母开头，区别于其他函数。这又是一个语法糖吧。
//1.创建一个新对象;
//2.将构造函数的作用域付给新对象。
//3.执行构造函数中的代码
//4.返回新对象。

//原型模式
//我们创建的每一个函数都有一个prototype属性，这个属性是一个指针。指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
//如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有实例共享他所包含的属性
//和方法。换句话说，不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中，
function Person(){
    
}


Person.prototype.name= "wuming1";
Person.prototype.age = 30;
Person.prototype.job = "shiye";

Person.prototype.sayName= function(){
    console.log(this.name);
};

var per1=new Person();
//per1.sayName();

//递归
function jiechen(num){
    if(num<=1){
        return 1;
    }else{
        return num*jiechen(num-1);
    }
}


//console.log(jiechen(3));

//命名函数
var factorial = (function f(num){
    if(num<=1)
        return 1;
    else{
        return num*f(num-1);
    }

});

//console.log(factorial(4));

//BOM 的核心是window, 表示浏览器的一个实例。在浏览器中，window 对象有双重角色，他既是通过javascript 访问浏览器窗口的一个接口，又是ecmascript 规定的global对象。
//这意味着在网页中定义的任何一个对象、变量和函数，都以window 作为根对象。
//console.log(window);

//如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames 集合中，可以通过数值索引（从0开始，从左至右，从上到下）
//或者框架名称来访问相应的window对象。每个window 对象都有一个name属性
//<html>,</html> 
//以上代码创建了一个框架集，其中一个框架居上，两个框架居下。可以通过window.frames[0] 来引用上方的框架.最好通过top.frames[0]引用
//以上好像失效了。

//window.open()方法可以导航窗口。
//如果是浏览器扩展或其他程序阻止弹出窗口，那么window.open()通常会抛出一个错误。
var blocked=false;
try{
    var winstate= window.open("www.baidu.com", "_blank");
    if(winstate === null){
        blocked=true;
    }
}
catch(ex){
    blocked=true;
}
if(blocked){
//    console.log("the popup was blocked");
}

//间歇调用和超时调用 setTimeout , setInterval

// setInterval(function(){
//     console.log("a");
// }, 1000);
//取消间歇调用 clearInterval(intervalId);


//客户端检测
//私有标准导致的。补救措施
//能力检测，识别浏览器的能力，
// if(object.nengli){
//     ....
// return 
// }

function getElement(id){
    if(document.getElementById){
        return document.getElementById(id);
    }else if(document.all){
        return docuemnt.all[id];
    }else{
        throw new Error("No way to retrieve elements");
    }

}


//DOM(文档对象模型)是针对HTML 和XML文档的一个API。
//Document
//Element html
// Element  head  ->Element title ->Text  title中包含的页面标题字符串
// Element body
// someNode.nodeType == Node.Element_node , 或者1是元素Node

//事件
//javascript 与 html之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定
//的交互瞬间。可以使用侦听器来预订事件，以便事件发生时执行相应代码。支持页面的行为和页面外观之间的松散耦合。
//一般使用事件冒泡流而不是捕获流（两者正好相反）

//<input type="button" onclick="alert('hh')">

//    <form method="post">
//   <input type="text" name="username" value="">
//  <input type="button" value="Echo Username" onclick="alert(username.value)">
//  </form>
//添加事件的方式
//var btn=document.getElementById("myBtn");
//btn.onclick=function(){};
//btn.addEventListener("click", function(){}, false);

//手机触摸事件
//touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。
//touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。
//touchend：当手指从屏幕上移开时触发。
//touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。


//事件委托，可以封装在一个 switch 　中而不是一个一个添加click  事件, 产用父的子事件
//var list= document.getElementById("myLinks");
//EventUtil.addHandler(list, "click", function(event){
//   event = EventUtil.getTarget(event); 
//});

//移除元素时最好将他绑定的事件处理程序移除　btn.onclick= null;


//json, 与javascript不同的是, 属性必须加双引号，json的字符串必须是双引号。其次，没有末尾分号。因为不是语句　
//与xml相比，解析数据特别简单，你想想html解析数据方式。
//books[2].title
//doc.getElementsByTagName("book")[2].getAttribute("title")
// 看看两者的比较
//json对象有两个方法
//stringify
//parse


var booka = {
    title:"xiaoming", 
    age:32,  
    job:"shiye"
};

var stjson=' {"title":"xiaoming","age":32,"job":"shiye"}';
//var jsonText=JSON.stringify(booka);
var jsonText=JSON.parse(stjson);


//console.log(jsonText);

//stringify 后面加参数起到过滤作用
///var jsonText = JSON.stringify(book, ["title", "edition"]);

//或者

// var jsonText = JSON.stringify(book, function(key, value){
//     switch(key){
//     case "authors":
//         return value.join(",");
// case "year":
//     return 5000;
//     case "edition":
//         return undefined;
//     default:
//         return value;
//     }
// });

//Ajax技术, 核心是XMLHttpRequest

  #+END_SRC
* js-mode
** 代码折叠
[, z e]
| Key Binding | Description              |
|-------------+--------------------------|
| ~SPC m z c~ | hide element             |
| ~SPC m z o~ | show element             |
| ~SPC m z r~ | show all element         |
| ~SPC m z e~ | toggle hide/show element |
| ~SPC m z F~ | toggle hide functions    |
| ~SPC m z C~ | toggle hide comments     |

** 反射
   Spc m r 开头
** 自动完成
auto-completion and documention: tern
*** document
   | Key Binding   | Description                           |
   |---------------+---------------------------------------|
   | ~SPC m r d b~ | insert JSDoc comment for current file |
   | ~SPC m r d f~ | insert JSDoc comment for function     |
   | ~SPC m r d t~ | insert tag to comment                 |
   | ~SPC m r d h~ | show list of available jsdoc tags     |
*** auto-complete and document
    | Key Binding   | Description                                                                              |
    |---------------+------------------------------------------------------------------------------------------|
    | ~SPC m C-g~   | brings you back to last place you were when you pressed M-..                             |
    | ~SPC m g g~   | jump to the definition of the thing under the cursor                                     |
    | ~SPC m g G~   | jump to definition for the given name                                                    |
    | ~SPC m h d~   | find docs of the thing under the cursor. Press again to open the associated URL (if any) |
    | ~SPC m h t~   | find the type of the thing under the cursor                                              |
    | ~SPC m r r V~ | rename variable under the cursor using tern                                              |

** coffeescript support
** 代码美化
   formatting with web-beautify
| ~SPC m =~   | beautify code in js2-mode, json-mode, web-mode, and css-mode |
** Get the path to a JSON value with [[https://github.com/Sterlingg/json-snatcher][json-snatcher]]
** REPL(代码交互） 
   通过 [[https://github.com/skeeto/skewer-mode][skewer-mode]] 和 [[https://github.com/pandeiro/livid-mode][livid-mode (输出　skewer.log)]]
   会打开两个交互，一个是控制台，一个是浏览器，都可以交互
   控制台：　skewer.log
   浏览器：console.log 或 alert
   | Key Binding | Description                                                      |
   |-------------+------------------------------------------------------------------|
   | ~SPC m e e~ | 选区, 求最后表达式evaluates the last expression                            |
   | ~SPC m e E~ | evaluates and inserts the result of the last expression at point |

| Key Binding | Description                                                                        |
|-------------+------------------------------------------------------------------------------------|
| ~SPC m s a~ | Toggle live evaluation of whole buffer in REPL on buffer changes                   |
| ~SPC m s b~ | send current buffer contents to the skewer REPL                                    |
| ~SPC m s B~ | send current buffer contents to the skewer REPL and switch to it in insert state   |
| ~SPC m s f~ | 发送函数给解释器send current function at point to the skewer REPL                  |
| ~SPC m s F~ | send current function at point to the skewer REPL and switch to it in insert state |
| ~SPC m s i~ | starts/switch to the skewer REPL                                                   |
| ~SPC m s r~ | send current region to the skewer REPL                                             |
| ~SPC m s R~ | send current region to the skewer REPL and switch to it in insert state            |
| ~SPC m s s~ | switch to REPL                                                                     |

** tern reference manual
*** The Tern server
    bin/tern(node.js 脚本）
    服务启动后，先查找　.tern-project 文件，在当前目录，没有就找上一级，这样递归(会找到 ~ 目录，最后是/ 目录) 可以在.tern-config 文件中配置, 会打开一个接口，然后跟客户端交互
    #+BEGIN_SRC doc
命令行参数：
--port <number>
Specify a port to listen on, instead of the default behavior of letting the OS pick a random unused port.

--host <host>
Specify a host to listen on. Defaults to 127.0.0.1. Pass null or any to listen on all available hosts.

--persistent
By default, the server will shut itself down after five minutes of inactivity. Pass it a this option to disable auto-shutdown.

--ignore-stdin
By default, the server will close when its standard input stream is closed. Pass this flag to disable that behavior.

--verbose
Will cause the server to spit out information about the requests and responses that it handles, and any errors that are raised. Useful for debugging.

--no-port-file
The server won’t write a .tern-port file. Can be used if the port files are a problem for you. Will prevent other clients from finding the server (and may thus result in multiple servers for the same project).


    #+END_SRC
*** JSON protocol
    发送请求是　用ＰＯＳＴ方式，请求的是一个ｊson 格式的对象文档
    This document should be an object, with three optional fields, query, files, and timeout.
*** Server plugins
    #+BEGIN_SRC json
      A .tern-project file is a JSON file in a format like this:
      libs 是默认插件，第三方插件在　plugins 中，　中间的是专门插件
            {
              "libs": [
                "browser",
                "jquery"
              ],
              "loadEagerly": [
                "importantfile.js"
              ],
              "plugins": {
                "requirejs": {
                  "baseURL": "./",
                  "paths": {}
                }
              }
            }
    #+END_SRC
　　重复调用是因为重复注册了setInterval，比如在某个事件的相应函数中创建setInterval，再次触发该事件的时候又注册了 setInterval。
建议直接在 ppt 方法的前面加上：

clearInterval(set); 即

function ppt(){
    clearInterval(set);
    ......
}
* 库
** MUI
*** 下拉刷新
 为实现下拉刷新功能，大多H5框架都是通过DIV模拟下拉回弹动画，在低端android手机上，DIV动画经常出现卡顿现象（特别是图文列表的情况）；
  mui通过双webview解决这个DIV的拖动流畅度问题；拖动时，拖动的不是div，而是一个完整的webview（子webview），回弹动画使用原生动画；
 在iOS平台，H5的动画已经比较流畅，故依然使用H5方案。两个平台实现虽有差异，但mui经过封装，可使用一套代码实现下拉刷新。

 主页面内容比较简单，只需要创建子页面即可：
 mui.init({
     subpages:[{
       url:pullrefresh-subpage-url,//下拉刷新内容页面地址
       id:pullrefresh-subpage-id,//内容页面标志
       styles:{
         top:subpage-top-position,//内容页面顶部位置,需根据实际页面布局计算，若使用标准mui导航，顶部默认为48px；
         .....//其它参数定义
       }
     }]
   });

 iOS平台的下拉刷新，使用的是mui封装的区域滚动组件， 为保证两个平台的DOM结构一致，内容页面需统一按照如下DOM结构构建：

 <!--下拉刷新容器-->
 <div id="refreshContainer" class="mui-content mui-scroll-wrapper">
   <div class="mui-scroll">
     <!--数据列表-->
     <ul class="mui-table-view mui-table-view-chevron">
      
     </ul>
   </div>
 </div>

 其次，通过mui.init方法中pullRefresh参数配置下拉刷新各项参数，如下：

 mui.init({
   pullRefresh : {
     container:"#refreshContainer",//下拉刷新容器标识，querySelector能定位的css选择器均可，比如：id、.class等
     down : {
       height:50,//可选,默认50.触发下拉刷新拖动距离,
       auto: true,//可选,默认false.自动下拉刷新一次
       contentdown : "下拉可以刷新",//可选，在下拉可刷新状态时，下拉刷新控件上显示的标题内容
       contentover : "释放立即刷新",//可选，在释放可刷新状态时，下拉刷新控件上显示的标题内容
       contentrefresh : "正在刷新...",//可选，正在刷新状态时，下拉刷新控件上显示的标题内容
       callback :pullfresh-function //必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
     }
   }
 });

 下拉刷新是mui框架的一个插件，该插件目前有下拉刷新结束、滚动到特定位置两个方法；
 下拉刷新结束

 在下拉刷新过程中，当获取新数据后，需要执行endPulldownToRefresh方法， 该方法的作用是关闭“正在刷新”的雪花进度提示，内容区域回滚顶部位置，如下：。

 function pullfresh-function() {
      //业务逻辑代码，比如通过ajax从服务器获取新数据；
      ......
      //注意，加载完新数据后，必须执行如下代码，注意：若为ajax请求，则需将如下代码放置在处理完ajax响应数据之后
      mui('#refreshContainer').pullRefresh().endPulldownToRefresh();
 }

 滚动到特定位置

 下拉刷新组件滚动到特定位置的方法类似区域滚动组件

     scrollTo( xpos , ypos [, duration] )
         xpos
         Type: Integer
         要在窗口文档显示区左上角显示的文档的 x 坐标
         ypos
         Type: Integer
         要在窗口文档显示区左上角显示的文档的 y 坐标
         duration
         Type: Integer
         滚动时间周期，单位是毫秒

 示例：在hello mui下拉刷新示例中，实现了双击标题栏，让列表快速回滚到顶部的功能；代码如下：

 var contentWebview = null;
 //监听标题栏的双击事件
 document.querySelector('header').addEventListener('doubletap',function () {
	 if(contentWebview==null){
		 contentWebview = plus.webview.currentWebview().children()[0];
	 }
	 //内容区滚动到顶部
	 contentWebview.evalJS("mui('#pullrefresh').pullRefresh().scrollTo(0,0,100)");
 });

 更改下拉刷新文字位置

 *可以解决修改下拉刷新子页面默认top值后,下拉刷新提示框位置异常问题

 根据实际需求在父页面给mui-content设置top属性

 .mui-bar-nav ~ .mui-content .mui-pull-top-pocket{
   top: 180px !important;
 }

 扩展阅读

 问答社区话题讨论： 下拉刷新
 代码块激活字符:    mpull(DOM结构)
 minitpull(初始化组件)
 mmpull(组件方法)

 mui遵循 MIT License

     最新版本 v3.5.0 · 问答社区 · Issues · Releases · 

*** 上拉加载
 mui的上拉加载和下拉刷新类似，都属于pullRefresh插件，使用过程如下：
     1、页面滚动到底，显示“正在加载...”提示（mui框架提供）
     2、执行加载业务数据逻辑（开发者提供）
     3、加载完毕，隐藏"正在加载"提示（mui框架提供）
 开发者只需关心业务逻辑，实现加载更多数据即可。

 初始化
 初始化方法类似下拉刷新，通过mui.init方法中pullRefresh参数配置上拉加载各项参数，如下：

 mui.init({
   pullRefresh : {
     container:refreshContainer,//待刷新区域标识，querySelector能定位的css选择器均可，比如：id、.class等
     up : {
       height:50,//可选.默认50.触发上拉加载拖动距离
       auto:true,//可选,默认false.自动上拉加载一次
       contentrefresh : "正在加载...",//可选，正在加载状态时，上拉加载控件上显示的标题内容
       contentnomore:'没有更多数据了',//可选，请求完毕若没有更多数据时显示的提醒内容；
       callback :pullfresh-function //必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
     }
   }
 });

 结束上拉加载

 加载完新数据后，需要执行endPullupToRefresh()方法，结束转雪花进度条的“正在加载...”过程

     .endPullupToRefresh( nomore )
         nomore
         Type: Boolean
         是否还有更多数据；若还有更多数据，则传入false; 否则传入true，之后滚动条滚动到底时，将不再显示“上拉显示更多”的提示语，而显示“没有更多数据了”的提示语；

 示例：

 function pullfresh-function() {
      //业务逻辑代码，比如通过ajax从服务器获取新数据；
      ......
      //注意：
      //1、加载完新数据后，必须执行如下代码，true表示没有更多数据了：
      //2、若为ajax请求，则需将如下代码放置在处理完ajax响应数据之后
      this.endPullupToRefresh(true|false);
 }

 重置上拉加载

 若部分业务中，有重新触发上拉加载的需求（比如当前类别已无更多数据，但切换到另外一个类别后，应支持继续上拉加载），此时调用.refresh(true)方法，可重置上拉加载控件，如下代码：

 //pullup-container为在mui.init方法中配置的pullRefresh节点中的container参数；
 //注意：refresh()中需传入true
 mui('#pullup-container').pullRefresh().refresh(true);

 禁用上拉刷新

 在部分场景下希望禁用上拉加载，比如在列表数据过少时，不想显示“上拉显示更多”、“没有更多数据”的提示语，开发者可以通过调用disablePullupToRefresh()方法实现类似需求，代码如下：

 //pullup-container为在mui.init方法中配置的pullRefresh节点中的container参数；
 mui('#pullup-container').pullRefresh().disablePullupToRefresh();

 启用上拉刷新

 使用disablePullupToRefresh()方法禁用上拉加载后，可通过enablePullupToRefresh()方法再次启用上拉加载，代码如下：

 //pullup-container为在mui.init方法中配置的pullRefresh节点中的container参数；
 mui('#pullup-container').pullRefresh().enablePullupToRefresh();

 扩展阅读

     1、上拉加载时，怎么隐藏底部的“没有更多数据了”?
     2、问答社区话题讨论：上拉加载

 mui遵循 MIT License

     最新版本 v3.5.0 · 问答社区 · Issues · Releases · 
** bootstrap css
*** 移动设备优先
    适应设备<meta name="viewport" content="width=device-width,initial-scale=1.0">
    禁用缩放 user-scalable=no  maximum-scale=1.0
** bootstrap
   bootstrap 建立了一个响应式的12列格网布局系统，它引入了fixed(固定) and fluid-with(浮动)的两种布局方式. 
   我们从全局样式(global style),格网系统（grid system），流式格网（fluid grid system）,自定义（customing）,
   布局（layouts）,响应式设计（responsive design ）这 六个方面讲解 scaffolding
   \* global style
   bootstrip 要求 html5 的文件类型，so <!DOCTYPE html>
   同时，它通过bootstrap.less 文件来设置 全局排版和链接显示风格，其中去掉了 body的margin,使用
   @baseFontFamily,@baseFontSize,@linkColor 等变量来控制基本排版
   \* 栅格系统（grid system）
   默认的bootstrap格网系统提供了一个宽达940像素的12列的格网。这意味着你页面的默认宽度是940px
   最小的单元要素宽度是940/12px.
   bootstrap 内置了一套响应式、移动设备优先的流式栅格系统。随着屏幕设备或视口（viewport）尺寸的增加，系统会自动分为最多12列
   就是通过一系列的行（row）与列（column）的组合创建页面布局，然后你的内容就可以放入到你创建好的布局当中。
   行（row）必须包含在.container中，以便为其赋予合适的排列(alignment)和内补(padding).
   使用行（row）在水平方向创建一组列(column).
   你的内容应当放置于列（column）内，而且,只有列（column)可以作为行（row）的直接子元素。
   类似Predefined grid classes like .row and .col-xs-4 这些预订义的栅格class可以用来快速创建 栅格布局。
   bootstrap 源码中定义的mixin也可以用来创建语义化的布局。
   通过设置padding 从而创建列(column)之间的间隔（gutter)。然后通过为第一和最后一列设置负值的margin从而抵消掉padding的影响。
   栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个.col-xs-4来创建。
   sm md lg xl 和默认
   offset push pull 设定偏移
*** 栅格选项
 |           | 手机（<768px) | 平板(>768px) | 桌面（>992px) |          |
 | class前缀 | .col-xs-      | .col-sm-     | .col-md-      | .col-lg- |
 | 列数      | 12            |              |               |          |
 \* 流式系统 (fluid grid system)
 \* 自定义(customing)
 \* 布局(layouts)
 \* 响应式设计(responsive design)
 abc璇
 abc璇
 abc璇

 璇
 璇
 璇
 璇
 jjjk璇
 璇
 璇
 璇
 璇
 abc璇
 abc璇
 abc璇
 abc璇
 璇
** echarts
   ECharts，缩写来自Enterprise Charts，商业级数据图表，一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），
   底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。
   支持折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表，同时提供标题，详情气泡、图例、值域、数据区域、时间轴、工具箱等7个可交互组件，支持多图表、组件的联动和混搭展现。
** highcharts
*** Highcharts 基本组成 
