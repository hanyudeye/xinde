 #+TITLE: JavaScript 使用简介
#+DATE: <2019-06-02 05:07:53>
#+TAGS: JavaScript 
#+CATEGORIES: 语言使用
#+DESCRIPTION: 写点关于 JavaScript 这门语言的使用方法

  在整理
* Javascript 
** 简介  
  通常是给浏览器用的 ~客户端脚本~ ，配合 CSS 用来渲染 文档树(DOM) ,现在也出了 此语言写的 ~服务端脚本~ 

  #+begin_verse
  一般称 ~前端语言~ ，[客户端] ，[浏览器端] ，怎么称呼无所谓啦!
  ~前端语言~ ，包括 ~HTML~, ~CSS~ ，他们，但现在有了很多封装的框架，顺便 ~框架语言~ 也要一并学的哦
  
  语言特点 ：开发时间短 , 功能又多 , so 有些功能的语法有点怪异 。
                      不提供任何与 I/O（输入/输出）相关的 API 。
  #+end_verse
 
  
 
 #+HTML: <!-- more -->

 #+begin_quote
 从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。阅读本书的过程中，你会诧异于 JavaScript 语法的灵活性。

 JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如`Array`、`Date`、`Math`等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。

- 浏览器控制类：操作浏览器
- DOM 类：操作网页的各种元素
- Web 类：实现互联网的各种功能

如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API 等等。这些你都可以在 Node 环境中找到。
 #+end_quote



 #+begin_quote
 老道认为 JavaScript 优美的特性如下:
 1. 函数是头等对象(可以作为其他函数的参数和返回值 ，支持闭包)
 2. 基于原型继承的动态对象
 3. 对象字面量和数组字面量(构成 JSON 的基础)

  对于鸡肋和糟粕, 使用 ~JSLint~ 测试  
 1. hasOwnProperty ，老道说它糟粕的原因是因为这不是一个关键字 ，而是一个 Object。
    prototype 上可以被重写的方法。那么这个告诉我们 ，并不是不要用 hasOwnProperty
    ，而是要注意不要覆盖它。

 2. eval 的主要问题是性能 ，大量的 eval(类 eval)语句降低了 JS 引擎的性能。少量可用
 #+end_quote

: Javascript 语言的发展: 现在使用越来越广啦
: 包括 Node ，数据库操作 [NoSQL] ,移动平台开发,内嵌脚本语言 [GNOME ,Acrobat]，跨平台的桌面应用程序 [这都 独立程序了 ]
: 现代浏览器都编译执行了
** 配套工具 
*** 解析器 
    安装浏览器,用控制台 
    - 打开控制台: 按键 @@html:<kbd>@@ Ctrl  + Shift + J @@html:</kbd>@@ 
    - 换行继续打命令    @@html:<kbd>@@ Shift +  Enter @@html:</kbd>@@ 
    - 执行命令  @@html:<kbd>@@  Enter @@html:</kbd>@@
    
    或者
    - 安装 node.js 解析器
    
*** 测试工具 
** 语言用法 [ 计算机功能的一套文字 ] 
*** 简介  
    #+begin_verse
   文字化最好的方法就是自然语言啦，中国用汉语，外国用外语 
   不过汉语编程语言用的不多，一般用来写文档、注释或伪代码
    #+end_verse
   
    语句: 就是表达一句意思 ，自然语言用  ~。~ 隔开，程序语言用 ~;~ 隔开.有的语句是一块的，代表多个用处，放一块了。
    一般先要定义一个东西，然后再使用它。
    #+begin_src js -n
      //定义 a 是一个数字
      var a = 1 + 3;

      // 定义 show 是一个操作 
      function show(arr){
          console.log(arr);
      }

      //使用 show 操作  a . 计算机，你去 用 show  操作  a
      show(a);
    #+end_src
   
    复制到 浏览器的 ~Console~  ， 按回车，就可以执行了
    
*** 被操作对象 [ Javascript 解释器能直接理解的对象 ]
    其实有很多 ，简单写一些
    
    数字 [ 整数，小数 ]  用法: 直接写
    #+begin_src js -n
      //整数,默认 10 进制 
      123, 7893 ,3

      //科学技术法
      1e3  //返回 1 乘以 10 的

      //八进制表示 第一位必须是 0
      012  //返回 10

      //十六进制 
      0xA   //返回 10

      //负数，负数只能 10 进制哦
          -10,-21

      //小数
      1.2,3.323
    #+end_src
    
    
    文字，用法: 用引号引起来。不加会面临文字中空格如何表示问题。
    看不见的字前面加转义符号 ~\~
    : Javascript 认可的是两个字节的 Unicode，对于四字节字符的无法识别，会认为是两个字节。
    

    
    #+begin_src js -n 
      "我是一段话" 

      'and me'

      '这是一行包含特殊字符的一段话 \n'
    #+end_src
    
    Object [ 对象对象,包含数据和功能 ]  用法  
    #+begin_src js -n 
      var woshiduixiang = {
          name:"阿明",
          lastName:"Huang" ,

          //方法
          whatsName:function(){
              alert(this.name+" "+this.lastName);   
          },
      }
    #+end_src
     
    对象有两种读取成员的方法：点结构（`object.key`）和方括号结构（`object[key]`）。
    但是，对于数值的键名，不能使用点结构。 ~arr.0~  的写法不合法


**** 基本对象 
     Function [ 函数对象 ] 
     Boolean [ 布尔型对象 ] [ true, false]
     Symbol [ 字符串 ]
     Error
     EvalError
     InternalError
     RangeError
     ReferenceError
     SyntaxError
     TypeError
     URIError
     Infinity
     NaN
     undefined 
     null 
     literal  [ 字面量 ]
     globalThis
 
**** Numbers and dates
     Number
     Math
     Date

****  Text processing
     These objects represent strings and support manipulating them.

     String
     RegExp

****  Indexed collections
     These objects represent collections of data which are ordered by an index
     value. This includes (typed) arrays and array-like constructs.

     Array
     Int8Array
     Uint8Array
     Uint8ClampedArray
     Int16Array
     Uint16Array
     Int32Array
     Uint32Array
     Float32Array
     Float64Array

****  Keyed collections
     These objects represent collections which use keys; these contain elements
     which are iterable in the order of insertion.

     Map
     Set
     WeakMap
     WeakSet

****  Structured data
     These objects represent and interact with structured data buffers and data
     coded using JavaScript Object Notation (JSON).

     ArrayBuffer
     SharedArrayBuffer 
     Atomics 
     DataView
     JSON

*** 功能 [ 被操作对象的功能,功能与对象要配才行哦 ? 你不会拿着自行车去种地吧 ]
**** 基本操作 
***** 数字操作
      整数小数 ，更复杂的功能用 ~Math~  库
     
      #+begin_src js -n
        //加减运算
        1+3;
        3-7;
        33*3;
        3.5/2;

        //数字是否相等，小数因为存储问题最好不要直接这样判断
        3==3.0  //true
        3===3.0   //true
        0.1 + 0.2 === 0.3  //false

      #+end_src
      
      将字符串转换整数 parseInt
      #+begin_src js -n
        parseInt('12.34') // 12
        parseInt('15e2') // 15
        parseInt('abc') // NaN
        parseInt('.3') // NaN
        parseInt('0x10') // 16
        parseInt('011') // 11
        parseInt('1000', 2) // 8
        parseInt('1000', 6) // 216

      #+end_src
      
      parseFloat     
      #+begin_src js -n
        parseFloat('314e-2') // 3.14
        parseFloat('0.0314E+2') // 3.14
        parseFloat('3.14more non-digit characters') // 3.14
        parseFloat('FF2') // NaN

      #+end_src

      isNaN()
      #+begin_src js -n
        isNaN(NaN) // true
        isNaN(123) // false
      #+end_src

      isFinite(),表示某个值是否为正常的数值

      #+begin_src js -n
        isFinite(Infinity) // false
        isFinite(-Infinity) // false
      #+end_src

***** 字符串操作
      获取长度  "hello".length
      
      Base64 转码
      一种编码方法，可以将任意值转成 0～9、A～Z、a-z、`+`和`/`这 64 个字符组成的可打印字符
    
    #+begin_src js -n
      var string = 'Hello World!';
      btoa(string) // "SGVsbG8gV29ybGQh"
      atob('SGVsbG8gV29ybGQh') // "Hello World!"
    #+end_src
    : 注意，这两个方法不适合非 ASCII 码的字符，会报错。

    索引位置
    #+BEGIN_SRC js
      var s="helo world";
      var i=s.search(/wo/i);
      i: 不区分大小写
    #+END_SRC

***** 数组 [ 特殊对象]
      任何类型的数据，都可以放入数组。
      也有 length 属性

      #+begin_src js -n
        var arr = [
            {a: 1},
            [1, 2, 3],
            function() {return true;}
        ];

        arr[0] // Object {a: 1}
        arr[1] // [1, 2, 3]
        arr[2] // function (){return true;}
      #+end_src

      in 运算符,检查键名是否存在
      #+begin_src js -n
        var arr = [ 'a', 'b', 'c' ];
        2 in arr  // true
        '2' in arr // true
        4 in arr // false
      #+end_src
      
      for...in 循环和数组的遍历
      `for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。

      #+begin_src js
        var a = [1, 2, 3];
        a.foo = true;

        for (var key in a) {
            console.log(key);
        }
        // 0
        // 1
        // 2
        // foo
      #+end_src

      forEach ,内部行为好像
      #+begin_src js -n
        var colors = ['red', 'green', 'blue'];
        colors.forEach(function (color) {
            console.log(color);
        });
        // red
        // green
        // blue
      #+end_src
      
      delete ,会产生空位
      : 但是 length 属性不变，要注意
      
      #+begin_src js -n
        var a = [1, 2, 3];
        delete a[1];

        a[1] // undefined
        a.length // 3
      #+end_src

      push 方法
     对象转数组  
     #+begin_src js -n
       var arr = Array.prototype.slice.call(arrayLike);
       //或

       function print(value, index) {
           console.log(index + ' : ' + value);
       }

       Array.prototype.forEach.call(arrayLike, print);

     #+end_src

***** 函数 [ 具有执行功能的变量 ] [ 其他变量存值,它存方法 ]
****** 声明方式 
       1. function 命令
       #+begin_src js -n
         function print(s) {
             console.log(s);
         }
       #+end_src

       2. 函数表达式
       #+begin_src js -n
         var print = function(s) {
             console.log(s);
         };
       #+end_src
       3. Function 构造函数
       #+begin_src js -n
         var add = new Function(
             'x',
             'y',
             'return x + y'
         );

         // 等同于
         function add(x, y) {
             return x + y;
         }
       #+end_src
****** 属性 
       看它的结构 ,包含者属性
       
       函数名属性 name
       
       函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
       
       函数的`toString`方法返回一个字符串，内容是函数的源码。

****** 递归 [ 每次只做一部分，循环调用自身的过程 (记得把余下的部分作参数哦)]

       #+begin_src js -n
         function fib(num) {
             if (num === 0) return 0;
             if (num === 1) return 1;
             return fib(num - 2) + fib(num - 1);
         }

         fib(6) // 8
       #+end_src
       
****** 闭包
       定义在一个函数内部的函数，就是能获取函数内部属性
       #+begin_src js -n
         function createIncrementor(start) {
             return function () {
                 return start++;
             };
         }

         var inc = createIncrementor(5);

         inc() // 5
         inc() // 6
         inc() // 7
       #+end_src
       
***** Object 
      读取对象的属性
      #+begin_src js -n
        var obj = {
            p: 'Hello World'
        };

        obj.p // "Hello World"
        obj['p'] // "Hello World"
      #+end_src

      #+begin_verse
      静态方法
      返回对象的属性: keys 
      #+end_verse
      
      #+begin_verse
      实例方法
      属性的删除：delete 命令 ,继承的属性不能删 ,比如 toString
      该对象求值: valueOf 
      #+end_verse
      
**** 流程控制 [ 条件语句 ，满足条件才做事情  ]
***** if - else  结构  
      #+begin_src js -n
        if (m === 3) {
            // 满足条件时，执行的语句
        } else {
            // 不满足条件时，执行的语句
        }
      #+end_src
***** switch 结构   
      #+begin_src js -n
        switch (fruit) {
        case "banana":
            // ...
            break;
        case "apple":
            // ...
            break;
        default:
            // ...
        }
      #+end_src

      
      if...else
      Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.
      switch
      Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.
      throw
      Throws a user-defined exception.
      try...catch
      Marks a block of statements to try, and specifies a response, should an exception be thrown.
***** while 循环
      #+begin_src js -n
        while (条件)
        语句;

        // 或者
        while (条件) 语句;
      #+end_src
***** for 循环 
      #+begin_src js -n
        for (初始化表达式; 条件; 递增表达式)
        语句

        // 或者

        for (初始化表达式; 条件; 递增表达式) {
            语句
        }
      #+end_src
**** 声明语句
***** var Declares a variable, optionally initializing it to a value.
***** let Declares a block scope local variable, optionally initializing it to a value.
***** const Declares a read-only named constant.
**** 其他
***** export
      Used to export functions to make them available for imports in external
      modules, and other scripts.
***** import
      Used to import functions exported from an external module, another script.
 
*** 错误处理
**** Try...Catch 
     #+BEGIN_SRC js
       var txt=""
       function message()
       {
           try
           {
               adddlert("Welcome guest!")
           }
           catch(err)
           {
               txt="此页面存在一个错误。\n\n"
               txt+="错误描述: " + err.description + "\n\n"
               txt+="点击 OK 继续。\n\n"
               alert(txt)
           }
       }
     #+END_SRC
*** 类 [ 现在面向对象了，可以用面向对象的一套概念了 ]
**** ES5 模拟类  
     #+begin_src javascript
       function PersonES5(p) {
           this.age = p.age;
           this.name = p.name;
           this.sex = p.sex;
       }

       PersonES5.prototype.showInfo = function() {
           console.log(this);
       };

       var person = new PersonES5({
           age:18,
           name:'tom',
           sex:'boy'
       });

       person.showInfo();
     #+end_src
**** ES6
     #+begin_src js
       class PersonES6 {
           constructor(p) {
               this.age = p.age;
               this.name = p.name;
               this.sex = p.sex;
           }
           showInfo() {
               console.log(this);
           }
       }


       var person = new PersonES6({
           age:18,
           name:'tom',
           sex:'boy'
       });

       person.showInfo();
     #+end_src
* 标准库
** Date 
   #+BEGIN_SRC js
     日期 Date() getTime() setFullYear() toUTString getDay()
     new Date() // 当前日期和时间
     new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数
     new Date(dateString)
     new Date(year, month, day, hours, minutes, seconds, milliseconds)

     milliseconds 毫秒（0-999）1 秒=1000 毫秒
     var today = new Date()
     var d1 = new Date("October 13, 1975 11:13:00")
     var d2 = new Date(79,5,24)
     var d3 = new Date(79,5,24,11,33,0)
     设置日期
     var myDate=new Date();
     myDate.setFullYear(2010,0,14);

     设置日期为 5 天后
     var myDate=new Date();
     myDate.setDate(myDate.getDate()+5);
     getTime 获取毫秒时间
   #+END_SRC
** Number
   MAX_VALUE 
   MIN_VALUE
** Math
   #+begin_verse
   abs 绝对值
   E 自然对数
   LN2 2 的自然对数
   PI 圆周率
   Math.SQRT2 2 的平方根
   sqrt 平方根
   pow(x, y) x 的 y 次方
   max 取最大值
   min 取最小值
   ceil 上
   floor 下
   round 四舍五入
   #+end_verse
** JSON
  - 对象转字符串  JSON.stringify(arr);
  - 字符串转对象  JSON.parse(strify);
** Array [ 原生对象 ] 
*** 数组创建 [ 推介用字面量]
    #+begin_src js -n
    var arr1 = new Array(); //创建一个空数组
    var arr2 = new Array(20); // 创建一个包含 20 项的数组
    var arr3 = new Array("lily","lucy","Tom"); // 创建一个包含 3 个字符串的数组
    #+end_src
    创建数组的第二种基本方式是使用数组字面量表示法：

    #+begin_src js -n
    var arr4 = []; //创建一个空数组
    var arr5 = [20]; // 创建一个包含 1 项的数组
    var arr6 = ["lily","lucy","Tom"]; // 创建一个包含 3 个字符串的数组
    #+end_src
    在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：

    #+begin_src js
    arr.length = arr.length-1; //将数组的最后一项删除
    #+end_src

*** 数组方法
**** Array.isArray()  [ 静态方法 ] 
     判断是否数组 
**** Array.prototype [ 静态方法 ]
    调用函数 call 
    
     #+begin_src js
     Array.prototype.join.call(['hello','world'],'----');
     #+end_src
     
     含义等于

     #+begin_src js
     ['hello','world'].join('---')
     #+end_src
     
**** join(separator) [ 实例方法 ]
     : 将数组的元素组起一个字符串，以 separator 为分隔符，省略的话则用默认用逗号为分隔符
     #+begin_src js -n
       var arr = [1,2,3];
       console.log(arr.join()); // 1,2,3
       console.log(arr.join("-")); // 1-2-3
       console.log(arr); // [1, 2, 3]（原数组不变）
     #+end_src
     
     通过 join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重
     复后的字符串，函数如下：

     #+begin_src js -n
       function repeatString(str, n) {
           return new Array(n + 1).join(str);
       }
       console.log(repeatString("abc", 3)); // abcabcabc
       console.log(repeatString("Hi", 5)); // HiHiHiHiHi
       #+end_src
     : 其实就是创建一个多一位的空数组，然后用 分隔符子串填充     
**** push()和 pop()
     #+begin_verse
     push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 
     pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。
     #+end_verse

     #+begin_src js -n
       var arr = ["Lily","lucy","Tom"];
       var count = arr.push("Jack","Sean");
       console.log(count); // 5
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]
       var item = arr.pop();
       console.log(item); // Sean
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack"]
     #+end_src
**** shift() 和 unshift()
#+begin_src js -n
     shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回 undefined。 
     unshift:将参数添加到原数组开头，并返回数组的长度 。
#+end_src

     这组方法和上面的 push()和 pop()方法正好对应，一个是操作数组的开头，一个是操
     作数组的结尾。

     #+begin_src js -n
     var arr = ["Lily","lucy","Tom"];
     var count = arr.unshift("Jack","Sean");
     console.log(count); // 5
     console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]
     var item = arr.shift();
     console.log(item); // Jack
     console.log(arr); // ["Sean", "Lily", "lucy", "Tom"]
     #+end_src
**** sort()
     #+begin_src js -n
     sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。
     在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，因此会出现以下的这种情况：
     #+end_src

     #+begin_src js -n
       var arr1 = ["a", "d", "c", "b"];
       console.log(arr1.sort()); // ["a", "b", "c", "d"]
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort()); // [13, 24, 3, 51]
       console.log(arr2); // [13, 24, 3, 51](元数组被改变)
     #+end_src
     为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个
     值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前
     则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后
     则返回一个正数。以下就是一个简单的比较函数：

     #+begin_src js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return -1;
           } else if (value1 > value2) {
               return 1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [3, 13, 24, 51]
     #+end_src
     如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：
     #+begin_src  js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return 1;
           } else if (value1 > value2) {
               return -1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [51, 24, 13, 3]
     #+end_src
**** reverse()
     reverse()：反转数组项的顺序。

     #+begin_src js -n
     var arr = [13, 24, 51, 3];
     console.log(arr.reverse()); //[3, 51, 24, 13]
     console.log(arr); //[3, 51, 24, 13](原数组改变)
     #+end_src
**** concat()
     concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

     #+begin_src js -n
     var arr = [1,3,5,7];
     var arrCopy = arr.concat(9,[11,13]);
     console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
     console.log(arr); // [1, 3, 5, 7](原数组未被修改)
     #+end_src
     从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？

     #+begin_src js -n
     var arrCopy2 = arr.concat([9,[11,13]]);
     console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
     console.log(arrCopy2[5]); //[11, 13]
     #+end_src
     上述代码中，arrCopy2 数组的第五项是一个包含两项的数组，也就是说 concat 方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到 arrCopy2 中。
**** slice()
     slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
#+begin_src js -n
     var arr = [1,3,5,7,9,11];
     var arrCopy = arr.slice(1);
     var arrCopy2 = arr.slice(1,4);
     var arrCopy3 = arr.slice(1,-2);
     var arrCopy4 = arr.slice(-4,-1);
     console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
     console.log(arrCopy); //[3, 5, 7, 9, 11]
     console.log(arrCopy2); //[3, 5, 7]
     console.log(arrCopy3); //[3, 5, 7]
     console.log(arrCopy4); //[5, 7, 9]
#+end_src
     arrCopy 只设置了一个参数，也就是起始下标为 1，所以返回的数组为下标 1（包括下标 1）开始到数组最后。 
     arrCopy2 设置了两个参数，返回起始下标（包括 1）开始到终止下标（不包括 4）的子数组。 
     arrCopy3 设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从 1 开始到 4（不包括）的子数组。 
     arrCopy4 中两个参数都是负数，所以都加上数组长度 6 转换成正数，因此相当于 slice(2,5)。
**** splice()
     splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。

     删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
     插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入 4 和 6。
     替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。
     splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。
     #+begin_src js -n
       var arr = [1,3,5,7,9,11];
       var arrRemoved = arr.splice(0,2);
       console.log(arr); //[5, 7, 9, 11]
       console.log(arrRemoved); //[1, 3]
       var arrRemoved2 = arr.splice(2,0,4,6);
       console.log(arr); // [5, 7, 4, 6, 9, 11]
       console.log(arrRemoved2); // []
       var arrRemoved3 = arr.splice(1,1,2,4);
       console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
       console.log(arrRemoved3); //[7]
#+end_src
**** indexOf()和 lastIndexOf()
#+begin_verse
     indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 
     lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。
#+end_verse

     这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

     #+begin_src js -n
     var arr = [1,3,5,7,7,5,3,1];
     console.log(arr.indexOf(5)); //2
     console.log(arr.lastIndexOf(5)); //5
     console.log(arr.indexOf(5,2)); //2
     console.log(arr.lastIndexOf(5,4)); //2
     console.log(arr.indexOf("5")); //-1
     #+end_src
**** forEach()
     forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是 function 类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。

     #+begin_src js -n 
     var arr = [1, 2, 3, 4, 5];
     arr.forEach(function(x, index, a){
     console.log(x + '|' + index + '|' + (a === arr));
     });
     // 输出为：
     // 1|0|true
     // 2|1|true
     // 3|2|true
     // 4|3|true
     // 5|4|true
     #+end_src
**** map()
#+begin_verse
     map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
#+end_verse

     下面代码利用 map 方法实现数组中每个数求平方。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.map(function(item){
     return item*item;
     });
     console.log(arr2); //[1, 4, 9, 16, 25]
#+end_src
**** filter()

     filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
#+begin_src js -n
     var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     var arr2 = arr.filter(function(x, index) {
     return index % 3 === 0 || x >= 8;
     }); 
     console.log(arr2); //[1, 4, 7, 8, 9, 10]
#+end_src
**** every()
     every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.every(function(x) {
     return x < 10;
     }); 
     console.log(arr2); //true
     var arr3 = arr.every(function(x) {
     return x < 3;
     }); 
     console.log(arr3); // false
#+end_src
**** some()

     some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.some(function(x) {
     return x < 3;
     }); 
     console.log(arr2); //true
     var arr3 = arr.some(function(x) {
     return x < 1;
     }); 
     console.log(arr3); // false
#+end_src
**** reduce()和 reduceRight()
#+begin_verse
     这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
     这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
     传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
#+end_verse

     下面代码用 reduce()实现数组求和，数组一开始加了一个初始值 10。
#+begin_src js -n
     var values = [1,2,3,4,5];
     var sum = values.reduceRight(function(prev, cur, index, array){
     return prev + cur;
     },10);
     console.log(sum); //25
#+end_src
** 时钟对象
   执行一次 setTimeout
   
   重复执行 setInterval
   #+BEGIN_SRC js -n
     var str = "这个是测试用的范例文字";
     var seq = 0;
     var second=1000; //间隔时间 1 秒钟

     function scroll() {
         msg = str.substring(0, seq+1);
         document.getElementByIdx_x_x('word').innerHTML = msg;
         seq++;
         if (seq >= str.length) seq = 0;
     }

     setInterval('scroll()',second)

     var myVar=setInterval(function(){myTimer()},1000);
     function myTimer(){
         var d=new Date();
         var t=d.toLocaleTimeString();
         // document.getElementById("demo").innerHTML=t;
         console.log(t);
     }

     function myStopFunction(){
         clearInterval(myVar);
     }

   #+END_SRC
* DOM 
*** window 
**** 状态处理
    | 窗口是否已被关闭               | closed      |
    | 文档显示区高度                 | innerHeight |
    | 文档显示区宽度                 | innerwidth  |
    | 设置或返回框架数量             | length      |
    | 设置或返回窗口的名称           | name        |
    | 返回窗口的外部高度           | outerheight |
    | 返回窗口的外部宽度           | outerwidth  |
    | 返回父窗口                   | parent      |
    | 返回对当前窗口的引用           | self        |
    | 设置窗口状态栏的文本           | status      |
    | 返回最顶层的先辈窗口           | top         |
    | 窗口的左上角在屏幕上的的 y 坐标 | screenY     |
**** 对象操作
   | 显示带有一段消息和一个确认按钮的警告框           | alert             |
   | 把键盘焦点从顶层窗口移开                         | blur              |
   | 取消由 setInterval() 设置的 timeout              | clearInterval     |
   | 取消由 setTimeout() 方法设置的 timeout           | clearTimeout      |
   | 关闭浏览器窗口                                   | close             |
   | 显示带有一段消息以及确认按钮和取消按钮的对话框   | confirm           |
   | 创建一个 pop-up 窗口                             | createPopup       |
   | 把键盘焦点给予一个窗口                           | focus             |
   | 可相对窗口的当前坐标把它移动指定的像素           | moveBy            |
   | 把窗口的左上角移动到一个指定的坐标               | moveTo            |
   | 打开一个新的浏览器窗口或查找一个已命名的窗口     | open(link,'blank) |
   | 访问打开的原窗口                                 | opener            |
   | 打印当前窗口的内容(打印机）                      | print             |
   | 显示可提示用户输入的对话框                       | prompt            |
   | 按照指定的像素调整窗口的大小                     | resizeBy          |
   | 把窗口的大小调整到指定的宽度和高度               | resizeTo          |
   | 按照指定的像素值来滚动内容                       | scrollBy          |
   | 把内容滚动到指定的坐标                           | scrollTo          |
   | 按照指定的周期（以毫秒计）来调用函数或计算表达式 | setInterval       |
   | 在指定的毫秒数后调用函数或计算表达式             | setTimeout        |
*** navigator
**** 属性
     | 代码名                | appCodeName     |
     | 次级版本              | appMinorVersion |
     | 名称                  | appName         |
     | 平台和版本信息        | appVersion      |
     | 语言                   | browserLanguage |
     | 是否启用 cookie     | cookieEnabled   |
     | CPU 等级             | cpuClass        |
     | 是否处于脱机模式       | onLine          |
     | 操作系统               | platform        |
     | 默认语言               | systemLanguage  |
     |                        | language        |
     | user-agent 头部的值    | userAgent       |
     | 返回 OS 的自然语言设置 | userLanguage    |
**** 方法
     javaEnabled() 	      规定浏览器是否启用 Java
     taintEnabled() 	    规定浏览器是否启用数据污点 (data tainting)
*** screen
**** 状态
     availHeight 	     返回显示屏幕的高度 (除 Windows 任务栏之外)
     availWidth 	     返回显示屏幕的宽度 (除 Windows 任务栏之外) 
     bufferDepth 	     设置或返回在 off-screen bitmap buffer 中调色板的比特深度
     colorDepth 	     返回目标设备或缓冲器上的调色板的比特深度
     deviceYDPI 	     返回显示屏幕的每英寸垂直点数 
     height 	         返回显示屏幕的高度 
     pixelDepth 	     返回显示屏幕的颜色分辨率（比特每像素）
     width 	           返回显示器屏幕的宽度 
*** history
**** 属性
     length            返回浏览器历史列表中的 URL 数量
**** 方法
     back() 	          加载 history 列表中的前一个 URL 	
     forward() 	        加载 history 列表中的下一个 URL 
     go() 	            加载 history 列表中的某个具体页面 [Num|URL] e: -1 前一个页面	
*** location(url) 
**** 属性
     hash 	            设置或返回从井号 (#) 开始的 URL（锚）
     host 	            设置或返回主机名和当前 URL 的端口号 
     hostname 	        设置或返回当前 URL 的主机名 
     href 	            设置或返回完整的 URL
     pathname 	        设置或返回当前 URL 的路径部分 
     port 	            设置或返回当前 URL 的端口号
     protocol 	        设置或返回当前 URL 的协议 
     search           	设置或返回从问号 (?) 开始的 URL（查询部分）
**** 方法
     assign() 	        加载新的文档
     reload() 	        重新加载当前文档
     replace() 	        用新的文档替换当前文档 
*** document  
**** 属性
     body    	          提供对 <body> 元素的直接访问对于定义了框架集的文档，该属性引用最外层的 <frameset> 	  	  	  	 
     cookie 	          设置或返回与当前文档有关的所有 cookie
     domain 	          返回当前文档的域名 	
     lastModified 	    返回文档被最后修改的日期和时间 该值来自于 Last-Modified HTTP 头部，它是由 Web 服务器发送的可选项	
     referrer 	        返回载入当前文档的文档的 URL
     title 	            返回当前文档的标题 
     URL 	              返回当前文档的 URL 
**** 方法
     close() 	             关闭用 document.open() 方法打开的输出流，并显示选定的数据 
     getElementById() 	   返回对拥有指定 id 的第一个对象的引用
     getElementsByName()   返回带有指定名称的对象集合 	
     getElementsByTagName()返回带有指定标签名的对象集合
     getElementsByClassName()返回带有指定 class 的对象集合
     open() 	             打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出
     write()    	         向文档写 HTML 表达式 或 JavaScript 代码 
     writeln() 	           等同于 write() 方法，不同的是在每个表达式之后写一个换行符 
*** Style
    element.style.属性=属性值 
**** 属性
***** 背景
      background 	          在一行中设置所有的背景属性 
      backgroundAttachment 	设置背景图像是否固定或随页面滚动 
      backgroundColor 	    设置元素的背景颜色 
      backgroundImage 	    设置元素的背景图像 
      backgroundPosition 	  设置背景图像的起始位置 
      backgroundPositionX 	设置 backgroundPosition 属性的 X 坐标 
      backgroundPositionY 	设置 backgroundPosition 属性的 Y 坐标 
      backgroundRepeat 	    设置是否及如何重复背景图像
***** 边框和边距
      border             	在一行设置四个边框的所有属性 	
      borderBottom  	    在一行设置底边框的所有属性 
      borderBottomColor 	设置底边框的颜色 	
      borderBottomStyle 	设置底边框的样式 	
      borderBottomWidth 	设置底边框的宽度 	
      borderColor     	  设置所有四个边框的颜色 (可设置四种颜色) 	
      borderLeft       	  在一行设置左边框的所有属性 
      borderLeftColor 	  设置左边框的颜色 	
      borderLeftStyle 	  设置左边框的样式 	
      borderLeftWidth 	  设置左边框的宽度 	
      borderRight 	      在一行设置右边框的所有属性
      borderRightColor 	  设置右边框的颜色 	
      borderRightStyle 	  设置右边框的样式 	
      borderRightWidth 	  设置右边框的宽度 	
      borderStyle 	      设置所有四个边框的样式 (可设置四种样式) 
      borderTop 	        在一行设置顶边框的所有属性 
      borderTopColor 	    设置顶边框的颜色 		
      borderTopStyle 	    设置顶边框的样式 		
      borderTopWidth 	    设置顶边框的宽度 		
      borderWidth 	      设置所有四条边框的宽度 (可设置四种宽度) 
      margin 	            设置元素的边距 (可设置四个值)
      marginBottom        设置元素的底边距
      marginLeft 	        设置元素的左边距 	
      marginRight 	      设置元素的右边据
      marginTop 	        设置元素的顶边距 	
      outline 	          在一行设置所有的 outline 属性 
      outlineColor 	      设置围绕元素的轮廓颜色 	
      outlineStyle 	      设置围绕元素的轮廓样式 	
      outlineWidth 	      设置围绕元素的轮廓宽度 	
      padding 	          设置元素的填充 (可设置四个值)
      paddingBottom       设置元素的下填充
      paddingLeft 	      设置元素的左填充
      paddingRight 	      设置元素的右填充
      paddingTop 	        设置元素的顶填充 	
***** 布局
      clear    	        设置在元素的哪边不允许其他的浮动元素 	
      clip      	      设置元素的形状 	
      content 	        设置元信息 	
      counterIncrement 	设置其后是正数的计数器名称的列表其中整数指示每当元素出现时计数器的增量默认是 1
      counterReset 	    设置其后是正数的计数器名称的列表其中整数指示每当元素出现时计数器被设置的值默认是 0
      cssFloat 	        设置图像或文本将出现（浮动）在另一元素中的何处 	
      cursor   	        设置显示的指针类型 
      direction 	      设置元素的文本方向 	
      display 	        设置元素如何被显示 	inherit 父的属性继承
      height 	          设置元素的高度 
      markerOffset 	    设置 marker box 的 principal box 距离其最近的边框边缘的距离
      marks 	          设置是否 cross marks 或 crop marks 应仅仅被呈现于 page box 边缘之外 	
      maxHeight 	      设置元素的最大高度 	
      maxWidth 	        设置元素的最大宽度 	
      minHeight 	      设置元素的最小高度 	
      minWidth 	        设置元素的最小宽度 	
****** overflow 	规定如何处理不适合元素盒的内容 	
       overflow-x:      hidden;隐藏水平滚动条
       verticalAlign 	  设置对元素中的内容进行垂直排列 
       visibility 	    设置元素是否可见 
       width 	          设置元素的宽度
***** 列表
      listStyle 	在一行设置列表的所有属性 
      listStyleImage 	把图像设置为列表项标记 
      listStylePosition 改变列表项标记的位置 	
      listStyleType 	设置列表项标记的类型
***** 定位
      bottom 	设置元素的底边缘距离父元素底边缘的之上或之下的距离 	
      left       	置元素的左边缘距离父元素左边缘的左边或右边的距离 	
      position 	把元素放置在 static, relative, absolute 或 fixed 的位置 	
      right 	            置元素的右边缘距离父元素右边缘的左边或右边的距离 	
      top 	            设置元素的顶边缘距离父元素顶边缘的之上或之下的距离 	
      zIndex 	设置元素的堆叠次序
***** 文本
      color 	设置文本的颜色 
      font 	在一行设置所有的字体属性 
      fontFamily 	设置元素的字体系列
      fontSize 	设置元素的字体大小
      fontSizeAdjust 	设置/调整文本的尺寸 
      fontStretch 	设置如何紧缩或伸展字体
      fontStyle 	设置元素的字体样式 
      fontVariant 	用小型大写字母字体来显示文本 
      fontWeight 	设置字体的粗细 
      letterSpacing 	设置字符间距 
      lineHeight 	设置行间距 
      quotes 	设置在文本中使用哪种引号 
      textAlign 	排列文本 
      textDecoration 	设置文本的修饰 
      textIndent 	缩紧首行的文本 
      textShadow 	设置文本的阴影效果
      textTransform 	对文本设置大写效果 
      whiteSpace 	设置如何设置文本中的折行和空白符 	
      wordSpacing 	设置文本中的词间距 
***** Table 
      borderCollapse 	设置表格边框是否合并为单边框，或者像在标准的 HTML 中那样分离 
      borderSpacing 	设置分隔单元格边框的距离 
      captionSide 	设置表格标题的位置 	
      emptyCells 	设置是否显示表格中的空单元格
      tableLayout 	设置用来显示表格单元格、行以及列的算法
*** node
**** 节点属性
     innerHTML: 获取元素内容,很多东西
     nodeName 规定节点的名称
     nodeValue 规定节点的值 (文本节点有值)
***** nodeType 返回节点的类型 nodeType 是只读的
      #+BEGIN_SRC 
      元素 	1
      属性 	2
      文本 	3
      注释 	8
      #+END_SRC
      : 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
**** 修改
     var para=document.createElement("p");
     var node=document.createTextNode("This is new.");
     para.appendChild(node);
**** 节点元素
***** 创建新的 HTML 元素 - appendChild()您首先必须创建该元素，然后把它追加到已有的元素上
***** 创建新的 HTML 元素 - insertBefore()
***** 删除已有的 HTML 元素
      var child=document.getElementById("p1");
      child.parentNode.removeChild(child);
***** 替换 HTML 元素
      : 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：
      #+BEGIN_SRC 
      var parent=document.getElementById("div1");
      var child=document.getElementById("p1");
      parent.replaceChild(para,child);
      #+END_SRC
*** 事件
**** window 
     onload    页面结束加载之后触发   
     onresize  当浏览器窗口被调整大小时触发 
**** 页面或图像  
     onload 
     onUnload
**** FORM 
     onFocus
     onBlur 
     onChange
     onselect      在元素中文本被选中后触发            
     onsubmit     在提交表单时触发                   
**** 键盘
     onkeydown  在用户按下按键时触发
     onkeypress 在用户敲击按钮时触发
     onkeyup    当用户释放按键时触发
**** Mouse 
     onclick
     ondblclick
     onmousedown
     onmouseup 
     onscroll
     onMouseOver 
     onMouseOut
**** Media 
     onabort
     onplay
* 浏览器 API
* web 移动开发最佳实践
** 避免使用全局变量和函数
   var myApp = {
   lang: "en",
   debug: true,
   };
 
   myApp.setLang = function (arg) {
   this.lang = arg;
   }
** 高效的使用 try catch 语句
   var object = ['foo', 'bar'], i;
   try {
   for (i = 0; i < object.length; i++) {
   // do something
   }
   } catch (e) {
   // handle exception
   }
** 使用赋值运算来连接字符串
   str += "x";
   str += "y";
** 避免使用 eval()方法
** 使用事件委托
   在处理 DOM 事件的时候，你可以仅对一个父元素绑定一个事件而不是每一个子元素。
   这种技术即事件委托，它利用事件冒泡来分配事件处理程序，可以提高脚本的性能

   <a href="javascript:handleClick();">Click</a>
   <button id="btn1" onclick="handleClick();">One</button>
   <button id="btn2" onclick="handleClick();">Two</button>
   为了提高代码的性能，我们可以加一个 div 父元素，事件会向上冒泡，直到被处理。事件对象是触发事件的元素，我们可以根据它的 id 属性来判断是哪一个元素触发了事件：
 

   <div id="btngroup">
   <button id="btn1">One</button>
   <button id="btn2">Two</button>
   </div>
   document.getElementById("btngroup").addEventListener("click", function (event) {
   switch (event.srcElement.id) {　　//firefox 下为 event.target.id
   case "btn1":
   handleClick();
   break;
   default:
   handleClick();
   }
   }, false); // type, listener, useCapture (true=beginning, false=end)
** 尽量减少 DOM 操作
   　　DOM 是一个包含了很多信息的复杂的 API，因此即使是很小的操作可能会花费较长的时间执行（如果要重绘页面的话）。为了提高程序性能，应尽量减少 DOM 操作，这里有一些建议：
***  1.减少 DOM 的数目

    DOM 节点的数目会影响与它相关的所有操作，要尽量使 DOM 树小一些：

    避免多余的标记和嵌套的表格
    元素数尽量控制在 500 个以内（document.getElementsByTagName('*').length）
*** 2.缓存已经访问过的节点
    当访问过一个 DOM 元素后，就应该把它缓存起来，因为你的程序往往要重复访问某个对象的，例如：

    for (var i = 0; i < document.images.length; i++) {
    document.images[i].src = "blank.gif";
    }
    以上例子中，docum.images 对象被访问了多次，这并不高效，因为每一次循环中，浏览器都要查找这个元素两次：第一次读取它的长度，第二次改变相应的 src 值。更好的做法是先把这个对象存储起来：

    var imgs = document.images;
    for (var i = 0; i < imgs.length; i++) {　　//当然也可以把 imgs.length 提前算出来，这里不是重点
    imgs[i].src = "blank.gif";
    }
** 减少页面重绘
 　　在控制 DOM 元素数目的同时，你还可以通过减少修改元素（减少页面的重绘）的方法来提高性能。重绘有两种方式：repaint、reflow。

 1.repaint，也叫 redraw，即改变了元素的视觉效果，但是不影响它的排版（比如改变背景颜色）
 2.reflow，会影响部分或者全部页面的排版，浏览器不仅要计算该元素的位置，还要计算它影响到的周围的元素位置

 当你要改变页面布局的时候，reflow 就发生了，主要有如下情况：

 增加或删除 DOM 节点
 改变元素的位置
 改变元素的尺寸（如 margin，padding，border，font，width，height 等）
 调整浏览器窗口的尺寸
 增加或删除 css
 改变内容（如用户输入表单）
 命中 css 选择器（如 hover）
 更改了 class 属性
 利用脚本更改了 DOM
 检索一个必须被计算的尺寸（如 offsetWidth，offsetHeight）
 设置了一个 css 属性
 这里有一些减少页面重绘的建议：

 css 的建议：

 改变 class 属性时应尽量少的影响到周围的元素节点
 避免声明多个内联的样式（把多个样式放在一个外部文件里）
 有动画的元素使用绝对定位，这样不会影响其他元素
 避免使用 table 来排版，如果需要使用保存数据，那么要固定排版（table-layout:fixed）
 js 的建议：

 缓存计算过的样式
 对于固定的样式，改变 class 的名词而不是样式；对于动态的样式，改变 cssText 属性：

 // bad - changing the stle - accessing DOM multiple times
 var myElement = document.getElementById('mydiv');
 myElement.style.borderLeft = '2px';
 myElement.style.borderRight = '3px';
 myElement.style.padding = '5px';
 
 // good - use cssText and modify DOM once
 var myElement = document.getElementById('mydiv');
 myElement.style.cssText = 'border-left: 2px; border-right: 3px; padding: 5px;';

 当你要对一个 DOM 元素做出很多修改时，可以先进行一些‘预处理’，批量修改后再替换原始的元素
 创建一个副本（cloneNode()），对这个副本进行更新，然后替代原来的节点

 // slower - multiple reflows
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster - create a copy
 var orig = document.getElementById('container'),
     clone = orig.cloneNode(true), // create a copy
     list = ['foo', 'bar', 'baz'], elem, contents;
 clone.setAttribute('width', '50%');

 修改一个不可见的元素，可以先让其不可见（display:none），修改完成后，再恢复其可见（display:block），这样就会减少 reflow 的次数

 // slower
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.appendChild(subElem);
 elem.style.width = '320px';
             
 // faster
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.style.display = 'none'; // will not be repainted
 elem.appendChild(subElem);
 elem.style.width = '320px';
 elem.style.display = 'block';

 创建一个文档片段（使用 DocumentFragment()），修改完成后，再把它追加到原始文档中

 // slower
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster
 var fragment = document.createDocumentFragment(),
     list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     fragment.appendChild(content);
 }
 document.body.appendChild(fragment); // one reflow

* 异步操作概述

## 单线程模型

单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。

注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。

JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。

如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。

单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

## 同步任务和异步任务

程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。

同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。

举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。

## 任务队列和事件循环

JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）

首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。[维基百科](http://en.wikipedia.org/wiki/Event_loop)的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。

## 异步操作的模式

下面总结一下异步操作的几种模式。

### 回调函数

回调函数是异步操作最基本的方法。

下面是两个函数`f1`和`f2`，编程的意图是`f2`必须等到`f1`执行完成，才能执行。

```javascript
function f1() {
  // ...
}

function f2() {
  // ...
}

f1();
f2();
```

上面代码的问题在于，如果`f1`是异步操作，`f2`会立即执行，不会等到`f1`结束再执行。

这时，可以考虑改写`f1`，把`f2`写成`f1`的回调函数。

```javascript
function f1(callback) {
  // ...
  callback();
}

function f2() {
  // ...
}

f1(f2);
```

回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](http://en.wikipedia.org/wiki/Coupling_(computer_programming))（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

### 事件监听

另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

还是以`f1`和`f2`为例。首先，为`f1`绑定一个事件（这里采用的 jQuery 的[写法](http://api.jquery.com/on/)）。

```javascript
f1.on('done', f2);
```

上面这行代码的意思是，当`f1`发生`done`事件，就执行`f2`。然后，对`f1`进行改写：

```javascript
function f1() {
  setTimeout(function () {
    // ...
    f1.trigger('done');
  }, 1000);
}
```

上面代码中，`f1.trigger('done')`表示，执行完成后，立即触发`done`事件，从而开始执行`f2`。

这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”[去耦合](http://en.wikipedia.org/wiki/Decoupling)“（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

### 发布/订阅

事件完全可以理解成”信号“，如果存在一个”信号中心“，某个任务执行完成，就向信号中心”发布“（publish）一个信号，其他任务可以向信号中心”订阅“（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](http://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](http://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。

这个模式有多种[实现](http://msdn.microsoft.com/en-us/magazine/hh201955.aspx)，下面采用的是 Ben Alman 的 [Tiny Pub/Sub](https://gist.github.com/661855)，这是 jQuery 的一个插件。

首先，`f2`向信号中心`jQuery`订阅`done`信号。

```javascript
jQuery.subscribe('done', f2);
```

然后，`f1`进行如下改写。

```javascript
function f1() {
  setTimeout(function () {
    // ...
    jQuery.publish('done');
  }, 1000);
}
```

上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。

`f2`完成执行后，可以取消订阅（unsubscribe）。

```javascript
jQuery.unsubscribe('done', f2);
```

这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

## 异步操作的流程控制

如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。

```javascript
function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1 秒后返回结果');
  setTimeout(function () { callback(arg * 2); }, 1000);
}
```

上面代码的`async`函数是一个异步任务，非常耗时，每次执行需要 1 秒才能完成，然后再调用回调函数。

如果有六个这样的异步任务，需要全部完成后，才能执行最后的`final`函数。请问应该如何安排操作流程？

```javascript
function final(value) {
  console.log('完成: ', value);
}

async(1, function(value){
  async(value, function(value){
    async(value, function(value){
      async(value, function(value){
        async(value, function(value){
          async(value, final);
        });
      });
    });
  });
});
```

上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。

### 串行执行

我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];

function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1 秒后返回结果');
  setTimeout(function () { callback(arg * 2); }, 1000);
}

function final(value) {
  console.log('完成: ', value);
}

function series(item) {
  if(item) {
    async( item, function(result) {
      results.push(result);
      return series(items.shift());
    });
  } else {
    return final(results[results.length - 1]);
  }
}

series(items.shift());
```

上面代码中，函数`series`就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行`final`函数。`items`数组保存每一个异步任务的参数，`results`数组保存每一个异步任务的运行结果。

注意，上面的写法需要六秒，才能完成整个脚本。

### 并行执行

流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行`final`函数。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];

function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1 秒后返回结果');
  setTimeout(function () { callback(arg * 2); }, 1000);
}

function final(value) {
  console.log('完成: ', value);
}

items.forEach(function(item) {
  async(item, function(result){
    results.push(result);
    if(results.length === items.length) {
      final(results[results.length - 1]);
    }
  })
});
```

上面代码中，`forEach`方法会同时发起六个异步任务，等到它们全部完成以后，才会执行`final`函数。

相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。

### 并行与串行的结合

所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行`n`个异步任务，这样就避免了过分占用系统资源。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
var running = 0;
var limit = 2;

function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1 秒后返回结果');
  setTimeout(function () { callback(arg * 2); }, 1000);
}

function final(value) {
  console.log('完成: ', value);
}

function launcher() {
  while(running < limit && items.length > 0) {
    var item = items.shift();
    async(item, function(result) {
      results.push(result);
      running--;
      if(items.length > 0) {
        launcher();
      } else if(running == 0) {
        final(results);
      }
    });
    running++;
  }
}

launcher();
```

上面代码中，最多只能同时运行两个异步任务。变量`running`记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于`0`，就表示所有任务都执行完了，这时就执行`final`函数。

这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节`limit`变量，达到效率和资源的最佳平衡。
