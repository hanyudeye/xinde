* Javascript 
  :  learn project /home/wuming/git/lang/javascript/javascript-tutorial/
** 对象
*** 东西
    数字，文字
*** 新建对象
   名字：值（类型）
 #+BEGIN_SRC json
 {
       "firstName": "John",
       "lastName": "Smith",
       "sex": "male",
       "age": 25,
       "address": 
       {
           "streetAddress": "21 2nd Street",
           "city": "New York",
           "state": "NY",
           "postalCode": "10021"
       },
       "phoneNumber": 
       [
           {
             "type": "home",
             "number": "212 555-1234"
           },
           {
             "type": "fax",
             "number": "646 555-4567"
           }
       ]
   }
 [
 {
      "text":"This is the text","color":"dark_red","bold":"true","strikethough":"true","clickEvent":
           {"action":"open_url","value":"zh.wikipedia.org"},
      "hoverEvent":
           {"action":"show_text","value":
                {"extra":"something"}
           }
 },
 {
      "translate":"item.dirt.name","color":"blue","italic":"true"
 }
 ]

 #+END_SRC
*** 东西起名字(变量) 
    var a=东西;
** 行为
*** 起名字
    #+begin_src javascript
      function doAdd(a,b) {
          return a + b;
      }
    #+end_src
*** 匿名函数
    #+begin_src javascript

      var doEcho = function() {
          console.log('你好');
      }
    #+end_src
*** 纯动作
    #+begin_src javascript

      function addLater(a,b,callback) {
          setTimeout(function() {
              var sum = a+b;
              callback(sum);
          },1000);
      }
    #+end_src
** 可视对象行为（事件)
   行为绑定 document.getElementById("btnTest").onclick=thisTest; //给button的onclick事件注册一个函数
   
   - 行为类型
     - 页面或图像对象 载入行为 onload 和 onUnload 
     - 表单对象 onFocus, onBlur 和 onChange
     - 鼠标对象 onMouseOver 和 onMouseOut
     - 提交对象 onSubmit 
** 错误对象捕捉 
*** Try...Catch 
    #+BEGIN_SRC js
      try
      {
          //在此运行代码
      }
      catch(err)
      {
          //在此处理错误
      }
    #+END_SRC
    #+BEGIN_SRC html
      <html>
        <head>
          <script type="text/javascript">
            var txt=""
            function message()
            {
            try
            {
            adddlert("Welcome guest!")
            }
            catch(err)
            {
            txt="此页面存在一个错误。\n\n"
            txt+="错误描述: " + err.description + "\n\n"
            txt+="点击OK继续。\n\n"
            alert(txt)
            }
            }
          </script>
        </head>

        <body>
          <input type="button" value="View message" onclick="message()" />
        </body>
      </html>
      #+END_SRC
** 对象库
*** Date对象
    #+BEGIN_SRC js
      日期 Date() getTime() setFullYear() toUTString getDay()
      new Date() // 当前日期和时间
      new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数
      new Date(dateString)
      new Date(year, month, day, hours, minutes, seconds, milliseconds)

      milliseconds 毫秒（0-999） 1秒=1000毫秒
      var today = new Date()
      var d1 = new Date("October 13, 1975 11:13:00")
      var d2 = new Date(79,5,24)
      var d3 = new Date(79,5,24,11,33,0)
      设置日期
      var myDate=new Date();
      myDate.setFullYear(2010,0,14);

      设置日期为5天后
      var myDate=new Date();
      myDate.setDate(myDate.getDate()+5);
      getTime 获取毫秒时间
    #+END_SRC
*** Math
    abs 绝对值
    E 自然对数
    LN2 2的自然对数
    PI 圆周率
    Math.SQRT2 2的平方根
    sqrt 平方根
    pow(x, y) x的y次方
    max
    min
    ceil 上
    floor 下
    round 四舍五入
*** 对象与字符串转换
    对象字符串化   var strify = JSON.stringify(arr);
    字符串对象话  var arrParse = JSON.parse(strify);
*** 字符正则查找
    #+BEGIN_SRC js
      var s="helo world";
      var i=s.search(/wo/i);
      i: 不区分大小写
    #+END_SRC
*** 对象数列 Array
    数组创建
    var arr1 = new Array(); //创建一个空数组
    var arr2 = new Array(20); // 创建一个包含20项的数组
    var arr3 = new Array("lily","lucy","Tom"); // 创建一个包含3个字符串的数组
    创建数组的第二种基本方式是使用数组字面量表示法：

    var arr4 = []; //创建一个空数组
    var arr5 = [20]; // 创建一个包含1项的数组
    var arr6 = ["lily","lucy","Tom"]; // 创建一个包含3个字符串的数组
    在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：

    var arr6 = ["lily","lucy","Tom"]; // 创建一个包含3个字符串的数组
    alert(arr6[0]); //lily
    arr6[1] = "mary"; //修改第二项为mary
    arr6[3] = "sean"; //增加第四项为sean
    JavaScript中数组的length属性是可以修改的，看下面的示例：

    var arr = ["lily","lucy","Tom"]; // 创建一个包含3个字符串的数组
    arr[arr.length] = "sean"; //在下标为3处（也就是数组尾部）添加一项"sean"
    arr.length = arr.length-1; //将数组的最后一项删除
    如果需要判断一个对象是不是数组对象，在ECMAScript 5之前，我们可以通过 instanceof Array去判断，但是instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

    ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

    数组方法

    下面开始介绍数组的方法，数组的方法有数组原型方法，也有从object对象继承来的方法，这里我们只介绍数组的原型方法，数组原型方法主要有以下这些：

    join()
    push()和pop()
    shift() 和 unshift()
    sort()
    reverse()
    concat()
    slice()
    splice()
    indexOf()和 lastIndexOf() （ES5新增）
    forEach() （ES5新增）
    map() （ES5新增）
    filter() （ES5新增）
    every() （ES5新增）
    some() （ES5新增）
    reduce()和 reduceRight() （ES5新增）
    针对ES5新增的方法浏览器支持情况：

    Opera 11+ 
    Firefox 3.6+ 
    Safari 5+ 
    Chrome 8+ 
    Internet Explorer 9+

    对于支持的浏览器版本，可以通过Array原型扩展来实现。下面详细介绍一下各个方法的基本功能。

    1、join()

    join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。

    var arr = [1,2,3];
    console.log(arr.join()); // 1,2,3
    console.log(arr.join("-")); // 1-2-3
    console.log(arr); // [1, 2, 3]（原数组不变）
    通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：

    function repeatString(str, n) {
    return new Array(n + 1).join(str);
    }
    console.log(repeatString("abc", 3)); // abcabcabc
    console.log(repeatString("Hi", 5)); // HiHiHiHiHi
    2、push()和pop()

    push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 
    pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

    var arr = ["Lily","lucy","Tom"];
    var count = arr.push("Jack","Sean");
    console.log(count); // 5
    console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]
    var item = arr.pop();
    console.log(item); // Sean
    console.log(arr); // ["Lily", "lucy", "Tom", "Jack"]
    3、shift() 和 unshift()

    shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。 
    unshift:将参数添加到原数组开头，并返回数组的长度 。

    这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。

    var arr = ["Lily","lucy","Tom"];
    var count = arr.unshift("Jack","Sean");
    console.log(count); // 5
    console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]
    var item = arr.shift();
    console.log(item); // Jack
    console.log(arr); // ["Sean", "Lily", "lucy", "Tom"]
    4、sort()

    sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。

    在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：

    var arr1 = ["a", "d", "c", "b"];
    console.log(arr1.sort()); // ["a", "b", "c", "d"]
    arr2 = [13, 24, 51, 3];
    console.log(arr2.sort()); // [13, 24, 3, 51]
    console.log(arr2); // [13, 24, 3, 51](元数组被改变)
    为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：

    function compare(value1, value2) {
    if (value1 < value2) {
    return -1;
    } else if (value1 > value2) {
    return 1;
    } else {
    return 0;
    }
    }
    arr2 = [13, 24, 51, 3];
    console.log(arr2.sort(compare)); // [3, 13, 24, 51]
    如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：

    function compare(value1, value2) {
    if (value1 < value2) {
    return 1;
    } else if (value1 > value2) {
    return -1;
    } else {
    return 0;
    }
    }
    arr2 = [13, 24, 51, 3];
    console.log(arr2.sort(compare)); // [51, 24, 13, 3]

    5、reverse()

    reverse()：反转数组项的顺序。

    var arr = [13, 24, 51, 3];
    console.log(arr.reverse()); //[3, 51, 24, 13]
    console.log(arr); //[3, 51, 24, 13](原数组改变)
    6、concat()

    concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

    var arr = [1,3,5,7];
    var arrCopy = arr.concat(9,[11,13]);
    console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
    console.log(arr); // [1, 3, 5, 7](原数组未被修改)
    从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？

    var arrCopy2 = arr.concat([9,[11,13]]);
    console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
    console.log(arrCopy2[5]); //[11, 13]
    上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。

    7、slice()

    slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

    var arr = [1,3,5,7,9,11];
    var arrCopy = arr.slice(1);
    var arrCopy2 = arr.slice(1,4);
    var arrCopy3 = arr.slice(1,-2);
    var arrCopy4 = arr.slice(-4,-1);
    console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
    console.log(arrCopy); //[3, 5, 7, 9, 11]
    console.log(arrCopy2); //[3, 5, 7]
    console.log(arrCopy3); //[3, 5, 7]
    console.log(arrCopy4); //[5, 7, 9]
    arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。 
    arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。 
    arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 
    arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。

    8、splice()

    splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。

    删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。
    插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。
    替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。
    splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。

    var arr = [1,3,5,7,9,11];
    var arrRemoved = arr.splice(0,2);
    console.log(arr); //[5, 7, 9, 11]
    console.log(arrRemoved); //[1, 3]
    var arrRemoved2 = arr.splice(2,0,4,6);
    console.log(arr); // [5, 7, 4, 6, 9, 11]
    console.log(arrRemoved2); // []
    var arrRemoved3 = arr.splice(1,1,2,4);
    console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
    console.log(arrRemoved3); //[7]
    9、indexOf()和 lastIndexOf()

    indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 
    lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。

    这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

    var arr = [1,3,5,7,7,5,3,1];
    console.log(arr.indexOf(5)); //2
    console.log(arr.lastIndexOf(5)); //5
    console.log(arr.indexOf(5,2)); //2
    console.log(arr.lastIndexOf(5,4)); //2
    console.log(arr.indexOf("5")); //-1
    10、forEach()

    forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。

    var arr = [1, 2, 3, 4, 5];
    arr.forEach(function(x, index, a){
    console.log(x + '|' + index + '|' + (a === arr));
    });
    // 输出为：
    // 1|0|true
    // 2|1|true
    // 3|2|true
    // 4|3|true
    // 5|4|true
    11、map()

    map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。

    下面代码利用map方法实现数组中每个数求平方。

    var arr = [1, 2, 3, 4, 5];
    var arr2 = arr.map(function(item){
    return item*item;
    });
    console.log(arr2); //[1, 4, 9, 16, 25]
    12、filter()

    filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。

    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    var arr2 = arr.filter(function(x, index) {
    return index % 3 === 0 || x >= 8;
    }); 
    console.log(arr2); //[1, 4, 7, 8, 9, 10]
    13、every()

    every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。

    var arr = [1, 2, 3, 4, 5];
    var arr2 = arr.every(function(x) {
    return x < 10;
    }); 
    console.log(arr2); //true
    var arr3 = arr.every(function(x) {
    return x < 3;
    }); 
    console.log(arr3); // false
    14、some()

    some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。

    var arr = [1, 2, 3, 4, 5];
    var arr2 = arr.some(function(x) {
    return x < 3;
    }); 
    console.log(arr2); //true
    var arr3 = arr.some(function(x) {
    return x < 1;
    }); 
    console.log(arr3); // false
    15、reduce()和 reduceRight()

    这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。

    这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。

    传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

    下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。

    var values = [1,2,3,4,5];
    var sum = values.reduceRight(function(prev, cur, index, array){
    return prev + cur;
    },10);
    console.log(sum); //25
*** 时钟对象
    执行一次 setTimeout
    重复执行 setInterval
    #+BEGIN_SRC html 
      <html>
        <head>
          <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
          <title>无标题文档</title>
          <script language="JavaScript" type="text/javascript">
            var str = "这个是测试用的范例文字";
            var seq = 0;
            var second=1000; //间隔时间1秒钟
            function scroll() {
            msg = str.substring(0, seq+1);
            document.getElementByIdx_x_x('word').innerHTML = msg;
            seq++;
            if (seq >= str.length) seq = 0;
            }
          </script>
        </head>
        <body onload="setInterval('scroll()',second)">
          <div id="word"></div><br/><br/>
        </body>
      </html>
      <p>页面上显示时钟：</p>
      <p id="demo"></p>
      <button onclick="myStopFunction()">停止时钟</button>
      <script>
        var myVar=setInterval(function(){myTimer()},1000);
        function myTimer(){
        var d=new Date();
        var t=d.toLocaleTimeString();
        document.getElementById("demo").innerHTML=t;
        }
        function myStopFunction(){
        clearInterval(myVar);
        }
      </script>


    #+END_SRC
** 对象的模板 类 最新ES6语法
*** ES5模拟类  
    #+begin_src javascript
      function PersonES5(p) {
          this.age = p.age;
          this.name = p.name;
          this.sex = p.sex;
      }

      PersonES5.prototype.showInfo = function() {
          console.log(this);
      };

      var person = new PersonES5({
          age:18,
          name:'tom',
          sex:'boy'
      });

      person.showInfo();
 #+end_src
*** ES6
    #+begin_src js
      class PersonES6 {
          constructor(p) {
              this.age = p.age;
              this.name = p.name;
              this.sex = p.sex;
          }
          showInfo() {
              console.log(this);
          }
      }


      var person = new PersonES6({
          age:18,
          name:'tom',
          sex:'boy'
      });

      person.showInfo();
    #+end_src
* 外观对象 DOM (树型排列）
*** 窗口(最外层的html)  window
**** 对象状态
    | 窗口是否已被关闭               | closed      |
    | 文档显示区高度                 | innerHeight |
    | 文档显示区宽度                 | innerwidth  |
    | 设置或返回框架数量             | length      |
    | 设置或返回窗口的名称           | name        |
    | 返回窗口的外部高度。           | outerheight |
    | 返回窗口的外部宽度。           | outerwidth  |
    | 返回父窗口。                   | parent      |
    | 返回对当前窗口的引用           | self        |
    | 设置窗口状态栏的文本           | status      |
    | 返回最顶层的先辈窗口           | top         |
    | 窗口的左上角在屏幕上的的y 坐标 | screenY     |
**** 动作
 alert() 	           显示带有一段消息和一个确认按钮的警告框。
 blur() 	           把键盘焦点从顶层窗口移开。
 clearInterval() 	   取消由 setInterval() 设置的 timeout。 
 clearTimeout()      取消由 setTimeout() 方法设置的 timeout。
 close() 	           关闭浏览器窗口。 
 confirm() 	         显示带有一段消息以及确认按钮和取消按钮的对话框。
 createPopup() 	     创建一个 pop-up 窗口
 focus() 	           把键盘焦点给予一个窗口
 moveBy() 	         可相对窗口的当前坐标把它移动指定的像素
 moveTo() 	         把窗口的左上角移动到一个指定的坐标。
 open() 	           打开一个新的浏览器窗口或查找一个已命名的窗口
window.open("http://www.baidu.com", "_blank");
 opener 访问打开的原窗口
 print()    	       打印当前窗口的内容。(打印机）
 prompt() 	         显示可提示用户输入的对话框。 
 resizeBy() 	       按照指定的像素调整窗口的大小。
 resizeTo() 	       把窗口的大小调整到指定的宽度和高度。
 scrollBy() 	       按照指定的像素值来滚动内容。 
 scrollTo() 	       把内容滚动到指定的坐标。
 setInterval() 	     按照指定的周期（以毫秒计）来调用函数或计算表达式。
 setTimeout() 	     在指定的毫秒数后调用函数或计算表达式。
*** 浏览器 navigator
**** 属性
    | 代码名。               | appCodeName     |
    | 次级版本。             | appMinorVersion |
    | 名称。                 | appName         |
    | 平台和版本信息。       | appVersion      |
    | 语言                   | browserLanguage |
    | 是否启用 cookie 。     | cookieEnabled   |
    | CPU 等级。             | cpuClass        |
    | 是否处于脱机模式       | onLine          |
    | 操作系统               | platform        |
    | 默认语言               | systemLanguage  |
    |                        | language        |
    | user-agent 头部的值    | userAgent       |
    | 返回 OS 的自然语言设置 | userLanguage    |
**** 方法
     javaEnabled() 	      规定浏览器是否启用 Java。
     taintEnabled() 	    规定浏览器是否启用数据污点 (data tainting)
*** 屏幕 screen
**** 状态
     availHeight 	     返回显示屏幕的高度 (除 Windows 任务栏之外)。
     availWidth 	     返回显示屏幕的宽度 (除 Windows 任务栏之外)。 
     bufferDepth 	     设置或返回在 off-screen bitmap buffer 中调色板的比特深度。
     colorDepth 	     返回目标设备或缓冲器上的调色板的比特深度。
     deviceYDPI 	     返回显示屏幕的每英寸垂直点数。 
     height 	         返回显示屏幕的高度。 
     pixelDepth 	     返回显示屏幕的颜色分辨率（比特每像素）
     width 	           返回显示器屏幕的宽度。 
*** history
**** 属性
     length            返回浏览器历史列表中的 URL 数量
**** 方法
back() 	          加载 history 列表中的前一个 URL 	
forward() 	        加载 history 列表中的下一个 URL 
go() 	            加载 history 列表中的某个具体页面 [Num|URL] e: -1 前一个页面	
*** location 地址
**** 属性
 hash 	            设置或返回从井号 (#) 开始的 URL（锚）。
 host 	            设置或返回主机名和当前 URL 的端口号。 
 hostname 	        设置或返回当前 URL 的主机名。 
 href 	            设置或返回完整的 URL。
 pathname 	        设置或返回当前 URL 的路径部分。 
 port 	            设置或返回当前 URL 的端口号。
 protocol 	        设置或返回当前 URL 的协议。 
 search           	设置或返回从问号 (?) 开始的 URL（查询部分）。
**** 方法
 assign() 	        加载新的文档。
 reload() 	        重新加载当前文档。
 replace() 	        用新的文档替换当前文档。 
*** document  显示区域 body
**** 属性
     body    	          提供对 <body> 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 <frameset>。 	  	  	  	 
     cookie 	          设置或返回与当前文档有关的所有 cookie。
     domain 	          返回当前文档的域名。 	
     lastModified 	    返回文档被最后修改的日期和时间。 该值来自于 Last-Modified HTTP 头部，它是由 Web 服务器发送的可选项	
     referrer 	        返回载入当前文档的文档的 URL。
     title 	            返回当前文档的标题。 
     URL 	              返回当前文档的 URL。 
**** 方法
close() 	             关闭用 document.open() 方法打开的输出流，并显示选定的数据。 
getElementById() 	   返回对拥有指定 id 的第一个对象的引用。
getElementsByName()   返回带有指定名称的对象集合。 	
getElementsByTagName()返回带有指定标签名的对象集合。
getElementsByClassName()返回带有指定 class 的对象集合。
open() 	             打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。
write()    	         向文档写 HTML 表达式 或 JavaScript 代码。 
writeln() 	           等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 
#+BEGIN_SRC javascript
<script type="text/javascript">
function createNewDoc()
  {
  var newDoc=document.open("text/html","replace");
  var txt="<html><body>学习 DOM 非常有趣！</body></html>";
  newDoc.write(txt);
  newDoc.close();
  }
</script>
#+END_SRC
*** Style(样式)
   element.style.属性=属性值 
**** 属性
***** 背景
 background 	          在一行中设置所有的背景属性 
 backgroundAttachment 	设置背景图像是否固定或随页面滚动 
 backgroundColor 	    设置元素的背景颜色 
 backgroundImage 	    设置元素的背景图像 
 backgroundPosition 	  设置背景图像的起始位置 
 backgroundPositionX 	设置backgroundPosition属性的X坐标 
 backgroundPositionY 	设置backgroundPosition属性的Y坐标 
 backgroundRepeat 	    设置是否及如何重复背景图像
***** 边框和边距
      border             	在一行设置四个边框的所有属性 	
      borderBottom  	    在一行设置底边框的所有属性 
      borderBottomColor 	设置底边框的颜色 	
      borderBottomStyle 	设置底边框的样式 	
      borderBottomWidth 	设置底边框的宽度 	
      borderColor     	  设置所有四个边框的颜色 (可设置四种颜色) 	
      borderLeft       	  在一行设置左边框的所有属性 
      borderLeftColor 	  设置左边框的颜色 	
      borderLeftStyle 	  设置左边框的样式 	
      borderLeftWidth 	  设置左边框的宽度 	
      borderRight 	      在一行设置右边框的所有属性
      borderRightColor 	  设置右边框的颜色 	
      borderRightStyle 	  设置右边框的样式 	
      borderRightWidth 	  设置右边框的宽度 	
      borderStyle 	      设置所有四个边框的样式 (可设置四种样式) 
      borderTop 	        在一行设置顶边框的所有属性 
      borderTopColor 	    设置顶边框的颜色 		
      borderTopStyle 	    设置顶边框的样式 		
      borderTopWidth 	    设置顶边框的宽度 		
      borderWidth 	      设置所有四条边框的宽度 (可设置四种宽度) 
      margin 	            设置元素的边距 (可设置四个值)
      marginBottom        设置元素的底边距
      marginLeft 	        设置元素的左边距 	
      marginRight 	      设置元素的右边据
      marginTop 	        设置元素的顶边距 	
      outline 	          在一行设置所有的outline属性 
      outlineColor 	      设置围绕元素的轮廓颜色 	
      outlineStyle 	      设置围绕元素的轮廓样式 	
      outlineWidth 	      设置围绕元素的轮廓宽度 	
      padding 	          设置元素的填充 (可设置四个值)
      paddingBottom       设置元素的下填充
      paddingLeft 	      设置元素的左填充
      paddingRight 	      设置元素的右填充
      paddingTop 	        设置元素的顶填充 	
***** 布局
      clear    	        设置在元素的哪边不允许其他的浮动元素 	
      clip      	      设置元素的形状 	
      content 	        设置元信息 	
      counterIncrement 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器的增量。默认是1。
      counterReset 	    设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器被设置的值。默认是0。
      cssFloat 	        设置图像或文本将出现（浮动）在另一元素中的何处。 	
      cursor   	        设置显示的指针类型 
      direction 	      设置元素的文本方向 	
      display 	        设置元素如何被显示 	inherit父的属性继承
      height 	          设置元素的高度 
      markerOffset 	    设置marker box的principal box距离其最近的边框边缘的距离
      marks 	          设置是否cross marks或crop marks应仅仅被呈现于page box边缘之外 	
      maxHeight 	      设置元素的最大高度 	
      maxWidth 	        设置元素的最大宽度 	
      minHeight 	      设置元素的最小高度 	
      minWidth 	        设置元素的最小宽度 	
****** overflow 	规定如何处理不适合元素盒的内容 	
       overflow-x:      hidden;隐藏水平滚动条
       verticalAlign 	  设置对元素中的内容进行垂直排列 
       visibility 	    设置元素是否可见 
       width 	          设置元素的宽度
***** 列表
      listStyle 	在一行设置列表的所有属性 
      listStyleImage 	把图像设置为列表项标记 
      listStylePosition改变列表项标记的位置 	
      listStyleType 	设置列表项标记的类型
***** 定位
      bottom 	设置元素的底边缘距离父元素底边缘的之上或之下的距离 	
      left       	置元素的左边缘距离父元素左边缘的左边或右边的距离 	
      position 	把元素放置在static, relative, absolute 或 fixed 的位置 	
      right 	            置元素的右边缘距离父元素右边缘的左边或右边的距离 	
      top 	            设置元素的顶边缘距离父元素顶边缘的之上或之下的距离 	
      zIndex 	设置元素的堆叠次序
***** 文本
      color 	设置文本的颜色 
      font 	在一行设置所有的字体属性 
      fontFamily 	设置元素的字体系列。
      fontSize 	设置元素的字体大小。
      fontSizeAdjust 	设置/调整文本的尺寸 
      fontStretch 	设置如何紧缩或伸展字体
      fontStyle 	设置元素的字体样式 
      fontVariant 	用小型大写字母字体来显示文本 
      fontWeight 	设置字体的粗细 
      letterSpacing 	设置字符间距 
      lineHeight 	设置行间距 
      quotes 	设置在文本中使用哪种引号 
      textAlign 	排列文本 
      textDecoration 	设置文本的修饰 
      textIndent 	缩紧首行的文本 
      textShadow 	设置文本的阴影效果
      textTransform 	对文本设置大写效果 
      whiteSpace 	设置如何设置文本中的折行和空白符 	
      wordSpacing 	设置文本中的词间距 
***** Table 
      borderCollapse 	设置表格边框是否合并为单边框，或者像在标准的HTML中那样分离。 
      borderSpacing 	设置分隔单元格边框的距离 
      captionSide 	设置表格标题的位置 	
      emptyCells 	设置是否显示表格中的空单元格
      tableLayout 	设置用来显示表格单元格、行以及列的算法
*** node
**** 节点属性
     innerHTML: 获取元素内容,很多东西
     nodeName 规定节点的名称
     nodeValue 规定节点的值 (文本节点有值)
***** nodeType 返回节点的类型。nodeType 是只读的
      #+BEGIN_SRC 
      元素 	1
      属性 	2
      文本 	3
      注释 	8
      #+END_SRC
      : 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
**** 修改
     var para=document.createElement("p");
     var node=document.createTextNode("This is new.");
     para.appendChild(node);
**** HTML DOM - 元素
***** 创建新的 HTML 元素 - appendChild()您首先必须创建该元素，然后把它追加到已有的元素上。
***** 创建新的HTML元素 - insertBefore()
***** 删除已有的HTML元素
      var child=document.getElementById("p1");
      child.parentNode.removeChild(child);
***** 替换 HTML 元素
      : 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：
      #+BEGIN_SRC 
      var parent=document.getElementById("div1");
      var child=document.getElementById("p1");
      parent.replaceChild(para,child);
      #+END_SRC
**** HTML DOM事件
***** window 事件属性
      onload    页面结束加载之后触发。   
      onresize  当浏览器窗口被调整大小时触发。 
***** FORM 事件
      onselect      script 在元素中文本被选中后触发。            
      onsubmit      script 在提交表单时触发。                   
***** 键盘事件
      onkeydown  script 在用户按下按键时触发。
      onkeypress script 在用户敲击按钮时触发。
      onkeyup    script 当用户释放按键时触发。
***** Mouse事件
      onclick
      ondblclick
      onmousedown
      onscroll
***** Media事件
      onabort
      onplay
***** onmousedown、onmouseup 以及 onclick 事件
* 树节点(对象)查询 jquery
** 插件源  
   <script type="text/javascript" src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.js">
** 选择节点
   $('') 
  节点名
  节点class属性
  节点ID属性
*** 确定当前的conext
    在任何事件内部，this引用的都是Dom对象
    在任何插件内部，this引用的都是当前的jquery对象
    在$(…).each方法中，this引用的都是Dom或正被遍历的元素对象
   
    在ajax事件中，this默认指向的是调用本次AJAX请求时传递的options参数，可以通过设
    定ajax options的context参数进行修改;
   
    转为Dom对象
    var $v =$("#v");    //jQuery对象
    var v=$v[0];       //DOM对象 
    var v=$v.get(0);   //DOM对象 
*** 节点过滤查找
    jQuery.find(expr)	不会有初始集合中的内容
    jQuery.filter(expr)	从初始的jQuery对象集合中筛选出一部分
    $("p").find("span");//是从元素p的后代开始找，等于$("p span")
** 节点对象属性 
*** 属性值
    $(…).attr	属性值
    $(…).prop	访问html规范定义的属性

    <input id="chk1" type="checkbox" />是否可见
    <input id="chk2" type="checkbox" checked="checked" />是否可见
    分别用prop和attr的操作结果如下：
    $("#chk1").prop("checked") == false
    $("#chk2").prop("checked") == true

    $("#chk1").attr("checked") == undefined
    $("#chk2").attr("checked") == "checked"
*** 节点漫游
    $.parent(expr)	找父元素
    $.parents(expr)	找到所有祖先元素，不限于父元素
    $.children(expr)	查找所有子元素，只会找到直接的孩子节点，不会返回所有子孙
    $.prev()	查找上一个兄弟节点，不是所有的兄弟节点
    $.prevAll()	查找所有之前的兄弟节点
    $.next()	查找下一个兄弟节点，不是所有的兄弟节点
    $.nextAll()	查找所有之后的兄弟节点
    $.siblings()	查找兄弟节点，不分前后
*** 节点定义事件
    基本只需要使用on、once、off三个即可 
    尽可能使用命名空间（bootstrap比较常见）
   
    $("#main").on("click.test",function(){
    this;//指向当前的Dom元素
    });
   
 灵活运用事件委托，利用时间冒泡机制，将事件绑定到祖先元素
 $("#parent").on("click.test",function(event){
     var $target=$(event.target);
     if($target.is("#child1")){//是否为child1
     //...
     }
     if($target.is("#child2")){//是否为child2
     //...
     }
     return false;//=event.stopPropagation();event.preventDefault();
 });

 使用命名函数代替匿名函数可以解决事件重复绑定问题，因为同一个命名函数绑定同一个事
 件只会绑定一次。
*** 动态创建节点
    #+begin_src js
      $('<input />',{
          type:"checkbox",
          name:"cbox",
          val:"1",
          checked:"checked"
      }).appendTo("body");
    #+end_src
*** 遍历
    $.each(data,function(index,item){})
    $.each(data,function(k,v,object){})
*** 表单对象
    //用Form传递表单数据
    var formData=new FormData();//方式1，new一个FormData
    formData.append("username","张三");

    var form=document.getElementById("myForm");
    var formData=new FormData(form);//方式2，根据Form创建FormData
    formData.append(...);//添加额外内容
    //xhr.open("POST",form.action);
    //xhr.send(formData);//使用xhr发送数据

    $.ajax({//使用jquery发送数据
    url:"example.php",
    type:"POST",
    data=formData,
    processData:false,//告诉jquery不要处理待发送的数据
    contentType:false//告诉jquery不要设置Content-Type请求头，默认为“application/x-www-form-urlencoded”
    });
* 60个很实用的jQuery代码开发技巧收集
** 1. 创建一个嵌套的过滤器
<span class="pun">.filter(":not(:has(.selected))")
 //去掉所有不包含class为.selected的元素
</span>
** 2. 重用你的元素查询
    var allItems = $("div.item");  
    var keepList = $("div#container1 div.item");
    $(formToLookAt + " input:checked").each(function() {     keepListkeepList = keepList.filter("." + $(this).attr("name")); });
** 3. 使用has()来判断一个元素是否包含特定的class或者元素
$("input").has(".email").addClass("email_icon");
** 4. 使用jQuery切换样式
    //Look for the media-type you wish to switch then set the href to your new style sheet  
    $('link[media='screen']').attr('href', 'Alternative.css');
** 5. 限制选择的区域
   //Where possible, pre-fix your class names with a tag name  
    //so that jQuery doesn't have to spend more time searching  
    //for the element you're after. Also remember that anything  
    //you can do to be more specific about where the element is  
    //on your page will cut down on execution/search times  
    var in_stock = $('#shopping_cart_items input.is_in_stock');

    <ul id="shopping_cart_items">  
    <li>  
    <input value="Item-X" name="item" class="is_in_stock" type="radio"> Item X</li>  
    <li>  
    <input value="Item-Y" name="item" class="3-5_days" type="radio"> Item Y</li>  
    <li>  
    <input value="Item-Z" name="item" class="unknown" type="radio"> Item Z</li>  
    </ul>
** 6. 如何正确使用ToggleClass
   //Toggle class allows you to add or remove a class  
    //from an element depending on the presence of that  
    //class. Where some developers would use:  
    a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');  
    //toggleClass allows you to easily do this using  
    a.toggleClass('blueButton');
** 7. 设置IE指定的功能
        if ($.browser.msie) { // Internet Explorer is a sadist. }
** 8. 使用jQuery来替换一个元素
       $('#thatdiv').replaceWith('fnuh');
** 9. 验证一个元素是否为空
       if ($('#keks').html()) { //Nothing found ;}
** 10. 在无序的set中查找一个元素的索引
          $("ul > li").click(function () {  
        var index = $(this).prevAll().length;  
    });
** 11. 绑定一个函数到一个事件
$('#foo').bind('click', function() {
  alert('User clicked on "foo."'); 
});
** 12. 添加HTML到一个元素
$('#lal').append('sometext');
** 13. 创建元素时使用对象来定义属性
var e = $("", { href: "#", class: "a-class another-class", title: "..." });
** 14. 使用过滤器过滤多属性
//This precision-based approached can be useful when you use  
//lots of similar input elements which have different types  
var elements = $('#someid input[type=sometype][value=somevalue]').get();
** 15. 使用jQuery预加载图片
jQuery.preloadImages = function() { for(var i = 0; i').attr('src', arguments[i]); } };  
// Usage $.preloadImages('image1.gif', '/path/to/image2.png', 'some/image3.jpg');
** 16. 设置任何匹配一个选择器的事件处理程序
    $('button.someClass').live('click', someFunction);
      //Note that in jQuery 1.4.2, the delegate and undelegate options have been
      //introduced to replace live as they offer better support for context
        //For example, in terms of a table where before you would use..
      // .live()
      $("table").each(function(){
        $("td", this).live("hover", function(){
        $(this).toggleClass("hover");
        });
      });
      //Now use..
      $("table").delegate("td", "hover", function(){
      $(this).toggleClass("hover");
    });
** 17. 找到被选择到的选项(option)元素
$('#someElement').find('option:selected');
** 18. 隐藏包含特定值的元素
$("p.value:contains('thetextvalue')").hide();
** 19. 自动的滚动到页面特定区域
    jQuery.fn.autoscroll = function(selector) {
      $('html,body').animate(
        {scrollTop: $(selector).offset().top},
        500
      );
    }
    //Then to scroll to the class/area you wish to get to like this:
    $('.area_name').autoscroll();
** 20. 检测各种浏览器
    Detect Safari (if( $.browser.safari)),
    Detect IE6 and over (if ($.browser.msie && $.browser.version > 6 )),
    Detect IE6 and below (if ($.browser.msie && $.browser.version <= 6 )),
    Detect FireFox 2 and above (if ($.browser.mozilla && $.browser.version >= '1.8' ))
** 21. 替换字符串中的单词
    var el = $('#id');
    el.html(el.html().replace(/word/ig, ''));
** 22. 关闭右键的菜单
 $(document).bind('contextmenu',function(e){ return false; });
** 23. 定义一个定制的选择器
    $.expr[':'].mycustomselector = function(element, index, meta, stack){
    // element- is a DOM element
    // index - the current loop index in stack
    // meta - meta data about your selector
    // stack - stack of all elements to loop
    // Return true to include current element
    // Return false to explude current element
    };
    // Custom Selector usage:
    $('.someClasses:test').doSomething();
** 24. 判断一个元素是否存在
if ($('#someDiv').length) {//hooray!!! it exists...}
** 25. 使用jQuery判断鼠标的左右键点击
    $("#someelement").live('click', function(e) {
        if( (!$.browser.msie && e.button == 0) || ($.browser.msie && e.button == 1) ) {
            alert("Left Mouse Button Clicked");
        }
        else if(e.button == 2)
            alert("Right Mouse Button Clicked");
    });
** 26. 显示或者删除输入框的缺省值
    //This snippet will show you how to keep a default value
    //in a text input field for when a user hasn't entered in
    //a value to replace it
    swap_val = [];
    $(".swap").each(function(i){
        swap_val[i] = $(this).val();
        $(this).focusin(function(){
            if ($(this).val() == swap_val[i]) {
                $(this).val("");
            }
        }).focusout(function(){
            if ($.trim($(this).val()) == "") {
                $(this).val(swap_val[i]);
            }
        });
    });
1
 <input class="swap" type="text" value="Enter Username here.." />
** 27. 指定时间后自动隐藏或者关闭元素(1.4支持）
    //Here's how we used to do it in 1.3.2 using setTimeout
    setTimeout(function() {
      $('.mydiv').hide('blind', {}, 500)
    }, 5000);
    //And here's how you can do it with 1.4 using the delay() feature (this is a lot like sleep)
    $(".mydiv").delay(5000).hide('blind', {}, 500);
** 28. 动态创建元素到DOM
    var newgbin1Div = $('');
    newgbin1Div.attr('id','gbin1.com').appendTo('body');
** 29. 限制textarea的字符数量
    jQuery.fn.maxLength = function(max){
      this.each(function(){
        var type = this.tagName.toLowerCase();
        var inputType = this.type? this.type.toLowerCase() : null;
        if(type == "input" && inputType == "text" || inputType == "password"){
          //Apply the standard maxLength
          this.maxLength = max;
        }
        else if(type == "textarea"){
          this.onkeypress = function(e){
            var ob = e || event;
            var keyCode = ob.keyCode;
            var hasSelection = document.selection? document.selection.createRange().text.length > 0 : this.selectionStart != this.selectionEnd;
            return !(this.value.length >= max && (keyCode > 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) && !ob.ctrlKey && !ob.altKey && !hasSelection);
          };
          this.onkeyup = function(){
            if(this.value.length > max){
              this.value = this.value.substring(0,max);
            }
          };
        }
      });
    };
    //Usage:
    $('#gbin1textarea').maxLength(500);
** 30. 为函数创建一个基本测试用例
    //Separate tests into modules.
    module("Module B");
    test("some other gbin1.com test", function() {
      //Specify how many assertions are expected to run within a test.
      expect(2);
      //A comparison assertion, equivalent to JUnit's assertEquals.
      equals( true, false, "failing test" );
      equals( true, true, "passing test" );
    });
** 31. 使用jQuery克隆元素
var cloned = $('#gbin1div').clone();
** 32. 测试一个元素在jQuery中是否可见
if($(element).is(':visible') == 'true') { //The element is Visible }
** 33. 元素屏幕居中
    jQuery.fn.center = function () {
      this.css('position','absolute');
      this.css('top', ( $(window).height() - this.height() ) / +$(window).scrollTop() + 'px');
      this.css('left', ( $(window).width() - this.width() ) / 2+$(window).scrollLeft() + 'px');return this;
    }
    //Use the above function as: $('#gbin1div').center();
34. 使用特定名字的元素对应的值生成一个数组

1
2
3
4
    var arrInputValues = new Array();
    $("input[name='table[]']").each(function(){
         arrInputValues.push($(this).val());
    });
35. 剔除元素中的HTML

1
2
3
4
5
6
7
8
9
10
11
12
13
    (function($) {
        $.fn.stripHtml = function() {
            var regexp = /<("[^"]*"|'[^']*'|[^'">])*>/gi;
            this.each(function() {
                $(this).html(
                    $(this).html().replace(regexp,"")
                );
            });
            return $(this);
        }
    })(jQuery);
    //usage:
    $('p').stripHtml();
36. 使用closest来得到父元素

1
$('#searchBox').closest('div');
37. 使用firebug来记录jQuery事件

1
2
3
4
5
6
7
8
    // Allows chainable logging
    // Usage: $('#someDiv').hide().log('div hidden').addClass('someClass');
    jQuery.log = jQuery.fn.log = function (msg) {
          if (console){
             console.log("%s: %o", msg, this);
          }
          return this;
    };
38. 点击链接强制弹出新窗口

1
2
3
4
5
    jQuery('a.popup').live('click', function(){
      newwindow=window.open($(this).attr('href'),'','height=200,width=150');
      if (window.focus) {newwindow.focus()}
      return false;
    });
39. 点击链接强制打开新标签页

1
2
3
4
5
    jQuery('a.newTab').live('click', function(){
      newwindow=window.open($(this).href);
      jQuery(this).target = "_blank";
      return false;
    });
40. 使用siblings()来处理同类元素

1
2
3
4
5
6
7
8
9
    // Rather than doing this
    $('#nav li').click(function(){
        $('#nav li').removeClass('active');
        $(this).addClass('active');
    });
    // Do this instead
    $('#nav li').click(function(){
        $(this).addClass('active').siblings().removeClass('active');
    });
41. 选择或者不选页面上全部复选框

1
2
3
4
5
    var tog = false; // or true if they are checked on load
    $('a').click(function() {
        $("input[type=checkbox]").attr("checked",!tog);
        tog = !tog;
    });
42. 基于输入文字过滤页面元素

1
2
3
4
5
    //If the value of the element matches that of the entered text
    //it will be returned
    $('.gbin1Class').filter(function() {
        return $(this).attr('value') == $('input#gbin1Id').val() ;
     })
43. 取得鼠标的X和Y坐标

1
2
3
4
5
6
    $(document).mousemove(function(e){
    $(document).ready(function() {
    $().mousemove(function(e){
    $('#XY').html("Gbin1 X Axis : " + e.pageX + " | Gbin1 Y Axis " + e.pageY);
    });
    });
44. 使得整个列表元素(LI)可点击

1
2
3
    $("ul li").click(function(){
      window.location=$(this).find("a").attr("href"); return false;
    });
GBin1 Link 1
 

GBin1 Link 2
 

 

GBin1 Link 3
 

 

GBin1 Link 4
 

 

45. 使用jQuery来解析XML

1
2
3
4
5
6
7
    function parseXml(xml) {
      //find every Tutorial and print the author
      $(xml).find("Tutorial").each(function()
      {
      $("#output").append($(this).attr("author") + "");
      });
    }
46. 判断一个图片是否加载完全

1
2
3
    $('#theGBin1Image').attr('src', 'image.jpg').load(function() {
    alert('This Image Has Been Loaded');
    });
47. 使用jQuery命名事件

1
2
3
4
5
6
    //Events can be namespaced like this
    $('input').bind('blur.validation', function(e){
        // ...
    });
    //The data method also accept namespaces
    $('input').data('validation.isValid', true);
48. 判断cookie是否激活或者关闭

1
2
3
4
5
6
7
8
    var dt = new Date();
    dt.setSeconds(dt.getSeconds() + 60);
    document.cookie = "cookietest=1; expires=" + dt.toGMTString();
    var cookiesEnabled = document.cookie.indexOf("cookietest=") != -1;
    if(!cookiesEnabled)
    {
      //cookies have not been enabled
    }
49. 强制过期cookie

1
2
3
    var date = new Date();
    date.setTime(date.getTime() + (x * 60 * 1000));
    $.cookie('example', 'foo', { expires: date });
50. 使用一个可点击的链接替换页面中所有URL

1
2
3
4
5
6
7
8
9
10
11
$.fn.replaceUrl = function() {
        var regexp = /((ftp|http|https)://(w+:{0,1}w*@)?(S+)(:[0-9]+)?(/|/([w#!:.?+=&%@!-/]))?)/gi;
        this.each(function() {
            $(this).html(
                $(this).html().replace(regexp,'<a href="$1">$1</a>')
            );
        });
        return $(this);
    }
//usage
$('#GBin1div').replaceUrl();
51: 在表单中禁用“回车键”

大家可能在表单的操作中需要防止用户意外的提交表单，那么下面这段代码肯定非常有帮助：

1
2
3
4
5
    $("#form").keypress(function(e) {
      if (e.which == 13) {
        return false;
      }
    });
52: 清除所有的表单数据

可能针对不同的表单形式，你需要调用不同类型的清楚方法，不过使用下面这个现成方法，绝对能让你省不少功夫。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
    function clearForm(form) {
      // iterate over all of the inputs for the form
      // element that was passed in
      $(':input', form).each(function() {
        var type = this.type;
        var tag = this.tagName.toLowerCase(); // normalize case
        // it's ok to reset the value attr of text inputs,
        // password inputs, and textareas
        if (type == 'text' || type == 'password' || tag == 'textarea')
          this.value = "";
        // checkboxes and radios need to have their checked state cleared
        // but should *not* have their 'value' changed
        else if (type == 'checkbox' || type == 'radio')
          this.checked = false;
        // select elements need to have their 'selectedIndex' property set to -1
        // (this works for both single and multiple select elements)
        else if (tag == 'select')
          this.selectedIndex = -1;
      });
    };
53: 将表单中的按钮禁用

下面的代码对于ajax操作非常有用，你可以有效的避免用户多次提交数据，个人也经常使用：

1
 $("#somebutton").attr("disabled", true);//禁用按钮
1
    $("#submit-button").removeAttr("disabled");//启动按钮
可能大家往往会使用.attr(‘disabled’,false);，不过这是不正确的调用。

54: 输入内容后启用递交按钮
这个代码和上面类似，都属于帮助用户控制表单递交按钮。使用这段代码后，递交按钮只有在用户输入指定内容后才可以启动。

1
2
3
    $('#username').keyup(function() {
        $('#submit').attr('disabled', !$('#username').val()); 
    });
55: 禁止多次递交表单
多次递交表单对于web应用来说是个比较头疼的问题，下面的代码能够很好的帮助你解决这个问题：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
    $(document).ready(function() {
      $('form').submit(function() {
        if(typeof jQuery.data(this, "disabledOnSubmit") == 'undefined') {
          jQuery.data(this, "disabledOnSubmit", { submited: true });
          $('input[type=submit], input[type=button]', this).each(function() {
            $(this).attr("disabled", "disabled");
          });
          return true;
        }
        else
        {
          return false;
        }
      });
    });
56: 高亮显示目前聚焦的输入框标示
有时候你需要提示用户目前操作的输入框，你可以使用下面代码高亮显示标示：

1
2
3
4
5
    $("form :input").focus(function() {
      $("label[for='" + this.id + "']").addClass("labelfocus");
    }).blur(function() {
      $("label").removeClass("labelfocus");
    });
57: 动态方式添加表单元素
这个方法可以帮助你动态的添加表单中的元素，比如，input等：

1
2
3
4
5
    //change event on password1 field to prompt new input
    $('#password1').change(function() {
            //dynamically create new input and insert after password1
            $("#password1").append("<input id="password2" name="password2" type="text" />");
    });
58: 自动将数据导入selectbox中

下面代码能够使用ajax数据自动生成选择框的内容

1
2
3
4
5
6
7
8
9
10
11
    $(function(){
      $("select#ctlJob").change(function(){
        $.getJSON("/select.php",{id: $(this).val(), ajax: 'true'}, function(j){
          var options = '';
          for (var i = 0; i < j.length; i++) {
            options += '' + j[i].optionDisplay + '';
          }
          $("select#ctlPerson").html(options);
        })
      })
    })
59: 判断一个复选框是否被选中

1
$('#checkBox').attr('checked');
60: 使用代码来递交表单

1
$("#myform").submit();
希望大家觉得这些jQuery代码会对你的开发有帮助，如果你也有类似的jQuery代码或者jQuery插件，欢迎一起分享！

注：部分代码原文应该是英文的。但是看见转的几个链接已经打不开了。所以就这样吧。
* web移动开发最佳实践
** 避免使用全局变量和函数
 var myApp = {
     lang: "en",
     debug: true,
 };
 
 myApp.setLang = function (arg) {
     this.lang = arg;
 }
** 高效的使用try catch语句
  var object = ['foo', 'bar'], i;
 try {
     for (i = 0; i < object.length; i++) {
         // do something
     }
 } catch (e) {
     // handle exception
 }
** 使用赋值运算来连接字符串
 str += "x";
 str += "y";
** 避免使用eval()方法
** 使用事件委托
   在处理DOM事件的时候，你可以仅对一个父元素绑定一个事件而不是每一个子元素。
   这种技术即事件委托，它利用事件冒泡来分配事件处理程序，可以提高脚本的性能

   <a href="javascript:handleClick();">Click</a>
   <button id="btn1" onclick="handleClick();">One</button>
   <button id="btn2" onclick="handleClick();">Two</button>
 为了提高代码的性能，我们可以加一个div父元素，事件会向上冒泡，直到被处理。事件对象是触发事件的元素，我们可以根据它的id属性来判断是哪一个元素触发了事件：
 

 <div id="btngroup">
   <button id="btn1">One</button>
   <button id="btn2">Two</button>
 </div>
 document.getElementById("btngroup").addEventListener("click", function (event) {
   switch (event.srcElement.id) {　　//firefox 下为 event.target.id
   case "btn1":
     handleClick();
     break;
   default:
     handleClick();
   }
 }, false); // type, listener, useCapture (true=beginning, false=end)
** 尽量减少DOM操作
 　　DOM是一个包含了很多信息的复杂的API，因此即使是很小的操作可能会花费较长的时间执行（如果要重绘页面的话）。为了提高程序性能，应尽量减少DOM操作，这里有一些建议：
***  1.减少DOM的数目

 DOM节点的数目会影响与它相关的所有操作，要尽量使DOM树小一些：

 避免多余的标记和嵌套的表格
 元素数尽量控制在500个以内（document.getElementsByTagName('*').length）
*** 2.缓存已经访问过的节点
 当访问过一个DOM元素后，就应该把它缓存起来，因为你的程序往往要重复访问某个对象的，例如：

 for (var i = 0; i < document.images.length; i++) {
     document.images[i].src = "blank.gif";
 }
 以上例子中，docum.images对象被访问了多次，这并不高效，因为每一次循环中，浏览器都要查找这个元素两次：第一次读取它的长度，第二次改变相应的src值。更好的做法是先把这个对象存储起来：

 var imgs = document.images;
 for (var i = 0; i < imgs.length; i++) {　　//当然也可以把 imgs.length 提前算出来，这里不是重点
     imgs[i].src = "blank.gif";
 }
** 减少页面重绘
 　　在控制DOM元素数目的同时，你还可以通过减少修改元素（减少页面的重绘）的方法来提高性能。重绘有两种方式：repaint、reflow。

 1.repaint，也叫redraw，即改变了元素的视觉效果，但是不影响它的排版（比如改变背景颜色）
 2.reflow，会影响部分或者全部页面的排版，浏览器不仅要计算该元素的位置，还要计算它影响到的周围的元素位置

 当你要改变页面布局的时候，reflow就发生了，主要有如下情况：

 增加或删除DOM节点
 改变元素的位置
 改变元素的尺寸（如margin，padding，border，font，width，height等）
 调整浏览器窗口的尺寸
 增加或删除css
 改变内容（如用户输入表单）
 命中css选择器（如hover）
 更改了class属性
 利用脚本更改了DOM
 检索一个必须被计算的尺寸（如offsetWidth，offsetHeight）
 设置了一个css属性
 这里有一些减少页面重绘的建议：

 css的建议：

 改变class属性时应尽量少的影响到周围的元素节点
 避免声明多个内联的样式（把多个样式放在一个外部文件里）
 有动画的元素使用绝对定位，这样不会影响其他元素
 避免使用table来排版，如果需要使用保存数据，那么要固定排版（table-layout:fixed）
 js的建议：

 缓存计算过的样式
 对于固定的样式，改变class的名词而不是样式；对于动态的样式，改变cssText属性：

 // bad - changing the stle - accessing DOM multiple times
 var myElement = document.getElementById('mydiv');
 myElement.style.borderLeft = '2px';
 myElement.style.borderRight = '3px';
 myElement.style.padding = '5px';
 
 // good - use cssText and modify DOM once
 var myElement = document.getElementById('mydiv');
 myElement.style.cssText = 'border-left: 2px; border-right: 3px; padding: 5px;';

 当你要对一个DOM元素做出很多修改时，可以先进行一些‘预处理’，批量修改后再替换原始的元素
 创建一个副本（cloneNode()），对这个副本进行更新，然后替代原来的节点

 // slower - multiple reflows
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster - create a copy
 var orig = document.getElementById('container'),
     clone = orig.cloneNode(true), // create a copy
     list = ['foo', 'bar', 'baz'], elem, contents;
 clone.setAttribute('width', '50%');

 修改一个不可见的元素，可以先让其不可见（display:none），修改完成后，再恢复其可见（display:block），这样就会减少reflow的次数

 // slower
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.appendChild(subElem);
 elem.style.width = '320px';
             
 // faster
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.style.display = 'none'; // will not be repainted
 elem.appendChild(subElem);
 elem.style.width = '320px';
 elem.style.display = 'block';

 创建一个文档片段（使用DocumentFragment()），修改完成后，再把它追加到原始文档中

 // slower
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster
 var fragment = document.createDocumentFragment(),
     list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     fragment.appendChild(content);
 }
 document.body.appendChild(fragment); // one reflow

* echarts
  http://echarts.baidu.com/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts
** 安装
   前端模块加载 <script src="echarts.js"></script>
   CDN库  <script src="http://echarts.baidu.com/build/dist/echarts.js"></script>
   npm install echarts
** 步骤 
***  引入 ECharts
***  制作一个图表容器 <div id="main" style="height:400px;"></div>
*** echarts.init 方法初始化一个 echarts 实例
*** setOption方法生成一个简单的柱状图
*** 代码
    #+BEGIN_SRC html
          <!DOCTYPE html>
      <html>
      <head>
          <meta charset="utf-8">
          <title>ECharts</title>
          <!-- 引入 echarts.js -->
          <script src="echarts.min.js"></script>
      </head>
      <body>
          <!-- 为ECharts准备一个具备大小（宽高）的Dom -->
          <div id="main" style="width: 600px;height:400px;"></div>
          <script type="text/javascript">
              // 基于准备好的dom，初始化echarts实例
              var myChart = echarts.init(document.getElementById('main'));

              // 指定图表的配置项和数据
              var option = {
                  title: {
                      text: 'ECharts 入门示例'
                  },
                  tooltip: {},
                  legend: {
                      data:['销量']
                  },
                  xAxis: {
                      data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
                  },
                  yAxis: {},
                  series: [{
                      name: '销量',
                      type: 'bar',
                      data: [5, 20, 36, 10, 10, 20]
                  }]
              };

              // 使用刚指定的配置项和数据显示图表。
              myChart.setOption(option);
          </script>
      </body>
      </html>
    #+END_SRC
** 阴影的配置
   ECharts 中有一些通用的样式，诸如阴影、透明度、颜色、边框颜色、边框宽度等，这些样
   式一般都会在系列的 itemStyle 里设置。例如阴影的样式可以通过下面几个配置项设置：

   #+begin_src js
        itemStyle: {
        normal: {
             // 阴影的大小
             shadowBlur: 200,
             // 阴影水平方向上的偏移
             shadowOffsetX: 0,
             // 阴影垂直方向上的偏移
             shadowOffsetY: 0,
             // 阴影颜色
             shadowColor: 'rgba(0, 0, 0, 0.5)'
         }
     }
   #+end_src
** 异步数据加载和更新
   ECharts 中实现异步数据的更新非常简单，在图表初始化后不管任何时候只要通过
   jQuery 等工具异步获取数据后通过 setOption 填入数据和配置项就行。
   
#+BEGIN_SRC javascript
var myChart = echarts.init(document.getElementById('main'));

$.get('data.json').done(function (data) {
    myChart.setOption({
        title: {
            text: '异步数据加载示例'
        },
        tooltip: {},
        legend: {
            data:['销量']
        },
        xAxis: {
            data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
        },
        yAxis: {},
        series: [{
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
        }]
    });
});
#+END_SRC
或者先设置完其它的样式，显示一个空的直角坐标轴，然后获取数据后填入数据。
#+BEGIN_SRC javascript
var myChart = echarts.init(document.getElementById('main'));
// 显示标题，图例和空的坐标轴
myChart.setOption({
    title: {
        text: '异步数据加载示例'
    },
    tooltip: {},
    legend: {
        data:['销量']
    },
    xAxis: {
        data: []
    },
    yAxis: {},
    series: [{
        name: '销量',
        type: 'bar',
        data: []
    }]
});

// 异步加载数据
$.get('data.json').done(function (data) {
    // 填入数据
    myChart.setOption({
        xAxis: {
            data: data.categories
        },
        series: [{
            // 根据名字对应到相应的系列
            name: '销量',
            data: data.data
        }]
    });
});

#+END_SRC
** loading 动画
   #+begin_src js
        myChart.showLoading();

        $.get('data.json').done(function (data) {
         myChart.hideLoading();
         myChart.setOption(...);
     });
   #+end_src
** 数据的动态更新
   #+BEGIN_SRC javascript
   var base = +new Date(2014, 9, 3);
var oneDay = 24 * 3600 * 1000;
var date = [];

var data = [Math.random() * 150];
var now = new Date(base);

function addData(shift) {
    now = [now.getFullYear(), now.getMonth() + 1, now.getDate()].join('-');
    date.push(now);
    data.push((Math.random() - 0.4) * 10 + data[data.length - 1]);
    if (shift) {
        date.shift();
        data.shift();
    }
    now = new Date(Date.parse(now) + 24 * 3600 * 1000);
}

for (var i = 1; i < 100; i++) {
    addData();
}

option = {
    xAxis: {
        type: 'category',
        boundaryGap: false,
        data: date
    },
    yAxis: {
        boundaryGap: [0, '50%'],
        type: 'value'
    },
    series: [
        {
            name:'成交',
            type:'line',
            smooth:true,
            symbol: 'none',
            stack: 'a',
            areaStyle: {
                normal: {}
            },
            data: data
        }
    ]
};

app.timeTicket = setInterval(function () {
    addData(true);
    myChart.setOption({
        xAxis: {
            data: date
        },
        series: [{
            name:'成交',
            data: data
        }]
    });
}, 500);
   #+END_SRC

