* git
** Git 工作流程
  * 克隆 Git 资源作为工作目录。
  * 在克隆的资源上添加或修改文件。
  * 如果其他人修改了，你可以更新资源。pull/push
  * 在提交前查看修改。
  * 提交修改。
  * 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交,commit/checkout
** 配置
git config [--system,--global]
/etc/gitconfig | ~/.gitconfig
user.name = "用户名或者用户ID"
user.email = "邮箱"
ssh-keygen -C 'you email address@gmail.com' -t rsa
: 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
: 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
*** 上传公钥
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。
** 管理 工作区、暂存区和版本库
*** 创建一个版本库
git init <directory>
git clone git://git.kernel.org/pub/scm/git/git.git <directory>
git remote add origin git@github.com:hanyudeye/os.git
git push origin master
git push -u origin master
*** git tag
*** git branch
*** git checkout
*** 将修改存入暂存区
git add <modified files>/git add .
*** 暂存区删除文件
git rm --cached <file>
*** 删除工作区和暂存区文件
git rm <file>
*** 取消已缓存的内容
git reset HEAD
*** 暂存区全部或指定的文件替换工作区的文件。这个操作很危险
git checkout .
git checkout -- <file>
*** 重命名
git mv 命令做得所有事情就是 git rm --cached 命令的操作，重命
名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。
*** 用 HEAD 指向的 master 分支中的全部或者部分文件替换
git checkout HEAD .
git checkout HEAD <file>
*** 提交到版本库中
git commit -m "msg"
也可以将git add与git commit用一个指令完成
git commit -a -m "msg"
*** 远程同步
git push
*** 更新本地端的repo
git pull/git pull git://github.com/tom/test.git
*** 查看状态
git status
git status -s 简短信息
git remote -v 列出服务器地址
git diff   尚未缓存的改动：
git diff --cached   查看已缓存的改动：
git diff HEAD  查看已缓存的与未缓存的所有改动：
git diff --stat   显示摘要而非整个diff
 A: 你本地新增的文件（服务器上没有）.
C: 文件的一个新拷贝.
D: 你本地删除的文件（服务器上还在）.
M: 文件的内容或者mode被修改了.
R: 文件名被修改了。
T: 文件的类型被修改了。
U: 文件没有被合并(你需要完成合并才能进行提交)。
X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。
在man git diff-files中可以查到这些标志的说明
** Git 分支管理
*** 创建分支命令：
git branch (branchname)
*** 切换分支命令:
git checkout (branchname)
当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工
作目录的内容，所以多个分支不需要多个目录。
*** 合并分支命令:
git merge 
*** 列出分支基本命令：
git branch
*** 创建新分支并立即切换到该分支下，从而在该分支中操作
git checkout -b (newbranchname)
*** 删除分支命令：
git branch -d (branchname)
*** 把bug_fix这个branch和现在的branch合并
git merge bug_fix 
*** Git 查看提交历史
git log
git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
 --author 指定用户日志
如果你要指定日期，可以执行几个选项：--since 和 --before，但
是你也可以用 --until 和 --after。
git show 可以看某次的变更
*** 查看远程分支
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local
** .gitignore
*** 配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；

A Git Porcelain inside Emacs

Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains. (less)

Staging and otherwise applying changes is one of the most important features in a Git porcelain and here Magit outshines anything else, including Git itself. Git’s own staging interface (git add --patch) is so cumbersome that many users only use it in exceptional cases. In Magit staging a hunk or even just part of a hunk is as trivial as staging all changes made to a file.

The most visible part of Magit’s interface is the status buffer, which displays information about the current repository. Its content is created by running several Git commands and making their output actionable. Among other things, it displays information about the current branch, lists unpulled and unpushed changes and contains sections displaying the staged and unstaged changes. That might sound noisy, but, since sections are collapsible, it’s not.

To stage or unstage a change one places the cursor on the change and then types s or u. The change can be a file or a hunk, or when the region is active (i.e. when there is a selection) several files or hunks, or even just part of a hunk. The change or changes that these commands - and many others - would act on are highlighted.

Magit also implements several other “apply variants” in addition to staging and unstaging. One can discard or reverse a change, or apply it to the working tree. Git’s own porcelain only supports this for staging and unstaging and you would have to do something like git diff ... | ??? | git apply ... to discard, revert, or apply a single hunk on the command line. In fact that’s exactly what Magit does internally (which is what lead to the term “apply variants”).

Magit isn’t just for Git experts, but it does assume some prior experience with Git as well as Emacs. That being said, many users have reported that using Magit was what finally taught them what Git it is capable off and how to use it to its fullest. Other users wished they had switched to Emacs sooner so that they would have gotten their hands on Magit earlier.

While one has to know the basic features of Emacs to be able to make full use of Magit, acquiring just enough Emacs skills doesn’t take long and is worth it, even for users who prefer other editors. Vim users are advised to give Evil the “Extensible VI Layer for Emacs”, and Spacemacs an “Emacs starter-kit focused on Evil” a try.

Magit provides a consistent and efficient Git porcelain. After a short learning period, you will be able to perform most of your daily version control tasks faster than you would on the command line. You will likely also start using features that seemed too daunting in the past.

Magit fully embraces Git. It exposes many advanced features using a simple but flexible interface instead of only wrapping the trivial ones like many GUI clients do. Of course Magit supports logging, cloning, pushing, and other commands that usually don’t fail in spectacular ways; but it also supports tasks that often cannot be completed in a single step. Magit fully supports tasks such as merging, rebasing, cherry-picking, reverting, and blaming by not only providing a command to initiate these tasks but also by displaying context sensitive information along the way and providing commands that are useful for resolving conflicts and resuming the sequence after doing so.

Magit wraps and in many cases improves upon at least the following Git porcelain commands: add, am, bisect, blame, branch, checkout, cherry, cherry-pick, clean, clone, commit, config, describe, diff, fetch, format-patch, init, log, merge, merge-tree, mv, notes, pull, rebase, reflog, remote, request-pull, reset, revert, rm, show, stash, submodule, and tag. Many more Magit porcelain commands are implemented on top of Git plumbing commands.
* magit

 - [[#install][Install]]
   - [[#layer][Layer]]
   - [[#magit-status-fullscreen][Magit status fullscreen]]
   - [[#magit-auto-complete][Magit auto-complete]]
   - [[#magit-svn-plugin][Magit SVN plugin]]
   - [[#global-git-commit-mode][Global git commit mode]]
   - [[#git][Git]]
   - [[#git-flow][Git-Flow]]
   - [[#org-integration][Org integration]]
 - [[#working-with-git][Working with Git]]
   - [[#magit][Magit]]
   - [[#staging-lines][Staging lines]]
   - [[#commit-message-editing-buffer][Commit message editing buffer]]
   - [[#interactive-rebase-buffer][Interactive rebase buffer]]
   - [[#quick-guide-for-recurring-use-cases-in-magit][Quick guide for recurring use cases in Magit]]
   - [[#git-flow-1][Git-Flow]]
   - [[#git-time-machine][Git time machine]]
   - [[#git-links-to-web-services][Git links to web services]]

* Description
This layers adds extensive support for [[http://git-scm.com/][git]].

** Features:
- git repository management the indispensable [[http://magit.vc/][magit]] package
- [[https://github.com/jtatarik/magit-gitflow][git-flow]] add-on for magit.
- quick in buffer history browsing with [[https://github.com/pidu/git-timemachine][git-timemachine]].
- quick in buffer last commit message per line with [[https://github.com/syohex/emacs-git-messenger][git-messenger]]
- colorize buffer line by age of commit with [[https://github.com/syohex/emacs-smeargle][smeargle]]
- gitignore generator with [[https://github.com/jupl/helm-gitignore][helm-gitignore]]
- org integration with magit via [[https://github.com/magit/orgit][orgit]]

New to Magit? Checkout the [[https://magit.vc/about/][official intro]].

* Install
** Layer
To use this configuration layer, add it to your =~/.spacemacs=. You will need to
add =git= to the existing =dotspacemacs-configuration-layers= list in this
file.

** Magit status fullscreen
To display the =magit status= buffer in fullscreen set the variable
=git-magit-status-fullscreen= to =t= in your =dotspacemacs/user-init= function.

#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-magit-status-fullscreen t))
#+END_SRC

** Magit auto-complete
Magit auto-complete feature is enabled. For this feature to work best you
have to setup your Git repository directory in your =dotspacemacs/user-config=
function, this is the folder where you keep all your git-controlled projects
(the path should end up with a ~/~ to respect Emacs conventions):

#+BEGIN_SRC emacs-lisp
  (setq magit-repository-directories '("~/repos/"))
#+END_SRC

For more information, see [[http://magit.vc/manual/magit.html#Status-buffer][Magit-User-Manual#Status-buffer]]

** Magit SVN plugin
For convenience the magit SVN plugin can be activated directly in the Git
layer by setting the variable =git-enable-magit-svn-plugin= to =t=.

#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-enable-magit-svn-plugin t))
#+END_SRC

** Global git commit mode
Spacemacs can be used as the =$EDITOR= (or =$GIT_EDITOR=) for editing git
commits messages. To enable this you have to add the following line to your
=dotspacemacs/user-config=:

#+begin_src emacs-lisp
(global-git-commit-mode t)
#+end_src

** Git
Of course if your OS does not ship with git (!) you'll have to install it
on your machine. You can download it from the [[http://git-scm.com/downloads][download page]].

** Git-Flow
Git-flow is a standardized branching pattern for git repositories with the aim
of making things more manageable. While there are tools to assist with making
this easier, these do nothing you couldn't do manually.

Support requires installation of the git-flow extensions. Please reference their
[[https://github.com/petervanderdoes/gitflow/wiki][installation page]] for assistance.

** Org integration

See the commentary section of the package [[https://github.com/magit/orgit/blob/master/orgit.el#L28][here]].

* Working with Git
Git commands (start with ~g~):

| Key Binding | Description                                         |
|-------------+-----------------------------------------------------|
| ~SPC g >~   | show submodule prompt                               |
| ~SPC g b~   | open a =magit= blame                                |
| ~SPC g f h~ | show file commits history                           |
| ~SPC g H c~ | clear highlights                                    |
| ~SPC g H h~ | highlight regions by age of commits                 |
| ~SPC g H t~ | highlight regions by last updated time              |
| ~SPC g I~   | open =helm-gitignore=                               |
| ~SPC g s~   | open a =magit= status window                        |
| ~SPC g S~   | stage current file                                  |
| ~SPC g m~   | magit dispatch popup                                |
| ~SPC g M~   | display the last commit message of the current line |
| ~SPC g t~   | launch the git time machine                         |
| ~SPC g U~   | unstage current file                                |

- Highlight by age of commit or last update time is provided by
 [[https://github.com/syohex/emacs-smeargle][smeargle]].
- Git time machine is provided by [[https://github.com/pidu/git-timemachine][git-timemachine]].
- Git last commit message per line is provided by [[https://github.com/syohex/emacs-git-messenger][git-messenger]].

** Magit
Spacemacs uses [[http://magit.vc/][magit]] to manage Git repositories.

To open a =status buffer=, type in a buffer of a Git repository: ~SPC g s~.
The central key binding hub of Magit is available on ~SPC g m~.

Spacemacs uses [[https://github.com/justbur/evil-magit][evil-magit]] for key bindings in magit buffers (unless your editing
style is set to emacs, in which case you get the default magit bindings), which
are the standard magit key bindings with some minimal changes to make them
comfortable for evil users.

Here are the often used bindings inside a =status buffer=:

| Key Binding | Description                                                         |
|-------------+---------------------------------------------------------------------|
| ~/~         | evil-search                                                         |
| ~$~         | open =command output buffer=                                        |
| ~c c~       | open a =commit message buffer=                                      |
| ~b b~       | checkout a branch                                                   |
| ~b c~       | create a branch                                                     |
| ~f f~       | fetch changes                                                       |
| ~F (r) u~   | pull tracked branch and rebase                                      |
| ~gr~        | refresh                                                             |
| ~j~         | goto next magit section                                             |
| ~C-j~       | next visual line                                                    |
| ~k~         | goto previous magit section                                         |
| ~C-k~       | previous visual line                                                |
| ~l l~       | open =log buffer=                                                   |
| ~n~         | next search occurrence                                              |
| ~N~         | previous search occurrence                                          |
| ~o~         | revert item at point                                                |
| ~P u~       | push to tracked branch                                              |
| ~P m~       | push to matching branch  (e.g., upstream/develop to origin/develop) |
| ~q~         | quit                                                                |
| ~s~         | on a file or hunk in a diff: stage the file or hunk                 |
| ~x~         | discard changes                                                     |
| ~+~         | on a hunk: increase hunk size                                       |
| ~-~         | on a hunk: decrease hunk size                                       |
| ~S~         | stage all                                                           |
| ~TAB~       | on a file: expand/collapse diff                                     |
| ~u~         | on a staged file: unstage                                           |
| ~U~         | unstage all staged files                                            |
| ~v or V~    | select multiple lines                                               |
| ~z z~       | stash changes                                                       |

** Staging lines
Magit allows you to stage specific lines by selecting them in a diff and hitting
=s= to stage. Due to inconsistencies between Vim and Emacs editing styles, if
you enter visual line state with =V=, you will stage one more line than
intended. To work around this, you can use =v= instead (since Magit only stages
whole lines, in any case).

** Commit message editing buffer
In a commit message buffer press ~​,​c~ (if =dotspacemacs-major-mode-leader-key= is ~​,​~)
or ~C-c C-c~ to commit the changes with the entered message. Pressing ~​,​a~ or ~C-c C-k~
will discard the commit message.

| Key Binding | Description |
|-------------+-------------|
| ~h~         | go left     |
| ~j~         | go down     |
| ~k~         | go up       |
| ~l~         | go right    |

** Interactive rebase buffer

| Key Binding | Description    |
|-------------+----------------|
| ~c~ or ~p~  | pick           |
| ~e~         | edit           |
| ~f~         | fixup          |
| ~j~         | go down        |
| ~M-j~       | move line down |
| ~k~         | go up          |
| ~M-k~       | move line up   |
| ~d~ or ~x~  | kill line      |
| ~r~         | reword         |
| ~s~         | squash         |
| ~u~         | undo           |
| ~y~         | insert         |
| ~!~         | execute        |

** Quick guide for recurring use cases in Magit
- Amend a commit:
  - ~l l~ to open =log buffer=
  - ~c a~ on the commit you want to amend
  - ~​,​c~ or ~C-c C-c~ to submit the changes
- Squash last commit:
  - ~l l~ to open =log buffer=
  - ~r e~ on the second to last commit, it opens the =rebase buffer=
  - ~j~ to put point on last commit
  - ~s~ to squash it
  - ~​,​c~ or ~C-c C-c~ to continue to the =commit message buffer=
  - ~​,​c~ or ~C-c C-c~ again when you have finished to edit the commit message
- Force push a squashed commit:
  - in the =status buffer= you should see the new commit unpushed and the old
    commit unpulled
  - ~P -f P~ for force a push (*beware* usually it is not recommended to rewrite
    the history of a public repository, but if you are *sure* that you are the
    only one to work on a repository it is ok - i.e. in your fork).
- Add upstream remote (the parent repository you have forked):
  - ~M~ to open the =remote popup=
  - ~a~ to add a remote, type the name (i.e. =upstream=) and the URL
- Pull changes from upstream (the parent repository you have forked) and push:
  - ~F -r C-u F~ and choose =upstream= or the name you gave to it
  - ~P P~ to push the commit to =origin=

** Git-Flow
[[https://github.com/jtatarik/magit-gitflow][magit-gitflow]] provides git-flow commands in its own magit menu.

| Key Binding | Description             |
|-------------+-------------------------|
| ~%~         | open magit-gitflow menu |

** Git time machine
[[https://github.com/pidu/git-timemachine][git-timemachine]] allows to quickly browse the commits of the current buffer.

| Key Binding | Description                                        |
|-------------+----------------------------------------------------|
| ~SPC g t~   | start git timemachine and initiate transient-state |
| ~c~         | show current commit                                |
| ~n~         | show next commit                                   |
| ~N~         | show previous commit                               |
| ~p~         | show previous commit                               |
| ~q~         | leave transient-state and git timemachine          |
| ~Y~         | copy current commit hash                           |

** Git links to web services
These key bindings allow to quickly construct URLs pointing to a given commit
or lines in a file hosted on Git web services like GitHub, GitLab, Bitbucket...

| Key Binding | Description                                                            |
|-------------+------------------------------------------------------------------------|
| ~SPC g l c~ | on a commit hash, browse to the current file at this commit            |
| ~SPC g l C~ | on a commit hash, create link to the file at this commit and copy it   |
| ~SPC g l l~ | on a region, browse to file at current lines position                  |
| ~SPC g l L~ | on a region, create a link to the file highlighting the selected lines |

*Notes:*
- You can use the universal argument ~SPC u~ to select a remote repository.
- When the link is opened, the URL is also copied in the kill ring, you can
  override this behavior by setting the variable =git-link-open-in-browser= to
  =nil=.
