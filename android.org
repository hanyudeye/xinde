* Android
** 架构 linux内核层，系统运行库层，应用框架层，应用层
** 四大组件
  活动 Activity 
  服务 Service
  广播接收器 Broadcast receiver
  内容提供器 Content provider
** 设置开发环境
*** 1.JDK
    前提
*** 2.SDK
    下载SDK
#+BEGIN_SRC 
for Linux 64bit的版本: http://developer.android.com/sdk/index.html?hl=sk#download
wget http://dl.google.com/android/android-sdk_r23.0.2-linux.tgz  
下载后，解压到本地目录，比如/opt/目录下， 然后设置环境变量，添加三行到~/.bashrc文件
 
#+END_SRC
配置PATH
#+BEGIN_SRC 
   export ANDROID_HOME=/opt/android-sdk-linux  
    PATH=$PATH:/opt/android-sdk-linux/tools  
    PATH=$PATH:/opt/android-sdk-linux/platform-tools  
#+END_SRC
更新
#+BEGIN_SRC 
    运行Android SDK Manager
    运行android命令，将会弹出SDK Manager对话框，从中选择需要的package进行安装
    google API 是针对google 应用的接口, 可以选装 
#+END_SRC
配置模拟设备
#+BEGIN_SRC 
    android avd  
#+END_SRC
*** 创建工程
**** 显示target
     $ android list target  
#+BEGIN_SRC 
      id: 4 or "Google Inc.:Google APIs x86:19"  
       Name: Google APIs x86  
       Type: Add-On  
       Vendor: Google Inc.  
       Revision: 4  
       Description: Android + Google APIs x86  
       Based on Android 4.4.2 (API level 19)  
       Libraries:  
       * com.google.android.media.effects (effects.jar)  
         Collection of video effects  
       * com.android.future.usb.accessory (usb.jar)  
         API for USB Accessories  
       * com.google.android.maps (maps.jar)  
         API for Google Maps  
         Skins: WVGA800 (default), QVGA, WSVGA, WXGA800-7in, WQVGA400, WVGA854, WXGA720, WXGA800, WQVGA432, HVGA  
         Tag/ABIs : default/x86  

#+END_SRC
**** 创建工程
     $ android create project --target android-10 --name MyFirstApp  --path MyFirstApp --activity MainActivity --package com.example.myfirstapp  
#+BEGIN_SRC 
     > Created project directory: MyFirstApp  
     MyFirstApp/src/com/example/myfirstapp  
     MyFirstApp/src/com/example/myfirstapp/MainActivity.java  
     MyFirstApp/res  
     MyFirstApp/bin  
     MyFirstApp/libs  
     MyFirstApp/res/values  
     MyFirstApp/res/values/strings.xml  
     MyFirstApp/res/layout  
     MyFirstApp/res/layout/main.xml  
     MyFirstApp/AndroidManifest.xml  
     MyFirstApp/build.xml  
     MyFirstApp/proguard-project.txt  
$ ls  
     MyFirstApp  README  

$ cd MyFirstApp/  
$ ls  
     AndroidManifest.xml  ant.properties  bin  build.xml  libs  local.properties  proguard-project.txt  project.properties  res  src  

#+END_SRC
**** 编译
     ant debug  
#+BEGIN_SRC 
     如果报以下错误：
     [aapt] /opt/android-sdk-linux/build-tools/19.0.3/aapt: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory  
     安装库：
     sudo apt-get install lib32z1  

#+END_SRC
**** 部署程序到模拟器
     $ adb install bin/MyFirstApp-debug.apk  
     #+BEGIN_SRC 
      97 KB/s (4858 bytes in 0.048s)  
     pkg: /data/local/tmp/MyFirstApp-debug.apk  
     Success  
    
     #+END_SRC
**** 运行程序
     好了，现在可以在模拟器里面运行程序了。 运行程序MainActivity，显示下面的文字:
     Hello World, MainActivity

     该文字其实是定义在./res/layout/main.xml 文件中:
#+BEGIN_SRC 
     <?xml version="1.0" encoding="utf-8"?>  
     <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
     android:orientation="vertical"  
     android:layout_width="fill_parent"  
     android:layout_height="fill_parent"  
     >  
     <TextView    
     android:layout_width="fill_parent"   
     android:layout_height="wrap_content"   
     android:text="Hello World, MainActivity wuming"  
     />  
     </LinearLayout>  

#+END_SRC
**** 定义应用程序名称

     如果想要修改Android中的应用程序名，不是在pom.xml中编辑，而是在src/values/strings.xml中定义，比如：
#+BEGIN_SRC 
     <?xml version="1.0" encoding="utf-8"?>  
     <resources>  
     <string name="app_name">mvn_example1</string>  
     <string name="edit_message">Enter a message</string>  
     <string name="button_send">Send</string>  
     <string name="action_settings">Settings</string>  
     <string name="title_activity_main">MainActivity</string>  
     </resources>  

#+END_SRC
*** 使用例子工程
      前文描述的是在SDK下用Ant开发， 本文在此基础上尝试用Maven开发。
      这里需要用到maven-android-plugin。

      运行mvn clean compile， 编译报错后会提示要安装一些Android SDK, 用下面的命令：
      /opt/android-sdk-linux/tools/android update sdk --no-ui --all --force  
*** 创建自己的Maven工程
      根据https://code.google.com/p/maven-android-plugin/wiki/GettingStarted 介绍，有两种方法可以创建Maven工程。

      第一种方法是用archetype， 但是我使用了之后，发现archetype产生的项目编译时有一个依赖找不到，不管了，先换其他方法。

      第二种方法就是使用android命令行创建项目，然后复制例子代码工程的pom文件并修改，

      先创建一个项目mvn_example1
  #+BEGIN_SRC 
          android create project --target android-10 --name mvn_example1 --path mvn_example1 --activity MainActivity --package org.csfreebird  
          Created project directory: mvn_example1  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/src/org/csfreebird  
          Added file mvn_example1/src/org/csfreebird/MainActivity.java  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/res  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/bin  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/libs  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/res/values  
          Added file mvn_example1/res/values/strings.xml  
          Created directory /home/dean/work/gitlab_cloud/android/example/mvn_example1/res/layout  
          Added file mvn_example1/res/layout/main.xml  
          Added file mvn_example1/AndroidManifest.xml  
          Added file mvn_example1/build.xml  
          Added file mvn_example1/proguard-project.txt  


  #+END_SRC

      现在复制heelloflashlight的pom.xml文件到该项目目录下， 然后修改其中的一些配置：

          <groupId>org.freebird</groupId>  
          <artifactId>example1</artifactId>  
          <version>1.0.0</version>  
          <packaging>apk</packaging>  
          
          <name>mvn_example1</name>  

      设置platform版本为10，这里使用的是API Level，也可以使用platform level: 2.3.3, 具体可以通过命令android list targets， 不过这里目前还只能设置16, 设置10部署会失败，暂时不明白原因。
  #+BEGIN_SRC 
          <plugins>  
            <plugin>  
              <groupId>com.jayway.maven.plugins.android.generation2</groupId>  
              <artifactId>android-maven-plugin</artifactId>  
              <configuration>  
                <sdk>  
                  <!-- platform as api level (api level 16 = platform 4.1)-->  
                  <platform>10</platform>  
                </sdk>  
              </configuration>  
            </plugin>  
          </plugins>  
  #+END_SRC
      删除掉ant相关的文件：
  #+BEGIN_SRC 
          mvn_example1$ rm -r bin build.xml build.properties libs  
          rm: cannot remove ‘build.properties’: No such file or directory  
  #+END_SRC

      启动模拟设备后，运行下面的命令编译和部署：
  #+BEGIN_SRC 
        mvn clean install  
        mvn android:deploy  
  #+END_SRC

  
      部署成功后，会看到模拟设备上出现程序图标。

      点击运行，成功。
*** Emacs用JDEE编写Android程序
    前文介绍了如何用Maven构建Android工程，现在进一步介绍如何使用JDEE编写程序。
    首先要安装一个m2jdee的插件，能够根据maven的pom.xml中的配置生成jdee所需的prj.el文件。

    获取该项目：
    git clone git@gitlab.com:devtool/m2jdee.git  
      或者
          git clone https://gitlab.com/devtool/m2jdee.git  

      进入m2jdee目录后，编译安装：
          mvn install  
      然后配置~/.m2/settings.xml文件，添加：
  #+BEGIN_SRC 
          <pluginGroups>  
            <pluginGroup>org.freebird.maven.plugins</pluginGroup>  
          </pluginGroups>  
  #+END_SRC
      好了，现在进入我的android maven工程目录， 运行下面的命令：

          mvn m2jdee:jdee  
      一会儿，prj.el文件生成了，内容如下：
  #+BEGIN_SRC 
          (jde-project-file-version "1.0")  
          (jde-set-variables  
            '(jde-sourcepath '("/home/dean/work/gitlab_cloud/android/example/mvn_example1/src/test/java" "/home/dean/work/gitlab_cloud/android/example/mvn_example1/src" ))  
            '(jde-global-classpath '("/home/dean/.m2/repository/org/apache/httpcomponents/httpcore/4.0.1/httpcore-4.0.1.jar" "/home/dean/.m2/repository/org/apache/httpcomponents/httpclient/4.0.1/httpclient-4.0.1.jar" "/home/dean/.m2/repository/xerces/xmlParserAPIs/2.6.2/xmlParserAPIs-2.6.2.jar" "/home/dean/work/gitlab_cloud/android/example/mvn_example1/target/test-classes" "/home/dean/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar" "/home/dean/work/gitlab_cloud/android/example/mvn_example1/target/classes" "/home/dean/.m2/repository/org/khronos/opengl-api/gl1.1-android-2.1_r1/opengl-api-gl1.1-android-2.1_r1.jar" "/home/dean/.m2/repository/com/google/android/android/4.1.1.4/android-4.1.1.4.jar" "/home/dean/.m2/repository/org/json/json/20080701/json-20080701.jar" "/home/dean/.m2/repository/xpp3/xpp3/1.1.4c/xpp3-1.1.4c.jar" "/home/dean/.m2/repository/commons-codec/commons-codec/1.3/commons-codec-1.3.jar" )))  
  #+END_SRC
     好，现在打开mvn_example1/工程的一个java文件， 看一下智能提示是否生效：
      C-c v .
      能够出现完成菜单。
      配置成功。

      具体使用细节请参考我之前的文章：

      Emacs开发Java之使用
      如何调试

      先在~/.emacs.d/init.el中配置一下, 设置jdb为调试器， 调试端口为8700。
  #+BEGIN_SRC 
          ;; jdee  
          (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp")  
          (load "jde")  
          (custom-set-variables  
           '(jde-debugger (quote ("jdb")))  
           '(jde-db-option-connect-socket (quote (nil "8700"))))  
          
          (require 'android-mode)  
          (setq android-mode-sdk-dir "/opt/android-sdk-linux/")  
 
  #+END_SRC
     启动
      andriod-start-emulator
      android-start-ddms
      一定要在DDM的窗口选中要调试的进程

      调试使用的命令
  #+BEGIN_SRC 
          mvn_example1$ jdb -sourcepath "/home/dean/work/gitlab_cloud/android/example/mvn_example1/src" -attach localhost:8700  
          设置 未捕捉到 javamvn_example1$ jdb -sourcepath "/home/dean/work/gitlab_cloud/android/example/mvn_example1/src" -attach localhost:8700  
          设置 未捕捉到 java.lang.Throwable  
          设置延迟的 未捕捉到 java.lang.Throwable  
          正在初始化 jdb....lang.Throwable  
          设置延迟的 未捕捉到 java.lang.Throwable  
          正在初始化 jdb...  

  #+END_SRC
      由于jdee的jde-jdb-attach-via-socket使用的命令是：

      jdb -connect com.sun.jdi.SocketAttach:port=8700

      无法连接android 里的 jvm。 

      经过实验，需要加一个参数就可以连接：

      jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost

      因此修改jdee的配置，在init.el中如下配置：

          ;; jdee  
          (add-to-list 'load-path "~/.emacs.d/jdee-2.4.1/lisp")  
          (load "jde")  
          (custom-set-variables  
           '(jde-db-option-connect-socket (quote ("localhost" "8700")))  
           '(jde-debugger (quote ("jdb"))))  

      现在jde-jdb-attach-via-socket命令成功了。
*** 使用android模式
    首先用package system安装android-mode, 
    然后编辑~/.emacs.d/init.el文件，添加下面几行：
    (require 'android-mode)  
    (setq android-mode-sdk-dir "/opt/android-sdk-linux/")  
    现在重新启动emacs，然后M-x 中运行命令
    android-start-emulator  
    此时会提示输入Android Virtual Device，， 用上下键查找后选择，会看到之前我安装的MT680, 回车后，弹出该设备运行界面。的确很方便。

    关闭该设备模拟的程序后，可以再次运行android-start-emulator启动之，退出emacs的时候，emulator也会关闭。
  
    如果不用emacs emulator也行，用下面的命令行：
    emulator -avd MT680 -partition-size 128 >/dev/null &  
    MT680可以通过android list avd命令查找得到：
    dean@dean-Aspire-V7-481G:~/.emacs.d$ android list avd  
    Available Android Virtual Devices:  
              Name: MT680  
            Device: 4in WVGA (Nexus S) (Generic)  
              Path: /home/dean/.android/avd/MT680.avd  
            Target: Android 2.3.3 (API level 10)  
           Tag/ABI: default/armeabi  
              Skin: HVGA  
            Sdcard: 1G  

      启用调试工具ddm
      M-x android-start-ddm
*** 编译
    之后再运行mvn clean compile, 编译成功。

    现在首先启动虚拟设备
        android avd  

    然后选中我之前创建的mt680, 启动之。
    现在退回到jayway-maven-android-plugin-samples-4d8d535 目录， 运行命令
*** 加载
    mvn clean install  
    经过较长的等待，会看到一些测试成功了，一些失败了。可能是我的mt680太老了吧。
    现在进入子项目helloflashlight目录中， 运行mvn install, 结果在targets目录下生成了apk文件，然后运行命令安装到设备中：
*** 安装
        adb install target/helloflashlight.apk   
    或者用下面的命令：
        mvn android:deploy  

    现在模拟设备上已经看到图标了：
    运行后可以看到几个不同颜色的按钮， 点击按钮窗口颜色可以切换。
** 软件开发流程
   ➤Create new Android application projects.
   ➤Access the tools for accessing your Android emulators and devices.
   ➤Compile and debug Android applications.
   ➤Export Android applications into Android Packages (APKs).
   ➤Create digital certificates for code-signing your APK.
 
  没有统一的入口（main()方法),而是根据四类核心组件通过 Intent 来导航.
  核心组件 ： Activity , Service , Brodcase Receiver , ContentProvider
  View类 用来显示

Activity: 通常是一个单独的屏幕。会显示由几个Views 控件组成的用户接口,并对事件作出响应。
所以每个应用由多个Activity
方法： startActivity() 可以在不同屏幕间导航

Service: 是一种长生命周期的，没有用户界面的程序。 比如音乐播放器，可以后台播放。
方法：Context.startService()来启动一个Service
   Context.bindService() 连接到一个没运行的Service上。

Broadcast  Receiver
系统广播组件，比如检测手机电量的信号。

ContentProvider
实现不同组件间数据共享

View 是用户界面基类。
次序是 底层是Activity ; Activity 上面是Window;Window 上面是Views;
View 又分 View(基本控件) 和ViewGroup （布局控件） 

Intent 是 不同组件间相互导航的纽带。

(length (visible-frame-list))

** AVD模拟器 别的平台的任务在电脑上运行
** 项目文件夹内容 
   src gen(自动生成）bin(编译好的apk) libs 第三方的jar 包
** java 目录 放置 java 源码
** AndroidManifest.xml 项目配置文件
    AndroidManifest.xml
    任何android 组件都要在此注册
** res    
     1. 在代码中通过R.string.hello_world可以获得该字符串的引用；
     2. 在XML中通过@string/hello_world可以获得该字符串的引用。
*** layout
    activity_main.xml
*** valudes
    colors.xml
    strings.xml
    styles.xml
** 日志工具 Log  在 LogCat 中
   android 的 android.util.Log提供几个方法
   1.Log.v() 打印最繁琐的日志信息 verbose
   2.Log.d() 打印调试信息 debug
   3.Log.i() 打印比较重要的信息  info
   4.Log.w() 打印警告信息 warn
   5.Log.e() 打印错误信息 error
*** 日志过滤工具 
    可以输出定义的日志
** 活动 
   手动创建活动
** 包 
* SDK常用命令 
** adb(android调试桥) 使用5037端口 
*** 显示连接的设备：adb devices   
*** 指定模拟器/设备实例
    adb -s <serialNumber> <command>
    <serialNumber>参数表示序列号；<command>参数表示执行的命令。

    例如，需要在emulator-5554上安装HelloWorld.apk应用，可以执行如下命令：
    adb -s emulator-5554 install HelloWorld.apk
    如果只有一个模拟器，则可以省略serialNumber
*** 模拟器/设备实例的文件复制
    adb push <local> <remote>
    adb push <remote> <local>
*** 进入shell    
    adb shell
** android命令
   android命令是一个非常重要的开发工具，其功能如下：
   
   ［√］创建、删除和查看Android虚拟设备（AVD）。
   ［√］创建和更新Android项目。
   ［√］更新Android SDK，内容包括新平台、插件和文档等。
*** 获得可用的Android平台
    android list targets

** emulator命令    
   emulator -avd <avd_name> [-<option> [<value>]] ... [-<qemu args>]
* 用户界面设计   
  Android提供了4种控制UI界面的方法，下面分别进行介绍。
** 1.使用XML布局文件控制UI界面
   。res\layout下写布局文件
   。在Activity中使用以下Java代码显示XML文件中布局的内容。
   setContentView(R.layout.main);

   
   真机模拟
* Gradle 依赖管理工具   
  默认下载路径 /home/USER/.gradle/wrapper/dists
** app/build.gradle 项目的最主要的配置文件
** wrapper.properties  gradle的配置文件 
** build.gradle 整个项目的的基本配置
** settings.gradle 项目的全局的配置文件
** 编译并查看ｇithub android源码   
1.查看项目的gradle版本  ./gradlew -v
2.下载gradle依赖　./gradlew clean
3.编译apk文件   ./gradlew build
app/build/outputs/apk 一种unaligned 代表没zip优化，unsigned 代表没签名
./gradlew assembleDebug 编译并打 Debug 包
./gradlew assembleRelease 编译并打 Release 的包

** 导入Android studio
* 创建应用程序   
  由组件通过 Manifest 绑定而成
** Manifest
   <service android:name=".MyService">
   </service>
   <activity android:name=".MyActivity">
   </activity>
   <provider>, <receiver>
   <uses-library> 使用共享库
组件：
** Activity 表示层
** Service  
** Content Provider 数据存储器
** Intent 消息传递框架
** Broadcast Receiver Intent侦听器
** Widget   
** Notification 向用户发送消息   
* 分离资源
** 创建资源 res/  
   资源类型包含：简单值、Drawable、颜色、布局、动画、样式、菜单、xml文件和原始资源
   R文件是对资源文件夹的引用
*** 简单值:
<resources>
<string name="app_name">To Do List</string>
<string name="app_name">&lt;b>To Do List&lt;/b></string>
<string name="app_name"><b>To Do List</b></string>
<string name="app_name">To Do List</string>
</resources>
*** 颜色
<color name="blue">#00F</color>
*** 尺寸
    <dimen name="border">5dp</dimen>
    px(屏幕像素)
    in(物理英寸)
    pt(物理点)
    mm(物理毫米)
    dp(非密度制约的像素)
    sp(scale-independent缩放比例无关的像素)
*** 样式和主题
    <style name="base_text">
        <item name="android:textSize">14sp</item>
        <item name="android:textColor">#111</item>
    </style>
    继承 parent关键字
    <style name="small_text" parent="base_text">
*** Drawable
    资源标识符是没有扩展名的小写字母文件名。
*** 布局
*** 动画
*** 菜单
    <menu>
       <item android:id="@+id/menu_refresh"/>
    </menu>
** 使用资源
   setContentView(R.layout.main);
*** 当需要资源本身的实例时：
   Resources myResources = getResources();
   
   cahrSequence styleText = myResources.getText(R.string.stop_message);
   Drawable icon = myResoureces.getDrawable(R.drawable.app_icon);
   int Blue = myResources.getColor(R.color.opeque_blue);
   float borderWidth = myResources.getDimension(R.dimen.standard_border);
   
   Animation tranOut;
   tranOut = AnimationUtils.loadAnimation(this, R.anim.spin_shrink_fade);

   String[] stringArray;
   stringArray = myResources.getStringArray(R.array.string_array);
   
   int[] intArray = myResources.getIntArray(R.array.integer_array);
*** 在资源内引用资源
    使用@符号，就可以在资源中引用另一个资源.
    attribute= "@[packagename:]resourcetype/resourceidentifier"
*** 使用系统资源 
    charSequence httpError = getString(android.R.string.httpErrorBadUrl);
    
    XML中
    android:text="@android:string/httpErrorBadUrl"
*** 在当前主题中引用样式
    使用?android: 而不是@
    android:textColor="?android:textColor"
* android
** 一、 Android基础笔记
*** 1. Android 入门
**** adb命令
     列出可以使用的android版本:  android list target
     列出可以使用的模拟器:  android list avd
     !不再是此方法     创建模拟器: android create avd –n <模拟器名> -t <Target版本ID> -c <SD卡大小> -s <屏幕尺寸>
     480*800
     启动模拟器:emulator –avd <模拟器名>
     显示已连接的设备:adb devices，显示内容：设备名，状态（device、offline）
     导入文件到手机:adb push <Windows源文件路径> <手机目标路径>。  推：把电脑上的文件推送到模拟器里
     从手机导出文件:adb pull <手机源文件路径> <Windows目录路径>
     安装程序：adb install <apk文件路径>
     卸载程序:adb uninstall <包名>
     卸载应用程序，如果执行此目录时，有两个设备同处于device状态，那么卸载时就要指定卸载哪一个设备上的应用程序：adb -s 设备名称 uninstall xxx.apk
     重启adb: adb kill-server，abd start-server
     Adb shell:来到模拟器linux系统的终端里，列出模拟器的目录结构:与DDMS中File Explorer界面显示的目录结构一样
     ps：运行的进程
     kill -9 pid:杀死进程
***** android程序部署与启动
      程序启动过程：
      Eclipse将.java源文件编译成.class
      dx工具将所有.class文件转换为.dex文件
      再将.dex文件和所有资源打包成.apk文件
      将.apk文件上传并安装到模拟器，存储在/data/app目录下
      启动程序，开启进程
      根据AndroidManifest.xml文件找到MainActivity类，创建Activity
      Activity创建后执行onCreate(Bundle)方法，根据R.layout.activity_main构建界面
      R.layout.activity_main是R类中的一个成员变量，指向res/layout/activity_main.xml文件
      activity_main.xml文件中描述了Activity的布局方式以及界面组件
      解析activity_main.xml，通过反射创建对象，生成界面
      
      程序打包安装过程

      Android程序——编译打包——apk——签名——通过adb发布到设备上
      编译打包：dx.bat；可以将bin目录下的classes文件、deseLibs依赖包打包成dex文件。还会将dex文件、工程的资源文件，和清单文件打包成apk，和签名文件(META-INF)（apk实际上是一个zip文件）
      通过压缩文件打开apk，可以看见META0INF。dx.bat文件位于：D:\Program Files\eclipse_adt-bundle-windows-x86\sdk\build-tools\android-xxx。

**** android 入门案例
     搭建界面需要组件：TextView（请输入电话号码）、EditText（xxx号码）、Button（呼叫此号码）
     当点击Button时获取EditText中文本
     使用Intent向系统内置的电话拨号器发送意图拨打电话
     注册拨打电话权限android.permission.CALL_PHONE

     layout布局代码
     <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:paddingBottom="@dimen/activity_vertical_margin"
     android:paddingLeft="@dimen/activity_horizontal_margin"
     android:paddingRight="@dimen/activity_horizontal_margin"
     android:paddingTop="@dimen/activity_vertical_margin"
     tools:context=".MainActivity" >
     <TextView
     android:id="@+id/textView1"
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
     android:layout_marginTop="27dp"
     android:text="请输入手机号码" />
     <EditText
     android:id="@+id/et_number"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_below="@+id/textView1"
     android:layout_marginTop="21dp"
     android:ems="10" >
     <requestFocus />
     </EditText>
     <Button
     android:id="@+id/btn_call"
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
     android:layout_alignLeft="@+id/et_number"
     android:layout_below="@+id/et_number"
     android:layout_marginTop="38dp"
     android:text="拨打此号码" />
     </RelativeLayout>

Activity代码
package com.itheima.phonedail;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends Activity {
    /**
     * activitiy 第一次创建的时候调用
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 加载 activity 需要显示布局
        setContentView(R.layout.activity_main);
        // 1. 找到拨打电话号码按钮
        Button btn_call = (Button) findViewById(R.id.btn_call);
        // 2. 给按钮设置点击事件 因为这个参数 是以借口 所有我搞以实现类
        btn_call.setOnClickListener(new MyButtonListener());
    }
    
    /**
     * 定义一个内部类 目的实现 按钮监听
     * 
     * @author Administrator
     * 
     */
    private class MyButtonListener implements OnClickListener {
        
        // 当按钮被点击的时候调用
        @Override
        public void onClick(View v) {
            // 3. 获取到 我要拨打的号码 首先我要 找到 文本框
            EditText et_number = (EditText) findViewById(R.id.et_number);
            String number = et_number.getText().toString().trim(); // 获取文本框的内容
            // 判断number 如果号码为空 我弹出一个提示 土司 Toast
            if ("".equals(number)) {
                // context 上下文 duration 显示土司的时长
                Toast.makeText(MainActivity.this, "号码不能为空", Toast.LENGTH_LONG).show();
                return;
            }
            System.out.println("number--" + number);
            // 4 拨打此号码 意图 干 一件事的想法 打 狗 猫 打代码 打电话 Intent
            Intent intent = new Intent();  // 创建意图对象
            // 设置要拨打的动作
            intent.setAction(Intent.ACTION_CALL);
            // 设置拨打电话号码的数据 uri统一资源标示符 范围要比 url定义范围要广定义的语法规则 比较 url
            // http://www.baidu.com 统一资源定位符
            intent.setData(Uri.parse("tel:" + number));
            // 真正的拨打号码 开启意图对象
            startActivity(intent);
        }
        
    }
    
}
清单文件AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.itheima.phonedail"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="8"
        android:targetSdkVersion="17" />
	<!-- 注意这里的打电话权限 -->
    <uses-permission android:name="android.permission.CALL_PHONE" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.itheima.phonedail.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
2.2. 查看程序错误信息
Android程序中如果出错，错误不会显示在Console中，而是显示在LogCat界面下。可以从window – show view中打开
日志信息分为5个级别：verbose > debug > info > warn > error 高级的包含低级的
可以创建过滤器对日志进行过滤显示，点击绿色加号，可以按照tag、pid、level进行筛选
LogCat不打印日志，如何激活：点击DDMS中的Device或重启adb，实在不行就重启Eclipse

**** 2.3. 将程序安装到真实手机
在电脑上安装手机驱动。有些手机自带驱动，有些没有，可以从官网下载。
在手机设置中打开USB调试，将手机用USB数据线连接到电脑
我的手机是：三星 i9100 。双核1228MHz、1GB RAM 、4GB ROM、480×800像素、Android 2.3、4.3英寸
检查Eclipse的设备管理器中是否显示出新设备。如果未能显示出设备，检查驱动安装是否正常，USB调试是否打开
Eclipse安装程序。Eclipse上右键点击工程 – Run as – Android Application – 自动安装运行

手动打包安装。右键点击工程 – Export – Export Android Application – 选择或创建密钥对程序签名并打包生成apk文件。将apk文件放到手机的SD卡中，通过手机文件浏览器执行安装。
2.4. 案例-短信发送

搭建界面需要组件：TextView、EditText、Button
给Button添加监听器，当被点击的时候获取号码，获取内容
使用SmsManager发送短信
需要注册短信发送权限。android.permission.SEND_SMS
主要代码
SmsManager smsManager=SmsManager.getDefault();
//一条短信可以发送70个中文汉字，140个英文字符，将短信内容分隔
ArrayList<String> sms= smsManager.divideMessage(s_content);
for(String mes:sms){
	smsManager.sendTextMessage(s_num, null,mes,null,null);
}
2.5. 四大布局
2.5.1. LinearLayout（线性布局）
线性布局：水平、垂直显示，如果有多个组件，超出屏幕大小，超出部分就不显示，可以通过android:orientation来定义方向。
android:orientation=“horizontal”表示水平方向
android:orientation=“vertical”表示垂直方向
下面通过代码实现一个线性布局。
1. 新建工程，工程名字叫《线性布局》

然后一直执行Next直到Finish即可。项目的目录结构如下图：

2. 编写布局文件activity_main.xml
由于布局文件比较长，因此把该布局文件拆分成了三份。布局文件第一部分：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:orientation="vertical"
     >
布局文件第二部分：
<LinearLayout 
    android:orientation="horizontal"
	android:layout_width="match_parent"
	android:layout_height="0sp"
	android:layout_weight="4"
    >
    <TextView 
        android:layout_height="match_parent"
        android:layout_width="0sp"
        android:layout_weight="1"
        android:background="#ffffff"
        />
    <TextView 
       android:layout_height="match_parent"
       android:layout_weight="1"
       android:layout_width="0sp"
       android:background="#ffff00"
        />
    <TextView 
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:layout_width="0sp"
        android:background="#00ff00"
        />
    <TextView 
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:layout_width="0sp"
        android:background="#0000ff"
        />
</LinearLayout>
布局文件第三部分：
<TextView
        android:layout_width="match_parent"
         android:layout_height="0sp"
        android:layout_weight="1"
        android:text="@string/hello_world" 
        android:background="#ff0000"
        />
    <TextView
        android:layout_width="match_parent"
        android:layout_height="0sp"
        android:layout_weight="1"
        android:text="@string/hello_world" 
        android:background="#0000ff"
        />
    <TextView
        android:layout_width="match_parent"
         android:layout_height="0sp"
        android:layout_weight="1"
        android:text="@string/hello_world" 
        android:background="#00ff00"
        />
</LinearLayout>
3. 编写java文件MainActivity.java
该java文件是ADT自动生成的。MainActivity.java
package com.itheima.linearLayout;
import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
}
4. 将该项目运行在模拟器上

2.5.2. TableLayout（表格布局）
1. Tablelayout实现边框
默认的是没有边框的 实现边框 可以通过不同的背景颜色去实现
<?xml version="1.0" encoding="utf-8"?>
<TableLayout android:layout_width="wrap_content" xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_height="wrap_content"
     android:stretchColumns="*" android:background="#ff0000">
     <TableRow android:background="#00ff00" android:layout_margin="2dip">
      <Button android:id="@+id/button" android:text="+" android:background="#0000ff" android:layout_margin="2dip"/>
      <TextView android:text="wahah"  android:background="#0000ff" android:layout_margin="2dip"/>
      <TextView android:id="@+id/amount"  android:background="#0000ff" android:layout_margin="2dip"/>
 </TableRow>
 </TableLayout>
2. Tablelayout常用属性
android:stretchColumns="1"是设置 TableLayout所有行的第二列为扩展列。
Id从0开始，1代表第二列。也就是说如果每行都有三列的话，剩余的空间由第二列补齐   
collapseColumns – 设置隐藏那些列，列ID从0开始，多个列的话用”,”分隔。
stretchColumns – 设置自动伸展那些列，列ID从0开始，多个列的话用”,”分隔。
shrinkColumns -设置自动收缩那些列，列ID从0开始，多个列的话用”,”分隔。可以用”*”来表示所有列，同一列可以同时设置为shrinkable和stretchable。

2.5.3. FrameLayout（帧布局）
框架布局是将控件组织在Android程序的用户界面中最简单的布局类型之一。框架布局在xml文件中使用<FrameLayout>来定义。框架布局中的子视图总是被绘制到相对于屏幕的左上角上，所有添加到这个布局中的视图都是以层叠的方式显示，第一个添加到框架布局中的视图显示在最底层，最后一个被放在最顶层，上一层的视图会覆盖下一层的视图，类似于html中的div。
帧布局的运行效果图：

帧布局的布局文件activity_main.xml
布局文件第一部分：
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity" >

布局文件第二部分：
<TextView
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:background="#ff0000"
        android:layout_gravity="center"
        />
    <TextView
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:background="#00ff00"
        android:layout_gravity="center"
        />
    <TextView
        android:layout_width="80dp"
        android:layout_height="80dp"
        android:background="#0000ff"
        android:layout_gravity="center"
        />
    <TextView
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:background="#aabbcc"
        android:layout_gravity="center"
        />
    <TextView
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:background="#ffff00"
        android:layout_gravity="center"
        />
    <TextView
        android:id="@+id/tv_6"
        android:layout_width="20dp"
        android:layout_height="20dp"
        android:background="#000000"
        android:layout_gravity="center"
        />
</FrameLayout>

2.5.4. RelativeLayout（相对布局）
相对布局是实际布局中最常用的布局方式之一。相对布局在xml文件中使用<RelativeLayout>来定义。相对布局可以设置某一个视图相对于其他视图的位置，这些位置可以包括上下左右等，因而相较于其他的布局方式而言具有很大的灵活性。
下面通过代码实现一个相对布局。创建工程步骤跟线性布局一样，因此直接给出布局文件盒运行效果。运行效果图如下所示：

相对布局布局文件activity_main.xml。布局文件第一部分：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" 
    android:id="@+id/rl"
    >

    <Button 
        android:id="@+id/bt_center"
        android:layout_centerInParent="true"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:text="居中"
        />
    <Button 
        android:id="@+id/bt_zn"
        android:layout_below="@id/bt_center"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_centerHorizontal="true"
        android:text="正南"
        />
    <Button 
        android:id="@+id/bt_zb"
        android:layout_above="@id/bt_center"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_centerHorizontal="true"
        android:text="正北"
        />
布局文件第二部分：
<Button 
        android:id="@+id/bt_zx"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_toLeftOf="@id/bt_center"
        android:layout_centerVertical="true"
        android:text="正西"
        />
    <Button 
        android:id="@+id/bt_zd"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_toRightOf="@id/bt_center"
        android:layout_centerVertical="true"
        android:text="正东"
        />
    <Button 
        android:id="@+id/bt_db"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_alignRight="@id/bt_zd"
        android:layout_alignTop="@id/bt_zb"
        android:text="东北"
        />
    <Button 
        android:id="@+id/bt_dn"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_alignRight="@id/bt_zd"
        android:layout_alignTop="@id/bt_zn"
        android:text="东南"
        />

布局文件第三部分：
<Button 
        android:id="@+id/bt_xn"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_alignRight="@id/bt_zx"
        android:layout_alignTop="@id/bt_zn"
        android:text="西南"
        />
    <Button 
        android:id="@+id/bt_xb"
        android:layout_width="60dp"
        android:layout_height="60dp"
        android:layout_alignRight="@id/bt_zx"
        android:layout_alignTop="@id/bt_zb"
        android:text="西北"
        />
</RelativeLayout>
在相对布局内的组件可以使用以下属性：
ParentLeft：true；父窗体左边
ParentBottom：true；父窗体下边
android:layout_centerHorizontal="true" 使组件能够水平居中
android:layout_centerVertical="true"  使组件能够垂直居中
layout_below:指定某个组件，位于此组件的下方。
2.5.5. AbsoluteLayout绝对布局
绝对布局的每一个控件都会有坐标位置:
android:layout_x="97dp"
android:layout_y="92dp"
使用绝对布局的程序，需要对每种手机的分辨率做相应的调整。QQ游戏大厅就是使用绝对布局，他就有各种分辨率的版本。
800*400 的apk  854*400 的apk
2.6. Android下的单位
2.6.1. dip	
缩写：dp
一个基于density(密度)的抽象单位，这个和设备硬件有关，通常在开发中设置一些view的宽高推荐用这个，一般情况下，在不同分辨率，都不会有缩放的感觉。在运行时, Android根据使用中的屏幕的实际密度, 透明地处理任何所需dip单位的缩放。不依赖设备像素，依据设备自动适应大小，推荐使用。
2.6.2. sp
同dip/dp相似，会根据用户的字体大小偏好来缩放，专门用于设置字体的大小。
2.6.3. px
像素，是屏幕的物理像素点，与密度相关，密度大了，单位面积上的px会比较多。在不同分辨率下会有不同的效果，通常不推荐使用这个
2.6.4. dp和px的区别
首先明确一点，HVGA屏density=160；QVGA屏density=120；WVGA屏density=240；WQVGA屏density=120。

density值表示每英寸有多少个显示点，与分辨率是两个概念。dip到px的转换公式: px = dip * (density / 160)。

Android官方定义dip等价于160dpi屏幕下的一个物理像素点， 即1dip=1px。举例来说, 在 240 dpi 的屏幕上, 1dip 等于 1.5px。

不同density下屏幕分辨率信息，以480dip*800dip的 WVGA(density=240)为例:

当density=120时屏幕实际分辨率为240px*400px （两个点对应一个分辨率）状态栏和标题栏高为19px或者25dip。
横屏时屏幕宽度为400px或者800dip，工作区域高度211px或者455dip；
竖屏时屏幕宽度为240px或者480dip，工作区域高度381px或者775dip。

当density=160时屏幕实际分辨率为320px*533px （3个点对应两个分辨率）状态栏和标题栏高为25px或者25dip。
横屏是屏幕宽度533px 或者800dip,工作区域高度295px或者455dip；
竖屏时屏幕宽度320px或者480dip,工作区域高度508px或者775dip。

当density=240时屏幕实际分辨率为480px*800px （一个点对于一个分辨率）状态栏和标题栏高为38px或者25dip。
横屏是屏幕宽度800px 或者800dip,工作区域高度442px或者455dip；
竖屏时屏幕宽度480px或者480dip,工作区域高度762px或者775dip。

 在Android的应用包apk中，系统会根据各个设备的具体情况引用相应的资源文件（注：不加任何标签的资源是各种分辨率情况下共用的）：
当屏幕density=240时，使用hdpi标签的资源；
当屏幕density=160时，使用mdpi标签的资源；
当屏幕density=120时，使用ldpi标签的资源。
下面是在manifest中设置app在不同分辨率时，是否支持多密度的方法。
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.itheima.FrameLayout"
    android:versionCode="1"
android:versionName="1.0" >
--------
<supports-screens
     android:smallScreens="true"
     android:normalScreens="true"
     android:largeScreens="true"
     android:xlargeScreens="true"
     android:anyDensity="true" />
-------
</manifest>
下面是dp与px换算的工具类：
package com.itheima.screenDesity;

import android.content.Context;

public class DensityUtil {
	public static int dip2px(Context context, float dipValue) {
		final float scale = context.getResources().getDisplayMetrics().density;
		return (int) (dipValue * scale + 0.5f);
	}

	public static int px2dip(Context context, float pxValue) {
		final float scale = context.getResources().getDisplayMetrics().density;
		return (int) (pxValue / scale + 0.5f);
	}
}
2.6.5. RGB
颜色：window里是bgr、android里是rgb。有关RGB三色空间我想大家都很熟悉,这里我想说的是在Windows下，RGB颜色阵列存储的格式其实BGR。所以window里的颜色是FF0202，那么android里就是0202FF
2.7. Android点击事件的四种写法
Android中获取到按钮后,我们一般会为其添加点击事件，而android中的点击事件共有四种。
通过匿名内部类来实现，代码由电话拨号器项目改编：

btn_call.setOnClickListener(new OnClickListener()
{
    
    @Override
    public void onClick(View v) {
        EditText et_number = (EditText) findViewById(R.id.et_number);
        String number = et_number.getText().toString().trim(); 
// 获取文本框的内容
        if ("".equals(number)) {
            // context 上下文 duration 显示土司的时长
            Toast.makeText(MainActivity.this, "号码不能为空", Toast.LENGTH_LONG).show();
            return;
        }
        Intent intent = new Intent();  // 创建意图对象
        intent.setAction(Intent.ACTION_CALL);
        intent.setData(Uri.parse("tel:" + number));
        startActivity(intent);
    }
});
 二、通过内部类来实现
其实第二种方法跟第一种方法在本质上没有任何差别，虽然一个是匿名内部类另外一个是内部类，但是这只是写法上的差别，两者都是通过Button对象的setOnClickListener()方法来绑定实现的。
代码摘抄自电话拨号器项目：
    /**
     * 定义一个内部类 目的实现 按钮监听
     * 
     * @author Administrator
     * 
     */
    private class MyButtonListener implements OnClickListener {
        @Override
        public void onClick(View v) {
            EditText et_number = (EditText) findViewById(R.id.et_number);
            String number = et_number.getText().toString().trim(); 
// 获取文本框的内容
            if ("".equals(number)) {
                Toast.makeText(MainActivity.this, "号码不能为空", Toast.LENGTH_LONG).show();
                return;
            }
            System.out.println("number--" + number);
            Intent intent = new Intent();  
// 创建意图对象
            intent.setAction(Intent.ACTION_CALL);
            intent.setData(Uri.parse("tel:" + number));
            startActivity(intent);
        }
    }
三、由类文件去实现监听接口
代码如下：
//第一步：Activity实现OnClickListener接口
public class SecondActivity extends Activity implements OnClickListener {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
//第二步：得到button，并且设置点击监听为：this
        Button btnCall = (Button) findViewById(R.id.btn_call);
        btnCall.setOnClickListener(this);
}
//第三步：重写OnClickListener接口的onClick方法
    @Override
public void onClick(View v) {
//根据v的id来区分点击的是哪个按钮
        switch (v.getId()) {
            case R.id.btn_call:
                    //DoSomething
            break;
        }
    }
}
 四、在布局文件中注册事件
1. 在布局文件中添加android:onClick 属性
<Button 
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="点击我"
    android:onClick="btnCall"/>
2. 在相应的java代码中定义call方法
该方法的形参必须为View对象，且只能有一个。修饰符必须是Public
    public void btnCall(View view) {
        Toast.makeText(getApplicationContext(), 
                "点击了我", Toast.LENGTH_SHORT).show();
    }
2.8. 结合工作和面试
查看程序错误信息
这个比较重要，有些Android断点调试比较麻烦，需要依据错误信息来定位错误。

将程序安装到真实手机
这个会把手机连上Eclipse，会发布应用到手机上即可。
会把电脑上的apk安装到手机里，可通过手机助手，也可以通过adb命令安装。

四大布局
比较重要的是线形布局，和相对布局。帧布局也会用到，其他的不常用。

Android下的单位
了解dp、sp是依据手机屏幕分辨率改变的，自动适应屏幕。px依赖像素不会自动屏幕适配。

四种点击事件的写法
这个在工作中用的非常多，需要掌握。但是具体用哪一种，看公司编码风格。

四大布局
在笔试中常考，面试问的不算多，比较基础。

屏幕适配  后期会具体讲解，到时候大家在自己总结
这个是面试常见问题：
在manifest里定义你的程序支持的屏幕类型
美工切多套图、定义多套layout、9path图片，代码中不要出现具体的像素值

四种点击事件，笔试面试有可能问，但是不多，也比较基础

3. Android测试，日志
3.1. 测试
3.1.1. 常见测试分类
在介绍Android Junit前先介绍一下常见的测试分类。
根据是否知道源程序源码：
黑盒测试：不知源码，只是测试程序的功能
白盒测试：知道源码，根据源代码进行测试
根据测试的粒度：（模块的大小）
单元测试：unit test
功能测试：function test：方法测试
整合测试：integration test：几个模块的测试，服务器/客户端的联调
系统测试：system test
根据测试的次数：（暴力测试）
冒烟测试：smoke test，不停的执行操作，直到系统崩溃
Google提供了一个monkey
Adb shell：进入模拟器目录，monkey 2000，通过monkey是随机点击2000次
monkey –p 包名 次数：只测试某个应用程序
压力测试：pressure test
3.1.2. Junit 测试框架
运行测试代码：后台会帮我们做两步操作
上传当前应用程序到手机系统
发送指令通知手机测试刚才上传的代码
所以需要在清单文件里配置：
  添加指令集(manifest节点下)
     <instrumentation
        android:name="android.test.InstrumentationTestRunner"
        android:targetPackage="com.example.sqlitephone" />
	targetPackage：是测试目标包
  指令集依赖jar包(application节点下)
     <uses-library android:name="android.test.runner" />
3.1.3. Junit 测试步骤
我们完成了一个业务方法，想要对其进行测试，Android程序是不能写main方法运行的，需要建测试项目。
创建测试项目
创建测试工程

定义工程名

选择要测试哪个工程

创建测试类，注意要继承AndroidTestCase

编写测试类
可以直接使用被测试工程中的业务类，测试方法必须以小写“test”开头

不创建测试项目，加测试类
在AndroidManifest.xml清单文件中添加配置
<instrumentation android:targetPackage="cn.itcast.junit" android:name="android.test.InstrumentationTestRunner" />
<uses-library android:name="android.test.runner" />
定义一个类继承AndroidTestCase，定义测试方法
3.1.4. Junit 单元测试
新建业务方法
例如计算器的加法：
// 计算器
public class Calc {
    /**
     * 计算器相加的方法
     * @param x
     * @param y
     * @return
     */
    public int add(int x, int y) {
        
        return x + y;
    }
}
新建Junit测试类，对add方法进行单元测试
//Android中想要进行单元测试 需要继承AndroidTestCase
public class TestCalc extends AndroidTestCase{
      //需要写一个测试方法 
	  public void testAdd(){
		  //想测试 计算器相加的方法 
		  Calc calc = new Calc();
		  int result = calc.add(5, 6);
		  //断言 
		  assertEquals(11,result);
	  }
}
在清单文件中添加测试指令
    <!--测试需要改成我们自己应用的包   -->
      <instrumentation android:name="android.test.InstrumentationTestRunner"
                android:targetPackage="com.itheima.unit" android:label="Tests for My App" />
运行测试方法testAdd
如图：双击方法，右键Run As——Android Junit Test

运行结果：绿条代表测试通过。

Junit 单元测试，在公司中会用到，所以大家需要掌握。
3.1.5. Android Junit拓展知识
 注意：拓展知识并不是必须要求掌握的，心有余力之时可以作为进一步提升的参考。
Android 测试环境的核心是一个Instrumentation框架，在这个框架下，你的测试应用程序可以精确控制应用程序。使用Instrumentation， 你可以在主程序启动之前，创建模拟的系统对象，如Context；控制应用程序的多个生命周期；发送UI事件给应用程序；在执行期间检查程序状态。 Instrumentation框架通过将主程序和测试程序运行在同一个进程来实现这些功能。

通过在测试工程的manifest文件中添 加<instrumentation>元素来指定要测试的应用程序。这个元素的特性指明了要测试的应用程序包名，以及告诉Android如何运行测试程序。下面的图片概要的描述了Android的测试环境：
  
在 Android中，测试程序也是Android程序，因此，它和被测试程序的书写方式有很多相同的地方。SDK工具能帮助你同时创建主程序工程及它的测试工程。你可以通过Eclipse的ADT插件或者命令行来运行Android测试。Eclipse的ADT提供了大量的工具来创建测试用例，运行以及查看结果。
Android提供了基于JUnit测试框架的测试API来书写测试用例和测试程序。另外，Android还提供了强大的Instrumentation框架，允许测试用例访问程序的状态及运行时对象。
1. 
2. 
3. 
4. 
5. 
5.1. 
5.1.1. 
5.1.2. 
5.1.3. 
5.1.4. 
Android Junit中的主要核心API
JUnit  TestCase类
继承自JUnit的TestCase，不能使用Instrumentation框架。但这些类包含访问系统对象（如Context）的方法。使用 Context，你可以浏览资源，文件，数据库等等。基类是AndroidTestCase，一般常见的是它的子类，和特定组件关联。
子类有：
ApplicationTestCase——测试整个应用程序的类。它允许你注入一个模拟的Context到应用程序中，在应用程序启动之前初始化测试参数，并在应用程序结束之后销毁之前检查应用程序。

ProviderTestCase2——测试单个ContentProvider的类。因为它要求使用MockContentResolver，并注入一个IsolatedContext，因此Provider的测试是与OS孤立的。


ServiceTestCase——测试单个Service的类。你可以注入一个模拟的Context或模拟的Application（或者两者），或者让Android为你提供Context和MockApplication。

Instrumentation TestCase类
	继承自JUnit TestCase类，并可以使用Instrumentation框架，用于测试Activity。使用Instrumentation，Android可 以向程序发送事件来自动进行UI测试，并可以精确控制Activity的启动，监测Activity生命周期的状态。

	基类是InstrumentationTestCase。它的所有子类都能发送按键或触摸事件给UI。子类还可以注入一个模拟的Intent。子类有：

ActivityTestCase——Activity测试类的基类。

SingleLaunchActivityTestCase——测试单个Activity的类。它能触发一次setup()和tearDown()，而不是每个方法调用时都触发。如果你的测试方法都是针对同一个Activity的话，那就使用它吧。

SyncBaseInstrumentation——测试Content Provider同步性的类。它使用Instrumentation在启动测试同步性之前取消已经存在的同步对象。


ActivityUnitTestCase——对单个Activity进行单一测试的类。使用它，你可以注入模拟的Context或Application，或者两者。它用于对Activity进行单元测试。不同于其它的Instrumentation类，这个测试类不能注入模拟的Intent。

ActivityInstrumentationTestCase2——在正常的系统环境中测试单个Activity的类。你不能注入一个模拟的 Context，但你可以注入一个模拟的Intent。另外，你还可以在UI线程（应用程序的主线程）运行测试方法，并且可以给应用程序UI发送按键及触 摸事件。

Assert类
	Android还继承了JUnit的Assert类，其中，有两个子类，MoreAsserts和ViewAsserts。

MoreAsserts类包含更多强大的断言方法，如assertContainsRegex(String, String)，可以作正则表达式的匹配。

ViewAsserts类包含关于Android View的有用断言方法，如assertHasScreenCoordinates(View, View, int, int)，可以测试View在可视区域的特定X、Y位置。这些Assert简化了UI中几何图形和对齐方式的测试。


Mock对象类
	Android 有一些类可以方便的创建模拟的系统对象，如Application，Context，Content Resolver和Resource。Android还在一些测试类中提供了一些方法来创建模拟的Intent。因为这些模拟的对象比实际对象更容易使 用，因此，使用它们能简化依赖注入。你可以在android.test和android.test.mock中找到这些类。
它们是：
IsolatedContext——模拟一个Context，这样应用程序可以孤立运行。与此同时，还有大量的代码帮助我们完成与Context的通信。这个类在单元测试时很有用。

RenamingDelegatingContext——当修改默认的文件和数据库名时，可以委托大多数的函数到一个存在的、常规的Context上。使用这个类来测试文件和数据库与正常的系统Context之间的操作。

MockApplication,MockContentResolver,MockContext,MockDialogInterface,MockPackageManager,MockResources ——创建模拟的系统对象的类。它们只暴露那些对对象的管理有用的方法。这些方法的默认实现只是抛出异常。你需要继承这些类并重写这些方法。


Instrumentation TestRunner
Android 提供了自定义的运行测试用例的类，叫做InstrumentationTestRunner。这个类控制应用程序处于测试环境中，在同一个进程中运行测试 程序和主程序，并且将测试结果输出到合适的地方。IntrumentationTestRunner在运行时对整个测试环境的控制能力的关键是使用 Instrumentation。注意，如果你的测试类不使用Instrumentation的话，你也可以使用这个TestRunner。
	当你运行一个测试程序时，首先会运行一个系统工具叫做Activity Manager。Activity Manager使用Instrumentation框架来启动和控制TestRunner，这个TestRunner反过来又使用 Intrumentation来关闭任何主程序的实例，然后启动测试程序及主程序（同一个进程中）。这就能确保测试程序与主程序间的直接交互。
在测试环境中工作
对Android程序的测试都包含在一个测试程序里，它本身也是一个Android应用程序。测试程序以单独的Android工程存在，与正常的Android程序有着相同的文件和文件夹。测试工程通过在manifest文件中指定要测试的应用程序。
每个测试程序包含一个或多个针对特定类型组件的测试用例。测试用例里定义了测试应用程序某些部分的测试方法。当你运行测试程序，Android会在相同进程里加载主程序，然后触发每个测试用例里的测试方法。
测试工程
为了开始对一个Android程序测试，你需要使用Android工具创建一个测试工程。工具会创建工程文件夹、文件和所需的子文件夹。工具还会创建一个manifest文件，指定被测试的应用程序。
测试用例
一个测试程序包含一个或多个测试用例，它们都继承自Android TestCase类。选择一个测试用例类取决于你要测试的Android组件的类型以及你要做什么样的测试。一个测试程序可以测试不同的组件，但每个测试用例类设计时只能测试单一类型的组件。
	一些Android组件有多个关联的测试用例类。在这种情况下，在可选择的类间，你需要判断你要进行的测试类型。例如，对于Activity来说，你有两个选择，ActivityInstrumentationTestCase2和ActivityUnitTestCase。
	ActivityInstrumentationTestCase2设计用于进行一些功能性的测试，因此，它在一个正常的系统环境中测试Activity。你可以注入模拟的Intent，但不能是模拟的Context。一般来说，你不能模拟Activity间的依赖关系。相比而言，ActivityUnitTestCase设计用于单元测试，因此，它在一个孤立的系统环境中测试Activity。换句话说，当你使用这个测试类时，Activity不能与其它Activity交互。
作为一个经验法则，如果你想测试Activity与Android的交互的话，使用ActivityInstrumentationTestCase2。如果你想对一个Activity做回归测试的话，使用ActivityUnitTestCase。
测试方法
每个测试用例类提供了可以建立测试环境和控制应用程序的方法。例如，所有的测试用例类都提供了JUnit的setUp()方法来搭建测试环境。另外，你可以添加方法来定义单独的测试。当你运行测试程序时，每个添加的方法都会运行一次。如果你重写了setUp()方法，它会在每个方法运行前运行。相似 的，tearDown()方法会在每个方法之后运行。
测试用例类提供了大量的对组件启动和停止控制的方法。由于这个原因，在运行测试之 前，你需要明确告诉Android启动一个组件。例如，你可以使用getActivity()来启动一个Activity。在整个测试用例期间，你只能调 用这个方法一次，或者每个测试方法一次。甚至你可以在单个测试方法中，调用它的finishing()来销毁Activity，然后再调用 getActivity()重新启动一个。
运行测试并查看结果
编译完测试工程后，你就可以使用系统工具Activity Manager来运行测试程序。你给Activity Manager提供了TestRunner的名（一般是InstrumentationTestRunner，在程序中指定）；名包括被测试程序的包名和 TestRunner的名。Activity Manager加载并启动你的测试程序，杀死主程序的任何实例，然后在测试程序的同一个进程里加载主程序，然后传递测试程序的第一个测试用例。这个时 候，TestRunner会接管这些测试用例，运行里面的每个测试方法，直到所有的方法运行结束。
	如果你使用Eclipse，结果会在JUnit的面板中显示。如果你使用命令行，将输出到STDOUT上。
测试什么？
除了一些功能测试外，这里还有一些你应该考虑测试的内容：
 Activity生命周期事件：你应该测试Activity处理生命周期事件的正确性。例如，一个Activity应该在pause或destroy事件 时保存它的状态。记住一点的是屏幕方向的改变也会引发当前Activity销毁，因此，你需要测试这种偶然情况确保不会丢失应用程序状态。
  数据库操作：你应该确保数据库操作能正确处理应用程序状态的变化。使用android.test.mock中的模拟对象。
 屏幕大小和分辨率：在发布程序之前，确保在所有要运行的屏幕大小和分辨率上测试通过。你可以使用AVD来测试，或者使用真实的目标设备进行测试。
UI线程中测试
Activity运行在程序的UI线程里。一旦UI初始化后，例如在Activity的onCreate()方法后，所有与UI的交互都必须运行在UI线程里。当你正常运行程序时，它有权限可以访问这个线程，并且不会出现什么特别的事情。当你运行测试程序时，这一点发生了变化。在带有instrumentation的类里，你可以触发方法在UI线程里运行。其它的测试用例类不允许这么做。
为了一个完整的测试方法都在UI线程里运行，你可以使用@UIThreadTest来声明线程。注意，这将会在UI线程里运行方法里所有的语句。不与UI交 互的方法不允许这么做；例如，你不能触发Instrumentation.waitForIdleSync()。
	如果让方法中的一部分代码运行在UI线程的话，创建一个匿名的Runnable对象，把代码放到run()方法中，然后把这个对象传递给appActivity.runOnUiThread()，在这里，appActivity就是你要测试的app对象。
3.2. 日志信息
3.2.1. LogCat介绍
Android LogCat的获取有两种方式：1、DDMS提供的LogCat视图2、通过adb命令行
DDMS提供的LogCat视图如下
如果该视图没有打开，点击window->show view->other->android->Logcat来进行选择。

视图的左侧可以选择或者添加过滤信息，运行一个应用程序时，此处会默认创建一个该包的过滤。视图的右上角区域用于选择LogCat的log级别，共有verbose、debug、info、warn、error、assert6个可选项。如图所示：
。
该视图的主体部分是log的详细信息，包括错误级别（Level）、时间（Time）、进程ID（PID）、线程ID（TID）、应用程序包名（Application）、标签（Tag）、日志正文（Text）。
其中的TID并不等同于Java中的Thread.currentThread().getId(),而是我们Linux中的Thread ID，跟PID相同。
通过命令行调用LogCat
将LogCat信息显示在控制台中

在控制台中输入adb logcat 然后按回车键即可看到LogCat信息，如果需要终止按Ctrl+C键即可。
将LogCat信息保存在文件中

执行adb logcat >D:/a.txt 则将日志输出到D:/a.txt文件中。按Ctrl+C键终止日志的输出。
上面介绍的只是adb logcat命令的最简单用法，其实该命令还有多种可选参数供选择，这里就不再详细说明。

3.2.2. Logcat的日志等级
android.util.Log常用的方法有以下5个：
Log.v() Log.d() Log.i() Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG,INFO, WARN，ERROR。
Log.v 的调试颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v("","");
Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择.
Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息，System.out输出信息是Info级别
Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。
Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。
程序中我们可以使用Log类来输出信息

结果：

3.2.3. Logcat通过tag过滤

  tag:可以利用tag进行过滤，用于查找日志。 在logcat中可以添加一个日志过滤器，选择日志等级，会显示出当前等级和比当前等级高的等级。选择warn，会出现warn和error两种日志。还可以使用System.out来打印日志（info级别），System.error（警告级别）
3.2.4. Logcat日志激活
  激活日志，ddms中随便点击devices中的一项即可。其实日志是打印在模拟器里的，系统通过adb，将日志信息传递到开发平台的logcat中
  如果还是没有打印日志，就重启adb或eclipse，然后也可以通过命令adb logcat，可在cmd中查看日志
3.2.5. 案例-Android程序获取LogCat信息
下面通过创建一个Android工程来演示如何在代码中实时获取LogCat信息。
创建一个新工程，这里工程名为LogCat

在这个工程中使用默认的MainActivity.java类和默认的布局文件。
修改布局文件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
   	<Button 
   	    android:layout_width="wrap_content"
   	    android:layout_height="wrap_content"
   	    android:text="获取LogCat"
   	    android:id="@+id/bt_click"
   	    />
   	<TextView 
   	    android:id="@+id/tv_show"
   	    android:layout_width="match_parent"
   	    android:layout_height="wrap_content"
   	    android:hint="显示日志"
   	    />
</LinearLayout>

修改MainActivity.java代码
代码第一部分：
package com.itheima.com.logcat;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends Activity {
	protected static final String TAG = "MyTest";
	private Button btn;
	private TextView tv_show;
	private Handler handler = new Handler() {
		public void handleMessage(android.os.Message msg) {
			tv_show.setText((String) msg.obj);
		};
	};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		btn = (Button) findViewById(R.id.bt_click);
		tv_show = (TextView) findViewById(R.id.tv_show);

代码第二部分：
btn.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				Log.v(TAG, "这是verbose信息");
				Log.d(TAG, "这是debug信息");
				Log.i(TAG, "这是info信息");
				Log.w(TAG, "这是warn信息");
				Log.e(TAG, "这是error信息");
				/** 开启线程用于监听log输出的信息 **/
				new Thread(new Runnable() {

					@Override
					public void run() {

						Process mLogcatProc = null;
						BufferedReader reader = null;
						try {
							/*
							 * 通过执行命令行获取LogCat信息
							 */
							mLogcatProc = Runtime.getRuntime().exec(new String[] { "logcat", TAG + ":v *:s" });
							/*
							 * 获取进程输出流对象
							 */
							reader = new BufferedReader(new InputStreamReader(mLogcatProc.getInputStream()));
							String line = null;
							StringBuilder sb = new StringBuilder();
代码第三部分（完）：
while ((line = reader.readLine()) != null) {
								sb.append(line);
								Message msg = Message.obtain();
								msg.obj = sb.toString();
								handler.sendMessage(msg);
							}
							reader.close();
							/*
							 * 通过发送消息，通知主线程修改TextView对象
							 * 因此这个操作是在子线程中进行的，而Android应用中子线程是无法修改UI（UI的修改操作必须在
							 * 主线程中进行
							 * ，因此Android提供了Handler机制，让子线程发送消息给主线程，然后由主线程修改UI）.
							 */

						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}).start();
			}
		});
	}

}

将项目运行在模拟器上，并点击按钮
运行结果如图所示：

3.3. 结合工作和面试
面试中
 Junit测试
面试中有可能会被问到，你们公司以前是怎么去测试的？
你可以说我们公司比较规范，有的功能会用Junit测试。也可以说，我们就是手工测试，自己测试没问题了，提交给测试人员去测试。然后他们提交bug，我们修复。
日志信息
面试中，会被问到，你是怎么解决bug的？
一般说下，断点调试，变量分析，日志跟踪即可。
变量分析就是断点调试过程中，对变量的值进行监控，看是否为null，或者不正常。
工作中
 Junit测试
这个会使用即可，一般的小公司不会让做Junit测试，就是手测。大公司，制度比较严格的可能会要求做Junit测试。要做也是一般的单元测试，所以大家单元测试需要掌握。
主要还是测试人员写测试用例去测。
日志信息
上边也提到过了，这个比较重要，一定要会看日志信息，对代码分析，bug调试很有帮助。
还有就是有些同学的日志有时候出现不了，参照Logcat日志激活，一般就是设备没连接成功，连接后有可能需要选择一下连接的设备。
4. 文件操作（File、XML、SharedPreferences）
在Android系统中我们常用的数据存储方式有4种。1、存储中手机内存中（ROM）2、存储在SD卡中3、存储在SharedPreferences中4、存储在SQLite数据库中。在本文档中只介绍前3种数据存储方式，而SQLite将在下一篇中做详细说明。
4.1. 保存文件
4.1.1. 保存文件到SD卡
通过一个模拟用户登录的案例来介绍如何将文件保存到手机内存中。
新创建一个Android工程，如图。

使用默认的布局文件盒默认的Activity。修改布局文件。
在该布局文件中采用了LinearLayout布局。
布局文件第一部分：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
	<EditText 
	    android:layout_marginTop="10dp"
	    android:layout_height="wrap_content"
	    android:layout_width="match_parent"
	    android:hint="请输入用户名"
	    android:id="@+id/et_username"
	    />
	<EditText 
	    android:layout_marginTop="10dp"
	    android:layout_height="wrap_content"
	    android:layout_width="match_parent"
	    android:hint="请输入密码"
	    android:inputType="textPassword"
	    android:id="@+id/et_pwd"
	    />

 属性说明，在以后的文档中对新出现的属性都会进行详细介绍，而已经使用过的属性则不再重复介绍。
上面布局文件中的android:orientation属性在LinearLayout布局中必须指定，有两个可选项：vertical和horizontal，分别代表垂直布局和水平布局。
android:layout_marginTop="10dp" 代表该组件头部距离上一个组件的间隔为10dp。

布局文件第二部分（完）：
<LinearLayout 
	    android:layout_marginTop="10dp"
	    android:layout_height="wrap_content"
	    android:layout_width="match_parent"
	    android:orientation="horizontal"
	    android:gravity="right"
	    >
	    <Button 
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="登陆"
	        android:onClick="login"
	        />
	    <CheckBox 
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="保存密码"
			 android:layout_marginRight="10dp"
			 android:id="@+id/cb"
	        />
	</LinearLayout>
</LinearLayout>
上面的LinearLayout布局中嵌套了LinearLayout组件。第二个LinearLayout布局采用水平方向。
android:gravity="right"的意思是在当前容器内的子元素右靠起的方式布局。

编写Activity代码实现登录功能
Activity主要功能是完成用户的登陆过程，在该过程中需要将用户的数据保存到手机内存（ROM而不是RAM）中。根据分层设计的思想，将有关文件的读、写操作封装为一个工具类来实现。该工具类在下一步会详细列出，这里先引用。
MainActivity.java代码第一部分：
package com.itheima.rom;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Toast;

import com.itheima.rom.service.SaveFileService;

public class MainActivity extends Activity {
	private EditText et_username;
	private EditText et_pwd;
	private CheckBox cb;
	/*
	 * 为了方便演示，因此将用户名和密码设置为常量
	 */
	private static final String PWD = "123456";
	private static final String USERNAME = "wzy";

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		
		/*
		 * 初始化页面元素
		 */
		et_username = (EditText) findViewById(R.id.et_username);
		et_pwd = (EditText) findViewById(R.id.et_pwd);
		cb = (CheckBox) findViewById(R.id.cb);
/*
		 * 在应用界面打开的时候查看手机内存中是否保存有用户的密码信息
		 * 如果有则进行数据的回显。
		 */
		String user = SaveFileService.findUser(this);
		if (user!=null) {
			String[] split = user.split(":");
			et_username.setText(split[0]);
			et_pwd.setText(split[1]);
		}
	}

	public void login(View view){
		String userName = et_username.getText().toString();
		String pwd = et_pwd.getText().toString();
		boolean checked = cb.isChecked();
		/*
		 * 用户名和密码如果为空，则提示用户。
		 */
		if (TextUtils.isEmpty(userName)) {
			Toast.makeText(this, "用户名不能为空！", Toast.LENGTH_SHORT).show();
			return ;
		}
		if (TextUtils.isEmpty(pwd)) {
			Toast.makeText(this, "密码不能为空！", Toast.LENGTH_SHORT).show();
			return ;
		}
		/*
		 * 如果用户选择了保存密码,则将用户名和密码保存在手机内存中
		 * 如果没有选择就将文件删除
		 */
if (USERNAME.equals(userName)&&PWD.equals(pwd)) {
			if (checked) {
				SaveFileService.saveFile(this, userName, pwd);
			}else {//删除用户文件
				SaveFileService.deleteFile(this);
			}
			Toast.makeText(this, "恭喜您，登陆成功！", Toast.LENGTH_SHORT).show();
		}else {
			Toast.makeText(this, "对不起，登陆失败！", Toast.LENGTH_SHORT).show();
		}
	}

}

创建一个新包，包名为com.itheima.rom.service,然后创建SafeFileService.java类
这里的*Service类并不是Android中的Service类，而只是对业务逻辑的抽取而命名的。在以后的学习中会遇到大量的*Service，这些Service则是Android API中很重要的一部分。有关Service会在以后的文档中作详细的介绍。
SafeFileService.java代码第一部分：
package com.itheima.rom.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

import android.content.Context;
/**
 * {@http://www.itheima.com}
 * @author wzy Dec 4, 2014
 *	用于操作手机内存文件的工具类
 */
public class SaveFileService {
	//将数据保存在指定文件中
	private static final String FILE_NAME = "info.txt"; 
	/**
	 * 
	 * @param context
	 * @param username
	 * @param pwd
	 * @return boolean
	 * 	保存用户名和密码于文件中
	 */
	public static boolean saveFile(Context context,String username,String pwd){
		/*
		 * content.getFilesDir()返回的路径为：/data/data/当前包名/files
		 * 比如下面这句代码返回的路径为：/data/data/com.itheima.rom/files
		 */
		File file = new File(context.getFilesDir(), FILE_NAME);
		try {
			FileWriter fw = new FileWriter(file);
			fw.write(username+":"+pwd);
			fw.close();
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}
/**
	 * @param context
	 * @return
	 * 删除用户文件
	 */
	public static boolean deleteFile(Context context){
		File file = new File(context.getFilesDir(), FILE_NAME);
		try {
			return file.delete();
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	/**
	 * @param context
	 * @return 返回用户保存的username:pwd
	 * 
	 */
	public static String findUser(Context context){
		File file = new File(context.getFilesDir(), FILE_NAME);
		//如果文件不存在则返回null
		if (!file.exists()) {
			return null;
		}
		String result = null;
		try {
			BufferedReader reader = new BufferedReader(new FileReader(file));
			result = reader.readLine();
			reader.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result ;
	}
}

将项目部署到AVM上，并进行测试

	输入用户名（wzy）和密码（123456），不选择保存密码选项。发现登录成功了。然后退出当前应用并在此打开该程序的界面的时候发现用户名和密码没用回显。
这一次我们登录前勾选“保存密码”选项，然后再退出程序，重新打开应用界面，发现用户名和密码已经成功回显
在该案例中我们将用户名和密码以文件的形式保存在内存中，并且用户名和密码只是用“：”分隔开，这是严重bug的设计，如果用户的用户名或者密码中有“：”字符，那么该程序就无法获取正确的答案。之所以这么做是因为这个项目只是单纯为了演示如何将用户信息保存在手机内存中。
该案例会在data/data/com.itheima.rom/files文件夹中创建一个info.txt文件。如下图。


4.1.2. 保存文件到手机
在该案例中我们依然采用4.1章节的案例。只需要对SafeFileService.java文件进行修改，将文件的保存路径改为SD卡。如何在SD卡上读、写文件是我们这章节的重点的内容。
如果想将数据文件保存到SD卡的前提是得为你的Android虚拟机创建一个SD卡，为了演示我们分配32M内存空间即可。分配太多会影响虚拟机的启动时间。下图演示了如何分配SD卡空间。


将4.1章节中的SaveFileService类进行修改
也可以重新复制一下这个类，并起名为SaveFileServiceSD，然后只需将MainActivity类中的SaveFileService全部替换为SaveFileServiceSD，这样我们的两个文件都将保存下来，本人就是这么干的。
修改该类中的saveFile方法，这也是重点内容。
public static boolean saveFile(Context context,String username,String pwd){
		/*
		 * 监测当前设备是否已经安装好SDCard
		 * 如果没有安装好则返回
		 */
		String state = Environment.getExternalStorageState();
		if (!state.equals(Environment.MEDIA_MOUNTED)) {
			return false;
		}
		/*
		 * Environment.getExternalStorageDirectory()返回的路径为：/sdcard
		 * 比如下面这句代码返回的路径为：/sdcard
		 * 其实/sdcard只是一个引用地址，真正的地址为/mnt/sdcard
		 */
		File file = new File(Environment.getExternalStorageDirectory(), FILE_NAME);
		try {
			FileWriter fw = new FileWriter(file);
			fw.write(username+":"+pwd);
			fw.close();
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}
上面这个方法对SDCard进行了写入文件的操作，因此需要在清单文件中添加权限：
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
如果不加该权限，保存文件会失败，但是很遗憾的是这时候系统并没有报任何异常。
 修改该类中的saveFile方法。
代码修改起来很简单，只需要修改一个地方即可。在第一个方法中已经展示了如何判断SDCard是否处于可用状态，处于节省篇幅的考虑以后的方法中就不再做判断，如果是在实际开发中，所有关于SDCard的读、写操作都建议大家进行判断。
public static boolean deleteFile(Context context){
		File file = new File(Environment.getExternalStorageDirectory(), FILE_NAME);
		try {
			return file.delete();
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}

修改该类中的findUser方法。
同样的只需要修改一个地方即可。
public static String findUser(Context context){
		File file = new File(Environment.getExternalStorageDirectory(), FILE_NAME);
		//如果文件不存在则返回null
		if (!file.exists()) {
			return null;
		}
		String result = null;
		try {
			BufferedReader reader = new BufferedReader(new FileReader(file));
			result = reader.readLine();
			reader.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result ;
	}
运行该应用于模拟器上。
输入正确的用户名和密码，并勾选“保存密码”选项。然后打开DDMS的File Explorer 窗口。可以看到sdcard目录下产生了info.txt文件。
当取消“保存密码”选项后，在点击登录，然后再打开DDMS的File Explorer窗口，发现该文件已经被删除了。


当我们的应用界面处于打开状态时，我们重新部署该程序到模拟器上经常会有类似如下异常产生。产生这样的异常很好解决，直接在的模拟器中将该应用退出。然后再部署一般就可以解决问题。
com.itheima.rom.MainActivity activity launch
[2014-12-04 23:00:19 - 保存文件到手机内存] Automatic Target Mode: using existing emulator 'emulator-5554' running compatible AVD 'iPhone'
[2014-12-04 23:00:19 - 保存文件到手机内存] Application already deployed. No need to reinstall.
[2014-12-04 23:00:19 - 保存文件到手机内存] Starting activity com.itheima.rom.MainActivity on device emulator-5554
[2014-12-04 23:00:19 - 保存文件到手机内存] ActivityManager: Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.itheima.rom/.MainActivity }
[2014-12-04 23:00:19 - 保存文件到手机内存] ActivityManager: Warning: Activity not started, its current task has been brought to the front
4.1.3. 常用API
在Activity中直接调用即可：
getFilesDir()
 context.getFilesDir().getAbsolutePath();
获取应用路径：  data/data/应用包名/file
getCacheDir().getAbsolutePath();
获取缓存目录
/data/data/应用包名/cache
4.2. XML解析&序列化
4.2.1. 常见XML解析
在Android平台上可以使用Simple API for XML(SAX) 、Document Object Model(DOM)和Android自带的pull解析器解析XML文件。
1、 SAX解析XML文件
     SAX是一个解析速度快并且占用内存少的xml解析器，非常适合用于Android等移动设备。 SAX解析XML文件采用的是事件驱动，也就是说，它并不需要解析完整个文档，在按内容顺序解析文档的过程中，SAX会判断当前读到的字符是否合法XML语法中的某部分，如果符合就会触发事件。所谓事件，其实就是一些回调（callback）方法，这些方法(事件)定义在ContentHandler接口。
2、 DOM解析XML文件
     DOM解析XML文件时，会将XML文件的所有内容读取到内存中，然后允许您使用DOM API遍历XML树、检索所需的数据。使用DOM操作XML的代码看起来比较直观，并且，在某些方面比基于SAX的实现更加简单。但是，因为DOM需要将XML文件的所有内容读取到内存中，所以内存的消耗比较大，特别对于运行Android的移动设备来说，因为设备的资源比较宝贵，所以建议还是采用SAX来解析XML文件，当然，如果XML文件的内容比较小采用DOM是可行的。
3、 Pull解析器解析XML文件
         Pull解析器的运行方式与SAX解析器相似。它提供了类似的事件，如：开始元素和结束元素事件，使用parser.next()可以进入下一个元素并触发相应事件。事件将作为数值代码被发送，因此可以使用一个switch对感兴趣的事件进行处理。当元素开始解析时，调用parser.nextText()方法可以获取下一个Text类型元素的值。
	Pull解析器是一个开源的Java项目，Android系统内部解析XML文件均为此种方式，也可用于JavaEE项目，Android SDK中已经集成了Pull解析器，无需添加任何jar文件。Android系统中推荐使用Pull。
4、 SAX和PULL区别
    SAX解析器的工作方式是自动将事件推入事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。
    你随便找个sax和pull的例子比较一下就可以发现，pull是一个while循环，随时可以跳出，而sax不是，sax是只要解析了，就必须解析完成。
 在本文档中我们将通过一个案例来重点讨论Android自带的pull解析器的使用。首先介绍在Android中XML的序列化。
4.2.2. 演示XML的序列化
创建一个工程，使用其默认的布局文件和Activity类。布局文件如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:orientation="vertical">
    <Button 
        android:layout_height="60dp"
        android:layout_width="wrap_content"
        android:text="生成XML文件"
        android:onClick="makeXML"
        />
</LinearLayout>



Activity类比较简单，出于篇幅考虑，这里只给出核心方法。makeXML生成xml方法：
public void makeXML(View v) {
		File file = null;
		try {
			XmlSerializer serializer = Xml.newSerializer();
			//将生成的文件保存在SDCard中
			String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/sms.xml";
			file = new File(path);
			FileOutputStream outputStream = new FileOutputStream(file);
			serializer.setOutput(outputStream, "utf-8");
			serializer.startDocument("utf-8", true);
			serializer.startTag(null, "message");
			serializer.startTag(null, "sms");
			serializer.startTag(null, "address");
			serializer.text("这是测试地址");
			serializer.endTag(null, "address");
			serializer.endTag(null, "sms");
			serializer.startTag(null, "body");
			serializer.text("这是测试短信内容。");
			serializer.endTag(null, "body");
			serializer.startTag(null, "number");
			serializer.text("132111111111");
			serializer.endTag(null, "number");
			serializer.endTag(null, "message");
			serializer.endDocument();
		} catch (Exception e) {
			Toast.makeText(this, "xml生成失败", Toast.LENGTH_LONG).show();
		}
		Toast.makeText(this, "xml生成了" + file.getAbsolutePath(), Toast.LENGTH_LONG).show();
	}

由于此方法中对SDCard进行了写操作，因此必须加上如下权限：android.permission.WRITE_EXTERNAL_STORAGE。
运行上面程序后发现在/mnt/sdcard下面多了一个sms.xml文件。将该文件导出到电脑中打开查看如下内容：
<?xml version="1.0" encoding="utf-8" standalone="yes" ?> 
 <message>
 <sms>
 <address>这是测试地址</address> 
</sms>
<body>这是测试短信内容。</body> 
 <number>132111111111</number> 
  </message>

4.2.3. 演示XML的Pull解析
已知weather.xml文件中存储着天气信息，使用pull解析xml，将天气信息解析出来并显示。weather.xml内容如下：
<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<weather>
    <city id="1">
    <name>北京</name> 
    <pm>200</pm>
    <wind>4</wind>
    <temp>21-30</temp>
    </city>
</weather>
布局文件比较简单，出于节省篇幅的考虑就不再给出。直接给出java代码。首先是Weather.java类，该类主要用户对数据的封装，这里只给出该类的属性。
private String id;//city id

	private String name;//city name
	private String pm;//pm2.5指数
	private String wind;//风力
	private String temp;//温度

创建PullService.java类，该类用于完成解析XML的业务逻辑。
public class PullService {
	public static Weather pullWeather(InputStream in) throws Exception{
		Weather weather = null;
		XmlPullParser parser = Xml.newPullParser();
		parser.setInput(in, "utf-8");
		//开始循环遍历xml文件，直到文件的结尾
		int type = parser.next();
		while(type!=XmlPullParser.END_DOCUMENT){
			if (type==XmlPullParser.START_TAG) {
				//如果开始标签是weather标签则实例化weather
				if ("weather".equals(parser.getName())) {
					weather = new Weather();
				}else if ("city".equals(parser.getName())) {
					//获取节点下的属性值
					String id = parser.getAttributeValue(0);
					weather.setId(id);
				}else if ("name".equals(parser.getName())) {
					String name = parser.nextText();
					weather.setName(name);
				}else if ("pm".equals(parser.getName())) {
					String pm = parser.nextText();
					weather.setPm(pm);
				}else if ("wind".equals(parser.getName())) {
					String wind = parser.nextText();
					weather.setWind(wind);
				}else if ("temp".equals(parser.getName())) {
					String temp = parser.nextText();
					weather.setTemp(temp);
				}
			}
			type = parser.next();
		}
		in.close();
		return weather;
	}
}
将weather.xml文件拷贝到src目录下，MainActivity.java中修改pullXML方法。

public void pullXML(View v) {
		InputStream in = this.getClass().getClassLoader().getResourceAsStream("weather.xml");
		try {
			Weather weather = PullService.pullWeather(in);
			Toast.makeText(this,weather.toString() , 1).show();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
运行结果如图：

4.3. SharedPreferences
SharedPreferences是Android平台上一个轻量级的存储类，主要是保存一些常用的配置，它提供了Android平台常规的Long、Int、String字符串型的保存。
 SharedPreferences类似过去Windows系统上的ini配置文件，但是它分为多种权限，可以全局共享访问，整体效率来看不是特别的高，对于常规的轻量级而言比SQLite要好不少，如果真的存储量不大可以考虑自己定义文件格式。
xml 处理时Dalvik会通过自带底层的本地XML Parser解析，比如XMLpull方式，这样对于内存资源占用比较好。
这种方式应该是用起来最简单的Android读写外部数据的方法了。他以一种简单、 透明的方式来保存一些用户个性化设置的字体、颜色、位置等参数信息。一般的应用程序都会提供“设置”或者“首选项”的这样的界面，那么这些设置最后就可以通过Preferences来保存，而程序员不需要知道它到底以什么形式保存的，保存在了什么地方。当然，如果你愿意保存其他的东西，也没有什么限制。只是在性能上不知道会有什么问题。
在Android系统中该文件保存在：/data/data/PACKAGE_NAME /shared_prefs 目录下。
下面通过修改“保存文件到SD卡”章节中的案例来演示如何使用SharedPreferences。在此案例中对用户数据的操作就不再需要SaveFileService类，直接在MainActivity类中使用SharedPreferences API即可。由于操作SharedPreferences不需要权限，因此清单文件中关于写SDCard的权限可以删除，当然放在那里不删除也是可以的。
修改后的MainActivity如下：
package com.itheima.rom;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends Activity {
	private EditText et_username;
	private EditText et_pwd;
	private CheckBox cb;
	//声明一个SharedPreferences对象
	private SharedPreferences sp;
	/*
	 * 为了方便演示，因此将用户名和密码设置为常量
	 */
	private static final String PWD = "123456";
	private static final String USERNAME = "wzy";
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		/*
		 * 第二个参数代表的是创建该文件的访问范围（权限），通常并建议选择MODE_PRIVATE，该值为0，
		 * 意思是只有当前应用可以访问该文件。而还有2个可选项MODE_WORLD_READABLE 和MODE_WORLD_WRITEABLE
		 * 值分别为1和2已经废除，因为这两种方式可以允许其他应用来访问此文件，这是很不安全的。
		 */
		sp = getSharedPreferences("info", MODE_PRIVATE);
et_username = (EditText) findViewById(R.id.et_username);
		et_pwd = (EditText) findViewById(R.id.et_pwd);
		cb = (CheckBox) findViewById(R.id.cb);
		/*
		 * 从sp中获取用户信息，用户数据的回显
		 * 第二个参数为默认返回值，也就是当要查找的key-value不存在时，返回的数据
		 */
		String username = sp.getString("username", "");
		String pwd = sp.getString("pwd", "");
		et_username.setText(username);
		et_pwd.setText(pwd);
	}

	public void login(View view){
		String userName = et_username.getText().toString();
		String pwd = et_pwd.getText().toString();
		boolean checked = cb.isChecked();
		/*
		 * 用户名和密码如果为空，则提示用户。
		 */
		if (TextUtils.isEmpty(userName)) {
			Toast.makeText(this, "用户名不能为空！", Toast.LENGTH_SHORT).show();
			return ;
		}
		if (TextUtils.isEmpty(pwd)) {
			Toast.makeText(this, "密码不能为空！", Toast.LENGTH_SHORT).show();
			return ;
		}
		/*
		 * 如果用户选择了保存密码,则将用户名和密码保存在手机内存中
		 * 如果没有选择就将文件删除
		 */
if (USERNAME.equals(userName)&&PWD.equals(pwd)) {
			if (checked) {
				/*
				 * 在对sp进行写、修改需要获取Editor对象
				 */
				Editor editor = sp.edit();
				editor.putString("username", userName);
				editor.putString("pwd", pwd);
				/*
				 * 此处非常重要，执行完修改或者写操作后只有调用sp的commit方法，数据才会被保存下来。
				 */
				editor.commit();
			}else {//删除用户文件
				Editor editor = sp.edit();
				/*
				 * 删除该sp中的所有数据
				 */
				editor.clear();
				editor.commit();
			}
			Toast.makeText(this, "恭喜您，登陆成功！", Toast.LENGTH_SHORT).show();
		}else {
			Toast.makeText(this, "对不起，登陆失败！", Toast.LENGTH_SHORT).show();
		}
	}

}
运行该程序，实现效果跟“保存文件到SD卡”章节是相同的，因此效果图就不再展示。
运行上面程序后系统会自动创建一个文件：/data/data/com.itheima.rom/shared_prefs/info.xml
文件目录结构如下图。

4.4. 案例-获取SD卡和内存的空间信息
4.4.1. 案例详解 
本章节将通过案例演示在Android中如何获取SDCard和手机内存的总空间和可用空间等信息。
1. 创建一个新的Android工程。
工程名字为《获取存储空间大小》，包名为：com.itheima.storageSize。这里使用默认生成的布局文件和Activity类。
2. 修改布局文件activity_main.xml
布局文件第一部分：


布局文件第二部分（完）：

3. 编写业务代码
业务代码第一部分：

业务代码第二部分：

在上述方法中，我们使用了两种方法分别计算SDCard的内存信息。其中第一种方法是JDK API提供的，第二种方法是Android API提供的。这两种方法获取到的总容量和可用容量信息在日志中输出见下图。发现得到的结果是一样的。
在我们Android的开发中自己比较推荐使用第二种方法。因为第二种方法Google工程师专门针对Android系统设计的。相对更加的适用，在看Android源码的时候我们也能发现Android系统自己计算内存容量的时候使用的就是第二种方法。

业务代码第三部分（完）：

4. 运行该程序，分别获取SD卡信息和内存信息。效果如图。

上面布局文件中出现了如下的属性：

在LinearLayout的android:orientation="horizontal"（或者默认）的情况下，如果android:layout_width="0dp" 那么就必须添加android:layout_weight="1"属性，属性值是float类型的。下面将重点说明该属性的真实含义。
4.4.2.  android:layout_weight属性详解
Layout_weight属性的作用：它是用来分配剩余空间的一个属性，你可以设置他的权重。通过几个小例子来说明该属性的用法，比如有如下布局文件：


运行结果是：

看上面代码发现只有Button2使用了Layout_weight属性，并赋值为了1，而Button1和Button3没有设置Layout_weight这个属性，根据API，可知，他们默认是0。
下面我就来讲，Layout_weight这个属性的真正的意思：Android系统先按照你设置的3个Button高度Layout_height值wrap_content,给你分配好他们3个的高度，
然后会把剩下来的屏幕空间全部赋给Button2,因为只有他的权重值是1，这也是为什么Button2占了那么大的一块空间。
通过上面的例子我相信大家对该属性已经有了一定的了解，那么再看下面的例子，相信大家会得到进一步的了解。
布局文件（完）：

运行效果如下：

对于上面运行效果的分析：三个文本框的属性 layout_width=“wrap_content ”时，系统先给3个TextView分配他们的宽度值wrap_content（宽度足以包含他们的内容1,2,3即可），然后会把剩下来的屏幕空间按照1:2:3的比列分配给3个textview，所以就出现了上面的图像。
修改上面的布局文件，当layout_width=“fill_parent”时，如果分别给三个TextView设置他们的Layout_weight为1、2、2的话，就会出现下面的效果：
我们会发现1的权重小，反而分的多了，这是为什么呢？我们可以简单的理解为当layout_width=“fill_parent”时，weight值越小权重越大，优先级越高，而其真正的原因是layout_width="fill_parent"的原因造成的。依照上面理解我们来分析：

系统先给3个textview分配他们所要的宽度fill_parent，也就是说每一都是填满他的父控件，这里就是屏幕的宽度那么这时候的剩余空间=1个parent_width-3个parent_width=-2个parent_width (parent_width指的是屏幕宽度 )。
那么第一个TextView的实际所占宽度应该=parent_width + 他所占剩余空间的权重比列1/5 * 剩余空间大小（-2 parent_width）=3/5parent_width,同理第二个TextView的实际所占宽度=parent_width+ 2/5*(-2parent_width)=1/5parent_width;
第三个TextView的实际所占宽度=parent_width + 2/5*(-2parent_width)=1/5parent_width；所以就是3:1:1的比列显示了。
4.5. 案例-学生管理系统
该案例的重点在于xml的解析和序列化，同时该案例的布局方案也是值得学习的知识点。系统运行如下图：

需求说明：
1、 点击添加按钮，将文本框中的数据添加到页面
2、 点击保存数据按钮，将页面中的所有数据保存到xml文件中
3、 点击清空数据，将页面中的所有数据清空，xml中的数据不作处理
4、 点击恢复数据，将xml文件中的数据展示在页面
使用工程默认的布局文件（第一部分）：

布局文件第二部分：

布局文件第三部分：


布局文件第四部分（完）：

创建User类，其属性信息和在XML中的格式分别如下：


为了方便演示，这里将核心业务写在默认的MainActivity类中：
代码一部分：

代码第二部分：
该部分代码主要对布局文件中元素进行了初始化操作。

代码第三部分：

代码第四部分：saveData（）方法，在界面点击添加按钮的业务逻辑。


代码第五部分（核心代码）：seriaXML(List<User> users)方法的实现


代码第六部分：实现清除数据功能，对应的是clearData()方法，这里的业务逻辑比较简单，只需要清楚界面的数据就行，其实就是将页面LinearLayout容器里面的所有子元素清除即可。

代码第七部分：实现恢复数据功能，也就是点击恢复数据按钮后将xml文件中的数据显示在界面。

代码第八部分（核心功能）：实现pullXML()方法，也就是将xml文件中的数据用pull方式解析出来，并封装在List<User>集合中。


4.6. 结合工作和面试
1. 面试中
 XML解析
面试，笔试都可能会考。对比分析下三种解析方式的优缺点，Android为什么使用Pull解析。
SharedPerferences
有可能会被问道，sp一般用于存储什么类型的数据。
int,float,long,String,boolean类型
一般存储一些flag标志，true、false。或者是时间等等。

2. 工作中
读写文件
工作中会用到一些操作文件的API：
Environment.getExternalStorageDirectory()获取当前SDCard
Environment.getExternalStorageState()方法获取SDCard当前状态
Context.openFileOutput(String name, int mode)可以获取一个文件输出流
Context.openFileInput(String name)可以获取一个文件输入流
context.getFilesDir().getAbsolutePath();获取应用路径
getCacheDir().getAbsolutePath();获取缓存目录
 Xml解析
工作中会用到，但是不算多。了解会用即可，到写代码时可以翻下笔记回顾一下。
SharedPreferences
用的比较多，大家一定要掌握。多加练习
android:layout_weight
权重这个属性比较重要，在工作中用的也比较多。布局中很多组件都可以等比分配来做屏幕适配。
关于文件操作，在应用中一般都会有一个清除缓存这个功能
这个功能就是文件操作实现的：
显示缓存大小，要递归循环缓存文件夹下所有文件大小，然后求和。
清除缓存，要递归删除文件。
以后你们找项目，很多项目都有这个功能，面试的时候有可能会被问到如何实现的。 
递归删除代码：这个方法要在子线程中做
/**
     * 递归删除文件和文件夹
     * 
     * @param file 要删除的根目录
     */
    public static void recursionDeleteFile(File file) {
        if (file.isFile()) {
            file.delete();
            return;
        }
        if (file.isDirectory()) {
            File[] childFile = file.listFiles();
            if (childFile == null || childFile.length == 0) {
                file.delete();
                return;
            }
            for (File f : childFile) {
                recursionDeleteFile(f);
            }
        }
    }
获取缓存大小代码：这个方法要在子线程中做
    /**
     * 获取文件大小
     * 
     * @param f
     * @return
     * @throws Exception
     */
    public static long getFileSize(File f) throws Exception {
        long size = 0;
        File flist[] = f.listFiles();
        if (flist != null)
            for (int i = 0; i < flist.length; i++) {
                File subFile = flist[i];
                if (subFile.isDirectory()) {
                    size = size + getFileSize(subFile);
                } else {
                    size = size + subFile.length();
                }
            }
        return size;
    }
5. 数据库（SQLite） （★★★）
5.1. SQLite特点
	SQLite，是一款轻量型的数据库，是遵守ACID(原子性、一致性、隔离性、持久性)的关联式数据库管理系统，多用于嵌入式开发中。
	Android平台中嵌入了一个关系型数据库SQLite，和其他数据库不同的是SQLite存储数据时不区分类型
例如一个字段声明为Integer类型，我们也可以将一个字符串存入，一个字段声明为布尔型，我们也可以存入浮点数。
除非是主键被定义为Integer，这时只能存储64位整数，SQLite，无需安装，是Android平台自带的一个数据库。
创建数据库的表时可以不指定数据类型，例如：
CREATE TABLE person(id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(20))
CREATE TABLE person(id INTEGER PRIMARY KEY AUTOINCREMENT, name)
SQLite支持大部分标准SQL语句，增删改查语句都是通用的，分页查询语句和MySQL相同
SELECT * FROM person LIMIT 20 OFFSET 10
SELECT * FROM person LIMIT 10,20
SQLite与MySql的不同之处 
主键自增长：SQLite是autoincrement，MySql是auto_increment
主键：	SQLite主键一般定义为_id，在做查询时要求主键列名必须是_id(本身不是_id，可以起别名)，不然拿不到主键值。
获取可读数据库、可写数据库的区别
可读的数据库也有可能可以写，可读的数据库在获取实例时有可能拿到上一次可写的数据库
5.2. 创建数据库
	下面通过一个案例演示SQLiteOpenHelper的用法。创建一个Android工程。为该工程添加Android Junit测试环境（注意：关于Android Junit的知识在本人的第二篇笔记中有详细的说明）。
定义类继承SQLiteOpenHelper
声明构造函数，4个参数
重写onCreate()方法
重写upGrade()方法
具体代码如下：
public class PersonOpenHelper extends SQLiteOpenHelper {
	/**
	 * 
	 * @param context 上下文对象
	 * @param name 数据库名称
	 * @param factory 游标结果集工厂，如果需要使用则需要自定义结果集工厂，null值代表使用默认结果集工厂
	 * @param version 数据库版本号，必须大于等于1
	 */
	public PersonOpenHelper(Context context, String name, CursorFactory factory, int version) {
		super(context, name, factory, version);
	}
/**
	 * 数据库第一次被创建时调用该方法，这里面主要进行对数据库的初始化操作
	 */
	public void onCreate(SQLiteDatabase db) {
		// 数据库第一次被创建的时候执行如下sql语句创建一个person表
		db.execSQL("create table person(id integer primary key autoincrement, name varchar(20), phone varchar(20), money integer(20),age integer(10));");
	}
/**
	 * 数据库更新的时候调用该方法
	 * @param db 当前操作的数据库对象
	 * @param oldVersion 老版本号
	 * @param enwVersion 新版本号
	 */
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		// 数据库的版本更新的时候执行
		if (oldVersion == 1 && newVersion == 2) {
			db.execSQL("alter table person add column balance integer");
		}
	}
	
}
创建一个PersonOpenHelperTest类，用于测试上面的代码:
public class PersonOpenHelperTest extends AndroidTestCase {
	
	public SQLiteDatabase getDataBase(){
		PersonOpenHelper helper = new PersonOpenHelper(getContext(), "person.db", null, 1);
		SQLiteDatabase writableDatabase = helper.getWritableDatabase();
		return writableDatabase;
	}
}
执行完上面代码后，通过DDMS，查看/data/data/com.itheima.sqlite/databases目录，发现产生了两个文件，person.db和person.db-journal。其中第一个文件就是我们的数据库文件。
第一次操作数据库时，person.db-journal文件会被自动创建，该文件是sqlite的一个临时的日志文件，主要用于sqlite数据库的事务回滚操作了。 但是Android系统中将该文件永久的保存在磁盘中，不会被自动清除的，如果没有操作异常或者不需要事务回滚时，此文件的大小为0。这种机制避免了每次生成和删除person.db-journal文件的开销。

	在测试类中创建该类对象，调用getWritableDatabase()或者getReadableDatabase()：
如果数据库不存在，创建数据库文件，执行onCreate()方法，并获取数据库对象。如果数据库存在，版本号没有发生改变，直接获取数据库对象。如果数据库存在，版本号提升，先执行onUpgrade()方法，再获取数据库对象。
数据库并不是初始化MyHelper时创建。
如果版本号降低，应用降级。并且不重写onDowngrade，就会调用父类的onDowngrade方法，抛出异常。一般不重写，没这个需求。

获取可读数据库、可写数据库的区别：可读的数据库也有可能可以写，可读的数据库在获取实例时有可能拿到上一次可写的数据库。

5.3. 使用SQLiteDatabase操作数据库
5.3.1. SQLiteDatabase（★★★）
Android提供了一个名为SQLiteDatabase的类，该类封装了一些操作数据库的API，使用该类可以完成对数据进行添加(Create)、查询(Retrieve)、更新(Update)和删除(Delete)操作（这些操作简称为CRUD）。
和JDBC访问数据库不同，操作SQLite数据库无需加载驱动，不用获取连接，直接可以使用
常用方法：
获取SQLiteDatabase对象之后通过该对象直接可以执行SQL语句。sqliteDatabase.execSQL()：可以执行insert、delete、update和CREATE TABLE
之类有更改行为的SQL语句sqliteDatabase.rawQuery()：用于执行select查询语句。
getReadableDatabase()和getWritableDatabase()的区别
查看源代码后我们发现getReadableDatabase()在通常情况下返回的就是getWritableDatabase()拿到的数据库。只有在抛出异常的时候才会以只读方式打开
数据库对象缓存
getWritableDatabase()方法最后会使用一个成员变量记住这个数据库对象，下次打开时判断是否重用
SQLiteDatabase封装了insert()、delete()、update()、query()四个方法也可以对数据库进行操作，详情参照7.3.4
5.3.2. 执行SQL语句来操作数据库
执行SQL语句来操作数据库有两种方式，拼串和使用占位符”?。使用占位符”?”来执行SQL语句能够防止SQL注入攻击。
拼串方式使用的方法：execSQL(String sql)：增、删、改。
Cursor rawQuery(String sql, String[] selectionArgs): 查询(拼串方式，第二个参数传null即可)。
占位符”?”使用的方法：void execSQL(String sql, Object[] bindArgs)。Cursor rawQuery(String sql, String[] selectionArgs)。
第二个参数对应的是第一个参数中占位符”?”对应的数据数组
下面通过一个案例来演示通过执行SQL实现对数据的增删改查操作，这里使用本文档中7.2章节中的工程（★★★★）。
在本文档7.2章节中，我们继续使用PersonOpenHelperTest类，在该测试类中添加如下方法：
//插入一条数据
public void insert(){
		//获取数据库对象
		SQLiteDatabase dataBase = getDataBase();
		String sql = "insert into person(name,age,phone) values(?,?,?)";
		//执行sql语句
		dataBase.execSQL(sql,new Object[]{"lisi","22","13240217764"});
//关闭数据库
		dataBase.close();
	}
//查询单个数据
public void query(){
		SQLiteDatabase dataBase = getDataBase();
		String sql = "select name,age,phone from person where name=?";
		//执行rawQuery查询，返回Cursor对象
		Cursor cursor = dataBase.rawQuery(sql , new String[]{"zhangsan"});
		Person person = new Person();
		//如果游标还有下一个元素，跟我们集合中Iterator中hasNext()方法类似
		while(cursor.moveToNext()){
			//获取当前游标的第0个元素，元素是从0开始的，而不是1
			String name = cursor.getString(0);
			//也可以通过列名来查询该字段在游标中的位置
			int age = cursor.getInt(cursor.getColumnIndex("age"));
			String phone = cursor.getString(2);
			person.setName(name);
			person.setAge(age);
			person.setPhone(phone);
		}
		//关闭游标
		cursor.close();
		System.out.println(person);
	}
//更新数据
public void update(){
		SQLiteDatabase dataBase = getDataBase();
		String sql = "update person set age=? where name=?";
		//将zhangsan的年龄修改为18
		dataBase.execSQL(sql,new String[]{"18","zhangsan"});
		dataBase.close();
	}
//查询所有数据
public void queryAll(){
		SQLiteDatabase dataBase = getDataBase();
		List<Person> persons = new ArrayList<Person>();
		String sql = "select name,age,phone from person";
		Cursor cursor = dataBase.rawQuery(sql , null);
		while(cursor.moveToNext()){
			String name = cursor.getString(0);
			int age = cursor.getInt(1);
			String phone = cursor.getString(2);
			Person p = new Person();
			p.setAge(age);
			p.setName(name);
			p.setPhone(phone);
			persons.add(p);
		}
		//关闭游标
		cursor.close();
		//输出集合中的数据
		for(Person p : persons){
			System.out.println(p);
		}
	}
在上面例子各个方法中，为了方便Android Junit测试，因此我把数据“写死”在代码里了，真正开发中是不会这么设计的。
5.3.3. 游标结果集Cursor（★★★）
Cursor是结果集游标，用于对结果集进行随机访问。Cursor与JDBC中的ResultSet作用很相似。
Cursor中维护一个行索引一个列索引，游标中本身没有数据，它只是指向数据库的索引，模拟一个行、列的表结构。其起始位置是在-1的位置上的。
常用方法：
moveToNext():将游标从当前行移动到下一行，如果已经移过了结果集的最后一行，返回结果为false，否则为true。
moveToPrevious():用于将游标从当前行移动到上一行，如果已经移过了结果集的第一行，返回值为false，否则为true。
moveToFirst():用于将游标移动到结果集的第一行，如果结果集为空，返回值为false，否则为true。
moveToLast():用于将游标移动到结果集的最后一行，如果结果集为空，返回值为false，否则为true。
5.3.4. SQLiteDataBase自带的增删改查 
SQLiteDatabase专门提供了对应于添加（insert）、删除（delete）、更新（update）、查询（query）的操作方法。
这些方法封装了部分SQL语句，通过参数进行拼接，这些方法实际上是给那些不太了解SQL语法的开发者使用的。对于熟悉SQL语法的程序员而言，直接使用execSQL()和rawQuery()方法执行SQL语句就能完成数据的添加、删除、更新、查询操作。
这四个方法主要是在使用内容提供者时使用，因为contentprovider中提供的增删改查方法，与这一套一样，方便调用传参。(等学完ContentProvider自然明白)
insert("表名",nullColumnHack,"",contentValue)
nullColumnHack:如果写null，就无法插入一条空数据（2.3会出异常，4.0之后可以写null）
如果想插入空数据，第二个参数必须写一个列名（任意列）
这个列名是用来拼接sql语句的，如果contentValue为空，则后台不知道表的列名，无法构建sql语句
ContentValue:键值对：键对应列明，值对应插入的值
返回值 long id，插入的主键id
delete("表名",条件，条件值)，返回受影响的行数。
update("表名",contentValues(更新列、值),条件，条件值)，返回受影响的行数
query("表名", 查询的字段, 条件, 条件值);
下面通过代码来演示SQLiteDatabase操作数据库的过程，我们这里直接使用本文档7.2中工程，只需修改PersonOpenHelperTest类中方法即可。
//测试添加数据
	public void insert() {
		SQLiteDatabase dataBase = getDataBase();
		ContentValues values = new ContentValues();
		values.put("name", "heima");
		values.put("age", 5);
		values.put("phone", "010-82826816");
		/*
		 * 第一个参数 table，代表要将数据插入哪家表 第二个参数
		 * nullColumnHack，字符串类型，指明如果某一字段没有值，那么会将该字段的值设为NULL
		 * ，一般给该参数传递null就行如果没有特殊要求
		 * ，在这里我传递了phone字符串，也就是说当我的ContentValues中phone字段为空的时候系统自动给其值设置为NULL
		 * 第三个参数ContentValues 类似一个Map<key,value>的数据结构，key是表中的字段，value是值
		 */
		dataBase.insert("person", "phone", values);
	}
//测试删除数据

	public void delete() {
		SQLiteDatabase database = getDataBase();
		/*
		 * 第一个参数 table，代表要删除的表名
		 * 第二个参数 whereClause ,选择的条件选项，如果为null则删除表中的所有数据
* 第三个参数 whereArgs  ,如果有条件选项，对应的条件选项的具体参数，没有写null
		 * 删除名字为"heima"的记录
		 */
		database.delete("person", "name=?", new String[]{"heima"});
	}
//测试修改数据
	public void update() {
		SQLiteDatabase database = getDataBase();
		ContentValues values = new ContentValues();
		values.put("age", "100");
		/*
		 * 第一个参数table，要更新的表名
		 * 第二个参数ContentValues 设置要修改的字段的新值，没有涉及到的字段则默认不修改
		 * 第三、四个参数的含义同方法delete
		 */
		database.update("person", values , "name=?", new String[]{"heima"});
	}
	//测试查询单个数据
	public void query() {
		SQLiteDatabase database = getDataBase();
		/*
		 * 第一个参数 table，查询的表名
		 * 第二个参数 columns，要查询的字段
		 * 第三个参数selection 过滤字段 
		 * 第四个参数selectionArgs 过滤字段的值
		 * 第五个参数groupBy 分组字段，null代表不分组
		 * 第六个参数having 
		 * A filter declare which row groups to include in the cursor, 
		 * if row grouping is being used, formatted as an SQL HAVING clause 
		 * (excluding the HAVING itself). Passing null will cause all row groups 
		 * to be included, and is required when row grouping is not being used.
		 * 第七个参数orderBy 排序字段，asc正序，desc倒序，null代表自然顺序
		 */
Cursor cursor = database.query("person", new String[]{"name,age,phone"}, "name=?", new String[]{"heima"}, null, null, null);
			int id = cursor.getInt(0);
			String name = cursor.getString(1);
			String phone = cursor.getString(2);
			System.out.println(id + "_" + name + "_" + phone);
	}
//测试查询所有数据
	public void queryAll(){
		SQLiteDatabase database = getDataBase();
		List<Person> persons = new ArrayList<Person>();
		/*
		 * 该方法跟query()方法是完全一样的，因此参数的含义不在介绍
		 */
		Cursor cursor = database.query("person", new String[]{"name,age,phone"}, null, null, null, null, null);
		while(cursor.moveToNext()){
			Person p = new Person();
			String name = cursor.getString(0);
			int age = cursor.getInt(1);
			String phone = cursor.getString(2);
			p.setName(name);
			p.setAge(age);
			p.setPhone(phone);
			persons.add(p);
		}
	}

5.4. 事务管理
5.4.1. 事务简介 
跟MySql、Oracle等常用数据库一样，SQLite数据库也对事物有较好的支持。使用方法：
beginTransaction(): 开启一个事务
setTransactionSuccessful():设置事务成功标记
endTransaction()：　结束事务，包括提交和回滚，需要放在finally中执行，否则事务只有到超时的时候才自动结束，会降低数据库并发效率
执行过程：
使用beginTransaction开启一个事务，程序执行到endTransaction方法时会检查事务的标志是否为成功，如果程序执行到endTransaction之前调用了setTransactionSuccessful方法设置事务的标志为成功，则提交事务；如果没有调用setTransactionSuccessful方法则回滚事务。
那么下面通过一个案例演示SQLite操作事务的过程。为了便于直奔主题，我们直接使用本文档7.2章节中的Android工程中的PersonOpenHelperTest类即可。
案例：银行转账，需求：客户lisi向zhangsan的账户上转了100块。
public void testTransaction(){
		//这里的最后一个参数（数据库版本号）设置为2，那么会执行PersonOpenHelper类中的onUpgrade方法
		PersonOpenHelper helper = new PersonOpenHelper(getContext(), "person", null, 2);
		SQLiteDatabase database = helper.getWritableDatabase();
		try {
			//开启事务
			database.beginTransaction();
			database.execSQL("update person set balance = balance-100 where name=?",new String[]{"lisi"});
			//当把int a=1/0;放开的时候，发现抛出异常，那么事务就会回滚，上面的扣除lsii的100元钱不会被真正执行
			//如果把int a = 1/0;注释掉，才发现事务成功了，lisi的钱被扣除了100元，同时zhangsan的钱也多了100元。
			int a=1/0;
database.execSQL("update person set balance = balance+100 where name=?",new String[]{"zhangsan"});
			//设置事务成功，也就是只有当代码执行到此行，才代表事务已经成功
			database.setTransactionSuccessful();
		} finally{
			//提交事务，如果setTransactionSuccessful（）方法已经执行，则beginTransaction（）后的语句执行成功
			//否则，事务回滚到开启事务前的状态
			database.endTransaction();
		}
	}

5.4.2. 事务对效率的提高 
在批量修改数据的时候，由于事务是在进行事务提交时将要执行的SQL操作一次性打开数据库连接执行，其执行速度比逐条执行SQL语句的速度快了很多倍。因此当我们开发中遇到对数据库的批量操作那么，使用事务是提高效率的重要原则。
下面通过一个案例，来演示批量操作的情况下，使用事务和不使用事务在效率上的差异。同样的该案例依然使用本文档7.2中的Android工程。
案例：插入一万条数据到数据库，比较使用事务和不使用事务各自所需的时间。
public void testTransactionEfficient(){
		PersonOpenHelper helper = new PersonOpenHelper(getContext(), "person", null, 2);
		SQLiteDatabase database = helper.getWritableDatabase();
//		------测试不使用事务时插入1w条数据耗时--------------------
		long beginTime = System.currentTimeMillis();
		for(int i=0;i<10000;i++){
			database.execSQL("insert into person(name,age,phone) values('text'+"+i+","+i+",'"+(1320000+i)+""+"')");
		}
long endTime = System.currentTimeMillis();
		System.out.println("不使用事务插入1w条数据耗时："+(endTime-beginTime)+"毫秒");
//		---------测试使用事务时耗时-----------------------
		beginTime = System.currentTimeMillis();
		database.beginTransaction();
		for(int i=0;i<10000;i++){
			database.execSQL("insert into person(name,age,phone) values('text'+"+i+","+i+",'"+(1320000+i)+""+"')");
		}
		database.setTransactionSuccessful();
		database.endTransaction();
		endTime = System.currentTimeMillis();
		System.out.println("使用事务插入1w条数据耗时："+(endTime-beginTime)+"毫秒");
	}

执行上面代码，查看控制台，发现不使用事务耗时19397毫秒，使用事务耗时3404毫秒，性能差别还是相当的明显。

5.4.3. 查看SQLite数据库文件
查看SQLite数据库有多种方法，上面章节的演示过程其实就是通过Android API的方式查看。那么下面要介绍的是非常常用的两种方式：1、通过SQLite Expert工具2、通过Android sqlite3工具。
1、 通过SQLite Expert工具
SQLite Expert（http://www.sqliteexpert.com/）是一款强大的SQLite数据库管理工具。从官网上下载的版本只能免费试用30天，试用期过后如果继续使用需要支付一定的费用购买许可。该工具的安装过程很简单，在这里就不再演示。只给大家演示如果利用该工具打开我们在上一个章节中生成的测试数据。
在DDMS视图中打开/data/data/com.itheima.sqlite/databases/person文件，点击右上角的导出按钮，然后在弹出的文件对话框中选择需要保存的位置，然后点击确定即可将模拟器中的数据库文件导出到本地。

然后打开SQLite Expert软件，将person数据拖拽到如下图的左侧区域即可。


2、 通过Android sqlite3工具
Android提供了一个sqlite3.exe程序，位于sdk的tools目录下，用于操作SQLite数据库，其常用命令为：
sqlite3 数据库名称：进入数据库操作模式	eg: sqlite3 contacts.db
tables：查看所有的表					    eg: .tables
schema：查看查看库中所有表的DDL语句　eg: .schema 
help ：　查看帮助　						eg: .help
headers on/off  ：显示表头，默认off 　	eg: headers on
mode list|column|insert|line|tabs|tcl|csv：改变输出格式。eg: .mode column
nullValue：　NULL空值数据显示问题		eg: .nullValue NULL
dump表名　：	生成形成表的SQL脚本	eq: .dump person
dump ：　生成整个数据库的SQL脚本		eq: .dump
exit ：　退出sqlite操作模式			    eq: .exit
操作步骤：
1、 在命令行界面使用adb shell命令进入linux内核
2、 使用cd命令进入数据库所在目录（数据库的路径为”/data/data/应用包名/databases/数据库”）
3、 使用”sqlite3 数据库名”进入数据库操作模式
4、 直接使用各种命令操作数据库

5.5. 结合工作和面试
1. 面试中
SQLite特点？
不区分数据类型等等，参照上边的章节即可。
数据库如何维护？
面试中有可能会被问到，你们公司之前应用的数据库是如何维护的？
其实意思就是你们的数据库表、表字段是怎么做增删修改的，你可以说如果数据库要修改，就改下数据库版本号，然后在onUpgrade里调用即可。
数据库用事务么?
这个就可以说，多表操作，或者是循环操作一个表时会用，其他情况不用。
多表操作，例如转账。循环操作，比如缓存listview数据，要循环插入listview的每一个item对象。
2. 工作中
 SQLiteDataBase
这个比较重要，每个应用都会用到数据库，用到数据库就要用到这个类。
会使用增删改查方法，事务，以及execSQL即可。
SQLiteOpenHelper
维护数据库升级，需要用到这个类。熟悉核心方法onCreate方法以及onUpgrade方法有什么作用，什么时候调用即可。
事务
上边也提到了，多表操作，循环操作数据库都需要用到事务。所以这个也比较重要。会用就行。
SQL语句  重点
做开发的，不管是web端还是客户端，都会接触到sql语句。作为两年工作经验的开发人员，sql语句是必须要会的，所以大家一定要注意。多加练习！！！
如果sql语句写的好，会提高性能，会少些很多逻辑代码。
6. ListView控件（★★★★）
ListView是我们Android中最重要的控件之一，是用于对数据进行列表展示的控件。
ListView的特点：
屏幕上可以展示几个控件, ListView就初始化几个,节省内存，防止内存溢出。
通过使用convertView对创建的视图对象进行复用，ListView始终保持创建的对象个数为: 屏幕显示的条目的个数 + 1。
ListView自带ScrollView的功能，可以实现界面滚动。
ListView控件的设计遵循MVC设计模式：
mode 数据模型(数据) ：要被显示到ListView上的数据集合
view 视图(展示数据) ： ListView
controller控制层(把数据展示到空间上) : 适配器Adapter
下面我们依然通过案例来演示ListView的用法。
6.1. 读取数据库的数据并显示到ListView上
在这里依然使用本文档7.2章节中的工程。在此工程上添加布局文件（2个，一个是Activity对应的布局文件，另外一个是用于显示用户的一条记录，指定ListView数据项的展示样式）。
ListView展示样式效果如下：
。
布局文件的名字必须全部都是小写字母！
1、 创建ListView展示样式布局文件，文件名为listview_item.xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
   	android:orientation="horizontal">
	<ImageView 
	    android:layout_height="60dp"
	    android:layout_width="60dp"
	    android:src="@drawable/ic_launcher"
	    />
	<LinearLayout 
	    android:layout_height="match_parent"
	    android:layout_width="0dp"
	    android:layout_weight="1"
	    android:orientation="vertical">
<TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="match_parent"
	        android:text="用户名"
	        android:id="@+id/tv_username"/>
	    <TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="match_parent"
	        android:text="年龄"
	        android:id="@+id/tv_age" />
	    <TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="match_parent"
	        android:text="电话"
	        android:id="@+id/tv_phone" />
	</LinearLayout>    
</LinearLayout>
2、 创建业务类操作数据库，在该工程中新创建PersonDao
//省略文件头部信息
public class PersonDao {
	private PersonOpenHelper helper;
	public PersonDao(Context context){
		helper = new PersonOpenHelper(context, "person", null, 2);
	}
	public List<Person> queryAll(){
		List<Person> persons = new ArrayList<Person>();
		SQLiteDatabase database = helper.getReadableDatabase();
		Cursor cursor = database.rawQuery("select name,age,phone from person",null);
		while(cursor.moveToNext()){
			Person p = new Person();
			String name = cursor.getString(0);
			int age = cursor.getInt(1);
			String phone = cursor.getString(2);
			p.setName(name);
			p.setAge(age);
			p.setPhone(phone);
			persons.add(p);
		}
		cursor.close();
		database.close();
		return persons;
	}
}
3、 修改main_activity.xml布局文件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity" 
   	android:orientation="vertical"
    >
    <TextView 
        android:gravity="center_horizontal"
android:layout_height="wrap_content"
        android:layout_width="match_parent"
        android:text="将数据显示在ListView中"
        />
	<ListView 
	    android:id="@+id/lv"
	    android:layout_width="match_parent"
	    android:layout_height="match_parent"
	    ></ListView>
</LinearLayout>
使用并修改该工程默认的Activity类，MainActivity。该类的主要业务功能有：
调用Dao获取数据库的全部数据
获取ListView控件的实例
自定义适配器，继承BaseAdapter，重写getCount以及getView方法
int getCount()：用于获取要展示的数据的总条数，即ListView的总长度。
view getView(int position,View convertView,ViewGroup parent)
参数：
第一个：position:当前要显示的项在ListView的索引。
第二个：convertView：就是被拖出去的View对象,getView的返回值，可以利用这个对象使得拖出去即将销毁的条目重用，即缓存对象。ListView中创建对象的个数=屏幕显示的条目数+1，当滑动屏幕时，被隐藏的项会作为缓存对象，作为getView的参数传递进来。
只需修改此缓存对象的内容，直接使用即可，而不需要再重新new一个新的对象出来，节省了内存，防止内存溢出。
具体代码如下所示：
View view =convertView==null?View.inflate(MainActivity.this, R.layout.item, null):convertView;
上述代码，View view= View.inflate(MainActivity.this, R.layout.item, null);这行代码是根据layout布局创建视图view对象。
通过view.findViewById();可以获取item布局中的组件。第三个参数，根节点，将layout构建成的view对象，将此对象放到谁的下边，指定他的父节点。
public class MainActivity extends Activity {
	private ListView lv;
	private List<Person> persons;
	private PersonDao dao;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		lv = (ListView) findViewById(R.id.lv);
		dao = new PersonDao(this);
		persons = dao.queryAll();
		lv.setAdapter(new MyAdapter());
		
	}
	private class MyAdapter extends BaseAdapter{

		@Override
		public int getCount() {
			return persons.size();
		}

		@Override
		public Object getItem(int position) {
			return null;
		}
@Override
		public long getItemId(int position) {
			return 0;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			View view;
			if (convertView!=null) {
				view = convertView;
			}else {
				view = View.inflate(MainActivity.this, R.layout.listview_item, null);
			}
TextView tv_username = (TextView) view.findViewById(R.id.tv_username);
			TextView tv_age = (TextView) view.findViewById(R.id.tv_age);
			TextView tv_phone = (TextView) view.findViewById(R.id.tv_phone);
			Person person = persons.get(position);
			tv_age.setText("年龄："+person.getAge()+"");
			tv_phone.setText("电话："+person.getPhone());
			tv_username.setText("姓名："+person.getName());
			return view;
		}
		
	}
}

4、 运行程序后效果图如下。

6.2. ListView常见方法
ListView的OnItemClickListener条目点击监听器 
实现此接口，重写的方法：条目点击事件
public void onItemClick(AdapterView<?> parent, View view, int position, long id)。
parent：就是listview对象：可以通过parent.getItemAtPosition(position);获取ListVIew适配器BaseAdapter的public Object getItem(int position)的返回值
ListView定位item
listview.setselection(item索引);//这样可以定义到某个索引的item的位置。
ListView的item条目数：listView.getCount();
6.3. 列表视图(ListView)优化
复用旧的convertView
ListView，在上下拖动的时候，会不断的加载View和销毁View，我们可以复用conertView这个旧的view对象来提高listView的效率。
if (convertView != null) {// 复用旧的view对象
	view = convertView;
}
这个view对象为ListView的适配器，getView返回的对象。
减少view.findViewById()，查找控件的操作
view.findViewById();是遍历树状结构的layout的节点来查找的。如果布局文件比较复杂，findviewById就比较耗时。在这里我们可以利用花名册的办法来减少查找操作。具体步骤如下所示:
1、 先定义记事本、花名册：static class 类 要查找的控件字段，
2、 静态类，的字节码只会加载一次，性能提高一点
3、 view.setTag(object)//把孩子id的记事本放在view他爹的兜里
4、 view.getTag();在复用view代码中，可以拿出记事本，不用再查找
具体代码如下所示：
private class BlackNumberAdapter extends BaseAdapter {
		@Override
		public int getCount() {
			return list.size();
		}

		@Override
		public Object getItem(int position) {
			return list.get(position);
		}
		@Override
		public long getItemId(int position) {
			return position;
		}
		@Override
		public View getView(final int position, View convertView, ViewGroup parent) {
			final BlackNumberInfo info = list.get(position);
			View view = null;
			if (convertView != null) {
// 复用旧的view对象
				view = convertView;
				blackNumberRemeber = (BlackNumberRemeber) view.getTag();
// 使用花名册，复用view对象中的孩子，不用每次都FindVIewById
			} else {
				//实例化花名册
				blackNumberRemeber = new BlackNumberRemeber();
				view = View.inflate(CommunicationActivity.this,
						R.layout.activity_comm_listitem, null);
				//实例化花名册中的三个对象
				blackNumberRemeber.tv_number = (TextView) view
						.findViewById(R.id.tv_comm_item_number);
				blackNumberRemeber.tv_mode = (TextView) view
						.findViewById(R.id.tv_comm_item_mode);
				blackNumberRemeber.iv_comm_item_delete=(ImageView) view.findViewById(R.id.iv_comm_item_delete);
				view.setTag(blackNumberRemeber);
			}
			//给花名册的三个对象赋值
			blackNumberRemeber.tv_number.setText(info.getPhone());
			blackNumberRemeber.tv_mode.setText(info.getMode());
			return view;
		}
	}
	//定义记事本、花名册
	static class BlackNumberRemeber {
		//这三个对象都是要查找的对象
		TextView tv_number;
		TextView tv_mode;
		ImageView iv_comm_item_delete;
	}
以上代码摘录自CommunicationActivity.java。

6.4. 列表视图(ListView) 分批加载、分页加载
分批加载
分批加载：解决用户体验问题，不能解决内存溢出（listView展示条目过多会出现内存溢出），先加载几十条，用户拖动到底部，显示加载对话框，再去加载。
listView.setOnScrollListener();设置滚动监听器，这个接口中常用的两个抽象方法如下所示：
onScroll()//滚动的方法
onScrollStateChange();//当滚动状态发送变化时调用的方法，参数：scrollState是用来表示滚动状态的，它有如下所示的几个状态值：
scroll_state_fling://手指已经离开拼命，处于惯性滚动状态
_idle:空闲，没有滚动
_touch_scroll:触摸滚动的状态
在空闲状态中写：因为拖到最底部，就停止了
listView.getLastVisiblePosition();得到listView的最后一个可见条目的位置
如果位置（从0开始）等于集合-1，说明界面拖到最后一个元素，加载新数据。
加载第二次数据时，只需要调用adapter. notifyDataSetChanged即可。

加载到最后，数据全部加载完成，在拖动，不显示正在加载对话框，提示用户已经没有数据
先获取记录总条数。dao：getCount。在滚动状态发送变化的监听器里加判断。如果开始位置，大于总位置，就不加载数据，并提示。分批加载并不能解决，存溢出问题，只是改善用户体验
分页加载
	在界面中添加输入页面的文本框，和跳转按钮：
分批加载、分页加载代码







6.5. 常见的适配器Adapter
ListView中使用的适配器有： BaseAdapter、ArrayAdapter、SimpleAdapter。在8.1章节中我们演示了BaseAdapter的用法。下面我们将通过两个案例分别介绍ArrayAdapter和SimpleAdapter。
6.5.1. ArrayAdapter
ArrayAdapter不仅可以用于显示简单的文本，也可以显示样式和内容丰富的对象。在这里只演示其最简单的使用方法。为了方便演示，新创建一个Android工程，工程名字就叫Adapter，使用该工程默认的布局文件和Activity类。
布局清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
	<TextView 
	    android:layout_height="wrap_content"
	    android:layout_width="wrap_content"
	    android:layout_gravity="center"
	    android:text="演示ArrayAdapter的使用"/>
    <ListView 
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/lv"
        ></ListView>
</LinearLayout>
MainActivity代码清单如下：
package com.itheima.adapter;
import android.app.Activity;
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;
public class MainActivity extends Activity {
	private ListView lv;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		lv = (ListView) findViewById(R.id.lv);
		//创建一个数组
		String[] cities = new String[]{"北京","上海","广州","深圳","杭州","珠海","武汉","郑州"};
		/**
		 * 创建一个ArrayAdapter对象
		 * 第一个参数是Context
		 * 第二个参数是ArrayAdapter的自身布局文件，这里使用Android系统默认提供的
		 * 第三个参数是数组对象
		 */
		ArrayAdapter<String> myAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, cities);
		lv.setAdapter(myAdapter);
	}
}
运行该工程，效果图如下：


6.5.2. SimpleAdapter
SimpleAdapter可以实现比ArrayAdapter复杂一点的布局。使用SimpleAdapter的数据是以List<Map<String, ?>>形式封装数据，List的每一节对应ListView的每一行。HashMap的每个键值数据映射到布局文件中对应id的组件上。
因为系统没有对应的布局文件可用，我们可以自己定义一个布局文件。在本文档中我们用TextView和ImageView组合来进行布局以演示SimpleAdapter的用法。布局效果如下图：

该布局，采用LinearLayout水平布局。为了直奔主题，我们直接修改本文档2.4中的MainActivity类即可，使用默认的main_activity.xml布局文件，另外需要创建上图的布局文件，该布局文件清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    tools:context=".MainActivity" >
	<ImageView 
	    android:layout_height="60dp"
	    android:layout_width="60dp"
	    android:id="@+id/iv_icon"
	    />
    <LinearLayout 
        android:orientation="horizontal"
        android:layout_height="match_parent"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:id="@+id/ll"
        android:gravity="center"
        >
        <TextView 
            android:layout_height="wrap_content"
            android:layout_width="wrap_content"
             android:id="@+id/tv_text"
            />
    </LinearLayout>
</LinearLayout>
MainActivity类代码清单：
public class MainActivity extends Activity {
	private ListView lv;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		lv = (ListView) findViewById(R.id.lv);
		List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
		Map<String, Object> map = new HashMap<String, Object>();
		map.put("icon", R.drawable.ic_launcher);
		map.put("text", "北京");
		list.add(map);
		map = new HashMap<String, Object>();
		map.put("icon", R.drawable.ic_launcher);
		map.put("text", "上海");
		list.add(map);
		map = new HashMap<String, Object>();
		map.put("icon", R.drawable.ic_launcher);
		map.put("text", "广州");
		list.add(map);
		map = new HashMap<String, Object>();
		map.put("icon", R.drawable.ic_launcher);
		map.put("text", "深圳");
		list.add(map);
		map = new HashMap<String, Object>();
		map.put("icon", R.drawable.ic_launcher);
		map.put("text", "杭州");
		list.add(map);
		/**
		 * 创建一个SimpleAdapter对象
		 * 第一个参数 Context 上下文
		 * 第二个参数 data 要显示的数据集合
		 * 第三个参数 id 指定一个作为ListView的子条目的布局文件
		 * 第四个参数 String[] 定义得Map中key组成的数组
		 * 第五个参数 int[] 控件的id组成的数组，必须与第四个参数的key一一对应
		 */
SimpleAdapter myAdapter = new SimpleAdapter(this, list, R.layout.listview_item, new String[] { "icon", "text" }, new int[] { R.id.iv_icon, R.id.tv_text });
		lv.setAdapter(myAdapter);
	}
}
运行该工程效果如下图：

6.6. 结合工作和面试
1. 面试中
Listview优化
Listview是重中之重，无论面试和工作，都常会涉及。具体如何优化，上边介绍的很清楚，后期大家在做项目的时候会再次接触。当然还有一些其他优化，大家可以去百度下，了解下。常用优化如下：
重用ConvertView 减少加载xml的时间
利用ViewHolder 减少findviewByid的时间
如果只涉及到一个Item的某一个控件的更改,不应该去刷新整个ListView(notifyDataSetChanged())
而是给这个控件使用setTag(Position)的方式设置不同的tag,然后使用ListView.findViewByTag,找到这个对应的控件进行更改(什么时候需要使用notifyDataSetChanged,当有一个条目添加或者删除,这个时候就必须刷新)
分批分页加载
当然还有一些其他优化，我在这里就不做阐述，可以自己去研究。
适配器 BaseAdapter
这个用的最多，需要重要熟悉，知道每个方法的意思，如何使用。当然会有一些特殊情况，可以使用其他的适配器会更方便，其他掌握即可。
7. Android中的对话框（★★★）
Android中常用的对话框有通知对话框、列表对话框、单选对话框、多选对话框以及进度对话框。其中，通知对话框、列表对话框、单选以及多选对话框由AlertDialog.Builder创建，进度对话框由ProgressDialog创建。
常用方法：
setIcon				设置对话框标题栏左侧的那个图标
setTitle				设置对话框标题栏的提示信息
setMessage			设置对话框主体部分的提示信息
setPositiveButton	设置确定按钮
setNegativeButton	设置取消按钮
setCancelable		设置对话框在点击返回键时是否会关闭
show				显示对话框
下面将通过案例分别介绍这五种对话框的用法。
为了方便演示，在这里需要创建一个新工程，工程名叫《对话框》。该工程的主界面有五个按钮，这五个按钮绑定了分别调用其对应对话框的函数，点击不同的按钮在其对应的函数里展示不同的对话框。因此下面的操作默认都是在该工程中实现的。
该工程的布局文件清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
android:layout_height="match_parent"
	 android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_gravity="center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="演示五种常见对话框" />
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="通知对话框"
	    android:onClick="notifyDialog"/>
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="列表对话框"
	    android:onClick="listDialog"/>
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="单选对话框"
	    android:onClick="singleDialog"/>
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="多选对话框"
	    android:onClick="multiDialog"/>
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="进度对话框"
	    android:onClick="progressDialog"/>
</LinearLayout>
该工程运行效果图如下：

7.1. 通知对话框
通知对话框使用Builder创建，一般都会有个确认和取消按钮。当通知对话框提示的信息是要求用户必须观看且必须做出确定或者取消的选择的时候，需要设置setCancelable属性为false(默认true),以防止用户直接使用返回键关闭对话框。
notifyDialog()方法代码清单：
public void notifyDialog(View v){
		Builder builder = new Builder(this);
		builder.setIcon(R.drawable.ic_launcher);
		builder.setTitle("通知");
		builder.setMessage("您看到的是通知对话框！");
		//设置对话框点击返回键不关闭
		builder.setCancelable(false);
		//设置确定按钮的点击事件
		builder.setPositiveButton("确定", new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				Toast.makeText(MainActivity.this, "您点击了确定按钮！", 0).show();
			}
		});
		//设置取消按钮的点击事件
		builder.setNegativeButton("取消", new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				Toast.makeText(MainActivity.this, "您点击了取消按钮！", 0).show();
			}
		});
		//将对话框显示出来
		builder.show();
	}
运行效果图：


7.2. 列表对话框
列表对话框使用Builder来创建，只需调用Builder对象的setItems方法设置要展示的列表项即可。
public void listDialog(View v){

		Builder builder = new Builder(this);
		builder.setIcon(R.drawable.ic_launcher);
		builder.setTitle("请选择要去的城市");
		final String[] cities = new String[]{"北京","上海","广州","深圳","杭州"};
		builder.setItems(cities, new OnClickListener() {
			/*
			 * 第一个参数代表对话框对象
			 * 第二个参数是点击对象的索引
			 */
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String city = cities[which];
				Toast.makeText(MainActivity.this, "您选择的是："+city, 0).show();
			}
		});
		builder.show();
	}
执行上面的代码，运行效果如下图：

7.3. 单选对话框
单选对话框使用Builder来创建，只需调用Builder对象的setSingleChoiceItems方法,设置要展示的列表项即可。
setSingleChoiceItems(
CharSequence[] items,//要展示的单选选项列表
int checkedItem,//默认选中项的索引
final OnClickListener listener//选中选项触发的点击事件
)
具体使用如下所示：
public void singleDialog(View v){
		Builder builder = new Builder(this);
		builder.setIcon(R.drawable.ic_launcher);
		builder.setTitle("请选择您要学习的编程语言");
		final String[] languages = new String[]{"Java","C/C++","iOS",".Net","PHP"};
		/*
		 * 第一个参数 显示的可选项
		 * 第二参数 默认选中的索引
		 * 第三个参数 点击事件监听器
		 */
		builder.setSingleChoiceItems(languages, 0, new OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String language = languages[which];
				Toast.makeText(MainActivity.this, "您选择的编程语言是："+language, 0).show();
			}
		});
		//设置确定按钮的点击事件
			builder.setPositiveButton("确定", new OnClickListener() {
					@Override
		public void onClick(DialogInterface dialog, int which) {
						Toast.makeText(MainActivity.this, "您点击了确定按钮！", 0).show();
					}
				});
				//设置取消按钮的点击事件
		builder.setNegativeButton("取消", new OnClickListener() {
					@Override
		public void onClick(DialogInterface dialog, int which) {
						Toast.makeText(MainActivity.this, "您点击了取消按钮！", 0).show();
					}
				});
		builder.show();
	}
执行上面的代码，运行效果如下图：

该种类型的对话框在点击选项的时候Toast即输出您点击的条目，但是此时该对话框并没有自动消息，需要我们点击确定和取消才会消失。而列表对话框在我们选种任何一个条目后对话框自动就消失。
7.4. 多选对话框
多选对话框使用Builder来创建，只需调用Builder对象的setMultiChoiceItems方法,设置要展示的列表项即可。
setMultiChoiceItems(
CharSequence[] items, //要展示的多选列表项
boolean[] checkedItems, //对应每个列表项的选中状态
final OnMultiChoiceClickListener listener//点击事件
) 
具体使用如下所示：
public void multiDialog(View v) {
		Builder builder = new Builder(this);
		builder.setIcon(R.drawable.ic_launcher);
		builder.setTitle("请选择您的兴趣爱好");
		final String[] hobbies = new String[] { "逛淘宝", "看杂志", "看电影", "游泳", "徒步旅游" };
		/*
		 * 第一个参数 显示的可选项 第二参数 默认选中的索引 第三个参数 点击事件监听器
		 */
		builder.setMultiChoiceItems(hobbies, new boolean[]{false,false,false,false,true}, new OnMultiChoiceClickListener() {
			
			@Override
	public void onClick(DialogInterface dialog, int which, boolean isChecked) {
				String hobby = hobbies[which];
				//如果选择了某一项
				if (isChecked) {
					Toast.makeText(MainActivity.this, "您选择了："+hobby, 0).show();
				}else {//取消某一项
					Toast.makeText(MainActivity.this, "您取消了："+hobby, 0).show();
				}
			}
		});
		// 不设置点击事件的监听，仅仅退出当前对话框
		builder.setPositiveButton("确定", null);
		builder.show();
	}
运行上面代码效果如下图：

7.5. 进度对话框
进度对话框不同于之前几种对话框，它是由ProgressDialog对象来创建的，而且进度对话框内部使用了消息机制Handler来进行处理，所以它可以直接在子线程中进行修改，无需再单独设置Handler来修改UI。
public void progressDialog(View v) {
		final ProgressDialog dialog = new ProgressDialog(this);
		dialog.setIcon(R.drawable.ic_launcher);
		dialog.setTitle("进度对话框");
		dialog.setMessage("玩命下载中...");
		// 设置对话框的样式为水平
		dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
		//给进度条设置最大值
		dialog.setMax(100);
		//显示对话框
		dialog.show();
		new Thread(new Runnable() {

			@Override
			public void run() {
				while (true) {
					//休眠500ms
					SystemClock.sleep(100);
					//进度条每次增加一个单位
					dialog.incrementProgressBy(1);
					//进度条到头时退出
					if (dialog.getMax() == dialog.getProgress()) {
						dialog.dismiss();
						Toast.makeText(MainActivity.this, "下载完成！", 0).show();
					}
				}
			}
		}).start();
	}
运行上面代码效果如下图：

7.6. Toast通知
创建通知
Toast.makeText(Context context, CharSequence text, int duration)
Toast.makeText(Context context, int resId, int duration)
发送通知
show()
7.7. 状态栏通知
        
创建通知
通过构造函数创建: Notification(int icon, CharSequence tickerText, long when)
icon: 通知的图片资源ID
tickerText: 状态栏中显示的消息内容
when: 时间 system.currentTimeMillis();
创建PendingIntent以供点击时发送，延迟意图，点击时发送
PendingIntent.getActivity(Context context, int requestCode, Intent intent, int flags)
context: 当前上下文
requestCode: 请求码
intent: 点击时要发送的意图
flags: 类型, PendingIntent中提供了常量选择
设置通知点击事件
调用Notification 对象方法: setLatestEventInfo(Context context, CharSequence contentTitle, CharSequence contentText, PendingIntent contentIntent)
context: 当前上下文
contentTitle: 标题
contentText: 内容
contentIntent: 点击时触发的意图
设置通知点击后清除
设置Notification 对象属性 。
n.flags = Notification.FLAG_AUTO_CANCEL;
获取系统通知服务 
NotificationManager nm = 
(NotificationManager) getSystemService(NOTIFICATION_SERVICE)
发送消息
调用Notification对象方法: notify(int id, Notification notification)
Id是声明这个通知的id，如果id一样，则只能发送一次通知。
具体代码
Notification n = new Notification(R.drawable.feq, "下载完成", System.currentTimeMillis());
PendingIntent pi = PendingIntent.getActivity(this, 100,  new Intent(this, ResultActivity.class), PendingIntent.FLAG_ONE_SHOT);
n.setLatestEventInfo(this, "下载完成", "FeiQ.exe下载完成", pi);
n.flags = Notification.FLAG_AUTO_CANCEL;
NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
manager.notify(0, n);
7.8. 对话框知识点 重点
  activity，弹出对话框时，生命周期方法：onpause()、onResume()方法不会执行。因为对话框是activity的一部分。 所以，构造对话框的Builder(context)，这个context是指定这个对话框挂载在哪个activity上。
7.9. 自定义对话框
步骤：
首先需要通过 dialog= builder.create();创建出来一个对话框
dialog.setView();//根据View来显示对话框
那么就创建view相对应的layot文件
-dialog_setup.xml 设置密码layout：包括按钮
取消：dialog.dismiss()或者dialog.cancle()内部调用dismiss
代码：
/**
	 * 显示设置密码对话框
	 */
	public void showSetupPwdDialog() {
		AlertDialog.Builder builder=new Builder(HomeActivity.this);
		final View view=View.inflate(this, R.layout.dialog_setup_pwd, null);
		//需要显示创建dialog（一般调用show时，会先判断有木有对话框，没有就创建）
		final AlertDialog dialog = builder.create();
		//给对话框指定自定义的layout文件，并且上下左右边框为0：不然对话框会出现黑框，因为低版本的对话框，不指定背景的话就是黑色的。
		dialog.setView(view,0,0,0,0);
		Button btn_confirm=(Button) view.findViewById(R.id.btn_dialog_confirm);
		Button btn_cancle=(Button) view.findViewById(R.id.btn_dialog_cancle);
		//添加点击事件
		btn_confirm.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				EditText ed_dialog_pwd= (EditText) view.findViewById(R.id.et_dialog_pwd);
				EditText ed_dialog_pwd_confirm=(EditText) view.findViewById(R.id.et_dialog_pwd_confirm);
				String pwd=ed_dialog_pwd.getText().toString().trim();
				String pwd_confirm=ed_dialog_pwd_confirm.getText().toString().trim();
				if(TextUtils.isEmpty(pwd)||TextUtils.isEmpty(pwd_confirm)){
					Toast.makeText(getApplicationContext(), "密码和再次密码不能为空", Toast.LENGTH_SHORT).show();
					return ;
				}
				if(!pwd.equals(pwd_confirm)){
					Toast.makeText(getApplicationContext(), "两次密码必须一致", Toast.LENGTH_SHORT).show();
					return ;
				}
				//保存密码
				Editor edit = sp.edit();
				edit.putString("pwd", pwd);
				edit.commit();
				dialog.dismiss();
				//显示输入密码
				showEnterPwdDialog();
			}
		});
		btn_cancle.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				dialog.dismiss();
			}
		});
		dialog.show();
	}
7.10. 结合工作和面试
1. 面试中
一个对话框弹出，Activity会执行什么生命周期方法？
Toast通知
如何显示任意时长的Toast？这个工作中也会碰到这样的需求。 
如何调用：
    // 显示任意时长的toast 
    private void showAnyTimeToastAndCountCurrentTime() {
        lowAnyTimeToast = AnyTimeToast.makeText(mContext, warnMsg);
        lowAnyTimeToast.show(60);//toast显示时长
    }

如何解决Toast重复弹出问题？这个工作中也会碰到这样的需求。
在我们做项目时，有时会用到Toast来给用户提示某些信息，可当用户视而不见时，连续重复的操作就会让Toast不停的在页面上显示，很是影响用户体验。
解决思路：
不用计算Toast的时间之类的，就是定义一个全局的成员变量Toast, 这个Toast不为null的时候才去make,否则直接setText.为了按返回键后立即使Toast不再显示，重写父类Activity的 onBackPressed()方法里面去cancel你的Toast即可.
    private Toast mToast;
    
    public void showToast(String text) {
        
        if (mToast == null) {
            mToast = Toast.makeText(MainActivity.this, text, Toast.LENGTH_SHORT);
        } else {
            mToast.setText(text);
            mToast.setDuration(Toast.LENGTH_SHORT);
        }
        mToast.show();
    }
    
    public void cancelToast() {
        if (mToast != null) {
            mToast.cancel();
        }
    }
    
    public void onBackPressed() {
        cancelToast();
        super.onBackPressed();
    }

2. 工作中
通知对话框
这个对话框用的会最多，但是其他的了解会用即可。
通知
Toast通知、状态栏通知用的比较多需要掌握。
自定义对话框
有很多公司会要求不同风格的对话框，所以需要自定义对话框。需要掌握。


8. Android中几个常用控件（★★★）
在本章节中我们将用介绍ProgressBar、Spinner、AutoCompleteTextView、MultiAutoCompleteTextView等共四个控件的基本用法。这些控件在我们以后的工作中经常会用到的，因此这里也要求我们必须掌握这部分知识。
为了便于演示我们新创建一个项目，项目名《常用控件》。使用默认的布局文件和默认的Activity类。
布局文件如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >

    <TextView
        android:layout_gravity="center_horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="演示常用控件的使用" />
    <TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="进度条ProgressBar"
        />
    <!-- 进度条控件 
    	android:max 进度条条总刻度
    	android:progress 默认进度
    -->
     <ProgressBar 
       style="@android:style/Widget.ProgressBar.Horizontal"
       android:layout_height="wrap_content"
       android:layout_width="match_parent"
       android:max="100"
       android:progress="20"
       android:id="@+id/progressBar"
       />
       <TextView 
        android:layout_marginTop="30dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="下拉列表框Spinner"
        />
<!-- 下拉列表框控件 
    	 android:entries 字符串数组常量
    -->
       <Spinner
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:entries="@array/cities" 
           android:id="@+id/spinner"
           />
       
       <TextView 
       	android:layout_marginTop="30dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="自动提示文本框AutoCompleteTextView"
        />
       <!-- 自动提示文本框控件 
    	 android:completionThreshold 自动提示门限 默认是2，这里改成1 也就是输入一个字符即可提示
    -->
       <AutoCompleteTextView 
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:id="@+id/auto_tv"
           android:completionThreshold="1"
           />
       <TextView 
        android:layout_marginTop="30dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="多个自动提示文本框MultiAutoCompleteTextView"
        />
       <!-- 自动提示文本框控件 
    	 android:completionThreshold 自动提示门限 默认是2，这里改成1 也就是输入一个字符即可提示
   		 -->
     <MultiAutoCompleteTextView 
         android:layout_width="match_parent"
android:layout_height="wrap_content"
         android:id="@+id/multi_tv"
         android:completionThreshold="1"
         />

</LinearLayout>
在上面布局文件清单中Spinner控件有个比较特殊的属性需要引入外部文件。android:entries="@array/cities"。该属性值是一个布局文件，需要在工程中res/values/strings.xml中添加。下面不是strings.xml的文件清单，其中黄色背景是新添加的字符串常量，作为Spinner的备选项。
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">常用控件</string>
    <string name="action_settings">Settings</string>
    <string name="hello_world">Hello world!</string>
    <string-array name="cities">
        <item>北京</item>
        <item>上海</item>
        <item>广州</item>
        <item>深圳</item>
    </string-array>
</resources>
MainActivity代码清单如下：
package com.itheima.commonWidget;

import android.app.Activity;
import android.os.Bundle;
import android.os.SystemClock;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.MultiAutoCompleteTextView;
import android.widget.ProgressBar;
import android.widget.Spinner;
import android.widget.Toast;

public class MainActivity extends Activity {
	private ProgressBar progressBar;
	private Spinner spinner;
	private AutoCompleteTextView auto_tv;
	private MultiAutoCompleteTextView multi_tv;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		/*
		 * 初始化控件实例
		 */
		progressBar = (ProgressBar) findViewById(R.id.progressBar);
		auto_tv = (AutoCompleteTextView) findViewById(R.id.auto_tv);
		multi_tv = (MultiAutoCompleteTextView) findViewById(R.id.multi_tv);
		spinner = (Spinner) findViewById(R.id.spinner);
		/**
		 * 给spinner绑定选中事件，当选中某一项时触发该事件
		 * 
		 */
spinner.setOnItemSelectedListener(new OnItemSelectedListener() {
			/*
			 * 某个条目被选中后调用此函数
			 * 第三个参数 position 代表选中条目的索引
			 */
		@Override
		public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				/*
				 * 调用Spinner的getItemAtPosition(int position)方法，获取选中的对象
				 * 强制转换为String类型
				 */
				String city = (String) spinner.getItemAtPosition(position);
			Toast.makeText(MainActivity.this, "您选择的是：" + city, 0).show();
			}
			/*
			 * 什么都没有选择时调用次函数
			 */
		@Override
		public void onNothingSelected(AdapterView<?> parent) {
				Toast.makeText(MainActivity.this, "您什么都没选！", 0).show();
			}
		});
		//调用本类中自定义的私有方法显示进度条控件
		showProgressBar();
		//创建字符串数组
		String[] books = new String[]{"JavaScript网页开发","Android源码分析","深入理解JVM","Android-阳哥随堂笔记","Android-阳哥面试宝典","JavaEE入门"};
		//创建ArrayAdapter，在本文档的ListView控件中介绍过，因此不再重复介绍
		ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1, books);
//给自动文本提示框控件设置Adapter
		auto_tv.setAdapter(adapter);
		//给多文本提示框控件设置Adapter
		multi_tv.setAdapter(adapter);
		//给多文本提示框设置分隔符，这里使用逗号作为分隔符
		multi_tv.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());
	}
	/*
	 * 显示进度条控件
	 */
	 void showProgressBar() {
		new Thread(new Runnable() {

			@Override
			public void run() {
				while (true) {
					for (int i = 0; i < 100; i++) {
						//设置进度条的进度
						progressBar.setProgress(i + 1);
						SystemClock.sleep(100);
					}
				}
			}
		}).start();
	}

}
8.1. 进度条ProgressBar
进度条，与进度对话框有着类似的功能，也可以直接在子线程中控制其进度的改变。不同的是进度条一般嵌入在我们自定义的布局文件中，而进度对话框则单独占据一个布局（该布局系统自带提供）。
8.2. 下拉列表框Spinner
Spinner 是一个列表选择框，会在用户选择后，展示一个列表供用户进行选择。Spinner是ViewGroup的间接子类，它和其他的Android控件一样，数据需要使用Adapter进行封装。

8.3. 自动提示文本框AutoCompleteTextView
AutoCompleteTextView和EditText组件类似，都可以输入文本。AutoCompleteTextView组件可以和一个字符串数组或List对象绑定，当用户输入一个及以上字符时，系统将在AutoCompleteTextView组件下方列出字符串数组中所有以输入字符开头的字符串（只能提示一次）。
这一点和www.baidu.com、www.google.com的搜索框非常相似，当输入某一个要查找的字符串时，搜索框就会列出以这个字符串开头的最热门的搜索字符串列表。

8.4. 多个自动提示文本框MultiAutoCompleteTextView
功能类似AutoCompleteTextView,只不过AutoCompleteTextView只能提示一次，再遇到短信多人发送的情况时，只提示一次的AutoCompleteTextView使用不是很合适，所以就有了MultiAutoCompleteTextView。
调用MultiAutoCompleteTextView.setTokenizer方法为此控件设置一个值与值之间的分隔符即可，其余设置于AutoCompleteTextView类似。

8.5. 结合工作和面试
1. 面试中
面试中，这块问的不多。
2. 工作中
进度条用的还挺多，其他的了解，工作用到查阅笔记能做出来即可。
9. Android中的样式和主题（★★）
9.1. 样式
样式是作用在控件上的,是它是一个包含一个或者多个view控件属性的集合，例如定义属性fontColor、fontSize、layout_width、layout_height等，以独立的资源文件存放在XML文件中，并设置样式的名称。
Android Style类似网页设计中的级联样式CSS设计思路，可以让设计与内容分离，并且可以方便的继承、覆盖、重用。
下面通过一个简单的案例演示自定义样式的用法，在该案例中，我们自定义一个样式用于渲染Button控件的显示效果。
我们新创建一个Android工程，工程名称《样式和主题》。直接使用默认布局文件和默认Activity类。
1、 打开工程中res->values->styles.xml文件，添加如下样式。
<style name="btn_style">
        <item name="android:layout_height">wrap_content</item>
        <item name="android:layout_width">wrap_content</item>
        <item name="android:textSize">20sp</item>
        <item name="android:textColor">#ff0000</item>
        <item name="android:text">自定义样式</item>
    </style>
   <!--  继承上一个样式，相同的属性则覆盖父类 -->
     <style name="btn_style_child" parent="btn_style">
        <item name="android:textColor">#0000ff</item>
    </style>
2、 在默认布局文件中使用上面的自定义样式。
我们只需在如下布局文件中给Button一个style="@style/btn_style"属性，那么所有属性都会作用在该Button上。
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_gravity="center_horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Android中的样式和主题" />
    <Button 
        style="@style/btn_style"/>
</LinearLayout>
执行上面代码的效果如图：

同CSS一样，样式的引入遵循就近原则，在控件上定义的属性会覆盖被引入的样式中的同一个属性。
9.2. 主题
主题的定义与样式的定义相同，都是定义在styles.xml文件下，且均可以通过设置parent属性来继承一个父样式，不同之处在于主题是作用在Activity上的。
主题通过定义AndroidManifest.xml文件中的<application>和<activity>节点下的”android:theme”属性作用在整个应用或者某个Activity，主题对整个应用或某个Activity进行全局性影响。如果一个应用使用了主题，同时应用下的view也使用了样式，那么当主题和样式属性发生冲突时，样式的优先级高于主题。
android系统也定义了一些主题，例如：<activity android:theme=“@android:style/Theme.Dialog”>，该主题可以让Activity看起来像一个对话框，还有透明主题：@android:style/Theme.Translucent。如果需要查阅这些主题，可以在文档的reference-->android-->R.style中查看。
1、 继续使用本文档11.1中创建的工程。
在res->values->styles.xml中添加如下样式：
<!-- 
    	主题也是通过在styles.xml文件中定义<style>节点来定义。
    	同样式一样，指定一个全局唯一的名字给主题，通过parent属性继承父样式。
     -->
    <style name="theme_noTitle">
        <!-- 该属性使window界面无标题 -->
        <item name="android:windowNoTitle">true</item>
    </style>
    	<!-- 该属性使window界面全屏 -->
    <style name="them_noTitle_full" parent="theme_noTitle">
        <item name="android:windowFullscreen">true</item>
    </style>
2、 在AndroidManifest.xml中给添加样式
如下图清单黄色高亮部分。
<!-- 在application中引入主题 则所有activity都适用-->
    <application	
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/theme_noTitle" >
        <!-- 在activity中引入主题 则当前Activity适用-->
        <activity
            android:theme="@style/them_noTitle_full"
            android:name="com.itheima.styleAndTheme.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

也可以在Activity类中通过Java代码动态设置样式。
public class MainActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//给当前Activity设置主题
		setTheme(R.style.them_noTitle_full);
	}
}
以上代码中设置的主题是全屏功能，那么全屏通过代码如何设置。activity中直接调用requestWindowFeature(window.Feature_n_title)。窗体特性，无标题
10. Android实现国际化（★★）
国际化的英文单词是Internationalization，因为这个单词太长了，有时也简称为I18N，其中的I是这个单词的第一个字符，18表示中间省略的字母个数，而N代表这个单词的最后一个字母。所以，I18N也就是国际化的意思。
Android程序国际化，也就是程序可以根据系统所使用的语言，将界面中的文字翻译成与之对应的语言。这样，可以让程序更加通用。Android可以通过资源文件非常方便的实现程序的国际化。
10.1. Android中如何实现国际化
在编写Android项目时，通常都是将程序中要使用的字符串资源放置在res/values目录下的strings.xml文件中，为了给这些字符串资源实现国际化，可以在Android项目的res目录下，创建对应于各个语言的资源文件夹（例如，为了让程序兼容简体中文、繁体中文和美式英文，可以分别创建名称为values-zh-rCN、values-zh-rTW和values-en-rUS的文件夹），然后在每个文件夹中创建一个对应的strings.xml文件，并在该文件中定义对应语言的字符串即可。这样，当程序运行时，就会自动根据操作系统所使用的语言来显示对应的字符串信息了。
图片也可以进行国际化，同字符串的国际化类似，只需根据程序要兼容的语言版本，分别创建名称类似drawable-zh-rCN,drawable-zh-rTW这样的文件夹，将图片资源存放在文件夹下即可。
10.2. 国际化示例
1、 在res文件下分别创建values-zh-rCN和values-zh-rTW文件夹，分别在两个文件夹下创建strings.xml文件。
给values-zh-rCN/settings.xml添加内容如下：
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">国际化</string>
    <string name="action_settings">设置简体</string>
    <string name="hello_world">简体字，心怀大志就莫虚度光阴！</string>
</resources>
给values-zh-rTW/settings.xml添加内容如下：
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">國際化</string>
    <string name="action_settings">設置</string>
    <string name="hello_world">繁體字，心懷大志就莫虛度光陰！</string>
</resources>

2、 在res文件下分别创建drawable-zh-rCN和drawable-zh-rTW文件夹，向里面各自添加一个flag.jpg的图片。第一个为为五星红旗、第二个为青天白日旗。图片的名字必须一致。

3、 修改该工程的默认布局文件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />
    <ImageView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/flag"
        />
</LinearLayout>
4、 设置模拟器的语言为简体中文
Menu->System settings->Language&input->Language->中文（简体）。然后运行改程序，效果图如下：
      
设置模拟器的语言为简体中文。Menu->System settings->Language&input->Language->中文（繁体）。然后运行改程序，效果右图所示。
11. Android中的动画（★★★）
Android 3.0以前，Android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 在本文档中只介绍tween animation和frame animation。
	Frame Animation(帧动画)：创建一个Drawable序列，这些Drawable可以按照指定的时间间隔一个一个的显示，也就是顺序播放事先做好的图像。
	Tween Animation(渐变动画)：通过对特定的对象做图像变换如平移、缩放、旋转、淡出/淡入等产生动画效果。
11.1. 帧动画FrameAnimation
Drawable Animation（Frame Animation）：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。
下面通过一个案例来演示帧动画的使用方法。新创建一个工程《Android中的动画》。
将准备好的图片文件放到res/drawable-hdpi目录中。如果大家缺乏图片资源可以随便放进去几张图片就行，只要起到练习代码的作用就行。
在项目的res目录下创建文件夹drawable，然后在文件夹下面定义动画XML文件，文件名称可以自定义（也可以使用AnimationDrawable类，采用代码方式定义动画效果），这里给改xml文件起名为frame_anim.xml。
打开创建好的xml文件，在里面添加根节点<animation-list>,可以在此根节点中设置属性”android:oneshot”来控制动画只播放一次，否则系统将默认持续播放。
在根节点<animation-list>下为帧动画的每幅图片添加一个<item>节点，节点的”android:drawable”属性是图片的资源id，”android:duration”属性指定图片展示的时间（一般每秒展示5-8张图片就可以感受到动画的效果）。
<?xml version="1.0" encoding="utf-8"?>
<animation-list xmlns:android="http://schemas.android.com/apk/res/android" 
    android:oneshot="true">
  <item android:drawable="@drawable/a1" android:duration="200"></item>
 <item android:drawable="@drawable/a2" android:duration="200"></item>
<!-----------------更多item不再展示--------------------->
</animation-list>
1、 编写默认的Activity类。
public class MainActivity extends Activity {
	private ImageView iv;
	private AnimationDrawable animationDrawable;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		iv = (ImageView) findViewById(R.id.iv);
		iv.setImageResource(R.drawable.frame_anim);
animationDrawable =  (AnimationDrawable) iv.getDrawable();

	}
	public void startAnimation(View view){// 点击按钮调用此方法
		if(animationDrawable.isRunning())animationDrawable.stop();
animationDrawable.start();
	}
}

注意点：
在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次。
最后一点是SDK中提到的，不要在onCreate中调用start，因为AnimationDrawable还没有完全跟Window相关联，如果想要界面显示时就开始动画的话，可以在onWindowFoucsChanged()中调用start()。

2、 运行该程序效果如下图：


11.2. 渐变动画TweenAnimation
	View Animation（Tween Animation）：补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。
	渐变包括：包括平移、缩放、旋转、改变透明度。动画效果的定义可以采用XML来做也可以采用java代码来做。补间动画有4种类型：

补间动画的常用方法：
Animation：
setDuration		设置动画的执行时间
setRepeatCount	设置动画的重复次数
setRepeatMode		指定重复的模式（如：反转）
setFillAfter		指示动画指定完毕之后控件的状态是否停留在动画停止的时候
setAnimationListener	设置动画的事件监听器
 View：
startAnimation(Animation a) 让View执行某动画
11.3. Alpha 渐变动画
渐变动画在代码中使用的是AlphaAnimation类来定义， 在XML文件中使用<alpha>节点来定义。
下面分别演示使用XML文件和Java代码的方式实现Alpha渐变动画。在这里依然使用本文档13.1章节中的工程。
使用XML文件实现Alpha动画
1、 在res目录下创建anim文件夹
2、 在anim文件夹中创建alpha_anim.xml文件，文件名自定义
3、 编辑alpha_anim.xml文件，具体代码如下所示。
<?xml version="1.0" encoding="utf-8"?>
<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:fromAlpha="1"
    android:repeatCount="2"
    android:toAlpha="0" 
    android:repeatMode="restart">
</alpha>
4、 添加Java逻辑代码:使用AnimationUtils工具类加载xml文件，获取Animation对象；调用startAnimation让ImageView执行此动画。
这里需要在13.1章节的默认布局文件（activity_main.xml)中添加一个Button，并为该Button指定android:onClick="startAlphaAnimation"属性，在MainActivity中实现该方法，具体代码如下所示：
public void startAlphaAnimation(View view){
		//通过AnimationUtils加载定义的动画文件
		Animation animation = AnimationUtils.loadAnimation(this, R.anim.alpha_anima);
		//给iv设置一个图片
		iv.setImageResource(R.drawable.me);
		//iv开始播放动画
		iv.startAnimation(animation);
	}

运行效果截图比较简单，且截图是静态的，因此不再给出。
	使用编码方式实现Alpha动画
public void startAlphaAnimation(View view){
		/*
		 * 创建一个动画类AlphaAnimation
		 * 第一个参数是开始透明度
		 * 第二个参数是结束透明度
		 */
		Animation animation = new AlphaAnimation(0, 1);
		//设置持续时间
		animation.setDuration(2000);
		//设置重复次数
		animation.setRepeatCount(2);
		//设置重复方式 Animation.RESTART代表重新开始播放
		animation.setRepeatMode(Animation.RESTART);
		//设置是否保持动画结束后的状态
		animation.setFillAfter(true);
		//绑定动画事件
		animation.setAnimationListener(new AnimationListener() {
			
			@Override
			public void onAnimationStart(Animation animation) {
				Toast.makeText(MainActivity.this, "动画开始播放", 0).show();
			}
			@Override
			public void onAnimationRepeat(Animation animation) {
				Toast.makeText(MainActivity.this, "动画重复中...", 0).show();
			}
			@Override
			public void onAnimationEnd(Animation animation) {
				Toast.makeText(MainActivity.this, "动画结束", 0).show();
			}
		});
		//给iv设置一个图片
		iv.setImageResource(R.drawable.me);
		//iv开始播放动画
		iv.startAnimation(animation);
	}
11.3.1. Scale 伸缩动画
在本文档13.1章节中创建的工程中的布局文件中添加ScaleAnimation按钮，在Activity类中设置改按钮的绑定事件。布局文件十分简单，因此这里就不再给出详细布局清单。
Activity类中添加scaleAnimation(View view)方法，方法清单如下：
public void scaleAnimation(View view){
		/*
		 * 第一个参数 fromX x轴起始大小(这个大小指倍数，它内部会用这个倍数去乘实际像素)
		 * 第二参数 toX 轴截止大小(若起始大小=截止大小就是指x轴不伸缩)
		 * 第三个参数fromY Y轴的起始大小
		 * 第四个参数toY 轴的截止大小
		 * 第五个参数pivotXType X轴的原点的类型（相对于自己而言还是相对于父容器而言）
		 * 第六个参数pivotXValue 开始伸缩时的X轴的原点(例:0.5就是指以图片宽度的二分之一的位置作为X轴的原点)
		 * 第七个参数pivotYType Y轴的原点的类型
		 * 第八个参数pivotYValue 开始伸缩时的Y轴的原点
		 */
		Animation sa = new ScaleAnimation(1,1.5f, 1, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF,0.5f);
		sa.setDuration(2000);
		sa.setRepeatCount(5);
		sa.setRepeatMode(Animation.REVERSE);
		sa.setFillBefore(true);
		iv.setImageResource(R.drawable.me);
		iv.setAnimation(sa);
		sa.start();
	}

11.3.2. Translate 位移动画
在本文档13.1章节中创建的工程中的布局文件中添加TranslateAnimation按钮，在Activity类中设置改按钮的绑定事件。布局文件十分简单，因此这里就不再给出详细布局清单。Activity类中添加translateAnimation(View view)方法，方法清单如下：
public void translateAnimation(View view){
		/*
		 * 第一个参数 fromXType 位移的x轴起始坐标的类型(相对于自己还是相对父容器)
		 * 第二参数 fromXValue x轴起点(0:自身最左边的x坐标  1：最右边的x坐标)
		 * 第三个参数toXType X轴终点坐标的类型
		 * 第四个参数toXValue X轴的终点
		 * 第五个参数fromYType Y轴起始坐标的类型
		 * 第六个参数fromYValue Y轴的起始坐标
		 * 第七个参数toYType Y轴的终点坐标的类型
		 * 第八个参数toYValue Y轴的终点坐标
		 * 
		 * 下面代码的效果是：以自身的左上角为位移的原点，向右平移，平移距离=自身大小
		 */
		Animation sa = new TranslateAnimation(Animation.RELATIVE_TO_SELF,0f, Animation.RELATIVE_TO_SELF, 1, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF,0.f);
		sa.setDuration(2000);
		sa.setRepeatCount(5);
		sa.setRepeatMode(Animation.REVERSE);
		sa.setFillBefore(true);
		iv.setImageResource(R.drawable.me);
		iv.setAnimation(sa);
		sa.start();
	}
11.3.3. Rotate 旋转
在本文档13.1章节中创建的工程中的布局文件中添加RotateAnimation按钮，在Activity类中设置改按钮的绑定事件。布局文件十分简单，因此这里就不再给出详细布局清单。Activity类中添加RotateAnimation(View view)方法，方法清单如下：
public void rotateAnimation(View view){
		/*
		 *第一个参数 fromDegrees：旋转的起始角度
		 *第二个参数 toDegrees:旋转的结束角度
		 *第三个参数 pivotXType:X轴原点的类型(相对于自身还是相对于父容器)
		 *第四个参数 pivotXValue:原点的X轴坐标
		 *第五个参数 pivotYType： Y轴原点的类型
		 *第六个参数pivotYValue:原点的Y轴坐标
		 *
		 * 下面代码的效果是：以自身中心点为旋转的原点，从左45度角摆动到右45
度角
		 */
		Animation ar = new RotateAnimation(-45,45,RotateAnimation.RELATIVE_TO_SELF, 0.5f,RotateAnimation.RELATIVE_TO_SELF, 0.5f);
		ar.setDuration(2000);
		ar.setRepeatCount(5);
		ar.setRepeatMode(Animation.REVERSE);
		ar.setFillBefore(true);
		iv.setImageResource(R.drawable.me);
		iv.setAnimation(ar);
		ar.start();
	}

11.3.4. AnimationSet动画的集合
动画集合在代码中使用的是AnimationSet类来定义， 在XML文件中使用<set>节点来定义。
下面分别演示使用XML文件和Java代码的方式实现动画集合。在这里依然使用本文档13.1章节中的工程。
使用XML文件实现动画
在res/anim目录下创建xml文件，anim_set.xml。文件清单如下：
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false">
   <alpha
        android:duration="2000"
        android:fillAfter="true"
        android:fromAlpha="1"
        android:repeatCount="2"
        android:repeatMode="reverse"
        android:toAlpha="0" >
    </alpha>
    <scale
        android:duration="2000"
        android:fillAfter="true"
        android:fromXScale="0"
        android:fromYScale="0"
        android:repeatCount="2"
        android:repeatMode="reverse"
        android:toXScale="3"
        android:toYScale="3" >
    </scale>
    <translate
        android:duration="2000"
        android:fillAfter="true"
        android:fromXDelta="0"
        android:fromYDelta="0%"
        android:repeatCount="2"
        android:repeatMode="reverse"
        android:toXDelta="500%"
        android:toYDelta="300%" >
    </translate>
    <rotate
        android:duration="2000"
        android:fillAfter="true"
        android:fromDegrees="0"
        android:pivotX="50%"
        android:pivotY="50%"
        android:repeatCount="2"
        android:repeatMode="reverse"
        android:toDegrees="360" >
    </rotate>
</set>

在Activity中添加如下方法，实现业务功能：
public void animationSet(View view) {
		//加载动画集合文件
		Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_set);
		iv.setAnimation(animation);
		animation.start();
	}
使用Java代码实现动画
在该工程的默认布局文件中添加Button，并给该Button指定一个onClick事件，触发的方法名为animationSet2在Activity类中添加如下方法：
public void animationSet2(View view) {
		//创建AnimationSet实例
		AnimationSet set = new AnimationSet(false);
		//创建一个普通动画实例
		AlphaAnimation aa = new AlphaAnimation(0.f, 1.f);
		aa.setDuration(2000);
		iv.setAnimation(aa);
		//创建一个普通动画实例
		Animation sa = new ScaleAnimation(1, 1.5f, 1, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
		sa.setDuration(2000);
		sa.setRepeatMode(Animation.REVERSE);
		iv.setAnimation(sa);
		//将普通动画实例添加到AnimationSet中
		set.addAnimation(aa);
		set.addAnimation(sa);
		//启动集合动画
		set.start();
		
	}
11.3.5. Tween动画特性 
View animation只能应用于View对象，而且只支持一部分属性，如支持缩放旋转而不支持背景颜色的改变。
而且对于View animation，它只是改变了View对象绘制的位置，而没有改变View对象本身，比如，你有一个Button，坐标（100,100），Width:200,Height:50，而你有一个动画使其变为Width：100，Height：100，你会发现动画过程中触发按钮点击的区域仍是(100,100)-(300,150)。
11.4. 结合工作和面试
1. 面试中
属性动画 这个问的比较多
Property 动画，属性动画，Android 3.0引进。tween动画他执行完动画后是不改变控件的位置与大小，不改变他的点击区域。就是说不改变熟悉。属性动画就是可以改变控件真是的位置、大小。
2. 工作中
工作中用的非常多，因为Android应用很多酷炫的效果都是通过动画实现的，所以需要掌握。
12. Android网络编程（★★★）
在当今互联网时代，我们在公司写的Android程序基本不可能不联网的，网络编程是任何一个Android程序员必备的技能。
12.1. 网络编程的预备知识
访问网络的Android应用都必须加上访问互联网的权限：
android.permission.INTERNET
 开启子线程执行网络或者耗时的操作
在Android中凡是对UI的更新、“耗时”操作等都需要在子线程中进行。Android4.0以上版本，Google更加在意UI界面运行的流畅性，强制要
求访问网络的操作不允许在主线程中执行，只能在子线程中进行，在主线程请求网络时，会报如下错误：
android.os.NetworkOnMainThreadException
ANR异常：
Application Not Response,应用程序无响应。在主线程中做一些耗时的操作，阻塞了主线程，当用户点击其时，主线程无法响应，这是就会出ANR异常。
 子线程不能修改UI
主线程也叫UI线程,Activity中的onCreate方法和点击事件的方法都是运行在主线程中的。主线程创建的界面,只有主线程才能修改，别的线程不允许修改UI，否则会报如下错误：
CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.

如果子线程修改了UI，系统会验证当前线程是不是主线程，如果不是主线程，就会终止运行。
既然子线程不能修改主线程的UI那么，我们的子线程如果需要修改UI该怎么办呢？
解决方式：
使用Handler实现子线程与主线程之间的通信。消息处理机制原理：所有使用UI界面的操作系统，后台都运行着一个死循环（Looper），在不停的监听和接收用户发出的指令，一旦接收指令就立即执行。关于Handler的使用会在接下来的案例中介绍，这里先点到为止。
Handler具体用法：
Handler：直接new，在主线程实例化。然后在新线程中，使用handler向主线程发送一段代码。通过handler.post(Runnable对象);向创建Handler的线程发一个runnable，重写run方法，run方法中写入需要传递的代码。run方法传递的代码，由主线程来执行。
模拟器如何访问本地Tomcat
模拟器把它自己作为了localhost，也就是说，代码中使用localhost或者127.0.0.1来访问，都是访问模拟器自己！若想在模拟器上面访问我们的电脑，那么就使用android内置的IP: 10.0.0.2，10.0.0.2是模拟器设定的特定ip,在模拟器上用 10.0.0.2就能成功访问我们的电脑本机。
12.2. HttpURLConnection发送GET请求
拼接路径和参数，通过URL进行封装，打开一个HttpURLConnection，发送请求。如果参数是中文会出现乱码，URL中包含的中文参数需要使用URLEncoder进行编码。服务器端如果是TOMCAT，其默认使用ISO8859-1编码，接收时需要处理编码问题
模拟登陆请求：//传入用户名、密码
public static boolean doGet(String nameString, String password) throws Exception {
		String urlString="http://192.168.1.42:8080/net/login";
		//参数，需要通过UrlEncode编码
String paramString="name="+URLEncoder.encode(nameString,"utf-8")+"&password="+URLEncoder.encode(password,"utf-8");
		//GET请求，访问的url是带参数的
URL url=new URL(urlString+"?"+paramString);
		HttpURLConnection connection=(HttpURLConnection) url.openConnection();
		connection.setReadTimeout(5000);
		//设置请求方式：GET，必须是大写
		connection.setRequestMethod("GET");
		int code = connection.getResponseCode();
		if(code==200){
			return true;
		}
		return false;
	}
12.3. HttpURLConnection发送POST请求
通过URL打开一个HttpURLConnection。头信息中除了超时时间和请求方式之外还必须设置Content-Type和Content-Length。从HttpURLConnection获得输出流输出参数数据，服务端可以使用request对象的setCharacterEncoding方法设置编码。
//还是模拟登陆功能
	public static boolean doPost(String name, String passwrod) throws Exception {
		String urlString="http://192.168.1.42:8080/net/login";
		String paramString="name="+URLEncoder.encode(name,"utf-8")+"&password="+URLEncoder.encode(passwrod,"utf-8");
		//POST请求，访问的url是不带参数的
URL url=new URL(urlString);
	    HttpURLConnection connection=	(HttpURLConnection) url.openConnection();
	    connection.setReadTimeout(5000);
		//设置POST请求特有的请求头：
	    connection.setRequestProperty("content-type", "application/x-www-form-urlencoded");
		//内容长度，即为请求体中参数的长度
	    connection.setRequestProperty("content-length", paramString.length()+"");
	    connection.setRequestProperty("host", "192.168.1.42:8080");
		//设置写出操作的标志为ture，意味着要想服务器写数据
	    connection.setDoOutput(true);
	    OutputStream os = connection.getOutputStream();//获取输出流
	    os.write(paramString.getBytes());//写数据
	    int code = connection.getResponseCode();
	    if(code==200){
	    	return true;
	    }
	    
		return false;
	}
为什么get请求方式不需要用输出流将内容写给服务器，因为get请求的请求参数在url后，没有请求体，不需要单独传递。
12.4. 案例-获取文本数据
思路：
1. 通过URL对象封装地址，打开一个HttpURLConnection
2. 设置头信息之后获取响应码，如果成功返回200即可从HttpURLConnection中获取输入流读取数据
3. 代码过长屏幕显示不全可以使用<ScrollView>进行显示
4. 需要访问网络的权限
<uses-permission android:name="android.permission.INTERNET" />
代码：
	private EditText edt_path = null;
	private TextView tv_content = null;
	private final Handler handler = new Handler(); 
//主线程中实例化Handler
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		edt_path = (EditText) findViewById(R.id.edt_path);
		tv_content = (TextView) findViewById(R.id.tv_content);
	}

	public void go(View v) {
		final ProgressDialog dialog=new ProgressDialog(this);
		dialog.show();
		new Thread() {//启动新线程连接网络，下载数据
			public void run() {
				try {
					String path = edt_path.getText().toString().trim();
					final String content = NetService.getText(path);
					handler.post(new Runnable() {
//通过handler，将修改组件的代码交给实例化handler的线程(在这里是主线程)
						public void run() {
							tv_content.setText(content);
							dialog.dismiss();
						}
					});
				} catch (Exception e) {
					e.printStackTrace();
					Toast.makeText(getApplicationContext(), "服务器忙", Toast.LENGTH_SHORT).show();
				}
			}
		}.start();
	}
通过网络，获取text的方法
	public static String getText(String path) throws Exception {
		URL url=new URL(path);
		HttpURLConnection connection= (HttpURLConnection) url.openConnection();
		connection.setConnectTimeout(5000);
		int code = connection.getResponseCode();
		if(code==200){
			InputStream is = connection.getInputStream();
			ByteArrayOutputStream boStream=new ByteArrayOutputStream();
			int len=0;
			byte [] buf=new byte[1024];
			while((len=is.read(buf))>0){
				boStream.write(buf,0,len);
			}
			boStream.close();
			is.close();
			String result=new String (boStream.toByteArray(),"gbk");
			return result;
		}
		throw new RuntimeException("访问网络异常："+code);
	}
进度条的使用：
ProgressDialog：dialog.show();  显示进度条
dialog.setCancleable(false);//设置进度条不能被取消
              dialog.dismiss();取消进度条
12.5. 案例-获取网络图片
思路：
1. 通过BitmapFactory的decodeByteArray(byte[] data, int offset, int length)方法将数据转换为图片对象
2. 第二次下载图片，拿缓存文件。
下载图片时，保存图片到本地：保存到应用的缓存文件夹内。这个在下载完图片，返回页面显示之前，保存图片到本地，会消耗一定时间，所以这个保存操作最好再开一个线程。在下载之前，判断缓存是否存在，如果存在，就把最后修改时间发送过去
获取文件最后时间file.getLastModify();发送最后修改时间请求头：conn.setRequestProperty("if-modified-since");或者conn.setIfModifiedSince(时间);如果是200，则从网络上拿。如果是304，读取本地缓存：   BitMapFactory.decodeFile();可以直接将文件，转换成bitmap。
代码
获取网络图片的方法，activity中设置可以通过imageVIew.setImageBitMap(bitmap对象)，设置图片。
	public static Bitmap getImage(File cacheDir,String path) throws Exception {
		URL url=new URL(path);
		HttpURLConnection connection= (HttpURLConnection) url.openConnection();
		connection.setConnectTimeout(5000);
		File file=new File(cacheDir,URLEncoder.encode(path,"utf-8"));
		if(file.exists()){
			connection.setIfModifiedSince(file.lastModified());
		}
		int code = connection.getResponseCode();  //这个代码必须放在conn设置请求头参数之后，不然会报异常：Connection already established
		System.out.println(code);
		if(code==200){
			InputStream is= connection.getInputStream();
			FileOutputStream fos=new FileOutputStream(file);
			ByteArrayOutputStream bos=new ByteArrayOutputStream();
			int len=0;
			byte [] buf=new byte[1024];
			while((len=is.read(buf))>0){
				fos.write(buf,0,len);
				bos.write(buf,0,len);
			}
			fos.close();
			bos.close();
			is.close();
			byte [] data=bos.toByteArray();
			return BitmapFactory.decodeByteArray(data, 0, data.length);
			
		}else if (code==304){
			return BitmapFactory.decodeFile(file.getAbsolutePath());
		}
		throw new RuntimeException("访问服务器异常："+code);
	}
12.6. 案例-网络图片查看器
需求：实现一个网络图片查看器，在页面输入框填入网络图片的地址，点击访问按钮，可以访问网络并获取图片，并显示在界面上。
1. 新创建一个工程，工程名字《网络图片查看器》。
2. 在工程清单文件（AndroidManifest.xml）中添加访问网络权限
<uses-permission android:name="android.permission.INTERNET"/>
使用并修改默认的布局文件（activity_main.xml）。
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity" 
    android:orientation="vertical" >
    <ImageView 
        android:layout_height="0dp"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:id="@+id/iv"/>
    <EditText 
        android:layout_height="wrap_content"
        android:layout_width="match_parent"
        android:hint="请输入地址"
android:text="http://g.hiphotos.baidu.com/image/pic/item/6159252dd42a2834d277681659b5c9ea14cebfde.jpg"
        android:id="@+id/et"/>
    <Button 
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:text="获取图片"
        android:onClick="getImage"/>
</LinearLayout>


使用并编辑默认的Activity（MainActivity.java）
public class MainActivity extends Activity {
	private ImageView imageView;
	//创建一个Handler对象，用户接收子线程发送的消息，然后更新UI
	private Handler handler = new Handler(){
		@Override
		public void handleMessage(Message msg) {
			super.handleMessage(msg);
			//将数据强转转化为Bitmap,然后显示在ImageView控件中
			imageView.setImageBitmap((Bitmap) msg.obj);
		}
	};
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		imageView = (ImageView)findViewById(R.id.iv);
	}
	public void getImage(View view) {
		//开启一个子线程 处理网络请求
			new Thread(new Runnable() {		
				@Override
				public void run() {
					try {
						//从页面获取URL地址
						EditText editText = (EditText)findViewById(R.id.et);
						String path = editText.getText().toString();
						//调用Android API中的TextUtils工具类判断路径是否为空
						if (TextUtils.isEmpty(path)) {
							Looper.prepare();
							Toast.makeText(MainActivity.this, "请输入URL", 0).show();
							Looper.loop();
							return;
						}
						URL url = new URL(path);
						//获取HttpURLConnection链接对象
						HttpURLConnection connection = (HttpURLConnection)url.openConnection();
						//设置请求方法为GET方式
						connection.setRequestMethod("GET");
						//设置链接超时时间
						connection.setConnectTimeout(50000);
						//设置输入流读取超时时间
						connection.setReadTimeout(50000);
						//打开链接，发送请求
						connection.connect();
						//判断返回的状态码
						if(connection.getResponseCode()==200){
							//获取输入流对象
							InputStream inputStream = connection.getInputStream();
							//调用Android API提供的BitmapFactory工具类将字节流转化为位图
							Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
							//创建一个新的消息
							Message message = new Message();
							//将数据绑定消息
							message.obj = bitmap;
							//调用handler发送消息给主线程
							handler.sendMessage(message);
						}
					} catch (Exception e) {
						e.printStackTrace();
					}		
				}
			}).start();
	}
}
运行上面的工程，效果图如下：输入百度图片的一个网址
http://g.hiphotos.baidu.com/image/pic/item/6159252dd42a2834d277681659b5c9ea14cebfde.jpg
运行效果如下：

12.7. 案例-网页源码查看器
需求：实现一个网页源码查看器，在页面输入框填入网页的地址，点击访问按钮，可以读取网页并显示在界面上。
该案例跟14.6章节案例类似，因此可以直接在14.6章节中创建的工程中修改，当然新建工程也可以。使用Button按钮、EditText控件、TextView控件设置布局，在网络访问时，将接收到的二进制流转换成字符串，将字符串交由handler修改TextView的显示即可。
因为布局比较简单，处于节约篇幅的考虑就不再给出布局清单，这里只给出Activity类代码清单。MainActivity.java代码如下：
public class MainActivity extends Activity {
	//定义两个常量用于代表消息的类型
	private static final int ERROR = 0;
	private static final int OK = 1;
	Handler handler = new Handler(){
		@Override
		public void handleMessage(Message msg) {
			super.handleMessage(msg);
			//获取界面的TextView对象实例
			TextView tv = (TextView)findViewById(R.id.tv);
			//如果接收到的信息为OK，则将结果显示出来
			if (msg.what==OK) {
				tv.setText((String)msg.obj);
			//如果ERROR则提示错误信息
			}else if (msg.what==ERROR) {
				tv.setText("对不起，页面加载失败！");
			}
		}
	};
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
	//界面Button绑定的事件
	public void load(View view){
		EditText editText = (EditText)findViewById(R.id.et);
		if (TextUtils.isEmpty(editText.getText().toString())) {
			Toast.makeText(this, "请输入网页的URL", Toast.LENGTH_SHORT).show();
			return;
		}
		//调用本类自定义方法，实现网页抓取
		getContent(editText.getText().toString());
	}
	private void getContent(final String path){
		final StringBuilder sb = new StringBuilder();
		new Thread(new Runnable() {	
			@Override
			public void run() {
				URL url;
				try {
					//根据url地址创建一个URL对象
					url = new URL(path);
					//创建一个HttpURLConnection对象
					HttpURLConnection connection = (HttpURLConnection)url.openConnection();
					//设置连接超时为5秒
					connection.setConnectTimeout(5000);
					//设置读取数据流超时为5秒
					connection.setReadTimeout(5000);
					//设置请求方式为GET
					connection.setRequestMethod("GET");
					//开始连接
					connection.connect();
					//获取返回状态码
					int responseCode = connection.getResponseCode();
					if(responseCode==200){//如果成功
						//获取字节流
						InputStream inputStream = connection.getInputStream();
						//将字节流转化为BufferedReader
						BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
						String tmp = null;
						while((tmp=bufferedReader.readLine())!=null){
							sb.append(tmp);
						}
						//新创建个消息对象
						Message msg = new Message();
						//设置消息的类型为OK（自定义，用于自己区分不同的消息）
						msg.what = OK;
						//给消息绑定数据
						msg.obj = sb.toString();
						//将消息发给主线程
						handler.sendMessage(msg);
					}else {//如果请求失败
						//发送一个空消息
						handler.sendEmptyMessage(ERROR);
					}
				} catch (Exception e) {
					e.printStackTrace();
					handler.sendEmptyMessage(ERROR);
				}
			}
		}).start();
	}
}

运行以上程序，结果图如下：

12.8. 案例-新闻客户端
需求：使用ListView控件实现一个新闻客户端，新闻信息以XML文件的格式存储，通过网络访问存放新闻信息的XML文件，解析此文件，逐条信息生成ListView的item，添加到ListView中，在界面上呈现出来。
1. 创建一个新工程，工程名为《新闻客户端》，包名为com.itheima.news，在清单文件中添加访问网络权限。
<uses-permission android:name="android.permission.INTERNET"/>
2. 使用并编辑默认布局文件activity_main.xml，布局文件清单如下：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity" >
    <ListView 
        android:layout_height="match_parent"
        android:layout_width="match_parent"
        android:id="@+id/lv"
        ></ListView>
</RelativeLayout>
3. 在res/layout目录下创建item.xml文件，作为第二步骤中ListView的item布局文件。该布局文件采用相对布局，布局清单如下：
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:id="@+id/rl">
     <!-- 引入第三方控件用于显示图片 -->
    <com.loopj.android.image.SmartImageView 
        android:id="@+id/iv"
        android:layout_height="match_parent"
      	android:layout_width="60dp"
      	android:contentDescription="news"
        />
    <!-- 创建一个LinearLayout，采用垂直布局方式 -->
    <LinearLayout 
        android:layout_height="match_parent"
        android:layout_width="match_parent"
        android:orientation="vertical"
        android:layout_toRightOf="@id/iv"
        >
        <!-- 用于显示新闻的标题 -->
        <TextView 
            android:layout_height="0dp"
            android:layout_width="match_parent"
            android:singleLine="true"
            android:id="@+id/tv_title"
            android:layout_weight="1"
            />
        <!-- 用于显示新闻正文内容 -->
        <TextView 
            android:layout_height="0dp"
            android:layout_width="match_parent"
            android:singleLine="true"
            android:id="@+id/tv_content"
            android:layout_weight="3"
            />
        <!-- 用于显示评论次数 -->
        <TextView 
            android:layout_height="0dp"
            android:layout_width="match_parent"
            android:singleLine="true"
            android:id="@+id/tv_commen"
            android:layout_weight="1"
            />
    </LinearLayout>

</RelativeLayout>

在上面的布局文件中我们采用了开源框架SmartImageView控件来显示图片。在布局文件声明此控件时需写全包路径，否则将无法找到。关于SmartImageView的用法将会在下面的撞见中详细介绍。该框架很小巧，只需将如下文件添加到工程中。

4. 编写一个JavaBean用于封装新闻对象。类名：News
public class News {
	private Integer id;//新闻id
	private String title;//新闻标题
	private String detail;//新闻内容详情
	private String image;//新闻图片链接地址
	private String comment;//评论
	//省略setter&getter方法
5. 在本地tomcat的webapps目录下创建news文件夹，然后将news.xml和image文件添加到改文件夹中。查看本机的IP地址，并修改news.xml文件。然后启动tomcat。部署后的tomcat目录结构如下截图。

其中news.xml的文件清单如下：
<?xml version="1.0" encoding="UTF-8" ?>
<newslist>
	<news>
		<title>尚学堂程序员37期就业快报</title>
		<detail>热烈祝贺尚学堂程序员37期平均薪水突破12k</detail>
		<comment>15687</comment>
		<image>http://172.16.0.61:8080/a/images/a6.jpg</image>
	</news>
	<news>
		<title>程序员因写代码太乱被杀害</title>
		<detail>凶手是死者同事，维护死者代码时完全看不懂而痛下杀手</detail>
		<comment>16359</comment>
		<image>http://172.16.0.61:8080/a/images/a7.jpg</image>
	</news>
	<news>
		<title>产品经理因频繁改需求被杀害</title>
		<detail>凶手是一名程序员，因死者对项目需求频繁改动而痛下杀手</detail>
		<comment>14112</comment>
		<image>http://172.16.0.61:8080/a/images/a7.jpg</image>
	</news>
	<news>
		<title>3Q大战宣判: 腾讯获赔500万</title>
		<detail>最高法驳回360上诉, 维持一审宣判.</detail>
		<comment>6427</comment>
		<image>http://172.16.0.61:8080/a/images/a1.jpg</image>
	</news>
	<news>
		<title>今日之声:北大雕塑被戴口罩</title>
		<detail>市民: 因雾霾起诉环保局; 公务员谈"紧日子": 坚决不出去.</detail>
		<comment>681</comment>
		<image>http://172.16.0.61:8080/a/images/a2.jpg</image>
	</news>
</newslist>
6. 使用并编辑默认MainActivity.java，在该类中实现所有方法。
public class MainActivity extends Activity {
	//设置新闻访问地址
	private String path = "http://172.16.0.67:8080/news/news.xml";
	Handler handler = new Handler(){
		@Override
		public void handleMessage(Message msg) {
			super.handleMessage(msg);
			final List<News> list = (List<News>)msg.obj;
			//实例化ListView对象
			ListView listView = (ListView)findViewById(R.id.lv);
			//给ListView设置适配器
			listView.setAdapter(new BaseAdapter() {
				
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					if(convertView==null){
						convertView =  (RelativeLayout)View.inflate(MainActivity.this, R.layout.item, null);
					}else{
						return convertView;
					}
						News news = list.get(position);
						//实例化SmartImageView对象
						SmartImageView imageView = (SmartImageView)convertView.findViewById(R.id.iv);
						//给SmartImageView设置一个图像的URL则SmartImageView会自动加载图片
						imageView.setImageUrl(news.getImage());
						TextView connenTextView = (TextView)convertView.findViewById(R.id.tv_commen);
						connenTextView.setText("评论："+news.getComment());
						TextView contentTextView = (TextView)convertView.findViewById(R.id.tv_content);
						contentTextView.setText(news.getDetail());
						TextView titleTextView = (TextView) convertView.findViewById(R.id.tv_title);
						titleTextView.setText(news.getTitle());
					

					return convertView;
				}
				@Override
				public long getItemId(int position) {
					return position;
				}
				@Override
				public Object getItem(int position) {
					return null;
				}
				@Override
				public int getCount() {
					return list.size();
				}
			});
		}
	};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//调用本类私有方法完成网络访问
		getString();
	}
	//开启子线程下载数据
	private String getString() {
			new Thread(new Runnable() {
				@Override
				public void run() {
					XmlPullParserFactory parserFactory;
					//创建一个集合，用于存储新闻
					List<News> list = new ArrayList<News>();
					try {
						//获取XML解析器工厂
	parserFactory = XmlPullParserFactory.newInstance();
						//获取解析器
	XmlPullParser parser = parserFactory.newPullParser();

						URL url = new URL(path);
						//打开一个链接
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
						//设置连接超时时间
						connection.setConnectTimeout(5000);
						connection.setReadTimeout(5000);
						connection.setRequestMethod("GET");
						//开始链接
						connection.connect();
						//获取数据流
						InputStream inputStream = connection.getInputStream();
						//给解析器设置流对象
						parser.setInput(new InputStreamReader(inputStream));
						News news = new News();
						//解析XML数据
						while(parser.next()!=XmlPullParser.END_DOCUMENT){
							int eventType = parser.getEventType();
							switch (eventType) {
							case XmlPullParser.START_TAG:
								String tagName = parser.getName();
								if (tagName.equals("newslist")) {
									continue;
								}else if (tagName.equals("news")) {
									news = new News();
									System.out.println("创建新的新闻对象");
								}else if (tagName.equals("title")) {
									String title = parser.nextText();
									news.setTitle(title);
								}else if (tagName.equals("detail")) {
									String detail = parser.nextText();
									news.setDetail(detail);
								}else if (tagName.equals("comment")) {
									String comment = parser.nextText();
									news.setComment(comment);
								}else if (tagName.equals("image")) {
									String image = parser.nextText();
									news.setImage(image);
								}else {
									continue;
								}
								break;
							case XmlPullParser.END_TAG:
								String endTag = parser.getName();
								 if (endTag.equals("news")) {
									//将解析出来的数据添加到集合中
									list.add(news);
								}
								break;
							default:
								continue;
							}
						}
					} catch (Exception e) {
						e.printStackTrace();
						Looper.prepare();
						Toast.makeText(MainActivity.this, "请求网络失败"+e, 0).show();
						Looper.loop();
					}
					//如果当前消息池中有则返回一个，没有则创建
					Message msg = Message.obtain();
					//给当前消息绑定数据
					msg.obj=list;
					handler.sendMessage(msg);
				}
			}).start();
		return null;
	}
}
运行上面的程序，效果图如下：

12.9. 案例-向服务器提交数据
模拟用户登录，该案例模拟Android客户端给服务器端发送登录申请，客户端将用户名和密码发给服务器，由服务器来验证登录是否成功。在该案例中我们分别用GET和POST两种方式提交数据。
在该案例前我们需要做一些前期工作，首先在本地tomcat服务器上发布一个用户登录的服务。服务端用JavaWEB阶段学过的Servlet实现。这里直接给出Servlet代码，关于JavaWEB的其他知识这里不再涉及。
以GET方式向客户端提交数据
1. LoginServlet核心业务代码清单如下：
public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String username = request.getParameter("username");
		String pwd = request.getParameter("pwd");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Type", "text/html; charset=UTF-8");
		PrintWriter writer = response.getWriter();
		if ("heima".equals(username)&&"123456".equals(pwd)) {
//登录成功
			writer.write("恭喜您，登录成功。haha");
		}else {//登录失败
			writer.write("对不起，密码或者用户名不正确，登录失败！");
		}
		writer.close();
	}
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		doGet(request, response);
	}

2. 将该Servlet发布到本地tomcat，然后运行tomcat，首先通过浏览器测试服务，发现发布成功。

3. 新创建一个Android工程，工程名《用户登录》。使用默认的布局文件和Activity。
布局文件清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="向服务器提交数据"
        android:textColor="#0000ff" />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="用户名" />
    <EditText
        android:id="@+id/et_username"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入用户名" />
     <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="密码" />
    <EditText
        android:id="@+id/et_pwd"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="textPassword"
        android:hint="请输入密码" />
	<Button 
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content"
	    android:text="登陆"
	    android:layout_gravity="right"
android:onClick="login"/>
</LinearLayout>
MainActivity 代码清单文件如下：
public class MainActivity extends Activity {
	private EditText et_username;
	private EditText et_pwd;
	private final String PATH = "http://172.16.0.61:8080/validateUserLogin/servlet/LoginServlet";
	private static final String METHOD_GET = "GET";
	private static final String METHOD_POST = "POST";
	private Handler handler = new Handler() {
		public void handleMessage(android.os.Message msg) {
				Toast.makeText(MainActivity.this, msg.obj.toString(), 1).show();
		};
	};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		et_username = (EditText) findViewById(R.id.et_username);
		et_pwd = (EditText) findViewById(R.id.et_pwd);
	}
	public void login(View view) {
		final String username = et_username.getText().toString();
		final String pwd = et_pwd.getText().toString();
		if (TextUtils.isEmpty(username)) {
			Toast.makeText(this, "对不起，用户名不能为空！", 0).show();
			return;
		} else if (TextUtils.isEmpty(pwd)) {
			Toast.makeText(this, "对不起，密码不能为空！", 0).show();
			return;
		}
		// 开启一个子线程访问网络，提交数据，对用户名和密码进行验证
		new Thread(new Runnable() {
			@Override
			public void run() {
				String result = null;
				try {
					String path = PATH+"?username="+username+"&pwd="+pwd;
					URL url = new URL(path);
	HttpURLConnection connection = (HttpURLConnection) url.openConnection();
					connection.setConnectTimeout(5000);
					connection.setReadTimeout(5000);
					connection.setRequestMethod(METHOD_GET);
					connection.connect();
					int responseCode = connection.getResponseCode();
					if (responseCode == 200) {
						InputStream in = connection.getInputStream();
						ByteArrayOutputStream out = new ByteArrayOutputStream();
						byte[] bytes = new byte[1024];
						int len = -1;
						while ((len = in.read(bytes)) != -1) {
							out.write(bytes, 0, len);
						}
						in.close();
						result = out.toString();
					}
				} catch (Exception e) {
					e.printStackTrace();
					result = e.getMessage();
				} finally {
					Message msg = Message.obtain();
					msg.obj = result;
					handler.sendMessage(msg);
				}
			}
		}).start();
	}
}



4. 运行上面的工程，输入账号heima，密码123456，发现登录成功。运行截图如下：

以POST方式向客户端提交数据
该方式跟以POST方式提交数据只有稍微的区别，因此为了方便演示，我们直接在上面的工程中修改代码。
//String path = PATH+"?username="+username+"&pwd="+pwd;
					String path = PATH;
					URL url = new URL(path);
					HttpURLConnection connection = (HttpURLConnection) url.openConnection();
					connection.setConnectTimeout(5000);
					connection.setReadTimeout(5000);
					//connection.setRequestMethod(METHOD_GET);
					connection.setRequestMethod(METHOD_POST);
					connection.setDoOutput(true);
					String data = "username="+username+"&pwd="+pwd;
					OutputStream outStream = connection.getOutputStream();
					outStream.write(data.getBytes());
					outStream.close();
在上面的代码清单中，蓝色部分为老的内容，需要替换，黄色的部分是新添加的部分。
运行上面的代码会得到跟以GET方式提交同样的结果。在上面的2个案例中，如果我们如果提交的用户名是中文，我们可能会遇到乱码问题，因此下面将结合上面的案例介绍一下常见的中文乱码问题。

12.10. 获取XML
使用URL封装路径，打开一个HttpURLConnection。设置头信息之后获取相应码，从输入流中获取数据。使用XmlPullPaser解析
具体代码如下所示：
//通过HttpUrlConnection.getInputStream()；返回读取流，然后解析这个流
private static List<Person> parserXml(InputStream is) throws Exception {
		List<Person> list=new ArrayList<Person>();
		Person person=null;
		XmlPullParser parser=Xml.newPullParser();
		parser.setInput(is, "utf-8");
		int eventType = parser.getEventType();
//这里可以使用for循环来解析xml
		for(int i=eventType;i!=XmlPullParser.END_DOCUMENT;i=parser.next()){
			if(i==XmlPullParser.START_TAG){
				if("person".equals(parser.getName())){
					person=new Person();
					list.add(person);
//这里放入的person，会动态加载下边给person设置的值。
					String id=parser.getAttributeValue(0);
					person.setId(Long.parseLong(id));
				}else if("name".equals(parser.getName())){
					String name=parser.nextText();
					person.setName(name);
				}else if("age".equals(parser.getName())){
					String age=parser.nextText();
					person.setAge(Integer.parseInt(age));
				}
			}
		}
		return list;
	}
12.11. 获取JSON
使用URL封装路径，打开一个HttpURLConnection。设置头信息之后获取相应码，从输入流中获取数据。将数据转为String，封装成JSONArray对象。遍历JSONArray对象，调用获取其中的JSONObject。再从JSONObject中获取每个字段的信息。
//从服务器上获取到json字符串后，解析json
private static List<Person> parserXml(String json) throws Exception {
		List<Person> list=new ArrayList<Person>();
		//直接将json字符串，封装成jsonArray对象
		JSONArray array=new JSONArray(json);
		for(int i=0;i<array.length();i++){
			//获取JsonObject对象	
			JSONObject object= array.getJSONObject(i);
			//jsonObject对象有获取各种类型数据的getxxx(key)方法
			long id = object.getLong("id");
			String name = object.getString("name");
			int age = object.getInt("age");
			list.add(new Person(id,name,age));
		}
		return list;
	}
----Josn：存储键值对的javascript。Json的书写格式：
[
 {
  id:1,name:"张三",age:33
 },
 {
 id:1,name:"张三",age:33
 },
 {
 id:1,name:"张三",age:33
 }
];

12.12. 案例-多线程断点续传下载器

在下载的时候多个线程并发可以占用服务器端更多资源，从而加快下载速度。手机端下载数据时难免会出现无信号断线、电量不足等情况，所以需要断点续传功能。根据下载数据长度计算每个线程下载的数据位置，程序中开启多个线程并发下载。
在请求头中设置Range字段就可以获取指定位置的数据，例如：Range: bytes=100-200。在下载过程中记录每个线程已拷贝数据的数量，如果下载中断，下次启动时从记录位置继续下载
多线程下载

进度条使用<Progress>进行配置。默认为圆形进度条，水平进度条需要配置style属性，?android:attr/progressBarStyleHorizontal。
使用android.R.attr.progressBarStyleHorizontal作为样式。当点击下载按钮时开启多线程下载，下载过程中修改进度条进度。
设置最大刻度：setMax()，设置当前进度：setProgress()。更新进度：给当前进度值加1,setIncrementProgresBy(1)，这个就不用自己定义变量来设置进度。添加关闭对话框监听事件，setOnDismissListener();关闭进度条对话框后执行。
断点续传
断点续传需要在下载过程中记录每条线程的下载进。每次下载开始之前先读取数据库，查询是否有未完成的记录，有就继续下载，没有则创建新记录插入数据库。
在每次向文件中写入数据之后，在数据库中更新下载进度。下载完成之后删除数据库中下载记录。
Handler传输数据
主线程中创建的View只能在主线程中修改，其他线程只能通过和主线程通信，在主线程中改变View数据。
我们使用Handler可以处理这种需求，主线程中创建Handler，重写handleMessage()方法。新线程中使用Handler的sendMessage方法发送消息，主线程即可收到消息，并且执行handleMessage方法。
12.12.1. 原理
把文件分为多部分，分别由多个线程去下载，每个线程指定文件的某一部分，指定下载起始位置和结束位置。
多线程下载文件速度快。核心类：RandomAccessFile，随机存储文件。Wirte()方法：写数据。Seek()：指定写的位置，Close()：关闭。
12.12.2. 多线程下载文件步骤
定义一个与服务器文件大小相同的随机操作的文件
先实例化randomaccessFile对象：new RandomAccessFile(file对象,”rwd”);
第二个参数：	模式：r、rw、rws（s：是将文件的内容和元数据立即写到硬盘上，一般是不会立即写到硬盘上，而是在缓冲区中。）
rwd：与rws不同点就是不将元数据写到硬盘上，元数据就是文件的创建时间、访问时间等等。我们这里使用rwd，防止断电缓冲区内容丢失。
设置大小：randomAccessFile.setlength();
设置文件length为服务器返回的文件大小conn.getContentLength()
自定义开启的线程数目
计算出每个文件负责下载文件大小，和范围（起始位置、结束位置）。文件大小/线程数目，得出每个文件负责下载的文件大小。注意最后一个需要调整结束位置为文件的末尾。
然后通过设置请求头：来控制下载文件的范围。conn.setRequestProperty(“Range”,”bytes=100-200”);
最后循环调用自定义线程类，去下载文件。
自定义线程类，没一个线程都通过URL去发送请求下载文件
自定义线程类，构造方法参数：线程索引（第几个线程）,下载文件的路径，起始位置、结束位置。
注意使用多个线程在同时对一个文件写的时候，要指定本线程开始写的位置randomAccessFile.seek(startPosition);
12.12.3. 多线程下载文件断点续传步骤
断点续传，就是记录每个线程停止时，当前下载的位置。然后再次开始下载时，把startPostition设置为currPostion。从断点位置开始下载。
保存断点位置
每个线程都需要保存一个自己当前的下载位置。用一个txt文本保存这个断点位置。如果本线程执行结束，就说明不需要断点，那么就删除保存断点的txt文本。
处理再次下载
如果有断点位置文件，就拿出断点位置，判断如果断点位置大于起始位置，那么就将起始位置指定为保存的断点位置。
12.12.4. 更新进度条，动态显示进度
原理：
只有创建view对象的线程，才可以操作他里面的view对象
为了避免多个线程同时操作界面，框架设计者规定只有主线程才可以更新操作界面。主界面用于创建UI界面，所以只有主界面才能操作他创建的view对象。
主线程：又叫UI线程，主线程主要用于显示UI，oncreate用于设置显示哪个layout，它运行在主线程中
那么子线程怎么间接操作view对象
消息队列：主线程接受子线程发送的消息，保存在消息队列中
消息轮询器looper：不断查询消息队列中有没有消息，如果有就处理。他运行在主线程内。

子线程如何给主线程发送消息
创建Handler对象，直接new，必须在主线程内创建
在子线程中：调用handler.sendMessage(Message对象);发送消息到主线程的消息队列中
Message对象，直接new实例化：通过message.obj=xxx来设置消息
消息轮询器，处理消息
实例化Handler时，重写他的内部方法handleMessage(Message m).
子线程发送消息后，主线程中的消息轮询器，就会调用handleMessage方法来处理消息，这个方法的参数是Message，所以可以通过message.obj拿到子线程发送的消息。拿到消息后，主线程根据消息来修改界面信息

12.13. 中文乱码问题
Android操作系统默认使用的编码是UTF-8，解决中文乱码问题的关键是确保服务器和客户端使用的编码一致。
12.13.1. GET方式中文乱码的解决
客户端：在拼接字符串的时候，对传递的数据通过URLEncoder类进行一下编码，使用的编码方式与服务器约定的编码方式一致。这里假设服务端的编码方式为UTF-8，发送数据到服务器的处理代码如下：
String usernameEncoder=URLEncoder.encode(username,"UTF-8");
String passwordEncoder=URLEncoder.encode(password,"UTF-8");
String urlPath=path+"?username="+usernameEncoder+"&password="+passwordEncoder;

接收来自服务器的数据时，处理代码如下：
//获取响应的内容
				InputStream is=conn.getInputStream();				
				//读取流，转换为字符串
				ByteArrayOutputStream baos=new ByteArrayOutputStream();
				int len=-1;
				byte[] bys=new byte[1024];
				while((len=is.read(bys))!=-1){
							baos.write(bys, 0, len);
					}
				String result=baos.toString("UTF-8");
				baos.close();

服务端：Tomcat默认采用iso-8859-1的编码接收客户端传递来的数据，因此在获取request请求中传递来的参数时，需先用iso-8859-1对参数进行解码，然后再以客户端传递的数据的编码方式进行编码。这里假设客户端发送的数据其编码方式为UTF-8，获取请求参数时处理代码如下：
String username=request.getParameter("username");
		byte[] bys=username.getBytes("iso-8859-1");
username=new String(bys,"UTF-8");

发送数据给客户端时，处理代码如下：
response.getOutputStream().write("登录成功".getBytes("UTF-8"));

12.13.2. POST方式中文乱码的解决
客户端：发送数据给服务器的时候，对发送的数据进行编码。
//要发送到服务端的数据
String data="username="+username+"&password="+password;
//写数据
conn.getOutputStream().write(data.getBytes("UTF-8"));
接收数据时的处理逻辑与GET方式相同。
服务端：发送数据给客户端时的处理逻辑与GET方式相同，接收request请求发送来的参数时，可以采用先使用iso-8859-1解码再使用客户端的编码方式进行编码，也可以通过如下处理代码实现：
request.setCharacterEncoding("UTF-8");

12.14. 结合工作和面试
1. 面试中
多线程断点续传
这个如果找的app里涉及有的话，就需要看看了，面试有可能会问。
ANR异常
为什么为出现ANR异常，如何解决？
2. 工作中
网络编程
网络这块比较重要，所用应用都会和服务端打交道，所以就需要请求网络。
所以老师讲的每个点，最好是都能够理解，虽然有些东西有可能后期工作用不到，但是这些是网络的基础，所以需要掌握HttpURLConnection。
上面这些案例呢，建议大家都敲一遍，但是如果是真敲不完，理解案例思路，选择几个去敲，比如图片查看器，新闻客户端、获取JSON，像务端提交数据。
中文乱码
在web的时候，中文乱码比较烦人。但是在Android中一般用的是封装好的网络框架xUtils，volley，所以很少见到中文乱码。但有可能面试会问到。
13. Android消息处理机制（★★★★）
13.1. Looper、Message、Handler的关系
当我们的Android应用程序的进程一创建的时候，系统就给这个进程提供了一个Looper，Looper是一个死循环，它内部维护这个一个消息队列。Looper不停地从消息队列中取消息（Message），取到消息就发送给了Handler，最后Handler根据接收到的消息去修改UI。Handler的sendMessage方法就是将消息添加到消息队列中。

13.2. runOnUiThread
Activity中提供了一个runOnUiThread方法，用于进行消息处理。此方法是通过线程合并——join来实现消息处理的。
线程合并：主线程将子线程的任务拿到自己这里来执行并终止子线程。
实例代码如下：
/**
		 * Runs the specified action on the UI thread. If the current thread is
		 * the UI thread, then the action is executed immediately. If the
		 * current thread is not the UI thread, the action is posted to the
		 * event queue of the UI thread.
		 * 上面的意思为：在UI线程中运行我们的任务，如果当前线程是UI线程，则立即执行，如果不是则该任务发送到UI线程的事件队列。
		 */
		runOnUiThread(new Runnable() {

			@Override
			public void run() {
				//自定义我们的业务代码
			}
		});

13.3. postDelayed
该方法是Handler对象提供的，Handler给消息队列发送一个消息，发送成功则返回true，否则返回false，如果返回false一般是由于looper进程不存在导致的。该方法主要用于定时任务。如果返回true也不一定代表着我们的定时任务就执行了，因为很可能在定时任务的时间未到之前我们的looper进程退出了，那么消息也就丢失了。
执行该任务的线程用的就是Handler对象所在的线程。
/**
* Causes the Runnable r to be added to the message queue, to be run
* after the specified amount of time elapses. The runnable will be run
* on the thread to which this handler is attached. Parameters: r The
* Runnable that will be executed. delayMillis The delay (in
* milliseconds) until the Runnable will be executed. Returns: Returns
* true if the Runnable was successfully placed in to the message queue.
* Returns false on failure, usually because the looper processing the
* message queue is exiting. Note that a result of true does not mean
* the Runnable will be processed -- if the looper is quit before the
* delivery time of the message occurs then the message will be dropped.
* 上面代码翻译如下：
* 该方法将一个Runnable对象r添加到消息队列，在指定的时间后会被执行。
* 这个Runnable对象会运行在当前handler所在的线程中。
* 第一个参数：Runnable 要执行的任务
* 第二个参数：delayMillis(单位：毫秒) runnable 任务被执行前的延迟时间
* 返回值：boolean ，如果该Runnable被成功添加到消息队列则返回true，否则返回false
* 不过，通常返回false是因为looper进程处理消息队列退出。
* 注意：返回true不代表着Runnable被执行，如果looper在延时任务还没被执行前退出了，那么消息就丢失掉了。
		 */
		boolean flag = handler.postDelayed(new Runnable() {
			@Override
			public void run() {
			}
		}, 2000);

13.4. postAtTime
该方法也属于Handler对象，唯一不同的是该方法设置的定时任务是一个绝对时间，指的是Android系统的开机时间，如果想设置从当前时间算起2秒后执行该任务则可以将时间这样写：SystemClock.uptimeMillis()+2000，其中SystemClock.uptimeMillis()是系统运行时间。
/**
* Causes the Runnable r to be added to the message queue, to be run at
* a specific time given by uptimeMillis. The time-base is
* android.os.SystemClock.uptimeMillis. The runnable will be run on the
* thread to which this handler is attached. Parameters: r The Runnable
* that will be executed. uptimeMillis The absolute time at which the
* callback should run, using the android.os.SystemClock.uptimeMillis
* time-base. Returns: Returns true if the Runnable was successfully
* placed in to the message queue. Returns false on failure, usually
* because the looper processing the message queue is exiting. Note that
* a result of true does not mean the Runnable will be processed -- if
* the looper is quit before the delivery time of the message occurs
* then the message will be dropped.
* 意译：给消息队列发出一个消息，让指定的任务在指定的时间执行。这里的时间是绝对时间，是相对于android.os.SystemClock.uptimeMillis的时间
* 如果我们想在当前时间的2秒后执行该任务则将时间设置为：SystemClock.uptimeMillis()+2000即可。
		 */
		boolean postAtTime = handler.postAtTime(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
			}
		}, SystemClock.uptimeMillis()+2000);
	}


13.5. ANR异常
1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
9. 
9.1. 
9.2. 
9.3. 
9.4. 
9.5. 
9.6. 
9.7. 
9.8. 
9.9. 
9.10. 
9.11. 
9.12. 
9.13. 
9.14. 
13.5.1. 简介
Application No Response：应用程序无响应。在主线程中，是不允许执行耗时的操作的，如果主线程阻塞的时间大于6秒，就很有可能出现anr异常。
主线程，要完成界面的更新，事件的处理，窗体显示的回调，所以如果主线程阻塞时间较长，就不能很好的处理以上比较重要的事情，那么Android有一个机制，就是如果他发现消息队列中有很多消息，主线程没办法响应的话，他就会抛出anr异常。所以，比较耗时的操作都必须要交给子线程。
13.5.2. 解决办法
可以通过Handler来解决这个问题，将比较耗时的操作交给子线程，然后子线程通过Handler，发送消息给主线程，让主线程去更新界面。
什么样的操作时比较耗时的？
   1、访问网络，2、大文件的拷贝，3、阻塞式的请求，socket
13.6. 结合工作和面试
1. 面试中
ANR异常  （常问）
为什么为出现ANR异常，如何解决？
Handler机制 （这个非常重要） 这个后期在讲项目的时候应该还会涉及到。Looper、Message、MessageQueue、Hanler如何运作的?

2. 工作中
这个章节非常重要，工作中用的很多。工作中如果碰到ANR异常，根据异常日志，需要会解决。需要会使用handler进行线程间通讯。
14. 网络编程中常用的框架（★★★）
14.1. 开源框架SmartImageView
此框架提供很多实用的功能，其中可使用setImageUrl方法将一个网络图片的地址赋值给此控件，此控件内部的处理逻辑将访问网络获取指定URL的图片资源，并显示到客户端。该框架的使用很简单。
setImageUrl(path,xx,xx)方法直接加载一个图片路径，此方法内部会保存缓存（内存、硬盘上都做缓存）。
第一个参数：图片网络路径
第二个参数：加载失败时显示的图片（指定R资源文件中的图片id）
第三个参数：加载过程中显示的图片
使用步骤：
1. 登录github开源大仓库，下载此开源控件。或者使用我在百度云盘上提供的附件。http://pan.baidu.com/s/1o6MDhJs。
2. 添加此开源框架的包到工程下

3. 在布局页面使用此控件：必须使用包名.类名这样的全路径，否则无法找到
  <!-- 引入第三方控件用于显示图片 -->
    <com.loopj.android.image.SmartImageView 
        android:id="@+id/iv"
        android:layout_height="70dp"
      	android:layout_width="70dp"
      	android:contentDescription="news"
        />
4. 调用setImageUrl,将图片的网络地址赋值给控件即可
//实例化SmartImageView对象
SmartImageView imageView = (SmartImageView)convertView.findViewById(R.id.iv);
//给SmartImageView设置一个图像的URL则SmartImageView会自动加载图片
imageView.setImageUrl(news.getImage());
14.2. HttpClient
HttpClient是apache开源组织研发的一个API，被Android引入使用。（URL以及HttpUrlConnection是java自带的API）。	HttpClient设计的思想是模拟浏览器的操作来实现网络访问。
使用步骤：
1. 定义一个客户端对象：即获得一个HttpClient对象（打开浏览器）
2. 定义请求方法（输入网址）：Get——HttpGet/POST——HttpPost
3. 设置请求的参数/请求头信息/连接超时时间/读取数据超时时间等
4. 执行请求(敲回车)：execute方法——此方法会返回一个HttpResponse对象
5. 获取状态码：response.getStatusLine().getStatusCode()
6. 若状态码是200，获取服务器返回的数据:
InputStream is=response.getEntity().getContent()
7. 操作结束后断开连接：
client.getConnectionManager().shutdown()
14.3. 使用HttpClient发送GET请求
为了方便演示，我们直接使用本文档14.9章节的工程，只需修改发送用户数据的核心方法即可。
代码如下：
String path = PATH+"?username="+username+"&pwd="+pwd;
//获取一个客户端对象
HttpClient client = new DefaultHttpClient();
//定义请求方式，并传递请求地址
HttpGet httpGet = new HttpGet(path);
//获取参数对象
HttpParams params = httpGet.getParams();
//设置链接超时时间
HttpConnectionParams.setConnectionTimeout(params, 5000);
//设置读取数据超时时间
HttpConnectionParams.setSoTimeout(params, 5000);
//开始发送请求，同时返回HttpResponse对象,该句代码属于耗时操作
HttpResponse httpResponse = client.execute(httpGet);
//获取状态码
int code = httpResponse.getStatusLine().getStatusCode();
if (code==200) {
    //获取返回数据流对象
    InputStream in = httpResponse.getEntity().getContent();
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    byte[] buff = new byte[1024];
    int len = -1;
    while((len=in.read(buff))!=-1){
        bos.write(buff, 0, len);
    }
    in.close();
    result = bos.toString();
    bos.close();
}else {
    result = "请求失败！";
}
//关闭链接
client.getConnectionManager().shutdown();
14.4. 使用HttpClient发送POST
使用上节中的工程，只需修改核心功能代码即可。代码清单如下：
//创建客户端对象
HttpClient client = new DefaultHttpClient();
//创建一个POST请求对象
HttpPost httpPost = new HttpPost(PATH);
//获取请求对象的参数
HttpParams httpParams = httpPost.getParams();
//设置链接超时时间
HttpConnectionParams.setConnectionTimeout(httpParams, 5000);
//设置读取数据流超时时间
HttpConnectionParams.setSoTimeout(httpParams, 5000);
//设置请求参数集合，将请求参数都添加到该集合
List<BasicNameValuePair> parameters = new ArrayList<BasicNameValuePair>();
//将用户信息添加到集合中
parameters.add(new BasicNameValuePair("username", username));
parameters.add(new BasicNameValuePair("pwd", pwd));
//创建一个请求体对象
UrlEncodedFormEntity entity = new UrlEncodedFormEntity(parameters );
//给httpPost对象设置请求体
httpPost.setEntity(entity);
HttpResponse httpResponse = client.execute(httpPost);
//获取状态码
int code = httpResponse.getStatusLine().getStatusCode();
if (code==200) {
//获取返回数据流对象
InputStream in = httpResponse.getEntity().getContent();
ByteArrayOutputStream bos = new ByteArrayOutputStream();
byte[] buff = new byte[1024];
int len = -1;
while((len=in.read(buff))!=-1){
bos.write(buff, 0, len);
				}
in.close();
result = bos.toString();
bos.close();			
}else {
	result = "请求失败！";
}
//关闭链接
client.getConnectionManager().shutdown();

14.4.1. HttpClient上传图片 *
图片上传，在Http请求内被分隔成一部分一部分，有普通表单，和图片表单，所以需要用到part。
实例化上传数据的数组part
stringPart(“表单name”,值);普通表单
filePart(“表单name”,new file(filepath));图片表单
封装请求方法：PostMethod
实例化PostMethod(请求url);
设置请求体：setRequestEntity(new MultipartRequestEntity(part数组,PostMethod.getparams()));
两个参数：一个是part数组，一个是postmethod对象的params参数。
实例化httpClient，执行方法
实例化后，执行方法，client.executeMethod(postMethod对象);
设置超时：HttpConnectionManager().getparams().setConnectionTimeout()
获取返回内容
Postmethod.getResponseBody();
14.4.2. HTTP协议上传文件
HttpURLConnection
通过URL封装路径打开一个HttpURLConnection。设置请求方式以及头字段：Content-Type、Content-Length、Host，拼接数据发送
Socket
使用HttpURLConnection发送时内部有缓存机制，如果上传较大文件会导致内存溢出，我们可以使用Socket发送TCP请求，将上传数据分段发送。
HttpClient
public void upload(String name, String password, String path) throws Exception {
	// 创建HttpClient对象
	HttpClient client = new HttpClient();
	// 设置超时事件
	client.getHttpConnectionManager().getParams().setConnectionTimeout(3000);
	// 创建一个Post请求, 指定路径
	PostMethod postMethod = new PostMethod("http://192.168.1.102:8080/14.Web/LoginServlet");
	// 封装每个表单项
	Part[] parts = { new StringPart("username", username), new StringPart("password", password), new FilePart("file", new File(path)) };
	// 给Post请求设置实体
	postMethod.setRequestEntity(new MultipartRequestEntity(parts, postMethod.getParams()));
	// 执行Post请求
	client.executeMethod(postMethod);
	// Post请求释放资源
	postMethod.releaseConnection();
}
14.5. 开源框架AsyncHttpClient
AsyncHttpClient是一个Android的异步HTTP函数库，使用此开源项目访问网络时，无需开启子线程，因为调用其方法时传递的接口参数中的方法就是执行在主线程中的，使用起来非常方便。登录github，搜索async-http,下载此开源项目，添加jar包到工程下的lib目录，直接使用即可。百度云盘下载地址：http://pan.baidu.com/s/1qWz80Ew
为了演示AsyncHttpClient的使用，我们依然使用14.9《用户登陆》工程，只需将下载的jar包添加到工程中，如图所示。

14.5.1. 使用GET方式提交数据给服务器
这里只在原有工程的基础上修改核心代码，代码如下：
//创建一个AsyncHttpClient对象，直接new
		AsyncHttpClient client = new AsyncHttpClient();
		//调用get方法，发送get方式的请求
//第一个参数是url，get请求url带参数
		//第二个参数是，服务器有返回结果后执行的回调函数
		//AsyncHttpClient实现网络访问，内部是新开的线程在执行
		client.get(PATH, new AsyncHttpResponseHandler() {
			/**
			 * 处理成功的结果
			 * statusCode 状态码
			 * headers 响应头消息
			 * responseBody 相应的主体内容
			 */
			@Override
			public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
				//内部通过handler的方式实现界面的操作
				String result = new String(responseBody);
				Toast.makeText(MainActivity.this, "请求结果："+result, 1).show();
			}
			/**
			 * 处理失败的结果
			 * statusCode 状态码
			 * headers 响应头消息
			 * responseBody 相应的主体内容
			 */
			@Override
			public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable throwable) {
				Toast.makeText(MainActivity.this, "请求网络失败！", 0).show();
			}
		});	

14.5.2. 使用POST方式提交数据给服务器
基本逻辑与GET方式相同，不同的是GET方式调用的是GET方法，POST方式调用的是POST方法；GET方式将请求参数拼接在URL后面传输给服务器，POST方式需要使用RequestParams对象封装请求参数给post。RequestParams，内部存储键值对。
AsyncHttpClient client = new AsyncHttpClient();

		RequestParams params = new RequestParams();
		params.put("username", "heima");
		params.put("pwd", "12346");
		client.post(PATH, params,new AsyncHttpResponseHandler() {
//省略其他一样的代码
14.5.3. 上传文件到服务器
上传文件其实用的就是POST方法，只需要给RequestParams对象设置一个File类型的参数即可。实例代码如下：
public void doUpload(View v) throws Exception{
		AsyncHttpClient client=new AsyncHttpClient();
		RequestParams params =new RequestParams();
		File path=Environment.getExternalStorageDirectory();
		//要想实现文件上传，直接在请求参数中添加file对象即可
		params.put("file", new File(path,"users.xml"));
		//然后通过post方式发送请求
		client.post("http://192.168.1.42:8080/MyDay15/uploadServlet", params , new AsyncHttpResponseHandler(){
			public void onSuccess(String content) {
				Toast.makeText(getApplicationContext(), "上传成功！", Toast.LENGTH_SHORT).show();
			}
			public void onFailure(Throwable error, String content) {
				Toast.makeText(getApplicationContext(), "上传失败！", Toast.LENGTH_SHORT).show();
			}
		});
	}
14.5.4. 发送XML，访问WebService
发送XML
通过URL封装路径打开一个HttpURLConnection，设置请求方式，Content-Type和Content-Length。
XML文件的Content-Type为：text/xml; charset=UTF-8。
使用HttpURLConnection获取输出流输出数据
WebService
WebService是发布在网络上的API，可以通过发送XML调用，WebService返回结果也是XML数据
WebService没有语言限制，只要可以发送XML数据和接收XML数据即可。
http://www.webxml.com.cn 网站上提供了一些WebService服务，我们可以对其进行调用。
http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?op=getMobileCodeInfo 中提供了电话归属地查询的使用说明
通过AsyncHttpClient：实现电话归属地查询
具体代码如下所示：
	public void query(View v){
		String number=edt_number.getText().toString().trim();
//获取输入的电话号码
		AsyncHttpClient  httpClient=new AsyncHttpClient();
//实例化AsyncHttpClient
		RequestParams params=new RequestParams();
//设置参数
		params.put("mobileCode", number);
//电话号码
		params.put("userID", "");
//付费用户，卡id
		//提供的webservice的电话归属地查询地址
	httpClient.get("http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx/getMobileCodeInfo",params, new AsyncHttpResponseHandler(){
			public void onSuccess(String content) {
				try {
					String place = XmlUtils.getPlace(content);//将拿到的xml解析
					tv_place.setText(place);
					Toast.makeText(getApplicationContext(), place,
							Toast.LENGTH_SHORT).show();
				} catch (Exception e) {
					Toast.makeText(getApplicationContext(), "获取失败", Toast.LENGTH_SHORT).show();
					e.printStackTrace();
				}
			}
		});
	}
解析返回的电话归属地的xml
	public static String getPlace(String content) throws Exception {
		XmlPullParser parser = Xml.newPullParser();
		parser.setInput(new StringReader(content));
		for(int i=parser.getEventType();i!=XmlPullParser.END_DOCUMENT;i=parser.next()){
			if(i==XmlPullParser.START_TAG&&"string".equals(parser.getName())){
				return parser.nextText();
			}
		}
		return null;
	}

webxml.com.cn提供的电话查询接口接受的xml和返回的xml示例
以下是 HTTP GET 请求和响应示例。所显示的占位符需替换为实际值。
GET /WebServices/MobileCodeWS.asmx/getMobileCodeInfo?mobileCode=string&userID=string HTTP/1.1
Host: webservice.webxml.com.cn
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

<?xml version="1.0" encoding="utf-8"?>
<string xmlns="http://WebXml.com.cn/">string</string>
14.5.5. 获取网络图片
使用的回调函数为：AsyncHttpResponseHandler的子类BinaryHttpResponseHandler
onSuccess(byte[] data)通过Bitmap将字节数据封装为bitmap，然后设置给imageview。
	public void asyncGo(View v){
		AsyncHttpClient client=new AsyncHttpClient();
		client.get("http://192.168.1.42:8080/net/1.jpg",new  BinaryHttpResponseHandler(){
			public void onSuccess(byte[] binaryData) {
				Bitmap bitmap = BitmapFactory.decodeByteArray(binaryData, 0, binaryData.length);
				siv_pic.setImageBitmap(bitmap);
			}
		});
	}
14.6. 结合工作和面试
1. 工作中
HttpClient和AsyncHttpClient用的都比较多，需要熟练掌握。
SmartImageView
这个需要知道如何使用，需要知道原理。后期会学习框架xUtils，这个也有请求图片的功能，原理使用方法类似。
15. 四大组件之Activity
15.1. Activity简介（★★）
Activity是Android四大组件之一，它用于展示界面。Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。
在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。
15.2. Activity简单使用
定义类继承Activity
在AndroidManifest.xml的<application>节点中声明<activity>
application:中lable是指程序的名字，在卸载页面显示的名字就是这个lable指定的。
Activity中的lable是指activity的名字，如果此activity还指定了:以下intent-filter，那么这个界面就会在桌面创建快捷方式，快捷方式名字就是这个activity的lable
<intent-filter>
   <action android:name="android.intent.action.MAIN" />
   <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
Category:指定意图的类别，Launcher是在桌面创建快捷方式。
15.3. Activity在清单文件中的配置
Lable属性：
Activity页面的标题，界面的名字，如果此界面被创建快捷方式，则快捷方式的名字就是lable值。
Name属性：
指定的值为:包名.Activity类名。包名如果与mainfest的package一致，可以用“.”代替或者不写。
Intent-filter子节点：
添加意图过滤，可以通过隐式意图启动。可以在桌面生成快捷方式，应用程序的入口。
Icon属性：
指定应用程序的图标
android：theme属性，
指定主题:android：theme="@android:style/Theme.Dialog"
15.4. Activity之间的跳转（★★★★）
Activity之间的跳转分为2种：
显式跳转：在可以引用到那个类, 并且可以引用到那个类的字节码时可以使用。一般用于自己程序的内部。显式跳转不可以跳转到其他程序的页面中。
隐式跳转：可以在当前程序跳转到另一个程序的页面。隐式跳转不需要引用到那个类,但是必须得知道那个界面的动作(action)和信息(category)。
Activity之间通过Intent进行通信。Intent即意图，用于描述一个页面的信息,同时也是一个数据的载体。
案例-显式跳转：显式跳转必须知道并且能够使用要跳转的Activity的字节码，所以显式跳转一般只能用于自己程序的内部的跳转，而不能跳转到其他程序的Activity。
为了方便演示，我们创建一个新的Android工程《Activity跳转》。然后创建两个Activity类，分别为FirstActivity，和SecondActivity，并在Android工程清单文件中声明这两个Activity类。工程清单中添加Activity配置如下。
<activity
            android:name="com.itheima.activitySkip.FirstActivity"
            android:label="@string/app_name" >
 <intent-filter>
<action android:name="android.intent.action.MAIN" />
 <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
</activity>
<activity android:name="com.itheima.activitySkip.SecondActivity"/>

修改FirstActivity布局文件（activity_first.xml），并将该布局文件复制并修改名字为activity_second.xml作为SecondActivity的布局文件。
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".FirstActivity" >

    <TextView
        android:layout_gravity="center_horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="#ff0000"
        android:text="我是第一个Activity" />
    <Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="跳转到第二个Activity"
        android:onClick="skip2Second"
        />
</LinearLayout>
15.4.1. 显式意图跳转
意图即Intent，用于激活组件，Android的组件都可以通过intent去激活。显示意图是知道意图的包名、类名。
示例：
编写FirstActivity类：
package com.itheima.activitySkip;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
public class FirstActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_first);
	}
	public void skip2Second(View view){
		//创建一个Intent对象，并传递当前对象（Context对象）和要跳转的Activity类字节码
		Intent intent = new Intent(this, SecondActivity.class);
		//启动第二个Activity
		startActivity(intent);
	}
}

运行上面的工程，点击按钮，发现成功跳转到了第二个Activity页面。此示例代码中使用的意图跳转是通过调用意图的构造来实现的，特点:代码少。
new Intent(this, XXXActivity.class);
显示意图的其他形式，特点:类名形式，灵活，可扩展性强。
intent.setClassName(this, "cn.itcast.activity.NewActivity");
这个可以是不同应用，只要知道其activity的全路径名即可，包名类名形式，可启动其他程序中的Activity。
intent.setClassName("cn.itcast.downloader", "cn.itcast.downloader.MainActivity");
注意这里第一个参数是应用程序的包名。
最后一种：使用组件名，这种方式不常用。具体做法，先实例化componentName("包名","带包的类名")，然后设置intent.setComponent()。
componentName 直译的话就是组件的名字的意思,如果我们写的一个类当作成一个组件,那么这个componentName就是用来封装我们写的这些类的位置.
//创建一个component的对象 
ComponentName componentName = new ComponentName(Context.this, xxx.class); 
Intent intent  = new Intent(); 
Intent.setComponent(componentName); 
startActivity(intent); 
//---------- 
//在xxxactivity中 
ComponentName comp = getIntent().getComponent(); 
String packageName = comp.getPackName(); 
String className = comp.getClassName();
15.4.2. 隐式意图跳转
隐式跳转可以跳转到其他程序的Activity，当然本应用也是可以的。只要知道Activity的动作(action)以及类型(category)。因此，能够被隐式跳转的Activity，在清单文件中声明时必须指定动作和信息这两个属性。
显式意图是指在创建意图时指定了组件，而隐式意图则不指定组件，通过动作、类型、数据匹配对应的组件。接下来将通过一段示例代码来演示隐式意图的用法，具体步骤如下所示：
1. 修改工程清单文件中SecondActivity的配置信息。
<activity android:name="com.itheima.activitySkip.SecondActivity">
            <!-- 配置意图过滤器 -->
            <intent-filter >
<!-- 在意图过滤器中设置action和category，当有匹配的action和category的时候启动该Activity。这里使用Android提供的默认category即可 -->
<action android:name="com.itheima.activitySkip.SecondActivity"/>
 <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
            </activity>

2. 修改在上一章节中FirstActivity类
//创建一个Intent对象
		Intent intent = new Intent();
		//设置Action
		intent.setAction("com.itheima.activitySkip.SecondActivity");
		//对于android.intent.category.DEFAULT类型的信息为Android系统默认的信息，省略也可以
		intent.addCategory("android.intent.category.DEFAULT");
		//启动Activity
		startActivity(intent);
执行上面的代码，发现实现了Activity的跳转。
注意：若清单文件中的Activity声明为:
<intent-filter>
<action android:name="android.intent.action.MAIN" />
<category android:name="android.intent.category.LAUNCHER" />
</intent-filter>
则此Activity将作为程序的入口，有几个作为入口的Activity，apk文件安装的时候就会生成几个图标。
3. 隐式意图注意点
在清单文件中定义<activity>时需要定义<intent-filter>才能被隐式意图启动
<intent-filter>中至少配置一个<action>和一个<category>，否则无法被启动
Intent对象中设置的action、category、data在<intent-filter>必须全部包含才能启动
<intent-filter>中的<action>、<category>、<data>都可以配置多个，Intent对象中不用全部匹配，每样匹配一个即可启动
如果一个意图可以匹配多个Activity，Android系统会提示选择
data中还可以设置type属性，那么激活时，也就必须setType()
<data android:mimeType=""></data>
15.5. 案例-Activity隐式跳转（★★★）
Android系统中本身存在很多的应用程序，打开系统源码，查看packages文件夹下的apps文件夹，里面存放着Android系统的这些应用程序。
	若想跳转到这些应用程序中，只需打开对应应用程序的清单文件，找到其动作和信息,采用隐式跳转即可实现。
15.5.1. 打开浏览器界面
将Android应用的源码安装在：D:\AndroidSource_GB\AndroidSource_GB中，打开D:\AndroidSource_GB\AndroidSource_GB\packages\apps\Browser目录，然后打开AndroidManifest.xml清单文件，找到用于启动浏览器的intent-filter。intent-filter有多个，我们选择一个适合我们即可。
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="http" />
                <data android:scheme="https" />
                <data android:scheme="about" />
                <data android:scheme="javascript" />
</intent-filter>
为了方便演示我们直接修改本文档17.4.1章节中创建的工程，在FirstActivity的布局文件中添加一个按钮，点击该按钮打开一个浏览器。这里给出FirstActivity类核心方法的代码清单：
//跳转到浏览器界面
	public void skip2Browser(View view){
		//创建一个Intent对象
		Intent intent = new Intent();
		//设置Action
		intent.setAction("android.intent.action.VIEW");
		//设置category
		intent.addCategory("android.intent.category.BROWSABLE");
		//设置参数
		intent.setData(Uri.parse("http://www.itheima.com"));
		//启动Activity
		startActivity(intent);
	}
运行上面代码，发现成功跳转到了浏览器界面，并打开了指定的网页。

15.5.2. 打开短信发送界面
打开Android应用源码，找到D:\AndroidSource_GB\AndroidSource_GB\packages\apps\Mms目录，打开AndroidManifest.xml清单文件，找到intent-filter。
<intent-filter>
<action android:name="android.intent.action.VIEW" />
<action android:name="android.intent.action.SENDTO" />
<category android:name="android.intent.category.DEFAULT" />
<category android:name="android.intent.category.BROWSABLE" />
          <data android:scheme="sms" />
         <data android:scheme="smsto" />
</intent-filter>    
在本文档17.4.1章节中给FirstActivity布局文件添加一个按钮，并添加按钮事件。在该方法中实现核心业务逻辑。
//跳转到发送短信界面
	public void skip2Mms(View view){
		//创建一个Intent对象
		Intent intent = new Intent();
		//设置Action
		intent.setAction("android.intent.action.VIEW");
		//设置category
		intent.addCategory("android.intent.category.BROWSABLE");
		//设置参数
		intent.setData(Uri.parse("sms:10086"));
		//设置短信内容
		intent.putExtra("sms_body", "301");
		//启动Activity
		startActivity(intent);
	}

运行上面的代码，发现成功打开了短信发送界面。这里就不给出运行效果图。

15.6. 使用Intent传递数据（★★★★）
Intent除了可以激活组件（启动Activity等），还可以通过封装的Bundle对象来携带数据。所以在启动一个Activity的时候，同时还可以传递数据，然后在新的Activity中可以获得意图对象以获取其中Bundle保存的数据。
Intent可传递的数据类型有: 八大基本数据类型，String,数组,ArrayList<String>, Bundle数据捆, 实现序列化接口的javabean。
注意：Intent传递的数据过多可能会造成跳转速度极慢甚至黑屏一会，不要用Intent传递过多的数据，会影响到应用程序的使用。
下面通过一个案例来演示Intent如何传递数据，我们使用17.4.1章节中的工程。需求：点击FirstActivity界面的按钮，将数据传递到SecondActivity，并显示传递的数据。具体实现步骤如下所示：
1. 修改AndroidManifest.xml文件中SecondActivity的intent-filter参数
<activity android:name="com.itheima.activitySkip.SecondActivity">
            <!-- 配置意图过滤器 -->
            <intent-filter >
                <!-- 在意图过滤器中设置action和category，当有匹配的action和category的时候启动该Activity -->
                <action android:name="com.itheima.activitySkip.SecondActivity"/>
                <category android:name="android.intent.category.DEFAULT"/>
               <!-- 设置数据协议 -->
              <data android:scheme="money"/>
              <!-- 配置数据的mimeType:必须为xxx/xxx的格式，否则会报异常  -->
                <data android:mimeType="data/mymime"/> 
            </intent-filter>
            </activity>
2. 在FirstActivity逻辑代码
布局中添加一个按钮，给该按钮绑定事件，点击该按钮实现跳转到SecondActivity界面。该事件核心方法清单如下：
// 发送数据给SecondActivity
	public void sendData2Second(View view) {
		// 创建一个Intent对象
		Intent intent = new Intent();
		// 设置Action
		intent.setAction("com.itheima.activitySkip.SecondActivity");
		// 对于android.intent.category.DEFAULT类型的信息为Android系统默认的信息，省略也可以
		intent.addCategory("android.intent.category.DEFAULT");
		intent.setDataAndType(Uri.parse("money:转账100元。"), "data/mymime");
		//给Intent设置数据
		intent.putExtra("name", "张三");
		ArrayList<String> list = new ArrayList<String>();
		for(int i=0;i<10;i++){
			list.add("list"+(i+1));
		}
		//给你Intent设置字符串类型的集合
		intent.putStringArrayListExtra("list", list);
		//声明一个Bundle对象，bundle内部是包装过的map集合
		Bundle bundle = new Bundle();
		//在Bundle对象中绑定数据
		bundle.putString("pwd", "123456");
		//给Intent设置Bundle对象
		intent.putExtras(bundle);//通过putExtras()传递bundle
		// 启动Activity
		startActivity(intent);
	
	}

3. 编写SecondActivity类，使其接收数据。

public class SecondActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_second);
		//获取从当前Context对象中获取Intent
		Intent intent = getIntent();//注意这个是getIntent()
		//获取数据
		String data = intent.getData().toString();
		System.out.println(data);
		//从Intent中获取Bundle对象
		Bundle extras = intent.getExtras();//通过getExtras获取bundle
		//从Bundle中获取可以为name的数据
		String name = (String) extras.get("name");//再通过get()获取具体值
		System.out.println("name="+name);
		//从Bundle对象中获取key为pwd的数据
		String pwd = (String) extras.get("pwd");
		System.out.println(pwd);
		//从Bundle中获取ley为list的数据
		List<String> list = (List<String>) extras.get("list");
		System.out.println(list);
	}

4. 运行该工程
发现成功跳转到了SecondActivity界面，同时控制台也成功打印出了通过Intent传递数据。如下图：

15.7. 创建Activity获取返回数据
使用startActivityForResult(Intent intent, int requestCode) 方法打开Activity
重写onActivityResult(int requestCode, int resultCode, Intent data) 方法
新Activity中调用setResult(int resultCode, Intent data) 设置返回数据之后，关闭Activity，第一个Activity就会调用onActivityResult方法
requestCode，请求码：用于区别是哪个操作启动的意图，resultCode，结果码，用于区别是哪个Activity返回的数据。接下来将通过案例——“人品计算器”来演示获取Activity返回数据。
15.8. 案例-人品计算器（★★）
知识点：
跳转时使用startActivityForResult方法开启新页面
在被开启的新的页面里, 调用setResult方法设置回传的数据. 
注意：设置完后不会立刻传递到前一个页面,而是等待当前页面关闭后, 才会回传数据。
回传数据给传递给前一个页面的onActivityResult方法，在此方法中对数据进行处理即可。
需求：在MainActivity页面中输入用户名，点击计算跳转到计算页面，计算页面计算完毕后将计算结果返回给MainActivity界面，该界面将计算结果显示出来。
1、 创建一个新工程《人品计算器》
使用默认的Activity和默认的布局文件，修改布局文件。activity_main.xml布局清单如下：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/rp"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <EditText
        android:layout_centerVertical="true"
        android:hint="请输入姓名"
        android:id="@+id/et"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <Button
        android:layout_below="@id/et"
        android:layout_alignParentRight="true"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="计算"
        android:id="@+id/bt"
        android:onClick="click" />
    <TextView 
        android:id="@+id/tv"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/bt"
        android:visibility="invisible"
        android:textSize="28sp"
        android:textColor="#0000ff"
        />
</RelativeLayout>
上面布局文件采用相对布局，其中android:background="@drawable/rp"，该属性的作用是给界面设置背景图片，需要我们将图片添加到/res/drawable-hdpi目录下面。
android:visibility="invisible"属性是设置该控件不显示，显示的时候我们可以通过代码来实现其显示。
2、 编写MainActivity核心代码类
public class MainActivity extends Activity {
	private TextView tv;
	private EditText et;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		tv = (TextView) findViewById(R.id.tv);
		et = (EditText) findViewById(R.id.et);
	}
	public void click(View view) {
		String data = et.getText().toString();
		if (data == null || "".equals(data.trim()) || data.length() > 10) {
			Toast.makeText(this, "大哥，您输入的是人名吗？", Toast.LENGTH_SHORT).show();
			et.setText("");
			tv.setVisibility(View.INVISIBLE);
			return;
		}
		byte[] bytes = data.getBytes();
		int result = 0;
		for (byte b : bytes) {
			result += b;
		}
		result = Math.abs(result % 101);
		//创建一个新Intent
		Intent intent = new Intent(this,CalcActivity.class);
		//将数据绑定到Intent中
		intent.putExtra("rp", result);
		//打开一个新的Activity，并接收器返回数据 请求码为1，我们可以将请求码理解为消息接应的暗号
		startActivityForResult(intent, 1);
	}
	/**
	 * 当当前Activity用startActivityForResult方式调用另外一个Activity的时候，
	 * 另外一个Activity将数据返回后会Android系统会调用该方法
	 * 
	 */
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		//从当前Intent中获取数据
		Bundle extras = data.getExtras();
		String result  = (String) extras.get("result");
		//在也页面显示计算结果
		tv.setVisibility(View.VISIBLE);
		tv.setText(result);
	}

}

3、 新建CalcActivity
创建CalcActivity继承自Activity类，并在AndroidManifest.xml中添加该类。
public class CalcActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		//获取当前Intent
		Intent intent = getIntent();
		//获取Intent中绑定的数据
		Bundle extras = intent.getExtras();
		//获取rp
		int data = (Integer) extras.get("rp");
		//计算人品结果
		String result = getRPText(data);
		//创建一个新的Intent
		Intent intent2 = new Intent();
		//将结果绑定到Intent中
		intent2.putExtra("result", result);
		//返回请求码和结果
		setResult(1, intent2);
		//关闭当前Activity
		finish();
	}
		//关闭当前Activity
		finish();
	}
private String getRPText(int rp) {
		String rpText = null;
		if (rp == 0) {
			rpText = "你一定不是人吧？怎么一点人品都没有？！";
		} else if (rp > 0 && rp <= 5) {
			rpText = "算了，跟你没什么人品好谈的...";
		} else if (rp > 5 && rp <= 10) {
			rpText = "是我不好...不应该跟你谈人品问题的...";
		} else if (rp > 10 && rp <= 15) {
			rpText = "杀过人没有?放过火没有?你应该无恶不做吧?";
		} else if (rp > 15 && rp <= 20) {
			rpText = "你貌似应该三岁就偷看隔壁大妈洗澡的吧...";
		} else if (rp > 20 && rp <= 25) {
			rpText = "你的人品之低下实在让人惊讶啊...";
		} else if (rp > 25 && rp <= 30) {
			rpText = "你的人品太差了。你应该有干坏事的嗜好吧?";
		} else if (rp > 30 && rp <= 35) {
			rpText = "你的人品真差！肯定经常做偷鸡摸狗的事...";
		} else if (rp > 35 && rp <= 40) {
			rpText = "你拥有如此差的人品请经常祈求佛祖保佑你吧...";
		} else if (rp > 40 && rp <= 45) {
			rpText = "老实交待..那些论坛上面经常出现的偷拍照是不是你的杰作?";
		} else if (rp > 45 && rp <= 50) {
			rpText = "你随地大小便之类的事没少干吧?";
		} else if (rp > 50 && rp <= 55) {
			rpText = "你的人品太差了..稍不小心就会去干坏事了吧?";
		} else if (rp > 55 && rp <= 60) {
			rpText = "你的人品很差了..要时刻克制住做坏事的冲动哦..";
		} else if (rp > 60 && rp <= 65) {
			rpText = "你的人品比较差了..要好好的约束自己啊..";
		} else if (rp > 65 && rp <= 70) {
			rpText = "你的人品勉勉强强..要自己好自为之..";
		} else if (rp > 70 && rp <= 75) {
			rpText = "有你这样的人品算是不错了..";
		} else if (rp > 75 && rp <= 80) {
			rpText = "你有较好的人品..继续保持..";
		} else if (rp > 80 && rp <= 85) {
			rpText = "你的人品不错..应该一表人才吧?";
		} else if (rp > 85 && rp <= 90) {
			rpText = "你的人品真好..做好事应该是你的爱好吧..";
		} else if (rp > 90 && rp <= 95) {
			rpText = "你的人品太好了..你就是当代活雷锋啊...";
		} else if (rp > 95 && rp <= 99) {
			rpText = "你是世人的榜样！";
		} else if (rp == 100) {
			rpText = "天啦！你不是人！你是神！！！";
		} else {
			rpText = "你的人品竟然负溢出了...我对你无语..";
		}
		return rpText;
	}
上面代码中，getRPText方法大家在练习的时候直接拷贝即可，没必要再重新写一遍。
运行上面的工程，启动后页面左侧图，输入名字后点击计算，结果如右侧图。


15.9. Activity生命周期（★★★★）
Activity有三种状态：
  1、当它在屏幕前台时,响应用户操作的Activity, 它是激活或运行状态
  2、当它上面有另外一个Activity，使它失去了焦点但仍然对用户可见时, 它处于暂停状态。
  3、当它完全被另一个Activity覆盖时则处于停止状态。
当Activity从一种状态转变到另一种状态时，会调用其生命周期方法。Activity一共有七个生命周期方法，具体如下表所示。
方法名
说明
 void onCreate()
设置布局以及进行初始化操作
void onStart()
可见, 但不可交互
void onRestart()	
调用onStart()
void onResume()
可见, 可交互
void onPause()
部分可见, 不可交互
void onStop()
完全不可见
void onDestroy()	
销毁
Activity生命周期图如下所示。


startActivity开启一个Activity时, 生命周期的过程是: onCreate onStart(可见不可交互) onResume(可见可交互)
点击back键关闭一个Activity时, 生命周期的过程是: onPause(部分可见不可交互) onStop(完全不可见) onDestroy(销毁)
当开启一个新的Activity(以对话框形式)，新的activity把后面的activity给盖住一部分时，后面的activity的生命周期执行的方法是:onPause(部分可见, 不可交互)。
注意：指定Activity以对话框的形式显示, 需在activity节点追加以下主题android:theme="@android:style/Theme.Dialog"
当把新开启的Activity(以对话框形式)给关闭时, 后面的activity的生命周期执行的方法是: onResume(可见，可交互)
当开启一个新的activity把后面的activity完全盖住时, 生命周期的方法执行顺序是: onPause onStop(完全不可见)。
当把新开启的activity(完全盖住)给关闭时, 生命周期的方法执行顺序是: onRestartonStart onResume(可见, 可交互)。
实际工作中常用的方法以及应用场景有：onResume 可见, 可交互，在该方法中可进行刷新数据操作。onPause 可见，但是不能响应用户操作，在该方法中可进行操作暂停。onCreate 初始化布局以及一些大量的数据。onDestroy 把数据给释放掉, 节省内存。
15.9.1. 横竖屏切换问题
横竖屏切换时,默认情况下会把activity先销毁再创建，在类似手机游戏这一类的应用中，这个体验是非常差的。不让Activity在横竖屏切换时销毁，只需要在清单文件声明Activity时配置<activity>节点的几个属性即可，其方式如下：
4.0以下版本：
android:configChanges="orientation|keyboardHidden" 
4.0以上版本：
android:configChanges="orientation|screenSize"
兼容所有版本
android:configChanges="orientation|keyboardHidden|screenSize"
configChange="orientation" 屏幕方向改变：不让屏幕在切换时重新创建activity。sreensize 屏幕大小，keyboardHidden是软键盘，如果切换屏幕，软键盘会去判断屏幕大小是否合适显示软键盘，在判断过程中会重启activity。
 禁止横竖屏：screenOrientation="" 指定屏幕固定方向，不会随着屏幕旋转而旋转，landscape横屏（旋转以后顺时针旋转90度，还是横屏），portrait竖屏，   旋  转以后逆时针旋转90度，还是竖屏。sensorLandscape：根据手机左右倒，而横屏旋转，sensor：上左右三个方向。
15.9.2. 保存Activity信息
onSaveInstanceState：在Activity被动的摧毁或停止的时候调用，用于保存运行数据，可以将数据存在在Bundle中。onPause之后执行。被动消耗，指被系统回收，不是主动调用finish方法。
onRestoreInstanceState：该方法在Activity被重新绘制的时候调用，例如改变屏幕方向，savedInstanceState为onSaveInstanceState保存的数据。
activity重新创建，恢复数据，onStart之后执行。如果activity停止之后，进程在后头很容易被杀死，然后重新启动，就会执行恢复数据方法

15.10. Activity的任务栈（★★★★）
任务栈是用来提升用户体验而设计的:
(1)程序打开时就创建了一个任务栈, 用于存储当前程序的activity,所有的activity属于一个任务栈。
(2)一个任务栈包含了一个activity的集合, 去有序的选择哪一个activity和用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。
(3)任务栈可以移动到后台, 并且保留了每一个activity的状态. 并且有序的给用户列出它们的任务, 而且还不丢失它们状态信息。
(4)退出应用程序时：当把所有的任务栈中所有的activity清除出栈时,任务栈会被销毁,程序退出。
任务栈的缺点：
(1)每开启一次页面都会在任务栈中添加一个Activity,而只有任务栈中的Activity全部清除出栈时，任务栈被销毁，程序才会退出,这样就造成了用，户体验差, 需要点击多次返回才可以把程序退出了。
(2)每开启一次页面都会在任务栈中添加一个Activity还会造成数据冗余, 重复数据太多, 会导致内存溢出的问题(OOM)。
为了解决任务栈产生的问题，Android为Activity设计了启动模式，那么下面的内容将介绍Android中Activity的启动模式，这也是最终要的内容之一。
15.11. Activity的启动模式（★★★★）
启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。
Activity一共有以下四种launchMode：standard，singleTop，singleTask，singleInstance。在AndroidManifest.xml配置<activity>的android:launchMode属性为以上四种之一即可。
15.11.1. standard
standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。
创建一个Activity命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下：
public class FirstActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.first);
        TextView textView = (TextView) findViewById(R.id.tv);
        textView.setText(this.toString());
        Button button = (Button) findViewById(R.id.bt);
        button.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(FirstActivity.this, FirstActivity.class);
		    	startActivity(intent);
			}
		});
    }
}
FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。连续点击几次按钮，将会出现下面的现象：
  

从上图可以看出，三个图片都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FirstActivity。standard模式的原理如下图所示：

如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。
这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。即每次调用startActivity()启动时都会创建一个新的Activity放在栈顶，可重复创建。
15.11.2. singleTop
我们在上面的基础上为<activity>指定属性android:launchMode="singleTop"，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象：


我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例，如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示：

正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。
我们再新建一个Activity命名为SecondActivity，如下：
public class SecondActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.second);
		TextView textView = (TextView) findViewById(R.id.tv);
        textView.setText(this.toString());
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(SecondActivity.this, FirstActivity.class);
		    	startActivity(intent);				
			}
        });
	}
}

然后将之前的FirstActivity跳转代码改为：
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);  
startActivity(intent);  
这时候，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下：
 

我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下：

当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例，但不是位于栈顶，于是重新生成一个实例。
这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。即启动Activity时，指定Activity不在栈顶(界面最顶端)就创建，如在栈顶，则不再创建。activity也可被重复创建。
15.11.3. singleTask
在上面的基础上修改FirstActivity的属性android:launchMode="singleTask"。演示的结果如下：


在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示：

在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。
也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。
这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。即如果启动的Activity不存在就创建，如果存在，就会清空自己上边所有的界面，使自己变为栈顶。activity不可重复创建
自己不能打开自己，同一个界面只能被打开一次，如果其他页面打开一存在的界面，那么会移除被打开页面之上的所有页面。
15.11.4. singleInstance
这种启动模式比较特殊，因为它会启用一个新的栈结构，将Activity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。
修改FirstActivity的launchMode="standard"，SecondActivity的launchMode="singleInstance"，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：
TextView taskIdView = (TextView) findViewById(R.id.taskIdView);  
taskIdView.setText("current task id: " + this.getTaskId()); 
然后我们再演示一下这个流程：

发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：
	
看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，需要“回归”到这个栈结构。
如果修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：

singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：
<activity
 	android:name=".ShareActivity"
 	android:launchMode="singleInstance" >
  <intent-filter>
  <action android:name="android.intent.action.MAIN" />
  <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
   <intent-filter>
<action android:name="android.intent.action.SINGLE_INSTANCE_SHARE" />
<category android:name="android.intent.category.DEFAULT" />
   </intent-filter>
</activity>
然后我们在其他应用中这样启动该Activity：
Intent intent = new Intent("android.intent.action.SINGLE_INSTANCE_SHARE");  
startActivity(intent);  
当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下：

开启新的任务栈，并且只有一个界面存在，使自己变为栈顶。即使自己所在的应用程序已经存在任务栈，也会新建一个任务栈，不会和同应用程序的其他界面共享任务栈
15.12. 内存管理
	Android系统在运行多个进程时，如果系统资源不足，会强制结束一些进程。优先选择哪个进程来结束是有优先级的。
前台进程：
Foreground process，进程中正在运行一个可交互的Activity，应用程序的界面在最顶端，此应用程序所占进程就是前台进程。优先级别最高，即便系统内存不足，也不会轻易被杀死
可见进程：
visible process，进程中有一个暂停状态的Activity，不是在最顶端，但是仍然可见的应用程序所在进程，就叫可见进程。例如：对话框应用程序，他下边的程序仍然可见。次高，系统内存不足时，可能被杀死
服务进程：
进程中有正在运行的服务。中等，会被杀死。
后台进程：
进程中只有停止状态的Activity，不可见的程序所在进程，但是还有组件存在进程中。比较容易回收
空进程：  
进程中没有任何组件。最容易被回收。

15.13. 结合工作和面试
1. 面试中
Activity生命周期
一般面试会模拟一个操作，让你去分析会执行什么样的方法。比如：A Activity打开B Activity，那么在点击返回。此时B Activity会执行什么方法，A Activity会执行什么方法？分两种情况：B Activity是/不是一个对话框。
Activity如何传递数据
通过Intent传递，那么Intent都可以传递什么类型的数据？
Activity任务栈
这个也比较重要，面试的时候答的好，会给你自己加分。
Activity启动模式
这个也重要，2年工作经验的必须知道。
横竖屏切换问题？
如何保存Activity信息？
Intent和IntentFilter的区别
Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。
通过Intent 可以实现各种系统组件的调用与激活，Intent filter: 可以理解为邮局或者是一个信笺的分拣系统，定义一些匹配条件。这个分拣系统通过3个参数来识别。Action: 动作 Intent.ation_view ，Data: 数据uri  uri  mime，Category : 另外的附加信息
2. 工作中
Activity
四大组件中，就属Activity用的最多，ContentProvider用的最少。所以Activity需要重点学习。
了解Activity的生命周期的每个方法，根据需求，在各个方法做不同的事情。
比如说某些客户端有这样的一个需求：每次进入某个界面的时候都要看到最新的数据,那么这个刷新列表的操作fillData() 就放在onStart()的方法里面.这样保证每次用户看到的数据都是最新的
Activity直接跳转，这个必须会，是最基本的。
Activity如何传递数据，这个也是最基本的。
startActivityForResult如何使用，数据回传，用的比较多。
16. 四大组件之BroadcastReceiver
16.1. BroadcastReceiver简介（★★★★）
在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的Broadcast进行过滤接受并响应的一类组件。
广播接收者（BroadcastReceiver）用于接收广播Intent的, 广播Intent的发送是通过调用sendBroadcast/sendOrderedBroadcast来实现的。通常一个广播Intent可以被订阅了此Intent的多个广播接收者所接收。
16.1.1. BroadcastReceiver简单应用
需求：定义一个广播接收器，用于接收SDCard移除时发送的广播。具体实现步骤如下：
1、 创建一个新的Android工程
创建一个工程名为——广播接收器，包名：com.itheima.broadcastReciver。
2、 创建广播接收者
在src目录下新建一个SDCardUnmountedReceiver类继承BroadcastReceiver类，覆写onReceive方法,代码清单如下：
public class SDCardUnmountedReceiver extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		Toast.makeText(context, "SDCard已经被移除！", 0).show();
	}
}
当接收到匹配广播之后就会执行onReceive方法
3、 注册SDCardUnmountedReceiver。
注册一个广播接收者有两种方式。静态注册：在AndroidManifest.xml中注册广播。清单文件中声明<receiver>，需要在其中配置<intent-filter>指定接收广播的动作(action)，在AndroidManifest.xml文件中添加如下配置：
<receiver android:name="com.itheima.broadcastReciver.SDCardUnmountedReceiver">
            <intent-filter>
<action android:name="android.intent.action.MEDIA_UNMOUNTED"/>
          <data android:scheme="file"></data>
            </intent-filter>
</receiver>
这里的这个动作，是指sd卡未挂载。
动态注册：在Java代码中注册
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		IntentFilter intentFilter = new IntentFilter("android.intent.action.MEDIA_UNMOUNTED");
		intentFilter.addDataScheme("file");
		registerReceiver(new SDCardUnmountedReceiver(), intentFilter);
		System.out.println("广播接收器已经注册成功。");
	}
}
 两种注册的区别： 代码注册，它不是常驻型广播，也就是说广播跟随程序的生命周期，一旦代码所在进程被杀死，广播接收者就失效。清单文件注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。一旦应用程序被部署到手机，广播接收者就会生效，高版本的模拟器（3.2以上）中的接收者，需要启动过一次才能接收到广播。
3.2版本以上出于安全问题：从未启动过的广播接收程序，默认是接收不到广播的，必须有一个界面，然后通过界面启动一次这个程序。
由于Android高版本中已经不支持SDCard的卸载，因此我们使用Android 2.3版本的模拟器。在settings->Storage settings中可以找到Unmount SD Card。点击此选项可以移除SDCard。
软件运行效果如下图所示，从下图中可以发现Toast成功打印出了“SDCard已经被移除”信息。

16.1.2. 生命周期
广播接收者也是运行在主线程中，所以在广播接收者的onReceive方法内不能有耗时的操作，需要放在子线程中做，但是onReceive的生命周期很短，有可能广播接收者结束，子线程还没有结束，这时广播接收者所在进程很有可能被杀掉，这样子线程就会出问题，所以耗时操作最好放到service服务中。
广播接收者的生命周期是非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁。
广播接收者中不要做一些耗时的工作，否则会弹出Application No Response错误对话框。
最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉
16.2. Android中常见广播（★★★）
16.2.1. 监听拨打电话广播
需求：监听用户拨打电话，在用户拨打电话号码前自动加上17951等。拦截的广播：
<action android:name="android.intent.action.NEW_OUTGOING_CALL"></action>
需要的权限：
<uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/>

1、新创建一个Android工程《IPCaller》。
在src目录下新创建一个类IPCallerReceiver继承BroadcastReceiver，重写OnReceive方法。
public class IPCallReveiver extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		//获取拨打的电话号码
		String resultData = getResultData();//获取数据
		//在电话号码前加上17951，然后返回数据
		setResultData("17951"+resultData);//设置数据
	}
}
2、在AndroidManifest.xml中注册广播接收者。
在下面的配置文件中 <intent-filter android:priority="1000">属性代表着给当前接收者设置优先级，优先级越高越优先接收到广播。
<receiver android:name="com.itheima.ipcaller.IPCallReveiver">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.NEW_OUTGOING_CALL"></action>
            </intent-filter>
        </receiver>
运行上面的代码，然后拨打电话5556，发现拨出去的号码已经变为179515556。


16.2.2. 监听系统开机的广播
需求：拦截手机开机的广播，手机开机后，弹一个提示。拦截的广播：
<action android:name="android.intent.action.BOOT_COMPLETED"></action>
需要的权限: 
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
模拟器重启命令：adb shell reboot。3.2以上版本必须加权限, 以下的版本可以不加,3.2以上的版本如果用户没有启动过程序, 接收不到开启启动完成的广播。
1. 新创建一个Android工程《开机启动》。
在src目录下新创建一个类BootReceiver继承BroadcastReceiver，重写OnReceive方法。
public class BootReceiver extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		Toast.makeText(context, "开机启动已经完成", 1).show();
	}
}
2. 在AndroidManifest.xml中注册广播接收者。
<receiver android:name="com.itheima.bootStart.BootReceiver" >
	    <intent-filter>
	        <action android:name="android.intent.action.BOOT_COMPLETED"></action>
	    </intent-filter>
	</receiver>
3. 将上面的代码部署到模拟器上
然后关机重启模拟器。运行效果图如下：


16.2.3. 监听安装和卸载程序的广播
需求：监听程序的安装或者卸载，并在LogCat中输出提示信息。
拦截的广播：
<action android:name="android.intent.action.PACKAGE_ADDED"></action>
<action android:name="android.intent.action.PACKAGE_REMOVED"></action>

1. 新创建一个Android工程《监听应用安装与卸载》
2. 新创建InstallReceiver类继承BroadcastReceiver类，覆写onReceive方法
public class InstallReceiver extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		//获取包名称
		String packageName = intent.getData().toString();
		String action = intent.getAction();
		//如果是卸载动作
		if ("android.intent.action.PACKAGE_REMOVED".equals(action)) {
			Toast.makeText(context, packageName + "已经被删除！", 1).show();
			System.out.println(packageName + "已经被删除！");
		//如果是安装动作
		} else if ("android.intent.action.PACKAGE_ADDED".equals(action)) {
			Toast.makeText(context, packageName + "已经被安装！", 1).show();
			System.out.println(packageName + "已经被安装！");
		}
	}
}
3. 在AndroidManifest.xml清单中注册InstallReceiver。
  <receiver android:name="com.itheima.installReceiver.InstallReceiver">
           <intent-filter>
 <action android:name="android.intent.action.PACKAGE_REMOVED"/>
<action android:name="android.intent.action.PACKAGE_ADDED"/>
               <data android:scheme="package"/>
           </intent-filter>
 </receiver>
4. 将上面的工程部署在模拟器上。
然后通过系统应用管理工具，卸载一个应用程序，发现成功接收到了应用被卸载的广播。运行图如下：

16.2.4. 拦截短信
需求：对用户接收的短信进行拦截，若是10086发来的短信，将此短信拦截。
分析：Android系统在收到短信的时候会发送一条有序广播，我们如果定义一个接收者接收这个广播，就可以得到短信内容，也可以拦截短信。
拦截的广播：
<action android:name="android.provider.Telephony.SMS_RECEIVED"></action>
需要的权限: 
<uses-permission android:name="android.permission.RECEIVE_SMS"/>
注意：android 4.2 后废除了此action。
新创建一个工程《短信拦截》,在src目录下新建SMSReceiver类继承BroadcastReceiver类
public class SMSReceiver extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		//获取短信数据 pdus：短信集合
		Object[] objs = (Object[]) intent.getExtras().get("pdus");
		for(Object pdu : objs){
			//通过Android API中的SmsMessage类将短信字节数组转化为短信对象
			SmsMessage message = SmsMessage.createFromPdu((byte[])pdu);
			//获取短信来源，发送者
			String address = message.getOriginatingAddress();
			//获取短信内容
			String body = message.getMessageBody();
			//短信短信内容
			System.out.println(address+"--"+body);
			Toast.makeText(context, address+"--"+body, 1).show();
if("10086".equals(address)){//过滤号码为10086的短信
//终止广播
				abortBroadcast();
			}
		}
	}
}
1. 在AndroidManifest.xml中注册短信拦截器
  <receiver android:name="com.itheima.smsreceiver.SMSReceiver">
            <intent-filter android:priority="1000">
                <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
            </intent-filter>
        </receiver>

其实我们模拟的是一个拦截骚扰短信的案例，所以我们需要在系统短信应用（系统优先级默认为0）之前接收到，优先级可以配置较高的priority(1000)，收到信息进行判断是否abortBroadcast()。
2. 在AndroidManifest.xml中添加权限
<uses-permission android:name="android.permission.RECEIVE_SMS"/>
3. 将上面的工程部署在模拟器上
打开DDMS视图，选择Emulator Control 选项卡，在Incomeing number：中填写一个号码，模拟发送消息的号码。然后选择SMS单选按钮，在右侧的输入框输入短信的内容。然后点击Send按钮，发送信息。 
运行截图如下：发现成功拦截了刚才发送的短信。



16.3. 发送自定义广播（★★★★）
16.3.1. 无序广播
 无序广播不可以被拦截，如果被拦截的话会报错：
BroadcastReceiver trying to return result during a non-ordered broadcast
 所有接收无序广播的广播接收者在此广播被发送时均能接收到此广播，并且是同时接收到。无序广播使用sendBroadcast方法来发送，无序广播的实现比较简单，因此这里只给出核心代码。
public void sendBroadcast(View view){
		//定义一个意图
		Intent intent = new Intent();
		//设置Action
		intent.setAction("com.itheima.broadcast");
		//绑定数据
		intent.putExtra("data", "我是无序广播数据");
		//发送无序广播
		sendBroadcast(intent);
	}

sendBroadCast(intent);符合这个intent的接收者接收这个广播。这个intent指定的action，可以是自定义的动作。那么接受者，定义的intent的action也需要指定发送广播的意图动作。
注意：
符号某广播条件的所有广播接收者的特点，无序，无优先级，不可中断，不可传递数据。
广播时可设置接收者权限，仅当接收者含有权限才能接收。
接收者的<receiver>也可设置发送方权限，只接收含有权限应用的广播Receiver节点增加属性permission。
发送广播时，通过intent.setFlags(intent.flag_include_stopped_pakeages)，包含从未启动过的程序，这样设置，可以让从未启动的接收者也收到广播。

16.3.2. 有序广播
无序广播使用sendOrderedBroadcast方法来发送
接收者可以在<intent-filter>中定义android:priority定义优先级，数字越大优先级越高，优先级的取值范围是: 1000(最高) ~ -1000(最低)谷歌规定最大是1000，但是他的类型其实是int。
系统默认优先级是0，那么想在系统程序之前接收到广播，那么就设置大于0的数，相同优先级下,接收的顺序要看在清单文件中声明注册的顺序。
有序广播可以被拦截或添加数据，优先级高的接收者可以拦截优先级低的 ，使用abortBroadcast方法拦截， 添加数据：通过bundle传递。
前面的接收者可以将数据通过setResultExtras(Bundle)方法存放进结果对象，
然后传给下一个接收者，下一个接收者通过代码：Bundle bundle = getResultExtras(true))可以获取上一个接收者存入在结果对象中的数据。

新创建一个项目，来演示无序广播的发送和接收过程。
1. 新创建一个Android工程《广播发送和接收》，包名com.itheima.broadcastAndreceiver。
2. 在默认的MainActivity的布局中添加一个按钮，绑定事件，该事件的核心功能是发送一个有序广播，MainActivity类代码清单如下：
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
	public void sendOrder(View view) {
		// 意图
		Intent intent = new Intent();
		intent.setAction("com.itheima.data");
		/**
		 * intent The Intent to broadcast; all receivers matching this Intent
		 * will receive the broadcast. receiverPermission String naming a
		 * permissions that a receiver must hold in order to receive your
		 * broadcast. If null, no permission is required. resultReceiver Your
		 * own BroadcastReceiver to treat as the final receiver of the
		 * broadcast. scheduler A custom Handler with which to schedule the
		 * resultReceiver callback; if null it will be scheduled in the
* Context's main thread. initialCode An initial value for the result
		 * code. Often Activity.RESULT_OK. initialData An initial value for the
		 * result data. Often null. initialExtras An initial value for the
		 * result extras. Often null.
		 * 第一个参数 Intent类型：意图
		 * 第二个参数 String类型 receiverPermission，接收器需要的权限
		 * 第三个参数BroadcastReceiver类型，自己定义的接收器作为最终接收器
		 * 第四个参数Handler类型，用于执行接收器的回调，如果为null则在主线程中执行
		 * 第五个参数int类型，结果代码的初始码
		 * 第六个参数初始化参数
		 * 第七个参数Bundle类型，额外的数据
		 */
		sendOrderedBroadcast(intent, null, null,
		null, RESULT_OK, "1万元钱", null);

	}
3. 分别编写MyReceiver和MyReceiver2类，继承BroadcastReceiver类
 MyReceiver类代码清单：
public class MyReceiver extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		String action = intent.getAction();
		String resultData = getResultData();
		Toast.makeText(context, "MyReceiver接收到"+action+"发布的广播："+resultData, 1).show();
		System.out.println("MyReceiver接收到"+action+"发布的广播："+resultData);
		}
}
 MyReceiver2类代码清单：
public class MyReceiver2 extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		String action = intent.getAction();
		String resultData = getResultData();
		Toast.makeText(context, "MyReceiver2接收到"+action+"发布的广播："+resultData, 1).show();
		System.out.println("MyReceiver2接收到"+action+"发布的广播："+resultData);
		
	}
}
4. 在AndroidManifest.xml中注册MyReceiver和MyReceiver2
<receiver android:name="com.itheima.broadcastAndreceiver.MyReceiver">
            <intent-filter android:priority="1000">
                <action android:name="com.itheima.data"></action>
            </intent-filter>
        </receiver>
        <receiver android:name="com.itheima.broadcastAndreceiver.MyReceiver2">
            <intent-filter android:priority="-1000">
                <action android:name="com.itheima.data"></action>
            </intent-filter>
        </receiver>
上述代码中，我们给MyReceiver设置了最高优先级1000，给MyReceiver2设置了最低优先级-1000。
5. 下面我们分多钟情况，分别演示有序广播的接收规律。
直接部署上面的工程到模拟器，点击发送广播按钮，控制台结果为：

我们发现MyReceiver先接收到了广播，然后MyReceiver2才接收到广播。修改MyReceiver类的代码：在onReceive方法中添加abortBroadcast（）方法，
public class MyReceiver extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		String action = intent.getAction();
		String resultData = getResultData();
		Toast.makeText(context, "MyReceiver接收到"+action+"发布的广播："+resultData, 1).show();
		System.out.println("MyReceiver接收到"+action+"发布的广播："+resultData);
		abortBroadcast();
	}
}
重新部署该工程，运行，点击发送广播按钮。这时控制台打印信息为：

我们发现只有MyReceiver接收到了广播，而MyReceiver2没有接收到广播。原因就是我们在MyReceiver中执行了abortBroadcast（）方法，终止了该广播。
在第二种情况的基础上，我们修改MainActivity类中sendOrder方法，修改sendOrderedBroadcast中第三个参数，指定一个最终接收器。
public void sendOrder(View view) {
		// 意图
		Intent intent = new Intent();
		intent.setAction("com.itheima.data");
		 sendOrderedBroadcast(intent, null, new MyReceiver2(),
		null, RESULT_OK, "1万元钱", null);
}
运行上面工程，然后点击发送广播按钮，发现控制台输出如下信息：

我们发现，虽然在MyReceiver中我们调用了abortBroadcast();方法，但是广播依然被MyReceiver2接收到。原因是我们在sendOrderedBroadcast方法中指定了MyReceiver2接收器为最终接收器，因此该广播被终止的时候MyReceiver2接收器依然可以接收到广播。
 在第3种情形的基础上，我们修改MyReceiver类，我们将该类中的onReceive方法中的abortBroadcast();方法去掉。然后运行上面工程。发现控制台输入如下信息：

我们发现MyReceiver第一个接收到广播，MyReceiver2第二个接收到广播，然后MyReceiver2又接收到一次广播。对的，结果确实是这样，因为我们在sendOrderedBroadcast方法中，将MyReceiver2作为最终接收器，那么我们发出的广播会被所有符合条件的接收器接收，最后指定的最终接收器不管是否已经接收过信息依然会再次接收。
16.4. 结合工作和面试
1. 面试中
请描述一下广播？
广播是Android系统的一个事件,他通过广播的机制去分发这个事件，系统已经实现了很多广播接收者。像：低电量，手机重启，接收短信，拨打电话，sd卡挂载,一个apk的安装成功…，系统都会通过广播给这些事件分发出去。这个广播被分发出去之后呢，如果有人想接收到这个广播事件，就需要用这个广播接收者了。
然后介绍一下广播分几种，广播的优先级，如何终止广播。以及一些常见广播如何实现。
广播中是否可以做耗时操作？
这个笔试面试，都可能被问。笔记中已经记录过。请自己总结，组织语言。
广播的生命周期？
广播分为几种？
答完2种之后，需要分别介绍下如何使用，有何特点，对比分析下。什么场景用哪种广播。
粘性广播
Sticky：粘性  开发很少用到，但是面试有可能会问到：sendStickyBroadcast(intent)  阴魂不散的广播 （粘性的广播）。粘性广播，会一直等待intent指定的事件处理完毕，才会消失。
广播接受者的生命周期都是比较短的，一般接受到广播之后10s左右就会结束，但是有一些广播事件是比较耗时的。比如WIFI状态改变。
Wifi设置：发送wifi状态改变的广播，系统就是通过sendStickyBroadcast来实现的，因为获取wifi状态改变是一个很耗时的操作（获取手机的SSID，并且会获取IP地址等等一系列操作），如果用一般发送广播方式，还没等wifi状态获取完，广播就结束了。
注册广播的两种方式，区别？
2. 工作中
 广播
工作中，每个应用都有可能会用到广播，但是不算多。而且一般是用到一些自定义的广播，应用内进行通信。所以大家需要掌握广播接收者的使用方法，以及如何发送广播。练习一下常见广播即可。
自定义广播：
//自定义行为
    private final String MY_ACTION = "android.com.example.broadcastreceiver.action.MYACTION";
    // 发送广播
    public void sendBroadcast() {
        Intent intent = new Intent();
        
        /* 设置Intent对象的action属性 */
        intent.setAction(MY_ACTION);
        
        /* 为Intent对象添加附加信息 */
        intent.putExtra("msg", "发送广播测试成功.....");        
        /* 发布广播 */
        sendBroadcast(intent);
    }    
    // 广播接收者
    private class MyBroadcastReceiver extends BroadcastReceiver {        
        /* 覆写该方法，对广播事件执行响应的动作 */
        public void onReceive(Context context, Intent intent) {
            
            /* 获取Intent对象中的数据 */
            String msg = intent.getStringExtra("msg");
            
            /*  */
            Toast.makeText(context, msg, 1000).show();
        }
        
    }
 为广播接收组件注册 
 <receiver android:name=".MyBroadcastReceiver">
     <intent-filter>
         <action android:name="android.com.example.broadcastreceiver.action.MYACTION" />
         <category android:name="android.intent.category.LAUNCHER" />
     </intent-filter>
 </receiver>

17. 四大组件之Service
17.1. Service简介（★★★）
很多情况下，一些与用户很少需要产生交互的应用程序，我们一般让它们在后台运行就行了，而且在它们运行期间我们仍然能运行其他的应用。为了处理这种后台进程，Android引入了Service的概念。
Service在Android中是一种长生命周期的组件，它不实现任何用户界面,是一个没有界面的组件，由其他组件开启。
Service长期在后台运行, 执行不关乎界面的一些操作比如: 网易新闻服务,每隔1分钟去服务查看是否有最新新闻。
Service和Thread有点相似,但是使用Thread不安全, 不严谨
Service和其他组件一样，都是运行在主线程中，因此不能用它来做耗时的操作。
17.2. Android中的进程（★★）
17.2.1. Android中进程的种类
进程优先级由高到低，依次为：
Foreground process 前台进程        
Visible process 可视进程, 可以看见, 但不可以交互.        
Service process 服务进程        
Background process 后台进程        
Empty process 空进程(当程序退出时, 进程没有被销毁, 而是变成了空进程)
17.2.2. 进程的回收机制
Android系统有一套内存回收机制,会根据优先级进行回收。Android系统会尽可能的维持程序的进程, 但是终究还是需要回收一些旧的进程节省内存提供给新的或者重要的进程使用。
进程的回收顺序是：从低到高。
当系统内存不够用时, 会把空进程一个一个回收掉。
当系统回收所有的完空进程不够用时, 继续向上回收后台进程, 依次类推。
但是当回收服务, 可视, 前台这三种进程时, 系统非必要情况下不会轻易回收, 如果需要回收掉这三种进程, 那么在系统内存够用时, 会再给重新启动进程;但是服务进程如果用户手动的关闭服务, 这时服务不会再重启了。
17.2.3. 为什么用服务而不是线程
进程中运行着线程， Android应用程序刚启动都会开启一个进程给这个程序来使用。Android一个应用程序把所有的界面关闭时, 进程这时还没有被销毁, 现在处于的是空进程状态,Thread运行在空进程中, 很容易的被销毁了。
服务不容易被销毁, 如果非法状态下被销毁了, 系统会在内存够用时, 重新启动。
17.3. 如何使用Service（★★★）
创建Service，定义类继承Service，AndroidManifest.xml中定义<service>
开启Service，在其他组件中调用startService方法
startService(intent);（在activity中可以直接调用），会执行onstartCommand(生命周期方法)(onStart()以过期的方法)，如果发现service还没有，就会先创建执行oncreate。
onCreate只会执行一次，服务一旦被创建出来，就不会再执行onCreate方法，以后再去开启服务只会执行onStartCommand。
停止Service，调用stopService方法，会执行onDestory()（生命周期方法）。
服务也是运行在主线程中，耗时操作需要放到子线程中，不然会出现anr
setForegound(true)(直接在service里调用)，为了避免服务被杀死，我们可以指定这个服务为前台进程。
服务在执行生命周期方法时，也是一个前台进程。广播接收者也一样，在执行生命周期方法onReceive时，也是一个前台进程。
17.4. 案例-电话窃听器（★★★）
需求：开启一个服务监听用户电话，当电话被接通时开始录音，电话挂断时停止录音。
1、 新建一个Android工程《电话窃听器》，包名：com.itheima.listenCall。 
2、 在src目录下新创建一个MyService类继承Service类，在该类中实现核心业务方法，实现监听电话，以及完成录音的功能。
代码：
public class MyService extends Service {
	/**
	 * 绑定服务时调用
	 */
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}
	/**
	 * 服务被创建时调用
	 */
	@Override
	public void onCreate() {
		super.onCreate();
		System.out.println("服务已经被创建。");
//得到手机电话相关的管理服务类
// getSystemService获取系统服务的方法，传入WIFI_service，获取的是wifi网络服务
		TelephonyManager telephonyManager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
		//给电话管理注册监听器
		//listen(phoneStateListener,监听类型)：LISTEN_CALL_STATE,监听打电话状态的常量
		telephonyManager.listen(new MyPhoneListener(), PhoneStateListener.LISTEN_CALL_STATE);
		
	}
	class MyPhoneListener extends PhoneStateListener{
		MediaRecorder recorder;
		boolean isCalling = false;
		@Override//当电话状态发送改变时被调用
		public void onCallStateChanged(int state, String incomingNumber) {
			super.onCallStateChanged(state, incomingNumber);
			if (TelephonyManager.CALL_STATE_OFFHOOK==state) {
				System.out.println("开始通话。。。");
				isCalling = true;
				//新建一个MediaRecorder对象，用来录音
				recorder = new MediaRecorder();
//设置声音来源
				recorder.setAudioSource(AudioSource.MIC);
				//设置输入格式
				recorder.setOutputFormat(OutputFormat.THREE_GPP);
				//格式化日期，作为文件名称
				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd_hh_mm_ss");
				String date = format.format(new Date());
				//设置输出到的文件
				recorder.setOutputFile(getFilesDir()+"/"+date+".3gp");
				//设置音频编码
				recorder.setAudioEncoder(AudioEncoder.DEFAULT);
				try {
					//录音准备
					recorder.prepare();
					//录音开始
					recorder.start();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}else if (TelephonyManager.CALL_STATE_IDLE==state&&isCalling) {
				recorder.stop();//停止
				recorder.release();//释放
				isCalling = false;
				System.out.println("录音结束。");
			}
		}
	}
}
状态：TelephoneManager.CAll_state_idle:电话处于空闲状态，call_state_ringing，电话处于铃响状态。call_state_offbook:解除锁定，电话处于接听状态。
3、 在MainActivity类中启动Service
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		Intent service = new Intent();
		service.setClass(this, MyService.class);
		startService(service);
	}
4、 在AndroidManifest.xml文件中注册该Service。
<service android:name="com.itheima.listenCall.MyService"/>
5、 在AndroidManifest.xml中添加权限。
在该案例中，我们把录音文件存储在data/data/com.itheima.listenCall/files目录中，因此不需要声明外部存储的写权限。读取电话状态的权限：READ_PHONE_STATE。录音权限：RECORD_AUDIO。
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<uses-permission android:name="android.permission.RECORD_AUDIO"/>
6、 将本工程部署到模拟器中
通过DDMS给该模拟器拨打电话，当我们接听一段时间并关闭后，发现控制台成功打印出了录音信息。


打开data/data/com.itheima.listenCall/files目录发现，录音文件被成功保存了。我们将该文件导出到电脑上，发现声音可以正常播放。
17.5. Service的生命周期（★★★★）
service的生命周期，从它被创建开始，到它被销毁为止，可以有两条不同的路径。服务有两种开启方式，一个是直接onstart，另一个是绑定服务。
17.5.1. started service（标准开启模式）
被开启的service通过其他组件调用 startService()被创建。这种service可以无限地运行下去，必须调用stopSelf()方法或者其他组件调用stopService()方法来停止它。当service被停止时，系统会销毁它。
17.5.2. bound service（绑定模式）
被绑定的service是当其他组件（一个客户）调用bindService()来创建的。客户可以通过一个IBinder接口和service进行通信。客户可以通过 unbindService()方法来关闭这种连接。一个service可以同时和多个客户绑定，当多个客户都解除绑定之后，系统会销毁service。
Service的这两种生命周期并不是完全分开的。也就是说，你可以和一个已经调用了 startService()而被开启的service进行绑定。
比如，一个后台音乐service可能因调用 startService()方法而被开启了，稍后，可能用户想要控制播放器或者得到一些当前歌曲的信息，可以通过bindService()将一个activity和service绑定。这种情况下，stopService()或 stopSelf()实际上并不能停止这个service，除非所有的客户都解除绑定。
绑定服务方法：bindService(intent,serviceConnection,int flag);在其他组件中调用此方法，调用后服务内部的生命周期方法onBind方法执行，一旦绑定成功，onBind只执行一次，再次绑定，onBind不会执行。
第二个参数：serviceConnection：连接对象，连接上服务之后可以调用服务的方法传入一个自定义的ServiceConnection用来接收Ibinder。实例化ServiceConnection对象，重写内部方法：onServiceConnected(ComponentName name,Ibinder binder)：绑定成功获取连接时，执行的方法。
参数：IBinder对象：接收服务内部onBind方法，返回的对象（通过这个对象可以间接的访问到服务内部的方法）
第三个参数：Bind_auto_create，如果绑定的这个服务没有创建，那么自动创建这个服务，调用生命周期方法onCreate()方法。
	unBindService()解除绑定服务，内部调用服务的生命周期方法onUnbind()，然后调用onDestory()销毁服务。服务只能被解除绑定一次，如果unBindService方法被调用多次，就会出错
17.5.3. 启动与绑定的区别
通过start()直接启动服务：
服务一旦开启，就与调用者没有任何关系，调用者的activity即使退出，也不会影响后台服务的运行。
通过bindService()绑定服务，启动的服务：
通过绑定方式开启的服务，服务跟调用者不求同生但求同死。如果调用者的activity退出了，那她绑定的服务也会跟着退出。
注意：如果一个程序的activity绑定了服务，那么这个activity退出时，会报异常，说是服务没有被释放。那么我们可以重写activity的onDestory方法，方法内调用unbindService()，去显示的解除与服务的绑定。
第二个不同点：
Start直接启动服务的方法，调用者不能调用服务内部的方法。绑定服务启动服务的方法，调用者可以调用服务内部的方法
利用serviceConnection接口获取服务onbind返回的ibinder对象，这个对象同时实现了自定义的接口，这个接口内定义了服务中的方法。
17.5.4. Service的生命周期回调函数
和activity一样，service也有一系列的生命周期回调函数，你可以实现它们来监测service状态的变化，并且在适当的时候执行适当的工作。
下面的service展示了每一个生命周期的方法：
public class TestService extends Service {
	int mStartMode; // indicates how to behave if the service is killed
	IBinder mBinder; // interface for clients that bind
	boolean mAllowRebind; // indicates whether onRebind should be used

	@Override
	public void onCreate() {
		// The service is being created
	}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
		// The service is starting, due to a call to startService()
		return mStartMode;
	}

	@Override
	public IBinder onBind(Intent intent) {
		// A client is binding to the service with bindService()
		return mBinder;
	}

	@Override
	public boolean onUnbind(Intent intent) {
		// All clients have unbound with unbindService()
		return mAllowRebind;
	}

	@Override
	public void onRebind(Intent intent) {
		// A client is binding to the service with bindService(),
		// after onUnbind() has already been called
	}

	@Override
	public void onDestroy() {
		// The service is no longer used and is being destroyed
	}
}
不像是activity的生命周期回调函数，我们不需要调用基类的实现。
17.5.5. Service的生命周期图

这个图说明了service典型的回调方法，尽管这个图中将开启的service和绑定的service分开，但是你需要记住，任何service都潜在地允许绑定。所以，一个被开启的service仍然可能被绑定。实现这些方法，你可以看到两层嵌套的service的生命周期（拓展知识）：
17.5.6. 整体生命周期（The entire lifetime）
service整体的生命时间是从onCreate()被调用开始，到onDestroy()方法返回为止。和activity一样，service在onCreate()中进行它的初始化工作，在onDestroy()中释放残留的资源。
比如，一个音乐播放service可以在onCreate()中创建播放音乐的线程，在onDestory()中停止这个线程。
onCreate() 和 onDestroy()会被所有的service调用，不论service是通过startService()还是bindService()建立。
17.5.7. 积极活动的生命时间(The active lifetime)
service积极活动的生命时间（active lifetime）是从onStartCommand() 或onBind()被调用开始，它们各自处理由startService()或 bindService()方法传过来的Intent对象。
如果service是被开启的，那么它的活动生命周期和整个生命周期一同结束。如果service是被绑定的，它们它的活动生命周期是在onUnbind()方法返回后结束。
尽管一个被开启的service是通过调用 stopSelf() 或 stopService()来停止的，没有一个对应的回调函数与之对应，即没有onStop()回调方法。所以，当调用了停止的方法，除非这个service和客户组件绑定，否则系统将会直接销毁它，onDestory()方法会被调用，并且是这个时候唯一会被调用的回调方法。
17.5.8. 管理生命周期
当绑定service和所有客户端解除绑定之后，Android系统将会销毁它，（除非它同时被onStartCommand()方法开启）。
因此，如果你的service是一个纯粹的绑定service，那么你不需要管理它的生命周期。然而，如果你选择实现onStartCommand()回调方法，那么你必须显式地停止service，因为service此时被看做是开启的。这种情况下，service会一直运行到它自己调用 stopSelf()或另一个组件调用stopService()，不论它是否和客户端绑定。
另外，如果你的service被开启并且接受绑定，那么当系统调用你的 onUnbind()方法时，如果你想要在下次客户端绑定的时候接受一个onRebind()的调用（而不是调用 onBind()），你可以选择在 onUnbind()中返回true。
onRebind()的返回值为void，但是客户端仍然在它的 onServiceConnected()回调方法中得到 IBinder 对象。
下图展示了这种service（被开启，还允许绑定）的生命周期：

17.6. Android中服务的调用（★★★）
17.6.1. 案例-本地服务调用音乐播放器
1、 新创建一个Android工程《音乐播放器》，包名：com.itheima.musicPlayer。
在res目录下新建一个文件夹raw（名字必须为raw，约定大于配置的原则），然后在raw目录中拷贝进一个音乐文件，注意文件名必须遵循Android资源文件的命名规则。
目录结构如下图：

2、 在src目录下，新建一个MediaService继承Service类，在该类中实现核心服务的方法。
public class MediaService extends Service {
	//声明一个MediaPlayer对象
	private MediaPlayer player;

	@Override
	public IBinder onBind(Intent intent) {
		System.out.println("服务返回MediaController对象了......");
		return new MediaController();
	}
	
	@Override
	public void onCreate() {
		System.out.println("音乐服务已经被创建......");
		//初始化音乐播放器
		player = MediaPlayer.create(this, R.raw.m);
	}
	//自定义一个Binder对象，Binder是IBinder接口的子类
	class MediaController extends Binder{
		public void play(){
			player.start();
		}
		public void pause(){
			player.pause();
		}

		public void stop(){
			player.stop();
		}
		//获取音乐的总时长
		public int getDuration(){
			return player.getDuration();
		}
		//获取当前播放位置
		public int getCurrentPostion(){
			return player.getCurrentPosition();
		}
		//判断是否在播放
		public boolean isPlaying(){
			return player.isPlaying();
		}
		
	}
}

3、 这是使用系统默认的布局文件，activity_main.xml清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="音乐播放器"
        android:textColor="#ff0000"
        android:textSize="28sp" />
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal" >
        <Button
            android:id="@+id/bt_play"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="play"
            android:text="播放" />

        <Button
            android:id="@+id/bt_pause"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="pause"
            android:text="暂停" />
        <Button
            android:id="@+id/bt_stop"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="stop"
            android:text="停止" />
    </LinearLayout>
    <ProgressBar 
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        style="?android:attr/progressBarStyleHorizontal"
        android:id="@+id/pb"
        />
</LinearLayout>
4、 使用默认的MainActivity类，在该类中完成业务的控制，代码清单如下：
public class MainActivity extends Activity {
	//声明进度条
	private ProgressBar pb;
	//声明自定义的MediaController对象
	private MediaController mediaController;
	private boolean isRunning;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//实例化进度条
		pb = (ProgressBar) findViewById(R.id.pb);
		//创建一个用于启动服务的显示意图，指向我们自定义的MediaService类
		Intent intent = new Intent(this, MediaService.class);
		//绑定服务，同时服务开启，如果成功则返回true否则返回false
		isRunning = bindService(intent, new MediaConnection(), BIND_AUTO_CREATE);
		if (isRunning) {
			System.out.println("音乐播放器服务绑定成功！");
		} else {
			System.out.println("音乐播放器服务绑定失败！");
		}
	}
	//用于循环更新当前播放进度
	private void updateProgressBar() {
		new Thread(new Runnable() {

			@Override
			public void run() {
				while (true) {
					SystemClock.sleep(400);
					pb.setProgress(mediaController.getCurrentPostion());
					if (mediaController.getDuration() == mediaController.getCurrentPostion()) {
						break;
					}
				}
			}
		}).start();
	}
	
	public void play(View view) {
		if (mediaController!=null) {
			//如果音乐正在播放则不能再次播放
			if(mediaController.isPlaying()){
				Toast.makeText(this, "音乐播放中", 0).show();
				return;
			}else {
				mediaController.play();
				Toast.makeText(this, "音乐开是播放", 0).show();
			}
		}
	}
	//暂停
	public void pause(View view) {
		if (mediaController != null) {
			mediaController.pause();
		}

	}
	//停止
	public void stop(View view) {
		if (mediaController!=null) {
			//停止的时候将进度条设置为初始位置
			pb.setProgress(0);
			mediaController.stop();
			Toast.makeText(this, "音乐已经关闭！", 0).show();
		}
	}
	//新建一个ServiceConnection类
	class MediaConnection implements ServiceConnection {
		/**
		 * 当service被绑定的时候回调该函数
		 */
		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			//返回的IBinder对象其实就是我们自定义的MediaController类对象
			mediaController = (MediaController) service;
			//给进度条设置最大值
			pb.setMax(mediaController.getDuration());
			//更新进度条
			updateProgressBar();
			System.out.println("服务已经连接......");
		}
		/**
		 * 服务被关闭或者断开的时候调用该方法
		 */
		@Override
		public void onServiceDisconnected(ComponentName name) {
			System.out.println("服务已经断开......");
		}
	}
}
5、 在AndroidManifest.xml中注册Service。
<service android:name="com.itheima.musicPlayer.MediaService"/>
6、 将工程部署到模拟器上
点击播放，发现成功播放了音乐。点击暂停，发现音乐暂停了，然后点击播放，音乐再次响起。点击停止，问题来了，我们发现点击停止后再次点击播放音乐没能再次播放，因为这里面直接调用MediaPlayer的stop方法是有bug的。因此为了解决这样的问题，我们应该将停止调用层pause方法，同时只需调用MediaPlayer的seekTo（int）方法将音乐设置到开始位置。

控制台输出信息如下：

17.6.2. AIDL简介
在Android平台中，各个组件运行在自己的进程中，他们之间是不能相互访问的，但是在程序之间是不可避免的要传递一些对象，在进程之间相互通信。为了实现进程之间的相互通信，Android采用了一种轻量级的实现方式RPC(Remote Procedure Call 远程进程调用)来完成进程之间的通信，并且Android通过接口定义语言（Android Interface Definition Language ,AIDL）来生成两个进程之间相互访问的代码，例如，你在Activity里的代码需要访问Service中的一个方法，那么就可以通过这种方式来实现了。
AIDL是Android的一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成 AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象。
AIDL RPC机制是通过接口来实现的，类似Windows中的COM或者Corba，但他是轻量级的，客户端和被调用实现之间是通过代理模式实现的，代理类和被代理类实现同一个接口IBinder接口。
AIDL使用步骤：
将我们定义的接口，改为aidl文件（自动在gen下生成一个接口），然后将这个aidl文件copy到调用者工程内即可。
注意，这个aidl文件copy过去以后，包名需要与服务工程内aidl文件的包名一致。
Aidl文件自动生成的java文件
Java文件中有个抽象类Stub。Stub extends android.os.Binder implements （继承Binder），com.example.service.PayInterface(自定义的接口，AIDL文件内的接口)。
AIDL默认只能使用Java中基本数据类型和String、List、Map，List和Map中的元素类型也只能是这些类型。
如果需要使用其他类型数据，使用的类必须实现Parcelable接口以完成序列化和反序列化工作。重写 public void writeToParcel(Parcel dest, int flags)，public static final Parcelable.Creator<Person> CREATOR。
定义该类对应的AIDL
package 包名，parcelable 类名在接口AIDL中导入该类，注意：即使是同一个包也需要导入

17.6.3. AIDL案例-远程服务调用商城支付
下面是案例-商城支付的步骤：
需求：分别创建两个工程，模拟一个支付平台，暂且叫支付宝，模拟一个商户端，叫商户。商户可以调用支付宝发布的远程服务进行收款操作。
1、 新创建一个Android工程《支付宝》，包名：com.itheima.alipay。
在src目录下创建com.itheima.alipay.aidl包，然后在该包下创建AlipayRemoteService.aidl文件。在该文件中只声明一个接口，在接口里声明一个方法。文件清单如下：
package com.itheima.alipay.aidl;

interface AlipayRemoteService{
	boolean forwardPayMoney(float money);
}

当该aidl文件创建好以后ADT会自动在gen目录下创建对应的类。

肯定是有个AlipayRemoteService的接口然后还有一个抽象类Stub：android.os.Binder（继承Binder）com.itheima.alipay.aidl.AlipayRemoteService (实现AIDL文件内的接口)。
/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: D:\\Work\\beike\\AIDL_支付宝
 */
package com.itheima.alipay.aidl;
public interface AlipayRemoteService extends android.os.IInterface
{
/** Local-side IPC implementation stub class. */
public static abstract class Stub extends android.os.Binder implements com.itheima.alipay.aidl.AlipayRemoteService
{
private static final java.lang.String DESCRIPTOR = "com.itheima.alipay.aidl.AlipayRemoteService";
/** Construct the stub at attach it to the interface. */
public Stub()
{
this.attachInterface(this, DESCRIPTOR);
}
/**
 * Cast an IBinder object into an com.itheima.alipay.aidl.AlipayRemoteService interface,
 * generating a proxy if needed.
 */
public static com.itheima.alipay.aidl.AlipayRemoteService asInterface(android.os.IBinder obj)
{
if ((obj==null)) {
return null;
}
android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
if (((iin!=null)&&(iin instanceof com.itheima.alipay.aidl.AlipayRemoteService))) {
return ((com.itheima.alipay.aidl.AlipayRemoteService)iin);
}
return new com.itheima.alipay.aidl.AlipayRemoteService.Stub.Proxy(obj);
}
@Override public android.os.IBinder asBinder()
{
return this;
}
@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
{
switch (code)
{
case INTERFACE_TRANSACTION:
{
reply.writeString(DESCRIPTOR);
return true;
}
case TRANSACTION_forwardPayMoney:
{
data.enforceInterface(DESCRIPTOR);
float _arg0;
_arg0 = data.readFloat();
boolean _result = this.forwardPayMoney(_arg0);
reply.writeNoException();
reply.writeInt(((_result)?(1):(0)));
return true;
}
}
return super.onTransact(code, data, reply, flags);
}
private static class Proxy implements com.itheima.alipay.aidl.AlipayRemoteService
{
private android.os.IBinder mRemote;
Proxy(android.os.IBinder remote)
{
mRemote = remote;
}
@Override public android.os.IBinder asBinder()
{
return mRemote;
}
public java.lang.String getInterfaceDescriptor()
{
return DESCRIPTOR;
}
@Override public boolean forwardPayMoney(float money) throws android.os.RemoteException
{
android.os.Parcel _data = android.os.Parcel.obtain();
android.os.Parcel _reply = android.os.Parcel.obtain();
boolean _result;
try {
_data.writeInterfaceToken(DESCRIPTOR);
_data.writeFloat(money);
mRemote.transact(Stub.TRANSACTION_forwardPayMoney, _data, _reply, 0);
_reply.readException();
_result = (0!=_reply.readInt());
}
finally {
_reply.recycle();
_data.recycle();
}
return _result;
}
}
static final int TRANSACTION_forwardPayMoney = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
}
public boolean forwardPayMoney(float money) throws android.os.RemoteException;
}
2、 在《支付宝》src目录下创建com.itheima.alipay.service包，在该包中新建一个Service，叫AlipayService，
该类实现付款功能。代码清单如下：
public class AlipayService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return new PayController();
	}
	public boolean pay(float money){
		System.out.println("成功付款"+money);
		return true;
	}
	/**
	 * 因为Stub已经继承了IBinder接口，因此PayController类也间接继承了该接口
	 * @author wzy Dec 13, 2014
	 *
	 */
	public class PayController extends Stub{
		@Override
		public boolean forwardPayMoney(float money) throws RemoteException {
			return pay(money);
		}
		
	}
}
3、 在《支付宝》工程的AndroidManifest.xml中注册该AlipayService。
  <service  android:name="com.itheima.alipay.service.AlipayService">
            <intent-filter >
                <action android:name="com.itheima.alipay"></action>
            </intent-filter>
 </service>
4、 创建一个新Android工程，名字叫《商户》，包名：com.itheima.shop。使用默认的布局文件和默认的MainActivity类。
将《支付宝》工程中的AlipayRemoteService.aidl文件拷贝到《商户》工程的src目录下，同时注意添加对应的包名，要求包名必须跟该文件在原工程中的包名严格一致。《商户》src目录结构如下图：

5、 编辑activity_main.xm布局文件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_gravity="center_horizontal"
        android:textColor="#ff0000"
        android:textSize="28sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="商城支付-调用远程服务" />
    <EditText 
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入要转正的金额"
        android:inputType="number"
        android:id="@+id/et"
        />
    <Button 
        android:layout_gravity="right"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="确定支付"
        android:onClick="pay"
        />
</LinearLayout>
6、 编写MainActivity类，在该类中实现核心方法
public class MainActivity extends Activity {
	//声明一个AlipayRemoteService对象，该类是根据aidl文件自动生成
	private AlipayRemoteService alipayRemoteService;
	private EditText et;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		et = (EditText) findViewById(R.id.et);
		//创建一个隐式意图，用于启动《支付宝》中的Service
		Intent intent = new Intent();
		intent.setAction("com.itheima.alipay");
		//绑定远程服务
		boolean bindService = bindService(intent, new MyConnection(), Context.BIND_AUTO_CREATE);
		if (bindService) {
			Toast.makeText(this, "服务绑定成功", 1).show();
			System.out.println("服务绑定成功");
		}else {
			Toast.makeText(this, "服务绑定失败", 1).show();
			System.out.println("服务绑定失败");
		}
	}
	public void pay(View view){
		float money = Float.valueOf(et.getText().toString());
		try {
			alipayRemoteService.forwardPayMoney(money);
		} catch (RemoteException e) {
			e.printStackTrace();
			Toast.makeText(this, "付款失败", 1).show();
		}
		Toast.makeText(this, "成功转账："+money+"元！", 0).show();
	}
	class MyConnection implements ServiceConnection{
		/**
		 * 通过Stub的静态方法asInterface将IBinder对象转化为本地AlipayRemoteService对象
		 */
		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			System.out.println("服务已经连接。。。");
			alipayRemoteService = Stub.asInterface(service);
		}

		@Override
		public void onServiceDisconnected(ComponentName name) {
			System.out.println("服务已经关闭。");
		}
		
	}
}
7、 先将《支付宝》部署到模拟器。
然后将《商户》部署到模拟器，然后在《商户》界面输入一个金额，然后点击确定支付，发现《商户》工程已经成功通过远程服务调用了《支付宝》中的服务。运行图如下：


17.6.4. AIDL经典案例：结束通话—黑名单拦截	
Android没有对外公开结束通话的api，如果需要结束通话，必须使用aidl与电话管理服务进行通信，并且调用服务中的api实现通话结束。
调用系电话的aidl的步骤为:首先copy 系统服务的aidl文件，获取系统电话管理的服务，通过反射获取Itelephony对象。
    Method m=Class.forName("android.os.ServiceManger").getMethod("getService");
	IBinder binder=method.invoke(null,new Object[]{Telephony_service});
	Itelephony t=ITelephony.Stub.asInterface(binder);
	t.endCall();//结束通话
	t.call("123");//拨打电话
调用系统电话aidl的具体代码如下所示：新建一个Activity，两个按钮，以下是核心代码：
	private ITelephony iTelephony;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		try {
			Method method = Class.forName("android.os.ServiceManager").getMethod("getService", String.class);
			IBinder binder = (IBinder) method.invoke(null, new Object[]{TELEPHONY_SERVICE});
			iTelephony = ITelephony.Stub.asInterface(binder);
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public void call(View v) throws RemoteException{
		iTelephony.call("110");
	}
	public void endCall(View v) throws RemoteException{
		iTelephony.endCall();
	}
17.7. 结合工作和面试
1. 面试中
服务中可以做耗时操作么？
服务两种使用方式，启动与绑定的区别？
服务的生命周期？
AIDL：
什么是AIDL？用过AIDL么？举个列子。举例子时，可以把AIDL使用的步骤说出来即可。
什么时候使用Service
官方文档告诉我们，Android系统会尽量保持拥有service的进程运行，只要在该service已经被启动(start)或者客户端连接(bindService)到它。当内存不足时，还会保持，拥有service的进程具有较高的优先级。
Service的特点可以让他在后台一直运行,可以在service里面创建线程去完成耗时的操作. 天气预报 widget TimerTask Timer 定期执行timertask
Service可以作为一个系统公用的组件. 现在有很多手机都有一个人脸识别的功能，比如索爱手机X10i的人脸识别，不管在照相，摄像，图库中都可以把人脸用一个方框给框起来。这个就是通过后台的一个人脸识别的Service服务来实现的。（这个服务一开机就会启动，服务开启之后，任何程序都可以绑定到这个服务上，绑定上之后就可以调用人脸识别的功能。他是作为一个公用的组件长期存活在后头供别人调用）
 想使用人脸识别的应用，图库。就可以绑定到这个Service。服务可以被多长绑定。
什么是IntentService
IntentService继承Service。
普通的service ，默认运行在ui main 主线程，Sdk给我们提供的方便的,带有异步处理的service类，异步处理的方法  onHandleIntent()，默认运行在子线程中，可以处理耗时的操作
Service里可以弹Toast么?可以，通过Handler.post。
handler=new Handler(Looper.getMainLooper());  
        handler.post(new Runnable(){  
            public void run(){  
                Toast.makeText(getApplicationContext(), "Service is created!", Toast.LENGTH_LONG).show();  
            }  
        });  
Toast必须运行在Activity的主线程才行，所以可以通过Handler发送子线程到主线程执行。
2. 工作中
Service和AIDL在工作中或多或少都会用到，所以需要掌握。
18. 四大组件之ContentProvider
18.1. ContentProvider简介（★★★）
ContentProvider即内容提供者，是Android的四大组件之一。内容提供者是应用程序之间共享数据的接口，Android系统将这种机制应用到方方面面。
比如：联系人Provider专为不同应用程序提供联系人数据；设置Provider专为不同应用程序提供系统配置信息，包括内置的设置应用程序等。当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。
虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用SharedPreferences共享数据，需要使用SharedPreferences API读写数据。
而使用ContentProvider共享数据的好处是统一了数据访问方式。内容提供者将数据封装，只暴露出我们希望提供给其他程序的数据。内容提供者中数据更改可被监听。
18.1.1. 如何使用ContentProvider
定义类继承ContentProvider，根据需要重写内部方法(增删改查)
在清单文件的<application>节点下进行配置，<provider>标签中需要指定name和authorities属性
name为类名，包名从程序Package开始，以“.”开始
authorities：是访问Provider时的路径，要唯一 
URI代表要操作的数据，由scheme、authorites、path三部分组成
content://cn.itcast.sqlite.provider/person
scheme：固定为content，代表访问内容提供者
authorites：<provider>节点中的authorites属性
path：程序定义的路径，可根据业务逻辑定义
18.1.2. 创建一个ContentProvider
为了方便演示ContentProvider的使用，我们下面将编写一个案例，跟着案例一点点学习ContentProvider的用法，相信当大家能独自把该案例写出来的时候也是我们基本掌握ContentProvider使用方法的时候。
在本应用下创建一个person数据库，对外提供一个ContentProvider接口，使外部程序可以通过我们提供的ContentProvider接口对我们的person数据库进行增删改查操作。
1、 新创建一个Android工程，工程名《MyContentProvider》，包名：com.itheima.provider。
2、 在com.itheima.provider.dao包下新建一个PersonOpenHelper类继承SQLiteOpenHelper类，该类用于创建数据库。
public class PersonOpenHelper extends SQLiteOpenHelper {

	public PersonOpenHelper(Context context, String name, CursorFactory factory, int version) {
		super(context, name, factory, version);
	}
	/**
	 * 对外提供一个简单的构造函数，使用默认的数据库和默认的版本号
	 * @param context
	 */
	public PersonOpenHelper(Context context){
		super(context, "person.db", null, 1);
	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		String sql = "create table person (id integer primary key autoincrement,name varchar(20),phone varchar(20),age integer,address varchar(50));";
		db.execSQL(sql);

	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

	}

}
3、 在com.itheima.contenProvider.provider包中创建，PersonContentProvider类继承ContentProvider类。同时将该Provider在AndroidManifest.xml中注册。
<provider     
android:exported="true"     android:name="com.itheima.contenProvider.provider.PersonContentProvider"android:authorities="com.itheima.person" />
PersonContentProvider类是核心业务代码，也是本文档的重要内容，代码清单如下：
public class PersonContentProvider extends ContentProvider {
	//用于存放并匹配个Uri标识信息，一般在静态代码块中对其信息进行初始化操作
	private static UriMatcher matcher;
	//声明一个用于操作数据库对象
	private PersonOpenHelper openHelper;
	//主机名信息：对应清单文件的authorities属性
	private static final String AUTHORITY = "com.itheima.person";
	//数据库 表名
	private static final String TABLE_PERSON_NAME = "person";
	//Uri匹配成功的返回码
	private static final int PERSON_INSERT_CODE = 1000;
	private static final int PERSON_DELETE_CODE = 10001;
	private static final int PERSON_UPDATE_CODE = 10002;
	private static final int PERSON_QUERYALL_CODE = 10003;
	private static final int PERSON_QUERYONE_CODE = 10004;
	//静态代码块，用于初始化UriMatcher
	static{
		//NO_MATCH:没有Uri匹配的时候返回的状态码（-1）
		matcher = new UriMatcher(UriMatcher.NO_MATCH);
		//添加一个分机号：
		//对person表进行添加操作，如果Uri=content://com.itheima.person/person/insert,则返回PERSON_INSERT_CODE
		matcher.addURI(AUTHORITY, "person/insert", PERSON_INSERT_CODE);
		//对person表进行删除操作,如果Uri= content://com.itheima.person/person/delete,则返回PERSON_DELETE_CODE
		matcher.addURI(AUTHORITY, "person/delete", PERSON_DELETE_CODE);
		//对person表进行修改操作,如果Uri= content://com.itheima.person/person/update,则返回PERSON_UPDATE_CODE
		matcher.addURI(AUTHORITY, "person/update", PERSON_UPDATE_CODE);
		//对person表进行查询所有操作,如果Uri= content://com.itheima.person/person,则返回PERSON_QUERYALL_CODE
		matcher.addURI(AUTHORITY, "person", PERSON_QUERYALL_CODE);
		//对person表进行查询单个操作,如果Uri= content://com.itheima.person/person/#,(#：代表数字)则返回PERSON_QUERYONE_CODE
		matcher.addURI(AUTHORITY, "person/#", PERSON_QUERYONE_CODE);
	}
	@Override
	public boolean onCreate() {
	//内容提供者中，获取contenxt，是通过getContext，与测试类一样，不能再成员变量，构造函数中调用，但是可以再onCreate方法中获取。
		openHelper = new PersonOpenHelper(getContext());
		return false;
	}
	@Override
	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
		//用匹配器去匹配uri，如果匹配成功则返回匹配器中对应的状态码
		int matchCode = matcher.match(uri);
		SQLiteDatabase db = openHelper.getReadableDatabase();
		switch (matchCode) {
		case PERSON_QUERYALL_CODE:
			return db.query(TABLE_PERSON_NAME, projection, selection, selectionArgs, null, null, sortOrder);
		case PERSON_QUERYONE_CODE:
//使用ContentUris工具类解析出uri中的id
			long parseId = ContentUris.parseId(uri);
			return db.query(TABLE_PERSON_NAME, projection,"id=?", new String[]{parseId+""}, null, null, sortOrder);
		default:
			throw new IllegalArgumentException("Uri匹配失败："+uri);
		}}
	@Override
	public Uri insert(Uri uri, ContentValues values) {
		SQLiteDatabase db = openHelper.getWritableDatabase();
		//新插入对象的id
		long id = db.insert(TABLE_PERSON_NAME, null, values);
		db.close();
		//使用ContentUris工具类将id追加到uri中，返回给客户
		return ContentUris.withAppendedId(uri, id);
	}

	@Override
	public int delete(Uri uri, String selection, String[] selectionArgs) {
		SQLiteDatabase db = openHelper.getWritableDatabase();
		//返回删除的个数
		int count = db.delete(TABLE_PERSON_NAME, selection, selectionArgs);
		//关闭数据库
		db.close();
		return count;
	}

	@Override
	public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
		SQLiteDatabase db = openHelper.getWritableDatabase();
		//返回更新的个数
		int count = db.update(TABLE_PERSON_NAME, values, selection, selectionArgs);
		//更新数据库
		db.close();
		return count;
	}

	@Override
	public String getType(Uri uri) {
		return null;
	}

}
18.1.3. 访问ContentProvider
外部程序只需知道内容提供者的Uri路径信息，通过内容解析器ContentResolver即可调用内容提供者。
如果内容提供者所在应用程序，没有启动，其他应用程序访问调用它时，就会启动它。启动时，会创建这个内容提供者。
Uri的组成：

schema，用来说明一个ContentProvider控制这些数据。 "content://"
主机名或授权Authority：它定义了是哪个ContentProvider提供这些数据。
path：路径，URI下的某一个Item。
ID：通常定义Uri时使用”#”号占位符代替, 使用时替换成对应的数字
content://com.itheima.provider/person/#：#表示数据id（#代表任意数字）
content://com.itheima.provider/person/*：*来匹配任意文本。
为了演示如何调用ContentProvider，我们新建一个Android测试工程，访问本文档上一个章节中提供的数据。
1、 新创建一个Android工程，工程名《TestContentProvider》，包名：com.itheima.contentProviderTest。
2、 在AndroidManifest.xml中添加instrumentation和uses-library。
<instrumentation android:name="android.test.InstrumentationTestRunner" android:targetPackage="com.itheima.contextProviderTest"/>
<uses-library android:name="android.test.runner"/>
其中instrumentation放在清单文件的manifest节点下，uses-library放在application节点下。
3、 在com.itheima.contentProviderTest包下，新建TestContentProvider类，在该类中实现核心方法，调用上一章节中ContentProvider。
测试insert方法
public void insertTest(){
		ContentResolver resolver = getContext().getContentResolver();
		Uri uri = Uri.parse("content://com.itheima.person/person/insert");
		ContentValues values = new ContentValues();
		values.put("name", "张三");
		values.put("age", 22);
		values.put("phone", "13240217777");
		values.put("address", "北京");
		Uri insert = resolver.insert(uri, values);
		System.out.println(insert);
		long id = ContentUris.parseId(insert);
		System.out.println("插入数据产生的id是："+id);
	}
在我第一次做测试时报了如下图表中的异常，意思就是我没有权限访问com.itheima.contenProvider包中提供的ContentProvider，原因是我忘记了在上一章节中AndroidManifest.xml文件中给provider标签添加 android:exported="true" 属性，该属性的意思是是否对外发布，系统默认为false，这里一定记住要设置为true。
java.lang.SecurityException: Permission Denial: opening provider com.itheima.contenProvider.provider.PersonContentProvider from ProcessRecord{b610aaa8 2082:com.itheima.contextProviderTest/u0a10090} (pid=2082, uid=10090) that is not exported from uid 10091
at android.os.Parcel.readException(Parcel.java:1425)
at android.os.Parcel.readException(Parcel.java:1379)
at android.app.ActivityManagerProxy.getContentProvider(ActivityManagerNative.java:2530)
at android.app.ActivityThread.acquireProvider(ActivityThread.java:4460)
at android.app.ContextImpl$ApplicationContentResolver.acquireProvider(ContextImpl.java:1987)
at android.content.ContentResolver.acquireProvider(ContentResolver.java:1054)
at android.content.ContentResolver.insert(ContentResolver.java:860)
at 
测试update方法
public void updateTest(){
		ContentResolver resolver = getContext().getContentResolver();
		Uri uri = Uri.parse("content://com.itheima.person/person/update");
		ContentValues values = new ContentValues();
		values.put("name", "李四");
		int count = resolver.update(uri, values , "name=?", new String[]{"张三"});
		System.out.println("更新的个数为："+count);
	}
测试delete方法
public void deleteTest(){
		ContentResolver resolver = getContext().getContentResolver();
		Uri uri = Uri.parse("content://com.itheima.person/preson/delete");
		int count = resolver.delete(uri, "id=?", new String[]{"1"});
		System.out.println("删除的个数为： "+count);
	}
测试query（单个）方法
public void queryOne(){
		ContentResolver resolver = getContext().getContentResolver();
		Uri uri = Uri.parse("content://com.itheima.person/person/2");
		Cursor cursor = resolver.query(uri, new String[]{"name","age","phone","address"}, null, null, null);
		while(cursor.moveToNext()){
			String name = cursor.getString(0);
			int age = cursor.getInt(1);
			String phone = cursor.getString(2);
			String address = cursor.getString(3);
			System.out.println(name+"/"+age+"/"+phone+"/"+address);
		}
		cursor.close();
	}
测试query（多个）方法
public void queryAll(){
		ContentResolver resolver = getContext().getContentResolver();
		Uri uri = Uri.parse("content://com.itheima.person/person");
		Cursor cursor = resolver.query(uri, new String[]{"name","age","phone","address"}, null, null, null);
		while(cursor.moveToNext()){
			String name = cursor.getString(0);
			int age = cursor.getInt(1);
			String phone = cursor.getString(2);
			String address = cursor.getString(3);
			System.out.println(name+"/"+age+"/"+phone+"/"+address);
		}
		cursor.close();
	}
18.2. 案例-短信的备份和恢复（★★★★）
Android系统中提供了一系列的内容提供者，通过调用他们，可以获取一些系统的信息，比如:短信信息，联系人信息等。
在应用界面有备份短信、恢复短信两个按钮，点击该按钮会将当前短信备份到XML文件中，同时XML文件被存储在存储卡中。点击恢复短信按钮，程序会将XML文件中的短信插入到手机中存储短信的数据库中。在备份和恢复的过程中有进度条显示完成情况。
18.2.1. 准备知识
打开Android源码，查看packages\providers\路径下的工程，这些就是Android系统中的内容提供者，其中TelephonyProvider就是短信的内容提供者文件。
打开TelephonyProvider下的src文件，查看java文件，其中的SmsProvider.java即短信息内容提供者逻辑代码。UriMatcher一般在静态代码块中进行初始化操作，查找静态代码块，找到的逻辑代码如下：
private static final UriMatcher sURLMatcher =
	            new UriMatcher(UriMatcher.NO_MATCH);

	    static {
	        sURLMatcher.addURI("sms", null, SMS_ALL);
	        sURLMatcher.addURI("sms", "#", SMS_ALL_ID);
	        sURLMatcher.addURI("sms", "inbox", SMS_INBOX);
	        sURLMatcher.addURI("sms", "inbox/#", SMS_INBOX_ID);
	        sURLMatcher.addURI("sms", "sent", SMS_SENT);
	        sURLMatcher.addURI("sms", "sent/#", SMS_SENT_ID);
	        sURLMatcher.addURI("sms", "draft", SMS_DRAFT);
	        sURLMatcher.addURI("sms", "draft/#", SMS_DRAFT_ID);
	        sURLMatcher.addURI("sms", "outbox", SMS_OUTBOX);
	        sURLMatcher.addURI("sms", "outbox/#", SMS_OUTBOX_ID);
	        sURLMatcher.addURI("sms", "undelivered", SMS_UNDELIVERED);
	        sURLMatcher.addURI("sms", "failed", SMS_FAILED);
	        sURLMatcher.addURI("sms", "failed/#", SMS_FAILED_ID);
	        sURLMatcher.addURI("sms", "queued", SMS_QUEUED);
	        sURLMatcher.addURI("sms", "conversations", SMS_CONVERSATIONS);
	        sURLMatcher.addURI("sms", "conversations/*", SMS_CONVERSATIONS_ID);
	        sURLMatcher.addURI("sms", "raw", SMS_RAW_MESSAGE);
	        sURLMatcher.addURI("sms", "attachments", SMS_ATTACHMENT);
	        sURLMatcher.addURI("sms", "attachments/#", SMS_ATTACHMENT_ID);
	        sURLMatcher.addURI("sms", "threadID", SMS_NEW_THREAD_ID);
	        sURLMatcher.addURI("sms", "threadID/*", SMS_QUERY_THREAD_ID);
	        sURLMatcher.addURI("sms", "status/#", SMS_STATUS_ID);
	        sURLMatcher.addURI("sms", "sr_pending", SMS_STATUS_PENDING);
	        sURLMatcher.addURI("sms", "icc", SMS_ALL_ICC);
	        sURLMatcher.addURI("sms", "icc/#", SMS_ICC);
	        //we keep these for not breaking old applications
	        sURLMatcher.addURI("sms", "sim", SMS_ALL_ICC);
	        sURLMatcher.addURI("sms", "sim/#", SMS_ICC);
sConversationProjectionMap.put(Sms.Conversations.SNIPPET,
	            "sms.body AS snippet");
	        sConversationProjectionMap.put(Sms.Conversations.THREAD_ID,
	            "sms.thread_id AS thread_id");
	        sConversationProjectionMap.put(Sms.Conversations.MESSAGE_COUNT,
	            "groups.msg_count AS msg_count");
	        sConversationProjectionMap.put("delta", null);
	    }
	}
在数据库中sms表就是用于存储短信的，所以通过查找系统源码，可以确定短信息内容提供者的Uri应该为:”content://sms”
查看Android模拟器下的com.android.providers.telephony，查看其mmssms.db文件。

打开数据库，其中sms表存储的就是短信的数据，其存储格式如下：

其中，address存储的是联系人号码，date是发送日期，type对应短信的类型（发送/接收）,body是短信的主体内容，准备备份这四项。
18.2.2. 实现步骤
1、 新创建一个新的Android工程《短信备份And恢复》，包名：com.itheima.smsbackup。在com.itheima.smsbackup.bean包中创建Sms类，用于封装短信数据。
public class Sms {
	private String body;
	private String address;
	private String date;
	private String type;
//省略setter&getter
}
2、 创建XML工具类，用于生成XML和解析XML。
public class Sms {
	private String body;
	private String address;
	private String date;
	private String type;
//省略setter&getter
}
3、 编写界面布局文件，这里使用默认生成的布局文件activity_main.xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <TextView
        android:layout_gravity="center"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="短信备份和恢复" />
    <Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="备份短信"
        android:onClick="backupSms"
        android:id="@+id/bt_backup"/>
    <Button 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="恢复短信"
        android:onClick="reverseSms"
        android:id="@+id/bt_reverse"/>
    <ProgressBar 
        android:id="@+id/pb"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        style="?android:attr/progressBarStyleHorizontal"/>
</LinearLayout>
4、 编写默认的MainActivity类，实现核心方法。
备份短信功能代码清单
public void backupSms(View view) {
		//如果当前正在备份，则返回。
		if (backupFlag) {
			Toast.makeText(this, "当前正在备份中。。。请稍后再操作", 0).show();
			return;
		}
		//开辟一个新的线程来处理业务，因为短信备份是耗时操作，如果不放在子线程中操作可能会导致ANR异常
		new Thread(new Runnable() {

			@Override
			public void run() {
				
//将标记位设置为true
				backupFlag = true;
				//子线程中创建一个Looper对象
				Looper.prepare();
				//获取ContentResolver对象
				ContentResolver resolver = getContentResolver();
				//编辑短信访问的uri
				Uri uri = Uri.parse("content://sms");
				//执行查询语句
				Cursor cursor = resolver.query(uri, new String[] { "address", "date", "body", "type" }, null, null, null);
				List<Sms> list = new ArrayList<Sms>();
				//获取短信的总共条数
				int count = cursor.getCount();
				//设置进度条的最大值
				pb.setMax(count);
				int i = 0;
				while (cursor.moveToNext()) {
					Sms sms = new Sms();
					String address = cursor.getString(0);
					String date = cursor.getString(1);
					String body = cursor.getString(2);
					String type = cursor.getString(3);
					sms.setAddress(address);
					sms.setBody(body);
					sms.setDate(date);
					sms.setType(type);
					list.add(sms);
					//更新进度条
					pb.setProgress(++i);
					//这里是为了方便演示备份的效果加上线程等待
					SystemClock.sleep(50);
				}
				try {
					//通过自定义的Sms2XmlUtil工具类将短信保存到xml中
					Sms2XmlUtil.sms2Xml(list);
				} catch (Exception e) {
					e.printStackTrace();
					Toast.makeText(MainActivity.this, "备份短信失败。" + e.getLocalizedMessage(), 1).show();
				}
				//关闭游标
				cursor.close();
				Toast.makeText(MainActivity.this, "短信备份成功！本次备份了" + i + "条短信。", 1).show();
				//循环消息
				Looper.loop();
				//将标记设置为flase
				backupFlag = false;
			}
		}).start();
}
5、 恢复短信功能代码清单
public void reverseSms(View view) {
		if (reverseFlag) {
			Toast.makeText(this, "当前短信正在备份中，请稍后再操作。", 0).show();
			return;
		}
		new Thread(new Runnable() {
			@Override
			public void run() {
				Looper.prepare();
				ContentResolver resolver = getContentResolver();
				Uri url = Uri.parse("content://sms");
				List<Sms> list = null;
				try {
					list = Sms2XmlUtil.xml2Sms();
					pb.setMax(list.size());
					pb.setProgress(0);
				} catch (Exception e) {
					e.printStackTrace();
					Toast.makeText(MainActivity.this, "短信恢复失败！" + e.getLocalizedMessage(), 1).show();
					return;
				}
				int i = 0;
				for (Sms s : list) {
					ContentValues values = new ContentValues();
					values.put(Sms2XmlUtil.SMS_TAG_ADDRESS, 
s.getAddress());
					values.put(Sms2XmlUtil.SMS_TAG_BODY, s.getBody());
					values.put(Sms2XmlUtil.SMS_TAG_DATE, s.getDate());
					values.put(Sms2XmlUtil.SMS_TAG_TYPE, s.getType());
					Uri uri = resolver.insert(url, values);
					System.out.println("插入的id：" + ContentUris.parseId(uri));
					pb.setProgress(++i);
					SystemClock.sleep(50);
				}
				Toast.makeText(MainActivity.this, "短信恢复成功！本次恢复了" + i + "条短信。", 1).show();
				reverseFlag = false;
				Looper.loop();
			}
		}).start();

	}

6、 为当前工程添加权限。在AndroidManifest.xml中添加权限声明。
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_SMS"/>
    <uses-permission android:name="android.permission.READ_SMS"/>
7、 将本工程部署到模拟器上，运行，并测试。发现我们成功将短信备份到了存储卡中。通过DDMS，我们可以看到在mnt/sdcard/smsbackup目录下多了sms.xml文件。

程序运行界面比较简单，效果如下图：

在该工程中，短信的恢复逻辑比较简单，只是把sms.xml文件中的所有短信插入到短信数据库中，其实如果短信数据库中还有相同的短信的时候我们这样处理的结果是数据库中有了2份相同的短信，因此比较好的做法是在插入数据库之前先判断该短信是否存在，如果存在则不插入。
18.3. 操作系统联系人（★★★★）
18.3.1. 准备知识
通过DDMS，查看Android模拟器下的com.android.providers.contacts包下的数据库，查看其contact2.db数据库的内容。

查看数据库，其中raw_contacts表存放的是联系人条数信息，data表中存放的是raw_contacts中的每一条id对应的具体信息，不同类型的信息由mimetype_id来标识。
raw_contacts表：其中保存了联系人id  字段为：_id

data表：和raw_contacts是多对一的关系，保存了联系人的各项数据

mimetypes表：

data表：字段data1：实际数据，外键：raw_contacts_id：联系人id。外键：mimetype_id:数据类型id，查询联系人信息思路：先查询raw_contacts得到每个联系人的id，在使用id从data表中查询对应数据，根据mimetype分类数据。

打开Android源码，查看packages\providers\路径下的文件，其中ContactsProvider就是联系人的内容提供者。
打开清单文件，寻找联系人的内容提供者对应的是哪个java文件。
<provider android:name="ContactsProvider2"
            android:authorities="contacts;com.android.contacts"
            android:label="@string/provider_label"
            android:multiprocess="false"
            android:readPermission="android.permission.READ_CONTACTS"
            android:writePermission="android.permission.WRITE_CONTACTS">
            <path-permission
                    android:pathPrefix="/search_suggest_query"
                    android:readPermission="android.permission.GLOBAL_SEARCH" />
            <path-permission
                    android:pathPrefix="/search_suggest_shortcut"
                    android:readPermission="android.permission.GLOBAL_SEARCH" />
            <path-permission
                    android:pathPattern="/contacts/.*/photo"
                    android:readPermission="android.permission.GLOBAL_SEARCH" />
            <grant-uri-permission android:pathPattern=".*" />
        </provider>
打开ContactsProvider2.java文件，查看此内容提供者的uri路径信息
matcher.addURI(ContactsContract.AUTHORITY, "contacts", CONTACTS);
matcher.addURI(ContactsContract.AUTHORITY, "contacts/#", CONTACTS_ID);
matcher.addURI(ContactsContract.AUTHORITY, "contacts/#/data", CONTACTS_DATA);
matcher.addURI(ContactsContract.AUTHORITY, "raw_contacts", RAW_CONTACTS);
	        matcher.addURI(ContactsContract.AUTHORITY, "raw_contacts/#", RAW_CONTACTS_ID);
	        matcher.addURI(ContactsContract.AUTHORITY, "raw_contacts/#/data", RAW_CONTACTS_DATA);
根据源码，确定内容提供者的Uri信息为：联系人内容提供者Provider的authorites为com.android.contacts，操作raw_contacts表的Uri: 
content://com.android.contacts/raw_contacts
操作data表的Uri：
content://com.android.contacts/data
操作数据库表时，由于contacts2.db数据库使用了视图，所以操作数据库表时，表结构有所改变，注意操作时要操纵的列的列名已经改变。比如：data表在查询的时候没有mimetype_id,取代的是mimetype
18.3.2. 操作系统联系人
步骤：
操作raw_contacts表，获取全部的id
根据获取到的每一条id去查询data表中的数据
将查询到的展示是用户界面
通过代码给系统联系人插入一条联系人信息
具体代码：
1. 新建一个Android工程《操作系统联系人》。包名：com.itheima.contacts。
2. 使用默认生成的布局文件和MainActivity类。
在布局文件里将用户联系人展示在ListView中，因此我们需要为ListView的Item创建一个布局文件，由于该布局文件比较简单，因此我们只给出效果图，布局文件清单就不再给出。activity_main.xml文件清单：

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >
    <ListView
        android:id="@+id/lv"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" >
    </ListView>
    <LinearLayout
        android:layout_gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal" >
        <Button
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            android:onClick="queryContacts"
            android:text="获取联系人" />
        <Button
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            android:onClick="insertContacts"
            android:text="插入联系人" />
    </LinearLayout>
</LinearLayout>
想想还是将list_item.xml的布局给出吧，哎，任性了。
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:baselineAligned="false"
    android:layout_width="match_parent" 
    android:layout_height="wrap_content"
    android:orientation="horizontal">
	<LinearLayout 
	    android:layout_width="0dp"
	    android:layout_height="match_parent"
	    android:orientation="vertical"
	    android:layout_weight="1">
	    <TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="联系人"
	        android:textColor="#0000ff"/>
	    <TextView 
	        android:id="@+id/tv_name"
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="张三"
	        android:textColor="#0000ff"/>
	</LinearLayout>
	<LinearLayout 
	    android:layout_height="match_parent"
	    android:layout_width="0dp"
	    android:layout_weight="1"
	    android:orientation="vertical">
	     <TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="电话"
	        android:textColor="#ff0000"/>
	    <TextView 
	        android:id="@+id/tv_phone"
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="12333333"
	        android:textColor="#ff0000"/>
</LinearLayout>
	<LinearLayout 
	    android:layout_height="match_parent"
	    android:layout_width="0dp"
	    android:layout_weight="1"
	    android:orientation="vertical">
	     <TextView 
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="邮件"
	        android:textColor="#00ff00"/>
	    <TextView 
	        android:id="@+id/tv_email"
	        android:layout_height="wrap_content"
	        android:layout_width="wrap_content"
	        android:text="12333333@qq.com"
	        android:textColor="#00ff00"/>
	</LinearLayout>
</LinearLayout>
3. 编写MainActivity类代码
在这里我们用到了自定义的Contact对象，用于封装属性，比较简单因此就不再给出Contact类代码清单。
public class MainActivity extends Activity {

	private ListView lv;
	private List<Contact> list;
	private MyAdapter adapter;
	private Handler handler = new Handler() {
		public void handleMessage(android.os.Message msg) {
			Toast.makeText(MainActivity.this, "数据获取成功。", 1).show();
			//更新数据
			adapter.notifyDataSetChanged();
		};
	};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		lv = (ListView) findViewById(R.id.lv);
		list = new ArrayList<Contact>();
		adapter = new MyAdapter();
		lv.setAdapter(adapter);
	}
	/**
	 * 查询所有的系统联系人，这里的业务放在子线程中操作 
	 */
	public void queryContacts(View view) {
		new Thread(new Runnable() {

			@Override
			public void run() {
				ContentResolver contentResolver = getContentResolver();
				Uri uri = Uri.parse("content://com.android.contacts/raw_contacts");
				Cursor cursor = contentResolver.query(uri, new String[] { "contact_id" }, null, null, null);
				list.clear();
				int i = 0;
				while (cursor.moveToNext()) {
					i++;
					//先从raw_contacts表中获取contact_id
					String contact_id = cursor.getString(0);
					if (TextUtils.isEmpty(contact_id)) {
						continue;
					}
					//根据contact_id从data表中查询具体的数据
					Cursor cursor2 = contentResolver.query(Uri.parse("content://com.android.contacts/data"), new String[] { "data1", "mimetype" }, "contact_id=?", new String[] { contact_id }, null);
					Contact contact = new Contact();
					while (cursor2.moveToNext()) {
						String data = cursor2.getString(0);
						String mimetype = cursor2.getString(1);
						if ("vnd.android.cursor.item/name".equals(mimetype)) {
							contact.setName(data);
						} else if ("vnd.android.cursor.item/phone_v2".equals(mimetype)) {
							contact.setPhone(data);
						} else if ("vnd.android.cursor.item/email_v2".equals(mimetype)) {
							contact.setEmail(data);
						} else {
							contact.setOther(data);
						}
					}
					list.add(contact);
					cursor2.close();
				}
				cursor.close();
				//发送一个空消息，更新ListView
				handler.sendEmptyMessage(RESULT_OK);
			}
		}).start();

	}

	class MyAdapter extends BaseAdapter {

		@Override
		public int getCount() {
			return list.size();
		}

		@Override
		public Object getItem(int position) {
			return null;
		}

		@Override
		public long getItemId(int position) {
			return position;
		}
		/**
		 * 这里面通过ViewHolder类将其他子属性值绑定在View上面，这里对ListView作了进一步的优化处理
		 */
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			View view;
			ViewHolder holder;
			if (convertView != null) {
				view = convertView;
				holder = (ViewHolder) view.getTag();
			} else {
				view = View.inflate(MainActivity.this, R.layout.list_item, null);
				holder = new ViewHolder();
				holder.tv_name = (TextView) view.findViewById(R.id.tv_name);
				holder.tv_phone = (TextView) view.findViewById(R.id.tv_phone);
				holder.tv_email = (TextView) view.findViewById(R.id.tv_email);
				view.setTag(holder);
			}
			Contact contact = list.get(position);
			holder.tv_name.setText(contact.getName());
			holder.tv_email.setText(contact.getEmail());
			holder.tv_phone.setText(contact.getPhone());
			return view;
		}
	}

	class ViewHolder {
		TextView tv_name;
		TextView tv_email;
		TextView tv_phone;
	}
	/**
	 * 往系统联系人表中插入一条数据，这里为了方便演示，我们直接插入一条固定的数据 
	 */
	public void insertContacts(View view) {
		//创建一个自定义的Contact类，将要网系统联系人表中插入的字段封装起来
		Contact contact = new Contact();
		contact.setEmail("itheima@itcast.cn");
		contact.setName("王二麻子"+new Random().nextInt(1000));
		contact.setPhone("9999999"+new Random().nextInt(100));
		contact.setOther("北京市中关村软件园");
		//获取ContentResolver对象
		ContentResolver resolver = getContentResolver();
		//操作raw_contacts表的uri
		Uri raw_uri = Uri.parse("content://com.android.contacts/raw_contacts");
		//操作data表的uri
		Uri data_uri = Uri.parse("content://com.android.contacts/data");
		//在插入数据之前先查询出当前最大的id
		Cursor cursor = resolver.query(raw_uri, new String[] { "contact_id" }, null, null, "contact_id desc limit 1");
		int id = 1;
		if (cursor!=null) {
			boolean moveToFirst = cursor.moveToFirst();
			if (moveToFirst) {
				id = cursor.getInt(0);
			}
		}
		cursor.close();
		//要插入数据的contact_id值
		int newId = id + 1;
		// 给raw_contact表中添加一天记录
		ContentValues values = new ContentValues();
		values.put("contact_id", newId);
		resolver.insert(raw_uri, values);
		// 在data表中添加数据
		// 添加name
		values = new ContentValues();
		values.put("raw_contact_id", newId);
		values.put("mimetype", "vnd.android.cursor.item/name");
		values.put("data1", contact.getName());
		resolver.insert(data_uri, values);
		// 添加phone
		values = new ContentValues();
		values.put("raw_contact_id", newId);
		values.put("mimetype", "vnd.android.cursor.item/phone_v2");
		values.put("data1", contact.getPhone());
		resolver.insert(data_uri, values);
		// 添加地址
		values = new ContentValues();
		values.put("raw_contact_id", newId);
		values.put("mimetype", "vnd.android.cursor.item/postal-address_v2");
		values.put("data1", contact.getOther());
		resolver.insert(data_uri, values);
		// 添加email
		values = new ContentValues();
		values.put("raw_contact_id", newId);
		values.put("mimetype", "vnd.android.cursor.item/email_v2");
		values.put("data1", contact.getEmail());
		resolver.insert(data_uri, values);
		Toast.makeText(this, "成功插入联系人" + contact, 0).show();
	}
}
4. 在AndroidManifest.xml中添加添加如下权限：
<uses-permission android:name="android.permission.READ_CONTACTS"/>
    <uses-permission android:name="android.permission.WRITE_CONTACTS"/>
5. 部署该工程于模拟器。
点击获取联系人，然后在点击插入联系人，然后在点击获取联系人。发现我们不仅成功的将所有的联系人读取出来了同时也将新联系人插入到了数据库中。运行效果图如下：


通过电话号码获取联系人
系统内部提供了根据电话号码获取data表数据的功能，路径为：data/phones/filter/*。用电话号码替换“*”部分就可以查到所需数据，获取“display_name”可以获取到联系人显示名。

18.4. ContentObserver简介（★★★）
ContentObserver——内容观察者，目的是观察(捕捉)特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它。触发器分为表触发器、行触发器，相应地ContentObserver也分为“表“ContentObserver、“行”ContentObserver，当然这是与它所监听的Uri MIME Type有关的。
学习过Content Provider(内容提供者)的我们都知道，可以通过UriMatcher类注册不同类型的Uri，可以通过这些不同的Uri来查询不同的结果。根据Uri返回的结果，Uri Type可以分为：返回多条数据的Uri、返回单条数据的Uri。
使用ContentObserver的步骤我这里总结如下：首先创建一个ContentObserver的子类，然后实现里面的onChange方法，监听的Uri中的数据发生变化的时候，会调用onChange方法，注册ContentObserver。
18.5. 案例-短信窃听（★★★★）
用户使用系统自带的短信程序发送短信，程序会通过ContentProvider把短信保存进数据库，并且发出一个数据变化通知，使用ContentObserver对数据变化进行监听，在用户发送短信时，就会被ContentObserver窃听到短信。
发出的短信有这样几个过程：草稿箱->发件箱->已发送。所以只需查询发件箱中的信息即可，处于正在发送状态的短信放在发送箱中。
创建一个应用程序，监听用户发送的短信。
1. 新创建一个Android工程《短信窃听》，包名：com.itheima.contentObserver。
2. 新创建一个SmsContentObserver类继承ContentObserver类，覆写onChange方法。在该方法中实现核心业务逻辑。
public class SmsContentObserver extends ContentObserver {
	//声明一个Content对象，在构造函数中对其进行实例化
	private Context context;
	private Handler handler;
	//声明构造函数
	public SmsContentObserver(Context context,Handler handler){
		super(handler);
		this.context = context;
		this.handler = handler;
	}
	//覆写父类onChange方法
	@Override
	public void onChange(boolean selfChange) {
		//通过查看发件箱中的短信即可观察到新短信的发送
		Uri uri = Uri.parse("content://sms/outbox");
		//获取Context对象的ContentResolver对象
		ContentResolver resolver = context.getContentResolver();
		String[] projection = {"address","body","date"};
		//获取发件箱中的短信
		Cursor cursor = resolver.query(uri, projection, null, null, null);
		if(cursor!=null&&cursor.moveToNext()){
			String address = cursor.getString(0);
			String body = cursor.getString(1);
			Long date = cursor.getLong(2);
			//调用DateFormat的方法将long类型的时间转化为系统相关时间
			String dateStr = DateFormat.getTimeFormat(context).format(date);
			//打印观察到正在发送的短信
			System.out.println("address="+address+" body="+body+" date="+dateStr);
		}
		cursor.close();
	}
}
3. 在MainActivity类中注册SmsContentObserver。
public class MainActivity extends Activity {
	private SmsContentObserver observer;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//实例化一个自定义的SMSContentObserver对象
		observer = new SmsContentObserver(this, null);
		//操作系统短信的uri
		Uri uri = Uri.parse("content://sms");
		/**
		 * 获取ContentResolver,然后注册ContentObserver
		 */
		getContentResolver().registerContentObserver(uri, true, observer);
	}
}
4. 因为我们读取系统短信了，因此需要在AndroidManifest.xml中添加权限。
<uses-permission android:name="android.permission.READ_SMS"/>
5. 将该工程部署在模拟器上并运行，然后打开短息功能，给5557模拟器（可以随意指定个号码，不需要启动5557模拟器）发送一条短信。观察LogCat发现，我们的ContentObserver成功监听到了短信内容。

18.6. 使用ContentObserver监听自定义的ContentProvider
在上一章节中，我们通过ContentObserver实现了对系统发送短信的监听。这是因为系统短信数据数据库中插入新的短信的时候通过ContentResolver调用了notifyChange方法，正是该方法对外发出了消息，这样我们的ContentObserver才监听到了短信的发送。
那么我们也可以自定义我们的ContentProvider，在ContentProvider中发送消息，被我们的ContentObserver监听到。
为了方便演示，我们直接使用该文档 18.1.2章节中创建的工程《MyContentProvider》。我们修改PersonContentProvider类中的insert方法，当有新用户插入数据库的时候发出消息以被ContentObserver监听。
public Uri insert(Uri uri, ContentValues values) {
		SQLiteDatabase db = openHelper.getWritableDatabase();
		//新插入对象的id
		long id = db.insert(TABLE_PERSON_NAME, null, values);
		db.close();
		//声明一个uri，通过这个uri ContentObserver可以进行监听
		Uri notifyUri = Uri.parse("com.itheima.person");
		/*
		 * notifyChange方法中第一个参数指定一个被监听的uri
		 * 第二个参数是指定ContentObserver，如果不为null则代表只有指定的ContentObserver可以接收到消息
		 * 为null则所有的ContentObserver都有机会接收到该消息
		 */
		getContext().getContentResolver().notifyChange(notifyUri, null);
		//使用ContentUris工具类将id追加到uri中，返回给客户
		return ContentUris.withAppendedId(uri, id);
	}
同样的，接下来同监听短信一样，我们已经可以通过自定义ContentObserver对我们的person数据库的添加动作进行监听了。由于监听的原理跟第5章完成一样，因此这里就不再给出详细的代码。
18.7. 监听内容提供者数据变化
在内容提供者中可以通知其他程序数据发生变化
调用其notifyChange()方法发送数据修改通知（在内容提供者的增删改方法内，调用notifyChange()方法通知修改），发送通知：getcontent.getContentResolver().notifyChange(uri,null);
通过Context的getContentResolver()方法获取ContentResolver
在其他程序中可以通过ContentObserver（内容观察者）监听数据变化。调用其registerContentObserver()方法指定对某个Uri注册ContentObserver，意为给某个uri添加观察者，观察这个uri下的所有数据修改。
contentResolver.registerContentObserver(uri,notifyForDescendents,contentObserver);
参数：uri、监听哪个uri的操作
notifyForDescendents是否观察uri的子集
contentObserver，内容观察者
自定义类继承ContentObserver，重写onChange()方法获取数据，如果收到数据修改通知，就执行
Activity通过内容观察者，可以监听数据的修改，收到修改通知，就可以刷新界面
代码：监听applock表的数据变化
可以在数据库dao层的增删改方法内发送修改通知，先定义uri：必须以content://开头。
uri = Uri.parse("content://com.itheima.mobilesafe.applock");
	public boolean add(String packageName) {
		boolean result = false;
		SQLiteDatabase database = helper.getWritableDatabase();
		if (database.isOpen()) {
			ContentValues values = new ContentValues();
			values.put("packagename", packageName);
			long insert = database.insert("applock", null, values);
			database.close();
			if (insert != 0) {
				result = true;
				resolver.notifyChange(uri, null); //发送通知
			}
		}
		return result;
	}
定义一个内容观察者，如果applock数据改变就，重新获取
	private class AppLockObserver extends ContentObserver{
		public AppLockObserver(){
			super(new Handler());
		}
		@Override
		public void onChange(boolean selfChange) {
			super.onChange(selfChange);
			//观察到注册的uri数据发送变化，根据业务需求处理
		}
	}
注册内容观察者
AppLockObserver appLockObserver=new AppLockObserver();
Uri uri=Uri.parse("content://com.itheima.mobilesafe.applock");
//第二个参数：boolean notifyForDescendents：通知子孙，如果为true，就可以观察以“com.itheima.mobilesafe.applock”开头的uri
//如果是false，不观察他的子孙，就只能完全匹配
getContentResolver().registerContentObserver(uri, true, appLockObserver);
18.8. 结合工作和面试
1. 面试中
请介绍下ContentProvider是如何实现共享的？
Android提供了ContentProvider，一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProviders是以类似数据库中表的方式将数据暴露，也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基本一样，只不过是采用URI来表示外界需要访问的“数据库”。外部访问通过ContentResolver去访问并操作这些被暴露的数据。
再举个例子讲讲使用ContentProvider的步骤。
为什么要用ContentProvider？它和sql的实现上有什么差别？
可以根据自己的业务逻辑暴露相应操作，屏蔽数据存储的细节,对用户透明,用户只需要关心操作数据的uri和对应的参数，就可以了。
不同app之间共享,操作数据 ，但是contentprovider 还可以去增删改查本地文件. xml文件的读取,更改。网络数据读取更改 （这种操作不多）
	Sql也有增删改查的方法，但是ContentProvider他不用将增删改查所有方法都实现，只需要更加需求来做。
2. 工作中
工作中，自己的应用对外提供ContentProvider的不多，但是Android 系统为一些常见的数据类型(如音乐、视频、图像、手机通信录联系人信息等)内置了一系列的 Content Provider, 这些都位于android.provider包下。
许多在自己开发的应用程序中访问这些Content Provider。所以这章节需要掌握。四大组件都比较重要，希望大家重视。
19. 多媒体编程
19.1. 加载大图片（★★★）
Android模拟器默认为每个应用分配的堆内存空间是16M，当加载大图片时，加载图片需要的内存空间不是按图片的大小来算的，而是按像素点的多少来算的。图片加载到内存中需要把每一个像素都加载到内存中. 所以对内存的要求非常高, 一不小心就会造成OOM(OutOfMemoryError) 内存溢出致命错误。
假设：当前有一张图片，大小仅为1M，但是其规格为3648*2736，现在需要加载此图片总像素数=3648*2736=9980928。三种像素单位如下：ARGB_4444 : 2bytes，ARGB_8888 : 4bytes，RGB_565 : 4bytes。
假设现在像素采用ARGB_4444标准，则其占用的总空间为：图片占用空间=总像素数 *像素的单位=9980928 * 2bytes，=19961856bytes，=19M>16M 。OOM内存溢出。
解决方案：Java代码可以对图片进行比例缩放。假设：图片的宽和高: 3648 * 2736，屏幕的宽和高: 320 * 480。
计算缩放比：宽度缩放比例: 3648 / 320 = 11，高度缩放比例: 2736 / 480 = 5。比较宽和高的缩放比例, 哪一个大用哪一个进行缩放，缩放后的图片：3648 / 11 = 331，2736 / 11 = 248，缩放后图片的宽和高: 331* 248。331* 248=882088 * 2bytes=160K。
19.1.1. 实现图片的缩放加载
这里只给出核心代码，用于演示加载大图片的原理。普通方法加载图片代码清单：
public void load(View v) {
    	String path = etPath.getText().toString().trim();
    	// 根据路径得到图片对象
    	Bitmap bitmap = BitmapFactory.decodeFile(path);
    	// 把图片展示到ImageView控件上.
    	ivIcon.setImageBitmap(bitmap);
    }
采用缩放方式加载图片：
public void scaleLoad(View v) {
    	String path = etPath.getText().toString().trim();
      	// 得到图片的宽和高
    	Options opts = new Options();
    	opts.inJustDecodeBounds = true; // 加载器不加载图片, 而是把图片的out(宽和高)的字段信息取出来
    	BitmapFactory.decodeFile(path, opts);
    	int imageWidth = opts.outWidth;
    	int imageHeight = opts.outHeight;
    	System.out.println("图片的宽和高: " + imageWidth + " * " + imageHeight);
    	// 得到屏幕的宽和高
    	Display display = getWindowManager().getDefaultDisplay();
    	int screenWidth = display.getWidth();
    	int screenHeight = display.getHeight();
    	System.out.println("屏幕的宽和高: " + screenWidth + " * " + screenHeight);
    	// 计算缩放比例
    	int widthScale = imageWidth / screenWidth;
    	int heightScale = imageHeight / screenHeight;    	
    	int scale = widthScale > heightScale ? widthScale : heightScale;
    	System.out.println("缩放比例为: " + scale);    	
    	// 使用缩放比例进行缩放加载图片
    	opts.inJustDecodeBounds = false; // 加载器就会返回图片了
    	opts.inSampleSize = scale;
    	Bitmap bm = BitmapFactory.decodeFile(path, opts);    	
    	// 显示在屏幕上
    	ivIcon.setImageBitmap(bm);
    }
19.2. 图片加水印（★★）
Android提供了两个类Canvas和Paint：
Canvas 	画画板,用于绘制各种图形(点, 线, 圆, 矩形等等)
Paint画笔,和Canvas搭配使用,用于指定绘制的颜色, 线条的粗细, 过渡, 渐变等效果。
使用方法：
Canvas.drawBitmap(
		bitmap,  	// 被绘制的图片
		x, 	// 图片的左上角在x轴上的位置
		y, 	// 图片的左上角在y轴上的位置
		paint);	// 画笔, 绘制图片时可以忽略. 设置为null
19.2.1. 图片加水印代码实现
需求：图片加水印，即准备一张原图和一张水印图片，然后对两个图片进行合成。前提知识：两张图片的合成有如下几种方式，在该案例中我们为了让两张图片都显示，因此我们选择Darken方法。图片合成的几种方式见下图。

现在有两张图片。
1、 原图：

2、 水印：

这里我会新创建一个Android工程，并把这两个资源加入到drawable目录中。关于创建工程的步骤等简单操作在以后的文档中就一笔带过，我们直接将重点放在核心代码上。
图片合成代码清单：
//图片加水印
	public void combine(View view){
		//获取用于显示图片的ImageView控件
		iv_combine = (ImageView) findViewById(R.id.iv_combine);
		//获取原始图片
		Bitmap bm_android = BitmapFactory.decodeResource(getResources(), R.drawable.android);
		//获取水印图片
		Bitmap bm_logo = BitmapFactory.decodeResource(getResources(), R.drawable.logo);
		//创建一个新的空白Bitmap对象，用于合成后的额图片
		Bitmap bm_new = Bitmap.createBitmap(bm_android.getWidth(), bm_android.getHeight(), Config.ARGB_8888);
		//在上一步创建的Bitmap的基础上新建一个画布对象
		Canvas canvas = new Canvas(bm_new);
		//将原始图片绘制到画布上，第二个参数是左边，第三个参数是上边距，第四个参数是Pain对象，这里设置为null
		canvas.drawBitmap(bm_android, 0, 0, null);
		//新创建一个Pain对象
		Paint paint = new Paint();
		//设置两张图片的相交模式：Darken，注意：Porter、Duff是两个发明人的合成单词，本身并没有任何意义
		paint.setXfermode(new PorterDuffXfermode(Mode.DARKEN));
		//设置水印的左边距，这里设置为右下角，右边距为10
		float left = bm_android.getWidth()-bm_logo.getWidth()+10;
		//设置水印的上边距，这里设置为距离底部10
		float top = bm_android.getHeight()-bm_logo.getHeight()+10;
		//在画布上将水印绘制上去
		canvas.drawBitmap(bm_logo, left, top, paint);
		//在控件中显示合成后的图片
		iv_combine.setImageBitmap(bm_new);
		
	}

图片的特效包括，图形的缩放、镜面、倒影、旋转、位移等。图片的特效是将原图的图形矩阵乘以一个特效矩阵，形成一个新的图形矩阵来实现的。
Matrix维护了一个3*3的矩阵去更改像素点的坐标，图形的默认矩阵用数组表示为:{ 1, 0, 0,		表示向量x = 1x + 0y + 0z ，0, 1, 0,    	表示向量y = 0x + 1y + 0z   0, 0, 1  表示向量z = 0x + 0y + 1z }   
通过更改图形矩阵的值，可以做出缩放/镜面/倒影等图片特效。下面分别给出各种特效实现的代码，在代码中会有详细的注释。
19.2.2. 缩放
矩阵示例：
         { 2, 0, 0,	
   0, 1, 0,
		   0, 0, 1 }
意义：
x轴所有的像素点放大2倍, 展现的效是: 图片宽度x2
代码清单：
// 缩放
	public void scale() {
		//获取原图
		Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.logo);
		//创建一个新的Bitmap对象，宽高跟原始图片保持一致
		Bitmap newBm = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Config.ARGB_8888);
		//以新Bitmap构造一个画布
		Canvas canvas = new Canvas(newBm);
		//创建一个Matrix对象
		Matrix matrix = new Matrix();
		//矩阵值
		float[] values = new float[] { 2, 0, 0, //x=2*x+0*y+0*z
									   0, 1, 0, //y=0*x+1*y+0*z
									   0, 0, 1 };//z=0*x+0*y+1*z
		matrix.setValues(values);
		//将原始图片乘以矩阵后画到画布上
		canvas.drawBitmap(bm, matrix, null); 		//将新bitmap输出到ImageView控件
		iv.setImageBitmap(newBm);
	}
19.2.3. 镜面
矩阵示例：
{ -1, 0, 0,	x坐标变为复数，代表以y轴为镜面成像
		   0, 1, 0,	
		   0, 0, 1 }
意义：x轴所有的像素点沿负数方向反过来, 展现的效果是: 镜面。
// 镜面
	public void mirror() {
		Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.logo);
		Bitmap newBm = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Config.ARGB_8888);
		Canvas canvas = new Canvas(newBm);
		Matrix matrix = new Matrix();
//因为镜面成像以后，图片x轴全为负数，跑出了屏幕范围，因此为了看到效果把图像往x轴正方向移动一个图片的宽度
		matrix.postTranslate(bm.getWidth(), 0);
		float[] values = new float[] { -1, 0, 0, //x=-1*x+0*y+0*z
									   0, 1, 0, //y=0*x+1*y+0*z
									   0, 0, 1 };//z=0*x+0*y+1*z
		matrix.setValues(values);
		canvas.drawBitmap(bm, matrix, null);
		iv.setImageBitmap(newBm);
	}
通过上面的代码其实我们发现镜面的代码跟缩放其实基本相同的，唯一不同的就是矩阵的参数不同而已。
19.2.4. 倒影
矩阵示例：
{ 1, 0, 0,	 x轴不变
		  0, -1, 0, y轴变为负数
		  0, 0, 1 }
y轴所有的像素点沿负数方向反过来, 展现的效果是: 倒影。倒影的代码跟3.2章节中的代码一样，唯一不同的就是矩阵参数不同。同时为了看到倒影后的效果需要在矩阵中添加如下代码：
matrix.postTranslate(0, bm.getHeight());
19.2.5. 旋转
Matrix中提供了设置图片旋转角度的方法：
setRotate(float degrees, float px, float py)
degrees：要旋转的角度
px　：　旋转原点的X轴坐标
py　：　旋转原点的Y轴坐标
// 旋转
	public void rotate() {
		Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.logo);
		Bitmap newBm = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Config.ARGB_8888);
		Canvas canvas = new Canvas(newBm);
		Matrix matrix = new Matrix();
		//获取屏幕的宽度
		int width = getWindowManager().getDefaultDisplay().getWidth();
		//获取屏幕的高度
		int height = getWindowManager().getDefaultDisplay().getHeight();
		//算出图片的x轴中心坐标
		int pointX = (width-bm.getWidth())/2;
		//算出图片y轴中心坐标
		int pointY = (height-bm.getHeight())/2;
		//顺时针旋转30度
		matrix.setRotate(30, pointX,pointY);
		canvas.drawBitmap(bm, matrix, null);
		iv.setImageBitmap(newBm);
	}
19.2.6. 位移
Matrix中提供了设置图片位移的方法：
setTranslate(float dx, float dy)
dx　：　位移的X轴距离
dy　：　位移的Y轴距离
// 位移
	public void translate() {
		Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.logo);
		Bitmap newBm = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Config.ARGB_8888);
		Canvas canvas = new Canvas(newBm);
		Matrix matrix = new Matrix();
		//像x轴方向移动10，y轴方向移动40
		matrix.setTranslate(10, 40);
		canvas.drawBitmap(bm, matrix, null);
		iv.setImageBitmap(newBm);
	}
19.3. 图片颜色处理（★★）
19.3.1. 颜色过滤器ColorMatrixColorFilter
Android提供了颜色过滤器来进行颜色处理。
ColorMatrixColorFilter：通过使用一个4*5的颜色矩阵来创建一个颜色过滤器，改变图片的颜色信息。
图形颜色默认矩阵是一个4x5的矩阵, 数组表现为:
 {1, 0, 0, 0, 0,	// red	 1*R + 0*G + 0*B + 0*A + 0
0, 1, 0, 0, 0,	// green	 0*R + 1*G + 0*B + 0*A + 0
0, 0, 1, 0, 0,	// blue	0*R + 0*G + 1*B + 0*A + 0
0, 0, 0, 1, 0}	// alpha	0*R + 0*G + 0*B + 1*A + 0
颜色矩阵的每一行的最后一个值更改时，其对应的颜色值就会发生改变,所以更改颜色只需修改其对应颜色矩阵行的最后一项的值即可，最大值范围为255。
19.3.2. 实现图片美化功能
需求：加载一张图片，通过4个SeekBar分别调整R（Red）、G（Green）、B（Blue）、A（Alpha）值，第四个同时改变RGB值，实现图片颜色的变亮。
设置页面布局
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >

    <ImageView
        android:src="@drawable/v"
        android:id="@+id/iv"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

    <EditText
        android:visibility="invisible"
        android:id="@+id/et"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" 
        android:text="b.jpg"
        />
    <LinearLayout 
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        >
        <TextView 
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="R:"
            />
        <SeekBar
        android:id="@+id/sb_red"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="255" />
    </LinearLayout>
    
<LinearLayout 
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
>
    <TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="G:"
        />
    <SeekBar
        android:id="@+id/sb_green"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="255" />
</LinearLayout>
    
<LinearLayout 
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    >
    <TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="B:"
        />
    <SeekBar
        android:id="@+id/sb_blue"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="255" />
</LinearLayout>
    
<LinearLayout 
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    >
    <TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="RGB:"
        />
    <SeekBar
        android:id="@+id/sb_rgb"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="255" />
</LinearLayout>
</LinearLayout>
在drawable目录下放置一张需要处理的图片
实现业务逻辑代码
public class MainActivity extends Activity implements OnSeekBarChangeListener {
	//声明页面控件对象
	private ImageView iv;
	private SeekBar sb_red;
	private SeekBar sb_green;
	private SeekBar sb_blue;
	private SeekBar sb_rgb;
	private EditText et;
	//初始化一个矩阵数组
	private float[] arrays = new float[]{
		1.0f,0,0,0,0,
		0,1.0f,0,0,0,
		0,0,1.0f,0,0,
		0,0,0,1,0
	};
	//声明一个颜色过滤器
	private ColorFilter colorFilter = new ColorMatrixColorFilter(arrays);
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//实例化界面控件
		sb_red = (SeekBar) findViewById(R.id.sb_red);
		sb_green = (SeekBar) findViewById(R.id.sb_green);
		sb_blue = (SeekBar) findViewById(R.id.sb_blue);
		sb_rgb = (SeekBar) findViewById(R.id.sb_rgb);
		et = (EditText) findViewById(R.id.et);
		iv = (ImageView) findViewById(R.id.iv);
		//给SeekBar对象设置监听事件，这是本类实现了OnSeekBarChangeListener接口
		sb_blue.setOnSeekBarChangeListener(this);
		sb_green.setOnSeekBarChangeListener(this);
		sb_red.setOnSeekBarChangeListener(this);
		sb_rgb.setOnSeekBarChangeListener(this);
	}
	//覆写onProgressChanged方法
	@Override
	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		int id = seekBar.getId();
		switch (id) {
		case R.id.sb_red:
			arrays[4] = progress;
			break;
		case R.id.sb_blue:
			arrays[14] = progress;
			break;
		case R.id.sb_green:
			arrays[9] = progress;
			break;
		case R.id.sb_rgb:
				arrays[4]=arrays[9]=arrays[14]=progress;
				break;
		default:
			break;
		}
		//修改对应的RGB值，穿创建新的ColorFilter对象
		colorFilter = new ColorMatrixColorFilter(arrays);
		//给ImageView控件设置颜色过滤器
		iv.setColorFilter(colorFilter);
	}
}
运行效果如下图：

19.4. 案例-随手涂鸦（★★）
19.4.1. 实现原理
Android中只有View才可以捕获到用户触摸的事件。ImageView控件可以设置一个触摸事件的监听器来监听触摸事件，重写OnTouchListener的onTouch方法,结合Canvas类，即可实现随手涂鸦的画板功能。
onTouch方法的返回值默认是false的，必须设置为true,否则触摸事件将不会被处理。触摸事件的类型分为：
MotionEvent.ACTION_DOWN 	按下
MotionEvent.ACTION_MOVE 	移动
MotionEvent.ACTION_UP 		抬起
19.4.2. 代码实现
需求：手指在界面滑动的时候绘制线条。点击保存按钮可以将绘制的图形保证到存储卡上，点击取消按钮可以将当前界面清空。
布局文件比较简单，这里不再给出。
代码清单：
public class MainActivity extends Activity implements OnTouchListener {
	private ImageView iv;
	private Bitmap bitmap;
	private Canvas canvas;
	//起始坐标
	private int startX;
	private int startY;
	private Paint paint;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//实例化ImageView对象
		iv = (ImageView) findViewById(R.id.iv);
		//给ImageView设置触摸事件监听
		iv.setOnTouchListener(this);
	}
	//覆写onTouch方法
	@Override
	public boolean onTouch(View view, MotionEvent motionEvent) {
		//判断动作类型
		switch (motionEvent.getAction()) {
		//手指按下事件
		case MotionEvent.ACTION_DOWN:
			//如果当前bitmap为空
			if(bitmap==null){
				//创建一个新的bitmap对象，宽、高使用界面布局中ImageView对象的宽、高
				bitmap = Bitmap.createBitmap(iv.getWidth(), iv.getHeight(), Config.ARGB_8888);
				//根据bitmap对象创建一个画布
				canvas = new Canvas(bitmap);
				//设置画布背景色为白色
				canvas.drawColor(Color.WHITE);
				//创建一个画笔对象
				paint = new Paint();
				//设置画笔的颜色为红色，线条粗细为5磅
				paint.setColor(Color.RED);
				paint.setStrokeWidth(5);
			}
			//记录手指按下时的屏幕坐标
			startX = (int)motionEvent.getX();
			startY = (int)motionEvent.getY();
			break;
		case MotionEvent.ACTION_MOVE://手指滑动事件
			//记录移动到的位置坐标
			int moveX = (int) motionEvent.getX();
			int moveY = (int) motionEvent.getY();
			//绘制线条，连接起始位置和当前位置
			canvas.drawLine(startX, startY, moveX, moveY, paint);
			//在ImageView中显示bitmap
			iv.setImageBitmap(bitmap);
			//将起始位置改变为当前移动到的位置
			startX = moveX;
			startY = moveY;
			break;
		default:
			break;
		}
		return true;
	}
	//清除界面
	public void clear(View view){
		bitmap = null;
		iv.setImageBitmap(null);
	}
	//将当前绘制的图形保存到文件
	public void save(View view){
		if (bitmap==null) {
			Toast.makeText(this, "没有图片可以保存", Toast.LENGTH_SHORT).show();
			return ;
		}
		//创建一个文件对象
		File file = new File(getFilesDir(),"mypic"+new Date().getDate()+"_"+new Date().getHours()+"_"+new Date().getMinutes()+"_"+new Date().getSeconds()+".jpg");
		FileOutputStream stream = null;
		try {
			stream = new FileOutputStream(file);
			//以JPEG的图形格式将当前图片以流的形式输出
			boolean compress = bitmap.compress(CompressFormat.JPEG, 100, stream);
			if (compress) {
				Toast.makeText(this, "保存成功："+file.getAbsolutePath(), Toast.LENGTH_SHORT).show();
			}else {
				Toast.makeText(this, "保存失败", Toast.LENGTH_SHORT).show();
			}
		} catch (FileNotFoundException e) {
			Toast.makeText(this, "保存失败"+e.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
		}finally{
			if (stream!=null) {
				try {
					stream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
	}	
	}
}
运行改项目，效果如下图：

19.5. 案例-撕衣服游戏（★★）
19.5.1. 实现原理
使用帧布局，准备2张图片，一张图片有衣服，一张图片没有衣服。没有衣服的图片放置在下面，有衣服的图片放置在上面，为在上面的ImageView设置触摸的事件，当手指触摸到图片上时，将手指触摸的点周边的上层图片的像素点设置为透明的，就会出现一个撕衣服的效果。
触摸事件onTouch的返回值必须设置为true，否则触摸的事件将不被处理。
使用BitmapFactory的decodeResouces方法得到的图片是没有透明度的，即图片格式为RGB_565,所以若想能够修改透明度，需要使用Canvas对象对图片进行重绘，重新绘制的图片格式采用ARGB。
加载图片时需要对其进行一下压缩，防止图片与控件大小不匹配，导致触摸时点对不上，达不到触摸那里就设置哪里的像素点透明的效果。
代码实现
public class MainActivity extends Activity implements OnTouchListener {

	private Bitmap bitmap;
	private ImageView ivTop;
	private ImageView ivBottom;
	
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //实例化两个ImageView控件对象
        ivBottom = (ImageView) findViewById(R.id.iv_bottom);
        ivTop = (ImageView) findViewById(R.id.iv_top);
        
        
        Options opts = new Options();
        opts.inSampleSize = 2;
        //加载2张图片
        Bitmap topBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.a8, opts);
        Bitmap bottomBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.b8, opts);
        //创建一个bitmap对象
        bitmap = Bitmap.createBitmap(topBitmap.getWidth(), topBitmap.getHeight(), Config.ARGB_8888);
       //创建一个画布对象
        Canvas canvas = new Canvas(bitmap);
        //将顶层图片绘制到bitmap对象中
        canvas.drawBitmap(topBitmap, 0, 0, null); 
        //给ImageView控件设置图片
        ivBottom.setImageBitmap(bottomBitmap);
        //给顶层ImageView设置新绘制的位图
        ivTop.setImageBitmap(bitmap);
        //给顶层图片控件设置监听事件
        ivTop.setOnTouchListener(this);
    }
    /**
     * 覆写onTouch方法
     */
	public boolean onTouch(View v, MotionEvent event) {
		if(event.getAction() == MotionEvent.ACTION_MOVE) {
			//获取当前屏幕坐标
			int x = (int) event.getX();
			int y = (int) event.getY();
			//将当前坐标周围的一个矩形区域设置为透明
	        for(int i = x - 10; i < x + 10; i ++) {
	        	for (int j = y - 10; j < y + 10; j++) {
	        		if(i >= 0 && i < bitmap.getWidth()
	        				&& j >= 0 && j < bitmap.getHeight()) {
	        			bitmap.setPixel(i, j, Color.TRANSPARENT);
	        		}
				}
	        }
	        //重新给ivTop控件设置bitmap对象
	        ivTop.setImageBitmap(bitmap);
		}
		//必须返回true，否则事件不成功
		return true;
	}
    
}
运行效果如下图所示：

在这里没衣服的就不展示了，想看的问我要。

19.6. 音频播放（★★）
19.6.1. MediaPlayer
MediaPlayer播放器状态流程如下图：

该播放器同时只能播放一个音乐文件，文件大小并没有限制。
MediaPlayer必须严格按照状态图操作，否则就会出现错误，这些错误都是底层抛出，严格按照状态图操作的话一般就不会出问题。使用MediaPlayer播放音乐的步骤如下所示：
MediaPlayer player = new MediaPlayer();		创建对象
player.reset();					重置为初始状态
player.setAudioStreamType(AudioManager.STREAM_MUSIC);声音流类型
player.setDataSource(“/mnt/sdcard/test.mp3”);	设置音频源
player.prepare();					准备				
player.start();					开始或恢复播放
player.pause();					暂停播放
player.start();					恢复播放
player.stop();					停止播放
player.release();	


19.6.2. SoundPool
SoundPool和其他声音播放类相比，其特点是可以自行设置声音的品质、音量、播放比率等参数。并且它可以同时管理多个音频流，每个流都有独自的ID，对某个音频流的管理都是通过ID进行的。
应用场景
程序中有些很短小音频需要经常播放，例如：游戏音效
如果使用MediaPlayer每次加载音频、播放、再释放，这样很费事
我们可以使用音频池一次性加载多个音频，需要哪个就直接播放

SoundPool最大只能申请1M的内存空间，这就意味着我们只能用一些很短的声音片段，而不是用它来播放歌曲或者做游戏背景音乐。
SoundPool提供了pause和stop方法，但这些方法建议最好不要轻易使用，因为有些时候它们可能会使你的程序莫名其妙的终止。
有些朋友反映它们不会立即中止播放声音，而是把缓冲区里的数据播放完才会停下来。这是SoundPool的效率问题。其实SoundPool的效率在这些播放类中算是很好的了，这可能会影响用户体验。也许这不能管SoundPool本身，因为到了性能比较好的Droid中这个延迟就可以让人接受了。
使用SoundPool播放音乐的步骤
创建SoundPool实例, 第一个参数用于指定最大可以加载声音个数
SoundPool soundPool=new SoundPool(3,AudioManager.STREAM_MUSIC, 0);
加载不同的声音文件，生成各自的声音id
int shoot1ID = soundPool.load(this, R.raw.shoot1, 1);
int shoot2ID = soundPool.load(this, R.raw.shoot2, 1);
int shoot3ID = soundPool.load(this, R.raw.shoot3, 1);
根据load方法获取的id播放对应的声音
soundPool.play(shoot1ID, 1, 1, 1, 0, 1);
soundPool.play(shoot2ID, 1, 1, 1, 0, 1);
soundPool.play(shoot3ID, 1, 1, 1, 0, 1);
19.6.3. 使用两种方式播放音乐
该案例比较简单，布局中只需两个按钮，一个用于播放MediaPlayer一个用于播放SoundPool。我们需要将事先准备好的因为文件放到res/raw目录下，其中raw目录需要我们新创建。
代码清单如下：
public class MainActivity extends Activity {
	//声明MediaPlayer和SoundPool对象
	private MediaPlayer mediaPlayer;
	private SoundPool soundPool;
	private int soundID;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//创建MediaPlayer对象
		mediaPlayer = new MediaPlayer();
		try {
			//设置音乐文件路径
	mediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+"/bgmusic.mp3");
			//准备
			mediaPlayer.prepare();
		} catch (Exception e) {
			e.printStackTrace();
		}
		//初始化SoundPool
		soundPool = new SoundPool(1, AudioManager.STREAM_MUSIC,1);
		//加载SoundPool音乐文件
		soundID = soundPool.load(this, R.raw.shoot1, 1);
	}

	public void soundPoolPlay(View view) {
		//播放SoundPool音乐
		soundPool.play(soundID, 1, 1, 0, 0, 1);
	}

	public void mediaPlayerPlay(View view) {
		//判断当前音乐是否在播放
		boolean isPlaying = mediaPlayer.isPlaying();
		if (!isPlaying) {
			//播放音乐
			mediaPlayer.start();
		}else {
			Toast.makeText(this, "音乐正在播放中", 0).show();	
		}
	}
}
19.6.4. 案例-音乐播放器
制作一个播放器，能够播放/暂停/停止/重播音乐文件，并且添加一个SeekBar,音乐播放时，SeekBar的滚动条也会变化，拖动SeekBar，可更改声音播放的进度。
要实现此音乐播放器，必须严格按照上方的MediaPlayer状态流程图进行控制，否则非常容易使应用程序出错挂掉。
1、 新创建一个Android工程《音乐播放器》
2、 修改并使用默认布局文件，布局文件清单如下：
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="音乐播放器" />

    <EditText
        android:id="@+id/et_path"
        android:text="/mnt/sdcard/bgmusic.mp3"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入音乐路径" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal" >

        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="play"
            android:text="播放" />

        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="pause"
            android:text="暂停" />

        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="stop"
            android:text="停止" />

        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="replay"
            android:text="重播" />
    </LinearLayout>

    <SeekBar
        android:id="@+id/sb"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/tv_time"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:textColor="#ff0000"
        android:textSize="24sp" />

</LinearLayout>

3、 使用并编写默认的MainActivity类，在该类中实现核心业务逻辑。代码清单如下：
  public class MainActivity extends Activity implements OnSeekBarChangeListener {
	private EditText et_path;
	private SeekBar sb;
	private TextView tv_time;
	private MediaPlayer player;
	private int duration;
	private boolean isUpdateBar;
	// 播放器的几个状态
	private static final int PLAYING = 1;// 播放状态
	private static final int PAUSING = 2;// 暂停状态
	private static final int STOPPING = 3;// 停止状态
	private int CURRENT = 0;// 当前状态

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//初始化界面控件
		et_path = (EditText) findViewById(R.id.et_path);
		sb = (SeekBar) findViewById(R.id.sb);
		//给SeekBar绑定滑动事件
		sb.setOnSeekBarChangeListener(this);
		tv_time = (TextView) findViewById(R.id.tv_time);
	}
	//播放音乐
	public void play(View view) {
		if (player!=null) {
			if (CURRENT==PLAYING) {
				return;
			}else if (CURRENT==PAUSING) {
				player.start();
				CURRENT = PLAYING;
				updateSeekBar();
				return;
			}else if (CURRENT==STOPPING) {
				player.reset();
				player.release();
			}
		}
			try {
				//创建一个播放器对象
				player = new MediaPlayer();
				//获取音乐路径
				String path = et_path.getText().toString();
				//给播放器设置音乐路径
				player.setDataSource(path);
				//设置音乐格式
				player.setAudioStreamType(AudioManager.STREAM_MUSIC);
				//准备
				player.prepare();
				//获取音乐最大长度 （毫秒单位）
				duration = player.getDuration();
				//给SeekBar设置最大值
				sb.setMax(duration);
				//格式化输出音乐长度
				String lastString = formatTime(duration);
				tv_time.setText("00:00/" + lastString);
				//音乐开始播放
				player.start();
				//更新SeekBar
				updateSeekBar();
			} catch (Exception e) {
				e.printStackTrace();
				Toast.makeText(this, "音乐播放失败"+e, 0).show();
			}
	}
	//暂停
	public void pause(View view) {
		if (player != null && CURRENT==PLAYING) {
			player.pause();
			stopSeekBar();
			CURRENT = PAUSING;
		}
	}
	//停止播放
	public void stop(View view) {
		if (player != null) {
			if (CURRENT == PLAYING || CURRENT == PAUSING) {
				player.stop();
				stopSeekBar();
				sb.setProgress(0);
				tv_time.setText("00:00/"+formatTime(duration));
				CURRENT = STOPPING;
			}
		}
	}
	//重新播放
	public void replay(View view) {
		if (player != null) {
			stopSeekBar();
			CURRENT = STOPPING;
			play(view);
		}
	}
	//停止SeekBar更新
	private void stopSeekBar() {
		isUpdateBar = false;
	}
	//更新SeekBar
	private void updateSeekBar() {
		isUpdateBar = true;
		new Thread(new Runnable() {

			@Override
			public void run() {
				while (isUpdateBar) {
					//每秒更新一次
					SystemClock.sleep(1000);
					if (player != null && CURRENT==PLAYING) {
						sb.setProgress(player.getCurrentPosition());
						//在主线程中运行如下代码更新EditText
						runOnUiThread(new Runnable() {

							@Override
							public void run() {
								String current = formatTime(player.getCurrentPosition());
								String durationString = formatTime(duration);
								
tv_time.setText(current + "/" + durationString);
							}
						});
					}
				}
			}
		}).start();
	}

	@Override
	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		if (player != null) {
			player.seekTo(progress);
		}
	}
	
	//开始拖动SeekBar时停止更新SeekBar
	public void onStartTrackingTouch(SeekBar seekBar) {
		stopSeekBar();
	}

	//停止拖动SeekBar的时候将音乐定位到相应位置
	public void onStopTrackingTouch(SeekBar seekBar) {
		if (player != null) {
			player.seekTo(seekBar.getProgress());
			updateSeekBar();
		}
	}
	//工具函数 格式化播放时间
	private String formatTime(int current) {
		int second = current / 1000;
		int minute = second / 60;
		second = second - minute * 60;
		StringBuilder sb = new StringBuilder();
		sb.append(minute > 10 ? minute + "" : "0" + minute);
		sb.append(":");
		sb.append(second > 10 ? second : "0" + second);
		return sb.toString();
	}
}

4、 运行上面的工程，效果图如下：

19.7. 视频播放（★★）
19.7.1. 使用MediaPlayer+SurfaceView播放视频文件
在这里视频播放依然通过MediaPlayer类，为了方便演示，我们直接使用1.4章节中的创建的工程，只需在布局文件添加SurfaceView控件即可。
<SurfaceView 
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/sv"
        />
我们直接在1.4章节的代码基础上进行修改，修改MainActivity类，这里只给出不同的代码片段：
添加如下变量的声明
private SurfaceView sv;
private SurfaceHolder holder;
 在play（）方法中添加如下代码
//设置输出画面
player.setDisplay(holder);
 获取SurfaceView对象，并设置缓存方式
sv = (SurfaceView) findViewById(R.id.sv);
		holder = sv.getHolder();
		/**
		 * SurfaceView内部采用双缓冲区
		 * 设置SurfaceView不维护自己的缓存区，使用屏幕的渲染引擎将内容推			 * 送到用户面前
		 */
		holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
运行该工程，效果图如下：

19.7.2. 使用VideoView控件显示视频
VideoView跟MediaPlayer相比播放视频步骤要简单的多，因此VideoView自己提供了播放，暂停、快进、快退、进度条等方法。使用起来要方便的很多。
1、 设置布局文件，布局文件比较简单，因此这里只给你VideoView标签。
   <VideoView
        android:id="@+id/vv"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
2、 设置VideoView的播放文件路径和媒体控制器,调用start方法即可播放媒体文件。
//实例化VideoView对象
		vv = (VideoView) findViewById(R.id.vv);
		//从界面获取播放路径
		et_path = (EditText) findViewById(R.id.et_path);
		//给VideoView设置视频路径
		vv.setVideoPath(et_path.getText().toString());
		//设置VideoView控制器，我们当前类实现了MediaPlayerControl接口
		vv.setMediaController(new MediaController(this));
		//开始播放
		vv.start();
		//设置当前播放器窗口设置为焦点
		vv.requestFocus();
3、 覆写MediaPlayerControl接口中的抽象方法
@Override
	public void start() {
	}
	@Override
	public void pause() {
		
	}
	@Override
	public int getDuration() {
		return 0;
	}
	@Override
	public int getCurrentPosition() {
		return 0;
	}
	@Override
	public void seekTo(int pos) {
	}
	@Override
	public boolean isPlaying() {
		return false;
	}
	@Override
	public int getBufferPercentage() {
		return 0;
	}
	@Override
	public boolean canPause() {
		return false;
	}
	@Override
	public boolean canSeekBackward() {
		return false;
	}
	@Override
	public boolean canSeekForward() {
		return false;
	}
	@Override
	public int getAudioSessionId() {
		return 0;
	}
上面的方法都是回调方法，我们可以在这些方法里面实现我们的业务逻辑。但是当我们给VideoView设置setMediaController后，控制器才会出现。
4、 运行上面代码，效果图如下：

19.8. 传感器（★★）
19.8.1. Android中常见的传感器
Android手机中内置了很多传感器，其主要类型有：方向、加速度(重力)、光线、磁场、距离(临近性)、温度等。
方向传感器			    Sensor.TYPE_ORIENTATION
加速度(重力)传感器		Sensor.TYPE_ACCELEROMETER
光线传感器			    Sensor.TYPE_LIGHT
磁场传感器			    Sensor.TYPE_MAGNETIC_FIELD
距离(临近性)传感器		Sensor.TYPE_PROXIMITY
温度传感器			    Sensor.TYPE_TEMPERATURE
19.8.2. 传感器的使用
获取传感器管理器SensorManager:
//获取传感器管理器
SensorManager sm = (SensorManager) getSystemService(SENSOR_SERVICE);
通过传感器管理器对象获得指定类型的传感器：
//获取指定传感器对象，获取系统默认的重力加速度传感器
Sensor sensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
通过传感器管理器对象获得手机中所有的传感器：
//获取手机支持的所有传感器
		List<Sensor> sensorList = sm.getSensorList(Sensor.TYPE_ALL);
		for(int i=0;i<sensorList.size();i++){
			Sensor sensor = sensorList.get(i);
			//获取传感器名称
			String name = sensor.getName();
			//获取传感器厂商
			String vendor = sensor.getVendor();
			//获取传感器版本号
			int version = sensor.getVersion();
		}	
使用传感器管理器对象注册传感器来使一个传感器工作：
/*
		 * 注册一个传感器
		 * 第二个参数Sensor是具体某个传感器对象
		 * 第三个参数是设定传感器采样频率
		 */
		sm.registerListener(new SensorEventListener() {
			//当传感器值改变时触发该函数
		@Override
			public void onSensorChanged(SensorEvent event) {
				Toast.makeText(MainActivity.this, ""+event.accuracy, 0).show();
			}
			//当传感器精确度更改是触发该函数
			@Override
			public void onAccuracyChanged(Sensor sensor, int accuracy) {
				Toast.makeText(MainActivity.this, ""+accuracy, 1).show();
			}
		}, sensor, SensorManager.SENSOR_DELAY_NORMAL);
listener ：传感器事件监听器
sensor　：要被注册的传感器对象
rate ：采样率,分为最快、游戏、普通、用户界面几种当应用程序请求特定的采样率时，其实只是对传感器子系统的一个建议，不保证特定的采样率可用。
采样率的四种类型详解：
最快： SensorManager.SENSOR_DELAY_FASTEST
最低延迟，一般不是特别敏感的处理不推荐使用，该种模式可能造成手机电力大量消耗，由于传递的为原始数据，算法不处理好将会影响游戏逻辑和UI的性能
游戏： SensorManager.SENSOR_DELAY_GAME
游戏延迟，一般绝大多数的实时性较高的游戏都使用该级别
普通： SensorManager.SENSOR_DELAY_NORMAL 
标准延迟，对于一般的益智类或EASY级别的游戏可以使用，但过低的采样率可能对一些赛车类游戏有跳帧现象
用户界面： SensorManager.SENSOR_DELAY_UI
一般对于屏幕方向自动旋转使用，相对节省电能和逻辑处理，一般游戏开发中我们不使用
19.8.3. 案例-公交防盗
当手机从衣服兜里被掏出时，手机响铃报警。原理是使用距离传感器，当距离从0变为1时，使用MediaPlayer播放声音文件报警。实现步骤如下所示：
1、 设置布局文件：添加一个报警按钮开关，用于开启/停止报警功能
2、 声明成员变量
// 声明Button变量
	private Button bt;
	// 声明传感器管理器
	private SensorManager sm;
	// 声明MediaPlayer
	private MediaPlayer player;
	// 声明一个传感器对象
	private Sensor sensor;
	// 标记当前防盗功能是否开启
	private boolean isOpen = false;
3、 使当前类继承SensorEventListener并覆写抽象方法
@Override
	public void onSensorChanged(SensorEvent event) {
		// 获取距离传感器的值
		float value = event.values[0];
		if (value > 0) {
			try {
				// 如果距离大于0则播放音乐
				player.start();
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			// 如果距离等于0 暂停音乐
			player.pause();
		}
	}
	@Override
	public void onAccuracyChanged(Sensor sensor, int accuracy) {
	}
4、 实现Button的按钮事件，点击开启或者关闭音乐
public void click(View view) {
		if (isOpen) {// 如果开启
			// 暂停音乐
			player.pause();
			// 使按钮显示提示文字
			bt.setText("防盗已经关闭");
			// 取消传感器监听
			sm.unregisterListener(this);
			isOpen = false;
		} else {// 如果没有开启
				// 播放音乐
			player.start();
			bt.setText("防盗已经开启");
			// 注册传感器监听
			sm.registerListener(this, sensor, 	SensorManager.SENSOR_DELAY_NORMAL);
			isOpen = true;
		}
	}
5、 覆写Activity的onCreate方法，在该方法里面实现MediaPlayer的初始化以及传感器的监听
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		// 初始化变量
		bt = (Button) findViewById(R.id.bt);
		sm = (SensorManager) getSystemService(SENSOR_SERVICE);
		// 获取距离传感器
		sensor = sm.getDefaultSensor(Sensor.TYPE_PROXIMITY);
		// 创建MediaPlayer对象
		player = MediaPlayer.create(this, R.raw.apple);
		// 给MediaPlayer设置播放完事件监听
		player.setOnCompletionListener(new OnCompletionListener() {
			@Override
			public void onCompletion(MediaPlayer mp) {
				// 播放完后重新播放
				mp.start();
			}
		});
	}
19.9. 摄像头（★★）
19.9.1. 调用系统摄像头实现照相和摄像功能
调用系统摄像头进行拍照和摄像无需添加权限，直接调用即可。只需知道系统摄像头的action和category就可以调用系统摄像头。具体步骤如下所示：
1. 打开Android源码，查看”\packages\apps\”文件文件目录下的Camera应用，即系统摄像头的应用程序。打开其清单文件文件，查看其Activity的action和category信息。
2. Camera类的action和category
   <intent-filter>
        <action android:name="android.media.action.IMAGE_CAPTURE" />
        <category android:name="android.intent.category.DEFAULT" />
</intent-filter>
3. VideoCamera类的action和category
<intent-filter>
        <action android:name="android.media.action.VIDEO_CAMERA" />
        <category android:name="android.intent.category.DEFAULT" />
 </intent-filter>

4. 已知调用系统摄像头拍照和摄像功能对应的action和category信息，采用隐式调用的方式调用Activity。
由于希望在调用拍照或摄像功能后回到当前应用的界面，且得知拍照或摄像的结果如何，是否成功，所以在开启Activity时不能使用startActivity方法，而是使用startActivityForResult方法开启Activity，并重写onActivityResult方法处理回传的数据。
布局文件比较简单，界面只有两个按钮，一个用于打开照相机，一个用于打开摄像机。这里只给出代码清单。
拍照功能
public void take(View view){
		//创建一个Intent对象
		Intent intent = new Intent();
		//设置Action
		intent.setAction("android.media.action.IMAGE_CAPTURE");
		//创建一个文件
		File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),"my.jpg");
		//创建uri对象
		Uri uri = Uri.fromFile(file);
		//设置图片的输出路径
		intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
		//开启Activity
		startActivityForResult(intent, 100);
	}
 摄像功能（摄像功能跟拍照功能比仅仅是action不同而已）
public void video(View view){
		Intent intent = new Intent();
		intent.setAction("android.media.action.VIDEO_CAPTURE");
		File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath(),"myVedio.mp4");
		Uri uri = Uri.fromFile(file);
		intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
		startActivityForResult(intent, 101);
	}
19.9.2. 编码实现照相功能
使用Camera+SurfaceView控件可实现拍照功能。首先设置布局文件：一个SurfaceView和一个拍照按钮，在清单文件中添加2个权限信息
<uses-permission android:name="android.permission.CAMERA"/>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>  
1、 声明成员变量
private Camera camera;//照相机对象
private SurfaceHolder holder;//SurfaceView的辅助类
2、 获取SurfaceView控件的实例，通过其辅助类SurfaceHolder对象添加CallBack接口的实现
//获取预览画面的SurfaceView控件
SurfaceView surfaceView = (SurfaceView) findViewById(R.id.sv);
//得到预览画面的辅助类
holder = surfaceView.getHolder();
//添加回调方法
		holder.addCallback(new Callback() {

			@Override
			public void surfaceCreated(SurfaceHolder holder) {
				try {
					//打开摄像头
					camera = Camera.open();
					//设置预览显示的位置
					camera.setPreviewDisplay(holder);
					//开启预览
					camera.startPreview();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			@Override
			public void surfaceDestroyed(SurfaceHolder holder) {
				//停止预览界面
				camera.stopPreview();
				//释放摄像头
				camera.release();
			}
			@Override
			public void surfaceChanged(SurfaceHolder holder, int format, 					int width, int height) {
			}
3、 添加点击拍照按钮的点击事件：设置摄像头自动对焦，对焦完成后保存图片并重新预览
	//拍照
	public void takeImage(View view) {
		if (camera == null) {
			Toast.makeText(this, "照相机还没打开。", Toast.LENGTH_SHORT).show();
			return;
		}
		//点击拍照按钮，摄像头自动对焦，对焦完成后拍照并保存
		camera.autoFocus(new AutoFocusCallback() {

			@Override
			public void onAutoFocus(boolean success, Camera camera) {
				//对焦完成，拍照并保存
				camera.takePicture(null, null, new PictureCallback() {
					@Override
					public void onPictureTaken(byte[] data, Camera camera) {
						//设置照片保存路径
						String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/" + UUID.randomUUID().toString() + ".jpg";
						try {
							FileOutputStream outputStream = new FileOutputStream(path);
							//将照片字节数组写到文件中
							outputStream.write(data);
							outputStream.close();
							//重新开启预览
							camera.startPreview();
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				});
			}
		});
	}
19.9.3. 编码实现摄像功能
使用Camera+MediaRecoder + SurfaceView控件可实现录制视频的功能。
所需权限如下所示：
<uses-permission android:name="android.permission.CAMERA"/>
 <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 <uses-permission android:name="android.permission.RECORD_AUDIO"/>

实现摄像功能步骤如下所示：
1、 设置布局文件：一个SurfaceView+一个开始录制按钮+一个停止录制按钮
2、 在清单文件中添加权限信息：摄像头+录音+写SD卡
3、 声明要使用的成员变量
private Camera camera;
	private SurfaceHolder holder;
	private MediaRecorder recorder;
4、 获取SurfaceHolder，添加回调方法
//获取SurfaceView控件实例
		SurfaceView sv = (SurfaceView) findViewById(R.id.sv);
		//获取SurfaceHolder对象
		holder = sv.getHolder();
		//添加回调对象
		holder.addCallback(this);
5、 重写Callback接口的surfaceCreated和surfaceDestroyed方法：SurfaceView创建时初始化摄像头,销毁时释放摄像头资源
@Override
	public void surfaceCreated(SurfaceHolder holder) {
		//打开摄像头
		camera = Camera.open();
		try {
			//给摄像头设置预览对象
			camera.setPreviewDisplay(holder);
			//开启预览
			camera.startPreview();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	@Override
	public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
		
	}
	@Override
	public void surfaceDestroyed(SurfaceHolder holder) {
		//停止预览
		camera.stopPreview();
		//释放资源
		camera.release();
	}
6、 添加点击开始录制按钮时的逻辑
//开始录制视频
	public void start(View view){
		//停止预览
		camera.stopPreview();
		//解锁摄像头
		camera.unlock();
		//初始化一个MediaRecorder对象
		recorder = new MediaRecorder();
		//给recorder设置摄像头
		recorder.setCamera(camera);
		//设置音频源
		recorder.setAudioSource(AudioSource.CAMCORDER);
		//设置视频源
		recorder.setVideoSource(VideoSource.CAMERA);
		//设置录像质量等参数
		CamcorderProfile profile = CamcorderProfile.get(CamcorderProfile.QUALITY_480P);
		recorder.setProfile(profile );
		//设置录像输出路径
		recorder.setOutputFile(Environment.getExternalStorageDirectory().getAbsolutePath()+"/text.mp4");
		//设置预览显示对象
		recorder.setPreviewDisplay(holder.getSurface());
		try {
			//准备
			recorder.prepare();
		} catch (Exception e) {
			e.printStackTrace();
		}
		//开始录像
		recorder.start();
	}
//开始录制视频
	public void start(View view){
		//停止预览
		camera.stopPreview();
		//解锁摄像头
		camera.unlock();
		//初始化一个MediaRecorder对象
		recorder = new MediaRecorder();
		//给recorder设置摄像头
		recorder.setCamera(camera);
		//设置音频源
		recorder.setAudioSource(AudioSource.CAMCORDER);
		//设置视频源
		recorder.setVideoSource(VideoSource.CAMERA);
		//设置录像质量等参数
		CamcorderProfile profile = CamcorderProfile.get(CamcorderProfile.QUALITY_480P);
		recorder.setProfile(profile );
		//设置录像输出路径
		recorder.setOutputFile(Environment.getExternalStorageDirectory().getAbsolutePath()+"/text.mp4");
		//设置预览显示对象
		recorder.setPreviewDisplay(holder.getSurface());
		try {
			//准备
			recorder.prepare();
		} catch (Exception e) {
			e.printStackTrace();
		}
		//开始录像
		recorder.start();
	}
7、 添加点击停止录制时的逻辑
public void stop(View view){
		//停止录像
		recorder.stop();
		//重置录像
		recorder.reset();
		//释放资源
		recorder.release();
		//锁定摄像头
		camera.lock();
		//开启预览
		camera.startPreview();
	}
19.10. 获取图库中的图片
打开图库
Intent intent = new Intent();
intent.setAction(Intent.ACTION_PICK);
intent.setType("image/*");
startActivityForResult(intent, 100);
获取返回数据
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
	Uri uri = data.getData();	// 被选中文件的Uri
	ImageView imageView = (ImageView) findViewById(R.id.imageView);
	imageView.setImageURI(uri);
}
获取Uri的绝对路径
private String getAbsolutePath(Uri uri) {
	Cursor c = getContentResolver().query(uri, new String[]{MediaStore.Images.Media.DATA}, null, null, null);
	c.moveToNext();
	return c.getString(0);
}
具体实现代码
public class MainActivity extends Activity {
	private ImageView iv_showPic;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		iv_showPic = (ImageView) findViewById(R.id.iv_showImg);
	}
	//选择图片按钮
	public void chooseImg(View v){
		Intent intent=new Intent(Intent.ACTION_PICK);
		intent.setType("image/*");
		startActivityForResult(intent, 100);
	}
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		if(data!=null){
			Uri uri = data.getData();
			//第一种方法：通过设置bitmap对象
			String url=getAbsolutePath(uri);
			System.out.println(url);
			Bitmap maBitmap = getScaleBitmap(url);
//			iv_showPic.setImageBitmap(maBitmap);//
			//第二种方法：
			iv_showPic.setImageURI(uri);//可以直接通过uri设置显示的图片
		}
	}
	//将一个图片路径转化为一个bitmap对象，并将其缩放适应屏幕
	private Bitmap getScaleBitmap(String url) {
		Options options=new Options();
		options.inJustDecodeBounds=true;
		WindowManager manager=(WindowManager) getSystemService(WINDOW_SERVICE);
		int scaleX=options.outWidth/manager.getDefaultDisplay().getWidth();
		int scaleY=options.outHeight/manager.getDefaultDisplay().getHeight();
		int scale=scaleX>scaleY?scaleX:scaleY;
		options.inJustDecodeBounds=false;
		options.inSampleSize=scale>1?scale:1;
		return BitmapFactory.decodeFile(url,options);
	}
	//通过内容提供者获取uri中的数据
	private String getAbsolutePath(Uri uri) {
		String url="";
		Cursor cursor = getContentResolver().query(uri, new String[]{MediaStore.Images.Media.DATA}, null, null, null);
		if(cursor.moveToNext()){
			url=cursor.getString(0);
		}
		return url;	
	}
}
19.11. 获取Exif信息
ExifInterface exif = new ExifInterface("/mnt/sdcard/test.jpg");
System.out.println(exif.getAttribute(ExifInterface.TAG_DATETIME));			// 拍摄时间
System.out.println(exif.getAttribute(ExifInterface.TAG_MODEL));			// 拍摄设备
System.out.println(exif.getAttribute(ExifInterface.TAG_ORIENTATION));		// 方向
System.out.println(exif.getAttribute(ExifInterface.TAG_GPS_LONGITUDE));	// 经度
System.out.println(exif.getAttribute(ExifInterface.TAG_GPS_LATITUDE));	// 纬度
19.12. 结合工作和面试
1. 面试中
如何加载100M的图片，不损伤精度？
2个方法：
根据屏幕大小将这个图切成N多块，要加载时根据屏幕滑动加载，类似于目前常用的谷歌地图方式；
熟悉图片的文件格式，只从文件中读取当前屏幕要显示的数据。
图片如何加水印？
图片的优化，如何避免大图导致的oom？
这个后期还会接触，三级缓存。Lrucache算法。
Android 中用bitmap 时很容易内存溢出，报如下错误：Java.lang.OutOfMemoryError : bitmap size exceeds VM budget
解决：
方法一： 等比例缩小图片，具体步骤如下所示：
1、 通过getResource()方法获取资源：
//解决加载图片 内存溢出的问题	
 //Options 只保存图片尺寸大小，不保存图片到内存
       BitmapFactory.Options opts = new BitmapFactory.Options();
       //缩放的比例，缩放是很难按准备的比例进行缩放的，其值表明缩放的倍数，SDK中建议其值是2的指数值,值越大会导致图片不清晰
       opts.inSampleSize = 2;
       Bitmap bmp = null;
       bmp = BitmapFactory.decodeResource(getResources(), mImageIds[position],opts);                             
       ... 
       //回收
       bmp.recycle();
2、 通过Uri取图片资源
private ImageView preview;
BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一
Bitmap bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri), null, options);
preview.setImageBitmap(bitmap);
上述代码可以优化内存溢出，但它只是改变图片大小，并不能彻底解决内存溢出。
3、 通过路径获取图片资源
private ImageView preview;
private String fileName= "/sdcard/DCIM/Camera/2010-05-14 16.01.44.jpg";
BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一
Bitmap b = BitmapFactory.decodeFile(fileName, options);
preview.setImageBitmap(b);
filePath.setText(fileName);
方法二：对图片采用软引用，及时地进行recyle()操作
SoftReference<Bitmap> bitmap;
bitmap = new SoftReference<Bitmap>(pBitmap);
if(bitmap != null){
if(bitmap.get() != null && !bitmap.get().isRecycled()){
bitmap.get().recycle();
bitmap = null;
}
}
图片这块比较重要，目前学习的不多，后期针对图片优化、内存优化这块需要多加关注。如果图片优化掌握的比较好，对后期就业会有很大帮助，希望大家重视！！！
2. 工作中
拍照、使用系统摄像头，这块用的比较多。大家多加关注。
大图片处理，图片优化，在工作中用的比较多，重中之重。
图片加水印，这块可以多了解下，面试，工作都有可能用到。
传感器，用的相对也比较多，像摇一摇。

20. Fragment（★★★★）
20.1. 什么是Fragment
Fragment（碎片）就是小型的Activity，它是在Android3.0时出现的。Fragment是表现Activity中UI的一个行为或者一部分。
可以把fragment想象成activity的一个模块化区域，有它自己的生命周期，接收属于它自己的输入事件，并且可以在activity运行期间添加和删除（有点像一个可以在不同的activity中重用的“子Activity”）。
Fragment必须被嵌入到一个activity中。它们的生命周期直接受其宿主activity的生命周期影响。当一个activity正在运行时，就可以独立地操作每一个Fragment，比如添加或删除它们。
Fragment可以定义自己的布局、生命周期回调方法，因此可以将fragment重用到多个activity中，因此可以根据不同的屏幕尺寸或者使用场合改变fragment组合。
20.2. 如何创建一个Fragment
1、 为Fragment定义一个布局
2、 定义类继承Fragment
3、 重写类中的onCreateView方法，返回一个View对象作为当前Fragment的布局。
fragment第一次绘制它的用户界面的时候，系统会调用onCreateView()方法。为了绘制fragment的UI，此方法必须返回一个作为fragment布局的根的view。如果fragment不提供UI，可以返回null。
/**
 * 定义类继承Fragment
 */
public class TitleFragment extends Fragment {
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		//使用打气筒填充生成一个View对象，fragment_title是一个布局的根节点
		View view = inflater.inflate(R.layout.fragment_title, null);
		return view;
	}
}
20.3. 如何将Fragment添加到Activity
Activity必须在清单文件中进行声明，但是Fragment不需要，Fragment只需要在Activity的布局文件中声明就可以了。
<fragment 
        android:id="@+id/fmt_title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:name="com.itheima.fragment.TitleFragment"
        />
注意：代码中的四个属性是必须的要给的，“android:name”属性：指定了在layout中实例化的Fragment类是哪个。
当系统创建这个activity layout时，它实例化每一个在layout中指定的Fragment，并调用它们的onCreateView()方法，来获取每一个Fragment的layout，系统将从Fragment返回的View 直接插入到<fragment>元素所在的地方
每一个fragment都需要一个唯一的标识，如果activity重启，系统可以用来恢复Fragment，并且可以用id来捕获Fragment来处理事务，例如移除它。
有3种方法来为一个fragment提供一个ID，具体如下所示：
为android:id属性提供一个唯一ID;
为android:tag属性提供一个唯一字符串;
如果以上2个你都没有提供，系统将使用容器view的ID;
20.4. 如何切换Fragment
 	要在activity中管理Fragment，需要使用FragmentManager可以通过调用activity的getFragmentManager()取得它的实例。
案例：点击不同的按钮切换到不同的Fragment进行显示。具体实现步骤：
1、 设置布局文件：添加三个按钮用于切换Fragment，并在按钮下方添加一个FrameLayout用来替换成响应的Fragment。
2、 创建三个Fragment，SportsFragment、NewsFragment、GameFragment。
public class SportsFragment extends Fragment {
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		// 使用打气筒生成一个View对象
		View view = inflater.inflate(R.layout.fragment_sports, null);
		return view;
	}
}
其余两个Fragment跟SportsFragment代码一致，只是布局文件不同。
3、 添加切换Fragment的逻辑，这个是新闻频道按钮的点击事件
public void news(View view){
		//获取Fragment管理器对象
		FragmentManager manager = getFragmentManager();
		//开启事务
		FragmentTransaction transaction = manager.beginTransaction();
		//将FrameLayout控件替换成Fragment对象
		transaction.replace(R.id.frame, new NewsFragment());
		//提交事务
		transaction.commit();
	}
sports（）方法、games（）方法同上，因此不再给出代码清单。
4、 运行程序，效果如下

20.5. Fragment的生命周期
Fragment的生命周期和activity生命周期很像，其生命周期方法如下所示。
onAttach：绑定到activity
onCreate：创建fragment
onCreateView： 创建fragment的布局
onActivityCreated： activity创建完成后
onStart： 可见, 不可交互
onResume： 可见, 可交互
onPause： 部分可见, 不可交互
onStop：不可见
onDestroyView： 销毁fragment的view对象
onDestroy： fragment销毁了
onDetach： 从activity解绑了

20.6. Fragment的向下兼容
Fragment是在Android 3.0才推出的，若想在3.0的低版本下使用Fragment，则需要执行下面2步：
1、 把所有Fragment和FragmentManager改成support-v4包下的类
2、 把Activity的继承改为FragmentActivity(support-v4包下的)
20.7. Fragment之间的通信案例
案例：创建一个用于显示选项卡的Fragment和一个用于显示内容的Fragment，当选项卡切换时，使内容的Fragment信息跟着一起切换。具体实现步骤如下所示：
1、 先创建选项卡Fragment和内容Fragment，并在activity_main.xml布局文件中进行设置，其布局效果如下：

2、 为选项卡Fragment创建布局文件，其布局效果如下：

3、 添加内容区域Fragment的代码逻辑
public class ContentFragment extends Fragment {
	private TextView tv_title;//标题
	private ImageView iv_pic;//内容
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		//使用打气筒填充布局
		View view = inflater.inflate(R.layout.fragment_content,null);
		//获取布局中的控件
		tv_title = (TextView) view.findViewById(R.id.tv_title);
		iv_pic = (ImageView) view.findViewById(R.id.iv_pic);
		return view;
	}
	//定义一个方法，用于改变标题和图片
	public void setTitleAndImage(String title,int picId){
		tv_title.setText(title);
		iv_pic.setImageResource(picId);
	}
}
4、 添加选项卡区域Fragment的代码逻辑
public class TabFragment extends Fragment implements OnItemClickListener {
	private String[] datas;
	private int[] picIds;
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		//直接使用ListView作为布局，因此不需要布局文件
		ListView listView = new ListView(getActivity());
		//定义一些常量数据作为册数数据
		datas = new String[]{"新闻","体育","财经","社会","娱乐","国际"};
		picIds = new int[]{R.drawable.a0,R.drawable.a1,R.drawable.a2,R.drawable.a3,R.drawable.a4,R.drawable.a5};
		//设置点击事件
		listView.setOnItemClickListener(this);
		//声明一个ArrayAdapter对象
		ArrayAdapter<String> adapter = new ArrayAdapter<String>(getActivity(), android.R.layout.simple_expandable_list_item_1, datas);
		//给ListView设置Adapter
		listView.setAdapter(adapter);
		//返回视图
		return listView;
	}
	@Override
	public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
		//获取当前的title和图片id
		String title = datas[position];
		int picId = picIds[position];
		//获取Fragment管理器
		FragmentManager manager = getFragmentManager();
		//通过ID选择出ContentFragment对象
		ContentFragment fragment = (ContentFragment) manager.findFragmentById(R.id.fragment_content);
		//调用ContentFragment的方法，给ContentFragment传递参数，实现不同Fragment直接的通信
		fragment.setTitleAndImage(title, picId);
	}
}
5、 运行程序，效果如下：

20.8. 结合工作和面试
1. 面试中
Fragment生命周期？
Fragment之间如何通信？
Fragment与Activity的区别？
百度下自己总结。
Fragment与Activity如何交互？
这里我不再详细介绍那写比较常规的方式，例如静态变量，静态方法，持久化，application全局变量，收发广播等等。

首先我们来介绍使用Handler来实现Fragment与Activity 的交互。第一步，我们需要在Activity中定义一个方法用来设置Handler对象。
public void setHandler(Handler handler) {
mHandler = handler;
}
第二步，在Fragment中的回调函数onAttach（）中得到Fragment所在Activity，并调用setHandler方法，设置Handler。该Handler在Fragment中定义，用来接收消息与Fragment进行交互。
@Override
public void onAttach(Activity activity) {
super.onAttach(activity);
mActivity = (MainActivity) activity;
mActivity.setHandler(mHandler);
}

public Handler mHandler = new Handler() {
public void handleMessage(android.os.Message msg) {
switch (msg.what) {
case 1:
text.setText((String) msg.obj);
break;
}
};
};
然后我们可以在Activity中发送消息给Fragment中的Hanlder进行交互。
public void inter(View view) {
Message msg = new Message();
msg.obj = edit.getText().toString();
msg.what = 1;
mHandler.sendMessage(msg);
}
21. 其他
21.1. 通知（★★★）
通知用于在状态栏显示消息，消息到来时以图标方式表示，如果需要查看消息，可以拖动状态栏到屏幕下方即可查看消息，在Android中通过通知管理器NotificationManager来发出或关闭一个通知。具体使用步骤如下所示。
1、 获取通知管理器对象
private NotificationManager manager;//通知管理器
//获取通知管理器服务
manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);
2、 如何发出一个通知
public void notify(View view) {
		// 创建一个通知
		Notification notification = new Notification(R.drawable.ic_launcher,// 消息的图标
				"您有一条来自尚学堂程序员的通知", // 消息的标题
				System.currentTimeMillis());// 消息发送的时刻 立即发送
		// 定义一个隐式意图：指定点击通知时要打开的Activity
		Intent intent = new Intent();
		intent.setAction("com.itheima.noftify");
		/*
		 * PendingIntent
		 * 是延时意图，在未来某个时间开启一个界面，并且可以指定使用的次数，其实就是对Intent进行的一个包装，并且指定了使用次数
		 */
	PendingIntent pendingIntent = PendingIntent.getActivity(this, 100, intent, PendingIntent.FLAG_ONE_SHOT);
		//设置消息的内容和意图
		notification.setLatestEventInfo(this, "这是详细通知的标题", "这是通知的详细内容", pendingIntent);
		//设置通知点击后自动关闭
		notification.flags = Notification.FLAG_AUTO_CANCEL;
		//设置消息发送时开启灯光、声音、震动等特效，如果震动开启了需要设置权限
		notification.defaults = Notification.DEFAULT_ALL;
		//发送通知，给该通知的id为1
		manager.notify(1, notification);
	}
3、 如何关闭通知
// 关闭通知
	public void close(View view) {
		//关闭id为1的通知
		manager.cancel(1);
	}
4、 通知的效果如下


点击通知，会跳转到指定页面。注意，若设置了弹出通知会有声音/震动/亮灯的效果，注意添加对应权限，否则会抛异常。比如，设置震动需加权限android.permission.VIBRATE。获取延期意图PendingIntent时，封装的意图对象必须采用隐式的方式。
21.2. 反编译（★）
Android打包好的APK如果直接解压缩，那么里面的布局文件和字节码文件如法直接使用，但是我们可以通过以下三个反编译工具对一个APK进行反编译。
apktool  反编译布局文件, 反编译之后会在apk相同的目录下创建一个
命令：apktool d xxx.apk
dex2jar 	把.dex文件转换成.jar的文件, 会在相同目录下生成一个
xxx.jar 
命令：dex2jar xxx.dex
jd-gui		查看jar文件
21.3. NinePatch（★）
21.3.1. 什么是NinePatch图片
	NinePatch是一种很有用的PNG图片文件夹格式，它可以在特定区域随文字大小进行缩放。

上图中背景图片的中间区域会随着文字的大小进行缩放背景图片就是一张NinePatch图片。
21.3.2. 如何制作NinePatch图片
NinePatch图片可以使用android自带的draw9patch工具来制作，该工具在SDK安装路径的tools目录下。
打开“sdk\tools\draw9patch.bat”，执行此工具然后点击“File”->“open 9-path”打开一张用于制作NinePatch图片的原图，通过在画布的四边画线来指定缩放区域和文字所在区域。
画布的左边和上边是控制图片拉伸的;画布的右边和底边是控制内容显示的区域的。使用鼠标左键点击拖动来画线，使用鼠标右键点击拖动才擦除线条。点击File，点击保存，就会生成后缀名为”.9.png”格式的图片。

21.3.3. 使用NinePatch图片做背景的效果
通过设置android:background="@drawable/bg"属性来设置背景图片，使用一般图片作为背景和使用NinePatch图片做背景的效果对比。

21.4. 手势识别(GestureOverlayView)

创建手势库
导入SDK中的工程
android-sdk-windows\samples\android-10\GestureBuilder。这个工程不能直接导入，需要添加三个配置文件：.classpath、.project、default.properties或者可以直接通过new-android project from existing code，创建工程。
将工程部署到手机中，创建手势库
手势库会存储在手机SD卡的根目录，文件名为：gestures
代码
将gestures放入res/raw文件夹下

<android.gesture.GestureOverlayView
    android:id="@+id/gov"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
android:gestureStrokeType="multiple" />
GestureOverlayView gov = (GestureOverlayView) findViewById(R.id.gov);
final GestureLibrary library = GestureLibraries.fromRawResource(this, R.raw.gestures);//加载手势库文件
library.load();
gov.addOnGesturePerformedListener(new OnGesturePerformedListener() {
	public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) {
		ArrayList<Prediction> list = library.recognize(gesture);
		for (Prediction p : list)
			System.out.println(p.name + ": " + p.score);
		//for外边，如果获取的第一个Prediction语言，的score大于4，则认为是已识别。
		//第一个是分数最大的，所以只去第一个即可。
			Prediction p=recognize.get(0);
				if(p.score>4){
					Toast.makeText(getApplicationContext(), p.name, Toast.LENGTH_SHORT).show();
				}else {
					Toast.makeText(getApplicationContext(), "未识别", Toast.LENGTH_SHORT).show();
				}
	}
});

21.5. 触摸事件
拖拽
XML配置
<ImageView
    android:id="@+id/image"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scaleType="matrix"
    android:src="@drawable/image" />
Java代码
public class MainActivity extends Activity {

	private ImageView imageView;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		imageView = (ImageView) findViewById(R.id.image);
		imageView.setOnTouchListener(new MyOnTouchListener());
	}

	private class MyOnTouchListener implements OnTouchListener {
		private float x;
		private float y;
		private Matrix currentMatrix = new Matrix();	// 用来操作图片的矩阵
		private Matrix oldMatrix = new Matrix();

		public boolean onTouch(View v, MotionEvent event) {
			switch (event.getAction()) {
				case MotionEvent.ACTION_DOWN: 			// 按下时
					x = event.getX(); 					// 获取x轴坐标
					y = event.getY();						// 获取y轴坐标
					oldMatrix.set(imageView.getImageMatrix());		// 记住位置
					break;
				case MotionEvent.ACTION_MOVE: 			// 移动时
					currentMatrix.set(oldMatrix); 		// 设置成按下时记住的位置
					currentMatrix.postTranslate(event.getX() - x, event.getY() - y);	// 改变位置
					break;
			}
			imageView.setImageMatrix(currentMatrix);	// 移动图片
			return true;
		}
	}

}
多点触摸
public class MainActivity extends Activity {

	private ImageView imageView;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		imageView = (ImageView) findViewById(R.id.image);
		imageView.setOnTouchListener(new MyOnTouchListener());
	}

	private class MyOnTouchListener implements OnTouchListener {
		private float x;		// 图片移动前的x轴坐标
		private float y;		// 图片移动前的y轴坐标
		private Matrix currentMatrix = new Matrix(); 	// 用来移动图片的矩阵
		private Matrix oldMatrix = new Matrix();		// 图片移动前的矩阵
		private int type;		// 操作类型, 一根手指触摸还是两根手指触摸
		private float start;	// 第二根手指按下时的距离
		private float end;		// 两根手指移动后的距离
		private PointF point;	// 放大时的中心点

		public boolean onTouch(View v, MotionEvent event) {
			switch (event.getAction() & MotionEvent.ACTION_MASK) {
				case MotionEvent.ACTION_DOWN:
					type = 1;
					x = event.getX();
					y = event.getY();
					oldMatrix.set(imageView.getImageMatrix());
					break;
				case MotionEvent.ACTION_MOVE:
					currentMatrix.set(oldMatrix);
					if (type == 1) { 	// 1根手指触摸
						currentMatrix.postTranslate(event.getX() - x, event.getY() - y);
					} else { 			// 2跟手指触摸
						end = countDistance(event); 	// 计算结束时距离
						float scale = end / start; 		// 计算缩放比例
						currentMatrix.postScale(scale, scale, point.x, point.y); 	// 设置缩放
					}
					break;
				case MotionEvent.ACTION_POINTER_DOWN:
					type = 2;
					start = countDistance(event); 		// 计算开始时距离
					point = countPoint(event); 			// 计算中心点
					oldMatrix.set(imageView.getImageMatrix());
					break;
			}
			imageView.setImageMatrix(currentMatrix); 	// 改变图片
			return true;
		}
	}

	public float countDistance(MotionEvent event) {
		float a = event.getX(1) - event.getX(0); 	// x轴距离
		float b = event.getY(1) - event.getY(0); 	// y轴距离
		return (float) Math.sqrt(a * a + b * b); 	// 勾股定理
	}
	public PointF countPoint(MotionEvent event) {
		float x = (event.getX(0) + event.getX(1)) / 2; 	
// x轴中间点
		float y = (event.getY(0) + event.getY(1)) / 2; 	
// y轴中间点
		return new PointF(x, y);
	}
}

21.6. 读取SIM卡
电话号码、运营商信息
需要权限
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
Java代码
TelephonyManager manager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
		System.out.println("电话号码: " + manager.getLine1Number());
		System.out.println("运营商编号: " + manager.getNetworkOperator());
		System.out.println("运营商名字: " + manager.getNetworkOperatorName());
联系人
需要权限
<uses-permission android:name="android.permission.READ_CONTACTS" />
<uses-permission android:name="android.permission.WRITE_CONTACTS" />
Java代码
Uri uri = Uri.parse("content://icc/adn");
		Cursor c = getContentResolver().query(uri, null, null, null, null);
		while (c.moveToNext())
System.out.println(c.getString(c.getColumnIndex("name")) + ": " + c.getString(c.getColumnIndex("number")));
通话记录
需要权限
<uses-permission android:name="android.permission.READ_CONTACTS" />
<uses-permission android:name="android.permission.WRITE_CONTACTS" />
Java代码
Uri uri = CallLog.Calls.CONTENT_URI;
		Cursor c = getContentResolver().query(uri, null, null, null, null);
		while (c.moveToNext())
	System.out.println(c.getString(c.getColumnIndex("number")) + ": " + c.getString(c.getColumnIndex("type")));
源代码
ContactsProvider\src\com\android\providers\contacts\ CallLogProvider.java
21.7. 安装程序
需要权限
<uses-permission android:name="android.permission.INSTALL_PACKAGES" />
Java代码
File file = new File(Environment.getExternalStorageDirectory(), "test.apk");
		Intent intent = new Intent();
		intent.setAction(Intent.ACTION_VIEW);
		intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive");
	startActivity(intent);
21.8. 关闭程序
杀死当前进程
Process.killProcess(Process.myPid());
退出模拟器
System.exit(0);
根据包名关闭后台进程
ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
manager.restartPackage("cn.itcast.test");
<uses-permission android:name="android.permission.RESTART_PACKAGES" />
21.9. 结合面试和工作
1. 面试中
反编译、9path
面试中有可能会被问到，你在工作中反编译过什么应用么？如何反编译？在工作中自己做9path图么，如何做？
手势识别，多点触控
这个以后在写简历时，大家有可能会写上，如果写了就需要熟练掌握。
2. 工作中
通知、反编译、9path图用的都比较多，需要掌握
通知知道如何使用，反编译要会反编译，不过一般都是混淆的项目，看不出来太多东西，不过可以看到一些布局，资源文件。
9path图，需要知道如何绘制。
手势识别、多点触控
这两点有可能会用到，所以需要了解。
