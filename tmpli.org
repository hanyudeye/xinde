* Chapter 4
      #include <stdio.h>
      #include <unistd.h>
      #define _GNU_SOURCE
      #include <getopt.h>
      int main(int argc, char *argv[])
      {
       int opt;
       struct option longopts[] = {
       {“initialize”, 0, NULL, ‘i’},
       {“file”, 1, NULL, ‘f’},
       {“list”, 0, NULL, ‘l’},
       {“restart”, 0, NULL, ‘r’},
       {0,0,0,0}};
       while((opt = getopt_long(argc, argv, “if:lr”, longopts, NULL)) != -1) {
       switch(opt) {
       case ‘i’:
       case ‘l’:
       case ‘r’:
       printf(“option: %c\n”, opt);
       break;
       case ‘f’:
       printf(“filename: %s\n”, optarg);
                      break;
                 case ‘:’:
                      printf(“option needs a value\n”);
                      break;
                 case ‘?’:
                      printf(“unknown option: %c\n”, optopt);
                      break;
                 }
           }
           for(; optind < argc; optind++)
                 printf(“argument: %s\n”, argv[optind]);
           exit(0);
       }
How It Works
  The getopt_long function takes two additional parameters over getopt. The first of these is an array
  of structures that describes the long options and tells getopt_long how to handle them. The second
  additional parameter is a pointer to a variable that can be used like a long option version of optind; for
  each long option recognized, its index in the long options array can be written into this variable. In our
  example, we do not need this information, so we use NULL as the second additional parameter.
  The long options array consists of a number of structures of type struct option, each of which describes
  the desired behavior of a long option. The array must end with a structure containing all zeros.
  The long option structure is defined in getopt.h and must be included with the constant _GNU_SOURCE,
  defined to enable the getopt_long functionality.
                   struct option {
                        const char *name;
                        int has_arg;
                        int *flag;
                        int val;
                   };
                                                                                                         141
Chapter 4
  The members of the structure are
      name                  The name of the long option. Abbreviations will be accepted as long as they
                            cannot be confused with other options.
      has_arg               Whether this option takes an argument. Set to 0 for options that do not take an
                            argument, 1 for options that must have a value, and 2 for those that have an
                            optional argument.
      flag                  Set to NULL to have getopt_long return the value given in val when this
                            option is found. Otherwise, getopt_long returns 0 and writes the value of
                            val into the variable pointed to by flag.
      val                   The value getopt_long is to return for this option.
  For other options associated with the GNU extensions to getopt and related functions, refer to the
  getopt manual page.
Environment Variables
  We discussed environment variables in Chapter 2. These are variables that can be used to control the
  behavior of shell scripts and other programs. You can also use them to configure the user’s environment.
  For example, each user has an environment variable, HOME, that defines his home directory, the default
  starting place for his or her session. As we’ve seen, we can examine environment variables from the shell
  prompt:
       $ echo $HOME
       /home/neil
  You can also use the shell’s set command to list all of the environment variables.
  The UNIX specification defines many standard environment variables used for a variety of purposes,
  including terminal type, default editors, time zones, and so on. A C program may gain access to environ-
  ment variables using the putenv and getenv functions.
       #include <stdlib.h>
       char *getenv(const char *name);
       int putenv(const char *string);
  The environment consists of strings of the form name=value. The getenv function searches the environ-
  ment for a string with the given name and returns the value associated with that name. It will return null
  if the requested variable doesn’t exist. If the variable exists but has no value, getenv succeeds with a string,
  the first byte of which is null. The string returned by getenv, and held in static storage provided by
  getenv, mustn’t be overwritten by the application, as it will by any subsequent calls to getenv.
  The putenv function takes a string of the form name=value and adds it to the current environment.
  It will fail and return -1 if it can’t extend the environment due to lack of available memory. When this
  happens, the error variable errno will be set to ENOMEM.
142
                                                                           The Linux Environment
  Let’s write a program to print out the value of any environment variable we choose. We’ll also arrange
  to set the value if we give the program a second argument.
Try It Out—getenv and putenv
     1. The first few lines after the declaration of main ensure that the program, environ.c, has been
            called correctly:
       #include <stdlib.h>
       #include <stdio.h>
       #include <string.h>
       int main(int argc, char *argv[])
       {
             char *var, *value;
             if(argc == 1 || argc > 3) {
                 fprintf(stderr,”usage: environ var [value]\n”);
                 exit(1);
             }
     2.     That done, we fetch the value of the variable from the environment, using getenv:
             var = argv[1];
             value = getenv(var);
             if(value)
                 printf(“Variable %s has value %s\n”, var, value);
             else
                 printf(“Variable %s has no value\n”, var);
     3.     Next, we check whether the program was called with a second argument. If it was, we set the
            variable to the value of that argument by constructing a string of the form name=value and
            then calling putenv:
             if(argc == 3) {
                 char *string;
                 value = argv[2];
                 string = malloc(strlen(var)+strlen(value)+2);
                 if(!string) {
                       fprintf(stderr,”out of memory\n”);
                       exit(1);
                 }
                 strcpy(string,var);
                 strcat(string,”=”);
                 strcat(string,value);
                 printf(“Calling putenv with: %s\n”,string);
                 if(putenv(string) != 0) {
                       fprintf(stderr,”putenv failed\n”);
                       free(string);
                       exit(1);
                 }
                                                                                                      143
Chapter 4
     4.    Finally, we discover the new value of the variable by calling getenv once again:
                 value = getenv(var);
                 if(value)
                      printf(“New value of %s is %s\n”, var, value);
                 else
                      printf(“New value of %s is null??\n”, var);
            }
            exit(0);
        }
  When we run this program, we can see and set environment variables:
       $ ./environ HOME
       Variable HOME has value /home/neil
       $ ./environ FRED
       Variable FRED has no value
       $ ./environ FRED hello
       Variable FRED has no value
       Calling putenv with: FRED=hello
       New value of FRED is hello
       $ ./environ FRED
       Variable FRED has no value
  Notice that the environment is local only to the program. Changes that we make within the program are
  not reflected outside it because variable values are not propagated from the child process (our program)
  to the parent (the shell).
Use of Environment Variables
  Programs often use environment variables to alter the way they work. Users can set the values of these
  environment variables either in their default environment, via a .profile file read by their login shell,
  using a shell-specific startup (rc) file, or by specifying variables on the shell command line. For example:
       $ ./environ FRED
       Variable FRED has no value
       $ FRED=hello ./environ FRED
       Variable FRED has value hello
  The shell takes initial variable assignments as temporary changes to environment variables. In the sec-
  ond example above, the program environ runs in an environment where the variable FRED has a value.
  For instance, in a future version of our CD database application, we could change an environment vari-
  able, say CDDB, to indicate the database to use. Each user could then specify his or her own default value
  or use a shell command to set it on a run-by-run basis:
       $ CDDB=mycds; export CDDB
       $ cdapp
  or
       $ CDDB=mycds cdapp
144
                                                                         The Linux Environment
         Environment variables are a mixed blessing and you should use them with care.
         They are more ‘hidden’ to the user than command line options and, as such, this can
         make debugging harder. In a sense, environment variables are like global variables
         in that they may alter the behavior of a program, giving unexpected results.
The environ Variable
  As we’ve seen, the program environment is made up of strings of the form name=value. This array of
  strings is made available to programs directly via the environ variable, which is declared as
       #include <stdlib.h>
       extern char **environ;
Try It Out—environ
  Here’s a program, showenv.c, that uses the environ variable to print out the environment variables:
       #include <stdlib.h>
       #include <stdio.h>
       extern char **environ;
       int main()
       {
            char **env = environ;
            while(*env) {
                printf(“%s\n”,*env);
                env++;
            }
            exit(0);
       }
  When we run this program on a Linux system, we get something like the following output, which has
  been abbreviated a little. The number, order of appearance, and values of these variables depend on the
  operating system version, the command shell being used, and the user settings in force at the time the
  program is run.
       $ ./showenv
       HOSTNAME=tilde.provider.com
       LOGNAME=neil
       MAIL=/var/spool/mail/neil
       TERM=console
       HOSTTYPE=i386
       PATH=/usr/local/bin:/bin:/usr/bin:
       HOME=/usr/neil
       LS_OPTIONS=—8bit—color=tty -F -T 0
                                                                                                      145
Chapter 4
       SHELL=/bin/bash
       PS1=\h:\w\$
       PS2=>
       OSTYPE=Linux
How It Works
  This program iterates through the environ variable, a null-terminated array of strings, to print out the
  whole environment.
Time and Date
  Often it can be useful for a program to be able to determine the time and date. It may wish to log the
  length of time it is run, or it may need to change the way it behaves at certain times. For example, a
  game might refuse to run during working hours, or a backup scheduling program might want to wait
  until the early hours before starting an automatic backup.
       UNIX systems all use the same starting point for times and dates: midnight GMT on January 1, 1970.
       This is the”start of the UNIX epoch” and Linux is no exception. All times in a Linux system are measured
       as seconds since then. This is similar to the way MS-DOS handles times, except that the MS-DOS epoch
       started in 1980. Other systems use other epoch start times.
  Times are handled using a defined type, a time_t. This is an integer type intended to be large enough
  to contain dates and times in seconds. On Linux systems, it’s a long integer and is defined, together
  with functions for manipulating time values, in the header file time.h.
          Never assume that times are 32 bits. On UNIX and Linux systems using a 32-bit
          time_t type, the time will “rollover” in the year 2038. By that time, we hope that
          systems have moved to using a time_t; that is, larger than 32 bits.
       #include <time.h>
       time_t time(time_t *tloc);
  You can find the low-level time value by calling the time function, which returns the number of seconds
  since the start of the epoch. It will also write the returned value to a location pointed to by tloc, if this
  isn’t a null pointer.
Try It Out—time
  Here’s a simple program, envtime.c, to demonstrate the time function:
       #include <time.h>
       #include <stdio.h>
       #include <unistd.h>
       int main()
       {
146
                                                                           The Linux Environment
            int i;
            time_t the_time;
            for(i = 1; i <= 10; i++) {
                 the_time = time((time_t *)0);
                 printf(“The time is %ld\n”, the_time);
                 sleep(2);
            }
            exit(0);
       }
  When we run this program, it prints the low-level time value every two seconds for 20 seconds.
       $ ./envtime
       The time is    1044695820
       The time is    1044695822
       The time is    1044695824
       The time is    1044695826
       The time is    1044695828
       The time is    1044695830
       The time is    1044695832
       The time is    1044695834
       The time is    1044695836
       The time is    1044695838
How It Works
  The program calls time with a null pointer argument, which returns the time and date as a number of
  seconds. The program sleeps for two seconds and repeats the call to time for a total of ten times.
  Using the time and date as a number of seconds since the start of 1970 can be useful for measuring how
  long something takes to happen. We could consider simply subtracting the values we get from two calls to
  time. However, in its deliberations, the ISO/ANSI C standard committee didn’t specify that the time_t
  type be used to measure arbitrary time intervals in seconds, so they invented a function, difftime, which
  will calculate the difference in seconds between two time_t values and return it as a double:
       #include <time.h>
       double difftime(time_t time1, time_t time2);
  The difftime function calculates the difference between two time values and returns the value time1-
  time2 as a floating-point number. For Linux, the return value from time is a number of seconds and can
  be manipulated, but for the ultimate in portability you should use difftime.
  To present the time and date in a more meaningful way (to humans), we need to convert the time value
  into a recognizable time and date. There are standard functions to help with this.
  The function gmtime breaks down a low-level time value into a structure containing more usual fields:
       #include <time.h>
       struct tm *gmtime(const time_t timeval);
                                                                                                       147
Chapter 4
  The structure tm is defined to contain at least the following members:
     tm Member                     Description
     int tm_sec                    Seconds, 0-61
     int tm_min                    Minutes, 0-59
     int tm_hour                   Hours, 0-23
     int tm_mday                   Day in the month, 1-31
     int tm_mon                    Month in the year, 0-11(January= 0)
     int tm_year                   Years since 1900
     int tm_wday)                  Day in the week, 0-6. (Sunday = 0)
     int tm_yday                   Day in the year, 0-365
     int tm_isdst                  Daylight savings in effect
  The range for tm_sec allows for the occasional leap second or double leap second.
Try It Out—gmtime
  Here’s a program, gmtime.c, which prints out the current time and date using the tm structure and
  gmtime:
       #include <time.h>
       #include <stdio.h>
       int main()
       {
           struct tm *tm_ptr;
           time_t the_time;
           (void) time(&the_time);
           tm_ptr = gmtime(&the_time);
           printf(“Raw time is %ld\n”, the_time);
           printf(“gmtime gives:\n”);
           printf(“date: %02d/%02d/%02d\n”,
                tm_ptr->tm_year, tm_ptr->tm_mon+1, tm_ptr->tm_mday);
           printf(“time: %02d:%02d:%02d\n”,
                tm_ptr->tm_hour, tm_ptr->tm_min, tm_ptr->tm_sec);
           exit(0);
       }
  When we run this program, we get a good approximation of the time and date:
       $ ./gmtime; date
       Raw time is 1044696004
       gmtime gives:
148
                                                                           The Linux Environment
       date: 103/02/08
       time: 09:20:04
       Sat Feb 8 09:20:04 GMT 2003
How It Works
  The program calls time to get the low-level time value and then calls gmtime to convert this into a struc-
  ture with useful time and date values. It prints these out using printf. Strictly speaking, we shouldn’t
  print the raw time value in this way because it isn’t guaranteed to be a long type on all systems. We ran
  the date command immediately after gmtime to compare its output.
  However, we have a little problem here. If you’re running this program in a time zone other than
  Greenwich Mean Time, or if your local daylight savings time is in effect, you’ll notice that the time
  (and possibly date) is incorrect. This is because gmtime returns the time as GMT (now known as
  Coordinated Universal Time, or UTC). Linux and UNIX do this so that all programs and systems across
  the world are synchronized. Files created at the same moment in different time zones will appear to
  have the same creation time. To see the local time, we need to use the function localtime instead.
       #include <time.h>
       struct tm *localtime(const time_t *timeval);
  The localtime function is identical to gmtime, except that it returns a structure containing values
  adjusted for local time zone and daylight savings. If you try the gmtime program again, but use local-
  time in place of gmtime, you should see a correct time and date reported.
  To convert a broken-down tm structure into a raw time_t value, we can use the function mktime:
       #include <time.h>
       time_t mktime(struct tm *timeptr);
  mktime will return -1 if the structure can’t be represented as a time_t value.
  For “friendly,” as opposed to machine, time, and date output provided by the date program, we can use
  the functions asctime and ctime:
       #include <time.h>
       char *asctime(const struct tm *timeptr);
       char *ctime(const time_t *timeval);
  The asctime function returns a string that represents the time and date given by the tm structure
  timeptr. The string returned has a format similar to
       Sun Jun    6 12:30:34 1999\n\0
  It’s always a fixed format, 26 characters long. The function ctime is equivalent to calling
       asctime(localtime(timeval))
  It takes a raw time value and converts it to a more readable local time.
                                                                                                        149
Chapter 4
Try It Out—ctime
  Let’s see ctime in action, using the following code:
       #include <time.h>
       #include <stdio.h>
       int main()
       {
            time_t timeval;
            (void)time(&timeval);
            printf(“The date is: %s”, ctime(&timeval));
            exit(0);
       }
  Compile and run the surprisingly named ctime.c and you should see
       $ ./ctime
       The date is: Sat Feb       8 09:21:17 2003
How It Works
  The ctime.c program calls time to get the low-level time value and lets ctime do all the hard work,
  converting it to a readable string, which it then prints.
  To gain more control of the exact formatting of time and date strings, Linux and modern UNIX-like sys-
  tems provide the strftime function. This is rather like a sprintf for dates and times and works in a
  similar way:
       #include <time.h>
       size_t strftime(char *s, size_t maxsize, const char *format, struct tm *timeptr);
  The strftime function formats the time and date represented by the tm structure pointed to by
  timeptr and places the result in the string s. This string is specified as (at least) maxsize characters
  long. The format string is used to control the characters written to the string. Like printf, it contains
  ordinary characters that will be transferred to the string and conversion specifiers for formatting time
  and date elements. The conversion specifiers include
     Conversion Specifier                 Description
     %a                                   Abbreviated weekday name
     %A                                   Full weekday name
     %b                                   Abbreviated month name
     %B                                   Full month name
     %c                                   Date and time
     %d                                   Day of the month, 01-31
150
                                                                            The Linux Environment
   Conversion Specifier                 Description
   %H                                   Hour, 00-23
   %I                                   Hour in 12-hour clock, 01-12
   %j                                   Day of the year, 001-366
   %m                                   Month of the year, 01-12
   %M                                   Minutes, 00-59
   %p                                   a.m. or p.m.
   %S                                   Seconds, 00-61
   %u                                   Day in the week, 1-7 (1 = Monday)
   %U                                   Week in the year, 01-53 (Sunday is the first day of the week.)
   %V                                   Week in the year, 01-53 (Monday is the first day of the week.)
   %w                                   Day in the week, 0-6 (0 = Sunday)
   %x                                   Date in local format
   %X                                   Time in local format
   %y                                   Year number less 1900
   %Y                                   Year
   %Z                                   Time zone name
   %%                                   A % character
So, the usual date as given by the date program corresponds to a strftime format string of
     “%a %b %d %H:%M:%S %Y”
To help with reading dates, we can use the strptime function, which takes a string representing a date
and time and creates a tm structure representing the same date and time:
     #include <time.h>
     char *strptime(const char *buf, const char *format, struct tm *timeptr);
The format string is constructed in exactly the same way as the format string for strftime. strptime
acts in a similar way to sscanf in that it scans a string, looking for identifiable fields, and writes them
into variables. Here it’s the members of a tm structure that are filled in according to the format string.
However, the conversion specifiers for strptime are a little more relaxed than those for strftime
because strptime will allow both abbreviated and full names for days and months. Either representation
will match a %a specifier in strptime. Also, where strftime always uses leading zeros on numbers less
than 10, strptime regards them as optional.
                                                                                                           151
Chapter 4
  strptime returns a pointer to the character following the last one consumed in the conversion process.
  If it encounters characters that can’t be converted, the conversion simply stops at that point. The calling
  program needs to check that enough of the passed string has been consumed to ensure that meaningful
  values are written to the tm structure.
Try It Out—strftime and strptime
  Have a look at the selection of conversion specifiers used in the following program:
        #include <time.h>
        #include <stdio.h>
        int main()
        {
            struct tm *tm_ptr, timestruct;
            time_t the_time;
            char buf[256];
            char *result;
            (void) time(&the_time);
            tm_ptr = localtime(&the_time);
            strftime(buf, 256, “%A %d %B, %I:%S %p”, tm_ptr);
            printf(“strftime gives: %s\n”, buf);
            strcpy(buf,”Sat 26 July 2003, 17:53 will do fine”);
            printf(“calling strptime with: %s\n”, buf);
            tm_ptr = &timestruct;
            result = strptime(buf,”%a %d %b %Y, %R”, tm_ptr);
            printf(“strptime consumed up to: %s\n”, result);
            printf(“strptime gives:\n”);
            printf(“date: %02d/%02d/%02d\n”,
                 tm_ptr->tm_year % 100, tm_ptr->tm_mon+1, tm_ptr->tm_mday);
            printf(“time: %02d:%02d\n”,
                 tm_ptr->tm_hour, tm_ptr->tm_min);
            exit(0);
        }
  When we compile and run this program, strftime.c, we get
        $ ./strftime
        strftime gives: Sunday 06 June, 11:55 AM
        calling strptime with: Sat 26 July 2003, 17:53 will do fine
        strptime consumed up to: will do fine
        strptime gives:
        date: 03/07/26
        time: 17:53
152
                                                                             The Linux Environment
How It Works
  The strftime program obtains the current local time by calling time and localtime. It then converts
  it to a readable form by calling strftime with an appropriate formatting argument. To demonstrate the
  use of strptime, the program sets up a string containing a date and time, then calls strptime to extract
  the raw time and date values, and prints them. The conversion specifier %R is a shortcut for %H:%M in
  strptime.
  It’s important to note that strptime needs an accurate format string to successfully scan a date.
  Typically, it won’t accurately scan dates read from users unless the format is very much restricted.
  It is possible that you will find the compiler issuing a warning when you compile strftime.c. This is
  because the GNU library does not by default declare strptime. The fix for this is to explicitly request
  X/Open standard features by adding the following line before including time.h:
        #define _XOPEN_SOURCE
Temporar y Files
  Often, programs will need to make use of temporary storage in the form of files. These might hold inter-
  mediate results of a computation or represent backup copies of files made before critical operations. For
  example, a database application could use a temporary file when deleting records. The file collects the
  database entries that need to be retained, and then, at the end of the process, the temporary file becomes
  the new database and the original is deleted.
  This popular use of temporary files has a hidden disadvantage. You must take care to ensure that the
  applications choose a unique filename to use for the temporary file. If this doesn’t happen, because
  Linux is a multitasking system, another program could choose the same name and the two will interfere
  with each other.
  A unique filename can be generated by the tmpnam function:
        #include <stdio.h>
        char *tmpnam(char *s);
  The tmpnam function returns a valid filename that isn’t the same as any existing file. If the string s isn’t
  null, the filename will also be written to it. Further calls to tmpnam will overwrite the static storage
  used for return values, so it’s essential to use a string parameter if tmpnam is to be called many times.
  The string is assumed to be at least L_tmpnam characters long. tmpnam can be called up to TMP_MAX
  times in a single program, and it will generate a different filename each time.
  If the temporary file is to be used immediately, you can name it and open it at the same time using the
  tmpfile function. This is important because another program could create a file with the same name as
  that returned by tmpnam. The tmpfile function avoids this problem altogether:
        #include <stdio.h>
        FILE *tmpfile(void);
                                                                                                          153
Chapter 4
  The tmpfile function returns a stream pointer that refers to a unique temporary file. The file is opened
  for reading and writing (via fopen with w+), and it will be automatically deleted when all references to
  the file are closed.
  tmpfile returns a null pointer and sets errno on error.
Try It Out—tmpnam and tmpfile
  Let’s see these two functions in action:
       #include <stdio.h>
       int main()
       {
             char tmpname[L_tmpnam];
             char *filename;
             FILE *tmpfp;
             filename = tmpnam(tmpname);
             printf(“Temporary file name is: %s\n”, filename);
             tmpfp = tmpfile();
             if(tmpfp)
                  printf(“Opened a temporary file OK\n”);
             else
                  perror(“tmpfile”);
             exit(0);
       }
  When we compile and run this program, tmpnam.c, we can see the unique filename generated by tmpnam:
       $ ./tmpnam
       Temporary file name is: /tmp/file2S64zc
       Opened a temporary file OK
How It Works
  The program calls tmpnam to generate a unique filename for a temporary file. If we wanted to use it, we
  would have to open it quickly to minimize the risk that another program would open a file with the
  same name. The tmpfile call creates and opens a temporary file at the same time, thus avoiding this
  risk. In fact, the GNU C compiler may give a warning about the use of tmpnam when compiling a pro-
  gram that uses it.
  Older versions of UNIX have another way to generate temporary filenames using the functions mktemp
  and mkstemp. These are supported by Linux and are similar to tmpnam, except that you can specify a
  template for the temporary filename, which gives you a little more control over their location and name:
       #include <stdlib.h>
       char *mktemp(char *template);
       int mkstemp(char *template);
154
                                                                              The Linux Environment
 The mktemp function creates a unique filename from the given template. The template argument must
 be a string with six trailing X characters. The mktemp function replaces these X characters with a unique
 combination of valid filename characters. It returns a pointer to the generated string or a null pointer if it
 couldn’t generate a unique name.
 The mkstemp function is similar to tmpfile in that it creates and opens a temporary file. The filename is
 generated in the same way as mktemp, but the returned result is an open, low-level file descriptor.
 In general, you should use the “create and open” functions tmpfile and mkstemp rather than tmpnam
 and mktemp.
User Information
 All Linux programs, with the notable exception of init, are started by other programs or users. We’ll learn
 more about how running programs, or processes, interact in Chapter 11. Users most often start programs
 from a shell that responds to their commands. We’ve seen that a program can determine a great deal about
 its environment by examining environment variables and reading the system clock. A program can also
 find out information about the person using it.
 When a user logs into a Linux system, he or she has a username and password. Once these have been
 validated, the user is presented with a shell. Internally, the user also has a unique user identifier known
 as a UID. Each program that Linux runs is run on behalf of a user and has an associated UID.
 You can set up programs to run as if a different user had started them. When a program has its UID per-
 mission set, it will run as if started by the owner of the executable file. When the su command is executed,
 the program runs as if it had been started by the superuser. It then validates the user’s access, changes the
 UID to that of the target account, and executes that account’s login shell. This also allows a program to be
 run as if a different user had started it and is often used by system administrators to perform maintenance
 tasks.
 Since the UID is key to the user’s identity, let’s start with that.
 The UID has its own type—uid_t—defined in sys/types.h. It’s normally a small integer. Some are
 predefined by the system; others are created by the system administrator when new users are made
 known to the system. Normally, users usually have UID values larger than 100.
      #include <sys/types.h>
      #include <unistd.h>
      uid_t getuid(void);
      char *getlogin(void);
 The getuid function returns the UID with which the program is associated. This is usually the UID of
 the user who started the program.
 The getlogin function returns the login name associated with the current user.
                                                                                                          155
Chapter 4
  The system file /etc/passwd contains a database dealing with user accounts. It consists of lines, one per
  user, that contain the username, encrypted password, user identifier (UID), group identifier (GID), full
  name, home directory, and default shell. Here’s an example line:
       neil:zBqxfqedfpk:500:100:Neil Matthew:/home/neil:/bin/bash
  If we write a program that determines the UID of the user who started it, we could extend it to look in the
  password file to find out the user’s login name and full name. We don’t recommend this because modern
  UNIX-like systems are moving away from using simple password files to improve system security. Many
  systems, including Linux, have the option to use shadow password files that don’t contain any useful
  encrypted password information at all (this is often held in /etc/shadow, a file that ordinary users can-
  not read). For this reason, a number of functions have been defined to provide a standard and effective
  programming interface to this user information:
       #include <sys/types.h>
       #include <pwd.h>
       struct passwd *getpwuid(uid_t uid);
       struct passwd *getpwnam(const char *name);
  The password database structure, passwd, defined in pwd.h includes the following members:
     passwd Member                      Description
     char *pw_name                      The user’s login name
     uid_t pw_uid                       The UID number
     gid_t pw_gid                       The GID number
     char *pw_dir                       The user’s home directory
     char *pw_gecos                     The user’s full name
     char *pw_shell                     The user’s default shell
  Some UNIX systems may use a different name for the field for the user’s full name: on some systems, it’s
  pw_gecos, as on Linux, and on others, it’s pw_comment. This means that we can’t recommend its use.
  The getpwuid and getpwnam functions both return a pointer to a passwd structure corresponding to a
  user. The user is identified by UID for getpwuid and by login name for getpwnam. They both return a
  null pointer and set errno on error.
Try It Out—User Information
  Here’s a program, user.c, which extracts some user information from the password database:
       #include   <sys/types.h>
       #include   <pwd.h>
       #include   <stdio.h>
       #include   <unistd.h>
156
                                                                                 The Linux Environment
       int main()
       {
             uid_t uid;
             gid_t gid;
             struct passwd *pw;
             uid = getuid();
             gid = getgid();
             printf(“User is %s\n”, getlogin());
             printf(“User IDs: uid=%d, gid=%d\n”, uid, gid);
             pw = getpwuid(uid);
             printf(“UID passwd entry:\n name=%s, uid=%d, gid=%d, home=%s, shell=%s\n”,
                  pw->pw_name, pw->pw_uid, pw->pw_gid, pw->pw_dir, pw->pw_shell);
             pw = getpwnam(“root”);
             printf(“root passwd entry:\n”);
             printf(“name=%s, uid=%d, gid=%d, home=%s, shell=%s\n”,
                  pw->pw_name, pw->pw_uid, pw->pw_gid, pw->pw_dir, pw->pw_shell);
             exit(0);
       }
  It gives the following output, which may differ in minor respects between versions of Linux and UNIX:
       $ ./user
       User is neil
       User IDs: uid=500, gid=100
       UID passwd entry:
         name=neil, uid=500, gid=100, home=/home/neil, shell=/bin/bash
       root passwd entry:
       name=root, uid=0, gid=0, home=/root, shell=/bin/bash
How It Works
  This program calls getuid to obtain the UID of the current user. This UID is used in getpwuid to obtain
  detailed password file information. As an alternative, we show how the username root can be given to
  getpwnam to obtain user information.
       If you take a look at the Linux source code, you can see another example of using getuid in the id
       command.
  To scan all the password file information, we can use the getpwent function. This fetches successive file
  entries:
       #include <pwd.h>
       #include <sys/types.h>
       void endpwent(void);
       struct passwd *getpwent(void);
       void setpwent(void);
                                                                                                          157
Chapter 4
  The getpwent function returns each user information entry in turn. When none remain, it returns a null
  pointer. We can use the endpwent function to terminate processing once sufficient entries have been
  scanned. The setpwent function resets the position in the password file to the start so that a new scan
  can be started with the next call to getpwent. These functions operate in a similar way to the directory
  scanning functions opendir, readdir, and closedir that we discussed in Chapter 3.
  User and group identifiers (effective and actual) can be obtained by other, less commonly used functions:
       #include <sys/types.h>
       #include <unistd.h>
       uid_t geteuid(void);
       gid_t getgid(void);
       gid_t getegid(void);
       int setuid(uid_t uid);
       int setgid(gid_t gid);
  You should refer to the system manual pages for details on group identifiers and effective user identi-
  fiers, although you’ll probably find that you won’t need to manipulate these at all.
          Only the superuser may call setuid and setgid.
Host Information
  Just as it can determine information about the user, a program can also establish some details about the com-
  puter on which it’s running. The uname(1) command provides such information. uname(2) also exists as a
  system call to provide the same information within a C program—check it out using man 2 uname.
  Host information can be useful in a number of situations. We might wish to customize a program’s
  behavior, depending on the name of the machine it’s running on in a network, say, a student’s machine
  or an administrator’s. For licensing purposes, we might wish to restrict a program to running on one
  machine only. All this means that we need a way to establish which machine the program is running on.
  If the system has networking components installed, we can obtain its network name very easily with the
  gethostname function:
       #include <unistd.h>
       int gethostname(char *name, size_t namelen);
  The gethostname function writes the machine’s network name into the string name. This string is
  assumed to be at least namelen characters long. gethostname returns 0 if successful and -1 otherwise.
  You can obtain more detailed information about the host computer from the uname system call:
       #include <sys/utsname.h>
       int uname(struct utsname *name);
158
                                                                         The Linux Environment
  The uname function writes host information into the structure pointed to by the name parameter. The
  utsname structure, defined in sys/utsname.h, must contain at least these members:
     utsname Member                    Description
     char sysname[]                    The operating system name
     char nodename[]                   The host name
     char release[]                    The release level of the system
     char version[]                    The version number of the system
     char machine[]                    The hardware type
  uname returns a nonnegative integer on success, -1 otherwise, with errno set to indicate any error.
Try It Out—Host Information
  Here’s a program, hostget.c, which extracts some host computer information:
       #include <sys/utsname.h>
       #include <unistd.h>
       #include <stdio.h>
       int main()
       {
            char computer[256];
            struct utsname uts;
            if(gethostname(computer, 255) != 0 || uname(&uts) < 0) {
                 fprintf(stderr, “Could not get host information\n”);
                 exit(1);
            }
            printf(“Computer host name is %s\n”, computer);
            printf(“System is %s on %s hardware\n”, uts.sysname, uts.machine);
            printf(“Nodename is %s\n”, uts.nodename);
            printf(“Version is %s, %s\n”, uts.release, uts.version);
            exit(0);
       }
  It gives the following Linux-specific output. If your machine is networked, you may see an extended
  host name that includes the network:
       $ ./hostget
       Computer host name is beast
       System is Linux on i686 hardware
       Nodename is beast
       Version is 2.4.19-4GB, #1 Wed Nov 27 00:56:40 UTC 2002
                                                                                                      159
Chapter 4
How It Works
  This program calls gethostname to obtain the network name of the host computer. In the preceding
  examples, it gets the name tilde. More detailed information about this Intel Pentium-II-based Linux
  computer is returned by the call to uname. Note that the format of the strings returned by uname is
  implementation-dependent; in the example, the version string contains the date that the kernel was
  compiled.
       For another example of the use of the uname function, have a look at the Linux source code for the
       uname command, which uses it.
  A unique identifier for each host computer may be available from the gethostid function:
       #include <unistd.h>
       long gethostid(void);
  The gethostid function is intended to return a unique value for the host computer. License managers
  use this to ensure that software programs can run only on machines that hold valid licenses. On Sun
  workstations, it returns a number that is set in non-volatile memory when the computer is built, and so,
  is unique to the system hardware.
  Other systems, such as Linux, return a value based on the Internet address of the machine, which isn’t
  usually secure enough to be used for licensing.
Logging
  Many applications need to record their activities. System programs very often will write messages to the
  console, or a log file. These messages might indicate errors, warnings, or more general information about
  the state of the system. For example, the su program might record the fact that a user has tried and
  failed to gain superuser privileges.
  Very often, these log messages are recorded in system files in a directory made available for that purpose.
  This might be /usr/adm or /var/log. On a typical Linux installation, the file /var/log/messages
  contains all system messages, /var/log/mail contains other log messages from the mail system, and
  /var/log/debug may contain debug messages. You can check your system’s configuration in the
  /etc/syslog.conf file.
  Here are some sample log messages:
       Feb 8 08:38:37       beast kernel: klogd 1.4.1, log source = /proc/kmsg started.
       Feb 8 08:38:37       beast kernel: Inspecting /boot/System.map-2.4.19-4GB
       Feb 8 08:38:37       beast kernel: Loaded 20716 symbols from /boot/System.map-
       2.4.19-4GB.
       Feb 8 08:38:37       beast kernel: Symbols match kernel version 2.4.19.
       Feb 8 08:38:37       beast kernel: Loaded 372 symbols from 17 modules.
       Feb 8 08:38:37 beast kernel: Linux Tulip driver version 0.9.15-pre11 (May 11,
       2002)
160
                                                                            The Linux Environment
     Feb 8 08:38:37 beast kernel: PCI: Found IRQ 5 for device 00:0d.0
     Feb 8 08:38:37 beast kernel: eth0: ADMtek Comet rev 17 at 0xe400,
     00:04:5A:5F:46:52, IRQ 5.
     ...
     Feb     8 08:39:20 beast /usr/sbin/cron[932]: (CRON) STARTUP (fork ok)
     Feb     8 09:50:35 beast su: (to root) neil on /dev/pts/4
Here, we can see the sort of messages that are logged. The first few are reported by the Linux kernel
itself as it boots and detects installed hardware. The task scheduler, cron, reports that it’s starting up.
Finally, the su program reports a superuser account access by user neil.
     You may require superuser privilege to view log messages.
Some UNIX systems don’t provide a readable messages file in this way, but do provide the administra-
tor with tools to read a database of system events. Refer to your system documentation for details.
Even though the format and storage of system messages may vary, the method of producing the mes-
sages is standard. The UNIX specification provides an interface for all programs to produce logging
messages using the syslog function:
     #include <syslog.h>
     void syslog(int priority, const char *message, arguments...);
The syslog function sends a logging message to the logging facility. Each message has a priority
argument that is a bitwise OR of a severity level and a facility value. The severity level controls how the
log message is acted upon and the facility value records the originator of the message.
Facility values (from syslog.h) include LOG_USER, used to indicate that the message has come from a
user application, (the default), and LOG_LOCAL0, LOG_LOCAL1, up to LOG_LOCAL7, which can be
assigned meanings by the local administrator.
The severity levels in descending order of priority are
   Priority Level                      Description
   LOG_EMERG                           An emergency situation
   LOG_ALERT                           High-priority problem, such as database corruption
   LOG_CRIT                            Critical error, such as hardware failure
   LOG_ERR                             Errors
   LOG_WARNING                         Warning
   LOG_NOTICE                          Special conditions requiring attention
   LOG_INFO                            Informational messages
   LOG_DEBUG                           Debug messages
                                                                                                         161
Chapter 4
  Depending on system configuration, LOG_EMERG messages might be broadcast to all users, LOG_ALERT
  messages might be mailed to the administrator, LOG_DEBUG messages might be ignored, and the others
  written to a messages file. We can write a program that uses the logging facility simply by calling syslog
  when we wish to create a log message.
  The log message created by syslog consists of a message header and a message body. The header is cre-
  ated from the facility indicator and the date and time. The message body is created from the message
  parameter to syslog, which acts like a printf format string. Further arguments to syslog are used
  according to printf style conversion specifiers in the message string. Additionally, the specifier %m may
  be used to insert the error message string associated with the current value of the error variable, errno.
  This can be useful for logging error messages.
Try It Out—syslog
  In this program, we try to open a nonexistent file:
       #include <syslog.h>
       #include <stdio.h>
       int main()
       {
            FILE *f;
            f = fopen(“not_here”,”r”);
            if(!f)
                  syslog(LOG_ERR|LOG_USER,”oops - %m\n”);
            exit(0);
       }
  When we compile and run this program, syslog.c, we see no output, but the file /var/log/messages
  now contains the following line at the end:
       Feb   8 09:59:14 beast syslog: oops - No such file or directory
How It Works
  In this program, we try to open a file that doesn’t exist. When this fails, we call syslog to record the fact
  in the system logs.
  Notice that the log message doesn’t indicate which program called the log facility; it just records the fact
  that syslog was called with a message. The %m conversion specifier has been replaced by a description
  of the error, in this case, that the file couldn’t be found. This is more useful than just reporting the raw
  error number.
  Other functions used to alter the behavior of logging facilities are also defined in syslog.h. These are:
       #include <syslog.h>
       void closelog(void);
       void openlog(const char *ident, int logopt, int facility);
       int setlogmask(int maskpri);
162
                                                                                 The Linux Environment
  We can alter the way that our log messages are presented by calling the openlog function. This allows
  us to set up a string, ident, which will be pre-pended to our log messages. We can use this to indicate
  which program is creating the message. The facility parameter records a default facility value to be
  used for future calls to syslog. The default is LOG_USER. The logopt parameter configures the behavior
  of future calls to syslog. It’s a bitwise OR of zero or more of the following:
     logopt Parameter                    Description
     LOG_PID                             Includes the process identifier, a unique number allocated to each
                                         process by the system, in the messages.
     LOG_CONS                            Sends messages to the console if they can’t be logged.
     LOG_ODELAY                          Opens the log facility at first call to .
     LOG_NDELAY                          Opens the log facility immediately, rather than at first log.
  The openlog function will allocate and open a file descriptor that will be used for writing to the logging
  facility. You can close this by calling the closelog function. Note that you don’t need to call openlog
  before calling syslog because syslog will open the logging facility itself if required.
  We can control the priority level of our log messages by setting a log mask using setlogmask. All future
  calls to syslog with priority levels not set in the log mask will be rejected, so you could, for example,
  use this to turn off LOG_DEBUG messages without having to alter the body of the program.
  We can create the mask for log messages using LOG_MASK(priority), which creates a mask consisting
  of just one priority level, or LOG_UPTO(priority), which creates a mask consisting of all priorities up to
  and including the specified priority.
Try It Out—logmask
  In this example, we’ll see logmask in action:
       #include <syslog.h>
       #include <stdio.h>
       #include <unistd.h>
       int main()
       {
             int logmask;
             openlog(“logmask”, LOG_PID|LOG_CONS, LOG_USER);
             syslog(LOG_INFO,”informative message, pid = %d”, getpid());
             syslog(LOG_DEBUG,”debug message, should appear”);
             logmask = setlogmask(LOG_UPTO(LOG_NOTICE));
             syslog(LOG_DEBUG,”debug message, should not appear”);
             exit(0);
       }
                                                                                                          163
Chapter 4
  This logmask.c program produces no output, but on a typical Linux system, toward the end of
  /var/log/messages, we should see the following line:
       Feb   8 10:00:50 beast logmask[1833]: informative message, pid = 1833
  The file that is configured to receive debug log entries (depending on logging configuration, this is often
  the file /var/log/debug or sometimes /var/log/messages) should contain the following line:
       Feb   8 10:00:50 beast logmask[1833]: debug message, should appear
How It Works
  The program initializes the logging facility with its name, logmask, and requests that log messages con-
  tain the process identifier. The informative message is logged to /var/log/messages, and the debug
  message to /var/log/debug. The second debug message doesn’t appear because we call setlogmask
  to ignore all messages with a priority below LOG_NOTICE. (Note that this may not work on early Linux
  kernels.)
  If your installation does not have debug message logging enabled, or it is configured differently, you
  may not see the debug messages appear. To enable all debug messages, add the following line to the end
  of /etc/syslog.conf and reboot. (You could also just send a hang-up signal to the syslogd process.)
  However, be sure to check your system documentation for the exact configuration details.
       *.debug        /var/log/debug
  logmask.c uses the getpid function, which is defined along with the closely related getppid as follows
       #include <sys/types.h>
       #include <unistd.h>
       pid_t getpid(void);
       pid_t getppid(void);
  The functions return the process and parent process identifiers of the calling process. For more informa-
  tion on PIDs, see Chapter 11.
Resources and Limits
  Programs running on a Linux system are subject to resource limitations. These might be physical limits
  imposed by hardware (such as memory), limits imposed by system policies (for example, allowed CPU
  time), or implementation limits (such as the size of an integer or the maximum number of characters
  allowed in a filename). The UNIX specification defines some of these limits that can be determined by
  an application. See Chapter 7 for a further discussion of limits and the consequences of breaking them.
164
                                                                            The Linux Environment
The header file limits.h defines many manifest constants that represent the constraints imposed by the
operating system. These include
   Limit Constant                   What They’re For
   NAME_MAX                         The maximum number of characters in a filename
   CHAR_BIT                         The number of bits in a char value
   CHAR_MAX                         The maximum char value
   INT_MAX                          The maximum int value
There will be many others that may be of use to an application, so you should refer to your installation’s
header files.
     Note that NAME_MAX is file-system specific. For more portable code, you should use the pathconf
     function. Refer to the manual pages on pathconf for more information.
The header file sys/resource.h provides definitions for resource operations. These include functions
for determining and setting limits on a program’s allowed size, execution priority, and file resources:
     #include <sys/resource.h>
     int  getpriority(int which, id_t who);
     int  setpriority(int which, id_t who, int priority);
     int  getrlimit(int resource, struct rlimit *r_limit);
     int  setrlimit(int resource, const struct rlimit *r_limit);
     int  getrusage(int who, struct rusage *r_usage);
id_t is an integral type used for user and group identifiers. The rusage structure, defined in
sys/resource.h, is used to determine how much CPU time has been used by the current program.
It must contain at least these members:
   rusage Member                                   Description
   struct timeval ru_utime                         The user time used
   struct timeval ru_stime                         The system time used
The timeval structure is defined in sys/time.h and contains fields tv_sec and tv_usec, representing
seconds and microseconds, respectively.
CPU time consumed by a program is separated into user time (the time that the program itself has con-
sumed executing its own instructions) and system time (the CPU time consumed by the operating system
on the program’s behalf; that is, the time spent in system calls performing input and output or other sys-
tem functions).
                                                                                                      165
Chapter 4
  The getrusage function writes CPU time information to the rusage structure pointed to by the param-
  eter r_usage. The who parameter can be one of the following constants:
     who Constant                          Description
     RUSAGE_SELF                           Returns usage information about current program only.
     RUSAGE_CHILDREN                       Includes usage information of child processes as well.
  We discuss child processes and task priorities in Chapter 11, but for completeness, we’ll cover their impli-
  cations for system resources here. For now, it’s enough to say that each program that’s running has a pri-
  ority associated with it, and that higher priority programs are allocated more of the available CPU time.
       Ordinary users are only able to reduce the priorities of their programs, not increase them.
  Applications can determine and alter their (and others’) priority with the getpriority and setprior-
  ity functions. The process to be examined or changed by the priority functions can be identified either
  by process identifier, group identifier, or user. The which parameter specifies how the who parameter is
  to be treated.
     which Parameter                       Description
     PRIO_PROCESS                          who is a process identifier.
     PRIO_PGRP                             who is a process group.
     PRIO_USER                             who is a user identifier.
  So, to determine the priority of the current process, we might call
       priority = getpriority(PRIO_PROCESS, getpid());
  The setpriority function allows a new priority to be set, if possible.
  The default priority is 0. Positive priorities are used for background tasks that run when no other higher
  priority task is ready to run. Negative priorities cause a program to run more frequently, taking a larger
  share of the available CPU time. The range of valid priorities is -20 to +20. This is often confusing
  because the higher the numerical value, the lower the execution precedence.
  getpriority returns a valid priority if successful or a -1 with errno set on error. Because -1 is itself a
  valid priority, errno should be set to zero before calling getpriority and checked that it’s still zero on
  return. setpriority returns 0 if successful, -1 otherwise.
  Limits on system resources can be read and set by getrlimit and setrlimit. Both of these
  functions make use of a general purpose structure, rlimit, to describe resource limits. It’s defined
  in sys/resource.h and has the following members:
166
                                                                            The Linux Environment
      rlimit Member                       Description
      rlim_t rlim_cur                     The current, soft limit
      rlim_t rlim_max                     The hard limit
  The defined type rlim_t is an integral type used to describe resource levels. Typically, the soft limit is
  an advisory limit that shouldn’t be exceeded; doing so may cause library functions to return errors. The
  hard limit, if exceeded, may cause the system to attempt to terminate the program by sending a signal to
  it. Examples would be the signal SIGXCPU on exceeding the CPU time limit and the signal SIGSEGV on
  exceeding a data size limit. A program may set its own soft limits to any value less than the hard limit. It
  may reduce its hard limit. Only a program running with superuser privileges may increase a hard limit.
  There are a number of system resources that can be limited. These are specified by the resource param-
  eter of the rlimit functions and are defined in sys/resource.h as
      resource Parameter                  Description
      RLIMIT_CORE                         The core dump file size limit, in bytes
      RLIMIT_CPU                          The CPU time limit, in seconds
      RLIMIT_DATA                         The data () segment limit, in bytes
      RLIMIT_FSIZE                        The file size limit, in bytes
      RLIMIT_NOFILE                       The limit on the number of open files
      RLIMIT_STACK                        The limit on stack size, in bytes
      RLIMIT_AS                           The limit on address space (stack and data), in bytes
  The following “Try It Out” shows a program, limits.c, that simulates a typical application. It also sets
  and breaks a resource limit.
Try It Out—Resource Limits
      1. Make the includes for all the functions we’re going to be using in this program:
       #include    <sys/types.h>
       #include    <sys/resource.h>
       #include    <sys/time.h>
       #include    <unistd.h>
       #include    <stdio.h>
       #include    <math.h>
      2.    The void function writes a string to a temporary file 10,000 times and then performs some
            arithmetic to generate load on the CPU:
       void work()
       {
            FILE *f;
                                                                                                         167
Chapter 4
         int i;
         double x = 4.5;
         f = tmpfile();
         for(i = 0; i < 10000; i++) {
              fprintf(f,”Do some output\n”);
              if(ferror(f)) {
                    fprintf(stderr,”Error writing to temporary file\n”);
                    exit(1);
              }
         }
         for(i = 0; i < 1000000; i++)
              x = log(x*x + 3.21);
     }
    3.   The main function calls work and then uses the getrusage function to discover how much
         CPU time it has used. It displays this information on screen:
     int main()
     {
         struct rusage r_usage;
         struct rlimit r_limit;
         int priority;
         work();
         getrusage(RUSAGE_SELF, &r_usage);
         printf(“CPU usage: User = %ld.%06ld, System = %ld.%06ld\n”,
              r_usage.ru_utime.tv_sec, r_usage.ru_utime.tv_usec,
              r_usage.ru_stime.tv_sec, r_usage.ru_stime.tv_usec);
    4.   Next, it calls getpriority and getrlimit to find out its current priority and file size limits,
         respectively:
         priority = getpriority(PRIO_PROCESS, getpid());
         printf(“Current priority = %d\n”, priority);
         getrlimit(RLIMIT_FSIZE, &r_limit);
         printf(“Current FSIZE limit: soft = %ld, hard = %ld\n”,
              r_limit.rlim_cur, r_limit.rlim_max);
    5.   Finally, we set a file size limit using setrlimit and call work again, which fails because it
         attempts to create too large a file:
         r_limit.rlim_cur = 2048;
         r_limit.rlim_max = 4096;
         printf(“Setting a 2K file size limit\n”);
         setrlimit(RLIMIT_FSIZE, &r_limit);
         work();
         exit(0);
     }
168
                                                                                 The Linux Environment
  When we run this program, we can see how much CPU resource is being consumed and the default pri-
  ority at which the program is running. Once a file size limit has been set, the program can’t write more
  than 2,048 bytes to a temporary file.
       $ cc -o limits limits.c -lm
       $ ./limits
       CPU usage: User = 0.980000, System = 0.010000
       Current priority = 0
       Current FSIZE limit: soft = -1, hard = -1
       Setting a 2K file size limit
       File size limit exceeded
  We can change the program priority by starting it with the nice command. Here, we see the priority
  changes to +10 and, as a result, it takes longer to execute the program:
       $ nice ./limits
       CPU usage: User = 1.000000, System = 0.000000
       Current priority = 10
       Current FSIZE limit: soft = -1, hard = -1
       Setting a 2K file size limit
       File size limit exceeded
How It Works
  The limits program calls the work function to simulate the actions of a typical program. It performs
  some calculations and produces some output, in this case, about 150K to a temporary file. It calls the
  resource functions to discover its priority and file size limits. In this case, the file size limits are unset,
  allowing us to create as large a file as we like (disk space permitting). The program then sets its file size
  limit to just 2K and again tries to perform some work. This time, the work function fails as it can’t create
  such a large temporary file.
       Limits may also be placed on a program running under a particular shell with the bash ulimit command.
  In this example, the error message ‘Error writing to temporary file’ may not be printed as we
  might expect. This is because some systems (such as Linux 2.2 and later) terminate our program when
  the resource limit is exceeded. It does this by sending a signal, SIGXFSZ. We will learn more about sig-
  nals and how to use them in Chapter 11. Other POSIX-compliant systems may simply cause the function
  that exceeds the limit to return an error.
Summar y
  In this chapter, we’ve looked at the Linux environment and examined the conditions under which pro-
  grams run. We’ve covered command line arguments and environment variables, both of which can be
  used to alter a program’s default behavior and provide useful program options.
  We’ve seen how a program can make use of library functions to manipulate date and time values and
  obtain information about itself and the user and the computer on which it’s running.
  Linux programs typically have to share precious resources, so we also looked at how those resources can
  be determined and managed.
                                                                                                               169
                                              5
                                   Terminals
 In this chapter, let’s consider the improvements we might like to make to our basic application
 from Chapter 2. Perhaps the most obvious failing is the user interface; it’s functional, but not very
 elegant. Here, we’ll look at how to take more control of the user’s terminal; that is, both keyboard
 input and screen output. More than this, though, we’ll learn how to “guarantee” that the programs
 we write can get input from the user, even in the presence of input redirection, and ensure that the
 output goes to the right place on the screen.
 Though the reimplemented CD database application won’t see the light of day until the end of
 Chapter 7, we’ll do much of the groundwork for that chapter here. Chapter 6 is on curses, which is
 not some ancient malediction, but rather a library of functions that provide a higher level of code to
 control the terminal screen display. Along the way, we’ll examine a little more of the thinking of the
 early UNIX meisters by introducing you to some philosophy of Linux and UNIX and the concept of
 terminal input and output. The low-level access presented here might be just what you’re looking
 for. Most of what we will cover applies equally well to programs running in a console window, such
 as KDE’s Konsole, GNOME’s gnome-terminal, or the standard X11 xterm.
 Specifically, in this chapter, we’ll learn about
     ❑    Reading and writing to the terminal
     ❑    Terminal drivers and the General Terminal Interface
     ❑    termios
     ❑    Terminal output and terminfo
     ❑    Detecting keystrokes
Reading from and Writing to the Terminal
 In Chapter 3, we learned that when a program is invoked from the command prompt, the shell
 arranges for the standard input and output streams to be connected to our program. We should be
 able to interact with the user simply by using the getchar and printf routines to read and write
 these default streams.
* Chapter 5
  Let’s try to rewrite our menu routines in C, using just those two routines, calling it menu1.c.
  Try It Out—Menu Routines in C
     1. Start with the following lines, which define the array to be used as a menu, and prototype the getchoice function:
       #include <stdio.h>
       char *menu[] = {
            “a - add new record”,
            “d - delete record”,
            “q - quit”,
            NULL,
       };
       int getchoice(char *greet, char *choices[]);
     2.    The main function calls getchoice with the sample menu, menu:
       int main()
       {
            int choice = 0;
            do
            {
                 choice = getchoice(“Please select an action”, menu);
                 printf(“You have chosen: %c\n”, choice);
            } while(choice != ‘q’);
            exit(0);
       }
     3.    Now for the important code: the function that both prints the menu and reads the user’s input:
       int getchoice(char *greet, char *choices[])
       {
            int chosen = 0;
            int selected;
            char **option;
            do {
                 printf(“Choice: %s\n”,greet);
                 option = choices;
                 while(*option) {
                      printf(“%s\n”,*option);
                      option++;
                 }
                 selected = getchar();
                 option = choices;
                 while(*option) {
                      if(selected == *option[0]) {
                           chosen = 1;
172
                                                                                                   Terminals
                             break;
                       }
                       option++;
                   }
                   if(!chosen) {
                       printf(“Incorrect choice, select again\n”);
                   }
             } while(!chosen);
             return selected;
        }
How It Works
  getchoice prints the program introduction greet and the sample menu choices and asks the user to
  choose the initial character. The program then loops until getchar returns a character that matches the
  first letter of one of the option array’s entries.
  When we compile and run this program, we discover that it doesn’t behave as we expected. Here’s some
  terminal dialogue to demonstrate the problem:
        $ ./menu1
        Choice: Please select an       action
        a - add new record
        d - delete record
        q - quit
        a
        You have chosen: a
        Choice: Please select an       action
        a - add new record
        d - delete record
        q - quit
        Incorrect choice, select       again
        Choice: Please select an       action
        a - add new record
        d - delete record
        q - quit
        q
        You have chosen: q
        $
  Here, the user had to enter A/Enter/Q/Enter to make selections. There seem to be at least two problems:
  The most serious problem is that we are getting Incorrect choice after every correct choice. Plus, we
  still have to press Enter (or the Return key) before our program reads our input.
Canonical versus Non-Canonical Modes
  The two problems are closely related. By default, terminal input is not made available to a program until
  the user presses Enter. In most cases, this is a benefit because it allows the user to correct typing mistakes
  using Backspace or Delete. Only when they’re happy with what they see on the screen do they press
  Enter to make the input available to the program.
  This behavior is called canonical, or standard, mode. All the input is processed in terms of lines. Until a
  line of input is complete (usually when the user presses Enter), the terminal interface manages all the
  key presses, including Backspace, and no characters may be read by the application.
                                                                                                           173
Chapter 5
  The opposite of this is non-canonical mode, where the application has much greater control over the pro-
  cessing of input characters. We’ll come back to these two modes again a little later.
  Among other things, the Linux terminal handler likes translating interrupt characters to signals and can
  automatically perform Backspace and Delete processing for you, so you don’t have to reimplement it in
  each program you write. We’ll find out more about signals in Chapter 11.
  So, what’s happening in our program? Well, Linux is saving the input until the user presses Enter, then
  passing both the choice character and the subsequent Enter to the program. So, each time you enter a menu
  choice, the program calls getchar, processes the character, then calls getchar again, which immediately
  returns with the Enter character.
  The character the program actually sees isn’t an ASCII carriage return, CR (decimal 13, hex 0D), but a line
  feed, LF (decimal 10, hex 0A). This is because, internally, Linux (like UNIX) always uses a line feed to
  end lines of text; that is, UNIX uses a line feed alone to mean a newline, where other systems, such as
  MS-DOS, use a carriage return and a line feed together as a pair. If the input or output device also sends
  or requires a carriage return, the Linux terminal processing takes care of it. This might seem a little
  strange if you’re used to MS-DOS or other environments, but one of the very considerable benefits is
  that there is no real difference between text and binary files on Linux. Only when you input or output
  to a terminal or some printers and plotters are carriage returns processed.
  We can correct the major deficiency in our menu routine simply by ignoring the additional line feed
  character with some code such as this:
                             do {
                                        selected = getchar();
                             } while(selected == ‘\n’);
  This solves the immediate problem. We’ll return to the second problem of needing to press Enter, and a
  more elegant solution to the line feed handling later.
Handling Redirected Output
  It’s very common for Linux programs, even interactive ones, to have their input or output redirected,
  either to files or other programs. Let’s see how our program behaves when we redirect its output to a
  file:
        $ menu1 > file
        a
        q
        $
  We could regard this as successful because the output has been redirected to a file rather than the termi-
  nal. However, there are cases where we want to prevent this from happening, or where we want to sepa-
  rate prompts that we want the user to see from other output that can be redirected safely.
  We can tell whether the standard output has been redirected by finding out if the low-level file descrip-
  tor is associated with a terminal. The isatty system call does this. We simply pass it a valid file descrip-
  tor and it tests to see if that is currently connected to a terminal.
174
                                                                                                 Terminals
       #include <unistd.h>
       int isatty(int fd);
  The isatty system call returns 1 if the open file descriptor, fd, is connected to a terminal and 0 otherwise.
  In our program, we are using file streams, but isatty operates only on file descriptors. To provide the
  necessary conversion, we need to combine the isatty call with the fileno routine that we discussed in
  Chapter 3.
  What are we going to do if stdout has been redirected? Just quitting isn’t good enough because the user
  has no way of knowing why the program failed to run. Printing a message on stdout won’t help either
  because it must have been redirected away from the terminal. One solution is to write to stderr, which
  isn’t redirected by the shell > file command.
Try It Out—Checking for Output Redirection
  Using the program menu1.c we created in the last “Try It Out” section, make a new include, change
  the main function to the following, and call the new file menu2.c.
       #include <unistd.h>
       ...
       int main()
       {
            int choice = 0;
            if(!isatty(fileno(stdout))) {
                 fprintf(stderr,”You are not a terminal!\n”);
                 exit(1);
            }
            do {
                 choice = getchoice(“Please select an action”, menu);
                 printf(“You have chosen: %c\n”, choice);
            } while(choice != ‘q’);
            exit(0);
       }
  Now look at the following sample output:
       $ menu2
       Choice: Please select an action
       a - add new record
       d - delete record
       q - quit
       q
       You have chosen: q
       $ menu2 > file
       You are not a terminal!
       $
                                                                                                          175
Chapter 5
How It Works
  The new section of code uses the isatty function to test whether the standard output is connected to
  a terminal and halts execution if it isn’t. This is the same test the shell uses to decide whether to offer
  prompts. It’s possible, and quite common, to redirect both stdout and stderr away from the terminal.
  We can direct the error stream to a different file like this:
       $ menu2 >file 2>file.error
       $
  Or combine the two output streams into a single file like this:
       $ menu2 >file 2>&1
       $
  (If you’re not familiar with output redirection, take another look at Chapter 2, where we explain this
  syntax in more detail.) In this case, you’ll need to send a message to the console.
Talking to the Terminal
  If we need to prevent the parts of our program that interact with the user from being redirected, but still
  allow it to happen to other input or output, we need to separate the interaction from stdout and stderr.
  We can do this by reading and writing directly to the terminal. Since Linux is inherently a multiuser sys-
  tem, usually with many terminals either directly connected or connected across a network, how can we
  discover the correct terminal to use?
  Fortunately, Linux and UNIX make things easy for us by providing a special device, /dev/tty, which is
  always the current terminal, or login session. Since Linux treats everything as a file, we can use normal
  file operations to read and write to /dev/tty.
  Let’s modify our choice program so that we can pass parameters to the getchoice routine, to provide
  better control over the output. We’re up to menu3.c.
Try It Out—Using /dev/tty
  Load up menu2.c and change the code to the following, so that input and output come from and are
  directed to /dev/tty:
       #include <stdio.h>
       #include <unistd.h>
       char *menu[] = {
            “a - add new record”,
            “d - delete record”,
            “q - quit”,
            NULL,
       };
       int getchoice(char *greet, char *choices[], FILE *in, FILE *out);
       int main()
176
                                                                         Terminals
{
    int choice = 0;
    FILE *input;
    FILE *output;
    if(!isatty(fileno(stdout))) {
         fprintf(stderr,”You are not a terminal, OK.\n”);
    }
    input = fopen(“/dev/tty”, “r”);
    output = fopen(“/dev/tty”, “w”);
    if(!input || !output) {
        fprintf(stderr,”Unable to open /dev/tty\n”);
        exit(1);
    }
    do {
         choice = getchoice(“Please select an action”, menu, input, output);
         printf(“You have chosen: %c\n”, choice);
    } while(choice != ‘q’);
    exit(0);
}
int getchoice(char *greet, char *choices[], FILE *in, FILE *out)
{
    int chosen = 0;
    int selected;
    char **option;
    do {
         fprintf(out,”Choice: %s\n”,greet);
         option = choices;
         while(*option) {
             fprintf(out,”%s\n”,*option);
             option++;
         }
         do {
             selected = fgetc(in);
         } while(selected == ‘\n’);
         option = choices;
         while(*option) {
             if(selected == *option[0]) {
                 chosen = 1;
                 break;
             }
             option++;
         }
         if(!chosen) {
             fprintf(out,”Incorrect choice, select again\n”);
         }
    } while(!chosen);
    return selected;
}
                                                                               177
Chapter 5
  Now, when we run the program with the output redirected, we can still see the prompts and the normal
  program output is separated.
       $ menu3 > file
       You are not a terminal, OK.
       Choice: Please select an action
       a - add new record
       d - delete record
       q - quit
       d
       Choice: Please select an action
       a - add new record
       d - delete record
       q - quit
       q
       $ cat file
       You have chosen: d
       You have chosen: q
The Terminal Driver and the General
Terminal Interface
  Sometimes a program needs much finer control over the terminal than can be achieved using simple file
  operations. Linux provides a set of interfaces that allow us to control the behavior of the terminal driver,
  giving us much greater control of the processing of terminal input and output.
Overview
  As Figure 5-1 shows, we can control the terminal through a set of function calls (the General Terminal
  Interface, or GTI) separate from those used for reading and writing. This keeps the data (read/write)
  interface very clean while still allowing detailed control over the terminal behavior. That’s not to say that
  the terminal I/O interface is clean—it’s got to deal with a wide variety of different hardware.
                                          User program
                                                  read/write         Control
                                                    interface       interface
                                         Terminal Driver
                                          in the Kernel
                                   Figure 5-1
178
                                                                                              Terminals
 In UNIX terminology, the control interface sets a “line discipline” that allows a program considerable
 flexibility in specifying the behavior of the terminal driver.
 The main features that we can control are
     ❑     Line editing: Choose whether to allow Backspace for editing.
     ❑     Buffering: Choose whether to read characters immediately, or read them after a configurable
           delay.
     ❑     Echo: Allows us to control echoing, such as when reading passwords.
     ❑     CR/LF: Determine mapping for input and output: what happens when you print a \n.
     ❑     Line speeds: Rarely used on a PC console, these speeds are very important for modems and ter-
           minals on serial lines.
Hardware Model
 Before we look at the General Terminal Interface in detail, it’s very important that we understand the
 hardware model that it’s intended to drive.
 The conceptual arrangement shown in Figure 5-2 (and for some UNIX sites, it will physically be like
 this) is to have a UNIX machine connected via a serial port to a modem and then via a telephone line
 and another modem to a remote terminal. In fact, this is just the kind of setup used by some small
 Internet service providers. It’s a distant relative of the client/server paradigm, used when the program
 ran on a mainframe and users worked at dumb terminals.
                                       Application
                             read/write           control
                               interface         interface
                                       UNIX Kernel
                                       Serial Hardware
                          Data and control lines           Data and control lines
                                                           'telephone' lines
                       Figure 5-2
                                                                                                       179
Chapter 5
  If you’re working on a PC running Linux, this may seem like an overly complex model. However, as
  both of the authors have modems, we can, if we choose, use a terminal emulation program like minicom
  to run a remote logon session on each other’s machines just like this, using a pair of modems and a tele-
  phone line.
  The advantage of using such a hardware model is that most real-world situations will form a subset of
  this, the most complex case. Supporting them will be much easier than if the model had omitted such
  functionality.
The termios Structure
  termios is the standard interface specified by POSIX and is similar to the System V interface termio.
  The terminal interface is controlled by setting values in a structure of type termios and using a small
  set of function calls. Both are defined in the header file termios.h.
          Programs that use the function calls defined in termios.h will need to be linked
          with an appropriate function library. This will normally be the curses library, so
          when compiling the examples in this chapter, you’ll need to add -lcurses to the
          end of the compiler command line. On some older Linux systems, the curses
          library is provided by a version known as “new curses,” or ncurses. In these cases,
          the library name and link argument become and -lncurses, respectively.
  The values that can be manipulated to affect the terminal are grouped into various modes:
      ❑     Input
      ❑     Output
      ❑     Control
      ❑     Local
      ❑     Special control characters
  A minimum termios structure is typically declared as follows (although the X/Open specification
  allows additional fields to be included).
       #include <termios.h>
       struct termios {
             tcflag_t c_iflag;
             tcflag_t c_oflag;
             tcflag_t c_cflag;
             tcflag_t c_lflag;
             cc_t       c_cc[NCCS];
       };
  The member names correspond with the five parameter types listed in the previous list.
180
                                                                                                 Terminals
  We can initialize a termios structure for the terminal by calling the function tcgetattr, which has the
  following prototype:
       #include <termios.h>
       int tcgetattr(int fd, struct termios *termios_p);
  This call writes the current values of the terminal interface variables into the structure pointed to
  by termios_p. If these values are then altered, we can reconfigure the terminal interface with the
  tcsetattr function as follows
       #include <termios.h>
       int tcsetattr(int fd, int actions, const struct termios *termios_p);
  The actions field for tcsetattr controls how any changes are applied. The three possibilities are
      ❑     TCSANOW: Changes values immediately.
      ❑     TCSADRAIN: Changes values when current output is complete.
      ❑     TCSAFLUSH: Changes values when current output is complete, but discards any input
            currently available and not yet returned in a read call.
          Note that it’s very important for programs to restore terminal settings to the values
          they had before the program started. It’s always the responsibility of a program to
          initially save and restore these settings when it finishes.
  We’ll now look more closely at the modes and related function calls. Some of the detail of the modes is
  rather specialized and rarely used, so we’ll cover only the main features here. If you need to know
  more, you should consult your local man pages or a copy of the POSIX or X/Open specification.
  The most important mode to take in on your first read is the local mode. The canonical and non-canonical
  modes are the solution to the second of our problems in the first application. We can instruct the program
  to wait for a line of input or pounce on input as soon as it is typed.
Input Modes
  The input modes control how input (characters received by the terminal driver at a serial port or keyboard)
  is processed before being passed on to the program. We control them by setting flags in the c_iflag mem-
  ber of the termios structure. All the flags are defined as macros and can be combined with a bitwise OR.
  This is the case for all the terminal modes.
  The macros that can be used for c_iflag are
      ❑     BRKINT: Generate an interrupt when a break condition is detected on the line
      ❑     IGNBRK: Ignore break conditions on the line
                                                                                                         181
Chapter 5
      ❑     ICRNL: Convert a received carriage return to a newline
      ❑     IGNCR: Ignore received carriage returns
      ❑     INLCR: Convert received newlines to carriage returns
      ❑     IGNPAR: Ignore characters with parity errors
      ❑     INPCK: Perform parity checking on received characters
      ❑     PARMRK: Mark parity errors
      ❑     ISTRIP: Strip (set to seven bits) all incoming characters
      ❑     IXOFF: Enable software flow control on input
      ❑     IXON: Enable software flow control on output
          If neither BRKINT nor IGNBRK is set, a break condition on the line is read as a
          NULL (0x00) character.
  You won’t need to change the input modes very often, as the default values are usually the most suit-
  able, so we won’t discuss them further here.
Output Modes
  These modes control how output characters are processed; that is, how characters sent from a program
  are processed before being transmitted to the serial port or screen. As you might expect, many of these
  are counterparts of the input modes. Several additional flags exist, which are mainly concerned with
  allowing for slow terminals that require time to process characters such as carriage returns. Almost all of
  these are either redundant (as terminals get faster) or better handled using the terminfo database of ter-
  minal capabilities, which we’ll use later in this chapter.
  We control output modes by setting flags in the c_oflag member of the termios structure. The macros
  that we can use in c_oflag are
      ❑     OPOST: Turn on output processing
      ❑     ONLCR: Convert any output newline to a carriage return/line feed pair
      ❑     OCRNL: Convert any output carriage return to a newline
      ❑     ONOCR: No carriage return output in column 0
      ❑     ONLRET: A newline also does a carriage return
      ❑     OFILL: Send fill characters to provide delays
      ❑     OFDEL: Use DEL as a fill character, rather then NULL
      ❑     NLDLY: Newline delay selection
      ❑     CRDLY: Carriage return delay selection
      ❑     TABDLY: Tab delay selection
182
                                                                                                Terminals
     ❑      BSDLY: Backspace delay selection
     ❑      VTDLY: Vertical tab delay selection
     ❑      FFDLY: Form feed delay selection
          If OPOST is not set, all the other flags are ignored.
  The output modes are also not commonly used, so we won’t consider them further here.
Control Modes
  These modes control the hardware characteristics of the terminal. We specify control modes by setting
  flags in the c_cflag member of the termios structure, which has the following macros:
     ❑      CLOCAL: Ignore any modem status lines.
     ❑      CREAD: Enable the receipt of characters.
     ❑      CS5: Use five bits in sent or received characters.
     ❑      CS6: Use six bits in sent or received characters.
     ❑      CS7: Use seven bits in sent or received characters.
     ❑      CS8: Use eight bits in sent or received characters.
     ❑      CSTOPB: Use two stop bits per character, rather than one.
     ❑      HUPCL: Hang up modem on close.
     ❑      PARENB: Enable parity generation and detection.
     ❑      PARODD: Use odd parity rather than even parity.
          If HUPCL is set, when the terminal driver detects that the last file descriptor referring
          to the terminal has been closed, it will set the modem control lines to “hang-up”
          the line.
  The control modes are used mainly when the serial line is connected to a modem, although they may be
  used when talking to a terminal. Normally, it’s easier to change your terminal’s configuration than to
  change the default line behavior by using the control modes of termios.
Local Modes
  These modes control various characteristics of the terminal. We specify local modes by setting flags in
  the c_lflag member of the termios structure, with the following macros:
     ❑      ECHO: Enable local echoing of input characters
     ❑      ECHOE: Perform a Backspace, Space, Backspace combination on receiving ERASE
                                                                                                       183
Chapter 5
      ❑    ECHOK: Perform erase line on the KILL character
      ❑    ECHONL: Echo newline characters
      ❑    ICANON: Enable canonical input processing (see the following)
      ❑    IEXTEN: Enable implementation specific functions
      ❑    ISIG: Enable signals
      ❑    NOFLSH: Disable flush on queue
      ❑    TOSTOP: Send background processes a signal on write attempts
  The two most important flags here are ECHO, which allows you to suppress the echoing of typed charac-
  ters, and ICANON, which switches the terminal between two very distinct modes of processing received
  characters. If the ICANON flag is set, the line is said to be in canonical mode; if not, the line is in non-
  canonical mode.
Special Control Characters
  These are a collection of characters, like Ctrl-C, acted upon in special ways when the user types them.
  The c_cc array member of the termios structure contains the characters mapped to each of the sup-
  ported functions. The position of each character (its index into the array) is defined by a macro, but
  there’s no limitation that they must be control characters.
  The c_cc array is used in two very different ways, depending on whether the terminal is set to canonical
  mode (i.e., the setting of the ICANON flag in the c_lflag member of termios).
  It’s important to realize that there is some overlap in the way the array index values are used for the two
  different modes. Because of this, you should never mix values from these two modes.
  For canonical mode, the array indices are
      ❑    VEOF: EOF character
      ❑    VEOL: EOL character
      ❑    VERASE: ERASE character
      ❑    VINTR: INTR character
      ❑    VKILL: KILL character
      ❑    VQUIT: QUIT character
      ❑    VSUSP: SUSP character
      ❑    VSTART: START character
      ❑    VSTOP: STOP character
  For non-canonical mode, the array indices are
      ❑    VINTR: INTR character
      ❑    VMIN: MIN value
184
                                                                                                  Terminals
      ❑    VQUIT: QUIT character
      ❑    VSUSP: SUSP character
      ❑    VTIME: TIME value
      ❑    VSTART: START character
      ❑    VSTOP: STOP character
Characters
  Since the special characters and non-canonical MIN and TIME values are so important for more advanced
  input character processing, we explain them in some detail here.
     Character               Description
     INTR                    Causes the terminal driver to send a SIGINT signal to processes connected
                             to the terminal. We discuss signals in more detail in Chapter 11.
     QUIT                    Causes the terminal driver to send a SIGQUIT signal to processes connected
                             to the terminal.
     ERASE                   Causes the terminal driver to delete the last character on the line.
     KILL                    Causes the terminal driver to delete the entire line.
     EOF                     Causes the terminal driver to pass all characters on the line to the application
                             reading input. If the line is empty, a read call will return zero characters as
                             though a read had been attempted at the end of a file.
     EOL                     Acts as a line terminator in addition to the more usual newline character.
     SUSP                    Causes the terminal driver to send a SIGSUSP signal to processes connected
                             to the terminal. If your UNIX supports job control, the current application
                             will be suspended.
     STOP                    Acts to “flow off;” that is, prevent further output to the terminal. It’s used to
                             support XON/XOFF flow control and is usually set to the ASCII XOFF char-
                             acter, Ctrl+S.
     START                   Restarts output after a STOP character, often the ASCII XON character.
The TIME and MIN Values
  The values of TIME and MIN are used only in non-canonical mode and act together to control the reading
  of input. Together, they control what happens when a program attempts to read a file descriptor associ-
  ated with a terminal.
  There are four cases:
      ❑    MIN = 0 and TIME = 0: In this case, a read will always return immediately. If some charac-
           ters are available, they will be returned; if none are available, read will return zero and no
           characters will have been read.
                                                                                                            185
Chapter 5
      ❑    MIN = 0 and TIME > 0: In this case, the read will return when any character is available to
           be read or when TIME tenths of a second have elapsed. If no character was read because the
           timer expired, read will return zero. Otherwise, it will return the number of characters read.
      ❑    MIN > 0 and TIME = 0: In this case, the read will wait until MIN characters can be read
           and then return that number of characters. Zero is returned on end of file.
      ❑    MIN > 0 and TIME > 0: This is the most complex case. When read is called, it waits for a
           character to be received. When the first character is received, and every subsequent time
           a character is received, an inter-character timer is started (or restarted if it was already run-
           ning). The read will return when either MIN characters can be read or the inter-character
           time of TIME tenths of a second expires. This can be useful for telling the difference between a
           single press of the Escape key and the start of a function key escape sequence. Be aware,
           though, that network communications or high processor loads neatly erase such fine timing
           information.
  By setting non-canonical mode and using the MIN and TIME values, programs can perform character-by-
  character processing of input.
Accessing Terminal Modes from the Shell
  If you want to see the termios settings that are being used while you’re using the shell, you can get a
  list using the command:
       $ stty -a
  On our Linux systems, which have some extensions to the standard termios, the output is
       speed 38400 baud; rows 44; columns 109; line = 0;
       intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 =
       <undef>; start = ^Q; stop = ^S;
       susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
       -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts
       -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -
       iuclc -ixany -imaxbel
       opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
       isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl
       echoke
  Among other things, we can see that the EOF character is Ctrl+D and that echoing is enabled. When
  you’re experimenting with terminal control, it’s very easy to get the terminal left in a nonstandard state,
  which makes using it very difficult. There are several ways out of this difficulty.
  The first method is, if your version of stty supports it, to use the command
       $ stty sane
  If you have lost the mapping of the carriage return key to the newline character (which terminates the
  line), you may need to enter stty sane, but rather than press Enter, press Ctrl+J (which is the newline
  character).
186
                                                                                                  Terminals
  The second method is to use the stty -g command to write the current stty setting in a form ready to
  reread. On the command line, you can use
       $ stty -g > save_stty
       ..
       <experiment with settings>
       ..
       $ stty $(cat save_stty)
  You still may need to use Ctrl+J rather than Enter for the final stty command. You can use the same
  technique in a shell script:
       save_stty=”$(stty -g)”
       <alter stty settings>
       stty $save_stty
  If you’re really stuck, the third method is to go to a different terminal, use the ps command to find the shell
  you have made unusable, and then use kill HUP <process id> to force the shell to terminate. Since
  stty parameters are always reset before a logon prompt is issued, you should be able to log in normally.
Setting Terminal Modes from the Command Prompt
  We can also use the stty command to set the terminal modes directly from the command prompt.
  To set a mode in which our shell script could perform single character reads, we need to turn off canoni-
  cal mode and set MIN to 1 and TIME to 0. The command is
       $ stty -icanon min 1 time 0
  Now that the terminal is set to read characters immediately, you can try to run our first program,
  menu1, again. You should find it works as originally intended.
  We also could improve our attempt to check for a password (Chapter 2) by turning echoing off before we
  prompt for the password. The command to do this is
       $ stty -echo
       Remember to use stty echo to turn echoing back on after you try this!
Terminal Speed
  The final function served by the termios structure is manipulating the line speed. No members are defined
  for terminal speed; instead, it’s set by function calls. Input and output speeds are handled separately.
  The four call prototypes are
       #include <termios.h>
       speed_t cfgetispeed(const struct termios *);
       speed_t cfgetospeed(const struct termios *);
                                                                                                           187
Chapter 5
      int cfsetispeed(struct termios *, speed_t speed);
      int cfsetospeed(struct termios *, speed_t speed);
  Notice that these act on a termios structure, not directly on a port. This means that to set a new speed,
  you must read the current settings with tcgetattr, set the speed using one of the above calls, and then
  write the termios structure back using tcsetattr. Only after the call to tcsetattr will the line speed
  be changed.
  Various values are allowed for speed in the function calls above, but the most important are
     ❑      B0: Hang up the terminal
     ❑      B1200: 1200 baud
     ❑      B2400: 2400 baud
     ❑      B9600: 9600 baud
     ❑      B19200: 19200 baud
     ❑      B38400: 38400 baud
  There are no speeds greater than 38400 defined by the standard and no standard method of supporting
  serial ports at speeds greater than this.
          Some systems, including Linux, define B57600, B115200, and B230400 for select-
          ing faster speeds. If you’re using an earlier version of Linux and these constants are
          unavailable, you can use the command setserial to obtain nonstandard speeds of
          57600 and 115200. In this case, these speeds will be used when B38400 is selected.
          Both of these methods are nonportable, so be careful when you’re using them.
Additional Functions
  There are a small number of additional functions for the control of terminals. These work directly on file
  descriptors, without needing to get and set termios structures. Their definitions are
      #include <termios.h>
      int tcdrain(int fd);
      int tcflow(int fd, int flowtype);
      int tcflush(int fd, int in_out_selector);
  The functions have the following purposes:
     ❑      tcdrain causes the calling program to wait until all queued output has been sent.
     ❑      tcflow is used to suspend or restart output.
     ❑      tcflush can be used to flush input, output, or both.
188
                                                                                                Terminals
  Now that we’ve covered the rather large subject of the termios structure, let’s look at a few practical
  examples. Possibly the simplest is the disabling of echo to read a password. We do this by turning off
  the ECHO flag.
Try It Out—A Password Program with termios
     1. Our password program, password.c, begins with the following definitions:
       #include <termios.h>
       #include <stdio.h>
       #define PASSWORD_LEN 8
       int main()
       {
            struct termios initialrsettings, newrsettings;
            char password[PASSWORD_LEN + 1];
     2.    Next, add a line to get the current settings from the standard input and copy them into the
           termios structure that we created previously.
            tcgetattr(fileno(stdin), &initialrsettings);
     3.    Make a copy of the original settings to replace them at the end. Turn off the ECHO flag on the
           newrsettings and ask the user for their password:
            newrsettings = initialrsettings;
            newrsettings.c_lflag &= ~ECHO;
            printf(“Enter password: “);
     4.    Next, set the terminal attributes to newrsettings and read in the password. Lastly, reset the
           terminal attributes to their original setting and print the password to render all the previous
           effort useless.
            if(tcsetattr(fileno(stdin), TCSAFLUSH, &newrsettings) != 0) {
                 fprintf(stderr,”Could not set attributes\n”);
            }
            else {
                 fgets(password, PASSWORD_LEN, stdin);
                 tcsetattr(fileno(stdin), TCSANOW, &initialrsettings);
                 fprintf(stdout, “\nYou entered %s\n”, password);
            }
            exit(0);
       }
How It Works
       $ ./password
       Enter password:
       You entered hello
       $
                                                                                                         189
Chapter 5
  In this example, the word hello is typed but not echoed at the Enter password: prompt. No output is
  produced until the user presses Enter.
  We’re careful to change only the flags we need to change, using the construct X &= ~FLAG (which clears
  the bit defined by FLAG in the variable X). If needed, we could use X |= FLAG to set a single bit defined
  by FLAG, although this wasn’t necessary in the example above.
  When we’re setting the attributes, we use TCSAFLUSH to discard any typeahead, characters users enter
  before the program is ready to read them. This is a good way of encouraging users not to start typing
  their password until echo has been turned off. We also restore the previous setting before our program
  terminates.
  Another common use of the termios structure is to put the terminal into a state where we can read each
  character as it is typed. We do this by turning off canonical mode and using the MIN and TIME settings.
Try It Out—Reading Each Character
     1. Using our new knowledge, we can make changes to our menu program. The following code bears
           much resemblance to password.c, but needs to be inserted into menu3.c to make our new pro-
           gram, menu4.c. For a start, we must include a new header file at the top of the program:
       #include <stdio.h>
       #include <unistd.h>
       #include <termios.h>
     2.    Then we need to declare a couple of new variables in the main function:
            int choice = 0;
            FILE *input;
            FILE *output;
            struct termios initial_settings, new_settings;
     3.    We need to change the terminal’s characteristics before we call the getchoice function, so
           that’s where we place these lines:
                 fprintf(stderr, “Unable to open /dev/tty\n”);
                 exit(1);
            }
            tcgetattr(fileno(input),&initial_settings);
            new_settings = initial_settings;
            new_settings.c_lflag &= ~ICANON;
            new_settings.c_lflag &= ~ECHO;
            new_settings.c_cc[VMIN] = 1;
            new_settings.c_cc[VTIME] = 0;
            if(tcsetattr(fileno(input), TCSANOW, &new_settings) != 0) {
                 fprintf(stderr,”could not set attributes\n”);
            }
     4.    We should also return the settings to their original values before exiting
            do {
                 choice = getchoice(“Please select an action”, menu, input, output);
190
                                                                                                 Terminals
                 printf(“You have chosen: %c\n”, choice);
            } while (choice != ‘q’);
            tcsetattr(fileno(input),TCSANOW,&initial_settings);
            exit(0);
      }
     5.    We need to check against carriage returns \r now that we’re in non-canonical mode, because
           the default mapping of CR to LF is no longer being performed.
                 do {
                     selected = fgetc(in);
                 } while (selected == ‘\n’ || selected == ‘\r’);
     6.    Unfortunately, if the user now types Ctrl+C at our program, the program will terminate. We can
           disable processing of these special characters by clearing the ISIG flag in the local modes. Add
           the following line to main.
            new_settings.c_lflag &= ~ISIG;
  If we put these changes into our menu program, we now get an immediate response and the character
  we type isn’t echoed
      $ ./menu4
      Choice: Please select an action
      a - add new record
      d - delete record
      q - quit
      You have chosen: a
      Choice: Please select an action
      a - add new record
      d - delete record
      q - quit
      You have chosen: q
      $
  If we type Ctrl+C, it’s passed directly to the program and treated as an incorrect choice.
Terminal Output
  Using the termios structure, we have control over keyboard input, but it would be good to have the
  same level of control over the way a program’s output is presented on the screen. We used printf at the
  beginning of the chapter to output characters to the screen, but with no way of placing the output at a
  particular position on the screen.
Terminal Type
  Many UNIX systems are used with terminals, although in many cases today, the “terminal” may actually
  be a PC running a terminal program. Historically, there have been a very large number of hardware ter-
  minals from different manufacturers. Although they nearly all use escape sequences (a string of characters
                                                                                                         191
Chapter 5
  starting with the escape character) to provide control over the position of the cursor and other attributes,
  such as bold and blinking, they are generally not very well standardized in the way they do this. Some
  older terminals also have different scrolling capabilities that may or may not erase when backspace is
  sent, and so on.
          There is an ANSI standard set of escape sequences (mostly based on the sequences
          used in the Digital Equipment Corporation VT series terminals, but not identical).
          Many software terminal programs provide an emulation of a standard hardware ter-
          minal, often VT100, VT220, or ANSI, and sometimes others as well.
  This variety of hardware terminals would be a major problem for programmers wishing to write soft-
  ware that controls the screen and runs on many terminal types. For example, an ANSI terminal uses the
  sequence Escape+[+A to move the cursor up one line. An ADM-3a terminal (very common some years
  ago) uses the single control character Ctrl+K.
  Writing a program that can deal with the many different types of terminals that might be connected to a
  UNIX system would seem to be an extremely daunting task. The program would need different source
  code for each type of terminal.
  Not surprisingly, there is a solution in a package known as terminfo. Instead of each program having
  to cater for every sort of terminal, the program looks up a database of terminal types to get the correct
  information. In most modern UNIX systems, including Linux, this has been integrated with another
  package called curses, which we will learn about in the next chapter.
  On Linux, we may have to use the implementation of curses known as ncurses, and include
  ncurses.h to provide prototypes for our terminfo functions. The terminfo functions themselves are
  declared in their own header file, term.h. Or at least that used to be the case. With newer Linux ver-
  sions, there’s a blurring of the line between terminfo and ncurses to the point where many programs
  requiring terminfo functions must also include the ncurses header file. To confuse matters further,
  recent Linux distributions also provide a standard curses header file and library to be more compatible
  with UNIX programs. On these distributions we recommend using curses.h and –lcurses.
Identify Your Terminal Type
  The Linux environment contains a variable, TERM, which is set to the type of terminal being used. It’s
  usually set automatically by the system at logon time. The system administrator may set a default termi-
  nal type for each of the directly connected terminals and may arrange for remote, networked users to be
  prompted for a terminal type. The value of TERM can be negotiated via telnet and is passed by rlogin.
  A user can query the shell to discover the system’s idea of the terminal he or she is using.
       $ echo $TERM
       xterm
       $
192
                                                                                              Terminals
In this case, the shell is being run from a program called xterm, a terminal emulator for the X Window
System, or a program that provides similar functionality such as KDE’s Konsole or GNOME’s gnome-
terminal.
The terminfo package contains a database of capabilities and escape sequences for a large number of
terminals and provides a uniform programming interface for using them. A single program can then be
written that will take advantage of future terminals as the database is extended, rather than each appli-
cation having to provide support for the many different terminals.
The terminfo capabilities are described by attributes. These are stored in a set of compiled terminfo
files, which are conventionally found in /usr/lib/terminfo or /usr/share/terminfo. For each ter-
minal (and many printers, which can also be specified in terminfo) there’s a file that defines its capabil-
ities and how its features can be accessed. To avoid creating a very large directory, the actual files are
stored in subdirectories, where the subdirectory name is simply the first letter of the terminal type. Thus,
the VT100 definition is found in ...terminfo/v/vt100.
terminfo files are written one per terminal type in a source format that is (just about!) readable, then
compiled using the tic command into a more compact and efficient format for use by application pro-
grams. Curiously, the X/Open specification refers to source and compiled format definitions, but fails
to mention the tic command for actually getting from source to compiled formats. You can use the
infocmp program to print a readable version of a compiled terminfo entry.
Here’s an example terminfo file for the VT100 terminal:
     $ infocmp vt100
     vt100|vt100-am|dec vt100 (w/advanced video),
       am, mir, msgr, xenl, xon,
       cols#80, it#8, lines#24, vt#3,
       acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
       bel=^G, blink=\E[5m$<2>, bold=\E[1m$<2>,
       clear=\E[H\E[J$<50>, cr=\r, csr=\E[%i%p1%d;%p2%dr,
       cub=\E[%p1%dD, cub1=\b, cud=\E[%p1%dB, cud1=\n,
       cuf=\E[%p1%dC, cuf1=\E[C$<2>,
       cup=\E[%i%p1%d;%p2%dH$<5>, cuu=\E[%p1%dA,
       cuu1=\E[A$<2>, ed=\E[J$<50>, el=\E[K$<3>,
       el1=\E[1K$<3>, enacs=\E(B\E)0, home=\E[H, ht=\t,
       hts=\EH, ind=\n, ka1=\EOq, ka3=\EOs, kb2=\EOr, kbs=\b,
       kc1=\EOp, kc3=\EOn, kcub1=\EOD, kcud1=\EOB,
       kcuf1=\EOC, kcuu1=\EOA, kent=\EOM, kf0=\EOy, kf1=\EOP,
       kf10=\EOx, kf2=\EOQ, kf3=\EOR, kf4=\EOS, kf5=\EOt,
       kf6=\EOu, kf7=\EOv, kf8=\EOl, kf9=\EOw, rc=\E8,
       rev=\E[7m$<2>, ri=\EM$<5>, rmacs=^O, rmkx=\E[?1l\E>,
       rmso=\E[m$<2>, rmul=\E[m$<2>,
       rs2=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h, sc=\E7,
       sgr=\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t^N%e^O%;,
       sgr0=\E[m^O$<2>, smacs=^N, smkx=\E[?1h\E=,
       smso=\E[1;7m$<2>, smul=\E[4m$<2>, tbc=\E[3g,
Each terminfo definition consists of three types of entry. Each entry is called a capname and defines a
terminal capability.
                                                                                                         193
Chapter 5
  Boolean capabilities simply indicate whether a terminal supports a particular feature. For example, the
  Boolean capability xon is present if the terminal supports XON/XOFF flow control.
  Numeric capabilities define sizes, such as lines, the number of lines on the screen, and cols, the num-
  ber of columns on the screen. The actual number is separated from the capability name by a # character.
  To define a terminal as having 80 columns and 24 lines, we would write cols#80, lines#24.
  String capabilities are slightly more complex. They are used for two distinct types of capability: defining
  output strings needed to access terminal features and defining the input strings that will be received
  when the user presses certain keys, normally function keys or special keys on the numeric keypad. Some
  string capabilities are quite simple, such as el, which is “erase to end of line.”. On a VT100 terminal, the
  escape sequence needed to do this is Esc+[+K. This is written el=\E[K in terminfo source format.
  Special keys are defined in a similar way. For example, the F1 function key on a VT100 sends the
  sequence Esc+O+P. This is defined as kf1=\EOP.
  Things get slightly more complicated where the escape sequence needs some parameters. Most terminals
  can move the cursor to a specified row and column location. It’s clearly impractical to have a different
  capability for each possible cursor location, so a generic capability string is used, with parameters defin-
  ing the values to be inserted when the stings are used. For example, a VT100 terminal uses the sequence
  Esc+[+<row>+;+<col>+H to move the cursor to a specified location. In terminfo source format, this is
  written with the rather intimidating cup=\E[%i%p1%d;%p2%dH$<5>.
  This means
      ❑     \E: Send Escape
      ❑     [: Send the [ character
      ❑     %i: Increment the arguments
      ❑     %p1: Put the first argument on the stack
      ❑     %d: Output the number on the stack as a decimal number
      ❑     ;: Send the ; character
      ❑     %p2: Put the second argument on the stack
      ❑     %d: Output the number on the stack as a decimal number
      ❑     H: Send the H character
  This seems more complex than it might be, but allows for the parameters to be in a fixed order, indepen-
  dent of which order the terminal expects them to appear in the final escape sequence. The %i to increment
  the arguments is required because standard cursor addressing is specified as starting from (0,0) at the top
  left of the screen, but the VT100 addresses this location as (1,1). The final $<5> indicates that a delay equiv-
  alent to five character output times is required to allow the terminal to process the cursor movement.
194
                                                                                                  Terminals
          We could define many, many capabilities, but, fortunately, most UNIX and Linux
          systems come with most terminals predefined. If you need to add a new terminal,
          you’ll find the complete capability list in the terminfo manual page. A good start-
          ing point is usually to locate a terminal that is similar to your new terminal and
          define the new terminal as a variation on the existing terminal or to work through
          the capabilities one at a time, updating them where required.
          The standard reference outside the man pages is the Termcap and Terminfo by John
          Strang, Linda Mui, and Tim O’Reilly (O’Reilly).
Using terminfo Capabilities
  Now that we know how to define terminal capabilities, we need to learn how to access them. When
  we’re using terminfo, the first thing we need to do is set up the terminal type by calling setupterm.
  This will initialize a TERMINAL structure for the current terminal type. We’ll then be able to ask for capa-
  bilities for the terminal and use its facilities. We do this with the setupterm call like this:
       #include <term.h>
       int setupterm(char *term, int fd, int *errret);
  The setupterm library function sets the current terminal type to that specified by the parameter term.
  If term is a null pointer, the TERM environment variable will be used. An open file descriptor to be used
  for writing to the terminal must be passed as fd. The function outcome is stored in the integer variable
  pointed to by errret, if this isn’t a null pointer. The value written will be
      ❑     –1: No terminfo database
      ❑     0: No matching entry in terminfo database
      ❑     1: Success
  The setupterm function returns the constant OK if it succeeds and ERR if it fails. If errret is set to a null
  pointer, setupterm will print a diagnostic message and exit the program if it fails, as in this example:
       #include <stdio.h>
       #include <term.h>
       #include <ncurses.h>
       int main()
       {
             setupterm(“unlisted”,fileno(stdout),(int *)0);
             printf(“Done.\n”);
             exit(0);
       }
                                                                                                          195
Chapter 5
  The output from running this program on your system may not be exactly that given here, but the mean-
  ing should be clear enough. Done. isn’t printed, because setupterm caused the program to exit when it
  failed.
       $ cc -o badterm badterm.c -I/usr/include/ncurses -lncurses
       $ badterm
       ‘unlisted’: unknown terminal type.
       $
  Notice the compilation line in the example: On this Linux system, the ncurses header file is in the direc-
  tory /usr/include/ncurses, so we have to specifically instruct the compiler to look there with the -I
  option. Some Linux systems have arranged for the ncurses library to be available in the standard loca-
  tions. On these systems, we can simply include curses.h, and specify –lcurses for the library.
  For our menu choice function, we would like to be able to clear the screen, move the cursor around the
  screen, and write at different locations on the screen. Once we’ve called setupterm, we can access the
  terminfo capabilities with three function calls, one for each of the capability types:
       #include <term.h>
       int tigetflag(char *capname);
       int tigetnum(char *capname);
       char *tigetstr(char *capname);
  The functions tigetflag, tigetnum, and tigetstr return the value of Boolean, numeric, and string
  terminfo capabilities, respectively. On failure (for example, if the capability isn’t present), tigetflag
  returns -1, tigetnum returns -2, and tigetstr returns (char *)-1.
  Let’s use the terminfo database to find out the size of the terminal by retrieving the cols and lines
  capabilities with this program, sizeterm.c:
       #include <stdio.h>
       #include <term.h>
       #include <ncurses.h>
       int main()
       {
           int nrows, ncolumns;
           setupterm(NULL, fileno(stdout), (int *)0);
           nrows = tigetnum(“lines”);
           ncolumns = tigetnum(“cols”);
           printf(“This terminal has %d columns and %d rows\n”, ncolumns, nrows);
           exit(0);
       }
       $ echo $TERM
       vt100
       $ sizeterm
       This terminal has 80 columns and 24 rows
       $
196
                                                                                               Terminals
If we run the program inside a window on a workstation, we’ll get answers that reflect the current win-
dow’s size:
     $ echo $TERM
     xterm
     $ sizeterm
     This terminal has 88 columns and 40 rows
     $
If we use tigetstr to retrieve the cursor motion capability (cup) of the xterm terminal type, we get a
parameterized answer: \E[%p1%d;%p2%dH.
This capability requires two parameters: a row and column to move the cursor to. Both coordinates are
measured starting at zero from the top left corner of the screen.
We can substitute the parameters in a capability with actual values using the tparm function. Up to nine
parameters can be substituted and a usable escape sequence is returned.
     #include <term.h>
     char *tparm(char *cap, long p1, long p2, ..., long p9);
Once we’ve constructed the terminal escape sequence with tparm, we must send it to the terminal. To
process this properly, you shouldn’t send the string to the terminal with printf. Instead, use one of the
special functions provided that correctly process any required delays while the terminal completes an
operation. These functions are
     #include <term.h>
     int putp(char *const str);
     int tputs(char *const str, int affcnt, int (*putfunc)(int));
On success, putp returns OK; on failure, it returns ERR. The putp function takes the terminal control
string and sends it to stdout.
So, to move to row 5, column 30 of the screen, we can use a block of code like this:
          char *cursor;
          char *esc_sequence;
          cursor = tigetstr(“cup”);
          esc_sequence = tparm(cursor,5,30);
          putp(esc_sequence);
The tputs function is provided for those situations when the terminal isn’t accessed via stdout and
allows you to specify the function to be used for outputting the characters. It returns the result of the user-
specified function putfunc. The affcnt parameter is intended to indicate the number of lines affected by
the change. It’s normally set to 1. The function used to output the string must have the same parameters
and return type as the putchar function. Indeed, putp(string) is equivalent to the call tputs(string,
1, putchar). We’ll see tputs used with a user-specified output function in the next example.
                                                                                                          197
Chapter 5
  Be aware that some older Linux distributions define the final parameter of the tputs function as int
  (*putfunc)(char), which would oblige us to alter the definition of the char_to_terminal function
  in our next “Try It Out” section.
          If you consult the manual pages for information on tparm and terminal capabilities,
          you may come across the tgoto function. The reason we haven’t used this function,
          when it apparently offers an easier solution to moving the cursor, is that the X/Open
          specification (Single UNIX Specification Version 2) does not include them as of the
          1997 edition. We therefore recommend that you don’t use any of these functions in
          new programs.
  We’re almost ready to add screen handling to our menu choice function. The only thing left to do is to
  clear the screen simply by using clear. Some terminals don’t support the clear capability, which
  leaves the cursor at the top left corner of the screen. In this case, we can position the cursor at the top left
  corner and use the “delete to end of display” command, ed.
  Putting all this information together, we’ll write the final version of our sample menu program, screen-
  menu.c, where we “paint” the options on the screen for the user to pick a valid one.
Try It Out—Total Terminal Control
  We can rewrite the getchoice function from menu4.c to give us total terminal control. In this listing, the
  main function has been omitted because it isn’t changed. Other differences from menu4.c are highlighted.
       #include <stdio.h>
       #include <unistd.h>
       #include <termios.h>
       #include <term.h>
       #include <curses.h>
       static FILE *output_stream = (FILE *)0;
       char *menu[] = {
            “a - add new record”,
            “d - delete record”,
            “q - quit”,
            NULL,
       };
       int getchoice(char *greet, char *choices[], FILE *in, FILE *out);
       int char_to_terminal(int char_to_write);
       int main()
       {
       ...
       }
198
                                                                         Terminals
int getchoice(char *greet, char *choices[], FILE *in, FILE *out)
{
    int chosen = 0;
    int selected;
    int screenrow, screencol = 10;
    char **option;
    char *cursor, *clear;
    output_stream = out;
    setupterm(NULL,fileno(out), (int *)0);
    cursor = tigetstr(“cup”);
    clear = tigetstr(“clear”);
    screenrow = 4;
    tputs(clear, 1, (int *) char_to_terminal);
    tputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);
    fprintf(out, “Choice: %s, greet);
    screenrow += 2;
    option = choices;
    while(*option) {
        tputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);
        fprintf(out,”%s”, *option);
        screenrow++;
        option++;
    }
    fprintf(out, “\n”);
    do {
        fflush(out);
        selected = fgetc(in);
        option = choices;
        while(*option) {
            if(selected == *option[0]) {
                chosen = 1;
                break;
            }
            option++;
        }
        if(!chosen) {
            tputs(tparm(cursor, screenrow, screencol), 1, char_to_terminal);
            fprintf(out,”Incorrect choice, select again\n”);
        }
    } while(!chosen);
    tputs(clear, 1, char_to_terminal);
    return selected;
}
int char_to_terminal(int char_to_write)
{
    if (output_stream) putc(char_to_write, output_stream);
    return 0;
}
                                                                               199
Chapter 5
How It Works
  The rewritten getchoice function implements the same menu as in previous examples, but the output
  routines are modified to make use of the terminfo capabilities. If you want to see the You have cho-
  sen: message for more than a moment before the screen is cleared, ready for the next selection, add a
  call to sleep in the main function:
       do {
                  choice = getchoice(“Please select an action”, menu, input, output);
                  printf(“\nYou have chosen: %c\n”, choice);
                  sleep(1);
             } while (choice != ‘q’);
  The last function in this program, char_to_terminal, includes a call to the putc function, which we
  mentioned in Chapter 3.
  To round off this chapter, we’ll look at a quick example of how to detect keystrokes.
Detecting Keystrokes
  People who have programmed MS-DOS often look for the Linux equivalent of the kbhit function,
  which detects whether a key has been pressed without actually reading it. Unfortunately, they fail to
  find it, since there’s no direct equivalent. UNIX programmers don’t notice the omission because UNIX is
  normally programmed in such a way that programs should rarely, if ever, busy-wait on an event. Since
  this is the normal use for kbhit, it’s rarely missed on UNIX and Linux.
  However, when you’re porting programs from MS-DOS, it’s often convenient to emulate kbhit, which
  you can do using the non-canonical input mode.
Try It Out—Your Very Own kbhit
     1. We begin with the standard headings and declare a couple of structures for the terminal settings.
            peek_character is used in the test of whether a key has been pressed. Then we prototype the
            functions we’ll be using later.
       #include <stdio.h>
       #include <termios.h>
       #include <term.h>
       #include <curses.h>
       #include <unistd.h>
       static struct termios initial_settings, new_settings;
       static int peek_character = -1;
       void init_keyboard();
       void close_keyboard();
       int kbhit();
       int readch();
200
                                                                                     Terminals
2.   The main function calls init_keyboard to configure the terminal, then loops once a second,
     calling kbhit each time it does. If the key hit is q, close_keyboard returns the behavior to
     normal and the program exits.
 int main()
 {
     int ch = 0;
     init_keyboard();
     while(ch != ‘q’) {
           printf(“looping\n”);
           sleep(1);
           if(kbhit()) {
               ch = readch();
               printf(“you hit %c\n”,ch);
           }
     }
     close_keyboard();
     exit(0);
 }
3.   init_keyboard and close_keyboard configure the terminal at the start and end of the
     program.
 void init_keyboard()
 {
     tcgetattr(0,&initial_settings);
     new_settings = initial_settings;
     new_settings.c_lflag &= ~ICANON;
     new_settings.c_lflag &= ~ECHO;
     new_settings.c_lflag &= ~ISIG;
     new_settings.c_cc[VMIN] = 1;
     new_settings.c_cc[VTIME] = 0;
     tcsetattr(0, TCSANOW, &new_settings);
 }
 void close_keyboard()
 {
     tcsetattr(0, TCSANOW, &initial_settings);
 }
4.   Now for the function that checks for the keyboard hit:
 int kbhit()
 {
     char ch;
     int nread;
     if(peek_character != -1)
           return 1;
     new_settings.c_cc[VMIN]=0;
     tcsetattr(0, TCSANOW, &new_settings);
     nread = read(0,&ch,1);
     new_settings.c_cc[VMIN]=1;
     tcsetattr(0, TCSANOW, &new_settings);
                                                                                              201
Chapter 5
            if(nread == 1) {
                 peek_character = ch;
                 return 1;
            }
            return 0;
      }
     5.    The character pressed is read by the next function, readch, which then resets peek_charac-
           ter to –1 for the next loop.
      int readch()
      {
            char ch;
            if(peek_character != -1) {
                 ch = peek_character;
                 peek_character = -1;
                 return ch;
            }
            read(0,&ch,1);
            return ch;
      }
  When we run the program, we get
      $ ./kbhit
      looping
      looping
      looping
      you hit h
      looping
      looping
      looping
      you hit d
      looping
      you hit q
      $
How It Works
  The terminal is configured in init_keyboard to read one character before returning (MIN=1, TIME=0).
  kbhit changes this behavior to check for input and return immediately (MIN=0, TIME=0) and then
  restores the original settings before exiting.
  Notice that we have to read the character that has been pressed but that we store it locally, ready for
  returning when it’s required.
Virtual Consoles
  Linux provides a feature called virtual consoles. A number of terminal devices are available, all of which
  share the PC’s screen, keyboard, and mouse. Typically, a Linux installation will be configured for 12 of
  these virtual consoles.
202
                                                                                              Terminals
The virtual consoles are made available through the character devices /dev/ttyN where N is a number,
starting at 1.
If you use a text login for your Linux system, you will be presented with a login prompt once Linux is
up and running. You then log in using a username and password. The device that you are using at this
point is the first virtual console, the terminal device /dev/tty1.
Using who and ps, we can see who is logged in and the shell and programs being executed on this vir-
tual console:
      $ who
      neil       tty1        Mar   8 18:27
      $ ps -e
        PID TTY               TIME   CMD
       1092 tty1         00:00:00    login
       1414 tty1         00:00:00    bash
       1431 tty1         00:00:00    emacs
Here, we can see in this cut-down output that user neil is logged in and running Emacs on the PC con-
sole device /dev/tty1.
Linux will normally start a getty process running on the first six virtual consoles so that it is possible to
log in six times using the same screen, keyboard, and mouse. We can see these processes with ps:
      $ ps -e
        PID TTY               TIME   CMD
       1092 tty1         00:00:00    login
       1093 tty2         00:00:00    mingetty
       1094 tty3         00:00:00    mingetty
       1095 tty4         00:00:00    mingetty
       1096 tty5         00:00:00    mingetty
       1097 tty6         00:00:00    mingetty
Here, we can see the SuSE default getty program, mingetty, running on five further virtual consoles,
waiting for a user to log in.
We can switch between virtual consoles using a special key combination: Ctrl+Alt+F<N> where N is the
number of the virtual console we wish to switch to. So, to switch to the second virtual console, we would
press Alt+Ctrl+F2, and Ctrl+Alt+F1 to return to the first console. (When switching from text logins
rather than graphical logins, the combination Ctrl+F<N> also works.)
If Linux starts a graphical login, either by startx or via a display manager such as xdm, the X Window
System will start up using the first free virtual console, normally /dev/tty7. When using the X Window
System, you can switch out to a text console with Ctrl+Alt+F<N> and back with Ctrl+Alt+F7.
It is possible to run more than one X session on Linux. If you do this, for example, with
      $ startx — :1
Linux will start the X server on the next free virtual console, in this case, /dev/tty8, and it is then possi-
ble to switch between them with Ctrl+Alt+F8 and Ctrl+Alt+F7.
                                                                                                         203
Chapter 5
  In all other respects, the virtual consoles behave as a terminal, as described in this chapter. If a process
  has the correct permissions, the virtual consoles may be opened, read from, and written to in the same
  way as a normal terminal.
Pseudo Terminals
  Many UNIX-like systems, including Linux, have a feature called pseudo-terminals. These are devices
  that behave much like the terminals we have been using in this chapter, except that they have no associ-
  ated hardware. They can be used to provide a terminal-like interface to other programs.
  For example, using pseudo-terminals, it is possible to make two chess programs play each other, despite
  the fact that the programs themselves were designed to interact with a human player at a terminal. An
  application acting as an intermediary passes one program’s moves to the other and vice versa. It uses
  pseudo-terminals to fool the programs into behaving normally without a terminal being present.
  Pseudo-terminals were at one time implemented in a system-specific manner, if at all. They have now
  been incorporated into the Single UNIX Specification as UNIX98 Pseudo-Terminals or PTYs.
Summar y
  In this chapter, we’ve learned about three different aspects of controlling the terminal. In the first part of
  the chapter, we learned about detecting redirection and how to talk directly to a terminal even when the
  standard file descriptors have been redirected. We covered the hardware model for terminals and a little
  of their history. We then learned about the General Terminal Interface and the termios structure that
  provides detailed control over Linux terminal handling. We also saw how to use the terminfo database
  and related functions to manage screen output in a terminal-independent fashion, and we looked at
  immediately detecting keystrokes. Finally, we discussed Linux virtual consoles and pseudo-terminals.
204
                                             6
           Managing Text-Based
             Screens with curses
In Chapter 5, we saw how to obtain much finer control over the input of characters and how to
provide character output in a terminal-independent way. The problem with using the general ter-
minal interface (GTI, or termios) and manipulating escape sequences with tparm and its related
functions is that it requires a lot of lower-level code. For many programs, a higher-level interface
would be more desirable. We would like to be able to simply draw on the screen and use a library
of functions to take care of terminal dependencies automatically.
In this chapter, you’ll learn about just such a library, the curses library. The curses standard is
important as a halfway house between simple “line-based” programs and the fully graphical (and
generally harder to program) X Window System programs, such as GTK/GNOME and Qt/KDE.
Linux does have the svgalib, but that is not a UNIX standard library, so is not generally available in
other UNIX-like operating systems. The curses library is used in many full-screen applications as
a reasonably easy and terminal-independent way to write full-screen, albeit character-based, pro-
grams. It’s almost always easier to write such programs with curses than to use escape sequences
directly. curses can also manage the keyboard, providing an easy-to-use, nonblocking character
input mode.
You may find that a few of the examples in this chapter don’t always display on the plain Linux
console exactly as you expect. There are occasions when the combination of the curses library
and the terminal definition of the console get slightly out of step and the effect is usually some
slightly odd layouts when using curses. However, you should find that if you use the X Window
System, and use an xterm window to display the output, things should display as you expect.
In this chapter, we’ll cover
    ❑     Using the curses library
    ❑     The concepts of curses
    ❑     Basic input and output control
    ❑     Multiple windows
