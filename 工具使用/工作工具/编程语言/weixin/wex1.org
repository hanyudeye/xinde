* 起步
** 小程序简介
   小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。

*** [[index_u97.html#小程序技术发展史][#]] 小程序技术发展史
 小程序并非凭空冒出来的一个概念。当微信中的 WebView 逐渐成为移动 Web
 的一个重要入口时，微信就有相关的 JS API 了。

 代码清单 1-1 使用 WeixinJSBridge 预览图片

 #+BEGIN_EXAMPLE
     WeixinJSBridge.invoke('imagePreview', {
         current: 'http://inews.gtimg.com/newsapp_bt/0/1693121381/641',
         urls: [ // 所有图片的URL列表，数组格式
             'https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg',
             'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
             'https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg'
         ]
     }, function(res) {
         console.log(res.err_msg)
     })
 #+END_EXAMPLE

 代码 1-1 是一个调用微信原生组件浏览图片的 JS
 API，相比于额外引入一个 JS 图片预览组件库，这种调用方式显得非常简洁和高效。

 实际上，微信官方是没有对外暴露过如此调用的，此类 API
 最初是提供给腾讯内部一些业务使用，很多外部开发者发现了之后，依葫芦画瓢地使用了，逐渐成为微信中网页的事实标准。2015 年初，微信发布了一整套网页开发工具包，称之为
 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个 API。给所有的
 Web
 开发者打开了一扇全新的窗户，让所有开发者都可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。

 同样是调用原生的浏览图片，调用方式如代码清单 1-2 所示。

 代码清单 1-2 使用 JS-SDK 调用图片预览组件

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     wx.previewImage({
       current: 'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
       urls: [ // 所有图片的URL列表，数组格式
         'https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg',
         'https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg',
         'https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg'
       ],
       success: function(res) {
         console.log(res)
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 JS-SDK 是对之前的 WeixinJSBridge
 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。

 JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 Web
 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK
 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个白屏的过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的 Web 开发者解决这个问题。因此我们设计了一个
 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 Web 资源离线存储”。

 以下文字引用自内部的文档（没有最终对外开放）：

 #+BEGIN_QUOTE
   微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web
   加速方案。

   通过使用微信离线存储，Web
   开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web
   资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有
   Web App 累计最多可缓存 5M 的资源。
 #+END_QUOTE

 这个设计有点类似 HTML5 的 Application Cache，但在设计上规避了一些
 Application Cache 的不足。

 在内部测试中，我们发现 离线存储
 能够解决一些问题，但对于一些复杂的页面依然会有白屏问题，例如页面加载了大量的
 CSS 或者是 JavaScript 文件。除了白屏，影响 Web
 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。

 微信面临的问题是如何设计一个比较好的系统，使得所有开发者在微信中都能获得比较好的体验。这个问题是之前的
 JS-SDK
 所处理不了的，需要一个全新的系统来完成，它需要使得所有的开发者都能做到：

 /- 快速的加载/

 /- 更强大的能力/

 /- 原生的体验/

 /- 易用且安全的微信数据开放/

 /- 高效和简单的开发/

 这就是小程序的由来。

*** [[index_u97.html#小程序与普通网页开发的区别][#]] 小程序与普通网页开发的区别
 小程序的主要开发语言是 JavaScript，小程序的开发同普通的网页开发相比有很大的相似
 性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些
 许区别的。

 网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失
 去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到
 各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和
 渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的
 DOM API 和 BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto
 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一
 些 NPM 的包在小程序中也是无法运行的。

 网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对
 IE、Chrome、QQ 浏览器等，在移动端需要面对 Safari、Chrome 以及 iOS、Android
 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和
 Android
 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表 1-1 所示。

 表 1-1 小程序的运行环境

 | *运行环境*         | *逻辑层*         | *渲染层*           |
 |--------------------+------------------+--------------------|
 | iOS                | JavaScriptCore   | WKWebView          |
 | 安卓               | V8               | chromium 定制内核   |
 | 小程序开发者工具   | NWJS             | Chrome WebView     |


 网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。

*** [[index_u97.html#体验小程序][#]] 体验小程序
 开发者可使用微信客户端(6.7.2 及以上版本)扫码下方小程序码，体验小程序。

*** [[index_u3.html#开始][#]] 开始
 开发小程序的第一步，你需要拥有一个小程序帐号，通过这个帐号你就可以管理你的小程序。

 跟随这个教程，开始你的小程序之旅吧！

*** [[index_u3.html#申请帐号][#]] 申请帐号
 进入[[https://mp.weixin.qq.com/wxopen/waregister?action=step1][小程序注册页<<>>]]
 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。

 在这个小程序管理平台，你可以管理你的小程序的权限，查看数据报表，发布小程序等操作。

 登录 [[https://mp.weixin.qq.com][小程序后台<<>>]] ，我们可以在菜单
 “开发”-“开发设置” 看到小程序的 *AppID* 了 。

 小程序的 AppID 相当于小程序平台的一个身份证，后续你会在很多地方要用到
 AppID （注意这里要区别于服务号或订阅号的 AppID）。

 有了小程序帐号之后，我们需要一个工具来开发小程序。

*** [[index_u3.html#安装开发工具][#]] 安装开发工具
    前往
    [[https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html][开发者工具下载页面<<>>]]
    ，根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看
    [[https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html][《开发者工具介绍》<<>>]]
 。

 打开小程序开发者工具，用微信扫码登录开发者工具，准备开发你的第一个小程序吧！

*** [[index_u3.html#你的第一个小程序][#]] 你的第一个小程序
    新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的 AppID，
    给你的项目起一个好听的名字，勾选 "不使用云服务" （注意:你要选择一个空的目录才可
    以创建项目），点击新建，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在微
    信开发者工具中预览你的第一个小程序。

*** [[index_u3.html#编译预览][#]] 编译预览
    点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以
    点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。
*** [[index_u12.html#小程序代码构成][#]] 小程序代码构成
    在上一章中，我们通过开发者工具快速创建了一个 QuickStart 项目。你可以留意到这个
    项目里边生成了不同类型的文件:

    1. =.json= 后缀的 =JSON= 配置文件
    2. =.wxml= 后缀的 =WXML= 模板文件
    3. =.wxss= 后缀的 =WXSS= 样式文件
    4. =.js= 后缀的 =JS= 脚本逻辑文件

    接下来我们分别看看这 4 种文件的作用。

**** [[index_u12.html#JSON-配置][#]] JSON 配置
     JSON 是一种数据格式，并不是编程语言，在小程序中，JSON 扮演的静态配置的角色。

     我们可以看到在项目的根目录有一个 =app.json= 和=project.config.json=，此外在
     =pages/logs= 目录下还有一个=logs.json=，我们依次来说明一下它们的用途。

***** [[index_u12.html#小程序配置-app-json][#]] 小程序配置 app.json
      =app.json= 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超
      时时间、底部 tab 等。QuickStart 项目里边的 =app.json= 配置内容如下：

      #+BEGIN_EXAMPLE
          {
            "pages":[
              "pages/index/index",
              "pages/logs/logs"
            ],
            "window":{
              "backgroundTextStyle":"light",
              "navigationBarBackgroundColor": "#fff",
              "navigationBarTitleText": "Weixin",
              "navigationBarTextStyle":"black"
            }
          }
      #+END_EXAMPLE

      我们简单说一下这个配置各个项的含义:

      1. =pages=字段 ------
         用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
      2. =window=字段 ------
         定义小程序所有页面的顶部背景颜色，文字颜色定义等。

      其他配置项细节可以参考文档 [[../config.html][小程序的配置 app.json]] 。

***** [[index_u12.html#工具配置-project-config-json][#]] 工具配置 project.config.json 
      通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编
      译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。

      考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个=project.config.json=，
      你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你
      只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性
      化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。

      其他配置项细节可以参考文档
      [[../../devtools/projectconfig.html][开发者工具的配置]] 。

***** [[index_u12.html#页面配置-page-json][#]] 页面配置 page.json
      这里的 =page.json= 其实用来表示 pages/logs 目录下的 =logs.json=这类和小程序页面
      相关的配置。

      如果你整个小程序的风格是蓝色调，那么你可以在 =app.json=里边声明顶部颜色是蓝色即
      可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同
      功能模块，因此我们提供了=page.json=，让开发者可以独立定义每个页面的一些属性，例
      如刚刚说的顶部颜色、是否允许下拉刷新等等。

      其他配置项细节可以参考文档 [[../config.html#页面配置][页面配置]] 。

***** [[index_u12.html#JSON-语法][#]] JSON 语法
      这里说一下小程序里 JSON 配置的一些注意事项。

      JSON 文件都是被包裹在一个大括号中{}，通过 key-value 的方式来表达数据。JSON
      的 Key 必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号
      或者是把双引号写成单引号是常见错误。

      JSON 的值只能是以下几种数据格式，其他任何格式都会触发报错，例如
      JavaScript 中的 undefined。

      1. 数字，包含浮点数和整数
      2. 字符串，需要包裹在双引号中
      3. Bool 值，true 或者 false
      4. 数组，需要包裹在方括号中 []
      5. 对象，需要包裹在大括号中 {}
      6. Null

      还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。

**** [[index_u12.html#WXML-模板][#]] WXML 模板
  从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 =HTML=
  是用来描述当前这个页面的结构，=CSS=用来描述页面的样子，=JS= 通常是用来处理这个
  页面和用户的交互。

  同样道理，在小程序中也有同样的角色，其中 =WXML= 充当的就是类似 =HTML=的角色。打
  开 =pages/index/index.wxml=，你会看到以下的内容:

  #+BEGIN_EXAMPLE
      <view class="container">
        <view class="userinfo">
          <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>
          <block wx:else>
            <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>
            <text class="userinfo-nickname">{{userInfo.nickName}}</text>
          </block>
        </view>
        <view class="usermotto">
          <text class="user-motto">{{motto}}</text>
        </view>
      </view>
  #+END_EXAMPLE

  和 =HTML= 非常相似，=WXML=由标签、属性等等构成。但是也有很多不一样的地方，我们
  来一一阐述一下：

  1. 标签名字有点不一样

     往往写 HTML 的时候，经常会用到的标签是 =div=, =p=, =span=，开发者在写一个页
     面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思
     路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高
     我们的开发效率。

     从上边的例子可以看到，小程序的 =WXML= 用的标签是 =view=, =button=, =text=等
     等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频
     等等组件能力。

     更多详细的组件讲述参考下个章节 [[file:framework.html][小程序的能力]]

  2. 多了一些 =wx:if= 这样的属性以及 {{ }} 这样的表达式

     在网页的一般开发流程中，我们通常会通过 =JS= 操作 =DOM= (对应 =HTML=
     的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，=JS=
     会记录一些状态到 =JS= 变量里边，同时通过 =DOM= API 操控 =DOM=
     的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了
     MVVM 的开发模式（例如 React,
     Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 =JS= 直接操控
     =DOM=，=JS=
     只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。

     小程序的框架也是用到了这个思路，如果你需要把一个 =Hello World=
     的字符串显示在界面上。

     WXML 是这么写 :

     #+BEGIN_HTML
       <div class="calibre6">
     #+END_HTML

     #+BEGIN_EXAMPLE
         <text>{{msg}}</text>
     #+END_EXAMPLE

     #+BEGIN_HTML
       </div>
     #+END_HTML

     JS 只需要管理状态即可:

     #+BEGIN_HTML
       <div class="calibre6">
     #+END_HTML

     #+BEGIN_EXAMPLE
         this.setData({ msg: "Hello World" })
     #+END_EXAMPLE

     #+BEGIN_HTML
       </div>
     #+END_HTML

     通过 {{ }}
     的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要
     =if=/=else=, =for=等控制能力，在小程序里边，这些控制能力都用 =wx:=
     开头的属性来表达。

  更详细的文档可以参考 [[../view/wxml][WXML]]

**** [[index_u12.html#WXSS-样式][#]] WXSS 样式
     :PROPERTIES:
     :CUSTOM_ID: index_u12.html#WXSS-样式
     :CLASS:    calibre11
     :END:

  =WXSS= 具有 =CSS= 大部分的特性，小程序在 =WXSS= 也做了一些扩充和修改。

  1. 新增了尺寸单位。在写 =CSS=
     样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。=WXSS=
     在底层支持新的尺寸单位 =rpx=
     ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。

  2. 提供了全局的样式和局部样式。和前边 =app.json=, =page.json=
     的概念相同，你可以写一个 =app.wxss=
     作为全局样式，会作用于当前小程序的所有页面，局部页面样式 =page.wxss=
     仅对当前页面生效。

  3. 此外 =WXSS= 仅支持部分 =CSS= 选择器

  更详细的文档可以参考 [[../view/wxss.html][WXSS]] 。

**** [[index_u12.html#JS-逻辑交互][#]] JS 逻辑交互
     :PROPERTIES:
     :CUSTOM_ID: index_u12.html#JS-逻辑交互
     :CLASS:    calibre11
     :END:

  一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写
  =JS= 脚本文件来处理用户的操作。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view>{{ msg }}</view>
      <button bindtap="clickMe">点击我</button>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  点击 =button= 按钮的时候，我们希望把界面上 =msg= 显示成
  ="Hello World"=，于是我们在 =button= 上声明一个属性: =bindtap= ，在 JS
  文件里边声明了 =clickMe= 方法来响应这次点击操作：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        clickMe: function() {
          this.setData({ msg: "Hello World" })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  响应用户的操作就是这么简单，更详细的事件可以参考文档
  [[../view/wxml/event.html][WXML - 事件]] 。

  此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API
  可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的
  QuickStart 例子中，在 =pages/index/index.js= 就调用了
  [[../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
  获取微信用户的头像和昵称，最后通过 =setData=
  把获取到的信息显示到界面上。更多 API 可以参考文档
  [[../app-service/api.html][小程序的API]] 。

  通过这个章节，你了解了小程序涉及到的文件类型以及对应的角色，在[[file:framework.html][下个章节]]中，我们把这一章所涉及到的文件通过
  “小程序的框架” 给 “串” 起来，让他们都工作起来。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html#JS-%E9%80%BB%E8%BE%91%E4%BA%A4%E4%BA%92][https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html#JS-逻辑交互]]

  \\
  \\
  | [[../index_u67.html#article_14][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u20.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_16/index_u73.html][下一项]] |
  [[../index_u67.html#article_15][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_14/index_u12.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u20.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u10.html#小程序宿主环境][#]] 小程序宿主环境
    :PROPERTIES:
    :CUSTOM_ID: index_u10.html#小程序宿主环境
    :CLASS:    calibre9
    :END:

  我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。

  上一章中我们把小程序涉及到的文件类型阐述了一遍，我们结合 QuickStart
  这个项目来讲一下这些文件是怎么配合工作的。

**** [[index_u10.html#渲染层和逻辑层][#]] 渲染层和逻辑层
     :PROPERTIES:
     :CUSTOM_ID: index_u10.html#渲染层和逻辑层
     :CLASS:    calibre11
     :END:

  首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中
  WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

  小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView
  进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。

  [[file:feed_0/article_18/images/img1_u6.png]]

  有关渲染层和逻辑层的详细文档参考 [[../MINA.html][小程序框架]] 。

**** [[index_u10.html#程序与页面][#]] 程序与页面
     :PROPERTIES:
     :CUSTOM_ID: index_u10.html#程序与页面
     :CLASS:    calibre11
     :END:

  微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。

  紧接着通过 =app.json= 的 =pages=
  字段就可以知道你当前小程序的所有页面路径:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "pages":[
          "pages/index/index",
          "pages/logs/logs"
        ]
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这个配置说明在 QuickStart 项目定义了两个页面，分别位于
  =pages/index/index= 和 =pages/logs/logs=。而写在 =pages=
  字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。

  于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。

  小程序启动之后，在 =app.js= 定义的 =App= 实例的 =onLaunch= 回调会被执行:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        onLaunch: function () {
          // 小程序启动之后 触发
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档
  [[../app-service/app.html][注册程序 App]] 。

  接下来我们简单看看小程序的一个页面是怎么写的。

  你可以观察到 =pages/logs/logs=
  下其实是包括了 4 种文件的，微信客户端会先根据 =logs.json=
  配置生成一个界面，顶部的颜色和文字你都可以在这个 =json=
  文件里边定义好。紧接着客户端就会装载这个页面的 =WXML= 结构和 =WXSS=
  样式。最后客户端会装载 =logs.js=，你可以看到 =logs.js= 的大体内容就是:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        data: { // 参与页面渲染的数据
          logs: []
        },
        onLoad: function () {
          // 页面渲染后 执行
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  =Page=
  是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把
  =data= 数据和 =index.wxml=
  一起渲染出最终的结构，于是就得到了你看到的小程序的样子。

  在渲染完界面之后，页面实例就会收到一个 =onLoad=
  的回调，你可以在这个回调处理你的逻辑。

  有关于 =Page= 构造器更多详细的文档参考
  [[../app-service/page.html][注册页面 Page]] 。

**** [[index_u10.html#组件][#]] 组件
     :PROPERTIES:
     :CUSTOM_ID: index_u10.html#组件
     :CLASS:    calibre11
     :END:

  小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。

  就像 =HTML= 的 =div=, =p= 等标签一样，在小程序里边，你只需要在 =WXML=
  写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <map></map>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的
  longitude（中心经度） 和 latitude（中心纬度）两个属性:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <map longitude="广州经度" latitude="广州纬度"></map>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在
  =js= 编写 =markertap= 函数来处理：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  当然你也可以通过 =style= 或者 =class=
  来控制组件的外层样式，以便适应你的界面宽度高度等等。

  更多的组件可以参考 [[../../component][小程序的组件]]。

**** [[index_u10.html#API][#]] API
     :PROPERTIES:
     :CUSTOM_ID: index_u10.html#API
     :CLASS:    calibre11
     :END:

  为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多
  API 给开发者去使用。

  要获取用户的地理位置时，只需要：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.getLocation({
        type: 'wgs84',
        success: (res) => {
          var latitude = res.latitude // 纬度
          var longitude = res.longitude // 经度
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  调用微信扫一扫能力，只需要：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.scanCode({
        success: (res) => {
          console.log(res)
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。

  更多的 API 能力见 [[../app-service/api.html][小程序的API]]。

  通过这个章节你已经大概了解了小程序运行的一些基本概念，当你开发完一个小程序之后，你就需要发布你的小程序。在[[file:release.html][下个章节]]，你会知道发布前需要做什么准备。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#API]]

  \\
  \\
  | [[../index_u67.html#article_19][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u54.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_21/index_u41.html][下一项]] |
  [[../index_u67.html#article_20][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_19/index_u10.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u54.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u40.html#小程序协同工作和发布][#]] 小程序协同工作和发布
    :PROPERTIES:
    :CUSTOM_ID: index_u40.html#小程序协同工作和发布
    :CLASS:    calibre9
    :END:

  在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作。

  以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问。在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在[[https://mp.weixin.qq.com][小程序后台<<>>]]发布小程序，用户可以通过搜索或者其它入口来进入该小程序。

  在这一章我们会把团队的协同工作的注意事项和小程序发布前后涉及的概念和流程做一些介绍。

**** [[index_u40.html#协同工作][#]] 协同工作
     :PROPERTIES:
     :CUSTOM_ID: index_u40.html#协同工作
     :CLASS:    calibre11
     :END:

  如果你只是一个人开发小程序，可以暂时先跳过这部分，如果是一个团队需要先了解一些概念。

  多数情况下，一个团队多人同时参与同一个小程序项目，每个角色所承担的工作或者权限不一样，中大公司的分工更为仔细。为了更形象的表达团队不同角色的关系以及权限的管理，我们通过虚拟一个项目成员组织结构来描述日常如何协同合作完成一个小程序的发布，组织关系如图 5-1 所示。

  [[file:feed_0/article_24/images/img1_u23.png]] 图 5-1 虚拟小程序项目组

  项目管理成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏，产品组提出需求，设计组与产品讨论并对需求进行抽象，设计出可视化流程与图形，输出设计方案。开发组依据设计方案，进行程序代码的编写，代码编写完成后，产品组与设计组体验小程序的整体流程，测试组编写测试用例并对小程序进行各种边界测试。项目一般的成员构成与工作流程如图 5-2 所示。

  [[file:feed_0/article_24/images/img2_u12.png]] 图 5-2
  提需求到发布小程序的流程

***** [[index_u40.html#小程序成员管理][#]] 小程序成员管理
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#小程序成员管理
      :CLASS:    calibre25
      :END:

  小程序成员管理包括对小程序项目成员及体验成员的管理。

  -  项目成员：表示参与小程序开发、运营的成员，可登录小程序管理后台，包括运营者、开发者及数据分析者。管理员可在“成员管理”中添加、删除项目成员，并设置项目成员的角色。

  -  体验成员：表示参与小程序内测体验的成员，可使用体验版小程序，但不属于项目成员。管理员及项目成员均可添加、删除体验成员。

  不同项目成员拥有不同的权限，从而保证小程序开发安全有序。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 权限             | 运营者   | 开发者   | 数据分析者   |
  |------------------+----------+----------+--------------|
  | 开发者权限       |          | √        |              |
  | 体验者权限       | √        | √        | √            |
  | 登录             | √        | √        | √            |
  | 数据分析         |          |          | √            |
  | 微信支付         | √        |          |              |
  | 推广             | √        |          |              |
  | 开发管理         | √        |          |              |
  | 开发设置         |          | √        |              |
  | 暂停服务         | √        |          |              |
  | 解除关联公众号   | √        |          |              |
  | 腾讯云管理       |          | √        |              |
  | 小程序插件       | √        |          |              |
  | 游戏运营管理     | √        |          |              |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  各权限功能说明

  -  开发者权限：可使用小程序开发者工具及开发版小程序进行开发
  -  体验者权限：可使用体验版小程序
  -  登录：可登录小程序管理后台，无需管理员确认
  -  数据分析：使用小程序统计模块功能查看小程序数据
  -  微信支付：使用小程序微信支付（虚拟支付）模块
  -  推广：使用小程序流量主、广告主模块
  -  开发管理：小程序提交审核、发布、回退
  -  开发设置：设置小程序服务器域名、消息推送及扫描普通链接二维码打开小程序
  -  暂停服务设置：暂停小程序线上服务
  -  解除关联公众号：可解绑小程序已关联的公众号
  -  小程序插件：可进行小程序插件开发管理和设置
  -  游戏运营管理：可使用小游戏管理后台的素材管理、游戏圈管理等功能

  需要留意，项目管理者控制整个小程序的发布、回退、下架等敏感操作，不应把敏感操作的权限分配给不相关人员

**** [[index_u40.html#小程序的版本][#]] 小程序的版本
     :PROPERTIES:
     :CUSTOM_ID: index_u40.html#小程序的版本
     :CLASS:    calibre11
     :END:

  一般的软件开发流程，开发者编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，开发者会把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的 Bug 后发布供外部用户正式使用。小程序的版本根据这个流程设计了小程序版本的概念，如表 5-3 所示。

  表 5-3 小程序的版本

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | *权限*       | *说明*                                                                                         |
  |--------------+------------------------------------------------------------------------------------------------|
  | 开发版本     | 使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。\\          |
  |              | 点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。             |
  | 体验版本     | 可以选择某个开发版本作为体验版，并且选取一份体验版。                                           |
  | 审核中版本   | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。   |
  | 线上版本     | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。                           |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  考虑到项目是协同开发的模式，一个小程序可能同时由多个开发者进行开发，往往开发者在小程序开发者工具上编写完代码后需要到手机进行真机体验，所以每个开发者拥有自己对应的一个开发版本。因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版，为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。

**** [[index_u40.html#发布上线][#]] 发布上线
     :PROPERTIES:
     :CUSTOM_ID: index_u40.html#发布上线
     :CLASS:    calibre11
     :END:

  一个小程序从开发完到上线一般要经过 预览-> 上传代码 -> 提交审核 ->
  发布等步骤。

***** [[index_u40.html#预览][#]] 预览
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#预览
      :CLASS:    calibre25
      :END:

  使用开发者工具可以预览小程序，帮助开发者检查小程序在移动客户端上的真实表现。

  点击开发者工具顶部操作栏的预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。

***** [[index_u40.html#上传代码][#]] 上传代码
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#上传代码
      :CLASS:    calibre25
      :END:

  同预览不同，上传代码是用于提交体验或者审核使用的。

  点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注，需要注意的是，这里版本号以及项目备注是为了方便管理员检查版本使用的，开发者可以根据自己的实际要求来填写这两个字段。

  上传成功之后，登录[[https://mp.weixin.qq.com][小程序管理后台<<>>]] -
  开发管理 - 开发版本 就可以找到刚提交上传的版本了。

  可以将这个版本设置 体验版 或者是 提交审核

***** [[index_u40.html#提交审核][#]] 提交审核
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#提交审核
      :CLASS:    calibre25
      :END:

  为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。

  在开发者工具中上传了小程序代码之后，登录
  [[https://mp.weixin.qq.com][小程序管理后台<<>>]] - 开发管理 - 开发版本
  找到提交上传的版本。

  在开发版本的列表中，点击 *提交审核*
  按照页面提示，填写相关的信息，即可以将小程序提交审核。

  需要注意的是，*请开发者严格测试了版本之后，再提交审核*，
  过多的审核不通过，可能会影响后续的时间。

***** [[index_u40.html#发布][#]] 发布
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#发布
      :CLASS:    calibre25
      :END:

  审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时登录
  [[https://mp.weixin.qq.com][小程序管理后台<<>>]] - 开发管理 -
  审核版本中可以看到通过审核的版本。

  点击发布后，即可发布小程序。小程序提供了两种发布模式：全量发布和分阶段发布。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。一般来说，普通小程序发布时采用全量发布即可，当小程序承载的功能越来越多，使用的用户数越来越多时，采用分阶段发布是一个非常好的控制风险的办法。

***** [[index_u40.html#小程序码][#]] 小程序码
      :PROPERTIES:
      :CUSTOM_ID: index_u40.html#小程序码
      :CLASS:    calibre25
      :END:

  很多场景下用户会通过扫码快速进入一个小程序，在小程序设计的初期，小程序平台提供的二维码的形式。我们发现用户在扫一个二维码时，他并不知道当前这次扫码会出现什么样的服务，因为二维码的背后有可能是公众号、小程序、网页服务、支付页面、添加好友等不同的服务。为了让用户在扫码之前就有一个明确的预期，因此微信设计了小程序码，如图 5-3 所示。

  [[file:feed_0/article_24/images/img3_u4.png]]

  图 5-3 “小程序数据助手”的小程序码

  小程序码在样式上更具辨识度和视觉冲击力，相对于二维码来说，小程序主题的品牌形象更加清晰明显，可以帮助开发者更好地推广小程序。在发布小程序之后，小程序管理平台会提供对应的小程序码的预览和下载，开发者可以自行下载用于线上和线下的小程序服务推广。

**** [[index_u40.html#运营数据][#]] 运营数据
     :PROPERTIES:
     :CUSTOM_ID: index_u40.html#运营数据
     :CLASS:    calibre11
     :END:

  有两种方式可以方便的看到小程序的[[https://developers.weixin.qq.com/miniprogram/analysis/index.html][运营数据<<>>]]

  方法一：

  登录 [[https://mp.weixin.qq.com][小程序管理后台<<>>]] - 数据分析

  点击相应的 tab 可以看到相关的数据。

  方法二：

  使用小程序数据助手，在微信中方便的查看运营数据

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E8%BF%90%E8%90%A5%E6%95%B0%E6%8D%AE][https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#运营数据]]

  \\
  \\
  | [[../index_u67.html#article_24][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u66.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_27/index_u39.html][下一项]] |
  [[../index_u67.html#article_26][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_25/index.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u66.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

* 目录结构
  :PROPERTIES:
  :CUSTOM_ID: index_u66.html#目录结构
  :CLASS: calibre9
  :END:

小程序包含一个描述整体程序的 =app= 和多个描述各自页面的 =page=。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

| 文件                                    | 必需   | 作用               |
|-----------------------------------------+--------+--------------------|
| [[file:app-service/app.html][app.js]]   | 是     | 小程序逻辑         |
| [[file:config.html][app.json]]          | 是     | 小程序公共配置     |
| [[file:view/wxss.html][app.wxss]]       | 否     | 小程序公共样式表   |

#+BEGIN_HTML
  </div>
#+END_HTML

一个小程序页面由四个文件组成，分别是：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

| 文件类型                              | 必需   | 作用         |
|---------------------------------------+--------+--------------|
| [[file:app-service/page.html][js]]    | 是     | 页面逻辑     |
| [[file:view/wxml][wxml]]              | 是     | 页面结构     |
| [[file:config.html#页面配置][json]]   | 否     | 页面配置     |
| [[file:view/wxss.html][wxss]]         | 否     | 页面样式表   |

#+BEGIN_HTML
  </div>
#+END_HTML

*注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。*

*** [[index_u66.html#允许上传的文件][#]] 允许上传的文件
    :PROPERTIES:
    :CUSTOM_ID: index_u66.html#允许上传的文件
    :CLASS: calibre25
    :END:

在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：/.js、app.json、/.wxml、*.wxss（其中
wxml 和 wxss 文件仅针对在 app.json
中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传，不在白名单列表内文件在开发工具能被访问到，但无法被上传。具体白名单列表如下：

1.  wxs
2.  png
3.  jpg
4.  jpeg
5.  gif
6.  svg
7.  json
8.  cer
9.  mp3
10. aac
11. m4a
12. mp4
13. wav
14. ogg
15. silk

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html]]

\\
\\
| [[../index_u67.html#article_26][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u39.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_28/index_u86.html][下一项]] |
[[../index_u67.html#article_27][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_26/index_u66.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u39.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

* 小程序配置
  :PROPERTIES:
  :CUSTOM_ID: index_u58.html#小程序配置
  :CLASS: calibre9
  :END:

** [[index_u58.html#全局配置][#]] 全局配置
   :PROPERTIES:
   :CUSTOM_ID: index_u58.html#全局配置
   :CLASS: calibre11
   :END:

小程序根目录下的 =app.json=
文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多
tab 等。

完整配置项说明请参考[[../reference/configuration/app.html][小程序全局配置]]

以下是一个包含了部分常用配置选项的 =app.json= ：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    {
      "pages": [
        "pages/index/index",
        "pages/logs/index"
      ],
      "window": {
        "navigationBarTitleText": "Demo"
      },
      "tabBar": {
        "list": [{
          "pagePath": "pages/index/index",
          "text": "首页"
        }, {
          "pagePath": "pages/logs/index",
          "text": "日志"
        }]
      },
      "networkTimeout": {
        "request": 10000,
        "downloadFile": 10000
      },
      "debug": true,
      "navigateToMiniProgramAppIdList": [
        "wxe5f52902cf4de896"
      ]
    }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

完整配置项说明请参考[[../reference/configuration/app.html][小程序全局配置]]

** [[index_u58.html#页面配置][#]] 页面配置
   :PROPERTIES:
   :CUSTOM_ID: index_u58.html#页面配置
   :CLASS: calibre11
   :END:

每一个小程序页面也可以使用同名 =.json=
文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 =app.json= 的
=window= 中相同的配置项。

完整配置项说明请参考[[../reference/configuration/page.html][小程序页面配置]]

例如：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    {
      "navigationBarBackgroundColor": "#ffffff",
      "navigationBarTextStyle": "black",
      "navigationBarTitleText": "微信接口功能演示",
      "backgroundColor": "#eeeeee",
      "backgroundTextStyle": "light"
    }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE][https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置]]

\\
\\
| [[../index_u67.html#article_29][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u87.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_31/index_u93.html][下一项]] |
[[../index_u67.html#article_30][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_29/index_u58.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u87.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

微信现已开放小程序内搜索，开发者可以通过 =sitemap.json=
配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。
爬虫访问小程序内页面时，会携带特定的 user-agent：=mpcrawler=
及[[../reference/scene-list.html][场景值]]：=1129=。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。

具体配置说明

1. 页面收录设置：可对整个小程序的索引进行关闭，小程序管理后台-功能-页面内容接入-页面收录开关；[[https://mp.weixin.qq.com/wxopen/readtemplate?t=config/collection_agreement_tmpl][详情<<>>]]
2. sitemap 配置：可对特定页面的索引进行关闭

** [[index_u87.html#sitemap-配置][#]] sitemap 配置
   :PROPERTIES:
   :CUSTOM_ID: index_u87.html#sitemap-配置
   :CLASS:    calibre9
   :END:

 小程序根目录下的 =sitemap.json=
 文件用来配置小程序及其页面是否允许被微信索引。

 完整配置项说明请参考[[../reference/configuration/sitemap.html][小程序
 sitemap 配置]]

 *例 1：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "rules":[{
         "action": "allow",
         "page": "*"
       }]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 所有页面都会被微信索引（默认情况）

 *例 2：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "rules":[{
         "action": "disallow",
         "page": "path/to/page"
       }]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 配置 =path/to/page= 页面不被索引，其余页面允许被索引

 *例 3：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "rules":[{
         "action": "allow",
         "page": "path/to/page"
       }, {
         "action": "disallow",
         "page": "*"
       }]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 配置 =path/to/page= 页面被索引，其余页面不被索引

 *例 4：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "rules":[{
         "action": "allow",
         "page": "path/to/page",
         "params": ["a", "b"],
         "matching": "inclusive"
       }, {
         "action": "allow",
         "page": "*"
       }]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 包含 =a 和 b= 参数的 =path/to/page=
 页面会被微信优先索引，其他页面都会被索引，例如：

 -  =path/to/page?a=1&b=2= => 优先被索引
 -  =path/to/page?a=1&b=2&c=3= => 优先被索引
 -  =path/to/page= => 被索引
 -  =path/to/page?a=1= => 被索引
 -  其他页面都会被索引

 *例 5：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "rules":[{
         "action": "allow",
         "page": "path/to/page",
         "params": ["a", "b"],
         "matching": "inclusive"
       }, {
         "action": "disallow",
         "page": "*"
       }, {
         "action": "allow",
         "page": "*"
       }]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 -  =path/to/page?a=1&b=2= => 优先被索引
 -  =path/to/page?a=1&b=2&c=3= => 优先被索引
 -  =path/to/page= => 不被索引
 -  =path/to/page?a=1= => 不被索引
 -  其他页面由于命中第二条规则，所以不会被索引
 -  由于优先级的问题，第三条规则是没有意义的

 *注：没有 sitemap.json 则默认所有页面都能被索引*

 *注：={"action": "allow", "page": "*"}=
 是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引*

*** [[index_u87.html#如何调试][#]] 如何调试
    :PROPERTIES:
    :CUSTOM_ID: index_u87.html#如何调试
    :CLASS:    calibre11
    :END:

 当在小程序项目中设置了 =sitemap= 的配置文件（默认为
 =sitemap.json=）时,便可在开发者工具控制台上显示当前页面是否被索引的调试信息（
 最新版本的开发者工具支持索引提示）

 [[file:feed_0/article_30/images/img1_u12.png]]

 *注：=sitemap= 的索引提示是默认开启的，如需要关闭 =sitemap=
 的索引提示，可在小程序项目配置文件 =project.config.json= 的 =setting=
 中配置字段 =checkSiteMap= 为 =false=*

 *注: =sitemap= 文件内容最大为 5120 个 UTF8 字符*

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html]]

 \\
 \\
 | [[../index_u67.html#article_30][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u93.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_32/index_u33.html][下一项]] |
 [[../index_u67.html#article_31][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_30/index_u87.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u93.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

* 框架

小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生
APP 体验的服务。

整个小程序框架系统分为两部分：*[[file:app-service][逻辑层]]*（App
Service）和
*[[file:view][视图层]]*（View）。小程序提供了自己的视图层描述语言 =WXML=
和 =WXSS=，以及基于 =JavaScript=
的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

*** [[index_u93.html#响应的数据绑定][#]] 响应的数据绑定
    :PROPERTIES:
    :CUSTOM_ID: index_u93.html#响应的数据绑定
    :CLASS: calibre25
    :END:

框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。

通过这个简单的例子来看：

[[https://developers.weixin.qq.com/s/l0gLEKmv6gZa][在开发者工具中预览效果<<>>]]

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    <!-- This is our View -->
    <view> Hello {{name}}! </view>
    <button bindtap="changeName"> Click me! </button>
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    // This is our App Service.
    // This is our data.
    var helloData = {
      name: 'Weixin'
    }

    // Register a Page.
    Page({
      data: helloData,
      changeName: function(e) {
        // sent data change to view
        this.setData({
          name: 'MINA'
        })
      }
    })
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

-  开发者通过框架将逻辑层数据中的 =name= 与视图层的 =name=
   进行了绑定，所以在页面一打开的时候会显示 =Hello Weixin!=；
-  当点击按钮的时候，视图层会发送 =changeName=
   的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
-  回调函数触发后，逻辑层执行 =setData= 的操作，将 =data= 中的 =name= 从
   =Weixin= 变为
   =MINA=，因为该数据和视图层已经绑定了，从而视图层会自动改变为
   =Hello MINA!=。

*** [[index_u93.html#页面管理][#]] 页面管理
    :PROPERTIES:
    :CUSTOM_ID: index_u93.html#页面管理
    :CLASS: calibre25
    :END:

框架
管理了整个*小程序*的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到
框架 中，其他的一切复杂的操作都交由 框架 处理。

*** [[index_u93.html#基础组件][#]] 基础组件
    :PROPERTIES:
    :CUSTOM_ID: index_u93.html#基础组件
    :CLASS: calibre25
    :END:

框架
提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的*微信小程序*
。

*** [[index_u93.html#丰富的-API][#]] 丰富的 API
    :PROPERTIES:
    :CUSTOM_ID: index_u93.html#丰富的-API
    :CLASS: calibre25
    :END:

框架 提供丰富的微信原生
API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html]]

\\
\\
| [[../index_u67.html#article_31][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u33.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_33/index_u88.html][下一项]] |
[[../index_u67.html#article_32][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_31/index_u93.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u33.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

** [[index_u33.html#场景值][#]] 场景值
   :PROPERTIES:
   :CUSTOM_ID: index_u33.html#场景值
   :CLASS:    calibre9
   :END:

 #+BEGIN_QUOTE
   基础库 1.1.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 场景值用来描述用户进入小程序的路径。完整场景值的含义请查看[[../../reference/scene-list.html][场景值列表]]。

 由于 Android 系统限制，目前还无法获取到按 Home
 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。

***** [[index_u33.html#获取场景值][#]] 获取场景值
      :PROPERTIES:
      :CUSTOM_ID: index_u33.html#获取场景值
      :CLASS:    calibre26
      :END:

 开发者可以通过下列方式获取场景值：

 -  对于小程序，可以在 =App= 的 =onLaunch= 和
    =onShow=，或[[../../api/base/app/life-cycle/wx.getLaunchOptionsSync.html][wx.getLaunchOptionsSync]]
    中获取上述场景值。
 -  对于小游戏，可以在
    [[../../api/base/app/life-cycle/wx.getLaunchOptionsSync.html][wx.getLaunchOptionsSync]]
    和 [[file:%28wx.onShow%29][wx.onShow]] 中获取上述场景值

***** [[index_u33.html#返回来源信息的场景][#]] 返回来源信息的场景
      :PROPERTIES:
      :CUSTOM_ID: index_u33.html#返回来源信息的场景
      :CLASS:    calibre26
      :END:

 部分场景值下还可以获取来源应用、公众号或小程序的 appId。获取方式请参考对应 API 的参考文档。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 场景值   | 场景                              | appId 含义    |
 |----------+-----------------------------------+--------------|
 | 1020     | 公众号 profile 页相关小程序列表   | 来源公众号   |
 | 1035     | 公众号自定义菜单                  | 来源公众号   |
 | 1036     | App 分享消息卡片                  | 来源 App      |
 | 1037     | 小程序打开小程序                  | 来源小程序   |
 | 1038     | 从另一个小程序返回                | 来源小程序   |
 | 1043     | 公众号模板消息                    | 来源公众号   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html]]

 \\
 \\
 | [[../index_u67.html#article_32][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u88.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_34/index_u89.html][下一项]] |
 [[../index_u67.html#article_33][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_32/index_u33.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u88.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u88.html#逻辑层-App-Service][#]] 逻辑层 App Service
   :PROPERTIES:
   :CUSTOM_ID: index_u88.html#逻辑层-App-Service
   :CLASS:    calibre9
   :END:

 小程序开发框架的逻辑层使用 =JavaScript= 引擎为小程序提供开发者
 =JavaScript= 代码的运行环境以及微信小程序的特有功能。

 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

 开发者写的所有代码最终将会打包成一份 =JavaScript=
 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似
 [[https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API][ServiceWorker<<>>]]，所以逻辑层也称之为
 App Service。

 在 =JavaScript= 的基础上，我们增加了一些功能，以方便小程序的开发：

 -  增加 =App= 和 =Page=
    方法，进行[[file:app.html][程序注册]]和[[file:page.html][页面注册]]。
 -  增加 =getApp= 和 =getCurrentPages= 方法，分别用来获取 =App=
    实例和当前页面栈。
 -  提供丰富的
    [[file:api.html][API]]，如微信用户数据，扫一扫，支付等微信特有能力。
 -  提供[[file:module.html#模块化][模块化]]能力，每个页面有独立的[[file:module.html#文件作用域][作用域]]。

 *注意：小程序框架的逻辑层并非运行在浏览器中，因此 =JavaScript= 在 web
 中一些能力都无法使用，如 =window=，=document= 等。*

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/]]

 \\
 \\
 | [[../index_u67.html#article_33][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u89.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_35/index_u51.html][下一项]] |
 [[../index_u67.html#article_34][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_33/index_u88.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u89.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u89.html#注册小程序][#]] 注册小程序
    :PROPERTIES:
    :CUSTOM_ID: index_u89.html#注册小程序
    :CLASS:    calibre9
    :END:

  每个小程序都需要在 =app.js= 中调用 =App=
  方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

  详细的参数含义和使用请参考 [[../../reference/api/App.html][App
  参考文档]] 。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // app.js
      App({
        onLaunch (options) {
          // Do something initial when launch.
        },
        onShow (options) {
          // Do something when show.
        },
        onHide () {
          // Do something when hide.
        },
        onError (msg) {
          console.log(msg)
        },
        globalData: 'I am global data'
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 =getApp=
  方法获取到全局唯一的 App 实例，获取 App 上的数据或调用开发者注册在 =App=
  上的函数。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // xxx.js
      const appInstance = getApp()
      console.log(appInstance.globalData) // I am global data
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html]]

  \\
  \\
  | [[../index_u67.html#article_34][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u51.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_36/index_u19.html][下一项]] |
  [[../index_u67.html#article_35][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_34/index_u89.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u51.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u51.html#注册页面][#]] 注册页面
    :PROPERTIES:
    :CUSTOM_ID: index_u51.html#注册页面
    :CLASS:    calibre9
    :END:

  对于小程序中的每个页面，都需要在页面对应的 =js=
  文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

**** [[index_u51.html#使用-Page-构造器注册页面][#]] 使用 Page
  构造器注册页面
     :PROPERTIES:
     :CUSTOM_ID: index_u51.html#使用-Page-构造器注册页面
     :CLASS: calibre11
     :END:

  简单的页面可以使用 =Page()= 进行构造。

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      //index.js
      Page({
        data: {
          text: "This is page data."
        },
        onLoad: function(options) {
          // 页面创建时执行
        },
        onShow: function() {
          // 页面出现在前台时执行
        },
        onReady: function() {
          // 页面首次渲染完毕时执行
        },
        onHide: function() {
          // 页面从前台变为后台时执行
        },
        onUnload: function() {
          // 页面销毁时执行
        },
        onPullDownRefresh: function() {
          // 触发下拉刷新时执行
        },
        onReachBottom: function() {
          // 页面触底时执行
        },
        onShareAppMessage: function () {
          // 页面被用户分享时执行
        },
        onPageScroll: function() {
          // 页面滚动时执行
        },
        onResize: function() {
          // 页面尺寸变化时执行
        },
        onTabItemTap(item) {
          // tab 点击时执行
          console.log(item.index)
          console.log(item.pagePath)
          console.log(item.text)
        },
        // 事件响应函数
        viewTap: function() {
          this.setData({
            text: 'Set some data for updating view.'
          }, function() {
            // this is setData callback
          })
        },
        // 自由数据
        customData: {
          hi: 'MINA'
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  详细的参数含义和使用请参考 [[../../reference/api/Page.html][Page
  参考文档]] 。

**** [[index_u51.html#在页面中使用-behaviors][#]] 在页面中使用 behaviors
     :PROPERTIES:
     :CUSTOM_ID: index_u51.html#在页面中使用-behaviors
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.9.2 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  页面可以引用 behaviors 。 behaviors
  可以用来让多个页面有相同的数据字段和方法。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // my-behavior.js
      module.exports = Behavior({
        data: {
          sharedText: 'This is a piece of data shared between pages.'
        },
        methods: {
          sharedMethod: function() {
            this.data.sharedText === 'This is a piece of data shared between pages.'
          }
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page-a.js
      var myBehavior = require('./my-behavior.js')
      Page({
        behaviors: [myBehavior],
        onLoad: function() {
          this.data.sharedText === 'This is a piece of data shared between pages.'
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  具体用法参见 [[../custom-component/behaviors.html][behaviors]] 。

**** [[index_u51.html#使用-Component-构造器构造页面][#]] 使用 Component
  构造器构造页面
     :PROPERTIES:
     :CUSTOM_ID: index_u51.html#使用-Component-构造器构造页面
     :CLASS: calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 1.6.3 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  =Page= 构造器适用于简单的页面。但对于复杂的页面， =Page=
  构造器可能并不好用。

  此时，可以使用 =Component= 构造器来构造页面。 =Component=
  构造器的主要区别是：方法需要放在 =methods: { }= 里面。

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Component({
        data: {
          text: "This is page data."
        },
        methods: {
          onLoad: function(options) {
            // 页面创建时执行
          },
          onPullDownRefresh: function() {
            // 下拉刷新时执行
          },
          // 事件响应函数
          viewTap: function() {
            // ...
          }
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这种创建方式非常类似于 [[../custom-component][自定义组件]]
  ，可以像自定义组件一样使用 =behaviors= 等高级特性。

  具体细节请阅读 [[../custom-component/component.html][=Component=
  构造器]] 章节。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html]]

  \\
  \\
  | [[../index_u67.html#article_35][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u19.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_37/index_u17.html][下一项]] |
  [[../index_u67.html#article_36][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_35/index_u51.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u19.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u19.html#生命周期][#]] 生命周期
     :PROPERTIES:
     :CUSTOM_ID: index_u19.html#生命周期
     :CLASS:    calibre11
     :END:

  *以下内容你不需要立马完全弄明白，不过以后它会有帮助。*

  下图说明了页面 =Page= 实例的生命周期。

  [[file:feed_0/article_36/images/img1_u18.png]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html]]

  \\
  \\
  | [[../index_u67.html#article_36][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u17.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_38/index_u44.html][下一项]] |
  [[../index_u67.html#article_37][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_36/index_u19.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u17.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u17.html#页面路由][#]] 页面路由
    :PROPERTIES:
    :CUSTOM_ID: index_u17.html#页面路由
    :CLASS:    calibre9
    :END:

  在小程序中所有页面的路由全部由框架进行管理。

***** [[index_u17.html#页面栈][#]] 页面栈
      :PROPERTIES:
      :CUSTOM_ID: index_u17.html#页面栈
      :CLASS:    calibre25
      :END:

  框架以栈的形式维护了当前的所有页面。
  当发生路由切换的时候，页面栈的表现如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 路由方式     | 页面栈表现                          |
  |--------------+-------------------------------------|
  | 初始化       | 新页面入栈                          |
  | 打开新页面   | 新页面入栈                          |
  | 页面重定向   | 当前页面出栈，新页面入栈            |
  | 页面返回     | 页面不断出栈，直到目标返回页        |
  | Tab 切换     | 页面全部出栈，只留下新的 Tab 页面   |
  | 重加载       | 页面全部出栈，只留下新的页面        |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  开发者可以使用 =getCurrentPages()= 函数获取当前页面栈。

***** [[index_u17.html#路由方式][#]] 路由方式
      :PROPERTIES:
      :CUSTOM_ID: index_u17.html#路由方式
      :CLASS:    calibre25
      :END:

  对于路由的触发方式以及页面生命周期函数如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 路由方式     | 触发时机                                                                               | 路由前页面   | 路由后页面           |
  |--------------+----------------------------------------------------------------------------------------+--------------+----------------------|
  | 初始化       | 小程序打开的第一个页面                                                                 |              | onLoad, onShow       |
  | 打开新页面   | 调用 API [[../../api/route/wx.navigateTo.html][wx.navigateTo]]\\                       | onHide       | onLoad, onShow       |
  |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="navigateTo"/>=]]     |              |                      |
  | 页面重定向   | 调用 API [[../../api/route/wx.redirectTo.html][wx.redirectTo]]\\                       | onUnload     | onLoad, onShow       |
  |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="redirectTo"/>=]]     |              |                      |
  | 页面返回     | 调用 API [[../../api/route/wx.navigateBack.html][wx.navigateBack]]\\                   | onUnload     | onShow               |
  |              | 使用组件[[../../component/navigator.html][=<navigator open-type="navigateBack">=]]\\   |              |                      |
  |              | 用户按左上角返回按钮                                                                   |              |                      |
  | Tab 切换     | 调用 API [[../../api/route/wx.switchTab.html][wx.switchTab]]\\                         |              | 各种情况请参考下表   |
  |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="switchTab"/>=]]\\    |              |                      |
  |              | 用户切换 Tab                                                                           |              |                      |
  | 重启动       | 调用 API [[../../api/route/wx.reLaunch.html][wx.reLaunch]]\\                           | onUnload     | onLoad, onShow       |
  |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="reLaunch"/>=]]       |              |                      |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A
  页面打开的页面，D 页面是从 C 页面打开的页面为例）：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 当前页面          | 路由后页面      | 触发的生命周期（按顺序）                             |
  |-------------------+-----------------+------------------------------------------------------|
  | A                 | A               | Nothing happend                                      |
  | A                 | B               | A.onHide(), B.onLoad(), B.onShow()                   |
  | A                 | B（再次打开）   | A.onHide(), B.onShow()                               |
  | C                 | A               | C.onUnload(), A.onShow()                             |
  | C                 | B               | C.onUnload(), B.onLoad(), B.onShow()                 |
  | D                 | B               | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   |
  | D（从转发进入）   | A               | D.onUnload(), A.onLoad(), A.onShow()                 |
  | D（从转发进入）   | B               | D.onUnload(), B.onLoad(), B.onShow()                 |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *Tips*:

  -  =navigateTo=, =redirectTo= 只能打开非 tabBar 页面。
  -  =switchTab= 只能打开 tabBar 页面。
  -  =reLaunch= 可以打开任意页面。
  -  页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有
     tabBar。
  -  调用页面路由带的参数可以在目标页面的=onLoad=中获取。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html]]

  \\
  \\
  | [[../index_u67.html#article_37][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u44.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_39/index_u57.html][下一项]] |
  [[../index_u67.html#article_38][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_37/index_u17.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u44.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u44.html#模块化][#]] 模块化
     :PROPERTIES:
     :CUSTOM_ID: index_u44.html#模块化
     :CLASS:    calibre11
     :END:

  可以将一些公共的代码抽离成为一个单独的 js
  文件，作为一个模块。模块只有通过
  [[../../reference/api/module.html][=module.exports=]] 或者 =exports=
  才能对外暴露接口。

  注意：

  -  =exports= 是 [[../../reference/api/module.html][=module.exports=]]
     的一个引用，因此在模块里边随意更改 =exports=
     的指向会造成未知的错误。所以更推荐开发者采用 =module.exports=
     来暴露模块接口，除非你已经清晰知道这两者的关系。
  -  小程序目前不支持直接引入 =node_modules= , 开发者需要使用到
     =node_modules=
     时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的
     [[../../devtools/npm.html][npm]] 功能。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // common.js
      function sayHello(name) {
        console.log(`Hello ${name} !`)
      }
      function sayGoodbye(name) {
        console.log(`Goodbye ${name} !`)
      }

      module.exports.sayHello = sayHello
      exports.sayGoodbye = sayGoodbye
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  在需要使用这些模块的文件中，使用 =require= 将公共代码引入

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      var common = require('common.js')
      Page({
        helloMINA: function() {
          common.sayHello('MINA')
        },
        goodbyeMINA: function() {
          common.sayGoodbye('MINA')
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u44.html#文件作用域][#]] 文件作用域
      :PROPERTIES:
      :CUSTOM_ID: index_u44.html#文件作用域
      :CLASS:    calibre25
      :END:

  在 JavaScript
  文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

  通过全局函数 =getApp= 可以获取全局的应用实例，如果需要全局的数据可以在
  =App()= 中设置，如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // app.js
      App({
        globalData: 1
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // a.js
      // The localValue can only be used in file a.js.
      var localValue = 'a'
      // Get the app instance.
      var app = getApp()
      // Get the global data and change it.
      app.globalData++
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // b.js
      // You can redefine localValue in file b.js, without interference with the localValue in a.js.
      var localValue = 'b'
      // If a.js it run before b.js, now the globalData shoule be 2.
      console.log(getApp().globalData)
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html]]

  \\
  \\
  | [[../index_u67.html#article_38][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u57.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_40/index_u61.html][下一项]] |
  [[../index_u67.html#article_39][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_38/index_u44.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u57.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u57.html#API][#]] API
    :PROPERTIES:
    :CUSTOM_ID: index_u57.html#API
    :CLASS:    calibre9
    :END:

  小程序开发框架提供丰富的微信原生
  API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考
  [[../../api/index.html][API 文档]]。

  通常，在小程序 API 有以下几种类型：

**** [[index_u57.html#事件监听-API][#]] 事件监听 API
     :PROPERTIES:
     :CUSTOM_ID: index_u57.html#事件监听-API
     :CLASS:    calibre11
     :END:

  我们约定，以 =on= 开头的 API
  用来监听某个事件是否触发，如：[[../../api/network/websocket/wx.onSocketOpen.html][wx.onSocketOpen]]，[[../../api/device/compass/wx.onCompassChange.html][wx.onCompassChange]]
  等。

  这类 API
  接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

  *代码示例*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.onCompassChange(function (res) {
        console.log(res.direction)
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u57.html#同步-API][#]] 同步 API
     :PROPERTIES:
     :CUSTOM_ID: index_u57.html#同步-API
     :CLASS:    calibre11
     :END:

  我们约定，以 =Sync= 结尾的 API 都是同步 API， 如
  [[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]，[[../../api/base/system/system-info/wx.getSystemInfoSync.html][wx.getSystemInfoSync]]
  等。此外，也有一些其他的同步 API，如
  [[../../api/worker/wx.createWorker.html][wx.createWorker]]，[[../../api/media/background-audio/wx.getBackgroundAudioManager.html][wx.getBackgroundAudioManager]]
  等，详情参见 API 文档中的说明。

  同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

  *代码示例*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      try {
        wx.setStorageSync('key', 'value')
      } catch (e) {
        console.error(e)
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u57.html#异步-API][#]] 异步 API
     :PROPERTIES:
     :CUSTOM_ID: index_u57.html#异步-API
     :CLASS:    calibre11
     :END:

  大多数 API 都是异步 API，如
  [[../../api/network/request/wx.request.html][wx.request]]，[[../../api/open-api/login/wx.login.html][wx.login]]
  等。这类 API 接口通常都接受一个 =Object=
  类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

  *Object 参数说明*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数名     | 类型       | 必填   | 说明                                               |
  |------------+------------+--------+----------------------------------------------------|
  | success    | function   | 否     | 接口调用成功的回调函数                             |
  | fail       | function   | 否     | 接口调用失败的回调函数                             |
  | complete   | function   | 否     | 接口调用结束的回调函数（调用成功、失败都会执行）   |
  | 其他       | Any        | -      | 接口定义的其他参数                                 |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *回调函数的参数*

  =success=，=fail=，=complete= 函数调用时会传入一个 =Object=
  类型参数，包含以下字段：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性      | 类型     | 说明                                                                   |
  |-----------+----------+------------------------------------------------------------------------|
  | errMsg    | string   | 错误信息，如果调用成功返回 =${apiName}:ok=                             |
  | errCode   | number   | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 =0=。   |
  | 其他      | Any      | 接口返回的其他数据                                                     |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  异步 API 的执行结果需要通过 =Object=
  类型的参数中传入的对应回调函数获取。部分异步 API
  也会有返回值，可以用来实现更丰富的功能，如
  [[../../api/network/request/wx.request.html][wx.request]]，[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
  等。

  *代码示例*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.login({
        success(res) {
          console.log(res.code)
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u57.html#异步-API-返回-Promise][#]] 异步 API 返回 Promise
     :PROPERTIES:
     :CUSTOM_ID: index_u57.html#异步-API-返回-Promise
     :CLASS:    calibre11
     :END:

  基础库 [[../compatibility.html][2.10.2]] 版本起，异步 API 支持 callback
  & promise 两种调用方式。当接口参数 Object 对象中不包含
  success/fail/complete 时将默认返回
  promise，否则仍按回调方式执行，无返回值。

****** [[index_u57.html#注意事项][#]] 注意事项
       :PROPERTIES:
       :CUSTOM_ID: index_u57.html#注意事项
       :CLASS:    calibre26
       :END:

  1. 部分接口如 =downloadFile=, =request=, =uploadFile=, =connectSocket=,
     =createCamera=（小游戏）本身就有返回值， 它们的 promisify
     需要开发者自行封装。
  2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail
     逻辑， 会报错提示 =Uncaught (in promise)=，开发者可通过 catch
     来进行捕获。
  3. [[../../api/base/app/app-event/wx.onUnhandledRejection.html][wx.onUnhandledRejection]]
     可以监听未处理的 Promise 拒绝事件。

  *代码示例*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // callback 形式调用
      wx.chooseImage({
        success(res) {
          console.log('res:', res)
        }
      })

      // promise 形式调用
      wx.chooseImage().then(res => console.log('res: ', res))
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html]]

  \\
  \\
  | [[../index_u67.html#article_39][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u61.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_41/index_u22.html][下一项]] |
  [[../index_u67.html#article_40][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_39/index_u57.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u61.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

** [[index_u61.html#视图层-View][#]] 视图层 View
   :PROPERTIES:
   :CUSTOM_ID: index_u61.html#视图层-View
   :CLASS:    calibre9
   :END:

 框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

 将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

 WXML(WeiXin Markup language) 用于描述页面的结构。

 WXS(WeiXin Script) 是小程序的一套脚本语言，结合
 =WXML=，可以构建出页面的结构。

 WXSS(WeiXin Style Sheet) 用于描述页面的样式。

 组件(Component)是视图的基本组成单元。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/]]

 \\
 \\
 | [[../index_u67.html#article_40][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u22.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_42/index_u96.html][下一项]] |
 [[../index_u67.html#article_41][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_40/index_u61.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u22.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u22.html#WXML][#]] WXML
    :PROPERTIES:
    :CUSTOM_ID: index_u22.html#WXML
    :CLASS:    calibre9
    :END:

  WXML（WeiXin Markup
  Language）是框架设计的一套标签语言，结合[[../../../component][基础组件]]、[[file:event.html][事件系统]]，可以构建出页面的结构。

  要完整了解 WXML 语法，请参考[[../../../reference/wxml][WXML 语法参考]]。

  用以下一些简单的例子来看看 WXML 具有什么能力：

***** [[index_u22.html#数据绑定][#]] 数据绑定
      :PROPERTIES:
      :CUSTOM_ID: index_u22.html#数据绑定
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <view> {{message}} </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page.js
      Page({
        data: {
          message: 'Hello MINA!'
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u22.html#列表渲染][#]] 列表渲染
      :PROPERTIES:
      :CUSTOM_ID: index_u22.html#列表渲染
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <view wx:for="{{array}}"> {{item}} </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page.js
      Page({
        data: {
          array: [1, 2, 3, 4, 5]
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u22.html#条件渲染][#]] 条件渲染
      :PROPERTIES:
      :CUSTOM_ID: index_u22.html#条件渲染
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
      <view wx:elif="{{view == 'APP'}}"> APP </view>
      <view wx:else="{{view == 'MINA'}}"> MINA </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page.js
      Page({
        data: {
          view: 'MINA'
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u22.html#模板][#]] 模板
      :PROPERTIES:
      :CUSTOM_ID: index_u22.html#模板
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <template name="staffName">
        <view>
          FirstName: {{firstName}}, LastName: {{lastName}}
        </view>
      </template>

      <template is="staffName" data="{{...staffA}}"></template>
      <template is="staffName" data="{{...staffB}}"></template>
      <template is="staffName" data="{{...staffC}}"></template>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page.js
      Page({
        data: {
          staffA: {firstName: 'Hulk', lastName: 'Hu'},
          staffB: {firstName: 'Shang', lastName: 'You'},
          staffC: {firstName: 'Gideon', lastName: 'Lin'}
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  具体的能力以及使用方式在以下章节查看：

  [[../../../reference/wxml/data.html][数据绑定]]、[[../../../reference/wxml/list.html][列表渲染]]、[[../../../reference/wxml/conditional.html][条件渲染]]、[[../../../reference/wxml/template.html][模板]]、[[../../../reference/wxml/import.html][引用]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/]]

  \\
  \\
  | [[../index_u67.html#article_41][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u96.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_43/index_u71.html][下一项]] |
  [[../index_u67.html#article_42][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_41/index_u22.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u96.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u96.html#WXSS][#]] WXSS
    :PROPERTIES:
    :CUSTOM_ID: index_u96.html#WXSS
    :CLASS:    calibre9
    :END:

  WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

  WXSS 用来决定 WXML 的组件应该怎么显示。

  为了适应广大的前端开发者，WXSS 具有 CSS
  大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS
  进行了扩充以及修改。

  与 CSS 相比，WXSS 扩展的特性有：

  -  尺寸单位
  -  样式导入

***** [[index_u96.html#尺寸单位][#]] 尺寸单位
      :PROPERTIES:
      :CUSTOM_ID: index_u96.html#尺寸单位
      :CLASS:    calibre25
      :END:

  -  rpx（responsive pixel）:
     可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6
     上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px =
     750 物理像素，1rpx = 0.5px = 1 物理像素。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 设备           | rpx 换算 px (屏幕宽度/750)   | px 换算 rpx (750/屏幕宽度)   |
  |----------------+----------------------------+----------------------------|
  | iPhone5        | 1rpx = 0.42px              | 1px = 2.34rpx              |
  | iPhone6        | 1rpx = 0.5px               | 1px = 2rpx                 |
  | iPhone6 Plus   | 1rpx = 0.552px             | 1px = 1.81rpx              |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *建议：* 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。

  *注意：*
  在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

***** [[index_u96.html#样式导入][#]] 样式导入
      :PROPERTIES:
      :CUSTOM_ID: index_u96.html#样式导入
      :CLASS:    calibre25
      :END:

  使用=@import=语句可以导入外联样式表，=@import=后跟需要导入的外联样式表的相对路径，用=;=表示语句结束。

  *示例代码：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      /** common.wxss **/
      .small-p {
        padding:5px;
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      /** app.wxss **/
      @import "common.wxss";
      .middle-p {
        padding:15px;
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u96.html#内联样式][#]] 内联样式
      :PROPERTIES:
      :CUSTOM_ID: index_u96.html#内联样式
      :CLASS:    calibre25
      :END:

  框架组件上支持使用 style、class 属性来控制组件的样式。

  -  style：静态的样式统一写到 class 中。style
     接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style
     中，以免影响渲染速度。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view style="color:{{color}};" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  -  class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上=.=，样式类名之间用空格分隔。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view class="normal_view" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u96.html#选择器][#]] 选择器
      :PROPERTIES:
      :CUSTOM_ID: index_u96.html#选择器
      :CLASS:    calibre25
      :END:

  目前支持的选择器有：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 选择器             | 样例               | 样例描述                                         |
  |--------------------+--------------------+--------------------------------------------------|
  | .class             | =.intro=           | 选择所有拥有 class="intro" 的组件                |
  | #id                | =#firstname=       | 选择拥有 id="firstname" 的组件                   |
  | element            | =view=             | 选择所有 view 组件                               |
  | element, element   | =view, checkbox=   | 选择所有文档的 view 组件和所有的 checkbox 组件   |
  | ::after            | =view::after=      | 在 view 组件后边插入内容                         |
  | ::before           | =view::before=     | 在 view 组件前边插入内容                         |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u96.html#全局样式与局部样式][#]] 全局样式与局部样式
      :PROPERTIES:
      :CUSTOM_ID: index_u96.html#全局样式与局部样式
      :CLASS:    calibre25
      :END:

  定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss
  文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss
  中相同的选择器。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html]]

  \\
  \\
  | [[../index_u67.html#article_42][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u71.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_44/index_u100.html][下一项]] |
  [[../index_u67.html#article_43][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_42/index_u96.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u71.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u71.html#WXS][#]] WXS
    :PROPERTIES:
    :CUSTOM_ID: index_u71.html#WXS
    :CLASS:    calibre9
    :END:

  WXS（WeiXin Script）是小程序的一套脚本语言，结合
  =WXML=，可以构建出页面的结构。

***** [[index_u71.html#注意][#]] 注意
      :PROPERTIES:
      :CUSTOM_ID: index_u71.html#注意
      :CLASS:    calibre25
      :END:

  1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
  2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript
     一致。
  3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他
     JavaScript 文件中定义的函数，也不能调用小程序提供的 API。
  4. WXS 函数不能作为组件的事件回调。
  5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript
     代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。

  以下是一些使用 WXS 的简单示例，要完整了解 WXS
  语法，请参考[[../../../reference/wxs][WXS 语法参考]]。

***** [[index_u71.html#页面渲染][#]] 页面渲染
      :PROPERTIES:
      :CUSTOM_ID: index_u71.html#页面渲染
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <wxs module="m1">
      var msg = "hello world";

      module.exports.message = msg;
      </wxs>

      <view> {{m1.message}} </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  页面输出：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      hello world
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u71.html#数据处理][#]] 数据处理
      :PROPERTIES:
      :CUSTOM_ID: index_u71.html#数据处理
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // page.js
      Page({
        data: {
          array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--wxml-->
      <!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
      <wxs module="m1">
      var getMax = function(array) {
        var max = undefined;
        for (var i = 0; i < array.length; ++i) {
          max = max === undefined ?
            array[i] :
            (max >= array[i] ? max : array[i]);
        }
        return max;
      }

      module.exports.getMax = getMax;
      </wxs>

      <!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
      <view> {{m1.getMax(array)}} </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  页面输出：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      5
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/]]

  \\
  \\
  | [[../index_u67.html#article_43][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u100.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_45/index_u52.html][下一项]] |
  [[../index_u67.html#article_44][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_43/index_u71.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u100.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u100.html#事件][#]] 事件
    :PROPERTIES:
    :CUSTOM_ID: index_u100.html#事件
    :CLASS:    calibre9
    :END:

**** [[index_u100.html#什么是事件][#]] 什么是事件
     :PROPERTIES:
     :CUSTOM_ID: index_u100.html#什么是事件
     :CLASS:    calibre11
     :END:

  -  事件是视图层到逻辑层的通讯方式。
  -  事件可以将用户的行为反馈到逻辑层进行处理。
  -  事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。
  -  事件对象可以携带额外信息，如 id, dataset, touches。

**** [[index_u100.html#事件的使用方式][#]] 事件的使用方式
     :PROPERTIES:
     :CUSTOM_ID: index_u100.html#事件的使用方式
     :CLASS:    calibre11
     :END:

  -  在组件中绑定一个事件处理函数。

  如=bindtap=，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view id="tapTest" data-hi="Weixin" bindtap="tapName"> Click me! </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  -  在相应的 Page 定义中写上相应的事件处理函数，参数是 event。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        tapName: function(event) {
          console.log(event)
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  -  可以看到 log 出来的信息大致如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "type":"tap",
        "timeStamp":895,
        "target": {
          "id": "tapTest",
          "dataset":  {
            "hi":"Weixin"
          }
        },
        "currentTarget":  {
          "id": "tapTest",
          "dataset": {
            "hi":"Weixin"
          }
        },
        "detail": {
          "x":53,
          "y":14
        },
        "touches":[{
          "identifier":0,
          "pageX":53,
          "pageY":14,
          "clientX":53,
          "clientY":14
        }],
        "changedTouches":[{
          "identifier":0,
          "pageX":53,
          "pageY":14,
          "clientX":53,
          "clientY":14
        }]
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u100.html#使用WXS函数响应事件][#]] 使用 WXS 函数响应事件
     :PROPERTIES:
     :CUSTOM_ID: index_u100.html#使用 WXS 函数响应事件
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.4.4
    开始支持，低版本需做[[../../compatibility.html][兼容处理]]。
  #+END_QUOTE

  从基础库版本=2.4.4=开始，支持使用 WXS 函数绑定事件，WXS 函数接受 2 个参数，第一个是 event，在原有的 event 的基础上加了=event.instance=对象，第二个参数是=ownerInstance=，和=event.instance=一样是一个=ComponentDescriptor=对象。具体使用如下：

  -  在组件中绑定和注册事件处理的 WXS 函数。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <wxs module="wxs" src="./test.wxs"></wxs>
      <view id="tapTest" data-hi="Weixin" bindtap="{{wxs.tapName}}"> Click me! </view>
      **注：绑定的WXS函数必须用{{}}括起来**
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  -  test.wxs 文件实现 tapName 函数

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      function tapName(event, ownerInstance) {
        console.log('tap Weixin', JSON.stringify(event))
      }
      module.exports = {
        tapName: tapName
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  =ownerInstance=包含了一些方法，可以设置组件的样式和 class，具体包含的方法以及为什么要用 WXS 函数响应事件，请[[../interactive-animation.html][点击查看详情]]。

**** [[index_u100.html#事件详解][#]] 事件详解
     :PROPERTIES:
     :CUSTOM_ID: index_u100.html#事件详解
     :CLASS:    calibre11
     :END:

***** [[index_u100.html#事件分类][#]] 事件分类
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#事件分类
      :CLASS:    calibre25
      :END:

  事件分为冒泡事件和非冒泡事件：

  1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
  2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

  WXML 的冒泡事件列表：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 类型                 | 触发条件                                                                                 | 最低版本                               |
  |----------------------+------------------------------------------------------------------------------------------+----------------------------------------|
  | touchstart           | 手指触摸动作开始                                                                         |                                        |
  | touchmove            | 手指触摸后移动                                                                           |                                        |
  | touchcancel          | 手指触摸动作被打断，如来电提醒，弹窗                                                     |                                        |
  | touchend             | 手指触摸动作结束                                                                         |                                        |
  | tap                  | 手指触摸后马上离开                                                                       |                                        |
  | longpress            | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发   | [[../../compatibility.html][1.5.0]]    |
  | longtap              | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                                 |                                        |
  | transitionend        | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                |                                        |
  | animationstart       | 会在一个 WXSS animation 动画开始时触发                                                   |                                        |
  | animationiteration   | 会在一个 WXSS animation 一次迭代结束时触发                                               |                                        |
  | animationend         | 会在一个 WXSS animation 动画完成时触发                                                   |                                        |
  | touchforcechange     | 在支持 3D Touch 的 iPhone 设备，重按时会触发                                             | [[../../compatibility.html][1.9.90]]   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如
  [[../../../component/form.html][form]]
  的=submit=事件，[[../../../component/input.html][input]]
  的=input=事件，[[../../../component/scroll-view.html][scroll-view]]
  的=scroll=事件，(详见各个[[../../../component][组件]])*

***** [[index_u100.html#普通事件绑定][#]] 普通事件绑定
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#普通事件绑定
      :CLASS:    calibre25
      :END:

  事件绑定的写法类似于组件的属性，如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view bindtap="handleTap">
          Click here!
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果用户点击这个 view ，则页面的 =handleTap= 会被调用。

  事件绑定函数可以是一个数据绑定，如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view bindtap="{{ handlerName }}">
          Click here!
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  此时，页面的 =this.data.handlerName=
  必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。

  自基础库版本 [[../../compatibility.html][1.5.0]]
  起，在大多数组件和自定义组件中， =bind=
  后可以紧跟一个冒号，其含义不变，如 =bind:tap= 。基础库版本
  [[../../compatibility.html][2.8.1]] 起，在所有组件中开始提供这个支持。

***** [[index_u100.html#绑定并阻止事件冒泡][#]] 绑定并阻止事件冒泡
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#绑定并阻止事件冒泡
      :CLASS:    calibre25
      :END:

  除 =bind= 外，也可以用 =catch= 来绑定事件。与 =bind= 不同， =catch=
  会阻止事件向上冒泡。

  例如在下边这个例子中，点击 inner view
  会先后调用=handleTap3=和=handleTap2=(因为 tap 事件会冒泡到 middle view，而
  middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view
  会触发=handleTap2=，点击 outer view 会触发=handleTap1=。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view id="outer" bindtap="handleTap1">
        outer view
        <view id="middle" catchtap="handleTap2">
          middle view
          <view id="inner" bindtap="handleTap3">
            inner view
          </view>
        </view>
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#互斥事件绑定][#]] 互斥事件绑定
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#互斥事件绑定
      :CLASS:    calibre25
      :END:

  自基础库版本 [[../../compatibility.html][2.8.2]] 起，除 =bind= 和
  =catch= 外，还可以使用 =mut-bind= 来绑定事件。一个 =mut-bind=
  触发后，如果事件冒泡到其他节点上，其他节点上的 =mut-bind=
  绑定函数不会被触发，但 =bind= 绑定函数和 =catch= 绑定函数依旧会被触发。

  换而言之，所有 =mut-bind=
  是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 =bind= 和
  =catch= 的绑定效果。

  例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
  =handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view id="outer" mut-bind:tap="handleTap1">
        outer view
        <view id="middle" bindtap="handleTap2">
          middle view
          <view id="inner" mut-bind:tap="handleTap3">
            inner view
          </view>
        </view>
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#事件的捕获阶段][#]] 事件的捕获阶段
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#事件的捕获阶段
      :CLASS:    calibre25
      :END:

  自基础库版本 [[../../compatibility.html][1.5.0]]
  起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用=capture-bind=、=capture-catch=关键字，后者将中断捕获阶段和取消冒泡阶段。

  在下面的代码中，点击 inner view
  会先后调用=handleTap2=、=handleTap4=、=handleTap3=、=handleTap1=。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
        outer view
        <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
          inner view
        </view>
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果将上面代码中的第一个=capture-bind=改为=capture-catch=，将只触发=handleTap2=。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2">
        outer view
        <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
          inner view
        </view>
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#事件对象][#]] 事件对象
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#事件对象
      :CLASS:    calibre25
      :END:

  如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

  *BaseEvent 基础事件对象属性列表：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                                               | 类型      | 说明                             | 基础库版本                            |
  |----------------------------------------------------+-----------+----------------------------------+---------------------------------------|
  | [[index_u100.html#type][type]]                     | String    | 事件类型                         |                                       |
  | [[index_u100.html#timeStamp][timeStamp]]           | Integer   | 事件生成时的时间戳               |                                       |
  | [[index_u100.html#target][target]]                 | Object    | 触发事件的组件的一些属性值集合   |                                       |
  | [[index_u100.html#currenttarget][currentTarget]]   | Object    | 当前组件的一些属性值集合         |                                       |
  | [[index_u100.html#mark][mark]]                     | Object    | 事件标记数据                     | [[../../compatibility.html][2.7.1]]   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                                 | 类型     | 说明         |
  |--------------------------------------+----------+--------------|
  | [[index_u100.html#detail][detail]]   | Object   | 额外的信息   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                                                 | 类型    | 说明                                           |
  |------------------------------------------------------+---------+------------------------------------------------|
  | [[index_u100.html#touches][touches]]                 | Array   | 触摸事件，当前停留在屏幕中的触摸点信息的数组   |
  | [[index_u100.html#changedTouches][changedTouches]]   | Array   | 触摸事件，当前变化的触摸点信息的数组           |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *特殊事件： [[../../../component/canvas.html][canvas]]
  中的触摸事件不可冒泡，所以没有 currentTarget。*

***** [[index_u100.html#type][#]] type
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#type
      :CLASS:    calibre25
      :END:

  代表事件的类型。

***** [[index_u100.html#timeStamp][#]] timeStamp
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#timeStamp
      :CLASS:    calibre25
      :END:

  页面打开到触发事件所经过的毫秒数。

***** [[index_u100.html#target][#]] target
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#target
      :CLASS:    calibre25
      :END:

  触发事件的源组件。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                                   | 类型     | 说明                                              |
  |----------------------------------------+----------+---------------------------------------------------|
  | id                                     | String   | 事件源组件的 id                                    |
  | [[index_u100.html#dataset][dataset]]   | Object   | 事件源组件上由=data-=开头的自定义属性组成的集合   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#currentTarget][#]] currentTarget
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#currentTarget
      :CLASS:    calibre25
      :END:

  事件绑定的当前组件。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                                   | 类型     | 说明                                            |
  |----------------------------------------+----------+-------------------------------------------------|
  | id                                     | String   | 当前组件的 id                                    |
  | [[index_u100.html#dataset][dataset]]   | Object   | 当前组件上由=data-=开头的自定义属性组成的集合   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *说明： target 和 currentTarget 可以参考上例中，点击 inner view
  时，=handleTap3= 收到的事件对象 target 和 currentTarget 都是 inner，而
  =handleTap2= 收到的事件对象 target 就是 inner，currentTarget 就是
  middle。*

***** [[index_u100.html#dataset][#]] dataset
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#dataset
      :CLASS:    calibre25
      :END:

  在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。

  在 WXML 中，这些自定义数据以 =data-= 开头，多个单词由连字符 =-=
  连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：

  -  =data-element-type= ，最终会呈现为
     =event.currentTarget.dataset.elementType= ；
  -  =data-elementType= ，最终会呈现为
     =event.currentTarget.dataset.elementtype= 。

  *示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"> DataSet Test </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        bindViewTap:function(event){
          event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法
          event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#mark][#]] mark
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#mark
      :CLASS:    calibre25
      :END:

  在基础库版本 [[../../compatibility.html][2.7.1]] 以上，可以使用 =mark=
  来识别具体触发事件的 target 节点。此外， =mark=
  还可以用于承载一些自定义数据（类似于 =dataset= ）。

  当事件触发时，事件冒泡路径上所有的 =mark=
  会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 =mark= 。）

  *代码示例：*

  [[https://developers.weixin.qq.com/s/boDQoKmu7M7G][在开发者工具中预览效果<<>>]]

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view mark:myMark="last" bindtap="bindViewTap">
        <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮</button>
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  在上述 WXML 中，如果按钮被点击，将触发 =bindViewTap= 和 =bindButtonTap=
  两个事件，事件携带的 =event.mark= 将包含 =myMark= 和 =anotherMark=
  两项。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        bindViewTap: function(e) {
          e.mark.myMark === "last" // true
          e.mark.anotherMark === "leaf" // true
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  =mark= 和 =dataset= 很相似，主要区别在于： =mark=
  会包含从触发事件的节点到根节点上所有的 =mark:= 属性值；而 =dataset=
  仅包含一个节点的 =data-= 属性值。

  细节注意事项：

  -  如果存在同名的 =mark= ，父节点的 =mark= 会被子节点覆盖。
  -  在自定义组件中接收事件时， =mark= 不包含自定义组件外的节点的 =mark=
     。
  -  不同于 =dataset= ，节点的 =mark= 不会做连字符和大小写转换。

***** [[index_u100.html#touches][#]] touches
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#touches
      :CLASS:    calibre25
      :END:

  touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的
  touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。

****** [[index_u100.html#Touch-对象][#]] Touch 对象
       :PROPERTIES:
       :CUSTOM_ID: index_u100.html#Touch-对象
       :CLASS:    calibre26
       :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性               | 类型     | 说明                                                                   |
  |--------------------+----------+------------------------------------------------------------------------|
  | identifier         | Number   | 触摸点的标识符                                                         |
  | pageX, pageY       | Number   | 距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴        |
  | clientX, clientY   | Number   | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u100.html#CanvasTouch-对象][#]] CanvasTouch 对象
       :PROPERTIES:
       :CUSTOM_ID: index_u100.html#CanvasTouch-对象
       :CLASS:    calibre26
       :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性         | 类型     | 说明                                                                     | 特殊说明   |
  |--------------+----------+--------------------------------------------------------------------------+------------|
  | identifier   | Number   | 触摸点的标识符                                                           |            |
  | x, y         | Number   | 距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为 X 轴，纵向为 Y 轴   |            |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u100.html#changedTouches][#]] changedTouches
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#changedTouches
      :CLASS:    calibre25
      :END:

  changedTouches 数据格式同 touches。
  表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

***** [[index_u100.html#detail][#]] detail
      :PROPERTIES:
      :CUSTOM_ID: index_u100.html#detail
      :CLASS:    calibre25
      :END:

  自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见[[../../../component][组件]]定义中各个事件的定义。

  点击事件的=detail= 带有的 x, y 同 pageX, pageY
  代表距离文档左上角的距离。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html]]

  \\
  \\
  | [[../index_u67.html#article_44][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u52.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_46/index_u5.html][下一项]] |
  [[../index_u67.html#article_45][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_44/index_u100.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u52.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u52.html#WXS响应事件][#]] WXS 响应事件
     :PROPERTIES:
     :CUSTOM_ID: index_u52.html#WXS 响应事件
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.4.4 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

***** [[index_u52.html#背景][#]] 背景
      :PROPERTIES:
      :CUSTOM_ID: index_u52.html#背景
      :CLASS:    calibre25
      :END:

  有频繁用户交互的效果在小程序上表现是比较卡顿的，例如页面有 2 个元素 A 和
  B，用户在 A 上做 touchmove 手势，要求 B
  也跟随移动，[[../../component/movable-view.html][movable-view]]
  就是一个典型的例子。一次 touchmove 事件的响应过程为：

  a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）

  b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B
  的位置

  一次 touchmove 的响应需要经过 2
  次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 setData
  渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。

***** [[index_u52.html#实现方案][#]] 实现方案
      :PROPERTIES:
      :CUSTOM_ID: index_u52.html#实现方案
      :CLASS:    calibre25
      :END:

  本方案基本的思路是减少通信的次数，让事件在视图层（Webview）响应。小程序的框架分为视图层（Webview）和逻辑层（App
  Service），这样分层的目的是管控，开发者的代码只能运行在逻辑层（App
  Service），而这个思路就必须要让开发者的代码运行在视图层（Webview），如下图所示的流程：

  [[file:feed_0/article_45/images/img1_u3.png]]

  使用 [[file:wxs][WXS]]
  函数用来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件。WXS
  函数的除了纯逻辑的运算，还可以通过封装好的=ComponentDescriptor=
  实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class
  足够了。WXS 函数的例子如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      var wxsFunction = function(event, ownerInstance) {
          var instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例
          instance.setStyle({
              "font-size": "14px" // 支持rpx
          })
          instance.getDataset()
          instance.setClass(className)
          // ...
          return false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  其中入参 =event= 是小程序[[file:wxml/event.html][事件对象]]基础上多了
  =event.instance= 来表示触发事件的组件的 =ComponentDescriptor=
  实例。=ownerInstance= 表示的是触发事件的组件所在的组件的
  =ComponentDescriptor=
  实例，如果触发事件的组件是在页面内的，=ownerInstance= 表示的是页面实例。

  =ComponentDescriptor=的定义如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 方法                             | 参数                             | 描述                                                                                                 | 最低版本                            |
  |----------------------------------+----------------------------------+------------------------------------------------------------------------------------------------------+-------------------------------------|
  | selectComponent                  | selector 对象                     | 返回组件的 =ComponentDescriptor= 实例。                                                              |                                     |
  | selectAllComponents              | selector 对象数组                 | 返回组件的 =ComponentDescriptor= 实例数组。                                                          |                                     |
  | setStyle                         | Object/string                    | 设置组件样式，支持=rpx=。设置的样式优先级比组件 wxml 里面定义的样式高。不能设置最顶层页面的样式。    |                                     |
  | addClass/removeClass/ hasClass   | string                           | 设置组件的 class。设置的 class 优先级比组件 wxml 里面定义的 class 高。不能设置最顶层页面的 class。   |                                     |
  | getDataset                       | 无                               | 返回当前组件/页面的 dataset 对象                                                                     |                                     |
  | callMethod                       | (funcName:string, args:object)   | 调用当前组件/页面在逻辑层（App Service）定义的函数。funcName 表示函数名称，args 表示函数的参数。       |                                     |
  | requestAnimationFrame            | Function                         | 和原生 =requestAnimationFrame= 一样。用于设置动画。                                                  |                                     |
  | getState                         | 无                               | 返回一个 object 对象，当有局部变量需要存储起来后续使用的时候用这个方法。                               |                                     |
  | triggerEvent                     | (eventName, detail)              | 和组件的[[../custom-component/events.html][triggerEvent]]一致。                                      |                                     |
  | getComputedStyle                 | Array.<string>                   | 参数与 [[../../api/wxml/NodesRef.fields.html][SelectorQuery]] 的 =computedStyle= 一致。              | [[../compatibility.html][2.11.2]]   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  WXS
  运行在视图层（Webview），里面的逻辑毕竟能做的事件比较少，需要有一个机制和逻辑层（App
  Service）开发者的代码通信，上面的 =callMethod= 是 WXS
  里面调用逻辑层（App Service）开发者的代码的方法，而 =WxsPropObserver=
  是逻辑层（App Service）开发者的代码调用 WXS 逻辑的机制。

***** [[index_u52.html#使用方法][#]] 使用方法
      :PROPERTIES:
      :CUSTOM_ID: index_u52.html#使用方法
      :CLASS:    calibre25
      :END:

  -  WXML 定义事件：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <wxs module="test" src="./test.wxs"></wxs>
      <view change:prop="{{test.propObserver}}" prop="{{propValue}}" bindtouchmove="{{test.touchmove}}" class="movable"></view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  上面的=change:prop=（属性前面带 change:前缀）是在 prop
  属性被设置的时候触发 WXS 函数，值必须用={{}}=括起来。类似 Component
  定义的 properties 里面的 observer
  属性，在=setData({propValue: newValue})=调用之后会触发。

  *注意*：WXS 函数必须用={{}}=括起来。当 prop 的值被设置 WXS
  函数就会触发，而不只是值发生改变，所以在页面初始化的时候会调用一次=WxsPropObserver=的函数。

  -  WXS 文件=test.wxs=里面定义并导出事件处理函数和属性改变触发的函数：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      module.exports = {
          touchmove: function(event, instance) {
              console.log('log event', JSON.stringify(event))
          },
          propObserver: function(newValue, oldValue, ownerInstance, instance) {
              console.log('prop observer', newValue, oldValue)
          }
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  更多示例请查看[[https://developers.weixin.qq.com/s/L1G0Dkmc7G8a][在开发者工具中预览效果<<>>]]

***** [[index_u52.html#Tips][#]] Tips
      :PROPERTIES:
      :CUSTOM_ID: index_u52.html#Tips
      :CLASS:    calibre25
      :END:

  1. 目前还不支持[[../../component/native-component.html][原生组件]]的事件、[[../../component/input.html][input]]和[[../../component/textarea.html][textarea]]组件的
     bindinput 事件
  2. 1.02.1901170 及以后版本的开发者工具上支持交互动画，最低版本基础库是 2.4.4
  3. 目前在 WXS 函数里面仅支持 console.log 方式打日志定位问题，注意连续的重复日志会被过滤掉。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html]]

  \\
  \\
  | [[../index_u67.html#article_45][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u5.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_47/index_u56.html][下一项]] |
  [[../index_u67.html#article_46][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_45/index_u52.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u5.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u5.html#简易双向绑定][#]] 简易双向绑定
    :PROPERTIES:
    :CUSTOM_ID: index_u5.html#简易双向绑定
    :CLASS:    calibre9
    :END:

  #+BEGIN_QUOTE
    基础库 2.9.3 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

**** [[index_u5.html#双向绑定语法][#]] 双向绑定语法
     :PROPERTIES:
     :CUSTOM_ID: index_u5.html#双向绑定语法
     :CLASS:    calibre11
     :END:

  在 WXML 中，普通的属性的绑定是单向的。例如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <input value="{{value}}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果使用 =this.setData({ value: 'leaf' })= 来更新 =value=
  ，=this.data.value= 和输入框的中显示的值都会被更新为 =leaf=
  ；但如果用户修改了输入框里的值，却不会同时改变 =this.data.value= 。

  如果需要在用户输入的同时改变 =this.data.value=
  ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 =model:= 前缀：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <input model:value="{{value}}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这样，如果输入框的值被改变了， =this.data.value= 也会同时改变。同时，
  WXML 中所有绑定了 =value= 的位置也会被一同更新，
  [[../custom-component/observer.html][数据监听器]] 也会被正常触发。

  [[https://developers.weixin.qq.com/s/8jXvobmV7vcj][在开发者工具中预览效果<<>>]]

  用于双向绑定的表达式有如下限制：

  1. 只能是一个单一字段的绑定，如

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <input model:value="值为 {{value}}" />
      <input model:value="{{ a + b }}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  都是非法的；

  2. 目前，尚不能 data 路径，如

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <input model:value="{{ a.b }}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这样的表达式目前暂不支持。

**** [[index_u5.html#在自定义组件中传递双向绑定][#]]
  在自定义组件中传递双向绑定
     :PROPERTIES:
     :CUSTOM_ID: index_u5.html#在自定义组件中传递双向绑定
     :CLASS: calibre11
     :END:

  双向绑定同样可以使用在自定义组件上。如下的自定义组件：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // custom-component.js
      Component({
        properties: {
          myValue: String
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!-- custom-component.wxml -->
      <input model:value="{{myValue}}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这个自定义组件将自身的 =myValue= 属性双向绑定到了组件内输入框的 =value=
  属性上。这样，如果页面这样使用这个组件：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <custom-component model:my-value="{{pageValue}}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  当输入框的值变更时，自定义组件的 =myValue= 属性会同时变更，这样，页面的
  =this.data.pageValue= 也会同时变更，页面 WXML 中所有绑定了 =pageValue=
  的位置也会被一同更新。

**** [[index_u5.html#在自定义组件中触发双向绑定更新][#]]
  在自定义组件中触发双向绑定更新
     :PROPERTIES:
     :CUSTOM_ID: index_u5.html#在自定义组件中触发双向绑定更新
     :CLASS: calibre11
     :END:

  自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData
  设置自身的属性。例如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // custom-component.js
      Component({
        properties: {
          myValue: String
        },
        methods: {
          update: function() {
            // 更新 myValue
            this.setData({
              myValue: 'leaf'
            })
          }
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果页面这样使用这个组件：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <custom-component model:my-value="{{pageValue}}" />
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=
  也会同时变更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/two-way-bindings.html]]

  \\
  \\
  | [[../index_u67.html#article_46][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u56.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_48/index_u68.html][下一项]] |
  [[../index_u67.html#article_47][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_46/index_u5.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u56.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u56.html#基础组件][#]] 基础组件
    :PROPERTIES:
    :CUSTOM_ID: index_u56.html#基础组件
    :CLASS:    calibre9
    :END:

  框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考[[../../component][组件文档]]。

  什么是组件：

  -  组件是视图层的基本组成单元。
  -  组件自带一些功能与微信风格一致的样式。
  -  一个组件通常包括 =开始标签= 和 =结束标签=，=属性=
     用来修饰这个组件，=内容= 在两个标签之内。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <tagname property="value">
      Content goes here ...
      </tagname>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *注意：所有组件与属性都是小写，以连字符=-=连接*

***** [[index_u56.html#属性类型][#]] 属性类型
      :PROPERTIES:
      :CUSTOM_ID: index_u56.html#属性类型
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 类型           | 描述             | 注解                                                                                         |
  |----------------+------------------+----------------------------------------------------------------------------------------------|
  | Boolean        | 布尔值           | 组件写上该属性，不管是什么值都被当作 =true=；只有组件上没有该属性时，属性值才为=false=。\\   |
  |                |                  | 如果属性值为变量，变量的值会被转换为 Boolean 类型                                              |
  | Number         | 数字             | =1=, =2.5=                                                                                   |
  | String         | 字符串           | ="string"=                                                                                   |
  | Array          | 数组             | =[ 1, "string" ]=                                                                            |
  | Object         | 对象             | ={ key: value }=                                                                             |
  | EventHandler   | 事件处理函数名   | ="handlerName"= 是 [[../app-service/page.html][Page]] 中定义的事件处理函数名                 |
  | Any            | 任意属性         |                                                                                              |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u56.html#公共属性][#]] 公共属性
      :PROPERTIES:
      :CUSTOM_ID: index_u56.html#公共属性
      :CLASS:    calibre25
      :END:

  所有组件都有以下属性：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性名           | 类型           | 描述             | 注解                                       |
  |------------------+----------------+------------------+--------------------------------------------|
  | id               | String         | 组件的唯一标示   | 保持整个页面唯一                           |
  | class            | String         | 组件的样式类     | 在对应的 WXSS 中定义的样式类               |
  | style            | String         | 组件的内联样式   | 可以动态设置的内联样式                     |
  | hidden           | Boolean        | 组件是否显示     | 所有组件默认显示                           |
  | data-*           | Any            | 自定义属性       | 组件上触发的事件时，会发送给事件处理函数   |
  | bind* / catch*   | EventHandler   | 组件的事件       | 详见[[file:wxml/event.html][事件]]         |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u56.html#特殊属性][#]] 特殊属性
      :PROPERTIES:
      :CUSTOM_ID: index_u56.html#特殊属性
      :CLASS:    calibre25
      :END:

  几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个[[../../component][组件]]的定义。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/component.html]]

  \\
  \\
  | [[../index_u67.html#article_47][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u68.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_49/index_u26.html][下一项]] |
  [[../index_u67.html#article_48][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_47/index_u56.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u68.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u68.html#获取界面上的节点信息][#]] 获取界面上的节点信息
    :PROPERTIES:
    :CUSTOM_ID: index_u68.html#获取界面上的节点信息
    :CLASS:    calibre9
    :END:

**** [[index_u68.html#WXML节点信息][#]] WXML 节点信息
     :PROPERTIES:
     :CUSTOM_ID: index_u68.html#WXML 节点信息
     :CLASS:    calibre11
     :END:

  [[../../api/wxml/wx.createSelectorQuery.html][节点信息查询 API]]
  可以用于获取节点属性、样式、在界面上的位置等信息。

  最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

  *示例代码：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const query = wx.createSelectorQuery()
      query.select('#the-id').boundingClientRect(function(res){
        res.top // #the-id 节点的上边界坐标（相对于显示区域）
      })
      query.selectViewport().scrollOffset(function(res){
        res.scrollTop // 显示区域的竖直滚动位置
      })
      query.exec()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  上述示例中， =#the-id= 是一个节点选择器，与 CSS
  的选择器相近但略有区别，请参见
  [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]]
  的相关说明。

  在自定义组件或包含自定义组件的页面中，推荐使用
  =this.createSelectorQuery= 来代替
  [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
  ，这样可以确保在正确的范围内选择节点。

**** [[index_u68.html#WXML节点布局相交状态][#]] WXML 节点布局相交状态
     :PROPERTIES:
     :CUSTOM_ID: index_u68.html#WXML 节点布局相交状态
     :CLASS:    calibre11
     :END:

  [[../../api/wxml/wx.createIntersectionObserver.html][节点布局相交状态
  API]]
  可用于监听两个或多个组件节点在布局位置上的相交状态。这一组 API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

  这一组 API 涉及的主要概念如下。

  -  参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的
     *交集* 作为参照区域。页面显示区域也可作为参照区域之一。
  -  目标节点：监听的目标，默认只能是一个节点（使用 =selectAll=
     选项时，可以同时监听多个节点）。
  -  相交区域：目标节点的布局区域与参照区域的相交区域。
  -  相交比例：相交区域占参照区域的比例。
  -  阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

  以下示例代码可以在目标节点（用选择器 =.target-class=
  指定）每次进入或离开页面显示区域时，触发回调函数。

  *示例代码：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        onLoad: function(){
          wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
            res.id // 目标节点 id
            res.dataset // 目标节点 dataset
            res.intersectionRatio // 相交区域占目标节点的布局区域的比例
            res.intersectionRect // 相交区域
            res.intersectionRect.left // 相交区域的左边界坐标
            res.intersectionRect.top // 相交区域的上边界坐标
            res.intersectionRect.width // 相交区域的宽度
            res.intersectionRect.height // 相交区域的高度
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  以下示例代码可以在目标节点（用选择器 =.target-class=
  指定）与参照节点（用选择器 =.relative-class=
  指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的 20%和 50%时，触发回调函数。

  *示例代码：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        onLoad: function(){
          wx.createIntersectionObserver(this, {
            thresholds: [0.2, 0.5]
          }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
            res.intersectionRatio // 相交区域占目标节点的布局区域的比例
            res.intersectionRect // 相交区域
            res.intersectionRect.left // 相交区域的左边界坐标
            res.intersectionRect.top // 相交区域的上边界坐标
            res.intersectionRect.width // 相交区域的宽度
            res.intersectionRect.height // 相交区域的高度
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是“布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中
  overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。

  在自定义组件或包含自定义组件的页面中，推荐使用
  =this.createIntersectionObserver= 来代替
  [[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]
  ，这样可以确保在正确的范围内选择节点。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html]]

  \\
  \\
  | [[../index_u67.html#article_48][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u26.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_50/index_u59.html][下一项]] |
  [[../index_u67.html#article_49][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_48/index_u68.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u26.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u26.html#响应显示区域变化][#]] 响应显示区域变化
    :PROPERTIES:
    :CUSTOM_ID: index_u26.html#响应显示区域变化
    :CLASS:    calibre9
    :END:

**** [[index_u26.html#显示区域尺寸][#]] 显示区域尺寸
     :PROPERTIES:
     :CUSTOM_ID: index_u26.html#显示区域尺寸
     :CLASS:    calibre11
     :END:

  显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

***** [[index_u26.html#在手机上启用屏幕旋转支持][#]]
  在手机上启用屏幕旋转支持
      :PROPERTIES:
      :CUSTOM_ID: index_u26.html#在手机上启用屏幕旋转支持
      :CLASS: calibre25
      :END:

  从小程序基础库版本 [[../compatibility.html][2.4.0]]
  开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在
  =app.json= 的 =window= 段中设置 ="pageOrientation": "auto"= ，或在页面
  json 文件中配置 ="pageOrientation": "auto"= 。

  以下是在单个页面 json 文件中启用屏幕旋转的示例。

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "pageOrientation": "auto"
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

  从小程序基础库版本 [[../compatibility.html][2.5.0]] 开始，
  =pageOrientation= 还可以被设置为 =landscape= ，表示固定为横屏显示。

***** [[index_u26.html#在-iPad-上启用屏幕旋转支持][#]] 在 iPad
  上启用屏幕旋转支持
      :PROPERTIES:
      :CUSTOM_ID: index_u26.html#在-iPad-上启用屏幕旋转支持
      :CLASS: calibre25
      :END:

  从小程序基础库版本 [[../compatibility.html][2.3.0]] 开始，在 iPad
  上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在
  =app.json= 中添加 ="resizable": true= 。

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "resizable": true
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果小程序添加了上述声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。注意：在
  iPad 上不能单独配置某个页面是否支持屏幕旋转。

**** [[index_u26.html#Media-Query][#]] Media Query
     :PROPERTIES:
     :CUSTOM_ID: index_u26.html#Media-Query
     :CLASS:    calibre11
     :END:

  有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 media
  query 来解决大多数问题。

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      .my-class {
        width: 40px;
      }

      @media (min-width: 480px) {
        /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
        .my-class {
          width: 200px;
        }
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  在 WXML 中，可以使用 [[../../component/match-media.html][match-media]]
  组件来根据 media query 匹配状态展示、隐藏节点。

  此外，可以在页面或者自定义组件 JS 中使用
  =this.createMediaQueryObserver()= 方法来创建一个
  [[../../api/wxml/MediaQueryObserver.html][=MediaQueryObserver=]]
  对象，用于监听指定的 media query 的匹配状态。

  [[https://developers.weixin.qq.com/s/TtFaFjmb7aiy][在开发者工具中预览效果<<>>]]

**** [[index_u26.html#屏幕旋转事件][#]] 屏幕旋转事件
     :PROPERTIES:
     :CUSTOM_ID: index_u26.html#屏幕旋转事件
     :CLASS:    calibre11
     :END:

  有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js
  作为辅助。

  在 js 中读取页面的显示区域尺寸，可以使用
  [[../../api/wxml/SelectorQuery.selectViewport.html][selectorQuery.selectViewport]]
  。

  页面尺寸发生改变的事件，可以使用页面的 =onResize=
  来监听。对于自定义组件，可以使用 resize
  生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本
  [[../compatibility.html][2.4.0]] 开始支持。）

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        onResize(res) {
          res.size.windowWidth // 新的显示区域宽度
          res.size.windowHeight // 新的显示区域高度
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Component({
        pageLifetimes: {
          resize(res) {
            res.size.windowWidth // 新的显示区域宽度
            res.size.windowHeight // 新的显示区域高度
          }
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  此外，还可以使用
  [[../../api/ui/window/wx.onWindowResize.html][wx.onWindowResize]]
  来监听（但这不是推荐的方式）。

  *Bug & tips:*

  -  Bug： Android 微信版本 6.7.3 中， =live-pusher=
     组件在屏幕旋转时方向异常。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html]]

  \\
  \\
  | [[../index_u67.html#article_49][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u59.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_51/index_u95.html][下一项]] |
  [[../index_u67.html#article_50][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_49/index_u26.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u59.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u59.html#动画][#]] 动画
    :PROPERTIES:
    :CUSTOM_ID: index_u59.html#动画
    :CLASS:    calibre9
    :END:

**** [[index_u59.html#界面动画的常见方式][#]] 界面动画的常见方式
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#界面动画的常见方式
     :CLASS:    calibre11
     :END:

  在小程序中，通常可以使用
  [[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions][CSS
  渐变<<>>]] 和
  [[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations][CSS
  动画<<>>]] 来创建简易的界面动画。

  [[https://developers.weixin.qq.com/s/oHKxDPm47h5k][在开发者工具中预览效果<<>>]]

  动画过程中，可以使用 =bindtransitionend= =bindanimationstart=
  =bindanimationiteration= =bindanimationend= 来监听动画事件。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 事件名               | 含义                                                                                                 |
  |----------------------+------------------------------------------------------------------------------------------------------|
  | transitionend        | CSS 渐变结束或 [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]] 结束一个阶段   |
  | animationstart       | CSS 动画开始                                                                                         |
  | animationiteration   | CSS 动画结束一个阶段                                                                                 |
  | animationend         | CSS 动画结束                                                                                         |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  注意：这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。

  同时，还可以使用
  [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]
  接口来动态创建简易的动画效果。（新版小程序基础库中推荐使用下述的关键帧动画接口代替。）

**** [[index_u59.html#关键帧动画][#]] 关键帧动画
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#关键帧动画
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.9.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  从小程序基础库 [[../compatibility.html][2.9.0]]
  开始支持一种更友好的动画创建方式，用于代替旧的
  [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]
  。它具有更好的性能和更可控的接口。

  在页面或自定义组件中，当需要进行关键帧动画时，可以使用 =this.animate=
  接口：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      this.animate(selector, keyframes, duration, callback)
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *参数说明*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性        | 类型       | 默认值   | 必填   | 说明                                                                                           |
  |-------------+------------+----------+--------+------------------------------------------------------------------------------------------------|
  | selector    | String     |          | 是     | 选择器（同 [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]] 的选择器格式）   |
  | keyframes   | Array      |          | 是     | 关键帧信息                                                                                     |
  | duration    | Number     |          | 是     | 动画持续时长（毫秒为单位）                                                                     |
  | callback    | function   |          | 否     | 动画完成后的回调函数                                                                           |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *keyframes 中对象的结构*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性              | 类型            | 默认值   | 必填                                | 说明                                      |
  |-------------------+-----------------+----------+-------------------------------------+-------------------------------------------|
  | offset            | Number          |          | 否                                  | 关键帧的偏移，范围[0-1]                   |
  | ease              | String          | linear   | 否                                  | 动画缓动函数                              |
  | transformOrigin   | String          | 否       | 基点位置，即 CSS transform-origin   |                                           |
  | backgroundColor   | String          |          | 否                                  | 背景颜色，即 CSS background-color         |
  | bottom            | Number/String   |          | 否                                  | 底边位置，即 CSS bottom                   |
  | height            | Number/String   |          | 否                                  | 高度，即 CSS height                       |
  | left              | Number/String   |          | 否                                  | 左边位置，即 CSS left                     |
  | width             | Number/String   |          | 否                                  | 宽度，即 CSS width                        |
  | opacity           | Number          |          | 否                                  | 不透明度，即 CSS opacity                  |
  | right             | Number          |          | 否                                  | 右边位置，即 CSS right                    |
  | top               | Number/String   |          | 否                                  | 顶边位置，即 CSS top                      |
  | matrix            | Array           |          | 否                                  | 变换矩阵，即 CSS transform matrix         |
  | matrix3d          | Array           |          | 否                                  | 三维变换矩阵，即 CSS transform matrix3d   |
  | rotate            | Number          |          | 否                                  | 旋转，即 CSS transform rotate             |
  | rotate3d          | Array           |          | 否                                  | 三维旋转，即 CSS transform rotate3d       |
  | rotateX           | Number          |          | 否                                  | X 方向旋转，即 CSS transform rotateX      |
  | rotateY           | Number          |          | 否                                  | Y 方向旋转，即 CSS transform rotateY      |
  | rotateZ           | Number          |          | 否                                  | Z 方向旋转，即 CSS transform rotateZ      |
  | scale             | Array           |          | 否                                  | 缩放，即 CSS transform scale              |
  | scale3d           | Array           |          | 否                                  | 三维缩放，即 CSS transform scale3d        |
  | scaleX            | Number          |          | 否                                  | X 方向缩放，即 CSS transform scaleX       |
  | scaleY            | Number          |          | 否                                  | Y 方向缩放，即 CSS transform scaleY       |
  | scaleZ            | Number          |          | 否                                  | Z 方向缩放，即 CSS transform scaleZ       |
  | skew              | Array           |          | 否                                  | 倾斜，即 CSS transform skew               |
  | skewX             | Number          |          | 否                                  | X 方向倾斜，即 CSS transform skewX        |
  | skewY             | Number          |          | 否                                  | Y 方向倾斜，即 CSS transform skewY        |
  | translate         | Array           |          | 否                                  | 位移，即 CSS transform translate          |
  | translate3d       | Array           |          | 否                                  | 三维位移，即 CSS transform translate3d    |
  | translateX        | Number          |          | 否                                  | X 方向位移，即 CSS transform translateX   |
  | translateY        | Number          |          | 否                                  | Y 方向位移，即 CSS transform translateY   |
  | translateZ        | Number          |          | 否                                  | Z 方向位移，即 CSS transform translateZ   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u59.html#示例代码][#]] 示例代码
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#示例代码
     :CLASS:    calibre11
     :END:

  [[https://developers.weixin.qq.com/s/P73kJ7mi7UcA][在开发者工具中预览效果<<>>]]

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
        this.animate('#container', [
          { opacity: 1.0, rotate: 0, backgroundColor: '#FF0000' },
          { opacity: 0.5, rotate: 45, backgroundColor: '#00FF00'},
          { opacity: 0.0, rotate: 90, backgroundColor: '#FF0000' },
          ], 5000, function () {
            this.clearAnimation('#container', { opacity: true, rotate: true }, function () {
              console.log("清除了#container上的opacity和rotate属性")
            })
        }.bind(this))

        this.animate('.block', [
          { scale: [1, 1], rotate: 0, ease: 'ease-out'  },
          { scale: [1.5, 1.5], rotate: 45, ease: 'ease-in', offset: 0.9},
          { scale: [2, 2], rotate: 90 },
        ], 5000, function () {
          this.clearAnimation('.block', function () {
            console.log("清除了.block上的所有动画属性")
          })
        }.bind(this))
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  调用 animate API
  后会在节点上新增一些样式属性覆盖掉原有的对应样式。如果需要清除这些样式，可在该节点上的动画全部执行完毕后使用
  =this.clearAnimation= 清除这些属性。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      this.clearAnimation(selector, options, callback)
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *参数说明*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性       | 类型       | 默认值   | 必填   | 说明                                                                                           |
  |------------+------------+----------+--------+------------------------------------------------------------------------------------------------|
  | selector   | String     |          | 是     | 选择器（同 [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]] 的选择器格式）   |
  | options    | Object     |          | 否     | 需要清除的属性，不填写则全部清除                                                               |
  | callback   | Function   |          | 否     | 清除完成后的回调函数                                                                           |

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u59.html#滚动驱动的动画][#]] 滚动驱动的动画
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#滚动驱动的动画
     :CLASS:    calibre11
     :END:

  我们发现，根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库
  [[../compatibility.html][2.9.0]] 开始支持一种由滚动驱动的动画机制。

  基于上述的关键帧动画接口，新增一个 =ScrollTimeline=
  的参数，用来绑定滚动元素（目前只支持 scroll-view）。接口定义如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      this.animate(selector, keyframes, duration, ScrollTimeline)
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *ScrollTimeline 中对象的结构*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性                | 类型     | 默认值     | 必填   | 说明                                                                                              |
  |---------------------+----------+------------+--------+---------------------------------------------------------------------------------------------------|
  | scrollSource        | String   |            | 是     | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度                          |
  | orientation         | String   | vertical   | 否     | 指定滚动的方向。有效值为 horizontal 或 vertical                                                   |
  | startScrollOffset   | Number   |            | 是     | 指定开始驱动动画进度的滚动偏移量，单位 px                                                         |
  | endScrollOffset     | Number   |            | 是     | 指定停止驱动动画进度的滚动偏移量，单位 px                                                         |
  | timeRange           | Number   |            | 是     | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u59.html#示例代码-2][#]] 示例代码
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#示例代码-2
     :CLASS:    calibre11
     :END:

  [[https://developers.weixin.qq.com/s/994o8jmY7FcQ][在开发者工具中预览效果<<>>]]

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
        this.animate('.avatar', [{
          borderRadius: '0',
          borderColor: 'red',
          transform: 'scale(1) translateY(-20px)',
          offset: 0,
        }, {
          borderRadius: '25%',
          borderColor: 'blue',
          transform: 'scale(.65) translateY(-20px)',
          offset: .5,
        }, {
          borderRadius: '50%',
          borderColor: 'blue',
          transform: `scale(.3) translateY(-20px)`,
          offset: 1
        }], 2000, {
          scrollSource: '#scroller',
          timeRange: 2000,
          startScrollOffset: 0,
          endScrollOffset: 85,
        })

        this.animate('.search_input', [{
          opacity: '0',
          width: '0%',
        }, {
          opacity: '1',
          width: '100%',
        }], 1000, {
          scrollSource: '#scroller',
          timeRange: 1000,
          startScrollOffset: 120,
          endScrollOffset: 252
        })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

**** [[index_u59.html#高级的动画方式][#]] 高级的动画方式
     :PROPERTIES:
     :CUSTOM_ID: index_u59.html#高级的动画方式
     :CLASS:    calibre11
     :END:

  在一些复杂场景下，上述的动画方法可能并不适用。

  [[file:interactive-animation.html][WXS 响应事件]] 的方式可以通过使用 WXS
  来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style
  属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

  连续使用 setData
  来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的
  setData 改为 [[../custom-component][自定义组件]] 中的 setData
  来提升性能。下面的例子是使用 setData 来实现秒表动画的示例。

  [[https://developers.weixin.qq.com/s/cRTvdPmO7d5T][在开发者工具中预览效果<<>>]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html]]

  \\
  \\
  | [[../index_u67.html#article_50][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u95.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_52/index_u99.html][下一项]] |
  [[../index_u67.html#article_51][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_50/index_u59.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u95.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u95.html#初始渲染缓存][#]] 初始渲染缓存
    :PROPERTIES:
    :CUSTOM_ID: index_u95.html#初始渲染缓存
    :CLASS:    calibre9
    :END:

  #+BEGIN_QUOTE
    基础库 2.11.1
    开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

**** [[index_u95.html#初始渲染缓存工作原理][#]] 初始渲染缓存工作原理
     :PROPERTIES:
     :CUSTOM_ID: index_u95.html#初始渲染缓存工作原理
     :CLASS:    calibre11
     :END:

  小程序页面的初始化分为两个部分。

  -  逻辑层初始化：载入必需的小程序代码、初始化页面 this
     对象（也包括它涉及到的所有自定义组件的 this
     对象）、将相关数据发送给视图层。
  -  视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。

  在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

  启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始
  data
  的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

  -  在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
  -  在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
  -  如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

  利用初始渲染缓存，可以：

  -  快速展示出页面中永远不会变的部分，如导航栏；
  -  预先展示一个骨架页，提升用户体验；
  -  展示自定义的加载提示；
  -  提前展示广告，等等。

**** [[index_u95.html#支持的组件][#]] 支持的组件
     :PROPERTIES:
     :CUSTOM_ID: index_u95.html#支持的组件
     :CLASS:    calibre11
     :END:

  在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

  目前支持的内置组件：

  -  =<view />=
  -  =<text />=
  -  =<button />=
  -  =<image />=
  -  =<scroll-view />=
  -  =<rich-text />=

  自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**** [[index_u95.html#静态初始渲染缓存][#]] 静态初始渲染缓存
     :PROPERTIES:
     :CUSTOM_ID: index_u95.html#静态初始渲染缓存
     :CLASS:    calibre11
     :END:

  若想启用初始渲染缓存，最简单的方法是在页面的 =json= 文件中添加配置项
  ="initialRenderingCache": "static"= ：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "initialRenderingCache": "static"
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  如果想要对所有页面启用，可以在 =app.json= 的 =window=
  配置段中添加这个配置：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "window": {
          "initialRenderingCache": "static"
        }
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

  注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML
  上的结果，不包含任何 setData 的结果。

  例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 =loading=
  数据字段控制：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view wx:if="{{loading}}">正在加载</view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  这种情况下， =loading= 应当在 =data= 中指定为 =true= ，如：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // 正确的做法
      Page({
        data: {
          loading: true
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  而不能通过 =setData= 将 =loading= 置为 =true= ：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // 错误的做法！不要这么做！
      Page({
        data: {},
        onLoad: function() {
          this.setData({
            loading: true
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  换而言之，这种做法只包含页面 =data= 的渲染结果，即页面的纯静态成分。

**** [[index_u95.html#在初始渲染缓存中添加动态内容][#]]
  在初始渲染缓存中添加动态内容
     :PROPERTIES:
     :CUSTOM_ID: index_u95.html#在初始渲染缓存中添加动态内容
     :CLASS: calibre11
     :END:

  有些场景中，只是页面 =data=
  的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片
  URL 等。

  这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置
  ="initialRenderingCache": "dynamic"= ：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "initialRenderingCache": "dynamic"
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  此时，初始渲染缓存不会被自动启用，还需要在页面中调用
  =this.setInitialRenderingCache(dynamicData)= 才能启用。其中，
  =dynamicData= 是一组数据，与 =data= 一起参与页面 WXML 渲染。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        data: {
          loading: true
        },
        onReady: function() {
          this.setInitialRenderingCache({
            loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <view wx:if="{{loading}}">{{loadingHint}}</view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用
  =this.setInitialRenderingCache=
  ，如果在一个页面内多次调用，仅最后一次调用生效。

  注意：

  -  =this.setInitialRenderingCache= 调用时机不能早于 =Page= 的 =onReady=
     或 =Component= 的 =ready= 生命周期，否则可能对性能有负面影响。
  -  如果想禁用初始渲染缓存，调用 =this.setInitialRenderingCache(null)= 。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html]]

  \\
  \\
  | [[../index_u67.html#article_51][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u99.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_53/index_u23.html][下一项]] |
  [[../index_u67.html#article_52][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_51/index_u95.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u99.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

* [[index_u99.html#小程序的运行环境][#]] 小程序的运行环境
  :PROPERTIES:
  :CUSTOM_ID: index_u99.html#小程序的运行环境
  :CLASS: calibre9
  :END:

微信小程序运行在多种平台上：iOS（iPhone/iPad）微信客户端、Android
微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

-  在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore
   中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；

-  在 Android 上，小程序逻辑层的 javascript 代码运行在
   [[https://developers.google.com/v8/][V8<<>>]] 中，视图层是由自研 XWeb
   引擎基于 Mobile Chrome 内核来渲染的；

-  在 开发工具上，小程序逻辑层的 javascript 代码是运行在
   [[https://nwjs.io/][NW.js<<>>]] 中，视图层是由 Chromium Webview
   来渲染的。

*** [[index_u99.html#平台差异][#]] 平台差异
    :PROPERTIES:
    :CUSTOM_ID: index_u99.html#平台差异
    :CLASS: calibre25
    :END:

尽管各运行环境是十分相似的，但是还是有些许区别：

-  =JavaScript= 语法和 API 支持不一致：语法上开发者可以通过开启 =ES6= 转
   =ES5=
   的功能来规避（[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5][详情<<>>]]）；此外，小程序基础库内置了必要的 Polyfill，来弥补 API 的差异（[[file:js-support.html][详情]])。

-  =WXSS=
   渲染表现不一致：尽管可以通过开启[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#%E6%A0%B7%E5%BC%8F%E8%A1%A5%E5%85%A8][样式补全<<>>]]来规避大部分的问题，还是建议开发者需要在
   iOS 和 Android 上分别检查小程序的真实表现。

*开发者工具仅供调试使用，最终的表现以客户端为准。*

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html]]

\\
\\
| [[../index_u67.html#article_52][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u23.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_54/index_u2.html][下一项]] |
[[../index_u67.html#article_53][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_52/index_u99.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u23.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

** [[index_u2.html#JavaScript-支持情况][#]] JavaScript 支持情况
   :PROPERTIES:
   :CUSTOM_ID: index_u2.html#JavaScript-支持情况
   :CLASS:    calibre9
   :END:

*** [[index_u2.html#运行限制][#]] 运行限制
    :PROPERTIES:
    :CUSTOM_ID: index_u2.html#运行限制
    :CLASS:    calibre11
    :END:

 基于安全考虑，小程序中不支持动态执行 JS 代码，即：

 -  不支持使用 =eval= 执行 JS 代码
 -  不支持使用 =new Function= 创建函数

*** [[index_u2.html#客户端-ES6-API-支持情况][#]] 客户端 ES6 API 支持情况
 微信小程序已经支持了绝大部分的 ES6 API，已支持的 API 如下（部分 API 依赖系统版本）：
 
 | String                 | iOS10+   | Android   |
 |------------------------+----------+-----------|
 | codePointAt            |          |           |
 | normalize              |          |           |
 | includes               |          |           |
 | startsWith             |          |           |
 | endsWith               |          |           |
 | repeat                 |          |           |
 | String.fromCodePoint   |          |           |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | Array        | iOS10+   | Android   |
 |--------------+----------+-----------|
 | copyWithin   |          |           |
 | find         |          |           |
 | findIndex    |          |           |
 | fill         |          |           |
 | entries      |          |           |
 | keys         |          |           |
 | values       |          | ✘         |
 | includes     |          |           |
 | Array.from   |          |           |
 | Array.of     |          |           |

 | Number          | iOS10+   | Android   |
 |-----------------+----------+-----------|
 | isFinite        |          |           |
 | isNaN           |          |           |
 | parseInt        |          |           |
 | parseFloat      |          |           |
 | isInteger       |          |           |
 | EPSILON         |          |           |
 | isSafeInteger   |          |           |

 | Math     | iOS10+   | Android   |
 |----------+----------+-----------|
 | trunc    |          |           |
 | sign     |          |           |
 | cbrt     |          |           |
 | clz32    |          |           |
 | imul     |          |           |
 | fround   |          |           |
 | hypot    |          |           |
 | expm1    |          |           |
 | log1p    |          |           |
 | log10    |          |           |
 | log2     |          |           |
 | sinh     |          |           |
 | cosh     |          |           |
 | tanh     |          |           |
 | asinh    |          |           |
 | acosh    |          |           |
 | atanh    |          |           |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | Object                     | iOS10+   | Android   |
 |----------------------------+----------+-----------|
 | is                         |          |           |
 | assign                     |          |           |
 | getOwnPropertyDescriptor   |          |           |
 | keys                       |          |           |
 | getOwnPropertyNames        |          |           |
 | getOwnPropertySymbols      |          |           |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | Other     | iOS10+   | Android   |
 |-----------+----------+-----------|
 | Symbol    |          |           |
 | Set       |          |           |
 | Map       |          |           |
 | Proxy     |          | ✘         |
 | Reflect   |          |           |
 | Promise   |          |           |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html]]

 \\
 \\
 | [[../index_u67.html#article_54][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u81.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_56/index_u13.html][下一项]] |
 [[../index_u67.html#article_55][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_54/index_u2.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u81.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u81.html#小程序运行机制][#]] 小程序运行机制
    :PROPERTIES:
    :CUSTOM_ID: index_u81.html#小程序运行机制
    :CLASS:    calibre11
    :END:

**** [[index_u81.html#前台-后台状态][#]] 前台/后台状态
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#前台-后台状态
     :CLASS:    calibre25
     :END:

 小程序启动后，界面被展示给用户，此时小程序处于*前台*状态。

 当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home
 键离开微信时，小程序并没有完全终止运行，而是进入了*后台*状态，小程序还可以运行一小段时间。

 当用户再次进入微信或再次打开小程序，小程序又会从后台进入*前台*。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被*销毁*，即完全终止运行。

**** [[index_u81.html#小程序启动][#]] 小程序启动
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#小程序启动
     :CLASS:    calibre25
     :END:

 这样，小程序启动可以分为两种情况，一种是*冷启动*，一种是*热启动*。

 -  冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
 -  热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

**** [[index_u81.html#小程序销毁时机][#]] 小程序销毁时机
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#小程序销毁时机
     :CLASS:    calibre25
     :END:

 通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：

 -  当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。
 -  当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。

    -  在 iOS
       上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户
       「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。
    -  建议小程序在必要时使用
       [[../../api/device/performance/wx.onMemoryWarning.html][wx.onMemoryWarning]]
       监听内存告警事件，进行必要的内存清理。

 #+BEGIN_QUOTE
   基础库 1.1.0 及以上，1.4.0 以下版本：
   当用户从扫一扫、转发等入口（[[../app-service/scene.html][场景值]]为 1007,
   1008, 1011,
   1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。
 #+END_QUOTE

**** [[index_u81.html#启动场景分类][#]] 启动场景分类
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#启动场景分类
     :CLASS:    calibre25
     :END:

 用户打开小程序时，场景可分为以下 A、B 两类：

 A. 保留上次的浏览状态。[[../app-service/scene.html][场景值]]有以下几项：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 场景值 ID   | 说明                                                                                                     |
 |------------+----------------------------------------------------------------------------------------------------------|
 | 1001       | 发现栏小程序主入口，「最近使用」列表（基础库 2.2.4 版本起包含「我的小程序」列表）                          |
 | 1003       | 星标小程序列表                                                                                           |
 | 1023       | 系统桌面小图标打开小程序                                                                                 |
 | 1038       | 从其他小程序返回小程序                                                                                   |
 | 1056       | 聊天顶部音乐播放器右上角菜单，打开小程序                                                                 |
 | 1080       | 客服会话菜单小程序入口，打开小程序                                                                       |
 | 1083       | 公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）                                            |
 | 1089       | 聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库 2.2.4 版本起包含「我的小程序」栏）   |
 | 1090       | 长按小程序右上角菜单，打开小程序                                                                         |
 | 1103       | 发现-小程序主入口我的小程序，打开小程序                                                                  |
 | 1104       | 聊天主界面下拉，从我的小程序，打开小程序                                                                 |
 | 1113       | 安卓手机负一屏，打开小程序                                                                               |
 | 1114       | 安卓手机侧边栏，打开小程序                                                                               |
 | 1117       | 后台运行小程序的管理页中，打开小程序                                                                     |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 -  若进入的场景中带有 path，则每次打开小程序时都进入对应的 path 页面
 -  若进入的场景中不带 path：

    1. 若小程序是热启动，则保留原来状态
    2. 若小程序是冷启动，则遵循下一节的重启策略，可能是首页或上次退出的页面

 B. relaunch 到指定页或首页

 包括除 A 类外的其他场景

 -  若进入的场景中带有 path，则每次点击时都进入对应的 path 页面
 -  若进入的场景中不带 path，则每次进入都打开首页

**** [[index_u81.html#A-类场景的重新启动策略][#]] A 类场景的重新启动策略
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#A-类场景的重新启动策略
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   基础库 2.8.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 小程序被销毁后，下次冷启动如果属于 B 类场景，将会进入特定的页面。

 下次冷启动如果属于 A
 类场景，默认情况下将会进入小程序的首页。在页面对应的 json
 文件中（也可以全局配置在 app.json 的 window 段中），指定
 =restartStrategy=
 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A
 类场景的冷启动可以回到这个页面。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "restartStrategy": "homePage"
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 =restartStrategy= 可选值：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 可选值                  | 含义                                                                                            |
 |-------------------------+-------------------------------------------------------------------------------------------------|
 | homePage                | （默认值）如果从这个页面退出小程序，下次将从首页冷启动                                          |
 | homePageAndLatestPage   | 如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 注意：即使不配置为 =homePage=
 ，小程序如果退出过久（当前默认一天时间，可以使用*退出状态*来调整），下次冷启动时也将不再遵循
 =restartStrategy= 的配置，而是直接从首页冷启动。

 无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox
 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用*退出状态*。

**** [[index_u81.html#退出状态][#]] 退出状态
     :PROPERTIES:
     :CUSTOM_ID: index_u81.html#退出状态
     :CLASS:    calibre25
     :END:

 每当小程序可能被销毁之前，页面回调函数 =onSaveExitState=
 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过
 =exitState= 获得这些已保存数据。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "restartStrategy": "homePageAndLatestPage"
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Page({
       onLoad: function() {
         var prevExitState = this.exitState // 尝试获得上一次退出前 onSaveExitState 保存的数据
         if (prevExitState !== undefined) { // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
           prevExitState.myDataField === 'myData' 
         }
       },
       onSaveExitState: function() {
         var exitState = { myDataField: 'myData' } // 需要保存的数据
         return {
           data: exitState,
           expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 =onSaveExitState= 返回值可以包含两项：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 字段名            | 类型     | 含义                                                                         |
 |-------------------+----------+------------------------------------------------------------------------------|
 | data              | Any      | 需要保存的数据（只能是 JSON 兼容的数据）                                     |
 | expireTimeStamp   | Number   | 超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 一个更完整的示例：[[https://developers.weixin.qq.com/s/ELP5uTmN7E8l][在开发者工具中预览效果<<>>]]

 注意事项：

 -  如果超过 =expireTimeStamp= ，保存的数据将被丢弃，且冷启动时不遵循
    =restartStrategy= 的配置，而是直接从首页冷启动。
 -  =expireTimeStamp= 有可能被自动提前，如微信客户端需要清理数据的时候。
 -  在小程序存活期间， =onSaveExitState=
    可能会被多次调用，此时以最后一次的调用结果作为最终结果。
 -  在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循
    =restartStrategy= 的配置，而是直接从首页冷启动。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html]]

 \\
 \\
 | [[../index_u67.html#article_55][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u13.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_57/index_u7.html][下一项]] |
 [[../index_u67.html#article_56][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_55/index_u81.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u13.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u13.html#小程序更新机制][#]] 小程序更新机制
    :PROPERTIES:
    :CUSTOM_ID: index_u13.html#小程序更新机制
    :CLASS:    calibre11
    :END:

**** [[index_u13.html#未启动时更新][#]] 未启动时更新
     :PROPERTIES:
     :CUSTOM_ID: index_u13.html#未启动时更新
     :CLASS:    calibre25
     :END:

 开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后
 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。

**** [[index_u13.html#启动时更新][#]] 启动时更新
     :PROPERTIES:
     :CUSTOM_ID: index_u13.html#启动时更新
     :CLASS:    calibre25
     :END:

 小程序每次*冷启动*时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

 如果需要马上应用最新版本，可以使用
 [[../../api/base/update/wx.getUpdateManager.html][wx.getUpdateManager]]
 API 进行处理。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     const updateManager = wx.getUpdateManager()

     updateManager.onCheckForUpdate(function (res) {
       // 请求完新版本信息的回调
       console.log(res.hasUpdate)
     })

     updateManager.onUpdateReady(function () {
       wx.showModal({
         title: '更新提示',
         content: '新版本已经准备好，是否重启应用？',
         success(res) {
           if (res.confirm) {
             // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
             updateManager.applyUpdate()
           }
         }
       })
     })

     updateManager.onUpdateFailed(function () {
       // 新版本下载失败
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html]]

 \\
 \\
 | [[../index_u67.html#article_56][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u7.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_58/index_u90.html][下一项]] |
 [[../index_u67.html#article_57][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_56/index_u13.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u7.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

* [[index_u7.html#自定义组件][#]] 自定义组件
  :PROPERTIES:
  :CUSTOM_ID: index_u7.html#自定义组件
  :CLASS: calibre9
  :END:

从小程序基础库版本 [[../compatibility.html][1.6.3]]
开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本
[[../compatibility.html][1.6.3]] 或更高。

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

*** [[index_u7.html#创建自定义组件][#]] 创建自定义组件
    :PROPERTIES:
    :CUSTOM_ID: index_u7.html#创建自定义组件
    :CLASS: calibre25
    :END:

类似于页面，一个自定义组件由 =json= =wxml= =wxss= =js=
4 个文件组成。要编写一个自定义组件，首先需要在 =json=
文件中进行自定义组件声明（将 =component= 字段设为 =true=
可将这一组文件设为自定义组件）：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    {
      "component": true
    }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

同时，还要在 =wxml= 文件中编写组件模板，在 =wxss=
文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见
[[file:wxml-wxss.html][组件模板和样式]] 。

*代码示例：*

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    <!-- 这是自定义组件的内部WXML结构 -->
    <view class="inner">
      {{innerText}}
    </view>
    <slot></slot>
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    /* 这里的样式只应用于这个自定义组件 */
    .inner {
      color: red;
    }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

*注意：在组件 wxss 中不应使用 ID 选择器、属性选择器和标签名选择器。*

在自定义组件的 =js= 文件中，需要使用 =Component()=
来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 =wxml=
的渲染，其中，属性值是可由组件外部传入的。更多细节参见
[[file:component.html][Component构造器]] 。

*代码示例：*

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    Component({
      properties: {
        // 这里定义了innerText属性，属性值可以在组件使用时指定
        innerText: {
          type: String,
          value: 'default value',
        }
      },
      data: {
        // 这里是一些组件内部数据
        someData: {}
      },
      methods: {
        // 这里是一个自定义方法
        customMethod: function(){}
      }
    })
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

*** [[index_u7.html#使用自定义组件][#]] 使用自定义组件
    :PROPERTIES:
    :CUSTOM_ID: index_u7.html#使用自定义组件
    :CLASS: calibre25
    :END:

使用已注册的自定义组件前，首先要在页面的 =json=
文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    {
      "usingComponents": {
        "component-tag-name": "path/to/the/custom/component"
      }
    }
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

这样，在页面的 =wxml=
中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

#+BEGIN_QUOTE
  开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明
  usingComponents
  字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。
#+END_QUOTE

*代码示例：*

[[https://developers.weixin.qq.com/s/OMfVAKmZ6KZT][在开发者工具中预览效果<<>>]]

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

#+BEGIN_EXAMPLE
    <view>
      <!-- 以下是对一个自定义组件的引用 -->
      <component-tag-name inner-text="Some text"></component-tag-name>
    </view>
#+END_EXAMPLE

#+BEGIN_HTML
  </div>
#+END_HTML

自定义组件的 =wxml= 节点结构在与数据结合之后，将被插入到引用位置内。

*** [[index_u7.html#细节注意事项][#]] 细节注意事项
    :PROPERTIES:
    :CUSTOM_ID: index_u7.html#细节注意事项
    :CLASS: calibre25
    :END:

一些需要注意的细节：

-  因为 WXML
   节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
-  自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用
   =usingComponents= 字段）。
-  自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

注意，是否在页面文件中使用 =usingComponents= 会使得页面的 =this=
对象的原型稍有差异，包括：

-  使用 =usingComponents= 页面的原型与不使用时不一致，即
   =Object.getPrototypeOf(this)= 结果不同。
-  使用 =usingComponents= 时会多一些方法，如 =selectComponent= 。
-  出于性能考虑，使用 =usingComponents= 时， =setData=
   内容不会被直接深复制，即 =this.setData({ field: obj })= 后
   =this.data.field === obj= 。（深复制会在这个值被组件间传递时发生。）

如果页面比较复杂，新增或删除 =usingComponents=
定义段时建议重新测试一下。

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/]]

\\
\\
| [[../index_u67.html#article_57][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u90.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_59/index_u72.html][下一项]] |
[[../index_u67.html#article_58][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_57/index_u7.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u90.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

** [[index_u90.html#组件模板和样式][#]] 组件模板和样式
   :PROPERTIES:
   :CUSTOM_ID: index_u90.html#组件模板和样式
   :CLASS:    calibre9
   :END:

 类似于页面，自定义组件拥有自己的 =wxml= 模板和 =wxss= 样式。

**** [[index_u90.html#组件模板][#]] 组件模板
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#组件模板
     :CLASS:    calibre25
     :END:

 组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

 在组件模板中可以提供一个 =<slot>= 节点，用于承载组件引用时提供的子节点。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/1udXLnmi6KY2][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 组件模板 -->
     <view class="wrapper">
       <view>这里是组件的内部节点</view>
       <slot></slot>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 引用组件的页面模板 -->
     <view>
       <component-tag-name>
         <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
         <view>这里是插入到组件slot中的内容</view>
       </component-tag-name>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 注意，在模板中引用到的自定义组件及其对应的节点名需要在 =json=
 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为[[file:generics.html][抽象节点]]。

**** [[index_u90.html#模板数据绑定][#]] 模板数据绑定
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#模板数据绑定
     :CLASS:    calibre25
     :END:

 与普通的 WXML
 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/8ZhcXBme7djX][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 引用组件的页面模板 -->
     <view>
       <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
         <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
         <view>这里是插入到组件slot中的内容</view>
       </component-tag-name>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在以上例子中，组件的属性 =propA= 和 =propB=
 将收到页面传递的数据。页面可以通过 =setData= 来改变绑定的数据字段。

 注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本
 [[../compatibility.html][2.0.9]]
 开始，还可以在数据中包含函数（但这些函数不能在 WXML
 中直接调用，只能传递给子组件）。

**** [[index_u90.html#组件-wxml-的-slot][#]] 组件 wxml 的 slot
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#组件-wxml-的-slot
     :CLASS:    calibre25
     :END:

 在组件的 wxml 中可以包含 =slot= 节点，用于承载组件使用者提供的 wxml
 结构。

 默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot
 时，可以在组件 js 中声明启用。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         multipleSlots: true // 在组件定义时的选项中启用多slot支持
       },
       properties: { /* ... */ },
       methods: { /* ... */ }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 =name= 来区分。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 组件模板 -->
     <view class="wrapper">
       <slot name="before"></slot>
       <view>这里是组件的内部细节</view>
       <slot name="after"></slot>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 使用时，用 =slot= 属性来将节点插入到不同的 slot 上。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 引用组件的页面模板 -->
     <view>
       <component-tag-name>
         <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
         <view slot="before">这里是插入到组件slot name="before"中的内容</view>
         <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
         <view slot="after">这里是插入到组件slot name="after"中的内容</view>
       </component-tag-name>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u90.html#组件样式][#]] 组件样式
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#组件样式
     :CLASS:    calibre25
     :END:

 组件对应 =wxss=
 文件的样式，只对组件 wxml 内的节点生效。编写组件样式时，需要注意以下几点：

 -  组件和引用组件的页面不能使用 id 选择器（=#a=）、属性选择器（=[a]=）和标签名选择器，请改用 class 选择器。
 -  组件和引用组件的页面中使用后代选择器（=.a .b=）在一些极端情况下会有非预期的表现，如遇，请避免使用。
 -  子元素选择器（=.a>.b=）只能用于 =view=
    组件与其子节点之间，用于其他组件可能导致非预期的情况。
 -  继承样式，如 =font= 、 =color= ，会从组件外继承到组件内。
 -  除继承样式外， =app.wxss=
    中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     #a { } /* 在组件中不能使用 */
     [a] { } /* 在组件中不能使用 */
     button { } /* 在组件中不能使用 */
     .a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 除此以外，组件可以指定它所在节点的默认样式，使用 =:host=
 选择器（需要包含基础库 [[../compatibility.html][1.7.2]]
 或更高版本的开发者工具支持）。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/jAgvwKm16bZD][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     /* 组件 custom-component.wxss */
     :host {
       color: yellow;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 页面的 WXML -->
     <custom-component>这段文本是黄色的</custom-component>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u90.html#组件样式隔离][#]] 组件样式隔离
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#组件样式隔离
     :CLASS:    calibre25
     :END:

 默认情况下，自定义组件的样式只受到自定义组件 wxss
 的影响。除非以下两种情况：

 -  =app.wxss= 或页面的 =wxss=
    中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
 -  指定特殊的样式隔离选项 =styleIsolation= 。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         styleIsolation: 'isolated'
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 [[https://developers.weixin.qq.com/s/xPQhJcm37e7h][在开发者工具中预览效果<<>>]]

 =styleIsolation= 选项从基础库版本 [[../compatibility.html][2.6.5]]
 开始支持。它支持以下取值：

 -  =isolated= 表示启用样式隔离，在自定义组件内外，使用 class
    指定的样式将不会相互影响（一般情况下的默认值）；
 -  =apply-shared= 表示页面 wxss 样式将影响到自定义组件，但自定义组件
    wxss 中指定的样式不会影响页面；
 -  =shared= 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss
    中指定的样式也会影响页面和其他设置了 =apply-shared= 或 =shared=
    的自定义组件。（这个选项在插件中不可用。）

 *使用后两者时，请务必注意组件间样式的相互影响。*

 如果这个 [[file:component.html][Component 构造器用于构造页面]]
 ，则默认值为 =shared= ，且还有以下几个额外的样式隔离选项可用：

 -  =page-isolated= 表示在这个页面禁用 app.wxss ，同时，页面的 wxss
    不会影响到其他自定义组件；
 -  =page-apply-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
    样式不会影响到其他自定义组件，但设为 =shared=
    的自定义组件会影响到页面；
 -  =page-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
    样式会影响到其他设为 =apply-shared= 或 =shared=
    的自定义组件，也会受到设为 =shared= 的自定义组件的影响。

 从小程序基础库版本 [[../compatibility.html][2.10.1]]
 开始，也可以在页面或自定义组件的 json 文件中配置 =styleIsolation=
 （这样就不需在 js 文件的 =options= 中再配置）。例如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "styleIsolation": "isolated"
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 此外，小程序基础库版本 [[../compatibility.html][2.2.3]] 以上支持
 =addGlobalClass= 选项，即在 =Component= 的 =options= 中设置
 =addGlobalClass: true= 。 这个选项等价于设置
 =styleIsolation: apply-shared= ，但设置了 =styleIsolation=
 选项后这个选项会失效。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/VkTd7Fm37ggl][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     /* 组件 custom-component.js */
     Component({
       options: {
         addGlobalClass: true,
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 组件 custom-component.wxml -->
     <text class="red-text">这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     /* app.wxss */
     .red-text {
       color: red;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u90.html#外部样式类][#]] 外部样式类
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#外部样式类
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   基础库 1.9.90
   开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 有时，组件希望接受外部传入的样式类。此时可以在 =Component= 中用
 =externalClasses= 定义段定义若干个外部样式类。

 这个特性可以用于实现类似于 =view= 组件的 =hover-class=
 属性：页面可以提供一个样式类，赋予 =view= 的 =hover-class=
 ，这个样式类本身写在页面中而非 =view= 组件的实现中。

 *注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。*

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     /* 组件 custom-component.js */
     Component({
       externalClasses: ['my-class']
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 组件 custom-component.wxml -->
     <custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 这样，组件的使用者可以指定这个样式类对应的 class
 ，就像使用普通属性一样。在 [[../compatibility.html][2.7.1]]
 之后，可以指定多个对应的 class 。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/rbgNNKmE6bZK][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 页面的 WXML -->
     <custom-component my-class="red-text" />
     <custom-component my-class="large-text" />
     <!-- 以下写法需要基础库版本 2.7.1 以上 -->
     <custom-component my-class="red-text large-text" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     .red-text {
       color: red;
     }
     .large-text {
       font-size: 1.5em;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u90.html#引用页面或父组件的样式][#]] 引用页面或父组件的样式
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#引用页面或父组件的样式
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   基础库 2.9.2 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 即使启用了样式隔离 =isolated=
 ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

 例如，如果在页面 wxss 中定义了：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     .blue-text {
       color: blue;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在这个组件中可以使用 =~= 来引用这个类的样式：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <view class="~blue-text"> 这段文本是蓝色的 </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 如果在一个组件的父组件 wxss 中定义了：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     .red-text {
       color: red;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在这个组件中可以使用 =^= 来引用这个类的样式：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <view class="^red-text"> 这段文本是红色的 </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 也可以连续使用多个 =^= 来引用祖先组件中的样式。

 *注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。*

**** [[index_u90.html#虚拟化组件节点][#]] 虚拟化组件节点
     :PROPERTIES:
     :CUSTOM_ID: index_u90.html#虚拟化组件节点
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   基础库 2.11.2
   开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置
 =class= =style= 、动画、 flex 布局等，就如同普通的 view 组件节点一样。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 页面的 WXML -->
     <view style="display: flex">
       <!-- 默认情况下，这是一个普通的节点 -->
       <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex
 布局等，而是希望自定义组件内部的第一层节点能够响应 flex
 布局或者样式由自定义组件本身完全决定。

 这种情况下，可以将这个自定义组件设置为“虚拟的”：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         virtualHost: true
       },
       properties: {
         style: { // 定义 style 属性可以拿到 style 属性上设置的值
           type: String,
         }
       },
       externalClasses: ['class'], // 可以将 class 设为 externalClasses
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 这样，可以将 flex 放入自定义组件内：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 页面的 WXML -->
     <view style="display: flex">
       <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
       <custom-component style="color: blue">不是蓝色的</custom-component>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- custom-component.wxml -->
     <view style="flex: 1">
       满宽的
       <slot></slot>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 需要注意的是，自定义组件节点上的 =class= =style=
 和动画将不再生效，但仍可以：

 -  将 style 定义成 =properties= 属性来获取 style 上设置的值；
 -  将 class 定义成 =externalClasses= 外部样式类使得自定义组件 wxml
    可以使用 class 值。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/AlV9fEmF7Dh8][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html]]

 \\
 \\
 | [[../index_u67.html#article_58][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u72.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_60/index_u65.html][下一项]] |
 [[../index_u67.html#article_59][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_58/index_u90.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u72.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u72.html#Component-构造器][#]] Component 构造器
   :PROPERTIES:
   :CUSTOM_ID: index_u72.html#Component-构造器
   :CLASS:    calibre9
   :END:

 =Component= 构造器可用于定义组件，调用 =Component=
 构造器时可以指定组件的属性、数据、方法等。

 详细的参数含义和使用请参考
 [[../../reference/api/Component.html][Component 参考文档]]。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({

       behaviors: [],

       properties: {
         myProperty: { // 属性名
           type: String,
           value: ''
         },
         myProperty2: String // 简化的定义方式
       },
      
       data: {}, // 私有数据，可用于模板渲染

       lifetimes: {
         // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
         attached: function () { },
         moved: function () { },
         detached: function () { },
       },

       // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
       attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
       ready: function() { },

       pageLifetimes: {
         // 组件所在页面的生命周期函数
         show: function () { },
         hide: function () { },
         resize: function () { },
       },

       methods: {
         onMyButtonTap: function(){
           this.setData({
             // 更新属性和数据的方法与更新页面数据的方法类似
           })
         },
         // 内部方法建议以下划线开头
         _myPrivateMethod: function(){
           // 这里将 data.A[0].B 设为 'myPrivateData'
           this.setData({
             'A[0].B': 'myPrivateData'
           })
         },
         _propertyChange: function(newVal, oldVal) {

         }
       }

     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u72.html#使用-Component-构造器构造页面][#]] 使用 Component
 构造器构造页面
    :PROPERTIES:
    :CUSTOM_ID: index_u72.html#使用-Component-构造器构造页面
    :CLASS: calibre11
    :END:

 事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用
 =Component=
 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json
 文件中包含 =usingComponents= 定义段。

 此时，组件的属性可以用于接收页面的参数，如访问页面
 =/pages/index/index?paramA=123&paramB=xyz= ，如果声明有属性 =paramA= 或
 =paramB= ，则它们会被赋值为 =123= 或 =xyz= 。

 页面的生命周期方法（即 =on= 开头的方法），应写在 =methods= 定义段中。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "usingComponents": {}
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({

       properties: {
         paramA: Number,
         paramB: String,
       },

       methods: {
         onLoad: function() {
           this.data.paramA // 页面参数 paramA 的值
           this.data.paramB // 页面参数 paramB 的值
         }
       }

     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 使用 =Component= 构造器来构造页面的一个好处是可以使用 =behaviors=
 来提取所有页面中公用的代码段。

 例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到
 =behaviors= 中。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // page-common-behavior.js
     module.exports = Behavior({
       attached: function() {
         // 页面创建时执行
         console.info('Page loaded!')
       },
       detached: function() {
         // 页面销毁时执行
         console.info('Page unloaded!')
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 页面 A
     var pageCommonBehavior = require('./page-common-behavior')
     Component({
       behaviors: [pageCommonBehavior],
       data: { /* ... */ },
       methods: { /* ... */ },
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 页面 B
     var pageCommonBehavior = require('./page-common-behavior')
     Component({
       behaviors: [pageCommonBehavior],
       data: { /* ... */ },
       methods: { /* ... */ },
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html]]

 \\
 \\
 | [[../index_u67.html#article_59][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u65.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_61/index_u94.html][下一项]] |
 [[../index_u67.html#article_60][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_59/index_u72.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u65.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u65.html#组件间通信与事件][#]] 组件间通信与事件
   :PROPERTIES:
   :CUSTOM_ID: index_u65.html#组件间通信与事件
   :CLASS:    calibre9
   :END:

*** [[index_u65.html#组件间通信][#]] 组件间通信
    :PROPERTIES:
    :CUSTOM_ID: index_u65.html#组件间通信
    :CLASS:    calibre11
    :END:

 组件间的基本通信方式有以下几种。

 -  WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON
    兼容数据（自基础库版本 [[../compatibility.html][2.0.9]]
    开始，还可以在数据中包含函数）。具体在
    [[file:wxml-wxss.html][组件模板和样式]] 章节中介绍。
 -  事件：用于子组件向父组件传递数据，可以传递任意数据。
 -  如果以上两种方式不足以满足需要，父组件还可以通过
    =this.selectComponent=
    方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

*** [[index_u65.html#监听事件][#]] 监听事件
    :PROPERTIES:
    :CUSTOM_ID: index_u65.html#监听事件
    :CLASS:    calibre11
    :END:

 事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见
 [[../view/wxml/event.html][事件]] 。

 监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->
     <component-tag-name bindmyevent="onMyEvent" />
     <!-- 或者可以写成 -->
     <component-tag-name bind:myevent="onMyEvent" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Page({
       onMyEvent: function(e){
         e.detail // 自定义组件触发事件时提供的detail对象
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u65.html#触发事件][#]] 触发事件
    :PROPERTIES:
    :CUSTOM_ID: index_u65.html#触发事件
    :CLASS:    calibre11
    :END:

 自定义组件触发事件时，需要使用 =triggerEvent=
 方法，指定事件名、detail 对象和事件选项：

 *代码示例：*

 [[https://developers.weixin.qq.com/s/DFfYSKmI6vZD][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 在自定义组件中 -->
     <button bindtap="onTap">点击这个按钮将触发“myevent”事件</button>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       properties: {},
       methods: {
         onTap: function(){
           var myEventDetail = {} // detail对象，提供给事件监听函数
           var myEventOption = {} // 触发事件的选项
           this.triggerEvent('myevent', myEventDetail, myEventOption)
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 触发事件的选项包括：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 选项名         | 类型      | 是否必填   | 默认值   | 描述                                                                                              |
 |----------------+-----------+------------+----------+---------------------------------------------------------------------------------------------------|
 | bubbles        | Boolean   | 否         | false    | 事件是否冒泡                                                                                      |
 | composed       | Boolean   | 否         | false    | 事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部   |
 | capturePhase   | Boolean   | 否         | false    | 事件是否拥有捕获阶段                                                                              |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 关于冒泡和捕获阶段的概念，请阅读 [[../view/wxml/event.html][事件]]
 章节中的相关说明。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/UGfljKm66zZ1][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 页面 page.wxml
     <another-component bindcustomevent="pageEventListener1">
       <my-component bindcustomevent="pageEventListener2"></my-component>
     </another-component>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 组件 another-component.wxml
     <view bindcustomevent="anotherEventListener">
       <slot />
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 组件 my-component.wxml
     <view bindcustomevent="myEventListener">
       <slot />
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 组件 my-component.js
     Component({
       methods: {
         onTap: function(){
           this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
           this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
           this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u65.html#获取组件实例][#]] 获取组件实例
    :PROPERTIES:
    :CUSTOM_ID: index_u65.html#获取组件实例
    :CLASS:    calibre11
    :END:

 可在父组件里调用 =this.selectComponent=
 ，获取子组件的实例对象。（插件的自定义组件将返回 =null=）

 调用时需要传入一个匹配选择器
 =selector=，如：=this.selectComponent(".my-component")=。

 =selector= 详细语法可查看
 [[../../api/wxml/SelectorQuery.select.html][selector 语法参考文档]]。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/oQ64sFmm7rhD][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 父组件
     Page({
       data: {},
       getChildComponent: function () {
         const child = this.selectComponent('.my-component');
         console.log(child)
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在上例中，父组件将会获取 =class= 为 =my-component=
 的子组件实例对象，即子组件的 =this= 。

 若需要自定义 =selectComponent= 返回的数据，可使用内置 =behavior=:
 =wx://component-export=

 从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

 使自定义组件中支持 =export= 定义段，这个定义段可以用于指定组件被
 =selectComponent= 调用时的返回值。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/ZtosuRmK741Y][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 自定义组件 my-component 内部
     Component({
       behaviors: ['wx://component-export'],
       export() {
         return { myField: 'myValue' }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- 使用自定义组件时 -->
     <my-component id="the-id" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 父组件调用
     const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在上例中，父组件获取 =id= 为 =the-id= 的子组件实例的时候，得到的是对象
 ={ myField: 'myValue' }= 。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html]]

 \\
 \\
 | [[../index_u67.html#article_60][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u94.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_62/index_u79.html][下一项]] |
 [[../index_u67.html#article_61][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_60/index_u65.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u94.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u94.html#组件生命周期][#]] 组件生命周期
   :PROPERTIES:
   :CUSTOM_ID: index_u94.html#组件生命周期
   :CLASS:    calibre9
   :END:

 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

 其中，最重要的生命周期是 =created= =attached= =detached=
 ，包含一个组件实例生命流程的最主要时间点。

 -  组件实例刚刚被创建好时， =created= 生命周期被触发。此时，组件数据
    =this.data= 就是在 =Component= 构造器中定义的数据 =data= 。
    *此时还不能调用 =setData= 。*
    通常情况下，这个生命周期只应该用于给组件 =this=
    添加一些自定义属性字段。
 -  在组件完全初始化完毕、进入页面节点树后， =attached=
    生命周期被触发。此时， =this.data=
    已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
 -  在组件离开页面节点树后， =detached=
    生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则
    =detached= 会被触发。

*** [[index_u94.html#定义生命周期方法][#]] 定义生命周期方法
    :PROPERTIES:
    :CUSTOM_ID: index_u94.html#定义生命周期方法
    :CLASS:    calibre11
    :END:

 生命周期方法可以直接定义在 =Component= 构造器的第一级参数中。

 自小程序基础库版本 [[../compatibility.html][2.2.3]]
 起，组件的的生命周期也可以在 =lifetimes=
 字段内进行声明（这是推荐的方式，其优先级最高）。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       lifetimes: {
         attached: function() {
           // 在组件实例进入页面节点树时执行
         },
         detached: function() {
           // 在组件实例被从页面节点树移除时执行
         },
       },
       // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
       attached: function() {
         // 在组件实例进入页面节点树时执行
       },
       detached: function() {
         // 在组件实例被从页面节点树移除时执行
       },
       // ...
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors
 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个
 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

 可用的全部生命周期如下表所示。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 生命周期   | 参数             | 描述                                       | 最低版本                           |
 |------------+------------------+--------------------------------------------+------------------------------------|
 | created    | 无               | 在组件实例刚刚被创建时执行                 | [[../compatibility.html][1.6.3]]   |
 | attached   | 无               | 在组件实例进入页面节点树时执行             | [[../compatibility.html][1.6.3]]   |
 | ready      | 无               | 在组件在视图层布局完成后执行               | [[../compatibility.html][1.6.3]]   |
 | moved      | 无               | 在组件实例被移动到节点树另一个位置时执行   | [[../compatibility.html][1.6.3]]   |
 | detached   | 无               | 在组件实例被从页面节点树移除时执行         | [[../compatibility.html][1.6.3]]   |
 | error      | =Object Error=   | 每当组件方法抛出错误时执行                 | [[../compatibility.html][2.4.1]]   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u94.html#组件所在页面的生命周期][#]] 组件所在页面的生命周期
    :PROPERTIES:
    :CUSTOM_ID: index_u94.html#组件所在页面的生命周期
    :CLASS:    calibre11
    :END:

 还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在
 =pageLifetimes= 定义段中定义。其中可用的生命周期包括：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 生命周期   | 参数            | 描述                           | 最低版本                           |
 |------------+-----------------+--------------------------------+------------------------------------|
 | show       | 无              | 组件所在的页面被展示时执行     | [[../compatibility.html][2.2.3]]   |
 | hide       | 无              | 组件所在的页面被隐藏时执行     | [[../compatibility.html][2.2.3]]   |
 | resize     | =Object Size=   | 组件所在的页面尺寸变化时执行   | [[../compatibility.html][2.4.0]]   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       pageLifetimes: {
         show: function() {
           // 页面被展示
         },
         hide: function() {
           // 页面被隐藏
         },
         resize: function(size) {
           // 页面尺寸变化
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html]]

 \\
 \\
 | [[../index_u67.html#article_61][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u79.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_63/index_u80.html][下一项]] |
 [[../index_u67.html#article_62][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_61/index_u94.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u79.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u79.html#behaviors][#]] behaviors
   :PROPERTIES:
   :CUSTOM_ID: index_u79.html#behaviors
   :CLASS:    calibre9
   :END:

 =behaviors= 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins”
 或 “traits”。

 每个 =behavior=
 可以包含一组属性、数据、生命周期函数和方法。*组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。*
 每个组件可以引用多个 =behavior= ，=behavior= 也可以引用其它 =behavior=
 。

 详细的参数含义和使用请参考 [[../../reference/api/Behavior.html][Behavior
 参考文档]]。

*** [[index_u79.html#组件中使用][#]] 组件中使用
    :PROPERTIES:
    :CUSTOM_ID: index_u79.html#组件中使用
    :CLASS:    calibre11
    :END:

 组件引用时，在 =behaviors= 定义段中将它们逐个列出即可。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/Yq4RqCm87thO][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // my-component.js
     var myBehavior = require('my-behavior')
     Component({
       behaviors: [myBehavior],
       properties: {
         myProperty: {
           type: String
         }
       },
       data: {
         myData: 'my-component-data'
       },
       created: function () {
         console.log('[my-component] created')
       },
       attached: function () { 
         console.log('[my-component] attached')
       },
       ready: function () {
         console.log('[my-component] ready')
       },
       methods: {
         myMethod: function () {
           console.log('[my-component] log by myMethod')
         },
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在上例中， =my-component= 组件定义中加入了 =my-behavior=，

 而 =my-behavior= 结构为：

 -  属性：=myBehaviorProperty=
 -  数据字段：=myBehaviorData=
 -  方法：=myBehaviorMethod=
 -  生命周期函数：=attached=、=created=、=ready=

 这将使 =my-component= 最终结构为：

 -  属性：=myBehaviorProperty=、=myProperty=
 -  数据字段：=myBehaviorData=、=myData=
 -  方法：=myBehaviorMethod=、=myMethod=
 -  生命周期函数：=attached=、=created=、=ready=

 当组件触发生命周期时，上例生命周期函数执行顺序为：

 1. =[my-behavior] created=
 2. =[my-component] created=
 3. =[my-behavior] attached=
 4. =[my-component] attached=
 5. =[my-behavior] ready=
 6. =[my-component] ready=

 详细规则参考 *同名字段的覆盖和组合规则*。

*** [[index_u79.html#同名字段的覆盖和组合规则][#]]
 同名字段的覆盖和组合规则
    :PROPERTIES:
    :CUSTOM_ID: index_u79.html#同名字段的覆盖和组合规则
    :CLASS: calibre11
    :END:

 组件和它引用的 =behavior=
 中可以包含同名的字段，对这些字段的处理方法如下：

 -  如果有同名的属性 (properties) 或方法 (methods)：

    1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 =behavior=
       中的同名属性或方法；
    2. 若组件本身无这个属性或方法，则在组件的 =behaviors=
       字段中定义靠后的 =behavior=
       的属性或方法会覆盖靠前的同名属性或方法；
    3. 在 2 的基础上，若存在嵌套引用 =behavior=
       的情况，则规则为：=父 behavior= 覆盖 =子 behavior=
       中的同名属性或方法。

 -  如果有同名的数据字段 (data)：

    -  若同名的数据字段都是对象类型，会进行对象合并；
    -  其余情况会进行数据覆盖，覆盖规则为：组件 > =父 behavior= >
       =子 behavior= 、 =靠后的 behavior= >
       =靠前的 behavior=。（优先级高的覆盖优先级低的，最大的为优先级最高）

 -  生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：

    -  对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
    -  对于同种生命周期函数，遵循如下规则：

       -  =behavior= 优先于组件执行；
       -  =子 behavior= 优先于 =父 behavior= 执行；
       -  =靠前的 behavior= 优先于 =靠后的 behavior= 执行；

    -  如果同一个 =behavior=
       被一个组件多次引用，它定义的生命周期函数只会被执行一次。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/CI5omDmT7khB][在开发者工具中预览效果<<>>]]

*** [[index_u79.html#内置-behaviors][#]] 内置 behaviors
    :PROPERTIES:
    :CUSTOM_ID: index_u79.html#内置-behaviors
    :CLASS:    calibre11
    :END:

 自定义组件可以通过引用内置的 =behavior= 来获得内置组件的一些行为。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       behaviors: ['wx://form-field']
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在上例中， =wx://form-field= 代表一个内置 =behavior=
 ，它使得这个自定义组件有类似于表单控件的行为。

 内置 =behavior=
 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的
 =type= 或添加 =observer= 。

**** [[index_u79.html#wx-form-field][#]] wx://form-field
     :PROPERTIES:
     :CUSTOM_ID: index_u79.html#wx-form-field
     :CLASS:    calibre25
     :END:

 使自定义组件有类似于表单控件的行为。 form
 组件可以识别这些自定义组件，并在 submit
 事件中返回组件的字段名及其对应字段值。

 详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

**** [[index_u79.html#wx-form-field-group][#]] wx://form-field-group
     :PROPERTIES:
     :CUSTOM_ID: index_u79.html#wx-form-field-group
     :CLASS:    calibre25
     :END:

 从基础库版本 [[../compatibility.html][2.10.2]] 开始提供支持。

 使 form 组件可以识别到这个自定义组件内部的所有表单控件。

 详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

**** wx://form-field-button
 从基础库版本 [[../compatibility.html][2.10.3]] 开始提供支持。

 使 form 组件可以识别到这个自定义组件内部的 button
 。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form
 接受。

 详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

**** [[index_u79.html#wx-component-export][#]] wx://component-export
 从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

 使自定义组件支持 =export= 定义段。这个定义段可以用于指定组件被
 =selectComponent= 调用时的返回值。

 详细用法以及代码示例可见：[[file:events][selectComponent 参考文档]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html]]

 \\
 \\
 | [[../index_u67.html#article_62][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u80.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_64/index_u35.html][下一项]] |
 [[../index_u67.html#article_63][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_62/index_u79.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u80.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u80.html#组件间关系][#]] 组件间关系
   :PROPERTIES:
   :CUSTOM_ID: index_u80.html#组件间关系
   :CLASS:    calibre9
   :END:

*** [[index_u80.html#定义和使用组件间关系][#]] 定义和使用组件间关系
    :PROPERTIES:
    :CUSTOM_ID: index_u80.html#定义和使用组件间关系
    :CLASS:    calibre11
    :END:

 有时需要实现这样的组件：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <custom-ul>
       <custom-li> item 1 </custom-li>
       <custom-li> item 2 </custom-li>
     </custom-ul>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 这个例子中， =custom-ul= 和 =custom-li=
 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入
 =relations= 定义段，可以解决这样的问题。示例：

 [[https://developers.weixin.qq.com/s/0kfvzKm56NZy][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-ul.js
     Component({
       relations: {
         './custom-li': {
           type: 'child', // 关联的目标节点应为子节点
           linked: function(target) {
             // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
           },
           linkChanged: function(target) {
             // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
           },
           unlinked: function(target) {
             // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
           }
         }
       },
       methods: {
         _getAllLi: function(){
           // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
           var nodes = this.getRelationNodes('path/to/custom-li')
         }
       },
       ready: function(){
         this._getAllLi()
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-li.js
     Component({
       relations: {
         './custom-ul': {
           type: 'parent', // 关联的目标节点应为父节点
           linked: function(target) {
             // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
           },
           linkChanged: function(target) {
             // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
           },
           unlinked: function(target) {
             // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
           }
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 *注意：必须在两个组件定义中都加入 relations 定义，否则不会生效。*

*** [[index_u80.html#关联一类组件][#]] 关联一类组件
    :PROPERTIES:
    :CUSTOM_ID: index_u80.html#关联一类组件
    :CLASS:    calibre11
    :END:

 [[https://developers.weixin.qq.com/s/LFEVaqmh6zYU][在开发者工具中预览效果<<>>]]

 有时，需要关联的是一类组件，如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <custom-form>
       <view>
         input
         <custom-input></custom-input>
       </view>
       <custom-submit> submit </custom-submit>
     </custom-form>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 =custom-form= 组件想要关联 =custom-input= 和 =custom-submit=
 两个组件。此时，如果这两个组件都有同一个 behavior：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-form-controls.js
     module.exports = Behavior({
       // ...
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-input.js
     var customFormControls = require('./custom-form-controls')
     Component({
       behaviors: [customFormControls],
       relations: {
         './custom-form': {
           type: 'ancestor', // 关联的目标节点应为祖先节点
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-submit.js
     var customFormControls = require('./custom-form-controls')
     Component({
       behaviors: [customFormControls],
       relations: {
         './custom-form': {
           type: 'ancestor', // 关联的目标节点应为祖先节点
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 则在 =relations=
 关系定义中，可使用这个 behavior 来代替组件路径作为关联的目标节点：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // path/to/custom-form.js
     var customFormControls = require('./custom-form-controls')
     Component({
       relations: {
         'customFormControls': {
           type: 'descendant', // 关联的目标节点应为子孙节点
           target: customFormControls
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u80.html#relations-定义段][#]] relations 定义段
    :PROPERTIES:
    :CUSTOM_ID: index_u80.html#relations-定义段
    :CLASS:    calibre11
    :END:

 =relations= 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 选项          | 类型       | 是否必填   | 描述                                                                                                   |
 |---------------+------------+------------+--------------------------------------------------------------------------------------------------------|
 | type          | String     | 是         | 目标组件的相对关系，可选的值为 =parent= 、 =child= 、 =ancestor= 、 =descendant=                       |
 | linked        | Function   | 否         | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件 attached 生命周期之后                 |
 | linkChanged   | Function   | 否         | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件 moved 生命周期之后                  |
 | unlinked      | Function   | 否         | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件 detached 生命周期之后                       |
 | target        | String     | 否         | 如果这一项被设置，则它表示关联的目标节点所应具有的 behavior，所有拥有这一 behavior 的组件节点都会被关联   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html]]

 \\
 \\
 | [[../index_u67.html#article_63][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u35.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_65/index_u48.html][下一项]] |
 [[../index_u67.html#article_64][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_63/index_u80.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u35.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u35.html#数据监听器][#]] 数据监听器
   :PROPERTIES:
   :CUSTOM_ID: index_u35.html#数据监听器
   :CLASS:    calibre9
   :END:

 数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本
 [[../compatibility.html][2.6.1]] 开始支持。

*** [[index_u35.html#使用数据监听器][#]] 使用数据监听器
    :PROPERTIES:
    :CUSTOM_ID: index_u35.html#使用数据监听器
    :CLASS:    calibre11
    :END:

 有时，在一些数据字段被 setData 设置时，需要执行一些操作。

 例如， =this.data.sum= 永远是 =this.data.numberA= 与 =this.data.numberB=
 的和。此时，可以使用数据监听器进行如下实现。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       attached: function() {
         this.setData({
           numberA: 1,
           numberB: 2,
         })
       },
       observers: {
         'numberA, numberB': function(numberA, numberB) {
           // 在 numberA 或者 numberB 被设置时，执行这个函数
           this.setData({
             sum: numberA + numberB
           })
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 [[https://developers.weixin.qq.com/s/FUZF9ams7g6N][在开发者工具中预览效果<<>>]]

*** [[index_u35.html#监听字段语法][#]] 监听字段语法
    :PROPERTIES:
    :CUSTOM_ID: index_u35.html#监听字段语法
    :CLASS:    calibre11
    :END:

 数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData
 最多触发每个监听器一次。

 同时，监听器可以监听子数据字段，如下例所示。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       observers: {
         'some.subfield': function(subfield) {
           // 使用 setData 设置 this.data.some.subfield 时触发
           // （除此以外，使用 setData 设置 this.data.some 也会触发）
           subfield === this.data.some.subfield
         },
         'arr[12]': function(arr12) {
           // 使用 setData 设置 this.data.arr[12] 时触发
           // （除此以外，使用 setData 设置 this.data.arr 也会触发）
           arr12 === this.data.arr[12]
         },
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 如果需要监听所有子数据字段的变化，可以使用通配符 =**= 。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       observers: {
         'some.field.**': function(field) {
           // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
           // （除此以外，使用 setData 设置 this.data.some 也会触发）
           field === this.data.some.field
         },
       },
       attached: function() {
         // 这样会触发上面的 observer
         this.setData({
           'some.field': { /* ... */ }
         })
         // 这样也会触发上面的 observer
         this.setData({
           'some.field.xxx': { /* ... */ }
         })
         // 这样还是会触发上面的 observer
         this.setData({
           'some': { /* ... */ }
         })
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 特别地，仅使用通配符 =**= 可以监听全部 setData 。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       observers: {
         '**': function() {
           // 每次 setData 都触发
         },
       },
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 *Bugs & Tips:*

 -  数据监听器监听的是 setData
    涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
 -  如果在数据监听器函数中使用 setData
    设置本身监听的数据字段，可能会导致死循环，需要特别留意。
 -  数据监听器和属性的 observer
    相比，数据监听器更强大且通常具有更好的性能。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html]]

 \\
 \\
 | [[../index_u67.html#article_64][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u48.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_66/index_u28.html][下一项]] |
 [[../index_u67.html#article_65][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_64/index_u35.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u48.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u48.html#纯数据字段][#]] 纯数据字段
   :PROPERTIES:
   :CUSTOM_ID: index_u48.html#纯数据字段
   :CLASS:    calibre9
   :END:

 纯数据字段是一些不用于界面渲染的 data
 字段，可以用于提升页面更新性能。从小程序基础库版本
 [[../compatibility.html][2.8.2]] 开始支持。

*** [[index_u48.html#组件数据中的纯数据字段][#]] 组件数据中的纯数据字段
    :PROPERTIES:
    :CUSTOM_ID: index_u48.html#组件数据中的纯数据字段
    :CLASS:    calibre11
    :END:

 有些情况下，某些 =data= 中的字段（包括 =setData=
 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

 此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在
 =this.data= 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

 指定“纯数据字段”的方法是在 =Component= 构造器的 =options= 定义段中指定
 =pureDataPattern=
 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

 [[https://developers.weixin.qq.com/s/DKWiBXmb7jaB][在开发者工具中预览效果<<>>]]

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
       },
       data: {
         a: true, // 普通数据字段
         _b: true, // 纯数据字段
       },
       methods: {
         myMethod() {
           this.data._b // 纯数据字段可以在 this.data 中获取
           this.setData({
             c: true, // 普通数据字段
             _d: true, // 纯数据字段
           })
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 上述组件中的纯数据字段不会被应用到 WXML 上：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <view wx:if="{{a}}"> 这行会被展示 </view>
     <view wx:if="{{_b}}"> 这行不会被展示 </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u48.html#组件属性中的纯数据字段][#]] 组件属性中的纯数据字段
    :PROPERTIES:
    :CUSTOM_ID: index_u48.html#组件属性中的纯数据字段
    :CLASS:    calibre11
    :END:

 属性也可以被指定为纯数据字段（遵循 =pureDataPattern= 的正则表达式）。

 属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的
 WXML 中。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         pureDataPattern: /^_/
       },
       properties: {
         a: Boolean,
         _b: {
           type: Boolean,
           observer() {
             // 不要这样做！这个 observer 永远不会被触发
           }
         },
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 注意：属性中的纯数据字段的属性 observer
 永远不会触发！如果想要监听属性值变化，使用
 [[file:observer.html][数据监听器]] 代替。

 从小程序基础库版本 [[../compatibility.html][2.10.1]]
 开始，也可以在页面或自定义组件的 json 文件中配置 =pureDataPattern=
 （这样就不需在 js 文件的 =options=
 中再配置）。此时，其值应当写成字符串形式：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "pureDataPattern": "^_"
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u48.html#使用数据监听器监听纯数据字段][#]]
 使用数据监听器监听纯数据字段
    :PROPERTIES:
    :CUSTOM_ID: index_u48.html#使用数据监听器监听纯数据字段
    :CLASS: calibre11
    :END:

 [[file:observer.html][数据监听器]]
 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

 下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

 [[https://developers.weixin.qq.com/s/fcWA1Xmd7tak][在开发者工具中预览效果<<>>]]

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       options: {
         pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
       },
       properties: {
         timestamp: Number,
       },
       observers: {
         timestamp: function () {
           // timestamp 被设置时，将它展示为可读时间字符串
           var timeString = new Date(this.data.timestamp).toLocaleString()
           this.setData({
             timeString: timeString
           })
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <view>{{timeString}}</view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html]]

 \\
 \\
 | [[../index_u67.html#article_65][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u28.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_67/index_u8.html][下一项]] |
 [[../index_u67.html#article_66][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_65/index_u48.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u28.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u28.html#抽象节点][#]] 抽象节点
   :PROPERTIES:
   :CUSTOM_ID: index_u28.html#抽象节点
   :CLASS:    calibre9
   :END:

 这个特性自小程序基础库版本 [[../compatibility.html][1.9.6]] 开始支持。

*** [[index_u28.html#在组件中使用抽象节点][#]] 在组件中使用抽象节点
    :PROPERTIES:
    :CUSTOM_ID: index_u28.html#在组件中使用抽象节点
    :CLASS:    calibre11
    :END:

 有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

 例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的
 wxml 可以这样编写：

 *代码示例：*

 [[https://developers.weixin.qq.com/s/ztPzoImW7E7P][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- selectable-group.wxml -->
     <view wx:for="{{labels}}">
       <label>
         <selectable disabled="{{false}}"></selectable>
         {{item}}
       </label>
     </view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 其中，“selectable”不是任何在 json 文件的 =usingComponents=
 字段中声明的组件，而是一个抽象节点。它需要在 =componentGenerics=
 字段中声明：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "componentGenerics": {
         "selectable": true
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u28.html#使用包含抽象节点的组件][#]] 使用包含抽象节点的组件
    :PROPERTIES:
    :CUSTOM_ID: index_u28.html#使用包含抽象节点的组件
    :CLASS:    calibre11
    :END:

 在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <selectable-group generic:selectable="custom-radio" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 这样，在生成这个 selectable-group
 组件的实例时，“selectable”节点会生成“custom-radio”组件实例。类似地，如果这样使用：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <selectable-group generic:selectable="custom-checkbox" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 “selectable”节点则会生成“custom-checkbox”组件实例。

 注意：上述的 =custom-radio= 和 =custom-checkbox= 需要包含在这个 wxml
 对应 json 文件的 =usingComponents= 定义段中。

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "usingComponents": {
         "custom-radio": "path/to/custom/radio",
         "custom-checkbox": "path/to/custom/checkbox"
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u28.html#抽象节点的默认组件][#]] 抽象节点的默认组件
    :PROPERTIES:
    :CUSTOM_ID: index_u28.html#抽象节点的默认组件
    :CLASS:    calibre11
    :END:

 抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在
 =componentGenerics= 字段中指定：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "componentGenerics": {
         "selectable": {
           "default": "path/to/default/component"
         }
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 *Tips:*

 -  节点的 generic 引用 =generic:xxx="yyy"= 中，值 =yyy=
    只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/generics.html]]

 \\
 \\
 | [[../index_u67.html#article_66][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u8.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_68/index_u83.html][下一项]] |
 [[../index_u67.html#article_67][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_66/index_u28.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u8.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u8.html#自定义组件扩展][#]] 自定义组件扩展
   :PROPERTIES:
   :CUSTOM_ID: index_u8.html#自定义组件扩展
   :CLASS:    calibre9
   :END:

 为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本
 [[../compatibility.html][2.2.3]] 开始支持。

*** [[index_u8.html#扩展后的效果][#]] 扩展后的效果
    :PROPERTIES:
    :CUSTOM_ID: index_u8.html#扩展后的效果
    :CLASS:    calibre11
    :END:

 为了更好的理解扩展后的效果，先举一个例子：

 [[https://developers.weixin.qq.com/s/STePQRmH7Q5H][在开发者工具中预览效果<<>>]]

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // behavior.js
     module.exports = Behavior({
       definitionFilter(defFields) {
         defFields.data.from = 'behavior'
       },
     })

     // component.js
     Component({
       data: {
         from: 'component'
       },
       behaviors: [require('behavior.js')],
       ready() {
         console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，上述例子就是修改了自定义组件中的
 =data= 定义段里的内容。

*** [[index_u8.html#使用扩展][#]] 使用扩展
    :PROPERTIES:
    :CUSTOM_ID: index_u8.html#使用扩展
    :CLASS:    calibre11
    :END:

 =Behavior()= 构造器提供了新的定义段 =definitionFilter=
 ，用于支持自定义组件扩展。 =definitionFilter=
 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的
 component/behavior 的定义对象，第二个参数是该 behavior 所使用的 behavior
 的 =definitionFilter= 函数列表。

 以下举个例子来说明：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // behavior3.js
     module.exports = Behavior({
         definitionFilter(defFields, definitionFilterArr) {},
     })

     // behavior2.js
     module.exports = Behavior({
       behaviors: [require('behavior3.js')],
       definitionFilter(defFields, definitionFilterArr) {
         // definitionFilterArr[0](defFields)
       },
     })

     // behavior1.js
     module.exports = Behavior({
       behaviors: [require('behavior2.js')],
       definitionFilter(defFields, definitionFilterArr) {},
     })

     // component.js
     Component({
       behaviors: [require('behavior1.js')],
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 上述代码中声明了 1 个自定义组件和 3 个 behavior，每个 behavior 都使用了
 =definitionFilter= 定义段。那么按照声明的顺序会有如下事情发生：

 1. 当进行 behavior2 的声明时就会调用 behavior3 的 =definitionFilter=
    函数，其中 =defFields= 参数是 behavior2 的定义段，
    =definitionFilterArr= 参数即为空数组，因为 behavior3 没有使用其他的
    behavior 。
 2. 当进行 behavior1 的声明时就会调用 behavior2 的 =definitionFilter=
    函数，其中 =defFields= 参数是 behavior1 的定义段，
    =definitionFilterArr=
    参数是一个长度为 1 的数组，=definitionFilterArr[0]= 即为 behavior3 的
    =definitionFilter= 函数，因为 behavior2 使用了
    behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用
    behavior3 的 =definitionFilter= 函数，如果需要调用，在此处补充代码
    =definitionFilterArr[0](defFields)= 即可，=definitionFilterArr=
    参数会由基础库补充传入。
 3. 同理，在进行 component 的声明时就会调用 behavior1 的
    =definitionFilter= 函数。

 简单概括，=definitionFilter= 函数可以理解为当 A 使用了 B 时，A
 声明就会调用 B 的 =definitionFilter= 函数并传入 A 的定义对象让 B
 去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和
 D 的 =definitionFilter= 函数去过滤 A 的定义对象。

 *代码示例：*

 [[https://developers.weixin.qq.com/s/WaqPbxmN7E1j][在开发者工具中预览效果<<>>]]

*** [[index_u8.html#真实案例][#]] 真实案例
    :PROPERTIES:
    :CUSTOM_ID: index_u8.html#真实案例
    :CLASS:    calibre11
    :END:

 下面利用扩展简单实现自定义组件的计算属性功能:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // behavior.js
     module.exports = Behavior({
       lifetimes: {
         created() {
           this._originalSetData = this.setData // 原始 setData
           this.setData = this._setData // 封装后的 setData
         }
       },
       definitionFilter(defFields) {
         const computed = defFields.computed || {}
         const computedKeys = Object.keys(computed)
         const computedCache = {}

         // 计算 computed
         const calcComputed = (scope, insertToData) => {
           const needUpdate = {}
           const data = defFields.data = defFields.data || {}

           for (let key of computedKeys) {
             const value = computed[key].call(scope) // 计算新值
             if (computedCache[key] !== value) needUpdate[key] = computedCache[key] = value
             if (insertToData) data[key] = needUpdate[key] // 直接插入到 data 中，初始化时才需要的操作
           }

           return needUpdate
         }

         // 重写 setData 方法
         defFields.methods = defFields.methods || {}
         defFields.methods._setData = function (data, callback) {
           const originalSetData = this._originalSetData // 原始 setData
           originalSetData.call(this, data, callback) // 做 data 的 setData
           const needUpdate = calcComputed(this) // 计算 computed
           originalSetData.call(this, needUpdate) // 做 computed 的 setData
         }

         // 初始化 computed
         calcComputed(defFields, true) // 计算 computed
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在组件中使用：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     const beh = require('./behavior.js')
     Component({
       behaviors: [beh],
       data: {
         a: 0,
       },
       computed: {
         b() {
           return this.data.a + 100
         },
       },
       methods: {
         onTap() {
           this.setData({
             a: ++this.data.a,
           })
         }
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <view>data: {{a}}</view>
     <view>computed: {{b}}</view>
     <button bindtap="onTap">click</button>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 实现原理很简单，对已有的 setData 进行二次封装，在每次 setData
 的时候计算出 computed 里各字段的值，然后设到 data
 中，已达到计算属性的效果。

 #+BEGIN_QUOTE
   此实现只是作为一个简单案例来展示，请勿直接在生产环境中使用。
 #+END_QUOTE

*** [[index_u8.html#官方扩展包][#]] 官方扩展包
    :PROPERTIES:
    :CUSTOM_ID: index_u8.html#官方扩展包
    :CLASS:    calibre11
    :END:

 -  [[https://github.com/wechat-miniprogram/computed][computed<<>>]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html]]

 \\
 \\
 | [[../index_u67.html#article_67][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u83.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_69/index.html][下一项]] |
 [[../index_u67.html#article_68][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_67/index_u8.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u83.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u83.html#开发第三方自定义组件][#]] 开发第三方自定义组件
   :PROPERTIES:
   :CUSTOM_ID: index_u83.html#开发第三方自定义组件
   :CLASS:    calibre9
   :END:

 小程序从基础库版本 [[../compatibility.html][2.2.1]] 开始支持使用 npm
 安装第三方包，因此也支持开发和使用第三方自定义组件包。关于 npm
 功能的详情可先阅读[相关文档]((npm 支持))。

*** [[index_u83.html#准备][#]] 准备
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#准备
    :CLASS:    calibre11
    :END:

 开发一个开源的自定义组件包给他人使用，首先需要明确他人是要如何使用这个包的，如果只是拷贝小程序目录下直接使用的话，可以跳过此文档。此文档中后续内容是以
 npm 管理自定义组件包的前提下进行说明的。

 在开发之前，要求开发者具有基础的 node.js 和 npm
 相关的知识，同时需要准备好支持 npm
 功能的开发者工具，[[../../devtools/download.html][点此下载]]。

*** [[index_u83.html#下载模板][#]] 下载模板
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#下载模板
    :CLASS:    calibre11
    :END:

 为了方便开发者能够快速搭建好一个可用于开发、调试、测试的自定义组件包项目，官方提供了一个[[https://github.com/wechat-miniprogram/miniprogram-custom-component][项目模板<<>>]]，下载使用模板的方式有三种：

 -  直接从 github 上下载 zip 文件并解压。
 -  直接将 github 上的仓库 clone 下来。
 -  使用官方提供的命令行工具初始化项目，下面会进行介绍。

 项目模板中的构建是基于 gulp + webpack
 来执行的，支持开发、构建、测试等命令，详情可参阅项目模板的
 [[https://github.com/wechat-miniprogram/miniprogram-custom-component/blob/master/README.md][README.md<<>>]]
 文件。

*** [[index_u83.html#命令行工具][#]] 命令行工具
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#命令行工具
    :CLASS:    calibre11
    :END:

 官方提供了[[https://github.com/wechat-miniprogram/miniprogram-cli][命令行工具<<>>]]，用于快速初始化一个项目。执行如下命令安装命令行工具：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     npm install -g @wechat-miniprogram/miniprogram-cli
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 然后新建一个空目录作为项目根目录，在此根目录下执行：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     miniprogram init --type custom-component
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 命令执行完毕后会发现项目根目录下生成了许多文件，这是根据官方的[[https://github.com/wechat-miniprogram/miniprogram-custom-component][项目模板<<>>]]生成的完整项目，之后开发者可直接在此之上进行开发修改。

 命令行工具的更多用法可以查看 github 仓库上的
 [[https://github.com/wechat-miniprogram/miniprogram-cli/blob/master/README.md][README.md<<>>]]
 文件。

 #+BEGIN_QUOTE
   PS：第一次使用 =miniprogram init= 初始化项目会去 github
   上拉取模板，因此需要保证网络畅通。
 #+END_QUOTE

*** [[index_u83.html#测试工具][#]] 测试工具
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#测试工具
    :CLASS:    calibre11
    :END:

 针对自定义组件的单元测试，可参阅文档[[file:unit-test.html][单元测试]]。

*** [[index_u83.html#自定义组件示例][#]] 自定义组件示例
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#自定义组件示例
    :CLASS:    calibre11
    :END:

 以下为官方提供的自定义组件，可以参考并使用：

 -  [[https://github.com/wechat-miniprogram/weui-miniprogram][weui-miniprogram<<>>]]
 -  [[https://github.com/wechat-miniprogram/recycle-view][recycle-view<<>>]]

*** [[index_u83.html#自定义组件扩展示例][#]] 自定义组件扩展示例
    :PROPERTIES:
    :CUSTOM_ID: index_u83.html#自定义组件扩展示例
    :CLASS:    calibre11
    :END:

 以下为官方提供的自定义组件扩展，可以参考并使用：

 -  [[https://github.com/wechat-miniprogram/computed][computed<<>>]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/trdparty.html]]

 \\
 \\
 | [[../index_u67.html#article_68][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_70/index_u11.html][下一项]] |
 [[../index_u67.html#article_69][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_68/index_u83.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index.html#单元测试][#]] 单元测试
   :PROPERTIES:
   :CUSTOM_ID: index.html#单元测试
   :CLASS:    calibre9
   :END:

 在编写高质量的自定义组件过程中，单元测试是永远避不开的一个话题。完善的测试用例是提高自定义组件可用性的保证，同时测试代码覆盖率也是必不可少的一个环节。小程序从基础库版本
 [[../compatibility.html][2.2.1]] 开始拥抱开源，支持使用 npm
 安装自定义组件，那针对自定义组件的单元测试也是必须支持的。

 以下就来介绍如何对自定义组件进行单元测试。

*** [[index.html#测试框架][#]] 测试框架
    :PROPERTIES:
    :CUSTOM_ID: index.html#测试框架
    :CLASS:    calibre11
    :END:

 现在市面上流行的测试框架均可使用，只要它能兼顾 nodejs 端和 dom
 环境。因为我们需要依赖到 nodejs 的一些库来完善测试环境，同时 dom
 环境也是必须的，因为我们需要建成完整的 dom
 树结构，才能更好的模拟自定义组件的运行。例如可以选用 mocha + jsdom
 的组合，亦可选用 jest，下述例子选用 jest 作为测试框架来说明。

*** [[index.html#自定义组件测试工具集][#]] 自定义组件测试工具集
    :PROPERTIES:
    :CUSTOM_ID: index.html#自定义组件测试工具集
    :CLASS:    calibre11
    :END:

 小程序的运行环境比较特殊，不同于常见的浏览器环境，它采用的是双线程的架构。而在进行单元测试时，我们并不需要用到这样复杂的架构带来的利好，我们进行的是功能测试而无需苛求性能、安全等因素，因此我们提供了一个测试工具集以支持自定义组件在
 nodejs 单线程中也能运行起来。

 我们先安装一下测试工具集------[[https://github.com/wechat-miniprogram/miniprogram-simulate][miniprogram-simulate<<>>]]：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     npm i --save-dev miniprogram-simulate
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index.html#编写测试用例][#]] 编写测试用例
    :PROPERTIES:
    :CUSTOM_ID: index.html#编写测试用例
    :CLASS:    calibre11
    :END:

 假设我们有如下自定义组件：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- /components/index.wmxl -->
     <view class="index">{{prop}}</view>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // /components/index.js
     Component({
       properties: {
         prop: {
           type: String,
           value: 'index.properties'
         },
       },
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     /* /components/index.wxss */
     .index {
       color: green;
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 我们想要测试渲染的结果，可以按照如下方式编写测试用例：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // /test/components/index.test.js
     const simulate = require('miniprogram-simulate')

     test('components/index', () => {
         const id = simulate.load('/components/index') // 此处必须传入绝对路径
         const comp = simulate.render(id) // 渲染成自定义组件树实例

         const parent = document.createElement('parent-wrapper') // 创建父亲节点
         comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子

         const view = comp.querySelector('.index') // 获取子组件 view
         expect(view.dom.innerHTML).toBe('index.properties') // 测试渲染结果
         expect(window.getComputedStyle(view.dom).color).toBe('green') // 测试渲染结果
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_QUOTE
   PS：测试工具集中的 wx
   对象和内置组件都不会实现真正的功能，如果需要测试一些特殊场景的话，可以自行覆盖掉测试工具集中的
   api 接口和内置组件。

   PS：目前因为有部分自定义组件功能仍未支持（如抽象节点等），故测试工具暂无法全部覆盖自定义组件的特性，后续会继续完善。
 #+END_QUOTE

 测试工具集中提供了一些方便测试的接口，比如：

 -  模拟 touch 事件、自定义事件触发
 -  选取子节点
 -  更新自定义组件数据
 -  触发生命周期
 -  ...

 更多详细的用法可以参阅
 [[https://github.com/wechat-miniprogram/miniprogram-simulate][github
 仓库<<>>]]上的文档。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html]]

 \\
 \\
 | [[../index_u67.html#article_69][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u11.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_71/index_u15.html][下一项]] |
 [[../index_u67.html#article_70][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_69/index.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u11.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u11.html#获取更新性能统计信息][#]] 获取更新性能统计信息
   :PROPERTIES:
   :CUSTOM_ID: index_u11.html#获取更新性能统计信息
   :CLASS:    calibre9
   :END:

 #+BEGIN_QUOTE
   基础库 2.12.0
   开始支持，低版本需做[[../compatibility.html][兼容处理]]。
 #+END_QUOTE

 如果想要知道 setData
 引发界面更新的开销，可以使用更新性能统计信息接口。它将返回每次更新中主要更新步骤发生的时间戳，可以用来大体上估计自定义组件（或页面）更新性能。例如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     Component({
       attached() { // 调用时机不能早于 attached
         this.setUpdatePerformanceListener({withDataPaths: true}, (res) => {
           console.log(res)
         })
       }
     })
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 =setUpdatePerformanceListener= 方法接受一个 =options= 对象和回调函数
 =listener= 作为参数。

 其中， =options= 对象包含以下字段：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 字段            | 类型      | 说明                           |
 |-----------------+-----------+--------------------------------|
 | withDataPaths   | Boolean   | 是否返回变更的 data 字段信息   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 =listeners= 返回携带一个 =res= 对象，表示一次由 setData 引发的
 *更新过程* 。根据 setData 调用时机的不同，更新过程大体可以分为三类：

 1. *基本更新* ，它有一个唯一的 =updateProcessId= ；
 2. *子更新* ，它是另一个基本更新的一个子步骤，也有唯一的
    =updateProcessId= ，但还有一个 =parentUpdateProcessId= ；
 3. *被合并更新*
    ，它被合并到了另一个基本更新或子更新过程中，无法被独立统计。

 每次成功的 setData 调用都会产生一个更新过程，使得 =listener=
 回调一次。不过 setData
 究竟触发了哪类更新过程很难判断，更新性能好坏与其具体是哪类更新也没有必然联系，只是它们的返回值参数有所不同。

 =res= 中包含以下字段：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | 字段                    | 类型      | 说明                                                                       |
 |-------------------------+-----------+----------------------------------------------------------------------------|
 | updateProcessId         | Number    | 此次更新过程的 ID                                                          |
 | parentUpdateProcessId   | Number    | 对于子更新，返回它所属的更新过程 ID                                        |
 | isMergedUpdate          | Boolean   | 是否是被合并更新，如果是，则 =updateProcessId= 表示被合并到的更新过程 ID   |
 | dataPaths               | Array     | 此次更新的 data 字段信息，只有 =withDataPaths= 设为 =true= 时才会返回      |
 | pendingStartTimestamp   | Number    | 此次更新进入等待队列时的时间戳                                             |
 | updateStartTimestamp    | Number    | 更新运算开始时的时间戳                                                     |
 | updateEndTimestamp      | Number    | 更新运算结束时的时间戳                                                     |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 说明：

 -  =setUpdatePerformanceListener= 只会激活当前组件或页面的统计，
    =parentUpdateProcessId= 有可能是其他组件或者页面的更新过程 ID
    而未被统计回调，如果想要知道页面内所有的更新过程，需要在所有组件中都调用
    =setUpdatePerformanceListener= ；
 -  统计本身有一点点开销，如果想要禁用统计，调用
    =setUpdatePerformanceListener= 时传入第二个参数 =listener= 为 =null=
    即可。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/update-perf-stat.html]]

 \\
 \\
 | [[../index_u67.html#article_70][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u15.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_72/index_u25.html][下一项]] |
 [[../index_u67.html#article_71][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_70/index_u11.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u15.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

* [[index_u15.html#插件][#]] 插件

插件是对一组 js 接口、[[../custom-component][自定义组件]]或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。

插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。

相对于普通 js 文件或自定义组件，插件拥有更强的独立性，拥有独立的 API
接口、域名列表等，但同时会受到一些限制，如[[file:api-limit.html][一些
API
无法调用或功能受限]]。还有个别特殊的接口，虽然插件不能直接调用，但可以使用
[[file:functional-pages.html][插件功能页]] 来间接实现。

同时，框架会对小程序和小程序使用的每个插件进行数据安全保护，保证它们之间不能窃取其他任何一方的数据（除非数据被主动传递给另一方）。

对于插件开发者，请阅读[[file:development.html][开发插件]]章节；对于插件使用者，请阅读[[file:using.html][使用插件]]章节。

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

--------------

This article was downloaded by *calibre* from
[[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/]]

\\
\\
| [[../index_u67.html#article_71][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |

#+BEGIN_HTML
  </div>
#+END_HTML

<<index_u25.html>>

#+BEGIN_HTML
  <div class="calibre_navbar">
#+END_HTML

| [[../article_73/index_u14.html][下一项]] |
[[../index_u67.html#article_72][段落菜单]] |
[[../../index_u64.html#feed_0][主菜单]] |
[[../article_71/index_u15.html][上一项]] |

--------------

#+BEGIN_HTML
  </div>
#+END_HTML

#+BEGIN_HTML
  <div id="index_u25.html#docContent" class="calibre6">
#+END_HTML

#+BEGIN_HTML
  <div class="calibre6">
#+END_HTML

** [[index_u25.html#开发插件][#]] 开发插件
   :PROPERTIES:
   :CUSTOM_ID: index_u25.html#开发插件
   :CLASS:    calibre9
   :END:

 开发插件前，请阅读了解[[https://developers.weixin.qq.com/miniprogram/introduction/plugin.html][《小程序插件接入指南》<<>>]]了解开通流程及开放范围，并开通插件功能。如果未开通插件功能，将无法上传插件。

*** [[index_u25.html#创建插件项目][#]] 创建插件项目
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#创建插件项目
    :CLASS:    calibre11
    :END:

 插件类型的项目可以在开发者工具中直接创建。[[../../devtools/plugin.html][详情]]

 [[file:feed_0/article_72/images/img1_u16.png]]

 新建插件类型的项目后，如果创建示例项目，则项目中将包含三个目录：

 -  =plugin= 目录：插件代码目录。
 -  =miniprogram= 目录：放置一个小程序，用于调试插件。
 -  =doc= 目录：用于放置插件开发文档。

 =miniprogram=
 目录内容可以当成普通小程序来编写，用于插件调试、预览和审核。下面的内容主要介绍
 =plugin= 中的插件代码及 =doc= 中的插件开发文档。

 我们提供了[[https://developers.weixin.qq.com/s/NrPCBmmT7B1B][一个可以直接在微信开发者工具中查看的完整插件示例<<>>]]，开发者可以和本文互相对照以便理解。请注意：

 1. 由于插件需要 appid 才能工作，请填入一个 appid；
 2. 由于当前代码片段的限制，打开该示例后请 *手动将 appid 填写到
    =miniprogram/app.json= 中（如下图）使示例正常运行。*

 [[file:feed_0/article_72/images/img2_u5.png]]

*** [[index_u25.html#插件目录结构][#]] 插件目录结构
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#插件目录结构
    :CLASS:    calibre11
    :END:

 一个插件可以包含若干个自定义组件、页面，和一组 js
 接口。插件的目录内容如下：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     plugin
     ├── components
     │   ├── hello-component.js   // 插件提供的自定义组件（可以有多个）
     │   ├── hello-component.json
     │   ├── hello-component.wxml
     │   └── hello-component.wxss
     ├── pages
     │   ├── hello-page.js        // 插件提供的页面（可以有多个，自小程序基础库版本 2.1.0 开始支持）
     │   ├── hello-page.json
     │   ├── hello-page.wxml
     │   └── hello-page.wxss
     ├── index.js                 // 插件的 js 接口
     └── plugin.json              // 插件配置文件
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

*** [[index_u25.html#插件配置文件][#]] 插件配置文件
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#插件配置文件
    :CLASS:    calibre11
    :END:

 向使用者小程序开放的所有自定义组件、页面和 js 接口都必须在插件配置文件
 =plugin.json= 列出，格式如下：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "publicComponents": {
         "hello-component": "components/hello-component"
       },
       "pages": {
         "hello-page": "pages/hello-page"
       },
       "main": "index.js"
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 这个配置文件将向使用者小程序开放一个自定义组件
 =hello-component=，一个页面 =hello-page= 和 =index.js= 下导出的所有 js
 接口。

*** [[index_u25.html#进行插件开发][#]] 进行插件开发
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#进行插件开发
    :CLASS:    calibre11
    :END:

 请注意：在插件开发中，只有[[file:api-limit.html][部分接口]]可以直接调用；另外还有部分能力（如
 获取用户信息 和 发起支付
 等）可以通过[[file:functional-pages.html][插件功能页]]的方式使用。

**** [[index_u25.html#自定义组件][#]] 自定义组件
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#自定义组件
     :CLASS:    calibre25
     :END:

 插件可以定义若干个自定义组件，这些自定义组件都可以在插件内相互引用。但提供给使用者小程序使用的自定义组件必须在配置文件的
 =publicComponents= 段中列出（参考上文）。

 除去接口限制以外，自定义组件的编写和组织方式与一般的自定义组件相同，每个自定义组件由
 =wxml=, =wxss=, =js= 和 =json=
 四个文件组成。具体可以参考[[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/][自定义组件的文档<<>>]]。

**** [[index_u25.html#页面][#]] 页面
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#页面
     :CLASS:    calibre25
     :END:

 插件从小程序基础库版本 [[../compatibility.html][2.1.0]]
 开始支持页面。插件可以定义若干个插件页面，可以从本插件的自定义组件、其他页面中跳转，或从使用者小程序中跳转。所有页面必须在配置文件的
 =pages= 段中列出（参考上文）。

 除去接口限制以外，插件的页面编写和组织方式与一般的页面相同，每个页面由
 =wxml=, =wxss=, =js= 和 =json=
 四个文件组成。具体可以参考其他关于页面的文档。

 插件执行页面跳转的时候，可以使用 =navigator=
 组件。当插件跳转到自身页面时， =url=
 应设置为这样的形式：=plugin-private://PLUGIN_APPID/PATH/TO/PAGE=
 。需要跳转到其他插件时，也可以这样设置 =url= 。

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <navigator url="plugin-private://wxidxxxxxxxxxxxxxx/pages/hello-page">
       Go to pages/hello-page!
     </navigator>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 自基础库版本 [[../compatibility.html][2.2.2]]
 开始，在插件自身的页面中，插件还可以调用
 [[../../api/route/wx.navigateTo.html][wx.navigateTo]] 来进行页面跳转，
 =url= 格式与使用 =navigator= 组件时相仿。

**** [[index_u25.html#接口][#]] 接口
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#接口
     :CLASS:    calibre25
     :END:

 插件可以在接口文件（在配置文件中指定，详情见上文）中 export 一些 js
 接口，供插件的使用者调用，如：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     module.exports = {
       hello: function() {
         console.log('Hello plugin!')
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u25.html#获取小程序导出][#]] 获取小程序导出
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#获取小程序导出
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   [[https://developers.weixin.qq.com/s/GbXmMLml7vjC][在开发者工具中预览效果<<>>]]，需要手动填写一下
   =miniprogram/app.json= 中的插件 AppID
 #+END_QUOTE

 从基础库 [[../compatibility.html][2.11.1]] 起，在插件中有全局函数
 =requireMiniProgram=，可以获取由使用者小程序导出的内容。

 例如，使用者小程序做了如下导出：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 使用者小程序
     module.exports = {
       greeting() {
         return 'Greetings from Weixin MiniProgram!';
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 那么在插件中，可以这样获得内容：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // 插件
     const miniProgramExports = requireMiniProgram();
     miniProgramExports.greeting(); // 'Greetings from Weixin MiniProgram!'
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 另外也可以 [[file:using.html#导出到插件][参考使用者小程序的相关文档]]

**** [[index_u25.html#引用小程序的自定义组件][#]] 引用小程序的自定义组件
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#引用小程序的自定义组件
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   [[https://developers.weixin.qq.com/s/QRRovLmu7Xjm][在开发者工具中预览效果<<>>]]，需要手动填写一下
   =miniprogram/app.json= 中的插件 AppID
 #+END_QUOTE

 有时，插件可能需要在页面或者自定义组件中，将一部分区域交给使用的小程序来渲染，因此需要能够引用小程序的自定义组件。但由于插件中不能直接指定小程序的自定义组件路径，因此无法直接通过
 =usingComponents= 的方式来引用。这里介绍通过
 [[../custom-component/generics.html][抽象节点（generics）]]
 来实现引用的方式。

 如果是插件自定义组件（例如 =plugin-view=），那么我们可以通过声明一个
 generic：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // plugin/components/plugin-view.json
     { "componentGenerics": { "mp-view": true } }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 并在希望显示小程序组件的位置引用：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- plugin/components/plugin-view.wxml -->
     <view>小程序组件：</view>
     <mp-view /><!-- 这里是一个小程序自定义组件 -->
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在小程序中引用 =plugin-view= 时，就可以传递组件给插件进行渲染了：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- miniprogram/page/index.wxml -->
     <plugin-view generic:mp-view="comp-from-miniprogram" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 如果是插件页，插件页本身就是一个页面顶层组件，小程序不会引用它，无法通过
 =generic:xxx=""= 的方式来指定抽象节点实现；因此，从基础库
 [[../compatibility.html][2.12.2]]
 起，小程序可以在插件的配置里为插件页指定抽象节点实现。例如插件页面名为
 =plugin-index=，则可以：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "myPlugin": {
         "provider": "wxAPPID",
         "version": "1.0.0",
         "genericsImplementation": {
           "plugin-index": {
             "mp-view": "components/comp-from-miniprogram"
           }
         }
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 另外也可以
 [[file:using.html#为插件提供自定义组件][参考使用者小程序的相关文档]]

*** [[index_u25.html#预览、上传和发布][#]] 预览、上传和发布
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#预览、上传和发布
    :CLASS:    calibre11
    :END:

 插件可以像小程序一样预览和上传，但插件没有体验版。

 插件会同时有多个线上版本，由使用插件的小程序决定具体使用的版本号。

 手机预览和提审插件时，会使用一个特殊的小程序来套用项目中 =miniprogram=
 文件夹下的小程序，从而预览插件。

 -  （建议的方式）如果当前开发者有[[../../devtools/sandbox.html][测试号]]，则会使用这个测试号；在测试号的设置页中可以看到测试号的
    =appid= 、 =appsecret= 并设置域名列表。
 -  否则，将使用“插件开发助手”，它具有一个特定的 =appid= 。

*** [[index_u25.html#在开发版小程序中测试][#]] 在开发版小程序中测试
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#在开发版小程序中测试
    :CLASS:    calibre11
    :END:

 通常情况下，可以将 =miniprogram=
 下的代码当做使用插件的小程序代码，来进行插件的调试和测试。

 但有时，需要将插件的代码放在实际运行的小程序中进行调试、测试。此时，可以使用开发版的小程序直接引用开发版插件。方法如下：

 1. 在开发者工具的插件项目中上传插件，此时，在上传成功的通知信息中将包含这次上传获得的插件开发版
    ID （一个英文、数字组成的随机字符串）；
 2. 点击开发者工具右下角的通知按钮，可以打开通知栏，看到新生成的 ID ；
 3. 在使用这个插件的任意小程序项目中，可以将插件 version 设置为
    ="version": "dev-[开发版ID]"= 的形式，如
    ="version": "dev-abcdef0123456789abcdef0123456789"= ；
 4. 这样就会引用到这次上传的开发版插件；
 5. 注意，再次上传插件时， ID 可能会改变。

 如果开发版小程序引用了开发版插件，此时这个小程序就不能上传发布了。必须要将插件版本设为正式版本之后，小程序才可以正常上传、发布。

*** [[index_u25.html#插件开发文档][#]] 插件开发文档
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#插件开发文档
    :CLASS:    calibre11
    :END:

 在使用者小程序使用插件时，插件代码并不可见。因此，除了插件代码，我们还支持插件开发者上传一份插件开发文档。这份开发文档将展示在插件详情页，供其他开发者在浏览插件和使用插件时进行阅读和参考。插件开发者应在插件开发文档中对插件提供的自定义组件、页面、接口等进行必要的描述和解释，方便使用者小程序正确使用插件。

 插件开发文档必须放置在插件项目根目录中的 =doc= 目录下，目录结构如下：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     doc
     ├── README.md   // 插件文档，应为 markdown 格式
     └── picture.jpg // 其他资源文件，仅支持图片
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 其中，=README.md= 的编写有一定的 *限制条件*，具体来说：

 1. 引用到的图片资源不能是网络图片，且必须放在这个目录下；
 2. 文档中的链接只能链接到：

    -  微信开发者社区（developers.weixin.qq.com）
    -  微信公众平台（mp.weixin.qq.com）
    -  GitHub（github.com）

 编辑 =README.md= 之后，可以在开发者工具左侧资源管理器的文件栏中右键单击
 =README.md=，并选择上传文档。发布上传文档后，文档不会立刻发布。此时可以使用帐号和密码登录
 [[https://mp.weixin.qq.com][管理后台<<>>]] ，在 小程序插件 > 基本设置
 中预览、发布插件文档。

*** [[index_u25.html#其他注意事项][#]] 其他注意事项
    :PROPERTIES:
    :CUSTOM_ID: index_u25.html#其他注意事项
    :CLASS:    calibre11
    :END:

**** [[index_u25.html#插件间互相调用][#]] 插件间互相调用
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#插件间互相调用
     :CLASS:    calibre25
     :END:

 插件不能直接引用其他插件。但如果小程序引用了多个插件，插件之间是可以互相调用的。

 一个插件调用另一个插件的方法，与插件调用自身的方法类似。可以使用
 =plugin-private://APPID= 访问插件的自定义组件、页面（暂不能使用
 =plugin://= ）。

 对于 js 接口，可使用 =requirePlugin= ，但目前尚不能在文件一开头就使用
 requirePlugin ，因为被依赖的插件可能还没有初始化，请考虑在更晚的时机调用
 =requirePlugin= ，如接口被实际调用时、组件 attached
 时。（未来会修复这个问题。）

**** [[index_u25.html#插件请求签名][#]] 插件请求签名
     :PROPERTIES:
     :CUSTOM_ID: index_u25.html#插件请求签名
     :CLASS:    calibre25
     :END:

 插件在使用 [[../../api/network/request/wx.request.html][wx.request]] 等
 API 发送网络请求时，将会额外携带一个签名 =HostSign=
 ，用于验证请求来源于小程序插件。这个签名位于请求头中，形如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     X-WECHAT-HOSTSIGN: {"noncestr":"NONCESTR", "timestamp":"TIMESTAMP", "signature":"SIGNATURE"}
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 其中， =NONCESTR= 是一个随机字符串， =TIMESTAMP= 是生成这个随机字符串和
 =SIGNATURE= 的 UNIX 时间戳。它们是用于计算签名 =SIGNATRUE=
 的参数，签名算法为：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     SIGNATURE = sha1([APPID, NONCESTR, TIMESTAMP, TOKEN].sort().join(''))
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 其中，=APPID= 是 *所在小程序* 的 AppId （可以从请求头的 =referrer=
 中获得）；=TOKEN= 是插件 Token，可以在小程序插件基本设置中找到。

 网络请求的 referer 格式固定为
 https://servicewechat.com/{appid}/{version}/page-frame.html，其中
 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0
 表示为开发版、体验版以及审核版本，版本号为 devtools
 表示为开发者工具，其余为正式版本。

 插件开发者可以在服务器上按以下步骤校验签名：

 1. =sort= 对 =APPID= =NONCESTR= =TIMESTAMP= =TOKEN=
    四个值表示成字符串形式，按照字典序排序（同 JavaScript 数组的 sort
    方法）；
 2. =join= 将排好序的四个字符串直接连接在一起；
 3. 对连接结果使用 =sha1= 算法，其结果即 =SIGNATURE= 。

 自基础库版本 [[../compatibility.html][2.0.7]]
 开始，在小程序运行期间，若网络状况正常， =NONCESTR= 和 =TIMESTAMP= 会每
 10 分钟变更一次。如有必要，可以通过判断 =TIMESTAMP=
 来确定当前签名是否依旧有效。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html]]

 \\
 \\
 | [[../index_u67.html#article_72][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u14.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_74/index_u50.html][下一项]] |
 [[../index_u67.html#article_73][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_72/index_u25.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u14.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u14.html#使用插件][#]] 使用插件
   :PROPERTIES:
   :CUSTOM_ID: index_u14.html#使用插件
   :CLASS:    calibre9
   :END:

*** [[index_u14.html#添加插件][#]] 添加插件
    :PROPERTIES:
    :CUSTOM_ID: index_u14.html#添加插件
    :CLASS:    calibre11
    :END:

 在使用插件前，首先要在小程序管理后台的“设置-第三方服务-插件管理”中添加插件。开发者可登录小程序管理后台，通过
 appid
 查找插件并添加。如果插件无需申请，添加后可直接使用；否则需要申请并等待插件开发者通过后，方可在小程序中使用相应的插件。

*** [[index_u14.html#引入插件代码包][#]] 引入插件代码包
    :PROPERTIES:
    :CUSTOM_ID: index_u14.html#引入插件代码包
    :CLASS:    calibre11
    :END:

 使用插件前，使用者要在 =app.json= 中声明需要使用的插件，例如：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "plugins": {
         "myPlugin": {
           "version": "1.0.0",
           "provider": "wxidxxxxxxxxxxxxxxxx"
         }
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 如上例所示， =plugins=
 定义段中可以包含多个插件声明，每个插件声明以一个使用者自定义的插件引用名作为标识，并指明插件的
 appid 和需要使用的版本号。其中，引用名（如上例中的
 =myPlugin=）由使用者自定义，无需和插件开发者保持一致或与开发者协调。在后续的插件使用中，该引用名将被用于表示该插件。

*** [[index_u14.html#在分包内引入插件代码包][#]] 在分包内引入插件代码包
    :PROPERTIES:
    :CUSTOM_ID: index_u14.html#在分包内引入插件代码包
    :CLASS:    calibre11
    :END:

 如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "subpackages": [
         {
           "root": "packageA",
           "pages": [
             "pages/cat",
             "pages/dog"
           ],
           "plugins": {
             "myPlugin": {
               "version": "1.0.0",
               "provider": "wxidxxxxxxxxxxxxxxxx"
             }
           }
         }
       ]
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 在分包内使用插件有如下限制：

 -  仅能在这个分包内使用该插件；
 -  同一个插件不能被多个分包同时引用；
 -  如果基础库版本低于 2.9.0
    ，不能从分包外的页面直接跳入分包内的插件页面，需要先跳入分包内的非插件页面、再跳入同一分包内的插件页面。

*** [[index_u14.html#使用插件-2][#]] 使用插件
    :PROPERTIES:
    :CUSTOM_ID: index_u14.html#使用插件-2
    :CLASS:    calibre11
    :END:

 使用插件时，插件的代码对于使用者来说是不可见的。为了正确使用插件，使用者应查看插件详情页面中的“开发文档”一节，阅读由插件开发者提供的插件开发文档，通过文档来明确插件提供的自定义组件、页面名称及提供的
 js 接口规范等。

**** [[index_u14.html#自定义组件][#]] 自定义组件
     :PROPERTIES:
     :CUSTOM_ID: index_u14.html#自定义组件
     :CLASS:    calibre25
     :END:

 使用插件提供的自定义组件，和[[../custom-component][使用普通自定义组件]]的方式相仿。在
 =json= 文件定义需要引入的自定义组件时，使用 =plugin://=
 协议指明插件的引用名和自定义组件名，例如：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "usingComponents": {
         "hello-component": "plugin://myPlugin/hello-component"
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：

 -  默认情况下，页面中的 =this.selectComponent=
    接口无法获得插件的自定义组件实例对象；
 -  [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
    等接口的 =>>>= 选择器无法选入插件内部。

**** [[index_u14.html#页面][#]] 页面
     :PROPERTIES:
     :CUSTOM_ID: index_u14.html#页面
     :CLASS:    calibre25
     :END:

 插件的页面从小程序基础库版本 [[../compatibility.html][2.1.0]] 开始支持。

 需要跳转到插件页面时，=url= 使用 =plugin://= 前缀，形如
 =plugin://PLUGIN_NAME/PLUGIN_PAGE=， 如：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <navigator url="plugin://myPlugin/hello-page">
       Go to pages/hello-page!
     </navigator>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u14.html#js-接口][#]] js 接口
     :PROPERTIES:
     :CUSTOM_ID: index_u14.html#js-接口
     :CLASS:    calibre25
     :END:

 使用插件的 js 接口时，可以使用 =requirePlugin=
 方法。例如，插件提供一个名为 =hello= 的方法和一个名为 =world=
 的变量，则可以像下面这样调用：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     var myPluginInterface = requirePlugin('myPlugin');

     myPluginInterface.hello();
     var myWorld = myPluginInterface.world;
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u14.html#导出到插件][#]] 导出到插件
     :PROPERTIES:
     :CUSTOM_ID: index_u14.html#导出到插件
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   [[https://developers.weixin.qq.com/s/GbXmMLml7vjC][在开发者工具中预览效果<<>>]]，需要手动填写一下
   =miniprogram/app.json= 中的插件 AppID
 #+END_QUOTE

 从基础库 [[../compatibility.html][2.11.1]]
 起，使用插件的小程序可以导出一些内容，供插件获取。具体来说，在声明使用插件时，可以通过
 =export= 字段来指定一个文件，如：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "myPlugin": {
         "version": "1.0.0",
         "provider": "wxidxxxxxxxxxxxxxxxx",
         "export": "index.js"
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 则该文件（上面的例子里是
 =index.js=）导出的内容可以被这个插件用全局函数获得。例如，在上面的文件中，使用插件的小程序做了如下导出：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // index.js
     module.exports = { whoami: 'Wechat MiniProgram' }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 那么插件就可以获得上面导出的内容：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     // plugin
     requireMiniProgram().whoami // 'Wechat MiniProgram'
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 具体导出什么内容，可以阅读插件开发文档，和插件的开发者做好约定。

 当插件在分包中时，这个特性也可以使用，但指定的文件的路径是相对于分包的。例如在
 =root: packageA= 的分包中指定了
 =export: exports/plugin.js=，那么被指定的文件在文件系统上应该是
 =/packageA/exports/plugin.js=。

 使用的多个插件的导出互不影响，两个插件可以导出同一个文件，也可以是不同的文件。但导出同一个文件时，如果一个插件对导出内容做了修改，那么另一个插件也会被影响，请注意这一点。

 *请谨慎导出 wx 对象或某个具体的 wx
 API，这将使插件可以以使用者小程序的身份调用 API。*

 另外也可以
 [[file:development.html#获取小程序导出][参考开发插件的相关文档]]

**** [[index_u14.html#为插件提供自定义组件][#]] 为插件提供自定义组件
     :PROPERTIES:
     :CUSTOM_ID: index_u14.html#为插件提供自定义组件
     :CLASS:    calibre25
     :END:

 #+BEGIN_QUOTE
   [[https://developers.weixin.qq.com/s/QRRovLmu7Xjm][在开发者工具中预览效果<<>>]]，需要手动填写一下
   =miniprogram/app.json= 中的插件 AppID
 #+END_QUOTE

 有时，插件可能会在页面或者自定义组件中，将一部分区域交给使用的小程序来渲染，因此需要使用的小程序提供一个自定义组件。但由于插件中不能直接指定小程序的自定义组件路径，因此需要通过为插件指定
 [[../custom-component/generics.html][抽象节点（generics）]]
 的方式来提供。

 如果是插件的自定义组件需要指定抽象节点实现，可以在引用时指定：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <!-- miniprogram/page/index.wxml -->
     <plugin-view generic:mp-view="comp-from-miniprogram" />
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 从基础库 [[../compatibility.html][2.12.2]]
 起，可以通过配置项为插件页面指定抽象组件实现。例如，要给插件名为
 =plugin-index= 的页面中的抽象节点 =mp-view= 指定小程序的自定义组件
 =components/comp-from-miniprogram= 作为实现的话：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "myPlugin": {
         "provider": "wxAPPID",
         "version": "1.0.0",
         "genericsImplementation": {
           "plugin-index": {
             "mp-view": "components/comp-from-miniprogram"
           }
         }
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 另外也可以
 [[file:development.html#引用小程序的自定义组件][参考开发插件的相关文档]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html]]

 \\
 \\
 | [[../index_u67.html#article_73][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u50.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_75/index_u62.html][下一项]] |
 [[../index_u67.html#article_74][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_73/index_u14.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u50.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** 插件调用 API 的限制
 插件可以调用的 API 与小程序不同，主要有两个区别：

 -  插件的请求域名列表与小程序相互独立；
 -  一些 API 不允许插件调用（这些函数不存在于 =wx= 对象下）。

 有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考[[file:functional-pages.html][插件功能页]]。

 目前，允许插件调用的 API 及其对应版本要求如下：

**** [[index_u50.html#基础][#]] 基础
   | API                                                                      | 最低版本   | 备注   |
 |--------------------------------------------------------------------------+------------+--------|
 | [[../../api/base/wx.arrayBufferToBase64.html][wx.arrayBufferToBase64]]   |            |        |
 | [[../../api/base/wx.base64ToArrayBuffer.html][wx.base64ToArrayBuffer]]   |            |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#发起请求][#]] 发起请求
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#发起请求
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                         | 最低版本                           | 备注   |
 |-------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/network/request/wx.request.html][wx.request]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#上传、下载][#]] 上传、下载
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#上传、下载
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                    | 最低版本                           | 备注   |
 |------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]         | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#WebSocket][#]] WebSocket
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#WebSocket
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                       | 最低版本                           | 备注   |
 |---------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#图片][#]] 图片
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#图片
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                   | 最低版本                           | 备注   |
 |---------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/image/wx.previewImage.html][wx.previewImage]]                       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/image/wx.chooseImage.html][wx.chooseImage]]                         | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/image/wx.getImageInfo.html][wx.getImageInfo]]                       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/image/wx.saveImageToPhotosAlbum.html][wx.saveImageToPhotosAlbum]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#录音][#]] 录音
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#录音
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                | 最低版本                           | 备注   |
 |--------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/recorder/wx.startRecord.html][wx.startRecord]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/recorder/wx.stopRecord.html][wx.stopRecord]]     | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#实时音视频][#]] 实时音视频
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#实时音视频
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                    | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/live/wx.createLivePlayerContext.html][wx.createLivePlayerContext]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/live/wx.createLivePusherContext.html][wx.createLivePusherContext]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#录音管理][#]] 录音管理
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#录音管理
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                              | 最低版本                            | 备注   |
 |----------------------------------------------------------------------------------+-------------------------------------+--------|
 | [[../../api/media/recorder/wx.getRecorderManager.html][wx.getRecorderManager]]   | [[../compatibility.html][1.9.94]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#音频播放控制][#]] 音频播放控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#音频播放控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                           | 最低版本                           | 备注   |
 |---------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/audio/wx.pauseVoice.html][wx.pauseVoice]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/audio/wx.playVoice.html][wx.playVoice]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/audio/wx.stopVoice.html][wx.stopVoice]]     | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#音乐播放控制][#]] 音乐播放控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#音乐播放控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                                            | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/background-audio/wx.onBackgroundAudioPlay.html][wx.onBackgroundAudioPlay]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.getBackgroundAudioPlayerState.html][wx.getBackgroundAudioPlayerState]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.onBackgroundAudioStop.html][wx.onBackgroundAudioStop]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.stopBackgroundAudio.html][wx.stopBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.onBackgroundAudioPause.html][wx.onBackgroundAudioPause]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.seekBackgroundAudio.html][wx.seekBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.playBackgroundAudio.html][wx.playBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/background-audio/wx.pauseBackgroundAudio.html][wx.pauseBackgroundAudio]]                     | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#背景音频播放管理][#]] 背景音频播放管理
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#背景音频播放管理
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                                    | 最低版本                           | 备注   |
 |--------------------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/background-audio/wx.getBackgroundAudioManager.html][wx.getBackgroundAudioManager]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#音频组件控制][#]] 音频组件控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#音频组件控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                     | 最低版本                           | 备注   |
 |-----------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/audio/wx.createInnerAudioContext.html][wx.createInnerAudioContext]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/audio/wx.createAudioContext.html][wx.createAudioContext]]             | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#视频][#]] 视频
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#视频
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                   | 最低版本                           | 备注   |
 |---------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/video/wx.chooseVideo.html][wx.chooseVideo]]                         | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/media/video/wx.saveVideoToPhotosAlbum.html][wx.saveVideoToPhotosAlbum]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#视频组件控制][#]] 视频组件控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#视频组件控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                           | 最低版本                           | 备注   |
 |-------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/video/wx.createVideoContext.html][wx.createVideoContext]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#相机组件控制][#]] 相机组件控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#相机组件控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                              | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/camera/wx.createCameraContext.html][wx.createCameraContext]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#数据缓存][#]] 数据缓存
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#数据缓存
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                     | 最低版本                           | 备注   |
 |-------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/storage/wx.setStorage.html][wx.setStorage]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/storage/wx.getStorage.html][wx.getStorage]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/storage/wx.removeStorage.html][wx.removeStorage]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]         | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/storage/wx.getStorageSync.html][wx.getStorageSync]]         | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/storage/wx.removeStorageSync.html][wx.removeStorageSync]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#获取位置][#]] 获取位置
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#获取位置
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                          | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/location/wx.getLocation.html][wx.getLocation]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/location/wx.chooseLocation.html][wx.chooseLocation]]             | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/location/wx.onLocationChange.html][wx.onLocationChange]]         | [[../compatibility.html][2.8.0]]   |        |
 | [[../../api/location/wx.offLocationChange.html][wx.offLocationChange]]       | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/location/wx.stopLocationUpdate.html][wx.stopLocationUpdate]]     | [[../compatibility.html][2.8.0]]   |        |
 | [[../../api/location/wx.startLocationUpdate.html][wx.startLocationUpdate]]   | [[../compatibility.html][2.8.0]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#查看位置][#]] 查看位置
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#查看位置
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                            | 最低版本                           | 备注   |
 |----------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/location/wx.openLocation.html][wx.openLocation]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#地图组件控制][#]] 地图组件控制
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#地图组件控制
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                     | 最低版本                           | 备注   |
 |-------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/media/map/wx.createMapContext.html][wx.createMapContext]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#系统信息][#]] 系统信息
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#系统信息
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                     | 最低版本                           | 备注   |
 |-----------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/base/system/system-info/wx.getSystemInfoSync.html][wx.getSystemInfoSync]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/base/system/system-info/wx.getSystemInfo.html][wx.getSystemInfo]]           | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#屏幕亮度][#]] 屏幕亮度
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#屏幕亮度
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                               | 最低版本                           | 备注   |
 |-----------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/screen/wx.setKeepScreenOn.html][wx.setKeepScreenOn]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/screen/wx.setScreenBrightness.html][wx.setScreenBrightness]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/screen/wx.getScreenBrightness.html][wx.getScreenBrightness]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#用户截屏事件][#]] 用户截屏事件
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#用户截屏事件
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                 | 最低版本                           | 备注                 |
 |-------------------------------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/device/screen/wx.onUserCaptureScreen.html][wx.onUserCaptureScreen]]     | [[../compatibility.html][1.9.6]]   | 仅限插件页面中调用   |
 | [[../../api/device/screen/wx.offUserCaptureScreen.html][wx.offUserCaptureScreen]]   | [[../compatibility.html][2.9.1]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#振动][#]] 振动
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#振动
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                  | 最低版本                           | 备注   |
 |----------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/vibrate/wx.vibrateLong.html][wx.vibrateLong]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/vibrate/wx.vibrateShort.html][wx.vibrateShort]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#手机联系人][#]] 手机联系人
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#手机联系人
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                        | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/contact/wx.addPhoneContact.html][wx.addPhoneContact]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#NFC][#]] NFC
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#NFC
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                  | 最低版本                           | 备注   |
 |----------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/nfc/wx.sendHCEMessage.html][wx.sendHCEMessage]]   | [[../compatibility.html][2.1.0]]   |        |
 | [[../../api/device/nfc/wx.stopHCE.html][wx.stopHCE]]                 | [[../compatibility.html][2.1.0]]   |        |
 | [[../../api/device/nfc/wx.onHCEMessage.html][wx.onHCEMessage]]       | [[../compatibility.html][2.1.0]]   |        |
 | [[../../api/device/nfc/wx.offHCEMessage.html][wx.offHCEMessage]]     | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/nfc/wx.startHCE.html][wx.startHCE]]               | [[../compatibility.html][2.1.0]]   |        |
 | [[../../api/device/nfc/wx.getHCEState.html][wx.getHCEState]]         | [[../compatibility.html][2.1.0]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#网络状态][#]] 网络状态
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#网络状态
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                      | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/network/wx.onNetworkStatusChange.html][wx.onNetworkStatusChange]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/network/wx.offNetworkStatusChange.html][wx.offNetworkStatusChange]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/network/wx.getNetworkType.html][wx.getNetworkType]]                   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#加速度计][#]] 加速度计
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#加速度计
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                            | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/accelerometer/wx.startAccelerometer.html][wx.startAccelerometer]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/accelerometer/wx.stopAccelerometer.html][wx.stopAccelerometer]]             | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/accelerometer/wx.onAccelerometerChange.html][wx.onAccelerometerChange]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/accelerometer/wx.offAccelerometerChange.html][wx.offAccelerometerChange]]   | [[../compatibility.html][2.9.1]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#设备方向][#]] 设备方向
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#设备方向
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                             | 最低版本                           | 备注   |
 |-------------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/motion/wx.startDeviceMotionListening.html][wx.startDeviceMotionListening]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/motion/wx.stopDeviceMotionListening.html][wx.stopDeviceMotionListening]]     | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/motion/wx.offDeviceMotionChange.html][wx.offDeviceMotionChange]]             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/motion/wx.onDeviceMotionChange.html][wx.onDeviceMotionChange]]               | [[../compatibility.html][2.9.1]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#陀螺仪][#]] 陀螺仪
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#陀螺仪
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/gyroscope/wx.startGyroscope.html][wx.startGyroscope]]           | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/gyroscope/wx.stopGyroscope.html][wx.stopGyroscope]]             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/gyroscope/wx.offGyroscopeChange.html][wx.offGyroscopeChange]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/gyroscope/wx.onGyroscopeChange.html][wx.onGyroscopeChange]]     | [[../compatibility.html][2.9.1]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#罗盘][#]] 罗盘
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#罗盘
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                          | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/compass/wx.onCompassChange.html][wx.onCompassChange]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/compass/wx.offCompassChange.html][wx.offCompassChange]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/compass/wx.stopCompass.html][wx.stopCompass]]             | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/compass/wx.startCompass.html][wx.startCompass]]           | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#拨打电话][#]] 拨打电话
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#拨打电话
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                  | 最低版本                           | 备注   |
 |----------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/phone/wx.makePhoneCall.html][wx.makePhoneCall]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#扫码][#]] 扫码
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#扫码
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                       | 最低版本                           | 备注   |
 |-----------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/scan/wx.scanCode.html][wx.scanCode]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#剪贴板][#]] 剪贴板
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#剪贴板
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                            | 最低版本                           | 备注   |
 |--------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/clipboard/wx.setClipboardData.html][wx.setClipboardData]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/clipboard/wx.getClipboardData.html][wx.getClipboardData]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#蓝牙][#]] 蓝牙
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#蓝牙
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                                                    | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/bluetooth-ble/wx.writeBLECharacteristicValue.html][wx.writeBLECharacteristicValue]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.startBluetoothDevicesDiscovery.html][wx.startBluetoothDevicesDiscovery]]               | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.getConnectedBluetoothDevices.html][wx.getConnectedBluetoothDevices]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.notifyBLECharacteristicValueChange.html][wx.notifyBLECharacteristicValueChange]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.onBluetoothDeviceFound.html][wx.onBluetoothDeviceFound]]                               | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.offBluetoothDeviceFound.html][wx.offBluetoothDeviceFound]]                             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/bluetooth-ble/wx.readBLECharacteristicValue.html][wx.readBLECharacteristicValue]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.openBluetoothAdapter.html][wx.openBluetoothAdapter]]                                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.getBLEDeviceCharacteristics.html][wx.getBLEDeviceCharacteristics]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.stopBluetoothDevicesDiscovery.html][wx.stopBluetoothDevicesDiscovery]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.onBLEConnectionStateChange.html][wx.onBLEConnectionStateChange]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.getBluetoothDevices.html][wx.getBluetoothDevices]]                                     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.getBluetoothAdapterState.html][wx.getBluetoothAdapterState]]                           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.onBluetoothAdapterStateChange.html][wx.onBluetoothAdapterStateChange]]                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.offBluetoothAdapterStateChange.html][wx.offBluetoothAdapterStateChange]]               | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/bluetooth-ble/wx.getBLEDeviceServices.html][wx.getBLEDeviceServices]]                               | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.onBLECharacteristicValueChange.html][wx.onBLECharacteristicValueChange]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.offBLECharacteristicValueChange.html][wx.offBLECharacteristicValueChange]]         | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/bluetooth-ble/wx.createBLEConnection.html][wx.createBLEConnection]]                                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth/wx.closeBluetoothAdapter.html][wx.closeBluetoothAdapter]]                                 | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.closeBLEConnection.html][wx.closeBLEConnection]]                                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.notifyBLECharacteristicValueChange.html][wx.notifyBLECharacteristicValueChange]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.onBLEConnectionStateChange.html][wx.onBLEConnectionStateChange]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/bluetooth-ble/wx.offBLEConnectionStateChange.html][wx.offBLEConnectionStateChange]]                 | [[../compatibility.html][2.9.1]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#iBeacon][#]] iBeacon
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#iBeacon
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                      | 最低版本                           | 备注   |
 |------------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/ibeacon/wx.getBeacons.html][wx.getBeacons]]                           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/ibeacon/wx.startBeaconDiscovery.html][wx.startBeaconDiscovery]]       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/ibeacon/wx.onBeaconServiceChange.html][wx.onBeaconServiceChange]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/ibeacon/wx.offBeaconServiceChange.html][wx.offBeaconServiceChange]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/ibeacon/wx.onBeaconUpdate.html][wx.onBeaconUpdate]]                   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/device/ibeacon/wx.offBeaconUpdate.html][wx.offBeaconUpdate]]                 | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/ibeacon/wx.stopBeaconDiscovery.html][wx.stopBeaconDiscovery]]         | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#Wi-Fi][#]] Wi-Fi
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#Wi-Fi
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                       | 最低版本                           | 备注   |
 |---------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/device/wifi/wx.connectWifi.html][wx.connectWifi]]             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.getConnectedWifi.html][wx.getConnectedWifi]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.getWifiList.html][wx.getWifiList]]             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.offGetWifiList.html][wx.offGetWifiList]]       | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.offWifiConnected.html][wx.offWifiConnected]]   | [[../compatibility.html][2.9.1]]   |        |
 | [[file:%28wx.onEvaluateWifi%29][wx.onEvaluateWifi]]                       | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.onGetWifiList.html][wx.onGetWifiList]]         | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.onWifiConnected.html][wx.onWifiConnected]]     | [[../compatibility.html][2.9.1]]   |        |
 | [[file:%28wx.presetWifiList%29][wx.presetWifiList]]                       | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.setWifiList.html][wx.setWifiList]]             | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.startWifi.html][wx.startWifi]]                 | [[../compatibility.html][2.9.1]]   |        |
 | [[../../api/device/wifi/wx.stopWifi.html][wx.stopWifi]]                   | [[../compatibility.html][2.9.1]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#交互反馈][#]] 交互反馈
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#交互反馈
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                        | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/ui/interaction/wx.hideLoading.html][wx.hideLoading]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/ui/interaction/wx.showActionSheet.html][wx.showActionSheet]]   | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/ui/interaction/wx.showLoading.html][wx.showLoading]]           | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/ui/interaction/wx.hideToast.html][wx.hideToast]]               | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/ui/interaction/wx.showToast.html][wx.showToast]]               | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/ui/interaction/wx.showModal.html][wx.showModal]]               | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#设置导航条][#]] 设置导航条
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#设置导航条
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                             | 最低版本                           | 备注                 |
 |-------------------------------------------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/ui/navigation-bar/wx.showNavigationBarLoading.html][wx.showNavigationBarLoading]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/ui/navigation-bar/wx.hideNavigationBarLoading.html][wx.hideNavigationBarLoading]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/ui/navigation-bar/wx.setNavigationBarColor.html][wx.setNavigationBarColor]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/ui/navigation-bar/wx.setNavigationBarTitle.html][wx.setNavigationBarTitle]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#背景][#]] 背景
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#背景
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                     | 最低版本                           | 备注                 |
 |-----------------------------------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/ui/background/wx.setBackgroundColor.html][wx.setBackgroundColor]]           | [[../compatibility.html][2.4.0]]   | 仅限插件页面中调用   |
 | [[../../api/ui/background/wx.setBackgroundTextStyle.html][wx.setBackgroundTextStyle]]   | [[../compatibility.html][2.4.0]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#WXML节点信息][#]] WXML 节点信息
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#WXML 节点信息
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                      | 最低版本                           | 备注   |
 |--------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#WXML节点布局相交状态][#]] WXML 节点布局相交状态
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#WXML 节点布局相交状态
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                                    | 最低版本                           | 备注   |
 |----------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#导航][#]] 导航
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#导航
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                         | 最低版本                           | 备注                 |
 |-------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/route/wx.navigateBack.html][wx.navigateBack]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/route/wx.navigateTo.html][wx.navigateTo]]       | [[../compatibility.html][2.2.2]]   | 仅限插件页面中调用   |
 | [[../../api/route/wx.redirectTo.html][wx.redirectTo]]       | [[../compatibility.html][2.2.2]]   | 仅限插件页面中调用   |
 | [[../../api/route/wx.switchTab.html][wx.switchTab]]         | [[../compatibility.html][2.3.1]]   | 仅限插件页面中调用   |
 | [[../../api/route/wx.reLaunch.html][wx.reLaunch]]           | [[../compatibility.html][2.3.1]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#动画][#]] 动画
     :PROPERTIES:
     :CUSTOM_ID: index_u50.html#动画
     :CLASS:    calibre25
     :END:

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 | API                                                                      | 最低版本                           | 备注   |
 |--------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]   | [[../compatibility.html][1.9.6]]   |        |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#位置][#]] 位置
 | API                                                             | 最低版本                           | 备注                 |
 |-----------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/ui/scroll/wx.pageScrollTo.html][wx.pageScrollTo]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#绘图][#]] 绘图

 | API                                                                            | 最低版本                           | 备注   |
 |--------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/canvas/wx.createOffscreenCanvas.html][wx.createOffscreenCanvas]]   | [[../compatibility.html][2.7.1]]   |        |
 | [[../../api/canvas/wx.canvasPutImageData.html][wx.canvasPutImageData]]         | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/canvas/wx.canvasToTempFilePath.html][wx.canvasToTempFilePath]]     | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/canvas/wx.createCanvasContext.html][wx.createCanvasContext]]       | [[../compatibility.html][1.9.6]]   |        |
 | [[../../api/canvas/wx.canvasGetImageData.html][wx.canvasGetImageData]]         | [[../compatibility.html][1.9.6]]   |        |

**** [[index_u50.html#下拉刷新][#]] 下拉刷新
 | API                                                                                        | 最低版本                           | 备注                 |
 |--------------------------------------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/ui/pull-down-refresh/wx.stopPullDownRefresh.html][wx.stopPullDownRefresh]]     | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/ui/pull-down-refresh/wx.startPullDownRefresh.html][wx.startPullDownRefresh]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |

 #+BEGIN_HTML
   </div>
 #+END_HTML

**** [[index_u50.html#当前帐号信息][#]] 当前帐号信息
 | API                                                                                     | 最低版本                           | 备注   |
 |-----------------------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/open-api/account-info/wx.getAccountInfoSync.html][wx.getAccountInfoSync]]   | [[../compatibility.html][2.2.2]]   |        |

**** [[index_u50.html#转发][#]] 转发
 | API                                                               | 最低版本                           | 备注                 |
 |-------------------------------------------------------------------+------------------------------------+----------------------|
 | [[../../api/share/wx.hideShareMenu.html][wx.hideShareMenu]]       | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/share/wx.getShareInfo.html][wx.getShareInfo]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/share/wx.showShareMenu.html][wx.showShareMenu]]       | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
 | [[../../api/share/wx.updateShareMenu.html][wx.updateShareMenu]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |

**** [[index_u50.html#其他][#]] 其他

 | API                                                                                | 最低版本                            | 备注         |
 |------------------------------------------------------------------------------------+-------------------------------------+--------------|
 | [[../../api/open-api/setting/wx.getSetting.html][wx.getSetting]]                   | [[../compatibility.html][2.6.3]]    |              |
 | [[../../api/open-api/setting/wx.openSetting.html][wx.openSetting]]                 | [[../compatibility.html][2.10.3]]   |              |
 | [[../../api/open-api/data-analysis/wx.reportAnalytics.html][wx.reportAnalytics]]   | [[../compatibility.html][1.9.6]]    | 见下方备注   |

**** [[index_u50.html#登录和获取用户信息][#]] 登录和获取用户信息
     *这一组接口仅限在用户信息功能页中获得用户授权之后调用。否则将返回 fail
 。详见 [[file:functional-pages/user-info.html][用户信息功能页]] 。*

 | API                                                                    | 最低版本                           | 备注   |
 |------------------------------------------------------------------------+------------------------------------+--------|
 | [[../../api/open-api/login/wx.login.html][wx.login]]                   | [[../compatibility.html][2.3.1]]   |        |
 | [[../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]   | [[../compatibility.html][2.3.1]]   |        |

***** [[index_u50.html#Bugs-Tips][#]] Bugs & Tips
      :PROPERTIES:
      :CUSTOM_ID: index_u50.html#Bugs-Tips
      :CLASS:    calibre26
      :END:

 -  [[../../api/open-api/data-analysis/wx.reportAnalytics.html][wx.reportAnalytics]]
    可以被正常调用，但目前不会进行统计展示。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html]]

 \\
 \\
 | [[../index_u67.html#article_74][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u62.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_76/index_u43.html][下一项]] |
 [[../index_u67.html#article_75][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_74/index_u50.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u62.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u62.html#插件使用组件的限制][#]] 插件使用组件的限制
   :PROPERTIES:
   :CUSTOM_ID: index_u62.html#插件使用组件的限制
   :CLASS:    calibre9
   :END:

 在插件开发中，以下组件不能在插件页面中使用：

 -  开放能力（open-type）为以下之一的
    [[../../component/button.html][button]]：

    -  contact（打开客服会话）
    -  getPhoneNumber（获取用户手机号）
    -  getUserInfo（获取用户信息）

 -  [[../../component/open-data.html][open-data]]
 -  [[../../component/web-view.html][web-view]]

 以下组件的使用对基础库版本有要求：

 -  [[../../component/navigator.html][navigator]] 需要基础库版本
    [[../compatibility.html][2.1.0]]
 -  [[../../component/live-player.html][live-player]] 和
    [[../../component/live-pusher.html][live-pusher]] 需要基础库版本
    [[../compatibility.html][2.3.0]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/component-limit.html]]

 \\
 \\
 | [[../index_u67.html#article_75][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u43.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_77/index_u34.html][下一项]] |
 [[../index_u67.html#article_76][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_75/index_u62.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u43.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

** [[index_u43.html#插件功能页][#]] 插件功能页
   :PROPERTIES:
   :CUSTOM_ID: index_u43.html#插件功能页
   :CLASS:    calibre9
   :END:

 插件功能页从小程序基础库版本 [[../compatibility.html][2.1.0]] 开始支持。

 某些接口不能在插件中直接调用（如
 [[../../api/open-api/login/wx.login.html][wx.login]]），但插件开发者可以使用插件功能页的方式来实现功能。目前，插件功能页包括：

 -  获取用户信息，包括 =openid= 和昵称等（相当于
    [[../../api/open-api/login/wx.login.html][wx.login]] 和
    [[../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
    的功能），详见[[file:functional-pages/user-info.html][用户信息功能页]]；
 -  支付（相当于
    [[../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]），详见[[file:functional-pages/request-payment.html][支付功能页]]；
 -  获取收货地址（相当于
    [[../../api/open-api/address/wx.chooseAddress.html][wx.chooseAddress]]），详见[[file:functional-pages/choose-address.html][收货地址功能页]]。

 要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 组件跳转到插件功能页，从而实现对应的功能。详情请参考下文。

***** [[index_u43.html#插件所有者小程序][#]] 插件所有者小程序
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#插件所有者小程序
      :CLASS:    calibre26
      :END:

 开始开发之前，我们需要知道，插件功能页是指 *插件所有者小程序*
 中的一个特殊页面。

 *插件所有者小程序*，指的是与插件 AppID
 相同的小程序。例如，“小程序示例”小程序开发了一个“小程序示例插件”，那么无论这个插件被哪个小程序使用，这个插件的
 *插件所有者小程序* 都是“小程序示例”。下文中会继续使用 *插件所有者小程序*
 这个说法。

***** [[index_u43.html#插件所有者小程序开发方法][#]]
 插件所有者小程序开发方法
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#插件所有者小程序开发方法
      :CLASS: calibre26
      :END:

 通常，在开始使用插件功能页的时候，需要开启两个开发者工具窗口，其中一个打开插件项目，另一个打开插件所有者小程序的小程序项目。例如，一个打开“小程序示例插件”项目，另一个打开“小程序示例”项目。

 这两个窗口，前者用于编辑插件，后者用于编辑插件所有者小程序。下文中所有需要编辑插件所有者小程序的内容，都是在后者中进行。

*** [[index_u43.html#激活功能页特性][#]] 激活功能页特性
    :PROPERTIES:
    :CUSTOM_ID: index_u43.html#激活功能页特性
    :CLASS:    calibre11
    :END:

 要在插件中调用插件功能页，需要先激活插件所有者小程序的功能页特性。具体来说，在插件所有者小程序的
 =app.json= 文件中添加 =functionalPages= 定义段，并令其值为 =true=
 ，例如：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "functionalPages": {
         "independent": true
       }
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 目前，兼容旧式写法：

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     {
       "functionalPages": true
     }
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 旧式写法将在未来将被移除支持，未来将不能编译上传。

 这两种写法的区别在于，新式的写法 ="independent": true=
 会使得插件功能页的代码独立于其他代码，这意味着插件功能页可以被独立下载、加载，具有更好的性能表现。
 但也同时使得插件功能页目录 =functional-pages/=
 （支付功能页会使用其中的文件）不能 require
 这个目录以外的文件（反之亦然：这个目录以外的文件也不能调用这个目录内的）。

 注意，新增或改变这个字段时，需要这个小程序发布新版本，才能在正式环境中使用插件功能页。

*** [[index_u43.html#跳转到功能页][#]] 跳转到功能页
    :PROPERTIES:
    :CUSTOM_ID: index_u43.html#跳转到功能页
    :CLASS:    calibre11
    :END:

 功能页不能使用 [[../../api/route/wx.navigateTo.html][wx.navigateTo]]
 来进行跳转，而是需要一个名为
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 的组件。以获取用户信息为例，可以在插件中放置如下的
 [[../../component/functional-page-navigator.html][functional-page-navigator]]：

 *代码示例：*

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

 #+BEGIN_EXAMPLE
     <functional-page-navigator name="loginAndGetUserInfo" args="" version="develop" bind:success="loginSuccess">
       <button>登录到插件</button>
     </functional-page-navigator>
 #+END_EXAMPLE

 #+BEGIN_HTML
   </div>
 #+END_HTML

 用户在点击这个 =navigator=
 时，会自动跳转到插件所有者小程序的对应功能页。功能页会提示用户进行登录或其他相应的操作。操作结果会以组件事件的方式返回。

 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 的参数和详细使用方法可以参考[[../../component/functional-page-navigator.html][组件说明]]
 。

 从小程序基础库版本 [[../compatibility.html][2.4.0]]
 开始，支持插件所有者小程序跳转到自己的功能页。在基础库版本低于
 [[../compatibility.html][2.4.0]] 时，点击跳转到自己的功能页的
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 将没有任何反应。

*** [[index_u43.html#真机开发测试的常规步骤][#]] 真机开发测试的常规步骤
    :PROPERTIES:
    :CUSTOM_ID: index_u43.html#真机开发测试的常规步骤
    :CLASS:    calibre11
    :END:

 目前，功能页的跳转目前不支持在开发者工具中调试，请在真机上测试。初次进行真机开发测试时，通常步骤如下：

 1. 在开发者工具上打开插件所有者小程序项目，并点击“预览”；
 2. 用测试用的真机扫一下预览二维码，此时会进入插件所有者小程序，进入后就可以直接退出这个小程序；
 3. 在开发者工具上打开插件项目，将插件中
    [[../../component/functional-page-navigator.html][functional-page-navigator]]
    中的 =version= 属性设置为 =develop=；
 4. 点击预览可以生成插件预览二维码，用测试用的真机扫码即可预览功能页；如果更改了插件代码，重新生成并扫描插件的预览二维码即可；
 5. 如果过了一段时间之后，跳转功能页时出现“开发版已过期”这样的提示，从第 1 步开始重试一次。

 *注意*：=functional-page-navigator= 的 =version=develop=
 仅用于调试，因此在插件提审前，需要：

 1. 确保已发布设置了 ="functionalPages": true= 的插件所有者小程序；
 2. 确保所有的 =functional-page-navigator= 组件属性设置为
    =version="release"= 。

*** [[index_u43.html#功能页常见问题-FAQ][#]] 功能页常见问题 FAQ
    :PROPERTIES:
    :CUSTOM_ID: index_u43.html#功能页常见问题-FAQ
    :CLASS:    calibre11
    :END:

***** [[index_u43.html#如何正确编辑插件所有者小程序？][#]]
 如何正确编辑插件所有者小程序？
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#如何正确编辑插件所有者小程序？
      :CLASS: calibre26
      :END:

 -  应该在开发者工具的“小程序”类型项目中编辑，而不是在“插件”类型的项目中编辑。比如，“小程序示例插件”的所有者小程序是“小程序示例”，它们的
    AppID 都是 =wxidxxxxxxxxxxxxxx=
    ，如果是初次开发“小程序示例”小程序，可以在开发者工具中创建一个小程序项目，其
    AppID 为 =wxidxxxxxxxxxxxxxx=
    ；如果之前开发过“小程序示例”小程序，直接打开之前的小程序项目即可。

***** [[index_u43.html#点击-functional-page-navigator-之后没有任何反应。][#]]
 点击
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 之后没有任何反应。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-之后没有任何反应。
      :CLASS: calibre26
      :END:

 -  请检查引用插件的小程序和插件本身是不是同一个 AppID
    ，如果是，跳转到自己的功能页需要基础库
    [[../compatibility.html][2.4.0]] 支持，否则使用
    [[../../component/functional-page-navigator.html][functional-page-navigator]]
    不会有任何反应。

***** [[index_u43.html#点击-functional-page-navigator-之后，展示了一个页面提示“页面不存在”。][#]]
 点击
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 之后，展示了一个页面提示“页面不存在”。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-之后，展示了一个页面提示“页面不存在”。
      :CLASS: calibre26
      :END:

 -  这种情况是因为插件所有者小程序没有正确设置 ="functionalPages": true=
    。如果 =functional-page-navigator= 的 =version="develop"=
    ，这部手机需要扫码并进入插件所有者小程序一次；如果
    =version="release"= ，请确保包含 ="functionalPages": true=
    的插件所有者小程序已被发布。

***** [[index_u43.html#点击-functional-page-navigator-version-develop-之后，弹窗提示“小程序开发版已过期”。][#]]
 点击 =<functional-page-navigator version="develop">=
 之后，弹窗提示“小程序开发版已过期”。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-version-develop-之后，弹窗提示“小程序开发版已过期”。
      :CLASS: calibre26
      :END:

 -  遇到这种情况，重新扫码并进入插件所有者小程序一次即可。

***** [[index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，展示了一个页面提示“该功能无法使用”。][#]]
 点击 =<functional-page-navigator name="requestPayment">=
 之后，展示了一个页面提示“该功能无法使用”。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，展示了一个页面提示“该功能无法使用”。
      :CLASS: calibre26
      :END:

 -  在使用插件功能页时，小程序不能是个人小程序，同时，插件也需要额外的步骤申请开通插件支付权限（位于
    [[https://mp.weixin.qq.com][管理后台<<>>]] -> 小程序插件 -> 基本设置
    -> 支付能力 ）。

***** [[index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，点击页面中的“支付”按钮，立刻退出了支付功能页。][#]]
 点击 =<functional-page-navigator name="requestPayment">=
 之后，点击页面中的“支付”按钮，立刻退出了支付功能页。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，点击页面中的“支付”按钮，立刻退出了支付功能页。
      :CLASS: calibre26
      :END:

 -  这通常是因为没有找到功能页函数 =beforeRequestPayment=
    ，请检查插件所有者小程序的 =functional-pages/request-payment.js=
    文件和其中的 =beforeRequestPayment= 函数是否存在。

***** [[index_u43.html#点击-functional-page-navigator-之后，展示了一个仅有返回按钮的页面。][#]]
 点击
 [[../../component/functional-page-navigator.html][functional-page-navigator]]
 之后，展示了一个仅有返回按钮的页面。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#点击-functional-page-navigator-之后，展示了一个仅有返回按钮的页面。
      :CLASS: calibre26
      :END:

 -  请检查
    [[../../component/functional-page-navigator.html][functional-page-navigator]]
    的 =name= 属性是否被正确设置。

***** [[index_u43.html#开发版可以正常跳转，但审核反馈不能跳转。][#]]
 开发版可以正常跳转，但审核反馈不能跳转。
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#开发版可以正常跳转，但审核反馈不能跳转。
      :CLASS: calibre26
      :END:

 -  请发布设置了 ="functionalPages": true= 的插件所有者小程序，且所有的
    =functional-page-navigator= 组件属性设置为 =version="release"= 。

***** [[index_u43.html#Bugs-Tips][#]] Bugs & Tips
      :PROPERTIES:
      :CUSTOM_ID: index_u43.html#Bugs-Tips
      :CLASS:    calibre26
      :END:

 -  功能页是插件所有者小程序中的一个特殊页面，开发者不能自定义这个页面的外观。
 -  插件所有者小程序本身也可以引用这个插件，此时，=functional-page-navigator=
    组件的 =version=
    属性将不会生效，而是取决于当前运行的插件所有者小程序的版本。
 -  [[../../component/functional-page-navigator.html][functional-page-navigator]]
    可以在开发者工具中使用，但功能页的跳转目前不支持在开发者工具中调试，请在真机上测试。
 -  Bug：在微信版本 6.6.7 中，功能页被拉起时会触发 App
    的部分生命周期并使得功能页启动时间变得比较长。在后续的微信版本中这一行为会发生变更，使
    App 生命周期不再被触发。

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages.html]]

 \\
 \\
 | [[../index_u67.html#article_76][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u34.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_78/index_u24.html][下一项]] |
 [[../index_u67.html#article_77][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_76/index_u43.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u34.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u34.html#用户信息功能页][#]] 用户信息功能页
    :PROPERTIES:
    :CUSTOM_ID: index_u34.html#用户信息功能页
    :CLASS:    calibre9
    :END:

  用户信息功能页用于帮助插件获取用户信息，包括 =openid= 和昵称等，相当于
  [[../../../api/open-api/login/wx.login.html][wx.login]] 和
  [[../../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
  的功能。

  此外，自基础库版本 [[../../compatibility.html][2.3.1]]
  起，用户在这个功能页中授权之后，插件就可以直接调用
  [[../../../api/open-api/login/wx.login.html][wx.login]] 和
  [[../../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
  。无需再次进入功能页获取用户信息。自基础库版本
  [[../../compatibility.html][2.6.3]] 起，可以使用
  [[../../../api/open-api/setting/wx.getSetting.html][wx.getSetting]]
  来查询用户是否授权过。

**** [[index_u34.html#调用参数][#]] 调用参数
     :PROPERTIES:
     :CUSTOM_ID: index_u34.html#调用参数
     :CLASS:    calibre11
     :END:

  用户信息功能页使用
  [[../../../component/functional-page-navigator.html][functional-page-navigator]]
  进行跳转时，对应的参数 name 应为固定值 =loginAndGetUserInfo=，其余参数与
  [[https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject][wx.getUserInfo<<>>]]
  相同，具体来说：

  *args 参数说明：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数名            | 类型      | 必填   | 说明                                                                            |
  |-------------------+-----------+--------+---------------------------------------------------------------------------------|
  | withCredentials   | Boolean   | 否     | 是否带上登录态信息                                                              |
  | lang              | String    | 否     | 指定返回用户信息的语言，zh\_CN 简体中文，zh\_TW 繁体中文，en 英文。默认为 en。   |
  | timeout           | Number    | 否     | 超时时间，单位 ms                                                               |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *注：当 withCredentials 为 true 时，返回的数据会包含 encryptedData, iv
  等敏感信息。*

  *bindsuccess 返回参数说明：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数            | 类型     | 说明                                                                                                                                                                                |
  |-----------------+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | code            | String   | 同 [[../../../api/open-api/login/wx.login.html][wx.login]] 获得的用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 api，使用 code 换取 openid 和 session\_key 等信息   |
  | errMsg          | String   | 调用结果                                                                                                                                                                            |
  | userInfo        | OBJECT   | 用户信息对象，不包含 openid 等敏感信息                                                                                                                                              |
  | rawData         | String   | 不包括敏感信息的原始数据字符串，用于计算签名。                                                                                                                                      |
  | signature       | String   | 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，参考文档 [[../../open-ability/signature.html][signature]]。                                                         |
  | encryptedData   | String   | 包括敏感数据在内的完整用户信息的加密数据，详细见[[../../open-ability/signature.html][加密数据解密算法]]                                                                             |
  | iv              | String   | 加密算法的初始向量，详细见[[../../open-ability/signature.html][加密数据解密算法]]                                                                                                   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *userInfo 参数说明：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数        | 类型     | 说明                                                                                                                                                            |
  |-------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | nickName    | String   | 用户昵称                                                                                                                                                        |
  | avatarUrl   | String   | 用户头像，最后一个数值代表正方形头像大小（有 0、46、64、96、132 数值可选，0代表 132*132 正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像 URL 将失效。   |
  | gender      | String   | 用户的性别，值为 1 时是男性，值为 2 时是女性，值为 0 时是未知                                                                                                         |
  | city        | String   | 用户所在城市                                                                                                                                                    |
  | province    | String   | 用户所在省份                                                                                                                                                    |
  | country     | String   | 用户所在国家                                                                                                                                                    |
  | language    | String   | 用户的语言，简体中文为 zh\_CN                                                                                                                                    |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--plugin/components/hello-component.wxml-->
        <functional-page-navigator
          name="loginAndGetUserInfo"
          args="{{ args }}"
          version="develop"
          bind:success="loginSuccess"
          bind:fail="loginFail"
        >
          <button class="login">登录到插件</button>
        </functional-page-navigator>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // plugin/components/hello-component.js
      Component({
        properties: {},
        data: {
          args: {
            withCredentials: true,
            lang: 'zh_CN'
          }
        },
        methods: {
          loginSuccess: function (res) {
            console.log(res.detail);
          },
          loginFail: function (res) {
            console.log(res);
          }
        }
      });
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  用户点击该 =navigator= 后，将跳转到如下的用户信息功能页：

  [[file:feed_0/article_77/images/img1_u2.png]]

  [[https://developers.weixin.qq.com/s/Uof4Iomt731Z][在微信开发者工具中查看示例<<>>]]：

  1. 由于插件需要 appid 才能工作，请填入一个 appid；
  2. 由于当前代码片段的限制，打开该示例后请 *手动将 appid 填写到
     =miniprogram/app.json= 中（如下图）使示例正常运行。*

  [[file:feed_0/article_72/images/img2_u5.png]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/user-info.html]]

  \\
  \\
  | [[../index_u67.html#article_77][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u24.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_79/index_u85.html][下一项]] |
  [[../index_u67.html#article_78][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_77/index_u34.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u24.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u24.html#支付功能页][#]] 支付功能页
    :PROPERTIES:
    :CUSTOM_ID: index_u24.html#支付功能页
    :CLASS:    calibre9
    :END:

  支付功能页用于帮助插件完成支付，相当于
  [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]
  的功能。

  需要注意的是：插件使用支付功能，需要进行额外的权限申请，申请位置位于[[https://mp.weixin.qq.com][管理后台<<>>]]的“小程序插件
  -> 基本设置 ->
  支付能力”设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。

**** [[index_u24.html#调用参数][#]] 调用参数
     :PROPERTIES:
     :CUSTOM_ID: index_u24.html#调用参数
     :CLASS:    calibre11
     :END:

  支付功能页使用
  [[../../../component/functional-page-navigator.html][functional-page-navigator]]
  进行跳转时，对应的参数 name 应为固定值 =requestPayment=，其他参数如下：

  *args 参数说明：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数名         | 类型     | 必填   | 说明                                           |
  |----------------+----------+--------+------------------------------------------------|
  | fee            | Number   | 是     | 需要显示在页面中的金额，单位为分               |
  | paymentArgs    | Object   | 否     | 任意数据，传递给功能页中的响应函数             |
  | currencyType   | String   | 否     | 需要显示在页面中的货币符号的代码，默认为 CNY   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *currencyType 的合法值：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 值    | 说明            | 最低版本   |
  |-------+-----------------+------------|
  | CNY   | 货币符号 ¥      |            |
  | USD   | 货币符号 US$    |            |
  | JPY   | 货币符号 J¥     |            |
  | EUR   | 货币符号 €      |            |
  | HKD   | 货币符号 HK$    |            |
  | GBP   | 货币符号 ￡      |            |
  | AUD   | 货币符号 A$     |            |
  | MOP   | 货币符号 MOP$   |            |
  | KRW   | 货币符号 ₩      |            |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!-- plugin/components/pay.wxml -->
      <!-- 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布 -->
      <functional-page-navigator
        version="develop"
        name="requestPayment"
        args="{{ args }}"
        bind:success="paymentSuccess"
        bind:fail="paymentFailed"
      >
        <button class="payment-button">支付 0.01 元</button>
      </functional-page-navigator>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // plugin/components/pay.js
      Component({
        data: {
          args: {
            fee: 1,             // 支付金额，单位为分
            paymentArgs: 'A', // 将传递到功能页函数的自定义参数
            currencyType: 'USD' // 货币符号，页面显示货币简写 US$ 
          }
        },
        methods: {
          // 支付成功的回调接口
          paymentSuccess: function (e) {
            console.log(e);
            e.detail.extraData.timeStamp // 用 extraData 传递数据，详见下面功能页函数代码
          },
          // 支付失败的回调接口
          paymentFailed: function (e) {
            console.log(e);
          }
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  用户点击该 =navigator= 后，将跳转到如下的支付功能页：

  [[file:feed_0/article_78/images/img1_u21.png]]

**** [[index_u24.html#配置功能页函数][#]] 配置功能页函数
     :PROPERTIES:
     :CUSTOM_ID: index_u24.html#配置功能页函数
     :CLASS:    calibre11
     :END:

  支付功能页需要插件开发者在插件所有者小程序中提供一个函数来响应插件中的支付调用。即，在插件中跳转到支付功能页时，这个函数就会在合适的时机被调用，来帮助完成支付。如果不提供功能页函数，功能页调用将通过
  =fail= 事件返回失败。

  支付功能页函数应以导出函数的形式提供在插件所有者小程序的根目录下的
  =functional-pages/request-payment.js= 文件中，名为
  =beforeRequestPayment=。该函数应接收两个参数：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数名        | 类型       | 说明                                                                                                                                                   |
  |---------------+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
  | paymentArgs   | Object     | 即通过 [[../../../component/functional-page-navigator.html][functional-page-navigator]] 的 =arg= 参数中的 =paymentArgs= 字段传递到功能页的自定义数据   |
  | callback      | Function   | 回调函数，调用该函数后，小程序将发起支付（类似于 [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]）                         |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *callback 函数的参数：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数名               | 类型     | 说明                                                                                                       |
  |----------------------+----------+------------------------------------------------------------------------------------------------------------|
  | error                | Object   | 失败信息，若无失败，应返回 =null=                                                                          |
  | requestPaymentArgs   | Object   | 支付参数，用于调用 [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]，参数如下   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *reqeustPaymentArgs 的参数：*

  用于发起支付，和
  [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]
  的参数相同，但没有回调函数（=success=, =fail=, =complete=）：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数        | 类型     | 必填   | 说明                                                                                                                                                        |
  |-------------+----------+--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | timeStamp   | String   | 是     | 时间戳从 1970 年 1 月 1 日 00:00:00 至今的秒数,即当前的时间                                                                                                         |
  | nonceStr    | String   | 是     | 随机字符串，长度为 32 个字符以下。                                                                                                                            |
  | package     | String   | 是     | 统一下单接口返回的 prepay\_id 参数值，提交格式如：prepay\_id=***                                                                                            |
  | signType    | String   | 是     | 签名算法，暂支持 MD5                                                                                                                                        |
  | paySign     | String   | 是     | 签名,具体签名方案参见[[https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3][小程序支付接口文档<<>>]];                                |
  | extraData   | any      | 否     | 由开发者决定的自定义数据段，该字段将被无修改地透传到支付成功的回调参数中，具体见代码示例中的使用方法。基础库 [[../../compatibility.html][2.9.1]] 开始支持   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  了解更多信息，请查看[[https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&index=1][微信支付接口文档<<>>]]

  *功能页函数代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // functional-pages/request-payment.js
      exports.beforeRequestPayment = function (paymentArgs, callback) {
        // 注意：
        // 功能页函数（这个函数）不应 require 其他非 functional-pages 目录中的文件，
        // 其他非 functional-pages 目录中的文件也不应 require 这个目录中的文件，
        // 这样的 require 调用在未来将不被支持。
        //
        // 同在 functional-pages 中的文件可以 require
        var getOpenIdURL = require('./URL').getOpenIdURL;
        var paymentURL = require('./URL').paymentURL;

        // 自定义的参数，此处应为从插件传递过来的 'A'
        var customArgument = paymentArgs.customArgument;

        // 第一步：调用 wx.login 方法获取 code，然后在服务端调用微信接口使用 code 换取下单用户的 openId
        // 具体文档参考 https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=20161230#wxloginobject
        wx.login({
          success: function (data) {
            wx.request({
              url: getOpenIdURL,
              data: { code: data.code },
              success: function (res) {
                // 拉取用户 openid 成功
                // 第二步：在服务端调用支付统一下单，返回支付参数。这里的开发和普通的 wx.requestPayment 相同
                // 文档可以参考 https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_4&index=3
                wx.request({
                  url: paymentURL,
                  data: { openid: res.data.openid },
                  method: 'POST',
                  success: function (res) {
                    console.log('unified order success, response is:', res);
                    var payargs = res.data.payargs;
                    // 第三步：调用回调函数 callback 进行支付
                    // 在 callback 中需要返回两个参数： err 和 requestPaymentArgs：
                    // err 应为 null （或者一些失败信息）；
                    // requestPaymentArgs 将被用于调用 wx.requestPayment，除了 success/fail/complete 不被支持外，
                    // 应与 wx.requestPayment 参数相同。
                    var error = null;
                    var requestPaymentArgs = {
                      timeStamp: payargs.timeStamp,
                      nonceStr: payargs.nonceStr,
                      package: payargs.package,
                      signType: payargs.signType,
                      paySign: payargs.paySign,
                      extraData: { // 用 extraData 传递自定义数据
                        timeStamp: payargs.timeStamp
                      },
                    };
                    callback(error, requestPaymentArgs);
                  }
                });
              },
              fail: function (res) {
                console.log('拉取用户openid失败，将无法正常使用开放接口等服务', res);
                // callback 第一个参数为错误信息，返回错误信息
                callback(res);
              }
            });
          },
          fail: function (err) {
            console.log('wx.login 接口调用失败，将无法正常使用开放接口等服务', err)
            // callback 第一个参数为错误信息，返回错误信息
            callback(err);
          }
        });
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *注意：功能页函数不应 =require= 其他非 =functional-pages=
  目录中的文件，其他非 =functional-pages= 目录中的文件也不应 =require=
  这个目录中的文件。这样的 =require= 调用在未来将不被支持。*

  *这个目录和文件应当被放置在插件所有者小程序代码中（而非插件代码中），它是插件所有者小程序的一部分（而非插件的一部分）。*
  如果需要新增或更改这段代码，需要发布插件所有者小程序，才能在正式版中生效；需要重新预览插件所有者小程序，才能在开发版中生效。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/request-payment.html]]

  \\
  \\
  | [[../index_u67.html#article_78][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u85.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_80/index_u47.html][下一项]] |
  [[../index_u67.html#article_79][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_78/index_u24.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u85.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u85.html#收货地址功能页][#]] 收货地址功能页
    :PROPERTIES:
    :CUSTOM_ID: index_u85.html#收货地址功能页
    :CLASS:    calibre9
    :END:

  收货地址功能页用于展示用户的收货地址列表，用户可以选择其中的收货地址。自基础库版本
  [[../../compatibility.html][2.4.0]] 开始支持。

**** [[index_u85.html#调用参数][#]] 调用参数
     :PROPERTIES:
     :CUSTOM_ID: index_u85.html#调用参数
     :CLASS:    calibre11
     :END:

  用户信息功能页使用
  [[../../../component/functional-page-navigator.html][functional-page-navigator]]
  进行跳转时，对应的参数 name 应为固定值 =chooseAddress= ，返回参数与
  [[../../../api/open-api/address/wx.chooseAddress.html][wx.chooseAddress]]
  相同。

  *bindsuccess 返回参数说明：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 属性           | 类型     | 说明                     | 最低版本   |
  |----------------+----------+--------------------------+------------|
  | userName       | string   | 收货人姓名               |            |
  | postalCode     | string   | 邮编                     |            |
  | provinceName   | string   | 国标收货地址第一级地址   |            |
  | cityName       | string   | 国标收货地址第一级地址   |            |
  | countyName     | string   | 国标收货地址第一级地址   |            |
  | detailInfo     | string   | 详细收货地址信息         |            |
  | nationalCode   | string   | 收货地址国家码           |            |
  | telNumber      | string   | 收货人手机号码           |            |
  | errMsg         | string   | 错误信息                 |            |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *代码示例：*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <!--plugin/components/hello-component.wxml-->
        <functional-page-navigator
          name="chooseAddress"
          version="develop"
          bind:success="onSuccess"
          bind:fail="onFail"
        >
          <button>选择收货地址</button>
        </functional-page-navigator>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // plugin/components/hello-component.js
      Component({
        methods: {
          onSuccess: function (res) {
            console.log(res.detail);
          },
          onFail: function (res) {
            console.log(res);
          }
        }
      });
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/choose-address.html]]

  \\
  \\
  | [[../index_u67.html#article_79][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u47.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_81/index_u98.html][下一项]] |
  [[../index_u67.html#article_80][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_79/index_u85.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u47.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u47.html#网络][#]] 网络
     :PROPERTIES:
     :CUSTOM_ID: index_u47.html#网络
     :CLASS:    calibre11
     :END:

  在小程序/小游戏中使用网络相关的 API
  时，需要注意下列问题，请开发者提前了解。

***** [[index_u47.html#_1-服务器域名配置][#]] 1. 服务器域名配置
      :PROPERTIES:
      :CUSTOM_ID: index_u47.html#_1-服务器域名配置
      :CLASS:    calibre25
      :END:

  每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
  HTTPS
  请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
  和 WebSocket
  通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

  从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
  *不允许与本机 IP 通信*。

  从 2.7.0 开始，提供了 UDP
  通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

****** [[index_u47.html#配置流程][#]] 配置流程
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#配置流程
       :CLASS:    calibre26
       :END:

  服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
  中进行配置，配置时需要注意：

  -  域名只支持 =https=
     ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
     和 =wss=
     ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
     协议；
  -  域名不能使用 IP
     地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
     IP 除外）或 localhost；
  -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
     https://myserver.com:8080 发起请求。如果向
     https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
  -  如果不配置端口。如 https://myserver.com，那么请求的 URL
     中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
     https://myserver.com:443 请求则会失败。
  -  域名必须经过 ICP 备案；
  -  *出于安全考虑，=api.weixin.qq.com=
     不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
     AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
     接口获取 =access_token=，并调用相关 API；
  -  对于每个接口，分别可以配置最多 20 个域名。
  -  不支持配置父域名，使用子域名。

***** [[index_u47.html#_2-网络请求][#]] 2. 网络请求
      :PROPERTIES:
      :CUSTOM_ID: index_u47.html#_2-网络请求
      :CLASS:    calibre25
      :END:

****** [[index_u47.html#超时时间][#]] 超时时间
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#超时时间
       :CLASS:    calibre26
       :END:

  -  默认超时时间和最大超时时间都是 *60s*；
  -  超时时间可以在 =app.json= 或 =game.json= 中通过
     [[../config.html][=networktimeout=]] 配置。

****** [[index_u47.html#使用限制][#]] 使用限制
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#使用限制
       :CLASS:    calibre26
       :END:

  -  网络请求的 =referer= header 不可设置。其格式固定为
     =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
     ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
     =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
     表示为开发者工具，其余为正式版本；
  -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
     的最大并发限制是 *10* 个；
  -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
     的最大并发限制是 *5* 个。
  -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
     =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

****** [[index_u47.html#返回值编码][#]] 返回值编码
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#返回值编码
       :CLASS:    calibre26
       :END:

  -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
     编码，小程序会尝试进行转换，但是会有转换失败的可能。
  -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

****** [[index_u47.html#回调函数][#]] 回调函数
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#回调函数
       :CLASS:    calibre26
       :END:

  -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
     =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

***** [[index_u47.html#_3-常见问题][#]] 3. 常见问题
      :PROPERTIES:
      :CUSTOM_ID: index_u47.html#_3-常见问题
      :CLASS:    calibre25
      :END:

****** [[index_u47.html#HTTPS-证书][#]] HTTPS 证书
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#HTTPS-证书
       :CLASS:    calibre26
       :END:

  *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
  HTTPS
  证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

  对证书要求如下：

  -  HTTPS 证书必须有效；

     -  证书必须被系统信任，即根证书被已系统内置
     -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
     -  证书必须在有效期内
     -  证书的信任链必需完整（需要服务器配置）

  -  =iOS= 不支持自签名证书;
  -  =iOS= 下证书必须满足苹果
     [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
     Transport Security (ATS)<<>>]] 的要求;
  -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
     1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
  -  部分 CA
     可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

     -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
        56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

  #+BEGIN_QUOTE
    证书有效性可以使用 =openssl s_client -connect example.com:443=
    命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
  #+END_QUOTE

  *除了网络请求 API 外，小程序中其他 =HTTPS=
  请求如果出现异常，也请按上述流程进行检查。如 https
  的图片无法加载、音视频无法播放等。*

****** [[index_u47.html#跳过域名校验][#]] 跳过域名校验
       :PROPERTIES:
       :CUSTOM_ID: index_u47.html#跳过域名校验
       :CLASS:    calibre26
       :END:

  在微信开发者工具中，可以临时开启
  =开发环境不校验请求域名、TLS版本及HTTPS证书=
  选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

  *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

  #+BEGIN_QUOTE
    如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
    的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
  #+END_QUOTE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

  \\
  \\
  | [[../index_u67.html#article_80][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u98.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_82/index_u29.html][下一项]] |
  [[../index_u67.html#article_81][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_80/index_u47.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u98.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u98.html#网络][#]] 网络
     :PROPERTIES:
     :CUSTOM_ID: index_u98.html#网络
     :CLASS:    calibre11
     :END:

  在小程序/小游戏中使用网络相关的 API
  时，需要注意下列问题，请开发者提前了解。

***** [[index_u98.html#_1-服务器域名配置][#]] 1. 服务器域名配置
      :PROPERTIES:
      :CUSTOM_ID: index_u98.html#_1-服务器域名配置
      :CLASS:    calibre25
      :END:

  每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
  HTTPS
  请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
  和 WebSocket
  通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

  从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
  *不允许与本机 IP 通信*。

  从 2.7.0 开始，提供了 UDP
  通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

****** [[index_u98.html#配置流程][#]] 配置流程
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#配置流程
       :CLASS:    calibre26
       :END:

  服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
  中进行配置，配置时需要注意：

  -  域名只支持 =https=
     ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
     和 =wss=
     ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
     协议；
  -  域名不能使用 IP
     地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
     IP 除外）或 localhost；
  -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
     https://myserver.com:8080 发起请求。如果向
     https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
  -  如果不配置端口。如 https://myserver.com，那么请求的 URL
     中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
     https://myserver.com:443 请求则会失败。
  -  域名必须经过 ICP 备案；
  -  *出于安全考虑，=api.weixin.qq.com=
     不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
     AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
     接口获取 =access_token=，并调用相关 API；
  -  对于每个接口，分别可以配置最多 20 个域名。
  -  不支持配置父域名，使用子域名。

***** [[index_u98.html#_2-网络请求][#]] 2. 网络请求
      :PROPERTIES:
      :CUSTOM_ID: index_u98.html#_2-网络请求
      :CLASS:    calibre25
      :END:

****** [[index_u98.html#超时时间][#]] 超时时间
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#超时时间
       :CLASS:    calibre26
       :END:

  -  默认超时时间和最大超时时间都是 *60s*；
  -  超时时间可以在 =app.json= 或 =game.json= 中通过
     [[../config.html][=networktimeout=]] 配置。

****** [[index_u98.html#使用限制][#]] 使用限制
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#使用限制
       :CLASS:    calibre26
       :END:

  -  网络请求的 =referer= header 不可设置。其格式固定为
     =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
     ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
     =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
     表示为开发者工具，其余为正式版本；
  -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
     的最大并发限制是 *10* 个；
  -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
     的最大并发限制是 *5* 个。
  -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
     =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

****** [[index_u98.html#返回值编码][#]] 返回值编码
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#返回值编码
       :CLASS:    calibre26
       :END:

  -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
     编码，小程序会尝试进行转换，但是会有转换失败的可能。
  -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

****** [[index_u98.html#回调函数][#]] 回调函数
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#回调函数
       :CLASS:    calibre26
       :END:

  -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
     =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

***** [[index_u98.html#_3-常见问题][#]] 3. 常见问题
      :PROPERTIES:
      :CUSTOM_ID: index_u98.html#_3-常见问题
      :CLASS:    calibre25
      :END:

****** [[index_u98.html#HTTPS-证书][#]] HTTPS 证书
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#HTTPS-证书
       :CLASS:    calibre26
       :END:

  *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
  HTTPS
  证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

  对证书要求如下：

  -  HTTPS 证书必须有效；

     -  证书必须被系统信任，即根证书被已系统内置
     -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
     -  证书必须在有效期内
     -  证书的信任链必需完整（需要服务器配置）

  -  =iOS= 不支持自签名证书;
  -  =iOS= 下证书必须满足苹果
     [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
     Transport Security (ATS)<<>>]] 的要求;
  -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
     1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
  -  部分 CA
     可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

     -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
        56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

  #+BEGIN_QUOTE
    证书有效性可以使用 =openssl s_client -connect example.com:443=
    命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
  #+END_QUOTE

  *除了网络请求 API 外，小程序中其他 =HTTPS=
  请求如果出现异常，也请按上述流程进行检查。如 https
  的图片无法加载、音视频无法播放等。*

****** [[index_u98.html#跳过域名校验][#]] 跳过域名校验
       :PROPERTIES:
       :CUSTOM_ID: index_u98.html#跳过域名校验
       :CLASS:    calibre26
       :END:

  在微信开发者工具中，可以临时开启
  =开发环境不校验请求域名、TLS版本及HTTPS证书=
  选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

  *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

  #+BEGIN_QUOTE
    如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
    的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
  #+END_QUOTE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

  \\
  \\
  | [[../index_u67.html#article_81][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u29.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_83/index_u92.html][下一项]] |
  [[../index_u67.html#article_82][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_81/index_u98.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u29.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u29.html#网络][#]] 网络
     :PROPERTIES:
     :CUSTOM_ID: index_u29.html#网络
     :CLASS:    calibre11
     :END:

  在小程序/小游戏中使用网络相关的 API
  时，需要注意下列问题，请开发者提前了解。

***** [[index_u29.html#_1-服务器域名配置][#]] 1. 服务器域名配置
      :PROPERTIES:
      :CUSTOM_ID: index_u29.html#_1-服务器域名配置
      :CLASS:    calibre25
      :END:

  每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
  HTTPS
  请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
  和 WebSocket
  通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

  从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
  *不允许与本机 IP 通信*。

  从 2.7.0 开始，提供了 UDP
  通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

****** [[index_u29.html#配置流程][#]] 配置流程
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#配置流程
       :CLASS:    calibre26
       :END:

  服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
  中进行配置，配置时需要注意：

  -  域名只支持 =https=
     ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
     和 =wss=
     ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
     协议；
  -  域名不能使用 IP
     地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
     IP 除外）或 localhost；
  -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
     https://myserver.com:8080 发起请求。如果向
     https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
  -  如果不配置端口。如 https://myserver.com，那么请求的 URL
     中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
     https://myserver.com:443 请求则会失败。
  -  域名必须经过 ICP 备案；
  -  *出于安全考虑，=api.weixin.qq.com=
     不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
     AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
     接口获取 =access_token=，并调用相关 API；
  -  对于每个接口，分别可以配置最多 20 个域名。
  -  不支持配置父域名，使用子域名。

***** [[index_u29.html#_2-网络请求][#]] 2. 网络请求
      :PROPERTIES:
      :CUSTOM_ID: index_u29.html#_2-网络请求
      :CLASS:    calibre25
      :END:

****** [[index_u29.html#超时时间][#]] 超时时间
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#超时时间
       :CLASS:    calibre26
       :END:

  -  默认超时时间和最大超时时间都是 *60s*；
  -  超时时间可以在 =app.json= 或 =game.json= 中通过
     [[../config.html][=networktimeout=]] 配置。

****** [[index_u29.html#使用限制][#]] 使用限制
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#使用限制
       :CLASS:    calibre26
       :END:

  -  网络请求的 =referer= header 不可设置。其格式固定为
     =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
     ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
     =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
     表示为开发者工具，其余为正式版本；
  -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
     的最大并发限制是 *10* 个；
  -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
     的最大并发限制是 *5* 个。
  -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
     =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

****** [[index_u29.html#返回值编码][#]] 返回值编码
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#返回值编码
       :CLASS:    calibre26
       :END:

  -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
     编码，小程序会尝试进行转换，但是会有转换失败的可能。
  -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

****** [[index_u29.html#回调函数][#]] 回调函数
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#回调函数
       :CLASS:    calibre26
       :END:

  -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
     =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

***** [[index_u29.html#_3-常见问题][#]] 3. 常见问题
      :PROPERTIES:
      :CUSTOM_ID: index_u29.html#_3-常见问题
      :CLASS:    calibre25
      :END:

****** [[index_u29.html#HTTPS-证书][#]] HTTPS 证书
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#HTTPS-证书
       :CLASS:    calibre26
       :END:

  *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
  HTTPS
  证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

  对证书要求如下：

  -  HTTPS 证书必须有效；

     -  证书必须被系统信任，即根证书被已系统内置
     -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
     -  证书必须在有效期内
     -  证书的信任链必需完整（需要服务器配置）

  -  =iOS= 不支持自签名证书;
  -  =iOS= 下证书必须满足苹果
     [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
     Transport Security (ATS)<<>>]] 的要求;
  -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
     1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
  -  部分 CA
     可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

     -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
        56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

  #+BEGIN_QUOTE
    证书有效性可以使用 =openssl s_client -connect example.com:443=
    命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
  #+END_QUOTE

  *除了网络请求 API 外，小程序中其他 =HTTPS=
  请求如果出现异常，也请按上述流程进行检查。如 https
  的图片无法加载、音视频无法播放等。*

****** [[index_u29.html#跳过域名校验][#]] 跳过域名校验
       :PROPERTIES:
       :CUSTOM_ID: index_u29.html#跳过域名校验
       :CLASS:    calibre26
       :END:

  在微信开发者工具中，可以临时开启
  =开发环境不校验请求域名、TLS版本及HTTPS证书=
  选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

  *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

  #+BEGIN_QUOTE
    如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
    的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
  #+END_QUOTE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

  \\
  \\
  | [[../index_u67.html#article_82][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u92.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_84/index_u76.html][下一项]] |
  [[../index_u67.html#article_83][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_82/index_u29.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u92.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u92.html#局域网通信][#]] 局域网通信
     :PROPERTIES:
     :CUSTOM_ID: index_u92.html#局域网通信
     :CLASS:    calibre11
     :END:

  基础库 2.4.0 提供了
  [[../../api/network/mdns/wx.startLocalServiceDiscovery.html][wx.startLocalServiceDiscovery]]
  等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。
  [[../../api/network/request/wx.request.html][wx.request]]/[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]/[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]/[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
  的 url 参数允许为 =${IP}:${PORT}/${PATH}= 的格式，当且仅当 IP 与手机 IP
  处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个
  wifi 下）时，请求/连接才会成功。

  在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用
  http/ws。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.request({
        url: 'http://10.9.176.40:828'
        // 省略其他参数
      })

      wx.connectSocket({
        url: 'ws://10.9.176.42:828'
        // 省略其他参数
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  基础库 2.7.0 开始，提供了
  [[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]]
  接口用于进行 UDP 通信。通信规则同上，仅允许同一局域网下的非本机 IP。

***** [[index_u92.html#mDNS][#]] mDNS
      :PROPERTIES:
      :CUSTOM_ID: index_u92.html#mDNS
      :CLASS:    calibre25
      :END:

  目前小程序只支持通过 mDNS 协议获取局域网内其他设备的 IP。iOS 上 mDNS API
  的实现基于
  [[https://developer.apple.com/bonjour/][Bonjour<<>>]]，Android
  上则是基于
  [[https://developer.android.com/training/connect-devices-wirelessly/nsd][Android
  系统接口<<>>]]。

  *serviceType*

  发起 mDNS 服务搜索
  [[../../api/network/mdns/wx.startLocalServiceDiscovery.html][wx.startLocalServiceDiscovery]]
  的接口有 serviceType 参数，指定要搜索的服务类型。

  serviceType 的格式和规范，iOS
  [[https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/NetServices/Articles/domainnames.html][Bonjour
  Overview<<>>]] 在 *Bonjour Names for Existing Service Types* 有提及。

  [[file:feed_0/article_83/images/img1_u26.png]]

  [[https://developer.android.com/training/connect-devices-wirelessly/nsd][Android
  文档<<>>]] 对此也有提及。

  [[file:feed_0/article_83/images/img2_u4.png]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html]]

  \\
  \\
  | [[../index_u67.html#article_83][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u76.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_85/index_u31.html][下一项]] |
  [[../index_u67.html#article_84][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_83/index_u92.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u76.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u76.html#存储][#]] 存储
     :PROPERTIES:
     :CUSTOM_ID: index_u76.html#存储
     :CLASS:    calibre11
     :END:

  每个微信小程序都可以有自己的本地缓存，可以通过
  [[../../api/storage/wx.setStorage.html][wx.setStorage]]/[[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]、[[../../api/storage/wx.getStorage.html][wx.getStorage]]/[[../../api/storage/wx.getStorageSync.html][wx.getStorageSync]]、[[../../api/storage/wx.clearStorage.html][wx.clearStorage]]/[[../../api/storage/wx.clearStorageSync.html][wx.clearStorageSync]]，[[../../api/storage/wx.removeStorage.html][wx.removeStorage]]/[[../../api/storage/wx.removeStorageSync.html][wx.removeStorageSync]]
  对本地缓存进行读写和清理。

***** [[index_u76.html#隔离策略][#]] 隔离策略
      :PROPERTIES:
      :CUSTOM_ID: index_u76.html#隔离策略
      :CLASS:    calibre25
      :END:

  同一个微信用户，同一个小程序 storage 上限为 10MB。storage
  以用户维度隔离，同一台设备上，A 用户无法读取到 B
  用户的数据；不同小程序之间也无法互相读写数据。

***** [[index_u76.html#清理策略][#]] 清理策略
      :PROPERTIES:
      :CUSTOM_ID: index_u76.html#清理策略
      :CLASS:    calibre25
      :END:

  本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html]]

  \\
  \\
  | [[../index_u67.html#article_84][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u31.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_86/index_u37.html][下一项]] |
  [[../index_u67.html#article_85][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_84/index_u76.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u31.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u31.html#文件系统][#]] 文件系统
     :PROPERTIES:
     :CUSTOM_ID: index_u31.html#文件系统
     :CLASS:    calibre11
     :END:

  文件系统是小程序提供的一套以小程序和用户维度隔离的存储以及一套相应的管理接口。通过
  [[../../api/file/wx.getFileSystemManager.html][wx.getFileSystemManager()]]
  可以获取到全局唯一的文件系统管理器，所有文件系统的管理操作通过
  [[../../api/file/FileSystemManager.html][FileSystemManager]] 来调用。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      var fs = wx.getFileSystemManager()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  文件主要分为两大类：

  -  代码包文件：代码包文件指的是在项目目录中添加的文件。
  -  本地文件：通过调用接口本地产生，或通过网络下载下来，存储到本地的文件。

  其中本地文件又分为三种：

  1. 本地临时文件：临时产生，随时会被回收的文件。不限制存储大小。
  2. 本地缓存文件：小程序通过接口把本地临时文件缓存后产生的文件，不能自定义目录和文件名。跟本地用户文件共计，小程序（含小游戏）最多可存储
     200MB。
  3. 本地用户文件：小程序通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名。跟本地缓存文件共计，小程序（含小游戏）最多可存储
     200MB。

***** [[index_u31.html#代码包文件][#]] 代码包文件
      :PROPERTIES:
      :CUSTOM_ID: index_u31.html#代码包文件
      :CLASS:    calibre25
      :END:

  由于代码包文件大小限制，代码包文件适用于放置首次加载时需要的文件，对于内容较大或需要动态替换的文件，不推荐用添加到代码包中，推荐在小游戏启动之后再用下载接口下载到本地。

****** [[index_u31.html#访问代码包文件][#]] 访问代码包文件
       :PROPERTIES:
       :CUSTOM_ID: index_u31.html#访问代码包文件
       :CLASS:    calibre26
       :END:

  代码包文件的访问方式是从项目根目录开始写文件路径，不支持相对路径的写法。如：=/a/b/c=、=a/b/c=
  都是合法的，=./a/b/c= =../a/b/c= 则不合法。
  [[file:feed_0/article_85/images/img1_u10.png]]

****** [[index_u31.html#修改代码包文件][#]] 修改代码包文件
       :PROPERTIES:
       :CUSTOM_ID: index_u31.html#修改代码包文件
       :CLASS:    calibre26
       :END:

  代码包内的文件无法在运行后动态修改或删除，修改代码包文件需要重新发布版本。

***** [[index_u31.html#本地文件][#]] 本地文件
      :PROPERTIES:
      :CUSTOM_ID: index_u31.html#本地文件
      :CLASS:    calibre25
      :END:

  本地文件指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户维度隔离。即同一台手机，每个微信用户不能访问到其他登录用户的文件，同一个用户不同
  appId 之间的文件也不能互相访问。
  [[file:feed_0/article_85/images/img2_u9.png]]

  本地文件的文件路径均为以下格式：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {{协议名}}://文件路径
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_QUOTE
    其中，协议名在 iOS/Android 客户端为 ="wxfile"=，在开发者工具上为
    ="http"=，开发者无需关注这个差异，也不应在代码中去硬编码完整文件路径。
  #+END_QUOTE

****** [[index_u31.html#本地临时文件][#]] 本地临时文件
       :PROPERTIES:
       :CUSTOM_ID: index_u31.html#本地临时文件
       :CLASS:    calibre26
       :END:

  本地临时文件只能通过调用特定接口产生，不能直接写入内容。本地临时文件产生后，仅在当前生命周期内有效，重启之后即不可用。因此，*不可把本地临时文件路径存储起来下次使用*。如果需要下次在使用，可通过
  [[../../api/file/FileSystemManager.saveFile.html][FileSystemManager.saveFile()]]
  或
  [[../../api/file/FileSystemManager.copyFile.html][FileSystemManager.copyFile()]]
  接口把本地临时文件转换成本地缓存文件或本地用户文件。

******* [[index_u31.html#示例][#]] 示例
        :PROPERTIES:
        :CUSTOM_ID: index_u31.html#示例
        :CLASS:    calibre31
        :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      wx.chooseImage({
        success: function (res) {
          var tempFilePaths = res.tempFilePaths // tempFilePaths 的每一项是一个本地临时文件路径
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u31.html#本地缓存文件][#]] 本地缓存文件
       :PROPERTIES:
       :CUSTOM_ID: index_u31.html#本地缓存文件
       :CLASS:    calibre26
       :END:

  本地缓存文件只能通过调用特定接口产生，不能直接写入内容。本地缓存文件产生后，重启之后仍可用。本地缓存文件只能通过
  [[../../api/file/FileSystemManager.saveFile.html][FileSystemManager.saveFile()]]
  接口将本地临时文件保存获得。

******* [[index_u31.html#示例-2][#]] 示例
        :PROPERTIES:
        :CUSTOM_ID: index_u31.html#示例-2
        :CLASS:    calibre31
        :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      fs.saveFile({
        tempFilePath: '', // 传入一个本地临时文件路径
        success(res) {
          console.log(res.savedFilePath) // res.savedFilePath 为一个本地缓存文件路径
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *注意：本地缓存文件是最初的设计，=1.7.0=
  版本开始，提供了功能更完整的本地用户文件，可以完全覆盖本地缓存文件的功能，如果不需要兼容低于
  =1.7.0= 版本，可以不使用本地缓存文件。*

****** [[index_u31.html#本地用户文件][#]] 本地用户文件
       :PROPERTIES:
       :CUSTOM_ID: index_u31.html#本地用户文件
       :CLASS:    calibre26
       :END:

  本地用户文件是从 =1.7.0=
  版本开始新增的概念。我们提供了一个用户文件目录给开发者，开发者对这个目录有完全自由的读写权限。通过
  =wx.env.USER_DATA_PATH= 可以获取到这个目录的路径。

******* [[index_u31.html#示例-3][#]] 示例
        :PROPERTIES:
        :CUSTOM_ID: index_u31.html#示例-3
        :CLASS:    calibre31
        :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // 在本地用户文件目录下创建一个文件 hello.txt，写入内容 "hello, world"
      const fs = wx.getFileSystemManager()
      fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'hello, world', 'utf8')
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u31.html#读写权限][#]] 读写权限
      :PROPERTIES:
      :CUSTOM_ID: index_u31.html#读写权限
      :CLASS:    calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 接口、组件     | 读   | 写   |
  |----------------+------+------|
  | 代码包文件     | 有   | 无   |
  | 本地临时文件   | 有   | 无   |
  | 本地缓存文件   | 有   | 无   |
  | 本地用户文件   | 有   | 有   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u31.html#清理策略][#]] 清理策略
      :PROPERTIES:
      :CUSTOM_ID: index_u31.html#清理策略
      :CLASS:    calibre25
      :END:

  -  本地临时文件只保证在小程序当前生命周期内，一旦小程序被关闭就可能被清理，即下次冷启动不保证可用。
  -  本地缓存文件和本地用户文件的清理时机跟代码包一样，只有在代码包被清理的时会被清理。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html]]

  \\
  \\
  | [[../index_u67.html#article_85][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u37.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_87/index_u32.html][下一项]] |
  [[../index_u67.html#article_86][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_85/index_u31.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u37.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u37.html#Canvas-画布][#]] Canvas 画布
     :PROPERTIES:
     :CUSTOM_ID: index_u37.html#Canvas-画布
     :CLASS:    calibre11
     :END:

  所有在 [[../../component/canvas.html][canvas]] 中的画图必须用 JavaScript
  完成：

  WXML：（我们在接下来的例子中如无特殊声明都会用这个 WXML
  为模板，不再重复）

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <canvas canvas-id="myCanvas" style="border: 1px solid;"/>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  JS：（我们在接下来的例子中会将 JS 放在 onLoad 中）

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const ctx = wx.createCanvasContext('myCanvas')
      ctx.setFillStyle('red')
      ctx.fillRect(10, 10, 150, 75)
      ctx.draw()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *第一步：创建一个 Canvas 绘图上下文*

  首先，我们需要创建一个 Canvas 绘图上下文
  [[../../api/canvas/CanvasContext.html][CanvasContext]]。

  CanvasContext 是小程序内建的一个对象，有一些绘图的方法：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const ctx = wx.createCanvasContext('myCanvas')
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *第二步：使用 Canvas 绘图上下文进行绘图描述*

  接着，我们来描述要在 Canvas 中绘制什么内容。

  设置绘图上下文的填充色为红色：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ctx.setFillStyle('red')
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  用 =fillRect(x, y, width, height)=
  方法画一个矩形，填充为刚刚设置的红色：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ctx.fillRect(10, 10, 150, 75)
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *第三步：画图*

  告诉 [[../../component/canvas.html][canvas]]
  组件你要将刚刚的描述绘制上去：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ctx.draw()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  *结果：*

  [[file:feed_0/article_86/images/img1_u13.png]]

**** [[index_u37.html#坐标系][#]] 坐标系
     :PROPERTIES:
     :CUSTOM_ID: index_u37.html#坐标系
     :CLASS:    calibre11
     :END:

  canvas 是在一个二维的网格当中。左上角的坐标为=(0, 0)=。

  在上一节，我们用了这个方法 =fillRect(0, 0, 150, 75)=。

  它的含义为：从左上角=(0, 0)=开始，画一个=150 x 75=px 的矩形。

  *代码示例*

  我们可以在 [[../../component/canvas.html][canvas]]
  中加上一些事件，来观测它的坐标系

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      <canvas canvas-id="myCanvas"
        style="margin: 5px; border:1px solid #d3d3d3;"
        bindtouchstart="start"
        bindtouchmove="move"
        bindtouchend="end"/>

      <view hidden="{{hidden}}">
        Coordinates: ({{x}}, {{y}})
      </view>
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      Page({
        data: {
          x: 0,
          y: 0,
          hidden: true
        },
        start (e) {
          this.setData({
            hidden: false,
            x: e.touches[0].x,
            y: e.touches[0].y
          })
        },
        move (e) {
          this.setData({
            x: e.touches[0].x,
            y: e.touches[0].y
          })
        },
        end (e) {
          this.setData({
            hidden: true
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  当你把手指放到 canvas 中，就会在下边显示出触碰点的坐标：

  [[file:feed_0/article_86/images/img2_u3.png]]

**** [[index_u37.html#渐变][#]] 渐变
     :PROPERTIES:
     :CUSTOM_ID: index_u37.html#渐变
     :CLASS:    calibre11
     :END:

  渐变能用于填充一个矩形，圆，线，文字等。填充色可以不固定为固定的一种颜色。

  我们提供了两种颜色渐变的方式：

  -  [[../../api/canvas/CanvasContext.createLinearGradient.html][=createLinearGradient(x, y, x1, y1)=]]
     创建一个线性的渐变
  -  [[../../api/canvas/CanvasContext.createCircularGradient.html][=createCircularGradient(x, y, r)=]]
     创建一个从圆心开始的渐变

  一旦我们创建了一个渐变对象，我们必须添加两个颜色渐变点。

  [[../../api/canvas/CanvasGradient.addColorStop.html][=addColorStop(position, color)=]]
  方法用于指定颜色渐变点的位置和颜色，位置必须位于 0 到 1 之间。

  可以用[[../../api/canvas/CanvasContext.setFillStyle.html][=setFillStyle=]]
  和
  [[../../api/canvas/CanvasContext.setStrokeStyle.html][=setStrokeStyle=]]
  方法设置渐变，然后进行画图描述。

  *使用 =createLinearGradient()=*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const ctx = wx.createCanvasContext('myCanvas')

      // Create linear gradient
      const grd = ctx.createLinearGradient(0, 0, 200, 0)
      grd.addColorStop(0, 'red')
      grd.addColorStop(1, 'white')

      // Fill with gradient
      ctx.setFillStyle(grd)
      ctx.fillRect(10, 10, 150, 80)
      ctx.draw()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  [[file:feed_0/article_86/images/img3_u10.png]]

  *使用 =createCircularGradient()=*

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const ctx = wx.createCanvasContext('myCanvas')

      // Create circular gradient
      const grd = ctx.createCircularGradient(75, 50, 50)
      grd.addColorStop(0, 'red')
      grd.addColorStop(1, 'white')

      // Fill with gradient
      ctx.setFillStyle(grd)
      ctx.fillRect(10, 10, 150, 80)
      ctx.draw()
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  [[file:feed_0/article_86/images/img4_u4.png]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/canvas.html]]

  \\
  \\
  | [[../index_u67.html#article_86][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u32.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_88/index_u1.html][下一项]] |
  [[../index_u67.html#article_87][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_86/index_u37.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u32.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

* 基础能力 
** [[index_u32.html#分包加载][#]] 分包加载
   :PROPERTIES:
   :CUSTOM_ID: index_u32.html#分包加载
   :CLASS:    calibre9
   :END:

 #+BEGIN_QUOTE
   微信客户端 6.6.0，基础库 [[file:compatibility.html][1.7.3]]
   及以上版本开始支持。开发者工具请使用 1.01.1712150
   及以上版本，可[[../devtools/download.html][点此下载]]。
 #+END_QUOTE

 某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。

 在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个*主包*。所谓的主包，即放置默认启动页面/TabBar
 页面，以及一些所有分包都需用到公共资源/JS
 脚本；而*分包*则是根据开发者的配置进行划分。

 在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。

 目前小程序分包大小有以下限制：

 -  整个小程序所有分包大小不超过 16M
 -  单个分包/主包大小不能超过 2M

 对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。

 具体使用方法请参考：

 -  [[file:subpackages/basic.html][使用分包]]
 -  [[file:subpackages/independent.html][独立分包]]
 -  [[file:subpackages/preload.html][分包预下载]]

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 --------------

 This article was downloaded by *calibre* from
 [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html]]

 \\
 \\
 | [[../index_u67.html#article_87][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |

 #+BEGIN_HTML
   </div>
 #+END_HTML

 <<index_u1.html>>

 #+BEGIN_HTML
   <div class="calibre_navbar">
 #+END_HTML

 | [[../article_89/index_u60.html][下一项]] |
 [[../index_u67.html#article_88][段落菜单]] |
 [[../../index_u64.html#feed_0][主菜单]] |
 [[../article_87/index_u32.html][上一项]] |

 --------------

 #+BEGIN_HTML
   </div>
 #+END_HTML

 #+BEGIN_HTML
   <div id="index_u1.html#docContent" class="calibre6">
 #+END_HTML

 #+BEGIN_HTML
   <div class="calibre6">
 #+END_HTML

*** [[index_u1.html#使用分包][#]] 使用分包
    :PROPERTIES:
    :CUSTOM_ID: index_u1.html#使用分包
    :CLASS:    calibre9
    :END:

***** [[index_u1.html#配置方法][#]] 配置方法
      :PROPERTIES:
      :CUSTOM_ID: index_u1.html#配置方法
      :CLASS:    calibre25
      :END:

  假设支持分包的小程序目录结构如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── app.wxss
      ├── packageA
      │   └── pages
      │       ├── cat
      │       └── dog
      ├── packageB
      │   └── pages
      │       ├── apple
      │       └── banana
      ├── pages
      │   ├── index
      │   └── logs
      └── utils
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  开发者通过在 app.json =subpackages= 字段声明项目分包结构：

  #+BEGIN_QUOTE
    写成 subPackages 也支持。
  #+END_QUOTE

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "pages":[
          "pages/index",
          "pages/logs"
        ],
        "subpackages": [
          {
            "root": "packageA",
            "pages": [
              "pages/cat",
              "pages/dog"
            ]
          }, {
            "root": "packageB",
            "name": "pack2",
            "pages": [
              "pages/apple",
              "pages/banana"
            ]
          }
        ]
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  =subpackages= 中，每个分包的配置有以下几项：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 字段          | 类型          | 说明                                                    |
  |---------------+---------------+---------------------------------------------------------|
  | root          | String        | 分包根目录                                              |
  | name          | String        | 分包别名，[[file:preload.html][分包预下载]]时可以使用   |
  | pages         | StringArray   | 分包页面路径，相对与分包根目录                          |
  | independent   | Boolean       | 分包是否是[[file:independent.html][独立分包]]           |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u1.html#打包原则][#]] 打包原则
      :PROPERTIES:
      :CUSTOM_ID: index_u1.html#打包原则
      :CLASS:    calibre25
      :END:

  -  声明 =subpackages= 后，将按 =subpackages=
     配置路径进行打包，=subpackages= 配置路径外的目录将被打包到
     app（主包） 中
  -  app（主包）也可以有自己的 pages（即最外层的 pages 字段）
  -  =subpackage= 的根目录不能是另外一个 =subpackage= 内的子目录
  -  =tabBar= 页面必须在 app（主包）内

***** [[index_u1.html#引用原则][#]] 引用原则
      :PROPERTIES:
      :CUSTOM_ID: index_u1.html#引用原则
      :CLASS:    calibre25
      :END:

  -  =packageA= 无法 require =packageB= JS 文件，但可以 require
     =app=、自己 package 内的 JS 文件
  -  =packageA= 无法 import =packageB= 的 template，但可以 require
     =app=、自己 package 内的 template
  -  =packageA= 无法使用 =packageB= 的资源，但可以使用 =app=、自己 package
     内的资源

***** [[index_u1.html#低版本兼容][#]] 低版本兼容
      :PROPERTIES:
      :CUSTOM_ID: index_u1.html#低版本兼容
      :CLASS:    calibre25
      :END:

  由微信后台编译来处理旧版本客户端的兼容，后台会编译两份代码包，一份是分包后代码，另外一份是整包的兼容代码。
  新客户端用分包，老客户端还是用的整包，完整包会把各个 =subpackage=
  里面的路径放到 pages 中。

***** [[index_u1.html#示例项目][#]] 示例项目
      :PROPERTIES:
      :CUSTOM_ID: index_u1.html#示例项目
      :CLASS:    calibre25
      :END:

  [[https://res.wx.qq.com/wxdoc/dist/assets/media/demo-subpackages.b42a3adb.zip][下载
  小程序示例（分包加载版）源码]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html]]

  \\
  \\
  | [[../index_u67.html#article_88][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u60.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_90/index_u30.html][下一项]] |
  [[../index_u67.html#article_89][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_88/index_u1.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u60.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u60.html#独立分包][#]] 独立分包
    :PROPERTIES:
    :CUSTOM_ID: index_u60.html#独立分包
    :CLASS:    calibre9
    :END:

  #+BEGIN_QUOTE
    微信客户端 6.7.2，基础库 [[../compatibility.html][2.3.0]]
    及以上版本开始支持。开发者工具请使用 1.02.1808300
    及以上版本，可[[../../devtools/download.html][点此下载]]。
  #+END_QUOTE

  独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。

  开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。

  一个小程序中可以有多个独立分包。

  #+BEGIN_QUOTE
    小游戏在基础库 v2.12.2 开始支持独立分包，详见
    [[https://developers.weixin.qq.com/minigame/dev/guide/base-ability/independent-sub-packages.html][小游戏独立分包指南<<>>]]。
  #+END_QUOTE

***** [[index_u60.html#配置方法][#]] 配置方法
      :PROPERTIES:
      :CUSTOM_ID: index_u60.html#配置方法
      :CLASS:    calibre25
      :END:

  假设小程序目录结构如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── app.wxss
      ├── moduleA
      │   └── pages
      │       ├── rabbit
      │       └── squirrel
      ├── moduleB
      │   └── pages
      │       ├── pear
      │       └── pineapple
      ├── pages
      │   ├── index
      │   └── logs
      └── utils
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  开发者通过在=app.json=的=subpackages=字段中对应的分包配置项中定义=independent=字段声明对应分包为独立分包。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "pages": [
          "pages/index",
          "pages/logs"
        ],
        "subpackages": [
          {
            "root": "moduleA",
            "pages": [
              "pages/rabbit",
              "pages/squirrel"
            ]
          }, {
            "root": "moduleB",
            "pages": [
              "pages/pear",
              "pages/pineapple"
            ],
            "independent": true
          }
        ]
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u60.html#限制][#]] 限制
      :PROPERTIES:
      :CUSTOM_ID: index_u60.html#限制
      :CLASS:    calibre25
      :END:

  独立分包属于分包的一种。普通分包的所有限制都对独立分包有效。独立分包中插件、自定义组件的处理方式同普通分包。

  此外，使用独立分包时要注意：

  -  *独立分包中不能依赖主包和其他分包中的内容*，包括 js 文件、template、wxss、自定义组件、插件等。主包中的=app.wxss=对独立分包无效，应避免在独立分包页面中使用
     =app.wxss= 中的样式；
  -  =App= 只能在主包内定义，独立分包中不能定义
     =App=，会造成无法预期的行为；
  -  独立分包中暂时不支持使用插件。

***** [[index_u60.html#注意事项][#]] 注意事项
      :PROPERTIES:
      :CUSTOM_ID: index_u60.html#注意事项
      :CLASS:    calibre25
      :END:

****** [[index_u60.html#（1）关于-getApp][#]] （1）关于 =getApp()=
       :PROPERTIES:
       :CUSTOM_ID: index_u60.html#（1）关于-getApp
       :CLASS:    calibre26
       :END:

  与普通分包不同，独立分包运行时，=App= 并不一定被注册，因此 =getApp()=
  也不一定可以获得 =App= 对象：

  -  当用户从独立分包页面启动小程序时，主包不存在，=App=也不存在，此时调用
     =getApp()= 获取到的是 =undefined=。
     当用户进入普通分包或主包内页面时，主包才会被下载，=App= 才会被注册。
  -  当用户是从普通分包或主包内页面跳转到独立分包页面时，主包已经存在，此时调用
     =getApp()= 可以获取到真正的 =App=。

  由于这一限制，开发者无法通过 =App=
  对象实现独立分包和小程序其他部分的全局变量共享。

  为了在独立分包中满足这一需求，基础库 [[../compatibility.html][2.2.4]]
  版本开始 =getApp=支持 [=allowDefault=]参数，在 =App=
  未定义时返回一个默认实现。当主包加载，=App=
  被注册时，默认实现中定义的属性会被覆盖合并到真正的 =App= 中。

  *示例代码：*

  -  独立分包中

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const app = getApp({allowDefault: true}) // {}
      app.data = 456
      app.global = {}
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  -  app.js 中

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        data: 123,
        other: 'hello'
      })

      console.log(getApp()) // {global: {}, data: 456, other: 'hello'}
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u60.html#（2）关于-App-生命周期][#]] （2）关于 =App=
  生命周期
       :PROPERTIES:
       :CUSTOM_ID: index_u60.html#（2）关于-App-生命周期
       :CLASS: calibre26
       :END:

  当从独立分包启动小程序时，主包中 =App= 的 =onLaunch= 和首次 =onShow=
  会在从独立分包页面首次进入主包或其他普通分包页面时调用。

  由于独立分包中无法定义 =App=，小程序生命周期的监听可以使用
  [[../../api/base/app/app-event/wx.onAppShow.html][wx.onAppShow]]，[[../../api/base/app/app-event/wx.onAppHide.html][wx.onAppHide]]
  完成。=App= 上的其他事件可以使用
  [[../../api/base/app/app-event/wx.onError.html][wx.onError]]，[[../../api/base/app/app-event/wx.onPageNotFound.html][wx.onPageNotFound]]
  监听。

***** [[index_u60.html#低版本兼容][#]] 低版本兼容
      :PROPERTIES:
      :CUSTOM_ID: index_u60.html#低版本兼容
      :CLASS:    calibre25
      :END:

  在低于 6.7.2 版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。

  *注意：在兼容模式下，主包中的 =app.wxss=
  可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用
  =app.wxss= 中的样式。*

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html]]

  \\
  \\
  | [[../index_u67.html#article_89][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u30.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_91/index_u55.html][下一项]] |
  [[../index_u67.html#article_90][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_89/index_u60.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u30.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

*** [[index_u30.html#分包预下载][#]] 分包预下载
    :PROPERTIES:
    :CUSTOM_ID: index_u30.html#分包预下载
    :CLASS:    calibre9
    :END:

  #+BEGIN_QUOTE
    基础库 2.3.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
    开发者工具请使用 1.02.1808300
    及以上版本，可[[../../devtools/download.html][点此下载]]。
  #+END_QUOTE

  开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于[[file:independent.html][独立分包]]，也可以预下载主包。

  *分包预下载目前只支持通过配置方式使用，暂不支持通过调用 API 完成。*

  #+BEGIN_QUOTE
    vConsole
    里有=preloadSubpackages=开头的日志信息，可以用来验证预下载的情况。
  #+END_QUOTE

***** [[index_u30.html#配置方法][#]] 配置方法
      :PROPERTIES:
      :CUSTOM_ID: index_u30.html#配置方法
      :CLASS:    calibre25
      :END:

  预下载分包行为在进入某个页面时触发，通过在 =app.json= 增加 =preloadRule=
  配置来控制。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "pages": ["pages/index"],
        "subpackages": [
          {
            "root": "important",
            "pages": ["index"],
          },
          {
            "root": "sub1",
            "pages": ["index"],
          },
          {
            "name": "hello",
            "root": "path/to",
            "pages": ["index"]
          },
          {
            "root": "sub3",
            "pages": ["index"]
          },
          {
            "root": "indep",
            "pages": ["index"],
            "independent": true
          }
        ],
        "preloadRule": {
          "pages/index": {
            "network": "all",
            "packages": ["important"]
          },
          "sub1/index": {
            "packages": ["hello", "sub3"]
          },
          "sub3/index": {
            "packages": ["path/to"]
          },
          "indep/index": {
            "packages": ["__APP__"]
          }
        }
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  =preloadRule= 中，=key= 是页面路径，=value=
  是进入此页面的预下载配置，每个配置有以下几项：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 字段       | 类型          | 必填   | 默认值   | 说明                                                            |
  |------------+---------------+--------+----------+-----------------------------------------------------------------|
  | packages   | StringArray   | 是     | 无       | 进入页面后预下载分包的 =root= 或 =name=。=__APP__= 表示主包。   |
  | network    | String        | 否     | wifi     | 在指定网络下预下载，可选值为：\\                                |
  |            |               |        |          | =all=: 不限网络\\                                               |
  |            |               |        |          | =wifi=: 仅 wifi 下预下载                                          |

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u30.html#限制][#]] 限制
      :PROPERTIES:
      :CUSTOM_ID: index_u30.html#限制
      :CLASS:    calibre25
      :END:

  同一个分包中的页面享有共同的预下载大小限额
  2M，限额会在工具中打包时校验。

  如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M
  的分包，B中最多只能预下载总大小 1.5M 的分包。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html]]

  \\
  \\
  | [[../index_u67.html#article_90][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u55.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_92/index_u27.html][下一项]] |
  [[../index_u67.html#article_91][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_90/index_u30.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u55.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u55.html#多线程-Worker][#]] 多线程 Worker
     :PROPERTIES:
     :CUSTOM_ID: index_u55.html#多线程-Worker
     :CLASS:    calibre11
     :END:

  一些异步处理的任务，可以放置于 Worker
  中运行，待运行结束后，再把结果返回到小程序主线程。Worker
  运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法。

  Worker 与主线程之间的数据传输，双方使用
  [[../api/worker/Worker.postMessage.html][Worker.postMessage()]]
  来发送数据，[[../api/worker/Worker.onMessage.html][Worker.onMessage()]]
  来接收数据，传输的数据并不是直接共享，而是被复制的。

**** [[index_u55.html#使用流程][#]] 使用流程
     :PROPERTIES:
     :CUSTOM_ID: index_u55.html#使用流程
     :CLASS:    calibre11
     :END:

  [[https://developers.weixin.qq.com/s/akaQknmy6ZY6][在开发者工具中预览效果<<>>]]

***** [[index_u55.html#_1-配置-Worker-信息][#]] 1. 配置 Worker 信息
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#_1-配置-Worker-信息
      :CLASS:    calibre25
      :END:

  在 =app.json= 中可配置 =Worker=
  代码放置的目录，目录下的代码将被打包成一个文件：

  配置示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "workers": "workers"
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u55.html#_2-添加-Worker-代码文件][#]] 2. 添加 Worker
  代码文件
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#_2-添加-Worker-代码文件
      :CLASS: calibre25
      :END:

  根据步骤 1 中的配置，在代码目录下新建以下两个入口文件：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      workers/request/index.js
      workers/request/utils.js
      workers/response/index.js
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  添加后，目录结构如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── project.config.json
      └── workers
          ├── request
          │   ├── index.js
          │   └── utils.js
          └── response
              └── index.js
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u55.html#_3-编写-Worker-代码][#]] 3. 编写 Worker 代码
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#_3-编写-Worker-代码
      :CLASS:    calibre25
      :END:

  在 =workers/request/index.js= 编写 Worker 响应代码

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const utils = require('./utils')

      // 在 Worker 线程执行上下文会全局暴露一个 worker 对象，直接调用 worker.onMessage/postMessage 即可
      worker.onMessage(function (res) {
        console.log(res)
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u55.html#_4-在主线程中初始化-Worker][#]] 4. 在主线程中初始化
  Worker
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#_4-在主线程中初始化-Worker
      :CLASS: calibre25
      :END:

  在主线程的代码 app.js 中初始化 Worker

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      const worker = wx.createWorker('workers/request/index.js') // 文件名指定 worker 的入口文件路径，绝对路径
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u55.html#_5-主线程向-Worker-发送消息][#]] 5. 主线程向 Worker
  发送消息
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#_5-主线程向-Worker-发送消息
      :CLASS: calibre25
      :END:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      worker.postMessage({
        msg: 'hello worker'
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  worker 对象的其它接口请看
  [[../api/worker/wx.createWorker.html][worker接口说明]]

***** [[index_u55.html#注意事项][#]] 注意事项
      :PROPERTIES:
      :CUSTOM_ID: index_u55.html#注意事项
      :CLASS:    calibre25
      :END:

  1. Worker 最大并发数量限制为 1 个，创建下一个前请用
     [[../api/worker/Worker.terminate.html][Worker.terminate()]] 结束当前
     Worker
  2. Worker 内代码只能 require 指定 Worker 路径内的文件，无法引用其它路径
  3. Worker 的入口文件由
     [[../api/worker/wx.createWorker.html][wx.createWorker()]]
     时指定，开发者可动态指定 Worker 入口文件
  4. Worker 内不支持 =wx= 系列的 API
  5. Workers 之间不支持发送消息

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/workers.html]]

  \\
  \\
  | [[../index_u67.html#article_91][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u27.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_93/index_u77.html][下一项]] |
  [[../index_u67.html#article_92][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_91/index_u55.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u27.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u27.html#后端-API][#]] 后端 API
     :PROPERTIES:
     :CUSTOM_ID: index_u27.html#后端-API
     :CLASS:    calibre11
     :END:

  小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的
  API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如
  =getAccessToken=，=code2Session= 等。详细介绍请参考
  [[../../api/index.html][API 文档]]。

***** [[index_u27.html#access-token][#]] access\_token
      :PROPERTIES:
      :CUSTOM_ID: index_u27.html#access-token
      :CLASS:    calibre25
      :END:

  =access_token=
  是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过
  =getAccessToken= 接口获取并进行妥善保存。

  为了 =access_token= 的安全性，*后端 API 不能直接在小程序内通过
  [[../../api/network/request/wx.request.html][wx.request]] 调用*，即
  =api.weixin.qq.com=
  不能被配置为服务器域名。开发者应在后端服务器使用=getAccessToken=获取
  =access_token=，并调用相关 API；

***** [[index_u27.html#请求参数说明][#]] 请求参数说明
      :PROPERTIES:
      :CUSTOM_ID: index_u27.html#请求参数说明
      :CLASS:    calibre25
      :END:

  -  对于 GET 请求，请求参数应以 QueryString 的形式写在 URL 中。
  -  对于 POST 请求，部分参数需以 QueryString 的形式写在 URL 中（一般只有
     =access_token=，如有额外参数会在文档里的 URL
     中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的
     body 中。

***** [[index_u27.html#返回参数说明][#]] 返回参数说明
      :PROPERTIES:
      :CUSTOM_ID: index_u27.html#返回参数说明
      :CLASS:    calibre25
      :END:

  *注意：当 API 调用成功时，部分接口不会返回 errcode 和
  errmsg，只有调用失败时才会返回。*

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html]]

  \\
  \\
  | [[../index_u67.html#article_92][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u77.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_94/index_u42.html][下一项]] |
  [[../index_u67.html#article_93][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_92/index_u27.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u77.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u77.html#后端-API][#]] 后端 API
     :PROPERTIES:
     :CUSTOM_ID: index_u77.html#后端-API
     :CLASS:    calibre11
     :END:

  小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的
  API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如
  =getAccessToken=，=code2Session= 等。详细介绍请参考
  [[../../api/index.html][API 文档]]。

***** [[index_u77.html#access-token][#]] access\_token
      :PROPERTIES:
      :CUSTOM_ID: index_u77.html#access-token
      :CLASS:    calibre25
      :END:

  =access_token=
  是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过
  =getAccessToken= 接口获取并进行妥善保存。

  为了 =access_token= 的安全性，*后端 API 不能直接在小程序内通过
  [[../../api/network/request/wx.request.html][wx.request]] 调用*，即
  =api.weixin.qq.com=
  不能被配置为服务器域名。开发者应在后端服务器使用=getAccessToken=获取
  =access_token=，并调用相关 API；

***** [[index_u77.html#请求参数说明][#]] 请求参数说明
      :PROPERTIES:
      :CUSTOM_ID: index_u77.html#请求参数说明
      :CLASS:    calibre25
      :END:

  -  对于 GET 请求，请求参数应以 QueryString 的形式写在 URL 中。
  -  对于 POST 请求，部分参数需以 QueryString 的形式写在 URL 中（一般只有
     =access_token=，如有额外参数会在文档里的 URL
     中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的
     body 中。

***** [[index_u77.html#返回参数说明][#]] 返回参数说明
      :PROPERTIES:
      :CUSTOM_ID: index_u77.html#返回参数说明
      :CLASS:    calibre25
      :END:

  *注意：当 API 调用成功时，部分接口不会返回 errcode 和
  errmsg，只有调用失败时才会返回。*

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html]]

  \\
  \\
  | [[../index_u67.html#article_93][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u42.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_95/index_u16.html][下一项]] |
  [[../index_u67.html#article_94][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_93/index_u77.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u42.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u42.html#消息推送][#]] 消息推送
     :PROPERTIES:
     :CUSTOM_ID: index_u42.html#消息推送
     :CLASS:    calibre11
     :END:

  接入微信小程序消息推送服务，可以两种方式选择其一：

  1. [[index_u42.html#option-url][开发者服务器接收消息推送]]
  2. [[index_u42.html#option-cloud][云函数接收消息推送]]

***** [[index_u42.html#开发者服务器接收消息推送][#]]
  开发者服务器接收消息推送
      :PROPERTIES:
      :CUSTOM_ID: index_u42.html#开发者服务器接收消息推送
      :CLASS: calibre25
      :END:

  <<index_u42.html#option-url>>

  开发者需要按照如下步骤完成：

  1. 填写服务器配置
  2. 验证服务器地址的有效性
  3. 据接口文档实现业务逻辑，接收消息和事件

****** [[index_u42.html#第一步：填写服务器配置][#]] 第一步：填写服务器配置
       :PROPERTIES:
       :CUSTOM_ID: index_u42.html#第一步：填写服务器配置
       :CLASS:    calibre26
       :END:

  登录[[https://mp.weixin.qq.com/][小程序后台<<>>]]后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token）
  和 消息加密密钥（EncodingAESKey）等信息。

  -  URL: 开发者用来接收微信消息和事件的接口 URL。开发者所填写的 URL 必须以
     http:// 或 https:// 开头，分别支持 80 端口和 443 端口。
  -  Token: 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL
     中包含的 Token 进行比对，从而验证安全性）。
  -  EncodingAESKey: 由开发者手动填写或随机生成，将用作消息体加解密密钥。

  同时，开发者可选择消息加解密方式：明文模式（默认）、兼容模式和安全模式。可以选择消息数据格式：XML
  格式（默认）或 JSON 格式。

  [[file:feed_0/article_94/images/img1_u4.png]]

  模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。切换加密方式和数据格式需要提前配置好相关代码，详情请参考
  [[https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN][消息加解密说明<<>>]]。

****** [[index_u42.html#第二步：验证消息的确来自微信服务器][#]]
  第二步：验证消息的确来自微信服务器
       :PROPERTIES:
       :CUSTOM_ID: index_u42.html#第二步：验证消息的确来自微信服务器
       :CLASS: calibre26
       :END:

  开发者提交信息后，微信服务器将发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带参数如下表所示：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数        | 描述                                                                                     |
  |-------------+------------------------------------------------------------------------------------------|
  | signature   | 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数。   |
  | timestamp   | 时间戳                                                                                   |
  | nonce       | 随机数                                                                                   |
  | echostr     | 随机字符串                                                                               |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次
  GET 请求来自微信服务器，请原样返回 echostr
  参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

  1. 将 token、timestamp、nonce 三个参数进行字典序排序
  2. 将三个参数字符串拼接成一个字符串进行 sha1 加密
  3. 开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信

  验证 URL 有效性成功后即接入生效，成为开发者。

  检验 signature 的 PHP 示例代码：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      private function checkSignature()
      {
          $signature = $_GET["signature"];
          $timestamp = $_GET["timestamp"];
          $nonce = $_GET["nonce"];

          $token = TOKEN;
          $tmpArr = array($token, $timestamp, $nonce);
          sort($tmpArr, SORT_STRING);
          $tmpStr = implode( $tmpArr );
          $tmpStr = sha1( $tmpStr );

          if ($tmpStr == $signature ) {
              return true;
          } else {
              return false;
          }
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  PHP 示例代码下载：[[https://wximg.gtimg.com/shake_tv/mpwiki/cryptoDemo.zip][下载<<>>]]

****** [[index_u42.html#第三步：接收消息和事件][#]] 第三步：接收消息和事件
       :PROPERTIES:
       :CUSTOM_ID: index_u42.html#第三步：接收消息和事件
       :CLASS:    calibre26
       :END:

  当某些特定的用户操作引发事件推送时（如用户向小程序客服发送消息、或者进入会话等情况），微信服务器会将消息（或事件）的数据包以
  POST 请求发送到开发者配置的 URL，开发者可以依据自身业务逻辑进行响应。

  微信服务器在将用户的消息发给开发者服务器地址后，微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。如果在调试中，发现用户无法收到响应的消息，可以检查是否消息处理超时。关于重试的消息排重，有
  msgid 的消息推荐使用 msgid 排重。事件类型消息推荐使用 FromUserName +
  CreateTime 排重。

  服务器收到请求必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试，否则，将出现严重的错误提示。详见下面说明：

  1. 直接回复 success（推荐方式）
  2. 直接回复空串（指字节长度为 0 的空字符串，而不是结构体中 content 字段的内容为空）
  3. 若接口文档有指定返回内容，应按文档说明返回

  对于客服消息，一旦遇到以下情况，微信会在小程序会话中向用户下发系统提示“该小程序客服暂时无法提供服务，请稍后再试”：

  1. 开发者在 5 秒内未回复任何内容
  2. 开发者回复了异常数据

  如果开发者希望增强安全性，可以在开发者中心处开启消息加密，这样，用户发给小程序的消息以及小程序被动回复用户消息都会继续加密，详见[[https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN][消息加解密说明<<>>]]。

  <<index_u42.html#option-cloud>>

***** [[index_u42.html#云函数接收消息推送][#]] 云函数接收消息推送
      :PROPERTIES:
      :CUSTOM_ID: index_u42.html#云函数接收消息推送
      :CLASS:    calibre25
      :END:

  #+BEGIN_QUOTE
    需开发者工具版本至少 =1.02.1906252=
  #+END_QUOTE

  开通了[[https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html][云开发<<>>]]的小程序可以使用云函数接收消息推送，目前仅支持客服消息推送。

  接入步骤如下：

  1. 开发者工具中填写配置并上传
  2. 云函数中处理消息

****** [[index_u42.html#第一步：开发者工具云开发控制台中增加配置][#]]
  第一步：开发者工具云开发控制台中增加配置
       :PROPERTIES:
       :CUSTOM_ID: index_u42.html#第一步：开发者工具云开发控制台中增加配置
       :CLASS: calibre26
       :END:

  打开云开发控制台，到设置 tab 中选择全局设置 -
  添加消息推送配置。消息类型对应收包的 =MsgType=，事件类型对应收包的
  =Event=，同一个 =<消息类型, 事件类型>=
  二元组只能推到一个环境的一个云函数。例如客服消息文本消息对应的就是消息类型为
  =text=，事件类型为空。具体值请查看各个消息的消息格式。

****** [[index_u42.html#第二步：云函数中处理消息][#]]
  第二步：云函数中处理消息
       :PROPERTIES:
       :CUSTOM_ID: index_u42.html#第二步：云函数中处理消息
       :CLASS: calibre26
       :END:

  云函数被触发时，其 =event= 参数即是接口所定义的 JSON 结构的对象（统一
  =JSON= 格式，不支持 =XML= 格式）。

  以客服消息为例，接收到客服消息推送时，=event= 结构如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "FromUserName": "ohl4L0Rnhq7vmmbT_DaNQa4ePaz0",
        "ToUserName": "wx3d289323f5900f8e",
        "Content": "测试",
        "CreateTime": 1555684067,
        "MsgId": "49d72d67b16d115e7935ac386f2f0fa41535298877_1555684067",
        "MsgType": "text"
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  此时可调用客服消息[[../../api-backend/open-api/customer-message/customerServiceMessage.send.html][发送]]接口回复消息，一个简单的接收到消息后统一回复
  “收到” 的示例如下：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      // 云函数入口文件
      const cloud = require('wx-server-sdk')

      cloud.init()

      // 云函数入口函数
      exports.main = async (event, context) => {
        const wxContext = cloud.getWXContext()
      
        await cloud.openapi.customerServiceMessage.send({
          touser: wxContext.OPENID,
          msgtype: 'text',
          text: {
            content: '收到',
          },
        })

        return 'success'
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html]]

  \\
  \\
  | [[../index_u67.html#article_94][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u16.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_96/index_u75.html][下一项]] |
  [[../index_u67.html#article_95][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_94/index_u42.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u16.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u16.html#自定义-tabBar][#]] 自定义 tabBar
     :PROPERTIES:
     :CUSTOM_ID: index_u16.html#自定义-tabBar
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.5.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  自定义 tabBar 可以让开发者更加灵活地设置 tabBar
  样式，以满足更多个性化的场景。

  在自定义 tabBar 模式下

  -  为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar
     的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染。
  -  此时需要开发者提供一个自定义组件来渲染 tabBar，所有 tabBar
     的样式都由该自定义组件渲染。推荐用 fixed 在底部的
     [[../../component/cover-view.html][cover-view]] +
     [[../../component/cover-image.html][cover-image]]
     组件渲染样式，以保证 tabBar 层级相对较高。
  -  与 tabBar 样式相关的接口，如
     [[../../api/ui/tab-bar/wx.setTabBarItem.html][wx.setTabBarItem]]
     等将失效。
  -  *每个 tab 页下的自定义 tabBar 组件实例是不同的*，可通过自定义组件下的
     =getTabBar= 接口，获取当前页面的自定义 tabBar 组件实例。

  *注意：如需实现 tab 选中态，要在当前页面下，通过 =getTabBar=
  接口获取组件实例，并调用 setData 更新选中态。可参考底部的代码示例。*

***** [[index_u16.html#使用流程][#]] 使用流程
      :PROPERTIES:
      :CUSTOM_ID: index_u16.html#使用流程
      :CLASS:    calibre25
      :END:

****** [[index_u16.html#_1-配置信息][#]] 1. 配置信息
       :PROPERTIES:
       :CUSTOM_ID: index_u16.html#_1-配置信息
       :CLASS:    calibre26
       :END:

  -  在 =app.json= 中的 =tabBar= 项指定 =custom= 字段，同时其余 =tabBar=
     相关配置也补充完整。
  -  所有 tab 页的 json 里需声明 =usingComponents= 项，也可以在 =app.json=
     全局开启。

  示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      {
        "tabBar": {
          "custom": true,
          "color": "#000000",
          "selectedColor": "#000000",
          "backgroundColor": "#000000",
          "list": [{
            "pagePath": "page/component/index",
            "text": "组件"
          }, {
            "pagePath": "page/API/index",
            "text": "接口"
          }]
        },
        "usingComponents": {}
      }
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u16.html#_2-添加-tabBar-代码文件][#]] 2. 添加 tabBar
  代码文件
      :PROPERTIES:
      :CUSTOM_ID: index_u16.html#_2-添加-tabBar-代码文件
      :CLASS: calibre25
      :END:

  在代码根目录下添加入口文件:

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      custom-tab-bar/index.js
      custom-tab-bar/index.json
      custom-tab-bar/index.wxml
      custom-tab-bar/index.wxss
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u16.html#_3-编写-tabBar-代码][#]] 3. 编写 tabBar 代码
       :PROPERTIES:
       :CUSTOM_ID: index_u16.html#_3-编写-tabBar-代码
       :CLASS:    calibre26
       :END:

  用自定义组件的方式编写即可，该自定义组件完全接管 tabBar
  的渲染。另外，自定义组件新增 =getTabBar= 接口，可获取当前页面下的自定义
  tabBar 组件实例。

***** [[index_u16.html#示例代码][#]] 示例代码
      :PROPERTIES:
      :CUSTOM_ID: index_u16.html#示例代码
      :CLASS:    calibre25
      :END:

  [[https://developers.weixin.qq.com/s/jiSARvmF7i55][在开发者工具中预览效果<<>>]]

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html]]

  \\
  \\
  | [[../index_u67.html#article_95][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u75.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_97/index_u74.html][下一项]] |
  [[../index_u67.html#article_96][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_95/index_u16.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u75.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u75.html#周期性更新][#]] 周期性更新
     :PROPERTIES:
     :CUSTOM_ID: index_u75.html#周期性更新
     :CLASS:    calibre11
     :END:

  #+BEGIN_QUOTE
    基础库 2.8.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  #+BEGIN_QUOTE
    生效条件：用户七天内使用过的小程序
  #+END_QUOTE

  周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。

***** [[index_u75.html#使用流程][#]] 使用流程
      :PROPERTIES:
      :CUSTOM_ID: index_u75.html#使用流程
      :CLASS:    calibre25
      :END:

****** [[index_u75.html#_1-配置数据下载地址][#]] 1. 配置数据下载地址
       :PROPERTIES:
       :CUSTOM_ID: index_u75.html#_1-配置数据下载地址
       :CLASS:    calibre26
       :END:

  登录小程序 MP 管理后台，进入设置 -> 开发设置 ->
  数据周期性更新，点击开启，填写数据下载地址。

  [[file:feed_0/article_96/images/img1_u9.png]]
****** [[index_u75.html#_2-设置-TOKEN][#]] 2. 设置 TOKEN
       :PROPERTIES:
       :CUSTOM_ID: index_u75.html#_2-设置-TOKEN
       :CLASS:    calibre26
       :END:

  第一次启动小程序时，调用
  [[../../api/storage/background-fetch/wx.setBackgroundFetchToken.html][wx.setBackgroundFetchToken()]]
  设置一个 TOKEN
  字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

  示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.setBackgroundFetchToken({
            token: 'xxx'
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u75.html#_3-微信客户端定期拉取数据][#]] 3.
  微信客户端定期拉取数据
       :PROPERTIES:
       :CUSTOM_ID: index_u75.html#_3-微信客户端定期拉取数据
       :CLASS: calibre26
       :END:

  微信客户端会在一定的网络条件下，每隔 12
  小时（以上一次成功更新的时间为准）向配置的数据下载地址发起一个 HTTP GET
  请求，其中包含的 query 参数如下，数据获取到后会将整个 HTTP body
  缓存到本地。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数        | 类型     | 说明                               |
  |-------------+----------+------------------------------------|
  | appid       | String   | 小程序标识                         |
  | token       | String   | 前面设置的 TOKEN                   |
  | timestamp   | Number   | 时间戳，微信客户端发起请求的时间   |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_QUOTE
    query 参数会使用 urlencode 处理
  #+END_QUOTE

  #+BEGIN_QUOTE
    开发者服务器接口返回的数据类型应为字符串，且大小应不超过
    =256KB=，否则将无法缓存数据
  #+END_QUOTE

****** [[index_u75.html#_4-读取数据][#]] 4. 读取数据
       :PROPERTIES:
       :CUSTOM_ID: index_u75.html#_4-读取数据
       :CLASS:    calibre26
       :END:

  用户启动小程序时，调用
  [[../../api/storage/background-fetch/wx.getBackgroundFetchData.html][wx.getBackgroundFetchData()]]
  获取已缓存到本地的数据。

  示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.getBackgroundFetchData({
            fetchType: 'periodic',
            success(res) {
              console.log(res.fetchedData) // 缓存数据
              console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
            }
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u75.html#调试方法][#]] 调试方法
      :PROPERTIES:
      :CUSTOM_ID: index_u75.html#调试方法
      :CLASS:    calibre25
      :END:

  由于微信客户端每隔 12
  个小时才会发起一次请求，调试周期性更新功能会显得不太方便。
  因此为了方便调试周期性数据，工具提供了下面的调试能力给到开发者，具体可查看[[../../devtools/periodic-data.html][周期性数据调试]]。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/background-fetch.html]]

  \\
  \\
  | [[../index_u67.html#article_96][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u74.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_98/index_u84.html][下一项]] |
  [[../index_u67.html#article_97][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_96/index_u75.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u74.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

**** [[index_u74.html#数据预拉取][#]] 数据预拉取
     :PROPERTIES:
     :CUSTOM_ID: index_u74.html#数据预拉取
     :CLASS:    calibre11
     :END:

  预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度
  。

***** [[index_u74.html#使用流程][#]] 使用流程
      :PROPERTIES:
      :CUSTOM_ID: index_u74.html#使用流程
      :CLASS:    calibre25
      :END:

****** [[index_u74.html#_1-配置数据下载地址][#]] 1. 配置数据下载地址
       :PROPERTIES:
       :CUSTOM_ID: index_u74.html#_1-配置数据下载地址
       :CLASS:    calibre26
       :END:

  登录小程序 MP 管理后台，进入设置 -> 开发设置 ->
  数据预加载，点击开启，填写数据下载地址，只支持 HTTPS 。

  [[file:feed_0/article_97/images/img1_u8.png]]
****** [[index_u74.html#_2-设置-TOKEN][#]] 2. 设置 TOKEN
       :PROPERTIES:
       :CUSTOM_ID: index_u74.html#_2-设置-TOKEN
       :CLASS:    calibre26
       :END:

  第一次启动小程序时，调用
  [[../../api/storage/background-fetch/wx.setBackgroundFetchToken.html][wx.setBackgroundFetchToken()]]
  设置一个 TOKEN
  字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

  示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.setBackgroundFetchToken({
            token: 'xxx'
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

****** [[index_u74.html#_3-微信客户端提前拉取数据][#]] 3.
  微信客户端提前拉取数据
       :PROPERTIES:
       :CUSTOM_ID: index_u74.html#_3-微信客户端提前拉取数据
       :CLASS: calibre26
       :END:

  当用户打开小程序时，微信服务器将向开发者服务器（上面配置的数据下载地址）发起一个
  HTTP GET 请求，其中包含的 query 参数如下，数据获取到后会将整个 HTTP body
  缓存到本地。

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  | 参数        | 类型     | 必填   | 说明                                                                                                    |
  |-------------+----------+--------+---------------------------------------------------------------------------------------------------------|
  | appid       | String   | 是     | 小程序标识。                                                                                            |
  | token       | String   | 否     | 前面设置的 TOKEN。                                                                                      |
  | code        | String   | 否     | 用户登录凭证，未设置 TOKEN 时由微信侧预生成，可在开发者后台调用 auth.code2Session，换取 openid 等信息。   |
  | timestamp   | Number   | 是     | 时间戳，微信客户端发起请求的时间                                                                        |
  | path        | String   | 否     | 打开小程序的路径。                                                                                      |
  | query       | String   | 否     | 打开小程序的 query。                                                                                     |
  | scene       | Number   | 否     | 打开小程序的场景值。                                                                                    |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_QUOTE
    query 参数会使用 urlencode 处理
  #+END_QUOTE

  #+BEGIN_QUOTE
    token 和 code 只会存在一个，用于标识用户身份。
  #+END_QUOTE

  #+BEGIN_QUOTE
    开发者服务器接口返回的数据类型应为字符串，且大小应不超过
    =256KB=，否则将无法缓存数据
  #+END_QUOTE

****** [[index_u74.html#_4-读取数据][#]] 4. 读取数据
       :PROPERTIES:
       :CUSTOM_ID: index_u74.html#_4-读取数据
       :CLASS:    calibre26
       :END:

  用户启动小程序时，调用
  [[../../api/storage/background-fetch/wx.getBackgroundFetchData.html][wx.getBackgroundFetchData()]]
  获取已缓存到本地的数据。

  示例：

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.getBackgroundFetchData({
            fetchType: 'pre',
            success(res) {
              console.log(res.fetchedData) // 缓存数据
              console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
              console.log(res.path) // 页面路径
              console.log(res.query) // query 参数
              console.log(res.scene) // 场景值
            }
          })
        }
      })
  #+END_EXAMPLE

  #+BEGIN_HTML
    </div>
  #+END_HTML

***** [[index_u74.html#调试方法][#]] 调试方法
      :PROPERTIES:
      :CUSTOM_ID: index_u74.html#调试方法
      :CLASS:    calibre25
      :END:

  为了方便调试数据预拉取，工具提供了下面的调试能力给到开发者，具体可查看[[../../devtools/prefetch-data.html][预拉取数据调试]]。

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  --------------

  This article was downloaded by *calibre* from
  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html]]

  \\
  \\
  | [[../index_u67.html#article_97][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |

  #+BEGIN_HTML
    </div>
  #+END_HTML

  <<index_u84.html>>

  #+BEGIN_HTML
    <div class="calibre_navbar">
  #+END_HTML

  | [[../article_99/index_u63.html][下一项]] |
  [[../index_u67.html#article_98][段落菜单]] |
  [[../../index_u64.html#feed_0][主菜单]] |
  [[../article_97/index_u74.html][上一项]] |

  --------------

  #+BEGIN_HTML
    </div>
  #+END_HTML

  #+BEGIN_HTML
    <div id="index_u84.html#docContent" class="calibre6">
  #+END_HTML

  #+BEGIN_HTML
    <div class="calibre6">
  #+END_HTML

