* 计算机体系结构[[file:computer.org][计算机体系结构]] 
* 计算机操作系统 (用程序控制设备)  
** 系统基本功能 
*** 进程管理
    进程控制、进程同步、进程通信、死锁
*** 内存管理
    内存分配、地址映射、内存保护与共享、虚拟内存
*** 文件管理
   文件存储空间的管理、目录管理、文件读写管理和保护等
*** 设备管理
   完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
   主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
** 系统调用
   Linux 的系统调用主要有以下这些：
| Task     | Commands                    |
| :---:    | ---                         |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |
* make os in ubuntu
** 环境准备[[file:shellcmd.org][cmd]] 
*** os系统软件 
    代码
    编译器 nasm gas
*** 虚拟机 qemu file:shellcmd.org::qemu
*** 虚拟磁盘 dd
*** 硬件 u盘
** 构建
*** nasm bootstrap.asm -o boot.img 
    [[file:~/project/os/da/bootstrap.asm][bootstrap]] 
** 运行
   qemu-system-i386 -fda boot.img
   qemu-system-x86_64 -hda boot.img

   都可以
** 构建软盘
   dd if=/dev/zero of=boot.img seek=1 count=2879
   构建软盘后直接可以运行
*** 软盘参数 
   80个柱面，cylinder
   18个扇区，sector
   2个磁头，head
   2x80x18x512bytes=80x18kbytes=1440kB
*** 写入U盘
    sudo dd if=$(bootstrap) of=/dev/sdb
    优盘启动
    sudo qemu   -drive file=/dev/sdb,if=floppy
*** 挂载软盘
    sudo mount -t msdos -o loop,fat=12   boot.img /mnt 
** 自动构建文件 Makefile 
  选择文件 make -f Makefile  
   #+BEGIN_SRC makefile
     src=boot.asm
     bootstrap=boot.img
     boot.img:boot.asm
       nasm $(src) -o $(bootstrap)
     fat12:
       @dd if=/dev/zero of=$(bootstrap) seek=1 count=2879 >> /dev/zero
       @ls -al $(bootstrap)
     loop:fat12
       sudo umount /mnt
       sudo mount -t msdos -o loop,fat=12 $(bootstrap) /mnt
     run: boot fat12
       qemu-system-i386 -fda $(bootstrap)
   #+END_SRC
** Gas语法
  [[file:~/project/os/da/boot.S][boot.s]] 
  1：首先將hello.S作为输入，使用gcc將汇编程序编译为hello.o的object程序。

  (注意：上面的-m32是不能少的，告诉编译器产生machine 32bit的代码，但是在我们汇编程
  序hello.S中有.code16的字样，就是告诉编译器产生16位的汇编。因为 gnu的汇编器太强大
  了，可以很方便的产生16位和32位的汇编，而日本人书里面用了两种汇编器就是因为nasm汇
  编器无法产生32位的汇编程序。所以问题在他那里就搞复杂了，用到了两种工具）

  2：然后ld这个链接器（linker)將hello.o这个obj文件链接成为boot.elf的elf文件，-e 是
  指定汇编程序的入口，-Ttext 0x7c00是指定程序运行时的地址。

  3：objcopy是將生成了boot.elf文件中的有用程序代码段.text提取出来，生成真正的512字
  节的启动扇区程序boot.out。

  4：objdump是为了以后写大的程序时，观察程序反汇编后是什么情况，生成了有帮助意义的
  boot.asm汇编程序。
** u盘读取扇区
  #+BEGIN_SRC asm
    .global start
    .code16
    start:
        jmp entry
        /*定义fat12文件格式*/
        .byte 0x00
        .ascii "helloOSX"
        .word  512
        .byte  1
        .word  1
        .byte  2
        .word  224
        .word  2880
        .byte  0xf0
        .word  9
        .word  18
        .word  2
        .long  0
        .long  2880
        .byte  0,0,0x29
        .long  0xffffffff
        .ascii  "myosudisk  "
        .ascii  "fat12   "
        .fill 18

    entry:
        mov $0,%ax
        mov %ax,%ds
        mov %ax,%es
        mov %ax,%ss
        mov $0x7c00,%sp
        mov %dl,(0x7dfe)

        mov $msg,%si
        call puts
        mov $my,%si
        call puts

    /*memory=0x8200,chs=002*/
        mov $0x820,%ax
        mov %ax,%es
        mov $0x00,%bx
        mov $0x00,%ch
        mov $0x00,%dh
        mov $0x02,%cl
        call read
        mov $okmsg,%si
        call puts

    loop:
        jmp loop

    read:
        mov (0x7dfe),%dl
        //mov $0x00,%dl
        mov $0x02,%ah
        mov $0x01,%al
        int $0x13
        jc error
        ret

    error:
        mov $errormsg,%si
        call puts
        hlt
        //ret
        jmp loop

    /*
    this is a subfunction to display string
    usage: mov $address,%si
           call puts
    or     mov $label,%si
           call puts
    ,*/
    puts:
      movb (%si),%al
      add $1,%si
      cmp $0,%al
      je finish
      movb $0x0e,%ah
      movw $15,%bx
      int $0x10
      jmp puts
    finish:
      ;hlt
      ret

    msg:
      .asciz "\r\nmy bootloader is running"
    my:
        .asciz "\r\nwelcome to our course "

    errormsg:
        .asciz "\r\nread u flash failed "

    okmsg:
        .asciz "\r\nread  u disk of 2 sector, ok "

    .org 510
    .word 0xaa55

  #+END_SRC
1:u盘的driver number是多少，dl=??

其实读u盘的第二扇区和读软盘没有什么区别，唯一的不同是我们需要知道u盘的
drive number。在调用0x13中断时，dl需要指定一个正确的driver number。从书
本上我们知道软盘的driver number是0x00，但是u盘的drive number是多少？只要
知道了这个driver number,我们就可以读取 u盘的第二个扇区到内存了。

从上面的代码中，可以看到有这样一条代码：

mov %dl,(0x7dfe)

不知道大家看懂了没有，其实当bios在读取u盘的512个字节时，已经把u盘的drive
number保存到了dl中，我们所做的只是把dl中已经保存的关于u盘的drive number,
保存到了内存的0x7dfe处。到后面读u盘，调用int 0x13中断，需要给dl赋值为u盘
drive number时，再从0x7dfe内存地址把drive number读到dl寄存器中，如下图中
所看到，这样就可以正确的读取u盘的第二个扇区了，因为我们得到u盘的drive
number。

** Linux(ubuntu)下30天自制os学习引导，第3.1天(如何得到 u盘的chs结构）
 上文已经讲了如何得到u盘的drive number,但是且得到这一参数，还不足够实现对u盘的多个扇区的读取，因为你还不知道u盘的一个cylinder有多少个扇区。所以本节就来解决这样的问题，通过调用 Int 13/AH=08h中断，可以知道得到有关u盘的chs结构。

        程序比较容易，只是在写显示寄存器上的二进制时，花了一点时间 。大家只需要把
        程序下载下来，编译后写到 u盘上运行一下就可以知道自己u盘的chs结构了。下面
        对Int 13/AH=08h这个中断进行简单介绍

 程序伪代码如下：

 ah=0x08
 
 dl=drive number
 
 int 0x13
 而关于u盘的chs的值则存在于dx,cx中：

 dh=max head number（最大的磁头数，对于软盘则是1）

 dl=number of drivers(有多少存储个盘，如果只有一个硬盘,就会显示1)

 cl=maximum sector number (bits 5-0)  (最大扇区数，注意只有这个字节的 低6位,高2位为cylinder的高2位）

 ch=low eight bits of maximum cylinder number(这个是关于u盘的磁道数，对于软盘则是79）

 上面这样说明，可能没有画图直观，博主在下面画一个图，更清楚的说明上面参数的意思



 上图可以清楚的知道我们的u盘的chs数，下面从运行程序得到数字来看看这样计算是否正常，先上一个qemu模拟软盘时，得到的chs值，因为软盘大家都比较清楚 。



 从上图二进制数字中，可以看到软盘的 drive number=dl=0x00

 dh代表head 的最的大max number,所以是1 (上图标错了)

 cl的低6位代表最大的扇区数，cl=0b 010010 =18

 而关于cylinder的数字则是上图中黄色字样： 0b 00  01001111,大家可以把二进制转换成16进制看看，正好是64+15=79



         因为cylinder 和head数是从0开始,而扇区数是从1开始 ，所以 软盘的大小正好是cxhxs=(79+1)x(1+1)x18扇区数

 通过上面的分析，大家应该知道怎么使用这个中断得到u盘的chs了，下面上一张从u盘启动时，显示的chs的结果的图片，有时间的读者可以分析一下，博主的这个u盘的大小。



 程序就不在这里上了，代码有点多，大家可以到百度云盘上云下载，目录为AboutUSB,运行程序的步骤也有说明


 好吧，下节再见！有问题记得加群交流哦！be relax!
** 上节我们讲了，通过通过调用 Int 13/AH=08h中断，可以得到u盘chs结构的数据信息，程序博主已经上传到百度云了，有兴趣的读者可以下载下来，将程序编译后，写到u盘中，然后从u盘启动（真机启动，或是用qemu从u盘启动都可以）。

 下面是博主的两个u盘的chs结构，大家可以看看。    



 大家可以发现,u盘每个 cyliner的扇区数都是从第1到第63,

 而博主8GB的u盘的head是从0到254,

            2GB的u盘的head是0到63

 因为《30天自制os》的作者只读了软盘的10个cylinder，软盘10个cylinder的大小是10x2x18x512=180KB

 如果我们要用u盘，那也只需要读180KB的内容到内存的0x8000就可以了，

 计算一下：6x63x512=189kB ，所以我们只需要读u盘的6个head大小，就可以满足要求了。

 伪代码如下：



  for(head=0;head<6;head++)
  {<pre name="code" class="plain">  for(sector=1;sector<64;sector++)
  {
 ah=0x02 al=0x01 int 0x13 }}
 当然，上面是用c写的伪代码，下面我把gnu格式的汇编代码贴出来，但是整个，工程包含makefile的文件，请大家都网盘自行下载，就不一一贴出来了，有问题群内交流。

 .global start
 .code16
 start:

     jmp entry
     /*定义fat12文件格式*/
     .byte 0x00
     .ascii "helloOSX"
     .word  512
     .byte  1
     .word  1
     .byte  2
     .word  224
     .word  2880
     .byte  0xf0
     .word  9
     .word  18
     .word  2
     .long  0
     .long  2880
     .byte  0,0,0x29
     .long  0xffffffff
     .ascii  "myosudisk  "
     .ascii  "fat12   "
     .fill 18


 entry:
     mov $0,%ax
     mov %ax,%ds
     mov %ax,%es
     mov %ax,%ss
     mov $0x7c00,%sp
     mov %dl,(0x7dfe)
 /*显示一些*/
     mov $msg,%si
     call puts
     mov $my,%si
     call puts
 /*memory=0x8200,chs=002*/
     mov $0x800,%ax
     mov %ax,%es
     mov $0x00,%bx

     mov $0x00,%ch
     mov $0x00,%dh
     mov $0x01,%cl
 //读取18个扇区数
 readloop:
     mov $0x00,%si    /*记住扇区读失败的次数*/
     call read

     mov %es,%ax
     add $0x0020,%ax
     mov %ax,%es
     add $0x01,%cl
     cmp $63,%cl
     jbe readloop
     //63个扇区读完了，可以chs中 h++了
     mov $0x01,%cl  //扇区从1开始
     add  $0x01,%dh
     cmp  $0x6,%dh
     jb readloop
     jmp haha
     mov $errormsg,%si
     call puts

 loop:
     jmp loop

 haha:
    mov $msgusb,%si
    call puts
    jmp loop

 msgusb:
	 .asciz "\r\nlast sector of usb read ok"



 /*读一个扇区的子程序*/
 read:
     mov (0x7dfe),%dl
     //mov $0x00,%dl
     mov $0x02,%ah   //read
     mov $0x01,%al   //one sector
     int $0x13
     jnc over        //没有进位就成功了，有进位就会需要重新读取
     add $0x01,%si
     cmp $0x05,%si
     jae error
     mov $0x00,%ah
     mov $0x00,%dl
     int $0x13
     jmp read
 over:
     ret


 error:
     mov $errormsg,%si
     call puts
     jmp loop

 /*
 this is a subfunction to display string
 usage: mov $address,%si
        call puts
 or     mov $label,%si
        call puts
 */
 puts:
   movb (%si),%al
   add $1,%si
   cmp $0,%al
   je finish
   movb $0x0e,%ah
   movw $15,%bx
   int $0x10
   jmp puts
 finish:
   ;hlt
   ret


 msg:
	 .asciz "\r\nmy bootloader is running"
 my:
     .asciz "\r\nwelcome to our course "

 errormsg:
     .asciz "\r\nread u flash failed "

 okmsg:
     .asciz "\r\nread  u disk of  180kB, ok "

 .org 510
 .word 0xaa55
 上面的程序，重点看博主是如何读取u盘的 6x63x512=189kB的内容到u盘的，有几点补充讲下：
 1：程序把 u盘的 chs=0 0 1到 0 5 63的内容复制到了 内存起点的0x8000的位置

 2：如果读取u盘的程序成功，就会显示“last sector of usb read ok"

 3:程序中得到u盘的drive numbe的方法，先把bios程序之前保存在dl中的drive number保存到内存的 0x7dfe处，

 等需要用到 u盘的drive number时，再从内存的这个位置读出来，

  mov %dl,(0x7dfe)
 读内存中保存的u盘的drive number到寄存器dl


  mov (0x7dfe),%dl

 好了，整个程序也没有其它的难点，大家看下来，应该也没有其它吃力的地方。

 如果大家能够自由的读取u盘的任何扇区，那么在后面自己学习这本书时，就完全可以从u盘启动，最大的好处，就是可以从真实的电脑启动自己的程序，以后把这本书学完了后，学习linux内核时，也更容易做各类实验，因为有时候我们还是不太相信虚拟机的。





 后面的课程中,我们就需要跳转到另一个汇编程序,我们称为head.S,然后在head.S中完成过渡到32位模式,并跳转到c函数继续我们的学习过路.

 今天就到这里，博主已经学习完了11天了，上面是11天的代码从u盘启动的情况 。有问题记得交流哦。



 以后的程序不再往百度云盘上存放，直接放到github上管理了，代码已经更新到了14天部分。

 github的使用可能对于新手来说有点拿，但这个代码管理工具对于一个专业的程序员来说是不可少的。

 github的学习如Linux这个系统一样，虽然学起来难，但是一旦学会了，你会发现这是管理代码的神器，当然只是博主用了大约两个星期的感觉。

 30天 github的地址：https://github.com/cherishsir/ubuntu230os

 如果读者现在已经走了使用ubuntu的道路，非常好，只要使用下面的命令就可以把github上的所有代码下载到你的电脑上了。



 1：首先，安装git工具：sudo apt-get install git

 2:然后，下载github上的30os的源代码：git clone https://github.com/cherishsir/ubuntu230os.git

 有没有感觉到github对于管理代码的强大，还没有？？？放心，工具这事，你要用一段时间才会有这要的感觉。坚持用LInux半年后，你同样会爱上这个系统，因为他真的很高效，方便无比。加油吧！！


 
 --------------------- 
 作者：cherishsir 
 来源：CSDN 
 原文：https://blog.csdn.net/cherishsir/article/details/29368655 
 版权声明：本文为博主原创文章，转载请附上博文链接！
** qemu调试内核需知，中断查询网页

 qume内核调试技术总结：

  1：动行qemu后，ctr+alt+2打开qemu monitor console

  2：查看内存里面的数据,比如我们要查看内存0x7dfe的数据，输入下面的命令


 xp /1x 0x7dfe

  3：查看寄存器的值 

 info registers
  4：查看有哪些命令


 info
  5：查看具体哪一个寄存器，如查看ax ,  


 print    $eax
  6：退出qemu 

 quit

 7:对操作系统启动方式的模式
 从硬盘启动

 qemu   -drive file=os.img
 从软盘启动


 qemu   -drive file=os.img,if=floppy
* elf
** ELF32文件结构
#+BEGIN_SRC c
#define EI_NIDENT    16
typedef struct elf32_hdr{
  unsigned char    e_ident[EI_NIDENT];  //开始的16个字节
  Elf32_Half    e_type;  //文件类型
  Elf32_Half    e_machine;  //运行的机器类型
  Elf32_Word    e_version;  //版本
  Elf32_Addr    e_entry;  //程序入口地址
  Elf32_Off    e_phoff;  //程序头表在文件中的偏移
  Elf32_Off    e_shoff;  //节头表在文件中的偏移
  Elf32_Word    e_flags;  //标记
  Elf32_Half    e_ehsize;  //elf文件头大小
  Elf32_Half    e_phentsize;  //程序头表项的大小
  Elf32_Half    e_phnum;  //程序头表中表项项的个数
  Elf32_Half    e_shentsize;  //节头表项大小
  Elf32_Half    e_shnum;  //节头表中表项的个数
  Elf32_Half    e_shstrndx;  //节头表的字符串节所在节头表中下标
} Elf32_Ehdr;
#+END_SRC
节头表项对应的代码定义为：
#+BEGIN_SRC c
typedef struct elf32_shdr {
  Elf32_Word    sh_name;  //节的名字，在符号表中的下标
  Elf32_Word    sh_type;  //节的类型，描述符号，代码，数据，重定位等
  Elf32_Word    sh_flags;  //读写执行标记
  Elf32_Addr    sh_addr;  //节在执行时的虚拟地址
  Elf32_Off    sh_offset;  //节在文件中的偏移量
  Elf32_Word    sh_size;  //节的大小
  Elf32_Word    sh_link;  //其它节的索引
  Elf32_Word    sh_info;  //节的其它信息
  Elf32_Word    sh_addralign;  //节对齐
  Elf32_Word    sh_entsize;  //节拥有固定大小项的大小
} Elf32_Shdr;
#+END_SRC
: jmp汇编 的是偏移地址,我们写是写绝对地址
#+TITTLE: int中断
** int 10 显示中断
#+CAPTION: 
|  AH | 功能                       | 调用参数                               | 返回参数                        |
|-----+----------------------------+----------------------------------------+---------------------------------|
|   0 | 设置显示模式               | AL = video mode                        | AL = video mode flag  mode byte |
|     |                            | 模式碼 (正常為 03h)                    |                                 |
|     |                            | 00H: 40*25 16 色 8 頁 B8000H~B87CFH    | 文字模式                        |
|     |                            | 01H: 80*25 16 色 8 頁 B8000H~B87CFH    |                                 |
|     |                            | 02H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 03H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 07H: 80*25 2 色 8 頁 B8000H~B8F9FH     |                                 |
|     |                            | 04H: 320*200 4 色 1 頁 B8000H~BBF3FH   | 绘图模式                        |
|     |                            | 05H: 320*200 4 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 06H: 640*200 2 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 0DH: 320*200 16 色 8 頁 A0000H~A1F3FH  |                                 |
|     |                            | 0EH: 640*200 16 色 4 頁 A0000H~A3E7FH  |                                 |
|     |                            | 0FH: 640*350 2 色 2 頁 A0000H~A6D5FH   |                                 |
|     |                            | 10H: 640*350 16 色 2 頁 A0000H~A6D5FH  |                                 |
|     |                            | 11H: 640*480 2 色 1 頁 A0000H~A95FFH   |                                 |
|     |                            | 12H: 640*480 16 色 1 頁 A0000H~A95FFH  |                                 |
|     |                            | 13H: 320*200 256 色 1 頁 A0000H~AF9FFH |                                 |
|   1 | 置光标类型                 | (CH)0―3 = 光标开始行                  |                                 |
|     |                            | (CL)0―3 = 光标结束行                  |                                 |
|   2 | 置光标位置                 | BH = 页号                              |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   3 | 读光标位置                 | BH = 页号                              |                                 |
|     |                            | CH = 光标开始行                        |                                 |
|     |                            | CL = 光标结束行                        |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   4 | 读光笔位置                 |                                        | AH=0 光笔未触发                 |
|     |                            |                                        | AH=1 光笔触发                   |
|     |                            |                                        | CH=象素行                       |
|     |                            |                                        | BX=象素列                       |
|     |                            |                                        | DH=字符行                       |
|     |                            |                                        | DL=字符列                       |
|     |                            |                                        |                                 |
|   5 | 显示页                     | AL = 显示页号                          |                                 |
|   6 | 屏幕初始化或上卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   7 | 屏幕初始化或下卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   8 | 读光标位置的属性和字符     | BH = 显示页                            | AH = 属性                       |
|     |                            |                                        | AL = 字符                       |
|   9 | 在光标位置显示字符及其属性 | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | BL = 属性                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   A | 在光标位置只显示字符       | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   E | 显示字符(光标前移)         | AL = 字符                              |                                 |
|     |                            | BL = 前景色                            |                                 |
| 13h | 显示字符串                 | ES:BP = 串地址                         |                                 |
|     |                            | CX = 串长度                            |                                 |
|     |                            | DH=row， DL = 起始行列                 |                                 |
|     |                            | BH = 页号                              |                                 |
|     |                            | AL = writemode，BL = 属性/颜色         |                                 |

** int 13 磁盘中断
#+CAPTION:  int 13 磁盘操作
| AH  | 功能                  | 调用参数                                  | 返回参数                                     |
| 00  | 磁盘系统复位          | DL＝驱动器                                | CF＝0——操作成功，AH＝00H                     |
|     |                       | 00H~7FH：软盘                             | 否则，AH＝状态代码                           |
|     |                       | 80H~0FFH：硬盘                            |                                              |
| 01  | 读取磁盘系统状态      | DL＝驱动器                                | AH＝00H，AL＝状态代码，其定义如下：          |
|     |                       | 00H~7FH：软盘                             | 00H — 无错                                   |
|     |                       | 80H~0FFH：硬盘                            | 01H — 非法命令                               |
|     |                       |                                           | 02H — 地址目标未发现                         |
|     |                       |                                           | 03H — 磁盘写保护(软盘)                       |
|     |                       |                                           | 04H — 扇区未发现                             |
|     |                       |                                           | 05H — 复位失败(硬盘)                         |
|     |                       |                                           | 06H — 软盘取出(软盘)                         |
|     |                       |                                           | 07H — 错误的参数表(硬盘)                     |
|     |                       |                                           | 08H — DMA越界(软盘)                          |
|     |                       |                                           | 09H — DMA超过64K界限                         |
|     |                       |                                           | 0AH — 错误的扇区标志(硬盘)                   |
|     |                       |                                           | 0BH — 错误的磁道标志(硬盘)                   |
|     |                       |                                           | 0CH — 介质类型未发现(软盘)                   |
|     |                       |                                           | 0DH — 格式化时非法扇区号(硬盘)               |
|     |                       |                                           | 0EH — 控制数据地址目标被发现(硬盘)           |
|     |                       |                                           | 0FH — DMA仲裁越界(硬盘)                      |
|     |                       |                                           | 10H — 不正确的CRC或ECC编码                   |
|     |                       |                                           | 11H — ECC校正数据错(硬盘)                    |
|     |                       |                                           | 20H — 控制器失败                             |
|     |                       |                                           | 40H — 查找失败                               |
|     |                       |                                           | 80H — 磁盘超时(未响应)                       |
|     |                       |                                           | AAH — 驱动器未准备好(硬盘)                   |
|     |                       |                                           | BBH — 未定义的错误(硬盘)                     |
|     |                       |                                           | CCH — 写错误(硬盘)                           |
|     |                       |                                           | E0H — 状态寄存器错(硬盘)                     |
|     |                       |                                           | FFH — 检测操作失败(硬盘)                     |
| 02H | 读扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | (#驱动器,相当于哪块磁盘)        |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 03H | 写扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 04H | 检验扇区              | AH＝04H                                   | CF＝0——操作成功，AH＝00H，AL＝被检验的扇区数 |
|     |                       | AL＝扇区数                                | 否则，AH＝状态代码                           |
|     |                       | CH＝柱面                                  |                                              |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 05H | 格式化磁道            | AL＝交替(Interleave)                      | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 06H | 格式化坏磁道          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 07H | 格式化驱动器          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 08H | 读取驱动器参数        | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | CF＝1——操作失败，AH＝状态代码                |
|     |                       |                                           | 否则， BL＝01H — 360K                        |
|     |                       |                                           | ＝02H — 1.2M                                 |
|     |                       |                                           | ＝03H — 720K                                 |
|     |                       |                                           | ＝04H — 1.44M                                |
|     |                       |                                           | CH＝柱面数的低8位                            |
|     |                       |                                           | CL的位7-6＝柱面数的高2位                     |
|     |                       |                                           | CL的位5-0＝扇区数                            |
|     |                       |                                           | DH＝磁头数                                   |
|     |                       |                                           | DL＝驱动器数                                 |
|     |                       |                                           | ES:DI＝磁盘驱动器参数表地址                  |
| 09H | 初始化硬盘参数        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H否则                 |
|     |                       |                                           | AH＝状态代码，参见功能号01H中的说明          |
| 0AH | 读长扇区, 每个扇区    | AL＝扇区数                                |                                              |
|     | 随带四个字节的ECC编码 | CH＝柱面                                  | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CL＝扇区                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0BH | 写长扇区，每个扇区随  | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     | 带四个字节的ECC编码   | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0CH | 查寻                  | CL(7-6位)＝柱面的高2位                    | CF＝0——操作成功，AH＝00H，                   |
|     |                       | DH＝磁头                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 0DH | 硬盘系统复位          | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 0EH | 读扇区缓冲区          | ES:BX＝缓冲区的地址                       | 出口参数：CF＝0——操作成功                    |
| 0FH | 写扇区缓冲区          | ES:BX＝缓冲区的地址                       | CF＝0——操作成功                              |
| 10H | 读取驱动器状态        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H                     |
| 11H | 校准驱动器            | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 12H | 控制器RAM诊断         |                                           | CF＝0——操作成功，....                        |
| 13H | 控制器驱动诊断        |                                           | CF＝0——操作成功，否则，...                   |
| 14H | 控制器内部诊断        |                                           | CF＝0——操作成功，否则                        |
| 15H | 读取磁盘类型          | DL＝驱动器，00H~7FH：软盘；               | CF＝1——操作失败，AH＝状态代码                |
|     |                       | 80H~0FFH：硬盘                            | AH＝00H — 未安装驱动器                       |
|     |                       |                                           | ＝01H — 无改变线支持的软盘驱动器             |
|     |                       |                                           | ＝02H — 带有改变线支持的软盘驱动器           |
|     |                       |                                           | ＝03H — 硬盘，CX:DX＝512字节的扇区数         |
| 16H | 读取磁盘变化状态      | DL＝00H~7FH：软盘                         | CF＝0——磁盘未改变，AH＝00H                   |
|     |                       |                                           | 否则，AH＝06H，参见功能号01H中的说明         |
| 17H | 设置磁盘类型          | DL＝00H~7FH：软盘 AL＝00H — 未用          | CF＝0——操作成功，AH＝00H，                   |
|     |                       | ＝01H — 360K在360K驱动器中                | 否则，AH＝状态编码，参见功能号01H中的说明    |
|     |                       | ＝02H — 360K在1.2M驱动器中                |                                              |
|     |                       | ＝03H — 1.2M在1.2M驱动器中                |                                              |
|     |                       | ＝04H — 720K在720K驱动器中                |                                              |
| 18H | 设置格式化媒体类型    | CH＝柱面数                                | CF＝0——操作成功，AH＝00H，                   |
|     |                       | CL＝每磁道的扇区数                        | ES:DI＝介质类型参数表地址，                  |
|     |                       | DL＝00H~7FH：软盘                         | 否则，AH＝状态编码，参见功能号01H中的说明    |
| 19H | 磁头保护，仅在PS/2    |                                           |                                              |
| 1AH | 格式化ESDI驱动器      | 仅在PS/2中有效，在此从略                  |                                              |

** int 16 键盘中断
| AH  | 功能                                | 调用参数                           | 返回值                           |
| 00H | 读取键盘输入                        |                                    | AL 字符的ASCII                   |
|     | 按键按下才返回                      |                                    | AH 扫描码                        |
| 01H | 确认键盘键入字符                    |                                    | AL 字符的ASCII                   |
|     |                                     |                                    | AH Scan code                     |
|     |                                     |                                    | ZF=1 未键入字符,无返回           |
|     |                                     |                                    | ZF=0 NZ,返回上面的               |
| 02H | Return shift-flag status            |                                    | AL Current shift status          |
|     |                                     |                                    | 7 6 5 4 3 2 1 0                  |
|     |                                     |                                    | Ins,Capa,Num,Scrol,Alt,C,左S,右S |
| 03H | Set typematic rate and delay        | AL 05 (subfunction number)         |                                  |
|     |                                     | BL 00H through 1FH, typematic rate |                                  |
|     |                                     | (30 charßsec to 2 char/sec)        |                                  |
|     |                                     | BH Delay rate:                     |                                  |
|     |                                     | 00h = 250 ms                       |                                  |
|     |                                     | 01h = 500 ms                       |                                  |
|     |                                     | 02h = 750 ms                       |                                  |
|     |                                     | 03h = 1000 ms                      |                                  |
|     |                                     | 04h to 07h = Reserved              |                                  |
| 05h | Add key to Keyboard buffer          | CL ASCII code                      | If Carry = 1:                    |
|     |                                     | CH Scan code                       | AL Keyboard buffer full          |
| 10h | Read extended character from buffer |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
| 11h | Return extended buffer status       |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
|     |                                     |                                    | ZF No keystroke available        |
|     |                                     |                                    | NZ Keystroke in buffer           |
| 12h | Return extended shift status        |                                    | AL Shift status:                 |
|     |                                     |                                    | Bit 7 1 = Sys Req pressed        |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Right Alt active       |
|     |                                     |                                    | Bit 2 1 = Right Ctrl active      |
|     |                                     |                                    | Bit 1 1 = Left Alt active        |
|     |                                     |                                    | Bit 0 1 = Left Ctrl active       |
|     |                                     |                                    | AH Extended shift status:        |
|     |                                     |                                    | Bit 7 1 = Insert active          |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Alt pressed            |
|     |                                     |                                    | Bit 2 1 = Ctrl pressed           |
|     |                                     |                                    | Bit 1 1 = Left Shift pressed     |
|     |                                     |                                    | Bit 0 1 = Right Shift pressed    |

** example
INT 0x10功能0x13
描述：
        以电传打字机的方式显示字符串
接受参数：
        AH                      0x13
        AL                      显示模式
        BH                      视频页
        BL                      属性值（如果AL=0x00或0x01）
        CX                      字符串的长度
        DH,DL           屏幕上显示起始位置的行、列值
        ES:BP           字符串的段:偏移地址
返回值：
        无
显示模式（AL）：
        0x00:字符串只包含字符码，显示之后不更新光标位置，属性值在BL中
        0x01:字符串只包含字符码，显示之后更新光标位置，属性值在BL中
        0x02:字符串包含字符码及属性值，显示之后不更新光标位置
        0x03:字符串包含字符码及属性值，显示之后更新光标位置

# A bootsect, which print a string by BIOS interrupt video services(int 0x10)

#+BEGIN_SRC asm -n -r
.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $msgstr,%bp
        movw    len,    %cx
        movb    $0x05,  %dh
        movb    $0x08,  %dl
        movb    $0x01,  %al
        movb    $0x13,  %ah
        movb    $0x01,  %bl
        movb    $0x00,  %bh

        int             $0x10
1:
        jmp             1b

msgstr:
        .asciz  "Hello babyos(print by BIOS int 0x10:0x13, mode 0x01)!"
len:
        .int    . - msgstr

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC
makefile:

#+BEGIN_SRC makefile -n -r
all: boot.img

boot.o: boot.s
        as -o $@ $<

boot: boot.o
        ld --oformat binary -N -Ttext 0x7c00 -o $@ $<

boot.img: boot
        dd if=boot of=boot.img bs=512 count=1

clean:
        rm ./boot ./boot.img ./boot.o
#+END_SRC
2.通过功能号0x09探究色彩控制
上面的显示为什么是红色呢？我们可以通过实验来看一下颜色控制

------------------------------------------------------------------------
                        INT 0x10功能0x09
-------------------------------------------------------------------
描述：
        显示字符并设置其属性
接受参数：
        AH                      0x09
        AL                      字符的ASCII码
        BH                      视频页
        BL                      属性值
        CX                      重复次数
返回值：
        无
注意：
        在显示字符之后并不前进光标。在文本和图形模式下均可调用该功能
        显示完字符后，如果还要继续显示字符，必须调用INT 0x10功能0x02前进光标
-------------------------------------------------------------------------

------------------------------------------------------------------------
                        INT 0x10功能0x02
-------------------------------------------------------------------
描述：
        把光标定位在选定视频页的特定行列位置
接受参数：
        AH                      0x02
        DH，DL          行、列值
        BH                      视频页
返回值：
        无
注意：
        在80x25模式下，DH范围0～24，DL范围0～79
-------------------------------------------------------------------------

示例：

实现一个从第4行～7行，第8列～71列，显示‘A’～‘Z’的程序，共显
示256个字符，使用BL（0～255）

: C 伪代码：

#+BEGIN_SRC C  -n -r
cx = 0x04;
bh = 0x00;

dh = 0x04;
dl = 0x08;
al = 'A';

for (bl = 0; bl < 256; bl++)
{
        print_char();
        
        al++;
        if (al == 'Z')
                al = 'A';
        
        dl++;
        if (dl == 72)
        {
                dh++;
                dl = 4;
        }
        
        set_cursor();
}

#+END_SRC
汇编代码：

#+BEGIN_SRC  asm -n -r
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char
        incb    %al
        cmpb    $'Z',   %al
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl
        cmpb    $72,    %dl
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor
        incb    %bl
        cmp             $256,   %bl
        jne             1b
        jmp             1f

print_char:
        movb    $0x09,  %ah
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC

结果：
[1356282645]

可以显式地验证色彩控制BL：

| 7    | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| I    | R | G | B | I | R | G | B |
| 闪烁 | R | G | B | I | R | G | B |
如上图所示，7～4位为背景色，I表示高亮，RGB表示红绿蓝，若显
卡支持闪烁，则位7表示是否闪烁。
色彩混合：
----------------------------------------------
| 混合的三种基色 | 不开启亮度位 | 开启亮度位 |
| 红+绿+蓝       | 浅灰         | 白色       |
| 绿+蓝          | 青色         | 浅青       |
| 红+蓝          | 洋红         | 浅洋红     |
| 红+绿          | 棕色         | 黄色       |
| 无色彩         | 黑色         | 暗灰       |
----------------------------------------------

3.清屏

可以发现屏幕上有许多Bochs的打印信息，看着不爽，想办法去掉它
们。

利用0x06号功能，上卷全部行，则可清屏。

-----------------------------------------------------------
INT 0x10 功能0x06
------------------------------------------------------
描述：
上卷窗口
参数：
AH 6
AL 上卷的行数（0表示全部）
BH 空白区域的视频属性
CH，CL 窗口左上角的行列位置
DH，DL 窗口右下角的行列位置
返回值：
无
------------------------------------------------------------
示例：

#+BEGIN_SRC asm -n
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        call    clear_screen    # 清屏

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char              # 打印字符
        incb    %al                             # 下一个字符
        cmpb    $'Z',   %al             # 是否该重新从‘A’开始
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl                             # 下一个位置
        cmpb    $72,    %dl             # 是否到下一行
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor              # 设置光标位置
        incb    %bl                             # 下一种属性
        cmp             $0,             %bl             # 是否256种属性用完
        jne             1b
        jmp             1f                              # 结束

clear_screen:                           # 清屏函数
        movb    $0x06,  %ah             # 功能号0x06
        movb    $0,             %al             # 上卷全部行，即清屏
        movb    $0,             %ch             # 左上角行
        movb    $0,             %ch             # 左上角列      
        movb    $24,    %dh             # 右下角行
        movb    $79,    %dl             # 右下角列
        movb    $0x07,  %bh             # 空白区域属性
        int             $0x10
        ret

print_char:
        movb    $0x09,  %ah             # 功能号0x09
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah             # 功能号0x02
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55

#+END_SRC
结果：

[1356283975]

4.直接写显存绘制字符串：

示例：

#+BEGIN_SRC asm -n -r
#---------------------------------------------------------------
# 直接写显存显示一些文字函数：
#       显示计算机当前工作的显示模式    
draw_some_text:
        # 设置ES，DS的值
        movw    $VIDEO_SEG_TEXT,%ax
        movw    %ax,                    %es
        xorw    %ax,                    %ax
        movw    %ax,                    %ds

        # 计算字符显示位置的显存地址(目标地址)
        movw    $((80*TEXT_ROW+TEXT_COL) * 2),  %di
        
        # 源字符串地址
        leaw    msgstr,                 %si
        
        movb    $TEXT_COLOR,    %al             # 属性值（颜色）
        movw    len,                    %cx             # 显示的字符个数

draw_a_char:                    
        movsb
        stosb
        loop    draw_a_char

        ret
#+END_SRC

* 引导方式
操作系统运行之前运行的一个Rom程序块，与硬件紧密相连在一起,也叫bootloader。根据不
同的bootloader可以划分为不同的引导方式。引导方式主要有两种：

1、BIOS

2、UEFI

BIOS是早期PC机上使用的引导程序，BIOS与MBR配合是32位计算机的主流。UEFI是BIOS升级
版，增加了对FAT文件系统的支持、安全性能进一步提高，可以说UEFI是一个与固件一体化
的小操作系统。

UEFI与GPT经常配对，实质上两者没有必然联系。可以使用如下UEFI+MBR
UEFI +GPT 、BIOS +GPT 、BIOS+ MBR。
* 文件系统(一个人的家，不同的系统类型表示平民的家或富人的家, 或各类的厂)
** FAT12格式软盘
   对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。
   FAT12是DOS时代就开始使用的文件系统（File System)，直到2009年仍然在软盘上使用。
*** 主磁盘结构
**** 引导扇区（Boot Sector）
     位于第一个扇区，在软盘上就是0柱面（磁道）0磁头1扇区。
     引导扇区格式
  | 名称           | 偏移 | 长度 | 内容                                    | 软盘参考值             |
  | BS_jmpBoot     |    0 |    3 |                                         | jmp LABEL_START nop    |
  | BS_OEMName     |    3 |    8 | 厂商名                                  | 	'ForrestY'           |
  | BPB_BytsPerSec |   11 |    2 | 每扇区字节数 　                         | 	0x200（即十进制512） |
  | BPB_SecPerClus |   13 |    1 | 每簇扇区 　                            | 	0x01                 |
  | BPB_RsvdSecCnt |   14 |    2 | Boot记录占用多少扇区                    | 	0x01                 |
  | BPB_NumFATs    |   16 |    1 | 共有多少FAT表                           | 	0x02                 |
  | BPB_RootEntCnt |   17 |    2 | 根目录文件数最大值                      | 	0xE0 （224）         |
  | BPB_TotSec16   |   19 |    2 | 扇区总数                                | 	0xB40（2880）        |
  | BPB_Media      |   21 |    1 | 介质描述符                              | 0xF0                   |
  | BPB_FATSz16    |   22 |    2 | 每FAT扇区数                             | 	0x09                 |
  | BPB_SecPerTrk  |   24 |    2 | 每磁道扇区数                            | 0x12                   |
  | BPB_NumHeads   |   26 |    2 | 磁头数                                  | 0x02                   |
  | BPB_HiddSec    |   28 |    4 | 隐藏扇区数                              | 	0                    |
  | BPB_TotSec32   |   32 |    4 | 如果BPB_TotSec16是0，由这个值记录扇区数 | 	0xB40（2880）        |
  | BS_DrvNum      |   36 |    1 | 中断13的驱动器号                        | 	0                    |
  | BS_Reserved1   |   37 |    1 | 未使用                                  | 	0                    |
  | BS_BootSig     |   38 |    1 | 扩展引导标记                            | 0x29                   |
  | BS_VolD        |   39 |    4 | 卷序列号                                | 	0                    |
  | BS_VolLab      |   43 |   11 | 卷标                                    | 	'OrangeS0.02'        |
  | BS_FileSysType |   54 |    8 | 文件系统类型                            | 	'FAT12'              |
  | 引导代码       |   62 |  448 | 引导代码、数据及其他填充字符等          |                        |
  | 结束标志       |  510 |    2 |                                         | 	0xAA55               |
 
**** 文件分配表（FAT）
     紧接着引导扇区的是两个完全相同的FAT表，每个FAT表占用9个扇区
     
     它包含有两份文件分配表，这是出于系统冗余考虑，尽管它很少使用，即使是磁盘修
     复工具也很少使用它。它是分区信息的映射表，指示簇是如何存储的。
     
     每个FAT项占12bit，这也所被成为FAT12的原因，FAT项的值代表的是文件下一个簇号，
     但如果值大于等于0xFF8，则表示当前簇已经是本文件的最后一个簇。如果值是0xFF7，
     表示它是一个坏簇。
     
     一个FAT项可能跨越两个扇区，编码实现的过程要考虑在内。 
**** 根目录区
     FAT表之后是根目录区，根目录区长度不固定
     
     根目录区位于第二个FAT表之后，开始扇区号为19，它由若干个目录条目（Directory
     Entry）组成，条目最多有BPB_RootEntCnt个。每个条目占用32个字节，它的格式如
     下： 
 | 名称         | 　　	偏移 | 　　	长度 | 　　	描述                     |
 | DIR_Name     | 　　	0    | 　　	0xB  | 　　	文件名8字节，扩展名3字节 |
 | DIR_Attr     | 　　	0xB  | 　　	1    | 　　	文件属性                 |
 | 保留         | 　　	0xC  | 　　	10   | 　　                           |
 | DIR_WrtTime  | 　　	0x16 | 　　	2    | 　　	最后修改时间             |
 | DIR_WrtDate  | 　　	0x18 | 　　	2    | 　　	最后修改日期             |
 | DIR_FstClus  | 　　	0x1A | 　　	2    | 　　	此条目对应的开始簇号     |
 | DIR_FileSize | 　　	0x1C | 　　	4    | 　　	文件大小                 |
     
**** 数据区
     数据区在根目录区后，数据区开始扇区号为根目录区起始扇区号+根目录区大小，即
     19+BPB_RootEntCnt * 32 / BPB_BytsPerSec。
<!-- GFM-TOC -->
** Ext2文件系统
   当要读取一个文件的内容时，先在 inode 中去查找文件内容所在
   的所有 block，然后把所有 block 的内容读出来。

* 操作系统
** 基本功能
*** 进程管理
    进程控制、进程同步、进程通信、死锁处理、处理机调度等。
*** 内存管理
    内存分配、地址映射、内存保护与共享、虚拟内存等。
*** 文件管理
    文件存储空间的管理、目录管理、文件读写管理和保护等。
*** 设备管理
  完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

  主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
*** 系统调用
  如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系
  统代为完成。

  Linux 的系统调用主要有以下这些：
  | Task     | Commands                    |
  | 进程控制 | fork(); exit(); wait();     |
  | 进程通信 | pipe(); shmget(); mmap();   |
  | 文件操作 | open(); read(); write();    |
  | 设备操作 | ioctl(); read(); write();   |
  | 信息维护 | getpid(); alarm(); sleep(); |
  | 安全     | chmod(); umask(); chown();  |
** 大内核和微内核
*** 大内核
   大内核是将操作系统功能作为一个紧密结合的整体放到内核。
   由于各模块共享信息，因此有很高的性能。
*** 微内核
   由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。
   移出的部分根据分层的原则划分成若干服务，相互独立。

   在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运
   行在内核态，其余模块运行在用户态。

   因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。
** 中断分类
*** 外中断
    由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完
    成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
*** 异常
    由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

    ### 3. 陷入

    在用户程序中使用系统调用。

    # 二、进程管理

    ## 进程与线程

    ### 1. 进程

    进程是资源分配的基本单位。

    进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建
    进程和撤销进程，都是指对 PCB 的操作。

    下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

    <div align="center"> <img
    src="../pics//a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>

    ### 2. 线程

    线程是独立调度的基本单位。

    一个进程中可以有多个线程，它们共享进程资源。

    QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线
    程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，
    浏览器还可以响应用户的其它事件。

    <div align="center"> <img
    src="../pics//3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>

    ### 3. 区别

    Ⅰ 拥有资源

    进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

    Ⅱ 调度

    线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中
    的线程切换到另一个进程中的线程时，会引起进程切换。

    Ⅲ 系统开销

    由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出
    的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程
    CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器
    内容，开销很小。

    Ⅳ 通信方面

    线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

    ## 进程状态的切换

    <div align="center"> <img src="../pics//ProcessState.png" width="500"/>
    </div><br>

    - 就绪状态（ready）：等待被调度
    - 运行状态（running）
    - 阻塞状态（waiting）：等待资源

    应该注意以下内容：

    - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法
      从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完
      之后就会转为就绪状态，等待下一次调度。
    - 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺
      少 CPU 时间会从运行态转换为就绪态。

    ## 进程调度算法

    不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

    ### 1. 批处理系统

    批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从
    提交到终止的时间）。

    **1.1 先来先服务 first-come first-serverd（FCFS）**

    按照请求的顺序进行调度。

    有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，
    而长作业又需要执行很长时间，造成了短作业等待时间过长。

    **1.2 短作业优先 shortest job first（SJF）**

    按估计运行时间最短的顺序进行调度。

    长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，
    那么长作业永远得不到调度。

    **1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

    按估计剩余时间最短的顺序进行调度。

    ### 2. 交互式系统

    交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

    **2.1 时间片轮转**

    将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，
    该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该
    进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

    时间片轮转算法的效率和时间片的大小有很大关系：

    - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程
      切换得太频繁，在进程切换上就会花过多时间。
    - 而如果时间片过长，那么实时性就不能得到保证。

    <div align="center"> <img
    src="../pics//8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>

    **2.2 优先级调度**

    为每个进程分配一个优先级，按优先级进行调度。

    为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

    **2.3 多级反馈队列**

    一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

    多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间
    片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。
    这种方式下，之前的进程只需要交换 7 次。

    每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能
    调度当前队列上的进程。

    可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

    <div align="center"> <img
    src="../pics//042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>

    ### 3. 实时系统

    实时系统要求一个请求在一个确定时间内得到响应。

    分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

    ## 进程同步

    ### 1. 临界区

    对临界资源进行访问的那段代码称为临界区。

    为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

    ```html
    // entry section
    // critical section;
    // exit section
    ```

    ### 2. 同步与互斥

    - 同步：多个进程按一定顺序执行；
    - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

    ### 3. 信号量

    信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P
    和 V 操作。

    -  **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待
       信号量大于 0；
    -  **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

    down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽
    中断。

    如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区
    已经加锁，1 表示临界区解锁。

    ```c
    typedef int semaphore;
    semaphore mutex = 1;
    void P1() {
        down(&mutex);
        // 临界区
        up(&mutex);
    }

    void P2() {
        down(&mutex);
        // 临界区
        up(&mutex);
    }
    ```

    <font size=3> **使用信号量实现生产者-消费者问题** </font> </br>

    问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有
    缓冲区不为空，消费者才可以拿走物品。

    因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

    为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进
    行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数
    量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入
    物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走
    物品。

    注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再
    执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执
    行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为
    生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生
    产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

    ```c
    #define N 100
    typedef int semaphore;
    semaphore mutex = 1;
    semaphore empty = N;
    semaphore full = 0;

    void producer() {
        while(TRUE) {
            int item = produce_item();
            down(&empty);
            down(&mutex);
            insert_item(item);
            up(&mutex);
            up(&full);
        }
    }

    void consumer() {
        while(TRUE) {
            down(&full);
            down(&mutex);
            int item = remove_item();
            consume_item(item);
            up(&mutex);
            up(&empty);
        }
    }
    ```

    ### 4. 管程

    使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码
    独立出来，不仅不容易出错，也使得客户端代码调用更容易。

    c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提
    供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者
    问题。

    ```pascal
    monitor ProducerConsumer
        integer i;
        condition c;

        procedure insert();
        begin
            // ...
        end;

        procedure remove();
        begin
            // ...
        end;
    end monitor;
    ```

    管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不
    能一直占用管程，否者其它进程永远不能使用管程。

    管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操
    作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。
    signal() 操作用于唤醒被阻塞的进程。

    <font size=3> **使用管程实现生产者-消费者问题** </font><br>

    ```pascal
    // 管程
    monitor ProducerConsumer
        condition full, empty;
        integer count := 0;
        condition c;

        procedure insert(item: integer);
        begin
            if count = N then wait(full);
            insert_item(item);
            count := count + 1;
            if count = 1 then signal(empty);
        end;

        function remove: integer;
        begin
            if count = 0 then wait(empty);
            remove = remove_item;
            count := count - 1;
            if count = N -1 then signal(full);
        end;
    end monitor;

    // 生产者客户端
    procedure producer
    begin
        while true do
        begin
            item = produce_item;
            ProducerConsumer.insert(item);
        end
    end;

    // 消费者客户端
    procedure consumer
    begin
        while true do
        begin
            item = ProducerConsumer.remove;
            consume_item(item);
        end
    end;
    ```

    ## 经典同步问题

    生产者和消费者问题前面已经讨论过了。

    ### 1. 读者-写者问题

    允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

    一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于
    对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

    ```c
    typedef int semaphore;
    semaphore count_mutex = 1;
    semaphore data_mutex = 1;
    int count = 0;

    void reader() {
        while(TRUE) {
            down(&count_mutex);
            count++;
            if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
            up(&count_mutex);
            read();
            down(&count_mutex);
            count--;
            if(count == 0) up(&data_mutex);
            up(&count_mutex);
        }
    }

    void writer() {
        while(TRUE) {
            down(&data_mutex);
            write();
            up(&data_mutex);
        }
    }
    ```

    以下内容由 [@Bandi Yugandhar](https://github.com/yugandharbandi) 提供。

    The first case may result Writer to starve. This case favous Writers i.e no
    writer, once added to the queue, shall be kept waiting longer than absolutely
    necessary(only when there are readers that entered the queue before the writer).

    ```source-c
    int readcount, writecount;                   //(initial value = 0)
    semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

    //READER
    void reader() {
    <ENTRY Section>
     down(&readLock);                 //  reader is trying to enter
     down(&rmutex);                  //   lock to increase readcount
      readcount++;                 
      if (readcount == 1)          
       down(&resource);              //if you are the first reader then lock  the resource
     up(&rmutex);                  //release  for other readers
     up(&readLock);                 //Done with trying to access the resource

    <CRITICAL Section>
    //reading is performed

    <EXIT Section>
     down(&rmutex);                  //reserve exit section - avoids race condition with readers
     readcount--;                       //indicate you're leaving
      if (readcount == 0)          //checks if you are last reader leaving
       up(&resource);              //if last, you must release the locked resource
     up(&rmutex);                  //release exit section for other readers
    }

    //WRITER
    void writer() {
      <ENTRY Section>
      down(&wmutex);                  //reserve entry section for writers - avoids race conditions
      writecount++;                //report yourself as a writer entering
      if (writecount == 1)         //checks if you're first writer
       down(&readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
      up(&wmutex);                  //release entry section

    <CRITICAL Section>
     down(&resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
      //writing is performed
     up(&resource);                //release file

    <EXIT Section>
      down(&wmutex);                  //reserve exit section
      writecount--;                //indicate you're leaving
      if (writecount == 0)         //checks if you're the last writer
       up(&readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
      up(&wmutex);                  //release exit section
    }
    ```

    We can observe that every reader is forced to acquire ReadLock. On the
    otherhand, writers doesn’t need to lock individually. Once the first writer
    locks the ReadLock, it will be released only when there is no writer left in the
    queue.

    From the both cases we observed that either reader or writer has to starve.
    Below solutionadds the constraint that no thread shall be allowed to starve;
    that is, the operation of obtaining a lock on the shared data will always
    terminate in a bounded amount of time.

    ```source-c
    int readCount;                  // init to 0; number of readers currently accessing resource

    // all semaphores initialised to 1
    Semaphore resourceAccess;       // controls access (read/write) to the resource
    Semaphore readCountAccess;      // for syncing changes to shared variable readCount
    Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

    void writer()
    { 
        down(&serviceQueue);           // wait in line to be servicexs
        // <ENTER>
        down(&resourceAccess);         // request exclusive access to resource
        // </ENTER>
        up(&serviceQueue);           // let next in line be serviced

        // <WRITE>
        writeResource();            // writing is performed
        // </WRITE>

        // <EXIT>
        up(&resourceAccess);         // release resource access for next reader/writer
        // </EXIT>
    }

    void reader()
    { 
        down(&serviceQueue);           // wait in line to be serviced
        down(&readCountAccess);        // request exclusive access to readCount
        // <ENTER>
        if (readCount == 0)         // if there are no readers already reading:
            down(&resourceAccess);     // request resource access for readers (writers blocked)
        readCount++;                // update count of active readers
        // </ENTER>
        up(&serviceQueue);           // let next in line be serviced
        up(&readCountAccess);        // release access to readCount

        // <READ>
        readResource();             // reading is performed
        // </READ>

        down(&readCountAccess);        // request exclusive access to readCount
        // <EXIT>
        readCount--;                // update count of active readers
        if (readCount == 0)         // if there are no readers left:
            up(&resourceAccess);     // release resource access for all
        // </EXIT>
        up(&readCountAccess);        // release access to readCount
    }

    ```


    ### 2. 哲学家进餐问题

    <div align="center"> <img
    src="../pics//a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

    五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭
    以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起
    一根筷子。

    下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右
    手边的筷子，造成死锁。

    ```c
    #define N 5

    void philosopher(int i) {
        while(TRUE) {
            think();
            take(i);       // 拿起左边的筷子
            take((i+1)%N); // 拿起右边的筷子
            eat();
            put(i);
            put((i+1)%N);
        }
    }
    ```

    为了防止死锁的发生，可以设置两个条件：

    - 必须同时拿起左右两根筷子；
    - 只有在两个邻居都没有进餐的情况下才允许进餐。

    ```c
    #define N 5
    #define LEFT (i + N - 1) % N // 左邻居
    #define RIGHT (i + 1) % N    // 右邻居
    #define THINKING 0
    #define HUNGRY   1
    #define EATING   2
    typedef int semaphore;
    int state[N];                // 跟踪每个哲学家的状态
    semaphore mutex = 1;         // 临界区的互斥
    semaphore s[N];              // 每个哲学家一个信号量

    void philosopher(int i) {
        while(TRUE) {
            think();
            take_two(i);
            eat();
            put_tow(i);
        }
    }

    void take_two(int i) {
        down(&mutex);
        state[i] = HUNGRY;
        test(i);
        up(&mutex);
        down(&s[i]);
    }

    void put_tow(i) {
        down(&mutex);
        state[i] = THINKING;
        test(LEFT);
        test(RIGHT);
        up(&mutex);
    }

    void test(i) {         // 尝试拿起两把筷子
        if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
            state[i] = EATING;
            up(&s[i]);
        }
    }
    ```

    ## 进程通信

    进程同步与进程通信很容易混淆，它们的区别在于：

    - 进程同步：控制多个进程按一定顺序执行；
    - 进程通信：进程间传输信息。

    进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，
    需要让进程进行通信，传输一些进程同步所需要的信息。

    ### 1. 管道

    管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

    ```c
    #include <unistd.h>
    int pipe(int fd[2]);
    ```

    它具有以下限制：

    - 只支持半双工通信（单向交替传输）；
    - 只能在父子进程中使用。

    <div align="center"> <img
    src="../pics//53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

    ### 2. FIFO

    也称为命名管道，去除了管道只能在父子进程中使用的限制。

    ```c
    #include <sys/stat.h>
    int mkfifo(const char *path, mode_t mode);
    int mkfifoat(int fd, const char *path, mode_t mode);
    ```

    FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传
    递数据。

    <div align="center"> <img
    src="../pics//2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>

    ### 3. 消息队列

    相比于 FIFO，消息队列具有以下优点：

    - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产
      生的困难；
    - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
    - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

    ### 4. 信号量

    它是一个计数器，用于为多个进程提供对共享数据对象的访问。

    ### 5. 共享存储

    允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一
    种 IPC。

    需要使用信号量用来同步对共享存储的访问。

    多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存
    不是使用文件，而是使用使用内存的匿名段。

    ### 6. 套接字

    与其它通信机制不同的是，它可用于不同机器间的进程通信。

    # 三、死锁

    ## 必要条件

    <div align="center"> <img
    src="../pics//c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

    - 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
    - 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
    - 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式
      地释放。
    - 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一
      个进程所占有的资源。

    ## 处理方法

    主要有以下四种方法：

    - 鸵鸟策略
    - 死锁检测与死锁恢复
    - 死锁预防
    - 死锁避免

    ## 鸵鸟策略

    把头埋在沙子里，假装根本没发生问题。

    因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

    当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

    大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

    ## 死锁检测与死锁恢复

    不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

    ### 1. 每种类型一个资源的死锁检测

    <div align="center"> <img
    src="../pics//b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

    上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配
    给该进程，进程指向资源表示进程请求获取该资源。

    图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

    每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进
    行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存
    在环，也就是检测到死锁的发生。

    ### 2. 每种类型多个资源的死锁检测

    <div align="center"> <img
    src="../pics//e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

    上图中，有三个进程四个资源，每个数据代表的含义如下：

    - E 向量：资源总量
    - A 向量：资源剩余量
    - C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
    - R 矩阵：每个进程请求的资源数量

    进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程
    P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此
    时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A
    = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

    算法总结如下：

    每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的
    进程都是死锁进程。

    1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
    2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转
       回 1。
    3. 如果没有这样一个进程，算法终止。

    ### 3. 死锁恢复

    - 利用抢占恢复
    - 利用回滚恢复
    - 通过杀死进程恢复

    ## 死锁预防

    在程序运行之前预防发生死锁。

    ### 1. 破坏互斥条件

    例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机
    守护进程。

    ### 2. 破坏占有和等待条件

    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

    ### 3. 破坏不可抢占条件

    ### 4. 破坏环路等待

    给资源统一编号，进程只能按编号顺序来请求资源。

    ## 死锁避免

    在程序运行时避免发生死锁。

    ### 1. 安全状态

    <div align="center"> <img
    src="../pics//ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

    图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示
    还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结
    束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程
    都能成功运行，因此可以称图 a 所示的状态时安全的。

    定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种
    调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

    安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算
    法与死锁检测算法非常类似，可以结合着做参考对比。

    ### 2. 单个资源的银行家算法

    一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求
    的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

    <div align="center"> <img
    src="../pics//d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

    上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

    ### 3. 多个资源的银行家算法

    <div align="center"> <img
    src="../pics//62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

    上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的
    资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个
    为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

    检查一个状态是否安全的算法如下：

    - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生
      死锁，状态是不安全的。
    - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
    - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

    如果一个状态不是安全的，需要拒绝进入这个状态。

    # 四、内存管理

    ## 虚拟内存

    虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

    为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这
    个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到
    连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页
    时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

    从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，
    也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。
    例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算
    机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

    <div align="center"> <img
    src="../pics//7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

    ## 分页系统地址映射

    内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储
    着页（程序地址空间）和页框（物理内存空间）的映射表。

    一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

    下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚
    拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页
    表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页
    框的地址为 （110 000000000100）。

    <div align="center"> <img
    src="../pics//cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>

    ## 页面置换算法

    在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。
    此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

    页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大
    小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓
    存数据。

    页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

    ### 1. 最佳

    > Optimal

    所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

    是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

    举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

    <div align="center"><img src="https://latex.codecogs.com/gif.latex?7，0，1，2，0，
    3，0，4，2，3，0，3，2，1，2，0，1，7，0，1"/></div> <br>

    开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，
    会将页面 7 换出，因为页面 7 再次被访问的时间最长。

    ### 2. 最近最久未使用

    > LRU, Least Recently Used

    虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久
    未使用的页面换出。

    为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面
    移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

    因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

    <div align="center"><img src="https://latex.codecogs.com/gif.latex?4，7，0，7，1，
    0，1，2，1，2，6"/></div> <br>

    <div align="center"> <img
    src="../pics//eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>

    ### 3. 最近未使用

    > NRU, Not Recently Used

    每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置
    M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

    - R=0，M=0
    - R=0，M=1
    - R=1，M=0
    - R=1，M=1

    当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

    NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，
    M=0）。

    ### 4. 先进先出

    > FIFO, First In First Out

    选择换出的页面是最先进入的页面。

    该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

    ### 5. 第二次机会算法

    FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的
    修改：

    当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R
    位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将
    R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继
    续从链表的头部开始搜索。

    <div align="center"> <img
    src="../pics//ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

    ### 6. 时钟

    > Clock

    第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起
    来，再使用一个指针指向最老的页面。

    <div align="center"> <img
    src="../pics//5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

    ## 分段

    虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行
    映射。

    下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系
    统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

    <div align="center"> <img
    src="../pics//22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

    分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，
    并且可以动态增长。

    <div align="center"> <img
    src="../pics//e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

    ## 段页式

    程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的
    页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

    ## 分页与分段的比较

    - 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

    - 地址空间的维度：分页是一维地址空间，分段是二维的。

    - 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

    - 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使
      程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

    # 五、设备管理

    ## 磁盘结构

    - 盘面（Platter）：一个磁盘有多个盘面；
    - 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
    - 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理
      储存单位，目前主要有 512 bytes 与 4 K 两种大小；
    - 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信
      号转换为盘面的磁场（写）；
    - 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
    - 主轴（Spindle）：使整个盘面转动。

    <div align="center"> <img
    src="../pics//014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br>

    ## 磁盘调度算法

    读写一个磁盘块的时间的影响因素有：

    - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
    - 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
    - 实际的数据传输时间

    其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

    ### 1. 先来先服务

    > FCFS, First Come First Served

    按照磁盘请求的顺序进行调度。

    优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

    ### 2. 最短寻道时间优先

    > SSTF, Shortest Seek Time First

    优先调度与当前磁头所在磁道距离最近的磁道。

    虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道
    请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的
    磁道请求更容易出现饥饿现象。

    <div align="center"> <img
    src="../pics//4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br>

    ### 3. 电梯算法

    > SCAN

    电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

    电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方
    向上没有未完成的磁盘请求，然后改变方向。

    因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

    <div align="center"> <img
    src="../pics//271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br>

    # 六、链接

    ## 编译系统

    以下是一个 hello.c 程序：

    ```c
    #include <stdio.h>

    int main()
    {
        printf("hello, world\n");
        return 0;
    }
    ```

    在 Unix 系统上，由编译器把源文件转换为目标文件。

    ```bash
    gcc -o hello hello.c
    ```

    这个过程大致如下：

    <div align="center"> <img
    src="../pics//b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>

    - 预处理阶段：处理以 # 开头的预处理命令；
    - 编译阶段：翻译成汇编文件；
    - 汇编阶段：将汇编文件翻译成可重定向目标文件；
    - 链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到
      最终的可执行目标文件。

    ## 静态链接

    静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。
    链接器主要完成以下两个任务：

    - 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是
      将每个符号引用与一个符号定义关联起来。
    - 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号
      的引用，使得它们指向这个内存位置。

    <div align="center"> <img
    src="../pics//47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>

    ## 目标文件

    - 可执行目标文件：可以直接在内存中执行；
    - 可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文
      件；
    - 共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链
      接；

    ## 动态链接

    静态库有以下两个问题：

    - 当静态库更新时那么整个程序都要重新进行链接；
    - 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

    共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，
    Windows 系统上它们被称为 DLL。它具有以下特点：

    - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文
      件，它不会被复制到引用它的可执行文件中；
    - 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的
      正在运行的进程共享。

    <div align="center"> <img
    src="../pics//76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>

    # 参考资料

    - Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.
    - 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.
    - Bryant, R. E., & O’Hallaron, D. R. (2004). 深入理解计算机系统.
    - 史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014.
    - [Operating System
      Notes](https://applied-programming.github.io/Operating-Systems-Notes/)
    - [Operating-System
      Structures](https://www.cs.uic.edu/\~jbell/CourseNotes/OperatingSystems/2_Structures.html)
    - [Processes](http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php)
    - [Inter Process Communication
      Presentation[1]](https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1)
    - [Decoding UCS Invicta – Part
      1](https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1)
* ubuntuOS (用OS程序控制设备)
** 设备  
*** CPU（含 加法器设备，传送带设备，跳转设备) 
*** 放东西的空间（寄存器，内存，硬盘)
*** 状态显示设备（显示器)
*** 状态改变设备（键盘鼠标)
** 程序
*** BIOS基础控制程序 
*** 操作系统软件
** 工具 
   编译器: nasm gas 创造程序的东西
   连接器: ld  合并程序，创造各格式的程序的东西
   构建工具： make 构建大程序的东西
   磁盘创建工具: dd 创建磁盘的东西
   磁盘挂载工具: mount 磁盘设备读取工具
** 做一个显示功能的假的操作系统 , 显示 hello, world!并且是fat12格式的软盘

  
