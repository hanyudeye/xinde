* 计算机操作系统                                                       :系统:
** 系统基本功能 
*** 进程管理
    进程控制、进程同步、进程通信、死锁处理、处理机调度等。
*** 内存管理
   内存分配、地址映射、内存保护与共享、虚拟内存等。

*** 文件管理
   文件存储空间的管理、目录管理、文件读写管理和保护等。

*** 设备管理
   完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
   主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
** 系统调用
   Linux 的系统调用主要有以下这些：
| Task     | Commands                    |
| :---:    | ---                         |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |
* make os in ubuntu
** 环境准备[[file:shellcmd.org][cmd]] 
*** os系统软件 
    代码
    编译器 nasm gas
*** 虚拟机 qemu file:shellcmd.org::qemu
*** 虚拟磁盘 dd
*** 硬件 u盘
** 构建
*** nasm bootstrap.asm -o boot.img 
    [[file:~/project/os/da/bootstrap.asm][bootstrap]] 
** 运行
   qemu-system-i386 -fda boot.img
   qemu-system-x86_64 -hda boot.img

   都可以
** 构建软盘
   dd if=/dev/zero of=boot.img seek=1 count=2879
   构建软盘后直接可以运行
*** 软盘参数 
   80个柱面，cylinder
   18个扇区，sector
   2个磁头，head
   2x80x18x512bytes=80x18kbytes=1440kB
*** 写入U盘
    sudo dd if=$(bootstrap) of=/dev/sdb
    优盘启动
    sudo qemu   -drive file=/dev/sdb,if=floppy
*** 挂载软盘
    sudo mount -t msdos -o loop,fat=12   boot.img /mnt 
** 自动构建文件 Makefile 
  选择文件 make -f Makefile  
   #+BEGIN_SRC makefile
     src=boot.asm
     bootstrap=boot.img
     boot.img:boot.asm
       nasm $(src) -o $(bootstrap)
     fat12:
       @dd if=/dev/zero of=$(bootstrap) seek=1 count=2879 >> /dev/zero
       @ls -al $(bootstrap)
     loop:fat12
       sudo umount /mnt
       sudo mount -t msdos -o loop,fat=12 $(bootstrap) /mnt
     run: boot fat12
       qemu-system-i386 -fda $(bootstrap)
   #+END_SRC
** Gas语法
  [[file:~/project/os/da/boot.S][boot.s]] 
  1：首先將hello.S作为输入，使用gcc將汇编程序编译为hello.o的object程序。

  (注意：上面的-m32是不能少的，告诉编译器产生machine 32bit的代码，但是在我们汇编程
  序hello.S中有.code16的字样，就是告诉编译器产生16位的汇编。因为 gnu的汇编器太强大
  了，可以很方便的产生16位和32位的汇编，而日本人书里面用了两种汇编器就是因为nasm汇
  编器无法产生32位的汇编程序。所以问题在他那里就搞复杂了，用到了两种工具）

  2：然后ld这个链接器（linker)將hello.o这个obj文件链接成为boot.elf的elf文件，-e 是
  指定汇编程序的入口，-Ttext 0x7c00是指定程序运行时的地址。

  3：objcopy是將生成了boot.elf文件中的有用程序代码段.text提取出来，生成真正的512字
  节的启动扇区程序boot.out。

  4：objdump是为了以后写大的程序时，观察程序反汇编后是什么情况，生成了有帮助意义的
  boot.asm汇编程序。
** u盘读取扇区
  #+BEGIN_SRC asm
    .global start
    .code16
    start:
        jmp entry
        /*定义fat12文件格式*/
        .byte 0x00
        .ascii "helloOSX"
        .word  512
        .byte  1
        .word  1
        .byte  2
        .word  224
        .word  2880
        .byte  0xf0
        .word  9
        .word  18
        .word  2
        .long  0
        .long  2880
        .byte  0,0,0x29
        .long  0xffffffff
        .ascii  "myosudisk  "
        .ascii  "fat12   "
        .fill 18

    entry:
        mov $0,%ax
        mov %ax,%ds
        mov %ax,%es
        mov %ax,%ss
        mov $0x7c00,%sp
        mov %dl,(0x7dfe)

        mov $msg,%si
        call puts
        mov $my,%si
        call puts

    /*memory=0x8200,chs=002*/
        mov $0x820,%ax
        mov %ax,%es
        mov $0x00,%bx
        mov $0x00,%ch
        mov $0x00,%dh
        mov $0x02,%cl
        call read
        mov $okmsg,%si
        call puts

    loop:
        jmp loop

    read:
        mov (0x7dfe),%dl
        //mov $0x00,%dl
        mov $0x02,%ah
        mov $0x01,%al
        int $0x13
        jc error
        ret

    error:
        mov $errormsg,%si
        call puts
        hlt
        //ret
        jmp loop

    /*
    this is a subfunction to display string
    usage: mov $address,%si
           call puts
    or     mov $label,%si
           call puts
    ,*/
    puts:
      movb (%si),%al
      add $1,%si
      cmp $0,%al
      je finish
      movb $0x0e,%ah
      movw $15,%bx
      int $0x10
      jmp puts
    finish:
      ;hlt
      ret

    msg:
      .asciz "\r\nmy bootloader is running"
    my:
        .asciz "\r\nwelcome to our course "

    errormsg:
        .asciz "\r\nread u flash failed "

    okmsg:
        .asciz "\r\nread  u disk of 2 sector, ok "

    .org 510
    .word 0xaa55

  #+END_SRC
1:u盘的driver number是多少，dl=??

其实读u盘的第二扇区和读软盘没有什么区别，唯一的不同是我们需要知道u盘的
drive number。在调用0x13中断时，dl需要指定一个正确的driver number。从书
本上我们知道软盘的driver number是0x00，但是u盘的drive number是多少？只要
知道了这个driver number,我们就可以读取 u盘的第二个扇区到内存了。

从上面的代码中，可以看到有这样一条代码：

mov %dl,(0x7dfe)

不知道大家看懂了没有，其实当bios在读取u盘的512个字节时，已经把u盘的drive
number保存到了dl中，我们所做的只是把dl中已经保存的关于u盘的drive number,
保存到了内存的0x7dfe处。到后面读u盘，调用int 0x13中断，需要给dl赋值为u盘
drive number时，再从0x7dfe内存地址把drive number读到dl寄存器中，如下图中
所看到，这样就可以正确的读取u盘的第二个扇区了，因为我们得到u盘的drive
number。



** Linux(ubuntu)下30天自制os学习引导，第3.1天(如何得到 u盘的chs结构）
 上文已经讲了如何得到u盘的drive number,但是且得到这一参数，还不足够实现对u盘的多个扇区的读取，因为你还不知道u盘的一个cylinder有多少个扇区。所以本节就来解决这样的问题，通过调用 Int 13/AH=08h中断，可以知道得到有关u盘的chs结构。

        程序比较容易，只是在写显示寄存器上的二进制时，花了一点时间 。大家只需要把
        程序下载下来，编译后写到 u盘上运行一下就可以知道自己u盘的chs结构了。下面
        对Int 13/AH=08h这个中断进行简单介绍

 程序伪代码如下：

 ah=0x08
 
 dl=drive number
 
 int 0x13
 而关于u盘的chs的值则存在于dx,cx中：

 dh=max head number（最大的磁头数，对于软盘则是1）

 dl=number of drivers(有多少存储个盘，如果只有一个硬盘,就会显示1)

 cl=maximum sector number (bits 5-0)  (最大扇区数，注意只有这个字节的 低6位,高2位为cylinder的高2位）

 ch=low eight bits of maximum cylinder number(这个是关于u盘的磁道数，对于软盘则是79）

 上面这样说明，可能没有画图直观，博主在下面画一个图，更清楚的说明上面参数的意思



 上图可以清楚的知道我们的u盘的chs数，下面从运行程序得到数字来看看这样计算是否正常，先上一个qemu模拟软盘时，得到的chs值，因为软盘大家都比较清楚 。



 从上图二进制数字中，可以看到软盘的 drive number=dl=0x00

 dh代表head 的最的大max number,所以是1 (上图标错了)

 cl的低6位代表最大的扇区数，cl=0b 010010 =18

 而关于cylinder的数字则是上图中黄色字样： 0b 00  01001111,大家可以把二进制转换成16进制看看，正好是64+15=79



         因为cylinder 和head数是从0开始,而扇区数是从1开始 ，所以 软盘的大小正好是cxhxs=(79+1)x(1+1)x18扇区数

 通过上面的分析，大家应该知道怎么使用这个中断得到u盘的chs了，下面上一张从u盘启动时，显示的chs的结果的图片，有时间的读者可以分析一下，博主的这个u盘的大小。



 程序就不在这里上了，代码有点多，大家可以到百度云盘上云下载，目录为AboutUSB,运行程序的步骤也有说明


 好吧，下节再见！有问题记得加群交流哦！be relax!
** 上节我们讲了，通过通过调用 Int 13/AH=08h中断，可以得到u盘chs结构的数据信息，程序博主已经上传到百度云了，有兴趣的读者可以下载下来，将程序编译后，写到u盘中，然后从u盘启动（真机启动，或是用qemu从u盘启动都可以）。

 下面是博主的两个u盘的chs结构，大家可以看看。    



 大家可以发现,u盘每个 cyliner的扇区数都是从第1到第63,

 而博主8GB的u盘的head是从0到254,

            2GB的u盘的head是0到63

 因为《30天自制os》的作者只读了软盘的10个cylinder，软盘10个cylinder的大小是10x2x18x512=180KB

 如果我们要用u盘，那也只需要读180KB的内容到内存的0x8000就可以了，

 计算一下：6x63x512=189kB ，所以我们只需要读u盘的6个head大小，就可以满足要求了。

 伪代码如下：



  for(head=0;head<6;head++)
  {<pre name="code" class="plain">  for(sector=1;sector<64;sector++)
  {
 ah=0x02 al=0x01 int 0x13 }}
 当然，上面是用c写的伪代码，下面我把gnu格式的汇编代码贴出来，但是整个，工程包含makefile的文件，请大家都网盘自行下载，就不一一贴出来了，有问题群内交流。

 .global start
 .code16
 start:

     jmp entry
     /*定义fat12文件格式*/
     .byte 0x00
     .ascii "helloOSX"
     .word  512
     .byte  1
     .word  1
     .byte  2
     .word  224
     .word  2880
     .byte  0xf0
     .word  9
     .word  18
     .word  2
     .long  0
     .long  2880
     .byte  0,0,0x29
     .long  0xffffffff
     .ascii  "myosudisk  "
     .ascii  "fat12   "
     .fill 18


 entry:
     mov $0,%ax
     mov %ax,%ds
     mov %ax,%es
     mov %ax,%ss
     mov $0x7c00,%sp
     mov %dl,(0x7dfe)
 /*显示一些*/
     mov $msg,%si
     call puts
     mov $my,%si
     call puts
 /*memory=0x8200,chs=002*/
     mov $0x800,%ax
     mov %ax,%es
     mov $0x00,%bx

     mov $0x00,%ch
     mov $0x00,%dh
     mov $0x01,%cl
 //读取18个扇区数
 readloop:
     mov $0x00,%si    /*记住扇区读失败的次数*/
     call read

     mov %es,%ax
     add $0x0020,%ax
     mov %ax,%es
     add $0x01,%cl
     cmp $63,%cl
     jbe readloop
     //63个扇区读完了，可以chs中 h++了
     mov $0x01,%cl  //扇区从1开始
     add  $0x01,%dh
     cmp  $0x6,%dh
     jb readloop
     jmp haha
     mov $errormsg,%si
     call puts

 loop:
     jmp loop

 haha:
    mov $msgusb,%si
    call puts
    jmp loop

 msgusb:
	 .asciz "\r\nlast sector of usb read ok"



 /*读一个扇区的子程序*/
 read:
     mov (0x7dfe),%dl
     //mov $0x00,%dl
     mov $0x02,%ah   //read
     mov $0x01,%al   //one sector
     int $0x13
     jnc over        //没有进位就成功了，有进位就会需要重新读取
     add $0x01,%si
     cmp $0x05,%si
     jae error
     mov $0x00,%ah
     mov $0x00,%dl
     int $0x13
     jmp read
 over:
     ret


 error:
     mov $errormsg,%si
     call puts
     jmp loop

 /*
 this is a subfunction to display string
 usage: mov $address,%si
        call puts
 or     mov $label,%si
        call puts
 */
 puts:
   movb (%si),%al
   add $1,%si
   cmp $0,%al
   je finish
   movb $0x0e,%ah
   movw $15,%bx
   int $0x10
   jmp puts
 finish:
   ;hlt
   ret


 msg:
	 .asciz "\r\nmy bootloader is running"
 my:
     .asciz "\r\nwelcome to our course "

 errormsg:
     .asciz "\r\nread u flash failed "

 okmsg:
     .asciz "\r\nread  u disk of  180kB, ok "

 .org 510
 .word 0xaa55
 上面的程序，重点看博主是如何读取u盘的 6x63x512=189kB的内容到u盘的，有几点补充讲下：
 1：程序把 u盘的 chs=0 0 1到 0 5 63的内容复制到了 内存起点的0x8000的位置

 2：如果读取u盘的程序成功，就会显示“last sector of usb read ok"

 3:程序中得到u盘的drive numbe的方法，先把bios程序之前保存在dl中的drive number保存到内存的 0x7dfe处，

 等需要用到 u盘的drive number时，再从内存的这个位置读出来，

  mov %dl,(0x7dfe)
 读内存中保存的u盘的drive number到寄存器dl


  mov (0x7dfe),%dl

 好了，整个程序也没有其它的难点，大家看下来，应该也没有其它吃力的地方。

 如果大家能够自由的读取u盘的任何扇区，那么在后面自己学习这本书时，就完全可以从u盘启动，最大的好处，就是可以从真实的电脑启动自己的程序，以后把这本书学完了后，学习linux内核时，也更容易做各类实验，因为有时候我们还是不太相信虚拟机的。





 后面的课程中,我们就需要跳转到另一个汇编程序,我们称为head.S,然后在head.S中完成过渡到32位模式,并跳转到c函数继续我们的学习过路.

 今天就到这里，博主已经学习完了11天了，上面是11天的代码从u盘启动的情况 。有问题记得交流哦。



 以后的程序不再往百度云盘上存放，直接放到github上管理了，代码已经更新到了14天部分。

 github的使用可能对于新手来说有点拿，但这个代码管理工具对于一个专业的程序员来说是不可少的。

 github的学习如Linux这个系统一样，虽然学起来难，但是一旦学会了，你会发现这是管理代码的神器，当然只是博主用了大约两个星期的感觉。

 30天 github的地址：https://github.com/cherishsir/ubuntu230os

 如果读者现在已经走了使用ubuntu的道路，非常好，只要使用下面的命令就可以把github上的所有代码下载到你的电脑上了。



 1：首先，安装git工具：sudo apt-get install git

 2:然后，下载github上的30os的源代码：git clone https://github.com/cherishsir/ubuntu230os.git

 有没有感觉到github对于管理代码的强大，还没有？？？放心，工具这事，你要用一段时间才会有这要的感觉。坚持用LInux半年后，你同样会爱上这个系统，因为他真的很高效，方便无比。加油吧！！


 
 --------------------- 
 作者：cherishsir 
 来源：CSDN 
 原文：https://blog.csdn.net/cherishsir/article/details/29368655 
 版权声明：本文为博主原创文章，转载请附上博文链接！
** qemu调试内核需知，中断查询网页

 qume内核调试技术总结：

  1：动行qemu后，ctr+alt+2打开qemu monitor console

  2：查看内存里面的数据,比如我们要查看内存0x7dfe的数据，输入下面的命令


 xp /1x 0x7dfe

  3：查看寄存器的值 

 info registers
  4：查看有哪些命令


 info
  5：查看具体哪一个寄存器，如查看ax ,  


 print    $eax
  6：退出qemu 

 quit

 7:对操作系统启动方式的模式
 从硬盘启动

 qemu   -drive file=os.img
 从软盘启动


 qemu   -drive file=os.img,if=floppy
* elf
** ELF32文件结构
#+BEGIN_SRC c
#define EI_NIDENT    16
typedef struct elf32_hdr{
  unsigned char    e_ident[EI_NIDENT];  //开始的16个字节
  Elf32_Half    e_type;  //文件类型
  Elf32_Half    e_machine;  //运行的机器类型
  Elf32_Word    e_version;  //版本
  Elf32_Addr    e_entry;  //程序入口地址
  Elf32_Off    e_phoff;  //程序头表在文件中的偏移
  Elf32_Off    e_shoff;  //节头表在文件中的偏移
  Elf32_Word    e_flags;  //标记
  Elf32_Half    e_ehsize;  //elf文件头大小
  Elf32_Half    e_phentsize;  //程序头表项的大小
  Elf32_Half    e_phnum;  //程序头表中表项项的个数
  Elf32_Half    e_shentsize;  //节头表项大小
  Elf32_Half    e_shnum;  //节头表中表项的个数
  Elf32_Half    e_shstrndx;  //节头表的字符串节所在节头表中下标
} Elf32_Ehdr;
#+END_SRC
节头表项对应的代码定义为：
#+BEGIN_SRC c
typedef struct elf32_shdr {
  Elf32_Word    sh_name;  //节的名字，在符号表中的下标
  Elf32_Word    sh_type;  //节的类型，描述符号，代码，数据，重定位等
  Elf32_Word    sh_flags;  //读写执行标记
  Elf32_Addr    sh_addr;  //节在执行时的虚拟地址
  Elf32_Off    sh_offset;  //节在文件中的偏移量
  Elf32_Word    sh_size;  //节的大小
  Elf32_Word    sh_link;  //其它节的索引
  Elf32_Word    sh_info;  //节的其它信息
  Elf32_Word    sh_addralign;  //节对齐
  Elf32_Word    sh_entsize;  //节拥有固定大小项的大小
} Elf32_Shdr;
#+END_SRC
: jmp汇编 的是偏移地址,我们写是写绝对地址
#+TITTLE: int中断
** int 10 显示中断
#+CAPTION: 
|  AH | 功能                       | 调用参数                               | 返回参数                        |
|-----+----------------------------+----------------------------------------+---------------------------------|
|   0 | 设置显示模式               | AL = video mode                        | AL = video mode flag  mode byte |
|     |                            | 模式碼 (正常為 03h)                    |                                 |
|     |                            | 00H: 40*25 16 色 8 頁 B8000H~B87CFH    | 文字模式                        |
|     |                            | 01H: 80*25 16 色 8 頁 B8000H~B87CFH    |                                 |
|     |                            | 02H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 03H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 07H: 80*25 2 色 8 頁 B8000H~B8F9FH     |                                 |
|     |                            | 04H: 320*200 4 色 1 頁 B8000H~BBF3FH   | 绘图模式                        |
|     |                            | 05H: 320*200 4 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 06H: 640*200 2 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 0DH: 320*200 16 色 8 頁 A0000H~A1F3FH  |                                 |
|     |                            | 0EH: 640*200 16 色 4 頁 A0000H~A3E7FH  |                                 |
|     |                            | 0FH: 640*350 2 色 2 頁 A0000H~A6D5FH   |                                 |
|     |                            | 10H: 640*350 16 色 2 頁 A0000H~A6D5FH  |                                 |
|     |                            | 11H: 640*480 2 色 1 頁 A0000H~A95FFH   |                                 |
|     |                            | 12H: 640*480 16 色 1 頁 A0000H~A95FFH  |                                 |
|     |                            | 13H: 320*200 256 色 1 頁 A0000H~AF9FFH |                                 |
|   1 | 置光标类型                 | (CH)0―3 = 光标开始行                  |                                 |
|     |                            | (CL)0―3 = 光标结束行                  |                                 |
|   2 | 置光标位置                 | BH = 页号                              |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   3 | 读光标位置                 | BH = 页号                              |                                 |
|     |                            | CH = 光标开始行                        |                                 |
|     |                            | CL = 光标结束行                        |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   4 | 读光笔位置                 |                                        | AH=0 光笔未触发                 |
|     |                            |                                        | AH=1 光笔触发                   |
|     |                            |                                        | CH=象素行                       |
|     |                            |                                        | BX=象素列                       |
|     |                            |                                        | DH=字符行                       |
|     |                            |                                        | DL=字符列                       |
|     |                            |                                        |                                 |
|   5 | 显示页                     | AL = 显示页号                          |                                 |
|   6 | 屏幕初始化或上卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   7 | 屏幕初始化或下卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   8 | 读光标位置的属性和字符     | BH = 显示页                            | AH = 属性                       |
|     |                            |                                        | AL = 字符                       |
|   9 | 在光标位置显示字符及其属性 | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | BL = 属性                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   A | 在光标位置只显示字符       | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   E | 显示字符(光标前移)         | AL = 字符                              |                                 |
|     |                            | BL = 前景色                            |                                 |
| 13h | 显示字符串                 | ES:BP = 串地址                         |                                 |
|     |                            | CX = 串长度                            |                                 |
|     |                            | DH=row， DL = 起始行列                 |                                 |
|     |                            | BH = 页号                              |                                 |
|     |                            | AL = writemode，BL = 属性/颜色         |                                 |

** int 13 磁盘中断
#+CAPTION:  int 13 磁盘操作
| AH  | 功能                  | 调用参数                                  | 返回参数                                     |
| 00  | 磁盘系统复位          | DL＝驱动器                                | CF＝0——操作成功，AH＝00H                     |
|     |                       | 00H~7FH：软盘                             | 否则，AH＝状态代码                           |
|     |                       | 80H~0FFH：硬盘                            |                                              |
| 01  | 读取磁盘系统状态      | DL＝驱动器                                | AH＝00H，AL＝状态代码，其定义如下：          |
|     |                       | 00H~7FH：软盘                             | 00H — 无错                                   |
|     |                       | 80H~0FFH：硬盘                            | 01H — 非法命令                               |
|     |                       |                                           | 02H — 地址目标未发现                         |
|     |                       |                                           | 03H — 磁盘写保护(软盘)                       |
|     |                       |                                           | 04H — 扇区未发现                             |
|     |                       |                                           | 05H — 复位失败(硬盘)                         |
|     |                       |                                           | 06H — 软盘取出(软盘)                         |
|     |                       |                                           | 07H — 错误的参数表(硬盘)                     |
|     |                       |                                           | 08H — DMA越界(软盘)                          |
|     |                       |                                           | 09H — DMA超过64K界限                         |
|     |                       |                                           | 0AH — 错误的扇区标志(硬盘)                   |
|     |                       |                                           | 0BH — 错误的磁道标志(硬盘)                   |
|     |                       |                                           | 0CH — 介质类型未发现(软盘)                   |
|     |                       |                                           | 0DH — 格式化时非法扇区号(硬盘)               |
|     |                       |                                           | 0EH — 控制数据地址目标被发现(硬盘)           |
|     |                       |                                           | 0FH — DMA仲裁越界(硬盘)                      |
|     |                       |                                           | 10H — 不正确的CRC或ECC编码                   |
|     |                       |                                           | 11H — ECC校正数据错(硬盘)                    |
|     |                       |                                           | 20H — 控制器失败                             |
|     |                       |                                           | 40H — 查找失败                               |
|     |                       |                                           | 80H — 磁盘超时(未响应)                       |
|     |                       |                                           | AAH — 驱动器未准备好(硬盘)                   |
|     |                       |                                           | BBH — 未定义的错误(硬盘)                     |
|     |                       |                                           | CCH — 写错误(硬盘)                           |
|     |                       |                                           | E0H — 状态寄存器错(硬盘)                     |
|     |                       |                                           | FFH — 检测操作失败(硬盘)                     |
| 02H | 读扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | (#驱动器,相当于哪块磁盘)        |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 03H | 写扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 04H | 检验扇区              | AH＝04H                                   | CF＝0——操作成功，AH＝00H，AL＝被检验的扇区数 |
|     |                       | AL＝扇区数                                | 否则，AH＝状态代码                           |
|     |                       | CH＝柱面                                  |                                              |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 05H | 格式化磁道            | AL＝交替(Interleave)                      | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 06H | 格式化坏磁道          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 07H | 格式化驱动器          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 08H | 读取驱动器参数        | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | CF＝1——操作失败，AH＝状态代码                |
|     |                       |                                           | 否则， BL＝01H — 360K                        |
|     |                       |                                           | ＝02H — 1.2M                                 |
|     |                       |                                           | ＝03H — 720K                                 |
|     |                       |                                           | ＝04H — 1.44M                                |
|     |                       |                                           | CH＝柱面数的低8位                            |
|     |                       |                                           | CL的位7-6＝柱面数的高2位                     |
|     |                       |                                           | CL的位5-0＝扇区数                            |
|     |                       |                                           | DH＝磁头数                                   |
|     |                       |                                           | DL＝驱动器数                                 |
|     |                       |                                           | ES:DI＝磁盘驱动器参数表地址                  |
| 09H | 初始化硬盘参数        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H否则                 |
|     |                       |                                           | AH＝状态代码，参见功能号01H中的说明          |
| 0AH | 读长扇区, 每个扇区    | AL＝扇区数                                |                                              |
|     | 随带四个字节的ECC编码 | CH＝柱面                                  | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CL＝扇区                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0BH | 写长扇区，每个扇区随  | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     | 带四个字节的ECC编码   | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0CH | 查寻                  | CL(7-6位)＝柱面的高2位                    | CF＝0——操作成功，AH＝00H，                   |
|     |                       | DH＝磁头                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 0DH | 硬盘系统复位          | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 0EH | 读扇区缓冲区          | ES:BX＝缓冲区的地址                       | 出口参数：CF＝0——操作成功                    |
| 0FH | 写扇区缓冲区          | ES:BX＝缓冲区的地址                       | CF＝0——操作成功                              |
| 10H | 读取驱动器状态        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H                     |
| 11H | 校准驱动器            | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 12H | 控制器RAM诊断         |                                           | CF＝0——操作成功，....                        |
| 13H | 控制器驱动诊断        |                                           | CF＝0——操作成功，否则，...                   |
| 14H | 控制器内部诊断        |                                           | CF＝0——操作成功，否则                        |
| 15H | 读取磁盘类型          | DL＝驱动器，00H~7FH：软盘；               | CF＝1——操作失败，AH＝状态代码                |
|     |                       | 80H~0FFH：硬盘                            | AH＝00H — 未安装驱动器                       |
|     |                       |                                           | ＝01H — 无改变线支持的软盘驱动器             |
|     |                       |                                           | ＝02H — 带有改变线支持的软盘驱动器           |
|     |                       |                                           | ＝03H — 硬盘，CX:DX＝512字节的扇区数         |
| 16H | 读取磁盘变化状态      | DL＝00H~7FH：软盘                         | CF＝0——磁盘未改变，AH＝00H                   |
|     |                       |                                           | 否则，AH＝06H，参见功能号01H中的说明         |
| 17H | 设置磁盘类型          | DL＝00H~7FH：软盘 AL＝00H — 未用          | CF＝0——操作成功，AH＝00H，                   |
|     |                       | ＝01H — 360K在360K驱动器中                | 否则，AH＝状态编码，参见功能号01H中的说明    |
|     |                       | ＝02H — 360K在1.2M驱动器中                |                                              |
|     |                       | ＝03H — 1.2M在1.2M驱动器中                |                                              |
|     |                       | ＝04H — 720K在720K驱动器中                |                                              |
| 18H | 设置格式化媒体类型    | CH＝柱面数                                | CF＝0——操作成功，AH＝00H，                   |
|     |                       | CL＝每磁道的扇区数                        | ES:DI＝介质类型参数表地址，                  |
|     |                       | DL＝00H~7FH：软盘                         | 否则，AH＝状态编码，参见功能号01H中的说明    |
| 19H | 磁头保护，仅在PS/2    |                                           |                                              |
| 1AH | 格式化ESDI驱动器      | 仅在PS/2中有效，在此从略                  |                                              |

** int 16 键盘中断
| AH  | 功能                                | 调用参数                           | 返回值                           |
| 00H | 读取键盘输入                        |                                    | AL 字符的ASCII                   |
|     | 按键按下才返回                      |                                    | AH 扫描码                        |
| 01H | 确认键盘键入字符                    |                                    | AL 字符的ASCII                   |
|     |                                     |                                    | AH Scan code                     |
|     |                                     |                                    | ZF=1 未键入字符,无返回           |
|     |                                     |                                    | ZF=0 NZ,返回上面的               |
| 02H | Return shift-flag status            |                                    | AL Current shift status          |
|     |                                     |                                    | 7 6 5 4 3 2 1 0                  |
|     |                                     |                                    | Ins,Capa,Num,Scrol,Alt,C,左S,右S |
| 03H | Set typematic rate and delay        | AL 05 (subfunction number)         |                                  |
|     |                                     | BL 00H through 1FH, typematic rate |                                  |
|     |                                     | (30 charßsec to 2 char/sec)        |                                  |
|     |                                     | BH Delay rate:                     |                                  |
|     |                                     | 00h = 250 ms                       |                                  |
|     |                                     | 01h = 500 ms                       |                                  |
|     |                                     | 02h = 750 ms                       |                                  |
|     |                                     | 03h = 1000 ms                      |                                  |
|     |                                     | 04h to 07h = Reserved              |                                  |
| 05h | Add key to Keyboard buffer          | CL ASCII code                      | If Carry = 1:                    |
|     |                                     | CH Scan code                       | AL Keyboard buffer full          |
| 10h | Read extended character from buffer |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
| 11h | Return extended buffer status       |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
|     |                                     |                                    | ZF No keystroke available        |
|     |                                     |                                    | NZ Keystroke in buffer           |
| 12h | Return extended shift status        |                                    | AL Shift status:                 |
|     |                                     |                                    | Bit 7 1 = Sys Req pressed        |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Right Alt active       |
|     |                                     |                                    | Bit 2 1 = Right Ctrl active      |
|     |                                     |                                    | Bit 1 1 = Left Alt active        |
|     |                                     |                                    | Bit 0 1 = Left Ctrl active       |
|     |                                     |                                    | AH Extended shift status:        |
|     |                                     |                                    | Bit 7 1 = Insert active          |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Alt pressed            |
|     |                                     |                                    | Bit 2 1 = Ctrl pressed           |
|     |                                     |                                    | Bit 1 1 = Left Shift pressed     |
|     |                                     |                                    | Bit 0 1 = Right Shift pressed    |

** example
INT 0x10功能0x13
描述：
        以电传打字机的方式显示字符串
接受参数：
        AH                      0x13
        AL                      显示模式
        BH                      视频页
        BL                      属性值（如果AL=0x00或0x01）
        CX                      字符串的长度
        DH,DL           屏幕上显示起始位置的行、列值
        ES:BP           字符串的段:偏移地址
返回值：
        无
显示模式（AL）：
        0x00:字符串只包含字符码，显示之后不更新光标位置，属性值在BL中
        0x01:字符串只包含字符码，显示之后更新光标位置，属性值在BL中
        0x02:字符串包含字符码及属性值，显示之后不更新光标位置
        0x03:字符串包含字符码及属性值，显示之后更新光标位置

# A bootsect, which print a string by BIOS interrupt video services(int 0x10)

#+BEGIN_SRC asm -n -r
.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $msgstr,%bp
        movw    len,    %cx
        movb    $0x05,  %dh
        movb    $0x08,  %dl
        movb    $0x01,  %al
        movb    $0x13,  %ah
        movb    $0x01,  %bl
        movb    $0x00,  %bh

        int             $0x10
1:
        jmp             1b

msgstr:
        .asciz  "Hello babyos(print by BIOS int 0x10:0x13, mode 0x01)!"
len:
        .int    . - msgstr

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC
makefile:

#+BEGIN_SRC makefile -n -r
all: boot.img

boot.o: boot.s
        as -o $@ $<

boot: boot.o
        ld --oformat binary -N -Ttext 0x7c00 -o $@ $<

boot.img: boot
        dd if=boot of=boot.img bs=512 count=1

clean:
        rm ./boot ./boot.img ./boot.o
#+END_SRC
2.通过功能号0x09探究色彩控制
上面的显示为什么是红色呢？我们可以通过实验来看一下颜色控制

------------------------------------------------------------------------
                        INT 0x10功能0x09
-------------------------------------------------------------------
描述：
        显示字符并设置其属性
接受参数：
        AH                      0x09
        AL                      字符的ASCII码
        BH                      视频页
        BL                      属性值
        CX                      重复次数
返回值：
        无
注意：
        在显示字符之后并不前进光标。在文本和图形模式下均可调用该功能
        显示完字符后，如果还要继续显示字符，必须调用INT 0x10功能0x02前进光标
-------------------------------------------------------------------------

------------------------------------------------------------------------
                        INT 0x10功能0x02
-------------------------------------------------------------------
描述：
        把光标定位在选定视频页的特定行列位置
接受参数：
        AH                      0x02
        DH，DL          行、列值
        BH                      视频页
返回值：
        无
注意：
        在80x25模式下，DH范围0～24，DL范围0～79
-------------------------------------------------------------------------

示例：

实现一个从第4行～7行，第8列～71列，显示‘A’～‘Z’的程序，共显
示256个字符，使用BL（0～255）

: C 伪代码：

#+BEGIN_SRC C  -n -r
cx = 0x04;
bh = 0x00;

dh = 0x04;
dl = 0x08;
al = 'A';

for (bl = 0; bl < 256; bl++)
{
        print_char();
        
        al++;
        if (al == 'Z')
                al = 'A';
        
        dl++;
        if (dl == 72)
        {
                dh++;
                dl = 4;
        }
        
        set_cursor();
}

#+END_SRC
汇编代码：

#+BEGIN_SRC  asm -n -r
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char
        incb    %al
        cmpb    $'Z',   %al
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl
        cmpb    $72,    %dl
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor
        incb    %bl
        cmp             $256,   %bl
        jne             1b
        jmp             1f

print_char:
        movb    $0x09,  %ah
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC

结果：
[1356282645]

可以显式地验证色彩控制BL：

| 7    | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| I    | R | G | B | I | R | G | B |
| 闪烁 | R | G | B | I | R | G | B |
如上图所示，7～4位为背景色，I表示高亮，RGB表示红绿蓝，若显
卡支持闪烁，则位7表示是否闪烁。
色彩混合：
----------------------------------------------
| 混合的三种基色 | 不开启亮度位 | 开启亮度位 |
| 红+绿+蓝       | 浅灰         | 白色       |
| 绿+蓝          | 青色         | 浅青       |
| 红+蓝          | 洋红         | 浅洋红     |
| 红+绿          | 棕色         | 黄色       |
| 无色彩         | 黑色         | 暗灰       |
----------------------------------------------

3.清屏

可以发现屏幕上有许多Bochs的打印信息，看着不爽，想办法去掉它
们。

利用0x06号功能，上卷全部行，则可清屏。

-----------------------------------------------------------
INT 0x10 功能0x06
------------------------------------------------------
描述：
上卷窗口
参数：
AH 6
AL 上卷的行数（0表示全部）
BH 空白区域的视频属性
CH，CL 窗口左上角的行列位置
DH，DL 窗口右下角的行列位置
返回值：
无
------------------------------------------------------------
示例：

#+BEGIN_SRC asm -n
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        call    clear_screen    # 清屏

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char              # 打印字符
        incb    %al                             # 下一个字符
        cmpb    $'Z',   %al             # 是否该重新从‘A’开始
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl                             # 下一个位置
        cmpb    $72,    %dl             # 是否到下一行
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor              # 设置光标位置
        incb    %bl                             # 下一种属性
        cmp             $0,             %bl             # 是否256种属性用完
        jne             1b
        jmp             1f                              # 结束

clear_screen:                           # 清屏函数
        movb    $0x06,  %ah             # 功能号0x06
        movb    $0,             %al             # 上卷全部行，即清屏
        movb    $0,             %ch             # 左上角行
        movb    $0,             %ch             # 左上角列      
        movb    $24,    %dh             # 右下角行
        movb    $79,    %dl             # 右下角列
        movb    $0x07,  %bh             # 空白区域属性
        int             $0x10
        ret

print_char:
        movb    $0x09,  %ah             # 功能号0x09
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah             # 功能号0x02
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55

#+END_SRC
结果：

[1356283975]

4.直接写显存绘制字符串：

示例：

#+BEGIN_SRC asm -n -r
#---------------------------------------------------------------
# 直接写显存显示一些文字函数：
#       显示计算机当前工作的显示模式    
draw_some_text:
        # 设置ES，DS的值
        movw    $VIDEO_SEG_TEXT,%ax
        movw    %ax,                    %es
        xorw    %ax,                    %ax
        movw    %ax,                    %ds

        # 计算字符显示位置的显存地址(目标地址)
        movw    $((80*TEXT_ROW+TEXT_COL) * 2),  %di
        
        # 源字符串地址
        leaw    msgstr,                 %si
        
        movb    $TEXT_COLOR,    %al             # 属性值（颜色）
        movw    len,                    %cx             # 显示的字符个数

draw_a_char:                    
        movsb
        stosb
        loop    draw_a_char

        ret
#+END_SRC

* 引导方式
操作系统运行之前运行的一个Rom程序块，与硬件紧密相连在一起,也叫bootloader。根据不
同的bootloader可以划分为不同的引导方式。引导方式主要有两种：

1、BIOS

2、UEFI

BIOS是早期PC机上使用的引导程序，BIOS与MBR配合是32位计算机的主流。UEFI是BIOS升级
版，增加了对FAT文件系统的支持、安全性能进一步提高，可以说UEFI是一个与固件一体化
的小操作系统。

UEFI与GPT经常配对，实质上两者没有必然联系。可以使用如下UEFI+MBR
UEFI +GPT 、BIOS +GPT 、BIOS+ MBR。
