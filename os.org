* 计算机体系结构[[file:computer.org][计算机体系结构]] 
* 内部引导系统程序
  操作系统运行之前运行的一个Rom程序块，与硬件紧密相连在一起,也叫bootloader。根据不
  同的bootloader可以划分为不同的引导方式。引导方式主要有两种：
** BIOS
   BIOS是早期PC机上使用的引导程序，BIOS与MBR配合是32位计算机的主流。UEFI是BIOS升
级版，增加了对FAT文件系统的支持、安全性能进一步提高，可以说UEFI是一个与固件一体
化的小操作系统。

** UEFI
UEFI与GPT经常配对，实质上两者没有必然联系。可以使用如下UEFI+MBR UEFI +GPT 、BIOS
+GPT 、BIOS+ MBR。
* 计算机操作系统 (用程序控制设备)  
** 系统基本功能 
*** 进程管理
    进程控制、进程同步、进程通信、死锁、处理机调度
*** 内存管理
    内存分配、地址映射、内存保护与共享、虚拟内存
*** 文件管理
   文件存储空间的管理、目录管理、文件读写管理和保护等
*** 设备管理
   完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
   主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
*** 系统调用
    Linux 的系统调用主要有以下这些：
 | Task     | Commands                    |
 | :---:    | ---                         |
 | 进程控制 | fork(); exit(); wait();     |
 | 进程通信 | pipe(); shmget(); mmap();   |
 | 文件操作 | open(); read(); write();    |
 | 设备操作 | ioctl(); read(); write();   |
 | 信息维护 | getpid(); alarm(); sleep(); |
 | 安全     | chmod(); umask(); chown();  |
** 中断分类
*** 外中断
    由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完
    成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
*** 异常
    由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

    ### 3. 陷入

    在用户程序中使用系统调用。

    # 二、进程管理

    ## 进程与线程

    ### 1. 进程

    进程是资源分配的基本单位。

    进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建
    进程和撤销进程，都是指对 PCB 的操作。

    下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

    <div align="center"> <img
    src="../pics//a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>

    ### 2. 线程

    线程是独立调度的基本单位。

    一个进程中可以有多个线程，它们共享进程资源。

    QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线
    程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，
    浏览器还可以响应用户的其它事件。

    <div align="center"> <img
    src="../pics//3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>

    ### 3. 区别

    Ⅰ 拥有资源

    进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

    Ⅱ 调度

    线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中
    的线程切换到另一个进程中的线程时，会引起进程切换。

    Ⅲ 系统开销

    由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出
    的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程
    CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器
    内容，开销很小。

    Ⅳ 通信方面

    线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

    ## 进程状态的切换

    <div align="center"> <img src="../pics//ProcessState.png" width="500"/>
    </div><br>

    - 就绪状态（ready）：等待被调度
    - 运行状态（running）
    - 阻塞状态（waiting）：等待资源

    应该注意以下内容：

    - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法
      从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完
      之后就会转为就绪状态，等待下一次调度。
    - 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺
      少 CPU 时间会从运行态转换为就绪态。

    ## 进程调度算法

    不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

    ### 1. 批处理系统

    批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从
    提交到终止的时间）。

    **1.1 先来先服务 first-come first-serverd（FCFS）**

    按照请求的顺序进行调度。

    有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，
    而长作业又需要执行很长时间，造成了短作业等待时间过长。

    **1.2 短作业优先 shortest job first（SJF）**

    按估计运行时间最短的顺序进行调度。

    长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，
    那么长作业永远得不到调度。

    **1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

    按估计剩余时间最短的顺序进行调度。

    ### 2. 交互式系统

    交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

    **2.1 时间片轮转**

    将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，
    该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该
    进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

    时间片轮转算法的效率和时间片的大小有很大关系：

    - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程
      切换得太频繁，在进程切换上就会花过多时间。
    - 而如果时间片过长，那么实时性就不能得到保证。

    <div align="center"> <img
    src="../pics//8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>

    **2.2 优先级调度**

    为每个进程分配一个优先级，按优先级进行调度。

    为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

    **2.3 多级反馈队列**

    一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

    多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间
    片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。
    这种方式下，之前的进程只需要交换 7 次。

    每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能
    调度当前队列上的进程。

    可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

    <div align="center"> <img
    src="../pics//042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>

    ### 3. 实时系统

    实时系统要求一个请求在一个确定时间内得到响应。

    分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

    ## 进程同步

    ### 1. 临界区

    对临界资源进行访问的那段代码称为临界区。

    为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

    ```html
    // entry section
    // critical section;
    // exit section
    ```

    ### 2. 同步与互斥

    - 同步：多个进程按一定顺序执行；
    - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

    ### 3. 信号量

    信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P
    和 V 操作。

    -  **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待
       信号量大于 0；
    -  **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

    down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽
    中断。

    如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区
    已经加锁，1 表示临界区解锁。

    ```c
    typedef int semaphore;
    semaphore mutex = 1;
    void P1() {
        down(&mutex);
        // 临界区
        up(&mutex);
    }

    void P2() {
        down(&mutex);
        // 临界区
        up(&mutex);
    }
    ```

    <font size=3> **使用信号量实现生产者-消费者问题** </font> </br>

    问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有
    缓冲区不为空，消费者才可以拿走物品。

    因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

    为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进
    行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数
    量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入
    物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走
    物品。

    注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再
    执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执
    行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为
    生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生
    产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

    ```c
    #define N 100
    typedef int semaphore;
    semaphore mutex = 1;
    semaphore empty = N;
    semaphore full = 0;

    void producer() {
        while(TRUE) {
            int item = produce_item();
            down(&empty);
            down(&mutex);
            insert_item(item);
            up(&mutex);
            up(&full);
        }
    }

    void consumer() {
        while(TRUE) {
            down(&full);
            down(&mutex);
            int item = remove_item();
            consume_item(item);
            up(&mutex);
            up(&empty);
        }
    }
    ```

    ### 4. 管程

    使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码
    独立出来，不仅不容易出错，也使得客户端代码调用更容易。

    c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提
    供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者
    问题。

    ```pascal
    monitor ProducerConsumer
        integer i;
        condition c;

        procedure insert();
        begin
            // ...
        end;

        procedure remove();
        begin
            // ...
        end;
    end monitor;
    ```

    管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不
    能一直占用管程，否者其它进程永远不能使用管程。

    管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操
    作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。
    signal() 操作用于唤醒被阻塞的进程。

    <font size=3> **使用管程实现生产者-消费者问题** </font><br>

    ```pascal
    // 管程
    monitor ProducerConsumer
        condition full, empty;
        integer count := 0;
        condition c;

        procedure insert(item: integer);
        begin
            if count = N then wait(full);
            insert_item(item);
            count := count + 1;
            if count = 1 then signal(empty);
        end;

        function remove: integer;
        begin
            if count = 0 then wait(empty);
            remove = remove_item;
            count := count - 1;
            if count = N -1 then signal(full);
        end;
    end monitor;

    // 生产者客户端
    procedure producer
    begin
        while true do
        begin
            item = produce_item;
            ProducerConsumer.insert(item);
        end
    end;

    // 消费者客户端
    procedure consumer
    begin
        while true do
        begin
            item = ProducerConsumer.remove;
            consume_item(item);
        end
    end;
    ```

    ## 经典同步问题

    生产者和消费者问题前面已经讨论过了。

    ### 1. 读者-写者问题

    允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

    一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于
    对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

    ```c
    typedef int semaphore;
    semaphore count_mutex = 1;
    semaphore data_mutex = 1;
    int count = 0;

    void reader() {
        while(TRUE) {
            down(&count_mutex);
            count++;
            if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
            up(&count_mutex);
            read();
            down(&count_mutex);
            count--;
            if(count == 0) up(&data_mutex);
            up(&count_mutex);
        }
    }

    void writer() {
        while(TRUE) {
            down(&data_mutex);
            write();
            up(&data_mutex);
        }
    }
    ```

    以下内容由 [@Bandi Yugandhar](https://github.com/yugandharbandi) 提供。

    The first case may result Writer to starve. This case favous Writers i.e no
    writer, once added to the queue, shall be kept waiting longer than absolutely
    necessary(only when there are readers that entered the queue before the writer).

    ```source-c
    int readcount, writecount;                   //(initial value = 0)
    semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

    //READER
    void reader() {
    <ENTRY Section>
     down(&readLock);                 //  reader is trying to enter
     down(&rmutex);                  //   lock to increase readcount
      readcount++;                 
      if (readcount == 1)          
       down(&resource);              //if you are the first reader then lock  the resource
     up(&rmutex);                  //release  for other readers
     up(&readLock);                 //Done with trying to access the resource

    <CRITICAL Section>
    //reading is performed

    <EXIT Section>
     down(&rmutex);                  //reserve exit section - avoids race condition with readers
     readcount--;                       //indicate you're leaving
      if (readcount == 0)          //checks if you are last reader leaving
       up(&resource);              //if last, you must release the locked resource
     up(&rmutex);                  //release exit section for other readers
    }

    //WRITER
    void writer() {
      <ENTRY Section>
      down(&wmutex);                  //reserve entry section for writers - avoids race conditions
      writecount++;                //report yourself as a writer entering
      if (writecount == 1)         //checks if you're first writer
       down(&readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
      up(&wmutex);                  //release entry section

    <CRITICAL Section>
     down(&resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
      //writing is performed
     up(&resource);                //release file

    <EXIT Section>
      down(&wmutex);                  //reserve exit section
      writecount--;                //indicate you're leaving
      if (writecount == 0)         //checks if you're the last writer
       up(&readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
      up(&wmutex);                  //release exit section
    }
    ```

    We can observe that every reader is forced to acquire ReadLock. On the
    otherhand, writers doesn’t need to lock individually. Once the first writer
    locks the ReadLock, it will be released only when there is no writer left in the
    queue.

    From the both cases we observed that either reader or writer has to starve.
    Below solutionadds the constraint that no thread shall be allowed to starve;
    that is, the operation of obtaining a lock on the shared data will always
    terminate in a bounded amount of time.

    ```source-c
    int readCount;                  // init to 0; number of readers currently accessing resource

    // all semaphores initialised to 1
    Semaphore resourceAccess;       // controls access (read/write) to the resource
    Semaphore readCountAccess;      // for syncing changes to shared variable readCount
    Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

    void writer()
    { 
        down(&serviceQueue);           // wait in line to be servicexs
        // <ENTER>
        down(&resourceAccess);         // request exclusive access to resource
        // </ENTER>
        up(&serviceQueue);           // let next in line be serviced

        // <WRITE>
        writeResource();            // writing is performed
        // </WRITE>

        // <EXIT>
        up(&resourceAccess);         // release resource access for next reader/writer
        // </EXIT>
    }

    void reader()
    { 
        down(&serviceQueue);           // wait in line to be serviced
        down(&readCountAccess);        // request exclusive access to readCount
        // <ENTER>
        if (readCount == 0)         // if there are no readers already reading:
            down(&resourceAccess);     // request resource access for readers (writers blocked)
        readCount++;                // update count of active readers
        // </ENTER>
        up(&serviceQueue);           // let next in line be serviced
        up(&readCountAccess);        // release access to readCount

        // <READ>
        readResource();             // reading is performed
        // </READ>

        down(&readCountAccess);        // request exclusive access to readCount
        // <EXIT>
        readCount--;                // update count of active readers
        if (readCount == 0)         // if there are no readers left:
            up(&resourceAccess);     // release resource access for all
        // </EXIT>
        up(&readCountAccess);        // release access to readCount
    }

    ```


    ### 2. 哲学家进餐问题

    <div align="center"> <img
    src="../pics//a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

    五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭
    以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起
    一根筷子。

    下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右
    手边的筷子，造成死锁。

    ```c
    #define N 5

    void philosopher(int i) {
        while(TRUE) {
            think();
            take(i);       // 拿起左边的筷子
            take((i+1)%N); // 拿起右边的筷子
            eat();
            put(i);
            put((i+1)%N);
        }
    }
    ```

    为了防止死锁的发生，可以设置两个条件：

    - 必须同时拿起左右两根筷子；
    - 只有在两个邻居都没有进餐的情况下才允许进餐。

    ```c
    #define N 5
    #define LEFT (i + N - 1) % N // 左邻居
    #define RIGHT (i + 1) % N    // 右邻居
    #define THINKING 0
    #define HUNGRY   1
    #define EATING   2
    typedef int semaphore;
    int state[N];                // 跟踪每个哲学家的状态
    semaphore mutex = 1;         // 临界区的互斥
    semaphore s[N];              // 每个哲学家一个信号量

    void philosopher(int i) {
        while(TRUE) {
            think();
            take_two(i);
            eat();
            put_tow(i);
        }
    }

    void take_two(int i) {
        down(&mutex);
        state[i] = HUNGRY;
        test(i);
        up(&mutex);
        down(&s[i]);
    }

    void put_tow(i) {
        down(&mutex);
        state[i] = THINKING;
        test(LEFT);
        test(RIGHT);
        up(&mutex);
    }

    void test(i) {         // 尝试拿起两把筷子
        if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
            state[i] = EATING;
            up(&s[i]);
        }
    }
    ```

    ## 进程通信

    进程同步与进程通信很容易混淆，它们的区别在于：

    - 进程同步：控制多个进程按一定顺序执行；
    - 进程通信：进程间传输信息。

    进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，
    需要让进程进行通信，传输一些进程同步所需要的信息。

    ### 1. 管道

    管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

    ```c
    #include <unistd.h>
    int pipe(int fd[2]);
    ```

    它具有以下限制：

    - 只支持半双工通信（单向交替传输）；
    - 只能在父子进程中使用。

    <div align="center"> <img
    src="../pics//53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

    ### 2. FIFO

    也称为命名管道，去除了管道只能在父子进程中使用的限制。

    ```c
    #include <sys/stat.h>
    int mkfifo(const char *path, mode_t mode);
    int mkfifoat(int fd, const char *path, mode_t mode);
    ```

    FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传
    递数据。

    <div align="center"> <img
    src="../pics//2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>

    ### 3. 消息队列

    相比于 FIFO，消息队列具有以下优点：

    - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产
      生的困难；
    - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
    - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

    ### 4. 信号量

    它是一个计数器，用于为多个进程提供对共享数据对象的访问。

    ### 5. 共享存储

    允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一
    种 IPC。

    需要使用信号量用来同步对共享存储的访问。

    多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存
    不是使用文件，而是使用使用内存的匿名段。

    ### 6. 套接字

    与其它通信机制不同的是，它可用于不同机器间的进程通信。

    # 三、死锁

    ## 必要条件

    <div align="center"> <img
    src="../pics//c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

    - 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
    - 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
    - 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式
      地释放。
    - 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一
      个进程所占有的资源。

    ## 处理方法

    主要有以下四种方法：

    - 鸵鸟策略
    - 死锁检测与死锁恢复
    - 死锁预防
    - 死锁避免

    ## 鸵鸟策略

    把头埋在沙子里，假装根本没发生问题。

    因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

    当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

    大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

    ## 死锁检测与死锁恢复

    不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

    ### 1. 每种类型一个资源的死锁检测

    <div align="center"> <img
    src="../pics//b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

    上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配
    给该进程，进程指向资源表示进程请求获取该资源。

    图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

    每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进
    行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存
    在环，也就是检测到死锁的发生。

    ### 2. 每种类型多个资源的死锁检测

    <div align="center"> <img
    src="../pics//e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

    上图中，有三个进程四个资源，每个数据代表的含义如下：

    - E 向量：资源总量
    - A 向量：资源剩余量
    - C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
    - R 矩阵：每个进程请求的资源数量

    进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程
    P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此
    时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A
    = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

    算法总结如下：

    每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的
    进程都是死锁进程。

    1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
    2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转
       回 1。
    3. 如果没有这样一个进程，算法终止。

    ### 3. 死锁恢复

    - 利用抢占恢复
    - 利用回滚恢复
    - 通过杀死进程恢复

    ## 死锁预防

    在程序运行之前预防发生死锁。

    ### 1. 破坏互斥条件

    例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机
    守护进程。

    ### 2. 破坏占有和等待条件

    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

    ### 3. 破坏不可抢占条件

    ### 4. 破坏环路等待

    给资源统一编号，进程只能按编号顺序来请求资源。

    ## 死锁避免

    在程序运行时避免发生死锁。

    ### 1. 安全状态

    <div align="center"> <img
    src="../pics//ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

    图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示
    还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结
    束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程
    都能成功运行，因此可以称图 a 所示的状态时安全的。

    定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种
    调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

    安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算
    法与死锁检测算法非常类似，可以结合着做参考对比。

    ### 2. 单个资源的银行家算法

    一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求
    的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

    <div align="center"> <img
    src="../pics//d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

    上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

    ### 3. 多个资源的银行家算法

    <div align="center"> <img
    src="../pics//62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

    上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的
    资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个
    为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

    检查一个状态是否安全的算法如下：

    - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生
      死锁，状态是不安全的。
    - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
    - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

    如果一个状态不是安全的，需要拒绝进入这个状态。

    # 四、内存管理

    ## 虚拟内存

    虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

    为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这
    个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到
    连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页
    时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

    从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，
    也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。
    例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算
    机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

    <div align="center"> <img
    src="../pics//7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

    ## 分页系统地址映射

    内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储
    着页（程序地址空间）和页框（物理内存空间）的映射表。

    一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

    下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚
    拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页
    表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页
    框的地址为 （110 000000000100）。

    <div align="center"> <img
    src="../pics//cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>

    ## 页面置换算法

    在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。
    此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

    页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大
    小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓
    存数据。

    页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

    ### 1. 最佳

    > Optimal

    所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

    是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

    举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

    <div align="center"><img src="https://latex.codecogs.com/gif.latex?7，0，1，2，0，
    3，0，4，2，3，0，3，2，1，2，0，1，7，0，1"/></div> <br>

    开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，
    会将页面 7 换出，因为页面 7 再次被访问的时间最长。

    ### 2. 最近最久未使用

    > LRU, Least Recently Used

    虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久
    未使用的页面换出。

    为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面
    移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

    因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

    <div align="center"><img src="https://latex.codecogs.com/gif.latex?4，7，0，7，1，
    0，1，2，1，2，6"/></div> <br>

    <div align="center"> <img
    src="../pics//eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>

    ### 3. 最近未使用

    > NRU, Not Recently Used

    每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置
    M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

    - R=0，M=0
    - R=0，M=1
    - R=1，M=0
    - R=1，M=1

    当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

    NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，
    M=0）。

    ### 4. 先进先出

    > FIFO, First In First Out

    选择换出的页面是最先进入的页面。

    该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

    ### 5. 第二次机会算法

    FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的
    修改：

    当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R
    位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将
    R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继
    续从链表的头部开始搜索。

    <div align="center"> <img
    src="../pics//ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

    ### 6. 时钟

    > Clock

    第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起
    来，再使用一个指针指向最老的页面。

    <div align="center"> <img
    src="../pics//5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

    ## 分段

    虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行
    映射。

    下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系
    统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

    <div align="center"> <img
    src="../pics//22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

    分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，
    并且可以动态增长。

    <div align="center"> <img
    src="../pics//e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

    ## 段页式

    程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的
    页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

    ## 分页与分段的比较

    - 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

    - 地址空间的维度：分页是一维地址空间，分段是二维的。

    - 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

    - 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使
      程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

    # 五、设备管理

    ## 磁盘结构

    - 盘面（Platter）：一个磁盘有多个盘面；
    - 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
    - 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理
      储存单位，目前主要有 512 bytes 与 4 K 两种大小；
    - 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信
      号转换为盘面的磁场（写）；
    - 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
    - 主轴（Spindle）：使整个盘面转动。

    <div align="center"> <img
    src="../pics//014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br>

    ## 磁盘调度算法

    读写一个磁盘块的时间的影响因素有：

    - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
    - 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
    - 实际的数据传输时间

    其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

    ### 1. 先来先服务

    > FCFS, First Come First Served

    按照磁盘请求的顺序进行调度。

    优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

    ### 2. 最短寻道时间优先

    > SSTF, Shortest Seek Time First

    优先调度与当前磁头所在磁道距离最近的磁道。

    虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道
    请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的
    磁道请求更容易出现饥饿现象。

    <div align="center"> <img
    src="../pics//4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br>

    ### 3. 电梯算法

    > SCAN

    电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

    电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方
    向上没有未完成的磁盘请求，然后改变方向。

    因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

    <div align="center"> <img
    src="../pics//271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br>

    # 六、链接

    ## 编译系统

    以下是一个 hello.c 程序：

    ```c
    #include <stdio.h>

    int main()
    {
        printf("hello, world\n");
        return 0;
    }
    ```

    在 Unix 系统上，由编译器把源文件转换为目标文件。

    ```bash
    gcc -o hello hello.c
    ```

    这个过程大致如下：

    <div align="center"> <img
    src="../pics//b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>

    - 预处理阶段：处理以 # 开头的预处理命令；
    - 编译阶段：翻译成汇编文件；
    - 汇编阶段：将汇编文件翻译成可重定向目标文件；
    - 链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到
      最终的可执行目标文件。

    ## 静态链接

    静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。
    链接器主要完成以下两个任务：

    - 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是
      将每个符号引用与一个符号定义关联起来。
    - 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号
      的引用，使得它们指向这个内存位置。

    <div align="center"> <img
    src="../pics//47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>

    ## 目标文件

    - 可执行目标文件：可以直接在内存中执行；
    - 可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文
      件；
    - 共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链
      接；

    ## 动态链接

    静态库有以下两个问题：

    - 当静态库更新时那么整个程序都要重新进行链接；
    - 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

    共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，
    Windows 系统上它们被称为 DLL。它具有以下特点：

    - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文
      件，它不会被复制到引用它的可执行文件中；
    - 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的
      正在运行的进程共享。

    <div align="center"> <img
    src="../pics//76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>

    # 参考资料

    - Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.
    - 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.
    - Bryant, R. E., & O’Hallaron, D. R. (2004). 深入理解计算机系统.
    - 史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014.
    - [Operating System
      Notes](https://applied-programming.github.io/Operating-Systems-Notes/)
    - [Operating-System
      Structures](https://www.cs.uic.edu/\~jbell/CourseNotes/OperatingSystems/2_Structures.html)
    - [Processes](http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php)
    - [Inter Process Communication
      Presentation[1]](https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1)
    - [Decoding UCS Invicta – Part
      1](https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1)
   
* 执行文件结构
** ELF32文件结构
#+BEGIN_SRC c
#define EI_NIDENT    16
typedef struct elf32_hdr{
  unsigned char    e_ident[EI_NIDENT];  //开始的16个字节
  Elf32_Half    e_type;  //文件类型
  Elf32_Half    e_machine;  //运行的机器类型
  Elf32_Word    e_version;  //版本
  Elf32_Addr    e_entry;  //程序入口地址
  Elf32_Off    e_phoff;  //程序头表在文件中的偏移
  Elf32_Off    e_shoff;  //节头表在文件中的偏移
  Elf32_Word    e_flags;  //标记
  Elf32_Half    e_ehsize;  //elf文件头大小
  Elf32_Half    e_phentsize;  //程序头表项的大小
  Elf32_Half    e_phnum;  //程序头表中表项项的个数
  Elf32_Half    e_shentsize;  //节头表项大小
  Elf32_Half    e_shnum;  //节头表中表项的个数
  Elf32_Half    e_shstrndx;  //节头表的字符串节所在节头表中下标
} Elf32_Ehdr;
#+END_SRC
节头表项对应的代码定义为：
#+BEGIN_SRC c
typedef struct elf32_shdr {
  Elf32_Word    sh_name;  //节的名字，在符号表中的下标
  Elf32_Word    sh_type;  //节的类型，描述符号，代码，数据，重定位等
  Elf32_Word    sh_flags;  //读写执行标记
  Elf32_Addr    sh_addr;  //节在执行时的虚拟地址
  Elf32_Off    sh_offset;  //节在文件中的偏移量
  Elf32_Word    sh_size;  //节的大小
  Elf32_Word    sh_link;  //其它节的索引
  Elf32_Word    sh_info;  //节的其它信息
  Elf32_Word    sh_addralign;  //节对齐
  Elf32_Word    sh_entsize;  //节拥有固定大小项的大小
} Elf32_Shdr;
#+END_SRC
: jmp汇编 的是偏移地址,我们写是写绝对地址
#+TITTLE: int中断
* 文件系统
** FAT12格式软盘
   对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。
   FAT12是DOS时代就开始使用的文件系统（File System)，直到2009年仍然在软盘上使用。
*** 主磁盘结构
**** 引导扇区（Boot Sector）
     位于第一个扇区，在软盘上就是0柱面（磁道）0磁头1扇区。
     引导扇区格式
  | 名称           | 偏移 | 长度 | 内容                                    | 软盘参考值             |
  | BS_jmpBoot     |    0 |    3 |                                         | jmp LABEL_START nop    |
  | BS_OEMName     |    3 |    8 | 厂商名                                  | 	'ForrestY'           |
  | BPB_BytsPerSec |   11 |    2 | 每扇区字节数 　                         | 	0x200（即十进制512） |
  | BPB_SecPerClus |   13 |    1 | 每簇扇区 　                            | 	0x01                 |
  | BPB_RsvdSecCnt |   14 |    2 | Boot记录占用多少扇区                    | 	0x01                 |
  | BPB_NumFATs    |   16 |    1 | 共有多少FAT表                           | 	0x02                 |
  | BPB_RootEntCnt |   17 |    2 | 根目录文件数最大值                      | 	0xE0 （224）         |
  | BPB_TotSec16   |   19 |    2 | 扇区总数                                | 	0xB40（2880）        |
  | BPB_Media      |   21 |    1 | 介质描述符                              | 0xF0                   |
  | BPB_FATSz16    |   22 |    2 | 每FAT扇区数                             | 	0x09                 |
  | BPB_SecPerTrk  |   24 |    2 | 每磁道扇区数                            | 0x12                   |
  | BPB_NumHeads   |   26 |    2 | 磁头数                                  | 0x02                   |
  | BPB_HiddSec    |   28 |    4 | 隐藏扇区数                              | 	0                    |
  | BPB_TotSec32   |   32 |    4 | 如果BPB_TotSec16是0，由这个值记录扇区数 | 	0xB40（2880）        |
  | BS_DrvNum      |   36 |    1 | 中断13的驱动器号                        | 	0                    |
  | BS_Reserved1   |   37 |    1 | 未使用                                  | 	0                    |
  | BS_BootSig     |   38 |    1 | 扩展引导标记                            | 0x29                   |
  | BS_VolD        |   39 |    4 | 卷序列号                                | 	0                    |
  | BS_VolLab      |   43 |   11 | 卷标                                    | 	'OrangeS0.02'        |
  | BS_FileSysType |   54 |    8 | 文件系统类型                            | 	'FAT12'              |
  | 引导代码       |   62 |  448 | 引导代码、数据及其他填充字符等          |                        |
  | 结束标志       |  510 |    2 |                                         | 	0xAA55               |
 
**** 文件分配表（FAT）
     紧接着引导扇区的是两个完全相同的FAT表，每个FAT表占用9个扇区
     
     它包含有两份文件分配表，这是出于系统冗余考虑，尽管它很少使用，即使是磁盘修
     复工具也很少使用它。它是分区信息的映射表，指示簇是如何存储的。
     
     每个FAT项占12bit，这也所被成为FAT12的原因，FAT项的值代表的是文件下一个簇号，
     但如果值大于等于0xFF8，则表示当前簇已经是本文件的最后一个簇。如果值是0xFF7，
     表示它是一个坏簇。
     
     一个FAT项可能跨越两个扇区，编码实现的过程要考虑在内。 
**** 根目录区
     FAT表之后是根目录区，根目录区长度不固定
     
     根目录区位于第二个FAT表之后，开始扇区号为19，它由若干个目录条目（Directory
     Entry）组成，条目最多有BPB_RootEntCnt个。每个条目占用32个字节，它的格式如
     下： 
 | 名称         | 　　	偏移 | 　　	长度 | 　　	描述                     |
 | DIR_Name     | 　　	0    | 　　	0xB  | 　　	文件名8字节，扩展名3字节 |
 | DIR_Attr     | 　　	0xB  | 　　	1    | 　　	文件属性                 |
 | 保留         | 　　	0xC  | 　　	10   | 　　                           |
 | DIR_WrtTime  | 　　	0x16 | 　　	2    | 　　	最后修改时间             |
 | DIR_WrtDate  | 　　	0x18 | 　　	2    | 　　	最后修改日期             |
 | DIR_FstClus  | 　　	0x1A | 　　	2    | 　　	此条目对应的开始簇号     |
 | DIR_FileSize | 　　	0x1C | 　　	4    | 　　	文件大小                 |
     
**** 数据区
     数据区在根目录区后，数据区开始扇区号为根目录区起始扇区号+根目录区大小，即
     19+BPB_RootEntCnt * 32 / BPB_BytsPerSec。
<!-- GFM-TOC -->
** Ext2文件系统
   当要读取一个文件的内容时，先在 inode 中去查找文件内容所在
   的所有 block，然后把所有 block 的内容读出来。
* BIOS 中断   
** 硬盘服务 int 13 硬盘服务
   中断INT13功能及用法分析 

INT 13H，AH=00H 软、硬盘控制器复位 

说明： 
此功能复位磁盘（软盘和硬盘）控制器板和磁盘驱动器，它在磁盘控制器 
芯片上完成复位操场作并在磁盘进行所需的操作之前做一系列用于磁盘校准的 
磁盘操作。 
当磁盘I/O功能调用出现错误时，需要调用此功能，此刻复位功能将使BIOS 
象该磁盘重新插入一样检查驱动器中磁盘状态，并将磁头校准使之在应该在的 
位置上。 
此功能调用不影响软盘或硬盘上的数据。 
入口参数： 
AH=00H 指明调用复位磁盘功能。 
DL 需要复位的驱动器号。 
返回参数： 
若产生错误，进位标志CF=1，错误码在AH寄存器。 
详情请见磁盘错误状态返回码一文。 
示例： 
C_SEG SEGMENT PUBLIC 
ASSUME CS:C_SEG,DS:C_SEG 
ORG 100H 
START: MOV AH, 00H 
MOV DL, 80H 
INT 13H 
;复位硬盘 C 
JC ERROR 
…… 
ERROR: …… 
C_SEG ENDS 
END START 

INT 13H，AH=02H 读扇区说明： 
调用此功能将从磁盘上把一个或更多的扇区内容读进存贮器。因为这是一个 
低级功能，在一个操作中读取的全部扇区必须在同一条磁道上（磁头号和磁道号 
相同）。BIOS不能自动地从一条磁道末尾切换到另一条磁道开始，因此用户必须 
把跨多条磁道的读操作分为若干条单磁道读操作。 
入口参数： 
AH=02H 指明调用读扇区功能。 
AL 置要读的扇区数目，不允许使用读磁道末端以外的数值，也不允许 
使该寄存器为0。 
DL 需要进行读操作的驱动器号。 
DH 所读磁盘的磁头号。 
CH 磁道号的低8位数。 
CL 低5位放入所读起始扇区号，位7-6表示磁道号的高2位。 
ES:BX 读出数据的缓冲区地址。 
返回参数： 
如果CF=1，AX中存放出错状态。读出后的数据在ES:BX区域依次排列。 
详情请参见磁盘错误状态返回码一文。 
示例： 
C_SEG SEGMENT PUBLIC 
ASSUME CS:C_SEG,DS:C_SEG 
ORG 100H 
START: JMP READ 
BUFFER DB 512 DUP(0) 
READ: PUSH CS 
POP ES 
MOV BX, OFFSET BUFFER 
MOV AX, 0201H 
MOV CX, 0001H 
MOV DX, 0000H 
INT 13H 
;读软盘A, 0面0道1扇区 
;读出后数据在BUFFER中 
JC ERROR 
…… 
ERROR: …… 
C_SEG ENDS 
END START 

INT 13H，AH=03H 写扇区 

说明： 
调用此功能将从磁盘上把一个或更多的扇区内容写入驱动器。因为这 
是一个低级功能，在一个写入操作中的全部扇区必须在同一条磁道上（磁 
头号和磁道号相同）。BIOS不能自动地从一条磁道末尾切换到另一条磁道 
开始，因此用户必须把跨多条磁道的写操作分为若干条单磁道写操作。 
入口参数： 
AH=03H 指明调用写扇区功能。 
AL 置要写的扇区数目，不允许使用超出磁道末端以外的数值， 
也不允许使该寄存器为0。 
DL 需要进行写操作的驱动器号。 
DH 所写磁盘的磁头号。 
CH 磁道号的低8位数。 
CL 低5位放入所读起始扇区号，位7-6表示磁道号的高2位。 
ES:BX 放置写入数据的存贮区地址。 
返回参数： 
如果CF=1，AX中存放出错状态。 
详情请参见磁盘错误状态返回码一文。 
示例： 
C_SEG SEGMENT PUBLIC 
ASSUME CS:C_SEG,DS:C_SEG 
ORG 100H 
START: JMP WRITE 
BUFFER DB 512 DUP(0FFH) 
WRITE: PUSH CS 
POP ES 
MOV BX, OFFSET BUFFER 
MOV AX, 0301H 
MOV CX, 0001H 
MOV DX, 0000H 
INT 13H 
;写入软盘A, 0面0道1扇区 
;把此扇区数据全部置为0FFH 
JC ERROR 
…… 
ERROR: …… 
C_SEG ENDS 
END START 
INT 13H，AH=04H 检测扇区 

说明： 
这个功能检测磁盘上1个或更多的扇区。这个验证测试不是把磁盘上的 
数据和内存中的数据进行比较，而只是简单地确定读出的数据有无CRC错误。 
这个功能可用来验证驱动器中的软盘版。如果盘片的格式正确，CF=0。 
入口参数： 
AH=03H 指明调用检测扇区功能。 
AL 置要检测的连续扇区数目，不允许使用超出磁道末端以外的 
数值，也不允许使该寄存器为0。 
DL 需要进行检测的驱动器号。 
DH 磁盘的磁头号。 
CH 磁道号的低8位数。 
CL 低5位放入起始扇区号，位7-6表示磁道号的高2位。 
返回参数： 
如果CF=1，AX中存放出错状态。CF=0，检测正确。 
详情请参见磁盘错误状态返回码一文。 
示例： 
C_SEG SEGMENT PUBLIC 
ASSUME CS:C_SEG,DS:C_SEG 
ORG 100H 
START: MOV AX, 0401H 
MOV CX, 0001H 
MOV DX, 0000H 
INT 13H 
;检测软盘A, 0面0道1扇区 
JC ERROR 
…… 
ERROR: …… 
C_SEG ENDS 
END START 

磁盘错误状态返回码: 

磁盘错误状态 

AH= 
00H 未出错 
01H 非法功能调用命令区。 
02H 地址标记损坏，扇区标识（ID）无效或未找到。 
03H 企图对有写保护的软盘执行写操作。 
04H 所寻找的扇区没找到。 
05H 复位操作失败。 
06H 无介质。 
07H 初始化错误，数据未存在DMA的64K缓冲区内。 
08H DMA故障 
09H DMA边界错误，数据未存在DMA的64K缓冲区内。 
0AH 检测出错误码率的扇区标志。 
0BH 所寻找的磁道没找到。 
0CH 介质类型没发现。 
0DH 扇区号有问题。 
0EH 发现控制数据地址标记。 
0FH 超出DMA边界 
10H 读磁盘时奇偶校验错，且纠错码（EDC）不能纠正。 
11H 读磁盘时奇偶校验错，但纠错码（EDC）已纠正错误。 
20H 控制器错。 
40H 查找操作无效。 
80H 超时错误，驱动器不响应。 
AAH 驱动器未准备好。 
BBH 不明错误。 
CCH 被选驱动器出现写故障。 
E0H 错误寄存器是零 
FFH 非法操作。 
** 显示服务 int 10h
*** wen
使用BIOS 显示服务（Video Service）--INT 10H，下面主要探究字符显示模式。

BIOS中断在保护模式下是不能用的，故不能在Linux中测试，所以写了个简单的boot loader，并在虚拟机中运行程序。



1.以电传的方式写入字符串（AH=0x13）
------------------------------------------------------------------
			INT 0x10功能0x13
--------------------------------------------------------------
描述：
	以电传打字机的方式显示字符串
接受参数：
	AH			0x13
	AL			显示模式
	BH			视频页
	BL			属性值（如果AL=0x00或0x01）
	CX			字符串的长度
	DH,DL		屏幕上显示起始位置的行、列值
	ES:BP		字符串的段:偏移地址
返回值：
	无
显示模式（AL）：
	0x00:字符串只包含字符码，显示之后不更新光标位置，属性值在BL中
	0x01:字符串只包含字符码，显示之后更新光标位置，属性值在BL中
	0x02:字符串包含字符码及属性值，显示之后不更新光标位置
	0x03:字符串包含字符码及属性值，显示之后更新光标位置
-------------------------------------------------------------------

示例：
# A bootsect, which print a string by BIOS interrupt video services(int 0x10)
.section .text
.global _start
.code16
_start:
	movw	%cx,	%ax
	movw	%ax,	%ds
	movw	%ax,	%es
	movw	$msgstr,%bp
	movw	len,	%cx
	movb	$0x05,	%dh
	movb	$0x08,	%dl
	movb	$0x01,	%al
	movb	$0x13,	%ah
	movb	$0x01,	%bl
	movb	$0x00,	%bh
	int		$0x10
1:
	jmp		1b
msgstr:
	.asciz	"Hello babyos(print by BIOS int 0x10:0x13, mode 0x01)!"
len:
	.int	. - msgstr
	.org	0x1fe,	0x90
	.word	0xaa55
makefile:
all: boot.img
boot.o: boot.s
	as -o $@ $<
boot: boot.o
	ld --oformat binary -N -Ttext 0x7c00 -o $@ $<
boot.img: boot
	dd if=boot of=boot.img bs=512 count=1
 
clean:
	rm ./boot ./boot.img ./boot.o

运行：




2.通过功能号0x09探究色彩控制
上面的显示为什么是红色呢？我们可以通过实验来看一下颜色控制。

------------------------------------------------------------------------
			INT 0x10功能0x09
-------------------------------------------------------------------
描述：
	显示字符并设置其属性
接受参数：
	AH			0x09
	AL			字符的ASCII码
	BH			视频页
	BL			属性值
	CX			重复次数
返回值：
	无
注意：
	在显示字符之后并不前进光标。在文本和图形模式下均可调用该功能
	显示完字符后，如果还要继续显示字符，必须调用INT 0x10功能0x02前进光标
-------------------------------------------------------------------------
 
------------------------------------------------------------------------
			INT 0x10功能0x02
-------------------------------------------------------------------
描述：
	把光标定位在选定视频页的特定行列位置
接受参数：
	AH			0x02
	DH，DL		行、列值
	BH			视频页
返回值：
	无
注意：
	在80x25模式下，DH范围0～24，DL范围0～79
-------------------------------------------------------------------------

示例：

实现一个从第4行～7行，第8列～71列，显示‘A’～‘Z’的程序，共显示256个字符，使用BL（0～255）

C 伪代码：
cx = 0x04;
bh = 0x00;
 
dh = 0x04;
dl = 0x08;
al = 'A';
 
for (bl = 0; bl < 256; bl++)
{
	print_char();
	
	al++;
	if (al == 'Z')
		al = 'A';
	
	dl++;
	if (dl == 72)
	{
		dh++;
		dl = 4;
	}
	
	set_cursor();
}
汇编代码：
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09
 
.section .text
.global _start
.code16
 
_start:
	movw	%cx,	%ax
	movw	%ax,	%ds
	movw	%ax,	%es
 
	movw	$0x01,	%cx		# 字符显示重复次数
	movb	$0x00,	%bh		# 视频页
	
	movb	$0x04,	%dh		# 显示起始行
	movb	$0x08,	%dl		# 显示起始列
	
	movb	$'A',	%al		# 显示字符
	movb	$0x00,	%bl		# 属性值
 
1:
	call	print_char
	incb	%al
	cmpb	$'Z',	%al
	jne		2f
	movb	$'A',	%al
2:	
	incb	%dl
	cmpb	$72,	%dl
	jne		3f
	movb	$8,		%dl
	incb	%dh
3:
	call	set_cursor
	incb	%bl
	cmp		$256,	%bl
	jne		1b
	jmp		1f
 
print_char:
	movb	$0x09,	%ah
	int		$0x10
	ret
 
set_cursor:
	movb	$0x02,	%ah
	int		$0x10
	ret
 
1:
	jmp		1b
 
	.org	0x1fe,	0x90
	.word	0xaa55

结果：


可以显式地验证色彩控制BL：
7		6		5		4		3		2		1		0
I       R		G		B		I		R		G		B
闪烁    R		G		B		I		R		G		B

如上图所示，7～4位为背景色，I表示高亮，RGB表示红绿蓝，若显卡支持闪烁，则位7表示是否闪烁。
色彩混合：
-----------------------------------------------------------
混合的三种基色		不开启亮度位		开启亮度位
-------------------------------------------------------
红+绿+蓝			浅灰				白色
绿+蓝				青色				浅青
红+蓝				洋红				浅洋红
红+绿				棕色				黄色
无色彩				黑色				暗灰
-----------------------------------------------------------

3.清屏
可以发现屏幕上有许多Bochs的打印信息，看着不爽，想办法去掉它们。

利用0x06号功能，上卷全部行，则可清屏。

-----------------------------------------------------------
INT 0x10 功能0x06
------------------------------------------------------
描述：
上卷窗口
参数：
AH 6
AL 上卷的行数（0表示全部）
BH 空白区域的视频属性
CH，CL 窗口左上角的行列位置
DH，DL 窗口右下角的行列位置
返回值：
无
------------------------------------------------------------
示例：

# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09
 
.section .text
.global _start
.code16
 
_start:
	movw	%cx,	%ax
	movw	%ax,	%ds
	movw	%ax,	%es
 
	call	clear_screen	# 清屏
 
	movw	$0x01,	%cx		# 字符显示重复次数
	movb	$0x00,	%bh		# 视频页
	
	movb	$0x04,	%dh		# 显示起始行
	movb	$0x08,	%dl		# 显示起始列
	
	movb	$'A',	%al		# 显示字符
	movb	$0x00,	%bl		# 属性值
 
1:
	call	print_char		# 打印字符
	incb	%al				# 下一个字符
	cmpb	$'Z',	%al		# 是否该重新从‘A’开始
	jne		2f
	movb	$'A',	%al
2:	
	incb	%dl				# 下一个位置
	cmpb	$72,	%dl		# 是否到下一行
	jne		3f
	movb	$8,		%dl
	incb	%dh
3:
	call	set_cursor		# 设置光标位置
	incb	%bl				# 下一种属性
	cmp		$0,		%bl		# 是否256种属性用完
	jne		1b
	jmp		1f				# 结束
 
clear_screen:				# 清屏函数
	movb	$0x06,	%ah		# 功能号0x06
	movb	$0,		%al		# 上卷全部行，即清屏
	movb	$0,		%ch		# 左上角行
	movb	$0,		%ch		# 左上角列	
	movb	$24,	%dh		# 右下角行
	movb	$79,	%dl		# 右下角列
	movb	$0x07,	%bh		# 空白区域属性
	int		$0x10
	ret
 
print_char:
	movb	$0x09,	%ah		# 功能号0x09
	int		$0x10
	ret
 
set_cursor:
	movb	$0x02,	%ah		# 功能号0x02
	int		$0x10
	ret
 
1:
	jmp		1b
 
	.org	0x1fe,	0x90
	.word	0xaa55

结果：




4.直接写显存绘制字符串：
示例：
#---------------------------------------------------------------
# 直接写显存显示一些文字函数：
#	显示计算机当前工作的显示模式	
draw_some_text:
	# 设置ES，DS的值
	movw	$VIDEO_SEG_TEXT,%ax
	movw	%ax,			%es
	xorw	%ax,			%ax
	movw	%ax,			%ds
 
 
	# 计算字符显示位置的显存地址(目标地址)
	movw	$((80*TEXT_ROW+TEXT_COL) * 2),	%di
	
	# 源字符串地址
	leaw	msgstr,			%si
	
	movb	$TEXT_COLOR,	%al		# 属性值（颜色）
	movw	len,			%cx		# 显示的字符个数
 
 
draw_a_char:			
	movsb
	stosb
	loop	draw_a_char
 
 

--------------------- 
作者：孤舟钓客 
来源：CSDN 
原文：https://blog.csdn.net/guzhou_diaoke/article/details/8397658 
版权声明：本文为博主原创文章，转载请附上博文链接！
