* 30天自制操作系统
** 设备管理  
  #+BEGIN_SRC asm
   io_out8(PIC0_IMR, 0xf9); /* 开放PIC1和键盘中断(11111001) */
   io_out8(PIC1_IMR, 0xef); /* 开放鼠标中断(11101111) */
   init_keyboard();
   init_palette();
   init_screen8(binfo->vram, binfo->scrnx, binfo->scrny);
  #+END_SRC
** 第9天　内存管理
整理源文件（harib06a）
内存容量检查（1）（harib06b）
内存容量检查（2）（harib06c）
挑战内存管理（harib06d）



*** 1　整理源文件（harib06a）
现在我们还残留一个问题，就是鼠标指针的叠加处理不太顺利。不过如果一味进行鼠标处理的话，大家可能很容易腻烦，所以我们今天干点儿别的。鼠标指针的叠加处理问题迟早会解决的，大家不用担心，暂时先忘掉这个事情吧。
那么，今天做什么呢？我们今天就做内存管理吧。好不容易变成了32位模式，终于可以使用电脑的全部内存了，大家肯定也想用一用试试吧。
刚想改造bootpack.c，却发现为了解决鼠标处理问题而大加修改程序导致程序变大了很多，足足有182行。嗯，程序太长了，怎么看都不舒服，所以笔者决定将程序整理一下。

本次的程序整理表

函　数　名 移　动　前 移　动　后
#+BEGIN_SRC asm
wait_KBC_sendready bootpack.c keyboard.c
init_keyboard bootpack.c keyboard.c
enable_mouse bootpack.c mouse.c
mouse_decode bootpack.c mouse.c
inthandler21 init.c keyboard.c
inthandler2c init.c mouse.c
#+END_SRC
要做的事情很简单，仅仅是把函数写到不同的地方而已。此时，如果不知道哪个函数写在什么地方，可就麻烦了，所以在bootpack.h里还要加上函数声明，在Makefile的“OBJS_BOOTPACK=”那里，要将keyboard.obj和mouse.obj也补进去。
我们顺便确认一下运行情况。“make run”，不错不错，还能像以前那样运行。这样bootpack.c就减到了86行。真清爽！

*** 2　内存容量检查（1）（harib06b）
现在我们要进行内存管理了。首先必须要做的事情，是搞清楚内存究竟有多大，范围是到哪里。如果连这一点都搞不清楚的话，内存管理就无从谈起。
在最初启动时，BIOS肯定要检查内存容量，所以只要我们问一问BIOS，就能知道内存容量有多大。但问题是，如果那样做的话，一方面asmhead.nas会变长，另一方面，BIOS版本不同，BIOS函数的调用方法也不相同，麻烦事太多了。所以，笔者想与其如此，不如自己去检查内存。
■■■■■

下面介绍一下做法。
首先，暂时让486以后的CPU的高速缓存（cache）功能无效。回忆一下最初讲的CPU与内存的关系吧。我们说过，内存与CPU的距离地与CPU内部元件要远得多，因此在寄存器内部MOV，要比从寄存器MOV到内存快得多。但另一方面，有一个问题，CPU的记忆力太差了，即使知道内存的速度不行，还不得不频繁使用内存。
考虑到这个问题，英特尔的大叔们在CPU里也加进了一点存储器，它被称为高速缓冲存储器（cache memory）。cache这个词原是指储存粮食弹药等物资的仓库。但是能够跟得上CPU速度的高速存储器价格特别高，一个芯片就有一个CPU那么贵。如果128MB内存全部都用这种高价存储器，预算上肯定受不了。高速缓存，容量只有这个数值的千分之一，也就是128KB左右。高级CPU，也许能有1MB高速缓存，但即便这样，也不过就是128MB的百分之一。
为了有效使用如此稀有的高速缓存，英特尔的大叔们决定，每次访问内存，都要将所访问的地址和内容存入到高速缓存里。也就是存放成这样：18号地址的值是54。如果下次再要用18号地址的内容，CPU就不再读内存了，而是使用高速缓存的信息，马上就能回答出18号地址的内容是54。
往内存里写入数据时也一样，首先更新高速缓存的信息，然后再写入内存。如果先写入内存的话，在等待写入完成的期间，CPU处于空闲状态，这样就会影响速度。所以，先更新缓存，缓存控制电路配合内存的速度，然后再慢慢发送内存写入命令。
观察机器语言的流程会发现，9成以上的时间耗费在循环上。所谓循环，是指程序在同一个地方来回打转。所以，那个地方的内存要一遍又一遍读进来。从第2圈循环开始，那个地方的内存信息已经保存到缓存里了，就不需要执行费时的读取内存操作了，机器语言的执行速度因而得以大幅提高。
另外，就算是变量，也会有像“for(i = 0; i < 100; i++){}”这样，i频繁地被引用，被赋值的情况，最初是０，紧接着是１，下一个就是２。也就是说，要往内存的同一个地址，一次又一次写入不同的值。缓存控制电路观察会这一特性，在写入值不断变化的时候，试图不写入缓慢的内存，而是尽量在缓存内处理。循环处理完成，最终i的值变成100以后，才发送内存写入命令。这样，就省略了99次内存写入命令，CPU几乎不用等就能连续执行机器语言。
386的CPU没有缓存，486的缓存只有8-16KB，但两者的性能就差了6倍以上1。286进化到386时，性能可没提高这么多。386进化到486时，除了缓存之外还有别的改善，不能光靠缓存来解释这么大的性能差异，但这个性能差异，居然比16位改良到32位所带来的性能差异还要大，笔者认为这主要应该归功于缓存。
1 这里用来比较的是386DX-33MHz与486DX4-100MHz（据ICOMP1.0）。
■■■■■
内存检查时，要往内存里随便写入一个值，然后马上读取，来检查读取的值与写入的值是否相等。如果内存连接正常，则写入的值能够记在内存里。如果没连接上，则读出的值肯定是乱七八糟的。方法很简单。但是，如果CPU里加上了缓存会怎么样呢？写入和读出的不是内存，而是缓存。结果，所有的内存都“正常”，检查处理不能完成。
所以，只有在内存检查时才将缓存设为OFF。具体来说，就是先查查CPU是不是在486以上，如果是，就将缓存设为OFF。按照这一思路，我们创建了以下函数memtest。
本次的bootpack.c节选
#+BEGIN_SRC asm
#define EFLAGS_AC_BIT 0x00040000
#define CR0_CACHE_DISABLE 0x60000000
unsigned int memtest(unsigned int start, unsigned int end)
{
char flg486 = 0;
unsigned int eflg, cr0, i;
/* 确认CPU是386还是486以上的 */
eflg = io_load_eflags();
eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */
io_store_eflags(eflg);
eflg = io_load_eflags();
if ((eflg & EFLAGS_AC_BIT) != 0) { /* 如果是386，即使设定AC=1，AC的值还会自动回到0 */
flg486 = 1;
}

eflg &= ~EFLAGS_AC_BIT; /* AC-bit = 0 */
io_store_eflags(eflg);
if (flg486 != 0) {
cr0 = load_cr0();
cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */
store_cr0(cr0);
}

i = memtest_sub(start, end);
if (flg486 != 0) {
cr0 = load_cr0();
cr0 &= ~CR0_CACHE_DISABLE; /* 允许缓存 */
store_cr0(cr0);
}
return i;
}
#+END_SRC

最初对EFLAGS进行的处理，是检查CPU是486以上还是386。如果是486以上，EFLAGS寄存器的第18位应该是所谓的AC标志位；如果CPU是386，那么就没有这个标志位，第18位一直是0。这里，我们有意识地把1写入到这一位，然后再读出EFLAGS的值，继而检查AC标志位是否仍为1。最后，将AC标志位重置为0。
将AC标志位重置为0时，用到了AND运算，那里出现了一个运算符“~”，它是取反运算符，就是将所有的位都反转的意思。所以，~EFLAGS_AC_BIT与0xfffbffff一样。
为了禁止缓存，需要对CR0寄存器的某一标志位进行操作。对哪里操作，怎么操作，大家一看程序就能明白。这时，需要用到函数load_cr0和store_cr0，与之前的情况一样，这两个函数不能用C语言写，只能用汇编语言来写，存在naskfunc.nas里。

本次的naskfunc.nas节选
#+BEGIN_SRC asm
_load_cr0: ; int load_cr0(void);
MOV EAX,CR0
RET
_store_cr0: ; void store_cr0(int cr0);
MOV EAX,[ESP+4]
MOV CR0,EAX
RET
#+END_SRC

■■■■■
另外，memtest_sub函数，是内存检查处理的实现部分。

最开始的memtest_sub
#+BEGIN_SRC asm
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
for (i = start; i <= end; i += 4) {
p = (unsigned int *) i;
old = *p; /* 先记住修改前的值 */
*p = pat0; /* 试写 */
*p ^= 0xffffffff; /* 反转 */
if (*p != pat1) { /* 检查反转结果 */
not_memory:
*p = old;
break;
}

*p ^= 0xffffffff; /* 再次反转 */
if (*p != pat0) { /* 检查值是否恢复 */
goto not_memory;
}

*p = old; /* 恢复为修改前的值 */
}
return i;
}
#+END_SRC
这个程序所做的是：调查从start地址到end地址的范围内，能够使用的内存的末尾地址。要做的事情很简单。首先如果p不是指针，就不能指定地址去读取内存，所以先执行“p=i;”。紧接着使用这个p，将原值保存下来（变量old）。接着试写0xaa55aa55，在内存里反转该值，检查结果是否正确2。如果正确，就再次反转它，检查一下是否能回复到初始值。最后，使用old变量，将内存的值恢复回去。……如果在某个环节没能恢复成预想的值，那么就在那个环节终止调查，并报告终止时的地址。
2 有些机型即便不进行这种检查也不会有问题。但有些机型因为芯片组和主板电路等原因，如果不做这种检查就会直接读出写入的数据，所以要反转一下。

关于反转，我们用XOR运算来实现，其运算符是“^”。“*p^ = 0xffffffff;”是“*p = *p^0xffffffff;”的省略形式。

i的值每次增加4是因为每次要检查4个字节。之所以把变量命名为pat0、pat1是因为这些变量表示测试时所用的几种形式。

■■■■■

笔者试着执行了一下这个程序，发现运行速度特别慢，于是就对memtest_sub做了些改良，不过只修改了最初的部分。

本次的bootpack.c节选

unsigned int memtest_sub(unsigned int start, unsigned int end)
{
unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
for (i = start; i <= end; i += 0x1000) {
p = (unsigned int *) (i + 0xffc);
old = *p; /* 先记住修改前的值 */
改变的内容只是for 语句中i 的增值部分以及p的赋值部分。每次只增加4，就要检查全部内存，速度太慢了，所以改成了每次增加0x1000，相当于4KB，这样一来速度就提高了1000倍。p的赋值计算式也变了，这是因为，如果不进行任何改变仍写作“p=i;”的话，程序就会只检查4KB最开头的4个字节。所以要改为“p=i + 0xffc;”，让它只检查末尾的4个字节。
毕竟在系统启动时内存已经被仔细检查过了，所以像这次这样，目的只是确认容量的话，做到如此程度就足够了。甚至可以说每次检查1MB都没什么问题。

■■■■■

那好，下面我们来改造HariMain。添加的程序如下：

本次的bootpack.c节选
i = memtest(0x00400000, 0xbfffffff) / (1024 * 1024);
sprintf(s, "memory %dMB", i);
putfonts8_asc(binfo->vram, binfo->scrnx, 0, 32, COL8_FFFFFF, s);
暂时先使用以上程序对0x00400000～0xbfffffff范围的内存进行检查。这个程序最大可以识别3GB范围的内存。0x00400000号以前的内存已经被使用了（参考8.5节的内存分布图），没有内存，程序根本运行不到这里，所以我们没做内存检查。如果以byte或KB为单位来显示结果不容易看明白，所以我们以MB为单位。
也不知道能不能正常运行。如果在QEMU上运行，根据模拟器的设定，内存应该为32MB。运行“make run”。
内存容量怎么不对呀？
哎？怎么回事？内存容量怎么不是32MB，而是3072MB？这不就是3GB吗？为什么会失败呢？明明已经将缓冲OFF掉了。

*** 3　内存容量检查（2）（harib06c）
这种做法本身没有问题，笔者在OSASK上确认过，所以看到上述结果很纳闷。这种内存检查方法在很多机型上都能运行，所以笔者非常自信地向大家推荐了它。虽然笔者坚信程序没有问题，可运行结果……
经过多方调查，终于搞清楚了原因。如果我们不用“make run”，而是用“make -r bootpack.nas”来运行的话，就可以确认bootpack.c被编译成了什么样的机器语言。用文本编辑器看一看生成的bootpack.nas会发现，最下边有memtest_sub的编译结果。我们将编译结果列在下面。（为了读起来方便，笔者还添加了注释。）
harib06b中，memtest_sub的编译结果

_memtest_sub:
#+BEGIN_SRC asm
PUSH EBP ; C编译器的固定语句

MOV EBP,ESP

MOV EDX,DWORD [12+EBP] ; EDX = end;
MOV EAX,DWORD [8+EBP] ; EAX = start; /* EAX是i */

CMP EAX,EDX ; if (EAX > EDX) goto L30;

JA L30

L36:

L34:

ADD EAX,4096 ; EAX += 0x1000;

CMP EAX,EDX ; if (EAX <= EDX) goto L36;

JBE L36

L30:

POP EBP ; 接收前文中PUSH的EBP

RET ; return;
#+END_SRC
有些细节大家可能不太明白，但是可以跟memtest_sub比较一下。可以发现，以上的编译结果有点不正常。

harib06b中，memtest_sub的内容

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;

for (i = start; i <= end; i += 0x1000) {

p = (unsigned int *) (i + 0xffc);

old = *p; /* 先记住修改前的值 */

*p = pat0; /* 试写 */

*p ^= 0xffffffff; /* 反转 */

if (*p != pat1) { /* 检查反转结果 */

not_memory:

*p = old;

break;

}

*p ^= 0xffffffff; /* 再次反转 */

if (*p != pat0) { /* 检查值是否恢复 */

goto not_memory;

}

*p = old; /* 恢复为修改前的值 */

}

return i;

}




大家会发现，编译后没有XOR等指令，而且，好像编译后只剩下了for语句。怪不得显示结果是3GB呢。但是，为什么会这样呢？

■■■■■

笔者开始以为这是C编译器的bug，但仔细查一查，发现并非如此。反倒是编译器太过优秀了。

编译器在编译时，应该是按下面思路考虑问题的。

首先将内存的内容保存到old里，然后写入pat0的值，再反转，最后跟pat1进行比较。这不是肯定相等的吗？if语句不成立，得不到执行，所以把它删掉。怎么？下面还要反转吗？这家伙好像就喜欢反转。这次是不是要比较*p和pat0呀？这不是也肯定相等吗？这些处理不是多余么？为了提高速度，将这部分也删掉吧。这样一来，程序就变成了：

编译器脑中所想的（1）

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;

for (i = start; i <= end; i += 0x1000) {

p = (unsigned int *) (i + 0xffc);



old = *p; /* 先记住修改前的值*/

*p = pat0; /* 试写 */

*p ^= 0xffffffff; /* 反转 */

*p ^= 0xffffffff; /* 再次反转 */

*p = old; /* 恢复为修改前的值 */

}

return i;

}




反转了两次会变回之前的状态，所以这些处理也可以不要嘛。因此程序就变成了这样：

编译器脑中所想的（2）

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;

for (i = start; i <= end; i += 0x1000) {

p = (unsigned int *) (i + 0xffc);

old = *p; /* 先记住修改前的值 */

*p = pat0; /* 试写 */

*p = old; /* 恢复为修改前的值 */

}

return i;

}




还有，“*p = pat0;”本来就没有意义嘛。反正要将old的值赋给*p。因此程序就变成了：

编译器脑中所想的（3）

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;

for (i = start; i <= end; i += 0x1000) {

p = (unsigned int *) (i + 0xffc);

old = *p; /* 先记住修改前的值 */

*p = old; /* 恢复为修改前的值 */

}

return i;

}




这程序是什么嘛？结果，*p里面不是没写进任何内容吗？这有什么意义？

编译器脑中所想的（4）

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i, *p, old, pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;

for (i = start; i <= end; i += 0x1000) {

p = (unsigned int *) (i + 0xffc);

}

return i;

}




这里的地址变量p，虽然计算了地址，却一次也没有用到。这么说来，old、pat0、pat1也都是用不到的变量。全部都舍弃掉吧。

编译器脑中所想的（5）

unsigned int memtest_sub(unsigned int start, unsigned int end)

{

unsigned int i;

for (i = start; i <= end; i += 0x1000) { }

return i;

}




好了，这样修改后，速度能提高许多。用户肯定会说：“这编译器真好，速度特别快！”

根据以上编译器的思路，我们可以看出，它进行了最优化处理。但其实这个工作本来是不需要的。用于应用程序的C编译器，根本想不到会对没有内存的地方进行读写。

如果更改编译选项，是可以停止最优化处理的。可是在其他地方，我们还是需要如此考虑周密的最优化处理的，所以不想更改编译选项。那怎样来解决这个问题呢？想来想去，还是觉得很麻烦，于是决定memtest_sub也用汇编来写算了。

这次C编译器只是好心干了坏事，但意外的是，它居然会考虑得如此周到、缜密来进行最优化处理……这个编译器真是聪明啊！顺便说一句，这种事偶尔还会有的，所以能够看见中途结果很有用。而且懂汇编语言很重要。

■■■■■

笔者用汇编语言写的程序列举如下。

本次的naskfunc.nas节选

_memtest_sub: ; unsigned int memtest_sub(unsigned int start, unsigned int end)

PUSH EDI ; （由于还要使用EBX, ESI, EDI）

PUSH ESI

PUSH EBX

MOV ESI,0xaa55aa55 ; pat0 = 0xaa55aa55;

MOV EDI,0x55aa55aa ; pat1 = 0x55aa55aa;

MOV EAX,[ESP+12+4] ; i = start;

mts_loop:

MOV EBX,EAX

ADD EBX,0xffc ; p = i + 0xffc;

MOV EDX,[EBX] ; old = *p;

MOV [EBX],ESI ; *p = pat0;

XOR DWORD [EBX],0xffffffff ; *p ^= 0xffffffff;

CMP EDI,[EBX] ; if (*p != pat1) goto fin;

JNE mts_fin

XOR DWORD [EBX],0xffffffff ; *p ^= 0xffffffff;

CMP ESI,[EBX] ; if (*p != pat0) goto fin;

JNE mts_fin

MOV [EBX],EDX ; *p = old;

ADD EAX,0x1000 ; i += 0x1000;

CMP EAX,[ESP+12+8] ; if (i <= end) goto mts_loop;



JBE mts_loop

POP EBX

POP ESI

POP EDI

RET

mts_fin:

MOV [EBX],EDX ; *p = old;

POP EBX

POP ESI

POP EDI

RET




笔者好久没写过这么长的汇编程序了。程序里加上了足够的注释，应该很好懂。虽然XOR指令（异或）是第一次出现，不过不用特别解释大家也应该能明白。

那好，我们删除bootpack.c中的memtest_sub函数，运行一下看看。“make run”。结果怎么样呢？



内存容量显示正常了

太好了！现在可以回到内存管理这个正题上来了。





4　挑战内存管理（harib06d）

刚才笔者一个劲儿地说内存管理长，内存管理短的，那到底什么是内存管理呢？为什么要进行内存管理呢?

比如说，假设内存大小是128MB，应用程序A暂时需要100KB，画面控制需要1.2MB……，像这样，操作系统在工作中，有时需要分配一定大小的内存，用完以后又不再需要，这种事会频繁发生。为了应付这些需求，必须恰当管理好哪些内存可以使用（哪些内存空闲），哪些内存不可以使用（正在使用），这就是内存管理。如果不进行管理，系统会变得一塌糊涂，要么不知道哪里可用，要么多个应用程序使用同一地址的内存。

内存管理的基础，一是内存分配，一是内存释放。“现在要启动应用程序B了，需要84KB内存，哪儿空着呢？”如果问内存管理程序这么一个问题，内存管理程序就会给出一个能够自由使用的84KB的内存地址，这就是内存分配。另一方面，“内存使用完了，现在把内存归还给内存管理程序”，这一过程就是内存的释放过程。

■■■■■

先假设有128MB的内存吧。也就是说，有0x08000000个字节。另外我们假设以0x1000个字节（4KB）为单位进行管理。大家会如何管理呢？答案有很多，我们从简单的方法开始介绍。

0x08000000/0x1000 = 0x08000 = 32768，所以首先我们来创建32768字节的区域，可以往其中写入0或者1来标记哪里是空着的，哪里是正在使用的。

char a[32768];

for (i = 0; i < 1024; i++) {

a[i] = 1; /* 一直到4MB为止，标记为正在使用 */

}

for (i = 1024; i < 32768; i++) {

a[i] = 0; /* 剩下的全部标记为空 */

}




比如需要100KB的空间，那么只要从a中找出连续25个标记为0的地方就可以了。

j = 0;

再来一次:

for (i = 0; i < 25; i++) {

if (a[j + i] != 0) {

j++;

if (j < 32768 - 25) goto 再来一次;

"没有可用内存了";

}

}

"从a[j]到a[j + 24]为止，标记连续为0";




如果找到了标记连续为0的地方，暂时将这些地方标记为“正在使用”，然后从j的值计算出对应的地址。这次是以0x1000字节为管理单位的，所以将j放大0x1000倍就行了。

for (i = 0; i < 25; i++) {

a[j + i] = 1;

}

"从 j * 0x1000 开始的100KB空间得到分配";




■■■■■

如果要释放这部分内存空间，可以像下面这样做。比如，如果遇到这种情况：“刚才取得的从0x00123000开始的100KB，已经不用了，现在归还。谢谢你呀。”那该怎么办呢？用地址值除以0x1000，计算出j就可以了。

j = 0x00123000 / 0x1000;

for (i = 0; i < 25; i++) {

a[j + i] = 0;

}




很简单吧。以后再有需要内存的时候，这个地方又可以再次被使用了。

■■■■■

上面这个方法虽然很好懂，但是有一点问题。如果内存是128MB，管理表只需要32768字节（32KB）；如果内存最大是3GB，管理表是多大呢？0xc0000000 / 0x1000 = 0xc0000 = 786432，也就是说光管理表就需要768KB。当然，虽说768KB不小，但从3GB看来，只不过是0.02%。

事实上，0.02%的比例是与容量没有关系的。用32KB管理128MB时，比例也是0.02%。如果容量是个问题，这个管理表可以不用char来构成，而是使用位（bit）来构成。归根到底，储存的只有0和1，用不了一个字节，一位就够了。这样做，程序会变得复杂些，但是管理表的大小可缩减到原来的1/8。如果是3GB内存，只需要96KB就可以管理整个内存了。这个比例只有0.003%。

我们后面还会讲到，这虽然不是最好的方法，但Windows的软盘管理方法，与这个方法很接近（1.44MB的容量，以512字节为单位分块管理）。

■■■■■

除了这个管理方法之外，还有一种列表管理的方法，是把类似于“从xxx号地址开始的yyy字节的空间是空着的”这种信息都列在表里。

struct FREEINFO { /* 可用状况 */

unsigned int addr, size;

};



struct MEMMAN { /* 内存管理 */

int frees;

struct FREEINFO free[1000];

};



struct MEMMAN memman;

memman.frees = 1; /* 可用状况list中只有1件 */

memman.free[0].addr = 0x00400000; /* 从0x00400000号地址开始，有124MB可用 */

memman.free[0].size = 0x07c00000;




大体就是这个样子。之所以有1000个free，是考虑到即使可用内存部分不连续，我们也能写入到这1000个free里。memman是笔者起的名字，代表memory manager。

比如，如果需要100KB的空间，只要查看memman中free的状况，从中找到100MB以上的可用空间就行了。

for (i = 0; i < memman.frees; i++) {

if (memman.free[i].size >= 100 * 1024) {

"找到可用空间！";

"从地址memman.free[i].addr开始的100KB空间，可以使用哦！";

}

}

"没有可用空间";




如果找到了可用内存空间，就将这一段信息从“可用内存空间管理表”中删除。这相当于给这一段内存贴上了“正在使用”的标签。

memman.free[i].addr += 100 * 1024; /* 可用地址向后推进了100KB */

memman.free[i].size -= 100 * 1024; /* 减去100KB */




如果size变成了0，那么这一段可用信息就不再需要了，将这条信息删除，frees减去1就可以了。

释放内存时，增加一条可用信息，frees加1。而且，还要调查一下这段新释放出来的内存，与相邻的可用空间能不能连到一起。如果能连到一起，就把它们归纳为一条。

能够归纳为一条的例子：

free[0]:地址0x00400000号开始，0x00019000字节可用

free[1]:地址0x00419000号开始，0x07be7000字节可用

可以归纳为

free[0]:地址0x00400000号开始，0x07c00000字节可用

如果不将它们归纳为一条，以后系统要求“请给我提供0x07bf0000字节的内存”时，本来有这么多的可用空间，但以先前的查找程序却会找不到。

■■■■■

上述新方法的优点，首先就是占用内存少。memman是8×1000 + 4 = 8004，还不到8KB。与上一种方法的32KB相比，差得可不少。而且，这里的1000是个很充裕的数字。可用空间不可能如此零碎分散（当然，这与内存的使用方法有关）。所以，这个数字或许能降到100。这样的话，只要804字节就能管理128MB的内存了。

如果用这种新方法，就算是管理3GB的内存，也只需要8KB左右就够了。当然，可用内存可能更零碎些，为了安全起见，也可以设定10000条可用区域管理信息。即使这样也只有80KB。

这样新方法，还有其他优点，那就是大块内存的分配和释放都非常迅速。比如我们考虑分配10MB内存的情形。如果按前一种方法，就要写入2560个“内存正在使用”的标记“1”，而释放内存时，要写入2560个“0”。这些都需要花费很长的时间。

另一方面，这种新方法在分配内存时，只要加法运算和减法运算各执行一次就结束了。不管是10MB也好，100MB也好，还是40KB，任何情况都一样。释放内存的时候虽然没那么快，但是与写入2560个“0”相比，速度快得可以用“一瞬间”来形容。

■■■■■

事情总是有两面性的，占用内存少，分配和释放内存速度快，现在看起来全是优点，但是实际上也有缺点，首先是管理程序变复杂了。特别是将可用信息归纳到一起的处理，变得相当复杂。

还有一个缺点是，当可用空间被搞得零零散散，怎么都归纳不到一块儿时，会将1000条可用空间管理信息全部用完。虽然可以认为这几乎不会发生，但也不能保证绝对不能发生。这种情况下，要么做一个更大的MEMMAN，要么就只能割舍掉小块内存。被割舍掉的这部分内存，虽然实际上空着，但是却被误认为正在使用，而再也不能使用。

为了解决这一问题，实际上操作系统想尽了各种办法。有一种办法是，暂时先割舍掉，当memman有空余时，再对使用中的内存进行检查，将割舍掉的那部分内容再捡回来。还有一种方法是，如果可用内存太零碎了，就自动切换到之前那种管理方法。

那么，我们的“纸娃娃系统”（haribote OS）会采用什么办法呢？笔者经过斟酌，采用了这样一种做法，即“割舍掉的东西，只要以后还能找回来，就暂时不去管它。”。如果我们陷在这个问题上不能自拔，花上好几天时间，大家就会厌烦的。笔者还是希望大家能开开心心心地开发“纸娃娃系统”。而且万一出了问题，到时候我们再回过头来重新修正内存管理程序也可以。

■■■■■

根据这种思路，笔者首先创建了以下程序。

本次的bootpack.c节选

#define MEMMAN_FREES 4090 /* 大约是32KB*/



struct FREEINFO { /* 可用信息 */

unsigned int addr, size;

};



struct MEMMAN { /* 内存管理 */

int frees, maxfrees, lostsize, losts;

struct FREEINFO free[MEMMAN_FREES];

};



void memman_init(struct MEMMAN *man)

{

man->frees = 0; /* 可用信息数目 */

man->maxfrees = 0; /* 用于观察可用状况：frees的最大值 */

man->lostsize = 0; /* 释放失败的内存的大小总和 */

man->losts = 0; /* 释放失败次数 */

return;

}



unsigned int memman_total(struct MEMMAN *man)

/* 报告空余内存大小的合计 */

{

unsigned int i, t = 0;

for (i = 0; i < man->frees; i++) {

t += man->free[i].size;

}

return t;

}



unsigned int memman_alloc(struct MEMMAN *man, unsigned int size)

/* 分配 */

{

unsigned int i, a;

for (i = 0; i < man->frees; i++) {

if (man->free[i].size >= size) {

/* 找到了足够大的内存 */

a = man->free[i].addr;

man->free[i].addr += size;

man->free[i].size -= size;

if (man->free[i].size == 0) {

/* 如果free[i]变成了0，就减掉一条可用信息 */

man->frees--;

for (; i < man->frees; i++) {

man->free[i] = man->free[i + 1]; /* 代入结构体 */

}

}

return a;

}

}

return 0; /* 没有可用空间 */

}




一开始的struct MEMMAN，只有1000组的话，可能不够。所以，我们创建了4000组，留出不少余量。这样一来，管理空间大约是32KB。其中还有变量 maxfrees、lostsize、losts等，这些变量与管理本身没有关系，不用在意它们。如果特别想了解的话，可以看看函数memman_init的注释，里面有介绍。

函数memman_init对memman进行了初始化，设定为空。主要工作，是将frees设为0，而其他的都是附属性设定。这里的init，是initialize（初始化）的缩写。

函数memman_total用来计算可用内存的合计大小并返回。笔者觉得有这个功能应该很方便，所以就创建了这么一个函数。原理很简单，不用解释大家也会明白。total这个英文单词，是“合计”的意思。

最后的memman_alloc函数，功能是分配指定大小的内存。除了free[i].size变为0时的处理以外的部分，在前面已经说过了。alloc是英文allocate（分配）的缩写。在编程中，需要分配内存空间时，常常会使用allocate这个词。

memman_alloc函数中free[i].size等于0的处理，与FIFO缓冲区的处理方法很相似，要进行移位处理。希望大家注意以下写法：

man->free[i].addr = man->free[i+1].addr;

man->free[i].size = man->free[i+1].size;

我们在这里将其归纳为了：

man->free[i] = man->free[i+1];

这种方法被称为结构体赋值，其使用方法如上所示，可以写成简单的形式。

■■■■■

释放内存函数，也就是往memman里追加可用内存信息的函数，稍微有点复杂。

本次的bootpack.c节选

int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size)

/* 释放 */

{

int i, j;

/* 为便于归纳内存，将free[]按照addr的顺序排列 */

/* 所以，先决定应该放在哪里 */

for (i = 0; i < man->frees; i++) {

if (man->free[i].addr > addr) {

break;

}

}

/* free[i - 1].addr < addr < free[i].addr */

if (i > 0) {

/* 前面有可用内存 */

if (man->free[i - 1].addr + man->free[i - 1].size == addr) {



/* 可以与前面的可用内存归纳到一起 */

man->free[i - 1].size += size;

if (i < man->frees) {

/* 后面也有 */

if (addr + size == man->free[i].addr) {

/* 也可以与后面的可用内存归纳到一起 */

man->free[i - 1].size += man->free[i].size;

/* man->free[i]删除 */

/* free[i]变成0后归纳到前面去 */

man->frees--;

for (; i < man->frees; i++) {

man->free[i] = man->free[i + 1]; /* 结构体赋值 */

}

}

}

return 0; /* 成功完成 */

}

}

/* 不能与前面的可用空间归纳到一起 */

if (i < man->frees) {

/* 后面还有 */

if (addr + size == man->free[i].addr) {

/* 可以与后面的内容归纳到一起 */

man->free[i].addr = addr;

man->free[i].size += size;

return 0; /* 成功完成 */

}

}

/* 既不能与前面归纳到一起，也不能与后面归纳到一起 */

if (man->frees < MEMMAN_FREES) {

/* free[i]之后的，向后移动，腾出一点可用空间 */

for (j = man->frees; j > i; j--) {

man->free[j] = man->free[j - 1];

}

man->frees++;

if (man->maxfrees < man->frees) {

man->maxfrees = man->frees; /* 更新最大值 */

}

man->free[i].addr = addr;

man->free[i].size = size;

return 0; /* 成功完成 */

}

/* 不能往后移动 */

man->losts++;

man->lostsize += size;

return -1; /* 失败 */

}




程序太长了，用文字来描述不易于理解，所以笔者在程序里加了注释。如果理解了以前讲解的原理，现在只要细细读一读程序，大家肯定能看懂。

另外，我们前面已经说过，如果可用信息表满了，就按照舍去之后带来损失最小的原则进行割舍。但是在这个程序里，我们并没有对损失程度进行比较，而是舍去了刚刚进来的可用信息，这只是为了图个方便。

■■■■■

最后，将这个程序应用于HariMain，结果就变成了下面这样。写着“（中略）”的部分，笔者没做修改。

本次的bootpack.c节选

#define MEMMAN_ADDR 0x003c0000



void HariMain(void)

{

（中略）

unsigned int memtotal;

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

（中略）

memtotal = memtest(0x00400000, 0xbfffffff);

memman_init(memman);

memman_free(memman, 0x00001000, 0x0009e000); /* 0x00001000 - 0x0009efff */

memman_free(memman, 0x00400000, memtotal - 0x00400000);

（中略）

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc(binfo->vram, binfo->scrnx, 0, 32, COL8_FFFFFF, s);




memman需要32KB，我们暂时决定使用自0x003c0000开始的32KB（0x00300000号地址以后，今后的程序即使有所增加，预计也不会到达0x003c0000，所以我们使用这一数值），然后计算内存总量memtotal，将现在不用的内存以0x1000个字节为单位注册到memman里。最后，显示出合计可用内存容量。在QEMU上执行时，有时会注册成632KB和28MB。632+28672=29304，所以屏幕上会显示出29304KB。

那好，运行一下“make run”看看。哦，运行正常。今天已经很晚了，我们明天继续吧。



能正常显示出29304KB





第10天　叠加处理



内存管理（续）（harib07a）

叠加处理（harib07b）

提高叠加处理速度（1）（harib07c）

提高叠加处理速度（2）（harib07d）





1　内存管理（续）（harib07a）

得益于昨天的努力，我们终于可以进行内存管理了。不过仔细一看会注意到，bootpack.c都已经有254行了。笔者感觉这段程序太长了，决定整理一下，分出一部分到memory.c中去。（整理中）……好了，整理完了。现在bootpack.c变成95行了。

为了以后使用起来更加方便，我们还是把这些内存管理函数再整理一下。memman_alloc和memman_free能够以1字节为单位进行内存管理，这种方式虽然不错，但是有一点不足——在反复进行内存分配和内存释放之后，内存中就会出现很多不连续的小段未使用空间，这样就会把man—>frees消耗殆尽。

因此，我们要编写一些总是以0x1000字节为单位进行内存分配和释放的函数，它们会把指定的内存大小按0x1000字节为单位向上舍入（ roundup），而之所以要以0x1000字节为单位，是因为笔者觉得这个数比较规整。另外，0x1000字节的大小正好是4KB。

本次的*memory.c节选

unsigned int memman_alloc_4k(struct MEMMAN *man, unsigned int size)

{

unsigned int a;

size = (size + 0xfff) & 0xfffff000;

a = memman_alloc(man, size);

return a;

}



int memman_free_4k(struct MEMMAN *man, unsigned int addr, unsigned int size)

{

int i;

size = (size + 0xfff) & 0xfffff000;

i = memman_free(man, addr, size);

return i;

}




■■■■■

下面我们来看看这次增加的部分，这里的关键是向上舍入，可是如果上来就讲向上舍入的话可能不太好懂，所以我们还是先从向下舍入（round down）讲起吧。

讲数字问题时，以钱为例大家可能更容易理解，所以我们就用钱来举例说明。比如，把123元以10元为单位进行向下舍入，就是120元；把456元以100元为单位进行向下舍入，就是400元。通过这些例子，你会发现“所谓向下舍入，就是把最后几位数字强制变为0”。

所以如果将0x12345678以0x1000为单位进行向下舍入，得到的就应该是0x12345000吧？没错，这就是正确答案。这样一来，用纸笔就可以进行向下舍入运算了。不过，如果我们要写个程序让电脑来做同样的事，那该怎么办才好呢？

在二进制下，如果我们想把某位变为0，只要进行“与运算”就可以了，这在4.2节已经介绍过了。而十六进制其实就是把二进制数4位4位地排在一起，所以要想把十六进制的某一位设置为0，同样只进行“与运算”就可以。

0x12345678 & 0xfffff000 = 0x12345000

因此把变量i中的数字以0x1000为单位进行向下舍入的式子如下：

i = i & 0xfffff000;

顺便告诉大家一下，以0x10为单位向下舍入的式子是“i =i & 0xfffffff0;”。这样我们就掌握了向下舍入的方法。

■■■■■

下面我们来看看向上舍入。如果把123元以10元为单位进行向上舍入，就是130元；把456元以100元为单位进行向上舍入，就是500元。嗯嗯，原来如此，看来先向下舍入，再在它的结果上做个加法运算就可以了。

以0x1000为单位对0x12345678进行向上舍入的结果为0x12346000。所以有人可能会问：“要是用程序来表达这个过程的话就应该写成这样吧？”

i = (i & 0xfffff000) + 0x1000;

看起来貌似确实不错，但其实这并不是正确答案。 因为如果“i = 0x12345000;”时执行上述命令，结果就变成了“i=0x12346000;”。这当然不对啦。这就相当于，以10元为单位对120元进行向上舍入，结果为130元，但实际上120 元向上舍入后应该还是120元。

所以我们要对程序进行改进。具体做法是：先判断最后几位，如果本来就是零则什么也不做，如果不是零就进行下面的运算。

if ((i & 0xfff) ! = 0) { i = (i & 0xfffff000) + 0x1000;}

这样问题就解决了。大功告成。

■■■■■

现在我们可以灵活自由地进行向下舍入和向上舍入了，而实际上向上舍入还有改进的“窍门”，那就是：

i = (i + 0xfff) & 0xfffff000;

这是怎么回事呢？实际上这是“加上0xfff后进行向下舍入”的运算。不论最后几位是什么，都可以用这个公式进行向上舍入运算。真的吗？

由于十六进制不易理解，所以我们还是以钱的十进制运算为例来说明吧。如使用这个方法以100元为单位对456元进行向上舍入，就相当于先加上99元再进行向下舍入。456元加上99元是555元，向下舍入后就是500元了。嗯，这方法做出来的答案没错，456元向上舍入的结果确实就是500元。

那么如果对400元进行向上舍入呢？先加上99元，得到499元，再进行向下舍入，结果是400元。看，400元向上舍入的结果还是400元。

这种方法多方便呀，可比if语句什么的好用多了。不过其中的原理是什么呢？其实加上99元就是判断进位，如果最后两位不是00，就要向前进一位，只有当最后两位是00时，才不需要进位。接下来再向下舍入，这样就正好把因为加法运算而改变的后两位设置成00了。看，向上舍入就成功了。

这个技巧并不是笔者想出来的，忘了是从哪本书上看到的。能想到这么做的人真是相当聪明呢。既然有了这么方便的技巧，我们没道理不用，在此笔者大力推荐给大家。而在memman_alloc_4k和memman_free_4k中也大量使用了该技巧。

那么试着“make run”一下吧。可是没有任何反应呀！那当然了，这次做的新函数，还没有被调用呢。

COLUMN-6　十进制数的向下舍入

上面介绍了“与运算”可以应用于二进制数和十六进制数的向下舍入，那么对于我们所熟悉的十进制数的向下舍入，也能使用“与运算”吗?

以0x10为单位对变量 i 进行向下舍入时，实际上是进行了“i = i & 0xfffffff0；”处理,可以将它看成“i = i &(0x100000000 - 0x10)；”。同样，以0x100为单位进行向下舍入时，进行的是“i = i & 0xffffff00；”处理，所以这也可以看成是“i = i & (0x100000000 - 0x100)； ”。也就是说，我们好像可以归纳出“i = i & (0x100000000 - 向下舍入单位)；”。

按照以上思路，如果以100为单位对变量i进行向下舍入，就可以按照“i = i & (0x100000000 - 100)；”，即“i = i & 0xffffff9c；”来处理。但这样做并不成功。假设“i = 123；”，结果是123& 0xffffff9c=24，没有得到我们的预期答案100。

不愿轻易放弃的人可以尝试更多的计算式，不过没有一个能成功,因为不能用“与运算”来进行十进制数的向下舍入处理，“与运算”只能用于二进制数的向下舍入处理。而十六进制数因为是4位4位排在一起的二进制数，所以凑巧成功了。

这倒不是说无法对二进制和十六进制以外的数进行向下舍入处理,只不过是不能使用“与运算”而已。如果允许使用其他方法，一样可以轻松地进行计算。例如“i = (i / 100)*100；”,只需要先除以100再乘以100就可以了。我们来假设“i=123”，123除以100，结果是1（当整数除以整数时，答案还是整数，所余的数值叫做“余数”），再用1乘以100就得到了我们的预期结果100。再假设“i = 456；”，那么先除以100得到4，再扩大100倍结果就是400，这个答案也是正确的。

我们还可以把计算方法进一步改进一下，写成“i = i - (i %100)；”，意思是用 i 减去 i 除以100所得的余数。这种方法只用了除法和减法计算，比既用除法又用乘法要快。

不管采用以上哪种方法，在以2_n_（n>0）以外的数为单位进行向下舍入和向上舍入处理时，都必须要使用除法命令，而它恰恰是CPU最不好处理的命令之一，所以计算过程要花费较长的时间（当然，在我们看来是一瞬间就结束了）。而“与”命令是所有CPU命令中速度最快的命令之一，和除法命令相比其执行速度要快10倍到100倍。

由此可见，如果以1000字节或4000字节单位进行内存管理的话，每次分配内存时，都不得不进行繁琐的除法计算。但如果以1024字节或4096字节为单位进行内存管理的话（两者都是在二进制下易于取整的数字。附带说明:0x1000 = 4096），在向上舍入的计算中就可以使用“与运算”，这样也能够提高操作系统的运行速度，因此笔者认为这个设计很高明。





2　叠加处理（harib07b）

上一节我们为了转换心情，做了内存管理的探讨，现在还是回过头来，继续解决鼠标的问题吧。从各方面深入思考鼠标的叠加处理确实很有意思，不过考虑到今后我们还面临着窗口的叠加处理问题，所以笔者想做这么一段程序，让它不仅适用于鼠标的叠加处理，也能直接适用于窗口的叠加处理。

■■■■■

其实在画面上进行叠加显示，类似于将绘制了图案的透明图层1叠加在一起。

1 读者朋友如果对图像处理软件中的“层”有所了解，也许脑海中会立刻浮现出这个概念。



实际上，我们并不是像上面那样仅仅把两张大小相同的图层重叠在一起，而是要从大到小准备很多张图层。

最上面的小图层用来描绘鼠标指针，它下面的几张图层是用来存放窗口的，而最下面的一张图层用来存放桌面壁纸。同时，我们还要通过移动图层的方法实现鼠标指针的移动以及窗口的移动。



■■■■■

我们想法已经有了，下面就把它们变成程序吧。首先来考虑如何将一个图层的信息编成程序。

struct SHEET {

unsigned char *buf;

int bxsize, bysize, vx0, vy0, col_inv, height, flags;

}




暂时先写成这样就可以了。程序里的sheet这个词，表示“透明图层”的意思。笔者觉得英文里没有和“透明图层”接近的词，就凭感觉选了它。buf是用来记录图层上所描画内容的地址（buffer的略语）。图层的整体大小，用bxsize*bysize表示。vx0和vy0是表示图层在画面上位置的坐标，v是VRAM的略语。col_inv表示透明色色号，它是color（颜色）和invisible（透明）的组合略语。height表示图层高度。Flags用于存放有关图层的各种设定信息。

只有一个图层是不能实现叠加处理的，所以下面我们来创建一个管理多重图层信息的结构。

#define MAX_SHEETS 256



struct SHTCTL {

unsigned char *vram;

int xsize, ysize, top;

struct SHEET *sheets[MAX_SHEETS];

struct SHEET sheets0[MAX_SHEETS];

};




我们创建了SHTCTL结构体，其名称来源于sheet control的略语，意思是“图层管理”。 MAX_SHEETS是能够管理的最大图层数，这个值设为256应该够用了。

变量vram、xsize、ysize代表VRAM的地址和画面的大小，但如果每次都从BOOTINFO查询的话就太麻烦了，所以在这里预先对它们进行赋值操作。top代表最上面图层的高度。sheets0这个结构体用于存放我们准备的256个图层的信息。而sheets是记忆地址变量的领域，所以相应地也要先准备256份。这是干什么用呢？由于sheets0中的图层顺序混乱，所以我们把它们按照高度进行升序排列，然后将其地址写入sheets中，这样就方便多了。

不知不觉我们已经写了很多了，不过也许个别地方大家还不太明白，与其在这纸上谈兵，不如直接看程序更易于理解。所以前面的说明部分，大家即使不懂也别太在意，先往下看吧。

在这里我们稍微说一下结构体吧。内容不难，只是确认大家是不是真正理解了这个概念。struct SHTCTL结构体的内部既有子结构体，又有结构体的指针数组，稍稍有些复杂，不过却是一个不错的例子。

我们的这个例子并不是用文字来解说，而是通过图例展示给大家。请大家看看下面这幅图，确认一下是否理解了结构体。

我们提到的图层控制变量中，仅仅sheets0的部分大小就有32× 256=8 192，即8KB，如果再加上sheets的话，就超过了9KB。对于空间需要如此大的变量，我们想赶紧使用memman_alloc_4k来分配内存空间，所以就编写了对内存进行分配和初始化的函数。



■■■■■

本次的*sheet.c节选

struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)

{

struct SHTCTL *ctl;

int i;

ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL));

if (ctl == 0) {

goto err;

}

ctl->vram = vram;

ctl->xsize = xsize;

ctl->ysize = ysize;

ctl->top = -1; /*一个SHEET没都有 */

for (i = 0; i < MAX_SHEETS; i++) {

ctl->sheets0[i].flags = 0; /* 标记为未使用 */

}

err:

return ctl;

}




这段程序是什么的呢？首先使用memman_alloc_4k来分配用于记忆图层控制变量的内存空间，这时必须指定该变量所占空间的大小，不过我们可以使用sizeof（struct SHTCTL）这种写法，让C编译器自动计算。只要写sizeof（变量型），C编译器就会计算出该变量型所需的字节数。

接着，我们给控制变量赋值，给其下的所有图层变量都加上“未使用”标签。做完这一步，这个函数就完成了。

■■■■■

下面我们再做一个函数，用于取得新生成的未使用图层。

本次的*sheet.c节选

#define SHEET_USE 1



struct SHEET *sheet_alloc(struct SHTCTL *ctl)

{

struct SHEET *sht;

int i;

for (i = 0; i < MAX_SHEETS; i++) {

if (ctl->sheets0[i].flags == 0) {

sht = &ctl->sheets0[i];

sht->flags = SHEET_USE; /* 标记为正在使用*/

sht->height = -1; /* 隐藏 */

return sht;

}

}

return 0; /* 所有的SHEET都处于正在使用状态*/

}




在sheets0[ ]中寻找未使用的图层，如果找到了，就将其标记为“正在使用”，并返回其地址就可以了，这里没有什么难点。高度设为-1，表示图层的高度还没有设置，因而不是显示对象。

程序中出现的&ctl—>sheets0[i]是“ctl—>sheets0[i]的地址”的意思。也就是说，指的是&（ctl—>sheets0[i]），而不是（&ctl）—> sheets0[i]。

■■■■■

本次的*sheet.c节选

void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv)

{

sht->buf = buf;

sht->bxsize = xsize;

sht->bysize = ysize;

sht->col_inv = col_inv;

return;

}




这是设定图层的缓冲区大小和透明色的函数，这也没什么难点。

■■■■■

接下来我们写设定底板高度的函数。这稍微有些复杂，所以我们在程序中加入了不少注释。这里的updown就是“上下”的意思。

本次的*sheet.c节选

void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height)

{

int h, old = sht->height; /* 存储设置前的高度信息 */



/* 如果指定的高度过高或过低，则进行修正 */

if (height > ctl->top + 1) {

height = ctl->top + 1;

}

if (height < -1) {

height = -1;

}

sht->height = height; /* 设定高度 */



/* 下面主要是进行sheets[ ]的重新排列 */

if (old > height) { /* 比以前低 */

if (height >= 0) {

/* 把中间的往上提 */

for (h = old; h > height; h--) {

ctl->sheets[h] = ctl->sheets[h - 1];

ctl->sheets[h]->height = h;

}

ctl->sheets[height] = sht;

} else { /* 隐藏 */

if (ctl->top > old) {

/* 把上面的降下来 */

for (h = old; h < ctl->top; h++) {



ctl->sheets[h] = ctl->sheets[h + 1];

ctl->sheets[h]->height = h;

}

}

ctl->top--; /* 由于显示中的图层减少了一个，所以最上面的图层高度下降 */

}

sheet_refresh(ctl); /* 按新图层的信息重新绘制画面 */

} else if (old < height) { /* 比以前高 */

if (old >= 0) {

/* 把中间的拉下去 */

for (h = old; h < height; h++) {

ctl->sheets[h] = ctl->sheets[h + 1];

ctl->sheets[h]->height = h;

}

ctl->sheets[height] = sht;

} else { /* 由隐藏状态转为显示状态 */

/* 将已在上面的提上来 */

for (h = ctl->top; h >= height; h--) {

ctl->sheets[h + 1] = ctl->sheets[h];

ctl->sheets[h + 1]->height = h + 1;

}

ctl->sheets[height] = sht;

ctl->top++; /* 由于已显示的图层增加了1个，所以最上面的图层高度增加 */

}

sheet_refresh(ctl); /* 按新图层信息重新绘制画面 */

}

return;

}




程序稍稍有些长，不过既然大家能看懂前面的程序，那么这个程序应该也是可以看明白的。每一条语句并不比之前的语句难，只是整个程序变长了而已。最初可能很难看进去，但是如果一直坚持读下去的话，阅读程序的能力就会越来越强。

程序中间有“ctl—>sheets[h] —>height = h；”这样一句话。两个[—>]一起出现估计还是第一次，不过大家应该懂吧。这当然是“(*(*ctl).sheets[h]).height = h；”的意思了。

要是改写为下面这样，就好理解了。

struct SHEET *sht2;

sht2 = ctl->sheets[h];

sht2 -> height = h;




■■■■■

下面来说说在sheet_updown中使用的sheet_refresh函数。这个函数会从下到上描绘所有的图层。refresh是“刷新”的意思。电视屏幕就是在1秒内完成多帧的描绘才做出动画效果的，这个动作就被称为刷新。而这种对图层的刷新动作，与电视屏幕的动作有些相似，所以我们也给它起名字叫做刷新。

本次的*sheet.c节选

void sheet_refresh(struct SHTCTL *ctl)

{

int h, bx, by, vx, vy;

unsigned char *buf, c, *vram = ctl->vram;

struct SHEET *sht;

for (h = 0; h <= ctl->top; h++) {

sht = ctl->sheets[h];

buf = sht->buf;

for (by = 0; by < sht->bysize; by++) {

vy = sht->vy0 + by;

for (bx = 0; bx < sht->bxsize; bx++) {

vx = sht->vx0 + bx;

c = buf[by * sht->bxsize + bx];

if (c != sht->col_inv) {

vram[vy * ctl->xsize + vx] = c;

}

}

}

}

return;

}




对于已设定了高度的所有图层而言，要从下往上，将透明以外的所有像素都复制到VRAM中。由于是从下开始复制，所以最后最上面的内容就留在了画面上。

■■■■■

现在我们来看一下不改变图层高度而只上下左右移动图层的函数——sheet_slide。slide原意是“滑动”，这里指上下左右移动图层。

本次的*sheet.c节选

void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0)

{

sht->vx0 = vx0;

sht->vy0 = vy0;

if (sht->height >= 0) { /* 如果正在显示*/

sheet_refresh(ctl); /* 按新图层的信息刷新画面 */

}

return;

}




■■■■■

最后是释放已使用图层的内存的函数sheet_free。这个简单。

本次的*sheet.c节选

void sheet_free(struct SHTCTL *ctl, struct SHEET *sht)

{

if (sht->height >= 0) {

sheet_updown(ctl, sht, -1); /* 如果处于显示状态，则先设定为隐藏 */

}

sht->flags = 0; /* "未使用"标志 */

return;

}




■■■■■

下面我们将以上与图层相关的程序汇总到sheet.c中，所以就要改造HariMain函数了。

本次的*bootpack.c节选

void HariMain(void)

{

（中略）

struct SHTCTL *shtctl;

struct SHEET *sht_back, *sht_mouse;

unsigned char *buf_back, buf_mouse[256];



（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);

sht_back = sheet_alloc(shtctl);

sht_mouse = sheet_alloc(shtctl);

buf_back = (unsigned char *) memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);

sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /* 没有透明色 */

sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99); /* 透明色号99 */

init_screen8(buf_back, binfo->scrnx, binfo->scrny);

init_mouse_cursor8(buf_mouse, 99); /* 背景色号99 */

sheet_slide(shtctl, sht_back, 0, 0);

mx = (binfo->scrnx - 16) / 2; /* 按显示在画面中央来计算坐标 */

my = (binfo->scrny - 28 - 16) / 2;

sheet_slide(shtctl, sht_mouse, mx, my);

sheet_updown(shtctl, sht_back, 0);

sheet_updown(shtctl, sht_mouse, 1);

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);

sheet_refresh(shtctl);



for (;;) {

io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {

io_stihlt();

} else {

if (fifo8_status(&keyfifo) != 0) {

i = fifo8_get(&keyfifo);

io_sti();

sprintf(s, "%02X", i);

boxfill8(buf_back, binfo->scrnx, COL8_008484, 0, 16, 15, 31);

putfonts8_asc(buf_back, binfo->scrnx, 0, 16, COL8_FFFFFF, s);

sheet_refresh(shtctl);

} else if (fifo8_status(&mousefifo) != 0) {

i = fifo8_get(&mousefifo);

io_sti();

if (mouse_decode(&mdec, i) != 0) {

/* 因为已得到3字节的数据所以显示 */

sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);

if ((mdec.btn & 0x01) != 0) {

s[1] = 'L';

}

if ((mdec.btn & 0x02) != 0) {

s[3] = 'R';

}

if ((mdec.btn & 0x04) != 0) {

s[2] = 'C';



}

boxfill8(buf_back, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);

putfonts8_asc(buf_back, binfo->scrnx, 32, 16, COL8_FFFFFF, s);

/* 移动光标 */

mx += mdec.x;

my += mdec.y;

if (mx < 0) {

mx = 0;

}

if (my < 0) {

my = 0;

}

if (mx > binfo->scrnx - 16) {

mx = binfo->scrnx - 16;

}

if (my > binfo->scrny - 16) {

my = binfo->scrny - 16;

}

sprintf(s, "(%3d, %3d)", mx, my);

boxfill8(buf_back, binfo->scrnx, COL8_008484, 0, 0, 79, 15); /* 消坐标 */

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s); /* 写坐标 */

sheet_slide(shtctl, sht_mouse, mx, my); /* 包含sheet_refresh含sheet_refresh */

}

}

}

}

}




我们准备了2个图层，分别是sht_back和sht_mouse，还准备了2个缓冲区buf_back和buf_mouse，用于在其中描绘图形。以前我们指定为binfo —> vram的部分，现在有很多都改成了buf_back。而且每次修改缓冲区之后都要刷新。这段代码不是很难，只要大家认认真真地读，肯定能理解。

好了，终于可以“make run”了，真是激动人心的一刻！



成功啦 很好很好！

成功地运行啦！真开心！由于使用的内存增加，从而导致剩余内存相对减少，但这也是不可避免的，现在这样就可以了。

不过其实这里面还是有问题。从图片来看确实很完美，可实际操作一下，你恐怕就要喊“吐血啦！”。没错，它太慢了，而且画面还一闪一闪的。动一下鼠标就要郁闷一次，哪个用户想用这样的操作系统呢？所以下面我们就来解决这个问题吧。





3　提高叠加处理速度（1）（harib07c）

那么怎样才能提高速度呢？既然其他操作系统都能处理得那么快，就肯定有好的方法。首先，我们从鼠标指针的移动，也就是图层的移动来思考一下。

鼠标指针虽然最多只有16×16=256个像素，可根据harib07b的原理，只要它稍一移动，程序就会对整个画面进行刷新，也就是重新描绘320×200=64 000个像素。而实际上，只重新描绘移动相关的部分，也就是移动前后的部分就可以了，即256×2=512个像素。这只是64 000像素的0.8%而已，所以有望提速很多。现在我们根据这个思路写一下程序。

■■■■■

本次的*sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)

{

int h, bx, by, vx, vy;

unsigned char *buf, c, *vram = ctl->vram;

struct SHEET *sht;

for (h = 0; h <= ctl->top; h++) {

sht = ctl->sheets[h];

buf = sht->buf;

for (by = 0; by < sht->bysize; by++) {

vy = sht->vy0 + by;

for (bx = 0; bx < sht->bxsize; bx++) {

vx = sht->vx0 + bx;

if (vx0 <= vx && vx < vx1 && vy0 <= vy && vy < vy1) {

c = buf[by * sht->bxsize + bx];

if (c != sht->col_inv) {

vram[vy * ctl->xsize + vx] = c;

}

}

}

}

}

return;

}




这个函数几乎和sheet_refresh一样，唯一的不同点在于它能使用vx0～ vy1指定刷新的范围，而我们只追加了一个if语句就实现了这个新功能。另外，程序中的&&运算符是我们之前没有见过的，所以在这里详细解释一下。

&&运算符是把多个条件关系式连接起来的运算符。当用它连接的所有条件都满足时，就执行{ }中的程序；只要有一个条件不满足，就不执行（如果有else，就执行else后的语句）。另外，还有一个跟它很像的运算符“||”。“ ||”也是把多个条件关系式连接起来的运算符，不过由它连接的各个条件，只要其中一个满足了，就执行{ }中的程序。简而言之，&&就是“而且”，而 || 是“或者”。

条件“vx大于等于vx0且小于vx1”可以用数学式vx0 <= vx < vx1来表达，但在C语言中不能这样写，我们只能写成 vx0 <= vx && vx < vx1。

■■■■■

现在我们使用这个refreshsub函数来提高sheet_slide的运行速度。

本次的*sheet.c节选

void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0)

{

int old_vx0 = sht->vx0, old_vy0 = sht->vy0;

sht->vx0 = vx0;

sht->vy0 = vy0;

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息刷新画面 */

sheet_refreshsub(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize);

sheet_refreshsub(ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize);

}

return;

}




这段程序所做的是：首先记住移动前的显示位置，再设定新的显示位置，最后只要重新描绘移动前和移动后的地方就可以了。

■■■■■

估计大家会认为“这次鼠标的移动就快了吧”，但移动鼠标时，由于要在画面上显示坐标等信息，结果又执行了sheet_refresh程序，所以还是很慢。为了不浪费我们付出的各种努力，下面我们就来解决一下图层内文字显示的问题。

我们所说的在图层上显示文字，实际上并不是改写图层的全部内容。假设我们已经写了20个字，那么8×16×20=2560，也就是仅仅重写2560个像素的内容就应该足够了。但现在每次却要重写64 000个像素的内容，所以速度才那么慢。

这么说来，这里好像也可以使用refreshsub，那么我们就来重新编写函数sheet_refresh吧。

本次的*sheet.c节选

void sheet_refresh(struct SHTCTL *ctl, struct SHEET *sht, int bx0, int by0, int bx1, int by1)

{

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息刷新画面*/

sheet_refreshsub(ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1);

}

return;

}




所谓指定范围，并不是直接指定画面内的坐标，而是以缓冲区内的坐标来表示。这样一来，HariMain就可以不考虑图层在画面中的位置了。

■■■■■

我们改动了refresh，所以也要相应改造updown。做了改动的只有sheet_refresh（ctl）这部分（有两处），修改后的程序如下：

sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize);




最后还要改写HariMain。

本次的*bootpack.c节选

void HariMain(void)

{

（中略）

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);

sheet_refresh(shtctl, sht_back, 0, 0, binfo->scrnx, 48); /* 这里！ */



for (;;) {

io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {

io_stihlt();

} else {

if (fifo8_status(&keyfifo) != 0) {

（中略）

sheet_refresh(shtctl, sht_back, 0, 16, 16, 32); /* 这里！ */

} else if (fifo8_status(&mousefifo) != 0) {

i = fifo8_get(&mousefifo);

io_sti();

if (mouse_decode(&mdec, i) != 0) {

（中略）

boxfill8(buf_back, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);

putfonts8_asc(buf_back, binfo->scrnx, 32, 16, COL8_FFFFFF, s);

sheet_refresh(shtctl, sht_back, 32, 16, 32 + 15 * 8, 32); /* 这里！ */

（中略）

sprintf(s, "(%3d, %3d)", mx, my);

boxfill8(buf_back, binfo->scrnx, COL8_008484, 0, 0, 79, 15); /* 消去坐标 */

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s); /* 写出坐标 */

sheet_refresh(shtctl, sht_back, 0, 0, 80, 16); /* 这里！ */

sheet_slide(shtctl, sht_mouse, mx, my);

}

}

}

}

}




这里我们仅仅改写了sheet_refresh，变更点共有4个。只有每次要往buf_back中写入信息时，才进行sheet_refresh。

这样应该可以顺利运行了。我们赶紧试一试。“make run”。哦，确实比以前快多了。太好了，撒花！不过还是欠缺一些东西……





4　提高叠加处理速度（2）（harib07d）

虽然我们想了如此多的办法，但结果还是没有达到我们的期望，真让人郁闷。到底是怎么回事呢？原来还是refreshsub有些问题。

不是太快的refreshsub

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)

{

int h, bx, by, vx, vy;

unsigned char *buf, c, *vram = ctl->vram;

struct SHEET *sht;

for (h = 0; h <= ctl->top; h++) {

sht = ctl->sheets[h];

buf = sht->buf;

for (by = 0; by < sht->bysize; by++) {

vy = sht->vy0 + by;

for (bx = 0; bx < sht->bxsize; bx++) {

vx = sht->vx0 + bx;

if (vx0 <= vx && vx < vx1 && vy0 <= vy && vy < vy1) {

c = buf[by * sht->bxsize + bx];

if (c != sht->col_inv) {

vram[vy * ctl->xsize + vx] = c;

}

}

}

}

}

return;

}




依照这个程序，即使不写入像素内容，也要多次执行if语句，这一点不太好，如果能改善一下，速度应该会提高不少。

■■■■■

按照上面这种写法，即便只刷新图层的一部分，也要对所有图层的全部像素执行if语句，判断“是写入呢，还是不写呢”。而对于刷新范围以外的部分，就算执行if判断语句，最后也不会进行刷新，所以这纯粹就是一种浪费。既然如此，我们最初就应该把for语句的范围限定在刷新范围之内。



基于以上思路，我们做好了改良版本。

本次的*sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1;

unsigned char *buf, c, *vram = ctl->vram;

struct SHEET *sht;

for (h = 0; h <= ctl->top; h++) {

sht = ctl->sheets[h];

buf = sht->buf;

/* 使用vx0～vy1，对bx0～by1进行倒推/

bx0 = vx0 - sht->vx0;

by0 = vy0 - sht->vy0;

bx1 = vx1 - sht->vx0;

by1 = vy1 - sht->vy0;

if (bx0 < 0) { bx0 = 0; } /* 说明(1) */

if (by0 < 0) { by0 = 0; }

if (bx1 > sht->bxsize) { bx1 = sht->bxsize; } /* 说明(2) */

if (by1 > sht->bysize) { by1 = sht->bysize; }

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

c = buf[by * sht->bxsize + bx];

if (c != sht->col_inv) {

vram[vy * ctl->xsize + vx] = c;

}

}

}

}

return;

}




改良的关键在于，bx在for语句中并不是在0到bxsize之间循环，而是在bx0到bx1之间循环（对于by也一样）。而bx0和bx1都是从刷新范围“倒推”求得的。倒推其实就是把公式变形转换了一下，具体如下：

vx = sht->vx0 + bx; → bx = vx - sht->vx0;

计算vx0的坐标相当于bx中的哪个位置，然后把它作为bx0。其他的坐标处理方法也一样。

■■■■■

这样算完以后，就该执行以上程序中说明(1)的地方了。这行代码用于处理刷新范围在图层外侧的情况。什么时候会出现这种情况呢？比如在sht_back中写入字符并进行刷新，而且刷新范围的一部分被鼠标覆盖的情况。



刷新范围与鼠标的图层像这样重叠在一起 这时候的vx和vy

假设在这种情况下h=1，且想要重复刷新鼠标的图层，那么就变成了下面这样。



对sheets[1]进行bx0～bx1计算的时候

在这里必须要进行重复描绘的只有与鼠标图层重叠的那一小块范围，而其他部分并没有被要求刷新，所以不能刷新。这样的话，可以把bx0和by0置0。

■■■■■

程序中“说明(2)”部分所做的，是为了应对不同的重叠方式。



需要执行“说明(2)”部分的情形

在这种情况下，bx0和by0虽然可以从vx0和vy0顺利求取， 但bx1和by1就变得太大了（超出了图层的范围），因此要修改这里。

第三种情况是完全不重叠的情况。例如，鼠标的图层往左移动直至不再重叠。此时当然完全不需要进行重复描绘，那么程序是否可以正常运行呢？

利用倒推计算得出的bx0和bx1都是负值，在说明(1)中，仅仅bx0被修正为0，而在说明(2) 中bx1没有被修正，还是负的。这样的话，for（bx = bx0;bx < bx1;bx++）这个语句里的循环条件bx < bx1从最开就不成立，所以for语句中的命令得不到循环，这样就完全不会进行重复描绘了，很好。

■■■■■

仅仅改了这些地方，就可以提高速度吗？我们来试一下。“make run”（要等待一会儿）吗？哦，这次感觉很好，操作系统正在迅速地运行，太开心了！虽然从表面上看不出有什么不同，不过这次我们要附上照片，展示一番。太棒了！



太好了！真开心。

纪念照片也拍完了（笑），在这里我们看一下haribote.sys的大小吧。哦，是11 104字节。除以1024的话，大约是10.8，也就是10.8KB。……我们的系统正在茁壮成长！ 到这里可以暂时告一段落了，那好，我们今天就到此结束吧。明天见！





第11天　制作窗口



鼠标显示问题（harib08a）

实现画面外的支持（harib08b）

shtctl的指定省略（harib08c）

显示窗口（harib08d）

小实验（harib08e）

高速计数器（harib08f）

消除闪烁（1）（harib08g）

消除闪烁（2）（harib08h）





1　鼠标显示问题（harib08a）

大家早上好！我们直接进入主题，先来看看下面这张截图。



把鼠标移到右侧时的情形

在harib07d中鼠标移动到右侧后就不能再往右移了，大家有没有觉得别扭？没错，在Windows中，鼠标应该可以向右或向下移动到画面之外隐藏起来的，可是我们的操作系统却还不能实现这样的功能，这多少有些遗憾。

这是为什么呢？我们还是先来看一看HariMain吧。

if (mx > binfo->scrnx - 16) {

mx = binfo->scrnx - 16;

}

if (my > binfo->scrny - 16) {

my = binfo->scrny - 16;

}




之所以出现这种情况，就是因为有上面这段代码。那么我们来修改一下，很简单。

if (mx > binfo->scrnx - 1) {

mx = binfo->scrnx - 1;

}

if (my > binfo->scrny - 1) {

my = binfo->scrny - 1;

}




现在“make run”一下，然后向右移动鼠标。能不能成功呢？



哎？这是怎么回事？

我们遇到了一个麻烦——只要图层一跑到画面的外面去就会出问题。那么我们赶紧进入到下一节，看看怎么解决这个问题吧。





2　实现画面外的支持（harib08b）

怎么才能让图层位于画面以外时也不出问题呢？因为只有sheet_refreshsub函数在做把图层内容写入VRAM的工作，所以我们决定把这个函数做得完美一些，让它不刷新画面以外的部分。

本次的sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1;

unsigned char *buf, c, *vram = ctl->vram;

struct SHEET *sht;

/* 如果refresh的范围超出了画面则修正 */

if (vx0 < 0) { vx0 = 0; }

if (vy0 < 0) { vy0 = 0; }

if (vx1 > ctl->xsize) { vx1 = ctl->xsize; }

if (vy1 > ctl->ysize) { vy1 = ctl->ysize; }

for (h = 0; h <= ctl->top; h++) {

（中略）

}

return;

}




这里不需要特别解释了吧，我们来“make run”。



成功啦！

运行成功啦！只稍作修改就解决了问题，太厉害了。





3　shtctl的指定省略（harib08c）

我们先来看一看bootpack.h。

上次的bootpack.h节选

struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize);

struct SHEET *sheet_alloc(struct SHTCTL *ctl);

void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv);

void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height);

void sheet_refresh(struct SHTCTL *ctl, struct SHEET *sht, int bx0, int by0, int bx1, int by1);

void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0);

void sheet_free(struct SHTCTL *ctl, struct SHEET *sht);




其实笔者对sheet_updown函数不太满意，因为仅是上下移动图层，就必须指定ctl，太麻烦。不过这仅仅是个人喜好问题（笑）。

要想改善这个问题，首先我们需要在struct SHEET中加入struct SHTCTL *ctl 。

本次bootpack.h节选

struct SHEET {

unsigned char *buf;

int bxsize, bysize, vx0, vy0, col_inv, height, flags;

struct SHTCTL *ctl;

};




然后对函数shtctl_init也进行追加，仅追加1行即可。

本次的sheet.c节选

struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)

{

struct SHTCTL *ctl;

int i;

ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL));

if (ctl == 0) {

goto err;

}

ctl->vram = vram;

ctl->xsize = xsize;

ctl->ysize = ysize;

ctl->top = -1; /* 没有一张SHEET */

for (i = 0; i < MAX_SHEETS; i++) {

ctl->sheets0[i].flags = 0; /* 未使用标记 */

ctl->sheets0[i].ctl = ctl; /* 记录所属*/ /* 这里！ */

}

err:

return ctl;

}




还有，函数sheet_updown也要修改。

本次的sheet.c节选

void sheet_updown(struct SHEET *sht, int height)

{

struct SHTCTL *ctl = sht->ctl;

int h, old = sht->height; /* 将设置前的高度记录下来 */

（中略）

}




好了，完成了。这样一来在sheet_updown函数里就可以不指定ctl了。函数变得比之前好用了。

■■■■■

最后，我们将sheet_refresh、sheet_slide、sheet_free这几个函数全部修改一下，让它们都不用指定ctl。

本次的sheet.c节选

void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1)

{

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新*/

sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1);

}

return;

}



void sheet_slide(struct SHEET *sht, int vx0, int vy0)

{

int old_vx0 = sht->vx0, old_vy0 = sht->vy0;

sht->vx0 = vx0;

sht->vy0 = vy0;

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */

sheet_refreshsub(sht->ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize);

sheet_refreshsub(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize);

}

return;

}



void sheet_free(struct SHEET *sht)

{

if (sht->height >= 0) {

sheet_updown(sht, -1); /* 如果正在显示，则先设置为隐藏 */

}

sht->flags = 0; /* 未使用标记 */

return;

}




改好了。这样，所有的函数都更好用了。

■■■■■

由于我们进行了以上这些变更，所以要在bootpack.c的HariMain中，把相应的shtctl也删掉。一共要修改9个地方。

sheet_slide(shtctl, sht_back, 0, 0); → sheet_slide(sht_back, 0, 0);

sheet_slide(shtctl, sht_mouse, mx, my); → sheet_slide(sht_mouse, mx, my);

sheet_updown(shtctl, sht_back, 0); → sheet_updown(sht_back, 0);

sheet_updown(shtctl, sht_mouse, 1); → sheet_updown(sht_mouse, 1);

sheet_refresh(shtctl, sht_back, 0, 0, binfo->scrnx, 48);

→ sheet_refresh(sht_back, 0, 0, binfo->scrnx, 48);

sheet_refresh(shtctl, sht_back, 0, 16, 16, 32);

→ sheet_refresh(sht_back, 0, 16, 16, 32);

sheet_refresh(shtctl, sht_back, 32, 16, 32 + 15 * 8, 32);

→ sheet_refresh(sht_back, 32, 16, 32 + 15 * 8, 32);

sheet_refresh(shtctl, sht_back, 0, 0, 80, 16);

→ sheet_refresh(sht_back, 0, 0, 80, 16);

sheet_slide(shtctl, sht_mouse, mx, my); → sheet_slide(sht_mouse, mx, my);




这样HariMain也稍稍变短了，太好了。

我们来“make run”一下看看，不错不错，运行正常。





4　显示窗口（harib08d）

我们现在做出来的图层构架，已经完全可以完成窗口的叠加处理了，所以下面我们就来尝试一下制作窗口吧。

其实方法很简单，就像前面制作背景和鼠标那样，只要先准备一张图层，然后在图层缓冲区内描绘一个貌似窗口的图就可以了。那么我们就来制作一个具有这种功能的函数make_window8吧。

本次的bootpack.c节选

void make_window8(unsigned char *buf, int xsize, int ysize, char *title)

{

static char closebtn[14][16] = {

"OOOOOOOOOOOOOOO@",

"OQQQQQQQQQQQQQ$@",

"OQQQQQQQQQQQQQ$@",

"OQQQ@@QQQQ@@QQ$@",

"OQQQQ@@QQ@@QQQ$@",

"OQQQQQ@@@@QQQQ$@",

"OQQQQQQ@@QQQQQ$@",

"OQQQQQ@@@@QQQQ$@",

"OQQQQ@@QQ@@QQQ$@",

"OQQQ@@QQQQ@@QQ$@",

"OQQQQQQQQQQQQQ$@",

"OQQQQQQQQQQQQQ$@",

"O$$$$$$$$$$$$$$@",

"@@@@@@@@@@@@@@@@"

};

int x, y;

char c;

boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 );

boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 );

boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1);

boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2);

boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2);

boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1);

boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3);

boxfill8(buf, xsize, COL8_000084, 3, 3, xsize - 4, 20 );

boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2);

boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1);

putfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title);

for (y = 0; y < 14; y++) {

for (x = 0; x < 16; x++) {

c = closebtn[y][x];

if (c == '@') {

c = COL8_000000;

} else if (c == '$') {

c = COL8_848484;

} else if (c == 'Q') {

c = COL8_C6C6C6;

} else {

c = COL8_FFFFFF;

}

buf[(5 + y) * xsize + (xsize - 21 + x)] = c;

}

}

return;

}




正如大家所看到的那样，其实我们只是对graph.c的init_screen8函数稍微进行了改造，而×按钮的功能则是通过修改 init_mouse_cursor8而得到的。

我们在HariMain里也添加了一些内容。因为功能很简单，所以添加的内容不多。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct SHEET *sht_back, *sht_mouse, *sht_win; /* 这里！ */

unsigned char *buf_back, buf_mouse[256], *buf_win; /* 这里！ */



（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);

sht_back = sheet_alloc(shtctl);

sht_mouse = sheet_alloc(shtctl);

sht_win = sheet_alloc(shtctl); /* 这里！ */

buf_back = (unsigned char *) memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);

buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 68); /* 这里！ */

sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /* 没有透明色 */

sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);

sheet_setbuf(sht_win, buf_win, 160, 68, -1); /* 没有透明色 */ /* 这里！*/

init_screen8(buf_back, binfo->scrnx, binfo->scrny);

init_mouse_cursor8(buf_mouse, 99);

make_window8(buf_win, 160, 68, "window"); /* 这里！ */

putfonts8_asc(buf_win, 160, 24, 28, COL8_000000, "Welcome to"); /* 这里！ */

putfonts8_asc(buf_win, 160, 24, 44, COL8_000000, " Haribote-OS!"); /* 这里！ */

sheet_slide(sht_back, 0, 0);

mx = (binfo->scrnx - 16) / 2; /* 为使其处于画面的中央位置，计算坐标 */

my = (binfo->scrny - 28 - 16) / 2;

sheet_slide(sht_mouse, mx, my);

sheet_slide(sht_win, 80, 72); /* 这里！ */

sheet_updown(sht_back, 0);

sheet_updown(sht_win, 1); /* 这里！ */

sheet_updown(sht_mouse, 2);

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);

sheet_refresh(sht_back, 0, 0, binfo->scrnx, 48);



（中略）

}




窗口里还写了点东西，大家一起来读一下程序，看看写了些什么吧。

■■■■■

下面我们来“make run”，到底能不能成功呢？



哦！太帅了！

感觉真有点操作系统的样子了，非常满意！





5　小实验（harib08e）*

这一节我们来做一个小实验。HariMain中有设置图层高度的地方，如果像下面这样，把窗口图层放在最上面，光标图层放在其次，会变成什么样呢？

sheet_updown(sht_back, 0);

sheet_updown(sht_mouse, 1);

sheet_updown(sht_win, 2);




我们还是来“make run”试试看吧。



原来会变成这样呀。如果从图层的架构来考虑的话当然会这样了，看来sheet.c运行正常。





6　高速计数器（harib08f）

实验顺利结束了，我们还把图层的高度设置恢复原样，然后再试着做个动作更丰富的窗口。做成什么样呢？我们就做一个能够计数，并将计数结果显示出来的窗口吧。计数器在英语中是counter，所以我们就将窗口的名称改为counter。

我们只改写了10行就得到了下面这个程序。

本次的bootpack.c节选

void HariMain(void)

{

struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;

char s[40], keybuf[32], mousebuf[128];

int mx, my, i;

unsigned int memtotal, count = 0; /* 这里！ */

struct MOUSE_DEC mdec;

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct SHTCTL *shtctl;

struct SHEET *sht_back, *sht_mouse, *sht_win;

unsigned char *buf_back, buf_mouse[256], *buf_win;



（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);

sht_back = sheet_alloc(shtctl);

sht_mouse = sheet_alloc(shtctl);

sht_win = sheet_alloc(shtctl);

buf_back = (unsigned char *) memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);

buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 52); /* 这里！ */

sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /* 没有透明色 */

sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);

sheet_setbuf(sht_win, buf_win, 160, 52, -1); /* 没有透明色 */ /* 这里！ */

init_screen8(buf_back, binfo->scrnx, binfo->scrny);

init_mouse_cursor8(buf_mouse, 99);

make_window8(buf_win, 160, 52, "counter"); /* 这里！ */

sheet_slide(sht_back, 0, 0);

mx = (binfo->scrnx - 16) / 2; /* 为使其处于画面中央位置，计算坐标 */

my = (binfo->scrny - 28 - 16) / 2;

sheet_slide(sht_mouse, mx, my);

sheet_slide(sht_win, 80, 72);

sheet_updown(sht_back, 0);

sheet_updown(sht_win, 1);

sheet_updown(sht_mouse, 2);

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc(buf_back, binfo->scrnx, 0, 0, COL8_FFFFFF, s);

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc(buf_back, binfo->scrnx, 0, 32, COL8_FFFFFF, s);

sheet_refresh(sht_back, 0, 0, binfo->scrnx, 48);



for (;;) {

count++; /* 从这里开始 */

sprintf(s, "%010d", count);

boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43);

putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s);



sheet_refresh(sht_win, 40, 28, 120, 44); /* 到这里结束 */



io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {

io_sti(); /* 不做HLT */

} else {

（中略）

}

}

}




这次不再采用HLT，因为与其让CPU有空睡觉（HLT命令），还不如让它在电力许可的范围内去全力计数。正因为这个原因，我们的计数器才被称为高速计数器。

按照惯例，我们来“make run”。



计数啦！

运行成功，动作正常，真顺利呀！可是再仔细一看，怎么总觉得显示的内容在闪烁呢（注：在上面截图中看不出来）？这可不行。

为什么会出现这种现象呢？这是由于在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，所以肯定就会闪烁了。可是我们使用Windows的时候就没见过这种闪烁，因此肯定有什么好的解决方法。

于是解决这个问题就成了我们下节内容的主题。





7　消除闪烁（1）（harib08g）

窗口图层刷新是因为窗口的内容有变化，所以要在画面上显示变化后的新内容。基本上来讲，可以认为其他图层的内容没有变化（如果其他图层的内容也变了，那么应该会随后执行该图层的刷新）。

既然如此，图层内容没有变化也进行刷新的话就太浪费了。如果只是窗口变了，那背景就不用刷新了。另外，假如上面有鼠标，但鼠标的图层没有变化，那我们应该刷新吗？必须要刷新。窗口的刷新，可能会覆盖鼠标的一部分显示区域。

综上所述，仅对refresh对象及其以上的图层进行刷新就可以了。那么我们赶紧按照这个思路修改程序吧。

■■■■■

首先修改为我们完成刷新工作的sheet_refreshsub函数。

本次的sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)

{

（中略）

for (h = h0; h <= ctl->top; h++) {

（中略）

}

return;

}




我们追加了h0参数，只对在此参数以上的图层进行刷新。然后还要把所有调用了sheet_refreshsub的函数都修改一下。

本次的sheet.c节选

void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1)

{

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */

sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1,

sht->height);

/* ↑这里！ */

}

return;

}



void sheet_slide(struct SHEET *sht, int vx0, int vy0)

{

int old_vx0 = sht->vx0, old_vy0 = sht->vy0;

sht->vx0 = vx0;

sht->vy0 = vy0;

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新*/

sheet_refreshsub(sht->ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0);

sheet_refreshsub(sht->ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height);

/* ↑这里！ */

}

return;

}



void sheet_updown(struct SHEET *sht, int height)

{

（中略）



/* 以下主要是对sheets[]的重新排列 */



if (old > height) { /* 比以前低 */

if (height >= 0) {

/* 中间的提起 */

for (h = old; h > height; h--) {

ctl->sheets[h] = ctl->sheets[h - 1];

ctl->sheets[h]->height = h;

}

ctl->sheets[height] = sht;

/* 这里 */ sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height + 1);

} else { /* 隐藏 */

if (ctl->top > old) {

/* 把上面的降下来 */

for (h = old; h < ctl->top; h++) {

ctl->sheets[h] = ctl->sheets[h + 1];

ctl->sheets[h]->height = h;

}

}

ctl->top--; /* 正在显示的图层减少了一个，故最上面的高度也减少 */

/* 这里 */ sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0);

}

} else if (old < height) { /* 比以前高 */

if (old >= 0) {

/* 中间的图层往下降一层 */

for (h = old; h < height; h++) {

ctl->sheets[h] = ctl->sheets[h + 1];

ctl->sheets[h]->height = h;

}

ctl->sheets[height] = sht;

} else { /* 从隐藏状态变为显示状态 */

/* 把在上面的图层往上提高一层 */

for (h = ctl->top; h >= height; h--) {

ctl->sheets[h + 1] = ctl->sheets[h];

ctl->sheets[h + 1]->height = h + 1;

}

ctl->sheets[height] = sht;

ctl->top++; /* 显示中的图层增加了一个，故最上面的高度也增加 */

}

sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, height);

/* ↑这里 */

}

return;

}




修改的内容很少，我们逐一来看一下。对于sheet_refresh函数，我们按照刚才的思路让它只刷新指定的图层和它上面的图层。

在sheet_slide函数里，图层的移动有时会导致下面的图层露出，所以要从最下面开始刷新。另一方面，在移动目标处，比新移来的图层位置还要低的图层没有什么变化，而且只是隐藏起来了，所以只要刷新移动的图层和它上面的图层就可以了。

在sheet_updown函数里，按照同样的思路，针对个别不需要自下而上全部刷新的部分只进行局部刷新。这样修改以后，闪烁现象应该就会消失了。

■■■■■

完成了，我们来“make run”看看。



闪烁现象消失了

不错，性能越来越完善了。哎？等等，怎么稍微一动，鼠标就又出问题了！



鼠标变得一闪一闪的

数字部分的背景闪烁问题是解决了，可是把鼠标放在上面时，鼠标又闪烁起来了（不过，从截图看不出来）。嗯，这可是个问题。





8　消除闪烁（2）（harib08h）

怎么样才能让鼠标不再闪烁呢？闪烁现象是由于一会儿描绘一会儿消除造成的。所以说要想消除闪烁，就要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理。这好像挺难的，但不管怎样我们还是要努力一下。

而且如果这里做好了，刷新窗口时就不需要重绘鼠标了，这样速度也能相应提高。一想到这里，就充满了克服困难的勇气和动力！

■■■■■

这样也不行，那样也不行，左思右想之后我们决定采用下面这种方法。首先，开辟一块内存，大小和VRAM一样，我们先称之为map（地图）吧。至于为什么要叫做地图，我们马上就来讲解。

本次的bootpack.h和sheet.c程序的节选

struct SHTCTL {

unsigned char *vram, *map; /* 这里！ */

int xsize, ysize, top;

struct SHEET *sheets[MAX_SHEETS];

struct SHEET sheets0[MAX_SHEETS];

};



struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize)

{

struct SHTCTL *ctl;

int i;

ctl = (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL));

if (ctl == 0) {

goto err;

}

/* 从这里开始 */

ctl->map = (unsigned char *) memman_alloc_4k(memman, xsize * ysize);

if (ctl->map == 0) {

memman_free_4k(memman, (int) ctl, sizeof (struct SHTCTL));

goto err;

}

/* 到这里结束 */

ctl->vram = vram;

ctl->xsize = xsize;

ctl->ysize = ysize;

ctl->top = -1; /* 没有一张SHEET */

for (i = 0; i < MAX_SHEETS; i++) {

ctl->sheets0[i].flags = 0; /* 未使用标记 */

ctl->sheets0[i].ctl = ctl; /* 记录所属 */

}

err:

return ctl;

}




这块内存用来表示画面上的点是哪个图层的像素，所以它就相当于是图层的地图。



当刷新图层1的时候，如果一边看着这个map一边刷新的话，就不必担心图层1和图层2重叠的部分被覆盖了。

■■■■■

下面我们来写向map中写入1、2等图层号码的函数。

本次的sheet.c节选

void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1;

unsigned char *buf, sid, *map = ctl->map;

struct SHEET *sht;

if (vx0 < 0) { vx0 = 0; }

if (vy0 < 0) { vy0 = 0; }

if (vx1 > ctl->xsize) { vx1 = ctl->xsize; }

if (vy1 > ctl->ysize) { vy1 = ctl->ysize; }

for (h = h0; h <= ctl->top; h++) {

sht = ctl->sheets[h];

sid = sht - ctl->sheets0; /* 将进行了减法计算的地址作为图层号码使用 */

buf = sht->buf;

bx0 = vx0 - sht->vx0;

by0 = vy0 - sht->vy0;

bx1 = vx1 - sht->vx0;

by1 = vy1 - sht->vy0;

if (bx0 < 0) { bx0 = 0; }

if (by0 < 0) { by0 = 0; }

if (bx1 > sht->bxsize) { bx1 = sht->bxsize; }

if (by1 > sht->bysize) { by1 = sht->bysize; }

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

if (buf[by * sht->bxsize + bx] != sht->col_inv) {

map[vy * ctl->xsize + vx] = sid;

}

}

}

}

return;

}




这个函数与以前的refreshsub函数基本一样，只是用色号代替了图层号码而已。代表图层号码的变量sid是“sheet lD1 ”的缩写。

1 ID是英文identification的缩写，意为“用来表示身份的证件以及某一身份所对应的证件号码或记号等”。

■■■■■

下面是sheet_refreshsub函数。我们对它进行改写，让它可以使用map。

本次的sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1;

unsigned char *buf, *vram = ctl->vram, *map = ctl->map, sid;

struct SHEET *sht;

/* 如果refresh的范围超出了画面则修正*/

（中略）

for (h = h0; h <= h1; h++) {

sht = ctl->sheets[h];

buf = sht->buf;



sid = sht - ctl->sheets0;

/* 利用vx0～vy1，对bx0～by1进行倒推 */

（中略）

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

if (map[vy * ctl->xsize + vx] == sid) {

vram[vy * ctl->xsize + vx] = buf[by * sht->bxsize + bx];

}

}

}

}

return;

}




今后程序会对照map内容来向VRAM中写入，所以有时没必要从下面开始一直刷新到最上面一层，因此不仅要能指定h0，也要可以指定h1。

■■■■■

现在我们来修改调用了sheet_refreshsub的3个函数，先从较短的2个入手吧。

本次的sheet.c节选

void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1)

{

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */

sheet_refreshsub(sht->ctl, sht->vx0 + bx0, sht->vy0 + by0, sht->vx0 + bx1, sht->vy0 + by1,

sht->height, sht->height);

}

return;

}



void sheet_slide(struct SHEET *sht, int vx0, int vy0)

{

struct SHTCTL *ctl = sht->ctl;

int old_vx0 = sht->vx0, old_vy0 = sht->vy0;

sht->vx0 = vx0;

sht->vy0 = vy0;

if (sht->height >= 0) { /* 如果正在显示，则按新图层的信息进行刷新 */

sheet_refreshmap(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0);

sheet_refreshmap(ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height);

sheet_refreshsub(ctl, old_vx0, old_vy0, old_vx0 + sht->bxsize, old_vy0 + sht->bysize, 0,

sht->height - 1);

sheet_refreshsub(ctl, vx0, vy0, vx0 + sht->bxsize, vy0 + sht->bysize, sht->height,

sht->height);

}

return;

}




在sheet_refresh函数里，由于图层的上下关系没有改变，所以不需要重新进行refreshmap的处理。实际上，我们有时候要把透明的地方变成不透明的，或者反过来要把不透明的地方变成透明的，遇到这些情况就必须重新编写map了，不过这里的sheet_refreshrefresh函数没有考虑这些情况。如果需要实现这样的功能，就要再编写其他的函数。

另外，在sheet_refresh函数里，需要刷新的图层只有一张，所以速度应该比较快。

在sheet_slide函数里，首先重写map，分别对应移动前后的图层，然后调用sheet_refreshsub函数。在移动前的地方，只针对上层图层移走之后而露出的下层图层进行重绘就可以了。在移动目的地处仅重绘了一张移动过去的图层。

■■■■■

最后是sheet_updown函数。

本次的sheet.c节选

void sheet_updown(struct SHEET *sht, int height)

{

（中略）



/* 下面主要是对sheets[]进行重新排列 */

if (old > height) { /* 比以前低 */

if (height >= 0) {

/* 中间的图层也提高一层 */

（中略）

sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 +

sht->bysize, height + 1);

sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 +

sht->bysize, height + 1, old);

} else { /* 隐藏 */

（中略）

sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0);

sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize, 0, old - 1);

}

} else if (old < height) { /* 比以前高 */

（中略）

sheet_refreshmap(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize,

height);

sheet_refreshsub(ctl, sht->vx0, sht->vy0, sht->vx0 + sht->bxsize, sht->vy0 + sht->bysize,

height, height);

}

return;

}




在调用sheet_refreshsub函数之前，先执行sheet_refreshmap来重做map。

■■■■■

通过这些修改，闪烁现象真能消失吗？速度会变快吗？

感觉速度好像稍稍变快了些，而且鼠标不再闪烁了。我们成功了！



即使这样，鼠标也不闪啦。

哎呀，不知不觉居然都已经这么晚了，今天我们就到这里吧，明天见！





第12天　定时器（1）



使用定时器（harib09a）

计量时间（harib09b）

超时功能（harib09c）

使用多个定时器（harib09d）

加快中断处理（1）（harib09e）

加快中断处理（2）（harib09f）

加快中断处理（3）（harib09g）





1　使用定时器（harib09a）

定时器1（Timer）对于操作系统非常重要。它在原理上却很简单，只是每隔一段时间（比如0.01秒）就发送一个中断信号给CPU。幸亏有了定时器，CPU才不用辛苦地去计量时间。……如果没有定时器会怎么样呢？让我们想象一下吧。

1 英文的Timer在汉语中有“定时器”或“时钟”等多种译法。另外，Clock这个词，也经常译作“时钟”。这两个词，意义上是不同的，如果都译作“时钟”，会引起混乱。本文原文为日文，用到了“Timer”和“Clock”这两个词的音译词。为了区别这两个词，本文中我们将Timer称作“定时器”，Clock称作“时钟周期”或“周期”。——译者注

假如CPU看不到定时器而仍想计量时间的话，就只能牢记每一条指令的执行时间了。比如，往寄存器写入常数的MOV指令是1个时钟周期（Clock）；加法计算的ADD指令原则上是1个时钟周期，但根据条件不同可能是2个时钟周期……等等。CPU不仅要牢记这些内容，然后还要据此调查一下调用这些函数所需的时间，比如，调用这个函数需要150个时钟周期，调用那个函数因参数不同需要106到587个时钟周期等。

而这里的“时钟周期”又不是一个固定值。比如CPU主频是100MHz的话，一个时钟周期是10 纳秒；但主频如果是200MHz，1个时钟周期就是5纳秒。既然CPU有各种主频，那么1个时钟周期的时间也就各不相同。

这样做可以勉强通过程序对时间进行管理，实现每隔一定时间进行一次某种处理，比如让钟表（程序）的秒针动起来。如果程序中时间计算出错了，那么做出的钟表不是快就是慢，没法使用。

如果没有定时器，还会出现别的麻烦，即不能使用HLT指令。完成这个指令所需的时钟周期，不是个固定值。这样，一旦执行HLT指令，程序就不知道时间了。不能执行HLT指令，就意味着要浪费很多电能。所以只能二选一，要么放弃时间的计量，要么选择浪费电能。左右为难，实在糟糕透顶。

打个比方说，如果大家没有手表还想知道时间，那该怎么办呢？当然，不准看太阳，也不准看星星。那就只能根据肚子的饥饿程度，或者烧一壶开水所用的时间等方法来判断了。总之只能是一边干点儿什么，一边计算时间，而且决不能睡觉！一睡觉就没法计时了……嗯，就类似这种情况。

然而实际上，由于有定时器中断，所以不用担心会发生这样的悲剧。程序只需要以自己的步调处理自己的问题就行了。至于到底经过了多长时间，只要在中断处理程序中数一数定时器中断发生的次数就可以了。就算CPU处于HLT状态，也可以通过中断来唤醒。根本就没必要让程序自己去记忆时间。CPU也就可以安心地去睡觉了（HLT）。这样，大家还可以省点电费（笑）。

所以说定时器非常重要。管理定时器是操作系统的重大任务之一，所以在“纸娃娃操作系统”中我们也想使用定时器。

■■■■■

要在电脑中管理定时器，只需对PIT进行设定就可以了。PIT是“ Programmable Interval Timer”的缩写，翻译过来就是“可编程的间隔型定时器”。我们可以通过设定PIT，让定时器每隔多少秒就产生一次中断。因为在电脑中PIT连接着IRQ（interrupt request，参考第6章）的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。……在旧机种上PIT是作为一个独立的芯片安装在主板上的，而现在已经和PIC（programmable interrupt controller，参考第6章）一样被集成到别的芯片里了。

前几天我们学习PIC时曾经非常辛苦，从现在开始，我们又要重温那种感觉了。大家可不要想：“怎么又学这个？”刚开始学习PIC时，陌生的东西比较多，学起来很费力。这次就不会那么辛苦了。

首先来看资料，还是到我们每次必去的那个网站。电脑里的定时器用的是8254芯片（或其替代品），那就查一下这个芯片吧。

http://community.osdev.info/?(PIT)8254

以上内容，如果全部讲解的话太长了。所以这里就不一一详述了，大家来看下面“给怕麻烦的读者”这一部分吧。



IRQ0的中断周期变更:

AL=0x34:OUT(0x43,AL);



AL=中断周期的低8位; OUT(0x40,AL);



AL=中断周期的高8位; OUT(0x40,AL);



到这里告一段落。



如果指定中断周期为0，会被看作是指定为65536。实际的中断产生的频率是单位时间时钟周期数（即主频）/设定的数值。比如设定值如果是1000，那么中断产生的频率就是1.19318KHz。设定值是10000的话，中断产生频率就是119.318Hz。再比如设定值是11932的话，中断产生的频率大约就是100Hz了，即每10ms发生一次中断。





我们不清楚其中的详细原理，只知道只要执行3次OUT指令设定就完成了。将中断周期设定为11932的话，中断频率好像就是100Hz，也就是说1秒钟会发生100次中断。那么我们就设定成这个值吧。把11932换算成十六进制数就是0x2e9c，下面是我们编写的函数init_pit。

本次的timer.c节选

#define PIT_CTRL 0x0043

#define PIT_CNT0 0x0040



void init_pit(void)

{

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

return;

}




本次的bootback.c节选

void HariMain(void)

{

（中略）



init_gdtidt();

init_pic();

io_sti(); /* IDT/PIC的初始化已经结束，所以解除CPU的中断禁止*/

fifo8_init(&keyfifo, 32, keybuf);

fifo8_init(&mousefifo, 128, mousebuf);

init_pit(); /* 这里！ */

io_out8(PIC0_IMR, 0xf8); /* PIT和PIC1和键盘设置为许可(11111000) */ /* 这里！ */

io_out8(PIC1_IMR, 0xef); /* 鼠标设置为许可(11101111) */



（中略）

}




这样的话IRQ0就会在1秒钟内发生100次中断了。

■■■■■

下面我们来编写IRQ0发生时所调用的中断处理程序。它几乎和键盘中断处理程序一样，所以就不用再讲了吧。

本次的timer.c节选

void inthandler20(int *esp)

{

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收完了的信息通知给PIC */

/* 暂时什么也不做 */

return;

}




本次的naskfunc.nas节选

_asm_inthandler20:

PUSH ES

PUSH DS

PUSHAD

MOV EAX,ESP

PUSH EAX

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler20

POP EAX

POPAD

POP DS

POP ES

IRETD




为了把这个中断处理程序注册到IDT，inlt_gdtidt函数中也要加上几行。这也和键盘处理的时候差不多。

本次的dsctbl.c节选

void init_gdtidt(void)

{

（中略）



/* IDT的设定 */

set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); /* 这里! */

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);



return;

}




■■■■■

到这里准备工作就完成了。也不知能不能正常运行。正常的话，嗯，应该什么都不发生（笑）。下面我们执行“make run”。哦，什么也没发生。太好了！但这样有点不过瘾，还是在中断处理程序中做点什么吧！





2　计量时间（harib09b）

那我们让它干点什么呢？……有了！我们就让它执行下面这段程序吧。

本次的bootback.h节选

struct TIMERCTL {

unsigned int count;

};




本次的timer.c节选

struct TIMERCTL timerctl;



void init_pit(void)

{

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0; /* 这里！ */

return;

}



void inthandler20(int *esp)

{

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收完了的信息通知给PIC */

timerctl.count++; /* 这里！ */

return;

}




程序所做的处理是：首先定义了struct TIMERCTL结构体。然后，在结构体内定义了一个计数变量。初始化PIT时，将这个计数变量设置为0。每次发生定时器中断时，计数变量就以1递增。也就是说，即使这个计数变量在HariMain中不进行加算， 每1秒钟它也会自动增加100。

■■■■■

为了确认这一点，我们把数值显示出来吧。

本次的bootback.c节选

void HariMain(void)

{

（中略）



for (;;) {

sprintf(s, "%010d", timerctl.count); /* 这里！ */

boxfill8(buf_win, 160, COL8_C6C6C6, 40, 28, 119, 43);

putfonts8_asc(buf_win, 160, 40, 28, COL8_000000, s);

sheet_refresh(sht_win, 40, 28, 120, 44);



（中略）

}

}




这样的话，数字应该是以每秒钟100的速度增加。而且不论哪个机种增加速度都是一样的。即使CPU的速度不同，增加速度也应该是一样的。我们先做做看吧。执行“make run”。……哦，正常运行了，还算顺利。



1秒钟增加100

利用这个方法，就能知道从启动开始时间过去了多少秒。如果往方便面里倒入开水的同时，我们启动这个程序，就能测量是否到3分钟（=180秒）了。哦，终于向着有实用价值的操作系统迈出了第一步（笑）。顺便说一下，5分钟相当于300秒，所以泡乌冬面时也可以拿它来计时呢！





3　超时功能（harib09c）

现在，从启动开始经过了多少秒这一类问题，我们就可以很轻松地判断了。另外，我们还可以计量处理所花费的时间。具体做法是，处理前看一下时间并把它存放到一个变量里，处理结束之后再看一下时间，然后只要用减法算出时间差，就能得到答案了，比如“这个处理耗时13.56秒”等。我们甚至可以据此编制基准测试程序1（benchmark program）。

1 指测试电脑性能的程序。比如有新的CPU面世的时候，在杂志等上面会评论说，执行某一基准测试程序，新的CPU比以前的CPU性能提高了多少等。

这里大家稍稍回想一下，现在已经能够显示出窗口，又能使用鼠标，又能计量时间，还能进行内存管理，已经实现了很多功能。有了这些功能，只要对它们进行各种组合，就能做很多事情。嗯，已经有点操作系统的样子了。

我们言归正传，继续说定时器吧。操作系统的定时器经常被用于这样一种情形：“喂，操作系统小兄弟，过了10秒钟以后通知我一声，我要干什么什么”。当然，不一定非要是10秒，也可以是1秒或30分钟。我们把这样的功能叫做“超时”（timeout）。下面就来实现这个功能吧。

■■■■■

首先往结构体struct TIMERCTL里添加一些代码，以便记录有关超时的信息。

本次的bootback.h节选

struct TIMERCTL {

unsigned int count;

unsigned int timeout;

struct FIFO8 *fifo;

unsigned char data;

};




以上结构体中的timeout用来记录离超时还有多长时间。一旦这个剩余时间达到0，程序就往FIFO缓冲区里发送数据。定时器就是通过这种方法通知HariMain时间到了。

至于为什么要使用FIFO缓冲区，笔者也说不上个所以然，只是觉得这个方法简单，因为使用FIFO缓冲区来通知的话，可以比照键盘和鼠标，利用同样的方法来处理。

■■■■■

下面我们来修改函数吧。

本次的timer.c节选

void init_pit(void)

{

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0;

timerctl.timeout = 0;

return;

}



void inthandler20(int *esp)

{

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC */

timerctl.count++;

if (timerctl.timeout > 0) { /* 如果已经设定了超时 */

timerctl.timeout--;

if (timerctl.timeout == 0) {

fifo8_put(timerctl.fifo, timerctl.data);

}

}

return;

}



void settimer(unsigned int timeout, struct FIFO8 *fifo, unsigned char data)

{

int eflags;

eflags = io_load_eflags();

io_cli();

timerctl.timeout = timeout;

timerctl.fifo = fifo;

timerctl.data = data;

io_store_eflags(eflags);

return;

}




希望大家注意的是，我们在inthandler20函数里实现了超时功能。每次发生中断时就把timeout减1，减到0时，就向fifo发送数据。

在settimer函数里，如果设定还没有完全结束IRQ0的中断就进来的话，会引起混乱，所以我们先禁止中断，然后完成设定，最后再把中断状态复原。

■■■■■

这在HariMain中如何实现呢？我们来尝试这样做：

本次的bootback.c节选

void HariMain(void)

{

（中略）



struct FIFO8 timerfifo;

char s[40], keybuf[32], mousebuf[128], timerbuf[8];



（中略）



fifo8_init(&timerfifo, 8, timerbuf);

settimer(1000, &timerfifo, 1);



（中略）



for (;;) {



（中略）

io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {

io_sti();

} else {

if (fifo8_status(&keyfifo) != 0) {

（中略）

} else if (fifo8_status(&mousefifo) != 0) {

（中略）

} else if (fifo8_status(&timerfifo) != 0) {

i = fifo8_get(&timerfifo); /* 首先读入（为了设定起始点） */

io_sti();

putfonts8_asc(buf_back, binfo->scrnx, 0, 64, COL8_FFFFFF, "10[sec]");

sheet_refresh(sht_back, 0, 64, 56, 80);

}

}

}

}




程序很简单，我们在其中设定10秒钟以后向timerfifo写入“1”这个数据，而timerfifo接收到数据时，就会在屏幕上显示“10[sec]”。

我们执行一下“make run”，看，显示出来了。太棒了！



等待10秒钟就会出现上面的画面





4　设定多个定时器（harib09d）

在上一节做的超时功能，超时结束后如果再设定1000的话，那我们就可以让它每10秒显示一次，或是让它一闪一灭地显示。另外，间隔不仅限于10秒，我们还可以设定得更长一些或更短一些。比如设定为0.5秒的间隔可以用于文字输入时的光标闪烁。

开发操作系统时，超时功能非常方便，所以在很多地方都可以使用它。比如可以让电子时钟每隔1秒重新显示一次；演奏音乐时，可以用它计量音符的长短；也可以让它以0.1秒1次的频率来监视没有中断功能的装置1 ；另外，还可以用它实现光标的闪烁功能。

1 像键盘和鼠标等是通过中断告知我们有数据过来的，但是还有些装置，即使状态有变化也不会发生中断。大家可能会想：“设计这种装置的人想什么呢！”但生气也于事无补，我们只能定期去查询装置的状态。就算是状态没有变化也得查询，实在是浪费电能。

为了简单地实现这些功能，我们要准备很多能够设定超时的定时器。

比起文字说明来，还是直接看程序更易于理解。

■■■■■

首先把struct TIMERCTL修改成下面这样。

本次的bootback.h节选

#define MAX_TIMER 500



struct TIMER {

unsigned int timeout, flags;

struct FIFO8 *fifo;

unsigned char data;

};



struct TIMERCTL {

unsigned int count;

struct TIMER timer[MAX_TIMER];

};




这样超时定时器最多就可以设定为500个了，flags则用于记录各个定时器的状态。

■■■■■

下面，我们把函数也相应地修改一下吧。

本次的timer.c节选

#define TIMER_FLAGS_ALLOC 1 /* 已配置状态 */

#define TIMER_FLAGS_USING 2 /* 定时器运行中 */



void init_pit(void)

{

int i;

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0;

for (i = 0; i < MAX_TIMER; i++) {

timerctl.timer[i].flags = 0; /* 未使用 */

}

return;

}



struct TIMER *timer_alloc(void)

{

int i;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == 0) {

timerctl.timer[i].flags = TIMER_FLAGS_ALLOC;

return &timerctl.timer[i];

}

}

return 0; /* 没找到 */

}



void timer_free(struct TIMER *timer)

{

timer->flags = 0; /* 未使用 */

return;

}



void timer_init(struct TIMER *timer, struct FIFO8 *fifo, unsigned char data)

{

timer->fifo = fifo;

timer->data = data;

return;

}



void timer_settime(struct TIMER *timer, unsigned int timeout)

{

timer->timeout = timeout;

timer->flags = TIMER_FLAGS_USING;

return;

}



void inthandler20(int *esp)

{

int i;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC*/

timerctl.count++;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

timerctl.timer[i].timeout--;

if (timerctl.timer[i].timeout == 0) {

timerctl.timer[i].flags = TIMER_FLAGS_ALLOC;

fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data);

}

}

}

return;

}




程序稍微有些长，但只要前面的程序大家都明白了，这里应该也没什么困难。

■■■■■

最后来看HariMain函数。我们不一定都设定为10秒，也尝试一下设为3秒吧。另外，我们还要编写类似光标闪烁那样的程序。

本次的bootback.c节选

void HariMain(void)

{

（中略）



struct FIFO8 timerfifo, timerfifo2, timerfifo3;

char s[40], keybuf[32], mousebuf[128], timerbuf[8], timerbuf2[8], timerbuf3[8];

struct TIMER *timer, *timer2, *timer3;



（中略）



fifo8_init(&timerfifo, 8, timerbuf);

timer = timer_alloc();

timer_init(timer, &timerfifo, 1);

timer_settime(timer, 1000);

fifo8_init(&timerfifo2, 8, timerbuf2);

timer2 = timer_alloc();

timer_init(timer2, &timerfifo2, 1);

timer_settime(timer2, 300);

fifo8_init(&timerfifo3, 8, timerbuf3);

timer3 = timer_alloc();

timer_init(timer3, &timerfifo3, 1);

timer_settime(timer3, 50);



（中略）



for (;;) {

（中略）



io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo)

+ fifo8_status(&timerfifo2) + fifo8_status(&timerfifo3) == 0) {

io_sti();

} else {

if (fifo8_status(&keyfifo) != 0) {

（中略）

} else if (fifo8_status(&mousefifo) != 0) {

（中略）

} else if (fifo8_status(&timerfifo) != 0) {

i = fifo8_get(&timerfifo); /* 首先读入（为了设定起始点） */

io_sti();

putfonts8_asc(buf_back, binfo->scrnx, 0, 64, COL8_FFFFFF, "10[sec]");

sheet_refresh(sht_back, 0, 64, 56, 80);

} else if (fifo8_status(&timerfifo2) != 0) {

i = fifo8_get(&timerfifo2); /* 首先读入（为了设定起始点） */

io_sti();

putfonts8_asc(buf_back, binfo->scrnx, 0, 80, COL8_FFFFFF, "3[sec]");

sheet_refresh(sht_back, 0, 80, 48, 96);

} else if (fifo8_status(&timerfifo3) != 0) { /* 模拟光标 */

i = fifo8_get(&timerfifo3);

io_sti();

if (i != 0) {

timer_init(timer3, &timerfifo3, 0); /* 然后设置0 */



boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);

} else {

timer_init(timer3, &timerfifo3, 1); /* 然后设置1 */

boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);

}

timer_settime(timer3, 50);

sheet_refresh(sht_back, 8, 96, 16, 112);

}

}

}

}




■■■■■

下面就是期盼已久的“make run”了。我们执行一下，当然会顺利运行了，结果如下图。



都显示出来啦！





5　加快中断处理（1）（harib09e）

现在我们可以自由使用多个定时器了，从数量上说，已经足够了。但仔细看一下大家会发现，inthandler20还有很大问题：中断处理本来应该在很短的时间内完成，可利用inthandler20时却花费了很长时间。这就妨碍了其他中断处理的执行，使得操作系统反应很迟钝。

如果检查inthandler20，能发现每次进行定时器中断处理的时候，都会对所有活动中的定时器进行“timerctl.timer[i].timeout--;”处理。也就是说，CPU要完成从内存中读取变量值，减去1，然后又往内存中写入的操作。本来谁也不会注意到这种细微之处，但由于我们想在中断处理程序中尽可能减少哪怕是一点点工作量，所以才会注意到这里。

问题找到了，那该怎么修改才好呢？我们看看下面这样行不行。

本次的timer.c节选

void inthandler20(int *esp)

{

int i;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC */

timerctl.count++;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

if (timerctl.timer[i].timeout <= timerctl.count) { /* 这里！ */

timerctl.timer[i].flags = TIMER_FLAGS_ALLOC;

fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data);

}

}

}

return;

}




我们改变了程序中变量timer[i].timeout的含义。它指的不再是“所剩时间”，而是“予定时刻”了。因为现在的时刻计数到timerctl.count中去了，所以就拿它和timer[i].timeout进行比较，如果相同或是超过了，就通过往FIFO缓冲区里传送数据来通知HariMain。大家现在再看一看，我们一直担心的减法计算没有了。这样一改，程序的速度应该能稍微变快一些了。

下面我们也要相应地修改timer_settime函数。

本次的timer.c节选

void timer_settime(struct TIMER *timer, unsigned int timeout)

{

timer->timeout = timeout + timerctl.count; /* 这里！ */

timer->flags = TIMER_FLAGS_USING;

return;

}




timer_settime函数中所指定的时间，是“从现在开始多少多少秒以后”的意思，所以用这个时间加上现在的时刻，就可以计算出中断的预定时刻。程序中对这个时刻进行了记录。别的地方就不用改了。

■■■■■

到底这样做行不行呢，我们执行一下“make run”。好哇，进行得很顺利。虽然还没能切身感到速度变快了多少，不过先自我满足一下吧（笑）。

同时也正是因为变成了这种方式，在我们这个纸娃娃操作系统中，启动以后经过42 949 673秒后，count就是0xffffffff了，比这个值再大就不能设定了。这么多秒是几天呢？……嗯，请稍等（用计算器算一下）……大约是497天。也就是大约一年就要重新启动一次操作系统，让count归0。

这里大家可能又会有怨言了“哎呀，还需要重新起动，这样的操作系统真是麻烦”。事实上笔者本人也是这么想的（笑）。怎么办才好呢。嗯，回到上一节的做法，好不好呢？可是回到上一节的做法，速度又有些慢。……既不希望速度慢，又不想重新启动——为了满足这种奢望，我们设计成一年调整一次时刻的程序也许比较好。

时刻调整程序

int t0 = timerctl.count; /* 所有时刻都要减去这个值 */

io_cli(); /* 在时刻调整时禁止定时器中断 */

timerctl.count -= t0;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

timerctl.timer[i].timeout -= t0;

}

}

io_sti();




也许以上方法并非最好，但我们不轻言放弃而去想办法解决，这种心境是最重要的。只要努力，我们肯定还能找到别的好办法。





6　加快中断处理（2）（harib09f）

虽然像上面那样做了改进，但笔者还是觉得中断处理程序太慢了，因此我们再来改善一下吧。

改善前的timer.c节选

void inthandler20(int *esp)

{

int i;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC */

timerctl.count++;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

if (timerctl.timer[i].timeout <= timerctl.count) {

timerctl.timer[i].flags = TIMER_FLAGS_ALLOC;

fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data);

}

}

}

return;

}




如果看一下 harib09e的inthandler20，大家会发现每次中断都要执行500次（=MAX_TIMER的次数）if语句，很浪费时间。由于1秒钟就要发生100次中断，这个if语句1秒钟就要执行5万次。尽管如此，这两个if语句都为真，而其中的flags值得以更改，或者是fifo8_put函数能够执行的频率，最多也就是每0.5秒1次，即每秒2次左右。其余的49998次if语句都是在做无用功，基本没什么意义。

■■■■■

我们来变通一下思考方式，如果是人在进行着这样的定时器管理，会怎么做呢？定时器加在一起最多有500个。其中有3秒钟以后超时的，有50秒钟以后超时的，也有0.3秒钟以后超时的，还有一天以后超时的。这种情况下，我们首先会关注哪一个？应该是0.3秒钟以后的那个吧。0.3秒钟的结束后，下次是3秒钟以后的。也就是没必要把500个都看完，只要看到“下一个”的时刻就可以了。因此，我们追加一个变量timerctl.next，让它记住下一个时刻。

本次的bootpack.h节选

struct TIMERCTL {

unsigned int count, next; /* 这里！ */

struct TIMER timer[MAX_TIMER];

};




本次的timer.c节选

void inthandler20(int *esp)

{

int i;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return; /* 还不到下一个时刻，所以结束*/

}

timerctl.next = 0xffffffff;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

if (timerctl.timer[i].timeout <= timerctl.count) {

/* 超时 */

timerctl.timer[i].flags = TIMER_FLAGS_ALLOC;

fifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data);

} else {

/* 还没有超时 */

if (timerctl.next > timerctl.timer[i].timeout) {

timerctl.next = timerctl.timer[i].timeout;

}

}

}

}

return;

}




虽然程序变长了，但要做的处理却减少了。在大多数情况下，第一个if语句的return都会执行，中断处理就到此结束了。当到达下一个时刻时，使用之前那种方法检查是否超时。超时的话，就写入到FIFO中；还没超时的话就调查是否将其设定为下一个时刻（未超时时刻中，最小的时刻是下一个时刻）。

如果用这样的方法，就能大大减少没有意义的if语句的执行次数，速度也应该快多了。

■■■■■

由于使用了next，所以其他地方也要修改一下。

本次的timer.c节选

void init_pit(void)

{

int i;

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0;

timerctl.next = 0xffffffff; /* 因为最初没有正在运行的定时器 */

for (i = 0; i < MAX_TIMER; i++) {

timerctl.timer[i].flags = 0; /* 没有使用 */

}

return;

}



void timer_settime(struct TIMER *timer, unsigned int timeout)

{

timer->timeout = timeout + timerctl.count;

timer->flags = TIMER_FLAGS_USING;

if (timerctl.next > timer->timeout) {

/* 更新下一次的时刻 */

timerctl.next = timer->timeout;

}

return;

}




这样就好了。现在我们来确认是否能正常运行。“make run”。……和以前一样，虽然仍不能切身地感受到速度变快了，但还是自我满足一下吧（笑）。





7　加快中断处理（3）（harib09g）

到了harib09f的时候，中断处理程序的平均处理时间已经大大缩短了。这真是太好了。可是，现在有一个问题，那就是到达next时刻和没到next时刻的定时器中断，它们的处理时间差别很大。这样的程序结构不好。因为平常运行一直都很快的程序，会偶尔由于中断处理拖得太长，而搞得像是主程序要停了似的。更确切一点，这样有时会让人觉得“不知为什么，鼠标偶尔会反应迟钝，很卡。”

因此，我们要让到达next时刻的定时器中断的处理时间再缩短一些。嗯，怎么办呢？模仿sheet.c的做法怎么样呢？我们来试试看。

在sheet.c的结构体struct SHTCTL中，除了sheet0[ ]以外，我们还定义了*sheets[ ]。它里面存放的是按某种顺序排好的图层地址。有了这个变量，按顺序描绘图层就简单了。这次我们在Struct TIMERCTL中也定义一个变量，其中存放按某种顺序排好的定时器地址。

本次的bootpack.h节选

struct TIMERCTL {

unsigned int count, next, using;

struct TIMER *timers[MAX_TIMER];

struct TIMER timers0[MAX_TIMER];

};




变量using相当于struct SHTCTL中的top，它用于记录现在的定时器中有几个处于活动中。

■■■■■

改进后的inthandler20函数如下：

本次的timer.c节选

void inthandler20(int *esp)

{

int i, j;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return;

}

for (i = 0; i < timerctl.using; i++) {

/* timers的定时器都处于动作中，所以不确认flags */

if (timerctl.timers[i]->timeout > timerctl.count) {

break;

}

/* 超时*/

timerctl.timers[i]->flags = TIMER_FLAGS_ALLOC;

fifo8_put(timerctl.timers[i]->fifo, timerctl.timers[i]->data);

}

/* 正好有i个定时器超时了。其余的进行移位。 */

timerctl.using -= i;

for (j = 0; j < timerctl.using; j++) {

timerctl.timers[j] = timerctl.timers[i + j];

}

if (timerctl.using > 0) {

timerctl.next = timerctl.timers[0]->timeout;

} else {

timerctl.next = 0xffffffff;

}

return;

}




这样，即使是在超时的情况下，也不用查找下一个next时刻，或者查找有没有别的定时器超时了，真不错。如果有很多的定时器都处于正在执行的状态，我们会担心定时器因移位而变慢，这放在以后再改进吧（从13.5节开始讨论）。

■■■■■

由于timerctl中的变量名改变了，所以其他地方也要随之修改。

void init_pit(void)

{

int i;

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0;

timerctl.next = 0xffffffff; /* 因为最初没有正在运行的定时器 */



timerctl.using = 0;

for (i = 0; i < MAX_TIMER; i++) {

timerctl.timers0[i].flags = 0; /* 未使用 */

}

return;

}



struct TIMER *timer_alloc(void)

{

int i;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timers0[i].flags == 0) {

timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;

return &timerctl.timers0[i];

}

}

return 0; /* 没找到 */

}




这两个函数比较简单，只是稍稍修改了一下变量名。

■■■■■

在timer_settime函数中，必须将timer注册到timers中去，而且要注册到正确的位置。如果在注册时发生中断的话可就麻烦了，所以我们要事先关闭中断。

void timer_settime(struct TIMER *timer, unsigned int timeout)

{

int e, i, j;

timer->timeout = timeout + timerctl.count;

timer->flags = TIMER_FLAGS_USING;

e = io_load_eflags();

io_cli();

/* 搜索注册位置 */

for (i = 0; i < timerctl.using; i++) {

if (timerctl.timers[i]->timeout >= timer->timeout) {

break;

}

}

/* i号之后全部后移一位 */

for (j = timerctl.using; j > i; j--) {

timerctl.timers[j] = timerctl.timers[j - 1];

}

timerctl.using++;

/* 插入到空位上 */

timerctl.timers[i] = timer;

timerctl.next = timerctl.timers[0]->timeout;

io_store_eflags(e);

return;

}




这样做看来不错。虽然中断处理程序速度已经提高了，但在设定定时器期间，我们关闭了中断，这多少有些令人遗憾。不过就算对此不满意，也不要随便更改哦。

从某种程度上来讲，这也是无法避免的事。如果在设定时，多下点工夫整理一下，到达中断时刻时就能轻松一些了。反之，如果在设定时偷点懒，那么到达中断时刻时就要吃点苦头了。总之，要么提前做好准备，要么临时抱佛脚。究竟哪种做法好呢，要根据情况而定。如果是笔者的话会选择提前准备。也没有什么特殊的理由，只是笔者喜欢这样吧（笑）。

■■■■■

现在我们执行“make run”看看吧。希望它能正常运行。会怎么样呢？貌似很顺利，太好了。

关于定时器我们还有想要修改的地方。不过大家肯定已经很困了，我们还是明天再继续吧。再见！





第13天　定时器（2）



简化字符串显示（harib10a）

重新调整FIFO缓冲区（1）（harib10b）

测试性能（harib10c～charib10f）

重新调整FIFO缓冲区（2）（harib10g）

加快中断处理（4）（harib10h）

使用“哨兵”简化程序（harib10i）





1　简化字符串显示（harib10a）

昨天我们学习了不少提高定时器处理速度的内容，只是还没有学完。但如果新一章一开始就讲那么难的东西，反而会事倍功半，所以我们还是从简单的地方开始吧。

浏览一下harib09g的bootpack.c，大家会发现它居然有210行之长。这中间多次出现了如下内容：

boxfill8(buf_back, binfo->scrnx, COL8_008484, 0, 16, 15, 31);

putfonts8_asc(buf_back, binfo->scrnx, 0, 16, COL8_FFFFFF, s);

sheet_refresh(sht_back, 0, 16, 16, 32);




这段程序要完成的是：先涂上背景色，再在上面写字符，最后完成刷新。既然这部分重复出现，我们就把它归纳到一个函数中，这样更方便使用。

void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l)

{

boxfill8(sht->buf, sht->bxsize, b, x, y, x + l * 8 - 1, y + 15);

putfonts8_asc(sht->buf, sht->bxsize, x, y, c, s);

sheet_refresh(sht, x, y, x + l * 8, y + 16);

return;

}




在此补充说明一下变量的名称。

x, y ...... 显示位置的坐标

　 c ...... 字符颜色（color）

　 b ...... 背景颜色（back color）

　 s ...... 字符串（string）

　 l ...... 字符串长度（length）

利用上面的函数，刚才的3行内容就可以简写成下面的1行了。

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);




太好了！那我们就赶紧改写bootpack.c吧！

■■■■■

如果把修改的内容都列出来，就太长了，意义也不大，所以这次我们省略了。可是一点都不写的话，又有点说不过去，所以简单写个例子吧。

修改前

boxfill8(buf_back, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);

putfonts8_asc(buf_back, binfo->scrnx, 32, 16, COL8_FFFFFF, s);

sheet_refresh(sht_back, 32, 16, 32 + 15 * 8, 32);




修改后

putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15);




修改后的bootpack.c只有208行，太好了！缩短了2行。

（可不要说“只缩短了2行呀”之类的哦）。运行“make run”确认一下吧。嗯，运行正常！





2　重新调整FIFO缓冲区（1）（harib10b）

把目光转向HariMain程序，我们能发现还有其他可以简化的内容。

改写前的HariMain节选

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo)

+ fifo8_status(&timerfifo2) + fifo8_status(&timerfifo3) == 0) {

io_sti();

} else {




这都是什么呀，整这么长一个if语句？使用3个定时器的情况下，就需要3个FIFO缓冲区吗?要是100个定时器难道就需要创建100个FIFO缓冲区吗？嗯……

把定时器用的多个FIFO缓冲区都集中成1个不是更好吗？可能会有人担心：“如果集中成了1个，会不会分辨不出是哪个定时器超时了？”其实只要在超时的情况下，我们往FIFO内写入不同的数据，就可以正常地分辨出是哪个定时器超时了。

本次的HariMain节选

fifo8_init(&timerfifo, 8, timerbuf);

timer = timer_alloc();

timer_init(timer, &timerfifo, 10);

timer_settime(timer, 1000);

timer2 = timer_alloc();

timer_init(timer2, &timerfifo, 3);

timer_settime(timer2, 300);

timer3 = timer_alloc();

timer_init(timer3, &timerfifo, 1);

timer_settime(timer3, 50);




我们对if语句也进行相应的修改吧。

本次的HariMain节选

for (;;) {

sprintf(s, "%010d", timerctl.count);

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10);



io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {

io_sti();

} else {

if (fifo8_status(&keyfifo) != 0) {

（中略）

} else if (fifo8_status(&mousefifo) != 0) {

（中略）

} else if (fifo8_status(&timerfifo) != 0) {

i = fifo8_get(&timerfifo); /*超时的是哪个呢？ */

io_sti();

if (i == 10) {

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

} else if (i == 3) {

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

} else {

/* 0还是1 */

if (i != 0) {

timer_init(timer3, &timerfifo, 0); /*下面是设定为0 */

boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);

} else {

timer_init(timer3, &timerfifo, 1); /*下面是设定为1*/

boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);

}

timer_settime(timer3, 50);

sheet_refresh(sht_back, 8, 96, 16, 112);

}

}

}

}




哦，程序略有精简。bootpack.c变成204行，精简了4行。我们“make run”一下，当然是正常运行了。





3　测试性能（harib10c～harib10f）

从昨天开始，我们就在不断地对定时器进行改善，而且以后还要继续改善，但我们不能总是自我满足呀，我们要亲自感受一下到底改善到什么程度了。所以我们要测试性能。

我们之所以如此专注于定时器的改良，理由很简单，是因为在今后的开发中会经常使用定时器。经常使用的东西当然要做好。同理，我们也努力地改进了图层控制程序。

测试性能的方法很简单：先对HariMain略加修改，恢复变量count，然后完全不显示计数，全力执行“count++；”语句。当到了10秒后超时的时候，再显示这个count值。程序所做的只有这么多。可是需要注意，必须在起动3秒后把count复位为0一次。为什么要这样做呢？我们在后面的专栏里说明。

本次的HariMain节选

int mx, my, i, count = 0;



（中略）



for (;;) {

count++; /* 这里！ */



io_cli();

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {

io_sti();

} else {

if (fifo8_status(&keyfifo) != 0) {

（中略）

} else if (fifo8_status(&mousefifo) != 0) {

（中略）

} else if (fifo8_status(&timerfifo) != 0) {

i = fifo8_get(&timerfifo); /* 超时的是哪个呢？ */

io_sti();

if (i == 10) {

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

sprintf(s, "%010d", count); /* 这里！ */

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10); /* 这里！ */

} else if (i == 3) {

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

count = 0; /* 开始测定 */

} else {

/* 0还是1 */

if (i != 0) {

timer_init(timer3, &timerfifo, 0); /* 下面是设定为0 */

boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);

} else {



timer_init(timer3, &timerfifo, 1); /* 下面是设定为1 */

boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);

}

timer_settime(timer3, 50);

sheet_refresh(sht_back, 8, 96, 16, 112);

}

}

}

}




■■■■■

我们先执行一下这段程序吧。运行“make run”。



在笔者的环境中执行haribl10c

像这样，10秒钟结果就出来了。大家试着运行几次“make run”，会发现每次结果都不同。我们运行了5次。在测试期间的10秒钟内，不要动鼠标也不要按键。如果动鼠标或按键了，程序就不得不进行光标的显示处理，这样会减缓count的增长。

用“make run”运行5次harib10c的结果

0002638668

0002639649

0002638944

0002648179

0002637604




5次结果是如此发散，是由于使用模拟器而受到了Windows的影响。5次结果中，最大值与最小值的差有10575之大。因此我们在真机上也执行“make install”1看看。

1 在真机上也进行了测试：笔者用的真机是“AMD Duron 800MHz，内存为192MB”的组装机。

用真机执行5次harib10c的结果

0074643522

0074643698

0074643532

0074643699

0074643524




靠按复位按钮完成多次起动，的确很麻烦，我们只做了5次。得到的数值收敛得很好，最大值和最小值的差只有177。果然还是真机好呀。虽然用了真机，可还是出现了177的误差，其原因在于电脑内部的温度変化，或时钟频率的微妙変化。

■■■■■

下面来看看，如果对harib10c程序利用harib09d时候的timer.c和bootpack.h，结果会怎样呢？赶紧尝试一下吧，当然是在误差较小的真机上做了。我们这时的程序叫作harib10d。

用真机执行5次harib10d的结果

0074620088

0074620077

0074619893

0074619902

0074619967




像这样记流水账似的罗列一堆数值，谁也看不出个所以然。我们还是计算一下平均值吧。

harib10c:0074643595

harib10d:0074619985

可以看得出来，harib10c比harib10d快了23610个数。这下我们能够确定程序的确有了改进，太好了！昨天的辛苦总算没有白费。

那么harib09e和harib09f的定时器控制又怎么样呢？笔者使用它们分别创建了harib10e和harib10f，而且也在真机上进行了测试，结果总结如下。

harib10d:0074619985(最初的定时器)

harib10e:0074629087(舍弃剩余时间，记忆超时时刻)

harib10f:0074633350(导入next)

harib10c:0074643595(导入timers[ ])

大家可以看出，程序每改良一次速度就提高一点。

COLUMN-7　起动3秒后，将count置为0的原因

首先考虑一下这个命令的意思吧。起动3秒后把count复位至0，这与从3秒后开始计数是一样的。画面上要到10秒以后才显示，这样测试的时间就是7秒钟。

事实上，笔者最初并没有加入“count=0;”语句。但那样做的结果是，在真机上测定harib10d时，最高值和最低值的差值竟然达到了150054。这可了不得呀。差值这么大，即使我们比较harib10c和harib10d，也不知道哪个更快。

对于这样的结果，笔者曾茫然不知所措，差一点要放弃性能比较。但后来笔者忽然想起，只要某些条件稍微有些变化，电脑初始化所花费的时间就会有很大变化。这就是为什么我们在起动后3秒钟之内不进行测试的原因。这样做之后，误差急剧减小，终于可以比较结果了，真是太好了。





4　重新调整FIFO缓冲区（2）（harib10g）

我们已经可以确定性能真正得到了改善，所以下面把程序恢复到harib10c，沿着13.2节继续思考吧。

既然可以把3个定时器归纳到1个FIFO缓冲区里，那是不是可以把键盘和鼠标都归纳起来，只用1个FIFO缓冲区来管理呢？如果能够这样管理的话，程序就可以写成：

if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) + fifo8_status(&timerfifo) == 0) {




冗长的if语句，也可以缩短了。那么或许harib10c中206行的bootpack.c也能简化。

■■■■■

在13.2节中，通过往FIFO内写入不同的数据，我们可以把3个定时器归入1个FIFO缓冲区里。同理，分别将从键盘和鼠标输入的数据也设定为其他值就可以了。那好，我们就这么办。

（写入FIFO的数值 中断类型）

0～ 1…………………光标闪烁用定时器

3…………………3秒定时器

10…………………10秒定时器

256～ 511…………………键盘输入（从键盘控制器读入的值再加上256）

512～ 767……鼠标输入（从键盘控制器读入的值再加上512）

这样，1个FIFO缓冲区就可以正常进行处理了。真是太好了！不过现在有一个问题，fifo8_put函数中的参数是char型，所以不能指定767那样的数值。哎，我们好不容易整理到1个缓存器中了，却又出现这种问题。

■■■■■

所以，我们想将写入FIFO缓冲区中的内容改成能够用int指定的形式。大家可不要担心哦。内容上与FIFO8完全相同。只是将char型变成了int型。

本次的bootpack.h节选

struct FIFO32 {

int *buf;

int p, q, size, free, flags;

};




本次的fifo.c节选

void fifo32_init(struct FIFO32 *fifo, int size, int *buf)

/* FIFO缓冲区的初始化*/

{

fifo->size = size;

fifo->buf = buf;

fifo->free = size; /*空*/

fifo->flags = 0;

fifo->p = 0; /*写入位置*/

fifo->q = 0; /*读取位置*/

return;

}



int fifo32_put(struct FIFO32 *fifo, int data)

/*给FIFO发送数据并储存在FIFO中*/

{

if (fifo->free == 0) {

/*没有空余空间，溢出*/

fifo->flags |= FLAGS_OVERRUN;

return -1;

}

fifo->buf[fifo->p] = data;

fifo->p++;

if (fifo->p == fifo->size) {

fifo->p = 0;

}

fifo->free--;

return 0;

}



int fifo32_get(struct FIFO32 *fifo)

/*从FIFO取得一个数据*/

{

int data;

if (fifo->free == fifo->size) {

/*当缓冲区为空的情况下返回-1*/

return -1;

}

data = fifo->buf[fifo->q];

fifo->q++;

if (fifo->q == fifo->size) {

fifo->q = 0;

}

fifo->free++;



return data;

}



int fifo32_status(struct FIFO32 *fifo)

/*报告已经存储了多少数据*/

{

return fifo->size - fifo->free;

}




■■■■■

下面我们就要写键盘和鼠标的相关程序了。我们不使用FIFO8，而是改为使用FIFO32。

本次的keyboard.c节选

struct FIFO32 *keyfifo;

int keydata0;



void init_keyboard(struct FIFO32 *fifo, int data0)

{

/* 将FIFO缓冲区的信息保存到全局变量里 */

keyfifo = fifo;

keydata0 = data0;

/* 键盘控制器的初始化 */

wait_KBC_sendready();

io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);

wait_KBC_sendready();

io_out8(PORT_KEYDAT, KBC_MODE);

return;

}



void inthandler21(int *esp)

{

int data;

io_out8(PIC0_OCW2, 0x61); /* 把IRQ-01接收信号结束的信息通知给PIC */

data = io_in8(PORT_KEYDAT);

fifo32_put(keyfifo, data + keydata0);

return;

}




本次的mouse.c节选

struct FIFO32 *mousefifo;

int mousedata0;



void enable_mouse(struct FIFO32 *fifo, int data0, struct MOUSE_DEC *mdec)

{

/* 将FIFO缓冲区的信息保存到全局变量里 */

mousefifo = fifo;

mousedata0 = data0;

/* 鼠标有效 */

wait_KBC_sendready();

io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);

wait_KBC_sendready();

io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);

/* 顺利的话，ACK(0xfa)会被发送*/

mdec->phase = 0; /* 等待鼠标的0xfa的阶段*/

return;

}



void inthandler2c(int *esp)



/* 基于PS/2鼠标的中断 */

{

int data;

io_out8(PIC1_OCW2, 0x64); /* 把IRQ-12接收信号结束的信息通知给PIC1 */

io_out8(PIC0_OCW2, 0x62); /* 把IRQ-02接收信号结束的信息通知给PIC0 */

data = io_in8(PORT_KEYDAT);

fifo32_put(mousefifo, data + mousedata0);

return;

}




■■■■■

修改定时器结构体，让它也能使用FIFO32。

本次的bootpack.h节选

struct TIMER {

unsigned int timeout, flags;

struct FIFO32 *fifo;

int data;

};




本次的timer.c节选

void timer_init(struct TIMER *timer, struct FIFO32 *fifo, int data)

{

timer->fifo = fifo;

timer->data = data;

return;

}



void inthandler20(int *esp)

{

int i, j;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收信号结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return;

}

for (i = 0; i < timerctl.using; i++) {

/* 因为timers的定时器都处于运行状态，所以不确认flags */

if (timerctl.timers[i]->timeout > timerctl.count) {

break;

}

/* 超时 */

timerctl.timers[i]->flags = TIMER_FLAGS_ALLOC;

fifo32_put(timerctl.timers[i]->fifo, timerctl.timers[i]->data); /* 这里！ */

}

/* 正好是i个定时器超时了。移位其余的定时器。 */

timerctl.using -= i;

for (j = 0; j < timerctl.using; j++) {

timerctl.timers[j] = timerctl.timers[i + j];

}

if (timerctl.using > 0) {

timerctl.next = timerctl.timers[0]->timeout;

} else {

timerctl.next = 0xffffffff;

}

return;

}




■■■■■

这样，我们的准备工作就完成了。最后我们来修改bootpack.c。

本次的HariMain节选

struct FIFO32 fifo;

char s[40];

int fifobuf[128];

（中略）

fifo32_init(&fifo, 128, fifobuf);

init_keyboard(&fifo, 256);

enable_mouse(&fifo, 512, &mdec);

io_out8(PIC0_IMR, 0xf8); /* 设定PIT和PIC1以及键盘为许可(11111000) */

io_out8(PIC1_IMR, 0xef); /* 设定鼠标为许可(11101111) */



timer = timer_alloc();

timer_init(timer, &fifo, 10);

timer_settime(timer, 1000);

timer2 = timer_alloc();

timer_init(timer2, &fifo, 3);

timer_settime(timer2, 300);

timer3 = timer_alloc();

timer_init(timer3, &fifo, 1);

timer_settime(timer3, 50);



（中略）



for (;;) {

count++;



io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /* 键盘数据*/

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

} else if (512 <= i && i <= 767) { /* 鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

/* 已经收集了3字节的数据，所以显示出来 */

sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);

if ((mdec.btn & 0x01) != 0) {

s[1] = 'L';

}

if ((mdec.btn & 0x02) != 0) {

s[3] = 'R';

}

if ((mdec.btn & 0x04) != 0) {

s[2] = 'C';

}

putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15);

/* 鼠标指针的移动 */

mx += mdec.x;

my += mdec.y;

if (mx < 0) {

mx = 0;

}

if (my < 0) {

my = 0;

}

if (mx > binfo->scrnx - 1) {

mx = binfo->scrnx - 1;

}



if (my > binfo->scrny - 1) {

my = binfo->scrny - 1;

}

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10);

sheet_slide(sht_mouse, mx, my);

}

} else if (i == 10) { /* 10秒定时器 */

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

sprintf(s, "%010d", count);

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10);

} else if (i == 3) { /* 3秒定时器 */

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

count = 0; /* 开始测试 */

} else if (i == 1) { /* 光标用定时器*/

timer_init(timer3, &fifo, 0); /* 下面是设定0 */

boxfill8(buf_back, binfo->scrnx, COL8_FFFFFF, 8, 96, 15, 111);

timer_settime(timer3, 50);

sheet_refresh(sht_back, 8, 96, 16, 112);

} else if (i == 0) { /* 光标用定时器 */

timer_init(timer3, &fifo, 1); /* 下面是设定1 */

boxfill8(buf_back, binfo->scrnx, COL8_008484, 8, 96, 15, 111);

timer_settime(timer3, 50);

sheet_refresh(sht_back, 8, 96, 16, 112);

}

}

}




哦，经过修正，bootpack.c简化成了198行，足足减少了8行呀。

■■■■■

下面我们执行“make run”。能不能顺利地运行呢？运行正常，太好了！



数字也在增加呀？！

嗯，和harib10c相比，结果值好了很多，竟然达到了1.7倍。

在模拟器上进行比较

harib10c:0002638668

harib10g:0004587870

这个结果可靠吗？（或许这个差异是模拟器或Windows造成的）。我们还是在真机上运行“make install”看看吧。

在真机上进行比较

harib10c:0074643595

harib10g:0099969263

差距是1.3倍左右。虽然改善幅度没有模拟器上大，但的的确确是改善了。

我们来想想这是为什么吧。定时器处理并没有变快，所以应该还有其他原因。……此次我们改写最多的是HariMain。在HariMain里，执行“count++;”语句和查询FIFO缓冲区中是否有数据这两个操作，是多次交互进行的。这次修改以后，程序只需要看1个FIFO缓冲区就行了，而以前要看3个。也就是说，FIFO缓冲区的查询能够更快完成，从而使得“count++;”语句执行的次数更多。

程序精简了，速度还变快了，太好了。





5　加快中断处理（4）（harib10h）

我们赶紧继续做昨天没有做完的定时器改良工作吧。现在最让我们费心的是inthandler20中最后的移位处理和timer_settime中的移位处理。timer_settime虽然不是中断处理程序，但毕竟是在中断禁止期间进行的，所以必须要迅速完成。如果像现在这样，使用的定时器只有3个，用目前的处理方式还没什么问题。可当我们面对多任务时，很多应用程序同时运行，每个应用程序都使用定时器，此时如果还是使用移位处理的话，就有点浪费时间了。

在FIFO里有一个取代移位处理的方法：读取一个数据以后不是让后面的数据向前靠齐，而是改变下一次的数据读取地址。这是一个很巧妙的方法，但不适用于定时器。因为从timers[ ]中去除超时的中断时，这个方法虽然不错，但问题在于，用timer_settime登录中断时，后面的中断必须后移，在这一点上，以上方法不太好。

因此笔者再介绍一个新方法。

■■■■■

下面，我们在结构体struct TIMER中加入next变量。这是个地址变量，用来存放下一个即将超时的定时器的地址。

本次的bootpack.h节选

struct TIMER {

struct TIMER *next;

unsigned int timeout, flags;

struct FIFO32 *fifo;

int data;

};




我们还是用下面的示意图来说明结构体struct TIMER。



next表示下一个即将超时的定时器地址，图示如下。



大家也许会想，这样的图有什么用呢？图示的方法有助于理解，所以请大家坚持看下去。

■■■■■

那么，试着按照这段内容，修改定时器的中断处理程序吧。

利用next的inthandler20函数

void inthandler20(int *esp)

{

int i;

struct TIMER *timer;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收信号结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return;

}

timer = timerctl.timers[0]; /* 首先把最前面的地址赋给timer */

for (i = 0; i < timerctl.using; i++) {

/* 因为timers的定时器都处于运行状态，所以不确认flags*/

if (timer->timeout > timerctl.count) {

break;

}

/* 超时 */

timer->flags = TIMER_FLAGS_ALLOC;

fifo32_put(timer->fifo, timer->data);

timer = timer->next; /* 下一定时器的地址赋给timer */

}

timerctl.using -= i;



/* 新移位 */

timerctl.timers[0] = timer;



/* timerctl.next的设定 */

if (timerctl.using > 0) {

timerctl.next = timerctl.timers[0]->timeout;

} else {

timerctl.next = 0xffffffff;

}

return;

}




移位部分暂时放一放，大家先看一下超时的处理。和以前不同，对于timers[ ]数组而言，除了timers[0]以外其他完全是没有必要的。这一点是重中之重。

如果不需要超时处理，还认真地去做移位处理就完全没有道理了。所以在移位处理中只改写timers[0]。

■■■■■

下面修改timer_settime函数了。

利用next之后的timer_settime

void timer_settime(struct TIMER *timer, unsigned int timeout)

{

int e;

struct TIMER *t, *s;

timer->timeout = timeout + timerctl.count;

timer->flags = TIMER_FLAGS_USING;

e = io_load_eflags();

io_cli();

timerctl.using++;

if (timerctl.using == 1) {

/* 处于运行状态的定时器只有这一个时 */

timerctl.timers[0] = timer;

timer->next = 0; /* 没有下一个 */

timerctl.next = timer->timeout;

io_store_eflags(e);

return;

}

t = timerctl.timers[0];

if (timer->timeout <= t->timeout) {

/* 插入最前面的情况下 */

timerctl.timers[0] = timer;

timer->next = t; /* 下面是t */

timerctl.next = timer->timeout;

io_store_eflags(e);

return;

}

/* 搜寻插入位置 */

for (;;) {

s = t;

t = t->next;

if (t == 0) {

break; /* 最后面*/

}



if (timer->timeout <= t->timeout) {

/* 插入到s和t之间时 */

s->next = timer; /* s的下一个是timer */

timer->next = t; /* timer的下一个是t */

io_store_eflags(e);

return;

}

}

/* 插入最后面的情况下 */

s->next = timer;

timer->next = 0;

io_store_eflags(e);

return;

}




程序还是变长了。 变量t是从头开始对timers[ ]进行遍历用的，而s用来保存前一个t值。t是timer的省略（timer这个变量名已经被使用了），而s是英文字母表中t的前一个字母。

判断一下顺序，如果我们知道了插入的位置（即知道了在s和t中间插入的话），就可以像下图那样把数据重新连接起来。也就是仅仅改变s —>next和timer —>next的值就可以了。看看下图可能会更容易理解。



这样就可以不进行移位了。我们成功了！现在就算使用很多定时器，速度也不会变慢了。

这里再说几句题外话。笔者写了后面很多章之后再回过头来读这段程序，才觉得timer—>next和timerctl.next很容易混淆。timer—>next是指下一个定时器的地址，而timerctl.next是指下一个超时的时刻。所以有点后悔，如果当初将它们分别命名为next_timer和next_time就好理解多了。

笔者没有修改（主要是受到出版时间的限制），大家如果能代笔者修改一下就最好了。或者大家读这段程序时，先在脑海里自己修改一下，然后再读，也许更有助于理解。

■■■■■

话说到这里，timers[ ]已经不需要了。不过不是全都不要，最前面的timers[0]还是要保留的，它后面的部分都没有用了。因此我们来删掉这些数据。只有1个timers[0]的话，就没必要加[ ]了，所以我们把名字定义为t0好了。

本次的bootpack.h节选

struct TIMERCTL {

unsigned int count, next, using;

struct TIMER *t0;

struct TIMER timers0[MAX_TIMER];

};




相应地，也要把刚才写的inthandler20和timer_settime中的timers[0]也改写为t0。改写后的程序，没有写在这里，如果想看的话，可以浏览附带光盘中的文档。

好了，这样应该可以顺利运行了吧。应该没问题的，否则就麻烦了。真紧张呀。我们运行“make run”看看。哦，运行成功！

虽然我们还是不知道速度是否变快了，还是很满足（又来了）。但是总感觉数值变差了，难道是错觉?





6　使用“哨兵”简化程序（harib10i）

标题中略显突兀的“哨兵”一词，其实是程序技巧中的专门用语。一般来讲，说到“哨兵”，大家会想到巡逻的士兵。可一旦大家知道了这项技术的内容，肯定会认为这个名字取得太好了。总之笔者认为这是一个很棒的名称。

顺便说一下，上一节的技术称为“线性表”（linear list）。可笔者觉得这个名字不太容易理解。其实它就像挖红薯一样，我们拔第一根红薯蔓，就能挖出第一个红薯，再拔这个红薯的蔓，就能挖出下一个红薯来，所以，如果是笔者的话，就会把这种技术命名为“拔红薯式”。

■■■■■

harib10h的timer.c程序在去除移位处理后，其中的timer_settime函数还是有些冗长。浓缩的才是精华，我们来想办法简化这个程序。

我们看看程序就会发现，其中有4种可能：



运行中的定时器只有一个的情况



插入到最前面的情况



插入到s和t之间的情况



插入到最后面的情况





“既然有这么多种情况，当然要加各种条件，程序长了点也没办法”，大家可不能这样轻易放弃。如果是因为有4种可能才使程序变复杂了的话，那我们想办法消除这4种可能性不就行了吗？

我们来看看具体的做法。在进行初始化的时候，将时刻0xffffffff的定时器连到最后一个定时器上。虽然我们偷了点懒没有设定fifo等，但不必担心。反正无论如何都不可能到达这个时刻（在到达之前会修改时刻），所以不可能发生超时问题。它一直处于后面，只是个附带物，是个留下来看家的留守者。这个留守者正是“哨兵“。

加入了哨兵

void init_pit(void)

{

int i;

struct TIMER *t;

io_out8(PIT_CTRL, 0x34);

io_out8(PIT_CNT0, 0x9c);

io_out8(PIT_CNT0, 0x2e);

timerctl.count = 0;

for (i = 0; i < MAX_TIMER; i++) {

timerctl.timers0[i].flags = 0; /* 没有使用 */

}

t = timer_alloc(); /* 取得一个 */

t->timeout = 0xffffffff;

t->flags = TIMER_FLAGS_USING;

t->next = 0; /* 末尾 */

timerctl.t0 = t; /* 因为现在只有哨兵，所以他就在最前面*/

timerctl.next = 0xffffffff; /* 因为只有哨兵，所以下一个超时时刻就是哨兵的时刻 */

timerctl.using = 1;

return;

}




如果使用在12.5节中介绍的一年调整一次时刻的程序，就必须修改程序来保证不改变哨兵的时刻。比如改写成下面这样：

哨兵的时刻调整程序

int t0 = timerctl.count; /* 所有的时刻都要减去这个值 */

io_cli(); /* 在时刻调整时禁止中断 */

timerctl.count -= t0;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timer[i].flags == TIMER_FLAGS_USING) {

if (timerctl.timer[i].timeout != 0xffffffff) {

timerctl.timer[i].timeout -= t0;

}

}

}

io_sti();




■■■■■

由于加入了哨兵，settime的状况就变了。4种情况中有2种情况是绝对不会发生的。（下面的第1种和第4种）



处于运行中的定时器只有这1个的情况（因为有哨兵，所以最少应该有2个）



插入最前面的情况



插入s和t之间的情况



插入最后的情况（哨兵总是在最后）





所以程序能简化不少，缩短了16行。

精简后的timer_settime

void timer_settime(struct TIMER *timer, unsigned int timeout)

{

int e;

struct TIMER *t, *s;

timer->timeout = timeout + timerctl.count;

timer->flags = TIMER_FLAGS_USING;

e = io_load_eflags();

io_cli();

timerctl.using++;

t = timerctl.t0;

if (timer->timeout <= t->timeout) {

/* 插入最前面的情况 */

timerctl.t0 = timer;

timer->next = t; /* 下面是设定t */

timerctl.next = timer->timeout;

io_store_eflags(e);

return;

}

/* 搜寻插入位置 */

for (;;) {

s = t;

t = t->next;

if (timer->timeout <= t->timeout) {

/* 插入s和t之间的情况 */

s->next = timer; /* s下一个是timer */



timer->next = t; /* timer的下一个是t */

io_store_eflags(e);

return;

}

}

}




■■■■■

现在我们终于能简化inthandler20函数了。程序最后的部分。

稍稍精简了的inthandler20

void inthandler20(int *esp)

{

int i;

struct TIMER *timer;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收信号结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return;

}

timer = timerctl.t0; /* 首先把最前面的地址赋给timer */

for (i = 0; i < timerctl.using; i++) {

/* 因为timers的定时器都处于运行状态，所以不确认flags */

if (timer->timeout > timerctl.count) {

break;

}

/* 超时 */

timer->flags = TIMER_FLAGS_ALLOC;

fifo32_put(timer->fifo, timer->data);

timer = timer->next; /* 将下一定时器的地址代入timer*/

}

timerctl.using -= i;



/* 新移位 */

timerctl.t0 = timer;



/* timerctl.next的设定 */ /* 这里！ */

timerctl.next = timerctl.t0->timeout;

return;

}




■■■■■

修改到这里以后，using就没什么用处了。……using以前用于对运行中的定时器进行计数。那时还使用数组timers[ ] ，using起过非常大的作用，它帮助我们记录timers[ ]已被使用到了哪个位置。另外，在不使用数组timers[ ]后，根据它是否变为0，我们才能决定应该怎样设定next。但是现在有了哨兵，就不会出现using为0的情况了。

所以，我们就让using光荣退休吧。再见了，using。感谢你一直帮助我们控制定时器，我们不会忘记你的……这当然是玩笑啦，笔者可没那么聪明能一直记住不再使用的变量。正所谓，“一切都是过眼云烟，什么都是浮云！”。ByeBye，using ！（笑）。

这样一来，inthandler20就变得更清爽整洁了。

本次的timer.c节选

void inthandler20(int *esp)

{

struct TIMER *timer;

io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00接收信号结束的信息通知给PIC */

timerctl.count++;

if (timerctl.next > timerctl.count) {

return;

}

timer = timerctl.t0; /* 首先把最前面的地址赋给timer*/

for (;;) {

/* 因为timers的定时器都处于运行状态，所以不确认flags */

if (timer->timeout > timerctl.count) {

break;

}

/* 超时 */

timer->flags = TIMER_FLAGS_ALLOC;

fifo32_put(timer->fifo, timer->data);

timer = timer->next; /* 将下一个定时器的地址赋给timer*/

}

timerctl.t0 = timer;

timerctl.next = timer->timeout;

return;

}




我们进一步从settime中删除“timerctl.using++;”，从init_ pit中删除“timerctl.using=1；”。嗯，很清爽呀。

■■■■■

那么今天的任务到此就结束了。为了确认结果，我们当然要运行“make run”了。运行结果很正常。嗯……但是与harib10g比较起来，结果值还是不太理想。怎么回事呢。如果在真机上运行，是不是效果一样呢？



稍稍变慢了？

虽然很想搞清楚原因，不过都已经这个时间了，所以今天就先到这里吧。我们明天再仔细思考。





第14天　高分辨率及键盘输入



继续测试性能（harib11a～ harib11c）

提高分辨率（1）（harib11d）

提高分辨率（2）（harib11e）

键盘输入（1）（harib11f）

键盘输入（2）（harib11g）

追记内容（1）（harib11h）

追记内容（2）（harib11i）





1　继续测试性能（harib11a ～ harib11c）

昨天的harib10i程序的执行结果，让笔者很不甘心，所以一早赶紧在真机上运行一下，看看效果。

真机上的运行结果比较

harib10g: 0099969263

harib10i: 0099969264

哦，几乎没什么不同。看来数值变小好像是由于模拟器的原因（Windows的原因?）。程序本身并没有问题，暂时松了一口气。

虽然放心了一些，但终究还是不满意。速度没有变慢，这当然令人欣慰。但我们费了半天劲，做了各种修改之后，与harib10g比较起来，速度却完全没有变快，大家不觉得很不甘心吗？至少笔者很不甘心。

然而当我们仔细思考一下后，会发现harib10h的改进之处在于“消除了移位处理”。也就是说，对于发生很多“移位”的情况，改进应该是有效果的。只有在大量使用定时器的时候，才会发生很多“移位”。如今只使用3个定时器，看不到改进效果也是理所当然的。所以，如果我们特意使用大量定时器，然后进行性能比较，改进效果或许能让人满意（笑）。

■■■■■

既然这样，我们就赶快试一下吧。在timer.c中，最多可以设定500个定时器。设定起动50天后1才超时的定时器490个左右，使得50天后，每隔1秒就有一个定时器超时。设定这么多定时器以后，有没有“移位”，就能从数字上看出来。

1 为什么是50天后呢？因为我们并不考虑定时器超时的情况，所以为了不让其超时，先暂时设定为50天。虽然设成1天以后也可以，但如果谁启动后一直开着，任其运行的话，可能会造成超时而导致误操作，所以还是设为50天吧。

本次的bootpack.c节选

void set490(struct FIFO32 *fifo, int mode)

{

int i;

struct TIMER *timer;

if (mode != 0) {

for (i = 0; i < 490; i++) {

timer = timer_alloc();

timer_init(timer, fifo, 1024 + i);

timer_settime(timer, 100 * 60 * 60 * 24 * 50 + i * 100);

}

}

return;

}




还有，在设定HariMain的timer～timer3之前，要先加入“set490（&fifo,1）；”语句。这样就可以追加490个定时器了。

那么，我们在timer.c中作出各种设定，分别运行“make install”，比较它们在真机上运行的结果。另外，还可以将“set490（&fifo,1）；”替换成“set490（&fifo,0）”，或者是什么语句也不加入（即不修改造），然后测定它们在真机上的运行结果。我们分别运行5次，取平均值归纳如下。

真机上运行结果的比较



追加490个定时器时的值 set490（&fifo, 1）;

harib11a:0096521077……harib10g里加入set490的时候(有移位)

harib11b:0096522038……harib10h里加入set490的时候(没有移位、没有哨兵)

harib11c:0096522097……harib10i里加入set490的时候(没有移位、有哨兵)



不追加490个定时器时的值 set490（&fifo, 0）;

harib11a:0096522095……harib10g里加入set490的时候(有移位)

harib11b:0096522038……harib10h里加入set490的时候(没有移位、没有哨兵)

harib11c:0096522101……harib10i里加入set490的时候(没有移位、有哨兵)



参考：不加入set490语句时的值

harib10g:0099969263……(有移位)

harib10h:0099969184……(没有移位、没有哨兵)

harib10i:0099969264……(没有移位、有哨兵)





让我们好好观察一下这个结果吧。

■■■■■

首先观察一下(1)，也就是追加490个定时器的情况。取消移位则速度变快（差是961）。可以看出，线性表对于性能改善有效果。太好了！而且使用哨兵也有效果，虽然只是一点点，但速度还是变快了（差是59）。使用哨兵不仅精简了程序，也加快了速度，一举两得。

再观察一下(2)也就是不追加490个定时器的情况。没有哨兵时，取消移位反而导致速度变慢（差是57）。而使用哨兵时取消移位，速度就可以追上了（虽然也可以说是“超过”，不过只超了6，所以还是说“相同”吧）。

另一方面，我们比较一下(1)的harib11c和(2)的harib11c。结果值几乎一样。在这个没有移位的方法中，无论使用的定时器的数量是多少，性能都没有变化。至于harib11a，因为定时器的数量差别，性能上的差异会达到1018（计数结果差别是1018）。而harib11b好像也与定时器的数量无关。因此我们取消移位是正确的。

最后我们看一下(3)的结果。由于取消了移位，性能（即计数结果）上有79左右的下降，不过使用了哨兵就能恢复性能。

■■■■■

但是，对于(2)和(3)，处理上虽然完全相同，而结果却相差了345万左右。这个差别实在是太大了，不可思议。……到底怎么回事儿呢？这不是程序内容的问题，而是C编译器的问题。实际上，由于跳转目标地址不同，CPU的JMP指令执行的时钟周期数也不相同。在HariMain中，循环执行“count++；”的for语句虽然最终被编译为JMP指令执行，但如果前面加上“set490（&fifo,0）；”语句，那么以后各个指令的地址也都会相应地错开几个字节，结果造成JMP指令的地址也略有变化。因此执行时间也稍稍延迟，执行结果大约变差了3%。

for语句被编译后的结果

for(;;) { L2：

count++; count++;

任意语句; -> 任意语句;

} JMP L2

这个L2的地址一旦变化，JMP的执行时间就变化！




这一次虽然执行速度慢了，但也有时候，追加命令以后，会变快。如果用nask来编写HariMain，JMP指令的跳转目标的地址可以根据情况自动调整，这个问题就不会发生了。但仅仅是为了达到这个目的（即确认JMP地址能自动调整，以达到自我满足的目的），而用nask来改写HariMain的话，就有些劳师动众了，所以这次我们没做。

再来跟大家说一段插曲吧。最初笔者只创建了程序(1)和(3)。看到(1)的harib11c和(3)的harib10i的结果竟然有着如此巨大的差异，笔者也是出了一身冷汗。笔者之前的预测是，不使用移位而使用哨兵的话，即使定时器的数目再多，执行时间也不应该有什么变化。但结果却出乎意料。为此笔者几乎认定timer.c中有bug，并苦恼了好几个小时（苦笑）。最后，笔者怎么想都觉得timer.c没有问题，于是就去查看bootpack.c编译而成的机械语言（bootpack.lst）。经过比较才想起，原来JMP指令跳转目标的地址不同，执行时间也不相同。因此笔者立即创建了动作与(3)相同而JMP指令的地址不变的程序(2)，并进行了测定。

令人高兴的是，这样做之后，结果正如笔者最初所预想的那样，在“无移位＋哨兵”的情况下，即使定时器的数目变化了，处理速度也不变。真是太好了。之前笔者还老担心是否要改写昨天的内容呢。

COLUMN-8　如此细微的改进有意义吗？

前天和昨天我们对timer.c进行了改进，又是使用timers[ ]，又是使用线性表，还使用了哨兵，花了不少时间。可得到的改善只有一点点。

0096521077 → 0096522097 在(1)中，harib11a → harib11c

差值只有1020，这个差值和整体性能相比只有可怜的0.001%。

有人会注意到0.001%吗？我们买瓶装饮料的时候，假设商店的货架上，有一瓶比其他的多出一滴，会有人真正考虑那是哪一瓶吗？我们这里谈到的0.001%，简直就像2升的饮料多出来的一滴一样。……再举个更实际的例子，一件工作需要1个小时完成，为了早完成0.9秒，你愿意下这么大工夫吗?

这类批判性的思考方式基本上也是正确的，也就是说，要想加快整体上的速度，不应该去做这种费力不讨好的事，而应该把精力集中在简单而效果明显的方法上，比如将FIFO8改成 FIFO32（效果有1.3倍吧）。

但是希望大家回想一下，现在我们不是在加快整体的动作速度，而是一直在努力缩短哪怕是一点点的中断禁止时间。我们真正想实现的是这样的操作系统：一按下按键立即就有反应，一动鼠标立即就有反应，一旦设定了动作的时间点就会在那个时间点动作(没有些许的延迟)。

这里我们讨论的1020这个差，恰好就意味着中断禁止时间缩短了。也就是说，系统对中断的反应能力提高了。即使是在不凑巧，很多中断几乎同时发生的情况下，系统也能够更快地对这些中断要求做出反应。要是从这一点来考虑的话，1020的差异可就不是一个小数了，而是很有意义的成果。





2　提高分辨率（1）（harib11d）

从着手“自制操作系统”到现在，不知不觉间已经过去2周了。有的读者朋友读到这里，可能已经花了更长的时间；也有的朋友，经过努力也可能只用了一周左右就读到了这里。

笔者认为，开发一个操作系统需要一些必备知识，像编程语言的知识，相关算法和技巧等。到现在为止，这些知识的介绍就结束了。知道了这些，今后只要灵活运用前几章的学习内容，就可以开发出不错的操作系统了。到现在为止的学习过程觉得怎么样？回过头来想一想，如果大家有什么不明白的内容，也许趁着现在就弄清楚比较好。

那么我们赶快把“纸娃娃操作系统”做得更像一个真正的操作系统吧。大家现在可以接触多任务了。可是按计划，我们是从第15天开始才学习多任务的，所以今天还是暂时不学习多任务吧。

笔者如果想休息了，可以跟大家说“今天就学到这里吧（笑）”，可读者朋友们肯定会觉得 “没什么意思呀”，所以还是学点儿别的吧。嗯，学点儿什么呢？好吧，就学提高画面分辨率吧。

从开发操作系统的角度来看，现在这样的320×200的画面也没什么问题，可毕竟还是大画面好。以前，我们特意创建了struct BOOTINFO，就是为了能在以后扩大画面。那时我们没有写成“320”，而是特意写成了“binfo —> xsize”这种很麻烦的方式。这种麻烦辛苦，现在终于得到了回报。

■■■■■

高分辨率的利用方法因显卡不同而不同。首先，为了能通过“make run”运行，我们只考虑支持QEMU模拟器的显卡。这个卡顺利运行以后，再去支持其他的显卡。

由于画面切换中我们要使用BIOS，所以就需要改写asmhead.nas的“画面模式设定”部分了。哦，好久没写汇编程序了。

本次的asmhead.nas节选

; 设定画面模式



MOV BX,0x4101 ; VBE的640x480x8bi彩色

MOV AX,0x4f02

INT 0x10

MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）

MOV WORD [SCRNX],640

MOV WORD [SCRNY],480

MOV DWORD [VRAM],0xe0000000




程序的构成几乎没什么变化。但是数值是0x4101或0x4f02，有点儿怪怪的。这些数字是怎样查出来的？笔者估计会有人问这个问题，可与其追问这样的问题，不如先看看画面扩大后的“纸娃娃操作系统”。所以，我们先运行“make run”。



哦，画面宽阔

因为大家已经习惯于以前的大文字显示，所以640×480看起来非常宽阔。高分辨率画面，嗯，感觉就是不一样，好像变成了另外一个操作系统。

大家肯定想在真机上演示这个程序吧。可这个程序只能在QEMU模拟器上执行。就像刚才说的，这个程序是专门面向QEMU创建的。所以，在真机上执行的时候，电脑还是有可能发生误动作。

■■■■■

下面来说明为什么这个程序能够在640×480画面上运行。

其实说起来也很简单。给AX赋值0x4f02，给BX赋值画面模式号码，这样就可以切换到高分辨率画面模式了。为什么呢？这个笔者也答不上来，原本就是这样的。这次我们只是正好使用到了这个功能。以前画面是320×200的时候，我们用的是“AH=0； AL=画面模式号码；”。现在切换到新画面时就使用“AX = 0x4f02；”。

大家是不是很纳闷：“画面模式有新旧之分吗？”是的，实际上是有新旧之分的。就说显卡吧，每当有新显卡面世时，性能就会提高，反过来想，以前的显卡，声音性能差，颜色数又少，分辨率又低。刚开始的时候，电脑规格是以IBM公司为中心决定的，他们也规定了画面模式的相关规格。而且各家显卡公司也都迎合IBM的规格来制作显卡。

可是过了一段时间，其他显卡公司的图像处理技术超越了IBM，在IBM制定规格前，就出现了具有各样画面模式的显卡。这造成了多家显卡公司的竞争，使得在各家公司之间，画面模式的设定方法和使用方法都各不相同。

这样的情况，我们这些普通程序员是难以应付的。显卡的种类太多，我们记不住那么多的设定方法，而且事实上，连参考资料都很难得到。这样一来，本应是高性能的显卡，却只能像老显卡一样，通过BIOS设定为320×200来使用。

有鉴于此，多家显卡公司经过协商，成立了VESA协会（Video Electronics Standards Association，视频电子标准协会）。此后，这个协会制定了虽然不能说完全兼容、但几乎可以通用的设定方法，制作了专用的BIOS。这个追加的BIOS被称作“VESA BIOS extension”（VESA-BIOS扩展，简略为VBE）。利用它，就可以使用显卡的高分辨率功能了。

因此，切换到不使用VBE的画面模式时用“AH = 0；AL=画面模式号码；”，而切换到使用VBE的画面模式时用“AX = 0x4f02；BX = 画面模式号码；”。而这种必须使用VBE才能利用的画面模式就称作“新”画面模式。

■■■■■

VBE的画面模式号码如下。

0x101……640× 480× 8bit彩色

0x103……800× 600× 8bit彩色

0x105……1024× 768× 8bit彩色

0x107……1280× 1024× 8bit彩色

还有其他一些画面模式，因为现在不需要，我们就省略了。另外，在QEMU中不能指定最下面的0x107。实际指定的时候，要像在asmhead.nas中所做的那样，将以上的画面模式号码值加上0x4000，再赋值到BX中去。不这样做就不能顺利运行。

所以，如果想要将画面扩展得特别大的话，请尝试运行以下程序。

MOV BX,0x4105 ; VBE的1024x768x8bit彩色

MOV AX,0x4f02

INT 0x10

MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）

MOV WORD [SCRNX],1024

MOV WORD [SCRNY],768

MOV DWORD [VRAM],0xe0000000




画面会变得特别宽哦。





3　提高分辨率（2）（harib11e）

只能在模拟器上运行的操作系统实在没什么意思，还是想在真机上运行。所以，我们来把前一节的程序改写一下，让它能在真机上运行。

我们不能断定真机上使用的是什么样的显卡。有的公司尚未与VESA进行合作。如果是这种公司的产品，由于不能使用VBE，所以大家只能忍耐一下，使用320×200的画面了。

本次的asmhead.nas节选

; 确认VBE是否存在

MOV AX,0x9000

MOV ES,AX

MOV DI,0

MOV AX,0x4f00

INT 0x10

CMP AX,0x004f

JNE scrn320




在这里，我们给ES赋值为0x9000，给DI赋值为0，给AX赋值为0x4f00，再执行“INT 0x10”。如果有VBE的话，AX就会变为0x004f。要是AX没有变为这个值，很遗憾，就只能使用320×200的画面了。

至于为什么要对ES和DI进行赋值，是因为此显卡能利用的VBE信息要写入到内存中以ES:DI开始的512字节中，赋值是为了指定写入地址。

■■■■■

在“纸娃娃操作系统”中，如果VBE的版本不是2.0以上，就不能使用高分辨率。所以我们要先调查一下VBE的版本。

本次的asmhead.nas节选

; 检查VBE的版本



MOV AX,[ES:DI+4]

CMP AX,0x0200

JB scrn320 ; if (AX < 0x0200) goto scrn320




程序进行到这里，下一步要通过VBE来查看一下画面模式0x105能不能使用。即使VBE 的版本是VBE 2.0，也不能保证所有的画面模式都可以使用。真是麻烦呢。因为如果局限于画面模式0x105，那些想使用其他画面模式的人就要抱怨了。为了调查这种模式能否使用，我们首先这样设定：

VBEMODE EQU 0x105




本次的asmhead.nas节选

; 取得画面模式信息



MOV CX,VBEMODE

MOV AX,0x4f01

INT 0x10

CMP AX,0x004f

JNE scrn320




在这里我们对AX的值也进行了确认。如果它是0x004f以外的值，就意味着所指定的画面模式不能使用。

此次取得的画面模式信息也被写入内存中从ES:DI开始的256字节中。因为ES和DI都保持刚才的值不变，所以画面模式信息会覆盖VBE版本信息从而导致其消失，但是只要版本能确认，后面就不需要这个信息了，所以大家不必在意。

■■■■■

在画面模式信息中，重要的信息有如下6个。

WORD　　 [ES : DI+0x00] : 模式属性……bit7不是1就不好办(能加上0x4000)

WORD　　 [ES : DI+0x12] : X的分辨率

WORD　　 [ES : DI+0x14] : Y的分辨率

BYTE　　 [ES : DI+0x19] : 颜色数……必须为8

BYTE　　 [ES : DI+0x1b] : 颜色的指定方法……必须为4 (4是调色板模式)

DWORD　　[ES : DI+0x28] : VRAM的地址

在这6项信息当中，我们来确认如下3项：



颜色数是否为8



是否为调色板模式



画面模式号码可否加上0x4000再进行指定





本次的asmhead.nas节选

; 画面模式信息的确认

CMP BYTE [ES:DI+0x19],8

JNE scrn320

CMP BYTE [ES:DI+0x1b],4

JNE scrn320

MOV AX,[ES:DI+0x00]

AND AX,0x0080

JZ scrn320 ; 模式属性的bit7是0，所以放弃




如果这些确认都完成的话，就可以跟大家说了：“恭喜。可以使用所指定的VBE画面模式了。那就尽情享受大画面的乐趣吧！”所以我们决定进行画面模式的切换。而一旦我们完成了切换，就可以将分辨率及VRAM的地址等信息复制到BOOTINFO中了。

本次的asmhead.nas节选

; 画面模式的切换



MOV BX,VBEMODE+0x4000

MOV AX,0x4f02

INT 0x10

MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）

MOV AX,[ES:DI+0x12]

MOV [SCRNX],AX

MOV AX,[ES:DI+0x14]

MOV [SCRNY],AX

MOV EAX,[ES:DI+0x28]

MOV [VRAM],EAX

JMP keystatus




最后的JMP指令，用来让程序跳过后面的scrn320，而让其跳转至在BIOS中查询键盘状态的地方。scrn320程序我们紧接着就要写。

■■■■■

那么当出现VBE不存在，版本不够，模式有问题的情况下，我们又该怎么办呢？没办法，我们只能使用迄今为止的320×200画面。

本次的asmhead.nas节选

scrn320:

MOV AL,0x13 ; VGA图、320x200x8bit彩色

MOV AH,0x00

INT 0x10

MOV BYTE [VMODE],8 ; 记下画面模式（参考C语言）

MOV WORD [SCRNX],320

MOV WORD [SCRNY],200

MOV DWORD [VRAM],0x000a0000




好，这样就大功告成了。首先要确认在模拟器上能否正常运行。运行“make run”。OK，运转正常。

下面确认在真机上能否正常运行。“make install”一下。完成以后，按下桌面上的开关。哦，顺利运行。

如果想试一试不能顺利运行是什么样，可以设定画面模式为0x107，再在模拟器上执行就可以了。画面还是320×200哦。

■■■■■

恭喜各位实现了高分辨率，不过在广大读者之中，可能有人还在使用不支持VBE 2.0的显卡，所以今后笔者还是要使用以前的320×200画面截图。而且这样的图片，文字和鼠标指针都显得比较大，容易看。



画面很宽

这次我们对于VBE的使用方法做了多方面的介绍，其中笔者参考了下面的网页。

http://community.osdev.info/?VESA

大家有兴趣的话也看一下吧。





4　键盘输入（1）（harib11f）

对高分辨率的支持我们已经完成了，比预想的要快。所以现在我们通过从键盘输入信息来稍稍放松游戏一下吧。

再对 harib11e运行一次“make run”，然后试着按下“A”键。按下“A”键的时候，应该显示“1E”，键弹起的时候应该显示“9E”。

下面我们按下“B”键吧。按下的时候显示“30”，弹起的时候显示“B0”。再按下“C”……，这样罗列下去，可就浪费纸张了，所以我们把这些值都归纳到下表里。表里的值是按下键时的数值。在此基础上加上0x80就可以得到键弹起时的数值。

按下键时的数值表

00：没有被分配使用 20：D 40：F6 60：保留

01：ESC 21：F 41：F7 61：保留？

02：主键盘的1 22：G 42：F8 62：保留？

03：主键盘的2 23：H 43：F9 63：保留？

04：主键盘的3 24：J 44：F10 64：保留？

05：主键盘的4 25：K 45：NumLock 65：保留？

06：主键盘的5 26：L 46：ScrollLock 66：保留？

07：主键盘的6 27：; 47：数字键的7 67：保留？

08：主键盘的7 28：:（在英语键盘是' ） 48：数字键的8 68：保留？

09：主键盘的8 29：全角•半角（在英语键盘是` ） 49：数字键的9 69：保留？

0A：主键盘的9 2A：左Shift 4A：数字键的- 6A：保留？

0B：主键盘的0 2B：]（在英语键盘是backslash（反斜线）） 4B：数字键的4 6B：保留？

0C：主键盘的- 2C：Z 4C：数字键的5 6C：保留？

0D：主键盘的^（在英语键盘是=） 2D：X 4D：数字键的6 6D：保留？

0E：退格键 2E：C 4E：数字键的+ 6E：保留？

0F：TAB键 2F：V 4F：数字键的1 6F：保留？

10：Q 30：B 50：数字键的2 70：平假名（日文键盘）

11：W 31：N 51：数字键的3 71：保留？

12：E 32：M 52：数字键的0 72：保留？

13：R 33：, 53：数字键的. 73：_

14：T 34：. 54：SysReq 74：保留？

15：Y 35：/ 55：保留？ 75：保留？

16：U 36：右Shift 56：保留？ 76：保留？

17：I 37：数字键的* 57：F11 77：保留？

18：O 38：左Alt 58：F12 78：保留？

19：P 39：Space 59：保留？ 79：变换（日文键盘）

1A：@（在英语键盘是[ ） 3A：CapsLock 5A：保留？ 7A：保留？

1B：[（在英语键盘是] ） 3B：F1 5B：保留？ 7B：无变换（日文键盘）

1C：主键盘的Enter 3C：F2 5C：保留？ 7C：保留？

1D：左Ctrl 3D：F3 5D：保留？ 7D：\

1E：A 3E：F4 5E：保留？ 7E：保留？

1F：S 3F：F5 5F：保留？ 7F：保留？

这个表中有写着“保留?”的地方是指，虽然现在按下哪个键都不出现该数值，但将来键盘的键数量一旦增加，那个数值就可以被分配使用了。

大家也许会想“笔者特意把所有的键都按了一遍来调查数值吗？真认真勤快呀。”，嘿嘿，实际上笔者只是把下面网页记载的内容原搬照抄而已（笑）。

http://community.osdev.info/?(AT)keyboard

■■■■■

笔者想利用这个表实现当“A”键被按下的时候就显示“A”。嗯，以前曾经通过计数来测试性能，现在也已经腻了，所以我们来修改bootpack.c。不再是让其计数，而是让其充分HLT（休眠），以便节电。

本次的HariMain节选

for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /* 键盘数据 */

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i == 0x1e + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "A", 1);

}

} else if (512 <= i && i <= 767) { /* 鼠标数据 */

（中略）

} else if (i == 10) { /* 10秒定时器 */

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

} else if (i == 3) { /* 3秒定时器 */

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

} else if (i == 1) { /* 光标用定时器 */

（中略）

} else if (i == 0) { /* 光标用定时器 */

（中略）

}

}

}




虽然在这段程序中没有出现，但我们已经把窗口的名字由“counter”改为了“window”。“make run”，再按一下“A”键，哦，“A”显示出来了。



“A”显示出来了！





5　键盘输入（2）（harib11g）

到了这一步，我们希望也能输入“B”和“C”等字符。那么，我们来动手写程序。

首先我们创建以下程序：

if (256 <= i && i <= 511) { /* 键盘数据 */

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i == 0x1e + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "A", 1);

}

if (i == 0x30 + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "B", 1);

}

if (i == 0x2e + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "C", 1);

}

if (i == 0x20 + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "D", 1);

}

if (i == 0x12 + 256) {

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, "E", 1);

}

} else if (512 <= i && i <= 767) { /* 鼠标数据 */




如果我们像上面这样写程序，仅仅是字母（26个）和数字（10个），就得写36个if语句。这样做的话，程序可就变长了。这不太好，必须要想出一个好办法。

■■■■■

因此又创建了如下程序。怎么样?

本次的HariMain节选

static char keytable[0x54] = {

0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '^', 0, 0,

'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0, 0, 'A', 'S',

'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', ':', 0, 0, ']', 'Z', 'X', 'C', 'V',

'B', 'N', 'M', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1',

'2', '3', '0', '.'

};



if (256 <= i && i <= 511) { /* 键盘数据 */

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i < 256 + 0x54) {

if (keytable[i - 256] != 0) {

s[0] = keytable[i - 256];

s[1] = 0;

putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1);

}

}

} else if (512 <= i && i <= 767) { /* 鼠标数据 */




之所以笔者把keytable[ ]设定为static char，是因为希望程序被编译为汇编语言的时候，static char能编译成DB指令。设定调色板的时候也是如此，大家还记得吗?

现在我们来解释这个程序的运行机制。比如说keytable[0x1e]对应的是“A”。而“A”的字符代码是0x41。如果i == 0x1e + 256的话，keytable[i - 256]就是“A”，所以s[0]也就是“A”了。

同理，“B”、“C”、“Z”以及“5”等也应该可以显示了。

■■■■■

让我们确认一下吧。运行“make run”。不错，很顺利呀。



按下“G”键

运行“make run”后，按下“@”等键，却显示出“W”。大家也许会想“唉?怎么回事儿?”，这是因为当“@”被按下的时候，HariMain接收到了0x11（请确认左上方的显示内容），这不是HariMain的bug，而是QEMU的问题（我想这可能是因为日语键盘还没有得到充分支持吧）。还有其他几个键，按下以后会显示出奇怪的字符。这些好像都是QEMU的问题。

如果读者还是觉得不放心，可以在真机上确认。运行肯定会很顺利的。





6　追记内容（1）（harib11h）

我们已经进行到了这个阶段，就想稍稍放松一下了。你看，光标也能闪烁了，窗口也有了。

我们先把程序放在一边，来看一看画面的截图吧。



我们都能实现这样的功能了

当这个画面出现的时候，笔者感到一股成功的喜悦。

虽然看起来有了不小的进步，但实际上我们也只是在窗口中添加了一些画，改变了鼠标和字符的显示位置以及颜色而已。如果我们按下退格键（BackSpace键），还可以改写已输入的字符哦。大家试着输入自己喜欢的信息吧。

■■■■■

程序如下。笔者只修改了bootpack.c。

本次的HariMain节选

int cursor_x, cursor_c;



make_textbox8(sht_win, 8, 28, 144, 16, COL8_FFFFFF);

cursor_x = 8;

cursor_c = COL8_FFFFFF;



（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /* 键盘数据 */

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);



if (i < 0x54 + 256) {

if (keytable[i - 256] != 0 && cursor_x < 144) { /* 一般字符 */

/* 显示1个字符就前移1次光标 */

s[0] = keytable[i - 256];

s[1] = 0;

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1);

cursor_x += 8;

}

}

if (i == 256 + 0x0e && cursor_x > 8) { /* 退格键 */

/* 用空格键把光标消去后，后移1次光标 */

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, " ", 1);

cursor_x -= 8;

}

/* 光标再显示 */

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

} else if (512 <= i && i <= 767) { /* 鼠标数据 */

（中略）

} else if (i == 10) { /* 10秒定时器 */

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

} else if (i == 3) { /* 3秒定时器 */

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

} else if (i <= 1) { /* 光标用定时器 */

if (i != 0) {

timer_init(timer3, &fifo, 0); /* 下面设定0 */

cursor_c = COL8_000000;

} else {

timer_init(timer3, &fifo, 1); /* 下面设定1 */

cursor_c = COL8_FFFFFF;

}

timer_settime(timer3, 50);

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

}

}

}




cursor_x是用来记住光标显示位置的变量，输入一个字符后，这个变量就递增“8”。而cursor_c变量则表示现在光标的颜色。它每0.5秒变化一次。

make_textb0x8函数是用来描绘文字输入背景的，内容如下。这个函数没什么特别难的东西，大家大致读一下就可以了。

本次的bootpack.c节选

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)

{

int x1 = x0 + sx, y1 = y0 + sy;

boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);

boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);

boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);

boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);

boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);

boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);

boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);

boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);

boxfill8(sht->buf, sht->bxsize, c, x0 - 1, y0 - 1, x1 + 0, y1 + 0);

return;

}





7　追记内容（2）（harib11i）

像harib11h那样玩儿是最高兴的了。这才是“纸娃娃操作系统”的乐趣所在！那么，我们继续玩点儿别的吧。

大家还记得，为了使鼠标动起来，我们付出了多少辛苦吗？我们付出了辛苦，终于让鼠标动了起来，可鼠标动起来后，却一点儿都没用到。它只是一个装饰物（也许还碍手碍脚的?）。

好不容易让鼠标动起来了，我们看看能用它干些什么吧。做什么好呢？嗯，还是来移动窗口吧。所以下面我们就使用鼠标完成窗口移动吧。

一说到窗口的移动，感觉好像很难。但实际并不难，只要添写4行程序就可以了。

本次的HariMain节选

for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /* 键盘数据 */

（中略）

} else if (512 <= i && i <= 767) { /* 鼠标数据 * */

if (mouse_decode(&mdec, i - 512) != 0) {

/* 收集了3字节的数据，所以显示出来 */

（中略）

/* 光标移动 */

（中略）

sheet_slide(sht_mouse, mx, my);

/* 从这里开始！ */ if ((mdec.btn & 0x01) != 0) {

/* 按下左键、移动sht_win */

sheet_slide(sht_win, mx - 80, my - 8);

/* 到这里结束！ */ }

}

} else if (i == 10) { /* 10秒定时器 */

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

} else if (i == 3) { /* 3秒定时器 */

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

} else if (i <= 1) { /* 光标用定时器 */

（中略）

}

}

}




■■■■■

好了，这样就完成了。我们赶紧运行“make run”吧。启动之后，请随意在画面上某个地方点击一下，窗口很快就移动到那里了。唰唰的感觉。耶，太好了。



唰唰地移动

当我们一直按着左键来移动鼠标时，可以让窗口四处移动。但在模拟器上，移动可就慢了。运行“make install”，在真机上一确认，快多了。唰唰的感觉。

即使窗口跑到了画面外，也没有问题。因为我们已经针对鼠标指针提前采取了对策，这就如同图层跑到了画面外面也可以动起来一样。



跑到了画面外也没事哟

真棒！能简单地实现这个功能，多亏在制作图层时下的一番苦功。做得不错！先表扬一下几天前的自己吧（笑）。

唉，玩得正高兴，不知不觉就到了今天的结束时间了。明天我们就要挑战，“多任务”了。今天正好是第2周，我们看看haribote.sys的大小吧。23 908字节也就是23KB。到现在为止，仅用23KB就可以完成像操作系统那样的功能了，不错不错。好了，我们明天见吧。





第15天　多任务（1）



挑战任务切换（harib12a）

任务切换进阶（harib12b）

做个简单的多任务（1）（harib12c）

做个简单的多任务（2）（harib12d）

提高运行速度（harib12e）

测试运行速度（harib12f）

多任务进阶（harib12g）





1　挑战任务切换（harib12a）

“话说，多任务到底是啥呢？”我们今天的内容，就从这个问题开始吧。

多任务，在英语中叫做“multitask”，顾名思义就是“多个任务”的意思。简单地说，在Windows等操作系统中，多个应用程序同时运行的状态（也就是同时打开好几个窗口的状态）就叫做多任务。

对于生活在现代社会的各位来说，这种多任务简直是理所当然的事情。比如你会一边用音乐播放软件听音乐一边写邮件，邮件写到一半忽然有点东西要查，便打开Web浏览器上网搜索。这对于大家来说这些都是家常便饭了吧。可如果没有多任务的话会怎么样呢？想写邮件的时候就必须关掉正在播放的音乐，要查东西的时候就必须先保存写到一半的邮件，然后才能打开Web浏览器……光想象一下就会觉得太不方便了。

然而在从前，没有多任务反倒是普遍的情形（那个时候大家不用电脑听音乐，也没有互联网）。在那个年代，电脑一次只能运行一个程序，如果要同时运行多个程序的话，就得买好几台电脑才行。

就在那个时候，诞生了最初的多任务操作系统，大家都觉得太了不起了。从现在开始，我们也要准备给“纸娃娃系统”添加执行多任务的能力了。连这样一个小不点儿操作系统都能够实现多任务，真是让人不由地感叹它生逢其时呀。

■■■■■

稍稍思考一下我们就会发现，多任务这个东西还真是奇妙，它究竟是怎样做到让多个程序同时运行的呢？如果我们的电脑里面装了好多个CPU的话，同时运行多个程序倒也顺理成章，但实际上就算我们只有一个CPU，照样可以实现多任务。

其实说穿了，这些程序根本没有在同时运行，只不过看上去好像是在同时运行一样：程序A运行一会儿，接下来程序B运行一会儿，再接下来轮到程序C，然后再回到程序A……如此反复，有点像日本忍者的“分身术”呢（笑）。



为了让这种分身术看上去更完美，需要让操作系统尽可能快地切换任务。如果10秒才切换一次，那就连人眼都能察觉出来了，同时运行多个程序的戏码也就穿帮了。再有，如果我们给程序C发出一个按键指令，正巧这个瞬间系统切换到了程序A的话，我们就不得不等上20秒，才能重新轮到程序C对按键指令作出反应。这实在是让人抓狂啊（哭）。

在一般的操作系统中，这个切换的动作每0.01～0.03秒就会进行一次。当然，切换的速度越快，让人觉得程序是在同时运行的效果也就越好。不过，CPU进行程序切换（我们称为“任务切换”）这个动作本身就需要消耗一定的时间，这个时间大约为0.0001秒左右，不同的CPU及操作系统所需的时间也有所不同。如果CPU每0.0002秒切换一次任务的话，该CPU处理能力的50%都要被任务切换本身所消耗掉。这意味着，如果同时运行2个程序，每个程序的速度就只有单独运行时的1/4，这样你会觉得开心吗？如果变成这种结果，那还不如干脆别搞多任务呢。

相比之下，即便是每0.001秒切换一次任务，单单在任务切换上面也要消耗CPU处理能力的10%。大概有人会想，10%也没什么大不了的吧？可如果你看看速度快10%的CPU卖多少钱，说不定就会恍然大悟，“对啊，只要优化一下任务切换间隔，就相当于一分钱也不花，便换上了比现在更快的CPU嘛……”（笑），你也就明白了浪费10%也是很不值得的。正是因为这个原因，任务切换的间隔最短也得0.01秒左右，这样一来只有1%的处理能力消耗在任务切换上，基本上就可以忽略不计了。

■■■■■

关于多任务是什么的问题，已经大致讲得差不多了，接下来我们来看看如何让CPU来处理多任务。

当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。接下来，为了运行下一个程序，CPU会把所有寄存器中的值从内存中读取出来（当然，这个读取的地址和刚刚写入的地址一定是不同的，不然就相当于什么都没变嘛），这样就完成了一次切换。我们前面所说的任务切换所需要的时间，正是对内存进行写入和读取操作所消耗的时间。

■■■■■

接下来我们来看看寄存器中的内容是怎样写入内存里去的。下面这个结构叫做“任务状态段”（task status segment），简称TSS。TSS有16位和32位两个版本，这里我们使用32位版。顾名思义，TSS也是内存段的一种，需要在GDT中进行定义后使用。

struct TSS32 {

int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;

int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;

int es, cs, ss, ds, fs, gs;

int ldtr, iomap;

};




参考上面的结构定义，TSS共包含26个int成员，总计104字节（摘自CPU的技术资料），我特意把它们分成4行来写。从开头的backlink起，到cr3为止的几个成员，保存的不是寄存器的数据，而是与任务设置相关的信息，在执行任务切换的时候这些成员不会被写入（backlink除外，某些情况下是会被写入的）。后面的部分中我们会用到这里的设定，不过现在你完全可以先忽略它。

第2行的成员是32位寄存器，第3行是16位寄存器，应该没必要解释了吧……不对，eip好像到现在还没讲过呢。EIP的全称是“extended instruction pointer”，也就是“扩展指令指针寄存器”的意思。这里的“扩展”代表它是一个32位寄存器，也就是说其对应的16位版本叫做IP，类比一下的话，跟EAX与AX之间的关系是一样的。

EIP是CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器，因此它才被称为“指令指针”。如果没有这个寄存器，记性不好的CPU就会忘记自己正在运行哪里的程序，于是程序就没办法正常运行了。每执行一条指令，EIP寄存器中的值就会自动累加，从而保证一直指向下一条指令所在的内存地址。

说点题外话，JMP指令实际上是一个向EIP寄存器赋值的指令。JMP 0x1234这种写法，CPU会解释为MOV EIP,0x1234，并向EIP赋值。也就是说，这条指令其实是篡改了CPU记忆中下一条该执行的指令的地址，蒙了CPU一把。这样一来，CPU在读取下一条指令时，就会去读取0x1234这个地址中的指令。你看，这不就相当于是做了一个跳转吗？

对了，如果你在汇编语言里用MOV EIP,0x1234这种写法是会出错的，还是不要尝试的好。在汇编语言中，应该使用JMP 0x1234来代替MOV EIP,0x1234。

如果在TSS中将EIP寄存器的值记录下来，那么当下次再返回这个任务的时候，CPU就可以明白应该从哪里读取程序来运行了。

按照常识，段寄存器应该是16位的才对，可是在TSS数据结构中却定义成了int（也就是DWORD）类型。我们可以大胆想象一下，说不定英特尔公司的人将来会把段寄存器变成32位的，这样想想也挺有意思的呢（笑）。

第4行的ldtr和iomap也和第1行的成员一样，是有关任务设置的部分，因此在任务切换时不会被CPU写入。也许你会想，那就和第1行一样，暂时先忽略好了——但那可是绝对不行的！如果胡乱赋值的话，任务就无法正常切换了，在这里我们先将ldtr置为0，将iomap置为0x40000000就好了。

■■■■■

关于TSS的话题暂且先告一段落，我们回来继续讲任务切换的方法。要进行任务切换，其实还得用JMP指令。JMP指令分为两种，只改写EIP的称为near模式，同时改写EIP和CS的称为far模式，在此之前我们使用的JMP指令基本上都是near模式的。不记得CS是什么了？CS就是代码段（code segment）寄存器啦。

说起来我们其实用过一次far模式的JMP指令，就在asmhead.nas的“bootpack启动”的最后一句（见8.5节）。

JMP　　 DWORD 2*8:0x0000001b

这条指令在向EIP存入0x1b的同时，将CS置为2*8（=16）。像这样在JMP目标地址中带冒号（:）的，就是far模式的JMP指令。

如果一条JMP指令所指定的目标地址段不是可执行的代码，而是TSS的话，CPU就不会执行通常的改写EIP和CS的操作，而是将这条指令理解为任务切换。也就是说，CPU会切换到目标TSS所指定的任务，说白了，就是JMP到一个任务那里去了。

CPU每次执行带有段地址的指令时，都会去确认一下GDT中的设置，以便判断接下来要执行的JMP指令到底是普通的far-JMP，还是任务切换。也就是说，从汇编程序翻译出来的机器语言来看，普通的far-JMP和任务切换的far-JMP，指令本身是没有任何区别的。

■■■■■

好了，枯燥的讲解就到这里，让我们实际做一次任务切换吧。我们准备两个任务：任务A和任务B，尝试从A切换到B。

首先，我们需要创建两个TSS：任务A的TSS和任务B的TSS。

本次的HariMain节选

struct TSS32 tss_a, tss_b;




向它们的ldtr和iomap分别存入合适的值。

本次的HariMain节选

tss_a.ldtr = 0;

tss_a.iomap = 0x40000000;

tss_b.ldtr = 0;

tss_b.iomap = 0x40000000;




接着将它们两个在GDT中进行定义。

本次的HariMain节选

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;



set_segmdesc(gdt + 3, 103, (int) &tss_a, AR_TSS32);

set_segmdesc(gdt + 4, 103, (int) &tss_b, AR_TSS32);




将tss_a定义在gdt的3号，段长限制为103字节，tss_b也采用类似的定义。

■■■■■

现在两个TSS都创建好了，该进行实际的切换了。

我们向TR寄存器存入3 * 8这个值，这是因为我们刚才把当前运行的任务定义为GDT的3号。TR寄存器以前没有提到过，它的作用是让CPU记住当前正在运行哪一个任务。当进行任务切换的时候，TR寄存器的值也会自动变化，它的名字也就是“task register”（任务寄存器）的缩写。我们每次给TR寄存器赋值的时候，必须把GDT的编号乘以8，因为英特尔公司就是这样规定的。如果你有意见的话，可以打电话找英特尔的大叔投诉哦（笑）。

给TR寄存器赋值需要使用LTR指令，不过用C语言做不到。唉，各位是不是都已经见怪不怪了啊？啥？你早就料到了？（笑）所以说，正如你所料，我们只能把它写进naskfunc.nas里面。

本次的HariMain节选

load_tr(3 * 8);




本次的naskfunc.nas节选

_load_tr: ; void load_tr(int tr);

LTR [ESP+4] ; tr

RET




对了，LTR指令的作用只是改变TR寄存器的值，因此执行了LTR指令并不会发生任务切换。

要进行任务切换，我们必须执行far模式的跳转指令，可惜far跳转这事C语言还是无能为力，这种语言还真是不方便啊。没办法，这个函数我们也得在naskfunc.nas里创建。

本次的naskfunc.nas节选

_taskswitch4: ; void taskswitch4(void);

JMP 4*8:0

RET




也许有人会问，在JMP指令后面写个RET有意义吗？也对，通常情况下确实没意义，因为已经跳转到别的地方了嘛，后面再写什么指令也不会被执行了。不过，用作任务切换的JMP指令却不太一样，在切换任务之后，再返回这个任务的时候，程序会从这条JMP指令之后恢复运行，也就是执行JMP后面的RET，从汇编语言函数返回，继续运行C语言主程序。

另外，如果far-JMP指令是用作任务切换的话，地址段（冒号前面的4*8的部分）要指向TSS这一点比较重要，而偏移量（冒号后面的0的部分）并没有什么实际作用，会被忽略掉，一般来说像这样写0就可以了。

现在我们需要在HariMain的某个地方来调用taskswitch()，可到底该写在哪里呢？唔，有了，就放在显示“10[sec]”的语句后面好了。也就是说，程序启动10秒以后进行任务切换。

本次的HariMain节选

} else if (i == 10) { /* 10秒计时器*/

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

taskswitch4(); /*这里！ */

} else if (i == 3) { /* 3秒计时器 */




■■■■■

大功告成了？不对，我们还没准备好tss_b呢。在任务切换的时候需要读取tss_b的内容，因此我们得在TSS中定义好寄存器的初始值才行。

本次的HariMain节选

tss_b.eip = (int) &task_b_main;

tss_b.eflags = 0x00000202; /* IF = 1; */

tss_b.eax = 0;

tss_b.ecx = 0;

tss_b.edx = 0;

tss_b.ebx = 0;

tss_b.esp = task_b_esp;

tss_b.ebp = 0;

tss_b.esi = 0;

tss_b.edi = 0;

tss_b.es = 1 * 8;

tss_b.cs = 2 * 8;

tss_b.ss = 1 * 8;

tss_b.ds = 1 * 8;

tss_b.fs = 1 * 8;

tss_b.gs = 1 * 8;




乍看之下，貌似会有很多看不懂的地方吧，我们从后半段对寄存器赋值的地方开始看。这里我们给cs置为GDT的2号，其他寄存器都置为GDT的1号，asmhead.nas的时候也是一样的。也就是说，我们这次使用了和bootpack.c相同的地址段。当然，如果你用别的地址段也没问题，不过这次我们只是想随便做个任务切换的实验而已，这种麻烦的事情还是以后再说吧。

继续看剩下的部分，关于eflags的赋值，如果把STI后的EFLAGS的值通过io_load_eflags赋给变量的话，该变量的值就显示为0x00000202，因此在这里就直接使用了这个值，仅此而已。如果还有看不懂的地方，大概就是eip和esp的部分了吧。

■■■■■

在eip中，我们需要定义在切换到这个任务的时候，要从哪里开始运行。在这里我们先把task_b_main这个函数的内存地址赋值给它。

本次的bootpack.c节选

void task_b_main(void)

{

for (;;) { io_hlt(); }

}




这个函数只执行了一个HLT，没有任何实际作用，后面我们会对它进行各种改造，现在就先这样吧。

■■■■■

task_b_esp是专门为任务B所定义的栈。有人可能会说，直接用任务A的栈不就好了吗？那可不行，如果真这么做的话，栈就会混成一团，程序也无法正常运行。

本次的HariMain节选

int task_b_esp;



task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024;




总之先写成这个样子了。我们为任务B的栈分配了64KB的内存，并计算出栈底的内存地址。请各位回忆一下向栈PUSH数据（入栈）的动作，ESP中存入的应该栈末尾的地址，而不是栈开头的地址。

■■■■■

好了，我们已经讲解得够多了，现在总算是万事俱备啦，马上“make run”一下吧。这个程序如果运行正常的话应该是什么样子呢？嗯，启动之后的10秒内，还是跟以前一样的，10秒一到便执行任务切换，task_b_main开始运行。因为task_b_main只有一句HLT，所以接下来程序就全部停止了，鼠标和键盘也应该都没有反应了。

唔……这样看起来好像很无聊啊，算了，总之我们先来“make run”吧。10秒钟的等待还真是漫长……哇！停了停了！

看来我们的首次任务切换获得了圆满成功。



输入到一半就停住了哦！





2　任务切换进阶（harib12b）

刚才我们只是实现了一次性从任务A切换到任务B，现在我们要尝试再切换回任务A。好，那我们就在切换到任务B的5秒后，让它再切换回任务A吧。

这其实很容易，只要稍微改写一下task_b_main就可以了。

本次的bootpack.c节选

void task_b_main(void)

{

struct FIFO32 fifo;

struct TIMER *timer;

int i, fifobuf[128];



fifo32_init(&fifo, 128, fifobuf);

timer = timer_alloc();

timer_init(timer, &fifo, 1);

timer_settime(timer, 500);



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 1) { /*超时时间为5秒 */

taskswitch3(); /*返回任务A */

}

}

}

}




你看，这样就搞定了。在这里所使用的变量名，比如fifo、timer等，和HariMain里面是一样的，不过别担心，计算机会把它们当成不同的变量来处理。无论我们对这里的变量如何赋值，都不会影响到HariMain中的对应变量。这并不是因为它们处于不同的任务，而是因为它们名字虽然一样，但实际上根本是不同的变量（之前一直没有机会解释这一点，现在稍微晚了点，不过还是在这里讲一下吧）。

对了，taskswitch3还没有创建，我们需要创建它。

本次的naskfunc.nas节选

_taskswitch3: ; void taskswitch3(void);

JMP 3*8:0

RET




好了，准备完毕！

■■■■■

我们来“make run”一下。哇，经过10秒之后光标停止闪烁，鼠标没有反应，键盘也无法输入文字了。然而又过了5秒，光标又重新开始闪烁，刚才键盘没反应的时候打进去的字一口气全都冒了出来，鼠标也又能动了。

这就说明我们已经成功回到了任务A并继续运行了，真顺利呀。





3　做个简单的多任务（1）（harib12c）

接下来，我们要实现更快速的，而且是来回交替的任务切换。这样一来，我们就可以告别光标停住、鼠标卡死、键盘打不了字等情况，从而让两个任务看上去好像在同时运行一样。

在开始动手之前，笔者认为像taskswitch3、taskswitch4这种写法实在不好。假设我们有100个任务，难道就要创建100个任务切换函数不成？这样肯定不行，最好是写成一个函数，比如像taskswitch(3);这样。

为了解决这个问题，我们先创建这样一个函数。

本次的naskfunc.nas节选

_farjmp: ; void farjmp(int eip, int cs);

JMP FAR [ESP+4] ; eip, cs

RET




“JMP FAR”指令的功能是执行far跳转。在JMP FAR指令中，可以指定一个内存地址，CPU会从指定的内存地址中读取4个字节的数据，并将其存入EIP寄存器，再继续读取2个字节的数据，并将其存入CS寄存器。当我们调用这个函数，比如farjmp(eip,cs);，在[ESP+4]这个位置就存放了eip的值，而[ESP+8]则存放了cs的值，这样就可以实现far跳转了。

因此我们需要将调用的部分改写如下：

taskswitch3(); → farjmp(0, 3 * 8);

taskswitch4(); → farjmp(0, 4 * 8);

■■■■■

现在我们来缩短切换的间隔。在任务A和任务B中，分别准备一个timer_ts变量，以便每隔0.02秒执行一次任务切换。这个变量名中的ts就是“task switch”的缩写，代表“任务切换计时器”的意思。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



timer_ts = timer_alloc();

timer_init(timer_ts, &fifo, 2);

timer_settime(timer_ts, 2);



（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 2) {

farjmp(0, 4 * 8);

timer_settime(timer_ts, 2);

} else if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i == 10) { /* 10秒计时器*/

putfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, "10[sec]", 7);

} else if (i == 3) { /* 3秒计时器*/

putfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, "3[sec]", 6);

} else if (i <= 1) { /*光标用计时器*/

（中略）

}

}

}

}



void task_b_main(void)

{

struct FIFO32 fifo;

struct TIMER *timer_ts;

int i, fifobuf[128];



fifo32_init(&fifo, 128, fifobuf);

timer_ts = timer_alloc();

timer_init(timer_ts, &fifo, 1);

timer_settime(timer_ts, 2);



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

io_stihlt();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 1) { /*任务切换*/

farjmp(0, 3 * 8);

timer_settime(timer_ts, 2);

}

}

}

}




上面的代码应该没有什么难点，不过还是稍微解释一下吧。在每个任务中，当从farjmp返回的时候，我们都将计时器重新设定到0.02秒之后，以便让程序在返回0.02秒之后，再次执行任务切换。

■■■■■

好了，这样做是不是能像我们所设想的那样，让键盘和鼠标持续响应呢？我们来“make run”……不错，键盘打字、鼠标操作、光标闪烁，全都运行正常，完全没有卡住。我们成功了。

不过，我们真的成功了吗？感觉不是很靠谱啊，task_b_main到底有没有运行啊？嗯，下面我们想办法来确认一下。





4　做个简单的多任务（2）（harib12d）

为了确认task_b_main到底有没有运行，我们需要让task_b_main显示点什么东西出来，最好是显示点会动的东西，要不还是让它数数吧……喂喂，是谁在下面叫“又来了啊”？（笑）

本次的bootpack.c节选

void task_b_main(void)

{

struct FIFO32 fifo;

struct TIMER *timer_ts;

int i, fifobuf[128], count = 0;

char s[11];

struct SHEET *sht_back;



（中略）



for (;;) {

count++;

sprintf(s, "%10d", count);

putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 10);

io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

（中略）

}

}

}




写到这里，我们遇到了一个问题，那就是sht_back。HariMain知道这个变量的值，但task_b_main可不知道。怎么办呢？怎样才能把这个变量的值从任务A传递给任务B呢？随便找一个内存地址存进去，然后再从那里读出来，这样应该可以吧。好，就用0x0fec这个地址，这个地址是BOOTINFO-4。

本次的HariMain节选

*((int *) 0x0fec) = (int) sht_back;




本次的task_b_main节选

sht_back = (struct SHEET *) *((int *) 0x0fec);




这里用了很多强制数据类型转换操作，代码比较难读，不过就先这样吧。

■■■■■

现在让我们来运行一下。不知道结果如何，心里好紧张啊。“make run”，哇，动了动了！task_b_main和HariMain在同时运行！当然，实际上只是因为切换速度很快，所以造成了在同时运行的假象。无论如何，我们的多任务取得了圆满成功！



多任务成功

（其实我们在harib12c的时候就已经成功实现了多任务，只不过当时还没有加入显示功能，所以无法实际感受到而已。）





5　提高运行速度（harib12e）

刚开始看到harib12d的成果还觉得挺感动的，过段时间头脑冷静下来以后再看的话，发现task_b_main数数的速度即便在真机环境下运行还是非常慢，我们得想办法提高它的运行速度。Harib10i在7秒钟的时间内可以数到0099969264，相比之下，harib12d也太慢了。任务A和任务B交替运行的情况下，性能下降到原来的一半还可以理解，如果比这个还慢的话就让人无法忍受了。

那运行速度为什么会这么慢呢？因为我们的程序每计1个数就在画面上显示一次，但1秒钟之内刷新100次以上的话，人眼根本就分辨不出来，所以我们不需要计1个数就刷新一次，只要每隔0.01秒刷新一次就足够了。

本次的bootpack.c节选

void task_b_main(struct SHEET *sht_back)

{

struct FIFO32 fifo;

struct TIMER *timer_ts, *timer_put;

int i, fifobuf[128], count = 0;

char s[12];



fifo32_init(&fifo, 128, fifobuf);

timer_ts = timer_alloc();

timer_init(timer_ts, &fifo, 2);

timer_settime(timer_ts, 2);

timer_put = timer_alloc();

timer_init(timer_put, &fifo, 1);

timer_settime(timer_put, 1);



for (;;) {

count++;

io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 1) {

sprintf(s, "%11d", count);

putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11);

timer_settime(timer_put, 1);

} else if (i == 2) {

farjmp(0, 3 * 8);

timer_settime(timer_ts, 2);

}

}

}

}




基本上就是这个样子。对了，代码开头的sht_back我们改为作为函数的参数来传递了，关于这一点我们以后会讲到，大家不必担心。

另外，上面的代码还把任务切换计时器超时的时候向FIFO写入的值改为了2。其实不改也没什么问题，只不过因为这个计时器定了0.02秒这个数，所以就顺手改成2了。

还有，count数值的显示格式改成了11位数字，因为运行速度变快了的话，说不定数字位数会不够用呢（笑）。

■■■■■

关于将sht_back的值从HariMain传递过来的方法，*((int *) 0x0fec)这样的写法感觉实在是不好看，于是果断废弃了，我们用栈来替代它。

举个例子，load_tr(123);这样的函数调用，如果从汇编语言的角度来考虑的话，参数指定的数值（123）就放在内存中，地址为ESP+4，这是C语言的一个既定机制。

既然有这种机制，那么我们可以反过来利用一下，也就是说，在HariMain里面这样写：

本次的HariMain节选

task_b_esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8;



*((int *) (task_b_esp + 4)) = (int) sht_back;




这样一来，在任务B启动的时候，[ESP+4]这个地址里面就已经存入了sht_back的值，因此我们就欺骗了task_b_main，让它以为自己所接收到的sht_back是作为一个参数传递过来的。

可能有人不明白为什么我们要把task_b_esp的地址减8，减4不就可以了吗？我们当然不能减4，只要仔细思考一下就能搞清楚这里的奥妙。

假设memman_alloc_4k分配出来的内存地址为0x01234000，由于我们申请分配了64KB的内存空间，那么我们可以自由使用的内存地址就是从0x01234000到0x01243fff为止的这一块。如果在这里我们既不减4也不减8，而是直接加上64 * 1024的话，task_b_esp即为0x01244000。如果我们减去4，task_b_esp即为0x01243ffc，但我们写入sht_back的地址是task_b_esp + 4，算下来就变成了0x01244000，如果把4字节的sht_back值写入这个地址的话，就超出了分配给我们的内存范围（0x01234000～0x01243fff），这样不行。

而如果我们减去8，task_b_esp即为0x01243ff8，写入sht_back的地址是task_b_esp + 4，即0x01243ffc，从这个地址向后写入4字节的sht_back值，则正好在分配出来的内存范围（0x01234000～0x01243fff）内完成操作，这样就不会出问题了。

■■■■■

好，我们来运行一下，看看是不是变快了？还有，task_b_main有没有被我们欺骗而顺利接收到sht_back的值呢？如果这一招不成功的话，sht_back的值就会出现异常，画面上也就应该显示不出数字了。“make run”，哇，成功了，而且速度飞快（请注意，右图显示的是程序还没有运行到10秒的状态，这时就已经数到这么大的数字了！）。



即便是模拟器环境下运行速度也已经相当快了

COLUMN-9　千万不能return？

在这一节中，task_b_main已经变得像一个普通函数一样了，但是在这个函数中千万不能使用return。

return的功能，说到底其实是返回函数被调用位置的一个JMP指令，但这个task_b_main并不是由某段程序直接调用的，因此不能使用return。如果强行return的话，就会像“执行数据”一样发生问题，程序无法正常运行。

HariMain的情况也是一样的，也禁止使用return。

我们在15.1节中讲过，为了记住现在正在执行的指令所在的内存地址，需要使用EIP寄存器，那么return的时候要返回的地址又记录在哪里呢？对于记性不好的CPU来说，肯定会把这个地址保存在某个地方，没错，它就保存在栈中，地址是[ESP]。

因此，我们不仅可以利用[ESP+4]，还可以利用[ESP]来欺骗CPU，其实只要向[ESP]写入一个合适的值，告诉CPU应该返回到哪个地址，task_b_main中就可以使用return了。





6　测试运行速度（harib12f）

我们的程序运行得很快，可是到底有多快呢？我们得想个办法测一下。可能有人会说，别搞这种节外生枝的玩意儿了，赶快继续往下讲吧！嗯，要说也是，这的确是有点不务正业了，不过该玩的时候也要玩一玩嘛！

我们向task_b_main添加了一些代码。

本次的bootpack.c节选

void task_b_main(struct SHEET *sht_back)

{

struct FIFO32 fifo;

struct TIMER *timer_ts, *timer_put, *timer_1s;

int i, fifobuf[128], count = 0, count0 = 0;

char s[12];



（中略）

timer_1s = timer_alloc();

timer_init(timer_1s, &fifo, 100);

timer_settime(timer_1s, 100);



for (;;) {



count++;

io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 1) {

（中略）

} else if (i == 2) {

（中略）

} else if (i == 100) {

sprintf(s, "%11d", count - count0);

putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11);

count0 = count;

timer_settime(timer_1s, 100);

}

}

}

}




■■■■■

我们来运行一下，先得看看它是不是能正常工作，“make run”。不错，在模拟器环境下运行成功。



上面的数字显示的是速度哦

■■■■■

现在我们到真机环境运行一下。哇，好快！果然真机环境就是快，速度已经达到大约46382001了。

1 最后两位数字的值经常变动，因此用00代替。

我们把这个速度和harib10i做个对比。harib10i在7秒内计数到0099969264，即速度为每秒14281323，相比之下性能是现在的3倍。咦，怎么会这样？如果是2倍的话还可以理解，3倍就有点过分了。

看到这个结果心里当然会很不爽，我们来找找原因。嗯，每隔0.01秒刷新显示是不是不太好呢？如果显示计数是导致速度慢的原因，那干脆就别显示了吧。我们把开头的timer_settime （timer_put, 1）;一句删掉，这样一来由于计时器没有被设定，就不会引起超时中断，也就不会触发显示了。



现在仅显示速度值了

那么在真机环境下运行情况如何呢？哇，速度真的快了不少，现在的成绩是6774100，和14281323相比，性能差距为2.1倍，这样已经很令人满意了。大概JMP的地址也会影响计数的速度，另外，如果把速度显示改成每隔5秒刷新一次，任务切换间隔再改成0.03秒的话，估计性能差距可以更加接近理想的2.0倍，不过现在这个阶段我们就不去一一尝试了。





7　多任务进阶（harib12g）

到现在为止，我们所做的多任务都是依靠在HariMain和task_b_main中写入负责任务切换的代码来实现的。有人会说，这种多任务方式“不是真正的多任务”（即便如此，应该也不至于被说成是“假的”多任务）。

那么真正的多任务又是什么样的呢？真正的多任务，是要做到在程序本身不知道的情况下进行任务切换。既然如此，我们就来为“纸娃娃系统”添加真正的多任务吧。

首先我们来创建这样一个函数。

本次的mtask.c节选

struct TIMER *mt_timer;

int mt_tr;



void mt_init(void)

{



mt_timer = timer_alloc();

/*这里没有必要使用timer_init */

timer_settime(mt_timer, 2);

mt_tr = 3 * 8;

return;

}



void mt_taskswitch(void)

{

if (mt_tr == 3 * 8) {

mt_tr = 4 * 8;

} else {

mt_tr = 3 * 8;

}

timer_settime(mt_timer, 2);

farjmp(0, mt_tr);

return;

}




mt_init函数的功能是初始化mt_timer和mt_tr的值，并将计时器设置为0.02秒之后，仅此而已。在这里，变量mt_tr实际上代表了TR寄存器，而不需要使用timer_init是因为在发生超时的时候不需要向FIFO缓冲区写入数据。具体内容请继续往下看。

接下来，mt_taskswitch函数的功能是按照当前的mt_tr变量的值计算出下一个mt_tr的值，将计时器重新设置为0.02秒之后，并进行任务切换，很简单吧。

■■■■■

下面我们来改造一下timer.c的inthandler20。

本次的timer.c节选

void inthandler20(int *esp)

{

char ts = 0;

（中略）

for (;;) {

/* timers的计时器全部在工作中，因此不用确认flags */

if (timer->timeout > timerctl.count) {

break;

}

/*超时*/

timer->flags = TIMER_FLAGS_ALLOC;

if (timer != mt_timer) {

fifo32_put(timer->fifo, timer->data);

} else {

ts = 1; /* mt_timer超时*/

}

timer = timer->next; /*将下一个计时器的地址赋给timer */

}

timerctl.t0 = timer;

timerctl.next = timer->timeout;

if (ts != 0) {

mt_taskswitch();

}

return;

}




在这里，如果产生超时的计时器是mt_timer的话，不向FIFO写入数据，而是将ts置为1。最后判断如果ts的值不为0，就调用mt_taskswitch进行任务切换。

看了上面这段代码，你可能会问，为什么要用ts这个变量呢？在/* 超时 */的地方直接调用mt_taskswitch不就好了吗？也就是下面这样：

出问题的例子

void inthandler20(int *esp)

{

（中略）

for (;;) {

/* timers的计时器全部在工作中，因此不用确认flags */

if (timer->timeout > timerctl.count) {

break;

}

/*超时*/

timer->flags = TIMER_FLAGS_ALLOC;

if (timer != mt_timer) {

fifo32_put(timer->fifo, timer->data);

} else {

mt_taskswitch();

}

timer = timer->next; /*将下一个计时器的地址赋给timer */

}

timerctl.t0 = timer;

timerctl.next = timer->timeout;

return;

}




为什么不这样写呢？这样写的确可以让代码更简短，但是会出问题。

出问题的原因在于，调用mt_taskswitch进行任务切换的时候，即便中断处理还没完成，IF（中断允许标志）的值也可能会被重设回1（因为任务切换的时候会同时切换EFLAGS）。这样可不行，在中断处理还没完成的时候，可能会产生下一个中断请求，这会导致程序出错。

因此我们需要采用这样的设计——等中断处理全部完成之后，再在必要时调用mt_taskswitch。

■■■■■

接下来我们只需要将HariMain和task_b_main里面有关任务切换的代码删掉即可。删代码没什么难度，而且HariMain又很长，为了节约纸张我们就省略了，只把task_b_main写在下面吧。

本次的bootpack.c节选

void task_b_main(struct SHEET *sht_back)

{

struct FIFO32 fifo;

struct TIMER *timer_put, *timer_1s;

int i, fifobuf[128], count = 0, count0 = 0;

char s[12];



fifo32_init(&fifo, 128, fifobuf);

timer_put = timer_alloc();

timer_init(timer_put, &fifo, 1);

timer_settime(timer_put, 1);

timer_1s = timer_alloc();

timer_init(timer_1s, &fifo, 100);

timer_settime(timer_1s, 100);



for (;;) {

count++;

io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 1) {

sprintf(s, "%11d", count);

putfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11);

timer_settime(timer_put, 1);

} else if (i == 100) {

sprintf(s, "%11d", count - count0);

putfonts8_asc_sht(sht_back, 0, 128, COL8_FFFFFF, COL8_008484, s, 11);

count0 = count;

timer_settime(timer_1s, 100);

}

}

}

}




像这样，把有关任务切换的部分全部删掉就可以了。

■■■■■

好，我们来试试看能不能正常工作吧。“make run”，成功了，真开心！不过看上去和之前没什么区别。

和上一节相比，为什么现在的设计可以称为“真正的多任务”呢？因为如果使用这样的设计，即便在程序中不进行任务切换的处理（比如忘记写了，或者因为bug没能正常切换之类的），也一定会正常完成切换。之前那种多任务的话，如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。



真正的多任务也成功了！

真正的多任务不会发生这样的问题，因此这种方式更好……话虽如此，但其实即便是harib12g，在任务B发生bug的情况下，也有可能出现键盘输入失去响应的问题。例如，明明写了io_cli();却忘记写io_sti();的话，中断就会一直处于禁止状态，即使产生了计时器中断请求，也不会被传递给中断处理程序。这样一来，mt_taskswitch当然也就不会被调用，这意味着任务切换也就不会被执行。

其实CPU已经为大家准备了解决这个问题的方法，因此我们稍后再考虑这个问题吧。

好，我们在真机环境下运行一下，看看速度会不会变慢。咦？速度非但没有变慢，反而变快了？运行结果是6493300，和之前的14281323相比，性能的差距是2.2倍。harib12f的时候还是差3倍来着，这次也太快了吧。我们再把timer_settime(timer_put,1);删掉，看看如果不显示计数只显示速度会怎样？说不定速度会变得更快呢？哇！结果出来了，6890930，居然达到了2.07倍，离理想值2.0倍又近了一步呢。

现在想想看，为什么速度反而会变快呢？我想这是因为在任务切换的时候，我们不再使用FIFO缓冲区的缘故。之前我们向FIFO中写入超时的编号，然后从中读取这个编号来判断是否执行任务切换，相比之下，现在的做法貌似对于CPU来说负担更小些，一定是这个原因吧。

哎呀，不知不觉就已经很晚了。今天就先到这里吧，我们明天继续。





第16天　多任务（2）



任务管理自动化（harib13a）

让任务休眠（harib13b）

增加窗口数量（harib13c）

设定任务优先级（1）（harib13d）

设定任务优先级（2）（harib13e）





1　任务管理自动化（harib13a）

大家好！昨天我们已经实践了很多关于多任务的内容，不过今天我们还得继续讲多任务。可能有人会说，“老是讲多任务都听腻了啊！”，但多任务真的非常重要（当然，如果你不想做一个多任务的操作系统，那就不重要啦）。从笔者的角度来说，希望大家能够在充分做好多任务机制的基础上，再利用多任务逐步完善操作系统本身。因此，大家再稍微忍耐一下吧。

在15.7节中，我们已经实现了真正的多任务，不过这样还不够完善，或者说不太好用。如果我们想要运行三个任务的话，就必须改写mt_taskswitch的代码。笔者认为，这样的设计实在太逊了，如果能像当初定时器和窗口背景的做法一样（具体如下），是不是觉得更好呢？

task = task\_alloc();

task->tss.eip = ○×;

task->tss.esp = △◇;

像上面这样设定各种寄存器的初始值

task\_run(task);

我们就先以此为目标，对代码进行改造吧。

■■■■■

于是我们写了下面这样一段程序，struct TASKCTL是仿照struct SHTCTL写出来的，首先我们来看结构定义。

本次的bootpack.h节选

#define MAX_TASKS 1000 /*最大任务数量*/

#define TASK_GDT0 3 /*定义从GDT的几号开始分配给TSS */



struct TSS32 {

int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;

int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;

int es, cs, ss, ds, fs, gs;

int ldtr, iomap;

};



struct TASK {

int sel, flags; /* sel用来存放GDT的编号*/

struct TSS32 tss;

};



struct TASKCTL {

int running; /*正在运行的任务数量*/

int now; /*这个变量用来记录当前正在运行的是哪个任务*/

struct TASK *tasks[MAX_TASKS];

struct TASK tasks0[MAX_TASKS];

};




■■■■■

下面我们来创建用来对struct TASKCTL及其当中包含的struct TASK进行初始化的函数task_init。由于struct TASKCTL是一个很庞大的结构，因此我们让它从memman_alloc来申请内存空间。这个函数是用来替代mt_init使用的。

我们使用sel这个变量来存放GDT编号，sel是“selector”的缩写，意为选择符。因为英特尔的大叔管段地址叫做selector，所以笔者只是照猫画虎而已，也就是代表“应该从GDT里面选择哪个编号”的意思。

本次的mtask.c节选

struct TASKCTL *taskctl;

struct TIMER *task_timer;



struct TASK *task_init(struct MEMMAN *memman)

{

int i;

struct TASK *task;

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;

taskctl = (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL));

for (i = 0; i < MAX_TASKS; i++) {



taskctl->tasks0[i].flags = 0;

taskctl->tasks0[i].sel = (TASK_GDT0 + i) * 8;

set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl->tasks0[i].tss, AR_TSS32);

}

task = task_alloc();

task->flags = 2; /*活动中标志*/

taskctl->running = 1;

taskctl->now = 0;

taskctl->tasks[0] = task;

load_tr(task->sel);

task_timer = timer_alloc();

timer_settime(task_timer, 2);

return task;

}




调用task_init，会返回一个内存地址，意思是“现在正在运行的这个程序，已经变成一个任务了”。可能大家不是很能理解这个说法，在调用init之后，所有程序的运行都会被当成任务来进行管理，而调用init的这个程序，我们也要让它所属于某个任务，这样一来，通过调用任务的设置函数，就可以对任务进行各种控制，比如说修改优先级等。

■■■■■

下面我们来创建用来初始化一个任务结构的函数。

本次的mtask.c节选

struct TASK *task_alloc(void)

{

int i;

struct TASK *task;

for (i = 0; i < MAX_TASKS; i++) {

if (taskctl->tasks0[i].flags == 0) {

task = &taskctl->tasks0[i];

task->flags = 1; /*正在使用的标志*/

task->tss.eflags = 0x00000202; /* IF = 1; */

task->tss.eax = 0; /*这里先置为0*/

task->tss.ecx = 0;

task->tss.edx = 0;

task->tss.ebx = 0;

task->tss.ebp = 0;

task->tss.esi = 0;

task->tss.edi = 0;

task->tss.es = 0;

task->tss.ds = 0;

task->tss.fs = 0;

task->tss.gs = 0;

task->tss.ldtr = 0;

task->tss.iomap = 0x40000000;

return task;

}

}

return 0; /*全部正在使用*/

}




关于寄存器的初始值，这里先随便设置了一下。如果不喜欢这个值，可以在bootpack.c里面设置一下。

■■■■■

接下来是task_run，这个函数非常短，看看这样写如何。

本次的mtask.c节选

void task_run(struct TASK *task)

{

task->flags = 2; /*活动中标志*/

taskctl->tasks[taskctl->running] = task;

taskctl->running++;

return;

}




这个函数的作用是，将task添加到tasks的末尾，然后使running加1，仅此而已。

■■■■■

最后是task_switch，这个函数用来代替mt_taskswitch。

在timer.c中对mt_taskswitch的调用，也相应地修改为调用task_switch。

本次的mtask.c节选

void task_switch(void)

{

timer_settime(task_timer, 2);

if (taskctl->running >= 2) {

taskctl->now++;

if (taskctl->now == taskctl->running) {

taskctl->now = 0;

}

farjmp(0, taskctl->tasks[taskctl->now]->sel);

}

return;

}




当running为1时，不需要进行任务切换，函数直接结束。当running大于等于2时，先把now加1，然后把now所代表的任务切换成当前任务，最后再将末尾的任务移动到开头。

■■■■■

现在我们用以上这些结构和函数，将bootpack.c改写一下。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct TASK *task_b;



（中略）



task_init(memman);

task_b = task_alloc();

task_b->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8;

task_b->tss.eip = (int) &task_b_main;

task_b->tss.es = 1 * 8;

task_b->tss.cs = 2 * 8;

task_b->tss.ss = 1 * 8;

task_b->tss.ds = 1 * 8;

task_b->tss.fs = 1 * 8;

task_b->tss.gs = 1 * 8;

*((int *) (task_b->tss.esp + 4)) = (int) sht_back;

task_run(task_b);



（中略）

}




行数变少了，不过相应地mtask.c却变长了，好像也不能说是非常好。不过好在，在HariMain中，就再也不用管GDT到底怎样、任务B的tss要分配到GDT的几号等。这些麻烦的事情，全部交给mtask.c来处理了。

当需要增加任务数量的时候，不用再像之前那样修改task_switch了，只要先task_alloc，然后再task_run就行了。

好了，我们来运行一下，“make run”。不错，貌似成功了。





2　让任务休眠（harib13b）

直到harib13a为止，我们所实现的多任务，是为两个任务分配大约相同的运行时间。这也不能说是不好，不过相比之下，任务A明显空闲的时间比较多。没有键盘输入、没有鼠标操作也不会经常出现定时器中断这样的情况，这个时候任务A没什么事做，就只好HLT了。

HLT的时候能省电，也不错嘛！不过当任务B全力以赴拼命干活的时候，任务A却在无所事事，这样好像不太好。笔者觉得，与其让任务A闲着没事干，还不如把这些时间分给繁忙的任务B呢。

那么怎样才能避免任务A浪费时间呢？如果我们不让任务A去HLT，而是把它从taskctl—>tasks[]中删掉的话，嗯，这应该是一个不错的主意。如果把任务A从tasks中删掉，只保留任务B，那任务B就可以全力以赴工作了。像这样将一个任务从tasks中删除的操作，用多任务中的术语来说叫做“休眠”（sleep）。

不过这样也有一个问题，当任务A休眠时，即便FIFO有数据过来，也无法响应了，这可不行，当FIFO有数据过来的时候，必须要把任务A唤醒。怎么唤醒呢？其实只要再运行一次task_run就可以了（笑）。

■■■■■

首先我们创建task_sleep。

本次的mtask.c节选

void task_sleep(struct TASK *task)

{

int i;

char ts = 0;

if (task->flags == 2) { /*如果指定任务处于唤醒状态*/

if (task == taskctl->tasks[taskctl->now]) {

ts = 1; /*让自己休眠的话，稍后需要进行任务切换*/

}

/*寻找task所在的位置*/

for (i = 0; i < taskctl->running; i++) {

if (taskctl->tasks[i] == task) {

/*在这里*/

break;

}

}

taskctl->running--;

if (i < taskctl->now) {

taskctl->now--; /*需要移动成员，要相应地处理*/

}

/*移动成员*/

for (; i < taskctl->running; i++) {

taskctl->tasks[i] = taskctl->tasks[i + 1];

}

task->flags = 1; /*不工作的状态*/

if (ts != 0) {

/*任务切换*/

if (taskctl->now >= taskctl->running) {

/*如果now的值出现异常，则进行修正*/

taskctl->now = 0;

}

farjmp(0, taskctl->tasks[taskctl->now]->sel);

}

}

return;

}




这次的程序比较长，所以多加了一些注释。类似任务A强行让任务B休眠这样“一个任务让另一个任务休眠”的情形还是很简单的，只要在tasks中搜索该任务，找到后用后面的成员填充过来即可。

问题是类似任务A让任务A休眠这样“自己让自己休眠”的情形，因为是要让当前正在运行的任务休眠，因此在处理结束之后必须马上切换到下一个任务。只要注意以上两点，task_sleep的代码还是不难理解的。

■■■■■

接下来是当FIFO中写入数据的时候将任务唤醒的功能。首先，我们要在FIFO的结构定义中，添加用于记录要唤醒任务的信息的成员。

本次的bootpack.h节选

struct FIFO32 {

int *buf;

int p, q, size, free, flags;

struct TASK *task;

};




然后我们改写fifo32_init，让它可以在参数中指定一个任务。如果不想使用任务自动唤醒功能的话，只要将task置为0即可。

本次的fifo.c节选

void fifo32_init(struct FIFO32 *fifo, int size, int *buf, struct TASK *task)

/* FIFO缓冲区初始化*/

{

fifo->size = size;

fifo->buf = buf;

fifo->free = size; /*剩余空间*/

fifo->flags = 0;

fifo->p = 0; /*写入位置*/

fifo->q = 0; /*读取位置*/

fifo->task = task; /*有数据写入时需要唤醒的任务*/ /*这里！ */

return;

}




接着，我们来实现当向FIFO写入数据时，唤醒某个任务的功能。

int fifo32_put(struct FIFO32 *fifo, int data)

/*向FIFO写入数据并累积起来*/

{

if (fifo->free == 0) {

/*没有剩余空间则溢出*/

fifo->flags |= FLAGS_OVERRUN;

return -1;

}

fifo->buf[fifo->p] = data;

fifo->p++;

if (fifo->p == fifo->size) {

fifo->p = 0;

}

fifo->free--;

if (fifo->task != 0) { /*从这里开始*/

if (fifo->task->flags != 2) { /*如果任务处于休眠状态*/

task_run(fifo->task); /*将任务唤醒*/

}

} /*到这里结束*/

return 0;

}




我们追加了5行代码。在这里如果任务已经处于唤醒状态的话，再次对其task_run是不行的（会造成任务重复注册），因此我们需要先确认该任务是否处于休眠状态，然后再将其唤醒。

■■■■■

最后我们来改写HariMain。

本次的bootpack.c节选

void HariMain(void)

{

struct TASK *task_a, *task_b;

（中略）

fifo32_init(&fifo, 128, fifobuf, 0);

（中略）

task_a = task_init(memman);

fifo.task = task_a;

（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

（中略）

}

}

}



void task_b_main(struct SHEET *sht_back)

{

（中略）

fifo32_init(&fifo, 128, fifobuf, 0);

（中略）

}




最开始的fifo32_init中指定任务的参数，我们用0代替了。因为我们在任务A中应用了休眠，也就需要使用让FIFO来唤醒的功能，不过在这个时间点上多任务的初始化还没有完成，因此无法指定任务，只能先在这里用0代替，也就是禁用自动唤醒功能。

随后，在task_init中会返回自己的构造地址，我们将这个地址存入fifo.task。

这样一来，当FIFO为空的时候，任务A将执行task_sleep来替代之前的HLT。关于io_sti和task_sleep的顺序，需要稍微动点脑筋。如果先STI的话，在进行休眠处理的时候可能会发生中断请求，FIFO里面就会写入数据，这样有可能会发生无法成功唤醒等异常情况。因此，我们需要在禁止中断请求的状态下进行休眠处理，然后在唤醒之后马上执行STI。

task_b_main不需要让FIFO唤醒，因此任务参数指定为0。

■■■■■

那么，这样做是否能成功呢，我们来试试看。“make run”，哇，速度很快。请注意看速度显示的数字。



速度变快了？

在真机环境下进行测试，在不操作鼠标和键盘的情况下，速度可以达到13438300，harib12g的成绩是6493300，相比之下速度达到了2倍以上。

大家可能会觉得速度超过2倍这一点有点无法理解，其实这是正常的，因为两者都是以每0.01秒刷新一次count的显示。



假定harib12g的任务B的处理能力为每秒100。



其中的10用于显示count，剩下的90用于计算count++;。



假定harib13b的任务B的处理能力为每秒198。（之所以无法达到200，是因为休眠的任务A并不是完全不需要消耗处理能力）



用于显示count的还是其中的10，剩下的188用于计算count++;。



188是90的2倍以上。





……基本上就是这样的原理。

如果用鼠标不停移动窗口，再加上用键盘不断打字的话，由于任务A会变得比较忙碌，任务B的速度就会相应下降，大约会降到8700000左右。如果我们能让任务A更忙碌一些的话，最终任务B的速度会下降到6493300，也就是任务A完全不休眠时的值。

■■■■■

和harib10i时的成绩14281323相比，这次的13438300还有6%左右的差距，这应该是每0.01秒刷新一次显示导致的，因此我们把这个去掉之后再来测试一下速度。做法和之前有所不同，采用的是将task_b_main中的两处timer_settime（timer_put, 1）;改成timer_settime（timer_put. 100）;的方法。测试结果为13782000，差距缩小到3%左右了，可以说和没有多任务的状态非常接近了。

其实一开始笔者也是按照之前的方法，把timer_settime（timer_put, 1）;删掉来测试速度的，但测出来的结果居然令人震惊地高达36343300，这相当于14281323的2.5倍。速度比没有多任务的时候还快，这个结果是十分异常的，这是由于JMP指令的跳转目标地址发生变化所致。

因此，为了不让跳转目标地址发生变化，我们只好保留那条语句。本来想把timer_put的中断间隔设置为1000或者10000左右的，不过这样一来指令的长度会发生变化，所以只好设置成100了。

从这个问题来看，用C语言测试速度还是有局限性的。如果要精确比较速度的话，只能在仔细考虑地址问题的前提下，用汇编语言来编写程序来实现了。





3　增加窗口数量（harib13c）

在16.1节中我们已经对任务的新增做了简化，因此接下来我们要为系统增加更多的任务，即形成任务A、任务B0、任务B1和任务B2的格局。

任务B0～B2各自拥有自己的窗口，它们的功能都一样，即进行计数，这有点像在Windows中启动了一个应用程序及其2个副本的感觉。对了，任务A的3秒定时和10秒定时我们已经不需要了，因此将它们删去。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

unsigned char *buf_back, buf_mouse[256], *buf_win, *buf_win_b;

struct SHEET *sht_back, *sht_mouse, *sht_win, *sht_win_b[3];

struct TASK *task_a, *task_b[3];

struct TIMER *timer;



（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);

task_a = task_init(memman);

fifo.task = task_a;



/* sht_back */

sht_back = sheet_alloc(shtctl);

buf_back = (unsigned char *) memman_alloc_4k(memman, binfo->scrnx * binfo->scrny);

sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1); /*无透明色 */

init_screen8(buf_back, binfo->scrnx, binfo->scrny);



/* sht_win_b */

for (i = 0; i < 3; i++) {



sht_win_b[i] = sheet_alloc(shtctl);

buf_win_b = (unsigned char *) memman_alloc_4k(memman, 144 * 52);

sheet_setbuf(sht_win_b[i], buf_win_b, 144, 52, -1); /*无透明色*/

sprintf(s, "task_b%d", i);

make_window8(buf_win_b, 144, 52, s, 0);

task_b[i] = task_alloc();

task_b[i]->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8;

task_b[i]->tss.eip = (int) &task_b_main;

task_b[i]->tss.es = 1 * 8;

task_b[i]->tss.cs = 2 * 8;

task_b[i]->tss.ss = 1 * 8;

task_b[i]->tss.ds = 1 * 8;

task_b[i]->tss.fs = 1 * 8;

task_b[i]->tss.gs = 1 * 8;

*((int *) (task_b[i]->tss.esp + 4)) = (int) sht_win_b[i];

task_run(task_b[i]);

}



/* sht_win */

sht_win = sheet_alloc(shtctl);

buf_win = (unsigned char *) memman_alloc_4k(memman, 160 * 52);

sheet_setbuf(sht_win, buf_win, 144, 52, -1); /*无透明色*/

make_window8(buf_win, 144, 52, "task_a", 1);

make_textbox8(sht_win, 8, 28, 128, 16, COL8_FFFFFF);

cursor_x = 8;

cursor_c = COL8_FFFFFF;

timer = timer_alloc();

timer_init(timer, &fifo, 1);

timer_settime(timer, 50);



/* sht_mouse */

sht_mouse = sheet_alloc(shtctl);

sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);

init_mouse_cursor8(buf_mouse, 99);

mx = (binfo->scrnx - 16) / 2; /*计算坐标使其位于画面中央*/

my = (binfo->scrny - 28 - 16) / 2;



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_win_b[0], 168, 56);

sheet_slide(sht_win_b[1], 8, 116);

sheet_slide(sht_win_b[2], 168, 116);

sheet_slide(sht_win, 8, 56);

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_win_b[0], 1);

sheet_updown(sht_win_b[1], 2);

sheet_updown(sht_win_b[2], 3);

sheet_updown(sht_win, 4);

sheet_updown(sht_mouse, 5);

sprintf(s, "(%3d, %3d)", mx, my);

putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10);

sprintf(s, "memory %dMB free : %dKB",

memtotal / (1024 * 1024), memman_total(memman) / 1024);

putfonts8_asc_sht(sht_back, 0, 32, COL8_FFFFFF, COL8_008484, s, 40);



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）



} else if (512 <= i && i <= 767) { /*光标用定时器*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}



void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act)

{

（中略）

char c, tc, tbc;

if (act != 0) {

tc = COL8_FFFFFF;

tbc = COL8_000084;

} else {

tc = COL8_C6C6C6;

tbc = COL8_848484;

}

（中略）

boxfill8(buf, xsize, tbc, 3, 3, xsize - 4, 20 );

boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2);

boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1);

putfonts8_asc(buf, xsize, 24, 4, tc, title);

for (y = 0; y < 14; y++) {

（中略）

}

return;

}



void task_b_main(struct SHEET *sht_win_b)

{

struct FIFO32 fifo;

struct TIMER *timer_1s;

int i, fifobuf[128], count = 0, count0 = 0;

char s[12];



fifo32_init(&fifo, 128, fifobuf, 0);

timer_1s = timer_alloc();

timer_init(timer_1s, &fifo, 100);

timer_settime(timer_1s, 100);



for (;;) {

count++;

io_cli();

if (fifo32_status(&fifo) == 0) {

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i == 100) {

sprintf(s, "%11d", count - count0);

putfonts8_asc_sht(sht_win_b, 24, 28, COL8_000000, COL8_C6C6C6, s, 11);

count0 = count;

timer_settime(timer_1s, 100);

}

}

}

}




这次的代码相当长，不过我们只是对之前的程序进行了整理，难度并没有提高。不要被代码的长度吓倒，只要静下心来仔细读一读，应该很快就会理解的。

在make_window8中我们增加了一个act变量。当act为1时，颜色不变，当为0时，窗口的标题栏（就是显示窗口名称的地方）会变成灰色。task_b_main中，去掉了每0.01秒显示一次count的部分，只保留每1秒显示速度的功能。

■■■■■

我们来运行一下，“make run”。怎么样，是不是感觉更像操作系统了呢？对了，现在只有任务A的窗口是可以拖动的（因为移动窗口的部分没有改写进去）。

任务B0～B2这3个任务基本上是以同样的速度在运行。在模拟器环境下它们的速度会有所差异，但在真机环境下还是十分接近的，如下：

4684200　　 4684800　　 4684800



4个任务在同时工作

看来运行非常成功。





4　设定任务优先级（1）（harib13d）

任务B0～B2以同样的速度运行，从公平竞争的角度来说确实不错，不过在某些情况下，我们需要提升或者降低某个应用程序的优先级，因此接下来我们要来实现这样的功能。

在此之前，任务切换间隔都固定为了0.02秒，我们把它修改一下，使得可以为每个任务在0.01秒～0.1秒的范围内设定不同的任务切换间隔，这样一来，我们就能实现最大10倍的优先级差异。

本次的bootpack.h节选

struct TASK {

int sel, flags; /* sel代表GDT编号 */

int priority; /*这里！*/

struct TSS32 tss;

};




变量名“priority”是“优先级”一词的英文写法。

■■■■■

为了应用上面的新结构，我们需要改写mtask.c。

本次的mtask.c节选

struct TASK *task_init(struct MEMMAN *memman)

{

（中略）

task = task_alloc();

task->flags = 2; /*活动中标志*/

task->priority = 2; /* 0.02秒 */

taskctl->running = 1;

taskctl->now = 0;

taskctl->tasks[0] = task;

load_tr(task->sel);

task_timer = timer_alloc();

timer_settime(task_timer, task->priority);

return task;

}




对task_init的改写很简单，没有什么需要特别说明的地方。在这里，我们给最开始的任务设定了0.02秒这个标准值。

■■■■■

接下来是用来运行任务的task_run，我们让它可以通过参数来设定优先级。

本次的mtask.c节选

void task_run(struct TASK *task, int priority)

{

if (priority > 0) {

task->priority = priority;

}

if (task->flags != 2) {

task->flags = 2; /*活动中标志*/

taskctl->tasks[taskctl->running] = task;

taskctl->running++;

}

return;

}




上面的代码中，一开始我们先判断了priority的值，当为0时则表示不改变当前已经设定的优先级。这样的设计主要是为了在唤醒休眠任务的时候使用。

此外，即使该任务正在运行，我们也能使用task_run仅改变任务的优先级。

■■■■■

接着是task_switch，我们要让它在设置定时器的时候，应用priority的值。

本次的mtask.c节选

void task_switch(void)

{

struct TASK *task;

taskctl->now++;

if (taskctl->now == taskctl->running) {

taskctl->now = 0;

}

task = taskctl->tasks[taskctl->now];

timer_settime(task_timer, task->priority);

if (taskctl->running >= 2) {

farjmp(0, task->sel);

}

return;

}




当只有一个任务的时候，如果执行farjmp(0, task—>sel);的话，虽然不会真的切换但确实是发出了任务切换的指令。这时CPU会认为“操作系统怎么会做这种毫无意义的事情呢？这一定是操作系统的bug！”因而拒绝执行该指令，程序运行就会乱套。所以我们需要在farjmp之前，判断任务数量是否在2个以上。

这样一来，对mtask.c的改写就OK了。

■■■■■

现在我们来改写fifo.c。从休眠状态唤醒任务的时候需要调用task_run，我们这次主要就是改写这个地方。说白了，其实我们只是将任务唤醒，并不改变其优先级，因此只要将优先级设置为0就可以了。

本次的fifo.c节选

int fifo32_put(struct FIFO32 *fifo, int data)

/*向FIFO写入数据并累积起来*/

{

（中略）

fifo->free--;

if (fifo->task != 0) {

if (fifo->task->flags != 2) { /*如果任务处于休眠状态*/

task_run(fifo->task, 0); /*将任务唤醒*/

}

}

return 0;

}




■■■■■

最后我们来改写一下HariMain，做一做改变优先级的实验。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/* sht_win_b */

for (i = 0; i < 3; i++) {

（中略）

task_run(task_b[i], i + 1);

}



（中略）

}




好了，大功告成。

■■■■■

我们为任务B0设置为优先级1，任务B1为2，任务B2为3，因此B2应该是最快的，而B0应该是最慢的，其速度的差异应该正好是3倍的关系。马上“make run”一下。



结果是这个样子

而真机环境下的结果如下。

1711130 3234785 4663010

(1806134) (4758230)




加括号的数值代表偶尔会出现的结果，根据每秒轮到该任务执行的次数不同，数值也会有些差异。如果以任务B0为基准来看，任务B1为1.9倍，任务B2为2.7倍。虽然不是完美的整数倍这一点令人有些不爽，不过用C语言写的程序，多多少少会有些误差。总之，这样的结果已经达到我们的目的了。





5　设定任务优先级（2）（harib13e）

如果多把玩一下harib13d，会发现鼠标的移动速度好像有点慢，尤其是拖住窗口快速移动的时候，反应很糟糕。模拟器环境下手已经放开鼠标了可它还在动，即使到了真机环境下也还是觉得有点不利索。

问题的原因在于，其他任务的运行造成任务A运行速度变慢，从而导致了上述情形。要解决这个问题，只要把任务A的优先级调高就可以了，调到最高值10的话，情况应该会有所改善吧。我们在HariMain中将启动任务A的部分改为task_run(task_a, 10);来试试看，果然速度回到从前的样子了。

有人可能会担心，如果把优先级设为10，那其他任务的运行速度不就变慢了吗？不会的。任务A的优先级无论设置得多高，也一点都不会浪费时间，因为当任务A空闲的时候会自动休眠，只要进入休眠状态，即从tasks中删除后，优先级的设置就毫无影响了，其他任务的运行速度也就和之前没什么区别了。

■■■■■

上述例子说明，任务优先级是个很好用的东西。我们不妨把这个例子来总结一下：在操作系统中有一些处理，即使牺牲其他任务的性能也必须要尽快完成，否则会引起用户的不满，就比如这次对鼠标的处理。对于这类任务，我们可以让它在处理结束后马上休眠，而优先级则可以设置得非常高。

这种宁可牺牲其他任务性能也必须要尽快处理的任务可不是只有鼠标一个，比如键盘处理也是一样，网络处理应该也属于这类（如果速度太慢的话可能会丢失数据哦）。播放音乐也是，如果音乐播放任务的优先级太低的话，音乐就会一卡一卡的。

我们当然可以把这些任务的优先级都设置成10，不过真这样做的话，当它们之中的两个以上同时运行的时候，可能还是会出问题。如果拿音乐和鼠标做比较，那应该是音乐更重要吧。因为如果发生“在播放音乐的时候移动窗口，音乐卡住”这种情况，用户肯定会觉得超级不爽的。相比之下，哪怕鼠标的反应稍微慢些，我们也要保证音乐播放的质量。

然而按照现在的设计，当优先级为10的两个任务同时运行时，优先哪个就全凭运气了，任务切换先轮到谁谁就赢了。运气好的那个任务可以消耗很多时间来完成它的工作，而另外一个优先级同样是10的任务就只能等待了。也就是说，如果运气不好，音乐播放就会变得一团糟，而这样的操作系统显然不怎么好用。

■■■■■

因此我们需要设计一种架构，使得即便高优先级的任务同时运行，也能够区分哪个更加优先。

其实也没有架构那么复杂，基本上就是创建了几个struct TASKCTL。个数随意，多少都行，我们在这里先按创建3个来讲解。



这种架构的工作原理是，最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL 2出场了。

在这种架构下，只要把音乐播放任务设置在LEVEL 0中，就可以保证获得比鼠标更高的优先级。

■■■■■

实际上，我们不需要创建多个TASKCTL，只要在TASKCTL中创建多个tasks[]即可。

本次的bootpack.h节选

#define MAX_TASKS_LV 100

#define MAX_TASKLEVELS 10



struct TASK {

int sel, flags; /* se1用来存放GDT的编号*/

int level, priority;

struct TSS32 tss;

};



struct TASKLEVEL {

int running; /*正在运行的任务数量*/

int now; /*这个变量用来记录当前正在运行的是哪个任务*/

struct TASK *tasks[MAX_TASKS_LV];

};



struct TASKCTL {

int now_lv; /*现在活动中的LEVEL */

char lv_change; /*在下次任务切换时是否需要改变LEVEL */

struct TASKLEVEL level[MAX_TASKLEVELS];

struct TASK tasks0[MAX_TASKS];

};




对于每个LEVEL我们设定最多允许创建100个任务，总共10个LEVEL。至于其余有变更的地方，与其在这里用文字讲解，不如看看在程序中的实际应用更加容易理解。

■■■■■

首先，我们先写几个用于操作struct TASKLEVEL的函数，如果没有这些函数的话，task_run和task_sleep会变得冗长难懂。

其中task_now函数，用来返回现在活动中的struct TASK的内存地址。

本次的mtask.c节选

struct TASK *task_now(void)

{

struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];

return tl->tasks[tl->now];

}




这里面包含很多结构，比较繁琐，不过仔细看看应该就能明白。

■■■■■

task_add函数，用来向struct TASKLEVEL中添加一个任务。

本次的mtask.c节选

void task_add(struct TASK *task)

{

struct TASKLEVEL *tl = &taskctl->level[task->level];

tl->tasks[tl->running] = task;

tl->running++;

task->flags = 2; /*活动中*/

return;

}




实际上，这里应该增加if（tl —> running < MAX_TASKS_LV）等，这可以判断在一个LEVEL中是否错误地添加了100个以上的任务，不过我们把它省略了，不好意思，偷个懒。

■■■■■

task_remove函数，用来从struct TASKLEVEL中删除一个任务。

本次的mtask.c节选

void task_remove(struct TASK *task)

{

int i;

struct TASKLEVEL *tl = &taskctl->level[task->level];



/*寻找task所在的位置*/

for (i = 0; i < tl->running; i++) {

if (tl->tasks[i] == task) {

/*在这里 */

break;

}

}



tl->running--;

if (i < tl->now) {

tl->now--; /*需要移动成员，要相应地处理 */

}

if (tl->now >= tl->running) {

/*如果now的值出现异常，则进行修正*/

tl->now = 0;

}

task->flags = 1; /* 休眠中 */



/* 移动 */

for (; i < tl->running; i++) {

tl->tasks[i] = tl->tasks[i + 1];

}



return;

}




上面的代码基本上是照搬了task_sleep的内容。

■■■■■

task_switchsub函数，用来在任务切换时决定接下来切换到哪个LEVEL。

本次的mtask.c节选

void task_switchsub(void)

{

int i;

/*寻找最上层的LEVEL */

for (i = 0; i < MAX_TASKLEVELS; i++) {

if (taskctl->level[i].running > 0) {

break; /*找到了*/

}

}

taskctl->now_lv = i;

taskctl->lv_change = 0;

return;

}




到目前为止，和struct TASKLEVEL相关的函数已经差不多都写好了，准备工作做到这里，接下来的事情就简单多了。

下面我们来改写其他一些函数，首先是task_init。最开始的任务，我们先将它放在LEVEL 0，也就是最高优先级LEVEL中。这样做在有些情况下可能会有问题，不过后面可以再用task_run重新设置，因此不用担心。

本次的mtask.c节选

struct TASK *task_init(struct MEMMAN *memman)

{

（中略）

for (i = 0; i < MAX_TASKLEVELS; i++) {

taskctl->level[i].running = 0;

taskctl->level[i].now = 0;

}

task = task_alloc();

task->flags = 2; /*活动中标志*/

task->priority = 2; /* 0.02秒*/

task->level = 0; /*最高LEVEL */

task_add(task);

task_switchsub(); /* LEVEL 设置*/

load_tr(task->sel);

task_timer = timer_alloc();

timer_settime(task_timer, task->priority);

return task;

}




开始的时候只有LEVEL 0中有一个任务，因此我们按照这样的方式来进行初始化。

■■■■■

下面是task_run，我们要让它可以在参数中指定LEVEL。

本次的mtask.c节选

void task_run(struct TASK *task, int level, int priority)

{

if (level < 0) {

level = task->level; /*不改变LEVEL */

}

if (priority > 0) {

task->priority = priority;

}



if (task->flags == 2 && task->level != level) { /*改变活动中的LEVEL */

task_remove(task); /*这里执行之后flag的值会变为1，于是下面的if语句块也会被执行*/

}

if (task->flags != 2) {

/*从休眠状态唤醒的情形*/

task->level = level;

task_add(task);

}



taskctl->lv_change = 1; /*下次任务切换时检查LEVEL */

return;

}




在此之前，task_run中下一个要切换到的任务是固定不变的，不过现在情况就不同了。例如，如果用task_run启动了一个比现在活动中的任务LEVEL更高的任务，那么在下次任务切换时，就必须无条件地切换到该LEVEL中的该任务去。



此外，如果当前活动中的任务LEVEL被下调，那么此时就必须将其他LEVEL的任务放在优先的位置（同样以上图来说的话，比如当LEVEL 0的任务被降级到LEVEL 2时，任务切换的目标就需要从LEVEL 0变为LEVEL 1）。

综上所述，我们需要在下次任务切换时先检查LEVEL，因此将lv_change置为1。

■■■■■

接下来是task_sleep，在这里我们可以调用task_remove，因此代码会大大缩短。

本次的mtask.c节选

void task_sleep(struct TASK *task)

{

struct TASK *now_task;

if (task->flags == 2) {

/*如果处于活动状态*/

now_task = task_now();

task_remove(task); /*执行此语句的话flags将变为1 */

if (task == now_task) {

/*如果是让自己休眠，则需要进行任务切换*/

task_switchsub();

now_task = task_now(); /*在设定后获取当前任务的值*/

farjmp(0, now_task->sel);

}

}

return;

}




这样看上去清清爽爽。

■■■■■

mtask.c的最后是task_switch，除了当lv_change不为0时的处理以外，其余几乎没有变化。

void task_switch(void)

{

struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];

struct TASK *new_task, *now_task = tl->tasks[tl->now];

tl->now++;

if (tl->now == tl->running) {

tl->now = 0;

}

if (taskctl->lv_change != 0) {

task_switchsub();

tl = &taskctl->level[taskctl->now_lv];

}

new_task = tl->tasks[tl->now];

timer_settime(task_timer, new_task->priority);

if (new_task != now_task) {

farjmp(0, new_task->sel);

}

return;

}




对比前面内容来读的话，应该很容易理解。到此为止，我们对mtask.c的改写就完成了。

■■■■■

fifo.c也需要改写一下，不过和上一节一样，只是将唤醒休眠任务的task_run稍稍修改一下而已。优先级和LEVEL都不需要改变，只要维持原状将任务唤醒即可。

本次的fifo.c节选

int fifo32_put(struct FIFO32 *fifo, int data)

/*向FIFO写入数据并累积起来*/

{

（中略）

fifo->free--;

if (fifo->task != 0) {

if (fifo->task->flags != 2) { /*如果任务处于休眠状态*/

task_run(fifo->task, -1, 0); /*将任务唤醒*/

}

}

return 0;

}




■■■■■

最后我们来改写HariMain，可到底该怎么改呢？我们就暂且将任务A设为LEVEL 1，任务B0～B2设为LEVEL 2吧。这样的话，当任务A忙碌的时候就不会切换到任务B0～B2，鼠标操作的响应应该会有不小的改善。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);

task_a = task_init(memman);

fifo.task = task_a;

task_run(task_a, 1, 0); /*这里！ */



（中略）



/* sht_win_b */

for (i = 0; i < 3; i++) {

（中略）

task_run(task_b[i], 2, i + 1); /*这里！ */

}



（中略）

}




■■■■■

好，我们来“make run”。画面看上去和harib13d一模一样，但如果用鼠标不停地拖动窗口的话，就会感到响应速度和之前有很大不同。相对地，拖动窗口时任务B0～B2会变得非常慢，这就代表我们的设计成功了，撒花！

多任务的基础部分到这里就算完成了。明天我们还会补充一些代码来完善一下，然后就开始制作一些更有操作系统范儿的东西了。大家晚安！





第17天　命令行窗口



闲置任务（harib14a）

创建命令行窗口（harib14b）

切换输入窗口（harib14c）

实现字符输入（harib14d）

符号的输入（harib14e）

大写字母与小写字母（harib14f）

对各种锁定键的支持（harib14g）





1　闲置任务（harib14a）

今天一开始，请大家先回忆一下任务A的情形。在harib13e中，任务A下面的LEVEL中有任务B0～B2，因此FIFO为空时我们可以让任务A进入休眠状态。那么，如果我们并未启动任务B0～B2的话，任务A又将会如何呢？

首先，如果我们不对任务A进行任何改写，就按照它现在的样子进入休眠状态的话，大家想一想，会发生什么呢？一旦任务A休眠，mtask.c将自动寻找下层LEVEL中的任务，但由于这一次我们没有启动任务B0～B2，因此程序就找不到其他的任务而导致运行出现异常。

如果这样不行，那我们把休眠的部分再改回io_hlt();不就好了吗？这样一来，不但程序运行不会出现异常，还能省电呢，撒花！……话虽如此，但如果一个操作系统要根据下层LEVEL是否存在任务来改写程序的话，大家觉得靠谱吗？笔者认为，即使不改写程序，也能自动在适当的LEVEL运行适当的任务，这样的操作系统才是优秀的操作系统。

因此，一般情况下可以让任务休眠，但当所有LEVEL中都没有任务存在的时候，就需要HTL了。接下来我们就按照这个要求来改写mtask.c。

■■■■■

那么我们从task_sleep开始改起吧。且慢，我们确实可以这样来改，但是改写之后task_sleep将变得更加复杂，速度也会打折扣（说是会打折扣，其实应该也就是稍微慢一点点而已啦）。其实我们还有更好的方法。

如果“所有LEVEL中都没有任务”就会出问题，那我们只要避免这种情况发生不就可以了吗？这类似于我们写定时器的时候所采用的“卫兵”的思路。

本次的mtask.c节选

void task_idle(void)

{

for (;;) {

io_hlt();

}

}




我们创建这样一个任务，并把它一直放在最下层LEVEL中，大家觉得如何？“idle”（闲置）就是代表“不工作，空闲”的意思，这个任务的功能只是执行HTL。

这样一来，即便任务A进入休眠状态，系统也会自动切换到上面这个闲置任务，于是便开始执行HTL。当我们移动鼠标，FIFO中有数据写入的时候，任务A就会被唤醒，系统会自动切换到任务A继续工作。

综上所述，我们完全不需要对task_sleep等代码进行任何改动，只需在task_init中将这个闲置任务放在最下层LEVEL中就可以了。

本次的mtask.c节选

struct TASK *task_init(struct MEMMAN *memman)

{

struct TASK *task, *idle;

（中略）



idle = task_alloc();

idle->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024;

idle->tss.eip = (int) &task_idle;

idle->tss.es = 1 * 8;

idle->tss.cs = 2 * 8;

idle->tss.ss = 1 * 8;

idle->tss.ds = 1 * 8;

idle->tss.fs = 1 * 8;

idle->tss.gs = 1 * 8;

task_run(idle, MAX_TASKLEVELS - 1, 1);



return task;

}




就是这样，很简单吧。

■■■■■

接着我们来测试一下，将HariMain改成下面这样。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/* sht_win_b */

for (i = 0; i < 3; i++) {

（中略）

*((int *) (task_b[i]->tss.esp + 4)) = (int) sht_win_b[i];

/* task_run(task_b[i], 2, i + 1); */ /*这里！*/

}



（中略）

}




也就是说，我们不让系统运行任务B0～B2，这样就只剩下任务A和task_idle了。当然，这样改只是不启动任务而已，窗口还是会照常显示的。

然后我们来“make run”，画面如下。



只有任务A的情况下也不会出现异常哦！





2　创建命令行窗口（harib14b）

所谓命令行窗口，就是大家在运行“make run”的时候所使用的那个黑底白字的，在里面输入文件名就可以运行程序的东西。接下来我们就做一个试试看。

“这玩意儿能算是命令行窗口吗？”我们一开始做出来的东西很可能带来这样的疑问，不过没关系，我们会让它逐步发展壮大，最终实现可以启动应用程序的功能。你看，是不是越来越像个操作系统的样子了呢？大家一定迫不及待了吧。

我们并不打算将命令行窗口作为任务A的一部分，而是单独做成一个新的任务。这样一来，就像任务B0～B2一样，我们可以很容易地创建多个命令行窗口。

我们对任务B的程序进行一些修改，并将任务A程序的一部分融合进去，就写成了下面这个样子。计数我们已经玩腻了，所以把计数的代码从任务B中删除。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/* sht_cons */

sht_cons = sheet_alloc(shtctl);

buf_cons = (unsigned char *) memman_alloc_4k(memman, 256 * 165);

sheet_setbuf(sht_cons, buf_cons, 256, 165, -1); /*无透明色*/

make_window8(buf_cons, 256, 165, "console", 0);

make_textbox8(sht_cons, 8, 28, 240, 128, COL8_000000);

task_cons = task_alloc();

task_cons->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 8;

task_cons->tss.eip = (int) &console_task;

task_cons->tss.es = 1 * 8;

task_cons->tss.cs = 2 * 8;

task_cons->tss.ss = 1 * 8;

task_cons->tss.ds = 1 * 8;

task_cons->tss.fs = 1 * 8;

task_cons->tss.gs = 1 * 8;

*((int *) (task_cons->tss.esp + 4)) = (int) sht_cons;

task_run(task_cons, 2, 2); /* level=2, priority=2 */



（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_cons, 32, 4);

sheet_slide(sht_win, 64, 56);

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_cons, 1);

sheet_updown(sht_win, 2);

sheet_updown(sht_mouse, 3);

（中略）

}



void console_task(struct SHEET *sheet)

{

struct FIFO32 fifo;

struct TIMER *timer;

struct TASK *task = task_now();



int i, fifobuf[128], cursor_x = 8, cursor_c = COL8_000000;

fifo32_init(&fifo, 128, fifobuf, task);



timer = timer_alloc();

timer_init(timer, &fifo, 1);

timer_settime(timer, 50);



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (i <= 1) { /*光标用定时器*/

if (i != 0) {

timer_init(timer, &fifo, 0); /*下次置0 */

cursor_c = COL8_FFFFFF;

} else {

timer_init(timer, &fifo, 1); /*下次置1 */

cursor_c = COL8_000000;

}

timer_settime(timer, 50);

boxfill8(sheet->buf, sheet->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44);

}

}

}

}




有一个地方需要解释一下，就是console_task中task = task_now(); 这里。在console_task中需要执行休眠，因此必须要知道自己本身的TASK结构所在的内存地址。由于HariMain中准备了task_cons，可以像sheet那样从HariMain传入这个地址，但那样也有点过于繁琐了。忽然想到在mtask.c中不是有个task_now函数吗，就用它来获取TASK地址好了。

■■■■■

我们来“make run”，结果如下。



看上去像不像命令行窗口的样子？

作为我们的命令行窗口雏形，看上去还不赖。





3　切换输入窗口（harib14c）

命令行窗口这东西，如果不能在里面输入字符的话就毫无用处了，因此我们得让它能接受字符输入才行。不过现在无论我们输入什么字符，都会跑到任务A的窗口中去，所以为了能够往命令行窗口中输入字符，我们要让系统在按下“Tab”键的时候，将输入窗口切换到命令行窗口上去。

虽说是切换窗口，其实我们只是先将窗口标题栏的颜色改一改而已啦（苦笑）。真正负责输入切换的部分我们下一节再写，改变先从表面工夫开始吧。

■■■■■

要改变窗口标题栏颜色，最好将make_window8中描绘窗口标题栏的代码，和描绘窗口剩余部分的代码区分开来，我们将这个函数改写一下。

本次的bootpack.c节选

void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act)

{

boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize - 1, 0 );

boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize - 2, 1 );

boxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize - 1);

boxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize - 2);

boxfill8(buf, xsize, COL8_848484, xsize - 2, 1, xsize - 2, ysize - 2);

boxfill8(buf, xsize, COL8_000000, xsize - 1, 0, xsize - 1, ysize - 1);

boxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize - 3, ysize - 3);

boxfill8(buf, xsize, COL8_848484, 1, ysize - 2, xsize - 2, ysize - 2);

boxfill8(buf, xsize, COL8_000000, 0, ysize - 1, xsize - 1, ysize - 1);

make_wtitle8(buf, xsize, title, act);

return;

}



void make_wtitle8(unsigned char *buf, int xsize, char *title, char act)

{

static char closebtn[14][16] = {

"OOOOOOOOOOOOOOO@",

"OQQQQQQQQQQQQQ$@",

"OQQQQQQQQQQQQQ$@",

"OQQQ@@QQQQ@@QQ$@",

"OQQQQ@@QQ@@QQQ$@",

"OQQQQQ@@@@QQQQ$@",

"OQQQQQQ@@QQQQQ$@",

"OQQQQQ@@@@QQQQ$@",

"OQQQQ@@QQ@@QQQ$@",

"OQQQ@@QQQQ@@QQ$@",

"OQQQQQQQQQQQQQ$@",

"OQQQQQQQQQQQQQ$@",

"O$$$$$$$$$$$$$$@",

"@@@@@@@@@@@@@@@@"

};

int x, y;

char c, tc, tbc;

if (act != 0) {

tc = COL8_FFFFFF;

tbc = COL8_000084;

} else {



tc = COL8_C6C6C6;

tbc = COL8_848484;

}

boxfill8(buf, xsize, tbc, 3, 3, xsize - 4, 20);

putfonts8_asc(buf, xsize, 24, 4, tc, title);

for (y = 0; y < 14; y++) {

for (x = 0; x < 16; x++) {

c = closebtn[y][x];

if (c == '@') {

c = COL8_000000;

} else if (c == '$') {

c = COL8_848484;

} else if (c == 'Q') {

c = COL8_C6C6C6;

} else {

c = COL8_FFFFFF;

}

buf[(5 + y) * xsize + (xsize - 21 + x)] = c;

}

}

return;

}




这样就差不多了，接下来我们来改写HariMain。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int key_to = 0; /*这里！ */



（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /*键盘数据 */

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i < 0x54 + 256) {

（中略）

}

if (i == 256 + 0x0e && cursor_x > 8) { /*退格键*/

（中略）

}

/*从此开始*/ if (i == 256 + 0x0f) { /* Tab键*/

if (key_to == 0) {

key_to = 1;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 0);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 1);

} else {

key_to = 0;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 1);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 0);

}

sheet_refresh(sht_win, 0, 0, sht_win->bxsize, 21);

sheet_refresh(sht_cons, 0, 0, sht_cons->bxsize, 21);

/*到此结束*/ }



/*重新显示光标*/

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




这段代码的重点在于key_to这个变量，用于记录键盘输入（key）应该发送到（to）哪里。为0则发送到任务A，为1则发送到命令行窗口任务。

还是一如既往地“make run”，然后按下Tab键试试看。



按下Tab键之后

哇，颜色变了耶！真不错啊。心情好激动，先按个10次Tab键看看。嗒嗒嗒嗒……

然后又很得意地输入了“abc”试试看，果然，结果是这个样子。



果然还是不行啊！

好，接下来我们就来实现键盘输入啦！





4　实现字符输入（harib14d）

要实现字符的输入，只要在键盘被按下的时候向console_task的FIFO发送数据即可。但要发送数据，必须要知道struct FIFO的内存地址才行。唔，这可怎么办呢？

我们可以让任务A在创建task_cons的时候，顺便将FIFO也准备好。这样一来，任务A就能知道task_cons所使用的FIFO的地址，我们的问题便迎刃而解了。

等等，这样还是太麻烦了，我们还是把struct FIFO放到struct TASK里面去吧。基本上没有什么任务是完全用不到FIFO的，因此我们把它们绑定起来。

本次的bootpack.h节选

struct TASK {

int sel, flags; /* sel代表GDT编号 */

int level, priority;

struct FIFO32 fifo; /*这里！ */

struct TSS32 tss;

};




■■■■■

接下来我们来修改一下HariMain，使其判断key_to的值并向task_cons的FIFO发送数据。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /*键盘数据*/

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

/*从此开始*/ if (i < 0x54 + 256 && keytable[i - 256] != 0) { /*一般字符*/

if (key_to == 0) { /*发送给任务A */

if (cursor_x < 128) {

/*显示一个字符之后将光标后移一位*/

s[0] = keytable[i - 256];

s[1] = 0;

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1);

cursor_x += 8;



}

} else { /*发送给命令行窗口*/

fifo32_put(&task_cons->fifo, keytable[i - 256] + 256);

/*到此结束*/ }

}

if (i == 256 + 0x0e) { /* 退格键 */

/*从此开始*/ if (key_to == 0) { /*发送给任务A */

if (cursor_x > 8) {

/*用空白擦除光标后将光标前移一位*/

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, " ", 1);

cursor_x -= 8;

}

} else { /*发送给命令行窗口*/

fifo32_put(&task_cons->fifo, 8 + 256);

/*到此结束*/ }

}

if (i == 256 + 0x0f) { /* Tab键*/

（中略）

}

/*重新显示光标*/

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




当key_to不为0时，系统会向命令行窗口任务发送键盘数据，支持一般的字符输入和退格键。由于在命令行窗口中也使用了定时器等，为了不与键盘数据冲突，我们在写入FIFO的时候将键盘数据的值加上256。

在向命令行窗口发送键盘数据的时候，并不是直接发送从键盘接收到的原始数据，而是发送经过keytable[]转换后的值。究其原因，是由于这样做可以省去在命令行窗口任务中将按键编码转换成字符编码的步骤。

对于退格键，我们将它的字符编码定义为8，因为在ASCII码中，编码8就对应着退格键，我们只是和它接轨而已。当然，如果你不想用8也完全没有问题。

■■■■■

console_task也需要改写一下，因为我们必须让它能够接收并处理键盘数据。此外，我们还得把&fifo改写成&task—>fifo。

本次的bootpack.c节选

void console_task(struct SHEET *sheet)

{

struct TIMER *timer;

struct TASK *task = task_now();

int i, fifobuf[128], cursor_x = 16, cursor_c = COL8_000000;

char s[2];



fifo32_init(&task->fifo, 128, fifobuf, task);

timer = timer_alloc();

timer_init(timer, &task->fifo, 1);

timer_settime(timer, 50);



/*显示提示符*/

putfonts8_asc_sht(sheet, 8, 28, COL8_FFFFFF, COL8_000000, ">", 1);



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

task_sleep(task);

io_sti();

} else {

i = fifo32_get(&task->fifo);

io_sti();

if (i <= 1) { /*光标用定时器*/

if (i != 0) {

timer_init(timer, &task->fifo, 0); /*接下来置0 */

cursor_c = COL8_FFFFFF;

} else {

timer_init(timer, &task->fifo, 1); /*接下来置1 */

cursor_c = COL8_000000;

}

timer_settime(timer, 50);

}

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

if (cursor_x > 16) {

/*用空白擦除光标后将光标前移一位*/

putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, " ", 1);

cursor_x -= 8;

}

} else {

/*一般字符*/

if (cursor_x < 240) {

/*显示一个字符之后将光标后移一位 */

s[0] = i - 256;

s[1] = 0;

putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1);

cursor_x += 8;

}

}

}

/*重新显示光标*/

boxfill8(sheet->buf, sheet->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44);

}

}

}




上面的程序基本是由HariMain照猫画虎而来，唯一的一点区别就是开头显示提示符“>”的地方了。退格键的处理上也对可以删除的界限作了调整，以避免退格时擦掉提示符。

■■■■■

我们来运行一下看看，“make run”。



可以输入了哦！

成功了，真是个伟大的胜利。现在我们可以输入英文、数字和符号了，但还无法输入“!”和“%”。好吧，接下来我们来解决这个问题。





5　符号的输入（harib14e）

我们这一节的课题就是要实现“!”和“%”的输入。

为了能够输入“!”和“%”，我们必须要处理Shift键。根据14.4节的按键编码表，Shift键的按键编码如下（觉得看表格看麻烦的话，可以自己“make run”一下，按键的时候屏幕上会显示出按键编码）。

按下键时的数值表

按　　下 抬　　起

左Shift 0x2a 0xaa

右Shift 0x36 0xb6

因此，我们准备一个key_shift变量，当左Shift按下时置为1，右Shift按下时置为2，两个都不按时置为0，两个都按下（有人会这么干吗？）的时候就置为3。

当key_shift为0时，我们用keytable0[]将按键编码转换为字符编码，而当key_shift不为0时，则使用keytable1[]进行转换。

■■■■■

将上面的思路用程序写到HariMain中，就是下面这样。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

static char keytable0[0x80] = {

0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '^', 0, 0,

'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0, 0, 'A', 'S',

'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', ':', 0, 0, ']', 'Z', 'X', 'C', 'V',

'B', 'N', 'M', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1',

'2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0, 0x5c, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x5c, 0, 0

};

static char keytable1[0x80] = {

0, 0, '!', 0x22, '#', '$', '%', '&', 0x27, '(', ')', '~', '=', '~', 0, 0,

'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '`', '{', 0, 0, 'A', 'S',

'D', 'F', 'G', 'H', 'J', 'K', 'L', '+', '*', 0, 0, '}', 'Z', 'X', 'C', 'V',

'B', 'N', 'M', '<', '>', '?', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1',

'2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

0, 0, 0, '_', 0, 0, 0, 0, 0, 0, 0, 0, 0, '|', 0, 0

};

int key_to = 0, key_shift = 0;



（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /*键盘数据*/

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i < 0x80 + 256) { /*将按键编码转换为字符编码*/

if (key_shift == 0) {

s[0] = keytable0[i - 256];

} else {

s[0] = keytable1[i - 256];

}

} else {

s[0] = 0;

}

if (s[0] != 0) { /*一般字符*/

if (key_to == 0) { /*发送给任务A */

if (cursor_x < 128) {

/*显示一个字符之后将光标后移一位*/

s[1] = 0;

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1);

cursor_x += 8;

}

} else { /*发送给命令行窗口*/

fifo32_put(&task_cons->fifo, s[0] + 256);

}

}

if (i == 256 + 0x0e) { /*退格键*/



（中略）

}

if (i == 256 + 0x0f) { /* Tab键*/

（中略）

}

if (i == 256 + 0x2a) { /*左Shift ON */

key_shift |= 1;

}

if (i == 256 + 0x36) { /*右Shift ON */

key_shift |= 2;

}

if (i == 256 + 0xaa) { /*左Shift OFF */

key_shift &= ~1;

}

if (i == 256 + 0xb6) { /*右Shift OFF */

key_shift &= ~2;

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




关于keytable0[]和keytable1[]，考虑到顺便支持“\”和“_”的输入也不错，就让它一直支持到0x80的转换吧。在keytable1[]中，对于英文字母和小键盘的部分没有进行改动。

程序的原理是，先将按键编码转换成字符编码，转换结果存入s[0]。如果遇到无法转换的按键编码，则向s[0]存入0。剩下的部分没有什么难度，只要仔细读读程序应该就可以理解了。

■■■■■

我们来运行一下，结果如下。



可以输入符号了！

虽然我们只修改了任务A，但在命令行窗口中也可以输入符号了，真不错。不过现在我们输入的英文字母都显示成大写，这个看着实在不舒服，因此我们需要实现小写字母的输入，一起看下一节吧。





6　大写字母与小写字母（harib14f）

要实现区分大写、小写字母的输入，我们必须要同时判断Shift键的状态以及CapsLock的状态。

CapsLock为OFF & Shift键为OFF → 小写英文字母

CapsLock为OFF & Shift键为ON → 大写英文字母

CapsLock为ON & Shift键为OFF → 大写英文字母

CapsLock为ON & Shift键为ON → 小写英文字母

综上所述，我们可以将需要转换为小写字母的条件总结如下：



输入的字符为英文字母



“CapsLock为OFF & Shift键为OFF”或者“CapsLock为ON & Shift键为ON”





我们已经知道如何获取Shift键的状态，但是CapsLock的状态要如何获取呢？BIOS知道CapsLock的状态，可现在我们处于32位模式，没办法向BIOS查询。不过别担心，在asmhead.nas中，我们已经从BIOS获取到了键盘状态，就保存在binfo—>leds中。

binfo->leds的第4位→ ScrollLock状态

binfo->leds的第5位 → NumLock状态

binfo->leds的第6位 → CapsLock状态

只要使用上述数据，我们就可以处理大小写字母的输入了。

■■■■■

在if语句中，除了&&运算符，还有一个||运算符，这个运算符代表“只要其中任意一个条件成立即可”的意思，我们可以用它来改写HariMain，使其能够实现小写字母的输入。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int key_to = 0, key_shift = 0, key_leds = (binfo->leds >> 4) & 7; /*这里！*/



（中略）



for (;;) {

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /*键盘数据*/

sprintf(s, "%02X", i - 256);

putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

if (i < 0x80 + 256) { /*将按键编码转换为字符编码*/

（中略）

} else {

s[0] = 0;

}

/*从此开始*/ if ('A' <= s[0] && s[0] <= 'Z') { /*当输入字符为英文字母时*/

if (((key_leds & 4) == 0 && key_shift == 0) ||

((key_leds & 4) != 0 && key_shift != 0)) {

s[0] += 0x20; /*将大写字母转换为小写字母*/

}

/*到此结束*/ }

if (s[0] != 0) { /*一般字符*/

（中略）

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




要获取CapsLock等锁定键的状态，我们只需要第4～6位的数据，剩下的数据对我们没用，所以在key_leds中只从binfo—>leds取出指定的3个比特即可。这里我们还做了4个比特的右移位，这是为了在下一节中能够更加方便地使用这些数据。

我们所使用的ASCII码中，将大写字母的编码加上0x20，就得到相应的小写字母编码。利用这一性质，我们就可以将大写字母转换为小写字母。

■■■■■

我们来运行一下，“make run”，结果如下。



可以输入小写字母了！

呀，这样就变得酷多了吧。啥？不能满足于这点成绩？其实这样挺好的不是吗，一步一个脚印，享受每一次进步，这样才有成就感呀。

我们已经实现了根据CapsLock的状态来切换大小写字母的输入，那大家想不想实现在按下CapsLock键的时候切换CapsLock的状态呢？一定很想吧？（哈哈，笔者又在自说自话了。）

COLUMN-10　键盘的设计问题？

在harib14f中，对于同时按住左右Shift键输入字母的情况，我们的程序也做了相应的处理，即同时按下两个Shift键，和只按下其中一个Shift键效果是一样的。

但当笔者试验了一番之后，却发现了一件很有意思的事情——按下左Shift＋右Shift＋A是无法输入的，可是左Shift＋右Shift＋Z却可以输入。

一开始笔者还惊慌地想“糟糕！别是bug吧！”，但后来看了一下显示出来的按键编码，发现这貌似是键盘本身设计的问题。其实在Windows中也会发生同样的现象。

笔者用家里好几台电脑试验了一下，发现无论用哪个键盘，ASDF这4个键，在同时按下两边Shift键的情况下都无法输入。不过笔者家里的键盘无一例外都是便宜货，说不定中高级键盘上就不会发生这种问题。大家如果有兴趣的话，也可以用自己的键盘试试看哦。





7　对各种锁定键的支持（harib14g）

好，让我们开始吧。回头再看一遍14.4节中的编码表（不想看表格的同学还是可以自己按键盘看编码哦），我们可以得到：

0x3a: CapsLock

0x45: NumLock

0x46: ScrollLock

因此当我们接收到上述按键编码时，只要将binfo—>leds中对应的位置改写就可以了。这和key_shift基本上是一样的，很容易实现。

到这里，我们已经实现了锁定键模式的切换，不过现在还是有一个问题，模式是可以切换了，但是键盘上面的指示灯却不会发生变化。这样就可能会发生下述情况：明明CapsLock灯没亮，但在系统中却是处于CapsLock模式。这个问题我们最好想办法解决它。

关于点亮/熄灭键盘上指示灯的方法，在这里有记载。

http://community.osdev.info/?(AT)keyboard



关于LED的控制

对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。

读取状态寄存器，等待bit 1的值变为0。



向数据输出（0060）写入要发送的1个字节数据。



等待键盘返回1个字节的信息，这和等待键盘输入所采用的方法相同（用IRQ等待或者用轮询状态寄存器bit 1的值直到其变为0都可以）。



返回的信息如果为0xfa，表明1个字节的数据已成功发送给键盘。如为0xfe则表明发送失败，需要返回第1步重新发送。





要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit 0代表ScrollLock，bit 1代表NumLock，bit 2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。





■■■■■

有了这些信息，我们总算看到希望了，于是我们写了以下程序。

本次的bootpack.c节选

#define KEYCMD_LED 0xed



void HariMain(void)

{

（中略）

struct FIFO32 fifo, keycmd;

int fifobuf[128], keycmd_buf[32];

（中略）

int key_to = 0, key_shift = 0, key_leds = (binfo->leds >> 4) & 7, keycmd_wait = -1;

（中略）

fifo32_init(&keycmd, 32, keycmd_buf, 0);

（中略）



/*为了避免和键盘当前状态冲突，在一开始先进行设置*/

fifo32_put(&keycmd, KEYCMD_LED);

fifo32_put(&keycmd, key_leds);



for (;;) {

if (fifo32_status(&keycmd) > 0 && keycmd_wait < 0) { /*从此开始*/

/*如果存在向键盘控制器发送的数据，则发送它 */

keycmd_wait = fifo32_get(&keycmd);

wait_KBC_sendready();

io_out8(PORT_KEYDAT, keycmd_wait);

} /*到此结束*/

io_cli();

if (fifo32_status(&fifo) == 0) {

task_sleep(task_a);

io_sti();

} else {

i = fifo32_get(&fifo);

io_sti();

if (256 <= i && i <= 511) { /* 键盘数据 */

（中略）

/*从此开始*/ if (i == 256 + 0x3a) { /* CapsLock */

key_leds ^= 4;

fifo32_put(&keycmd, KEYCMD_LED);

fifo32_put(&keycmd, key_leds);

}

if (i == 256 + 0x45) { /* NumLock */

key_leds ^= 2;

fifo32_put(&keycmd, KEYCMD_LED);

fifo32_put(&keycmd, key_leds);

}

if (i == 256 + 0x46) { /* ScrollLock */

key_leds ^= 1;

fifo32_put(&keycmd, KEYCMD_LED);

fifo32_put(&keycmd, key_leds);

}

if (i == 256 + 0xfa) { /*键盘成功接收到数据*/

keycmd_wait = -1;

}

if (i == 256 + 0xfe) { /*键盘没有成功接收到数据*/

wait_KBC_sendready();

io_out8(PORT_KEYDAT, keycmd_wait);

/*到此结束*/ }

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




程序的工作原理是这样的。首先，我们创建了一个叫keycmd的FIFO缓冲区，它不是用来接收中断请求的，而是用来管理由任务A向键盘控制器发送数据的顺序的。如果有数据要发送到键盘控制器，首先会在这个keycmd中累积起来。

keycmd_wait变量，用来表示向键盘控制器发送数据的状态。当keycmd_wait的值为-1时，表示键盘控制器处于通常状态，可以发送指令；当值不为-1时，表示键盘控制器正在等待发送的数据，这时要发送的数据被保存在keycmd_wait变量中。

在for循环的开头，当keycmd中有数据，且keycmd_wait为-1时，向键盘发送1个字节的数据，在开始发送数据的同时，keycmd_wait变为非-1的值。随后，当从键盘接收到0xfa返回信息时，keycmd_wait恢复为-1，继续发送下一个数据。当从键盘接收到的返回信息为0xfe时，则重新发送刚才的数据。

在for循环前面，我们向键盘控制器设置了指示灯的状态，也许这一段是可有可无的，不过这样可以保证key_leds的值和实际的键盘指示灯状态绝对不会发生冲突的情况，因此保险起见还是设置了。

■■■■■

好了，我们来“make run”。本来想贴一张运行时的截图，不过这里发生变化的不是屏幕画面，而是键盘的指示灯，所以很遗憾，没有办法给大家展示这个令人感动的场面了。

嗯？不管怎么按CapsLock键，在笔者的Windows上都无法点亮指示灯，不过NumLock和ScrollLock却是正常的。哦，按Shift＋CapsLock指示灯就亮了，好奇怪啊，我们明明不是这样设计的呢。

由于实在无法理解这一现象，笔者又重新“make run”了harib14f，按下NumLock进行实验，咦？harib14f中也可以点亮NumLock指示灯呢1。看起来在这个QEMU模拟器中，键盘的指示灯貌似并不是由模拟器管理，而是由Windows管理的。

1 harib14f中还尚未实现对指示灯的控制。——译者注

于是我们在真机环境下再挑战一下。哇，这次完美了，harib14f无法改变键盘指示灯的状态，而harib14g则可以正常控制键盘指示灯。撒花！

好，今天就到这里吧，明天我们继续来做命令行窗口哦！





第18天　dir命令



控制光标闪烁（1）（harib15a）

控制光标闪烁（2）（harib15b）

对回车键的支持（harib15c）

对窗口滚动的支持（harib15d）

mem命令（harib15e）

cls命令（harib15f）

dir命令（harib15g）





1　控制光标闪烁（1）（harib15a）

我们已经完成了一个很像样的命令行窗口，看起来越来越有操作系统范儿了，真是可喜可贺。今天我们也要卯足干劲继续努力哦。

说起来，如果仔细观察一下Windows的话，就会发现和我们的“纸娃娃系统”有个不同的地方。在Windows中，只有可以接受键盘输入的窗口有光标闪烁，而其他的窗口中是不显示光标的。这样的设计貌似挺不错的，不然所有的窗口光标都闪烁的话眼睛要花掉了，那我们也来照猫画虎试试看吧。

怎样才能模仿出这个效果呢？判断是否按下Tab键的是HariMain，而控制光标闪烁的是HariMain和console_task。

■■■■■

首先，我们从比较简单的HariMain开始考虑。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x0f) { /* Tab键*/

if (key_to == 0) {

key_to = 1;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 0);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 1);

/*从此开始*/ cursor_c = -1; /* 不显示光标 */

/*到此结束*/ boxfill8(sht_win->buf, sht_win->bxsize, COL8_FFFFFF, cursor_x, 28, cursor_x + 7, 43);

} else {

key_to = 0;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 1);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 0);

/*这里！*/ cursor_c = COL8_000000; /*显示光标*/

}

sheet_refresh(sht_win, 0, 0, sht_win->bxsize, 21);

sheet_refresh(sht_cons, 0, 0, sht_cons->bxsize, 21);

}

（中略）

/*重新显示光标*/

/*从此开始*/ if (cursor_c >= 0) {

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

/*到此结束*/ }

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

/*从此开始*/ if (i != 0) {

timer_init(timer, &fifo, 0); /*下次置0 */

if (cursor_c >= 0) {

cursor_c = COL8_000000;

}

} else {

timer_init(timer, &fifo, 1); /*下次置1 */

if (cursor_c >= 0) {

cursor_c = COL8_FFFFFF;

}

}

timer_settime(timer, 50);

if (cursor_c >= 0) {

boxfill8(sht_win->buf, sht_win->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44);

/*到此结束*/ }

}

}

}

}




我们将按下Tab键时的处理以及光标闪烁的处理改写了一下，当不想显示光标的时候，使cursor_c为负值。

这样一来，任务A的窗口中光标就可以停止闪烁了，成功了！命令行窗口因为还没有改过，所以即便不是处于输入模式，光标也依然会闪烁。

“make run”一下，结果如下。



任务A的光标不见了哦！





2　控制光标闪烁（2）（harib15b）

接下来我们来实现稍微有点麻烦的命令行窗口中光标闪烁的控制。之所以说稍微有点麻烦，是因为命令行窗口是另外一个任务，无法从HariMain中改变它里面的变量。

那么应该怎样由HariMain（任务A）向console_task（命令行窗口）传递信息，告诉它“不需让光标闪烁”或者“需要让光标闪烁”呢？像传递按键编码一样，我们可以使用FIFO来实现。

我们先将光标开始闪烁定义为2，停止闪烁定义为3。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x0f) { /* Tab键*/

if (key_to == 0) {

key_to = 1;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 0);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 1);

cursor_c = -1; /*不显示光标*/

boxfill8(sht_win->buf, sht_win->bxsize, COL8_FFFFFF, cursor_x, 28,

cursor_x + 7, 43);

/*这里！ */ fifo32_put(&task_cons->fifo, 2); /*命令行窗口光标ON */



} else {

key_to = 0;

make_wtitle8(buf_win, sht_win->bxsize, "task_a", 1);

make_wtitle8(buf_cons, sht_cons->bxsize, "console", 0);

cursor_c = COL8_000000; /*显示光标*/

/*这里！ */ fifo32_put(&task_cons->fifo, 3); /*命令行窗口光标OFF */

}

sheet_refresh(sht_win, 0, 0, sht_win->bxsize, 21);

sheet_refresh(sht_cons, 0, 0, sht_cons->bxsize, 21);

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




HariMain这样改就差不多了。

■■■■■

下面该轮到console_task了。在启动的时候是任务A处于输入状态，因此我们在一开始就将cursor_c置为-1，剩下的部分和任务A大同小异。

本次的bootpack.c节选

void console_task(struct SHEET *sheet)

{

struct TIMER *timer;

struct TASK *task = task_now();

int i, fifobuf[128], cursor_x = 16, cursor_c = -1; /*这里！*/

char s[2];



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

task_sleep(task);

io_sti();

} else {

i = fifo32_get(&task->fifo);

io_sti();

if (i <= 1) { /*光标用定时器*/

/*从此开始*/ if (i != 0) {

timer_init(timer, &task->fifo, 0); /*下次置为0 */

if (cursor_c >= 0) {

cursor_c = COL8_FFFFFF;

}

} else {

timer_init(timer, &task->fifo, 1); /*下次置为1 */

if (cursor_c >= 0) {

cursor_c = COL8_000000;

}

/*到此结束*/ }

timer_settime(timer, 50);

}



if (i == 2) { /*光标ON */ /*从此开始*/

cursor_c = COL8_FFFFFF;

}

if (i == 3) { /*光标OFF */

boxfill8(sheet->buf, sheet->bxsize, COL8_000000, cursor_x, 28, cursor_x + 7, 43);

cursor_c = -1;

} /*到此结束*/

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

if (cursor_x > 16) {

/*用空白擦除光标后将光标前移一位 */

putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, " ", 1);

cursor_x -= 8;

}

} else {

/*一般字符*/

if (cursor_x < 240) {

/*显示一个字符之后将光标后移一位 */

s[0] = i - 256;

s[1] = 0;

putfonts8_asc_sht(sheet, cursor_x, 28, COL8_FFFFFF, COL8_000000, s, 1);

cursor_x += 8;

}

}

}

/*重新显示光标*/

if (cursor_c >= 0) { /*从此开始*/

boxfill8(sheet->buf, sheet->bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43);

} /*到此结束*/

sheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44);

}

}

}




■■■■■

还是一如既往来“make run”，不知道能不能成功呢。



命令行窗口的光标也不见了哦！

成功了！怎么样，是不是变得很酷呢？





3　对回车键的支持（harib15c）

既然大家精神振奋，那就让我们一鼓作气继续前进吧。

现在的命令行窗口里面，按下回车键是完全没有反应的，我们得让它对回车键进行响应才行。具体应该如何响应呢？暂且只要简单地换个行就好了。实际上，这里应该对输入的字符进行判断，然后执行相应的命令才对，不过一上来就搞这个也太难了点，笔者的讲解会跟不上的，因此我们还是先不管什么命令了，全部直接忽略掉吧。

■■■■■

我们先修改一下HariMain，使其在按下回车键时向命令行窗口发送10+256这个值。之所以用10，是因为用于控制换行的ASCII码就是10，我们在这里照搬一下而已。当然，如果你喜欢用别的值，也是完全没有问题的哦。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

/*从此开始*/ if (i == 256 + 0x1c) { /*回车键*/

if (key_to != 0) { /*发送至命令行窗口*/

fifo32_put(&task_cons->fifo, 10 + 256);

}

/*到此结束*/ }

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




然后我们还要修改用来接收数据的console_task。之前我们已经有了一个cursor_x变量，按照这个样子再创建一个cursor_y变量，当按下回车键时，将cursor_y加1就可以了。

本次的bootpack.c节选

void console_task(struct SHEET *sheet)

{

struct TIMER *timer;

struct TASK *task = task_now();

int i, fifobuf[128], cursor_x = 16, cursor_y = 28, cursor_c = -1; /*这里！*/

（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

i = fifo32_get(&task->fifo);

io_sti();

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/

if (i == 8 + 256) {

/*退格键*/

（中略）

/*从此开始*/ } else if (i == 10 + 256) {

/*回车键*/

if (cursor_y < 28 + 112) {

/*用空格将光标擦除*/

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, " ", 1);

cursor_y += 16;

/*显示提示符*/

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, ">", 1);

cursor_x = 16;

/*到此结束*/ }

} else {

/*一般字符*/

（中略）

}

}

/*重新显示光标*/

if (cursor_c >= 0) {

/*这里！ */ boxfill8(sheet->buf, sheet->bxsize, cursor_c, cursor_x, cursor_y, cursor_x + 7, cursor_y + 15);

}

sheet_refresh(sheet, cursor_x, cursor_y, cursor_x + 8, cursor_y + 16); /*这里！*/

}

}

}




好，改成这样差不多了，到底能不能成功呢？我们还是照常“make run”一下。



换行成功了哦！

我们又成功了，耶！





4　对窗口滚动的支持（harib15d）

在harib15c中，到最后一行的时候回车键就不管用了，原因很简单，因为下面没有更多的行了，这可不像个操作系统的样子啊。在别的操作系统中遇到这样的情况会怎样处理呢？窗口应该会向下滚动才对。那么我们来让“纸娃娃系统”也支持窗口滚动吧。

要实现窗口滚动，只要将所有的像素向上移动一行就可以了。元素移动这种操作大家应该已经习惯了吧？移动完成之后，还需要将最下面一行涂黑，否则上面一行的内容就会残留在那里。

本次的bootpack.c节选

void console_task(struct SHEET *sheet)

{

（中略）

int x, y;



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

（中略）

} else if (i == 10 + 256) {

/* Enter */

/*用空格将光标擦除*/

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, " ", 1);

/*从此开始 */ if (cursor_y < 28 + 112) {

cursor_y += 16; /*换行*/

} else {

/*滚动*/

for (y = 28; y < 28 + 112; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = sheet->buf[x + (y + 16) *

sheet->bxsize];

}

}

for (y = 28 + 112; y < 28 + 128; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = COL8_000000;

}

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

}

/*显示提示符*/

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, ">", 1);

/*到此为止*/ cursor_x = 16;

} else {

/*一般字符*/

（中略）

}

}

（中略）

}

}

}




■■■■■

貌似完工了，测试一下，“make run”。



噢噢！窗口滚动了哟！

我们又成功了。一切顺利呀，如此顺利到底是好还是不好呢……当然是再好不过啦！





5　mem命令（harib15e）

之前我们已经成功实现了屏幕滚动，现在该是到了让它执行命令的时候了。不过这值得纪念的第一个命令到底该花落谁家呢？纠结了一番之后，还是决定来做mem命令吧。

mem命令就是memory的缩写，也就是用来显示内存使用情况的命令。画面上虽然已经显示了剩余内存，不过现在被命令行窗口挡住看不见了。因此我们就不让它继续显示了，改成用命令来查询好了。

而且，这种功能对于一个命令来说也是很容易实现的，比起之前在背景上面显示剩余内存来说，还是用命令来查询比较像个操作系统的样子。既然如此，那我们干脆顺便把按键编码、鼠标坐标的显示也一起去掉吧。

■■■■■

既然方针已定，那就开工吧。首先从去掉多余的显示开始，这个非常容易，我们给这次去掉的行加上了“//”注释标记。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

// sprintf(s, "(%3d, %3d)", mx, my);

// putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10);

// sprintf(s, "memory %dMB free : %dKB",

// memtotal / (1024 * 1024), memman_total(memman) / 1024);

// putfonts8_asc_sht(sht_back, 0, 32, COL8_FFFFFF, COL8_008484, s, 40);



（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据 */

// sprintf(s, "%02X", i - 256);

// putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

// /*数据已达到3个字节，显示*/

// sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);

// if ((mdec.btn & 0x01) != 0) {

// s[1] = 'L';

// }

// if ((mdec.btn & 0x02) != 0) {

// s[3] = 'R';

// }

// if ((mdec.btn & 0x04) != 0) {

// s[2] = 'C';

// }

// putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15);

（中略）

// sprintf(s, "(%3d, %3d)", mx, my);

// putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10);

（中略）

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




噢噢，代码居然减少了21行，真不错呢。不过接下来我们要实现mem命令，行数又会变多啦。

■■■■■

增加了mem命令的部分后，就变成了这样。

本次的bootpack.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

char s[30], cmdline[30]; /*这里！*/

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR; /*这里！ */



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

（中略）

} else if (i == 10 + 256) {

/*回车键*/

/*将光标用空格擦除后换行*/

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, " ", 1);

/*从此开始 */ cmdline[cursor_x / 8 - 2] = 0;

cursor_y = cons_newline(cursor_y, sheet);

/*执行命令*/

if (cmdline[0] == 'm' && cmdline[1] == 'e' && cmdline[2] == 'm' && cmdline[3] == 0) {

/* mem命令*/

sprintf(s, "total %dMB", memtotal / (1024 * 1024));

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, s, 30);

cursor_y = cons_newline(cursor_y, sheet);

sprintf(s, "free %dKB", memman_total(memman) / 1024);

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, s, 30);

cursor_y = cons_newline(cursor_y, sheet);

cursor_y = cons_newline(cursor_y, sheet);

} else if (cmdline[0] != 0) {

/*不是命令，也不是空行 */

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, "Bad

command.", 12);

cursor_y = cons_newline(cursor_y, sheet);

cursor_y = cons_newline(cursor_y, sheet);

/*到此结束*/ }

/*显示提示符*/

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, ">", 1);

cursor_x = 16;

} else {

/*一般字符*/

if (cursor_x < 240) {

/*显示一个字符之后将光标后移一位 */

s[0] = i - 256;

s[1] = 0;

/*这里！ */ cmdline[cursor_x / 8 - 2] = i - 256;

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, s,1);

cursor_x += 8;

}

}

}

（中略）

}

}

}




介绍一下重点。首先我们添加了memtotal和memman两个变量，它们是执行mem命令所必需的。关于memtotal，我们采用和sheet相同的方法从HariMain传递过来，因此我们还需要改写一下HariMain。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/* sht_cons */

sht_cons = sheet_alloc(shtctl);

（中略）

task_cons->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12; /*这里！ */

（中略）

*((int *) (task_cons->tss.esp + 4)) = (int) sht_cons;

*((int *) (task_cons->tss.esp + 8)) = memtotal; /*这里！ */

（中略）

}




回来继续讲解console_task，我们还添加了一个cmdline变量，也就是“命令行”（command line）的缩写。这个变量用来记录通过键盘输入的内容，在“键盘数据”处理的“一般字符”部分，将输入的内容顺次累积起来。

然后，处理回车键输入的部分我们已经完全改写了。在这里出现的cons_newline是一个用来换行的函数，当到达最后一行的时候还会自动滚动。如果把换行处理直接写在程序中会导致代码非常难读，因此我们把它做成了一个单独的函数，函数的内容如下。

本次的bootpack.c节选

int cons_newline(int cursor_y, struct SHEET *sheet)

{

int x, y;

if (cursor_y < 28 + 112) {

cursor_y += 16; /*换行*/

} else {

/*滚动*/

for (y = 28; y < 28 + 112; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = sheet->buf[x + (y + 16) * sheet->bxsize];

}

}

for (y = 28 + 112; y < 28 + 128; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = COL8_000000;

}

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

}

return cursor_y;

}




这里应该没有什么难点，我们继续回到console_task。

当按下回车键时，换行后程序会读取cmdline的值，分析所输入的内容。如果输入的内容为“mem”，则执行mem命令，显示内存的相关信息；如不为“mem”，程序无法理解这个命令，则显示“Bad command”错误信息。不过，在什么都不输入的情况下按回车键不会显示错误信息，也不会执行什么操作。

我们的系统能够出现错误信息了，看上去是不是超有操作系统范儿呢？笔者认为错误信息特别有操作系统的感觉，于是就给加上去啦（笑）。

讲解到此结束。

■■■■■

我们来运行一下，“make run”，然后输入一些东西试试看。结果如下。



哇，好酷！

天啊，这实在是酷毙了！操作系统的感觉大幅上升，真是越来越有干劲了！





6　cls命令（harib15f）

上来先问个问题，大家知道cls命令吗？啥？不知道？那真是太遗憾啦。好吧，大家可以在Windows的命令行窗口中执行cls命令试试看。明白了？没错，这个命令的作用是清除屏幕上的内容，也就是“clear screen”（清屏）的缩写。顺便补充个小知识，在Linux中清屏命令是“clear”。

下面我们就要给“纸娃娃系统”也增加cls这个命令。可能有人会说，这种无聊的命令做了有啥用？别说那么让人伤心的话嘛，好歹这也是笔者的个人喜好啦（笑）。

于是，只要像mem命令一样，把cls命令也加进去就好了，不过在这里我们要介绍一个新的小技巧。

■■■■■

在harib15e中，为了读取输入的命令内容，我们是这样写的：

if (cmdline[0] == 'm' && cmdline[1] == 'e' && cmdline[2] == 'm' && cmdline[3] == 0) {




这种写法相当差劲，而且代码也很难读。如果我们把cmdline这么长的变量名简化成c试试 看呢？

if (c[0] == 'm' && c[1] == 'e' && c[2] == 'm' && c[3] == 0) {




这个好像不错，代码变短了点。

其实我们还可以写成这样，看下面的代码。

if (strcmp(cmdline, "mem") == 0) {




怎么样，是不是特别棒？如果还不明白这样写的好处，可以想象一下如果要做一个像“haribote”这样8个字符的命令的话要怎么写呢？就知道有人懒得想象，笔者帮你写出来吧。

if (c[0] == 'h' && c[1] == 'a' && c[2] == 'r' && c[3] == 'i' && c[4] == 'b' &&

c[5] == 'o' && c[6] == 't' && c[7] == 'e' && c[8] == 0) {




这样的代码，不觉得很糟糕吗？这样写的话，万一不小心颠倒了“b”和“i”的位置，命令从“haribote”变成了“harbiote”，可能你都完全发现不了，简直是难读到了极点。不过，只要使用strcmp，即便变量名还是cmdline那么长，也可以写成这样：

if (strcmp(cmdline, "haribote") == 0) {




这么短的代码就搞定了，你看，好处显而易见吧？

strcmp这个函数，只要声明#include 即可使用，因此在bootpack.c中我们也要用它。

■■■■■

于是，在添加了cls命令之后，bootpack.c就变成了下面这样。

本次的bootpack.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

（中略）

} else if (i == 10 + 256) {

/*回车键*/

（中略）

/*这里！ */ if (strcmp(cmdline, "mem") == 0) {

/* mem命令*/

（中略）

/*从此开始 */ } else if (strcmp(cmdline, "cls") == 0) {

/* cls命令*/

for (y = 28; y < 28 + 128; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = COL8_000000;

}

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

/*到此结束*/ cursor_y = 28;

} else if (cmdline[0] != 0) {

/*不是命令，也不是空行 */

（中略）

}

（中略）

} else {

（中略）

}

}

（中略）

}

}

}




顺利写完了，我们来“make run”，然后执行cls命令试试看。哇，真的清除掉了！



可能有人没看明白，这是执行了cls命令之后的样子哦

照这样下去，我们已经可以随意增加更多的命令了呢。你要是特别中意哪个命令，一定要添加进去玩玩看哦。如果成功的话，干劲会更足呢。





7　dir命令（harib15g）

好了，现在我们已经可以自己来尽情添加命令了，不过作为一个操作系统，我们的目标还是制作可执行文件（比如.exe）来让它运行。笔者很想马上进入这个话题，不过在此之前，我们先来制作一个显示磁盘内文件名称的命令吧。通过这个命令的制作，我们可以学习对磁盘中文件信息的操作方法，为明天制作可执行文件打好基础。

那么dir命令到底是干什么用的呢？大家在Windows的命令行窗口中输入“dir”执行一下就明白了，除了会显示文件名，还会显示文件的日期和大小。在Linux中与dir对应的命令是ls。接下来我们就来实现这个命令的功能。

■■■■■

怎样才能让系统执行dir命令呢？要显示文件名等信息，我们需要读取磁盘的内容，这得借助BIOS的帮助。当然，不通过BIOS来读写磁盘的方法也是有的，但是较难实现，所以这里就不介绍了。

不过，现在“纸娃娃系统”正处于32位模式，想使用BIOS也不行。BIOS不能用，不用BIOS读取磁盘的方法又不讲，这样的话你要让我怎么来读磁盘啊！其实大家不用担心。没错，其实在进入32位模式之前，我们不是已经从磁盘读了很多内容了吗？有10个柱面那么多呢！实在想不起来的话，请再翻到3.4节看一看吧。

说句题外话，笔者也重新读了读3.4节，哇，真的好怀念呢。仅仅过了15天，差异竟然如此之大！不，应该说是进步如此之快吧～（做感慨状）。

那么已经读出来的这些数据，存放在内存中的什么地方呢？在8.5节中写得很清楚，是0x00100000～0x00267fff。其中存放文件名的地方又在哪里呢？其实我们也已经说过了，不过大家可能都不记得了吧，参考3.5节从0柱面、0磁头、1扇区开始的0x002600之后，也就是内存地址的0x00102600开始写入。

■■■■■

这些数据的具体内容，在这里需要详细讲解一下。作为试验，我们在磁盘映像中加入了haribote.sys、ipl10.nas和make.bat这3个文件（加入其他文件也可以，这里暂以这3个文件为例）我们对Makefile稍作修改。

本次的Makefile节选

haribote.img : ipl10.bin haribote.sys Makefile

$(EDIMG) imgin:../z_tools/fdimg0at.tek \

wbinimg src:ipl10.bin len:512 from:0 to:0 \

copy from:haribote.sys to:@: \

copy from:ipl10.nas to:@: \

copy from:make.bat to:@: \

imgout:haribote.img




然后我们make一下，查看磁盘映像中0x002600字节以后的部分，内容如下。

磁盘映像的内容

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

002600 48 41 52 49 42 4F 54 45 53 59 53 20 00 00 00 00 HARIBOTESYS ....

002610 00 00 00 00 00 00 18 74 FF 32 02 00 68 6B 00 00 .......t.2..hk..

002620 49 50 4C 31 30 20 20 20 4E 41 53 20 00 00 00 00 IPL10 NAS ....

002630 00 00 00 00 00 00 59 7A 42 41 38 00 95 0B 00 00 ......YzB58.....

002640 4D 41 4B 45 20 20 20 20 42 41 54 20 00 00 00 00 MAKE BAT ....

002650 00 00 00 00 00 00 F6 10 81 30 3E 00 2E 00 00 00 .........0>.....

002660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................




看起来这里的内容是以32个字节为单位循环的，这32个字节的结构如下。

struct FILEINFO {

unsigned char name[8], ext[3], type;

char reserve[10];

unsigned short time, date, clustno;

unsigned int size;

};




开始的8个字节是文件名。文件名不足8个字节时，后面用空格补足。文件名超过8个字节的情况比较复杂，我们在这里先只考虑不超过8个字节的情况吧，一上来就挑战高难度的话，很容易产生挫败感呢。再仔细观察一下，我们发现所有的文件名都是大写的。

如果文件名的第一个字节为0xe5，代表这个文件已经被删除了；文件名第一个字节为0x00，代表这一段不包含任何文件名信息。从磁盘映像的0x004200就开始存放文件haribote.sys了，因此文件信息最多可以存放224个。

接下来3个字节是扩展名，和文件名一样，不足3个字节时用空格补足，如果文件没有扩展名，则这3个字节都用空格补足。扩展名和文件名一样，也全部使用了大写字母。

后面1个字节存放文件的属性信息。我们这3个文件的属性都是0x20。一般的文件不是0x20就是0x00，至于其他的值，我们来看下面的说明。

0x01……只读文件（不可写入）

0x02……隐藏文件

0x04……系统文件

0x08……非文件信息（比如磁盘名称等）

0x10……目录

当一个文件既是只读文件又是隐藏文件时，将上面的对应值加算即可，即0x03。

到此为止的总计12个字节，基本上存放的都是字符编码信息，不会出现负数，因此在数据结构声明中使用unsigned类型。

接下来的10个字节为保留，也就是说，是为了将来可能会保存更多的文件信息而预留的，在我们的磁盘映像中都是0x00。话说，这个磁盘格式是由Windows的开发商微软公司定义的，因此，这段保留区域以后要如何使用，也是由微软公司来决定的。其他人要自行定义的话也可以，只不过将来可能会和Windows产生不兼容的问题。

下面2个字节为WORD整数，存放文件的时间。因此即便文件的内容都一样，这里大家看到的数值也可能是因人而异的。再下面2个字节存放文件的日期。这些数值虽然怎么看都不像是时间和日期，但只要用微软公司的公式计算一下，就可以转换为时、分、秒等信息了。

接下来的2个字节也是WORD整数，代表这个文件的内容从磁盘上的哪个扇区开始存放。变量名clustno本来是“簇号”（cluster number）的缩写，“簇”这个词是微软的专有名词，在这里我们先暂且理解为和“扇区”是一码事就好了。

最后的4个字节为DWORD整数，存放文件的大小。

■■■■■

有了上面这些信息，感觉dir命令应该可以实现了，我们来做做看吧。

本次的bootpack.h节选

/* asmhead.nas */

struct BOOTINFO { /* 0x0ff0-0x0fff */

（中略）

};

#define ADR_BOOTINFO 0x00000ff0

#define ADR_DISKIMG 0x00100000 /*这里！ */




本次的bootpack.c节选

struct FILEINFO {

unsigned char name[8], ext[3], type;

char reserve[10];

unsigned short time, date, clustno;

unsigned int size;

};



void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

struct FILEINFO *finfo = (struct FILEINFO *) (ADR_DISKIMG + 0x002600); /*这里！*/



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

/*退格键*/

（中略）

} else if (i == 10 + 256) {

/*回车键*/

（中略）

/*执行命令*/

if (strcmp(cmdline, "mem") == 0) {

/* mem命令*/

（中略）

} else if (strcmp(cmdline, "cls") == 0) {

/* cls命令*/

（中略）

/*从此开始*/ } else if (strcmp(cmdline, "dir") == 0) {

/* dir命令 */

for (x = 0; x < 224; x++) {

if (finfo[x].name[0] == 0x00) {

break;

}

if (finfo[x].name[0] != 0xe5) {

if ((finfo[x].type & 0x18) == 0) {

sprintf(s, "filename.ext %7d", finfo[x].size);

for (y = 0; y < 8; y++) {

s[y] = finfo[x].name[y];

}

s[ 9] = finfo[x].ext[0];

s[10] = finfo[x].ext[1];

s[11] = finfo[x].ext[2];

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF,

COL8_000000, s, 30);

cursor_y = cons_newline(cursor_y, sheet);

}

}

}

/*到此结束*/ cursor_y = cons_newline(cursor_y, sheet);



} else if (cmdline[0] != 0) {

/*不是命令，也不是空行*/

（中略）

}

（中略）

} else {

/*一般字符*/

（中略）

}

}

（中略）

}

}

}




先大概写成这个样子，可以显示文件名、扩展名和文件大小。到底能不能成功呢？我们来“make run”，然后“dir”。



哇，出来啦！

哇，显示出来了哦！话说回来，不显示出来的话才让人抓狂，运行成功了真的很开心呢。

对了，如果你不喜欢Windows风格的dir命令，觉得Linux风格的ls命令更好的话，没问题，当然可以把这个命令给改成ls哦。至于应该修改哪里嘛，对于已经读到这里的人，应该不用再解释了吧？

好了，今天就到这里，明天再见啦。





第19天　应用程序



type命令（harib16a）

type命令改良（harib16b）

对FAT的支持（harib16c）

代码整理（harib16d）

第一个应用程序（harib16e）





1　type命令（harib16a）

大家好。笔者觉得“纸娃娃系统”最近越来越有操作系统的样子了，不知道大家是不是也有同感呢？今天我们的系统即将可以运行应用程序了哦，很激动人心吧！

昨天经过我们的努力，终于可以显示磁盘中的文件名和文件大小信息了，不过，这离运行应用程序还差得远。因此，接下来我们要讲解一下如何读取文件本身的内容。

在Windows的命令行中，有一个叫做type的命令，输入“type 文件名”就会显示出文件的内容。在Linux中有一个cat命令，功能基本上是一样的。

可能有人还不知道type命令，我们来演示一下。

也就是说，我们要在“纸娃娃系统”上也实现这样的功能。

■■■■■

那么到底应该如何读取文件呢？我们还是从观察磁盘映像入手寻找线索吧。

首先，我们再回头看看昨天讲过的文件信息的部分。这是harib15g的磁盘映像，和昨天看到的只有少许不同，没关系，我们就当是复习了。



运行type Makefile的结果

磁盘映像的内容

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

002600 48 41 52 49 42 4F 54 45 53 59 53 20 00 00 00 00 HARIBOTESYS ....

002610 00 00 00 00 00 00 18 74 FF 32 02 00 70 6C 00 00 .......t.2..pl..

002620 49 50 4C 31 30 20 20 20 4E 41 53 20 00 00 00 00 IPL10 NAS ....

002630 00 00 00 00 00 00 59 7A 42 35 39 00 95 0B 00 00 ......YzB59.....

002640 4D 41 4B 45 20 20 20 20 42 41 54 20 00 00 00 00 MAKE BAT ....

002650 00 00 00 00 00 00 F6 10 81 30 3F 00 2E 00 00 00 .........0?.....

002660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................




这里面有一个32个字节的数据结构：

struct FILEINFO {

unsigned char name[8], ext[3], type;

char reserve[10];

unsigned short time, date, clustno;

unsigned int size;

};




其中clustno这个成员，代表文件从磁盘上的哪个扇区开始存放，我们只把这个部分写出来看看。

HARIBOTE.SYS 02 00 → clustno = 0x0002

IPL10.NAS 39 00 → clustno = 0x0039

MAKE.BAT 3F 00 → clustno = 0x003f




原来如此……说啥呢，其实完全没看懂吧（苦笑）。好吧，接下来我们就来找一找文件的内容到底存放在磁盘上的哪个扇区。首先来看第一个文件HARIBOTE.SYS的位置，这个很简单，在0x004200。咦，你怎么知道的？其实看一下3.4节就明白了，这可不是超能力哟。

也就是说，貌似clustno = 0x0002就代表0x004200的意思，嗯嗯，我们再来看看其他的文件。

IPL10.NAS在哪里呢？我们在磁盘映像中找找看。HARIBOTE.SYS的大小差不多27KB，估摸着也就是在它27KB之后的位置附近吧。你看，找到了！在0x00b000这个位置。



0x00b000附近的样子

MAKE.BAT我们也找到了，在0x00bc00这个位置。



0x00bc00附近的样子

于是，我们把上面搜集到的线索总结一下。

clustno = 0x0002 → 0x004200

clustno = 0x0039 → 0x00b000

clustno = 0x003f → 0x00bc00




唔，这个里面有什么规律呢？首先，我们从0x0039和0x003f开始看，把它们相减，0x3f – 0x39 = 6，也就是说，culstno每增加6，磁盘映像中的位置就增加0xc00个字节，将0xc00除以6得到0x200，即512个字节。

如果能马上想到512个字节代表什么，那你真是个天才！没错，1个扇区的容量正好是512个字节。也就是说，clustno的值相差1，在磁盘映像中文件的位置就相差1个扇区，即512个字节。如果以clustno = 0x0002为起点出发倒推的话，笔者认为clustno = 0x0000应该就相当于0x003e00这个位置。

如果当真如此，那我们就可以总结出下面这个公式。

磁盘映像中的地址 = clustno * 512 + 0x003e00


那么这个公式是否正确呢？我们来试算一下。

0x0002 * 512 + 0x003e00 = 0x000400 + 0x003e00 = 0x004200（正确）

0x0039 * 512 + 0x003e00 = 0x007200 + 0x003e00 = 0x00b000（正确）

0x003f * 512 + 0x003e00 = 0x007e00 + 0x003e00 = 0x00bc00（正确）

哇，成功了！看来这个公式可行。

■■■■■

有了上面的知识，接下来只要将文件的内容逐字节读取出来并显示在屏幕上就可以了。好，我们来写代码了哦。

本次的bootpack.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

char s[30], cmdline[30], *p; /*这里！ */

（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

（中略）

} else if (i == 10 + 256) {

/* Enter */

（中略）

if (strcmp(cmdline, "mem") == 0) {

（中略）

} else if (strcmp(cmdline, "cls") == 0) {

（中略）

} else if (strcmp(cmdline, "dir") == 0) {

（中略）

/*从此开始*/ } else if (cmdline[0] == 't' && cmdline[1] == 'y' && cmdline[2] == 'p' && cmdline[3] == 'e' && cmdline[4] == ' ') {

/* type命令*/

/*准备文件名*/



for (y = 0; y < 11; y++) {

s[y] = ' ';

}

y = 0;

for (x = 5; y < 11 && cmdline[x] != 0; x++) {

if (cmdline[x] == '.' && y <= 8) {

y = 8;

} else {

s[y] = cmdline[x];

if ('a' <= s[y] && s[y] <= 'z') {

/*将小写字母转换成大写字母 */

s[y] -= 0x20;

}

y++;

}

}

/*寻找文件*/

for (x = 0; x < 224; ) {

if (finfo[x].name[0] == 0x00) {

break;

}

if ((finfo[x].type & 0x18) == 0) {

for (y = 0; y < 11; y++) {

if (finfo[x].name[y] != s[y]) {

goto type_next_file;

}

}

break; /*找到文件*/

}

type_next_file:

x++;

}

if (x < 224 && finfo[x].name[0] != 0x00) {

/*找到文件的情况*/

y = finfo[x].size;

p = (char *) (finfo[x].clustno * 512 + 0x003e00 + ADR_DISKIMG);

cursor_x = 8;

for (x = 0; x < y; x++) {

/*逐字输出*/

s[0] = p[x];

s[1] = 0;

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF,

COL8_000000, s, 1);

cursor_x += 8;

if (cursor_x == 8 + 240) { /*到达最右端后换行*/

cursor_x = 8;

cursor_y = cons_newline(cursor_y, sheet);

}

}

} else {

/*没有找到文件的情况*/

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, "File not found.", 15);

cursor_y = cons_newline(cursor_y, sheet);

}

/*到此结束*/ cursor_y = cons_newline(cursor_y, sheet);

} else if (cmdline[0] != 0) {

（中略）

}

（中略）

} else {

（中略）

}

}

（中略）

}

}

}




■■■■■

这次的代码比较长，我们还是来稍微讲解一下。

首先看type命令那一段开头的地方，我们这次没有使用strcmp（cmdline,“type”），而是用了之前那种很难读的写法。其实笔者也想用strcmp来着，不过在这里用strcmp的话，当输入“type make.bat”时，就会输出“Bad command.”了，这可不行啊。这是由于strcmp会比较字符串的长度，因此仅开头5个字符一致是不会被判定相等的。

接下来的程序中（“准备文件名”的地方），首先将s[0～10]这11个字节用空格的字符编码填充，然后读取cmdline[5～]并复制到s[0～]，在复制的同时，将其中的小写字母转换为大写字母。随后，当遇到句点时，则可以断定接下来的部分为扩展名，于是将复制的目标改为s[8～]。经过这样的转换，我们就得到了和磁盘内格式相同的文件名。

“寻找文件”这一段中，我们在磁盘中寻找与所输入的文件名相符的文件。如果成功找到指定文件，则用break跳出for循环；如果找不到，则会在x到达224或者finfo[x].name[0]为0x00时结束循环。

因此，当for循环结束后，我们就可以判断出到底是找到文件跳出for循环的，还是没有找到文件而结束for循环的，从而决定是显示指定的文件内容，还是显示“File not found.”的错误信息。

■■■■■

我们来“make run”，然后“type make.bat”。



type make.bat

哇，运行成功，撒花。显示出来的内容是不是正确呢？我们可以用文本编辑器打开make.bat来确认一下，果然是一模一样呢。

如果我们输入“type haribote.sys”会怎么样呢？程序会将机器语言的文件强行用文本方式显示出来，于是就变成下面这样的乱码。



type haribote.sys的话……

玩得一时兴起，我们再来试试看“type ipl10.nas”，笔者认为一定会显示出ipl10的程序源代码，但结果却显示出下面这样乱七八糟的字符。



type ipl10.nas

为……为啥会这样？不过我们仔细看看的话，其中还是有“load error”、RESB、DB之类正确显示的部分嘛。

哦，对了！我们忘记处理换行和制表符的字符编码了，怪不得会变成这个样子呢。好，接下来我们就来搞定它。





2　type命令改良（harib16b）

下面我们就来实现对换行的支持吧。这次需要支持的特殊字符编码如下。

0x09……制表符：显示空格直到x被4整除为止

0x0a……换行符：换行

0x0d……回车符：忽略

针对上面几个特殊字符，我们来详细讲解一下。

制表符原本是用来对齐字符显示位置的，因此“遇到制表符就显示4个空格”这种做法是不对的，制表符的功能应该是在当前位置到下一个制表位之间填充空格。这里我们将制表位设定在第0、4、8、12……个字符这样4的倍数的位置（这是笔者的偏好），而在Windows等环境中，制表位则是8的倍数。

再介绍个小知识，我们这里所说的制表符也称为水平制表符（horizonal tab），因为对齐字符位置是在水平方向上移动。相对的，还有一种垂直制表符（vertical tab），不过因为这次我们遇不到（其实在一般的文本文件中也不会出现），所以大家可以先不用理会它了。

换行符其实也有一段有趣的身世。在Windows中换行的字符编码为“0x0d 0x0a”两个字节，而Linux中只有“0x0a”一个字节。也就是说，同样一篇文章，在Windows中保存下来文件尺寸会比Linux中要大。那么为什么Windows要用两个字节的换行符呢？我们来追本溯源一下吧。

字符编码0x0a原本代表折行（line feed）的意思，即只是移动到下一行。因此，如果只用0x0a作为换行符的，以前有些打印机就会印成这个样子：

one

two

three

four




而另一方面，0x0d，也就是回车符的文字编码，代表“让打印头（或者打字机的辊筒）回到行首”的意思，因此才被称为“回车”（carriage return）。回车符其实不会换行，而只是让文字显示的位置回到最左端。

因此，如果使用“0x0d 0x0a”两个字节作为换行符的话，即便是最古老的打印机，也会正确打印成下面这样。

one

two

three

four




正是因为如此，Windows中的换行符编码才会被规定为“0x0d 0x0a”吧。

另外，如果反过来利用0x0d的这一性质，在以前的打印机上可以实现文字的叠加打印，不过现在的打印机上会如何，那就不得而知了。

那么我们的“纸娃娃系统”该怎么办呢？我们就先将0x0a作为换行加回车，将0x0d忽略掉吧。因为这样一来，无论是在Windows中还是Linux中所保存的文件，都可以正确显示出来。

■■■■■

所以我们仅将type命令的字符显示部分进行一些改写。

本次的bootpack.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

（中略）

} else if (i == 10 + 256) {

/*回车键*/

（中略）

/*执行命令*/

if (strcmp(cmdline, "mem") == 0) {

（中略）

} else if (strcmp(cmdline, "cls") == 0) {

（中略）

} else if (strcmp(cmdline, "dir") == 0) {

（中略）

/*这里！*/ } else if (strncmp(cmdline, "type ", 5) == 0) {

/* type命令*/

（中略）

if (x < 224 && finfo[x].name[0] != 0x00) {

/*找到文件的情况*/

（中略）

for (x = 0; x < y; x++) {



/*逐字输出*/

s[0] = p[x];

s[1] = 0;

/*从此开始*/ if (s[0] == 0x09) { /*制表符*/

for (;;) {

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF, COL8_000000, " ", 1);

cursor_x += 8;

if (cursor_x == 8 + 240) {

cursor_x = 8;

cursor_y = cons_newline(cursor_y, sheet);

}

if (((cursor_x - 8) & 0x1f) == 0) {

break; /*被32整除则break */

}

}

} else if (s[0] == 0x0a) { /*换行*/

cursor_x = 8;

cursor_y = cons_newline(cursor_y, sheet);

} else if (s[0] == 0x0d) { /*回车*/

/*这里暂且不进行任何操作*/

} else { /*一般字符*/

putfonts8_asc_sht(sheet, cursor_x, cursor_y, COL8_FFFFFF,

COL8_000000, s, 1);

cursor_x += 8;

if (cursor_x == 8 + 240) {

cursor_x = 8;

cursor_y = cons_newline(cursor_y, sheet);

}

/*到此结束*/ }

}

} else {

/*没有找到文件的情况*/

（中略）

}

cursor_y = cons_newline(cursor_y, sheet);

} else if (cmdline[0] != 0) {

（中略）

}

（中略）

} else {

（中略）

}

}

（中略）

}

}

}




我们来讲解一下吧。首先是这里：

} else if (strncmp(cmdline, "type ", 5) == 0) {




这个部分我们前面因为不能用strcmp，而只好写成了很难看的if语句，这次我们使用strncmp这个函数，又把代码给改整洁了。最后的5这个参数，代表“只比较前面5个字符，后面的部分即便不一致，也要判定为一致”的意思。这样一来，这里的代码就干净多了！

接下来是制表符的处理，这个貌似有点难懂。

if (((cursor_x - 8) & 0x1f) == 0) {

break; /* 被32整除则break */

}




首先，为什么要将cursor_x减8呢？因为命令行窗口的边框有8个像素，所以要把那部分给去掉。然后，1个字符的宽度是8个像素，每个制表位相隔4个字符，也就是说，cursor_x – 8应该为0、32、64、96、128、160、192、224其中之一，即被32除后余数为0即可。

这里我们回想一下笔者在10.1节中所讲过的内容。32这个数字对于2进制来说是一个“很整的数”，因此用&就可以计算余数了——说起来我们还真是很走运嘛。

换行处理的部分没有什么难度，那我们的讲解就到这里吧。

■■■■■

好，来“make run”了哦，心情好紧张啊。按Tab键切换到命令行窗口，输入“type ipl10.nas”。



这次显示出来了哦！

虽然里面的日文部分还是乱码，不过剩下的字符都已经能够正常显示了。太好啦，成功了！

仔细看看程序，我们发现bootpack.c越来越长，console_task也很长了，不过整理起来太麻烦，所以我们就暂时让它再乱一会阵子吧，实在不好意思。

话说，观察像ipl10.nas这种比较长的文件，会发现全部显示出来需要花上一段时间（尤其在模拟器环境中感觉很明显），这时我们可以按Tab键切换到task_a的窗口中输入字符试试看。也就是说，在命令执行的过程中，系统还是可以进行其他的工作。看上去这应该是理所当然的，因为我们已经实现了多任务嘛。不过一个自制的操作系统能达到这样的程度，大家不觉得很开心吗？笔者心里已经乐开花了哟。





3　对FAT的支持（harib16c）

笔者在这里得先跟大家道个歉，其实这个type命令是有问题的，有时候会无法正确显示文件内容。现在的type命令，肯定可以正确显示文件开头的512个字节的内容，但是如果遇到大于512个字节的文件，中间可能就会突然显示出其他文件的内容。

因此，我们需要解决这个问题。

按照Windows管理磁盘的方法，保存大于512字节的文件时，有时候并不是存入连续的扇区中，虽然这种情况并不算多。怎么样，吓一跳吧？如果中了这一招的话，harib16b可就应付不了了。

其实，对于文件的下一段存放在哪里，在磁盘中是有记录的，我们只要分析这个记录，就可以正确读取文件内容了。这个记录在哪里呢？它位于从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200～0x0013ff。这个记录被称为FAT，是“file allocation table”的缩写，翻译过来叫作“文件分配表”（即记录文件在磁盘中存放位置的表）。

补充一下，文件在磁盘中没有存放在连续的扇区，这种情况被称为“磁盘碎片”。Windows中的磁盘整理工具，就是用来将扇区内容重新排列，以减少磁盘碎片的程序。

■■■■■

再往后光靠文字已经很难讲明白了，我们还是先看看FAT的样子吧。

这就是FAT

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

000200 F0 FF FF 03 40 00 05 60 00 70 80 00 09 A0 00 0B ....@..`........

000210 C0 00 0D E0 00 0F 00 01 11 20 01 13 40 01 15 60 ......... ..@..`

000220 01 17 80 01 19 A0 01 1B C0 01 1D E0 01 1F 00 02 ................

000230 21 20 02 23 40 02 25 60 02 27 80 02 29 A0 02 2B .......&.29.....

000240 C0 02 2D E0 02 2F 00 03 31 20 03 33 40 03 35 60 ..-../..1 .3@5.`

000250 03 37 80 03 39 F0 FF 3B C0 03 3D E0 03 3F F0 FF .7..9..;..=..?..

000260 FF 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................

000270 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................




这就是harib16b磁盘映像中的FAT，不过这个FAT使用了微软公司设计的算法进行压缩，因此我们无法直接看懂里面的内容，需要先用下面的方法进行解压缩（看了下面的讲解，可能有人会想，这哪里算是压缩啊？关于这一点，我们会在后面的专栏中详细讨论）。

首先将数据以3个字节分为一组，并进行换位，我们用开头的“F0 FF FF”来举例。

F0 FF FF → FF0 FFF

ab cd ef dab efc




为了让大家看清楚具体是如何换位的，我们在下面标记了英文字母。换位之后，原来的3个字节变成了2个数字。同样地，“03 40 00”换位后结果如下。

03 40 00 → 003 004

ab cd ef dab efc




以此类推，我们对整个FAT解码之后的样子如下。

FAT数据

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9

-----------------------------------------------

0 FF0 FFF 003 004 005 006 007 008 009 00A

10 00B 00C 00D 00E 00F 010 011 012 013 014

20 015 016 017 018 019 01A 01B 01C 01D 01E

30 01F 020 021 022 023 024 025 026 027 028

40 029 02A 02B 02C 02D 02E 02F 030 031 032

50 033 034 035 036 037 038 039 FFF 03B 03C

60 03D 03E 03F FFF FFF 000 000 000 000 000




■■■■■

虽然我们已经对数据进行了解压缩，不过这样还是看不懂啊。我们先来看看文件信息的部分。

harib16b的磁盘映像节选

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

002600 48 41 52 49 42 4F 54 45 53 59 53 20 00 00 00 00 HARIBOTESYS ....

002610 00 00 00 00 00 00 18 74 FF 32 02 00 C8 6E 00 00 .......t.2...n..

002620 49 50 4C 31 30 20 20 20 4E 41 53 20 00 00 00 00 IPL10 NAS ....

002630 00 00 00 00 00 00 B9 34 63 34 3A 00 B0 0B 00 00 .......4c4:.....

002640 4D 41 4B 45 20 20 20 20 42 41 54 20 00 00 00 00 MAKE BAT ....

002650 00 00 00 00 00 00 F6 10 81 30 40 00 2E 00 00 00 .........0@.....

002660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................




从上面的信息我们可以得到：

HARIBOTE.SYS 02 00 → clustno = 0x0002

IPL10.NAS 3A 00 → clustno = 0x003a

MAKE.BAT 40 00 → clustno = 0x0040




我们以haribote.sys为例来分析一下。已知clustno = 2，因此我们读取0x004200～0x0043ff这512个字节。那么接下来应该读取哪里的数据呢？我们来看FAT的第2号记录，其值为003，也就是说下面的部分存放在clustno = 3这个位置，即读取0x004400～0x0045ff这512个字节。再接下来参照FAT的第3号记录，即可得到下一个地址clustno = 4。

以此类推，我们一直读取到clustno = 57（0x39）。57号扇区后面应该读哪里了呢？参照对应的FAT记录，居然是FFF。也就是说，57号之后已经没有数据了，即这里就是文件的末尾。一般来说，如果遇到FF8～FFF的值，就代表文件数据到此结束。

正如上面所讲的，文件读取就是一个接力的过程，大家明白了吗？不明白也没关系，看了程序代码相信大家一定会理解的。

不过，这种接力的方式下，只要其中一个地方损坏，之后的部分就会全部混乱。因此，微软公司将FAT看作是最重要的磁盘信息，为此在磁盘中存放了2份FAT。第1份FAT位于0x000200～0x0013ff，第2份位于0x001400～0x0025ff。其中第2份是备份FAT，内容和第1份完全相同。

■■■■■

好了，我们来写程序吧，代码如下。

本次的bootpack.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

int *fat = (int *) memman_alloc_4k(memman, 4 * 2880);



（中略）

file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200)); /*这里！*/



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/

if (i == 8 + 256) {



（中略）

} else if (i == 10 + 256) {

（中略）

if (strcmp(cmdline, "mem") == 0) {

（中略）

} else if (strcmp(cmdline, "cls") == 0) {

（中略）

} else if (strcmp(cmdline, "dir") == 0) {

（中略）

} else if (strncmp(cmdline, "type ", 5) == 0) {

/* type命令*/

（中略）

if (x < 224 && finfo[x].name[0] != 0x00) {

/*找到文件的情况*/

/*这里！*/ p = (char *) memman_alloc_4k(memman, finfo[x].size);

/*这里！*/ file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

cursor_x = 8;

/*这里！*/ for (y = 0; y < finfo[x].size; y++) {

/*逐字输出*/

/*这里！*/ s[0] = p[y];

s[1] = 0;

（中略）

}

/*这里！*/ memman_free_4k(memman, (int) p, finfo[x].size);

} else {

/*没有找到文件的情况 */

（中略）

}

cursor_y = cons_newline(cursor_y, sheet);

} else if (cmdline[0] != 0) {

（中略）

}

（中略）

} else {

/*一般字符*/

（中略）

}

}

（中略）

}

}

}



void file_readfat(int *fat, unsigned char *img)

/*将磁盘映像中的FAT解压缩 */

{

int i, j = 0;

for (i = 0; i < 2880; i += 2) {

fat[i + 0] = (img[j + 0] | img[j + 1] << 8) & 0xfff;

fat[i + 1] = (img[j + 1] >> 4 | img[j + 2] << 4) & 0xfff;

j += 3;

}

return;

}



void file_loadfile(int clustno, int size, char *buf, int *fat, char *img)

{

int i;

for (;;) {

if (size <= 512) {

for (i = 0; i < size; i++) {

buf[i] = img[clustno * 512 + i];

}

break;

}

for (i = 0; i < 512; i++) {

buf[i] = img[clustno * 512 + i];

}



size -= 512;

buf += 512;

clustno = fat[clustno];

}

return;

}




程序的结构很简单。首先，由于压缩状态的FAT很难使用，因此我们先用file_readfat将其展开到fat[]。

然后，在type命令中，我们先分配一块和文件大小相同的内存空间，用file_loadfile将文件的内容读入内存。这样一来内存中的文件内容已经排列为正确的顺序，使用之前的程序来显示文件内容即可。显示完成后，释放用于临时存放文件内容的内存空间。

■■■■■

好，我们来“make run”。嗯嗯，貌似运行成功了。其实我们最好是特意准备一个不连续的文件，以便确认程序是否能够正常显示它，不过准备不连续的文件实在比较麻烦，我们就权且“相信”它可以正常显示吧（笑）。

COLUMN-11　FAT的压缩

软盘中的FAT是经过压缩的，将2个扇区的信息挤到了3个字节中。正是因此，我们的程序必须先从FAT的解压缩开始。

如果不进行压缩，到底会浪费多少空间呢？我们来简单计算一下。磁盘中一共有2880个扇区，正常使用WORD保存扇区号的话，FAT总共需要2880×2=5760个字节，也就是说，一个FAT要占用12个扇区。

经过压缩后，3个字节可以保存2个扇区号，也就是说，存放1个扇区号所需要的空间变为了1.5个字节。因此，FAT总共需要2880×1.5=4320个字节，这样的话，一个FAT只占用9个扇区。

一张软盘中一共有2份FAT，因此经过压缩后，总共可以节省6个扇区的空间，但对于磁盘的总容量来说，也只相当于0.2%（6 / 2880×100）。唔，仅仅为了节省这0.2%的空间，有必要搞这么麻烦的压缩吗？从笔者的感觉来说，这实在是够纠结的。





4　代码整理（harib16d）

唔，bootpack.c有点太长了（已经达到648行了哦！），虽然笔者一向懒惰，但现在也觉得该整理整理了。



窗口相关函数 → window.c



命令行窗口相关函数 → console.c



文件相关函数 → file.c





这样一来就清爽多了，bootpack.c也缩减为282行了，撒花。

不过，我们还是要确认一下整理后的程序是否可以顺利编译，是否可以像之前一样正常运行。“make run”，哇，运行成功，不错不错——虽说这是理所应当吧。





5　第一个应用程序（harib16e）

好，既然现在我们已经可以读取文件的内容，那么运行应用程序也就不难实现了。

作为头一次尝试，我们要挑战什么样的应用程序呢？当然还是从简单的开始啦。唔，最简单的应用程序是……到底哪个比较好呢？哦，有了，就选那个吧。

因此，请大家把书一口气翻回到3.5节，那里有一个非常简单的操作系统程序，只有3个字节。可能有些人连翻书都懒得翻，好吧，我们就再次来个那3个字节程序的大公开吧！（笑）

3个字节的应用程序

[BITS 32]

fin:

HLT

JMP fin




将上面这段代码保存为hlt.nas，然后用nask进行汇编，生成hlt.hrb。可能大家会问，这个扩展名.hrb是啥？这个嘛，其实是haribote的缩写。如果我们命名为.exe文件的话，就会和Windows的可执行文件产生混淆，因此这里我们用了个自定义的扩展名。

■■■■■

那么，要怎样才能运行文件的内容呢？像type命令一样，我们用file_loadfile将文件的内容读到内存中，问题是后面要怎么办？

应用程序不知道自己被读到哪个内存地址，这里暂且由ORG 0来生成。因此，为了应用程序能够顺利运行，我们需要为其创建一个内存段。

段创建好之后，接下来只要goto到该段中的程序，程序应该就会开始运行了。要goto到其他的内存段，在汇编语言中用farjmp指令。话说，这个指令我们在任务切换的时候已经用过了嘛。因此，这次我们不需要改动naskfunc.nas中的函数就可以运行hlt.hrb了，撒花。

■■■■■

写好的程序如下。

本次的console.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;



（中略）



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A） */

if (i == 8 + 256) {

（中略）

} else if (i == 10 + 256) {

（中略）

if (strcmp(cmdline, "mem") == 0) {

（中略）

} else if (strcmp(cmdline, "cls") == 0) {

（中略）

} else if (strcmp(cmdline, "dir") == 0) {

（中略）

} else if (strncmp(cmdline, "type ", 5) == 0) {

（中略）

} else if (strcmp(cmdline, "hlt") == 0) {

/*从此开始*/ /*启动应用程序hlt.hrb */

for (y = 0; y < 11; y++) {

s[y] = ' ';

}

s[0] = 'H';

s[1] = 'L';

s[2] = 'T';

s[8] = 'H';

s[9] = 'R';

s[10] = 'B';

for (x = 0; x < 224; ) {

if (finfo[x].name[0] == 0x00) {



break;

}

if ((finfo[x].type & 0x18) == 0) {

for (y = 0; y < 11; y++) {

if (finfo[x].name[y] != s[y]) {

goto hlt_next_file;

}

}

break; /*找到文件*/

}

hlt_next_file:

x++;

}

if (x < 224 && finfo[x].name[0] != 0x00) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo[x].size);

file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *)

(ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo[x].size - 1, (int) p, AR_CODE32_ER);

farjmp(0, 1003 * 8);

memman_free_4k(memman, (int) p, finfo[x].size);

} else {

/*没有找到文件的情况*/

putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, "File not found.", 15);

cursor_y = cons_newline(cursor_y, sheet);

}

/*到此结束*/ cursor_y = cons_newline(cursor_y, sheet);

} else if (cmdline[0] != 0) {

（中略）

}

（中略）

} else {

（中略）

}

}

（中略）

}

}

}




这次添加的hlt命令，是用来启动hlt.hrb这个应用程序的，前半部分和type命令的代码非常类似。

hlt.hrb成功读入内存之后，将其注册为GDT的1003号。为什么要用1003号呢？100号或者12号不行吗？还真不行，因为1～2号由dsctbl.c使用，而3～1002号由mtask.c使用，所以我们用了1003号，因此如果把1003号换成1234号之类的还是没问题的哦。

随后，当内存段创建完成后，用farjmp跳转并运行。

■■■■■

我们来试试看吧，“make run”，然后在命令行窗口中运行hlt命令，这是“纸娃娃系统”历史上首次运行应用程序，我们的心情无比激动。咦？程序停止了。



运行时的样子

糟糕，难道是bug？转念一想，这个程序本来就是执行HTL，这样才是正常的嘛。因为程序不会执行任何操作，因此看上去好像是停止了一样。对了，其实（看上去）停止了的只有命令行窗口而已，如果按下Tab键的话，还是可以切换回task_a的哦。

唔，不过这样一来，我们就没办法判断命令行窗口的停止到底是因为运行了hlt.hrb呢，还是由于另外一些原因不明的bug导致的。我们还是要再确认一下才行。

该怎么办呢？我们用个巧办法吧：

改造版的第一个应用程序

[BITS 32]

CLI

fin:

HLT

JMP fin




我们在开头加上了一个CLI指令，这样整个程序变成了4个字节。如果应用程序正常运行的话，中断处理会被禁止，因此即便按下Tab键也无法切换回task_a，鼠标应该也停止不动了。

那么我们来试验一下。哇，真的停止了耶！太棒了，果然我们的应用程序成功运行了。话说回来，冷静下来一想，自己制作的操作系统明明死机了却还开心得不得了，真是个奇怪的家伙（笑）。总之，撒花。

好了，今天的内容就到这里。明天我们继续加油哦！





第20天　API



程序整理（harib17a）

显示单个字符的API（1）（harib17b）

显示单个字符的API（2）（harib17c）

结束应用程序（harib17d）

不随操作系统版本而改变的API（harib17e）

为应用程序自由命名（harib17f）

当心寄存器（harib17g）

用API显示字符串（harib17h）





1　程序整理（harib17a）

大家早上好，今天我们继续努力哦。昨天我们已经实现了应用程序的运行，今天我们来实现由应用程序对操作系统功能的调用（即API，也叫系统调用）。

为什么这样的功能称为“系统调用”（system call）呢？因为它是由应用程序来调用（操作）系统中的功能来完成某种操作，这个名字很直白吧。

“API”这个名字就稍微复杂些，是“application program interface”的缩写，即“应用程序（与系统之间的）接口”的意思。

请大家把这两个名字记住哦，考试题目中会有的哦……开玩笑啦，这些其实用不着记啦。有记这些单词的工夫，还不如多享受一下制作操作系统的乐趣呢。

以后，在本书中会更多地使用“API”这个名字，理由很简单，因为它比较短嘛（笑）！

这值得纪念的第一次，我们就来做个在命令行窗口中显示字符的API吧。BIOS中也有这个功能哦，如果忘了的话请重新看看第二天的内容。怎么样，找到了吧？无论什么样的操作系统，都会有功能类似的API，这可以说是必需的。

■■■■■

下面来改造一下我们操作系统，让它可以使用API吧……等等，现在这程序是怎么回事！尤其是console_task，简直太不像样了。看着如此混乱的程序代码，真是提不起任何干劲来进行改造，我们还是先把程序整理一下吧。

由于只是改变了程序的写法，并没有改变程序处理的内容，因此这里就不讲解了。原本很长的console_task，从249行改到了85行，哦耶！不过由于创建了很多函数，整体的行数反而比原来多了，叹。

本次的console.c节选

struct CONSOLE {

struct SHEET *sht;

int cur_x, cur_y, cur_c;

};



void console_task(struct SHEET *sheet, unsigned int memtotal)

{

struct TIMER *timer;

struct TASK *task = task_now();

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

int i, fifobuf[128], *fat = (int *) memman_alloc_4k(memman, 4 * 2880);

struct CONSOLE cons;

char cmdline[30];

cons.sht = sheet;

cons.cur_x = 8;

cons.cur_y = 28;

cons.cur_c = -1;



fifo32_init(&task->fifo, 128, fifobuf, task);

timer = timer_alloc();

timer_init(timer, &task->fifo, 1);

timer_settime(timer, 50);

file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200));



/*显示提示符*/

cons_putchar(&cons, '>', 1);



for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

task_sleep(task);

io_sti();

} else {

i = fifo32_get(&task->fifo);

io_sti();

if (i <= 1) { /*光标用定时器*/

if (i != 0) {

timer_init(timer, &task->fifo, 0); /*下次置0 */

if (cons.cur_c >= 0) {

cons.cur_c = COL8_FFFFFF;

}



} else {

timer_init(timer, &task->fifo, 1); /*下次置1 */



if (cons.cur_c >= 0) {

cons.cur_c = COL8_000000;

}

}

timer_settime(timer, 50);

}

if (i == 2) { /*光标ON */

cons.cur_c = COL8_FFFFFF;

}

if (i == 3) { /*光标OFF */

boxfill8(sheet->buf, sheet->bxsize, COL8_000000,

cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15);

cons.cur_c = -1;

}

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/

if (i == 8 + 256) {

/*退格键*/

if (cons.cur_x > 16) {

/*用空格擦除光标后将光标前移一位*/

cons_putchar(&cons, ' ', 0);

cons.cur_x -= 8;

}

} else if (i == 10 + 256) {

/*回车键*/

/*将光标用空格擦除后换行 */

cons_putchar(&cons, ' ', 0);

cmdline[cons.cur_x / 8 - 2] = 0;

cons_newline(&cons);

cons_runcmd(cmdline, &cons, fat, memtotal); /*运行命令*/

/*显示提示符*/

cons_putchar(&cons, '>', 1);

} else {

/*一般字符*/

if (cons.cur_x < 240) {

/*显示一个字符之后将光标后移一位*/

cmdline[cons.cur_x / 8 - 2] = i - 256;

cons_putchar(&cons, i - 256, 1);

}

}

}

/*重新显示光标*/

if (cons.cur_c >= 0) {

boxfill8(sheet->buf, sheet->bxsize, cons.cur_c, cons.cur_x, cons.cur_y,

cons.cur_x + 7, cons.cur_y + 15);

}

sheet_refresh(sheet, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16);

}

}

}



void cons_putchar(struct CONSOLE *cons, int chr, char move)

{

char s[2];

s[0] = chr;

s[1] = 0;

if (s[0] == 0x09) { /*制表符*/

for (;;) {

putfonts8_asc_sht(cons->sht, cons->cur_x, cons->cur_y, COL8_FFFFFF, COL8_000000, " ", 1);

cons->cur_x += 8;

if (cons->cur_x == 8 + 240) {

cons_newline(cons);

}

if (((cons->cur_x - 8) & 0x1f) == 0) {

break; /*被32整除则break*/

}



}

} else if (s[0] == 0x0a) { /*换行*/

cons_newline(cons);

} else if (s[0] == 0x0d) { /*回车*/

/*先不做任何操作*/

} else { /*一般字符*/

putfonts8_asc_sht(cons->sht, cons->cur_x, cons->cur_y, COL8_FFFFFF, COL8_000000, s, 1);

if (move != 0) {

/* move为0时光标不后移*/

cons->cur_x += 8;

if (cons->cur_x == 8 + 240) {

cons_newline(cons);

}

}

}

return;

}



void cons_newline(struct CONSOLE *cons)

{

int x, y;

struct SHEET *sheet = cons->sht;

if (cons->cur_y < 28 + 112) {

cons->cur_y += 16; /*到下一行*/

} else {

/*滚动*/

for (y = 28; y < 28 + 112; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = sheet->buf[x + (y + 16) * sheet->bxsize];

}

}

for (y = 28 + 112; y < 28 + 128; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = COL8_000000;

}

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

}

cons->cur_x = 8;

return;

}



void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, unsigned int memtotal)

{

if (strcmp(cmdline, "mem") == 0) {

cmd_mem(cons, memtotal);

} else if (strcmp(cmdline, "cls") == 0) {

cmd_cls(cons);

} else if (strcmp(cmdline, "dir") == 0) {

cmd_dir(cons);

} else if (strncmp(cmdline, "type ", 5) == 0) {

cmd_type(cons, fat, cmdline);

} else if (strcmp(cmdline, "hlt") == 0) {

cmd_hlt(cons, fat);

} else if (cmdline[0] != 0) {

/*不是命令，也不是空行*/

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, "Bad command.", 12);

cons_newline(cons);

cons_newline(cons);

}

return;

}



void cmd_mem(struct CONSOLE *cons, unsigned int memtotal)

{



struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

char s[30];

sprintf(s, "total %dMB", memtotal / (1024 * 1024));

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, s, 30);

cons_newline(cons);

sprintf(s, "free %dKB", memman_total(memman) / 1024);

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, s, 30);

cons_newline(cons);

cons_newline(cons);

return;

}



void cmd_cls(struct CONSOLE *cons)

{

int x, y;

struct SHEET *sheet = cons->sht;

for (y = 28; y < 28 + 128; y++) {

for (x = 8; x < 8 + 240; x++) {

sheet->buf[x + y * sheet->bxsize] = COL8_000000;

}

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

cons->cur_y = 28;

return;

}



void cmd_dir(struct CONSOLE *cons)

{

struct FILEINFO *finfo = (struct FILEINFO *) (ADR_DISKIMG + 0x002600);

int i, j;

char s[30];

for (i = 0; i < 224; i++) {

if (finfo[i].name[0] == 0x00) {

break;

}

if (finfo[i].name[0] != 0xe5) {

if ((finfo[i].type & 0x18) == 0) {

sprintf(s, "filename.ext %7d", finfo[i].size);

for (j = 0; j < 8; j++) {

s[j] = finfo[i].name[j];

}

s[ 9] = finfo[i].ext[0];

s[10] = finfo[i].ext[1];

s[11] = finfo[i].ext[2];

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, s, 30);

cons_newline(cons);

}

}

}

cons_newline(cons);

return;

}



void cmd_type(struct CONSOLE *cons, int *fat, char *cmdline)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct FILEINFO *finfo = file_search(cmdline + 5, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

char *p;

int i;

if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

for (i = 0; i < finfo->size; i++) {

cons_putchar(cons, p[i], 1);



}

memman_free_4k(memman, (int) p, finfo->size);

} else {

/*没有找到文件的情况*/

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, "File not found.", 15);

cons_newline(cons);

}

cons_newline(cons);

return;

}



void cmd_hlt(struct CONSOLE *cons, int *fat)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct FILEINFO *finfo = file_search("HLT.HRB", (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;

char *p;

if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER);

farjmp(0, 1003 * 8);

memman_free_4k(memman, (int) p, finfo->size);

} else {

/*没有找到文件的情况*/

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, "File not found.", 15);

cons_newline(cons);

}

cons_newline(cons);

return;

}




本次的file.c节选

struct FILEINFO *file_search(char *name, struct FILEINFO *finfo, int max)

{

int i, j;

char s[12];

for (j = 0; j < 11; j++) {

s[j] = ' ';

}

j = 0;

for (i = 0; name[i] != 0; i++) {

if (j >= 11) { return 0; /*没有找到*/ }

if (name[i] == '.' && j <= 8) {

j = 8;

} else {

s[j] = name[i];

if ('a' <= s[j] && s[j] <= 'z') {

/*将小写字母转换为大写字母*/

s[j] -= 0x20;

}

j++;

}

}

for (i = 0; i < max; ) {

if (finfo[i].name[0] == 0x00) {

break;

}

if ((finfo[i].type & 0x18) == 0) {

for (j = 0; j < 11; j++) {

if (finfo[i].name[j] != s[j]) {

goto next;

}

}

return finfo + i; /*找到文件*/



}

next:

i++;

}

return 0; /*没有找到*/

}




■■■■■

嗯嗯，比之前的代码易读多了。你看，只要想把代码写得清爽些就一定能做到的，连笔者都做到了嘛（笑）。这个例子说明，如果持续增加新的功能，一个函数的代码就会变得很长，像这样定期整理一下还是很有帮助的。

好了，我们来“make run”，输入一些命令试试看。和之前运行的情况一样，很好。





2　显示单个字符的API（1）（harib17b）

现在我们要开始做显示单个字符的API了哦。说起来其实也不是很难，只要应用程序能用某种方法调用cons_putchar就可以了。

首先我们做一个测试用的应用程序，将要显示的字符编码存入AL寄存器，然后调用操作系统的函数，字符就显示出来了。

本次的hlt.nas（初稿）

[BITS 32]

MOV AL,'A'

CALL （cons_putchar的地址）

fin:

HLT

JMP fin




就是这个样子。CALL是一个用来调用函数的指令。在C语言中，goto和函数调用的处理方式完全不同，不过在汇编语言中，CALL指令和JMP指令其实差不多是一码事，它们的区别仅仅在于，当执行CALL指令时，为了能够在接下来执行RET指令时正确返回，会先将要返回的目标地址PUSH到栈中。

关于CALL指令这里想再讲一下。有人可能会想，直接写CALL cons_putchar不就好了吗？然而，hlt.nas这个应用程序在汇编时并不包含操作系统本身的代码，因此汇编器无法得知要调用的函数地址，汇编就会出错。要解决这个问题，必须人工查好地址后直接写到代码中。在对haribote.sys进行make的时候，通过一定的方法我们可以查出cons_putchar的地址，没有问题，那么我们就来查一下地址……且慢！

■■■■■

这样做有个问题，因为cons_putchar是用C语言写的函数，即便我们将字符编码存入寄存器，函数也无法接收，因此我们必须在CALL之前将文字编码推入栈才行，但这样做也太麻烦了。

没办法，我们只好用汇编语言写一个用来将寄存器的值推入栈的函数了。这个函数不是应用程序的一部分，而是写在操作系统的代码中，因此我们要改写的是naskfunc.nas。另一方面，在应用程序中，我们CALL的地址不再是cons_putchar，而是变成了新写的_asm_cons_putchar。



本次的naskfunc.nas节选（初稿）

_asm_cons_putchar:

PUSH 1

AND EAX,0xff ; 将AH和EAX的高位置0，将EAX置为已存入字符编码的状态

PUSH EAX

PUSH （cons的地址）

CALL _cons_putchar

ADD ESP,12 ; 将栈中的数据丢弃

RET




PUSH的特点是后进先出，因此这个顺序没问题。

这段程序的问题在于“cons的地址”到底是多少。应用程序是不知道这个地址的，因此让应用程序来指定地址难以实现。唔，那么只能让操作系统把这个地址事先保存在内存中的某个地方了。哪里比较好呢？对了，就保存在BOOTINFO之前的0x0fec这个地址吧。

本次的naskfunc.nas节选（完成版）

_asm_cons_putchar:

PUSH 1

AND EAX,0xff ; 将AH和EAX的高位置0，将EAX置为已存入字符编码的状态

PUSH EAX

PUSH DWORD [0x0fec] ; 读取内存并PUSH该值

CALL _cons_putchar

ADD ESP,12 ; 将栈中的数据丢弃

RET




本次的console.c节选

void console_task(struct SHEET *sheet, unsigned int memtotal)

{

（中略）

cons.sht = sheet;

cons.cur_x = 8;

cons.cur_y = 28;

cons.cur_c = -1;

*((int *) 0x0fec) = (int) &cons; /*这里！*/

（中略）

}




■■■■■

现在操作系统这边的工作已经完成了，因此我们先来“make”一下，注意这里不是“make run”，和之前不太一样，因为应用程序还没有准备好呢，所以我们先只进行“make。”

make完成后，除了haribote.sys之外，还会生成一个叫bootpack.map的文件。之前我们一直忽略这个文件的，不过这次它要派上用场了。

这是一个文本文件，用文本编辑器打开即可，其中应该可以找到这样一行：

0x00000BE3 : _asm_cons_putchar


这就是_asm_cons_putchar的地址了，因此，我们将地址填在应用程序中：

本次的hlt.nas（完成版）

[BITS 32]

MOV AL,'A'

CALL 0xbe3

fin:

HLT

JMP fin




然后再进行汇编就可以了，很简单吧。

说起来，我们写的这些代码里面，哪个部分是API呢？“MOVE AL,‘A’”和“CALL 0xbe3”就是API了，因为API就是由应用程序来使用操作系统所提供的服务。当然，我们这个是否达到 “服务”的程度就另当别论了。

现在我们的应用程序也已经完成了，可以“make run”了。嘿！然后在命令行窗口里面运行“hlt”。哈！

于是乎，哐叽！qemu.exe出错关闭了！看来笔者遭遇了一个不得了的大bug。在真机环境下无法预料会造成什么后果，因此请大家不要尝试。好吧，下面我们来解决这个bug。





3　显示单个字符的API（2）（harib17c）*

像这样会造成模拟器出错关闭的bug，果然只有在开发操作系统时才能碰到。如果不用模拟器进行开发的话，不经意间产生的bug有时可能会造成电脑损坏、硬盘被格式化等严重问题，也许好几天都无法恢复过来。开发操作系统就是这么刺激。如果通过这次的bug，大家能够瞥见这种刺激的冰山一角，那么笔者觉得这个bug也算是有点用的吧（苦笑）。

不过，光扯刺激啦什么的也无济于事，我们还得仔细寻找原因。哦，原来如此，找到了！

原因其实很简单。应用程序对API执行CALL的时候，千万不能忘记加上段号。应用程序所在的段为“1003 * 8”，而操作系统所在的段为“2 * 8”，因此我们不能使用普通的CALL，而应该使用far-CALL。

far-CALL实际上和far-JMP一样，只要同时指定段和偏移量即可。

本次的hlt.nas

[BITS 32]

MOV AL,'A'

CALL 2*8:0xbe3

fin:

HLT

JMP fin




好，完工了，这样bug应该就解决了，我们来试试看。“make run”，然后运行“hlt”。咦？还是不行。这次虽然没有出错关闭，但qemu.exe停止响应了。

这个问题是由于_asm_cons_putchar的RET指令所造成的。普通的RET指令是用于普通的CALL的返回，而不能用于far-CALL的返回，既然我们用了far-CALL，就必须相应地使用far-RET，也就是RETF指令。因此我们将程序修改一下。

_asm_cons_putchar:

（中略）

RETF ; 这里！




好啦，这次应该没问题了吧。“make run”，“hlt”，成功了！撒花！



字符显示出来了哦！！！





4　结束应用程序（harib17d）

照现在这个样子，应用程序结束之后会执行HLT，我们就无法在命令行窗口中继续输入命令了，这多无聊啊。如果应用程序结束后不执行HLT，而是能返回操作系统就好了。

怎样才能实现这样的设想呢？没错，只要将应用程序中的HLT改成RET，就可以返回了。相应地，操作系统这边也需要用CALL来代替JMP启动应用程序才对。虽说是CALL，不过因为要调用的程序位于不同的段，所以实际上应该使用far-CALL，因此应用程序那边也应该使用RETF。好，我们的方针已经明确了。

■■■■■

C语言中没有用来执行far-CALL的命令，我们只好来创建一个farcall函数，这个函数和farjmp大同小异。

本次的naskfunc.nas节选

_farcall: ; void farcall(int eip, int cs);

CALL FAR [ESP+4] ; eip, cs

RET




然后，我们还要把hlt命令的处理改为调用farcall。

本次的console.c节选

void cmd_hlt(struct CONSOLE *cons, int *fat)

{

（中略）

if (finfo != 0) {

/*找到文件的情况*/

（中略）

farcall(0, 1003 * 8); /*这里！*/

（中略）

} else {

/*没有找到文件的情况*/

（中略）

}

（中略）

}




最后我们还要改写一下应用程序hlt.nas，把HLT换成RETF就可以了。

本次的hlt.nas（第1部分）

[BITS 32]

MOV AL,'A'

CALL 2*8:0xbe3

RETF




■■■■■

好，完工了哦。我们来“make run”一下，然后运行“hlt”。

咦？qemu.exe又停止响应了，貌似是有bug（今天我们碰了好几个钉子了嘛）。

怎么回事呢？啊，明白了。由于我们改写了操作系统的代码，导致_asm_cons_putchar的地址发生了变化。重新查看bootpack.map，我们发现地址变成了这样：

0x0000BE8 : _asm_cons_putchar


因此，我们把应用程序修改一下。

本次的hlt.nas（第2部分）

[BITS 32]

MOV AL,'A'

CALL 2*8:0xbe8

RETF




好，改完了，再试试看。“make run”，“hlt”，怎么样？好了！成功了！



心情激动，于是运行了3次hlt

趁热打铁，我们再来个新的尝试：显示“hello”。

本次的hlt.nas（第3部分）

[BITS 32]

MOV AL,'h'

CALL 2*8:0xbe8

MOV AL,'e'

CALL 2*8:0xbe8

MOV AL,'l'

CALL 2*8:0xbe8

MOV AL,'l'

CALL 2*8:0xbe8

MOV AL,'o'

CALL 2*8:0xbe8

RETF




貌似用循环比较好呢？算了，实在太麻烦（笑）。我们运行一下试试看，结果如下。



你好！

话说回来，现在这个应用程序已经和当初“hlt”这个名字完全对不上号了，看来我们得赶快给它改改名字了呢。





5　不随操作系统版本而改变的API（harib17e）

所以说我们又要改写console.c了。等等，如果修改了操作系统的代码，岂不是_asm_cons_putchar的地址也会像上次那样发生变化？难道说每次我们修改操作系统的代码，都得把应用程序的代码也改一遍？这也太麻烦了。

虽说确实有的操作系统版本一改变，应用程序也得重新编译，不过还有些系统即便版本改变，应用程序也照样可以运行，大家觉得哪种更好呢？

我们的“纸娃娃系统”也需要解决这个问题，把这个搞定之后，我们再考虑命名的事。

■■■■■

解决这个问题的方法其实有很多，这里先为大家介绍其中一种。

CPU中有个专门用来注册函数的地方，也许大家一下子想不起来，笔者说的其实是中断处理程序。在前面我们曾经做过“当发生IRQ-1的时候调用这个函数”这样的设置，大家还记得吗？这是在IDT中设置的。

反正IRQ只有0～15，而CPU用于通知异常状态的中断最多也只有32种，这些都在CPU规格说明书中有明确记载。不过，IDT中却最多可以设置256个函数，因此还剩下很多没有使用的项。

我们的操作系统从这些项里面借用一个的话，CPU应该也不会有什么意见的吧。所以我们就从IDT中找一个空闲的项来用一下。好，我们就选0x40号（其实0x30～0xff都是空闲的，只要在这个范围内任意一个都可以），并将_asm_cons_putchar注册在这里。

本次的dsctbl.c节选

void init_gdtidt(void)

{

（中略）

/* IDT的设置*/

set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x40, (int) asm_cons_putchar, 2 * 8, AR_INTGATE32); /*这里！*/



return;

}




这样一来，我们只要用INT 0x40来代替原来的CALL 2*8:0xbd1就可以调用_asm_cons_putchar了，很方便吧？我们来修改一下应用程序吧。

本次的hlt.nas

[BITS 32]

MOV AL,'h'

INT 0x40

MOV AL,'e'

INT 0x40

MOV AL,'l'

INT 0x40

MOV AL,'l'

INT 0x40

MOV AL,'o'

INT 0x40

RETF




于是程序变成了这个样子。看到这里，直觉敏锐的读者也许已经发现了“跟调用BIOS的时候差不多嘛……”。没错，虽然INT号不同，但通过INT方式调用这一点的确是非常类似。说起来，MS-DOS的API采用的也是这种INT方式。

另外，使用INT指令来调用的时候会被视作中断来处理，用RETF是无法返回的，需要使用IRETD指令。因此，我们还要改写_asm_cons_putchar。

本次的naskfunc.nas节选

_asm_cons_putchar:

STI ;这里！

PUSH 1

AND EAX,0xff ; 将AH和EAX的高位置0，将EAX置为已存入字符编码的状态

PUSH EAX

PUSH DWORD [0x0fec] ; 读取内存并PUSH该值

CALL _cons_putchar

ADD ESP,12 ; 丢弃栈中的数据

IRETD ; 这里！




用INT调用时，对于CPU来说相当于执行了中断处理程序，因此在调用的同时CPU会自动执行CLI指令来禁止中断请求。但我们只是用它来代替CALL使用，这种做法就显得画蛇添足了。我们可不想看到“API处理时键盘无法输入”这样的情况，因此需要在开头添加一条STI指令。

其实，对于这种问题，一般来说可以通过在注册到IDT时修改设置来禁止CPU擅自执行CLI，不过这个有点麻烦，还是算了吧（笑）。话说，今天笔者貌似懒到家了，得反省一下。

■■■■■

好了，修改完成，我们来“make run”一下，结果如下。



正常显示“你好”

嗯，很顺利呢。而且应用程序还比之前小了。

harib17d的hlt.hrb：46字节

harib17e的hlt.hrb：21字节

你看，用这种方法能把应用程序缩小，厉害吧？这是因为far-CALL指令需要7个字节而INT指令只需要2个字节的缘故。这次修改还真是一箭双雕呢。





6　为应用程序自由命名（harib17f）

现在我们的应用程序只能用hlt这个名字，下面我们来让系统支持其他应用程序名，这次我们就用hello吧。将console.c中的“hlt”改成“hello”，好啦，这样我们就可以用hello这个应用程序了……哇！别生气别生气，开个玩笑而已（笑）。

好吧，我们先来改写cons_runcmd。

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, unsigned int memtotal)

{

if (strcmp(cmdline, "mem") == 0) {

cmd_mem(cons, memtotal);

} else if (strcmp(cmdline, "cls") == 0) {

cmd_cls(cons);

} else if (strcmp(cmdline, "dir") == 0) {

cmd_dir(cons);

} else if (strncmp(cmdline, "type ", 5) == 0) {

cmd_type(cons, fat, cmdline);

} else if (cmdline[0] != 0) { /*从此开始*/

if (cmd_app(cons, fat, cmdline) == 0) {

/*不是命令，不是应用程序，也不是空行*/

putfonts8_asc_sht(cons->sht, 8, cons->cur_y, COL8_FFFFFF, COL8_000000, "Bad command.", 12);

cons_newline(cons);

cons_newline(cons);

}

} /*到此结束 */

return;

}




总结一下修改的地方，首先是去掉了cmd_hlt，并创建了新的cmd_app。这个函数用来根据命令行的内容判断文件名，并运行相应的应用程序，如果找到文件则返回1，没有找到文件则返回0。

现在程序的工作过程是：当输入的命令不是mem、cls、dir、type其中之一时，则调用cmd_app，如果返回0则作为错误处理。这样应该能行。

我们在cmd_hlt的基础上稍作修改后得到cmd_app函数，具体内容如下。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct FILEINFO *finfo;

struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;

char name[18], *p;

int i;



/*根据命令行生成文件名*/

for (i = 0; i < 13; i++) {

if (cmdline[i] <= ' ') {

break;

}

name[i] = cmdline[i];

}

name[i] = 0; /*暂且将文件名的后面置为0*/



/*寻找文件 */

finfo = file_search(name, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

if (finfo == 0 && name[i -1]!= '.') {

/*由于找不到文件，故在文件名后面加上“.hrb”后重新寻找*/

name[i ] = '.';

name[i + 1] = 'H';

name[i + 2] = 'R';

name[i + 3] = 'B';



name[i + 4] = 0;

finfo = file_search(name, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

}



if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER);

farcall(0, 1003 * 8);

memman_free_4k(memman, (int) p, finfo->size);

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}




我们在程序上动了一点脑筋，使得无论输入“hlt”还是“hlt.hrb”都可以启动“hlt.hrb”。因为在Windows命令行窗口中，不管加不加后面的“.exe”都可以运行程序，所以我们就借鉴了这个设计。

■■■■■

差不多完工了，我们将hlt.nas改名为hello.nas，然后汇编生成hello.hrb。接下来“make run”，用dir命令确认一下磁盘中的内容，再输入“hello”。哦！出来了！成功了！



再来一次，你好！

嗯嗯，不错！我们再来输入“hlt”试一下，这个文件现在已经没有了，会不会报错呢？另外，如果输入“hello.hrb”能否正常运行呢？我们来试试看。



报错了哦

出现错误信息了，加上扩展名的情况也OK，太完美了。





7　当心寄存器（harib17g）

hello.hrb的大小现在是21个字节，能不能再让它变小点呢？我们做了如下修改，用了一个循环。

本次的hello.nas

[INSTRSET "i486p"]

[BITS 32]

MOV ECX,msg

putloop:

MOV AL,[CS:ECX]

CMP AL,0

JE fin

INT 0x40

ADD ECX,1

JMP putloop

fin:

RETF

msg:

DB "hello",0




改成这样后make一下，hello.hrb变成了26个字节，居然还大了5个字节，哎，好失望。不过，这样改也有好处，即便以后要显示很长的字符串，程序也不会变得太大。

马上运行一下看看。



哎呀？

咦？为啥只显示出一个h呢？再把hello.nas仔细检查一遍，也没发现什么不对劲的地方啊……

■■■■■

既然应用程序没问题，那问题肯定出在操作系统身上。不过，到底是哪里有问题呢？刚刚找到了点眉目，我们给_asm_cons_putchar添上2行代码，就是PUSHAD和POPAD。

本次的naskfunc.nas节选

_asm_cons_putchar:

STI

PUSHAD ; 这里！

PUSH 1

AND EAX,0xff ; 将AH和EAX的高位置0，将EAX置为已存入字符编码的状态

PUSH EAX

PUSH DWORD [0x0fec] ; 读取内存并PUSH该值

CALL _cons_putchar

ADD ESP,12 ; 将栈中的数据丢弃

POPAD ; 这里！

IRETD




为什么要这么改我们待会儿再讲，先来试验一下哦。



哦，好了！

果然是这个问题呀。那为什么会想到加上PUSHAD和POPAD呢？因为笔者推测这有可能是INT 0x40之后ECX寄存器的值发生了变化所导致的，应该是_cons_putchar改动了ECX的值。因此，我们加上了PUSHAD和POPAD确保可以将全部寄存器的值还原，这样程序就能正常运行了。





8　用API显示字符串（harib17h）

从实际的应用程序开发角度来说，能显示字符串的API远比只能显示单个字符的API要来的方便，因为一次显示一串字符的情况比一次只显示一个字符的情况多得多。

从其他操作系统的显示字符串的API来看，一般有两种方式：一种是显示一串字符，遇到字符编码0则结束；另一种是先指定好要显示的字符串的长度再显示。我们到底要用哪一种呢？再三考虑之后，贪心的笔者决定在“纸娃娃系统”上同时实现两种方式（笑）。

本次的console.c节选

void cons_putstr0(struct CONSOLE *cons, char *s)

{

for (; *s != 0; s++) {

cons_putchar(cons, *s, 1);

}

return;

}



void cons_putstr1(struct CONSOLE *cons, char *s, int l)

{

int i;

for (i = 0; i < l; i++) {

cons_putchar(cons, s[i], 1);

}

return;

}




■■■■■

哦，对了，有了这个函数，就可以简化mem、dir、type这几个命令的代码，趁着还没忘记，赶紧改良一下。

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, unsigned int memtotal)

{

if (strcmp(cmdline, "mem") == 0) {

cmd_mem(cons, memtotal);

} else if (strcmp(cmdline, "cls") == 0) {

cmd_cls(cons);

} else if (strcmp(cmdline, "dir") == 0) {

cmd_dir(cons);

} else if (strncmp(cmdline, "type ", 5) == 0) {

cmd_type(cons, fat, cmdline);

} else if (cmdline[0] != 0) {

if (cmd_app(cons, fat, cmdline) == 0) {

/*不是命令，不是应用程序，也不是空行*/

cons_putstr0(cons, "Bad command.\n\n"); /*这里！*/

}

}

return;

}



void cmd_mem(struct CONSOLE *cons, unsigned int memtotal)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

char s[60]; /*从此开始*/

sprintf(s, "total %dMB\nfree %dKB\n\n", memtotal / (1024 * 1024), memman_total(memman) / 1024);

cons_putstr0(cons, s); /*到此结束*/

return;

}



void cmd_dir(struct CONSOLE *cons)

{

struct FILEINFO *finfo = (struct FILEINFO *) (ADR_DISKIMG + 0x002600);

int i, j;

char s[30];



for (i = 0; i < 224; i++) {

if (finfo[i].name[0] == 0x00) {

break;

}

if (finfo[i].name[0] != 0xe5) {

if ((finfo[i].type & 0x18) == 0) {

sprintf(s, "filename.ext %7d\n", finfo[i].size);

for (j = 0; j < 8; j++) {

s[j] = finfo[i].name[j];

}

s[ 9] = finfo[i].ext[0];

s[10] = finfo[i].ext[1];

s[11] = finfo[i].ext[2];

cons_putstr0(cons, s); /*这里！*/

}

}

}

cons_newline(cons);

return;

}



void cmd_type(struct CONSOLE *cons, int *fat, char *cmdline)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct FILEINFO *finfo = file_search(cmdline + 5, (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

char *p;

if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

cons_putstr1(cons, p, finfo->size); /*这里！*/

memman_free_4k(memman, (int) p, finfo->size);

} else {

/*没有找到文件的情况*/

cons_putstr0(cons, "File not found.\n"); /*这里！*/

}

cons_newline(cons);

return;

}




代码缩减了12行，什么嘛！一开始就这样写不就好了吗？不过不管怎么说也算是个值得高兴的事吧。

在上面字符串中我们使用了“\n”这个新的符号，这里来讲解一下。在C语言中，“\”这个字符有特殊的含义，用来表示一些特殊字符。这里出现的“\n”代表换行符，即0x0a，也就是说用2个字符来表示1个字节的信息，有点怪吧。此外还有“\t”，它代表制表符，即0x09。顺便说一下，换行符“\n”之所以用“n”，是因为它是“new line”的缩写。

■■■■■

好，我们已经有了cons_putstr0和cons_putstr1，那么怎样把它们变成API呢？最简单的方法就是像显示单个字符的API那样，分配INT 0x41和INT 0x42来调用这两个函数。不过这样一来，只能设置256个项目的IDT很快就会被用光。

既然如此，我们就借鉴BIOS的调用方式，在寄存器中存入功能号，使得只用1个INT就可以选择调用不同的函数。在BIOS中，用来存放功能号的寄存器一般是AH，我们也可以照搬，但这样最多只能设置256个API函数。而如果我们改用EDX来存放功能号，就可以设置多达42亿个API函数，这样总不会不够用了吧。

功能号暂时按下面那样划分，寄存器的用法也是随意设定的，如果不喜欢的话尽管修改就好哦。

功能号1……显示单个字符（AL = 字符编码）

功能号2……显示字符串0（EBX = 字符串地址）

功能号3……显示字符串1（EBX = 字符串地址，ECX = 字符串长度）

接下来我们将_asm_cons_putchar改写成一个新的函数。

本次的naskfunc.nas节选

_asm_hrb_api:

STI

PUSHAD ; 用于保存寄存器值的PUSH



PUSHAD ; 用于向hrb_api传值的PUSH

CALL _hrb_api

ADD ESP,32

POPAD

IRETD




这个函数非常短，因为我们想尽量用C语言来编写API处理程序，而且这样各位读者也更容易理解。

用C语言编写的API处理程序如下。

本次的console.c节选

void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

cons_putstr0(cons, (char *) ebx);

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx, ecx);

}

return;

}




嗯，还是挺好理解的吧。开头的寄存器顺序是按照PUSHAD的顺序写的，如果在_asm_hrb_api中不用PUSHAD，而是一个一个分别去PUSH的话，那当然可以按照自己喜欢的顺序来。

啊，对了对了，我们还得改一下IDT的设置，将INT 0x40改为调用_asm_hrb_api。

void init_gdtidt(void)

{

（中略）



/* IDT设定*/

set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32); /*这里！*/



return;

}




■■■■■

这样改写之后，现在的hello.nas就无法正常运行了，因为我们需要往EDX里面存入1才能调用相应的API。虽说我们加上一条向EDX中存入1的指令就可以，不过既然已经写好了cons_putstr0，那就干脆用这个新的API写一个hello2.nas吧。

本次的hello2.nas

[INSTRSET "i486p"]

[BITS 32]

MOV EDX,2

MOV EBX,msg

INT 0x40

RETF

msg:

DB "hello",0




哇，这样貌似短多了，make了一下，只有19个字节，创造了最小文件纪录哦。

好，完工了，赶紧“make run”，运行“hello2”试试看。



咦？什么都没显示出来？

呃……貌似失败了，怎么回事呢……？今天已经很累了，脑子都不转了，我们还是明天再来找原因吧。总之，我们先将这个放在一边，在以前的hello.nas中加一条EDX = 1；试试看吧。

本次的hello.nas

[INSTRSET "i486p"]

[BITS 32]

MOV ECX,msg

MOV EDX,1 ; 这里！

putloop:

MOV AL,[CS:ECX]

CMP AL,0

JE fin

INT 0x40

ADD ECX,1

JMP putloop

fin:

RETF

msg:

DB "hello",0




看看这次怎么样。“make run”试验一下。



嗯嗯，这次貌似成功了

成功了，总算稍稍松了口气。

今天我们在最后的最后碰了个大钉子（就是hello2），心情有点不爽，不过已经困得不行了，就先到这吧！大家明天见。





第21天　保护操作系统



攻克难题——字符串显示API（harib18a）

用C语言编写应用程序（harib18b）

保护操作系统（1）（harib18c）

保护操作系统（2）（harib18d）

对异常的支持（harib18e）

保护操作系统（3）（harib18f）

保护操作系统（4）（harib18g）





1　攻克难题——字符串显示API（harib18a）

早安，大家精神还好吗？笔者有点没睡够，不过今天我们要继续加油哦。

先总结一下昨天最后遇到的情况：hello.hrb运行正常，但hello2.hrb却出现异常。为什么会这样呢？想了一下，应该是内存段惹的祸。

显示单个字符时，我们用[CS:ECX]的方式特意指定了CS（代码段寄存器），因此可以成功读取msg的内容。但在显示字符串时，由于无法指定段地址，程序误以为是DS而从完全错误的内存地址中读取了内容，碰巧读出的内容是0，于是就什么都没有显示出来。

因此，我们需要在API中做个改动，使其能够将应用程序传递的地址解释为代码段内的地址。

■■■■■

hrb_api并不知道代码段的起始位置位于内存的哪个地址，但cmd_app应该知道，因为当初设置这个代码段的正是cmd_app。

由于我们没有办法从cmd_app向hrb_api直接传递数据，因此只好又在内存里找个地方存放一下了。0xfec这个位置之前已经用过了，这次我们放在它前面的0xfe8好了。

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）



if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

*((int *) 0xfe8) = (int) p; /*这里！ */

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER);

farcall(0, 1003 * 8);

memman_free_4k(memman, (int) p, finfo->size);

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}



void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

int cs_base = *((int *) 0xfe8); /*这里！*/

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

cons_putstr0(cons, (char *) ebx + cs_base); /*这里！*/

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + cs_base, ecx); /*这里！*/

}

return;

}




就是这个样子，应该没有什么难点，所以就不讲解了。

好了，赶紧试验一下，看看只有19个字节的hello2能不能成功显示出字符串。



显示出来了！

成功了，看来果然是内存段搞的鬼，问题解决！





2　用C语言编写应用程序（harib18b）

在此之前，我们的应用程序都是用汇编语言编写的，因为用汇编语言没有使用不了的指令，而且还可以在寄存器层面上实现精确的操作。不过一直用汇编语言写应用程序实在太累，要是能用C语言就省事多了，比如像下面这样：

本次的a.c

void api_putchar(int c);



void HariMain(void)

{

api_putchar('A');

return;

}




（注：这里的函数名HariMain可能会让大家联想到bootpack.c，但其实两者并没有任何关系。用C语言编写程序时，开始执行的入口函数就叫HariMain。这里的a.c和bootpack.c是完全独立编译的应用程序。）

■■■■■

好，让我们开始吧。要实现C语言编写应用程序，需要在应用程序方面创建一个api_putchar函数。注意，这个函数不是创建在操作系统中。api_putchar函数需要用C语言来调用，功能是向EDX和AL赋值，并调用INT 0x40。也许这样说大家还不太明白，看看下面的程序应该马上就能理解了。

本次的a_nask.nas

[FORMAT "WCOFF"] ; 生成对象文件的模式

[INSTRSET "i486p"] ; 表示使用486兼容指令集

[BITS 32] ; 生成32位模式机器语言

[FILE "a_nask.nas"] ; 源文件名信息



GLOBAL _api_putchar



[SECTION .text]



_api_putchar: ; void api_putchar(int c);

MOV EDX,1

MOV AL,[ESP+4] ; c

INT 0x40

RET




这里的api_putchar需要与a.c的编译结果进行连接，因此我们使用对象文件模式。

然后，Makefile也需要修改一下。

本次的Makefile节选

a.bim : a.obj a_nask.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj a_nask.obj



a.hrb : a.bim Makefile

$(BIM2HRB) a.bim a.hrb 0




这里我们借鉴了生成bootpack.hrb时的方法。话说回来，当时我们并没有详细讲解为什么要用这样的方式生成bootpack.hrb，关于这一点稍后我们会讲到。

■■■■■

我们来“make run”，生成了一个72个字节的a.hrb。明明只显示1个字符，却比显示5个字符的hello.hrb还要大，真郁闷，不过因为是用C语言编写的，这也很正常。接着我们在命令行中输入“a”来运行一下，结果QEMU没反应了，貌似程序有bug。看来用C语言编写应用程序还是困难重重啊。

我们当然不能就这样放弃，在这里我们来变个神奇的小戏法。这个小戏法可是很有内涵的哟，不过暂时先卖个关子。

修改前的a.hrb

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

000000 00 00 01 00 48 61 72 69 00 00 00 00 00 00 01 00 ....Hari........

000010 00 00 00 00 48 00 00 00 00 00 00 E9 1C 00 00 00 ....H...........

000020 00 00 00 00 55 89 E5 6A 41 E8 02 00 00 00 C9 C3 ....U..jA.......

000030 BA 01 00 00 00 8A 44 24 04 CD 40 C3 55 89 E5 5D ......D$..@.U..]

000040 E9 DF FF FF FF 00 00 00 ........




我们将开头的6个字节替换成“E8 16 00 00 00 CB”，替换后就变成了这样：

修改后的a.hrb

+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF

-------------------------------------------------------------------------

000000 E8 16 00 00 00 CB 72 69 00 00 00 00 00 00 01 00 ...... ri........

000010 00 00 00 00 48 00 00 00 00 00 00 E9 1C 00 00 00 ....H...........

000020 00 00 00 00 55 89 E5 6A 41 E8 02 00 00 00 C9 C3 ....U..jA.......

000030 BA 01 00 00 00 8A 44 24 04 CD 40 C3 55 89 E5 5D ......D$..@.U..]

000040 E9 DF FF FF FF 00 00 00 ........




大家还记得16进制编辑器的使用方法吗？如果用只读模式无法修改内容，隔的时间太久已经全忘了的同学，请好好回忆一下。

我们再来“make run”一下，a.hrb居然可以正常运行了。仅仅6个字节就解决了问题，二进制编辑器太厉害了！



看，运行成功了

■■■■■

现在a.hrb已经可以正常运行了，那么我们就来讲讲这6个字节小戏法的原理吧。其实说起来也简单，这6个字节其实就相当于下面3行代码用nask汇编之后的结果。

[BITS 32]

CALL 0x1b

RETF




也就是先调用0x1b这个地址的函数，从函数返回后再执行far-RET，仅此而已。

这里的0x1b，其实就是.hrb文件中HariMain的地址（其实还是有点差别的，不过这里我们先照这样来讲）。如果我们回想一下很久之前的内容，在asmhead.nas中，最后调用bootpack.hrb的时候有这样一句：

JMP DWORD 2*8:0x0000001b


你看，这里也是0x1b，一样的。

至于为什么还需要一个far-RET，大家知道吗？因为如果没有它的话，程序结束之后就无法返回到命令行了。

■■■■■

现在我们已经可以用C语言编写应用程序了，为了纪念这一进步，我们再来写一个。

本次的hello3.c

void api_putchar(int c);



void HariMain(void)

{

api_putchar('h');

api_putchar('e');

api_putchar('l');

api_putchar('l');

api_putchar('o');

return;

}




这个程序也使用了api_putchar，也需要a_nask.obj，因此Makefile要这样写。

hello3.bim : hello3.obj a_nask.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:hello3.bim map:hello3.map hello3.obj a_nask.obj



\* * *


$(BIM2HRB) hello3.bim hello3.hrb 0




“make”一下，生成了一个正好100个字节的hello3.hrb。但光这样还不行，我们得把那6个字节的小戏法写进去才能正常运行。

■■■■■

不过每次都替换那6个字节实在是太麻烦了，笔者还是希望“make run”一下就能一步到位，所以我们在操作系统上面做点手脚。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）



if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

*((int *) 0xfe8) = (int) p;

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER);

if (finfo->size >= 8 && strncmp(p + 4, "Hari", 4) == 0) { /*从此开始*/

p[0] = 0xe8;

p[1] = 0x16;

p[2] = 0x00;

p[3] = 0x00;

p[4] = 0x00;

p[5] = 0xcb;

} /*到此结束*/

farcall(0, 1003 * 8);

memman_free_4k(memman, (int) p, finfo->size);

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}




凡是通过bim2hrb生成的hrb文件，其第4～7字节一定为“Hari”，因此程序通过判断第4～7字节的内容，将读取的数据先进行修改之后再运行。这样一来，不需要用二进制编辑器手工修改，程序应该也可以正常运行了。

我们来试试看，将之前修改过的hello3.hrb删除，然后重新“make run”一下。哇，成功啦！



不用二进制编辑器也能运行





3　保护操作系统（1）（harib18c）

接下来我们先稍微偏离一下主线，谈一谈关于操作系统保护的话题。

操作系统需要运行各种应用程序，而这些应用程序有可能是操作系统开发者编写的，也有可能是用户、别的软件开发商或者是某个自由软件作者出于善意编写的。然而，也有些人会出于恶意编写一些捣乱的应用程序出来。

最近大家都下载并安装了很多自由软件吧，那些软件的作者是否值得信赖呢？大多数人往往并不关心这一点，但某些情况下，下载的软件中可能包含着电脑病毒（当然，大多数情况下作者并非有意为之，而是作者的电脑不小心感染了病毒，导致发布出来的软件也感染了病毒）。

即便没有恶意，应用程序中也可能存在bug，而且某些bug可能会对操作系统造成破坏。所谓对操作系统的破坏，严重程度也不同，比如擅自删除重要文件、使其他任务的运行产生异常，或者造成操作系统死机而不得不重新启动等等。无论如何，这些都给用户造成了麻烦。

既然操作系统需要为应用程序的运行提供支持，也就必须考虑如何应对这样的问题。如果应用程序出了问题就会破坏操作系统的话，那大家都不敢用下载下来的软件了（当然，这样说夸张了些）。即便是自己编写的程序，一旦有了bug也可能会使操作系统遭到破坏，这实在是太可怕了。因此，如果稍微花点工夫就可以让操作系统变得更加安全，那我们没有理由不这样做。

值得庆幸的是，我们所使用的x86架构CPU为我们提供了保护操作系统的功能，只要我们学会运用这些功能完善操作系统的安全性，就可以最大限度地保护操作系统。我们的目标是：没有漏洞！

■■■■■

首先，我们来做一个用来捣乱的应用程序。

本次的crack1.c

void HariMain(void)

{

*((char *) 0x00102600) = 0;

return;

}




程序的功能很简单，向内存的0x102600地址写入一个0，虽说仅此而已，但破坏力却十分强大。这么说可能大家还不明白，我们来实际操作一下。

首先来“make run”，然后输入“crack1”……大家做好心理准备没？……按下回车。



破坏后的状态？

哎呀？貌似什么都没有发生嘛。其实系统已经彻底坏掉了，不信的话输入dir试试看。

重新启动一下系统就恢复了。真要不小心运行了这样的程序，除非重新启动，否则就什么都做不了了，这种程序我们必须在它产生破坏作用之前强行终止才行。



咚！命令错误！





4　保护操作系统（2）（harib18d）

到底怎样才能阻止crack1.hrb呢？它所干的坏事，其实就是擅自访问了本该由操作系统来管理的内存空间。我们需要为应用程序提供专用的内存空间，并且告诉它们“别的地方不许碰哦”。要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。

操作系统用代码段……2 * 8

操作系统用数据段……1 * 8

应用程序用代码段……1003 * 8

应用程序用数据段……1004 * 8

（3 * 8～1002 * 8为TSS所使用的段）

至于应用程序专用的内存空间，好吧，就先分配64KB吧（反正我们还可以根据需要进行调节）。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

char name[18], *p, *q; /*这里！*/



（中略）



if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

q = (char *) memman_alloc_4k(memman, 64 * 1024); /*这里！*/

*((int *) 0xfe8) = (int) p;

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER);

set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW); /*这里！*/

（中略）

start_app(0, 1003 * 8, 64 * 1024, 1004 * 8); /*这里！*/

memman_free_4k(memman, (int) p, finfo->size);

memman_free_4k(memman, (int) q, 64 * 1024); /*这里！*/

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}




这里出现的start_app是用来启动应用程序的函数。之前我们只是执行一个far-CALL，现在我们还要设置ESP和DS.SS。

本次的naskfunc.nas节选

_start_app: ; void start_app(int eip, int cs, int esp, int ds);

PUSHAD ; 将32位寄存器的值全部保存起来

MOV EAX,[ESP+36] ; 应用程序用EIP

MOV ECX,[ESP+40] ; 应用程序用CS

MOV EDX,[ESP+44] ; 应用程序用ESP

MOV EBX,[ESP+48] ; 应用程序用DS/SS

MOV [0xfe4],ESP ; 操作系统用ESP

CLI ; 在切换过程中禁止中断请求

MOV ES,BX

MOV SS,BX

MOV DS,BX

MOV FS,BX

MOV GS,BX

MOV ESP,EDX

STI ; 切换完成后恢复中断请求

PUSH ECX ; 用于far-CALL的PUSH(cs)

PUSH EAX ; 用于far-CALL的PUSH(eip)

CALL FAR [ESP] ; 调用应用程序



; 应用程序结束后返回此处



MOV EAX,1*8 ; 操作系统用DS/SS

CLI ; 再次进行切换，禁止中断请求

MOV ES,AX

MOV SS,AX

MOV DS,AX

MOV FS,AX

MOV GS,AX

MOV ESP,[0xfe4]

STI ; 切换完成后恢复中断请求

POPAD ; 恢复之前保存的寄存器值

RET




稍微有点复杂，大家看懂了吗？在向SS和DS赋值的时候，我们也同时向ES、FS和GS赋了值，这样做是为了以防万一。我们将操作系统栈的ESP保存在0xfe4这个地址，以便从应用程序返回操作系统时使用。

■■■■■

不过，光这样改还不够，当使用API时应用程序需要调用hrb_api，但hrb_api这个函数是用C语言编写的操作系统程序，因此如果不将段地址设回操作系统用的段就无法正常工作。于是我们还得修改_asm_hrb_api。

本次的naskfunc.nas节选

_asm_hrb_api:

; 为方便起见从开头就禁止中断请求

PUSH DS

PUSH ES

PUSHAD ; 用于保存的PUSH

MOV EAX,1*8

MOV DS,AX ; 先仅将DS设定为操作系统用

MOV ECX,[0xfe4] ; 操作系统的ESP

ADD ECX,-40

MOV [ECX+32],ESP ; 保存应用程序的ESP

MOV [ECX+36],SS ; 保存应用程序的SS



; 将PUSHAD后的值复制到系统栈



MOV EDX,[ESP ]

MOV EBX,[ESP+ 4]

MOV [ECX ],EDX ; 复制传递给hrb_api

MOV [ECX+ 4],EBX ; 复制传递给hrb_api

MOV EDX,[ESP+ 8]

MOV EBX,[ESP+12]

MOV [ECX+ 8],EDX ; 复制传递给hrb_api

MOV [ECX+12],EBX ; 复制传递给hrb_api

MOV EDX,[ESP+16]

MOV EBX,[ESP+20]

MOV [ECX+16],EDX ; 复制传递给hrb_api

MOV [ECX+20],EBX ; 复制传递给hrb_api

MOV EDX,[ESP+24]

MOV EBX,[ESP+28]

MOV [ECX+24],EDX ; 复制传递给hrb_api

MOV [ECX+28],EBX ; 复制传递给hrb_api



MOV ES,AX ; 将剩余的段寄存器也设为操作系统用

MOV SS,AX

MOV ESP,ECX

STI ; 恢复中断请求



CALL _hrb_api



MOV ECX,[ESP+32] ; 取出应用程序的ESP

MOV EAX,[ESP+36] ; 取出应用程序的SS

CLI

MOV SS,AX

MOV ESP,ECX

POPAD

POP ES

POP DS

IRETD ; 这个命令会自动执行STI




这次估计大家是真的看不懂了吧。不过只要仔细读一遍，还是能看懂个大概的。开头的PUSHAD是将值存到应用程序的栈中，因此使用操作系统栈的hrb_api无法读取这些值，我们需要特地把它们复制过来。因为怕麻烦，这次我们把FS和GS的设置给省略了。

这回总该改好了吧？别急，还差一点。大家已经不耐烦了吧？下面我们来修改中断的部分。在应用程序运行中也会产生中断请求，中断产生后会调用_inthandler20等操作系统内部的C语言函数，因此，我们还得对DS和SS进行切换才行。

本次的naskfunc.nas节选

_asm_inthandler20:

PUSH ES

PUSH DS

PUSHAD

MOV AX,SS

CMP AX,1*8

JNE .from_app

; 当操作系统活动时产生中断的情况和之前差不多

MOV EAX,ESP

PUSH SS ; 保存中断时的SS

PUSH EAX ; 保存中断时的ESP

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler20



ADD ESP,8

POPAD

POP DS

POP ES

IRETD

.from_app:

; 当应用程序活动时发生中断

MOV EAX,1*8

MOV DS,AX ; 先仅将DS设定为操作系统用

MOV ECX,[0xfe4] ; 操作系统的ESP

ADD ECX,-8

MOV [ECX+4],SS ; 保存中断时的SS

MOV [ECX ],ESP ; 保存中断时的ESP

MOV SS,AX

MOV ES,AX

MOV ESP,ECX

CALL _inthandler20

POP ECX

POP EAX

MOV SS,AX ; 将SS设回应用程序用

MOV ESP,ECX ; 将ESP设回应用程序用

POPAD

POP DS

POP ES

IRETD




这样总算可以运行了，asm_inthandler21和asm_inthandler2c也和上面大同小异。

如果你看不懂本节中这些汇编语言的程序也不要紧，忽略它们就是了。现在大家可能看得云里雾里的，但其实这个程序在今天之内就会消失不见的。为什么会这样呢？因为CPU实际上本身就有自动进行这种复杂段切换的功能，最终我们还是要用CPU本身的功能来实现。

有人可能会说，有那么方便的功能，为什么不一开始就用呢？笔者是想让大家先体验一下，如果不用CPU的功能实现起来有多么麻烦，先苦后甜嘛。话说回来，任务切换我们一开始就是用TSS来实现的，其实不用TSS也可以，差不多就像现在这样麻烦。由此看来，x86考虑到操作系统开发者的需求，提供了各种方便的功能，还真得感谢它呢。

这次我们还使用了以句点（.）开头的标签名，这是一种被称为本地标签的特殊标签。它基本上和普通的标签功能一样，区别在于即使标签名和其他函数中的标签重复，系统也能将它们区分开来。

■■■■■

好，现在我们应该可以运行hello.hrb这些应用程序了。虽说运行应用程序这种功能我们早就实现了，不过之前应用程序栈和系统栈是混在一起的，而现在我们将它们清晰地区分开了，虽然这种改变表面上看不出来，但却是相当了不起的。之所以这么说是因为只有写这么深奥的汇编语言代码才能把它们区分开，就冲这一点也相当了不起……你说是不是呢？（笑）

总之，我们先来“make run”试试。看，运行成功了。



成功运行了，不过表面上看不出什么区别

那么，我们在这里运行crack1.hrb会怎么样呢？大概电脑会出问题吧。因为我们虽然可以阻止这些有问题的程序，但还没有实现强制其终止的功能。不过“make run”试验一下，却发现电脑运行正常，输入dir也能正常列出文件，看起来防御是成功了。其实QEMU没有出错应该是QEMU本身的bug，因此大家千万别在真机上尝试哦。



bug导致crack1.hrb正常结束了 不过dir还是正常的





5　对异常的支持（harib18e）

接下来我们要实现强制结束程序的功能，完成这个功能之后，我们就可以在真机环境下测试crack1.hrb了。

要想强制结束程序，只要在中断号0x0d中注册一个函数即可，这是因为在x86架构规范中，当应用程序试图破坏操作系统，或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。

我们赶紧来写一个_asm_inthandler0d函数吧，代码和_asm_inthandler20大同小异。

本次的naskfunc.nas节选

_asm_inthandler0d:

STI

PUSH ES

PUSH DS

PUSHAD

MOV AX,SS

CMP AX,1*8

JNE .from_app

; 当操作系统活动时产生中断的情况和之前差不多

MOV EAX,ESP

PUSH SS ; 保存中断时的SS

PUSH EAX ; 保存中断时的ESP

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler0d

ADD ESP,8

POPAD

POP DS

POP ES

ADD ESP,4 ; 在INT 0x0d中需要这句

IRETD

.from_app:

; 当应用程序活动时产生中断

CLI

MOV EAX,1*8

MOV DS,AX ; 先仅将DS设定为操作系统用

MOV ECX,[0xfe4] ; 操作系统的ESP

ADD ECX,-8

MOV [ECX+4],SS ; 保存产生中断时的SS

MOV [ECX ],ESP ; 保存产生中断时的ESP

MOV SS,AX

MOV ES,AX

MOV ESP,ECX

STI

CALL _inthandler0d

CLI

CMP EAX,0

JNE .kill

POP ECX

POP EAX

MOV SS,AX ; 将SS恢复为应用程序用

MOV ESP,ECX ; 将ESP恢复为应用程序用

POPAD

POP DS

POP ES

ADD ESP,4 ; INT 0x0d需要这句

IRETD

.kill:

; 将应用程序强制结束

MOV EAX,1*8 ; 操作系统用的DS/SS

MOV ES,AX

MOV SS,AX

MOV DS,AX

MOV FS,AX

MOV GS,AX

MOV ESP,[0xfe4] ; 强制返回到start_app时的ESP

STI ; 切换完成后恢复中断请求

POPAD ; 恢复事先保存的寄存器值

RET




这个函数与_asm_inthandler20的主要区别在于增加了STI/CLI这样控制中断请求禁止、恢复的指令和根据inthandler0d的结果来执行强制结束应用程序的操作。在强制结束时，尽管中断处理完成了但却没有使用IRETD指令，而且还把栈强制恢复到start_app时的状态，使程序返回到cmd_app。可能大家会问，这种奇怪的做法真的没问题吗？是的，完全没问题。

然后我们又写了inthandler0d这样一个函数。

本次的console.c节选

int inthandler0d(int *esp)

{

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

cons_putstr0(cons, "\nINT 0D :\n General Protected Exception.\n");

return 1; /*强制结束程序*/

}




这里显示的信息“General Protection Exception”，翻译成中文就是“一般保护异常”，这其实是INT 0x0d的名称。“一般”就是一般性的意思，“保护”就是指对操作系统进行保护。除了一般性的异常，还有一些特殊的异常，这些异常并不是由应用程序的bug和破坏行为所引发的，而是其他种类的异常情况，特殊的的异常会由INT 0x0d以外的中断来处理。

接下来，我们将_asm_inthandler0d注册到IDT中。

本次的dsctbl.c节选

void init_gdtidt(void)

{

（中略）



/* IDT的设置*/

set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32); /* 这里！*/

set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32);



return;

}




好了，大功告成。

■■■■■

我们来“make run”，并运行crack1.hrb。



异常快出来！……咦？

好奇怪啊，居然没有发生异常，应该出来才对嘛……难道是程序哪里写错了吗？嗯……看上去也没什么问题啊。那我们在真机环境下试试看吧……啊，出来了！

看来，是QEMU对异常的模拟有点bug，而并不是“纸娃娃系统”的bug，大家可以放心了。





6　保护操作系统（3）（harib18f）

我们的“纸娃娃系统”终于可以成功防御crack1.hrb的攻击了，不过坏人们可不会就此善罢甘休哦，正所谓“道高一尺，魔高一丈”嘛。

站在坏人的角度，我们来想想有没有什么漏洞可以钻。操作系统会指定应用程序用的DS，因此破坏行为会发生异常，那么如果忽略操作系统指定的DS，而是用汇编语言直接将操作系统用的段地址存入DS的话，就又可以干坏事了。嘿嘿嘿。

本次的crack2.nas

[INSTRSET "i486p"]

[BITS 32]

MOV EAX,1*8 ; OS用的段号

MOV DS,AX ; 将其存入DS

MOV BYTE [0x102600],0

RETF




坏人：让你尝尝这招！

我们来“make run”，运行crack2.hrb试试看。PK开始了，结果呢……



没有出现异常！

没有出现异常……不过先别慌，估计又是QEMU的bug，只要没有出现异常，就应该是成功防御了攻击，可是……



dir也不显示了！中招了！

dir也不显示了，看来我们的“纸娃娃系统”这次中招了……





7　保护操作系统（4）（harib18g）

这次之所以会中招，是因为应用程序擅自向DS存入了操作系统用的段地址。那么我们只要想个办法，让应用程序无法使用操作系统的段地址不就好了吗？

大家可能会想：“说起来容易，但具体应该怎么做呢？”其实我们的x86架构正好有这样的功能。

在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用。当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

char name[13], *p, *q;

struct TASK *task = task_now(); /*这里！*/



（中略）



if (finfo != 0) {

/*找到文件的情况*/

（中略）

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60); /*从此开始*/

set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW + 0x60);

（中略）

start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &(task->tss.esp0)); /*到此结束*/

（中略）

}

/*没有找到文件的情况*/

return 0;

}




如果使用这次的方法，就必须在TSS中注册操作系统用的段地址和ESP，因此，我们在start_app中增加了用于传递注册地址的代码。

■■■■■

用上面的方法的话，在启动应用程序的时候我们需要让“操作系统向应用程序用的段执行far-CALL”，但根据x86的规则，是不允许操作系统CALL应用程序的（如果强行CALL的话会产生异常）。可能有人会想如果CALL不行的话JMP总可以吧，但在x86中“操作系统向应用程序用的段进行far-JMP”也是被禁止的。

那我们该怎么办呢？可以使用RETF。就像是被应用程序CALL过之后那样，事先将地址PUSH到栈中，然后执行RETF，这样就可以成功启动应用程序了。

可能有人会问：“为什么不可以从操作系统CALL/JMP应用程序呢！”笔者也搞不明白，还是打电话问英特尔公司的大叔吧——难道说这样设计可以减轻CPU的负担吗？

不过，从应用程序CALL操作系统是可以的（只是需要通过一些设置才能实现），这应该是为API而设计的。

之前我们一直讲RETF是当far-CALL调用后进行返回的指令，其实即便没有被CALL调用，也可以进行RETF。说穿了，RETF的本质就是从栈中将地址POP出来，然后JMP到该地址而已。因此正如这次我们所做的一样，可以用RETF来代替far-JMP的功能。

本次的naskfunc.nas节选

_start_app: ; void start_app(int eip, int cs, int esp, int ds, int *tss_esp0);

PUSHAD ; 将32位寄存器的值全部保存下来

MOV EAX,[ESP+36] ; 应用程序用EIP

MOV ECX,[ESP+40] ; 应用程序用CS

MOV EDX,[ESP+44] ; 应用程序用ESP

MOV EBX,[ESP+48] ; 应用程序用DS/SS

MOV EBP,[ESP+52] ; tss.esp0的地址

MOV [EBP ],ESP ; 保存操作系统用ESP

MOV [EBP+4],SS ; 保存操作系统用SS

MOV ES,BX

MOV DS,BX

MOV FS,BX

MOV GS,BX

; 下面调整栈，以免用RETF跳转到应用程序

OR ECX,3 ; 将应用程序用段号和3进行OR运算

OR EBX,3 ; 将应用程序用段号和3进行OR运算

PUSH EBX ; 应用程序的SS

PUSH EDX ; 应用程序的ESP

PUSH ECX ; 应用程序的CS

PUSH EAX ; 应用程序的EIP

RETF

; 应用程序结束后不会回到这里




关于将应用程序的段号和3进行OR运算的部分，是为用RETF调用应用程序而使用的一个小技巧，这里就先不详细讲解了。

这次由于我们并不是通过far-CALL来调用应用程序，因此应用程序也无法用RETF的方式结束并返回，后面我们得想别的办法来替代。

■■■■■

接受API调用的_asm_hrb_api也需要进行修改，改完之后比之前的版本还短。

本次的naskfunc.nas节选

_asm_hrb_api:

STI

PUSH DS

PUSH ES

PUSHAD ; 用于保存的PUSH

PUSHAD ; 用于向hrb_api传值的PUSH

MOV AX,SS

MOV DS,AX ; 将操作系统用段地址存入DS和ES

MOV ES,AX

CALL _hrb_api

CMP EAX,0 ; 当EAX不为0时程序结束

JNE end_app

ADD ESP,32

POPAD

POP ES

POP DS

IRETD

end_app:

; EAX为tss.esp0的地址

MOV ESP,[EAX]

POPAD

RET ; 返回cmd_app




怎么样，短了不少吧？现在的代码长度已经和我们尚未准备应用程序用的段之前差不多了，这多亏了CPU来帮我们自动执行那些麻烦的栈切换操作。

当hrb_api返回0时继续运行应用程序，当返回非0的值时则当作tss.esp0的地址来处理，强制结束应用程序。之所以需要这样的设计，是因为我们打算做一个结束程序用的API。这次我们不是用far-CALL来启动应用程序，自然也无法用RETF来结束，因此作为替代方案，我们需要做一个用于结束程序的API。

程序结束API分配到EDX = 4，修改后的hrb_api如下。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

int cs_base = *((int *) 0xfe8);

struct TASK *task = task_now(); /*这里！*/

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {



cons_putstr0(cons, (char *) ebx + cs_base);

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + cs_base, ecx);

} else if (edx == 4) { /*这里！*/

return &(task->tss.esp0); /*这里！*/

}

return 0; /*这里！*/

}




没有什么特别的难点，接下来我们照这样把inthandler0d也修改一下。

本次的console.c节选

int *inthandler0d(int *esp)

{

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

struct TASK *task = task_now(); /*这里！*/

cons_putstr0(cons, "\nINT 0D :\n General Protected Exception.\n");

return &(task->tss.esp0); /*让程序强制结束*/ /*这里！*/

}




■■■■■

中断处理的部分又要修改了，说是修改，其实也只不过是改回之前的版本而已。

本次的naskfunc.nas节选

_asm_inthandler20:

PUSH ES

PUSH DS

PUSHAD

MOV EAX,ESP

PUSH EAX

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler20

POP EAX

POPAD

POP DS

POP ES

IRETD




由于我们把麻烦的栈切换全部交给CPU来处理，因此程序又完全恢复到之前的样子了。我们把_asm_inthandler21和_asm_inthandler2c也改回去了。

中断处理的部分中，只有负责处理异常中断的_asm_inthandler0d没有完全改回之前的样子。

本次的naskfunc.nas节选

_asm_inthandler0d:

STI

PUSH ES

PUSH DS

PUSHAD

MOV EAX,ESP

PUSH EAX

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler0d

CMP EAX,0 ; 只有这里不同

JNE end_app ; 只有这里不同

POP EAX

POPAD

POP DS

POP ES

ADD ESP,4 ; 在INT 0x0d中需要这句

IRETD




不同的地方只有两处，像API一样，我们添加了用于强制结束的代码。

接下来，还要修改一下IDT的设置。在我们已经清晰地区分操作系统段和应用程序段的情况下，当应用程序试图调用未经操作系统授权的中断时，CPU会认为“这家伙乱用奇怪的中断号，想把操作系统搞坏，是坏人”，并产生异常。因此，我们需要在IDT中将INT 0x40设置为“可供应用程序作为API来调用的中断”。

本次的dsctbl.c节选

void init_gdtidt(void)

{

（中略）



/* IDT设置*/

set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32 + 0x60); /*这里！*/



return;

}




我们所谓的设置，就是将访问权编码加上0x60而已。至于其他的中断，并不是用于应用程序对操作系统的调用，而是用于键盘、鼠标等外部设备的控制，以及异常处理用的中断，因此禁止应用程序调用。

对了，应用程序也需要修改一下，因为已经不能通过RETF来结束程序了。

本次的hello.nas

[INSTRSET "i486p"]

[BITS 32]

MOV ECX,msg

MOV EDX,1

putloop:

MOV AL,[CS:ECX]

CMP AL,0

JE fin

INT 0x40

ADD ECX,1

JMP putloop

fin:

MOV EDX,4 ; 这里！

INT 0x40 ; 这里！

msg:

DB "hello",0




本次的hello2.nas

[INSTRSET "i486p"]

[BITS 32]

MOV EDX,2

MOV EBX,msg

INT 0x40

MOV EDX,4 ; 这里！

INT 0x40 ; 这里！

msg:

DB "hello",0




本次的a.c

void api_putchar(int c);

void api_end(void); /*这里！*/



void HariMain(void)

{

api_putchar('A');

api_end(); /*这里！*/

}




本次的a_nask.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "a_nask.nas"]



GLOBAL _api_putchar

GLOBAL _api_end ; 这里！



[SECTION .text]



_api_putchar: ; void api_putchar(int c);

MOV EDX,1

MOV AL,[ESP+4] ; c

INT 0x40

RET



_api_end: ; void api_end(void); ; 从此开始

MOV EDX,4

INT 0x40 ; 到此结束




本次的hello3.c

void api_putchar(int c);

void api_end(void); /*这里！*/



void HariMain(void)

{

api_putchar('h');

api_putchar('e');

api_putchar('l');

api_putchar('l');

api_putchar('o');

api_end(); /*这里！*/

}




本次的crack1.c

void api_end(void); /*这里！*/



void HariMain(void)

{

*((char *) 0x00102600) = 0;

api_end(); /*这里！*/

}




本次的crack2.nas

[INSTRSET "i486p"]

[BITS 32]

MOV EAX,1*8 ; 操作系统用段号

MOV DS,AX ; 将其存入DS

MOV BYTE [0x102600],0

MOV EDX,4 ; 这里！

INT 0x40 ; 这里！




好，这样就大功告成了！

■■■■■

我们来“make run”，先来看看以前能运行的程序现在还能不能正常运行。不错不错，貌似很顺利，太好了！



运行情况正常

下面运行一下做坏事的程序看看怎么样。哦哦，crack2.hrb貌似被强制结束了，我们的系统好厉害！



破坏行为被阻止了

话说，这次QEMU对异常的处理貌似又正常了，不错。

啊，不过crack1.hrb还是会正常结束，这是QEMU的bug，不过dir命令可以正常运行说明系统成功防御了攻击。那么我们用“make install”在真机环境下试验一下吧……很好很好，在真机环境下两个crack程序都产生了一般保护异常。

今天就到这里吧，大家晚上做个好梦，明天还要继续加油哦。





第22天　用C语言编写应用程序



保护操作系统（5）（harib19a）

帮助发现bug （harib19b）

强制结束应用程序（harib19c）

用C语言显示字符串（1）（harib19d）

用C语言显示字符串（2）（harib19e）

显示窗口（harib19f）

在窗口中描绘字符和方块（harib19g）





1　保护操作系统（5）（harib19a）

大家早上好。

在昨天的最后我们成功干掉了crack2.hrb，今天我们要尝试一下更厉害的攻击手段。所以说，从现在开始又要打开坏人模式了哟，嘿嘿嘿。

■■■■■

虽然把操作系统的段地址存入DS这一招现在已经不能用了，不过我可不会善罢甘休的。我要想个更厉害的招数，把使用“纸娃娃系统”的人推进恐怖的深渊，哈哈哈哈！

在操作系统管理的内存空间里搞破坏是行不通了，这次算你厉害，不过我还可以在定时器上动动手脚。这样一来，光标闪烁就会变得异常缓慢，任务切换的速度也会变慢，一定很不爽吧。嗯，光想想就觉得很有趣啊，嘿嘿嘿。

本次的crack3.nas

[INSTRSET "i486p"]

[BITS 32]

MOV AL,0x34

OUT 0x43,AL

MOV AL,0xff

OUT 0x40,AL

MOV AL,0xff

OUT 0x40,AL



; 上述代码的功能与下面代码相当

; io_out8(PIT_CTRL, 0x34);

; io_out8(PIT_CNT0, 0xff);

; io_out8(PIT_CNT0, 0xff);



MOV EDX,4

INT 0x40




好，完成了！赶紧“make run”，然后输入“crack3”，口中念念有词道：“可恶的‘纸娃娃系统’，吃我这招！”然后按下回车键。



可是失败了……

哎呀，有两下子嘛！可恶！

当以应用程序模式运行时，执行IN指令和OUT指令都会产生一般保护异常。当然，通过修改CPU设置，可以允许应用程序使用IN指令和OUT指令，不过这样大家会担心留下bug而遭到恶意攻击。

■■■■■

我还没输呢，这点挫折我可不会善罢甘休！既然如此，我就给你执行CLI然后再HLT，这样一来电脑就死机了。由于不再产生定时器中断，任务切换也会停止，键盘和鼠标中断也停止响应，除了按下机箱上的Reset按钮以外没有别的办法了。我真是个天才，哈哈哈哈！

本次的crack4.nas

[INSTRSET "i486p"]

[BITS 32]

CLI

fin:

HLT

JMP fin




这次一定要成功，“make run”！



又失败了……

又产生了异常，为什么啊！

当以应用程序模式运行时，执行CLI、STI和HLT这些指令都会产生异常。因为中断应该是由操作系统来管理的，应用程序不可以随便进行控制。不能执行HLT的话，应用程序就没办法省电了，不过一般情况下，这应该通过调用任务休眠API来实现，而不能由应用程序自己来执行HLT。此外，在多任务下，调用休眠API还可以让系统将CPU时间分配给其他任务。

连CLI也不让我执行吗？怎么会有这种事！这样的话不就干不成坏事了吗？难道只能缴械投降了？

哦哦，想起来了！操作系统里面不是有一个用来CLI的函数嘛，far-CALL这个函数不就行了吗？这样一来“纸娃娃系统”应该就会死机了。应该CALL哪个地址呢？只要有map文件就可以轻松找到了。

嗯嗯，map文件中有这样一行：

0x00000AC1 : _io_cli


我就来far-CALL这个地址吧，哈哈！

本次的crack5.nas

[INSTRSET "i486p"]

[BITS 32]

CALL 2*8:0xac1

MOV EDX,4

INT 0x40




嘿嘿，准备接招吧，“make run”！



还是失败了……

又产生异常了！到底为啥呀！能不能让我赢一次啊！可恶！

如果应用程序可以CALL任意地址的话，像这样的恶作剧就可以成功了，因此CPU规定除了设置好的地址以外，禁止应用程序CALL其他的地址。因此，“纸娃娃系统”中应用程序要调用操作系统只能采用INT 0x40的方法。

■■■■■

于是坏人只好失望地洗洗睡了（笑）。3天后……

有了！这次应该能行，我怎么早没想到这个办法呢？哈哈，这次绝对可以成功！

既然应用程序只能调用API，那么把API修改一下不就行了吗？

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

int cs_base = *((int *) 0xfe8);

struct TASK *task = task_now();

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

cons_putstr0(cons, (char *) ebx + cs_base);

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + cs_base, ecx);

} else if (edx == 4) {

return &(task->tss.esp0);

} else if (edx == 123456789) { /*这里！*/

*((char *) 0x00102600) = 0; /*这里！*/

}

return 0;

}




嘿嘿嘿，改好了，然后只要写这样一个应用程序就行了。

本次的crack6.nas

[INSTRSET "i486p"]

[BITS 32]

MOV EDX,123456789

INT 0x40

MOV EDX,4

INT 0x40




好啦！准备接招吧，“make run”！



没有异常……

没有产生异常！不过到底成功了没有呢？dir一下看看……成功了，消失了耶！这次我赢了，哈哈！

如果操作系统内部存在这种蠢到作茧自缚的API，那么再优秀的CPU也对此无能为力，操作系统只能束手就擒。即使操作系统原本没有这样的API，如果像这次一样被篡改的话，也有可能被植入后门。

要防止这种问题的发生，我们只能 “不安装不可靠的操作系统”了。如果大家都能遵守这条原则，就不会因为随意下载应用程序而弄坏电脑了——当然，如果操作系统本身就破绽百出的话就另当别论了。

这次的crack6.hrb其实只能在使用 “改版纸娃娃系统”的人身上发挥效果。如果对方不安装“改版纸娃娃系统”的话，即便运行了这个应用程序也不会发生任何问题。因此，就目前而言，这个应用程序的受害者就只有这个坏人自己而已，从这个角度来说，他“赢”得还真是空虚啊。

■■■■■

现在坏人已经走了，接下来我们继续做系统吧。





2　帮助发现bug（harib19b）

CPU的异常处理功能，除了可以保护操作系统免遭应用程序的破坏，还可以帮助我们在编写应用程序时及早发现bug。

我们来举个例子。

本次的bug1.c

void api_putchar(int c);

void api_end(void);



void HariMain(void)

{

char a[100];

a[10] = 'A'; /*这句当然没有问题*/

api_putchar(a[10]);

a[102] = 'B'; /*这句就有问题了*/

api_putchar(a[102]);

a[123] = 'C'; /*这句也有问题了*/

api_putchar(a[123]);

api_end();

}




这明显是个有bug的程序，因为a是一个100字节的数组，“A”的赋值显然没有问题，肯定会显示出“A”这个字符，但“B”的赋值就不行，因为它已经超出数组范围了；“C”的赋值当然也是不行的。

把这个程序“make run”一下，结果如下……咦？



运行成功了

本来我们以为会产生异常，结果却没有出现。我们在真机环境下试试看。

在真机环境下运行了一下，结果电脑自动重启了。嗯，这可不妙啊，电脑自动重启应该是产生了没有设置过的异常所导致的。

哦对了，坏人刚刚擅自加上去的API已经删掉了哦，crack应用程序也已经玩腻了，所以一起都删除了。

■■■■■

由于a这个数组是保存在栈中的，因此这次可能产生了栈异常。我们需要一个函数来处理栈异常，栈异常的中断号为0x0c1。

1 栈异常的中断号为0x0c：可能大家会问，除此之外还有什么异常呢？我们在这里补充讲解一下吧。根据CPU说明书，从0x00到0x1f都是异常所使用的中断，因此，IRQ的中断号都是从0x20之后开始的。其他一些比较有用的异常有0x00号除零异常（当试图除以0时产生）和0x06号非法指令异常（当试图执行CPU无法理解的机器语言指令，例如当试图执行一段数据时，有可能会产生）等。

本次的naskfunc.nas节选

_asm_inthandler0c:

STI

PUSH ES

PUSH DS

PUSHAD

MOV EAX,ESP

PUSH EAX

MOV AX,SS

MOV DS,AX

MOV ES,AX

CALL _inthandler0c

CMP EAX,0

JNE end_app

POP EAX

POPAD

POP DS

POP ES

ADD ESP,4 ; 在INT 0x0c中也需要这句

IRETD




然后，我们编写inthandler0c函数，只是将inthandler0d中的出错信息改了一下而已。

本次的console.c节选

int *inthandler0c(int *esp)

{

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

struct TASK *task = task_now();

cons_putstr0(cons, "\nINT 0C :\n Stack Exception.\n");

return &(task->tss.esp0); /*强制结束程序*/

}




当然，在IDT中也需要登记一下。

本次的dsctbl.c节选

void init_gdtidt(void)

{

（中略）



/* IDT的设置*/

set_gatedesc(idt + 0x0c, (int) asm_inthandler0c, 2 * 8, AR_INTGATE32); /*这里！*/

set_gatedesc(idt + 0x0d, (int) asm_inthandler0d, 2 * 8, AR_INTGATE32);



set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);

set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32 + 0x60);



return;

}




我们来“make run”一下试试看。啊，果然QEMU对异常的模拟有问题，因此程序还是可以顺利运行的，看来只能在真机环境下测试了。真机环境下成功产生了异常。

在真机环境下，显示出“AB”之后才产生异常，也就是说，写入的“C”被判定为异常，而“B”却被放过去了。从这个例子可以看出，异常并不能发现所有的bug。不过，比起一个bug都发现不了来说，哪怕能发现一个bug也是非常有帮助的，请大家一定要好好利用哦。

可能有人会问，为什么“C”会被判定为异常而“B”就可以被放过去呢？下面我们就来简单讲一讲。

a[102]虽然超出了数组的边界，但却没有超出为应用程序分配的数据段的边界，因此虽然这是个bug，CPU也不会产生异常。另一方面，a[123]所在的地址已经超出了数据段的边界，因此CPU马上就发现并产生了异常。

其实，CPU产生异常的目的并不是去发现bug，而是为了保护操作系统，它的思路是：“这个程序试图访问自身所在数据段以外的内存地址，一定是想擅自改写操作系统或者其他应用程序所管理的内存空间，这种行为岂能放任不管？”因此，即便CPU不能帮我们发现所有的bug，也不可以责怪它哦。

■■■■■

要想让它帮忙发现bug的话，最好是能知道引发异常的指令的地址。这个功能很简单，我们来加上去。

本次的console.c节选

int *inthandler0c(int *esp)

{

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

struct TASK *task = task_now();

char s[30]; /*这里！*/

cons_putstr0(cons, "\nINT 0C :\n Stack Exception.\n");

sprintf(s, "EIP = %08X\n", esp[11]); /*这里！*/

cons_putstr0(cons, s); /*这里！*/

return &(task->tss.esp0); /*强制结束程序*/

}



int *inthandler0d(int *esp)

{



struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

struct TASK *task = task_now();

char s[30]; /*这里！*/

cons_putstr0(cons, "\nINT 0D :\n General Protected Exception.\n");

sprintf(s, "EIP = %08X\n", esp[11]); /*这里！*/

cons_putstr0(cons, s); /*这里！*/

return &(task->tss.esp0); /*强制结束程序*/

}




上面代码的功能是，将esp（即栈）的11号元素（即EIP）显示出来。

另外，如果想要得到产生异常时其他寄存器的值，只要按照下表显示相应的元素即可。

esp[ 0] : EDI

esp[ 1] : ESI　　　　esp[0～7]为_asm_inthandler中PUSHAD的结果

esp[ 2] : EBP

esp[ 4] : EBX

esp[ 5] : EDX

esp[ 6] : ECX

esp[ 7] : EAX

esp[ 8] : DS　　　　 esp[8～9]为_asm_inthandler中PUSH的结果

esp[ 9] : ES

esp[10] : 错误编号（基本上是0，显示出来也没什么意思）

esp[11] : EIP

esp[12] : CS 　　　　esp[10～15]为异常产生时CPU自动PUSH的结果

esp[13] : EFLAGS

esp[14] : ESP 　（应用程序用ESP）

esp[15] : SS　　（应用程序用SS）

■■■■■

赶紧在真机环境下测试一下，运行bug1.hrb显示“EIP = 00000042”，我们来看看bug1.map的内容：

0x00000024 : _HariMain

0x00000052 : _api_putchar




看起来0x42这个地址是位于HariMain中。要查看得更详细的话，可以看一下bug1.lst文件：

11 00000000 _HariMain:




从这一行可以看出，在bug1.lst中，HariMain的地址暂且被当作是0（临时地址），而实际的地址要等到连接之后才能决定，因此nask是不知道的，只好先用.obj文件中的临时地址来生成.lst文件。连接后的HariMain实际地址记载于.map文件中，为0x24。

那么，0x42地址到底位于.lst文件的哪里呢？通过对比.map文件，我们发现.lst文件中的0x1e，就相当于EIP=0x42所指向的地址（因为0x24+0x1e=0x42）。

22 0000001E C6 45 0B 43 MOV BYTE [11+EBP],67




应该就是这里了，这正好就是将a[123]赋值为“C”的指令（“C”为0x43，即67）。

因此，我们可以确定，CPU真的是对这个bug做出了响应。





3　强制结束应用程序（harib19c）

现在我们的系统已经可以对付大部分恶意破坏和bug，变得越来越优秀了，不过，我们还需要一些别的功能，比如强制结束应用程序。

本次的bug2.c

void HariMain(void)

{

for (;;) { }

}




如果运行这样一个程序，将永远循环下去而无法结束。中断并没有被禁用，因此其他的任务还可以照常工作，不过这个任务总归要消耗一定的CPU运行时间，系统整体的速度就会变慢，还会白白浪费电。如果操作系统没有强制结束应用程序的功能，那么bug2.hrb也可以算是一个不错的恶意破坏程序了。

■■■■■

怎样实现强制结束功能呢？将某一个按键设定为强制结束键，按一下就可以结束程序，这样看起来不错。笔者本来想在console.c的console_task中编写当按下强制结束键时结束应用程序的处理，但是命令行窗口任务在应用程序运行的时候不会去读取FIFO缓冲区，强制结束键也就不管用了，因此我们还是换个方式吧。

于是，我们只好把强制结束处理写在其他的任务中，而bootpack.c看起来很适合。

强制结束键我们就定义为“Shift+F1”吧，当然，用其他的组合键也完全没问题，大家请按照自己的喜好修改吧。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct CONSOLE *cons;

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x3b && key_shift != 0 && task_cons->tss.ss0 != 0) { /* Shift+F1 */

cons = (struct CONSOLE *) *((int *) 0x0fec);

cons_putstr0(cons, "\nBreak(key):\n");

io_cli(); /*不能在改变寄存器值时切换到其他任务*/

task_cons->tss.eax = (int) &(task_cons->tss.esp0);

task_cons->tss.eip = (int) asm_end_app;

io_sti();

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




asm_app_end是将naskfunc.nas中的end_app改名之后得来的函数。

上述程序的工作原理是，当按下强制结束键时，改写命令行窗口任务的的寄存器值，并goto到asm_end_app，仅此而已。

这样一来程序会被强制结束，但也有个问题，那就是当应用程序没有在运行的时候，按下强制结束键会发生误操作。这样可不行，必须要确认task_cons —> tss.ss0不为0时才能继续进行处理。为此，我们还得进行一些修改，使得当应用程序运行时，该值一定不为0；而当应用程序没有运行时，该值一定为0。

本次的naskfunc.nas节选

_asm_end_app:

; EAX为tss.esp0的地址

MOV ESP,[EAX]

MOV DWORD [EAX+4],0 ; 这里！

POPAD

RET ; 返回cmd_app




本次的mtask.c节选

struct TASK *task_alloc(void)

{

int i;

struct TASK *task;

for (i = 0; i < MAX_TASKS; i++) {

if (taskctl->tasks0[i].flags == 0) {

task = &taskctl->tasks0[i];

task->flags = 1; /*正在使用的标志*/

task->tss.eflags = 0x00000202; /* IF = 1; */

task->tss.eax = 0; /*将其置为0*/

（中略）

task->tss.iomap = 0x40000000;

task->tss.ss0 = 0; /*这里！*/

return task;

}

}

return 0; /*已经全部正在使用*/

}




■■■■■

我们来“make run”，结果如下，按下“Shift+F1”就可以轻松结束应用程序了。



顺利结束了

我们再来创建一个bug3.hrb，该程序负责不断显示字符“a”。

本次的bug3.c

void api_putchar(int c);

void api_end(void);



void HariMain(void)

{

for (;;) {

api_putchar('a');

}

}




“make run”的结果如下。按下强制结束键就可以顺利停止了。



停止了的样子

也许在这个阶段就准备强制结束和异常处理还有点为时过早，因为我们还有很多功能想尽快实现。不过早点做好这些基础工作，笔者在后面制作示例程序时就会轻松很多（更容易发现bug），所以我们就把这部分内容放在今天做了。





4　用C语言显示字符串（1）（harib19d）

我们已经做好了用来显示字符串的API，却没做可供C语言调用该API的函数。不过这个很容易，我们现在就来做做看。

本次的a_nask.nas节选

_api_putstr0: ; void api_putstr0(char *s);

PUSH EBX

MOV EDX,2

MOV EBX,[ESP+8] ; s

INT 0x40

POP EBX

RET




利用上面的函数我们来写一个hello4.hrb。

本次的hello4.c

void api_putstr0(char *s);

void api_end(void);



void HariMain(void)

{

api_putstr0("hello, world\n");

api_end();

}




好，我们来“make run”……咦？什么都没显示出来，太奇怪了。



什么都没出来！

运行没成功感觉很不爽，不过在读程序排查原因思考对策的时候，想到了一件与此无关的事：既然已经不能用RETF指令来结束程序了，那么“Hari”那时候对开头6个字节的改写也用不到了吧。

去掉6个字节的改写之后，程序就不再JMP到0x1b了，因此start_app的地址也需要修改一下。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）



if (finfo != 0) {

/*找到文件的情况*/

（中略）

if (finfo->size >= 8 && strncmp(p + 4, "Hari", 4) == 0) {

start_app(0x1b, 1003 * 8, 64 * 1024, 1004 * 8, &(task->tss.esp0));

} else {

start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &(task->tss.esp0));

}

（中略）

}

（中略）

}




这样改过以后，hello3.hrb还能不能正常运行呢？我们来“make run”试验一下。哦哦，不错不错，运行正常，太完美了……不过hello4.hrb还是不行呢。





5　用C语言显示字符串（2）（harib19e）

为什么字符串显示API会失败呢？怎么想都不应该是a_nask.nas的问题，难道这次又是内存段的问题吗？于是我们对操作系统进行一点修改，使其在字符串显示API被调用的时候，显示EBX寄存器的值。

临时修改过的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

char s[12]; /*这里！*/

if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

/* cons_putstr0(cons, (char *) ebx + cs_base); */ /*从此开始*/

sprintf(s, "%08X\n", ebx);

cons_putstr0(cons, s); /*到此结束*/

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + cs_base, ecx);

} else if (edx == 4) {

return &(task->tss.esp0);

}

return 0;

}




将这个版本“make run”一下，然后运行hello4.hrb，屏幕上显示出00000400。这到底是怎么回事呢？hello4.hrb的文件大小只有114个字节，这样根本不可能显示出“hello, world”嘛。

■■■■■

为什么EBX里面会被写入这样一个匪夷所思的值呢？其实是因为连接了.obj文件的bim2hrb认为“hello, world”这个字符串就应该存放在0x400这个地址中。

由bim2hrb生成的.hrb文件其实是由两个部分构成的。



代码部分



数据部分





虽然有两个部分，不过之前我们一直都是不考虑数据部分的。当程序中没有使用字符串和外部变量（即在函数外面所定义的变量）时，就会生成不包含数据部分的.hrb文件，因此之前的程序都没有任何问题。

.hrb文件的数据部分会在应用程序启动时被传送到应用程序用的数据段中，而.hrb文件中数据部分的位置则存放在代码部分的开头一块区域中。现在是时候了，我们来详细讲解一下.hrb文件的结构吧。

由bim2hrb生成的.hrb文件，开头的36个字节不是程序，而是存放了下列这些信息（话说，bim2hrb就是笔者做出来的，如果对这个内容有意见的话，不用找英特尔或者微软，直接找笔者投诉就好了哦……笑）。

0x0000 (DWORD) ……请求操作系统为应用程序准备的数据段的大小

0x0004 (DWORD) ……“Hari”（.hrb文件的标记）

0x0008 (DWORD) ……数据段内预备空间的大小

0x000c (DWORD) ……ESP初始值&数据部分传送目的地址

0x0010 (DWORD) ……hrb文件内数据部分的大小

0x0014 (DWORD) ……hrb文件内数据部分从哪里开始

0x0018 (DWORD) ……0xe9000000

0x001c (DWORD) ……应用程序运行入口地址 - 0x20

0x0020 (DWORD) ……malloc空间的起始地址

我们来从上到下逐一讲解吧。

■■■■■

0x0000中存放的是数据段的大小。现在在“纸娃娃系统”中，应用程序用的数据段大小固定为64KB，但根据应用程序的内容，可能会需要更多的内存空间。那么把数据段都改成1MB不就好了吗？但这样一来，明明不需要那么多内存就可以运行的程序，也会被分配很大的内存空间，内存很快就会不够用了。因此，我们就在应用程序中先写好需要多大的内存空间。

0x0004中存放的是“Hari”这4个字节。这几个字符本来没什么用，只是操作系统用来判断这是不是一个应用程序文件的标记，在文件中写入这样的标记，说不定在某些情况下就会派上用场。也许在这个世界上，除了我们的“纸娃娃系统”以外，还会有其他的软件也使用.hrb这个扩展名，那样的话，光凭扩展名来判断文件的格式就有点危险了。因此，我们在文件中加上一个标记，并在操作系统中添加相应的判断功能，如果没有找到这个标记，则停止运行该文件。

如果我们不去确认“Hari”这个标记，而错误地运行了一个数据文件的话，这就和去运行一个JPEG文件差不多，会造成很严重的后果。不过现在我们使用了异常处理功能来保护操作系统，像磁盘数据被清除以及损坏电脑这种情况，已经完全可以避免了，而且操作系统也不会发生宕机。能做到这些，都是异常处理的功劳。

0x0008中存放的内容为“数据段内预备空间的大小”，不过这个值目前还没什么用（说不定以后也不会有什么用），大家不用管它就是了。在hello4.hrb中，这个值并没有被设置，所以为0。

0x000c中存放的是应用程序启动时ESP寄存器的初始值，也就是说在这个地址之前的部分会被作为栈来使用，而这个地址将被用于存放字符串等数据。在hello4.hrb中，这个值为0x400……也就是说ESP寄存器的初始值为0x400，并且分配了1KB的栈空间。1KB这个数是从哪里来的呢？其实是在生成hello4.bim的时候，在Makefile中设置的（注意看“stack:1k”这里！）。

hello4.bim : hello4.obj a_nask.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:hello4.bim stack:1k map:hello4.map \

hello4.obj a_nask.obj




■■■■■

0x0010中存放的是需要向数据段传送的部分的字节数。

0x0014中存放的是需要向数据段传送的部分在.hrb文件中的起始地址。

0x0018中存放的是0xe9000000这个数值，这个数在内存中存放的时候形式为“00 00 00 E9”。前面几个00的部分没什么用，后面的E9才是关键。其实E9是JMP指令的机器语言编码，和后面4个字节合起来的话，就表示JMP到应用程序运行的入口地址。

0x001c中存放的是应用程序运行入口地址减去0x20后的值。为什么不直接写上入口地址而是要减掉一个数呢？因为我们在0x0018（其实是0x001b）写了一个JMP指令，这样可以通过JMP指令跳转到应用程序的运行入口地址。通过这样的处理，只要先JMP到0x001b这个地址，程序就可以开始运行了。

0x0020中存放的是将来编写应用程序用malloc函数时要使用的地址，因此现在先不用管它。malloc这个函数和memman_alloc函数十分相似。

■■■■■

根据上面的讲解，我们来修改console.c。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

int segsiz, datsiz, esp, dathrb;

（中略）



if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);



file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

segsiz = *((int *) (p + 0x0000));

esp = *((int *) (p + 0x000c));

datsiz = *((int *) (p + 0x0010));

dathrb = *((int *) (p + 0x0014));

q = (char *) memman_alloc_4k(memman, segsiz);

*((int *) 0xfe8) = (int) q;

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60);

set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60);

for (i = 0; i < datsiz; i++) {

q[esp + i] = p[dathrb + i];

}

start_app(0x1b, 1003 * 8, esp, 1004 * 8, &(task->tss.esp0));

memman_free_4k(memman, (int) q, segsiz);

} else {

cons_putstr0(cons, ".hrb file format error.\n");

}

memman_free_4k(memman, (int) p, finfo->size);

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}




本次修改的要点如下：



文件中找不到“Hari”标志则报错。



数据段的大小根据.hrb文件中指定的值进行分配。



将.hrb文件中的数据部分先复制到数据段后再启动程序。





我们来“make run”一下。hello4.hrb运行成功了，但不是由bim2hrb生成的hello.hrb等程序就会出错。在以后的内容中，即便使用汇编语言编写应用程序，我们也需要先生成.obj文件，然后再生成.bim并转换成.hrb。这样一来即便将文件扩展名误写为.hrb，也不会发生运行不该运行的文件的风险了。



终于运行了

下面我们用一个例子来看看只用汇编语言编写应用程序的情形，我们写一段和hello4.c功能相同的程序。

本次的hello5.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "hello5.nas"]



GLOBAL _HariMain



[SECTION .text]



_HariMain:

MOV EDX,2

MOV EBX,msg

INT 0x40

MOV EDX,4

INT 0x40



[SECTION .data]



msg:

DB "hello, world", 0x0a, 0




将上面的程序make一下，得到78个字节的hello5.hrb，而同样内容的hello4.hrb却需要114个字节，果然还是汇编语言比较节省呢（笑）。

在WCOFF模式下的nask中必须要使用SECTION命令，这个命令是用来下达“将程序的这个部分放在代码段，将那个部分放在数据段”之类的指示（不过在.obj文件中不用“段”[segment]这个词，而是用“区”[section]，比如代码段在这里要被称为文本区[text section]。为什么呢？笔者也不知道，从一开始就是这样叫的，如果你有意见的话……笔者也不知道该去找谁投诉了，不好意思啦）。

■■■■■

如果大家明白了.hrb文件中所包含的信息，那么对于asmhead.nas启动bootpack.hrb的部分，应该也会理解得更透彻了。

说段题外话。在一般操作系统的可执行文件中都会加入像“Hari”这样的标记，不过通常情况下这个标记会放在文件的开头。例如，Windows的.exe文件开头两个字节内容就是“MZ”。那么.hrb文件中的标记为什么不放在开头，而是从第4个字节开始呢？下面来讲解一下。

笔者的考虑是，如果将标记存放在文件开头，有些普通的文本文件在偶然的情况下也有可能带有与标记相同的字符，从而被误认为是可执行文件。当然，我们还会通过扩展名来进行区分，所以一般情况下也不太会弄错，但如果扩展名可靠的话，就没必要加什么标记了。正是因为通过扩展名判断有时候会出错，我们才特地加了4个字节的标记，而如果不将标记放在文件开头可以进一步减少和普通文本文件混淆的可能性的话，那为什么不这样做呢？

开头的4个字节我们用来存放数据段的大小，而bim2hrb会自动将数据段大小调整为4KB的倍数，因此低位的8个比特总是0x00，也就是说，文件开头的第1个字节肯定是“00”。普通的文本文件不可能一上来就以“00”开头，因此就不大可能将文本文件误认为成可执行文件了。

将存放“Hari”的位置推后4个字节就可以如此显著地提高安全性，这应该算是个聪明的点子吧，至少笔者自己是这么认为的（笑）。





6　显示窗口（harib19f）

用应用程序显示字符已经玩腻了，这次我们来挑战让应用程序显示窗口吧。这要如何实现呢？我们只要编写一个用来显示窗口的API就可以了，听起来很简单吧。

这个API应该写成什么样呢？考虑了一番之后，我们决定这样设计。

EDX = 5

EBX = 窗口缓冲区

ESI = 窗口在x轴方向上的大小（即窗口宽度）

EDI = 窗口在y轴方向上的大小（即窗口高度）

EAX = 透明色

ECX = 窗口名称

调用后，返回值如下：

EAX =用于操作窗口的句柄（用于刷新窗口等操作）

确定思路之后，新的问题又来了：我们没有考虑如何在调用API之后将值存入寄存器并返回给应用程序。

不过说起来，在asm_hrb_api中我们执行了两次PUSHAD，第一次是为了保存寄存器的值，第二次是为了向hrb_api传递值。因此如果我们查出被传递的变量的地址，在那个地址的后面应该正好存放着相同的寄存器的值。然后只要修改那个值，就可以由POPAD获取修改后的值，实现将值返回给应用程序的功能。

我们来按这种思路编写程序。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

int ds_base = *((int *) 0xfe8);

struct TASK *task = task_now();

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);

struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4); /*从此开始*/

struct SHEET *sht;

int *reg = &eax + 1; /* eax后面的地址*/

/*强行改写通过PUSHAD保存的值*/

/* reg[0] : EDI, reg[1] : ESI, reg[2] : EBP, reg[3] : ESP */

/* reg[4] : EBX, reg[5] : EDX, reg[6] : ECX, reg[7] : EAX */ /*到此结束*/



if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

cons_putstr0(cons, (char *) ebx + ds_base);

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + ds_base, ecx);

} else if (edx == 4) {

return &(task->tss.esp0);

} else if (edx == 5) { /*从此开始*/

sht = sheet_alloc(shtctl);

sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax);

make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0);

sheet_slide(sht, 100, 50);

sheet_updown(sht, 3); /*背景层高度3位于task_a之上*/

reg[7] = (int) sht; /*到此结束*/

}

return 0;

}




shtctl的值是bootpack.c的HariMain中的变量，因此我们可以从0x0fe4地址获得。reg就是我们为了向应用程序返回值所动的手脚。

窗口我们就暂且显示在（100, 50）这个位置上，背景层高度3。

bootpack.c中也添加了1行。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

*((int *) 0x0fe4) = (int) shtctl;

（中略）

}




■■■■■

我们编写这样一个应用程序来测试。

本次的a_nask.nas节选

_api_openwin: ; int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

PUSH EDI

PUSH ESI

PUSH EBX

MOV EDX,5

MOV EBX,[ESP+16] ; buf

MOV ESI,[ESP+20] ; xsiz

MOV EDI,[ESP+24] ; ysiz

MOV EAX,[ESP+28] ; col_inv

MOV ECX,[ESP+32] ; title

INT 0x40

POP EBX

POP ESI

POP EDI

RET




本次的winhelo.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_end(void);



char buf[150 * 50];



void HariMain(void)

{

int win;

win = api_openwin(buf, 150, 50, -1, "hello");

api_end();

}




这些程序应该不用解释了吧？

■■■■■

我们来“make run”，好，快出现吧，窗口！……出来了！



显示出来了哦！





7　在窗口中描绘字符和方块（harib19g）

虽然时间已经很晚了，大家也很困了，不过看到成功显示出窗口，我们的精神又振奋了起来，所以我们再来试一下在窗口上显示字符和方块吧。这两个功能都是现成的，只要加在API上面就可以了。

在窗口上显示字符的API如下：

EDX = 6

EBX = 窗口句柄

ESI = 显示位置的x坐标

EDI = 显示位置的y坐标

EAX = 色号

ECX = 字符串长度

EBP = 字符串

描绘方块的API如下：

EDX = 7

EBX = 窗口句柄

EAX = x0

ECX = y0

ESI = x1

EDI = y1

EBP = 色号

哎哟，真悬，如果再多一个参数寄存器就要不够用了。

■■■■■

接下来就是写程序了，这个简单。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）



if (edx == 1) {

cons_putchar(cons, eax & 0xff, 1);

} else if (edx == 2) {

cons_putstr0(cons, (char *) ebx + ds_base);

} else if (edx == 3) {

cons_putstr1(cons, (char *) ebx + ds_base, ecx);



} else if (edx == 4) {

return &(task->tss.esp0);

} else if (edx == 5) {

（中略）

} else if (edx == 6) { /*从此开始*/

sht = (struct SHEET *) ebx;

putfonts8_asc(sht->buf, sht->bxsize, esi, edi, eax, (char *) ebp + ds_base);

sheet_refresh(sht, esi, edi, esi + ecx * 8, edi + 16);

} else if (edx == 7) {

sht = (struct SHEET *) ebx;

boxfill8(sht->buf, sht->bxsize, ebp, eax, ecx, esi, edi);

sheet_refresh(sht, eax, ecx, esi + 1, edi + 1); /*到此结束*/

}

return 0;

}




操作系统的修改完成了，下面来修改应用程序。

本次的a_nask.nas节选

_api_putstrwin: ; void api_putstrwin(int win, int x, int y, int col, int len, char *str);

PUSH EDI

PUSH ESI

PUSH EBP

PUSH EBX

MOV EDX,6

MOV EBX,[ESP+20] ; win

MOV ESI,[ESP+24] ; x

MOV EDI,[ESP+28] ; y

MOV EAX,[ESP+32] ; col

MOV ECX,[ESP+36] ; len

MOV EBP,[ESP+40] ; str

INT 0x40

POP EBX

POP EBP

POP ESI

POP EDI

RET



_api_boxfilwin: ; void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

PUSH EDI

PUSH ESI

PUSH EBP

PUSH EBX

MOV EDX,7

MOV EBX,[ESP+20] ; win

MOV EAX,[ESP+24] ; x0

MOV ECX,[ESP+28] ; y0

MOV ESI,[ESP+32] ; x1

MOV EDI,[ESP+36] ; y1

MOV EBP,[ESP+40] ; col

INT 0x40

POP EBX

POP EBP

POP ESI

POP EDI

RET




本次的winhelo2.c节选

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_putstrwin(int win, int x, int y, int col, int len, char *str);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_end(void);



char buf[150 * 50];



void HariMain(void)

{

int win;

win = api_openwin(buf, 150, 50, -1, "hello");

api_boxfilwin(win, 8, 36, 141, 43, 3 /*黄色*/);

api_putstrwin(win, 28, 28, 0 /*黑色*/, 12, "hello, world");

api_end();

}




■■■■■

大功告成，“make run”之后结果如下。对了，刚刚忘记说了，bug1.hrb已经没有用了，所以把它删掉了哦。



完成了！

运行得很顺利，心里相当满意呀。那么今天就到这里吧，大家晚安，明天见哦。





第23天　图形处理相关



编写malloc （harib20a）

画点（harib20b）

刷新窗口（harib20c）

画直线（harib20d）

关闭窗口（harib20e）

键盘输入API （harib20f）

用键盘输入来消遣一下（harib20g）

强制结束并关闭窗口（harib20h）





1　编写malloc（harib20a）

大家早上好，今天心情真不错，让我们来继续努力吧！

昨天我们显示出了窗口并绘制了方块、显示了文字，今天我们要来绘制更多的东西。不过，一开始我们先来做点别的事情。

■■■■■

今天早上在玩“纸娃娃系统”的时候发现一个问题，winhelo2.hrb居然有7.6KB。实现了窗口显示功能之后，可执行文件就一下子变得那么大，这令笔者十分不爽（注：笔者就喜欢短小精悍的程序）。

为了找原因，笔者用二进制编辑器打开winhelo2.hrb看了看，里面居然有很多的“00”，这到底是怎么回事！

于是笔者又回去检查了一遍源代码，发现原因在于winhelo2.c的char buf[150 * 50]; 这一句，这相当于在可执行文件中插入了150×50＝7500个字节的“00”，和汇编语言中的RESB 7500是等效的。

只要去掉这句，可执行文件就可以变小很多，问题是怎样才能实现呢？如果应用程序也有一个类似memman_alloc的函数用于分配内存空间就好了。在操作系统中，这样的功能一般被称为malloc，因此我们就来编写一个api_malloc函数吧。

■■■■■

如果api_malloc只是调用操作系统中的memman_alloc，并将分配到的内存空间地址返回给应用程序的话，是行不通的，因为通过memman_alloc所获得的内存空间并不位于应用程序的数据段范围内，应用程序是无法进行读写操作的。如果应用程序在不知情的情况下执行了读写操作，将会产生异常并强制结束。

说到底，应用程序可以进行读写的只是最开始操作系统为它准备好的数据段中的内存空间而已，那么如果我们一开始就将应用程序用的数据段分配得大一点，当需要malloc的时候从多余的空间里面拿出一小部分来交给应用程序不就好了吗？

其实，市面上大多数操作系统中，当请求malloc的时候会根据需要调整应用程序的段大小。而这次我们在“纸娃娃系统”中所采用的事先多分配内存空间的方法，实在算不上是个聪明的办法。

不过由于我们今后还会对操作系统进行各种改良，因此现在就先用这个笨办法将就一下吧，一开始就选择最聪明的办法还是很有难度的。

■■■■■

虽说我们要“事先多分配一些内存空间”，但如果由操作系统单方面定一个值，比如100KB，可能某些情况下不够用，某些情况下又浪费了，因此还是像栈一样，在编写应用程序的时候指定出来比较好。这样一来，当应用程序需要使用很多malloc时可以设定为1MB之类的，而当应用程序完全不需要使用malloc时则可以设定为0。

在哪里指定这个值呢？我们在用bim2hrb的时候指定。之前我们都是像下面这样直接指定为0的。

$(BIM2HRB) winhelo2.bim winhelo2.hrb 0


但这里如果改成3k的话，系统就会为malloc准备3KB的内存空间。

当指定了malloc所需内存大小时，这个数值会和栈等的大小进行累加，并写入.hrb文件最开头的4个字节中。因此，操作系统不需要做任何改动，就可以确保在应用程序段中分配到包括malloc所需部分在内的全部内存空间。

同时，malloc用的内存空间在数据段中的开始位置，被保存在.hrb文件的0x0020处。

■■■■■

既然如此，我们就可以将API设计成如下式样：

memman初始化

EDX=8

EBX=memman的地址

EAX=memman所管理的内存空间的起始地址

ECX=memman所管理的内存空间的字节数



malloc

EDX=9

EBX=memman的地址

ECX=需要请求的字节数

EAX=分配到的内存空间地址



free

EDX=10

EBX=memman的地址

EAX=需要释放的内存空间地址

ECX=需要释放的字节数

根据上述式样，我们来修改console.c。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 8) {

memman_init((struct MEMMAN *) (ebx + ds_base));

ecx &= 0xfffffff0; /*以16字节为单位*/

memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx);

} else if (edx == 9) {

ecx = (ecx + 0x0f) & 0xfffffff0; /*以16字节为单位进位取整*/

reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx);

} else if (edx == 10) {

ecx = (ecx + 0x0f) & 0xfffffff0; /*以16字节为单位进位取整*/

memman_free((struct MEMMAN *) (ebx + ds_base), eax, ecx);

}

return 0;

}




然后我们来编写应用程序。

本次的a_nask.nas节选

_api_initmalloc: ; void api_initmalloc(void);

PUSH EBX

MOV EDX,8

MOV EBX,[CS:0x0020] ; malloc内存空间的地址

MOV EAX,EBX

ADD EAX,32*1024 ; 加上32KB

MOV ECX,[CS:0x0000] ; 数据段的大小

SUB ECX,EAX

INT 0x40

POP EBX

RET



_api_malloc: ; char *api_malloc(int size);

PUSH EBX

MOV EDX,9

MOV EBX,[CS:0x0020]

MOV ECX,[ESP+8] ; size

INT 0x40

POP EBX

RET



_api_free: ; void api_free(char *addr, int size);

PUSH EBX

MOV EDX,10

MOV EBX,[CS:0x0020]

MOV EAX,[ESP+ 8] ; addr

MOV ECX,[ESP+12] ; size

INT 0x40

POP EBX

RET




本次的winhelo3.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_putstrwin(int win, int x, int y, int col, int len, char *str);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

void api_end(void);



void HariMain(void)

{

char *buf;

int win;



api_initmalloc();

buf = api_malloc(150 * 50);

win = api_openwin(buf, 150, 50, -1, "hello");

api_boxfilwin(win, 8, 36, 141, 43, 6 /*浅蓝色*/);

api_putstrwin(win, 28, 28, 0 /*黑色*/, 12, "hello, world");

api_end();

}




应该没有什么难点，不过，有一个地方需要注意：malloc用来管理内存的结构（struct MEMMAN）存放在malloc内存空间最开始的地方，因此要多申请出一些malloc所需的空间用于存放这个结构。那么，在winhelo3.hrb中总共申请了40k的空间（32+8=40）。

■■■■■

又到了“make run”的时间，在运行之前我们先用dir来看一下文件的大小。现在只有387个字节了，太好了！然后我们来运行程序……运行成功！



只有387个字节却运行成功了哦

当然，如果用nask来编写的话程序应该会更小，不过那实在能累死人，还是免了吧。





2　画点（harib20b）

终于进入今天的正题——图形处理了。虽然我们已经可以描绘字符和方块了，但现在却还不能画点呢。其实仔细想想，只要能画点就可以画出任何图形，画点简直是基本中的基本。然而就是这最基本的东西到现在都还没有实现，这是怎么搞的嘛！好了，我们马上来编写。

编写画点的API太麻烦了，笔者想要不就用画方块的API画一个1像素见方的小方块来代替好了……不过这样一来各位读者肯定会发飙的，还是不耍小聪明了，认认真真来编写这个API吧（笑）。

在窗口中画点

EDX =11

EBX =窗口句柄

ESI =显示位置的x坐标

EDI =显示位置的y坐标

EAX =色号

嗯，看上去挺简单的，三两下就能写出来了。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 11) {

sht = (struct SHEET *) ebx;

sht->buf[sht->bxsize * edi + esi] = eax;

sheet_refresh(sht, esi, edi, esi + 1, edi + 1);

}

return 0;

}




好，完工啦。

■■■■■

我们写一个什么样的应用程序好呢？可以画点的确意味着可以画出任何图形，不过这样一来就更不知道该干啥了。要不就在黑色的背景上画一个黄色的点吧，题曰“最亮的星”。

本次的a_nask.nas节选

_api_point: ; void api_point(int win, int x, int y, int col);

PUSH EDI

PUSH ESI

PUSH EBX

MOV EDX,11

MOV EBX,[ESP+16] ; win

MOV ESI,[ESP+20] ; x

MOV EDI,[ESP+24] ; y

MOV EAX,[ESP+28] ; col

INT 0x40

POP EBX

POP ESI

POP EDI

RET




本次的star1.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

void api_point(int win, int x, int y, int col);

void api_end(void);



void HariMain(void)

{

char *buf;

int win;

api_initmalloc();

buf = api_malloc(150 * 100);

win = api_openwin(buf, 150, 100, -1, "star1");

api_boxfilwin(win, 6, 26, 143, 93, 0 /*黑色*/);

api_point(win, 75, 59, 3 /*黄色*/);

api_end();

}




和之前一样，这个程序也相当简单，不过貌似光看名字就让人感觉这个程序很有料啊（笑）。

我们来“make run”，运行成功，意料之中。不过说起来，要是这么简单的程序还出错的话也太对不起笔者的实力了。



最亮的星星找到了！

■■■■■

做这种小程序当然会成功啦，所以没有以往的那种成就感啊，最好能再锦上添花一下。对了，我们就多画些星星吧，就画30个左右。

本次的stars.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

void api_point(int win, int x, int y, int col);

void api_end(void);



int rand(void); /*产生0～32767之间的随机数*/



void HariMain(void)

{

char *buf;

int win, i, x, y;

api_initmalloc();

buf = api_malloc(150 * 100);

win = api_openwin(buf, 150, 100, -1, "stars");

api_boxfilwin(win, 6, 26, 143, 93, 0 /*黑色*/);

for (i = 0; i < 50; i++) {

x = (rand() % 137) + 6;

y = (rand() % 67) + 26;

api_point(win, x, y, 3 /*黄色*/);

}

api_end();

}




我们来讲解一下这里出现的rand函数。这个函数和sprintf、strcmp一样，都是编译器自带的函数，它的功能是随机产生位于0～32767的一个数字，术语称为“随机数”，这个函数也可以称为“骰子函数”。

“%”这个运算符的功能是求除法运算的余数，在舍入取整的地方我们曾经讲到过，所以这里就一笔带过吧。将随机数的值除以123求余，结果一定落在0～122之间，也就是说，我们可以得到一个0～122的随机数。

其实所谓随机数也是通过计算得到的，电脑中不可能真有一个骰子，即便重新运行应用程序，得到的结果也总是一样的。因此大家“make run”之后所看到的星空，和笔者这里看到的应该是一样的。

于是我们来“make run”。出来了！



呼，星空真美丽呀！

可能有人会问，这些星座我怎么都没见过？要从哪个角度看星空才能看到这样的排列啊？咳咳，其实呢，这是从笔者的朋友所居住的外星球上所看到的星空哦。下次他还会不会乘坐UFO来地球玩呢……呵呵。





3　刷新窗口（harib20c）

在写stars.hrb的时候突然想到一个问题，现在每次调用api_point画点，窗口都会被刷新一次，这样感觉会非常慢，还不如把星星都画好之后，最后再刷新一次窗口，这样应该会快一些。

于是，我们需要在所有的窗口绘图命令中设置一个“不自动刷新”的选项，然后再编写一个仅用来刷新的API。

这个选项要如何指定呢？窗口句柄归根到底是struct SHEET的地址，这一定是一个偶数，那么我们可以让程序在指定一个奇数（即在原来的数值上加1）的情况下不进行自动刷新。

仅用来刷新的API式样如下。

刷新窗口

EDX = 12

EBX = 窗口句柄

EAX = x0

ECX = y0

ESI = x1

EDI = y1

■■■■■

修改操作系统，具体如下。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 6) {

sht = (struct SHEET *) (ebx & 0xfffffffe);

putfonts8_asc(sht->buf, sht->bxsize, esi, edi, eax, (char *) ebp + ds_base);

if ((ebx & 1) == 0) {

sheet_refresh(sht, esi, edi, esi + ecx * 8, edi + 16);

}

} else if (edx == 7) {

sht = (struct SHEET *) (ebx & 0xfffffffe);

boxfill8(sht->buf, sht->bxsize, ebp, eax, ecx, esi, edi);

if ((ebx & 1) == 0) {

sheet_refresh(sht, eax, ecx, esi + 1, edi + 1);

}

} else if (edx == 8) {

（中略）

} else if (edx == 9) {

（中略）

} else if (edx == 10) {

（中略）

} else if (edx == 11) {

sht = (struct SHEET *) (ebx & 0xfffffffe);

sht->buf[sht->bxsize * edi + esi] = eax;

if ((ebx & 1) == 0) {

sheet_refresh(sht, esi, edi, esi + 1, edi + 1);

}

} else if (edx == 12) {

sht = (struct SHEET *) ebx;

sheet_refresh(sht, eax, ecx, esi, edi);

}

return 0;

}




在计算sht的地方，我们将ebx和0xfffffffe做了一个AND运算，即对其按2的倍数取整。然后在判断是否需要刷新的if语句中，我们将ebx最低的一个比特用AND取出，判断其是否为0，如为0则表示其除以2的余数为0，也就是偶数。

■■■■■

用上面的功能，我们来编写stars2.c。

本次的a_nask.nas节选

_api_refreshwin: ; void api_refreshwin(int win, int x0, int y0, int x1, int y1);

PUSH EDI

PUSH ESI

PUSH EBX

MOV EDX,12

MOV EBX,[ESP+16] ; win

MOV EAX,[ESP+20] ; x0

MOV ECX,[ESP+24] ; y0

MOV ESI,[ESP+28] ; x1

MOV EDI,[ESP+32] ; y1

INT 0x40

POP EBX

POP ESI

POP EDI

RET




本次的stars2.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

void api_point(int win, int x, int y, int col);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_end(void);



int rand(void); /*产生0～32767的随机数*/



void HariMain(void)

{

char *buf;

int win, i, x, y;

api_initmalloc();

buf = api_malloc(150 * 100);

win = api_openwin(buf, 150, 100, -1, "stars2");

api_boxfilwin(win + 1, 6, 26, 143, 93, 0 /*黑色*/);

for (i = 0; i < 50; i++) {

x = (rand() % 137) + 6;

y = (rand() % 67) + 26;

api_point(win + 1, x, y, 3 /*黄色*/);

}

api_refreshwin(win, 6, 26, 144, 94);

api_end();

}




好了，这个也很简单吧。大功告成，我们来“make run”试试看。运行成功了，画面和stars.hrb没区别，那到底速度有没有变快呢？嗯，两个都很快所以看不出来，肯定是变快了吧。





4　画直线（harib20d）

现在我们已经可以显示文字、描绘方块，还能够画点，接下来我们应该实现画直线的功能了。

画直线的基本方法概括如下。

for (i = 0; i < len; i++) {

api_point(win, x, y, col);

x += dx;

y += dy;

}




len表示直线的长度，x和y表示直线的起点坐标，dx和dy表示直线延伸的方向。不过这样用起来很麻烦，最好是只要指定直线两端的坐标，就可以自动计算出dx、dy和len并画出直线，那么我们就按这个思路来编写API吧。

dx和dy这两个值如果太大的话，点与点之间的间隔就会空得很大，看上去就变成虚线了；反过来说，如果dx和dy取值太小，画点的坐标就无法前进，会导致多次在同一个坐标上画点，浪费CPU的处理能力。

■■■■■

此外，x和y，以及dx和dy如果不支持小数的话，就画不出漂亮的直线（假如只支持整数，某些情况下画出来的就是虚线了）。不过现在我们还没有做好使用小数的准备，不能使用小数，因此我们将这4个整数预先扩大1000倍，即下面这样：

for (i = 0; i < len; i++) {

api_point(win, x / 1000, y / 1000, col);

x += dx;

y += dy;

}




这样一来，如果x为100000，dx为123，就相当于用整数实现了将100每次累加0.123这样的运算。

实际上，除以1000的运算速度不怎么快，所以我们改成除以1024。再进一步说，其实我们使用的根本不是除法运算，而是右移10比特的方法，这等效于除以1024，而之所以使用移位运算，当然是因为它比除法运算速度要快。因为除数改成了1024，所以如果要表示0.5的话应该使用512而不是500了。

■■■■■

关于 dx和dy等值详细的计算方法请看下面的程序。

本次的API式样如下。

在窗口上画直线

EDX = 13

EBX = 窗口句柄

EAX = x0

ECX = y0

ESI = x1

EDI = y1

EBP = 色号

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 13) {

sht = (struct SHEET *) (ebx & 0xfffffffe);

hrb_api_linewin(sht, eax, ecx, esi, edi, ebp);

if ((ebx & 1) == 0) {

sheet_refresh(sht, eax, ecx, esi + 1, edi + 1);

}

}

return 0;

}



void hrb_api_linewin(struct SHEET *sht, int x0, int y0, int x1, int y1, int col)

{

int i, x, y, len, dx, dy;



dx = x1 - x0;

dy = y1 - y0;

x = x0 << 10;

y = y0 << 10;

if (dx < 0) {

dx = - dx;

}

if (dy < 0) {

dy = - dy;

}

if (dx >= dy) {

len = dx + 1;

if (x0 > x1) {

dx = -1024;

} else {

dx = 1024;

}



if (y0 <= y1) {

dy = ((y1 - y0 + 1) << 10) / len;

} else {

dy = ((y1 - y0 - 1) << 10) / len;

}

} else {

len = dy + 1;

if (y0 > y1) {

dy = -1024;

} else {

dy = 1024;

}

if (x0 <= x1) {

dx = ((x1 - x0 + 1) << 10) / len;

} else {

dx = ((x1 - x0 - 1) << 10) / len;

}

}



for (i = 0; i < len; i++) {

sht->buf[(y >> 10) * sht->bxsize + (x >> 10)] = col;

x += dx;

y += dy;

}



return;

}




我们来讲解一下这段程序。程序首先要做的是计算len，通过比较直线起点和终点的坐标，将变化比较大的作为len（实际上还需要加上1）。为什么要加上1呢？因为如果不这样做的话，画到最后就会差1个像素。举个例子，当起点和终点完全相同时，应该在画面上画出1个点才对，但此时dx和dy都为0，如果不加1就什么都画不出来了。

len计算出来以后，接着计算dx和dy。将变化比较大的一方设为1024或者-1024（即1或-1），变化较小的一方用变化量去除以len。在做除法的时候我们还是会进行加1和减1的运算，这有点像烧菜用的秘方，是个很微妙的小技巧，下面我们来讲一讲这个秘方的效果吧。

如果不用这个小技巧的话，假设我们需要画一条从（100, 100）到（159, 102）的直线，则dy为2 / 60，约为0.0333。



不用小技巧的情况（x = 100, y= 100, dx = 1, dy = 0.0333, len = 60）

这样不行，画这条直线的时候y明明需要增加2，但这里只增加了1。如果我们加上这个小技巧的话，dy的计算就变成了3 / 60，即0.05。



用了小技巧的情况（x = 100, y= 100, dx = 1, dy = 0.05, len = 60）

■■■■■

好，我们来编写测试用的应用程序吧。

本次的a_nask.nas节选

_api_linewin: ; void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

PUSH EDI

PUSH ESI

PUSH EBP

PUSH EBX

MOV EDX,13

MOV EBX,[ESP+20] ; win

MOV EAX,[ESP+24] ; x0

MOV ECX,[ESP+28] ; y0

MOV ESI,[ESP+32] ; x1

MOV EDI,[ESP+36] ; y1

MOV EBP,[ESP+40] ; col

INT 0x40

POP EBX

POP EBP

POP ESI

POP EDI

RET




本次的lines.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_initmalloc(void);

char *api_malloc(int size);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

void api_end(void);



void HariMain(void)

{

char *buf;

int win, i;

api_initmalloc();

buf = api_malloc(160 * 100);

win = api_openwin(buf, 160, 100, -1, "lines");

for (i = 0; i < 8; i++) {

api_linewin(win + 1, 8, 26, 77, i * 9 + 26, i);

api_linewin(win + 1, 88, 26, i * 9 + 88, 89, i);

}

api_refreshwin(win, 6, 26, 154, 90);

api_end();

}




我们来“make run”，希望一切顺利。成功了！



画出直线了哦

美丽的星空……哦不对，这不是星空，不过感觉比stars看上去要高级多了，难道是笔者自我感觉良好吗？





5　关闭窗口（harib20e）

现在我们终于可以在窗口上画线玩了，不过一个重大的问题出现了：在应用程序结束之后，窗口依然还留在画面上。

这是因为系统为留在画面上的这个窗口分配了应用程序的数据段作为存放窗口图层的内存空间，当应用程序活动时没有任何问题，但当应用程序运行结束后，其数据段的内存空间就被释放出来，供操作系统及其他应用程序来使用。所以这样不行。

因此在应用程序结束之前，我们需要先关闭窗口。

■■■■■

首先还是像之前一样，编写一个API。

关闭窗口

EDX=14

EBX=窗口句柄

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 14) {

sheet_free((struct SHEET *) ebx);

}

return 0;

}




非常简单吧。

然后我们来编写应用程序。写一个新的应用程序太麻烦了，我们就用之前的lines.c修改一下。

本次的a_nask.nas节选

_api_closewin: ; void api_closewin(int win);

PUSH EBX

MOV EDX,14

MOV EBX,[ESP+8] ; win

INT 0x40

POP EBX

RET




本次的lines.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_initmalloc(void);

char *api_malloc(int size);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

void api_closewin(int win);

void api_end(void);



void HariMain(void)

{

char *buf;

int win, i;

api_initmalloc();

buf = api_malloc(160 * 100);

win = api_openwin(buf, 160, 100, -1, "lines");

for (i = 0; i < 8; i++) {

api_linewin(win + 1, 8, 26, 77, i * 9 + 26, i);

api_linewin(win + 1, 88, 26, i * 9 + 88, 89, i);

}

api_refreshwin(win, 6, 26, 154, 90);

api_closewin(win); /*这里！ */

api_end();

}




好了，大功告成，这个也挺简单的呢。

我们来“make run”试试看吧。哦哦，运行成功，窗口消失了。



看，窗口消失了吧？

嗯，不过这样一来，窗口只显示了一下就瞬间消失了，我们连显示出来的内容都看不清。在程序结束之前关闭窗口固然很好，可是这样的话显示窗口就没有意义了嘛。





6　键盘输入API（harib20f）

那么，我们就给这个应用程序增加接受键盘输入的功能，当按下回车键时再结束运行，这样就不会出现窗口显示时间过短的问题了。

要接受键盘输入，其实只要从和任务绑定的FIFO缓冲区中取出1个就可以了。哦对了，等待键盘输入的这段时间程序没有什么事情好做，因此我们还要加上休眠的功能。

键盘输入

EDX = 15

EAX = 0……没有键盘输入时返回-1，不休眠

　 　 = 1……休眠直到发生键盘输入

EAX = 输入的字符编码

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

int ds_base = *((int *) 0xfe8);

（中略）

int i;

（中略）

} else if (edx == 15) {

for (;;) {



io_cli();

if (fifo32_status(&task->fifo) == 0) {

if (eax != 0) {

task_sleep(task); /* FIFO为空，休眠并等待*/

} else {

io_sti();

reg[7] = -1;

return 0;

}

}

i = fifo32_get(&task->fifo);

io_sti();

if (i <= 1) { /*光标用定时器*/

/*应用程序运行时不需要显示光标，因此总是将下次显示用的值置为1*/

timer_init(cons->timer, &task->fifo, 1); /*下次置为1*/

timer_settime(cons->timer, 50);

}

if (i == 2) { /*光标ON */

cons->cur_c = COL8_FFFFFF;

}

if (i == 3) { /*光标OFF */

cons->cur_c = -1;

}

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/

reg[7] = i - 256;

return 0;

}

}

}

return 0;

}




这次的代码有点长。首先，从整体上看，我们通过一个for语句来进行循环。为什么要这样做呢？当FIFO为空或成功接收到键盘输入后循环结束，在这个过程里，FIFO中还会收到诸如计时器光标ON、OFF之类的数据，这时，我们需要简单地将它们处理掉，然后再重新循环轮询FIFO的状态。当确认接收到键盘输入的数据，或者FIFO缓冲区为空时，则通过return命令结束API的处理。这样一来，从结果上来说，就相当于跳出了for循环。

这段程序是仿照console_task的FIFO数据处理部分写的，将它们对比着看应该会更容易理解。

还有cons —> timer的地方需要讲一下。为了设置定时器我们需要timer的地址，不过这是console_task中的变量，hrb_api是无法获取的，虽然像ds_base的时候那样，随便找一个地址存放一下也可以解决，不过这次我们采用了不同的方法。

本次的bootpack.h节选

struct CONSOLE {

struct SHEET *sht;

int cur_x, cur_y, cur_c;

struct TIMER *timer;

};




像这样，我们将定时器加入到struct CONSOLE中了。因为这个定时器是用来控制光标闪烁的，对于命令行窗口来说是必需的，所以放在CONSOLE结构中也没什么问题（笔者希望将相关的成员都封装到同一个结构中）。

因此我们还修改了console_task，去掉timer变量，以cons.timer取而代之。

■■■■■

操作系统的修改已经完成了，接下来轮到应用程序了。写一个新程序太麻烦，所以我们还是来改造lines.c吧。

本次的a_nask.nas节选

_api_getkey: ; int api_getkey(int mode);

MOV EDX,15

MOV EAX,[ESP+4] ; mode

INT 0x40

RET




本次的lines.c节选

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_initmalloc(void);

char *api_malloc(int size);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

void api_closewin(int win);

int api_getkey(int mode);

void api_end(void);



void HariMain(void)

{

（中略）

api_refreshwin(win, 6, 26, 154, 90);

for (;;) {

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break; */

}

}

api_closewin(win);

api_end();

}




写好啦。应用程序很简单，当然，编写API也不是什么很难的事情啦。

我们赶紧“make run”吧，不知道能不能成功呢。哦哦，这次没有马上消失！



看，这次不会自动消失了哦

而且，按空格键或者其他字母键都没有反应，但按下回车键时窗口就关闭了，看来很成功呢。



按下回车键程序结束





7　用键盘输入来消遣一下（harib20g）

既然我们已经实现了键盘输入，不如多用它来消遣消遣吧，边玩边做才有乐趣嘛。

于是我们编写了下面这个程序，只看代码的话，能猜出这是个怎样的程序吗？

本次的walk.c节选

void HariMain(void)

{

char *buf;

int win, i, x, y;

api_initmalloc();

buf = api_malloc(160 * 100);

win = api_openwin(buf, 160, 100, -1, "walk");

api_boxfilwin(win, 4, 24, 155, 95, 0 /*黑色*/);

x = 76;

y = 56;



api_putstrwin(win, x, y, 3 /*黄色*/, 1, "*");

for (;;) {

i = api_getkey(1);

api_putstrwin(win, x, y, 0 /*黑色*/, 1, "*"); /*用黑色擦除*/

if (i == '4' && x > 4) { x -= 8; }

if (i == '6' && x < 148) { x += 8; }

if (i == '8' && y > 24) { y -= 8; }

if (i == '2' && y < 80) { y += 8; }

if (i == 0x0a) { break; } /*按回车键结束*/

api_putstrwin(win, x, y, 3 /*黄色*/, 1, "*");

}

api_closewin(win);

api_end();

}




简单来说，这个程序是让“*”在窗口中移动，按小键盘的“5”让它回到窗口中心，按“2”、“4”、“6”、“8”可以上下左右移动，玩累了按下回车键就可以退出程序啦。

那么我们来“make run”试试看，画面如下。



我走我走我走……

如果将“*”这个字符换成一个帅气的卡通人物，将黑色的背景换成更漂亮的背景的话，我们就可以做一个RPG（角色扮演游戏）了呢。不过笔者可不会这么做哦（如果真这么做的话，这本讲操作系统编写方法的书就成了讲RPG制作的书了……笑）。

在Linux中有一个很有名的游戏叫做nethack，如果喜欢那个游戏的话，把“*”改成“@”说不定会更好哦（笑）。





8　强制结束并关闭窗口（harib20h）

眼看天色已晚，本打算今天就到此结束的，却突然发现了一个问题。

在运行walk.hrb和lines.hrb时，如果不按回车键结束，而是按Shift+F1强制结束程序的话，窗口就会残留在画面上。话说回来，强制结束的时候还并没有执行api_closewin，窗口会留在画面上也是意料之中的事情，不过应用程序已经强制结束，内存空间也已经被回收，而窗口却还留在上面，这可不太好。

带着这样的问题肯定没办法睡个好觉，说不定还会做噩梦，所以我们还是在今晚把它搞定吧。



强制结束harib20g后就变成这样了！

■■■■■

到底该怎么办呢？首先，我们在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序任务，则关闭该图层。

这个功能不仅是在强制结束的时候起作用，在正常结束时一样有效，因此，即便程序本身忘记加上关闭窗口的代码，系统也会自动将窗口关闭，进一步说，应用程序甚至可以完全依靠系统的这个功能，而不必特地调用api_closewin来关闭窗口了。

本次的bootpack.h节选

struct SHEET {

unsigned char *buf;

int bxsize, bysize, vx0, vy0, col_inv, height, flags;

struct SHTCTL *ctl;

struct TASK *task; /*这里！*/

};




本次的sheet.c节选

struct SHEET *sheet_alloc(struct SHTCTL *ctl)

{

struct SHEET *sht;

int i;

for (i = 0; i < MAX_SHEETS; i++) {

if (ctl->sheets0[i].flags == 0) {

sht = &ctl->sheets0[i];

sht->flags = SHEET_USE; /*正在使用的标记*/

sht->height = -1; /*不显示*/

sht->task = 0; /*不使用自动关闭功能*/ /*这里！*/

return sht;

}

}

return 0; /*所有的图层都正在使用*/

}




本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 5) {

sht = sheet_alloc(shtctl);

sht->task = task; /*这里！*/

sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax);

make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0);

sheet_slide(sht, 100, 50);

sheet_updown(sht, 3); /*图层高度为3，在task_a之上*/

reg[7] = (int) sht;

} else if (edx == 6) {

（中略）

}




本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

struct SHTCTL *shtctl; /*从此开始*/

struct SHEET *sht; /*到此结束*/

（中略）

if (finfo != 0) {

/*找到文件的情况*/

p = (char *) memman_alloc_4k(memman, finfo->size);

file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

start_app(0x1b, 1003 * 8, esp, 1004 * 8, &(task->tss.esp0));

shtctl = (struct SHTCTL *) *((int *) 0x0fe4); /*从此开始*/

for (i = 0; i < MAX_SHEETS; i++) {

sht = &(shtctl->sheets0[i]);

if (sht->flags != 0 && sht->task == task) {

/*找到被应用程序遗留的窗口*/

sheet_free(sht); /*关闭*/

}

} /*到此结束*/

memman_free_4k(memman, (int) q, segsiz);

} else {

cons_putstr0(cons, ".hrb file format error.\n");

}

memman_free_4k(memman, (int) p, finfo->size);

cons_newline(cons);

return 1;

}

/*没有找到文件的情况*/

return 0;

}




这样就大功告成了。

■■■■■

我们来试验一下，“make run”，然后运行lines.hrb，按Shift+F1强制结束。运行成功了！



看，窗口不见了吧？

下面我们再用winhelo3.hrb试试看，这个程序中我们没有调用closewin，不知道窗口能不能自动关闭呢？哦哦，关闭了，虽说这样就完全看不清窗口显示的内容了（笑），但只要像lines和walk那样加上等待键盘输入再结束的功能就好了。



winhelo3.hrb在程序结束时窗口也会被关闭哦

好了，我们已经成功实现了强制结束时也能关闭窗口的功能，这下可以睡个好觉了，大家晚安……





第24天　窗口操作



窗口切换（1）（harib21a）

窗口切换（2）（harib21b）

移动窗口（harib21c）

用鼠标关闭窗口（harib21d）

将输入切换到应用程序窗口（harib21e）

用鼠标切换输入窗口（harib21f）

定时器API （harib21g）

取消定时器（harib21h）





1　窗口切换（1）（harib21a）

前天开始我们的应用程序可以显示自己的窗口了，现在画面上到处都是窗口，我们急需能够切换窗口顺序的功能，使得在需要的时候可以查看最下面的窗口的内容。这个功能看起来不难，我们马上来实现它。

不过，一上来就实现“点击鼠标切换窗口”的功能还有点难，所以我们先从用键盘切换的方法入手吧，即按下F11时，将最下面的那个窗口放到最上面。

■■■■■

要实现这一功能我们首先需要知道F11的按键编码。根据下面网址中的资料：

http://community.osdev.info/?(AT)keyboard

F11的按键编码为0x57（F12为0x58）。知道了这些，接下来只要稍微修改一下bootpack.c即可，只需要添加3行代码。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

/*从此开始*/ if (i == 256 + 0x57 && shtctl->top > 2) { /* F11 */

sheet_updown(shtctl->sheets[1], shtctl->top - 1);

/*到此结束*/ }

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




恐怕没几个人记得图层的操作方法了吧，我们还是稍微详细地讲解一下。

sheet_updown(shtctl->sheets[1], shtctl->top - 1);




这句代码的功能是将从下面数第2个图层（最下面一个图层shtctl —> sheets[0]是背景）的高度提升为shtctl —> top –1。Shtctl —> top这个高度存放的是最上面一个图层的高度，这个图层永远是绘制鼠标指针用的，我们不能将窗口放在比鼠标还高的位置上（搞个恶作剧倒是挺有趣的），因此将窗口高度设置为鼠标图层的下面一层。

我们来试试看能不能成功，“make run”——虽然我们已经做了无数遍，但笔者还是乐在其中。撒花！运行成功了！

■■■■■



按一次F11，将命令行窗口提升到了上面





2　窗口切换（2）（harib21b）

这次我们来实现Windows那样的用鼠标点击来切换窗口的功能。这个功能会让task_a中窗口移动的功能失效，不过没关系，我们在下一节会重新编写窗口移动功能的，大家不必担心。

当鼠标点击画面的某个地方时，怎样才能知道鼠标所点击到的是哪个图层呢？我们需要按照从上到下的顺序，判断鼠标的位置落在哪个图层的范围内，并且还需要确保该位置不是透明色区域。

将上述思路用程序写出来就是下面这样。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int j, x, y; /*这里！*/

struct SHEET *sht; /*这里！*/

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

/*鼠标指针移动*/

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

/*从此开始*/ /*按照从上到下的顺序寻找鼠标所指向的图层*/

for (j = shtctl->top - 1; j > 0; j--) {

sht = shtctl->sheets[j];

x = mx - sht->vx0;

y = my - sht->vy0;

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

sheet_updown(sht, shtctl->top - 1);

break;

}

}

/*到此结束*/ }

}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




我们来“make run”，然后运行lines.hrb，点击一个窗口试试看。哦哦！成功了！



通过点击将task_a切换到最上面

如果点击命令行窗口将其切换到最上面的话，别的窗口就全都被遮住了，这样无法用鼠标点击切换了，还好我们可以按F11将被遮住的窗口切换出来，F11这个功能还真是挺方便的呢。





3　移动窗口（harib21c）

窗口切换的功能已经做的差不多了，这次我们来实现窗口的移动。之前我们只能移动task_a的窗口，这次的目标是实现像Windows一样的窗口移动功能。不过要如何才能实现呢……

当鼠标左键点击窗口时，如果点击位置位于窗口的标题栏区域，则进入“窗口移动模式”，使窗口的位置追随鼠标指针的移动，当放开鼠标左键时，退出“窗口移动模式”，返回通常模式。

要实现窗口的移动，我们需要记录鼠标指针所移动的距离，为此我们添加了两个变量：mmx和mmy，mm是“move mode”的缩写，这两个变量所记录的是移动之前的坐标。由于鼠标指针不会跑到画面以外，因此我们规定当mmx为负数时代表当前不处于窗口移动模式。

■■■■■

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int j, x, y, mmx = -1, mmy = -1; /*这里！*/

struct SHEET *sht = 0; /*这里！*/

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

/*鼠标指针移动*/

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

/*从此开始*/ if (mmx < 0) {

/*如果处于通常模式*/

/*按照从上到下的顺序寻找鼠标所指向的图层*/

for (j = shtctl->top - 1; j > 0; j--) {

sht = shtctl->sheets[j];

x = mx - sht->vx0;

y = my - sht->vy0;

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

sheet_updown(sht, shtctl->top - 1);

if (3 <= x && x < sht->bxsize - 3 && 3 <= y && y < 21) {

mmx = mx; /*进入窗口移动模式*/

mmy = my;

}

break;

}

}

}

} else {

/*如果处于窗口移动模式*/

x = mx - mmx; /*计算鼠标的移动距离*/

y = my - mmy;

sheet_slide(sht, sht->vx0 + x, sht->vy0 + y);

mmx = mx; /*更新为移动后的坐标*/

mmy = my;

}

} else {

/*没有按下左键*/

/*到此结束*/ mmx = -1; /*返回通常模式*/

}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




虽然代码有点长，不过静下心来仔细读一定能看懂的。

■■■■■

我们来“make run”试试看，能不能成功呢……哦哦，成功了！



可以像这样自由自在地移动哦

不过命令行窗口的移动速度太慢了！这大概是QEMU的原因，在真机环境下窗口的移动一定可以达到可接受的速度。还是有点不放心，于是在真机环境下测试了一下，不错，虽然还是有一点慢，不过这个速度也没什么问题。





4　用鼠标关闭窗口（harib21d）

现在我们已经实现了窗口的移动，这次就来实现关闭窗口的功能吧。我们的窗口上面已经有了一个“×”按钮，看到它大家都想按一下吧（笑）？

判断是否点击了“×”按钮的方法，和之前窗口移动时判断是否点击到标题栏的方法是一样的，而且点击后的程序结束处理，也可以参考强制结束部分的代码。嗯，这样看上去还挺容易的。

■■■■■

我们添加了11行代码，这样应该可以搞定了。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

/*鼠标指针移动*/

（中略）

if ((mdec.btn & 0x01) != 0) {



/*按下左键*/

if (mmx < 0) {

/*如果处于通常模式*/

/*按照从上到下的顺序寻找鼠标所指向的图层*/

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

sheet_updown(sht, shtctl->top - 1);

if (3 <= x && x < sht->bxsize - 3 && 3 <= y && y < 21) {

（中略）

}

/*从此开始*/ if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

if (sht->task != 0) { /*该窗口是否为应用程序窗口？*/

cons = (struct CONSOLE *) *((int *) 0x0fec);

cons_putstr0(cons, "\nBreak(mouse) :\n");

io_cli(); /*强制结束处理中禁止切换任务*/

task_cons->tss.eax = (int)

&(task_cons->tss.esp0);

task_cons->tss.eip = (int) asm_end_app;

io_sti();

}

/*到此结束*/ }

break;

}

}

}

} else {

/*如果处于窗口移动模式*/

（中略）

}

} else {

/*没有按下左键*/

（中略）

}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




应该不难吧？那么程序的讲解就到此为止了哦。

将上面的程序“make run”一下，结果如下。看，成功了！



点击这里的话…… 窗口就关掉了





5　将输入切换到应用程序窗口（harib21e）

虽然我们已经实现了像walk.hrb这样让应用程序接受键盘输入的功能，不过仔细看画面会发现，处于输入状态的其实是命令行窗口，而不是walk的窗口。



用harib21d移动“*”时的样子

这样看上去有点怪，应该先让应用程序窗口处于输入状态，然后再操作“*”进行移动。

之前我们所使用的Tab键切换很简单，只能在两个窗口之间交替进行，但这次我们已经显示出了3个以上的窗口，情况变得有点复杂，在按下Tab键时，我们需要判断切换到哪个窗口。我们先这样规定吧：按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层，则切换到最上层窗口。

■■■■■

对于键盘输入的控制我们之前用的是key_to这个变量，不过这已经是很久以前写的了（应该是在17.3节中写的，也就是差不多一个礼拜之前吧，但感觉好像已经过了很久了呢），这个方法现在已经不能用了，于是我们改成使用key_win这个变量存放当前处于输入模式的窗口地址。

另外，还有一个问题，如果当应用程序窗口处于输入模式时被关闭的话要怎样处理呢？这个时候我们可以让系统自动切换到最上层的窗口。

本次修改的内容较多。主要修改的地方是将HariMain中key_to的地方改为key_win，以及添加在输入窗口消失时（被关闭时）进行处理的代码。

有个细节需要讲一下，我们用SHEET结构中的task成员来判断数据发送对象的FIFO，因此在sht_cons—>task中也加入了TASK结构的地址，这样的话我们就无法分辨窗口是不是由应用程序生成的，于是我们需要通过SHEET结构中的flags成员进行判断（以0x10比特位进行区分）。此外，只有命令行窗口需要控制光标的ON/OFF，应用程序窗口不需要，这一区别也是通过flags来进行判断的（以0x20比特位进行区分）。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct SHEET *sht = 0, *key_win; /*这里！*/



（中略）

key_win = sht_win; /*从此开始*/

sht_cons->task = task_cons;

sht_cons->flags |= 0x20; /*有光标*/ /*到此结束*/



（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

i = fifo32_get(&fifo);

io_sti();

if (key_win->flags == 0) { /*输入窗口被关闭*/ /*从此开始*/

key_win = shtctl->sheets[shtctl->top - 1];

cursor_c = keywin_on(key_win, sht_win, cursor_c);

} /*到此结束*/

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (s[0] != 0) { /*一般字符*/

/*从此开始*/ if (key_win == sht_win) { /*发送至任务A */

if (cursor_x < 128) {

/*显示一个字符并将光标后移一位*/

s[1] = 0;

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1);

cursor_x += 8;

}

} else { /*发送至命令行窗口*/

fifo32_put(&key_win->task->fifo, s[0] + 256);

}

}

if (i == 256 + 0x0e) { /*退格键*/

if (key_win == sht_win) { /*发送至任务A */

if (cursor_x > 8) {

/*用空格擦除光标后将光标前移一位*/

putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFF ", 1);

cursor_x -= 8;

}

} else { /*发送至命令行窗口*/

fifo32_put(&key_win->task->fifo, 8 + 256);

}

}

if (i == 256 + 0x1c) { /*回车键*/

if (key_win != sht_win) { /*发送至命令行窗口*/

fifo32_put(&key_win->task->fifo, 10 + 256);

}

}

if (i == 256 + 0x0f) { /* Tab键*/



cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x);

j = key_win->height - 1;

if (j == 0) {

j = shtctl->top - 1;

}

key_win = shtctl->sheets[j];

/*到此结束*/ cursor_c = keywin_on(key_win, sht_win, cursor_c);

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

if (mmx < 0) {

/*如果处于通常模式*/

/*按照从上到下的顺序寻找鼠标所指向的图层*/

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

/*这里！*/ if ((sht->flags & 0x10) != 0) { /*是由应用程序生成的窗口吗？*/

（中略）

}

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




上面的代码中调用了keywin_on和keywin_off两个函数，它们的功能是控制窗口标题栏的颜色和task_a窗口的光标，我们将它们写在bootpack.c中。

本次的bootpack.c节选

int keywin_off(struct SHEET *key_win, struct SHEET *sht_win, int cur_c, int cur_x)

{

change_wtitle8(key_win, 0);

if (key_win == sht_win) {

cur_c = -1; /*删除光标*/

boxfill8(sht_win->buf, sht_win->bxsize, COL8_FFFFFF, cur_x, 28, cur_x + 7, 43);

} else {

if ((key_win->flags & 0x20) != 0) {

fifo32_put(&key_win->task->fifo, 3); /*命令行窗口光标OFF */

}

}

return cur_c;

}



int keywin_on(struct SHEET *key_win, struct SHEET *sht_win, int cur_c)

{

change_wtitle8(key_win, 1);

if (key_win == sht_win) {

cur_c = COL8_000000; /*显示光标*/

} else {

if ((key_win->flags & 0x20) != 0) {

fifo32_put(&key_win->task->fifo, 2); /*命令行窗口光标ON */

}

}

return cur_c;

}




上面的代码中我们调用了一个叫做change_wtitle8的函数，这个函数的功能是改变窗口标题栏的颜色，我们写在window.c中。其实make_wtitle8也可以实现相同的功能，但change_wtitle8的好处是，即便不知道窗口的名称也可以改变标题栏的颜色。除此之外，代码的其余部分应该不需要讲解了吧。

本次的window.c节选

void change_wtitle8(struct SHEET *sht, char act)

{

int x, y, xsize = sht->bxsize;

char c, tc_new, tbc_new, tc_old, tbc_old, *buf = sht->buf;

if (act != 0) {

tc_new = COL8_FFFFFF;

tbc_new = COL8_000084;

tc_old = COL8_C6C6C6;

tbc_old = COL8_848484;

} else {

tc_new = COL8_C6C6C6;

tbc_new = COL8_848484;

tc_old = COL8_FFFFFF;

tbc_old = COL8_000084;

}

for (y = 3; y <= 20; y++) {

for (x = 3; x <= xsize - 4; x++) {

c = buf[y * xsize + x];

if (c == tc_old && x <= xsize - 22) {

c = tc_new;

} else if (c == tbc_old) {

c = tbc_new;

}

buf[y * xsize + x] = c;

}

}

sheet_refresh(sht, 3, 3, xsize, 21);

return;

}




我们对cmd_app也进行了修改，主要修改了应用程序结束时自动关闭窗口的部分。因为没有运行应用程序的命令行窗口，其task也不为0，所以需要通过flags的0x10比特位来判断是否自动关闭。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

if (finfo != 0) {

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

for (i = 0; i < MAX_SHEETS; i++) {

sht = &(shtctl->sheets0[i]);

if ((sht->flags & 0x11) == 0x11 && sht->task == task) { /*这里！*/

/*找到应用程序残留的窗口*/

sheet_free(sht); /*关闭*/

}

}

memman_free_4k(memman, (int) q, segsiz);

} else {

cons_putstr0(cons, ".hrb file format error.\n");

}

（中略）

}

（中略）

}




我们还修改了hrb_api，为了在打开窗口的地方启用自动关闭窗口的功能，我们将flags和0x10进行OR运算。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 5) {

sht = sheet_alloc(shtctl);

sht->task = task;

sht->flags |= 0x10; /*这里！*/

sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax);

make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0);

sheet_slide(sht, 100, 50);

sheet_updown(sht, 3); /*图层高度3位于task_a之上*/

reg[7] = (int) sht;

} else if (edx == 6) {

（中略）

}




下面轮到例行的“make run”了。成功了！



选择了应用程序窗口





6　用鼠标切换输入窗口（harib21f）

我们已经实现了输入窗口的切换，着实进步不小，只是用Tab键来进行切换的操作和Windows还不一样。在Windows中，只要用鼠标在窗口上点击一下，那个窗口就会被切换到画面的最上方，而且键盘输入也会自动切换到该窗口。因此，我们要让“纸娃娃系统”也可以通过简单的点击就能完成输入切换。

刚才为了实现用Tab键切换，我们修改了大量的代码，而这次我们只需要添加一点点代码就好了，因为只需要通过鼠标操作实现和键盘操作相同的功能而已。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

if (mmx < 0) {

/*如果处于通常模式*/

/*按照从上到下的顺序寻找鼠标所指向的图层*/

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

sheet_updown(sht, shtctl->top - 1);

/*从此开始*/ if (sht != key_win) {

cursor_c = keywin_off(key_win, sht_win, cursor_c,

cursor_x);

key_win = sht;

cursor_c = keywin_on(key_win, sht_win, cursor_c);

/*到此结束*/ }

if (3 <= x && x < sht->bxsize - 3 && 3 <= y && y < 21) {

mmx = mx; /*进入窗口移动模式*/

mmy = my;

}

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

（中略）

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}



} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




好了，我们来“make run”，点击一下应用程序窗口试试看吧。



只需要点击一下就可以完成切换啦





7　定时器API（harib21g）

到现在为止，计划今天要讲的关于窗口操作功能的部分已经全部完成了，不过现在时间还早，我们来做点好玩的吧。今天我们还没有写过新的API，那现在我们就来做个新的API吧，比如说，定时器的API。

记得在12.2节中我们实现了用定时器来计时的功能，当时我们高兴了半天，因为我们的操作系统可以用来泡面了。不过现在我们的操作系统又回到了派不上什么用场的状态，即便可以显示窗口、画点、画直线，但它却不能帮我们解决实际问题呀。

因此，接下来我们打算让应用程序也可以使用定时器，然后就可以去吃碗泡面了。大家先把想吃的泡面还有开水准备好，趁这段时间笔者先来写程序了哦！

■■■■■

这次要编写的API如下。

获取定时器（alloc）

EDX=16

EAX=定时器句柄（由操作系统返回）



设置定时器的发送数据（init）

EDX=17

EBX=定时器句柄

EAX=数据



定时器时间设定（set）

EDX=18

EBX=定时器句柄

EAX=时间



释放定时器（free）

EDX=19

EBX=定时器句柄

思路确定了，接下来就是写程序了。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 15) {

for (;;) {

（中略）

if (i >= 256) { /*键盘数据（通过任务A）等*/ /*这里！*/

reg[7] = i - 256;

return 0;

}

}

} else if (edx == 16) { /*从此开始*/

reg[7] = (int) timer_alloc();

} else if (edx == 17) {

timer_init((struct TIMER *) ebx, &task->fifo, eax + 256);

} else if (edx == 18) {

timer_settime((struct TIMER *) ebx, eax);

} else if (edx == 19) {

timer_free((struct TIMER *) ebx); /*到此结束*/

}

return 0;

}




edx的取值为16～19，这个很简单，应该不用讲了。哦对了，edx = 17的情况需要稍微说一下，这里数据的编号加上了256，是因为在向应用程序传递FIFO数据时，需要先减去256。

此外，api_getkey，也就是edx = 15的部分也稍微修改了一下。之前我们写的是if （256 <= I && I <= 511），而现在修改成了if（i>=256），就是说，512以上的值也可以通过api_getkey来获取了。之所以要这样改，是因为现在应用程序不仅需要接收键盘的数据，还需要接收应用程序所设置的定时器发生超时时所传递的数据。

■■■■■

下面我们来编写应用程序。

本次的a_nask.nas节选

_api_alloctimer: ; int api_alloctimer(void);

MOV EDX,16

INT 0x40

RET



_api_inittimer: ; void api_inittimer(int timer, int data);

PUSH EBX

MOV EDX,17

MOV EBX,[ESP+ 8] ; timer

MOV EAX,[ESP+12] ; data

INT 0x40

POP EBX

RET



_api_settimer: ; void api_settimer(int timer, int time);

PUSH EBX

MOV EDX,18

MOV EBX,[ESP+ 8] ; timer

MOV EAX,[ESP+12] ; time

INT 0x40

POP EBX

RET



_api_freetimer: ; void api_freetimer(int timer);

PUSH EBX

MOV EDX,19

MOV EBX,[ESP+ 8] ; timer

INT 0x40

POP EBX

RET




本次的noodle.c节选

#include <stdio.h>



int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_putstrwin(int win, int x, int y, int col, int len, char *str);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

int api_getkey(int mode);

int api_alloctimer(void);

void api_inittimer(int timer, int data);

void api_settimer(int timer, int time);

void api_end(void);



void HariMain(void)

{

char *buf, s[12];

int win, timer, sec = 0, min = 0, hou = 0;

api_initmalloc();

buf = api_malloc(150 * 50);

win = api_openwin(buf, 150, 50, -1, "noodle");

timer = api_alloctimer();

api_inittimer(timer, 128);

for (;;) {

sprintf(s, "%5d:%02d:%02d", hou, min, sec);

api_boxfilwin(win, 28, 27, 115, 41, 7 /*白色*/);

api_putstrwin(win, 28, 27, 0 /*黑色*/, 11, s);



api_settimer(timer, 100); /* 1秒*/

if (api_getkey(1) != 128) {

break;

}

sec++;

if (sec == 60) {

sec = 0;

min++;

if (min == 60) {

min = 0;

hou++;

}

}

}

api_end();

}




关于noodle.c这里稍微讲解一下，之前操作系统显示的是秒，而现在我们需要显示时、分、秒，这样一来时间看起来会更直观，我们就不需要用泡面的3分钟再乘以60换算成秒了。

当定时器超时时，会产生128这样一个值，这个值不是由键盘的编码所使用的，因此除了定时器，别的事件不可能产生这个值。如果产生的数据是128以外的值，那一定是用户按了回车键或者其他什么键，这时应用程序结束退出。

■■■■■

要开始运行了哦，开水准备好了吗？“make run”，先往泡面里面倒好开水，然后运行noodle.hrb。好，3分钟到了，可以吃喽！



可以吃喽

现在我们的操作系统又可以派上用场了，不错不错。





8　取消定时器（harib21h）

上一节我们所实现的定时器功能，其实有个问题，接下来我们来解决它。

这个问题是在应用程序结束之后发生的，请大家想象一下noodle.hrb结束之后的情形。应用程序设置了一个1秒的定时器，当定时器到达指定时间时会产生超时，并向任务发送事先设置的数据。问题是，如果这时应用程序已经结束了，定时器的数据就会被发送到命令行窗口，而命令行窗口肯定是一头雾水。

为了确认这个问题，我们在harib21g中运行noodle.hrb，按回车键或者其他任意键结束程序看看。大约1秒钟之后，命令行窗口中会自动出现一个神秘的字符。用鼠标按“×”关闭窗口之后，也会出现同样的现象。



noodle.hrb结束后出现的神秘字符（不是C哦）

要解决这个问题，我们需要取消待机中的定时器，这样一来，就可以在应用程序结束的同时取消定时器，问题也就迎刃而解了。

■■■■■

首先我们来编写用于取消指定定时器的函数。

本次的timer.c节选

int timer_cancel(struct TIMER *timer)

{

int e;

struct TIMER *t;

e = io_load_eflags();

io_cli(); /*在设置过程中禁止改变定时器状态*/

if (timer->flags == TIMER_FLAGS_USING) { /*是否需要取消？*/

if (timer == timerctl.t0) {

/*第一个定时器的取消处理*/

t = timer->next;



timerctl.t0 = t;

timerctl.next = t->timeout;

} else {

/*非第一个定时器的取消处理*/

/*找到timer前一个定时器*/

t = timerctl.t0;

for (;;) {

if (t->next == timer) {

break;

}

t = t->next;

}

t->next = timer->next; /*将之前“timer的下一个”指向“timer的下一个”*/

}

timer->flags = TIMER_FLAGS_ALLOC;

io_store_eflags(e);

return 1; /*取消处理成功*/

}

io_store_eflags(e);

return 0; /*不需要取消处理*/

}




详细的解说已经写在程序的注释中了，请大家自行阅读。

接下来，我们来编写在应用程序结束时取消全部定时器的函数。在此之前，我们需要在定时器上增加一个标记，用来区分该定时器是否需要在应用程序结束时自动取消。如果没有这个标记的话，命令行窗口中用来控制光标闪烁的定时器也会被取消掉了。

本次的bootpack.h节选

struct TIMER {

struct TIMER *next;

unsigned int timeout;

char flags, flags2; /*这里！*/

struct FIFO32 *fifo;

int data;

};




通常情况下，这里的flags2为0，为了避免忘记置0，我们来修改一下timer.alloc。

本次的timer.c节选

struct TIMER *timer_alloc(void)

{

int i;

for (i = 0; i < MAX_TIMER; i++) {

if (timerctl.timers0[i].flags == 0) {

timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;

timerctl.timers0[i].flags2 = 0; /*这里！*/

return &timerctl.timers0[i];

}

}

return 0; /*没有找到*/

}




接下来，我们将应用程序所申请的定时器的flags2设为1。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 16) {

reg[7] = (int) timer_alloc();

((struct TIMER *) reg[7])->flags2 = 1; /*允许自动取消*/ /*这里！*/

} else if (edx == 17) {

（中略）

}




准备完成了，下面我们就编写一个函数，来取消应用程序结束时所不需要的定时器。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

if (finfo != 0) {

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

start_app(0x1b, 1003 * 8, esp, 1004 * 8, &(task->tss.esp0));

shtctl = (struct SHTCTL *) *((int *) 0x0fe4);

for (i = 0; i < MAX_SHEETS; i++) {

sht = &(shtctl->sheets0[i]);

if ((sht->flags & 0x11) == 0x11 && sht->task == task) {

/*找到应用程序残留的窗口*/

sheet_free(sht); /*关闭*/

}

}

timer_cancelall(&task->fifo); /*这里！*/

memman_free_4k(memman, (int) q, segsiz);

} else {

（中略）

}

（中略）

}

（中略）

}




本次的timer.c节选

void timer_cancelall(struct FIFO32 *fifo)

{

int e, i;

struct TIMER *t;

e = io_load_eflags();

io_cli(); /*在设置过程中禁止改变定时器状态*/

for (i = 0; i < MAX_TIMER; i++) {

t = &timerctl.timers0[i];

if (t->flags != 0 && t->flags2 != 0 && t->fifo == fifo) {

timer_cancel(t);

timer_free(t);

}

}

io_store_eflags(e);

return;

}




大功告成了！

我们来“make run”，运行noodle.hrb，然后让程序结束。哦哦成功了，神秘字符再也不出现了，太好了。



神秘字符消失了

好了，今天的内容就到这里吧，明天见哦！





第25天　增加命令行窗口



蜂鸣器发声（harib22a）

增加更多的颜色（1）（harib22b）

增加更多的颜色（2）（harib22c）

窗口初始位置（harib22d）

增加命令行窗口（1）（harib22e）

增加命令行窗口（2）（harib22f）

增加命令行窗口（3）（harib22g）

增加命令行窗口（4）（harib22h）

变得更像真正的操作系统（1）（harib22i）

变得更像真正的操作系统（2）（harib22j）





1　蜂鸣器发声（harib22a）

大家早上好，今天我们还要继续努力哦。

之前我们为系统添加了很多API，但那些只不过是将以前操作系统就有的功能开放给应用程序来调用而已，没什么让人眼前一亮的东西。现在看来，我们之前给操作系统编写的功能已经用光了，以后如果要为API添加新的功能，就需要同时为操作系统本身编写新的代码了。

因此我们这次来做一个“蜂鸣器发声”的功能吧。蜂鸣器发出的声音，英语叫“BEEP”，是个象声词，也就是那种哔哔哔的声音。一提到电脑上的声音，可能大家首先会想到“声卡”，不过声卡的调用实在过于复杂，新手上路难度太大，因此我们还是先来实现蜂鸣器发声吧，这个功能是所有型号的电脑都有的（如果是自己组装的电脑，只要你没忘记接上蜂鸣器的线就好）。

■■■■■

关于发声的方法，笔者从这里查阅了一下资料。

http://community.osdev.info/?(PIT)8254

没错，其实蜂鸣器发声和定时器一样，都是由PIT来控制的，而PIT位于芯片组中，因此所有型号的电脑都能使用它。

跟以前一样，我们还是直接来看原文中“懒人专用指南”一节的内容吧。



蜂鸣器发声的控制

音高操作

AL = 0xb6; OUT(0x43, AL);



AL = 设定值的低位8bit; OUT(0x42, AL);



AL = 设定值的高位8bit; OUT(0x42, AL);



设定值为0时当作65536来处理。



发声的音高为时钟除以设定值，也就是说设定值为1000时相当于发出1.19318KHz的声音；设定值为10000时相当于119.318Hz。因此设定2712即可发出约440Hz的声音1。





1 440Hz为中央C之上的A音，即国际标准音。





蜂鸣器ON/OFF

使用I/O端口0x61控制。



ON：IN(AL, 0x61); AL |= 0x03; AL &= 0x0f; OUT(0x61, AL);



OFF：IN(AL, 0x61); AL &= 0xd; OUT(0x61, AL);





嗯，差不多看懂了，我们来编写API吧（这里所提到的时钟不是CPU时钟，而是PIT时钟。在电脑中PIT时钟与CPU无关，频率恒定为1.19318MHz）。

蜂鸣器发声

EDX=20

DAX=声音频率（单位是mHz，即毫赫兹）

例如当EAX=4400000时，则发出440Hz的声音

频率设为0则表示停止发声



本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 20) {

if (eax == 0) {

i = io_in8(0x61);

io_out8(0x61, i & 0x0d);

} else {

i = 1193180000 / eax;

io_out8(0x43, 0xb6);



io_out8(0x42, i & 0xff);

io_out8(0x42, i >> 8);

i = io_in8(0x61);

io_out8(0x61, (i | 0x03) & 0x0f);

}

}

return 0;

}




■■■■■

接着我们编写用来测试的应用程序。

本次的a_nask.nas节选

_api_beep: ; void api_beep(int tone);

MOV EDX,20

MOV EAX,[ESP+4] ; tone

INT 0x40

RET




本次的beepdown.c

void api_end(void);

int api_getkey(int mode);

int api_alloctimer(void);

void api_inittimer(int timer, int data);

void api_settimer(int timer, int time);

void api_beep(int tone);



void HariMain(void)

{

int i, timer;

timer = api_alloctimer();

api_inittimer(timer, 128);

for (i = 20000000; i >= 20000; i -= i / 100) {

/* 20KHz～20Hz，即人类可以听到的声音范围*/

/* i以1%的速度递减*/

api_beep(i);

api_settimer(timer, 1); /* 0.01秒*/

if (api_getkey(1) != 128) {

break;

}

}

api_beep(0);

api_end();

}




这个应用程序每0.01秒便降低一次发出的声音频率，当声音频率降至20Hz或者用户按下任意键时结束。

■■■■■

笔者刚要“make run”的时候突然想到， QEMU并没有模拟蜂鸣器发声的功能，因此即便运行这个程序也发不出声音。没办法，我们只好用“make install”在真机环境下测试了，只要主板和蜂鸣器正确连接就会发出声音哦。

咻——

如果你听了这个声音觉得“哇！掉下去啦”，心情也跟着一起跌落到低谷的话，不妨编写下面这个beepup.c听听看。只是将i由递减改为递增，就能发出让人“充满能量”的声音啦（笑）。

beepup.c

void HariMain(void)

{

int i, timer;

timer = api_alloctimer();

api_inittimer(timer, 128);

for (i = 20000; i <= 20000000; i += i / 100) {

api_beep(i);

api_settimer(timer, 1); /* 0.01秒*/

if (api_getkey(1) != 128) {

break;

}

}

api_beep(0);

api_end();

}





2　增加更多的颜色（1）（harib22b）

到目前为止我们的操作系统只用了16种颜色，话说既然现在我们已经用上了256色的显示模式，那实际上还有240种颜色可以用，不用的话实在太浪费了。因此我们准备修改一下操作系统，以便可以显示更多的颜色。

到底要增加哪些颜色呢？我们可以为光的三原色reg、green、blue（红、绿、蓝）中每种颜色赋予6个色阶2，这样一来，我们就可以定义出6×6×6＝216种颜色，没定义的就只剩下24种颜色了。

2 6个色阶：也就是6个级别的浓度的意思。在这里，定义为“6个级别的亮度”应该更加准确。

对于操作系统，我们需要修改graphic.c，好久没碰这个文件了，真怀念啊！

本次的graphic.c节选

void init_palette(void)

{

static unsigned char table_rgb[16 * 3] = {

（中略）

};

unsigned char table2[216 * 3];

int r, g, b;

set_palette(0, 15, table_rgb);

for (b = 0; b < 6; b++) {

for (g = 0; g < 6; g++) {

for (r = 0; r < 6; r++) {

table2[(r + g * 6 + b * 36) * 3 + 0] = r * 51;

table2[(r + g * 6 + b * 36) * 3 + 1] = g * 51;

table2[(r + g * 6 + b * 36) * 3 + 2] = b * 51;

}

}

}

set_palette(16, 231, table2);

return;

}




这样一来，当我们需要指定RGB=[51, 102, 153]这个颜色时，只要使用色号137就可以了。137这个数字的计算方法为：16＋1＋2×6＋3×36。

按照这样的划分方式，色号0和16所代表的颜色都是#000000，浪费了一个色号，不过我们就偷个懒先这样吧。除此之外，#ff0000等颜色也会发生重复（重复的颜色一共有8种）。

接下来我们还需要编写应用程序，不过这次不用编写新的API，所以任务很轻松。

本次的color.c

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_initmalloc(void);

char *api_malloc(int size);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

int api_getkey(int mode);

void api_end(void);



void HariMain(void)

{

char *buf;

int win, x, y, r, g, b;

api_initmalloc();

buf = api_malloc(144 * 164);

win = api_openwin(buf, 144, 164, -1, "color");

for (y = 0; y < 128; y++) {

for (x = 0; x < 128; x++) {

r = x * 2;

g = y * 2;

b = 0;



buf[(x + 8) + (y + 28) * 144] = 16 + (r / 43) + (g / 43) * 6 + (b / 43) * 36;

}

}

api_refreshwin(win, 8, 28, 136, 156);

api_getkey(1); /*等待按下任意键*/

api_end();

}




赶紧“make run”一下，嗯，好漂亮！



五彩斑斓





3　增加更多的颜色（2）（harib22c）

color.hrb很漂亮，不过其实还有一种技巧能够让颜色更加丰富，下面我们就来试试看吧。

实际上，如果我们不用256色模式，而使用VESA的全彩色模式的话，可以轻而易举地显示出更多的颜色，不过在不兼容VESA标准的电脑上（偶尔会有）是完全无法使用全彩色模式和65536色模式的。而且，要在“纸娃娃系统”上实现对全彩色模式的支持，得花上差不多整整一天时间。眼看剩下的日子不多了，笔者也该开始考虑30天到底能做到什么程度了（笑），所以就不在全彩色模式上花费时间了。

可能有人会说“反正我以后是要用全彩色的，这个技巧对我就没什么用了吧”，这个想法也没错。不过笔者认为，即便如此，也还是对这种技巧有点了解比较好，因为有时候需要显示一幅全彩色的图片，但很有可能遇到不支持全彩色模式的电脑，如果了解了这个技巧，在这种情况下也可以让图片看上去相对好看一些。

“谁让他们不能用全彩色的，才不管他们呢”，大家千万不要说这种绝情的话哦。如果大家编写的操作系统能够做到“用全彩色模式的时候很漂亮，不能用的时候也不难看”，笔者也就感到很欣慰了。

怎样才能让颜色看起来更多呢？我们可以用两种颜色交替排列，看上去就像这两种颜色混合在一起一样，这就是要点。颜色的混合方式我们考虑了下面3种（算上完全不混合的情况，一共有5种）。



这样一来，虽然我们只有6级色阶，但却可以显示出21级色阶（在纯色中间可以产生3个中间色，因此是6＋5×3＝21）。

■■■■■

这次我们只需要修改应用程序即可。

本次的color2.hrb

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_initmalloc(void);

char *api_malloc(int size);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

int api_getkey(int mode);

void api_end(void);



unsigned char rgb2pal(int r, int g, int b, int x, int y);



void HariMain(void)

{

char *buf;

int win, x, y;

api_initmalloc();

buf = api_malloc(144 * 164);

win = api_openwin(buf, 144, 164, -1, "color2");

for (y = 0; y < 128; y++) {

for (x = 0; x < 128; x++) {

buf[(x + 8) + (y + 28) * 144] = rgb2pal(x * 2, y * 2, 0, x, y);

}

}

api_refreshwin(win, 8, 28, 136, 156);

api_getkey(1); /*等待按下任意键*/

api_end();

}



unsigned char rgb2pal(int r, int g, int b, int x, int y)



{

static int table[4] = { 3, 1, 0, 2 };

int i;

x &= 1; /*判断是偶数还是奇数*/

y &= 1;

i = table[x + y * 2]; /*用来生成中间色的常量*/

r = (r * 21) / 256; /* r为0～20*/

g = (g * 21) / 256;

b = (b * 21) / 256;

r = (r + i) / 4; /* r为0～5*/

g = (g + i) / 4;

b = (b + i) / 4;

return 16 + r + g * 6 + b * 36;

}




rgb2pal是本次增加颜色的核心部分，里面的算法看上去非常神秘，估计很多人都不明白为什么如此简短的代码却能实现我们所需的功能。其实用很多个if语句也可以实现一样的功能，但相比之下显然我们的算法速度更快，因此我们还是采用这个算法吧。

如果对解谜感兴趣的话，可以花点时间仔细思考一下。话说这个算法也不是笔者想出来的，而是一位编程达人传授的（笔者一开始也是写了很多if语句，后来被这位达人给改成这样了）。

好了，我们来“make run”吧。哦哦，看起来平滑多了。



看起来平滑多了





4　窗口初始位置（harib22d）

在编写color.hrb的时候笔者注意到一个小问题，color的窗口一开始出现的位置好像有点别扭（注：使用VESA的人画面尺寸非常大，可能并不觉得有什么别扭的）。



harib22c运行的时候窗口跑到画面外面去了

因此我们希望让窗口总是显示在画面的中央，而且显示窗口时的图层高度也不能总是固定为3，而是要判断当前画面中窗口的数量并自动显示在最上面。虽说现在窗口也是显示在最上面，不过如果再多打开几个的话，情况就不一样了。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 5) {

（中略）

sheet_slide(sht, (shtctl->xsize - esi) / 2, (shtctl->ysize - edi) / 2);

sheet_updown(sht, shtctl->top); /*将窗口图层高度指定为当前鼠标所在图层的高度，鼠标移到上层*/

（中略）

} else if (edx == 6) {

（中略）

}




好，完工了，这下窗口应该显示在画面中央了，我们来试试看吧。“make run”，成功了！



这次显示在画面中央了





5　增加命令行窗口（1）（harib22e）

我们在25.2节和25.3节中分别编写了color.hrb和color2.hrb，如果要仔细对比一下这两个程序显示出来的画面有什么区别，就要把两个程序的窗口并排起来看才行，可是我们不能同时启动两个应用程序啊。这实在是太郁闷了，我们辛辛苦苦实现的多任务到底是为了什么呢？

要解决这个问题，我们可以考虑修改一下命令行窗口，使其在应用程序运行中就可以输入下一条命令，不过这样的修改量实在太大，讲解起来也会很麻烦，因此我们还是改用同时启动两个命令行窗口的方法吧。如果可以启动两个命令行窗口，就可以在每个窗口中各自启动一个应用程序，这就相当于同时运行了两个应用程序。而命令行窗口我们一开始就是作为任务来编写的，所以要同时启动两个也很容易。

不过我们的程序中还有一部分是以只有一个命令行窗口为前提设计的，所以如果只是启动两个命令行窗口任务的话肯定是行不通的。不过我们不妨先启动两个命令行窗口试试看，如果有什么不对的地方再去一点一点地修改（一上来就想做得完美，反而会遇到麻烦的问题呢）。

■■■■■

于是，我们这次只修改bootpack.c，将命令行窗口的相关变量（buf_cons、sht_cons、task_cons和cons）各准备2个，分别分给命令行1和命令行2。

例如：task_cons → task_cons1和task_cons2

不过这样一来，如果要将命令行窗口增加到10个，岂不是要写10组这样的变量吗？虽说可以复制粘贴，但还是太麻烦了，因此我们稍微动点脑筋改成下面这样就好了。

task_cons → task_cons[0]和task_cons[1]

这样的话我们就可以用一个循环来进行相同的处理，管它10个还是100个都没问题！

本次的bootpack.c节选

void HariMain(void)

{

（中略）

unsigned char *buf_back, buf_mouse[256], *buf_win, *buf_cons[2]; /*从此开始*/

struct SHEET *sht_back, *sht_mouse, *sht_win, *sht_cons[2];

struct TASK *task_a, *task_cons[2]; /*到此结束*/

（中略）





/* sht_cons */

for (i = 0; i < 2; i++) { /*从此开始*/

sht_cons[i] = sheet_alloc(shtctl);

buf_cons[i] = (unsigned char *) memman_alloc_4k(memman, 256 * 165);

sheet_setbuf(sht_cons[i], buf_cons[i], 256, 165, -1); /*没有透明色*/

make_window8(buf_cons[i], 256, 165, "console", 0);

make_textbox8(sht_cons[i], 8, 28, 240, 128, COL8_000000);

task_cons[i] = task_alloc();

task_cons[i]->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12;

task_cons[i]->tss.eip = (int) &console_task;

task_cons[i]->tss.es = 1 * 8;

task_cons[i]->tss.cs = 2 * 8;

task_cons[i]->tss.ss = 1 * 8;

task_cons[i]->tss.ds = 1 * 8;

task_cons[i]->tss.fs = 1 * 8;

task_cons[i]->tss.gs = 1 * 8;

*((int *) (task_cons[i]->tss.esp + 4)) = (int) sht_cons[i];

*((int *) (task_cons[i]->tss.esp + 8)) = memtotal;

task_run(task_cons[i], 2, 2); /* level=2, priority=2 */

sht_cons[i]->task = task_cons[i];

sht_cons[i]->flags |= 0x20; /*有光标*/

} /*到此结束*/



（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_cons[1], 56, 6); /*这里！ */

sheet_slide(sht_cons[0], 8, 2); /*这里！ */

sheet_slide(sht_win, 64, 56);

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_cons[1], 1); /*从此开始*/

sheet_updown(sht_cons[0], 2);

sheet_updown(sht_win, 3);

sheet_updown(sht_mouse, 4); /*到此结束*/

key_win = sht_win;



（中略）



for (;;) {

（中略）

io_cli();

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

/*从此开始*/ if (i == 256 + 0x3b && key_shift != 0 && task_cons[0]->tss.ss0 != 0) { /* Shift+F1 */

cons = (struct CONSOLE *) *((int *) 0x0fec);

cons_putstr0(cons, "\nBreak(key) :\n");

io_cli(); /*强制结束处理时禁止任务切换*/

task_cons[0]->tss.eax = (int) &(task_cons[0]->tss.esp0);

/*到此结束*/ task_cons[0]->tss.eip = (int) asm_end_app;

io_sti();

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键时*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {



（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

if ((sht->flags & 0x10) != 0) { /*是否为应用程序窗口*/

cons = (struct CONSOLE *) *((int *) 0x0fec);

cons_putstr0(cons, "\nBreak(mouse) :\n");

io_cli(); /*强制结束处理时禁止任务切换*/

/*从此开始*/ task_cons[0]->tss.eax = (int) &(task_cons[0]->tss.esp0);

/*到此结束*/ task_cons[0]->tss.eip = (int) asm_end_app;

io_sti();

}

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




前半部分代码应该还很容易看懂，不过后半部分Shift+F1以及“×”按钮的处理是不是觉得有些蹊跷？为什么不判断就直接写cons[0]呢？其实呢，这里纯粹是偷懒了（笑）。如果我们不加上[0]或者[1]的话编译器通不过，因此就先写了[0]，关于这一块，我们会在25.8节中进行修复。

因此，在运行harib22e和harib22f的时候，大家记得千万别按Shift+F1或者“×”按钮哦。

好了，我们来“make run”，目前打开两个命令行窗口应该没问题吧。好，出来了！



出现了两个命令行窗口

在两个窗口之间切换一下，貌似都能够执行命令。之所以说“貌似”，是因为笔者知道剩下的问题还有很多，至于后面到底能不能顺利运行，说实话笔者真没什么自信。



尝试执行一下mem和dir命令

那么现在到底能不能同时启动两个应用程序呢？虽然很想用color.hrb和color2.hrb来试一下，不过大抵是不会成功的，所以我们还是从基本中的基本——a.hrb开始测试吧。咦？什么都没显示出来？？？……晕！在这儿呢！居然显示到没运行这个程序的命令行窗口中去了。



运行a.hrb的情形……

这样可不行啊，我们得解决这个问题。





6　增加命令行窗口（2）（harib22f）

到底应该改哪里呢？其实笔者已经心里有数了，函数hrb_api()中的这句：

struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);




应该就是问题所在了，这里的cons变量是用来判断“要向哪个命令行窗口输出字符”的关键。该变量的值是从内存地址0x0fec读取出来的，而无论从哪个任务读取这个内存地址中的值，得到的肯定都是同一个值，因此不管在哪个窗口中运行a.hrb，都只能在固定的其中一个窗口中显示字符。



harib22e中，无论在哪个窗口运行，结果都一样

那么该如何解决这个问题呢？嗯，看看这种方法怎么样。

本次的bootpack.h节选

struct TASK {

int sel, flags; /* sel代表GDT编号*/

int level, priority;

struct FIFO32 fifo;

struct TSS32 tss;

struct CONSOLE *cons; /*从此开始*/

int ds_base; /*到此结束*/

};




每个任务都拥有各自的TASK结构，只要我们将cons保存在TASK结构中，就可以由不同的任务读取出不同的值了。此外，我们将ds_base也放到了TASK结构中，理由和上面的cons是相同的。ds_base之前是从内存地址0x0fe8处读取的，但很明显，cons[0]的应用程序数据段地址和cons[1]的地址肯定是不同的，如果不在这里区分开的话，字符串的显示就会出问题。

■■■■■

接下来我们只要将代码中的*((int *) 0x0fec)和*((int *) 0x0fe8)全部改为使用TASK结构中的cons和ds_base成员就可以了，需要修改的只有console.c一个文件。

本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

task->cons = &cons; /*修改前：*((int *) 0x0fec) = (int) &cons;*/

（中略）



}



int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

if (finfo != 0) {

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

task->ds_base = (int) q; /*修改前：*((int *) 0x0fe8) = (int) &q;*/

} else {

（中略）

}

（中略）

}

（中略）

}



int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

int ds_base = task->ds_base; /*这里！*/

struct CONSOLE *cons = task->cons; /*这里！*/

（中略）

}



int *inthandler0c(int *esp)

{

（中略）

struct CONSOLE *cons = task->cons; /*这里！*/

（中略）

}



int *inthandler0d(int *esp)

{

（中略）

struct CONSOLE *cons = task->cons; /*这里！*/

（中略）

}




好，完工啦。现在无论在哪个窗口运行a.hrb，应该会在相应的窗口中显示出字符……了吧……

■■■■■

我们来试验一下吧。“make run”，在两边的窗口分别运行a.hrb！哦哦，成功了，太棒了！（要是这样还不行的话，笔者真的不知道该怎么办了，小捏了一把汗）



a.hrb运行成功！

趁热打铁，我们来运行color.hrb和color2.hrb试试看。哇！成功了！现在我们可以把两个窗口并排对比了，终于实现了当初的夙愿。



color.hrb vs color2.hrb

接下来我们来做点别的试验吧，比如说把color.hrb和color2.hrb的窗口关闭（注：Shift+F1和“×”按钮点击的处理我们还没有改好，记得按回车键退出程序哦）……咦？哐叽，QEMU出错退出了1！

1 这是由于color.hrb和color2.hrb的启动顺序、各从哪个命令行窗口运行的、以及先关闭的哪一个窗口等不同情况导致的，出错的方式貌似也不一样。应用程序没有bug，也没有故意捣乱，这是由于“纸娃娃系统”本身所引发的异常。

因此，在两个color程序PK之后，我们的下一个目标就是要使窗口能够正常关闭。





7　增加命令行窗口（3）（harib22g）

为什么程序会无法正常关闭呢？一开始笔者以为问题出在关闭窗口的函数，或者是处理程序结束的部分，但事实并非如此，这个失误比想象中更加严重。问题的原因在于应用程序的内存段消失了，突然间竟然发生这种事情，QEMU肯定也被整糊涂了。

也许大家不明白应用程序的内存段消失是怎么一回事，总之，问题出在cmd_app身上。

harib22f的cmd_app节选

set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60);

set_segmdesc(gdt + 1004, segsiz - 1, (int) q, AR_DATA32_RW + 0x60);

（中略）

start_app(0x1b, 1003 * 8, esp, 1004 * 8, &(task->tss.esp0));




上面这段代码是用来创建应用程序段并启动应用程序的，大家仔细思考一下这段代码。

首先，color.hrb在某个窗口中被运行，启动程序一切顺利，然后显示窗口并绘图，接下来等待键盘输入并进入休眠状态。到这里为止没有任何问题。

然后我们在另外一个窗口中运行color.hrb，程序也顺利启动了，显示窗口并绘图，随后进入休眠状态。然而在这个时候，问题其实已经发生了。这是怎么回事呢？因为我们为color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。

因此，当按下回车键唤醒color.hrb时，就会发生异常情况——明明应该去运行color.hrb的，结果却错误地运行了color2.hrb，这样当然会出错了。

■■■■■

既然问题的原因想明白了，要干掉这个bug也就不难了，只要为color.hrb和color2.hrb分配编号不同的段就可以了。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）



if (finfo != 0) {

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

set_segmdesc(gdt + task->sel / 8 + 1000, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60);

set_segmdesc(gdt + task->sel / 8 + 2000, segsiz - 1, (int) q, AR_DATA32_RW + 0x60);

（中略）

start_app(0x1b, task->sel + 1000 * 8, esp, task->sel + 2000 * 8, &(task->tss.esp0));

（中略）

} else {

（中略）

}

（中略）

}

（中略）

}




在task—>sel中填入TSS的段号 * 8（请参照mtask.c的task_init），将这个值除以8，结果一定落在3～1002。将其加上1000，就得到1003～2002的值，我们把它用作应用程序用的代码段编号；将其加上2000，即得到2003～3002的值，我们把它用作应用程序用的数据段编号。这样一来，就不会发生段被覆盖的问题了。

■■■■■

我们来试试看能不能成功，“make run”，运行color.hrb和color2.hrb，并排对比一下，然后按下回车键结束程序。啊，这次终于成功了，撒花！



成功结束了应用程序





8　增加命令行窗口（4）（harib22h）

增加命令行窗口这个系列终于到了最后一节，之前我们已经知道Shift+F1和“×”按钮的部分是有问题的，但一直放着没管，现在终于到了解决它的时候了。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct TASK *task_a, *task_cons[2], *task;

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

/*从此开始*/ if (i == 256 + 0x3b && key_shift != 0) {

task = key_win->task;

if (task != 0 && task->tss.ss0 != 0) { /* Shift+F1 */

cons_putstr0(task->cons, "\nBreak(key) :\n");

io_cli(); /*强制结束处理时禁止任务切换*/

task->tss.eax = (int) &(task->tss.esp0);

task->tss.eip = (int) asm_end_app;

io_sti();

/*到此结束*/ }

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

if (mmx < 0) {



（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) { /*点击“×”按钮*/

/*从此开始*/ if ((sht->flags & 0x10) != 0) {/*是否为应用程序窗口？*/

task = sht->task;

cons_putstr0(task->cons, "\nBreak(mouse) :\n");

io_cli(); /*强制结束处理时禁止任务切换*/

task->tss.eax = (int) &(task->tss.esp0);

/*到此结束*/ task->tss.eip = (int) asm_end_app;

io_sti();

}

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）



}

}

} else if (i <= 1) { /*光标用定时器*/

（中略）

}

}

}

}




这次的修改也很简单，首先将原来task_cons[0]的地方改为key_win—>task和sht—>task，这样一来，用键盘强制结束时会以当前输入窗口为对象，而用鼠标点击“×”按钮时会以被点击的窗口为对象。然后，我们将从内存地址0xfec读出cons的部分改为使用task—>cons，这样就改好了。

■■■■■

我们来“make run”，将color.hrb和color2.hrb的窗口并排显示之后，用键盘或者鼠标强制结束试试……看，成功了！



成功了！





9　变得更像真正的操作系统（1）（harib22i）

做到这里，我们的系统看上去已经非常像那么回事了。不过，大家回忆一下一般操作系统的样子，再看看我们的画面，是不是有什么奇怪的东西混进去了？一般的操作系统中哪有这玩意儿啊？笔者所说的，就是taks_a的窗口。

一般的操作系统不会一上来就弹出这么一个窗口来吧？话说回来，这个窗口貌似是14.6节中我们为了让画面看上去更酷更有操作系统范儿而做出来的，也就是说，它只是个花瓶，摆着好看罢了（14.6节已经是差不多两周之前讲的了呢）。之后，我们在练习多任务等部分时这个窗口也还派上过用场，不过现在它看起来确实有点碍手碍脚了——它不是应用程序而是操作系统的一部分，所以连关都关不掉。

因此，我们还是把它从操作系统中删掉吧，如果哪天我们又想念它了，只要再写一个应用程序出来就好了。而且应用程序的话，不需要的时候就可以关掉，（如果需要）还可以同时运行多个副本呢。

其实，在bootpack.c中，只有这个task_a的窗口是搞特殊化的，如果删掉task_a的部分程序就变得清爽多了。对了，task_a的处理全部是在bootpack.c中完成的，因此不需要修改其他的程序。

■■■■■

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int mx, my, i; /*删掉了cursor_x和cursor_c */

unsigned int memtotal;

struct MOUSE_DEC mdec;

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

unsigned char *buf_back, buf_mouse[256], *buf_cons[2]; /*删掉了buf_win */

struct SHEET *sht_back, *sht_mouse, *sht_cons[2];

struct TASK *task_a, *task_cons[2], *task;

/*删掉了用于光标闪烁的timer */

static char keytable0[0x80] = { /*向keytable0、keytable1中追加退格键和回车键的编码*/

0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '^', 0x08, 0,

'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0x0a, 0, 'A', 'S',

（中略）

};

static char keytable1[0x80] = {

0, 0, '!', 0x22, '#', '$', '%', '&', 0x27, '(', ')', '~', '=', '~', 0x08, 0,

'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '`', '{', 0x0a, 0, 'A', 'S',

（中略）

};

（中略）



/* sht_back */

（中略）



/* sht_cons */

（中略）



/*删掉了关于sht_win的部分*/



/* sht_mouse */

（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_cons[1], 56, 6);

sheet_slide(sht_cons[0], 8, 2);

/*删掉了sht_win */

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_cons[1], 1);

sheet_updown(sht_cons[0], 2);

sheet_updown(sht_mouse, 3); /*从此开始*/

key_win = sht_cons[0];

keywin_on(key_win); /*到此结束*/



（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

/*从此开始*/ if (s[0] != 0) { /*一般字符、退格键、回车键*/

fifo32_put(&key_win->task->fifo, s[0] + 256);

}

if (i == 256 + 0x0f) { /* Tab键*/

keywin_off(key_win);

j = key_win->height - 1;

if (j == 0) {

j = shtctl->top - 1;

}

key_win = shtctl->sheets[j];

/*到此结束*/ keywin_on(key_win);

}

（中略）

/*删掉了“重新显示光标”的部分*/

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

sheet_updown(sht, shtctl->top - 1);

if (sht != key_win) {

keywin_off(key_win); /*这里！*/

key_win = sht;

keywin_on(key_win); /*这里！*/

}

（中略）

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}

}



/*删掉了“光标用定时器”的部分*/

}

}

}



void keywin_off(struct SHEET *key_win) /*从此开始*/

{

change_wtitle8(key_win, 0);

if ((key_win->flags & 0x20) != 0) {

fifo32_put(&key_win->task->fifo, 3); /*命令行窗口光标OFF */

}

return; /*到此结束*/

}



void keywin_on(struct SHEET *key_win) /*从此开始*/

{

change_wtitle8(key_win, 1);

if ((key_win->flags & 0x20) != 0) {

fifo32_put(&key_win->task->fifo, 2); /*命令行窗口光标ON */

}

return; /*到此结束*/

}




大功告成，看上去清爽多了。修改前的bootpack.c一共有374行代码，修改后只剩下304行，居然减掉了70行呢。

我们还是来“make run”吧，不知道能不能成功呢。哎呀？



一直重复这个画面

貌似系统在不断重启，当然，任何操作都没有反应，看来是失败了……





10　变得更像真正的操作系统（2）（harib22j）

当然不能就这样放弃，我们来找找失败的原因。在对有可能出问题的地方排查一遍之后，我们发现只要将bootpack.c的第117行keywin_on(key_win);这一句删掉1，重启的毛病就没了。不过这样一来，启动之后光标没有显示出来，必须要按Tab键或者点击窗口将窗口手工切换一下才行。

1 可能有人会问，你是怎样发现这一句有问题的呢？其实笔者寻找bug的基本思路是搞清楚“为什么之前还运行得好好的程序，现在就无法运行了呢”。因此，导致程序无法正常运行的原因肯定在于我们添加的或者删除的那部分代码里，我们可以采取逐个还原的方式来排查。

harib22i的bootpack.c节选

void HariMain(void)

{

（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_cons[1], 56, 6);

sheet_slide(sht_cons[0], 8, 2);

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_cons[1], 1);

sheet_updown(sht_cons[0], 2);

sheet_updown(sht_mouse, 3);

key_win = sht_cons[0];

keywin_on(key_win); ←将这一行删掉的话，重启的毛病就没了



（中略）

}




看来，只要检查一下keywin_on函数就能找到自动重启的原因了。

harib22i的bootpack.c节选

void keywin_on(struct SHEET *key_win)

{

change_wtitle8(key_win, 1);

if ((key_win->flags & 0x20) != 0) {

fifo32_put(&key_win->task->fifo, 2); /*命令行窗口光标ON */

}

return;

}




keywin_on这个函数的功能很简单，先是改变窗口的颜色，然后向命令行窗口任务的FIFO发送2这个值用来显示光标。我们将刚才出问题的keywin_on(key_win);这一句改成change_wtitle8(key_win, 1);试了一下，没有发生重启的问题，看来问题的原因就在fifo32_put这里了。

■■■■■

不过，fifo32_put这个函数我们已经用了很久了，从来没有出过问题，应该不会是程序的bug，因此我们来检查一下发送数据的目的地key_win —> task —> fifo。

这个FIFO缓冲区是否处于正常状态呢？想到这里，我们来找找看对这个FIFO缓冲区进行初始化的代码在哪里，啊，找到了，位于console_task最开头的地方。

这样肯定不行，因为命令行窗口任务的优先级比较低，只有当bootpack.c的HariMain休眠之后才会运行命令行窗口任务，而如果不运行这个任务的话，FIFO缓冲区就不会被初始化，这就相当于我们在向一个还没初始化的FIFO强行发送数据，于是造成fifo32_put混乱而导致重启。

搞清楚原因，改起来就简单了。我们只要将console_task中对FIFO进行初始化的代码移动到HariMain中就可以了。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int fifobuf[128], keycmd_buf[32], *cons_fifo[2]; /*这里！*/

（中略）



/* sht_cons */

for (i = 0; i < 2; i++) {

（中略）

sht_cons[i]->task = task_cons[i];

sht_cons[i]->flags |= 0x20; /*有光标*/

cons_fifo[i] = (int *) memman_alloc_4k(memman, 128 * 4); /*从此开始*/

fifo32_init(&task_cons[i]->fifo, 128, cons_fifo[i], task_cons[i]); /*到此结束*/

}



（中略）

}




本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

struct TASK *task = task_now();

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

int i, *fat = (int *) memman_alloc_4k(memman, 4 * 2880); /*这里！（删掉了fifobuf[128]） */

struct CONSOLE cons;

char cmdline[30];

cons.sht = sheet;

cons.cur_x = 8;

cons.cur_y = 28;

cons.cur_c = -1;

task->cons = &cons;



/*删掉了这里的fifo32_init(&task->fifo, 128, fifobuf, task); */

cons.timer = timer_alloc();

timer_init(cons.timer, &task->fifo, 1);

（中略）

}




虽然我们只修改了5行代码，但是完全可以解决我们的问题，话说，要是还解决不了可真该头大了，因为笔者的上眼皮和下眼皮已经开始打架了（笑）。总之，我们来“make run”试试看吧。

貌似成功了，那个碍事的task_a已经不见了，系统运行也没有问题，太好了。



启动后的画面

好了，我们今天就到这里吧！





第26天　为窗口移动提速



提高窗口移动速度（1）（harib23a）

提高窗口移动速度（2）（harib23b）

提高窗口移动速度（3）（harib23c）

提高窗口移动速度（4）（harib23d）

启动时只打开一个命令行窗口（harib23e）

增加更多的命令行窗口（harib23f）

关闭命令行窗口（1）（harib23g）

关闭命令行窗口（2）（harib23h）

start命令（harib23i）

ncst命令（harib23j）





1　提高窗口移动速度（1）（harib23a）

昨天我们增加了可同时启动的应用程序的数量，窗口也跟着变多了，整个画面变得热闹起来。

话说，在对比color.hrb和color2.hrb的时候我们需要移动窗口，那个时候笔者感到窗口移动的速度很慢。在真机环境下的速度还算可以接受，但在QEMU下就慢得离谱，让人心烦。虽说在真机环境下速度不慢就可以了，但如果速度能再快点总归是件好事。因此，提高窗口移动的速度就成了我们今天的第一个课题。

■■■■■

导致窗口移动速度慢的原因有很多，其中之一就是sheet_refreshmap的速度太慢。这个函数在sheet_slide中被调用了两次，如果能提高它的速度效果应该会很明显。

这个函数是很久之前写的，因此在修改之前我们再来看一下它的代码。

修改前的sheet.c节选

void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)

{

（中略）

for (h = h0;s h <= ctl->top; h++) {

（中略）

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

if (buf[by * sht->bxsize + bx] != sht->col_inv) {

map[vy * ctl->xsize + vx] = sid;

}

}

}

}

return;

}




怎样才能提高这个函数的速度呢？我们可以尝试将里面的if语句去掉。这个if语句位于三层for循环之中，要被执行成千上万次，因此如果能去掉这个if语句的话，速度应该会有不小的提高。

要去掉这个if语句，我们得先思考一下它的含义。这个if语句的功能是判断图层是否为透明部分，如果强行去掉它的话图层的透明部分就没有了，鼠标指针就会变成一个方块，这样可不行。但换个角度想想，窗口基本上都是矩形的，没有透明部分，如果仅去掉窗口部分的if判断是没有影响的。

因此，我们在进入bx和by的for循环之前先判断这个图层是否有透明部分，如果有透明部分的话还按现有程序执行，否则执行一个没有if语句的两层循环。

本次的sheet.c节选

void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)

{

（中略）

for (h = h0; h <= ctl->top; h++) {

（中略）

if (sht->col_inv == -1) { /*从此开始*/

/*无透明色图层专用的高速版*/

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

map[vy * ctl->xsize + vx] = sid;

}

}

} else {

/*有透明色图层用的普通版*/

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {



vx = sht->vx0 + bx;

if (buf[by * sht->bxsize + bx] != sht->col_inv) {

map[vy * ctl->xsize + vx] = sid;

}

}

}

} /*到此结束*/

}

return;

}




■■■■■

完工啦！我们赶紧来运行一下看看，“make run”……嗯嗯，总之运行起来没有什么问题。窗口移动的速度呢……唔，也看不太出来，不过感觉好像快了那么一点，就当是成功了吧（笑）。



截图上看不出来，不过感觉快了那么一点点





2　提高窗口移动速度（2）（harib23b）

这点改善还不够，我们得想办法让速度变得更快才行。其实要想变快，方法还是很多的。

比如sheet_refreshmap中有这样一句：

map[vy * ctl->xsize + vx] = sid;




我们来琢磨一下这行代码。这个命令的功能是向内存中某个地址写入sid的值，它也位于for循环中，会被反复执行，而且这个地址的后面以及再后面的地址也要写入sid的值。

且慢，这样的话不是有个更好的方法吗？在汇编语言中，如果我们用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。

更重要的是，即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍！这简直是太强大了，我们一定得试试看。

修改后的代码如下。

本次的sheet.c节选

void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1, sid4, *p; /*这里！*/

（中略）

for (h = h0; h <= ctl->top; h++) {

（中略）

if (sht->col_inv == -1) {

if ((sht->vx0 & 3) == 0 && (bx0 & 3) == 0 && (bx1 & 3) == 0) { /*从此开始*/

/*无透明色图层专用的高速版（4字节型）*/

bx1 = (bx1 - bx0) / 4; /* MOV次数*/

sid4 = sid | sid << 8 | sid << 16 | sid << 24;

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

vx = sht->vx0 + bx0;

p = (int *) &map[vy * ctl->xsize + vx];

for (bx = 0; bx < bx1; bx++) {

p[bx] = sid4;

}

}

} else {

/*无透明色图层专用的高速版（1字节型）*/

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

map[vy * ctl->xsize + vx] = sid;

}

}

} /*到此结束*/

} else {

/*有透明色图层用的普通版*/

（中略）

}

}

return;

}




其实有透明色的情况我们也可以改成4字节型，不过这次我们先不改了。因为修改这里必须考虑透明色的处理，算法会比较复杂，而且现在用透明色的只有鼠标指针，鼠标的图层尺寸很小，两种方式的速度差异不大。

为了让这次的修改发挥最大的效果，我们需要使窗口在x方向上的大小为4的倍数，而且窗口的x坐标也要为4的倍数。目前所有的窗口大小都是4的倍数，所以不需要修改了，而对于窗口坐标，我们需要做AND运算来取整，使打开窗口时的显示位置为4的倍数。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 5) {

sht = sheet_alloc(shtctl);

sht->task = task;

sht->flags |= 0x10;

sheet_setbuf(sht, (char *) ebx + ds_base, esi, edi, eax);

make_window8((char *) ebx + ds_base, esi, edi, (char *) ecx + ds_base, 0);

sheet_slide(sht, ((shtctl->xsize - esi) / 2) & ~3, (shtctl->ysize - edi) / 2);/*这里！*/

sheet_updown(sht, shtctl->top); /*将窗口图层高度指定为当前鼠标所在图层的高度，鼠标移到上层*/

reg[7] = (int) sht;

} else if (edx == 6) {

（中略）

}




其中~3的意思是将3这个数的每个比特位进行取反，也就是等于0xfffffffc，之所以写成~3是因为这样写起来比较短，而且也不会由于f的个数太多而不小心写错。

还有一点，当用鼠标拖动窗口时如果目的地坐标不是4的倍数，我们这次的修改也就没有效果了，为了避免这种情况，我们必须保证目的地坐标为4的倍数才行。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int j, x, y, mmx = -1, mmy = -1, mmx2 = 0; /*这里！（添加mmx2）*/

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）



if (3 <= x && x < sht->bxsize - 3 && 3 <= y && y < 21) {

mmx = mx; /*切换到窗口移动模式*/

mmy = my;

mmx2 = sht->vx0; /*这里！*/

}

（中略）

}

}

}

} else {

/*如果处于窗口移动模式*/

x = mx - mmx; /*计算鼠标指针移动量*/

y = my - mmy;

sheet_slide(sht, (mmx2 + x + 2) & ~3, sht->vy0 + y); /*这里！*/

mmy = my; /*更新到移动后的坐标*/

}

} else {

（中略）

}

}

}

}

}

}




变量mmx2的功能是保存移动前的sht—>vx0的值。

sheet_slide的地方我们做了AND运算，之所以要先加2再做AND，是因为只做AND的话就像直接舍去小数一样，容易造成窗口往左移，而如果先加上2就相当于做了四舍五入，使往左和往右移的几率对等。

■■■■■

好了，我们来“make run”。哇哦！好快！如果说之前移动窗口是“唰唰唰”的感觉的话，现在比之前变得更加流畅了，差不多是“嗖嗖嗖”这样吧。大家可以在CPU特别慢的电脑上用QEMU来对比一下，一定能明显感觉到差距的。



截图上看不出来，不过速度快了不少





3　提高窗口移动速度（3）（harib23c）

我们发现一次性写入4个字节这个办法可以有效地提高速度，既然如此，这个办法是不是也能用在sheet_refreshmap以外的函数中呢？于是我们首先想到了sheet_refreshsub，窗口移动的时候也调用了这个函数，因此通过修改它可以提高窗口移动的速度，此外其他一些地方也会调用这个函数，如果顺利的话，系统整体的绘图速度都会有所提升，真是令人兴奋呀。

本次的sheet.c节选

void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1)

{

int h, bx, by, vx, vy, bx0, by0, bx1, by1, bx2, sid4, i, i1, *p, *q, *r; /*这里！*/

（中略）

for (h = h0; h <= h1; h++) {

（中略）

if ((sht->vx0 & 3) == 0) { /*从此开始*/

/* 4字节型*/

i = (bx0 + 3) / 4; /* bx0除以4（小数进位）*/

i1 = bx1 / 4; /* bx1除以4（小数舍去）*/

i1 = i1 - i;

sid4 = sid | sid << 8 | sid << 16 | sid << 24;

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1 && (bx & 3) != 0; bx++) { /*前面被4除多余的部分逐个字节写入*/

vx = sht->vx0 + bx;

if (map[vy * ctl->xsize + vx] == sid) {

vram[vy * ctl->xsize + vx] = buf[by * sht->bxsize + bx];

}

}

vx = sht->vx0 + bx;

p = (int *) &map[vy * ctl->xsize + vx];

q = (int *) &vram[vy * ctl->xsize + vx];

r = (int *) &buf[by * sht->bxsize + bx];

for (i = 0; i < i1; i++) { /* 4的倍数部分*/

if (p[i] == sid4) {

q[i] = r[i]; /*估计大多数会是这种情况，因此速度会变快*/

} else {

bx2 = bx + i * 4;

vx = sht->vx0 + bx2;

if (map[vy * ctl->xsize + vx + 0] == sid) {

vram[vy * ctl->xsize + vx + 0] = buf[by * sht->bxsize + bx2 + 0];

}

if (map[vy * ctl->xsize + vx + 1] == sid) {

vram[vy * ctl->xsize + vx + 1] = buf[by * sht->bxsize + bx2 + 1];

}

if (map[vy * ctl->xsize + vx + 2] == sid) {

vram[vy * ctl->xsize + vx + 2] = buf[by * sht->bxsize + bx2 + 2];

}

if (map[vy * ctl->xsize + vx + 3] == sid) {

vram[vy * ctl->xsize + vx + 3] = buf[by * sht->bxsize + bx2 + 3];

}

}

}

for (bx += i1 * 4; bx < bx1; bx++) { /*后面被4除多余的部分逐个字节写入*/

vx = sht->vx0 + bx;

if (map[vy * ctl->xsize + vx] == sid) {

vram[vy * ctl->xsize + vx] = buf[by * sht->bxsize + bx];

}

}

}



} else {

/* 1字节型*/

for (by = by0; by < by1; by++) {

vy = sht->vy0 + by;

for (bx = bx0; bx < bx1; bx++) {

vx = sht->vx0 + bx;

if (map[vy * ctl->xsize + vx] == sid) {

vram[vy * ctl->xsize + vx] = buf[by * sht->bxsize + bx];

}

}

}

} /*到此结束*/

}

return;

}




这样一来，当窗口显示位置为4的倍数时速度就会变快。重绘画面时，重绘范围不一定为4的倍数，因此我们也考虑了这种情况的处理方法：当前面有余数时将余数部分逐个字节处理，后面有余数时也一样。不过，即便窗口本身没有透明色，当它和别的窗口或者鼠标重叠时我们也不能直接往相邻的内存地址中写入数据，因此for循环中用来判断map的值是否等于sid的if语句还是不能去掉的。

■■■■■

我们来“make run”吧。哦哦，好快！移动起来嗖嗖的，昨天我们还在忍受着龟速呢，现在想想就跟做梦似的，耶！



截图上看不出来，不过速度快了很多





4　提高窗口移动速度（4）（harib23d）

虽说窗口移动的速度已经快了很多，但还是无法完全跟上鼠标指针那矫健的身影（啊，在真机环境下当然还是跟得上的，这里是说在QEMU中运行的情形，大家别误会哦）。更进一步的提速我们现在还做不到，不过我们可以动点脑筋，在真正的速度不变的情况下，给用户带来好像变快了的错觉（笑）。

说起来，用“纸娃娃系统”之所以会感到速度慢，是因为移动窗口的时候，窗口移动的速度赶不上鼠标的速度，在放开鼠标键之后窗口还在那里挪动，因此我们只要针对这个现象想想办法就可以了。

为什么明明已经放开了鼠标键，窗口却还在挪动呢？这是因为伴随图层移动所进行的绘图操作非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据。那么我们可以在接收到鼠标移动数据后不立即进行绘图操作，但如果一直不绘图的话鼠标和窗口就静止不动了，那不就没意义了吗？我们可以等FIFO为空时再进行绘图操作嘛。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int mx, my, i, new_mx = -1, new_my = 0, new_wx = 0x7fffffff, new_wy = 0; /*这里！*/

（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

/* FIFO为空，当存在搁置的绘图操作时立即执行*/ /*从此开始*/

if (new_mx >= 0) {

io_sti();

sheet_slide(sht_mouse, new_mx, new_my);

new_mx = -1;

} else if (new_wx != 0x7fffffff) {

io_sti();

sheet_slide(sht, new_wx, new_wy);

new_wx = 0x7fffffff;

} else {

task_sleep(task_a);

io_sti();

} /*到此结束*/

} else {

（中略）

} else if (512 <= i && i <= 767) { /*到此结束*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

new_mx = mx; /*这里！*/

new_my = my; /*这里！*/

if ((mdec.btn & 0x01) != 0) {

/*按下鼠标左键*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {



（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (3 <= x && x < sht->bxsize - 3 && 3 <= y && y < 21) {

mmx = mx; /*切换到窗口移动模式*/

mmy = my;

mmx2 = sht->vx0;

new_wy = sht->vy0; /*这里！*/

}

（中略）

}

}

}

} else {

/*如果处于窗口移动模式*/

x = mx - mmx; /*计算鼠标指针移动量*/

y = my - mmy;

new_wx = (mmx2 + x + 2) & ~3; /*这里！*/

new_wy = new_wy + y; /*这里！*/

mmy = my; /*更新到移动后的坐标*/

}

} else {

/*没有按下鼠标左键*/

mmx = -1; /*切换到一般模式*/

if (new_wx != 0x7fffffff) { /*从此开始*/

sheet_slide(sht, new_wx, new_wy); /*固定图层位置*/

new_wx = 0x7fffffff;

} /*到此结束*/

}

}

}

}

}

}




这次我们增加了new_mx和new_wy两个变量，并将原来的sheet_slide（sht_mouse, mx, my）;改成了new_mx = mx; new_my = my;，也就是说，我们并不真的移动鼠标图层的位置，而是将移动后的坐标暂且保存起来，当FIFO为空时，再执行sheet_slide（sht_mouse, new_mx, new_my）;。

窗口移动我们也采用相同的方法，只不过有一点小小的区别，代表FIFO为空时不需要执行sheet_slide的值从-1变成了0x7fffffff，这是因为鼠标的坐标不可能为负数，但窗口的坐标却有可能为负数，因此用-1会造成歧义，我们只好改用另外一个不可能会出现的值，即0x7fffffff。

当放开鼠标左键退出窗口移动模式时，即便FIFO不为空也需要立即更新窗口的位置，这是因为用户可能马上会去移动别的窗口，那样的话sht变量的值就会发生变化，因此我们必须在sht变量的值改变之前将当前窗口移动到指定的位置。

■■■■■

好了，我们来“make run”……哇！即便在CPU很慢的电脑上用QEMU运行我们的系统，窗口也能跟鼠标同步快速移动，太好了！



截图上看不出来，不过跟鼠标完全同步





5　启动时只打开一个命令行窗口（harib23e）

昨天我们将命令行窗口的数量增加到了两个，还把碍眼的task_a窗口给去掉了，今天我们要让它看上去更像一个普通的操作系统。

说到这里，首先想到的是系统启动时所打开的命令行窗口数量，普通的操作系统没有一启动就打开两个命令行窗口的吧？一般都是先打开一个命令行窗口，然后根据需要增加。下面我们就将启动时显示的命令行窗口数量改为一个，并且实现可以随意启动新命令行窗口的功能吧。

■■■■■

这里我们需要考虑一下，如果启动一个新窗口需要让用户如何操作呢？比如说，在Windows2000的命令行窗口中输入“start cmd.exe”，就会出现一个新的命令行窗口。那么我们就来模仿一下这个方法，先编写一个用来启动新窗口的命令吧。

不过，实际使用操作系统的用户一般是在运行某个程序的同时突然想做另外一件事情，才需要开新窗口的。这时，如果只能通过命令来启动新窗口，就必须先强制关闭现在正在运行的应用程序，再往命令行窗口中输入命令才行——这也太麻烦了。

在Windows中，即便不在命令行中输入命令，只通过鼠标的操作也可以打开新的命令行窗口（比如可以通过开始菜单），我们的“纸娃娃系统”也可以借鉴一下这种方法。不过鼠标点击开始菜单这种方式实现起来太难，我们还是做快捷键吧，可以规定按下Shift+F2就打开一个新的命令行窗口。之所以用这个组合键，是因为程序改起来方便，如果不喜欢这个组合键的话，完全可以根据下面的范例自行修改哦。

修改后的程序如下：

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/* sht_cons */

sht_cons[0] = open_console(shtctl, memtotal); /*从此开始*/

sht_cons[1] = 0; /*未打开状态*/ /*到此结束*/



（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(sht_cons[0], 32, 4); /*这里！*/

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(sht_cons[0], 1); /*从此开始*/

sheet_updown(sht_mouse, 2); /*到此结束*/

key_win = sht_cons[0];

keywin_on(key_win);



（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x3c && key_shift != 0 && sht_cons[1] == 0) { /* Shift+F2 */

sht_cons[1] = open_console(shtctl, memtotal);

sheet_slide(sht_cons[1], 32, 4);

sheet_updown(sht_cons[1], shtctl->top);

/*自动将输入焦点切换到新打开的命令行窗口（这样比较方便吧？） */

keywin_off(key_win);

key_win = sht_cons[1];

keywin_on(key_win);

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

}

}

}

}



struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal)



{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct SHEET *sht = sheet_alloc(shtctl);

unsigned char *buf = (unsigned char *) memman_alloc_4k(memman, 256 * 165);

struct TASK *task = task_alloc();

int *cons_fifo = (int *) memman_alloc_4k(memman, 128 * 4);

sheet_setbuf(sht, buf, 256, 165, -1); /*无透明色*/

make_window8(buf, 256, 165, "console", 0);

make_textbox8(sht, 8, 28, 240, 128, COL8_000000);

task->tss.esp = memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 - 12;

task->tss.eip = (int) &console_task;

task->tss.es = 1 * 8;

task->tss.cs = 2 * 8;

task->tss.ss = 1 * 8;

task->tss.ds = 1 * 8;

task->tss.fs = 1 * 8;

task->tss.gs = 1 * 8;

*((int *) (task->tss.esp + 4)) = (int) sht;

*((int *) (task->tss.esp + 8)) = memtotal;

task_run(task, 2, 2); /* level=2, priority=2 */

sht->task = task;

sht->flags |= 0x20; /*有光标*/

fifo32_init(&task->fifo, 128, cons_fifo, task);

return sht;

}




首先，我们将打开命令行窗口的程序封装成了一个单独的函数（open_console），然后将没有打开的窗口的sht_cons[]置为0以示区别。当按下Shift+F2且第2个命令行窗口处于未打开状态时将其打开。

■■■■■

那么我们来“make run”吧，先来运行我们特别喜欢的color2.hrb，然后按下Shift+F2打开新的命令行窗口，再运行lines.hrb。成功了，好开心呀！



刚刚启动完毕的画面（只有一个命令行窗口） 成功启动了另一个命令行窗口





6　增加更多的命令行窗口（harib23f）

命令行窗口最多只能打开两个，这太不方便了，要是能打开更多的窗口就好了。那我们写一个sht_cons[100]之类的不就行了吗？不过仔细想想看，这个sht_cons[]到底是用来干什么的呢？怎么想也想不通啊，特地定义这个变量保存了一个值，实际上却根本没有用到！

因此，我们干脆不用sht_cons[]了，如果顺利的话，命令行窗口将不再有数量的限制，只要内存空间足够，就可以想开多少开多少。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct SHEET *sht_back, *sht_mouse; /*删掉了sht_cons[2]*/

（中略）



/* sht_cons */

key_win = open_console(shtctl, memtotal);



（中略）



sheet_slide(sht_back, 0, 0);

sheet_slide(key_win, 32, 4); /*这里！*/

sheet_slide(sht_mouse, mx, my);

sheet_updown(sht_back, 0);

sheet_updown(key_win, 1); /*这里！*/

sheet_updown(sht_mouse, 2);

keywin_on(key_win);



（中略）



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x3c && key_shift != 0) { /* Shift+F2 */

/*自动将输入焦点切换到新打开的命令行窗口（这样比较方便吧？）*/

/*从此开始*/ keywin_off(key_win);

key_win = open_console(shtctl, memtotal);

sheet_slide(key_win, 32, 4);

/*到此结束*/ sheet_updown(key_win, shtctl->top);

keywin_on(key_win);

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

}

}

}

}




程序写好了，之前的程序中我们是先向sht_cons[]赋值，然后再由sht_cons[]赋值给key_win，现在我们改成直接向key_win赋值了。

这样能不能行呢？改得太彻底了，笔者有点担心呢。不过这样也无济于事，还是“make run”一下试试看吧……哦哦，成功了！我们可以打开好多个命令行窗口了，运行多个应用程序也没问题哦，太棒了！



启动成功 打开3个命令行窗口





运行3个应用程序





7　关闭命令行窗口（1）（harib23g）

现在，我们对新开命令行窗口这个功能已经很满意了，不过如果一高兴刹不住车打开太多命令行窗口的话，画面就会变得拥挤不堪，同时也会浪费内存，所以我们得想个办法来关闭命令行窗口才行。

在Windows的命令行窗口中，输入“exit”命令就可以关闭当前窗口，我们也来照猫画虎，给“纸娃娃系统”增加一个exit命令吧。

在关闭一个命令行窗口时系统需要做些什么事呢？首先需要将创建该窗口时所占用的内存空间全部释放出来，然后还需要释放窗口的图层和任务结构。咦，问题来了，在创建任务时我们为命令行窗口准备了专用的栈，却没有将这个栈的地址保存起来，这样的话就无法执行释放操作了。怎么办呢？我们可以在TASK结构中添加一个cons_stack成员，用来保存栈的地址。

■■■■■

好，我们先进行以下修改。

本次的bootpack.h节选

struct TASK {

int sel, flags; /* sel为GDT编号*/

int level, priority;

struct FIFO32 fifo;

struct TSS32 tss;

struct CONSOLE *cons;

int ds_base, cons_stack; /*这里！*/

};




本次的bootpack.c节选

struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal)

{

（中略）

task->cons_stack = memman_alloc_4k(memman, 64 * 1024); /*从此开始*/

task->tss.esp = task->cons_stack + 64 * 1024 - 12; /*到此结束*/

（中略）

}



void close_constask(struct TASK *task)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

task_sleep(task);

memman_free_4k(memman, task->cons_stack, 64 * 1024);

memman_free_4k(memman, (int) task->fifo.buf, 128 * 4);

task->flags = 0; /*用来替代task_free(task); */

return;

}



void close_console(struct SHEET *sht)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct TASK *task = sht->task;

memman_free_4k(memman, (int) sht->buf, 256 * 165);

sheet_free(sht);

close_constask(task);

return;

}




一上来笔者只写了一个用来结束命令行窗口任务的close_constask函数，不过关闭命令行窗口还需要关闭图层，于是就又写了一个close_console函数，在关闭图层之后调用close_constask。其实，将这个两个功能都整合到close_console里面也可以，不过我们后面还需要只关闭任务不关闭图层的功能，因此在这里我们先分成两个函数来写。

在close_constask中，一开始我们先让任务进入休眠状态，这是为了将任务从等待切换列表中安全地剥离出来，因为这样一来就绝对不会切换到该任务，我们就可以安全地释放栈和FIFO缓冲区了。当全部内存空间都释放完毕之后，为了task_alloc下次能够重新利用这些内存空间，我们还需要将flags置为0。

到这里bootpack.c的准备就完成了，下面我们来编写exit命令。

■■■■■

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)

{

（中略）

} else if (strcmp(cmdline, "exit") == 0) {

cmd_exit(cons, fat);

} else if (cmdline[0] != 0) {

（中略）

}



void cmd_exit(struct CONSOLE *cons, int *fat)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct TASK *task = task_now();

struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4);

struct FIFO32 *fifo = (struct FIFO32 *) *((int *) 0x0fec);

timer_cancel(cons->timer);

memman_free_4k(memman, (int) fat, 4 * 2880);

io_cli();

fifo32_put(fifo, cons->sht - shtctl->sheets0 + 768); /* 768〜1023 */

io_sti();

for (;;) {

task_sleep(task);

}

}




exit命令的执行部分中，首先我们需要取消控制光标闪烁的定时器，然后将FAT用的内存空间释放，最后调用close_console关闭命令行窗口和自身的任务……咦？这里看出问题了吗？

如果在cmd_exit中调用close_console的话，就相当于close_constask中的task_sleep对自己这个任务本身执行休眠，那么之后的程序就都无法继续执行下去了。因此，我们需要让task_a来替我们执行这个操作（注：虽然现在已经没有task_a这个窗口了，但是task_a这个任务依然存在，它负责处理鼠标指针的移动、将键盘输入的数据分配给各命令行窗口等工作）。

那么我们可以从命令行窗口任务向task_a任务发送一个数据，请task_a帮忙关闭命令行窗口任务。task_a的FIFO地址保存在0x0fec这个地址（等一下我们会修改bootpack.c让它将地址写入这里），只要读取出来并发送数据就可以了。为了防止发送数据期间产生中断请求导致发送失败，我们将发送数据的程序两边加上cli和sti。

发送完成之后，既然结束任务的处理已经交给task_a，那么命令行窗口任务本身也没有什么可做的了，接下来直接休眠就可以了。

■■■■■

我们还需要修改HariMain使其能够处理来自命令行窗口的768～1023的数据，另外，从现在开始可能会出现画面上一个窗口都没有的情况（如果关闭了所有的命令行窗口的话），因此我们必须对这样的情况做出应对。

本次的bootpack.c节选

void HariMain(void)

{

（省略）

*((int *) 0x0fec) = (int) &fifo; /*这里！*/



for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (key_win != 0 && key_win->flags == 0) { /*窗口被关闭*/ /*从此开始*/

if (shtctl->top == 1) { /*当画面上只剩鼠标和背景时*/

key_win = 0;

} else {

key_win = shtctl->sheets[shtctl->top - 1];

keywin_on(key_win);

} /*到此结束*/

}

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (s[0] != 0 && key_win != 0) { /*一般字符、退格键和回车键*/ /*这里！*/

fifo32_put(&key_win->task->fifo, s[0] + 256);

}

if (i == 256 + 0x0f && key_win != 0) { /* Tab键*/ /*这里！*/

（中略）

}

（中略）

if (i == 256 + 0x3b && key_shift != 0 && key_win != 0) { /* Shift+F1 */ /*这里！*/

（中略）

}

if (i == 256 + 0x3c && key_shift != 0) { /* Shift+F2 */

/*自动将输入焦点切换到新打开的命令行窗口（这样比较方便吧？）*/

if (key_win != 0) { /*从此开始*/

keywin_off(key_win);

} /*到此结束*/

key_win = open_console(shtctl, memtotal);

sheet_slide(key_win, 32, 4);

sheet_updown(key_win, shtctl->top);

keywin_on(key_win);

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

} else if (768 <= i && i <= 1023) { /*命令行窗口关闭处理*/ /*这里！*/

close_console(shtctl->sheets0 + (i - 768)); /*这里！*/

}

}

}

}




我们先来看最后关于“命令行窗口关闭处理”那一段。这段程序比较简单，只是完成命令行窗口所委托的操作而已。至于要关闭的图层句柄，是通过将命令行窗口发送过来的数据减去768计算出来的。

除此之外，我们还修改了关于key_win的部分，当画面上一个窗口都没有的情况下，自然也没有窗口处于输入模式，这时我们将key_win置为0，而通常情况下key_win是不可能为0的，这样就可以清楚地区别开来。当key_win为0时，字符输入和Shift+F1没有任何作用，因此我们对于这两种键盘输入不进行任何处理。

■■■■■

现在到了欢乐的“make run”时间，首先是刚刚启动完毕的画面。



刚刚启动结束的样子

然后，我们按Shift+F2新开几个窗口，并在窗口中输入exit命令。



要执行exit命令了哦

命令行窗口成功关闭了，成功了！



看，命令行窗口关闭了哦

如果把所有的窗口都关闭的话就是下面这个样子。当然，即便窗口都没有了，我们还可以按Shift+F2重新打开窗口，没有问题。



将所有的命令行窗口都关闭了





8　关闭命令行窗口（2）（harib23h）

做到这一步，接下来我们就来实现用鼠标关闭命令行窗口的功能。当鼠标点击窗口上的“×”按钮时，向命令行窗口任务发送4这个数据，命令行窗口接收到这个数据后则开始执行exit命令的程序。

话说，鼠标的点击是在task_a中处理的，为什么不直接在task_a中调用close_console，而要绕这么个弯子呢？因为如果直接在task_a中关闭命令行窗口的话，由窗口自身所管理的释放定时器及FAT内存空间的部分就难以实现了，因此我们还是选择向命令行窗口发送通知数据这种方式。

由于这次我们只需要将已经实现的功能通过鼠标来进行操作，所以修改起来比较简单。

本次bootpack.c节选

void HariMain(void)

{

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {



/*按下左键的情形*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

if ((sht->flags & 0x10) != 0) { /*是否为应用程序

窗口？*/

task = sht->task;

cons_putstr0(task->cons, "\nBreak(mouse) :\n");

io_cli(); /*禁止在强制结束处理时切换任务*/

task->tss.eax = (int) &(task->tss.esp0);

task->tss.eip = (int) asm_end_app;

io_sti();

/*从此开始*/ } else { /*命令行窗口*/

task = sht->task;

io_cli();

fifo32_put(&task->fifo, 4);

/*到此结束*/ io_sti();

}

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}

} else if (768 <= i && i <= 1023) { /*命令行窗口关闭处理*/

（中略）

}

}

}

}




我们在bootpack.c中仅仅增加了5行代码。

接下来是console.c，这里其实仅仅增加了3行代码。

本次console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

for (;;) {

（中略）

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (i == 4) { /*点击命令行窗口的“×”按钮*/ /*从此开始*/

cmd_exit(&cons, fat);

} /*到此结束*/

（中略）

}

}

}




好，完工了，简单就是好啊，如果一直都这么简单的话，笔者也能轻松多了……哦，对了，我们还是先“make run”吧。哇，按“×”按钮可以顺利关闭命令行窗口了，成功了！



点击这里…… 窗口就关闭了

顺便说一句，在应用程序运行的时候，点击命令行窗口的“×”按钮是不会关闭命令行窗口的。因为如果应用程序运行中关闭了命令行窗口，万一程序调用了显示字符的API，就不知道会造成什么后果了。



应用程序运行时点击“×”按钮命令行窗口也不会关闭





9　start命令（harib23i）

今天时间也不早了，差不多该结束了，不过30天大限将至，我们还剩好多东西没有做呢，因此今天大家就辛苦一下，再努把力吧。

我们在26.5节中提起过，Windows的命令行窗口里有一个start命令，它的功能是可以打开一个新的命令行窗口并运行指定的应用程序。讲这么多不如自己实践一下，在Windows中输入“start make run”试试看吧。

如果“纸娃娃系统”也有这个功能该多方便啊，那我们就来编写一个start命令吧。

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)

{

（省略）

} else if (strncmp(cmdline, "start ", 6) == 0) {

cmd_start(cons, cmdline, memtotal);

} else if (cmdline[0] != 0) {

（省略）

}



void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal)

{

struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4);

struct SHEET *sht = open_console(shtctl, memtotal);

struct FIFO32 *fifo = &sht->task->fifo;

int i;

sheet_slide(sht, 32, 4);

sheet_updown(sht, shtctl->top);

/*将命令行输入的字符串逐字复制到新的命令行窗口中*/

for (i = 6; cmdline[i] != 0; i++) {

fifo32_put(fifo, cmdline[i] + 256);

}

fifo32_put(fifo, 10 + 256); /*回车键*/

cons_newline(cons);

return;

}




好，完工了，很简单吧。我们来“make run”，输入“start color2”……哦，成功了！



执行start命令 执行后的样子





10　ncst命令（harib23j）

本节要进行今天的最后一项修改。

用start命令启动应用程序看起来很不错，但如果运行color这样的程序的话，我们并不希望真的新开一个命令行窗口出来，反倒是没有这个多余的窗口比较好。那么下面我们就来做一个不打开新命令行窗口的start命令吧，给它起个名字，叫做“no console start”，简称ncst命令。

这样，我们可以根据需要来选择用哪个命令：当希望运行程序的同时打开新的命令行窗口时，用start命令；而当不需要打开新的命令行窗口时，就用ncst命令。

不过，不打开命令行窗口而直接运行应用程序到底应该怎样实现呢？想来想去，总觉得要改的地方实在太多了，我们还是一步一步慢慢来吧。其实我们可以换个思路，不要一味去想“没有命令行窗口该怎样处理”，而可以“想办法禁止向命令行显示内容”（换句话说，用ncst命令启动的应用程序会忽略字符串显示API的调用）。

■■■■■

好了，我们先从添加ncst命令开始做起吧。

我们将没有窗口的命令行任务的cons—>sht规定为0。在没有窗口的情况下，执行mem命令和cls命令也没有用，因此我们将这些命令全部忽略。

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)

{

if (strcmp(cmdline, "mem") == 0 && cons->sht != 0) { /*从此开始*/

cmd_mem(cons, memtotal);

} else if (strcmp(cmdline, "cls") == 0 && cons->sht != 0) {

cmd_cls(cons);

} else if (strcmp(cmdline, "dir") == 0 && cons->sht != 0) {

cmd_dir(cons);

} else if (strncmp(cmdline, "type ", 5) == 0 && cons->sht != 0) { /*到此结束*/

cmd_type(cons, fat, cmdline);

} else if (strcmp(cmdline, "exit") == 0) {

cmd_exit(cons, fat);

} else if (strncmp(cmdline, "start ", 6) == 0) {

cmd_start(cons, cmdline, memtotal);

} else if (strncmp(cmdline, "ncst ", 5) == 0) { /*这里！*/

cmd_ncst(cons, cmdline, memtotal); /*这里！*/

} else if (cmdline[0] != 0) {

（中略）

}



void cmd_ncst(struct CONSOLE *cons, char *cmdline, int memtotal)

{

struct TASK *task = open_constask(0, memtotal);

struct FIFO32 *fifo = &task->fifo;

int i;

/*将命令行输入的字符串逐字复制到新的命令行窗口中*/

for (i = 5; cmdline[i] != 0; i++) {

fifo32_put(fifo, cmdline[i] + 256);

}

fifo32_put(fifo, 10 + 256); /*回车键*/

cons_newline(cons);

return;

}




cmd_ncst是照着cmd_start的样子写的，其中open_constask这个函数我们接下来会写在bootpack.c中。

■■■■■

当cons—>sht为0时，要禁用命令行窗口的字符显示等所有操作，因此我们需要修改与其相关的函数。

本次的console.c节选

void cons_putchar(struct CONSOLE *cons, int chr, char move)

{

（中略）

if (s[0] == 0x09) { /*制表符*/

for (;;) {

if (cons->sht != 0) { /*从此开始*/

putfouts8_asc_sht(cons->sht, cons->cur_x, cons->cur_y, COL8_FFFFFF, COL8_000000, " ", 1);

} /*到此结束*/

cons->cur_x += 8;

（中略）

}

} else if (s[0] == 0x0a) { /*换行*/

cons_newline(cons);

} else if (s[0] == 0x0d) { /*回车*/

/*不执行任何操作*/

} else { /*一般字符*/

if (cons->sht != 0) { /*从此开始*/

putfouts8_asc_sht(cons->sht, cons->cur_x, cons->cur_y, COL8_FFFFFF, COL8_000000, s, 1);

} /*到此结束*/

if (move != 0) {

（中略）

}

}

return;

}



void cons_newline(struct CONSOLE *cons)

{

int x, y;

struct SHEET *sheet = cons->sht;

if (cons->cur_y < 28 + 112) {

cons->cur_y += 16; /*到下一行*/

} else {

/*滚动*/

if (sheet != 0) { /*这里！*/



for (y = 28; y < 28 + 112; y++) {

（中略）

}

for (y = 28 + 112; y < 28 + 128; y++) {

（中略）

}

sheet_refresh(sheet, 8, 28, 8 + 240, 28 + 128);

} /*这里！*/

}

cons->cur_x = 8;

return;

}




本以为相关的函数很多，所以要改动的地方也会很多，不过这么一看其实也没多少嘛。

■■■■■

接下来我们来修改console_task。修改的要点是，当不显示命令行窗口时，禁用一些不必要的处理，并且当命令执行完毕时，立即结束命令行窗口任务（应用程序运行完毕后，这个命令行窗口任务就派不上什么用场了。因为画面上不显示命令行窗口，也就无法输入其他命令，也不能执行关闭操作，所以我们需要使其在命令执行完毕时自动终止任务）。

本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

if (sheet != 0) { /*从此开始*/

cons.timer = timer_alloc();

timer_init(cons.timer, &task->fifo, 1);

timer_settime(cons.timer, 50);

} /*到此结束*/

（中略）

for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

task_sleep(task);

io_sti();

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/

（中略）

if (i == 8 + 256) {

（中略）

} else if (i == 10 + 256) {

/*回车键*/

/*用空白擦除光标后换行*/

cons_putchar(&cons, ' ', 0);

cmdline[cons.cur_x / 8 - 2] = 0;

cons_newline(&cons);

cons_runcmd(cmdline, &cons, fat, memtotal); /*执行命令*/

if (sheet == 0) { /*从此开始*/

cmd_exit(&cons, fat);

} /*到此结束*/

/*显示提示符*/



cons_putchar(&cons, '>', 1);

} else {

（中略）

}

}

/*重新显示光标*/

if (sheet != 0) { /*从此开始*/

if (cons.cur_c >= 0) {

boxfill8(sheet->buf, sheet->bxsize, cons.cur_c,

cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15);

}

sheet_refresh(sheet, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16);

} /*到此结束*/

}

}

}




■■■■■

cmd_exit也需要修改一下，添加用于无命令行窗口情况下的任务结束处理。

本次的console.c节选

void cmd_exit(struct CONSOLE *cons, int *fat)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct TASK *task = task_now();

struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4);

struct FIFO32 *fifo = (struct FIFO32 *) *((int *) 0x0fec);

if (cons->sht != 0) {

timer_cancel(cons->timer);

}

memman_free_4k(memman, (int) fat, 4 * 2880);

io_cli();

if (cons->sht != 0) { /*从此开始*/

fifo32_put(fifo, cons->sht - shtctl->sheets0 + 768); /* 768～1023 */

} else {

fifo32_put(fifo, task - taskctl->tasks0 + 1024); /*1024～2023*/

} /*到此结束*/

io_sti();

for (;;) {

task_sleep(task);

}

}




有命令行窗口时，我们可以通过图层的地址告诉task_a需要结束哪个任务，而无命令行窗口的情况下，这种方法就用不了了，因此在这里我们将TASK结构的地址告诉task_a。

■■■■■

接下来轮到bootpack.c了，首先来编写与open_constask相关的部分。

本次的bootpack.c节选

struct TASK *open_constask(struct SHEET *sht, unsigned int memtotal)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct TASK *task = task_alloc();

int *cons_fifo = (int *) memman_alloc_4k(memman, 128 * 4);

task->cons_stack = memman_alloc_4k(memman, 64 * 1024);

task->tss.esp = task->cons_stack + 64 * 1024 - 12;

task->tss.eip = (int) &console_task;

task->tss.es = 1 * 8;

task->tss.cs = 2 * 8;

task->tss.ss = 1 * 8;

task->tss.ds = 1 * 8;

task->tss.fs = 1 * 8;

task->tss.gs = 1 * 8;

*((int *) (task->tss.esp + 4)) = (int) sht;

*((int *) (task->tss.esp + 8)) = memtotal;

task_run(task, 2, 2); /* level=2, priority=2 */

fifo32_init(&task->fifo, 128, cons_fifo, task);

return task;

}



struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal)

{

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

struct SHEET *sht = sheet_alloc(shtctl);

unsigned char *buf = (unsigned char *) memman_alloc_4k(memman, 256 * 165);

sheet_setbuf(sht, buf, 256, 165, -1); /*无透明色*/

make_window8(buf, 256, 165, "console", 0);

make_textbox8(sht, 8, 28, 240, 128, COL8_000000);

sht->task = open_constask(sht, memtotal);

sht->flags |= 0x20; /*有光标*/

return sht;

}




到底修改了哪里呢？其实我们把之前open_console的一部分内容拿出来放到open_constask中了，正如把关闭命令行窗口的函数close_console中的一部分分离到close_constask中一样。

■■■■■

最后我们来修改HariMain，只要在结束命令行窗口任务的部分添加一些代码即可。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）



} else if (768 <= i && i <= 1023) { /*命令行窗口关闭处理*/

close_console(shtctl->sheets0 + (i - 768));

} else if (1024 <= i && i <= 2023) { /*从此开始*/

close_constask(taskctl->tasks0 + (i - 1024)); /*到此结束*/

}

}

}

}




呼，修改全部完成了，好累。

■■■■■

好了，我们来“make run”吧。首先试一下“ncst color”……撒花！成功了耶！碍眼的命令行窗口没有弹出来，画面上只有应用程序的窗口。开心之余，我们又运行了color2.hrb，当然，命令行窗口还是只有一个。



应用程序运行画面清清爽爽！

咦？用鼠标点击应用程序窗口的“×”按钮无法关闭窗口！用Shift+F1强制关闭也不行。这是怎么回事！不过，按回车键总算可以正常退出了，今晚就先这样将就一下吧。

话说，都已经半夜了，再不早点睡觉就要感冒了。大家晚安，这个bug我们留到明天解决吧。





第27天　LDT与库



先来修复bug （harib24a）

应用程序运行时关闭命令行窗口（harib24b）

保护应用程序（1）（harib24c）

保护应用程序（2）（harib24d）

优化应用程序的大小（harib24e）

库（harib24f）

整理make环境（harib24g）





1　先来修复bug（harib24a）

大家早上好，我们今天的第一个任务就是修复昨天晚上的那个bug。是个什么bug来着？就是用nsct命令运行的应用程序，无论是按Shift+F1还是点击窗口的“×”按钮都没有反应的那个bug啦。

我们得先来找到出问题的原因，然后才能采取对策。从昨天晚上到今天早上笔者一直在思考这个问题，想来想去暂时能得到的结论是，昨天编写的内容貌似没有什么问题，因此这个bug可能之前就已经存在了，只是我们没有发现而已。

所以说，今天早上我们不能局限在昨天修改过的范围中，而是要扩大一下思路。哦，终于找到了！其实只要修改两行代码就可以了。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

if (i == 256 + 0x3b && key_shift != 0 && key_win != 0) { /* Shift+F1 */

task = key_win->task;

if (task != 0 && task->tss.ss0 != 0) {

cons_putstr0(task->cons, "/\Break(key) :/\");

io_cli(); /*强制结束处理时禁止切换任务*/

task->tss.eax = (int) &(task->tss.esp0);

task->tss.eip = (int) asm_end_app;

io_sti();

/*这里！*/ task_run(task, -1, 0); /*为了确实执行结束处理，如果处于休眠状态则唤醒*/

}

}

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键的情形*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/*点击“×”按钮*/

if ((sht->flags & 0x10) != 0) { /*是否为应用程序

窗口*/

task = sht->task;

cons_putstr0(task->cons, "/\Break(mouse) :/ \");

io_cli(); /*强制结束处理时禁止切换任务*/

task->tss.eax = (int) &(task->tss.esp0);

task->tss.eip = (int) asm_end_app;

io_sti();

/*这里！*/ task_run(task, -1, 0);

} else { /*命令行窗口*/

（中略）

}

}

break;

}

}

}

} else {

（中略）

}

} else {

（中略）

}

}

} else if (768 <= i && i <= 1023) { /*命令行窗口结束处理*/

close_console(shtctl->sheets0 + (i - 768));

} else if (1024 <= i && i <= 2023) {

close_constask(taskctl->tasks0 + (i - 1024));

}

}

}

}




我们添加的两行语句都是task_run(task, -1, 0);，它的功能当然是将休眠的任务唤醒，不过为什么加上这两句问题就解决了呢？下面我们来一起探讨一下。

到底为什么需要唤醒任务呢？尽管我们特地在TSS中改写了EIP和EAX以便执行结束任务的处理，可如果任务一直处于休眠状态的话结束任务的处理就永远不会开始执行，因此我们需要唤醒它，使得结束处理确实能够被执行。

可是之前一直没有这个语句，强制结束功能也没出过问题，这是怎么回事呢？因为命令行窗口会触发用来控制光标闪烁的定时器中断（在命令行窗口中，不显示光标时也会每0.5秒触发一次定时器中断），当产生定时器中断时，定时器超时时会向FIFO写入数据，于是任务就被自动唤醒了。

在之前没有这个语句的情况下，（不使用ncst的时候）即便看上去可以正常执行强制结束，但其实距离应用程序真正结束还是会产生最大0.5秒的延迟。因此通过这次的修改，Shift+F1和“×”按钮的反应速度应该也会有所改善。

好，我们来“make run”，试试看用ncst运行的应用程序是否也可以通过点击“×”按钮关闭。哦哦，成功了！嗯嗯，感觉从点击按钮到程序关闭所经过的时间也确实比之前要短了。



点击这里…… 成功除掉bug了！





2　应用程序运行时关闭命令行窗口（harib24b）*

终于除掉了bug，神清气爽。命令行窗口的功能已经实现得差不多了，不过还有一个地方不太满意，就是在应用程序运行的时候无法关闭所对应的命令行窗口。

我们先不考虑ncst命令，用普通的方法运行应用程序的时候，在应用程序退出之前，我们是无法关闭用来启动这个程序的命令行窗口的。直到程序运行之后才觉得命令行窗口太碍事了，但事已至此也不想再重新启动应用程序（比如说，热水已经倒好了，总不能这个时候重新启动noodle.hrb吧！），于是就只好将就了。

因此还是想办法解决这个问题比较好。

■■■■■

首先我们来修改bootpack.c。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

struct SHEET *sht = 0, *key_win, *sht2; /*添加sht2 */

（中略）

for (;;) {

（中略）

if (fifo32_status(&fifo) == 0) {

（中略）

} else {

（中略）

if (256 <= i && i <= 511) { /*键盘数据*/

（中略）

} else if (512 <= i && i <= 767) { /*鼠标数据*/

（中略）

if (mouse_decode(&mdec, i - 512) != 0) {

（中略）

if ((mdec.btn & 0x01) != 0) {

/*按下左键的情形*/

if (mmx < 0) {

（中略）

for (j = shtctl->top - 1; j > 0; j--) {

（中略）

if (0 <= x && x < sht->bxsize && 0 <= y && y < sht->bysize) {

if (sht->buf[y * sht->bxsize + x] != sht->col_inv) {

（中略）

if (sht->bxsize - 21 <= x && x < sht->bxsize - 5 && 5 <= y && y < 19) {

/* 点击“×”按钮*/

if ((sht->flags & 0x10) != 0) { /*是否为应用程序窗口*/

（中略）

} else { /*命令行窗口*/

task = sht->task;

/*从此开始*/ sheet_updown(sht, -1); /*暂且隐藏该图层*/

keywin_off(key_win);

key_win = shtctl->sheets[shtctl->top - 1];

/*到此结束*/ keywin_on(key_win);

io_cli();

fifo32_put(&task->fifo, 4);

io_sti();

}

}

break;

}

}

}

} else {

（中略）

}

} else {



（中略）

}

}

} else if (768 <= i && i <= 1023) { /*命令行结束处理*/

close_console(shtctl->sheets0 + (i - 768));

} else if (1024 <= i && i <= 2023) {

close_constask(taskctl->tasks0 + (i - 1024));

} else if (2024 <= i && i <= 2279) { /*只关闭命令行窗口*/ /*从此开始*/

sht2 = shtctl->sheets0 + (i - 2024);

memman_free_4k(memman, (int) sht2->buf, 256 * 165);

sheet_free(sht2); /*到此结束*/

}

}

}

}




我们修改了bootpack.c中的两个地方。前面一个地方的修改是让系统在按下“×”按钮时暂且将命令行窗口从画面上隐藏起来。为什么要耍这样一个小聪明呢？这是因为关闭有的应用程序的命令行窗口时需要消耗一定的时间，如果点了按钮还不关闭用户会觉得很烦躁，先隐藏窗口就可以避免这样的问题。总之这只是一个小技巧而已，并不是本次修改的重点。

后面一处修改是当FIFO接收到从console.c发送的“关闭窗口”请求数据时所进行的处理，主要是释放指定的图层。关于这一处修改的内容，看了对console.c进行修改的部分之后会更容易理解。

■■■■■

下面就是对console.c的修改。

本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

if (cons.sht != 0) { /*这里！*/

（中略）

}

（中略）

for (;;) {

io_cli();

if (fifo32_status(&task->fifo) == 0) {

（中略）

} else {

（中略）

if (i <= 1 && cons.sht != 0) { /*光标用定时器*/ /*这里！*/

（中略）

}

（中略）

if (i == 3) { /*光标OFF */

if (cons.sht != 0) { /*这里！*/

boxfill8(cons.sht->buf, cons.sht->bxsize, COL8_000000, /*这里！*/

cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15);

}

cons.cur_c = -1;

}

（中略）

if (256 <= i && i <= 511) { /*键盘数据（通过任务A）*/



if (i == 8 + 256) {

（中略）

} else if (i == 10 + 256) {

（中略）

if (cons.sht == 0) { /*这里！*/

cmd_exit(&cons, fat);

}

（中略）

} else {

（中略）

}

}

/*重新显示光标*/

if (cons.sht != 0) { /*这里！*/

if (cons.cur_c >= 0) {

boxfill8(cons.sht->buf, cons.sht->bxsize, cons.cur_c, /*这里！*/

cons.cur_x, cons.cur_y, cons.cur_x + 7, cons.cur_y + 15);

}

/*这里！*/ sheet_refresh(cons.sht, cons.cur_x, cons.cur_y, cons.cur_x + 8, cons.cur_y + 16);

}

}

}

}




修改的要点是将变量sheet的部分改用变量cons.sht代替。虽然两个变量的值基本上是一致的，但cons.sht在命令行窗口关闭后会被置为0，而sheet则不变，因此在这里我们需要使用前者。

接下来我们来修改API中键盘输入的部分。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

struct FIFO32 *sys_fifo = (struct FIFO32 *) *((int *) 0x0fec); /*这里！*/

（中略）

} else if (edx == 15) {

for (;;) {

（中略）

if (i == 4) { /*只关闭命令行窗口*/ /*从此开始*/

timer_cancel(cons->timer);

io_cli();

fifo32_put(sys_fifo, cons->sht - shtctl->sheets0 + 2024); /*2024～2279*/

cons->sht = 0;

io_sti();

} /*到此结束*/

（中略）

}

} else if (edx == 16) {

（中略）

}




在等待键盘输入期间，如果FIFO中接收到4这个数据，则表示收到了关闭命令行窗口的信号，此时取消定时器，并发出清理图层的消息，然后将cons—>sht置为0。

■■■■■

好，大功告成了，我们来“make run”吧。

我们故意不使用ncst命令，而是用一般的方法运行笔者最喜欢的color2.hrb，程序启动后尝试关闭命令行窗口……耶！



color2.hrb启动时的样子 关闭命令行窗口后的样子





3　保护应用程序（1）（harib24c）

嘿嘿嘿，没想到吧，我胡汉三又回来了！最近“纸娃娃系统”进步很快嘛，命令行窗口也增加了呢，这样一来我搞起破坏来也更有成就感啦，嘿嘿。

这次我可是想出了新的攻击方法哦，一定要给大家露一手。现在有了异常保护功能，大家已经对安全很放心了吧？我就是要彻底粉碎你们的心理防线，嘿嘿嘿。啊，当然，我是不会用篡改操作系统那种低级手段的，只需要用一个应用程序就可以搞破坏了哦。

详细的原理我们后面再说，先来看下面这个应用程序吧，嘿嘿。

本次的crack7.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "crack7.nas"]



GLOBAL _HariMain



[SECTION .text]



_HariMain:

MOV AX,1005*8

MOV DS,AX

CMP DWORD [DS:0x0004],'Hari'



JNE fin ; 不是应用程序，因此不执行任何操作



MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小

MOV AX,2005*8

MOV DS,AX



crackloop: ; 整个用123填充

ADD ECX,-1

MOV BYTE [DS:ECX],123

CMP ECX,0

JNE crackloop



fin: ; 结束

MOV EDX,4

INT 0x40




这个要怎么用呢？首先“make run”并启动lines.hrb（不使用ncst），然后打开一个新的命令行窗口，在新窗口中运行crack7.hrb。这样一来，会发生很了不得的事情哟！哈哈哈！



运行lines.hrb后的样子/b> 运行crack7.hrb后的样子

唉？你说什么都没发生？你太天真了哦，不信你把鼠标移动到lines的窗口上试试看？怎么样，这次我赢了吧！



移动鼠标之后……

这次我们只攻击了lines.hrb，但对于其他的应用程序，用同样的手段也可以破坏它们哦。当然，对于不同的应用程序，其出现运行混乱的现象也不一样罢了。嘿嘿嘿。

好啦，我先闪了，你们努力研究研究找找原因吧！

■■■■■

哎呀，那个坏人又来了，而且还成功地攻击了我们的系统，真不甘心！

这次破坏行动的特征是，由于无法破坏操作系统本身，转而破坏运行中的应用程序，也就是找软柿子捏嘛。运行中的应用程序存在被破坏的风险，如果我们不拿出对策的话，用户可能就不敢同时运行多个应用程序了——如果因为一个程序的bug，而导致别的程序也受到牵连，甚至出错退出的话，那就不好了。

这个捣乱的程序到底做了什么坏事呢？首先它从1005号段的第4字节读取数据，判断其是否为“Hari”。这个1005其实是代表第一个打开的命令行窗口所运行的应用程序的代码段编号。

1003：task_a用（没有应用程序，不使用）

1004：idle用（没有应用程序，不使用）

1005：第一个命令行窗口的应用程序代码段

1006：第二个命令行窗口的应用程序代码段

如果从那个段读出“Hari”这个字符串，说明应用程序正在运行的可能性很高，接下来就读取段开头的4个字节，即应用程序用数据段的大小。

随后我们切换到2005号段，并将其中的内容全部用123这个数值填充。当然，123这个值并没有什么特别的意义，用234、255或者其他什么的都可以，目的只是覆盖应用程序数据段原有的内容，使其无法正常运行。这招好狠啊！

对于CPU来说，应用程序访问应用程序用的段是理所当然的事情，所以不会产生异常。

我们当然不能就这么败下阵来，得好好想想办法才行。要防御这样的攻击，我们只要禁止应用程序随意访问其他任务所拥有的内存段就可以了。这样一来，捣乱的程序就只能攻击自己了，结果只能是自取灭亡啦。





4　保护应用程序（2）（harib24d）

到底该怎样阻止应用程序攻击别的应用程序呢？我们倒是有一个办法，就是通过改写GDT的设置，只将正在运行的那个程序的段设置为应用程序用，其他的应用程序段都暂时设置为操作系统用。不过，用这个方法的话，需要在每次任务切换时都改写GDT的设置，话说我们现在每个任务也就只有两个应用程序段，这样看来这个方法也并不是不可行。

不过其实CPU已经为我们准备好了这个问题的解决方案，那就是LDT。难得有这么好的功能，我们当然要充分利用啦。

GDT是“global （segment） descriptor table”的缩写，LDT则是“local （segment） descriptor table”的缩写。相对于global代表“全局”，local则代表“局部”的意思，即GDT中的段设置是供所有任务通用的，而LDT中的段设置则只对某个应用程序有效。

如果将应用程序段设置在LDT中，其他的任务由于无法使用该LDT，也就不用担心它们来搞破坏了。

■■■■■

和GDT一样，LDT的容量也是64KB（可容纳设置8,192个段），不过在“纸娃娃系统”中我们现在只需要设置两个段，所以只使用了其中的16个字节，我们把这16个字节的信息放在struct TASK中。

我们可以通过GDTR这个寄存器将GDT的内存地址告知CPU，而LDT的内存地址则是通过在GDT中创建LDT段来告知CPU的。也就是说，在GDT中我们可以设置多个LDT（当然，不能同时使用两个以上的LDT），这和TSS非常相似。

下面我们在bootpack.h中添加用于设置LDT的段属性编号。

本次的bootpack.h节选

/* dsctbl.c */

（中略）

#define ADR_IDT 0x0026f800

#define LIMIT_IDT 0x000007ff

#define ADR_GDT 0x00270000

#define LIMIT_GDT 0x0000ffff

#define ADR_BOTPAK 0x00280000

#define LIMIT_BOTPAK 0x0007ffff

#define AR_DATA32_RW 0x4092

#define AR_CODE32_ER 0x409a

#define AR_LDT 0x0082 /*这里！*/

#define AR_TSS32 0x0089

#define AR_INTGATE32 0x008e



/* mtask.c */

（中略）

struct TASK {

int sel, flags; /* sel代表GDT编号*/

int level, priority;

struct FIFO32 fifo;

struct TSS32 tss;

struct SEGMENT_DESCRIPTOR ldt[2]; /*这里！*/

struct CONSOLE *cons;

int ds_base, cons_stack;

};




接下来我们修改mtask.c以便设置LDT。我们可以将LDT编号写入tss.ldtr，这样在创建TSS时就顺便在GDT中设置了LDT，CPU也就知道这个任务应该使用哪个LDT了。

本次的mtask.c节选

struct TASK *task_init(struct MEMMAN *memman)

{

（中略）

for (i = 0; i < MAX_TASKS; i++) {

taskctl->tasks0[i].flags = 0;

taskctl->tasks0[i].sel = (TASK_GDT0 + i) * 8;

taskctl->tasks0[i].tss.ldtr = (TASK_GDT0 + MAX_TASKS + i) * 8; /*这里！*/

set_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl->tasks0[i].tss, AR_TSS32);

set_segmdesc(gdt + TASK_GDT0 + MAX_TASKS + i, 15, (int) taskctl->tasks0[i].ldt, AR_LDT);

/*这里！*/

}

（中略）

}



struct TASK *task_alloc(void)

{

（中略）

for (i = 0; i < MAX_TASKS; i++) {

if (taskctl->tasks0[i].flags == 0) {

（中略）

task->tss.fs = 0;

task->tss.gs = 0;

/*删掉原来的task->tss.ldtr = 0;*/

task->tss.iomap = 0x40000000;

task->tss.ss0 = 0;

return task;

}

}

return 0; /*已经全部正在使用*/

}




最后我们来修改console.c，使得应用程序段创建在LDT中。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

if (finfo !=s 0) {

/*找到文件的情况*/

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

set_segmdesc(task->ldt + 0, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60); /*这里！*/

set_segmdesc(task->ldt + 1, segsiz - 1, (int) q, AR_DATA32_RW + 0x60); /*这里！*/

for (i = 0; i < datsiz; i++) {

q[esp + i] = p[dathrb + i];

}

start_app(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(task->tss.esp0)); /*这里！*/

（中略）

} else {

cons_putstr0(cons, ".hrb file format error.\n");

}

（中略）

}

（中略）

}




在start_app的地方，我们指定的段号是4（＝0×8＋4）和12（＝1×8＋4），这里乘以8的部分和GDT是一样的，但不一样的是还加上了4，这是代表“该段号不是GDT中的段号，而是LDT内的段号”的意思。

不过如果用这样的写法，在多个应用程序同时运行时，应用程序用的代码段号就都为4，数据段号都为12，这不就跟我们之前遇到的一个bug差不多了嘛（参阅25.7节）。其实不然，由于这里我们使用的是LDT的段号，而每个任务都有自己专用的LDT，因此这样写完全没有问题。耶！

于是我们总共只修改了8行代码就完成了对LDT的支持，赶紧来测试一下吧。

■■■■■

我们来“make run”，当然，之前能实现的功能现在也完全没问题。

然后我们运行lines.hrb，再运行crack7.hrb。哦哦，crack7产生异常了，这是因为1005和2005号段现在并不是应用程序用的代码段和数据段了。



crack7.hrb产生异常了哦

那么如果我们将crack7.nas中的段号从1005*8和2005*8改为4和12会怎么样呢？

修改的crack7.nas节选

_HariMain:

MOV AX,4 ; 这里！

MOV DS,AX

CMP DWORD [DS:0x0004],'Hari'

JNE fin ; 不是应用程序，因此不执行任何操作



MOV ECX,[DS:0x0000] ; 读取该应用程序数据段的大小

MOV AX,12 ; 这里！

MOV DS,AX




这样的话就变成自己攻击自己了，对lines.hrb没有任何影响，所以坏人被我们打败了。

不过对于坏人来说还有一个漏洞可以利用，那就是CPU中的LLDT指令，用这个指令可以改变LDTR寄存器（用于保存当前正在运行的应用程序所使用的LDT的寄存器）的值，这样的话就可以切换到其他应用程序的LDT，从而引发问题。但是大家别担心，因为这个指令是系统专用指令，位于应用程序段内的程序是无法执行的，即时要强行执行这个指令，也会像执行CLI指令那样产生异常（参阅22.1节），捣乱的程序就会被强制结束。

于是我们终于成功地保卫了“世界和平”，可喜可贺呀。





5　优化应用程序的大小（harib24e）

话说，我们的“纸娃娃系统”开发计划已经差不多接近尾声了，第29天和第30天我们主要是来编写一些应用程序的，对于操作系统本身的开发也就只剩下今明两天的时间了。正琢磨着这1天半里还能做点什么的时候，笔者忽然想起操作系统的大小来了。截止到harib24d时的haribote.sys大小为33 331字节，也就是32.5KB。麻雀虽小，五脏俱全，这么小的文件也已经具备了操作系统的基本功能了。

而另一方面，应用程序的大小又如何呢？不看不知道，一看吓一跳，hello3.hrb居然有520字节那么大了，在21.2节的时候明明才只有100字节来着！后来我们也只是将结束应用程序的方式改为了API方式而已，居然会增大到520字节，这也太不可思议了。

究其原因，主要是因为创建hello3.hrb时所引用的a_nask.nas变大了。也就是说，在hello3.hrb中，除了包含像_api_putchar和_api_end这样真正需要用到的函数之外，还包含了像_api_openwin和_api_linewin这些在这个应用程序中根本用不到的函数。

这实在是对空间的浪费，我们得想个办法才行。如果能够只将需要用到的部分包含在可执行文件中，就可以解决这个问题了。

■■■■■

那么我们该怎么办呢？我们可以将这些函数做成不同的.obj文件，将_api_putchar等需要用到的函数和_api_openwin等不需要用到的函数分离开。连接器（Linker，即obj2bim）的功能只是决定是否将.obj文件连接上去，而不会在一个包含多个函数的.obj文件中挑出需要使用的部分，并舍弃不需要使用的部分（这并不是因为obj2bim的功能不够强大，一般的连接器都是这样设计的）。

因此，我们将函数都拆开吧。

本次的api001.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "api001.nas"]



GLOBAL _api_putchar



[SECTION .text]



_api_putchar: ; void api_putchar(int c);

MOV EDX,1

MOV AL,[ESP+4] ; c

INT 0x40

RET




本次的api002.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "api002.nas"]



GLOBAL _api_putstr0



[SECTION .text]



_api_putstr0: ; void api_putstr0(char *s);

PUSH EBX

MOV EDX,2

MOV EBX,[ESP+8] ; s

INT 0x40

POP EBX

RET




本次的api003.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "api003.nas"]



GLOBAL _api_putstr1



[SECTION .text]



_api_putstr1: ; void api_putstr1(char *s, int l);

PUSH EBX

MOV EDX,3

MOV EBX,[ESP+ 8] ; s

MOV ECX,[ESP+12] ; l

INT 0x40

POP EBX

RET




照这样全都写出来的话太浪费纸张了，后面的就省略了哦（全部是从a_nask.nas中原封不动拆出来的）。依此类推，我们将这些函数拆分成api001.nas～api020.nas。

■■■■■

由于hello3.hrb所需要的.obj文件只有api001.obj和api004.obj，因此我们来修改一下Makefile。

修改后的Makefile节选

hello3.bim : hello3.obj api001.obj api004.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:hello3.bim map:hello3.map hello3.obj api001.obj api004.obj




这样一make，hello3.hrb就只有112字节了，减少了408字节，撒花！

我们索性将其他的应用程序也全部重新修改一下吧。首先是a.hrb，它所需的.obj文件也是api001和api004，所以像上面一样修改就可以了。

修改后的Makefile节选

a.bim : a.obj api001.obj api004.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj api001.obj api004.obj




然后是beepdown.hrb，它用到了api004、api015、api016、api017、api018和api020。

修改后的Makefile节选

beepdown.bim : beepdown.obj api004.obj api015.obj api016.obj api017.obj\

api018.obj api020.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:beepdown.bim stack:1k map:beepdown.map \

beepdown.obj api004.obj api015.obj api016.obj api017.obj api018.obj \

api020.obj




■■■■■

剩下也像这样一个一个修改好就可以了，不过笔者还是觉得好麻烦啊。在此之前我们什么都不用想，只要将a_nask.obj连接上去就好了，而现在还要根据程序来确认所使用的API。于是，笔者想了一个偷懒的办法。

其实obj2bim这个连接器有一个功能，如果所指定的.obj文件中的函数并没有被程序所使用，那么这个.obj文件是不会被连接的，所以我们把用不到的.obj文件写进去也没有问题。其实市面上大多数连接器都没有这个功能，只要指定好的.obj文件就都会连接进去，而笔者编写的这个obj2bim则会先判断一下。

利用这一特性我们就可以偷懒了，也就是说，我们可以不管三七二十一，把api001到api020全都写上去。比如说，a.hrb的话可以这样写：

修改后的Makefile节选

a.bim : a.obj api001.obj api002.obj （中略） api019.obj api020.obj Makefile

$(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj api001.obj api002.obj \

（中略） api019.obj api020.obj




虽然这样写很长，不过连接起来并没有什么问题（而且a.hrb也不会因此变大）。长是长了点，不过用文本编辑器的复制粘贴功能还是很快就能搞定的。

在将这一修改应用到所有的程序之前，笔者还是觉得Makefile太长的话不易于理解，因此我们还是想个办法改短一点吧。

本次的Makefile节选

OBJS_API = api001.obj api002.obj （中略） api019.obj api020.obj



a.bim : a.obj $(OBJS_API) Makefile

$(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj $(OBJS_API)




这样一来，今后如果追加了api021.obj，我们也只要在Makefile里修改一行代码就可以了。

我们将Makefile中的a_nask.obj全部替换为$(OBJS_API)之后，应用程序果然变小了很多，而且运行起来毫无问题，撒花！

应用程序名 大　　小 备　　注

hello.hrb 37→37 没有引用a_nask.obj，因此文件大小不变

hello2.hrb 25→25 没有引用a_nask.obj，因此文件大小不变

a.hrb 488→84

hello3.hrb 520→112

hello4.hrb 506→102

hello5.hrb 78→78 没有引用a_nask.obj，因此文件大小不变

winhelo.hrb 8024→7640

winhelo2.hrb 8088→7784

winhelo3.hrb 587→335

star1.hrb 566→306

stars.hrb 652→392

stars2.hrb 676→452

lines.hrb 638→406

walk.hrb 715→487

noodle.hrb 1969→1773

beepdowm.hrb 576→224

color.hrb 670→386

color2.hrb 796→512

crack7.hrb 96→96 没有引用a_nask.obj，因此文件大小不变

在做上表的时候发现，有几个应用程序是无法正常工作的。比如hello.hrb和hello2.hrb并不是用bim2hrb生成的，因此运行时会报hrb文件格式错误。此外，我们现在已经支持了LDT，crack7.hrb也就没什么用了。因此，上面3个文件我们会在harib24f中删除。





6　库（harib24f）

如果像上一节那样，把函数拆分开来，并用连接器来进行连接的话，我们需要创建很多很多个.obj文件。当然，如果不拆分函数，而是做成一个大的.obj文件也可以（如同a_nask.obj），但这样的话应用程序没有引用的函数也会被包含进去，生成的应用程序文件就会像之前那样无端增大很多。

作为一个操作系统来说，现在我们的“纸娃娃系统”规模还不算大，但如果我们要实现Windows和Linux这样的操作系统中的全部API函数，最终需要多少个.obj文件呢？大概得有几千个吧，只是想想头就大了。

要解决这个问题，我们可以使用“库”。库的英文名称是“library”，原本是图书馆的意思，在这里它的用途是将很多个.obj文件打包成一个文件（这种管理方式的确有点像图书馆吧），这样一来文件的数量就变少了，整个系统的结构也精简了。

要创建一个库，我们首先需要.obj文件作为原材料，除此之外，我们还需要一个叫做库管理器的程序。库管理器英文是“librarian”，原本是图书馆管理员的意思。其实， tolset中已经包含笔者编写的库管理器了，大家不用担心。

■■■■■

好了，我们马上来创建一个库吧。在Makefile中加上下面的代码。

本次的Makefile节选

GOLIB = $(TOOLPATH)golib00.exe



apilib.lib : Makefile $(OBJS_API)

$(GOLIB) $(OBJS_API) out:apilib.lib




完工了，通过短短几行代码我们就得到了apilib.lib这样一个文件。

我们可以在obj2bim中指定刚刚生成的这个apilib.lib来代替那一串.obj文件。仅从Makefile来看的话好像也没有太大的好处，不过只用一个.lib文件就能代替那么多.obj文件，怎么说都是很酷的哦。

本次的Makefile节选

a.bim : a.obj apilib.lib Makefile

$(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj apilib.lib




■■■■■

借此机会，我们顺便写一个apilib.h。

本次的apilib.h

void api_putchar(int c);

void api_putstr0(char *s);

void api_putstr1(char *s, int l);

void api_end(void);

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title);

void api_putstrwin(int win, int x, int y, int col, int len, char *str);

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col);

void api_initmalloc(void);

char *api_malloc(int size);

void api_free(char *addr, int size);

void api_point(int win, int x, int y, int col);

void api_refreshwin(int win, int x0, int y0, int x1, int y1);

void api_linewin(int win, int x0, int y0, int x1, int y1, int col);

void api_closewin(int win);

int api_getkey(int mode);

int api_alloctimer(void);

void api_inittimer(int timer, int data);

void api_settimer(int timer, int time);

void api_freetimer(int timer);

void api_beep(int tone);




有了它，我们用一句话就可以搞定应用程序开头的API函数声明了。

#include "apilib.h"




例如，beepdown.c就可以简化成下面这样了。

本次的beepdown.c节选

#include "apilib.h" /*这里！*/



void HariMain(void)

{

（中略）

}




这样的代码非常易读，因此我们把其他应用程序也改成这样了，看起来多清爽，耶！

■■■■■

下面我们来详细讲解一下库的知识。

在很久很久以前，程序都是一个整块，也就是说，编程的时候必须完整地从头写到尾，这种编程的方法自然是十分麻烦的。

后来，有人提出了一种新的编程方法：将程序的功能拆分为小的部件（函数），然后再组合起来构成一个完整的程序。这样，编写好的部件还可以保存起来，下次可以用在其他程序上面。这种编程方法被称为“结构化编程”。“纸娃娃系统”的核心以及各个应用程序就是由无数个函数组合而成的，这便是结构化编程理念的体现。

依据结构化编程的思想，把将来可以用于其他程序的部件组织起来就构成了库。结构化编程中库是一个很宽泛的概念，除了.lib文件，.obj文件本身也可以被称为库（总之凡是能作为部件使用的都是库）。

我们不仅在a.c中使用过用来调用API的函数，在其他程序的开发中也使用过。之前我们也没有特别提过，大家可能认为前面编写过的部分后面可以直接拿过来用是理所当然的，但其实这就是结构化编程的技术之一。

不断扩充的库就像自己所拥有的财产一样，手上拥有的部件种类越多，后面的各种开发工作就会越轻松、迅速。而且库不一定要自己来编写，我们也可以使用别人编写的库。例如，在“纸娃娃系统”中，我们所用到的sprintf和rand等函数就属于这一类。我们并没有在本书中特地编写这些函数，但依然能够正常地使用它们。因此，库也可以说是人类的公共财产（就像公共图书馆一样）。

在结构化编程的思想中，库越容易使用越好。如果文件数量太多，一不小心丢掉了其中一个又没有发现就非常麻烦了。此外，在将库分享给别人时，自然也是文件数量越少越好，与人方便，自己方便，因此像这种.lib形式的库是十分常用的。

■■■■■

对了，sprintf和rand其实包含在tolset的z_tool/haribote目录下的golibc.lib中。

顺便说一句，随着结构化编程的普及，人类的程序开发能力大幅提升，众多的开发者编写出了无数的库。但随着时代进步，函数的数量实在太多了，无法对每个函数的使用方法进行有效的管理。为了解决这个问题，“面向对象编程”的新思想应运而生（当然，这其实是结构化编程的扩展版，是在结构化编程思想的基础上发展而来的）。关于面向对象编程的具体内容，在这里就不详细讲解了（因为本书中并没有用面向对象编程的方法所开发的程序）。





7　整理make环境（harib24g）

也许是笔者的电脑性能比较差，最近感觉“make run”需要的时间很长。另外，操作系统、应用程序和库的源文件都混在一起，看起来非常混乱。因此，我们来把它们各归各位吧。



■■■■■

我们先从操作系统的部分开始吧。在harib24g中创建一个名为“haribote”的目录，将操作系统核心的源代码以及Makefile移动到这里。哦，清爽多了。这样一来目录结构就多了一层，我们也得对Makefile进行相应的修改。这个Makefile只是将原来的文件稍作修改而已，具体的代码我们就省略了哦。

现在如果我们要只make操作系统的话，只要双击haribote目录中的!cons.bat文件，并输入“make”就可以了。

由于这个目录中只包含操作系统核心部分，可以使用的命令只有“make”、“make clean”以及“make src_only”。如果要执行相当于 “make run”的操作的话，则需要在harib24g中输入“make run”来执行（稍后我们会详细讲解）。

■■■■■

接下来是库，我们创建一个名为“apilib”的目录，将库相关的源代码以及Makefile移动进去。唔，看上去也很清爽，真不错。这里的Makefile也是将原来的文件稍作修改而已，具体代码省略。

apilib中的命令也只有“make”、“make clean”以及“make src_only”，当然，对于库我们也不需要执行“make run”吧（笑）。

■■■■■

接下来轮到应用程序了。应用程序的Makefile比较短而且很有意思，我们还是写出来吧。下面这个是a.hrb的Makefile。

a.hrb用的Makefile

APP = a

STACK = 1k

MALLOC = 0k



include ../app_make.txt




怎么样？算上空行也才只有5行。不过话说回来，其实app_make.txt还是很长的，实际上也没有变短，只是“看上去变短了”而已。之所以要用include，是因为所有的应用程序的Makefile都大同小异，如果将其中相同的部分改为include方式来引用就可以缩短Makefile，而且如果以后要对Makefile进行修改的话，只需要修改app_make.txt就可以应用到所有的应用程序，修改起来会非常省事。

app_make.txt的内容如下，这个稍微有点长。

本次的app_make.txt

TOOLPATH = ../../z_tools/

INCPATH = ../../z_tools/haribote/

APILIBPATH = ../apilib/

HARIBOTEPATH = ../haribote/



MAKE = $(TOOLPATH)make.exe -r

NASK = $(TOOLPATH)nask.exe

CC1 = $(TOOLPATH)cc1.exe -I$(INCPATH) -I../ -Os -Wall -quiet

GAS2NASK = $(TOOLPATH)gas2nask.exe -a

OBJ2BIM = $(TOOLPATH)obj2bim.exe

MAKEFONT = $(TOOLPATH)makefont.exe

BIN2OBJ = $(TOOLPATH)bin2obj.exe

BIM2HRB = $(TOOLPATH)bim2hrb.exe

RULEFILE = ../haribote.rul

EDIMG = $(TOOLPATH)edimg.exe

IMGTOL = $(TOOLPATH)imgtol.com

GOLIB = $(TOOLPATH)golib00.exe

COPY = copy

DEL = del



#默认动作



default :

$(MAKE) $(APP).hrb



#文件生成规则



$(APP).bim : $(APP).obj $(APILIBPATH)apilib.lib Makefile ../app_make.txt

$(OBJ2BIM) @$(RULEFILE) out:$(APP).bim map:$(APP).map stack:$(STACK) \

$(APP).obj $(APILIBPATH)apilib.lib



$(APP).hrb : $(APP).bim Makefile ../app_make.txt

$(BIM2HRB) $(APP).bim $(APP).hrb $(MALLOC)



haribote.img : ../haribote/ipl10.bin ../haribote/haribote.sys $(APP).hrb \

Makefile ../app_make.txt

$(EDIMG) imgin:../../z_tools/fdimg0at.tek \

wbinimg src:../haribote/ipl10.bin len:512 from:0 to:0 \

copy from:../haribote/haribote.sys to:@: \

copy from:$(APP).hrb to:@: \

imgout:haribote.img



#一般规则



%.gas : %.c ../apilib.h Makefile ../app_make.txt

$(CC1) -o $*.gas $*.c



%.nas : %.gas Makefile ../app_make.txt

$(GAS2NASK) $*.gas $*.nas



%.obj : %.nas Makefile ../app_make.txt

$(NASK) $*.nas $*.obj $*.lst



#命令



run :

$(MAKE) haribote.img

$(COPY) haribote.img .. \.. \z_tools\qemu\fdimage0.bin

$(MAKE) -C ../../z_tools/qemu



full :

$(MAKE) -C $(APILIBPATH)

$(MAKE) $(APP).hrb



run_full :

$(MAKE) -C $(APILIBPATH)

$(MAKE) -C ../haribote

$(MAKE) run



clean :

-$(DEL) *.lst

-$(DEL) *.obj

-$(DEL) *.map

-$(DEL) *.bim

-$(DEL) haribote.img



src_only :

$(MAKE) clean

-$(DEL) $(APP).hrb




这里的重点是，可以使用的命令增加了。一般的“make”命令会生成a.hrb，这是理所当然的啦。如果执行“make run”的话，则会生成一个包含haribote.sys和a.hrb的精简版磁盘映像，然后调用QEMU来运行。

而这次我们又在此基础上新增了“make full”和“make run_full”两个命令。生成a.hrb时需要引用apilib.lib，但也可能出现在“make”a.hrb时apilib.lib还未完成的情况，这时我们应该用“make full”。在“make full”中，有“$(MAKE) –C $(APILIBPATH)”这样一条语句，表示“先执行apilib的make”的意思，而如果已经存在apilib.lib的话，这条语句将不执行任何操作。因此如果不放心的话，一直用“make full”来代替“make”也是可以的。而“make run_full”则是“make run”的full版，即将apilib和系统核心都make之后，再执行原本的“make run”操作。

最后来介绍一下harib24g的Makefile。

harib24g的Makefile

TOOLPATH = ../z_tools/

INCPATH = ../z_tools/haribote/



MAKE = $(TOOLPATH)make.exe -r

EDIMG = $(TOOLPATH)edimg.exe

IMGTOL = $(TOOLPATH)imgtol.com

COPY = copy

DEL = del



#默认动作



default :

$(MAKE) haribote.img



#文件生成规则



haribote.img : haribote/ipl10.bin haribote/haribote.sys Makefile\

a/a.hrb hello3/hello3.hrb hello4/hello4.hrb hello5/hello5.hrb \

winhelo/winhelo.hrb winhelo2/winhelo2.hrb winhelo3/winhelo3.hrb \

star1/star1.hrb stars/stars.hrb stars2/stars2.hrb \

lines/lines.hrb walk/walk.hrb noodle/noodle.hrb \

beepdown/beepdown.hrb color/color.hrb color2/color2.hrb

$(EDIMG) imgin:../z_tools/fdimg0at.tek \

wbinimg src:haribote/ipl10.bin len:512 from:0 to:0 \

copy from:haribote/haribote.sys to:@: \

copy from:haribote/ipl10.nas to:@: \

copy from:make.bat to:@: \

copy from:a/a.hrb to:@: \

copy from:hello3/hello3.hrb to:@: \

copy from:hello4/hello4.hrb to:@: \

copy from:hello5/hello5.hrb to:@: \

copy from:winhelo/winhelo.hrb to:@: \

copy from:winhelo2/winhelo2.hrb to:@: \

copy from:winhelo3/winhelo3.hrb to:@: \

copy from:star1/star1.hrb to:@: \

copy from:stars/stars.hrb to:@: \

copy from:stars2/stars2.hrb to:@: \

copy from:lines/lines.hrb to:@: \

copy from:walk/walk.hrb to:@: \

copy from:noodle/noodle.hrb to:@: \

copy from:beepdown/beepdown.hrb to:@: \

copy from:color/color.hrb to:@: \

copy from:color2/color2.hrb to:@: \

imgout:haribote.img



#命令



run :

$(MAKE) haribote.img

$(COPY) haribote.img ..\ z_tools\qemu \ fdimage0.bin

$(MAKE) -C ../z_tools/qemu



install :

$(MAKE) haribote.img

$(IMGTOL) w a: haribote.img



full :

$(MAKE) -C haribote

$(MAKE) -C apilib

$(MAKE) -C a



$(MAKE) -C hello3

$(MAKE) -C hello4

$(MAKE) -C hello5

$(MAKE) -C winhelo

$(MAKE) -C winhelo2

$(MAKE) -C winhelo3

$(MAKE) -C star1

$(MAKE) -C stars

$(MAKE) -C stars2

$(MAKE) -C lines

$(MAKE) -C walk

$(MAKE) -C noodle

$(MAKE) -C beepdown

$(MAKE) -C color

$(MAKE) -C color2

$(MAKE) haribote.img



run_full :

$(MAKE) full

$(COPY) haribote.img ../z_tools\qemu\fdimage0.bin

$(MAKE) -C ../z_tools/qemu



install_full :

$(MAKE) full

$(IMGTOL) w a: haribote.img



run_os :

$(MAKE) -C haribote

$(MAKE) run



clean :

#不执行任何操作



src_only :

$(MAKE) clean

-$(DEL) haribote.img



clean_full :

$(MAKE) -C haribote clean

$(MAKE) -C apilib clean

$(MAKE) -C a clean

$(MAKE) -C hello3 clean

$(MAKE) -C hello4 clean

$(MAKE) -C hello5 clean

$(MAKE) -C winhelo clean

$(MAKE) -C winhelo2 clean

$(MAKE) -C winhelo3 clean

$(MAKE) -C star1 clean

$(MAKE) -C stars clean

$(MAKE) -C stars2 clean

$(MAKE) -C lines clean

$(MAKE) -C walk clean

$(MAKE) -C noodle clean

$(MAKE) -C beepdown clean

$(MAKE) -C color clean

$(MAKE) -C color2 clean



src_only_full :

$(MAKE) -C haribote src_only

$(MAKE) -C apilib src_only

$(MAKE) -C a src_only

$(MAKE) -C hello3 src_only

$(MAKE) -C hello4 src_only

$(MAKE) -C hello5 src_only



$(MAKE) -C winhelo src_only

$(MAKE) -C winhelo2 src_only

$(MAKE) -C winhelo3 src_only

$(MAKE) -C star1 src_only

$(MAKE) -C stars src_only

$(MAKE) -C stars2 src_only

$(MAKE) -C lines src_only

$(MAKE) -C walk src_only

$(MAKE) -C noodle src_only

$(MAKE) -C beepdown src_only

$(MAKE) -C color src_only

$(MAKE) -C color2 src_only

-$(DEL) haribote.img



refresh :

$(MAKE) full

$(MAKE) clean_full

-$(DEL) haribote.img




在这里我们可以使用很多命令。

make 像之前一样，生成一个包含操作系统内核及全部应用程序的磁盘映像

make run “make”后启动QEMU

make install “make”后将磁盘映像安装到软盘中

make full 将操作系统核心、apilib和应用程序全部make后生成磁盘映像

make run_full “make full”后“make run”

make install_full “make full”后“make install”

make run_os 将操作系统核心make后执行“make run”，当只对操作系统核心进行修改时可使用这个命令

make clean 本来clean命令是用于清除临时文件的，但由于在这个Makefile中并不生成临时文件，因此这个命令不执行任何操作

make src_only 将生成的磁盘映像删除以释放磁盘空间

make clean_full 对操作系统核心、apilib和应用程序全部执行“make clean”，这样将清除所有的临时文件

make src_only_full 对操作系统核心、apilib和应用程序全部执行“make src_only”， 这样将清除所有的临时文件和最终生成物。不过执行这个命令后，“make”和“make run”就无法使用了（用带full版本的命令代替即可），make时会消耗更多的时间

make refresh “make full”后“make clean_full”。从执行过“make src_only_full”的状态执行这个命令的话，就会恢复到可以直接“make”和“make run”的状态

■■■■■

像这样划分好不同的目录后，程序看起来更加清爽了，make所用时间也缩短了。例如，当编写了一个新的应用程序时，harib24f的话需要全部重新生成一遍（因为修改了Makefile），但现在由于操作系统核心和应用程序的Makefile是分开的，因此不需要每次新增应用程序都重新生成一遍，make的速度也就变快了，耶！

嗯，在整理的时候发现有几个应用程序有点问题，比如说winhelo.hrb这个程序，窗口弹出之后马上就结束了，看不清窗口上面的内容，因此我们按照lines.c的方式将winhelo.c修改一下。

本次的winhelo/winhelo.c

#include "apilib.h"



char buf[150 * 50];



void HariMain(void)

{

int win;

win = api_openwin(buf, 150, 50, -1, "hello");

for (;;) { /*从此开始*/

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break; */

}

} /*到此结束*/

api_end();

}




winhelo2、winhelo3、star1、stars和stars2也有同样的问题，顺便全都改了一下。

好了，我们来“make run_full”吧。哦哦，运行正常，撒花！为了庆祝成功，我们把修改过的stars.hrb和winhelo3.hrb也运行一下，摆出来装点门面。



好多应用程序

本书光盘中的harib24g是执行过“make refresh”的状态，因此大家可以直接执行“make run”，而不用执行比较耗时的“make fun_full”。

好啦，今天我们已经很努力了，就到这里吧。明天继续，晚安喽！





第28天　文件操作与文字显示



alloca（1）（harib25a）

alloca（2）（harib25b）

文件操作API （harib25c）

命令行API （harib25d）

日文文字显示（1）（harib25e）

日文文字显示（2）（harib25f）

日文文字显示（3）（harib25g）





1　alloca（1）（harib25a）

今天我们准备来实现读取文件的功能和显示文字的功能，不过在做这些看上去很酷的事情之前，我们先来解决一些基本的问题，就当是热身吧。

首先，我们来编写一个简单的应用程序。

sosu.c

#include <stdio.h>

#include "apilib.h"



#define MAX 1000



void HariMain(void)

{

char flag[MAX], s[8];

int i, j;

for (i = 0; i < MAX; i++) {

flag[i] = 0;

}

for (i = 2; i < MAX; i++) {

if (flag[i] == 0) {

/*没有标记的为质数*/



sprintf(s, "%d ", i);

api_putstr0(s);

for (j = i * 2; j < MAX; j += i) {

flag[j] = 1; /*给它的倍数做上标记*/

}

}

}

api_end();

}




这个程序的功能是显示1000以内的质数，所谓质数，就是“只能被1及其本身整除的大于1的自然数”，例如2、3、5、7都是质数1，而4可以被2整除，6可以被2和3整除，因此它们不是质数。

1 质数又称素数。为什么这样的数会被称为素数呢？因为凡是2以上的整数都可以写成两个素数的乘积，也就是说，素数相当于构成整数世界的“元素”的意思吧。话说，如果不用乘法而是用加法分解整数的话，那么素数就只有1一个了，不过这样没什么研究价值，因此数学上就不研究它了。

将这个程序“make run”一下，当然会顺利运行啦。



运行结果 为了看清数列的开头，我们强制结束一下

嗯，看上去不错呢。这样一来，“纸娃娃系统”不但能用来给泡面计时，还能用来求质数了，太好了。

■■■■■

下面我们稍微修改一下这个程序，让它显示1万以内的质数。程序的修改很简单，只要把开头一句改成“#define MAX 10000”就行了，然后另存为sosu2.c。哦对了，这个程序需要在栈中保存很多变量（光flag[10000]就需要大概10KB的空间），因此在Makefile中指定的栈大小改为11k了。

然后我们来“make run”一下。咦？出现了一条神秘的警告：“Warning: can’t link __alloca”。我们不管它，继续执行，可运行后显示出奇怪的内容，然后就停止不动了。没办法，我们用Shift+F1强制结束。

显示1000以内的质数运行很正常，为什么sosu2.hrb就不行了呢？其实我们刚刚忽略的那条警告信息中暗含玄机，它其实是在提醒我们缺少一个叫__alloca的函数。

电脑上所使用的C语言编译器规定，如果栈中的变量超过4KB，则需要调用__alloca这个函数。这个函数的主要功能是根据操作系统的规格来获取栈中的空间。在Windows和Linux中，如果不调用这个函数，而是仅对ESP进行减法运算的话，貌似无法成功获取内存空间（小于4KB时只要对ESP进行减法运算即可）。

不过，在“纸娃娃系统”中，对于栈的管理并没有什么特殊的设计，因此也用不着去调用__alloca函数，可C语言的编译器又不是“纸娃娃系统”专用的，于是就会擅自去调用那个函数了。唉，C语言还是不让人省心啊。

为了解决这个问题，我们需要编写一个__alloca函数，只对ESP进行减法运算，而不做其他任何多余的操作。

■■■■■

好了，那我们就来编写__alloca吧……慢着，在编写这个函数之前，我们可以先想个办法在程序中获取这10KB的内存空间。其实，笔者曾经写不出成功的__alloca，当时就是用下面的方法将就的（笑）。

sosu3.c

#include <stdio.h>

#include "apilib.h"



#define MAX 10000



void HariMain(void)

{

char *flag, s[8]; /*这里！*/

int i, j;

api_initmalloc(); /*从此开始*/

flag = api_malloc(MAX); /*到此结束*/

for (i = 0; i < MAX; i++) {

flag[i] = 0;

}

for (i = 2; i < MAX; i++) {

if (flag[i] == 0) {

/*没有标记的为质数*/

sprintf(s, "%d ", i);

api_putstr0(s);

for (j = i * 2; j < MAX; j += i) {

flag[j] = 1; /*给它的倍数做上标记*/

}

}

}

api_end();

}




这样的程序应该就可以成功运行了，我们来试试看，“make run”。



1万以内的质数

果然成功了！这样看来，问题果然出在alloca上（而并不是算法的局限所导致的）。





2　alloca（2）（harib25b）

即便没有__alloca，只要用malloc就可以搞定了，我们就到这里结束吧……等等，我可没有这么说哦（笑）。栈中使用的变量一多，程序就无法正常运行了，这可说不过去呀。

alloca.nas

[FORMAT "WCOFF"]

[INSTRSET "i486p"]

[BITS 32]

[FILE "alloca.nas"]



GLOBAL __alloca



[SECTION .text]



__alloca:

ADD EAX,-4

SUB ESP,EAX

JMP DWORD [ESP+EAX] ; 代替RET




于是我们编写了包含上述内容的alloca.nas，并将它放在了apilib中。虽然它并不能称为API，但是另外归类实在太麻烦了，我们就先放在apilib中好了。

■■■■■

这个程序实际上只有3行内容，却颇有内涵，下面我们来讲解一下。

__alloca会在下述情况下被C语言的程序调用（采用near-CALL的方式）。



要执行的操作从栈中分配EAX个字节的内存空间（ESP -= EAX;）



要遵守的规则不能改变ECX、EDX、EBX、EBP、ESI、EDI的值（可以临时改变它们的值，但要使用PUSH/POP来复原）





看到这里大家可能会想“什么嘛？这么简单”，于是就编写出下面这样的程序：

错误的alloca示例(1)

SUB ESP,EAX

RET




但这个程序是无法运行的，因为RET返回的地址保存在了ESP中，而ESP的值在这里被改变了，于是读取了错误的返回地址（注意：“RET”指令实际上相当于“POP EIP”）。

■■■■■

既然这个不行，我们又想到了别的办法。

错误的alloca示例(2)

SUB ESP,EAX

JMP DWORD [ESP+EAX] ; 代替RET




这个貌似不错，JMP的目标地址从[ESP]变成了[ESP+EAX]，而ESP+EAX的值正好是减法运算之前的ESP值，也就是正确的地址。

不过这样还是有个问题，“RET”指令相当于“POP EIP”，而“POP EIP”实际上又相当于下面两条指令：

MOV EIP,[ESP] ; 没有这个指令，用JMP [ESP]代替

ADD ESP,4




也就是说，刚刚我们忘记给ESP加上4，因此ESP的值就有了误差。

那么我们再来改良一下，程序就变成了下面这样。

错误的alloca示例(3)

SUB ESP,EAX

JMP DWORD [ESP+EAX] ; 代替RET

ADD ESP,4




这个程序的问题在于ADD指令的位置，将ADD指令放在了JMP指令的后面，所以是不可能被执行的，因此也失败了。

■■■■■

这次我们一定得解决这个问题，于是我们将程序改成了下面这样。

基本正确的alloca示例

SUB ESP,EAX

ADD ESP,4

JMP DWORD [ESP+EAX-4] ; 代替RET




这个程序可以成功运行，太好了！因此将这个程序直接作为alloca.nas也没问题。这里的要点是：先加上4，然后在JMP指令的地址计算中再减掉4.

讲到这里，再回头看看前面实际的__alloca，怎么样，更加简短吧？不错不错。

■■■■■

这样一来sosu2.hrb应该就可以正常运行了，我们来试试看，“make run”。



看，成功了！ 为了防止你们说我用sosu3滥竽充数，来看一下开头

运行成功，耶！

话说，sosu2.hrb和sosu3.hrb在运行结果上就没有什么区别了，那么程序的大小如何呢？

sosu2.hrb：1484字节

sosu3.hrb：1524字节

虽然差距不大，但还是sosu2.hrb更胜一筹。

既然如此，我们让winhelo也从栈中分配buf的空间吧。HariMain函数中声明的变量在程序结束前是不会被释放的，因此完全可以代替。

本次的winhelo.c

#include "apilib.h"



void HariMain(void)

{

int win;

char buf[150 * 50]; /*这里！*/

win = api_openwin(buf, 150, 50, -1, "hello");

for (;;) {

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break;*/

}

}

api_end();

}




在Makefile中设定“STACK = 8k”，然后“make run”一下（buf大约需要7.5KB的空间）。哦哦，运行成功了，而且程序大小变为174字节了，要知道修改前的大小有7664字节呢（因为有“RESB 7500”），真是个重大改进。由于担心磁盘空间不够（考虑到后面我们还要加入字库），因此应用程序当然是越小越好。



174字节的程序就可以实现这样的功能！

说实话，本来winhelo.hrb一开始就是从栈中为buf分配空间的，不过buf差不多要占用7.5KB，超过4KB了，没有alloca的话是不会成功运行的。如果在22.5节那个阶段就引入alloca的话，整体的条理就会被打乱，因此笔者才不得已将buf的声明放到函数外面，勉强算是挺过了那一关（C语言中，在函数外部声明的变量和带static的变量一样，都会被解释为DB和RESB；在函数内部不带static声明的变量则会从栈中分配空间）。

随后，在23.1节中由于我们引入了malloc，所以即便没有alloca也可以尽量缩小应用程序的大小，于是就没有机会讲解alloca了。在这里笔者想说的是，现在我们终于让winhelo.hrb恢复到它本来的样子了，可喜可贺呀。

下面，我们顺便将winhelo2.hrb也修改一下。

本次的winhelo2.hrb

#include "apilib.h"



void HariMain(void)

{

int win;

char buf[150 * 50]; /*这里！*/

win = api_openwin(buf, 150, 50, -1, "hello");

api_boxfilwin(win, 8, 36, 141, 43, 3 /*黄色*/);

api_putstrwin(win, 28, 28, 0 /*黑色*/, 12, "hello, world");

for (;;) {

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break;*/

}

}

api_end();

}




大功告成。说是修改，其实也就是移动了1行代码而已。我们来“make run”一下……咦，一般保护异常？哎呀不好，忘记将STACK设定为8k了。

设定为8k之后就可以正常运行了，程序只有315字节，撒花！

改良前的winhelo2.hrb：7808字节

改良后的winhelo2.hrb：315字节

winhelo3.hrb（用malloc方式）：359字节





3　文件操作API（harib25c）

好了，让我们进入今天的第一个主题——文件操作API吧。所谓文件操作API，就是可以指定文件，并能自由读写文件内容的API。现在我们的“纸娃娃系统”还不能对磁盘进行写入操作，因此只要能读取文件内容就可以了。

一般的操作系统中，输入输出文件的API基本上都有下面这些功能（当然，还有其他一些次要的功能）。



打开……open



定位……seek



读取……read



写入……write



关闭……close





打开和关闭API用来对要读写的文件进行打开和关闭的操作。一个文件必须先打开才能进行读写操作，因为在打开时，操作系统需要对读写文件进行准备工作，关闭时也要进行一些善后处理。

打开文件时需要指定文件名，如果打开成功，操作系统将返回文件句柄。在随后的操作中，只要提供这个文件句柄就可以进行读写操作了，操作结束后将文件关闭。

定位API的功能是指定下次读取、写入命令需要操作的目标位于文件中的哪个位置。说句题外话，表示定位API的英文单词seek原本是“检索”的意思，在文件中定位就和在磁盘中检索文件差不多，不过实际上的感觉更像是检索指定文件位置所在的扇区。

读取和写入API基本上需要指定需要读取（写入）的数据长度以及内存地址，文件的内容会被传送至内存（写入操作时是由内存传送至文件）。

■■■■■

根据以上内容，我们将API设计成下面这样。

打开文件

EDX=21

EBX=文件名

EAX=文件句柄（为0时表示打开失败）（由操作系统返回）



关闭文件

EDX=22

EAX=文件句柄



文件定位

EDX=23

EAX=文件句柄

ECX=定位模式

　　　=0：定位的起点为文件开头

　　　=1：定位的起点为当前的访问位置

　　　=2：定位的起点为文件末尾

EBX=定位偏移量

获取文件大小

EDX=24

EAX=文件句柄

ECX=文件大小获取模式

　　　=0：普通文件大小

　　　=1：当前读取位置从文件开头起算的偏移量

　　　=2：当前读取位置从文件末尾起算的偏移量

EAX=文件大小（由操作系统返回）



文件读取

EDX=25

EAX=文件句柄

EBX=缓冲区地址

ECX=最大读取字节数

EAX=本次读取到的字节数（由操作系统返回）

■■■■■

我们修改一下bootpack.h和console.c来添加这些API。

本次的bootpack.h节选

struct TASK {

int sel, flags; /* sel为GDT编号*/

int level, priority;

struct FIFO32 fifo;

struct TSS32 tss;

struct SEGMENT_DESCRIPTOR ldt[2];

struct CONSOLE *cons;

int ds_base, cons_stack;

struct FILEHANDLE *fhandle; /*从此开始*/

int *fat; /*到此结束*/

};



struct FILEHANDLE { /*从此开始*/

char *buf;

int size;

int pos;

}; /*到此结束*/




本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

struct FILEHANDLE fhandle[8];



（中略）

for (i = 0; i < 8; i++) {

fhandle[i].buf = 0; /*未使用标记*/

}

task->fhandle = fhandle;

task->fat = fat;

（中略）

}



int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

if (finfo != 0) {

/*找到文件的情况*/

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

start_app(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(task->tss.esp0));

（中略）

for (i = 0; i < 8; i++) { /*将未关闭的文件关闭*/ /*从此开始*/

if (task->fhandle[i].buf != 0) {

memman_free_4k(memman, (int) task->fhandle[i].buf, task->fhandle[i].size);

task->fhandle[i].buf = 0;

}

} /*到此结束*/

（中略）

} else {

（中略）

}

（中略）

}

（中略）

}



int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

struct FILEINFO *finfo;

struct FILEHANDLE *fh;

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

（中略）

} else if (edx == 21) {

for (i = 0; i < 8; i++) {

if (task->fhandle[i].buf == 0) {

break;

}

}

fh = &task->fhandle[i];

reg[7] = 0;

if (i < 8) {

finfo = file_search((char *) ebx + ds_base,

(struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

if (finfo != 0) {

reg[7] = (int) fh;

fh->buf = (char *) memman_alloc_4k(memman, finfo->size);

fh->size = finfo->size;

fh->pos = 0;

file_loadfile(finfo->clustno, finfo->size, fh->buf, task->fat, (char *)

(ADR_DISKIMG + 0x003e00));

}

}

} else if (edx == 22) {

fh = (struct FILEHANDLE *) eax;

memman_free_4k(memman, (int) fh->buf, fh->size);

fh->buf = 0;

} else if (edx == 23) {

fh = (struct FILEHANDLE *) eax;

if (ecx == 0) {

fh->pos = ebx;

} else if (ecx == 1) {

fh->pos += ebx;

} else if (ecx == 2) {

fh->pos = fh->size + ebx;

}

if (fh->pos < 0) {



fh->pos = 0;

}

if (fh->pos > fh->size) {

fh->pos = fh->size;

}

} else if (edx == 24) {

fh = (struct FILEHANDLE *) eax;

if (ecx == 0) {

reg[7] = fh->size;

} else if (ecx == 1) {

reg[7] = fh->pos;

} else if (ecx == 2) {

reg[7] = fh->pos - fh->size;

}

} else if (edx == 25) {

fh = (struct FILEHANDLE *) eax;

for (i = 0; i < ecx; i++) {

if (fh->pos == fh->size) {

break;

}

*((char *) ebx + ds_base + i) = fh->buf[fh->pos];

fh->pos++;

}

reg[7] = i;

}

return 0;

}




我们在struct TASK中添加了fhandle和fat两个元素，这是为了让hrb_api也能够使用console_task中声明的变量（cmd_app也可以使用）。fhandle用来存放应用程序所打开文件的信息。在cmd_app中新添加的代码，是为了自动关闭应用程序没有关闭的文件句柄。

■■■■■

接下来我们来添加apilib的函数，以便C语言可以使用新的API。

api021.nas节选

_api_fopen: ; int api_fopen(char *fname);

PUSH EBX

MOV EDX,21

MOV EBX,[ESP+8] ; fname

INT 0x40

POP EBX

RET




api022.nas节选

_api_fclose: ; void api_fclose(int fhandle);

MOV EDX,22

MOV EAX,[ESP+4] ; fhandle

INT 0x40

RET




api023.nas节选

_api_fseek: ; void api_fseek(int fhandle, int offset, int mode);

PUSH EBX

MOV EDX,23

MOV EAX,[ESP+8] ; fhandle

MOV ECX,[ESP+16] ; mode

MOV EBX,[ESP+12] ; offset

INT 0x40

POP EBX

RET




api024.nas节选

_api_fsize: ; int api_fsize(int fhandle, int mode);

MOV EDX,24

MOV EAX,[ESP+4] ; fhandle

MOV ECX,[ESP+8] ; mode

INT 0x40

RET




api025.nas节选

_api_fread: ; int api_fread(char *buf, int maxsize, int fhandle);

PUSH EBX

MOV EDX,25

MOV EAX,[ESP+16] ; fhandle

MOV ECX,[ESP+12] ; maxsize

MOV EBX,[ESP+8] ; buf

INT 0x40

POP EBX

RET




这几个都很简单，就不详细讲解了。

■■■■■

最后我们编写一个测试用的应用程序，这个程序的功能是将ipl10.nas的内容type出来。

typeipl.c

#include "apilib.h"



void HariMain(void)

{

int fh;

char c;

fh = api_fopen("ipl10.nas");

if (fh != 0) {

for (;;) {

if (api_fread(&c, 1, fh) == 0) {

break;

}

api_putchar(c);

}

}

api_end();

}




正如大家所看到的，这是个非常简单的程序。

我们来“make run”试试看吧。哦哦，运行很成功，真不错。



显示出文件内容了哦

typeipl.hrb是程序，所以可以通过Shift+F1来强制结束，从这一点来看它比命令行窗口内置的type命令要好用一些。





4　命令行API（harib25d）

typeipl.hrb看起来相当不错（尤其是可以强制结束这一点很好），我们不妨就用这个程序来替代type命令吧。首先，我们需要从命令行窗口中删除type命令。从console.c中删掉cmd_type，然后将函数cons_runcmd中用于调用cmd_type的部分也删掉。嗯，看着舒服多了（这里只是删掉几个语句，就不将代码列出来了）。

现在typeipl.hrb还只能显示ipl10.nas这个文件，而我们需要实现能任意指定文件名的功能，否则它就无法完全替代type命令。为此，我们需要在用户输入“type ipl10.nas”这样的命令时获取后面的文件名，这个功能被称为获取命令行。因此我们就要编写一个API来获取命令行。

不同的操作系统下获取命令行的形式也不尽相同，Windows的API在获取命令行时并非只返回后面的文件名部分，而是返回包含应用程序名（也就是这里的type）在内的完整命令行内容，我们就来模仿这种方式吧……其实这只是一个借口啦（笑），归根结底还是因为返回完整命令行内容的API编写起来比较简单。

获取命令行

EDX=26

EBX=存放命令行内容的地址

ECX=最多可存放多少字节

EAX=实际存放了多少字节（由操作系统返回）

对程序进行的修改不多。

本次的bootpack.h节选

struct TASK {

（中略）

char *cmdline;

};




本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

task->cons = &cons;

task->cmdline = cmdline; /*这里！*/



（中略）

}



int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 26) {

i = 0;

for (;;) {

*((char *) ebx + ds_base + i) = task->cmdline[i];

if (task->cmdline[i] == 0) {

break;

}

if (i >= ecx) {

break;

}

i++;

}

reg[7] = i;

}

return 0;

}




好，完工了，很简单吧？将cmdline添加到struct TASK中是为了把console_task的cmdline传递给hrb_api。

■■■■■

下面我们来添加apilib的函数。

api026.nas节选

_api_cmdline: ; int api_cmdline(char *buf, int maxsize);

PUSH EBX

MOV EDX,26

MOV ECX,[ESP+12] ; maxsize

MOV EBX,[ESP+8] ; buf

INT 0x40

POP EBX

RET




然后我们来编写应用程序，就叫type.c。

type.c

#include "apilib.h"



void HariMain(void)

{

int fh;

char c, cmdline[30], *p;



api_cmdline(cmdline, 30);

for (p = cmdline; *p > ' '; p++) { } /*跳过之前的内容，直到遇到空格*/

for (; *p == ' '; p++) { } /*跳过空格*/

fh = api_fopen(p);

if (fh != 0) {

for (;;) {

if (api_fread(&c, 1, fh) == 0) {

break;

}

api_putchar(c);

}

} else {

api_putstr0("File not found.\n");

}

api_end();

}




获取命令行内容之后进行的p的计算可能不容易看明白，所以我们稍微讲解一下。

之前在命令行窗口中，我们直接指定了p = cmdline + 5;，这是为了跳过“type”直接取出用户所指定的文件名。而这次我们是通过应用程序来实现的，用户完全可能通过“type.hrb 文件名”这种形式来运行，这样一来我们就不是跳过5个字符，而是要跳过9个字符了。此外，用户也是可以改变应用程序名称的，例如可以改成像Linux那样的cat.hrb。

为了在任何情况下都能顺利运行程序，我们要逐字读取cmdline的内容，遇到比空格的字符编码大的字符连续出现时，将它们全部跳过，这样一来无论是“type”、“type.hrb”还是“cat”都可以跳过去了。

跳过应用程序名之后，还要跳过空格，然后我们就可以将文件名的部分剥离出来了。

■■■■■

我们来“make run”试试看。type.hrb的大小为256字节，还是相当小的，不错（如果用汇编语言编写的话，应该还能更小吧）。运行也很成功，而且由于这是一个应用程序，还可以在中途强制结束，撒花！



type ipl10.nas

运行“type ipll0.nas”时的情形

另外，由于去掉了type命令的功能，操作系统核心的haribote.sys也从原来的33871字节减少到了33716字节。由于添加了新的API，所以只减少了155字节，不过整体上还是稍微变小了一点，也不错啦！





5　日文文字显示（1）（harib25e）<sup>1</sup>

1 本章中作者为大家讲解了如何实现对日文显示的支持，由于本书涉及大量操作系统底层功能的实现，可谓牵一发而动全身，因此在翻译过程中我们原原本本地呈现了关于日文显示的内容。和中文一样，在日文中也有大量的汉字，因此日文显示和中文显示实现起来有很多相似的地方，而且中文显示比日文显示在实现上还相对简单一些。我们在相关章节中补充了一些关于中文显示的内容供大家参考，希望大家本着求同存异的原则，能够对相关知识有一个更加深入的了解。

我们终于等到了这个时刻，那就是对日文显示的支持，估计很多人早就摩拳擦掌盼着实现这个功能吧，其实笔者也很期待呢。日文显示，其实说到底只要准备好相应的字库就好了。

如果将字库内置到操作系统核心中的话，操作系统会变得很大，而且要更换新字体时还必须重新make一遍。因此我们不将日文字库内置到haribote.sys中，而是单独生成一个名叫nihongo.fnt的文件，在“纸娃娃系统”启动时先检查是否存在该文件，如果存在则自动将其读入内存。

■■■■■

那么这样一个字库文件到底有多大呢？我们不妨来计算一下。日文的字符基本上都是用全角来显示的，相对于8 × 16点阵的半角字符来说，1个全角字符的大小为16×16点阵。如果1个半角字符的字库数据需要16字节的话，那么1个全角字符就需要32字节。

日文汉字编码表按照使用频率分类，常用的汉字为第一水准，偶尔使用的汉字为第二水准，基本上不会用到的汉字为第三水准，用得更少的为第四水准（这样的分类是以总体使用情况为基准的，如果你的名字或者住址里面用到了第四水准汉字，那对于你来说可能就会出现“第四水准汉字更加常用”的情况哦）。

在JIS制定的汉字编码表中，非汉字加上第一水准汉字～第三水准汉字一共有94×94＝8836个字符（再加上第四水准汉字的话就更多了）。如果我们要用上所有的这8836个字符的话，就需要32×8836＝282752字节的容量，也就是276KB！2

2 在中文汉字编码标准GB2312中，也按照汉字的常用度划分了一级汉字和二级汉字，其中一级汉字3755个，二级汉字3008个，再加上非汉字（拉丁字母、希腊字母等）字符682个，一共有7445个字符，基本上与上述JIS编码中非汉字加第一～第三水准汉字的容量相当。——译者注

276KB实在是太大了，虽然这个大小还能够装进软盘，但差不多消耗了软盘总容量的20%。这么大的文件，用type ipl10.nas是不行了，必须要在启动时读取更多的扇区，可这样一来在真机环境下的启动速度又要变慢了，看来我们必须要给字库文件瘦瘦身。

■■■■■

根据JIS规格，全角字符的编码以“点、区、面”为单位来进行定义，点和区的关系类似于几号楼几单元，比如说“3号楼4单元”可以类比成“3区4点”，而面则是比它们更大的一个单位。



1个点就对应1个全角字符



1个区中包含94个点



1个面中包含94个区



第一水准～第三水准全部位于1面，第四水准全部位于2面3





3 这一段是不是有点看不懂呢？其实以前的编码表示方法更加简单一些。例如，“あ”（注：日文平假名，读作“啊”）这个字符的编码为0x2422，“川”的编码为0x406e，这种方法比较简单吧，因为每一个字符都有它对应的一个编号。但现在我们所使用的表示方法和以前不同，按照现在的方法，“あ”的字符编码为1面04区02点，“川”的字符编码为1面32区78点。

其实将以前的编码转换为现在的编码也不难，只要将二进制的4位数字编码中前两位和后两位拆开，再各自减掉0x20就可以了。例如“あ”是0x2422，转换后得到0x04、0x02，将这两个数字转换为10进制就分别对应了区号和点号。“川”也一样，将0x406e拆开并各自减掉0x20，得到0x20和0x4e，因此是32区78点。

字符编码大致可分为下面几类。

01区～13区：非汉字

14区～15区：第三水准汉字

16区～47区：第一水准汉字

48区～84区：第二水准汉字

84区～94区：第三水准汉字4

4 有人可能会问，84区不是已经包含在第二水准汉字中了吗？这里再补充说明一下，根据定义，84区前面为第二水准汉字，后面为第三水准汉字。——译者注

这次我们为了节省容量，准备只将01区～47区装入nihongo.fnt中，这样的话就只需要47×94×32＝141376字节，也就是之前的差不多一半大小，启动时间也应该不会很长了。如果大家觉得这样不好，想要把第二、第三水准汉字也全部显示出来的话，不要客气，欢迎大胆改造哦。6

5 在GB2312汉字标准中，字符的定位也是采用类似日文“点区面”的方式，不过GB2312中没有面的概念（或者可以说，GB2312的字符集只有1个面），而区和点我们称为“区位”，和日文一样，每个区包含94个位（即94个字符），例如“啊”字位于16区1位。GB2312中的字符也可以采用二进制编码的方式来表示，相对于日文JIS标准中将区和点的编号加上0x20的做法，GB2312中是将区和位的编号加上0xa0，例如“啊”字区位编码加上0xa0后为：0x10（16）＋0xa0＝0xb0，0x01（1）＋0xa0＝0xa1，因此“啊”字的二进制字符编码为0xb0a1。——译者注

在GB2312中，字符编码的分类如下：

01区～09区：非汉字

10区～15区：空白

16区～55区：一级汉字

56区～87区：二级汉字

88区～94区：空白

如果为了节省容量，我们可以只使用非汉字和一级汉字的部分，即01区～55区的部分，一共需要55×94×32＝165440字节。

■■■■■

接下来我们需要考虑的就是字库的字模数据。即便我们只选用01区～47区，其中也包括了47×94＝4418个字符。如果要一个一个字符去设计字模的话，那比编写一个操作系统还要花时间。因此这次我们还是和当初的半角字库一样，直接从笔者正在开发的OSASK中借用字模吧（OSASK的日文字库版权属于泊何水和圣人[Kiyoto]）。

SASK中的字库文件为jpn16v00.fnt，大小为304KB。不过OSASK和“纸娃娃系统”一样，都是以安装在软盘上使用为前提而设计的，304KB对于软盘来说负担重了些，因此在OSASK中将这个文件进行了压缩，大小变成了56.7KB6。于是我们首先需要对字库文件进行解压缩（否则我们无法拿到里面的数据）。

6 jpn16v00.fnt分为两个版本，一个只包含第一水准汉字，另一个包含从第一到第三水准的全部汉字，56.7KB的是只包含第一水准汉字的版本，48区～94区的内容是空白的。

笔者编写的大多数工具程序中都内置了解压缩的功能，随便使用任何一个工具都可以完成解压缩的操作，这次我们以edimg为例。

提示符> edimg copy nocmp: from:jpn16v00.fnt to:jpn16v00.bin

（这里没有考虑文件路径，请大家根据需要自行加上路径）

好，这样我们就得到了304KB的jpn16v00.bin文件。

下面我们将01区～47区的字模数据提取出来，只要将jpn16v00.bin从开头算起的前141376字节提取出来就可以了，用二进制编辑器可以轻松搞定。

说起日文显示，我们还需要半角片假名的字库。可能有人会说，我从来不用半角片假名。不过，能显示总比不能显示要好吧，所以我们还需要提取半角片假名的字模数据。在jpn16v00.bin中已经包含了显示日文用的半角片假名字模，总共256个字符，位于04A000～04AFFF，共4096字节。

最终nihongo.fnt的内容如下。

000000～000FFF：显示日文用半角字模，共256个字符（4096字节）

001000～02383F：显示日文用全角字模，共4418个字符（141376字节）

至于提取数据的方法嘛，其实笔者就是用二进制编辑器复制粘贴的（笑）。虽然可能有更棒的工具来做这件事，不过笔者认为没必要在这种事情上面花太多心思。

（5分钟之后）完工啦，不错不错。7

7 由于作者开发的OSASK系统中并不包含中文字库，各位读者如果需要改造源代码以实现中文显示的支持，则需要获取一个符合GB2312标准的中文点阵字库文件（例如UCDOS中包含的HZK16），并提取前165440字节制作成一个仅包含一级汉字的子集。由于汉字显示不需要涉及半角片假名的问题，因此最终在“纸娃娃系统”中所使用的.fnt文件中000000～000FFF的256个半角字符部分，我们可以直接使用5.5节中生成的字模数据（即“纸娃娃系统”的内置英文字库）。综上所述，要实现中文显示，所需的.fnt文件结构可以是下面这样：

000000～000FFF：英文半角字模，共256个字符（4096字节），来自系统内置字库数据

001000～02963F：中文全角字模，共5170个字符（165440字节），来自HZK16或其他符合GB2312标准的汉字点阵字库

■■■■■

接下来，我们需要修改bootpack.c，使操作系统可以自动装载字库。

本次的bootpack.c节选

void HariMain(void)

{

（中略）

int *fat;

unsigned char *nihongo;

struct FILEINFO *finfo;

extern char hankaku[4096];



（中略）



/*载入nihongo.fnt */

nihongo = (unsigned char *) memman_alloc_4k(memman, 16 * 256 + 32 * 94 * 47);

fat = (int *) memman_alloc_4k(memman, 4 * 2880);

file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200));

finfo = file_search("nihongo.fnt", (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

if (finfo != 0) {

file_loadfile(finfo->clustno, finfo->size, nihongo, fat, (char *) (ADR_DISKIMG + 0x003e00));

} else {

for (i = 0; i < 16 * 256; i++) {

nihongo[i] = hankaku[i]; /*没有字库，半角部分直接复制英文字库*/

}

for (i = 16 * 256; i < 16 * 256 + 32 * 94 * 47; i++) {

nihongo[i] = 0xff; /*没有字库，全角部分以0xff填充*/

}

}

*((int *) 0x0fe8) = (int) nihongo;

memman_free_4k(memman, (int) fat, 4 * 2880);



（中略）

}




首先分配出用于存放nihongo.fnt内容的内存空间，然后寻找文件，如果找到的话则载入内存。如果没有找到字库文件，则只好用内置的半角字库代替日文半角字库，并用方块填充全角字库的部分。最后，将用于存放nihongo.fnt内容的内存地址写入0x0fe8作为记录。

■■■■■

下面我们该实现用日文字库来显示字符了。字符显示是由graphic.c中的putfonts8_asc来负责的，所以我们就先修改这里吧。

本次的bootpack.h节选

struct TASK {

（中略）

char langmode;

};




本次的graphic.c节选

void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)

{

extern char hankaku[4096]; /*这里没有修改*/

struct TASK *task = task_now();

char *nihongo = (char *) *((int *) 0x0fe8);



if (task->langmode == 0) {

for (; *s != 0x00; s++) { /*从这里起没有修改*/

putfont8(vram, xsize, x, y, c, hankaku + *s * 16);

x += 8;

} /*到这里为止没有修改*/

}

if (task->langmode == 1) {

for (; *s != 0x00; s++) {

putfont8(vram, xsize, x, y, c, nihongo + *s * 16);

x += 8;

}

}

return; /*这里没有修改*/

}




我们在struct TASK里添加了一个langmode（即language mode，语言模式）变量，用于指定一个任务是使用内置的英文字库还是使用nihongo.fnt的日文字库。通过在struct TASK中添加这个变量，我们可以对每个任务单独设置语言模式，例如为某个应用程序设置日文模式，而为另一个应用程序设置英文模式。

■■■■■

既然我们设计了这个语言模式的变量，那么就需要一个命令来对模式进行设定。

本次的console.c节选

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)

{

（中略）

} else if (strncmp(cmdline, "langmode ", 9) == 0) {

cmd_langmode(cons, cmdline);

} else if (cmdline[0] != 0) {

（中略）

}



void cmd_langmode(struct CONSOLE *cons, char *cmdline)

{

struct TASK *task = task_now();



unsigned char mode = cmdline[9] - '0';

if (mode <= 1) {

task->langmode = mode;

} else {

cons_putstr0(cons, "mode number error.\n");

}

cons_newline(cons);

return;

}




完工了，现在只要输入“langmode 0”就代表设定为英文模式，输入“langmode 1”就代表设定为日文模式。

■■■■■

不过，在命令行窗口启动时没有设定langmode，这有点不方便，我们来设定一个默认值。

本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

unsigned char *nihongo = (char *) *((int *) 0x0fe8);



（中略）

if (nihongo[4096] != 0xff) { /*是否载入了日文字库？*/

task->langmode = 1;

} else {

task->langmode = 0;

}



（中略）

}




这样一来，当成功载入日文字库时，默认值为日文模式，否则默认为英文模式。要想知道是否成功载入了日文字库，只要判断01区01点的内容就可以了。如果没有载入字库，这里应该是填充了0xff，如果载入了字库，那么由于01区01点所对应的字符是全角空格，因此这里应该是0x00。

到这，我们就差不多大功告成了，不过task_a的langmode还没设定，因此我们再稍微修改一下HariMain。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



init_palette();

shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);



task_a = task_init(memman);

fifo.task = task_a;

task_run(task_a, 1, 2);

*((int *) 0x0fe4) = (int) shtctl;

task_a->langmode = 0; /*这里！*/



（中略）

}




这样task_a就设定为英文模式了。

■■■■■

下面我们可以开始编写用来测试的应用程序了，只是现在我们还无法显示全角字符，只能显示半角字符。不过即便如此，我们也可以测试出是否能成功载入nihongo.fnt（全角字符的显示在下一节实现）。

由于只能显示半角字符，因此我们来显示几个半角片假名“イロハニホヘト”（注：读作I RO HA HI HO HE TO，是日本平安时代诗歌《伊吕波歌》的第一句）吧。

iroha.c

#include "apilib.h"



void HariMain(void)

{

static char s[9] = { 0xb2, 0xdb, 0xca, 0xc6, 0xce, 0xcd, 0xc4, 0x0a, 0x00 };

/*半角片假名イロハニホヘト的字符编码+换行+0 */

api_putstr0(s);

api_end();

}




在这个程序中我们特地声明了一个s[]用来保存要显示字符串，有人可能会说，那为啥不直接写成下面这样呢？

api_putstr0(“ｲﾛﾊﾆﾎﾍﾄ\n”);




这样写的话在Windows中可能没问题，但在Linux中可能就不行了。准确地说，其实这并不是操作系统的问题，而是字符编码方式的问题。

说到底，字符串就是一串按顺序排列的字符编码，而对于半角片假名应该赋予怎样的编码，有着不同的标准。在Windows常用的“Shift-JIS”8编码中，半角的“イロハニホヘト”的字符编码和s[]中的值一模一样，但在Linux常用的“日文EUC”编码中，则变成了形如0x8e, 0xb2, 0x8e, 0xdb, 0x8e, 0xca, 0x8e, 0xc6, …这样的排列，即在每个半角片假名前都加上了一个0x8e。

8 其实“Shift-JIS“这个名称是不正确的，准确名称应该是“MS汉字编码“，不过反倒是“Shift-JIS“的使用最广泛。

最近出现了一些功能强大的文本编辑器，可以选择字符编码方式，也就是说，在Windows中也可以按EUC编码保存，而在Linux中也可以按Shift-JIS编码保存了，所以刚刚我们也说了，这并不完全是操作系统的问题。

因此，如果直接写成“MS Mincho\n”的话，根据字符编码方式的不同，最终形成的字符串（数值的排列）也会不同，所以我们需要用二进制数字逐个来写出字符的编码，这样一来，即便在Linux下make这个程序，也应该可以得到完全相同的可执行文件。

■■■■■

好了，我们来“make run”试试看。能不能成功呢？我们已经修改了Makefile，将nihongo.fnt加入到磁盘映像中了，因此默认的语言模式应该是日文模式。哦哦，显示出来了！

如果我们先执行“langmode 0”然后再运行iroha.hrb的话，就会显示出下面这样的乱码，这也验证了我们编写的程序成功运行了，撒花！



成功显示出了半角片假名！ 在英文模式下显示出乱码

由于中文不存在像日文半角片假名这样的特殊字符，所以我们不需要考虑这个问题。不过，本节中提到的由于文字编码方式不同导致实际生成的字符编码数据不同的问题，在中文中也是存在的。例如简体中文的GB2312和繁体中文的BIG5就是两种不同的编码方式，相互之间不能兼容。本节中提到的“EUC”实际上是“Extended Unix Code”的缩写，是一种为了让中日韩文字能够兼容ASCII编码而提出的一种兼容编码方式，GB2312（以及后来的GB18030）都属于EUC方式，而Shift-JIS则不属于EUC方式。





6　日文文字显示（2）（harib25f）

好啦，接下来我们该挑战全角字符的显示了。在全角字符显示方面，Shift-JIS和日文EUC的处理方法是不同的，我们先从Shift-JIS开始。

各种半角字符，包括字母、数字、符号、片假名等，加起来总的字符数也不是很多，用1个字节完全可以容纳，不过汉字就不行了，汉字需要使用2个字节来表示（在某些编码方式中，甚至会使用3个甚至更多的字节来表示）。

例如“あ”在Shift-JIS中的编码为0x82、0xa0两个字节。只要用文本编辑器输入一个“あ”并保存，再用二进制编辑器打开就能看到这个编码了（注：在中文系统下，需要用支持选择编码方式的文本编辑器，并选择用Shift-JIS编码保存）。下面我们来讲解一下如何将0x82、0xa0这两个字节的编码转换为区点的编号。

■■■■■

我们先来看第一个字节。如果这个字节为0x81，则代表01区或02区；0x82则代表03区或04区；0x83则代表05区或06区……我们把规则整理成下面这张表，顺便将0x00～0x7f也加进去了。

Shift-JIS的第一个字节

0x00 控制字符 （中略）

0x01 控制字符 0xdd 半角片假名（“ﾝ”）

0x02 控制字符 0xde 半角片假名（“ﾟ”）

（中略） 0xdf 半角片假名（“ﾞ”）

0x1d 控制字符 0xe0 全角字符（1面63区～64区）

0x1e 控制字符 0xe1 全角字符（1面65区～66区）

0x1f 控制字符 0xe2 全角字符（1面67区～68区）

0x20 半角字符（空格） （中略）

0x21 半角字符（“!”） 0xed 全角字符（1面89区～90区）

0x22 半角字符（“””） 0xee 全角字符（1面91区～92区）

（中略） 0xef 全角字符（1面93区～94区）

0x7c 半角字符（“|”） 0xf0 全角字符（2面01区或08区）

0x7d 半角字符（“}”） 0xf1 全角字符（2面03区～04区）

0x7e 半角字符（“~”） 0xf2 全角字符（2面05区或12区）

0x7f 控制字符 0xf3 全角字符（2面13区～14区）

0x80 不使用 0xf4 全角字符（2面15区或78区）

0x81 全角字符（1面01区～02区） 0xf5 全角字符（2面79区～80区）

0x82 全角字符（1面03区～04区） 0xf6 全角字符（2面81区～82区）

0x83 全角字符（1面05区～06区） 0xf7 全角字符（2面83区～84区）

（中略） （中略）

0x9d 全角字符（1面57区～58区） 0xfa 全角字符（2面89区～90区）

0x9e 全角字符（1面59区～60区） 0xfb 全角字符（2面91区～92区）

0x9f 全角字符（1面61区～62区） 0xfc 全角字符（2面93区～94区）

0xa0 不使用 0xfd 不使用

0xa1 半角片假名（“｡”） 0xfe 不使用

0xa2 半角片假名（“｢”） 0xff 不使用

接下来是第二个字节，如下表。

Shift-JIS的第二个字节

0x00 不使用 0x81 全角字符（较小的区的65点）

0x01 不使用 0x82 全角字符（较小的区的66点）

0x02 不使用 （中略）

（中略） 0x9c 全角字符（较小的区的92点）

0x3d 不使用 0x9d 全角字符（较小的区的93点）

0x3e 不使用 0x9e 全角字符（较小的区的94点）

0x3f 不使用 0x9f 全角字符（较大的区的01点）

0x40 全角字符（较小的区的01点） 0xa0 全角字符（较大的区的02点）

0x41 全角字符（较小的区的02点） 0xa1 全角字符（较大的区的03点）

0x42 全角字符（较小的区的03点） （中略）

（中略） 0xfa 全角字符（较大的区的92点）

0x7c 全角字符（较小的区的61点） 0xfb 全角字符（较大的区的93点）

0x7d 全角字符（较小的区的62点） 0xfc 全角字符（较大的区的94点）

0x7e 全角字符（较小的区的63点） 0xfd 不使用

0x7f 不使用 0xfe 不使用

0x80 全角字符（较小的区的64点） 0xff 不使用

参照上面的两张表，我们就可以得到“あ”的编码0x82、0xa0对应04区02点。

知道了区点编号我们就可以计算出字模的内存地址，再显示出来也就很容易了。

■■■■■

我们来修改一下操作系统吧。

本次的graphic.c节选

void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)

{

extern char hankaku[4096];

struct TASK *task = task_now();

char *nihongo = (char *) *((int *) 0x0fe8), *font; /*从此开始*/

int k, t; /*到此结束*/



if (task->langmode == 0) {

for (; *s != 0x00; s++) {

putfont8(vram, xsize, x, y, c, hankaku + *s * 16);

x += 8;

}

}

if (task->langmode == 1) {

for (; *s != 0x00; s++) {

if (task->langbyte1 == 0) { /*从此开始*/

if ((0x81 <= *s && *s <= 0x9f) || (0xe0 <= *s && *s <= 0xfc)) {

task->langbyte1 = *s;

} else {

putfont8(vram, xsize, x, y, c, nihongo + *s * 16);

}

} else {

if (0x81 <= task->langbyte1 && task->langbyte1 <= 0x9f) {

k = (task->langbyte1 - 0x81) * 2;

} else {

k = (task->langbyte1 - 0xe0) * 2 + 62;



}

if (0x40 <= *s && *s <= 0x7e) {

t = *s - 0x40;

} else if (0x80 <= *s && *s <= 0x9e) {

t = *s - 0x80 + 63;

} else {

t = *s - 0x9f;

k++;

}

task->langbyte1 = 0;

font = nihongo + 256 * 16 + (k * 94 + t) * 32;

putfont8(vram, xsize, x - 8, y, c, font ); /*左半部分*/

putfont8(vram, xsize, x , y, c, font + 16); /*右半部分*/

} /*到此结束*/

x += 8;

}

}

return;

}




本次的bootpack.h节选

struct TASK {

（中略）

unsigned char langmode, langbyte1;

};




这里的变量k用来存放区号，变量t用来存放点号，为了方便计算，我们存放的是减1之后的值。由于我们没有考虑第2面的字符，因此如果以后要支持第四水准汉字会比较麻烦，不过要支持第二和第三水准汉字还是比较容易的，只要修改载入nihongo.fnt的部分就可以了。

struct TASK中的langbyte1是当接收到全角字符时用来存放第1个字节内容的变量。当接收到半角字符，或者全角字符显示完成之后，该变量被置为0。

putfonts8_asc中每接收到1个字节就会执行x += 8;，当显示全角字符时，需要在接收到第2个字节之后，再往左回移8个像素并绘制字模的左半部分。

采用这种方式时，如果一开始langbyte1不置为0，显示就会出问题，因此我们还需要再修改一下console.c。

本次的console.c节选

void console_task(struct SHEET *sheet, int memtotal)

{

（中略）

if (nihongo[4096] != 0xff) { /*是否载入了日文字库？*/

task->langmode = 1;

} else {

task->langmode = 0;

}

task->langbyte1 = 0; /*这里！*/

（中略）

}



int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)



{

（中略）



if (finfo != 0) {

/*找到文件的情况*/

（中略）

if (finfo->size >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) {

（中略）

start_app(0x1b, 0 * 8 + 4, esp, 1 * 8 + 4, &(task->tss.esp0));

（中略）

timer_cancelall(&task->fifo);

memman_free_4k(memman, (int) q, segsiz);

task->langbyte1 = 0; /*这里！*/

} else {

cons_putstr0(cons, ".hrb file format error.\n");

}

（中略）

}

（中略）

}




对console_task所做的修改只是在决定langmode默认值时顺便将langbyte1置为0而已。

当程序出现bug或者强制结束时可能出现在显示全角字符第1个字节时停止的情况，而对cmd_app所做的修改就是为了应对这种情况。

不过换行还有一点问题，当字符串很长时，可能在全角字符的第1个字节处就遇到自动换行了，这样一来当收到第2个字节时，字模的左半部分就会画到命令行窗口外面去。所以我们在遇到第1个字节换行时，可以特意将cur_x再右移8个像素。

本次的console.c节选

void cons_newline(struct CONSOLE *cons)

{

int x, y;

struct SHEET *sheet = cons->sht;

struct TASK *task = task_now(); /*这里！*/

if (cons->cur_y < 28 + 112) {

cons->cur_y += 16; /*到下一行*/

} else {

/*屏幕滚动*/

（中略）

}

cons->cur_x = 8;

if (task->langmode == 1 && task->langbyte1 != 0) { /*从此开始*/

cons->cur_x += 8;

} /*到此结束*/

return;

}




完工了，我们来“make run”试试看。虽然没有编写用于测试的应用程序，不过我们可以执行“type ipl10.nas”，如果显示出日文就算成功啦。……出来啦！



终于显示出日文了哦

不过现在高兴还太早了，仔细看看画面就发现有什么地方不对，为什么“埋”这个汉字没有显示出来呢？k和t的计算应该没有问题啊，嗯……

哦对了，一定是nihongo.fnt文件太大，用ipl10.nas无法全部载入。嗯，一定是这样！





7　日文文字显示（3）（harib25g）

为了解决这个问题，我们先来写一个ipl20.nas替换原来的ipl10.nas，只要将最开头的地方修改一下就好了。

ipl20.nas节选

CYLS EQU 20 ; 要载入多少数据




我们只修改了这一行。哦，当然，要将Makefile中的“ipl10”也替换成“ipl20”哦。

我们再来“make run”一下，输入“type ipl20.nas”。哦，出来了，现在正常了！



汉字也显示出来了！

好，下面我们来为Linux用户实现对日文EUC的支持吧。咦，已经到这个时间了？算了，不管了，人逢喜事精神爽，要做咱就做到底。

如果不考虑对半角片假名的支持，日文EUC比Shift-JIS要简单。EUC中半角片假名占用2个字节，但却是一个半角字符，字节数与字符宽度不匹配，而我们目前还没有考虑这种情况，所以要支持半角片假名就得做很多改动才行，太麻烦了，这次就算了吧，反正在EUC中也不怎么用半角片假名，应该没什么问题。

日文EUC中k和t的计算公式很简单。

k = langbyte1 – 0xa1;

t = *s – 0xa1;




怎么样，简单吧！第1个字节和第2个字节的范围都在0xa1～0xfe，虽然笔者现在已经开始犯困了，不过对付这么简单的问题还不是小菜一碟？看，三下五除二就搞定了。

本次的graphic.c节选

void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)

{

（中略）



if (task->langmode == 0) {

（中略）

}

if (task->langmode == 1) {

（中略）

}

if (task->langmode == 2) { /*从此开始*/

for (; *s != 0x00; s++) {

if (task->langbyte1 == 0) {

if (0x81 <= *s && *s <= 0xfe) {

task->langbyte1 = *s;

} else {

putfont8(vram, xsize, x, y, c, nihongo + *s * 16);

}

} else {

k = task->langbyte1 - 0xa1;

t = *s - 0xa1;

task->langbyte1 = 0;

font = nihongo + 256 * 16 + (k * 94 + t) * 32;

putfont8(vram, xsize, x - 8, y, c, font ); /*左半部分*/

putfont8(vram, xsize, x , y, c, font + 16); /*右半部分*/

}

x += 8;

}

} /*到此结束*/

return;

}




嗯，话说，putfonts8_asc这个函数名现在看来已经不合适了，因为它不仅支持ASCII，还能支持Shift-JIS和日文EUC。不过给函数改名实在太麻烦了，所以就先这样吧。

另外，langmode命令也需要修改一下，以便可以用它指定模式2，也就是说“langmode 2”代表日文EUC模式。

本次的console.c节选

void cmd_langmode(struct CONSOLE *cons, char *cmdline)

{

struct TASK *task = task_now();

unsigned char mode = cmdline[9] - '0';

if (mode <= 2) { /*这里！*/

task->langmode = mode;

} else {

cons_putstr0(cons, "mode number error.\n");

}

cons_newline(cons);

return;

}




■■■■■

好，我们来“make run”……先等等，在此之前，为了测试日文EUC我们需要一个用EUC编码保存的文本文件。嗯，那我们就先来做一个EUC编码的文本文件吧。

打开二进制编辑器BZ，选择“查看”→“字符编码”→“EUC”，然后在我们平常不怎么注意的，右边写着“0123456789ABCDEF”的地方点击一下，将光标移动过去，输入“日本語EUCで書いてみたよー”（这是用日文EUC写的哦）。虽然这样直接结束也可以，不过我们还是再加一个换行符上去吧。点击左侧区域最后的地方（000010行的+9列），将光标移动过去，然后输入0A。

将这些内容保存为euc.txt。这个文件是用EUC编码保存的，所以如果用Windows自带的记事本程序打开会显示出乱码，不过用Internet Explorer或者Firefox等程序打开的话（前提是选择了正确的字符编码方式）就可以正常显示。



保存为euc.txt的样子

接下来我们修改Makefile，来将euc.txt装入磁盘映像……好，完工了！我们来“make run”吧！

我们先在没有设定langmode的情况下type一下euc.txt看看。嗯，完全看不懂呢（笑）。因为在不设定langmode的情况下默认的语言模式是Shift-JIS。



Shift-JIS模式下type的结果

这次我们先来执行“langmode 2”，然后再type试试看……哦哦，正常显示了！撒花！



日文EUC模式下type的结果

如果各位读者当中有人经常使用日文EUC的话，不妨在console_task中将设定语言模式默认值的部分修改一下，默认使用EUC就可以了。

我们前面已经提到过，中文GB2312编码采用的是EUC方式，因此中文字符二进制编码转换为区位码的公式和日文EUC是完全相同的，再加上中文里不需要涉及类似半角片假名的问题，因此通过这一节的内容，就应该可以完美地实现对中文显示的支持了。

要测试中文显示，我们可以用记事本或者其他文本编辑器编写一个包含中文的文本文件，然后用GB2312编码方式保存，再参照本节中的讲解将文本文件装入磁盘映像，用type命令就可以显示出来了。

■■■■■

虽然已经又困又累了，不过我们还剩下一个日文显示方面的问题没有修改，我们需要一个可以查询当前所使用的langmode的API。这个API要怎么用呢？比如可以这样：让画面上的文字提示信息可以在英文模式时显示成英文，在日文模式下显示成日文。

获取langmode

EDX=27

EAX=langmode（由操作系统返回）

我们来修改一下console.c，很简单。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 27) {

reg[7] = task->langmode;

}

return 0;

}




我们还得编写apilib（其实不写也可以，但不写的话就无法从C语言调用了）。

api027.nas节选

_api_getlang: ; int api_getlang(void);

MOV EDX,27

INT 0x40

RET




既然我们新增了API，最好还是写一个用来测试的应用程序，否则出了bug就麻烦了。

chklang.c

#include "apilib.h"



void HariMain(void)

{

int langmode = api_getlang();

static char s1[23] = { /*日本語シフトJISモード（日文Shift-JIS模式）*/

0x93, 0xfa, 0x96, 0x7b, 0x8c, 0xea, 0x83, 0x56, 0x83, 0x74, 0x83, 0x67,

0x4a, 0x49, 0x53, 0x83, 0x82, 0x81, 0x5b, 0x83, 0x68, 0x0a, 0x00

};

static char s2[17] = { /*日本語EUCモード（日文EUC模式）*/

0xc6, 0xfc, 0xcb, 0xdc, 0xb8, 0xec, 0x45, 0x55, 0x43, 0xa5, 0xe2, 0xa1,

0xbc, 0xa5, 0xc9, 0x0a, 0x00

};

if (langmode == 0) {

api_putstr0("English ASCII mode\n");

}

if (langmode == 1) {

api_putstr0(s1);

}

if (langmode == 2) {

api_putstr0(s2);

}

api_end();

}




应该不用特地解释了吧，这里s1和s2没有直接写成字符串是为了在make时避免受到源代码字符编码方式的影响。

好，完工了，“make run”！咦？全角字符的显示有点不对劲啊！

嗯，这是怎么回事？不过移动一下窗口貌似就恢复正常了。



只显示出右半部分 移动一下窗口就恢复正常了？

实在是太困了，今天就到此为止吧。本来我们预计今天能完成操作系统核心部分的开发，不过现在遇到了个bug，所以明天还得在操作系统核心的编写上再花点时间。





第29天　压缩与简单的应用程序



修复bug （harib26a）

文件压缩（harib26b）

标准函数

非矩形窗口（harib26c）

bball （harib26d）

外星人游戏（harib26e）





1　修复bug（harib26a）

大家早上好。今天我们打算编写一些应用程序来玩玩，不过在此之前，我们得修复昨天剩下的那个关于日文显示的bug。

仔细观察这个bug后我们发现，只有全角字符的显示有问题，半角字符是正常的，而且移动窗口之后就可以恢复正常，这说明图层缓冲区中的数据是正确的，问题一定出在refresh上面。

带着这个思路再去看程序，果然如此，显示全角字符的时候只refresh了半角部分，难怪只能显示出右半部分呢。我们马上来改一改。

本次的window.c节选

void putfouts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l)

{

struct TASK *task = task_now(); /*这里！*/

boxfill8(sht->buf, sht->bxsize, b, x, y, x + l * 8 - 1, y + 15);

if (task->langmode != 0 && task->langbyte1 != 0) { /*从此开始*/

putfonts8_asc(sht->buf, sht->bxsize, x, y, c, s);

sheet_refresh(sht, x - 8, y, x + l * 8, y + 16);



} else {

putfonts8_asc(sht->buf, sht->bxsize, x, y, c, s);

sheet_refresh(sht, x, y, x + l * 8, y + 16);

} /*到此结束*/



return;

}




这次修改中我们进行如下设定：当在日文界面下开始显示全角字符的第2个字节时， refresh的范围会从x – 8开始，其他的部分保持不变。

我们来看看是不是解决了这个bug，“make run”一下试试看，和昨天一样运行chklang命令……哦哦，出来了！



修好了

于是这个bug顺利解决了，可喜可贺。





2　文件压缩（harib26b）

到上一节为止，我们已经修复了所有的bug，“纸娃娃系统”也可以宣告完成了，撒花！不过为了锦上添花，我们还要再做个小小的修改。

在此之前，我们先来确认一下目前操作系统核心部分程序的大小（好像已经很久没有确认了呢）。haribote.sys的大小为34782字节，即34.0KB，真小啊，不错不错。源代码的大小又如何呢？我们来看一下haribote目录下的所有文件，一共是99230字节（不包括hankaku.txt），即96.9KB，相当小呀。

那么下面我们还想要增加一个什么样的功能呢？答案是“支持文件压缩”的功能。这里所说的文件压缩，就是像zip文件一样将文件变小保存起来的功能。不过其实这次我们所要实现的并不是文件的“压缩”，而是将压缩好的文件“解压缩”的功能。

这样一来，压缩过的文件可以在操作系统内部自动解压缩，不需要使用压缩软件来进行解压缩的操作。对于压缩过的文件，可以像未经压缩的文件一样直接使用。

之所以要增加这样的功能，是为了尽量让日文字库文件变小。现在nihongo.fnt有142KB，但OSASK用的jpn16v00.fnt却只有56.7KB，这都是拜压缩所赐。因此如果我们在“纸娃娃系统”中也使用压缩，估计能节省大约85KB的磁盘空间，这样一来即便我们编写很多应用程序，也用不着使用ipl30.bin了，也就是说，可以不需要再额外延长启动时间了。

■■■■■

世界上有许多种压缩格式（比如.zip、.cab、.lzh、.bz2等），那么我们选用哪一种格式呢？有些格式的压缩率不错，但解压缩需要花费很长的时间；有些格式压缩率不是很理想，但解压缩速度却很快。哎呀，如果有一种格式压缩率又好，同时解压缩速度又快就太好了；反之，如果压缩率不行，解压缩又慢的话，那就太差劲了。

此外，解压缩程序的大小也是个问题。即便压缩率再好，可以将142KB的nihongo.fnt压缩到1KB，但解压缩程序却要150KB，那结果只能是适得其反。

其实笔者在这个问题上考虑了半年的时间，为了给自己开发的软件加上对压缩文件的支持，在选用哪一种压缩格式上面做了一些研究，结果自己编写了一个平衡性还不错的新格式——tek，之后就一直使用这种格式了。之前我们介绍的jpn16v00.fnt就是用tek压缩的（OSASK中已经实现了对压缩文件的支持）。

在这里很想跟大家介绍一下tek的优点，不过真讲起来的话太浪费篇幅了，总之在这里我们也使用tek格式了，请大家接受这个设定吧。如果有人不赞同的话，也可以对程序进行修改，使用其他的格式，你一定会发现tek在平衡性方面的优势（当然，如果你发现有比tek更好的选择，请尽管用哦）。

■■■■■

好，下面我们将tek的解压缩程序整合到“纸娃娃系统”中，不过如果要在这里讲解tek的算法，然后再编写相关的函数，不知道要讲到猴年马月了，而且本书是讲编写操作系统的，不是学习压缩算法的，所以我们就偷个懒，从edimg.exe的源代码中直接将tek相关的部分拿出来用吧（对不住了！）。

edimg.exe的源代码是公开的，tek相关的程序位于autodec_.c这个文件中，将这个文件直接复制到harib26b目录的tek/uatodec_.c就可以了。

然而，这个程序并无法轻易地汇整作为程序库来使用，这一点上笔者确实偷懒了（借口：与其说是偷懒，不如说是忙到没有时间来整理吧……比如说忙着写这本书之类的）。

于是，我们删除了对于“纸娃娃系统”来说不太好用的autodecomp函数，并增加了必要的函数tek_getsize和tek_decomp，同时将加工过的程序保存为tek.c（在tek/和haribote/中同时放入同样的文件）。

tek.c节选

int tek_getsize(unsigned char *p)

{

static char header[15] = {

0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x4f, 0x53, 0x41, 0x53, 0x4b, 0x43, 0x4d, 0x50 };

int size = -1;

if (memcmp(p + 1, header, 15) == 0 && (*p == 0x83 || *p == 0x85 || *p == 0x89)) {

p += 16;

size = tek_getnum_s7s(&p);

}

return size;

} /* （注）memcmp和strncmp差不多，这个函数忽略字符串中的0并一直比较到指定的15个字符为止*/



int tek_decomp(unsigned char *p, char *q, int size)

{

int err = -1;

if (*p == 0x83) {

err = tek_decode1(size, p, q);

} else if (*p == 0x85) {

err = tek_decode2(size, p, q);

} else if (*p == 0x89) {

err = tek_decode5(size, p, q);

}

if (err != 0) {

return -1; /*失败*/

}

return 0; /*成功*/

}




话说回来，即便给大家看上面的代码，估计大家也看不明白tek_getnum_s7s和tek_decode1之类的到底是怎么一回事。不过基本上，tek_getsize函数用来判断文件是否符合tek格式，如果是合法的tek格式则取得解压缩后的文件大小（如果不是合法的tek格式则返回-1），然后tek_decomp函数用来完成解压缩操作。

还有，我们将autodec_.c中的malloc和free分别改成了memman_alloc_4k和memman_free_4k，以上就是本次修改的全部内容。

利用上面两个函数，我们编写了一个叫file_loadfile2的函数。

本次的file.c节选

char *file_loadfile2(int clustno, int *psize, int *fat)

{

int size = *psize, size2;

struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;

char *buf, *buf2;

buf = (char *) memman_alloc_4k(memman, size);

file_loadfile(clustno, size, buf, fat, (char *) (ADR_DISKIMG + 0x003e00));

if (size >= 17) {

size2 = tek_getsize(buf);

if (size2 > 0) { /*使用tek格式压缩的文件*/

buf2 = (char *) memman_alloc_4k(memman, size2);

tek_decomp(buf, buf2, size2);

memman_free_4k(memman, (int) buf, size);

buf = buf2;

*psize = size2;

}

}

return buf;

}




这个函数的功能是，首先用memman_alloc_4k申请必要的内存空间，然后用file_loadfile函数将文件内容载入内存。如果文件大小超过17字节则表示其有可能为tek格式的文件1，调用tek_getsize进行判断，如果判断该文件确实为tek格式，则为解压缩后的文件申请分配内存空间，并执行解压缩操作，然后舍弃解压缩前的文件内容。本函数将返回载入并存放文件内容的内存地址。

1 tek格式的文件必须带有一个用于识别格式的文件头，这个文件头的部分至少有17字节，因此只对大于17字节的文件判断其是否为tek格式。

这里需要说明的是psize这个变量，之前我们一直是这样写的：

char *file_loadfile2(int clustno, int size, int *fat)




而这次我们将size改成了int *psize，因为我们不是要向函数传递size的值，而是要传递存放size变量的内存地址。

之所以要这样做，是因为在判断文件为tek格式之后，我们需要将size变量的值修改为解压缩后的文件大小，要修改变量的值就需要知道该变量的内存地址。

■■■■■

接下来我们用file_loadfile2函数来修改一下载入nihongo.fnt的部分。

本次的bootpack.c节选

void HariMain(void)

{

（中略）



/*载入nihongo.fnt */

fat = (int *) memman_alloc_4k(memman, 4 * 2880);

file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200));



finfo = file_search("nihongo.fnt", (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

if (finfo != 0) {

i = finfo->size; /*这里！*/

nihongo = file_loadfile2(finfo->clustno, &i, fat); /*这里！*/

} else {

nihongo = (unsigned char *) memman_alloc_4k(memman, 16 * 256 + 32 * 94 * 47); /*这里！*/

for (i = 0; i < 16 * 256; i++) {

nihongo[i] = hankaku[i]; /*没有字库，半角部分直接复制英文字库*/

}

for (i = 16 * 256; i < 16 * 256 + 32 * 94 * 47; i++) {

nihongo[i] = 0xff; /* 没有字库，全角部分以0xff填充 */

}

}

*((int *) 0x0fe8) = (int) nihongo;

memman_free_4k(memman, (int) fat, 4 * 2880);



（中略）

}




在载入nihongo.fnt的代码中，我们没有直接写file_loadfile2（finfo —>clustno, &finfo —>size, fat）; 而是用了一个变量i作为中转，这是为了防止finfo —>size的值被修改，因为finfo —>size位于磁盘缓冲区中，如果被改掉的话就会出问题。

■■■■■

下面我们来压缩nihongo.fnt……话说，通过上面的程序大家应该能看出来，即便nihongo.fnt不进行压缩，程序照样可以正常工作，不过既然我们已经实现了对压缩文件的支持，那为什么不压缩一下呢？

要对文件进行压缩，可以使用z_tools中的bim2bin.exe。bim2bin.exe这个工具，本来是用于创建OSASK可执行文件的程序，所以才叫这个名字（OSASK的可执行文件扩展名为.bin）。其实tek压缩原本只是OSASK可执行文件附带的功能，因此从那以后就一直用bimzbin.exe来进行tek压缩了。输入下面的命令：

提示符>bim2bin –osacmp in:nihongo.org out:nihongo.fnt

即可完成文件的压缩，其中nihongo.org是在压缩前将nihongo.fnt改了一下名字而已。tek压缩还有一些选项，比如用下面的命令：

提示符> bim2bin –osacmp in:nihongo.org out:nihongo.fnt –tek2

表示压缩为tek2格式。如果指定-tek5，或者不指定任何选项的话，则是压缩为tek5格式。tek2格式的压缩率比较低，但解压缩速度比较快，在真机环境下测试表明，tek5格式的解压缩速度已经够快了，当然，如果对解压缩速度不满意的话，可以试试tek2。

用tek5格式压缩后，142KB的nihongo.org被压缩为56.6KB的nihongo.fnt，撒花！

准备完成，“make run”试试看，能不能顺利显示出汉字呢？显示出来了！



使用压缩过的字库也能显示出汉字了

再加把劲，这次我们要让应用程序经过tek压缩后也可以直接运行。

本次的console.c节选

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)

{

（中略）

int i, segsiz, datsiz, esp, dathrb, appsiz; /*这里！ */

（中略）



if (finfo != 0) {

/*如果找到文件*/

appsiz = finfo->size; /*从此开始*/

p = file_loadfile2(finfo->clustno, &appsiz, fat);

if (appsiz >= 36 && strncmp(p + 4, "Hari", 4) == 0 && *p == 0x00) { /*到此结束*/

（中略）

} else {

（中略）

}

memman_free_4k(memman, (int) p, appsiz); /*这里！*/

cons_newline(cons);

return 1;

}

/*如果没有找到文件*/

return 0;

}




修改的部分只是将应用程序的大小从finfo—>size改成appsiz，并使用file_loadfile2函数来载入。

除此之外，虽然我们已使用了file_loadfile，但还剩下一个地方，那就是文件API的部分，我们也顺便将其修改成file_loadfile2吧。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 21) {

（中略）

if (i < 8) {

finfo = file_search((char *) ebx + ds_base,

(struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);

if (finfo != 0) {

reg[7] = (int) fh;

fh->size = finfo->size;

fh->pos = 0;

fh->buf = file_loadfile2(finfo->clustno, &fh->size, task->fat); /*这里！ */

}

}

} else if (edx == 22) {

（中略）

}




这里不用讲解应该也能明白了吧。这样一来，我们就对字库、应用程序，以及应用程序所打开的数据文件等等所有涉及文件操作的部分，都实现了对tek压缩的支持，如果觉得哪些文件比较大的话，压缩一下就可以了。

■■■■■

作为测试，我们将应用程序压缩一下看看。

本次的app_make.txt节选

%.org : %.bim Makefile ../app_make.txt

$(BIM2HRB) $*.bim $*.org $(MALLOC)



%.hrb : %.org Makefile ../app_make.txt

$(BIM2BIN) -osacmp in:$*.org out:$*.hrb




我们运行一下“make full”，结果如下图所示。

应用程序名 压　缩　前 压　缩　后 差　　异

a.hrb 84字节 84字节 0字节

hello3.hrb 112字节 101字节 -11字节

hello4.hrb 102字节 105字节 +3字节

hello5.hrb 78字节 86字节 +8字节

winhelo.hrb 174字节 175字节 +1字节

winhelo2.hrb 315字节 249字节 -66字节

winhelo3.hrb 359字节 268字节 -91字节

star1.hrb 330字节 257字节 -73字节

stars.hrb 416字节 322字节 -94字节

stars2.hrb 476字节 352字节 -124字节

lines.hrb 406字节 310字节 -96字节

walk.hrb 487字节 354字节 -133字节

noodle.hrb 1773字节 1250字节 -523字节

Beepdown.hrb 224字节 184字节 -40字节

color.hrb 386字节 312字节 -74字节

color2.hrb 512字节 399字节 -113字节

sosu.hrb 1472字节 1082 -390字节

sosu2.hrb 1484字节 1095字节 -389字节

Sosu3.hrb 1524字节 1103字节 -421字节

typeipl.hrb 174字节 165字节 -9字节

type.hrb 265字节 226字节 -39字节

iroha.hrb 97字节 101字节 +4字节

chklang.hrb 208字节 199字节 -9字节

于是应用程序也变得更小了。当然，变小之后应用程序还是可以正常运行的。真不错，noodle.hrb这种程序居然小到只有523字节了呢。

不过我们也发现，有一些原本就很小的应用程序，压缩了之后反倒稍微变大了一点2。虽然这点差异我们完全可以忽略，不过文件总归还是越小越好，我们就不对这些文件进行压缩了（这样还能节省解压缩的时间，虽然也只有一点点而已）。

2 可能大家会觉得压缩之后居然比原来还大这一点很奇怪，其实这也很正常。压缩说白了就是对数据的一种转换，大多数情况下这种转换会让文件变得更小，但偶然的情况下转换之后反而变大也是有可能的。这一性质并非是tek压缩所独有的，而是所有压缩方法所共有的。

本次的hello4.hrb的Makefile

APP = hello4

STACK = 1k

MALLOC = 0k



include ../app_make.txt



$(APP).hrb : $(APP).org Makefile

$(COPY) $(APP).org $(APP).hrb




这样一来，文件本身的生成规则会优先于一般规则，于是.hrb文件变成copy.org文件。

hello5.hrb和winhelo.hrb也进行了同样的修改。

■■■■■

通过这次的修改，毫无疑问，操作系统本身肯定变大了，不过到底大了多少呢？haribote.sys的大小由34782字节变为40000字节，增加了5218字节，也就是5.10KB。而字库文件通过压缩减小了85.4KB，减去操作系统增大的部分，我们还赚了80多KB，而且应用程序也变小了，效果还是相当显著的。

到这里为止，我们的“纸娃娃系统”总算是正式完工了。撒花！放鞭炮！这29天一路走来，现在好想庆祝一番。笔者实在是太开心了，要不出去吃顿大餐吧！

忽然想起typeipl.hrb，这个程序相当于一个只能显示“ipl10.nas”的type命令，而且现在“ipl10.nas”这个文件已经不存在了（被替换成了“ipl20.nas”），这个程序也就没有任何意义了，从下一节开始我们就将它删掉。





3　标准函数

在C语言中，有一些函数被称为“标准函数”，这些函数对于C语言来说是非常常用的函数，大多数情况下，C语言编译器的作者或者是操作系统的作者都会提供这样的库。

其中有代表性的函数包括printf、putchar、strcmp以及malloc等。如果一个程序只调用了标准函数，那么无论在Windows中还是在Linux中都可以生成相同的应用程序（这里的相同指的是源代码可以完全通用，而并不是说完全相同的可执行文件能同时在不同的系统上运行）。

如果“纸娃娃系统”中也包含这些标准函数的话，那么上述这样的应用程序就同样可以用于“纸娃娃系统”了。听起来很不错，我们来试试看吧。

要凑齐所有的标准函数，笔者实在是吃不消，于是我们只挑其中一部分来做。如果有必要的话，剩下的可以由大家来完成。如果不清楚有哪些标准函数，可以参考一些C语言的教材，或者到“纸娃娃系统”的支持页面来提问。

■■■■■

我们先来做putchar吧。这个函数的功能是在屏幕上显示一个指定的字符，只要include了就可以使用。用api_putchar可以很容易地实现这个函数的功能。

putchar.c

#include "apilib.h"



int putchar(int c)

{

api_putchar(c);

return c;

}




代码很简单，用不着讲解了吧。最后的return命令指定了c，这是putchar的参考手册1上面规定的。

1 笔者参考的是这个网页：http://www.linux.or.jp/JM/html/LDP_man_pages/man3/putchar.3.html（译者注：由于时间久远，原链接已失效，各位读者请参考这里：http://www.linux.com/learn/docs/man/3838-putchar3）。

■■■■■

接下来是strcmp，不过这个已经由编译器附带了，因此不需要我们再特地编写了。

那么我们就来做exit吧。exit是用来结束应用程序的函数，只要include的就可以使用2。本来exit函数有很多功能，比如实现用atexit函数对一些函数进行注册，在程序结束时可以自动调用这些注册过的函数。要实现这些功能代码就会变得很长，我们在这里就只调用api_end，做一个简单的exit函数吧。

2 笔者参考的是这个网页：http://www.linux.or.jp/JM/html/LDP_man-pages/man3/exit.3.html（译者注：由于时间久远，原链接已失效，各位读者请参考这里：http://www.linux.com/learn/docs/man/2912-exit3）。

exit.c

#include "apilib.h"



void exit(int status)

{

api_end();

}




这个也用不着讲解了吧。status参数是用来向操作系统报告程序结束状态的，由于在现在的“纸娃娃系统”中完全没有用到，因此这里就直接忽略了。

■■■■■

下面我们来做printf，这个函数连C语言的初学者都应该很熟悉了。它的功能很简单，就是将sprintf的结果输出到画面上，只要include了就可以使用了3。

3 笔者参考的是这个网页：http://www.linux.or.jp/JM/html/LDP_man-pages/man3/printf.3.html（译者注：由于时间久远，原链接已失效，各位读者请参考这里：http://www.linux.com/learn/docs/man/4138-sprintf3）。

不过printf还真是一个比较难写的函数，因为它的调用方式不是固定的，例如：

printf("hello, world\n");

printf("a = %d (%x) ", a, a);




像上面这样，通过使用%d和%x之类的转义符，会导致参数的数量发生变化。这样的函数到底应当如何声明呢？

只要完成了函数的声明，接下来只要调用sprintf，然后再调用api_putstr0就搞定了。可问题是sprintf应该怎样调用呢？参数的数量是不固定的呀……

说那么多好像有点吓唬大家了，实际上程序并不长哦。

printf.c

#include <stdio.h>

#include <stdarg.h>

#include "apilib.h"



int printf(char *format, ...)

{

va_list ap;

char s[1000];

int i;



va_start(ap, format);

i = vsprintf(s, format, ap);

api_putstr0(s);

va_end(ap);

return i;

}




先来看声明部分，直接写了一个省略号“…”，看上去很奇怪吧，其实这是C语言的语法，并不是笔者的错哦（笑）。

这个“…”的部分中传递的参数，可以使用va_list来获取，只要include了就可以使用了。使用时先通过va_start进行初始化，最后再用va_end来扫尾。

同时，有一个版本的sprintf是可以接受va_list作为参数的，名字叫vsprintf，使用这个函数就可以完成处理了。vsprintf也是编译器附带的，可以直接使用。

虽然上面对“…”形式的参数做了讲解，不过这种形式并不常用，大家随便看看就可以了。

■■■■■

最后我们来做malloc和free，这两个函数只要include了就可以使用了4。

4 笔者参考的是这个网页：http://www.linux.or.jp/JM/html/LDP_man-pages/man3/malloc.3.html（译者注：由于时间久远，原链接已失效，各位读者请参考这里：http://www.linux.com/learn/docs/man/2634-calloc3）。

可能大家会觉得，用api_malloc和api_free不就可以轻松实现了吗？事实上可没有那么简单。标准函数的free无需指定size，因此我们需要将malloc时指定的size找个地方存放起来。

malloc.c

void *malloc(int size)

{

char *p = api_malloc(size + 16);

if (p != 0) {

*((int *) p) = size;

p += 16;

}

return p;

}




free.c

void free(void *p)



void free(void *p)

{

char *q = p;

int size;

if (q != 0) {

q -= 16;

size = *((int *) q);

api_free(q, size + 16);

}

return;

}




size的值到底应该存放在哪里呢？我们在api_malloc的时候特地多分配了16字节的空间出来，然后将size存放在那里，在free的时候则执行相反的操作。size是int型，其实只需要占用4字节的内存空间，不过内存地址为16字节的倍数时，CPU的处理速度有时候可以更快，因此在这里就用了16字节（这样从api_malloc返回的内存地址就一定是16字节的倍数）。

■■■■■

到这里，标准函数就编写完成了。由于这部分内容只是顺带提及，因此上述程序代码并未包含在本书附送的光盘中，有需要的读者请自己输入代码吧。像printf这样的函数，如果可以使用的话应该还是很方便的呢。





4　非矩形窗口（harib26c）

好啦，现在开始我们可以编写应用程序玩玩了！

这里“非矩形”表示“非方块形状”，也就是说我们现在要让窗口的形状为方形以外的其他形状，这通过使用透明色就可以实现。这个例子说明“纸娃娃系统”也能实现这种高级功能哟。

notrec.c

#include "apilib.h"



void HariMain(void)

{

int win;

char buf[150 * 70];

win = api_openwin(buf, 150, 70, 255, "notrec");

api_boxfilwin(win, 0, 50, 34, 69, 255);

api_boxfilwin(win, 115, 50, 149, 69, 255);

api_boxfilwin(win, 50, 30, 99, 49, 255);

for (;;) {

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break; */



}

}

api_end();

}




我们将透明色指定为255号，然后用这个透明色在窗口中绘制3个方块。于是我们绘制方块的部分就变成了透明的，从结果上说也就画出非矩形的窗口了。

应用程序名称“notrec”是“not rectangle”（非矩形）的缩写。

“make run”的结果如图1，是不是很有意思呢？

1 “make run”的结果如图：某些情况下可能不会显示出图上的结果，出现这种情况时只要移动一下窗口就可以了。这是由于没有考虑到窗口形状变化（增加了透明色）而出现的问题，只要编写一个窗口形状变化时专用的refresh API就可以解决。本书中对于非矩形窗口并没有实现真正意义上的支持，因此没有增加相应的API。



非矩形的窗口？

虽然现在这样还不行，但只要对操作系统方面进行一些修改并支持隐藏窗口标题栏的话，我们就可以绘制出桔子形的窗口，甚至是人形的窗口等各种窗口啦。这多亏了我们前面设计好的图层管理机制呢。





5　bball（harib26d）

“bball”是笔者很喜欢的一个OSASK上的应用程序，这个名字是“beautiful ball”的缩写，通过绘制很多条直线，组成一个美丽的球形。程序本身很短也很简单，不过画出来的图形非常漂亮。我们把这个程序也移植到“纸娃娃系统”上来吧。

其实，笔者之所以在“纸娃娃系统”中编写了用来画直线的API，也正是为了在这里移植这个程序呢（笑）。

bball.c

#include "apilib.h"



void HariMain(void)

{

int win, i, j, dis;

char buf[216 * 237];

struct POINT {

int x, y;

};

static struct POINT table[16] = {

{ 204, 129 }, { 195, 90 }, { 172, 58 }, { 137, 38 }, { 98, 34 },

{ 61, 46 }, { 31, 73 }, { 15, 110 }, { 15, 148 }, { 31, 185 },

{ 61, 212 }, { 98, 224 }, { 137, 220 }, { 172, 200 }, { 195, 168 },

{ 204, 129 }

};



win = api_openwin(buf, 216, 237, -1, "bball");

api_boxfilwin(win, 8, 29, 207, 228, 0);

for (i = 0; i <= 14; i++) {

for (j = i + 1; j <= 15; j++) {

dis = j - i; /*两点间的距离*/

if (dis >= 8) {

dis = 15 - dis; /*逆向计数*/

}

if (dis != 0) {

api_linewin(win, table[i].x, table[i].y, table[j].x, table[j].y, 8 - dis);

}

}

}



for (;;) {

if (api_getkey(1) == 0x0a) {

break; /*按下回车键则break; */

}

}

api_end();

}




这种写法在结构数组声明部分直接赋予初始值，可能大家还是第一次见到。没关系，只要知道“嘿，原来还可以这样写啊”就可以啦。

■■■■■

好，我们来“make run”。啊，图形超出画面边界了，不过用VESA的人应该可以完全显示出来的哦。咦？显示的图形有问题啊……



有些线没有显示出来

唔，这貌似是操作系统的bug呢，因为画线的程序并没有什么问题。我们把窗口移动一下看看。哦，果然好了。也就是说，这是refresh失败导致的。

于是我们来修正一下操作系统的bug。

本次的console.c节选

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)

{

（中略）

} else if (edx == 13) {

sht = (struct SHEET *) (ebx & 0xfffffffe);

hrb_api_linewin(sht, eax, ecx, esi, edi, ebp);

if ((ebx & 1) == 0) { /*从此开始*/

if (eax > esi) {

i = eax;

eax = esi;

esi = i;

}

if (ecx > edi) {

i = ecx;

ecx = edi;

edi = i;

} /*到此结束*/

sheet_refresh(sht, eax, ecx, esi + 1, edi + 1);

}

} else if (edx == 14) {

（中略）

}




为了保证refresh范围指定正确的左上角和右下角坐标，我们将变量进行比较后做了替换。

再来“make run”一次看看……成功了！怎么样，很漂亮吧？这样一个应用程序只需要350字节哦，“纸娃娃系统”真是相当给力不是吗？



bball完成

不过图形超出画面范围看上去很不爽，我们用VESA模式再重新截一张图片下来。



这就是bball的完整版啦！





6　外星人游戏（harib26e）

接下来，我们打算做一个跟OSASK上面的外星人游戏差不多的游戏。在看这本书的各位读者估计也不知道OSASK的外星人游戏到底是何方神圣，那么我们先从背景故事开始讲起吧（笑）。顺便说一句，这个故事不是之前就设定好的，而是笔者在这里现编的。

20XX年，从遥远的宇宙另一端飞来一群外星侵略者，它们不用穿太空服就能在宇宙中生存。它们也没有发达的文明，一直就这样在宇宙中四处漂泊。

虽然并没有恶意，但它们身上感染了一种凶恶的病毒，人类目前的科学水平还无法应付（它们自己虽然感染了病毒，但这种病毒对它们的健康无害），如果它们来到地球，包括人类在内的大多数地球生命都会遭到毁灭性的打击。

人类曾经尝试说服这些外星人，但是他们的语言能力不佳，根本就无法沟通。科学家们经过讨论，认为只好将它们击退。虽然做法有些残酷，但如果它们看到同伴受到攻击全都牺牲了，它们似乎就会做出“看来这里不适合我们居住”的判断。

时间紧迫，只争朝夕。就在人类商讨对策之时，它们已经来到地球了。没办法，只好抄起手边的等离子炮，将它们连同病毒一起消灭掉。

游戏的操作方法是这样的，按小键盘上的“4”和“6”键移动自机的位置，按空格键发射等离子炮。等离子炮每发射一次，必须进行一段时间的充电（或者是加热?）才能重新发射（其实这个时间也不是很长），因此不能连续发射。笔者也没见过真的等离子炮是什么样的（笑），不过我们的等离子炮炮弹飞行的速度慢到可以用肉眼看见，反正不是像光线那样飞快就是了，发射的时候还是要瞄准好哟。

消灭外星人会得到奖金（得分），命中率越高（打空的次数少）的话得到的奖金越多。因为这个等离子炮需要消费大量的电力，如果老是打不中而白白浪费的话，咱们国家的电力就会不够用啦。为了鼓励炮击手节约弹药，我们才设定了这样一个奖励的规定。

为了地球的和平，希望大家英勇奋战！

补充：当初估计它们只有30只来到了地球，但现在看来还有后续部队。另有不确定的情报表示，后续部队的移动速度很快……消灭它们吧！

我们来编写程序吧，这次比较长哦。

invader.c

#include <stdio.h> /* sprintf */

#include <string.h> /* strlen */

#include "apilib.h"



void putstr(int win, char *winbuf, int x, int y, int col, unsigned char *s);

void wait(int i, int timer, char *keyflag);



static unsigned char charset[16 * 8] = {



/* invader(0) */

0x00, 0x00, 0x00, 0x43, 0x5f, 0x5f, 0x5f, 0x7f,

0x1f, 0x1f, 0x1f, 0x1f, 0x00, 0x20, 0x3f, 0x00,



/* invader(1) */

0x00, 0x0f, 0x7f, 0xff, 0xcf, 0xcf, 0xcf, 0xff,

0xff, 0xe0, 0xff, 0xff, 0xc0, 0xc0, 0xc0, 0x00,



/* invader(2) */

0x00, 0xf0, 0xfe, 0xff, 0xf3, 0xf3, 0xf3, 0xff,

0xff, 0x07, 0xff, 0xff, 0x03, 0x03, 0x03, 0x00,



/* invader(3) */

0x00, 0x00, 0x00, 0xc2, 0xfa, 0xfa, 0xfa, 0xfe,

0xf8, 0xf8, 0xf8, 0xf8, 0x00, 0x04, 0xfc, 0x00,



/* fighter(0) */

0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

0x01, 0x43, 0x47, 0x4f, 0x5f, 0x7f, 0x7f, 0x00,



/* fighter(1) */

0x18, 0x7e, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xff,

0xff, 0xff, 0xe7, 0xe7, 0xe7, 0xe7, 0xff, 0x00,



/* fighter(2) */

0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

0x80, 0xc2, 0xe2, 0xf2, 0xfa, 0xfe, 0xfe, 0x00,



/* laser */

0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,

0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00

};

/* invader:"abcd", fighter:"efg", laser:"h" */



void HariMain(void)

{

int win, timer, i, j, fx, laserwait, lx = 0, ly;

int ix, iy, movewait0, movewait, idir;

int invline, score, high, point;

char winbuf[336 * 261], invstr[32 * 6], s[12], keyflag[4], *p;

static char invstr0[32] = " abcd abcd abcd abcd abcd ";



win = api_openwin(winbuf, 336, 261, -1, "invader");

api_boxfilwin(win, 6, 27, 329, 254, 0);

timer = api_alloctimer();

api_inittimer(timer, 128);



high = 0;

putstr(win, winbuf, 22, 0, 7, "HIGH:00000000");



restart:

score = 0;

point = 1;

putstr(win, winbuf, 4, 0, 7, "SCORE:00000000");

movewait0 = 20;

fx = 18;

putstr(win, winbuf, fx, 13, 6, "efg");

wait(100, timer, keyflag);



next_group:

wait(100, timer, keyflag);

ix = 7;

iy = 1;

invline = 6;

for (i = 0; i < 6; i++) {

for (j = 0; j < 27; j++) {

invstr[i * 32 + j] = invstr0[j];

}

putstr(win, winbuf, ix, iy + i, 2, invstr + i * 32);

}

keyflag[0] = 0;

keyflag[1] = 0;

keyflag[2] = 0;



ly = 0; /*不显示*/

laserwait = 0;

movewait = movewait0;

idir = +1;

wait(100, timer, keyflag);



for (;;) {

if (laserwait != 0) {

laserwait--;

keyflag[2 /* space */] = 0;

}



wait(4, timer, keyflag);



/*自机的处理*/

if (keyflag[0 /* left */] != 0 && fx > 0) {

fx--;

putstr(win, winbuf, fx, 13, 6, "efg ");

keyflag[0 /* left */] = 0;

}

if (keyflag[1 /* right */] != 0 && fx < 37) {

putstr(win, winbuf, fx, 13, 6, " efg");

fx++;

keyflag[1 /* right */] = 0;

}

if (keyflag[2 /* space */] != 0 && laserwait == 0) {



laserwait = 15;

lx = fx + 1;

ly = 13;

}



/*外星人移动*/

if (movewait != 0) {

movewait--;

} else {

movewait = movewait0;

if (ix + idir > 14 || ix + idir < 0) {

if (iy + invline == 13) {

break; /* GAME OVER */

}

idir = - idir;

putstr(win, winbuf, ix + 1, iy, 0, " ");

iy++;

} else {

ix += idir;

}

for (i = 0; i < invline; i++) {

putstr(win, winbuf, ix, iy + i, 2, invstr + i * 32);

}

}



/*炮弹处理*/

if (ly > 0) {

if (ly < 13) {

if (ix < lx && lx < ix + 25 && iy <= ly && ly < iy + invline) {

putstr(win, winbuf, ix, ly, 2, invstr + (ly - iy) * 32);

} else {

putstr(win, winbuf, lx, ly, 0, " ");

}

}

ly--;

if (ly > 0) {

putstr(win, winbuf, lx, ly, 3, "h");

} else {

point -= 10;

if (point <= 0) {

point = 1;

}

}

if (ix < lx && lx < ix + 25 && iy <= ly && ly < iy + invline) {

p = invstr + (ly - iy) * 32 + (lx - ix);

if (*p != ' ') {

/* hit ! */

score += point;

point++;

sprintf(s, "%08d", score);

putstr(win, winbuf, 10, 0, 7, s);

if (high < score) {

high = score;

putstr(win, winbuf, 27, 0, 7, s);

}

for (p--; *p != ' '; p--) { }

for (i = 1; i < 5; i++) {

p[i] = ' ';

}

putstr(win, winbuf, ix, ly, 2, invstr + (ly - iy) * 32);

for (; invline > 0; invline--) {

for (p = invstr + (invline - 1) * 32; *p != 0; p++) {

if (*p != ' ') {

goto alive;

}

}

}

/*全部消灭*/

movewait0 -= movewait0 / 3;

goto next_group;

alive:

ly = 0;



}

}

}

}



/* GAME OVER */

putstr(win, winbuf, 15, 6, 1, "GAME OVER");

wait(0, timer, keyflag);

for (i = 1; i < 14; i++) {

putstr(win, winbuf, 0, i, 0, " ");

}

goto restart;

}



void putstr(int win, char *winbuf, int x, int y, int col, unsigned char *s)

{

int c, x0, i;

char *p, *q, t[2];

x = x * 8 + 8;

y = y * 16 + 29;

x0 = x;

i = strlen(s); /*计算s的字符数*/

api_boxfilwin(win + 1, x, y, x + i * 8 - 1, y + 15, 0);

q = winbuf + y * 336;

t[1] = 0;

for (;;) {

c = *s;

if (c == 0) {

break;

}

if (c != ' ') {

if ('a' <= c && c <= 'h') {

p = charset + 16 * (c - 'a');

q += x;

for (i = 0; i < 16; i++) {

if ((p[i] & 0x80) != 0) { q[0] = col; }

if ((p[i] & 0x40) != 0) { q[1] = col; }

if ((p[i] & 0x20) != 0) { q[2] = col; }

if ((p[i] & 0x10) != 0) { q[3] = col; }

if ((p[i] & 0x08) != 0) { q[4] = col; }

if ((p[i] & 0x04) != 0) { q[5] = col; }

if ((p[i] & 0x02) != 0) { q[6] = col; }

if ((p[i] & 0x01) != 0) { q[7] = col; }

q += 336;

}

q -= 336 * 16 + x;

} else {

t[0] = *s;

api_putstrwin(win + 1, x, y, col, 1, t);

}

}

s++;

x += 8;

}

api_refreshwin(win, x0, y, x, y + 16);

return;

}



void wait(int i, int timer, char *keyflag)

{

int j;

if (i > 0) {

/*等待一段时间*/

api_settimer(timer, i);

i = 128;

} else {

i = 0x0a; /* Enter */

}

for (;;) {

j = api_getkey(1);

if (i == j) {

break;



}

if (j == '4') {

keyflag[0 /* left */] = 1;

}

if (j == '6') {

keyflag[1 /* right */] = 1;

}

if (j == ' ') {

keyflag[2 /* space */] = 1;

}

}

return;

}




由于这不是操作系统，而只是一个应用程序。这本书也不是讲如何编写外星人游戏的，而是讲如何编写操作系统的（笑），因此对于程序的讲解我们就速战速决吧。

putstr函数用来显示字符串，不过a～h的字符不是直接显示，而是用charset的字库来显示的，为提高显示速度，使用了api_refreshwin。

wait函数用来延时并等待按键输入。当i指定为0时等待回车键的输入，否则按照“指定的时间×0.01秒”为基准进行延时等待，在等待期间如果有按键输入则反映到keyflag[0～2]中。

HariMain则是处理游戏的主体，里面有很多变量，这里介绍一些比较难懂的。

fx：自机的x坐标（fighter_x）

lx, ly：等离子炮弹的坐标（laser_x, laser_y）1

ix, iy：外星人群的坐标（invaders_x, invaders_y）

idir：外星人群的移动方向（invaders_direction）

laserwait：等离子炮弹的剩余充电时间

movewait：当这个变量变为0时外星人群前进一步

movewait0：movewait的初始值（消灭30只敌人后减少）

invline：外星人群的行数（invaders_line）

score：当前得分

high：最高得分

point：得分的增加量（奖金的单价？）

invstr：将外星人群的状态显示为字符串的变量

1 一开始本来管自机发射的炮弹叫“激光”，不过激光居然飞得这么慢实在太诡异了（笑），于是在编故事的时候改成等离子炮弹了。

对了，在这个游戏中，当外星人到达最底下一行时就Game Over了，这时按下回车键可以重新开始。对于这个程序我们没有设定正常的结束方法，大家可以按Shift+F1或者点击“×”按钮强制结束。

■■■■■

好了，我们来“make run”。静下心来，为了保卫地球的明天，加油！



战斗开始 呜哇！

漫长的战斗之后（话说也就是几分钟吧）……终于挂了！

地球完蛋了！……这样可不行，要是人生能重新来过就好了（太夸张了）。其实按下回车键就可以了哦，胜败乃兵家常事，大侠请重新来过（笑）。

我们再来重新看看程序吧。make之后生成的invader.hrb大小为2335字节，也就是说，“纸娃娃系统”所具备的API使得这样一个游戏仅用2.28KB就可以写出来。和其他操作系统相比，这并不能算是非常好，不过笔者还是感到挺自豪的。

今天就到这里吧，明天我们继续来编写应用程序哦！





第30天　高级的应用程序



命令行计算器（harib27a）

文本阅览器（harib27b）

MML播放器（harib27c）

图片阅览器（harib27d）

IPL的改良（harib27e）

光盘启动（harib27f）





1　命令行计算器（harib27a）

这一章我们要编写一些“高级的应用程序”，不过其实也没那么高级，说不定还是昨天那个invader.hrb比较高级呢，因此大家可别抱太大的期望哦（笑）。

那到底做点什么样的应用程序好呢？现在我们的系统中已经有noodle.hrb可以帮我们做泡面，还有invader.hrb可以用来玩游戏，应该再找一些其他能派上用场的功能……于是笔者想到了计算器。

Windows中附带了一个计算器软件，不过做那样一个好看的计算器太麻烦了，我们就做一个在命令行中输入算式来进行计算的应用程序吧。

■■■■■

我们来看程序。

calc.c

#include "apilib.h"

#include <stdio.h> /* sprintf */



#define INVALID -0x7fffffff



int strtol(char *s, char **endp, int base); /*标准函数(stdlib.h) */



char *skipspace(char *p);

int getnum(char **pp, int priority);



void HariMain(void)

{

int i;

char s[30], *p;



api_cmdline(s, 30);

for (p = s; *p > ' '; p++) { } /*一直读到空格为止*/

i = getnum(&p, 9);

if (i == INVALID) {

api_putstr0("error!\n");

} else {

sprintf(s, "= %d = 0x%x\n", i, i);

api_putstr0(s);

}

api_end();

}



char *skipspace(char *p)

{

for (; *p == ' '; p++) { } /*将空格跳过去*/

return p;

}



int getnum(char **pp, int priority)

{

char *p = *pp;

int i = INVALID, j;

p = skipspace(p);



/*单项运算符*/

if (*p == '+') {

p = skipspace(p + 1);

i = getnum(&p, 0);

} else if (*p == '-') {

p = skipspace(p + 1);

i = getnum(&p, 0);

if (i != INVALID) {

i = - i;

}

} else if (*p == '~') {

p = skipspace(p + 1);

i = getnum(&p, 0);

if (i != INVALID) {

i = ~i;

}

} else if (*p == '(') { /*括号*/

p = skipspace(p + 1);

i = getnum(&p, 9);

if (*p == ')') {

p = skipspace(p + 1);

} else {

i = INVALID;

}

} else if ('0' <= *p && *p <= '9') { /*数值*/

i = strtol(p, &p, 0);

} else { /*错误 */

i = INVALID;

}



/*二项运算符*/

for (;;) {

if (i == INVALID) {

break;

}

p = skipspace(p);

if (*p == '+' && priority > 2) {

p = skipspace(p + 1);

j = getnum(&p, 2);

if (j != INVALID) {

i += j;

} else {

i = INVALID;

}

} else if (*p == '-' && priority > 2) {

p = skipspace(p + 1);

j = getnum(&p, 2);

if (j != INVALID) {

i -= j;

} else {

i = INVALID;

}

} else if (*p == '*' && priority > 1) {

p = skipspace(p + 1);

j = getnum(&p, 1);

if (j != INVALID) {

i *= j;

} else {

i = INVALID;

}

} else if (*p == '/' && priority > 1) {

p = skipspace(p + 1);

j = getnum(&p, 1);

if (j != INVALID && j != 0) {

i /= j;

} else {

i = INVALID;

}

} else if (*p == '%' && priority > 1) {

p = skipspace(p + 1);

j = getnum(&p, 1);

if (j != INVALID && j != 0) {

i %= j;

} else {

i = INVALID;

}

} else if (*p == '<' && p[1] == '<' && priority > 3) {

p = skipspace(p + 2);

j = getnum(&p, 3);

if (j != INVALID && j != 0) {

i <<= j;

} else {

i = INVALID;

}

} else if (*p == '>' && p[1] == '>' && priority > 3) {

p = skipspace(p + 2);

j = getnum(&p, 3);

if (j != INVALID && j != 0) {

i >>= j;



} else {

i = INVALID;

}

} else if (*p == '&' && priority > 4) {

p = skipspace(p + 1);

j = getnum(&p, 4);

if (j != INVALID) {

i &= j;

} else {

i = INVALID;

}

} else if (*p == '^' && priority > 5) {

p = skipspace(p + 1);

j = getnum(&p, 5);

if (j != INVALID) {

i ^= j;

} else {

i = INVALID;

}

} else if (*p == '|' && priority > 6) {

p = skipspace(p + 1);

j = getnum(&p, 6);

if (j != INVALID) {

i |= j;

} else {

i = INVALID;

}

} else {

break;

}

}

p = skipspace(p);

*pp = p;

return i;

}




如果以前没有编写过类似的计算器程序的话，估计不太容易看懂上面这段程序。这段程序本来就已经偏离了“编写操作系统”这个主题，因此笔者也没打算逼着大家看懂，不过如果你对这段程序很感兴趣，不妨先运行一下玩玩看，然后再仔细阅读下面的讲解，一定能慢慢看明白的。

在这段程序中使用了strtol(s, endp, base)这样一个函数，这个函数的功能基本上和sprintf是相反的，它可以将字符串形式的数值转换为整数。字符串的地址由s指定，base表示进制，例如10代表十进制，16代表十六进制，0则代表自动识别（以0x开头则识别为十六进制）。

endp一般可以指定为0，也可以指定一个变量的地址，如果指定了地址，则函数会返回在转换字符串时所读取到的字符串末尾地址。字符串末尾地址是一个char *型的变量，这个变量的地址由endp指定，地址的地址，也就是一个char **型的变量。

strtol是一个只要include了就可以使用的标准函数，不过笔者在“纸娃娃系统”用的tolset中没有包含，因此在程序中直接进行了声明。

getnum中也使用了char **型的参数，和strtol一样，也是为了将当前解析到算式中的位置返回给相应的变量。

函数getnum的功能是将字符串形式的算式进行解释，并获取一个数值。除了进入字符串开始地址的变量地址外，还需要指定计算到哪个等级的运算符（“+”、“/”等用于表示各种运算的符号）。在HariMain中我们指定了9，这代表“无论多么低优先级的运算符，全部需要计算出来”的意思。

用作运算符的字符包括+ - * / % & | ^ ~ << >> ( )，结果同时显示十进制和十六进制。不过计算都是以整数进行，比如：10 / 3 = 3，可以使用负数。计算的优先级和C语言的规定相同，因此1 + 2 * 3 + 4 = 11，如果单纯从左往右按顺序计算的话结果应该是13，但我们的计算器不会这样计算，当然，如果输入（ 1 + 2 ） * 3 + 4的话就可以计算出13了哦。

由于使用了和C语言相同的语法规则，因此^是代表XOR运算的运算符，2^3可不是“2的3次方”的意思，而是“2 XOR 3”的意思哦。另外，和C语言一样，我们可以直接输入十六进制的数字进行计算，只要在数字前面加上0x就可以了。

■■■■■

我们来“make run”看看吧，关于使用方法，可以输入如 “calc 1+2”。



尝试进行了各种计算 又尝试了更多种类的计算

怎么样，还挺有意思的吧？这样一来，一些比较简单的计算用“纸娃娃系统”就可以胜任了哦，可喜可贺。对了，calc.hrb只有1688字节哦，短小精悍吧！





2　文本阅览器（harib27b）

“纸娃娃系统”中已经有了type.hrb，可以显示出文本文件的内容。不过由于屏幕滚动的速度太快，而且没有办法往回滚动，用起来挺不方便的，而且命令行窗口也太小了。

于是，我们来做一个用来查看文本文件内容的文本阅览器吧。

首先来看程序……话说每次都一上来就先拿一大段程序出来好像挺无聊的，从现在起就先给大家展示一下完成后的运行画面好了。如果事先知道要做出来的程序是什么样，再去看程序的话应该会更容易理解吧。

输入“tview ipl20.nas –w100 –h30”，运行结果如下图。



咚！显示出来了

用光标键可以上下左右进行滚动，在QEMU中可能速度不是很快，这是由于模拟器性能不佳造成的，在真机环境下速度还是相当快的哦。

滚动的速度也是可以调节的。按“b”可以将纵向滚动的速度设为每次2行，“c”则每次4行，“d”则每次8行。以此类推，可以一直用到“f”，按“a”则恢复为初始状态，每次滚动1行。同样地，用“A”～“F”可以改变横向滚动的速度。

关于启动时的命令行选项，-w和-h代表窗口的大小。-w表示打开一个宽度为100个半角字符的窗口，最大可以指定为126。-h表示行数，最大可以指定为45。如果不指定-w和-h，则默认为-w30、-h10。

此外，用-t选项可以指定制表符的大小，省略的话则按照笔者的习惯默认为-t4。制表符的大小在程序启动后也可以通过“<”和“>”键来进行调节。

按“q”或者“Q”可以退出程序。其实这个键倒没那么重要。即便忘记了，点击“×”按钮或者按Shift+F1强制结束也没什么问题。

■■■■■

下面我们来看程序吧。

tview.c

#include "apilib.h"



#include <stdio.h>



int strtol(char *s, char **endp, int base); /*标准函数(stdlib.h) */



char *skipspace(char *p);

void textview(int win, int w, int h, int xskip, char *p, int tab, int lang);

char *lineview(int win, int w, int y, int xskip, unsigned char *p, int tab, int lang);

int puttab(int x, int w, int xskip, char *s, int tab);



void HariMain(void)

{

char winbuf[1024 * 757], txtbuf[240 * 1024];

int w = 30, h = 10, t = 4, spd_x = 1, spd_y = 1;

int win, i, j, lang = api_getlang(), xskip = 0;

char s[30], *p, *q = 0, *r = 0;



/*命令行解析*/

api_cmdline(s, 30);

for (p = s; *p > ' '; p++) { } /*一直读到空格为止*/

for (; *p != 0; ) {

p = skipspace(p);

if (*p == '-') {

if (p[1] == 'w') {

w = strtol(p + 2, &p, 0);

if (w < 20) {

w = 20;

}

if (w > 126) {

w = 126;

}

} else if (p[1] == 'h') {

h = strtol(p + 2, &p, 0);

if (h < 1) {

h = 1;

}

if (h > 45) {

h = 45;

}

} else if (p[1] == 't') {

t = strtol(p + 2, &p, 0);

if (t < 1) {

t = 4;

}

} else {

err:



api_putstr0(" >tview file [-w30 -h10 -t4]\n");

api_end();

}

} else { /*找到文件名*/

if (q != 0) {

goto err;

}

q = p;

for (; *p > ' '; p++) { } /*一直读到空格为止*/

r = p;

}

}

if (q == 0) {

goto err;

}



/*准备窗口*/

win = api_openwin(winbuf, w * 8 + 16, h * 16 + 37, -1, "tview");

api_boxfilwin(win, 6, 27, w * 8 + 9, h * 16 + 30, 7);



/*载入文件*/

*r = 0;

i = api_fopen(q);

if (i == 0) {

api_putstr0("file open error.\n");

api_end();

}

j = api_fsize(i, 0);

if (j >= 240 * 1024 - 1) {

j = 240 * 1024 - 2;

}

txtbuf[0] = 0x0a; /*卫兵用的换行代码*/

api_fread(txtbuf + 1, j, i);

api_fclose(i);

txtbuf[j + 1] = 0;

q = txtbuf + 1;

for (p = txtbuf + 1; *p != 0; p++) { /*为了让处理变得简单，删掉0x0d的代码*/

if (*p != 0x0d) {

*q = *p;

q++;

}

}

*q = 0;



/*主体*/

p = txtbuf + 1;

for (;;) {

textview(win, w, h, xskip, p, t, lang);

i = api_getkey(1);

if (i == 'Q' || i == 'q') {

api_end();

}

if ('A' <= i && i <= 'F') {

spd_x = 1 << (i - 'A'); /* 1, 2, 4, 8, 16, 32 */

}

if ('a' <= i && i <= 'f') {

spd_y = 1 << (i - 'a'); /* 1, 2, 4, 8, 16, 32 */

}

if (i == '<' && t > 1) {

t /= 2;

}

if (i == '>' && t < 256) {

t *= 2;

}

if (i == '4') {



for (;;) {

xskip -= spd_x;

if (xskip < 0) {

xskip = 0;

}

if (api_getkey(0) != '4') { /*如果没有按下“4”则处理结束*/

break;

}

}

}

if (i == '6') {

for (;;) {

xskip += spd_x;

if (api_getkey(0) != '6') {

break;

}

}

}

if (i == '8') {

for (;;) {

for (j = 0; j < spd_y; j++) {

if (p == txtbuf + 1) {

break;

}

for (p--; p[-1] != 0x0a; p--) { } /*回溯到上一个字符为0x0a为止*/

}

if (api_getkey(0) != '8') {

break;

}

}

}

if (i == '2') {

for (;;) {

for (j = 0; j < spd_y; j++) {

for (q = p; *q != 0 && *q != 0x0a; q++) { }

if (*q == 0) {

break;

}

p = q + 1;

}

if (api_getkey(0) != '2') {

break;

}

}

}

}

}



char *skipspace(char *p)

{

for (; *p == ' '; p++) { } /*跳过空格*/

return p;

}



void textview(int win, int w, int h, int xskip, char *p, int tab, int lang)

{

int i;

api_boxfilwin(win + 1, 8, 29, w * 8 + 7, h * 16 + 28, 7);

for (i = 0; i < h; i++) {

p = lineview(win, w, i * 16 + 29, xskip, p, tab, lang);

}

api_refreshwin(win, 8, 29, w * 8 + 8, h * 16 + 29);

return;

}



char *lineview(int win, int w, int y, int xskip, unsigned char *p, int tab, int lang)

{

int x = - xskip;

char s[130];

for (;;) {

if (*p == 0) {

break;

}

if (*p == 0x0a) {

p++;

break;

}

if (lang == 0) { /* ASCII */

if (*p == 0x09) {

x = puttab(x, w, xskip, s, tab);

} else {

if (0 <= x && x < w) {

s[x] = *p;

}

x++;

}

p++;

}

if (lang == 1) { /* SJIS */

if (*p == 0x09) {

x = puttab(x, w, xskip, s, tab);

p++;

} else if ((0x81 <= *p && *p <= 0x9f) || (0xe0 <= *p && *p <= 0xfc)) {

/*全角字符*/

if (x == -1) {

s[0] = ' ';

}

if (0 <= x && x < w - 1) {

s[x] = *p;

s[x + 1] = p[1];

}

if (x == w - 1) {

s[x] = ' ';

}

x += 2;

p += 2;

} else {

if (0 <= x && x < w) {

s[x] = *p;

}

x++;

p++;

}

}

if (lang == 2) { /* EUC */

if (*p == 0x09) {

x = puttab(x, w, xskip, s, tab);

p++;

} else if (0xa1 <= *p && *p <= 0xfe) {

/*全角字符*/

if (x == -1) {

s[0] = ' ';

}

if (0 <= x && x < w - 1) {

s[x] = *p;

s[x + 1] = p[1];

}

if (x == w - 1) {

s[x] = ' ';

}



x += 2;

p += 2;

} else {

if (0 <= x && x < w) {

s[x] = *p;

}

x++;

p++;

}

}

}

if (x > w) {

x = w;

}

if (x > 0) {

s[x] = 0;

api_putstrwin(win + 1, 8, y, 0, x, s);

}

return p;

}



int puttab(int x, int w, int xskip, char *s, int tab)

{

for (;;) {

if (0 <= x && x < w) {

s[x] = ' ';

}

x++;

if ((x + xskip) % tab == 0) {

break;

}

}

return x;

}




程序基本上没有什么难点（虽然看上去很长），只要慢慢读应该能看懂。和calc.hrb一样，即便看不懂也问题不大。

在屏幕滚动的处理上用了api_getkey(0)，这是为了在QEMU上运行时可以尽量减少延迟。当同一个键被连续按下时，程序会将按键数据全部读取之后，再计算出总的移动量，然后再进行显示。

这个tview.hrb只有1753字节，跟calc.hrb大小差不多。嗯，也是短小精悍的。这么小的应用程序可以拥有如此不错的功能，我们的“纸娃娃系统”还真是挺强大的系统呢。

有人可能会说，既然都做到这一步了，还不如干脆做成文本编辑器呢。其实笔者也是这么想的，只不过现在的“纸娃娃系统”中还没有用于写入文件的API，即便做了文本编辑器也无法保存，感觉没有什么意义。看来“纸娃娃系统”还不太给力啊（笑）。





3　MML播放器（harib27c）

我们来想想看，用现存的API，还能做出什么有趣的应用程序呢？想起来了，做个演奏音乐的程序吧，这样一来我们就可以边听音乐边看电子书了，好不惬意。不过说是音乐，其实只是用音质很烂的蜂鸣器来演奏啦。

先来看看实际运行的画面。输入“mmlplay daigo.mml”后如下图。



正在演奏daigo.mml1

1 乐曲名称为《c小调第五交响曲“命运”op.67》。——译者注

■■■■■

在命令行中指定的文件名，是一个用MML（music macro language）编写的文本文件。这个文件中包含的内容是乐谱数据，如“哆来咪发唆啦西哆”分别对应“CDEFGABC”（在C大调中）。在音符的后面加上“+”或者“#”表示升高半音，加上“-”表示降低半音。再后面还可以加上数字，“4”表示四分音符，“8”表示八分音符，“1”表示全音符，如果是“2.”的话则表示符点二分音符。

“O”命令用来设定八度音区，例如可以设为“O4”。“L”命令用来设定音长，表示音符或者休止符（R）在不指定音长时的默认音长。“T”命令用来设定乐曲速度，“>”用来升高一个八度，“<”用来降低一个八度，“&”表示连音线。“Q”用来指定音符演奏是短促还是连贯，如“Q4”标出断奏，“Q8”表示一直使用连音奏法。

“$”开头的是扩展命令，是笔者自己对MML语法扩展出来的。“$K”是卡拉OK命令，后面指定的字符串会显示在卡拉OK栏中。“$E”表示卡拉OK歌词数据的字符编码，不过这个信息在mmlplay.hrb中是被忽略的。

MML数据中是不区分大小写的，演奏到最后会自动回到开头重新演奏，按下“Q”可以退出。

在演奏过程中有一条蓝色的竖线在不停地动，它是根据音阶来移动的，笔者觉得这个看上去挺好玩的。

乐曲数据我们先准备了4个2，选曲按照笔者的喜好（笑）。乐曲数据文件貌似都比较大，因此全部用tek5进行了压缩。

2 这里的几首歌曲给出的是日文版的歌词，如果大家没有对日文显示支持的部分进行改造，而是沿用作者编写的日文显示程序和日文字库，那么在这里只有用日文的歌词才能正常显示。如果大家对日文显示的部分进行了改造，并使用了中文字库，那么就需要将歌词替换为中文。为了方便大家使用，我们在原文下面给出了相应的中文歌词。——译者注

■■■■■

kirakira.mml

/* 《小星星》3 法国民歌 */



$E"SJIS"; T120L4O4



$K"一闪一闪亮晶晶，满天都是小星星"; CCGGAAG2 FFEEDDC2

$K"挂在天上放光明，好像许多小眼睛"; GGFFEED2 GGFFEED2

$K"一闪一闪亮晶晶，满天都是小星星"; CCGGAAG2 FFEEDDC2

$K""; R1



$K"一闪一闪亮晶晶，满天都是小星星"; CCGGAAG2 FFEEDDC2

$K"挂在天上放光明，好像许多小眼睛"; GGFFEED2 GGFFEED2

$K"一闪一闪亮晶晶，满天都是小星星"; CCGGAAG2 FFEEDDC2

$K""; R1 R1




3 这首歌中文版歌词只有一段，第二段重复第一段歌词即可。——译者注

fujisan.mml

/* 《富士山》4日本文部省民歌*/



$E"SJIS"; T120L4O4



$K"冲破云霄"; G.G8AGEC8D8E2 D.G8GF8E8D2.R

$K"傲视群山"; G.G8ECA.B8>C<A G.A8G8F8E8D8C2.R

$K"问鼎惊雷"; D.D8DDC8D8E8F8G2 A.B8>C<AG2.R

$K"富士，日本第一山"; >C2<AGE.E8AG FED.C8C2.R



$K"高耸蓝天"; G.G8AGEC8D8E2 D.G8GF8E8D2.R

$K"银装素裹"; G.G8ECA.B8>C<A G.A8G8F8E8D8C2.R

$K"身披彩霞"; D.D8DDC8D8E8F8G2 A.B8>C<AG2.R

$K"富士，日本第一山"; >C2<AGE.E8AG FED.C8C2.R



$K""; R1R1




4 这首歌是日本的歌谣，没有相应的中文版歌词，这里给出翻译的歌词大意。——译者注

daigo.mml

/* "第五交响曲 c小调 "命运" op. 67"选段 路德维希•范•贝多芬*/



$E"SJIS"; $K"第五交响曲 c小调 "命运" op.67";



T155Q7L8O4

RGGGE-2.RFFFD4&D1

RGGGQ8E-Q7A-A-A-Q8GQ7>E-E-E-C8&C2<GGG

Q8DQ7A-A-A-Q8GQ7>FFFD8&D2GGF

Q8E-Q7<E-E-FQ8G>Q7GGFQ8E-Q7<E-E-F

Q8GQ7>GGFL4E-RCRG2.L8R<A-A-A-F4&F1

RA-A-A-Q8FQ7DDDQ8<BQ7A-A-A-Q8GQ7<GGG

>>E-A-A-A-Q8FQ7DDDQ8<BQ7A-A-A-Q8GQ7<GGG

>>E-G>CCQ8C2Q7<BBB>DQ8D2Q7CCCE-Q8E-Q7DQ4DF

Q8FQ7EQ4EGQ7GQ7FQ4FA-Q8A-Q7GQ4GB-Q8B-Q7A-Q4A->C

Q8CQ7<BQ4B>DQ7CE-E-E-C<GGGE-C<GGE-CCC<B>>>FDD



<BGFFD<BGFD<B>CCC>>E-E-E-

C<AAAG-E-E-E-C<AAAA4R2R4B-4R4

RB-B-B-E-2F2Q8<B-2>L4B->E-DE-FQ7CQ8CQ7<B-

Q8B->E-DE-FQ7CQ8CQ7<B-Q8>B->E-DE-FQ7CQ8C<B-

Q8<B->CD-Q7CQ8<B->C<B-Q7A-Q8>D-E-FQ7E-

Q8D-E-D-Q7CQ8E-FG-FE-Q7FQ8G-FE-Q7FQ8G-F

E-Q7FQ8G-FE-FG-FG-Q7AL8B-&B-2Q4>C<B-A-

Q8A-Q7GQ4FE-Q8E-Q7DQ4CDQ8FQ7E-Q4<B-G

Q8>DQ7CQ4<A-FQ8>CQ7<B-Q4GE-Q7<B-Q8>>AB-A

B-AB-Q7AQ4B->C<B-A-Q8A-Q7GQ4FE-Q8E-Q7DQ4CD

Q8FQ7E-Q4<B-GQ8>DQ7CQ4<A-FQ8>CQ7<B-Q4GE-

Q7<B->B->B-B-E-GGGE-<B-B-B-GE-E-E-

Q8<B-Q7>DDDQ8E-Q7>GGGE-<B-B-B-GE-E-E-

Q8<B-Q7>B-B-B-B-4R4.B-B-B-B-4R4.>DDDE-4

R1R4




daiku.mml

/* "第九交响曲 d小调 "合唱" op.125"选段 路德维希•范•贝多芬5 */



$E"SJIS"; T110L4



O4

$K"欢乐女神，圣洁美丽，灿烂光芒照大地"; F+F+GA AGF+E DDEF+ F+.E8E2

$K"我们心中充满热情，来到你的圣殿里"; F+F+GA AGF+E DDEF+ E.D8D2

$K"你的力量能使人们消除一切分歧"; EEF+D EF+8G8F+D EF+8G8F+E DE<A>

$K"在你光辉照耀下面，人们团结成兄弟"; F+& F+F+GA AGF+E DDEF+ E.D8D2



O5

$K"在这美丽大地上，普世众生共欢乐"; F+F+GA AGF+E DDEF+ F+.E8E2

$K"一切人们不论善恶，都蒙自然赐恩泽"; F+F+GA AGF+E DDEF+ E.D8D2

$K"它给我们爱情美酒，同生共死好朋友"; EEF+D EF+8G8F+D EF+8G8F+E DE<A>

$K"它让众生共享欢乐，天使也高声同唱歌"; F+& F+F+GA AGF+E DDEF+ E.D8D2



$K""; R1




5 《欢乐颂》中文歌词共有4段，这里选了有代表性的第1段和第3段。——译者注

■■■■■

然后我们来看程序。

mmlplay.c

#include "apilib.h"



#include <string.h> /* strlen */



int strtol(char *s, char **endp, int base); /*标准函数(stdlib.h) */



void waittimer(int timer, int time);

void end(char *s);



void HariMain(void)

{

char winbuf[256 * 112], txtbuf[100 * 1024];

char s[32], *p, *r;

int win, timer, i, j, t = 120, l = 192 / 4, o = 4, q = 7, note_old = 0;



/*音号与频率（mHz）的对照表*/

/*例如，04A为440Hz，即440000 */

/*第16八度的A为1802240Hz，即1802240000 */

/*以下为第16八度的列表（C～B） */



static int tonetable[12] = {

1071618315, 1135340056, 1202850889, 1274376125, 1350154473, 1430438836,

1515497155, 1605613306, 1701088041, 1802240000, 1909406767, 2022946002

};

static int notetable[7] = { +9, +11, +0 /* C */, +2, +4, +5, +7 };



/*命令行解析*/

api_cmdline(s, 30);

for (p = s; *p > ' '; p++) { } /*一直读到空格为止*/

for (; *p == ' '; p++) { } /*跳过空格*/

i = strlen(p);

if (i > 12) {

file_error:

end("file open error.\n");

}

if (i == 0) {

end(0);

}



/*准备窗口*/

win = api_openwin(winbuf, 256, 112, -1, "mmlplay");

api_putstrwin(win, 128, 32, 0, i, p);

api_boxfilwin(win, 8, 60, 247, 76, 7);

api_boxfilwin(win, 6, 86, 249, 105, 7);



/*载入文件*/

i = api_fopen(p);

if (i == 0) {

goto file_error;

}

j = api_fsize(i, 0);

if (j >= 100 * 1024) {

j = 100 * 1024 - 1;

}

api_fread(txtbuf, j, i);

api_fclose(i);

txtbuf[j] = 0;

r = txtbuf;

i = 0; /*通常模式*/

for (p = txtbuf; *p != 0; p++) { /*为了方便处理，将注释和空白删去*/

if (i == 0 && *p > ' ') { /*不是空格或换行符*/

if (*p == '/') {

if (p[1] == '*') {

i = 1;

} else if (p[1] == '/') {

i = 2;

} else {

*r = *p;

if ('a' <= *p && *p <= 'z') {

*r += 'A' - 'a'; /*将小写字母转换为大写字母*/

}

r++;

}

} else if (*p == 0x22) {

*r = *p;

r++;

i = 3;

} else {

*r = *p;

r++;

}

} else if (i == 1 && *p == '*' && p[1] == '/') { /*段注释*/

p++;

i = 0;



} else if (i == 2 && *p == 0x0a) { /*行注释*/

i = 0;

} else if (i == 3) { /*字符串*/

*r = *p;

r++;

if (*p == 0x22) {

i = 0;

} else if (*p == '%') {

p++;

*r = *p;

r++;

}

}

}

*r = 0;



/*定时器准备*/

timer = api_alloctimer();

api_inittimer(timer, 128);



/*主体*/

p = txtbuf;

for (;;) {

if (('A' <= *p && *p <= 'G') || *p == 'R') { /*音符、休止符*/

/*计算频率*/

if (*p == 'R') {

i = 0;

s[0] = 0;

} else {

i = o * 12 + notetable[*p - 'A'] + 12;

s[0] = 'O';

s[1] = '0' + o;

s[2] = *p;

s[3] = ' ';

s[4] = 0;

}

p++;

if (*p == '+' || *p == '-' || *p == '#') {

s[3] = *p;

if (*p == '-') {

i--;

} else {

i++;

}

p++;

}

if (i != note_old) {

api_boxfilwin(win + 1, 32, 36, 63, 51, 8);

if (s[0] != 0) {

api_putstrwin(win + 1, 32, 36, 10, 4, s);

}

api_refreshwin(win, 32, 36, 64, 52);

if (28 <= note_old && note_old <= 107) {

api_boxfilwin(win, (note_old - 28) * 3 + 8, 60, (note_old - 28) * 3 + 10, 76, 7);

}

if (28 <= i && i <= 107) {

api_boxfilwin(win, (i - 28) * 3 + 8, 60, (i - 28) * 3 + 10, 76, 4);

}

if (s[0] != 0) {

api_beep(tonetable[i % 12] >> (17 - i / 12));

} else {

api_beep(0);

}

note_old = i;



}

/*音长计算*/

if ('0' <= *p && *p <= '9') {

i = 192 / strtol(p, &p, 10);

} else {

i = l;

}

for (; *p == '.'; ) {

p++;

i += i / 2;

}

i *= (60 * 100 / 48);

i /= t;

if (s[0] != 0 && q < 8 && *p != '&') {

j = i * q / 8;

waittimer(timer, j);

api_boxfilwin(win, 32, 36, 63, 51, 8);

if (28 <= note_old && note_old <= 107) {

api_boxfilwin(win, (note_old - 28) * 3 + 8, 60, (note_old - 28) * 3 + 10, 76, 7);

}

note_old = 0;

api_beep(0);

} else {

j = 0;

if (*p == '&') {

p++;

}

}

waittimer(timer, i - j);

} else if (*p == '<') { /*八度-- */

p++;

o--;

} else if (*p == '>') { /*八度++ */

p++;

o++;

} else if (*p == 'O') { /*八度指定*/

o = strtol(p + 1, &p, 10);

} else if (*p == 'Q') { /* Q参数指定*/

q = strtol(p + 1, &p, 10);

} else if (*p == 'L') { /*默认音长指定*/

l = strtol(p + 1, &p, 10);

if (l == 0) {

goto syntax_error;

}

l = 192 / l;

for (; *p == '.'; ) {

p++;

l += l / 2;

}

} else if (*p == 'T') { /*速度指定*/

t = strtol(p + 1, &p, 10);

} else if (*p == '$') { /*扩展命令*/

if (p[1] == 'K') { /*卡拉OK命令*/

p += 2;

for (; *p != 0x22; p++) {

if (*p == 0) {

goto syntax_error;

}

}

p++;

for (i = 0; i < 32; i++) {

if (*p == 0) {

goto syntax_error;

}



if (*p == 0x22) {

break;

}

if (*p == '%') {

s[i] = p[1];

p += 2;

} else {

s[i] = *p;

p++;

}

}

if (i > 30) {

end("karaoke too long.\n");

}

api_boxfilwin(win + 1, 8, 88, 247, 103, 7);

s[i] = 0;

if (i != 0) {

api_putstrwin(win + 1, 128 - i * 4, 88, 0, i, s);

}

api_refreshwin(win, 8, 88, 248, 104);

}

for (; *p != ';'; p++) {

if (*p == 0) {

goto syntax_error;

}

}

p++;

} else if (*p == 0) {

p = txtbuf;

} else {

syntax_error:

end("mml syntax error.\n");

}

}

}



void waittimer(int timer, int time)

{

int i;

api_settimer(timer, time);

for (;;) {

i = api_getkey(1);

if (i == 'Q' || i == 'q') {

api_beep(0);

api_end();

}

if (i == 128) {

return;

}

}

}



void end(char *s)

{

if (s != 0) {

api_putstr0(s);

}

api_beep(0);

api_end();

}




只要读过之前的程序，这段程序应该不会难懂吧。由音符数据计算频率，以及由音符的长度计算定时器应该设定为几秒这些地方可能不太容易理解，其实只要有相应的音乐知识（例如一个音升高半音后，频率是原来的约1.059463倍）就很容易看懂了。

总之（老生常谈了），本书的目的是编写操作系统，而不是编写MML播放器，关于相关音乐理论的讲解就省略了，不好意思。当然，笔者也是想给大家仔细讲讲的，只不过要讲清楚的话，又得增加1章的篇幅了。

将这个程序make一下，得到的mmlplay.hrb大小为1975字节，还是非常小的，真不错！





4　图片阅览器（harib27d）

话说，到现在为止的几个应用程序，都比昨天的invader.hrb要小，感觉非常对不起今天这一章的标题（高级的应用程序）。不过，体积大也未必说明它比较高级。虽说如此，我们还是来做一个规模大一点的应用程序吧。

其实invader.hrb之所以比较大，并不是因为内容比较高级，而是因为使用了sprintf函数。sprintf是一个很大的函数，如果可以避免使用这个函数的话，大约又可以缩小500多字节。

于是我们来做一个图片阅览器吧。用这一个程序，就可以查看BMP和JPEG两种格式的图片。我们先来看看实际运行的画面。



“gview night.bmp” “gview fujisan.jpg”

怎么样，显示效果不错吧？呵呵，小菜一碟（笑）。

关于程序，如果要给大家讲解BMP和JPEG的文件格式的话，篇幅又要变得很～长了，于是我们只好又省略了。而且用来解释BMP和JPEG文件格式的程序我们也不重新编写了，而是直接使用OSASK中的应用程序所引用的代码。

OSASK中有一个叫做PICTURE0.BIN的应用程序，这就是一个用来查看BMP和JPEG格式图片的图片阅览器。从这个程序的源代码中，我们提取了bmp.nasm和jpeg.c（这剧情怎么跟tek那时候差不多啊）。

这两个源程序看起来无需修改就可以直接使用，其中bmp.nasm的作者是I.Tak.，jpeg.c的作者是nikq、笔者、I.Tak.和Kumin。在这里要向I.Tak.、nikq和Kumin表示感谢，这个应用程序能很快编写出来都是你们的功劳。

于是，剩下的只需要载入文件并显示出来而已，这些程序刷刷刷就写出来了，放在这里了哦（关于bmp.nasm和jpeg.c的源代码，请大家查阅附送的光盘）。

gview.c

#include "apilib.h"



struct DLL_STRPICENV { /* 64KB */

int work[64 * 1024 / 4];

};



struct RGB {

unsigned char b, g, r, t;

};



/* bmp.nasm */

int info_BMP(struct DLL_STRPICENV *env, int *info, int size, char *fp);

int decode0_BMP(struct DLL_STRPICENV *env, int size, char *fp, int b_type, char *buf, int skip);



/* jpeg.c */

int info_JPEG(struct DLL_STRPICENV *env, int *info, int size, char *fp);

int decode0_JPEG(struct DLL_STRPICENV *env, int size, char *fp, int b_type, char *buf, int skip);



unsigned char rgb2pal(int r, int g, int b, int x, int y);

void error(char *s);



void HariMain(void)

{

struct DLL_STRPICENV env;

char filebuf[512 * 1024], winbuf[1040 * 805];

char s[32], *p;

int win, i, j, fsize, xsize, info[8];

struct RGB picbuf[1024 * 768], *q;



/*命令行解析*/

api_cmdline(s, 30);

for (p = s; *p > ' '; p++) { } /*一直读到空格为止*/

for (; *p == ' '; p++) { } /*跳过空格*/



/*文件载入*/

i = api_fopen(p); if (i == 0) { error("file not found.\n"); }

fsize = api_fsize(i, 0);

if (fsize > 512 * 1024) {

error("file too large.\n");



}

api_fread(filebuf, fsize, i);

api_fclose(i);



/*检查文件类型*/

if (info_BMP(&env, info, fsize, filebuf) == 0) {

/*不是BMP */

if (info_JPEG(&env, info, fsize, filebuf) == 0) {

/*也不是JPEG */

api_putstr0("file type unknown.\n");

api_end();

}

}

/*上面其中一个info函数调用成功的话，info中包含以下信息 */

/*info[0]：文件类型（1:BMP、2:JPEG）*/

/*info[1]：颜色数信息*/

/*info[2]：xsize */

/*info[3]：ysize */



if (info[2] > 1024 || info[3] > 768) {

error("picture too large.\n");

}



/*窗口准备*/

xsize = info[2] + 16;

if (xsize < 136) {

xsize = 136;

}

win = api_openwin(winbuf, xsize, info[3] + 37, -1, "gview");



/*将文件内容转换为图像数据*/

if (info[0] == 1) {

i = decode0_BMP (&env, fsize, filebuf, 4, (char *) picbuf, 0);

} else {

i = decode0_JPEG(&env, fsize, filebuf, 4, (char *) picbuf, 0);

}

/*b_type = 4表示struct RGB格式*/

/*skip设为0即可*/

if (i != 0) {

error("decode error.\n");

}



/*显示*/

for (i = 0; i < info[3]; i++) {

p = winbuf + (i + 29) * xsize + (xsize - info[2]) / 2;

q = picbuf + i * info[2];

for (j = 0; j < info[2]; j++) {

p[j] = rgb2pal(q[j].r, q[j].g, q[j].b, j, i);

}

}

api_refreshwin(win, (xsize - info[2]) / 2, 29, (xsize - info[2]) / 2 + info[2], 29 + info[3]);



/*等待结束*/

for (;;) {

i = api_getkey(1);

if (i == 'Q' || i == 'q') {

api_end();

}

}

}



unsigned char rgb2pal(int r, int g, int b, int x, int y)

{

static int table[4] = { 3, 1, 0, 2 };

int i;



x &= 1; /*判断是偶数还是奇数*/

y &= 1;

i = table[x + y * 2]; /*用于生成中间色的常量*/

r = (r * 21) / 256; /*结果为0～20*/

g = (g * 21) / 256;

b = (b * 21) / 256;

r = (r + i) / 4; /*结果为0～5*/

g = (g + i) / 4;

b = (b + i) / 4;

return 16 + r + g * 6 + b * 36;

}



void error(char *s)

{

api_putstr0(s);

api_end();

}




比较难懂的地方……大概就是info_BMP这里了吧。info_BMP是用来解释BMP文件格式，并获取图片分辨率等信息的函数。其中env是info_BMP工作用的内存空间（必须确保有64KB的空间）。另外，decode0_BMP函数用来读取BMP文件，并转换为统一的容易显示的形式。info_JPEG等函数就是对JPEG文件执行上述操作的版本，功能和上述函数都是相同的。

关于变量info，gview.c中只使用到了info[3]，看起来貌似声明到info[4]就足够了，不过info_BMP等函数需要任意使用info[4～7]的内存空间，如果不声明的话可能不会正常工作，因此我们还是声明为info[8]。

rgb2pal就是直接用了color2.hrb中的代码，有了这一算法fujisan.jpg也可以显示得很漂亮了。

■■■■■

关于bmp.nasm这里要稍微说明一下。这个程序是针对NASM这个汇编器编写的，用笔者准备的工具是无法进行汇编的。没办法，笔者向该程序的作者I.Tak.索取了汇编后生成的bmp.obj1，只要有了.obj文件就可以进行连接，这样就OK了。

1 索取了bmp.obj：由于觉得NASM写的源代码各位读者可能比较难懂，笔者本来准备将这段程序整个用C语言改写一遍，不过由于本书面临截稿，便没能实现这一设想，十分抱歉。至少能将格式比较简单的BMP改写成比较易懂的形式也好啊……

另外，在编译jpeg.c的时候，不知为何会出现很多警告信息，非常抱歉。不过jpeg.c即便忽略这些警告信息也没有什么问题，请大家不要在意就是了。

night.bmp和fujisan.jpg这两个文件都使用了tek进行压缩。如果想要边看night.bmp边听音乐的话，笔者推荐kirakira.mml。至于fujisan.jpg的音乐……用不着笔者告诉大家了吧（笑）。

最终生成的gview.hrb，大小为3865字节，即3.77KB，我们终于做出了比昨天的invader.hrb更大的应用程序了呢（笑）。不过即便如此，这样一个图片阅览器只要3.75KB，“纸娃娃系统”真是个不错的系统呢。





5　IPL的改良（harib27e）

进入本章以后（尤其是在测试mmlplay.hrb的时候），笔者在真机环境下运行了几次“纸娃娃系统”，发现启动时读取磁盘的时间还是有点长。现在我们是读取20个柱面，如果能减少到14或者18个这样勉强够用的柱面数的话，启动速度就可以加快了（不过代价是，以后新增文件的时候又要重新调整）。

于是我们先用二进制编辑器查看一下harib27d的haribote.img文件，发现数据占用的部分是到028C98为止。额，这是多少个柱面呢？一个柱面是512×18×2＝18432字节（当然，这是用calc.hrb计算的哟！……笑），因此0x28c99 / 18432＝9个柱面。

什么！只要9个柱面就够了吗？！真奇怪，当初明明是因为10个柱面不够用我们才特地抛弃了ipl10.nas改用ipl20.nas的呀？哦，对了，我们用tek对nihongo.fnt进行了压缩，因此大幅度减少了容量，真开心呀。那我们将ipl10.nas还原回去就好了呢，这样启动时间就只有现在的一半了。

不过且慢，0x28c99 % 18432＝1193字节（求余数运算用calc.hrb也可以轻松搞定，真方便），也就是说，如果我们能再将文件容量缩减1KB左右，就可以将读取的范围缩小到9个柱面了，这样一来启动时间又可以缩短一成。好，我们加油试试看，有什么好办法呢？啊，有了，我们将ipl20.nas也用tek压缩一下就好了呢！如果可以减小3个扇区的话，ipl09.nas就足够了。

■■■■■

嗯，既然要做ipl09.nas的话，不如顺便对磁盘读取做个优化。这里所说的优化，是将AL = 1这样逐个扇区读取的方法，改为同时读取多个扇区（参见3.1节和3.3节）。至于这种优化是否会带来速度上的提升则是因人而异的。在大部分内置软驱的电脑上，逐个扇区读取的速度可能已经相当快了，优化之后速度也不会有什么提升。不过像笔者这样使用USB1.1外置软驱来启动的话，优化之后大约可以比原来的速度提高10倍左右。

ipl09.nas节选

; haribote-ipl

; TAB=4



CYLS EQU 9 ; 要读取多少内容



; （中略）



; 读取磁盘



MOV AX,0x0820

MOV ES,AX

MOV CH,0 ; 0柱面

MOV DH,0 ; 0磁头

MOV CL,2 ; 2扇区

MOV BX,18*2*CYLS-1 ; 要读取的合计扇区数 从此开始

CALL readfast ; 告诉读取



; 读取结束，运行haribote.sys！



MOV BYTE [0x0ff0],CYLS ; 记录IPL实际读取了多少内容 到此结束

JMP 0xc200



error:

MOV AX,0

MOV ES,AX

MOV SI,msg

putloop:

MOV AL,[SI]

ADD SI,1 ; 将SI加1

CMP AL,0

JE fin

MOV AH,0x0e ; 显示一个字符的函数

MOV BX,15 ; 颜色代码

INT 0x10 ; 调用显示BIOS

JMP putloop

fin:

HLT ; 暂时让CPU停止运行

JMP fin ; 无限循环

msg:

DB 0x0a, 0x0a ; 两个换行

DB "load error"

DB 0x0a ; 换行

DB 0



readfast: ; 使用AL尽量一次性读取数据 从此开始

; ES:读取地址, CH:柱面, DH:磁头, CL:扇区, BX:读取扇区数



MOV AX,ES ; < 通过ES计算AL的最大值 >

SHL AX,3 ; 将AX除以32，将结果存入AH（SHL是左移位指令）

AND AH,0x7f ; AH是AH除以128所得的余数（512*128=64K）

MOV AL,128 ; AL = 128 - AH; AH是AH除以128所得的余数（512*128=64K）

SUB AL,AH



MOV AH,BL ; < 通过BX计算AL的最大值并存入AH >

CMP BH,0 ; if (BH != 0) { AH = 18; }

JE .skip1

MOV AH,18

.skip1:

CMP AL,AH ; if (AL > AH) { AL = AH; }

JBE .skip2

MOV AL,AH

.skip2:





MOV AH,19 ; < 通过CL计算AL的最大值并存入AH >

SUB AH,CL ; AH = 19 - CL;

CMP AL,AH ; if (AL > AH) { AL = AH; }

JBE .skip3

MOV AL,AH



.skip3:



PUSH BX

MOV SI,0 ; 计算失败次数的寄存器

retry:

MOV AH,0x02 ; AH=0x02 : 读取磁盘

MOV BX,0

MOV DL,0x00 ; A盘

PUSH ES

PUSH DX

PUSH CX

PUSH AX

INT 0x13 ; 调用磁盘BIOS

JNC next ; 没有出错的话则跳转至next

ADD SI,1 ; 将SI加1

CMP SI,5 ; 将SI与5比较

JAE error ; SI >= 5则跳转至error

MOV AH,0x00

MOV DL,0x00 ; A盘

INT 0x13 ; 驱动器重置

POP AX

POP CX

POP DX

POP ES

JMP retry

next:

POP AX

POP CX

POP DX

POP BX ; 将ES的内容存入BX

SHR BX,5 ; 将BX由16字节为单位转换为512字节为单位

MOV AH,0

ADD BX,AX ; BX += AL;

SHL BX,5 ; 将BX由512字节为单位转换为16字节为单位

MOV ES,BX ; 相当于EX += AL * 0x20;

POP BX

SUB BX,AX

JZ .ret

ADD CL,AL ; 将CL加上AL

CMP CL,18 ; 将CL与18比较

JBE readfast ; CL <= 18则跳转至readfast

MOV CL,1

ADD DH,1

CMP DH,2

JB readfast ; DH < 2则跳转至readfast

MOV DH,0

ADD CH,1

JMP readfast

.ret:

RET ; 到此结束



RESB 0x7dfe-$ ; 到0x7dfe为止用0x00填充的指令



DB 0x55, 0xaa




完工，代码中加入了很多注释，应该没有什么特别难懂的地方了。

■■■■■

哎呀呀，糟糕！我们修改了ipl09.nas之后，为了实现对磁盘读取的优化，结果代码却变长了。和ipl20.nas相比，从2992字节增加到了4081字节。不过大家也不用担心，我们还有tek5压缩呢，压缩之后就变成了1778字节。你看，变小了很多吧。

我们修改一下Makefile，将这个新文件装入磁盘映像，然后“make”，再用二进制编辑器打开生成好的磁盘映像确认一下。唔，貌似数据占用的部分到028898。0x28899 / 18432 = 9个柱面，0x28899 % 18432 = 153字节……什么！居然超出了153字节？！不是吧！

如果在这里乖乖就范，换回ipl10.nas的话也太憋屈了，于是我们可以抛弃其中一个应用程序，比如sosu或者hello之类的。能抛弃的应用程序实在是太多了（苦笑），反而不知道该抛弃哪个比较好了1。呜呜呜！

1 大家可千万别说“这种程序全部丢掉算了”这种话，虽然这个主意挺正确的，但实在是太“残忍”了。这些应用程序中可满载着这些日子我们开发工作中所留下的回忆啊！

既然如此，我们就下定决心，一定要在一个都不能少的前提下，解决这个问题。唔，到底怎么办才好呢……有了！我们将invader.hrb修改一下，如果不用sprintf函数的话，程序就可以变小了！

■■■■■

invader.c中只有一处调用了sprintf，因此修改起来也很简单，首先替换下面一句：

sprintf(s, "%08d", score); → setdec8(s, score);




然后再添加下面这个函数：

本次的invader.c节选

void setdec8(char *s, int i)

/*将i用十进制表示并存入s*/

{

int j;

for (j = 7; j >= 0; j--) {

s[j] = '0' + i % 10;

i /= 10;

}

s[8] = 0;

return;

}




这样就完工了，仅通过这一点修改，invader.hrb就从2335字节变成了1509字节，大幅度瘦身了，大获全胜！反过来说，sprintf这个函数是如此之大，真是减肥瘦身的大敌呢（笑）。

当然，修改了之后的invader.hrb运行起来不会有任何变化，不信的话可以“make run”试试看哦。

■■■■■

修改完成之后，我们再重新“make”一下磁盘映像，并用二进制编辑器打开看看，数据占用的部分到028498。0x28499 / 18432 = 8个柱面，0x28499 % 18432 = 17561字节，正好缩减到9个柱面的范围内，撒花！

到此为止，我们的应用程序编写活动也该告一段落了，我们来总结一下本章的成果吧。

invader.hrb......1509字节：外星人游戏

calc.hrb......1668字节：命令行计算器

tview.hrb......1753字节：文本阅览器

mmlplay.hrb......1975字节：MML播放器

gview.hrb......3865字节：图片阅览器

看起来从上到下文件的大小是在不断递增的呢。虽然很有趣，不过这只是个巧合啦。

最后我们来一张纪念截图吧。



大家来拍个全家福





6　光盘启动（harib27f）

到现在，我们的“纸娃娃系统”就已经正式完工了。可能有人觉得软盘读取速度太慢，如果能从光盘启动就好了。为此，笔者在这里给大家一些建议。

http://www.geocities.co.jp/SiliconValley-Cupertino/3686/fdtoiso.html

从上面的网址下载fdtoiso_gui.lzh，解压缩之后运行里面的fdtoiso.exe，会弹出一个窗口，将haribote.img拖进窗口中，点击“进入ISO映像生成画面”，就可以很容易地生成光盘用的映像文件了。接下来只要将这个ISO映像刻录到CD-R或者CD-RW上面就可以了。

当然，你的电脑也必须支持从光盘启动才可以哦。

在这里，十分感谢这个软件的作者（虽然不知道他的名字）为我们提供了如此方便的软件。

■■■■■

如果你觉得光做个能启动的光盘还不过瘾，希望这张光盘在Windows或者Linux中读取的时候还能显示里面的文件内容的话，笔者推荐下面这个工具。

http://cdrtfe.sourceforge.net/

在此对本软件的作者kerberos002表示感谢。

将cdrtfe软件安装好之后，启动该软件，从菜单中选择“Extra - Language – Chinese （simplified）”即可将软件界面切换成简体中文。

点击“文件系统”按钮，将“引导光盘”中的“制作引导光盘”选项打勾，点击“引导镜像”旁边的“浏览”按钮，选择haribote.img文件并确定，然后将准备好放进光盘的其他一些文件和文件夹拖到软件的窗口中，点击“开始”按钮就可以开始刻录了。如果不想刻录光盘，只生成ISO映像文件的话，可以点击“光盘选项”按钮，点击“使用镜像”旁边的“浏览”按钮，选择要保存ISO映像文件的位置和文件名，勾选下面的“只生成镜像，不刻录”选项，确定，然后再点击软件主界面中的“开始”按钮，就可以生成指定的ISO映像文件了。

这个软件的选项非常丰富，功能也很强大，大家在掌握了基本方法之后可以自己多做一些尝试。此外，还有一些光盘刻录软件也具备类似的功能，大家如果有已经非常熟悉的软件，也可以使用它们来创建可用来启动电脑的光盘。

好，今天的内容就到这里啦，大家晚安。





第31天　写在开发完成之后



继续开发要靠大家的努力

关于操作系统的大小

操作系统开发的诀窍

分享给他人使用

关于光盘中的软件

关于开源的建议

后记

毕业典礼

附录





1　继续开发要靠大家的努力

到昨天为止，我们为期30天的操作系统开发工作终于落下帷幕了。30天的时间说短不短，说长也不长，大家是过得开心呢，还是已经累到不行了呢？笔者觉得，一个菜鸟只用30天的时间，就能取得出相当不错的成果，还是非常值得高兴的一件事。对于那些觉得30天太长太累的读者来说，是不是也能感到“操作系统开发其实没有想象中的那么难”呢？没错，确实没有那么难哦。

如果觉得这些内容还不过瘾，请一定要继续开发下去。之前都是笔者一个人在唱独角戏，从现在开始，各位读者就是舞台上的主角。笔者非常期待看到并认真学习大家的作品呢（笑）。说到继续开发，也不一定要从“纸娃娃系统”最后的harib27e开始，把之前的基础全部推翻重来也可以，用Linux或FreeBSD等开源操作系统为基础进行改造也完全没有问题。

■■■■■

如果可以再多给笔者一点时间的话，在harib27e之后还要做些什么呢？笔者想首先开发一个关于鼠标点击的API，有了这个，我们就可以编写出类似扫雷、纸牌这样的游戏了。鼠标API有半天的时间就可以编写出来了。

接下来，可以实现对非矩形窗口的完全支持，增加有透明色时专用的refresh，然后再增加一个不自动绘制窗口标题栏的模式。只需这样，我们就可以绘制出各种有趣形状的窗口。要实现这个功能，只考虑API的话仅半天就够了。

壁纸功能也比较简单。不过要实现壁纸功能，需要先实现读取图片文件的功能。这就需要将相当于gview.hrb的内容移植到操作系统中去。在画面下方的任务栏中显示窗口的信息，并用鼠标切换，也会相当有趣。这两个功能加在一起，大概用一天的时间可以完成。

再接下来要开发的，还有向磁盘进行写入的功能。如果实现了不依赖BIOS的磁盘写入功能，再稍加改造就可以顺便实现磁盘读取功能，这样一来就不需要在系统启动时将所有文件装入内存，启动时间也可以变得更短，也不需要每次特地去调整IPL了，真是一箭三雕呢。这项改造如果依照本书的格式来撰写的话，大约需要3天的时间。

一旦实现了对文件写入的支持，那么后面可以做的东西就相当丰富了，比如可以编写文本编辑器，还有类似“画图”的图片编辑软件等。有了文本编辑器，我们就可以直接在“纸娃娃系统”中编写MML文件并立即播放了。假如移植了C语言编译器、nask以及连接器，就可以在“纸娃娃系统”中编写应用程序并立即运行了。如果真能做到这一步，那么连在“纸娃娃系统”中对“纸娃娃系统”本身进行make也不再是痴人说梦了，真是想想就觉得心潮澎湃呢。

再更进一步说，如果可以支持硬盘和存储卡的读写并支持网络，能做的事情就会更多了。还可以增加对虚拟内存的支持，使操作系统可以使用比实际的物理内存更多的内存空间。命令行窗口也可以扩展一下，比如增加重定向功能（即不将信息输出到画面上，而是写入文件中）等，或者实现像Windows资源管理器那样用鼠标来管理文件的功能也不错呢。

■■■■■

除了表面上的改造之外，还可以做一些操作系统内部的完善工作。目前的“纸娃娃系统”中没有考虑到进行大量处理时内存会不足的情况，如果我们启动很多个gview.hrb将内存消耗光，肯定会出问题的。我们需要采取一些措施，比如在内存空间不足时不允许启动更多的应用程序等。

此外，在mmlplay.hrb演奏的时候，如果移动一个很大的窗口（如“tview –w100 –h30”这么大的窗口），演奏就会变得混乱。这是由于负责窗口移动的task_a的优先级高于mmlplay.hrb所导致的，而思考一下如何解决这个问题应该也挺有意思的（例如将音乐播放的应用程序作为特例提高其优先级，或者创建一个专门移动窗口的任务再对其优先级进行微调等）。

这次我们在编写“纸娃娃系统”的过程中，讲解了使用32位模式的方法、内存段的使用方法、中断的处理方法、内存的管理方法、窗口和鼠标的处理、定时器的管理方法、命令行窗口的原理、API的方式、访问文件的方法，等等。但这些内容并不都是正确答案，其实在编写操作系统的方法上，并没有所谓的正确答案。本书中所讲解的内容，只能算是一个实例而已，大家千万不要被这些条条框框所束缚，请自由发挥自己的想象力，去编写出更优秀的操作系统吧。例如笔者开发的OSASK就很大程度上使用了和“纸娃娃系统”不同的算法，而Linux和Windows所使用的算法又和“纸娃娃系统”以及OSASK不同。

■■■■■

笔者打算在本书的支持网页上征集各位读者所编写的操作系统以及为“纸娃娃系统”编写的应用程序。说是征集，不过也没有什么奖品啦，请大家不要过分期待啦（笑）。对于想让自己的操作系统被大家所知道和了解的人来说，这里提供了一个展示的场所。可以加上几张运行时的截图，还可以加上大家各自主页的链接。





2　关于操作系统的大小

在0.1节中笔者曾经介绍了OSASK的大小只有不到80KB，不过目前完成的“纸娃娃系统”居然只有39.1KB这么小，连笔者都感到很震惊，而且这还是没有经过压缩的大小。在OSASK和Linux中，为了缩短系统的启动时间，操作系统的核心部分都是经过压缩的。我们来简单计算一下，如果“纸娃娃系统”也用同样的方法进行压缩的话，包括解压缩的程序在内，也只要大约20KB左右，差不多是现在的一半。

笔者并没有刻意去将操作系统做得很小，因此这个结果是出乎意料的（当然，应用程序倒是有几次刻意缩减大小的行为，比如创建apilib.lib，将应用程序进行压缩，以及对invader.hrb所进行的修改）。

笔者一直坚持这样一个观点：现在的操作系统都过于臃肿了，如果真要推翻重写的话，肯定能一下子变小很多。也许有人会说，“纸娃娃系统”之所以这么小，是因为它的功能少呀。当然，笔者也不认为像Windows和Linux这样的系统可以用20KB编写出来，不过如果20KB可以实现这样的功能，那100KB应该能实现5倍的功能，1MB的话应该能实现50倍的功能才对。

而且，我们的“纸娃娃系统”是将便于初学者理解这个目的放在首位的，因此并没有使用一些一般开发者会用到的手法。从让编写的程序变得更小这个观点来看，这是一个非常不利的条件。此外们我们还进行了一些优化系统速度方面的改造，这也会增加系统的大小（如定时器、窗口移动速度的提高等）。但即便如此，我们的系统还是只有20KB那么小。

■■■■■

笔者的OSASK大约有80KB，它的小巧曾引起了不少的关注。笔者曾经说过，OSASK就是对现在OS都过于臃肿的最好证明。大部分普通人都可以理解笔者的这一观点，但有一些对编程比较精通的人反驳道：“你是用了很多超出常识的高级技巧，为了让尺寸变小而牺牲了很多东西，并且用汇编语言大量代替C语言1，才让OSASK变得这么小的。”

1 相比C语言，笔者更喜欢汇编语言，因此OSASK的一半都是用汇编语言编写的。

这次我们的“纸娃娃系统”可基本上都是用C语言编写的（只有C语言无法实现的部分才用汇编语言来编写）。当然，也没有使用什么高级技巧（其实笔者根本就不会什么高级的技巧，如果真有那种像魔法一样的技巧，笔者还真想学学呢）。相信读过本书的各位读者都是有目共睹的。通过本书，笔者认为自己的观点更加有说服力了。

■■■■■

操作系统变得更小到底有什么好处呢？启动可以变快些，安装所需容量能变小些，而且可以在硬盘、光盘以外的记录媒体上进行安装（比如软盘和存储卡等）。其实，也没什么特别的好处，不过至少应该也没有什么坏处，比起臃肿的系统来说，应该还是精简的系统用起来要爽一些吧？如果花钱购买的操作系统，或者是花很长时间下载的操作系统，其中一半以上都是没用的，笔者觉得这实在是太可悲了。

同样的观点对于应用程序也适用。笔者认为“纸娃娃系统”的应用程序比Windows和Linux的应用程序都要小2。这是操作系统的功劳呢，还是我们为将应用程序变小所做的努力的功劳呢，好像也说不清楚了。不过，应用程序如果内容相同，那自然是小一些的比较好，既能节约磁盘空间，还能缩短应用程序启动时的读取时间。

2 其实OSASK的应用程序更小，这是因为为了让应用程序变得更小，在API上面下了工夫，这个结果也是理所当然的。比如OSASK的invader.bin为1108字节（invader.hrb为1590字节）。

■■■■■

话说，如果编写一个轻巧的操作系统也算是一种比较优秀的特殊技能的话，那么大家通过这30天应该已经可以体验到了。也就是说，大家已经比普通的初学者（甚至是比普通的程序员？）更加优秀了也说不定哦（笑）。如果这是真的，那这本书说不定能成为名著而大卖特卖呢……（笑）

如果你曾经不知不觉地编写了一些比较臃肿的程序，（从喜欢短小精悍程序的笔者的角度来看的话）若能基于本书的体验加以改善那就太好了。不过这一点和本书的目的（编写自己的操作系统）是没关系的，即便是很大的操作系统或者很大的应用程序，也欢迎推荐到我们的支持网页上来。





3　操作系统开发的诀窍

在这里想跟大家介绍一些操作系统开发的诀窍。在0.3节中也提到了，不要从一开始就想着去做一个操作系统，这一点是非常重要的。还有，遇到不满意的地方，可以过后再来改，甚至是过后全部推翻重来也没问题。从一开始就想做得完美的话，真的可能会寸步难行。

也不要指望能够一次就搞定，推翻重做几次也是很正常的。反正有30天的时间就可以做到现在这样（如果习惯了的话，有两周的时间就足够做到现在这样了，因为我们总不会每次都从helloos开始吧）。在这个过程中，你的能力也在一点点提升。

■■■■■

为你的操作系统设定一个明确而又容易理解的目标也很重要。比如说，“纸娃娃系统”是作为教材编写的，目标就是让初学者能看懂。为了实现“易懂”这个目的，我们可以牺牲一些性能和功能，实用性稍微差一点也没有关系。虽然有些部分若改用汇编语言就可以大幅度提升速度，不过笔者还是放弃了这个念头。如果明确了“什么是最优先的，什么又是可以放弃的”，操作系统的开发就会变得更加顺利。

如果什么都没想清楚就开始开发的话，最后做出来的操作系统就会让人搞不懂开发者的目的。只是做着玩的话，这样也未尝不可，或者说也可以将“做着玩”设定成一个目标吧。这样一来只要享受开发的过程就可以了，用起来有点慢也没关系。当别人抱怨“这个不好用啊”的时候，你就可以堂堂正正地回答说：“嗯，是啊。不过这样也挺好了。”

以提高自己的编程技巧为目的来开发操作系统也不错。如果以此为目标，就尽量不要从其他的操作系统中挪用代码，而是要自己来编写。

上面这些可能有点难懂，其实刚上手也不必太在意目标啦。或者说，在开发的过程中你自然而然地就会发现各种目标。重新做过几次之后（从大约第三次开始）就应该仔细考虑目标了。





4　分享给他人使用

好不容易编写了一个操作系统，想要使用这个操作系统是理所当然的。这个想法很不错，一定要用用看。实际的使用会激发你改良的欲望，你对系统的理解也会相应加深。

更进一步，可能你会想分享给别人使用。不过要做到这一点，有一个障碍是不得不去逾越的，那就是“找到你的系统比其他系统出色的地方”。无论多么小，如果找不到一个比其他系统更好的地方，那别人肯定会想，还不如用Windows或者Linux呢。

笔者开发的OSASK因为运行速度非常快，因此将“在很老很慢的电脑上也可以流畅运行，启动时间很短”作为宣传重点，并找到了一些愿意使用它的人（不过笔者觉得OSASK也不一定要让别人来使用，因此即便找不到愿意使用的人也不会觉得遗憾）。

即便操作系统本身没什么亮点，如果能开发出好玩的应用程序（比如游戏）也不错，“如果要用这个应用程序就只能用我的操作系统哦！”想想看这方法似乎有点不太厚道，不过从操作系统的的历史来看，这可以算是最常用的一种推销手段了（笑）。

只要逾越了这个障碍，找到愿意使用你的操作系统的人，那么你的用户一定会发邮件来鼓励你的。如果是商业销售的话，收益也会跟着水涨船高吧。





5　关于光盘中的软件

光盘中project/目录中的文件是教材用的操作系统，按照0.7节中的声明，大家是可以随意使用的。这种使用方法对与tolset/目录中的大多数文件也是适用的。在这里我们将不适用于KL-01许可协议的软件列出来，也就是说，没有在这里列出的软件都适用KL-01协议。

文　件　名 许可协议 发布地址

cc1.exe GPL http://wiki.osask.jp/?downloads/dev (go_0020)

cpp0.exe GPL http://wiki.osask.jp/?downloads/dev (go_0020)

ld.exe GPL ftp://ftp.gnu.org/gnu/binutils/ (2.13)

make.exe GPL ftp://ftp.gnu.org/gnu/make/ (3.79.1)

upx.exe GPL http://upx.sourceforge.net/ (1.25w)

t5lzma.exe LGPL http://k.hideyosi.com/tk5lgpl1.lzh

qemu/qemu.exe LGPL http://fabrice.bellard.free.fr/qemu/ (0.6.1)

qemu/bios.bin LGPL http://fabrice.bellard.free.fr/qemu/ (0.6.1)

qemu/SDL.dll LGPL http://fabrice.bellard.free.fr/qemu/ (0.6.1)

GPL是“The GNU General Public License”（GNU通用公共许可协议）的缩写，在这里可以查看协议的中文翻译版本1：

http://wiki.linux.org.hk/w/GPLv3

1 值得注意的是，所有该协议的中文版都不是GNU官方翻译的版本，GNU官方发布的该协议语言只有英语、阿拉伯语、加泰罗尼亚语和德语4种版本，GNU官方协议文本请参见：http://www.gnu.org/licenses/gpl.html。——译者注

简单概括一下，就是说如果对以GPL协议发布的软件进行了修改，那么修改之后的产物也必须以GPL协议来进行发布（但这并不是说只能免费发布），而且源代码也必须公开。如果未经修改而只是单纯地转载发布的话，必须要明示其原始发布地址。如果将以GPL协议发布的软件的一部分或者全部用于自己开发的程序中，该程序也必须以GPL协议进行发布（当然源代码也需要公开）。不过修改和引用完全是私人行为，如果不公开其可执行文件的话，源代码也不必公开。以GPL协议发布的软件是无保障的，因使用该软件所造成的损失，不能向软件作者索取赔偿。

■■■■■

LGPL是“The GNU Lesser General Public License”（GNU较宽松通用公共许可协议）的缩写，在这里可以查看协议的中文翻译版本2：

http://www.thebigfly.com/gnu/lgpl/lgpl-v3.php

2 值得注意的是，所有该协议的中文版都不是GNU官方翻译的版本，GNU官方发布的该协议语言只有英语、加泰罗尼亚语和德语3种版本，GNU官方协议文本请参见：http://www.gnu.org/copyleft/lesser.html。——译者注

LGPL相较于GPL只有一点不同：将以LGPL协议发布的软件的一部分或者全部用于自己开发的程序中时，不伴随协议的强制性和公开的义务。LGPL协议主要是为库而准备的，只是引用了一个库没有必要强制发布协议。不过，如果对库本身进行了修改，则修改后的库必须以LGPL或者GPL协议进行发布。

■■■■■

至于以KL-01协议发布的文件，无论怎么修改都是OK的，也没有必须将修改产物的源代码公开或者必须以KL-01协议进行发布之类的规定，大家可以随意使用。当然，它们同样是无保障。

■■■■■

本书附送的光盘里面还有很多剩余空间，因此笔者在omake/目录中塞了很多东西（其实是现在才打算要塞进去）。在写书稿的时候，还没有想好到底要放点什么东西进去，笔者会在omake/omake.txt中做出说明。不过剩余空间实在是太多了，肯定没办法全部填满，不好意思。





6　关于开源的建议

在这里想说说顺利完成操作系统和应用程序开发之后应该做什么。在软件的发布上，大概有三种方法。

第一种方法是做成软件包，或者以共享软件的方式出售。这样做如果顺利的话会怎么样呢？你也许会变得很有钱，可能靠这份收入可以维持生计，也可能雇佣开发人员，使事业得到进一步的发展。一般来说，开发操作系统花不了多少钱，比如这个“纸娃娃系统”的成本，除了笔者的生活费以外，再就是电脑的电费之类的。所以说操作系统也许还是能维持稳定的经营。话说，这种情况好像也不必多费口舌，大家自己应该可以想象出来。

第二种方法是作为自由软件来发布。可以做一个网站，把软件放在上面供大家下载，也可以发布到专门的软件下载门户网站上面。有人会说，“这样不就挣不到钱了吗？”基本上就是挣不到钱的，因为这样做的目的本来就不是为了挣钱。这样的软件只要想用的人就可以免费下载使用。

最后一种方法就是以开源方式发布。所谓开源并不仅仅是公开了源代码就可以了，而是必须认可对源代码进行修改并作为自己的作品进行发布的行为。只能看我的源代码，但是不准模仿，或者可以拿来修改但必须经过作者的允许才能发布等等之类的，都不能算作是开源。

开源还有一个条件，那就是必须认可再次发布的自由。也就是说，你不能因为人家复制了你的软件放在其他网页上供人下载而生气。比如“只能从我自己的主页才能下载哦”，“由于想要正确统计下载数量而禁止再次发布哦”之类的话是不能说的。KL-01以及GPL、LGPL都是为开源软件而制定的许可协议。

■■■■■

无论是自由软件也好还是开源软件也好，并不是说就完全不能用来盈利。你可以宣布“下个月开始停止免费下载，改成在商店里面出售”之类的。不过如果是开源软件的话，因为拥有再次发布的自由，已经下载过软件的人在自己的主页上发布出来，半价销售跟你竞争的话，你也无话可说。如果不希望变成这样，那最好从一开始就不要选择开源。如果是自由软件，那只要在文档中写明禁止再次发布，将来想改成收费软件的时候就可以放心了。

如果想要半路出家改成收费软件，为了吸引之前下载过免费版的用户来购买，可以使用增加一些功能、发布升级版的方法，而之前的免费版可以作为试用版继续提供免费下载。用这种方法可以不用过于担心再次发布的问题，也同样适用于开源软件。不过话说回来，开源软件由于公开了源代码，那实际上是保证了修改的自由，可能会有人做出比你的商品版更好的软件，然后用来出售或者免费发布。

因此，如果选择以开源方式发布软件的话，将来想要转为付费方式就比较困难了。

■■■■■

看上去弊端很多的开源方式，其实也有好的一面。如果用户跟你抱怨“请加上一个○○的功能吧”、“××功能没什么用啊，去掉吧”、“bug太多了，帮帮忙”之类的话，你可以说：

“这个是开源软件，请自己修改好了（笑）。

这就是开源软件最大的好处。

如果作为商品出售的话，用户可能会抱怨说，“有○○这样的功能是理所当然的啊，你这个软件居然没有，太过分了，退钱！”如果是自由软件虽说不会被要求“退钱”，但用户可能会说：“我已经请求了很久了，为什么还没加上这个功能呢？什么，你说有意见的话自己从头开发一个类似的软件好了？这也太过分了吧，你是作者，只要改几行代码再重新make一下就好了啊……”。但开源的话就不会有这样的问题啦。

尤其是当你只是凭兴趣编写了一个小软件，发布之后即便引来一大堆抱怨也不希望会过于占用自己的时间，这个时候开源是很适合你的。即便很久之后服务器不能继续工作了，也会有人帮你再次发布出来，你也不会因此而受到过多的指责。甚至也许在不经意间，你的软件已经渐渐流传开来，并有人进行了各种改良，然后你意外地发现已经有很多人在使用它了。

■■■■■

而且，开源的话，会有很多人“误以为”“这个作者好大方”，于是你会多出许多朋友，搞不好还会被人尊敬。朋友和尊敬可是用钱买不到的。当然，如果你是高帅富也可能会有很多朋友，也可能会赢得尊敬，但万一你遭灾变得贫穷时，朋友和尊敬可能也会随之烟消云散。啊，真正的朋友屈指可数，真是人生无常啊。但是，由开源而赢得的朋友和尊敬，如果你真破产了，他们反而会变得更加支持你。啊，那个家伙已经身无分文了，居然还将自己的软件开源呢！（笑）

而且，这种事是会上瘾的。因一次开源而成名之后，以后就会只想用开源方式发布软件了。这样可不行，真的会破产的。因此，好孩子可千万不要玩开源哦。喂，那啥，这哪里是在推荐大家开源啊！（笑）

■■■■■

话说，如果你一直努力做开源软件，在你的朋友中间可能会有人帮你介绍一份好工作，请你到大学里面演讲，或者明明实力一般却意外地出了名，获得自己写书出版的机会。其实这只是笔者的情况而已，不知道是不是所有人都能走这条路。笔者觉得只是自己运气比较好罢了，可不敢打包票哦。

如果大家选择用开源方式发布自己的软件，以后有机会一定要和笔者一起出席“开源大会”哦。笔者会出席OSASK的展位，如果各位读者能在旁边的展位一起展示你的开源软件，那真是再好不过的事了。

开源大会是日本开源软件界的盛会1，每年在东京举办两次，在北海道和冲绳举办一次，详细请参见以下网页：

http://www.ospn.jp/

1 中国也举办类似的开源大会，详细信息可以参见“中国开源软件推进联盟”： http://www.copu.org.cn/。——译者注

关于开源就介绍到这里。对于自己所开发的软件，如果是有偿销售或者是作为自由软件发布，可能大家比较容易想象，而开源的发布方式可能大家不是很熟悉，因此才在这里专门详细介绍了一下。

开源有开源的好处，也有其独有的乐趣，但开源也不是万能的，如果你选择自由软件或者有偿销售的话都是完全OK的。请大家深思熟虑，找一个最贴近目标的方式来发布自己的软件吧（当然，不想发布的话也是OK的啦）。无论如何，笔者都会支持大家的。





7　后记

后记，或者叫涂鸦吧，反正凡是关于这本书的话题，都可以随便写写。

从哪里开始写呢？就从这本书的封面开始写吧。书的封面是很漂亮的绿色，这个绿色是笔者提议的，代表鲜嫩的叶子。初学者就像是嫩叶一样，而且笔者很喜欢森林浴，感觉这种看上去很环保的颜色，和非常强调HLT重要性的本书也挺搭调的。

封面中间还有只猫，其实那不是猫，而是有两条尾巴的一种日本传说中的妖怪——猫又，在本书的漫画中也经常登场。它是OSASK的吉祥物，也是“纸娃娃系统”的吉祥物，名字叫做“卡奥斯”，昵称叫“小卡”，大家请多关照……喂，话说怎么到了后记才介绍人家啊！

■■■■■

笔者努力将这本书写成一本初中生也能看懂的书。笔者自己也是从初中的时候开始萌发要编写一个操作系统的念头的，因此在这本书的内容安排上是以当时的自己也能看懂为基准的（话说，其实笔者当时并没有能够编写出操作系统）。

在本书中，笔者尽量避免使用晦涩难懂的语言，对英语单词也进行了适度的解释。其实编写操作系统本来也不需要什么高深的知识。即便你不会解数学方程式，不会用英语对话，不知道历史上的重要人物，不知道如何使用敬语1，不知道原子的名称，你都可以毫无障碍地编写出操作系统。因此，笔者没有刻意去圈定对象读者，而是以让所有想要编写操作系统的人都能够看懂作为写这本书的目的。

1 日语中有严格的敬语体系。当对方为长辈、上级、合作伙伴时须使用敬语。——译者注

另一方面，笔者也努力让大学生和成人读者不至于觉得这本书太幼稚。笔者觉得自己应该是找到了这么一个平衡点，如果各位读者也有同感那就再好不过了。

■■■■■

笔者觉得编程相关的书都卖得比较贵，当然，考虑到读者的数量，这个价格也无可厚非，请大家不要埋怨出版社（如果出版社亏损倒闭的话那情况会更糟糕）。不过，笔者想让这本书能让初中生也买得起，因此拜托了一些有关的朋友，让他们把价格定得低一些。我不知道对现在的初中生来说，如果不等到过年发压岁钱的话，这个价格他们是否能够承受，如果不行的话可以让图书馆购买，学生只要到图书馆去借就可以了。如果这个价格让你觉得还可以承受，那么请对出版社和那些有关人士的努力表示感谢吧。

如果笔者是一个很有名的作者，出版社对书的销量有信心的话，可能会定一个比较有挑战性的价格，但其实这本书是笔者写的第一本书，出版社也基本上是赌了一把。这么想的话觉得自己的要求确实有点任性，在这里说声抱歉了。

可能有的读者觉得这本书页数太多，太重了。其实当初也考虑过分成上下册，甚至是分成1～4册，但结果发现合并成一册最便宜，于是就这样愉快地决定了。这本书的内容属于先苦后甜的类型，如果分成上下册，有些读者只看了上册觉得未来一片黑暗，可能会失去继续阅读的兴趣，这也是合并成一册出版的理由之一。如果一定要分成几册的话，那只能麻烦大家自己用切割机把书给切开了。

这本书从开始到读完差不多真的需要30天左右，因此把这本书的价格除以30的话，说不定就会觉得“平均每天只要花3.3元啊，真划算”。虽然不如RPG（角色扮演游戏）那样好玩，不过你可以想象一下屏幕后面不是你的分身，而就是你自己，在不停地升级。这么说感觉好像在跟大家推销似的（笑）。那就再说说相反的情况，一本不便宜的书，买了之后觉得后悔的话那真是太伤心了，因此请大家听听读过这本书的人的感想，或者先试读一部分，仔细考虑之后再购买。也可以跟同样的价钱能买到的别的东西（比如可以买几根巧克力棒之类的）对比一下，考虑考虑买了对你是不是有价值。不过这种话写在最后好像没什么意义了嘛，如果看到这里的应该是已经买了吧……

作为笔者来说，已经在内容的充实方面做了很多努力。既然定价的调整是有限度的，那么如果能让内容的质量提高到原来的两倍，就相当于价格降到了一半。虽说这本书还远远没达到两倍的标准，但笔者确实已经尽了自己最大的努力。

■■■■■

讲解的长短以及整体的节奏也是经过仔细调整的，如果加快节奏，以笔者的能力恐怕会讲不清楚。如果把本书这些内容两天并作一天来写的话，用15章的篇幅就可以搞定了，但各位读者当中一定会有人消化不良的。

光看本书的书名“30天自制操作系统”，对于毫无操作系统相关知识的人来说，可能会觉得“什么嘛，居然要30天那么长啊”，笔者也知道30天有点长，但以现在的节奏，到第20天就结束的话，感觉实在是很可惜（不信的话可以看看第20天时的样子……我们刚刚开始编写API呢），想想看仅仅多了10天的内容，我们的系统就变得好玩多了。如果在第10天或者第15天收尾就更无法接受了，完全体现不出编写操作系统的乐趣。

反过来说，如果我们将开发周期延长到40天或者50天，那一定能做出更有意思的系统。不过笔者的体力实在是支撑不了，好想休息一下呀。况且如果书名变成《50天自制操作系统》，估计各位读者更要敬而远之了吧。

对于操作系统，笔者有很多自己的观点，其中之一就是操作系统应自带文件压缩功能。但这个观点并未成为操作系统界的常识，因此笔者也就没有过多地讨论，而是在29.2节中，仅以缩小字库文件大小为目的加入了压缩功能，关于压缩对操作系统的重要性也只字未提。

若操作系统自带压缩功能是常识，笔者就会在29.2节中，从构思基本算法开始，对tek压缩进行详细的介绍，或者说是十分想向大家介绍。很遗憾，我们的篇幅有限，无论如何也无法在这本书中展开这个话题。

笔者对于操作系统的这些观点，大部分都在OSASK中有所体现，但在本书的撰写过程中，却尽量避免将这些观点流露出来，也没有将OSASK搬出来，跟大家吹嘘“怎么样，这个功能也有哦，很厉害吧”之类的，因为这样做一点意思都没有。笔者不想给大家强加先入为主的观念，而将大家好不容易冒出来的好点子给扼杀掉。

因此，笔者只向大家介绍编写操作系统的技术，并希望各位读者能自由发挥想象力，开发出各种各样不同的操作系统。如果大家开发出来的操作系统都像OSASK的克隆一样，那自制操作系统的世界也就没有进步，变得相当无聊了。

■■■■■

临近收尾，预定的截稿日一拖再拖，实在是给编辑添了不少麻烦，笔者能力有限，实在抱歉。另外，对于出版社能够听取笔者的建议，也表示衷心的感谢。

在这里，还要向临近考试还参与本书校对的初中生读者代表DAsoran同学、高中生代表uchan同学，以及对本书做出很多客观诚恳指摘的成人读者代表若生启表示感谢。

还有为本书绘制插图以及制作各种示意图的hideyosi，真是帮了大忙，在此表示感谢。

还要感谢OSASK社区的各位成员。在这一年多的时间里，为了撰写这本书，而中断了OSASK的开发，在此期间，虽然有些抱怨，但大家还是坚持了下来。归根结底，也是承蒙社区各位成员的厚爱，便OSASK一举成名，笔者才能有机会出版本书。

当然，最要感谢的是现在正在读这本书的你，谢谢。

■■■■■

哎呀，再多说几句。如果各位想给笔者发邮件，请发送到下面的邮箱2：

Hidemi KAWAI <kawai@osask.jp>

2 请发送到下面的邮箱：在某些文档中，笔者的邮箱可能写的是这个：kawai@imasy.org，这个地址现在已经不用了，因此请不要发到这里。

不过，笔者不能保证对收到的来信一一回复。如果是提问或者感想的话，请尽量到支持网页的论坛中发帖，这样的话，笔者之外的人也可以看到以及回帖，应该可以更快地得到有用的回答。

如果想给笔者发私人邮件，回复慢了或者收不到回复也无所谓的话，那么请发到上面的邮箱吧。

COLUMN-12　这也能叫自制操作系统？太坑爹了！（以下内容不是面向初学者的）

说到编写操作系统，难道不该先从应该编写一个怎样的操作系统开始讨论吗？要编写多任务操作系统，如何解决访问冲突难道不是最重要的吗？连文件系统都没有设计怎么能算是自制操作系统啊！根本没有考虑设备驱动程序的问题嘛！内存不足时的处理实在是不够完善啊！窗口系统也太粗糙了点吧？中断处理的少许优化、窗口移动的加速、加入压缩功能之类的，都不算是操作系统中本质的部分，难道不该减少这部分内容的篇幅，将重点更多地放在操作系统的本质上吗？如果操作系统都照这样来做，那世上的操作系统得有多不靠谱啊！

且先不论自制操作系统这个主题，想要找点这本书的好处难啊。作为汇编语言的入门吧，对于指令的讲解也太少了；作为C语言的入门吧，对语法的讲解又不充分；作为算法的入门吧，还需要介绍很多其他的东西才行。无论哪个都是只有半瓶醋，没什么用处。这种对操作系统大小的过度追求，对编程初学者来说难道不是有害的吗？

像上面这种质疑的声音是肯定会有的，没错没错，你说得对，这本书的确有上面这些不足之处。不过，笔者在写这本书的时候，可并不是对这些不足一无所知的哦（关于操作系统大小的那一点，笔者认为是有益而不是有害的）。

■■■■■

“从失败中学习”是贯穿本书的一个理念。当然，一开始在什么都不知道的情况下，也谈不上失败，因此笔者就先单方面地进行一些讲解，而随着内容的进行，我们一般是先随便做一个版本，然后发现这个版本的缺陷之后再进行改良。因此，可能你看到“纸娃娃系统”在访问冲突方面考虑不周，其实笔者是故意这样做的。有更多篇幅的话，就可以利用访问冲突让“纸娃娃系统”崩溃一次，然后再引出改良的话题。

或者说，笔者正是因为清楚这些不足才希望各位指教。如果你能指出其中的不足，而且可以提出对策的话，那笔者就可以直接将这些对策告诉各位读者了。也就是说，你可以为这本书来撰写续篇了。所以别客气，请多多指教吧。

■■■■■

当然，这个“从失败中学习”的理念恐怕也会遭到一些质疑吧。如果不经过这些失败的例子，从一开始就条理清楚地讲解各个功能的必要性，整个篇幅就可以缩短，最终的操作系统完成度也会提高，大概有15天左右就可以达到现在的完成度了吧。可是那样的讲解到底效果如何呢？是不是能通俗易懂呢？用算术来举例，我们不要一上来就介绍乘法运算，而是先用反复的加法运算先凑合一段时间，等实在觉得太麻烦受不了的时候，再介绍乘法运算，这样一下子就可以感受到乘法运算的便利，也就更有动力去背九九乘法表了。

对这本书的标题感兴趣的读者，一定都曾经萌发过编写操作系统的念头吧。因此凡是可能会对读者的兴趣产生不利影响的东西，笔者都尽量避免。在使用汇编语言时，尽量减少所使用指令的种类；对C语言的语法并非完全讲解，而是仅限于其中容易理解的部分（或者说是不用的话反而会变得更难懂的部分）。

对于笔者来说，这的确是颇具挑战性的。“纸娃娃系统”到底能用多简单的语法实现丰富的功能，这是个挑战；到底能用多简单的知识就能完成一个操作系统，也是一个挑战。大家可能也不止一次会想，在某些地方使用更高级的命令会更好。笔者也想过在某些地方使用一些高级的算法，也想过为了本书的读者将来能读懂其他程序而对C语言一些其他的语法进行讲解，但是这些笔者都没有做，因为一旦开始这样的话题，可能就没完没了了。

■■■■■

本书的主旨就是要让本来很难的东西看上去变得很容易。只要看上去很容易，读者就会在基本理解的基础上有动力继续读下去（有些无法实际感受到的东西也不是很重要，只要基本上理解了就没有问题），读到后面发现前面的东西其实并没有完全理解，这时只要再翻回前面看看就可以了。如果本来就很难的东西，还要用很难的方式去讲解，那读者马上就会厌倦的，因此笔者尽量避免出现这种情况。

当然，把本来简单的东西搞得很复杂，那就更不应该了。

在内容的先后上笔者也花了心思。从操作系统的重要功能开始做，这种观点对于本书来说是不成立的。本书是从简单的、好看的、效果容易理解的、有成就感的、而且是对操作系统有必要的部分开始，逐步进行开发的。因此，可能会出现一些不太寻常的东西。例如为了介绍操作系统的核心，从一开始就引入了bim2hrb.exe，其实这个工具是应用程序用的连接器。也就是说，本来应该在编写应用程序的时候才引入bim2hrb.exe的，但我们却在一开始几乎不加说明地引入了bim2hrb.exe。另外，在本书中根本没有操作系统用的连接器，这也是在内容上花了心思的结果。

在编写“纸娃娃系统”的过程中，有很多涉及对速度进行优化的内容，现在想想看，其中有一些内容感觉不是非常有必要。不过，在撰写那些章节的时候，考虑到这个算法在以后还可以派上别的用场，因此附带提一提。另一方面，其实优化速度本身在某些情况下还是相当重要的。如果因为没有优化而造成速度很慢，读者可能会误以为“果然初学者做出的系统，速度没办法达到像Windows和Linux那样实用的程度”，从而影响了开发的斗志。

■■■■■

嗯，就说这么多吧，如果无法接受这些观点也没关系，但希望大家在批判前能理解笔者的想法。





8　毕业典礼

/* 《友谊天长地久》苏格兰民谣1*/



$E"SJIS"; T100L4O4



$K"ほたるのひかり まどのゆき"; CF.F8FAG.F8GAFFA>CD2&D8R8

$K"書(ふみ)よむつき日 かさねつつ"; DC.

$K"いつしか年も すぎのとを"; DC.DC.CD2&D8R8

$K"あけてぞ　けさは　わかれゆく"; DC.


1 这里和30.3节的情况相同，如果大家没有将日文显示改造成中文显示，则还是要使用日文歌词才能在应用程序中正常显示出来。这首歌是苏格兰民谣，在日本的中小学毕业典礼上经常会演唱，中文版就是大家所熟悉的《友谊地久天长》。——译者注





9　附录

这本书如果按顺序读下来的话应该还是一本不错的书，不过在读过一遍之后，忽然想知道关于某个知识点是在哪里讲解的，找起来可就麻烦了。此外，如果对于某个函数的写法不太理解，想找到这个写法是在哪个章节提到的，就更加麻烦了。

因此，我们在这里提供了一个简单的函数索引。它是在bootpack.h和apilib.h的代码中加上注释所构成的，通过这个索引，就可以追溯到某个函数是在哪个章节进行过修改了。

bootpack.h

/* asmhead.nas */

struct BOOTINFO { /* 0x0ff0.0x0fff */ /* 5.2, 6.3, 18.7 */

char cyls; /* 引导扇区读取到磁盘的哪个位置 */

char leds; /* 引导时键盘的LED状态 */

char vmode; /* 显卡的颜色位数 */

char reserve;

short scrnx, scrny; /* 画面分辨率 */

char *vram;

};

#define ADR_BOOTINFO 0x00000ff0

#define ADR_DISKIMG 0x00100000



/* naskfunc.nas */

void io_hlt(void); /* 3.9, 4.6 */

void io_cli(void); /* 4.6 */

void io_sti(void); /* 4.6 */

void io_stihlt(void); /* 4.6 */

int io_in8(int port); /* 4.6 */

void io_out8(int port, int data); /* 4.6 */

int io_load_eflags(void); /* 4.6 */

void io_store_eflags(int eflags); /* 4.6 */

void load_gdtr(int limit, int addr); /* 6.4 */

void load_idtr(int limit, int addr);

int load_cr0(void); /* 9.2 */

void store_cr0(int cr0); /* 9.2 */

void load_tr(int tr); /* 15.1 */

void asm_inthandler0c(void); /* 22.2 */

void asm_inthandler0d(void); /* 21.5, 21.6 */

void asm_inthandler20(void); /* 12.1, 21.4, 21.6 */

void asm_inthandler21(void); /* 6.6 */

void asm_inthandler2c(void);

unsigned int memtest_sub(unsigned int start, unsigned int end); /* 9.2, 9.3 */

void farjmp(int eip, int cs); /* 15.3 */

void farcall(int eip, int cs); /* 20.4 */

void asm_hrb_api(void); /* 20.8, 21.4, 21.6 */

void start_app(int eip, int cs, int esp, int ds, int *tss_esp0); /* 21.4, 21.6 */

void asm_end_app(void); /* 22.3 */



/* fifo.c */

struct FIFO32 { /* 13.4, 16.2 */

int *buf;

int p, q, size, free, flags;

struct TASK *task;

};

void fifo32_init(struct FIFO32 *fifo, int size, int *buf, struct TASK *task); /* 13.4, 16.2 */

int fifo32_put(struct FIFO32 *fifo, int data); /* 13.4, 16.2, 16.4, 16.5 */

int fifo32_get(struct FIFO32 *fifo); /* 13.4 */

int fifo32_status(struct FIFO32 *fifo); /* 13.4 */



/* graphic.c */

void init_palette(void); /* 4.6, 25.2 */

void set_palette(int start, int end, unsigned char *rgb); /* 4.6 */

void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1); /* 4.7 */

void init_screen8(char *vram, int x, int y);

void putfont8(char *vram, int xsize, int x, int y, char c, char *font); /* 5.4 */

void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); /* 5.6, 28.5, 28.6, 28.7 */

void init_mouse_cursor8(char *mouse, char bc); /* 5.8 */

void putblock8_8(char *vram, int vxsize, int pxsize, /* 5.8 */

int pysize, int px0, int py0, char *buf, int bxsize);

#define COL8_000000 0

#define COL8_FF0000 1

#define COL8_00FF00 2

#define COL8_FFFF00 3

#define COL8_0000FF 4

#define COL8_FF00FF 5

#define COL8_00FFFF 6

#define COL8_FFFFFF 7

#define COL8_C6C6C6 8

#define COL8_840000 9

#define COL8_008400 10

#define COL8_848400 11

#define COL8_000084 12

#define COL8_840084 13

#define COL8_008484 14

#define COL8_848484 15



/* dsctbl.c */

struct SEGMENT_DESCRIPTOR { /* 5.9, 6.4 */

short limit_low, base_low;

char base_mid, access_right;

char limit_high, base_high;

};

struct GATE_DESCRIPTOR { /* 5.9 */

short offset_low, selector;

char dw_count, access_right;

short offset_high;

};

void init_gdtidt(void); /* 5.9, 12.1, 20.5, 20.8, 21.5, 21.6, 22.2 */

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar); /* 5.9, 6.4 */

void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar); /* 5.9 */

#define ADR_IDT 0x0026f800

#define LIMIT_IDT 0x000007ff

#define ADR_GDT 0x00270000

#define LIMIT_GDT 0x0000ffff

#define ADR_BOTPAK 0x00280000

#define LIMIT_BOTPAK 0x0007ffff

#define AR_DATA32_RW 0x4092

#define AR_CODE32_ER 0x409a

#define AR_LDT 0x0082

#define AR_TSS32 0x0089

#define AR_INTGATE32 0x008e



/* int.c */

void init_pic(void); /* 6.5 */

#define PIC0_ICW1 0x0020

#define PIC0_OCW2 0x0020

#define PIC0_IMR 0x0021

#define PIC0_ICW2 0x0021

#define PIC0_ICW3 0x0021

#define PIC0_ICW4 0x0021

#define PIC1_ICW1 0x00a0

#define PIC1_OCW2 0x00a0

#define PIC1_IMR 0x00a1

#define PIC1_ICW2 0x00a1

#define PIC1_ICW3 0x00a1

#define PIC1_ICW4 0x00a1



/* keyboard.c */

void inthandler21(int *esp); /* 6.6, 7.1, 7.2, 7.3, 7.4, 7.5, 13.4 */

void wait_KBC_sendready(void); /* 7.6 */

void init_keyboard(struct FIFO32 *fifo, int data0); /* 7.6, 13.4 */

#define PORT_KEYDAT 0x0060

#define PORT_KEYCMD 0x0064



/* mouse.c */

struct MOUSE_DEC { /* 8.2, 8.3 */

unsigned char buf[3], phase;

int x, y, btn;

};

void inthandler2c(int *esp); /* 6.6, 7.7 */

void enable_mouse(struct FIFO32 *fifo, int data0, struct MOUSE_DEC *mdec); /* 7.6, 8.2, 13.4 */

int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat); /* 8.2, 8.3 */



/* memory.c */

#define MEMMAN_FREES 4090 /* 约32KB */

#define MEMMAN_ADDR 0x003c0000

struct FREEINFO { /* 剩余容量信息 */ /* 9.4 */

unsigned int addr, size;

};

struct MEMMAN { /*内存管理*/ /* 9.4 */

int frees, maxfrees, lostsize, losts;

struct FREEINFO free[MEMMAN_FREES];

};

unsigned int memtest(unsigned int start, unsigned int end); /* 9.2 */

void memman_init(struct MEMMAN *man); /* 9.4 */

unsigned int memman_total(struct MEMMAN *man); /* 9.4 */

unsigned int memman_alloc(struct MEMMAN *man, unsigned int size); /* 9.4 */

int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size); /* 9.4 */

unsigned int memman_alloc_4k(struct MEMMAN *man, unsigned int size); /* 10.1 */

int memman_free_4k(struct MEMMAN *man, unsigned int addr, unsigned int size); /* 10.1 */



/* sheet.c */

#define MAX_SHEETS 256

struct SHEET { /* 10.2, 11.3, 23.8 */

unsigned char *buf;

int bxsize, bysize, vx0, vy0, col_inv, height, flags;

struct SHTCTL *ctl;

struct TASK *task;

};

struct SHTCTL { /* 10.2, 11.8 */

unsigned char *vram, *map;

int xsize, ysize, top;

struct SHEET *sheets[MAX_SHEETS];

struct SHEET sheets0[MAX_SHEETS];

};

struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize);

/* 10.2, 11.3, 11.8 */

struct SHEET *sheet_alloc(struct SHTCTL *ctl); /* 10.2, 23.8 */

void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv);

/* 10.2 */

void sheet_updown(struct SHEET *sht, int height); /* 10.2, 11.3, 11.7, 11.8 */

void sheet_refresh(struct SHEET *sht, int bx0, int by0, int bx1, int by1); /* 10.2, 10.3, 11.3, 11.7, 11.8 */

void sheet_slide(struct SHEET *sht, int vx0, int vy0); /* 10.2, 10.3, 11.3, 11.7, 11.8 */

void sheet_free(struct SHEET *sht); /* 10.2, 11.3 */



/* timer.c */

#define MAX_TIMER 500

struct TIMER { /* 12.4, 13.4, 13.5, 24.8 */

struct TIMER *next;

unsigned int timeout;

char flags, flags2;

struct FIFO32 *fifo;

int data;

};

struct TIMERCTL { /* 12.2, 12.3, 12.4, 12.6, 12.7, 13.5 */

unsigned int count, next;

struct TIMER *t0;

struct TIMER timers0[MAX_TIMER];

};

extern struct TIMERCTL timerctl;

void init_pit(void); /* 12.1, 12.2, 12.3, 12.4, 12.6, 12.7, 13.6 */

struct TIMER *timer_alloc(void); /* 12.4, 12.7, 24.8 */

void timer_free(struct TIMER *timer); /* 12.4 */

void timer_init(struct TIMER *timer, struct FIFO32 *fifo, int data); /* 12.4, 13.4 */

void timer_settime(struct TIMER *timer, unsigned int timeout); /* 12.4, 12.5, 12.6, 12.7, 13.5, 13.6 */

void inthandler20(int *esp); /* 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 13.4, 13.5, 13.6, 15.7 */

int timer_cancel(struct TIMER *timer); /* 24.8 */

void timer_cancelall(struct FIFO32 *fifo); /* 24.8 */



/* mtask.c */

#define MAX_TASKS 1000 /* 最大任务数量 */

#define TASK_GDT0 3 /* TSS从GDT的几号开始分配 */

#define MAX_TASKS_LV 100

#define MAX_TASKLEVELS 10

struct TSS32 { /* 15.1, 16.1 */

int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;

int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;

int es, cs, ss, ds, fs, gs;

int ldtr, iomap;

};

struct TASK { /* 16.1, 16.4, 16.5, 17.4, 25.6, 26.7, 27.4, 28.3, 28.4, 28.5, 28.6 */

int sel, flags; /* sel代表GDT编号*/

int level, priority;

struct FIFO32 fifo;

struct TSS32 tss;

struct SEGMENT_DESCRIPTOR ldt[2];

struct CONSOLE *cons;

int ds_base, cons_stack;

struct FILEHANDLE *fhandle;

int *fat;

char *cmdline;

unsigned char langmode, langbyte1;

};

struct TASKLEVEL { /* 16.5 */

int running; /*活动的任务数量*/

int now; /*保存当前活动任务的变量*/

struct TASK *tasks[MAX_TASKS_LV];

};

struct TASKCTL { /* 16.1, 16.5 */

int now_lv; /*当前活动的层级 */

char lv_change; /* 下次切换任务时是否需要改变层级 */

struct TASKLEVEL level[MAX_TASKLEVELS];

struct TASK tasks0[MAX_TASKS];

};

extern struct TASKCTL *taskctl;

extern struct TIMER *task_timer;

struct TASK *task_now(void); /* 16.5 */

struct TASK *task_init(struct MEMMAN *memman); /* 16.1, 16.4, 16.5, 17.1, 27.4 */

struct TASK *task_alloc(void); /* 16.1, 22.3, 27.4 */

void task_run(struct TASK *task, int level, int priority); /* 16.1, 16.4, 16.5 */

void task_switch(void); /* 16.1, 16.4, 16.5 */

void task_sleep(struct TASK *task); /* 16.2, 16.5 */



/* window.c */

void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act); /* 11.4, 16.3, 17.3 */

void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l); /* 13.1, 29.1 */

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c); /* 14.6 */

void make_wtitle8(unsigned char *buf, int xsize, char *title, char act); /* 17.3 */

void change_wtitle8(struct SHEET *sht, char act); /* 24.5 */



/* console.c */

struct CONSOLE { /* 20.1, 23.6 */

struct SHEET *sht;

int cur_x, cur_y, cur_c;

struct TIMER *timer;

};

struct FILEHANDLE { /* 28.3 */

char *buf;

int size;

int pos;

};

void console_task(struct SHEET *sheet, int memtotal);

/* 17.2, 17.4, 18.2, 18.3, 18.4, 18.5, 18.6, 18.7, 19.1, 19.2, 19.3,19.5, 20.1, 20.2, 25.6, 25.10, 26.8, 26.10, 27.2, 28.3, 28.4, 28.5, 28.6 */

void cons_putchar(struct CONSOLE *cons, int chr, char move); /* 20.1, 26.10 */

void cons_newline(struct CONSOLE *cons); /* 20.1, 26.10, 28.6 */

void cons_putstr0(struct CONSOLE *cons, char *s); /* 20.8 */

void cons_putstr1(struct CONSOLE *cons, char *s, int l); /* 20.8 */

void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal);

/* 20.1, 20.6, 20.8, 26.7, 26.9, 26.10, 28.5 */

void cmd_mem(struct CONSOLE *cons, int memtotal); /* 20.1, 20.8 */

void cmd_cls(struct CONSOLE *cons); /* 20.1 */

void cmd_dir(struct CONSOLE *cons); /* 20.1, 20.8 */

void cmd_exit(struct CONSOLE *cons, int *fat); /* 26.7, 26.10 */

void cmd_start(struct CONSOLE *cons, char *cmdline, int memtotal); /* 26.9 */

void cmd_ncst(struct CONSOLE *cons, char *cmdline, int memtotal); /* 26.10 */

void cmd_langmode(struct CONSOLE *cons, char *cmdline); /* 28.5, 28.7 */

int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline);

/* 20.6, 21.1, 21.2, 21.4, 21.6, 22.4, 23.8, 24.5, 24.8, 25.6, 25.7, 27.4, 28.3, 28.6, 29.2 */

int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax);

/* 21.6, 22.1, 22.4, 22.5, 22.6, 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.8,

24.5, 24.7, 24.8, 25.1, 25.4, 25.6, 26.2, 27.2, 28.3, 28.4, 28.7, 29.2, 29.5 */

int *inthandler0d(int *esp); /* 21.6, 22.2, 25.6 */

int *inthandler0c(int *esp); /* 22.2, 25.6 */

void hrb_api_linewin(struct SHEET *sht, int x0, int y0, int x1, int y1, int col); /* 23.4 */



/* file.c */

struct FILEINFO { /* 18.7, 19.1 */

unsigned char name[8], ext[3], type;

char reserve[10];

unsigned short time, date, clustno;

unsigned int size;

};

void file_readfat(int *fat, unsigned char *img); /* 19.3 */

void file_loadfile(int clustno, int size, char *buf, int *fat, char *img); /* 19.3 */

struct FILEINFO *file_search(char *name, struct FILEINFO *finfo, int max); /* 20.1 */

char *file_loadfile2(int clustno, int *psize, int *fat); /* 29.2 */



/* tek.c */

int tek_getsize(unsigned char *p); /* 29.2 */

int tek_decomp(unsigned char *p, char *q, int size); /* 29.2 */



/* bootpack.c */

struct TASK *open_constask(struct SHEET *sht, unsigned int memtotal); /* 26.10 */

struct SHEET *open_console(struct SHTCTL *shtctl, unsigned int memtotal); /* 26.5, 26.7, 26.10 */




■■■■■

apilib.h

void api_putchar(int c); /* 21.2, 21.6, 27.5 */

void api_putstr0(char *s); /* 22.4, 27.5 */

void api_putstr1(char *s, int l); /* 27.5 */

void api_end(void); /* 21.6 */

int api_openwin(char *buf, int xsiz, int ysiz, int col_inv, char *title); /* 22.5 */

void api_putstrwin(int win, int x, int y, int col, int len, char *str); /* 22.6 */

void api_boxfilwin(int win, int x0, int y0, int x1, int y1, int col); /* 22.6 */

void api_initmalloc(void); /* 23.1 */

char *api_malloc(int size); /* 23.1 */

void api_free(char *addr, int size); /* 23.1 */

void api_point(int win, int x, int y, int col); /* 23.2 */

void api_refreshwin(int win, int x0, int y0, int x1, int y1); /* 23.3 */

void api_linewin(int win, int x0, int y0, int x1, int y1, int col); /* 23.4 */

void api_closewin(int win); /* 23.5 */

int api_getkey(int mode); /* 23.6 */

int api_alloctimer(void); /* 24.7 */

void api_inittimer(int timer, int data); /* 24.7 */

void api_settimer(int timer, int time); /* 24.7 */

void api_freetimer(int timer); /* 24.7 */

void api_beep(int tone); /* 25.1 */

int api_fopen(char *fname); /* 28.3 */

void api_fclose(int fhandle); /* 28.3 */

void api_fseek(int fhandle, int offset, int mode); /* 28.3 */

int api_fsize(int fhandle, int mode); /* 28.3 */

int api_fread(char *buf, int maxsize, int fhandle); /* 28.3 */

int api_cmdline(char *buf, int maxsize); /* 28.4 */

int api_getlang(void); /* 28.7 */





Table of Contents

版权信息

版 权 声 明

译 者 序

前　言

第0天　着手开发之前

1　前言

2　何谓操作系统

3　开发操作系统的各种方法

4　无知则无畏

5　如何开发操作系统

6　操作系统开发中的困难

7　学习本书时的注意事项（重要！）

8　各章内容摘要

第1天　从计算机结构到汇编程序入门

1　先动手操作

2　究竟做了些什么

3　初次体验汇编程序

4　加工润色

第2天　汇编语言学习与Makefile入门

1　介绍文本编辑器

2　继续开发

3　先制作启动区

4　Makefile入门

第3天　进入32位模式并导入C语言

1　制作真正的IPL

2　试错

3　读到18扇区

4　读入10个柱面

5　着手开发操作系统

6　从启动区执行操作系统

7　确认操作系统的执行情况

8　32位模式前期准备

9　开始导入C语言

10　实现HLT（harib00j）

第4天　C语言与画面显示的练习

1　用C语言实现内存写入（harib01a）

2　条纹图案（harib01b）

3　挑战指针（harib01c）

4　指针的应用（1）（harib01d）

5　指针的应用（2）（harib01e）

6　色号设定（harib01f）

7　绘制矩形（harib01g）

8　今天的成果（harib01h）

第5天　结构体、文字显示与GDT/IDT初始化

1　接收启动信息（harib02a）

2　试用结构体（harib02b）

3　试用箭头记号（harib02c）

4　显示字符（harib02d）

5　增加字体（harib02e）

6　显示字符串（harib02f）

7　显示变量值（harib02g）

8　显示鼠标指针（harib02h）

9　GDT与IDT的初始化（harib02i）

第6天　分割编译与中断处理

1　分割源文件（harib03a）

2　整理Makefile（harib03b）

3　整理头文件（harib03c）

4　意犹未尽

5　初始化PIC（harib03d）

6　中断处理程序的制作（harib03e）

第7天　FIFO与鼠标控制

1　获取按键编码（hiarib04a）

2　加快中断处理（hiarib04b）

3　制作FIFO缓冲区（hiarib04c）

4　改善FIFO缓冲区（hiarib04d）

5　整理FIFO缓冲区（hiarib04e）

6　总算讲到鼠标了（harib04f）

7　从鼠标接受数据（harib04g）

第8天　鼠标控制与32位模式切换

1　鼠标解读（1）（harib05a）

2　稍事整理（harib05b）

3　鼠标解读（2）（harib05c）

4　移动鼠标指针（harib05d）

5　通往32位模式之路

第9天　内存管理

1　整理源文件（harib06a）

2　内存容量检查（1）（harib06b）

3　内存容量检查（2）（harib06c）

4　挑战内存管理（harib06d）

第10天　叠加处理

1　内存管理（续）（harib07a）

2　叠加处理（harib07b）

3　提高叠加处理速度（1）（harib07c）

4　提高叠加处理速度（2）（harib07d）

第11天　制作窗口

1　鼠标显示问题（harib08a）

2　实现画面外的支持（harib08b）

3　shtctl的指定省略（harib08c）

4　显示窗口（harib08d）

5　小实验（harib08e）*

6　高速计数器（harib08f）

7　消除闪烁（1）（harib08g）

8　消除闪烁（2）（harib08h）

第12天　定时器（1）

1　使用定时器（harib09a）

2　计量时间（harib09b）

3　超时功能（harib09c）

4　设定多个定时器（harib09d）

5　加快中断处理（1）（harib09e）

6　加快中断处理（2）（harib09f）

7　加快中断处理（3）（harib09g）

第13天　定时器（2）

1　简化字符串显示（harib10a）

2　重新调整FIFO缓冲区（1）（harib10b）

3　测试性能（harib10c～harib10f）

4　重新调整FIFO缓冲区（2）（harib10g）

5　加快中断处理（4）（harib10h）

6　使用“哨兵”简化程序（harib10i）

第14天　高分辨率及键盘输入

1　继续测试性能（harib11a ～ harib11c）

2　提高分辨率（1）（harib11d）

3　提高分辨率（2）（harib11e）

4　键盘输入（1）（harib11f）

5　键盘输入（2）（harib11g）

6　追记内容（1）（harib11h）

7　追记内容（2）（harib11i）

第15天　多任务（1）

1　挑战任务切换（harib12a）

2　任务切换进阶（harib12b）

3　做个简单的多任务（1）（harib12c）

4　做个简单的多任务（2）（harib12d）

5　提高运行速度（harib12e）

6　测试运行速度（harib12f）

7　多任务进阶（harib12g）

第16天　多任务（2）

1　任务管理自动化（harib13a）

2　让任务休眠（harib13b）

3　增加窗口数量（harib13c）

4　设定任务优先级（1）（harib13d）

5　设定任务优先级（2）（harib13e）

第17天　命令行窗口

1　闲置任务（harib14a）

2　创建命令行窗口（harib14b）

3　切换输入窗口（harib14c）

4　实现字符输入（harib14d）

5　符号的输入（harib14e）

6　大写字母与小写字母（harib14f）

7　对各种锁定键的支持（harib14g）

第18天　dir命令

1　控制光标闪烁（1）（harib15a）

2　控制光标闪烁（2）（harib15b）

3　对回车键的支持（harib15c）

4　对窗口滚动的支持（harib15d）

5　mem命令（harib15e）

6　cls命令（harib15f）

7　dir命令（harib15g）

第19天　应用程序

1　type命令（harib16a）

2　type命令改良（harib16b）

3　对FAT的支持（harib16c）

4　代码整理（harib16d）

5　第一个应用程序（harib16e）

第20天　API

1　程序整理（harib17a）

2　显示单个字符的API（1）（harib17b）

3　显示单个字符的API（2）（harib17c）*

4　结束应用程序（harib17d）

5　不随操作系统版本而改变的API（harib17e）

6　为应用程序自由命名（harib17f）

7　当心寄存器（harib17g）

8　用API显示字符串（harib17h）

第21天　保护操作系统

1　攻克难题——字符串显示API（harib18a）

2　用C语言编写应用程序（harib18b）

3　保护操作系统（1）（harib18c）

4　保护操作系统（2）（harib18d）

5　对异常的支持（harib18e）

6　保护操作系统（3）（harib18f）

7　保护操作系统（4）（harib18g）

第22天　用C语言编写应用程序

1　保护操作系统（5）（harib19a）

2　帮助发现bug（harib19b）

3　强制结束应用程序（harib19c）

4　用C语言显示字符串（1）（harib19d）

5　用C语言显示字符串（2）（harib19e）

6　显示窗口（harib19f）

7　在窗口中描绘字符和方块（harib19g）

第23天　图形处理相关

1　编写malloc（harib20a）

2　画点（harib20b）

3　刷新窗口（harib20c）

4　画直线（harib20d）

5　关闭窗口（harib20e）

6　键盘输入API（harib20f）

7　用键盘输入来消遣一下（harib20g）

8　强制结束并关闭窗口（harib20h）

第24天　窗口操作

1　窗口切换（1）（harib21a）

2　窗口切换（2）（harib21b）

3　移动窗口（harib21c）

4　用鼠标关闭窗口（harib21d）

5　将输入切换到应用程序窗口（harib21e）

6　用鼠标切换输入窗口（harib21f）

7　定时器API（harib21g）

8　取消定时器（harib21h）

第25天　增加命令行窗口

1　蜂鸣器发声（harib22a）

2　增加更多的颜色（1）（harib22b）

3　增加更多的颜色（2）（harib22c）

4　窗口初始位置（harib22d）

5　增加命令行窗口（1）（harib22e）

6　增加命令行窗口（2）（harib22f）

7　增加命令行窗口（3）（harib22g）

8　增加命令行窗口（4）（harib22h）

9　变得更像真正的操作系统（1）（harib22i）

10　变得更像真正的操作系统（2）（harib22j）

第26天　为窗口移动提速

1　提高窗口移动速度（1）（harib23a）

2　提高窗口移动速度（2）（harib23b）

3　提高窗口移动速度（3）（harib23c）

4　提高窗口移动速度（4）（harib23d）

5　启动时只打开一个命令行窗口（harib23e）

6　增加更多的命令行窗口（harib23f）

7　关闭命令行窗口（1）（harib23g）

8　关闭命令行窗口（2）（harib23h）

9　start命令（harib23i）

10　ncst命令（harib23j）

第27天　LDT与库

1　先来修复bug（harib24a）

2　应用程序运行时关闭命令行窗口（harib24b）*

3　保护应用程序（1）（harib24c）

4　保护应用程序（2）（harib24d）

5　优化应用程序的大小（harib24e）

6　库（harib24f）

7　整理make环境（harib24g）

第28天　文件操作与文字显示

1　alloca（1）（harib25a）

2　alloca（2）（harib25b）

3　文件操作API（harib25c）

4　命令行API（harib25d）

5　日文文字显示（1）（harib25e）<sup>1</sup>

6　日文文字显示（2）（harib25f）

7　日文文字显示（3）（harib25g）

第29天　压缩与简单的应用程序

1　修复bug（harib26a）

2　文件压缩（harib26b）

3　标准函数

4　非矩形窗口（harib26c）

5　bball（harib26d）

6　外星人游戏（harib26e）

第30天　高级的应用程序

1　命令行计算器（harib27a）

2　文本阅览器（harib27b）

3　MML播放器（harib27c）

4　图片阅览器（harib27d）

5　IPL的改良（harib27e）

6　光盘启动（harib27f）

第31天　写在开发完成之后

1　继续开发要靠大家的努力

2　关于操作系统的大小

3　操作系统开发的诀窍

4　分享给他人使用

5　关于光盘中的软件

6　关于开源的建议

7　后记

8　毕业典礼

9　附录

目录

* elf
** ELF32文件结构
#+BEGIN_SRC c
#define EI_NIDENT    16
typedef struct elf32_hdr{
  unsigned char    e_ident[EI_NIDENT];  //开始的16个字节
  Elf32_Half    e_type;  //文件类型
  Elf32_Half    e_machine;  //运行的机器类型
  Elf32_Word    e_version;  //版本
  Elf32_Addr    e_entry;  //程序入口地址
  Elf32_Off    e_phoff;  //程序头表在文件中的偏移
  Elf32_Off    e_shoff;  //节头表在文件中的偏移
  Elf32_Word    e_flags;  //标记
  Elf32_Half    e_ehsize;  //elf文件头大小
  Elf32_Half    e_phentsize;  //程序头表项的大小
  Elf32_Half    e_phnum;  //程序头表中表项项的个数
  Elf32_Half    e_shentsize;  //节头表项大小
  Elf32_Half    e_shnum;  //节头表中表项的个数
  Elf32_Half    e_shstrndx;  //节头表的字符串节所在节头表中下标
} Elf32_Ehdr;
#+END_SRC
节头表项对应的代码定义为：
#+BEGIN_SRC c
typedef struct elf32_shdr {
  Elf32_Word    sh_name;  //节的名字，在符号表中的下标
  Elf32_Word    sh_type;  //节的类型，描述符号，代码，数据，重定位等
  Elf32_Word    sh_flags;  //读写执行标记
  Elf32_Addr    sh_addr;  //节在执行时的虚拟地址
  Elf32_Off    sh_offset;  //节在文件中的偏移量
  Elf32_Word    sh_size;  //节的大小
  Elf32_Word    sh_link;  //其它节的索引
  Elf32_Word    sh_info;  //节的其它信息
  Elf32_Word    sh_addralign;  //节对齐
  Elf32_Word    sh_entsize;  //节拥有固定大小项的大小
} Elf32_Shdr;
#+END_SRC
: jmp汇编 的是偏移地址,我们写是写绝对地址
#+TITTLE: int中断
** int 10 显示中断
#+CAPTION: 
|  AH | 功能                       | 调用参数                               | 返回参数                        |
|-----+----------------------------+----------------------------------------+---------------------------------|
|   0 | 设置显示模式               | AL = video mode                        | AL = video mode flag  mode byte |
|     |                            | 模式碼 (正常為 03h)                    |                                 |
|     |                            | 00H: 40*25 16 色 8 頁 B8000H~B87CFH    | 文字模式                        |
|     |                            | 01H: 80*25 16 色 8 頁 B8000H~B87CFH    |                                 |
|     |                            | 02H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 03H: 80*25 16 色 8 頁 B8000H~B8F9FH    |                                 |
|     |                            | 07H: 80*25 2 色 8 頁 B8000H~B8F9FH     |                                 |
|     |                            | 04H: 320*200 4 色 1 頁 B8000H~BBF3FH   | 绘图模式                        |
|     |                            | 05H: 320*200 4 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 06H: 640*200 2 色 1 頁 B8000H~BBF3FH   |                                 |
|     |                            | 0DH: 320*200 16 色 8 頁 A0000H~A1F3FH  |                                 |
|     |                            | 0EH: 640*200 16 色 4 頁 A0000H~A3E7FH  |                                 |
|     |                            | 0FH: 640*350 2 色 2 頁 A0000H~A6D5FH   |                                 |
|     |                            | 10H: 640*350 16 色 2 頁 A0000H~A6D5FH  |                                 |
|     |                            | 11H: 640*480 2 色 1 頁 A0000H~A95FFH   |                                 |
|     |                            | 12H: 640*480 16 色 1 頁 A0000H~A95FFH  |                                 |
|     |                            | 13H: 320*200 256 色 1 頁 A0000H~AF9FFH |                                 |
|   1 | 置光标类型                 | (CH)0―3 = 光标开始行                  |                                 |
|     |                            | (CL)0―3 = 光标结束行                  |                                 |
|   2 | 置光标位置                 | BH = 页号                              |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   3 | 读光标位置                 | BH = 页号                              |                                 |
|     |                            | CH = 光标开始行                        |                                 |
|     |                            | CL = 光标结束行                        |                                 |
|     |                            | DH = 行                                |                                 |
|     |                            | DL = 列                                |                                 |
|   4 | 读光笔位置                 |                                        | AH=0 光笔未触发                 |
|     |                            |                                        | AH=1 光笔触发                   |
|     |                            |                                        | CH=象素行                       |
|     |                            |                                        | BX=象素列                       |
|     |                            |                                        | DH=字符行                       |
|     |                            |                                        | DL=字符列                       |
|     |                            |                                        |                                 |
|   5 | 显示页                     | AL = 显示页号                          |                                 |
|   6 | 屏幕初始化或上卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   7 | 屏幕初始化或下卷           | AL = 上卷行数                          |                                 |
|     |                            | AL =0全屏幕为空白                      |                                 |
|     |                            | BH = 卷入行属性                        |                                 |
|     |                            | CH = 左上角行号                        |                                 |
|     |                            | CL = 左上角列号                        |                                 |
|     |                            | DH = 右下角行号                        |                                 |
|     |                            | DL = 右下角列号                        |                                 |
|   8 | 读光标位置的属性和字符     | BH = 显示页                            | AH = 属性                       |
|     |                            |                                        | AL = 字符                       |
|   9 | 在光标位置显示字符及其属性 | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | BL = 属性                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   A | 在光标位置只显示字符       | BH = 显示页                            |                                 |
|     |                            | AL = 字符                              |                                 |
|     |                            | CX = 字符重复次数                      |                                 |
|   E | 显示字符(光标前移)         | AL = 字符                              |                                 |
|     |                            | BL = 前景色                            |                                 |
| 13h | 显示字符串                 | ES:BP = 串地址                         |                                 |
|     |                            | CX = 串长度                            |                                 |
|     |                            | DH=row， DL = 起始行列                 |                                 |
|     |                            | BH = 页号                              |                                 |
|     |                            | AL = writemode，BL = 属性/颜色         |                                 |

** int 13 磁盘中断
#+CAPTION:  int 13 磁盘操作
| AH  | 功能                  | 调用参数                                  | 返回参数                                     |
| 00  | 磁盘系统复位          | DL＝驱动器                                | CF＝0——操作成功，AH＝00H                     |
|     |                       | 00H~7FH：软盘                             | 否则，AH＝状态代码                           |
|     |                       | 80H~0FFH：硬盘                            |                                              |
| 01  | 读取磁盘系统状态      | DL＝驱动器                                | AH＝00H，AL＝状态代码，其定义如下：          |
|     |                       | 00H~7FH：软盘                             | 00H — 无错                                   |
|     |                       | 80H~0FFH：硬盘                            | 01H — 非法命令                               |
|     |                       |                                           | 02H — 地址目标未发现                         |
|     |                       |                                           | 03H — 磁盘写保护(软盘)                       |
|     |                       |                                           | 04H — 扇区未发现                             |
|     |                       |                                           | 05H — 复位失败(硬盘)                         |
|     |                       |                                           | 06H — 软盘取出(软盘)                         |
|     |                       |                                           | 07H — 错误的参数表(硬盘)                     |
|     |                       |                                           | 08H — DMA越界(软盘)                          |
|     |                       |                                           | 09H — DMA超过64K界限                         |
|     |                       |                                           | 0AH — 错误的扇区标志(硬盘)                   |
|     |                       |                                           | 0BH — 错误的磁道标志(硬盘)                   |
|     |                       |                                           | 0CH — 介质类型未发现(软盘)                   |
|     |                       |                                           | 0DH — 格式化时非法扇区号(硬盘)               |
|     |                       |                                           | 0EH — 控制数据地址目标被发现(硬盘)           |
|     |                       |                                           | 0FH — DMA仲裁越界(硬盘)                      |
|     |                       |                                           | 10H — 不正确的CRC或ECC编码                   |
|     |                       |                                           | 11H — ECC校正数据错(硬盘)                    |
|     |                       |                                           | 20H — 控制器失败                             |
|     |                       |                                           | 40H — 查找失败                               |
|     |                       |                                           | 80H — 磁盘超时(未响应)                       |
|     |                       |                                           | AAH — 驱动器未准备好(硬盘)                   |
|     |                       |                                           | BBH — 未定义的错误(硬盘)                     |
|     |                       |                                           | CCH — 写错误(硬盘)                           |
|     |                       |                                           | E0H — 状态寄存器错(硬盘)                     |
|     |                       |                                           | FFH — 检测操作失败(硬盘)                     |
| 02H | 读扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | (#驱动器,相当于哪块磁盘)        |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 03H | 写扇区                | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 04H | 检验扇区              | AH＝04H                                   | CF＝0——操作成功，AH＝00H，AL＝被检验的扇区数 |
|     |                       | AL＝扇区数                                | 否则，AH＝状态代码                           |
|     |                       | CH＝柱面                                  |                                              |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 05H | 格式化磁道            | AL＝交替(Interleave)                      | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码                           |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 06H | 格式化坏磁道          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝地址域列表的地址                   |                                              |
| 07H | 格式化驱动器          | AL＝交替                                  | CF＝0——操作成功，AH＝00H                     |
|     |                       | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 08H | 读取驱动器参数        | DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘 | CF＝1——操作失败，AH＝状态代码                |
|     |                       |                                           | 否则， BL＝01H — 360K                        |
|     |                       |                                           | ＝02H — 1.2M                                 |
|     |                       |                                           | ＝03H — 720K                                 |
|     |                       |                                           | ＝04H — 1.44M                                |
|     |                       |                                           | CH＝柱面数的低8位                            |
|     |                       |                                           | CL的位7-6＝柱面数的高2位                     |
|     |                       |                                           | CL的位5-0＝扇区数                            |
|     |                       |                                           | DH＝磁头数                                   |
|     |                       |                                           | DL＝驱动器数                                 |
|     |                       |                                           | ES:DI＝磁盘驱动器参数表地址                  |
| 09H | 初始化硬盘参数        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H否则                 |
|     |                       |                                           | AH＝状态代码，参见功能号01H中的说明          |
| 0AH | 读长扇区, 每个扇区    | AL＝扇区数                                |                                              |
|     | 随带四个字节的ECC编码 | CH＝柱面                                  | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     |                       | CL＝扇区                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0BH | 写长扇区，每个扇区随  | AL＝扇区数                                | CF＝0——操作成功，AH＝00H，AL＝传输的扇区数   |
|     | 带四个字节的ECC编码   | CH＝柱面                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | CL＝扇区                                  |                                              |
|     |                       | DH＝磁头                                  |                                              |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
|     |                       | ES:BX＝缓冲区的地址                       |                                              |
| 0CH | 查寻                  | CL(7-6位)＝柱面的高2位                    | CF＝0——操作成功，AH＝00H，                   |
|     |                       | DH＝磁头                                  | 否则，AH＝状态代码，参见功能号01H中的说明    |
|     |                       | DL＝80H~0FFH：硬盘                        |                                              |
| 0DH | 硬盘系统复位          | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 0EH | 读扇区缓冲区          | ES:BX＝缓冲区的地址                       | 出口参数：CF＝0——操作成功                    |
| 0FH | 写扇区缓冲区          | ES:BX＝缓冲区的地址                       | CF＝0——操作成功                              |
| 10H | 读取驱动器状态        | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H                     |
| 11H | 校准驱动器            | DL＝80H~0FFH：硬盘                        | CF＝0——操作成功，AH＝00H，                   |
| 12H | 控制器RAM诊断         |                                           | CF＝0——操作成功，....                        |
| 13H | 控制器驱动诊断        |                                           | CF＝0——操作成功，否则，...                   |
| 14H | 控制器内部诊断        |                                           | CF＝0——操作成功，否则                        |
| 15H | 读取磁盘类型          | DL＝驱动器，00H~7FH：软盘；               | CF＝1——操作失败，AH＝状态代码                |
|     |                       | 80H~0FFH：硬盘                            | AH＝00H — 未安装驱动器                       |
|     |                       |                                           | ＝01H — 无改变线支持的软盘驱动器             |
|     |                       |                                           | ＝02H — 带有改变线支持的软盘驱动器           |
|     |                       |                                           | ＝03H — 硬盘，CX:DX＝512字节的扇区数         |
| 16H | 读取磁盘变化状态      | DL＝00H~7FH：软盘                         | CF＝0——磁盘未改变，AH＝00H                   |
|     |                       |                                           | 否则，AH＝06H，参见功能号01H中的说明         |
| 17H | 设置磁盘类型          | DL＝00H~7FH：软盘 AL＝00H — 未用          | CF＝0——操作成功，AH＝00H，                   |
|     |                       | ＝01H — 360K在360K驱动器中                | 否则，AH＝状态编码，参见功能号01H中的说明    |
|     |                       | ＝02H — 360K在1.2M驱动器中                |                                              |
|     |                       | ＝03H — 1.2M在1.2M驱动器中                |                                              |
|     |                       | ＝04H — 720K在720K驱动器中                |                                              |
| 18H | 设置格式化媒体类型    | CH＝柱面数                                | CF＝0——操作成功，AH＝00H，                   |
|     |                       | CL＝每磁道的扇区数                        | ES:DI＝介质类型参数表地址，                  |
|     |                       | DL＝00H~7FH：软盘                         | 否则，AH＝状态编码，参见功能号01H中的说明    |
| 19H | 磁头保护，仅在PS/2    |                                           |                                              |
| 1AH | 格式化ESDI驱动器      | 仅在PS/2中有效，在此从略                  |                                              |

** int 16 键盘中断
| AH  | 功能                                | 调用参数                           | 返回值                           |
| 00H | 读取键盘输入                        |                                    | AL 字符的ASCII                   |
|     | 按键按下才返回                      |                                    | AH 扫描码                        |
| 01H | 确认键盘键入字符                    |                                    | AL 字符的ASCII                   |
|     |                                     |                                    | AH Scan code                     |
|     |                                     |                                    | ZF=1 未键入字符,无返回           |
|     |                                     |                                    | ZF=0 NZ,返回上面的               |
| 02H | Return shift-flag status            |                                    | AL Current shift status          |
|     |                                     |                                    | 7 6 5 4 3 2 1 0                  |
|     |                                     |                                    | Ins,Capa,Num,Scrol,Alt,C,左S,右S |
| 03H | Set typematic rate and delay        | AL 05 (subfunction number)         |                                  |
|     |                                     | BL 00H through 1FH, typematic rate |                                  |
|     |                                     | (30 charßsec to 2 char/sec)        |                                  |
|     |                                     | BH Delay rate:                     |                                  |
|     |                                     | 00h = 250 ms                       |                                  |
|     |                                     | 01h = 500 ms                       |                                  |
|     |                                     | 02h = 750 ms                       |                                  |
|     |                                     | 03h = 1000 ms                      |                                  |
|     |                                     | 04h to 07h = Reserved              |                                  |
| 05h | Add key to Keyboard buffer          | CL ASCII code                      | If Carry = 1:                    |
|     |                                     | CH Scan code                       | AL Keyboard buffer full          |
| 10h | Read extended character from buffer |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
| 11h | Return extended buffer status       |                                    | AL ASCII keystroke pressed       |
|     |                                     |                                    | AH Scan code of key              |
|     |                                     |                                    | ZF No keystroke available        |
|     |                                     |                                    | NZ Keystroke in buffer           |
| 12h | Return extended shift status        |                                    | AL Shift status:                 |
|     |                                     |                                    | Bit 7 1 = Sys Req pressed        |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Right Alt active       |
|     |                                     |                                    | Bit 2 1 = Right Ctrl active      |
|     |                                     |                                    | Bit 1 1 = Left Alt active        |
|     |                                     |                                    | Bit 0 1 = Left Ctrl active       |
|     |                                     |                                    | AH Extended shift status:        |
|     |                                     |                                    | Bit 7 1 = Insert active          |
|     |                                     |                                    | Bit 6 1 = Caps Lock active       |
|     |                                     |                                    | Bit 5 1 = Num Lock active        |
|     |                                     |                                    | Bit 4 1 = Scroll Lock active     |
|     |                                     |                                    | Bit 3 1 = Alt pressed            |
|     |                                     |                                    | Bit 2 1 = Ctrl pressed           |
|     |                                     |                                    | Bit 1 1 = Left Shift pressed     |
|     |                                     |                                    | Bit 0 1 = Right Shift pressed    |

** example
INT 0x10功能0x13
描述：
        以电传打字机的方式显示字符串
接受参数：
        AH                      0x13
        AL                      显示模式
        BH                      视频页
        BL                      属性值（如果AL=0x00或0x01）
        CX                      字符串的长度
        DH,DL           屏幕上显示起始位置的行、列值
        ES:BP           字符串的段:偏移地址
返回值：
        无
显示模式（AL）：
        0x00:字符串只包含字符码，显示之后不更新光标位置，属性值在BL中
        0x01:字符串只包含字符码，显示之后更新光标位置，属性值在BL中
        0x02:字符串包含字符码及属性值，显示之后不更新光标位置
        0x03:字符串包含字符码及属性值，显示之后更新光标位置

# A bootsect, which print a string by BIOS interrupt video services(int 0x10)

#+BEGIN_SRC asm -n -r
.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $msgstr,%bp
        movw    len,    %cx
        movb    $0x05,  %dh
        movb    $0x08,  %dl
        movb    $0x01,  %al
        movb    $0x13,  %ah
        movb    $0x01,  %bl
        movb    $0x00,  %bh

        int             $0x10
1:
        jmp             1b

msgstr:
        .asciz  "Hello babyos(print by BIOS int 0x10:0x13, mode 0x01)!"
len:
        .int    . - msgstr

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC
makefile:

#+BEGIN_SRC makefile -n -r
all: boot.img

boot.o: boot.s
        as -o $@ $<

boot: boot.o
        ld --oformat binary -N -Ttext 0x7c00 -o $@ $<

boot.img: boot
        dd if=boot of=boot.img bs=512 count=1

clean:
        rm ./boot ./boot.img ./boot.o
#+END_SRC
2.通过功能号0x09探究色彩控制
上面的显示为什么是红色呢？我们可以通过实验来看一下颜色控制

------------------------------------------------------------------------
                        INT 0x10功能0x09
-------------------------------------------------------------------
描述：
        显示字符并设置其属性
接受参数：
        AH                      0x09
        AL                      字符的ASCII码
        BH                      视频页
        BL                      属性值
        CX                      重复次数
返回值：
        无
注意：
        在显示字符之后并不前进光标。在文本和图形模式下均可调用该功能
        显示完字符后，如果还要继续显示字符，必须调用INT 0x10功能0x02前进光标
-------------------------------------------------------------------------

------------------------------------------------------------------------
                        INT 0x10功能0x02
-------------------------------------------------------------------
描述：
        把光标定位在选定视频页的特定行列位置
接受参数：
        AH                      0x02
        DH，DL          行、列值
        BH                      视频页
返回值：
        无
注意：
        在80x25模式下，DH范围0～24，DL范围0～79
-------------------------------------------------------------------------

示例：

实现一个从第4行～7行，第8列～71列，显示‘A’～‘Z’的程序，共显
示256个字符，使用BL（0～255）

: C 伪代码：

#+BEGIN_SRC C  -n -r
cx = 0x04;
bh = 0x00;

dh = 0x04;
dl = 0x08;
al = 'A';

for (bl = 0; bl < 256; bl++)
{
        print_char();
        
        al++;
        if (al == 'Z')
                al = 'A';
        
        dl++;
        if (dl == 72)
        {
                dh++;
                dl = 4;
        }
        
        set_cursor();
}

#+END_SRC
汇编代码：

#+BEGIN_SRC  asm -n -r
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char
        incb    %al
        cmpb    $'Z',   %al
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl
        cmpb    $72,    %dl
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor
        incb    %bl
        cmp             $256,   %bl
        jne             1b
        jmp             1f

print_char:
        movb    $0x09,  %ah
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55
#+END_SRC

结果：
[1356282645]

可以显式地验证色彩控制BL：

| 7    | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| I    | R | G | B | I | R | G | B |
| 闪烁 | R | G | B | I | R | G | B |
如上图所示，7～4位为背景色，I表示高亮，RGB表示红绿蓝，若显
卡支持闪烁，则位7表示是否闪烁。
色彩混合：
----------------------------------------------
| 混合的三种基色 | 不开启亮度位 | 开启亮度位 |
| 红+绿+蓝       | 浅灰         | 白色       |
| 绿+蓝          | 青色         | 浅青       |
| 红+蓝          | 洋红         | 浅洋红     |
| 红+绿          | 棕色         | 黄色       |
| 无色彩         | 黑色         | 暗灰       |
----------------------------------------------

3.清屏

可以发现屏幕上有许多Bochs的打印信息，看着不爽，想办法去掉它
们。

利用0x06号功能，上卷全部行，则可清屏。

-----------------------------------------------------------
INT 0x10 功能0x06
------------------------------------------------------
描述：
上卷窗口
参数：
AH 6
AL 上卷的行数（0表示全部）
BH 空白区域的视频属性
CH，CL 窗口左上角的行列位置
DH，DL 窗口右下角的行列位置
返回值：
无
------------------------------------------------------------
示例：

#+BEGIN_SRC asm -n
# A bootsect, which print a colorful chars by BIOS INT 0x10, 0x09

.section .text
.global _start
.code16

_start:
        movw    %cx,    %ax
        movw    %ax,    %ds
        movw    %ax,    %es

        call    clear_screen    # 清屏

        movw    $0x01,  %cx             # 字符显示重复次数
        movb    $0x00,  %bh             # 视频页
        
        movb    $0x04,  %dh             # 显示起始行
        movb    $0x08,  %dl             # 显示起始列
        
        movb    $'A',   %al             # 显示字符
        movb    $0x00,  %bl             # 属性值

1:
        call    print_char              # 打印字符
        incb    %al                             # 下一个字符
        cmpb    $'Z',   %al             # 是否该重新从‘A’开始
        jne             2f
        movb    $'A',   %al
2:      
        incb    %dl                             # 下一个位置
        cmpb    $72,    %dl             # 是否到下一行
        jne             3f
        movb    $8,             %dl
        incb    %dh
3:
        call    set_cursor              # 设置光标位置
        incb    %bl                             # 下一种属性
        cmp             $0,             %bl             # 是否256种属性用完
        jne             1b
        jmp             1f                              # 结束

clear_screen:                           # 清屏函数
        movb    $0x06,  %ah             # 功能号0x06
        movb    $0,             %al             # 上卷全部行，即清屏
        movb    $0,             %ch             # 左上角行
        movb    $0,             %ch             # 左上角列      
        movb    $24,    %dh             # 右下角行
        movb    $79,    %dl             # 右下角列
        movb    $0x07,  %bh             # 空白区域属性
        int             $0x10
        ret

print_char:
        movb    $0x09,  %ah             # 功能号0x09
        int             $0x10
        ret

set_cursor:
        movb    $0x02,  %ah             # 功能号0x02
        int             $0x10
        ret

1:
        jmp             1b

        .org    0x1fe,  0x90
        .word   0xaa55

#+END_SRC
结果：

[1356283975]

4.直接写显存绘制字符串：

示例：

#+BEGIN_SRC asm -n -r
#---------------------------------------------------------------
# 直接写显存显示一些文字函数：
#       显示计算机当前工作的显示模式    
draw_some_text:
        # 设置ES，DS的值
        movw    $VIDEO_SEG_TEXT,%ax
        movw    %ax,                    %es
        xorw    %ax,                    %ax
        movw    %ax,                    %ds

        # 计算字符显示位置的显存地址(目标地址)
        movw    $((80*TEXT_ROW+TEXT_COL) * 2),  %di
        
        # 源字符串地址
        leaw    msgstr,                 %si
        
        movb    $TEXT_COLOR,    %al             # 属性值（颜色）
        movw    len,                    %cx             # 显示的字符个数

draw_a_char:                    
        movsb
        stosb
        loop    draw_a_char

        ret
#+END_SRC

* Dos
 MS-DOS在个人计算机上的抽象架构           
 普通应用程序（Shell script、文本编辑器） 
 MS-DOS（文件系统）                       
 BIOS（驱动程序）                         
 硬件（中央处理器、存储设备等）           
* Linux
| 用户模式 | 	应用程序（sh、vi、OpenOffice.org等）     |
|          | 复杂库（KDE、glib等）                      |
|          | 简单库（opendbm、sin等）                   |
|          | C库（open、fopen、socket、exec、calloc等） |
| 内核模式 | 	系统中断、调用、错误等软硬件消息         |
|          | 内核（驱动程序、进程、网络、内存管理等）   |
|          | 硬件（处理器、内存、各种设备）             |
* 计算机操作系统  :系统:
** 系统基本功能 
*** 进程管理
    进程控制、进程同步、进程通信、死锁处理、处理机调度等。
*** 内存管理
   内存分配、地址映射、内存保护与共享、虚拟内存等。

*** 文件管理
   文件存储空间的管理、目录管理、文件读写管理和保护等。

*** 设备管理
   完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
   主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
** 系统调用
   Linux 的系统调用主要有以下这些：
| Task     | Commands                    |
| :---:    | ---                         |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |
