* 安装与配置
  配置文件/etc/php/7.0/apache2/php.ini
  命令行配置 /etc/php/7.0/cli/php.ini 
** 安装
   ./configure --with-mysql --with-apxs=/www/bin/apxs
*** apache的支持
    LoadModule php5_module        libexec/libphp5.so
    或
    apt install libapache2-mod-php php-common
    不同系统安装方式不一样
**** 隐藏入口文件
     index.php 相当于main 函数，apache 默认 会与此文件产生关系。
     在url 中隐藏此字串的方法是设置
     1.httpd.conf配置文件中加载了mod_rewrite.so模块 //在APACHE里面去配置
     #LoadModule rewrite_module modules/mod_rewrite.so把前面的警号去掉
     2.AllowOverride None 讲None改为 All      //在APACHE里面去配置
     3、在应用入口文件同级目录添加 .htaccess 文件,内容如下:
     <IfModule	mod_rewrite.c>
     Options	+FollowSymlinks	-Multiviews
     RewriteEngine	on
     RewriteCond	%{REQUEST_FILENAME}	!-d
     RewriteCond	%{REQUEST_FILENAME}	!-f
     RewriteRule	^(.*)$	index.php/$1	[QSA,PT,L]
     </IfModule>

*** nginx的支持
    vim /usr/local/nginx/conf/nginx.conf
    修改默认的 location 块，使其支持 .php 文件：

    location / {
    root   html;
    index  index.php index.html index.htm;
    }
    下一步配置来保证对于 .php 文件的请求将被传送到后端的 PHP-FPM 模块， 取消默认的 PHP 配置块的注释，并修改为下面的内容：

    location ~* \.php$ {
    fastcgi_index   index.php;
    fastcgi_pass    127.0.0.1:9000;
    include         fastcgi_params;
    fastcgi_param   SCRIPT_FILENAME    $document_root$fastcgi_script_name;
    fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;
    }
** 模块安装  
   apt install php-curl php-mysql
*** 手动加载模块 
    1. a2enmod rewrite 加载 rewrite模块
    2. 创建 到 mods-enabled 的软链接 ln -s /etc/apache2/mods-available/rewrite.load /etc/apache2/mods-enabled/rewrite.load
    3. 注意 虚拟主机 中 AllowOverride 为 All
*** 模块安装路径
    查找扩展路径 php -ini |grep extension
    extension_dir => /usr/lib/php/20151012
** php配置  
*** 配置错误提示 
  #+BEGIN_SRC php
    ini_set("display_errors", "On"); 
    error_reporting(E_ALL); //-1是关闭
  #+END_SRC
*** php.ini文件
  short_open_tag = Off（是否允许使用 PHP 代码开始标志的缩写形式（<? ?> ）。）；
  memory_limit = 128M（最大使用内存的大小）；
  upload_max_filesize = 2M（上传附件的最大值），第一个需要改成on，否则的话很多php程序都会运行不了，后面的两项就按照大家的实际需求更改就行了。
* php教程
** PHP的基本语法 
*** 变量 
**** 变量的类型 
***** 类型介绍 
***** 布尔型（boolean） 
***** 整型（integer） 
***** 浮点型（float或double） 
***** 字符串（String） 
      定义字符串的另种种方法是使用定界符
#+BEGIN_SRC php
  $string=<<<EOT
  这里是字符串，
  任意换行
  EOT;
#+END_SRC      
***** 数组（Array） 
      #+BEGIN_SRC php
        array( [key =>]
               value
               , ...
        )

            $arr = array("foo" => "bar", 12 => true);
      #+END_SRC
***** 对象（Object） 
      #+BEGIN_SRC php
        class Person {                          //使用class关键字定义一个类为Person
            var $name;                      //在类中定义一个成员属性$name;

            function say() {                //在类中定义一个成员方法say()
                echo "Doing foo.";     //在成员方法中输出一条语句
            }
        }

        $p = new Person;                        //使用new语句实例化类Person的对象放变量$p中

        $p->name="Tom";                      //通过对象$p访问对象中的成员属性$name
        $p->say();        
      #+END_SRC
***** 资源类型（Resource） 
      资源是通过专门的函数来创建和使用的。使用资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄。并由程序员创建、使用和释放。
     #+BEGIN_SRC php
             //使用fopen()函数以写的方式打开本目录下的info.txt文件，返回文件资源赋给变量$file_handle
        $file_handle = fopen("info.txt", "w");
        var_dump($file_handle);                         //输出resource(3) of type (stream)

        //使用opendir()函数打开Windows系统下的C:\\WINDOWS\\Fonts目录，返回目录资源
        $dir_handle = opendir("C:\\WINDOWS\\Fonts");
        var_dump($dir_handle);                          //输出resource(4) of type (stream)

        //使用mysql_connect()函数连接本机的MySQL管理系统，返回MySQL的连接资源
        $link_mysql = mysql_connect("localhost", "root", "123456");
        var_dump($link_mysql);                          //输出resource(5) of type (mysql link)

        //使用imagecreate()函数创建一个100x50的画板，返回图像资源
        $im_handle = imagecreate(100, 50);
        var_dump($im_handle);                           //输出resource(6) of type (gd)

        //使用xml_parser_create()函数返回xml解析器资源
        $xml_parser = xml_parser_create();
        var_dump($xml_parser);                          //输出resource(7) of type (xml)
     #+END_SRC 
***** NULL类型 
      特殊的NULL值表示一个变量没有值，NULL类型唯一可能的值就是NULL。
      NULL不区分大小写，在下列情况下一个变量被认为是NULL：
      将变量直接赋值为NULL。
      声明的变量尚未被赋值。
      被unset()函数销毁的变量。
***** 伪类型介绍 
      伪类型并不是PHP语言中的基本数据类型。只是因为PHP是弱类型语言，所以在一些函数中，一个参数可以接收多种类型的数据，还可以接收别的函数作为回调函数使用

 mixed： 说明一个参数可以接受多种不同的（但并不必须是所有的）类型。例如gettype()可以接受所有的PHP类型，str_replace()可以接受字符串和数组。
 number： 说明一个参数可以是integer或者float。
 callback： 有些诸如call_user_function()或usort()的函数接受用户自定义的函数作为一个参数。callback函数不仅可以是一个简单的函数，它还可以是一个对象的方法，包括静态类的方法。一个PHP函数用函数名字符串来传递。可以传递任何内置的或者用户自定义的函数，除了array()，echo()，empty()，eval()，exit()，isset()，list()，print()和unset()。
***** 数据类型之间相互转换 
        (bool) "false"       // bool(true)
        
***** 变量类型的测试函数 
      获取类型 echo gettype($bool);
        
      is_bool()：判断是否是布尔型。
      is_int()、is_integer()和is_long()：判断是否是整型。
      is_float()、is_double()和is_real()：判断是否是浮点数。
      is_string()：判断是否是字符串。
      is_array()：判断是否是数组。
      is_object()：判断是否是对象。
      is_resource()：判断是否是资源类型。
      is_null()：判断是否是为空。
      is_scalar()：判断是否是标量，也就是一个整数、浮点数、布尔型或字符串。
      is_numeric()：判断是否是任何类型的数字或数字字符串。
      is_callable()：判断是否是有效的函数名。

*** 常量 
**** 常量的定义和使用 
    boolean define (string name, mixed value [, bool case_insensitive]);           //常量定义函数
    此函数的第一个参数为常量名，第二个参数为常量的值或是表达式，第三个参数是可选的，如果把第三个参数
    case_insensitive设为TRUE，则常数将会定义成不区分大小写。缺省上是区分大小写的。如果只想检查是否定义了
    某常量，用defined()函数。常量的声明与使用如下所示：
    define("BOO", true);                    //声明一个名为BOO的常量，值为布尔型true
    if (defined('CONSTANT')) {}
**** 预定义常量 
     __FILE__  当前的文件名  在哪个文件中使用，就代表哪个文件名称  
     __LINE__  当前的行数  在代码的哪行使用，就代表哪行的行号  
     __FUNCTION__  当前的函数名  在哪个函数中使用，就代表哪个函数名  
     __CLASS__  当前的类名  在哪个类中使用，就代表哪个类的类名  
     __METHOD__  当前对象的方法名  在对象中的哪个方法中使用，就代表这个方法名  
     PHP_OS  UNIX或WINNT等  执行PHP解析的操作系统名称  
     PHP_VERSION  5.2.6等  当前PHP服务器的版本  
     TRUE  TRUE  代表布尔值，真  
     FALSE  FALSE  代表布尔值，假  
     NULL  NULL  代表空值  
     DIRECTORY_SEPARATOR  \或/  根据操作系统决定目录的分隔符  
     PATH_SEPARATOR  ；或：  根据操作系统决定环境变量的目录列表分隔符  
     E_ERROR  1  错误，导致PHP脚本运行终止  
     E_WARNING  2  警告，不会导致PHP脚本运行终止  
     E_PARSE  4  解析错误，由程序解析器报告  
     E_NOTICE  8  关键的错误，例如变量末初始化  
     M_PI  3.1415926535898  Π  
*** 运算符 
**** 算术运算符 
      闰年   if(($year%4 == 0 && $year%100 != 0) || ($year%400 == 0))
***** 递增运算符
     $a=10;  //声明一个整型变量$a，值为10
     $b=$a++; //采用反缀模式将$a自增1
     $a的值为11，而$b的值为10。首先将$a的值赋给$b，然后将$a的值加1。
     
     $a=10;  //声明一个整型变量$a，值为10
     $b=++$a; //采用前缀模式将$a自增1
     
     $a和$b的值都是11，即首先将$a的值加1，然后将$a的值赋给$b。
**** 字符串运算符 
     . 号
**** 赋值运算符 
     =     
     +=    
     -=
     *=
     /=
     %=
     .=
**** 比较运算符 
     >    
     <    
     >= 
     <= 
     == 
     ===
     <>或!=
     !==
**** 逻辑运算符 
     and或&&    
     or或||
     not或！
     xor 
**** 位运算符 
     &     
     ｜
     ^
     ~
     <<
     >>
**** 其他运算符 
     (expr1) ? (expr2) : (expr3)                             //三元运算符
     执行运算符（``） 
     错误控制运算符 $my_file = @file ('non_existent_file'); //将其放置在一个PHP表达式之前
**** 表达式 
** PHP的语言结构 
*** 分支结构 
***** 单一条件分支结构（if） 
***** 双向条件分支结构（else子句） 
***** 多向条件分支结构（elseif子句） 
***** 多向条件分支结构（switch语句） 
***** 巢状条件分支结构 
***** 条件分支结构应用实例（简单计算器） 
*** 循环结构 
***** while语句 
***** do…while循环 
***** for语句 
***** 特殊的流程控制语句 
*** PHP中的函数 
***** 函数的定义 
    #+BEGIN_SRC php
 function 函数名 ([参数1, 参数2, … 参数n])
       函数体;
}
    #+END_SRC

***** 自定义函数 
***** 函数的工作原理和结构化编程 
***** PHP变量的范围 
***** 参数的传递 
***** 变量函数 
***** 递归函数 
***** 使用自定义函数库 
      使用require语句包含并执行config.php文件
      include_once()和require_once()语句也是在脚本执行期间包括并运行指定文件。
***** 使用系统函数库 
** PHP中的数组与数据结构 
*** 数组的定义 
*** 多维数组的声明 
#+BEGIN_SRC php
$contact1 = array(
                   array(1, '高某', 'A公司', '北京市', '(010)98765432', 'gm@linux.com'),
                   array(2, '洛某', 'B公司', '上海市', '(021)12345678', 'lm@apache.com'),
                   array(3, '峰某', 'C公司', '天津市', '(022)24680246', 'fm@mysql.com'),
                   array(4, '书某', 'D公司', '重庆市', '(023)13579135', 'sm@php.com')
           );


#+END_SRC
*** 数组的遍历 
**** 使用for语句循环遍历数组 
**** 使用foreach语句遍历数组 
**** 联合使用list( )、each( )和while循环遍历数组 
**** 使用数组的内部指针控制函数遍历数组 
*** 预定义数组 
**** 服务器变量：$_SERVER 
**** 环境变量：$_ENV 
**** HTTP GET变量：$_GET 
**** HTTP POST变量：$_POST 
**** request变量：$_REQUEST 
此关联数组包含$_GET，$_POST和$_COOKIE中的全部内容。
**** HTTP文件上传变量：$_FILES 
     使用表单的file输入域上传文件时，必须使用POST提交。但在服务器文件中，并不能通过$_POST超全局数组获取到表单中file域的内容。
     $_FILES是一个二维数组，包含5个子数组元素，其中第一个下标是表单中file输入域的名称，第二个下标用于描述上传文件
     的属性。具体文件上传的说明将在后面文件处理的章节中使用大篇幅介绍。

**** HTTP Cookies：$_COOKIE  经由HTTP Cookies方法提交至脚本的变量
     $_COOKIE超全局数组是经由HTTP Cookies方法提交至脚本的变量。通常这些Cookies是由以前执行的PHP脚本通
     过setCookie()函数设置到客户端浏览器中的，当PHP脚本从客户浏览器提取了一个cookie后，它将自动地把它转换
     成一个变量，可以通过这个$_COOKIE超全局数组和cookie的名称来存取指定的cookie值。具体cookie的应用和
     $_COOKIE超全局数组的使用，将在后面会话控制的章节中使用大篇幅介绍。
**** Session变量：$_SESSION 
     在PHP5中，会话控制是在服务器端使用session跟踪用户。当服务器页面中使用session_start()函数打开session
     后，就可以使用$_SESSION数组注册全局变量，用户就可以在整个网站中访问这些会话信息。如何使用
     $_SESSION数组注册全局变量，和$_COOKIE数组一起将在后面会话控制的章节中使用大篇幅介绍。
**** Global变量：$GLOBALS 
$GLOBALS是由所有已定义的全局变量组成的数组，变量名就是该数组的索引。在所有的脚本中都有效，在函数或
对象的方法中不需要使用global关键字访问它。所以在函数中使用函数外部声明的全局变量时，可以使用
$_GLOBALS数组替代global关键字。代码如下所示：


<?php
        $a = 1;                 //声明一个全局变量$a，初始值为1
        $b = 2;                 //声明一个全局变量$b, 初始值为2

        function Sum() {        //声明一个函数Sum()，在函数体中使用全局变量$a和$b
           $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];       //使用$_GLOBALS数组访问全局变量
        }
 
*** 数组的相关处理函数 
**** 数组的键/值操作函数 
***** array_values() 返回数组中所有元素的值
***** array_keys() 返回数组中所有的键名
      array  array_keys ( array input [, mixed search_value [, bool strict]] )
      
      如果指定了可选参数search_value，则只返回指定该值的键名，否则input数组中的所有键名都会被返回。
     #+BEGIN_SRC php
       $lamp=array("a"=>"Linux","b"=>"Apache","c"=>"MySQL","d"=>"PHP");  //只使第一个必需的参数
       $a=array(10,20,30,"10");                //声明一个数组，其中元素的值有整数10和字符串”10”
       print_r(array_keys($a,"10",false));     //使用第三个参数 (false)输出：Array ( [0] => 0 [1] => 3 )

       $a=array(10,20,30,"10");                //声明一个数组，其中元素的值有整数10和字符串”10”
       print_r(array_keys($a,"10",true));      //使用第三个参数 (true)输出：Array ( [0] => 3) 
     #+END_SRC 
***** in_array()函数的作用是检查数组中是否存在某个值，即在数组中搜索给定的值。本函数中有三个参数，前两个参数
bool  in_array ( mixed needle, array haystack [, bool strict] )
如果needle参数是字符串， 且strict参数设置为TRUE，则搜索区分大小写。函数array_keys()使用的代码如下所示：
***** array_flip()的作用是交换数组中的键和值。
***** array_reverse()作用是将原数组中的元素顺序翻转，创建新的数组并返回。
      第二个参数是可选项，如果指定为TRUE，则元素的键名保持不变，否则键名将丢失。
      
**** 统计数组元素的个数和唯一性 
***** int count ( mixed var [, int mode] )
      第二个参数是可选的，规定函数的模式是否递归地计算多维数组中的数组的元素个数。可能的值是0和1，0为默认值，不检测多维数组，1则检测多维数组。
***** array_count_values()函数用于统计数组中所有值出现的次数
***** array_unique()函数用于删除数组中重复的值，并返回没有重复值的新数组
**** 使用回调函数处理数组的函数 
***** array_fileter()函数用回调函数过滤数组中的元素，返回按用户自定义函数过滤后的新数组
      array array_filter ( array input [, callback callback] )
该函数的第一个参数是必选项，要求输入一个被过滤的数组。第二个参数是可选项，将用户自定义的函数名以字符
串形式传入。如果自定义过滤函数返回true，则被操作的数组的当前值就会被包含在返回的结果数组中，并将结果
组成一个新的数组。如果原数组是一个关联数组，键名保持不变。函数array_filter()使用的代码如下所示：

        function myFun($var){                                           //自定义函数myFun，如果参数能被2整除则返回真
                if($var % 2 == 0)
                        return true;
        }

        $array = array("a"=>1, "b"=>2, "c"=>3, "d"=>4, "e"=>5);          //声明值为整数序列的数组
     //使用函数array_filter()将自定义的函数名以字符串的形式传给第二个参数
        print_r(array_filter($array, "myFun"));                         //过滤后的结果输出Array ( [b] => 2 [d] => 4 )
?>

在上面的代码中，array_filter()函数依次将$array数组中的每个值传递到myFun()函数中，如果myFun()函数返回
TRUE，则$array数组的当前值会被包含在返回的结果数组中，并将结果组成一个新的数组返回。


***** array_walk()函数对数组中的每个元素应用回调函数处理。如果成功则返回TRUE，否则返回FALSE。该函数有三个
      bool array_walk ( array &array, callback funcname [, mixed userdata] )

该函数的第一个参数是必选项，要求输入一个被指定的回调函数处理的数组。第二个参数也是必选项，传入用户定
义的回调函数，用于操作传入第一个参数的数组。array_walk()函数依次将第一个参数的数组中的每个值传递到这
个自定义的函数中。自定义的这个回调函数中应该接收两个参数，依次传入进来元素的值作为第一个参数，键名作
为第二个参数。如果在array_walk()函数中提供可选的第三个参数，也将被作为回调函数的第三个参数接收。

如果自定义的回调函数需要的参数比给出得多，则每次array_walk()调用回调函数时都会产生一个E_WARNING级的
错误。这些警告可以通过在array_walk()调用前加上PHP的错误操作符@来抑制，或者用error_reporting()。

如果回调函数需要直接作用于数组中的值，可以将回调函数的第一个参数指定为引用：&$value。函数array_walk
()使用的代码如下所示：


<?php
        function myFun1($value,$key) {                                          //定义一个回调函数接收两个参数
                echo "The key $key has the value $value<br>";                     //将参数连接在一起输出
        }

        $lamp=array("a"=>"Linux","b"=>"Apache","c"=>"Mysql","d"=>"PHP");    //定义一个数组$lamp
        array_walk($lamp,"myFun1");                     //使用array_walk函数传入一个数组和一个回调函数
        /*  执行后输出如下结果：
            The key a has the value Linux
            The key b has the value Apache
            The key c has the value MySQL
            The key d has the value PHP */

        function myFun2($value,$key,$p)  {              //自定义一个回调函数需要接受三个参数
                echo "$key $p $value <br>";             //将三个参数连接后输出
        }
        
        array_walk($lamp,"myFun2","has the value");     //使用array_walk函数传入三个参数
        /*执行后输出如下结果：
          a has the value Linux
          b has the value Apache
          c has the value MySQL
       d has the value PHP     */

        function myFun3(&$value,$key) {                     //改变量组元素的值（请注意 &$value传入引用）
                $value="Web";                           //将改变原数组中每个元素的值
        }

        array_walk($lamp,"myFun3");                     //使用array_walk函数传入两个参数，其中第一个参数为引用
        print_r($lamp);                                 //输出：Array ( [a] => Web [b] => Web [c] => Web [d] => Web )
?>

***** 函数array_map() 
与上一个array_walk()函数相比，array_map()函数将更加灵活，并且可以处理多个数组。将回调函数作用到给定数
组的元素上，返回用户自定义函数作用后的数组。array_map()是任意参数列表函数，回调函数接受的参数数目应该
和传递给array_map()函数的数组数目一致。其函数的原型如下：
**** 数组的排序函数 
*****      sort()  按由小到大的升序对给定数组的值排序  
       ( array &array [, int sort_flags] )

第一个参数是必需的，指定需要排序的数组。后一个参数是可选的，给出了排序的方式，可以用以下值改变排序的
行为：

       SORT_REGULAR–是默认值，将自动识别数组元素的类型进行排序。
 SORT_NUMERIC–用于数字符素的排序。
 SORT_STRING–用于字符串元素的排序。
 SORT_LOCALE_STRING-根据当前的locale设置来把元素当做字符串比较。
 
 rsort  对数组的元素按照键值进行由大到小的逆向排序  
 usort()  使用用户自定义的回调函数对数组排序  
***** 根据元素的值对数组排序 
 asort()  对数组进行由小到大排序并保持索引关系  
 arsort()  对数组进行由大到小的逆向排序并保持索引关系  
 uasort()  使用用户自定义的比较回调函数对数组中的值进行排序并保持索引关联  
      $data = array("l"=>"Linux", "a"=>"Apache","m"=>"MySQL","p"=>"PHP");
        
        asort($data);           //使用asort()函数将数组$data按元素的值升序排序，并保留原有的键名和值
        print_r($data);         //输出：Array ( [a] => Apache [l] => Linux [m] => MySQL [p] => PHP )

        arsort($data);          //使用arsort()函数将数组$data按元素的值降序排序，并保留原有的键名和值
        print_r($data);         //输出：Array ( [p] => PHP [m] => MySQL [l] => Linux [a] => Apache )
    
***** 根据键名对数组排序 
 ksort()  按照键名对数组进行由小到大的排序，为数组值保留原来的键  
 krsort()  将数组按照由大到小的键逆向排序，为数组值保留原来的键  
 uksort()  使用用户自定义的比较回调函数对数组中的键名进行排序  
 
***** 根据“自然排序”法对数组排序 
 natsort()  用自然顺序算法对给定数组中的元素排序  
 natcasesort()  用不区分大小写的自然顺序算法对给定数组中的元素排序  
         $data = array("file1.txt", "file11.txt", "File2.txt", "FILE12.txt", "file.txt");
        
        natsort($data);         //普通的“自然排序”
        print_r($data);         //输出排序后的结果，数组中包括大小写，输出不是正确的排序结果

        natcasesort($data);     //忽略大小写的“自然排序”
        print_r($data);         //输出“自然排序”后的结果，正常结果
?

***** 根据用户自定的规则对数组排序 

PHP也能让你定义自己的排序算法，以进行更复杂的排序操作。提供了可以通过创建你自己的比较函数作为回调函
数的数组排序函数，包括usort()、uasort()和uksort等函数。它们的使用格式一样，并具有相同的参数列表，区别
在于对键还是值进行排序。其函数的原型分别如下：


bool usort ( array &array, callback cmp_function )
bool uasort ( array &array, callback cmp_function )
bool uksort ( array &array, callback cmp_function )
#+BEGIN_SRC php
        $lamp = array("Linux", "Apache", "MySQL", "PHP");       //声明一个数组，其中元素值的长度不相同

        usort($lamp, "sortByLen");              //使用usort()函数传入用户自定义的回调函数进行数组排序
        print_r($lamp);         // 排序后输出：Array ( [0] => PHP [1] => MySQL [2] => Linux [3] => Apache )
        
        function sortByLen($one, $two) {           //自定义的函数作为回调用函数提供给usort()函数使用
                if (strlen($one) == strlen($two))  //如果两个参数长度相等返回0，在数组中的位置不变
                        return 0;
                else            //第一个参数大于第二个参数返回大于0的数，否则返回小于0的数
                        return (strlen($one) > strlen($two)) ? 1 : -1;
        }
?>


#+END_SRC

***** 多维数组的排序 
 array_multisort()  对多个数组或多维数组进行排序  
 PHP也允许在多维数组上执行一些比较复杂的排序。例如，首先对一个嵌套数组使用一个普通的键值进行排序，然
后再根据另一个键值进行排序。这与使用SQL的ORDER BY语句对多个字段进行排序非常相似。可以使用
array_multisort()函数对多个数组或多维数组进行排序，或者根据某一维或多维对多维数组进行排序。其函数的原
型分别如下：


bool array_multisort ( array ar1 [, mixed arg [, mixed ... [, array ...]]] )

该函数如果成功则返回TRUE，失败则返回FALSE。第一个参数是要排序的主要数组。数组中的值比较为相同的话，
就按照下一个输入数组中相应值的大小来排序，依此类推。函数array_multisort()使用的代码如下所示：


<?php
        $data = array(                          //声明一个$data数组，仿真了一个行和列数组
                        array("id" => 1, "soft" => "Linux", "rating" => 3),
                        array("id" => 2, "soft" => "Apache", "rating" => 1),
                        array("id" => 3, "soft" => "MySQL", "rating" => 4),
                        array("id" => 4, "soft" => "PHP", "rating" => 2),
                );
        //使用foreach遍历创建两个数组作为array_multisort的参数
        foreach ($data as $key => $value) {
                $soft[$key] = $value["soft"];     //将$data中的每个数组元素中键值为soft的值形成数组$soft
                $rating[$key] = $value["rating"]; //将每个数组元素中键值为rating的值形成数组$rating
        }

        array_multisort($rating, $soft, $data);  //使用array_multisort()函数传入三个数组进行排序
        print_r($data);                          //输出排序后的二维数组
?>


**** 拆分、合并、分解和接合数组 
***** 函数array_slice() 
array_slice()函数的作用是在数组中根据条件取出一段值并返回。如果数组有字符串键，所返回的数组将保留键名。
该函数可以设置四个参数，其函数的原型如下：


**** 数组与数据结构 
**** 其他有用的数组处理函数 
** PHP面向对象的程序设计 

 1 8.1　面向对象的介绍 

 1 8.1.1　类和对象之间的关系 
 2 8.1.2　面向对象的程序设计 

 2 8.2　如何抽象一个类 

 1 8.2.1　类的声明 
 2 8.2.2　成员属性 
 3 8.2.3　成员方法 

 3 8.3　通过类实例化对象 

 1 8.3.1　创建对象 
 2 8.3.2　对象类型在内存中的分配 
 3 8.3.3　对象中成员的访问 
 4 8.3.4　特殊的对象引用“$this” 
 5 8.3.5　构造方法与析构方法 

 4 8.4　封装性 

 1 8.4.1　设置私有成员 
 2 8.4.2　私有成员的访问 
 3 8.4.3　__set()、__get()、__isset()和__unset()四个方法 

 5 8.5　继承性 

 1 8.5.1　类继承的应用 
 2 8.5.2　访问类型控制 
 3 8.5.3　子类中重载父类的方法 

 6 8.6　常见的关键字和魔术方法 

 1 8.6.1　final关键字的应用 
 2 8.6.2　static和const关键字的使用 
 3 8.6.3　克隆对象 
 4 8.6.4　类中通用的方法__toString() 
 5 8.6.5　通过__call()方法处理错误调用 
 6 8.6.6　自动加载类 
 7 8.6.7　对象串行化 

 7 8.7　抽象类与接口 

 1 8.7.1　抽象方法和抽象类 
 2 8.7.2　接口技术 

 8 8.8　多态性的应用 
 9 8.9　小结 
 10 自测题 

17 第9章　字符串处理与正则表达式 

 1 9.1　字符串的处理介绍 

 1 9.1.1　字符串的处理方式 
 2 9.1.2　字符串类型的特点 

 2 9.2　常用的字符串输出函数 
 3 9.3　常用的字符串格式化函数 

 1 9.3.1　去除空格和字符串填补函数 
 2 9.3.2　字符串大小写的转换 
 3 9.3.3　和HTML标签相关的字符串格式化 
 4 9.3.4　其他字符串格式化函数 

 4 9.4　字符串比较函数 

 1 9.4.1　按字节顺序进行字符串比较 
 2 9.4.2　按自然排序进行字符串比较 

 5 9.5　正则表达式在字符串处理中的应用 

 1 9.5.1　正则表达式简介 
 2 9.5.2　正则表达式的语法规则 

 6 9.6　与Perl兼容的正则表达式函数 

 1 9.6.1　字符串的匹配与查找 
 2 9.6.2　字符串的替换 
 3 9.6.3　字符串的分割和连接 

 7 9.7　文章发布操作示例 
 8 9.8　小结 
 9 自测题 
 10 10.3　动态图像处理 

 1 10.3.1　PHP中GD库的使用 
 2 10.3.2　画布管理 
 3 10.3.3　设置颜色 
 4 10.3.4　生成图像 
 5 10.3.5　绘制图像 
 6 10.3.6　在图像中绘制文字 
 7 10.3.7　在PHP中实现验证码类的设计 

 11 10.4　小结 
 12 自测题 

18 第10章　PHP常用功能模块 

 1 10.1　错误和异常处理 

 1 10.1.1　错误类型和基本的调试方法 
 2 10.1.2　错误日志 
 3 10.1.3　异常处理 

 2 10.2　日期和时间 

 1 10.2.1　UNIX时间戳 
 2 10.2.2　在PHP中获取日期和时间 
 3 10.2.3　日期和时间格式化输出 
 4 10.2.4　修改PHP的默认时区 
 5 10.2.5　使用微秒计算PHP脚本执行时间 

19 第11章　文件系统处理 

 1 11.1　文件系统概述 

 1 11.1.1　文件类型 
 2 11.1.2　文件的属性 

 2 11.2　目录的基本操作 

 1 11.2.1　解析目录路径 
 2 11.2.2　遍历目录 
 3 11.2.3　统计目录大小 
 4 11.2.4　建立和删除目录 
 5 11.2.5　复制或移动目录 

 3 11.3　文件的基本操作 

 1 11.3.1　文件的打开与关闭 
 2 11.3.2　写入文件 
 3 11.3.3　读取文件内容 
 4 11.3.4　访问远程文件 
 5 11.3.5　移动文件指针 
 6 11.3.6　文件的锁定机制 
 7 11.3.7　文件的一些基本操作函数 

 4 11.4　文件的上传与下载 

 1 11.4.1　文件上传 
 2 11.4.2　处理多个文件上传 
 3 11.4.3　文件下载 

 5 11.5　文件系统项目实例 

 1 11.5.1　功能分析 
 2 11.5.2　系统功能设计 
 3 11.5.3　实例代码实现 

 6 11.6　小结 
 7 自测题 
 8 12.4　SQL语言设计 

 1 12.4.1　执行DDL命令操作数据对象 
 2 12.4.2　使用DML命令操作数据表中的数据记录 
 3 12.4.3　通过DQL命令查询数据表中的数据 

 9 12.5　使用PHP脚本向MySQL服务器发送SQL 

 1 12.5.1　在PHP脚本中连接MySQL服务器 
 2 12.5.2　在PHP程序中选择已创建的数据库 
 3 12.5.3　执行SQL命令 
 4 12.5.4　在PHP脚本中处理SELECT查询结果集 

 10 12.6　小结 
 11 自测题 

20 第12章　MySQL数据库设计 

 1 12.1　MySQL数据库管理 

 1 12.1.1　数据库管理系统 
 2 12.1.2　结构化查询语言SQL 
 3 12.1.3　MySQL数据库的连接与关闭 
 4 12.1.4　创建、选择及查看数据库 

 2 12.2　MySQL数据库中数据表的设计 

 1 12.2.1　数据表（Table） 
 2 12.2.2　数据值和列类型 
 3 12.2.3　数据字段属性 
 4 12.2.4　创建、修改及删除表 
 5 12.2.5　数据表的类型及存储位置 
 6 12.2.6　数据表的默认字符集 
 7 12.2.7　创建索引 
 8 12.3　数据库的设计步骤 
 9 12.3.1　需求分析 
 10 12.3.2　概念设计 
 11 12.3.3　逻辑设计 

21 第13章　PHP的mysqli扩展 

 1 13.1　启用mysqli扩展模块 
 2 13.2　使用mysqli类 

 1 13.2.1　连接MySQL服务器 
 2 13.2.2　处理连接错误报告 
 3 13.2.3　关闭与MySQL服务器连接 
 4 13.2.4　执行SQL命令 

 3 13.3　使用mysqli_result类 

 1 13.3.1　创建结果集对象 
 2 13.3.2　回收查询内存 
 3 13.3.3　从结果集中解析数据 
 4 13.3.4　从结果集中获取数据列的信息 
 5 13.3.5　一次执行多条SQL命令 

 4 13.4　使用mysqli_stmt类 

 1 13.4.1　获取预处理语句对象 
 2 13.4.2　绑定参数 
 3 13.4.3　执行准备好的语句 
 4 13.4.4　回收资源 
 5 13.4.5　简单的示例分析 
 6 13.4.6　使用预处理语句处理SELECT查询结果 

 5 13.5　数据库事务 

 1 13.5.1　事务处理 
 2 13.5.2　构建事务应用程序 

 6 13.6　MVC模式实现商品管理系统 

 1 13.6.1　MVC设计模式 
 2 13.6.2　商品管理系统的设计与实现 

 7 13.7　小结 
 8 自测题 

22 第14章　数据库抽象层PDO 

 1 14.1　PDO所支持的数据库 
 2 14.2　PDO的安装 
 3 14.3　创建PDO对象 

 1 14.3.1　以多种方式调用构造方法 
 2 14.3.2　PDO对象中的成员方法 

 4 14.4　使用PDO对象 

 1 14.4.1　调整PDO的行为属性 
 2 14.4.2　PDO处理PHP程序和数据库之间的数据类型转换 
 3 14.4.3　PDO的错误处理模式 
 4 14.4.4　使用PDO执行SQL语句 

 5 14.5　PDO对预处理语句的支持 

 1 14.5.1　了解PDOStatement对象 
 2 14.5.2　准备语句 
 3 14.5.3　绑定参数 
 4 14.5.4　执行准备好的查询 
 5 14.5.5　获取数据 
 6 14.5.6　大数据对象的存取 

 6 14.6　PDO的事务处理 
 7 14.7　小结 
 8 自测题 

23 第15章　会话控制 

 1 15.1　为什么要使用会话控制 
 2 15.2　会话跟踪的方式 
 3 15.3　Cookie的应用 

 1 15.3.1　Cookie概述 
 2 15.3.2　向客户端电脑中设置Cookie 
 3 15.3.3　在PHP脚本中读取Cookie的资料内容 
 4 15.3.4　数组形态的Cookie应用 
 5 15.3.5　删除Cookie 
 6 15.3.6　基于Cookie的用户登录模块 

 4 15.4　Session的应用 

 1 15.4.1　Session概述 
 2 15.4.2　配置Session 
 3 15.4.3　Session的声明与使用 
 4 15.4.4　注册一个会话变量和读取Session 
 5 15.4.5　注销变量与销毁Session 
 6 15.4.6　传递Session ID 

 5 15.5　一个简单的邮件系统 

 1 15.5.1　为邮件系统准备数据 
 2 15.5.2　编码实现邮件系统 
 3 15.5.3　邮件系统执行说明 

 6 15.6　小结 
 7 自测题 
 8 16.6　Smarty模板中的程序逻辑 

 1 16.6.1　模板中的注释 
 2 16.6.2　模板中变量的声明 
 3 16.6.3　在模板中输出从PHP分配的变量 
 4 16.6.4　模板中变量的数学计算 
 5 16.6.5　在模板中使用{$smarty}保留变量 
 6 16.6.6　变量调解器 
 7 16.6.7　模板的控制结构 
 8 16.6.8　在模板中包含子模板 

 9 16.7　为Smarty模板创建配置文件 

 1 16.7.1　配置文件语法格式 
 2 16.7.2　加载配置文件 
 3 16.7.3　引用配置文件中的变量 

 10 16.8　Smarty处理页面缓存 

 1 16.8.1　在Smarty中控制缓存 
 2 16.8.2　每个页面多个缓存 
 3 16.8.3　为缓存实例消除处理开销 
 4 16.8.4　清除缓存 
 5 16.8.5　关闭局部缓存 

 11 16.9　应用Smarty实现分页示例 

 1 16.9.1　准备工作 
 2 16.9.2　设计数据库操作类 
 3 16.9.3　设计分页操作类 
 4 16.9.4　PHP的程序逻辑层 
 5 16.9.5　Smarty模板的表现层 

 12 16.10　小结 
 13 自测题 

24 第16章　PHP的模板技术Smarty 

 1 16.1　什么是模板引擎 
 2 16.2　编写自己的模板引擎 

 1 16.2.1　创建自己的模板引擎类 
 2 16.2.2　使用自己的模板引擎 
 3 16.2.3　自定义模板的使用示例分析 

 3 16.3　选择Smarty模板引擎 
 4 16.4　安装Smarty及初始化配置 

 1 16.4.1　安装Smarty 
 2 16.4.2　初始化Smarty类库的默认设置 
 3 16.4.3　第一个Smarty的简单示例 

 5 16.5　Smarty在应用程序逻辑层的使用步骤 

25 第17章　内容管理系统（CMS） 

 1 17.1　Web软件开发流程概述 

 1 17.1.1　Web开发团队的成员 
 2 17.1.2　Web软件开发流程 
 3 17.1.3　项目开发规范 

 2 17.2　需求分析 

 1 17.2.1　CMS简介 
 2 17.2.2　用户行为分析 
 3 17.2.3　系统目标 
 4 17.2.4　系统特点 

 3 17.3　系统功能预览 

 1 17.3.1　CMS系统安装 
 2 17.3.2　登录管理平台 
 3 17.3.3　常规设置管理 
 4 17.3.4　友情链接管理 
 5 17.3.5　图片管理 
 6 17.3.6　栏目管理 
 7 17.3.7　文章管理 
 8 17.3.8　用户管理 
 9 17.3.9　网站首页 
 10 17.3.10　文章列表页面 
 11 17.3.11　文章内容页面 

 4 17.4　数据库设计 

 1 17.4.1　数据库需求分析 
 2 17.4.2　数据表关系 

 5 17.5　系统架构 

 1 17.5.1　系统体系结构 
 2 17.5.2　管理平台的文件结构 
 3 17.5.3　网站前台模板风格的文件结构 

 6 17.6　常用的功能模块开发 

 1 17.6.1　系统安装模块设计 
 2 17.6.2　管理平台（后台）的模块设计 
 3 17.6.3　无限分类模块设计 
 4 17.6.4　网站首页面的设计 

 7 17.7　小结 

26 附录A　PHP配置文件详解 
27 反侵权盗版声明 
***** 
* php语言
  特性标记<?PHP ?>
** 数据 
*** 定义   
   object array resource 
   $bar = &$foo;                       //这是一个有效的引用赋值
*** 预定义常量/变量数据
**** 定义常量 
     常量和变量的区别之一是 没有 $
     define("const",33);
**** 预定义常量/变量
***** web端     
****** 服务器数据 $_SERVER
	   $_SERVER["SERVER_PORT"]  //获取端口  
	   $_SERVER['HTTP_HOST']  	 //获取域名或主机地址 如test.cn
     $_SERVER['SERVER_NAME']  //获取域名或主机地址 注：只是主域名如test.cn
	   $_SERVER["REQUEST_URI"]  //获取域名后的详细地址 如：/index.php?id=123 ...  
	 !!!  $_SERVER['SERVER_ROOT']  //请求的网页主目录, 好像没用了
     $_SERVER['SCRIPT_NAME']  //包含当前脚本的路径
     $_SERVER['PHP_SELF']  //获取PHP文件名 
	   $_SERVER["QUERY_STRING"]  //获取PHP后的网址参数  
	   $_SERVER['HTTP_REFERER']  //来源网页的详细地址  
     $_SERVER['REMOTE_ADDR'] #正在浏览当前页面用户的 IP 地址。
     $_SERVER['REMOTE_HOST'] #正在浏览当前页面用户的主机名。
     $_SERVER['REMOTE_PORT'] #用户连接到服务器时所使用的端口。
     $_SERVER['PHP_SELF']//正在执行脚本的文件名
     $_SERVER['argv'] //传递给该脚本的参数。
     $_SERVER['argc'] //传递给程序的命令行参数的个数。
     $_SERVER['GATEWAY_INTERFACE']//CGI 规范的版本。
     $_SERVER['SERVER_SOFTWARE'] //服务器标识的字串
     $_SERVER['SERVER_PROTOCOL'] //请求页面时通信协议的名称和版本
     $_SERVER['REQUEST_METHOD']//访问页面时的请求方法
     $_SERVER['REQUEST_URI'] //URL路径
     $_SERVER['QUERY_STRING'] //查询(query)的字符串。
     $_SERVER['DOCUMENT_ROOT'] //当前运行脚本所在的文档根目录
     $_SERVER['HTTP_ACCEPT'] //当前请求的 Accept: 头部的内容。
     $_SERVER['HTTP_ACCEPT_CHARSET'] //当前请求的 Accept-Charset: 头部的内容。
     $_SERVER['HTTP_ACCEPT_ENCODING'] //当前请求的 Accept-Encoding: 头部的内容
     $_SERVER['HTTP_ACCEPT_LANGUAGE'];//浏览器语言
     $_SERVER['HTTP_CONNECTION'] //当前请求的 Connection: 头部的内容。例如：“Keep-Alive”。
     $_SERVER['HTTP_HOST'] //获取当前程序所在主机,当前请求的 Host: 头部的内容。
     $_SERVER['HTTP_REFERER'] //链接到当前页面的前一页面的 URL 地址。
     $_SERVER['HTTP_USER_AGENT'] //当前请求的 User_Agent: 头部的内容。
     $_SERVER['HTTPS']//如果通过https访问,则被设为一个非空的值(on)，否则返回off
     $_SERVER['SCRIPT_FILENAME'] #当前执行脚本的绝对路径名。
     $_SERVER['SERVER_ADMIN'] #管理员信息
     $_SERVER['SERVER_PORT'] #服务器所使用的端口
     $_SERVER['SERVER_SIGNATURE'] #包含服务器版本和虚拟主机名的字符串。
     $_SERVER['PATH_TRANSLATED'] #当前脚本所在文件系统（不是文档根目录）的基本路径。
     $_SERVER['SCRIPT_NAME'] #包含当前脚本的路径。这在页面需要指向自己时非常有用。
     $_SERVER['PHP_AUTH_USER'] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。
     $_SERVER['PHP_AUTH_PW'] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。
     $_SERVER['AUTH_TYPE'] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型
****** $_SESSION 会话
****** __FILE__ 文件路径
       __line__ 文件中的当前行号
****** 客户机数据 $_POST  $_GET 
***** console端
      环境变量
****** 命令行 $argc $argv
*** 数据影响区域
**** local 函数内部
**** global 整个项目
     $var= $GLOBALS["var"] === global $var(建立一个引用,不能赋值)
**** static（静态）
** 函数 
*** 定义 
    function($arr)   传递值
    function add_some_extra(&$string) 传递引用
    function &functionname  引用返回
*** 内部函数、扩展函数
*** 类型相关操作
    类型比较 is_number instanceof(继承也可以, 对类和接口）跟 is_a 一样的功能
**** 变量存在
     PHP 判断常量,变量和函数是否存在
     if (defined('CONST_NAME')) {
     //do something 
     }

     变量检测则是使用isset，注意变量未声明或声明时赋值为NULL，isset均返回FALSE，如：

     if (isset($var_name)) {
     //do something
     }
     函数检测用function_exists，注意待检测的函数名也需要使用引号，如：
     复制代码 代码如下:

     if (function_exists('fun_name')) {
     fun_name();
     }
 
     先不说多了我们看一个实例
     复制代码 代码如下:

     <?php 
     /* 判断常量是否存在*/ 
     if (defined('MYCONSTANT')) { 
     echo MYCONSTANT; 
     } 
     //判断变量是否存在 
     if (isset($myvar)) { 
     echo "存在变量$myvar."; 
     } 
     //判断函数是否存在 
     if (function_exists('imap_open')) { 
     echo "存在函数imag_openn"; 
     } else { 
     echo "函数imag_open不存在n"; 
     } 
     ?>
 
     function_exists判断函数是否存在
     复制代码 代码如下:

     <?php
     if (function_exists('test_func')) {
     echo "函数test_func存在";
     } else {
     echo "函数test_func不存在";
     }
     ?>
 
     filter_has_var函数
     filter_has_var() 函数检查是否存在指定输入类型的变量。
     若成功，则返回 true，否则返回 false。

     复制代码 代码如下:

     <?php
     if(!filter_has_var(INPUT_GET, "name"))
     {
     echo("Input type does not exist");
     }
     else
     {
     echo("Input type exists");
     }
     ?>  

     输出为. Input type exists

     获取文件名(去除后缀) mb_substr($filename,0,mb_strpos($filename,'.'),"utf8");
     $path_parts ['dirname'] = rtrim(substr($filepath, 0, strrpos($filepath, '/')),"/")."/";   
     $path_parts ['basename'] = ltrim(substr($filepath, strrpos($filepath, '/')),"/");   
     $path_parts ['extension'] = substr(strrchr($filepath, '.'), 1);   
 
*** 库函数
**** array 
	   foreach($array as $key=>$value){}遍历数组
	   each() 函数返回当前元素的键名和键值，并将内部指针向前移动。
	   该元素的键名和键值会被返回带有四个元素的数组中。两个元素（1 和 Value）包含键值，两个元素（0 和 Key）包含键名。
	   array()创建数组
	   current() - 返回数组中的当前元素的值
	   end() - 将内部指针指向数组中的最后一个元素，并输出
	   next() - 将内部指针指向数组中的下一个元素，并输出
	   prev() - 将内部指针指向数组中的上一个元素，并输出
	   reset() - 将内部指针指向数组中的第一个元素，并输出
	   array_values() 函数返回一个包含给定数组中所有键值的数组，但不保留键名。
	   int count ( mixed $var [, int $mode = COUNT_NORMAL ] )统计一个数组里的所有元素，或者一个对象里的东西。
	   is_array() - 检测变量是否是数组
	   array_count_values() 返回一个数组，统计的是每个值的数量，相等，数量加１
	   array_unique(array) 删除数组中重复的值,返回新数组
	   array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )  过滤器,把每个值传给callback函数,如果返回值为真，就返回过来
	   usort()	使用用户自定义的比较函数对数组进行排序。
	   array_slice(array,start,length,preserve) 函数在数组中根据条件取出一段值，并返回。
	   array()	创建数组。
	   array_change_key_case()	把数组中所有键更改为小写或大写。
	   array_chunk()	把一个数组分割为新的数组块。
	   array_column()	返回输入数组中某个单一列的值。
	   array_combine()	通过合并两个数组来创建一个新数组。
	   array_count_values()	用于统计数组中所有值出现的次数。
	   array_diff()	比较数组，返回差集（只比较键值）。
	   array_diff_assoc()	比较数组，返回差集（比较键名和键值）。
	   array_diff_key()	比较数组，返回差集（只比较键名）。
	   array_diff_uassoc()	比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。
	   array_diff_ukey()	比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。
	   array_fill()	用给定的键值填充数组。
	   array_fill_keys()	用指定键名的给定键值填充数组。
	   array_filter()	用回调函数过滤数组中的元素。
	   array_flip()	交换数组中的键和值。
	   array_intersect()	比较数组，返回交集（只比较键值）。
	   array_intersect_assoc()	比较数组，返回交集（比较键名和键值）。
	   array_intersect_key()	比较数组，返回交集（只比较键名）。
	   array_intersect_uassoc()	比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。
	   array_intersect_ukey()	比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。
	   array_key_exists()	检查指定的键名是否存在于数组中。
	   array_keys()	返回数组中所有的键名。
	   array_map()	把数组中的每个值发送到用户自定义函数，返回新的值。
	   array_merge()	把一个或多个数组合并为一个数组。
	   array_merge_recursive()	递归地合并一个或多个数组。
	   array_multisort()	对多个数组或多维数组进行排序。
	   array_pad()	用值将数组填补到指定长度。
	   array_pop()	删除数组的最后一个元素（出栈）。
	   array_product()	计算数组中所有值的乘积。
	   array_push()	将一个或多个元素插入数组的末尾（入栈）。
	   array_rand()	返回数组中一个或多个随机的键。
	   array_reduce()	通过使用用户自定义函数，以字符串返回数组。
	   array_replace()	使用后面数组的值替换第一个数组的值。
	   array_replace_recursive()	递归地使用后面数组的值替换第一个数组的值。
	   array_reverse()	以相反的顺序返回数组。
	   array_search()	搜索数组中给定的值并返回键名。
	   array_shift()	删除数组中首个元素，并返回被删除元素的值。
	   array_slice()	返回数组中被选定的部分。
	   array_splice()	删除并替换数组中指定的元素。
	   array_sum()	返回数组中值的和。
	   array_udiff()	比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。
	   array_udiff_assoc()	比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	   array_udiff_uassoc()	比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。
	   array_uintersect()	比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。
	   array_uintersect_assoc()	比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	   array_uintersect_uassoc()	比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。
	   array_unique()	删除数组中的重复值。
	   array_unshift()	在数组开头插入一个或多个元素。
     :  int array_unshift ( array &$array , mixed $var [, mixed $... ] )
	   array_values()	返回数组中所有的值。
	   array_walk()	对数组中的每个成员应用用户函数。
	   array_walk_recursive()	对数组中的每个成员递归地应用用户函数。
	   arsort()	对关联数组按照键值进行降序排序。
	   asort()	对关联数组按照键值进行升序排序。
	   compact()	创建包含变量名和它们的值的数组。
	   count()	返回数组中元素的数目。
	   current()	返回数组中的当前元素。
	   each()	返回数组中当前的键／值对。
	   end()	将数组的内部指针指向最后一个元素。
	   extract()	从数组中将变量导入到当前的符号表。
	   in_array()	检查数组中是否存在指定的值。
     : bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )
     : 在 haystack[干草堆] 中搜索 needle[针]，如果没有设置 strict[严格的] 则使用宽松的比较。 
	   key()	从关联数组中取得键名。
	   krsort()	对数组按照键名逆向排序。
	   ksort()	对数组按照键名排序。
***** list()	把数组中的值赋给一些变量。 list($a, $b, $c)=['a', 'b', 'c'];
	   natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。
	   natsort()	用“自然排序”算法对数组排序。
	   next()	将数组中的内部指针向前移动一位。
	   pos()	current() 的别名。
	   prev()	将数组的内部指针倒回一位。
	   range()	创建包含指定范围单元的数组。
	   reset()	将数组的内部指针指向第一个元素。
	   rsort()	对数组逆向排序。
	   shuffle()	将数组打乱。
	   sizeof()	count() 的别名。
	   sort()	对数组排序。
	   uasort()	使用用户自定义的比较函数对数组中的键值进行排序。
	   uksort()	使用用户自定义的比较函数对数组中的键名进行排序。
      
     : print_r(array_filter($array1, "odd"));
**** date
	   date(Y年m月d日l星期/M英文月,而不是数字)
	   ((int)date('h')+8)时间,东八区要加8小时
	   h - 带有首位零的 12 小时小时格式
	   i - 带有首位零的分钟 (minute)
	   s - 带有首位零的秒（00 -59）(second)
	   a - 小写的午前和午后（am 或 pm）ante (before) meridiem post meridiem
	   cal_days_in_month()	针对指定的年份和历法，返回一个月中的天数。
	   cal_from_jd()	把儒略日计数转换为指定历法的日期。
	   cal_info()	返回有关指定历法的信息。
	   cal_to_jd()	把指定历法中的日期转换为儒略日计数。
	   easter_date()	返回指定年份的复活节午夜的 Unix 时间戳。
	   easter_days()	返回指定年份的复活节与 3 月 21 日之间的天数。
	   frenchtojd()	把法国共和历的日期转换成为儒略日计数。
	   gregoriantojd()	把格利高里历法的日期转换成为儒略日计数。
	   jddayofweek()	返回日期在周几。
	   jdmonthname()	返回月的名称。
	   jdtofrench()	把儒略日计数转换为法国共和历的日期。
	   jdtogregorian()	将格利高里历法转换成为儒略日计数。
	   jdtojewish()	把儒略日计数转换为犹太历法的日期。
	   jdtojulian()	把儒略日计数转换为儒略历法的日期。
	   jdtounix()	把儒略日计数转换为 Unix 时间戳。
	   jewishtojd()	把犹太历法的日期转换为儒略日计数。
	   juliantojd()	把儒略历法的日期转换为儒略日计数。
	   unixtojd()	把 Unix 时间戳转换为儒略日计数。

	   Date/Time 函数的行为受到 php.ini 中设置的影响：
	   date.timezone 	默认时区（所有的 Date/Time 函数使用该选项） 	
	   date.default_latitude 	默认纬度（date_sunrise() 和 date_sunset() 使用该选项）
	   date.default_longitude 	默认经度（date_sunrise() 和 date_sunset() 使用该选项）
	   date.sunrise_zenith 	默认日出天顶（date_sunrise() 和 date_sunset() 使用该选项）
	   date.sunset_zenith 	默认日落天顶（date_sunrise() 和 date_sunset() 使用该选项）
	   PHP 5 Date/Time 函数
	   函数 	描述
	   checkdate() 	验证格利高里日期。
	   date_add() 	添加日、月、年、时、分和秒到日期。
	   date_create_from_format() 	返回根据指定格式进行格式化的新的 DateTime 对象。
	   date_create() 	返回新的 DateTime 对象。
	   date_date_set() 	设置新日期。
	   date_default_timezone_get() 	返回由所有的 Date/Time 函数使用的默认时区。
	   date_default_timezone_set() 	设置由所有的 Date/Time 函数使用的默认时区。
	   date_diff() 	返回两个日期间的差值。
	   date_format() 	返回根据指定格式进行格式化的日期。
	   date_get_last_errors() 	返回日期字符串中的警告/错误。
	   date_interval_create_from_date_string() 	从字符串的相关部分建立 DateInterval。
	   date_interval_format() 	格式化时间间隔。
	   date_isodate_set() 	设置 ISO 日期。
	   date_modify() 	修改时间戳。
	   date_offset_get() 	返回时区偏移。
	   date_parse_from_format() 	根据指定的格式返回带有关于指定日期的详细信息的关联数组。
	   date_parse() 	返回带有关于指定日期的详细信息的关联数组。
	   date_sub() 	从指定日期减去日、月、年、时、分和秒。
	   date_sun_info() 	返回包含有关指定日期与地点的日出/日落和黄昏开始/黄昏结束的信息的数组。
	   date_sunrise() 	返回指定日期与位置的日出时间。
	   date_sunset() 	返回指定日期与位置的日落时间。
	   date_time_set() 	设置时间。
	   date_timestamp_get() 	返回 Unix 时间戳。
	   date_timestamp_set() 	设置基于 Unix 时间戳的日期和时间。
	   date_timezone_get() 	返回给定 DateTime 对象的时区。
	   date_timezone_set() 	设置 DateTime 对象的时区。
	   date() 	格式化本地日期和时间。
	   getdate() 	返回某个时间戳或者当前本地的日期/时间的日期/时间信息。
	   gettimeofday() 	返回当前时间。
	   gmdate() 	格式化 GMT/UTC 日期和时间。
	   gmmktime() 	返回 GMT 日期的 UNIX 时间戳。
	   gmstrftime() 	根据区域设置对 GMT/UTC 日期和时间进行格式化。
	   idate() 	将本地时间/日期格式化为整数。
	   localtime() 	返回本地时间。
	   microtime() 	返回当前时间的微秒数。
	   mktime() 	返回日期的 Unix 时间戳。
	   strftime() 	根据区域设置对本地时间/日期进行格式化。
	   strptime() 	解析由 strftime() 生成的时间/日期。
	   strtotime() 	将任何英文文本的日期或时间描述解析为 Unix 时间戳。
	   time() 	返回当前时间的 Unix 时间戳。
	   timezone_abbreviations_list() 	返回包含夏令时、偏移量和时区名称的关联数组。
	   timezone_identifiers_list() 	返回带有所有时区标识符的索引数组。
	   timezone_location_get() 	返回指定时区的位置信息。
	   timezone_name_from_abbr() 	根据时区缩略语返回时区名称。
	   timezone_name_get() 	返回时区的名称。
	   timezone_offset_get() 	返回相对于 GMT 的时区偏移。
	   timezone_open() 	创建新的 DateTimeZone 对象。
	   timezone_transitions_get() 	返回时区的所有转换。
	   timezone_version_get() 	返回时区数据库的版本。

**** file
	   fopen("filename",'w')  //可以指定绝对路径或相对路径
	   "r" 	只读方式打开，将文件指针指向文件头。
	   "r+" 	读写方式打开，将文件指针指向文件头。
	   "w" 	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	   "w+" 	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	   "a" 	写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	   "a+" 	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	   "x" 	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则报错.
	   basename() 	返回路径中的文件名部分。
	   chgrp() 	改变文件组。 	
	   chmod() 	改变文件模式。 
	   chown() 	改变文件所有者。 	
	   clearstatcache() 	清除文件状态缓存。 	
	   fopen() 可以通过http路径打开,可以在php.ini 中配置allow_url_fopen   //unix中要注意文件的访问权限
	   copy() 	复制文件。
	   fread(filepoint,length)	读取打开的文件。
	   fwrite(file,string,length)   
	   file_get_contents(filepath) 函数把整个文件读入一个字符串中。
	   file_put_contents(filepath,filecontent) 在ftp中要用到flags和context标志
	   basename()
	   is_readable()
	   fgets()
	   fgetss() 去掉文件中的html格式
	   readfile(filename) 输出到浏览器
	   file(file) 返回值是文件内容
	   fgetc()
	   file_exists()
	   filesize()
	   unlink() 删除文件
	   rewind()
	   fseek()
	   ftell()
	   delete() 	参见 unlink() 或 unset()。 	 
	   dirname() 	返回路径中的目录名称部分。 	
	   disk_free_space() 	返回目录的可用空间。 	
	   disk_total_space() 	返回一个目录的磁盘总容量。
	   diskfreespace() 	disk_free_space() 的别名。
	   fclose() 	关闭打开的文件。 	
	   feof() 	测试文件指针是否到了文件结束的位置。 	
	   fflush() 	向打开的文件输出缓冲内容。 
	   fgetc() 	从打开的文件中返回字符。 
	   fgetcsv() 	从打开的文件中解析一行，校验 CSV 字段。 	
	   fgets() 	从打开的文件中返回一行。 	
	   fgetss() 	从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。 	  file() 	把文件读入一个数组中。 	
	   file_exists() 	检查文件或目录是否存在。
	   file_get_contents() 	将文件读入字符串。 	
	   file_put_contents() 	将字符串写入文件。 	
	   fileatime() 	返回文件的上次访问时间。 	
	   filectime() 	返回文件的上次改变时间。 	
	   filegroup() 	返回文件的组 ID。 	
	   fileinode() 	返回文件的 inode 编号。 
	   filemtime() 	返回文件的上次修改时间。
	   fileowner() 	文件的 user ID （所有者）。
	   fileperms() 	返回文件的权限。 	
	   filesize() 	返回文件大小。 	
	   filetype() 	返回文件类型。 	
	   flock() 	锁定或释放文件。
	   fnmatch() 	根据指定的模式来匹配文件名或字符串。 	
	   fopen() 	打开一个文件或 URL。 	
	   fpassthru() 	从打开的文件中读数据，直到 EOF，并向输出缓冲写结果
	   fputcsv() 	将行格式化为 CSV 并写入一个打开的文件中。 	
	   fputs() 	fwrite() 的别名。 	
	   fread() 	读取打开的文件。 	
	   fscanf() 	根据指定的格式对输入进行解析。
	   fseek() 	在打开的文件中定位。 	
	   fstat() 	返回关于一个打开的文件的信息。
	   ftell() 	返回文件指针的读/写位置 
	   ftruncate() 	将文件截断到指定的长度。
	   fwrite() 	写入文件。 	
	   glob() 	返回一个包含匹配指定模式的文件名/目录的数组。 	
	   is_dir() 	判断指定的文件名是否是一个目录。 	
	   is_executable() 	判断文件是否可执行。 	
	   is_file() 	判断指定文件是否为常规的文件。 	
	   is_link() 	判断指定的文件是否是连接。 	
	   is_readable() 	判断文件是否可读。 	
	   is_uploaded_file() 	判断文件是否是通过 HTTP POST 上传的。 	
	   is_writable() 	判断文件是否可写。 	
	   is_writeable() 	is_writable() 的别名。 	
	   link() 	创建一个硬连接。 	
	   linkinfo() 	返回有关一个硬连接的信息。 	
	   lstat() 	返回关于文件或符号连接的信息。 	
	   mkdir() 	创建目录。 	
	   move_uploaded_file() 	将上传的文件移动到新位置。 	
	   parse_ini_file() 	解析一个配置文件。 	
	   pathinfo() 	返回关于文件路径的信息。 	
	   pclose() 	关闭有 popen() 打开的进程。 	
	   popen() 	打开一个进程。 	
	   readfile() 	读取一个文件，并输出到输出缓冲。 	
	   readlink() 	返回符号连接的目标。 	
	   realpath() 	返回绝对路径名。 	
	   rename() 	重名名文件或目录。 	
	   rewind() 	倒回文件指针的位置。 	
	   rmdir() 	删除空的目录。 	
	   set_file_buffer() 	设置已打开文件的缓冲大小。 	
	   stat() 	返回关于文件的信息。 	
	   symlink() 	创建符号连接。 	
	   tempnam() 	创建唯一的临时文件。
	   tmpfile() 	建立临时文件。 	
	   touch() 	设置文件的访问和修改时间。 	
	   umask() 	改变文件的文件权限。 	
	   unlink() 	删除文件。

	   isset(varname)判断变量是否已经配置，就是变量存不存在值
	   unset(varname)取消配置；
	   empty(varname) 对于值是0的数返回true，这里要当心

**** Directory 函数
	   chdir()	改变当前的目录。
	   chroot()	改变根目录。
	   closedir()	关闭目录句柄。
	   dir()	返回 Directory 类的实例。
	   getcwd()	返回当前工作目录。
	   opendir()	打开目录句柄。
	   readdir()	返回目录句柄中的条目。
	   rewinddir()	重置目录句柄。
	   scandir()	返回指定目录中的文件和目录的数组。
**** PHP 过滤器用于对来自非安全来源的数据（比如用户输入）进行验证和过滤。
	   filter_has_var() 	检查是否存在指定输入类型的变量。 	
	   filter_id() 	返回指定过滤器的 ID 号。 	
	   filter_input() 	从脚本外部获取输入，并进行过滤。 	
	   filter_input_array() 	从脚本外部获取多项输入，并进行过滤。 	
	   filter_list() 	返回包含所有得到支持的过滤器的一个数组。 	
	   filter_var_array() 	获取多项变量，并进行过滤。 	
	   filter_var() 	获取一个变量，并进行过滤。
**** HTTP 函数允许您在其他输出被发送之前，对由 Web 服务器发送到浏览器的信息进行操作。
	   header() 	向客户端发送原始的 HTTP 报头。
	   headers_list() 	返回已发送的（或待发送的）响应头部的一个列表。
	   headers_sent() 	检查 HTTP 报头是否发送/已发送到何处。
	   setcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie。
	   setrawcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie（不进行 URL 编码）。

**** 数学 (Math) 函数能处理 integer 和 float 范围内的值。
	   abs() 	绝对值。 	
	   acos() 	反余弦。 	
	   acosh() 	反双曲余弦。 	
	   asin() 	反正弦。 	
	   asinh() 	反双曲正弦。 	
	   atan() 	反正切。 	
	   atan2() 	两个参数的反正切。 	
	   atanh() 	反双曲正切。 	
	   base_convert() 	在任意进制之间转换数字。 	
	   bindec() 	把二进制转换为十进制。 	
	   ceil() 	向上舍入为最接近的整数。 	
	   cos() 	余弦。 	
	   cosh() 	双曲余弦。 	
	   decbin() 	把十进制转换为二进制。 	
	   dechex() 	把十进制转换为十六进制。 	
	   decoct() 	把十进制转换为八进制。 	
	   deg2rad() 	将角度转换为弧度。 	
	   exp() 	返回 Ex 的值。 	
	   expm1() 	返回 Ex - 1 的值。 	
	   floor() 	向下舍入为最接近的整数。 	
	   fmod() 	返回除法的浮点数余数。 	
	   getrandmax() 	显示随机数最大的可能值。 	
	   hexdec() 	把十六进制转换为十进制。 	
	   hypot() 	计算直角三角形的斜边长度。 	
	   is_finite() 	判断是否为有限值。 	
	   is_infinite() 	判断是否为无限值。 	
	   is_nan() 	判断是否为合法数值。 	
	   lcg_value() 	返回范围为 (0, 1) 的一个伪随机数。 	
	   log() 	自然对数。 	
	   log10() 	以 10 为底的对数。 	
	   log1p() 	返回 log(1 + number)。 	
	   max() 	返回最大值。 	
	   min() 	返回最小值。 	
	   mt_getrandmax() 	显示随机数的最大可能值。 	
	   mt_rand() 	使用 Mersenne Twister 算法返回随机整数。 	
	   mt_srand() 	播种 Mersenne Twister 随机数生成器。 	
	   octdec() 	把八进制转换为十进制。 	
	   pi() 	返回圆周率的值。 	
	   pow() 	返回 x 的 y 次方。 	
	   rad2deg() 	把弧度数转换为角度数。 	
	   rand() 	返回随机整数。 	
	   round() 	对浮点数进行四舍五入。 	
	   sin() 	正弦。 	
	   sinh() 	双曲正弦。 	
	   sqrt() 	平方根。 
	   srand() 	播下随机数发生器种子。 	
	   tan() 	正切。 	
	   tanh() 	双曲正切。
**** string	
     mb_substr(strip_tags( $list["content"]),0,20) 截取字符串 对中文的支持
     ucfirst(string)->string第一个字大写
     addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符
     addslashes — 使用反斜线引用字符串
     bin2hex — 函数把包含数据的二进制字符串转换为十六进制值
     chop — rtrim 的别名
     chr — 返回指定的字符
     chunk_split — 将字符串分割成小块
     convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种
     convert_uudecode — 解码一个 uuencode 编码的字符串
     convert_uuencode — 使用 uuencode 编码一个字符串
     count_chars — 返回字符串所用字符的信息
     crc32 — 计算一个字符串的 crc32 多项式
     crypt — 单向字符串散列
     explode — 使用一个字符串分割另一个字符串 : array explode ( string $delimiter , string $string [, int $limit ] )
     fprintf — 将格式化后的字符串写入到流
     get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表
     hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）
     hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符
     hex2bin — 转换十六进制字符串为二进制字符串
     html_entity_decode — Convert all HTML entities to their applicable characters
     htmlentities — Convert all applicable characters to HTML entities
     htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符
     htmlspecialchars — Convert special characters to HTML entities
***** implode — 将一个一维数组的值转化为字符串
     #+BEGIN_SRC php
       <?php
       $arr = array('Hello','World!','I','love','Shanghai!');
       echo implode(" ",$arr);
       ?>
     #+END_SRC
***** join — 别名 implode
     lcfirst — 使一个字符串的第一个字符小写
     levenshtein — 计算两个字符串之间的编辑距离
     localeconv — Get numeric formatting information
     ltrim — 删除字符串开头的空白字符（或其他字符）
     md5_file — 计算指定文件的 MD5 散列值
     md5 — 计算字符串的 MD5 散列值
     metaphone — Calculate the metaphone key of a string
     money_format — 将数字格式化成货币字符串
     nl_langinfo — Query language and locale information
     nl2br — 在字符串所有新行之前插入 HTML 换行标记
     number_format — 以千位分隔符方式格式化一个数字
     ord — 返回字符的 ASCII 码值
     parse_str — 将字符串解析成多个变量
     print — 输出字符串;    实际不是函数,没参数
     printf — 输出格式化字符串
     quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串
     quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串
     quotemeta — 转义元字符集
     rtrim — 删除字符串末端的空白字符（或者其他字符）
     setlocale — 设置地区信息
     sha1_file — 计算文件的 sha1 散列值
     sha1 — 计算字符串的 sha1 散列值
     similar_text — 计算两个字符串的相似度
     soundex — Calculate the soundex key of a string
     sprintf — Return a formatted string
     sscanf — 根据指定格式解析输入的字符
     str_getcsv — 解析 CSV 字符串为一个数组
     str_ireplace — str_replace 的忽略大小写版本
     str_pad — 使用另一个字符串填充字符串为指定长度
     str_repeat — 重复一个字符串
     str_replace — 子字符串替换
     str_rot13 — 对字符串执行 ROT13 转换
     str_shuffle — 随机打乱一个字符串
     str_split — 将字符串转换为数组
     str_word_count — 返回字符串中单词的使用情况
     strcasecmp — 二进制安全比较字符串（不区分大小写）
     strchr — 别名 strstr
     strcmp — 二进制安全字符串比较
     strcoll — 基于区域设置的字符串比较
     strcspn — 获取不匹配遮罩的起始子字符串的长度
     strip_tags — 从字符串中去除 HTML 和 PHP 标记
     stripcslashes — 反引用一个使用 addcslashes 转义的字符串
     stripos — 查找字符串首次出现的位置（不区分大小写）
     stripslashes — 反引用一个引用字符串
     stristr — strstr 函数的忽略大小写版本
     strlen — 获取字符串长度
     strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）
     strnatcmp — 使用自然排序算法比较字符串
     strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）
     strncmp — 二进制安全比较字符串开头的若干个字符
     strpbrk — 在字符串中查找一组字符的任何一个字符
     strpos — 查找字符串首次出现的位置
     strrchr — 查找指定字符在字符串中的最后一次出现
     strrev — 反转字符串
     strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）
     strrpos — 计算指定字符串在目标字符串中最后一次出现的位置
     strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。
     strstr — 查找字符串的首次出现
     strtok — 标记分割字符串
     strtolower — 将字符串转化为小写
     strtoupper — 将字符串转化为大写
     strtr — 转换指定字符
     substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）
     substr_count — 计算字串出现的次数
     substr_replace — 替换字符串的子串
     substr — 返回字符串的子串
     trim — 去除字符串首尾处的空白字符（或者其他字符）
     ucfirst — 将字符串的首字母转换为大写
     ucwords — 将字符串中每个单词的首字母转换为大写
     vfprintf — 将格式化字符串写入流
     vprintf — 输出格式化字符串
     vsprintf — 返回格式化字符串
     wordwrap — 打断字符串为指定数量的字串
**** 网络 函数
     checkdnsrr — 给指定的主机（域名）或者IP地址做DNS通信检查
     closelog — 关闭系统日志链接
     define_syslog_variables — Initializes all syslog related variables
     dns_check_record — 别名 checkdnsrr
     dns_get_mx — 别名 getmxrr
     dns_get_record — 获取指定主机的DNS记录
     fsockopen — 打开一个网络连接或者一个Unix套接字连接
     gethostbyaddr — 获取指定的IP地址对应的主机名  //这个只能查到本机的主机名,可能跟域名反向解析有关,不能反向解析,只能解析host文件里面的
     gethostbyname — Get the IPv4 address corresponding to a given Internet host name
     gethostbynamel — Get a list of IPv4 addresses corresponding to a given Internet host name
     gethostname — Gets the host name
     getmxrr — Get MX records corresponding to a given Internet host name
     getprotobyname — Get protocol number associated with protocol name
     getprotobynumber — Get protocol name associated with protocol number
     getservbyname — Get port number associated with an Internet service and protocol
     getservbyport — Get Internet service which corresponds to port and protocol
     header_register_callback — Call a header function
     header_remove — Remove previously set headers
     header — 发送原生 HTTP 头
     headers_list — Returns a list of response headers sent (or ready to send)
     headers_sent — Checks if or where headers have been sent
     http_response_code — Get or Set the HTTP response code
     inet_ntop — Converts a packed internet address to a human readable representation
     inet_pton — Converts a human readable IP address to its packed in_addr representation
     ip2long — 将一个IPV4的字符串互联网协议转换成数字格式
     long2ip — Converts an long integer address into a string in (IPv4) Internet standard dotted format
     openlog — Open connection to system logger
     pfsockopen — 打开一个持久的网络连接或者Unix套接字连接。
     setcookie — Send a cookie
     setrawcookie — Send a cookie without urlencoding the cookie value
     socket_get_status — 别名 stream_get_meta_data
     socket_set_blocking — 别名 stream_set_blocking
     socket_set_timeout — 别名 stream_set_timeout
     syslog — Generate a system log message

**** pthreads
		 Threaded — Threaded 类
     Threaded::chunk — 操作
     Threaded::count — Manipulation
     Threaded::extend — Runtime Manipulation
     Threaded::from — Creation
     Threaded::getTerminationInfo — Error Detection
     Threaded::isRunning — State Detection
     Threaded::isTerminated — State Detection
     Threaded::isWaiting — State Detection
     Threaded::lock — Synchronization
     Threaded::merge — Manipulation
     Threaded::notify — Synchronization
     Threaded::pop — Manipulation
     Threaded::run — Execution
     Threaded::shift — Manipulation
     Threaded::synchronized — Synchronization
     Threaded::unlock — Synchronization
     Threaded::wait — Synchronization
		 Thread — Thread 类
     Thread::detach — 执行
     Thread::getCreatorId — 识别
     Thread::getCurrentThread — 识别
     Thread::getCurrentThreadId — 识别
     Thread::getThreadId — 识别
     Thread::globally — 执行
     Thread::isJoined — 状态监测
     Thread::isStarted — 状态检测
     Thread::join — 同步
     Thread::kill — 执行
     Thread::start — 执行
**** Worker — Worker 类
     Worker::getStacked — 栈分析
     Worker::isShutdown — 状态检测
     Worker::isWorking — 状态检测
     Worker::shutdown — 同步
     Worker::stack — 栈操作
     Worker::unstack — 栈操作
	   Collectable — The Collectable class
     Collectable::isGarbage — Determine whether an object has been marked as garbage
     Collectable::setGarbage — Mark an object as garbage
     Modifiers — 方法修饰符
**** Pool — Pool 类
     Pool::collect — 回收已完成任务的引用
     Pool::__construct — 创建新的 Worker 对象池
     Pool::resize — 改变 Pool 对象的可容纳 Worker 对象的数量
     Pool::shutdown — 停止所有的 Worker 对象
     Pool::submit — 提交对象以执行
     Pool::submitTo — 提交对象以执行
**** Mutex — Mutex 类
     Mutex::create — 创建一个互斥量
     Mutex::destroy — 销毁互斥量
     Mutex::lock — 给互斥量加锁
     Mutex::trylock — 尝试给互斥量加锁
     Mutex::unlock — 释放互斥量上的锁
**** Cond — Cond 类
     Cond::broadcast — 广播条件变量
     Cond::create — 创建一个条件变量
     Cond::destroy — 销毁条件变量
     Cond::signal — 发送唤醒信号
     Cond::wait — 等待
		  
**** PCRE 函数 Perl Compatible Regular Expressions 兼容正则
	   if(!(/^1[34578]\d{9}$/.test(phone))) 测试手机号
     preg_filter — 执行一个正则表达式搜索和替换
     preg_grep — 返回匹配模式的数组条目
     preg_last_error — 返回最后一个PCRE正则执行产生的错误代码
     preg_match_all — 执行一个全局正则表达式匹配
     preg_match — 执行一个正则表达式匹配
     preg_quote — 转义正则表达式字符
     preg_replace_callback_array — Perform a regular expression search and replace using callbacks
     preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换
     preg_replace — 执行一个正则表达式的搜索和替换
     : mixed preg_replace( mixed pattern, mixed replacement, mixed subject [, int limit ] )
     : $str = preg_replace('/\s/','-',$str);  这里要注意,匹配模式要加载/ /中间
     pattern 	正则表达式
     replacement 	替换的内容
     subject 	需要匹配替换的对象
     limit 	可选，指定替换的个数，如果省略 limit 或者其值为 -1，则所有的匹配项都会被替换

     replacement 可以包含 \\n 形式或 $n 形式的逆向引用，首选使用后者。每个此种引用将被替换为与第 n 个被捕获的括号内的子模式所匹配的文本。n 可以从 0 到 99，其中 \\0 或 $0 指的是被整个模式所匹配的文本。对左圆括号从左到右计数（从 1 开始）以取得子模式的数目。
     对替换模式在一个逆向引用后面紧接着一个数字时（如 \\11），不能使用 \\ 符号来表示逆向引用。因为这样将会使 preg_replace() 搞不清楚是想要一个 \\1 的逆向引用后面跟着一个数字 1 还是一个 \\11 的逆向引用。解决方法是使用 \${1}1。这会形成一个隔离的 $1 逆向引用，而使另一个 1 只是单纯的文字。
     上述参数除 limit 外都可以是一个数组。如果 pattern 和 replacement 都是数组，将以其键名在数组中出现的顺序来进行处理，这不一定和索引的数字顺序相同。如果使用索引来标识哪个 pattern 将被哪个 replacement 来替换，应该在调用 preg_replace() 之前用 ksort() 函数对数组进行排序。

     int preg_match ( string pattern, string subject [, array matches [, int flags]])
     在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。
     如果提供了 matches，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推    
     模式修正符 	说明
     i 	模式中的字符将同时匹配大小写字母
     m 	字符串视为多行
     s 	将字符串视为单行，换行符作为普通字符
     x 	将模式中的空白忽略
     e 	preg_replace() 函数在替换字符串中对逆向引用作正常的替换，将其作为 PHP 代码求值，并用其结果来替换所搜索的字符串。
     A 	强制仅从目标字符串的开头开始匹配
     D 	模式中的 $ 元字符仅匹配目标字符串的结尾
     U 	匹配最近的字符串
     u 	模式字符串被当成 UTF-8 

*****    preg_split — 通过一个正则表达式分隔字符串		
**** JSON 函数 
     json_decode — 对 JSON 格式的字符串进行解码
     json_encode — 对变量进行 JSON 编码
     json_last_error_msg — Returns the error string of the last json_encode() or json_decode() call
     json_last_error — 返回最后发生的错误
**** Socket 函数
     socket_accept — Accepts a connection on a socket
     socket_bind — 给套接字绑定名字
     socket_clear_error — 清除套接字或者最后的错误代码上的错误
     socket_close — 关闭套接字资源
     socket_cmsg_space — Calculate message buffer size
     socket_connect — 开启一个套接字连接
     socket_create_listen — Opens a socket on port to accept connections
     socket_create_pair — Creates a pair of indistinguishable sockets and stores them in an array
     socket_create — 创建一个套接字（通讯节点）
     socket_get_option — Gets socket options for the socket
     socket_getopt — 别名 socket_get_option
     socket_getpeername — Queries the remote side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
     socket_getsockname — Queries the local side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
     socket_import_stream — Import a stream
     socket_last_error — Returns the last error on the socket
     socket_listen — Listens for a connection on a socket
     socket_read — Reads a maximum of length bytes from a socket
     socket_recv — 从已连接的socket接收数据
     socket_recvfrom — Receives data from a socket whether or not it is connection-oriented
     socket_recvmsg — Read a message
     socket_select — Runs the select() system call on the given arrays of sockets with a specified timeout
     socket_send — Sends data to a connected socket
     socket_sendmsg — Send a message
     socket_sendto — Sends a message to a socket, whether it is connected or not
     socket_set_block — Sets blocking mode on a socket resource
     socket_set_nonblock — Sets nonblocking mode for file descriptor fd
     socket_set_option — Sets socket options for the socket
     socket_setopt — 别名 socket_set_option
     socket_shutdown — Shuts down a socket for receiving, sending, or both
     socket_strerror — Return a string describing a socket error
     socket_write — Write to a socket
*** 日志记录函数
    可以把函数执行流程写入日志
    file_put_contents(filepath,"out:".$data, FILE_APPEND); 追加到文本
** 流程控制
   if
   include
   include_once
   require
** 类
*** 属性
    $this->property
    静态属性 self::$property
*** 类常量
    const constant='aa';
    self::constant
*** 自动加载类
    写个 __autoload 实现
    #+BEGIN_SRC php
      <?php
      function __autoload($class_name) {
        require_once $class_name . '.php';
      }

      $obj  = new MyClass1();
      $obj2 = new MyClass2();
      ?>
    #+END_SRC
    接口
    #+BEGIN_SRC php
      <?php

      function __autoload($name) {
        var_dump($name);
      }

      class Foo implements ITest {
      }

      /*
        string(5) "ITest"

        Fatal error: Interface 'ITest' not found in ...
      ,*/
      ?>
    #+END_SRC
*** 构造函数和析构函数
    void __construct ([ mixed $args [, $... ]] )
    void __destruct ( void )
*** 访问控制
    private/protect/public
*** 继承
    extends
*** 范围解析 ::
    self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的
*** 接口 interface
*** 属性重载
    __get()，__set()，__isset() 和 __unset()
*** 对象序列化
    所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。
** 命名空间
   使用命名空间的关键字 use 同require功能一样 , 不用重复使用
   命名空间 namespace my\name; 引用 $a= new my\name::class(); use
   命名空间 namespace my\name; 引用 $a= new my\name\class(); use
   当前命名空间常量 __NAMESPACE__
   别名 use My\Full\Classname as Another;
   调用全局 同名函数 \gloFunc(); 前面加个 \, 若果同当前函数同名

   在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。
   另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前：
   另外，与PHP其它的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同
   一个命名空间的内容分割存放在不同的文件中。
   Import and Alias
   函数
     <?php
     use func Namespace\functionName;
     functionName();
     To import a constant, change use to use constant:
     <?php
     use constant Namespace\CONST_NAME;
     echo CONST_NAME;

     多名字空间
     PHP lets you define multiple namespaces in a single PHP file like this:
    <?php
    namespace Foo {
         // Declare classes, interfaces, functions, and constants here
    }
    namespace Bar {
         // Declare classes, interfaces, functions, and constants here
    }
\ prefix 指代全局命名空间
** trait 
   #+BEGIN_SRC php
     <?php
     trait Geocodable {
          {
              $this->address = $address;
          }
          public function getLatitude()
         {
             if (isset($this->geocoderResult) === false) {
                  $this->geocodeAddress();
             }
             return $this->geocoderResult->getLatitude();
         }
         public function getLongitude()
         {
             if (isset($this->geocoderResult) === false) {
                  $this->geocodeAddress();
             }
             return $this->geocoderResult->getLongitude();
         }
         protected function geocodeAddress()
         {
             $this->geocoderResult = $this->geocoder->geocode($this->address);
             return true;
         }
     }

   #+END_SRC
** 调用外部工具  执行shell shell_exec()
** 错误输出 die($msg)
   层次结构
   Throwable
   Error
   ArithmeticError
   DivisionByZeroError
   AssertionError
   ParseError
   TypeError
   Exception
   ... 
   
   Exception::__construct — 异常构造函数
   Exception::getMessage — 获取异常消息内容
   Exception::getPrevious — 返回异常链中的前一个异常
   Exception::getCode — 获取异常代码
   Exception::getFile — 获取发生异常的程序文件名称
   Exception::getLine — 获取发生异常的代码在文件中的行号
   Exception::getTrace — 获取异常追踪信息
   Exception::getTraceAsString — 获取字符串类型的异常追踪信息
   Exception::__toString — 将异常对象转换为字符串
   Exception::__clone — 异常克隆
** 上下文（Context）选项和参数
*** 套接字上下文选项 — 套接字上下文选项列表
*** HTTP context 选项 — HTTP context 的选项列表
*** FTP context options — FTP context option listing
*** SSL 上下文选项 — SSL 上下文选项清单
*** CURL context options — CURL 上下文选项列表
*** Phar 上下文（context）选项 — Phar 上下文（context）选项列表
*** MongoDB context options — MongoDB context option listing
** 支持的协议和封装协议
   PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。

   file:// — 访问本地文件系统
   http:// — 访问 HTTP(s) 网址
   ftp:// — 访问 FTP(s) URLs
   php:// — 访问各个输入/输出流（I/O streams）
   zlib:// — 压缩流
   data:// — 数据（RFC 2397）
   glob:// — 查找匹配的文件路径模式
   phar:// — PHP 归档
   ssh2:// — Secure Shell 2
   rar:// — RAR
   ogg:// — 音频流
   expect:// — 处理交互式的流
** 安全
*** HTTP 认证
*** Cookie
    setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
    <?php setcookie("mycookie['foo']", 'hfafa', time()+3600); ?>
    <?php echo $_COOKIE['foo']; ?>
*** 会话
*** XForms
*** 文件上传
*** 数据库连接
** 命令行模式
*** 内置 webserver
    启动Web服务器
    $ cd ~/public_html
    $ php -S localhost:8000
* PHP扩展
** 压缩  
*** zip
    Windows 用户需要在 php.ini 里使 php_zip.dll 可用，以便使用这些函数。
    Linux 在编译 PHP 时用 --enable-zip 配置选项来提供 zip 支持。
*** Bzip2
*** LZF
*** Rar
*** ZipArchive
** excel
   最近因项目需要，需要开发一个模块，把系统中的一些数据导出成Excel，修改后再导回系统。就趁机对这个研究了一番，下面进行一些总结。
   基本上导出的文件分为两种：
   1：类Excel格式，这个其实不是传统意义上的Excel文件，只是因为Excel的兼容能力强，能够正确打开而已。修改这种文件后再保存，通常会提示你是否要转换成Excel文件。
   优点：简单。
   缺点：难以生成格式，如果用来导入需要自己分别编写相应的程序。
   2：Excel格式，与类Excel相对应，这种方法生成的文件更接近于真正的Excel格式。

   如果导出中文时出现乱码，可以尝试将字符串转换成gb2312，例如下面就把$yourStr从utf-8转换成了gb2312:
   $yourStr = mb_convert_encoding(”gb2312″, “UTF-8″, $yourStr);

   下面详细列举几种方法。
   一、PHP导出Excel
   1：第一推荐无比风骚的PHPExcel，官方网站： http://www.codeplex.com/PHPExcel
   导入导出都成，可以导出office2007格式，同时兼容2003。
   下载下来的包中有文档和例子，大家可以自行研究。
   抄段例子出来：
   #+BEGIN_SRC php
    <?php   
   /**  
   */   
   
   /** Error reporting */   
   error_reporting(E_ALL);   
   
   /** Include path **/   
   set_include_path(get_include_path() . PATH_SEPARATOR . ‘../Classes/’);   
   
   /** PHPExcel */   
   include ‘PHPExcel.php’;   
   
   /** PHPExcel_Writer_Excel2007 */   
   include ‘PHPExcel/Writer/Excel2007.php’;   
   
   // Create new PHPExcel object   
   echo date(’H:i:s’) . ” Create new PHPExcel object\n”;   
   $objPHPExcel = new PHPExcel();   
   
   // Set properties   
   echo date(’H:i:s’) . ” Set properties\n”;   
   $objPHPExcel->getProperties()->setCreator(”Maarten Balliauw”);   
   $objPHPExcel->getProperties()->setLastModifiedBy(”Maarten Balliauw”);   
   $objPHPExcel-
  
   #+END_SRC
 

   2、使用pear的Spreadsheet_Excel_Writer类
   下载地址： http://pear.php.net/package/Spreadsheet_Excel_Writer
   此类依赖于OLE,下载地址：http://pear.php.net/package/OLE
   需要注意的是导出的Excel文件格式比较老，修改后保存会提示是否转换成更新的格式。
   不过可以设定格式，很强大。
#+BEGIN_SRC php
   <?php   
   require_once ‘Spreadsheet/Excel/Writer.php’;   
   
   // Creating a workbook   
   $workbook = new Spreadsheet_Excel_Writer();   
   
   // sending HTTP headers   
   $workbook->send(’test.xls’);   
   
   // Creating a worksheet   
   $worksheet =& $workbook->addWorksheet(’My first worksheet’);   
   
   // The actual data   
   $worksheet->write(0, 0, ‘Name’);   
   $worksheet->write(0, 1, ‘Age’);   
   $worksheet->write(1, 0, ‘John Smith’);   
   $worksheet->write(1, 1, 30);   
   $worksheet->write(2, 0, ‘Johann Schmidt’);   
   $worksheet->write(2, 1, 31);   
   $worksheet->write(3, 0, ‘Juan Herrera’);   
   $worksheet->write(3, 1, 32);   
   
   // Let’s send the file   
   $workbook->close();   
   ?>  
#+END_SRC

   3:利用smarty，生成符合Excel规范的XML或HTML文件
   支持格式，非常完美的导出方案。不过导出来的的本质上还是XML文件，如果用来导入就需要另外处理了。
   详细内容请见rardge大侠的帖子：http://bbs.chinaunix.net/viewthread.php?tid=745757

   需要注意的是如果导出的表格行数不确定时，最好在模板中把”ss:ExpandedColumnCount=”5″ ss:ExpandedRowCount=”21″”之类的东西删掉。

   4、利用pack函数打印出模拟Excel格式的断句符号，这种更接近于Excel标准格式，用office2003修改后保存，还不会弹出提示，推荐用这种方法。
   缺点是无格式。


   PHP代码
   <?php   
   // Send Header   
   header(”Pragma: public”);   
   header(”Expires: 0″);   
   header(”Cache-Control: must-revalidate, post-check=0, pre-check=0″);   
   header(”Content-Type: application/force-download”);   
   header(”Content-Type: application/octet-stream”);   
   header(”Content-Type: application/download”);;   
   header(”Content-Disposition: attachment;filename=test.xls “);   
   header(”Content-Transfer-Encoding: binary “);   
   // XLS Data Cell   
   
   xlsBOF();   
   xlsWriteLabel(1,0,”My excel line one”);   
   xlsWriteLabel(2,0,”My excel line two : “);   
   xlsWriteLabel(2,1,”Hello everybody”);   
   
   xlsEOF();   
   
   function xlsBOF() {   
   echo pack(”ssssss”, 0×809, 0×8, 0×0, 0×10, 0×0, 0×0);   
   return;   
   }   
   function xlsEOF() {   
   echo pack(”ss”, 0×0A, 0×00);   
   return;   
   }   
   function xlsWriteNumber($Row, $Col, $Value) {   
   echo pack(”sssss”, 0×203, 14, $Row, $Col, 0×0);   
   echo pack(”d”, $Value);   
   return;   
   }   
   function xlsWriteLabel($Row, $Col, $Value ) {   
   $L = strlen($Value);   
   echo pack(”ssssss”, 0×204, 8 + $L, $Row, $Col, 0×0, $L);   
   echo $Value;   
   return;   
   }   
   ?>   
   不过笔者在64位linux系统中使用时失败了，断句符号全部变成了乱码。   
   
   5、使用制表符、换行符的方法   
   制表符”\t”用户分割同一行中的列，换行符”\t\n”可以开启下一行。   
   <?php   
   header(”Content-Type: application/vnd.ms-execl”);   
   header(”Content-Disposition: attachment; filename=myExcel.xls”);   
   header(”Pragma: no-cache”);   
   header(”Expires: 0″);   
   /*first line*/   
   echo “hello”.”\t”;   
   echo “world”.”\t”;   
   echo “\t\n”;   
   
   /*start of second line*/   
   echo “this is second line”.”\t”;   
   echo “Hi,pretty girl”.”\t”;   
   echo “\t\n”;   
   ?>  


   6、使用com
   如果你的PHP可以开启com模块，就可以用它来导出Excel文件


   PHP代码
   <?PHP   
   $filename = “c:/spreadhseet/test.xls”;   
   $sheet1 = 1;   
   $sheet2 = “sheet2″;   
   $excel_app = new COM(”Excel.application”) or Die (”Did not connect”);   
   print “Application name: {$excel_app->Application->value}\n” ;   
   print “Loaded version: {$excel_app->Application->version}\n”;   
   $Workbook = $excel_app->Workbooks->Open(”$filename”) or Die(”Did not open $filename $Workbook”);   
   $Worksheet = $Workbook->Worksheets($sheet1);   
   $Worksheet->activate;   
   $excel_cell = $Worksheet->Range(”C4″);   
   $excel_cell->activate;   
   $excel_result = $excel_cell->value;   
   print “$excel_result\n”;   
   $Worksheet = $Workbook->Worksheets($sheet2);   
   $Worksheet->activate;   
   $excel_cell = $Worksheet->Range(”C4″);   
   $excel_cell->activate;   
   $excel_result = $excel_cell->value;   
   print “$excel_result\n”;   
   #To close all instances of excel:   
   $Workbook->Close;   
   unset($Worksheet);   
   unset($Workbook);   
   $excel_app->Workbooks->Close();   
   $excel_app->Quit();   
   unset($excel_app);   
   ?>  

   一个更好的例子： http://blog.chinaunix.net/u/16928/showart_387171.html

   一、PHP导入Excel

   1：还是用PHPExcel，官方网站： http://www.codeplex.com/PHPExcel。

   2：使用PHP-ExcelReader,下载地址: http://sourceforge.net/projects/phpexcelreader
   举例：


   PHP代码
   <?php   
   require_once ‘Excel/reader.php’;   
   
   // ExcelFile($filename, $encoding);   
   $data = new Spreadsheet_Excel_Reader();   
   
   // Set output Encoding.   
   $data->setOutputEncoding(’utf8′);   
   
   $data->read(’ jxlrwtest.xls’);   
   
   error_reporting(E_ALL ^ E_NOTICE);   
   
   for ($i = 1; $i <= $data->sheets[0]['numRows']; $i++) {   
   for ($j = 1; $j <= $data->sheets[0]['numCols']; $j++) {   
   echo “\”".$data->sheets[0]['cells'][$i][$j].”\”,”;   
   }   
   echo “\n”;   
   }   
   
   ?>  
** mPDF
   支持 html标签, 样式的导出(不是全部样式, 如floating只能部分)
   使用了很多代码, 有荣誉的人很多
*** install
    在/ttfontdata/ /tmp/ /graph_cache/文件夹中有写权限
    测试: [path_to_mpdf_folder]/mpdf/examples/
    要改变/tmp/文件夹的目录, 看手册 ^_^
** 音频 ID3
** 图像
*** 二维码 phpqrcode
   phpqrcode.php提供了一个关键的png()方法，其中
   参数$text表示生成二位的的信息文本；
   参数$outfile表示是否输出二维码图片 文件，默认否；
   参数$level表示容错率，也就是有被覆盖的区域还能识别，分别是 L（QR_ECLEVEL_L，7%），M（QR_ECLEVEL_M，15%），Q（QR_ECLEVEL_Q，25%），H（QR_ECLEVEL_H，30%）； 
   参数$size表示生成图片大小，默认是3；参数$margin表示二维码周围边框空白区域间距值；
   参数$saveandprint表示是否保存二维码并显示。

   . 代码如下:
   #+BEGIN_SRC php
     public static function png($text, $outfile=false, $level=QR_ECLEVEL_L, $size=3, $margin=4, $saveandprint=false)    
                   {   
                     $enc = QRencode::factory($level, $size, $margin);   
                     return $enc->encodePNG($text, $outfile, $saveandprint=false);   
                   }
   #+END_SRC
  
   调用PHP QR Code非常简单，如下代码即可生成一张内容为"http://www.cnblogs.com/txw1958/"的二维码.

   #+BEGIN_SRC php
     include 'phpqrcode.php'; 
     QRcode::png('http://www.cnblogs.com/txw1958/');
 
   #+END_SRC


   那么实际应用中，我们会在二维码的中间加上自己的LOGO，已增强宣传效果。那如何生成含有logo的二维码呢？其实原理很简单，先使用PHP QR Code生成一张二维码图片，然后再利用php的image相关函数，将事先准备好的logo图片加入到刚生成的原始二维码图片中间，然后重新生成一张新 的二维码图片。
   . 代码如下:
   #+BEGIN_SRC php
     include 'phpqrcode.php';    
     $value = 'http://www.cnblogs.com/txw1958/'; //二维码内容   
     $errorCorrectionLevel = 'L';//容错级别   
     $matrixPointSize = 6;//生成图片大小   
     //生成二维码图片   
     QRcode::png($value, 'qrcode.png', $errorCorrectionLevel, $matrixPointSize, 2);   
     $logo = 'logo.png';//准备好的logo图片   
     $QR = 'qrcode.png';//已经生成的原始二维码图   

     if ($logo !== FALSE) {   
       $QR = imagecreatefromstring(file_get_contents($QR));   
       $logo = imagecreatefromstring(file_get_contents($logo));   
       $QR_width = imagesx($QR);//二维码图片宽度   
       $QR_height = imagesy($QR);//二维码图片高度   
       $logo_width = imagesx($logo);//logo图片宽度   
       $logo_height = imagesy($logo);//logo图片高度   
       $logo_qr_width = $QR_width / 5;   
       $scale = $logo_width/$logo_qr_width;   
       $logo_qr_height = $logo_height/$scale;   
       $from_width = ($QR_width - $logo_qr_width) / 2;   
       //重新组合图片并调整大小   
       imagecopyresampled($QR, $logo, $from_width, $from_width, 0, 0, $logo_qr_width,   
                          $logo_qr_height, $logo_width, $logo_height);   
     }   
     //输出图片   
     imagepng($QR, 'helloweixin.png');   
     echo '<img src="helloweixin.png">';   

   #+END_SRC
   复制代码
   复制代码
   include 'phpqrcode.php';    
   $value = 'http://www.cnblogs.com/txw1958/'; //二维码内容   
   $errorCorrectionLevel = 'L';//容错级别   
   $matrixPointSize = 6;//生成图片大小   
   //生成二维码图片   
   QRcode::png($value, 'qrcode.png', $errorCorrectionLevel, $matrixPointSize, 2);   
   $logo = 'logo.png';//准备好的logo图片   
   $QR = 'qrcode.png';//已经生成的原始二维码图   

   if ($logo !== FALSE) {   
   $QR = imagecreatefromstring(file_get_contents($QR));   
   $logo = imagecreatefromstring(file_get_contents($logo));   
   $QR_width = imagesx($QR);//二维码图片宽度   
   $QR_height = imagesy($QR);//二维码图片高度   
   $logo_width = imagesx($logo);//logo图片宽度   
   $logo_height = imagesy($logo);//logo图片高度   
   $logo_qr_width = $QR_width / 5;   
   $scale = $logo_width/$logo_qr_width;   
   $logo_qr_height = $logo_height/$scale;   
   $from_width = ($QR_width - $logo_qr_width) / 2;   
   //重新组合图片并调整大小   
   imagecopyresampled($QR, $logo, $from_width, $from_width, 0, 0, $logo_qr_width,   
   $logo_qr_height, $logo_width, $logo_height);   
   }   
   //输出图片   
   imagepng($QR, 'helloweixin.png');   
   echo '<img src="helloweixin.png">';   
   复制代码
   由于二维码允许有一定的容错性，一般的二维码即使在遮住部分但仍然能够解码，经常我们扫描二维码的时候扫描到甚至不到一半时就能解码扫描结果，这是因为生成器会将部分信息重复表示来提高其容错度，这就是为什么我们在二维码中间加个LOGO图片并不影响解码结果的原因。
** 扩展管理器
*** pecl
   下载: pecl install extname
   这里可以指定版本   extname-0.1
   或者svn: $ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
   然后在php.ini 中激活扩展 ubuntu 中要创建软链接, 包含在文件夹中的, 所以不用修改php.ini文件 
   php-config  php配置信息
*** Composer 依赖管理器
**** 安装composer
    curl -sS https://getcomposer.org/installer | php
    mv composer.phar /usr/local/bin/composer
**** 设置镜像地址(中国的镜像地址 -g参数表示全局配置)
     composer config -g repo.packagist composer https://packagist.phpcomposer.com
      然后在自己项目里面的composer.json文件里面添加如下：
  "repositories": {
         "packagist": {
             "type": "composer",
             "url": "https://packagist.phpcomposer.com"
         }
     }

**** 声明依赖
  在项目目录下创建一个 composer.json 文件，指明依赖，比如，你的项目依赖 monolog：
  #+BEGIN_SRC json
  {
      "require": {
          "monolog/monolog": "1.2.*"
      }
  }
  #+END_SRC

**** 安装依赖
     安装依赖非常简单，只需在项目目录下运行：
     composer install
   
     如果没有全局安装的话，则运行：
     php composer.phar install
**** 自动加载
     Composer 提供了自动加载的特性，只需在你的代码的初始化部分中加入下面一行：
     require 'vendor/autoload.php';
**** 模块仓库
     packagist.org 是Composer的仓库，很多著名的 PHP 库都能在其中找到。你也可以提交你自己的作品。
**** 1. 仅更新单个库
  只想更新某个特定的库，不想更新它的所有依赖，很简单：

  composer update foo/bar
  此外，这个技巧还可以用来解决“警告信息问题”。你一定见过这样的警告信息：

  Warning: The lock file is not up to date with the latest changes in composer.json, you may be getting outdated dependencies, run update to update them.
  擦，哪里出问题了？别惊慌！如果你编辑了composer.json，你应该会看到这样的信息。比如，如果你增加或更新了细节信息，比如库的描述、作者、更多参数，甚至仅仅增加了一个空格，都会改变文件的md5sum。然后Composer就会警告你哈希值和composer.lock中记载的不同。

  那么我们该怎么办呢？update命令可以更新lock文件，但是如果仅仅增加了一些描述，应该是不打算更新任何库。这种情况下，只需update nothing：

  $ composer update nothing
  Loading composer repositories with package information
  Updating dependencies
  Nothing to install or update
  Writing lock file
  Generating autoload files
  这样一来，Composer不会更新库，但是会更新composer.lock。注意nothing并不是update命令的关键字。只是没有nothing 这个包导致的结果。如果你输入foobar，结果也一样。

  如果你用的Composer版本足够新，那么你可以直接使用--lock选项：

  composer update --lock
**** 2. 不编辑composer.json的情况下安装库
  你可能会觉得每安装一个库都需要修改composer.json太麻烦，那么你可以直接使用require命令。

  composer require "foo/bar:1.0.0"
  这个方法也可以用来快速地新开一个项目。init命令有--require选项，可以自动编写composer.json：（注意我们使用-n，这样就不用回答问题）

  $ composer init --require=foo/bar:1.0.0 -n
  $ cat composer.json
  {
      "require": {
          "foo/bar": "1.0.0"
      }
  }
**** 3. 派生很容易
  初始化的时候，你试过create-project命令么？

  composer create-project doctrine/orm path 2.2.0
  这会自动克隆仓库，并检出指定的版本。克隆库的时候用这个命令很方便，不需要搜寻原始的URI了。

**** 4. 考虑缓存，dist包优先
  最近一年以来的Composer会自动存档你下载的dist包。默认设置下，dist包用于加了tag的版本，例如"symfony/symfony": "v2.1.4"，或者是通配符或版本区间，"2.1.*"或">=2.2,<2.3-dev"（如果你使用stable作为你的minimum-stability）。

  dist包也可以用于诸如dev-master之类的分支，Github允许你下载某个git引用的压缩包。为了强制使用压缩包，而不是克隆源代码，你可以使用install和update的--prefer-dist选项。

  下面是一个例子（我使用了--profile选项来显示执行时间）：

  $ composer init --require="twig/twig:1.*" -n --profile
  Memory usage: 3.94MB (peak: 4.08MB), time: 0s

  $ composer install --profile
  Loading composer repositories with package information
  Installing dependencies
    - Installing twig/twig (v1.12.2)
      Downloading: 100%

  Writing lock file
  Generating autoload files
  Memory usage: 10.13MB (peak: 12.65MB), time: 4.71s

  $ rm -rf vendor

  $ composer install --profile
  Loading composer repositories with package information
  Installing dependencies from lock file
    - Installing twig/twig (v1.12.2)
      Loading from cache

  Generating autoload files
  Memory usage: 4.96MB (peak: 5.57MB), time: 0.45s
  这里，twig/twig:1.12.2的压缩包被保存在~/.composer/cache/files/twig/twig/1.12.2.0-v1.12.2.zip。重新安装包时直接使用。

**** 5. 若要修改，源代码优先
  当你需要修改库的时候，克隆源代码就比下载包方便了。你可以使用--prefer-source来强制选择克隆源代码。

  composer update symfony/yaml --prefer-source
  接下来你可以修改文件：

  composer status -v
  You have changes in the following dependencies:
  /path/to/app/vendor/symfony/yaml/Symfony/Component/Yaml:
      M Dumper.php
  当你试图更新一个修改过的库的时候，Composer会提醒你，询问是否放弃修改：

  $ composer update
  Loading composer repositories with package information
  Updating dependencies
    - Updating symfony/symfony v2.2.0 (v2.2.0- => v2.2.0)
      The package has modified files:
      M Dumper.php
      Discard changes [y,n,v,s,?]?
**** 为生产环境作准备
  最后提醒一下，在部署代码到生产环境的时候，别忘了优化一下自动加载：

  composer dump-autoload --optimize
  安装包的时候可以同样使用--optimize-autoloader。不加这一选项，你可能会发现20%到25%的性能损失。

  如果你需要帮助，或者想要了解某个命令的细节，你可以阅读官方文档或者中文文档，也可以查看JoliCode做的这个交互式备忘单。

**** 简单说下composer update和composer install区别：
    这里说下 composer 的机制, 当 `composer.lock` 文件存在的时候, 执行 `composer install` 命令时, composer 会更新按照 `composer.lock` 里的 package 指定版本进行安装, 如果是执行 `composer update` 的话, 会更新 `package` 版本, 并更新 `composer.lock` 文件（没明白到底有啥区别，参考知乎）.

    在composer 中国推荐的加速方法就是把默认的国外镜像换成国内的。
    具体步骤：
    composer config repo.packagist composer https://packagist.phpcomposer.com
    该命令是修改config.json配置

  然后在自己项目里面的composer.json文件里面添加如下：
   "repositories": {
          "packagist": {
              "type": "composer",
              "url": "https://packagist.phpcomposer.com"
          }
      }

  测试后，速度是变快了很多。

  原有项目新添加扩展的，都使用 composer require new/package 这种方式来安装。
  需要加版本的话
  composer require "foo/bar:1.0.0"
* CI 框架
** 应用程序流程图
***    index.php 文件作为前端控制器，初始化运行 CodeIgniter 所需的基本资源；
    : index.php 是唯一入口,因为其他文件开头都有
    : defined('BASEPATH') OR exit('No direct script access allowed');
***    Router 检查 HTTP 请求，以确定如何处理该请求；
***    如果存在缓存文件，将直接输出到浏览器，不用走下面正常的系统流程；
***    在加载应用程序控制器之前，对 HTTP 请求以及任何用户提交的数据进行安全检查；
***    控制器加载模型、核心类库、辅助函数以及其他所有处理请求所需的资源；
***    最后一步，渲染视图并发送至浏览器，如果开启了缓存，视图被会先缓存起来用于 后续的请求。
** 模型-视图-控制器  //用户请求一个资源  (数据库中存放资源/找到资源并构图/返回资源给用户)
** 判断请求(生成资源/存储资源)通过浏览器返回给他页面
** 安装(设备安装一下)
   1:  解压缩安装包；
   2:  将 CodeIgniter 文件夹及里面的文件上传到服务器，通常 index.php 文件将位于网站的根目录；
   3:  使用文本编辑器打开 application/config/config.php 文件设置你网站的根 URL，如果你想使用加密或会话，在这里设置上你的加密密钥；
   4:  如果你打算使用数据库，打开 application/config/database.php 文件设置数据库参数。
** 请求流程
*** 1.弄到URL http://example.com/news/latest/10
*** 2.分析,路由  routes.php //路由的作用是分析成类和方法调用,路由条目中没有,就不分析了
    $route['default_controller']='pages/view'; 控制器路径
    $route['(:any)'] = 'pages/view/$1';  通配规则
*** 3.制造控制器 News
    #+BEGIN_SRC php
      class News extends CI_Controller{
      }    
    #+END_SRC
*** 4.制造数据模型 News_model
****    1.创建数据库表
     #+BEGIN_SRC sql
       CREATE TABLE news (
       id int(11) NOT NULL AUTO_INCREMENT,
       title varchar(128) NOT NULL,
       slug varchar(128) NOT NULL,
       text text NOT NULL,
       PRIMARY KEY (id),
       KEY slug (slug)
       );
     #+END_SRC
****    2.在application/models/目录
     #+BEGIN_SRC php
       class News_model extends CI_Model{

         public function __construct()
                {
                  $this->load->database();
                }

         public function get_news($slug=FALSE)
                {
                  if ($slug===FALSE)
                  {
                    $query=$this->db->get('news');
                    return $query->result_array();
                  }
                  $query=$this->db->get_where('news',array('slug'=>$slug));
                  return $query->row_array();
                }
       }
     #+END_SRC
*** 5.控制器中使用model
    #+BEGIN_SRC php
      class News externs CI_controller{
        public function __construct(){
                 parent::__construct();
                 $this->load->model('news_model');
                 $this->load->helper('url_help');
               }
        public function index()
               {
                 $data['news']=$this->news_model->get_news();
               }
        public function view($slug){
                 $data['news_item']=$this->news_model->get_news($slug);
               }
      }
    #+END_SRC
*** 6.控制器中把数据传递给视图
    #+BEGIN_SRC php
      public function index(){
               : $data['news']=$this->news_model->get_news();
        $data['title']="Hello,world";

        $this->load->view('templates/header',$data);
        $this->load->view('news/index',$data);
        $this->load->view('templates/footer');   此视图不传数据
                                                     }
    #+END_SRC
*** 7.视图中调用数据 application/views/news/index.php ;这里就是前台啦
    #+BEGIN_SRC php
      <h2><?php echo $title; ?></h2>
      <?php foreach($news as $new_item):?>
      <h3><?php echo $news_item['title']; ?></h3>
      <div class="main">
      <?php echo $new_item['text']; ?>
      </div>
      <?php endforch; ?>
#+END_SRC
*** 8.修改路由
#+BEGIN_SRC php
$route['news/(:any)'] = 'news/view/$1';
$route['news'] = 'news';
#+END_SRC
** 创建数据 
*** 1.表单或jquery
*** 2.控制器验证并插入数据
#+BEGIN_SRC php
class News extends CI_Controller{
public function create()
{
if(INPUT==RIGHT)
{
$this->news_model->set_news();
$this->load->view('news/success');    创建成功返回页面
}
}
}
#+END_SRC
*** 3.插入数据的模块
#+BEGIN_SRC php
public function set_news()
{
$data=array(
'title'=>$this->input->post('title'),
'slug'=>$slug,
'text'=>$this->input->post('text')
);
return $this->db->insert('news',$data);
}
#+END_SRC
** 常规主题
*** CodeIgniter URL
**** (默认) URI分段方式 : example.com/class/function/ID
**** 查询字符串格式 : index.php?c=controller&m=method
*** 配置文件 config/config.php
**** 后缀 .html
**** 启用查询字符串格式
#+BEGIN_SRC php
$config['enable_query_strings'] = FALSE;
$config['controller_trigger'] = 'c';
$config['function_trigger'] = 'm';
#+END_SRC
**** 管理应用程序目录 $application_folder = 'application';
*** 控制器
**** 默认控制器 当 URI 没有分段参数时加载
#+BEGIN_SRC php
$route['default_controller'] = 'blog';
#+END_SRC
**** _remap
: 如果你的控制包含一个 _remap() 方法，那么无论 URI 中包含什么参数时都会调用该方法
**** 处理输出 
: 如果你的控制器含有一个 _output() 方法，输出类将会调用该方法来显示数据， 而不是直接显示数据。该方法的第一个参数包含了最终输出的数据。
#+BEGIN_SRC php
public function _output($output)
{
    echo $output;
}
#+END_SRC
**** 私有方法
只要简单的将方法声明为 private 或 protected 或 _methodname [名字前加下划线]
*** 视图
**** 加载视图$this->load->view('view_name');
**** 将视图作为数据返回
: 如果你将该参数设置为 TRUE ， 该方法返回字符串，默认情况下为 FALSE ，视图将显示到浏览器。
: $string = $this->load->view('myfile', '', TRUE);
*** 模型  
模型是专门用来和数据库打交道的 PHP 类
**** 加载模型 $this->load->model('model_name');
*** 辅助函数
**** 加载辅助函数 $this->load->helper('url');
*** 类库 位于 /system/libraries
**** 加载类库$this->load->library('class_name');
*** 网页缓存
**** 开始缓存$this->output->cache($n);
**** 删除缓存
#+BEGIN_SRC php
// Deletes cache for the currently requested URI
$this->output->delete_cache();
// Deletes cache for /foo/bar
$this->output->delete_cache('/foo/bar');
#+END_SRC
*** 以 CLI 方式运行
: $ php index.php tools message 重新路由了,单一入口
*** 处理环境
: ENVIRONMENT 常量
: define('ENVIRONMENT', isset($_SERVER['CI_ENV']) ? $_SERVER['CI_ENV'] : 'development');
*** URI安全
: CodeIgniter 严格限制 URI 中允许出现的字符，以此来减少恶意数据传到你的应用程序的可能性。
* PHPUnit测试框架
PHPUnit是什么？
它是一款轻量级的php测试框架
为什么要用PHPUnit？
1. facebook在用
2. 可以通过命令操控测试脚本

3. 可以测试性能

4. 可以测试代码覆盖率

5. 可以自动化的更新测试用例的参数数据

6. 各种格式的日志

7. 最最重要的是，功能如此炫，使用起来还特别简单

PHPUnit的安装

pear channel-discover pear.phpunit.de
pear install phpunit/PHPUnit
快速入门

<?php
require_once 'PHPUnit/Framework.php';
 
class ArrayTest extends PHPUnit_Framework_TestCase
{
    public function testNewArrayIsEmpty()
    {
        // 创建数组fixture。
        $fixture = array();
 
        // 断言数组fixture的尺寸是0。
        $this->assertEquals(0, sizeof($fixture));
    }
}
?>

1. ArrayTest为测试类

2. ArrayTest 继承于PHPUnit_Framework_TestCase

3.测试方法testNewArrayIsEmpty()，测试方法必须为public权限，一般以test开头，或者
你也可以选择给其加注释@test来表明该函数为测试函数

/**
 @test
*/
public function testNewArrayIsEmpty()
{
     $fixture = array();
     $this->assertEquals(0, sizeof($fixture));
}

命令行启动测试

phpunit  测试文件名，此处为要测试ArrayTest.php文件

phpunit ArrayTest
PHPUnit 3.2.10 by Sebastian Bergmann.
..
Time: 0 seconds
OK (2 tests)

命令行参数

phpunit --help
PHPUnit 3.2.10 by Sebastian Bergmann.

Usage: phpunit [switches] UnitTest [UnitTest.php]

  --log-graphviz <file>  Log test execution in GraphViz markup.
  --log-json <file>      Log test execution in JSON format.
  --log-tap <file>       Log test execution in TAP format to file.
  --log-xml <file>       Log test execution in XML format to file.
  --log-metrics <file>   Write metrics report in XML format.
  --log-pmd <file>       Write violations report in PMD XML format.

  --coverage-html <dir>  Generate code coverage report in HTML format.
  --coverage-xml <file>  Write code coverage information in XML format.

  --test-db-dsn <dsn>    DSN for the test database.
  --test-db-log-rev <r>  Revision information for database logging.
  --test-db-prefix ...   Prefix that should be stripped from filenames.
  --test-db-log-info ... Additional information for database logging.

  --testdox-html <file>  Write agile documentation in HTML format to file.
  --testdox-text <file>  Write agile documentation in Text format to file.

  --filter <pattern>     Filter which tests to run.
  --group ...            Only runs tests from the specified group(s).
  --exclude-group ...    Exclude tests from the specified group(s).

  --loader <loader>      TestSuiteLoader implementation to use.
  --repeat <times>       Runs the test(s) repeatedly.

  --tap                  Report test execution progress in TAP format.
  --testdox              Report test execution progress in TestDox format.

  --no-syntax-check      Disable syntax check of test source files.
  --stop-on-failure      Stop execution upon first error or failure.
  --verbose              Output more verbose information.
  --wait                 Waits for a keystroke after each test.

  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.

  --help                 Prints this usage information.
  --version              Prints the version and exits.

  --configuration <file> Read configuration from XML file.
  -d key[=value]         Sets a php.ini value.

高级功能

你是否已经厌烦了在每一个测试方法命名前面加一个test，是否因为只是调用的参数不同
，却要写多个测试用例而纠结？我最喜欢的高级功能，现在隆重推荐给你，叫做框架生成
器

<?php
class Calculator
{
    public function add($a, $b)
    {
        return $a + $b;
    }
}
?>

命令行启动测试用例

phpunit --skeleton Calculator
PHPUnit 3.2.10 by Sebastian Bergmann.

Wrote test class skeleton for Calculator to CalculatorTest.php.

简单么？简单，但是它其实没有什么意义，因为没有测试数据，怎样加数据，哦哦哦，重
头戏来了

<?php
class Calculator
{
    /**
     * @assert (0, 0) == 0
     * @assert (0, 1) == 1
     * @assert (1, 0) == 1
     * @assert (1, 1) == 2
     */
    public function add($a, $b)
    {
        return $a + $b;
    }
}
?>

原始类中的每个方法都进行@assert注解的检测。这些被转变为测试代码，像这样
    /**
     * Generated from @assert (0, 0) == 0.
     */
    public function testAdd() {
        $o = new Calculator;
        $this->assertEquals(0, $o->add(0, 0));
    }
下面是运行生成的测试用例类的输出。

phpunit CalculatorTest
PHPUnit 3.2.10 by Sebastian Bergmann.

....

Time: 0 seconds

OK (4 tests)

阅读全文

  * 本文已收录于以下专栏：

相关文章推荐

    PHPUnit 基本使用
   
    头一次使用这种东西，开始有些手忙脚乱，弄了二天了，终于有点眉目了，记录一下
    过程。　　以下都是在windows下进行，我的php版本是php-5.1.4-win32 　　因为
    phpunit要通过p...
      + jucrazy 
      + jucrazy
      + 2011年08月26日 10:31
      + 14918

    php单元测试入门教程phpunit详解
   
    指对软件中的基本单元进行测试，如函数、方法等，以检查其返回值或行为是否符合
    预期；实际中软件是很复杂的，由许多组件构成，执行流程连贯在一起，要进行单元
    片段的测试，就需要为其提供执行上下文（或者说参数）和...
      + u0114740
      + u011474028
      + 2017年02月14日 16:29
      + 5534

    PHPUnit学习笔记(五)PHPUnit参数详解
   
    PHPUnit参数详解:     本文直接翻译自PHPUnit官方文档,个人翻译水平有限,可能会
    存在某些词和意思翻译不准的地方,进请谅解!     Runs the tests that ...
      + fafa211 
      + fafa211
      + 2012年11月08日 23:39
      + 5142

    PHPUnit的使用
   
    Composer 安装PHPUnitcomposer global require "phpunit/phpunit=5.5.*" 会将
    PHPUnit以全局的形式安装到电脑当中去确保.bash_...
      + lzx_vict
      + lzx_victory
      + 2016年11月28日 15:11
      + 243

    PHPUnit单元测试
   
    PHPUnit单元测试一、概述 1. 什么是单元测试？【百度百科】单元测试是对软件中的
    最小可测单元进行检查和验证。是开发者编写的一小段代码，用于检验被测代码的一
    个很小的、很明确的功能是否...
      + u0108893
      + u010889390
      + 2016年03月15日 18:48
      + 2915

    PHPunit深入了解
   
    一、使用依赖关系通过在测试函数前添加 @depends 注解，来讲需求函数的返回值作
    为参数获取...
      + Register
      + Register_man
      + 2016年12月21日 14:55
      + 395

    Laravel 5.2使用phpunit提示command not found
   
    在Laravel目录下使用phpunit命令提示command not found。如果执行 phpunit 命令
    报错：command not found 或者 permiss...
      + karwik  
      + karwik
      + 2016年04月13日 19:27
      + 1562

    【phpunit】phpunit初次安装使用简记
   
    安装环境 windows7操作系统，php 5.3.28,，已经安装xdeb
      + eightwhe
      + eightwhells
      + 2014年05月31日 18:22
      + 2346

    phpunit功能点整理
   
    只要你想到输入一些东西到print语句或调试表达式中，就用测试代替它。      
    --Martin Fowler 本文档整理参考： phpunit中文手册 http://downl...
      + e4210834
      + e421083458
      + 2012年12月15日 14:54
      + 3268

    phpUnit 优点与注意
   
    回调测试　　对于具有回调方法的 API 来说，这些测试可以确保如果没有定义回调函
    数，代码可以正常运行。另外，这些测试还可以确保在定义了回调函数但是这些回调
    函数操作有误或产生异常时，代码...
      + cakexuex
      + cakexuexi
      + 2013年07月30日 22:23
      + 625

[3_fly_]
   
    fly_heart_yuan
   
    ＋关注

原创
    15

粉丝
    16

喜欢
    0

码云

他的最新文章

更多文章

  * PHPUnit入门篇
  * 服务器并发处理能力
  * Building A Great API

在线课程

  * 腾讯云容
   
    腾讯云容器服务架构实现介绍
   
    讲师：董晓杰
   
  * 容器技术
   
    容器技术在58同城的实践
   
    讲师：姚远
   
他的热门文章

  * PHPUnit入门篇
    17368
  * Nikto
    16985
  * linux下的网络配置命令ipconfig命令详解
    11268
  * web服务器性能测试之利器—apache的ab
    5691
  * 安装MySQL时start service出错的解决办法
    5601

相关推荐

  * PHPUnit 基本使用
  * php单元测试入门教程phpunit详解
  * PHPUnit学习笔记(五)PHPUnit参数详解
  * PHPUnit的使用

  * 0
  * submit
  * 
  * submit
  * submit
  * submit

内容举报
返回顶部
收藏助手
不良信息举报

您举报文章：PHPUnit入门篇                                 
举报原因： ( )色情 ( )政治 ( )抄袭 ( )广告 ( )招聘 ( )骂人
           ( )其他 [                    ]                 
原文地址： [http://             ]                         
           [                    ]                         
           [                    ]                         
原因补充： [                    ]                         
                                                          
           (最多只允许输入30个字)                         
                                                          
           [btn_su] [btn_ca]                              

* php-mode
  执行区域  php-send-region
  查网页文档(这个好点, 查关键字的) C-c C-f         php-search-documentation
  看手册    C-c RET         php-browse-manual
  标记函数             mark-defun
  跳到定义 ~SPC m g g~ 
  返回  ~C-t~      

** 初始化工程(最好做下)
1. Run the following
  #+BEGIN_SRC shell
    cd /root/of/project
    touch .ac-php-conf.json
  #+END_SRC
2. Inside of spacemacs run:
  = ac-php-remake-tags-all =

* 简单文件上传 
 注意路径都是相对路径，绝对路径 必须是/home/wuming这种的，要么用常量 ROOT这种
  PHP 文件上传
通过 PHP，可以把文件上传到服务器。
本章节实例在 test 项目下完成，目录结构为：
test
|-----upload             # 文件上传的目录
|-----form.html          # 表单文件
|-----upload_file.php    # php 上传代码
源码下载
创建一个文件上传表单
允许用户从表单上传文件是非常有用的。
请看下面这个供上传文件的 HTML 表单：
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>

</body>
</html>
将以上代码保存到 form.html 文件中。
有关上面的 HTML 表单的一些注意项列举如下：
<form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 "multipart/form-data"。
<input> 标签的 type="file" 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。
注释：允许用户上传文件是一个巨大的安全风险。请仅仅允许可信的用户执行文件上传操作。
创建上传脚本
"upload_file.php" 文件含有供上传文件的代码：
<?php
if ($_FILES["file"]["error"] > 0)
{
    echo "错误：" . $_FILES["file"]["error"] . "<br>";
}
else
{
    echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
    echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
    echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
    echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"];
}
?>
通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。
第一个参数是表单的 input name，第二个下标可以是 "name"、"type"、"size"、"tmp_name" 或 "error"。如下所示：
$_FILES["file"]["name"] - 上传文件的名称
$_FILES["file"]["type"] - 上传文件的类型
$_FILES["file"]["size"] - 上传文件的大小，以字节计
$_FILES["file"]["tmp_name"] - 存储在服务器的文件的临时副本的名称
$_FILES["file"]["error"] - 由文件上传导致的错误代码
这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。
上传限制
在这个脚本中，我们增加了对文件上传的限制。用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB：
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
$extension = end($temp);        // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)    // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"];
    }
}
else
{
    echo "非法的文件格式";
}
?>
保存被上传的文件
上面的实例在服务器的 PHP 临时文件夹中创建了一个被上传文件的临时副本。
这个临时的副本文件会在脚本结束时消失。要保存被上传的文件，我们需要把它拷贝到另外的位置：
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当期目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
上面的脚本检测了文件是否已存在，如果不存在，则把文件拷贝到名为 "upload" 的目录下。
文件上传演示操作如下所示：
* 日志记录
error_log("出现大麻烦了!", 1, ". mydomain.com");   //发送到管理员邮箱中   
error_log("搞砸了!",   2,   "localhost:5000");     //发送到本机对应5000端口的服务器中   
error_log("搞砸了!\n",   3,   "/usr/local/errors.log");  //追加到指定的文件中   
#+BEGIN_SRC php
 <?php
 header("Content-type: text/html; charset=utf-8");
 /********************
 1、写入内容到文件,追加内容到文件
 2、打开并读取文件内容
 ********************/
  $file  = 'log.txt';//要写入文件的文件名（可以是任意文件名），如果文件不存在，将会创建一个
  $content = "第一次写入的内容\n";
  
  if($f  = file_put_contents($file, $content,FILE_APPEND)){// 这个函数支持版本(PHP 5) 
   echo "写入成功。<br />";
  }
 if($data = file_get_contents($file)){; // 这个函数支持版本(PHP 4 >= 4.3.0, PHP 5) 
   echo "写入文件的内容是：$data";
  }
 ?>
#+END_SRC
* 常见错误
  : php 文件权限对 file_exist()等文件函数影响大
* modern php
** 第一部分 语言功能
*** 命名空间 (避免在一个对话中方言的冲突)
    指向具体事物
*** 声明 namespace
*** 导入和别名
    默认使用    $response = new \Symfony\Component\HttpFoundation\Response('Oops'，400);
    导入 use Symfony\Component\HttpFoundation\Response;
    别名 use Symfony\Component\HttpFoundation\Response as Res;
    
      有用的提示
      代码到接口
      性状
      为什么我们使用特质18
      如何创建特质19
      如何使用特质20
      发电机22
      创建一个生成器22
      使用发电机23
      关闭25
      创建25
      附加国家27
      Zend OPcache 29
     启用Zend OPcache 29
     配置Zend OPcache 31
     使用Zend OPcache 31
   内置HTTP服务器31
     启动服务器32
     配置服务器32
     路由器脚本33
     检测内置服务器33
     缺点33
   接下来是什么34
第二部分 好的做法
3.标准。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。37
   PHP-FIG的救援37
   框架互操作性38
     接口38
     自动加载39
     39式
   什么是PSR？40
   PSR-1：基本代码风格40
   PSR-2：严格的代码风格41
   PSR-3：记录器接口45
     写一个PSR-3记录器46
     使用PSR-3记录器47
   PSR-4：自动加载机47
     为什么自动加载器很重要47
     PSR-4 Autoloader策略48
     如何编写PSR-4自动加载器（以及为什么不应该）49
4.组件。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。51
   为什么使用组件？51
   什么是组件？52
   组件与框架53
     不是所有的框架都不好54
     为作业使用正确的工具54
   查找组件55
     商店56
     选择56
     留下反馈
   使用PHP组件57
vi | 目录
     如何安装Composer 58
     如何使用作曲家59
     示例项目61
     作曲家和私人存储库64
   创建PHP组件66
     供应商和包装名称66
     命名空间66
     文件系统组织67
     composer.json文件68
     自述文件70
     组件实现71
     版本控制72
     包装师提交73
     使用组件74
好的做法。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。75
   消毒，验证和逃生75
     消毒输入76
     验证数据79
     逃生输出80
   密码80
     永远不知道用户密码81
     永不限制用户密码81
     永不电子邮件用户密码81
     用bcrypt散列用户密码82
     密码哈希API 82
     用于PHP的密码散列API <5.5.0 87
   日期，时间和时区87
     设置默认时区88
     DateTime类88
     DateInterval类89
     DateTimeZone类91
     DatePeriod类92
     nesbot /碳组件93
   数据库93
     PDO分机93
     数据库连接和DSN 93
     准备好的陈述96
     查询结果98
     交易100
   多字节字符串103
     字符编码104
                                                                                                               目录| 七
        输出UTF-8数据105
     流106
        流包装106
        流上下文109
        流过滤器110
        自定义流过滤器112
     错误和例外115
        例外115
        异常处理程序118
        错误119
        错误处理程序121
        开发过程中的错误和例外123
        生产124
第三部分 部署，测试和调优
主持。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。129
     共享服务器129
     虚拟专用服务器130
     专用服务器131
     PaaS 131
     选择一个托管计划132
7.配置。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。133
     我们的目标134
     服务器设置134
        首次登录134
        软件更新135
        非根用户135
        SSH密钥对认证136
        禁用密码和根登录138
     PHP-FPM 138
        安装138
        全局配置139
        池配置140
     nginx 143
        安装143
        虚拟主机143
     自动化服务器配置
     委托服务器供应146
     进一步阅读147
viii | 目录
    接下来是什么147
 8.调音。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。149
    php.ini文件149
    存储器150
    Zend OPcache 151
    文件上传152
    最长执行时间153
    会话处理154
    输出缓冲155
    实际路径高速缓存155
    下一步155
 9.部署。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。157
    版本控制157
    自动部署157
      使它简单158
      使其可预测158
      让它可逆158
    Capistrano 158
      它是如何工作的158
      安装159
      配置159
      验证161
      准备远程服务器161
      Capistrano钩162
      部署您的应用程序163
      回滚您的应用程序163
    进一步阅读163
    什么是下一步163
10.测试。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。165
    我们为什么要测试？165
    我们什么时候测试？166
      在166之前
      在166期间
      166后
    我们测试什么？166
    我们如何测试？167
      单元测试167
      测试驱动开发（TDD）167
      行为驱动开发（BDD）167
                                                                                                                      目录| 九
     PHPUnit 168
       目录结构169
       安装PHPUnit 170
       安装Xdebug 170
       配置PHPUnit 171
       Whovian类172
       WhovianTest测试用例173
       运行测试175
       代码覆盖率176
     用Travis CI 177进行连续测试
       安装程序177
       运行178
     进一步阅读178
     接下来是什么179
11.分析。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。181
     何时使用分析器181
     轮廓仪的类型181
     Xdebug 182
       配置182
       触发器183
       分析183
     XHProf 183
       安装184
       XHGUI 184
       配置185
       触发器185
     新的遗物探查器185
     Blackfire Profiler 186
     进一步阅读186
     接下来是什么186
12. HHVM和Hack。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。187
     HHVM 187
       PHP在Facebook 188
       HHVM和Zend Engine Parity 189
       HHVM适合我吗？190
       安装190
       配置191
       扩展192
       使用Supervisord 192监视HHVM
       HHVM，FastCGI和Nginx 194
 x | 目录
     黑客语言195
       转换PHP到黑客196
       什么是类型？196
       静态打字197
       动态打字198
       黑客两种方式198
       黑客类型检查199
       黑客模式200
       Hack语法200
       黑客数据结构202
       HHVM /黑客与PHP 203
     进一步阅读204
13.社区。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。205
     本地PUG 205
     会议205
     辅导206
     保持最新206
       网站206
       邮件列表206
       Twitter 206
       播客206
       幽默207
 A.安装PHP。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。209
 B.地方发展环境。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。229
 指数。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。237
*** 
* 函数
** ini_get — Gets the value of a configuration option
  Returns the value of the configuration option as a string on success, or an empty
  string for null values. Returns FALSE if the configuration option doesn't exist.

  选项有
  display_errors 
  register_globals 
  post_max_size = 8M
  max_execution_time
  
  //以下两条获取服务器时间，中国大陆采用的是东八区的时间,设置时区写成Etc/GMT-8
  date_default_timezone_set("Etc/GMT-8");
  $systemtime = date("Y-m-d H:i:s",time());
 
* 临时域名
    ./natapp -authtoken=e5eb817e91aeee83 
