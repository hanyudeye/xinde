cli: php php.php   <?php echo "a"; ?>
: php 文件权限对 file_exist()等文件函数影响大
* 什么是PHP?
  标记，<?PHP ?> 静态html 文件是不动的，需要一些动态语言 做些东西，就像现在一个 html 对象变成了php 对象了，此对象是可执行的
  数据类型 
  类型比较 is_number instanceof(继承也可以, 对类和接口）跟 is_a 一样的功能
  数组初始化
  $array= array("foo" => "bar",);内置的，不要用new
  对象 这里是类的 初始化 ，用new
  错误输出 die($msg)
调用外部工具  执行shell shell_exec()
命名空间 namespace my\name; 引用 $a= new my\name::class();
** 数据区域范围
  local（局部）
  global（全局）来自于$var= $GLOBALS["var"] === global $var(建立一个引用,不能赋值)
  static（静态）
** 客户端参数传递  
   一种是URL中的 ，通过$_GET['varname']获取
   另一种通过 $_POST获取
** cookie 这里不大会
   setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
   <?php setcookie("mycookie['foo']", 'hfafa', time()+3600); ?>
   <?php echo $_COOKIE['foo']; ?>
** 配置  不同的库
  配置文件/etc/php/7.0/apache2
  这是命令行配置 /etc/php/7.0/cli/php.ini 
  错误配置  
  #+BEGIN_SRC php
    ini_set("display_errors", "On");   
    error_reporting(E_ALL); //-1是关闭
  #+END_SRC
** 常量数据
   定义 define("const",33);
   环境常量 $_SERVER 这种常量只有服务器端才能用, 命令行下展示的是bash 里的常量
   __file__ | __FILE__ 函数返回的是脚本所在在的路径
   __line__ 文件中的当前行号。
*** 数据
**** 服务器数据 $_SERVER
	  $_SERVER["SERVER_PORT"]  //获取端口  
	  $_SERVER['HTTP_HOST']  	 //获取域名或主机地址 如test.cn
    $_SERVER['SERVER_NAME']  //获取域名或主机地址 注：只是主域名如test.cn
	  $_SERVER["REQUEST_URI"]  //获取域名后的详细地址 如：/index.php?id=123 ...  
	  $_SERVER['SERVER_ROOT']  //请求的网页主目录
    $_SERVER['SCRIPT_NAME']  //包含当前脚本的路径
    $_SERVER['PHP_SELF']  //获取PHP文件名 
	  $_SERVER["QUERY_STRING"]  //获取PHP后的网址参数  
	  $_SERVER['HTTP_REFERER']  //来源网页的详细地址  
**** $_SESSION
    $_SESSION["userid"]=$manager['adminid'];
**** 客户机数据 $_POST  $_GET 
** 函数 
*** 定义 function
*** 定义引用返回function &functionname
*** 库函数
**** array 
	   foreach($array as $key=>$value){}遍历数组
	   each() 函数返回当前元素的键名和键值，并将内部指针向前移动。
	   该元素的键名和键值会被返回带有四个元素的数组中。两个元素（1 和 Value）包含键值，两个元素（0 和 Key）包含键名。
	   array()创建数组
	   current() - 返回数组中的当前元素的值
	   end() - 将内部指针指向数组中的最后一个元素，并输出
	   next() - 将内部指针指向数组中的下一个元素，并输出
	   prev() - 将内部指针指向数组中的上一个元素，并输出
	   reset() - 将内部指针指向数组中的第一个元素，并输出
	   array_values() 函数返回一个包含给定数组中所有键值的数组，但不保留键名。
	   int count ( mixed $var [, int $mode = COUNT_NORMAL ] )统计一个数组里的所有元素，或者一个对象里的东西。
	   is_array() - 检测变量是否是数组
	   array_count_values() 返回一个数组，统计的是每个值的数量，相等，数量加１
	   array_unique(array) 删除数组中重复的值,返回新数组
	   array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )  过滤器,把每个值传给callback函数,如果返回值为真，就返回过来
	   usort()	使用用户自定义的比较函数对数组进行排序。
	   array_slice(array,start,length,preserve) 函数在数组中根据条件取出一段值，并返回。
	   array()	创建数组。
	   array_change_key_case()	把数组中所有键更改为小写或大写。
	   array_chunk()	把一个数组分割为新的数组块。
	   array_column()	返回输入数组中某个单一列的值。
	   array_combine()	通过合并两个数组来创建一个新数组。
	   array_count_values()	用于统计数组中所有值出现的次数。
	   array_diff()	比较数组，返回差集（只比较键值）。
	   array_diff_assoc()	比较数组，返回差集（比较键名和键值）。
	   array_diff_key()	比较数组，返回差集（只比较键名）。
	   array_diff_uassoc()	比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。
	   array_diff_ukey()	比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。
	   array_fill()	用给定的键值填充数组。
	   array_fill_keys()	用指定键名的给定键值填充数组。
	   array_filter()	用回调函数过滤数组中的元素。
	   array_flip()	交换数组中的键和值。
	   array_intersect()	比较数组，返回交集（只比较键值）。
	   array_intersect_assoc()	比较数组，返回交集（比较键名和键值）。
	   array_intersect_key()	比较数组，返回交集（只比较键名）。
	   array_intersect_uassoc()	比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。
	   array_intersect_ukey()	比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。
	   array_key_exists()	检查指定的键名是否存在于数组中。
	   array_keys()	返回数组中所有的键名。
	   array_map()	把数组中的每个值发送到用户自定义函数，返回新的值。
	   array_merge()	把一个或多个数组合并为一个数组。
	   array_merge_recursive()	递归地合并一个或多个数组。
	   array_multisort()	对多个数组或多维数组进行排序。
	   array_pad()	用值将数组填补到指定长度。
	   array_pop()	删除数组的最后一个元素（出栈）。
	   array_product()	计算数组中所有值的乘积。
	   array_push()	将一个或多个元素插入数组的末尾（入栈）。
	   array_rand()	返回数组中一个或多个随机的键。
	   array_reduce()	通过使用用户自定义函数，以字符串返回数组。
	   array_replace()	使用后面数组的值替换第一个数组的值。
	   array_replace_recursive()	递归地使用后面数组的值替换第一个数组的值。
	   array_reverse()	以相反的顺序返回数组。
	   array_search()	搜索数组中给定的值并返回键名。
	   array_shift()	删除数组中首个元素，并返回被删除元素的值。
	   array_slice()	返回数组中被选定的部分。
	   array_splice()	删除并替换数组中指定的元素。
	   array_sum()	返回数组中值的和。
	   array_udiff()	比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。
	   array_udiff_assoc()	比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	   array_udiff_uassoc()	比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。
	   array_uintersect()	比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。
	   array_uintersect_assoc()	比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	   array_uintersect_uassoc()	比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。
	   array_unique()	删除数组中的重复值。
	   array_unshift()	在数组开头插入一个或多个元素。
     :  int array_unshift ( array &$array , mixed $var [, mixed $... ] )
	   array_values()	返回数组中所有的值。
	   array_walk()	对数组中的每个成员应用用户函数。
	   array_walk_recursive()	对数组中的每个成员递归地应用用户函数。
	   arsort()	对关联数组按照键值进行降序排序。
	   asort()	对关联数组按照键值进行升序排序。
	   compact()	创建包含变量名和它们的值的数组。
	   count()	返回数组中元素的数目。
	   current()	返回数组中的当前元素。
	   each()	返回数组中当前的键／值对。
	   end()	将数组的内部指针指向最后一个元素。
	   extract()	从数组中将变量导入到当前的符号表。
	   in_array()	检查数组中是否存在指定的值。
     : bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )
     : 在 haystack[干草堆] 中搜索 needle[针]，如果没有设置 strict[严格的] 则使用宽松的比较。 
	   key()	从关联数组中取得键名。
	   krsort()	对数组按照键名逆向排序。
	   ksort()	对数组按照键名排序。
	   list()	把数组中的值赋给一些变量。
	   natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。
	   natsort()	用“自然排序”算法对数组排序。
	   next()	将数组中的内部指针向前移动一位。
	   pos()	current() 的别名。
	   prev()	将数组的内部指针倒回一位。
	   range()	创建包含指定范围单元的数组。
	   reset()	将数组的内部指针指向第一个元素。
	   rsort()	对数组逆向排序。
	   shuffle()	将数组打乱。
	   sizeof()	count() 的别名。
	   sort()	对数组排序。
	   uasort()	使用用户自定义的比较函数对数组中的键值进行排序。
	   uksort()	使用用户自定义的比较函数对数组中的键名进行排序。
      
     : print_r(array_filter($array1, "odd"));
**** date
	   date(Y年m月d日l星期/M英文月,而不是数字)
	   ((int)date('h')+8)时间,东八区要加8小时
	   h - 带有首位零的 12 小时小时格式
	   i - 带有首位零的分钟 (minute)
	   s - 带有首位零的秒（00 -59）(second)
	   a - 小写的午前和午后（am 或 pm）ante (before) meridiem post meridiem
	   cal_days_in_month()	针对指定的年份和历法，返回一个月中的天数。
	   cal_from_jd()	把儒略日计数转换为指定历法的日期。
	   cal_info()	返回有关指定历法的信息。
	   cal_to_jd()	把指定历法中的日期转换为儒略日计数。
	   easter_date()	返回指定年份的复活节午夜的 Unix 时间戳。
	   easter_days()	返回指定年份的复活节与 3 月 21 日之间的天数。
	   frenchtojd()	把法国共和历的日期转换成为儒略日计数。
	   gregoriantojd()	把格利高里历法的日期转换成为儒略日计数。
	   jddayofweek()	返回日期在周几。
	   jdmonthname()	返回月的名称。
	   jdtofrench()	把儒略日计数转换为法国共和历的日期。
	   jdtogregorian()	将格利高里历法转换成为儒略日计数。
	   jdtojewish()	把儒略日计数转换为犹太历法的日期。
	   jdtojulian()	把儒略日计数转换为儒略历法的日期。
	   jdtounix()	把儒略日计数转换为 Unix 时间戳。
	   jewishtojd()	把犹太历法的日期转换为儒略日计数。
	   juliantojd()	把儒略历法的日期转换为儒略日计数。
	   unixtojd()	把 Unix 时间戳转换为儒略日计数。

	   Date/Time 函数的行为受到 php.ini 中设置的影响：
	   date.timezone 	默认时区（所有的 Date/Time 函数使用该选项） 	
	   date.default_latitude 	默认纬度（date_sunrise() 和 date_sunset() 使用该选项）
	   date.default_longitude 	默认经度（date_sunrise() 和 date_sunset() 使用该选项）
	   date.sunrise_zenith 	默认日出天顶（date_sunrise() 和 date_sunset() 使用该选项）
	   date.sunset_zenith 	默认日落天顶（date_sunrise() 和 date_sunset() 使用该选项）
	   PHP 5 Date/Time 函数
	   函数 	描述
	   checkdate() 	验证格利高里日期。
	   date_add() 	添加日、月、年、时、分和秒到日期。
	   date_create_from_format() 	返回根据指定格式进行格式化的新的 DateTime 对象。
	   date_create() 	返回新的 DateTime 对象。
	   date_date_set() 	设置新日期。
	   date_default_timezone_get() 	返回由所有的 Date/Time 函数使用的默认时区。
	   date_default_timezone_set() 	设置由所有的 Date/Time 函数使用的默认时区。
	   date_diff() 	返回两个日期间的差值。
	   date_format() 	返回根据指定格式进行格式化的日期。
	   date_get_last_errors() 	返回日期字符串中的警告/错误。
	   date_interval_create_from_date_string() 	从字符串的相关部分建立 DateInterval。
	   date_interval_format() 	格式化时间间隔。
	   date_isodate_set() 	设置 ISO 日期。
	   date_modify() 	修改时间戳。
	   date_offset_get() 	返回时区偏移。
	   date_parse_from_format() 	根据指定的格式返回带有关于指定日期的详细信息的关联数组。
	   date_parse() 	返回带有关于指定日期的详细信息的关联数组。
	   date_sub() 	从指定日期减去日、月、年、时、分和秒。
	   date_sun_info() 	返回包含有关指定日期与地点的日出/日落和黄昏开始/黄昏结束的信息的数组。
	   date_sunrise() 	返回指定日期与位置的日出时间。
	   date_sunset() 	返回指定日期与位置的日落时间。
	   date_time_set() 	设置时间。
	   date_timestamp_get() 	返回 Unix 时间戳。
	   date_timestamp_set() 	设置基于 Unix 时间戳的日期和时间。
	   date_timezone_get() 	返回给定 DateTime 对象的时区。
	   date_timezone_set() 	设置 DateTime 对象的时区。
	   date() 	格式化本地日期和时间。
	   getdate() 	返回某个时间戳或者当前本地的日期/时间的日期/时间信息。
	   gettimeofday() 	返回当前时间。
	   gmdate() 	格式化 GMT/UTC 日期和时间。
	   gmmktime() 	返回 GMT 日期的 UNIX 时间戳。
	   gmstrftime() 	根据区域设置对 GMT/UTC 日期和时间进行格式化。
	   idate() 	将本地时间/日期格式化为整数。
	   localtime() 	返回本地时间。
	   microtime() 	返回当前时间的微秒数。
	   mktime() 	返回日期的 Unix 时间戳。
	   strftime() 	根据区域设置对本地时间/日期进行格式化。
	   strptime() 	解析由 strftime() 生成的时间/日期。
	   strtotime() 	将任何英文文本的日期或时间描述解析为 Unix 时间戳。
	   time() 	返回当前时间的 Unix 时间戳。
	   timezone_abbreviations_list() 	返回包含夏令时、偏移量和时区名称的关联数组。
	   timezone_identifiers_list() 	返回带有所有时区标识符的索引数组。
	   timezone_location_get() 	返回指定时区的位置信息。
	   timezone_name_from_abbr() 	根据时区缩略语返回时区名称。
	   timezone_name_get() 	返回时区的名称。
	   timezone_offset_get() 	返回相对于 GMT 的时区偏移。
	   timezone_open() 	创建新的 DateTimeZone 对象。
	   timezone_transitions_get() 	返回时区的所有转换。
	   timezone_version_get() 	返回时区数据库的版本。

**** file
	   fopen("filename",'w')  //可以指定绝对路径或相对路径
	   "r" 	只读方式打开，将文件指针指向文件头。
	   "r+" 	读写方式打开，将文件指针指向文件头。
	   "w" 	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	   "w+" 	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	   "a" 	写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	   "a+" 	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	   "x" 	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则报错.
	   basename() 	返回路径中的文件名部分。
	   chgrp() 	改变文件组。 	
	   chmod() 	改变文件模式。 
	   chown() 	改变文件所有者。 	
	   clearstatcache() 	清除文件状态缓存。 	
	   fopen() 可以通过http路径打开,可以在php.ini 中配置allow_url_fopen   //unix中要注意文件的访问权限
	   copy() 	复制文件。
	   fread(filepoint,length)	读取打开的文件。
	   fwrite(file,string,length)   
	   file_get_contents(filepath) 函数把整个文件读入一个字符串中。
	   file_put_contents(filepath,filecontent) 在ftp中要用到flags和context标志
	   basename()
	   is_readable()
	   fgets()
	   fgetss() 去掉文件中的html格式
	   readfile(filename) 输出到浏览器
	   file(file) 返回值是文件内容
	   fgetc()
	   file_exists()
	   filesize()
	   unlink() 删除文件
	   rewind()
	   fseek()
	   ftell()
	   delete() 	参见 unlink() 或 unset()。 	 
	   dirname() 	返回路径中的目录名称部分。 	
	   disk_free_space() 	返回目录的可用空间。 	
	   disk_total_space() 	返回一个目录的磁盘总容量。
	   diskfreespace() 	disk_free_space() 的别名。
	   fclose() 	关闭打开的文件。 	
	   feof() 	测试文件指针是否到了文件结束的位置。 	
	   fflush() 	向打开的文件输出缓冲内容。 
	   fgetc() 	从打开的文件中返回字符。 
	   fgetcsv() 	从打开的文件中解析一行，校验 CSV 字段。 	
	   fgets() 	从打开的文件中返回一行。 	
	   fgetss() 	从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。 	  file() 	把文件读入一个数组中。 	
	   file_exists() 	检查文件或目录是否存在。
	   file_get_contents() 	将文件读入字符串。 	
	   file_put_contents() 	将字符串写入文件。 	
	   fileatime() 	返回文件的上次访问时间。 	
	   filectime() 	返回文件的上次改变时间。 	
	   filegroup() 	返回文件的组 ID。 	
	   fileinode() 	返回文件的 inode 编号。 
	   filemtime() 	返回文件的上次修改时间。
	   fileowner() 	文件的 user ID （所有者）。
	   fileperms() 	返回文件的权限。 	
	   filesize() 	返回文件大小。 	
	   filetype() 	返回文件类型。 	
	   flock() 	锁定或释放文件。
	   fnmatch() 	根据指定的模式来匹配文件名或字符串。 	
	   fopen() 	打开一个文件或 URL。 	
	   fpassthru() 	从打开的文件中读数据，直到 EOF，并向输出缓冲写结果
	   fputcsv() 	将行格式化为 CSV 并写入一个打开的文件中。 	
	   fputs() 	fwrite() 的别名。 	
	   fread() 	读取打开的文件。 	
	   fscanf() 	根据指定的格式对输入进行解析。
	   fseek() 	在打开的文件中定位。 	
	   fstat() 	返回关于一个打开的文件的信息。
	   ftell() 	返回文件指针的读/写位置 
	   ftruncate() 	将文件截断到指定的长度。
	   fwrite() 	写入文件。 	
	   glob() 	返回一个包含匹配指定模式的文件名/目录的数组。 	
	   is_dir() 	判断指定的文件名是否是一个目录。 	
	   is_executable() 	判断文件是否可执行。 	
	   is_file() 	判断指定文件是否为常规的文件。 	
	   is_link() 	判断指定的文件是否是连接。 	
	   is_readable() 	判断文件是否可读。 	
	   is_uploaded_file() 	判断文件是否是通过 HTTP POST 上传的。 	
	   is_writable() 	判断文件是否可写。 	
	   is_writeable() 	is_writable() 的别名。 	
	   link() 	创建一个硬连接。 	
	   linkinfo() 	返回有关一个硬连接的信息。 	
	   lstat() 	返回关于文件或符号连接的信息。 	
	   mkdir() 	创建目录。 	
	   move_uploaded_file() 	将上传的文件移动到新位置。 	
	   parse_ini_file() 	解析一个配置文件。 	
	   pathinfo() 	返回关于文件路径的信息。 	
	   pclose() 	关闭有 popen() 打开的进程。 	
	   popen() 	打开一个进程。 	
	   readfile() 	读取一个文件，并输出到输出缓冲。 	
	   readlink() 	返回符号连接的目标。 	
	   realpath() 	返回绝对路径名。 	
	   rename() 	重名名文件或目录。 	
	   rewind() 	倒回文件指针的位置。 	
	   rmdir() 	删除空的目录。 	
	   set_file_buffer() 	设置已打开文件的缓冲大小。 	
	   stat() 	返回关于文件的信息。 	
	   symlink() 	创建符号连接。 	
	   tempnam() 	创建唯一的临时文件。
	   tmpfile() 	建立临时文件。 	
	   touch() 	设置文件的访问和修改时间。 	
	   umask() 	改变文件的文件权限。 	
	   unlink() 	删除文件。

	   isset(varname)判断变量是否已经配置，就是变量存不存在值
	   unset(varname)取消配置；
	   empty(varname) 对于值是0的数返回true，这里要当心

**** Directory 函数
	   chdir()	改变当前的目录。
	   chroot()	改变根目录。
	   closedir()	关闭目录句柄。
	   dir()	返回 Directory 类的实例。
	   getcwd()	返回当前工作目录。
	   opendir()	打开目录句柄。
	   readdir()	返回目录句柄中的条目。
	   rewinddir()	重置目录句柄。
	   scandir()	返回指定目录中的文件和目录的数组。
**** PHP 过滤器用于对来自非安全来源的数据（比如用户输入）进行验证和过滤。
	   filter_has_var() 	检查是否存在指定输入类型的变量。 	
	   filter_id() 	返回指定过滤器的 ID 号。 	
	   filter_input() 	从脚本外部获取输入，并进行过滤。 	
	   filter_input_array() 	从脚本外部获取多项输入，并进行过滤。 	
	   filter_list() 	返回包含所有得到支持的过滤器的一个数组。 	
	   filter_var_array() 	获取多项变量，并进行过滤。 	
	   filter_var() 	获取一个变量，并进行过滤。
**** HTTP 函数允许您在其他输出被发送之前，对由 Web 服务器发送到浏览器的信息进行操作。
	   header() 	向客户端发送原始的 HTTP 报头。
	   headers_list() 	返回已发送的（或待发送的）响应头部的一个列表。
	   headers_sent() 	检查 HTTP 报头是否发送/已发送到何处。
	   setcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie。
	   setrawcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie（不进行 URL 编码）。

**** 数学 (Math) 函数能处理 integer 和 float 范围内的值。
	   abs() 	绝对值。 	
	   acos() 	反余弦。 	
	   acosh() 	反双曲余弦。 	
	   asin() 	反正弦。 	
	   asinh() 	反双曲正弦。 	
	   atan() 	反正切。 	
	   atan2() 	两个参数的反正切。 	
	   atanh() 	反双曲正切。 	
	   base_convert() 	在任意进制之间转换数字。 	
	   bindec() 	把二进制转换为十进制。 	
	   ceil() 	向上舍入为最接近的整数。 	
	   cos() 	余弦。 	
	   cosh() 	双曲余弦。 	
	   decbin() 	把十进制转换为二进制。 	
	   dechex() 	把十进制转换为十六进制。 	
	   decoct() 	把十进制转换为八进制。 	
	   deg2rad() 	将角度转换为弧度。 	
	   exp() 	返回 Ex 的值。 	
	   expm1() 	返回 Ex - 1 的值。 	
	   floor() 	向下舍入为最接近的整数。 	
	   fmod() 	返回除法的浮点数余数。 	
	   getrandmax() 	显示随机数最大的可能值。 	
	   hexdec() 	把十六进制转换为十进制。 	
	   hypot() 	计算直角三角形的斜边长度。 	
	   is_finite() 	判断是否为有限值。 	
	   is_infinite() 	判断是否为无限值。 	
	   is_nan() 	判断是否为合法数值。 	
	   lcg_value() 	返回范围为 (0, 1) 的一个伪随机数。 	
	   log() 	自然对数。 	
	   log10() 	以 10 为底的对数。 	
	   log1p() 	返回 log(1 + number)。 	
	   max() 	返回最大值。 	
	   min() 	返回最小值。 	
	   mt_getrandmax() 	显示随机数的最大可能值。 	
	   mt_rand() 	使用 Mersenne Twister 算法返回随机整数。 	
	   mt_srand() 	播种 Mersenne Twister 随机数生成器。 	
	   octdec() 	把八进制转换为十进制。 	
	   pi() 	返回圆周率的值。 	
	   pow() 	返回 x 的 y 次方。 	
	   rad2deg() 	把弧度数转换为角度数。 	
	   rand() 	返回随机整数。 	
	   round() 	对浮点数进行四舍五入。 	
	   sin() 	正弦。 	
	   sinh() 	双曲正弦。 	
	   sqrt() 	平方根。 
	   srand() 	播下随机数发生器种子。 	
	   tan() 	正切。 	
	   tanh() 	双曲正切。

**** string	
     mb_substr(strip_tags( $list["content"]),0,20) 截取字符串 对中文的支持
     ucfirst(string)->string第一个字大写
     addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符
     addslashes — 使用反斜线引用字符串
     bin2hex — 函数把包含数据的二进制字符串转换为十六进制值
     chop — rtrim 的别名
     chr — 返回指定的字符
     chunk_split — 将字符串分割成小块
     convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种
     convert_uudecode — 解码一个 uuencode 编码的字符串
     convert_uuencode — 使用 uuencode 编码一个字符串
     count_chars — 返回字符串所用字符的信息
     crc32 — 计算一个字符串的 crc32 多项式
     crypt — 单向字符串散列
     explode — 使用一个字符串分割另一个字符串 : array explode ( string $delimiter , string $string [, int $limit ] )
     fprintf — 将格式化后的字符串写入到流
      get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表
      hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）
      hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符
      hex2bin — 转换十六进制字符串为二进制字符串
      html_entity_decode — Convert all HTML entities to their applicable characters
      htmlentities — Convert all applicable characters to HTML entities
      htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符
      htmlspecialchars — Convert special characters to HTML entities
      implode — 将一个一维数组的值转化为字符串
      join — 别名 implode
      lcfirst — 使一个字符串的第一个字符小写
      levenshtein — 计算两个字符串之间的编辑距离
      localeconv — Get numeric formatting information
      ltrim — 删除字符串开头的空白字符（或其他字符）
      md5_file — 计算指定文件的 MD5 散列值
      md5 — 计算字符串的 MD5 散列值
      metaphone — Calculate the metaphone key of a string
      money_format — 将数字格式化成货币字符串
      nl_langinfo — Query language and locale information
      nl2br — 在字符串所有新行之前插入 HTML 换行标记
      number_format — 以千位分隔符方式格式化一个数字
      ord — 返回字符的 ASCII 码值
      parse_str — 将字符串解析成多个变量
      print — 输出字符串;    实际不是函数,没参数
      printf — 输出格式化字符串
      quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串
      quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串
      quotemeta — 转义元字符集
      rtrim — 删除字符串末端的空白字符（或者其他字符）
      setlocale — 设置地区信息
      sha1_file — 计算文件的 sha1 散列值
      sha1 — 计算字符串的 sha1 散列值
      similar_text — 计算两个字符串的相似度
      soundex — Calculate the soundex key of a string
      sprintf — Return a formatted string
      sscanf — 根据指定格式解析输入的字符
      str_getcsv — 解析 CSV 字符串为一个数组
      str_ireplace — str_replace 的忽略大小写版本
      str_pad — 使用另一个字符串填充字符串为指定长度
      str_repeat — 重复一个字符串
      str_replace — 子字符串替换
      str_rot13 — 对字符串执行 ROT13 转换
      str_shuffle — 随机打乱一个字符串
      str_split — 将字符串转换为数组
      str_word_count — 返回字符串中单词的使用情况
      strcasecmp — 二进制安全比较字符串（不区分大小写）
      strchr — 别名 strstr
      strcmp — 二进制安全字符串比较
      strcoll — 基于区域设置的字符串比较
      strcspn — 获取不匹配遮罩的起始子字符串的长度
      strip_tags — 从字符串中去除 HTML 和 PHP 标记
      stripcslashes — 反引用一个使用 addcslashes 转义的字符串
      stripos — 查找字符串首次出现的位置（不区分大小写）
      stripslashes — 反引用一个引用字符串
      stristr — strstr 函数的忽略大小写版本
      strlen — 获取字符串长度
      strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）
      strnatcmp — 使用自然排序算法比较字符串
      strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）
      strncmp — 二进制安全比较字符串开头的若干个字符
      strpbrk — 在字符串中查找一组字符的任何一个字符
      strpos — 查找字符串首次出现的位置
      strrchr — 查找指定字符在字符串中的最后一次出现
      strrev — 反转字符串
      strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）
      strrpos — 计算指定字符串在目标字符串中最后一次出现的位置
      strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。
      strstr — 查找字符串的首次出现
      strtok — 标记分割字符串
      strtolower — 将字符串转化为小写
      strtoupper — 将字符串转化为大写
      strtr — 转换指定字符
      substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）
      substr_count — 计算字串出现的次数
      substr_replace — 替换字符串的子串
      substr — 返回字符串的子串
      trim — 去除字符串首尾处的空白字符（或者其他字符）
      ucfirst — 将字符串的首字母转换为大写
      ucwords — 将字符串中每个单词的首字母转换为大写
      vfprintf — 将格式化字符串写入流
      vprintf — 输出格式化字符串
      vsprintf — 返回格式化字符串
      wordwrap — 打断字符串为指定数量的字串
**** 网络 函数
     checkdnsrr — 给指定的主机（域名）或者IP地址做DNS通信检查
     closelog — 关闭系统日志链接
     define_syslog_variables — Initializes all syslog related variables
     dns_check_record — 别名 checkdnsrr
     dns_get_mx — 别名 getmxrr
     dns_get_record — 获取指定主机的DNS记录
     fsockopen — 打开一个网络连接或者一个Unix套接字连接
     gethostbyaddr — 获取指定的IP地址对应的主机名  //这个只能查到本机的主机名,可能跟域名反向解析有关,不能反向解析,只能解析host文件里面的
     gethostbyname — Get the IPv4 address corresponding to a given Internet host name
     gethostbynamel — Get a list of IPv4 addresses corresponding to a given Internet host name
     gethostname — Gets the host name
     getmxrr — Get MX records corresponding to a given Internet host name
     getprotobyname — Get protocol number associated with protocol name
     getprotobynumber — Get protocol name associated with protocol number
     getservbyname — Get port number associated with an Internet service and protocol
     getservbyport — Get Internet service which corresponds to port and protocol
     header_register_callback — Call a header function
     header_remove — Remove previously set headers
     header — 发送原生 HTTP 头
     headers_list — Returns a list of response headers sent (or ready to send)
     headers_sent — Checks if or where headers have been sent
     http_response_code — Get or Set the HTTP response code
     inet_ntop — Converts a packed internet address to a human readable representation
     inet_pton — Converts a human readable IP address to its packed in_addr representation
     ip2long — 将一个IPV4的字符串互联网协议转换成数字格式
     long2ip — Converts an long integer address into a string in (IPv4) Internet standard dotted format
     openlog — Open connection to system logger
     pfsockopen — 打开一个持久的网络连接或者Unix套接字连接。
     setcookie — Send a cookie
     setrawcookie — Send a cookie without urlencoding the cookie value
     socket_get_status — 别名 stream_get_meta_data
     socket_set_blocking — 别名 stream_set_blocking
     socket_set_timeout — 别名 stream_set_timeout
     syslog — Generate a system log message

**** pthreads
		 Threaded — Threaded 类
     Threaded::chunk — 操作
     Threaded::count — Manipulation
     Threaded::extend — Runtime Manipulation
     Threaded::from — Creation
     Threaded::getTerminationInfo — Error Detection
     Threaded::isRunning — State Detection
     Threaded::isTerminated — State Detection
     Threaded::isWaiting — State Detection
     Threaded::lock — Synchronization
     Threaded::merge — Manipulation
     Threaded::notify — Synchronization
     Threaded::pop — Manipulation
     Threaded::run — Execution
     Threaded::shift — Manipulation
     Threaded::synchronized — Synchronization
     Threaded::unlock — Synchronization
     Threaded::wait — Synchronization
		 Thread — Thread 类
     Thread::detach — 执行
     Thread::getCreatorId — 识别
     Thread::getCurrentThread — 识别
     Thread::getCurrentThreadId — 识别
     Thread::getThreadId — 识别
     Thread::globally — 执行
     Thread::isJoined — 状态监测
     Thread::isStarted — 状态检测
     Thread::join — 同步
     Thread::kill — 执行
     Thread::start — 执行
**** Worker — Worker 类
     Worker::getStacked — 栈分析
     Worker::isShutdown — 状态检测
     Worker::isWorking — 状态检测
     Worker::shutdown — 同步
     Worker::stack — 栈操作
     Worker::unstack — 栈操作
	   Collectable — The Collectable class
     Collectable::isGarbage — Determine whether an object has been marked as garbage
     Collectable::setGarbage — Mark an object as garbage
     Modifiers — 方法修饰符
**** Pool — Pool 类
     Pool::collect — 回收已完成任务的引用
     Pool::__construct — 创建新的 Worker 对象池
     Pool::resize — 改变 Pool 对象的可容纳 Worker 对象的数量
     Pool::shutdown — 停止所有的 Worker 对象
     Pool::submit — 提交对象以执行
     Pool::submitTo — 提交对象以执行
**** Mutex — Mutex 类
     Mutex::create — 创建一个互斥量
     Mutex::destroy — 销毁互斥量
     Mutex::lock — 给互斥量加锁
     Mutex::trylock — 尝试给互斥量加锁
     Mutex::unlock — 释放互斥量上的锁
**** Cond — Cond 类
     Cond::broadcast — 广播条件变量
     Cond::create — 创建一个条件变量
     Cond::destroy — 销毁条件变量
     Cond::signal — 发送唤醒信号
     Cond::wait — 等待
		  
**** PCRE 函数 Perl Compatible Regular Expressions 兼容正则
     preg_filter — 执行一个正则表达式搜索和替换
     preg_grep — 返回匹配模式的数组条目
     preg_last_error — 返回最后一个PCRE正则执行产生的错误代码
     preg_match_all — 执行一个全局正则表达式匹配
     preg_match — 执行一个正则表达式匹配
     preg_quote — 转义正则表达式字符
     preg_replace_callback_array — Perform a regular expression search and replace using callbacks
     preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换
     preg_replace — 执行一个正则表达式的搜索和替换
      : mixed preg_replace( mixed pattern, mixed replacement, mixed subject [, int limit ] )
      : $str = preg_replace('/\s/','-',$str);  这里要注意,匹配模式要加载/ /中间
      pattern 	正则表达式
      replacement 	替换的内容
      subject 	需要匹配替换的对象
      limit 	可选，指定替换的个数，如果省略 limit 或者其值为 -1，则所有的匹配项都会被替换

      replacement 可以包含 \\n 形式或 $n 形式的逆向引用，首选使用后者。每个此种引用将被替换为与第 n 个被捕获的括号内的子模式所匹配的文本。n 可以从 0 到 99，其中 \\0 或 $0 指的是被整个模式所匹配的文本。对左圆括号从左到右计数（从 1 开始）以取得子模式的数目。
      对替换模式在一个逆向引用后面紧接着一个数字时（如 \\11），不能使用 \\ 符号来表示逆向引用。因为这样将会使 preg_replace() 搞不清楚是想要一个 \\1 的逆向引用后面跟着一个数字 1 还是一个 \\11 的逆向引用。解决方法是使用 \${1}1。这会形成一个隔离的 $1 逆向引用，而使另一个 1 只是单纯的文字。
      上述参数除 limit 外都可以是一个数组。如果 pattern 和 replacement 都是数组，将以其键名在数组中出现的顺序来进行处理，这不一定和索引的数字顺序相同。如果使用索引来标识哪个 pattern 将被哪个 replacement 来替换，应该在调用 preg_replace() 之前用 ksort() 函数对数组进行排序。

      int preg_match ( string pattern, string subject [, array matches [, int flags]])
      在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。
      如果提供了 matches，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推    
      模式修正符 	说明
      i 	模式中的字符将同时匹配大小写字母
      m 	字符串视为多行
      s 	将字符串视为单行，换行符作为普通字符
      x 	将模式中的空白忽略
      e 	preg_replace() 函数在替换字符串中对逆向引用作正常的替换，将其作为 PHP 代码求值，并用其结果来替换所搜索的字符串。
      A 	强制仅从目标字符串的开头开始匹配
      D 	模式中的 $ 元字符仅匹配目标字符串的结尾
      U 	匹配最近的字符串
      u 	模式字符串被当成 UTF-8 

*****    preg_split — 通过一个正则表达式分隔字符串		
**** JSON 函数 
     json_decode — 对 JSON 格式的字符串进行解码
     json_encode — 对变量进行 JSON 编码
     json_last_error_msg — Returns the error string of the last json_encode() or json_decode() call
     json_last_error — 返回最后发生的错误
**** Socket 函数
     socket_accept — Accepts a connection on a socket
     socket_bind — 给套接字绑定名字
     socket_clear_error — 清除套接字或者最后的错误代码上的错误
     socket_close — 关闭套接字资源
     socket_cmsg_space — Calculate message buffer size
     socket_connect — 开启一个套接字连接
     socket_create_listen — Opens a socket on port to accept connections
     socket_create_pair — Creates a pair of indistinguishable sockets and stores them in an array
     socket_create — 创建一个套接字（通讯节点）
     socket_get_option — Gets socket options for the socket
     socket_getopt — 别名 socket_get_option
     socket_getpeername — Queries the remote side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
     socket_getsockname — Queries the local side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
     socket_import_stream — Import a stream
     socket_last_error — Returns the last error on the socket
     socket_listen — Listens for a connection on a socket
     socket_read — Reads a maximum of length bytes from a socket
     socket_recv — 从已连接的socket接收数据
     socket_recvfrom — Receives data from a socket whether or not it is connection-oriented
     socket_recvmsg — Read a message
     socket_select — Runs the select() system call on the given arrays of sockets with a specified timeout
     socket_send — Sends data to a connected socket
     socket_sendmsg — Send a message
     socket_sendto — Sends a message to a socket, whether it is connected or not
     socket_set_block — Sets blocking mode on a socket resource
     socket_set_nonblock — Sets nonblocking mode for file descriptor fd
     socket_set_option — Sets socket options for the socket
     socket_setopt — 别名 socket_set_option
     socket_shutdown — Shuts down a socket for receiving, sending, or both
     socket_strerror — Return a string describing a socket error
     socket_write — Write to a socket
* 什么是PHP扩展
** zip
   Windows 用户需要在 php.ini 里使 php_zip.dll 可用，以便使用这些函数。
   Linux 系统 ¶
   为了使用这些函数，必须在编译 PHP 时用 --enable-zip 配置选项来提供 zip 支持。
** PECL php扩展仓库
   下载: pecl install extname
   这里可以指定版本   extname-0.1
   或者svn: $ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
   然后在php.ini 中激活扩展 ubuntu 中要创建软链接, 包含在文件夹中的, 所以不用修改php.ini文件 
   php-config  php配置信息
** 导入excel
 最近因项目需要，需要开发一个模块，把系统中的一些数据导出成Excel，修改后再导回系统。就趁机对这个研究了一番，下面进行一些总结。
 基本上导出的文件分为两种：
 1：类Excel格式，这个其实不是传统意义上的Excel文件，只是因为Excel的兼容能力强，能够正确打开而已。修改这种文件后再保存，通常会提示你是否要转换成Excel文件。
 优点：简单。
 缺点：难以生成格式，如果用来导入需要自己分别编写相应的程序。
 2：Excel格式，与类Excel相对应，这种方法生成的文件更接近于真正的Excel格式。

 如果导出中文时出现乱码，可以尝试将字符串转换成gb2312，例如下面就把$yourStr从utf-8转换成了gb2312:
 $yourStr = mb_convert_encoding(”gb2312″, “UTF-8″, $yourStr);

 下面详细列举几种方法。
 一、PHP导出Excel
 1：第一推荐无比风骚的PHPExcel，官方网站： http://www.codeplex.com/PHPExcel
 导入导出都成，可以导出office2007格式，同时兼容2003。
 下载下来的包中有文档和例子，大家可以自行研究。
 抄段例子出来：
 PHP代码
 <?php   
 /**  
 */   
   
 /** Error reporting */   
 error_reporting(E_ALL);   
   
 /** Include path **/   
 set_include_path(get_include_path() . PATH_SEPARATOR . ‘../Classes/’);   
   
 /** PHPExcel */   
 include ‘PHPExcel.php’;   
   
 /** PHPExcel_Writer_Excel2007 */   
 include ‘PHPExcel/Writer/Excel2007.php’;   
   
 // Create new PHPExcel object   
 echo date(’H:i:s’) . ” Create new PHPExcel object\n”;   
 $objPHPExcel = new PHPExcel();   
   
 // Set properties   
 echo date(’H:i:s’) . ” Set properties\n”;   
 $objPHPExcel->getProperties()->setCreator(”Maarten Balliauw”);   
 $objPHPExcel->getProperties()->setLastModifiedBy(”Maarten Balliauw”);   
 $objPHPExcel->getProperties()->setTitle(”Office 2007 XLSX Test Document”);   
 $objPHPExcel->getProperties()->setSubject(”Office 2007 XLSX Test Document”);   
 $objPHPExcel->getProperties()->setDescrīption(”Test document for Office 2007 XLSX, generated using PHP classes.”);   
 $objPHPExcel->getProperties()->setKeywords(”office 2007 openxml php”);   
 $objPHPExcel->getProperties()->setCategory(”Test result file”);   
   
 // Add some data   
 echo date(’H:i:s’) . ” Add some data\n”;   
 $objPHPExcel->setActiveSheetIndex(0);   
 $objPHPExcel->getActiveSheet()->setCellValue(’A1′, ‘Hello’);   
 $objPHPExcel->getActiveSheet()->setCellValue(’B2′, ‘world!’);   
 $objPHPExcel->getActiveSheet()->setCellValue(’C1′, ‘Hello’);   
 $objPHPExcel->getActiveSheet()->setCellValue(’D2′, ‘world!’);   
   
 // Rename sheet   
 echo date(’H:i:s’) . ” Rename sheet\n”;   
 $objPHPExcel->getActiveSheet()->setTitle(’Simple’);   
   
 // Set active sheet index to the first sheet, so Excel opens this as the first sheet   
 $objPHPExcel->setActiveSheetIndex(0);   
   
 // Save Excel 2007 file   
 echo date(’H:i:s’) . ” Write to Excel2007 format\n”;   
 $objWriter = new PHPExcel_Writer_Excel2007($objPHPExcel);   
 $objWriter->save(str_replace(’.php’, ‘.xlsx’, __FILE__));   
   
 // Echo done   
 echo date(’H:i:s’) . ” Done writing file.\r\n”;  

 

 2、使用pear的Spreadsheet_Excel_Writer类
 下载地址： http://pear.php.net/package/Spreadsheet_Excel_Writer
 此类依赖于OLE,下载地址：http://pear.php.net/package/OLE
 需要注意的是导出的Excel文件格式比较老，修改后保存会提示是否转换成更新的格式。
 不过可以设定格式，很强大。


 PHP代码
 <?php   
 require_once ‘Spreadsheet/Excel/Writer.php’;   
   
 // Creating a workbook   
 $workbook = new Spreadsheet_Excel_Writer();   
   
 // sending HTTP headers   
 $workbook->send(’test.xls’);   
   
 // Creating a worksheet   
 $worksheet =& $workbook->addWorksheet(’My first worksheet’);   
   
 // The actual data   
 $worksheet->write(0, 0, ‘Name’);   
 $worksheet->write(0, 1, ‘Age’);   
 $worksheet->write(1, 0, ‘John Smith’);   
 $worksheet->write(1, 1, 30);   
 $worksheet->write(2, 0, ‘Johann Schmidt’);   
 $worksheet->write(2, 1, 31);   
 $worksheet->write(3, 0, ‘Juan Herrera’);   
 $worksheet->write(3, 1, 32);   
   
 // Let’s send the file   
 $workbook->close();   
 ?>  


 3:利用smarty，生成符合Excel规范的XML或HTML文件
 支持格式，非常完美的导出方案。不过导出来的的本质上还是XML文件，如果用来导入就需要另外处理了。
 详细内容请见rardge大侠的帖子：http://bbs.chinaunix.net/viewthread.php?tid=745757

 需要注意的是如果导出的表格行数不确定时，最好在模板中把”ss:ExpandedColumnCount=”5″ ss:ExpandedRowCount=”21″”之类的东西删掉。

 4、利用pack函数打印出模拟Excel格式的断句符号，这种更接近于Excel标准格式，用office2003修改后保存，还不会弹出提示，推荐用这种方法。
 缺点是无格式。


 PHP代码
 <?php   
 // Send Header   
 header(”Pragma: public”);   
 header(”Expires: 0″);   
 header(”Cache-Control: must-revalidate, post-check=0, pre-check=0″);   
 header(”Content-Type: application/force-download”);   
 header(”Content-Type: application/octet-stream”);   
 header(”Content-Type: application/download”);;   
 header(”Content-Disposition: attachment;filename=test.xls “);   
 header(”Content-Transfer-Encoding: binary “);   
 // XLS Data Cell   
   
 xlsBOF();   
 xlsWriteLabel(1,0,”My excel line one”);   
 xlsWriteLabel(2,0,”My excel line two : “);   
 xlsWriteLabel(2,1,”Hello everybody”);   
   
 xlsEOF();   
   
 function xlsBOF() {   
 echo pack(”ssssss”, 0×809, 0×8, 0×0, 0×10, 0×0, 0×0);   
 return;   
 }   
 function xlsEOF() {   
 echo pack(”ss”, 0×0A, 0×00);   
 return;   
 }   
 function xlsWriteNumber($Row, $Col, $Value) {   
 echo pack(”sssss”, 0×203, 14, $Row, $Col, 0×0);   
 echo pack(”d”, $Value);   
 return;   
 }   
 function xlsWriteLabel($Row, $Col, $Value ) {   
 $L = strlen($Value);   
 echo pack(”ssssss”, 0×204, 8 + $L, $Row, $Col, 0×0, $L);   
 echo $Value;   
 return;   
 }   
 ?>   
 不过笔者在64位linux系统中使用时失败了，断句符号全部变成了乱码。   
   
 5、使用制表符、换行符的方法   
 制表符”\t”用户分割同一行中的列，换行符”\t\n”可以开启下一行。   
 <?php   
 header(”Content-Type: application/vnd.ms-execl”);   
 header(”Content-Disposition: attachment; filename=myExcel.xls”);   
 header(”Pragma: no-cache”);   
 header(”Expires: 0″);   
 /*first line*/   
 echo “hello”.”\t”;   
 echo “world”.”\t”;   
 echo “\t\n”;   
   
 /*start of second line*/   
 echo “this is second line”.”\t”;   
 echo “Hi,pretty girl”.”\t”;   
 echo “\t\n”;   
 ?>  


 6、使用com
 如果你的PHP可以开启com模块，就可以用它来导出Excel文件


 PHP代码
 <?PHP   
 $filename = “c:/spreadhseet/test.xls”;   
 $sheet1 = 1;   
 $sheet2 = “sheet2″;   
 $excel_app = new COM(”Excel.application”) or Die (”Did not connect”);   
 print “Application name: {$excel_app->Application->value}\n” ;   
 print “Loaded version: {$excel_app->Application->version}\n”;   
 $Workbook = $excel_app->Workbooks->Open(”$filename”) or Die(”Did not open $filename $Workbook”);   
 $Worksheet = $Workbook->Worksheets($sheet1);   
 $Worksheet->activate;   
 $excel_cell = $Worksheet->Range(”C4″);   
 $excel_cell->activate;   
 $excel_result = $excel_cell->value;   
 print “$excel_result\n”;   
 $Worksheet = $Workbook->Worksheets($sheet2);   
 $Worksheet->activate;   
 $excel_cell = $Worksheet->Range(”C4″);   
 $excel_cell->activate;   
 $excel_result = $excel_cell->value;   
 print “$excel_result\n”;   
 #To close all instances of excel:   
 $Workbook->Close;   
 unset($Worksheet);   
 unset($Workbook);   
 $excel_app->Workbooks->Close();   
 $excel_app->Quit();   
 unset($excel_app);   
 ?>  

 一个更好的例子： http://blog.chinaunix.net/u/16928/showart_387171.html

 一、PHP导入Excel

 1：还是用PHPExcel，官方网站： http://www.codeplex.com/PHPExcel。

 2：使用PHP-ExcelReader,下载地址: http://sourceforge.net/projects/phpexcelreader
 举例：


 PHP代码
 <?php   
 require_once ‘Excel/reader.php’;   
   
 // ExcelFile($filename, $encoding);   
 $data = new Spreadsheet_Excel_Reader();   
   
 // Set output Encoding.   
 $data->setOutputEncoding(’utf8′);   
   
 $data->read(’ jxlrwtest.xls’);   
   
 error_reporting(E_ALL ^ E_NOTICE);   
   
 for ($i = 1; $i <= $data->sheets[0]['numRows']; $i++) {   
 for ($j = 1; $j <= $data->sheets[0]['numCols']; $j++) {   
 echo “\”".$data->sheets[0]['cells'][$i][$j].”\”,”;   
 }   
 echo “\n”;   
 }   
   
 ?>  
** mPDF   (make PDF ??) [[file+emacs:/home/wuming/soft/extend/phpextend/mpdfmanual.pdf][manualpage]]
  支持 html标签, 样式的导出(不是全部样式, 如floating只能部分)
  使用了很多代码, 有荣誉的人很多
*** install
 在/ttfontdata/ /tmp/ /graph_cache/文件夹中有写权限
 测试: [path_to_mpdf_folder]/mpdf/examples/
 要改变/tmp/文件夹的目录, 看手册 ^_^
* 什么是CI 框架
** 应用程序流程图
***    index.php 文件作为前端控制器，初始化运行 CodeIgniter 所需的基本资源；
    : index.php 是唯一入口,因为其他文件开头都有
    : defined('BASEPATH') OR exit('No direct script access allowed');
***    Router 检查 HTTP 请求，以确定如何处理该请求；
***    如果存在缓存文件，将直接输出到浏览器，不用走下面正常的系统流程；
***    在加载应用程序控制器之前，对 HTTP 请求以及任何用户提交的数据进行安全检查；
***    控制器加载模型、核心类库、辅助函数以及其他所有处理请求所需的资源；
***    最后一步，渲染视图并发送至浏览器，如果开启了缓存，视图被会先缓存起来用于 后续的请求。
** 模型-视图-控制器  //用户请求一个资源  (数据库中存放资源/找到资源并构图/返回资源给用户)
** 判断请求(生成资源/存储资源)通过浏览器返回给他页面
** 安装(设备安装一下)
1:  解压缩安装包；
2:  将 CodeIgniter 文件夹及里面的文件上传到服务器，通常 index.php 文件将位于网站的根目录；
3:  使用文本编辑器打开 application/config/config.php 文件设置你网站的根 URL，如果你想使用加密或会话，在这里设置上你的加密密钥；
4:  如果你打算使用数据库，打开 application/config/database.php 文件设置数据库参数。
** 请求流程
*** 1.弄到URL http://example.com/news/latest/10
*** 2.分析,路由  routes.php //路由的作用是分析成类和方法调用,路由条目中没有,就不分析了
    $route['default_controller']='pages/view'; 控制器路径
    $route['(:any)'] = 'pages/view/$1';  通配规则
*** 3.制造控制器 News
#+BEGIN_SRC php
class News extends CI_Controller{
}    
#+END_SRC
*** 4.制造数据模型 News_model
****    1.创建数据库表
#+BEGIN_SRC sql
CREATE TABLE news (
    id int(11) NOT NULL AUTO_INCREMENT,
    title varchar(128) NOT NULL,
    slug varchar(128) NOT NULL,
    text text NOT NULL,
    PRIMARY KEY (id),
    KEY slug (slug)
);
#+END_SRC
****    2.在application/models/目录
#+BEGIN_SRC php
class News_model extends CI_Model{

public function __construct()
{
$this->load->database();
}

public function get_news($slug=FALSE)
{
if ($slug===FALSE)
{
$query=$this->db->get('news');
return $query->result_array();
}
$query=$this->db->get_where('news',array('slug'=>$slug));
return $query->row_array();
}
}
#+END_SRC
*** 5.控制器中使用model
#+BEGIN_SRC php
class News externs CI_controller{
public function __construct(){
parent::__construct();
$this->load->model('news_model');
$this->load->helper('url_help');
}
public function index()
{
$data['news']=$this->news_model->get_news();
}
public function view($slug){
$data['news_item']=$this->news_model->get_news($slug);
}
}
#+END_SRC
*** 6.控制器中把数据传递给视图
#+BEGIN_SRC php
public function index(){
: $data['news']=$this->news_model->get_news();
$data['title']="Hello,world";

$this->load->view('templates/header',$data);
$this->load->view('news/index',$data);
$this->load->view('templates/footer');   此视图不传数据
}
#+END_SRC
*** 7.视图中调用数据 application/views/news/index.php ;这里就是前台啦
#+BEGIN_SRC php
<h2><?php echo $title; ?></h2>
<?php foreach($news as $new_item):?>
<h3><?php echo $news_item['title']; ?></h3>
<div class="main">
<?php echo $new_item['text']; ?>
</div>
<?php endforch; ?>
#+END_SRC
*** 8.修改路由
#+BEGIN_SRC php
$route['news/(:any)'] = 'news/view/$1';
$route['news'] = 'news';
#+END_SRC
** 创建数据 
*** 1.表单或jquery
*** 2.控制器验证并插入数据
#+BEGIN_SRC php
class News extends CI_Controller{
public function create()
{
if(INPUT==RIGHT)
{
$this->news_model->set_news();
$this->load->view('news/success');    创建成功返回页面
}
}
}
#+END_SRC
*** 3.插入数据的模块
#+BEGIN_SRC php
public function set_news()
{
$data=array(
'title'=>$this->input->post('title'),
'slug'=>$slug,
'text'=>$this->input->post('text')
);
return $this->db->insert('news',$data);
}
#+END_SRC
** 常规主题
*** CodeIgniter URL
**** (默认) URI分段方式 : example.com/class/function/ID
**** 查询字符串格式 : index.php?c=controller&m=method
*** 配置文件 config/config.php
**** 后缀 .html
**** 启用查询字符串格式
#+BEGIN_SRC php
$config['enable_query_strings'] = FALSE;
$config['controller_trigger'] = 'c';
$config['function_trigger'] = 'm';
#+END_SRC
**** 管理应用程序目录 $application_folder = 'application';
*** 控制器
**** 默认控制器 当 URI 没有分段参数时加载
#+BEGIN_SRC php
$route['default_controller'] = 'blog';
#+END_SRC
**** _remap
: 如果你的控制包含一个 _remap() 方法，那么无论 URI 中包含什么参数时都会调用该方法
**** 处理输出 
: 如果你的控制器含有一个 _output() 方法，输出类将会调用该方法来显示数据， 而不是直接显示数据。该方法的第一个参数包含了最终输出的数据。
#+BEGIN_SRC php
public function _output($output)
{
    echo $output;
}
#+END_SRC
**** 私有方法
只要简单的将方法声明为 private 或 protected 或 _methodname [名字前加下划线]
*** 视图
**** 加载视图$this->load->view('view_name');
**** 将视图作为数据返回
: 如果你将该参数设置为 TRUE ， 该方法返回字符串，默认情况下为 FALSE ，视图将显示到浏览器。
: $string = $this->load->view('myfile', '', TRUE);
*** 模型  
模型是专门用来和数据库打交道的 PHP 类
**** 加载模型 $this->load->model('model_name');
*** 辅助函数
**** 加载辅助函数 $this->load->helper('url');
*** 类库 位于 /system/libraries
**** 加载类库$this->load->library('class_name');
*** 网页缓存
**** 开始缓存$this->output->cache($n);
**** 删除缓存
#+BEGIN_SRC php
// Deletes cache for the currently requested URI
$this->output->delete_cache();
// Deletes cache for /foo/bar
$this->output->delete_cache('/foo/bar');
#+END_SRC
*** 以 CLI 方式运行
: $ php index.php tools message 重新路由了,单一入口
*** 处理环境
: ENVIRONMENT 常量
: define('ENVIRONMENT', isset($_SERVER['CI_ENV']) ? $_SERVER['CI_ENV'] : 'development');
*** URI安全
: CodeIgniter 严格限制 URI 中允许出现的字符，以此来减少恶意数据传到你的应用程序的可能性。
* 什么是变量存在
  PHP 判断常量,变量和函数是否存在
  if (defined('CONST_NAME')) {
  //do something 
  }

变量检测则是使用isset，注意变量未声明或声明时赋值为NULL，isset均返回FALSE，如：

if (isset($var_name)) {
    //do something
}
函数检测用function_exists，注意待检测的函数名也需要使用引号，如：
复制代码 代码如下:

if (function_exists('fun_name')) {
 fun_name();
}
 
先不说多了我们看一个实例
复制代码 代码如下:

<?php 
/* 判断常量是否存在*/ 
if (defined('MYCONSTANT')) { 
echo MYCONSTANT; 
} 
//判断变量是否存在 
if (isset($myvar)) { 
echo "存在变量$myvar."; 
} 
//判断函数是否存在 
if (function_exists('imap_open')) { 
echo "存在函数imag_openn"; 
} else { 
echo "函数imag_open不存在n"; 
} 
?>
 
function_exists判断函数是否存在
复制代码 代码如下:

<?php
if (function_exists('test_func')) {
    echo "函数test_func存在";
} else {
    echo "函数test_func不存在";
}
?>
 
filter_has_var函数
filter_has_var() 函数检查是否存在指定输入类型的变量。
若成功，则返回 true，否则返回 false。

复制代码 代码如下:

<?php
if(!filter_has_var(INPUT_GET, "name"))
 {
 echo("Input type does not exist");
 }
else
 {
 echo("Input type exists");
 }
?>  

输出为. Input type exists

获取文件名(去除后缀) mb_substr($filename,0,mb_strpos($filename,'.'),"utf8");
$path_parts ['dirname'] = rtrim(substr($filepath, 0, strrpos($filepath, '/')),"/")."/";   
$path_parts ['basename'] = ltrim(substr($filepath, strrpos($filepath, '/')),"/");   
$path_parts ['extension'] = substr(strrchr($filepath, '.'), 1);   
 
* PHPUnit入门篇
PHPUnit是什么？
它是一款轻量级的php测试框架
为什么要用PHPUnit？
1. facebook在用
2. 可以通过命令操控测试脚本

3. 可以测试性能

4. 可以测试代码覆盖率

5. 可以自动化的更新测试用例的参数数据

6. 各种格式的日志

7. 最最重要的是，功能如此炫，使用起来还特别简单

PHPUnit的安装

pear channel-discover pear.phpunit.de
pear install phpunit/PHPUnit
快速入门

<?php
require_once 'PHPUnit/Framework.php';
 
class ArrayTest extends PHPUnit_Framework_TestCase
{
    public function testNewArrayIsEmpty()
    {
        // 创建数组fixture。
        $fixture = array();
 
        // 断言数组fixture的尺寸是0。
        $this->assertEquals(0, sizeof($fixture));
    }
}
?>

1. ArrayTest为测试类

2. ArrayTest 继承于PHPUnit_Framework_TestCase

3.测试方法testNewArrayIsEmpty()，测试方法必须为public权限，一般以test开头，或者
你也可以选择给其加注释@test来表明该函数为测试函数

/**
 @test
*/
public function testNewArrayIsEmpty()
{
     $fixture = array();
     $this->assertEquals(0, sizeof($fixture));
}

命令行启动测试

phpunit  测试文件名，此处为要测试ArrayTest.php文件

phpunit ArrayTest
PHPUnit 3.2.10 by Sebastian Bergmann.
..
Time: 0 seconds
OK (2 tests)

命令行参数

phpunit --help
PHPUnit 3.2.10 by Sebastian Bergmann.

Usage: phpunit [switches] UnitTest [UnitTest.php]

  --log-graphviz <file>  Log test execution in GraphViz markup.
  --log-json <file>      Log test execution in JSON format.
  --log-tap <file>       Log test execution in TAP format to file.
  --log-xml <file>       Log test execution in XML format to file.
  --log-metrics <file>   Write metrics report in XML format.
  --log-pmd <file>       Write violations report in PMD XML format.

  --coverage-html <dir>  Generate code coverage report in HTML format.
  --coverage-xml <file>  Write code coverage information in XML format.

  --test-db-dsn <dsn>    DSN for the test database.
  --test-db-log-rev <r>  Revision information for database logging.
  --test-db-prefix ...   Prefix that should be stripped from filenames.
  --test-db-log-info ... Additional information for database logging.

  --testdox-html <file>  Write agile documentation in HTML format to file.
  --testdox-text <file>  Write agile documentation in Text format to file.

  --filter <pattern>     Filter which tests to run.
  --group ...            Only runs tests from the specified group(s).
  --exclude-group ...    Exclude tests from the specified group(s).

  --loader <loader>      TestSuiteLoader implementation to use.
  --repeat <times>       Runs the test(s) repeatedly.

  --tap                  Report test execution progress in TAP format.
  --testdox              Report test execution progress in TestDox format.

  --no-syntax-check      Disable syntax check of test source files.
  --stop-on-failure      Stop execution upon first error or failure.
  --verbose              Output more verbose information.
  --wait                 Waits for a keystroke after each test.

  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.

  --help                 Prints this usage information.
  --version              Prints the version and exits.

  --configuration <file> Read configuration from XML file.
  -d key[=value]         Sets a php.ini value.

高级功能

你是否已经厌烦了在每一个测试方法命名前面加一个test，是否因为只是调用的参数不同
，却要写多个测试用例而纠结？我最喜欢的高级功能，现在隆重推荐给你，叫做框架生成
器

<?php
class Calculator
{
    public function add($a, $b)
    {
        return $a + $b;
    }
}
?>

命令行启动测试用例

phpunit --skeleton Calculator
PHPUnit 3.2.10 by Sebastian Bergmann.

Wrote test class skeleton for Calculator to CalculatorTest.php.

简单么？简单，但是它其实没有什么意义，因为没有测试数据，怎样加数据，哦哦哦，重
头戏来了

<?php
class Calculator
{
    /**
     * @assert (0, 0) == 0
     * @assert (0, 1) == 1
     * @assert (1, 0) == 1
     * @assert (1, 1) == 2
     */
    public function add($a, $b)
    {
        return $a + $b;
    }
}
?>

原始类中的每个方法都进行@assert注解的检测。这些被转变为测试代码，像这样
    /**
     * Generated from @assert (0, 0) == 0.
     */
    public function testAdd() {
        $o = new Calculator;
        $this->assertEquals(0, $o->add(0, 0));
    }
下面是运行生成的测试用例类的输出。

phpunit CalculatorTest
PHPUnit 3.2.10 by Sebastian Bergmann.

....

Time: 0 seconds

OK (4 tests)

阅读全文

  * 本文已收录于以下专栏：

相关文章推荐

    PHPUnit 基本使用
   
    头一次使用这种东西，开始有些手忙脚乱，弄了二天了，终于有点眉目了，记录一下
    过程。　　以下都是在windows下进行，我的php版本是php-5.1.4-win32 　　因为
    phpunit要通过p...
      + jucrazy 
      + jucrazy
      + 2011年08月26日 10:31
      + 14918

    php单元测试入门教程phpunit详解
   
    指对软件中的基本单元进行测试，如函数、方法等，以检查其返回值或行为是否符合
    预期；实际中软件是很复杂的，由许多组件构成，执行流程连贯在一起，要进行单元
    片段的测试，就需要为其提供执行上下文（或者说参数）和...
      + u0114740
      + u011474028
      + 2017年02月14日 16:29
      + 5534

    PHPUnit学习笔记(五)PHPUnit参数详解
   
    PHPUnit参数详解:     本文直接翻译自PHPUnit官方文档,个人翻译水平有限,可能会
    存在某些词和意思翻译不准的地方,进请谅解!     Runs the tests that ...
      + fafa211 
      + fafa211
      + 2012年11月08日 23:39
      + 5142

    PHPUnit的使用
   
    Composer 安装PHPUnitcomposer global require "phpunit/phpunit=5.5.*" 会将
    PHPUnit以全局的形式安装到电脑当中去确保.bash_...
      + lzx_vict
      + lzx_victory
      + 2016年11月28日 15:11
      + 243

    PHPUnit单元测试
   
    PHPUnit单元测试一、概述 1. 什么是单元测试？【百度百科】单元测试是对软件中的
    最小可测单元进行检查和验证。是开发者编写的一小段代码，用于检验被测代码的一
    个很小的、很明确的功能是否...
      + u0108893
      + u010889390
      + 2016年03月15日 18:48
      + 2915

    PHPunit深入了解
   
    一、使用依赖关系通过在测试函数前添加 @depends 注解，来讲需求函数的返回值作
    为参数获取...
      + Register
      + Register_man
      + 2016年12月21日 14:55
      + 395

    Laravel 5.2使用phpunit提示command not found
   
    在Laravel目录下使用phpunit命令提示command not found。如果执行 phpunit 命令
    报错：command not found 或者 permiss...
      + karwik  
      + karwik
      + 2016年04月13日 19:27
      + 1562

    【phpunit】phpunit初次安装使用简记
   
    安装环境 windows7操作系统，php 5.3.28,，已经安装xdeb
      + eightwhe
      + eightwhells
      + 2014年05月31日 18:22
      + 2346

    phpunit功能点整理
   
    只要你想到输入一些东西到print语句或调试表达式中，就用测试代替它。      
    --Martin Fowler 本文档整理参考： phpunit中文手册 http://downl...
      + e4210834
      + e421083458
      + 2012年12月15日 14:54
      + 3268

    phpUnit 优点与注意
   
    回调测试　　对于具有回调方法的 API 来说，这些测试可以确保如果没有定义回调函
    数，代码可以正常运行。另外，这些测试还可以确保在定义了回调函数但是这些回调
    函数操作有误或产生异常时，代码...
      + cakexuex
      + cakexuexi
      + 2013年07月30日 22:23
      + 625

[3_fly_]
   
    fly_heart_yuan
   
    ＋关注

原创
    15

粉丝
    16

喜欢
    0

码云

他的最新文章

更多文章

  * PHPUnit入门篇
  * 服务器并发处理能力
  * Building A Great API

在线课程

  * 腾讯云容
   
    腾讯云容器服务架构实现介绍
   
    讲师：董晓杰
   
  * 容器技术
   
    容器技术在58同城的实践
   
    讲师：姚远
   
他的热门文章

  * PHPUnit入门篇
    17368
  * Nikto
    16985
  * linux下的网络配置命令ipconfig命令详解
    11268
  * web服务器性能测试之利器—apache的ab
    5691
  * 安装MySQL时start service出错的解决办法
    5601

相关推荐

  * PHPUnit 基本使用
  * php单元测试入门教程phpunit详解
  * PHPUnit学习笔记(五)PHPUnit参数详解
  * PHPUnit的使用

  * 0
  * submit
  * 
  * submit
  * submit
  * submit

内容举报
返回顶部
收藏助手
不良信息举报

您举报文章：PHPUnit入门篇                                 
举报原因： ( )色情 ( )政治 ( )抄袭 ( )广告 ( )招聘 ( )骂人
           ( )其他 [                    ]                 
原文地址： [http://             ]                         
           [                    ]                         
           [                    ]                         
原因补充： [                    ]                         
                                                          
           (最多只允许输入30个字)                         
                                                          
           [btn_su] [btn_ca]                              

* php-mode
  执行区域  C-c C-r         php-send-region
  查网页文档 C-c C-f         php-search-documentation
  看手册    C-c RET         php-browse-manual
  标记函数   C-M-h           mark-defun
  注释      C-c C-c         comment-region
  格式化函数 C-c C-q         c-indent-defun
* 安装 php 和 apache2 挂钩的模块
  不同系统安装方式不一样
  apt install libapache2-mod-php php-common
  支持模块 php-curl php-mysql
  会自动添加 extension
* 命名空间
PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：
非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();
。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。
如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。
 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。
限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，
则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。
完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。
在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。
下面是一个使用这三种方式的实例：

file1.php

<?php
namespace Foo\Bar\subnamespace;

const FOO = 1;
function foo() {}
class foo
{
    static function staticmethod() {}
}
?>

file2.php

<?php
namespace Foo\Bar;
include 'file1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function staticmethod() {}
}

/* 非限定名称 */
foo(); // 解析为 Foo\Bar\foo resolves to function Foo\Bar\foo
foo::staticmethod(); // 解析为类 Foo\Bar\foo的静态方法staticmethod。resolves to class Foo\Bar\foo, method staticmethod
echo FOO; // resolves to constant Foo\Bar\FOO

/* 限定名称 */
subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo
subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo,
                                  // 以及类的方法 staticmethod
echo subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO
                                  
/* 完全限定名称 */
\Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo
\Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod
echo \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO
?>
注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 \strlen() 或 \Exception 或 \INI_ALL。

Example #1 在命名空间内部访问全局类、函数和常量

* 简单文件上传 
 注意路径都是相对路径，绝对路径 必须是/home/wuming这种的，要么用常量 ROOT这种
  PHP 文件上传
通过 PHP，可以把文件上传到服务器。
本章节实例在 test 项目下完成，目录结构为：
test
|-----upload             # 文件上传的目录
|-----form.html          # 表单文件
|-----upload_file.php    # php 上传代码
源码下载
创建一个文件上传表单
允许用户从表单上传文件是非常有用的。
请看下面这个供上传文件的 HTML 表单：
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>

<form action="upload_file.php" method="post" enctype="multipart/form-data">
    <label for="file">文件名：</label>
    <input type="file" name="file" id="file"><br>
    <input type="submit" name="submit" value="提交">
</form>

</body>
</html>
将以上代码保存到 form.html 文件中。
有关上面的 HTML 表单的一些注意项列举如下：
<form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 "multipart/form-data"。
<input> 标签的 type="file" 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。
注释：允许用户上传文件是一个巨大的安全风险。请仅仅允许可信的用户执行文件上传操作。
创建上传脚本
"upload_file.php" 文件含有供上传文件的代码：
<?php
if ($_FILES["file"]["error"] > 0)
{
    echo "错误：" . $_FILES["file"]["error"] . "<br>";
}
else
{
    echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
    echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
    echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
    echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"];
}
?>
通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。
第一个参数是表单的 input name，第二个下标可以是 "name"、"type"、"size"、"tmp_name" 或 "error"。如下所示：
$_FILES["file"]["name"] - 上传文件的名称
$_FILES["file"]["type"] - 上传文件的类型
$_FILES["file"]["size"] - 上传文件的大小，以字节计
$_FILES["file"]["tmp_name"] - 存储在服务器的文件的临时副本的名称
$_FILES["file"]["error"] - 由文件上传导致的错误代码
这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。
上传限制
在这个脚本中，我们增加了对文件上传的限制。用户只能上传 .gif、.jpeg、.jpg、.png 文件，文件大小必须小于 200 kB：
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
$extension = end($temp);        // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)    // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"];
    }
}
else
{
    echo "非法的文件格式";
}
?>
保存被上传的文件
上面的实例在服务器的 PHP 临时文件夹中创建了一个被上传文件的临时副本。
这个临时的副本文件会在脚本结束时消失。要保存被上传的文件，我们需要把它拷贝到另外的位置：
<?php
// 允许上传的图片后缀
$allowedExts = array("gif", "jpeg", "jpg", "png");
$temp = explode(".", $_FILES["file"]["name"]);
echo $_FILES["file"]["size"];
$extension = end($temp);     // 获取文件后缀名
if ((($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/jpg")
|| ($_FILES["file"]["type"] == "image/pjpeg")
|| ($_FILES["file"]["type"] == "image/x-png")
|| ($_FILES["file"]["type"] == "image/png"))
&& ($_FILES["file"]["size"] < 204800)   // 小于 200 kb
&& in_array($extension, $allowedExts))
{
    if ($_FILES["file"]["error"] > 0)
    {
        echo "错误：: " . $_FILES["file"]["error"] . "<br>";
    }
    else
    {
        echo "上传文件名: " . $_FILES["file"]["name"] . "<br>";
        echo "文件类型: " . $_FILES["file"]["type"] . "<br>";
        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB<br>";
        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "<br>";
        
        // 判断当期目录下的 upload 目录是否存在该文件
        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777
        if (file_exists("upload/" . $_FILES["file"]["name"]))
        {
            echo $_FILES["file"]["name"] . " 文件已经存在。 ";
        }
        else
        {
            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);
            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];
        }
    }
}
else
{
    echo "非法的文件格式";
}
?>
上面的脚本检测了文件是否已存在，如果不存在，则把文件拷贝到名为 "upload" 的目录下。
文件上传演示操作如下所示：
* php入口文件 的隐藏 , 每个目录下都可以是入口文件, 只要文件名是index.php
index.php 相当于main 函数，apache 默认 会与此文件产生关系。
在url 中隐藏此字串的方法是设置
1.httpd.conf配置文件中加载了mod_rewrite.so模块 //在APACHE里面去配置
#LoadModule rewrite_module modules/mod_rewrite.so把前面的警号去掉
2.AllowOverride None 讲None改为 All      //在APACHE里面去配置
3、在应用入口文件同级目录添加 .htaccess 文件,内容如下:
<IfModule	mod_rewrite.c>
Options	+FollowSymlinks	-Multiviews
RewriteEngine	on
RewriteCond	%{REQUEST_FILENAME}	!-d
RewriteCond	%{REQUEST_FILENAME}	!-f
RewriteRule	^(.*)$	index.php/$1	[QSA,PT,L]
</IfModule>

* 错误
#+BEGIN_SRC php
    ini_set("display_errors", "On");   
    error_reporting(E_ALL); //-1是关闭
#+END_SRC
