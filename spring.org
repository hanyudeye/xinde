* spring or sprint boot
  生成工程 https://start.spring.io/
* 第 1 部分 Spring 的核心 
第 1 章 Spring 之旅 
1.1 简化 Java 开发 
1.1.1 激发 POJO 的潜能 
1.1.2 依赖注入 
1.1.3 应用切面 
1.1.4 使用模板消除样板式代码 
1.2 容纳你的 Bean 
1.2.1 使用应用上下文 
1.2.2 bean 的生命周期 
1.3 俯瞰 Spring 风景线 
1.3.1 Spring 模块 
1.3.2 Spring Portfolio 
1.4 Spring 的新功能 
1.4.1 Spring 3.1 新特性 
1.4.2 Spring 3.2 新特性 
1.4.3 Spring 4.0 新特性 
1.5 小结 
第 2 章 装配 Bean 
2.1 Spring 配置的可选方案 
2.2 自动化装配 bean 
2.2.1 创建可被发现的 bean 
2.2.2 为组件扫描的 bean 命名 
2.2.3 设置组件扫描的基础包 
2.2.4 通过为 bean 添加注解实现自动装配 
2.2.5 验证自动装配 
2.3 通过 Java 代码装配 bean 
2.3.1 创建配置类 
2.3.2 声明简单的 bean 
2.3.3 借助 JavaConfig 实现注入 
2.4 通过 XML 装配 bean 
2.4.1 创建 XML 配置规范 
2.4.2 声明一个简单的<bean> 
2.4.3 借助构造器注入初始化 bean 
2.4.4 设置属性 
2.5 导入和混合配置 
2.5.1 在 JavaConfig 中引用 XML 配置 
2.5.2 在 XML 配置中引用 JavaConfig 
2.6 小结 
第 3 章 高级装配 
3.1 环境与 profile 
3.1.1 配置 profile bean 
3.1.2 激活 profile 
3.2 条件化的 bean 
3.3 处理自动装配的歧义性 
3.3.1 标示首选的 bean 
3.3.2 限定自动装配的 bean 
3.4 bean 的作用域 
3.4.1 使用会话和请求作用域 
3.4.2 在 XML 中声明作用域代理 
3.5 运行时值注入 
3.5.1 注入外部的值 
3.5.2 使用 Spring 表达式语言进行装配 
3.6 小结 
第 4 章 面向切面的 Spring 
4.1 什么是面向切面编程 
4.1.1 定义 AOP 术语 
4.1.2 Spring 对 AOP 的支持 
4.2 通过切点来选择连接点 
4.2.1 编写切点 
4.2.2 在切点中选择 bean 
4.3 使用注解创建切面 
4.3.1 定义切面 
4.3.2 创建环绕通知 
4.3.3 处理通知中的参数 
4.3.4 通过注解引入新功能 
4.4 在 XML 中声明切面 
4.4.1 声明前置和后置通知 
4.4.2 声明环绕通知 
4.4.3 为通知传递参数 
4.4.4 通过切面引入新的功能 
4.5 注入 AspectJ 切面 
4.6 小结 
第 2 部分 Web 中的 Spring 
第 5 章 构建 Spring Web 应用程序 
5.1 Spring MVC 起步 
5.1.1 跟踪 Spring MVC 的请求 
5.1.2 搭建 Spring MVC 
5.1.3 Spittr 应用简介 
5.2 编写基本的控制器 
5.2.1 测试控制器 
5.2.2 定义类级别的请求处理 
5.2.3 传递模型数据到视图中 
5.3 接受请求的输入 
5.3.1 处理查询参数 
5.3.2 通过路径参数接受输入 
5.4 处理表单 
5.4.1 编写处理表单的控制器 
5.4.2 校验表单 
5.5 小结 
第 6 章 渲染 Web 视图 
6.1 理解视图解析 
6.2 创建 JSP 视图 
6.2.1 配置适用于 JSP 的视图解析器 
6.2.2 使用 Spring 的 JSP 库 
6.3 使用 Apache Tiles 视图定义布局 
6.3.1 配置 Tiles 视图解析器 
6.4 使用 Thymeleaf 
6.4.1 配置 Thymeleaf 视图解析器 
6.4.2 定义 Thymeleaf 模板 
6.5 小结 
第 7 章 Spring MVC 的高级技术 
7.1 Spring MVC 配置的替代方案 
7.1.1 自定义 DispatcherServlet 配置 
7.1.2 添加其他的 Servlet 和 Filter 
7.1.3 在 web.xml 中声明 DispatcherServlet 
7.2 处理 multipart 形式的数据 
7.2.1 配置 multipart 解析器 
7.2.2 处理 multipart 请求 
7.3 处理异常 
7.3.1 将异常映射为 HTTP 状态码 
7.3.2 编写异常处理的方法 
7.4 为控制器添加通知 
7.5 跨重定向请求传递数据 
7.5.1 通过 URL 模板进行重定向 
7.5.2 使用 flash 属性 
7.6 小结 
第 8 章 使用 Spring Web Flow 
8.1 在 Spring 中配置 Web Flow 
8.1.1 装配流程执行器 
8.1.2 配置流程注册表 
8.1.3 处理流程请求 
8.2 流程的组件 
8.2.1 状态 
8.2.2 转移 
8.2.3 流程数据 
8.3 组合起来：披萨流程 
8.3.1 定义基本流程 
8.3.2 收集顾客信息 
8.3.3 构建订单 
8.3.4 支付 
8.4 保护 Web 流程 
8.5 小结 
第 9 章 保护 Web 应用 
9.1 Spring Security 简介 
9.1.1 理解 Spring Security 的模块 
9.1.2 过滤 Web 请求 
9.1.3 编写简单的安全性配置 
9.2 选择查询用户详细信息的服务 
9.2.1 使用基于内存的用户存储 
9.2.2 基于数据库表进行认证 
9.2.3 基于 LDAP 进行认证 
9.2.4 配置自定义的用户服务 
9.3 拦截请求 
9.3.1 使用 Spring 表达式进行安全保护 
9.3.2 强制通道的安全性 
9.3.3 防止跨站请求伪造 
9.4 认证用户 
9.4.1 添加自定义的登录页 
9.4.2 启用 HTTP Basic 认证 
9.4.3 启用 Remember-me 功能 
9.4.4 退出 
9.5 保护视图 
9.5.1 使用 Spring Security 的 JSP 标签库 
9.5.2 使用 Thymeleaf 的 Spring Security 方言 
9.6 小结 
第 3 部分 后端中的 Spring 
第 10 章 通过 Spring 和 JDBC 征服数据库 
10.1 Spring 的数据访问哲学 
10.1.1 了解 Spring 的数据访问异常体系 
10.1.2 数据访问模板化 
10.2 配置数据源 
10.2.1 使用 JNDI 数据源 
10.2.2 使用数据源连接池 
10.2.3 基于 JDBC 驱动的数据源 
10.2.4 使用嵌入式的数据源 
10.2.5 使用 profile 选择数据源 
10.3 在 Spring 中使用 JDBC 
10.3.1 应对失控的 JDBC 代码 
10.3.2 使用 JDBC 模板 
10.4 小结 
第 11 章 使用对象-关系映射持久化数据 
11.1 在 Spring 中集成 Hibernate 
11.1.1 声明 Hibernate 的 Session 工厂 
11.1.2 构建不依赖于 Spring 的 Hibernate 代码 
11.2 Spring 与 Java 持久化 API 
11.2.1 配置实体管理器工厂 
11.2.2 编写基于 JPA 的 Repository 
11.3 借助 Spring Data 实现自动化的 JPA Repository 
11.3.1 定义查询方法 
11.3.2 声明自定义查询 
11.3.3 混合自定义的功能 
11.4 小结 
第 12 章 使用 NoSQL 数据库 
12.1 使用 MongoDB 持久化文档数据 
12.1.1 启用 MongoDB 
12.1.2 为模型添加注解，实现 MongoDB 持久化 
12.1.3 使用 MongoTemplate 访问 MongoDB 
12.1.4 编写 MongoDB Repository 
12.2 使用 Neo4j 操作图数据 
12.2.1 配置 Spring Data Neo4j 
12.2.2 使用注解标注图实体 
12.2.3 使用 Neo4jTemplate 
12.2.4 创建自动化的 Neo4j Repository 
12.3 使用 Redis 操作 key-value 数据 
12.3.1 连接到 Redis 
12.3.2 使用 RedisTemplate 
12.3.3 使用 key 和 value 的序列化器 
12.4 小结 
第 13 章 缓存数据 
13.1 启用对缓存的支持 
13.1.1 配置缓存管理器 
13.2 为方法添加注解以支持缓存 
13.2.1 填充缓存 
13.2.2 移除缓存条目 
13.3 使用 XML 声明缓存 
13.4 小结 
第 14 章 保护方法应用 
14.1 使用注解保护方法 
14.1.1 使用@Secured 注解限制方法调用 
14.1.2 在 Spring Security 中使用 JSR-250 的@RolesAllowed 注解 
14.2 使用表达式实现方法级别的安全性 
14.2.1 表述方法访问规则 
14.2.2 过滤方法的输入和输出 
14.3 小结 
第 4 部分 Spring 集成 
第 15 章 使用远程服务 
15.1 Spring 远程调用概览 
15.2 使用 RMI 
15.2.1 导出 RMI 服务 
15.2.2 装配 RMI 服务 
15.3 使用 Hessian 和 Burlap 发布远程服务 
15.3.1 使用 Hessian 和 Burlap 导出 bean 的功能 
15.3.2 访问 Hessian/Burlap 服务 
15.4 使用 Spring 的 HttpInvoker 
15.4.1 将 bean 导出为 HTTP 服务 
15.4.2 通过 HTTP 访问服务 
15.5 发布和使用 Web 服务 
15.5.1 创建基于 Spring 的 JAX-WS 端点 
15.5.2 在客户端代理 JAX-WS 服务 
15.6 小结 
第 16 章 使用 Spring MVC 创建 REST API 
16.1 了解 REST 
16.1.1 REST 的基础知识 
16.1.2 Spring 是如何支持 REST 的 
16.2 创建第一个 REST 端点 
16.2.1 协商资源表述 
16.2.2 使用 HTTP 信息转换器 
16.3 提供资源之外的其他内容 
16.3.1 发送错误信息到客户端 
16.3.2 在响应中设置头部信息 
16.4 编写 REST 客户端 
16.4.1 了解 RestTemplate 的操作 
16.4.2 GET 资源 
16.4.3 检索资源 
16.4.4 抽取响应的元数据 
16.4.5 PUT 资源 
16.4.6 DELETE 资源 
16.4.7 POST 资源数据 
16.4.8 在 POST 请求中获取响应对象 
16.4.9 在 POST 请求后获取资源位置 
16.4.10 交换资源 
16.5 小结 
第 17 章 Spring 消息 
17.1 异步消息简介 
17.1.1 发送消息 
17.1.2 评估异步消息的优点 
17.2 使用 JMS 发送消息 
17.2.1 在 Spring 中搭建消息代理 
17.2.2 使用 Spring 的 JMS 模板 
17.2.3 创建消息驱动的 POJO 
17.2.4 使用基于消息的 RPC 
17.3 使用 AMQP 实现消息功能 
17.3.1 AMQP 简介 
17.3.2 配置 Spring 支持 AMQP 消息 
17.3.3 使用 RabbitTemplate 发送消息 
17.3.4 接收 AMQP 消息 
17.4 小结 
第 18 章 使用 WebSocket 和 STOMP 实现消息功能 
18.1 使用 Spring 的低层级 WebSocket API 
18.2 应对不支持 WebSocket 的场景 
18.3 使用 STOMP 消息 
18.3.1 启用 STOMP 消息功能 
18.3.2 处理来自客户端的 STOMP 消息 
18.3.3 发送消息到客户端 
18.4 为目标用户发送消息 
18.4.1 在控制器中处理用户的消息 
18.4.2 为指定用户发送消息 
18.5 处理消息异常 
18.6 小结 
第 19 章 使用 Spring 发送 Email 
19.1 配置 Spring 发送邮件 
19.1.1 配置邮件发送器 
19.1.2 装配和使用邮件发送器 
19.2 构建丰富内容的 Email 消息 
19.2.1 添加附件 
19.2.2 发送富文本内容的 Email 
19.3 使用模板生成 Email 
19.3.1 使用 Velocity 构建 Email 消息 
19.3.2 使用 Thymeleaf 构建 Email 消息 
19.4 小结 
第 20 章 使用 JMX 管理 Spring Bean 
20.1 将 Spring bean 导出为 MBean 
20.1.1 通过名称暴露方法 
20.1.2 使用接口定义 MBean 的操作和属性 
20.1.3 使用注解驱动的 MBean 
20.1.4 处理 MBean 冲突 
20.2 远程 MBean 
20.2.1 暴露远程 MBean 
20.2.2 访问远程 MBean 
20.2.3 代理 MBean 
20.3 处理通知 
20.3.1 监听通知 
20.4 小结 
第 21 章 借助 Spring Boot 简化 Spring 开发 
21.1 Spring Boot 简介 
21.1.1 添加 Starter 依赖 
21.1.2 自动配置 
21.1.3 Spring Boot CLI 
21.1.4 Actuator 
21.2 使用 Spring Boot 构建应用 
21.2.1 处理请求 
21.2.2 创建视图 
21.2.3 添加静态内容 
21.2.4 持久化数据 
21.2.5 尝试运行 
21.3 组合使用 Groovy 与 Spring Boot CLI 
21.3.1 编写 Groovy 控制器 
21.3.2 使用 Groovy Repository 实现数据持久化 
21.3.3 运行 Spring Boot CLI 
21.4 通过 Actuator 获取了解应用内部状况 
21.5 小结 
看完了 
* sprint boot
  创建项目 mvn archetype:generate -DgroupId=springboot
  -DartifactId=springboot-helloworld
  -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
** 生成执行  
mvn clean install 生成 jar 程序
java -jar target/test-1.0.0-BUILD-SNAPSHOT.jar  执行 jar 程序
** hello world
   创建 controller 包
   
   #+begin_src java 

     @RestController
     public class HelloController {

       @RequestMapping("/hello")
       public String hello() {
           return "Hello World! Welcome to visit waylau.com!";
       }
     }

   #+end_src
   : 其中`@RestController`等价于`@Controller`与`@ResponseBody`的组合。
  @RestController = @Controller + @ResponseBody 

  `@ResponseBody`:该注解指示方法返回值的应绑定到 Web 响应正文。
 `@RequestMapping`:是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。根据方法的不同，还可以用`GetMapping`、`PostMapping`、`PutMapping`、`DeleteMapping`、`PatchMapping`代替。
 `@RestController`：暗示用户，这是一个支持 REST 的控制器。

*** 编写测试用例
    创建    controller 包

   #+begin_src java 
     // 太复杂
          import org.junit.Test;
          import org.junit.runner.RunWith;
          import org.springframework.boot.test.context.SpringBootTest;
          import org.springframework.test.context.junit4.SpringRunner;


          @RunWith(SpringRunner.class)
          @SpringBootTest
          @AutoConfigureMockMvc
          public class HelloControllerTest {

              @Autowired
              private MockMvc mockMvc;

              @Test
              public void testHello() throws Exception {
                  System.out.println("im in test");
              }
          }
   #+end_src
** 引入 web 模块
1、pom.xml 中添加支持 web 的模块：
<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
 </dependency>

pom.xml 文件中默认有两个模块：

spring-boot-starter：核心模块，包括自动配置支持、日志和 YAML；
spring-boot-starter-test：测试模块，包括 JUnit、Hamcrest、Mockito。
开发环境的调试

热启动在正常开发项目中已经很常见了吧，虽然平时开发 web 项目过程中，改动项目启重
启总是报错；但 springBoot 对调试支持很好，修改之后可以实时生效，需要添加以下的配
置：

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
   </dependency>
</dependencies>
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <fork>true</fork>
            </configuration>
        </plugin>
   </plugins>
</build>

该模块在完整的打包环境下运行的时候会被禁用。如果你使用 java -jar 启动应用或者用
一个特定的 classloader 启动，它会认为这是一个“生产环境”。

使用 spring boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适
用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 sping
boot 非常适合构建微服务。
* SpringMVC 框架
* Spring Cloud 框架
可以实现一整套分布式系统的解决方案（当然其中也包括微服务架构的方案），包括服务注
册、服务发现、监控等，而 Spring Boot 只是作为开发单一服务的框架的基础。

