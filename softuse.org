# 汇编程序员和c程序员看到的机器差别很大.
# c不可视部分: 程序计数器;整数寄存器;条件码寄存器;浮点寄存器 器官

* shell
: locate	本地关键字

* emacs
: mark->复制->粘贴 	set-mark-command
: (define-key global-map [C-return] 'set-mark-command)
: m-x hexl-mode
: 设置输入法 set-input-mode
: 注释区块 string-rectangle C-x r t   反注释 uncomment-region
* gcc   
** 1. 预处理 gcc -E test.c -o test.i
** 2. 编译为汇编代码   gcc -S test.i -o test.s
** 3. 汇编  gcc -c test.s -o test.o
** 4. linking  gcc test.o -o test
: 汇编代码	masm=intel 
: m32
: c 编译 成elf(ELF(Executable and Linking Format)是一种对象文件的格式，
	用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。)目标文件
	c 选项识别汇编语言,对于c语言,要先运行S 汇编选项
	O2 优化级别,编译时间会长,O0不优化 可以用time测试
	-E 预处理
	S 可以把.开头的行删除便于理解
	g 表示将源代码信息编译到可执行文件中
	o 输出目标文件或库文件,起个名字

	-std=c99 /c89/gnu99/c++98
** 5. 检错
: -Wall 产生尽可能多的警告信息
: -Werror GCC会在所有产生警告的地方停止编译
** 6. 库文件连接 
: 包含文件-I 
: 库

* as
#+Target: 此as编译器能编译各种机器的汇编语言,可以指定面向的汇编语言
#+i386 中可以[-march=CPU]| [-32|-x32|-64]
: 	o 同gcc,输出目标文件或库文件,起个名字
: 	as 命令时带上参数 [-g|--gstabs] 可以告诉汇编器在生成的目标代码中加上符号表，
	所有的系统调用功能号都可以在文件 /usr/include/bits/syscall.h 中找到，为了便于使用，
	它们是用 SYS_<name> 这样的宏来定义的，如 SYS_write、SYS_exit 等。例如，经常用到的 write 函数是如下定义的：
	ssize_t write(int fd, const void *buf, size_t count); 
	该函数的功能最终是通过 SYS_write 这一系统调用来实现的。根据上面的约定，参数 fb、buf 和 count 分别存在寄存器 ebx、ecx 和 edx 中，而系统调用号 SYS_write 则放在寄存器 eax 中，当 int 0x80 指令执行完毕后，返回值可以从寄存器 eax 中获得。
:'-I DIR'   Add directory DIR to the search list for '.include' directory.

* ld
: 合并一组目标文件(object)和库文件(archive), 重定位数据部分, 
: 构建 符号引用(symbol reference). 一般说来, 编译 生成 可执行文件的最后步骤就是 调用 ld. 	
: o 这里的输出是执行文件 ,缺省的输出文件名是'a.out'.
: [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
: -lAR	在连接文件列表中增加归档库文件AR.可以多次使用这个选项. 凡指定一项AR,ld 就会在路径列表中增加一项对libar.a的搜索.
: -LSEARCHDIR   这个选项将路径SEARCHDIR添加到路径列表, ld在这个列表中搜索归档库.
  可以多次使用这个选项.缺省的搜索路径集(不使用-L时)取决于ld使用的
  模拟模式(emulation)及其配置.在连接脚本中,可以用SEARCH_DIR命令指定路径. 
: -Olevel    生成 优化的 输出文件
: -S    去掉 输出文件 中的 调试符号信息 (但不是 所有符号).
: -s    去掉 输出文件 中的 全部 符号信息. 
: -Tbss org
: -Tdata org
: -Ttext org
  把org作为输出文件的段起始地址 --- 特别是 --- bss,data,或text段.org必须是十六进制整数. 
: -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
: -x    删除 全部 局部符号. 
: -m 指定仿真环境,这里要与gcc 的选项 -m32一致; -V显示 支持的仿真：本机支持   elf_x86_64   
  elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
  LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
: 注意,如果连接器通过被编译器驱动来间接引用(比如gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
  gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
: `-b INPUT-FORMAT'
  `--format=INPUT-FORMAT' [binary]
  'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
  你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
: `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld的缺省输出格式配置
  为/各个机器上最常用的/ 格式. output-format是一个 字符串,BFD库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
: [`-N']|[`--omagic']
  把text和data节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
  支持Unix风格的magic number, 把输出标志为'OMAGIC'. 

* readelf
: -a       --all
  Equivalent to specifying --file-header, --program-headers, --sections, --symbols, --relocs, --dynamic, --notes and--version-info
  [1] elf header描述了这个elf文件的一些信息，如数据格式是big-endian 或者little-endian、运行平台、section header 的个数等。
  [2] section headers是一个表，表中的每个条目描述了一个section，如section在文件中的偏移，大小等。
  [3] section中就是elf文件中“真正”的信息了。

* objdump
: d反汇编

* gdb	
* samba
  创建共享目录:
  mkdir /home/xxx/share   sudo chmod 777 /home/xxx/share  说明：xxx为你的ubuntu的用户名　　　  share你可以随便起个名字做为共享文件夹	
  修改现配置文件
  sudo gedit /etc/samba/smb.conf
:  在smb.conf最后添加
	    　[share]
	     path = /home/xxx/share      
	     available = yes
	     browseable = yes
	     public = yes
             writable = yes
	     valid users =myname
	     create mask = 0700
	     directory mask =0700
	     force user =nobody
	     force group = nogroup
	     sudo smbpasswd -a myname
: 说明：valid users = myname　这个myname是自己起的，后面在添加用户名时就是添加的这个
	     另外这个[share]名字也是可以随便起的，这个是你在windows下访问时显示的名字在windows下\\162.168.160.11\share
	     就可以访问linux下/home/god/code目录下的内容了    其中162.168.160.11是你linux的IP地址,用ifconfig就可以查看到
	     samba服务器配置

* ubuntu
  休眠		 pm-hibernate
  待机	 

* grep
  排除	v

* git
# 在本地建立一个文件夹，然后做一些全局变量的初始化	git config --global user.name = "用户名或者用户ID"
# git config --global user.email = "邮箱"
# 这两个选项会在以后的使用过程中自动添加到代码中。
** 创建验证用的公钥
: 这个是比较复杂和困扰大多数人的地方，因为 git 是通过 ssh 的方式访问资源库的，所以需要在本地创建验证用的文件。
: 使用命令：ssh-keygen -C 'you email address@gmail.com' -t rsa
: 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
: 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
** 上传公钥
# 在 github.com 的界面中 选择右上角的 Account Settings，然后选择 SSH Public Keys ，选择新加。
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。看到下面的信息表示验证成功。
# 进行到这里，我们也可以利用github来管理我们的项目和参与开源工作了，大体上使用git分为三种方式。

# 创建一个版本库
 git init
# 每次修改好了后，可以先将修改存入stage(快照/索引)中
git add <modified files>
# 修改了大量文件则使用下面这个命令批量存入
git add .
# 使用commit将快照/索引中的内容提交到版本库中
git commit -m "msg"
# 也可以将git add与git commit用一个指令完成
git commit -a -m "msg"
# 将本地的git档案与github(远程)上的同步
git push
# 将github(远程)的git档案与本地的同步(即更新本地端的repo)
git pull
# 例如,pull指令其实包含了fetch(將变更复制回來)以及merge(合并)操作
git pull git://github.com/tom/test.git

# 另外版本控制系統的branch功能也很有意思，若同时修改bug，又要加入新功能，可以fork出一个branch：一个专门修bug，一个专门加入新功能，等到稳定后再merge合并
git branch bug_fix # 建立branch，名为bug_fix
git checkout bug_fix # 切换到bug_fix
git checkout master #切换到主要的repo
git merge bug_fix #把bug_fix这个branch和现在的branch合并

# 若有remote的branch，想要查看并checkout
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local

# 还有其它可以查看repo状态的工具
git log #可以查看每次commit的改变
git diff #可以查看最近一次改变的內容，加上参数可以看其它的改变并互相比较
git show #可以看某次的变更

# 若想知道目前工作树的状态，可以輸入
git status	

* emacs 
** 键盘宏
   + C-x ( 开始录制宏
   + C-x ) 录制结束
   + C-u [执行次数] C-x e 执行键盘宏
   + 录制过程：
   + 删除若干空格(左移偏移量) 命令 C-d
   + 下一行 C-n
   + 行头 C-a
** 选择块
   C-x C-q 切换为只读或者读写模式
   C-x i 插入文件
	撤销 C-/
	多行注释 C-x r t
	反注释	 C-x r k
	关闭窗口 C-x 0
	窗口移动 M-x windmove-left /right /down
	替换windows换行M-x replace-string RET C-q C-m RET RET


	gdb –annotate=3 test回车就进入了调试模式
	annotate = 0是最基本的模式和在命令行使用gdb完全一样。
	annotate = 1是单步调试模式，出现上下两个窗口，上面是gdb运行的buffer，下面是你代码的buffer，会在代码 buffer中，同步指示当前运行的语句的位置。
	annotate = 2是产生注解的模式。
	annotate = 3是信息最完整的模式。此时的 Emacs 分5个 buffer，从上到下、从左到右依次是：gdb 调试窗口、变量实时变化显示窗口、源代码窗口、栈窗口、断点信息
	无论上面的那种情况，都出现了一个现象：程序的输出不能显示，只有在程序退出的时候才显示出来。
	gdb-many-windows 切换单窗格/多窗格模式
	gdb-restore-windows 恢复窗格布局	
		
		常用的调试命令，可以简写
		命令 		意义					用法
		list 		从第一行开始列出源码（默认10行）	  l; l 3 （开始行）
		break		设置断点。				  b <行号>;b <函数名称>;b *<函数名称>;b *<代码地址>
		run		开始调试程序	  			  r
		continue   	继续执行被调试程序，直至下一个断点	  c
		clear 		删除特定行的断点 			  clear <行号>
		delete 		删除断点，编号从1开始   		  d <编号>
		next line	执行一行源程序代码，此行代码中的函数调用也一并执行。 	        n
		step line       执行一行源程序代码，如果此行代码中有函数调用，则进入该函数 	  s
		until 		结束当前循环 				   until
		print 		print p ;print $1 ($1为历史记录变量); p <数组名>显示数组元素：p <*数组指针>显示数组int a[N]的特定值：
				   	① p *a@10;② p (int [10])*10
		whatis 		可以显示某个变量的类型			    whatis p
		info 		用于显示各类信息 			    如：info b 显示断点信息;info r 寄存器信息;info local 显示当                                                                            前函数中的局部变量信息;info prog 显示被调试程序的执行状态
		quit 		退出gdb调试				    q

vim
	ngg跳到指定行	| :n 指定行 |vim +n FileName 打开文件既跳转
	:set number 显示行号 autoindent cindent(c语言自动缩进)
	:syntax on 



du	磁盘使用
	-b filename ->filename 占用多少字节 -k -m (多少K,兆)


emacs-w3m
	例如收到的一封电子邮件里有一个指向某个Web站点，或FTP站点的URL地址，于是想去看一看。 移动到该URL地址处并输入 ESC x w3-follow-URL-at-point 就会转到那个站点去。
	如果对那个站点上的东西感兴趣，则可以把它添加到收藏夹里，或者用 C-x C-w (另存为)组合键把该 主页上的内容保存到一个文件里去。
	也可以在不退出Emacs的情况下浏览自己编写的HTML文档，输入 ESC x w3-open-local RET filename RET 命令即可。

	快捷键	功能
	q	关闭窗口
	Q	直接离开
	U	打开 URL
	V	打开文件
	C-x-k	关闭当前标签页
	G	在标签页中打开一个网址
	c-c c-p	上一标签
	c-c c-n	下一标签
	S	用google进行搜索
	B	后退
	ESC I	图片另存为 
	=   	显示当前页面属性 
	N	前进
	H	主页
	R	刷新
	C-n	下一行
	C-p	向上一行
	C-b	向后
	C-f	向前
	C-v	向下滚屏
	ESC v	向上滚屏
	F   	提交表单 
	打开链接	RET
	>		向右滚屏
	<		向左滚屏
	,		向左移动一格
	.		向右移动一格
	 书签
	快捷键	功能
	a	添加当前页到书签
	ESC a	添加该URL到书签
	v   显示书签
	E   编辑书签
	C-k 删除书签
	C-_ 撤消书签
	M   用外部浏览器打开当前页面
	ESC M	用外部浏览器打开链接
	C-c C-k	停止载入

* bochs
** bximage--->创建软盘/硬盘映像
#+title:	debug command
| 断点                            | b 0x7c00         |
| 查看寄存器信息                  | info cpu         |
|                                 | r                |
|                                 | fp               |
|                                 | sreg             |
|                                 | creg             |
| 断点信息                        | info break       |
| 执行                            | c                |
|                                 | n                |
|                                 | s  N             |
| 查看堆栈                        | print-stack      |
| 查看物理地址内容                | xp /nuf addr     |
| .. 线性.......                  | x /nuf addr      |
| 查看帮助                        | help xx          |
| 反汇编内存                      | u start end      |
| 反汇编每一条                    | trace on         |
| 每执行一条打印cpu               | trace-reg on     |
| 查询从0x90000开始的32个字节内容 | xp /32bx 0x90000 |
* head
-c  xx xx字节
-n 行
* hexdump
-c 每单元以字节为单位，显示出对应的ASCII码
-C 每单元以字节为单位，同时显示十六机制和ASCII码
* qemu	
  [-fda fdb] Use file as floppy disk 0/1 image	     
* objcopy拷贝一个目标文件的内容到另一个目标文件中,bfdname是BFD库中描述的标准格式名
: -I bfdname或--input-target=bfdname  用来指明源文件的格式,取值elf32-little，elf32-big等，可用用objdump –i查看相应的信息
: -O bfdname 或--output-target=bfdname 输出的格式
: -R sectionname 从输出文件中删除掉所有名为sectionname的段
: -S 不从源文件中复制重定位信息和符号信息到目标文件中
: -g 不从源文件中复制调试符号到目标文件中
: -j sectionname 或--only-section=sectionname 只将由sectionname指定的section拷贝到输出文件
: -K symbolname 保留由symbolname指定的符号信息
: -N symbolname 去除掉由symbolname指定的符号信息
* dd
  if=boot.bin of=a.img bs=512 count=1 conv=notrunc
* apt
: apt-cache search 'expression'
: apt-get source libc6-dev 下载源代码

* mount
 mount  [-t vfstype] [-o options] device dir
** 1.-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：
　　光盘或光盘镜像：iso9660
　　DOS fat16文件系统：msdos
　　Windows 9x fat32文件系统：vfat
　　Windows NT ntfs文件系统：ntfs
　　Mount Windows文件网络共享：smbfs
　　UNIX(LINUX) 文件网络共享：nfs
** 　2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
　　loop：用来把一个文件当成硬盘分区挂接上系统
　　ro：采用只读方式挂接设备
　　rw：采用读写方式挂接设备
　　iocharset：指定访问文件系统所用字符集,不能显示中文 iocharset=cp936
** 3.device 要挂接(mount)的设备。
** 4.dir设备在系统上的挂接点(mount point)。
** sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览windows 共享文件夹
* fdisk -l查看磁盘
* find	find pathname -options [-print -exec -ok ...]
  : 搜索文件,并执行操作
  : pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。
  : -print： find命令将匹配的文件输出到标准输出。
  : -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
  : -ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。

  : -name   按照文件名查找文件。
  : -perm   按照文件权限来查找文件。
  : -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
  : -user   按照文件属主来查找文件。
  : -group  按照文件所属的组来查找文件。
  : -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距
  : 现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。
  : -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
  : -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
  : -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。
  : -type  查找某一类型的文件，诸如：
  + b - 块设备文件。
  + d - 目录。
  + c - 字符设备文件。
  + p - 管道文件。
  + l - 符号链接文件。
  + f - 普通文件。
  + -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
  + -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
  + -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。
  + -mount：在查找文件时不跨越文件系统mount点。
  + -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
  + -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。

*** 另外,下面三个的区别:
  : -amin n   查找系统中最后N分钟访问的文件  -n n天以内;+n n天之前
  : -atime n  查找系统中最后n*24小时访问的文件
  :  -cmin n   查找系统中最后N分钟被改变文件状态的文件
  :  -ctime n  查找系统中最后n*24小时被改变文件状态的文件
  :  -mmin n   查找系统中最后N分钟被改变文件数据的文件
  :  -mtime n  查找系统中最后n*24小时被改变文件数据的文件
  : find  ./    -mtime    -1    -type f    -ok   ls -l    {} \;  
  : find .    -perm -007    -exec ls -l {} \;  

* awk
	: awk '{print $1}'

* dmesg
# linux 错误消息控制
# clear 
# 查看  一般看最后几行 tail

* fsck.vat

* Org Mode	
** 标题
*** 文章标题 #+TITLE: xx
*** 正文标题 *
** 字体
   *粗体*
   /斜体/
   +删除线+
   _下划线_
   下标: H_2 O H 2 O 
   上标: E=mc^2
   等宽字:=git=
   # 注释 
   :抽屉:
** 列表
*** 无序    -|+|*
*** 有序    1.|1
*** 描述    ::
** 内容元数据
s    #+begin_src ... #+end_src 
e    #+begin_example ... #+end_example  : 单行的例子以冒号开头
q    #+begin_quote ... #+end_quote      通常用于引用，与默认格式相比左右都会留出缩进
v    #+begin_verse ... #+end_verse      默认内容不换行，需要留出空行才能换行
c    #+begin_center ... #+end_center 
l    #+begin_latex ... #+end_latex 
L    #+latex: 
h    #+begin_html ... #+end_html 
H    #+html: 
a    #+begin_ascii ... #+end_ascii 
A    #+ascii: 
i    #+index: line 
I    #+include: line
上面的单字母为快捷键字母，如输入一个<s 然后TAB后就变为
注释 
** 以‘#‘开头的行被看作注释，不会被导出区块注释采用如下写法：
#+BEGIN_COMMENT
  块注释
  ...
#+END_COMMENT
** 表格与图片 
对于表格和图片，可以在前面增加标题和标签的说明，以方便交叉引用。比如在表格的前面添加：
#+CAPTION: This is the caption for the next table (or link)
则在需要的地方可以通过\ref{table1}来引用该表格。 
** TODO 待办事项（TODO ）
#+beg org-mode可以利用Emacs的时间空间插入当前时间。
  输入C-c . 会出现一个日历，我们点选相应的时间即可插入
  时间前可以加DEADLINE:和SCHEDULED:表示时间的类型如：
#+end 富文本
** 代码格式化
#符合emacs 模式时
#+BEGIN_SRC emacs-lisp -n -r
     (defun org-xor (a b)          (ref:df)
        "Exclusive or."             
        (if a (not b) b))
#+END_SRC

** 格式导出与发布 
1.C-c C-e a 导出为文本文件。
2.C-c C-e h 导出为 HTML 文件 
* Emacs 插件	
# ido, 类似于helm,和helm各有千秋我都用,五五开,
# imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置
# flymake 实时语法检查,通吃所有语言
# flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
