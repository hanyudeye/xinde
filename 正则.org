* 正则 
  foo ——————字符串"foo" 
  ^foo ——————以"foo"开头的字符串 
  foo$ ——————以"foo"结尾的字符串 
  ^foo$ ——————"foo"开头和结尾，（只能是他自己 ） 
  [abc]—————— a 或者 b 或者 c 
  [a-z] —————— a 到 z 之间任意字母 
  [^A-Z]——————除了 A-Z 这些之外的字符 
  (gif|jpg)——————"gif"或者 "jpeg" 
  [a-z]+—————— 一个或者多个 a 到 z 之间任意字母
  [0-9.-]—————— 0-9 之间任意数字，或者 点 或者 横线
  ^[a-zA-Z0-9_]{1,}$—————— 至少一个字母数字下划线 
  ([wx])([yz])—————— wy 或 wz 或 xy 或 xz
  [^A-Za-z0-9]—————— 字符数字之外的字符 
  ([A-Z]{3}|[0-9]{4})—————— 三个大写字母或者 4 个数字
  \B 匹配非单词边界。
  'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 
  \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
 \d 匹配一个数字字符。等价于 [0-9]。 
\D 匹配一个非数字字符。等价于 [^0-9]。
 \f 匹配一个换页符。等价于 \x0c 和 \cL。 
 \n 匹配一个换行符。等价于 \x0a 和 \cJ。
 \r 匹配一个回车符。等价于 \x0d 和 \cM。 
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 
\t 匹配一个制表符。等价于 \x09 和 \cI。 
\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。
 \w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。 
\W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。 
\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。. 
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 
\n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 
\nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。
如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。
例如， \u00A9 匹配版权符号 (?)。 常用的正则表达式 1、非负整数："^\d+$" 
2、正整数："^[0-9]*[1-9][0-9]*$" 
3、非正整数："^((-\d+)|(0+))$" 4、负整数："^-[0-9]*[1-9][0-9]*$" 5、整数："^-?\d+$" 6、非负浮点数："^\d+(\.\d+)?$"
7、正浮点数："^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$" 8、非正浮点数："^((-\d+\.\d+)?)|(0+(\.0+)?))$" 
9、负浮点数："^(-((正浮点数正则式)))$" 10、英文字符串："^[A-Za-z]+$" 11、英文大写串："^[A-Z]+$" 
12、英文小写串："^[a-z]+$" 13、英文字符数字串："^[A-Za-z0-9]+$" 14、英数字加下划线串："^\w+$" 
15、E-mail 地址："^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$" 16、URL："^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$" 
PHP 常用正则表达式整理 表单验证匹配 验证账号，字母开头，允许 5-16 字节，允许字母数字下划线：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 验证账号，不能为空，不能有空格，只能是英文字母：^\S+[a-z A-Z]$ 验证账号，不能有空格，不能非数字：^\d+$ 验证用户密码，以字母开头，长度在 6-18 之间：^[a-zA-Z]\w{5,17}$ 验证是否含有 ^%&',;=?$\ 等字符：[^%&',;=?$\x22]+ 匹配 Email 地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 匹配腾讯 QQ 号：[1-9][0-9]{4,} 匹配日期，只能是 2004-10-22 格式：^\d{4}\-\d{1,2}-\d{1,2}$ 匹配国内电话号码：^\d{3}-\d{8}|\d{4}-\d{7,8}$ 评注：匹配形式如 010-12345678 或 0571-12345678 或 0831-1234567 匹配中国邮政编码：^[1-9]\d{5}(?!\d)$ 匹配身份证：\d{14}(\d{4}|(\d{3}[xX])|\d{1}) 评注：中国的身份证为 15 位或 18 位 不能为空且二十字节以上：^[\s|\S]{20,}$ 字符匹配 匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$ 匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$ 匹配由 26 个小写英文字母组成的字符串：^[a-z]+$ 匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$ 匹配由数字、
26 个英文字母或者下划线组成的字符串：
^\w+$ 匹配空行：\n[\s| ]*\r 匹配任何内容：[\s\S]* 匹配中文字符：[\x80-\xff]+ 或者 [\xa1-\xff]+ 只能输入汉字：^[\x80-\xff],{0,}$ 匹配双字节字符(包括汉字在内)：[^\x00-\xff] 匹配数字 只能输入数字：^[0-9]*$ 只能输入 n 位的数字：^\d{n}$ 只能输入至少 n 位数字：^\d{n,}$ 只能输入 m-n 位的数字：^\d{m,n}$ 匹配正整数：^[1-9]\d*$ 匹配负整数：^-[1-9]\d*$ 匹配整数：^-?[1-9]\d*$ 匹配非负整数（正整数 + 0）：^[1-9]\d*|0$ 匹配非正整数（负整数 + 0）：^-[1-9]\d*|0$ 匹配正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 匹配负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 匹配浮点数：^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 匹配非负浮点数（正浮点数 + 0）：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 匹配非正浮点数（负浮点数 + 0）：^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 其他 匹配 HTML 标记的正则表达式（无法匹配嵌套标签）：<(\S*?)[^>]*>.*?</\1>|<.*? /> 匹配网址 URL：[a-zA-z]+://[^\s]* 匹配 IP 地址：((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?) 匹配完整域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.? 提示 上述正则表达式通常都加了 ^ 与 $ 来限定字符的起始和结束，如果需要匹配的内容包括在字符串当中，可能需要考虑去掉 ^ 和 $ 限定符。 以上正则表达式仅供参考，使用时请检验后再使用 s

  ^                Matches the beginning of a line.
  $                Matches the end of a line.
  .                Matches any single character (like ? in filenames).
  .*               Matches any group of zero or more characters 
  \<               Matches the beginning of a word.
  \>               Matches the end of a word.
  []               Matches any character specified within the brackets; for example, [a-z]
  \{n,m\}          表示它前面的单个字符重新的次数
  \s, \S           \S matches any character except whitespace.
  \d, \D           Matches any single digit, 0-9; \D matches any character but a digit.
  \w, \W           Matches any "word" character (upper- and lowercase letters, digits, and the
  
* zhengzhe
# 一、概述

正则表达式用于文本内容的查找和替换。

正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。

[正则表达式在线工具](https://regexr.com/)

# 二、匹配单个字符

**.**  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；

**.**  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。

正则表达式一般是区分大小写的，但是也有些实现是不区分。

**正则表达式** 

```
nam.
```

**匹配结果** 

My  **name**  is Zheng.

# 三、匹配一组字符

**[ ]**  定义一个字符集合；

0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。

**-**  只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；

**^**  在 [ ] 中是取非操作。

**应用** 

匹配以 abc 为开头，并且最后一个字母不为数字的字符串：

**正则表达式** 

```
abc[^0-9]
```

**匹配结果** 

1.  **abcd** 
2. abc1
3. abc2

# 四、使用元字符

## 匹配空白字符

|  元字符 | 说明  |
| :---: | :---: |
|  [\b] | 回退（删除）一个字符   |
|  \f |  换页符 |
|  \n |  换行符 |
|  \r |  回车符 |
|  \t |  制表符 |
|  \v |  垂直制表符 |

\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。

\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行；

## 匹配特定的字符类别

### 1. 数字元字符

|  元字符 | 说明  |
| :---: | :---: |
| \d  | 数字字符，等价于 [0-9]  |
| \D  | 非数字字符，等价于 [^0-9]   |

### 2. 字母数字元字符

|  元字符 | 说明  |
| :---: | :---: |
| \w  |  大小写字母，下划线和数字，等价于 [a-zA-Z0-9\_] |
|  \W |  对 \w 取非 |

### 3. 空白字符元字符

| 元字符  | 说明  |
| :---: | :---: |
|  \s | 任何一个空白字符，等价于 [\f\n\r\t\v]  |
| \S  |  对 \s 取非  |

\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。

# 五、重复匹配

-  **\+**  匹配 1 个或者多个字符
-  **\** * 匹配 0 个或者多个
-  **?**  匹配 0 个或者 1 个

**应用** 

匹配邮箱地址。

**正则表达式** 

```
[\w.]+@\w+\.\w+
```

[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；

**匹配结果** 

**abc.def<span>@</span>qq.com** 

-  **{n}**  匹配 n 个字符
-  **{m, n}**  匹配 m\~n 个字符
-  **{m,}**  至少匹配 m 个字符

\* 和 + 都是贪婪型元字符，会匹配最多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 \*?、+? 和 {m, n}? 。

**正则表达式** 

```
a.+c
```

由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。

**匹配结果** 

**abcabcabc** 

# 六、位置匹配

## 单词边界

**\b**  可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；**\B** 匹配一个不是单词边界的位置。

\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。

## 字符串边界

**^**  匹配整个字符串的开头，**$** 匹配结尾。

^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。

分行匹配模式（multiline）下，换行被当做字符串的边界。

**应用** 

匹配代码中以 // 开始的注释行

**正则表达式** 

```
^\s*\/\/.*$
```

<div align="center"> <img src="../pics//600e9c75-5033-4dad-ae2b-930957db638e.png"/> </div><br>

**匹配结果** 

1. public void fun() {
2. &nbsp;&nbsp;&nbsp;&nbsp;     **// 注释 1** 
3. &nbsp;&nbsp;&nbsp;&nbsp;    int a = 1;
4. &nbsp;&nbsp;&nbsp;&nbsp;    int b = 2;
5. &nbsp;&nbsp;&nbsp;&nbsp;     **// 注释 2** 
6. &nbsp;&nbsp;&nbsp;&nbsp;    int c = a + b;
7. }

# 七、使用子表达式

使用  **( )**  定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。

子表达式可以嵌套，但是嵌套层次过深会变得很难理解。

**正则表达式** 

```
(ab){2,}
```

**匹配结果** 

**ababab** 

**|**  是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。

**正则表达式** 

```
(19|20)\d{2}
```

**匹配结果** 

1.  **1900** 
2.  **2010** 
3. 1020

**应用** 

匹配 IP 地址。

IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：

- 一位数字
- 不以 0 开头的两位数字
- 1 开头的三位数
- 2 开头，第 2 位是 0-4 的三位数
- 25 开头，第 3 位是 0-5 的三位数

**正则表达式** 

```
((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```

**匹配结果** 

1.  **192.168.0.1** 
2. 00.00.00.00
3. 555.555.555.555

# 八、回溯引用

回溯引用使用  **\n**  来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。

**应用** 

匹配 HTML 中合法的标题元素。

**正则表达式** 

\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。

```
<(h[1-6])>\w*?<\/\1>
```

**匹配结果** 

1.  **&lt;h1>x&lt;/h1>** 
2.  **&lt;h2>x&lt;/h2>** 
3. &lt;h3>x&lt;/h1>

## 替换

需要用到两个正则表达式。

**应用** 

修改电话号码格式。

**文本** 

313-555-1234

**查找正则表达式** 

```
(\d{3})(-)(\d{3})(-)(\d{4})
```

**替换正则表达式** 

在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。

```
($1) $3-$5
```

**结果** 

(313) 555-1234

## 大小写转换

|  元字符 | 说明  |
| :---: | :---: |
|  \l | 把下个字符转换为小写  |
|   \u| 把下个字符转换为大写  |
|  \L | 把\L 和\E 之间的字符全部转换为小写  |
|  \U | 把\U 和\E 之间的字符全部转换为大写  |
|  \E | 结束\L 或者\U  |

**应用** 

把文本的第二个和第三个字符转换为大写。

**文本** 

abcd

**查找** 

```
(\w)(\w{2})(\w)
```

**替换** 

```
$1\U$2\E$3
```

**结果** 

aBCd

# 九、前后查找

前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用  **?=**  来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?<= 定义（注: javaScript 不支持向后匹配, java 对其支持也不完善）。

**应用** 

查找出邮件地址 @ 字符前面的部分。

**正则表达式** 

```
\w+(?=@)
```

**结果** 

**abc** @qq.com

对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。

# 十、嵌入条件

## 回溯引用条件

条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。

**正则表达式** 

子表达式 (\\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 \) 匹配，也就是匹配右括号。

```
(\()?abc(?(1)\))
```

**结果** 

1.  **(abc)** 
2.  **abc** 
3. (abc

## 前后查找条件

条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。

**正则表达式** 

 ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。

```
\d{5}(?(?=-)-\d{4})
```

**结果** 

1.  **11111** 
2. 22222-
3.  **33333-4444** 

# 参考资料

- BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.
