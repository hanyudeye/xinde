* shell 解释器会适当解释 一段文本
** 变量
   your_name="qinjx"
   for file in `ls /etc`
   只读 readonly myUrl
*** unset  删除变量或函数，只读变量不受影响 
*** 定义  
  declare -i a=3
-a : 数组
-f: function
-i: integer
-r:readonly
-x:通过环境输出变量

** 变量类型
*** 局部变量
    local var="localvar"
    同名会暂时覆盖函数外的变量
*** 环境变量
*** shell 变量
    export 导出的变量成为那个shell 环境下的变量，哪个程序都能访问
*** 字符串
    长度 echo ${#string}
    子字符串 ${string:1:4}
 #+BEGIN_SRC shell
   查找子字符串
   查找字符 "i 或 s" 的位置：
   string="wscxy is a great company"
   echo `expr index "$string" is`  # 输出 8

 #+END_SRC
*** 数组
    #+BEGIN_SRC bash
      array_name=(value0 value1 value2 value3)
      ${数组名[下标]}
      length=${#array_name[*]}
      for str in ${mingnong[*]}
      do
      done
    #+END_SRC
** 传递参数 $1 $2 $n
   $0 是文件名
   #+BEGIN_SRC shell
       $#	传递到脚本的参数个数
       $*	以一个单字符串显示所有向脚本传递的参数。
       如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
     $$	脚本运行的当前进程ID号
     $!	后台运行的最后一个进程的ID号
     $@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
     如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
       $-	显示Shell使用的当前选项，与set命令功能相同。
       $?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
   #+END_SRC
** 基本运算符, 不支持，但可以用其他命令实现 如 awk 和 expr$(())，expr 最常用
   [[file:image/expr][expr]] 
   
   val=`expr 2 + 2` 被下面的替代了, 不过很有用
   $((3+4))
   #+BEGIN_SRC shell
         [ $a -eq $b ] 
         [ $a -lt 20 -a $b -gt 100 ] 返回 false
         [[ $a -lt 100 || $b -gt 100 ]] 返回 true
         #注意 + 号之间空格
   #+END_SRC
   = != > < -eq -ne -lt -gt -le -ge -a (and) -o (or) -z (空字符)
   -n (非空)

** 字符串运算符
 #+BEGIN_SRC shell
 =	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
 !=	检测两个字符串是否相等，不相等返回 true。	[ $a != $b ] 返回 true。
 -z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
 -n	检测字符串长度是否为0，不为0返回 true。	[ -n $a ] 返回 true。
 str	检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。
 #+END_SRC
** 逻辑运算
   : 逻辑判断
# TITLE shell 的逻辑判断式
| 功能     | 逻辑标识 | 表示意思                    |
|----------+----------+-----------------------------|
| 文件目录 | -f       | 文件是否存在                |
|          | -d       | 目录                        |
|          | -b       | block                       |
|          | -c       | character文件               |
|          | -S       | socket                      |
|          | -L       | 符号链接                    |
|          | -e       | 某个东西                    |
|----------+----------+-----------------------------|
| 程序     | -G       | 是否由GID所执行的程序所拥有 |
|          | -O       | UID                         |
|          | -p       | name pipe or FIFO           |
|----------+----------+-----------------------------|
| 文件属性 | -r       | 可读                        |
|          | -w       | 写                          |
|          | -x       | 执行                        |
|          | -s       | 非空白                      |
|          | -u       | SUID属性                    |
|          | -g       | SGID                        |
|----------+----------+-----------------------------|
| 文件间   | -nt      | 第一个比第二个新            |
|          | -ot      | 旧                          |
|          | -ef      | 同一文件(link之类)          |
|----------+----------+-----------------------------|
| 逻辑     | &&       | AND的意思                   |
|          | 两竖     | OR                          |
|----------+----------+-----------------------------|
: 条件判断
#+BEGIN_SRC bash
if [[ one && two ]];then
elif [[ && ]];then
else
fi
#+END_SRC

** 流程控制
   break continue
 #+BEGIN_SRC shell
     if condition
     then
         command1 
         command2
         ...
         commandN
     else
         command
     fi

     for var in item1 item2 ... itemN
     do
         command1
         command2
         ...
         commandN
     done
     while condition
     do
         command
     done
   until condition
   do
       command
   done
   case 值 in
    模式1)
        command1
        command2
        ...
        commandN
        ;;
    模式2）
        command1
        command2
        ...
        commandN
        ;;
           esac
 #+END_SRC
** 函数
   #+BEGIN_SRC shell
       [ function ] funname [()]

       {

         action;

         [return int;]

     }
   调用
 函数名 参数1 参数2 ...
   #+END_SRC
** 重定向
   #+BEGIN_SRC shell
     command > file	将输出重定向到 file。
     command < file	将输入重定向到 file。
     command >> file	将输出以追加的方式重定向到 file。
      n > file	将文件描述符为 n 的文件重定向到 file。
      n >> file	将文件描述符为 n 的文件以追加的方式重定向到 file。
      n >& m	将输出文件 m 和 n 合并。
      n <& m	将输入文件 m 和 n 合并。
      << tag	将开始标记 tag 和结束标记 tag 之间的内容作为输入。
 
      $ kill -1 1234 >killouterr.txt 2>&1
   #+END_SRC
** 包含文件
 #+BEGIN_SRC shell
 . filename   # 注意点号(.)和文件名中间有一空格
 或
 source filename
 #+END_SRC
** 调试 sh [-nvx] scripts
   -n:查询语法,不执行
   -v:显示脚本内容,执行
   -x:将有使用到的脚本显示,跟-v略有不同

** 错误
   Exit Code                        Description
   126                              The file was not executable.
   127                              A command was not found.
   128 and above                    A signal occurred.
   0 是成功 ，1 是失败 
   echo $?
** 例子
   整数比较
-eq 等于,如:if [ "$a" -eq "$b" ]
-ne 不等于,如:if [ "$a" -ne "$b" ]
-gt 大于,如:if [ "$a" -gt "$b" ]
-ge 大于等于,如:if [ "$a" -ge "$b" ]
-lt 小于,如:if [ "$a" -lt "$b" ]
-le 小于等于,如:if [ "$a" -le "$b" ]
< 小于(需要双括号),如:(("$a" < "$b"))
<= 小于等于(需要双括号),如:(("$a" <= "$b"))
> 大于(需要双括号),如:(("$a" > "$b"))
>= 大于等于(需要双括号),如:(("$a" >= "$b"))

字符串比较
= 等于,如:if [ "$a" = "$b" ]
== 等于,如:if [ "$a" == "$b" ],与=等价
注意:==的功能在[[]]和[]中的行为是不同的,如下:

1 [[ $a == z* ]] # 如果$a以"z"开头(模式匹配)那么将为true
2 [[ $a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true
3
4 [ $a == z* ] # File globbing 和word splitting将会发生
5 [ "$a" == "z*" ] # 如果$a等于z*(字符匹配),那么结果为true

一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.
但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.

!= 不等于,如:if [ "$a" != "$b" ]
这个操作符将在[[]]结构中使用模式匹配.
< 小于,在ASCII字母顺序下.如:
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]
注意:在[]结构中"<"需要被转义.
> 大于,在ASCII字母顺序下.如:
if [[ "$a" > "$b" ]]
if [ "$a" \> "$b" ]
注意:在[]结构中">"需要被转义.
具体参考Example 26-11来查看这个操作符应用的例子.
-z 字符串为"null".就是长度为0.
-n 字符串不为"null"

注意:

使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z
或者就是未用""引用的字符串本身,放到[]结构中。虽然一般情况下可
以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.

awk '{print $2}' class.txt | grep '^[0-9.]' > res

SHELL下的数字比较及计算

比较：

方法一： if [ ${A} -lt ${B} ]; then ...
这是最基本的比较方法，使用lt(小于),gt(大于),le(小于等于),ge(大于等于)，优点：还没发现；缺点：只能比较整数，使用lt,gt等不直
观

方法二： if ((${A} < ${B})) then ...
这是CShell风格比较，优点：不用使用lt,gt等难记的字符串；缺点：还是只能比较整数

方法三： if (echo ${A} ${B} | awk '!($1>$2){exit 1}') then ...
这是使用awk比较，优点：可以比较小数；缺点：表达式太复杂，难记

方法四： if (echo ${A} - ${B} | bc -q | grep -q "^-"); then ...
这是使用bc计算比较，优点：可以比较小数；缺点：表达式更复杂，难记

计算：
方法一：typeset C=$(expr ${A} + ${B});
SHELL中的基本工具，优点：方便检测变量是否为数字；缺点：只能计算整数，且只能计算加减法，不能计算乘除法

方法二：let "C=${A}+${B}"; 或 let "C=A+B"
内嵌命令计算，优点：能计算乘除法及位运算等；缺点：只能计算整数

方法三：typeset C=$((A+B))
CShell风格的计算，优点：能计算乘除法及位运算等，简介，编写方便；缺点：不能计算小数

方法四：typeset C=${echo ${A} ${B} | awk '{print $1+$2}')
使用awk计算，优点：能计算小数，可以实现多种计算方式，计算灵活；缺点：表达式太复杂

方法五：typeset C=${echo ${A} + ${B} | bc -q)
使用awk计算，优点：能计算小数，计算方式比awk还多，计算灵活；缺点：表达式太复杂，小数点后面的位数必须使用scale=N来设置，否
则可能会将结果截断为整数

特殊字符

符号使用
；一般情况我们输出完一个命令需要按一个回车，如果你想在一行执行多个命令，中间可以用；号分割 cd /home ; ls
\* 表示任意字符（正则）
? 任一个字符
[abc] 列表项之一
[^abc] 对于列表取非也可以使用范围 [a-z] [0-9] [A-Z](所有字符和数字)
{} 循环列表时用 touch_{1,2,3}时就会建立touch_1,touch_2,touch_3循环出这三个文件，也会用 echo ${ab}c
~ home目录cd ~ （普通通话进入的是/home目录下用户自己的家目录）
$ 提取变量值
`` $() 命令替换touch `date +%F_\`date +%T\`` touch $(date +%F_$(date +%T))
$[] 整数计算 echo $[2+3] - * / % 浮点数用 echo "scale=3; 10/3" | bc -l (bc用于计算的)
\ 转义后面的字符串 echo \\ 输出\ 转义特殊字符，为防止被SHELL解释bash中的特殊字符
"" '' 带空格串将空格视为串的一部分 echo "abc xyz" echo 'abc xyz'
`` 命令替换取命令的执行结果
$() 同上，但它弥补了``的嵌套缺陷
@ 无特殊含义
# 注释（一般编程都需要加注释，让其他团队队员对自己写的程序功能了解）
$ 变量取值
$() 命令替换
${} 变量名的范围
% 杀后台经常jobs号，取模运算(大家对取模应该并不陌生)
^ 取非和！雷同
& 用进程后台处理， &&用于逻辑与
\* 匹配任意字符串；计算乘法
() 子进程执行
- 减号，区间，cd - 回到上层目录，杀掉当前jobs

_ （下划线）无特殊含义
+ 加号；杀掉当前jobs（进程）
= 赋值
| 管道，|| 逻辑或
\ 转义当一些特殊符号如$是一个变量需要转义才不被bash解析
{} 命令列表 {ls;cd /;}
[] 字符通配符，[]也是用于测试命令
：空命令真值
；命令结束符
"" 软引 '' 硬引
< 输入重定向
> 输出重定向
>& 合并2和1输出
, 枚举分隔符
. 当前目录
/ 目录分隔符
? 单个字符
回车命令执行

这篇文章主要介绍了Linux Shell中的特殊符号和含义简明总结,本文汇总了包含了绝大部份的Shell特殊符号,对每一个符号的作用做了总
结,需要的朋友可以参考下

在Linux Shell中有很多的特殊符号，这对于我们写Shell脚本时要特别留意：一方面要知道这些特殊符号的用法，这些符号用好了可以达到
事半功倍的效果；但另一方面要避免这些特殊符号的过度使用而导致脚本难以调试、难以阅读。

这些特殊符号罗列出来大致如下：
复制代码代码如下:
# ; ;; . , / / ‘string'| ! $ ${} $? $$ $* “string”* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || && {xx,yy,zz,…}~ ~+ ~- &
/ + – %= == !=

输出/输入重导向：
复制代码代码如下:
> >> < << : > &> 2&> 2<>>& >&2

下面就逐一介绍这些特殊符号的含义和用法……

# 井号 (comments)
这几乎是个满场都有的符号。
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo “a = $a” # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo “a = $a” # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。

~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user
或者当成是路径的一部份：~/bin；~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd 的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs

; 分号 (Command separator)
在 shell 中，担任”连续指令”功能的符号就是”分号”。譬如以下的例子：cd ~/backup ; mkdir startup ; cp ~/.* startup/.

;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case “$fop” inhelp) echo “Usage: Command -help -version filename” ;;version) echo “version 0.1″ ;;esac

. 逗号 (dot)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regular expression 中，一个
dot 代表匹配一个字元。

‘string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量
替换。
heyyou=homeecho ‘$heyyou' # We get $heyyou

“string” 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho “$heyyou” # We get home
`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo “Today $fdv”
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。

, 逗点 (comma)
这个符号常运用在运算当中当做”区隔”用途。如下例
#!/bin/bashlet “t1 = ((a = 5 + 3, b = 7 – 1, c = 15 / 3))”echo “t1 = $t1, a = $a, b = $b”

/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let “num1 = ((a = 10 / 2, b = 25 / 5))”

\ 倒斜线 (escape)
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases 的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令
的最末端，表示指令连接下一行。
# type rm
rm is aliased to `rm -i'
# \rm .\*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home
# echo “Backup dir, \$bkdir = $bkdir”
Backup dir, $bkdir = /home
上例 echo 内的 \$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir 则会输出变数的内容 /home。

| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。

! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于”
if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
在规则表达式中她担任 “反逻辑” 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 …. a9 这几个文件的其他文件。

: 冒号
在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null > f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if 这类的做
法，基本上也可以处理，但都比不上上例的简洁与效率。
除了上述之外，还有一个地方必须使用冒号
PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla
在使用者自己的HOME 目录下的 .bash_profile 或任何功能相似的档案中，设定关于”路径”的场合中，我们都使用冒号，来做区隔。

? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。

\* 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 “乘法”。
let “fmult=2*3″
除了内建指令 let，还有一个关于运算的指令 expr，星号在这里也担任”乘法”的角色。不过在使用上得小心，他的前面必须加上escape 字
元。

\** 次方运算
两个星号在运算时代表 “次方” 的意思。
let “sus=2**3″echo “sus = $sus” # sus = 8

$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo “vrs = $vrs” # vrs = 123
另外，在 Regular Expressions 里被定义为 “行” 的最末端 (end-of-line)。这个常用在 grep、sed、awk 以及 vim(vi) 当中。

${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length}
${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/
string} ${parameter//pattern/string}

$*引用script 的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}…..
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo “$*”
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。

$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。
$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo “$#”

$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行
状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho “$?”$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script 会需要产生临时文件，用来存放必要的资料。而此
script 亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。
符号$$ 或许可以符合这种需求。它代表当前shell 的 PID。
echo “$HOSTNAME, $USER, $MAIL” > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果 script 执
行完毕后仍不加以清除，会产生其他问题。
() 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ; echo $vcgh)，指令群组
有一个特性，shell会以产生 subshell 来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e “/n $a /n”)echo $a# ./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape 字元才能使用的场合，如运算式。

(())
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let 指令要好许多。
#!/bin/bash(( a = 10 ))echo -e “inital value, a = $a/n”(( a++ ))echo “after a++, a = $a”

{} 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以”分号”做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e “/n $a /n”}echo $a# ./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 “函数” 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script 也
是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。
此外，大括号还有另一种用法，如下
{xx,yy,zz,…}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin, userB-data, userC-home, userC-bin, userC-data，这几个目
录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！

[] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。

[[]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与 && 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak < 9 ]]thenecho $akfi || 逻辑符号这个会时常看到，代表 or 逻辑的符号。 && 逻辑符号这
个也会常看到，代表 and 逻辑的符号。 & 后台工作单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 tar
cvfz data.tar.gz data > /dev/null &
/ 单字边界
这组符号在规则表达式中，被定义为”边界”的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there 的一部份。如果我们要必免这种情况，就得加上
“边界” 的符号
grep ‘/' FileA

+ 加号 (plus)
在运算式中，她用来表示 “加法”。
expr 1 + 2 + 3
此外在规则表达式中，用来表示”很多个”的前面字元的意思。
# grep '10/+9′ fileB109100910000910000931010009#这个符号在使用时，前面必须加上 escape 字元。

- 减号 (dash)
在运算式中，她用来表示 “减法”。
expr 10 – 2
此外也是系统指令的选项符号。
ls -expr 10 – 2
在 GNU 指令中，如果单独使用 – 符号，不加任何该加的文件名称时，代表”标准输入”的意思。这是 GNU 指令的共通选项。譬如下例
tar xpvf -
这里的 – 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到”上一次”工作目录。

% 除法 (Modulo)
在运算式中，用来表示 “除法”。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。
** eval  对参数求值
   eval [arguments]
   The arguments are concatenated together into a single command,
   which is then read and executed, and its exit status returned as the exit 
status of eval. If there are no arguments or only empty arguments, 
the return status is zero.
** exec [-cl] [-a name] [command [arguments]]
  1. 执行新进程, 现在这个是父进程
  2.修改当前文件描述符 exec 3 < afile, 很少用 
** set 设定参数变量
   #+BEGIN_SRC shell
     #!/bin/bashh
     echo the date is $(date)
     set $(date)
     echo The month is $2
     exit 0

   #+END_SRC
    set命令用于设置shell。
    set指令能设置所使用shell的执行方式，可依照不同的需求来做设置。

语法
set [+-abCdefhHklmnpPtuvx]
参数说明：

-a 　标示已修改的变量，以供输出至环境变量。
-b 　使被中止的后台程序立刻回报执行状态。
-C 　转向所产生的文件无法覆盖已存在的文件。
-d 　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。
-e 　若指令传回值不等于0，则立即退出shell。
-f　 　取消使用通配符。
-h 　自动记录函数的所在位置。
-H Shell 　可利用"!"加<指令编号>的方式来执行history中记录的指令。
-k 　指令所给的参数都会被视为此指令的环境变量。
-l 　记录for循环的变量名称。
-m 　使用监视模式。
-n 　只读取指令，而不实际执行。
-p 　启动优先顺序模式。
-P 　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。
-t 　执行完随后的指令，即退出shell。
-u 　当执行时使用到未定义过的变量，则显示错误信息。
-v 　显示shell所读取的输入值。
-x 　执行指令后，会先显示该指令及所下的参数。
+<参数> 　取消某个set曾启动的参数。
** shift 把参数左移一位
** trap 一般是收到信号，进行收尾工作
  [[file:image/trap.png][trap]] 
  第一次 会执行中断，第二次中断清除，会直接退出
   trap -l 查看信号
   trap command signal
   trap - INT 清除中断
** return 函数返回，相当于返回到父进程去(类比)
** 命令执行 $(command) 不要用 `command`
** 库
*** i/o
   read
** 功能调用 
  要想 一段字符当命令运行， 用 $() 或 `` 
* shell mode 
** shell 集成工具
*** 定义shell 
    #+BEGIN_SRC lisp 
      '((shell :variables shell-default-shell 'eshell)))
    #+END_SRC
    可选
 - =eshell=
 - =shell=
 - =term=
 - =ansi-term=
 - =multi-term=

 通过 spc ' 可快速访问
*** 配置 shell
 #+BEGIN_SRC lisp
    (setq-default dotspacemacs-configuration-layers
                  '((shell :variables
                           shell-default-position 'bottom
                           shell-default-height 30)))

   执行程序   '((shell :variables shell-default-term-shell "/bin/bash"))
   宽度'((shell :variables shell-default-full-span nil))
   在 类似命令的字串前面 按 i, 会当命令执行
 #+END_SRC
*** Key bindings
  | Key Binding | Description                                                    |
  |-------------+----------------------------------------------------------------|
  | ~SPC '​~     | Open, close or go to the default shell                         |
  | ~SPC p '​~   | Open a shell in the project's root                             |
  | ~SPC a s e~ | Open, close or go to an =eshell=                               |
  | ~SPC a s i~ | Open, close or go to a =shell=                                 |
  | ~SPC a s m~ | Open, close or go to a =multi-term=    , 打开多进程shell       |
  | ~SPC a s t~ | Open, close or go to a =ansi-term=                             |
  | ~SPC a s T~ | Open, close or go to a =term=                                  |
  | ~SPC m H~   | 历史browse history with =helm= (works in =eshell= and =shell=) |
  | ~C-j~       | next item in history                                           |
  | ~C-k~       | previous item in history                                       |

  *Note:* You can open multiple shells using a numerical prefix argument,
  for instance pressing ~2 SPC '​~ will a second default shell, the
  number of shell is indicated on the mode-line.

  *Note:* Use the universal prefix argument ~SPC u SPC '​~ to open the shell
  in the current buffer instead of a popup.

**** Multi-term

  | Key Binding | Description                  |
  |-------------+------------------------------|
  | ~SPC m c~   | create a new multi-term      |
  | ~SPC m n~   | go to next multi-term        |
  | ~SPC m p~   | go to previous multi-term    |
  | ~SPC p $ t~ | run multi-term shell in root |

**** DONE Eshell
     CLOSED: [2018-01-19 五 20:23]

  | Key Binding        | Description                                |
  |--------------------+--------------------------------------------|
  | ~SPC m H~ or ~M-l~ | shell commands history using a helm buffer |
** shell-script
   支持 .sh 和 .fish 脚本
 fish  the friendly interactive shell
*** 安装
    fish
    #+BEGIN_SRC shell
      sudo apt-add-repository ppa:fish-shell/release-2
      sudo apt-get update
      sudo apt-get install fish
    #+END_SRC
    - Auto-completion using [[https://github.com/Alexander-Miller/company-shell][company-shell]]
    In order to enable =sh= scripts linting, install [[https://www.shellcheck.net/][shellcheck]].
    In order to enable =sh= scripts style checking, install [[https://github.com/openstack-dev/bashate][bashate]].
*** 完成后端
    company-shell offers 3 backends for 3 different sources:
    company-shell - providing completions for binaries that are found on your $PATH
    company-fish-shell - providing completions for fish-shell’s functions, both builtin as well as user-defined
    company-shell-env - providing completions for environment variables based on the env command
Company: backend (company-shell company-shell-env company-fish-shell) error "Wrong type argument: stringp, nil" with args (candidates ech)
To find the documentation for a completion candidate c company-shell and company-fish-shell will both first try the output of man c.
 If c does not have a manpage they will then use c --help as a fallback. 
The latter needs to be enabled manually (see the desciption about company-shell-use-help-arg below).
 The meta doc-string (shown in the minibuffer during completion) is provided by (the first line of) whatis c.

There are no doc- or meta-strings for company-shell-env.