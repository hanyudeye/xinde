* spacemacs
** 界面功能
*** 换行 SPC-t-l 开关 truncate line
*** 书签 看小说用的 ~SPC fb~
    | 删除选中的书签                   |
    | 编辑所选书签                     |
    | 切换文件名位置                   |
    | 在另一个窗口    中打开选定的书签 |
*** 文本的缓冲区显示 可以集中显示选中的文本
    | 〜SPC nf〜 | 将缓冲区缩小到当前函数   |
    | 〜SPC np〜 | 将缓冲区缩小到可见页面   |
    | 〜SPC nr〜 | 将缓冲区缩小到选定的文本 |
    | 〜SPC nw〜 | 加宽，即显示整个缓冲区   |
*** frame字体缩放
    | 〜SPC zf +〜   | 放大帧内容并启动帧缩放瞬态     |
    | 〜SPC zf =〜   | 放大帧内容并启动帧缩放瞬态     |
    | 〜SPC zf  - 〜 | 缩小帧内容并启动帧缩放瞬态     |
    | 〜SPC zf 0〜   | 重置帧内容大小并启动​​帧缩放瞬态 |
    | 〜+〜          | 放大                           |
    | 〜=〜          | 放大                           |
    | 〜 - 〜        | 缩小                           |
    | 〜0〜          | 重置缩放                       |
    | 任何其他键     | 保留缩放框架的过渡状态         |

*** 文本缩放
    | 键绑定         | 说明                                     |
    | 〜SPC zx +〜   | 放大字体并启动字体缩放瞬态               |
    | 〜SPC zx =〜   | 放大字体并启动字体缩放瞬态               |
    | 〜SPC zx  - 〜 | 缩小字体并启动字体缩放瞬态               |
    | 〜SPC zx 0〜   | 重置字体大小（不缩放）并启动字体缩放瞬态 |
    | 〜+〜          | 增加字体大小                             |
    | 〜=〜          | 增加字体大小                             |
    | 〜 - 〜        | 减小字体大小                             |
    | 〜0〜          | 重置字体大小                             |
    | 任何其他键     | 保持字体缩放瞬态                         |
    请注意，/只/当前缓冲区的文本被缩放，其他缓冲区，
*** 移动
**** 在屏幕中移动光标：
     vi & vim 命令行模式操作移动光标位置都是指移动到要编辑单词、字母的前面。

     按键                                        操作描述
     h                                            光标左移一个字符；
     j                                             光标下移一行；
     k                                            光标上移一行；
     l                                             光标右移一个字符；

     数值  +  G                                光标移至“数值”所指行的行首；
     ^H                                          光标移至当前屏幕显示首行的行首；
     ^M                                          光标移至当前屏幕显示的中间行的行首；
     ^L                                           光标移至当前屏幕显示的最后一行的行首；

**** 在文件行内移动光标：
     vi & vim 命令行模式操作光标行内移动，单词间以空格作为分隔字符，标点符号看作一个单词。

     按键                                        操作描述
     0    （数字零）                        光标移动到光标所在行的行首；
     $                                           光标移动到光标所在行的行末；
     w                                          光标移动到下一个单词的首字母前；
     b                                           光标移动到上一个单词的首字母前；
     e                                           光标移动到当前光标所在单词的最后字符前；
**** 屏幕滚动：
     ^F                                            屏幕向下滚动一屏；
     ^B                                            屏幕向上滚动一屏；
     ^E                                            屏幕向下滚动一行；
     ^Y                                            屏幕向上滚动一行；
     ^D                                            屏幕向下滚动半屏；
     ^U                                            屏幕向上滚动半屏；
     z + Enter                                     滚动屏幕，使当前光标所在行处于屏幕第一行；
     z + .                                         滚动屏幕，使当前光标所在行处于屏幕中间行；
     z + -                                         滚动屏幕，使当前光标所在行处于屏幕最后一行；
*** 高亮当前行
    (global-hl-line-mode 1)
** 编程功能
*** flycheck
    | Key Binding | Description                                                           |
    |-------------+-----------------------------------------------------------------------|
    | ~SPC t s~   | toggle flycheck                                                       |
    | ~SPC e c~   | clear all errors                                                      |
    | ~SPC e h~   | describe a flycheck checker                                           |
    | ~SPC e l~   | toggle the display of the =flycheck= list of errors/warnings          |
    | ~SPC e n~   | go to the next error                                                  |
    | ~SPC e p~   | go to the previous error                                              |
    | ~SPC e v~   | verify flycheck setup (useful to debug 3rd party tools configuration) |
    | ~SPC e .~   | error transient state                                                 |

*** 注释 
    | Key Binding | Description               |
    |-------------+---------------------------|
    | ~SPC ;~     | comment operator          |
    | ~SPC c h~   | hide/show comments        |
    | ~SPC c l~   | comment lines             |
    | ~SPC c L~   | invert comment lines      |
    | ~SPC c p~   | comment paragraphs        |
    | ~SPC c P~   | invert comment paragraphs |
    | ~SPC c t~   | comment to line           |
    | ~SPC c T~   | invert comment to line    |
    | ~SPC c y~   | comment and yank          |
    | ~SPC c Y~   | invert comment and yank   |

*** layout, windows, workspace 和 project 相关
**** Layout 操作
     1. SPC l L 加载 layout 文件
     2. SPC l l 在 layout 之间切换
     3. SPC l s 将 layout 保存到文件
     4. SPC l <tab> 在当前 layout 和上一个 layout 之间切换
     5. SPC l o 配置 layout
     6. SPC l R 重命名 layout
     7. SPC l ? 显示更多的与 layout 相关的命令
**** Window 相关操作
  1. SPC w - 上下拆分窗口
  2. SPC w / 左右拆分窗口
  3. SPC w . 显示更多的与 window micro state 的相关的命令
  4. SPC w 2/3 左右显示 2/3 个窗口
  5. SPC w = 将窗口均等分
  6. SPC w b 切换到 minibuffer
  7. SPC w d 删除当前窗口
  8. SPC w h/j/k/l 向 左/下/上/右 移动窗口
  9. SPC w m 最大化显示当前窗口
  10. SPC W H/J/K/L 将当前窗口向 左/下/上/右 移动
  11. SPC w u/U 取消/重置上次操作
  12. SPC w o 切换到其他 frame
  13. SPC w F 创建一个新的 frame
  14. SPC w 1/2/3/4 切换到对应的编号的窗口
  15. SPC w w 依次切换到其他窗口
  16. SPC w W 使用字母标识需要跳转的窗口, 并按下字母进行跳转
  17. SPC t g 将当前显示的窗口与其他窗口进行黄金分割显示
  18. SPC t - 开启/关闭 将光标始终显示在中心行
**** workspace
     | ~SPC l w~         | activate the transient state                                |
**** project 相关操作
  1. SPC p f 在当前 project 中查找并打开文件
  2. SPC p b 在当前 project 中查找打开的 buffer
  3. SPC p p 切换到其他的 project
  4. SPC p l 切换到其他的 project 并创建一个新的 layout
  5. find-file-in-project 这是一个插件, 支持全平台. 目前绑定在 SUPER f 快捷键上.
***** 工程
      1.目录下创建空的 .projectile
    2. 在文件/home/wuming/.emacs.d/.cache/projectile-bookmarks.eld 中添加目录
    3. 也可以在变量 project ... file 中添加 后缀文件类型
*** 使用 ctags 和 company-etags
**** 为什么使用 ctags
     ctags 是一个开源的, 可以方便的对大型代码库进行索引的软件, 在使用 ctags 生成 tag 之后就可以非常方便的在这些 tag 中进行跳转.
     因为有些编程语言, 例如 javascript 或者 lua, 它们不能进行精确的语义补全, 在有 ctags 进行索引补全的情况下也可以方便编写代码.

  之前作者使用 YCMD 来对 C/C++ 代码进行补全, 但是它不太稳定, 现在已经切换为 ctags 来进行补全, 对于调试和 profile 会使用 IDE 进行操作.
**** 如何配置 ctags
     首先新建一个 testJs-ctags 目录, 然后在该目录下新建 a.js 以及 b.js 两个文件:

  #+BEGIN_SRC shell
    mkdir testJs-ctags
    cd testJs-ctags
    touch a.js
    touch b.js
  #+END_SRC

  然后编辑 a.js 的内容如下:

  #+BEGIN_SRC javascript
    var func1 = function () {
        console.log("func1");
    };

    var func2 = function () {
    };
  #+END_SRC

  然后在 b.js 中的补全中可以显示处 func1 和 func2 的补全提示的. 为了更方便的讲解之后的内容, 我们可以查看使用的补全的后端:
  输入 M-x, diminish-undo, 选择 company-mode, 这样在 modeline 就可以看到 company-mode 的具体信息.

  再次输入 fun 等待弹出补全提示, 在补全选项中上下移动, 可以看到使用的补全后端包括 dabbrev-code 和 etags 等,
   如果我们关闭 a.js 的 buffer, 就不会出现 func1 和 func2 的补全选项.

  在之前的操作中, 我们并没有生成 ctags, 为什么也能使用 ctags 补全呢? 我们可以使用 SPC h d v,
  然后输出 tags-table-list 来查看该变量的值, 当前的值是指向作者 cocos 目录下的 TAGS 文件.
  使用以下代码清空该值:

  #+BEGIN_SRC emacs-lisp
    (setq-default tags-table-list nil)
  #+END_SRC

  然后再次尝试补全, 这时就不会使用 ctags 补全了.

  那么如何生成 ctags 补全的文件呢? 使用以下命令即可:

  #+BEGIN_SRC shell
    cd testJs-ctags
    ctags -e a.js
    # 针对目录
    # ctags -eR foldername
  #+END_SRC

  company-etags 在进行补全的时候, 会从变量 tags-table-list 值的文件列表中去查找 tags, 而且 tags 是不区分语言的.

  如果需要手动加载 TAGS 文件, 那么可以调用 visit-tags-table 命令. 而在打开一个文件时, ctags 会从文件所在的目录进行查找, 一直到根目录,
   加载所找到的 TAGS 文件.

**** 如何高效的使用 ctags
***** 自动重新生成 TAGS 文件
  在使用 ctags 的过程中, 如果文件的内容被改变, 那么需要重新生成 TAGS 文件, 以便 ctags 的补全结果更精确.
   作者实现了一个函数来自动加载必须的 TAGS 文件:

  #+BEGIN_SRC emacs-lisp
    (defun my-setup-develop-environment ()
      (interactive)
      (when (my-project-name-contains-substring "guanghui")
        (cond
         ((my-project-name-contains-substring "cocos2d-x")
          ;; C++ project don't need html tags
          (setq tags-table-list (list (my-create-tags-if-needed "~/cocos2d-x/cocos"))))
         ((my-project-name-contains-substring "Github/fireball")
          (message "load tags for fireball engine repo...")
          ;; html project donot need C++ tags
          (setq tags-table-list (list (my-create-tags-if-needed "~/Github/fireball/engine/cocos2d")))))))
  #+END_SRC

  有另外一个工具函数, 当保存文件时会自动的重新生成 TAGS:

  #+BEGIN_SRC emacs-lisp
    (defun my-auto-update-tags-when-save (prefix)
      (interactive "P")
      (cond
       ((not my-tags-updated-time)
        (setq my-tags-updated-time (current-time)))

       ((and (not prefix)
             (< (- (float-time (current-time)) (float-time my-tags-updated-time)) 300))
        ;; < 300 seconds
        (message "no need to update the tags")
        )
       (t
        (setq my-tags-updated-time (current-time))
        (my-update-tags)
        (message "updated tags after %d seconds." (- (float-time (current-time)) (float-time my-tags-updated-time))))))
  #+END_SRC

  可以将 my-auto-udpate-tags-when-save 函数加入 after-save-hook 中, 或者绑定到快捷键上.

***** 配置规则来生成更多的 TAGS
      ctags 自身也有一个配置文件, 可以在该文件中定义规则来更好的生成 TAGS, 一个配置文件的示例如下:

  #+BEGIN_EXAMPLE
  --exclude=*.svn*
  --exclude=*.git*
  --exclude=*tmp*
  --exclude=.#*
  --tag-relative=yes
  --recurse=yes

  --langdef=js

  --regex-js=/[ \t.]([A-Z][A-Z0-9._$]+)[ \t]*[=:][ \t]*([0-9"'\[\{]|null)/\1/n,constant/

  --langdef=css
  --langmap=css:.css
  --regex-css=/^[ \t]*\.([A-Za-z0-9_-]+)/.\1/c,class,classes/
  #+END_EXAMPLE

  在配置文件中可以使用 --exclude 来忽略文件或路径, 使用 --langdef 来定义哪些文件属于 js 文件, 使用 --regex-js 来定义 TAGS 生成时的匹配规则.
  这些匹配规则中可以使用正则表达式来提取内容生成 TAGS.

***** 使用 etags-select 来浏览项目
      在有 TAGS 之后, 可以使用 ctags 来方便的浏览文件内容.
      例如在某个函数名上点击 [, g], 然后选择 etags-select-find-tag-at-point, 这时会把所有相关的内容列出到 buffer 中, 然后可以选择想要跳转的位置跳转过去.

**** 最后的思考
  company-etags 不能对所有的 mode 进行补全, 例如在 org-mode 中默认是不使用 company-etags 的.
  因为在 company-etags.el 文件中有如下的代码:

  #+BEGIN_SRC emacs-lisp
    (defvar company-etags-modes '(prog-mode c-mode objc-mode c++-mode java-mode
                                            jde-mode pascal-mode perl-mode python-mode))
  #+END_SRC

  在该变量中定义了可以使用 company-etags 的 mode, 将 org-mode 加入该变量的值中即可在 org-mode 使用 company-etags 进行补全.
  ctags 支持上百种语言, 学会使用 ctags 能够提交效率.
*** Error
 下一个错误 SPC e n
*** 数字增加/减少？
   对于数字或小数
 | 〜SPC n +〜   | 增加指示点下的数量并启动暂态 |
 | 〜SPC n  - 〜 | 减少指示点下的数量并启动暂态 |
 参数（即〜10 SPC n +〜将点数加 10）
*** gtags
   除了第一次,生成外，以后都是自动生成的
  =helm-gtags= and =ggtags= are clients for GNU Global. GNU Global is a source
  code tagging system that allows querying symbol locations in source code, such
  as definitions or references. Adding the =gtags= layer enables both of these
  modes.

**** Features:
  - Select any tag in a project retrieved by gtags
  - Resume previous helm-gtags session
  - Jump to a location based on context
  - Find definitions
  - Find references
  - Present tags in current function only
  - Create a tag database
  - Jump to definitions in file
  - Show stack of visited locations
  - Manually update tag database
  - Jump to next location in context stack
  - Jump to previous location in context stack
  - Jump to a file in tag database
  - Enables =eldoc= in modes that otherwise might not support it.
  - Enables =company complete= in modes that otherwise might not support it.

**** Install 安装
***** GNU Global (gtags)
   To use gtags, you first have to install [[https://www.gnu.org/software/global/download.html][GNU Global]].

   You can install =global= from the software repository of your OS; however, many
   OS distributions are out of date, and you will probably be missing support for
   =pygments= and =exuberant ctags=, and thus support for many languages. We
   recommend installing from source. If not for example to install on Ubuntu:

   #+begin_src sh
     sudo apt-get install global
   #+end_src

****** Install on OSX using Homebrew
   #+begin_src sh options
     brew install global --with-pygments --with-ctags
   #+end_src

****** Install on *nix from source
******* Install recommended dependencies
   To take full advantage of global you should install 2 extra packages in
   addition to global: pygments and ctags (exuberant). You can do this using
   your normal OS package manager, e.g., on Ubuntu

   #+BEGIN_SRC sh
     sudo apt-get install exuberant-ctags python-pygments
   #+END_SRC


******* Install with recommended features
   Download the latest tar.gz archive, then run these commands:

   #+BEGIN_SRC sh
     tar xvf global-6.5.3.tar.gz
     cd global-6.5.3
     ./configure --with-exuberant-ctags=/usr/bin/ctags
     make
     sudo make install
   #+END_SRC

******* Configure your environment to use pygments and ctags
   To be able to use =pygments= and =ctags=, you need to copy the sample
   =gtags.conf= either to =/etc/gtags.conf= or =$HOME/.globalrc=. For example:

   #+begin_src sh
     cp gtags.conf ~/.globalrc
   #+end_src

   Additionally you should define GTAGSLABEL in your shell startup file e.g.
   with sh/ksh:

   #+begin_src sh
     echo export GTAGSLABEL=pygments >> .profile
   #+end_src

****** Conflict between =ctags= and emacs's =etags= binary
   If you installed =emacs= from source after =ctags=, your original =ctags= binary
   is probably replaced by emacs's =etags=. To get around this you will need to
   configure =emacs= as following before installing:

   #+begin_src sh
     ./configure --program-transform-name='s/^ctags$/ctags.emacs/'
   #+end_src

   To check if you have the correct version of =ctags= execute:

   #+begin_src sh
     ctags --version | grep Exuberant
   #+end_src

   If yo do not get any output then it means you have the wrong =ctags= and must
   install it again.

***** Emacs Configuration
   To use this configuration layer, add it to your =~/.spacemacs=. You
   will need to add =gtags= to the existing =dotspacemacs-configuration-layers=.

   #+begin_src emacs-lisp
     (setq dotspacemacs-configuration-layers
           '( ;; ...
             gtags
              ;; ...
             ))
   #+end_src

****** Disabling by default
   If =ggtags-mode= is too intrusive you can disable it by default, by setting the
   layer variable =gtags-enable-by-default= to =nil=.

   #+BEGIN_SRC emacs-lisp
     (setq-default dotspacemacs-configuration-layers
       '((gtags :variables gtags-enable-by-default t)))
   #+END_SRC

   This variable can also be set as a file-local or directory-local variable for
   additional control per project.

**** 使用
   - 首先创建 gtags 数据库文件
     运行 =helm-gtags-create-tags= ~SPC m g c~.
     If the language is not directly supported by GNU Global, you
     can choose =ctags= or =pygments= as a backend to generate tag database.
     如果 =global= 不支持 此语言，那么可以换工具, 或者在终端执行

   - From inside terminal, runs gtags at your project root in terminal:
   #+BEGIN_SRC sh
     cd /path/to/project/root
     gtags
   #+END_SRC

     If the language is not directly supported by =gtags=, and you have not set the
     GTAGSLABEL environment variable, use this command instead:

   #+BEGIN_SRC sh
     gtags --gtagslabel=pygments
   #+END_SRC

****** Language Support
******* Built-in languages
   If you do not have =ctags= or =pygments= enabled gtags will only produce
   tags for the following languages:

   - asm
   - c/c++
   - java
   - php
   - yacc

******* Exuberant ctags languages
   If you have enabled =exuberant ctags= and use that as the backend (i.e.,
   =GTAGSLABEL=ctags= or =--gtagslabel=ctags=) the following additional languages
   will have tags created for them:

   - c#
   - erlang
   - javascript
   - common-lisp
   - emacs-lisp
   - lua
   - ocaml
   - python
   - ruby
   - scheme
   - vimscript
   - windows-scripts (.bat .cmd files)

******* Universal ctags languages
   If instead you installed you the newer/beta =universal ctags= and use that
   as the backend (i.e., GTAGSLABEL=ctags or --gtagslabel=ctags) the following
   additional languages will have tags created for them:

   - clojure
   - d
   - go
   - rust

******* Pygments languages (plus symbol and reference tags)
   In order to look up symbol references for any language not in the built in
   parser you must use the pygments backend. When this backend is used global
   actually uses both ctags and pygments to find the definitions and uses of
   functions and variables as well as "other symbols".

   If you enabled pygments (the best choice) and use that as the backend (i.e.,
   =GTAGSLABEL=pygments= or =--gtagslabel=pygments=) the following additional
   languages will have tags created for them:

   - elixir
   - fsharp
   - haskell
   - octave
   - racket
   - scala
   - shell-scripts
   - tex

***** Eldoc integration
   This layer also integrates =ggtags= for its Eldoc feature. That means, when
   writing code, you can look at the minibuffer (at the bottom) and see variable
   and function definition of the symbol the cursor is on. However, this feature is
   only activated for programming modes that are not one of these languages:

   - C
   - C++
   - Common Lisp
   - Emacs Lisp
   - Python
   - Ruby

   Since these modes have better Eldoc integration already.

   In addition, if output from =compile= (bound to ~SPC c C~), =shell-command=
   (bound to ~SPC !~ and ~M-!~) or =async-shell-command= (bound to ~M-&~) commands
   contains symbol in your project, you move cursor on such symbol and use any of
   the gtags commands.
**** Key bindings
   | Key Binding | Description                                                                  |
   |-------------+------------------------------------------------------------------------------|
   | ~SPC m g C~ | create a tag database 第一步，创建标记文件                                   |
   | ~SPC m g f~ | jump to a file in tag database    跳到包含那个 tag 的文件                     |
   | ~SPC m g g~ | jump to a location based on context       这个更精确，调到函数定义           |
   | ~SPC m g G~ | jump to a location based on context (open another window) 另个窗口           |
   | ~SPC m g d~ | find definitions                      跟上面没区别                           |
   | ~SPC m g i~ | present tags in current function only 这个给你选一下 tag 链表,表示可能它会认错 |
   | ~SPC m g l~ | jump to definitions in file           如果这个 tag 是本文件定义的，这个可以用  |
   | ~SPC m g n~ | jump to next location in context stack                                       |
   | ~SPC m g p~ | jump to previous location in context stack                                   |
   | ~SPC m g r~ | find references                         有几个人用了这函数                   |
   | ~SPC m g R~ | resume previous helm-gtags session       看看 tags 文件中有多少 tag            |
   | ~SPC m g s~ | select any tag in a project retrieved by gtags 看看 tags 文件中有多少 tag      |
   | ~SPC m g S~ | show stack of visited locations                                              |
   | ~SPC m g y~ | find symbols   状态栏显示符号                                                |
   | ~SPC m g u~ | manually update tag database 手动更新 tag 数据库                               |
*** 文件比较 ediff
*** 代码折叠
    zc      折叠
    zC     对所在范围内所有嵌套的折叠点进行折叠
    zo      展开折叠
    zO     对所在范围内所有嵌套的折叠点展开
    [z       到当前打开的折叠的开始处。
    ]z       到当前打开的折叠的末尾处。
    zj       向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
    zk      向上移动到前一折叠的结束处。关闭的折叠也被计入。
    zf      创建折叠，比如在 marker 方式下：
    zd      删除 (delete) 在光标下的折叠。仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效。
    zD     循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。
    zE     除去 (Eliminate) 窗口里“所有”的折叠。
*** projects
    | Key Binding | Description                                             |
|-------------+---------------------------------------------------------|
| ~SPC p '​~   | open a shell in project's root (with the =shell= layer) |
| ~SPC p !~   | run shell command in project's root                     |
| ~SPC p &~   | run async shell command in project's root               |
| ~SPC p %~   | replace a regexp                                        |
| ~SPC p a~   | toggle between implementation and test                  |
| ~SPC p b~   | switch to project buffer                                |
| ~SPC p c~   | compile project using =projectile=                      |
| ~SPC p d~   | find directory                                          |
| ~SPC p D~   | open project root in =dired=                            |
| ~SPC p e~   | edit dir-locals.el                                      |
| ~SPC p f~   | find file                                               |
| ~SPC p F~   | find file based on path around point                    |
| ~SPC p g~   | find tags                                               |
| ~SPC p G~   | regenerate the project's =etags= / =gtags=              |
| ~SPC p h~   | find file                                               |
| ~SPC p I~   | invalidate the projectile cache                         |
| ~SPC p k~   | kill all project buffers                                |
| ~SPC p o~   | run =multi-occur=                                       |
| ~SPC p p~   | switch project                                          |
| ~SPC p r~   | open a recent file                                      |
| ~SPC p R~   | replace a string                                        |
| ~SPC p t~   | open =NeoTree= in =projectile= root                     |
| ~SPC p T~   | test project                                            |
| ~SPC p v~   | open project root in =vc-dir= or =magit=                |
| ~SPC /~     | search in project with the best search tool available   |
| ~SPC s p~   | see [[#searching-in-a-project][searching in a project]]                              |
| ~SPC s a p~ | run =ag=                                                |
| ~SPC s g p~ | run =grep=                                              |
| ~SPC s k p~ | run =ack=                                               |
| ~SPC s t p~ | run =pt=                                                |
| ~SPC s r p~ | run =rg=                                                |

*** Registers
 Access commands to the various registers start with =r=:

 | Key Binding | Description                        |
 |-------------+------------------------------------|
 | ~SPC r e~   | show evil yank and named registers |
 | ~SPC r m~   | show marks register                |
 | ~SPC r r~   | show helm register                 |
 | ~SPC r y~   | show kill ring                     |

*** Errors handling
 Spacemacs uses [[https://github.com/flycheck/flycheck][Flycheck]] to gives error feedback on the fly. The checks are
 only performed at save time by default.

 Errors management commands (start with ~e~):

 | Key Binding | Description                                                           |
 |-------------+-----------------------------------------------------------------------|
 | ~SPC t s~   | toggle flycheck                                                       |
 | ~SPC e c~   | clear all errors                                                      |
 | ~SPC e h~   | describe a flycheck checker                                           |
 | ~SPC e l~   | toggle the display of the =flycheck= list of errors/warnings          |
 | ~SPC e n~   | go to the next error                                                  |
 | ~SPC e p~   | go to the previous error                                              |
 | ~SPC e v~   | verify flycheck setup (useful to debug 3rd party tools configuration) |
 | ~SPC e .~   | error transient state                                                 |

 The next/previous error bindings and the error transient state can be used to
 browse errors from flycheck as well as errors from compilation buffers, and
 indeed anything that supports Emacs’ =next-error= API. This includes for example
 search results that have been saved to a separate buffer.

 Custom fringe bitmaps:

 | Symbol                   | Description |
 |--------------------------+-------------|
 | [[file:img/dot-error.png]]   | Error       |
 | [[file:img/dot-warning.png]] | warning     |
 | [[file:img/dot-info.png]]    | Info        |

*** Compiling
 Spacemacs binds a few commands to support compiling a project.

    | Key Binding | Description                    |
    |-------------+--------------------------------|
    | ~SPC c c~   | use =helm-make= via projectile |
    | ~SPC c C~   | compile                        |
    | ~SPC c d~   | close compilation window       |
    | ~SPC c k~   | kill compilation               |
    | ~SPC c m~   | =helm-make=                    |
    | ~SPC c r~   | recompile                      |

** 按键功能开发
*** 键绑定
    (evil-leader/set-key "o y" 'copy-to-clipboard)
    全局绑定 会被模式绑定覆盖
     (global-set-key (kbd "C-]") 'forward-char)
     //被下面的覆盖了
     (define-key evil-insert-state-map (kbd "C-]") 'forward-char)
     //用前导键
  #+BEGIN_SRC emacs-lisp
    (spacemacs/set-leader-keys "C-]" 'forward-char)
    (spacemacs/set-leader-keys-for-major-mode 'emacs-lisp-mode "C-]" 'forward-char)
  #+END_SRC
*** 快捷键
    主模式相关快捷键 SPC m
       SPC b . 	   缓冲区微状态。
       窗口
       SPC w v 或 :vsplit 	    在右侧打开一个垂直分割。
       SPC w s 或 :split 	    在下部打开一个水平分割。
       SPC w h/j/k/l 	    在窗口间导航。
       SPC w H/J/K/L 	    移动当前窗口。
       SPC w . 	    窗口微状态。

       文件
       Spacemacs 中所有文件命令都有 SPC f 前缀。
       SPC f f 	    打开一个缓冲区搜索当前目录中的文件。
       SPC f r 	    打开一个缓冲区在最近打开的文件中搜索。
       SPC f s 或 :w 	    保存当前文件。
       :x 	    保存当前文件并退出。
       :e <file> 	    打开<file>

       帮助系统
       Emacs 具有一个可扩展的帮助系统。所有的快捷键都有 SPC h d 前缀，以允许便捷地访问帮助系统。
       最重要的快捷键是 SPC h d f, SPC h d k, 和 SPC h d v。同样还有 SPC <f1> 允许用户搜索文档。
       SPC h d f 	    对一个功能提示并显示其文档。
       SPC h d k 	    对一个快捷键提示并显示其绑定的内容。
       SPC h d v 	    对一个变量提示并显示其文档和当前值。
       SPC <f1> 	    搜索一个命令，功能，变量或接口，并显示其文档
       不论何时，你遇到怪异的行为或想知道是什么东西做的，这些功能是你应该首先查阅的。

       探索
       SPC f e h 	    列出所有层并允许你浏览层上的文件。
       SPC ? 	    列出所有快捷键。helm-descbinds

       .spacemacs  文件
       SPC f e d 	                打开你的 .spacemacs
       SPC f e D 	                使用 diff 通过默认模版手动更新你的 .spacemacs

       Emacs Lisp
       变量
       设置变量是定制 Spacemacs 行为最常见的方式。语法很简单：
       (setq variable value) ; Syntax
       ;; Setting variables example
       (setq variable1 t; True
       variable2 nil ; False
       variable3 '("A" "list" "of" "things"))

       快捷键
       定义快捷键是几乎每个人都想做的事情，最好的方式就是使用内置的 define-key 函数。
       (define-key map new-keybinding function) ; Syntax
       ;; Map H to go to the previous buffer in normal mode
       (define-key evil-normal-state-map (kbd "H") 'spacemacs/previous-useful-buffer)
       ;; Mapping keybinding to another keybinding
       (define-key evil-normal-state-map (kbd "H") (kbd "^")) ; H goes to beginning of the line

       map 是你想要绑定键位到的 keymap。大多数情况下你会使用
       evil-<state-name>-state-map。其对应不同的 evil-mode 状态。例如，使用 evil-insert-state-map 映射用于插入模式的快捷键。

       使用 evil-leader/set-key 函数来映射 <Leader> 快捷键。
       (evil-leader/set-key key function) ; Syntax
       ;; Map killing a buffer to <Leader> b c
       (evil-leader/set-key "bc" 'kill-this-buffer)
       ;; Map opening a link to <Leader> o l only in org-mode
       (evil-leader/set-key-for-mode 'org-mode
       "ol" 'org-open-at-point)

       函数
       你可能偶尔想要定义一个函数做更复杂的定制，语法很简单：
       (defun func-name (arg1 arg2)
       "docstring"
       ;; Body
       )
       ;; Calling a function
       (func-name arg1 arg1)
       这里有个现实可用的示例函数：

       ;; This snippet allows you to run clang-format before saving
       ;; given the current file as the correct filetype.
       ;; This relies on the c-c++ layer being enabled.
       (defun clang-format-for-filetype ()
       "Run clang-format if the current file has a file extensions
       in the filetypes list."
       (let ((filetypes '("c" "cpp")))
       (when (member (file-name-extension (buffer-file-name)) filetypes)
       (clang-format-buffer))))
       ;; See http://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html for
       ;; what this line means
       (add-hook 'before-save-hook 'clang-format-for-filetype)

       激活一个层
       正如上文术语那段所说，层提供一个简单的方式来添加特性。可在 .spacemacs 文件中激活
       一个层。
       在文件中找到 dotspacemacs-configuration-layers 变量，默认情况下，它看起来应该是这样的：
       (defun dotspacemacs/layers ()
       (setq-default
       ;; ...
       dotspacemacs-configuration-layers '(;; auto-completion
       ;; better-defaults
       emacs-lisp
       ;; (git :variables
       ;;      git-gutter-use-fringe t)
       ;; markdown
       ;; org
       ;; syntax-checking
       )))

       你可以通过删除分号来取消注释这些建议的层，开箱即用。要添加一个层，就把它的名字添
       加到列表中并重启
       Emacs 或按 SPC f e R。使用 SPC f e h 来显示所有的层和他们的文档。

       创建一个层
       为了将配置分组或当配置与你的 .spacemacs 文件之间不匹配时，你可以创建一个配置层
       。Spacemacs 提供了一个内建命令用于生成层的样板文件：SPC
       :configuration-layer/create-layer。
       这条命令将会生成一个如下的文件夹：

       [layer-name]
       |__ [local]*
       | |__ [example-mode-1]
       | |     ...
       | |__ [example-mode-n]
       |__ config.el*
       |__ funcs.el*
       |__ keybindings.el*
       |__ packages.el

       [] = 文件夹
       \ * = 不是命令生成的文件

       Packages.el 文件包含你可以在 <layer-name>-packages 变量中安装的包的列表。
       所有 MELPA 仓库中的包都可以添加到这个列表中。还可以使用 :excludedt 特性将包包含
       在列表中。
       每个包都需要一个函数来初始化。这个函数必须以这种模式命名：
       <layer-name>/init-<package-name>。
       这个函数包含了包的配置。同时还有一个 pre/post-init 函数来在包加载之前或之后运行代码。它看起来想这个样子：

       (setq layer-name-packages '(example-package
       ;;这个层通过设置:excluded 属性
       ;;为真(t)来卸载 example-package-2
       (example-package-2 :excluded t)))
       (defun layer-name/post-init-package ()
       ;;在这里添加另一个层的包的配置
       )
       (defun layer-name/init-example-package ()
       ;;在这里配置 example-package
       )

       **注意**：只有一个层可以具有一个对于包的 init 函数。如果你想覆盖另一个层对一个包
       的配置，请使用 use-package hooks 中的 <layer-name>/pre-init 函数。
       如果 MELPA 中没有你想要的包，你必须是由一个本地包或一个包源。关于此的更多信息可以从层的剖析处获得。

       确保你添加了你的层到你的 .spacemacs 文件中，并重启 spacemacs 以激活。
       关于层的加载过程和层的工作原理的详细描述可以参考 LAYERS.org。

       安装一个单独的包
       有时创建一个层会有点大材小用了，也许你仅仅想要一个包而不想维持整个层。Spacemacs
       在 .spacemacs 文件中的 dotspacemacs/layers 函数里提供了一个叫做
       dotspacemacs-additional-packages 的变量，只要在列表中添加一个包名，它就会在你重
       启的时候被安装。
       下一段来说明如何加载这个包。
       加载包
       有没有想过 Spacemacs 如何可以在仅仅几秒钟之内加载超过 100 个包呢？
       如此低的加载时间必须需要某种难以理解的黑魔法吧。还好这不是真的，多亏有了
       use-package。
       它是一个可以轻松实现对包进行延迟加载和配置的包。以下是它的基础用法：

       ;; Basic form of use-package declaration. The :defer t tells use-package to
       ;; try to lazy load the package.
       (use-package package-name
       :defer t)
       ;; The :init section is run before the package loads The :config section is
       ;; run after the package loads
       (use-package package-name
       :defer t
       :init
       (progn
       ;; Change some variables
       (setq variable1 t variable2 nil)
       ;; Define a function
       (defun foo ()
       (message "%s" "Hello, World!")))
       :config
       (progn
       ;; Calling a function that is defined when the package loads
       (function-defined-when-package-loads)))

       这只是 use-package 的一个非常基本的概述。它还有许多其他的方式来控制包的加载，就不在这里介绍了。
       卸载一个包

       Spacemacs 在 .spacemacs 文件中的 dotspacemacs/init 函数里提供了一个叫做
       dotspacemacs-excluded-packages 的变量。只要在列表中添加一个包名，它就会在你重启的时候被卸载。
       常见调整
       本段是为了想要做更多调整的人所写的。除非另有说明，所有这些设置都去你的
       .spacemacs 文件中的
       dotspacemacs/user-config 函数里完成。

       变更 escape 键
       Spacemacs 使用 [[https://github.com/syl20bnr/evil-escape][evil-escape]] 来允许从许多拥有一个快捷键的 major-modes 中跳出。
       你可以在你的 dotspacemacs/user-config 函数中像这样定制变量：
       (defun dotspacemacs/user-config ()
       ;; ...
       ;; Set escape keybinding to "jk"
       (setq-default evil-escape-key-sequence "jk"))
       更多的文档可以在 evil-escape README 中找到。

       变更配色方案
       .spacemacs 文件的 dotspacemacs/init 函数中有一个 dotspacemacs-themes 变量
       。这是一个可以用 SPC T n 键循环的主题的列表。列表中的第一个主题是在启动时加载的主题。
       以下为示例：

       (defun dotspacemacs/init
       ;; Darktooth theme is the default theme
       ;; Each theme is automatically installed.
       ;; Note that we drop the -theme from the package name.
       ;; Ex. darktooth-theme -> darktooth
       (setq-default dotspacemacs-themes '(darktooth
       soothe
       gotham)))

       可以使用 SPC T h 键列出和选择所有已安装的主题。
       非高亮搜索
       Spacemacs 模仿了默认的 vim 行为，会高亮显示搜索结果，尽管你不在它们之间进行导航。
       你可以使用 SPC s c 或 :nohlsearch 来关闭搜索结果高亮。
       若再也不需要自动高亮结果，你可以卸载 evil-search-highlight-persist 包。

       会话
       当你打开 Spacemacs 时，它不会自动恢复窗口和缓冲区。如果你常使用 vim 会话，
       你可能要在你的 .spacemacs 文件中的 dotspacemacs/user-config 里添加
       (desktop-save-mode t)，然后你就可以使用 SPC : desktop-read 加载已被保存的会话。
       桌面文件的位置可以使用 desktop-dirname 变量设置。要自动加载一个会话，就在你的
       .spacemacs 文件中添加 (desktop-read)。

       使用 visual lines 导航
       Spacemacs 使用 vim 默认 actual lines 导航，即使它们被包装了。如果你想要让 j 和 k
       的行为如 g j 和 g k 一般，将一下代码添加到你的 .spacemacs 文件：
       (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
       (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)

*** EScaping 键
    (setq-default evil-escape-key-sequence "jj"))
*** 键绑定帮助
  | Key Binding | Description                                               |
  |-------------+-----------------------------------------------------------|
  | ~SPC h d b~ | describe bindings                                         |
  | ~SPC h d c~ | describe current character under point                    |
  | ~SPC h d d~ | describe current expression under point                   |
  | ~SPC h d f~ | describe a function                                       |
  | ~SPC h d F~ | describe a face                                           |
  | ~SPC h d k~ | describe a key                                            |
  | ~SPC h d K~ | describe a keymap                                         |
  | ~SPC h d l~ | copy last pressed keys that you can paste in gitter chat  |
  | ~SPC h d m~ | describe current modes                                    |
  | ~SPC h d p~ | describe a package (Emacs built-in function)              |
  | ~SPC h d P~ | describe a package (Spacemacs layer information)          |
  | ~SPC h d s~ | copy system information that you can paste in gitter chat |
  | ~SPC h d t~ | describe a theme                                          |
  | ~SPC h d v~ | describe a variable                                       |

  Other help key bindings:

  | Key Binding | Description                                           |
  |-------------+-------------------------------------------------------|
  | ~SPC h SPC~ | discover Spacemacs documentation, layers and packages |
  | ~SPC h i~   | search in info pages with the symbol at point         |
  | ~SPC h k~   | show top-level bindings with =which-key=              |
  | ~SPC h m~   | search available man pages                            |
  | ~SPC h n~   | browse emacs news                                     |

  Navigation key bindings in =help-mode=:

*** 快速访问 ace-link 模式
    在 help-mode 和 info-mode 中可以 用 o 快速跳转
*** 通过语义列出符号 SPC s j
*** 寄存器
    | Key Binding | Description                        |
    |-------------+------------------------------------|
    | ~SPC r e~   | show evil yank and named registers |
    | ~SPC r m~   | show marks register                |
    | ~SPC r r~   | show helm register                 |
    | ~SPC r y~   | show kill ring                     |
*** 文件和 Buffer 操作
**** 不同点
  - 没有使用官方的 modeline, 而是采用自己定制的
  - 排除掉了大量的作者认为对他没有作用的 package, 因为这些 package 确实不经常使用, 反而可能导致一些 BUG 或者导致 spacemacs 启动或使用过程中变慢

**** 文件相关操作
  1. SPC p f
    在当前的项目中查找文件, 类似于 vim 中的 Ctrl-p. 在作者的配置中, 该快捷键被绑定到了以下函数:

    #+BEGIN_SRC emacs-lisp
      (defun zilongshanren/open-file-with-projectile-or-counsel-git ()
        (interactive)
        (if (zilongshanren/vcs-project-root)
            (counsel-git)
          (if (projectile-project-p)
              (projectile-find-file)
            (ido-find-file))))
    #+END_SRC

    该函数会针对不同的项目类型使用不同的查找方式:
     - 如果是 git 项目, 那么使用 counsel-git 来查找文件, 不使用 projectile 的原因是 counsel-git 更快
     - 如果是 projectile 项目, 即在项目的根目录中存在 .projectile 文件, 那么使用 projectile-find-file 来查找文件
     - 否则使用 ido-fine-file 来查找文件

  2. SPC f f
    从当前目录开始查找文件. 在作者的配置中同时启用了 ivy-layer 和 helm-layer, 默认使用的是 helm 来查找文件.

  3. SPC f L
    使用 helm-locate 来在当前系统中查找文件.

  4. SPC f l
    查找文件并使用 literal(逐字, 只能是 ascii 形式， 对于 utf 显示形式 '\350\380'） 的方式来打开文件, 使用 literal 方式打开的文件不会附加编码信息,
  例如 utf-8 编码中可能存在的 BOM 头信息, 使用 literal 模式即可以看到 BOM 头.

  5. SPC f h 查找文件并使用二进制的方式来打开文件, 可以使用 C-c C-c 回到之前的模式.

  6. SPC f o 使用外部程序打开文件.

  7. SPC f E 使用 sudo 来编辑文件, 当某些文件是只读的时候可以采用这种方式来编辑文件.

  8. SPC f D 删除当前的文件和 buffer.

  9. SPC f j 以当前文件的目录打开 dired buffer.

  10. SPC f r 使用 ivy 打开最近文件列表.

  11. SPC f R 重命名当前文件.

  12. SPC f v
    添加 local variables, 可以通过这个功能给项目做一些特殊的设置.
    例如按下 SPC f v, 然后选择 add-dir-local-variable, 选择 org-mode, 再选择 org-highlight-links 变量, 此时 emacs 会在当前文件的目录下生成一个 .dir-locals.el 文件, 内容如下:

    #+BEGIN_SRC emacs-lisp
    ;;; Directory Local Variables
    ;;; For more information see (info "(emacs) Directory Variables")

    ((org-mode
      (org-highlight-links)))
    #+END_SRC

    这个文件中的代码会在当前目录下的所有文件 buffer 中生效.

  13. SPC f y 拷贝当前文件的全路径.

  14. SPC f a d 列出最近访问的目录, 使用命令行工具 fasd 实现.

  15. SPC f C d/u 将当前文件的编码转换为 DOS/UNIX 编码., unix 编码少一个换行, 真的
  16. SPC f e d 打开 .spacemacs 或 .spacemacs.d/init.el 文件.
  17. SPC f e i 打开 .emacs 或 .emacs.d/init.el 文件.
  18. SPC f e l 打开系统中已经安装的 el 文件.
  19. SPC f c 复制文件.
  20. SPC f b 打开标签.
  21. SPC f s/S 保存当前 buffer 或 所有 buffer.
**** buffer 相关操作
  1. SPC b . 打开 Buffer Selection Transient State, 在该模式下可以进行更多的操作, 由 hydra 提供.
  2. SPC b b 切换到已经打开的 buffer.
  3. SPC b d 关闭一个 buffer.

  4. SPC b f !!!!! 在 finder 中打开当前文件, 只在 Mac 系统下生效.

  5. SPC b B/i 以类似 Dired Mode 的形式打开 buffer 列表, 在这个列表中可以执行和 Dired Mode 类似的操作.

  6. SPC b h 进入 \*spacemacs\* buffer.
  7. SPC b k 使用正则表达式来删除 buffer.
  8. SPC b N 新建一个 buffer.
  9. SPC b m 删除除当前 buffer 外的所有 buffer.

  10. SPC b R 使用 emacs 自动备份的文件恢复文件.

  11. SPC b s 跳转到 scratch buffer.

  12. SPC b w 关闭/打开 buffer 的 read-only.
  13. SPC b Y 复制整个 buffer 的内容.
  14. SPC b P 将剪切板的内容粘贴到整个 buffer.
  15. SPC <tab> 在当前 buffer 和上一个打开的 buffer 中进行切换.
*** 对齐文本
| 键绑定       | 说明           |
| 〜SPC xa＆〜 | 在＆  对齐区域 |
*** 键绑定
    1.可以使用命令 (global-set-key (kbd "C-f") 'forward-word)
    2.模式下（define-key evil-insert-state-map（kbd“C-”））'forward-char）
*** 文本插入
    | 〜SPC ill〜   | 插入 lorem-ipsum 列表                      |
    | 〜SPC ilp〜   | 插入 lorem-ipsum 段落                      |
    | 〜SPC ils〜   | 插入 lorem-ipsum 句子                      |
    | 〜SPC ip 1〜  | 插入简单的密码                             |
    | 〜SPC ip 2〜  | 插入更强的密码                             |
    | 〜SPC ip 3〜  | 为偏执狂插入密码                           |
    | 〜SPC ipp〜   | 插入发音简单的密码                         |
    | 〜SPC ipn〜   | 插入数字密码                               |
    | 〜SPC iu〜    | 搜索 Unicode 字符并将其插入到活动缓冲区中  |
    | 〜SPC i U 1〜 | 插入 UUIDv1（使用通用参数来插入 CID 格式） |
    | 〜SPC i U 4〜 | 插入 UUIDv4（使用通用参数来插入 CID 格式） |
    | 〜SPC 我 UU〜 | 插入 UUIDv4（使用通用参数来插入 CID 格式） |

  *提示：*您可以用数字改变插入的密码的长度 前缀参数，例如〜SPC U 24 SPC ipp〜将插入一个密码24 个字符。
** 调试
   找到(出问题的)快捷键对应的函数；
   M-x edebug-defun；
   按(出问题的)快捷键。
*** 编码
    ;;;; 设置编辑环境
;; 设置为中文简体语言环境
(set-language-environment 'Chinese-GB)
;; 设置 emacs 使用 utf-8
(setq locale-coding-system 'utf-8)
;; 设置键盘输入时的字符编码
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
;; 文件默认保存为 utf-8
(set-buffer-file-coding-system 'utf-8)
(set-default buffer-file-coding-system 'utf8)
(set-default-coding-systems 'utf-8)
;; 解决粘贴中文出现乱码的问题
(set-clipboard-coding-system 'utf-8)
;; 终端中文乱码
(set-terminal-coding-system 'utf-8)
(modify-coding-system-alist 'process "*" 'utf-8)
(setq default-process-coding-system '(utf-8 . utf-8))
;; 解决文件目录的中文名乱码
(setq-default pathname-coding-system 'utf-8)
(set-file-name-coding-system 'utf-8)
;; 解决 Shell Mode(cmd) 下中文乱码问题
(defun change-shell-mode-coding ()
  (progn
    (set-terminal-coding-system 'gbk)
    (set-keyboard-coding-system 'gbk)
    (set-selection-coding-system 'gbk)
    (set-buffer-file-coding-system 'gbk)
    (set-file-name-coding-system 'gbk)
    (modify-coding-system-alist 'process "*" 'gbk)
    (set-buffer-process-coding-system 'gbk 'gbk)
    (set-file-name-coding-system 'gbk)))

直接在缓冲区修改编码：
1、打开文件出现乱码时，可以尝试修改字符的编码：
M-x revert-buffer-with-coding-system RET（回车）
然后输入对应编码，如：utf-8 或者 chinese-gbk。

2、在保存的时候还可以指定文件的保存编码：
M-x set-buffer-file-coding-system

3、查看 Emacs 编码格式
M-x describe-coding-system
*** 编码
**** 方法一：
只需 C-x <RET> r ( M-x revert-buffer-with-coding-system) 来用指定的编码重新读入这个文件即可。一般乱码都是因为 emacs 下使用 latin 或者 utf8，而打开的文档是 gb2312 编码。如果不记得编码类型就试一下，基本上 gb2312 都能解决。询问编码时记得用 tab 补齐比较方便。或则也可以通过 file 文件名或者 enca 文件名来查看！
** 配置
   如果希望把配置放在 ~/.emacs.d/init.el 文件中，那么需要手工删除 ~/.emacs 文件。
   init.el文件 它可以更好将所有 Emacs 相关的文件整合在一个目录内（干净的 HOME，网盘备份等优点）
   更好的版本控制
** unicode 
    以某编码打开： M-x revert-buffer-with-coding-system RET（回车）
    Ctrl-x 8 Enter 3bb Enter
  $ ＄ 央行网页选用了半角字符 U+00A5 (¥)。另见：人民币符号是「U+FFE5」还是「U+00A5」？ ￥
shy
