
* linux 接口　[ 文件,进程,计时器,进程线程通信,网络]
 hapter 1: History and Standards .................................................................................... 1
 hapter 2: Fundamental Concepts ................................................................................. 21
 hapter 3: System Programming Concepts...................................................................... 43
 hapter 4: File I/O: The Universal I/O Model................................................................. 69
 hapter 5: File I/O: Further Details ................................................................................ 89
 hapter 6: Processes .................................................................................................. 113
 hapter 7: Memory Allocation..................................................................................... 139
 hapter 8: Users and Groups ...................................................................................... 153
 hapter 9: Process Credentials .................................................................................... 167
 hapter 10: Time....................................................................................................... 185
 hapter 11: System Limits and Options......................................................................... 211
 hapter 12: System and Process Information ................................................................. 223
 hapter 13: File I/O Buffering..................................................................................... 233
 hapter 14: File Systems ............................................................................................ 251
 hapter 15: File Attributes .......................................................................................... 279
 hapter 16: Extended Attributes .................................................................................. 311
 hapter 17: Access Control Lists .................................................................................. 319
 hapter 18: Directories and Links ................................................................................ 339
 hapter 19: Monitoring File Events .............................................................................. 375
 hapter 21: Signals: Signal Handlers........................................................................... 421
 hapter 22: Signals: Advanced Features ...................................................................... 447
 hapter 23: Timers and Sleeping................................................................................. 479
 hapter 24: Process Creation...................................................................................... 513
 hapter 25: Process Termination.................................................................................. 531
 hapter 26: Monitoring Child Processes ....................................................................... 541
 hapter 27: Program Execution ................................................................................... 563
 hapter 28: Process Creation and Program Execution in More Detail............................... 591
 hapter 29: Threads: Introduction................................................................................ 617
 hapter 30: Threads: Thread Synchronization ............................................................... 631
 hapter 31: Threads: Thread Safety and Per-Thread Storage........................................... 655
 hapter 32: Threads: Thread Cancellation.................................................................... 671
 hapter 33: Threads: Further Details ............................................................................ 681
 hapter 34: Process Groups, Sessions, and Job Control ................................................. 699
 hapter 35: Process Priorities and Scheduling ............................................................... 733
 hapter 36: Process Resources .................................................................................... 753
 hapter 37: Daemons ................................................................................................ 767
 hapter 38: Writing Secure Privileged Programs ........................................................... 783
 hapter 39: Capabilities ............................................................................................ 797
 hapter 40: Login Accounting ..................................................................................... 817
 hapter 41: Fundamentals of Shared Libraries .............................................................. 833
 hapter 42: Advanced Features of Shared Libraries....................................................... 859
 hapter 43: Interprocess Communication Overview ....................................................... 877
 hapter 44: Pipes and FIFOs....................................................................................... 889
 hapter 45: Introduction to System V IPC...................................................................... 921
 hapter 46: System V Message Queues ....................................................................... 937
iii Brief Contents
 hapter 48: System V Shared Memory ......................................................................... 997
 hapter 49: Memory Mappings ................................................................................ 1017
 hapter 50: Virtual Memory Operations ..................................................................... 1045
 hapter 51: Introduction to POSIX IPC........................................................................ 1057
 hapter 52: POSIX Message Queues ......................................................................... 1063
 hapter 53: POSIX Semaphores ................................................................................ 1089
 hapter 54: POSIX Shared Memory........................................................................... 1107
 hapter 55: File Locking ........................................................................................... 1117
 hapter 56: Sockets: Introduction .............................................................................. 1149
 hapter 57: Sockets: UNIX Domain ........................................................................... 1165
 hapter 58: Sockets: Fundamentals of TCP/IP Networks............................................... 1179
 hapter 59: Sockets: Internet Domains ....................................................................... 1197
 hapter 60: Sockets: Server Design ........................................................................... 1239
 hapter 61: Sockets: Advanced Topics....................................................................... 1253
 hapter 62: Terminals .............................................................................................. 1289
 hapter 63: Alternative I/O Models........................................................................... 1325
 hapter 64: Pseudoterminals..................................................................................... 1375
ppendix A: Tracing System Calls ............................................................................. 1401
ppendix B: Parsing Command-Line Options............................................................... 1405
ppendix C: Casting the NULL Pointer ......................................................................... 1413
ppendix D: Kernel Configuration ............................................................................. 1417
ppendix E: Further Sources of Information ................................................................. 1419
ppendix F: Solutions to Selected Exercises................................................................. 1425
ibliography............................................................................................................ 1437
 dex .......................................................................................................................1447
                                                                                                                          B r i e f C on t e n t s ix
REFA CE                                                                                                                         xxxi
     HISTORY AND STANDARDS                                                                                                           1
.1   A Brief History of UNIX and C ........................................................................................2
.2   A Brief History of Linux ...................................................................................................5
        1.2.1         The GNU Project ......................................................................................5
        1.2.2         The Linux Kernel .......................................................................................6
.3   Standardization .......................................................................................................... 10
        1.3.1         The C Programming Language ................................................................. 10
        1.3.2         The First POSIX Standards........................................................................ 11
        1.3.3         X/Open Company and The Open Group .................................................. 13
        1.3.4         SUSv3 and POSIX.1-2001 ....................................................................... 13
        1.3.5         SUSv4 and POSIX.1-2008 ....................................................................... 15
        1.3.6         UNIX Standards Timeline ......................................................................... 16
        1.3.7         Implementation Standards........................................................................ 17
        1.3.8         Linux, Standards, and the Linux Standard Base........................................... 18
.4   Summary.................................................................................................................... 19
     F UNDAMENTAL C ONCEP TS                                                                                                       21
.1   The Core Operating System: The Kernel .........................................................................                21
.2   The Shell .................................................................................................................... 24
.3   Users and Groups .......................................................................................................       26
.4   Single Directory Hierarchy, Directories, Links, and Files ...................................................                  27
.5   File I/O Model ...........................................................................................................     29
.6   Programs....................................................................................................................   30
.7   Processes ...................................................................................................................  31
.8   Memory Mappings ......................................................................................................         35
.9   Static and Shared Libraries...........................................................................................         35
.10  Interprocess Communication and Synchronization ...........................................................                     36
.11  Signals....................................................................................................................... 37
.12  Threads......................................................................................................................  38
.13  Process Groups and Shell Job Control............................................................................               38
.14  Sessions, Controlling Terminals, and Controlling Processes ...............................................                     39
.15  Pseudoterminals ..........................................................................................................     39
.16  Date and Time ............................................................................................................     40
.17  Client-Server Architecture .............................................................................................       40
.18  Realtime ..................................................................................................................... 41
.19  The /proc File System...................................................................................................       42
.20  Summary....................................................................................................................    42
     S YSTEM PROGRAMM ING CO NCEP TS                                                                                               43
.1   System Calls ...............................................................................................................   43
.2   Library Functions .........................................................................................................    46
.3   The Standard C Library; The GNU C Library ( glibc) .........................................................                   47
.4   Handling Errors from System Calls and Library Functions..................................................                      48
.5   Notes on the Example Programs in This Book..................................................................                   50
        3.5.1         Command-Line Options and Arguments .....................................................                      50
        3.5.2         Common Functions and Header Files.........................................................                    51
            3.6.2                  System Data Types ..................................................................................   63
            3.6.3                  Miscellaneous Portability Issues.................................................................      66
.7     Summary....................................................................................................................        68
.8     Exercise .....................................................................................................................     68
       F ILE I/O: THE UN IVERSA L I/O MODEL                                                                                              69
.1     Overview ...................................................................................................................       69
.2     Universality of I/O ......................................................................................................         72
.3     Opening a File: open() .................................................................................................           72
            4.3.1                  The open() flags Argument........................................................................      74
            4.3.2                  Errors from open() ................................................................................... 77
            4.3.3                  The creat() System Call ............................................................................   78
.4     Reading from a File: read() ...........................................................................................            79
.5     Writing to a File: write()...............................................................................................          80
.6     Closing a File: close() ...................................................................................................        80
.7     Changing the File Offset: lseek() ....................................................................................             81
.8     Operations Outside the Universal I/O Model: ioctl() .......................................................                        86
.9     Summary....................................................................................................................        86
.10    Exercises ....................................................................................................................     87
       F ILE I/O: FURTHER DETAILS                                                                                                        89
.1     Atomicity and Race Conditions ..................................................................................... 90
.2     File Control Operations: fcntl() ..................................................................................... 92
.3     Open File Status Flags ................................................................................................. 93
.4     Relationship Between File Descriptors and Open Files ...................................................... 94
.5     Duplicating File Descriptors .......................................................................................... 96
.6     File I/O at a Specified Offset: pread() and pwrite() ......................................................... 98
.7     Scatter-Gather I/O: readv() and writev() ........................................................................ 99
.8     Truncating a File: truncate() and ftruncate() ................................................................. 103
.9     Nonblocking I/O ...................................................................................................... 103
.10    I/O on Large Files ..................................................................................................... 104
.11    The /dev/fd Directory ................................................................................................ 107
.12    Creating Temporary Files ........................................................................................... 108
.13    Summary.................................................................................................................. 109
.14    Exercises .................................................................................................................. 110
       PROCESSES                                                                                                                      11 3
.1     Processes and Programs.............................................................................................              113
.2     Process ID and Parent Process ID.................................................................................                114
.3     Memory Layout of a Process .......................................................................................               115
.4     Virtual Memory Management .....................................................................................                  118
.5     The Stack and Stack Frames .......................................................................................               121
.6     Command-Line Arguments (argc, argv) .........................................................................                    122
.7     Environment List ........................................................................................................        125
.8     Performing a Nonlocal Goto: setjmp() and longjmp() ....................................................                          131
.9     Summary..................................................................................................................        138
.10    Exercises ..................................................................................................................     138
ii  C on t e n t s i n D e t a i l
       7.1.1         Adjusting the Program Break: brk() and sbrk() ..........................................                     139
       7.1.2         Allocating Memory on the Heap: malloc() and free() .................................                         140
       7.1.3         Implementation of malloc() and free() ......................................................                 144
       7.1.4         Other Methods of Allocating Memory on the Heap ...................................                           147
.2  Allocating Memory on the Stack: alloca() .....................................................................                150
.3  Summary..................................................................................................................     151
.4  Exercises ..................................................................................................................  152
    U S ER S AN D GR OU PS                                                                                                      15 3
.1  The Password File: /etc/passwd ...................................................................................            153
.2  The Shadow Password File: /etc/shadow ......................................................................                  155
.3  The Group File: /etc/group .........................................................................................          155
.4  Retrieving User and Group Information ........................................................................                157
.5  Password Encryption and User Authentication ...............................................................                   162
.6  Summary..................................................................................................................     166
.7  Exercises ..................................................................................................................  166
    PROCESS CREDENTIALS                                                                                                         167
.1  Real User ID and Real Group ID..................................................................................              167
.2  Effective User ID and Effective Group ID.......................................................................               168
.3  Set-User-ID and Set-Group-ID Programs ........................................................................                168
.4  Saved Set-User-ID and Saved Set-Group-ID ...................................................................                  170
.5  File-System User ID and File-System Group ID................................................................                  171
.6  Supplementary Group IDs ..........................................................................................            172
.7  Retrieving and Modifying Process Credentials...............................................................                   172
       9.7.1         Retrieving and Modifying Real, Effective, and Saved Set IDs ......................                           172
       9.7.2         Retrieving and Modifying File-System IDs .................................................                   178
       9.7.3         Retrieving and Modifying Supplementary Group IDs .................................                           178
       9.7.4         Summary of Calls for Modifying Process Credentials .................................                         180
       9.7.5         Example: Displaying Process Credentials .................................................                    182
.8  Summary..................................................................................................................     183
.9  Exercises ..................................................................................................................  184
0   TIME                                                                                                                        18 5
0.1 Calendar Time ..........................................................................................................      186
0.2 Time-Conversion Functions..........................................................................................           187
       10.2.1        Converting time_t to Printable Form ........................................................                 188
       10.2.2        Converting Between time_t and Broken-Down Time ...................................                           189
       10.2.3        Converting Between Broken-Down Time and Printable Form .......................                               191
0.3 Timezones ................................................................................................................    197
0.4 Locales.....................................................................................................................  200
0.5 Updating the System Clock .........................................................................................           204
0.6 The Software Clock (Jiffies) .........................................................................................        205
0.7 Process Time.............................................................................................................     206
0.8 Summary..................................................................................................................     209
0.9 Exercise ...................................................................................................................  210
                                                                                                                          C o n te n t s i n D e t a i l xiii
1.2   Retrieving System Limits (and Options) at Run Time ........................................................                   215
1.3   Retrieving File-Related Limits (and Options) at Run Time..................................................                    217
1.4   Indeterminate Limits ...................................................................................................      219
1.5   System Options .........................................................................................................      219
1.6   Summary..................................................................................................................     221
1.7   Exercises ..................................................................................................................  222
 2    SYSTEM AND PROCESS INFORMATION                                                                                              22 3
2.1   The /proc File System.................................................................................................        223
         12.1.1            Obtaining Information About a Process: /proc/PID ...................................                     224
         12.1.2            System Information Under /proc..............................................................             226
         12.1.3            Accessing /proc Files ............................................................................       226
2.2   System Identification: uname() ....................................................................................           229
2.3   Summary..................................................................................................................     231
2.4   Exercises ..................................................................................................................  231
 3    F ILE I/O BUFF ERING                                                                                                        233
3.1   Kernel Buffering of File I/O: The Buffer Cache ..............................................................                 233
3.2   Buffering in the stdio Library .......................................................................................        237
3.3   Controlling Kernel Buffering of File I/O ........................................................................             239
3.4   Summary of I/O Buffering ..........................................................................................           243
3.5   Advising the Kernel About I/O Patterns........................................................................                244
3.6   Bypassing the Buffer Cache: Direct I/O........................................................................                246
3.7   Mixing Library Functions and System Calls for File I/O ..................................................                     248
3.8   Summary..................................................................................................................     249
3.9   Exercises ..................................................................................................................  250
 4    FILE SYSTEMS                                                                                                                25 1
4.1   Device Special Files (Devices) .....................................................................................          252
4.2   Disks and Partitions ...................................................................................................      253
4.3   File Systems ..............................................................................................................   254
4.4   I-nodes ..................................................................................................................... 256
4.5   The Virtual File System (VFS) .......................................................................................         259
4.6   Journaling File Systems...............................................................................................        260
4.7   Single Directory Hierarchy and Mount Points ................................................................                  261
4.8   Mounting and Unmounting File Systems .......................................................................                  262
         14.8.1            Mounting a File System: mount() ............................................................             264
         14.8.2            Unmounting a File System: umount() and umount2() ................................                        269
4.9   Advanced Mount Features ..........................................................................................            271
         14.9.1            Mounting a File System at Multiple Mount Points.......................................                   271
         14.9.2            Stacking Multiple Mounts on the Same Mount Point...................................                      271
         14.9.3            Mount Flags That Are Per-Mount Options .................................................                 272
         14.9.4            Bind Mounts.........................................................................................     272
         14.9.5            Recursive Bind Mounts...........................................................................         273
4.10  A Virtual Memory File System: tmpfs ............................................................................              274
4.11  Obtaining Information About a File System: statvfs() ......................................................                   276
4.12  Summary..................................................................................................................     277
4.13  Exercise ...................................................................................................................  278
iv   Contents in D eta i l
5.2  File Timestamps.........................................................................................................     285
        15.2.1         Changing File Timestamps with utime() and utimes() .................................                       287
        15.2.2         Changing File Timestamps with utimensat() and futimens() ........................                          289
5.3  File Ownership .........................................................................................................     291
        15.3.1         Ownership of New Files ........................................................................            291
        15.3.2         Changing File Ownership: chown(), fchown(), and lchown().......................                            291
5.4  File Permissions .........................................................................................................   294
        15.4.1         Permissions on Regular Files ...................................................................           294
        15.4.2         Permissions on Directories......................................................................           297
        15.4.3         Permission-Checking Algorithm ...............................................................              297
        15.4.4         Checking File Accessibility: access() .........................................................            299
        15.4.5         Set-User-ID, Set-Group-ID, and Sticky Bits .................................................               300
        15.4.6         The Process File Mode Creation Mask: umask() ........................................                      301
        15.4.7         Changing File Permissions: chmod() and fchmod() .....................................                      303
5.5  I-node Flags (ext2 Extended File Attributes) ...................................................................             304
5.6  Summary..................................................................................................................    308
5.7  Exercises .................................................................................................................. 309
6    EXTENDED ATTRIBUTES                                                                                                        311
6.1  Overview .................................................................................................................   311
6.2  Extended Attribute Implementation Details ....................................................................               313
6.3  System Calls for Manipulating Extended Attributes.........................................................                   314
6.4  Summary..................................................................................................................    318
6.5  Exercise ................................................................................................................... 318
7    ACC ESS C ONT RO L LIS T S                                                                                                 31 9
7.1  Overview .................................................................................................................   320
7.2  ACL Permission-Checking Algorithm.............................................................................               321
7.3  Long and Short Text Forms for ACLs.............................................................................              323
7.4  The ACL_MASK Entry and the ACL Group Class................................................................                   324
7.5  The getfacl and setfacl Commands ...............................................................................             325
7.6  Default ACLs and File Creation ...................................................................................           327
7.7  ACL Implementation Limits ..........................................................................................         328
7.8  The ACL API .............................................................................................................    329
7.9  Summary..................................................................................................................    337
7.10 Exercise ................................................................................................................... 337
8    D I R E C T O R I E S A ND L I NKS                                                                                          33 9
8.1  Directories and (Hard) Links........................................................................................         339
8.2  Symbolic (Soft) Links ..................................................................................................     342
8.3  Creating and Removing (Hard) Links: link() and unlink() ...............................................                      344
8.4  Changing the Name of a File: rename() .......................................................................                348
8.5  Working with Symbolic Links: symlink() and readlink() ..................................................                     349
8.6  Creating and Removing Directories: mkdir() and rmdir() ...............................................                       350
8.7  Removing a File or Directory: remove() .........................................................................             352
8.8  Reading Directories: opendir() and readdir() ................................................................                352
8.9  File Tree Walking: nftw() ...........................................................................................        358
8.10 The Current Working Directory of a Process .................................................................                 363
8.11 Operating Relative to a Directory File Descriptor ...........................................................                365
8.12 Changing the Root Directory of a Process: chroot() ........................................................                  367
8.13 Resolving a Pathname: realpath() ................................................................................            369
                                                                                                                            Contents in Detai l xv
8.16 Exercises .................................................................................................................. 373
9     M O NIT O R I NG F I L E E V E N T S                                                                                       37 5
9.1   Overview .................................................................................................................   376
9.2   The inotify API ..........................................................................................................   376
9.3   inotify Events ............................................................................................................  378
9.4   Reading inotify Events................................................................................................       379
9.5   Queue Limits and /proc Files.......................................................................................          385
9.6   An Older System for Monitoring File Events: dnotify.......................................................                   386
9.7   Summary..................................................................................................................    386
9.8   Exercise ................................................................................................................... 386
0     S IG NA LS : F U ND AME NT AL CONCE PTS                                                                                    38 7
0.1   Concepts and Overview.............................................................................................           388
0.2   Signal Types and Default Actions ................................................................................            390
0.3   Changing Signal Dispositions: signal().........................................................................              397
0.4   Introduction to Signal Handlers ...................................................................................          398
0.5   Sending Signals: kill() ...............................................................................................      401
0.6   Checking for the Existence of a Process........................................................................              403
0.7   Other Ways of Sending Signals: raise() and killpg() .....................................................                    404
0.8   Displaying Signal Descriptions ....................................................................................          406
0.9   Signal Sets ...............................................................................................................  406
0.10  The Signal Mask (Blocking Signal Delivery) ..................................................................                410
0.11  Pending Signals ........................................................................................................     411
0.12  Signals Are Not Queued ............................................................................................          412
0.13  Changing Signal Dispositions: sigaction() .....................................................................              416
0.14  Waiting for a Signal: pause()......................................................................................          418
0.15  Summary..................................................................................................................    418
0.16  Exercises .................................................................................................................. 419
1     S I G NA L S : S I G N A L H A ND L E R S                                                                                  42 1
1.1   Designing Signal Handlers .........................................................................................          422
         21.1.1            Signals Are Not Queued (Revisited) ........................................................             422
         21.1.2            Reentrant and Async-Signal-Safe Functions ...............................................               422
         21.1.3            Global Variables and the sig_atomic_t Data Type .....................................                   428
1.2   Other Methods of Terminating a Signal Handler ...........................................................                    428
         21.2.1            Performing a Nonlocal Goto from a Signal Handler ..................................                     429
         21.2.2            Terminating a Process Abnormally: abort() ...............................................               433
1.3   Handling a Signal on an Alternate Stack: sigaltstack() ...................................................                   434
1.4   The SA_SIGINFO Flag...................................................................................................       437
1.5   Interruption and Restarting of System Calls ...................................................................              442
1.6   Summary..................................................................................................................    445
1.7   Exercise ................................................................................................................... 446
2     S I G NA L S : A DV A N C E D F E A TU R E S                                                                               44 7
2.1   Core Dump Files .......................................................................................................      448
2.2   Special Cases for Delivery, Disposition, and Handling ...................................................                    450
2.3   Interruptible and Uninterruptible Process Sleep States.....................................................                  451
2.4   Hardware-Generated Signals......................................................................................             452
2.5   Synchronous and Asynchronous Signal Generation .......................................................                       452
vi   Contents in D eta i l
2.8  Realtime Signals........................................................................................................     456
        22.8.1        Sending Realtime Signals.......................................................................             458
        22.8.2        Handling Realtime Signals .....................................................................             460
2.9  Waiting for a Signal Using a Mask: sigsuspend() ..........................................................                   464
2.10 Synchronously Waiting for a Signal.............................................................................              468
2.11 Fetching Signals via a File Descriptor...........................................................................            471
2.12 Interprocess Communication with Signals .....................................................................                474
2.13 Earlier Signal APIs (System V and BSD) ........................................................................              475
2.14 Summary..................................................................................................................    477
2.15 Exercises .................................................................................................................. 478
3    TIMERS AND SLEEPING                                                                                                        479
3.1  Interval Timers...........................................................................................................   479
3.2  Scheduling and Accuracy of Timers .............................................................................              485
3.3  Setting Timeouts on Blocking Operations ......................................................................               486
3.4  Suspending Execution for a Fixed Interval (Sleeping) .....................................................                   487
        23.4.1        Low-Resolution Sleeping: sleep() ..............................................................             487
        23.4.2        High-Resolution Sleeping: nanosleep()......................................................                 488
3.5  POSIX Clocks............................................................................................................     491
        23.5.1        Retrieving the Value of a Clock: clock_gettime() ........................................                   491
        23.5.2        Setting the Value of a Clock: clock_settime() .............................................                 492
        23.5.3        Obtaining the Clock ID of a Specific Process or Thread .............................                        493
        23.5.4        Improved High-Resolution Sleeping: clock_nanosleep() ...............................                        493
3.6  POSIX Interval Timers.................................................................................................       495
        23.6.1        Creating a Timer: timer_create() .............................................................              495
        23.6.2        Arming and Disarming a Timer: timer_settime() ........................................                      498
        23.6.3        Retrieving the Current Value of a Timer: timer_gettime() .............................                      499
        23.6.4        Deleting a Timer: timer_delete() ..............................................................             499
        23.6.5        Notification via a Signal........................................................................           499
        23.6.6        Timer Overruns.....................................................................................         503
        23.6.7        Notification via a Thread .......................................................................           504
3.7  Timers That Notify via File Descriptors: the timerfd API ...................................................                 507
3.8  Summary..................................................................................................................    511
3.9  Exercises .................................................................................................................. 512
4    PROCESS CREATION                                                                                                           513
4.1  Overview of fork(), exit(), wait(), and execve() ..............................................................              513
4.2  Creating a New Process: fork() ...................................................................................           515
        24.2.1        File Sharing Between Parent and Child ....................................................                  517
        24.2.2        Memory Semantics of fork() ...................................................................              520
4.3  The vfork() System Call ..............................................................................................       522
4.4  Race Conditions After fork() .......................................................................................         525
4.5  Avoiding Race Conditions by Synchronizing with Signals...............................................                        527
4.6  Summary..................................................................................................................    529
4.7  Exercises .................................................................................................................. 530
5    PR OCES S T ERMI NAT ION                                                                                                   53 1
5.1  Terminating a Process: _exit() and exit().......................................................................             531
5.2  Details of Process Termination.....................................................................................          533
5.3  Exit Handlers ............................................................................................................   533
5.4  Interactions Between fork(), stdio Buffers, and _exit() .....................................................                537
                                                                                                                           Contents i n Detail xvii
6     M O NIT O R I NG C H I L D P RO C E SS E S                                                                                   54 1
6.1   Waiting on a Child Process ........................................................................................           541
         26.1.1                   The wait() System Call........................................................................... 541
         26.1.2                   The waitpid() System Call ......................................................................  544
         26.1.3                   The Wait Status Value ........................................................................... 545
         26.1.4                   Process Termination from a Signal Handler ..............................................          549
         26.1.5                   The waitid() System Call ........................................................................ 550
         26.1.6                   The wait3() and wait4() System Calls ......................................................       552
6.2   Orphans and Zombies ...............................................................................................           553
6.3   The SIGCHLD Signal ....................................................................................................       555
         26.3.1                   Establishing a Handler for SIGCHLD ..........................................................     555
         26.3.2                   Delivery of SIGCHLD for Stopped Children .................................................        559
         26.3.3                   Ignoring Dead Child Processes ...............................................................     559
6.4   Summary..................................................................................................................     561
6.5   Exercises ..................................................................................................................  562
7     PROGRA M EXECUTION                                                                                                          563
7.1   Executing a New Program: execve() .............................................................................               563
7.2   The exec() Library Functions.........................................................................................         567
         27.2.1                   The PATH Environment Variable ...............................................................     568
         27.2.2                   Specifying Program Arguments as a List...................................................         570
         27.2.3                   Passing the Caller’s Environment to the New Program ...............................               570
         27.2.4                   Executing a File Referred to by a Descriptor: fexecve() ................................          571
7.3   Interpreter Scripts ......................................................................................................    572
7.4   File Descriptors and exec() ..........................................................................................        575
7.5   Signals and exec() .....................................................................................................      578
7.6   Executing a Shell Command: system() ..........................................................................                579
7.7   Implementing system() ................................................................................................        582
7.8   Summary..................................................................................................................     588
7.9   Exercises ..................................................................................................................  589
8     PROCESS CREATION AND PRO GRAM EXECUTION IN
      MO RE DET AIL                                                                                                                591
8.1   Process Accounting....................................................................................................        591
8.2   The clone() System Call ..............................................................................................        598
         28.2.1                   The clone() flags Argument .....................................................................  603
         28.2.2                   Extensions to waitpid() for Cloned Children .............................................         609
8.3   Speed of Process Creation..........................................................................................           610
8.4   Effect of exec() and fork() on Process Attributes..............................................................               612
8.5   Summary..................................................................................................................     616
8.6   Exercise ...................................................................................................................  616
9     T H REA DS : I N TR O D UCT I O N                                                                                           61 7
9.1   Overview .................................................................................................................    617
9.2   Background Details of the Pthreads API ........................................................................               620
9.3   Thread Creation........................................................................................................       622
9.4   Thread Termination....................................................................................................        623
9.5   Thread IDs................................................................................................................    624
9.6   Joining with a Terminated Thread ................................................................................             625
9.7   Detaching a Thread ...................................................................................................        627
viii C on t e n t s i n D e t a i l
9.10 Summary..................................................................................................................    629
9.11 Exercises .................................................................................................................. 630
0    THREADS: THREAD SYNCHRONIZATION                                                                                            631
0.1  Protecting Accesses to Shared Variables: Mutexes.........................................................                    631
       30.1.1         Statically Allocated Mutexes...................................................................             635
       30.1.2         Locking and Unlocking a Mutex..............................................................                 635
       30.1.3         Performance of Mutexes ........................................................................             638
       30.1.4         Mutex Deadlocks ..................................................................................          639
       30.1.5         Dynamically Initializing a Mutex .............................................................              639
       30.1.6         Mutex Attributes....................................................................................        640
       30.1.7         Mutex Types.........................................................................................        640
0.2  Signaling Changes of State: Condition Variables ..........................................................                   642
       30.2.1         Statically Allocated Condition Variables ..................................................                 643
       30.2.2         Signaling and Waiting on Condition Variables ........................................                       643
       30.2.3         Testing a Condition Variable’s Predicate..................................................                  647
       30.2.4         Example Program: Joining Any Terminated Thread....................................                          648
       30.2.5         Dynamically Allocated Condition Variables..............................................                     651
0.3  Summary..................................................................................................................    652
0.4  Exercises .................................................................................................................. 652
1    T H REA DS : T H R E A D S A F E T Y A N D P E R- T H R E A D S T O RA GE                                                   65 5
1.1  Thread Safety (and Reentrancy Revisited) .....................................................................               655
1.2  One-Time Initialization ...............................................................................................      658
1.3  Thread-Specific Data..................................................................................................       659
       31.3.1         Thread-Specific Data from the Library Function’s Perspective ......................                         660
       31.3.2         Overview of the Thread-Specific Data API ................................................                   660
       31.3.3         Details of the Thread-Specific Data API ....................................................                661
       31.3.4         Employing the Thread-Specific Data API ..................................................                   663
       31.3.5         Thread-Specific Data Implementation Limits ..............................................                   668
1.4  Thread-Local Storage .................................................................................................       668
1.5  Summary..................................................................................................................    669
1.6  Exercises .................................................................................................................. 670
2    T H REA DS : THR E A D C A NCE L L A T I O N                                                                               67 1
2.1  Canceling a Thread...................................................................................................        671
2.2  Cancellation State and Type .......................................................................................          672
2.3  Cancellation Points ....................................................................................................     673
2.4  Testing for Thread Cancellation...................................................................................           675
2.5  Cleanup Handlers .....................................................................................................       676
2.6  Asynchronous Cancelability........................................................................................           680
2.7  Summary..................................................................................................................    680
3    T H REA DS : F U R TH E R D E T A I L S                                                                                     68 1
3.1  Thread Stacks ...........................................................................................................    681
3.2  Threads and Signals ..................................................................................................       682
       33.2.1         How the UNIX Signal Model Maps to Threads .........................................                         682
       33.2.2         Manipulating the Thread Signal Mask .....................................................                   684
       33.2.3         Sending a Signal to a Thread.................................................................               684
       33.2.4         Dealing with Asynchronous Signals Sanely ..............................................                     685
                                                                                                                           Contents i n D etai l xix
3.5   Linux Implementations of POSIX Threads ......................................................................                689
         33.5.1          LinuxThreads ........................................................................................     689
         33.5.2          NPTL ...................................................................................................  692
         33.5.3          Which Threading Implementation?..........................................................                 694
3.6   Advanced Features of the Pthreads API ........................................................................               696
3.7   Summary..................................................................................................................    696
3.8   Exercises .................................................................................................................. 697
4     PROCESS GROUPS, SESS IONS, AND JOB CONTROL                                                                                 69 9
4.1   Overview .................................................................................................................   699
4.2   Process Groups .........................................................................................................     701
4.3   Sessions ................................................................................................................... 704
4.4   Controlling Terminals and Controlling Processes............................................................                  706
4.5   Foreground and Background Process Groups ...............................................................                     708
4.6   The SIGHUP Signal......................................................................................................      709
         34.6.1          Handling of SIGHUP by the Shell ..............................................................            710
         34.6.2          SIGHUP and Termination of the Controlling Process.....................................                    712
4.7   Job Control...............................................................................................................   714
         34.7.1          Using Job Control Within the Shell ..........................................................             714
         34.7.2          Implementing Job Control.......................................................................           717
         34.7.3          Handling Job-Control Signals .................................................................            722
         34.7.4          Orphaned Process Groups (and SIGHUP Revisited) .....................................                      725
4.8   Summary..................................................................................................................    730
4.9   Exercises .................................................................................................................. 731
5     PROCESS PRIORI TIES A ND S CHEDULING                                                                                       733
5.1   Process Priorities (Nice Values) ...................................................................................         733
5.2   Overview of Realtime Process Scheduling.....................................................................                 737
         35.2.1          The SCHED_RR Policy ...............................................................................       739
         35.2.2          The SCHED_FIFO Policy ............................................................................        740
         35.2.3          The SCHED_BATCH and SCHED_IDLE Policies..................................................                 740
5.3   Realtime Process Scheduling API .................................................................................            740
         35.3.1          Realtime Priority Ranges ........................................................................         740
         35.3.2          Modifying and Retrieving Policies and Priorities........................................                  741
         35.3.3          Relinquishing the CPU ...........................................................................         747
         35.3.4          The SCHED_RR Time Slice .........................................................................         747
5.4   CPU Affinity..............................................................................................................   748
5.5   Summary..................................................................................................................    751
5.6   Exercises .................................................................................................................. 751
6     PROC E S S R E S OU RC E S                                                                                                 75 3
6.1   Process Resource Usage .............................................................................................         753
6.2   Process Resource Limits ..............................................................................................       755
6.3   Details of Specific Resource Limits ...............................................................................          760
6.4   Summary..................................................................................................................    765
6.5   Exercises .................................................................................................................. 765
7     D A E M O NS                                                                                                               76 7
7.1   Overview ................................................................................................................. 767
7.2   Creating a Daemon ................................................................................................... 768
x   Co ntents i n Detail
7.5  Logging Messages and Errors Using syslog ...................................................................                 775
        37.5.1        Overview.............................................................................................       775
        37.5.2        The syslog API .......................................................................................      777
        37.5.3        The /etc/syslog.conf File ......................................................................            781
7.6  Summary..................................................................................................................    782
7.7  Exercise ................................................................................................................... 782
8    WRITING SECURE PRIVILEGED PROGRAMS                                                                                         783
8.1  Is a Set-User-ID or Set-Group-ID Program Required? .......................................................                   784
8.2  Operate with Least Privilege .......................................................................................         784
8.3  Be Careful When Executing a Program ........................................................................                 787
8.4  Avoid Exposing Sensitive Information...........................................................................              788
8.5  Confine the Process ...................................................................................................      789
8.6  Beware of Signals and Race Conditions.......................................................................                 790
8.7  Pitfalls When Performing File Operations and File I/O ...................................................                    790
8.8  Don’t Trust Inputs or the Environment............................................................................            791
8.9  Beware of Buffer Overruns .........................................................................................          792
8.10 Beware of Denial-of-Service Attacks .............................................................................            793
8.11 Check Return Statuses and Fail Safely ..........................................................................             794
8.12 Summary..................................................................................................................    795
8.13 Exercises .................................................................................................................. 796
9    CAPABILITIES                                                                                                               79 7
9.1  Rationale for Capabilities ...........................................................................................       797
9.2  The Linux Capabilities ................................................................................................      798
9.3  Process and File Capabilities ......................................................................................         798
        39.3.1        Process Capabilities ..............................................................................         798
        39.3.2        File Capabilities....................................................................................       799
        39.3.3        Purpose of the Process Permitted and Effective Capability Sets....................                          802
        39.3.4        Purpose of the File Permitted and Effective Capability Sets .........................                       802
        39.3.5        Purpose of the Process and File Inheritable Sets ........................................                   802
        39.3.6        Assigning and Viewing File Capabilities from the Shell..............................                        803
9.4 The Modern Capabilities Implementation......................................................................                  804
9.5 Transformation of Process Capabilities During exec() ......................................................                   805
        39.5.1        Capability Bounding Set ........................................................................            805
        39.5.2        Preserving root Semantics ......................................................................            806
9.6 Effect on Process Capabilities of Changing User IDs ......................................................                    806
9.7 Changing Process Capabilities Programmatically ..........................................................                     807
9.8 Creating Capabilities-Only Environments......................................................................                 811
9.9 Discovering the Capabilities Required by a Program......................................................                      813
9.10 Older Kernels and Systems Without File Capabilities .....................................................                    814
9.11 Summary..................................................................................................................    816
9.12 Exercise ................................................................................................................... 816
0    L O GIN A C C O U NT I N G                                                                                                 81 7
0.1  Overview of the utmp and wtmp Files ............................................................................             817
0.2  The utmpx API ..........................................................................................................     818
0.3  The utmpx Structure ...................................................................................................      818
0.4  Retrieving Information from the utmp and wtmp Files ........................................................                 821
0.5  Retrieving the Login Name: getlogin() ..........................................................................             825
0.6  Updating the utmp and wtmp Files for a Login Session .....................................................                   825
                                                                                                                           Contents i n D etai l xxi
0.9   Exercises .................................................................................................................. 832
1     F UNDAMENTALS OF SHARED LIBRARIE S                                                                                             833
1.1   Object Libraries ........................................................................................................        833
1.2   Static Libraries ..........................................................................................................      834
1.3   Overview of Shared Libraries......................................................................................               836
1.4   Creating and Using Shared Libraries—A First Pass ........................................................                        837
          41.4.1                    Creating a Shared Library......................................................................    837
          41.4.2                    Position-Independent Code.....................................................................     838
          41.4.3                    Using a Shared Library..........................................................................   839
          41.4.4                    The Shared Library Soname ...................................................................      840
1.5   Useful Tools for Working with Shared Libraries .............................................................                     843
1.6   Shared Library Versions and Naming Conventions ........................................................                          844
1.7   Installing Shared Libraries ..........................................................................................           847
1.8   Compatible Versus Incompatible Libraries.....................................................................                    850
1.9   Upgrading Shared Libraries........................................................................................               850
1.10  Specifying Library Search Directories in an Object File ..................................................                       851
1.11  Finding Shared Libraries at Run Time ...........................................................................                 854
1.12  Run-Time Symbol Resolution ........................................................................................              854
1.13  Using a Static Library Instead of a Shared Library .........................................................                     856
1.14  Summary..................................................................................................................        856
1.15  Exercise ...................................................................................................................     857
2     ADVANCED FE ATURES OF SHARED LIBRARIES                                                                                         859
2.1   Dynamically Loaded Libraries .....................................................................................               859
          42.1.1                    Opening a Shared Library: dlopen() ........................................................        860
          42.1.2                    Diagnosing Errors: dlerror() ...................................................................   862
          42.1.3                    Obtaining the Address of a Symbol: dlsym() ............................................            862
          42.1.4                    Closing a Shared Library: dlclose() ..........................................................     866
          42.1.5                    Obtaining Information About Loaded Symbols: dladdr() ............................                  866
          42.1.6                    Accessing Symbols in the Main Program..................................................            867
2.2   Controlling Symbol Visibility .......................................................................................            867
2.3   Linker Version Scripts .................................................................................................         868
          42.3.1                    Controlling Symbol Visibility with Version Scripts ......................................          868
          42.3.2                    Symbol Versioning ................................................................................ 870
2.4   Initialization and Finalization Functions ........................................................................               872
2.5   Preloading Shared Libraries........................................................................................              873
2.6   Monitoring the Dynamic Linker: LD_DEBUG......................................................................                    874
2.7   Summary..................................................................................................................        875
2.8   Exercises ..................................................................................................................     876
3     INTERPROCESS COMMUN ICATION OVERVIEW                                                                                           877
3.1   A Taxonomy of IPC Facilities ......................................................................................              877
3.2   Communication Facilities............................................................................................             879
3.3   Synchronization Facilities ...........................................................................................           880
3.4   Comparing IPC Facilities ............................................................................................            882
3.5   Summary..................................................................................................................        887
3.6   Exercises ..................................................................................................................     887
xii  C o n t e n ts i n D e t a i l
4.2  Creating and Using Pipes...........................................................................................            892
4.3  Pipes as a Method of Process Synchronization ..............................................................                    897
4.4  Using Pipes to Connect Filters .....................................................................................           899
4.5  Talking to a Shell Command via a Pipe: popen() ...........................................................                     902
4.6  Pipes and stdio Buffering ............................................................................................         906
4.7  FIFOs.......................................................................................................................   906
4.8  A Client-Server Application Using FIFOs.......................................................................                 909
4.9  Nonblocking I/O ......................................................................................................         915
4.10 Semantics of read() and write() on Pipes and FIFOs.......................................................                      917
4.11 Summary..................................................................................................................      918
4.12 Exercises ..................................................................................................................   919
5    IN T RODUCTIO N TO SYST EM V IPC                                                                                             92 1
5.1  API Overview ...........................................................................................................       922
5.2  IPC Keys ..................................................................................................................    925
5.3  Associated Data Structure and Object Permissions.........................................................                      927
5.4  IPC Identifiers and Client-Server Applications ................................................................                929
5.5  Algorithm Employed by System V IPC get Calls..............................................................                     931
5.6  The ipcs and ipcrm Commands ...................................................................................                934
5.7  Obtaining a List of All IPC Objects ..............................................................................             935
5.8  IPC Limits .................................................................................................................   935
5.9  Summary..................................................................................................................      936
5.10 Exercises ..................................................................................................................   936
6    SYSTEM V MESSAGE QUEUES                                                                                                      93 7
6.1  Creating or Opening a Message Queue ......................................................................                     938
6.2  Exchanging Messages ...............................................................................................            940
       46.2.1         Sending Messages................................................................................              940
       46.2.2         Receiving Messages ..............................................................................             943
6.3 Message Queue Control Operations............................................................................                    947
6.4 Message Queue Associated Data Structure ..................................................................                      948
6.5 Message Queue Limits ...............................................................................................            950
6.6 Displaying All Message Queues on the System .............................................................                       951
6.7 Client-Server Programming with Message Queues .........................................................                         953
6.8 A File-Server Application Using Message Queues..........................................................                        955
6.9 Disadvantages of System V Message Queues ...............................................................                        961
6.10 Summary..................................................................................................................      962
6.11 Exercises ..................................................................................................................   963
7    SYSTEM V SEMAPHORES                                                                                                          96 5
7.1  Overview .................................................................................................................     966
7.2  Creating or Opening a Semaphore Set ........................................................................                   969
7.3  Semaphore Control Operations...................................................................................                969
7.4  Semaphore Associated Data Structure..........................................................................                  972
7.5  Semaphore Initialization.............................................................................................          975
7.6  Semaphore Operations ..............................................................................................            978
7.7  Handling of Multiple Blocked Semaphore Operations ....................................................                         986
7.8  Semaphore Undo Values............................................................................................              986
7.9  Implementing a Binary Semaphores Protocol.................................................................                     988
                                                                                                                          C on t e n t s i n D e t a i l xxiii
7.12 Summary..................................................................................................................    993
7.13 Exercises .................................................................................................................. 994
8    SYS T E M V S H A R E D M E M OR Y                                                                                          99 7
8.1  Overview ................................................................................................................. 998
8.2  Creating or Opening a Shared Memory Segment ......................................................... 998
8.3  Using Shared Memory ............................................................................................... 999
8.4  Example: Transferring Data via Shared Memory ......................................................... 1001
8.5  Location of Shared Memory in Virtual Memory............................................................ 1006
8.6  Storing Pointers in Shared Memory............................................................................ 1010
8.7  Shared Memory Control Operations .......................................................................... 1011
8.8  Shared Memory Associated Data Structure ................................................................. 1012
8.9  Shared Memory Limits.............................................................................................. 1014
8.10 Summary................................................................................................................ 1015
8.11 Exercises ................................................................................................................ 1016
9    ME MORY MAPPINGS                                                                                                         1017
9.1  Overview ...............................................................................................................   1017
9.2  Creating a Mapping: mmap() ...................................................................................             1020
9.3  Unmapping a Mapped Region: munmap() .................................................................                      1023
9.4  File Mappings.........................................................................................................     1024
        49.4.1          Private File Mappings..........................................................................         1024
        49.4.2          Shared File Mappings .........................................................................          1025
        49.4.3          Boundary Cases .................................................................................        1029
        49.4.4          Memory Protection and File Access Mode Interactions.............................                        1030
9.5  Synchronizing a Mapped Region: msync() .................................................................                   1031
9.6  Additional mmap() Flags..........................................................................................          1033
9.7  Anonymous Mappings .............................................................................................           1034
9.8  Remapping a Mapped Region: mremap()...................................................................                     1037
9.9  MAP_NORESERVE and Swap Space Overcommitting ........................................................                       1038
9.10 The MAP_FIXED Flag ..................................................................................................      1040
9.11 Nonlinear Mappings: remap_file_pages() ...................................................................                 1041
9.12 Summary................................................................................................................    1043
9.13 Exercises ................................................................................................................ 1044
0    V I R TU A L M E M O R Y O P E RA T I O N S                                                                              1 04 5
0.1  Changing Memory Protection: mprotect() ...................................................................                 1045
0.2  Memory Locking: mlock() and mlockall() ....................................................................                1047
0.3  Determining Memory Residence: mincore() .................................................................                  1051
0.4  Advising Future Memory Usage Patterns: madvise() .....................................................                     1054
0.5  Summary................................................................................................................    1056
0.6  Exercises ................................................................................................................ 1056
1    I N T RO D U C TIO N TO P O S I X I P C                                                                                  1 05 7
1.1  API Overview ......................................................................................................... 1058
1.2  Comparison of System V IPC and POSIX IPC .............................................................. 1061
1.3  Summary................................................................................................................ 1062
xiv  Co ntents i n Detail
2.2  Opening, Closing, and Unlinking a Message Queue ...................................................                         1064
2.3  Relationship Between Descriptors and Message Queues ..............................................                          1067
2.4  Message Queue Attributes........................................................................................            1068
2.5  Exchanging Messages .............................................................................................           1073
        52.5.1        Sending Messages..............................................................................             1073
        52.5.2        Receiving Messages ............................................................................            1074
        52.5.3        Sending and Receiving Messages with a Timeout ...................................                          1077
2.6 Message Notification...............................................................................................          1077
        52.6.1        Receiving Notification via a Signal .......................................................                1079
        52.6.2        Receiving Notification via a Thread ......................................................                 1082
2.7 Linux-Specific Features .............................................................................................        1083
2.8 Message Queue Limits .............................................................................................           1085
2.9 Comparison of POSIX and System V Message Queues ................................................                             1086
2.10 Summary................................................................................................................     1087
2.11 Exercises ................................................................................................................  1087
3    POSIX SEMAPHORES                                                                                                         1 08 9
3.1  Overview ...............................................................................................................    1089
3.2  Named Semaphores................................................................................................            1090
        53.2.1        Opening a Named Semaphore ............................................................                     1090
        53.2.2        Closing a Semaphore..........................................................................              1093
        53.2.3        Removing a Named Semaphore ...........................................................                     1093
3.3  Semaphore Operations ............................................................................................           1094
        53.3.1        Waiting on a Semaphore ....................................................................                1094
        53.3.2        Posting a Semaphore ..........................................................................             1096
        53.3.3        Retrieving the Current Value of a Semaphore .........................................                      1097
3.4  Unnamed Semaphores.............................................................................................             1099
        53.4.1        Initializing an Unnamed Semaphore .....................................................                    1100
        53.4.2        Destroying an Unnamed Semaphore .....................................................                      1102
3.5  Comparisons with Other Synchronization Techniques ..................................................                        1103
3.6  Semaphore Limits ....................................................................................................       1104
3.7  Summary................................................................................................................     1105
3.8  Exercises ................................................................................................................  1105
4    P O S I X S H A RE D M E M O R Y                                                                                         1 10 7
4.1  Overview ...............................................................................................................    1108
4.2  Creating Shared Memory Objects .............................................................................                1109
4.3  Using Shared Memory Objects .................................................................................               1112
4.4  Removing Shared Memory Objects............................................................................                  1114
4.5  Comparisons Between Shared Memory APIs...............................................................                       1115
4.6  Summary................................................................................................................     1116
4.7  Exercise .................................................................................................................  1116
5    F I L E L O C KI NG                                                                                                      1 11 7
5.1  Overview ...............................................................................................................    1117
5.2  File Locking with flock() ............................................................................................      1119
        55.2.1        Semantics of Lock Inheritance and Release.............................................                     1122
        55.2.2        Limitations of flock() ............................................................................        1123
                                                                                                                          C o n te n t s i n D e t a i l xxv
       55.3.2          Example: An Interactive Locking Program...............................................                   1129
       55.3.3          Example: A Library of Locking Functions ................................................                 1133
       55.3.4          Lock Limits and Performance.................................................................             1135
       55.3.5          Semantics of Lock Inheritance and Release.............................................                   1136
       55.3.6          Lock Starvation and Priority of Queued Lock Requests..............................                       1137
5.4 Mandatory Locking..................................................................................................         1137
5.5 The /proc/locks File ................................................................................................       1140
5.6 Running Just One Instance of a Program.....................................................................                 1142
5.7 Older Locking Techniques ........................................................................................           1144
5.8 Summary................................................................................................................     1146
5.9 Exercises ................................................................................................................  1147
6   S O C K E T S: I N TR O D U C TIO N                                                                                       1 14 9
6.1 Overview ...............................................................................................................    1150
6.2 Creating a Socket: socket() .......................................................................................         1153
6.3 Binding a Socket to an Address: bind() ......................................................................               1153
6.4 Generic Socket Address Structures: struct sockaddr ......................................................                   1154
6.5 Stream Sockets........................................................................................................      1155
       56.5.1          Listening for Incoming Connections: listen() ............................................                1156
       56.5.2          Accepting a Connection: accept() ..........................................................              1157
       56.5.3          Connecting to a Peer Socket: connect() ..................................................                1158
       56.5.4          I/O on Stream Sockets ........................................................................           1159
       56.5.5          Connection Termination: close() ............................................................             1159
6.6 Datagram Sockets ...................................................................................................        1159
       56.6.1          Exchanging Datagrams: recvfrom() and sendto() .....................................                      1160
       56.6.2          Using connect() with Datagram Sockets .................................................                  1162
6.7 Summary................................................................................................................     1162
7   S O C K E T S: U N I X D O M A I N                                                                                        1 16 5
7.1 UNIX Domain Socket Addresses: struct sockaddr_un ....................................................                       1165
7.2 Stream Sockets in the UNIX Domain ..........................................................................                1167
7.3 Datagram Sockets in the UNIX Domain ......................................................................                  1171
7.4 UNIX Domain Socket Permissions ..............................................................................               1174
7.5 Creating a Connected Socket Pair: socketpair() ...........................................................                  1174
7.6 The Linux Abstract Socket Namespace .......................................................................                 1175
7.7 Summary................................................................................................................     1176
7.8 Exercises ................................................................................................................  1177
8   S O C K E T S: F U N D A M E N T A L S O F TC P /I P NE TWO RK S                                                          1 17 9
8.1 Internets ................................................................................................................. 1179
8.2 Networking Protocols and Layers ..............................................................................              1180
8.3 The Data-Link Layer..................................................................................................       1182
8.4 The Network Layer: IP ..............................................................................................        1184
8.5 IP Addresses ...........................................................................................................    1186
8.6 The Transport Layer .................................................................................................       1188
       58.6.1          Port Numbers .....................................................................................       1188
       58.6.2          User Datagram Protocol (UDP)..............................................................               1189
       58.6.3          Transmission Control Protocol (TCP).......................................................               1190
8.7 Requests for Comments (RFCs) ..................................................................................             1193
8.8 Summary................................................................................................................     1195
xvi Co ntents i n Detail
9.2  Network Byte Order ................................................................................................        1198
9.3  Data Representation ................................................................................................       1199
9.4  Internet Socket Addresses .........................................................................................        1202
9.5  Overview of Host and Service Conversion Functions....................................................                      1204
9.6  The inet_pton() and inet_ntop() Functions ..................................................................               1206
9.7  Client-Server Example (Datagram Sockets)..................................................................                 1207
9.8  Domain Name System (DNS)....................................................................................               1209
9.9  The /etc/services File .............................................................................................       1212
9.10 Protocol-Independent Host and Service Conversion......................................................                     1213
        59.10.1       The getaddrinfo() Function....................................................................            1213
        59.10.2       Freeing addrinfo Lists: freeaddrinfo() .....................................................              1217
        59.10.3       Diagnosing Errors: gai_strerror() ...........................................................             1217
        59.10.4       The getnameinfo() Function...................................................................             1218
9.11 Client-Server Example (Stream Sockets) ......................................................................              1219
9.12 An Internet Domain Sockets Library ...........................................................................             1225
9.13 Obsolete APIs for Host and Service Conversions .........................................................                   1230
        59.13.1       The inet_aton() and inet_ntoa() Functions ..............................................                  1230
        59.13.2       The gethostbyname() and gethostbyaddr() Functions ..................................                      1231
        59.13.3       The getservbyname() and getservbyport() Functions ...................................                     1234
9.14 UNIX Versus Internet Domain Sockets ........................................................................               1235
9.15 Further Information ..................................................................................................     1235
9.16 Summary................................................................................................................    1236
9.17 Exercises ................................................................................................................ 1236
0    S O C K E T S: S E R VE R D E S I G N                                                                                    1 23 9
0.1  Iterative and Concurrent Servers................................................................................           1239
0.2  An Iterative UDP echo Server .....................................................................................         1240
0.3  A Concurrent TCP echo Server ...................................................................................           1243
0.4  Other Concurrent Server Designs ..............................................................................             1245
0.5  The inetd (Internet Superserver) Daemon ....................................................................               1247
0.6  Summary................................................................................................................    1252
0.7  Exercises ................................................................................................................ 1252
1    SOCKETS: ADVANCED TOPICS                                                                                                 1253
1.1  Partial Reads and Writes on Stream Sockets ...............................................................                 1254
1.2  The shutdown() System Call ......................................................................................          1256
1.3  Socket-Specific I/O System Calls: recv() and send() .....................................................                  1259
1.4  The sendfile() System Call.........................................................................................        1260
1.5  Retrieving Socket Addresses .....................................................................................          1263
1.6  A Closer Look at TCP ...............................................................................................       1266
        61.6.1        Format of a TCP Segment.....................................................................              1266
        61.6.2        TCP Sequence Numbers and Acknowledgements....................................                             1268
        61.6.3        TCP State Machine and State Transition Diagram ...................................                        1269
        61.6.4        TCP Connection Establishment ..............................................................               1270
        61.6.5        TCP Connection Termination ................................................................               1272
        61.6.6        Calling shutdown() on a TCP Socket......................................................                  1273
        61.6.7        The TIME_WAIT State..........................................................................             1274
1.7 Monitoring Sockets: netstat .......................................................................................         1275
1.8 Using tcpdump to Monitor TCP Traffic ........................................................................               1276
1.9 Socket Options .......................................................................................................      1278
1.10 The SO_REUSEADDR Socket Option................................................................................             1279
1.11 Inheritance of Flags and Options Across accept() .........................................................                 1281
                                                                                                                         Contents i n D e ta i l xxvii
         61.13.1                 Out-of-Band Data ................................................................................   1283
         61.13.2                 The sendmsg() and recvmsg() System Calls..............................................              1284
         61.13.3                 Passing File Descriptors .......................................................................    1284
         61.13.4                 Receiving Sender Credentials ...............................................................        1284
         61.13.5                 Sequenced-Packet Sockets....................................................................        1285
         61.13.6                 SCTP and DCCP Transport-Layer Protocols .............................................               1285
1.14 Summary................................................................................................................         1286
1.15 Exercises ................................................................................................................      1287
2     T E RM I NA L S                                                                                                              1 28 9
2.1   Overview ...............................................................................................................       1290
2.2   Retrieving and Modifying Terminal Attributes ..............................................................                    1291
2.3   The stty Command...................................................................................................            1294
2.4   Terminal Special Characters .....................................................................................              1296
2.5   Terminal Flags ........................................................................................................        1301
2.6   Terminal I/O Modes................................................................................................             1307
         62.6.1                  Canonical Mode.................................................................................     1307
         62.6.2                  Noncanonical Mode ...........................................................................       1307
         62.6.3                  Cooked, Cbreak, and Raw Modes........................................................               1309
2.7 Terminal Line Speed (Bit Rate) ...................................................................................               1316
2.8 Terminal Line Control ...............................................................................................            1317
2.9 Terminal Window Size ............................................................................................                1319
2.10 Terminal Identification..............................................................................................           1321
2.11 Summary................................................................................................................         1322
2.12 Exercises ................................................................................................................      1323
3     A L TER N A TI V E I /O M O D E L S                                                                                          1 32 5
3.1   Overview ...............................................................................................................       1325
         63.1.1                  Level-Triggered and Edge-Triggered Notification.....................................                1329
         63.1.2                  Employing Nonblocking I/O with Alternative I/O Models .......................                       1330
3.2   I/O Multiplexing .....................................................................................................         1330
         63.2.1                  The select() System Call........................................................................    1331
         63.2.2                  The poll() System Call .........................................................................    1337
         63.2.3                  When Is a File Descriptor Ready? .........................................................          1341
         63.2.4                  Comparison of select() and poll() ..........................................................        1344
         63.2.5                  Problems with select() and poll()............................................................       1346
3.3   Signal-Driven I/O....................................................................................................          1346
         63.3.1                  When Is “I/O Possible” Signaled? ........................................................           1351
         63.3.2                  Refining the Use of Signal-Driven I/O....................................................           1352
3.4   The epoll API...........................................................................................................       1355
         63.4.1                  Creating an epoll Instance: epoll_create() ...............................................          1356
         63.4.2                  Modifying the epoll Interest List: epoll_ctl() .............................................        1356
         63.4.3                  Waiting for Events: epoll_wait() ............................................................       1358
         63.4.4                  A Closer Look at epoll Semantics ..........................................................         1363
         63.4.5                  Performance of epoll Versus I/O Multiplexing.........................................               1365
         63.4.6                  Edge-Triggered Notification .................................................................       1366
3.5   Waiting on Signals and File Descriptors.....................................................................                   1368
         63.5.1                  The pselect() System Call ......................................................................    1369
         63.5.2                  The Self-Pipe Trick ............................................................................... 1370
3.6   Summary................................................................................................................        1373
3.7   Exercises ................................................................................................................     1374
xviii  C o n t e n ts i n D e t a i l
4.2  UNIX 98 Pseudoterminals.........................................................................................             1380
       64.2.1         Opening an Unused Master: posix_openpt() ...........................................                        1380
       64.2.2         Changing Slave Ownership and Permissions: grantpt() ...........................                             1381
       64.2.3         Unlocking the Slave: unlockpt() ............................................................                1382
       64.2.4         Obtaining the Name of the Slave: ptsname() ..........................................                       1382
4.3 Opening a Master: ptyMasterOpen() .........................................................................                   1383
4.4 Connecting Processes with a Pseudoterminal: ptyFork() ................................................                        1385
4.5 Pseudoterminal I/O .................................................................................................          1388
4.6 Implementing script(1) .............................................................................................          1390
4.7 Terminal Attributes and Window Size ........................................................................                  1394
4.8 BSD Pseudoterminals ...............................................................................................           1395
4.9 Summary................................................................................................................       1397
4.10 Exercises ................................................................................................................   1398
 
* linux 编程 [ 系统调用 ,调用检查]
** c 库  
   /lib32/libc.so.6
   
   显示 c 库路径 
   $ ldd myprog | grep libc

   
   显示链接的库
   #include <gnu/libc-version.h>
   const char *gnu_get_libc_version(void);
** error
*** perror
      void perror(const char *msg);
#+begin_src c
  fd = open(pathname, flags, mode);
  if (fd == -1) {
      perror("open");
      exit(EXIT_FAILURE);
  }
#+end_src
*** strerror
* source code[[file:~/downcode/tlpi-dist/][source]] 
* 库
** sys/types.h 
** stdlib.h [ 标准库定义的常量,函数 ]
   EXIT_SUCCESS 
   EXIT_FAILURE
** unistd.h [ 系统调用 ] 
** errno.h
** string.h
