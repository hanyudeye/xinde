* docker 轻量级虚拟化技术
  不像一般项目，在不同系统要编译，这个就像java程序一样，在全平台都能运行
 [[file:image/dockermoshi.png][流程]] 
  一次构建，各平台运行
** docker 组件构成
*** docker 客户端和服务器 [[file:image/docker][结构]]
*** docker 镜像, 相当于另一种形式的源码
    Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 
    允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，
    比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新 的层被添加或升级了。
    现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。
*** registry（库） 免费库  Docker Hub
*** Docker 容器 [[file:image/docker1.png][关系图]] 
    Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。
    每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。
*** 基本概念
    1.5 命名空间「Namespaces」
pid namespace
不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:

每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)
每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程
因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程
因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid
参考文档：Introduction to Linux namespaces – Part 3: PID

mnt namespace
类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。

net namespace
网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。

参考文档：Introduction to Linux namespaces – Part 5: NET

uts namespace
UTS ("UNIX Time-sharing System") namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。

参考文档：Introduction to Linux namespaces – Part 1: UTS

ipc namespace
container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。

参考文档：Introduction to Linux namespaces – Part 2: IPC

user namespace
每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。

有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。

Reference
Docker Getting Start: Related Knowledge
Docker 介绍以及其相关术语、底层原理和技术
1.6 资源配额「cgroups」
cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。

memory
内存相关的限制
cpu
在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值
blkio
block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO
devices
设备权限限制
参考文档：how to use cgroup
** 安装
*** 先决 64为cpu 
   更新下 
   apt install linux-head-generic linux-image-genric linux-head
   sudo update-grub
   sudo reboot
   
   检查device-mapper sudo grep device-mapper /proc/devices
   安装device-mapper sudo modprobe dm_mod
*** 监听地址
    
    sudo docker -d -H unix://home/docker/docker.sock
    sudo docker -d -H tcp:0.0.0.0:2375 所有接口
    检查是否运行 sudo service docker status/start/stop 
*** 获取版本
    docker version
** 运行
** docker 镜像和仓库
*** Search images
    查找镜像 $ sudo docker search ubuntu
   $ sudo docker search -s 100 ubuntu # 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像
*** 信息显示
   docker info
*** 列出镜像
   $ sudo docker images -a # 显示当前系统所有镜像，包括过渡层镜像 
   $ sudo docker images ubuntu # 显示当前系统 docker ubuntu 库中的所有镜像
*** Pull images
   拉取镜像 $ sudo docker pull ubuntu # 获取 ubuntu 官方镜像 
  列出镜像  $ sudo docker images # 查看当前镜像列表 
*** Running an interactive shell
    $ sudo docker run -i -t ubuntu:14.04 /bin/bash
    docker run - 运行一个容器
    -t - 分配一个（伪）tty (link is external)
    -i - 交互模式 (so we can interact with it)
    ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04
    /bin/bash - 运行命令 bash shell
    注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]

    $ sudo docker ps # 查看当前运行的容器
    ps -a 列出当前系统所有的容器
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    6c9129e9df10        ubuntu:14.04        /bin/bash 6 minutes ago       Up 6 minutes                            cranky_babbage
*** 相关快捷键
    退出：Ctrl-D
    detach：Ctrl-P + Ctrl-Q
    attach:docker attach CONTAINER-ID
*** 推送镜像   
    $ sudo docker pull ubuntu # 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像 
    $ sudo docker pull ubuntu:14.04 # 下载指定版本 ubuntu 官方镜像 
    $ sudo docker push 192.168.0.100:5000/ubuntu # 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户] 
    $ sudo docker push 192.168.0.100:5000/ubuntu:14.04 # 推送指定镜像到私有源 
*** 构建镜像
   
*** 删除镜像 
    $ sudo docker rmi --help
    Usage: docker rmi IMAGE [IMAGE...] Remove one or more images
    -f, --force=false Force removal of the image # 强制移除镜像不管是否有容器使用该镜像 
    --no-prune=false Do not delete untagged parents # 不要删除未标记的父镜像 
** docker start|stop|kill
   docker start CONTAINER [CONTAINER...]
# 运行一个或多个停止的容器
docker stop CONTAINER [CONTAINER...]
# 停掉一个或多个运行的容器-t选项可指定超时时间
docker kill [OPTIONS] CONTAINER [CONTAINER...]
# 默认 kill 发送 SIGKILL 信号-s可以指定发送 kill 信号类型
docker restart [OPTIONS] CONTAINER [CONTAINER...]
# 重启一个或多个运行的容器-t选项可指定超时时间
docker pause CONTAINER
# 暂停一个容器，方便 commit
docker unpause CONTAINER
# 继续暂停的容器
docker rm [OPTIONS] CONTAINER [CONTAINER...]
# 移除一个或多个容器
-f, --force=false Force removal of running container
-l, --link=false Remove the specified link and not the underlying container
-v, --volumes=false Remove the volumes associated with the container
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
# 提交指定容器为镜像
-a, --author="" Author (e.g., "John Hannibal Smith hannibal@a-team.com")
-m, --message="" Commit message
-p, --pause=true Pause container during commit
# 默认 commit 是暂停状态
docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE...]
# 查看容器或者镜像的详细信息
docker logs CONTAINER
# 输出指定容器日志信息
-f, --follow=false Follow log output
# 类似 tail -f
-t, --timestamps=false Show timestamps
--tail="all" Output the specified number of lines at the end of logs (defaults to all logs)
** 命令
   $ sudo docker   # docker 命令帮助

   Commands:
    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像
    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像
    commit    Create a new image from a container's changes # 提交当前容器为新的镜像
    cp        Copy files/folders from the containers filesystem to the host path
              # 从容器中拷贝指定文件或者目录到宿主机中
    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器
    diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化
    events    Get real time events from the server          # 从 docker 服务获取容器实时事件
    exec      Run a command in an existing container        # 在已存在的容器上运行命令
    export    Stream the contents of a container as a tar archive   
              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]
    history   Show the history of an image                  # 展示一个镜像形成历史
    images    List images                                   # 列出系统当前镜像
    import    Create a new filesystem image from the contents of a tarball  
              # 从tar包中的内容创建一个新的文件系统映像[对应 export]
    info      Display system-wide information               # 显示系统相关信息
    inspect   Return low-level information on a container   # 查看容器详细信息
    kill      Kill a running container                      # kill 指定 docker 容器
    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]
    login     Register or Login to the docker registry server   
              # 注册或者登陆一个 docker 源服务器
    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出
    logs      Fetch the logs of a container                 # 输出当前容器日志信息
    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT
              # 查看映射端口对应的容器内部源端口
    pause     Pause all processes within a container        # 暂停容器
    ps        List containers                               # 列出容器列表
    pull      Pull an image or a repository from the docker registry server
              # 从docker镜像源服务器拉取指定镜像或者库镜像
    push      Push an image or a repository to the docker registry server
              # 推送指定镜像或者库镜像至docker源服务器
    restart   Restart a running container                   # 重启运行的容器
    rm        Remove one or more containers                 # 移除一个或者多个容器
    rmi       Remove one or more images                 
              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]
    run       Run a command in a new container
              # 创建一个新的容器并运行一个命令
    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]
    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像
    start     Start a stopped containers                    # 启动容器
    stop      Stop a running containers                     # 停止容器
    tag       Tag an image into a repository                # 给源中镜像打标签
    top       Lookup the running processes of a container   # 查看容器中运行的进程信息
    unpause   Unpause a paused container                    # 取消暂停容器
    version   Show the docker version information           # 查看 docker 版本号
    wait      Block until a container stops, then print its exit code   
              # 截取容器停止时的退出状态值
Run 'docker COMMAND --help' for more information on a command.
** 测试
** 构建服务
*** 构建 jekyll 
*** Java引用程序
*** redis
*** node
** 编配 fig
** 使用api
