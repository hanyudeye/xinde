* Hexo blog framework
** 帮助  https://hexo.io/zh-cn/docs/writing
   创建 hexo new "My New Post"
   hexo s -g #生成并本地预览
   hexo server -p 5000 设定端口
   hexo d -g #生成并上传
** 绑定域名
   域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，
   由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，
   然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，
   这样可以保证无论是否添加www都可以访问
  [[file:image/cname.png][示例]] 
** 配置sshkey
   因为直接用用户名和密码太不安全
   
   检查本机存在的ssh秘钥  存在则有 ~/.ssh 
   生成 ssh-keygen -t rsa -C "邮件地址"
   公钥 复制到 git .ssh\id_rsa.pub
   进入个人设置 -> SSH and GPG keys -> New SSH key
   测试是否成功
   $ ssh -T git@github.com # 注意邮箱地址不用改
   
   此时你还需要配置：
$ git config --global user.name "liuxianan"// 你的github用户名，非昵称
$ git config --global user.email  "xxx@qq.com"// 填写你的github注册邮箱
** 安装
   $ npm install hexo-cli -g
   $ npm install -g hexo
** 创建博客
   $ hexo init blog
   $ cd blog
** 开启服务
   $ hexo server
** Create a new post
   $ hexo new "Hello Hexo"
** Generate static files
   $ hexo generate
** 发布
   hexo d -g #生成并上传
   deploy
** 清理 hexo clean来清理一下public的内容，然后再来重新生成和发布。
** 上传到github
首先，ssh key肯定要配置好。
其次，配置_config.yml中有关deploy的部分：

正确写法：
#+BEGIN_SRC yml
deploy:
  type: git
  repository: git@github.com:liuxianan/liuxianan.github.io.git
  branch: master
#+END_SRC
还需要安装一个插件：
npm install hexo-deployer-git --save

hexo d
** 保留CNAME、README.md等文件
   一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：
   由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。
   保留CNAME、README.md等文件 这一节，
   只要在_config.yml做如下配置就好了：
   skip_render: README.md
** 常用命令
常见命令

hexo new "postName" #新建文章
hexo new page "pageName" #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）
hexo deploy #部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
缩写：

hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
组合命令：

hexo s -g #生成并本地预览
hexo d -g #生成并上传
* 资源文件夹
  资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。
  文章资源文件夹
  对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。

  _config.yml
  post_asset_folder: true
  当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。

  相对路径引用的标签插件
  通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。

  {% asset_path slug %}
  {% asset_img slug [title] %}
  {% asset_link slug [title] %}
  比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）

  正确的引用图片方式是使用下列的标签插件而不是 markdown ：

  {% asset_img example.jpg This is an example image %}
  通过这种方式，图片将会同时出现在文章和主页以及归档页中。
* 插件
** 站长统计 不蒜子 
*** 总计
    文件 /home/wuming/git/web/blog/themes/yilia/layout/_partial/footer.ejs
    添加
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
*** 单页面
    文件    /home/wuming/git/web/blog/themes/yilia/layout/_partial/article.ejs
    添加
    <% if ( !index ){ %>
		<span class="archive-article-date">
		阅读量 <span id="busuanzi_value_page_pv"></span>
		</span>
    <% } %>
* 主题
** NexT 参考 https://notes.iissnan.com/
   文档  https://theme-next.org/docs/getting-started/
*** 安装 
**** 1.下载最新 release 版本
     #+BEGIN_SRC shell
            $ mkdir themes/next
            $ curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1
     #+END_SRC
**** 2.指定branch 使用 git 安装：
     $ git clone --branch v6.0.0 https://github.com/theme-next/hexo-theme-next themes/next
**** 3.下载最新 master 分支
     $ git clone https://github.com/theme-next/hexo-theme-next themes/next
     
#+BEGIN_SRC shell
获取 tags 列表：

$ cd themes/next
$ git tag -l
…
v6.0.0
v6.0.1
v6.0.2
例如，假设你想要切换到 v6.0.1 这一 tag 指向的 release 版本。输入如下指令：

$ git checkout tags/v6.0.1
Note: checking out 'tags/v6.0.1'.
…
HEAD is now at da9cdd2... Release v6.0.1
然后，假设你想要切换回 master 分支，输入如下指令即可：

$ git checkout master
#+END_SRC
**** 完成配置
     在 hexo 根配置文件 _config.yml 中设置你的主题：
     theme: next
*** Hexo的Next主题配置
    使用Next主题
  将下载的代码放在myBlog/next目录下
  设置站点myBlog/_config.yml的theme字段值为next
  生成新页面hexo g
  开启服务hexo s --debug
  发布代码hexo d
  注：此时登录网站，发现是空白的，打开控制台，提示很多vendors目录下的文件404，解决办法是将next主题下即myBlog/themes/next/source下的vendors目录名改为lib，并修改myBlog/themes/next/_config.yml的_internal: vendors改为_internal: lib。

  参考：iissnan的回答

  主题配置
  主题风格设定
  通过修改next主题下的_config.yml的scheme字段，配置不同的风格。

  # Schemes
  scheme: Muse
  #scheme: Mist
  #scheme: Pisces
  本站点使用的是默认的Muse，显示效果如下：



  菜单设置
  通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。

  menu:
    home: /
    categories: /categories
    about: /about
    archives: /archives
    tags: /tags
    #commonweal: /404.html
  其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。

  菜单项文本修改是在对next主题下的language文件夹下的文件进行修改，若当前语言是简体中文，直接修改language/zh-Hans.yml里的对应字段即可。

  本站点显示主页，分类页，关于页面和归档页。

  头像设置
  在主题下的source/images/下放置头像文件avatar.gif即可。

  设置文章代码主题
  Next主题总共支持5种主题，默认主题是白色的normal。通过修改next主题下的_config.yml的highlight字段，来设置代码主题。

  本站点使用的是night主题。即令highlight为night。

  添加标签页面
  前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。

  添加标签页面的具体方法是：

  新建页面
  输入如下命令：

  $ cd myBlog
  $ hexo new page tags
  输入命令后，在myBlog/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件。

  设置页面类型
  在上步新生成的myBlog/source/tags/index.md中添加type: "tags"，index.md文件内容如下：

  ---
  title: tags
  date: 2016-11-15 19:10:05
  type: "tags"
  ---
  设置具体文章的tags
  当要为某一篇文章添加标签，只需在myBlog/source/_post目录下的具体文章的tags中添加标签即可，如：

  ---
  title: 基于Hexo和Github搭建博客
  date: 2016-11-09
  tags: [npm, hexo, github]
  categories: 搭建博客
  ---
  本站添加为标签后的效果如下：



  添加分类页面
  步骤与添加标签页面类似，具体如下：

  新建页面
  输入如下命令：

  $ cd myBlog
  $ hexo new page categories
  输入命令后，在myBlog/source下会新生成一个新的文件夹categories，在该文件夹下会有一个index.md文件。

  设置页面类型
  在上步新生成的myBlog/source/categories/index.md中添加type: "categories"，index.md文件内容如下：

  ---
  title: categories
  date: 2016-11-15 19:11:13
  type: "categories"
  ---
  设置具体文章的categories
  当要为某一篇文章添加分类，只需在myBlog/source/_post目录下的具体文章的categories中添加分类即可，如：

  ---
  title: 基于Hexo和Github搭建博客
  date: 2016-11-09
  tags: [npm, hexo, github]
  categories: 搭建博客
  ---
  本站添加为标签后的效果如下：



  添加关于我页面
  步骤与添加标签页面类似，具体如下：

  新建页面
  $ cd myBlog
  $ hexo new page about
  输入命令后，在myBlog/source下会新生成一个新的文件夹about，在该文件夹下会有一个index.md文件。

  修改about/index.md
  本站点index.md如下：

  ---
  title: about
  date: 2016-11-15 19:08:50
  ---
  ## 关于我

  一只学习前端的小菜鸟，欢迎分享知识。

  From XDU

  QQ：847909475
  Email: 847909475@qq.com
  效果如下：



  引入第三方服务
  加入评论功能
  本站点使用的是多说。加入评论功能的步骤如下：

  登录多说，填写表单，创建站点


  图片中红框圈中的框中内容就是下一步duoshuo_shortname字段的值

  添加duoshuo_shortname
  在站点的myBlog/_config.yml中加入duoshuo_shortname字段，值为第一步红框里的内容

  加入评论后效果如下：



  加入分享功能
  本站点使用的是多说。加入分享功能的步骤如下：

  在站点的myBlog/_config.yml中加入duoshuo_share字段，值为true。

  加入分享后效果如下：


  加入站点内容搜索功能
  本站点使用的是Local Search。加入站点内容搜索功能步骤如下：

  安装hexo-generator-searchdb
  $ npm install hexo-generator-searchdb --save
  注意：安装时应在站点根目录下，即myBlog目录下

  添加search字段
  在站点myBlog/_config.yml中添加search字段，如下：

  search:
    path: search.xml
    field: post
    format: html
    limit: 10000
  效果如下：



  加入数据统计与分析功能
  本站点使用的是百度统计。加入数据统计与分析功能步骤如下：

  注册站长账号并登陆
  在这里注册站长账号，并填写信息，网站域名和网站首页以下图为例来填写，注册完成后并登陆。


  在跳转的页面中会显示下图，复制hm.js后的id值


  添加baidu_analytics字段

  在站点myBlog/_config.yml中添加search字段，值为上步复制的id值

  至此，该功能已成功加入，大约过20min后在百度统计上可以看到站点的访问情况，如下图：

*** 提交合并请求

提交合并请求前，请再次确认您已经查看了[你需要了解的](#before-submitting-an-issue)内容，避免提交重复的合并请求。确定相关仓库后，创建合并请求。更多详细操作过程可以查看[帮助文档](https://help.github.com/articles/creating-a-pull-request/)。

1. 进入 [hexo-theme-next](https://github.com/theme-next/hexo-theme-next) 源仓库，点击`Fork`。
2. 进入到已经`Fork`的个人仓库（`https://github.com/username/hexo-theme-next`），点击 **Clone or download** 并复制该仓库地址。选择本地文件夹，并打开 Git Bash ，输入如下命令并回车，即可完成仓库克隆。
    ```bash
    $ git clone git@github.com:username/hexo-theme-next.git
    ```
3. 进入 `hexo-theme-next` 本地文件夹，并创建分支。
    ```bash
    $ cd hexo-theme-next
    $ git checkout -b patchname
    ```
4. 本地修改并测试，推送分支。
    ```bash
    $ git add .
    $ git commit -m "add commit messamge"
    $ git push origin patchname
    ```
5. 进入 `fork` 后的仓库，切换到新提交的 `patchname` 分支，点击 `patchname` 分支右侧的 **New pull request** 。在 PR 对比页面，正确选择你需要发起合并请求的分支，然后点击 **Create pull request** ，建立一个新的合并申请并描述变动。

请认真遵守如下指南，这样我们才能更好地理解你的合并请求：

创建合并请求时，请遵守[编码规范](#coding-rules)和[提交信息规范](#commit-messages-rules)。
在标题中清晰准确地描述你的合并请求，不要加入 Issue 编号。
按照[模板](../../.github/PULL_REQUEST_TEMPLATE.md)尽可能的详细填写相关信息。
合并请求需要在所有主题样式中测试通过，并提供所表现功能的样例，如图像文件、在线演示网址等等。
<a name="creating-releases"></a>
  
* 帮助文档
** 标签插件  
标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。

引用块
在文章中插入引言，可包含作者、来源和标题。

别号： quote

{% blockquote [author[, source]] [link] [source_link_title] %}
content
{% endblockquote %}
样例
没有提供参数，则只输出普通的 blockquote

{% blockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.
{% endblockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.

引用书上的句子

{% blockquote David Levithan, Wide Awake %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.
{% endblockquote %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.

David LevithanWide Awake
引用 Twitter

{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}
NEW: DevDocs now comes with syntax highlighting. http://devdocs.io
{% endblockquote %}
NEW: DevDocs now comes with syntax highlighting. http://devdocs.io

@DevDocstwitter.com/devdocs/status/356095192085962752
引用网络上的文章

{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}
Every interaction is both precious and an opportunity to delight.
{% endblockquote %}
Every interaction is both precious and an opportunity to delight.

Seth GodinWelcome to Island Marketing
代码块
在文章中插入代码。

别名： code

{% codeblock [title] [lang:language] [url] [link text] %}
code snippet
{% endcodeblock %}
样例
普通的代码块

{% codeblock %}
alert('Hello World!');
{% endcodeblock %}
alert('Hello World!');
指定语言

{% codeblock lang:objc %}
[rectangle setX: 10 y: 10 width: 20 height: 20];
{% endcodeblock %}
[rectangle setX: 10 y: 10 width: 20 height: 20];
附加说明

{% codeblock Array.map %}
array.map(callback[, thisArg])
{% endcodeblock %}
Array.map
array.map(callback[, thisArg])
附加说明和网址

{% codeblock _.compact http://underscorejs.org/#compact Underscore.js %}
_.compact([0, 1, false, 2, '', 3]);
=> [1, 2, 3]
{% endcodeblock %}
_.compactUnderscore.js
_.compact([0, 1, false, 2, '', 3]);
=> [1, 2, 3]
反引号代码块
另一种形式的代码块，不同的是它使用三个反引号来包裹。

``` [language] [title] [url] [link text] code snippet ```
Pull Quote
在文章中插入 Pull quote。

{% pullquote [class] %}
content
{% endpullquote %}
jsFiddle
在文章中嵌入 jsFiddle。

{% jsfiddle shorttag [tabs] [skin] [width] [height] %}
Gist
在文章中嵌入 Gist。

{% gist gist_id [filename] %}
iframe
在文章中插入 iframe。

{% iframe url [width] [height] %}
Image
在文章中插入指定大小的图片。

{% img [class names] /path/to/image [width] [height] [title text [alt text]] %}
Link
在文章中插入链接，并自动给外部链接添加 target="_blank" 属性。

{% link text url [external] [title] %}
Include Code
插入 source 文件夹内的代码文件。

{% include_code [title] [lang:language] path/to/file %}
Youtube
在文章中插入 Youtube 视频。

{% youtube video_id %}
Vimeo
在文章中插入 Vimeo 视频。

{% vimeo video_id %}
引用文章
引用其他文章的链接。

{% post_path slug %}
{% post_link slug [title] %}
引用资源
引用文章的资源。

{% asset_path slug %}
{% asset_img slug [title] %}
{% asset_link slug [title] %}
Raw
如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。

{% raw %}
content
{% endraw %}
** 资源文件夹
   资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。

文章资源文件夹
对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。

_config.yml
post_asset_folder: true
当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹。
这个资源文件夹将会有与这个 markdown 文件一样的名字。
将所有与你的文章有关的资源放在这个关联文件夹中之后，
你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。

相对路径引用的标签插件
通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。
在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。
这使得你可以更简单地在文章中引用你的资源。

{% asset_path slug %}
{% asset_img slug [title] %}
{% asset_link slug [title] %}
比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，
如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，
它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）

正确的引用图片方式是使用下列的标签插件而不是 markdown ：

{% asset_img example.jpg This is an example image %}
通过这种方式，图片将会同时出现在文章和主页以及归档页中。
** 数据文件
有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。

举例来说，在 source/_data 文件夹中新建 menu.yml 文件：

Home: /
Gallery: /gallery/
Archives: /archives/
您就能在模板中使用这些资料：

<% for (var link in site.data.menu) { %>
  <a href="<%= site.data.menu[link] %>"> <%= link %> </a>
<% } %>
渲染结果如下 :

<a href="/"> Home </a>
<a href="/gallery/"> Gallery </a>
<a href="/archives/"> Archives </a>
** 模版
模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：

模板	用途	回调
index	首页	
post	文章	index
page	分页	index
archive	归档	index
category	分类归档	archive
tag	标签归档	archive
布局（Layout）
如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说：

index.ejs
index
layout.ejs
<!DOCTYPE html>
<html>
  <body><%- body %></body>
</html>
生成：

<!DOCTYPE html>
<html>
  <body>index</body>
</html>
每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。

局部模版（Partial）
局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。举例来说：

partial/header.ejs
<h1 id="logo"><%= config.title %></h1>
index.ejs
<%- partial('partial/header') %>
<div id="content">Home page</div>
生成：

<h1 id="logo">My Site</h1>
<div id="content">Home page</div>
局部变量
您可以在局部模板中指定局部变量并使用。

partial/header.ejs
<h1 id="logo"><%= title></h1>
index.ejs
<%- partial('partial/header', {title: 'Hello World'}) %>
<div id="content">Home page</div>
生成：

<h1 id="logo">Hello World</h1>
<div id="content">Home page</div>
优化
如果您的主题太过于复杂，或是需要生成的文件量太过于庞大，可能会大幅降低性能，除了简化主题外，您可以考虑 Hexo 2.7 新增的局部缓存（Fragment Caching） 功能。

本功能借鉴于 Ruby on Rails，它储存局部内容，下次便能直接使用缓存内容，可以减少文件夹查询并使生成速度更快。

它可用于页首、页脚、侧边栏等文件不常变动的位置，举例来说：

<%- fragment_cache('header', function(){
  return '<header></header>';
});
如果您使用局部模板的话，可以更简单：

<%- partial('header', {}, {cache: true});
但是，如果您开启了 relative_link 参数的话，请勿使用局部缓存功能，因为相对链接在每个页面可能不同。
** 变量
全局变量
变量	描述
site	网站变量
page	针对该页面的内容以及 front-matter 所设定的变量。
config	网站配置
theme	主题配置。继承自网站配置。
_ (单下划线)	Lodash 函数库
path	当前页面的路径（不含根路径）
url	当前页面的完整网址
env	环境变量
网站变量
变量	描述
site.posts	所有文章
site.pages	所有分页
site.categories	所有分类
site.tags	所有标签
页面变量
页面（page）

变量	描述
page.title	页面标题
page.date	页面建立日期（Moment.js 对象）
page.updated	页面更新日期（Moment.js 对象）
page.comments	留言是否开启
page.layout	布局名称
page.content	页面的完整内容
page.excerpt	页面摘要
page.more	除了页面摘要的其余内容
page.source	页面原始路径
page.full_source	页面的完整原始路径
page.path	页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。
page.permalink	页面的完整网址
page.prev	上一个页面。如果此为第一个页面则为 null。
page.next	下一个页面。如果此为最后一个页面则为 null。
page.raw	文章的原始内容
page.photos	文章的照片（用于相簿）
page.link	文章的外部链接（用于链接文章）
文章 (post): 和 page 布局类似，但是添加了下列变量。

Variable	Description
page.published	如果该文章已发布则为True
page.categories	该文章的所有分类
page.tags	该文章的所有标签
首页（index）

变量	描述
page.per_page	每页显示的文章数量
page.total	总文章数
page.current	目前页数
page.current_url	目前分页的网址
page.posts	本页文章
page.prev	上一页的页数。如果此页是第一页的话则为 0。
page.prev_link	上一页的网址。如果此页是第一页的话则为 ''。
page.next	下一页的页数。如果此页是最后一页的话则为 0。
page.next_link	下一页的网址。如果此页是最后一页的话则为 ''。
page.path	当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。
归档 (archive)：与 index 布局相同，但新增以下变量。

变量	描述
page.archive	等于 true
page.year	年份归档 (4位)
page.month	月份归档 (没有前导零的2位数)
分类 (category)：与 index 布局相同，但新增以下变量。

变量	描述
page.category	分类名称
标签 (tag)：与 index 布局相同，但新增以下变量。

变量	描述
page.tag	标签名称
** 辅助函数（Helpers）
辅助函数帮助您在模版中快速插入内容。辅助函数不能在源文件中使用。

网址
url_for
在路径前加上根路径，从 Hexo 2.7 开始您应该使用此函数而不是 config.root + path。

<%- url_for(path) %>
relative_url
取得与 from 相对的 to 路径。

<%- relative_url(from, to) %>
gravatar
插入 Gravatar 图片。
如果你不指定 options 参数，将会应用默认参数。否则，你可以将其设置为一个数字，这个数字将会作为 Gravatar 的大小参数。最后，如果你设置它一个对象，它将会被转换为 Gravatar 的一个查询字符串参数。

<%- gravatar(email, [options]);
示例：

<%- gravatar('a@abc.com') %>
// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787

<%- gravatar('a@abc.com', 40) %>
// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787?s=40

<%- gravatar('a@abc.com' {s: 40, d: 'http://example.com/image.png'}) %>
// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787?s=40&d=http%3A%2F%2Fexample.com%2Fimage.png
HTML 标签
css
载入 CSS 文件。path 可以是数组或字符串，如果 path 开头不是 / 或任何协议，则会自动加上根路径；如果后面没有加上 .css 扩展名的话，也会自动加上。

<%- css(path, ...) %>
示例：

<%- css('style.css') %>
// <link rel="stylesheet" href="/style.css" type="text/css">

<%- css(['style.css', 'screen.css']) %>
// <link rel="stylesheet" href="/style.css" type="text/css">
// <link rel="stylesheet" href="/screen.css" type="text/css">
js
载入 JavaScript 文件。path 可以是数组或字符串，如果 path 开头不是 / 或任何协议，则会自动加上根路径；如果后面没有加上 .js 扩展名的话，也会自动加上。

<%- js(path, ...) %>
示例：

<%- js('script.js') %>
// <script type="text/javascript" src="/script.js"></script>

<%- js(['script.js', 'gallery.js']) %>
// <script type="text/javascript" src="/script.js"></script>
// <script type="text/javascript" src="/gallery.js"></script>
link_to
插入链接。

<%- link_to(path, [text], [options]) %>
参数	描述	默认值
external	在新视窗打开链接	false
class	Class 名称	
id	ID	
示例：

<%- link_to('http://www.google.com') %>
// <a href="http://www.google.com" title="http://www.google.com">http://www.google.com</a>

<%- link_to('http://www.google.com', 'Google') %>
// <a href="http://www.google.com" title="Google">Google</a>

<%- link_to('http://www.google.com', 'Google', {external: true}) %>
// <a href="http://www.google.com" title="Google" target="_blank" rel="external">Google</a>
mail_to
插入电子邮箱链接。

<%- mail_to(path, [text], [options]) %>
参数	描述
class	Class 名称
id	ID
subject	邮件主题
cc	抄送（CC）
bcc	密送（BCC）
body	邮件内容
示例：

<%- mail_to('a@abc.com') %>
// <a href="mailto:a@abc.com" title="a@abc.com">a@abc.com</a>

<%- mail_to('a@abc.com', 'Email') %>
// <a href="mailto:a@abc.com" title="Email">Email</a>
image_tag
插入图片。

<%- image_tag(path, [options]) %>
参数	描述
alt	图片的替代文字
class	Class 名称
id	ID
width	图片宽度
height	图片高度
favicon_tag
插入 favicon。

<%- favicon_tag(path) %>
feed_tag
插入 feed 链接。

<%- feed_tag(path, [options]) %>
参数	描述	默认值
title	Feed 标题	
type	Feed 类型	atom
条件函数
is_current
检查 path 是否符合目前页面的网址。开启 strict 选项启用严格比对。

<%- is_current(path, [strict]) %>
is_home
检查目前是否为首页。

<%- is_home() %>
is_post
检查目前是否为文章。

<%- is_post() %>
is_archive
检查目前是否为存档页面。

<%- is_archive() %>
is_year
检查目前是否为年度归档页面。

<%- is_year() %>
is_month
检查目前是否为月度归档页面。

<%- is_month() %>
is_category
检查目前是否为分类归档页面。
如果给定一个字符串作为参数，将会检查目前是否为指定分类。

<%- is_category() %>
<%- is_category('hobby') %>
is_tag
检查目前是否为标签归档页面。
如果给定一个字符串作为参数，将会检查目前是否为指定标签。

<%- is_tag() %>
<%- is_tag('hobby') %>
字符串处理
trim
清除字符串开头和结尾的空格。

<%- trim(string) %>
strip_html
清除字符串中的 HTML 标签。

<%- strip_html(string) %>
示例：

<%- strip_html('It's not <b>important</b> anymore!') %>
// It's not important anymore!
titlecase
把字符串转换为正确的 Title case。

<%- titlecase(string) %>
示例：

<%- titlecase('this is an apple') %>
# This is an Apple
markdown
使用 Markdown 解析字符串。

<%- markdown(str) %>
示例：

<%- markdown('make me **strong**') %>
// make me <strong>strong</strong>
render
解析字符串。

<%- render(str, engine, [options]) %>
word_wrap
使每行的字符串长度不超过 length。length 预设为 80。

<%- word_wrap(str, [length]) %>
示例：

<%- word_wrap('Once upon a time', 8) %>
// Once upon\n a time
truncate
移除超过 length 长度的字符串。

<%- truncate(text, length) %>
示例：

<%- truncate('Once upon a time in a world far far away', {length: 17}) %>
// Once upon a ti...

<%- truncate('Once upon a time in a world far far away', {length: 17, separator: ' '}) %>
// Once upon a...

<%- truncate('And they found that many people were sleeping better.', {length: 25, omission: '... (continued)'}) %>
// And they f... (continued)
模板
partial
载入其他模板文件，您可在 locals 设定区域变量。

<%- partial(layout, [locals], [options]) %>
参数	描述	默认值
cache	缓存（使用 Fragment cache）	false
only	限制局部变量。在模板中只能使用 locals 中设定的变量。	false
fragment_cache
局部缓存。它储存局部内容，下次使用时就能直接使用缓存。

<%- fragment_cache(id, fn);
示例：

<%- fragment_cache('header', function(){
  return '<header></header>';
}) %>
日期与时间
date
插入格式化的日期。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 date_format 配置信息。

<%- date(date, [format]) %>
示例：

<%- date(Date.now()) %>
// 2013-01-01

<%- date(Date.now(), 'YYYY/M/D') %>
// Jan 1 2013
date_xml
插入 XML 格式的日期。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。

<%- date_xml(date) %>
示例：

<%- date_xml(Date.now()) %>
// 2013-01-01T00:00:00.000Z
time
插入格式化的时间。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 time_format 配置信息。

<%- time(date, [format]) %>
示例：

<%- time(Date.now()) %>
// 13:05:12

<%- time(Date.now(), 'h:mm:ss a') %>
// 1:05:12 pm
full_date
插入格式化的日期和时间。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 date_format + time_format。

<%- full_date(date, [format]) %>
示例：

<%- full_date(new Date()) %>
// Jan 1, 2013 0:00:00

<%- full_date(new Date(), 'dddd, MMMM Do YYYY, h:mm:ss a') %>
// Tuesday, January 1st 2013, 12:00:00 am
moment
Moment.js 函数库。

列表
list_categories
插入分类列表。

<%- list_categories([options]) %>
参数	描述	默认值
orderby	分类排列方式	name
order	分类排列顺序。1, asc 升序；-1, desc 降序。	1
show_count	显示每个分类的文章总数	true
style	分类列表的显示方式。使用 list 以无序列表（unordered list）方式显示。	list
separator	分类间的分隔符号。只有在 style 不是 list 时有用。	,
depth	要显示的分类层级。0 显示所有层级的分类；-1 和 0 很类似，但是显示不分层级；1 只显示第一层的分类。	0
class	分类列表的 class 名称。	category
transform	改变分类名称显示方法的函数	
list_tags
插入标签列表。

<%- list_tags([options]) %>
选项	描述	预设值
orderby	标签排列方式	name
order	标签排列顺序。1, asc 升序；-1, desc 降序。	1
show_count	显示每个标签的文章总数	true
style	标签列表的显示方式。使用 list 以无序列表（unordered list）方式显示。	list
separator	标签间的分隔符号。只有在 style 不是 list 时有用。	,
class	标签列表的 class 名称。	tag
transform	改变标签名称显示方法的函数	
amount	要显示的标签数量（0 = 无限制）	0
list_archives
插入归档列表。

<%- list_archives([options]) %>
参数	描述	默认值
type	类型。此设定可为 yearly 或 monthly。	monthly
order	排列顺序。1, asc 升序；-1, desc 降序。	1
show_count	显示每个归档的文章总数	true
format	日期格式	MMMM YYYY
style	归档列表的显示方式。使用 list 以无序列表（unordered list）方式显示。	list
separator	归档间的分隔符号。只有在 style 不是 list 时有用。	,
class	归档列表的 class 名称。	archive
transform	改变归档名称显示方法的函数	
list_posts
插入文章列表。

<%- list_posts([options]) %>
参数	描述	默认值
orderby	文章排列方式	date
order	文章排列顺序。1, asc 升序；-1, desc 降序。	-1
style	文章列表的显示方式。使用 list 以无序列表（unordered list）方式显示。	list
separator	文章间的分隔符号。只有在 style 不是 list 时有用。	,
class	文章列表的 class 名称。	post
amount	要显示的文章数量（0 = 无限制）	6
transform	改变文章名称显示方法的函数	
tagcloud
插入标签云。

<%- tagcloud([tags], [options]) %>
参数	描述	默认值
min_font	最小字体尺寸	10
max_font	最大字体尺寸	20
unit	字体尺寸的单位	px
amount	标签总量	40
orderby	标签排列方式	name
order	标签排列顺序。1, sac 升序；-1, desc 降序	1
color	使用颜色	false
start_color	开始的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。	
end_color	结束的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。	
其他
paginator
插入分页链接。

<%- paginator(options) %>
参数	描述	默认值
base	基础网址	/
format	网址格式	page/%d/
total	分页总数	1
current	目前页数	0
prev_text	上一页链接的文字。仅在 prev_next 设定开启时才有用。	Prev
next_text	下一页链接的文字。仅在 prev_next 设定开启时才有用。	Next
space	空白文字	…
prev_next	显示上一页和下一页的链接	true
end_size	显示于两侧的页数	1
mid_size	显示于中间的页数	2
show_all	显示所有页数。如果开启此参数的话，end_size 和 mid_size 就没用了。	false
search_form
插入 Google 搜索框。

<%- search_form(options) %>
参数	描述	默认值
class	表单的 class name	search-form
text	搜索提示文字	Search
button	显示搜索按钮。此参数可为布尔值（boolean）或字符串，当设定是字符串的时候，即为搜索按钮的文字。	false
number_format
格式化数字。

<%- number_format(number, [options]) %>
参数	描述	默认值
precision	数字精度。此选项可为 false 或非负整数。	false
delimiter	千位数分隔符号	,
separator	整数和小数之间的分隔符号	.
示例：

<%- number_format(12345.67, {precision: 1}) %>
// 12,345.68

<%- number_format(12345.67, {precision: 4}) %>
// 12,345.6700

<%- number_format(12345.67, {precision: 0}) %>
// 12,345

<%- number_format(12345.67, {delimiter: ''}) %>
// 12345.67

<%- number_format(12345.67, {separator: '/'}) %>
// 12,345/67
open_graph
插入 open graph 资源。

<%- open_graph([options]) %>
参数	描述	默认值
title	页面标题 (og:title)	page.title
type	页面类型 (og:type)	blog
url	页面网址 (og:url)	url
image	页面图片 (og:image)	内容中的图片
site_name	网站名称 (og:site_name)	config.title
description	页面描述 (og:desription)	内容摘要或前 200 字
twitter_card	Twitter 卡片类型 (twitter:card)	summary
twitter_id	Twitter ID (twitter:creator)	
twitter_site	Twitter 网站 (twitter:site)	
google_plus	Google+ 个人资料链接	
fb_admins	Facebook 管理者 ID	
fb_app_id	Facebook 应用程序 ID	
toc
解析内容中的标题标签 (h1~h6) 并插入目录。

<%- toc(str, [options]) %>
参数	描述	默认值
class	Class 名称	toc
list_number	显示编号	true
示例：

<%- toc(page.content) %>
** 国际化（i18n）
若要让您的网站以不同语言呈现，您可使用国际化（internationalization）功能。请先在 _config.yml 中调整 language 设定，这代表的是预设语言，您也可设定多个语言来调整预设语言的顺位。

language: zh-tw

language: 
- zh-tw
- en
语言文件
语言文件可以使用 YAML 或 JSON 编写，并放在主题文件夹中的 languages 文件夹。您可以在语言文件中使用 printf 格式。

模板
在模板中，透过 __ 或 _p 辅助函数，即可取得翻译后的字符串，前者用于一般使用；而后者用于复数字符串。例如：

en.yml
index:
  title: Home
  add: Add
  video:
    zero: No videos
    one: One video
    other: %d videos
<%= __('index.title') %>
// Home

<%= _p('index.video', 3) %>
// 3 videos
路径
您可在 front-matter 中指定该页面的语言，也可在 _config.yml 中修改 i18n_dir 设定，让 Hexo 自动侦测。

i18n_dir: :lang
i18n_dir 的预设值是 :lang，也就是说 Hexo 会捕获网址中的第一段以检测语言，举例来说：

/index.html => en
/archives/index.html => en
/zh-tw/index.html => zh-tw
捕获到的字符串唯有在语言文件存在的情况下，才会被当作是语言，因此例二 /archives/index.html 中的 archives 就不被当成是语言。
** 插件系统
Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：

脚本（Scripts）
如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。

插件（Packages）
如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 node_modules 文件夹中建立文件夹，文件夹名称开头必须为 hexo-，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。

文件夹内至少要包含 2 个文件：一个是主程序，另一个是 package.json，描述插件的用途和所依赖的插件。

.
├── index.js
└── package.json
package.json 中至少要包含 name, version, main 属性，例如：

package.json
{
  "name": "hexo-my-plugin",
  "version": "0.0.1",
  "main": "index"
}
工具
您可以使用 Hexo 提供的官方工具插件来加速开发：

hexo-fs：文件 IO
hexo-util：工具程式
hexo-i18n：本地化（i18n）
hexo-pagination：生成分页资料
发布
当您完成插件后，可以考虑将它发布到 插件列表，让更多人能够使用您的插件。发布插件的步骤和 更新文件 非常类似。

Fork hexojs/site
把库（repository）复制到电脑上，并安装所依赖的插件。

$ git clone https://github.com/<username>/site.git
$ cd site
$ npm install
编辑 source/_data/plugins.yml，在档案中新增您的插件，例如：

- name: hexo-server
  description: Server module for Hexo.
  link: https://github.com/hexojs/hexo-server
  tags:
    - official
    - server
    - console
推送（push）分支。

建立一个新的合并申请（pull request）并描述改动。
** 插入视频
   <video src=' ' type='video/mp4' controls='controls'  width='100%' height='100%'>
</video>
** 更多
<!-- more -->
** 前言
本篇文章是在已经搭建好gitpage+hexo的博客的前提下（不懂怎么搭建的可以参考我的另一篇博文：了解githubPages+hexo搭建博客的原理 或者利用Gitpage+hexo开发自己的博客，这两篇博文都比较详细的教大家最基础的怎么将博客搭建起来。本篇博文是使用next主题的进击版本，主要是有以下内容

域名绑定，将github博客和你的独有域名绑定
添加更多的menu内容
添加头像
定义网站个性logo
自定义样式，重写默认样式，个性化定制你的博客
炫酷动态背景制作
添加网易云音乐
添加网易云跟帖
添加leancloud阅读次数统计功能
添加wordcount页面字数统计
添加fork me on github功能
要想最快的知道这些功能的效果，请移步我的个人博客：http://cherryblog.site/ ，顺便求个fork，大爷们看过可以评论一下，试一下新加上的网易云跟帖效果怎么样ヽ(●´ε｀●)ノ

首先要说一下我使用的版本，这个是很重要的，我的博客最先创建于2016年的9月份，距离现在已经有大半年了，所以好多版本都已经进行了更新，特别是next主题集成了更多的插件，简直不要太爽＼（＠￣∇￣＠）／

hexo v3.2.2
next v5.1.0
node v4.5.0

在改成自己想要的效果之后，对整体的hexo的next主题我有了一个大概的了解，其实next主题的最新版（5.1）已经集成了大部分我们需要的插件，只需要在主题配置文件中将默认的false改为true即可，但是我们也仍然需要知道都有哪些新的功能，最有效的方法是直接去查看官网的api：next官网这里写图片描述

授之于鱼不如授之于渔
希望我们都能够理解其源码，制作出属于自己专属的个性化博客(•̀ᴗ•́)

我们需要改的文件其实也就那么几个，大部分是不需要更改，next都已经帮我们配置好了~
默认目录结构：

.
├── .deploy
├── public
├── scaffolds
├── scripts
├── source
|   ├── _drafts
|   └── _posts
├── themes
├── _config.yml
└── package.json
deploy：执行hexo deploy命令部署到GitHub上的内容目录
public：执行hexo generate命令，输出的静态网页内容目录
scaffolds：layout模板文件目录，其中的md文件可以添加编辑
scripts：扩展脚本目录，这里可以自定义一些javascript脚本
source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。
drafts：草稿文章
posts：发布文章
themes：主题文件目录
_config.yml：全局配置文件，大多数的设置都在这里
package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮
我们最先修改的应该是在hexo根目录下的配置文件_config.yml文件，这里是配置整个站点的配置信息，在文章的最后贴出我的配置文件，有兴趣的朋友可以参考一下~
其次就是我们的主题配置文件
在对应的主题下的_config.yml 因为我使用的是next主题，所以目录的路径为C:\Hexo\themes\next\_config.yml 这里配置的是使用主题的配置文件，这个配置文件的东西就有点多了，我们大部分的修改也是在这个文件下完成的。比如说使用集成的第三方插件，默认为false，我们需要将其改为true并且配置相应的app_key就可以使用该插件了~有木有很方便(^ ◕ᴥ◕ ^)
然后我们需要修改样式的话是需要设置css和甚至是修改模板，
页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以next主题为例：

├── .github            #git信息
├── languages          #多语言
|   ├── default.yml    #默认语言
|   └── zh-Hans.yml      #简体中文
|   └── zh-tw.yml      #繁体中文
├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制
|   ├── _custom        #可以自己修改的模板，覆盖原有模板
|   |   ├── _header.swig    #头部样式
|   |   ├── _sidebar.swig   #侧边栏样式
|   ├── _macro        #可以自己修改的模板，覆盖原有模板
|   |   ├── post.swig    #文章模板
|   |   ├── reward.swig    #打赏模板
|   |   ├── sidebar.swig   #侧边栏模板
|   ├── _partial       #局部的布局
|   |   ├── head       #头部模板
|   |   ├── search     #搜索模板
|   |   ├── share      #分享模板
|   ├── _script        #局部的布局
|   ├── _third-party   #第三方模板
|   ├── _layout.swig   #主页面模板
|   ├── index.swig     #主页面模板
|   ├── page           #页面模板
|   └── tag.swig       #tag模板
├── scripts            #script源码
|   ├── tags           #tags的script源码
|   ├── marge.js       #页面模板
├── source             #源码
|   ├── css            #css源码
|   |   ├── _common    #*.styl基础css
|   |   ├── _custom    #*.styl局部css
|   |   └── _mixins    #mixins的css
|   ├── fonts          #字体
|   ├── images         #图片
|   ├── uploads        #添加的文件
|   └── js             #javascript源代码
├── _config.yml        #主题配置文件
└── README.md          #用GitHub的都知道
绑定域名
绑定域名的思路如下：

在万网购买自己喜欢的域名（.com的会贵一点，.site和.xyz的相对便宜一些，有的只需要几块钱一年就可以）
解析DNS
在hexo中添加CNAME文件
购买域名
之前没有买域名的时候我想使用网易云跟帖，发现在注册网易云跟帖的时候使用原来的域名提示“url已被使用”，这是因为网易云跟帖不认可二级域名，所以要自己买域名。
我选择的是万网，阿里下面的。我选择了一个.site的域名，原价8元，使用阿里云app支付还优惠5元，等于3元到手一个域名（一年）~
按照官网的步骤一步一来就可以了~

解析DNS
购买完域名之后我们需要解析DNS地址，在管理控制台中的左侧有域名选项，然后找到你的域名，点击后面的“解析”
这里写图片描述

点击添加解析，记录类型选A或CNAME，

A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，
解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是sunshine940326.github.io。

在hexo中添加CNAME文件
接下来在你的hexo文件夹下source文件夹下新建一个CANME文件,里面加上你刚刚购买的域名比如我的cherryblog.site
这里写图片描述
然后你就可以hexo clean,hexo g，hexo d 发布你的博客看看效果啦~
这里写图片描述
在这里我出现一个问题，就是单独输入域名是可以访问的，但是前面加上www之后就访问不聊了= =了，我感觉应该是可以的，但是不行，再等几天看看效果= =

添加菜单页
添加菜单页的思路（添加菜单页就是添加一个页面，有两种方式）：第一种是使用git命令hexo new page "photo" 就直接创建了C:\Hexo\source\photo\index.md文件，然后编辑index.md 文件就可以了~
这里写图片描述
第二种：手动创建上面的文件= =

在主题的配置文件添加menu索引路径（根路径是hexo/source）,所以你如果想要更改页面的内容就去hexo/source下找到对应的文件夹，默认内容是在其index.md文件下
在hexo的source文件下添加对应的文件夹
在主题的配置文件添加menu_icon字段设置对应的icon
修改language文件下zh-hans语言包
在发表文章的时候添加对应的menu字段就可以看到
刚开始的时候不理解怎么添加分类页和添加文章的区别，公司有一个项目用到了wordpress，然后发现两者有相似的地方，不同的就是wordpress是有可视化的操作后台，而hexo是需要git bash自己创建首先我们要分清什么是页面，什么是文章，
在hexo中menu下的内容都是新的页面我们可以通过hexo new page "pagename" 创建，hexo默认的页面只有home,archives,tags 三个，之后我们写的博文就是文章，通过hexo new "name" 创建的name.md 文件在根目录的source\_posts 下，在每一个文章的头部，我们可以配置其tags或者categories内容，相当于文章是页面的下一级

在配置文件中添加menu索引路径
我们可以在主题配置的_config文件下找到相应的字段，字段前加# 表示被注释掉，我们也可以自己添加menu的内容，比如我又新增了两个menulife 和photo
这里写图片描述
这里添加的字段其实是加上文件索引的路径，这里hexo设置的根路径是hexo/source 接下来我们在这个根路径下建立相应的文件夹就可以实现点击mune跳转到相应的页面上了
这里写图片描述,
没有明白什么意思的同学看下图

在source文件添加menu文件夹
我们需要在这个路径下自己建立对应的页面，比如说我新建了menulife 和photos，然后再source文件夹下面新建两个名字为life 和photo 的文件夹，里面添加一个index.md markdown文件，内容是类似这样的

title: photo
date: 2017-04-04 22:14:07
type: "photo"
comments: false
---
啦啦啦~
这里写图片描述
这是一个markdown文件，你可以自己编写，但是我还不知道怎么把添加html文件= =，回来研究一下

给menu添加icon
如果只是上面的步骤，那么你可能会创建出一个新的页面，但是显示的效果会是这样：这里写图片描述
怎么icon没有换？？？其实hexo中换icon是一个很简单的事情，因为hexo集成了FontAwsome 所以我们只需要在主题的配置文件中加入相应的icon名字即可
这里写图片描述

查找FontAwsome icon
这时候你想要换一个自己喜欢的icon怎么办，这就需要自己动手，丰衣足食了，你需要自己到FontAwsome官网，然后鼠标往下拉，在图标集中选择自己喜欢的icon，然后记住名字，保存在上面的menu_icon字段中就可以啦~
这里写图片描述tips ：在字段中只需要填写icon-name后面跟的name即可，不需要加上前面的”icon-“

在language添加zh-hans翻译字段
上面的步骤完成之后你会发现，在你的博客首页显示的仍然是英文名，而我们想要有一个中文的名字，并且想要个性化定制我们的页面，我们可以在主题的language文件下的zh-hans（中文）语言包下增加相应的字段（做过翻译的童鞋应该都知道什么意思~）还可以修改其他的字段，这样就可以定制我们的博客了呢~
这里写图片描述

在发表文章的时候添加对应的menu字段
在我们写文章的时候只要在头部信息添加相应的字段就在tags页面和categories中显示相应的分类，例如:

title: Git使用中的报错情况
date: 2017-03-11 23:54:11
tags: [git,实战经验] 
categories: git
---
tags、categories都是支持数组的形式的，可以添加多个tags、categories。这样我们在tags、categories页面就可以看见相应的分类了
这里写图片描述

添加头像
我使用的主题头像是位于侧边栏，显示的效果如下，
这里写图片描述要添加一个这个的头像要怎么操作呢，其实思路就是将你要上传的头像放在你的文件夹中，然后再配置文件中引用正确的路径即可，当然也可以上传绝对路径。在你的主题配置文件找到avatar字段，然后将你得图片路径写在后面，我是新建了一个uploads文件夹，将图片放在下面

# Sidebar Avatar
# in theme directory(source/images): /images/avatar.jpg
# in site  directory(source/uploads): /uploads/avatar.jpg
avatar: /uploads/avatar.png
这里写图片描述

设置网站logo
跟设置头像其实是一个思路，都是在配置文件中引入正确的地址就可以了，不过网站的logo是对图片有要求的，我们需要在Favicon在线制作工具中制作32*32的.ico图片，然后放在source/images下面。然后在主题配置文件下添加主题配置文件中添加：favicon: images/favicon.ico

自定义样式
不得不说next还是很人性化的，你可以个性化定制你的网站，你所有的改动（css）需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，所以只要你不想要你修改的样式，只需要删除这个文件夹就可以了，再也不用担心还原不回去了~
这里写图片描述

炫酷动态背景
2017.5.8更新，具体过程往下看仿知乎动态背景
之前做过一个类似的canvas-nest的效果。新版本的next已经支持canvas-nest了，但是效果不怎么样，就不用了，但是也介绍一下，毕竟简单，只有两步就可以了。
添加修改代码next/layout/_layout.swig在</body>之前加上

{% if theme.canvas_nest %}
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
{% endif %}
打开next/_config.yml，添加以下代码就可以了：

 # Canvas-nest
canvas_nest: true
这种虽然简单，但是我认为效果不够好，于是我决定添加原生的js来仿知乎的登录界面做背景，这就需要修改模板来实现了。首先我们要知道next文件的结构，这样我们想改什么就知道在什么位置了~
这里写图片描述
所以我们需要在layout下面的_layout.swig 添加一个canvas

然后使用原生js写一个仿知乎页面,详情script代码可以从github上clone：
https://github.com/sunshine940326/canvas-nest

<script>
class Circle {
    //创建对象
    //以一个圆为对象
    //设置随机的 x，y坐标，r半径，_mx，_my移动的距离
    //this.r是创建圆的半径，参数越大半径越大
    //this._mx,this._my是移动的距离，参数越大移动
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = Math.random() * 10 ;
        this._mx = Math.random() ;
        this._my = Math.random() ;
    }
    //canvas 画圆和画直线
    //画圆就是正常的用canvas画一个圆
    //画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理
    drawCircle(ctx) {
        ctx.beginPath();
        //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
        ctx.arc(this.x, this.y, this.r, 0, 360)
        ctx.closePath();
        ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
        ctx.fill();
    }
    drawLine(ctx, _circle) {
        let dx = this.x - _circle.x;
        let dy = this.y - _circle.y;
        let d = Math.sqrt(dx * dx + dy * dy)
        if (d < 150) {
            ctx.beginPath();
            //开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：
            ctx.moveTo(this.x, this.y);   //起始点
            ctx.lineTo(_circle.x, _circle.y);   //终点
            ctx.closePath();
            ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
            ctx.stroke();
        }
    }
    // 圆圈移动
    // 圆圈移动的距离必须在屏幕范围内
    move(w, h) {
        this._mx = (this.x < w && this.x > 0) ? this._mx : (-this._mx);
        this._my = (this.y < h && this.y > 0) ? this._my : (-this._my);
        this.x += this._mx / 2;
        this.y += this._my / 2;
    }
}
//鼠标点画圆闪烁变动
class currentCirle extends Circle {
    constructor(x, y) {
        super(x, y)
    }
    drawCircle(ctx) {
        ctx.beginPath();
        //注释内容为鼠标焦点的地方圆圈半径变化
        //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
        this.r = 8;
        ctx.arc(this.x, this.y, this.r, 0, 360);
        ctx.closePath();
        //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
        ctx.fillStyle = 'rgba(255, 77, 54, 0.3)'
        ctx.fill();
    }
}
//更新页面用requestAnimationFrame替代setTimeout
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let w = canvas.width = canvas.offsetWidth;
let h = canvas.height = canvas.offsetHeight;
let circles = [];
let current_circle = new currentCirle(0, 0)
let draw = function () {
    ctx.clearRect(0, 0, w, h);
    for (let i = 0; i < circles.length; i++) {
        circles[i].move(w, h);
        circles[i].drawCircle(ctx);
        for (j = i + 1; j < circles.length; j++) {
            circles[i].drawLine(ctx, circles[j])
        }
    }
    if (current_circle.x) {
        current_circle.drawCircle(ctx);
        for (var k = 1; k < circles.length; k++) {
            current_circle.drawLine(ctx, circles[k])
        }
    }
    requestAnimationFrame(draw)
}
let init = function (num) {
    for (var i = 0; i < num; i++) {
        circles.push(new Circle(Math.random() * w, Math.random() * h));
    }
    draw();
}
window.addEventListener('load', init(60));
window.onmousemove = function (e) {
    e = e || window.event;
    current_circle.x = e.clientX;
    current_circle.y = e.clientY;
}
window.onmouseout = function () {
    current_circle.x = null;
    current_circle.y = null;
};
</script>
仿知乎动态背景
2017.5.8更新，很多朋友都私信我说这个动态背景没有效果，发现上面的js代码是es6写的，兼容性不好，并且中间也漏了一步添加css样式的，导致好多显示的不完全，特此更新
，完整步骤如下

1：首先在主题文件的layout中的_layout.swigC:\Hexo\themes\next\layout\_layout.swig中加入

 <div class="bg_content">
      <canvas id="canvas"></canvas>
 </div>
'use strict';
   var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
   function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
   function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
   function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
   var Circle = function () {
      function Circle(x, y) {
           _classCallCheck(this, Circle);
           this.x = x;
           this.y = y;
           this.r = Math.random() * 10;
           this._mx = Math.random();
           this._my = Math.random();
       }
      _createClass(Circle, [{
           key: 'drawCircle',
           value: function drawCircle(ctx) {
               ctx.beginPath();
               //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
               ctx.arc(this.x, this.y, this.r, 0, 360);
               ctx.closePath();
               ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
               ctx.fill();
           }
       }, {
           key: 'drawLine',
           value: function drawLine(ctx, _circle) {
               var dx = this.x - _circle.x;
               var dy = this.y - _circle.y;
               var d = Math.sqrt(dx * dx + dy * dy);
               if (d < 150) {
                   ctx.beginPath();
                   ctx.moveTo(this.x, this.y); //起始点
                   ctx.lineTo(_circle.x, _circle.y); //终点
                   ctx.closePath();
                   ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
                   ctx.stroke();
               }
           }
       }, {
           key: 'move',
           value: function move(w, h) {
               this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;
               this._my = this.y < h && this.y > 0 ? this._my : -this._my;
               this.x += this._mx / 2;
               this.y += this._my / 2;
           }
       }]);
       return Circle;
   }();
   var currentCirle = function (_Circle) {
       _inherits(currentCirle, _Circle);
       function currentCirle(x, y) {
           _classCallCheck(this, currentCirle);
           return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));
       }
       _createClass(currentCirle, [{
           key: 'drawCircle',
           value: function drawCircle(ctx) {
               ctx.beginPath();
               //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
               this.r = 8;
               ctx.arc(this.x, this.y, this.r, 0, 360);
               ctx.closePath();
               //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
               ctx.fillStyle = 'rgba(255, 77, 54, 0.6)';
               ctx.fill();
           }
       }]);
       return currentCirle;
   }(Circle);
   window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
   var canvas = document.getElementById('canvas');
   var ctx = canvas.getContext('2d');
   var w = canvas.width = canvas.offsetWidth;
   var h = canvas.height = canvas.offsetHeight;
   var circles = [];
   var current_circle = new currentCirle(0, 0);
   var draw = function draw() {
       ctx.clearRect(0, 0, w, h);
       for (var i = 0; i < circles.length; i++) {
           circles[i].move(w, h);
           circles[i].drawCircle(ctx);
           for (j = i + 1; j < circles.length; j++) {
               circles[i].drawLine(ctx, circles[j]);
           }
       }
       if (current_circle.x) {
           current_circle.drawCircle(ctx);
           for (var k = 1; k < circles.length; k++) {
               current_circle.drawLine(ctx, circles[k]);
           }
       }
       requestAnimationFrame(draw);
   };
   var init = function init(num) {
       for (var i = 0; i < num; i++) {
           circles.push(new Circle(Math.random() * w, Math.random() * h));
       }
       draw();
   };
   window.addEventListener('load', init(60));
   window.onmousemove = function (e) {
       e = e || window.event;
       current_circle.x = e.clientX;
       current_circle.y = e.clientY;
   };
   window.onmouseout = function () {
       current_circle.x = null;
       current_circle.y = null;
   };
2：在主题文件的C:\Hexo\themes\next\source\css\_custom\custom.styl文件中加上css代码

/*设置背景*/
.bg_content{
  position: fixed;
  top: 0;
  z-index: -1;
  width: 100%;
  height: 100%;
}
#canvas{
  width: 100%;
  height:100%;
}
/*将头部背景变为透明*/
.header{
  background: transparent ;
}
添加网易云音乐
在知道了页面的结构之后，你就可以将你的播放器添加在页面的任意位置，开始我是放在了首页，然后发现一上来就自动播放太吵了，于是就放在了侧边栏，想要听得朋友可以手动点击播放，
我们可以直接在网易云音乐中搜索我们想要插入的音乐，然后点击生成外链播放器
这里写图片描述
然后可以根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置即可
这里写图片描述
我放在了layout/_macro/sidebar.swig 文件下

<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66">
    </iframe>
</div>

然后就可以在侧边栏看见我的播放器了~
这里写图片描述


#添加Fork me on GitHub
去网址https://github.com/blog/273-github-ribbons 挑选自己喜欢的样式，并复制代码，添加到themes\next\layout_layout.swig的body标签之内即可
记得把里面的url换成自己的!

hexo-wordcount实现统计功能
这里写图片描述
wordcount可以实现字数统计，阅读时常还有总字数的统计功能
只需要npm install hexo-wordcount --save 就可以安装wordcount插件，
主要功能

字数统计:WordCount
阅读时长预计:Min2Read
总字数统计: TotalCount
安装完插件之后在主题的配置文件中开启该功能就可以~

# Post wordcount display settings
# Dependencies: https://github.com/willin/hexo-wordcount
post_wordcount:
  item_text: true
  wordcount: true
  min2read: true
** 生成网易云音乐外链
把审查的元素插在这个链接后面 http://music.163.com/#
例如： http://music.163.com/#/outchain/2/254574/
** 评论系统 gitment 
基础使用
1. 注册 OAuth Application
点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 https://imsun.net）。
https://github.com/settings/applications/new
你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。
我自己的是 
Client ID
a0dc2bc5e40d25adfcaa
Client Secret
1945a52f996559e61f5cb0a55317d1a0838c4901

2. 引入 Gitment
将下面的代码添加到你的页面：

<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '页面 ID', // 可选。默认为 location.href
  owner: '你的 GitHub ID',
  repo: '存储评论的 repo',
  oauth: {
    client_id: '你的 client ID',
    client_secret: '你的 client secret',
  },
})
gitment.render('container')
</script>
注意，上述代码引用的 Gitment 将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。

如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。

$ npm install --save gitment
关于构造函数中的更多可用参数请查看 Gitment Options

3. 初始化评论
页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。

之后其他用户即可在该页面发表评论。

自定义
Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）

比如你可以通过自定义主题将评论框放在评论列表前面：

const myTheme = {
  render(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'gitment-container gitment-root-container'
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderFooter(state, instance))
    return container
  },
}
const gitment = new Gitment({
  // ...
  theme: myTheme,
})
gitment.render('container')
更多自定义内容请查看文档。

其他问题
语言问题
考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。

** 写作

你可以执行下列命令来创建一篇新文章。

$ hexo new [layout] <title>
您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。

布局（Layout）
Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。

布局	路径
post	source/_posts
page	source
draft	source/_drafts
不要处理我的文章
如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。

文件名称
Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。

变量	描述
:title	标题（小写，空格将会被替换为短杠）
:year	建立的年份，比如， 2015
:month	建立的月份（有前导零），比如， 04
:i_month	建立的月份（无前导零），比如， 4
:day	建立的日期（有前导零），比如， 07
:i_day	建立的日期（无前导零），比如， 7
草稿
刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。

$ hexo publish [layout] <title>
草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。

模版（Scaffold）
在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：

$ hexo new photo "My Gallery"
在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：

变量	描述
layout	布局
title	标题
date	文件建立日期

** Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：

title: Hello World
date: 2013/7/13 20:46:25
---
以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。

参数	描述	默认值
layout	布局	
title	标题	
date	建立日期	文件建立日期
updated	更新日期	文件更新日期
comments	开启文章的评论功能	true
tags	标签（不适用于分页）	
categories	分类（不适用于分页）	
permalink	覆盖文章网址	
分类和标签
只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。

categories:
- Diary
tags:
- PS3
- Games
分类方法的分歧
如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：
categories:
- Diary
- Life
会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。

JSON Front-matter
除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。

"title": "Hello World",
"date": "2013/7/13 20:46:25"
;;;

** 标签插件（Tag Plugins）
标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。

引用块
在文章中插入引言，可包含作者、来源和标题。

别号： quote

{% blockquote [author[, source]] [link] [source_link_title] %}
content
{% endblockquote %}
样例
没有提供参数，则只输出普通的 blockquote

{% blockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.
{% endblockquote %}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.

引用书上的句子

{% blockquote David Levithan, Wide Awake %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.
{% endblockquote %}
Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.

David LevithanWide Awake
引用 Twitter

{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}
NEW: DevDocs now comes with syntax highlighting. http://devdocs.io
{% endblockquote %}
NEW: DevDocs now comes with syntax highlighting. http://devdocs.io

@DevDocstwitter.com/devdocs/status/356095192085962752
引用网络上的文章

{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}
Every interaction is both precious and an opportunity to delight.
{% endblockquote %}
Every interaction is both precious and an opportunity to delight.

Seth GodinWelcome to Island Marketing
代码块
在文章中插入代码。

别名： code

{% codeblock [title] [lang:language] [url] [link text] %}
code snippet
{% endcodeblock %}
样例
普通的代码块

{% codeblock %}
alert('Hello World!');
{% endcodeblock %}
alert('Hello World!');
指定语言

{% codeblock lang:objc %}
[rectangle setX: 10 y: 10 width: 20 height: 20];
{% endcodeblock %}
[rectangle setX: 10 y: 10 width: 20 height: 20];
附加说明

{% codeblock Array.map %}
array.map(callback[, thisArg])
{% endcodeblock %}
Array.map
array.map(callback[, thisArg])
附加说明和网址

{% codeblock _.compact http://underscorejs.org/#compact Underscore.js %}
_.compact([0, 1, false, 2, '', 3]);
=> [1, 2, 3]
{% endcodeblock %}
_.compactUnderscore.js
_.compact([0, 1, false, 2, '', 3]);
=> [1, 2, 3]
反引号代码块
另一种形式的代码块，不同的是它使用三个反引号来包裹。

``` [language] [title] [url] [link text] code snippet ```
Pull Quote
在文章中插入 Pull quote。

{% pullquote [class] %}
content
{% endpullquote %}
jsFiddle
在文章中嵌入 jsFiddle。

{% jsfiddle shorttag [tabs] [skin] [width] [height] %}
Gist
在文章中嵌入 Gist。

{% gist gist_id [filename] %}
iframe
在文章中插入 iframe。

{% iframe url [width] [height] %}
Image
在文章中插入指定大小的图片。

{% img [class names] /path/to/image [width] [height] [title text [alt text]] %}
Link
在文章中插入链接，并自动给外部链接添加 target="_blank" 属性。

{% link text url [external] [title] %}
Include Code
插入 source 文件夹内的代码文件。

{% include_code [title] [lang:language] path/to/file %}
Youtube
在文章中插入 Youtube 视频。

{% youtube video_id %}
Vimeo
在文章中插入 Vimeo 视频。

{% vimeo video_id %}
引用文章
引用其他文章的链接。

{% post_path slug %}
{% post_link slug [title] %}
引用资源
引用文章的资源。

{% asset_path slug %}
{% asset_img slug [title] %}
{% asset_link slug [title] %}
Raw
如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。

{% raw %}
content
{% endraw %}

** 资源文件夹
资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。

文章资源文件夹
对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。

_config.yml
post_asset_folder: true
当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。

相对路径引用的标签插件
通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。

{% asset_path slug %}
{% asset_img slug [title] %}
{% asset_link slug [title] %}
比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）

正确的引用图片方式是使用下列的标签插件而不是 markdown ：

{% asset_img example.jpg This is an example image %}
通过这种方式，图片将会同时出现在文章和主页以及归档页中。

** 数据文件
有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。

举例来说，在 source/_data 文件夹中新建 menu.yml 文件：

Home: /
Gallery: /gallery/
Archives: /archives/
您就能在模板中使用这些资料：

<% for (var link in site.data.menu) { %>
  <a href="<%= site.data.menu[link] %>"> <%= link %> </a>
<% } %>
渲染结果如下 :

<a href="/"> Home </a>
<a href="/gallery/"> Gallery </a>
<a href="/archives/"> Archives </a>

** 服务器
hexo-server
Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。

$ npm install hexo-server --save
安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。

$ hexo server
如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：

$ hexo server -p 5000
静态模式
在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate，此模式通常用于生产环境（production mode）下。

$ hexo server -s
自定义 IP
服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：

$ hexo server -i 192.168.1.1
指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。

Pow
Pow 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。

安装
$ curl get.pow.cx | sh
设置
在 ~/.pow 文件夹建立链接（symlink）。

$ cd ~/.pow
$ ln -s /path/to/myapp
您的网站将会在 http://myapp.dev 下运行，网址根据链接名称而定。

** 生成文件
使用 Hexo 生成静态文件快速而且简单。

$ hexo generate
监视文件变动
Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。

$ hexo generate --watch
完成后部署
您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。

$ hexo generate --deploy
$ hexo deploy --generate
简写
上面两个命令可以简写为
$ hexo g -d
$ hexo d -g

** 
Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。

$ hexo deploy
在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：

deploy:
  type: git
您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。

deploy:
- type: git
  repo:
- type: heroku
  repo:
缩进
YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。

Git
安装 hexo-deployer-git。

$ npm install hexo-deployer-git --save
修改配置。

deploy:
  type: git
  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io
  branch: [branch] #published
  message: [message]
参数	描述
repo	库（Repository）地址
branch	分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。
message	自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})
生成站点文件并推送至远程库。执行hexo clean && hexo deploy命令。前者清除站点文件，后者重新生成站点文件并将之推送到指定的库分支。（如果您的Hexo是局部安装，则需要执行./node_modules/.bin/hexo clean && ./node_modules/.bin/hexo deploy。）

登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。

这一切是如何发生的？
当初次新建一个库的时候，库将自动包含一个master分支。请在这个分支下进行写作和各种配置来完善您的网页。当执行hexo deploy时，Hexo会创建或更新另外一个用于部署的分支，这个分支就是_config.yml配置文件中指定的分支。Hexo会将生成的站点文件推送至该分支下，并且完全覆盖该分支下的已有内容。因此，部署分支应当不同于写作分支。（一个推荐的方式是把master作为写作分支，另外使用public分支作为部署分支。）值得注意的是，hexo deploy并不会对本地或远程的写作分支进行任何操作，因此依旧需要手动推送写作分支的所有改动以实现版本控制。此外，如果您的Github Pages需要使用CNAME文件自定义域名，请将CNAME文件置于写作分支的source_dir目录下，只有这样hexo deploy才能将CNAME文件一并推送至部署分支。

Heroku
安装 hexo-deployer-heroku。

$ npm install hexo-deployer-heroku --save
修改配置。

deploy:
  type: heroku
  repo: <repository url>
  message: [message]
参数	描述
repo	Heroku 库（Repository）地址
message	自定提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})
Netlify
Netlify 是一个提供网络托管的综合平台。它集持续集成（CI）CDN 自定义域名 HTTPS 持续部署（CD）等诸多功能于一身。您可以通过以下两种方式将Hexo站点部署到Netlify。

首先，也是最通用的方式，就是使用Netlify提供的网页端用户界面。前往新建一个网站页面，选择需要关联的 Github/BitBucket/Gitlab 库，然后遵循网站提示。

另一种方式是使用Netlify提供的命令行客户端工具 Node based CLI 管理和部署您的站点。

此外，您还可以在项目的README中增加一个 部署至Netlify按钮，这样其他用户在fork或clone了您的项目之后可以方便快捷地一键部署。

Rsync
安装 hexo-deployer-rsync。

$ npm install hexo-deployer-rsync --save
修改配置。

deploy:
  type: rsync
  host: <host>
  user: <user>
  root: <root>
  port: [port]
  delete: [true|false]
  verbose: [true|false]
  ignore_errors: [true|false]
参数	描述	默认值
host	远程主机的地址	
user	使用者名称	
root	远程主机的根目录	
port	端口	22
delete	删除远程主机上的旧文件	true
verbose	显示调试信息	true
ignore_errors	忽略错误	false
rsync部署模块的工作方式
需要注意的是，要求您提供的实际上是一个能通过SSH登陆远程主机的Linux用户。Hexo会自动处理关于rsync使用的一切操作。因此，您需要在远程主机上为您的Hexo站点建立一个用户，并允许其通过SSH登陆。不过，这里的port，的确是指rsync监听的端口，请确保防火墙打开了该端口。

OpenShift
安装 hexo-deployer-openshift。

$ npm install hexo-deployer-openshift --save
修改配置。

deploy:
  type: openshift
  repo: <repository url>
  message: [message]
参数	描述
repo	OpenShift 库（Repository）地址
message	自定提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})
FTPSync
安装 hexo-deployer-ftpsync。

$ npm install hexo-deployer-ftpsync --save
修改配置。

deploy:
  type: ftpsync
  host: <host>
  user: <user>
  pass: <password>
  remote: [remote]
  port: [port]
  ignore: [ignore]
  connections: [connections]
  verbose: [true|false]
参数	描述	默认值
host	远程主机的地址	
user	使用者名称	
pass	密码	
remote	远程主机的根目录	/
port	端口	21
ignore	忽略的文件或目录	
connections	使用的连接数	1
verbose	显示调试信息	false
FTP部署可能出现的问题
您可能需要预先通过其他方式将所有文件上传到远程主机中。否则初次使用ftpsync插件就可能出现报错。另外，由于FTP协议的特征，它每传送一个文件就需要一次握手，相对速度较慢。

SFTP
安装 hexo-deployer-sftp。

$ npm install hexo-deployer-sftp --save
修改配置。

deploy:
  type: sftp
  host: <host>
  user: <user>
  pass: <password>
  remotePath: [remote path]
  port: [port]
  privateKey: [path/to/privateKey]
  passphrase: [passphrase]
  agent: [path/to/agent/socket]
参数	描述	默认值
host	远程主机的地址	
user	使用者名称	
pass	密码	
remotePath	远程主机的根目录	/
port	端口	22
privateKey	ssh私钥的目录地址	
passphrase	（可省略）ssh私钥的密码短语	
agent	ssh套接字的目录地址	$SSH_AUTH_SOCK
其他方法
Hexo 生成的所有文件都放在 public 文件夹中，您可以将它们复制到您喜欢的地方。

