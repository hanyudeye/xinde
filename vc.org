* 版本控制（多人可修改的东西,我的修改版，你的修改版,修改记录)
  版本控制包括：检入检出控制(修改)、分支和合并、历史记录。
** 集中式与分布式(版本库的位置)
   Git 属于分布式版本控制系统，而 SVN 属于集中式。
   git 本地也有版本库,本地就可以检入检出
** 分支实现 (东西不仅有版本，归属，还有分支属性)
   使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。

   新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支表示新分
   支成为当前分支。

   每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。

   合并分支也只需要改变指针即可。
** 冲突(东西冲突)
   当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。

   Git 会使用 <<<<<<< ，======= ，>>>>>>> 标记出不同分支的内容，只需要把不同分支中
   冲突部分修改成一样就能解决冲突。
** 快进式合并
   "快进式合并"（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式
   下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。

   可以在合并时加上 --no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时
   产生一个新的 commit。
  
   #+begin_src shell
     $ git merge --no-ff -m "merge with no-ff" dev
   #+end_src
** 分支管理策略 (东西要分稳定版和开发版)
   master 分支应该是非常稳定的，只用来发布新版本；
   日常开发在开发分支 dev 上进行
** 储藏（Stashing）,还不想存本地库，又想切分支时可用
   在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个
   分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。

   可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到
   栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其
   它分支上了。
#+begin_src shell
  $ git stash
#+end_src

该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master
上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分
支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。
* git 
** 配置东西的属性  所属人，所属分支
   git config [--system,--global]
   /etc/gitconfig | ~/.gitconfig
   user.name = "用户名或者用户 ID"
   user.email = "邮箱"
   
** 配置SSH 传输
      Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。

      如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可
      以通过以下命令来创建 SSH Key：
      #+begin_src shell
        $ ssh-keygen -t rsa -C "youremail@example.com"
      #+end_src

      然后把公钥 id_rsa.pub 的内容复制到 Github "Account settings" 的 SSH Keys 中。
      : 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
      : 测试是否能够连接 ssh -T git@github.com

** 功能 (本地文件 本地库文件要一致，才能同步远程库文件,三个不一致难搞的)
*** 东西目录初始化(东西都在目录下) 
    init
*** 暂存功能 (修改的东西放到暂存区)  
**** 加入暂存区东西 git add <modified files>/git add .
**** 删除暂存区东西 git rm --cached <file>  
**** 取消暂存区的东西 
     和暂存区删除文件差别不大, 删除会把索引也删除
     git reset HEAD <file>
     git rm --cached 
     是从 stage（index，暂存区） 里面删除文件，当你提交（commit）之后文件就会删除了。
    
     git reset HEAD --file 
     : 回退暂存区里的文件（还原为 HEAD commit 里面该文件的状态），会撤销从上一次提交（commit） 之后的一些操作。
     如果是对于新增文件，这两个操作时等效的。
**** 抛弃工作区修改, 不提交都能恢复
     git checkout . # 抛弃工作区修改
     git checkout <file>
**** 用别的分支的文件替换同名文件
     用 HEAD 指向的 master(默认主分支) 分支中的全部或者部分文件替换
     git checkout HEAD .
     git checkout HEAD <file>
**** 用两次确认的恢复草稿
     此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交
*** 仓库功能(清空暂存区，把东西放到本地版本库)
**** 保存到本地版本库(当前分支)
     git commit -m "msg"
     也可以将 git add 与 git commit 用一个指令完成
     git commit -a -m "msg"
**** 反转(用本地版本库的东西替换掉本地的文件,再执行一次反过来)
     git revert HEAD                  撤销前一次 commit
     git revert HEAD^               撤销前前一次 commit
     git revert commit-id（比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。
     git revert 是提交一个新的版本，将需要 revert 的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。
**** 版本库分库
***** 创建分支
      git branch (branchname)
***** 切换分支
      git checkout (branchname)
      当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容，所以多个分支不需要多个目录。
***** 合并分支, 然后可以删除分支
      git merge test 
      把 test 分支合并到当前分支
***** 删除分支
      git branch -d (branchname)
***** 隐藏
      git stash
      git pull
      git stash pop
      接下来 diff 一下此文件看看自动合并的情况，并作出相应修改。

      git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。
      git stash pop: 从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 Stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。
      git stash list: 显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
      git stash clear: 清空 Git 栈。此时使用 gitg 等图形化工具会发现，原来 stash 的哪些节点都消失了。
     
      2.放弃本地修改，直接覆盖之
      git reset --hard
      git pull

***** 忘了切分支
      可以先用 git stash save xxx 来保存工作区的内容，然后新建 一个分支并调用 git stash pop
*** 远程仓库(把本地版本库的东西放到中心服务器)
**** 克隆远程到本地
     git clone RESP
     git clone --depth=1 RESP 只克隆最新的
**** 添加要提交的中心服务器
     git remote add origin https://github.com/hanyudeye/test.git 添加远程源 
**** 远程的东西与本地同步
     git push -u origin master
**** 更新本地的版本库
     git pull
     git pull git://github.com/tom/test.git
**** 查看远程分支
     git branch -r # 查看远程 branch
     git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的 bug_fix_remote branch 并命名为 bug_fix_local
**** 修改远程仓库 
***** 1.修改命令
     git remote  set-url origin [url]
***** 2.先删后加
     git remote rm origin
     git remote add origin [url]
**** 强制覆盖本地, 这里不想覆盖的也要覆盖
     git fetch --all
     git reset --hard origin/master
     git pull
*** 文件日志
**** 状态 status   
     git status
     git status -s 简短信息
     git remote -v 列出服务器地址
     git diff   尚未缓存的改动：
     git diff --cached   查看已缓存的改动：
     git diff HEAD  查看已缓存的与未缓存的所有改动：
   
     git diff branch1 branch2 --stat   //显示出所有有差异的文件列表
     git diff branch1 branch2 文件名(带路径)   //显示指定文件的详细差异
     git diff branch1 branch2                   //显示出所有有差异的文件的详细差异

     git diff --stat   显示摘要而非整个 diff
     A: 你本地新增的文件（服务器上没有）.
     C: 文件的一个新拷贝.
     D: 你本地删除的文件（服务器上还在）.
     M: 文件的内容或者 mode 被修改了.
     R: 文件名被修改了。
     T: 文件的类型被修改了。
     U: 文件没有被合并(你需要完成合并才能进行提交)。
     X: 未知状态(很可能是遇到 git 的 bug 了，你可以向 git 提交 bug report)。
     在 man git diff-files 中可以查到这些标志的说明
**** Git 查看提交历史
     git log
     git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
     --author 指定用户日志
     如果你要指定日期，可以执行几个选项：--since 和 --before，但
     是你也可以用 --until 和 --after。
**** 某次提交的内容 
     git show # 显示某次提交的内容 git show $id
** 忽略版本文件 gitignore
   以斜杠“/”开头表示目录； 
   以星号“*”通配多个字符；
   以问号“?”通配单个字符
   以方括号“[]”包含单个字符的匹配列表；
   以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
   规则：/fd1/*
   说明：忽略根目录下的 /fd1/ 目录的全部内容；根目录指项目的的根目录
* svn
** svn 重新验证证书 ->会在用户名和密码错误的情况下重新验证 
   Error:  “Server certificate verification failed: issuer is not trusted”
   
   使用终端执行如下命令：svn list https://your.repository.url 接下来选择对应的
   （临时）/（永久）即可。
** 功能
   查看修改的文件记录
   svn cat -- 显示特定版本的某文件内容。
   svn list -- 显示一个目录或某一版本存在的文件列表。
   svn log -- 显示 svn 的版本 log，含作者、日期、路径等。
   svn diff -- 显示特定修改的行级详细信息。

   list 示例：

   svn list http://svn.test.com/svn     #查看目录中的文件。
   svn list -v http://svn.test.com/svn  #查看详细的目录的信息(修订人,版本号,文件大小等)。
   svn list [-v]                        #查看当前当前工作拷贝的版本库 URL。
   cat 示例：

   svn cat -r 4 test.c     #查看版本 4 中的文件 test.c 的内容,不进行比较。
   diff 示例：

   svn diff               #什么都不加，会坚持本地代码和缓存在本地.svn 目录下的信息的不同;信息太多，没啥用处。
   svn diff -r 3          #比较你的本地代码和版本号为 3 的所有文件的不同。
   svn diff -r 3 text.c   #比较你的本地代码和版本号为 3 的 text.c 文件的不同。
   svn diff -r 5:6        #比较版本 5 和版本 6 之间所有文件的不同。
   svn diff -r 5:6 text.c #比较版本 5 和版本 6 之间的 text.c 文件的变化。
   svn diff -c 6 test.c    #比较版本 5 和版本 6 之间的 text.c 文件的变化。
   log 示例：

   svn log         #什么都不加会显示所有版本 commit 的日志信息:版本、作者、日期、comment。
   svn log -r 4:20 #只看版本 4 到版本 20 的日志信息，顺序显示。
   svn log -r 20:5 #显示版本 20 到 4 之间的日志信息，逆序显示。
   svn log test.c  #查看文件 test.c 的日志修改信息。
   svn log -r 8 -v #显示版本 8 的详细修改日志，包括修改的所有文件列表信息。
   svn log -r 8 -v -q   #显示版本 8 的详细提交日志，不包括 comment。
   svn log -v -r 88:866 #显示从版本 88 到版本 866 之间，当前代码目录下所有变更的详细信息 。
   svn log -v dir  #查看目录的日志修改信息,需要加 v。
   svn log http://foo.com/svn/trunk/code/  #显示代码目录的日志信息。
   常用命令

   svn add file|dir -- 添加文件或整个目录
   svn checkout -- 获取 svn 代码
   svn commit  -- 提交本地修改代码
   svn status    -- 查看本地修改代码情况：修改的或本地独有的文件详细信息
   svn merge   -- 合并 svn 和本地代码
   svn revert   -- 撤销本地修改代码
   svn resolve -- 合并冲突代码

   svn help [command] -- 查看 svn 帮助，或特定命令帮助
   svn diff 个性化定制
   svn 配置文件: ~/.subversion/config

   修改~/.subversion/config，找到如下配置行：

   # diff-cmd = diff_program (diff, gdiff, etc.)
   将上面那个脚本的路径添加进去就行，修改为

   diff-cmd = /usr/local/bin/diffwrap.sh  #绝对路径
   这样 svn diff 命令就会默认使用 vimdiff 比较文件。

   diffwrap.sh 文件
   #! /bin/bash

   # for svn diff: 修改~/.subversion/config，找到如下配置行：
   # diff-cmd = diff_program (diff, gdiff, etc.)
   # diff-cmd = ~/bin/diffwrap.sh

   # 参数大于 5 时，去掉前 5 个参数；参数小于 5，失败，什么也不做
   shift 5

   # 使用 vimdiff 比较
   vimdiff "$@"
