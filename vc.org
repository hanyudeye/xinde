ABC
* git
** 工作流程
   #+BEGIN_SRC 
   本地  本地仓库 远程仓库
   #+END_SRC
  * 克隆 Git 资源作为工作目录。
  : git clone --depth=1 RESP 只克隆最新的
  * 在克隆的资源上添加或修改文件。
  * 如果其他人修改了，你可以更新资源。pull/push
  * 在提交前查看修改。
  * 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交,commit/checkout
** 配置
   git config [--system,--global]
   /etc/gitconfig | ~/.gitconfig
   user.name = "用户名或者用户ID"
   user.email = "邮箱"
   ssh-keygen -C 'you email address@gmail.com' -t rsa
   : 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
   : 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
*** 上传公钥
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。
** 管理 工作区、暂存区和版本库
*** 创建一个版本库
    git init <directory>
    git clone git://git.kernel.org/pub/scm/git/git.git <directory>
    git remote add origin git@github.com:hanyudeye/os.git
*** git tag
*** git branch
*** git checkout
*** 将修改存入暂存区
    git add <modified files>/git add .
*** 暂存区删除文件
    git rm --cached <file>
*** 删除工作区和暂存区文件
git rm <file>
*** 取消已缓存的内容
    git reset HEAD
*** 暂存区全部或指定的文件替换工作区的文件。这个操作很危险
    git checkout .
    git checkout -- <file>
*** 重命名
    git mv 命令做得所有事情就是 git rm --cached 命令的操作，重命
    名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。
*** 用 HEAD 指向的 master 分支中的全部或者部分文件替换
git checkout HEAD .
git checkout HEAD <file>
*** 提交到版本库中
    git commit -m "msg"
    也可以将git add与git commit用一个指令完成
    git commit -a -m "msg"
*** 远程同步
    git push
*** 更新本地端的repo
    git pull/git pull git://github.com/tom/test.git
*** 查看状态
    git status
    git status -s 简短信息
    git remote -v 列出服务器地址
    git diff   尚未缓存的改动：
    git diff --cached   查看已缓存的改动：
    git diff HEAD  查看已缓存的与未缓存的所有改动：
    git diff --stat   显示摘要而非整个diff
    A: 你本地新增的文件（服务器上没有）.
    C: 文件的一个新拷贝.
    D: 你本地删除的文件（服务器上还在）.
    M: 文件的内容或者mode被修改了.
    R: 文件名被修改了。
    T: 文件的类型被修改了。
    U: 文件没有被合并(你需要完成合并才能进行提交)。
    X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。
    在man git diff-files中可以查到这些标志的说明
** Git 分支管理
*** 创建分支命令：
git branch (branchname)
*** 切换分支命令:
git checkout (branchname)
当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工
作目录的内容，所以多个分支不需要多个目录。
*** 合并分支命令:
git merge 
*** 列出分支基本命令：
git branch
*** 创建新分支并立即切换到该分支下，从而在该分支中操作
git checkout -b (newbranchname)
*** 删除分支命令：
git branch -d (branchname)
*** 把bug_fix这个branch和现在的branch合并
git merge bug_fix 
*** Git 查看提交历史
git log
git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
 --author 指定用户日志
如果你要指定日期，可以执行几个选项：--since 和 --before，但
是你也可以用 --until 和 --after。
git show 可以看某次的变更
*** 查看远程分支
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local
** .gitignore
*** 配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；

A Git Porcelain inside Emacs

Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains. (less)

Staging and otherwise applying changes is one of the most important features in a Git porcelain and here Magit outshines anything else, including Git itself. Git’s own staging interface (git add --patch) is so cumbersome that many users only use it in exceptional cases. In Magit staging a hunk or even just part of a hunk is as trivial as staging all changes made to a file.

The most visible part of Magit’s interface is the status buffer, which displays information about the current repository. Its content is created by running several Git commands and making their output actionable. Among other things, it displays information about the current branch, lists unpulled and unpushed changes and contains sections displaying the staged and unstaged changes. That might sound noisy, but, since sections are collapsible, it’s not.

To stage or unstage a change one places the cursor on the change and then types s or u. The change can be a file or a hunk, or when the region is active (i.e. when there is a selection) several files or hunks, or even just part of a hunk. The change or changes that these commands - and many others - would act on are highlighted.

Magit also implements several other “apply variants” in addition to staging and unstaging. One can discard or reverse a change, or apply it to the working tree. Git’s own porcelain only supports this for staging and unstaging and you would have to do something like git diff ... | ??? | git apply ... to discard, revert, or apply a single hunk on the command line. In fact that’s exactly what Magit does internally (which is what lead to the term “apply variants”).

Magit isn’t just for Git experts, but it does assume some prior experience with Git as well as Emacs. That being said, many users have reported that using Magit was what finally taught them what Git it is capable off and how to use it to its fullest. Other users wished they had switched to Emacs sooner so that they would have gotten their hands on Magit earlier.

While one has to know the basic features of Emacs to be able to make full use of Magit, acquiring just enough Emacs skills doesn’t take long and is worth it, even for users who prefer other editors. Vim users are advised to give Evil the “Extensible VI Layer for Emacs”, and Spacemacs an “Emacs starter-kit focused on Evil” a try.

Magit provides a consistent and efficient Git porcelain. After a short learning period, you will be able to perform most of your daily version control tasks faster than you would on the command line. You will likely also start using features that seemed too daunting in the past.

Magit fully embraces Git. It exposes many advanced features using a simple but flexible interface instead of only wrapping the trivial ones like many GUI clients do. Of course Magit supports logging, cloning, pushing, and other commands that usually don’t fail in spectacular ways; but it also supports tasks that often cannot be completed in a single step. Magit fully supports tasks such as merging, rebasing, cherry-picking, reverting, and blaming by not only providing a command to initiate these tasks but also by displaying context sensitive information along the way and providing commands that are useful for resolving conflicts and resuming the sequence after doing so.

Magit wraps and in many cases improves upon at least the following Git porcelain commands: add, am, bisect, blame, branch, checkout, cherry, cherry-pick, clean, clone, commit, config, describe, diff, fetch, format-patch, init, log, merge, merge-tree, mv, notes, pull, rebase, reflog, remote, request-pull, reset, revert, rm, show, stash, submodule, and tag. Many more Magit porcelain commands are implemented on top of Git plumbing commands.
* git本地仓库关联远程仓库的两种方式：
1.将远程的代码clone到本地仓库
1.git clone现有的项目（https | SSH）
SSH：
检查你的电脑中是否有密匙对id_rsa id_rsa.pub
没有的话，创建密匙对  ssh-keygen -t rsa -b 4096 -C "你的git中设置的邮箱"
检查你的ssh-agent是否是活跃的 eval "$(ssh-agent -s)"
将私匙添加到 ssh-add  ~/.ssh/id_rsa
然后将公匙复制后添加到git网站中，如github
测试是否能够连接ssh -T git@github.com
克隆到本地git clone git@github.com:hongminzhang/zhm.git

2.将本地的已有项目关联到github上的新的项目上
在github上新建一个仓库，然后在本地仓库中执行git remote add origin git@github.com:stormzhang/test.git
origin是仓库的名字，可能你的本地项目关联着几个仓库，你可以根据仓库的名字
git push origin master 将代码提交到不同仓库中，可以指定分支
然后执行git pull origin master 先将github上的代码pull下来
然后在git push origin master

* git mode
** 单屏显示版本文件状态
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-magit-status-fullscreen t))
#+END_SRC
** Magit auto-complete
#+BEGIN_SRC emacs-lisp
  (setq magit-repository-directories '("~/repos/"))
#+END_SRC
** Magit SVN plugin
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-enable-magit-svn-plugin t))
#+END_SRC
** Global git commit mode
Spacemacs can be used as the =$EDITOR= (or =$GIT_EDITOR=) for editing git
commits messages. To enable this you have to add the following line to your
=dotspacemacs/user-config=:

#+begin_src emacs-lisp
(global-git-commit-mode t)
#+end_src

** Git-Flow
Git-flow is a standardized branching pattern for git repositories with the aim
of making things more manageable. While there are tools to assist with making
this easier, these do nothing you couldn't do manually.

Support requires installation of the git-flow extensions. Please reference their
[[https://github.com/petervanderdoes/gitflow/wiki][installation page]] for assistance.

** Org integration
   See the commentary section of the package [[https://github.com/magit/orgit/blob/master/orgit.el#L28][here]].
* Working with Git
Git commands (start with ~g~):

| Key Binding | Description                                         |
|-------------+-----------------------------------------------------|
| ~SPC g >~   | show submodule prompt                               |
| ~SPC g b~   | open a =magit= blame                                |
| ~SPC g f h~ | show file commits history                           |
| ~SPC g H c~ | clear highlights                                    |
| ~SPC g H h~ | highlight regions by age of commits                 |
| ~SPC g H t~ | highlight regions by last updated time              |
| ~SPC g I~   | open =helm-gitignore=                               |
| ~SPC g s~   | open a =magit= status window                        |
| ~SPC g S~   | stage current file                                  |
| ~SPC g m~   | magit dispatch popup                                |
| ~SPC g M~   | display the last commit message of the current line |
| ~SPC g t~   | launch the git time machine                         |
| ~SPC g U~   | unstage current file                                |

- Highlight by age of commit or last update time is provided by
 [[https://github.com/syohex/emacs-smeargle][smeargle]].
- Git time machine is provided by [[https://github.com/pidu/git-timemachine][git-timemachine]].
- Git last commit message per line is provided by [[https://github.com/syohex/emacs-git-messenger][git-messenger]].

** Magit
Spacemacs uses [[http://magit.vc/][magit]] to manage Git repositories.

To open a =status buffer=, type in a buffer of a Git repository: ~SPC g s~.
The central key binding hub of Magit is available on ~SPC g m~.

Spacemacs uses [[https://github.com/justbur/evil-magit][evil-magit]] for key bindings in magit buffers (unless your editing
style is set to emacs, in which case you get the default magit bindings), which
are the standard magit key bindings with some minimal changes to make them
comfortable for evil users.

Here are the often used bindings inside a =status buffer=:

| Key Binding | Description                                                         |
|-------------+---------------------------------------------------------------------|
| ~/~         | evil-search                                                         |
| ~$~         | open =command output buffer=                                        |
| ~c c~       | open a =commit message buffer=                                      |
| ~b b~       | checkout a branch                                                   |
| ~b c~       | create a branch                                                     |
| ~f f~       | fetch changes                                                       |
| ~F (r) u~   | pull tracked branch and rebase                                      |
| ~gr~        | refresh                                                             |
| ~j~         | goto next magit section                                             |
| ~C-j~       | next visual line                                                    |
| ~k~         | goto previous magit section                                         |
| ~C-k~       | previous visual line                                                |
| ~l l~       | open =log buffer=                                                   |
| ~n~         | next search occurrence                                              |
| ~N~         | previous search occurrence                                          |
| ~o~         | revert item at point                                                |
| ~P u~       | push to tracked branch                                              |
| ~P m~       | push to matching branch  (e.g., upstream/develop to origin/develop) |
| ~q~         | quit                                                                |
| ~s~         | on a file or hunk in a diff: stage the file or hunk                 |
| ~x~         | discard changes                                                     |
| ~+~         | on a hunk: increase hunk size                                       |
| ~-~         | on a hunk: decrease hunk size                                       |
| ~S~         | stage all                                                           |
| ~TAB~       | on a file: expand/collapse diff                                     |
| ~u~         | on a staged file: unstage                                           |
| ~U~         | unstage all staged files                                            |
| ~v or V~    | select multiple lines                                               |
| ~z z~       | stash changes                                                       |

** Staging lines
Magit allows you to stage specific lines by selecting them in a diff and hitting
=s= to stage. Due to inconsistencies between Vim and Emacs editing styles, if
you enter visual line state with =V=, you will stage one more line than
intended. To work around this, you can use =v= instead (since Magit only stages
whole lines, in any case).

** Commit message editing buffer
In a commit message buffer press ~​,​c~ (if =dotspacemacs-major-mode-leader-key= is ~​,​~)
or ~C-c C-c~ to commit the changes with the entered message. Pressing ~​,​a~ or ~C-c C-k~
will discard the commit message.

| Key Binding | Description |
|-------------+-------------|
| ~h~         | go left     |
| ~j~         | go down     |
| ~k~         | go up       |
| ~l~         | go right    |

** Interactive rebase buffer

| Key Binding | Description    |
|-------------+----------------|
| ~c~ or ~p~  | pick           |
| ~e~         | edit           |
| ~f~         | fixup          |
| ~j~         | go down        |
| ~M-j~       | move line down |
| ~k~         | go up          |
| ~M-k~       | move line up   |
| ~d~ or ~x~  | kill line      |
| ~r~         | reword         |
| ~s~         | squash         |
| ~u~         | undo           |
| ~y~         | insert         |
| ~!~         | execute        |

** Quick guide for recurring use cases in Magit
- Amend a commit:
  - ~l l~ to open =log buffer=
  - ~c a~ on the commit you want to amend
  - ~​,​c~ or ~C-c C-c~ to submit the changes
- Squash last commit:
  - ~l l~ to open =log buffer=
  - ~r e~ on the second to last commit, it opens the =rebase buffer=
  - ~j~ to put point on last commit
  - ~s~ to squash it
  - ~​,​c~ or ~C-c C-c~ to continue to the =commit message buffer=
  - ~​,​c~ or ~C-c C-c~ again when you have finished to edit the commit message
- Force push a squashed commit:
  - in the =status buffer= you should see the new commit unpushed and the old
    commit unpulled
  - ~P -f P~ for force a push (*beware* usually it is not recommended to rewrite
    the history of a public repository, but if you are *sure* that you are the
    only one to work on a repository it is ok - i.e. in your fork).
- Add upstream remote (the parent repository you have forked):
  - ~M~ to open the =remote popup=
  - ~a~ to add a remote, type the name (i.e. =upstream=) and the URL
- Pull changes from upstream (the parent repository you have forked) and push:
  - ~F -r C-u F~ and choose =upstream= or the name you gave to it
  - ~P P~ to push the commit to =origin=

** Git-Flow
[[https://github.com/jtatarik/magit-gitflow][magit-gitflow]] provides git-flow commands in its own magit menu.

| Key Binding | Description             |
|-------------+-------------------------|
| ~%~         | open magit-gitflow menu |

** Git time machine
[[https://github.com/pidu/git-timemachine][git-timemachine]] allows to quickly browse the commits of the current buffer.

| Key Binding | Description                                        |
|-------------+----------------------------------------------------|
| ~SPC g t~   | start git timemachine and initiate transient-state |
| ~c~         | show current commit                                |
| ~n~         | show next commit                                   |
| ~N~         | show previous commit                               |
| ~p~         | show previous commit                               |
| ~q~         | leave transient-state and git timemachine          |
| ~Y~         | copy current commit hash                           |

** Git links to web services
These key bindings allow to quickly construct URLs pointing to a given commit
or lines in a file hosted on Git web services like GitHub, GitLab, Bitbucket...

| Key Binding | Description                                                            |
|-------------+------------------------------------------------------------------------|
| ~SPC g l c~ | on a commit hash, browse to the current file at this commit            |
| ~SPC g l C~ | on a commit hash, create link to the file at this commit and copy it   |
| ~SPC g l l~ | on a region, browse to file at current lines position                  |
| ~SPC g l L~ | on a region, create a link to the file highlighting the selected lines |

*Notes:*
- You can use the universal argument ~SPC u~ to select a remote repository.
- When the link is opened, the URL is also copied in the kill ring, you can
  override this behavior by setting the variable =git-link-open-in-browser= to
  =nil=.
* git
  git [--version] [--help] [-C <path>] [-c <name>=<value>]
  [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
  [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
  [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
  <command> [<args>]

  Git is a fast, scalable, distributed revision control
  system with an unusually rich command set that provides
  both high-level operations and full access to internals.

  See gittutorial(7) to get started, then see giteveryday(7)
  for a useful minimum set of commands. The Git User’s
  Manual[1] has a more in-depth introduction.

  After you mastered the basic concepts, you can come back to
  this page to learn what commands Git offers. You can learn
  more about individual Git commands with "git help command".
  gitcli(7) manual page gives you an overview of the
  command-line command syntax.

  Formatted and hyperlinked version of the latest Git
  documentation can be viewed at
  http://git-htmldocs.googlecode.com/git/git.html.

  OPTIONS
  --version
  Prints the Git suite version that the git program came
  from.

  --help
  Prints the synopsis and a list of the most commonly
  used commands. If the option --all or -a is given then
  all available commands are printed. If a Git command is
  named this option will bring up the manual page for
  that command.

  Other options are available to control how the manual
  page is displayed. See git-help(1) for more
  information, because git --help ...  is converted
  internally into git help ....

  -C <path>
  Run as if git was started in <path> instead of the
  current working directory. When multiple -C options are
  given, each subsequent non-absolute -C <path> is
  interpreted relative to the preceding -C <path>.

  This option affects options that expect path name like
  --git-dir and --work-tree in that their interpretations
  of the path names would be made relative to the working
  directory caused by the -C option. For example the
  following invocations are equivalent:

  git --git-dir=a.git --work-tree=b -C c status
  git --git-dir=c/a.git --work-tree=c/b status

  -c <name>=<value>
  Pass a configuration parameter to the command. The
  value given will override values from configuration
  files. The <name> is expected in the same format as
  listed by git config (subkeys separated by dots).

  Note that omitting the = in git -c foo.bar ...  is
  allowed and sets foo.bar to the boolean true value
  (just like [foo]bar would in a config file). Including
  the equals but with an empty value (like git -c
  foo.bar= ...) sets foo.bar to the empty string.

  --exec-path[=<path>]
  Path to wherever your core Git programs are installed.
  This can also be controlled by setting the
  GIT_EXEC_PATH environment variable. If no path is
  given, git will print the current setting and then
  exit.

  --html-path
  Print the path, without trailing slash, where Git’s
  HTML documentation is installed and exit.

  --man-path
  Print the manpath (see man(1)) for the man pages for
  this version of Git and exit.

  --info-path
  Print the path where the Info files documenting this
  version of Git are installed and exit.

  -p, --paginate
  Pipe all output into less (or if set, $PAGER) if
  standard output is a terminal. This overrides the
  pager.<cmd> configuration options (see the
  "Configuration Mechanism" section below).

  --no-pager
  Do not pipe Git output into a pager.

  --git-dir=<path>
  Set the path to the repository. This can also be
  controlled by setting the GIT_DIR environment variable.
  It can be an absolute path or relative path to current
  working directory.

  --work-tree=<path>
  Set the path to the working tree. It can be an absolute
  path or a path relative to the current working
  directory. This can also be controlled by setting the
  GIT_WORK_TREE environment variable and the
  core.worktree configuration variable (see core.worktree
  in git-config(1) for a more detailed discussion).

  --namespace=<path>
  Set the Git namespace. See gitnamespaces(7) for more
  details. Equivalent to setting the GIT_NAMESPACE
  environment variable.

  --bare
  Treat the repository as a bare repository. If GIT_DIR
  environment is not set, it is set to the current
  working directory.

  --no-replace-objects
  Do not use replacement refs to replace Git objects. See
  git-replace(1) for more information.

  --literal-pathspecs
  Treat pathspecs literally (i.e. no globbing, no
  pathspec magic). This is equivalent to setting the
  GIT_LITERAL_PATHSPECS environment variable to 1.

  --glob-pathspecs
  Add "glob" magic to all pathspec. This is equivalent to
  setting the GIT_GLOB_PATHSPECS environment variable to
  1. Disabling globbing on individual pathspecs can be
     done using pathspec magic ":(literal)"

     --noglob-pathspecs
     Add "literal" magic to all pathspec. This is equivalent
     to setting the GIT_NOGLOB_PATHSPECS environment
     variable to 1. Enabling globbing on individual
     pathspecs can be done using pathspec magic ":(glob)"

     --icase-pathspecs
     Add "icase" magic to all pathspec. This is equivalent
     to setting the GIT_ICASE_PATHSPECS environment variable
     to 1.

     GIT COMMANDS
     We divide Git into high level ("porcelain") commands and
     low level ("plumbing") commands.

     HIGH-LEVEL COMMANDS (PORCELAIN)
     We separate the porcelain commands into the main commands
     and some ancillary user utilities.

     Main porcelain commands
     git-add(1)
     Add file contents to the index.

     git-am(1)
     Apply a series of patches from a mailbox.

     git-archive(1)
     Create an archive of files from a named tree.

     git-bisect(1)
     Use binary search to find the commit that introduced a
     bug.

     git-branch(1)
     List, create, or delete branches.

     git-bundle(1)
     Move objects and refs by archive.

     git-checkout(1)
     Switch branches or restore working tree files.

     git-cherry-pick(1)
     Apply the changes introduced by some existing commits.

     git-citool(1)
     Graphical alternative to git-commit.

     git-clean(1)
     Remove untracked files from the working tree.

     git-clone(1)
     Clone a repository into a new directory.

     git-commit(1)
     Record changes to the repository.

     git-describe(1)
     Describe a commit using the most recent tag reachable
     from it.

     git-diff(1)
     Show changes between commits, commit and working tree,
     etc.

     git-fetch(1)
     Download objects and refs from another repository.

     git-format-patch(1)
     Prepare patches for e-mail submission.

     git-gc(1)
     Cleanup unnecessary files and optimize the local
     repository.

     git-grep(1)
     Print lines matching a pattern.

     git-gui(1)
     A portable graphical interface to Git.

     git-init(1)
     Create an empty Git repository or reinitialize an
     existing one.

     git-log(1)
     Show commit logs.

     git-merge(1)
     Join two or more development histories together.

     git-mv(1)
     Move or rename a file, a directory, or a symlink.

     git-notes(1)
     Add or inspect object notes.

     git-pull(1)
     Fetch from and integrate with another repository or a
     local branch.

     git-push(1)
     Update remote refs along with associated objects.

     git-rebase(1)
     Forward-port local commits to the updated upstream
     head.

     git-reset(1)
     Reset current HEAD to the specified state.

     git-revert(1)
     Revert some existing commits.

     git-rm(1)
     Remove files from the working tree and from the index.

     git-shortlog(1)
     Summarize git log output.

     git-show(1)
     Show various types of objects.

     git-stash(1)
     Stash the changes in a dirty working directory away.

     git-status(1)
     Show the working tree status.

     git-submodule(1)
     Initialize, update or inspect submodules.

     git-tag(1)
     Create, list, delete or verify a tag object signed with
     GPG.

     git-worktree(1)
     Manage multiple working trees.

     gitk(1)
     The Git repository browser.

     Ancillary Commands
     Manipulators:

     git-config(1)
     Get and set repository or global options.

     git-fast-export(1)
     Git data exporter.

     git-fast-import(1)
     Backend for fast Git data importers.

     git-filter-branch(1)
     Rewrite branches.

     git-mergetool(1)
     Run merge conflict resolution tools to resolve merge
     conflicts.

     git-pack-refs(1)
     Pack heads and tags for efficient repository access.

     git-prune(1)
     Prune all unreachable objects from the object database.

     git-reflog(1)
     Manage reflog information.

     git-relink(1)
     Hardlink common objects in local repositories.

     git-remote(1)
     Manage set of tracked repositories.

     git-repack(1)
     Pack unpacked objects in a repository.

     git-replace(1)
     Create, list, delete refs to replace objects.

     Interrogators:

     git-annotate(1)
     Annotate file lines with commit information.

     git-blame(1)
     Show what revision and author last modified each line
     of a file.

     git-cherry(1)
     Find commits yet to be applied to upstream.

     git-count-objects(1)
     Count unpacked number of objects and their disk
     consumption.

     git-difftool(1)
     Show changes using common diff tools.

     git-fsck(1)
     Verifies the connectivity and validity of the objects
     in the database.

     git-get-tar-commit-id(1)
     Extract commit ID from an archive created using
     git-archive.

     git-help(1)
     Display help information about Git.

     git-instaweb(1)
     Instantly browse your working repository in gitweb.

     git-merge-tree(1)
     Show three-way merge without touching index.

     git-rerere(1)
     Reuse recorded resolution of conflicted merges.

     git-rev-parse(1)
     Pick out and massage parameters.

     git-show-branch(1)
     Show branches and their commits.

     git-verify-commit(1)
     Check the GPG signature of commits.

     git-verify-tag(1)
     Check the GPG signature of tags.

     git-whatchanged(1)
     Show logs with difference each commit introduces.

     gitweb(1)
     Git web interface (web frontend to Git repositories).

     Interacting with Others
     These commands are to interact with foreign SCM and with
     other people via patch over e-mail.

     git-archimport(1)
     Import an Arch repository into Git.

     git-cvsexportcommit(1)
     Export a single commit to a CVS checkout.

     git-cvsimport(1)
     Salvage your data out of another SCM people love to
     hate.

     git-cvsserver(1)
     A CVS server emulator for Git.

     git-imap-send(1)
     Send a collection of patches from stdin to an IMAP
     folder.

     git-p4(1)
     Import from and submit to Perforce repositories.

     git-quiltimport(1)
     Applies a quilt patchset onto the current branch.

     git-request-pull(1)
     Generates a summary of pending changes.

     git-send-email(1)
     Send a collection of patches as emails.

     git-svn(1)
     Bidirectional operation between a Subversion repository
     and Git.

     LOW-LEVEL COMMANDS (PLUMBING)
     Although Git includes its own porcelain layer, its
     low-level commands are sufficient to support development of
     alternative porcelains. Developers of such porcelains might
     start by reading about git-update-index(1) and git-read-
     tree(1).

     The interface (input, output, set of options and the
     semantics) to these low-level commands are meant to be a
     lot more stable than Porcelain level commands, because
     these commands are primarily for scripted use. The
     interface to Porcelain commands on the other hand are
     subject to change in order to improve the end user
     experience.

     The following description divides the low-level commands
     into commands that manipulate objects (in the repository,
     index, and working tree), commands that interrogate and
     compare objects, and commands that move objects and
     references between repositories.

     Manipulation commands
     git-apply(1)
     Apply a patch to files and/or to the index.

     git-checkout-index(1)
     Copy files from the index to the working tree.

     git-commit-tree(1)
     Create a new commit object.

     git-hash-object(1)
     Compute object ID and optionally creates a blob from a
     file.

     git-index-pack(1)
     Build pack index file for an existing packed archive.

     git-merge-file(1)
     Run a three-way file merge.

     git-merge-index(1)
     Run a merge for files needing merging.

     git-mktag(1)
     Creates a tag object.

     git-mktree(1)
     Build a tree-object from ls-tree formatted text.

     git-pack-objects(1)
     Create a packed archive of objects.

     git-prune-packed(1)
     Remove extra objects that are already in pack files.

     git-read-tree(1)
     Reads tree information into the index.

     git-symbolic-ref(1)
     Read, modify and delete symbolic refs.

     git-unpack-objects(1)
     Unpack objects from a packed archive.

     git-update-index(1)
     Register file contents in the working tree to the
     index.

     git-update-ref(1)
     Update the object name stored in a ref safely.

     git-write-tree(1)
     Create a tree object from the current index.

     Interrogation commands
     git-cat-file(1)
     Provide content or type and size information for
     repository objects.

     git-diff-files(1)
     Compares files in the working tree and the index.

     git-diff-index(1)
     Compare a tree to the working tree or index.

     git-diff-tree(1)
     Compares the content and mode of blobs found via two
     tree objects.

     git-for-each-ref(1)
     Output information on each ref.

     git-ls-files(1)
     Show information about files in the index and the
     working tree.

     git-ls-remote(1)
     List references in a remote repository.

     git-ls-tree(1)
     List the contents of a tree object.

     git-merge-base(1)
     Find as good common ancestors as possible for a merge.

     git-name-rev(1)
     Find symbolic names for given revs.

     git-pack-redundant(1)
     Find redundant pack files.

     git-rev-list(1)
     Lists commit objects in reverse chronological order.

     git-show-index(1)
     Show packed archive index.

     git-show-ref(1)
     List references in a local repository.

     git-unpack-file(1)
     Creates a temporary file with a blob’s contents.

     git-var(1)
     Show a Git logical variable.

     git-verify-pack(1)
     Validate packed Git archive files.

     In general, the interrogate commands do not touch the files
     in the working tree.

     Synching repositories
     git-daemon(1)
     A really simple server for Git repositories.

     git-fetch-pack(1)
     Receive missing objects from another repository.

     git-http-backend(1)
     Server side implementation of Git over HTTP.

     git-send-pack(1)
     Push objects over Git protocol to another repository.

     git-update-server-info(1)
     Update auxiliary info file to help dumb servers.

     The following are helper commands used by the above; end
     users typically do not use them directly.

     git-http-fetch(1)
     Download from a remote Git repository via HTTP.

     git-http-push(1)
     Push objects over HTTP/DAV to another repository.

     git-parse-remote(1)
     Routines to help parsing remote repository access
     parameters.

     git-receive-pack(1)
     Receive what is pushed into the repository.

     git-shell(1)
     Restricted login shell for Git-only SSH access.

     git-upload-archive(1)
     Send archive back to git-archive.

     git-upload-pack(1)
     Send objects packed back to git-fetch-pack.

     Internal helper commands
     These are internal helper commands used by other commands;
     end users typically do not use them directly.

     git-check-attr(1)
     Display gitattributes information.

     git-check-ignore(1)
     Debug gitignore / exclude files.

     git-check-mailmap(1)
     Show canonical names and email addresses of contacts.

     git-check-ref-format(1)
     Ensures that a reference name is well formed.

     git-column(1)
     Display data in columns.

     git-credential(1)
     Retrieve and store user credentials.

     git-credential-cache(1)
     Helper to temporarily store passwords in memory.

     git-credential-store(1)
     Helper to store credentials on disk.

     git-fmt-merge-msg(1)
     Produce a merge commit message.

     git-interpret-trailers(1)
     help add structured information into commit messages.

     git-mailinfo(1)
     Extracts patch and authorship from a single e-mail
     message.

     git-mailsplit(1)
     Simple UNIX mbox splitter program.

     git-merge-one-file(1)
     The standard helper program to use with
     git-merge-index.

     git-patch-id(1)
     Compute unique ID for a patch.

     git-sh-i18n(1)
     Git’s i18n setup code for shell scripts.

     git-sh-setup(1)
     Common Git shell script setup code.

     git-stripspace(1)
     Remove unnecessary whitespace.

     CONFIGURATION MECHANISM
     Git uses a simple text format to store customizations that
     are per repository and are per user. Such a configuration
     file may look like this:

     #
     # A '#' or ';' character indicates a comment.
     #

     ; core variables
     [core]
     ; Don't trust file modes
     filemode = false

     ; user identity
     [user]
     name = "Junio C Hamano"
     email = "gitster@pobox.com"

     Various commands read from the configuration file and
     adjust their operation accordingly. See git-config(1) for a
     list and more details about the configuration mechanism.

     IDENTIFIER TERMINOLOGY
     <object>
     Indicates the object name for any type of object.

     <blob>
     Indicates a blob object name.

     <tree>
     Indicates a tree object name.

     <commit>
     Indicates a commit object name.

     <tree-ish>
     Indicates a tree, commit or tag object name. A command
     that takes a <tree-ish> argument ultimately wants to
     operate on a <tree> object but automatically
     dereferences <commit> and <tag> objects that point at a
     <tree>.

     <commit-ish>
     Indicates a commit or tag object name. A command that
     takes a <commit-ish> argument ultimately wants to
     operate on a <commit> object but automatically
     dereferences <tag> objects that point at a <commit>.

     <type>
     Indicates that an object type is required. Currently
     one of: blob, tree, commit, or tag.

     <file>
     Indicates a filename - almost always relative to the
     root of the tree structure GIT_INDEX_FILE describes.

     SYMBOLIC IDENTIFIERS
     Any Git command accepting any <object> can also use the
     following symbolic notation:

     HEAD
     indicates the head of the current branch.

     <tag>
     a valid tag name (i.e. a refs/tags/<tag> reference).

     <head>
     a valid head name (i.e. a refs/heads/<head> reference).

     For a more complete list of ways to spell object names, see
     "SPECIFYING REVISIONS" section in gitrevisions(7).

     FILE/DIRECTORY STRUCTURE
     Please see the gitrepository-layout(5) document.

     Read githooks(5) for more details about each hook.

     Higher level SCMs may provide and manage additional
     information in the $GIT_DIR.

     TERMINOLOGY
     Please see gitglossary(7).

     ENVIRONMENT VARIABLES
     Various Git commands use the following environment
     variables:

     The Git Repository
     These environment variables apply to all core Git commands.
     Nb: it is worth noting that they may be used/overridden by
     SCMS sitting above Git so take care if using a foreign
     front-end.

     GIT_INDEX_FILE
     This environment allows the specification of an
     alternate index file. If not specified, the default of
     $GIT_DIR/index is used.

     GIT_INDEX_VERSION
     This environment variable allows the specification of
     an index version for new repositories. It won’t affect
     existing index files. By default index file version 2
     or 3 is used. See git-update-index(1) for more
     information.

     GIT_OBJECT_DIRECTORY
     If the object storage directory is specified via this
     environment variable then the sha1 directories are
     created underneath - otherwise the default
     $GIT_DIR/objects directory is used.

     GIT_ALTERNATE_OBJECT_DIRECTORIES
     Due to the immutable nature of Git objects, old objects
     can be archived into shared, read-only directories.
     This variable specifies a ":" separated (on Windows ";"
     separated) list of Git object directories which can be
     used to search for Git objects. New objects will not be
     written to these directories.

     GIT_DIR
     If the GIT_DIR environment variable is set then it
     specifies a path to use instead of the default .git for
     the base of the repository. The --git-dir command-line
     option also sets this value.

     GIT_WORK_TREE
     Set the path to the root of the working tree. This can
     also be controlled by the --work-tree command-line
     option and the core.worktree configuration variable.

     GIT_NAMESPACE
     Set the Git namespace; see gitnamespaces(7) for
     details. The --namespace command-line option also sets
     this value.

     GIT_CEILING_DIRECTORIES
     This should be a colon-separated list of absolute
     paths. If set, it is a list of directories that Git
     should not chdir up into while looking for a repository
     directory (useful for excluding slow-loading network
     directories). It will not exclude the current working
     directory or a GIT_DIR set on the command line or in
     the environment. Normally, Git has to read the entries
     in this list and resolve any symlink that might be
     present in order to compare them with the current
     directory. However, if even this access is slow, you
     can add an empty entry to the list to tell Git that the
     subsequent entries are not symlinks and needn’t be
     resolved; e.g.,
     GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink.

     GIT_DISCOVERY_ACROSS_FILESYSTEM
     When run in a directory that does not have ".git"
     repository directory, Git tries to find such a
     directory in the parent directories to find the top of
     the working tree, but by default it does not cross
     filesystem boundaries. This environment variable can be
     set to true to tell Git not to stop at filesystem
     boundaries. Like GIT_CEILING_DIRECTORIES, this will not
     affect an explicit repository directory set via GIT_DIR
     or on the command line.

     GIT_COMMON_DIR
     If this variable is set to a path, non-worktree files
     that are normally in $GIT_DIR will be taken from this
     path instead. Worktree-specific files such as HEAD or
     index are taken from $GIT_DIR. See gitrepository-
     layout(5) and git-worktree(1) for details. This
     variable has lower precedence than other path variables
     such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY...

     Git Commits
     GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE,
     GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL,
     GIT_COMMITTER_DATE, EMAIL
     see git-commit-tree(1)

     Git Diffs
     GIT_DIFF_OPTS
     Only valid setting is "--unified=??" or "-u??" to set
     the number of context lines shown when a unified diff
     is created. This takes precedence over any "-U" or
     "--unified" option value passed on the Git diff command
     line.

     GIT_EXTERNAL_DIFF
     When the environment variable GIT_EXTERNAL_DIFF is set,
     the program named by it is called, instead of the diff
     invocation described above. For a path that is added,
     removed, or modified, GIT_EXTERNAL_DIFF is called with
     7 parameters:

     path old-file old-hex old-mode new-file new-hex new-mode

     where:

     <old|new>-file
     are files GIT_EXTERNAL_DIFF can use to read the
     contents of <old|new>,

     <old|new>-hex
     are the 40-hexdigit SHA-1 hashes,

     <old|new>-mode
     are the octal representation of the file modes.

     The file parameters can point at the user’s working
     file (e.g.  new-file in "git-diff-files"), /dev/null
     (e.g.  old-file when a new file is added), or a
     temporary file (e.g.  old-file in the index).
     GIT_EXTERNAL_DIFF should not worry about unlinking the
     temporary file --- it is removed when GIT_EXTERNAL_DIFF
     exits.

     For a path that is unmerged, GIT_EXTERNAL_DIFF is
     called with 1 parameter, <path>.

     For each path GIT_EXTERNAL_DIFF is called, two
     environment variables, GIT_DIFF_PATH_COUNTER and
     GIT_DIFF_PATH_TOTAL are set.

     GIT_DIFF_PATH_COUNTER
     A 1-based counter incremented by one for every path.

     GIT_DIFF_PATH_TOTAL
     The total number of paths.

     other
     GIT_MERGE_VERBOSITY
     A number controlling the amount of output shown by the
     recursive merge strategy. Overrides merge.verbosity.
     See git-merge(1)

     GIT_PAGER
     This environment variable overrides $PAGER. If it is
     set to an empty string or to the value "cat", Git will
     not launch a pager. See also the core.pager option in
     git-config(1).

     GIT_EDITOR
     This environment variable overrides $EDITOR and
     $VISUAL. It is used by several Git commands when, on
     interactive mode, an editor is to be launched. See also
     git-var(1) and the core.editor option in git-config(1).

     GIT_SSH, GIT_SSH_COMMAND
     If either of these environment variables is set then
     git fetch and git push will use the specified command
     instead of ssh when they need to connect to a remote
     system. The command will be given exactly two or four
     arguments: the username@host (or just host) from the
     URL and the shell command to execute on that remote
     system, optionally preceded by -p (literally) and the
     port from the URL when it specifies something other
     than the default SSH port.

     $GIT_SSH_COMMAND takes precedence over $GIT_SSH, and is
     interpreted by the shell, which allows additional
     arguments to be included.  $GIT_SSH on the other hand
     must be just the path to a program (which can be a
     wrapper shell script, if additional arguments are
     needed).

     Usually it is easier to configure any desired options
     through your personal .ssh/config file. Please consult
     your ssh documentation for further details.

     GIT_ASKPASS
     If this environment variable is set, then Git commands
     which need to acquire passwords or passphrases (e.g.
     for HTTP or IMAP authentication) will call this program
     with a suitable prompt as command-line argument and
     read the password from its STDOUT. See also the
     core.askPass option in git-config(1).

     GIT_TERMINAL_PROMPT
     If this environment variable is set to 0, git will not
     prompt on the terminal (e.g., when asking for HTTP
     authentication).

     GIT_CONFIG_NOSYSTEM
     Whether to skip reading settings from the system-wide
     $(prefix)/etc/gitconfig file. This environment variable
     can be used along with $HOME and $XDG_CONFIG_HOME to
     create a predictable environment for a picky script, or
     you can set it temporarily to avoid using a buggy
     /etc/gitconfig file while waiting for someone with
     sufficient permissions to fix it.

     GIT_FLUSH
     If this environment variable is set to "1", then
     commands such as git blame (in incremental mode), git
     rev-list, git log, git check-attr and git check-ignore
     will force a flush of the output stream after each
     record have been flushed. If this variable is set to
     "0", the output of these commands will be done using
     completely buffered I/O. If this environment variable
     is not set, Git will choose buffered or record-oriented
     flushing based on whether stdout appears to be
     redirected to a file or not.

     GIT_TRACE
     Enables general trace messages, e.g. alias expansion,
     built-in command execution and external command
     execution.

     If this variable is set to "1", "2" or "true"
     (comparison is case insensitive), trace messages will
     be printed to stderr.

     If the variable is set to an integer value greater than
     2 and lower than 10 (strictly) then Git will interpret
     this value as an open file descriptor and will try to
     write the trace messages into this file descriptor.

     Alternatively, if the variable is set to an absolute
     path (starting with a / character), Git will interpret
     this as a file path and will try to write the trace
     messages into it.

     Unsetting the variable, or setting it to empty, "0" or
     "false" (case insensitive) disables trace messages.

     GIT_TRACE_PACK_ACCESS
     Enables trace messages for all accesses to any packs.
     For each access, the pack file name and an offset in
     the pack is recorded. This may be helpful for
     troubleshooting some pack-related performance problems.
     See GIT_TRACE for available trace output options.

     GIT_TRACE_PACKET
     Enables trace messages for all packets coming in or out
     of a given program. This can help with debugging object
     negotiation or other protocol issues. Tracing is turned
     off at a packet starting with "PACK" (but see
     GIT_TRACE_PACKFILE below). See GIT_TRACE for available
     trace output options.

     GIT_TRACE_PACKFILE
     Enables tracing of packfiles sent or received by a
     given program. Unlike other trace output, this trace is
     verbatim: no headers, and no quoting of binary data.
     You almost certainly want to direct into a file (e.g.,
     GIT_TRACE_PACKFILE=/tmp/my.pack) rather than displaying
     it on the terminal or mixing it with other trace
     output.

     Note that this is currently only implemented for the
     client side of clones and fetches.

     GIT_TRACE_PERFORMANCE
     Enables performance related trace messages, e.g. total
     execution time of each Git command. See GIT_TRACE for
     available trace output options.

     GIT_TRACE_SETUP
     Enables trace messages printing the .git, working tree
     and current working directory after Git has completed
     its setup phase. See GIT_TRACE for available trace
     output options.

     GIT_TRACE_SHALLOW
     Enables trace messages that can help debugging fetching
     / cloning of shallow repositories. See GIT_TRACE for
     available trace output options.

     GIT_LITERAL_PATHSPECS
     Setting this variable to 1 will cause Git to treat all
     pathspecs literally, rather than as glob patterns. For
     example, running GIT_LITERAL_PATHSPECS=1 git log --
     '*.c' will search for commits that touch the path *.c,
     not any paths that the glob *.c matches. You might want
     this if you are feeding literal paths to Git (e.g.,
     paths previously given to you by git ls-tree, --raw
     diff output, etc).

     GIT_GLOB_PATHSPECS
     Setting this variable to 1 will cause Git to treat all
     pathspecs as glob patterns (aka "glob" magic).

     GIT_NOGLOB_PATHSPECS
     Setting this variable to 1 will cause Git to treat all
     pathspecs as literal (aka "literal" magic).

     GIT_ICASE_PATHSPECS
     Setting this variable to 1 will cause Git to treat all
     pathspecs as case-insensitive.

     GIT_REFLOG_ACTION
     When a ref is updated, reflog entries are created to
     keep track of the reason why the ref was updated (which
     is typically the name of the high-level command that
     updated the ref), in addition to the old and new values
     of the ref. A scripted Porcelain command can use
     set_reflog_action helper function in git-sh-setup to
     set its name to this variable when it is invoked as the
     top level command by the end user, to be recorded in
     the body of the reflog.

     GIT_REF_PARANOIA
     If set to 1, include broken or badly named refs when
     iterating over lists of refs. In a normal,
     non-corrupted repository, this does nothing. However,
     enabling it may help git to detect and abort some
     operations in the presence of broken refs. Git sets
     this variable automatically when performing destructive
     operations like git-prune(1). You should not need to
     set it yourself unless you want to be paranoid about
     making sure an operation has touched every ref (e.g.,
     because you are cloning a repository to make a backup).

     GIT_ALLOW_PROTOCOL
     If set, provide a colon-separated list of protocols
     which are allowed to be used with fetch/push/clone.
     This is useful to restrict recursive submodule
     initialization from an untrusted repository. Any
     protocol not mentioned will be disallowed (i.e., this
     is a whitelist, not a blacklist). If the variable is
     not set at all, all protocols are enabled. The protocol
     names currently used by git are:

     ·   file: any local file-based path (including file://
     URLs, or local paths)

     ·   git: the anonymous git protocol over a direct TCP
     connection (or proxy, if configured)

     ·   ssh: git over ssh (including host:path syntax,
     git+ssh://, etc).

     ·   rsync: git over rsync

     ·   http: git over http, both "smart http" and "dumb
     http". Note that this does not include https; if
     you want both, you should specify both as
     http:https.

     ·   any external helpers are named by their protocol
     (e.g., use hg to allow the git-remote-hg helper)

     DISCUSSION
     More detail on the following is available from the Git
     concepts chapter of the user-manual[2] and gitcore-
     tutorial(7).

     A Git project normally consists of a working directory with
     a ".git" subdirectory at the top level. The .git directory
     contains, among other things, a compressed object database
     representing the complete history of the project, an
     "index" file which links that history to the current
     contents of the working tree, and named pointers into that
     history such as tags and branch heads.

     The object database contains objects of three main types:
     blobs, which hold file data; trees, which point to blobs
     and other trees to build up directory hierarchies; and
     commits, which each reference a single tree and some number
     of parent commits.

     The commit, equivalent to what other systems call a
     "changeset" or "version", represents a step in the
     project’s history, and each parent represents an
     immediately preceding step. Commits with more than one
     parent represent merges of independent lines of
     development.

     All objects are named by the SHA-1 hash of their contents,
     normally written as a string of 40 hex digits. Such names
     are globally unique. The entire history leading up to a
     commit can be vouched for by signing just that commit. A
     fourth object type, the tag, is provided for this purpose.

     When first created, objects are stored in individual files,
     but for efficiency may later be compressed together into
     "pack files".

     Named pointers called refs mark interesting points in
     history. A ref may contain the SHA-1 name of an object or
     the name of another ref. Refs with names beginning
     ref/head/ contain the SHA-1 name of the most recent commit
     (or "head") of a branch under development. SHA-1 names of
     tags of interest are stored under ref/tags/. A special ref
     named HEAD contains the name of the currently checked-out
     branch.

     The index file is initialized with a list of all paths and,
     for each path, a blob object and a set of attributes. The
     blob object represents the contents of the file as of the
     head of the current branch. The attributes (last modified
     time, size, etc.) are taken from the corresponding file in
     the working tree. Subsequent changes to the working tree
     can be found by comparing these attributes. The index may
     be updated with new content, and new commits may be created
     from the content stored in the index.

     The index is also capable of storing multiple entries
     (called "stages") for a given pathname. These stages are
     used to hold the various unmerged version of a file when a
     merge is in progress.

     FURTHER DOCUMENTATION
     See the references in the "description" section to get
     started using Git. The following is probably more detail
     than necessary for a first-time user.

     The Git concepts chapter of the user-manual[2] and gitcore-
     tutorial(7) both provide introductions to the underlying
     Git architecture.

     See gitworkflows(7) for an overview of recommended
     workflows.

     See also the howto[3] documents for some useful examples.

     The internals are documented in the Git API
     documentation[4].

     Users migrating from CVS may also want to read gitcvs-
     migration(7).

     AUTHORS
     Git was started by Linus Torvalds, and is currently
     maintained by Junio C Hamano. Numerous contributions have
     come from the Git mailing list <git@vger.kernel.org[5]>.
     http://www.openhub.net/p/git/contributors/summary gives you
     a more complete list of contributors.

     If you have a clone of git.git itself, the output of git-
     shortlog(1) and git-blame(1) can show you the authors for
     specific parts of the project.

     REPORTING BUGS
     Report bugs to the Git mailing list
     <git@vger.kernel.org[5]> where the development and
     maintenance is primarily done. You do not have to be
     subscribed to the list to send a message there.

     SEE ALSO
     gittutorial(7), gittutorial-2(7), giteveryday(7), gitcvs-
     migration(7), gitglossary(7), gitcore-tutorial(7),
     gitcli(7), The Git User’s Manual[1], gitworkflows(7)

     GIT
     Part of the git(1) suite

     NOTES
     1. Git User’s Manual
        file:///usr/share/doc/git/html/user-manual.html

     2. Git concepts chapter of the user-manual
        file:///usr/share/doc/git/html/user-manual.html#git-concepts

     3. howto
        file:///usr/share/doc/git/html/howto-index.html

     4. Git API documentation
        file:///usr/share/doc/git/html/technical/api-index.html

     5. git@vger.kernel.org
        mailto:git@vger.kernel.org

        Git 2.7.4                   03/23/2016                      GIT(1)
* git (存储对象状态的东东) 
** 配置/设置/存储东东的状态
   $ git config --global user.name "Your Name Comes Here"
   $ git config --global user.email you@yourdomain.example.com
   $ git init
   $ git add .
   $ git commit
** 东东副本的行动
   看状态差异 $ git diff --cached
   整体状态差异 $ git status
   $ git log --stat --summary
** 再造一个副本吧
   $ git branch experimental
   表示以后对分支东东行为了 $ git checkout experimental
   改回来$ git checkout master
   并入主分支$ git merge experimental
   删除 $ git branch -d experimental
** 协作
   Bob begins with:
   bob$ git clone /home/alice/project myrepo
   Bob then makes some changes and commits them:
   (edit files)
   bob$ git commit -a
   (repeat as necessary)

   alice$ cd /home/alice/project
   alice$ git pull /home/bob/myrepo master
   或者不合并, 看bob干了什么
   alice$ git fetch /home/bob/myrepo master
   alice$ git log -p HEAD..FETCH_HEAD

   太麻烦, 可以
   alice$ git remote add bob /home/bob/myrepo
   alice$ git fetch bob
   alice$ git log -p master..bob/master
   alice$ git merge bob/master
   alice$ git pull . remotes/bob/master

看log
          $ git show HEAD         # the tip of the current branch
           $ git show experimental # the tip of the "experimental" branch
           $ git show HEAD^  # to see the parent of HEAD
           $ git show HEAD^^ # to see the grandparent of HEAD
           $ git show HEAD~4 # to see the great-great grandparent of HEAD

       Note that merge commits may have more than one parent:

           $ git show HEAD^1 # show the first parent of HEAD (same as HEAD^)
           $ git show HEAD^2 # show the second parent of HEAD

           $ git branch stable v2.5 # start a new branch named "stable" based
                                    # at v2.5
           $ git reset --hard HEAD^ # reset your current branch and working
                                    # directory to its state at HEAD^

           $ git grep "hello" v2.5

           $ git tag v2.5 1b2e1d63ff
           $ git log v2.5..v2.6            # commits between v2.5 and v2.6
           $ git log v2.5..                # commits since v2.5
           $ git log --since="2 weeks ago" # commits from the last 2 weeks
           $ git log v2.5.. Makefile       # commits since v2.5 which modify
                                           # Makefile

* git
** 1.create a new repository on the command line
echo "# test" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/hanyudeye/test.git
git push -u origin master
** 2.push an existing repository from the command line
git remote add origin https://github.com/hanyudeye/test.git
git push -u origin master
* git 
要 参与任何一个 Git 项目的协作,必须要了解该如何管理远程仓库.远程仓库是指托管在网络上的项目仓库,可能会有好多个,其中有些你只能读,另外有些可以写.同他人协作开发某 个项目时,需要管理这些远程仓库,以便推送或拉取数据,分享各自的工作进展.管理远程仓库的工作,包括添加远程库,移除废弃的远程库,管理各式远程库分 支,定义是否跟踪这些分支,等等.本节我们将详细讨论远程库的管理和使用.

　　查看当前的远程库

　　要查看当前配置有哪些远程仓库,可以用 Git remote 命令,它会列出每个远程库的简短名字.在克隆完某个项目后,至少可以看到一个名为 origin 的远程库,git 默认使用这个名字来标识你所克隆的原始仓库:

　　$ git clone git://github.com/schacon/ticgit.git

　　Initialized empty Git repository in /private/tmp/ticgit/.git/

　　remote: Counting objects: 595, done.

　　remote: Compressing objects: 100% (269/269), done.

　　remote: Total 595 (delta 255), reused 589 (delta 253)

　　Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.

　　Resolving deltas: 100% (255/255), done.

　　$ cd ticgit

（1）git remote 不带参数，列出已经存在的远程分支

　　$ git remote

　　origin

（2）git remote -v | --verbose 列出详细信息，在每一个名字后面列出其远程url

此时， -v 选项(译注:此为 –verbose 的简写,取首字母),显示对应的克隆地址:

　　$ git remote -v

　　origin git://github.com/schacon/ticgit.git如果有多个远程仓库,此命令将全部列出.比如在我的 Grit 项目中,可以看到:

　　$ cd grit

　　$ git remote -v

　　bakkdoor git://github.com/bakkdoor/grit.git

　　cho45 git://github.com/cho45/grit.git

　　defunkt git://github.com/defunkt/grit.git

　　koke git://github.com/koke/grit.git

　　origin 这样一来,我就可以非常轻松地从这些用户的仓库中,拉取他们的提交到本地.请注意,上面列出的地址只有 origin 用的是 SSH URL 链接,所以也只有这个仓库我能推送数据上去(我们会在第四章解释原因).

　　添加远程仓库

　　要添加一个新的远程仓库,可以指定一个简单的名字,以便将来引用,运行 git remote add [shortname] [url]:

　　$ git remote

　　origin

　　$ git remote add pb git://github.com/paulboone/ticgit.git

　　$ git remote -v

　　origin git://github.com/schacon/ticgit.git

　　pb git://github.com/paulboone/ticgit.git现在可以用字串 pb 指代对应的仓库地址了.比如说,要抓取所有 Paul 有的,但本地仓库没有的信息,可以运行 git fetch pb:

　　$ git fetch pb

　　remote: Counting objects: 58, done.

　　remote: Compressing objects: 100% (41/41), done.

　　remote: Total 44 (delta 24), reused 1 (delta 0)

　　Unpacking objects: 100% (44/44), done.

　　From git://github.com/paulboone/ticgit

　　* [new branch] master -> pb/master

　　* [new branch] ticgit -> pb/ticgit

现在,Paul 的主干分支(master)已经完全可以在本地访问了,对应的名字是 pb/master,你可以将它合并到自己的某个分支,或者切换到这个分支,看看有些什么有趣的更



二。通过git remote 建立远程仓库


建立远程仓库
最近一直在学习使用git来管理自己的程序，总是今天东学一点，明天西凑一点，到用的时候，总是有些茫然不知所措。

在博客园里看见一篇老好的文章，教我们做笔记啦，但是做完笔记还是要记得总结哦！

来吧，让我们一起来总结吧，今天先来看看git远程的仓库是怎么建立的。

当然，使用git嘛，第一步肯定是得新建一个git仓库，总得有个操作的空间吧,巧妇难为无米之炊嘛。

1.初始化一个空的git仓库

1 software@debian:~$ mkdir yafeng
2 software@debian:~$ cd yafeng/
3 software@debian:~/yafeng$ ls
4 software@debian:~/yafeng$ git init
5 Initialized empty Git repository in /home/software/yafeng/.git/
6 software@debian:~/yafeng$ 
命令注释：

在上面的命令中，真正去初始化的是第四行的那句---git init

当然，还有很多同学会看见加了参数--bare的命令，这个命令会在我们以后慢慢给大家解释，对于不是作为共享仓库，而是作为一个自己操作的仓库，上面这样就足够了。

好了，现在yafeng目录就是我们的据点---git仓库了哦。

下面我们总要做点什么的吧，入宝山总不能光看着哦：

2.向仓库提交我们写的文件

复制代码
1 software@debian:~/yafeng$ echo "our first git repository" >> file
2 software@debian:~/yafeng$ ls
3 file
4 software@debian:~/yafeng$ git add file
5 software@debian:~/yafeng$ git commit -m "the first file to commit" file
6 [master (root-commit) 0c72641] the first file to commit
7  1 files changed, 1 insertions(+), 0 deletions(-)
8  create mode 100644 file
9 software@debian:~/yafeng$ 
复制代码
命令解释：
我们在仓库中新建了一个文件file，作为我们的示例文件。

第4行：将file文件的信息添加到git仓库的索引库中，并没有真正添加到库。当然上例中的file文件只是我们的示例，它是一个路径，因此，可以是文件，更可以是目录。

第5行：将索引库中的内容向git仓库进行提交。这步之后文件file才算真正提交到拉git仓库中。双引号中的内容是根据每次修改的不同内容，由我们自己去填写的，

很多人会看见

　　git commit -a -m “ ”

这条的命令是在你已经add了一个或多个文件过之后，然后修改了这些文件，就可以使用该命令进行提交。

好了，不管怎么样，终于是将文件提交到库了。可是现在的仓库只是一个本地的仓库，我们的目标是变成远程仓库哦，继续吧。

3.在本地仓库添加一个远程仓库,并将本地的master分支跟踪到远程分支

1 software@debian:~/yafeng$ git remote add origin ssh://software@172.16.0.30/~/yafeng/.git
2 software@debian:~/yafeng$ git push origin master
3 software@172.16.0.30's password: 
4 Everything up-to-date
5 software@debian:~/yafeng$ 
命令注释:

第1行:在本地仓库添加一个远程仓库,当然ssh后面的地址是我们本地仓库的地址.

第2行:将本地master分支跟踪到远程分支,在git仓库建立之初就会有一个默认的master分支,当然你如果建立了其他分支,也可以用同样的方法去跟踪.

对于分支的事情,我们会在以后细细的讲述.

做到拉这一步了吗?我告诉你,你已经完成目的了哦,现在的git仓库已经是一个远程仓库了,

不相信吗?我们来测试一次阿:

4.测试

现在本机上看看:

复制代码
 1 software@debian:~/yafeng$ git remote show origin
 2 software@172.16.0.30's password: 
 3 * remote origin
 4   Fetch URL: ssh://software@172.16.0.30/~/yafeng/.git
 5   Push  URL: ssh://software@172.16.0.30/~/yafeng/.git
 6   HEAD branch: master
 7   Remote branch:
 8     master tracked
 9   Local ref configured for 'git push':
10     master pushes to master (up to date)
11 software@debian:~/yafeng$ 
复制代码
代码注释:

第1行:显示远程信息

很多看见这还是会不以为然的,这又能说明什么呢?好,那就来点实际的:

在另一个机子上,远程clone

复制代码
 1 root@yafeng-VirtualBox:~# ls
 2 bin  gittest  read_temp
 3 root@yafeng-VirtualBox:~# git clone ssh://software@172.16.0.30/~/yafeng/.git
 4 Cloning into yafeng...
 5 software@172.16.0.30's password: 
 6 remote: Counting objects: 9, done.
 7 remote: Compressing objects: 100% (3/3), done.
 8 remote: Total 9 (delta 0), reused 0 (delta 0)
 9 Receiving objects: 100% (9/9), done.
10 root@yafeng-VirtualBox:~# ls
11 bin  gittest  read_temp  yafeng
12 root@yafeng-VirtualBox:~# cd yafeng/
13 root@yafeng-VirtualBox:~/yafeng# ls
14 file
15 root@yafeng-VirtualBox:~/yafeng# 
复制代码
代码注释:

第3行:就是远程clone仓库.很明显的对比可以知道多了yafeng目录,而这个yafeng目录里的内容和我们另外一台机子上的内容一样

至此,一个简单的git远程仓库就建好了,简单不,试试吧!!
* svn
什么是svn被锁定 扩展功能清理一下
** svn 重新验证证书 ->会在用户名和密码错误的情况下重新验证 
Error:  “Server certificate verification failed: issuer is not trusted”
使用终端执行如下命令： svn list https://your.repository.url 接下来选择对应的（临时）/（永久）即可。
