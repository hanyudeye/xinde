* git
** git
*** 1.create a new repository on the command line
    echo "# test" >> README.md
    git init
    git add README.md
    git commit -m "first commit"
    git remote add origin https://github.com/hanyudeye/test.git
    git push -u origin master
*** 2.push an existing repository from the command line
 git remote add origin https://github.com/hanyudeye/test.git
 git push -u origin master
** 工作流程
   #+BEGIN_SRC 
   本地  本地仓库 远程仓库
   #+END_SRC
  * 克隆 Git 资源作为工作目录。
  : git clone --depth=1 RESP 只克隆最新的
  * 在克隆的资源上添加或修改文件。
  * 如果其他人修改了，你可以更新资源。pull/push
  * 在提交前查看修改。
  * 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交,commit/checkout
** 配置
   git config [--system,--global]
   /etc/gitconfig | ~/.gitconfig
   user.name = "用户名或者用户ID"
   user.email = "邮箱"
   ssh-keygen -C 'you email address@gmail.com' -t rsa
   : 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
   : 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
*** 上传公钥
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。
** 管理 工作区、暂存区和版本库
*** 创建一个版本库
    git init <directory>
    git clone git://git.kernel.org/pub/scm/git/git.git <directory>
    git remote add origin git@github.com:hanyudeye/os.git
*** git tag
*** git branch
*** git checkout
*** 将修改存入暂存区
    git add <modified files>/git add .
*** 暂存区删除文件
    git rm --cached <file>
*** 删除工作区和暂存区文件
git rm <file>
*** 取消已缓存的内容
    git reset HEAD
*** 暂存区全部或指定的文件替换工作区的文件。这个操作很危险
    git checkout .
    git checkout -- <file>
*** 重命名
    git mv 命令做得所有事情就是 git rm --cached 命令的操作，重命
    名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。
*** 用 HEAD 指向的 master 分支中的全部或者部分文件替换
git checkout HEAD .
git checkout HEAD <file>
*** 提交到版本库中
    git commit -m "msg"
    也可以将git add与git commit用一个指令完成
    git commit -a -m "msg"
*** 远程同步
    git push
*** 更新本地端的repo
    git pull/git pull git://github.com/tom/test.git
*** 查看状态
    git status
    git status -s 简短信息
    git remote -v 列出服务器地址
    git diff   尚未缓存的改动：
    git diff --cached   查看已缓存的改动：
    git diff HEAD  查看已缓存的与未缓存的所有改动：
    git diff --stat   显示摘要而非整个diff
    A: 你本地新增的文件（服务器上没有）.
    C: 文件的一个新拷贝.
    D: 你本地删除的文件（服务器上还在）.
    M: 文件的内容或者mode被修改了.
    R: 文件名被修改了。
    T: 文件的类型被修改了。
    U: 文件没有被合并(你需要完成合并才能进行提交)。
    X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。
    在man git diff-files中可以查到这些标志的说明
** git 分支管理
*** 创建分支命令：
git branch (branchname)
*** 切换分支命令:
git checkout (branchname)
当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工
作目录的内容，所以多个分支不需要多个目录。
*** 合并分支命令:
git merge 
*** 列出分支基本命令：
git branch
*** 创建新分支并立即切换到该分支下，从而在该分支中操作
git checkout -b (newbranchname)
*** 删除分支命令：
git branch -d (branchname)
*** 把bug_fix这个branch和现在的branch合并
git merge bug_fix 
*** Git 查看提交历史
git log
git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
 --author 指定用户日志
如果你要指定日期，可以执行几个选项：--since 和 --before，但
是你也可以用 --until 和 --after。
git show 可以看某次的变更
*** 查看远程分支
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local
** .gitignore
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
   规则：/fd1/*
   说明：忽略根目录下的 /fd1/ 目录的全部内容；
* git本地仓库关联远程仓库的两种方式：
1.将远程的代码clone到本地仓库
1.git clone现有的项目（https | SSH）
SSH：
检查你的电脑中是否有密匙对id_rsa id_rsa.pub
没有的话，创建密匙对  ssh-keygen -t rsa -b 4096 -C "你的git中设置的邮箱"
检查你的ssh-agent是否是活跃的 eval "$(ssh-agent -s)"
将私匙添加到 ssh-add  ~/.ssh/id_rsa
然后将公匙复制后添加到git网站中，如github
测试是否能够连接ssh -T git@github.com
克隆到本地git clone git@github.com:hongminzhang/zhm.git

2.将本地的已有项目关联到github上的新的项目上
在github上新建一个仓库，然后在本地仓库中执行git remote add origin git@github.com:stormzhang/test.git
origin是仓库的名字，可能你的本地项目关联着几个仓库，你可以根据仓库的名字
git push origin master 将代码提交到不同仓库中，可以指定分支
然后执行git pull origin master 先将github上的代码pull下来
然后在git push origin master

* git mode
** 单屏显示版本文件状态
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-magit-status-fullscreen t))
#+END_SRC
** Magit auto-complete
#+BEGIN_SRC emacs-lisp
  (setq magit-repository-directories '("~/repos/"))
#+END_SRC
** Magit SVN plugin
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-enable-magit-svn-plugin t))
#+END_SRC
** Global git commit mode
Spacemacs can be used as the =$EDITOR= (or =$GIT_EDITOR=) for editing git
commits messages. To enable this you have to add the following line to your
=dotspacemacs/user-config=:

#+begin_src emacs-lisp
(global-git-commit-mode t)
#+end_src

** Git-Flow
Git-flow is a standardized branching pattern for git repositories with the aim
of making things more manageable. While there are tools to assist with making
this easier, these do nothing you couldn't do manually.

Support requires installation of the git-flow extensions. Please reference their
[[https://github.com/petervanderdoes/gitflow/wiki][installation page]] for assistance.

** Org integration
   See the commentary section of the package [[https://github.com/magit/orgit/blob/master/orgit.el#L28][here]].
* 快捷键
** Git commands (start with ~g~):
| Key Binding | Description                                         |
|-------------+-----------------------------------------------------|
| ~SPC g >~   | show submodule prompt                               |
| ~SPC g b~   | open a =magit= blame                                |
| ~SPC g f h~ | show file commits history                           |
| ~SPC g H c~ | clear highlights                                    |
| ~SPC g H h~ | highlight regions by age of commits                 |
| ~SPC g H t~ | highlight regions by last updated time              |
| ~SPC g I~   | open =helm-gitignore=                               |
| ~SPC g s~   | open a =magit= status window                        |
| ~SPC g S~   | stage current file                                  |
| ~SPC g m~   | magit dispatch popup                                |
| ~SPC g M~   | display the last commit message of the current line |
| ~SPC g t~   | launch the git time machine                         |
| ~SPC g U~   | unstage current file                                |

** Magit
Spacemacs uses [[http://magit.vc/][magit]] to manage Git repositories.

To open a =status buffer=, type in a buffer of a Git repository: ~SPC g s~.
The central key binding hub of Magit is available on ~SPC g m~.

Here are the often used bindings inside a =status buffer=:

| Key Binding | Description                                                         |
|-------------+---------------------------------------------------------------------|
| ~/~         | evil-search                                                         |
| ~$~         | open =command output buffer=                                        |
| ~c c~       | open a =commit message buffer=                                      |
| ~b b~       | checkout a branch                                                   |
| ~b c~       | create a branch                                                     |
| ~f f~       | fetch changes                                                       |
| ~F (r) u~   | pull tracked branch and rebase                                      |
| ~gr~        | refresh                                                             |
| ~j~         | goto next magit section                                             |
| ~C-j~       | next visual line                                                    |
| ~k~         | goto previous magit section                                         |
| ~C-k~       | previous visual line                                                |
| ~l l~       | open =log buffer=                                                   |
| ~n~         | next search occurrence                                              |
| ~N~         | previous search occurrence                                          |
| ~o~         | revert item at point                                                |
| ~P u~       | push to tracked branch                                              |
| ~P m~       | push to matching branch  (e.g., upstream/develop to origin/develop) |
| ~q~         | quit                                                                |
| ~s~         | on a file or hunk in a diff: stage the file or hunk                 |
| ~x~         | discard changes   复原                                              |
| ~+~         | on a hunk: increase hunk size                                       |
| ~-~         | on a hunk: decrease hunk size                                       |
| ~S~         | stage all                                                           |
| ~TAB~       | on a file: expand/collapse diff                                     |
| ~u~         | on a staged file: unstage                                           |
| ~U~         | unstage all staged files                                            |
| ~v or V~    | select multiple lines                                               |
| ~z z~       | stash changes                                                       |
** Staging lines
Magit allows you to stage specific lines by selecting them in a diff and hitting
=s= to stage. Due to inconsistencies between Vim and Emacs editing styles, if
you enter visual line state with =V=, you will stage one more line than
intended. To work around this, you can use =v= instead (since Magit only stages
whole lines, in any case).

** Commit message editing buffer
   In a commit message buffer press ~​,​c~ (if =dotspacemacs-major-mode-leader-key= is ~​,​~)
   or ~C-c C-c~ to commit the changes with the entered message. Pressing ~​,​a~ or ~C-c C-k~
   will discard the commit message.
** Interactive rebase buffer

| Key Binding | Description    |
|-------------+----------------|
| ~c~ or ~p~  | pick           |
| ~e~         | edit           |
| ~f~         | fixup          |
| ~j~         | go down        |
| ~M-j~       | move line down |
| ~k~         | go up          |
| ~M-k~       | move line up   |
| ~d~ or ~x~  | kill line      |
| ~r~         | reword         |
| ~s~         | squash         |
| ~u~         | undo           |
| ~y~         | insert         |
| ~!~         | execute        |

** Quick guide for recurring use cases in Magit
- Amend a commit:
  - ~l l~ to open =log buffer=
  - ~c a~ on the commit you want to amend
  - ~​,​c~ or ~C-c C-c~ to submit the changes
- Squash last commit:
  - ~l l~ to open =log buffer=
  - ~r e~ on the second to last commit, it opens the =rebase buffer=
  - ~j~ to put point on last commit
  - ~s~ to squash it
  - ~​,​c~ or ~C-c C-c~ to continue to the =commit message buffer=
  - ~​,​c~ or ~C-c C-c~ again when you have finished to edit the commit message
- Force push a squashed commit:
  - in the =status buffer= you should see the new commit unpushed and the old
    commit unpulled
  - ~P -f P~ for force a push (*beware* usually it is not recommended to rewrite
    the history of a public repository, but if you are *sure* that you are the
    only one to work on a repository it is ok - i.e. in your fork).
- Add upstream remote (the parent repository you have forked):
  - ~M~ to open the =remote popup=
  - ~a~ to add a remote, type the name (i.e. =upstream=) and the URL
- Pull changes from upstream (the parent repository you have forked) and push:
  - ~F -r C-u F~ and choose =upstream= or the name you gave to it
  - ~P P~ to push the commit to =origin=

** Git-Flow
[[https://github.com/jtatarik/magit-gitflow][magit-gitflow]] provides git-flow commands in its own magit menu.

| Key Binding | Description             |
|-------------+-------------------------|
| ~%~         | open magit-gitflow menu |

** Git time machine
[[https://github.com/pidu/git-timemachine][git-timemachine]] allows to quickly browse the commits of the current buffer.

| Key Binding | Description                                        |
|-------------+----------------------------------------------------|
| ~SPC g t~   | start git timemachine and initiate transient-state |
| ~c~         | show current commit                                |
| ~n~         | show next commit                                   |
| ~N~         | show previous commit                               |
| ~p~         | show previous commit                               |
| ~q~         | leave transient-state and git timemachine          |
| ~Y~         | copy current commit hash                           |

** Git links to web services
These key bindings allow to quickly construct URLs pointing to a given commit
or lines in a file hosted on Git web services like GitHub, GitLab, Bitbucket...

| Key Binding | Description                                                            |
|-------------+------------------------------------------------------------------------|
| ~SPC g l c~ | on a commit hash, browse to the current file at this commit            |
| ~SPC g l C~ | on a commit hash, create link to the file at this commit and copy it   |
| ~SPC g l l~ | on a region, browse to file at current lines position                  |
| ~SPC g l L~ | on a region, create a link to the file highlighting the selected lines |

*Notes:*
- You can use the universal argument ~SPC u~ to select a remote repository.
- When the link is opened, the URL is also copied in the kill ring, you can
  override this behavior by setting the variable =git-link-open-in-browser= to
  =nil=.
* svn
** svn 重新验证证书 ->会在用户名和密码错误的情况下重新验证 
Error:  “Server certificate verification failed: issuer is not trusted”
使用终端执行如下命令： svn list https://your.repository.url 接下来选择对应的（临时）/（永久）即可。
** help
   查看修改的文件记录
   svn cat -- 显示特定版本的某文件内容。
   svn list -- 显示一个目录或某一版本存在的文件列表。
   svn log -- 显示svn 的版本log，含作者、日期、路径等。
   svn diff -- 显示特定修改的行级详细信息。

   list示例：

   svn list http://svn.test.com/svn     #查看目录中的文件。
   svn list -v http://svn.test.com/svn  #查看详细的目录的信息(修订人,版本号,文件大小等)。
   svn list [-v]                        #查看当前当前工作拷贝的版本库URL。
   cat示例：

   svn cat -r 4 test.c     #查看版本4中的文件test.c的内容,不进行比较。
   diff示例：

   svn diff               #什么都不加，会坚持本地代码和缓存在本地.svn目录下的信息的不同;信息太多，没啥用处。
   svn diff -r 3          #比较你的本地代码和版本号为3的所有文件的不同。
   svn diff -r 3 text.c   #比较你的本地代码和版本号为3的text.c文件的不同。
   svn diff -r 5:6        #比较版本5和版本6之间所有文件的不同。
   svn diff -r 5:6 text.c #比较版本5和版本6之间的text.c文件的变化。
   svn diff -c 6 test.c    #比较版本5和版本6之间的text.c文件的变化。
   log示例：

   svn log         #什么都不加会显示所有版本commit的日志信息:版本、作者、日期、comment。
   svn log -r 4:20 #只看版本4到版本20的日志信息，顺序显示。
svn log -r 20:5 #显示版本20到4之间的日志信息，逆序显示。
svn log test.c  #查看文件test.c的日志修改信息。
svn log -r 8 -v #显示版本8的详细修改日志，包括修改的所有文件列表信息。
svn log -r 8 -v -q   #显示版本8的详细提交日志，不包括comment。
svn log -v -r 88:866 #显示从版本88到版本866之间，当前代码目录下所有变更的详细信息 。
svn log -v dir  #查看目录的日志修改信息,需要加v。
svn log http://foo.com/svn/trunk/code/  #显示代码目录的日志信息。
常用命令

svn add file|dir -- 添加文件或整个目录
svn checkout -- 获取svn代码
svn commit  -- 提交本地修改代码
svn status    -- 查看本地修改代码情况：修改的或本地独有的文件详细信息
svn merge   -- 合并svn和本地代码
svn revert   -- 撤销本地修改代码
svn resolve -- 合并冲突代码

svn help [command] -- 查看svn帮助，或特定命令帮助
svn diff个性化定制
svn配置文件: ~/.subversion/config

修改~/.subversion/config，找到如下配置行：

# diff-cmd = diff_program (diff, gdiff, etc.)
将上面那个脚本的路径添加进去就行，修改为

diff-cmd = /usr/local/bin/diffwrap.sh  #绝对路径
这样svn diff命令就会默认使用vimdiff比较文件。

diffwrap.sh文件
#! /bin/bash

# for svn diff: 修改~/.subversion/config，找到如下配置行：
# diff-cmd = diff_program (diff, gdiff, etc.)
# diff-cmd = ~/bin/diffwrap.sh

# 参数大于5时，去掉前5个参数；参数小于5，失败，什么也不做
shift 5

# 使用vimdiff比较
vimdiff "$@"
** svn ignore
   假设想忽略文件temp
1. cd到temp所在的目录下：
2. svn propedit svn:ignore .
注意：请别漏掉最后的点（.表示当前目录），如果报错请看下面

3. 打开的文件就是忽略列表文件了（默认是空的），每一行是一项，在该文件中输入temp，保存退出

4. svn st查看状态，temp的?状态已经消除了

如果在svn propedit svn:ignore .时报错：svn: None of the environment variables SVN_EDITOR, VISUAL or EDITOR are set, and no 'editor-cmd' run-time configuration option was found

说明SVN的默认属性编辑器没有设置，设置方法如下：

vi ~/.bash_profile

在最后一行追加

export SVN_EDITOR=vim

保存退出，然后输入命令source ~/.bash_profile（使配置文件立即生效）

以上步骤完成后，继续按照上面的方法设置

一直不知道svn的忽略命令如何使用，经过google的查找，使用方法还是有的，做个记录好了。
如果想在SVN提交时，忽略某个文件，也就是某个文件不提交，可以使用
svn propedit svn:ignore命令。

下面详细介绍一下使用步骤。

单纯的看svn官方文档和一些网上搜索的资料，有时候真的不如亲自试验的好。

svn propedit svn:ignore 目录名称。
注意，在使用这个SVN的属性编辑前，你得确保后面的“目录名称”是SVN版本控制的目录。

如果要忽略此目录下的文件，可以如下操作。
比如，想忽略/product目录下的test.php文件。前提是/product目录必须在svn版本控制下，而test.php文件不在svn版本控制。

svn st先看一下状态，会显示如下：
?     /product/test.php

我们需要将test.php文件加入忽略列表。
此时先设置SVN默认的编辑器
export SVN_EDITOR=vim

然后，使用svn propedit svn:ignore ,用法如下

svn propedit svn:ignore /product
此时会出现一个VIM的编辑窗口，表示需要将某个文件加入到忽略列表里
我们在编辑窗口中，写入
test.php

然后保存，并退出VIM编辑器。

这时候会有一个提示：属性 “svn:ignore” 于 “product” 被设为新值。
表示文件test.php的svn:ignore属性设置成功。
然后使用svn st查看，会显示：
M        product

我们需要提交，然后这个svn:ignore属性才会起作用
svn ci -m '忽略test.php文件'

这时候，无论你如何修改test.php文件，再使用svn st时，也不会出现修改提示符合M了。
jpg改doc

* 我的Git工作流(上)
初始化工作
新建好项目之后，打开终端，运行：
git init
git add .
git commit -m 'first commit'
这样我的项目就纳入Git版本管理了。

接下来，我需要添加一个.gitignore文件，用来忽略掉一些不想被Git管理的文件，比如编译过程中产生的Obj和libs文件，以及一些用户相关的配置文件，另外还有mact系统下面恶心的.DS_Store文件。

vim .gitignore
然后添加一些忽略规则进去：(规则里面支持正则表达式）
.DS_Store
objs/
libs/
[Dd]ebug/
[Dd]ebug.win32/

功能开发
首先，游戏当然是开发核心玩法，即游戏原型制作。这个原型可能后面会被丢弃，或者被借鉴一部分。总之，这只是我的一些测试性idea。所以，这里当然要用分支(topic分支)啦。
git checkout -b prototype
//do some coding
git commit -m 'finish featrue1'
//do some coding
git commit -m 'finish feature2'
注：这些分支存在的时间不会很长，实现功能以后就要合并到主分去，并且删除之。

当然，在原型实现的过程，可能还会遇到一些临时性的想法，还可以继续开分支，然后做完以后，如果ok就合并到prototype，如果不行，就丢掉。
合并我会用到下列命令:

git merge test_feature3 prototype
git branch -d test_feature3
如果是丢掉这个分支里的内容，可以先切换回原来的分支，然后强制删除新的分支：

git checkout prototype
git branch -D test_feature4 (注意这里需要用大写的-D)
这里我的原则就是，commit early and commit often. 同时尽量保持每一个commit做的事情单一。 如果要保持版本库的历史记录好看，
在合并特性分支到主分支的时候，除了使用merge，还可以使用rebase，比如:

//假调当前我在一个test_feature9上面
git rebase prototype  （或者使用rebase -i来整理commit log）
因为我们经常commit，就有可能导致有时候一些commit log写得不完整或者不清楚。有时候也可能导致一个功能可能被拆分到多个commit里面去了。
这时候要使用rebase或者使用–squash的方法来整理git commit log。这一点，可以参考这篇文章。

如果有时候在写代码的时候，忘了要切分支去弄了。可以先用git stash save xxx来保存工作区的内容，然后新建 一个分支并调用git stash pop
就可以把刚刚的patch应用到新分支上面。

如果对于commit的log格式有特殊要求的，还可以编写钩子程序，用一些正则表达式来检查commit消息的格式是否正确。
这样可以防止某些人在commit的时候写一些无用的commit log。

至于一个产品更细致的分支的艺术，请参考此文
使用Git作为个人项目管理的好处

分支可以让我编写代码的时候更自信，因为我完全不用担心自己的代码会不会破坏已有的代码。同时，由于我经常commit，这样我即使犯错，回滚的成本也很低。再次，它让我在项目过程中更愿意去尝试一些新的idea。我现在写代码要是没有Git，我写半个小时，心里就开始发慌了。因为代码量一多，我就感觉自己要hold不住了。
另外，如果自己不小心在test的时候，犯了错误 ，引起了bug。这个时候，你不清楚是哪一行代码修改导致的问题。可以尝试使用git bisect工具来找出有问题的commit记录。这个工具最近帮了我一个大忙，感谢Git！

结语

本文主要介绍我日常中用到的一些基本的Git命令，当然还有git reset, git clean等命令没有涉及到。
作为一个21世纪的程序员，如果还没有用Git和Github，那就真的Out了。
其中很多常用命令都被我重定义了，比如git简化为g，commit简化为cm。总之，怎么简单怎么来，更多配置信息可以查看Github上面的gitconfig
* 在上篇文章中,我谈到了我日常使用Git作为个人项目管理工具的一些基本用法。同时，我还简单地谈了一下使用Git作为个人项目管理工具的好处。但是，Git的强大威力只有在多人协作与大项目开发中才能真正体会到。它的分布式理念，灵活的分支机制，再加上多种错误应急措施，让我对它赞不绝口。
本文主要谈一下我在参与开源项目Cocos2D-X中学到的一些东西。
多人协作

首先，Cocos2D-X现在主要分为3个分支（v1,v2和v3），分别对应OpenGL ES1.0，OpenGL ES 2.0 OC style和OpenGL ES 2.0 C++11 style。目前，整个团队的重心放在v3分支上面。新功能的开发，bug的修复以及代码的持续改进基本上都基于v3分支在做。而v2分支主要是用来修复一些重大的bug。

谈到多人协作，肯定免不了要提到Github，这家伙现在可是程序猿们津津乐道的话题。不过国内访问Github的速度有点慢，有时候还访问不了，比较郁闷。国内的代码托管平台也比较多，推荐码云和Coding。

一个项目一般由一个组织或都者一个牛人发起，然后其他人可以通过fork+pull request的方式来给此项目贡献代码。参与者不仅仅局限于代码提交，还可以修复文档和注释，另外还可以提建议和反馈bug。另外这些代码托管平台一般还提供项目wiki的功能，这样代码和文档就更好地放在一起了。

采用这种方式进行软件开发，我认为有以下几点好处：
一、可以集众人之智慧，不断地改进软件代码，提高软件质量
二、每一份代码在合并进主仓库时，都会有人进行Code Review。这是一种非常好的软件工程实践
三、可以与jekins或者travis等持续集成工具结合，一旦有pr产生，CI服务器便会对代码进行构建并在构建结束时返回此次构建的状态。确保每一份代码在check in的时候至少编译正确。
四、可以与redmine等issue系统关联起来，让roadmap的制订，issue的管理，bug的反馈融合成一个有机整体，有效地帮助PM对项目进行把控。
五、能让程序员更加关心自己的代码。每一份代码在发PR之前，至少在本地由自己Review一遍，如果产生了bug，能及时有效地发现并解决之。
六、有完整的版本历史，可以方便地追踪错误代码的责任人，另外，使用git bisect也可以非常方便地定位一些非常隐秘的bug。

我很难想象，现在一个大型项目如果没有使用版本控制,持续集成工具和issue系统，它将如何能够良性发展，可能等待程序员的只有没日没夜地加班了。

Git的分布式

当我在没有网络的情况下面我也可以在本地提交代码，这是svn无法做到的。另外，任何一个人的代码，可以作为主仓库代码，可以被别人fork，也可以合并到其它人的代码里面去。Git的这种灵泛的特性允许我们把一个大型项目拆分成若干个项目组，每一个组fork一份代码，然后每个组的成员从组长那里再fork代码。组员的代码要提交到组长那里去审核，最后，当一个功能特性做完以后，再由组长提交pr到主仓库上去。此时，代码还可以被更高级别的人Review。

它同时也允许多人并行进行项目开发，并且各自独立提交修改。当要发PR的时候，可以先用git rebase -i来整理好log历史记录。一旦历史记录ok，就可以给主仓库发pr了。

Git让我变成一个更好的程序员

现在，任何一个non-trival的项目，我都会使用Git来管理并且同步到Github（或者Gitcaf、开源中国上）。我曾经做过一个外包小游戏，用了不到2周完成了。如果不是使用了Git，我想我肯定无法在这么短的时间内完成项目。因为，我的每一步正确的代码都会及时提交进版本库，而我的每一个想法都可以尽情地被testing而不用担心破坏已有的代码。

其次，我在学习一门新技术，比如OpenGL ES2.0和WebGL时，我会把我学习过程中的一些Demo都用Git管理起来，同时上传到相应的代码托管平台上面。这样做的好处是，下次我可以非常方便地找到我以前写的代码，及时温故和复查。

最后，Git提供了一种思维模式，即“小步快跑，大胆试错”的理念。通过不停地切分支，合并分支，最后项目在不断地往前推进，这种感觉真好！

关于Git命令行与图形化工具

我目前主要用Git命令行工具，我喜欢这种Geek-style。同时，我觉得使用比GUI方便。但是我也用SourceTree（windows下用tortoisegit）来做Code Review和冲突解决。命令行与GUI应该是统一的，没有必要排拆任何一方，能让自己的工作最高效的做事方法就是最好的。
