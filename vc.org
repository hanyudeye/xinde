* git
** git
*** 1.create a new repository on the command line
    echo "# test" >> README.md
    git init
    git add README.md
    git commit -m "first commit"
    git remote add origin https://github.com/hanyudeye/test.git
    git push -u origin master
*** 2.push an existing repository from the command line
 git remote add origin https://github.com/hanyudeye/test.git
 git push -u origin master
** 工作流程
   #+BEGIN_SRC 
   本地  本地仓库 远程仓库
   #+END_SRC
  * 克隆 Git 资源作为工作目录。
  : git clone --depth=1 RESP 只克隆最新的
  * 在克隆的资源上添加或修改文件。
  * 如果其他人修改了，你可以更新资源。pull/push
  * 在提交前查看修改。
  * 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交,commit/checkout
** 配置
   git config [--system,--global]
   /etc/gitconfig | ~/.gitconfig
   user.name = "用户名或者用户ID"
   user.email = "邮箱"
   ssh-keygen -C 'you email address@gmail.com' -t rsa
   : 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
   : 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
*** 上传公钥
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。
** 管理 工作区、暂存区和版本库
*** 创建一个版本库
    git init <directory>
    git clone git://git.kernel.org/pub/scm/git/git.git <directory>
    git remote add origin git@github.com:hanyudeye/os.git
*** git tag
*** git branch
*** git checkout
*** 将修改存入暂存区
    git add <modified files>/git add .
*** 暂存区删除文件
    git rm --cached <file>
*** 删除工作区和暂存区文件
git rm <file>
*** 取消已缓存的内容
    git reset HEAD
*** 暂存区全部或指定的文件替换工作区的文件。这个操作很危险
    git checkout .
    git checkout -- <file>
*** 重命名
    git mv 命令做得所有事情就是 git rm --cached 命令的操作，重命
    名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。
*** 用 HEAD 指向的 master 分支中的全部或者部分文件替换
git checkout HEAD .
git checkout HEAD <file>
*** 提交到版本库中
    git commit -m "msg"
    也可以将git add与git commit用一个指令完成
    git commit -a -m "msg"
*** 远程同步
    git push
*** 更新本地端的repo
    git pull/git pull git://github.com/tom/test.git
*** 查看状态
    git status
    git status -s 简短信息
    git remote -v 列出服务器地址
    git diff   尚未缓存的改动：
    git diff --cached   查看已缓存的改动：
    git diff HEAD  查看已缓存的与未缓存的所有改动：
    git diff --stat   显示摘要而非整个diff
    A: 你本地新增的文件（服务器上没有）.
    C: 文件的一个新拷贝.
    D: 你本地删除的文件（服务器上还在）.
    M: 文件的内容或者mode被修改了.
    R: 文件名被修改了。
    T: 文件的类型被修改了。
    U: 文件没有被合并(你需要完成合并才能进行提交)。
    X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。
    在man git diff-files中可以查到这些标志的说明
** git 分支管理
*** 创建分支命令：
git branch (branchname)
*** 切换分支命令:
git checkout (branchname)
当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工
作目录的内容，所以多个分支不需要多个目录。
*** 合并分支命令:
git merge 
*** 列出分支基本命令：
git branch
*** 创建新分支并立即切换到该分支下，从而在该分支中操作
git checkout -b (newbranchname)
*** 删除分支命令：
git branch -d (branchname)
*** 把bug_fix这个branch和现在的branch合并
git merge bug_fix 
*** Git 查看提交历史
git log
git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
 --author 指定用户日志
如果你要指定日期，可以执行几个选项：--since 和 --before，但
是你也可以用 --until 和 --after。
git show 可以看某次的变更
*** 查看远程分支
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local
** .gitignore
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
   规则：/fd1/*
   说明：忽略根目录下的 /fd1/ 目录的全部内容；
* git本地仓库关联远程仓库的两种方式：
1.将远程的代码clone到本地仓库
1.git clone现有的项目（https | SSH）
SSH：
检查你的电脑中是否有密匙对id_rsa id_rsa.pub
没有的话，创建密匙对  ssh-keygen -t rsa -b 4096 -C "你的git中设置的邮箱"
检查你的ssh-agent是否是活跃的 eval "$(ssh-agent -s)"
将私匙添加到 ssh-add  ~/.ssh/id_rsa
然后将公匙复制后添加到git网站中，如github
测试是否能够连接ssh -T git@github.com
克隆到本地git clone git@github.com:hongminzhang/zhm.git

2.将本地的已有项目关联到github上的新的项目上
在github上新建一个仓库，然后在本地仓库中执行git remote add origin git@github.com:stormzhang/test.git
origin是仓库的名字，可能你的本地项目关联着几个仓库，你可以根据仓库的名字
git push origin master 将代码提交到不同仓库中，可以指定分支
然后执行git pull origin master 先将github上的代码pull下来
然后在git push origin master

* git mode
** 单屏显示版本文件状态
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-magit-status-fullscreen t))
#+END_SRC
** Magit auto-complete
#+BEGIN_SRC emacs-lisp
  (setq magit-repository-directories '("~/repos/"))
#+END_SRC
** Magit SVN plugin
#+BEGIN_SRC emacs-lisp
  (defun dotspacemacs/user-init ()
    (setq-default git-enable-magit-svn-plugin t))
#+END_SRC
** Global git commit mode
Spacemacs can be used as the =$EDITOR= (or =$GIT_EDITOR=) for editing git
commits messages. To enable this you have to add the following line to your
=dotspacemacs/user-config=:

#+begin_src emacs-lisp
(global-git-commit-mode t)
#+end_src

** Git-Flow
Git-flow is a standardized branching pattern for git repositories with the aim
of making things more manageable. While there are tools to assist with making
this easier, these do nothing you couldn't do manually.

Support requires installation of the git-flow extensions. Please reference their
[[https://github.com/petervanderdoes/gitflow/wiki][installation page]] for assistance.

** Org integration
   See the commentary section of the package [[https://github.com/magit/orgit/blob/master/orgit.el#L28][here]].
* 快捷键
** Git commands (start with ~g~):
| Key Binding | Description                                         |
|-------------+-----------------------------------------------------|
| ~SPC g >~   | show submodule prompt                               |
| ~SPC g b~   | open a =magit= blame                                |
| ~SPC g f h~ | show file commits history                           |
| ~SPC g H c~ | clear highlights                                    |
| ~SPC g H h~ | highlight regions by age of commits                 |
| ~SPC g H t~ | highlight regions by last updated time              |
| ~SPC g I~   | open =helm-gitignore=                               |
| ~SPC g s~   | open a =magit= status window                        |
| ~SPC g S~   | stage current file                                  |
| ~SPC g m~   | magit dispatch popup                                |
| ~SPC g M~   | display the last commit message of the current line |
| ~SPC g t~   | launch the git time machine                         |
| ~SPC g U~   | unstage current file                                |

** Magit
Spacemacs uses [[http://magit.vc/][magit]] to manage Git repositories.

To open a =status buffer=, type in a buffer of a Git repository: ~SPC g s~.
The central key binding hub of Magit is available on ~SPC g m~.

Here are the often used bindings inside a =status buffer=:

| Key Binding | Description                                                         |
|-------------+---------------------------------------------------------------------|
| ~/~         | evil-search                                                         |
| ~$~         | open =command output buffer=                                        |
| ~c c~       | open a =commit message buffer=                                      |
| ~b b~       | checkout a branch                                                   |
| ~b c~       | create a branch                                                     |
| ~f f~       | fetch changes                                                       |
| ~F (r) u~   | pull tracked branch and rebase                                      |
| ~gr~        | refresh                                                             |
| ~j~         | goto next magit section                                             |
| ~C-j~       | next visual line                                                    |
| ~k~         | goto previous magit section                                         |
| ~C-k~       | previous visual line                                                |
| ~l l~       | open =log buffer=                                                   |
| ~n~         | next search occurrence                                              |
| ~N~         | previous search occurrence                                          |
| ~o~         | revert item at point                                                |
| ~P u~       | push to tracked branch                                              |
| ~P m~       | push to matching branch  (e.g., upstream/develop to origin/develop) |
| ~q~         | quit                                                                |
| ~s~         | on a file or hunk in a diff: stage the file or hunk                 |
| ~x~         | discard changes   复原                                              |
| ~+~         | on a hunk: increase hunk size                                       |
| ~-~         | on a hunk: decrease hunk size                                       |
| ~S~         | stage all                                                           |
| ~TAB~       | on a file: expand/collapse diff                                     |
| ~u~         | on a staged file: unstage                                           |
| ~U~         | unstage all staged files                                            |
| ~v or V~    | select multiple lines                                               |
| ~z z~       | stash changes                                                       |
** Staging lines
Magit allows you to stage specific lines by selecting them in a diff and hitting
=s= to stage. Due to inconsistencies between Vim and Emacs editing styles, if
you enter visual line state with =V=, you will stage one more line than
intended. To work around this, you can use =v= instead (since Magit only stages
whole lines, in any case).

** Commit message editing buffer
   In a commit message buffer press ~​,​c~ (if =dotspacemacs-major-mode-leader-key= is ~​,​~)
   or ~C-c C-c~ to commit the changes with the entered message. Pressing ~​,​a~ or ~C-c C-k~
   will discard the commit message.
** Interactive rebase buffer

| Key Binding | Description    |
|-------------+----------------|
| ~c~ or ~p~  | pick           |
| ~e~         | edit           |
| ~f~         | fixup          |
| ~j~         | go down        |
| ~M-j~       | move line down |
| ~k~         | go up          |
| ~M-k~       | move line up   |
| ~d~ or ~x~  | kill line      |
| ~r~         | reword         |
| ~s~         | squash         |
| ~u~         | undo           |
| ~y~         | insert         |
| ~!~         | execute        |

** Quick guide for recurring use cases in Magit
- Amend a commit:
  - ~l l~ to open =log buffer=
  - ~c a~ on the commit you want to amend
  - ~​,​c~ or ~C-c C-c~ to submit the changes
- Squash last commit:
  - ~l l~ to open =log buffer=
  - ~r e~ on the second to last commit, it opens the =rebase buffer=
  - ~j~ to put point on last commit
  - ~s~ to squash it
  - ~​,​c~ or ~C-c C-c~ to continue to the =commit message buffer=
  - ~​,​c~ or ~C-c C-c~ again when you have finished to edit the commit message
- Force push a squashed commit:
  - in the =status buffer= you should see the new commit unpushed and the old
    commit unpulled
  - ~P -f P~ for force a push (*beware* usually it is not recommended to rewrite
    the history of a public repository, but if you are *sure* that you are the
    only one to work on a repository it is ok - i.e. in your fork).
- Add upstream remote (the parent repository you have forked):
  - ~M~ to open the =remote popup=
  - ~a~ to add a remote, type the name (i.e. =upstream=) and the URL
- Pull changes from upstream (the parent repository you have forked) and push:
  - ~F -r C-u F~ and choose =upstream= or the name you gave to it
  - ~P P~ to push the commit to =origin=

** Git-Flow
[[https://github.com/jtatarik/magit-gitflow][magit-gitflow]] provides git-flow commands in its own magit menu.

| Key Binding | Description             |
|-------------+-------------------------|
| ~%~         | open magit-gitflow menu |

** Git time machine
[[https://github.com/pidu/git-timemachine][git-timemachine]] allows to quickly browse the commits of the current buffer.

| Key Binding | Description                                        |
|-------------+----------------------------------------------------|
| ~SPC g t~   | start git timemachine and initiate transient-state |
| ~c~         | show current commit                                |
| ~n~         | show next commit                                   |
| ~N~         | show previous commit                               |
| ~p~         | show previous commit                               |
| ~q~         | leave transient-state and git timemachine          |
| ~Y~         | copy current commit hash                           |

** Git links to web services
These key bindings allow to quickly construct URLs pointing to a given commit
or lines in a file hosted on Git web services like GitHub, GitLab, Bitbucket...

| Key Binding | Description                                                            |
|-------------+------------------------------------------------------------------------|
| ~SPC g l c~ | on a commit hash, browse to the current file at this commit            |
| ~SPC g l C~ | on a commit hash, create link to the file at this commit and copy it   |
| ~SPC g l l~ | on a region, browse to file at current lines position                  |
| ~SPC g l L~ | on a region, create a link to the file highlighting the selected lines |

*Notes:*
- You can use the universal argument ~SPC u~ to select a remote repository.
- When the link is opened, the URL is also copied in the kill ring, you can
  override this behavior by setting the variable =git-link-open-in-browser= to
  =nil=.
* svn
** svn 重新验证证书 ->会在用户名和密码错误的情况下重新验证 
Error:  “Server certificate verification failed: issuer is not trusted”
使用终端执行如下命令： svn list https://your.repository.url 接下来选择对应的（临时）/（永久）即可。
** help
   查看修改的文件记录
   svn cat -- 显示特定版本的某文件内容。
   svn list -- 显示一个目录或某一版本存在的文件列表。
   svn log -- 显示svn 的版本log，含作者、日期、路径等。
   svn diff -- 显示特定修改的行级详细信息。

   list示例：

   svn list http://svn.test.com/svn     #查看目录中的文件。
   svn list -v http://svn.test.com/svn  #查看详细的目录的信息(修订人,版本号,文件大小等)。
   svn list [-v]                        #查看当前当前工作拷贝的版本库URL。
   cat示例：

   svn cat -r 4 test.c     #查看版本4中的文件test.c的内容,不进行比较。
   diff示例：

   svn diff               #什么都不加，会坚持本地代码和缓存在本地.svn目录下的信息的不同;信息太多，没啥用处。
   svn diff -r 3          #比较你的本地代码和版本号为3的所有文件的不同。
   svn diff -r 3 text.c   #比较你的本地代码和版本号为3的text.c文件的不同。
   svn diff -r 5:6        #比较版本5和版本6之间所有文件的不同。
   svn diff -r 5:6 text.c #比较版本5和版本6之间的text.c文件的变化。
   svn diff -c 6 test.c    #比较版本5和版本6之间的text.c文件的变化。
   log示例：

   svn log         #什么都不加会显示所有版本commit的日志信息:版本、作者、日期、comment。
   svn log -r 4:20 #只看版本4到版本20的日志信息，顺序显示。
svn log -r 20:5 #显示版本20到4之间的日志信息，逆序显示。
svn log test.c  #查看文件test.c的日志修改信息。
svn log -r 8 -v #显示版本8的详细修改日志，包括修改的所有文件列表信息。
svn log -r 8 -v -q   #显示版本8的详细提交日志，不包括comment。
svn log -v -r 88:866 #显示从版本88到版本866之间，当前代码目录下所有变更的详细信息 。
svn log -v dir  #查看目录的日志修改信息,需要加v。
svn log http://foo.com/svn/trunk/code/  #显示代码目录的日志信息。
常用命令

svn add file|dir -- 添加文件或整个目录
svn checkout -- 获取svn代码
svn commit  -- 提交本地修改代码
svn status    -- 查看本地修改代码情况：修改的或本地独有的文件详细信息
svn merge   -- 合并svn和本地代码
svn revert   -- 撤销本地修改代码
svn resolve -- 合并冲突代码

svn help [command] -- 查看svn帮助，或特定命令帮助
svn diff个性化定制
svn配置文件: ~/.subversion/config

修改~/.subversion/config，找到如下配置行：

# diff-cmd = diff_program (diff, gdiff, etc.)
将上面那个脚本的路径添加进去就行，修改为

diff-cmd = /usr/local/bin/diffwrap.sh  #绝对路径
这样svn diff命令就会默认使用vimdiff比较文件。

diffwrap.sh文件
#! /bin/bash

# for svn diff: 修改~/.subversion/config，找到如下配置行：
# diff-cmd = diff_program (diff, gdiff, etc.)
# diff-cmd = ~/bin/diffwrap.sh

# 参数大于5时，去掉前5个参数；参数小于5，失败，什么也不做
shift 5

# 使用vimdiff比较
vimdiff "$@"
** svn ignore
   假设想忽略文件temp
1. cd到temp所在的目录下：
2. svn propedit svn:ignore .
注意：请别漏掉最后的点（.表示当前目录），如果报错请看下面

3. 打开的文件就是忽略列表文件了（默认是空的），每一行是一项，在该文件中输入temp，保存退出

4. svn st查看状态，temp的?状态已经消除了

如果在svn propedit svn:ignore .时报错：svn: None of the environment variables SVN_EDITOR, VISUAL or EDITOR are set, and no 'editor-cmd' run-time configuration option was found

说明SVN的默认属性编辑器没有设置，设置方法如下：

vi ~/.bash_profile

在最后一行追加

export SVN_EDITOR=vim

保存退出，然后输入命令source ~/.bash_profile（使配置文件立即生效）

以上步骤完成后，继续按照上面的方法设置

一直不知道svn的忽略命令如何使用，经过google的查找，使用方法还是有的，做个记录好了。
如果想在SVN提交时，忽略某个文件，也就是某个文件不提交，可以使用
svn propedit svn:ignore命令。

下面详细介绍一下使用步骤。

单纯的看svn官方文档和一些网上搜索的资料，有时候真的不如亲自试验的好。

svn propedit svn:ignore 目录名称。
注意，在使用这个SVN的属性编辑前，你得确保后面的“目录名称”是SVN版本控制的目录。

如果要忽略此目录下的文件，可以如下操作。
比如，想忽略/product目录下的test.php文件。前提是/product目录必须在svn版本控制下，而test.php文件不在svn版本控制。

svn st先看一下状态，会显示如下：
?     /product/test.php

我们需要将test.php文件加入忽略列表。
此时先设置SVN默认的编辑器
export SVN_EDITOR=vim

然后，使用svn propedit svn:ignore ,用法如下

svn propedit svn:ignore /product
此时会出现一个VIM的编辑窗口，表示需要将某个文件加入到忽略列表里
我们在编辑窗口中，写入
test.php

然后保存，并退出VIM编辑器。

这时候会有一个提示：属性 “svn:ignore” 于 “product” 被设为新值。
表示文件test.php的svn:ignore属性设置成功。
然后使用svn st查看，会显示：
M        product

我们需要提交，然后这个svn:ignore属性才会起作用
svn ci -m '忽略test.php文件'

这时候，无论你如何修改test.php文件，再使用svn st时，也不会出现修改提示符合M了。
jpg改doc


