* 编译器
** 功能选项
   -d      提供调试输出
   -O      生成优化的字节码(生成 .pyo 文件)
   -S      不导入 site 模块以在启动时查找 Python 路径
   -v      冗余输出(导入语句详细追踪)
   -m mod  将一个模块以脚本形式运行
   -c cmd  运行以命令行字符串形式提交的 Python 脚本
   file    从给定的文件运行 Python 脚本(参阅后文)
** 环境变量
   PYTHONPATH	PYTHONPATH 是 Python 搜索路径，默认我们 import 的模块都会从 PYTHONPATH 里面寻找。
   PYTHONSTARTUP 	Python 启动后，先寻找 PYTHONSTARTUP 环境变量，然后执行此文件中变量指定的执行代码。
   PYTHONCASEOK 	加入 PYTHONCASEOK 的环境变量, 就会使 python 导入模块的时候不区分大小写.
   PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的 PYTHONSTARTUP 或 PYTHONPATH 目录中，使得两个模块库更容易切换。
** 编码 由于python 在unicode 出现，所以为兼容后面
   # -*- coding: UTF-8 -*- 
   # coding=utf-8
* python mode
** Features:
- Auto-completion using [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]
- Code Navigation using  [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]
- Documentation Lookup using  [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]  and [[https://github.com/tsgates/pylookup][pylookup]]
- Test Runners using [[https://github.com/syl20bnr/nose.el][nose.el]] or [[https://github.com/ionrock/pytest-el][pytest]]
- Virtual Environment using  [[https://github.com/jorgenschaefer/pyvenv][pyvenv]] and [[https://github.com/yyuu/pyenv][pyenv]]
- semantic mode is enabled
- PEP8 compliant formatting via [[https://github.com/google/yapf][YAPF]]
- PEP8 checks with [[https://pypi.python.org/pypi/flake8][flake8]] or [[https://pypi.python.org/pypi/pylint/1.6.4][pylint]]
- Suppression of unused import with [[https://github.com/myint/autoflake][autoflake]]
- Use the ~%~ key to jump between blocks with [[https://github.com/redguardtoo/evil-matchit][evil-matchit]]
- Sort imports with [[https://pypi.python.org/pypi/isort][isort]]

** Install
*** Layer
 To use this configuration layer, add it to your =~/.spacemacs=. You will need to
 add =python= to the existing =dotspacemacs-configuration-layers= list in this
 file.

*** Dependencies
**** Auto-completion: Anaconda dependencies
 =anaconda-mode= tries to install the dependencies itself but sometimes
 it does not work and you may encounter the following message when
 opening a python buffer:

 #+begin_example
     Blocking call to accept-process-output with quit inhibited!!
 #+end_example

 To fix this, install the =anaconda-mode= [[https://github.com/proofit404/anaconda-mode/wiki][anaconda-deps]] by hand:

 #+begin_src sh
     pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
 #+end_src

 If you encounter problems with Jedi 1.0 consider downgrading to 0.9.0. See [[https://github.com/davidhalter/jedi/issues/873][this
 issue]] for details.

 Source: https://github.com/proofit404/anaconda-mode#issues

 If you are facing errors such as "Unable to run anaconda-mode server", try
 setting your =PYTHONPATH= as explained at
 https://github.com/proofit404/anaconda-mode#pythonpath

**** Syntax checking
 Syntax checking uses =flake8= package:
 #+begin_src sh
     pip install flake8
 #+end_src

*** Test runner
 Both =nose= and =pytest= are supported. By default =nose= is used.
 To choose your test runner set the layer variable =python-test-runner= to
 either =nose= or =pytest=.

 #+BEGIN_SRC emacs-lisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-test-runner 'pytest)))
 #+END_SRC

 If you need both then you can set =python-test-runner= to a list like this:
 #+BEGIN_SRC emacs-lisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-test-runner '(pytest nose))))
 #+END_SRC

 This means that =pytest= is your primary test runner. To use the secondary test
 runner you can call the test functions with a prefix argument e.g. ~SPC u SPC m
 t t~ to run one test with =nose=.

 To set project specific test runners you can set =python-test-runner= in a
 directory local variable in your project root. ~SPC f v d~ in Spacemacs. See
 [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][the official documentation]] for more information.

 The root of the project is detected with a =.git= directory or a =setup.cfg= file.
*** Automatic buffer formatting on save
    To enable automatic buffer formatting on save with  [[https://github.com/google/yapf][YAPF]] set the variable
    =python-enable-yapf-format-on-save= to =t=.
 #+BEGIN_SRC emacs-lisp
   (setq-default dotspacemacs-configuration-layers '(
     (python :variables python-enable-yapf-format-on-save t)))
 #+END_SRC

*** autoflake
 To be able to suppress unused imports easily, install [[https://github.com/myint/autoflake][autoflake]]:

 #+BEGIN_SRC sh
   pip install autoflake
 #+END_SRC

*** pylookup
 To use =pylookup= on ~SPC m h H~, make sure you update the database first, using
 ~SPC SPC pylookup-update~.

*** Hy-mode
 To be able to connect to an inferior lisp repl in =hy-mode=, you need to make sure
 that hy is installed.

 #+BEGIN_SRC sh
   pip install hy
 #+END_SRC

** 选择后端 Choosing a backend
To choose a default backend set the layer variable =python-backend=:

#+BEGIN_SRC elisp
  (python :variables python-backend 'anaconda)
  #+END_SRC

   Backend can be chosen on a per project basis using directory local variables
   (files named =.dir-locals.el= at the root of a project), an example to use the
   =lsp= backend:
  可以在 .dir-locals.el 文件中单独配置后端

    ,#+BEGIN_SRC elisp
    ;;; Directory Local Variables
    ;;; For more information see (info "(emacs) Directory Variables")

    ((python-mode (python-backend . lsp)))
#+END_SRC

*Note:* you can easily add a directory local variable with ~SPC f v d~.

** Management of Python versions and virtual environments
*** Manage virtual environments with pyvenv
 A virtual environment provides isolation of your Python package versions. For a
 general overview see [[http://docs.python-guide.org/en/latest/dev/virtualenvs/][this site]]. [[http://virtualenvwrapper.readthedocs.io/en/latest/index.html][Virtualenvwrapper]] which is also explained in the
 previous link, is a program which manages your virtual environments in a central
 location set by the =WORKON_HOME= environment variable.

 Spacemacs integration of virtual environments and virtualenvwrapper is provided
 by the [[https://github.com/jorgenschaefer/pyvenv][pyvenv]] package. It provides the following keybindings:

 | Key Binding | Description                                     |
 |-------------+-------------------------------------------------|
 | ~SPC m V a~ | activate a virtual environment in any directory |
 | ~SPC m V d~ | deactivate active virtual environment           |
 | ~SPC m V w~ | work on virtual environment in =WORKON_HOME=    |

*** Manage multiple Python versions with pyenv
 If you need multiple Python versions (e.g. Python 2 and Python 3) then take a
 look at [[https://github.com/yyuu/pyenv][pyenv]]. It enables the installation and managment of multiple
 Python versions.
 [[https://www.brianthicks.com/post/2015/04/15/automate-your-python-environment-with-pyenv/][This blogpost]] gives a good overview on how to use the tool. Spacemacs
 integration is provided by [[https://github.com/proofit404/pyenv-mode][pyenv mode]] which has the following keybindings.

 | Key Binding | Description                          |
 |-------------+--------------------------------------|
 | ~SPC m v s~ | set a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]   |
 | ~SPC m v u~ | unset a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]] |

 Pyenv can also manage virtual environments for each of the Python versions it
 has installed. Those will be listed alongside your Python versions.

**** Automatic activation of local pyenv version
 A project-specific pyenv version may be written to a file called
 =.python-version= using the [[https://github.com/yyuu/pyenv/blob/master/COMMANDS.md#user-content-pyenv-local][pyenv local]] command.

 Spacemacs can search in parent directories for this file, and automatically set
 the pyenv version. The behavior can be set with the variable
 =python-auto-set-local-pyenv-version= to:
 - =on-visit= (default) set the version when you visit a python buffer,
 - =on-project-switch= set the version when you switch projects,
 - =nil= to disable.

 The same is also possible on pyvenv with a file called =.venv=. The behavior
 can be set with the variable =python-auto-set-local-pyvenv-virtualenv== to:
 - =on-visit= (default) set the virtualenv when you visit a python buffer,
 - =on-project-switch= set the virtualenv when you switch projects,
 - =nil= to disable.

** Key Bindings
*** Inferior REPL process 在交互模式下, 需 SPC m s i
 Start a Python or iPython inferior REPL process with ~SPC m s i~.
 If =ipython= is available in system executable search paths, =ipython=
 will be used to launch python shell; otherwise, default =python=
 interpreter will be used.  You may change your system executable
 search path by activating a virtual environment.

 Send code to inferior process commands:

 | Key Binding | Description                                     |
 |-------------+-------------------------------------------------|
 | ~SPC m s b~ | send buffer and keep code buffer focused        |
 | ~SPC m s B~ | send buffer and switch to REPL in insert mode   |
 | ~SPC m s f~ | send function and keep code buffer focused 发送光标处函数 |
 | ~SPC m s F~ | send function and switch to REPL in insert mode |
 | ~SPC m s i~ | start inferior REPL process                     |
 | ~SPC m s r~ | send region and keep code buffer focused        |
 | ~SPC m s R~ | send region and switch to REPL in insert mode   |
 | ~CTRL+j~    | next item in REPL history                       |
 | ~CTRL+k~    | previous item in REPL history                   |
*** Running Python Script in shell
 To run a Python script like you would in the shell press ~SPC m c c~
 to start the Python script in comint mode. This is useful when working with
 multiple Python files since the REPL does not reload changes made in other
 modules.

 | Key Binding | Description                                                               |
 |-------------+---------------------------------------------------------------------------|
 | ~SPC m c c~ | Execute current file in a comint shell                                    |
 | ~SPC m c C~ | Execute current file in a comint shell and switch to it in =insert state= |

 *Note:* With the universal argument ~SPC u~ you can enter a new
 compilation command.
用 spc u spc m c c 可以输入执行脚本的命令, 可以在后面加参数
*** Testing (没装 nose)
 Test commands start with ~m t~. To use the secondary test runner call the
 function with a prefix argument, for example ~SPC u SPC m t a~.
 | No Debug    | Description                                              |
 |-------------+----------------------------------------------------------|
 | ~SPC m t a~ | launch all tests of the project                          |
 | ~SPC m t b~ | launch all tests of the current buffer (same as module)  |
 | ~SPC m t m~ | launch all tests of the current module                   |
 | ~SPC m t s~ | launch all tests of the current suite (only with =nose=) |
 | ~SPC m t t~ | launch the current test (function)                       |

 | Debug       | Description                                                            |
 |-------------+------------------------------------------------------------------------|
 | ~SPC m t A~ | launch all tests of the project in debug mode                          |
 | ~SPC m t B~ | launch all tests of the current buffer (module) in debug mode          |
 | ~SPC m t M~ | launch all tests of the current module in debug mode                   |
 | ~SPC m t S~ | launch all tests of the current suite in debug mode (only with =nose=) |
 | ~SPC m t T~ | launch the current test (function) in debug mode                       |

*** Refactoring

 | Key Binding | Description                          |
 |-------------+--------------------------------------|
 | ~SPC m r i~ | remove unused imports with [[https://github.com/myint/autoflake][autoflake]] |
 | ~SPC m r I~ | sort imports with [[https://pypi.python.org/pypi/isort][isort]]              |

*** Live coding
 Live coding is provided by the [[https://github.com/donkirkby/live-py-plugin][live-py-plugin.]]

 | Key Binding | Description         |
 |-------------+---------------------|
 | ~SPC m l~   | Toggle live-py-mode |

*** Hy REPL process
 Start a Hy inferior repel process with ~SPC m s i~. If =hy= is
 available in system executable search paths, =hy= will be used to
 launch the shell. You may change your system executable search path
 by activating a virtual enviornment.

 Send code to hy REPL commands:

 | Key Binding | Description                                               |
 |-------------+-----------------------------------------------------------|
 | ~SPC m s b~ | send buffer and keep code buffer focused                  |
 | ~SPC m s B~ | switch to REPL                                            |
 | ~SPC m s e~ | send sexp in front of the cursor to the REPL              |
 | ~SPC m s f~ | send function to REPL and stay in buffer                  |
 | ~SPC m s F~ | send function to REPL and switch to repl buffer           |
 | ~SPC m s i~ | start inferior hy repl                                    |
 | ~SPC m s r~ | send current region to the REPL and stay in buffer        |
 | ~SPC m s R~ | send current region to the REPL and switch to repl buffer |

*** Other Python commands

 | Key Binding | Description                                                                  |
 |-------------+------------------------------------------------------------------------------|
 | ~SPC m =~   | Reformat the buffer according to PEP8 using  [[https://github.com/google/yapf][YAPF]]                            |
 | ~SPC m d b~ | toggle a breakpoint using =wdb=, =ipdb=, =pudb= or =pdb=                     |
 | ~SPC m g g~ | go to definition using =anaconda-mode-find-definitions= (~C-o~ to jump back) |
 | ~SPC m g a~ | go to assignment using =anaconda-mode-find-assignments= (~C-o~ to jump back) |
 | ~SPC m g b~ | jump back                                                                    |
 | ~SPC m g u~ | navigate between usages with =anaconda-mode-find-references=                 |
 | ~SPC m h d~ | look for documentation using =helm-pydoc=                                    |
 | ~SPC m h h~ | quick documentation using anaconda                                           |
 | ~SPC m h H~ | open documentation in =firefox= using [[https://github.com/tsgates/pylookup][pylookup]]                               |
 | ~SPC m v s~ | set a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]                                           |
 | ~SPC m v u~ | unset a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]                                         |
 | ~SPC m V w~ | work on virtual environment in =WORKON_HOME=                                 |
 | ~SPC m V a~ | activate a virtual environment in any directory                              |
 | ~SPC m V d~ | deactivate active virtual environment                                        |

** Configuration
*** Fill column
    If you want to customize the fill column value, use something like this inside
    the =user-init= function in your =.spacemacs=:

 #+BEGIN_SRC elisp
 (setq-default dotspacemacs-configuration-layers '(
     (python :variables python-fill-column 99)))
 #+END_SRC

*** Sort imports
 If you want imports to be automatically sorted when you save a file (using
 [[https://pypi.python.org/pypi/isort][isort]]), set the =python-sort-imports-on-save= variable in the python layer
 config section:

 #+BEGIN_SRC elisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-sort-imports-on-save t)))
 #+END_SRC

 or as a directory-local variable (for per-project settings).
* 语言
** 对象(词汇)
*** 基本对象
    数量
    字符串(可以格式化)
    未加工字符串 r'/--\'
    范围[1:3]
    1. List（列表）list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] list[1:2]
    2. 元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )!元组不让更新
    3. 字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
    4. 空值　 None
    5. set(集合) python 的 set 和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。set 和 dict 类似，但是 set 不存储 value 值的。

**** 双精度浮点型
 不精确的，如果想用更加精度的(精度位数多了)，可以导入 decimals, 但其实还是没算对
 设置精度后可能就算对了，没想
 #+BEGIN_SRC python
 设置精度
   >>> from decimal import *
   >>> getcontext()
   Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
           capitals=1, flags=[], traps=[Overflow, DivisionByZero,
           InvalidOperation])

   >>> getcontext().prec = 7       # Set a new precision
 #+END_SRC

 #+RESULTS:
*** ## 5、List（列表）运算符 ##

列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。

|Python 表达式|结果|描述|
|-----------|-----|-----|
|len([1, 2, 3])|3|计算元素个数|
|[1, 2, 3] + [4, 5, 6]|	[1, 2, 3, 4, 5, 6]|	组合|
|['Hi!'] * 4|['Hi!', 'Hi!', 'Hi!', 'Hi!']|复制|
|3 in [1, 2, 3]|True|元素是否存在于列表中|
|for x in [1, 2, 3]: print x,|1 2 3|迭代|
*** ## 6、List （列表）函数&方法 ##

|函数&方法|描述|
|----|----|
|cmp(list1, list2)|比较两个列表的元素|
|len(list)|列表元素个数|
|max(list)|返回列表元素最大值|
|min(list)|返回列表元素最小值|
|list(seq)|将元组转换为列表|
|list.append(obj)|在列表末尾添加新的对象|
|list.count(obj)|统计某个元素在列表中出现的次数|
|list.extend(seq)|在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）|
|list.index(obj)|从列表中找出某个值第一个匹配项的索引位置|
|list.insert(index, obj)|将对象插入列表|
|list.pop(obj=list[-1])|移除列表中的一个元素（默认最后一个元素），并且返回该元素的值|
|list.reverse()|反向列表中元素|
|list.sort([func])|对原列表进行排序|
*** ## 6、tuple （元组）运算符 ##
    
与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。

|Python 表达式|结果|描述|
|-----------|-----|-----|
|len((1, 2, 3))|3|计算元素个数|
|(1, 2, 3) + (4, 5, 6)|(1, 2, 3, 4, 5, 6)|连接|
|('Hi!',) * 4|('Hi!', 'Hi!', 'Hi!', 'Hi!')|复制|
|3 in (1, 2, 3)|True|元素是否存在|
|for x in (1, 2, 3): print x,|1 2 3|迭代|
*** ## 7、元组内置函数 ##

|方法|描述|
|----|----|
|cmp(tuple1, tuple2)|比较两个元组元素|
|len(tuple)|计算元组元素个数|
|max(tuple)|返回元组中元素最大值|
|min(tuple)|返回元组中元素最小值|
|tuple(seq)|将列表转换为元组|
*** 分支循环
    if elif else
   while for  
*** 函数 
**** 定义函数
     #+BEGIN_SRC python
       def functionname( parameters ):
           "函数_文档字符串"
           function_suite
           return [expression]
     #+END_SRC
**** 返回多个值
     return b , a
     其实是一个元组
**** ## 3、不定长参数 ##


有时我们在设计函数接口的时候，可会需要可变长的参数。也就是说，我们事先无法确定传入的参数个数。Python 提供了一种元组的方式来接受没有直接定义的参数。这种方式在参数前边加星号 `*` 。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。

例如：

```python
# -*- coding: UTF-8 -*-

def print_user_info( name ,  age  , sex = '男' , * hobby):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( '两点水' ,18 , '女', '打篮球','打羽毛球','跑步')

```

输出的结果：

```python
昵称：两点水 年龄：18 性别：女 爱好：('打篮球', '打羽毛球', '跑步')
```

通过输出的结果可以知道，`*hobby`是可变参数，且 hobby其实就是一个 tuple （元祖）


可变长参数也支持关键参数，没有被定义的关键参数会被放到一个字典里。这种方式即是在参数前边加 `**`,更改上面的示例如下：


```python
# -*- coding: UTF-8 -*-

def print_user_info( name ,  age  , sex = '男' , ** hobby ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( name = '两点水' , age = 18 , sex = '女', hobby = ('打篮球','打羽毛球','跑步'))

```

输出的结果：

```txt
昵称：两点水 年龄：18 性别：女 爱好：{'hobby': ('打篮球', '打羽毛球', '跑步')}	
```

通过对比上面的例子和这个例子，可以知道，`*hobby`是可变参数，且 hobby其实就是一个 tuple （元祖），`**hobby`是关键字参数，且 hobby 就是一个 dict （字典）
**** ## 4、只接受关键字参数 ##

关键字参数使用起来简单，不容易参数出错，那么有些时候，我们定义的函数希望某些参数强制使用关键字参数传递，这时候该怎么办呢？

将强制关键字参数放到某个`*`参数或者单个`*`后面就能达到这种效果,比如：

```python
# -*- coding: UTF-8 -*-

def print_user_info( name , *, age  , sex = '男' ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex))
    return;

# 调用 print_user_info 函数
print_user_info( name = '两点水' ,age = 18 , sex = '女' )

# 这种写法会报错，因为 age ，sex 这两个参数强制使用关键字参数
#print_user_info( '两点水' , 18 , '女' )
print_user_info('两点水',age='22',sex='男')
```

通过例子可以看，如果 `age` , `sex` 不适用关键字参数是会报错的。

很多情况下，使用强制关键字参数会比使用位置参数表意更加清晰，程序也更加具有可读性。使用强制关键字参数也会比使用 `**kw` 参数更好且强制关键字参数在一些更高级场合同样也很有用。
**** # 五、匿名函数 #

有没有想过定义一个很短的回调函数，但又不想用 `def` 的形式去写一个那么长的函数，那么有没有快捷方式呢？答案是有的。

python 使用 lambda 来创建匿名函数，也就是不再使用 def 语句这样标准的形式定义一个函数。

匿名函数主要有以下特点：

 lambda 只是一个表达式，函数体比 def 简单很多。
 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
 lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。

**基本语法**

```python
lambda [arg1 [,arg2,.....argn]]:expression
```

示例：

```python
# -*- coding: UTF-8 -*-

sum = lambda num1 , num2 : num1 + num2;

print( sum( 1 , 2 ) )

```

输出的结果：

```txt
3
```

注意：**尽管 lambda 表达式允许你定义简单函数，但是它的使用是有限制的。 你只能指定单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了， 包括多个语句、条件表达式、迭代以及异常处理等等。**

匿名函数中，有一个特别需要注意的问题，比如，把上面的例子改一下：

```python
# -*- coding: UTF-8 -*-

num2 = 100
sum1 = lambda num1 : num1 + num2 ;

num2 = 10000
sum2 = lambda num1 : num1 + num2 ;

print( sum1( 1 ) )
print( sum2( 1 ) )
```

你会认为输出什么呢？第一个输出是 101，第二个是 10001，结果不是的，输出的结果是这样：

```txt
10001
10001
```

这主要在于 lambda 表达式中的 num2 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。所以建议还是遇到这种情况还是使用第一种解法。
*** 迭代器
    迭代器有两个基本的方法：iter() 和 next(),且字符串，列表或元组对象都可用于创建迭代器，迭代器对象可以使用常规 for 语句进行遍历，也可以使用 next() 函数来遍历。
#+BEGIN_SRC python
  # 1、字符创创建迭代器对象
  str1 = 'liangdianshui'
  iter1 = iter ( str1 )

  # 2、list对象创建迭代器
  list1 = [1,2,3,4]
  iter2 = iter ( list1 )

  # 3、tuple(元祖) 对象创建迭代器
  tuple1 = ( 1,2,3,4 )
  iter3 = iter ( tuple1 )

  # for 循环遍历迭代器对象
  for x in iter1 :
      print ( x , end = ' ' )

  print('\n------------------------')
 
  # next() 函数遍历迭代器
  while True :
      try :
          print ( next ( iter3 ) )
      except StopIteration :
          break

#+END_SRC
**** ## 2、list 生成式的创建 ##

首先，lsit 生成式的语法为：

```python
[expr for iter_var in iterable] 
[expr for iter_var in iterable if cond_expr]
```

第一种语法：首先迭代 iterable 里所有内容，每一次迭代，都把 iterable 里相应内容放到iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计算值生成一个列表。

第二种语法：加入了判断语句，只有满足条件的内容才把 iterable 里相应内容放到 iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计算值生成一个列表。

其实不难理解的，因为是 list 生成式，因此肯定是用 [] 括起来的，然后里面的语句是把要生成的元素放在前面，后面加 for 循环语句或者 for 循环语句和判断语句。

例子：

```python
# -*- coding: UTF-8 -*-
lsit1=[x * x for x in range(1, 11)]
print(lsit1)
```

输出的结果：

```txt
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

可以看到，就是把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来。那么 for 循环后面有 if 的形式呢？又该如何理解：

```python
# -*- coding: UTF-8 -*-
lsit1= [x * x for x in range(1, 11) if x % 2 == 0]
print(lsit1)
```

输出的结果：

```txt
[4, 16, 36, 64, 100]
```

这个例子是为了求 1 到 10 中偶数的平方根，上面也说到， `x * x` 是要生成的元素，后面那部分其实就是在 for 循环中嵌套了一个 if 判断语句。

那么有了这个知识点，我们也可以猜想出，for 循环里面也嵌套 for 循环。具体示例：

```python
# -*- coding: UTF-8 -*-
lsit1= [(x+1,y+1) for x in range(3) for y in range(5)] 
print(lsit1)
```

输出的结果：

```txt
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)]
```

其实知道了 list 生成式是怎样组合的，就不难理解这个东西了。因为 list 生成式只是把之前学习的知识点进行了组合，换成了一种更简洁的写法而已。
**** # 四、生成器 #

## 1、为什么需要生成器 ##

通过上面的学习，可以知道列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 1000 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。

在 Python 中，使用了 yield 的函数被称为生成器（generator）。

跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。

那么如何创建一个生成器呢？


## 2、生成器的创建 ##

最简单最简单的方法就是把一个列表生成式的 `[]` 改成 `()`

```python
# -*- coding: UTF-8 -*-
gen= (x * x for x in range(10))
print(gen)
```

输出的结果：

```txt
<generator object <genexpr> at 0x0000000002734A40>
```

创建 List 和 generator 的区别仅在于最外层的 `[]` 和 `()` 。但是生成器并不真正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生” ( yield ) 出来。 生成器表达式使用了“惰性计算” ( lazy evaluation，也有翻译为“延迟求值”，我以为这种按需调用 call by need 的方式翻译为惰性更好一些)，只有在检索时才被赋值（ evaluated ），所以在列表比较长的情况下使用内存上更有效。


那么竟然知道了如何创建一个生成器，那么怎么查看里面的元素呢？

## 3、遍历生成器的元素 ##

按我们的思维，遍历用 for 循环，对了，我们可以试试：

```python
# -*- coding: UTF-8 -*-
gen= (x * x for x in range(10))

for num  in  gen :
	print(num)
```

没错，直接这样就可以遍历出来了。当然，上面也提到了迭代器，那么用 next() 可以遍历吗？当然也是可以的。


## 4、以函数的形式实现生成器 ##

上面也提到，创建生成器最简单最简单的方法就是把一个列表生成式的 `[]` 改成 `()`。为啥突然来个以函数的形式来创建呢？

其实生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。而且实际运用中，大多数的生成器都是通过函数来实现的。那么我们该如何通过函数来创建呢？

先不急，来看下这个例子：

```python
# -*- coding: UTF-8 -*-
def my_function():
    for i in range(10):
        print ( i )

my_function()
```

输出的结果：

```txt
0
1
2
3
4
5
6
7
8
9
```

如果我们需要把它变成生成器，我们只需要把 `print ( i )` 改为 `yield i` 就可以了，具体看下修改后的例子：

```python
# -*- coding: UTF-8 -*-
def my_function():
    for i in range(10):
        yield i

print(my_function())
```

输出的结果：

```txt
<generator object my_function at 0x0000000002534A40>
```

但是，这个例子非常不适合使用生成器，发挥不出生成器的特点，生成器的最好的应用应该是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。因为这样会耗很大的资源。

比如下面是一个计算斐波那契数列的生成器：

```python
# -*- coding: UTF-8 -*-
def fibon(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

# 引用函数
for x in fibon(1000000):
    print(x , end = ' ')
```

运行的效果：

![计算斐波那契数列的生成器](http://upload-images.jianshu.io/upload_images/2136918-304e50af22b787ce?imageMogr2/auto-orient/strip)

你看，运行一个这么打的参数，也不会说有卡死的状态，因为这种方式不会使用太大的资源。这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，遇到 return 语句或者最后一行函数语句就返回。而变成 generator 的函数，在每次调用 next() 的时候执行，遇到 yield语句返回，再次执行时从上次返回的 yield 语句处继续执行。

比如这个例子：

```python
# -*- coding: UTF-8 -*-
def odd():
    print ( 'step 1' )
    yield ( 1 )
    print ( 'step 2' )
    yield ( 3 )
    print ( 'step 3' )
    yield ( 5 )

o = odd()
print( next( o ) )
print( next( o ) )
print( next( o ) )
```

输出的结果：

```txt
step 1
1
step 2
3
step 3
5
```

可以看到，odd 不是普通函数，而是 generator，在执行过程中，遇到 yield 就中断，下次又继续执行。执行 3 次 yield 后，已经没有 yield 可以执行了，如果你继续打印 `print( next( o ) ) ` ,就会报错的。所以通常在 generator 函数中都要对错误进行捕获。

## 5、打印杨辉三角 ##

通过学习了生成器，我们可以直接利用生成器的知识点来打印杨辉三角：

```python
# -*- coding: UTF-8 -*-
def triangles( n ):         # 杨辉三角形
    L = [1]
    while True:
        yield L
        L.append(0)
        L = [ L [ i -1 ] + L [ i ] for i in range (len(L))]

n= 0
for t in triangles( 10 ):   # 直接修改函数名即可运行
    print(t)
    n = n + 1
    if n == 10:
        break
```

输出的结果为：

```txt
[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]
[1, 5, 10, 10, 5, 1]
[1, 6, 15, 20, 15, 6, 1]
[1, 7, 21, 35, 35, 21, 7, 1]
[1, 8, 28, 56, 70, 56, 28, 8, 1]
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
```
**** # 五、迭代器和生成器综合例子 #

因为迭代器和生成器基本是互通的，因此有些知识点需要综合在一起

## 1、反向迭代 ##

反向迭代，应该也是常有的需求了，比如从一开始迭代的例子里，有个输出 list 的元素，从 1 到 5 的

```python
list1 = [1,2,3,4,5]
for num1 in list1 :
    print ( num1 , end = ' ' )
```

那么我们从 5 到 1 呢？这也很简单， Python 中有内置的函数 `reversed()`

```python
list1 = [1,2,3,4,5]
for num1 in reversed(list1) :
    print ( num1 , end = ' ' )
```

方向迭代很简单，可是要注意一点就是：**反向迭代仅仅当对象的大小可预先确定或者对象实现了 `__reversed__()` 的特殊方法时才能生效。 如果两者都不符合，那你必须先将对象转换为一个列表才行**

其实很多时候我们可以通过在自定义类上实现 `__reversed__()` 方法来实现反向迭代。不过有些知识点在之前的篇节中还没有提到，不过可以相应的看下，有编程基础的，学完上面的知识点应该也能理解的。

```python
# -*- coding: UTF-8 -*-

class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
    	# Forward iterator
        n = self.start
        while n > 0:
            yield n
            n -= 1

    def __reversed__(self):
    	# Reverse iterator
        n = 1
        while n <= self.start:
            yield n
            n += 1

for rr in reversed(Countdown(30)):
    print(rr)
for rr in Countdown(30):
    print(rr)
```

输出的结果是 1 到 30 然后 30 到 1 ，分别是顺序打印和倒序打印

## 2、同时迭代多个序列 ##

你想同时迭代多个序列，每次分别从一个序列中取一个元素。你遇到过这样的需求吗？

为了同时迭代多个序列，使用 zip() 函数，具体示例：

```python
# -*- coding: UTF-8 -*-

names = ['laingdianshui', 'twowater', '两点水']
ages = [18, 19, 20]
for name, age in zip(names, ages):
     print(name,age)
```

输出的结果：

```txt
laingdianshui 18
twowater 19
两点水 20
```

其实 zip(a, b) 会生成一个可返回元组 (x, y) 的迭代器，其中 x 来自 a，y 来自 b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。注意理解这句话喔，也就是说如果 a ， b 的长度不一致的话，以最短的为标准，遍历完后就结束。

利用 `zip()` 函数，我们还可把一个 key 列表和一个 value 列表生成一个 dict （字典）,如下：

```python
# -*- coding: UTF-8 -*-

names = ['laingdianshui', 'twowater', '两点水']
ages = [18, 19, 20]

dict1= dict(zip(names,ages))

print(dict1)

```


输出如下结果：

```python
{'laingdianshui': 18, 'twowater': 19, '两点水': 20}
```

这里提一下， `zip()` 是可以接受多于两个的序列的参数，不仅仅是两个。

*** 数学对象简化操作运算符
**** 算术运算符
     **	幂 - 返回 x 的 y 次幂	a**b 为 10 的 20 次方， 输出结果 100000000000000000000
     //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
*** 模块(对象包)
    !模块名(文件名) 与 类名 相同 
**** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
     import module1[, module2[,... moduleN]
**** From…import 语句
 : Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中
**** globals()和 locals()函数
 : 根据调用地方的不同，globals()和 locals()函数可被用来返回全局和局部命名空间里的名字。
**** reload()函数
 : 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
 : 因此，如果你想重新执行模块里顶层部分的代码，可以用 reload()函数
**** 完成模块
***** 定义用于模块的错误和异常
     #+BEGIN_SRC python
       class sendException(Exception):
             pass
     #+END_SRC
***** 定义模块中要输出的项 
     from module import classname/functionname
     __all__ 中确定的 或是 除去_ 开头的 是公有的
***** 编写文档
     '''items'''
***** 测试, 写好注释, 执行方法
***** 提供调用的回退函数
***** 安装模块     
      通常在 sys.path 的 site-packages 目录下
*** 包 一个包几个类
    使用操作系统原有的目录结构、包是一个目录、如 Hello, 然后在里面创建__init__.py 文件，该文件提示该目录是包目录
    在目录下创建类，类名同文件名要相同，默认只执行 __init__.py 文件，需要在里面 用 from 文件 import 同文件名同的类名
    就可以在调用的源码中 import 包名 了
   
    实例化 时 是 包名+类名
*** 测试模块和包
    if __name== '__main__'
    __name__是 模块或包名的变量, __main__ 用来测试模块中的方法 
*** 类
**** class
     类中方法定义 必须带 self
    #+BEGIN_SRC python
      class wa:
       def __init__(self, items={}):
           '''items'''
           if type(item)!=type({}):
               raise TypeError("类型错误")
           self.items=items
           return
          def	deposit(self,	amount):
           self.balance	=	self.balance	+	amount
           return	self.balance
          def	withdraw(self,	amount):
           if	amount	>	self.balance:
            return	'Insufficient	funds'
    #+END_SRC
**** 初始化函数 
     __init
**** 类的实例 ，没有 new 关键词
     a = Acc('xx')
**** 类的继承
     #+BEGIN_SRC python
       class Subclass(Parentclass):
              def __init__(self):
               Parentclass.__init__

     #+END_SRC
**** 类属性与方法
***** 类的私有属性
      __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
      类的方法
      在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数
***** 类的私有方法
      __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
**** type 函数
** 基本数据类型转换 
| 方法                   | 说明                                                  |
|------------------------+-------------------------------------------------------|
| int(x [,base ])        | 将x转换为一个整数                                     |
| float(x )              | 将x转换到一个浮点数                                   |
| complex(real [,imag ]) | 创建一个复数                                          |
| str(x )                | 将对象 x 转换为字符串                                 |
| repr(x )               | 将对象 x 转换为表达式字符串                           |
| eval(str )             | 用来计算在字符串中的有效 Python 表达式,并返回一个对象 |
| tuple(s )              | 将序列 s 转换为一个元组                               |
| list(s )               | 将序列 s 转换为一个列表                               |
| chr(x )                | 将一个整数转换为一个字符                              |
| unichr(x )             | 将一个整数转换为 Unicode 字符                         |
| ord(x )                | 将一个字符转换为它的整数值                            |
| hex(x )                | 将一个整数转换为一个十六进制字符串                    |
| oct(x )                | 将一个整数转换为一个八进制字符串                      |
** 功能
*** 定义 def funname(a="a"): 默认值
*** 对象属性 
    对象的长度  len(obj), 整数没有长度
    打开文件 open(fn, mode) 以 mode('r' = 读, 'w'= 写)方式打开一个文件名为 fn 的文件
    对象 type 还能判断是类 还是实例, 还可以直接用 isinstance()判断
    读键盘 input(str)
    切片 相当于从 排序的东西 选择 某种间隔的东西, 符号代表反向
 #+BEGIN_SRC python
foostr = 'abcde'
foostr[::-1]
 #+END_SRC 
 and or 没有 C 中的 || 和&& 了
 is, is not 比较两个东西一样不一样
 not 逻辑否定
*** 文件
**** 键盘输入
***** : raw_input 函数
 : raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
***** : input 函数
 : input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个 Python 表达式作为输入，并将运算结果返回
**** 打开和关闭文件 
***** open 
***** close
***** write
***** read
***** 文件定位
***** 重命名和删除文件
***** remove()方法
**** 目录
***** mkdir()方法 
***** chdir()方法 
***** rmdir()方法 
*** math
    max()
    pow(100,	2) 平方
    sqrt  平方根
    e
*** operator	 提供了中缀运算
    add()  和
    sub()
    mul
    div
    concat
    operator.lt(a, b)
   operator.le(a, b)
   operator.eq(a, b)
   operator.ne(a, b)
   operator.__lt__(a, b)
   operator.__le__(a, b)
   operator.__eq__(a, b)
   operator.__ne__(a, b)
   operator.__ge__(a, b)
   operator.__gt__(a, b)
*** functools
** 具体对象
*** json
**** encode 	将 Python 对象编码成 JSON 字符串
**** decode	将已编码的 JSON 字符串解码为 Python 对象
     pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
** 流程控制
   #+BEGIN_SRC python
     if 判断条件：
     执行语句……
     else：
     执行语句……
#+END_SRC

while 循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
循环控制
break
continue
assert(3>4) 断言, 产生此种情况会中断

** 帮助
   help()  函数或类文档字串说明
   dir() 函数或类的性质
** 对象监控(异常处理)
*** 捕捉异常可以使用 try/except 语句
#+BEGIN_SRC python
  try:
  <语句>        #运行别的代码
  except <名字>：
  <语句>        #如果在 try 部份引发了'name'异常
  except <名字>，<数据>:
  <语句>        #如果引发了'name'异常，获得附加的数据
  else:
  <语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** CGI 对象
: CGI 程序可以是 Python 脚本，PERL 脚本，SHELL 脚本，C 或者 C++程序等
*** Web 服务器支持及配置

在你进行 CGI 编程前，确保您的 Web 服务器支持 CGI 及已经配置了 CGI 的处理程序。

Apache 支持 CGI 配置：

设置好 CGI 目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的 HTTP 服务器执行 CGI 程序都保存在一个预先配置的目录。这个目录被称为 CGI 目录，并按照惯例，它被命名为/var/www/cgi-bin 目录。

CGI 文件的扩展名为.cgi，python 也可以使用.py 扩展名。

默认情况下，Linux 服务器配置运行的 cgi-bin 目录中为/var/www。

如果你想指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个 CGI 程序

我们使用 Python 创建第一个 CGI 程序，文件名为 hello.py，文件位于/var/www/cgi-bin 目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一 CGI 程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI 环境变量
: 所有的 CGI 程序都接收以下的环境变量，这些变量在 CGI 程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的 MIME 类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded,他表示数据来自于 HTML 表单。
CONTENT_LENGTH	如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。
QUERY_STRING	如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。
REMOTE_HOST	这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI 脚本的完整路径
SCRIPT_NAME	CGI 脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或 IP 地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)
** 网络对象
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统 Socket 接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
* Web 框架
** 轻量级
** 重量级
*** Django
**** ### 一个完整的初学者指南Django - 第1部分

  ![一个完整的初学者指南Django  - 第1部分](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/featured.jpg)


  ![Python 3.6.2](https://img.shields.io/badge/python-3.6.2-brightgreen.svg) ![Django 1.11.4](https://img.shields.io/badge/django-1.11.4-brightgreen.svg)


 #### 介绍

 ![欢迎班](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Welcome_Class.png)


 今天我将开始一个关于 Django 基础知识的新系列教程。这是一个完整的 Django 初学者指南。材料分为七个部分。我们将从安装，开发环境准备，模型，视图，模板，URL 到更高级主题（如迁移，测试和部署）来探索所有基本概念。


 我想做一些不同的事情。一个教程，易于遵循，信息丰富和有趣的阅读。因此我想出了在文章中创建一些漫画的想法来说明一些概念和场景。希望你喜欢这种阅读方式！


 但在我们开始之前......


 我想通过孔夫子的名言来开始我们的课程：

 > 我听见了，我就忘了
 > 
 > 我看见了，我就记得了
 > 
 > 我去做了，我就理解了

 ![孔子名言](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Confucius_Quote.png)

 所以，一定要动手！不要只阅读教程。让我们一起来实操，这样你将通过做和练会学习到更多的知识。

  * *

 #### 为什么选择 Django？


 Django 是一个用 Python 编写的 Web 框架。这个 Web 框架支持动态网站，应用程序和服务开发。它提供了一组工具和功能，可解决许多与 Web 开发相关的常见问题，例如安全功能，数据库访问，会话，模板处理，URL 路由，国际化，本地化等等。


 使用诸如 Django 之类的 Web 框架，能使我们能够以标准化的方式快速开发安全可靠的Web 应用程序，从而无需重新开发。


 那么，Django 有什么特别之处呢？

 对于初学者来说，这是一个 Python Web 开源框架，这意味着您可以从各种各样的开源库中受益。在[python软件资料库(pypi)](https://pypi.python.org/pypi) 中托管了超过 **11.6万** 个的包（按照 2017 年 9 月 6 日的数据）。如果你需要解决一个特定问题的时候，可能已经有相关的库给你使用。

 Django 是用 Python 编写的最流行的 Web 框架之一。它可以提供各种功能，例如用于开发和测试的独立 Web 服务器，缓存，中间件系统，ORM，模板引擎，表单处理，基于 Python 单元测试工具的接口。Django 还附带了电池，提供内置应用程序，如认证系统，具有自动生成`CRUD`(增删改除)操作页面的管理界面，生成订阅文档（RSS / Atom），站点地图等。甚至在 Django 中建立了一个地理信息系统（GIS）框架。

 而且 Django 的开发得到了 [Django软件基金会的](https://www.djangoproject.com/foundation/)支持，并且由 JetBrains 和 Instagram 等公司赞助。Django 到目前为止，已经持续开发维护超过12年了，这足以证明它是一个成熟，可靠和安全的 Web 框架。

 ##### 谁在使用Django？

 为什么要知道谁在使用 Django 呢？

 因为这能很好的让我们了解和知道它能做些什么？

 在使用 Django 的最大网站中，有：[Instagram](https://instagram.com/)， [Disqus](https://disqus.com/)，[Mozilla](https://www.mozilla.org/)， [Bitbucket](https://bitbucket.org/)，[Last.fm](https://www.last.fm/)， [National Geographic](http://www.nationalgeographic.com/)。

 当然，远远不止上面列举的这些，你可以看下 [Django Sites](https://www.djangosites.org/) 数据库，它们提供了超过 **5000** 个 Django 支持的 Web站点的列表。

 顺便说一下，去年在 Django Under The Hood 2016 大会上，Django 核心开发人员Carl Meyer 和 Instagram 员工就[如何在规模上使用Django](https://www.youtube.com/watch?v=lx5WQjXLlq8) 以及它如何支持其增长展开了一次演讲。这是一个长达一个小时的谈话，如果你有兴趣的话，可以去了解下。


  * *

 #### 安装

 如果我们想开始使用 Django ，那么我们需要安装一些应用程序，包括安装 **Python**，**Virtualenv** 和 **Django**。

 ![基本设置](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Basic_Setup.png)


 一开始，强烈建议使用虚拟环境，虽然不是强制性的，可是这对于初学者来说，是一个很好的开端.


 在使用 Django 开发 Web 站点或 Web 项目时，必须安装外部库以支持开发是非常常见的。使用虚拟环境，您开发的每个项目都会有其独立的环境。所以依赖关系不会发生冲突。它还允许您维护在不同 Django 版本上运行的本地计算机项目。


 ##### 安装Python 3.6.2

 我们想要做的第一件事是安装最新的  Python 发行版，它是 **Python 3.6.2**。至少在我写这篇教程的时候是这样。如果有更新的版本，请与它一起使用。接下来的步骤应该保持大致相同。

 我们将使用 Python 3，因为最重要的 Python 库已经移植到 Python 3，并且下一个主要的 Django 版本（2.x）不再支持 Python 2。所以 Python 3 是很有必要的。

 在 Mac 中，最好的安装方法就是 [Homebrew](https://brew.sh/)。如果您还没有在Mac 上安装它，请在 **终端** 运行以下命令：

 ```
 /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
 ```

 如果您没有安装**命令行工具`(Command Line Tools)`**，则 Homebrew 安装可能需要更长一点时间。但它会自动处理，所以不用担心。请坐下来等到安装完成。

 当您看到以下消息时，您会知道安装何时完成：


 ```
 ==> Installation successful!

 ==> Homebrew has enabled anonymous aggregate user behaviour analytics.
 Read the analytics documentation (and how to opt-out) here:
   https://docs.brew.sh/Analytics.html

 ==> Next steps:
 - Run `brew help` to get started
 - Further documentation:
     https://docs.brew.sh
 ```

 请运行以下命令来安装Python 3：

 ```
 brew install python3
 ```


 由于 macOS 已经安装了Python 2，所以在安装 Python 3 之后，您将可以使用这两个版本。

 要运行 Python 2，请使用`python`终端中的命令。对于 Python 3，请`python3`改用。

 我们可以通过在终端中输入来测试安装：

 ```
 python3 --version
 Python 3.6.2
 ```

 ![macOS测试Python 3](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/test-python.png)

 到此时，Python 已经安装完成了。进入下一步：虚拟环境！

 ##### 安装 Virtualenv

 接下来这一步，我们将通过 **pip**(一个管理和安装Python包的工具)来安装**Virtualenv**。


 请注意，Homebrew 已经为您的 Python 3.6.2 安装了 `pip3`。

 在终端中，执行下面的命令：

 ```
 sudo pip3 install virtualenv
 ```

 ![pip3安装virtualenv](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/pip-virtualenv.png)


 到目前为止，我们执行的操作都是在系统环境下的。不过，从这一刻起，我们安装的所有东西，包括 Django 本身，都将安装在虚拟环境中。


 你可以这样想像一下：对于每个 diango 项目，我们都会为它创建一个虚拟环境。这就好比每个 Django 项目都是一个独立的沙盒，你可以在这个沙盒里随意的玩，安装软件包，卸载软件包，不管怎么对系统环境都不会有任何影响，也不会对其他项目有影响。


 我个人喜欢在我的电脑上创建一个 **Development** 的文件夹，然后在这个文件夹下存放我的所有项目。当然，你也可以根据下面的步骤来创建你个人的目录。


 通常，我会在我的 **Development** 文件夹中创建一个项目名称的新文件夹。竟然这是我们的第一个项目，就直接将项目名称起为 **myproject**。

 ```
 mkdir myproject
 cd myproject
 ```

 ![创建myproject文件夹](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/myproject.png)


 该文件夹将存储与 Django 项目相关的所有文件，包括其虚拟环境。

 接下来，我们将开始创建我们第一个虚拟环境和安装 Django。

 在 **myproject** 文件夹中，我们创建一个基于 python 3 的虚拟环境。

 ```
 virtualenv venv -p python3
 ```

 ![VIRTUALENV](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/venv.png)

 如上图所示，我们的虚拟环境已创建完成。那么我们将如何使用它呢？


 当然，我们先开启虚拟环境啦，可以通过以下命令来激活一下虚拟环境：


  ```
  source venv/bin/activate
  ```

 如果你在命令行的前面看到 **（venv）**，就说明，虚拟环境激活成功，现在已经进入到虚拟环境里面了。如下图所示：


 ![Virtualenv激活](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/activate.png)


 那么这里面到底发生了什么呢？


 其实这里我们首先创建了名为 **venv** 的特殊文件夹，这个文件夹里面有 python 的副本，当我们激活 **venv** 环境之后，运行 `Python` 命令时，它使用的是存储在 **venv** 里面 `Python` 环境 ，而不是我们装在操作系统上的。


 如果在该环境下，我们使用 **PIP** 安装 python 软件包，比如 Django ，那么它是被安装在 **venv** 的虚拟环境上的。


 这里有一点需要注意的，当我们启动了 **venv** 这个虚拟环境后，我们使用命令 `python` 就能调用 python 3.6.2 ，而且也仅仅使用 `pip`（而不是`pip3`）来安装软件包。


 那么如果我们想退出 **venv** 虚拟环境，该如何操作呢？

 只要运行以下命令就可以：

 ```
 deactivate
 ```

 不过，现在我们先不退出虚拟环境 **venv** ，保持着虚拟环境的激活状态，开始下一步操作。




 ##### 安装Django 1.11.4

 现在我们来安装以下 Django 1.11.4 ，因为我们已经开启了虚拟环境 **venv** ，因此，这操作会非常的简单。我们将运行下面的命令来安装 Django ：

 ```
 pip install django
 ```

 ![pip安装django](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/pip-django.png)


 安装成功了，现在一切都准备就绪了！


 ![结束安装](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_End_Installation.png)

  * *

 #### 开始一个新项目

 要开始一个新的 Django项目，运行下面的命令：

 到目前为止，我们终于可以开始一个新的 Django 项目了，运行下面的命令，创建一个 Django 项目：

 ```
 django-admin startproject myproject
 ```

 命令行工具 **django-admin** 会在安装 Django 的时候一起安装的。


 当我们运行了上面的命令之后，系统就会自动的为 Django 项目生成基础的文件。


 我们可以打开 **myproject** 目录，可以看到具体的文件结构如下所示：


 ```
 myproject/                  <-- higher level folder
  |-- myproject/             <-- django project folder
  |    |-- myproject/
  |    |    |-- __init__.py
  |    |    |-- settings.py
  |    |    |-- urls.py
  |    |    |-- wsgi.py
  |    +-- manage.py
  +-- venv/                  <-- virtual environment folder
 ```


 可以看到，一个初始 Django 的项目由五个文件组成：


    **manage.py**：**django-admin** 是命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。
    **__init__.py**：这个空文件告诉 Python 这个文件夹是一个 Python 包。
    **settings.py**：这个文件包含了所有的项目配置。我们会一直使用到这个文件。
    **urls.py**：这个文件负责映射我们项目中的路由和路径。例如，如果您想在 URL `/about/` 中显示某些内容，则必须先将其映射到此处。
    **wsgi.py**：该文件是用于部署简单的网关接口。现在我们暂时不用关心它的内容。



 Django 自带有一个简单的 Web 服务器。在开发过程中非常方便，所以我们不需要安装其他任何软件即可以在本地运行项目。我们可以通过执行命令来运行它：

 ```
 python manage.py runserver
 ```


 现在在 Web 浏览器中打开以下 URL：**http://127.0.0.1:8000**，您应该看到以下页面：


 ![有效！](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/it-worked.png)


 这里提醒一点，如果你需要停止服务器，可以 `Control + C` 点击停止开发服务器。

  * *

 #### Django 的应用


 在 Django 哲学中，我们有两个重要的概念：

    **app**：是一个可以执行某些操作的 Web 应用程序。一个应用程序通常由一组 models(数据库表)，views(视图)，templates(模板)，tests(测试) 组成。
    **project**：是配置和应用程序的集合。一个项目可以由多个应用程序或一个应用程序组成。

 请注意，如果没有一个 project，你就无法运行 Django 应用程序。像博客这样的简单网站可以完全在单个应用程序中编写，例如可以将其命名为 blog或 weblog。

 ![Django应用程序](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Django_Apps.png)


 当然这是组织源代码的一种方式，现在刚入门，判断确定什么是不是应用程序这些还不太重要。包括如何组织代码等，现在都不是担心这些问题的时候。现在，首先让我们先熟悉了解 Django 的 API 和基础知识。

 好了，为了更好的了解，我们先来创建一个简单的论坛项目，那么我们要创建一个应用程序，首先要进入到 **manage.py** 文件所在的目录并执行以下命令：

 ```
 django-admin startapp boards
 ```


 请注意，这次我们使用了命令 **startapp**。

 这会给我们以下的目录结构：

 ```
 myproject/
  |-- myproject/
  |    |-- boards/                <-- our new django app!
  |    |    |-- migrations/
  |    |    |    +-- __init__.py
  |    |    |-- __init__.py
  |    |    |-- admin.py
  |    |    |-- apps.py
  |    |    |-- models.py
  |    |    |-- tests.py
  |    |    +-- views.py
  |    |-- myproject/
  |    |    |-- __init__.py
  |    |    |-- settings.py
  |    |    |-- urls.py
  |    |    |-- wsgi.py
  |    +-- manage.py
  +-- venv/
 ```


 所以，我们先来看看每个文件的功能：
    **migrations /**：在这个文件夹中，Django 会存储一些文件以跟踪您在 **models.py** 文件中创建的更改，目的是为了保持数据库和 **models.py** 同步。
    **admin.py**：这是 Django应用程序一个名为 **Django Admin** 的内置配置文件。
    **apps.py**：这是应用程序本身的配置文件。
    **models.py**：这里是我们定义 Web 应用程序实体的地方。models  由 Django 自动转换为数据库表。
    **tests.py**：该文件用于为应用程序编写单元测试。
    **views.py**：这是我们处理Web应用程序请求(request)/响应(resopnse)周期的文件。

 现在我们创建了我们的第一个应用程序，让我们来配置一下项目以便启用这个应用程序。


 为此，请打开**settings.py**并尝试查找`INSTALLED_APPS`变量：

 **settings.py**

 ```
 INSTALLED_APPS = [
     'django.contrib.admin',
     'django.contrib.auth',
     'django.contrib.contenttypes',
     'django.contrib.sessions',
     'django.contrib.messages',
     'django.contrib.staticfiles',
 ]
 ```

 正如你所看到的，Django 已经安装了6个内置的应用程序。它们提供大多数Web应用程序所需的常用功能，如身份验证，会话，静态文件管理（图像，JavaScript，CSS等）等。

 我们将会在本系列教程中探索这些应用程序。但现在，先不管它们，只需将我们的应用程序 boards 添加到 `INSTALLED_APPS` 列表即可：

 ```
 INSTALLED_APPS = [
     'django.contrib.admin',
     'django.contrib.auth',
     'django.contrib.contenttypes',
     'django.contrib.sessions',
     'django.contrib.messages',
     'django.contrib.staticfiles',

     'boards',
 ]
 ```

 使用上个漫画中的正方形和圆形的比喻，黄色圆圈将成为我们的 **boards** 应用程序，而 **django.contrib.admin**，**django.contrib.auth** 等将成为红色圆圈。

  * *

 #### Hello, World!


 现在我们先来写一个我们的第一个 **视图（view）** ，那么，现在我们来看看该如何使用 Django 来创建一个新的页面吧。


 打开 **boards** 应用程序中的 **views.py** 文件，并添加下面的代码：

 **views.py**

 ```python
 from django.http import HttpResponse

 def home(request):
     return HttpResponse('Hello, World!')
 ```

 **视图（view）** 是接收 `HttpRequest` 对象并返回 `HttpResponse`对象的 Python 函数。接收 request 作为参数并返回 response 作为结果。这个过程是需要我们记住的。


 因此，就像我们上面的代码，我们定义了一个简单的视图，命名为 `home` ，然后我们简单的返回了一个字符串 **Hello，World！**


 那么我们直接运行就可以了吗？

 并不是的，我们还没有告诉 Django 什么时候调用这个 **视图（view）** 呢？这就需要我们在 **urls.py** 文件中完成：


 **urls.py**

 ```Python
 from django.conf.urls import url
 from django.contrib import admin

 from boards import views

 urlpatterns = [
     url(r'^/code>, views.home, name='home'),
     url(r'^admin/', admin.site.urls),
 ]
 ```


 如果您将上面的代码段与您的 **urls.py** 文件进行比较，您会注意到我添加了以下的代码：`url(r'^$', views.home, name='home')` 并使用我们的应用程序 **boards** 中导入了 **views** 模块。`from boards import views`

 可能这里大家还是会有很多疑问，不过先这样做，在后面我们会详细探讨这些概念。

 但是现在，Django 使用**正则表达式**来匹配请求的URL。对于我们的 **home** 视图，我使用的是`^$`正则表达式，它将匹配空白路径，这是主页（此URL：**http://127.0.0.1:8000**）。如果我想匹配URL **http://127.0.0.1:8000/homepage/**，那么我们 url 的正则表达式就应该这样写：`url(r'^homepage/$', views.home, name='home')`。

 运行项目，让我们看看会发生什么：

 ```
 python manage.py runserver
 ```


 在 Web 浏览器中，打开 http://127.0.0.1:8000 ：


 ![你好，世界！](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/hello-world.png)


 这样我们就看到了我们刚刚创建的第一个界面了。

  * *

 #### 总结

 这是本系列教程的第一部分。在本教程中，我们学习了如何安装最新的 Python 版本以及如何设置开发环境。我们还介绍了虚拟环境，并开始了我们第一个 Django 项目，并已创建了我们的初始应用程序。

 我希望你喜欢第一部分！第二部将涉及模型，视图，模板和网址。我们将一起探索所有的Django 基础知识！

 就这样我们可以保持在同一页面上，我在 GitHub 上提供了源代码。项目的当前状态可以在发布**release tag v0.1-lw**下找到。下面的链接将带你到正确的地方：

 [https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw](https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw)
**** #### 介绍
欢迎来到 Django 教程的第二部分！在上一课中，我们安装了项目所需要的一切软件，希望你们在学习这篇文章之前，安装了 Python 3.6，并且在虚拟环境中运行Django 1.11。因为，在本篇文章中，我们将继续在这个项目中编写我们的代码。


在这一篇文章中，可能不会有太多的代码操作，主要是讨论分析项目。在下一篇中，我们就开始学习 Django 的基础知识，包括模型（models），管理后台（admin），视图（views），模板（templates）和 路由（URL）。


在这里，还是跟第一篇一样，建议大家多动手。

 * *

#### 论坛项目


每个人的学习习惯都是不同的，不知道你们是怎样的，就我个人而言，通过看实例和一些代码片段，可以让我学的更多，学的更快。但是，有些时候当我们看到 `Class A`和`Class B` ，或者是 `foo(bar)` 这样的例子的时候，我们是很难理解这些概念的。


所以在我们进入模型（models），创建视图（views） 这些有趣的代码实操之前，我们还是需要花点时间，简单的讨论一下我们将怎样设计，开发这个项目。


但是如果你已经有 web 开发经验的，而且觉得讲的太细了，那么你可以快速的浏览一下，然后进入到 【模型（models）】那一块中。

如果你对 Web 开发并不熟悉，那么我强烈建议你认真阅读下去。这里会介绍 web 应用程序开发的建模和设计，因为对于 web 开发来说，敲代码只是其中的一部分，模型的设计也是很重要的。


![火箭科学](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Rocket_Science.png)


##### 用例图


我们的项目本身是一个论坛系统，整个项目来说就是维护几个【论坛板块（boards）】 ，然后在每个板块里面，用户可以通过创建【主题（Topic）】并且在主题中讨论。


一般情况下，只有管理员才能创建【论坛板块（boards）】，那么在用户这方面，我们就需要分为普通用户和管理员用户了，而且他们拥有的权限是不同的，管理员用户可以创建 【论坛板块（boards）】，【主题（Topic）】以及讨论回复，而普通用户只能发布【主题（Topic）】以及讨论回复。具体每个用户角色的功能分配如下图：



> 图1：Web Board 核心功能的用例图


![用例图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/use-case-diagram.png)



##### 类图


从上面的用例图中，我们可以开始思考我们项目中的**实体类**有哪些了。这些实体是我们要创建的模型，它与我们的 Django 应用非常密切。


如果要实现上面我们说到的论坛，那么我们至少需要以下的几个模型：**Board**，**Topic**，**Post**和**User**。

 **Board** : 版块
 **Topic** : 主题
 **Post** : 帖子（用户评论与回复）
 **User** : 用户


> 图2：Web Board 类图


![基本类图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/basic-class-diagram.png)


上面我们只是说了需要有几个模型，并没有提到模型与模型之间是怎么关联的。


通过上面的图片我们可以知道，主题（Topic）与版块（Board） 之间是有关联的，就好比我们需要知道这个主题（Topic） 是属于哪一个版块的（Board），因此我们需要一个字段，也就是可以通过外键爱关联它们。


同样的，一个帖子（Post） 也是需要确定它是那个主题的，当然，用户和主题（Topic）和帖子（Post） 之间也是有联系的，因为我们需要确认是谁发的帖子，是谁回复评论了内容。


竟然知道了模型之间的联系了，那么我们也必须要考虑这些模型应该存放哪些信息。就目前而言，我们的模型可以设计成这样：


> 图3：类（模型）之间关系的类图


![类图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram.png)



这个类图强调的是模型之间的关系，当然最后这些线条和箭头都会用字段来进行表示。

**Board（版块模型）** ：Board 中有 **name** 和 **description** 这两个字段，name 是唯一的，主要是为了避免两个名称重复。description 则是用于描述把这个版块来用干什么的。


**Topic（主题模型）** ：subject 表示主题内容，last_update 用来定义话题的排序，starter 用来识别谁发起的话题，board 用于指定它属于哪个版块


**Post（帖子模型）** ： message 字段，用于存储回复的内容，created_at 创建的时间，在排序时候用（最先发表的帖子排最前面），updated_at 更新时间，告诉用户是否更新了内容，同时，还需要有对应的 User 模型的引用，Post 由谁创建的和谁更新的。


**User（用户模型）** ：这里有 username ，password，email 和 is_superuser 四个字段。


这里值得注意的是，我们在 Django 应用中，不需要创建 User 用户模型，因为在 Django 的 contrib 中已经内置了 User 模型，我们可以直接拿来使用，就没必要重新创建了。


认真观察的童鞋应该看到了，上面的模型关系图中，模型与模型之间的对应关系有数字 1，0..* 等等的字段，这是代表什么意思呢？


如下图，`1` 代表一个 Topic 必须与一个  Board 相关联，`0..*` 代表 Board 下面可能会有多个和 0 个 Topic ，也就是一对多的关系。


![类图板和主题协会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-board-topic.png)


这里也是一样，`1` 代表一个 Post 只有一个  Topic ，`1..*` 代表一个 Topic 下面可能会有 1 个和多个个 Post ，也就是说，一个主题最少一个一个帖子。



![类图主题和帖子关联](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-post.png)


`1` 代表一个 Topic 有且至于一个  User ，`0..*` 代表一个 User（用户） 可能拥有多个 Topic ，也可能没有。


![类图主题和用户关联](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-user.png)


Post（帖子） 和 User（用户）的关系也是类似，一个 Post 必须有一个 User ，而一个 User 可能没有也可能有多个 Post。这里的 Post ，用户发布了之后是可以进行修改的，也就是更新（updated_by），当然如果又被修改，updated_by 就是为空了。


![类图邮政和用户协会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-post-user.png)一


当然，如果你觉得上面的图看起来很复杂，那么你也可以不需要强调模型与模型之间的关系，直接强调字段就可以了，如下图：


> 图4：强调类（模型）属性（字段）的类图


![类图属性](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-attributes.png)


其实这种表达图和前面那个显示箭头和线的表达图，要表达的内容是一样的。不过使用这种表达方式可能更符合 Django  Modles API 的设计。


好了，现在已经够 UML 了！为了绘制本节介绍的图表，我使用的是 [StarUML](http://staruml.io/) 工具。


##### 原型图


花了一些时间来设计我们的程序模型，后面我们也需要设计一下我们的网页原型图。只有这样，才能更好的让我们清楚的知道自己将要干什么？


![线框漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Wireframes.png)



首先，是我们的主页，在主页中，我们会显示我们所有的版块：


> 图5：主页显示所有的版块信息


![线框板](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-boards.png)


同样的，当用户点进了版块信息，进入到版块页面，那么版块页面也将显示该版块下的所有主题：


>图6：版块下的所有主题信息

![线框主题](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-topics.png)


通过观察图片，细心的你，可能会发现，用户在这个页面有两条可以走的路线。第一条就是点击 “new topic” 来创建新的主题，第二条就是点击已经存在的主题进入相关的主题进行讨论回复。



“new topic” 的界面如下 ：


![线框新主题](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-new-topic.png)


而，进入了相关的主题后，应该显示具体的帖子信息和用户的一些回复信息：


![线框帖子](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-posts.png)



如果用户点击 “Reply” 的按钮，他们将看到下面的页面，并以相反的顺序（最新的第一个）对帖子进行显示：

![线框回复](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-reply.png)


那么这些图是用什么来绘制的呢？你可以使用 [draw.io](https://draw.io/) ，而且他是完全免费的。


 * *

#### 模型（Models）


上一部分，设计了我们 Web 应用的数据库还有界面原型设计。在模型（Models）这一部分中，我们将在 Django 中创建我们数据库的模型类：**Board** ，**Topic** 和 **Post** 。


这里是不是有个疑问，明明我们设计数据库的时候是有 **User** 的，为什么我们不用创建它的模型类呢？是不是写漏了？


并不是，那是因为 **User** 这个模型类，已经内置在 Django 应用程序中的，**User** 模型就在 **django.contrib.auth** 中。在 settings.py 中，`INSTALLED_APPS` 就配置了**django.contrib.auth**。


好了，现在我们将根据我们上面设计的数据库模型来完成我们项目 **boards** 下的 models.py 文件中的所有操作。


> **boards/models.py**

```python
from django.db import models
from django.contrib.auth.models import User

class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

class Topic(models.Model):
    subject = models.CharField(max_length=255)
    last_updated = models.DateTimeField(auto_now_add=True)
    board = models.ForeignKey(Board, related_name='topics')
    starter = models.ForeignKey(User, related_name='topics')

class Post(models.Model):
    message = models.TextField(max_length=4000)
    topic = models.ForeignKey(Topic, related_name='posts')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    created_by = models.ForeignKey(User, related_name='posts')
    updated_by = models.ForeignKey(User, null=True, related_name='+')
```

可以看到，创建的所有模型类，**Board** ， **Topic** 和 **Post** 都是 **django.db.models.Model** 的子类，它们都将会转化成数据表。而 **django.db.models.Field** 的子类（Django 内置的核心类）的实例都会转化为数据表中的列。


上面可以看到的 `CharField`，`DateTimeField` 等，都是 **django.db.models.Field** 的子类，在 Django 项目中都可以直接使用它们。


在这里，我们仅仅使用了 `CharField`，`TextField`，`DateTimeField`，和 `ForeignKey` 字段来定义我们的模型（Models） 。当然，在 Django 中，不仅仅只是提供了这些字段，还提供了更多，更广泛的选择来代表不同类型的数据，比如还有：`IntegerField`，`BooleanField`， `DecimalField`。我们会根据不同的需求来使用它们。	
 

有些字段是需要参数的，就好比 `CharField` ，我们都设定了一个 `max_length` , 设置一个最大长度。当我们设定了这个字段后，就会作用于数据的。


在 `Board` 模型（Model）中，在 `name` 字段中，我们也设置了参数 `unique=True`，顾名思义，这是为了在数据库中，保证该字段的唯一性。


在 `Post` 模型中，`created_at` 字段有一个可选参数，`auto_now_add` 设置为 `True`。这是为了指明 Django 在创建 `Post` 对象的时候，`created_at` 使用的是当前的日期和时间。


创建模型与模型之间关系的其中一种方法就是使用 `ForeignKey` 字段，使用这个字段，会自动创建模型与模型之间的联系，而且会在数据库中也创建它们的关系。使用 `ForeignKey` 会有一个参数，来表明他与那个模型之间的联系。 例如：


在 `Topic` 模型中，`models.ForeignKey(Board, related_name='topics')`，第一个参数是代表关联的表格（主表），在默认情况下，外键存储的是主表的主键（Primary Key）。第二个参数 `related_name` 是定义一个名称，用于反向查询的。Django 会自动创建这种反向关系。 虽然 `related_name` 是可选参数，但是如果我们不为它设置一个名称的，Django 会默认生成名称 `(class_name)_set` 。例如，在 `Board` 模型中，`Topic` 实例将在该 `topic_set` 属性下可用。而我们只是将其重新命名为`topics`，使用起来更加自然。


在 `Post` 模型中，`updated_by` 字段设置`related_name='+'`。这指示 Django 我们不需要这种反向关系。


下面这张图可以很好地看到设计图和源码之间的比较，其中绿线就表示了我们是如何处理反向关系的。


![类图模型定义](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-django-models.png)


可能到这一步，你会问：“主键呢？”好像我们都没有定义主键啊。对，如果我们没有为模型（Models）指定主键，那么 Django 会自动生成它。


##### 迁移模型（Migrating the Models）


到这一步，我们要开始告诉 Django 如何创建数据库，这样方便我们更好的使用。


打开**终端** ，激活虚拟环境，进入到 **manage.py** 文件所在的文件夹，然后运行以下命令：


```
python manage.py makemigrations
```

这时，你会看到这样的输出信息：


```
Migrations for 'boards':
  boards/migrations/0001_initial.py
    - Create model Board
    - Create model Post
    - Create model Topic
    - Add field topic to post
    - Add field updated_by to post
```


此时，Django 在 **boards / migrations** 目录内创建了一个名为**0001_initial.py** 的文件。它代表了我们应用程序模型的当前状态。在下一步中，Django 将使用该文件来创建表和列。


迁移文件被翻译成 SQL 语句。如果您熟悉 SQL，则可以运行以下命令来检查将在数据库中执行的 SQL 指令：

```
python manage.py sqlmigrate boards 0001
```


如果你不熟悉 SQL，也不用担心。在本系列教程中，我们不会直接使用 SQL。所有的工作都将使用 Django ORM 来完成，它是一个与数据库进行通信的抽象层。

好了，下一步我们将把我们的迁移文件应用到我们的数据库中：


```
python manage.py migrate</code>
```


输出应该是这样的：

```
Operations to perform:
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
```



因为这是我们第一次迁移数据库，所以该 `migrate` 命令还应用了 Django contrib 应用中现有的迁移文件，这些文件列于 `settings.py` 中的 `INSTALLED_APPS` 。


而 `Applying boards.0001_initial... OK` 就是指我们在上一步中生成的迁移文件。


好了，此时！我们的数据库已经可以使用了。


![SQLite的](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_SQLite.png)


> **注意：** 需要注意的是 **SQLite** 是一个数据库。SQLite 被许多公司用于成千上万的产品，如所有 Android 和 iOS 设备，所有主要的 Web 浏览器，Windows 10，MacOS 等。
>
> 当然，它也不是适合所有的应用场景。SQLite 不能与 MySQL，PostgreSQL 或 Oracle 等数据库进行比较。大容量网站，密集型的应用程序，大数据集，高并发性，这些使用使用 SQLite 可能会导致很多问题。
>
> 在我们开发的项目中，我们将使用 SQLite ，因为它很方便，我们不需要安装其他任何东西。当我们将项目部署到生产环境时，我们将切换到 PostgreSQL 。因为这对于简单的网站是不错的选择。但这里有一点要注意，对于复杂的网站，建议在开发和生产中使用相同的数据库。


##### Models API


使用 Python 开发的一个重要优点是交互式 shell。我几乎一直都在使用它。这是一个可以快速尝试和测试实验的方法。

你可以使用 **manage.py** 加载我们的项目来启动 Python shell ：

启动命令：

```
python manage.py shell
```

可以看到这样的输出：

```
Python 3.6.2 (default, Jul 17 2017, 16:44:45)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>>
```


在我们使用 `python manage.py shell` 之外，我们也可以将项目添加到`sys.path`并加载 Django。这意味着我们可以在项目中导入我们的模型(models) 和任何其他资源。

我们从导入 **Board** 类开始：

```
from boards.models import Board
```

如果我们需要创建 **Board** 对象，我们可以执行以下操作：

```
board = Board(name='Django', description='This is a board about Django.')
```

此时我们只是创建了这个对象，并没有保存到数据库的，因此我们可以调用 `save` 方法，将这个对象保存在数据库中。


```
board.save()
```

该 `save` 方法 ，在创建对象和更新对象中都可以使用，这里 Django 会创建一个新的对象，因为 **Board** 实例是没有 **id** 这个字段的，因此保存后，Django 会自动设置一个 ID ：


```
board.id
1
```


其他的字段你也可以当作属性来访问就好了，比如：

```
board.name
'Django'
```

```
board.description
'This is a board about Django.'
```


要更新一个值，我们可以这样做：


```
board.description = 'Django discussion board.'
board.save()
```


每个 Django 模型 (Models) 都带有一个特殊的属性; 我们称之为 **Model Manager（模型管理器）**。我们可以通过 Python 属性 `objects` 来访问它。它主要用于在数据库中执行查询。例如，我们可以使用它来直接创建一个新的**Board** 对象：

```
board = Board.objects.create(name='Python', description='General discussion about Python.')
```

```
board.id
2
```

```
board.name
'Python'
```

所以，结合之前的操作，我们现在有两个 boards 对象。我们可以使用`objects` 列出数据库中所有现有的 boards ：


```
Board.objects.all()
<QuerySet [<Board: Board object>, <Board: Board object>]>
```


结果是一个 **QuerySet** 。稍后我们会进一步了解它。基本上，它是来自数据库的对象列表。通过输出结果，可以看到我们有两个对象，但我们只能读取 **Board对象** 。这是因为我们没有在 **Board** 模型中定义 `__str__` 方法。


该 `__str__` 方法是一个对象的字符串表示。我们可以使用 Board 的名称来表示它。


首先，退出交互式控制台：


```
exit()
```


现在编辑 **boards** 应用程序中的 **models.py** 文件：


```
class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

    def __str__(self):
        return self.name
```


让我们再次尝试查询。再次打开交互式控制台：


```
from boards.models import Board

Board.objects.all()
<QuerySet [<Board: Django>, <Board: Python>]>
```


仔细对比上面的，看下区别？

可以看到上面那个是 object ，而这里是我们定义的字符串。


我们可以将这个 **QuerySet** 看作一个列表。假设我们想遍历它并打印每个 Board（版块） 的描述：


```
boards_list = Board.objects.all()
for board in boards_list:
    print(board.description)
```


结果是：


```
Django discussion board.
General discussion about Python.
```


当然，我们也可以使用 **Model Manager（模型管理器）** 来查询数据库，如果查询其中的一个，我们可以使用 `get` 的方法：


```
django_board = Board.objects.get(id=1)

django_board.name
'Django'
```

当然我们要小心这种情况，因为很容易发生内存溢出的。比如我们试图去查询一个不存在的对象，就好比我们数据库只有两个 Board 对象，如果你查询 `id=3`，那么它会引发一个异常：


```
board = Board.objects.get(id=3)

boards.models.DoesNotExist: Board matching query does not exist.
```

当然，在 `get` 方法中，参数可以是该模型下的字段，最好是使用唯一的标识字段。否则会返回多个对象，会导致异常的。


```
Board.objects.get(name='Django')
<Board: Django>
```


请注意，查询是区分大小写的，小写 “django” 是不匹配的：


```
Board.objects.get(name='django')
boards.models.DoesNotExist: Board matching query does not exist.
```


##### 模型操作摘要

下面的表格是我们在本章节中学到的方法和操作。代码示例使用 **Board** 模型作为参考示例。大写的 **Board** 代表类，小写的 **board** 是指 **Board** 的实例对象。


| 描述 | 代码示例 |
| --- | --- |
| 创建一个对象并没有保存 | `board = Board()` |
| 保存一个对象（创建或更新） | `board.save()` |
| 在数据库中创建并保存一个对象 | `Board.objects.create(name='...', description='...')` |
| 列出所有对象 | `Board.objects.all()` |
| 获取由字段标识的单个对象 | `Board.objects.get(id=1)` |


在下一节中，我们将开始编写视图并在 HTML 页面中显示我们的版块页面。


 * *

#### Views, Templates 和静态文件


回顾一下，我们之前做的。我们已经可以在应用程序的主页上显示 ”Hello ，World！“ 的界面了。


> **MyProject/urls.py**

```
from django.conf.urls import url
from django.contrib import admin

from boards import views

urlpatterns = [
    url(r'^/code>, views.home, name='home'),
    url(r'^admin/', admin.site.urls),
]
```

> **boards/views.py**

```
from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello, World!')
```

好了，现在我们需要修改这个主页，如果你不记得我们的主页要做成什么样子，可以看看之前我们已经设计好的原型界面图。我们在主页上，要做的是在表格中显示一些版块的名单和其他的一些信息。


首先我们要做的是：导入 **Board** 模型，然后获取所有的存在的版块（boards）信息


> **boards/views.py**


```
from django.http import HttpResponse
from .models import Board

def home(request):
    boards = Board.objects.all()
    boards_names = list()

    for board in boards:
        boards_names.append(board.name)

    response_html = '<br>'.join(boards_names)

    return HttpResponse(response_html)
```



然后我们运行，就会看到这个简单的 HTML 页面：



![主页HttpResponse](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-httpresponse.png)


但是，一般情况下，我们是不会通过这种方式去渲染 HTML ，在 **views.py** 中，我们只需要获取 **boards** 的集合，至于 HTML 渲染那部分的代码，我们应该在 Django 的 templates 目录下完成。


##### Django 模板引擎设置

竟然我们要将 **views.py** 里渲染 HTML 的代码分离，那么我们首先要在 **baords** 的同目录下，创建一个名为 **templates** 的文件夹。


```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/   <-- here!
 |    +-- manage.py
 +-- venv/
```

在我们创建的 **templates** 文件夹中，我们创建一个名为 **home.html** 的 HTML 文件

> **templates/home.html**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
  </head>
  <body>
    <h1>Boards</h1>

    {% for board in boards %}
      {{ board.name }} <br>
    {% endfor %}

  </body>
</html>
```

**home.html** 的文件内容如上面的一样，是一些原始的 HTML 标签代码和 Django 语言上的代码：`{% for ... in ... %}` ，`{{ variable }}`。上面的代码中展示了如何使用 for 循环遍历 list 对象。

到此，我们的 HTML 页面已经完成了，可是我们还没有告诉 Django 在哪里能找到我们应用中的 `templates` 文件夹里的 HTML。


首先，我们在 Django 中绑定一下我们的 `templates` ,打开我们 ** myproject** 项目中的 **settings.py** 文件，搜索 `TEMPLATES` 变量然后在 `DIRS`设置 ：`os.path.join(BASE_DIR, 'templates')`

具体如下：

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates')
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

这样设计就好比相当于在你的项目中的完整路径下，在加上 "/templates"

那是不是跟我们预想的一样呢？我们可以通过 python shell 进行调试：

```
python manage.py shell
```

```
from django.conf import settings

settings.BASE_DIR
'/Users/vitorfs/Development/myproject'

import os

os.path.join(settings.BASE_DIR, 'templates')
'/Users/vitorfs/Development/myproject/templates'
```


可以看到，目录就是指向我们在上面创建的 **templates** 文件夹

此时，我们只是绑定了 **templates** 文件夹的路径，Django 并没有绑定我们 **home.html** ，我们可以在 **views.py** 中绑定：

```
from django.shortcuts import render
from .models import Board

def home(request):
    boards = Board.objects.all()
    return render(request, 'home.html', {'boards': boards})
```



运行后，HTML 的页面是这样的：


![主板渲染](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render.png)

我们可以改进HTML模板来代替使用表格：

> **templates/home.html**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
  </head>
  <body>
    <h1>Boards</h1>

    <table border="1">
      <thead>
        <tr>
          <th>Board</th>
          <th>Posts</th>
          <th>Topics</th>
          <th>Last Post</th>
        </tr>
      </thead>
      <tbody>
        {% for board in boards %}
          <tr>
            <td>
              {{ board.name }}<br>
              <small style="color: #888">{{ board.description }}</small>
            </td>
            <td>0</td>
            <td>0</td>
            <td></td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  </body>
</html>
```


![主板渲染](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render-2.png)


##### 测试主页


![测试漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Testing.png)

测试这部分会在这系列教程中会不断的重复探讨。


现在让我们来写第一个测试，首先在应用程序 **boards** 中找到 **tests.py** 

> **boards/tests.py** 

```
from django.core.urlresolvers import reverse
from django.test import TestCase

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
```

这是一个非常简单的测试用例，但非常的有用。我们在测试的是响应状态码，如果是 200 意味着成功。


我们可以在控制台中检查响应码：

![回应200](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/test-homepage-view-status-code-200.png)


如果出现未捕获的异常，语法错误或其他任何情况，Django 会返回状态代码**500**，这意味着**服务器错误**。现在，想象我们的应用程序有 100 个界面（view）。如果我们为所有视图（view）编写了这个简单的测试，只需一个命令，我们就可以测试所有视图是否返回成功代码，这样用户就不会在任何地方看到任何错误消息。如果没有自动化测试，我们需要逐一检查每个页面。

要执行 Django 的测试套件：

```
python manage.py test
```

```
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.041s

OK
Destroying test database for alias 'default'...
```

现在我们可以测试 Django 是否为请求的 URL 返回了正确的视图函数。这也是一个有用的测试，因为随着开发的进展，您会发现 **urls.py** 模块可能变得非常庞大而复杂。URL 配置全部是关于解析正则表达式的。有些情况下我们有一个非常宽容的URL，所以 Django 最终可能返回错误的视图函数。

以下是我们如何做到的：

> **boards/tests.py**

```
from django.core.urlresolvers import reverse
from django.urls import resolve
from django.test import TestCase
from .views import home

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

    def test_home_url_resolves_home_view(self):
        view = resolve('/')
        self.assertEquals(view.func, home)
```



在第二个测试中，我们正在使用 `resolve` 功能。Django 使用它来将请求的 URL与 **urls.py** 模块中列出的 URL 列表进行匹配。该测试将确保使用 `/`根 URL ，是否返回主视图（home view）。

再次测试：

```
python manage.py test
```

```
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.027s

OK
Destroying test database for alias 'default'...
```


要查看有关测试执行的更多详细信息，请将 **verbosity** 设置为更高级别：

```
python manage.py test --verbosity=2
```

```
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
Operations to perform:
  Synchronize unmigrated apps: messages, staticfiles
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
System check identified no issues (0 silenced).
test_home_url_resolves_home_view (boards.tests.HomeTests) ... ok
test_home_view_status_code (boards.tests.HomeTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.017s

OK
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
```

详细程度决定了将要打印到控制台的通知和调试信息量; 0 是无输出，1 是正常输出，2 是详细输出。

##### 静态文件设置

静态文件是指 CSS，JavaScript，字体，图像或者是我们用来组成用户界面的任何其他资源。

事实上，Django 不提供这些文件。但在开发过程中，我们又会用到，因此 Django 提供了一些功能来帮助我们管理静态文件。这些功能可在配置文件（settings.py）中 `INSTALLED_APPS` 里的 **django.contrib.staticfiles** 。

有了这么多的前端组件库，我们没有理由继续渲染基本的 HTML 。我们可以轻松地将Bootstrap 4 添加到我们的项目中。Bootstrap 是一个用 HTML，CSS 和JavaScript 开发的开源工具包。

在项目根目录中，除**boards**，**templates** 和 **myproject** 文件夹外，我们还需要创建一个名为 **static** 的文件夹，并在 **static** 文件夹内创建另一个名为 **css** 文件夹：

```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/       <-- here
 |    |    +-- css/     <-- and here
 |    +-- manage.py
 +-- venv/
```

到 [getbootstrap.com](https://getbootstrap.com/docs/4.0/getting-started/download/#compiled-css-and-js) 下载最新版本：

![Bootstrap下载](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/bootstrap-download.png)

下载 **Compiled CSS and JS** 的版本。

解压从 Bootstrap 网站下载的 **bootstrap-4.0.0-beta-dist.zip** 文件，将文件 **css / bootstrap.min.css** 复制到我们项目的css文件夹中：

```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/
 |    |    +-- css/
 |    |         +-- bootstrap.min.css    <-- here
 |    +-- manage.py
 +-- venv/
```

还是一样的问题，我们需要将 Django 中的 **settings.py** 里配置一下静态文件的目录。在 `STATIC_URL` 添加以下内容： 

```
STATIC_URL = '/static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
```


这里可以回忆一下，`TEMPLATES` 配置目录的路径，操作是差不多的。


现在我们必须在模板中加载静态文件（Bootstrap CSS文件）：

> **templates/home.html**

```
{% load static %}<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}">
  </head>
  <body>
    <!-- body suppressed for brevity ... -->
  </body>
</html>
```



首先，我们在 html 的开头加载静态文件：`{% load static %}`


`{% static %}` 是用于告诉资源文件存在的路径，在这是，`{% static 'css/bootstrap.min.css' %}` 就会返回 **/static/css/bootstrap.min.css** ，相当于 **http://127.0.0.1:8000/static/css/bootstrap.min.css**


这个 `{% static %}` 标签将会和 **settings.py** 的 `STATIC_URL` 组成最终的 URL。怎么理解这句话呢？

例如，我们在静态文件托管在 **https://static.example.com/** ，然后我们设置了这个属性：`STATIC_URL=https://static.example.com/`，然后 `{% static 'css/bootstrap.min.css' %}` 返回的是 ：**https://static.example.com/css/bootstrap.min.css**。


如果还不能理解，放心，你现在只需要了解和记住相关的过程就行了，后面正式开发上线的时候，会继续开展这部分的内容。


刷新页面 **127.0.0.1:8000** 我们可以看到它是这个样子的：

![Boards主页Bootstrap](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap.png)

现在我们可以编辑模板，以利用Bootstrap CSS：

现在我们可以利用 Bootstrap CSS 来编辑我们的模板页面了：



```
{% load static %}<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}">
  </head>
  <body>
    <div class="container">
      <ol class="breadcrumb my-4">
        <li class="breadcrumb-item active">Boards</li>
      </ol>
      <table class="table">
        <thead class="thead-inverse">
          <tr>
            <th>Board</th>
            <th>Posts</th>
            <th>Topics</th>
            <th>Last Post</th>
          </tr>
        </thead>
        <tbody>
          {% for board in boards %}
            <tr>
              <td>
                {{ board.name }}
                <small class="text-muted d-block">{{ board.description }}</small>
              </td>
              <td class="align-middle">0</td>
              <td class="align-middle">0</td>
              <td></td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </body>
</html>
```



修改后变成这样子：

![Boards主页Bootstrap](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-2.png)


到目前为止，我们使用交互式控制台（`python manage.py shell`）添加新的版块（board）。但是这样很不方便，因此我们需要一个更好的方式来做这个。在下一节中，我们将为网站管理员实施一个管理界面来管理它。

 * *

#### Django Admin简介

当我们开始一个新项目时，Django 在 `INSTALLED_APPS` 中已经配置了 **Django Admin** 。

![Django Admin漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Django_Admin.png)

Django Admin 的一个很好的用例就是，在博客中，它可以被作者用来编写和发布文章。另一个例子是电子商务网站，工作人员可以创建，编辑，删除产品。

目前，我们将配置 Django Admin 来维护我们的应用程序的版块模块。

我们首先创建一个管理员帐户：

```
python manage.py createsuperuser
```

按照说明操作：

```
Username (leave blank to use 'vitorfs'): admin
Email address: admin@example.com
Password:
Password (again):
Superuser created successfully.
```

现在在浏览器中打开 URL：**http://127.0.0.1:8000/admin/**

![Django管理员登录](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-login.png)

输入 **用户名** 和 **密码** ：

![Django Admin](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin.png)


在这里，它已经配置了一些功能，我们也可以添加**用户**和**组**来管理权限。


那么我们如何在这个管理后台中管理版块（Board）里面的内容呢？

其实很简单，在 **board** 目录下，**admin.py** 中添加以下代码：


> **boards/admin.py**

```
from django.contrib import admin
from .models import Board

admin.site.register(Board)
```


保存以下，然后刷新网页：

![Django管理委员会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards.png)

点击 **Boards** 链接就能查看现有版块列表：

![Django管理委员会名单](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list.png)

我们可以通过点击 **Add Board** 按钮添加一个新的版块：

![Django管理委员会添加](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-add.png)

点击 **SAVE** 按钮：

![Django管理委员会名单](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list-2.png)

我们可以检查一切是否正常，打开 **http://127.0.0.1:8000** URL：

![董事会主页](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-3.png)

 * *

#### 结论

在本教程中，我们探讨了许多新概念。我们为我们的项目定义了一些要求，创建了第一个模型，迁移了数据库，开始玩 Models API。我们创建了第一个视图并编写了一些单元测试。我们还配置了 Django 模板引擎，静态文件，并将 Bootstrap 4 库添加到项目中。最后，我们简要介绍了 Django Admin 界面。


该项目的源代码在 GitHub 上,你可以在下面的链接中找到本章节的代码：

[https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw](https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw)

* 模块
**   # 二、模块的使用 #

## 1、import ##

Python 模块的使用跟其他编程语言也是类似的。你要使用某个模块，在使用之前，必须要导入这个模块。导入模块我们使用关键字 `import`。

`import` 的语法基本如下：

```python
import module1[, module2[,... moduleN]
```

比如我们使用标准库模块中的 math 模块。当解释器遇到 `import` 语句，如果模块在当前的搜索路径就会被导入。

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import math

_author_ = '两点水'

print(math.pi)
```

输出的结果：

```txt
3.141592653589793
```

一个模块只会被导入一次，不管你执行了多少次 import。这样可以防止导入模块被一遍又一遍地执行。

当我们使用 import 语句的时候，Python 解释器是怎样找到对应的文件的呢？

这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys 模块中的 path 变量 。

因此，我们可以查一下路径：

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys

print(sys.path)
```

输出结果：


```txt
['C:\\Users\\Administrator\\Desktop\\Python\\Python8Code', 'G:\\PyCharm 2017.1.4\\helpers\\pycharm', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\python36.zip', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\DLLs', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\lib', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages', 'C:\\Users\\Administrator\\Desktop\\Python\\Python8Code\\com\\Learn\\module\\sys']

```

## 2、from···import  ##


有没有想过，怎么直接导入某个模块中的属性和方法呢？

Python 中，导入一个模块的方法我们使用的是 `import` 关键字，这样做是导入了这个模块，这里需要注意了，这样做只是导入了模块，并没有导入模块中具体的某个属性或方法的。而我们想直接导入某个模块中的某一个功能，也就是属性和方法的话，我们可以使用 `from···import` 语句。

语法如下：

```python
from modname import name1[, name2[, ... nameN]]
```

看完简介后可能会想， `from···import`  和 `import` 方法有啥区别呢？

想知道区别是什么，观察下面两个例子：

 `import` 导入 sys 模块，然后使用 version 属性

![from···import和 import的区别1](http://upload-images.jianshu.io/upload_images/2136918-499dd531d4ce3d72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`from···import` 直接导入 version 属性

![from···import和 import的区别2](http://upload-images.jianshu.io/upload_images/2136918-eea99fc170ed5a07?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 3、from ··· import *  ##

通过上面的学习，我们知道了 `from sys import version` 可以直接导入 version 属性。但是如果我们想使用其他的属性呢？比如使用 sys 模块中的 `executable` ，难道又要写多一句 `from sys import executable` ,两个还好，如果三个，四个呢？难道要一直这样写下去？

这时候就需要 `from ··· import *` 语句了，这个语句可以把某个模块中的所有方法属性都导入。比如：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

from sys import *

print(version)
print(executable)

```

输出的结果为：

```txt
3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)]
C:\Users\Administrator\AppData\Local\Programs\Python\Python36\python.exe
```

注意：这提供了一个简单的方法来导入一个模块中的所有方法属性。然而这种声明不该被过多地使用。
** # 三、主模块和非主模块 #

## 1、主模块和非主模块的定义 ##

在 Python 函数中，如果一个函数调用了其他函数完成一项功能，我们称这个函数为主函数，如果一个函数没有调用其他函数，我们称这种函数为非主函数。主模块和非主模块的定义也类似，如果一个模块被直接使用，而没有被别人调用，我们称这个模块为主模块，如果一个模块被别人调用，我们称这个模块为非主模块。

## 2、__name__ 属性 ##

在 Python  中，有主模块和非主模块之分，当然，我们也得区分他们啊。那么怎么区分主模块和非主模块呢？

这就需要用到 `__name__`  属性了，这个 `——name——` 属性值是一个变量，且这个变量是系统给出的。利用这个变量可以判断一个模块是否是主模块。如果一个属性的值是 `__main__` ,那么就说明这个模块是主模块，反之亦然。但是要注意了：** 这个 `__main__` 属性只是帮助我们判断是否是主模块，并不是说这个属性决定他们是否是主模块，决定是否是主模块的条件只是这个模块有没有被人调用**

具体看示例：

首先创建了模块 lname ，然后判断一下是否是主模块，如果是主模块就输出 `main` 不是，就输出 `not main` ，首先直接运行该模块，由于该模块是直接使用，而没有被人调用，所以是主模块，因此输出了 `main` ，具体看下图：

![name属性区分模块1](http://upload-images.jianshu.io/upload_images/2136918-d892d81a71cda9d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


然后又创建一个 user_lname 模块，里面只是简单的导入了 lname 模块，然后执行，输出的结果是 `not main` ，因为 lname 模块被该模块调用了，所以不是主模块，输出结果如图：


![name属性区分模块2](http://upload-images.jianshu.io/upload_images/2136918-9137cb874588dded?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
** # 四、包 #

包，其实在上面的一些例子中，都创建了不同的包名了，具体可以仔细观察。在一开始模块的简介中提到，使用模块可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。但是这里也有个问题，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为包（Package）。

比如最开始的例子，就引入了包，这样子做就算有相同的模块名，也不会造成重复，因为包名不同，其实也就是路径不同。如下图，引入了包名后， lname.py 其实变成了 com.Learn.module.nameattributes.lname

![Python 包](http://upload-images.jianshu.io/upload_images/2136918-7f92a0da0bc609d5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

仔细观察的人，基本会发现，每一个包目录下面都会有一个 `__init__.py` 的文件，为什么呢？

因为这个文件是必须的，否则，Python 就把这个目录当成普通目录，而不是一个包 。 `__init__.py` 可以是空文件，也可以有Python代码，因为 `__init__.py` 本身就是一个模块，而它对应的模块名就是它的包名。
** # 五、作用域 #

学习过 Java 的同学都知道，Java 的类里面可以给方法和属性定义公共的（ public ）或者是私有的 （ private ）,这样做主要是为了我们希望有些函数和属性能给别人使用或者只能内部使用。 通过学习 Python 中的模块，其实和 Java 中的类相似，那么我们怎么实现在一个模块中，有的函数和变量给别人使用，有的函数和变量仅仅在模块内部使用呢？

在 Python 中，是通过 `_` 前缀来实现的。正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，ni12，PI等；类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 `__name__` 就是特殊变量，还有 `__author__` 也是特殊变量，用来标明作者。注意，我们自己的变量一般不要用这种变量名；类似 `_xxx` 和 `__xxx` 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 `_abc` ，`__abc` 等；

注意，这里是说不应该，而不是不能。因为 Python 种并没有一种方法可以完全限制访问 private 函数或变量，但是，从编程习惯上不应该引用 private 函数或变量。

比如：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

def _diamond_vip(lv):
    print('尊敬的钻石会员用户，您好')
    vip_name = 'DiamondVIP' + str(lv)
    return vip_name


def _gold_vip(lv):
    print('尊敬的黄金会员用户，您好')
    vip_name = 'GoldVIP' + str(lv)
    return vip_name


def vip_lv_name(lv):
    if lv == 1:
        print(_gold_vip(lv))
    elif lv == 2:
        print(_diamond_vip(lv))


vip_lv_name(2)

```

输出的结果：

```txt
尊敬的钻石会员用户，您好
DiamondVIP2
```

在这个模块中，我们公开 `vip_lv_name`  方法函数，而其他内部的逻辑分别在 `_diamond_vip` 和 `_gold_vip` private 函数中实现，因为是内部实现逻辑，调用者根本不需要关心这个函数方法，它只需关心调用 `vip_lv_name`  的方法函数，所以用 private 是非常有用的代码封装和抽象的方法

一般情况下，外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为 public。

------------------------

最后扯淡，欢迎加我微信：`androidwed`,进入微信Python讨论群，一起学习讨论。现在微信群只有50几个人.
* 面相对象
** # 二、类 #

## 1、定义类 ##

类定义语法格式如下：

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

一个类也是由属性和方法组成的，有些时候我们定义类的时候需要设置类的属性，因此这就需要构造函

类的构造函数如下：

```python
def __init__(self,[...):
```

类定义了 __init__() 方法的话，类的实例化操作会自动调用 __init__() 方法。

那么如构造函数相对应的是析构函数，理所当然，一个类创建的时候我们可以用过构造函数设置属性，那么当一个类销毁的时候，就会调用析构函数。

析构函数语法如下：

```python
def __del__(self,[...):
```

仔细观察的童鞋都会发现，类的方法与普通的函数有一个特别的区别，它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。

那么这个 self 代表什么呢？

我们可以看下实例，通过实例来找出答案：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
```

观察输出的结果：

![Python self](http://upload-images.jianshu.io/upload_images/2136918-66d29b081ad5510b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从执行结果可以很明显的看出，self 代表的是类的实例，输出的是当前对象的地址，而 `self.__class__` 则指向类。

当然 self 不是 python 关键字，也就是说我们把他换成其他的字符也是可以正常执行的。只不过我们习惯使用 self

## 2、Python 定义类的历史遗留问题 ##

Python  在版本的迭代中，有一个关于类的历史遗留问题，就是新式类和旧式类的问题，具体先看以下的代码：

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# 旧式类
class OldClass:
    pass

# 新式类
class NewClass(object):
    pass

```

可以看到，这里使用了两者中不同的方式定义类，可以看到最大的不同就是，新式类继承了`object` 类，在 Python2 中，我们定义类的时候最好定义新式类，当然在 Python3 中不存在这个问题了，因为 Python3 中所有类都是新式类。

那么新式类和旧式类有什么区别呢？

运行下下面的那段代码：

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# 旧式类
class OldClass:
    def __init__(self, account, name):
        self.account = account;
        self.name = name;


# 新式类
class NewClass(object):
    def __init__(self, account, name):
        self.account = account;
        self.name = name;


if __name__ == '__main__':
    old_class = OldClass(111111, 'OldClass')
    print(old_class)
    print(type(old_class))
    print(dir(old_class))
    print('\n')
    new_class=NewClass(222222,'NewClass')
    print(new_class)
    print(type(new_class))
    print(dir(new_class))

```


仔细观察输出的结果，对比一下，就能观察出来，注意喔，Pyhton3 中输出的结果是一模一样的，因为Python3 中没有新式类旧式类的问题。
** # 三、类的属性 #

## 1、直接在类中定义属性 ##

定义类的属性，当然最简单最直接的就是在类中定义，例如：

```python
class UserInfo(object):
    name='两点水'
```

## 2、在构造函数中定义属性 ##

故名思议，就是在构造对象的时候，对属性进行定义。

```python
class UserInfo(object):
    def __init__(self,name):
        self.name=name
```

## 3、属性的访问控制 ##

在 Java 中，有 public （公共）属性 和 private （私有）属性，这可以对属性进行访问控制。那么在 Python 中有没有属性的访问控制呢？

一般情况下，我们会使用 `__private_attrs` 两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。

为什么只能说一般情况下呢？因为实际上， Python 中是没有提供私有属性等功能的。但是 Python 对属性的访问控制是靠程序员自觉的。为什么这么说呢？看看下面的示例：

![Python 属性访问控制](http://upload-images.jianshu.io/upload_images/2136918-4ac2643aa5b0fa37?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

仔细看图片，为什么说双下划线不是真正的私有属性呢？我们看下下面的例子，用下面的例子来验证：

```python

#!/usr/bin/env python
# -*- coding: UTF-8 -*-

class UserInfo(object):
    def __init__(self, name, age, account):
        self.name = name
        self._age = age
        self.__account = account

    def get_account(self):
        return self.__account


if __name__ == '__main__':
    userInfo = UserInfo('两点水', 23, 347073565);
    # 打印所有属性
    print(dir(userInfo))
    # 打印构造函数中的属性
    print(userInfo.__dict__)
    print(userInfo.get_account())
    # 用于验证双下划线是否是真正的私有属性
    print(userInfo._UserInfo__account)


```

输出的结果如下图：

![Python 属性访问控制](http://upload-images.jianshu.io/upload_images/2136918-de89d4dc5f5f9f77?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
** # 四、类的方法 #

## 1、类专有的方法 ##

一个类创建的时候，就会包含一些方法，主要有以下方法：

类的专有方法：

| 方法 | 说明 |
| ------| ------ |
|`__init__` |构造函数，在生成对象时调用|
|`__del__ `| 析构函数，释放对象时使用|
|`__repr__ `| 打印，转换|
|`__setitem__ `| 按照索引赋值|
|`__getitem__`| 按照索引获取值|
|`__len__`| 获得长度|
|`__cmp__`| 比较运算|
|`__call__`| 函数调用|
|`__add__`| 加运算|
|`__sub__`| 减运算|
|`__mul__`|乘运算|
|`__div__`| 除运算|
|`__mod__`| 求余运算|
|`__pow__`|乘方|

当然有些时候我们需要获取类的相关信息，我们可以使用如下的方法：

 `type(obj)`：来获取对象的相应类型；
 `isinstance(obj, type)`：判断对象是否为指定的 type 类型的实例；
 `hasattr(obj, attr)`：判断对象是否具有指定属性/方法；
 `getattr(obj, attr[, default])` 获取属性/方法的值, 要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出 AttributeError 异常；
 `setattr(obj, attr, value)`：设定该属性/方法的值，类似于 obj.attr=value；
 `dir(obj)`：可以获取相应对象的所有属性和方法名的列表：

## 2、方法的访问控制 ##

其实我们也可以把方法看成是类的属性的，那么方法的访问控制也是跟属性是一样的，也是没有实质上的私有方法。一切都是靠程序员自觉遵守 Python 的编程规范。

示例如下，具体规则也是跟属性一样的，

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

class User(object):
    def upgrade(self):
        pass

    def _buy_equipment(self):
        pass

    def __pk(self):
        pass

```

## 3、方法的装饰器 ##


 **@classmethod**
调用的时候直接使用类名类调用，而不是某个对象

 **@property**
可以像访问属性一样调用方法

具体的使用看下实例：

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

class UserInfo(object):
    lv = 5

    def __init__(self, name, age, account):
        self.name = name
        self._age = age
        self.__account = account

    def get_account(self):
        return self.__account

    @classmethod
    def get_name(cls):
        return cls.lv

    @property
    def get_age(self):
        return self._age


if __name__ == '__main__':
    userInfo = UserInfo('两点水', 23, 347073565);
    # 打印所有属性
    print(dir(userInfo))
    # 打印构造函数中的属性
    print(userInfo.__dict__)
    # 直接使用类名类调用，而不是某个对象
    print(UserInfo.lv)
    # 像访问属性一样调用方法（注意看get_age是没有括号的）
    print(userInfo.get_age)
```

运行的结果：

![Python 方法的装饰器](http://upload-images.jianshu.io/upload_images/2136918-63dc478a8b2f965f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
** # 五、类的继承 #

## 1、定义类的继承 ##

首先我们来看下类的继承的基本语法：

```python
class ClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

在定义类的时候，可以在括号里写继承的类，一开始也提到过，如果不用继承类的时候，也要写继承 object 类，因为在 Python 中 object 类是一切类的父类。

当然上面的是单继承，Python 也是支持多继承的，具体的语法如下：

```python
class ClassName(Base1,Base2,Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

多继承有一点需要注意的：若是父类中有相同的方法名，而在子类使用时未指定，python 在圆括号中父类的顺序，从左至右搜索 ， 即方法在子类中未找到时，从左到右查找父类中是否包含方法。

那么继承的子类可以干什么呢？

继承的子类的好处：
 会继承父类的属性和方法
 可以自己定义，覆盖父类的属性和方法

## 2、调用父类的方法 ##

一个类继承了父类后，可以直接调用父类的方法的，比如下面的例子，`UserInfo2` 继承自父类 `UserInfo` ，可以直接调用父类的  `get_account` 方法。

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

class UserInfo(object):
    lv = 5

    def __init__(self, name, age, account):
        self.name = name
        self._age = age
        self.__account = account

    def get_account(self):
        return self.__account


class UserInfo2(UserInfo):
    pass


if __name__ == '__main__':
    userInfo2 = UserInfo2('两点水', 23, 347073565);
    print(userInfo2.get_account())

```

## 3、父类方法的重写 ##

当然，也可以重写父类的方法。

示例：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class UserInfo(object):
    lv = 5

    def __init__(self, name, age, account):
        self.name = name
        self._age = age
        self.__account = account

    def get_account(self):
        return self.__account

    @classmethod
    def get_name(cls):
        return cls.lv

    @property
    def get_age(self):
        return self._age


class UserInfo2(UserInfo):
    def __init__(self, name, age, account, sex):
        super(UserInfo2, self).__init__(name, age, account)
        self.sex = sex;


if __name__ == '__main__':
    userInfo2 = UserInfo2('两点水', 23, 347073565, '男');
    # 打印所有属性
    print(dir(userInfo2))
    # 打印构造函数中的属性
    print(userInfo2.__dict__)
    print(UserInfo2.get_name())

```

最后打印的结果：

![Python 类的继承](http://upload-images.jianshu.io/upload_images/2136918-aa2701fc5913a8a6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这里就是重写了父类的构造函数。


## 3、子类的类型判断 ##

对于 class 的继承关系来说，有些时候我们需要判断 class 的类型，该怎么办呢？

可以使用 `isinstance()` 函数,

一个例子就能看懂 `isinstance()` 函数的用法了。

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User1(object):
    pass


class User2(User1):
    pass


class User3(User2):
    pass


if __name__ == '__main__':
    user1 = User1()
    user2 = User2()
    user3 = User3()
    # isinstance()就可以告诉我们，一个对象是否是某种类型
    print(isinstance(user3, User2))
    print(isinstance(user3, User1))
    print(isinstance(user3, User3))
    # 基本类型也可以用isinstance()判断
    print(isinstance('两点水', str))
    print(isinstance(347073565, int))
    print(isinstance(347073565, str))

```

输出的结果如下：

```txt
True
True
True
True
True
False
```

可以看到 `isinstance()` 不仅可以告诉我们，一个对象是否是某种类型，也可以用于基本类型的判断。
** # 六、类的多态 #

多态的概念其实不难理解，它是指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。

事实上，我们经常用到多态的性质，比如：

```
>>> 1 + 2
3
>>> 'a' + 'b'
'ab'
```

可以看到，我们对两个整数进行 + 操作，会返回它们的和，对两个字符进行相同的 + 操作，会返回拼接后的字符串。也就是说，不同类型的对象对同一消息会作出不同的响应。


看下面的实例，来了解多态：


```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __init__(self, name):
        self.name = name

    def printUser(self):
        print('Hello !' + self.name)


class UserVip(User):
    def printUser(self):
        print('Hello ! 尊敬的Vip用户：' + self.name)


class UserGeneral(User):
    def printUser(self):
        print('Hello ! 尊敬的用户：' + self.name)


def printUserInfo(user):
    user.printUser()


if __name__ == '__main__':
    userVip = UserVip('两点水')
    printUserInfo(userVip)
    userGeneral = UserGeneral('水水水')
    printUserInfo(userGeneral)

```

输出的结果:

```txt
Hello ! 尊敬的Vip用户：两点水
Hello ! 尊敬的用户：水水水
```

可以看到，userVip 和 userGeneral 是两个不同的对象，对它们调用 printUserInfo 方法，它们会自动调用实际类型的 printUser 方法，作出不同的响应。这就是多态的魅力。

要注意喔，有了继承，才有了多态，也会有不同类的对象对同一消息会作出不同的相应。



最后，本章的所有代码都可以在 [https://github.com/TwoWater/Python](https://github.com/TwoWater/Python) 上面找到，文章的内容和源文件都放在上面。同步更新到 Gitbooks。
* xxxMagic 
** # 一、Python 的 Magic Method #

 在 Python 中，所有以 "__" 双下划线包起来的方法，都统称为"魔术方法"。比如我们接触最多的 `__init__` 。魔术方法有什么作用呢？

 使用这些魔术方法，我们可以构造出优美的代码，将复杂的逻辑封装成简单的方法。

 那么一个类中有哪些魔术方法呢？

 我们可以使用 Python 内置的方法 `dir()` 来列出类中所有的魔术方法.示例如下：

 ```python
 #!/usr/bin/env python3
 # -*- coding: UTF-8 -*-

 class User(object):
     pass


 if __name__ == '__main__':
     print(dir(User()))
 ```

 输出的结果：

 ![Python 类的魔术方法](http://p1ceh5usj.bkt.clouddn.com/Python%20%E7%B1%BB%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95.png)

 可以看到，一个类的魔术方法还是挺多的，截图也没有截全，不过我们只需要了解一些常见和常用的魔术方法就好了。
** # 二、构造(`__new__`)和初始化(`__init__`) #

通过上一篇的内容，我们已经知道定义一个类时，我们经常会通过 `__init__(self)` 的方法在实例化对象的时候，对属性进行设置。比如下面的例子：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __init__(self, name, age):
        self.name = name;
        self.age = age;

user=User('两点水',23)
```

实际上，创建一个类的过程是分为两步的，一步是创建类的对象，还有一步就是对类进行初始化。`__new__` 是用来创建类并返回这个类的实例, 而`__init__` 只是将传入的参数来初始化该实例.`__new__` 在创建一个实例的过程中必定会被调用,但 `__init__` 就不一定，比如通过pickle.load 的方式反序列化一个实例时就不会调用 `__init__` 方法。

![Python类创建的过程](http://upload-images.jianshu.io/upload_images/2136918-a2b39b078cc81841?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`def __new__(cls)` 是在 `def __init__(self)` 方法之前调用的，作用是返回一个实例对象。还有一点需要注意的是：`__new__` 方法总是需要返回该类的一个实例，而 `__init__`  不能返回除了 `None` 的任何值

具体的示例：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __new__(cls, *args, **kwargs):
        # 打印 __new__方法中的相关信息
        print('调用了 def __new__ 方法')
        print(args)
        # 最后返回父类的方法
        return super(User, cls).__new__(cls)

    def __init__(self, name, age):
        print('调用了 def __init__ 方法')
        self.name = name
        self.age = age


if __name__ == '__main__':
    usr = User('两点水', 23)
```

看看输出的结果：

```txt
调用了 def __new__ 方法
('两点水', 23)
调用了 def __init__ 方法
```

通过打印的结果来看，我们就可以知道一个类创建的过程是怎样的了，先是调用了 `__new__` 方法来创建一个对象，把参数传给 `__init__` 方法进行实例化。

其实在实际开发中，很少会用到 `__new__` 方法，除非你希望能够控制类的创建。通常讲到 `__new__` ，都是牵扯到 `metaclass`(元类)的。

当然当一个对象的生命周期结束的时候，析构函数 `__del__` 方法会被调用。但是这个方法是 Python 自己对对象进行垃圾回收的。
** # 三、属性的访问控制 #

之前也有讲到过，Python 没有真正意义上的私有属性。然后这就导致了对 Python 类的封装性比较差。我们有时候会希望 Python 能够定义私有属性，然后提供公共可访问的 get 方法和 set 方法。Python 其实可以通过魔术方法来实现封装。

|方法|说明|
| ---| --- |
|`__getattr__(self, name)`|该方法定义了你试图访问一个不存在的属性时的行为。因此，重载该方法可以实现捕获错误拼写然后进行重定向, 或者对一些废弃的属性进行警告。|
|`__setattr__(self, name, value)`|定义了对属性进行赋值和修改操作时的行为。不管对象的某个属性是否存在,都允许为该属性进行赋值.有一点需要注意，实现 `__setattr__` 时要避免"无限递归"的错误，|
|`__delattr__(self, name)`|`__delattr__` 与 `__setattr__` 很像，只是它定义的是你删除属性时的行为。实现 `__delattr__` 是同时要避免"无限递归"的错误|
|`__getattribute__(self, name)`|`__getattribute__` 定义了你的属性被访问时的行为，相比较，`__getattr__` 只有该属性不存在时才会起作用。因此，在支持 `__getattribute__ `的 Python 版本,调用`__getattr__` 前必定会调用 `__getattribute__``__getattribute__` 同样要避免"无限递归"的错误。|

通过上面的方法表可以知道，在进行属性访问控制定义的时候你可能会很容易的引起一个错误，可以看看下面的示例：

```python
def __setattr__(self, name, value):
    self.name = value
    # 每当属性被赋值的时候， ``__setattr__()`` 会被调用，这样就造成了递归调用。
    # 这意味这会调用 ``self.__setattr__('name', value)`` ，每次方法会调用自己。这样会造成程序崩溃。

def __setattr__(self, name, value):
    # 给类中的属性名分配值
    self.__dict__[name] = value  
    # 定制特有属性
```

上面方法的调用具体示例如下：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __getattr__(self, name):
        print('调用了 __getattr__ 方法')
        return super(User, self).__getattr__(name)

    def __setattr__(self, name, value):
        print('调用了 __setattr__ 方法')
        return super(User, self).__setattr__(name, value)

    def __delattr__(self, name):
        print('调用了 __delattr__ 方法')
        return super(User, self).__delattr__(name)

    def __getattribute__(self, name):
        print('调用了 __getattribute__ 方法')
        return super(User, self).__getattribute__(name)


if __name__ == '__main__':
    user = User()
    # 设置属性值，会调用 __setattr__
    user.attr1 = True
    # 属性存在,只有__getattribute__调用
    user.attr1
    try:
        # 属性不存在, 先调用__getattribute__, 后调用__getattr__
        user.attr2
    except AttributeError:
        pass
    # __delattr__调用
    del user.attr1

```

输出的结果：

```txt
调用了 __setattr__ 方法
调用了 __getattribute__ 方法
调用了 __getattribute__ 方法
调用了 __getattr__ 方法
调用了 __delattr__ 方法
```
** # 四、对象的描述器 #

一般来说，一个描述器是一个有“绑定行为”的对象属性 (object attribute)，它的访问控制被描述器协议方法重写。这些方法是 `__get__()`, `__set__()` , 和 `__delete__()`  。有这些方法的对象叫做描述器。

默认对属性的访问控制是从对象的字典里面 (`__dict__`) 中获取 (get) , 设置 (set) 和删除 (delete) 。举例来说， `a.x` 的查找顺序是, `a.__dict__['x']` , 然后 `type(a).__dict__['x']` , 然后找 `type(a)` 的父类 ( 不包括元类 (metaclass) ).如果查找到的值是一个描述器, Python 就会调用描述器的方法来重写默认的控制行为。这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。注意, 只有在新式类中时描述器才会起作用。在之前的篇节中已经提到新式类和旧式类的，有兴趣可以查看之前的篇节来看看，至于新式类最大的特点就是所有类都继承自 type 或者 object 的类。

在面向对象编程时，如果一个类的属性有相互依赖的关系时，使用描述器来编写代码可以很巧妙的组织逻辑。在 Django 的 ORM 中,models.Model中的 InterField 等字段, 就是通过描述器来实现功能的。

我们先看下下面的例子：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __init__(self, name='两点水', sex='男'):
        self.sex = sex
        self.name = name

    def __get__(self, obj, objtype):
        print('获取 name 值')
        return self.name

    def __set__(self, obj, val):
        print('设置 name 值')
        self.name = val


class MyClass(object):
    x = User('两点水', '男')
    y = 5


if __name__ == '__main__':
    m = MyClass()
    print(m.x)

    print('\n')

    m.x = '三点水'
    print(m.x)

    print('\n')

    print(m.x)

    print('\n')

    print(m.y)

```

输出的结果如下：

```txt
获取 name 值
两点水


设置 name 值
获取 name 值
三点水


获取 name 值
三点水


5

```

通过这个例子，可以很好的观察到这 `__get__()` 和  `__set__()` 这些方法的调用。

再看一个经典的例子

我们知道，距离既可以用单位"米"表示,也可以用单位"英尺"表示。
现在我们定义一个类来表示距离,它有两个属性: 米和英尺。

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-


class Meter(object):
    def __init__(self, value=0.0):
        self.value = float(value)

    def __get__(self, instance, owner):
        return self.value

    def __set__(self, instance, value):
        self.value = float(value)


class Foot(object):
    def __get__(self, instance, owner):
        return instance.meter * 3.2808

    def __set__(self, instance, value):
        instance.meter = float(value) / 3.2808


class Distance(object):
    meter = Meter()
    foot = Foot()


if __name__ == '__main__':
    d = Distance()
    print(d.meter, d.foot)
    d.meter = 1
    print(d.meter, d.foot)
    d.meter = 2
    print(d.meter, d.foot)

```
 
输出的结果：

```txt
0.0 0.0
1.0 3.2808
2.0 6.5616
```

在上面例子中,在还没有对 Distance 的实例赋值前, 我们认为 meter 和 foot 应该是各自类的实例对象, 但是输出却是数值。这是因为 `__get__` 发挥了作用.

我们只是修改了 meter ,并且将其赋值成为 int ，但 foot 也修改了。这是 `__set__` 发挥了作用.

描述器对象 (Meter、Foot) 不能独立存在, 它需要被另一个所有者类 (Distance) 所持有。描述器对象可以访问到其拥有者实例的属性，比如例子中 Foot 的 `instance.meter` 。
** # 五、自定义容器（Container） #

经过之前编章的介绍，我们知道在 Python 中，常见的容器类型有: dict, tuple, list, string。其中也提到过可容器和不可变容器的概念。其中 tuple, string 是不可变容器，dict, list 是可变容器。	可变容器和不可变容器的区别在于，不可变容器一旦赋值后，不可对其中的某个元素进行修改。当然具体的介绍，可以看回之前的文章，有图文介绍。

那么这里先提出一个问题，这些数据结构就够我们开发使用吗？不够的时候，或者说有些特殊的需求不能单单只使用这些基本的容器解决的时候，该怎么办呢？

这个时候就需要自定义容器了，那么具体我们该怎么做呢？

|功能|说明|
|------|------|
|自定义不可变容器类型|需要定义 `__len__` 和 `__getitem__` 方法|
|自定义可变类型容器|在不可变容器类型的基础上增加定义 `__setitem__` 和 `__delitem__` |
|自定义的数据类型需要迭代|需定义 `__iter__` |
|返回自定义容器的长度|需实现 `__len__(self)` |
|自定义容器可以调用 `self[key]` ，如果 key 类型错误，抛出TypeError ，如果没法返回key对应的数值时,该方法应该抛出ValueError|需要实现 `__getitem__(self, key)`|
|当执行 	`self[key] = value` 时|调用是 `__setitem__(self, key, value)`这个方法|
|当执行 `del self[key]` 方法 |其实调用的方法是 `__delitem__(self, key)`|
|当你想你的容器可以执行 `for x in container:` 或者使用 `iter(container)` 时|需要实现 `__iter__(self)` ，该方法返回的是一个迭代器|

来看一下使用上面魔术方法实现 Haskell 语言中的一个数据结构：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class FunctionalList:
    ''' 实现了内置类型list的功能,并丰富了一些其他方法: head, tail, init, last, drop, take'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return FunctionalList(reversed(self.values))

    def append(self, value):
        self.values.append(value)

    def head(self):
        # 获取第一个元素
        return self.values[0]

    def tail(self):
        # 获取第一个元素之后的所有元素
        return self.values[1:]

    def init(self):
        # 获取最后一个元素之前的所有元素
        return self.values[:-1]

    def last(self):
        # 获取最后一个元素
        return self.values[-1]

    def drop(self, n):
        # 获取所有元素，除了前N个
        return self.values[n:]

    def take(self, n):
        # 获取前N个元素
        return self.values[:n]

```
** # 六、运算符相关的魔术方法 #


运算符相关的魔术方法实在太多了,j就大概列举下面两类：


## 1、比较运算符 ##

|魔术方法|说明|
|-----|-----|
|`__cmp__(self, other)`|如果该方法返回负数，说明 `self < other`;  返回正数，说明 `self > other`; 返回 0 说明 `self == other `。强烈不推荐来定义 `__cmp__` , 取而代之, 最好分别定义 `__lt__`, `__eq__` 等方法从而实现比较功能。 `__cmp__` 在 Python3 中被废弃了。|
|`__eq__(self, other)`|定义了比较操作符 == 的行为|
|`__ne__(self, other)`|定义了比较操作符 != 的行为|
|`__lt__(self, other)`|定义了比较操作符 < 的行为|
|`__gt__(self, other)`|定义了比较操作符 > 的行为|
|`__le__(self, other)`|定义了比较操作符 <= 的行为|
|`__ge__(self, other)`|定义了比较操作符 >= 的行为|


来看个简单的例子就能理解了：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class Number(object):
    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        print('__eq__')
        return self.value == other.value

    def __ne__(self, other):
        print('__ne__')
        return self.value != other.value

    def __lt__(self, other):
        print('__lt__')
        return self.value < other.value

    def __gt__(self, other):
        print('__gt__')
        return self.value > other.value

    def __le__(self, other):
        print('__le__')
        return self.value <= other.value

    def __ge__(self, other):
        print('__ge__')
        return self.value >= other.value


if __name__ == '__main__':
    num1 = Number(2)
    num2 = Number(3)
    print('num1 == num2 ? --------> {} \n'.format(num1 == num2))
    print('num1 != num2 ? --------> {} \n'.format(num1 == num2))
    print('num1 < num2 ? --------> {} \n'.format(num1 < num2))
    print('num1 > num2 ? --------> {} \n'.format(num1 > num2))
    print('num1 <= num2 ? --------> {} \n'.format(num1 <= num2))
    print('num1 >= num2 ? --------> {} \n'.format(num1 >= num2))

```

输出的结果为：

```txt
__eq__
num1 == num2 ? --------> False

__eq__
num1 != num2 ? --------> False

__lt__
num1 < num2 ? --------> True

__gt__
num1 > num2 ? --------> False

__le__
num1 <= num2 ? --------> True

__ge__
num1 >= num2 ? --------> False

```

## 2、算术运算符 ##

|魔术方法|说明|
|-----|-----|
|`__add__(self, other)`|实现了加号运算|
|`__sub__(self, other)`|实现了减号运算|
|`__mul__(self, other)`|实现了乘法运算|
|`__floordiv__(self, other)`|实现了 // 运算符|
|`___div__(self, other)`|实现了/运算符. 该方法在 Python3 中废弃. 原因是 Python3 中，division 默认就是 true division|
|`__truediv__(self, other)`|实现了 true division. 只有你声明了 `from __future__ import division` 该方法才会生效|
|`__mod__(self, other)`|实现了 % 运算符, 取余运算|
|`__divmod__(self, other)`|实现了 divmod() 內建函数|
|`__pow__(self, other)`|实现了 `**` 操作. N 次方操作|
|`__lshift__(self, other)`|实现了位操作 `<<`|
|`__rshift__(self, other)`|实现了位操作 `>>`|
|`__and__(self, other)`|实现了位操作 `&`|
|`__or__(self, other)`|实现了位操作 `|`|
|`__xor__(self, other)`|实现了位操作 `^`|


最后，如果对本文感兴趣的，可以关注下公众号：

![公众号](http://twowater.com.cn/images/20171204192251900.gif)
* enum
** # 一、枚举类的使用 #

实际开发中，我们离不开定义常量，当我们需要定义常量时，其中一个办法是用大写变量通过整数来定义，例如月份：

```python
JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12
```

当然这样做简单快捷，缺点是类型是 `int` ，并且仍然是变量。

那有没有什么好的方法呢？

这时候我们定义一个 class 类型，每个常量都是 class 里面唯一的实例。正好 Python 提供了 Enum 类来实现这个功能如下：

```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

# 遍历枚举类型
for name, member in Month.__members__.items():
    print(name, '---------', member, '----------', member.value)

# 直接引用一个常量
print('\n', Month.Jan)

```

输出的结果如下：


![Python3 枚举类型的使用](http://p1ceh5usj.bkt.clouddn.com/Python3%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8.png)

可见，我们可以直接使用 `Enum` 来定义一个枚举类。上面的代码，我们创建了一个有关月份的枚举类型 Month ，这里要注意的是构造参数，第一个参数 Month 表示的是该枚举类的类名，第二个 tuple 参数，表示的是枚举类的值；当然，枚举类通过 `__members__` 遍历它的所有成员的方法。注意的一点是 ， `member.value` 是自动赋给成员的 `int`类型的常量，默认是从 1 开始的。而且 Enum 的成员均为单例（Singleton），并且不可实例化，不可更改
**    # 二、Enum 的源码 #

通过上面的实例可以知道通过 `__members__`  可以遍历枚举类的所有成员。那为什么呢？

我们可以先来大致看看 Enum 的源码是如何实现的；Enum 在模块 enum.py 中，先来看看 Enum 类的片段

```python
class Enum(metaclass=EnumMeta):
    """Generic enumeration.
    Derive from this class to define new enumerations.
    """
```

可以看到，Enum 是继承元类 EnumMeta 的；再看看 EnumMeta 的相关片段

```python
class EnumMeta(type):
    """Metaclass for Enum"""
    @property
    def __members__(cls):
        """Returns a mapping of member name->value.
        This mapping lists all enum members, including aliases. Note that this
        is a read-only view of the internal mapping.
        """
        return MappingProxyType(cls._member_map_)
```

首先 `__members__` 方法返回的是一个包含一个 Dict 既 Map 的 MappingProxyType，并且通过 @property 将方法 `__members__(cls)` 的访问方式改变为了变量的的形式，既可以直接通过 `__members__` 来进行访问了

