* 语言工具
** 编译器 python 
*** 功能选项
    -d      提供调试输出
    -O      生成优化的字节码(生成 .pyo 文件)
    -S      不导入 site 模块以在启动时查找 Python 路径
    -v      冗余输出(导入语句详细追踪)
    -m mod  将一个模块以脚本形式运行
    -c cmd  运行以命令行字符串形式提交的 Python 脚本
    file    从给定的文件运行 Python 脚本(参阅后文)
*** 环境变量
    PYTHONPATH	PYTHONPATH 是 Python 搜索路径，默认我们 import 的模块都会从 PYTHONPATH 里面寻找。
    PYTHONSTARTUP 	Python 启动后，先寻找 PYTHONSTARTUP 环境变量，然后执行此文件中变量指定的执行代码。
    PYTHONCASEOK 	加入 PYTHONCASEOK 的环境变量, 就会使 python 导入模块的时候不区分大小写.
    PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的 PYTHONSTARTUP 或 PYTHONPATH 目录中，使得两个模块库更容易切换。
*** 国际化
    # -*- coding: UTF-8 -*- 
    # coding=utf-8
** 项目管理
** 包管理工具 
*** pip 
    安装 pip install requests
    查找 pip search xml
    明细 pip show beautifulsoup4
    卸载 pip uninstall requests
    国内源 pip install -i https://pypi.douban.com/simple virtualenv

** python 虚拟环境 virtualenv
*** 创建虚拟环境
    创建env环境目录   virtualenv env
    创建目录，并选用python3 的解释器 virtualenv -p /usr/local/bin/python3 venv
*** 启动虚拟环境 source ./bin/activate
    Virtualenv 附带有 pip 安装工具，因此需要安装的 packages 可以直接运行：
*** 退出虚拟环境 deactivate
*** 删除虚拟环境 rm -rf 
*** 虚拟环境管理工具 Virtualenvwrapper 
**** 创建虚拟机 mkvirtualenv env
**** 列出虚拟环境列表 workon 或者 lsvirtualenv
**** 启动/切换虚拟环境 workon [virtual-name]
**** 删除虚拟环境 rmvirtualenv  [virtual-name]
**** 离开虚拟环境 deactivate
* python
** 对象
*** 基本对象
    数量
    字符串 未加工字符串 r'{}<?>'
   字符串编码
    # -*- coding: utf-8 -*-
    范围[1:3]
    list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
    元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )
    字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
    空值 None
    集合 无序不重复元素集set([1,3,4])
    bool  True False  连接词 and or not 
*** 对象操作
    | 将x转换为一个整数                                     | int(x [,base ])        |
    | 将x转换到一个浮点数                                   | float(x )              |
    | 创建一个复数                                          | complex(real [,imag ]) |
    | 将对象 x 转换为字符串                                 | str(x )                |
    | 将对象 x 转换为表达式字符串                           | repr(x )               |
    | 用来计算在字符串中的有效 Python 表达式,并返回一个对象 | eval(str )             |
    | 将序列 s 转换为一个元组                               | tuple(s )              |
    | 将序列 s 转换为一个列表                               | list(s )               |
    | 将一个整数转换为一个字符                              | chr(x )                |
    | 将一个整数转换为 Unicode 字符                         | unichr(x )             |
    | 将一个字符转换为它的整数值                            | ord(x )                |
    | 将一个整数转换为一个十六进制字符串                    | hex(x )                |
    | 将一个整数转换为一个八进制字符串                      | oct(x )                |
*** 函数 
**** 定义函数
     #+BEGIN_SRC python
       def functionname( parameters ):
           "函数_文档字符串"
           function_suite
           return [expression]
     #+END_SRC
**** 返回多个值
     return b , a
     其实是一个元组
**** 不定长参数
     #+begin_src python
       # -*- coding: UTF-8 -*-
       def print_user_info( name ,  age  , sex = '男' , * hobby):
           # 打印用户信息
           print('昵称：{}'.format(name) , end = ' ')
           print('年龄：{}'.format(age) , end = ' ')
           print('性别：{}'.format(sex) ,end = ' ' )
           print('爱好：{}'.format(hobby))
           return;

       # 调用 print_user_info 函数
       print_user_info( '两点水' ,18 , '女', '打篮球','打羽毛球','跑步')
     #+end_src

**** 只接受关键字参数 
     #+begin_src python
       # -*- coding: UTF-8 -*-

       def print_user_info( name , *, age  , sex = '男' ):
           # 打印用户信息
           print('昵称：{}'.format(name) , end = ' ')
           print('年龄：{}'.format(age) , end = ' ')
           print('性别：{}'.format(sex))
           return;

       # 调用 print_user_info 函数
       print_user_info( name = '两点水' ,age = 18 , sex = '女' )

       # 这种写法会报错，因为 age ，sex 这两个参数强制使用关键字参数
       #print_user_info( '两点水' , 18 , '女' )
       print_user_info('两点水',age='22',sex='男')
     #+end_src

**** 匿名函数 lambda 
     #+begin_src python
       lambda [arg1 [,arg2,.....argn]]:expression
     #+end_src
     
     #+begin_src python
       # -*- coding: UTF-8 -*-

       sum = lambda num1 , num2 : num1 + num2;
       print( sum( 1 , 2 ) )
     #+end_src

*** 迭代器
    迭代器有两个基本的方法：iter() 和 next(),且字符串，列表或元组对象都可用于创建迭代器，迭代器对象可以使用常规 for 语句进行遍历，也可以使用 next() 函数来遍历。
    #+BEGIN_SRC python
      # 1、字符创创建迭代器对象
      str1 = 'liangdianshui'
      iter1 = iter ( str1 )

      # 2、list对象创建迭代器
      list1 = [1,2,3,4]
      iter2 = iter ( list1 )

      # 3、tuple(元祖) 对象创建迭代器
      tuple1 = ( 1,2,3,4 )
      iter3 = iter ( tuple1 )

      # for 循环遍历迭代器对象
      for x in iter1 :
          print ( x , end = ' ' )

      print('\n------------------------')

      # next() 函数遍历迭代器
      while True :
          try :
              print ( next ( iter3 ) )
          except StopIteration :
              break

    #+END_SRC
**** ## 2、list 生成式的创建 ##

     首先，lsit 生成式的语法为：

     ```python
     [expr for iter_var in iterable] 
     [expr for iter_var in iterable if cond_expr]
     ```

     第一种语法：首先迭代 iterable 里所有内容，每一次迭代，都把 iterable 里相应内容放到iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计算值生成一个列表。

     第二种语法：加入了判断语句，只有满足条件的内容才把 iterable 里相应内容放到 iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计算值生成一个列表。

     其实不难理解的，因为是 list 生成式，因此肯定是用 [] 括起来的，然后里面的语句是把要生成的元素放在前面，后面加 for 循环语句或者 for 循环语句和判断语句。

     例子：

     ```python
     # -*- coding: UTF-8 -*-
     lsit1=[x * x for x in range(1, 11)]
     print(lsit1)
     ```

     输出的结果：

     ```txt
     [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
     ```

     可以看到，就是把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来。那么 for 循环后面有 if 的形式呢？又该如何理解：

     ```python
     # -*- coding: UTF-8 -*-
     lsit1= [x * x for x in range(1, 11) if x % 2 == 0]
     print(lsit1)
     ```

     输出的结果：

     ```txt
     [4, 16, 36, 64, 100]
     ```

     这个例子是为了求 1 到 10 中偶数的平方根，上面也说到， `x * x` 是要生成的元素，后面那部分其实就是在 for 循环中嵌套了一个 if 判断语句。

     那么有了这个知识点，我们也可以猜想出，for 循环里面也嵌套 for 循环。具体示例：

     ```python
     # -*- coding: UTF-8 -*-
     lsit1= [(x+1,y+1) for x in range(3) for y in range(5)] 
     print(lsit1)
     ```

     输出的结果：

     ```txt
     [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)]
     ```

     其实知道了 list 生成式是怎样组合的，就不难理解这个东西了。因为 list 生成式只是把之前学习的知识点进行了组合，换成了一种更简洁的写法而已。
**** # 四、生成器 #

     ## 1、为什么需要生成器 ##

     通过上面的学习，可以知道列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 1000 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

     所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器：generator。

     在 Python 中，使用了 yield 的函数被称为生成器（generator）。

     跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

     在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。

     那么如何创建一个生成器呢？


     ## 2、生成器的创建 ##

     最简单最简单的方法就是把一个列表生成式的 `[]` 改成 `()`

     ```python
     # -*- coding: UTF-8 -*-
     gen= (x * x for x in range(10))
     print(gen)
     ```

     输出的结果：

     ```txt
     <generator object <genexpr> at 0x0000000002734A40>
     ```

     创建 List 和 generator 的区别仅在于最外层的 `[]` 和 `()` 。但是生成器并不真正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生” ( yield ) 出来。 生成器表达式使用了“惰性计算” ( lazy evaluation，也有翻译为“延迟求值”，我以为这种按需调用 call by need 的方式翻译为惰性更好一些)，只有在检索时才被赋值（ evaluated ），所以在列表比较长的情况下使用内存上更有效。


     那么竟然知道了如何创建一个生成器，那么怎么查看里面的元素呢？

     ## 3、遍历生成器的元素 ##

     按我们的思维，遍历用 for 循环，对了，我们可以试试：

     ```python
     # -*- coding: UTF-8 -*-
     gen= (x * x for x in range(10))

     for num  in  gen :
	   print(num)
     ```

     没错，直接这样就可以遍历出来了。当然，上面也提到了迭代器，那么用 next() 可以遍历吗？当然也是可以的。


     ## 4、以函数的形式实现生成器 ##

     上面也提到，创建生成器最简单最简单的方法就是把一个列表生成式的 `[]` 改成 `()`。为啥突然来个以函数的形式来创建呢？

     其实生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。而且实际运用中，大多数的生成器都是通过函数来实现的。那么我们该如何通过函数来创建呢？

     先不急，来看下这个例子：

     ```python
     # -*- coding: UTF-8 -*-
     def my_function():
     for i in range(10):
     print ( i )

     my_function()
     ```

     输出的结果：

     ```txt
     0
     1
     2
     3
     4
     5
     6
     7
     8
     9
     ```

     如果我们需要把它变成生成器，我们只需要把 `print ( i )` 改为 `yield i` 就可以了，具体看下修改后的例子：

     ```python
     # -*- coding: UTF-8 -*-
     def my_function():
     for i in range(10):
     yield i

     print(my_function())
     ```

     输出的结果：

     ```txt
     <generator object my_function at 0x0000000002534A40>
     ```

     但是，这个例子非常不适合使用生成器，发挥不出生成器的特点，生成器的最好的应用应该是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。因为这样会耗很大的资源。

     比如下面是一个计算斐波那契数列的生成器：

     ```python
     # -*- coding: UTF-8 -*-
     def fibon(n):
     a = b = 1
     for i in range(n):
     yield a
     a, b = b, a + b

     # 引用函数
     for x in fibon(1000000):
     print(x , end = ' ')
     ```

     运行的效果：

     ![计算斐波那契数列的生成器](http://upload-images.jianshu.io/upload_images/2136918-304e50af22b787ce?imageMogr2/auto-orient/strip)

     你看，运行一个这么打的参数，也不会说有卡死的状态，因为这种方式不会使用太大的资源。这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，遇到 return 语句或者最后一行函数语句就返回。而变成 generator 的函数，在每次调用 next() 的时候执行，遇到 yield语句返回，再次执行时从上次返回的 yield 语句处继续执行。

     比如这个例子：

     ```python
     # -*- coding: UTF-8 -*-
     def odd():
     print ( 'step 1' )
     yield ( 1 )
     print ( 'step 2' )
     yield ( 3 )
     print ( 'step 3' )
     yield ( 5 )

     o = odd()
     print( next( o ) )
     print( next( o ) )
     print( next( o ) )
     ```

     输出的结果：

     ```txt
     step 1
     1
     step 2
     3
     step 3
     5
     ```

     可以看到，odd 不是普通函数，而是 generator，在执行过程中，遇到 yield 就中断，下次又继续执行。执行 3 次 yield 后，已经没有 yield 可以执行了，如果你继续打印 `print( next( o ) ) ` ,就会报错的。所以通常在 generator 函数中都要对错误进行捕获。

     ## 5、打印杨辉三角 ##

     通过学习了生成器，我们可以直接利用生成器的知识点来打印杨辉三角：

     ```python
     # -*- coding: UTF-8 -*-
     def triangles( n ):         # 杨辉三角形
     L = [1]
     while True:
     yield L
     L.append(0)
     L = [ L [ i -1 ] + L [ i ] for i in range (len(L))]

     n= 0
     for t in triangles( 10 ):   # 直接修改函数名即可运行
     print(t)
     n = n + 1
     if n == 10:
     break
     ```

     输出的结果为：

     ```txt
     [1]
     [1, 1]
     [1, 2, 1]
     [1, 3, 3, 1]
     [1, 4, 6, 4, 1]
     [1, 5, 10, 10, 5, 1]
     [1, 6, 15, 20, 15, 6, 1]
     [1, 7, 21, 35, 35, 21, 7, 1]
     [1, 8, 28, 56, 70, 56, 28, 8, 1]
     [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
     ```
**** # 五、迭代器和生成器综合例子 #

     因为迭代器和生成器基本是互通的，因此有些知识点需要综合在一起

     ## 1、反向迭代 ##

     反向迭代，应该也是常有的需求了，比如从一开始迭代的例子里，有个输出 list 的元素，从 1 到 5 的

     ```python
     list1 = [1,2,3,4,5]
     for num1 in list1 :
     print ( num1 , end = ' ' )
     ```

     那么我们从 5 到 1 呢？这也很简单， Python 中有内置的函数 `reversed()`

     ```python
     list1 = [1,2,3,4,5]
     for num1 in reversed(list1) :
     print ( num1 , end = ' ' )
     ```

     方向迭代很简单，可是要注意一点就是：**反向迭代仅仅当对象的大小可预先确定或者对象实现了 `__reversed__()` 的特殊方法时才能生效。 如果两者都不符合，那你必须先将对象转换为一个列表才行**

     其实很多时候我们可以通过在自定义类上实现 `__reversed__()` 方法来实现反向迭代。不过有些知识点在之前的篇节中还没有提到，不过可以相应的看下，有编程基础的，学完上面的知识点应该也能理解的。

     ```python
     # -*- coding: UTF-8 -*-

     class Countdown:
     def __init__(self, start):
     self.start = start

     def __iter__(self):
     # Forward iterator
     n = self.start
     while n > 0:
     yield n
     n -= 1

     def __reversed__(self):
     # Reverse iterator
     n = 1
     while n <= self.start:
     yield n
     n += 1

     for rr in reversed(Countdown(30)):
     print(rr)
     for rr in Countdown(30):
     print(rr)
     ```

     输出的结果是 1 到 30 然后 30 到 1 ，分别是顺序打印和倒序打印

     ## 2、同时迭代多个序列 ##

     你想同时迭代多个序列，每次分别从一个序列中取一个元素。你遇到过这样的需求吗？

     为了同时迭代多个序列，使用 zip() 函数，具体示例：

     ```python
     # -*- coding: UTF-8 -*-

     names = ['laingdianshui', 'twowater', '两点水']
     ages = [18, 19, 20]
     for name, age in zip(names, ages):
     print(name,age)
     ```

     输出的结果：

     ```txt
     laingdianshui 18
     twowater 19
     两点水 20
     ```

     其实 zip(a, b) 会生成一个可返回元组 (x, y) 的迭代器，其中 x 来自 a，y 来自 b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。注意理解这句话喔，也就是说如果 a ， b 的长度不一致的话，以最短的为标准，遍历完后就结束。

     利用 `zip()` 函数，我们还可把一个 key 列表和一个 value 列表生成一个 dict （字典）,如下：

     ```python
     # -*- coding: UTF-8 -*-

     names = ['laingdianshui', 'twowater', '两点水']
     ages = [18, 19, 20]

     dict1= dict(zip(names,ages))

     print(dict1)

     ```


     输出如下结果：

     ```python
     {'laingdianshui': 18, 'twowater': 19, '两点水': 20}
     ```

     这里提一下， `zip()` 是可以接受多于两个的序列的参数，不仅仅是两个。

*** 数学对象简化操作运算符
**** 算术运算符
     **	幂 - 返回 x 的 y 次幂	a**b 为 10 的 20 次方， 输出结果 100000000000000000000
     //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
*** 模块(对象包)
    !模块名(文件名) 与 类名 相同 
**** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
     import module1[, module2[,... moduleN]
**** From…import 语句
     : Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中
**** globals()和 locals()函数
     : 根据调用地方的不同，globals()和 locals()函数可被用来返回全局和局部命名空间里的名字。
**** reload()函数
     : 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
     : 因此，如果你想重新执行模块里顶层部分的代码，可以用 reload()函数
**** 完成模块
***** 定义用于模块的错误和异常
      #+BEGIN_SRC python
        class sendException(Exception):
              pass
      #+END_SRC
***** 定义模块中要输出的项 
      from module import classname/functionname
      __all__ 中确定的 或是 除去_ 开头的 是公有的
***** 编写文档
      '''items'''
***** 测试, 写好注释, 执行方法
***** 提供调用的回退函数
***** 安装模块     
      通常在 sys.path 的 site-packages 目录下
*** 包 一个包几个类
    使用操作系统原有的目录结构、包是一个目录、如 Hello, 然后在里面创建__init__.py 文件，该文件提示该目录是包目录
    在目录下创建类，类名同文件名要相同，默认只执行 __init__.py 文件，需要在里面 用 from 文件 import 同文件名同的类名
    就可以在调用的源码中 import 包名 了
   
    实例化 时 是 包名+类名
*** 测试模块和包
    if __name== '__main__'
    __name__是 模块或包名的变量, __main__ 用来测试模块中的方法 
*** 类
**** class
     类中方法定义 必须带 self
     #+BEGIN_SRC python
       class wa:
        def __init__(self, items={}):
         '''items'''
            if type(item)!=type({}):
                raise TypeError("类型错误")
               self.items=items
            return
           def	deposit(self,	amount):
            self.balance	=	self.balance	+	amount
            return	self.balance
           def	withdraw(self,	amount):
            if	amount	>	self.balance:
             return	'Insufficient	funds'
     #+END_SRC
**** 初始化函数 
     __init
**** 类的实例 ，没有 new 关键词
     a = Acc('xx')
**** 类的继承
     #+BEGIN_SRC python
       class Subclass(Parentclass):
              def __init__(self):
                     Parentclass.__init__

     #+END_SRC
**** 类属性与方法
***** 类的私有属性
      __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
      类的方法
      在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数
***** 类的私有方法
      __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
**** type 函数
**** 类的多态

多态的概念其实不难理解，它是指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。

事实上，我们经常用到多态的性质，比如：

```
>>> 1 + 2
3
>>> 'a' + 'b'
'ab'
```

可以看到，我们对两个整数进行 + 操作，会返回它们的和，对两个字符进行相同的 + 操作，会返回拼接后的字符串。也就是说，不同类型的对象对同一消息会作出不同的响应。


看下面的实例，来了解多态：


```python
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

class User(object):
    def __init__(self, name):
        self.name = name

    def printUser(self):
        print('Hello !' + self.name)


class UserVip(User):
    def printUser(self):
        print('Hello ! 尊敬的Vip用户：' + self.name)


class UserGeneral(User):
    def printUser(self):
        print('Hello ! 尊敬的用户：' + self.name)


def printUserInfo(user):
    user.printUser()


if __name__ == '__main__':
    userVip = UserVip('两点水')
    printUserInfo(userVip)
    userGeneral = UserGeneral('水水水')
    printUserInfo(userGeneral)

```

输出的结果:

```txt
Hello ! 尊敬的Vip用户：两点水
Hello ! 尊敬的用户：水水水
```

可以看到，userVip 和 userGeneral 是两个不同的对象，对它们调用 printUserInfo 方法，它们会自动调用实际类型的 printUser 方法，作出不同的响应。这就是多态的魅力。

要注意喔，有了继承，才有了多态，也会有不同类的对象对同一消息会作出不同的相应。

** 数据类型转换 
   | 方法                   | 说明                                                  |
   |------------------------+-------------------------------------------------------|
   | int(x [,base ])        | 将x转换为一个整数                                     |
   | float(x )              | 将x转换到一个浮点数                                   |
   | complex(real [,imag ]) | 创建一个复数                                          |
   | str(x )                | 将对象 x 转换为字符串                                 |
   | repr(x )               | 将对象 x 转换为表达式字符串                           |
   | eval(str )             | 用来计算在字符串中的有效 Python 表达式,并返回一个对象 |
   | tuple(s )              | 将序列 s 转换为一个元组                               |
   | list(s )               | 将序列 s 转换为一个列表                               |
   | chr(x )                | 将一个整数转换为一个字符                              |
   | unichr(x )             | 将一个整数转换为 Unicode 字符                         |
   | ord(x )                | 将一个字符转换为它的整数值                            |
   | hex(x )                | 将一个整数转换为一个十六进制字符串                    |
   | oct(x )                | 将一个整数转换为一个八进制字符串                      |
** 功能
*** 命名函数 def funname(a="a"): 默认值
*** 对象属性 
    对象的长度  len(obj), 整数没有长度
    
    间隔选择
    foostr = 'abcde'
    foostr[::-1]
** 流程控制
   #+BEGIN_SRC python
     if 判断条件：
     执行语句……
     else：
     执行语句……
#+END_SRC

while 循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
循环控制
break
continue
assert(3>4) 断言, 产生此种情况会中断

** 帮助
   help()  函数或类文档字串说明
   dir() 函数或类的性质
** 对象监控(异常处理)
*** 捕捉异常可以使用 try/except 语句
#+BEGIN_SRC python
  try:
  <语句>        #运行别的代码
  except <名字>：
  <语句>        #如果在 try 部份引发了'name'异常
  except <名字>，<数据>:
  <语句>        #如果引发了'name'异常，获得附加的数据
  else:
  <语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** CGI 对象
   : CGI 程序可以是 Python 脚本，PERL 脚本，SHELL 脚本，C 或者 C++程序等
*** Web 服务器支持及配置

在你进行 CGI 编程前，确保您的 Web 服务器支持 CGI 及已经配置了 CGI 的处理程序。

Apache 支持 CGI 配置：

设置好 CGI 目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的 HTTP 服务器执行 CGI 程序都保存在一个预先配置的目录。这个目录被称为 CGI 目录，并按照惯例，它被命名为/var/www/cgi-bin 目录。

CGI 文件的扩展名为.cgi，python 也可以使用.py 扩展名。

默认情况下，Linux 服务器配置运行的 cgi-bin 目录中为/var/www。

如果你想指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个 CGI 程序

我们使用 Python 创建第一个 CGI 程序，文件名为 hello.py，文件位于/var/www/cgi-bin 目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一 CGI 程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI 环境变量
: 所有的 CGI 程序都接收以下的环境变量，这些变量在 CGI 程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的 MIME 类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded,他表示数据来自于 HTML 表单。
CONTENT_LENGTH	如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。
QUERY_STRING	如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。
REMOTE_HOST	这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI 脚本的完整路径
SCRIPT_NAME	CGI 脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或 IP 地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)
** 网络对象
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统 Socket 接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
* Web 框架
** 轻量级
** 重量级
*** Django
**** 一个完整的初学者指南Django - 第1部分
     Django 是一个用 Python 编写的 Web 框架。这个 Web 框架支持动态网站，应用程序和服务开发。
     它提供了一组工具和功能，可解决许多与 Web 开发相关的常见问题，例如安全功能，数据库访问，会话，模板处理，URL 路由，国际化，本地化等等。
**** 安装
     如果我们想开始使用 Django ，那么我们需要安装一些应用程序，包括安装 **Python**，**Virtualenv** 和 **Django**。

     ![基本设置](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Basic_Setup.png)
     一开始，强烈建议使用虚拟环境，虽然不是强制性的，可是这对于初学者来说，是一个很好的开端.
     在使用 Django 开发 Web 站点或 Web 项目时，必须安装外部库以支持开发是非常常见的。使用虚拟环境，您开发的每个项目都会有其独立的环境。所以依赖关系不会发生冲突。它还允许您维护在不同 Django 版本上运行的本地计算机项目。
***** 安装Python 3.6.2
***** 安装 Virtualenv
      接下来这一步，我们将通过 **pip**(一个管理和安装Python包的工具)来安装**Virtualenv**。


      请注意，Homebrew 已经为您的 Python 3.6.2 安装了 `pip3`。
      
      在终端中，执行下面的命令：

 ```
 sudo pip3 install virtualenv
 ```

 ![pip3安装virtualenv](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/pip-virtualenv.png)


 到目前为止，我们执行的操作都是在系统环境下的。不过，从这一刻起，我们安装的所有东西，包括 Django 本身，都将安装在虚拟环境中。
 你可以这样想像一下：对于每个 diango 项目，我们都会为它创建一个虚拟环境。这就好比每个 Django 项目都是一个独立的沙盒，你可以在这个沙盒里随意的玩，安装软件包，卸载软件包，不管怎么对系统环境都不会有任何影响，也不会对其他项目有影响。


 我个人喜欢在我的电脑上创建一个 **Development** 的文件夹，然后在这个文件夹下存放我的所有项目。当然，你也可以根据下面的步骤来创建你个人的目录。


 通常，我会在我的 **Development** 文件夹中创建一个项目名称的新文件夹。竟然这是我们的第一个项目，就直接将项目名称起为 **myproject**。

 ```
 mkdir myproject
 cd myproject
 ```
 该文件夹将存储与 Django 项目相关的所有文件，包括其虚拟环境。

 接下来，我们将开始创建我们第一个虚拟环境和安装 Django。

 在 **myproject** 文件夹中，我们创建一个基于 python 3 的虚拟环境。

 ```
 virtualenv venv -p python3
 ```

 当然，我们先开启虚拟环境啦，可以通过以下命令来激活一下虚拟环境：

  ```
  source venv/bin/activate
  ```

 如果你在命令行的前面看到 **（venv）**，就说明，虚拟环境激活成功，现在已经进入到虚拟环境里面了。如下图所示：

 那么这里面到底发生了什么呢？
 其实这里我们首先创建了名为 **venv** 的特殊文件夹，这个文件夹里面有 python 的副本，当我们激活 **venv** 环境之后，运行 `Python` 命令时，它使用的是存储在 **venv** 里面 `Python` 环境 ，而不是我们装在操作系统上的。


 如果在该环境下，我们使用 **PIP** 安装 python 软件包，比如 Django ，那么它是被安装在 **venv** 的虚拟环境上的。
 这里有一点需要注意的，当我们启动了 **venv** 这个虚拟环境后，我们使用命令 `python` 就能调用 python 3.6.2 ，而且也仅仅使用 `pip`（而不是`pip3`）来安装软件包。
 那么如果我们想退出 **venv** 虚拟环境，该如何操作呢？
 只要运行以下命令就可以：

 ```
 deactivate
 ```

 不过，现在我们先不退出虚拟环境 **venv** ，保持着虚拟环境的激活状态，开始下一步操作。
 ##### 安装Django 1.11.4

 现在我们来安装以下 Django 1.11.4 ，因为我们已经开启了虚拟环境 **venv** ，因此，这操作会非常的简单。我们将运行下面的命令来安装 Django ：

 ```
 pip install django
 ```
****** 开始一个新项目
       要开始一个新的 Django项目，运行下面的命令：
       到目前为止，我们终于可以开始一个新的 Django 项目了，运行下面的命令，创建一个 Django 项目：

       ```
       django-admin startproject myproject
       ```

       命令行工具 **django-admin** 会在安装 Django 的时候一起安装的。

       当我们运行了上面的命令之后，系统就会自动的为 Django 项目生成基础的文件。
       我们可以打开 **myproject** 目录，可以看到具体的文件结构如下所示：


  ```
  myproject/                  <-- higher level folder
   |-- myproject/             <-- django project folder
   |    |-- myproject/
   |    |    |-- __init__.py
   |    |    |-- settings.py
   |    |    |-- urls.py
   |    |    |-- wsgi.py
   |    +-- manage.py
   +-- venv/                  <-- virtual environment folder
  ```


  可以看到，一个初始 Django 的项目由五个文件组成：


     **manage.py**：**django-admin** 是命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。
     **__init__.py**：这个空文件告诉 Python 这个文件夹是一个 Python 包。
     **settings.py**：这个文件包含了所有的项目配置。我们会一直使用到这个文件。
     **urls.py**：这个文件负责映射我们项目中的路由和路径。例如，如果您想在 URL `/about/` 中显示某些内容，则必须先将其映射到此处。
     **wsgi.py**：该文件是用于部署简单的网关接口。现在我们暂时不用关心它的内容。



  Django 自带有一个简单的 Web 服务器。在开发过程中非常方便，所以我们不需要安装其他任何软件即可以在本地运行项目。我们可以通过执行命令来运行它：

  ```
  python manage.py runserver
  ```
  现在在 Web 浏览器中打开以下 URL：**http://127.0.0.1:8000**，您应该看到以下页面：

  这里提醒一点，如果你需要停止服务器，可以 `Control + C` 点击停止开发服务器。
****** Django 的应用
       在 Django 哲学中，我们有两个重要的概念：

      **app**：是一个可以执行某些操作的 Web 应用程序。一个应用程序通常由一组 models(数据库表)，views(视图)，templates(模板)，tests(测试) 组成。
      **project**：是配置和应用程序的集合。一个项目可以由多个应用程序或一个应用程序组成。

   请注意，如果没有一个 project，你就无法运行 Django 应用程序。像博客这样的简单网站可以完全在单个应用程序中编写，例如可以将其命名为 blog或 weblog。

   ![Django应用程序](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Django_Apps.png)


   当然这是组织源代码的一种方式，现在刚入门，判断确定什么是不是应用程序这些还不太重要。包括如何组织代码等，现在都不是担心这些问题的时候。现在，首先让我们先熟悉了解 Django 的 API 和基础知识。

   好了，为了更好的了解，我们先来创建一个简单的论坛项目，那么我们要创建一个应用程序，首先要进入到 **manage.py** 文件所在的目录并执行以下命令：

   ```
   django-admin startapp boards
   ```


   请注意，这次我们使用了命令 **startapp**。

   这会给我们以下的目录结构：

   ```
   myproject/
    |-- myproject/
    |    |-- boards/                <-- our new django app!
    |    |    |-- migrations/
    |    |    |    +-- __init__.py
    |    |    |-- __init__.py
    |    |    |-- admin.py
    |    |    |-- apps.py
    |    |    |-- models.py
    |    |    |-- tests.py
    |    |    +-- views.py
    |    |-- myproject/
    |    |    |-- __init__.py
    |    |    |-- settings.py
    |    |    |-- urls.py
    |    |    |-- wsgi.py
    |    +-- manage.py
    +-- venv/
   ```


   所以，我们先来看看每个文件的功能：
      **migrations /**：在这个文件夹中，Django 会存储一些文件以跟踪您在 **models.py** 文件中创建的更改，目的是为了保持数据库和 **models.py** 同步。
      **admin.py**：这是 Django应用程序一个名为 **Django Admin** 的内置配置文件。
      **apps.py**：这是应用程序本身的配置文件。
      **models.py**：这里是我们定义 Web 应用程序实体的地方。models  由 Django 自动转换为数据库表。
      **tests.py**：该文件用于为应用程序编写单元测试。
      **views.py**：这是我们处理Web应用程序请求(request)/响应(resopnse)周期的文件。

   现在我们创建了我们的第一个应用程序，让我们来配置一下项目以便启用这个应用程序。


   为此，请打开**settings.py**并尝试查找`INSTALLED_APPS`变量：

   **settings.py**

   ```
   INSTALLED_APPS = [
       'django.contrib.admin',
       'django.contrib.auth',
       'django.contrib.contenttypes',
       'django.contrib.sessions',
       'django.contrib.messages',
       'django.contrib.staticfiles',
   ]
   ```

   正如你所看到的，Django 已经安装了6个内置的应用程序。它们提供大多数Web应用程序所需的常用功能，如身份验证，会话，静态文件管理（图像，JavaScript，CSS等）等。

   我们将会在本系列教程中探索这些应用程序。但现在，先不管它们，只需将我们的应用程序 boards 添加到 `INSTALLED_APPS` 列表即可：

   ```
   INSTALLED_APPS = [
       'django.contrib.admin',
       'django.contrib.auth',
       'django.contrib.contenttypes',
       'django.contrib.sessions',
       'django.contrib.messages',
       'django.contrib.staticfiles',

       'boards',
   ]
   ```

   使用上个漫画中的正方形和圆形的比喻，黄色圆圈将成为我们的 **boards** 应用程序，而 **django.contrib.admin**，**django.contrib.auth** 等将成为红色圆圈。
******  Hello, World!
       现在我们先来写一个我们的第一个 **视图（view）** ，那么，现在我们来看看该如何使用 Django 来创建一个新的页面吧。


   打开 **boards** 应用程序中的 **views.py** 文件，并添加下面的代码：

   **views.py**

   ```python
   from django.http import HttpResponse

   def home(request):
       return HttpResponse('Hello, World!')
   ```

   **视图（view）** 是接收 `HttpRequest` 对象并返回 `HttpResponse`对象的 Python 函数。接收 request 作为参数并返回 response 作为结果。这个过程是需要我们记住的。


   因此，就像我们上面的代码，我们定义了一个简单的视图，命名为 `home` ，然后我们简单的返回了一个字符串 **Hello，World！**


   那么我们直接运行就可以了吗？

   并不是的，我们还没有告诉 Django 什么时候调用这个 **视图（view）** 呢？这就需要我们在 **urls.py** 文件中完成：


   **urls.py**

   ```Python
   from django.conf.urls import url
   from django.contrib import admin

   from boards import views

   urlpatterns = [
       url(r'^/code>, views.home, name='home'),
       url(r'^admin/', admin.site.urls),
   ]
   ```

    现在要变更成 url('code/', views.home, name='home'),

   如果您将上面的代码段与您的 **urls.py** 文件进行比较，您会注意到我添加了以下的代码：`url(r'^$', views.home, name='home')` 并使用我们的应用程序 **boards** 中导入了 **views** 模块。`from boards import views`

   可能这里大家还是会有很多疑问，不过先这样做，在后面我们会详细探讨这些概念。

   但是现在，Django 使用**正则表达式**来匹配请求的URL。对于我们的 **home** 视图，我使用的是`^$`正则表达式，它将匹配空白路径，这是主页（此URL：**http://127.0.0.1:8000**）。如果我想匹配URL **http://127.0.0.1:8000/homepage/**，那么我们 url 的正则表达式就应该这样写：`url(r'^homepage/$', views.home, name='home')`。

   运行项目，让我们看看会发生什么：

   ```
   python manage.py runserver
   ```


   在 Web 浏览器中，打开 http://127.0.0.1:8000 ：


   ![你好，世界！](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/hello-world.png)


   这样我们就看到了我们刚刚创建的第一个界面了。

    * *

   #### 总结

   这是本系列教程的第一部分。在本教程中，我们学习了如何安装最新的 Python 版本以及如何设置开发环境。我们还介绍了虚拟环境，并开始了我们第一个 Django 项目，并已创建了我们的初始应用程序。

   我希望你喜欢第一部分！第二部将涉及模型，视图，模板和网址。我们将一起探索所有的Django 基础知识！

   就这样我们可以保持在同一页面上，我在 GitHub 上提供了源代码。项目的当前状态可以在发布**release tag v0.1-lw**下找到。下面的链接将带你到正确的地方：

   [https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw](https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw)
**** #### 介绍
欢迎来到 Django 教程的第二部分！在上一课中，我们安装了项目所需要的一切软件，希望你们在学习这篇文章之前，安装了 Python 3.6，并且在虚拟环境中运行Django 1.11。因为，在本篇文章中，我们将继续在这个项目中编写我们的代码。


在这一篇文章中，可能不会有太多的代码操作，主要是讨论分析项目。在下一篇中，我们就开始学习 Django 的基础知识，包括模型（models），管理后台（admin），视图（views），模板（templates）和 路由（URL）。


在这里，还是跟第一篇一样，建议大家多动手。

 * *

#### 论坛项目


每个人的学习习惯都是不同的，不知道你们是怎样的，就我个人而言，通过看实例和一些代码片段，可以让我学的更多，学的更快。但是，有些时候当我们看到 `Class A`和`Class B` ，或者是 `foo(bar)` 这样的例子的时候，我们是很难理解这些概念的。


所以在我们进入模型（models），创建视图（views） 这些有趣的代码实操之前，我们还是需要花点时间，简单的讨论一下我们将怎样设计，开发这个项目。


但是如果你已经有 web 开发经验的，而且觉得讲的太细了，那么你可以快速的浏览一下，然后进入到 【模型（models）】那一块中。

如果你对 Web 开发并不熟悉，那么我强烈建议你认真阅读下去。这里会介绍 web 应用程序开发的建模和设计，因为对于 web 开发来说，敲代码只是其中的一部分，模型的设计也是很重要的。


![火箭科学](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Rocket_Science.png)


##### 用例图


我们的项目本身是一个论坛系统，整个项目来说就是维护几个【论坛板块（boards）】 ，然后在每个板块里面，用户可以通过创建【主题（Topic）】并且在主题中讨论。


一般情况下，只有管理员才能创建【论坛板块（boards）】，那么在用户这方面，我们就需要分为普通用户和管理员用户了，而且他们拥有的权限是不同的，管理员用户可以创建 【论坛板块（boards）】，【主题（Topic）】以及讨论回复，而普通用户只能发布【主题（Topic）】以及讨论回复。具体每个用户角色的功能分配如下图：



> 图1：Web Board 核心功能的用例图


![用例图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/use-case-diagram.png)



##### 类图


从上面的用例图中，我们可以开始思考我们项目中的**实体类**有哪些了。这些实体是我们要创建的模型，它与我们的 Django 应用非常密切。


如果要实现上面我们说到的论坛，那么我们至少需要以下的几个模型：**Board**，**Topic**，**Post**和**User**。

 **Board** : 版块
 **Topic** : 主题
 **Post** : 帖子（用户评论与回复）
 **User** : 用户


> 图2：Web Board 类图


![基本类图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/basic-class-diagram.png)


上面我们只是说了需要有几个模型，并没有提到模型与模型之间是怎么关联的。


通过上面的图片我们可以知道，主题（Topic）与版块（Board） 之间是有关联的，就好比我们需要知道这个主题（Topic） 是属于哪一个版块的（Board），因此我们需要一个字段，也就是可以通过外键爱关联它们。


同样的，一个帖子（Post） 也是需要确定它是那个主题的，当然，用户和主题（Topic）和帖子（Post） 之间也是有联系的，因为我们需要确认是谁发的帖子，是谁回复评论了内容。


竟然知道了模型之间的联系了，那么我们也必须要考虑这些模型应该存放哪些信息。就目前而言，我们的模型可以设计成这样：


> 图3：类（模型）之间关系的类图


![类图](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram.png)



这个类图强调的是模型之间的关系，当然最后这些线条和箭头都会用字段来进行表示。

**Board（版块模型）** ：Board 中有 **name** 和 **description** 这两个字段，name 是唯一的，主要是为了避免两个名称重复。description 则是用于描述把这个版块来用干什么的。


**Topic（主题模型）** ：subject 表示主题内容，last_update 用来定义话题的排序，starter 用来识别谁发起的话题，board 用于指定它属于哪个版块


**Post（帖子模型）** ： message 字段，用于存储回复的内容，created_at 创建的时间，在排序时候用（最先发表的帖子排最前面），updated_at 更新时间，告诉用户是否更新了内容，同时，还需要有对应的 User 模型的引用，Post 由谁创建的和谁更新的。


**User（用户模型）** ：这里有 username ，password，email 和 is_superuser 四个字段。


这里值得注意的是，我们在 Django 应用中，不需要创建 User 用户模型，因为在 Django 的 contrib 中已经内置了 User 模型，我们可以直接拿来使用，就没必要重新创建了。


认真观察的童鞋应该看到了，上面的模型关系图中，模型与模型之间的对应关系有数字 1，0..* 等等的字段，这是代表什么意思呢？


如下图，`1` 代表一个 Topic 必须与一个  Board 相关联，`0..*` 代表 Board 下面可能会有多个和 0 个 Topic ，也就是一对多的关系。


![类图板和主题协会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-board-topic.png)


这里也是一样，`1` 代表一个 Post 只有一个  Topic ，`1..*` 代表一个 Topic 下面可能会有 1 个和多个个 Post ，也就是说，一个主题最少一个一个帖子。



![类图主题和帖子关联](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-post.png)


`1` 代表一个 Topic 有且至于一个  User ，`0..*` 代表一个 User（用户） 可能拥有多个 Topic ，也可能没有。


![类图主题和用户关联](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-user.png)


Post（帖子） 和 User（用户）的关系也是类似，一个 Post 必须有一个 User ，而一个 User 可能没有也可能有多个 Post。这里的 Post ，用户发布了之后是可以进行修改的，也就是更新（updated_by），当然如果又被修改，updated_by 就是为空了。


![类图邮政和用户协会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-post-user.png)一


当然，如果你觉得上面的图看起来很复杂，那么你也可以不需要强调模型与模型之间的关系，直接强调字段就可以了，如下图：


> 图4：强调类（模型）属性（字段）的类图


![类图属性](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-attributes.png)


其实这种表达图和前面那个显示箭头和线的表达图，要表达的内容是一样的。不过使用这种表达方式可能更符合 Django  Modles API 的设计。


好了，现在已经够 UML 了！为了绘制本节介绍的图表，我使用的是 [StarUML](http://staruml.io/) 工具。


##### 原型图


花了一些时间来设计我们的程序模型，后面我们也需要设计一下我们的网页原型图。只有这样，才能更好的让我们清楚的知道自己将要干什么？


![线框漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Wireframes.png)



首先，是我们的主页，在主页中，我们会显示我们所有的版块：


> 图5：主页显示所有的版块信息


![线框板](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-boards.png)


同样的，当用户点进了版块信息，进入到版块页面，那么版块页面也将显示该版块下的所有主题：


>图6：版块下的所有主题信息

![线框主题](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-topics.png)


通过观察图片，细心的你，可能会发现，用户在这个页面有两条可以走的路线。第一条就是点击 “new topic” 来创建新的主题，第二条就是点击已经存在的主题进入相关的主题进行讨论回复。



“new topic” 的界面如下 ：


![线框新主题](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-new-topic.png)


而，进入了相关的主题后，应该显示具体的帖子信息和用户的一些回复信息：


![线框帖子](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-posts.png)



如果用户点击 “Reply” 的按钮，他们将看到下面的页面，并以相反的顺序（最新的第一个）对帖子进行显示：

![线框回复](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-reply.png)


那么这些图是用什么来绘制的呢？你可以使用 [draw.io](https://draw.io/) ，而且他是完全免费的。


 * *

#### 模型（Models）


上一部分，设计了我们 Web 应用的数据库还有界面原型设计。在模型（Models）这一部分中，我们将在 Django 中创建我们数据库的模型类：**Board** ，**Topic** 和 **Post** 。


这里是不是有个疑问，明明我们设计数据库的时候是有 **User** 的，为什么我们不用创建它的模型类呢？是不是写漏了？


并不是，那是因为 **User** 这个模型类，已经内置在 Django 应用程序中的，**User** 模型就在 **django.contrib.auth** 中。在 settings.py 中，`INSTALLED_APPS` 就配置了**django.contrib.auth**。


好了，现在我们将根据我们上面设计的数据库模型来完成我们项目 **boards** 下的 models.py 文件中的所有操作。


> **boards/models.py**

```python
from django.db import models
from django.contrib.auth.models import User

class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

class Topic(models.Model):
    subject = models.CharField(max_length=255)
    last_updated = models.DateTimeField(auto_now_add=True)
    board = models.ForeignKey(Board, related_name='topics')
    starter = models.ForeignKey(User, related_name='topics')

class Post(models.Model):
    message = models.TextField(max_length=4000)
    topic = models.ForeignKey(Topic, related_name='posts')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    created_by = models.ForeignKey(User, related_name='posts')
    updated_by = models.ForeignKey(User, null=True, related_name='+')
```

可以看到，创建的所有模型类，**Board** ， **Topic** 和 **Post** 都是 **django.db.models.Model** 的子类，它们都将会转化成数据表。而 **django.db.models.Field** 的子类（Django 内置的核心类）的实例都会转化为数据表中的列。


上面可以看到的 `CharField`，`DateTimeField` 等，都是 **django.db.models.Field** 的子类，在 Django 项目中都可以直接使用它们。


在这里，我们仅仅使用了 `CharField`，`TextField`，`DateTimeField`，和 `ForeignKey` 字段来定义我们的模型（Models） 。当然，在 Django 中，不仅仅只是提供了这些字段，还提供了更多，更广泛的选择来代表不同类型的数据，比如还有：`IntegerField`，`BooleanField`， `DecimalField`。我们会根据不同的需求来使用它们。	
 

有些字段是需要参数的，就好比 `CharField` ，我们都设定了一个 `max_length` , 设置一个最大长度。当我们设定了这个字段后，就会作用于数据的。


在 `Board` 模型（Model）中，在 `name` 字段中，我们也设置了参数 `unique=True`，顾名思义，这是为了在数据库中，保证该字段的唯一性。


在 `Post` 模型中，`created_at` 字段有一个可选参数，`auto_now_add` 设置为 `True`。这是为了指明 Django 在创建 `Post` 对象的时候，`created_at` 使用的是当前的日期和时间。


创建模型与模型之间关系的其中一种方法就是使用 `ForeignKey` 字段，使用这个字段，会自动创建模型与模型之间的联系，而且会在数据库中也创建它们的关系。使用 `ForeignKey` 会有一个参数，来表明他与那个模型之间的联系。 例如：


在 `Topic` 模型中，`models.ForeignKey(Board, related_name='topics')`，第一个参数是代表关联的表格（主表），在默认情况下，外键存储的是主表的主键（Primary Key）。第二个参数 `related_name` 是定义一个名称，用于反向查询的。Django 会自动创建这种反向关系。 虽然 `related_name` 是可选参数，但是如果我们不为它设置一个名称的，Django 会默认生成名称 `(class_name)_set` 。例如，在 `Board` 模型中，`Topic` 实例将在该 `topic_set` 属性下可用。而我们只是将其重新命名为`topics`，使用起来更加自然。


在 `Post` 模型中，`updated_by` 字段设置`related_name='+'`。这指示 Django 我们不需要这种反向关系。


下面这张图可以很好地看到设计图和源码之间的比较，其中绿线就表示了我们是如何处理反向关系的。


![类图模型定义](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-django-models.png)


可能到这一步，你会问：“主键呢？”好像我们都没有定义主键啊。对，如果我们没有为模型（Models）指定主键，那么 Django 会自动生成它。


##### 迁移模型（Migrating the Models）


到这一步，我们要开始告诉 Django 如何创建数据库，这样方便我们更好的使用。


打开**终端** ，激活虚拟环境，进入到 **manage.py** 文件所在的文件夹，然后运行以下命令：


```
python manage.py makemigrations
```

这时，你会看到这样的输出信息：


```
Migrations for 'boards':
  boards/migrations/0001_initial.py
    - Create model Board
    - Create model Post
    - Create model Topic
    - Add field topic to post
    - Add field updated_by to post
```


此时，Django 在 **boards / migrations** 目录内创建了一个名为**0001_initial.py** 的文件。它代表了我们应用程序模型的当前状态。在下一步中，Django 将使用该文件来创建表和列。


迁移文件被翻译成 SQL 语句。如果您熟悉 SQL，则可以运行以下命令来检查将在数据库中执行的 SQL 指令：

```
python manage.py sqlmigrate boards 0001
```


如果你不熟悉 SQL，也不用担心。在本系列教程中，我们不会直接使用 SQL。所有的工作都将使用 Django ORM 来完成，它是一个与数据库进行通信的抽象层。

好了，下一步我们将把我们的迁移文件应用到我们的数据库中：


```
python manage.py migrate</code>
```


输出应该是这样的：

```
Operations to perform:
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
```



因为这是我们第一次迁移数据库，所以该 `migrate` 命令还应用了 Django contrib 应用中现有的迁移文件，这些文件列于 `settings.py` 中的 `INSTALLED_APPS` 。


而 `Applying boards.0001_initial... OK` 就是指我们在上一步中生成的迁移文件。


好了，此时！我们的数据库已经可以使用了。


![SQLite的](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_SQLite.png)


> **注意：** 需要注意的是 **SQLite** 是一个数据库。SQLite 被许多公司用于成千上万的产品，如所有 Android 和 iOS 设备，所有主要的 Web 浏览器，Windows 10，MacOS 等。
>
> 当然，它也不是适合所有的应用场景。SQLite 不能与 MySQL，PostgreSQL 或 Oracle 等数据库进行比较。大容量网站，密集型的应用程序，大数据集，高并发性，这些使用使用 SQLite 可能会导致很多问题。
>
> 在我们开发的项目中，我们将使用 SQLite ，因为它很方便，我们不需要安装其他任何东西。当我们将项目部署到生产环境时，我们将切换到 PostgreSQL 。因为这对于简单的网站是不错的选择。但这里有一点要注意，对于复杂的网站，建议在开发和生产中使用相同的数据库。


##### Models API


使用 Python 开发的一个重要优点是交互式 shell。我几乎一直都在使用它。这是一个可以快速尝试和测试实验的方法。

你可以使用 **manage.py** 加载我们的项目来启动 Python shell ：

启动命令：

```
python manage.py shell
```

可以看到这样的输出：

```
Python 3.6.2 (default, Jul 17 2017, 16:44:45)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>>
```


在我们使用 `python manage.py shell` 之外，我们也可以将项目添加到`sys.path`并加载 Django。这意味着我们可以在项目中导入我们的模型(models) 和任何其他资源。

我们从导入 **Board** 类开始：

```
from boards.models import Board
```

如果我们需要创建 **Board** 对象，我们可以执行以下操作：

```
board = Board(name='Django', description='This is a board about Django.')
```

此时我们只是创建了这个对象，并没有保存到数据库的，因此我们可以调用 `save` 方法，将这个对象保存在数据库中。


```
board.save()
```

该 `save` 方法 ，在创建对象和更新对象中都可以使用，这里 Django 会创建一个新的对象，因为 **Board** 实例是没有 **id** 这个字段的，因此保存后，Django 会自动设置一个 ID ：


```
board.id
1
```


其他的字段你也可以当作属性来访问就好了，比如：

```
board.name
'Django'
```

```
board.description
'This is a board about Django.'
```


要更新一个值，我们可以这样做：


```
board.description = 'Django discussion board.'
board.save()
```


每个 Django 模型 (Models) 都带有一个特殊的属性; 我们称之为 **Model Manager（模型管理器）**。我们可以通过 Python 属性 `objects` 来访问它。它主要用于在数据库中执行查询。例如，我们可以使用它来直接创建一个新的**Board** 对象：

```
board = Board.objects.create(name='Python', description='General discussion about Python.')
```

```
board.id
2
```

```
board.name
'Python'
```

所以，结合之前的操作，我们现在有两个 boards 对象。我们可以使用`objects` 列出数据库中所有现有的 boards ：


```
Board.objects.all()
<QuerySet [<Board: Board object>, <Board: Board object>]>
```


结果是一个 **QuerySet** 。稍后我们会进一步了解它。基本上，它是来自数据库的对象列表。通过输出结果，可以看到我们有两个对象，但我们只能读取 **Board对象** 。这是因为我们没有在 **Board** 模型中定义 `__str__` 方法。


该 `__str__` 方法是一个对象的字符串表示。我们可以使用 Board 的名称来表示它。


首先，退出交互式控制台：


```
exit()
```


现在编辑 **boards** 应用程序中的 **models.py** 文件：


```
class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

    def __str__(self):
        return self.name
```


让我们再次尝试查询。再次打开交互式控制台：


```
from boards.models import Board

Board.objects.all()
<QuerySet [<Board: Django>, <Board: Python>]>
```


仔细对比上面的，看下区别？

可以看到上面那个是 object ，而这里是我们定义的字符串。


我们可以将这个 **QuerySet** 看作一个列表。假设我们想遍历它并打印每个 Board（版块） 的描述：


```
boards_list = Board.objects.all()
for board in boards_list:
    print(board.description)
```


结果是：


```
Django discussion board.
General discussion about Python.
```


当然，我们也可以使用 **Model Manager（模型管理器）** 来查询数据库，如果查询其中的一个，我们可以使用 `get` 的方法：


```
django_board = Board.objects.get(id=1)

django_board.name
'Django'
```

当然我们要小心这种情况，因为很容易发生内存溢出的。比如我们试图去查询一个不存在的对象，就好比我们数据库只有两个 Board 对象，如果你查询 `id=3`，那么它会引发一个异常：


```
board = Board.objects.get(id=3)

boards.models.DoesNotExist: Board matching query does not exist.
```

当然，在 `get` 方法中，参数可以是该模型下的字段，最好是使用唯一的标识字段。否则会返回多个对象，会导致异常的。


```
Board.objects.get(name='Django')
<Board: Django>
```


请注意，查询是区分大小写的，小写 “django” 是不匹配的：


```
Board.objects.get(name='django')
boards.models.DoesNotExist: Board matching query does not exist.
```


##### 模型操作摘要

下面的表格是我们在本章节中学到的方法和操作。代码示例使用 **Board** 模型作为参考示例。大写的 **Board** 代表类，小写的 **board** 是指 **Board** 的实例对象。


| 描述 | 代码示例 |
| --- | --- |
| 创建一个对象并没有保存 | `board = Board()` |
| 保存一个对象（创建或更新） | `board.save()` |
| 在数据库中创建并保存一个对象 | `Board.objects.create(name='...', description='...')` |
| 列出所有对象 | `Board.objects.all()` |
| 获取由字段标识的单个对象 | `Board.objects.get(id=1)` |


在下一节中，我们将开始编写视图并在 HTML 页面中显示我们的版块页面。


 * *

#### Views, Templates 和静态文件


回顾一下，我们之前做的。我们已经可以在应用程序的主页上显示 ”Hello ，World！“ 的界面了。


> **MyProject/urls.py**

```
from django.conf.urls import url
from django.contrib import admin

from boards import views

urlpatterns = [
    url(r'^/code>, views.home, name='home'),
    url(r'^admin/', admin.site.urls),
]
```

> **boards/views.py**

```
from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello, World!')
```

好了，现在我们需要修改这个主页，如果你不记得我们的主页要做成什么样子，可以看看之前我们已经设计好的原型界面图。我们在主页上，要做的是在表格中显示一些版块的名单和其他的一些信息。


首先我们要做的是：导入 **Board** 模型，然后获取所有的存在的版块（boards）信息


> **boards/views.py**


```
from django.http import HttpResponse
from .models import Board

def home(request):
    boards = Board.objects.all()
    boards_names = list()

    for board in boards:
        boards_names.append(board.name)

    response_html = '<br>'.join(boards_names)

    return HttpResponse(response_html)
```



然后我们运行，就会看到这个简单的 HTML 页面：



![主页HttpResponse](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-httpresponse.png)


但是，一般情况下，我们是不会通过这种方式去渲染 HTML ，在 **views.py** 中，我们只需要获取 **boards** 的集合，至于 HTML 渲染那部分的代码，我们应该在 Django 的 templates 目录下完成。


##### Django 模板引擎设置

竟然我们要将 **views.py** 里渲染 HTML 的代码分离，那么我们首先要在 **baords** 的同目录下，创建一个名为 **templates** 的文件夹。


```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/   <-- here!
 |    +-- manage.py
 +-- venv/
```

在我们创建的 **templates** 文件夹中，我们创建一个名为 **home.html** 的 HTML 文件

> **templates/home.html**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
  </head>
  <body>
    <h1>Boards</h1>

    {% for board in boards %}
      {{ board.name }} <br>
    {% endfor %}

  </body>
</html>
```

**home.html** 的文件内容如上面的一样，是一些原始的 HTML 标签代码和 Django 语言上的代码：`{% for ... in ... %}` ，`{{ variable }}`。上面的代码中展示了如何使用 for 循环遍历 list 对象。

到此，我们的 HTML 页面已经完成了，可是我们还没有告诉 Django 在哪里能找到我们应用中的 `templates` 文件夹里的 HTML。


首先，我们在 Django 中绑定一下我们的 `templates` ,打开我们 ** myproject** 项目中的 **settings.py** 文件，搜索 `TEMPLATES` 变量然后在 `DIRS`设置 ：`os.path.join(BASE_DIR, 'templates')`

具体如下：

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates')
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

这样设计就好比相当于在你的项目中的完整路径下，在加上 "/templates"

那是不是跟我们预想的一样呢？我们可以通过 python shell 进行调试：

```
python manage.py shell
```

```
from django.conf import settings

settings.BASE_DIR
'/Users/vitorfs/Development/myproject'

import os

os.path.join(settings.BASE_DIR, 'templates')
'/Users/vitorfs/Development/myproject/templates'
```


可以看到，目录就是指向我们在上面创建的 **templates** 文件夹

此时，我们只是绑定了 **templates** 文件夹的路径，Django 并没有绑定我们 **home.html** ，我们可以在 **views.py** 中绑定：

```
from django.shortcuts import render
from .models import Board

def home(request):
    boards = Board.objects.all()
    return render(request, 'home.html', {'boards': boards})
```



运行后，HTML 的页面是这样的：


![主板渲染](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render.png)

我们可以改进HTML模板来代替使用表格：

> **templates/home.html**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
  </head>
  <body>
    <h1>Boards</h1>

    <table border="1">
      <thead>
        <tr>
          <th>Board</th>
          <th>Posts</th>
          <th>Topics</th>
          <th>Last Post</th>
        </tr>
      </thead>
      <tbody>
        {% for board in boards %}
          <tr>
            <td>
              {{ board.name }}<br>
              <small style="color: #888">{{ board.description }}</small>
            </td>
            <td>0</td>
            <td>0</td>
            <td></td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  </body>
</html>
```


![主板渲染](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render-2.png)


##### 测试主页


![测试漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Testing.png)

测试这部分会在这系列教程中会不断的重复探讨。


现在让我们来写第一个测试，首先在应用程序 **boards** 中找到 **tests.py** 

> **boards/tests.py** 

```
from django.core.urlresolvers import reverse
from django.test import TestCase

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
```

这是一个非常简单的测试用例，但非常的有用。我们在测试的是响应状态码，如果是 200 意味着成功。


我们可以在控制台中检查响应码：

![回应200](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/test-homepage-view-status-code-200.png)


如果出现未捕获的异常，语法错误或其他任何情况，Django 会返回状态代码**500**，这意味着**服务器错误**。现在，想象我们的应用程序有 100 个界面（view）。如果我们为所有视图（view）编写了这个简单的测试，只需一个命令，我们就可以测试所有视图是否返回成功代码，这样用户就不会在任何地方看到任何错误消息。如果没有自动化测试，我们需要逐一检查每个页面。

要执行 Django 的测试套件：

```
python manage.py test
```

```
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.041s

OK
Destroying test database for alias 'default'...
```

现在我们可以测试 Django 是否为请求的 URL 返回了正确的视图函数。这也是一个有用的测试，因为随着开发的进展，您会发现 **urls.py** 模块可能变得非常庞大而复杂。URL 配置全部是关于解析正则表达式的。有些情况下我们有一个非常宽容的URL，所以 Django 最终可能返回错误的视图函数。

以下是我们如何做到的：

> **boards/tests.py**

```
from django.core.urlresolvers import reverse
from django.urls import resolve
from django.test import TestCase
from .views import home

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

    def test_home_url_resolves_home_view(self):
        view = resolve('/')
        self.assertEquals(view.func, home)
```



在第二个测试中，我们正在使用 `resolve` 功能。Django 使用它来将请求的 URL与 **urls.py** 模块中列出的 URL 列表进行匹配。该测试将确保使用 `/`根 URL ，是否返回主视图（home view）。

再次测试：

```
python manage.py test
```

```
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.027s

OK
Destroying test database for alias 'default'...
```


要查看有关测试执行的更多详细信息，请将 **verbosity** 设置为更高级别：

```
python manage.py test --verbosity=2
```

```
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
Operations to perform:
  Synchronize unmigrated apps: messages, staticfiles
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
System check identified no issues (0 silenced).
test_home_url_resolves_home_view (boards.tests.HomeTests) ... ok
test_home_view_status_code (boards.tests.HomeTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.017s

OK
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
```

详细程度决定了将要打印到控制台的通知和调试信息量; 0 是无输出，1 是正常输出，2 是详细输出。

##### 静态文件设置

静态文件是指 CSS，JavaScript，字体，图像或者是我们用来组成用户界面的任何其他资源。

事实上，Django 不提供这些文件。但在开发过程中，我们又会用到，因此 Django 提供了一些功能来帮助我们管理静态文件。这些功能可在配置文件（settings.py）中 `INSTALLED_APPS` 里的 **django.contrib.staticfiles** 。

有了这么多的前端组件库，我们没有理由继续渲染基本的 HTML 。我们可以轻松地将Bootstrap 4 添加到我们的项目中。Bootstrap 是一个用 HTML，CSS 和JavaScript 开发的开源工具包。

在项目根目录中，除**boards**，**templates** 和 **myproject** 文件夹外，我们还需要创建一个名为 **static** 的文件夹，并在 **static** 文件夹内创建另一个名为 **css** 文件夹：

```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/       <-- here
 |    |    +-- css/     <-- and here
 |    +-- manage.py
 +-- venv/
```

到 [getbootstrap.com](https://getbootstrap.com/docs/4.0/getting-started/download/#compiled-css-and-js) 下载最新版本：

![Bootstrap下载](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/bootstrap-download.png)

下载 **Compiled CSS and JS** 的版本。

解压从 Bootstrap 网站下载的 **bootstrap-4.0.0-beta-dist.zip** 文件，将文件 **css / bootstrap.min.css** 复制到我们项目的css文件夹中：

```
myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/
 |    |    +-- css/
 |    |         +-- bootstrap.min.css    <-- here
 |    +-- manage.py
 +-- venv/
```

还是一样的问题，我们需要将 Django 中的 **settings.py** 里配置一下静态文件的目录。在 `STATIC_URL` 添加以下内容： 

```
STATIC_URL = '/static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
```


这里可以回忆一下，`TEMPLATES` 配置目录的路径，操作是差不多的。


现在我们必须在模板中加载静态文件（Bootstrap CSS文件）：

> **templates/home.html**

```
{% load static %}<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}">
  </head>
  <body>
    <!-- body suppressed for brevity ... -->
  </body>
</html>
```



首先，我们在 html 的开头加载静态文件：`{% load static %}`


`{% static %}` 是用于告诉资源文件存在的路径，在这是，`{% static 'css/bootstrap.min.css' %}` 就会返回 **/static/css/bootstrap.min.css** ，相当于 **http://127.0.0.1:8000/static/css/bootstrap.min.css**


这个 `{% static %}` 标签将会和 **settings.py** 的 `STATIC_URL` 组成最终的 URL。怎么理解这句话呢？

例如，我们在静态文件托管在 **https://static.example.com/** ，然后我们设置了这个属性：`STATIC_URL=https://static.example.com/`，然后 `{% static 'css/bootstrap.min.css' %}` 返回的是 ：**https://static.example.com/css/bootstrap.min.css**。


如果还不能理解，放心，你现在只需要了解和记住相关的过程就行了，后面正式开发上线的时候，会继续开展这部分的内容。


刷新页面 **127.0.0.1:8000** 我们可以看到它是这个样子的：

![Boards主页Bootstrap](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap.png)

现在我们可以编辑模板，以利用Bootstrap CSS：

现在我们可以利用 Bootstrap CSS 来编辑我们的模板页面了：



```
{% load static %}<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Boards</title>
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}">
  </head>
  <body>
    <div class="container">
      <ol class="breadcrumb my-4">
        <li class="breadcrumb-item active">Boards</li>
      </ol>
      <table class="table">
        <thead class="thead-inverse">
          <tr>
            <th>Board</th>
            <th>Posts</th>
            <th>Topics</th>
            <th>Last Post</th>
          </tr>
        </thead>
        <tbody>
          {% for board in boards %}
            <tr>
              <td>
                {{ board.name }}
                <small class="text-muted d-block">{{ board.description }}</small>
              </td>
              <td class="align-middle">0</td>
              <td class="align-middle">0</td>
              <td></td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </body>
</html>
```



修改后变成这样子：

![Boards主页Bootstrap](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-2.png)


到目前为止，我们使用交互式控制台（`python manage.py shell`）添加新的版块（board）。但是这样很不方便，因此我们需要一个更好的方式来做这个。在下一节中，我们将为网站管理员实施一个管理界面来管理它。

 * *

#### Django Admin简介

当我们开始一个新项目时，Django 在 `INSTALLED_APPS` 中已经配置了 **Django Admin** 。

![Django Admin漫画](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Django_Admin.png)

Django Admin 的一个很好的用例就是，在博客中，它可以被作者用来编写和发布文章。另一个例子是电子商务网站，工作人员可以创建，编辑，删除产品。

目前，我们将配置 Django Admin 来维护我们的应用程序的版块模块。

我们首先创建一个管理员帐户：

```
python manage.py createsuperuser
```

按照说明操作：

```
Username (leave blank to use 'vitorfs'): admin
Email address: admin@example.com
Password:
Password (again):
Superuser created successfully.
```

现在在浏览器中打开 URL：**http://127.0.0.1:8000/admin/**

![Django管理员登录](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-login.png)

输入 **用户名** 和 **密码** ：

![Django Admin](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin.png)


在这里，它已经配置了一些功能，我们也可以添加**用户**和**组**来管理权限。


那么我们如何在这个管理后台中管理版块（Board）里面的内容呢？

其实很简单，在 **board** 目录下，**admin.py** 中添加以下代码：


> **boards/admin.py**

```
from django.contrib import admin
from .models import Board

admin.site.register(Board)
```


保存以下，然后刷新网页：

![Django管理委员会](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards.png)

点击 **Boards** 链接就能查看现有版块列表：

![Django管理委员会名单](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list.png)

我们可以通过点击 **Add Board** 按钮添加一个新的版块：

![Django管理委员会添加](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-add.png)

点击 **SAVE** 按钮：

![Django管理委员会名单](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list-2.png)

我们可以检查一切是否正常，打开 **http://127.0.0.1:8000** URL：

![董事会主页](https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-3.png)

 * *

#### 结论

在本教程中，我们探讨了许多新概念。我们为我们的项目定义了一些要求，创建了第一个模型，迁移了数据库，开始玩 Models API。我们创建了第一个视图并编写了一些单元测试。我们还配置了 Django 模板引擎，静态文件，并将 Bootstrap 4 库添加到项目中。最后，我们简要介绍了 Django Admin 界面。


该项目的源代码在 GitHub 上,你可以在下面的链接中找到本章节的代码：

[https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw](https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw)

* 模块 包 类
** 使用模块
*** import module1[, module2[,... moduleN]
** 模块搜索路径   
   import sys
   print(sys.path)
** 导入某个模块中的属性和方法 from···import
   from modname import name1[, name2[, ... nameN]]
** 包
   每一个包目录下面都会有一个 `__init__.py` 的文件

   因为这个文件是必须的，否则，Python 就把这个目录当成普通目录，而不是一个包 。
   `__init__.py` 可以是空文件，也可以有Python代码，因为 `__init__.py` 本身就是一个
   模块，而它对应的模块名就是它的包名。
** 作用域
正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，ni12，PI等
`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途
`_xxx` 和 `__xxx` 这样的函数或变量就是非公开的（private），不应该被直接引用
* 模块列表
** math
   max()
   pow(100,	2) 平方
   sqrt  平方根
   e
** 文件
*** 键盘输入
**** : raw_input 函数
: raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
**** : input 函数
: input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个 Python 表达式作为输入，并将运算结果返回
*** 打开和关闭文件 
**** open 
**** close
**** write
**** read
**** 文件定位
**** 重命名和删除文件
**** remove()方法
*** 目录
**** mkdir()方法 
**** chdir()方法 
**** rmdir()方法 
** json
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
    pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
** enum
*** 枚举类的使用 
    #+begin_src python
      #!/usr/bin/env python3
      # -*- coding: UTF-8 -*-

      from enum import Enum

      Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

      # 遍历枚举类型
      for name, member in Month.__members__.items():
          print(name, '---------', member, '----------', member.value)

      # 直接引用一个常量
      print('\n', Month.Jan)
    #+end_src

***  Enum 的源码 
Enum 在模块 enum.py 中，先来看看 Enum 类的片段

#+begin_src python
 class Enum(metaclass=EnumMeta):
     """Generic enumeration.
     Derive from this class to define new enumerations.
     """
#+end_src

 可以看到，Enum 是继承元类 EnumMeta 的；再看看 EnumMeta 的相关片段

#+begin_src python
 class EnumMeta(type):
     """Metaclass for Enum"""
     @property
     def __members__(cls):
         """Returns a mapping of member name->value.
         This mapping lists all enum members, including aliases. Note that this
         is a read-only view of the internal mapping.
         """
         return MappingProxyType(cls._member_map_)
#+end_src
 首先 `__members__` 方法返回的是一个包含一个 Dict 既 Map 的 MappingProxyType，并
 且通过 @property 将方法 `__members__(cls)` 的访问方式改变为了变量的的形式，既可
 以直接通过 `__members__` 来进行访问了

** operator
   add()  
   sub()
   mul
   div
   concat
   operator.lt(a, b)
   operator.le(a, b)
   operator.eq(a, b)
   operator.ne(a, b)
   operator.__lt__(a, b)
   operator.__le__(a, b)
   operator.__eq__(a, b)
   operator.__ne__(a, b)
   operator.__ge__(a, b)
   operator.__gt__(a, b)
