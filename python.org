* 语言工具
** 编译器 python 
*** 功能选项
    | d     | 提供调试输出                               |
    | O     | 生成优化的字节码(生成 .pyo 文件)           |
    | S     | 不导入 site 模块以在启动时查找 Python 路径 |
    | v     | 冗余输出(导入语句详细追踪)                 |
    | m mod | 将一个模块以脚本形式运行                   |
    | c cmd | 执行 cmd 字符串脚本                        |
*** 环境变量
| PYTHONPATH    | 搜索路径，默认我们 import 的模块都会从 PYTHONPATH 里面寻找。                                      |
| PYTHONSTARTUP | Python 启动后，先寻找 PYTHONSTARTUP 环境变量，然后执行此文件中变量指定的执行代码。                |
| PYTHONCASEOK  | 加入 PYTHONCASEOK 的环境变量, 就会使 python 导入模块的时候不区分大小写.                           |
| PYTHONHOME    | 另一种模块搜索路径。它通常内嵌于的 PYTHONSTARTUP 或 PYTHONPATH 目录中，使得两个模块库更容易切换。 |
*** 国际化
    # -*- coding: UTF-8 -*- 
    # coding=utf-8
** 项目管理
** 包管理工具 
*** pip 
    安装 pip install requests
    查找 pip search xml
    明细 pip show beautifulsoup4
    卸载 pip uninstall requests
    国内源 pip install -i https://pypi.douban.com/simple virtualenv
** 虚拟环境 virtualenv
*** 创建虚拟环境
    创建 env 环境目录   virtualenv env
    创建目录，并选用 python3 的解释器 virtualenv -p /usr/local/bin/python3 venv
*** 启动虚拟环境 source ./bin/activate
    Virtualenv 附带有 pip 安装工具，因此需要安装的 packages 可以直接运行：
*** 退出虚拟环境 deactivate
*** 删除虚拟环境 rm -rf 
*** 虚拟环境管理工具 Virtualenvwrapper 
**** 创建虚拟机 mkvirtualenv env
**** 列出虚拟环境列表 workon 或者 lsvirtualenv
**** 启动/切换虚拟环境 workon [virtual-name]
**** 删除虚拟环境 rmvirtualenv  [virtual-name]
**** 离开虚拟环境 deactivate
* python
** 对象
*** 基本对象
    数量
    字符串 未加工字符串 r'{}<?>'
    列表  [ 'runoob', 786 , 2.23, 'john', 70.2 ]
    元组  ( 'runoob', 786 , 2.23, 'john', 70.2 )
    字典  {'name': 'john','code':6734, 'dept': 'sales'}
    空值 None
    集合 无序不重复元素集 set([1,3,4])
    bool  True False 
**** 对象之间转换
     | 将 字符串 x 转换为一个整数                                     | int(x [,base ])        |
     | 将 字符串 x 转换到一个浮点数                                   | float(x )              |
     | 创建一个复数                                          | complex(real [,imag ]) |
     | 将对象 x 转换为字符串                                 | str(x )                |
     | 将对象 x 转换为表达式字符串                           | repr(x )               |
     | 用来计算在字符串中的有效 Python 表达式,并返回一个对象 | eval(str )             |
     | 将序列 s 转换为一个元组                               | tuple(s )              |
     | 将序列 s 转换为一个列表                               | list(s )               |
     | 将一个整数转换为一个字符                              | chr(x )                |
     | 将一个整数转换为 Unicode 字符                         | unichr(x )             |
     | 将一个字符转换为它的整数值                            | ord(x )                |
     | 将一个整数转换为一个十六进制字符串                    | hex(x )                |
     | 将一个整数转换为一个八进制字符串                      | oct(x )                |
**** 对象属性 
     对象的长度  len(obj), 整数没有长度
    
     间隔选择
     foostr = 'abcde'
     foostr[::-1]
*** 模块(对象包)
    !模块名(文件名) 与 类名 相同 
**** 导入模块 import 
     import module1[, module2[,... moduleN]
**** 导入属性和方法 From…import 
**** 主模块和非主模块 
     如果一个函数调用了其他函数完成一项功能，我们称这个函数为主函数，如果一个函
     数没有调用其他函数，我们称这种函数为非主函数
     
     主模块和非主模块的定义也类似，如果一个模块被直接使用，而没有被别人调用，我
     们称这个模块为主模块，如果一个模块被别人调用，我们称这个模块为非主模块。
***** 区分  通过模块的__name__ 
**** 作用域
     正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，ni12，PI 等
     `__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途
     `_xxx` 和 `__xxx` 这样的函数或变量就是非公开的（private），不应该被直接引用
**** globals()和 locals()函数
     : 根据调用地方的不同，globals()和 locals()函数可被用来返回全局和局部命名空间里的名字。
**** reload()函数
     : 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
     : 因此，如果你想重新执行模块里顶层部分的代码，可以用 reload()函数
**** 完成模块
***** 定义用于模块的错误和异常
      #+BEGIN_SRC python
        class sendException(Exception):
              pass
      #+END_SRC
***** 定义模块中要输出的项 
      from module import classname/functionname
      __all__ 中确定的 或是 除去_ 开头的 是公有的
***** 编写文档
      '''items'''
***** 测试, 写好注释, 执行方法
***** 提供调用的回退函数
***** 安装模块     
      通常在 sys.path 的 site-packages 目录下
*** 包 一个包几个类
    使用操作系统原有的目录结构、包是一个目录、如 Hello, 然后在里面创建__init__.py
    文件，该文件提示该目录是包目录在目录下创建类，类名同文件名要相同，默认只执行
    __init__.py 文件，需要在里面 用 from 文件 import 同文件名同的类名就可以在调
    用的源码中 import 包名 了
   
    实例化 时 是 包名+类名
**** 测试模块和包
     if __name== '__main__'
     __name__是 模块或包名的变量, __main__ 用来测试模块中的方法 
*** 类
**** 类  
***** 定义类 
      #+begin_src python
        class ClassName:
            <statement-1>
            .
            .
            .
            <statement-N>
      #+end_src
***** 类的构造函数如下：
      #+begin_src python
        def __init__(self,[...):
      #+end_src

      类定义了 __init__() 方法的话，类的实例化操作会自动调用 __init__() 方法。
***** 析构函数语法如下：
      #+begin_src python
        def __del__(self,[...):

      #+end_src

      仔细观察的童鞋都会发现，类的方法与普通的函数有一个特别的区别，它们必须有一个额外
      的第一个参数名称, 按照惯例它的名称是 self。

      那么这个 self 代表什么呢？

      我们可以看下实例，通过实例来找出答案：

      #+begin_src python
        #!/usr/bin/env python3
        # -*- coding: UTF-8 -*-

        class Test:
            def prt(self):
                print(self)
                print(self.__class__)

        t = Test()
        t.prt()
      #+end_src
      观察输出的结果：

      <__main__.Test instance at 0x7f1fbec55638>
      __main__.Test


      self 代表的是类的实例，输出的是当前对象的地址，
      而 `self.__class__` 则指向类。

      当然 self 不是 python 关键字，也就是说我们把他换成其他的字符也是可以正常执行的。
      只不过我们习惯使用 self
***** Python 定义类的历史遗留问题 
      Python 在版本的迭代中，有一个关于类的历史遗留问题，就是新式类和旧式类的问题，具
      体先看以下的代码：

      #+begin_src python
        #!/usr/bin/env python
        # -*- coding: UTF-8 -*-

        # 旧式类
        class OldClass:
            pass

        # 新式类
        class NewClass(object):
            pass

      #+end_src

      可以看到，这里使用了两者中不同的方式定义类，可以看到最大的不同就是，新式类继承了
      `object` 类，在 Python2 中，我们定义类的时候最好定义新式类，当然在 Python3 中不
      存在这个问题了，因为 Python3 中所有类都是新式类。

      那么新式类和旧式类有什么区别呢？

      运行下下面的那段代码：

      #+begin_src python
        #!/usr/bin/env python
        # -*- coding: UTF-8 -*-

        # 旧式类
        class OldClass:
            def __init__(self, account, name):
                self.account = account;
                self.name = name;


        # 新式类
        class NewClass(object):
            def __init__(self, account, name):
                self.account = account;
                self.name = name;


        if __name__ == '__main__':
            old_class = OldClass(111111, 'OldClass')
            print(old_class)
            print(type(old_class))
            print(dir(old_class))
            print('\n')
            new_class=NewClass(222222,'NewClass')
            print(new_class)
            print(type(new_class))
            print(dir(new_class))

      #+end_src

      仔细观察输出的结果，对比一下，就能观察出来，注意喔，Pyhton3 中输出的结果是一模一
      样的，因为 Python3 中没有新式类旧式类的问题。
**** 类的属性 
***** 直接在类中定义属性
      定义类的属性，当然最简单最直接的就是在类中定义，例如：
      
      #+begin_src python
        class UserInfo(object):
            name='两点水'

      #+end_src
***** 在构造函数中定义属性 
      故名思议，就是在构造对象的时候，对属性进行定义。

      #+begin_src python
        class UserInfo(object):
            def __init__(self,name):
                self.name=name
      #+end_src
***** 属性的访问控制
      在 Java 中，有 public（公共）属性 和 private（私有）属性，这可以对属性进行访问
      控制。那么在 Python 中有没有属性的访问控制呢？

      一般情况下，我们会使用 `__private_attrs` 两个下划线开头，声明该属性为私有，不能
      在类地外部被使用或直接访问。在类内部的方法中使用时 `self.__private_attrs`。

      为什么只能说一般情况下呢？因为实际上，Python 中是没有提供私有属性等功能的。但是
      Python 对属性的访问控制是靠程序员自觉的。

      #+begin_src python

        #!/usr/bin/env python
        # -*- coding: UTF-8 -*-

        class UserInfo(object):
            def __init__(self, name, age, account):
                self.name = name
                self._age = age
                self.__account = account

            def get_account(self):
                return self.__account


        if __name__ == '__main__':
            userInfo = UserInfo('两点水', 23, 347073565);
            # 打印所有属性
            print(dir(userInfo))
            # 打印构造函数中的属性
            print(userInfo.__dict__)
            print(userInfo.get_account())
            # 用于验证双下划线是否是真正的私有属性
            print(userInfo._UserInfo__account)

      #+end_src
**** 类的方法 

     ## 1、类专有的方法 ##

     一个类创建的时候，就会包含一些方法，主要有以下方法：

     类的专有方法：

     | 方法 | 说明 |
     | ------| ------ |
     |`__init__` |构造函数，在生成对象时调用|
     |`__del__ `| 析构函数，释放对象时使用|
     |`__repr__ `| 打印，转换|
     |`__setitem__ `| 按照索引赋值|
     |`__getitem__`| 按照索引获取值|
     |`__len__`| 获得长度|
     |`__cmp__`| 比较运算|
     |`__call__`| 函数调用|
     |`__add__`| 加运算|
     |`__sub__`| 减运算|
     |`__mul__`|乘运算|
     |`__div__`| 除运算|
     |`__mod__`| 求余运算|
     |`__pow__`|乘方|

     当然有些时候我们需要获取类的相关信息，我们可以使用如下的方法：

     * `type(obj)`：来获取对象的相应类型；
     * `isinstance(obj, type)`：判断对象是否为指定的 type 类型的实例；
     * `hasattr(obj, attr)`：判断对象是否具有指定属性/方法；
     * `getattr(obj, attr[, default])` 获取属性/方法的值, 要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出 AttributeError 异常；
     * `setattr(obj, attr, value)`：设定该属性/方法的值，类似于 obj.attr=value；
     * `dir(obj)`：可以获取相应对象的所有属性和方法名的列表：

     ## 2、方法的访问控制 ##

     其实我们也可以把方法看成是类的属性的，那么方法的访问控制也是跟属性是一样的，也是没有实质上的私有方法。一切都是靠程序员自觉遵守 Python 的编程规范。

     示例如下，具体规则也是跟属性一样的，

     ```python
     #!/usr/bin/env python
     # -*- coding: UTF-8 -*-

     class User(object):
     def upgrade(self):
     pass

     def _buy_equipment(self):
     pass

     def __pk(self):
     pass

     ```

     ## 3、方法的装饰器 ##


     * **@classmethod**
     调用的时候直接使用类名类调用，而不是某个对象

     * **@property**
     可以像访问属性一样调用方法

     具体的使用看下实例：

     ```python
     #!/usr/bin/env python
     # -*- coding: UTF-8 -*-

     class UserInfo(object):
     lv = 5

     def __init__(self, name, age, account):
     self.name = name
     self._age = age
     self.__account = account

     def get_account(self):
     return self.__account

     @classmethod
     def get_name(cls):
     return cls.lv

     @property
     def get_age(self):
     return self._age


     if __name__ == '__main__':
     userInfo = UserInfo('两点水', 23, 347073565);
     # 打印所有属性
     print(dir(userInfo))
     # 打印构造函数中的属性
     print(userInfo.__dict__)
     # 直接使用类名类调用，而不是某个对象
     print(UserInfo.lv)
     # 像访问属性一样调用方法（注意看 get_age 是没有括号的）
     print(userInfo.get_age)
     ```

     运行的结果：

     ![Python 方法的装饰器](http://upload-images.jianshu.io/upload_images/2136918-63dc478a8b2f965f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 
**** class
     类中方法定义 必须带 self
     #+BEGIN_SRC python
       class wa:
        def __init__(self, items={}):
         '''items'''
            if type(item)!=type({}):
                raise TypeError("类型错误")
               self.items=items
            return
           def	deposit(self,	amount):
            self.balance	=	self.balance	+	amount
            return	self.balance
           def	withdraw(self,	amount):
            if	amount	>	self.balance:
             return	'Insufficient	funds'
     #+END_SRC
**** 类的继承

     ## 1、定义类的继承 ##

     首先我们来看下类的继承的基本语法：

     ```python
     class ClassName(BaseClassName):
     <statement-1>
     .
     .
     .
     <statement-N>
     ```

     在定义类的时候，可以在括号里写继承的类，一开始也提到过，如果不用继承类的时候，也要写继承 object 类，因为在 Python 中 object 类是一切类的父类。

     当然上面的是单继承，Python 也是支持多继承的，具体的语法如下：

     ```python
     class ClassName(Base1,Base2,Base3):
     <statement-1>
     .
     .
     .
     <statement-N>
     ```

     多继承有一点需要注意的：若是父类中有相同的方法名，而在子类使用时未指定，python 在圆括号中父类的顺序，从左至右搜索 ， 即方法在子类中未找到时，从左到右查找父类中是否包含方法。

     那么继承的子类可以干什么呢？

     继承的子类的好处：
     * 会继承父类的属性和方法
     * 可以自己定义，覆盖父类的属性和方法

     ## 2、调用父类的方法 ##

     一个类继承了父类后，可以直接调用父类的方法的，比如下面的例子，`UserInfo2` 继承自父类 `UserInfo` ，可以直接调用父类的  `get_account` 方法。

     ```python
     #!/usr/bin/env python
     # -*- coding: UTF-8 -*-

     class UserInfo(object):
     lv = 5

     def __init__(self, name, age, account):
     self.name = name
     self._age = age
     self.__account = account

     def get_account(self):
     return self.__account


     class UserInfo2(UserInfo):
     pass


     if __name__ == '__main__':
     userInfo2 = UserInfo2('两点水', 23, 347073565);
     print(userInfo2.get_account())

     ```

     ## 3、父类方法的重写 ##

     当然，也可以重写父类的方法。

     示例：

     ```python
     #!/usr/bin/env python3
     # -*- coding: UTF-8 -*-

     class UserInfo(object):
     lv = 5

     def __init__(self, name, age, account):
     self.name = name
     self._age = age
     self.__account = account

     def get_account(self):
     return self.__account

     @classmethod
     def get_name(cls):
     return cls.lv

     @property
     def get_age(self):
     return self._age


     class UserInfo2(UserInfo):
     def __init__(self, name, age, account, sex):
     super(UserInfo2, self).__init__(name, age, account)
     self.sex = sex;


     if __name__ == '__main__':
     userInfo2 = UserInfo2('两点水', 23, 347073565, '男');
     # 打印所有属性
     print(dir(userInfo2))
     # 打印构造函数中的属性
     print(userInfo2.__dict__)
     print(UserInfo2.get_name())

     ```

     最后打印的结果：

     ![Python 类的继承](http://upload-images.jianshu.io/upload_images/2136918-aa2701fc5913a8a6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

     这里就是重写了父类的构造函数。


     ## 3、子类的类型判断 ##

     对于 class 的继承关系来说，有些时候我们需要判断 class 的类型，该怎么办呢？

     可以使用 `isinstance()` 函数,

     一个例子就能看懂 `isinstance()` 函数的用法了。

     ```python
     #!/usr/bin/env python3
     # -*- coding: UTF-8 -*-

     class User1(object):
     pass


     class User2(User1):
     pass


     class User3(User2):
     pass


     if __name__ == '__main__':
     user1 = User1()
     user2 = User2()
     user3 = User3()
     # isinstance()就可以告诉我们，一个对象是否是某种类型
     print(isinstance(user3, User2))
     print(isinstance(user3, User1))
     print(isinstance(user3, User3))
     # 基本类型也可以用 isinstance()判断
     print(isinstance('两点水', str))
     print(isinstance(347073565, int))
     print(isinstance(347073565, str))

     ```

     输出的结果如下：

     ```txt
     True
     True
     True
     True
     True
     False
     ```

     可以看到 `isinstance()` 不仅可以告诉我们，一个对象是否是某种类型，也可以用于基本类型的判断。

**** 类的继承
     #+BEGIN_SRC python
       class Subclass(Parentclass):
              def __init__(self):
                     Parentclass.__init__

     #+END_SRC
**** 类属性与方法
***** 类的私有属性
      __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
      类的方法
      在类地内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数
***** 类的私有方法
      __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
**** type 函数
**** 类的多态

     多态的概念其实不难理解，它是指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。

     事实上，我们经常用到多态的性质，比如：

     ```
     >>> 1 + 2
     3
     >>> 'a' + 'b'
     'ab'
     ```

     可以看到，我们对两个整数进行 + 操作，会返回它们的和，对两个字符进行相同的 + 操作，会返回拼接后的字符串。也就是说，不同类型的对象对同一消息会作出不同的响应。


     看下面的实例，来了解多态：


     ```python
     #!/usr/bin/env python3
     # -*- coding: UTF-8 -*-

     class User(object):
     def __init__(self, name):
     self.name = name

     def printUser(self):
     print('Hello !' + self.name)


     class UserVip(User):
     def printUser(self):
     print('Hello ! 尊敬的 Vip 用户：' + self.name)


     class UserGeneral(User):
     def printUser(self):
     print('Hello ! 尊敬的用户：' + self.name)


     def printUserInfo(user):
     user.printUser()


     if __name__ == '__main__':
     userVip = UserVip('两点水')
     printUserInfo(userVip)
     userGeneral = UserGeneral('水水水')
     printUserInfo(userGeneral)

     ```

     输出的结果:

     ```txt
     Hello ! 尊敬的 Vip 用户：两点水
     Hello ! 尊敬的用户：水水水
     ```

     可以看到，userVip 和 userGeneral 是两个不同的对象，对它们调用 printUserInfo 方法，它们会自动调用实际类型的 printUser 方法，作出不同的响应。这就是多态的魅力。

     要注意喔，有了继承，才有了多态，也会有不同类的对象对同一消息会作出不同的相应。

** 对象操作 
*** 自定义操作 函数 
**** 定义函数
     #+BEGIN_SRC python
       def functionname( parameters ):
           "函数_文档字符串"
           function_suite
           return [expression]
     #+END_SRC
**** 返回多个值 return b , a
**** 不定长参数(参数长度可变)
     #+begin_src python
       # -*- coding: UTF-8 -*-
       def print_user_info( name ,  age  , sex = '男' , * hobby):
           # 打印用户信息
           print('昵称：{}'.format(name) , end = ' ')
           print('年龄：{}'.format(age) , end = ' ')
           print('性别：{}'.format(sex) ,end = ' ' )
           print('爱好：{}'.format(hobby))
           return;

       # 调用 print_user_info 函数
       print_user_info( '两点水' ,18 , '女', '打篮球','打羽毛球','跑步')
     #+end_src
**** 关键字参数 不用关心参数列表定义时的顺序
     #+begin_src python
       # -*- coding: UTF-8 -*-

       def print_user_info( name ,  age  , sex = '男' ):
           # 打印用户信息
           print('昵称：{}'.format(name))
           print('年龄：{}'.format(age) )
           print('性别：{}'.format(sex))
           return;

       # 调用 print_user_info 函数
       print_user_info( name = '两点水' ,age = 18 , sex = '女')
       print_user_info( name = '两点水' ,sex = '女', age = 18 )

     #+end_src

**** 只接受关键字参数 (有错误！！）
     将强制关键字参数放到某个`*`参数或者单个`*`后面就能达到这种效果
     #+begin_src python
       # -*- coding: UTF-8 -*-

       def print_user_info( name , *, age  , sex = '男' ):
           # 打印用户信息
           print('昵称：{}'.format(name) , end = ' ')
           print('年龄：{}'.format(age) , end = ' ')
           print('性别：{}'.format(sex))
           return;

       # 调用 print_user_info 函数
       print_user_info( name = '两点水' ,age = 18 , sex = '女' )

       # 这种写法会报错，因为 age，sex 这两个参数强制使用关键字参数
       #print_user_info( '两点水' , 18 , '女' )

       print_user_info('两点水',age='22',sex='男')
     #+end_src

**** 匿名函数 lambda (没名字的函数,那种函数使用时临时创建下)
     #+begin_src python
       lambda [arg1 [,arg2,.....argn]]:expression
     #+end_src
     
     #+begin_src python
       # -*- coding: UTF-8 -*-

       sum = lambda num1 , num2 : num1 + num2;
       print( sum( 1 , 2 ) )
     #+end_src

*** 迭代器对象
    ! 我测试了，数组元组不能用 next 方法，创建的也不是迭代器，但他们本身是能迭代的
     
    迭代器有两个基本的方法：iter() 和 next(),且字符串，列表或元组对象都可用于创
    建迭代器，迭代器对象可以使用常规 for 语句进行遍历，也可以使用 next() 函数来
    遍历。
**** 从数组对象创建迭代对象 
     #+BEGIN_SRC python
       # 1、字符创创建迭代器对象
       str1 = 'liangdianshui'
       iter1 = iter ( str1 )

       # 2、list 对象创建迭代器,有问题
       list1 = [1,2,3,4]
       iter2 = iter ( list1 )

       # 3、tuple(元祖) 对象创建迭代器,有问题
       tuple1 = ( 1,2,3,4 )
       iter3 = iter ( tuple1 )

       # for 循环遍历迭代器对象
       for x in iter1 :
           print ( x , end = ' ' )

       print('\n------------------------')

       # next() 函数遍历迭代器
       while True :
           try :
               print ( next ( iter3 ) )
           except StopIteration :
               break

     #+END_SRC
**** 迭代对象生成式生成列表
     首先，lsit 生成式的语法为：

     #+begin_src python
       [expr for iter_var in iterable] 
       [expr for iter_var in iterable if cond_expr]
     #+end_src
     第一种语法：首先迭代 iterable 里所有内容，每一次迭代，都把 iterable 里相应
     内容放到 iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计
     算值生成一个列表。

     第二种语法：加入了判断语句，只有满足条件的内容才把 iterable 里相应内容放到
     iter_var 中，再在表达式中应用该 iter_var 的内容，最后用表达式的计算值生成一
     个列表。

     其实不难理解的，因为是 list 生成式，因此肯定是用 [] 括起来的，然后里面的语
     句是把要生成的元素放在前面，后面加 for 循环语句或者 for 循环语句和判断语句。

     例子：

     #+begin_src python
       # -*- coding: UTF-8 -*-
       lsit1=[x * x for x in range(1, 11)]
       print(lsit1)
     #+end_src

     输出的结果：
     [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

     可以看到，就是把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list
     创建出来。那么 for 循环后面有 if 的形式呢？又该如何理解：

     #+begin_src python
       # -*- coding: UTF-8 -*-
       lsit1= [x * x for x in range(1, 11) if x % 2 == 0]
       print(lsit1)
     #+end_src

     输出的结果：
     [4, 16, 36, 64, 100]

     这个例子是为了求 1 到 10 中偶数的平方根，上面也说到， `x * x` 是要生成的元
     素，后面那部分其实就是在 for 循环中嵌套了一个 if 判断语句。

     那么有了这个知识点，我们也可以猜想出，for 循环里面也嵌套 for 循环。具体示例：

     #+begin_src python
       # -*- coding: UTF-8 -*-
       lsit1= [(x+1,y+1) for x in range(3) for y in range(5)] 
       print(lsit1)
     #+end_src
     
     输出的结果：

     [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)]

     其实知道了 list 生成式是怎样组合的，就不难理解这个东西了。因为 list 生成式
     只是把之前学习的知识点进行了组合，换成了一种更简洁的写法而已。
*** 生成器对象 只能对其迭代一次??
**** 为什么需要生成器

     通过上面的学习，可以知道列表生成式，我们可以直接创建一个列表。但是，受到内
     存限制，列表容量肯定是有限的。而且，创建一个包含 1000 万个元素的列表，不仅
     占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占
     用的空间都白白浪费了。

     所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不
     断推算出后续的元素呢？这样就不必创建完整的 list，从而节省大量的空间。在
     Python 中，这种一边循环一边计算的机制，称为生成器：generator。

     在 Python 中，使用了 yield 的函数被称为生成器（generator）。

     跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点
     理解生成器就是一个迭代器。

     在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信
     息，返回 yield 的值。并在下一次执行 next()方法时从当前位置继续运行。

     那么如何创建一个生成器呢？
**** 生成器的创建
     最简单最简单的方法就是把一个列表生成式的 `[]` 改成 `()`
    
     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       gen= (x * x for x in range(10))
       print(gen)
     #+END_SRC
      
     输出的结果：
     <generator object <genexpr> at 0x0000000002734A40>

     创建 List 和 generator 的区别仅在于最外层的 `[]` 和 `()` 。但是生成器并不真
     正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这
     个条目“产生” ( yield ) 出来。 生成器表达式使用了“惰性计算” ( lazy
     evaluation，也有翻译为“延迟求值”，我以为这种按需调用(  call by need ) 的方式翻
     译为惰性更好一些)，只有在检索时才被赋值（evaluated），所以在列表比较长的情况
     下使用内存上更有效。
     那么竟然知道了如何创建一个生成器，那么怎么查看里面的元素呢？
**** 遍历生成器的元素 
     按我们的思维，遍历用 for 循环，对了，我们可以试试：

     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       gen= (x * x for x in range(10))

       for num  in  gen :
           print(num)
     #+END_SRC

     没错，直接这样就可以遍历出来了。当然，上面也提到了迭代器，那么用 next() 可以
     遍历吗？当然也是可以的。
    
     #+BEGIN_SRC python
       while True:
           try:
               print next(gen)
           except StopIteration:
               break

     #+END_SRC
**** 以函数的形式实现生成器 
     上面也提到，创建生成器最简单最简单的方法就是把一个列表生成式的 `[]` 改成
     `()`。为啥突然来个以函数的形式来创建呢？

     其实生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的
     值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循
     环，要么将它们传递给任意可以进行迭代的函数和结构。而且实际运用中，大多数的生
     成器都是通过函数来实现的。那么我们该如何通过函数来创建呢？

     先不急，来看下这个例子：

     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       def my_function():
       for i in range(10):
           print ( i )

       my_function()

     #+END_SRC
     输出的结果：

     ```txt
     0
     1
     2
     3
     4
     5
     6
     7
     8
     9
     ```

     如果我们需要把它变成生成器，我们只需要把 `print ( i )` 改为 `yield i` 就可以
     了，具体看下修改后的例子：

     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       def my_function():
       for i in range(10):
           yield i

       print(my_function())
     #+END_SRC

     输出的结果：

     ```txt
     <generator object my_function at 0x0000000002534A40>
     ```

     但是，这个例子非常不适合使用生成器，发挥不出生成器的特点，生成器的最好的应用
     应该是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集
     里还包含循环。因为这样会耗很大的资源。

     比如下面是一个计算斐波那契数列的生成器：

     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       def fibon(n):
           a = b = 1
       for i in range(n):
           yield a
           a, b = b, a + b

       # 引用函数
       for x in fibon(1000000):
           print(x , end = ' ')
     #+END_SRC

     你看，运行一个这么打的参数，也不会说有卡死的状态，因为这种方式不会使用太大的
     资源。这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，
     遇到 return 语句或者最后一行函数语句就返回。而变成 generator 的函数，在每次
     调用 next() 的时候执行，遇到 yield 语句返回，再次执行时从上次返回的 yield 语
     句处继续执行。

     比如这个例子：
     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       def odd():
           print ( 'step 1' )
           yield ( 1 )
           print ( 'step 2' )
           yield ( 3 )
           print ( 'step 3' )
           yield ( 5 )

       o = odd()
       print( next( o ) )
       print( next( o ) )
       print( next( o ) )
     #+END_SRC

     输出的结果：

     ```txt
     step 1
     1
     step 2
     3
     step 3
     5
     ```

     可以看到，odd 不是普通函数，而是 generator，在执行过程中，遇到 yield 就中断，
     下次又继续执行。执行 3 次 yield 后，已经没有 yield 可以执行了，如果你继续打
     印 `print( next( o ) ) ` ,就会报错的。所以通常在 generator 函数中都要对错误
     进行捕获。
**** 打印杨辉三角 

     通过学习了生成器，我们可以直接利用生成器的知识点来打印杨辉三角：

     #+BEGIN_SRC python
       # -*- coding: UTF-8 -*-
       def triangles( n ):         # 杨辉三角形
           L = [1]
       while True:
           yield L
           L.append(0)
           L = [ L [ i -1 ] + L [ i ] for i in range (len(L))]

       n= 0
       for t in triangles( 10 ):   # 直接修改函数名即可运行
           print(t)
           n = n + 1
       if n == 10:
       break
     #+END_SRC
    
     输出的结果为：

     ```txt
     [1]
     [1, 1]
     [1, 2, 1]
     [1, 3, 3, 1]
     [1, 4, 6, 4, 1]
     [1, 5, 10, 10, 5, 1]
     [1, 6, 15, 20, 15, 6, 1]
     [1, 7, 21, 35, 35, 21, 7, 1]
     [1, 8, 28, 56, 70, 56, 28, 8, 1]
     [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
     ```
**** 迭代器和生成器综合例子 

     因为迭代器和生成器基本是互通的，因此有些知识点需要综合在一起

     ## 1、反向迭代 ##

     反向迭代，应该也是常有的需求了，比如从一开始迭代的例子里，有个输出 list 的元素，从 1 到 5 的

     ```python
     list1 = [1,2,3,4,5]
     for num1 in list1 :
     print ( num1 , end = ' ' )
     ```

     那么我们从 5 到 1 呢？这也很简单，Python 中有内置的函数 `reversed()`

     ```python
     list1 = [1,2,3,4,5]
     for num1 in reversed(list1) :
     print ( num1 , end = ' ' )
     ```

     方向迭代很简单，可是要注意一点就是：**反向迭代仅仅当对象的大小可预先确定或者对象实现了 `__reversed__()` 的特殊方法时才能生效。 如果两者都不符合，那你必须先将对象转换为一个列表才行**

     其实很多时候我们可以通过在自定义类上实现 `__reversed__()` 方法来实现反向迭代。不过有些知识点在之前的篇节中还没有提到，不过可以相应的看下，有编程基础的，学完上面的知识点应该也能理解的。

     ```python
     # -*- coding: UTF-8 -*-

     class Countdown:
     def __init__(self, start):
     self.start = start

     def __iter__(self):
     # Forward iterator
     n = self.start
     while n > 0:
     yield n
     n -= 1

     def __reversed__(self):
     # Reverse iterator
     n = 1
     while n <= self.start:
     yield n
     n += 1

     for rr in reversed(Countdown(30)):
     print(rr)
     for rr in Countdown(30):
     print(rr)
     ```

     输出的结果是 1 到 30 然后 30 到 1，分别是顺序打印和倒序打印

     ## 2、同时迭代多个序列 ##

     你想同时迭代多个序列，每次分别从一个序列中取一个元素。你遇到过这样的需求吗？

     为了同时迭代多个序列，使用 zip() 函数，具体示例：

     ```python
     # -*- coding: UTF-8 -*-

     names = ['laingdianshui', 'twowater', '两点水']
     ages = [18, 19, 20]
     for name, age in zip(names, ages):
     print(name,age)
     ```

     输出的结果：

     ```txt
     laingdianshui 18
     twowater 19
     两点水 20
     ```

     其实 zip(a, b) 会生成一个可返回元组 (x, y) 的迭代器，其中 x 来自 a，y 来自 b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。注意理解这句话喔，也就是说如果 a，b 的长度不一致的话，以最短的为标准，遍历完后就结束。

     利用 `zip()` 函数，我们还可把一个 key 列表和一个 value 列表生成一个 dict（字典）,如下：

     ```python
     # -*- coding: UTF-8 -*-

     names = ['laingdianshui', 'twowater', '两点水']
     ages = [18, 19, 20]

     dict1= dict(zip(names,ages))

     print(dict1)

     ```


     输出如下结果：

     ```python
     {'laingdianshui': 18, 'twowater': 19, '两点水': 20}
     ```

     这里提一下， `zip()` 是可以接受多于两个的序列的参数，不仅仅是两个。

*** 数学对象运算符
**** 算术运算符
     **	幂 - 返回 x 的 y 次幂
     //	取整除 - 返回商的整数部分	
*** 数据类型转换 
    | 方法                   | 说明                                                  |
    |------------------------+-------------------------------------------------------|
    | int(x [,base ])        | 将 x 转换为一个整数                                     |
    | float(x )              | 将 x 转换到一个浮点数                                   |
    | complex(real [,imag ]) | 创建一个复数                                          |
    | str(x )                | 将对象 x 转换为字符串                                 |
    | repr(x )               | 将对象 x 转换为表达式字符串                           |
    | eval(str )             | 用来计算在字符串中的有效 Python 表达式,并返回一个对象 |
    | tuple(s )              | 将序列 s 转换为一个元组                               |
    | list(s )               | 将序列 s 转换为一个列表                               |
    | chr(x )                | 将一个整数转换为一个字符                              |
    | unichr(x )             | 将一个整数转换为 Unicode 字符                         |
    | ord(x )                | 将一个字符转换为它的整数值                            |
    | hex(x )                | 将一个整数转换为一个十六进制字符串                    |
    | oct(x )                | 将一个整数转换为一个八进制字符串                      |
** 流程控制
   if 分支
   #+BEGIN_SRC python
     if condition：
     cmd
     else：
     cmd

   #+END_SRC

   while 循环
   #+BEGIN_SRC 

while 判断条件：
    执行语句……

   #+END_SRC
   for 循环
   #+BEGIN_SRC python

     for iterating_var in sequence:
        statements(s)
   #+END_SRC

   循环控制
   break
   continue
   assert(3>4) 断言, 产生此种情况会中断

** 帮助
   help()  函数或类文档字串说明
   dir() 函数或类的性质
** 对象监控(异常处理)
*** 捕捉异常可以使用 try/except 语句
    #+BEGIN_SRC python
      try:
          <语句>        #运行别的代码
      except <名字>：
      <语句>        #如果在 try 部份引发了'name'异常
      except <名字>，<数据>:
          <语句>        #如果引发了'name'异常，获得附加的数据
      else:
          <语句>        #如果没有异常发生
    #+END_SRC
*** 触发异常
    : raise [Exception [, args [, traceback]]]
** 进程  
*** 线程与进程 
  多任务的实现有 3 种方式：

    多进程模式；
    多线程模式；
    多进程+多线程模式。

  同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，
  任务 1 必须暂停等待任务 2 完成后才能继续执行，有时，任务 3 和任务 4 又不能同时执
  行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。
*** 进程
  Python 中的多线程其实并不是真正的多线程，如果想要充分地使用多核 CPU 的资源，在
  Python 中大部分情况需要使用多进程。Python 提供了非常好用的多进程包
  multiprocessing，只需要定义一个函数，Python 会完成其他所有事情。借助这个包，可以
  轻松完成从单进程到并发执行的转换。multiprocessing 支持子进程、通信和共享数据、执
  行不同形式的同步，提供了 Process、Queue、Pipe、Lock 等组件。
**** 类 Process
*****  创建进程的类：`Process([group [, target [, name [, args [, kwargs]]]]])`
      target 表示调用对象
      args 表示调用对象的位置参数元组
      kwargs 表示调用对象的字典
      name 为别名
      group 实质上不使用

    下面看一个创建函数并将其作为多个进程的例子：
  #+begin_src python

    #!/usr/bin/env python3
    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    def worker(interval, name):
        print(name + '【start】')
        time.sleep(interval)
        print(name + '【end】')


    if __name__ == "__main__":
        p1 = multiprocessing.Process(target=worker, args=(2, '两点水 1'))
        p2 = multiprocessing.Process(target=worker, args=(3, '两点水 2'))
        p3 = multiprocessing.Process(target=worker, args=(4, '两点水 3'))

        p1.start()
        p2.start()
        p3.start()

        print("The number of CPU is:" + str(multiprocessing.cpu_count()))
        for p in multiprocessing.active_children():
            print("child   p.name:" + p.name + "\tp.id" + str(p.pid))
        print("END!!!!!!!!!!!!!!!!!")

  #+end_src
***** 把进程创建成类

    当然我们也可以把进程创建成一个类，如下面的例子，当进程 p 调用 start() 时，自动调用 run() 方法。

  #+begin_src python

    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    class ClockProcess(multiprocessing.Process):
        def __init__(self, interval):
            multiprocessing.Process.__init__(self)
            self.interval = interval

        def run(self):
            n = 5
            while n > 0:
                print("当前时间: {0}".format(time.ctime()))
                time.sleep(self.interval)
                n -= 1


    if __name__ == '__main__':
        p = ClockProcess(3)
        p.start()

  #+end_src
***** daemon 属性

    想知道 daemon 属性有什么用，看下下面两个例子吧，一个加了 daemon 属性，一个没有加，对比输出的结果：

    没有加 deamon 属性的例子：

  #+begin_src python
    # -*- coding: UTF-8 -*-
    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.start()
        print('【EMD】')

  #+end_src
    输出结果：

    ```txt
    【EMD】
    工作开始时间：Mon Oct  9 17:47:06 2017
    工作结果时间：Mon Oct  9 17:47:09 2017
    ```

    在上面示例中，进程 p 添加 daemon 属性：

    ```python
    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.daemon = True
        p.start()
        print('【EMD】')
    ```

    输出结果：

    ```txt
    【EMD】
    ```


    根据输出结果可见，如果在子进程中添加了 daemon 属性，那么当主进程结束的时候，子
    进程也会跟着结束。所以没有打印子进程的信息。
***** join 方法

    结合上面的例子继续，如果我们想要让子线程执行完该怎么做呢？

    那么我们可以用到 join 方法，join 方法的主要作用是：阻塞当前进程，直到调用 join 方法的那个进程执行完，再继续执行当前进程。

    因此看下加了 join 方法的例子：

  #+begin_src python
    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.daemon = True
        p.start()
        p.join()
        print('【EMD】')
  #+end_src
    输出的结果：

    ```txt
    工作开始时间：Tue Oct 10 11:30:08 2017
    工作结果时间：Tue Oct 10 11:30:11 2017
    【EMD】
    ```
***** Pool

    如果需要很多的子进程，难道我们需要一个一个的去创建吗？

    当然不用，我们可以使用进程池的方法批量创建子进程。

    例子如下：

    ```python
    # -*- coding: UTF-8 -*-

    from multiprocessing import Pool
    import os, time, random


    def long_time_task(name):
        print('进程的名称：{0} ；进程的 PID: {1} '.format(name, os.getpid()))
        start = time.time()
        time.sleep(random.random() * 3)
        end = time.time()
        print('进程 {0} 运行了 {1} 秒'.format(name, (end - start)))


    if __name__ == '__main__':
        print('主进程的 PID：{0}'.format(os.getpid()))
        p = Pool(4)
        for i in range(6):
            p.apply_async(long_time_task, args=(i,))
        p.close()
        # 等待所有子进程结束后在关闭主进程
        p.join()
        print('【End】')
    ```

    输出的结果如下：

    ```txt
    主进程的 PID：7256
    进程的名称：0；进程的 PID: 1492
    进程的名称：1；进程的 PID: 12232
    进程的名称：2；进程的 PID: 4332
    进程的名称：3；进程的 PID: 11604
    进程 2 运行了 0.6500370502471924 秒
    进程的名称：4；进程的 PID: 4332
    进程 1 运行了 1.0830621719360352 秒
    进程的名称：5；进程的 PID: 12232
    进程 5 运行了 0.029001712799072266 秒
    进程 4 运行了 0.9720554351806641 秒
    进程 0 运行了 2.3181326389312744 秒
    进程 3 运行了 2.5331451892852783 秒
    【End】
    ```

    这里有一点需要注意： `Pool` 对象调用 `join()` 方法会等待所有子进程执行完毕，调
    用 `join()` 之前必须先调用 `close()` ，调用`close()` 之后就不能继续添加新的
    Process 了。

    请注意输出的结果，子进程 0，1，2，3 是立刻执行的，而子进程 4 要等待前面某个子
    进程完成后才执行，这是因为 Pool 的默认大小在我的电脑上是 4，因此，最多同时执行
    4 个进程。这是 Pool 有意设计的限制，并不是操作系统的限制。如果改成：

    ```python
    p = Pool(5)
    ```

    就可以同时跑 5 个进程。
***** 进程间通信

    Process 之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python
    的 multiprocessing 模块包装了底层的机制，提供了 Queue、Pipes 等多种方式来交换
    数据。

    以 Queue 为例，在父进程中创建两个子进程，一个往 Queue 里写数据，一个从 Queue 里读数据：

    ```python
    #!/usr/bin/env python3
    # -*- coding: UTF-8 -*-

    from multiprocessing import Process, Queue
    import os, time, random


    def write(q):
        # 写数据进程
        print('写进程的 PID:{0}'.format(os.getpid()))
        for value in ['两点水', '三点水', '四点水']:
            print('写进 Queue 的值为：{0}'.format(value))
            q.put(value)
            time.sleep(random.random())


    def read(q):
        # 读取数据进程
        print('读进程的 PID:{0}'.format(os.getpid()))
        while True:
            value = q.get(True)
            print('从 Queue 读取的值为：{0}'.format(value))


    if __name__ == '__main__':
        # 父进程创建 Queue，并传给各个子进程
        q = Queue()
        pw = Process(target=write, args=(q,))
        pr = Process(target=read, args=(q,))
        # 启动子进程 pw
        pw.start()
        # 启动子进程 pr
        pr.start()
        # 等待 pw 结束:
        pw.join()
        # pr 进程里是死循环，无法等待其结束，只能强行终止
        pr.terminate()

    ```

    输出的结果为：

    ```txt
    读进程的 PID:13208
    写进程的 PID:10864
    写进 Queue 的值为：两点水
    从 Queue 读取的值为：两点水
    写进 Queue 的值为：三点水
    从 Queue 读取的值为：三点水
    写进 Queue 的值为：四点水
    从 Queue 读取的值为：四点水
    ```
** CGI 对象
   : CGI 程序可以是 Python 脚本，PERL 脚本，SHELL 脚本，C 或者 C++程序等
*** Web 服务器支持及配置

    在你进行 CGI 编程前，确保您的 Web 服务器支持 CGI 及已经配置了 CGI 的处理程序。

    Apache 支持 CGI 配置：

    设置好 CGI 目录：

    ScriptAlias /cgi-bin/ /var/www/cgi-bin/

    所有的 HTTP 服务器执行 CGI 程序都保存在一个预先配置的目录。这个目录被称为 CGI 目录，并按照惯例，它被命名为/var/www/cgi-bin 目录。

    CGI 文件的扩展名为.cgi，python 也可以使用.py 扩展名。

    默认情况下，Linux 服务器配置运行的 cgi-bin 目录中为/var/www。

    如果你想指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示：

    <Directory "/var/www/cgi-bin">
    AllowOverride None
    Options +ExecCGI
    Order allow,deny
    Allow from all
    </Directory>

    在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个 CGI 程序

我们使用 Python 创建第一个 CGI 程序，文件名为 hello.py，文件位于/var/www/cgi-bin 目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一 CGI 程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI 环境变量
: 所有的 CGI 程序都接收以下的环境变量，这些变量在 CGI 程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的 MIME 类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded,他表示数据来自于 HTML 表单。
CONTENT_LENGTH	如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。
QUERY_STRING	如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。
REMOTE_HOST	这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI 脚本的完整路径
SCRIPT_NAME	CGI 脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或 IP 地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)
** 网络对象
***  低级别的网络服务支持基本的 Socket
    它提供了标准的 BSD Sockets API，可以访问底层操作系统 Socket 接口的全部方法。
***  高级别的网络服务模块 SocketServer
    它提供了服务器中心类，可以简化网络服务器的开发。
** 正则表达式
 比如在一段字符串中寻找是否含有某个字符或某些字符，通常我们使用内置函数来实现，如下：

 ```python
 # 设定一个常量
 a = '两点水|twowater|liangdianshui|草根程序员|ReadingWithU'

 # 判断是否有 “两点水” 这个字符串，使用 PY 自带函数

 print('是否含有“两点水”这个字符串：{0}'.format(a.index('两点水') > -1))
 print('是否含有“两点水”这个字符串：{0}'.format('两点水' in a))
 ```

 输出的结果如下：

 ```txt
 是否含有“两点水”这个字符串：True
 是否含有“两点水”这个字符串：True
 ```

 那么，如果使用正则表达式呢？

 刚刚提到过，Python 给我们提供了 re 模块来实现正则表达式的所有功能，那么我们先使用其中的一个函数：

 ```python
 re.findall(pattern, string[, flags])
 ```

 该函数实现了在字符串中找到正则表达式所匹配的所有子串，并组成一个列表返回,具体操作如下：

 ```python

 import re

 # 设定一个常量
 a = '两点水|twowater|liangdianshui|草根程序员|ReadingWithU'

 # 正则表达式

 findall = re.findall('两点水', a)
 print(findall)

 if len(findall) > 0:
     print('a 含有“两点水”这个字符串')
 else:
     print('a 不含有“两点水”这个字符串')

 ```

 输出的结果：

 ```txt
 ['两点水']
 a 含有“两点水”这个字符串
 ```

 从输出结果可以看到，可以实现和内置函数一样的功能，可是在这里也要强调一点，上面这
 个例子只是方便我们理解正则表达式，这个正则表达式的写法是毫无意义的。为什么这样说
 呢？

 因为用 Python 自带函数就能解决的问题，我们就没必要使用正则表达式了，这样做多此一
 举。而且上面例子中的正则表达式设置成为了一个常量，并不是一个正则表达式的规则，正
 则表达式的灵魂在于规则，所以这样做意义不大。

 那么正则表达式的规则怎么写呢？先不急，我们一步一步来，先来一个简单的，找出字符串
 中的所有小写字母。首先我们在 `findall` 函数中第一个参数写正则表达式的规则，其中
 `[a-z]` 就是匹配任何小写字母，第二个参数只要填写要匹配的字符串就行了。具体如下：

 ```python

 import re

 # 设定一个常量
 a = '两点水|twowater|liangdianshui|草根程序员|ReadingWithU'

 # 选择 a 里面的所有小写英文字母

 re_findall = re.findall('[a-z]', a)

 print(re_findall)

 ```

 输出的结果：

 ```txt
 ['t', 'w', 'o', 'w', 'a', 't', 'e', 'r', 'l', 'i', 'a', 'n', 'g', 'd', 'i', 'a', 'n', 's', 'h', 'u', 'i', 'e', 'a', 'd', 'i', 'n', 'g', 'i', 't', 'h']
 ```

 这样我们就拿到了字符串中的所有小写字母了。
 # 字符集


 好了，通过上面的几个实例我们初步认识了 Python 的正则表达式，可能你就会问，正则表
 达式还有什么规则，什么字母代表什么意思呢？

 其实，这些都不急，在本章后面会给出对应的正则表达式规则列表，而且这些东西在网上随
 便都能 Google 到。所以现在，我们还是进一步加深对正则表达式的理解，讲一下正则表达
 式的字符集。

 字符集是由一对方括号 “[]” 括起来的字符集合。使用字符集，可以匹配多个字符中的一个。

 举个例子，比如你使用 `C[ET]O` 匹配到的是 CEO 或 CTO，也就是说 `[ET]` 代表的是一
 个 E 或者一个 T。像上面提到的 `[a-z]` ,就是所有小写字母中的其中一个，这里使用了
 连字符 “-” 定义一个连续字符的字符范围。当然，像这种写法，里面可以包含多个字符
 范围的，比如：`[0-9a-fA-F]` ,匹配单个的十六进制数字，且不分大小写。注意了，字符
 和范围定义的先后顺序对匹配的结果是没有任何影响的。

 其实说了那么多，只是想证明，字符集一对方括号 “[]” 里面的字符关系是或关系，下面看一个例子：

 ```Python

 import re
 a = 'uav,ubv,ucv,uwv,uzv,ucv,uov'

 # 字符集

 # 取 u 和 v 中间是 a 或 b 或 c 的字符
 findall = re.findall('u[abc]v', a)
 print(findall)
 # 如果是连续的字母，数字可以使用 - 来代替
 l = re.findall('u[a-c]v', a)
 print(l)

 # 取 u 和 v 中间不是 a 或 b 或 c 的字符
 re_findall = re.findall('u[^abc]v', a)
 print(re_findall)

 ```

 输出的结果：

 ```txt
 ['uav', 'ubv', 'ucv', 'ucv']
 ['uav', 'ubv', 'ucv', 'ucv']
 ['uwv', 'uzv', 'uov']
 ```

 在例子中，使用了取反字符集，也就是在左方括号 “[” 后面紧跟一个尖括号 “^”，就
 会对字符集取反。需要记住的一点是，取反字符集必须要匹配一个字符。比如：`q[^u]` 并
 不意味着：匹配一个 q，后面没有 u 跟着。它意味着：匹配一个 q，后面跟着一个不是 u
 的字符。具体可以对比上面例子中输出的结果来理解。

 我们都知道，正则表达式本身就定义了一些规则，比如 `\d`,匹配所有数字字符,其实它是
 等价于 [0-9]，下面也写了个例子，通过字符集的形式解释了这些特殊字符。

 ```Python
 import re

 a = 'uav_ubv_ucv_uwv_uzv_ucv_uov&123-456-789'

 # 概括字符集

 # \d 相当于 [0-9] ,匹配所有数字字符
 # \D 相当于 [^0-9] ， 匹配所有非数字字符
 findall1 = re.findall('\d', a)
 findall2 = re.findall('[0-9]', a)
 findall3 = re.findall('\D', a)
 findall4 = re.findall('[^0-9]', a)
 print(findall1)
 print(findall2)
 print(findall3)
 print(findall4)

 # \w 匹配包括下划线的任何单词字符，等价于 [A-Za-z0-9_]
 findall5 = re.findall('\w', a)
 findall6 = re.findall('[A-Za-z0-9_]', a)
 print(findall5)
 print(findall6)

 ```

 输出结果：

 ```txt
 ['1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '&', '-', '-']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '&', '-', '-']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 ```
** 闭包
 这个需求是这样的，我们需要一直记录自己的学习时间，以分钟为单位。就好比我学习了 2
 分钟，就返回 2，然后隔了一阵子，我学习了 10 分钟，那么就返回 12，像这样把学习时
 间一直累加下去。


 面对这个需求，我们一般都会创建一个全局变量来记录时间，然后用一个方法来新增每次的
 学习时间，通常都会写成下面这个形式：

 ```Python
 time = 0

 def insert_time(min):
     time = time + min
     return  time

 print(insert_time(2))
 print(insert_time(10))
 ```

 认真想一下，会不会有什么问题呢？

 其实，这个在 Python 里面是会报错的。会报如下错误：

 ```
 UnboundLocalError: local variable 'time' referenced before assignment
 ```

 那是因为，在 Python 中，如果一个函数使用了和全局变量相同的名字且改变了该变量的值，
 那么该变量就会变成局部变量，那么就会造成在函数中我们没有进行定义就引用了，所以会
 报该错误。

 如果确实要引用全局变量，并在函数中对它进行修改，该怎么做呢？

 我们可以使用 `global` 关键字,具体修改如下：

 ```Python
 time = 0


 def insert_time(min):
     global  time
     time = time + min
     return  time

 print(insert_time(2))
 print(insert_time(10))
 ```

 输出结果如下：

 ```
 2
 12
 ```

 可是啊，这里使用了全局变量，我们在开发中能尽量避免使用全局变量的就尽量避免使用。
 因为不同模块，不同函数都可以自由的访问全局变量，可能会造成全局变量的不可预知性。
 比如程序员甲修改了全局变量 `time` 的值，然后程序员乙同时也对 `time` 进行了修改，
 如果其中有错误，这种错误是很难发现和更正的。


 全局变量降低了函数或模块之间的通用性，不同的函数或模块都要依赖于全局变量。同样，
 全局变量降低了代码的可读性，阅读者可能并不知道调用的某个变量是全局变量。

 那有没有更好的方法呢？

 这时候我们使用闭包来解决一下，先直接看代码：

 ```python
 time = 0


 def study_time(time):
     def insert_time(min):
         nonlocal  time
         time = time + min
         return time

     return insert_time


 f = study_time(time)
 print(f(2))
 print(time)
 print(f(10))
 print(time)
 ```

 输出结果如下:

 ```
 2
 0
 12
 0
 ```

 这里最直接的表现就是全局变量 `time` 至此至终都没有修改过,这里还是用了 `nonlocal`
 关键字,表示在函数或其他作用域中使用外层(非全局)变量。那么上面那段代码具体的运行
 流程是怎样的。我们可以看下下图：


 这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭
 包。更加直接的表达方式就是，当某个函数被当成对象返回时，夹带了外部变量，就形成了
 一个闭包。k


 闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。
 而且使用闭包，可以使代码变得更加的优雅。而且下一篇讲到的装饰器，也是基于闭包实现
 的。


 到这里，就会有一个问题了，你说它是闭包就是闭包了？有没有什么办法来验证一下这个函数就是闭包呢？


 有的，所有函数都有一个 ` __closure__` 属性，如果函数是闭包的话，那么它返回的是一
 个由 cell 组成的元组对象。cell 对象的 cell_contents 属性就是存储在闭包中的变量。

 我们打印出来体验一下：

 ```Python
 time = 0


 def study_time(time):
     def insert_time(min):
         nonlocal  time
         time = time + min
         return time

     return insert_time


 f = study_time(time)
 print(f.__closure__)
 print(f(2))
 print(time)
 print(f.__closure__[0].cell_contents)
 print(f(10))
 print(time)
 print(f.__closure__[0].cell_contents)
 ```

 打印的结果为：

 ```
 (<cell at 0x0000000000410C48: int object at 0x000000001D6AB420>,)
 2
 0
 2
 12
 0
 12
 ```

 从打印结果可见，传进来的值一直存储在闭包的 cell_contents 中,因此，这也就是闭包的
 最大特点，可以将父函数的变量与其内部定义的函数绑定。就算生成闭包的父函数已经释放
 了，闭包仍然存在。

 闭包的过程其实好比类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执
 行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，
 因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，
 且更轻巧灵活。

* 模块列表
** math
   max()
   pow(100,	2) 平方
   sqrt  平方根
   e
** 文件
*** 键盘输入
**** : raw_input 函数
: raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
**** : input 函数
: input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个 Python 表达式作为输入，并将运算结果返回
*** 打开和关闭文件 
**** open 
**** close
**** write
**** read
**** 文件定位
**** 重命名和删除文件
**** remove()方法
*** 目录
**** mkdir()方法 
**** chdir()方法 
**** rmdir()方法 
** json
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
    pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
** enum
*** 枚举类的使用 
    #+begin_src python
      #!/usr/bin/env python3
      # -*- coding: UTF-8 -*-

      from enum import Enum

      Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

      # 遍历枚举类型
      for name, member in Month.__members__.items():
          print(name, '---------', member, '----------', member.value)

      # 直接引用一个常量
      print('\n', Month.Jan)
    #+end_src

***  Enum 的源码 
Enum 在模块 enum.py 中，先来看看 Enum 类的片段

#+begin_src python
 class Enum(metaclass=EnumMeta):
     """Generic enumeration.
     Derive from this class to define new enumerations.
     """
#+end_src

 可以看到，Enum 是继承元类 EnumMeta 的；再看看 EnumMeta 的相关片段

#+begin_src python
 class EnumMeta(type):
     """Metaclass for Enum"""
     @property
     def __members__(cls):
         """Returns a mapping of member name->value.
         This mapping lists all enum members, including aliases. Note that this
         is a read-only view of the internal mapping.
         """
         return MappingProxyType(cls._member_map_)
#+end_src
 首先 `__members__` 方法返回的是一个包含一个 Dict 既 Map 的 MappingProxyType，并
 且通过 @property 将方法 `__members__(cls)` 的访问方式改变为了变量的的形式，既可
 以直接通过 `__members__` 来进行访问了

** operator
   add()  
   sub()
   mul
   div
   concat
   operator.lt(a, b)
   operator.le(a, b)
   operator.eq(a, b)
   operator.ne(a, b)
   operator.__lt__(a, b)
   operator.__le__(a, b)
   operator.__eq__(a, b)
   operator.__ne__(a, b)
   operator.__ge__(a, b)
   operator.__gt__(a, b)
** collections 
* Web 框架
** 轻量级
** 重量级
  [[file:django.org][Django]] 
