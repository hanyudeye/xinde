* option
-d      提供调试输出
-O      生成优化的字节码(生成 .pyo 文件)
-S      不导入 site 模块以在启动时查找 Python 路径
-v      冗余输出(导入语句详细追踪)
-m mod  将一个模块以脚本形式运行
-Q opt  除法选项(参阅文档)
-c cmd  运行以命令行字符串形式提交的 Python 脚本
file    从给定的文件运行 Python 脚本(参阅后文)
* python
** 环境变量
 PYTHONPATH	PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。
 PYTHONSTARTUP 	Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此文件中变量指定的执行代码。
 PYTHONCASEOK 	加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.
 PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。
** 中文编码
   # -*- coding: UTF-8 -*- 
   # coding=utf-8
** 类型
   1. List（列表）list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] list[1:2]
   2. 元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )!元组不让更新
   3. 字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'} 
*** 双精度浮点型
不精确的，如果想用更加精度的(精度位数多了)，可以导入 decimals, 但其实还是没算对
设置精度后可能就算对了，没想
#+BEGIN_SRC python
设置精度
  >>> from decimal import *
  >>> getcontext()
  Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
          capitals=1, flags=[], traps=[Overflow, DivisionByZero,
          InvalidOperation])

  >>> getcontext().prec = 7       # Set a new precision
#+END_SRC

#+RESULTS:

** 算术运算符
   **	幂 - 返回x的y次幂	a**b 为10的20次方， 输出结果 100000000000000000000
   //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
** 流程控制
   #+BEGIN_SRC python
     if 判断条件：
     执行语句……
     else：
     执行语句……
#+END_SRC

while循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
循环控制
break
continue
assert(3>4) 断言, 产生此种情况会中断

** 帮助
   help()  函数或类文档字串说明
   dir() 函数或类的性质
** pass 语句 空语句 ，替换 为其他语言的占位符 ;
** 模块, 一个模块几个类
  !模块名(文件名) 与 类名 相同 
*** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
    import module1[, module2[,... moduleN]
*** From…import 语句
: Python的from语句让你从模块中导入一个指定的部分到当前命名空间中
*** globals()和locals()函数
: 根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
*** reload()函数
: 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
: 因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数
*** 完成模块
**** 定义用于模块的错误和异常
    #+BEGIN_SRC python
      class sendException(Exception):
            pass
    #+END_SRC
**** 定义模块中要输出的项 
    from module import classname/functionname
    __all__ 中确定的 或是 除去_ 开头的 是公有的
**** 编写文档
    '''items'''
**** 测试, 写好注释, 执行方法
**** 提供调用的回退函数
**** 安装模块     
     通常在 sys.path 的 site-packages 目录下
** 包 一个包几个类
   使用操作系统原有的目录结构、包是一个目录、如 Hello, 然后在里面创建__init__.py 文件，该文件提示该目录是包目录
   在目录下创建类，类名同文件名要相同，默认只执行 __init__.py 文件，需要在里面 用 from 文件 import 同文件名同的类名
   就可以在调用的源码中 import 包名 了
   
实例化 时 是 包名+类名
** 测试模块和包
   if __name== '__main__'
   __name__是 模块或包名的变量, __main__ 用来测试模块中的方法 
** 函数
*** 定义 def funname(a="a"): 默认值
*** 对象属性 
    对象的长度  len(obj), 整数没有长度
    打开文件 open(fn, mode) 以 mode('r' = 读, 'w'= 写)方式打开一个文件名为 fn 的文件
    对象type 还能判断是类 还是实例, 还可以直接用isinstance()判断
    读键盘 input(str)
    切片 相当于从 排序的东西 选择 某种间隔的东西, 符号代表反向
 #+BEGIN_SRC python
foostr = 'abcde'
foostr[::-1]
 #+END_SRC 
 and or 没有C 中的 || 和&& 了
 is, is not 比较两个东西一样不一样
 not 逻辑否定
*** 文件
**** 键盘输入
***** : raw_input函数
 : raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
***** : input函数
 : input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回
**** 打开和关闭文件 
***** open 
***** close
***** write
***** read
***** 文件定位
***** 重命名和删除文件
***** remove()方法
**** 目录
***** mkdir()方法 
***** chdir()方法 
***** rmdir()方法 
*** math
    max()
    pow(100,	2) 平方
    sqrt  平方根
    e
*** operator	 提供了中缀运算
    add()  和
    sub()
    mul
    div
    concat
    operator.lt(a, b)
   operator.le(a, b)
   operator.eq(a, b)
   operator.ne(a, b)
   operator.__lt__(a, b)
   operator.__le__(a, b)
   operator.__eq__(a, b)
   operator.__ne__(a, b)
   operator.__ge__(a, b)
   operator.__gt__(a, b)
*** functools
** 异常处理
*** 捕捉异常可以使用try/except语句
#+BEGIN_SRC python
  try:
  <语句>        #运行别的代码
  except <名字>：
  <语句>        #如果在try部份引发了'name'异常
  except <名字>，<数据>:
  <语句>        #如果引发了'name'异常，获得附加的数据
  else:
  <语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** 类
*** class
    类中方法定义 必须带 self
   #+BEGIN_SRC python
     class wa:
      def __init__(self, items={}):
          '''items'''
          if type(item)!=type({}):
              raise TypeError("类型错误")
          self.items=items
          return
         def	deposit(self,	amount):
          self.balance	=	self.balance	+	amount
          return	self.balance
         def	withdraw(self,	amount):
          if	amount	>	self.balance:
           return	'Insufficient	funds'
   #+END_SRC
*** 初始化函数 
    __init
*** 类的实例 ，没有new 关键词
    a = Acc('xx')
*** 类的继承
    #+BEGIN_SRC python
      class Subclass(Parentclass):
             def __init__(self):
              Parentclass.__init__

    #+END_SRC
*** 类属性与方法
**** 类的私有属性
     __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
     类的方法
     在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数
**** 类的私有方法
     __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
*** type 函数
** CGI编程 引入python cgi库
: CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等
*** Web服务器支持及配置

在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。

Apache 支持CGI 配置：

设置好CGI目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的HTTP服务器执行CGI程序都保存在一个预先配置的目录。这个目录被称为CGI目录，并按照惯例，它被命名为/var/www/cgi-bin目录。

CGI文件的扩展名为.cgi，python也可以使用.py扩展名。

默认情况下，Linux服务器配置运行的cgi-bin目录中为/var/www。

如果你想指定其他运行CGI脚本的目录，可以修改httpd.conf配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个CGI程序

我们使用Python创建第一个CGI程序，文件名为hello.py，文件位于/var/www/cgi-bin目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一CGI程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI环境变量
: 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。
CONTENT_LENGTH	如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。
QUERY_STRING	如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。
REMOTE_HOST	这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI脚本的完整路径
SCRIPT_NAME	CGI脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或IP地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)
** MySQLdb
** 网络编程
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
** 多线程
** GUI编程(Tkinter)
** JSON
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
    pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
* python mode
** Features:
- Auto-completion using [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]
- Code Navigation using  [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]
- Documentation Lookup using  [[https://github.com/proofit404/anaconda-mode][anaconda-mode]]  and [[https://github.com/tsgates/pylookup][pylookup]]
- Test Runners using [[https://github.com/syl20bnr/nose.el][nose.el]] or [[https://github.com/ionrock/pytest-el][pytest]]
- Virtual Environment using  [[https://github.com/jorgenschaefer/pyvenv][pyvenv]] and [[https://github.com/yyuu/pyenv][pyenv]]
- semantic mode is enabled
- PEP8 compliant formatting via [[https://github.com/google/yapf][YAPF]]
- PEP8 checks with [[https://pypi.python.org/pypi/flake8][flake8]] or [[https://pypi.python.org/pypi/pylint/1.6.4][pylint]]
- Suppression of unused import with [[https://github.com/myint/autoflake][autoflake]]
- Use the ~%~ key to jump between blocks with [[https://github.com/redguardtoo/evil-matchit][evil-matchit]]
- Sort imports with [[https://pypi.python.org/pypi/isort][isort]]

** Install
*** Layer
 To use this configuration layer, add it to your =~/.spacemacs=. You will need to
 add =python= to the existing =dotspacemacs-configuration-layers= list in this
 file.

*** Dependencies
**** Auto-completion: Anaconda dependencies
 =anaconda-mode= tries to install the dependencies itself but sometimes
 it does not work and you may encounter the following message when
 opening a python buffer:

 #+begin_example
     Blocking call to accept-process-output with quit inhibited!!
 #+end_example

 To fix this, install the =anaconda-mode= [[https://github.com/proofit404/anaconda-mode/wiki][anaconda-deps]] by hand:

 #+begin_src sh
     pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
 #+end_src

 If you encounter problems with Jedi 1.0 consider downgrading to 0.9.0. See [[https://github.com/davidhalter/jedi/issues/873][this
 issue]] for details.

 Source: https://github.com/proofit404/anaconda-mode#issues

 If you are facing errors such as "Unable to run anaconda-mode server", try
 setting your =PYTHONPATH= as explained at
 https://github.com/proofit404/anaconda-mode#pythonpath

**** Syntax checking
 Syntax checking uses =flake8= package:
 #+begin_src sh
     pip install flake8
 #+end_src

*** Test runner
 Both =nose= and =pytest= are supported. By default =nose= is used.
 To choose your test runner set the layer variable =python-test-runner= to
 either =nose= or =pytest=.

 #+BEGIN_SRC emacs-lisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-test-runner 'pytest)))
 #+END_SRC

 If you need both then you can set =python-test-runner= to a list like this:
 #+BEGIN_SRC emacs-lisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-test-runner '(pytest nose))))
 #+END_SRC

 This means that =pytest= is your primary test runner. To use the secondary test
 runner you can call the test functions with a prefix argument e.g. ~SPC u SPC m
 t t~ to run one test with =nose=.

 To set project specific test runners you can set =python-test-runner= in a
 directory local variable in your project root. ~SPC f v d~ in Spacemacs. See
 [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][the official documentation]] for more information.

 The root of the project is detected with a =.git= directory or a =setup.cfg= file.
*** Automatic buffer formatting on save
    To enable automatic buffer formatting on save with  [[https://github.com/google/yapf][YAPF]] set the variable
    =python-enable-yapf-format-on-save= to =t=.
 #+BEGIN_SRC emacs-lisp
   (setq-default dotspacemacs-configuration-layers '(
     (python :variables python-enable-yapf-format-on-save t)))
 #+END_SRC

*** autoflake
 To be able to suppress unused imports easily, install [[https://github.com/myint/autoflake][autoflake]]:

 #+BEGIN_SRC sh
   pip install autoflake
 #+END_SRC

*** pylookup
 To use =pylookup= on ~SPC m h H~, make sure you update the database first, using
 ~SPC SPC pylookup-update~.

*** Hy-mode
 To be able to connect to an inferior lisp repl in =hy-mode=, you need to make sure
 that hy is installed.

 #+BEGIN_SRC sh
   pip install hy
 #+END_SRC

** Management of Python versions and virtual environments
*** Manage virtual environments with pyvenv
 A virtual environment provides isolation of your Python package versions. For a
 general overview see [[http://docs.python-guide.org/en/latest/dev/virtualenvs/][this site]]. [[http://virtualenvwrapper.readthedocs.io/en/latest/index.html][Virtualenvwrapper]] which is also explained in the
 previous link, is a program which manages your virtual environments in a central
 location set by the =WORKON_HOME= environment variable.

 Spacemacs integration of virtual environments and virtualenvwrapper is provided
 by the [[https://github.com/jorgenschaefer/pyvenv][pyvenv]] package. It provides the following keybindings:

 | Key Binding | Description                                     |
 |-------------+-------------------------------------------------|
 | ~SPC m V a~ | activate a virtual environment in any directory |
 | ~SPC m V d~ | deactivate active virtual environment           |
 | ~SPC m V w~ | work on virtual environment in =WORKON_HOME=    |

*** Manage multiple Python versions with pyenv
 If you need multiple Python versions (e.g. Python 2 and Python 3) then take a
 look at [[https://github.com/yyuu/pyenv][pyenv]]. It enables the installation and managment of multiple
 Python versions.
 [[https://www.brianthicks.com/post/2015/04/15/automate-your-python-environment-with-pyenv/][This blogpost]] gives a good overview on how to use the tool. Spacemacs
 integration is provided by [[https://github.com/proofit404/pyenv-mode][pyenv mode]] which has the following keybindings.

 | Key Binding | Description                          |
 |-------------+--------------------------------------|
 | ~SPC m v s~ | set a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]   |
 | ~SPC m v u~ | unset a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]] |

 Pyenv can also manage virtual environments for each of the Python versions it
 has installed. Those will be listed alongside your Python versions.

**** Automatic activation of local pyenv version
 A project-specific pyenv version may be written to a file called
 =.python-version= using the [[https://github.com/yyuu/pyenv/blob/master/COMMANDS.md#user-content-pyenv-local][pyenv local]] command.

 Spacemacs can search in parent directories for this file, and automatically set
 the pyenv version. The behavior can be set with the variable
 =python-auto-set-local-pyenv-version= to:
 - =on-visit= (default) set the version when you visit a python buffer,
 - =on-project-switch= set the version when you switch projects,
 - =nil= to disable.

 The same is also possible on pyvenv with a file called =.venv=. The behavior
 can be set with the variable =python-auto-set-local-pyvenv-virtualenv== to:
 - =on-visit= (default) set the virtualenv when you visit a python buffer,
 - =on-project-switch= set the virtualenv when you switch projects,
 - =nil= to disable.

** Key Bindings
*** Inferior REPL process 在交互模式下, 需SPC m s i
 Start a Python or iPython inferior REPL process with ~SPC m s i~.
 If =ipython= is available in system executable search paths, =ipython=
 will be used to launch python shell; otherwise, default =python=
 interpreter will be used.  You may change your system executable
 search path by activating a virtual environment.

 Send code to inferior process commands:

 | Key Binding | Description                                     |
 |-------------+-------------------------------------------------|
 | ~SPC m s b~ | send buffer and keep code buffer focused        |
 | ~SPC m s B~ | send buffer and switch to REPL in insert mode   |
 | ~SPC m s f~ | send function and keep code buffer focused 发送光标处函数 |
 | ~SPC m s F~ | send function and switch to REPL in insert mode |
 | ~SPC m s i~ | start inferior REPL process                     |
 | ~SPC m s r~ | send region and keep code buffer focused        |
 | ~SPC m s R~ | send region and switch to REPL in insert mode   |
 | ~CTRL+j~    | next item in REPL history                       |
 | ~CTRL+k~    | previous item in REPL history                   |
*** Running Python Script in shell
 To run a Python script like you would in the shell press ~SPC m c c~
 to start the Python script in comint mode. This is useful when working with
 multiple Python files since the REPL does not reload changes made in other
 modules.

 | Key Binding | Description                                                               |
 |-------------+---------------------------------------------------------------------------|
 | ~SPC m c c~ | Execute current file in a comint shell                                    |
 | ~SPC m c C~ | Execute current file in a comint shell and switch to it in =insert state= |

 *Note:* With the universal argument ~SPC u~ you can enter a new
 compilation command.
用 spc u spc m c c 可以输入执行脚本的命令, 可以在后面加参数
*** Testing (没装 nose)
 Test commands start with ~m t~. To use the secondary test runner call the
 function with a prefix argument, for example ~SPC u SPC m t a~.
 | No Debug    | Description                                              |
 |-------------+----------------------------------------------------------|
 | ~SPC m t a~ | launch all tests of the project                          |
 | ~SPC m t b~ | launch all tests of the current buffer (same as module)  |
 | ~SPC m t m~ | launch all tests of the current module                   |
 | ~SPC m t s~ | launch all tests of the current suite (only with =nose=) |
 | ~SPC m t t~ | launch the current test (function)                       |

 | Debug       | Description                                                            |
 |-------------+------------------------------------------------------------------------|
 | ~SPC m t A~ | launch all tests of the project in debug mode                          |
 | ~SPC m t B~ | launch all tests of the current buffer (module) in debug mode          |
 | ~SPC m t M~ | launch all tests of the current module in debug mode                   |
 | ~SPC m t S~ | launch all tests of the current suite in debug mode (only with =nose=) |
 | ~SPC m t T~ | launch the current test (function) in debug mode                       |

*** Refactoring

 | Key Binding | Description                          |
 |-------------+--------------------------------------|
 | ~SPC m r i~ | remove unused imports with [[https://github.com/myint/autoflake][autoflake]] |
 | ~SPC m r I~ | sort imports with [[https://pypi.python.org/pypi/isort][isort]]              |

*** Live coding
 Live coding is provided by the [[https://github.com/donkirkby/live-py-plugin][live-py-plugin.]]

 | Key Binding | Description         |
 |-------------+---------------------|
 | ~SPC m l~   | Toggle live-py-mode |

*** Hy REPL process
 Start a Hy inferior repel process with ~SPC m s i~. If =hy= is
 available in system executable search paths, =hy= will be used to
 launch the shell. You may change your system executable search path
 by activating a virtual enviornment.

 Send code to hy REPL commands:

 | Key Binding | Description                                               |
 |-------------+-----------------------------------------------------------|
 | ~SPC m s b~ | send buffer and keep code buffer focused                  |
 | ~SPC m s B~ | switch to REPL                                            |
 | ~SPC m s e~ | send sexp in front of the cursor to the REPL              |
 | ~SPC m s f~ | send function to REPL and stay in buffer                  |
 | ~SPC m s F~ | send function to REPL and switch to repl buffer           |
 | ~SPC m s i~ | start inferior hy repl                                    |
 | ~SPC m s r~ | send current region to the REPL and stay in buffer        |
 | ~SPC m s R~ | send current region to the REPL and switch to repl buffer |

*** Other Python commands

 | Key Binding | Description                                                                  |
 |-------------+------------------------------------------------------------------------------|
 | ~SPC m =~   | Reformat the buffer according to PEP8 using  [[https://github.com/google/yapf][YAPF]]                            |
 | ~SPC m d b~ | toggle a breakpoint using =wdb=, =ipdb=, =pudb= or =pdb=                     |
 | ~SPC m g g~ | go to definition using =anaconda-mode-find-definitions= (~C-o~ to jump back) |
 | ~SPC m g a~ | go to assignment using =anaconda-mode-find-assignments= (~C-o~ to jump back) |
 | ~SPC m g b~ | jump back                                                                    |
 | ~SPC m g u~ | navigate between usages with =anaconda-mode-find-references=                 |
 | ~SPC m h d~ | look for documentation using =helm-pydoc=                                    |
 | ~SPC m h h~ | quick documentation using anaconda                                           |
 | ~SPC m h H~ | open documentation in =firefox= using [[https://github.com/tsgates/pylookup][pylookup]]                               |
 | ~SPC m v s~ | set a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]                                           |
 | ~SPC m v u~ | unset a pyenv environment with [[https://github.com/pyenv/pyenv][pyenv]]                                         |
 | ~SPC m V w~ | work on virtual environment in =WORKON_HOME=                                 |
 | ~SPC m V a~ | activate a virtual environment in any directory                              |
 | ~SPC m V d~ | deactivate active virtual environment                                        |

** Configuration
*** Fill column
 If you want to customize the fill column value, use something like this inside
 the =user-init= function in your =.spacemacs=:

 #+BEGIN_SRC elisp
 (setq-default dotspacemacs-configuration-layers '(
     (python :variables python-fill-column 99)))
 #+END_SRC

*** Sort imports
 If you want imports to be automatically sorted when you save a file (using
 [[https://pypi.python.org/pypi/isort][isort]]), set the =python-sort-imports-on-save= variable in the python layer
 config section:

 #+BEGIN_SRC elisp
 (setq-default dotspacemacs-configuration-layers
   '((python :variables python-sort-imports-on-save t)))
 #+END_SRC

 or as a directory-local variable (for per-project settings).
