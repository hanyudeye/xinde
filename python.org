* python option
-d      提供调试输出
-O      生成优化的字节码(生成 .pyo 文件)
-S      不导入 site 模块以在启动时查找 Python 路径
-v      冗余输出(导入语句详细追踪)
-m mod  将一个模块以脚本形式运行
-Q opt  除法选项(参阅文档)
-c cmd  运行以命令行字符串形式提交的 Python 脚本
file    从给定的文件运行 Python 脚本(参阅后文)
* python
** Python 环境变量
: PYTHONPATH	PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。
: PYTHONSTARTUP 	Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此文件中变量指定的执行代码。
: PYTHONCASEOK 	加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.
: PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。
** Python 中文编码
 默认编码格式是 ASCII 格式
  # -*- coding: UTF-8 -*- 或者 #coding=utf-8.
** 变量
1. List（列表）list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] list[1:2]
2. 元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )!元组不让更新
3. 字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'} 
冰箱={'苹果':3,'梨子':5,'橘子':3}
** 类型 type
** 算术运算符
 **	幂 - 返回x的y次幂	a**b 为10的20次方， 输出结果 100000000000000000000
 //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
** 条件语句
#+BEGIN_SRC python
if 判断条件：
    执行语句……
else：
    执行语句……
#+END_SRC
** 循环语句
*** while循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
*** for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
*** 循环控制
**** break
**** continue
** 帮助
help()  dir()
** pass 语句 空语句 ，替换 为其他语言的占位符 ;
** Python 函数
 #+BEGIN_SRC python
 def functionname( parameters ):
   "函数_文档字符串"
   function_suite
   return [expression]
 #+END_SRC
** Python 模块
*** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
import module1[, module2[,... moduleN]
*** From…import 语句
: Python的from语句让你从模块中导入一个指定的部分到当前命名空间中
*** globals()和locals()函数
: 根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
*** reload()函数
: 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
: 因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数
*** Python中的包 相当于c中的头文件
** Python 文件I/O
*** 键盘输入
**** : raw_input函数
: raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
**** : input函数
: input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回
*** 打开和关闭文件 
**** open 
**** close
**** write
**** read
**** 文件定位
**** 重命名和删除文件
**** remove()方法
*** 目录
**** mkdir()方法 
**** chdir()方法 
**** rmdir()方法 
** Python 异常处理
*** 捕捉异常可以使用try/except语句
#+BEGIN_SRC python
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** Python 面向对象
*** 类
*** 类的继承
*** 类属性与方法
**** 类的私有属性
__private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
类的方法
在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数
**** 类的私有方法
__private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
** Python CGI编程 引入python cgi库
: CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等
*** Web服务器支持及配置

在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。

Apache 支持CGI 配置：

设置好CGI目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的HTTP服务器执行CGI程序都保存在一个预先配置的目录。这个目录被称为CGI目录，并按照惯例，它被命名为/var/www/cgi-bin目录。

CGI文件的扩展名为.cgi，python也可以使用.py扩展名。

默认情况下，Linux服务器配置运行的cgi-bin目录中为/var/www。

如果你想指定其他运行CGI脚本的目录，可以修改httpd.conf配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个CGI程序

我们使用Python创建第一个CGI程序，文件名为hello.py，文件位于/var/www/cgi-bin目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一CGI程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI环境变量
: 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。
CONTENT_LENGTH	如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。
QUERY_STRING	如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。
REMOTE_HOST	这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI脚本的完整路径
SCRIPT_NAME	CGI脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或IP地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)
** python操作mysql数据库 MySQLdb
** Python 网络编程
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
** Python 多线程
** python GUI编程(Tkinter)
** Python JSON
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
* core python 
  输入/输出
  操作符
  变量与赋值
  Python 类型
  循环与条件
  文件
  错误
  函数
  类
  模块
  列表解析
  文件和内建函数open（）、file（）
  错误和异常
  函数
  默认参数
  类
  模块 import sys
  如何访问一个模块函数或访问一个模块变量
  多个语句构成代码组（:）
  代码组由不同的缩进分隔
  同一行书写多个语句（;）
动态类型
内存分配
Python对象
　类型对象和type类型对象
　None--Python的Null对象
内部类型
　代码对象
　帧对象
　跟踪记录对象
　切片对象
　省略对象
　XRange 对象
标准类型操作符
　对象值的比较
　对象身份比较
　布尔类型
标准类型内建函数
　type（）
　cmp（）
　str（）和repr（）（及``操作符）
　type（）和isinstance（）
　Python类型操作符和内建函数总结
类型工厂函数
标准类型的分类
　存储模型
　更新模型
　访问模型
不支持的类型
练习
　数字
数字简介
　如何创建数值对象并用其赋值（数字对象）
　如何更新数字对象
　如何删除数字对象
整型
　布尔型
　标准整型
　长整型
　整型和长整型的统一
双精度浮点型
复数
操作符
　混合模式操作符
　标准类型操作符
　数字类型函数
　仅用于整型的函数
其他数字类型
　布尔“数”
　十进制浮点型
相关模块
序列
　标准类型操作符
　序列类型操作符
　内建函数（BIF）
字符串
字符串和操作符
　标准类型操作符
　序列操作符切片（[]和[:]）
只适用于字符串的操作符
　格式化操作符（％）
　字符串模板: 更简单的替代品
　原始字符串操作符（r/R）
　Unicode字符串操作符（u/U）
内建函数
　标准类型函数
　序列类型函数
　字符串类型函数
字符串内建函数
字符串的独特特性
　特殊字符串和控制字符
　三引号
　字符串不变性
Unicode
　术语
　什么是Unicode
　怎样使用Unicode
　Codec是什么
　编码解码
　把Unicode应用到实际应用中
　从现实中得来的教训
　Python的Unicode支持
关模块
字符串关键点总结
列表
操作符
　标准类型操作符
　序列类型操作符
　列表类型操作符和列表解析
内建函数
　标准类型函数
　序列类型函数
　列表类型内建函数
列表类型的内建函数
列表的特殊特性
元组
元组操作符和内建函数
　标准类型操作符、序列类型操作符和内建函数
　元组类型操作符和内建函数、内建方法
元组的特殊特性
1　不可变性给元组带来了什么影响
2　元组也不是那么“不可变”
3　默认集合类型
4　单元素元组
5　字典的关键字
相关模块
*拷贝Python对象、浅拷贝和深拷贝
序列类型小结
练习
　映像和集合类型
映射类型：字典
　如何创建字典和给字典赋值
　如何访问字典中的值
　如何更新字典
　如何删除字典元素和字典
映射类型操作符
　标准类型操作符
　映射类型操作符
映射类型的内建函数和工厂函数
　标准类型函数[type（）、str（）和cmp（）]
　映射类型相关的函数
映射类型内建方法
字典的键
　不允许一个键对应多个值
　键必须是可哈希的
集合类型
　如何创建集合类型和给集合赋值
　如何访问集合中的值
　如何更新集合
　如何删除集合中的成员和集合
集合类型操作符
　标准类型操作符（所有的集合类型）
　集合类型操作符（所有的集合类型）
　集合类型操作符（仅适用于可变集合）
内建函数
　标准类型函数
　集合类型工厂函数
集合类型内建方法
　方法（所有的集合方法）
　方法（仅适用于可变集合）
　操作符和内建方法比较
集合类型总结表
相关模块
练习
　条件和循环
if语句
　多重条件表达式
　单一语句的代码块
else语句
elif（即else-if）语句
条件表达式（即“三元操作符”）
while语句
　一般语法
　计数循环
　无限循环
for语句
　一般语法
　用于序列类型
　用于迭代器类型
　range（）内建函数
　xrange（） 内建函数
　与序列相关的内建函数
break语句
continue语句
pass语句
再谈else语句
迭代器和iter（）函数
　什么是迭代器
　为什么要迭代器
　如何迭代
　使用迭代器
　可变对象和迭代器
　如何创建迭代器
列表解析
生成器表达式
相关模块
练习
文件和输入输出
件对象
件内建函数（open（）和file（））
工厂函数file（）
通用换行符支持（UNS）
件内建方法
输入
输出
文件内移动
文件迭代
其他
文件方法杂项
件内建属性
准文件
令行参数
件系统
件执行
久存储模块
pickle和marshal模块
DBM风格的模块
shelve模块
相关模块
练习
　错误和异常
什么是异常
　错误
　异常
Python 中的异常
检测和处理异常
　try-except语句
　包装内建函数
　带有多个except的try语句
　处理多个异常的except语句
　捕获所有异常
　“异常参数”
　在应用使用我们封装的函数
　else子句
　finally子句
0　try-finally语句
1　try-except-else-finally：厨房一锅端
上下文管理
　with语句
　*上下文管理协议
*字符串作为异常
触发异常
断言
标准异常
创建异常
（现在）为什么用异常
到底为什么要异常
异常和sys模块
相关模块
练习
　函数和函数式编程
什么是函数？
　函数vs过程
　返回值与函数类型
调用函数
　函数操作符
　关键字参数
**** 11.2.3　默认参数
**** 11.2.4　参数组
**** 11.3　创建函数
**** 11.3.1　def语句
**** 11.3.2　声明与定义比较
**** 11.3.3　前向引用
**** 11.3.4　函数属性
**** 11.3.5　内部/内嵌函数
**** 11.3.6　*函数（与方法）装饰器
**** 11.4　传递函数
**** 11.5　Formal Arguments
**** 11.5.1　位置参数
**** 11.5.2　默认参数
**** 11.6　可变长度的参数
**** 11.6.1　非关键字可变长参数（元组）
**** 11.6.2　关键字变量参数（字典）
**** 11.6.3　调用带有可变长参数对象函数
**** 11.7　函数式编程
**** 11.7.1　匿名函数与lambda
**** 11.7.2　内建函数apply（）、filter（）、map（）、reduce（）
**** 11.7.3　偏函数应用
**** 11.8　变量作用域
**** 11.8.1　全局变量与局部变量
**** 11.8.2　globa语句
**** 11.8.3　作用域的数字
**** 11.8.4　闭包
**** 11.8.5　作用域和lambda
**** 11.8.6　变量作用域和名称空间
**** 11.9　*递归
**** 11.10　生成器
**** 11.10.1　简单的生成器特性
**** 11.10.2　加强的生成器特性
**** 11.11　练习
**** 第12章　模块
**** 12.1　什么是模块
**** 12.2　模块和文件
**** 12.2.1　模块名称空间
**** 12.2.2　搜索路径和路径搜索
**** 12.3　名称空间
**** 12.3.1　名称空间与变量作用域比较
**** 12.3.2　名称查找、确定作用域、覆盖
**** 12.3.3　无限制的名称空间
**** 12.4　导入模块
**** 12.4.1　import语句
**** 12.4.2　from-import语句
**** 12.4.3　多行导入
**** 12.4.4　扩展的import语句（as）
**** 12.5　模块导入的特性
**** 12.5.1　载入时执行模块
**** 12.5.2　导入（import）和加载（load）
**** 12.5.3　导入到当前名称空间的名称
**** 12.5.4　被导入到导入者作用域的名字
**** 12.5.5　关于__future__
**** 12.5.6　警告框架
**** 12.5.7　从ZIP文件中导入模块
**** 12.5.8　“新的”导入钩子
**** 12.6　模块内建函数
**** 12.6.1　__import__（）
**** 12.6.2　globals（）和locals（）
**** 12.6.3　reload（）
**** 12.7　包
**** 12.7.1　目录结构
**** 12.7.2　使用from-import导入包
**** 12.8　模块的其他特性
**** 12.8.1　自动载入的模块
**** 12.8.2　阻止属性导入
**** 12.8.3　不区分大小的导入
**** 12.8.4　源代码编码
**** 12.8.5　导入循环
**** 12.8.6　模块执行
**** 12.9　相关模块
**** 12.10　练习
**** 第13章　面向对象编程
**** 13.1　引言
**** 13.2　面向对象编程
**** 13.2.1　面向对象设计与面向对象编程的关系
**** 13.2.2　现实中的问题
**** 13.2.3　*常用术语
**** 13.3　类
**** 13.3.1　创建类
**** 13.3.2　声明与定义
**** 13.4　类属性
**** 13.4.1　类的数据属性
**** 13.4.2　Methods
**** 13.4.3　决定类的属性
**** 13.4.4　特殊的类属性
**** 13.5　实例
**** 13.5.1　初始化：通过调用类对象来创建实例
**** 13.5.2　__init__（）“构造器”方法
**** 13.5.3　__new__（）“构造器”方法
**** 13.5.4　__del__（）“解构器”方法
**** 13.6　实例属性
**** 13.6.1　“实例化”实例属性（或创建一个更好的构造器）
**** 13.6.2　查看实例属性
**** 13.6.3　特殊的实例属性
**** 13.6.4　建类型属性
**** 13.6.5　实例属性vs类属性
**** 13.7　绑定和方法调用
**** 13.7.1　调用绑定方法
**** 13.7.2　调用非绑定方法
**** 13.8　静态方法和类方法
**** 13.8.1　staticmethod（）和classmethod（）内建函数
**** 13.8.2　使用函数修饰符
**** 13.9　组合
**** 13.10　子类和派生
**** 13.11　继承
**** 13.11.1　__bases__类属性
**** 13.11.2　通过继承覆盖方法
**** 13.11.3　从标准类型派生
**** 13.11.4　多重继承
**** 13.12　类、实例和其他对象的内建函数
**** 13.12.1　issubclass（）
**** 13.12.2　isinstance（）
**** 13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）
**** 13.12.4　dir（）
**** 13.12.5　super（）
**** 13.12.6　vars（）
**** 13.13　用特殊方法定制类
**** 13.13.1　简单定制（RoundFloat2）
**** 13.13.2　数值定制（Time60）
**** 13.13.3　迭代器（RandSeq和AnyIter）
**** 13.13.4　*多类型定制（NumStr）
**** 13.14　私有化
**** 13.15　*授权
**** 13.15.1　包装
**** 13.15.2　实现授权
**** 13.16　新式类的高级特性（Python 2.2+）
**** 13.16.1　新式类的通用特性
**** 13.16.2　__slots__类属性
**** 13.16.3　__getattribute__（）特殊方法
**** 13.16.4　描述符
**** 13.16.5　元类和__metaclass__
**** 13.17　相关模块和文档
**** 13.18　练习
**** 第14章　执行环境
**** 14.1　可调用对象
**** 14.1.1　函数
**** 14.1.2　方法
**** 14.1.3　类
**** 14.1.4　类的实例
**** 14.2　代码对象
**** 14.3　可执行的对象声明和内建函数
**** 14.3.1　callable（）
**** 14.3.2　compile（）
**** 14.3.3　eval（）
**** 14.3.4　exec
**** 14.3.5　input（）
**** 14.3.6　使用Python在运行时生成和执行Python代码
**** 14.4　执行其他（Python）程序
**** 14.4.1　导入
**** 14.4.2　execfile（）
**** 14.4.3　将模块作为脚本执行
**** 14.5　执行其他（非Python）程序
**** 14.5.1　os.system（）
**** 14.5.2　os.popen（）
**** 14.5.3　os.fork（）、os.exec*（）、os.wait*（）
**** 14.5.4　os.spawn*（）
**** 14.5.5　subprocess 模块
**** 14.5.6　相关函数
**** 14.6　受限执行
**** 14.7　结束执行
**** 14.7.1　sys.exit（） and SystemExit
**** 14.7.2　sys.exitfunc（）
**** 14.7.3　os._exit（） 函数
**** 14.7.4　os.kill（） Function
**** 14.8　各种操作系统接口
**** 14.9　相关模块
**** 14.10　练习
**** 第2部分　高级主题
**** 第15章　正则表达式
**** 15.1　引言/动机
**** 15.2　正则表达式使用的特殊符号和字符
**** 15.2.1　用管道符号（|）匹配多个正则表达式模式
**** 15.2.2　匹配任意一个单个的字符（.）
**** 15.2.3　从字符串的开头或结尾或单词边界开始匹配（^/$ /\b /\B ）
**** 15.2.4　创建字符类（[]）
**** 15.2.5　指定范围（-）和否定（^）
**** 15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现/重复匹配
**** 15.2.7　特殊字符表示、字符集
**** 15.2.8　用圆括号（（））组建组
**** 15.3　正则表达式和Python语言
**** 15.3.1　re模块：核心函数和方法
**** 15.3.2　使用compile（）编译正则表达式
**** 15.3.3　匹配对象和group（）、groups（）方法
**** 15.3.4　用match（）匹配字符串
**** 15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）
**** 15.3.6　匹配多个字符串（|）
**** 15.3.7　匹配任意单个字符（.）
**** 15.3.8　创建字符集合（[]）
**** 15.3.9　重复、特殊字符和子组
**** 15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配
**** 15.3.11　用findall（）找到每个出现的匹配部分
**** 15.3.12　用sub（）（和subn（））进行搜索和替换
**** 15.3.13　用split（）分割（分隔模式）
**** 15.4　正则表达式示例
**** 15.4.1　匹配一个字符串
**** 15.4.2　搜索与匹配的比较，“贪婪”匹配
**** 15.5　练习
**** 第16章　网络编程
**** 16.1　引言
**** 16.1.1　什么是客户端/服务器架构
**** 16.1.2　客户端/服务器网络编程
**** 16.2　套接字：通信端点
**** 16.2.1　什么是套接字
**** 16.2.2　套接字地址：主机与端口
**** 16.2.3　面向连接与无连接
**** 16.3　Python中的网络编程
**** 16.3.1　socket（）模块函数
**** 16.3.2　套接字对象（内建）方法
**** 16.3.3　创建一个TCP服务器
**** 16.3.4　创建TCP客户端
**** 16.3.5　运行我们的客户端与TCP服务器
**** 16.3.6　创建一个UDP服务器
**** 16.3.7　创建一个UDP客户端
**** 16.3.8　执行UDP服务器和客户端
**** 16.3.9　Socket模块属性
**** 16.4　*SocketServer模块
**** 16.4.1　创建一个SocketServerTCP服务器
**** 16.4.2　创建SocketServerTCP客户端
**** 16.4.3　执行TCP服务器和客户端
**** 16.5　Twisted框架介绍
**** 16.5.1　创建一个Twisted Reactor TCP服务器
**** 16.5.2　创建一个Twisted Reactor TCP客户端
**** 16.5.3　执行TCP服务器和客户端
**** 16.6　相关模块
**** 16.7　练习
**** 第17章　网络客户端编程
**** 17.1　什么是因特网客户端
**** 17.2　文件传输
**** 17.2.1　文件传输网际协议
**** 17.2.2　文件传输协议（FTP）
**** 17.2.3　Python和FTP
**** 17.2.4　ftplib.FTP类方法
**** 17.2.5　交互式FTP示例
**** 17.2.6　客户端FTP程序举例
**** 17.2.7　FTP的其他方面
**** 17.3　网络新闻
**** 17.3.1　Usenet与新闻组
**** 17.3.2　网络新闻传输协议（NNTP）
**** 17.3.3　Python和NNTP
**** 17.3.4　nntplib.NNTP类方法
**** 17.3.5　交互式NNTP举例
**** 17.3.6　客户端程序NNTP举例
**** 17.3.7　NNTP的其他方面
**** 17.4　电子邮件
**** 17.4.1　电子邮件系统组件和协议
**** 17.4.2　发送电子邮件
**** 17.4.3　Python和SMTP
**** 17.4.4　smtplib.SMTP类方法
**** 17.4.5　交互式SMTP示例
**** 17.4.6　SMTP的其他方面
**** 17.4.7　接收电子邮件
**** 17.4.8　POP和IMAP
**** 17.4.9　Python和POP3
**** 17.4.10　交互式POP3举例
**** 17.4.11　poplib.POP3类方法
**** 17.4.12　客户端程序SMTP和POP3举例
**** 17.5　相关模块
**** 17.5.1　电子邮件
**** 17.5.2　其他网络协议
**** 17.6　练习
**** 第18章　多线程编程
**** 18.1　引言/动机
**** 18.2　线程和进程
**** 18.2.1　什么是进程
**** 18.2.2　什么是线程
**** 18.3　Python、线程和全局解释器锁
**** 18.3.1　全局解释器锁（GIL）
**** 18.3.2　退出线程
**** 18.3.3　在Python中使用线程
**** 18.3.4　没有线程支持的情况
**** 18.3.5　Python的threading模块
**** 18.4　thread模块
**** 18.5　threading模块
**** 18.5.1　Thread类
**** 18.5.2　斐波那契、阶乘和累加和
**** 18.5.3　threading模块中的其他函数
**** 18.5.4　生产者-消费者问题和Queue模块
**** 18.6　相关模块
**** 18.7　练习
**** 第19章　图形用户界面编程
**** 19.1　简介
**** 19.1.1　什么是Tcl、Tk和Tkinter
**** 19.1.2　安装和使用Tkinter　533
**** 19.1.3　客户端/服务器架构　534
**** 19.2　Tkinter与Python编程　534
**** 19.2.1　Tkinter模块：把Tk引入你的程序
**** 19.2.2　GUI程序开发简介
**** 19.2.3　顶层窗口：Tkinter.Tk（）
**** 19.2.4　Tk组件
**** 19.3　Tkinter举例
**** 19.3.1　标签组件
**** 19.3.2　按钮组件
**** 19.3.3　标签和按钮组件
**** 19.3.4　标签、按钮和进度条组件
**** 19.3.5　偏函数应用举例
**** 19.3.6　中级Tkinter范例
**** 19.4　其他GUI简介
**** 19.4.1　Tk Interface eXtensions （Tix）
**** 19.4.2　Python MegaWidgets （PMW）
**** 19.4.3　wxWidgets和wxPython
**** 19.4.4　GTK+和PyGTK
**** 19.5　相关模块和其他GUI
**** 19.6　练习
**** 第20章　Web编程
**** 20.1　介绍
**** 20.1.1　Web应用：客户端/服务器计算
**** 20.1.2　因特网
**** 20.2　使用Python进行Web应用：创建一个简单的Web客户端
**** 20.2.1　统一资源定位符
**** 20.2.2　urlparse模块
**** 20.2.3　urllib模块
**** 20.2.4　urllib2模块
**** 20.3　高级Web客户端
**** 20.4　CGI：帮助Web服务器处理客户端数据
**** 20.4.1　CGI介绍
**** 20.4.2　CGI应用程序
**** 20.4.3　cgi模块
**** 20.5　建立CGI应用程序
**** 20.5.1　建立Web服务器
**** 20.5.2　建立表单页
**** 20.5.3　生成结果页
**** 20.5.4　生成表单和结果页面
**** 20.5.5　全面交互的Web站点
**** 20.6　在CGI中使用Unicode编码
**** 20.7　高级CGI
**** 20.7.1　Mulitipart表单提交和文件的上传
**** 20.7.2　多值字段
**** 20.7.3　cookie
**** 20.7.4　使用高级CGI
**** 20.8　Web（HTTP）服务器
**** 20.9　相关模块
**** 20.10　练习
**** 第21章　数据库编程
**** 21.1　介绍
**** 21.1.1　持久存储
**** 21.1.2　基本的数据库操作和SQL语言
**** 21.1.3　数据库和Python
**** 21.2　Python数据库应用程序程序员接口（DB-API）
**** 21.2.1　模块属性
**** 21.2.2　连接对象
**** 21.2.3　游标对象
**** 21.2.4　类型对象和构造器
**** 21.2.5　关系数据库
**** 21.2.6　数据库和Python：接口程序
**** 21.2.7　使用数据库接口程序举例
**** 21.3　对象-关系管理器（ORM）
**** 21.3.1　考虑对象，而不是SQL
**** 21.3.2　Python和ORM
**** 21.3.3　雇员数据库举例
**** 21.3.4　总结
**** 21.4　相关模块
**** 21.5　练习
**** 第22章　扩展Python　623
**** 22.1　引言/动机
**** 22.1.1　什么是扩展
**** 22.1.2　为什么要扩展Python
**** 22.2　创建Python扩展
**** 22.2.1　创建您的应用程序代码
**** 22.2.2　用样板来包装你的代码
**** 22.2.3　编译
**** 22.2.4　导入和测试
**** 22.2.5　引用计数
**** 22.2.6　线程和全局解释器锁（GIL）
**** 22.3　相关话题
**** 22.4　练习
**** 第23章　其他话题
**** 23.1　Web服务
**** 23.2　用Win32的COM来操作微软Office
**** 23.2.1　客户端COM编程
**** 23.2.2 微软Excel
**** 23.2.3　微软Word　第1部分　Python核心
**** 23.2.4　微软PowerPoint
**** 23.2.5　微软Outlook
**** 23.2.6　中等规模的例子
**** 23.3　用Jython写Python和Java的程序
**** 23.3.1　什么是Jython
**** 23.3.2　Swing GUI开发（Java或者Python!）
**** 23.4　练习
**** 23.2.4　微软PowerPoint
**** 23.2.5　微软Outlook
**** 23.2.6　中等规模的例子
**** 23.3　用Jython写Python和Java的程序
**** 23.3.1　什么是Jython
**** 23.3.2　Swing GUI开发（Java或者Python!）
* core python
>>> abs(-4)
>>> myString = 'Hello World!'
>>> print myString
>>> myString
>>> user = raw_input('Enter login name: ')
>>> print 'Your login is:', user
>>> num = raw_input('Now enter a number: ')
>>> print 'Doubling your number: %d' % (int(num) * 2)
>>> help(raw_input)
+         -       *     /        //           % **
<        <=       >      >=      ==           != <>
and or not
>>> 2 < 4 and 2 == 4
>>> 2 > 4 or 2 < 4
>>> not 6.2 <= 6
>>> 3 < 4 < 5
变量和赋值
>>> miles = 1000.0
>>> name = 'Bob'
>>> counter = counter + 1
>>> kilometers = 1.609 * miles
int (有符号整数)
long (长整数)
bool (布尔值)
float (浮点值)
complex (复数)
>>> pystr[2:5]
>>> iscool[:2]
>>> iscool[3:]
列表和元组
>>>  aList = [1, 2, 3, 4] 
>>>  aList[2:]
元组也可以进行切片运算,得到的结果也是元组(不能被修改):
>>> aTuple = ('robots', 77, 93, 'try')
>>> aTuple[:3]
>>> aTuple[1] = 5
字典
>>> aDict = {'host': 'earth'} # create dict
>>> aDict['port'] = 80 # add to dict
if 语句
if expression:
if_suite
else:
else_suite
elif expression2:
while 循环
while expression:
while_suite
for item in ['e-mail', 'net-surfing', 'homework', 'chat']:
>>> for eachNum in range(3):
>>> for i, ch in enumerate(foo):
列表解析
>>> squared = [x ** 2 for x in range(4)]
>>> sqdEvens = [x ** 2 for x in range(8) if not x % 2]
文件和内建函数 open() 、file()
如何打开文件
handle = open(file_name, access_mode = 'r')
file_name 变量包含我们希望打开的文件的字符串名字, access_mode 中 'r' 表示读取,
'w' 表示写入, 'a' 表示添加。其它可能用到的标声还有 '+' 表示读写, 'b'表示二进制访
问. 如果未提供 access_mode , 默认值为 'r'。如果 open() 成功, 一个文件对象句柄会被
返回。所有后续的文件操作都必须通过此文件句柄进行。当一个文件对象返回之后, 我们就可
以访问它的一些方法, 比如 readlines() 和 close().文件对象的方法属性也必须通过句点属
性标识法访问(参阅下面的核心笔记)
下面有一些代码, 提示用户输入文件名, 然后打开一个文件, 并显示它的内容到屏幕上:
filename = raw_input('Enter file name: ')
fobj = open(filename, 'r')
for eachLine in fobj:
print eachLine,
fobj.close()
我们的代码没有用循环一次取一行显示, 而是做了点改变。我们一次读入文件的所有行,
然后关闭文件, 再迭代每一行输出。这样写代码的好处是能够快速完整的访问文件。内容输出
和文件访问不必交替进行。这样代码更清晰, 而且将不相关的任务区分开来。需要注意的一点
是文件的大小。 上面的代码适用于文件大小适中的文件。对于很大的文件来说, 上面的代码
会占用太多的内存, 这时你最好一次读一行。(下一节有一个好例子)
我们的代码中另一个有趣的语句是我们又一次在 print 语句中使用逗号来抑制自动生成
的换行符号。 为什么要这样做?因为文件中的每行文本已经自带了换行字符, 如果我们不抑
制 print 语句产生的换行符号, 文本在显示时就会有额外的空行产生。
file()内建函数是最近才添加到 Python 当中的。它的功能等同于 open(), 不过 file()
这个名字可以更确切的表明它是一个工厂函数。(生成文件对象)类似 int()生成整数对象,
dict()生成字典对象。在第 9 章, 我们详细介绍文件对象, 及它们的内建方法属性, 以及如
何访问本地文件系统。
错误和异常
try:
filename = raw_input('Enter file name: ')
fobj = open(filename, 'r')
for eachLine in fobj:
print eachLine, fobj.close()
except IOError, e:
print 'file open error:', e
程序员也可以通过使用 raise 语句故意引发一个异常。
>>> sys.stdout.write('Hello World!\n')
Hello World!
>>> sys.platform
'win32'
>>> sys.version
这些代码的输出与我们使用 print 语句完全相同。 唯一的区别在于这次调用了标准输出
的 write()方法,而且这次需要显式的在字符串中提供换行字符, 不同于 print 语句, write()
不会自动在字符串后面添加换行符号。
关于模块和导入, 你可以在第 12 章中得到更多有用的信息。在那里会详细介绍本章上面
所有提到的主题,希望我们提供的快速入门能达到你迅速使用 Python 开始工作的目标。
实用的函数
对新 Python 程序员有用的内建函数
    函数                描述
    dir([obj])        显示对象的属性,如果没有提供参数, 则显示全局变量的名字
    help([obj])        以一种整齐美观的形式 显示对象的文档字符串, 如果没有提供任何参
    数, 则会进入交互式帮助。
    int(obj)           将一个对象转换为整数
    len(obj)           返回对象的长度
    open(fn, mode) 以 mode('r' = 读, 'w'= 写)方式打开一个文件名为 fn 的文件
    range([[start,]stop[,step]) 返回一个整数列表。起始值为 start, 结束值为 stop - 1; start
    默认值为 0, step默认值为1。
    raw_input(str) 等待用户输入一个字符串, 可以提供一个可选的参数 str 用作提示信
    息。
    str(obj)           将一个对象转换为字符串
    type(obj)          返回对象的类型(返回值本身是一个 type 对象!)
    2–1. 变量, print 和字符串格式化运算符。启动交互式解释器。给一些变量赋值(字
符串,数值等等)并通过输入变量名显示它们的值。再用 print 语句做同样的事。这二者有
何区别? 也尝试着使用字符串格式运算符 %, 多做几次, 慢慢熟悉它。
2–2. P 程序输出, 阅读下面的 Python 脚本:
#!/usr/bin/env python
1+2*4
(a) 你认为这段脚本是用来做什么的?
(b) 你认为这段脚本会输出什么?
(c) 输入以上代码,并保存为脚本,然后运行它。它所做的与你的预期一样吗?为什么一
样/不一样?
(d) 这段代码单独执行和在交互解释器中执行有何不同?试一下,然后写出结果
(e) 如何改进这个脚本, 以便它能和你想像的一样工作?
2–3. 数值和运算符
启动交互解释器,使用 Python 对两个数值(任意类型)进行加、减、乘、除运算。然后使
用取余运算符来得到两个数相除的余数, 最后使用乘方运算符求 A 数的 B 次方。
2–4. 使用 raw_input()函数得到用户输入


(a) 创建一段脚本使用 raw_input() 内建函数从用户输入得到一个字符串,然后显示这个
用户刚刚键入的字符串。
(b) 添加一段类似的代码,不过这次输入的是数值。将输入数据转换为一个数值对象,(使
用 int()或其它数值转换函数) 并将这个值显示给用户看。(注意,如果你用的是早于 1.5 的版
本,你需要使用 string.ato*() 函数执行这种转换)
2–5. 循环和数字
分别使用 while 和 for 创建一个循环:
(a) 写一个 while 循环,输出整数从 0 到 10。(要确保是从 0 到 10, 而不是从 0 到 9 或
从 1 到 10)
(b) 做同 (a) 一样的事, 不过这次使用 range() 内建函数。
2–6. 条件判断 判断一个数是正数,还是负数, 或者等于 0. 开始先用固定的数值,然
后修改你的代码支持用户输入数值再进行判断。
2–7.
循环和字串 从用户那里接受一个字符串输入,然后逐字符显示该字符串。先用 while 循
环实现,然后再用 for 循环实现。
2–8. 循环和运算符 创建一个包含五个固定数值的列表或元组,输出他们的和。然后修
改你的代码为接受用户输入数值。 分别使用 while 和 for 循环实现。
2–9.
循环和运算符 创建一个包含五个固定数值的列表或元组,输出他们的平均值。本练习的难
点之一是通过除法得到平均值。 你会发现整数除会截去小数,因此你必须使用浮点除以得到更
精确的结果。 float()内建函数可以帮助你实现这一功能。
2–10.
带循环和条件判断的用户输入 使用 raw_input()函数来提示用户输入一个 1 和 100 之间的
数,如果用户输入的数满足这个条件,显示成功并退出。否则显示一个错误信息然后再次提示
用户输入数值,直到满足条件为止。
2–11.
带文本菜单的程序 写一个带文本菜单的程序,菜单项如下(1)取五个数的和 (2) 取五个
数的平均值....(X)退出。由用户做一个选择,然后执行相应的功能。当用户选择退出时程序
结束。这个程序的有用之处在于用户在功能之间切换不需要一遍一遍的重新启动你的脚本。                                                 (这
对开发人员测试自己的程序也会大有用处)
2–12. dir()内建函数


(a) 启动 Python 交互式解释器, 通过直接键入 dir()回车以执行 dir()内建函数。你看到
什么? 显示你看到的每一个列表元素的值,记下实际值和你想像的值
(b) 你会问, dir()函数是干什么的?我们已经知道在 dir 后边加上一对括号可以执行 dir()
内建函数, 如果不加括号会如何? 试一试。 解释器返回给你什么信息? 你认为这个信息表
示什么意思 ?
(c) type() 内建函数接收任意的 Python 对象做为参数并返回他们的类型。 在解释器中键
入 type(dir), 看看你得到的是什么?
(d) 本练习的最后一部分, 我们来瞧一瞧 Python 的文档字符串。 通过 dir.__doc__ 可
以访问 dir()内建函数的文档字符串。print dir.__doc__可以显示这个字符串的内容。 许多内建
函数,方法,模块及模块属性都有相应的文档字符串。我们希望你在你的代码中也要书写文档
字符串, 它会对使用这些代码的人提供及时方便的帮助。
2–13. 利用 dir() 找出 sys 模块中更多的东西。
(a) 启动 Python 交互解释器,执行 dir()函数,然后键入 import sys 以导入 sys 模块。
再次执行 dir()函数以确认 sys 模块被正确的导入。 然后执行 dir(sys) , 你就可以看到 sys
模块的所有属性了。
(b) 显示 sys 模块的版本号属性及平台变量。记住在属性名前一定要加 sys. ,这表示
这个属性是 sys 模块的。其中 version 变量保存着你使用的 Python 解释器版本, platform
属性则包含你运行 Python 时使用的计算机平台信息。
(c) 最后, 调用 sys.exit() 函数。 这是一种热键之外的另一种退出 Python 解释器的方
式 。
2–14. 重写 2.4 小节中 print 语句里的算术表达式, 试着在这个表达式中添加合适的
括号以便它能正常工作。
2–15. 元素排序
(a)让用户输入三个数值并将分别将它们保存到 3 个不同的变量中。不使用列表或排序算法,
自己写代码来对这三个数由小到大排序。(b)修改(a)的解决方案,使之从大到小排序
2–16. 文件
键入 2.15 节的文件显示的代码, 然后运行它, 看看能否在你的系统上正常工作,然后试
一下其它的输入文件。


Python基础 
本章主题
z 语句和语法
z 变量赋值
z 标识符和关键字
z 基本风格指南
z 内存管理
z 第一个 Python 程序


我们下一个目标是了解基本的 Python 语法,介绍一些基本的编程风格,之后简要介绍一
下标识符、变量和关键字。我们也会讨论变量占用的内存是如何分配和回收的。最后,我们会
给出一个较大的 Python 样例程序,让你实际体验一下这些特性。无须担心,在你畅游 Python
的过程中有很多救生员在保护着你。
3.1      语句和语法
Python 语句中有一些基本规则和特殊字符:
z 井号(#)表示之后的字符为 Python 注释
z 换行 (\n) 是标准的行分隔符(通常一个语句一行)
z 反斜线 ( \ ) 继续上一行
z 分号 ( ; )将两个语句连接在一行中
z 冒号 ( : ) 将代码块的头和体分开
z 语句(代码块)用缩进块的方式体现
z 不同的缩进深度分隔不同的代码块
z Python 文件以模块的形式组织
3.1.1    注释( # )


首要说明的事情是:尽管 Python 是可读性最好的语言之一,这并不意味着程序员在代码中
就可以不写注释。和很多 Unix 脚本类似,Python 注释语句从 # 字符开始,注释可以在一行
的任何地方开始,解释器会忽略掉该行 # 之后的所有内容。要正确的使用注释。
3.1.2       继续( \ )
Python 语句,一般使用换行分隔,也就是说一行一个语句。一行过长的语句可以使用反斜
杠( \ ) 分解成几行,如下例:
# check conditions
if (weather_is_hot == 1) and \
(shark_warnings == 0):
send_goto_beach_mesg_to_pager()
有两种例外情况一个语句不使用反斜线也可以跨行。在使用闭合操作符时,单一语句可以
跨多行,例如:在含有小括号、中括号、花括号时可以多行书写。另外就是三引号包括下的字
符串也可以跨行书写。如下例:
# display a string with triple quotes
print'''hi there, this is a long message for you
that goes over multiple lines... you will find
out soon that triple quotes in Python allows
this kind of fun! it is like a day on the beach!'''
# set some variables
go_surf, get_a_tan_while, boat_size, toll_money = (1,'windsurfing', 40.0, -2.00)
如果要在使用反斜线换行和使用括号元素换行作一个选择,我们推荐使用括号,这样可读
性会更好。
3.1.3       多个语句构成代码组(:):
缩进相同的一组语句构成一个代码块,我们称之代码组。像 if、while、def 和 class 这样
的复合语句,首行以关键字开始,以冒号( : )结束,该行之后的一行或多行代码构成代码组。
我们将首行及后面的代码组称为一个子句(clause)。


3.1.4    代码组由不同的缩进分隔
我们在章节 2.10 中曾提到,Python 使用缩进来分隔代码组。代码的层次关系是通过同样
深度的空格或制表符缩进体现的。同一代码组的代码行必须严格左对齐(左边有同样多的空格
或同样多的制表符),如果不严格遵守这个规则,同一组的代码就可能被当成另一个组,甚至
会导致语法错误。
核心风格:缩进四个空格宽度,避免使用制表符
对一个初次使用空白字符作为代码块分界的人来说,遇到的第一个问题是:缩进多大宽度
才合适?两个太少,六到八个又太多,因此我们推荐使用四个空格宽度。需要说明一点,不同
的文本编辑器中制表符代表的空白宽度不一,如果你的代码要跨平台应用,或者会被不同的编
辑器读写,    建议你不要使用制表符。使用空格或制表符这两种风格都得到了 Python 创始人 Guido
van Rossum 的支持,并被收录到 Python 代码风格指南文档。在本章第 3.4 小节中你会看到同
样的建议。
随着缩进深度的增加,代码块的层次也在加深,没有缩进的代码块是最高层次的,别称做
脚本的“main”部分。
使用缩进对齐这种方式组织代码,不但代码风格优雅,而且也大大提高了代码的可读性。
而且它有效的避免了"悬挂 else"(dangling-else)问题,和未写大括号的单一子句问题。(如
果 C 语言中 if 语句没写大括号,而后面却跟着两个缩近的语句,这会造成不论条件表达式是
否成立,第二个语句总会执行。这种问题很难调试,不知道困惑了多少程序员。)
最后一点,由于 Python 只使用缩进方式表达代码块逻辑,因此“神圣的大括号战争”永远
不会发生在 Python 身上。C、C++和 Java 语言中,开始大括号可以在第一行的尾部,也可以在
第二行的头部,也可以在第二行空几格后开始,这就造成不同的人选择不同的风格,于是你就
会看到大括号战争的场景了。
3.1.5    同一行书写多个语句(;)
分号( ; )允许你将多个语句写在同一行上,语句之间用分号隔开,而这些语句也不能在这
行开始一个新的代码块。这里有一个例子:


import sys; x = 'foo'; sys.stdout.write(x + '\n')
必须指出一点, 同一行上书写多个语句会大大降低代码的可读性,Python 虽然允许但不
提倡你这么做。
3.1.6       模块
每一个 Python 脚本文件都可以被当成是一个模块。模块以磁盘文件的形式存在。当一个模
块变得过大,并且驱动了太多功能的话,就应该考虑拆一些代码出来另外建一个模块。模块里
的代码可以是一段直接执行的脚本,也可以是一堆类似库函数的代码,从而可以被别的模块导
入(import)调用。记得我们在上一章中曾提到过,模块可以包含直接运行的代码块、类定义、
函数定义或这几者的组合。
3.2         变量赋值
本节主题是变量赋值。我们将在 3.3 小节中讨论什么样的标识符才是合法的变量名。
赋值运算符
Python 语言中, 等号(=)是主要的赋值运算符。(其他的是增量赋值运算符,参见下节)
anInt = -12
aString = 'cart'
aFloat = -3.1415 * (5.0 ** 2)
anotherString = 'shop' + 'ping'
aList = [3.14e10, '2nd elmt of a list', 8.82-4.371j]
注意,赋值并不是直接将一个值赋给一个变量, 尽管你可能根据其它语言编程经验认为应
该如此。在 Python 语言中,对象是通过引用传递的。在赋值时,不管这个对象是新创建的,还
是一个已经存在的,都是将该对象的引用(并不是值)赋值给变量。如果此刻你还不是 100%理
解清楚,也不用着急。 在本章的后面部分,我们还会再讨论这个话题, 现在你只需要有这么
一个概念即可。
同样的, 如果你比较熟悉 C, 你会知道赋值语句其实是被当成一个表达式(可以返回值)。


不过这条并不适合于 Python, Python 的赋值语句不会返回值。类似下面的语句在 Python 中是
非法的:
>>> x = 1
>>> y = (x = x + 1)     # assignments not expressions! File "<stdin>", line 1
y = (x = x + 1)
^
SyntaxError: invalid syntax
链式赋值没问题, 看(本章稍后部分会给出更多的例子):
>>> y = x = x + 1
>>> x, y
(2, 2)
增量赋值
从 Python 2.0 开始, 等号可以和一个算术运算符组合在一起, 将计算结果重新赋值给
左边的变量。这被称为增量赋值, 类似下面这样的语句:
x = x + 1
现在可以被写成:
x += 1
增量赋值通过使用赋值运算符,将数学运算隐藏在赋值过程当中。如果您用过 C、C++或者
Java,会觉得下面的运算符很熟悉。
+=      -=      *=     /=      %=         **=
<<=     >>=     &=     ^=      |=
增量赋值相对普通赋值不仅仅是写法上的改变,最有意义的变化是第一个对象(我们例子
中的 A)仅被处理一次。可变对象会被就地修改(无修拷贝引用), 不可变对象则和 A = A +


B 的结果一样(分配一个新对象),我们前面提到过,有一个例外就是 A 仅被求值一次。
>>> m = 12
>>> m %= 7
>>> m
5
>>> m **= 2
>>> m
25
>>> aList = [123, 'xyz']
>>> aList += [45.6e7]
>>> aList
[123, 'xyz', 456000000.0]
Python 不支持类似 x++ 或 --x 这样的前置/后置自增/自减运算。
多重赋值
>>> x = y = z = 1
>>> x
1
>>> y
1
>>> z
1
在上面的例子中,一个值为 1 的整数对象被创建,该对象的同一个引用被赋值给 x、y 和
z 。也就是将一个对象赋给了多个变量。当然,在 Python 当中,将多个对象赋给多个变量也是
可以的。
“多元”赋值
另一种将多个变量同时赋值的方法我们称为多元赋值(multuple)。这不是官方 Python 术
语, 而是我们将 "mul-tuple"连在一起自造的。因为采用这种方式赋值时, 等号两边的对象
都是元组(我们在 2.8 节讲过元组是一种 Python 基本数据类型)。
>>> x, y, z = 1, 2, 'a string'
>>> x


1
>>> y
2
>>> z
'a string'
在上面的例子里, 两个整数对象(值分别为 1 和 2)及一个字符串对象, 被分别赋值给
x, y 和 z。通常元组需要用圆括号(小括号)括起来,尽管它们是可选的。我们建议总是加上
圆括号以使得你的代码有更高的可读性。
>>> (x, y, z) = (1, 2, 'a string')
在其它类似 C 的语言中, 如果你要交换两个值, 你会想到使用一个临时变量比如 tmp 来
临时保存其中一个值:
/* C 语言中两个变量交换 */
tmp = x;
x = y;
y = tmp;
在上面的 C 代码片段中,变量 x 和变量 y 的值被互相交换。 临时变量 tmp 用于在将 y 赋
值给 x 前先保存 x 的值。将 y 的值赋给 x 之后, 才可以将保存在 tmp 变量中的 x 的值赋给 y。
Python 的多元赋值方式可以实现无需中间变量交换两个变量的值。
# swapping variables in Python
>>> x, y = 1, 2
>>> x
1
>>> y
2
>>> x, y = y, x
>>> x
2
>>> y
1
显然, Python 在赋值之前已经事先对 x 和 y 的新值做了计算。


3.3     标识符
标识符是电脑语言中允许作为名字的有效字符串集合。其中,有一部分是关键字,构成语
言的标识符。这样的标识符是不能做它用的标识符的,否则会引起语法错误(SyntaxError 异
常)。
Python 还有称为 built-in 标识符集合,虽然它们不是保留字,但是不推荐使用这些特别
的名字(见 3.3.3)。
3.3.1    合法的 Python 标识符
Python 标识符字符串规则和其他大部分用 C 编写的高级语言相似:
z 第一个字符必须是字母或下划线(_)
z 剩下的字符可以是字母和数字或下划线
z 大小写敏感
标识符不能以数字开头;除了下划线,其他的符号都不允许使用。处理下划线最简单的方
法是把它们当成字母字符。大小写敏感意味着标识符 foo 不同于 Foo,而这两者也不同于 FOO。
3.3.2   关键字
Python 的关键字列在表 3.1 中。一般来说,任何语言的关键字应该保持相对的稳定,但是
因为 Python 是一门不断成长和进化的语言,关键字列表和 iskeyword()函数都放入了 keyword
模块以便查阅。


a.      从 Python1.4 开始关键字 access 就被废除了
b.   Python2.6 时加入
c.      Python1.5 时加入
d.   Python2.3 时加入
e.      Python2.4 中非关键字常量
3.3.3    内建
除了关键字之外,Python 还有可以在任何一级代码使用的“内建”的名字集合,这些名字
可以由解释器设置或使用。虽然 built-in 不是关键字,但是应该把它当作“系统保留字”,不
做他用。然而,有些情况要求覆盖(也就是:重定义,替换)它们。Python 不支持重载标识符,
所以任何时刻都只有一个名字绑定。
我们还可以告诉高级读者 built-in 是__builtins__模块的成员,在你的程序开始或在交互
解释器中给出>>>提示之前,由解释器自动导入的。把它们看成适用在任何一级 Python 代码的
全局变量。
3.3.4     专用下划线标识符
Python 用下划线作为变量前缀和后缀指定特殊变量。稍后我们会发现,对于程序来说,其
中的有些变量是非常有用的,而其他的则是未知或无用的。这里对 Python 中下划线的特殊用法


做了总结:
z  _xxx    不用'from module import *'导入
z  __xxx__系统定义名字
z  __xxx   类中的私有变量名
核心风格:避免用下划线作为变量名的开始
因为下划线对解释器有特殊的意义,而且是内建标识符所使用的符号,我们建议程序员避
免用下划线作为变量名的开始。一般来讲,变量名_xxx 被看作是“私有的”,在模块或类外不
可以使用。当变量是私有的时候,用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对
Python 来说有特殊含义,对于普通的变量应当避免这种命名风格。
3.4    基本风格指南
注释
注释对于自己和后来人来说都是非常重要的,特别是对那些很久没有被动过的代码而言,
注释更显得有用了。既不能缺少注释,也不能过度使用注释。尽可能使注释简洁明了,并放在
最合适的地方。这样注释便为每个人节省了时间和精力。记住,要确保注释的准确性。
文档
Python 还提供了一个机制,可以通过__doc__特别变量,动态获得文档字串。在模块,类
声明,或函数声明中第一个没有赋值的字符串可以用属性 obj.__doc__来进行访问,其中 obj
是一个模块,类,或函数的名字。这在运行时刻也可以运行。
缩进
因为缩进对齐有非常重要的作用,您得考虑用什么样的缩进风格才让代码容易阅读。在选
择要空的格数的时候,常识也起着非常大的作用。
1 或 2     可能不够,很难确定代码语句属于哪个块
8 至 10 可能太多,如果代码内嵌的层次太多,就会使得代码很难阅读。四个空格非常的
流行,更不用说 Python 的创造者也支持这种风格。五和六个也不坏,但是文本编辑器通常不支
持这样的设置,所以也不经常使用。三个和七个是边界情况。


当使用制表符 Tab 的时候,请记住不同的文本编辑器对它的设置是不一样。推荐您不要
使用 Tab,如果您的代码会存在并运行在不同的平台上,或者会用不同的文本编辑器打开,推
荐您不要使用 Tab。
选择标识符名称
好的判断也适用于选择标志符名称,请为变量选择短而意义丰富的标识符。虽然变量名的
长度对于今天的编程语言不再是一个问题,但是使用简短的名字依然是个好习惯,这个原则同
样使用于模块(Python 文件)的命名。
Python 风格指南
Guido van Rossum 在多年前写下 Python 代码风格指南。目前它已经被至少三个 PEP 代替:
7(C 代码风格指南)、8(Python 代码风格指南)和 257(文档字符串规范)。这些 PEP 被归
档、维护并定期更新。
渐渐的,你会听到“Pythonic”这个术语,它指的是以 Python 的方式去编写代码、组织
逻辑,及对象行为。更多时间过后,你才会真正理解它的含义。PEP 20 写的是 Python 之禅,
你可以从那里开始你探索“Pythonic”真正含义的旅程。如果你不能上网,但想看到这篇诗句,
那就从你的 Python 解释器输入 import this 然后回车。下面是一些网上资源:
www.Python.org/doc/essays/styleguide.html
www.Python.org/dev/peps/pep-0007/
www.Python.org/dev/peps/pep-0008/
www.Python.org/dev/peps/pep-0020/
www.Python.org/dev/peps/pep-0257/
3.4.1      模块结构和布局
用模块来合理组织你的 Python 代码是简单又自然的方法。你应该建立一种统一且容易阅读
的结构,并将它应用到每一个文件中去。下面就是一种非常合理的布局:
# (1) 起始行(Unix)
# (2) 模块文档


# (3) 模块导入
# (4) 变量定义
# (5) 类定义
# (6) 函数定义
# (7) 主程序
图 3–1 一个典型模块的内部结构图解。
(1)    起始行
通常只有在类 Unix 环境下才使用起始行,有起始行就能够仅输入脚本名字来执行脚本,无
需直接调用解释器。
(2)模块文档
简要介绍模块的功能及重要全局变量的含义,模块外可通过 module.__doc__ 访问这些内
容。
(3)模块导入
导入当前模块的代码需要的所有模块;每个模块仅导入一次(当前模块被加载时);函数
内部的模块导入代码不会被执行, 除非该函数正在执行。
(4)变量定义
这里定义的变量为全局变量,本模块中的所有函数都可直接使用。从好的编程风格角度说,
除非必须,否则就要尽量使用局部变量代替全局变量,如果坚持这样做,你的代码就不但容易
维护,而且还可以提高性能并节省内存。
(5)类定义语句
所有的类都需要在这里定义。当模块被导入时 class 语句会被执行, 类也就会被定义。类
的文档变量是 class.__doc__。
(6)函数定义语句
此处定义的函数可以通过 module.function()在外部被访问到,当模块被导入时 def 语句
会被执行, 函数也就都会定义好,函数的文档变量是 function.__doc__。
(7) 主程序
无论这个模块是被别的模块导入还是作为脚本直接执行,都会执行这部分代码。通常这里
不会有太多功能性代码,而是根据执行的模式调用不同的函数。


Figure 3–1 Typical Python file structure
推荐代码风格:主程序调用 main()函数
主程序代码通常都和你前面看到的代码相似,检查 __name__ 变量的值然后再执行相应的
调用(参阅下一页的核心笔记)。主程序中的代码通常包括变量赋值, 类定义和函数定义,随
后检查__name__来决定是否调用另一个函数(通常调用 main()函数)来完成该模块的功能。主
程序通常都是做这些事。(我们上面的例子中使用 test()而不是 main()是为了避免你在读到核
心笔记前感到迷惑。) 不管用什么名字,我们想强调一点那就是:这儿是放置测试代码的好地
方。我们在 3.4.2 小节中曾经说过,大部分的 Python 模块都是用于导入调用的,直接运行模块
应该调用该模块的回归测试代码。
很多项目都是一个主程序,由它导入所有需要的模块。所以请记住,绝大部分的模块创建
的目的是为了被别人调用而不是作为独立执行的脚本。我们也很可能创建一个 Python 库风格的


模块,这种模块的创建目的就是为了被其他模块调用。总之,只有一个模块,也就是包含主程
序的模块会被直接执行,或由用户通过命令行执行,或作为批处理执行, 或由 Unix cron 任务
定时执行,或通过 Web 服务器调用,或通过 GUI 执行。
时刻记住一个事实,那就是所有的模块都有能力来执行代码。最高级别的 Python 语句--
也就是说, 那些没有缩进的代码行在模块被导入时就会执行, 不管是不是真的需要执行。由
于有这样一个“特性”,比较安全的写代码的方式就是除了那些真正需要执行的代码以外, 几
乎所有的功能代码都在函数当中。再说一遍, 通常只有主程序模块中有大量的顶级可执行代码,
所有其它被导入的模块只应该有很少的顶级执行代码,所有的功能代码都应该封装在函数或类
当中。
(参阅核心笔记了解更多信息)
核心笔记:__name__ 指示模块应如何被加载
由于主程序代码无论模块是被导入还是被直接执行都会运行, 我们必须知道模块如何决定
运行方向。一个应用程序可能需要导入另一个应用程序的一个模块,以便重用一些有用的代码
(否则就只能用拷贝粘贴那种非面向对象的愚蠢手段)。这种情况下,你只想访问那些位于其
它应用程序中的代码,而不是想运行那个应用程序。因此一个问题出现了,“Python 是否有
一种方法能在运行时检测该模块是被导入还是被直接执行呢?” 答案就是......(鼓声雷
动).....没错! __name__ 系统变量就是正确答案。
如果模块是被导入, __name__ 的值为模块名字
如果模块是被直接执行, __name__ 的值为 '__main__'
3.4.2  在主程序中书写测试代码
优秀的程序员和软件工程师,总是会为我们的应用程序提供一组测试代码或者简单教程。
对那些仅仅为了让别的程序导入而创建的模块来说, Python 有效的简化了这个任务。这些模
块理论上永远不会被直接执行, 那么,在这个模块被直接执行时进行系统测试岂不妙哉? 设
置起来难吗? 一点儿也不。
测试代码仅当该文件被直接执行时运行, 也就是说不是被别的模块导入时。上文及核心笔
记中提到如何判断一个模块是被直接运行还是被导入。我们应该利用 __name__ 变量这个有利
条件。将测试代码放在一个或者叫 main(), 或者叫 test()(或者你随便取个啥名字)的函数中,


如果该模块是被当成脚本运行, 就调用这个函数。
这些测试代码应该随着测试条件及测试结果的变更及时修改, 每次代码更新都应该运行这
些测试代码,以确认修改没有引发新问题。只要坚持这样做,你的代码就会足够健壮,更不用
提验证和测试新特性和更新了。
在主程序中放置测试代码是测试模块的简单快捷的手段。Python 标准库中还提供了
unittest 模块, 有时候它被称为 PyUnit, 是一个测试框架。如何使用 unittest 超出了本书
的范围, 不过当需要对一个大系统的组件进行正规系统的回规测试时,它就会派上用场。
3.5         内存管理
到现在为止, 你已经看了不少 Python 代码的例子。我们本节的主题是变量和内存管理的
细节, 包括:
z 变量无须事先声明
z      变量无须指定类型
z      程序员不用关心内存管理
z      变量名会被“回收”
z      del 语句能够直接释放资源
3.5.1       变量定义
大多数编译型语言,变量在使用前必须先声明,其中的 C 语言更加苛刻:变量声明必须位
于代码块最开始,且在任何其他语句之前。其它语言,像 C++和 Java,允许“随时随地”声明
变量,比如,变量声明可以在代码块的中间,不过仍然必须在变量被使用前声明变量的名字和
类型。在 Python 中,无需此类显式变量声明语句,变量在第一次被赋值时自动声明。和其他大
多数语言一样,变量只有被创建和赋值后才能被使用。
>>> a
Traceback (innermost last):
File "<stdin>", line 1, in ?
NameError: a


变量一旦被赋值,您就可以通过变量名来访问它。
>>> x = 4
>>> y = 'this is a string'
>>> x
4
>>> y
'this is a string'
3.5.2      动态类型
还要注意一点,Python 中不但变量名无需事先声明,而且也无需类型声明。Python 语言中,
对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码,Python 仍然是一种解释
型语言。在创建--也就是赋值时,解释器会根据语法和右侧的操作数来决定新对象的类型。
在对象创建后,一个该对象的应用会被赋值给左侧的变量。
3.5.3      内存分配
作为一个负责任的程序员,我们知道在为变量分配内存时,是在借用系统资源,在用完之
后, 应该释放借用的系统资源。Python 解释器承担了内存管理的复杂任务, 这大大简化了应
用程序的编写。你只需要关心你要解决的问题,至于底层的事情放心交给 Python 解释器去做就
行了。
3.5.4      引用计数
要保持追踪内存中的对象, Python 使用了引用计数这一简单技术。也就是说 Python 内部
记录着所有使用中的对象各有多少引用。你可以将它想像成扑克牌游戏“黑杰克”或“21 点”。
一个内部跟踪变量,称为一个引用计数器。至于每个对象各有多少个引用, 简称引用计数。当
对象被创建时, 就创建了一个引用计数, 当这个对象不再需要时, 也就是说, 这个对象的
引用计数变为 0 时, 它被垃圾回收。(严格来说这不是 100%正确,不过现阶段你可以就这么
认为)
增加引用计数


当对象被创建并(将其引用)赋值给变量时,该对象的引用计数就被设置为 1。
当同一个对象(的引用)又被赋值给其它变量时,或作为参数传递给函数, 方法或类实例
时, 或者被赋值为一个窗口对象的成员时,该对象的一个新的引用,或者称作别名,就被创建
(则该对象的引用计数自动加 1)。
图 3–2 有两个引用的同一对象
请看以下声明:
x = 3.14
y = x
语句 x=3.14 创建了一个浮点数对象并将其引用赋值给 x。 x 是第一个引用, 因此,该
对象的引用计数被设置为 1。语句 y=x 创建了一个指向同一对象的别名 y(参阅图 3-2)。事
实上并没有为 Y 创建一个新对象, 而是该对象的引用计数增加了 1 次(变成了 2)。这是对象
引用计数增加的方式之一。还有一些其它的方式也能增加对象的引用计数, 比如该对象作为参
数被函数调用或这个对象被加入到某个容器对象当中时。
总之,对象的引用计数在
z 对象被创建
x = 3.14
z 或另外的别名被创建
y = x
z 或被作为参数传递给函数(新的本地引用)
foobar(x)


z 或成为容器对象的一个元素
myList = [123, x, 'xyz']
下面让我们来看一下引用计数是如何变少的。
减少引用计数
当对象的引用被销毁时,引用计数会减小。最明显的例子就是当引用离开其作用范围时,
这种情况最经常出现在函数运行结束时,所有局部变量都被自动销毁,对象的引用计数也就随
之减少。
当变量被赋值给另外一个对象时,原对象的引用计数也会自动减 1:
foo = 'xyz'
bar = foo
foo = 123
当字符串对象"xyz"被创建并赋值给 foo 时, 它的引用计数是 1. 当增加了一个别名 bar
时, 引用计数变成了 2. 不过当 foo 被重新赋值给整数对象 123 时, xyz 对象的引用计数自
动减 1,又重新变成了 1.
其它造成对象的引用计数减少的方式包括使用 del 语句删除一个变量(参阅下一节), 或
者当一个对象被移出一个窗口对象时(或该容器对象本身的引用计数变成了 0 时)。 总结一下,
一个对象的引用计数在以下情况会减少:
z 一个本地引用离开了其作用范围。比如 foobar()(参见上一下例子)函数结束时。
z 对象的别名被显式的销毁。
del y     # or del x
z 对象的一个别名被赋值给其它的对象
x = 123
z 对象被从一个窗口对象中移除
myList.remove(x)
z 窗口对象本身被销毁
del myList        # or goes out-of-scope


参阅 11.8 了解更多变量作用范围的信息。
del 语句
Del 语句会删除对象的一个引用,它的语法是:
del obj1[, obj2[,... objN]]
例如,在上例中执行 del y 会产生两个结果:
z   从现在的名字空间中删除 y
z   x 的引用计数减一
引申一步, 执行 del x 会删除该对象的最后一个引用, 也就是该对象的引用计数会减为
0, 这会导致该对象从此“无法访问”或“无法抵达”。 从此刻起, 该对象就成为垃圾回收
机制的回收对象。 注意任何追踪或调试程序会给一个对象增加一个额外的引用, 这会推迟该
对象被回收的时间。
3.5.5      垃圾收集
不再被使用的内存会被一种称为垃圾收集的机制释放。象上面说的, 虽然解释器跟踪对象
的引用计数, 但垃圾收集器负责释放内存。垃圾收集器是一块独立代码, 它用来寻找引用计
数为 0 的对象。它也负责检查那些虽然引用计数大于 0 但也应该被销毁的对象。 特定情形会导
致循环引用。
一个循环引用发生在当你有至少两个对象互相引用时, 也就是说所有的引用都消失时, 这
些引用仍然存在, 这说明只靠引用计数是不够的。Python 的垃圾收集器实际上是一个引用计
数器和一个循环垃圾收集器。 当一个对象的引用计数变为 0,解释器会暂停,释放掉这个对象
和仅有这个对象可访问(可到达)的其它对象。作为引用计数的补充, 垃圾收集器也会留心被
分配的总量很大(及未通过引用计数销毁的那些)的对象。 在这种情况下, 解释器会暂停下
来, 试图清理所有未引用的循环。
3.6     第一个 Python 程序


我们已经熟悉了语法、代码风格、变量赋值及内存分配,现在来看一点略微复杂的代码。
这个例子中还有你不熟悉(我们还未讲到的)的 Python 结构,不过我们相信因为 Python 非常
的简单和优雅,你一定可以弄懂每一行代码的用途。
我们将要介绍两段处理文本文件的相关脚本。首先, makeTextFile.py, 创建一个文本文
件。 它提示用户输入每一行文本, 然后将结果写到文件中。另一个 readTextFile.py 读取并
显示该文本文件的内容。 研究一下这两段代码, 看看他们是如何工作的。
例 3.1    创建文件(makeTextFile.py)
这个脚本提醒用户输入一个(尚不存在的)文件名, 然后由用户输入该文件的每一行。最
后, 将所有文本写入文本文件。
1 #!/usr/bin/env python
2
3'makeTextFile.py -- create text file'
4
5import os
6 ls = os.linesep
7
8# get filename
9 while True:
10
11 if os.path.exists(fname):
12 print "ERROR: '%s' already exists" % fname
13 else:
14 break
15
16 # get file content (text) lines
17 all = []
18 print "\nEnter lines ('.' by itself to quit).\n"
19
20 # loop until user terminates input
21 while True:
22 entry = raw_input('> ')
23 if entry == '.':
24 break
25 else:


26 all.append(entry)
27
28 # write lines to file with proper line-ending
29 fobj = open(fname, 'w')
30 fobj.writelines(['%s%s' % (x, ls) for x in all])
31 fobj.close()
32 print 'DONE!'
第 1–3 行
UNIX 启动行之后是模块的文档字符串。应该坚持写简洁并有用的文档字符串。这里我们写
的有点短,不过对这段代码已经够用。(建议读者看一下标准库中 cgi 模块的文档字符串,那
是一个很好的示例)
第 5–6 行
之后我们导入 os 模块, 在第 6 行我们为 os.linesep 属性取了一个新别名。这样做一方
面可以缩短变量名, 另一方面也能改善访问该变量的性能。
核心技巧:使用局部变量替换模块变量
类似 os.linesep 这样的名字需要解释器做两次查询:                    (1)查找 os 以确认它是一个模块,
(2)在这个模块中查找 linesep 变量。因为模块也是全局变量, 我们多消耗了系统资源。如
果你在一个函数中类似这样频繁使用一个属性,我们建议你为该属性取一个本地变量别名。 变
量查找速度将会快很多--在查找全局变量之前, 总是先查找本地变量。 这也是一个让你的
程序跑的更快的技巧: 将经常用到的模块属性替换为一个本地引用。代码跑得更快,而也不用
老是敲那么长的变量名了。在我们的代码片段中,并没有定义函数,所以不能给你定义本地别
名的示例。不过我们有一个全局别名,至少也减少了一次名字查询
第 8–14 行
显然这是一个无限循环, 也就是说除非我们在 while 语句体提供 break 语句, 否则它会
一直循环下去。
while 语句根据后面的表达式决定是否进行下一次循环, 而 True 则确保它一直循环下去。
第 10-14 行提示用户输入一个未使用的文件名。 raw_input() 内建函数接受一个“提示
字符串”参数,作为对用户的提示信息。raw_input()返回用户输入的字符串,也就是为 fname


赋值。 如果用户不小心输入了一个已经存在的文件的名字,我们要提示这个用户重新输入另一
个名字。 os.path.exists() 是 os 模块中一个有用的函数, 帮助我们确认这一点。 当有输
入一个不存在的文件名时, os.path.exists() 才会返回 False, 这时我们中断循环继续下面
的代码。
第 16–26 行
这部分代码提供用户指令,引导用户输入文件内容,一次一行。我们在第十七行初始化了
列表 all,它用来保存每一行文本。第 21 行开始另一个无限循环, 提示用户输入每一行文本,
一行仅输入一个句点 '.' 表示输入结束。 23-26 行的 if-else 语句判断是否满足结束条件
以中止循环(行 24), 否则就再添加新的一行。
第 28–32 行
现在所有内容都保存在内存当中, 我们需要将它们保存到文件。 第 29 行打开文件准备进
行写操作,第 30 行将内存中的内容逐行写入文件。每个文件都需要一个行结束符(或文件结束
字符)。 第 30 行的结构称为列表解析, 它做以下事: 对我们文件的每一行, 根据程序运行
平台添加一个合适的行结束符。 '%s%s' 为每一行添加行结束符,(x, ls)表示每一行及其行
结束符, 对 Unix 平台,是'\n', 对 DOS 或 win32 平台,则是 '\r\n'。通过使用 os.lineseq ,
我们不必关心程序运行在什么平台,也不必要根据不同的平台决定使用哪种行结束符。 文件
对象的 writelines() 方法接收包含行结束符的结果列表,并将它写入文件
不错吧。现在来看一下如何查看刚刚创建的文件。出于这个目的,我们创建了第二个 Python
脚本, readTextFile.py。你会看到,它比 makeTextFile.py 短的多。创建一个文件的复杂度
总是比读取它要大。你可能感兴趣的、有新意的一点在于异常处理的出现。
第 1–3 行
和前面一样, 是 Unix 启动行及模块文档字符串。
第 5–7 行
不同于 makeTextFil.py, 我们在这个例子中不再关心用户是否输入合适的文件名。
Example 3.2 File Read and Display (readTextFile.py)


1     #!/usr/bin/env Python
2
3     'readTextFile.py -- read and display text file'
4
5     # get filename
6     fname = raw_input('Enter filename: ')
7     print
8
9     # attempt to open file for reading
10 try:
11    fobj = open(fname, 'r')
12 except IOError, e:
13    print "*** file open error:", e
14 else:
15    # display contents to the screen
16    for eachLine in fobj:
17    print eachLine,
18    fobj.close()
换句话说, 我们在其它地方进行验证工作(如果需要)。第 7 行打印一个空行以便将提
示信息和文件内容分隔开来。
第 9–18 行
脚本的剩余部分展示了一种新的 Python 结构, try-except-else 语句。try 子句是一段
我们希望监测错误的代码块。 在第 10-11 行代码,我们尝试打开用户输入的文件。except 子
句是我们处理错误的地方。在 12-13 行,我们检查 open() 是否失败-通常是 IOError 类型
的错误。
最后,14-18 行的 else 子句在 try 代码块运行无误时执行。我们在这儿将文件的每一行
显示在屏幕上。注意由于我们没有移除代表每行结束的行结束符,我们不得不抵制 print 语句
自动生成的行结束符 --通过在 print 语句的最后加一个逗号可以达到这一目的。 第 18 行关
闭文件,从而结束这段脚本。
最后要讲的一点是关于使用 os.path.exists() 和异常处理:一般程序员倾向于使用前者,
因为有一个现成的函数可以检查错误条件 -- 并且很简单, 这是个布尔函数, 它会告你“是”
还是“不是”。 (注意,这个函数内可能已经有异常处理代码)。那你为什么还要重新发明一


个轮子来干同样一件事?异常处理最适用的场合,是在没有合适的函数处理异常状况的时候。
这时程序员必须识别这些非正常的错误,并做出相应处理。对我们的例子来说, 我们能够通过
检查文件是否存在来避免异常发生, 不过因为有可能因为其它原因造成文件打开失败,比如缺
少权限,网络驱动器突然连接失败等等。从更安全的角度来说, 就不应该使用类似
os.path.exists() 之类的函数而是使用异常处理, 尤其是在没有合适函数的情况下更应如此。
你会在第 9 章中找到更多文件系统函数的例子,在第 10 章则有更多关于异常处理的知识。
3.6        相关模块和开发工具
Python 代码风格指南(PEP8), Python 快速参考和 Python 常见问答都是开发者很重要的
“工具”。另外, 还有一些模块会帮助你成为一个优秀的 Python 程序员。
z Debugger: pdb
z Logger: logging
z Profilers: profile, hotshot, cProfile
调试模块 pdb 允许你设置(条件)断点,代码逐行执行,检查堆栈。它还支持事后调试。
logging 模块是在 Python2.3 中新增的, 它定义了一些函数和类帮助你的程序实现灵活
的日志系统。共有五级日志级别: 紧急, 错误,警告,信息和调试。
历史上,因为不同的人们为了满足不同的需求重复实现了很多性能测试器,Python 也有好
几个性能测试模块。 最早的 Python profile 模块是 Python 写成的,用来测试函数的执行时
间,及每次脚本执行的总时间,既没有特定函数的执行时间也没有被包含的子函数调用时间。
在三个 profile 模块中,它是最老的也是最慢的,尽管如此, 它仍然可以提供一些有价值的性
能信息。 hotshot 模块是在 Python2.2 中新增的,它的目标是取代 profile 模块, 它修复了
profile 模块的一些错误, 因为它是用 C 语言写成,所以它有效的提高了性能。 注意 hotshot
重点解决了性能测试过载的问题, 但却需要更多的时间来生成结果。Python2.5 版修复了
hotshot 模块的一个关于时间计量的严重 bug。
cProfile 模块是 Python2.5 新增的, 它用来替换掉已经有历史的 hotshot 和 profile 模
块。被作者确认的它的一个较明显的缺点是它需要花较长时间从日志文件中载入分析结果, 不
支持子函数状态细节及某些结果不准。它也是用 C 语言来实现的。


3.8    练习
3–1.    标识符。为什么 Python 中不需要变量名和变量类型声明?
3–2.    标识符。为什么 Python 中不需要声明函数类型?
3–3.    标识符。为什么应当避免在变量名的开始和和结尾使用双下划线?
3–4.    语句。在 Python 中一行可以书写多个语句吗?
3–5. 语句。在 Python 中可以将一个语句分成多行书写吗?
3–6.    变量赋值
(a)赋值语句 x, y, z = 1, 2, 3 会在 x、y、z 中分别赋什么值?
(b)执行 z, x, y = y, z, x 后,x、y、z 中分别含有什么值?
3–7.    标识符。下面哪些是 Python 合法的标识符?如果不是,请说明理由!在合法的标
识符中,哪些是关键字?
下面的问题涉及了 makeTextFile.py 和 readTextFile.py 脚本。
3–8.    Python 代码。将脚本拷贝到您的文件系统中,然后修改它。可以添加注释,修改
提示符(‘>’太单调了)等等,修改这些代码,使它看上去更舒服。
3–9.    移植。 如果你在不同类型的计算机系统中分别安装有 Python, 检查一下,
os.linesep 的值是否有不同。 记下操作系统的类型以及 linesep 的值。
3–10.    异常。使用类似 readTextFile.py 中异常处理的方法取代 readTextFile.py
makeTextFile.py 中 对 os.path.exists() 的 调 用 。 反 过 来 , 用 os.path.exists() 取 代
readTextFile.py 中的异常处理方法。
3–11.
字符串格式化 不再抑制 readTextFile.py 中 print 语句生成的 NEWLINE 字符,修改你的
代码, 在显示一行之前删除每行末尾的空白。这样, 你就可以移除 print 语句末尾的逗号了。
提示: 使用字符串对象的 strip()方法


3–12.     合并源文件。将两段程序合并成一个,给它起一个你喜欢的名字,比方
readNwriteTextFiles.py。让用户自己选择是创建还是显示一个文本文件。
3–13.    添加新功能。将你上一个问题改造好的 readNwriteTextFiles.py 增加一个新功
能:允许用户编辑一个已经存在的文本文件。 你可以使用任何方式,无论是一次编辑一行,还
是一次编辑所有文本。需要提醒一下的是, 一次编辑全部文本有一定难度,你可能需要借助 GUI
工具包或一个基于屏幕文本编辑的模块比如 curses 模块。要允许用户保存他的修改(保存到
文件)或取消他的修改(不改变原始文件),并且要确保原始文件的安全性(不论程序是否正
常关闭)。


Python 对象
本章主题
z Python 对象
z 内建类型
z 标准类型运算符
z 值的比较
z 对象身份比较
z 布尔类型
z 标准类型内建函数
z 标准类型总览
z 各种类型
z 不支持的类型
4


我们现在来学习 Python 语言的核心部分。首先我们来了解什么是 Python 对象,然后讨论
最常用的内建类型,接下来我们讨论标准类型运算符和内建函数,之后给出对标准类型的不同
分类方式。这有助于我们更好的理解他们如何工作。最后我们提一提 Python 目前还不支持的
类型(这对那些有其他高级语言经验的人会有所帮助)。
4.1     Python 对象
Python 使用对象模型来存储数据。构造任何类型的值都是一个对象。尽管 Python 通常当
成一种“面向对象的编程语言”,但你完全能够写出不使用任何类和实例的实用脚本。不过
Python 的对象语法和架构鼓励我们使用这些特性,下面让我们仔细研究一下 Python 对象。
所有的 Python 对像都拥有三个特性:身份,类型和值。
身份:
每一个对象都有一个唯一的身份标识自己,任何对象的身份可以使用内建函数 id()来得到。
这个值可以被认为是该对象的内存地址。您极少会用到这个值,也不用太关心它究竟是什么。
类型
对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么


样的规则。您可以用内建函数 type()查看 Python 对象的类型。因为在 Python 中类型也是对象
(还记得我们提到 Python 是面向对象的这句话吗?),所以 type()返回的是对象而不是简单的
字符串。
值
对象表示的数据项
上面三个特性在对象创建的时候就被赋值,除了值之外,其它两个特性都是只读的。对于
新风格的类型和类, 对象的类型也是可以改变的,不过对于初学者并不推荐这样做。
如果对象支持更新操作,那么它的值就可以改变,否则它的值也是只读的。对象的值是否
可以更改被称为对象的可改变性(mutability)       ,我们会在后面的小节 4.7 中讨论这个问题。只
要一个对象还没有被销毁, 这些特性就一直存在。
Python 有一系列的基本(内建)数据类型,必要时也可以创建自定义类型来满足你的应用
程序的需求。绝大多数应用程序通常使用标准类型,对特定的数据存储则通过创建和实例化类
来实现。
4.1.1   对象属性
某些 Python 对象有属性、值或相关联的可执行代码,比如方法(method)。Python 用点(.)
标记法来访问属性。属性包括相应对象的名字等等,在章节 2.14 的备注中曾做过介绍。最常用
的属性是函数和方法,不过有一些 Python 类型也有数据属性。含有数据属性的对象包括(但不
限于):类、类实例、模块、复数和文件。
4.2      标准类型
z   数字(分为几个子类型,其中有三个是整型)
z   整型
z   布尔型
z   长整型
z   浮点型
z   复数型
z   字符串


z   列表
z   元组
z   字典
在本书中,我们把标准类型也称作“基本数据类型”,因为这些类型是 Python 内建的基本
数据类型,我们会在第 5、6 和 7 章详细介绍它们。
4.3        其他内建类型
z 类型
z Null 对象 (None)
z 文件
z 集合/固定集合
z 函数/方法
z 模块
z 类
这些是当你做 Python 开发时可能会用到的一些数据类型。我们在这里讨论 Type 和 None
类型的使用,除此之外的其他类型将在其他章节中讨论。
4.3.1     类型对象和 type 类型对象
在本章我们要讨论所有的 Python 类型,虽然看上去把类型本身也当成对象有点特别,我们
还是要在这里提一提。你一定还记得,对象的一系列固有行为和特性(比如支持哪些运算,具
有哪些方法)必须事先定义好。从这个角度看,类型正是保存这些信息的最佳位置。描述一种
类型所需要的信息不可能用一个字符串来搞定,所以类型不能是一个简单的字符串,这些信息
不能也不应该和数据保存在一起, 所以我们将类型定义成对象。
下面我们来正式介绍内建函数 type()。通过调用 type()函数你能够得到特定对象的类型
信息:
>>> type(42)
<type 'int'>
我们仔细研究一下这个例子,请注意看 type 函数有趣的返回值。我们得到一个简洁的


输出结果<type 'int'>。不过你应当意识到它并不是一个简简单单的告诉你 42 是个整数这样
的字符串。您看到的<type 'int'>实际上是一个类型对象,碰巧它输出了一个字符串来告诉你
它是个 int 型对象。
现在你该问自己了,那么类型对象的类型是什么?来, 我们试验一下:
>>> type(type(42))
<type 'type'>
没错,所有类型对象的类型都是 type,它也是所有 Python 类型的根和所有 Python 标准类
的默认元类(metaclass)。你现在有点搞不明白,没关系,随着我们逐步深入的学习类和类型,
你就会慢慢理解。
随着 Python 2.2 中类型和类的统一,类型对象在面向对象编程和日常对象使用中扮演着
更加重要的角色。从现在起, 类就是类型,实例是对应类型的对象。
4.3.2        None, Python 的 Null 对象
Python 有一个特殊的类型,被称作 Null 对象或者 NoneType,它只有一个值,那就是 None。
它不支持任何运算也没有任何内建方法。如果非常熟悉 C 语言,和 None 类型最接近的 C 类型就
是 void,None 类型的值和 C 的 NULL 值非常相似(其他类似的对象和值包括 Perl 的 undef 和
Java 的 void 类型与 null 值)。
None 没有什么有用的属性,它的布尔值总是 False。
核心笔记:布尔值
所有标准对象均可用于布尔测试,同类型的对象之间可以比较大小。每个对象天生具有布
尔 True 或 False 值。空对象、值为零的任何数字或者 Null 对象 None 的布尔值都是 False。
下列对象的布尔值是 False。
z None
z False (布尔类型)
z 所有的值为零的数:


z 0 (整型)
z (浮点型)
z 0L (长整型)
z 0.0+0.0j (复数)
z "" (空字符串)
z [] (空列表)
z () (空元组)
z {} (空字典)
值不是上面列出来的任何值的对象的布尔值都是 True,例如 non-empty、non-zero 等等。
用户创建的类实例如果定义了 nonzero(__nonzero__())或 length(__len__())且值为 0,那
么它们的布尔值就是 False。
4.4       内部类型
z   代码
z   帧
z   跟踪记录
z   切片
z  省略
z  Xrange
我们在这里简要介绍一下这些内部类型,一般的程序员通常不会直接和这些对象打交道。
不过为了这一章的完整性,我们还是在这里介绍一下它们。请参阅源代码或者 Python 的内部文
档和在线文档获得更详尽的信息。
你如果对异常感到迷惑的话,可以告诉你它们是用类来实现的,在老版本的 Python 中,异
常是用字符串来实现的。
4.4.1     代码对象
代码对象是编译过的 Python 源代码片段,它是可执行对象。通过调用内建函数 compile()
可以得到代码对象。代码对象可以被 exec 命令或 eval()内建函数来执行。在第 14 章将详细
研究代码对象。


代码对象本身不包含任何执行环境信息, 它是用户自定义函数的核心, 在被执行时动态
获得上下文。      (事实上代码对象是函数的一个属性)一个函数除了有代码对象属性以外,还有一
些其它函数必须的属性,包括函数名,文档字符串,默认参数,及全局命名空间等等。
4.4.2      帧对象
帧对象表示 Python 的执行栈帧。帧对象包含 Python 解释器在运行时所需要知道的所有信
息。它的属性包括指向上一帧的链接,正在被执行的代码对象(参见上文),本地及全局名字空
间字典以及当前指令等。每次函数调用产生一个新的帧,每一个帧对象都会相应创建一个 C 栈
帧。用到帧对象的一个地方是跟踪记录对象(参见下一节)
4.4.3      跟踪记录 对象
当你的代码出错时, Python 就会引发一个异常。如果异常未被捕获和处理, 解释器就会
退出脚本运行,显示类似下面的诊断信息:
Traceback (innermost last):
File "<stdin>", line N?, in ???
ErrorName: error reason
当异常发生时,一个包含针对异常的栈跟踪信息的跟踪记录对象被创建。如果一个异常有
自己的处理程序,处理程序就可以访问这个跟踪记录对象。
4.4.4      切片对象
当使用 Python 扩展的切片语法时,就会创建切片对象。扩展的切片语法允许对不同的索引
切片操作,包括步进切片, 多维切片,及省略切片。多维切片语法是 sequence[start1 : end1,
start2 : end2], 或使用省略号, sequence[...,start1 : end1 ]. 切片对象也可以由内建
函 数 slice() 来 生 成 。 步 进 切 片 允 许 利 用 第 三 个 切 片 元 素 进 行 步 进 切 片 , 它 的 语 法 为
sequence[起始索引 : 结束索引 : 步进值]。Python 很早就支持扩展步进切片语法了,但直到
Python2.3 以前都必须依靠 C API 或 Jython 才能工作。 下面是几个步进切片的例子:
>>> foostr = 'abcde'
>>> foostr[::-1]
'edcba'
>>> foostr[::-2]


'eca'
>>> foolist = [123, 'xba', 342.23, 'abc']
>>> foolist[::-1]
['abc', 342.23, 'xba', 123]
4.4.5     省略对象
省略对象用于扩展切片语法中,起记号作用。 这个对象在切片语法中表示省略号。类似
Null 对象 None, 省略对象有一个唯一的名字 Ellipsis, 它的布尔值始终为 True.
4.4.6     XRange 对象
调用内建函数 xrange() 会生成一个 Xrange 对象,xrange()是内建函数 range()的兄弟版
本, 用于需要节省内存使用或 range()无法完成的超大数据集场合。在第 8 章你可以找到更多
关于 range() 和 xrange() 的使用信息。
4.5     标准类型运算符
4.5.1       对象值的比较
比较运算符用来判断同类型对象是否相等,所有的内建类型均支持比较运算,比较运算返
回布尔值 True 或 False。如果你正在使用的是早于 Python2.3 的版本,因为这些版本还没有
布尔类型,所以会看到比较结果为整型值 1 (代表 True)或 0 (代表 False)。
注意,实际进行的比较运算因类型而异。换言之,数字类型根据数值的大小和符号比较,
字符串按照字符序列值进行比较,等等。
>>> 2 == 2
True
>>> 2.46 <= 8.33
True
>>> 5+4j >= 2-3j
True
>>> 'abc' == 'xyz'
False
>>> 'abc' > 'xyz'
False


>>> 'abc' < 'xyz'
True
>>> [3, 'abc'] == ['abc', 3]
False
>>> [3, 'abc'] == [3, 'abc']
True
不同于很多其它语言,多个比较操作可以在同一行上进行,求值顺序为从左到右。
>>> 3 < 4 < 7 # same as ( 3 < 4 ) and ( 4 < 7 )
True
>>> 4 > 3 == 3 # same as ( 4 > 3 ) and ( 3 == 3 )
True
>>> 4 < 3 < 5 != 2 < 7
False
我们会注意到比较操作是针对对象的值进行的,也就是说比较的是对象的数值而不是对象
本身。在后面的部分我们会研究对象身份的比较。
表 4.1    标准类型值比较运算符
运算符               功能
expr1 < expr2     expr1  小于 expr2
expr1 > expr2     expr1  大于 expr2
expr1 <= expr2    expr1  小于等于 expr2
expr1 >= expr2    expr1  大于等于 expr2
expr1 == expr2    expr1  等于 expr2
expr1 != expr2    expr1  不等于 expr2 (C 风格)
expr1 <> expr2    expr1  不等于 expr2 (ABC/Pascal 风格)
注:       未来很有可能不再支持 <> 运算符,建议您一直使用 != 运算符。
4.5.2      对象身份比较


作为对值比较的补充,Python 也支持对象本身的比较。对象可以被赋值到另一个变量(通
过引用)。因为每个变量都指向同一个(共享的)数据对象,只要任何一个引用发生改变,该对
象的其它引用也会随之改变。
为了方便大家理解,最好先别考虑变量的值,而是将变量名看作对象的一个链接。让我们
来看以下三个例子:
例 1:    foo1 和 foo2 指向相同的对象
foo1 = foo2 = 4.3
当你从值的观点看这条语句时, 它表现的只是一个多重赋值,将 4.3 这个值赋给了 foo1
和 foo2 这两个变量。这当然是对的, 不过它还有另一层含义。 事实是一个值为 4.3 的数字对
象被创建,然后这个对象的引用被赋值给 foo1 和 foo2, 结果就是 foo1 和 foo2 指向同一个对
象。图 4-1 演示了一个对象两个引用。
图 4–1     foo1 和 foo2 指向相同的对象
例 2: foo1 和 foo2 指向相同的对象
foo1 = 4.3
foo2 = foo1
这个例子非常类似上一个,一个值为 4.3 的数值对象被创建,然后赋给一个变量, 当执行
foo2 = foo1 时, foo2 被指向 foo1 所指向的同一个对象, 这是因为 Python 通过传递引用来
处理对象。foo2 就成为原始值 4.3 的一个新的引用。 这样 foo1 和 foo2 就都指向了同一个对
象。示意图也和图 4-1 一样。
例 3: foo1 和 foo2 指向不同的对象


foo1 = 4.3
foo2 = 1.3 + 3.0
这个例子有所不同。首先一个数字对象被创建,然后赋值给 foo1. 然后第二个数值对象被
创建并赋值给 foo2. 尽管两个对象保存的是同样大小的值,但事实上系统中保存的都是两个独
立的对象,其中 foo1 是第一个对象的引用, foo2 则是第二个对象的引用。图 4-2 演示给我
们这里有两个不同的对象,尽管这两个对象有同样大小的数值。 我们为什么在示意图中使用盒
子?没错,对象就象一个装着内容的盒子。当一个对象被赋值到一个变量,就象在这个盒子上
贴了一个标签,表示创建了一个引用。每当这个对象有了一个新的引用,就会在盒子上新贴一
张标签。当一个引用被销毁时, 这个标签就会被撕掉。当所有的标签都被撕掉时, 这个盒子
就会被回收。那么,Python 是怎么知道这个盒子有多少个标签呢?
图 4–2       foo1 和 foo2 指向不同的对象
每个对象都天生具有一个计数器,记录它自己的引用次数。这个数目表示有多少个变量指
向该对象。这也就是我们在第三章 3.5.5-3.5.7 小节提到的引用计数。Python 提供了 is 和 is not
运算符来测试两个变量是否指向同一个对象。象下面这样执行一个测试
a is b
这个表达式等价于下面的表达式
id(a) == id(b)
对象身份比较运算符拥有同样的优先级,表 4.2 列出了这些运算符。在下面这个例子里,
我们创建了一个变量,然后将第二个变量指向同一个对象。
>>> a = [ 5, 'hat', -9.3]
>>> b = a
>>> a is b
True
>>> a is not b
False


>>>
>>> b = 2.5e-5
>>> b
2.5e-005
>>> a
[5, 'hat', -9.3]
>>> a is b
False
>>> a is not b
True
is 与 not 标识符都是 Python 关键字。
表 4.2    标准类型对象身份比较运算符
运算符               功能
obj1 is obj2      obj1 和 obj2 是同一个对象
obj1 is not obj2  obj1 和 obj2 不是同一个对象
核心提示:实践
在上面的例子中,您会注意到我们使用的是浮点数而不是整数。为什么这样?整数对象和
字符串对象是不可变对象,所以 Python 会很高效的缓存它们。这会造成我们认为 Python 应该
创建新对象时,它却没有创建新对象的假象。看下面的例子:
>>> a = 1
>>> id(a)
8402824
>>> b = 1
>>> id(b)
8402824
>>>
>>> c = 1.0
>>> id(c)
8651220
>>> d = 1.0
>>> id(d)
8651204
在上面的例子中,a 和 b 指向了相同的整数对象,但是 c 和 d 并没有指向相同的浮点数
对象。如果我们是纯粹主义者,我们会希望 a 与 b 能和 c 与 d 一样,因为我们本意就是为
了创建两个整数对象,而不是像 b = a 这样的结果。


Python 仅缓存简单整数,因为它认为在 Python 应用程序中这些小整数会经常被用到。当
我们在写作本书的时候,Python 缓存的整数范围是(-1, 100),不过这个范围是会改变的,所
以请不要在你的应用程序使用这个特性。
Python 2.3 中决定,在预定义缓存字符串表之外的字符串,如果不再有任何引用指向它,
那这个字符串将不会被缓存。也就是说, 被缓存的字符串将不会象以前那样永生不灭,对象回
收器一样可以回收不再被使用的字符串。从 Python 1.5 起提供的用于缓存字符的内建函数
intern() 也已经不再推荐使用, 即将被废弃。
4.5.3      布尔类型
布尔逻辑运算符 and, or 和 not 都是 Python 关键字,这些运算符的优先级按从高到低
的顺序列于表 4.3. not 运算符拥有最高优先级,只比所有比较运算符低一级。 and 和 or 运
算符则相应的再低一级。
表 4.3   标准类型布尔运算符
运算符                   功能
not expr              expr 的逻辑非 (否)
expr1 and expr2       expr1 和 expr2 的逻辑与
expr1 or expr2         expr1 和 expr2 的逻辑或
>>> x, y = 3.1415926536, -1024
>>> x < 5.0
True
>>> not (x < 5.0) False
>>> (x < 5.0) or (y > 2.718281828) True
>>> (x < 5.0) and (y > 2.718281828) False
>>> not (x is y)
True
前面我们提到过 Python 支持一个表达式进行多种比较操作, 其实这个表达式本质上是由
多个隐式的 and 连接起来的多个表达式。
>>> 3 < 4 < 7    # same as "( 3 < 4 ) and ( 4 < 7 )"
True


4.6         标准类型内建函数
除了这些运算符,我们刚才也看到,Python 提供了一些内建函数用于这些基本对象类型:
cmp(), repr(), str(), type(), 和等同于 repr()函数的单反引号(``) 运算符。
表 4.4      标准类型内建函数
函数                 功能
cmp(obj1, obj2)      比较 obj1 和 obj2, 根据比较结果返回整数 i:
i < 0 if obj1 < obj2
i > 0 if obj1 > obj2
i == 0 if obj1 == obj2
repr(obj) 或 `obj` 返回一个对象的字符串表示
str(obj)             返回对象适合可读性好的字符串表示
type(obj)           得到一个对象的类型,并返回相应的 type 对象
4.6.1    type()
我们现在来正式介绍 type()。在 Python2.2 以前, type() 是内建函数。不过从那时起,
它变成了一个“工厂函数”             。在本章的后面部分我们会讨论工厂函数, 现在你仍然可以将 type()
仅仅当成一个内建函数来看。 type() 的用法如下:
type(object)
type() 接受一个对象做为参数,并返回它的类型。它的返回值是一个类型对象。
>>> type(4)    # int type
<type 'int'>
>>>
>>> type('Hello World!')        # string type
<type 'string'>
>>>
>>> type(type(4))       # type type
<type 'type'>


在上面的例子里, 我们通过内建函数 type() 得到了一个整数和一个字符串的类型;为了
确认一下类型本身也是类型, 我们对 type()的返回值再次调用 type(). 注意 type()有趣的
输出, 它看上去不象一个典型的 Python 数据类型, 比如一个整数或一个字符串,一些东西被
一个大于号和一个小号包裹着。这种语法是为了告诉你它是一个对象。每个对象都可以实现一
个可打印的字符串表示。不过并不总是这样, 对那些不容易显示的对象来说, Python 会以一
个相对标准的格式表示这个对象,格式通常是这种形式: <object_something_or_another>, 以
这种形式显示的对象通常会提供对象类别,对象 id 或位置, 或者其它合适的信息。
4.6.2      cmp()
内建函数 cmp()用于比较两个对象 obj1 和 obj2, 如果 obj1 小于 obj2, 则返回一个负整
数,如果 obj1 大于 obj2 则返回一个正整数, 如果 obj1 等于 obj2, 则返回 0。它的行为非常
类似于 C 语言的 strcmp()函数。比较是在对象之间进行的,不管是标准类型对象还是用户自定
义对象。如果是用户自定义对象, cmp()会调用该类的特殊方法__cmp__()。在第 13 章会详细
介绍类的这些特殊方法。下面是几个使用 cmp()内建函数的对数值和字符串对象进行比较的例
子。
>>> a, b = -4, 12
>>> cmp(a,b)
-1
>>> cmp(b,a)
1
>>> b = -4
>>> cmp(a,b)
0
>>>
>>> a, b = 'abc', 'xyz'
>>> cmp(a,b)
-23
>>> cmp(b,a)
23
>>> b = 'abc'
>>> cmp(a,b)
0
在后面我们会研究 cmp()用于其它对象的比较操作。


4.6.3       str()和 repr() (及 `` 运算符)
内建函数 str() 和 repr() 或反引号运算符(``) 可以方便的以字符串的方式获取对象的
内容、类型、数值属性等信息。str()函数得到的字符串可读性好, 而 repr()函数得到的字符
串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的。
这两个函数接受一个对象做为其参数, 返回适当的字符串。在下面的例子里, 我们会随机取
一些 Python 对象来查看他们的字符串表示。
>>> str(4.53-2j)
'(4.53-2j)'
>>>
>>> str(1)
'1'
>>>
>>> str(2e10)
'20000000000.0'
>>>
>>> str([0, 5, 9, 9])
'[0, 5, 9, 9]'
>>>
>>> repr([0, 5, 9, 9])
'[0, 5, 9, 9]'
>>>
>>> `[0, 5, 9, 9]`
'[0, 5, 9, 9]'
尽管 str(),repr()和``运算在特性和功能方面都非常相似, 事实上 repr() 和 `` 做的
是完全一样的事情,它们返回的是一个对象的“官方”字符串表示, 也就是说绝大多数情况下
可以通过求值运算(使用 eval()内建函数)重新得到该对象,但 str()则有所不同。str() 致力
于生成一个对象的可读性好的字符串表示,它的返回结果通常无法用于 eval()求值, 但很适
合用于 print 语句输出。需要再次提醒一下的是, 并不是所有 repr()返回的字符串都能够用
eval()内建函数得到原来的对象:
>>> eval(`type(type))`)
File "<stdin>", line 1
eval(`type(type))`)
^
SyntaxError: invalid syntax


也就是说 repr() 输出对 Python 比较友好, 而 str()的输出对人比较友好。虽然如此,
很多情况下这三者的输出仍然都是完全一样的。
核心笔记:为什么我们有了 repr()还需要``?
在 Python 学习过程中,你偶尔会遇到某个运算符和某个函数是做同样一件事情。之所以如
此是因为某些场合函数会比运算符更适合使用。举个例子, 当处理类似函数这样的可执行对象
或根据不同的数据项调用不同的函数处理时,函数就比运算符用起来方便。另一个例子就是双
星号(**)乘方运算和 pow()内建函数,x ** y 和 pow(x,y) 执行的都是 x 的 y 次方。
译者注:事实上 Python 社区目前已经不鼓励继续使用``运算符。
4.6.4       type() 和 isinstance()
Python 不支持方法或函数重载, 因此你必须自己保证调用的就是你想要的函数或对象。
(参阅 Python 常见问答 4.75 节)。幸运的是, 我们前面 4.3.1 小节提到的 type()内建函数可
以帮助你确认这一点。一个名字里究竟保存的是什么?相当多,尤其是这是一个类型的名字时。
确认接收到的类型对象的身份有很多时候都是很有用的。为了达到此目的,Python 提供了一
个内建函数 type(). type()返回任意 Python 对象对象的类型,而不局限于标准类型。让我们
通过交互式解释器来看几个使用 type()内建函数返回多种对象类型的例子:
>>> type('')
<type 'str'>
>>>
>>> s = 'xyz'
>>> type(s)
<type 'str'>
>>>
>>> type(100)
<type 'int'>
>>> type(0+0j)
<type 'complex'>
>>> type(0L)
<type 'long'>
>>> type(0.0)
<type 'float'>
>>>
>>> type([])
<type 'list'>
>>> type(())


<type 'tuple'>
>>> type({})
<type 'dict'>
>>> type(type)
<type 'type'>
>>>
>>> class Foo: pass     # new-style class
...
>>> foo = Foo()
>>> class Bar(object): pass     # new-style class
...
>>> bar = Bar()
>>>
>>> type(Foo)
<type 'classobj'>
>>> type(foo)
<type 'instance'>
>>> type(Bar)
<type 'type'>
>>> type(bar)
<class '__main__.Bar'>
Python2.2 统一了类型和类, 如果你使用的是低于 Python2.2 的解释器,你可能看到不一
样的输出结果。
>>> type('')
<type 'string'>
>>> type(0L)
<type 'long int'>
>>> type({})
<type 'dictionary'>
>>> type(type)
<type 'builtin_function_or_method'>
>>>
>>> type(Foo) # assumes Foo created as in above
<type 'class'>
>>> type(foo) # assumes foo instantiated also
<type 'instance'>
除了内建函数 type(), 还有一个有用的内建函数叫 isinstance(). 我们会在第 13 章(面


向对象编程)正式研究这个函数,不过在这里我们还是要简要介绍一下你如何利用它来确认一
个对象的类型。
举例
在例 4.1 中我们提供了一段脚本来演示在运行时环境使用 isinstance() 和 type()函数。
随后我们讨论 type()的使用以及怎么将这个例子移植为改用 isinstance()。
运行 typechk.py, 我们会得到以下输出:
-69 is a number of type: int
9999999999999999999999 is a number of type: long
98.6 is a number of type: float
(-5.2+1.9j) is a number of type: complex
xxx is not a number at all!!
例 4.1     检查类型(typechk.py)
函数 displayNumType() 接受一个数值参数,它使用内建函数 type()来确认数值的类型
(或不是一个数值类型)。
1 #!/usr/bin/env python
2
3def displayNumType(num):
4 print num, 'is',
5 if isinstance(num, (int, long, float, complex)):
6 print 'a number of type:', type(num).__name__
7 else:
8 print 'not a number at all!!'
9
10 displayNumType(-69)
11 displayNumType(9999999999999999999999L)
12 displayNumType(98.6)
13 displayNumType(-5.2+1.9j)
14 displayNumType('xxx')


例子进阶
原始
这个完成同样功能的函数与本书的第一版中的例子已经大不相同:
def displayNumType(num):
print num, "is",
if type(num) == type(0):
print 'an integer'
elif type(num) == type(0L):
print 'a long'
elif type(num) == type(0.0):
print 'a float'
elif type(num) == type(0+0j):
print 'a complex number'
else:
print 'not a number at all!!'
由于 Python 奉行简单但是比较慢的方式,所以我们必须这么做,看一眼我们原来的条件
表达式:
if type(num) == type(0)...
减少函数调用的次数
如果我们仔细研究一下我们的代码,会看到我们调用了两次 type()。要知道每次调用函数
都会付出性能代价, 如果我们能减少函数的调用次数, 就会提高程序的性能。
利用在本章我们前面提到的 types 模块, 我们还有另一种比较对象类型的方法,那就是
将检测得到的类型与一个已知类型进行比较。如果这样, 我们就可以直接使用 type 对象而不
用每次计算出这个对象来。那么我们现在修改一下代码,改为只调用一次 type()函数:
>>> import types
>>> if type(num) == types.IntType...
对象值比较 VS 对象身份比较
在这一章的前面部分我们讨论了对象的值比较和身份比较, 如果你了解其中的关键点,你
就会发现我们的代码在性能上还不是最优的.在运行时期,只有一个类型对象来表示整数类型.
也就是说,type(0),type(42),type(-100) 都是同一个对象: <type 'int'>(types.IntType 也
是这个对象)


如果它们是同一个对象, 我们为什么还要浪费时间去获得并比较它们的值呢(我们已经知
道它们是相同的了!)? 所以比较对象本身是一个更好地方案.下面是改进后的代码:
if type(num) is types.IntType... # or type(0)
这样做有意义吗? 我们用对象身份的比较来替代对象值的比较。如果对象是不同的,那意
味着原来的变量一定是不同类型的。(因为每一个类型只有一个类型对象),我们就没有必要去
检查(值)了。 一次这样的调用可能无关紧要,不过当很多类似的代码遍布在你的应用程序中的
时候,就有影响了。
减少查询次数
这是一个对前一个例子较小的改进,如果你的程序像我们的例子中做很多次比较的话,程
序的性能就会有一些差异。为了得到整数的对象类型,解释器不得不首先查找 types 这个模块
的名字,然后在该模块的字典中查找 IntType。通过使用 from-import,你可以减少一次查询:
from types import IntType
if type(num) is IntType...
惯例和代码风格
Python2.2 对类型和类的统一导致 isinstance()内建函数的使用率大大增加。我们将在
第 13 章(面向对象编程)正式介绍 isinstance(),在这里我们简单浏览一下。
这个布尔函数接受一个或多个对象做为其参数,由于类型和类现在都是一回事, int 现在
既是一个类型又是一个类。我们可以使用 isinstance() 函数来让我们的 if 语句更方便,并具
有更好的可读性。
if isinstance(num, int)...
在判断对象类型时也使用 isinstance() 已经被广为接受, 我们上面的 typechk.py 脚本
最终与改成了使用 isinstance() 函数。值得一提的是, isinstance()接受一个类型对象的元
组做为参数, 这样我们就不必像使用 type()时那样写一堆 if-elif-else 判断了。
4.6.5      Python 类型运算符和内建函数总结
表 4.5 列出了所有运算符和内建函数,其中运算符顺序是按优先级从高到低排列的。同一
种灰度的运算符拥有同样的优先级。注意在 operator 模块中有这些(和绝大多数 Python)运算


符相应的同功能的函数可供使用。
表 4.5 标准类型运算符和内建函数
Operator/Function            Description                                 Resulta 
String                                         
‘‘                           String representation                        st
Built‐in functions                             
cmp(obj1, obj2)              Compares two objects                         in
repr(obj)                    String representation                        st
str(obj)                     String representation                        st
type(obj)                    Determines object type                      typ
Value comparisons                              
<                            Less than                                   boo
>                            Greater than                               boo
<=                           Less than or equal to                      boo
>=                           Greater than or equal to                   boo
==                           Equal to                                   boo
!=                           Not equal to                               boo
<>                           Not equal to                               boo
Object comparisons                            
is                           The same as                                boo
is not                       Not the same as                            boo
Boolean operators                             
not                          Logical negation                           boo
and                          Logical conjunction                        boo
or                           Logical disjunction                        boo
布尔比较总是返回 True 或 False


4.7        类型工厂函数
Python 2.2 统一了类型和类, 所有的内建类型现在也都是类, 在这基础之上, 原来的
所谓内建转换函数象 int(), type(), list() 等等, 现在都成了工厂函数。 也就是说虽然他
们看上去有点象函数, 实质上他们是类。当你调用它们时, 实际上是生成了该类型的一个实
例, 就象工厂生产货物一样。
下面这些大家熟悉的工厂函数在老的 Python 版里被称为内建函数:
z int(), long(), float(), complex()
z str(), unicode(), basestring()
z list(), tuple()
z type()
以前没有工厂函数的其他类型,现在也都有了工厂函数。除此之外,那些支持新风格的类
的全新的数据类型,也添加了相应的工厂函数。下面列出了这些工厂函数:
z dict()
z bool()
z set(), frozenset()
z object()
z classmethod()
z staticmethod()
z super()
z property()
z file()
4.8        标准类型的分类
如果让我们最啰嗦的描述标准类型,我们也许会称它们是 Python 的“基本内建数据对象原
始类型”。
z  “基本”,是指这些类型都是 Python 提供的标准或核心类型。
z  “内建”,是由于这些类型是 Python 默认就提供的
z  “数据”,因为他们用于一般数据存储
z  “对象”,因为对象是数据和功能的默认抽象


z  “原始”,因为这些类型提供的是最底层的粒度数据存储
z  “类型”,因为他们就是数据类型
不过, 上面这些描述实际上并没有告诉你每个类型如何工作以及它们能发挥什么作用。事
实上, 几个类型共享某一些的特性,比如功能的实现手段, 另一些类型则在访问数据值方面
有一些共同之处。我们感兴趣的还有这些类型的数据如何更新以及它们能提供什么样的存储。
有三种不同的模型可以帮助我们对基本类型进行分类,每种模型都展示给我们这些类型之间的
相互关系。这些模型可以帮助我们更好的理解类型之间的相互关系以及他们的工作原理。
4.8.1   存储模型
我们对类型进行分类的第一种方式, 就是看看这种类型的对象能保存多少个对象。Python
的类型, 就象绝大多数其它语言一样,能容纳一个或多个值。一个能保存单个字面对象的类型
我们称它为原子或标量存储,那些可容纳多个对象的类型,我们称之为容器存储。                               (容器对象有
时会在文档中被称为复合对象,不过这些对象并不仅仅指类型,还包括类似类实例这样的对象)
容器类型又带来一个新问题,那就是它是否可以容纳不同类型的对象。所有的 Python 容器对
象都能够容纳不同类型的对象。表 4.6 按存储模型对 Python 的类型进行了分类。
字符串看上去像一个容器类型,因为它“包含”字符(并且经常多于一个字符),不过由
于 Python 并没有字符类型(参见章节 4.8),所以字符串是一个自我包含的文字类型。
表 4.6  以存储模型为标准的类型分类
存储模型
分类         Python 类型
标量/原子类型    数值(所有的数值类型),字符串(全部是文字)
容器类型       列表、元组、字典
4.8.2   更新模型
另一种对标准类型进行分类的方式就是, 针对每一个类型问一个问题:“对象创建成功之
后,它的值可以进行更新吗?” 在前面我们介绍 Python 数据类型时曾经提到,某些类型允许
他们的值进行更新,而另一些则不允许。可变对象允许他们的值被更新,而不可变对象则不允


许他们的值被更改。表 4.7 列出了支持更新和不支持更新的类型。
看完这个表之后,你可能马上冒出一个问题:                          “等等,你说数值和字符串对象是不可改变的?
看看下面的例子!”:
x = 'Python numbers and strings'
x = 'are immutable?!? What gives?'
i = 0
i = i + 1
“在我看来, 这可不象是不可变对象的行为!                            ” 没错,是这样,不过你还没有搞清楚幕后
的真相。上面的例子中,事实上是一个新对象被创建,然后它取代了旧对象。就是这样,请多
读一遍这段。
新创建的对象被关联到原来的变量名, 旧对象被丢弃,垃圾回收器会在适当的时机回收这
些对象。你可以通过内建函数 id()来确认对象的身份在两次赋值前后发生了变化。
表 4.7       以更新模型为标准的类型分类
更新模型
分类                Python 类型
可变类型              列表, 字典
不可变类型             数字、字符串、元组
下面我们在上面的例子里加上 id()调用, 就会清楚的看到对象实际上已经被替换了:
>>> x = 'Python numbers and strings'
>>> print id(x)
16191392
>>> x = 'are immutable?!? What gives?'
>>> print id(x)
16191232
>>> i = 0
>>> print id(i)
7749552
>>> i = i + 1
>>> print id(i)


7749600
你看到的身份数字很可能和我不同,每次执行这些数字也会不同,这是正常的。这个数字
与该对象当时分配的内存地址密切相关。因此不同的机器, 不同的执行时间都会生成不同的对
象身份。另一类对象, 列表可以被修改而无须替换原始对象, 看下面的例子:
>>> aList = ['ammonia', 83, 85, 'lady']
>>> aList
['ammonia', 83, 85, 'lady']
>>>
>>> aList[2]
85
>>>
>>> id(aList)
135443480
>>>
>>> aList[2] = aList[2] + 1
>>> aList[3] = 'stereo'
>>> aList
['ammonia', 83, 86, 'stereo']
>>>
>>> id(aList)
135443480
>>>
>>> aList.append('gaudy')
>>> aList.append(aList[2] + 1)
>>> aList
['ammonia', 83, 86, 'stereo', 'gaudy', 87]
>>>
>>> id(aList)
135443480
注意列表的值不论怎么改变, 列表的 ID 始终保持不变。
4.8.3       访问模型
尽管前面两种模型分类方式在介绍 Python 时都很有用,它们还不是区分数据类型的首要模
型。对这种目的,我们使用访问模型。也就是说根据访问我们存储的数据的方式对数据类型进
行分类。在访问模型中共有三种访问方式:直接存取,顺序,和映射。表 4.8 按访问方式对数
据类型进行了分类。


对非容器类型可以直接访问。所有的数值类型都归到这一类。
序列类型是指容器内的元素按从 0 开始的索引顺序访问。一次可以访问一个元素或多个元
素, 也就是大家所了解的切片(slice)。字符串, 列表和元组都归到这一类。我们前面提到过,
Python 不支持字符类型,因此,虽然字符串是简单文字类型,因为它有能力按照顺序访问子字
符串,所以也将它归到序列类型。
映射类型类似序列的索引属性,不过它的索引并不使用顺序的数字偏移量取值, 它的元素
无序存放, 通过一个唯一的 key 来访问, 这就是映射类型, 它容纳的是哈希键-值对的集合。
我们在以后的章节中将主要使用访问模型,详细介绍各种访问模型的类型, 以及某个分类
的类型之间有哪些相同之处(比如运算符和内建函数)               , 然后讨论每种 Python 标准类型。所有
类型的特殊运算符,内建函数, 及方法都会在相应的章节特别说明。
为什么要对同样的数据类型再三分类呢?首先, 我们为什么要分类? 因为 Python 提供
了高级的数据结构,我们需要将那些原始的类型和功能强大的扩展类型区分开来。另一个原因
就是这有助于搞清楚某种类型应该具有什么行为。举例来说,如果我们基本上不用问自己“列
表和元组有什么区别?”或“什么是可变类型和不可变类型?”这些问题的时候,我们也就达
到了目的。最后,某些分类中的所有类型具有一些相同的特性。一个优秀的工匠应该知道他或
她的工具箱里都有哪些宝贝。
表 4.7   以访问模型为标准的类型分类
访问模型
分类                Python 类型
直接访问                    数字
顺序访问                字符串、列表、元组
映射访问                字典
表 4.9 标准类型分类


数据类型       存储模型               更新模型          访问模型l 
数字         Scalar             不可更改          直接访问  
字符串        Scalar             不可更改          顺序访问 
列表         Container          可更改           顺序访问 
元组         Container          不可更改          顺序访问 
字典         Container          可更改           映射访问 
另一个问题就是, “为什么要用这么多不同的模型或从不同的方面来分类?” 所有这些
数据类型看上去是很难分类的。它们彼此都有着错综复杂的关系,所有类型的共同之处最好能
揭示出来,而且我们还想揭示每种类型的独到之处。没有两种类型横跨所有的分类。(当然,所
有的数值子类型做到了这一点, 所以我们将它们归纳到一类当中)。最后,我们确信搞清所有
类型之间的关系会对你的开发工作有极大的帮助。你对每种类型的了解越多,你就越能在自己
的程序中使用恰当的类型以达到最佳的性能。
我们提供了一个汇总表(表 4.9)。表中列出了所有的标准类型, 我们使用的三个模型,
以及每种类型归入的分类。
4.9        不支持的类型
在我们深入了解各个标准类型之前,我们在本章的结束列出 Python 目前还不支持的数据类
型。
char 或 byte
Python 没有 char 或 byte 类型来保存单一字符或 8 比特整数。你可以使用长度为 1 的字
符串表示字符或 8 比特整数。
指针
Python 替你管理内存,因此没有必要访问指针。在 Python 中你可以使用 id()函数得到一


个对象的身份号, 这是最接近于指针的地址。因为你不能控制这个值,所以其实没有太大意义。
其实在 Python 中, 一切都是指针。
int vs short vs long
Python 的普通整数相当于标准整数类型,不需要类似 C 语言中的 int, short, long 这三
种整数类型。事实上 Python 的整数实现等同于 C 语言的长整数。 由于 Python 的整型与长整型
密切融合, 用户几乎不需要担心什么。 你仅需要使用一种类型, 就是 Python 的整型。即便
数值超出整型的表达范围, 比如两个很大的数相乘, Python 会自动的返回一个长整数给你而
不会报错。
float VS double
C 语言有单精度和双精度两种浮点类型。 Python 的浮点类型实际上是 C 语言的双精度浮
点类型。Python 认为同时支持两种浮点类型的好处与支持两种浮点类型带来的开销不成比例,
所以 Python 决定不支持单精度浮点数。对那些宁愿放弃更大的取值范围而需要更高精确度的
用户来说, Python 还有一种十进制浮点数类型 Decimal, 不过你必须导入 decimal 模块才可
以使用它。浮点数总是不精确的。Decimals 则拥有任意的精度。在处理金钱这类确定的值时,
Decimal 类型就很有用。 在处理重量,长度或其它度量单位的场合, float 足够用了。
4.10       练习
4–1.    Python 对象。与所有 Python 对象有关的三个属性是什么?请简单的描述一下。
4–2.    类型。不可更改(immutable)指的是什么?Python 的哪些类型是可更改的
(mutable),哪些不是?
4–3.    类型。哪些 Python 类型是按照顺序访问的,它们和映射类型的不同是什么?
4–4.    type()。内建函数 type()做什么?type()返回的对象是什么?
4–4.    str() 和 repr()。内建函数 str()与 repr()之间的不同是什么?哪一个等价于反
引号(``)运算符?。
4–6.    对象相等。您认为 type(a) == type(b)和 type(a) is type(b)之间的不同是什么?
为什么会选择后者?函数 isinstance()与这有什么关系?
4–7.    内建函数 dir()。在第二章的几个练习中,我们用内建函数 dir()做了几个实验,
它接受一个对象,然后给出相应的属性。请对 types 模块做相同的实验。记下您熟悉的类型,
包括您对这些类型的认识,然后记下你还不熟悉的类型。在学习 Python 的过程中,你要逐步将
“不熟悉”的类型变得“熟悉”起来。


4–8.     列表和元组。列表和元组的相同点是什么?不同点是什么?
4–9.     练习,给定以下赋值:
a = 10
b = 10
c = 100
d = 100
e = 10.0
f = 10.0
请问下面各表达式的输出是什么?为什么?
(a) a is b
(b) c is d
(c) e is f


数字
本章主题
z 数的简介
z 整型
z 布尔型
z 标准的整型
z 长整型
z 浮点型实数
z 复数
z 操作符
z 内建函数
z 其它数字类型
z 相关模块


本章的主题是 Python 中的数字。我们会详细介绍每一种数字类型,它们适用的各种运算
符, 以及用于处理数字的内建函数。在本章的末尾, 我们简单介绍了几个标准库中用于处理
数字的模块。
5.1     数字类型
数字提供了标量贮存和直接访问。它是不可更改类型,也就是说变更数字的值会生成新的
对象。当然,这个过程无论对程序员还是对用户都是透明的,并不会影响软件的开发方式。
Python 支持多种数字类型:整型、长整型、布尔型、双精度浮点型、十进制浮点型和复数。
如何创建数值对象并用其赋值
(数字对象)
创建数值对象和给变量赋值一样同样简单:
anInt = 1
aLong = -9999999999999999L
aFloat = 3.1415926535897932384626433832795


aComplex = 1.23+4.56J
如何更新数字对象
通过给数字对象(重新)赋值, 您可以“更新”一个数值对象。我们之所以给更新这两个
字加上引号, 是因为实际上你并没有更新该对象的原始数值。这是因为数值对象是不可改变对
象。Python 的对象模型与常规对象模型有些不同。你所认为的更新实际上是生成了一个新的数
值对象,并得到它的引用。
在学习编程的过程中, 我们一直接受这样的教育, 变量就像一个盒子, 里面装着变量的
值。在 Python 中, 变量更像一个指针指向装变量值的盒子。 对不可改变类型来说, 你无法
改变盒子的内容, 但你可以将指针指向一个新盒子。每次将另外的数字赋给变量的时候,实际
上创建了一个新的对象并把它赋给变量.(不仅仅是数字,对于所有的不可变类型,都是这么回
事)
anInt += 1
aFloat = 2.718281828
如何删除数字对象
按照 Python 的法则, 你无法真正删除一个数值对象, 你仅仅是不再使用它而已。如果你
实际上想删除一个数值对象的引用, 使用 del 语句(参见 3.5.6 小节)。 删除对象的引用之
后, 你就不能再使用这个引用(变量名), 除非你给它赋一个新值。如果试图使用一个已经被
删除的对象引用, 会引发 NameError 异常。
del anInt
del aLong, aFloat, aComplex
好了, 既然你已经了解如何创建和更新数值对象, 那么来看下 Python 的四种主要数字类
型。
5.2 整型
Python 有几种整数类型。布尔类型是只有两个值的整型。常规整型是绝大多数现代系统都
能识别的整型。Python 也有长整数类型。然而,它表示的数值大小远超过 C 语言的长整数 。
下面我们先来了解一下这些类型,然后再来研究那些用于 Python 整数类型的运算符和内建函数。


5.2.1       布尔型
Python 从版本 2.3 开始支持布尔类型。该类型的取值范围只有两个值,也就是布尔值 True
和布尔值 False。我们会在本章的末尾一节 5.7.1 详细讲解布尔对象。
5.2.2       标准整数类型
Python 的标准整数类型是最通用的数字类型。在大多数 32 位机器上,标准整数类型的取
值范围是-231      到 231-1,也就是-2,147,483,648 到 2,147,483,647。如果在 64 位机器上使
用 64 位编译器编译 Python,那么在这个系统上的整数将是 64 位。下面是一些 Python 标准整
数类型对象的例子:
0101 84 -237    0x80 017 -680     -0X92
Python 标准整数类型等价于 C 的(有符号)长整型。整数一般以十进制表示,但是 Python
也支持八进制或十六进制来表示整数。如果八进制整数以数字“0”开始, 十六进制整数则以
“0x” 或“0X” 开始。
5.2.3     长整型
关于 Python 长整数类型我们必须要提的是, 请不要将它和 C 或其它编译型语言的长整数
类型混淆。那些语言的长整数典型的取值范围是 32 位或 64 位。Python 的长整数类型能表达的
数值仅仅与你的机器支持的(虚拟)内存大小有关, 换句话说, Python 能轻松表达很大很大很
大的整数。
长整数类型是标准整数类型的超集, 当你的程序需要使用比标准整数类型更大的整数时,
长整数类型就有用武之地了。在一个整数值后面加个 L(大写或小写都可以),表示这个整数是
长整数。这个整数可以是十进制,八进制, 或十六进制。下面是一些长整数的例子:
16384L -0x4E8L 017L -2147483648l 052144364L
299792458l 0xDECADEDEADBEEFBADFEEDDEAL -5432101234L


核心风格:用大写字母 “L”表示长整数
尽管 Python 也支持用小写字母 L 标记的长整型,但是我们郑重推荐您仅使用大写的“L”,
这样能有效避免数字 1 和小写 L 的混淆。Python 在显示长整数类型数值的时候总是用大写                                           “L ”         ,
目前整型和长整型正在逐渐缓慢的统一,您只有在对长整数调用 repr()函数时才有机会看到
“L”,如果对长整数对象调用 str()函数就看不到 L 。举例如下:
>>> aLong = 999999999l
>>> aLong
999999999L
>>> print aLong
999999999
5.2.4 整型和长整型的统一
这两种整数类型正在逐渐统一为一种。在 Python 2.2 以前,标准整数类型对象超出取值范
围会溢出(比如上面提到的大于 232 的数),但是从 Python2.2 以后就再也没有这样的错误了。
Python 2.1
>>> 9999 ** 8
Traceback (most recent call last):
File "<stdin>", line 1, in ?
OverflowError: integer exponentiation
Python 2.2
>>> 9999 ** 8
99920027994400699944002799920001L
移除这个错误是第一步。 下一步修改位移位; 左移比特导致出界(导致 0 值)在过去是
经常可能发生的事;
>>> 2 << 32
0


在 Python2.3 中, 这个操作产生一个警告, 不过在 2.4 版里移除了这个 Warning, 并且
这步操作生成了一个真正的长整数。
Python 2.3
>>> 2 << 32
__main__:1: FutureWarning: x<<y losing bits or changing sign will return a long
in Python 2.4
and up
0
Python 2.4
>>> 2 << 32
8589934592L
不远的将来,至少普通用户会几乎感觉不到长整型的存在。必要时整型会悄悄自动转换为
长整型。当然,那些要调用 C 的人仍然可以继续使用这两种整数类型, 因为 C 代码必须区分不
同的整数类型。如果你想详细了解标准整型与长整型整合的信息,请阅读 PEP237.
5.3     双精度浮点数
Python 中的浮点数类似 C 语言中的 double 类型, 是双精度浮点数,可以用直接的十进制
或科学计数法表示。每个浮点数占 8 个字节(64 比特),完全遵守 IEEE754 号规范(52M/11E/1S)                                                    ,
其中 52 个比特用于表示底,11 个比特用于表示指数(可表示的范围大约是正负 10 的 308.25
次方), 剩下的一个比特表示符号。这看上去相当完美,然而,实际精度依赖于机器架构和创
建 Python 解释器的编译器。
浮点数值通常都有一个小数点和一个可选的后缀 e(大写或小写,表示科学计数法)。在 e
和指数之间可以用正(+)或负(-)表示指数的正负(正数的话可以省略符号)。下面是一些典
型的浮点数值的例子:
0.0      -777.      1.6       -5.555567119     96e3 * 1.0
4.3e25  9.384e-23 -2.172818 float(12)          1.000000001
3.1416  4.2E-10    -90.        6.022e23        -1.609E-19


5.4    复数
在很久以前,数学家们被下面这样的等式困扰。
x2 = -1
这是因为任何实数(无论正数还是负数)乘以自己总是会得到一个非负数。一个数怎么可
以乘以自己却得到一个负数?没有这样的实数存在。就这样, 直到 18 世纪, 数学家们发明了
一个虚拟的数 i (或者叫 j,看你读的是哪本教科书了)
j=
基于这个特殊的数(或者称之为概念)                 ,数学从此有了一个新的分支。现在虚数已经广泛应
用于数值和科学计算应用程序中。一个实数和一个虚数的组合构成一个复数。一个复数是一对
有序浮点数(x, y)。表示为 x + yj, 其中 x 是实数部分,y 是虚数部分。
渐渐的复数在日常运算,机械,电子等行业获得了广泛的应用。由于一些研究人员不断的重
复制造用于复数运算的工具, 在很久以前的 Python1.4 版本里,复数终于成为一个真正的
Python 数据类型。
下面是 Python 语言中有关复数的几个概念:
z   虚数不能单独存在,它们总是和一个值为 0.0 的实数部分一起来构成一个复数。
z   复数由实数部分和虚数部分构成
z   表示虚数的语法: real+imagj
z   实数部分和虚数部分都是浮点数
z   虚数部分必须有后缀 j 或 J。
下面是一些复数的例子:
64.375+1j 4.23-8.5j  0.23-8.55j          1.23e-045+6.7e+089j
6.23+1.5j -1.23-875J  0+1j       9.80665-8.31441J      -.0224+0j
5.4.1     复数的内建属性
复数对象拥有数据属性(参见 4.1.1 节), 分别为该复数的实部和虚部。复数还拥有
conjugate 方法, 调用它可以返回该复数的共轭复数对象。(两头牛背上的架子称为轭,轭使


两头牛同步行走。共轭即为按一定的规律相配的一对——译者注)
表 5.1 复数属性
属性                  描述
num.real           该复数的实部
num num.imag       该复数的虚部
num.conjugate()    返回该复数的共轭复数
>>> aComplex = -8.333-1.47j
>>> aComplex
(-8.333-1.47j)
>>> aComplex.real
-8.333
>>> aComplex.imag
-1.47
>>> aComplex.conjugate()
(-8.333+1.47j)
表 5.1 描述了复数的所有属性
5.5 运算符
数值类型可进行多种运算。从标准运算符到数值运算符,甚至还有专门的整数运算符。
5.5.1 混合模式运算符
也许你还记得, 过去将两个数相加时, 你必须努力保证操作数是合适的类型。自然而然的,
加法总是使用 + 号, 然而在计算机语言看来这件事没那么简单,因为数字又有很多不同的类
型。
当两个整数相加时, + 号表示整数加法, 当两个浮点数相加时, + 表示浮点数加法, 依
此类推。在 Python 中, 甚至非数字类型也可以使用 + 运算符。举例来说, 字符串 A + 字符
串 B 并不表示加法操作, 它表示的是把这两个字符串连接起来, 生成一个新的字符串。关键
之处在于支持 + 运算符的每种数据类型, 必须告诉 Python, + 运算符应该如何去工作。 这
也体现了重载概念的具体应用。


虽然我们不能让一个数字和一个字符串相加, 但 Python 确实支持不同的数字类型相加。
当一个整数和一个浮点数相加时, 系统会决定使用整数加法还是浮点数加法(实际上并不存在
混合运算)。Python 使用数字类型强制转换的方法来解决数字类型不一致的问题, 也就是说它
会强制将一个操作数转换为同另一个操作数相同的数据类型。这种操作不是随意进行的, 它遵
循以下基本规则。
首先,如果两个操作数都是同一种数据类型,没有必要进行类型转换。仅当两个操作数类
型不一致时, Python 才会去检查一个操作数是否可以转换为另一类型的操作数。如果可以,
转换它并返回转换结果。由于某些转换是不可能的,比如果将一个复数转换为非复数类型, 将
一个浮点数转换为整数等等,因此转换过程必须遵守几个规则。
要将一个整数转换为浮点数,只要在整数后面加个 .0 就可以了。 要将一个非复数转换为
复数,则只需要要加上一个 “0j” 的虚数部分。这些类型转换的基本原则是: 整数转换为浮
点数, 非复数转换为复数。 在 Python 语言参考中这样描述 coerce() 方法:
z  如果有一个操作数是复数, 另一个操作数被转换为复数。
z   否则,如果有一个操作数是浮点数, 另一个操作数被转换为浮点数。
z   否则, 如果有一个操作数是长整数,则另一个操作数被转换为长整数;
z   否则,两者必然都是普通整数,无须类型转换。(参见下文中的示意图)
图 5-1 的流程图阐释了强制转换的规则。数字类型之间的转换是自动进行的,程序员无须
自己编码处理类型转换。不过在确实需要明确指定对某种数据类型进行特殊类型转换的场合,
Python 提供了 coerce() 内建函数来帮助你实现这种转换。(见 5.6.2 小节)


图 5-1 数值类型转换
下面演示一下 Python 的自动数据类型转换。为了让一个整数和一个浮点数相加, 必须使
二者转换为同一类型。因为浮点数是超集,所以在运算开始之前, 整数必须强制转换为一个浮
点数,运算结果也是浮点数:
>>> 1 + 4.5
5.5


5.5.2         标准类型运算符
第四章中讲到的标准运算符都可以用于数值类型。上文中提到的混合模式运算问题, 也就
是不同数据类型之间的运算, 在运算之前,Python 内部会将两个操作数转换为同一数据类型。
下面是一些数字标准运算的例子:
>>> 5.2 == 5.2
True
>>> -719 >= 833
False
>>> 5+4e >= 2-3e
True
>>> 2 < 5 < 9 # same as ( 2 < 5 ) and ( 5 < 9 )
True
>>> 77 > 66 == 66 # same as ( 77 > 66 ) and ( 66 == 66 )
True
>>> 0. < -90.4 < 55.3e2 != 3 < 181
False
>>> (-1 < 1) or (1 < -1)
True
5.5.3         算术运算符
Python 支持单目运算符正号(+)和负号(-), 双目运算符, +,-,*,/,%,还有 ** ,
分别表示加法,减法, 乘法, 除法, 取余, 和幂运算。从 Python2.2 起,还增加了一种新
的整除运算符 // 。
除法
拥有 C 背景的程序员一定熟悉传统除法――也就是说, 对整数操作数,会执行“地板除”
(floor,取比商小的最大整数。例如 5 除以 2 等于 2.5,其中“2”就称为商的“地板”,即“地
板除”的结果。本书中使用“地板除”的说法是为了沿用原作者的风格,译者注)。对浮点操作
数会执行真正的除法。然而,对第一次学编程的人或者那些依赖精确计算的人来说,可能就需
要多次调整代码才能得到自己想要的结果。
在未来的 Python 版本中,Python 开发小组已经决定改变 / 运算符的行为。/ 的行为将变
更为真正的除法, 会增加一种新的运算来表示地板除。 下面我们总结一下 Python 现在的除法
规则, 以及未来的除法规则:


传统除法
如果是整数除法, 传统除法会舍去小数部分,返回一个整数(地板除)。如果操作数之一
是浮点数,则执行真正的除法。包括 Python 语言在内的很多语言都是这种行为。看下面的例子:
>>> 1 / 2 # perform integer result (floor) # 地板除
0
>>> 1.0 / 2.0 # returns actual quotient#真正除法
0.5
真正的除法
除法运算总是返回真实的商, 不管操作数是整数还是浮点数。在未来版本的 Python 中,
这将是除法运算的标准行为。现阶段通过执行 from __future__ import division 指令, 也
可以做到这一点。
>>> from __future__ import division
>>>
>>> 1 / 2 # returns real quotient
0.5
>>> 1.0 / 2.0 # returns real quotient
0.5
地板除
从 Python 2.2 开始, 一个新的运算符 // 已经被增加进来, 以执行地板除: // 除法不
管操作数何种数值类型,总是舍去小数部分,返回数字序列中比真正的商小的最接近的数字。
>>> 1 // 2 # floors result, returns integer # 地板除, 返回整数
0
>>> 1.0 // 2.0 # floors result, returns float # 地板除, 返回浮点数
0.0
>>> -1 // 2 # move left on number line# 返回比 –0.5 小的整数, 也就是 -1
-1


关于除法运算的变更, 支持的人和反对的人几乎一样多。有些人认为这种变化是错误的,
有些人则不想修改自己的现有代码,而剩下的人则想要真正的除法。
之所以会有这种变化是因为 Python 的核心开发团队认为 Python 的除法运算从一开始就设
计失误。特别是, 随着 Python 的逐渐发展, 它已经成为那些从未接触过地板除的人们的首选
学习语言。Python 语言的发明人 范•罗萨姆 在他的 《Python 2.2 新增功能》一文中讲到:
def velocity(distance, totalTime):
rate = distance / totalTime
你可能会说, 只要有一个参数为浮点数这个函数就能正常工作。像上面提到的那样,要确
保 它 能 正 常 工 作 需 要 强 制 将 参 数 转 换 为 浮 点 类 型 , 也 就 是 rate = float(distance) /
float(totalTime)。将来除法将变更为真正的除法,上面的代码可以无需更改正常工作。需要
地板除的地方只需要改变为两个连续的 除号。
是的, 代码会受到一些影响, Python 团队已经创作了一系列脚本帮助你转换旧代码,
以确保它能适应新的除法行为。而且对那些强烈需要某种除法行为的人来说, Python 解释器
提供了 Qdivision_style 启动参数。 -Qnew 执行新的除法行为, -Qold 则执行传统除法行
为(默认为 Qold)。你也可以帮助你的用户使用-Qwarn 或 –Qwarnall 参数度过过渡时期。
关于这次变化的详细信息可以参考 PEP238。如果你对这场论战感兴趣,也可以翻阅 2001
年的 comp.lang.python 归档。 表 5.2 总结了除法运算符在不同 Python 版本中的行为差异。
取余
整数取余相当容易理解, 浮点数取余就略复杂些。
表 5.2 除法操作符的行为


商取小于等于精确值的最大整数的乘积之差. 即:                        x - (math.floor(x/y) * y) 或者
对于复数,取余的定义类似于浮点数,不同之处在于商仅取其实数部分,即:
x - (math.floor((x/y).real) * y)。
幂运算
幂运算操作符和一元操作符之间的优先级关系比较特别: 幂运算操作符比其左侧操作数
的一元操作符优先级低,比
起右侧操作数的一元操作符的优先级高,由于这个特性你会在算术运算符表中找到两个
** .下面举几个例子:
>>> 3 ** 2
9
>>> -3 ** 2 # ** 优先级高于左侧的 -
-9
>>> (-3) ** 2 # 加括号提高 -的优先级
9
>>> 4.0 ** -1.0 # ** 优先级低于右侧的 -
0.25
第 2 种情况下解释器先计算 3**2 再取其相反数,我们需要给"-3"加上括号来得到我们希


望的结果。最后一个例子,结果是 4**(-1),这是按照规定的优先级获得的结果.
>>> 4 ** -1
Traceback (innermost last):
File "<stdin>", line 1, in ?
ValueError: integer to the negative power
总结
表 5.3 总结了所有的算术运算符, 从上到下, 计算优先级依次降低。 这里列出的所有
运算符都比即将在 5.5.4 小节讲到的位运算符优先级高。
表 5.3 算术运算符
算术去处符                  功能 
表达式1 表达式2                结果
+expr                    结果符号不变 
-expr                    对结果符号取负 
表达式1 表达式2                结果
expr1 * expr2           表达式1 乘 表达式2
expr1 / expr2           表达式1 除以 表达式2(传统除或真正除)   
expr1 // expr2          表达式1 地板除以 表达式2
expr1 % expr2           表达式1 对表达式2 取余
expr1 + expr2           表达式1 加 表达式2
expr1 - expr2           表达式1 减 表达式2
注:** 运算符优先级高于单目运算符
下面是更多 Python 数值运算的例子:
>>> -442 - 77
-519
>>>


>>> 4 ** 3
64
>>>
>>> 4.2 ** 3.2
98.7183139527
>>> 8 / 3
2
>>> 8.0 / 3.0
2.66666666667
>>> 8 % 3
2
>>> (60. - 32.) * ( 5. / 9. )
15.5555555556
>>> 14 * 0x04
56
>>> 0170 / 4
30
>>> 0x80 + 0777
639
>>> 45L * 22L
990L
>>> 16399L + 0xA94E8L
709879L
>>> -2147483648L - 52147483648L
-54294967296L
>>> 64.375+1j + 4.23-8.5j
(68.605-7.5j)
>>> 0+1j ** 2 # same as 0+(lj**2)
(-1+0j)
>>> 1+1j ** 2 # same as 1+(lj**2)
0j
>>> (1+1j) ** 2
2j
注意指数运算符的优先级高于连接实部和虚部的+号运算符。就上面最后一个例子来说, 我
们人为的加上了括号,这就改变运算顺序, 从而得到我们想要的结果。
5.5.4         *位运算符(只适用于整数)


Python 整数支持标准位运算:取反(~),按位 与(&), 或(|) 及 异或(^) 及左移(<<)和右
移(>>)。Python 这样处理位运算:
z 负数会被当成正数的 2 进制补码处理。
z 左移和右移 N 位等同于无溢出检查的 2 的 N 次幂运算: 2**N。
z 对长整数来说, 位运算符使用一种经修改的 2 进制补码形式,使得符号位可以无限的
向左扩展。
取反(~)运算的优先级与数字单目运算符相同, 是所有位操作符中优先级最高的一个。 左
移和右移运算的优先级次之,但低于加减法运算。与, 或, 异或 运算优先级最低。所有位运
算符按优先级高低列在表 5.4 中。
表 5.4     整型位运算符
位运算符                       功能 
~num                     单目运算,对数的每一位取反。结果为 
num1 << num2             Num1 左移 num2 位 
num1 >> num2             Num1 右移 num2 位 
num1 & num2              num1 与 num2 按位 与
num1 ^ num2             num1 异或 num2
num1 | num2             num1 与 num2 按位 或
下面是几个使用整数 30(011110),45(101101),60(111100)进行位运算的例子:
>>> 30 & 45
12


>>> 30 | 45
63
>>> 45 & 60
44
>>> 45 | 60
61
>>> ~30
-31
>>> ~45
-46
>>> 45 << 1
90
>>> 60 >> 2
15
>>> 30 ^ 45
51
5.6    内建函数与工厂函数
5.6.1      标准类型函数
在上一章中, 我们介绍了 cmp(), str() 和 type() 内建函数。 这些函数可以用于所有
的标准类型。对数字对象来说, 这些函数分别比较两个数的大小, 将数字转换为字符串, 以
及返回数字对象的类型。
>>> cmp(-6, 2)
-1
>>> cmp(-4.333333, -2.718281828)
-1
>>> cmp(0xFF, 255)
0
>>> str(0xFF)
'255'
>>> str(55.3e2)
'5530.0'
>>> type(0xFF)
<type 'int'>
>>> type(98765432109876543210L)


<type 'long'>
>>> type(2-1j)
<type 'complex'>
5.6.2         数字类型函数
Python 现在拥有一系列针对数字类型的内建函数。一些函数用于数字类型转换, 另一些
则执行一些常用运算。
转换工厂函数
函数 int(), long(), float() 和 complex() 用来将其它数值类型转换为相应的数值类型。
从 Python 1.5 版本开始, 这些函数也接受字符串参数, 返回字符串所表示的数值。从 Python
1.6 版开始,int() 和 long() 在转换字符串时,接受一个进制参数。如果是数字类型之间的
转换,则这个进制参数不能使用。
从 Python2.2 起, 有了第五个内建函数 bool()。它用来将整数值 1 和 0 转换为标准布尔
值 True 和 False. 从 Python2.3 开始, Python 的标准数据类型添加了一个新成员:布尔
(Boolean)类型。从此 true 和 false 现在有了常量值即 True 和 False(不再是 1 和 0)。
要了解布尔类型的更多信息, 参阅 5.7.1 小节。
另外, 由于 Python 2.2 对类型和类进行了整合(这里指 Python 的传统风格类和新风格类
——译者注), 所有这些内建函数现在都转变为工厂函数。我们曾经在第四章介绍过工厂函数,
所谓工厂函数就是指这些内建函数都是类对象, 当你调用它们时,实际上是创建了一个类实例。
不过不用担心, 这些函数的使用方法并没有什么改变。
下面是一些使用内建函数的示例:
>>> int(4.25555)
4
>>> long(42)
42L
>>> float(4)
4.0
>>> complex(4)
(4+0j)
>>>


>>> complex(2.4, -8)
(2.4-8j)
>>>
>>> complex(2.3e-10, 45.3e4)
(2.3e-10+453000j)
表 5.5 数值工厂函数总结
类(工厂函数)                                       操作 
bool(obj) b                    返回obj对象的布尔值,也就是
obj.__nonzero__()方法的返回值
int(obj, base=10)              返回一个字符串或数值对象的整数表
示,  类似string.atoi();从Python 1.6起,
引入了可选的进制参数。
long(obj, base=10)             返回一个字符或数据对象的长整数表
示,类似string.atol(),  从Python1.6起, 
引入了可选的进制参数
float(obj)              返回一个字符串或数据对象的浮点数
表示,类似string.atof()
complex(str) or
complex(real, imag=0.0)                 返回一个字符串的复数表示,或
者根据给定的实数(及一个可选
的虚数部分)生成一个复数对象。
a.  在 Python2.3 之前, 这些都是内建函数
b.  Python2.2 中新增的内建函数,在 Python2.3 中改变为工厂函数
功能函数
Python 有五个运算内建函数用于数值运算: abs(), coerce(), divmod(), pow(), pow()
和 round()。我们将对这些函数逐一浏览,并给出一些有用的例子:


abs()返回给定参数的绝对值。如果参数是一个复数,那么就返回 math.sqrt(num.real2                                             +
num.imag2)。下面是几个 abs()函数的示例:
>>> abs(-1)
1
>>> abs(10.)
10.0
>>> abs(1.2-2.1j)
2.41867732449
>>> abs(0.23 - 0.78)
0.55
函数 coerce(),尽管从技术上讲它是一个数据类型转换函数,不过它的行为更像一个运算
符,因此我将它放到了这一小节。在 5.5.1 小节,我们讨论了 Python 如何执行数值类型转换。
函数 coerce()为程序员提供了不依赖 Python 解释器, 而是自定义两个数值类型转换的方法。
对一种新创建的数值类型来说, 这个特性非常有用。函数 coerce()仅回一个包含类型转换完
毕的两个数值元素的元组。下面是几个例子:
>>> coerce(1, 2)
(1, 2)
>>>
>>> coerce(1.3, 134L)
(1.3, 134.0)
>>>
>>> coerce(1, 134L)
(1L, 134L)
>>>
>>> coerce(1j, 134L)
(1j, (134+0j))
>>>
>>> coerce(1.23-41j, 134L)
((1.23-41j), (134+0j))
divmod()内建函数把除法和取余运算结合起来, 返回一个包含商和余数的元组。对整数来
说,它的返回值就是地板除和取余操作的结果。对浮点数来说, 返回的商部分是
math.floor(num1/num2),对复数来说, 商部分是 ath.floor((num1/num2).real)。
>>> divmod(10,3)
(3, 1)
>>> divmod(3,10)


(0, 3)
>>> divmod(10,2.5)
(4.0, 0.0)
>>> divmod(2.5,10)
(0.0, 2.5)
>>> divmod(2+1j, 0.5-1j)
(0j, (2+1j))
函数 pow() 和双星号 (**) 运算符都可以进行指数运算。不过二者的区别并不仅仅在于
一个是运算符,一个是内建函数。
在 Python 1.5 之前,并没有 ** 运算符。内建函数 pow()还接受第三个可选的参数,一个
余数参数。如果有这个参数的, pow() 先进行指数运算,然后将运算结果和第三个参数进行取
余运算。这个特性主要用于密码运算,并且比 pow(x,y) % z 性能更好, 这是因为这个函数的
实现类似于 C 函数 pow(x,y,z)。
>>> pow(2,5)
32
>>>
>>> pow(5,2)
25
>>> pow(3.141592,2)
9.86960029446
>>>
>>> pow(1+1j, 3)
(-2+2j)
内建函数 round()用于对浮点数进行四舍五入运算。它有一个可选的小数位数参数。如果
不提供小数位参数, 它返回与第一个参数最接近的整数(但仍然是浮点类型)。第二个参数告
诉 round 函数将结果精确到小数点后指定位数。
>>> round(3)
3.0
>>> round(3.45)
3.0
>>> round(3.4999999)
3.0
>>> round(3.4999999, 1)
3.5
>>> import math


>>> for eachNum in range(10):
... print round(math.pi, eachNum)
...
3.0
3.1
3.14
3.142
3.1416
3.14159
3.141593
3.1415927
3.14159265
3.141592654
3.1415926536
>>> round(-3.5)
-4.0
>>> round(-3.4)
-3.0
>>> round(-3.49)
-3.0
>>> round(-3.49, 1)
-3.5
值得注意的是 round() 函数是按四舍五入的规则进行取整。也就是 round(0.5)得到 1,
round(-0.5)得到-1。猛一看 int(), round(), math.floor() 这几个函数好像做的是同一件
事, 很容易将它们弄混,是不是?下面列出它们之间的不同之处:
z 函数 int()直接截去小数部分。(返回值为整数)
z 函数 floor()得到最接近原数但小于原数的整数。(返回值为浮点数)
z 函数 round()得到最接近原数的整数。(返回值为浮点数)
z 的例子用四个正数和四个负数作为这三个函数的参数,将返回结果列在一起做个比较。
(为了便于比较,我们将 int()函数的返回值也转换成了浮点数)。
>>> import math
>>> for eachNum in (.2, .7, 1.2, 1.7, -.2, -.7, -1.2, -1.7):
... print "int(%.1f)\t%+.1f" % (eachNum, float(int(each-
Num)))
... print "floor(%.1f)\t%+.1f" % (eachNum,


... math.floor(eachNum))
... print "round(%.1f)\t%+.1f" % (eachNum, round(eachNum))
... print '-' * 20
...
int(0.2) +0.0
floor(0.2) +0.0
round(0.2) +0.0
--------------------
int(0.7) +0.0
floor(0.7) +0.0
round(0.7) +1.0
--------------------
int(1.2) +1.0
floor(1.2) +1.0
round(1.2) +1.0
--------------------
int(1.7) +1.0
floor(1.7) +1.0
round(1.7) +2.0
--------------------
int(-0.2) +0.0
floor(-0.2) -1.0
round(-0.2) +0.0
--------------------
int(-0.7) +0.0
floor(-0.7) -1.0
round(-0.7) -1.0
--------------------
int(-1.2) -1.0
floor(-1.2) -2.0
round(-1.2) -1.0
--------------------
int(-1.7) -1.0
floor(-1.7) -2.0
round(-1.7) -2.0
表 5.6    数值运算函数一览
表 5.6 数值运算内建函数


函数                             功能 
abs(num)                         返回 num 的绝对值
coerce(num1, num2) 将num1和num2转换为同一类型,然后以一个  元组的形式
返回。
divmod(num1, num2) 除法-取余运算的结合。返回一个元组(num1/num2,num1 % 
num2)。对浮点数和复数的商进行下舍入(复数仅取实    
数部分的商) 
pow(num1, num2, mod=1) 取 num1 的 num2次方,如果提供 mod参数,则计算结果
再对mod进行取余运算 
round(flt, ndig=0) 接受一个浮点数  flt  并对其四舍五入,保存  ndig位小数。
若不提供ndig  参数,则默认小数点后0位。 

round()仅用于浮点数。(译者注:整数也可以,  不过并没有什么
实际意义) 
5.6.3         仅用于整数的函数
除了适应于所有数值类型的内建函数之外,Python 还提供一些仅适用于整数的内建函数(标
准整数和长整数)。这些函数分为两类,一类用于进制转换,另一类用于 ASCII 转换。
进制转换函数
前面我们已经看到,除了十进制标准,Python 整数也支持八进制和 16 进制整数。 除此之
外,Python 还提供了两个内建函数来返回字符串表示的 8 进制和 16 进制整数。它们分别是 oct()
和 hex()。它们都接受一个整数(任意进制的)对象,并返回一个对应值的字符串对象。下面
是几个示例:
>>> hex(255)
'0xff'


>>> hex(23094823l)
'0x1606627L'
>>> hex(65535*2)
'0x1fffe'
>>>
>>> oct(255)
'0377'
>>> oct(23094823l)
'0130063047L'
>>> oct(65535*2)
'0377776'
ASCII 转换函数
Python 也提供了 ASCII(美国标准信息交换码)码与其序列值之间的转换函数。每个字符
对应一个唯一的整数(0-255)。对所有使用 ASCII 表的计算机来说, 这个数值是不变的。这
保证了不同系统之间程序行为的一致性。函数 chr()接受一个单字节整数值,返回一个字符串,
其值为对应的字符。函数 ord()则相反,它接受一个字符,返回其对应的整数值。
>>> ord('a')
97
>>> ord('A')
65
>>> ord('0')
48
>>> chr(97)
'a'
>>> chr(65L)
'A'
>>> chr(48)
'0'
表 5.7 列出了用于整数类型的所有内建函数
表 5.7 仅适用于整数的内建函数
函数                      操作 


hex(num)    将数字转换成十六进制数并以字符串形式返回 
oct(num)    将数字转换成八进制数并以字符串形式返回 
chr(num)    将ASCII值的数字转换成ASCII字符,范围只
能是0 <= num <= 255。 
ord(chr)    接受一个  ASCII  或  Unicode  字符(长度为1的字符串),返回相应的ASCII 
或Unicode  值。 
unichr(num)    接受Unicode码值,返回  其对应的Unicode字符。所接受的码值范围依赖于
你的Python是构建于UCS‐2还是UCS‐4。 
5.7    其他数字类型
5.7.1       布尔“数”
从 Python2.3 开始,布尔类型添加到了 Python 中来。尽管布尔值看上去是“True”和“False,
但是事实上是整型的子类,对应与整数的 1 和 0。下面是有关布尔类型的主要概念:
z   有两个永不改变的值 True 或 False。
z   布尔型是整型的子类,但是不能再被继承而生成它的子类。
z   没有__nonzero__()方法的对象的默认值是 True。
z   对于值为零的任何数字或空集(空列表、空元组和空字典等)在 Python 中的布尔值都
是 False。
z   在数学运算中,Boolean 值的 True 和 False 分别对应于 1 和 0。
z   以前返回整数的大部分标准库函数和内建布尔型函数现在返回布尔型。
z   True 和 False 现在都不是关键字,但是在 Python 将来的版本中会是。
所有 Python 对象都有一个内建的 True 或 False 值,对内建类型来说,这个值究竟是 True
还是 False 请参阅章节 4.3.2 中的核心备注。下面是使用内建类型布尔值的一些例子:


# intro
>>> bool(1) True
>>> bool(True) True
>>> bool(0) False
>>> bool('1') True
>>> bool('0') True
>>> bool([]) False
>>> bool ( (1,) ) True
# 使用布尔数
>>> foo = 42
>>> bar = foo < 100
>>> bar
True
>>> print bar + 100
101
>>> print '%s' % bar
True
>>> print '%d' % bar
1
# 无 __nonzero__()
>>> class C: pass
>>> c = C()
>>>
>>> bool(c) True
>>> bool(C) True
# 重载 __nonzero__() 使它返回 False
>>> class C:
... def __nonzero__(self):
... return False
...
>>> c = C()
>>> bool(c) False
>>> bool(C) True
# 哦,别这么干!! (无论如何不要这么干!)
>>> True, False = False, True
>>> bool(True) False


>>> bool(False) True
你可以在 Python 文档和 PEP 285 看到有关布尔类型的知识。
5.7.2         十进制浮点数
从 Python2.4 起(参阅 PEP327)十进制浮点制成为一个 Python 特性。这主要是因为下面
的语句经常会让一些编写科学计算或金融应用程序的程序员抓狂:
>>> 0.1
0.1000000000000001
为什么会这样?这是因为语言绝大多数 C 语言的双精度实现都遵守 IEEE 754 规范,其中
52 位用于底。因此浮点值只能有 52 位精度,类似这样的值的二进制表示只能象上面那样被截
断。0.1 的二进制表示是 0.11001100110011 . . .
因为最接近的二进制表示就是.0001100110011...或 1/16 +1/32 + 1/256 + . . .
你可以看到,这些片断不停的重复直到舍入出错。如果我们使用十进制来做同样的事情,
感觉就会好很多,看上去会有任意的精度。注意下面,你不能混用十进制浮点数和普通的浮点
数。你可以通过字符串或其它十进制数创建十进制数浮点数。你必须导入 decimal 模块以便
使用 Decimal 类:
>>> from decimal import Decimal
>>> dec = Decimal(.1)
Traceback (most recent call last): File "<stdin>", line 1, in ?
File "/usr/local/lib/python2.4/decimal.py", line 523, in __new__
raise TypeError("Cannot convert float to Decimal. " +
TypeError: Cannot convert float to Decimal. First convert the float to
a string
>>> dec = Decimal('.1')
>>> dec
Decimal("0.1")
>>> print dec
0.1
>>> dec + 1.0
Traceback (most recent call last): File "<stdin>", line 1, in ?
File "/usr/local/lib/python2.4/decimal.py", line 906, in __add__
other = _convert_other(other)
File "/usr/local/lib/python2.4/decimal.py", line 2863, in
_convert_other


raise TypeError, "You can interact Decimal only with int, long or
Decimal data types."
TypeError: You can interact Decimal only with int, long or Decimal data types.
>>>
>>> dec + Decimal('1.0') Decimal("1.1")
>>> print dec + Decimal('1.0')
1.1
你可以从 Python 文档中读取相关的 PEP 以了解十进制数。值得庆幸的是,十进制数和其
它数值类型一样, 可以使用同样的算术运算符。由于十进制数本质上是一种用于数值计算的特
殊类, 我们在本章的剩余部分将不再专门讲解十进制数。
5.8     相关模块
在 Python 标准库中有不少专门用于处理数值类型对象的模块,它们增强并扩展了内建函数
的功能和数值运算的功能。 表 5.8 列出了几个比较核心的模块。要详细了解这些模块,请参阅
这些模块的文献或在线文档。
对高级的数字科学计算应用来说,你会对著名的第三方包 Numeric(NumPy) 和 SciPy 感兴
趣。关于这两个包的详细请访问下面的网址。
http://numeric.scipy.org/
http://scipy.org/
表 5.8        数字类型相关模块
模块                    介绍 
decimal             十进制浮点运算类  Decimal 
array               高效数值数组(字符,整数,浮点数等等) 
math/cmath 标准C库数学运算函数。常规数学运算在match模块,
复数运算在cmath模块 
operator            数字运算符的函数实现。比如 tor.sub(m,n)等价


于 m - n
random       多种伪随机数生成器
核心模块: random
当你的程序需要随机数功能时,random 模块就能派上用场。该模块包含多个伪随机数发生
器,它们均以当前的时间戳为随机数种子。这样只要载入这个模块就能随时开始工作。下面列
出了该模块中最常用的函数:
两个整数参数,返回二者之间的随机整数
randrange()      它 接 受 和        range() 函 数 一 样 的 参 数 ,                   随 机 返 回
range([start,]stop[,step])结果的一项
uniform() 几乎和 randint()一样,不过它返回的是二者之间的一个浮点数(不包括范围
上限)。
random() 类似 uniform() 只不过下限恒等于 0.0,上限恒等于 1.0
choice() 随机返回给定序列(关于序列,见第六章)的一个元素
到这儿,我们的 Python 数值类型之旅就该结束了。
表 5.9 总结了数值类型的所有内建函数和运算符。


运算符/内建函数  描述          整型    长整型      浮点型    复数      结果 




Table 5.9 Operators and Built-in Functions for All Numeric Types


(continued)
Operator/ 
Built‐in                Description         Int        Long Float        Complex                     Resulta 

+          Addition                 •   •        •           •       number 
加法                                                         
-          Subtraction              •   •        •           •       number 
减法                                                         
<<         Bit left shift           •   •                            int/lo
位左移                             
>>         Bit right shift          •   •                            int/lo
位右移                          
&           Bitwise AND             •    •                            int/lo
按位与运算                          
^           Bitwise XOR             •    •                            int/lo
按位异或运算                         
|           Bitwise OR              •ˇ  •ˇˇ                           int/lo
按位或运算                        

a.  结果为 number 表示可以为所有四种数值类型,可能与操作数相同
b.    与单目运算符有特殊关系,参阅 5.5.3 小节和表 5.2
c.  单目运算符
5.9 练习
本章的练习可以先通过应用程序的形式实现。一旦功能齐备并且调试通过, 建议读者将自
己的代码功能用函数封装起来,以便 在后面的练习中重用代码。关于编程风格我在这儿提醒一
下,最好不要在函数内使用 print 语句输出信息,而是通过 return 语句返回必要的值。 这
样调用函数的代码就可以自己处理显示方式。这样你的代码就适应性更广,更便于重用。


5-1 整形 讲讲 Python 普通整型和长整型的区别
5-2 运算符
(a) 写一个函数,计算并返回两个数的乘积
(b) 写一段代码调用这个函数,并显示它的结果
5-3 标准类型运算符. 写一段脚本,输入一个测验成绩,根据下面的标准,输出他的评分
成绩(A-F)。
A: 90–100
B: 80–89
C: 70–79
D: 60–69
F: <60
5-4 取余。判断给定年份是否是闰年。使用下面的公式:
一个闰年就是指它可以被 4 整除,但不能被 100 整除, 或者它既可以被 4 又可以被 100 整
除。比如 1992,1996 和 2000 年是闰年,但 1967 和 1900 则不是闰年。下一个是闰年的整世
纪是 2400 年。
5-5 取余。取一个任意小于 1 美元的金额,然后计算可以换成最少多少枚硬币。硬币有 1
美分,5 美分,10 美分,25 美分四种。1 美元等于 100 美分。举例来说,0.76 美元换算结果
应该是 3 枚 25 美分,1 枚 1 美分。类似 76 枚 1 美分,2 枚 25 美分+2 枚 10 美分+1 枚 5 美分+1
枚 1 美分这样的结果都是不符合要求的。
5-6 算术。写一个计算器程序 你的代码可以接受这样的表达式,两个操作数加一个运算符:
N1 运算符 N2. 其中 N1 和 N2 为整数或浮点数,运算符可以是+, -, *, /, %, ** 分别表示
加法,减法, 乘法, 整数除,取余和幂运算。计算这个表达式的结果,然后显示出来。提示:
可以使用字符串方法 split(),但不可以使用内建函数 eval().
5-7 营业税。随意取一个商品金额,然后根据当地营业税额度计算应该交纳的营业税。
5-8 几何。计算面积和体积:
(a) 正方形 和 立方体
(b) 圆 和 球
5–9.    数值形式 回答下面关于数值格式的问题:
(a) 为什么下面的例子里 17+32 等于 49, 而 017+32 等于 47, 017+032 等于 41?
>>> 17 + 32


49
>>> 017+ 32
47
>>> 017 + 032
41
(b)为什么下面这个表达式我们得到的结果是 134L 而不是 1342 ?
>>> 56l + 78l
134L
5-10 转换。写一对函数来进行华氏度到摄氏度的转换。转换公式为 C = (F - 32) * (5 / 9)
应该在这个练习中使用真正的除法, 否则你会得到不正确的结果。
5-11 取余。
(a) 使用循环和算术运算,求出 0-20 之间的所有偶数
(b) 同上,不过这次输出所有的奇数
(c) 综合 (a) 和 (b), 请问辨别奇数和偶数的最简单的方法是什么?
(d) 使用(c)的成果,写一个函数,检测一个整数能否被另一个整数整除。 先要求用户输
入两个数,然后你的函数判断两者是否有整除关系,根据判断结果分别返回 True 和 False;
5-12 系统限制。写一段脚本确认一下你的 Python 所能处理的整数,长整数,浮点数和复
数的范围。
5-13 转换。写一个函数把由小时和分钟表示的时间转换为只用分钟表示的时间。
5-14 银行利息。写一个函数,以定期存款利率为参数, 假定该账户每日计算复利,请计
算并返回年回报率。
5–15.    最大公约数和最小公倍数。请计算两个整数的最大公约数和最小公倍数。
5-16 家庭财务。给定一个初始金额和月开销数, 使用循环,确定剩下的金额和当月的支
出数, 包括最后的支出数。 Payment() 函数会用到初始金额和月额度, 输出结果应该类似下
面的格式(例子中的数字仅用于演示):
Enter opening balance:100.00


Enter monthly payment: 16.13
Amount Remaining
Pymt# Paid       Balance
----- ------   ---------
0     $ 0.00     $100.00
1     $16.13     $ 83.87
2     $16.13     $ 67.74
3     $16.13     $ 51.61
4     $16.13     $ 35.48
5     $16.13     $ 19.35
6     $16.13     $ 3.22
7     $ 3.22     $ 0.00
5-17 随机数。熟读随机数模块然后解下面的题:
生成一个有 N 个元素的由随机数 n 组成的列表, 其中 N 和 n 的取值范围分别为: (1 <
N <= 100), (0 <= n <= 231 -1)。然后再随机从这个列表中取 N (1 <= N <= 100)个随机数
出来, 对它们排序,然后显示这个子集。


序列: 
字符串、列表和元
组 
本章主题
z 序列简介
z 字符串
z 列表
z 元组


接下来我们要研究这样一些 Python 的类型,它们的成员有序排列的,并且可以通过下标
偏移量访问到它的一个或者几个成员,这类 Python 类型统称为序列,包括下面这些:字符串(普
通字符串和 unicode 字符串),列表,和元组类型。
因为这些类型其实都是由一些成员共同组成的一个序列整体,所以我们把它们统称为序列,
比如说,一个字符串是由一些字符(尽管 Python 并没有显式的定义字符这个类型)组成的序列,
那么“Hello”这个字符串的第一个字符就是“H",第二个字符就是‘e’......,同样的,列表类
型和元组类型就是其他一些 Python 对象所组成的序列。
首先我们来熟悉一下适用于所有序列类型的操作符和内建函数(BIFs),
z 简介
z 操作符
z 内建函数
z 内建函数(如果可用)
z 特性(如果可用)
z 相关模块(如果可用)
在本章的末尾我们会给出一个对于所有序列类型都适用的操作符和函数的参考图表,现


在让我们概略看一下这些内容.
N == 序列的长度 == len(sequence)
Figure 6-1    有多少可以保存并可以被访问的序列元素
6.1    序列
序列类型有着相同的访问模式:它的每一个元素可以通过指定一个偏移量的方式得到。而
多个元素可以通过切片操作的方式一次得到,切片操作会在接下来的内容中讲到。下标偏移量
是从 0 开始到 总元素数-1 结束 -- 之所以要减一是因为我们是从 0 开始计数的。图 6-1 阐述
了序列的元素是如何存储的。
6.1.1     标准类型操作符
标准类型操作符(参见 4.5 节)一般都能适用于所有的序列类型。当然,如果作复合类型的
对象比较的话,这样说可能需要有所保留,不过其他的操作绝对是完全适用的。
6.1.2     序列类型操作符
表 6.1 列出了对所有序列类型都适用的操作符。操作符是按照优先级从高到底的顺序排列
的。
成员关系操作符 (in, not in)
成员关系操作符使用来判断一个元素是否属于一个序列的。比如对字符串类型来说,就是
判断一个字符是否属于这个字符串,对和元组类型来说,就代表了一个对象是否属于该对象序
列。in/not in 操作符的返回值一般来讲就是 True/False,满足成员关系就返回 True,否则返
回 False。该操作符的语法如下:
obj [not] in sequence


表 6.1 序列类型操作符
序列操作符          作用
seq[ind]        获得下标为 ind 的元素
seq[ind1:ind2] 获得下标从 ind1 到 ind2 间的元素集合
seq * expr     序列重复 expr 次
seq1 + seq2    连接序列 seq1 和 seq2
obj in seq     判断 obj 元素是否包含在 seq 中
obj not in seq 判断 obj 元素是否不包含在 seq 中
连接操作符( + )
这个操作符允许我们把一个序列和另一个相同类型的序列做连接。语法如下:
sequence1 + sequence2
该表达式的结果是一个包含 sequence1 和 sequence2 的内容的新序列.注意,这种方式看
起来似乎实现了把两个序列内容合并的概念,但是这个操作不是最快或者说最有效的。对字符
串来说,这个操作不如把所有的子字符串放到一个列表或可迭代对象中,然后调用一个 join
方法来把所有的内容连接在一起节约内存;类似地,对列表来说,我们推荐读者用列表类型的
extend()方法来把两个或者多个列表对象合并.当你需要简单地把两个对象的内容合并,或者说
不能依赖于可变对象的那些没有返回值(实际上它返回一个 None)的内建方法来完成的时候时,
连接操作符还是很方便的一个选择。下面的切片操作可以视作这些情况的例子。
重复操作符 ( * )
当你需要需要一个序列的多份拷贝时,重复操作符非常有用,它的语法如下:
sequence * copies_int
copies_int 必须是一个整数(1.6 节里面有讲到,不能是长整数).像连接操作符一样,该操
作符返回一个新的包含多份原对象拷贝的对象。
切片操作符 ( [], [:], [::] )
简单地讲,所谓序列类型就是包含一些顺序排列的对象的一个结构.你可以简单的用方括号
加一个下标的方式访问它的每一个元素,或者通过在方括号中用冒号把开始下标和结束下标分


开的方式来访问一组连续的元素.下面我们将详细的讲解提到的这两种方式.序列类型是其元素
被顺序放置的一种数据结构类型,这种方式允许通过指定下标的方式来获得某一个数据元素,或
者通过指定下标范围来获得一组序列的元素.这种访问序列的方式叫做切片,我们通过切片操作
符就可以实现我们上面说到的操作。访问某一个数据元素的语法如下:
sequence[index]
sequence 是序列的名字,index 是想要访问的元素对应的偏移量.偏移量可以是正值,范围
从 0 到偏移最大值(比序列长度少一),用 len()函数(下一节会讲),可以得到序列长度,实际
的范围是 0 <= inde <= len(sequece)-1 .另外,也可以使用负索引,范围是 -1 到序列的负
长度,-len(sequence), -len(sequence) <= index <= -1.正负索引的区别在于正索引以序列
的开始为起点,负索引以序列的结束为起点.试图访问一个越界的索引会引发一个如下的异常:
>>> names = ('Faye', 'Leanna', 'Daylen')
>>> print names[4]
Traceback (most recent call last): File "<stdin>", line 1, in ?
IndexError: tuple index out of range
因为 Python 是面向对象的,所以你可以像下面这样直接访问一个序列的元素(不用先把它
赋值给一个变量):
>>> print ('Faye', 'Leanna', 'Daylen')[1]
Leanna
这个特性在你调用一个返回值是序列类型的函数,并且你只对返回的序列中的一个或某几
个元素感兴趣时特别有用.
那么我们如何才能一次得到多个元素呢?其实这跟访问某一个单一元素一样简单,只要简
单的给出开始和结束的索引值,并且用冒号分隔就可以了,其语法如下:
sequence[starting_index:ending_index]
通过这种方式我们可以得到从起始索引到结束索引(不包括结束索引对应的元素)之间的
一"片"元素.起始索引和结束索引都是可选的,如果没有提供或者用 None 作为索引值,切片操作
会从序列的最开始处开始,或者直到序列的最末尾结束.在图 6-2 和 6-6 里面,我们以一个长度
为 5 的序列为例,分别讲解了这几种切片方式。


图 6–2 Entire sequence: sequence or sequence[:]
图 6-3 序列切片操作: sequence[0:3]或者 sequence[:3]
用步长索引来进行扩展的切片操作
序列的最后一个切片操作是扩展切片操作,它多出来的第三个索引值被用做步长参数。你
可以把这个参数看成跟内建函数 range()里面的步长参数或者类似于 C/C++,Perl,PHP 和 Java
语言里面 for 语句中的步长参数一样来理解。 Python 的虚拟机里面其实很早就有了扩展切片


操作,只不过以前需要通过扩展的方式来使用。Jython 也支持这个语法(以前叫 JPython)
图       6-4    序列切片操作:        sequence[2:5]
图       6-5    序列切片操作:        sequence[1:3]
long before version 2.3 of the C interpreter gave everyone else access to it.
以下是几个例子:
>>> s = 'abcdefgh'
>>> s[::-1] # 可以视作"翻转"操作
'hgfedcba'


>>> s[::2]    # 隔一个取一个的操作
'aceg'
图       6-6    序列切片操作:            sequence[3]
切片索引的更多内容
切片索引的语法要比简单的单一元素索引灵活的多。开始和结束素引值可以超过字符串的
长度。换句话说,起始索引可以小于 0,而对于结束索引,即使索引值为 100 的元素并不存在也
不会报错,简单地说,即使用 100 来作为一个长度不到 100 的序列的结束索引也不会有什么问
题,例子如下:
>>> ('Faye', 'Leanna', 'Daylen')[-100:100]
('Faye', 'Leanna', 'Daylen')
有这么一个问题:有一个字符串,我们想通过一个循环按照这样的形式显示它:每次都把
位于最后的一个字符砍掉,下面是实现这个要求的一种方法:
>>> s = 'abcde'
>>> i = -1
>>> for i in range(-1, -len(s), -1):
...   print s[:i]
... abcd
abc


ab
a
可是,该如何在第一次迭代的时候显示整个字符串呢?是否有一种方法可以不用在整个循
环之前加入一个额外的 print 语句呢?我们该如何定义一个索引,来代表整个的序列呢?事实
上在个以负数作为索引的例子里是没有一个真正能解决这个问题的方法的,因为-1 已经是“最
小”的索引了.我们不可能用 0 来作为索引值,因为这会切片到第一个元素之前而什么都不会显
示:
>>> s[:0]
''
我们的方案是使用另一个小技巧:用 None 作为索引值,这样一来就可以满足你的需要,比
如说,在你想用一个变量作为索引来从第一个到遍历最后一个元素的时候:
>>> s = 'abcde'
>>> for i in [None] + range(-1, -len(s), -1):
... print s[:i]
...
abcde
abcd
abc
ab
a
现在这个程序符合我们的要求了。在进行下面的内容之前,必须指出,似乎还可以先创建
一个只包含 None 的列表,然后用 extend()函数把 range()的输出添加到这个列表,或者先建立
range()输出组成的列表然后再把 None 插入到这个列表的最前面,然后对这个列表进行遍历,
但是可变对象的内建函数 extend()根本就没有返回值,所以这个方法是行不通的:
>>> for i in [None].extend(range(-1, -len(s), -1)):
... print s[:i]
...
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: iteration over non-sequence


这个错误发生的原因是[None].extend(...)函数返回 None , None 既不是序列类型也不是
可迭代对象. 这种情况下使用上面提到的的列表连接操作来实现是唯一不需要添加额外代码的
方法.
6.1.3    内建函数(BIFs)
在讲解序列类型的内建函数之前,有一点需要说明,序列本身就内含了迭代的概念,之所以
会这样,是因为迭代这个概念就是从序列,迭代器,或者其他支持迭代操作的对象中泛化得来
的。由于 Python 的 for 循环可以遍历所有的可迭代类型,在(非纯序列对象上)执行 for 循环时
就像在一个纯序列对象上执行一样。而且 Python 的很多原来只支持序列作为参数的内建函数现
在也开始支持迭代器或者或类迭代器了.我们把这些类型统称为"可迭代对象".在这一章里我们
会详细的讨论跟序列关系紧密的内建函数(BIF). 在第八章"条件判断和循环"里面将讨论针对"
在循环中迭代"这种情况的内建函数(BIF).
类型转换
内建函数 list(),str()和 tuple()被用做在各种序列类型之间转换。你可以把它们理解成
其他语言里面的类型转换,但是并没有进行任何的转换。这些转换实际上是工厂函数(在第 4
章介绍),将对象作为参数,并将其内容(浅)拷贝到新生成的对象中.表 6.2 列出了适用于序
列类型的转换函数。
表      6.2  序列类型转换工厂函数
函数           含义
list(iter)   把可迭代对象转换为列表
str(obj)     把 obj 对象转换成字符串(对象的字符串表示法)
unicode(obj) 把对象转换成 Unicode 字符串(使用默认编码)
basestring() 抽象工厂函数,其作用仅仅是为 str 和 unicode 函数提供父类,所以不能被
实例化,也不能被调用(详见第 6.2 节)
tuple(iter) 把一个可迭代对象转换成一个元组对象


我们又用了一次“转换”这个词。不过,为什么 Python 里面不简单地把一个对象转换成另
一个对象呢?回过头看一下第 4 章就会知道,一旦一个 Python 的对象被建立,我们就不能更改
其身份或类型了.如果你把一个列表对象传给 list()函数,便会创建这个对象的一个浅拷贝,
然后将其插入新的列表中。同样地,在做连接操作和重复操作时,我们也会这样处理。
所谓浅拷贝就是只拷贝了对对象的索引,而不是重新建立了一个对象!如果你想完全的拷
贝一个对象(包括递归,如果你的对象是一个包含在容器中的容器),你需要用到深拷贝,关于浅
拷贝和深拷贝的更多信息会在本章的末尾讲到。
str()函数在需要把一个对象的可打印信息输出时特别有用,不仅仅是对序列类型,对其他
类型的对象同样如此.Unicode()是 str()函数的 unicode 版本,          它跟 str()函数基本一样.list()
和 tuple()函数在列表类型和元组类型的互换时非常有用.不过,虽然这些函数也适用于 string
类型(因为 string 类型也是序列的一种),但是在 string 类型上应用 tuple()和 list()函数却得
不到我们通常希望的结果.
Operational
Python 为序列类型提供以下可操作 BIFs(见表 6.3).注意,len(),reversed()和 sum()函
数只能接受序列类型对象作为参数,而剩下的则还可以接受可迭代对象做为参数,另外,max()
和 min()函数也可以接受一个参数列表.
表 6.3       序列类型可用的内建函数
函数名                        功能
a
enumerate(iter)          接受一个可迭代对象作为参数,返回一个 enumerate 对象(同
时也是一个迭代器),该对象生成由 iter 每个元素的 index 值
和 item 值组成的元组(PEP 279)
len(seq)                返回 seq 的长度
max(iter,key=None) or
b
max(arg0,arg1...,key=None) 返回 iter 或(arg0,arg1,...)中的最大值,如果指定了 key,
这个 key 必须是一个可以传给 sort()方法的,用于比较的回
调函数.
min(iter, key=None) or
min(arg0, arg1.... key=None)b 返回 iter 里面的最小值;或者返回(arg0,arg2,...)里面


的最小值;如果指定了 key,这个 key 必须是一个可以传给
sort()方法的,用于比较的回调函数.
reversed(seq)c     接受一个序列作为参数,返回一个以逆序访问的迭代器(PEP 322)
sorted(iter,
func=None,
key=None,
reverse=False)c     接受一个可迭代对象作为参数,返回一个有序的列表;可选参数
func,key 和 reverse 的含义跟 list.sort()内建函数的参数含义一
样.
a
sum(seq, init=0)    返 回 seq 和 可 选 参 数 init 的 总 和 , 其 效 果 等 同 于
reduce(operator.add,seq,init)
zip([it0, it1,... itN])d   返回一个列表,其第一个元素是 it0,it1,...这些元素的第
一个元素组成的一个元组,第二个...,类推.
a. Python2.3 新增
b. 从 Python2.5 开始支持关键字参数
c. Python2.4 开始支持
d. Python2.0 加入,Python2.4 加强
我们将分别在每个序列的章节里面提供使用这些函数的例子.
6.2 字符串
字符串类型是 Python 里面最常见的类型.我们可以简单地通过在引号间包含字符的方式
创建它.Python 里面单引号和双引号的作用是相同的,这一点 Python 不同于其他类 Shell 的脚
本语言,在这些脚本语言中,通常转义字符仅仅在双引号字符串中起作用,在单一号括起的字
符串中不起作用。Python 用"原始字符串"操作符来创建直接量字符串,所以再做区分就没什么
意义了。其他的语言,比如 C 语言里面用单引号来标示字符,双引号标示字符串,而在 Python
里面没有字符这个类型.这可能是双引号和单引号在 Python 里面被视作一样的的另一个原因.
几乎所有的 Python 应用程序都会某种方式用到字符串类型.字符串是一种直接量或者说是一种
标量,这意味着 Python 解释器在处理字符串时是把它作为单一值并且不会包含其他 Python 类型
的。字符串是不可变类型,就是说改变一个字符串的元素需要新建一个新的字符串.字符串是由
独立的字符组成的,并且这些字符可以通过切片操作顺序地访问。


根据在 2.2 章节里面对类型和类的概念进行的统一,Python 实际上有 3 类字符串.通常意
义的字符串(str)和 Unicode 字符串(unicode)实际上都是抽象类 basestring 的子类.这个
basestring 是不能实例化的,如果你试图实例化一个 basestring 类,你会得到以下报错信息:
>>> basestring('foo')
Traceback (most recent call last): File "<stdin>", line 1, in <module>
TypeError: The basestring type cannot be instantiated
字符串的创建和赋值
创建一个字符串就像使用一个标量一样简单,当然你也可以把 str()作为工厂方法来创建
一个字符串并把它赋值给一个变量:
>>> aString = 'Hello World!' # 使用单引号
>>> anotherString = "Python is cool!" # 使用双引号
>>> print aString # print 不带引号的 Hello World!
>>> anotherString # 不是进行 print 操作,带有引号
'Python is cool!'
>>> s = str(range(4)) # 把一个列表转换成一个字符串
>>> s
'[0, 1, 2, 3]'
如何访问字符串的值(字符和子串)
Python 里面没有字符这个类型,而是用长度为 1 的字符串来表示这个概念,当然,这其实也
是一个子串。用方括号加一个或者多于一个索引的方式来获得子串:
>>> aString = 'Hello World!'
>>> aString[0]
'H'
>>> aString[1:5]
'ello'
>>> aString[6:]
'World!'
如何改变字符串


你可以通过给一个变量赋值(或者重赋值)的方式“更新”一个已有的字符串.新的值可能
与原有值差不多,也可能跟原有串完全不同。
>>> aString = aString[:6] + 'Python!'
>>> aString
'Hello Python!'
>>> aString = 'different string altogether'
>>> aString
'different string altogether'
跟数字类型一样,字符串类型也是不可变的,所以你要改变一个字符串就必须通过创建一
个新串的方式来实现。也就是说你不能只改变一个字符串的一个字符或者一个子串,然而,通
过拼凑一个旧串的各个部分来得到一个新串是被允许的,正如上面你看到的那样.
如何删除字符和字符串
再重复一遍,字符串是不可变的,所以你不能仅仅删除一个字符串里的某个字符,你能做的
是清空一个空字符串,或者是把剔除了不需要的部分后的字符串组合起来形成一个新串。假设
你想要从"Hello World!"里面删除小写的'l'
>>> aString = 'Hello World!'
>>> aString = aString[:3] + aString[4:]
>>> aString
'Helo World!'
通过赋一个空字符串或者使用 del 语句来清空或者删除一个字符串:
>>> aString = ''
>>> aString
''
>>> del aString
在大部分应用程序里,没有必要显式的删除字符串。定义这个字符串的代码最终会结束,
那时 Python 会自动释放这些字符串.
6.3 字符串和操作符
6.3.1 标准类型操作符


在第 4 章里面,我们介绍了一些适用于包括标准类型在内的大部分对象的操作符,在这里
再看一下这些其中的一些操作符是怎样作用于字符串类型的,下面是几个简单的例子:
>>> str1 = 'abc'
>>> str2 = 'lmn'
>>> str3 = 'xyz'
>>> str1 < str2
True
>>> str2 != str3
True
>>> str1 < str3 and str2 == 'xyz'
False
在做比较操作的时候,字符串是按照 ASCII 值的大小来比较的.
6.3.2 序列操作符
切片( [ ] 和 [ : ] )
在早先地 6.1.1 章节里面我们展示了如何访问序列类型的一个或一组元素,接下来我们会
把这些知识应用到字符串类型上,着重考察以下的操作:
z   正向索引
z   反向索引
z   默认索引
接下来以字符串'abcd'为例子.表里面分别列出了使用正索引和负索引来定位字符的情况.
可以用长度操作符来确认该字符串的长度是 4:
>>> aString = 'abcd'
>>> len(aString)
4


正向索引时,索引值开始于 0,结束于总长度减 1(因为我们是从 0 开始索引的).本例中最后
一个索引是:
final_index = len(aString) - 1
= 4 - 1
= 3
在这个范围内,我们可以访问任意的子串。用一个参数来调用切片操作符结果是一个单一
字符,而使用一个数值范围(用':')作为参数调用切片操作的参数会返回一串连续地字符.再强
调一遍,对任何范围[start:end],我们可以访问到包括 start 在内到 end(不包括 end)的所有字
符,换句话说,假设 x 是[start:end]中的一个索引值,那么有: start<= x < end.
>>> aString[0]
'a'
>>> aString[1:3]
'bc'
>>> aString[2:4]
'cd'
>>> aString[4]
Traceback (innermost last): File "<stdin>", line 1, in ?
IndexError: string index out of range
使用不在允许范围(本例中是 0 到 3)内的索引值会导致错误。上面的 aString[2:4]却并没
有出错,那是因为实际上它返回的是索引值 2 和 3 的值。但是直接拿 4 作为索引访问是不被允
许的。
在进行反向索引操作时,是从-1 开始,向字符串的开始方向计数,到字符串长度的负数为
索引的结束。最末一个索引(也就是第一个字符)是这样定位的:
final_index    = -len(aString)
= -4
>>> aString[-1]
'd'
>>> aString[-3:-1]
'bc'
>>> aString[-4]
'a'


如果开始索引或者结束索引没有被指定,则分别以字符串的第一个和最后一个索引值为
默认值。
>>> aString[2:]
'cd'
>>> aString[1:]
'bcd'
>>> aString[:-1]
'abc'
>>> aString[:]
'abcd'
注意:起始/结束索引都没有指定的话会返回整个字符串.
成员操作符(in ,not in)
成员操作符用于判断一个字符或者一个子串(中的字符)是否出现在另一个字符串中。出现
则返回 True,否则返回 False.注意,成员操作符不是用来判断一个字符串是否包含另一个字符
串的,这样的功能由 find()或者 index()(还有它们的兄弟:rfind()和 rindex())函数来完成
下面是一些字符串和成员操作符的例子.
在 Python2.3 以前,in(和 not in)操作符只允许用来判断一个单个字符是否属于一个字
符串,就像下面第二个例子那样.2.3 以后这个限制去掉了,所有的字符串都可以拿来判断.
>>> 'bc' in 'abcd' True
>>> 'n' in 'abcd' False
>>> 'nm' not in 'abcd' True
在例 6.1 里面,我们会用到下面这些 string 模块预定义的字符串:
>>> import string
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_letters
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


>>> string.digits
'0123456789'
例 6.1 是一个用来检查 Python 有效标识符的小脚本,名字是 idcheck.py.我们知道,
Python 标识符必须以字母或下划线开头,后面跟字母,下划线或者数字.
例 6.1    标识符检查 (idcheck.py)
标识符合法性检查,首先要以字母或者下划线开始,后面要跟字母,下划线或者或数字.
这个小例子只检查长度大于等于 2 的标识符.
1 #!usr/bin/env python
2
3 import string
4
5 alphas = string.letters + '_'
6 nums = string.digits
7
8 print 'Welcome to the Identifier Checker v1.0'
9 print 'Testees must be at least 2 chars long.'
10 inp = raw_input('Identifier to test? ')
11
12 if len(myInput) > 1:
13
14 if myInput[0] not in alphas:
15 print '''invalid: first symbol must be
16 alphabetic'''
17 else:
18 for otherChar in myInput[1:]:
19
20 if otherChar not in alphas + nums:
21 print '''invalid: remaining
22 symbols must be alphanumeric'''
23 break


24    else:
25    print "okay as an identifier"
这个例子还展示了字符串连接符( + )的使用,本章的后面会讲到字符串连接符.运行几次
后得到下面的输出:
$ python idcheck.py
Welcome to the Identifier Checker v1.0
Testees must be at least 2 chars long. Identifier to test? counter
okay as an identifier
$
$ python idcheck.py
Welcome to the Identifier Checker v1.0
Testees must be at least 2 chars long. Identifier to test? 3d_effects
invalid: first symbol must be alphabetic
让我们逐行解释这个应用程序 。
3-6 行
导入 string 模块并且预定义了两个字符串,用于后面的判断.
8-12 行
输出提示信息,第 12 行的 if 语句过滤掉长度小于 2 的标识符或者候选标识符.
14-16 行
检查第一个符号是不是字母或下划线,如果不是,输出结果并退出。
17-18 行
否则,从第二个字符开始到最后一个字符,循环检查剩余的字符.
20-23 行
检查剩余的符号是否都是字母,下划线或者数字.注意我们是如何使用连接操作符来创建合
法字符集合的。只要发现一个非法字符,就显示结果并通过 break 语句退出。


核心提示: 性能
一般来说,从性能的的角度来考虑,把重复操作作为参数放到循环里面进行是非常低效的.
while i < len(myString):
print 'character %d is:', myString[i]
上面的循环操作把大把的时间都浪费到了重复计算字符串 myString 的长度上了.每次循环
迭代都要运行一次这个函数.如果把这个值做一次保存,我们就可以用更为高效的方式重写我们
的循环操作.
length = len(myString)
while i < length:
print 'character %d is:', myString[i]
这个方法同样适用于上面的例 6.1
for otherChar in myInput[1:]:
if otherChar not in alphas + nums:
:
第 18 行的 for 循环包含了一个 if 语句,在这个 if 里面执行了合并两个字符串的操作。
被合并的这两个字符串从始至终就没变过,而每次都会重新进行一次计算.如果先把这两个字
符串存为一个新字符串,我们就可以直接引用这个字符串而不用进行重复计算了。
alphnums = alphas + nums
for otherChar in myInput[1:]:
if otherChar not in alphnums:
:
24-25 行
或许现在就向你展示 for-else 循环语句有点儿早,可是我们必需先看一看这个语句(在第
8 章有详细的介绍).for 循环的 else 语句是一个可选项,它只在 for 循环完整的结束,没有遇到
break 时执行。在我们的例子中,如果所有的符号都检查合格,那么我们就得到了一个合法的
标识符,程序会返回一个这样的结果,然后执行完毕。
其实,这段程序并不是完美的,一个问题就是标识符的长度必须大于 1.我们的程序几乎是,
但还并没有真正定义出 Python 标识符的范围,Python 标识符长度可以是 1.另一个问题是这段
程序并没有考虑到 Python 的关键字,而这些都是作为保留字,不允许用做标识符的.我们把这两
个问题作为课后练习留给读者(见练习 6-2)。


连接符( + )
运行时刻字符串连接
我们可以通过连接操作符来从原有字符串获得一个新的字符串.我们已经在前面的例
6-1 里面见识过连接符了,下面是一些更多的例子:
>>> 'Spanish' + 'Inquisition'
'SpanishInquisition'
>>>
>>> 'Spanish' + ' ' + 'Inquisition'
'Spanish Inquisition'
>>>
>>> s = 'Spanish' + ' ' + 'Inquisition' + ' Made Easy'
>>> s
'Spanish Inquisition Made Easy'
>>>
>>> import string
>>> string.upper(s[:3] + s[20])        # archaic (see below)
'SPAM'
最后一个例子展示了用一个字符串 s 的两个切片来构成一个新串的操作,从"Spanish"里
面切出"Spa"加上从"Made"里面切出来的"M".将抽取出来字符串切片连接后作为参数传给了
string.upper()方法,该方法负责把字符串的所有字符都变为大写。String 模块的方法是在
Python1.6 里面添加进来的,所以这个操作也可以用最后一个字符串的一个单一方法调用来完
成(见下面的例子)。现在已经没有必要导入 string 模块了,除非你需要访问该模块自己定义的
字符串常量。注意:虽然对初学者来说 string 模块的方式更便于理解,但出于性能方面的考虑,
我们还是建议你不要用 string 模块。原因是 Python 必须为每一个参加连接操作的字符串分配
新的内存,包括新产生的字符串。取而代之,我们推荐你像下面介绍的那样使用字符串格式化
操作符(%),或者把所有的字符串放到一个列表中去,然后用一个 join()方法来把它们连接在
一起。
>>> '%s %s' % ('Spanish', 'Inquisition')


'Spanish Inquisition'
>>>
>>> s = ' '.join(('Spanish', 'Inquisition', 'Made Easy'))
>>> s
'Spanish Inquisition Made Easy'
>>>
>>> # no need to import string to use string.upper():
>>> ('%s%s' % (s[:3], s[20])).upper()
'SPAM'
编译时字符串连接
上面的语法在运行时字符串连接的加法操作,这个用法是非常标准的。Python 中还有一种
并不是经常用到,更像是一种程序员的习惯用法的语法.Python 的语法允许你在源码中把几个
字符串连在一起写,以此来构建新字符串:
>>> foo = "Hello" 'world!'
>>> foo
'Helloworld!'
通过这种方法,你可以把长的字符串分成几部分来写,而不用加反斜杠。如上所示,
你可以在一行里面混用两种分号。这种写法的好处是你可以把注释也加进来,如下:
>>>  f = urllib.urlopen('http://' # protocol
... 'localhost' # hostname
...  ':8000' # port
... '/cgi-bin/friends2.py') # file
如你所想,下面就是 urlopen()方法所得到的真实输入:
>>> 'http://' 'localhost' ':8000' '/cgi-bin/friends2.py'
'http://localhost:8000/cgi-bin/friends2.py'
普通字符串转化为 Unicode 字符串
如果把一个普通字符串和一个 Unicode 字符串做连接处理,Python 会在连接操作前先把普
通字符串转化为 Unicode 字符串:


>>> 'Hello' + u' ' + 'World' + u'!'
u'Hello World!'
重复操作符( * )
重复操作符创建一个包含了原有字符串的多个拷贝的新串:
>>> 'Ni!' * 3
'Ni!Ni!Ni!'
>>>
>>> '*'*40
'****************************************'
>>>
>>> print '-' * 20, 'Hello World!', '-' * 20
-------------------- Hello World! --------------------
>>> who = 'knights'
>>> who * 2
'knightsknights'
>>> who
'knights'
像其他的标准操作符一样,原变量是不被修改的,就像上面最后一个例子所示。
6.4 只适用于字符串的操作符
6.4.1 格式化操作符( % )
Python 风格的字符串格式化操作符。只适用于字符串类型,非常类似于 C 语言里面的
printf()函数的字符串格式化,甚至所用的符号都一样,都用百分号(%),并且支持所有 printf()
式的格式化操作.语法如下:
左边的 format_string 里面同通常会在 printf()函数的第一个参数里面见到的一样:包含%
jgjk
请选择修改过的execl文档)
的格式化字符串.表 6.4 列出了可用的各种符号.arguments_to_convert 参数是你要转化、显示
的变量,对应于你送给 prinf 的其他参数.
表 6.4 字符串格式化符号
格式化字符             转换方式
%c               转换成字符(ASCII 码值,或者长度为一的字符串)
%ra              优先用 repr()函数进行字符串转换
%s               优先用 str()函数进行字符串转换
%d / %i           转成有符号十进制数
%ub               转成无符号十进制数
%ob              转成无符号八进制数
%xb/%Xb         (Unsigned)转成无符号十六进制数(x/X 代表转换后的十六进制字符的大
小写)
%e/%E          转成科学计数法(e/E 控制输出 e/E)
%f/%F           转成浮点数(小数部分自然截断)
%g/%G           %e 和%f/%E 和%F 的简写
%%               输出%
a.   Python2.0 新增;而且好像只有 Python 里面有.
b.   Python2.4 里面%u/%o/%x/%X 在遇到负数的时候会返回一个有符号字符串
Python 支持两种格式的输入参数。第一种是元组(见 2.8 节,6.15 节),这基本上是一种的 C
printf()风格的转换参数集;
Python 支持的第二种形式是字典形式(详见第 7 章).字典其实是一个哈希键-值对的集合。
这种形式里面,key 是作为格式字符串出现,相对应的 value 值作为参数在进行转化时提
供给格式字符串.
格式字符串既可以跟 print 语句一起用来向终端用户输出数据,又可以用来合并字符串形
成新字符串,而且还可以直接显示到 GUI(Graphical User Interface)界面上去.
其他的格式字符和方法见表 6.5
表 6.5 格式化操作符辅助指令
符号                   作用
\*                定义宽度或者小数点精度
-                用做左对齐
+               在正数前面显示加号( + )
<sp>           在正数前面显示空格
#              在八进制数前面显示零('0'),在十六进制前面显示'0x'或者'0X'(取决于
用的是'x'还是'X')
0             显示的数字前面填充‘0’而不是默认的空格
%                '%%'输出一个单一的'%'
(var)         映射变量(字典参数)
m.n            m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)
以下是一些使用格式字符串的例子:
十六进制输出:
>>> "%x" % 108
'6c'
>>> "%X" % 108
'6C'
>>> "%#X" % 108
'0X6C'
>>> "%#x" % 108
'0x6c'
浮点数和科学记数法形式输出:
>>> '%f' % 1234.567890
'1234.567890'
>>> '%.2f' % 1234.567890
'1234.57'
>>> '%E' % 1234.567890
'1.234568E+03'
>>> '%e' % 1234.567890
'1.234568e+03'
>>>
>>> '%g' % 1234.567890
'1234.57'
>>>
>>> '%G' % 1234.567890
'1234.57'
>>>
>>> "%e" % (1111111111111111111111L)
'1.111111e+21'
整数和字符串输出:
>>> "%+d" % 4
'+4'
>>> "%+d" % -4
'-4'
>>> "we are at %d%%" % 100
'we are at 100%'
>>>
>>> 'Your host is: %s' % 'earth'
'Your host is: earth'
>>>


>>> 'Host: %s\tPort: %d' % ('mars', 80)
'Host: mars Port: 80'
>>> num = 123
>>> 'dec: %d/oct: %#o/hex: %#X' % (num, num, num)
'dec: 123/oct: 0173/hex: 0X7B'
>>> "MM/DD/YY = %02d/%02d/%d" % (2, 15, 67)
'MM/DD/YY = 02/15/67'
>>> w, p = 'Web', 'page'
>>> 'http://xxx.yyy.zzz/%s/%s.html' % (w, p)
'http://xxx.yyy.zzz/Web/page.html'
上面的例子都是使用的元组类型的参数作转换.下面我们将把字典类型的参数提供给格式
化操作符.
>>> 'There are %(howmany)d %(lang)s Quotation Symbols' % \
... {'lang': 'Python', 'howmany': 3}
'There are 3 Python Quotation Symbols'
令人称奇的调试工具
字符串格式化操作符不仅很酷,易用,上手快,而且是一个非常有用的调试工具。事实上,
所有的 Python 对象都有一个字符串表示形式
(通过 repr()函数,'' 或 str()函数来展现).print 语句自动为每个对象调用 str()函数.
更好的是,在定义自己的对象时,你可以利用"钩子"为你的对象创建字符串表达形式. 这样,
repr(),str()或`` 或者 print 被调用时,就可以获得一个适当的字符串描述信息.即使在坏
的不能再坏的情况下,repr()或者 str()也不能显示一个对象的信息时,Pythonic 方式的默认
做法最起码能给你返回想如下格式的信息:
<... something that is useful ...>.


6.4.2     字符串模板: 更简单的替代品
字符串格式化操作符是 Python 里面处理这类问题的主要手段,而且以后也是如此。然而它
也不是完美的,其中的一个缺点是它不是那么直观,尤其对刚从 C/C++转过来的 Python 新手来
说更是如此,即使是现在使用字典形式转换的程序员也会偶尔出现遗漏转换类型符号的错误,
比如说,用了%(lang)而不是正确的%(lang)s.为了保证字符串被正确的转换,程序员必须明确
的记住转换类型参数,比如到底是要转成字符串,整数还是其他什么类型.
新式的字符串模板的优势是不用去记住所有的相关细节的,而是像现在 shell 风格的脚本
语言里面那样使用美元符号($).
由于新式的字符串 Template 对象的引进使得 string 模块又重新活了过来,Template 对象
有两个方法,substitute()和 safe_substitute().前者更为严谨,在 key 缺少的情况下它会报一
个 KeyError 的异常出来,而后者在缺少 key 时,直接原封不动的把字符串显示出来.
>>> from string import Template
>>> s = Template('There are ${howmany} ${lang} Quotation Symbols')
>>>
>>> print s.substitute(lang='Python', howmany=3) There are 3 Python Quotation
Symbols
>>>
>>> print s.substitute(lang='Python') Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "/usr/local/lib/python2.4/string.py", line 172, in substitute
return self.pattern.sub(convert, self.template)
File "/usr/local/lib/python2.4/string.py", line 162, in convert val =
mapping[named]
KeyError: 'howmany'
>>>
>>> print s.safe_substitute(lang='Python') There are ${howmany} Python Quotation
Symbols
新式的字符串模板是从 Python2.4 开始加入的,更多信息请查阅 Python 类库手册和 PEP

6.4.3     原始字符串操作符( r/R )
关于原始字符串的目的,在 Python1.5 里面已经有说明,是为了对付那些在字符串中出现
的特殊字符(下面的小节会介绍这些特殊字符)。在原始字符串里,所有的字符都是直接按照字
面的意思来使用,没有转义特殊或不能打印的字符。
原始字符串的这个特性让一些工作变得非常的方便,比如正则表达式的创建(详见文档的 re
模块).正则表达式是一些定义了高级搜索匹配方式的字符串,通常是由代表字符,分组、匹配信
息、变量名、和字符类等的特殊符号组成。正则表达式模块已经包含了足够用的符号。但当你
必须插入额外的符号来使特殊字符表现的像普通字符的时候,你就陷入了“字符数字”的泥潭!
这时原始字符串就会派上用场了.
除了原始字符串符号(引号前面的字母"r")以外,原始字符串跟普通字符串有着几乎完全相
同的语法.
这个'r'可以是小写也可以是大写,唯一的要求是必须紧靠在第一个引号前.
在三个例子的第一个例子里面,我们需要一个反斜杠加一个'n'来而不是一个换行符.:
>>> '\n'
'\n'
>>> print '\n'
>>> r'\n'
'\\n'
>>> print r'\n'
\n
接下来的例子里,我们打不开我们的 README 文件了,为什么?因为'\t'和'\r'被当成
不在我们的文件名中的特殊符号,但它们实际上文件路径的中 4 个独立的字符.
>>> f = open('C:\windows\temp\readme.txt', 'r')
Traceback (most recent call last):


File "<stdin>", line 1, in ?
f = open('C:\windows\temp\readme.txt', 'r')
IOError: [Errno 2] No such file or directory: 'C:\\win- dows\\temp\readme.txt'
>>> f = open(r'C:\windows\temp\readme.txt', 'r')
>>> f.readline()
'Table of Contents (please check timestamps for last update!)\n'
>>> f.close()
最后我们要找一对原始的\n 字符而不是换行。为了找到它,我们使用了一个简单的正则表
达式,它的作用是查找通常被用来表示空白字符的反斜线-字符对(backslash-character
pairs)。
>>> import re
>>> m = re.search('\\[rtfvn]', r'Hello World!\n')
>>> if m is not None: m.group()
...
>>> m = re.search(r'\\[rtfvn]', r'Hello World!\n')
>>> if m is not None: m.group()
...
'\\n'
6.4.4     Unicode 字符串操作符( u/U )
Unocide 字符串操作符,大写的(U)和小写的(u)是在 Python1.6 中 和 Unicode 字符串一
起被引入的. 它用来把标准字符串或者是包含 Unicode 字符的字符串转换成完全地 Unicode 字
符串对象。关于 Unicode 字符串的进一步信息在 6.7.4 节有详细介绍.另外,字符串方法(见 6.6
节)和正则表达式引擎也支持 Unicode.下面是几个例子:
u'abc'            U+0061 U+0062     U+0063
u'\u1234'        U+1234
u'abc\u1234\n'   U+0061 U+0062       U+0063     U+1234 U+0012
Unicode 操作符也可以接受原始 Unicode 字符串, 只要我们将 Unicode 操作符和前面讨论


过的原始字符串操作符连接在一起就可以了. 注意:Unicode 操作符必须出现在原始字符串操作
符前面.
ur'Hello\nWorld!'
6.5 内建函数
6.5.1 标准类型函数
cmp()
同比较操作符一样,内建的 cmp()函数也根据字符串的 ASCII 码值进行比较.
>>> str1 = 'abc'
>>> str2 = 'lmn'
>>> str3 = 'xyz'
>>> cmp(str1, str2)
-11
>>> cmp(str3, str1)
23
>>> cmp(str2, 'lmn')
0
6.5.2      序列类型函数
len()
>>> str1 = 'abc'
>>> len(str1)
3
>>> len('Hello World!')
12
正如您期望的那样,内建函数 len()返回字符串的字符数.
max() and min()
>>> str2 = 'lmn'


>>> str3 = 'xyz'
>>> max(str2)
'n'
>>> min(str3)
'x'
虽然 max()和 min()函数对其他的序列类型可能更有用,但对于 string 类型它们能很好地
运行,返回最大或者最小的字符,(按照 ASCII 码值排列),下面是几个例子:
>>> min('ab12cd')
'1'
>>> min('AB12CD')
'1'
>>> min('ABabCDcd')
'A'
enumerate()
>>> s = 'foobar'
>>> for i, t in enumerate(s):
...    print i, t
...
0 f
1 o
2 o
3 b
4 a
5 r
zip()
>>> s, t = 'foa', 'obr'
>>> zip(s, t)
[('f', 'o'), ('o', 'b'), ('a', 'r')]


6.5.3     字符串类型函数
raw_input()
内建的 raw_input()函数使用给定字符串提示用户输入并将这个输入返回,下面是一个使
用 raw_input()的例子:
>>> user_input = raw_input("Enter your name: ")
Enter your name: John Doe
>>>
>>> user_input
'John Doe'
>>>
>>> len(user_input)
8
Python 里面没有 C 风格的结束字符 NUL,你输入多少个字符,len()函数的返回值就是多少.
str() and unicode()
str()和 unicode()函数都是工厂函数,就是说产生所对应的类型的对象.它们接受一个任
意类型的对象,然后创建该对象的可打印的或者 Unicode 的字符串表示. 它们和 basestring 都
可以作为参数传给 isinstance()函数来判断一个对象的类型.
>>> isinstance(u'\0xAB', str)
False
>>> not isinstance('foo', unicode)
True
>>> isinstance(u'', basestring)
True
>>> not isinstance('foo', basestring)
False
chr(), unichr(), and ord()
chr()函数用一个范围在 range(256)内的(就是 0 到 255)整数做参数,返回一个对应的字


符.unichr()跟它一样,只不过返回的是 Unicode 字符,这个从 Python2.0 才加入的 unichr()
的参数范围依赖于你的 Python 是如何被编译的.如果是配置为 USC2 的 Unicode,那么它的允许
范 围 就 是 range(65536) 或 者 说 0x0000-0xFFFF; 如 果 配 置 为 UCS4 , 那 么 这 个 值 应 该 是
range(1114112)或者 0x000000-0x110000.如果提供的参数不在允许的范围内,则会报一个
ValueError 的异常。
ord()函数是 chr()函数(对于 8 位的 ASCII 字符串)或 unichr()函数(对于 Unicode 对象)
的配对函数,它以一个字符(长度为 1 的字符串)作为参数,返回对应的 ASCII 数值,或者 Unicode
数值,如果所给的 Unicode 字符超出了你的 Python 定义范围,则会引发一个 TypeError 的异常。
>>> chr(65)
'A'
>>> ord('a')
97
>>> unichr(12345)
u'\u3039'
>>> chr(12345)
Traceback (most recent call last): File "<stdin>", line 1, in ?
chr(12345)
ValueError: chr() arg not in range(256)
>>> ord(u'\ufffff')
Traceback (most recent call last): File "<stdin>", line 1, in ?
ord(u'\ufffff')
TypeError: ord() expected a character, but string of length 2 found
>>> ord(u'\u2345')
9029
6.6    字符串内建函数
字符串方法是从 Python1.6 到 2.0 慢慢加进来的--它们也被加到了 Jython 中.这些方法实
现了 string 模块中的大部分方法,表 6.6 列出了目前字符串内建支持的方法,所有这些方法都
包含了对 Unicode 的支持,有一些甚至是专门用于 Unicode 的.
表 6.6 字符串类型内建方法


方法                             描述
string.capitalize()           把字符串的第一个字符大写
string.center(width)          返回一个原字符串居中,并使用空格填充至长度 width 的新字符
串
string.count(str, beg=0,
end=len(string))               返回 str 在 string 里面出现的次数,如果 beg 或者 end 指定则
返回指定范围内 str 出现的次数
string.decode(encoding='UTF-8',
errors='strict')              以 encoding 指定的编码格式解码 string,如果出错默认报一个
ValueError 的 异 常 , 除 非 errors 指 定 的 是 'ignore' 或 者
'replace'
string.encode(encoding='UTF-8',
errors='strict')a             以 encoding 指定的编码格式编码 string,如果出错默认报一个
ValueError 的异常,除非 errors 指定的是'ignore'或者'replace'
string.endswith(obj, beg=0,
end=len(string))b,e 检查字符串是否以 obj 结束,如果 beg 或者 end 指定则检查指
定的范围内是否以 obj 结束,如果是,返回 True,否则返回 False.
string.expandtabs(tabsize=8)把字符串 string 中的 tab 符号转为空格,默认的空
格数 tabsize 是 8.
string.find(str, beg=0,
end=len(string))                  检测 str 是否包含在 string 中,如果 beg 和 end 指定范围,
则检查是否包含在指定范围内,如果是返回开始的索引值,否则
返回-1
string.index(str, beg=0,
end=len(string))              跟 find()方法一样,只不过如果 str 不在 string 中会报一个异常.
a, b, c
string.isalnum()              R 如果 string 至少有一个字符并且所有字符都是字母或数字则返
回 True,否则返回 False
a, b, c
string.isalpha()              如果 string 至少有一个字符并且所有字符都是字母则返回 True,
否则返回 False
b, c, d
string.isdecimal()            如果 string 只包含十进制数字则返回 True 否则返回 False.
b, c
string.isdigit() 如果 string 只包含数字则返回 True 否则返回 False.
string.islower()b, c 如果 string 中包含至少一个区分大小写的字符,并且所有这些(区分
大小写的)字符都是小写,则返回 True,否则返回 False


string.isnumeric()b, c, d 如果 string 中只包含数字字符,则返回 True,否则返回 False
string.isspace()b, c 如果 string 中只包含空格,则返回 True,否则返回 False.
string.istitle()b, c 如果 string 是标题化的(见 title())则返回 True,否则返回 False
string.isupper()b, c 如果 string 中包含至少一个区分大小写的字符,并且所有这些(区分
大小写的)字符都是大写,则返回 True,否则返回 False
string.join(seq) Merges (concatenates)以 string 作为分隔符,将 seq 中所有的元素
(的字符串表示)合并为一个新的字符串
string.ljust(width)返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串
string.lower() 转换 string 中所有大写字符为小写.
string.lstrip() 截掉 string 左边的空格
string.partition(str)e 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,
把 字 符 串 string 分 成 一 个 3 元 素 的 元 组
(string_pre_str,str,string_post_str),如果 string 中不包含
str 则 string_pre_str == string.
string.replace(str1, str2,
num=string.count(str1))把 string 中的 str1 替换成 str2,如果 num 指定,
则替换不超过 num 次.
string.rfind(str, beg=0,end=len(string))类似于 find()函数,不过是从右边开始查
找.
string.rindex( str, beg=0,end=len(string))                    类似于 index(),不过是从右边开始.
string.rjust(width)返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串
string.rpartition(str)e       类似于 partition()函数,不过是从右边开始查找.
string.rstrip() 删除 string 字符串末尾的空格.
string.split(str="", num=string.count(str)) 以 str 为分隔符切片 string,如果 num
有指定值,则仅分隔 num 个子字符串
b, c
string.splitlines(num=string.count('\n')) 按照行分隔,返回一个包含各行作为元素
的列表,如果 num 指定则仅切片 num 个
行.
b, e
string.startswith(obj, beg=0,end=len(string)) 检查字符串是否是以 obj 开头,是则
返回 True,否则返回 False。如果
beg 和 end 指定值,则在指定范围内


检查.
string.strip([obj])      在 string 上执行 lstrip()和 rstrip()
string.swapcase() 翻转 string 中的大小写
string.title()b, c       返回"标题化"的 string,就是说所有单词都是以大写开始,其余
字母均为小写(见 istitle())
string.translate(str, del="") 根据 str 给出的表(包含 256 个字符)转换 string 的字符,
要过滤掉的字符放到 del 参数中
string.upper() 转换 string 中的小写字母为大写
string.zfill(width)      返回长度为 width 的字符串,原字符串 string 右对齐,前面填充
0
a.Python1.6 中只适用于 Unicode 字符串,2.0 中适用于所有字符串
b. 1.5.2 版本中 string 模块没有该方法
c. 在 Jython2.1 有
d. 仅对 Unicode 字符串有效,
e.Python2.5 或者以上版本
几个使用字符串方法的例子:
>>> quest = 'what is your favorite color?'
>>> quest.capitalize()
'What is your favorite color?'
>>>
>>> quest.center(40)
' what is your favorite color?    '
>>>
>>> quest.count('or')
2
>>>
>>> quest.endswith('blue') False
>>>
>>> quest.endswith('color?') True
>>>
>>> quest.find('or', 30)
-1


>>>
>>> quest.find('or', 22)
25
>>
>>> quest.index('or', 10)
16
>>>
>>> ':'.join(quest.split())
'what:is:your:favorite:color?'
>>> quest.replace('favorite color', 'quest')
>>>
'what is your quest?'
>>>
>>> quest.upper()
'WHAT IS YOUR FAVORITE COLOR?'
上面最复杂的例子是有 split()和 join()函数的那个.首先我们在 string 上调用 split()
函数,没有用参数,也就是说以空格作为分隔符分隔字符串,然后我们以这个包含单词的列表
做参数调用 join()方法把这些单词用一个新的分隔符冒号重新串在一起,注意,我们首先用
split()函数把 string 切片成一个列表,然后我们在字符串':'上应用 join()方法把这个列表
重新连接成一个字符串.
6.7 字符串的独特特性
6.7.1 特殊字符串和控制字符
像其他高级语言和脚本语言一样,一个反斜线加一个单一字符可以表示一个特殊字符,通常
是一个不可打印的字符,这就是我们上面讨论的特殊字符,如果这些特殊字符是包含在一个原
始字符串中的,那么它就失去了转义的功能.
除了通常用的特殊字符,比如换行符(\n),tab 符(\t)之外,也可以直接用 ASCII 码值来标
示特殊字符:\000 或者\xXX,分别对应字符的八进制和十六进制 ASCII 码值,下面分别是十进
制,八进制和十六进制的 0,65,和 255:
ASCII     ASCII   ASCII
Decimal        0          65    255


Octal              \000 \101    \177
Hexadecimal       \x00  \x41    \xFF
特殊字符,包括反斜杠转义的那些都可以像普通字符一样存储到 Python 的字符串中.
跟 C 字符串的另一个不同之处是 Python 的字符串并不是以 NUL(\000)作为结束符的.NUL 跟
其他的反斜杠转义字符没什么两样.事实上,一个字符串中不仅可以出现 NUL 字符,而且还可以
出现不止一次,在字符串的任意位置都可以。表 6.7 列出了被大部分 Python 版本支持的转义字
符.
如上所述,就像使用连字符来让一行的内容持续到下一行一样,可以用显式定义八进制
或者十六进制的 ASCII 码的方式定义特殊字符,合法的 ASCII 码值范围是从 0 到 255(八进制的
是 0177,十六进制是 0XFF).
Table 6.7    反斜杠开头的转义字符
/X  八进制     十进制        十六进制             字符      说明
\0  000        0         0x00            NUL    空字符 Nul
\a  007        7         0x07             BEL    响铃字符
\b  010        8         0x08               BS    退格
\t     011         9        0x09               HT   横向制表符
\n     012         10       0x0A               LF   换行
\v     013       11         0x0B             VT    纵向制表符
\f     014     12           0x0C             FF    换页
\r     015     13           0x0D             CR    回车
\e     033      27          0x1B             ESC 转义
\"     042       34         0x22               "   双引号
\'     047       39          0x27              '   单引号
\\     134     92            0x5C            \     反斜杠
\OOO       八进制值(范围是 000 到 0177)
\xXX       x 打头的十六进制值(范围是 0x00 到 0xFF)
\            连字符,将本行和下一行的内容连接起来.


控制字符的一个作用是用做字符串里面的定界符,在数据库或者 web 应用中,大多数的可
打印字符都是被允许用在数据项里面的,就是说可打印的字符不适合做定界符.
用可打印的字符串比如冒号(:)来作定界符,将会很难分辨一个字符到底是数据还是定
界符.而且还会限定你能用在数据项里面的字符数量,而这不是你想要的.
一个通常的解决方案是,使用那些不经常使用的,不可打印的 ASCII 码值来作为定界符,
它们是非常完美的定界符,这样一来诸如冒号这样的可打印字符就可以解脱出来用在数据项中
了.
6.7.2      三引号
虽然你可以用单引号或者双引号来定义字符串,但是如果你需要包含诸如换行符这样的特
殊字符时,单引号或者双引号就不是那么方便了。Python 的三引号就是为了解决这个问题的,
它允许一个字符串跨多行,字符串中可以包含换行符、制表符以及其他特殊字符.
三引号的语法是一对连续的单引号或者双引号(通常都是成对的用):
>>> hi = '''hi there'''
>>> hi # repr()
'hi\nthere'
>>> print hi     # str()
hi there
三引号让程序员从引号和特殊字符串的泥潭里面解脱出来,自始至终保持一小块字符串的
格式是所谓的 WYSIWYG(所见即所得)格式的。
一个典型的用例是,当你需要一块 HTML 或者 SQL 时,这时用字符串组合,特殊字符串转义
将会非常的繁琐.
errHTML = '''
<HTML><HEAD><TITLE>
Friends CGI Demo</TITLE></HEAD>
<BODY><H3>ERROR</H3>
<B>%s</B><P>
<FORM><INPUT TYPE=button VALUE=Back
ONCLICK="window.history.back()"></FORM>


</BODY></HTML>
'''
cursor.execute('''
CREATE TABLE users (
login VARCHAR(8), uid INTEGER,
prid INTEGER)
''')
6.7.3      字符串不变性
在第 4.7.2 节里面,我们讨论了字符串是一种不可变数据类型,就是说它的值是不能被改
变或修改的。这就意味着如果你想修改一个字符串,或者截取一个子串,或者在字符串的末尾
连接另一个字符串等等,你必须新建一个字符串。
这听起来要比实际情况复杂.因为 Python 替你管理内存,你根本不需要知道到底发生了什
么,每次你修改一个字符串或者做一些改变字符串内容的操作时,Python 都会自动为你分配
一个新串.在下面的例子里面,Python 分别为"abc"和"def"分配了空间,当进行连接操作时,
Python 自动为新的字符串"abcdef"分配了空间.
>>> 'abc' + 'def'
'abcdef'
给变量赋值是没什么不同:
>>> s = 'abc'
>>> s = s + 'def'
>>> s
'abcdef'
上面的例子里,看起来是我们先把"abc"赋给了 s,然后在 s 的末尾添加了"def".这样看起
来字符串似乎是可变的,其实事实是在"s+'def""这个操作进行的时候,新建了一个新字符串,
然后这个新的对象被赋给了 s,原来的字符串'abc'被析构掉了.


我们可以用 id()函数来更明显的显示出来到底发生了什么.复习一下,id()函数返回一个
对象的身份,这个概念有点类似于"内存地址"。
>> s = 'abc'
>>>
>>> id(s)
135060856
>>>
>>> s += 'def'
>>> id(s)
135057968
注意修改前后的身份是不同的.另一个测试是针对字符串的一个字符或者一个子串所做的
修改.我们现在将展示对字符串的一个字符或者一片字符的改动都是不被允许的:
>>> s
'abcdef'
>>>
>>> s[2] = 'C'
Traceback (innermost last):
File "<stdin>", line 1, in ? AttributeError: __setitem__
>>>
>>> s[3:6] = 'DEF'
Traceback (innermost last):
File "<stdin>", line 1, in ?
AttributeError: __setslice__
两个操作都抛出了异常.为了实现要求,我们需要用现有字符串的子串来构建一个新串,然
后把这个新串赋给原来的变量:
>>> s
'abcdef'
>>>
>>> s = '%sC%s' % (s[0:2], s[3:])
>>> s


'abCdef'
>>>
>>> s[0:3] + 'DEF'
'abCDEF'
对像字符串这样的不可变对象,我们探究了它在赋值操作中所为左值的限制,左值必须是一
个完整的对象,比如说一个字符串对象,不能是字符串的一部分.对赋值操作的右值没有这个限
制.
6.8     Unicode
从 Python1.6 起引进的 Unicode 字符串支持,是用来在多种双字节字符的格式、编码进行转
换的,其中包括一些对这类字符串的操作管理功能。内建的字符串和正则表达式对 Unicode 字符
串的支持,再加上 string 模块的辅助,Python 已经可以应付大部分应用对 Unicode 的存储、
访问、操作的需要了。我们会尽最大的努力把 Python 对 Unicode 的支持说清楚,但在这之前,
让我们先讨论一些基本的术语,然后问一下自己,到底什么是 Unicode?
6.8.1     术语
Table 6.8 Unicode 术语
名词        意思
ASCII       美国标准信息交换码
BMP        基本多文种平面(第零平面)
BOM        字节顺序标记(标识字节顺序的字符)
CJK/CJKV    中文-日文-韩文(和越南语)的缩写
Code point 类似于 ASCII 值,代表 Unicode 字符的值,范围在 range(1114112)或者说
0x000000 到 0x10FFFF.
Octet       八位二进制数的位组
UCS         通用字符集
UCS2       UCS 的双字节编码方式(见 UTF-16)
UCS4        UCS 的四字节编码方式.
UTF         Unicode 或者 UCS 的转换格式.
UTF-8    八位 UTF 转换格式(无符号字节序列, 长度为一到四个字节)


UTF-16   16 位 UTF 转换格式(无符号字节序列,通常是 16 位长[两个字节],见 UCS2)
6.8.2     什么是 Unicode?
Unicode 是计算机可以支持这个星球上多种语言的秘密武器.在 Unicode 之前,用的都是
ASCII,ASCII 码非常简单,每个英文字符都是以七位二进制数的方式存贮在计算机内,其范围
是 32 到 126.当用户在文件中键入一个大写字符 A 时,计算机会把 A 的 ASCII 码值 65
写入磁盘,然后当计算机读取该文件时,它会首先把 65 转化成字符 A 然后显示到屏幕上.
ASCII 编码的文件小巧易读。一个程序只需简单地把文件的每个字节读出来,把对应的数
值转换成字符显示出来就可以了.但是 ASCII 字符只能表示 95 个可打印字符.后来的软件厂商把
ASCII 码扩展到了 8 位,这样一来它就可以多标识 128 个字符,可是 223 个字符对需要成千上万
的字符的非欧洲语系的语言来说仍然太少
Unicode 通过使用一个或多个字节来表示一个字符的方法突破了 ASCII 的限制. 在这样机
制下, Unicode 可以表示超过 90,000 个字符.
6.8.3     你是怎么用 Unicode 的?
早先,Python 只能处理 8 位的 ASCII 值,字符串就是简单的数据类型,为了处理一个字符
串,用户必须首先创建一个字符串,然后把它作为参数传给 string 模块的一个函数来处理.2000
年,Python1.6(和 2.0)版释出,Unicode 第一次在 Python 里面得到了支持.
为了让 Unicode 和 ASCII 码值的字符串看起来尽可能的相像,Python 的字符串从原来的简
单 数据 类 型 改 成了真正的对象 .ASCII 字符串成了 StringType,而 Unicode 字 符 串 成 了
UnicodeType 类型.它们的行为是非常相近的.string 模块里面都有相应的处理函数.string 模
块已经停止了更新,只保留了 ASCII 码的支持,string 模块已经不推荐使用,在任何需要跟
Unicode 兼容的代码里都不要再用该模块,Python 保留该模块仅仅是为了向后兼容。
Python 里面处理 Unicode 字符串跟处理 ASCII 字符串没什么两样.Python 把硬编码的字符
串叫做字面上的字符串,默认所有字面上的字符串都用 ASCII 编码,可以通过在字符串前面加一
个'u'前缀的方式声明 Unicode 字符串,      这个'u'前缀告诉 Python 后面的字符串要编码成 Unicode
字符串 .


>>> "Hello World" # ASCII string
>>> u"Hello World" # Unicode string
内建的 str()函数和 chr()函数并没有升级成可以处理 Unicode.它们只能处理常规的
ASCII 编码字符串,如果一个 Unicode 字符串被作作为参数传给了 str()函数,它会首先被转换
成 ASCII 字符串然后在交给 str()函数.如果该 Unicode 字符串中包含任何不被 ASCII 字符串支
持的字符,会导致 str()函数报异常.同样地,chr()函数只能以 0 到 255 作为参数工作.如果你
传给它一个超出此范围的值(比如说一个 Unicode 字符),它会报异常.
新的内建函数 unicode()和 unichar()可以看成 Unicode 版本的 str()和 chr().Unicode()
函数可以把任何 Python 的数据类型转换成一个 Unicode 字符串,如果是对象,并且该对象定义
了__unicode__()方法,它还可以把该对象转换成相应的 Unicode 字符串.具体内容见 6.1.3 和
6.5.3 章节.
6.8.4    Codecs 是什么?
codec 是 COder/DECoder 的首字母组合.它定义了文本跟二进制值的转换方式,跟 ASCII 那
种用一个字节把字符转换成数字的方式不同,Unicode 用的是多字节.这导致了 Unicode 支持多
种 不 同 的 编 码 方 式 . 比 如 说 codec 支 持 的 四 种 耳 熟 能 详 的 编 码 方 式 是 :ASCII,ISO
8859-1/Latin-1,UTF-8 和 UTF-16.
中最著名的是 UTF-8 编码,它也用一个字节来编码 ASCII 字符,这让那些必须同时处理 ASCII
码和 Unicode 码文本的程序员的工作变得非常轻松,因为 ASCII 字符的 UTF-8 编码跟 ASCII 编
码完全相同。
UTF-8 编码可以用 1 个到 4 个字节来表示其他语言的字符,CJK/East 这样的东亚文字一般都
是用 3 个字节来表示,那些少用的、特殊的、或者历史遗留的字符用 4 个字节来表示.这给那些
需要直接处理 Unicode 数据的程序员带来了麻烦,因为他们没有办法按照固定长度逐一读出各
个字符.幸运的是我们不需要掌握直接读写 Unicode 数据的方法,Python 已经替我们完成了相
关细节,我们无须为处理多字节字符的复杂问题而担心.Python 里面的其他编码不是很常用,
事实上,我们认为大部分的 Python 程序员根本就用不着去处理其他的编码,UTF-16 可能是个
例外.
UTF-16 可能是以后大行其道的一种编码格式,它容易读写,因为它把所有的字符都是用单


独的一个 16 位字,两个字节来存储的,正因为此,这两个字节的顺序需要定义一下,一般的
UTF-16 编码文件都需要一个 BOM(Byte Order Mark),或者你显式地定义 UTF-16-LE(小端)或
者 UTF-16-BE(大端)字节序.
从技术上讲,UTF-16 也是一种变长编码,但它不是很常用(人们一般不会知道或者根本不
在意除了基本多文种平面 BMP 之外到底使用的是那种平面),尽管如此,UTF-16 并不向后兼容
ASCII,因此,实现它的程序很少,因为大家需要对 ASCII 进行支持。
6.8.5    编码解码
Unicode 支持多种编码格式,这为程序员带来了额外的负担,每当你向一个文件写入字符
串的时候,你必须定义一个编码(encoding 参数)用于把对应的 Unicode 内容转换成你定义的格
式,Python 通过 Unicode 字符串的 encode()函数解决了这个问题,该函数接受字符串中的字符
为参数,输出你指定的编码格式的内容。
所以,每次我们写一个 Unicode 字符串到磁盘上我们都要用指定的编码器给他"编码"一下,
相应地,当我们从这个文件读取数据时,我们必须"解码"该文件,使之成为相应的 Unicode 字符
串对象.
简单的例子
下面的代码创建了一个 Unicode 字符串,用 UTF-8 编码器将它编码,然后写入到一个文件中
去.接着把数据从文件中读回来,解码成 Unicode 字符串对象.最后,打印出 Unicode 字符串,用
以确认程序正确地运行.
逐行解释
第 1-7 行
像通常一样,首先定义了 doc 字符串和用以表示解码器的常量,还有用以存储字符串的文
件名.
第 9-19 行
我们创建了一个 Unicode 字符串,用我们指定的编码格式对其进行编码,然后把它写入到文


件中去,(9-13 行),接着我们把内容从文件中重新读出来, 解码,显示到屏幕上,输出的时候去
掉 print 的自动换行,因为我们已经在字符串中写了一个换行符(15-19 行).
例 6.2     简单 Unicode 字符串例子(uniFile.py)
这个简单的例子中,我们把一个 Unicode 字符串写入到磁盘文件,然后再把它读出并显示
出来。写入的时候用 UTF-8 编码,读出也一样,用 UTF-8.
1  #!/usr/bin/env python
2  '''
3  An example of reading and writing Unicode strings:Writes
4  a Unicode string to a file in utf-8 and reads itback in.
5  '''
6  CODEC = 'utf-8'
7  FILE = 'unicode.txt'
8
9  hello_out = u"Hello world\n"
10 bytes_out = hello_out.encode(CODEC)
11 f = open(FILE, "w")
12 f.write(bytes_out)
13 f.close()
14
15 f = open(FILE, "r")
16 bytes_in = f.read()
17 f.close()
18 hello_in = bytes_in.decode(CODEC)
19 print hello_in,
运行该程序,我们得到如下的输出:
$ unicode_example.py
Hello World
在文件系统中也会发现一个叫 unicode.txt 的文件,里面包含跟输出的内容一致的数据.
$ cat unicode.txt
Hello World!


简单 Web 例子
在第 20 章 Web 编程里面我们展示了一个简单的在 CGI 应用中使用 Unicode 的例子.
6.8.6   把 Unicode 应用到实际应用中
这些处理 Unicode 字符串的例子简单到让人感到有点假,事实上,只要你遵守以下的规则,
处理 Unicode 就是这么简单:
z   程序中出现字符串时一定要加个前缀 u.
z   不要用 str()函数,用 unicode()代替.
z   不要用过时的 string 模块 -- 如果传给它的是非 ASCII 字符,它会把一切搞砸。
z   不到必须时不要在你的程序里面编解码 Unicod 字符.只在你要写入文件或数据库或者
网络时,才调用 encode()函数;相应地,         只在你需要把数据读回来的时候才调用 decode()
函数.
这些规则可以规避 90%由于 Unicode 字符串处理引起的 bug.现在的问题是剩下的 10%的问
题却让你处理不了,幸亏 Python 提供了大量的模块、库来替你处理这些问题.它们可以让你用
10 行 Python 语句写出其他语言需要 100 行语句才能完成的功能,但是相应地,对 Unicode 支
持的质量也完全取决于这些模块、库.
Python 标准库里面的绝大部分模块都是兼容 Unicode 的.除了 pickle 模块!pickle 模块只
支持 ASCII 字符串。如果你把一个 Unicode 字符串交给 pickle 模块来 unpickle,它会报异常.
你必须先把你的字符串转换成 ASCII 字符串才可以.所以最好是避免基于文本的 pickle 操作.
幸运地是现在二进制格式已经作为 pickle 的默认格式了,pickle 的二进制格式支持不错.这点
在你向数据库里面存东西是尤为突出,把它们作为 BLOB 字段存储而不是作为 TEXT 或者 VARCHAR
字段存储要好很多.万一有人把你的字段改成了 Unicode 类型,这可以避免 pickle 的崩溃.
如果你的程序里面用到了很多第三方模块,那么你很可能在各个模块统一使用 Unicode 通
讯方面遇到麻烦,Unicode 还没成为一项必须的规定,在你系统里面的第三方模块(包括你的应
用要面对的平台\系统)需要用相同的 Unicode 编码,否则,可能你就不能正确的读写数据.
作为一个例子,假设你正在构建一个用数据库来读写 Unicode 数据的 Web 应用.为了支持


Unicode,你必须确保以下方面对 Unicode 的支持:
z   数据库服务器(MySQL,PostgreSQL,SQL Server,等等)
z   数据库适配器(MySQLdb 等等)
z   Web 开发框架(mod_python,cgi,Zope,Plane,Django 等等)
数据库方面最容易对付,你只要确保每张表都用 UTF-8 编码就可以了。
数据库适配器可能有点麻烦,有些适配器支持 Unicode 有些不支持,比如说 MySQLdb,它并
不是默认就支持 Unicode 模式,你必须在 connect()方法里面用一个特殊的关键字 use_unicode
来确保你得到的查询结果是 Unicode 字符串.
mod_python 里 面 开 启 对 Unicode 的 支 持 相 当 简 单 , 只 要 在 request 对 象 里 面 把
text-encoding 一项设成"utf-8"就行了,剩下的 mod_python 都会替你完成,Zope 等其他复杂
的系统可能需要更多的工作来支持 Unicode.
6.8.7    从现实中得来的教训
失误 #1: 你必须在一个极有限的时间内写出一个大型的应用,而且需要其他语言的支持,
但是产品经理并没有明确定义这一点。你并没有考虑 Unicode 的兼容,直到项目快要结束... ,
这时候再添加 Unicode 的支持几乎不太可能,不是吗?
结果 #1: 没能预测到最终用户对其他语言界面的需求,在集成他们用的面向其他语种的应
用时又没有使用 Unicode 支持.更新整个系统既让让人觉得枯燥和更是浪费时间。
失误 #2:在源码中到处使用 string 模块或者 str()和 chr()函数.
结果 #2:通过全局的查找替换把 str()和 chr()替换成 unicode()和 unichr(),但是这样一
来很可能就不能再用 pickle 模块,要用只能把所有要 pickle 处理的数据存成二进制形式,这
样一来就必须修改数据库的结构,而修改数据库结构就意味着全部推倒重来.
失误 #3: 不能确定所有的辅助系统都完全地支持 Unicode.
结果 #3: 不得不去为那些系统打补丁,而其中有些系统可能你根本就没有源码.修复对
Unicode 支持的 bug 可能会降低代码的可靠性,而且非常有可能引入新的 bug.
总结: 使应用程序完全支持 Unicode,兼容其他的语言本身就是一个工程.


它需要详细的考虑、计划.所有涉及到的软件、系统都需要检查,包括 Python 的标准库和其
他将要用到的第三方扩展模块.你甚至有可能需要组建一个经验丰富的团队来专门负责国际化
(I18N)问题.
6.8.8     Python 的 Unicode 支持
内建的 unicode()函数
Unicode 的工厂方法,同 Unicode 字符串操作符(u / U)的工作方式很类似,它接受一个
string 做参数,返回一个 Unicode 字符串.
内建的 decode()/encode()方法
decode()和 encode()内建函数接受一个字符串做参数返回该字符串对应的解码后/编码后
的字符串.decode()和 encode()都可以应用于常规字符串和 Unicode 字符串.decode()方法是在
Python2.2 以后加入的.
Unicode 类型
Unicode 字符串对象是 basestring 的子类、用 Unicode()工厂方法或直接在字符串前面加
一个 u 或者 U 来创建实例.支持 Unicode 原始字符串,只要在你的字符串前面加一个 ur 或者 UR
就可以了.
Unicode 序数
标准内建函数 ord()工作方式相同,最近已经升级到可以支持 Unicode 对象了。内建的
unichr()函数返回一个对应的 Unicode 字符(需要一个 32 位的值);否则就产生一个 ValueError
异常.
强制类型转换
混合类型字符串操作需要把普通字符串转换成 Unicode 对象.
异常
UnicodeError 异常是在 exceptions 模块中定义的,ValueError 的子类.所有关于 Unicode
编解码的异常都要继承自 UnicodeError.详见 encode()函数.


标准编码
表 6.9 简洁地列出了 Python 中常用的编码方式.更详细、完全的列表见 Python 的文档,下
面是它的链接:
http://docs.python.org/lib/standard-encodings.html
RE 引擎对 Unicode 的支持
正则表达式引擎需要 Unicode 支持.详见 6.9 节的 re 模块.
表 6.9 常用 Unicode 编辑码
编码               描述
utf-8            变量长度为 8 的编码(默认编码)
utf-16           变量长度为 16 的编码(大/小端)
utf-16-le        小端 UTF-16 编码
utf-16-be      大端 UTF-16 编码
ascii           7-bit 7 位 ASCII 码表
iso-8859-1         ISO 8859-1 (Latin-1) 码表
unicode-escape    (定义见 Python Unicode 构造函数)
raw-unicode-escape (定义见 Python Unicode 构造函数)
native          Python 用的内部格式
字符串格式化操作符
对于 Python 的格式化字符串的操作符,%s 把 Python 字符串中的 Unicode 对象执行了
str(u)操作,所以,输出的应该是 u.encode(默认编码).如果格式化字符串是 Unicode 对象,所
有的参数都将首先强制转换成 Unicode 然后根据对应的格式串一起进行格式转换.数字首先被
转 换 成 普 通 字 符 串 , 然 后 在 转 换 成 Unicode.Python 字 符 串 通 过 默 认 编 码 格 式 转 化 成
Unicode.Unicode 对象不变,所有其他格式字符串都需要像上面这样转化,下面是例子:
u"%s %s" % (u"abc", "abc")   u"abc abc"
6.9    相关模块


表 6.10 列出了 Python 标准库里面与字符串有关的主要模块.
Table 6.10    与字符串类型有关的模块
模块                描述
string            字符串操作相关函数和工具,比如 Template 类.
re                正则表达式:强大的字符串模式匹配模块
struct            字符串和二进制之间的转换
c/StringIO        字符串缓冲对象,操作方法类似于 file 对象.
base64            Base 16,32,64 数据编解码
codecs            解码器注册和基类
crypt           进行单方面加密
a
difflib         找出序列间的不同
b
hashlib         多种不同安全哈希算法和信息摘要算法的 API
c
hma               HMAC 信息鉴权算法的 Python 实现
d
md5               RSA 的 MD5 信息摘要鉴权
rotor        提供多平台的加解密服务
d
sha               NIAT 的安全哈希算法 SHA
e
stringprep 提供用于 IP 协议的 Unicode 字符串
textwrape       文本打包和填充
unicodedata    Unicode 数据库
a. Python2.1 新加
b.Python2.5 新加
c. Python2.2 新加
d. Python2.5 的 hashlib 中废除
e. Python2.3 新加
核心模块: re
正则表达式(RE)提供了高级的字符串模式匹配方案.通过描述这些模式的语法,你可以像使
用“过滤器”一样高效地查找传进来的文本。这些过滤器允许你基于自定义的模式字符串抽取
匹配模式、执行查找-替换或分割字符串.


Python1.5 中加入的 re 模块代替了早期的 regex 和 regsub 模块,全面采用了 Perl 正则表
达式语法,使得 Python 在对正则表达式的支持方面前进了一大步. Python1.6 里面重写了正则
表达式引擎(SRE),增加了对 Unicode 字符串的支持并对性能进行了重大的升级.SRE 引擎取代了
原有正则表达式的模块下的 PCRE 引擎.
该模块中包含的关键函数有:compile() - 将一个 RE 表达式编译成一个可重用的 RE 对
象;match() - 试图从字符串的开始匹配一个模式;
search() - 找出字符串中所有匹配的项;sub() - 进行查找替换操作。其中的一些函数返
回匹配到的对象,你可以通过组匹配来访问(如果找到的话)。15 章的整章内容都是讲述正则
表达式。
6.10     字符串关键点总结
一些引号分隔的字符
你可以把字符串看成是 Python 的一种数据类型,在 Python 单引号或者双引号之间的字符数
组或者是连续的字符集合.在 Python 中最常用两个引号是单引号(')和双引号(")。字符串
的实际内容是这些单引号(')或者双引号(")之间的字符,不包括引号本身.
可以用两种引号来创建字符串是很有益处的,因为是当你的字符串中包含单引号时,如果
用单引号创建字符串,那么字符串中的双引号就不需要转义。反之亦然.
不可分字符类型
字符串是唯一的字面上的字符序列类型.不过,字符本身并不是一种类型,所以,字符串是字
符存储操作的最基本单位.字符应该视为长度为 1 的字符串.
字符串格式化操作符 ( % )提供类似于 printf()那样的功能.
字符串格式化操作符(见 6.4.1 节)提供了一种基于多种输入类型的创建自定义字符串的灵
活方式.它也提供了类似于 C/C++世界里的格式化操作的接口.
三引号
在 6.7.2 节里面,我们介绍了三引号,在三引号字符串中可以包含诸如换行回车或者 tab 键
这样的特殊字符.三引号字符串是用两边各三个单引号(''')或者两边各三个双引号(""")来定
义的.


原始字符串对每个特殊字符串都使用它的原意
第 6.4.2 节中,我们讲述了原始字符串,并且讨论了它们并不通过反斜线转义特殊字符的特
性.这个特性使得原始字符串非常适用于那些需要字符串原意的场合,比如在定义一个正则表达
式时.
Python 字符串不是通过 NUL 或者'\0'来结束的
C 编程的一个主要问题是你访问了一个字符串后面的本不属于你的空间,这种情况发生在你
没有在字符串末尾添加终结符,NUL 或者'\0'(ASCII 值为 0)的时候.Python 不仅为你自动管理内
存,而且也把 C 的这个负担或者说是小麻烦去掉了.Python 中的字符串不是以 NUL 结束的,所以
你不需要为是否已经添加终结符担心.字符串中只包含你所定义的东西,没有别的.
6.11  列表
像字符串类型一样,列表类型也是序列式的数据类型,可以通过下标或者切片操作来访问
某一个或者某一块连续的元素.然而,相同的方面也就这些,字符串只能由字符组成,而且是不
可变的(不能单独改变它的某个值),而列表则是能保留任意数目的 Python 对象的灵活的容器。
就像我们将要看到的例子中所示,创建列表非常简单,向列表中添加元素也是如此.
列表不仅可以包含 Python 的标准类型,而且可以用用户定义的对象作为自己的元素.列表
可以包含不同类型的对象,而且要比 C 或者 Python 自己的数组类型(包含在 array 扩展包中)都
要灵活.因为数组类型所有的元素只能是一种类型.列表可以执行 pop,empt,sort,reverse 等操
作.列表也可以添加或者减少元素.还可以跟其他的列表结合或者把一个列表分成几个.可以对
单独一个元素或者多个元素执行 insert,update,或者 remove 操作.
元组类型在很多操作上都跟列表一样,许多用在列表上的例子在元组上照样能跑,我们有一
节内容专门讲解元组类型.它们的主要不同在于元组是不可变的,或者说是只读的,所以那些用
于更新列表的操作,比如用切片操作来更新一部分元素的操作,就不能用于元组类型.
如何创建列表类型数据并给它赋值
创建一个列表就像给一个变量赋值一样的简单.你手工写一个列表(空的或者有值的都行)
然后赋给一个变量,列表是由方括号([])来定义的,当然,你也可以用工厂方法来创建它.


>>> aList = [123, 'abc', 4.56, ['inner', 'list'], 7-9j]
>>> anotherList = [None, 'something to see here']
>>> print aList
[123, 'abc', 4.56, ['inner', 'list'], (7-9j)]
>>> print anotherList
[None, 'something to see here']
>>> aListThatStartedEmpty = []
>>> print aListThatStartedEmpty
[]
>>> list('foo')
['f', 'o', 'o']
如何访问列表中的值
列表的切片操作就像字符串中一样;切片操作符([])和索引值或索引值范围一起使用
>>> aList[0]
123
>>> aList[1:4]
['abc', 4.56, ['inner', 'list']]
>>> aList[:3]
[123, 'abc', 4.56]
>>> aList[3][1]
'list'
如何更新列表
你可以通过在等号的左边指定一个索引或者索引范围的方式来更新一个或几个元素,你也
可以用 append()方法来追加元素到列表中去.
>>> aList
[123, 'abc', 4.56, ['inner', 'list'], (7-9j)]
>>> aList[2]
4.56
>>> aList[2] = 'float replacer'
>>> aList
[123, 'abc', 'float replacer', ['inner', 'list'], (7-9j)]
>>>
>>> anotherList.append("hi, i'm new here")


>>> print anotherList
[None, 'something to see here', "hi, i'm new here"]
>>> aListThatStartedEmpty.append('not empty anymore')
>>> print aListThatStartedEmpty
['not empty anymore']
如何删除列表中的元素或者列表(本身)
要删除列表中的元素,如果你确切的知道要删除元素的素引可以用 del 语句,否则可以用
remove()方法.
>>> aList
[123, 'abc', 'float replacer', ['inner', 'list'], (7-9j)]
>>> del aList[1]
>>> aList
[123, 'float replacer', ['inner', 'list'], (7-9j)]
>>> aList.remove(123)
>>> aList
['float replacer', ['inner', 'list'], (7-9j)]
你还可以通过 pop()方法来删除并从列表中返回一个特定对象.
一般来说,程序员不需要去删除一个列表对象。列表对象出了作用域(比如程序结束,函数调
用完成等等)后它会自动被析构,但是如果你想明确的删除一整个列表,你可以用 del 语句:
del aList
6.12 操作符
6.12.1 标准类型操作符
在第 4 章里,我们介绍了一些适用于包括标准类型在内的大部分对象的操作符,现在我们来
看一下这些操作符如何作用在列表上:
>>> list1 = ['abc', 123]
>>> list2 = ['xyz', 789]


>>> list3 = ['abc', 123]
>>> 1ist1 < list2
True
>>> list2 < list3
False
>>> list2 > list3 and list1 == list3
True
在使用比较操作符时,比较数字和字符串是很明了的,但是用在列表上时就不是那么简单了,
列表比较操作有些狡猾,但是合乎逻辑.比较列表时也是用的内建的 cmp()函数,基本的比较逻辑
是这样的:两个列表的元素分别比较,直到有一方的元素胜出,比如我们上面的例子,'abc'和
'xyz'的比较直接决定了比较结果,在'abc'<'xyz'时,list1<list2,list2>=list3,元组类型在
进行比较操作时跟列表遵循相同的逻辑.
6.12.2      序列类型操作符
切片([] 和[:])
列表的切片操作跟字符串的切片操作很像,不过列表的切片操作返回的是一个对象或者是
几个对象的集合,而不是像字符串那样,返回一个字符或者一个子串.我们定义以下几个列表用
来做例子:
>>> num_list = [43, -1.23, -2, 6.19e5]
>>> str_list = ['jack', 'jumped', 'over', 'candlestick']
>>> mixup_list = [4.0, [1, 'x'], 'beef', -1.9+6j]
列表的切片操作也遵从正负索引规则,也有开始索引值,结束索引值,如果这两个值为空,默
认也会分别指到序列的开始和结束位置.
>>> num_list[1]
-1.23
>>>
>>> num_list[1:]
[-1.23, -2, 619000.0]
>>>
>>> num_list[2:-1]


[-2]
>>>
>>> str_list[2]
'over'
>>> str_list[:2]
['jack', 'jumped']
>>>
>>> mixup_list
[4.0, [1, 'x'], 'beef', (-1.9+6j)]
>>> mixup_list[1]
[1, 'x']
跟字符串类型只能用字符为元素不同,列表类型的元素可以是另一个序列类型,这就意味着
你在列表的元素上也可以使用所有的序列操作符或者在其之上执行序列类型内建的各种操作.
在下面的例子中,我们将会展示,不仅可以在一个切片操作的结果之上再进行切片,而且还可以
改变这个切片的结果,即使新对象的类型跟原对象不同也可以.你会注意到,这跟多维数组有一
些类似.
>>> mixup_list[1][1]
'x'
>>> mixup_list[1][1] = -64.875
>>> mixup_list
[4.0, [1, -64.875], 'beef', (-1.9+6j)]
这时用 num_list 来做的另一个例子:
>>> num_list
[43, -1.23, -2, 6.19e5]
>>>
>>> num_list[2:4] = [16.0, -49]
>>>
>>> num_list
[43, -1.23, 16.0, -49]
>>>
>>> num_list[0] = [65535L, 2e30, 76.45-1.3j]


>>>
>>> num_list
[[65535L, 2e+30, (76.45-1.3j)], -1.23, 16.0, -49]
注意在最后一个例子中,我们是如何把列表的单一元素替换成一个列表.在列表中进行诸如
remove,add,和 replace 的操作是多么的自由了吧!还有一点要注意,如果你想以子列表的形式
得到一个列表中的一个切片,那需要确保在赋值时等号的左边也是一个列表而不是一个列表的
元素.
成员关系操作( in ,not in)
列表中(同样适用于元组),我们可以检查一个对象是否是一个列表(或者元组)的成员.
>>> mixup_list
[4.0, [1, 'x'], 'beef', (-1.9+6j)]
>>>
>>> 'beef' in mixup_list
True
>>>
>>> 'x' in mixup_list
False
>>>
>>> 'x' in mixup_list[1] True
>>> num_list
[[65535L, 2e+030, (76.45-1.3j)], -1.23, 16.0, -49]
>>>
>>> -49 in num_list
True
>>>
>>> 34 in num_list
False
>>>
>>> [65535L, 2e+030, (76.45-1.3j)] in num_list
True
注 意 ,'x' 并 不 属 于 mixup_list, 因 为 'x' 本 身 并 不 是 mixup_list 的 一 个 成 员 , 而 是
mixup_list[1]的,mixup_list[1]也是一个列表类型.成员关系操作运算同样适用于元组类型.


连接接操作符( + )
连接操作符允许我们把多个列表对象合并在一起.注意,列表类型的连接操作也只能在同类
型之间进行,换句话说,你不能把两个不同类型的对象连接在一起,即便他们都是序列类型也不
行.
>>> num_list = [43, -1.23, -2, 6.19e5]
>>> str_list = ['jack', 'jumped', 'over', 'candlestick']
>>> mixup_list = [4.0, [1, 'x'], 'beef', -1.9+6j]
>>>
>>> num_list + mixup_list
[43, -1.23, -2, 619000.0, 4.0, [1, 'x'], 'beef', (-1.9+6j)]
>>>
>>> str_list + num_list
['jack', 'jumped', 'over', 'candlestick', 43, -1.23, -2, 619000.0]
在 6.23 节里面我们会讲到,从 Python1.5.2 起,我们可以用 extend()方法来代替连接操作
符把一个列表的内容添加到另一个中去.使用 extend()方法比连接操作的一个优点是它实际上
是把新列表添加到了原有的列表里面,而不是像连接操作那样新建一个列表。list.extend()
方法也被用来做复合赋值运算,也就是 Python2.0 中添加的替换连接操作(+=).
必须指出,连接操作符并不能实现向列表中添加新元素的操作.在接下来的例子中,我们展
示了一个试图用连接操作向列表中添加新元素报错的例子.
>>> num_list + 'new item' Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: illegal argument type for built-in operation
这个例子之所以是错误的,是因为我们在连接操作符的左右两边使用了不同类型的值,列表
类型 + 字符串类型这样的操作是非法的.显然,我们的初衷是把一个字符串作为一个新元素添
加到列表中去,不过我们的方法不正确.幸运的是,我们有一个正确的方法:
使用内建函数 append() (我们会在 6.13 节里面正是地介绍 append()和其他内建函数)


>>> num_list.append('new item')
重复操作符( * )
重复操作符可能更多的应用在字符串类型中,不过,列表和元组跟字符串同属序列类型,所
以需要的时候也可以使用这一操作.
>>> num_list * 2
[43, -1.23, -2, 619000.0, 43, -1.23, -2, 619000.0]
>>>
>>> num_list * 3
[43, -1.23, -2, 619000.0, 43, -1.23, -2, 619000.0, 43,
-1.23, -2, 619000.0]
Python2.0 起,也开始支持复合赋值运算:
>>> hr = '-'
>>> hr *= 30
>>> hr
'------------------------------'
6.12.3 列表类型操作符和列表解析
其实 Python 中没有专门用于列表类型的操作符.列表可以使用大部分的对象和序列类型的
操作符.此外,列表类型有属于自己的方法.列表才有的构建--列表解析.这种方法是结合了列表
的方括弧和 for 循环,在逻辑上描述要创建的列表的内容.我们在第八章讨论列表解析,这里仅
仅向本章其他地方所做的那样,展示一个简单的例子:
>>> [ i * 2 for i in [8, -2, 5] ]
[16, -4, 10]
>>> [ i for i in range(8) if i % 2 == 0 ]
[0, 2, 4, 6]
6.13     内建函数


6.13.1      标准类型函数
cmp()
在 4.6.1 章节里,我们通过比较数字和字符串介绍了内建 cmp()函数.但我们还不知道 cmp()
函数是如何跟其他的比如列表和元组类型合作的,这些类型不仅含有数字和字符串,而且还有列
表,元组,字典之类的其他对象,甚至可以是用户自定义的对象.这种情况下 cmp()函数是如何工
作的呢?
>>> list1, list2 = [123, 'xyz'], [456, 'abc']
>>> cmp(list1, list2)
-1
>>>
>>> cmp(list2, list1)
1
>>> list3 = list2 + [789]
>>> list3
[456, 'abc', 789]
>>>
>>> cmp(list2, list3)
-1
如果我们比较的是两个同类的对象,比较操作是非常直观的.比如数字和字符串,直接比较
它们的值就行了。对于序列类型,比较操作稍微有点复杂了,但是方式上有相似 Python 在两个
对象基本不能比较的时候尽量做出公平的结果,比如当两个对象没有关系时或者两种类型根本
就没有用于比较的函数时,这时 Python 只能根据"逻辑"来做出结论.
除了这种极端的情况之外,安全又健全的比较方法是如果有不相等的情况出现,比较操作就
结束.这种算法是如何工作的呢?像我们前面简短的提到过的,列表的元素是可以无限迭代的.如
果它的元素都是相同类型,则用标准的比较方法来作比较.否则,如果要比较的元素类型不一致,
就像我们前面提到过的那样,如果比较的对象不一致,那么要得到一个准确的或者说绝对的比较
结果就有些冒险.
当我们较 list1 和 list2 时,list1 和 list2 进行逐项比较.第一个比较操作发生在两个列
表的第一个元素之间,比如说,123 跟 456 比较,因为 123<456,所以 list1 被认为小于 list2.


如果比较的值相等,那么两个序列的下一个值继续比较,直到不相等的情况出现,或者到达
较短的一个序列的末尾,在这种情况下,长的序列被认为是"较大"的.这就是为什么上面的
list2<list3 的原因.元组类型比较也是用这种算法.最后我们以这种算法的关键点作为本节的
结束:
1.    对两个列表的元素进行比较.
2.    如果比较的元素是同类型的,则比较其值,返回结果.
3.    如果两个元素不是同一种类型,则检查它们是否是数字.
a. 如果是数字,执行必要的数字强制类型转换,然后比较.
b. 如果有一方的元素是数字,则另一方的元素"大"(数字是"最小的")
c. 否则,通过类型名字的字母顺序进行比较.
4.    如果有一个列表首先到达末尾,则另一个长一点的列表"大".
5.    如果我们用尽了两个列表的元素而且所有元素都是相等的,那么结果就是个平局,就
是说返回一个 0.
6.13.2    序列类型函数
len()
对字符串来说 len()返回字符串的长度,就是字符串包含的字符个数.对列表或者元组来说,
它会像你想像的那样返回列表或者元组的元素个数,容器里面的每个对象被作为一个项来处理.
我们下面的例子用了上面已经定义的列表.
>>> len(num_list)
4
>>>
>>> len(num_list*2)
8
max() and min()
max()和 min()函数在字符串操作里面用处不大,因为它们能对字符串做的只能是找出字符


串中"最大"和"最小"的字符(按词典序),而对列表和元组来说,它们被定义了更多的用处.比如
对只包含数字和字符串对象的列表,max()和 min()函数就非常有用,重申一遍,混合对象的结构
越复杂返回的结构准确性就越差.然而,在有些情况下(虽然很少),这样的操作可以返回你需要
的结果.我们展示了一些使用上面定义好的列表的例子.
>>> max(str_list)
'park'
>>> max(num_list)
[65535L, 2e+30, (76.45-1.3j)]
>>> min(str_list)
'candlestick'
>>> min(num_list)
-49
sorted() and reversed()
>>> s = ['They', 'stamp', 'them', 'when', "they're", 'small']
>>> for t in reversed(s):
...    print t,
...
small they're when them stamp They
>>> sorted(s)
['They', 'small', 'stamp', 'them', "they're", 'when']
初学者使用字符串,应该注意是如何把单引号和双引号的使用矛盾和谐掉.同时还要注意字
符串排序使用的是字典序,而不是字母序(字母'T'的 ASCII 码值要比字母'a'的还要靠前)
enumerate() and zip()
>>> albums = ['tales', 'robot', 'pyramid']
>>> for i, album in enumerate(albums):
... print i, album
...


0 tales
1 robot
2 pyramid
>>>
>>> fn = ['ian', 'stuart', 'david']
>>> ln = ['bairnson', 'elliott', 'paton']
>>>
>>> for i, j in zip(fn, ln):
... print ('%s %s' % (i,j)).title()
...
Ian Bairnson Stuart Elliott David Paton
sum()
>>> a = [6, 4, 5]
>>> reduce(operator.add, a)
15
>>> sum(a)
15
>>> sum(a, 5)
20
>>> a = [6., 4., 5.]
>>> sum(a)
15.0
list() and tuple()
list()函数和 tuple()函数接受可迭代对象(比如另一个序列)作为参数,并通过浅拷贝数据
来创建一个新的列表或者元组.虽然字符串也是序列类型的,但是它们并不是经常用于 list()和
tuple(). 更多的情况下,它们用于在两种类型之间进行转换,比如你需要把一个已有的元组转
成列表类型的(然后你就可以修改它的元素了),或者相反.


>>> aList = ['tao', 93, 99, 'time']
>>> aTuple = tuple(aList)
>>> aList, aTuple
(['tao', 93, 99, 'time'], ('tao', 93, 99, 'time'))
>>> aList == aTuple
False
>>> anotherList = list(aTuple)
>>> aList == anotherList
True
>>> aList is anotherList
False
>>> [id(x) for x in aList, aTuple, anotherList]
[10903800, 11794448, 11721544]
正如我们在本章的开头所讨论的,无论 list()还是 tuple()都不可能做完全的转换(见
6.1.2 节).也就是说,你传给 tuple()的一个列表对象不可能变成一个元组,而你传给 list()的
对象也不可能真正的变成一个列表.虽然前后两个对象(原来的和新的对象)有着相同的数据集
合(所以相等 == ),但是变量指向的却不是同一个对象了(所以执行 is 操作会返回 false).还
要注意,即使它们的所有的值都相同,一个列表也不可能"等于"一个元组.
6.13.3     列表类型内建函数
如果你不考虑 range()函数的话,Python 中没有特定用于列表的内建函数.range()函数接
受一个数值作为输入,输出一个符合标准的列表.第 8 章里面详细讨论了 range()函数.列表类型
对象可以使用大多数的对象和序列的内建函数,并且,列表对象有属于它们自己的方法.
6.14    列表类型的内建函数
Python 中的列表类型有自己的方法.我们会在第 13 章面向对象编程里面正式而详细的介绍
方法这一概念,现在你只需要把方法视为特定对象的函数或者过程就好.本节讨论的方法就像内
建的函数一样,除了它们只对列表类型进行操作之外.因为这些函数涉及到对列表更改(或者说
更新),所以它们都不适应于元组.


你可以重温以下我们前面讲到的用点号的方式访问对象的属性:object.attribute.列表的
方法也是这样:list.method().我们用点号来访问一个对象的属性(在这里是一个函数),然后用
函数操作符( () )来调用这个方法.
我们可以在一个列表对象上应用 dir()方法来得到它所有的方法和属性:
>>> dir(list) # or dir([])
['__add__', '__class__', '__contains__', '__delattr__',
'__delitem__', '__delslice__', '__doc__', '__eq__',
'__ge__', '__getattribute__', '__getitem__',
'__getslice__', '__gt__', '__hash__', '__iadd__',
'__imul__', '__init__', '__iter__', '__le__', '__len__',
'__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
'__setattr__', '__setitem__', '__setslice__', '__str__',
'append', 'count', 'extend', 'index', 'insert', 'pop',
'remove', 'reverse', 'sort']
表 6.11 列出了目前列表类型支持的所有方法,稍后我们给出使用这些方法的例子.
表 6.11      列表类型内建函数
List Method            Operation
list.append(obj)          向列表中添加一个对象 obj
list.count(obj)          返回一个对象 obj 在列表中出现的次数
list.extend(seq)a          把序列 seq 的内容添加到列表中
list.index(obj, i=0,
j=len(list))              返回 list[k] == obj 的 k 值,并且 k 的范围在 i<=k<j;否则
引发 ValueError 异常.
list.insert(index, obj) 在索引量为 index 的位置插入对象 obj.
a
list.pop(index=-1)        删除并返回指定位置的对象,默认是最后一个对象
list.remove(obj)         从列表中删除对象 obj
list.reverse()           原地翻转列表
list.sort(func=None,key=None,


reverse=False)b         以指定的方式排序列表中的成员,如果 func 和 key 参数指定,
则按照指定的方式比较各个元素,如果 reverse 标志被置为
True,则列表以反序排列.
a.   Python1.5.2 加入的特性.
b.   key 和 reverse 特性在 Python2.4 中新添.
>>> music_media = [45]
>>> music_media
[45]
>>>
>>> music_media.insert(0, 'compact disc')
>>> music_media
['compact disc', 45]
>>>
>>> music_media.append('long playing record')
>>> music_media
['compact disc', 45, 'long playing record']
>>>
>>> music_media.insert(2, '8-track tape')
>>> music_media
['compact disc', 45, '8-track tape', 'long playing record']
在前面的例子中,我们用一个元素初始化了一个列表,然后当向列表插入元素,或在尾部追
加新的元素后,都会去检查这个列表.现在确认一下一个值是否在我们的列表中,并看看如何找
出元素在列表中的索引值.我们用 in 操作符和 index()方法实现这两个需求.
>>> 'cassette' in music_media
False
>>> 'compact disc' in music_media
True
>>> music_media.index(45)
1
>>> music_media.index('8-track tape')
2


>>> music_media.index('cassette') Traceback (innermost last):
File "<interactive input>", line 0, in ? ValueError: list.index(x): x not in list
噢!最后一个例子怎么出错了?呃,看起来用 index()来检查一个元素是否存在于一个 list
中并不是个好主意,因为我们出错了.应该先用 in 成员关系操作符(或者是 not in)检查一下,然
后在用 index()找到这个元素的位置。我们可以把最后几个对 index()调用放到一个单独的 for
循环里面,像这样:
for eachMediaType in (45, '8-track tape', 'cassette'):
if eachMediaType in music_media:
print music_media.index(eachMediaType)
这个方案避免了我们上面犯的错误,因为在确认一个元素属于该列表之前 index()方法是不
会被调用的.稍后我们将会发现该如何处理这种错误,而不是这样的一出错,程序就崩溃了。
接下来我们测试 sort()和 reverse()方法,它们会把列表中的元素排序,然后翻转.
>>> music_media
['compact disc', 45, '8-track tape', 'long playing record']
>>> music_media.sort()
>>> music_media
[45, '8-track tape', 'compact disc', 'long playing record']
>>> music_media.reverse()
>>> music_media
['long playing record', 'compact disc', '8-track tape', 45]
核心笔记:那些可以改变对象值的可变对象的方法是没有返回值的!
Python 初学者经常会陷入一个误区:调用一个方法就返回一个值.最明显的例子就是
sort():
>>> music_media.sort()# 没有输出?
>>>
在使用可变对象的方法如 sort(),extend()和 reverse()的时候要注意,这些操作会在列表
中原地执行操作,也就是说现有的列表内容会被改变,但是没有返回值!是的,与之相反,字符串
方法确实有返回值:


>>> 'leanna, silly girl!'.upper()
'LEANNA, SILLY GIRL!'
温习一下,字符串是不可变的 -- 不可变对象的方法是不能改变它们的值的,所以它们必须
返回一个新的对象.如果你确实需要返回一个对象,那么我们建议你看一下 Python2.4 以后加入
的 reversed()和 sorted()内建函数.
它们像列表的方法一样工作,不同的是它们可以用做表达式,因为它们返回一个对象.同时
原来的那个列表还是那个列表,没有改变,而你得到的是一个新的对象.
回到 sort()方法,它默认的排序算法是归并排序(或者说"timsort")的衍生算法,时间复杂
度是 O(lg(n!)).关于这个算法我们不做进一步的讲解,可以通过源码查看它们的详情 --
Objects/listobject.c,还有算法描述: Objects/listsort.txt.
extend()方法接受一个列表的内容然后把它的所有元素追加到另一个列表中去:
>>> new_media = ['24/96 digital audio disc', 'DVD Audio disc', 'Super Audio CD']
>>> music_media.extend(new_media)
>>> music_media
['long playing record', 'compact disc', '8-track tape',
45, '24/96 digital audio disc', 'DVD Audio disc', 'Super
Audio CD']
从 2.2 开始,extend()方法的参数支持任何可迭代对象,在 2.2 之前,它的参数必须是序列对
象,而在 1.6 之前它的参数必须是列表对象.通过可迭代对象(而不是一个序列对象),你能做更
多有趣的事情,比如:
>>> motd = []
>>> motd.append('MSG OF THE DAY')
>>> f = open('/etc/motd', 'r')
>>> motd.extend(f)
>>> f.close()
>>> motd
['MSG OF THE DAY', 'Welcome to Darwin!\n']


1.5.2 中加入的 pop()方法会从列表中把最后的或指定的元素返回调用者.我们会在 6.15.1
节和练习中看到 pop()方法,
6.15 列表的特殊特性
6.15.1 用列表构建其他数据结构
列表有容器和可变的特性,这使得它非常灵活,用它来构建其他的数据结构不是件难事.我
们马上能想到的是堆栈和队列.
堆栈
堆栈是一个后进先出(LIFO)的数据结构,其工作方式就像自助餐厅里面用于放盘子的弹簧
支架.把盘子想像成对象,第一个离开堆栈的是你最后放上的那个.在栈上"push"元素是个常用
术语,意思是把一个对象添加到堆栈中.反之,要删除一个元素,你可以把它"pop"出堆栈,例 6.3
展示了一个菜单驱动的程序,它实现了一个简单的、用于存储字符串的堆栈.
逐行解释
1-3 行
一开始是 Unix 的起始行,然后我们初始化堆栈(其实是个列表).
例 6.3 用列表模拟堆栈(stack.py)
这个简单的脚本把列表做为堆栈用于存储和取回输入的字符串,这个菜单驱动驱动的程序
仅使用了列表的 append()和 pop()方法.
1  #!/usr/bin/env python
2
3  stack = []
4
5  def pushit():
6  stack.append(raw_input('Enter new string: ').strip())
7
8  def popit():
9  if len(stack) == 0:


10 print 'Cannot pop from an empty stack!'
11 else:
12 print 'Removed [', ‘stack.pop()‘, ']'
13
14 def viewstack():
15 print stack # calls str() internally
16
17 CMDs = {'u': pushit, 'o': popit, 'v': viewstack}
18
19 def showmenu():
20 pr = """
21 p(U)sh
22 p(O)p
23 (V)iew
24 (Q)uit
25
26 Enter choice: """
27
28 while True:
29 while True:
30 try:
31 choice = raw_input(pr).strip()[0].lower()
32 except (EOFError,KeyboardInterrupt,IndexError):
33 choice = 'q'
34
35 print '\nYou picked: [%s]' % choice
36 if choice not in 'uovq':
37 print 'Invalid option, try again'
38 else:
39 break
40
41 if choice == 'q':
42 break


43 CMDs[choice]()
44
45 if __name__ == '__main__':
46 showmenu()
5-6 行
pushit()函数添加一个元素(通过提示由用户输入)到堆栈中.
8-12 行
popit()函数从堆栈中移除一个元素(最新的那个).试图从一个空的堆栈中移除元素会引
发一个错误.这种情况下,用户会得到一个警告提示.当一个元素从堆栈中 pop 出来时,用户可以
看到到底是哪个元素被移除了.我们用反单引号(`)来代替 repr()函数,,把字符串的内容用引号
括起来显示而不是单单显示字符串的内容.
14-15 行
viewstack()方法显示堆栈现有的内容.
Line 17
虽然我们下一章才会正式讲解字典类型,但是这里我们还是希望给你展示一个小例子,一
个包含命令的矢量(CMDs).这个字典的内容是前面定义的三个"动作"函数,它们可以通过字母进
行访问,用户必须输入这些字母来执行相应的命令.比如说,要进栈一个字符串,用户就必须输入
'u',那么字母'u'是如何从字典里面访问到 pushit()函数的呢?在第 43 行执行了选择的函数.
19-43 行
整个菜单驱动的应用都是由 showmenu()函数控制的.它首先向用户提供一个选单,如果用户
输入了合法选项就调用相应的函数.我们还没有详细的涉及到异常的处理,try-except 语句,但
本 节 里 面 的 代 码 允 许 用 户 输 入 ^D(EOF, 产 生 一 个 EOF 错 误 ) 或 者 ^C( 中 断 退 出 , 产 生 一 个
KeyboardInterrupt 异常),这两种操作在我们的脚本里面都会得到处理,结果等同于用户输入
'q'退出应用程序.这是对 Python 异常处理特性的一次应用,说明了 Python 的异常处理机制是多
么方便.外循环用来执行用户输入的指令直到用户退出应用,内循环提示用户输入一个合法的命
令项.
45-46 行


如果调用文件,这部分的代码就会启动程序.如果该脚本只是被作为一个模块导入,则仅仅
是导入定义的函数和变量,而菜单也就不会显示.关于第 45 行和 __name__ 变量,请查阅第
3.4.1 节 .
下面简单的执行了一下该脚本:
$ stack.py p(U)sh
p(O)p
(V)iew
(Q)uit
Enter choice: u
You picked: [u]
Enter new string: Python
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: u
You picked: [u]
Enter new string: is
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: u
You picked: [u]
Enter new string: cool!


p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: v
You picked: [v]
['Python', 'is', 'cool!']
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: o
You picked: [o] Removed [ 'cool!' ]
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: o
You picked: [o] Removed [ 'is' ]
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: o
You picked: [o] Removed [ 'Python' ]
p(U)sh p(O)p
(V)iew
(Q)uit


Enter choice: o
You picked: [o]
Cannot pop from an empty stack!
p(U)sh p(O)p
(V)iew
(Q)uit
Enter choice: ^D You picked: [q]
队列
队列是一种先进先出(FIFO)的数据类型,它的工作原理类似于超市中排队交钱或者银行里
面的排队,队列里的第一个人首先接受服务(
满心想第一个出去).新的元素通过"入队"的方式添加进队列的末尾,"出队"就是从队列的
头部删除.下面的例子里面展示了这种操作,我们把上面的堆栈的例子进行了改造,用列表实现
了一个简单的队列.
例 6.4 把列表用做队列(queue.py)
这个例子中,我们把列表用做队列来存储和取回菜单驱动应用里面输入的字符串,只用到了
列表的 append()和 pop()方法.
1 #!/usr/bin/env python
2
3 queue = []
4
5 def enQ():
6 queue.append(raw_input('Enter new string: ').strip())
7
8 def deQ():
9 if len(queue) == 0:
10 print 'Cannot pop from an empty queue!'
11 else:


12 print 'Removed [', ‘queue.pop(0)‘, ']'
13
14 def viewQ():
15 print queue # calls str() internally
16
17 CMDs = {'e': enQ, 'd': deQ, 'v': viewQ}
18
19 def showmenu():
20 pr = """
21 (E)nqueue
22 (D)equeue
23 (V)iew
24 (Q)uit
25
26 Enter choice: """
27
28 while True:
29 while True:
30 try:
31 choice = raw_input(pr).strip()[0].lower()
32 except (EOFError,KeyboardInterrupt,IndexError):
33 choice = 'q'
34
35 print '\nYou picked: [%s]' % choice
36 if choice not in 'devq':
37 print 'Invalid option, try again'
38 else:
39 break
40
41 if choice == 'q':
42 break
43 CMDs[choice]()
44


45 if __name__ == '__main__':
46 showmenu()
逐行解释
该脚本跟上面的 stack.py 非常相似,所以我们只讲解一下有显著不同的行:
1-7 行
定义了几个后面脚本要用到的常量.
Lines 5–6
enQ()方法跟 pushit()方法非常相近,只不过名字改变了.
8-12 行
两个脚本的主要差别就在于此,deQ()函数不像 popit()函数那样把列表的最后一个元素
弹出来,而是第一个元素.
17,21-24,36 行
选项改变了,所以我们也需要重写原来的提示信息和输入检查.
还是在这里列举一些输出:
$ queue.py
(E)nqueue
(D)equeue
(V)iew
(Q)uit
Enter choice: e
You picked: [e]
Enter new queue element: Bring out
(E)nqueue


(D)equeue
(V)iew
(Q)uit
Enter choice: e
You picked: [e]
Enter new queue element: your dead!
(E)nqueue
(D)equeue
(V)iew
(Q)uit
Enter choice: v
You picked: [v]
['Bring out', 'your dead!']
(E)nqueue
(D)equeue
(V)iew
(Q)uit
Enter choice: d
You picked: [d]
Removed [ 'Bring out' ]
(E)nqueue
(D)equeue
(V)iew
(Q)uit


Enter choice: d
You picked: [d]
Removed [ 'your dead!' ]
(E)nqueue
(D)equeue
(V)iew
(Q)uit
Enter choice: d
You picked: [d]
Cannot dequeue from empty queue!
(E)nqueue
(D)equeue
(V)iew
(Q)uit
Enter choice: ^D You picked: [q]
6.16     元组
实际上元组是跟列表非常相近的另一种容器类型.元组和列表看起来不同的一点是元组用
的是圆括号而列表用的是方括号。而功能上,元组和列表相比有一个很重要的区别,元组是一种
不可变类型.正因为这个原因,元组能做一些列表不能做的事情... 用做一个字典的 key.另外当
处理一组对象时,这个组默认是元组类型.
通常情况下,我们会先介绍可用于大部分对象的操作符和内建函数,然后是介绍针对序列类
型的, 最后是总结一下仅适用于元组类型的操作符和内建函数.不过,由于元组类型跟列表类型
有着如此多的共同之处,按照这种讲法我们会重复非常多的上一节的内容.为了避免太多重复信
息,我们会讲解元组和列表在应用于每一组操作符和内建函数上时的区别,然后讨论一下元组的
不变性以及其他独特的特性.


如何创建一个元组并给它赋值
创建一个元组并给他赋值实际上跟创建一个列表并给它赋值完全一样,除了一点,只有一个
元素的元组需要在元组分割符里面加一个逗号(,)用以防止跟普通的分组操作符混淆.不要忘了
它是一个工厂方法!
>>> aTuple = (123, 'abc', 4.56, ['inner', 'tuple'], 7-9j)
>>> anotherTuple = (None, 'something to see here')
>>> print aTuple
(123, 'abc', 4.56, ['inner', 'tuple'], (7-9j))
>>> print anotherTuple
(None, 'something to see here')
>>> emptiestPossibleTuple = (None,)
>>> print emptiestPossibleTuple
(None,)
>>> tuple('bar')
('b', 'a', 'r')
如何访问元组中的值
元组的切片操作跟列表一样,用方括号作为切片操符([]),里面写上索引值或者索引范围.
>>> aTuple[1:4]
('abc', 4.56, ['inner', 'tuple'])
>>> aTuple[:3]
(123, 'abc', 4.56)
>>> aTuple[3][1]
'tuple'
如何更新元组
跟数字和字符串一样,元组也是不可变类型,就是说你不能更新或者改变元组的元素,在 6.2
和 6.3.2 节里面,我们是通过现有字符串的片段再构造一个新字符串的方式解决的,对元组同样


需要这样.
>>> aTuple = aTuple[0], aTuple[1], aTuple[-1]
>>> aTuple
(123, 'abc', (7-9j))
>>> tup1 = (12, 34.56)
>>> tup2 = ('abc', 'xyz')
>>> tup3 = tup1 + tup2
>>> tup3
(12, 34.56, 'abc', 'xyz')
如何移除一个元组的元素以及元组本身
删除一个单独的元组元素是不可能的,当然,把不需要的元素丢弃后, 重新组成一个元组是
没有问题的.
要显示地删除一整个元组,只要用 del 语句减少对象引用计数.当这个引用计数达到 0 的时
候,该对象就会被析构.记住,大多数时候,我们不需要显式的用 del 删除一个对象,一出它的作
用域它就会被析构,Python 编程里面用到显式删除元组的情况非常之少.
del aTuple
6.17    元组操作符和内建函数
6.17.1     标准类型操作符,序列类型操作符和内建函数.
元组的对象和序列类型操作符还有内建函数跟列表的完全一样.你仍然可以对元组进行切
片操作,合并操作,以及多次拷贝一个元组,还可以检查一个对象是否属于一个元组,进行元组之
间的比较等.
创建,重复,连接操作
>>> t = (['xyz', 123], 23, -103.4)
>>> t


(['xyz', 123], 23, -103.4)
>>> t * 2
(['xyz', 123], 23, -103.4, ['xyz', 123], 23, -103.4)
>>> t = t + ('free', 'easy')
>>> t
(['xyz', 123], 23, -103.4, 'free', 'easy')
成员关系操作,切片操作
>>> 23 in t
True
>>> 123 in t
False
>>> t[0][1]
123
>>> t[1:]
(23, -103.4, 'free', 'easy')
内建函数
>>> str(t)
(['xyz', 123], 23, -103.4, 'free', 'easy')
>>> len(t)
5
>>> max(t)
'free'
>>> min(t)
-103.4
>>> cmp(t, (['xyz', 123], 23, -103.4, 'free', 'easy'))
0
>>> list(t)
[['xyz', 123], 23, -103.4, 'free', 'easy']
操作符
>>> (4, 2) < (3, 5)


False
>>> (2, 4) < (3, -1)
True
>>> (2, 4) == (3, -1)
False
>>> (2, 4) == (2, 4)
True
6.17.2     元组类型操作符和内建函数,内建方法
像列表一样 元组也没有它自己专用的运算符和内建函数.上一节中描述的列表方法都跟列
表对象的可变性有关,比如说排序,替换,添加等等,因为元组是不可变的,所以这些操作对元组
来说就是多余的,这些方法没有被实现.
6.18    元组的特殊特性.
6.18.1     不可变性给元组带来了什么影响?
是的,我们在好多地方使用到了"不可变性"这个单词,除了这个词的计算机学科定义和实现,
从应用的角度来考虑,这个词的底线是什么?一个数据类型成为不可变的到底意味着什么?
在三个标准不可变类型里面--数字,字符串和元组字符串--元组是受到影响最大的,一个数
据类型是不可变的,简单来讲,就意味着一旦一个对象被定义了,它的值就不能再被更新,除非重
新创建一个新的对象.对数字和字符串的影响不是很大,因为它们是标量类型,当它们代表的值
改变时,这种结果是有意义的,是按照你所想要的方式进行访问的,而对于元组,事情就不是
这样了。
因为元组是容器对象,很多时候你想改变的只是这个容器中的一个或者多个元素,不幸的
是这是不可能的,切片操作符不能用作左值进行赋值。这和字符串没什么不同,切片操作只能
用于只读的操作。
不可变并不是坏事,比如我们把数据传给一个不了解的 API 时,可以确保我们的数据不会
被修改。同样地,如果我们操作从一个函数返回的元组,可以通过内建 list()函数把它转换成
一个列表.


6.18.2     元组也不是那么“不可变”
虽然元组是被定义成不可变的,但这并不影响它的灵活性。元组并不像我们想的那么不可
变,这是什么意思?其实元组几个特定的行为让它看起来并不像我们先前声称的那么不可变.
比如说,既然我们可以把字符串组合在一起形成一个大字符串。那么把元组组合在一起形
成一个大的元组也没什么不对,所以,连接操作可用,这个操作一点都没有改变那些小元组。
我们所作的是把它们的元素结合在一起.这里有几个例子:
>>> s = 'first'
>>> s = s + ' second'
>>> s
'first second'
>>>
>>> t = ('third', 'fourth')
>>> t
('third', 'fourth')
>>>
>>> t = t + ('fifth', 'sixth')
>>> t
('third', 'fourth', 'fifth', 'sixth')
同样的概念也适用于重复操作。重复操作只不过是多次复制同样的元素,再有,我们前面
提到过可以用一个简单的函数调用把一个元组变成一个可变的列表。我们的最后一个特性可能
会吓到你。你可以“修改”特定的元组元素,哇!这意味着什么?
虽然元组对象本身是不可变的,但这并不意味着元组包含的可变对象也不可变了。
>>> t = (['xyz', 123], 23, -103.4)
>>> t
(['xyz', 123], 23, -103.4)
>>> t[0][1]
123
>>> t[0][1] = ['abc', 'def']
>>> t


(['xyz', ['abc', 'def']], 23, -103.4)
在上面的例子中,虽然 t 是一个元组类型变量,但是我们设法通过替换它的第一个元素(一
个列表对象)的项来“改变”了它。我们替换了 t[0][1],原来是个整数,我们把它替换成了一
个列表对象 ['abc','def'].虽然我们只是改变了一个可变对象,但在某种意义上讲,我们也“改
变”了我们的元组类型变量。
6.18.3     默认集合类型
所有的多对象的,逗号分隔的,没有明确用符号定义的,比如说像用方括号表示列表和用
圆括号表示元组一样,等等这些集合默认的类型都是元组,下面是一个简单的示例:
>>> 'abc', -4.24e93, 18+6.6j, 'xyz'
('abc', -4.24e+093, (18+6.6j), 'xyz')
>>>
>>> x, y = 1, 2
>>> x, y
(1, 2)
所有函数返回的多对象(不包括有符号封装的)都是元组类型。注意,有符号封装的多对
象集合其实是返回的一个单一的容器对象,比如:
def foo1():
:
return obj1, obj2, obj3
def foo2():
:
return [obj1, obj2, obj3]
def foo3():
:
return (obj1, obj2, obj3)


上面的例子中,foo1()返回 3 个对象,默认的作为一个包含 3 个对象的元组类型,foo2()
返回一个单一对象,一个包含 3 个对象的列表,还有 foo3()返回一个跟 foo1()相同的对象.唯一
不同的是这里的元组是显式定义的.
为了避免令人讨厌的副作用,建议总是显式的用圆括号表达式表示元组或者创建一个元组.
>>> 4, 2 < 3, 5 # int, comparison, int
(4, True, 5)
>>> (4, 2) < (3, 5) # tuple comparison
False
在第一个例子中小于号的优先级高于逗号,2<3 的结果成了元组变量的第二个元素,适当
的封装元组就会得到希望得到的结果.
6.18.4      单元素元组
曾经试过创建一个只有一个元素的元组?你在列表上试过,它可以完成,但是无论你怎么
在元组上试验,你都不能得到想要的结果。
>>> ['abc']
['abc']
>>> type(['abc']) # a list
<type 'list'>
>>>
>>> ('xyz')
'xyz'
>>> type(('xyz')) # a string, not a tuple
<type 'str'>
或许你忘记了圆括号被重载了,它也被用作分组操作符。由圆括号包裹的一个单一元素首
先被作为分组操作,而不是作为元组的分界符。一个变通的方法是在第一个元素后面添一个逗
号(,)来表明这是一个元组而不是在做分组操作.
>>> ('xyz',)


('xyz',)
6.18.5    字典的关键字
不可变对象的值是不可改变的。这就意味着它们通过 hash 算法得到的值总是一个值。这是
作为字典键值的一个必备条件。在下一章节里面我们会讨论到,键值必须是可哈希的对象,元
组变量符合这个标准,而列表变量就不行。
核心笔记:列表 VS 元组
一个经常会被问到的问题是,"为什么我们要区分元组和列表变量?"这个问题也可以被表
述为“我们真的需要两个相似的序列类型吗?”,一个原因是在有些情况下,使用其中的一种类
型要优于使用另一种类型。
最好使用不可变类型变量的一个情况是,如果你在维护一些敏感的数据,并且需要把这些
数据传递给一个并不了解的函数(或许是一个根本不是你写的 API),作为一个只负责一个软件
某一部分的工程师,如果你确信你的数据不会被调用的函数篡改,你会觉得安全了许多。
一个需要可变类型参数的例子是,如果你在管理动态数据集合时。你需要先把它们创建出
来,逐渐地或者不定期的添加它们,或者有时还要移除一些单个的元素。这是一个必须使用可
变类型对象的典型例子。幸运的是,通过内建的 list()和 tuple()转换函数,你可以非常轻松
的在两者之间进行转换.
list()和 tuple()函数允许你用一个列表来创建一个元组,反之亦然.如果你有一个元组变
量,但你需要一个列表变量因为你要更新一下它的对象,这时 list()函数就是你最好的帮手.如
果你有一个列表变量,并且想把它传递给一个函数,或许一个 API,而你又不想让任何人弄乱你
的数据,这时 tuple()函数就非常有用。
6.19    相关模块
表 6.12 列出了与序列类型相关的关键模块,这个列表包含了前面我们间接提到的数组模块,
它就像列表类型,不过它要求所有的元素都是同一类型。copy 模块(可以参考下面的 6.20 节)
负责处理对象的浅拷贝和深拷贝。
Table 6.12 与序列类型相关的模块
模块          内容


数组          一种受限制的可变序列类型,要求所有的元素必须都是相同的类型。
copy        提供浅拷贝和深拷贝的能力(详见 6.20)
operator      包含函数调用形式的序列操作符,比如 operator.concat(m,n)就相当于连
接操作(m+n)。
re            Perl 风格的正则表达式查找(和匹配);见第 15 章
StringIO/
cStringIO      把长字符串作为文件来操作,比如 read(),seek()函数等,C 版的更快一些,
但是它不能被继承.
a
Textwrap     用作包裹/填充文本的函数,也有一个类
types          包含 Python 支持的所有类型
b
collections 高性能容器数据类型
a. Python2.3 新加
b. Python2.4 新加
operator 模块除了提供与数字操作符相同的功能外,还提供了与序列类型操作符相同的
功能.types 模块是代表 python 支持的全部类型的 type 对象的引用。最后,UserList 模块包
含了 list 对象的完全的类实现。因为 Python 类型不能作为子类,所以这个模块允许用户获得
类似 list 的类,也可以派生出新的类或功能。如果你熟悉面向对象编程的话,我们强烈推荐你
阅读第 13 章
6.20     拷贝 Python 对象
浅拷贝和深拷贝
在前面的 3.5 节里面我们讲过对象赋值实际上是简单的对象引用。也就是说当你创建一个
对象,然后把它赋给另一个变量的时候,Python 并没有拷贝这个对象,而是拷贝了这个对象的
引用。
比如,假设你想创建一对小夫妻的通用档案,名为 person.然后你分别为他俩拷贝一份。
在下面的例子中,我们展示了两种拷贝对象的方式,一种使用了切片操作,另一种用了工厂方
法,为了区分出三个不同的对象,我们使用 id()内建函数来显示每个对象的标识符。(我们还
可以用 is 操作符来做相同的事情)


>>> person = ['name', ['savings', 100.00]]
>>> hubby = person[:] # slice copy
>>> wifey = list(person) # fac func copy
>>> [id(x) for x in person, hubby, wifey]
[11826320, 12223552, 11850936]
为他们创建了初始有$100 的个人存款帐户。用户名改为定制的名字。但是,当丈夫取走$50
后,他的行为影响到了他妻子的账户,虽然我们进行了分开的拷贝作(当然,前提是我们希望他
们每个人都拥有自己单独的帐号,而不是一个单一的联合帐号。)为什么会这样呢?
>>> hubby[0] = 'joe'
>>> wifey[0] = 'jane'
>>> hubby, wifey
(['joe', ['savings', 100.0]], ['jane', ['savings', 100.0]])
>>> hubby[1][1] = 50.00
>>> hubby, wifey
(['joe', ['savings', 50.0]], ['jane', ['savings', 50.0]])
原因是我们仅仅做了一个浅拷贝。对一个对象进行浅拷贝其实是新创建了一个类型跟原对
象一样,其内容是原来对象元素的引用,换句话说,这个拷贝的对象本身是新的,但是它的内容不
是.序列类型对象的浅拷贝是默认类型拷贝,并可以以下几种方式实施:(1)完全切片操作[:],(2)
利用工厂函数,比如 list(),dict()等,(3)使用 copy 模块的 copy 函数.
你的下一个问题可能是:当妻子的名字被赋值,为什么丈夫的名字没有受到影响?难道它们
的名字现在不应该都是'jane'了吗?为什么名字没有变成一样的呢?怎么会是这样呢?这是因为
在这两个列表的两个对象中,第一个对象是不可变的(是个字符串类型),而第二个是可变的(一
个列表).正因为如此,当进行浅拷贝时,字符串被显式的拷贝,并新创建了一个字符串对象,而列
表元素只是把它的引用复制了一下,并不是它的成员.所以改变名字没有任何问题,但是更改他
们银行账号的任何信息都会引发问题.现在,让我们分别看一下每个列表的元素的对象 ID 值,注
意,银行账号对象是同一个对象,这也是为什么对一个对象进行修改会影响到另一个的原因.注
意在我们改变他们的名字后,新的名字字符串是如何替换原有'名字'字符串的.


BEFORE:
>>> [id(x) for x in hubby]
[9919616, 11826320]
>>> [id(x) for x in wifey]
[9919616, 11826320]
AFTER:
>>> [id(x) for x in hubby]
[12092832, 11826320]
>>> [id(x) for x in wifey]
[12191712, 11826320]
假设我们要给这对夫妻创建一个联合账户,那这是一个非常棒的方案,但是,如果需要的是
两个分离账户,就需要作些改动了.要得到一个完全拷贝或者说深拷贝--创建一个新的容器对象,
包含原有对象元素(引用)全新拷贝的引用--需要 copy.deepcopy()函数.我们使用深拷贝来重
写整个例子.
>>> person = ['name', ['savings', 100.00]]
>>> hubby = person
>>> import copy
>>> wifey = copy.deepcopy(person)
>>> [id(x) for x in person, hubby, wifey]
[12242056, 12242056, 12224232]
>>> hubby[0] = 'joe'
>>> wifey[0] = 'jane'
>>> hubby, wifey
(['joe', ['savings', 100.0]], ['jane', ['savings', 100.0]])
>>> hubby[1][1] = 50.00
>>> hubby, wifey
(['joe', ['savings', 50.0]], ['jane', ['savings', 100.0]])
这就是我们想要的方式,作为验证,让我们确认一下所有四个对象都是不同的.
>>> [id(x) for x in hubby]
[12191712, 11826280]


>>> [id(x) for x in wifey]
[12114080, 12224792]
以下有几点关于拷贝操作的警告。第一,非容器类型(比如数字,字符串和其他"原子"类型的
对象,像代码,类型和 xrange 对象等)没有被拷贝一说,浅拷贝是用完全切片操作来完成的.第二,
如果元组变量只包含原子类型对象,对它的深拷贝将不会进行.如果我们把账户信息改成元组类
型,那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝:
>>> person = ['name', ('savings', 100.00)]
>>> newPerson = copy.deepcopy(person)
>>> [id(x) for x in person, newPerson]
[12225352, 12226112]
>>> [id(x) for x in person]
[9919616, 11800088]
>>> [id(x) for x in newPerson]
[9919616, 11800088]
核心模块: copy
我们刚才描述的浅拷贝和深拷贝操作都可以在 copy 模块中找到.其实 copy 模块中只有两
个函数可用:copy()进行浅拷贝操作,而 deepcopy()进行深拷贝操作.
6.21    序列类型小结
序列类型为数据的顺序存储提供了几种机制.字符串是最常用的数据载体,无论是用于给用
户显示,存贮到硬盘,通过网络传输,还是作为一个多源信息的容器.列表和元组提供了容器存储
能力,允许简单的操作和访问多个对象,无论它们是 Python 的对象还是用户自定义的对象.单一
元素或一组元素可以通过持续有序地索引偏移进行切片操作来访问.总之,这些数据类型为你的
Python 开发环境提供了灵活而易用的存贮工具.我们用表 6.13--序列类型的操作符,内建函数
和方法的摘要列表来总结本章.


Table 6.13 序列类型操作符,内建函数和方法


























6.22    练习
6–1.    字符串.string 模块中是否有一种字符串方法或者函数可以帮我鉴定一下一个字符串
是否是另一个大字符串的一部分?
6–2.    字符串标识符.修改例 6-1 的 idcheck.py 脚本,使之可以检测长度为一的标识符,并且
可以识别 Python 关键字,对后一个要求,你可以使用 keyword 模块(特别是 keyword.kelist)来帮你.
6–3.    排序
(a) 输入一串数字,从大到小排列之.
(b) 跟 a 一样,不过要用字典序从大到小排列之.
6–4.    算术. 更新上一章里面你的得分测试练习方案,把测试得分放到一个列表中去.你的代
码应该可以计算出一个平均分,见练习 2-9 和练习 5-3.
6–5.    字符串
(a)更新你在练习 2-7 里面的方案,使之可以每次向前向后都显示一个字符串的一个字符.
(b)通过扫描来判断两个字符串是否匹配(不能使用比较操作符或者 cmp()内建函数)。附加题:


在你的方案里加入大小写区分.
(c)判断一个字符串是否重现(后面跟前面的一致).附加题:在处理除了严格的回文之外,加入对
例如控制符号和空格的支持。
(d)接受一个字符,在其后面加一个反向的拷贝,构成一个回文字符串.
6–6.     字符串.创建一个 string.strip()的替代函数:接受一个字符串,去掉它前面和后面的
空格(如果使用 string.*strip()函数那本练习就没有意义了)
6–7.     调试.看一下在例 6.5 中给出的代码(buggy.py)
(a)研究这段代码并描述这段代码想做什么.在所有的(#)处都要填写你的注释.
(b)这个程序有一个很大的问题,比如输入 6,12,20,30,等它会死掉,实际上它不能处理任何的偶
数,找出原因.
(c)修正(b)中提出的问题.
6–8.     列表.给出一个整数值,返回代表该值的英文,比如输入 89 返回"eight-nine"。附加题:
能够返回符合英文语法规则的形式,比如输入“89”返回“eighty-nine”。本练习中的值限定在家 0
到 1,000.
6–9.    转换.为练习 5-13 写一个姊妹函数, 接受分钟数, 返回小时数和分钟数. 总时间不
变,并且要求小时数尽可能大.
6–10.字符串.写一个函数,返回一个跟输入字符串相似的字符串,要求字符串的大小写反转.
比如,输入"Mr.Ed",应该返回"mR.eD"作为输出.
Example 6.4 有 bug 的程序(buggy.py)
这是一个用于练习 6-7 的程序,判断这个程序是干什么的,在"#"处添加你的注释,找出其中的错
误,并修改之.
1 #!/usr/bin/env python
2
3 #
4 num_str = raw_input('Enter a number: ')
5
6 #
7 num_num = int(num_str)
8
9#
10 fac_list = range(1, num_num+1)
11 print "BEFORE:", 'fac_list'


12
13 #
14 i = 0
15
16 #
17 while i < len(fac_list):
18
19 #
20 if num_num % fac_list[i] == 0:
21 del fac_list[i]
22
23 #
24 i = i + 1
25
26 #
27 print "AFTER:", 'fac_list'
6–11.转换
(a)创建一个从整数到 IP 地址的转换程序,如下格式: WWW.XXX.YYY.ZZZ.
(b)更新你的程序,使之可以逆转换.
6–12.字符串
(a)创建一个名字为 findchr()的函数,函数声明如下:
def findchr(string, char)
findchr()要在字符串 string 中查找字符 char,找到就返回该值的索引,否则返回-1.不能用
string.*find()或者 string.*index()函数和方法
(b)创建另一个叫 rfindchr()的函数,查找字符 char 最后一次出现的位置.它跟 findchr()工作
类似,不过它是从字符串的最后开始向前查找的.
(c)创建第三个函数,名字叫 subchr(),声明如下:
def subchr(string, origchar, newchar)
subchr()跟 findchr()类似,不同的是,如果找到匹配的字符就用新的字符替换原先字符.返回
修改后的字符串.
6–13.字符串.string 模块包含三个函数,atoi(),atol(),和 atof(),它们分别负责把字符串转
换成整数,长整型,和浮点型数字.从 Python1.5 起,Python 的内建函数 int(),long(),float()也可以
做相同的事了, complex()函数可以把字符串转换成复数.(然而 1,5 之前,这些转换函数只能工作于
数字之上)
string 模块中并没有实现一个 atoc()函数,那么你来实现一个,atoc(),接受单个字符串做参
数输入,一个表示复数的字符串,例如,'-1.23e+4-5.67j',返回相应的复数对象.你不能用 eval()函
数,但可以使用 complex()函数,而且你只能在如下的限制之下使用 complex():complex(real,imag)


的 real 和 imag 都必须是浮点值.
6–14.随机数.设计一个"石头,剪子,布"游戏,有时又叫"Rochambeau",你小时候可能玩过,下面
是规则.你和你的对手,在同一时间做出特定的手势,必须是下面一种手势:石头,剪子,布.胜利者从
下面的规则中产生,这个规则本身是个悖论.
(a) the paper covers the rock,
布包石头.
(b)石头砸剪子,
(c)剪子剪破布.在你的计算机版本中,用户输入她/他的选项,计算机找一个随机选项,然后由你
的程序来决定一个胜利者或者平手.注意:最好的算法是尽量少的使用 if 语句.
6–15.转换
(a)给出两个可识别格式的日期,比如 MM/DD/YY 或者 DD/MM/YY 格式,计算出两个日期间的天
数.
(b)给出一个人的生日,计算从此人出生到现在的天数,包括所有的闰月.
(c)还是上面的例子,计算出到此人下次过生日还有多少天.
6–16.矩阵.处理矩阵 M 和 N 的加和乘操作.
6–17.方法.实现一个叫 myPop()的函数,功能类似于列表的 pop()方法,用一个列表作为输入,
移除列表的最新一个元素,并返回它.
6–18. zip() 内建函数       在 6.13.2 节里面关于 zip()函数的例子中,zip(fn,ln)返回的是什么?
6–19.多列输出.有任意项的序列或者其他容器,把它们等距离分列显示.由调用者提供数据和
输出格式.例如,如果你传入 100 个项并定义 3 列输出,按照需要的模式显示这些数据.这种情况下,应
该是两列显示 33 个项,最后一列显示 34 个.你可以让用户来选择水平排序或者垂直排序.


映射和集合类型 
本章主题
z 映射类型: 字典
z 操作符
z 内建函数
z 内建方法
z 字典的键
z 集合类型
z 操作符
z 内建函数
z 内建方法
z 相关模块


本章中,我们来讨论 Python 语言中的映射类型和集合类型。和前面的章节一样,我们首先做一
个介绍,然后在来讨论可用操作符,工厂函数、内建函数(BIF)和方法。然后我们再来看看每种数据
类型的详细用法。
7.1 映射类型:字典
字典是 Python 语言中唯一的映射类型。映射类型对象里哈希值(键) 和指向的对象(值)是一对
多的关系。 它们与 Perl 中的哈希类型(译者注:又称关联数组)相似,通常被认为是可变的哈希表。
一个字典对象是可变的,它是一个容器类型,能存储任意个数的 Python 对象,其中也包括其他容器
类型。字典类型和序列类型容器类(列表、元组)的区别是存储和访问数据的方式不同。序列类型只
用数字类型的键(从序列的开始起按数值顺序索引)。映射类型可以用其他对象类型做键;一般最常
见的是用字符串做键(keys)。和序列类型的键不同,映射类型的键(keys)直接,或间接地和存储的
数据值相关联。但因为在映射类型中,我们不再用"序列化排序"的键(keys),所以映射类型中的数据
是无序排列的。
显然,这并不影响我们使用映射类型,因为映射类型不要求用数字值做索引以从一个容器中获
取对应的数据项。你可以用键(key)直接 "映射" 到值, 这就是为什么叫映射类型(“mapping type”)
的原因。映射类型通常被称做哈希表的原因是字典对象就是哈希类型的。字典是 Python 中最强大的
数据类型之一。
核心笔记:什么是哈希表?它们与字典的关系是什么?
序列类型用有序的数字键做索引将数据以数组的形式存储。一般,索引值与所存储的数据毫无
关系。还可以用另一种方式来存储数据:基于某种相关值,比如说一个字符串。我们在日常生活中


一直这么做。你把人们的电话号码按照他们的姓记录在电话簿上,你按照时间在日历或约会簿上添
加事件,等等。在这些例子中,你的键(key)就是和数据项相关的值。
哈希表是一种数据结构:它按照我们所要求的去工作。哈希表中存储的每一条数据,叫做一个
值(value),是根据与它相关的一个被称作为键(key)的数据项进行存储的。键和值合在一起被称为
“键-值 对”(key-value pairs)。 哈希表的算法是获取键,对键执行一个叫做哈希函数的操作,
并根据计算的结果,选择在数据结构的某个地址中来存储你的值。任何一个值存储的地址皆取决于
它的键。正因为这种随意性,哈希表中的值是没有顺序的。你拥有的是一个无序的数据集。
你所能获得的有序集合只能是字典中的键的集合或者值的集合。方法 Keys() 或 values() 返回
一个列表,该列表是可排序的。 你还可以用 items()方法得到包含键、值对的元组的列表来排序。
由于字典本身是哈希的,所以是无序的。
哈希表一般有很好的性能, 因为用键查询相当快。
Python 的字典是作为可变的哈希表实现的。如果你熟悉 Perl 的话, 就可以发现字典与 Perl 中
的"关系数组"或散列相似。
现在我们就来研究 Python 字典。一个字典条目的语法格式是 键:值。 而且,多条字典条目
被包含在( { } ) 里。
如何创建字典和给字典赋值
创建字典只需要把字典赋值给一个变量,不管这个字典是否包含元素:
>>> dict1 = {}
>>> dict2 = {'name': 'earth', 'port': 80}
>>> dict1, dict2
({}, {'port': 80, 'name': 'earth'})
从 Python 2.2 版本起, 可以用工厂方法 dict() 来创建字典。 当我们详细讨论 dict()的时候
会看到更多的例子,现在来看一个小例子:
>>> fdict = dict((['x', 1], ['y', 2]))
>>> fdict
{'y': 2, 'x': 1}
从 Python 2.3 版本起, 可以用一个很方便的内建方法 fromkeys() 来创建一个"默认"字典, 字
典中元素具有相同的值 (如果没有给出, 默认为 None):
>>> ddict = {}.fromkeys(('x', 'y'), -1)
>>> ddict
{'y': -1, 'x': -1}


>>>
>>> edict = {}.fromkeys(('foo', 'bar'))
>>> edict
{'foo': None, 'bar': None}
如何访问字典中的值
要想遍历一个字典(一般用键), 你只需要循环查看它的键, 像这样:
>>> dict2 = {'name': 'earth', 'port': 80}
>>>
>>>> for key in dict2.keys():
... print 'key=%s, value=%s' % (key, dict2[key])
...
key=name, value=earth
key=port, value=80
从 Python 2.2 开始, 你可以不必再用 keys()方法获取供循环使用的键值列表了。 可以
用迭代器来轻松地访问类序列对象(sequence-like objects),比如字典和文件。只需要用字
典的名字就可以在 for 循环里遍历字典。
>>> dict2 = {'name': 'earth', 'port': 80}
>>>
>>>> for key in dict2:
... print 'key=%s, value=%s' % (key, dict2[key])
...
key=name, value=earth
key=port, value=80
要得到字典中某个元素的值, 可以用你所熟悉的字典键加上中括号来得到:
>>> dict2['name']
'earth'
>>>
>>> print 'host %s is running on port %d' % \
... (dict2['name'], dict2['port'])
host earth is running on port 80
字典 dict1 是空的,字典 dict2 有两个数据元素。字典 dict2 的键是 'name' 和 'port',它们
对应的值分别是'earth' 和 80。就像你看到的,通过键'name'可以得到字典中的元素的值。


如果我们想访问该字典中的一个数据元素,而它在这个字典中没有对应的键,将会产生一个错
误:
>>> dict2['server'] Traceback (innermost last):
File "<stdin>", line 1, in ?
KeyError: server
在这个例子中,我们试图获得字典中'server'键所对应的值。你从上面的代码知道,'server'
这个键并不存在。检查一个字典中是否有某个键的最好方法是用字典的 has_key()方法, 或者另一
种比较好的方法就是从 2.2 版本起用的,in 或 not in 操作符。 has_key() 方法将会在未来的
Python 版本中弃用,所以用 in 或 not in 是最好的方法。
下面我们将介绍字典所有的方法。方法 has_key()和 in 以及 not in 操作符都是布尔类型的。
对于前两者而言,如果字典中有该键就返回真(True),否则返回假(False)。(Python 2.3 版本以前,
没有布尔常量,为真时返回 1,假时返回 0。)
>>> 'server' in dict2 # 或 dict2.has_key('server')
False
>>> 'name' in dict # 或 dict2.has_key('name')
True
>>> dict2['name']
'earth'
一个字典中混用数字和字符串的例子:
>>> dict3 = {}
>>> dict3[1] = 'abc'
>>> dict3['1'] = 3.14159
>>> dict3[3.2] = 'xyz'
>>> dict3
{3.2: 'xyz', 1: 'abc', '1': 3.14159}
除了逐一地添加每个键-值对外,我们也可以给 dict3 整体赋值。
dict3 = {3.2: 'xyz', 1: 'abc', '1': 3.14159}
如果事先已经知道所有的数据就可以用键-值对来创建一个字典(这是显而易见的)。通过字典
dict3 的示例说明你可以采用各种类型的数据作为字典的键。如果我们被问到是否可以改变某个字典


值的键(key) 时,你可能会说,“不”,对吗?
为什么在执行中字典中的键不允许被改变呢?你这样想就会明白: 比方说, 你创建了一个字
典,字典中包含一个元素(一个键和一个值)。可能是由于某个变量的改变导致键发生了改变。这时
候你如果用原来的键来取出字典里的数据,会得到 KeyError(因为键的值已经改变了),现在你没办
法从字典中获取该值了,因为键本身的值发生了变化。由于上面的原因,字典中的键必须是可哈希
的, 所以数字和字符串可以作为字典中的键, 但是列表和其他字典不行。(见 7.5.2 小节 字典的
键必须是可哈希的)
如何更新字典
你可以通过以下几种方式对一个字典做修改:添加一个新数据项或新元素(即,一个键-值对);
修改一个已存在的数据项;或删除一个已存在的数据项(下面有关于数据项删除操作的详细讲述).
>>> dict2['name'] = 'venus' # 更新已有条目
>>> dict2['port'] = 6969 # 更新已有条目
>>> dict2['arch'] = 'sunos5'# 增加新条目
>>>
>>> print 'host %(name)s is running on port %(port)d' %dict2
host venus is running on port 6969
如果字典中该键已经存在,则字典中该键对应的值将被新值替代。上面的 print 语句展示了另
一种在字典中使用字符串格式符( %)的方法。用字典参数可以简化 print 语句,因为这样做你只须
用到一次该字典的名字,而不用在每个元素出现的时候都用元组参数表示。
你也可以用内建方法 update()将整个字典的内容添加到另一个字典。我们将在 7.4 节介绍此
方法。
如何删除字典元素和字典
删除整个字典的操作不常见。通常,你删除字典中的单个元素或是清除整个字典的内容。但是,
如果你真想"删除"一个字典,用 del 语句 (介绍见小节 3.5.5)。 以下是删除字典和字典元素的例
子。
del dict2['name']  # 删除键为“name”的条目
dict2.clear()      # 删除 dict2 中所有的条目
del dict2          # 删除整个 dict2 字典
dict2.pop('name')   # 删除并返回键为“name”的条目


核心笔记:避免使用内建对象名字作为变量的标识符
如果在 Python 2.3 前,你已经开始使用 Python,你可能用 dict 作为一个字典的标识符。但是,
因为 dict() 现在已成为 Python 的类型和工厂方法,重载 dict()会给你带来麻烦和潜在的 bugs。
编译器允许你做这样的重载,它认为你是聪明的,知道自己正在做什么!小心。请不要用 dict, list,
file, bool, str, input, len 这样的内建类型为变量命名。
7.2 映射类型操作符
字典可以和所有的标准类型操作符一起工作,但却不支持像拼接(concatenation)和重复
(repetition)这样的操作。这些操作对序列有意义,可对映射类型行不通。在接下来的两小节里,
我们将向你讲述字典中的操作符。
7.2.1 标准类型操作符
标准类型操作符已在第四章介绍。 下面是一些使用操作符的简单示例:
>>> dict4 = {'abc': 123}
>>> dict5 = {'abc': 456}
>>> dict6 = {'abc': 123, 98.6: 37}
>>> dict7 = {'xyz': 123}
>>> dict4 < dict5
True
>>> (dict4 < dict6) and (dict4 < dict7)
True
>>> (dict5 < dict6) and (dict5 < dict7)
True
>>> dict6 < dict7
False
字典是如何比较的呢? 与列表和元组一样,这个过程比数字和字符串的比较更复杂些。详细
算法请见第 7.3.1 小节。
7.2.2 映射类型操作符
字典的键查找操作符([ ])
键查找操作符是唯一仅用于字典类型的操作符,它和序列类型里单一元素的切片(slice)操作符
很相象。对序列类型来说,用索引做唯一参数或下标(subscript)以获取一个序列中某个元素的值。


对字典类型来说,是用键(key)查询(字典中的元素),所以键是参数(argument), 而不是一个索引
(index)。键查找操作符既可以用于给字典赋值,也可以用于从字典中取值:
d[k] = v     通过键'k',给字典中某元素赋值'v'
d[k]         通过键'k',查询字典中某元素的值
(键)成员关系操作( in ,not in)
从 Python 2.2 起,程序员可以不用 has_key()方法,而用 in 和 not in 操作符来检查某个键
是否存在于字典中:
>>> 'name' in dict2
True
>>> 'phone' in dict2
False
7.3 映射类型的内建函数和工厂函数
7.3.1 标准类型函数[type()、str()和 cmp()]
如你所料,对一个字典调用 type()工厂方法,会返回字典类型, “<type 'dict'>”. 调用
str()工厂方法将返回该字典的字符串表示形式,这些都很容易理解。
在前面的三个章节里,我们已经讲述了用 cmp() 内建函数来操作数字、字符串、列表和元组。
那么字典又是如何比较的呢? 字典是通过这样的算法来比较的: 首先是字典的大小,然后是键,最
后是值。可是,用 cmp() 做字典的比较一般不是很有用。
接下来的小节里,将进一步详细说明字典比较的算法,但这部分是高层次的阅读内容,可以跳
过,因为字典的比较不是很有用也不常见。
*字典比较算法
接下来的例子中,我们建立两个字典进行比较,然后慢慢修改,来看看这些修改对它们之间的
比较带来的影响:
>>> dict1 = {}
>>> dict2 = {'host': 'earth', 'port': 80}
>>> cmp(dict1, dict2)
-1


>>> dict1['host'] = 'earth'
>>> cmp(dict1, dict2)
-1
在第一个比较中,dict1 比 dict2 小,因为 dict2 有更多元素(2 个 vs. 0 个)。在向 dict1 添
加一个元素后,dict1 仍然比 dict2 小 (2 vs. 1),虽然添加的元素在 dict2 中也存在。
>>> dict1['port'] = 8080
>>> cmp(dict1, dict2)
1
>>> dict1['port'] = 80
>>> cmp(dict1, dict2)
0
在向 dict1 中添加第二个元素后,两个字典的长度相同,所以用键比较大小。这时键相等,则
通过它们的值比较大小。键 'host'的值相同,对于键 'port',dict1 中值比 dict2 中的值大(8080 vs.
80)。当把 dict2 中'port'的值设成和 dict1 中的值一样,那么两个字典相等:它们有相同的大小、
相同的键、相同的值,所以 cmp() 返回值是 0。
{译者注: 原文有误:dict2 is deemed larger because its value is greater than that of
dict1’s 'port' key (8080 vs. 80). 应为: dict1 is deemed larger because its value is greater
than that of dict2’s 'port' key (8080 vs. 80). }
>>> dict1['prot'] = 'tcp'
>>> cmp(dict1, dict2)
1
>>> dict2['prot'] = 'udp'
>>> cmp(dict1, dict2)
-1
当向两个字典中的任何一个添加新元素时,这个字典马上会成为大的那个字典,就像例子中的
dict1 一样。向 dict2 添加键-值对后,因为两个字典的长度又相等了,会继续比较它们的键和值。
>>> cdict = {'fruits':1}
>>> ddict = {'fruits':1}
>>> cmp(cdict, ddict)
0
>>> cdict['oranges'] = 0
>>> ddict['apples'] = 0
>>> cmp(cdict, ddict)
14


上面的例子表明 cmp()可以返回除-1,0,1 外的其他值。算法按照以下的顺序。
(1)比较字典长度
如果字典的长度不同,那么用 cmp(dict1, dict2) 比较大小时,如果字典 dict1 比 dict2 长,
cmp()返回正值,如果 dict2 比 dict1 长,则返回负值。也就是说,字典中的键的个数越多,这个
字典就越大,即:
len(dict1) > len(dict2) ==> dict1 > dict2
(2)比较字典的键
如果两个字典的长度相同,那就按字典的键比较;键比较的顺序和 keys()方法返回键的顺序相
同。 (注意: 相同的键会映射到哈希表的同一位置,这保证了对字典键的检查的一致性。) 这时,
如果两个字典的键不匹配时,对这两个(不匹配的键)直接进行比较。当 dict1 中第一个不同的键大
于 dict2 中第一个不同的键,cmp()会返回正值。
(3)比较字典的值
如果两个字典的长度相同而且它们的键也完全匹配,则用字典中每个相同的键所对应的值进行
比较。一旦出现不匹配的值,就对这两个值进行直接比较。若 dict1 比 dict2 中相同的键所对应的
值大,cmp()会返回正值。
(4) Exact Match
到此为止,即,每个字典有相同的长度、相同的键、每个键也对应相同的值,则字典完全匹配,
返回 0 值。
图 7-1 说明了上述字典比较的算法


图 7-1 字典是如何进行比较的
7.3.2 映射类型相关的函数
dict()
工厂函数被用来创建字典。如果不提供参数,会生成空字典。当容器类型对象做为一个参数传
递给方法 dict() 时很有意思。如果参数是可以迭代的,即,一个序列,或是一个迭代器,或是一个
支持迭代的对象,那每个可迭代的元素必须成对出现。在每个值对中,第一个元素是字典的键、第
二个元素是字典中的值。见 Python 文档里关于 dict()的例子:
>>> dict(zip(('x', 'y'), (1, 2)))
{'y': 2, 'x': 1}
>>> dict([['x', 1], ['y', 2]])
{'y': 2, 'x': 1}
>>> dict([('xy'[i-1], i) for i in range(1,3)])
{'y': 2, 'x': 1}
如果输入参数是(另)一个映射对象,比如,一个字典对象,对其调用 dict()会从存在的字典里
复制内容来生成新的字典。新生成的字典是原来字典对象的浅复制版本, 它与用字典的内建方法
copy() 生成的字典对象是一样的。但是从已存在的字典生成新的字典速度比用 copy()方法慢,我们
推荐使用 copy()。
从 Python 2.3 开始,调用 dict()方法可以接受字典或关键字参数字典(函数操作符,第 11 章):
>>> dict(x=1, y=2)
{'y': 2, 'x': 1}
>>> dict8 = dict(x=1, y=2)
>>> dict8
{'y': 2, 'x': 1}
>>> dict9 = dict(**dict8)
>>> dict9
{'y': 2, 'x': 1}
我们提醒读者 dict9 的例子只作为了解 dict()方法的用途,它不是现实中的例子。使用下面这
些行的方法更聪明(效率更好):
>>> dict9 = dict8.copy()


>>> dict9
{'y': 2, 'x': 1}
len()
内建函数 len()很灵活。它可用在序列、映射类型和集合上(在本章的后面我们会看到)。对字典
调用 len(),它会返回所有元素(键-值对)的数目:
>>> dict2 = {'name': 'earth', 'port': 80}
>>> dict2
{'port': 80, 'name': 'earth'}
>>> len(dict2)
2
我们前面提到字典中的元素是没有顺序的。从上面的例子中可以看到,dict2 的元素显示的顺序
和输入时的顺序正相反。
hash()
内建函数 hash()本身并不是为字典设计的方法,但它可以判断某个对象是否可以做一个字典的
键。将一个对象作为参数传递给 hash(), 会返回这个对象的哈希值。 只有这个对象是可哈希的,
才可作为字典的键 (函数的返回值是整数,不产生错误或异常)。
如果用比较操作符来比较两个数值,发现它们是相等的,那么即使二者的数据类型不同, 它
们也会得到相同的哈希值。
如果非可哈希类型作为参数传递给 hash()方法,会产生 TypeError 错误(因此,如果使用这样的
对象作为键给字典赋值时会出错):
>>> hash([])
Traceback (innermost last):  File "<stdin>", line 1, in ?
TypeError: list objects are  unhashable
>>>
>>> dict2[{}] = 'foo'
Traceback (most recent call  last): File "<stdin>", line 1, in ?
TypeError: dict objects are  unhashable
在表 7.1 中,我们列出以下三个映射类型的相关函数。
表 7.1      映射类型的相关函数


函数                       操作
dict([container])       创 建 字 典 的 工 厂 函 数 。 如 果 提 供 了 容 器 类 (container) , 就
用其中的条目填充字典,否则就创建一个空字典。
len(mapping)             返回映射的长度(键-值对的个数)
hash(obj)             返回 obj 的哈希值
7.4 映射类型内建方法
字典提供了大量方法来帮你做事情,见表 7.2.
下面,我们说明字典的一些很常见的方法。在上面的例子里,我们已经看到 has_key() 和它的
替代方法 in 和 not in。如我们在 7.1 小节看到,试图查找一个字典里没有的键值会产生 KeyError
异常。
基本的字典方法关注他们的键和值。它们有:keys()方法,返回一个列表,包含字典中所有的
键,values()方法,返回一个列表,包含字典中所有的值,items(), 返回一个包含所有(键, 值)元
组的列表。这些方法在不按任何顺序遍历字典的键或值时很有用。
>>> dict2.keys()
['port', 'name']
>>>
>>> dict2.values()
[80, 'earth']
>>>
>>> dict2.items()
[('port', 80), ('name', 'earth')]
>>>
>>> for eachKey in dict2.keys():
... print 'dict2 key', eachKey, 'has value', dict2[eachKey]
...
dict2 key port has value 80
dict2 key name has value earth
keys()方法很有用,它返回一个包含字典中所有键的列表,此方法可以与 for 循环一起使用来
获取字典中的值。
表 7.2 字典类型方法
方法名字                  操作
a
dict.clear ()            删除字典中所有元素
a
dict.copy ()           返回字典(浅复制)的一个副本
c
dict.fromkeys (seq,


val=None) c            创建并返回一个新字典,以 seq 中的元素做该字典的键,val 做该字
典中所有键对应的初始值(如果不提供此值,则默认为 None)
dict.get(key,
default=None)a        对字典 dict 中的键 key,返回它对应的值 value,如果字典中不存在此
键,则返回 default 的值(注意,参数 default 的默认值为 None)
dict.has_key(key)     如果键(key)在字典中存在,返回 True,否则返回 False. 在 Python2.2
版本引入 in 和 not in 后,此方法几乎已废弃不用了,但仍提供一个
可工作的接口。
dict.items()          返回一个包含字典中(键, 值)对元组的列表
dict.keys()           返回一个包含字典中键的列表
dict.iter()d         方法 iteritems(), iterkeys(), itervalues()与它们对应的非迭代方法
一样,不同的是它们返回一个迭代子,而不是一个列表。
dict.popc(key
[, default]) c        和方法 get()相似,如果字典中 key 键存在,删除并返回 dict[key],
如果 key 键不存在,且没有给出 default 的值,引发 KeyError 异常。
dict.setdefault(key,
default=None)e      和方法 set()相似,如果字典中不存在 key 键,由 dict[key]=default 为
它赋值。
a
dict.update(dict2) 将字典 dict2 的键-值对添加到字典 dict
dict.values()       返回一个包含字典中所有值的列表
a.  Python 1.5 新增
b.  关于深复制和浅复制的详细信息请参见 6.19 节.
c.  Python 2.3 新增
d.  Python 2.2 新增
e.  Python 2.0 新增
但是,它返回的元素是没有顺序的(和哈希表中的键(keys)一样),我们通常希望它们能按某种
方式排序。
在 Python 2.4 版本以前,你只能调用字典的 keys()方法获得键的列表,然后调用列表的 sort()
方法得到一个有序可遍历的列表。现在特别为迭代子设计了一个名为 sorted()的内建函数,它返回
一个有序的迭代子:
>>> for eachKey in sorted(dict2):
... print 'dict2 key', eachKey, 'has value',
dict2[eachKey]
...
dict2 key name has value earth
dict2 key port has value 80


update()方法可以用来将一个字典的内容添加到另外一个字典中。字典中原有的键如果与新添
加的键重复,那么重复键所对应的原有条目的值将被新键所对应的值所覆盖。原来不存在的条目则
被添加到字典中。clear()方法可以用来删除字典中的所有的条目。
>>> dict2= {'host':'earth', 'port':80}
>>> dict3= {'host':'venus', 'server':'http'}
>>> dict2.update(dict3)
>>> dict2
{'server': 'http', 'port': 80, 'host': 'venus'}
>>> dict3.clear()
>>> dict3
{}
copy() 方法返回一个字典的副本。注意这只是浅复制。关于浅复制和深复制请阅读小节 6.19。
最后要说明,get()方法和键查找(key-lookup)操作符( [ ] )相似,不同的是它允许你为不存在的
键提供默认值。如果该键不存在,也未给出它的默认值,则返回 None。此方法比采用键查找
(key-lookup)更灵活,因为你不必担心因键不存在而引发异常。
>>> dict4 = dict2.copy()
>>> dict4
{'server': 'http', 'port': 80, 'host': 'venus'}
>>> dict4.get('host')
'venus'
>>> dict4.get('xxx')
>>> type(dict4.get('xxx'))
<type 'None'>
>>> dict4.get('xxx', 'no such key')
'no such key'
setdefault()是自 2.0 才有的内建方法, 使得代码更加简洁,它实现了常用的语法: 检查字典
中是否含有某键。 如果字典中这个键存在,你可以取到它的值。 如果所找的键在字典中不存在,
你可以给这个键赋默认值并返回此值。这正是执行 setdefault()方法的目的:
>>> myDict = {'host': 'earth', 'port': 80}
>>> myDict.keys()
['host', 'port']
>>> myDict.items()
[('host', 'earth'), ('port', 80)]
>>> myDict.setdefault('port', 8080)
80


>>> myDict.setdefault('prot', 'tcp')
'tcp'
>>> myDict.items()
[('prot', 'tcp'), ('host', 'earth'), ('port', 80)]
前面,我们曾简要介绍过 fromkeys()方法,下面是更多的示例:
>>> {}.fromkeys('xyz')
{'y': None, 'x': None, 'z': None}
>>>
>>> {}.fromkeys(('love', 'honor'), True)
{'love': True, 'honor': True}
目前,keys(), items(), 和 values()方法的返回值都是列表。数据集如果很大会导致很难
处理,这也正是 iteritems(), iterkeys(), 和 itervalues() 方法被添加到 Python 2.2 的主要原
因。这些函数与返回列表的对应方法相似,只是它们返回惰性赋值的迭代器,所以节省内存。未来
的 Python 版本中,甚至会更灵活,那时这些方法将会返回强大的对象,暂叫做视图(views)。视图
(views)是访问容器对象的接口集。举例来说,你可以从一个视图(views)中删除某个字典的键,从
而改变某个字典。
7.5 字典的键
字典中的值没有任何限制。 他们可以是任意 Python 对象,即,从标准对象到用户自定义对象
皆可。但是字典中的键是有类型限制的。
7.5.1     不允许一个键对应多个值
你必须明确一条原则:每个键只能对应一个项。也就是说,一键对应多个值是不允许的。(像列
表、元组和其他字典这样的容器对象是可以的。) 当有键发生冲突(即,字典键重复赋值),取最后(最
近)的赋值。
>>> dict1 = {' foo':789, 'foo': 'xyz'}
>>> dict1
{'foo': 'xyz'}
>>>
>>> dict1['foo'] = 123
>>> dict1
{'foo': 123}


Python 并不会因字典中的键存在冲突而产生一个错误,它不会检查键的冲突是因为,如果真这
样做的话,在每个键-值对赋值的时候都会做检查,这将会占用一定量的内存。在上面的例子里,键
'foo'被列出两次,Python 从左到右检查键-值对。首先值 789 被赋值(给键'foo'所对应的值),然后
又很快被字符串'xyz'替代。当给字典中一个不存在的键赋值时,键和值会被创建和添加,但如果该
键已经存在(键冲突),那此键所对应的值将被替换。上面例子中,键 'foo' 所对应的值被替换了两
次;最后的赋值语句,值 123 代替了值'xyz'。
7.5.2 键必须是可哈希的
我们在小节 7.1 说过,大多数 Python 对象可以作为键;但它们必须是可哈希的对象。像列表和
字典这样的可变类型,由于它们不是可哈希的,所以不能作为键。
所有不可变的类型都是可哈希的,因此它们都可以做为字典的键。一个要说明的是问题是数字:
值相等的数字表示相同的键。换句话来说,整型数字 1 和 浮点数 1.0 的哈希值是相同的,即它们
是相同的键。
同时,也有一些可变对象(很少)是可哈希的,它们可以做字典的键,但很少见。举一个例子,
一个实现了__hash__() 特殊方法的类。因为__hash__()方法返回一个整数,所以仍然是用不可变
的值(做字典的键)。
为什么键必须是可哈希的?解释器调用哈希函数,根据字典中键的值来计算存储你的数据的位
置。如果键是可变对象,它的值可改变。如果键发生变化,哈希函数会映射到不同的地址来存储数
据。如果这样的情况发生,哈希函数就不可能可靠地存储或获取相关的数据。选择可哈希的键的原
因就是因为它们的值不能改变。(此问题在 Python FAQ 中也能找到答案)
我们知道数字和字符串可以被用做字典的键,但元组又怎么样呢?我们知道元组是不可变的,
但在小节 6.17.2, 我们提示过它们也可能不是一成不变的。用元组做有效的键,必须要加限制:元
组中只包括像数字和字符串这样的不可变参数,才可以作为字典中有效的键。
我们用一个程序(userpw.py 例 7.1), 来为本章关于字典的讲述做个小结。这个程序是用于管
理用户名和密码的模拟登录数据系统。脚本接受新用户的信息:
示例 7.1 字典示例(userpw.py)
这个程序管理用于登录系统的用户信息:登录名字和密码。登录用户帐号建立后,已存在用户
可以用登录名字和密码重返系统。新用户不能用别人的登录名建立用户帐号。
1 #!/usr/bin/env python
2


3 db = {}
4
5 def newuser():
6     prompt = 'login desired: '
7     while True:
8          name = raw_input(prompt)
9          if db.has_key(name):
10            prompt = 'name taken, try another: '
11                 continue
12             else:
13                 break
14        pwd = raw_input('passwd: ')
15        db[name] = pwd
16
17 def olduser():
18       name = raw_input('login: ')
19        pwd = raw_input('passwd: ')
20       passwd = db.get(name)
21       if passwd == pwd:
22           print 'welcome back', name
23      else:
24           print 'login incorrect'
25
26 def showmenu():
27       prompt = """
28 (N)ew User Login
29 (E)xisting User Login
30 (Q)uit
Example 7.1 Dictionary Example (userpw.py) (continued)
31
32   Enter choice: """
33
34   done = False
35        while not done:
36
37             chosen = False
38             while not chosen:
39                 try:


40                  choice = raw_input(prompt).strip()[0].lower()
41              except (EOFError, KeyboardInterrupt):
42                  choice = 'q'
43              print '\nYou picked: [%s]' % choice
44             if choice not in 'neq':
45                 print 'invalid option, try again'
46             else:
47                  chosen = True
49                 done = True
50 newuser()
51 olduser()
52
53 if __name__ == '__main__':
54 showmenu()
他们提供登录名和密码。帐号建立后,已存在用户可用登录名和正确的密码重返系统。新用户
不能用别人的登录名建立帐号。
逐行解释
Lines 1–3
在 Unix 初始行后,我们用一个空用户数据库初始化程序。 因为我们没有把数据存储在任何地
方,每次程序执行时都会新建一个用户数据库。
Lines 5–15
newuser() 函数用来建立新用户。它检查名字是否已经存在,如果证实是一个新名字,将要求
用户输入他或她的密码 (我们这个简单的程序没有加密),用户的密码被存储在字典里,以他们的名
字做字典中的键。
Lines 17–24
olduser()函数处理返回的用户。如果用户用正确的用户名和密码登录,打出欢迎信息。否则通
知用户是无效登录并返回菜单。我们不会采用一个无限循环来提示用户输入正确的密码,因为用户
可能会无意进入错误的菜单选项。
Lines 26–51
真正控制这个脚本的是 showmenu()函数,它显示给用户一个友好界面。提示信息被包括在三引
号里("""), 这样做是因为提示信息跨多行,而且比单行包含'\n'符号的字符串更容易处理。菜单显
示后,它等待用户的有效输入,然后根据菜单选项选择操作方式。try-expect 语句和上章 stack.py
queue.py 例子里的一样(见 小节 6.14.1).


Lines 53–54
如果这个脚本被直接执行(不是通过 import 方式),这行代码会调用 showmenu()函数运行程序。
这是我们的脚本运行结果:
$ userpw.py
(N)ew User Login
(E)xisting User Login
(Q)uit
Enter choice: n
You picked: [n]
login desired: king arthur
passwd: grail
(N)ew User Login
(E)xisting User Login
(Q)uit
Enter choice: e
You picked: [e]
login: sir knight
passwd: flesh wound
login incorrect
(N)ew User Login
(E)xisting User Login
(Q)uit
Enter choice: e
You picked: [e]
login: king arthur
passwd: grail
welcome back king Arthur
(N)ew User Login
(E)xisting User Login
(Q)uit


Enter choice: ^D
You picked: [q]
7.6 集合类型
数学上, 把 set 称做由不同的元素组成的集合,集合(set)的成员通常被称做集合元素(set
elements)。Python 把这个概念引入到它的集合类型对象里。集合对象是一组无序排列的可哈希的值。
是的,集合成员可以做字典中的键。数学集合转为 Python 的集合对象很有效,集合关系测试和 union、
intersection 等操作符在 Python 里也同样如我们所预想地那样工作。
和其他容器类型一样,集合支持用 in 和 not in 操作符检查成员, 由 len() 内建函数得到集
合的基数(大小), 用 for 循环迭代集合的成员。但是因为集合本身是无序的,你不可以为集合创建
索引或执行切片(slice)操作,也没有键(keys)可用来获取集合中元素的值。
集合(sets)有两种不同的类型,可变集合(set) 和 不可变集合(frozenset)。如你所想,对可
变集合(set),你可以添加和删除元素,对 不可变集合(frozenset)则不允许这样做。请注意,可变
集合(set)不是可哈希的,因此既不能用做字典的键也不能做其他集合中的元素。不可变集合
(frozenset)则正好相反,即,他们有哈希值,能被用做字典的键或是作为集合中的一个成员。
集合(Sets)最早出现在 Python2.3 版本中,通过集合(sets)模块来创建,并通过 ImmutableSet
类和 Set 类进行访问。而后来,大家都认为把它们作为内建的数据类型是个更好的主意,因此这些
类被用 C 重写改进后包含进 Python2.4。关于集合类型和这些类改进的更多内容,可阅读此文获得详
情:PEP 218,链接地址: http://python.org/peps/pep-0218.html.
虽然现在集合类型已经是 Python 的基本数据类型了,但它经常会以用户自定义类的形式出现在
各种 Python 程序中,就像复数一样(复数从 Python1.4 版本起成为 python 的一个数据类型),这样
重复的劳动已数不胜数了。在现在的 Python 版本之前,(即使集合类型对许多人的程序来说并不是
最理想的数据结构,)许多人仍然试图给列表和字典这样的 Python 标准类型添加集合功能,这样可
以把它们作为真正集合类型的代理来使用。因此现在的使用者有包括“真正”集合类型在内的多种
选择。
在我们详细讲述 Python 的集合对象之前,我们必须理解 Python 中的一些数学符号 (见表 7.3),
这样对术语和功能有一个清晰的了解。
表 7.3 集合操作符和关系符号


数学符号         Python 符号          说明
7.6 集合类型
如何创建集合类型和给集合赋值
集合与列表( [ ] )和字典( { } ) 不同,没有特别的语法格式。列表和字典可以分别用他们自
己的工厂方法 list() 和 dict() 创建,这也是集合被创建的唯一方法 - 用集合的工厂方法 set()
和 frozenset():
>>> s = set('cheeseshop')
>>> s
set(['c', 'e', 'h', 'o', 'p', 's'])
>>> t = frozenset('bookshop')
>>> t
frozenset(['b', 'h', 'k', 'o', 'p', 's'])
>>> type(s)
<type 'set'>
>>> type(t)
<type 'frozenset'>
>>> len(s)
6
>>> len(s) == len(t)


True
>>> s == t
False
如何访问集合中的值
你可以遍历查看集合成员或检查某项元素是否是一个集合中的成员:
>>> 'k' in s
False
>>> 'k' in t
True
>>> 'c' not in t
True
>>> for i in s:
...    print i
...
c
e
h
o
p
s
如何更新集合
用各种集合内建的方法和操作符添加和删除集合的成员:
>>> s.add('z')
>>> s
set(['c', 'e', 'h', 'o', 'p', 's', 'z'])
>>> s.update('pypi')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y', 'z'])
>>> s.remove('z')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y'])
>>> s -= set('pypi')
>>> s


set(['c', 'e', 'h', 'o', 's'])
我们之前提到过,只有可变集合能被修改。试图修改不可变集合会引发异常。
>>> t.add('z')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
AttributeError: 'frozenset' object has no attribute 'add'
如何删除集合中的成员和集合
前面我们看到如何删除集合成员。如果如何删除集合本身,可以像删除任何 Python 对象一样,
令集合超出它的作用范围,或调用 del 将他们直接清除出当前的名字空间。如果它的引用计数为零,
也会被标记以便被垃圾回收。
>>> del s
>>>
7.7     集合类型操作符
7.7.1 标准类型操作符(所有的集合类型)
成员关系 (in, not in)
就序列而言,Python 中的 in 和 not in 操作符决定某个元素是否是一个集合中的成员。
>>> s = set('cheeseshop')
>>> t = frozenset('bookshop')
>>> 'k' in s
False
>>> 'k' in t
True
>>> 'c' not in t
True
集合等价/不等价


等价/不等价被用于在相同或不同的集合之间做比较。两个集合相等是指,对每个集合而言,当
且仅当其中一个集合中的每个成员同时也是另一个集合中的成员。
你也可以说每个集合必须是另一个集合的一个子集, 即,s <= t 和 s >= t 的值均为真(True),
或(s <= t and s>= t) 的值为真(True)。集合等价/不等价与集合的类型或集合成员的顺序无关,
只与集合的元素有关。
>>> s == t
False
>>> s != t
True
>>> u = frozenset(s)
>>> s == u
True
>>> set('posh') == set('shop')
True
子集/超集
Sets 用 Python 的比较操作符检查某集合是否是其他集合的超集或子集。                  “小于”符号(  <, <= )
用来判断子集,“大于”符号( >, >= )用来判断超集。
“小于” 和 “大于”意味着两个集合在比较时不能相等。等于号允许非严格定义的子集和超
集。
Sets 支持严格( < )子集和非严格 ( <= ) 子集, 也支持严格( > )超集和非严格 ( >= )
超集。只有当第一个集合是第二个集合的严格子集时,我们才称第一个集合“小于”第二个集合,
同理,只有当第一个集合是第二个集合的严格超集时,我们才称第一个集合“大于”第二个集合。
>>> set('shop') < set('cheeseshop')
True
>>> set('bookshop') >= set('shop')
True
7.7.2 集合类型操作符(所有的集合类型)
联合( | )
联合(union)操作和集合的 OR(又称可兼析取(inclusive disjunction))其实是等价的,两个集
合的联合是一个新集合,该集合中的每个元素都至少是其中一个集合的成员,即,属于两个集合其
中之一的成员。联合符号有一个等价的方法,union().


>>> s | t
set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
交集( & )
你可以把交集操作比做集合的 AND(或合取)操作。两个集合的交集是一个新集合,该集合中的每
个元素同时是两个集合中的成员,即,属于两个集合的成员。交集符号有一个等价的方法,
intersection().
>>> s & t
set(['h', 's', 'o', 'p']
差补/相对补集( – )
两个集合(s 和 t)的差补或相对补集是指一个集合 C,该集合中的元素,只属于集合 s,而不属
于集合 t。差符号有一个等价的方法,difference().
>>> s - t
set(['c', 'e'])
对称差分( ^ )
和其他的布尔集合操作相似,对称差分是集合的 XOR(又称”异或“ (exclusive disjunction)).
两个集合(s 和 t)的对称差分是指另外一个集合 C,该集合中的元素,只能是属于集合 s 或者集合 t
的成员,不能同时属于两个集合。对称差分有一个等价的方法,symmetric_difference().
>>> s ^ t
set(['k', 'b', 'e', 'c'])
混合集合类型操作
上面的示例中,左边的 s 是可变集合,而右边的 t 是一个不可变集合. 注意上面使用集合操作
运算符所产生的仍然是可变集合,但是如果左右操作数的顺序反过来,结果就不一样了:
>>> t | s
frozenset(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
>>> t ^ s
frozenset(['c', 'b', 'e', 'k'])
>>> t - s frozenset(['k', 'b'])
如果左右两个操作数的类型相同,既都是可变集合或不可变集合, 则所产生的结果类型是相同
的,但如果左右两个操作数的类型不相同(左操作数是 set,右操作数是 frozenset,或相反情况),


则所产生的结果类型与左操作数的类型相同,上例中可以证明这一点。还要注意,加号不是集合类
型的运算符:
>>> v = s + t
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: unsupported operand type(s) for +: 'set' and 'set'
>>> v = s | t
>>> v
set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
>>> len(v)
8
>>> s < v
True
7.7.3 集合类型操作符(仅适用于可变集合)
(Union) Update ( |= )
这个更新方法从已存在的集合中添加(可能多个)成员,此方法和 update()等价.
>>> s = set('cheeseshop')
>>> u = frozenset(s)
>>> s |= set('pypi')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y'])
保留/交集更新( &= )
保留(或交集更新)操作保留与其他集合的共有成员。此方法和 intersection_update()等价.
>>> s = set(u)
>>> s &= set('shop')
>>> s
set(['h', 's', 'o', 'p'])
差更新 ( –= )
对集合 s 和 t 进行差更新操作 s-=t,差更新操作会返回一个集合,该集合中的成员是集合 s 去
除掉集合 t 中元素后剩余的元素。此方法和 difference_update()等价.


>>> s = set(u)
>>> s -= set('shop')
>>> s
set(['c', 'e'])
对称差分更新( ^= )
对集合 s 和 t 进行对称差分更新操作(s^=t),对称差分更新操作会返回一个集合,该集合中的成
员仅是原集合 s 或仅是另一集合 t 中的成员。此方法和 symmetric_difference_update()等价.
>>> s = set(u)
>>> t = frozenset('bookshop')
>>> s ^= t
>>> s
set(['c', 'b', 'e', 'k'])
7.8   内建函数
7.8.1 标准类型函数
len()
把集合作为参数传递给内建函数 len(),返回集合的基数(或元素的个数)。
>>> s = set(u)
>>> s
set(['p', 'c', 'e', 'h', 's', 'o'])
>>> len(s)
6
7.8.2 集合类型工厂函数
set() and frozenset()
set()和 frozenset()工厂函数分别用来生成可变和不可变的集合。如果不提供任何参数,默认
会生成空集合。如果提供一个参数,则该参数必须是可迭代的,即,一个序列,或迭代器,或支持
迭代的一个对象,例如:一个文件或一个字典。


>>> set()
set([])
>>> set([])
set([])
>>> set(())
set([])
>>> set('shop')
set(['h', 's', 'o', 'p'])
>>>
>>> frozenset(['foo', 'bar'])
frozenset(['foo', 'bar'])
>>>
>>> f = open('numbers', 'w')
>>> for i in range(5):
... f.write('%d\n' % i)
...
>>> f.close()
>>> f = open('numbers', 'r')
>>> set(f)
set(['0\n', '3\n', '1\n', '4\n', '2\n'])
>>> f.close()
7.9    集合类型内建方法
7.9.1 方法(所有的集合方法)
我们已看到很多和内建方法等价的操作符,表 7.4 做了小结:
内建方法 copy() 没有等价的操作符。和同名的字典方法一样,copy()方法比用像 set(),
frozenset(), 或 dict()这样的工厂方法复制对象的副本要快。
表 7.4       集合类型方法
方法名称             操作
s.issubset(t)      如果 s 是 t 的子集,则返回 True,否则返回 False
s.issuperset(t)     如果 t 是 s 的超集,则返回 True,否则返回 False
s.union(t)          返回一个新集合,该集合是 s 和 t 的并集
s.intersection(t) 返回一个新集合,该集合是 s 和 t 的交集


s.difference(t)    返回一个新集合,该集合是 s 的成员,但不是 t 的成员
s.symmetric_difference(t) 返回一个新集合,该集合是 s 或 t 的成员,但不是 s 和 t 共有的
成员
s.copy()           返回一个新集合,它是集合 s 的浅复制
7.9.2 方法(仅适用于可变集合)
表 7.5 总结了所有可变集合的内建方法,和上面的方法相似,我们已经看过许多和它们等价的
操作符。
新的方法有 add(), remove(), discard(), pop(), clear().  这些接受对象的方法,参数必
须是可哈希的。
7.9.3 操作符和内建方法比较
像你看到的, 很多内建的方法几乎和操作符等价。我们说"几乎等价",意思是它们间是有一个
重要区别: 当用操作符时,操作符两边的操作数必须是集合。 在使用内建方法时,对象也可以是
迭 代 类 型 的 。 为 什 么 要 用 这 种 方 式 来 实 现 呢 ? Python 的 文 档 里 写 明 : 采 用 易 懂 的
set('abc').intersection('cbs') 可以避免用 set('abc') [and] 'cbs' 这样容易出错的构建方
法。
表 7.5 可变集合类型的方法
方法名                          操作
s.update(t)                   用 t 中的元素修改 s, 即,s 现在包含 s 或 t 的成员
s.intersection_update(t) s 中的成员是共同属于 s 和 t 的元素。
s.difference_update(t)    s 中的成员是属于 s 但不包含在 t 中的元素
s.symmetric_difference_update(t) s 中的成员更新为那些包含在 s 或 t 中,但不           是s
和 t 共有的元素
s.add(obj)                  在集合 s 中添加对象 obj
s.remove(obj)               从集合 s 中删除对象 obj;如果 obj 不是集合 s 中的元素(obj not
in s),将引发 KeyError 错误
s.discard(obj)               如果 obj 是集合 s 中的元素,从集合 s 中删除对象 obj;
s.pop()                     删除集合 s 中的任意一个对象,并返回它
s.clear()                   删除集合 s 中的所有元素
7.10 操作符、函数/方法


集合类型总结表
表 7.6 中,我们总结了所有的集合类型的操作符、函数和方法
7.11     相关模块
集合(set)模块从 2.3 版本引进,可继承 Set 或 ImmuteablSet 来生成子类。虽然从 Python2.4
起使用集合类型,但是集合模块不会弃用。
表 7.6 集合类型操作符、函数和方法
函数/方法名             等价运算符                   说明
所有集合类型
len(s)                                 集合基数: 集合 s 中元素的个数
set([obj])                             可变集合工厂函数; obj 必须是支持迭代的,由 obj 中
的元素创建集合,否则创建一个空集合
frozenset([obj])                        不可变集合工厂函数; 执行方式和 set()方法相同,
但它返回的是不可变集合
obj in s            成员测试:obj 是 s 中的一个元素吗?
obj not in s          非成员测试:obj 不是 s 中的一个元素吗?
s == t           等价测试: 测试 s 和 t 是否具有相同的元素?
s != t        不等价测试: 与==相反
s < t               (严格意义上)子集测试; s != t 而且 s 中 所 有
的元素都是 t 的成员
s.issubset(t)         s <= t           子集测试(允许不严格意义上的子集): s 中所有的元素
都是 t 的成员
s > t            (严格意义上)超集测试: s != t 而且 t 中所有的元素
都是 s 的成员
s.issuperset(t)       s >= t         超集测试(允许不严格意义上的超集): t 中所有的元素
都是 s 的成员
s.union(t)           s | t           合并操作:s 或 t 中的元素
s.intersec- tion(t)     s & t          交集操作:s 和 t 中的元素
s.difference(t)          s - t   差分操作: s 中的元素,而不是 t 中的元素
s.symmetric_difference(t)s ^ t          对称差分操作:s 或 t 中的元素,但不是 s 和 t 共有
的元素
s.copy()                             复制操作:返回 s 的(浅复制)副本
Table 7.6  集合类型,函数和方法(继续)


函数/方法名字              操作符              等价描述
仅用于可变集合
s.update(t)           s |= t          (Union) 修改操作: 将 t 中的成员添加 s
s.intersection_update(t) s &= t        交集修改操作: s 中仅包括 s 和 t 中共有的成员
s.difference_update(t) s -= t            差修改操作: s 中包括仅属于 s 但不属于 t 的成员
s.symmetric_
difference_
update(t)               s ^= t           对称差分修改操作: s 中包括仅属于 s 或仅属于 t 的
成员
s.add(obj)                               加操作: 将 obj 添加到 s
s.remove(obj)                                删除操作: 将 obj 从 s 中删除;如果 s 中不存在
obj,将引发 KeyError
s.discard(obj)                      丢弃操作: remove() 的 友 好 版 本                    -   如
果 s                               中存在 obj,
从 s 中删除它
s.pop()                                  Pop 操作: 移除并返回 s 中的任意一个元素
s.clear()                                 清除操作: 移除 s 中的所有元素
以下是一些你可能认为有用的在线参考文章:
http://en.wikipedia.org/wiki/Set http://www.geocities.com/basicmathsets/set.html
http://www.math.uah.edu/stat/foundations/Sets.xhtml
7.12     练习
7–1.    字典方法。哪个字典方法可以用来把两个字典合并到一起?
7–2.    字典的键。我们知道字典的值可以是任意的 Python 对象,那字典的键又如何呢?请试
着将除数字和字符串以外的其他不同类型的对象作为字典的键,看一看,哪些类型可以,哪些不行?
对那些不能作字典的键的对象类型,你认为是什么原因呢?
7–3.    字典和列表的方法。
(a) 创建一个字典,并把这个字典中的键按照字母顺序显示出来。
(b) 现在根据已按照字母顺序排序好的键,显示出这个字典中的键和值。
(c)同(b),但这次是根据已按照字母顺序排序好的字典的值,显示出这个字典中的键和值。(注
意:对字典和哈希表来说,这样做一般没有什么实际意义,因为大多数访问和排序(如果需要)都是
基于字典的键,这里只把它作为一个练习。)
7-4.    建立字典。给定两个长度相同的列表,比如说,列表[1, 2, 3,...]和['abc', 'def',
'ghi',...],用这两个列表里的所有数据组成一个字典,像这样:{1:'abc', 2: 'def', 3: 'ghi',...}


7–5. userpw2.py. 下面的问题和例题 7.1 中管理名字-密码的键值对数据的程序有关。
(a)修改那个脚本,使它能记录用户上次的登录日期和时间(用 time 模块),并与用户密码一起
保存起来。程序的界面有要求用户输入用户名和密码的提示。无论户名是否成功登录,都应有提示,
在户名成功登录后,应更新相应用户的上次登录时间戳。如果本次登录与上次登录在时间上相差不
超过 4 个小时,则通知该用户: “You already logged in at: <last_ login_timestamp>.”
(b) 添加一个“管理”菜单,其中有以下两项:(1)删除一个用户 (2)显示系统中所有用户的名
字和他们的密码的清单。
(c) 口令目前没有加密。请添加一段对口令加密的代码(请参考 crypt, rotor, 或其它加密模块)
(d) 为程序添加图形界面,例如,用 Tkinter 写。
(e) 要求用户名不区分大小写。
(f) 加强对用户名的限制,不允许符号和空白符。
(g)合并“新用户”和“老用户”两个选项。如果一个新用户试图用一个不存在的用户名登录,
询问该用户是否是新用户,如果回答是肯定的,就创建该帐户。否则,按照老用户的方式登录。
7-6. 列表和字典。创建一个简单的股票证券投资数据系统。其中应至少包含四项数据:股市
行情显示器符号,所持有的股票,购买价格及当前价位 - 你可以随意添加其他数据项,比如收益率,
52 周最高指数、最低指数,等等。
用户每次输入各列的数据构成一个输出行。每行数据构成一个列表。还有一个总列表,包括了
所有行的数据。数据输入完毕后,提示用户选择一列数据项进行排序。把该数据项抽取出来作为字
典的键,字典的值就是该键对应行的值的列表。提醒读者:被选择用来排序的数据项必须是非重复
的键,否则就会丢失数据,因为字典不允许一个键有多个值。
你还可以选择其他计算输出,比如,盈亏比率,目前证券资产价值等。
7-7.   颠倒字典中的键和值。用一个字典做输入,输出另一个字典,用前者的键做值,前者的
值做键。
7-8.   人力资源。创建一个简单的雇员姓名和编号的程序。让用户输入一组雇员姓名和编号。
你的程序可以提供按照姓名排序输出的功能,雇员姓名显示在前面,后面是对应的雇员编号。附加
题:添加一项功能,按照雇员编号的顺序输出数据。
7-9.   翻译
(a) 编写一个字符翻译程序(功能类似于 Unix 中的 tr 命令)。我们将这个函数叫做 tr(),它有
三个字符串做参数: 源字符串、目的字符串、基本字符串,语法定义如下:
def tr(srcstr, dststr, string)
srcstr 的内容是你打算“翻译”的字符集合,dsrstr 是翻译后得到的字符集合,而 string 是
你打算进行翻译操作的字符串。举例来说,如果 srcstr == 'abc', dststr == 'mno', string ==
'abcdef', 那么 tr()的输出将是'mnodef'. 注意这里 len(srcstr) == len(dststr).
在这个练习里,你可以使用内建函数 chr() 和 ord(), 但它们并不一定是解决这个问题所必不
可少的函数。
(b) 在这个函数里增加一个标志符参数,来处理不区分大小写的翻译问题。


(c)修改你的程序,使它能够处理删除字符的操作。字符串 srcstr 中不能够映射到字符串 dststr
中字符的多余字符都将被过滤掉。换句话说,这些字符没有映射到 dststr 字符串中的任何字符,因
此就从函数返回的字符里被过滤掉了。举例来说:如果 srcstr == 'abcdef', dststr == 'mno',
string == 'abcdefghi', 那么 tr()将输出'mnoghi'. 注意这里 len(srcstr) >= len(dststr).
7–10.    加密。
(a) 用上一个练习的思路编写一个"rot13"翻译器。"rot13"是一个古老而又简单的加密方法,
它把字母表中的每个字母用其后的第 13 个字母来代替。字母表中前半部分字母将被映射到后半部分,
而后半部分字母将被映射到前半部分,大小写保持不变。举例来说,'a'将被替换为'n','X'将被替
换为'K'; 数字和符号不进行翻译。
(b)在你的解决方案的基础上加一个应用程序,让它提示用户输入准备加密的字符串(这个算法
同时也可以对加密后的字符串进行解密),如下所示:
% rot13.py
Enter string to rot13: This is a short sentence. Your string to en/decrypt was: [This
is a short sentence.].
The rot13 string is: [Guvf vf n fubeg fragrapr.].
%
% rot13.py
Enter string to rot13: Guvf vf n fubeg fragrapr. Your string to en/decrypt was: [Guvf
vf n fubeg fragrapr.].
The rot13 string is: [This is a short sentence.].
7–11.    定义。什么组成字典中合法的键? 举例说明字典中合法的键和非法的键。
7-12.   定义。
(a)在数学上,什么是集合?
(b)在 Python 中,关于集合类型的定义是什么?
7–13.    随机数。修改练习 5-17 的代码:使用 random 模块中的 randint()或 randrange()方
法生成一个随机数集合:从 0 到 9(包括 9)中随机选择,生成 1 到 10 个随机数。这些数字组成集合
A(A 可以是可变集合,也可以不是)。同理,按此方法生成集合 B。每次新生成集合 A 和 B 后,显示
结果 A | B 和 A & B
7–14.    用户验证。修改前面的练习,要求用户输入 A | B 和 A & B 的结果,并告诉用户他(或
她)的答案是否正确,而不是将 A | B 和 A & B 的结果直接显示出来。如果用户回答错误,允许他(或
她)修改解决方案,然后重新验证用户输入的答案。如果用户三次提交的答案均不正确,程序将显示
正确结果。
附加题:运用你关于集合的知识,创建某个集合的潜在子集,并询问用户此潜在子集是否真是
该集合的子集,要求和主程序一样有显示更正和答案的功能。


7–15.    编写计算器。 这个练习取材于 http://math.hws.edu/ 在线免费 Java 教材中的练习
12.2。编写一个程序允许用户选择两个集合:A 和 B, 及运算操作符。例如,in, not in, &, |, ^, <,
<=, >, >=, ==, !=, 等. (你自己定义集合的输入语法,它们并不一定要像 Java 示例中那样用方括
号括住。)解析输入的字符串,按照用户选择的运算进行操作。你写的程序代码应该比 Java 版本的
该程序更简洁。


条件和循环 
本章主题
z if 语句
z else 语句
z elif 语句
z 条件表达式
z while 语句
z for 语句
z break 语句
z continue 语句
z pass 语句
z else 语句 (再看)
z Iterators 迭代器
z 列表解析(List Comprehensions)
z 生成器表达式(Generator Expressions )


本章的主要内容是 Python 的条件和循环语句以及与它们相关的部分. 我们会深入探讨 if ,
while , for 以及与他们相搭配的 else , elif , break , continue 和 pass 语句.
8.1 if 语句
Python 中的 if 子句看起来十分熟悉. 它由三部分组成: 关键字本身, 用于判断结果真假的
条件表达式, 以及当表达式为真或者非零时执行的代码块.
if 语句的语法如下:
if expression:
expr_true_suite
if 语句的 expr_true_suite 代码块只有在条件表达式的结果的布尔值为真时才执行, 否则将
继续执行紧跟在该代码块后面的语句.
8.1.1 多重条件表达式
单个 if 语句可以通过使用布尔操作符 and , or 和 not
实现多重判断条件或是否定判断条件.
if not warn and (system_load >= 10):
print "WARNING: losing resources"


warn += 1
8.1.2 单一语句的代码块
如果一个复合语句(例如 if 子句, while 或 for 循环)的代码块仅仅包含一行代码, 那么它可
以和前面的语句写在同一行上:
if make_hard_copy: send_data_to_printer()
上边这样的单行语句是合法的, 尽管它可能方便, 但这样会使得代码更难阅读, 所以我们推
荐将这行代码移到下一行并合理地缩进. 另外一个原因就是如果你需要添加新的代码, 你还是得把
它移到下一行.
8.2 else 语句
和其他语言一样, Python 提供了与 if 语句搭配使用的 else 语句.
如果 if 语句的条件表达式的结果布尔值为假, 那么程序将执行 else 语句后的代码. 它的语
法你甚至可以猜到:
if expression:
expr_true_suite
else:
expr_false_suite
这里是样例代码:
if passwd == user.passwd:
ret_str = "password accepted"
id = user.id valid = True
else:
ret_str = "invalid password entered... try again!"
valid = False
8.2.1      避免“悬挂 else”
Python 使用缩进而不是用大括号标记代码块边界的设计, 不仅帮助强化了代码的正确性, 而
且还暗中帮助程序员避免了语法上正确的代码中存在潜在的问题. 其中一个问题就是(臭名)昭著的
"悬挂 else (dangling else)"问题, 一种语义错觉.


我们在这里给出一段 C 代码来说明我们的例子( K&R 和其他的编程教材也给出过):
/* dangling-else in C */
if (balance > 0.00)
if (((balance - amt) > min_bal) && (atm_cashout() == 1))
printf("Here's your cash; please take all bills.\n");
else
printf("Your balance is zero or negative.\n");
问题是: else 属于哪个 if ? 在 C 语言中, 规则是 else 与最近的 if 搭配. 所以我们上
面的例子中, else 虽然是想和外层的 if 搭配, 但是事实上 else 属于内部的 if ,因为 C 编译器
会忽略额外的空白. 结果, 如果你的 balance 是正数但小于最小值, 你将得到错误的输出, 程序
会显示你的 balance 是零或者为负数.
由于这个例子很简单, 所以解决这个问题并不难, 但是如果是大块的代码嵌入到了类似这样
的框架中, 那么发现并改正程序中的错误需要耗费很多精力. Python 设置的护栏不仅阻止你掉下悬
崖, 而且会带你离开危险的境地. 在 Python 中相同的例子对应如下的两种代码(只有一种是正确
的):
if balance > 0.00:
if balance - amt > min_bal and atm_cashout():
print "Here's your cash; please take all bills."
else:
print 'Your balance is zero or negative.'
或者是:
if balance > 0.00:
if balance - amt > min_bal and atm_cashout():
print "Here's your cash; please take all bills."
else:
print 'Your balance is zero or negative.'
Python 的缩进使用强制使代码正确对齐, 让程序员来决定 else 属于哪一个 if . 限制您的选
择从而减少了不确定性, Python 鼓励您第一次就写出正确的代码. 在 Python 中制造出“悬挂 else”
问题是不可能的, 而且, 由于大括号不再被使用, Python 代码更易读懂.


8.3 elif (即 else-if )语句
elif 是 Python 的 else-if 语句, 它检查多个表达式是否为真, 并在为真时执行特定代码块
中的代码. 和 else 一样, elif 声明是可选的, 然而不同的是, if 语句后最多只能有一个 else
语句, 但可以有任意数量的 elif 语句.
if expression1:
expr1_true_suite
elif expression2:
expr2_true_suite
elif expressionN:
exprN_true_suite
else:
none_of_the_above_suite
switch/case 语句的替代品么?
在将来的某天, Python 可能会支持 switch /case 语句, 但是你完全可以用其他的 Python
结构来模拟它. 在 Python 中, 大量的 if-elif 语句并不难阅读:
if user.cmd == 'create':
action = "create item"
elif user.cmd == 'delete':
action = 'delete item'
elif user.cmd == 'update':
action = 'update item'
else:
action = 'invalid choice... try again!'
上面的语句完全可以满足我们的需要, 不过我们还可以用序列和成员关系操作符来简化它:
if user.cmd in ('create', 'delete', 'update'):
action = '%s item' % user.cmd
else:


action = 'invalid choice... try again!'
另外我们可以用 Python 字典给出更加优雅的解决方案, 我们将在第七章 "映射和集合类型"
中介绍字典.
msgs = {'create': 'create item',
'delete': 'delete item',
'update': 'update item'}
default = 'invalid choice... try again!'
action = msgs.get(user.cmd, default)
众所周知, 使用映射对象(比如字典)的一个最大好处就是它的搜索操作比类似                                if-elif-else
语句或是 for 循环这样的序列查询要快很多.
8.4    条件表达式(即"三元操作符")
如果你来自 C/C++ 或者是 Java 世界, 那么你很难忽略的一个事实就是 Python 在很长的一
段时间里没有条件表达式(C ? X : Y), 或称三元运算符. ( C 是条件表达式; X 是 C 为 True 时
的结果, Y 是 C 为 False 时的结果) 贵铎·范·罗萨姆一直拒绝加入这样的功能, 因为他认为应
该保持代码简单, 让程序员不轻易出错. 不过在十年多后, 他放弃了, 主要是因为人们试着用
and 和 or 来模拟它, 但大多都是错误的. 根据 FAQ , 正确的方法(并不唯一)是
(C and [X] or [Y])[0] . 唯一的问题是社区不同意这样的语法. (你可以看一看 PEP 308, 其
中有不同的方案.) 对于 Python 的这一问题,人们表达了极大的诉求.
贵铎·范·罗萨姆最终选择了一个最被看好(也是他最喜欢)的方案, 然后把它运用于标准库中
的一些模块. 根据 PEP , "这个评审通过考察大量现实世界的案例, 包含不同的应用, 以及由不同
程序员完成的代码." 最后 Python 2.5 集成的语法确定为: X if C else Y .
有了三元运算符后你就只需要一行完成条件判断和赋值操作, 而不需要像下面例子中的 min()
那样,使用 if-else 语句实现对数字 x 和 y 的操作:
>>>  x, y = 4, 3
>>>  if x < y:
...       smaller = x
...  else:
...       smaller = y
...
>>>  smaller
3


在 2.5 以前的版本中, Python 程序员最多这样做(其实是一个 hack ):
>>> smaller = (x < y and [x] or [y])[0]
>>> smaller
3
```
在 2.5 和更新的版本中, 你可以使用更简明的条件表达式:
>>> smaller = x if x < y else y
>>> smaller
3
8.5 while 语句
Python 的 while 是本章我们遇到的第一个循环语句. 事实它上是一个条件循环语句. 与 if
声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循
环执行, 直到循环条件不再为真.
8.5.1 一般语法
while 循环的语法如下:
while expression:
suite_to_repeat
while 循环的 suite_to_repeat 子句会一直循环执行, 直到 expression 值为布尔假. 这种
类型的循环机制常常用在计数循环中, 请参见下节中例子.
8.5.2 计数循环
count = 0
while (count < 9):
print 'the index is:', count
count += 1
这里的代码块里包含了 print 和自增语句, 它们被重复执行, 直到 count 不再小于 9 . 索引
count 在每次迭代时被打印出来然后自增 1 . 在 Python 解释器中输入这些代码我们将得到这样的


结果:
>>> count = 0
>>> while (count < 9):
...      print 'the index is:', count
...      count += 1
...
the index is: 0
the index is: 1
the index is: 2
the index is: 3
the index is: 4
the index is: 5
the index is: 6
the index is: 7
the index is: 8
8.5.3 无限循环
你必须小心地使用 while 循环, 因为有可能 condition 永远不会为布尔假. 这样一来循环
就永远不会结束. 这些"无限"的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通
过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就
是说, 条件表达式会不会计算后得到布尔假?
while True:
handle, indata = wait_for_client_connect()
outdata = process_request(indata)
ack_result_to_client(handle, outdata)
例如上边的代码就是故意被设置为无限循环的,因为 True 无论如何都不会变成 False. 这是因
为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器
处理请求.
请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求.
对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接. 在第
16 章, "网络编程" 和第 17 章节 "Internet 客户端编程" 里你将了解关于如何处理客户端/服务
器的更多信息.


8.6 for 语句
Python 提供给我们的另一个循环机制就是 for 语句. 它提供了 Python 中最强大的循环结构.
它可以遍历序列成员, 可以用在 列表解析 和 生成器表达式中, 它会自动地调用迭代器的 next()
方法, 捕获 StopIteration 异常并结束循环(所有这一切都是在内部发生的). 如果你刚刚接触
Python 那么我们要告诉你, 在以后你会经常用到它的. 和传统语言(例如 C/C++ , Fortran, 或者
Java )中的 for 语句不同, Python 的 for 更像是 shell 或是脚本语言中的 foreach 循环.
8.6.1 一般语法
for 循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过
后结束循环. 它的语法如下:
for iter_var in iterable:
suite_to_repeat
每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对
象)的当前元素, 提供给 suite_to_repeat 语句块使用.
8.6.2 用于序列类型
本节中, 我们将学习用 for 循环迭代不同的序列对象. 样例将涵盖字符串, 列表, 以及元组.
>>> for eachLetter in 'Names':
... print 'current letter:', eachLetter
...
current letter: N
current letter: a
current letter: m
current letter: e
current letter: s
当迭代字符串时, 迭代变量只会包含一个字符(长度为 1 的字符串). 但这并不常用。在字符串
里中查找字符时, 程序员往往使用 in 来测试成员关系, 或者使用 string 模块中的函数以及字符
串方法来检查子字符串.
看到单个的字符在一种情况下有用,即在通过 print 语句调试 for 循环中的序列时, 如果你在
应该看到字符串的地方发现的却是单个的字符, 那么很有可能你接受到的是一个字符串, 而不是对


象的序列.
迭代序列有三种基本方法:
通过序列项迭代
>>> nameList = ['Walter', "Nicole", 'Steven', 'Henry']
>>> for eachName in nameList:
...      print eachName, "Lim"
...
Walter Lim
Nicole Lim
Steven Lim
Henry Lim
在上面的例子中, 我们迭代一个列表. 每次迭代, eacgName 变量都被设置为列表中特定某个元
素,
然后我们在代码块中打印出这个变量.
===通过序列索引迭代===
另个方法就是通过序列的索引来迭代:
>>> nameList = ['Cathy', "Terry", 'Joe', 'Heather',
'Lucy']
>>> for nameIndex in range(len(nameList)):
... print "Liu,", nameList[nameIndex]
...
Liu, Cathy
Liu, Terry
Liu, Joe
Liu, Heather
Liu, Lucy
我们没有迭代元素, 而是通过列表的索引迭代.
这里我们使用了内建的 len() 函数获得序列长度, 使用 range() 函数(我们将在下面详细讨
论它)创建了要迭代的序列.
>>> len(nameList)
5
>>> range(len(nameList))


[0, 1, 2, 3, 4]
使用 range() 我们可以得到用来迭代 nameList 的索引数列表; 使用切片/下标操作符( [ ] ),
就可以访问对应的序列对象.
如果你对性能有所了解的话, 那么毫无疑问你会意识到
直接迭代序列要比通过索引迭代快. 如果你不明白, 那么你可以仔细想想.
(参见练习 8-13).
===使用项和索引迭代===
两全其美的办法是使用内建的 enumerate() 函数, 它是 Python 2.3 的新增内容. 代码如下:
>>> nameList = ['Donn', 'Shirley', 'Ben', 'Janice',
...      'David', 'Yen', 'Wendy']
>>> for i, eachLee in enumerate(nameList):
...      print "%d %s Lee" % (i+1, eachLee)
...
1 Donn Lee
2 Shirley Lee
3 Ben Lee
4 Janice Lee
5 David Lee
6 Yen Lee
7 Wendy Lee
8.6.3      用于迭代器类型
用 for 循环访问迭代器和访问序列的方法差不多. 唯一的区别就是 for 语句会为你做一些额
外的事情. 迭代器并不代表循环条目的集合.
迭代器对象有一个 next() 方法, 调用后返回下一个条目. 所有条目迭代完后, 迭代器引发一
个 StopIteration 异常告诉程序循环结束. for 语句在内部调用 next() 并捕获异常.
使用迭代器做 for 循环的代码与使用序列条目几乎完全相同. 事实上在大多情况下, 你无法
分辨出你迭代的是一个序列还是迭代器, 因此,这就是为什么我们在说要遍历一个迭代器时,实际
上可能我们指的是要遍历一个序列,迭代器,或是一个支持迭代的对象(它有 next()方法)。


8.6.4 range() 内建函数
我们前面介绍 Python 的 for 循环的时候提到过它是一种迭代的循环机制. Python 同样提供
一个工具让我们在传统的伪条件设置下使用 for 声明, 例如从一个数字开始计数到另外个数字,
一旦到达最后的数字或者某个条件不再满足就立刻退出循环.
内建函数 range() 可以把类似 foreach 的 for 循环变成你更加熟悉的语句. 例如从 0 到
10 计数, 或者从 10 到 100 一次递增 5 .
=== range() 的完整语法===
Python 提供了两种不同的方法来调用 range() . 完整语法要求提供两个或三个整数参数:
range(start, end, step =1)
range() 会返回一个包含所有 k 的列表, 这里 start <= k < end , 从 start 到 end , k 每
次
递增 step . step 不可以为零,否则将发生错误.
>>> range(2, 19, 3)
[2, 5, 8, 11, 14, 17]
如果只给定两个参数,而省略 step, step 就使用默认值 1 .
>>> range(3, 7)
[3, 4, 5, 6]
我们来看看解释器环境下的例子
>>> for eachVal in range(2, 19, 3):
...       print "value is:", eachVal
...
value is: 2
value is: 5
value is: 8
value is: 11
value is: 14
value is: 17
我们的循环从 2 "数" 到 19 , 每次递增 3 . 如果你对 C 熟悉的话, 你会发现,range()的参
数与 C 的 for 循环变量有着直接的关系:


/* equivalent loop in C */
for (eachVal = 2; eachVal < 19; eachVal += 3) {
printf("value is: %d\n", eachVal);
}
虽然看起来像是一个条件循环(检查 eachVal< 19 ), 但实际上是 range() 先用我们指定的条
件生成一个列表, 然后把列表用于这个 for 语句.
===range() 简略语法===
range() 还有两种简略的语法格式:
range(end)
range(start, end)
我们在第 2 章看到过最短的语法 接受一个值, start 默认为 0 , step 默认为 1 , 然后
range()返回从 0 到 end 的数列.
>>> range(5)
[0, 1, 2, 3, 4]
range() 的中型版本和完整版本几乎完全一样, 只是 step 使用默认值 1 . 现在我们在
Python 解释器中试下这条语句:
>>> for count in range(2, 5):
...       print count
...
2
3
4
核心笔记: 为什么 range() 不是只有一种语法?
你已经知道了 range() 的所有语法, 有些人可能会问一个挑剔的问题, 为什么不把这两种语
法合并成一个下面这样的语法?
range(start=0, end, step =1) # 错误
这个语法不可以使用两个参数调用. 因为 step 要求给定 start . 换句话说, 你不能只传递
end 和 step 参数. 因为它们会被解释器误认为是 start 和 end .


8.6.5 xrange() 内建函数
xrange() 类似 range() , 不过当你有一个很大的范围列表时, xrange() 可能更为适合, 因为
它不会在内存里创建列表的完整拷贝. 它只被用在 for 循环中, 在 for 循环外使用它没有意义。
同样地, 你可以想到, 它的性能远高出 range(), 因为它不生成整个列表。在 Python 的将来版本
中, range() 可能会像 xrange() 一样, 返回一个可迭代对象(不是列表也不是一个迭代器) - 它会
像前边一章讨论的那样.
8.6.6 与序列相关的内建函数
sorted(), reversed(), enumerate(), zip()
下边是使用循环相关和序列相关函数的例子. 为什么它们叫"序列相关"呢? 是因为其中两个函
数( sorted() 和 zip() )返回一个序列(列表), 而另外两个函数( reversed() 和 enumerate() )
返回迭代器(类似序列)
>>> albums = ('Poe', 'Gaudi', 'Freud', 'Poe2')
>>> years = (1976, 1987, 1990, 2003)
>>> for album in sorted(albums):
...        print album,
...
Freud Gaudi Poe Poe2
>>>
>>> for album in reversed(albums):
...      print album,
...
Poe2 Freud Gaudi Poe
>>>
>>> for i, album in enumerate(albums):
...      print i, album
...
0 Poe
1 Gaudi
2 Freud
3 Poe2
>>>
>>> for album, yr in zip(albums, years):
...      print yr, album
...


1976  Poe
1987  Gaudi
1990  Freud
2003  Poe2
我们已经涵盖了 Python 中的所有循环语句, 下面我们看看循环相关的语句, 包括用于放弃循
环的 break 语句, 和立即开始下一次迭代的 continue 语句.
8.7 break 语句
Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break .
常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可
以用在 while 和 for 循环中.
count = num / 2
while count > 0:
if num % count == 0:
print count, 'is the largest factor of', num
break
count -= 1
上边这段代码用于寻找给定数字 num 的最大约数. 我们迭代所有可能的约数, count 变量依次
递减, 第一个能整除 num 的就是我们要找的最大约数,找到后就不再再继续找了, 使用 break 语
句退出循环.
phone2remove = '555-1212'
for eachPhone in phoneList:
if eachPhone == phone2remove:
print "found", phone2remove, '... deleting'
deleteFromPhoneDB(phone2remove)
break
这里的 break 语句用于打断列表的迭代. 目的是为了找到列表中的目标元素, 如果找到, 则
把它从数据库里删除然后退出循环.
8.8 continue 语句
核心笔记: continue 语句


不管是 Python, C, Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样
的一个误解:continue 语句"立即启动循环的下一次迭代". 实际上, 当遇到 continue 语句时, 程
序会终止当前循环,并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前,如果是条件循
环, 我们将验证条件表达式.如果是迭代循环,我们将验证是否还有元素可以迭代. 只有在验证成功
的情况下, 我们才会开始下一次迭代.
Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被
用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开
始下一次循环前要满足一些先决条件(前边的核心笔记中强调的), 否则循环会正常结束.
valid = False
count = 3
while count > 0:
input = raw_input("enter password")
# check for valid passwd
for eachPasswd in passwdList:
if input == eachPasswd:
valid = True
break
if not valid: # (or valid == 0)
print "invalid input"
count -= 1
continue
else:
break
这里例子结合使用了 while , for , if , break 以及 continue , 用来验证用户输入. 用
户有三次机会来输入正确的密码, 如果失败, 那么 valid 变量将仍为一个布尔假( 0 ), 然后我们
可以采取必要的操作阻止用户猜测密码.
8.9 pass 语句
Python 还提供了 pass 语句( C 中没有提供对应的语句). Python 没有使用传统的大括号来标
记代码块, 有时,有些地方在语法上要求要有代码, 而 Python 中没有对应的空大括号或是分号( ; )
来表示 C 语言中的 "不做任何事" , 如果你在需要子语句块的地方不写任何语句, 解释器会提示你
语法错误. 因此, Python 提供了 pass 语句, 它不做任何事情 - 即 NOP , ( No OPeration , 无
操作) 我们从汇编语言中借用这个概念. pass 同样也可作为开发中的小技巧, 标记你后来要完成的
代码, 例如这样:


def foo_func():
pass
或是
if user_choice == 'do_calc':
pass else:
pass
这样的代码结构在开发和调试时很有用, 因为编写代码的时候你可能要先把结构定下来,但你
不希望它干扰其他已经完成的代码. 在不需要它做任何事情地方, 放一个 pass 将是一个很好的主
意.
另外它在异常处理中也被经常用到, 我们将在第 10 章中详细介绍; 比如你跟踪到了一个非致
命的错误, 不想采取任何措施(你只是想记录一下事件或是在内部进行处理).
8.10 再谈 else 语句
在 C (以及大多其他语言中), 你不会在条件语句范围外发现 else 语句, 但 Python 不同,
你可以在 while 和 for 循环中使用 else 语句. 它们是怎么工作的呢? 在循环中使用时, else
子句只在循环完成后执行, 也就是说 break 语句也会跳过 else 块.
展示 while 语句中 else 用法的一个例子就是寻找一个数的最大约数. 我们已经实现了完成
这个任务的函数, 使用 while 循环和 else 语句. Example 8.1 (maxFact.py) 利用这个语法完成
了 showMaxFactor() 函数.
Example 8.1 while-else Loop Example (maxFact.py)
这个程序显示出 10 到 20 中的数字的最大约数. 该脚本也会提示这个数是否为素数.
1 #!/usr/bin/env python
2
3 def showMaxFactor(num):
4 count = num / 2
5 while count > 1:
6 if num % count == 0:
7 print 'largest factor of %d is %d' % \
8 (num, count)
9 break
10 count -= 1


11 else:
12 print num, "is prime"
13
14 for eachNum in range(10, 21):
15 showMaxFactor(eachNum)
showMaxFactor() 函数中第 3 行的循环从 amount 的一半开始计数(这样就可以检查这个数是否
可以被 2 整除, 如果可以,那就找到了最大的约数). 然后循环每次递减 1 (第 10 行), 直到发现
约数(第 6-9 行). 如果循环递减到 1 还没有找到约数, 那么这个数一定是素数. 11-12 行的 else
子句负责处理这样的情况. 程序的主体( 14-15 行)用数字参数调用 showMaxFactor() .
执行该程序将得到这样的输出:
largest factor of 10 is 5
11 is prime
largest factor of 12 is 6
13 is prime
largest factor of 14 is 7
largest factor of 15 is 5
largest factor of 16 is 8
17 is prime
largest factor of 18 is 9
19 is prime
largest factor of 20 is 10
同样地, for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的
else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行. 我们在
8.5.3 已经见过这样的例子
表 8.1 条件及循环语句中的辅助语句总结
a.   pass 在任何需要语句块(一个或多个语句)的地方都可以使用(例如 elif , else , clasa ,


def , try , except , finally ).
8.11    迭代器和 iter() 函数
8.11.1     什么是迭代器?
迭代器是在版本 2.2 被加入 Python 的, 它为类序列对象提供了一个类序列的接口. 我们在
前边的第 6 章已经正式地介绍过序列. 它们是一组数据结构,你可以利用它们的索引从 0 开始一直
"迭代" 到序列的最后一个条目. 用"计数"的方法迭代序列是很简单的. Python 的迭代无缝地支持
序列对象, 而且它还允许程序员迭代非序列类型, 包括用户定义的对象.
迭代器用起来很灵巧, 你可以迭代不是序列但表现出序列行为的对象, 例如字典的 key , 一个
文件的行, 等等. 当你使用循环迭代一个对象条目时, 你几乎不可能分辨出它是迭代器还是序列.
你不必去关注这些, 因为 Python 让它象一个序列那样操作.
8.11.2 为什么要迭代器?
援引 PEP (234) 中对迭代器的定义:
z   提供了可扩展的迭代器接口.
z   对列表迭代带来了性能上的增强.
z   在字典迭代中性能提升.
z   创建真正的迭代接口, 而不是原来的随机对象访问.
z  与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容
z  迭代非序列集合(例如映射和文件)时, 可以创建更简洁可读的代码.
8.11.3 如何迭代?
根本上说, 迭代器就是有一个 next() 方法的对象, 而不是通过索引来计数. 当你或是一个循
环机制(例如 for 语句)需要下一个项时, 调用迭代器的 next() 方法就可以获得它. 条目全部取
出后, 会引发一个 StopIteration 异常, 这并不表示错误发生, 只是告诉外部调用者, 迭代完成.
不过, 迭代器也有一些限制. 例如你不能向后移动, 不能回到开始, 也不能复制一个迭代器.
如果你要再次(或者是同时)迭代同个对象, 你只能去创建另一个迭代器对象. 不过, 这并不糟糕,


因为还有其他的工具来帮助你使用迭代器.
reversed() 内建函数将返回一个反序访问的迭代器. enumerate() 内建函数同样也返回迭代器.
另外两个新的内建函数, any() 和 all() , 在 Python 2.5 中新增, 如果迭代器中某个/所有条目
的值都为布尔真时,则它们返回值为真. 本章先前部分我们展示了如何在 for 循环中通过索引或是
可迭代对象来遍历条目. 同时 Python 还提供了一整个 itertools 模块, 它包含各种有用的迭代
器.
8.11.4 使用迭代器
===序列===
正如先前提到的, 迭代 Python 的序列对象和你想像的一样:
>>> myTuple = (123, 'xyz', 45.67)
>>> i = iter(myTuple)
>>> i.next()
123
>>> i.next()
'xyz'
>>> i.next()
45.67
>>> i.next()
Traceback (most recent call last):
File "", line 1, in ?
StopIteration
如果这是一个实际应用程序, 那么我们需要把代码放在一个 try-except 块中. 序列现在会自
动地产生它们自己的迭代器, 所以一个 for 循环:
for i in seq:
do_something_to(i)
实际上是这样工作的:
fetch = iter(seq)
while True:
try:
i = fetch.next()
except StopIteration:


break
do_something_to(i)
不过, 你不需要改动你的代码, 因为 for 循环会自动调用迭代器的 next() 方法(以及监视
StopIteration 异常).
===字典===
字典和文件是另外两个可迭代的 Python 数据类型. 字典的迭代器会遍历它的键(keys).
语句 for eachKey in myDict.keys() 可以缩写为 for eachKey in myDict , 例如:
>>> legends = { ('Poe', 'author'): (1809, 1849, 1976),
... ('Gaudi', 'architect'): (1852, 1906, 1987),
... ('Freud', 'psychoanalyst'): (1856, 1939, 1990)
... }
...
>>> for eachLegend in legends:
...       print 'Name: %s\tOccupation: %s' % eachLegend
...         print ' Birth: %s\tDeath: %s\tAlbum: %s\n' \
...         % legends[eachLegend]
...
Name: Freud Occupation: psychoanalyst
Birth: 1856 Death: 1939 Album: 1990
Name: Poe Occupation: author
Birth: 1809 Death: 1849 Album: 1976
Name: Gaudi Occupation: architect
Birth: 1852 Death: 1906 Album: 1987
另外, Python 还引进了三个新的内建字典方法来定义迭代: myDict.iterkeys() (通过 keys 迭
代), myDict.itervalues() (通过 values 迭代), 以及 myDicit.iteritems() (通过 key/value 对
来 迭 代 ). 注 意 , in 操 作 符 也 可 以 用 于 检 查 字 典 的 key 是 否 存 在 , 之 前 的 布 尔 表 达 式
myDict.has_key(anyKey) 可以被简写为 anyKey in myDict .
===文件===
文件对象生成的迭代器会自动调用 readline() 方法. 这样, 循环就可以访问文本文件的所有
行 . 程 序 员 可 以 使 用 更 简 单 的 for eachLine in myFile 替 换 for eachLine in
myFile.readlines() :


>>> myFile = open('config-win.txt')
>>> for eachLine in myFile:
...      print eachLine, # comma suppresses extra \n
...
[EditorWindow]
font-name: courier new
font-size: 10
>>> myFile.close()
8.11.5 可变对象和迭代器
记住,在迭代可变对象的时候修改它们并不是个好主意. 这在迭代器出现之前就是一个问题.
一个流行的例子就是循环列表的时候删除满足(或不满足)特定条件的项:
for eachURL in allURLs:
if not eachURL.startswith('http://'):
allURLs.remove(eachURL)       # YIKES!!
除列表外的其他序列都是不可变的, 所以危险就发生在这里. 一个序列的迭代器只是记录你
当前到达第多少个元素, 所以如果你在迭代时改变了元素, 更新会立即反映到你所迭代的条目上.
在迭代字典的 key 时, 你绝对不能改变这个字典. 使用字典的 keys() 方法是可以的, 因为
keys() 返回一个独立于字典的列表. 而迭代器是与实际对象绑定在一起的, 它将不会继续执行下
去:
>>> myDict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> for eachKey in myDict:
...      print eachKey, myDict[eachKey]
...      del myDict[eachKey]
... a 1
Traceback (most recent call last):
File "", line 1, in ?
RuntimeError: dictionary changed size during iteration
这样可以避免有缺陷的代码. 更多有关迭代器的细节请参阅 PEP 234 .
8.11.6 如何创建迭代器
对一个对象调用 iter() 就可以得到它的迭代器. 它的语法如下:


iter(obj)
iter(func, sentinel )
如果你传递一个参数给 iter() , 它会检查你传递的是不是一个序列, 如果是, 那么很简单:
根据索引从 0 一直迭代到序列结束. 另一个创建迭代器的方法是使用类, 我们将在第 13 章详细
介绍, 一个实现了 __iter__() 和 next() 方法的类可以作为迭代器使用.
如 果 是 传 递 两 个 参 数 给 iter() , 它 会 重 复 地 调 用 func , 直 到 迭 代 器 的 下 个 值 等 于
sentinel .
8.12 列表解析
列表解析( List comprehensions, 或缩略为 list comps ) 来自函数式编程语言 Haskell . 它
是一个非常有用, 简单, 而且灵活的工具, 可以用来动态地创建列表. 它在 Python 2.0 中被加入.
在第 11 章, 函数中, 我们将讨论 Python 早就支持的函数式编程特性, 例如 lambda , map() ,
以及 filter() 等, 这些存在于 Python 中已经很长时间了, 但通过列表解析 , 它们可以被简化
为一个列表解析式子. map() 对所有的列表成员应用一个操作, filter() 基于一个条件表达式过
滤列表成员. 最后, lambda 允许你快速地创建只有一行的函数对象. 你不需要现在就去掌握这些,
在本节中你将看到它们出现在例子里, 因为我们需要讨论列表解析的优势. 首先让我们看看列表
解析的语法:
[expr for iter_var in iterable]
这个语句的核心是 for 循环, 它迭代 iterable 对象的所有条目. 前边的 expr 应用于序列
的每个成员, 最后的结果值是该表达式产生的列表. 迭代变量并不需要是表达式的一部分.
这里用到了第 11 章的一些代码. 它有一个计算序列成员的平方的 lambda 函数表达式:
>>> map(lambda x: x ** 2, range(6))
[0, 1, 4, 9, 16, 25]
我们可以使用下面这样的列表解析来替换它:
>>> [x ** 2 for x in range(6)]
[0, 1, 4, 9, 16, 25]
在新语句中, 只有一次函数调用( range() ), 而先前的语句中有三次函数调用(range() ,
map() , 以及 lambda ). 你也可以用括号包住表达式, 象 [(x ** 2) for x in range(6)] 这样, 更


便于阅读. 列表解析的表达式可以取代内建的 map() 函数以及 lambda , 而且效率更高. 结合 if
语句,列表解析还提供了一个扩展版本的语法:
[expr for iter_var in iterable if cond_expr]
这个语法在迭代时会过滤/捕获满足条件表达式 cond_expr 的序列成员.
回想下 odd() 函数, 它用于判断一个数值对象是奇数还是偶数(奇数返回 1 , 偶数返回 0 ):
def odd(n):
return n % 2
我们可以借用这个函数的核心操作, 使用 filter() 和 lambda 挑选出序列中的奇数:
>>> seq = [11, 10, 9, 9, 10, 10, 9, 8, 23, 9, 7, 18, 12, 11, 12]
>>> filter(lambda x: x % 2, seq)
[11, 9, 9, 9, 23, 9, 7, 11]
和先前的例子一样, 即使不用 filter() 和 lambda,我们同样可以使用列表解析来完成操作,
获得想要的数字:
>>> [x for x in seq if x % 2]
[11, 9, 9, 9, 23, 9, 7, 11]
我们使用更多实用的例子结束这节.
===矩阵样例===
你需要迭代一个有三行五列的矩阵么? 很简单:
>>> [(x+1,y+1) for x in range(3) for y in range(5)]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2,
3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)]
===磁盘文件样例===
假设我们有如下这样一个数据文件 hhga.txt , 需要计算出所有非空白字符的数目:
And the Lord spake, saying, "First shalt thou take
out the Holy Pin. Then shalt thou count to three,


no more, no less. Three shall be the number thou shalt
count, and the number of the counting shall be three.
Four shalt thou not count, nei- ther count thou two,
excepting that thou then proceed to three. Five is
right out. Once the number three, being the third
number, be reached, then lobbest thou thy Holy Hand
Grenade of Antioch towards thy foe, who, being
naughty in My sight, shall snuff it."
我们已经知道可以通过 for line in data 迭代文件内容, 不过, 除了这个, 我们还可以把每
行分割( split )为单词, 然后我们可以像这样计算单词个数:
>>> f = open('hhga.txt', 'r')
>>> len([word for line in f for word in line.split()])
91
快速地计算文件大小
import os
>>> os.stat('hhga.txt').st_size
499L
假定文件中至少有一个空白字符, 我们知道文件中有少于 499 个非空字符. 我们可以把每个
单词的长度加起来, 得到和.
>>> f.seek(0)
>>> sum([len(word) for line in f for word in line.split()])
408
这里我们用 seek() 函数回到文件的开头, 因为迭代器已经访问完了文件的所有行. 一个清晰
明了的列表解析完成了之前需要许多行代码才能完成的工作! 如你所见, 列表解析支持多重嵌套
for 循环以及多个 if 子句. 完整的语法可以在官方文档中找到. 你也可以在 PEP 202 中找到更多
关于列表解析的资料.
8.13 生成器表达式
生成器表达式是列表解析的一个扩展. 在 Python 2.0 中我们加入了列表解析, 使语言有了一
次革命化的发展, 提供给用户了一个强大的工具, 只用一行代码就可以创建包含特定内容的列表.
你可以去问一个有多年 Python 经验的程序员是什么改变了他们编写 Python 程序的方式, 那么列


表解析一定会是最多的答案.
另个在 Python 版本 2.2 时被加入的另一个重要特性是生成器. 生成器是特定的函数, 允许
你返回一个值, 然后"暂停"代码的执行, 稍后恢复. 我们将在第 11 章中讨论生成器.
列表解析的一个不足就是必要生成所有的数据, 用以创建整个列表. 这可能对有大量数据的迭
代器有负面效应. 生成器表达式通过结合列表解析和生成器解决了这个问题.
生成器表达式在 Python 2.4 被引入, 它与列表解析非常相似,而且它们的基本语法基本相同;
不过它并不真正创建数字列表, 而是返回一个生成器,这个生成器在每次计算出一个条目后,把这
个条目“产生”(yield)出来. 生成器表达式使用了"延迟计算"(lazy evaluation), 所以它在使用
内存上更有效. 我们来看看它和列表解析到底有多相似:
列表解析:
[expr for iter_var in iterable if cond_expr]
生成器表达式:
(expr for iter_var in iterable if cond_expr)
生成器并不会让列表解析废弃, 它只是一个内存使用更友好的结构, 基于此, 有很多使用生
成器地方. 下面我们提供了一些使用生成器表达式的例子, 最后例举一个冗长的样例, 从它你可
以感觉到 Python 代码在这些年来的变化.
===磁盘文件样例===
在前边列表解析一节, 我们计算文本文件中非空白字符总和. 最后的代码中, 我们展示了如何
使用一行列表解析代码做所有的事. 如果这个文件的大小变得很大, 那么这行代码的内存性能会很
低, 因为我们要创建一个很长的列表用于存放单词的长度.
为了避免创建庞大的列表, 我们可以使用生成器表达式来完成求和操作. 它会计算每个单词的
长度然后传递给 sum() 函数(它的参数不仅可以是列表,还可以是可迭代对象,比如生成器表达式).
这样, 我们可以得到优化后的代码(代码长度, 还有执行效率都很高效):
>>> sum(len(word) for line in data for word in line.split())
408
我们所做的只是把方括号删除: 少了两字节, 而且更节省内存 ... 非常地环保!
=== 交叉配对例子 ===


生成器表达式就好像是懒惰的列表解析(这反而成了它主要的优势). 它还可以用来处理其他列
表或生成器, 例如这里的 rows 和 cols :
rows = [1, 2, 3, 17]
def cols(): # example of simple generator
yield 56
yield 2
yield 1
不需要创建新的列表, 直接就可以创建配对. 我们可以使用下面的生成器表达式:
x_product_pairs = ((i, j) for i in rows for j in cols())
现在我们可以循环 x_product_pairs , 它会懒惰地循环 rows 和 cols :
>>> for pair in x_product_pairs:
...      print pair
...
(1, 56)
(1, 2)
(1, 1)
(2, 56)
(2, 2)
(2, 1)
(3, 56)
(3, 2)
(3, 1)
(17, 56)
(17, 2)
(17, 1)
===  重构样例 ===
我们通过一个寻找文件最长的行的例子来看看如何改进代码. 在以前, 我们这样读取文件:
f = open('/etc/motd', 'r')
longest = 0
while True:
linelen = len(f.readline().strip())


if not linelen:
break
if linelen > longest:
longest = linelen
f.close()
return longest
事实上, 这还不够老. 真正的旧版本 Python 代码中, 布尔常量应该写是整数 1 , 而且我们应
该使用 string 模块而不是字符串的 strip() 方法:
import string
:
len(string.strip(f.readline()))
从那时起, 我们认识到如果读取了所有的行, 那么应该尽早释放文件资源. 如果这是一个很多
进程都要用到的日志文件, 那么理所当然我们不能一直拿着它的句柄不释放. 是的, 我们的例子是
用来展示的, 但是你应该得到这个理念. 所以读取文件的行的首选方法应该是这样:
f = open('/etc/motd', 'r')
longest = 0
allLines = f.readlines()
f.close()
for line in allLines:
linelen = len(line.strip())
if linelen > longest:
longest = linelen
return longest
列表解析允许我们稍微简化我们代码, 而且我们可以在得到行的集合前做一定的处理. 在下段
代码中, 除了读取文件中的行之外,我们还调用了字符串的 strip() 方法处理行内容.
f = open('/etc/motd', 'r')
longest = 0
allLines = [x.strip() for x in f.readlines()]
f.close()
for line in allLines:
linelen = len(line)
if linelen > longest:
longest = linelen
return longest


然而, 两个例子在处理大文件时候都有问题, 因为 readlines() 会读取文件的所有行. 后来
我们有了迭代器, 文件本身就成为了它自己的迭代器, 不需要调用 readlines() 函数. 我们已经
做到了这一步, 为什么不去直接获得行长度的集合呢(之前我们得到的是行的集合)? 这样, 我们就
可以使用 max() 内建函数得到最长的字符串长度:
f = open('/etc/motd', 'r')
allLineLens = [len(x.strip()) for x in f]
f.close()
return max(allLineLens)
这里唯一的问题就是你一行一行迭代 f 的时候, 列表解析需要文件的所有行读取到内存中,
然后生成列表. 我们可以进一步简化代码: 使用生成器表达式替换列表解析, 然后把它移到 max()
函数里, 这样, 所有的核心部分只有一行:
f = open('/etc/motd', 'r')
longest = max(len(x.strip()) for x in f)
f.close()
return longest
最后, 我们可以去掉文件打开模式(默认为读取), 然后让 Python 去处理打开的文件. 当然,
文件用于写入的时候不能这么做, 但这里我们不需要考虑太多:
return max(len(x.strip()) for x in open('/etc/motd'))
我们走了好长一段路. 注意,即便是这只有一行的 Python 程序也不是很晦涩. 生成器表达式
在 Python 2.4 中被加入, 你可以在 PEP 289 中找到更多相关内容.
8.14 R 相关模块
Python 2.2 引进了迭代器, 在下一个发行 (2.3) 中, itertools 模块被加入, 用来帮助那些
发现迭代器威力但又需要一些辅助工具的开发者. 有趣的是如果你阅读关于 itertools 中实用程
序的文档, 你会发现生成器. 所以在迭代器和生成器间有一定的联系. 你可以在第 11 章 "函数"
中了解更多.
8.15     练习
8–1.    条件语句. 请看下边的代码


# statement A
if x > 0:
# statement  B
pass
elif x < 0:
# statement  C
pass
else:
# statement  D
pass
# statement  E
(a)如果 x< 0 , 上面哪个语句(A, B, C, D, E)将被执行
(b)如果 x== 0 , 上面哪个居于将被执行?
(c)如果 x> 0 , 上面哪个语句将被执行?
8–2. 循环. 编写一个程序, 让用户输入三个数字: (f)rom, (t)o, 和 (i)ncrement . 以 i
为步长, 从 f 计数到 t , 包括 f 和 t . 例如, 如果输入的是 f == 2, t == 26, i == 4 , 程序
将输出 2, 6, 10, 14, 18, 22, 26.
8–3.     range() . 如果我们需要生成下面的这些列表, 分别需要在 range() 内建函数中提
供那些参数?
(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
(b) [3, 6, 9, 12, 15, 18]
(c) [-20, 200, 420, 640, 860]
8–4.     素数. 我们在本章已经给出了一些代码来确定一个数字的最大约数或者它是否是一个
素数. 请把相关代码转换为一个返回值为布尔值的函数,函数名为 isprime() . 如果输入的是一个
素数, 那么返回 True , 否则返回 False .
8–5.     约数. 完成一个名为 getfactors() 的函数. 它接受一个整数作为参数, 返回它所有
约数的列表, 包括 1 和它本身,
8–6.     素因子分解. 以刚才练习中的 isprime() 和 getfactors() 函数为基础编写一个函
数, 它接受一个整数作为参数, 返回该整数所有素数因子的列表. 这个过程叫做求素因子分解, 它
输出的所有因子之积应该是原来的数字. 注意列表里可能有重复的元素. 例如输入 20 , 返回结果
应该是 [2, 2, 5] .
8–7.     全数. 完全数被定义为这样的数字: 它的约数(不包括它自己)之和为它本身. 例如: 6
的约数是 1, 2, 3, 因为 1 + 2 + 3 = 6 , 所以 6 被认为是一个完全数. 编写一个名为 isperfect()


的函数, 它接受一个整数作为参数, 如果这个数字是完全数, 返回 1 ; 否则返回 0 .
8–8.     阶乘. 一个数的阶乘被定义为从 1 到该数字所有数字的乘积. N 的阶乘简写为 N! .
写一个函数, 指定 N, 返回 N! 的值.
8–9.     Fibonacci 数列. Fibonacci 数列形如 1, 1, 2, 3, 5, 8, 13, 21, 等等. 也就是说,
下一个值是序列中前两个值之和. 写一个函数, 给定 N , 返回第 N 个 Fibonacci 数字. 例如, 第
1 个 Fibonacci 数字是 1 , 第 6 个是 8 .
8–10.     文本处理. 统计一句话中的元音, 辅音以及单词(以空格分割)的个数. 忽略元音和
辅音的特殊情况, 如 "h", "y", "qu" 等. 附加题: 编写处理这些特殊情况的代码.
8–11. 文本处理. 要求输入一个姓名列表,输入格式是“Last Name, First Name,” 即 姓,
逗号, 名. 编写程序处理输入, 如果用户输入错误, 比如“First Name Last Name,” , 请纠正这
些错误, 并通知用户. 同时你还需要记录输入错误次数. 当用户输入结束后, 给列表排序, 然后以
"姓 , 名" 的顺序显示.
输入输出示例(你不需要完全按照这里里例子完成):
% nametrack.py
Enter total number of names: 5
Please enter name 0: Smith, Joe
Please enter name 1: Mary Wong
>> Wrong format... should be Last, First.
>> You have done this 1 time(s) already. Fixing input... Please enter name 2: Hamilton,
Gerald
Please enter name 3: Royce, Linda
Please enter name 4: Winston Salem
>> Wrong format... should be Last, First.
>> You have done this 2 time(s) already. Fixing input...
The sorted list (by last name) is:
Hamilton, Gerald
Royce, Linda
Salem, Winston
Smith, Joe
Wong, Mary
8–12. (整数)位操作. 编写一个程序, 用户给出起始和结束数字后给出一个下面这样的表格,
分别显示出两个数字间所有整数的十进制, 二进制, 八进制和十六进制表示. 如果字符是可打印的
ASCII 字符, 也要把它打印出来, 如果没有一个是可打印字符, 就省略掉 ASCII 那一栏的表头.


请参考下面的输入输出格式:
8–13. 程序执行性能. 在 8.5.2 节里, 我们介绍了两种基本的迭代序列方法: (1) 通过序列
项, 以及 (2) 通过序列索引遍历. 该小节的末尾我们指出后一种方法在序列很长的时候性能不佳.
(在我的系统下, 性能差了将近两倍[83%]) 你认为它的原因是什么?


文件和输入输出 





本章主题
z 文件对象
z 文件内建函数
z 文件内建方法
z 文件内建属性
z 标准文件
z 命令行参数
z 文件系统
z 文件执行
z 持久存储
z 相关模块


本章将深入介绍 Python 的文件处理和相关输入输出能力. 我们将介绍文件对象(它的内建函
数, 内建方法和属性), 标准文件, 同时讨论文件系统的访问方法, 文件执行, 最后 简洁地涉及持
久存储和标准库中与文件有关的模块.
9.1 文件对象
文件对象不仅可以用来访问普通的磁盘文件, 而且也可以访问任何其它类型抽象层面上的"文
件". 一旦设置了合适的"钩子", 你就可以访问具有文件类型接口的其它对象, 就好像访问的是普
通文件一样.
随着你使用 Python 经验的增长. 您会遇到很多处理"类文件"对象的情况. 有很多这样的例子,
例如实时地"打开一个 URL"来读取 Web 页面,在另一个独立的进程中执行一个命令进行通讯, 就好
像是两个同时打开的文件, 一个用于读取, 另个用于写入.
内建函数 open() 返回一个文件对象(参见下一小节), 对该文件进行后继相关的操作都要用到
它. 还有大量的函数也会返回文件对象或是类文件( file-like )对象. 进行这种抽象处理的主要原
因是许多的输入/输出数据结构更趋向于使用通用的接口. 这样就可以在程序行为和实现上保持一
致性. 甚至像 Unix 这样的操作系统把文件作为通信的底层架构接口. 请记住, 文件只是连续的字
节序列. 数据的传输经常会用到字节流, 无论字节流是由单个字节还是大块数据组成.
9.2  文件内建函数[open()和 file()]


作为打开文件之门的"钥匙", 内建函数 open() [以及 file() ]提供了初始化输入/输出(I/O)
操作的通用接口. open() 内建函数成功打开文件后时候会返回一个文件对象, 否则引发一个错误.
当操作失败, Python 会产生一个 IOError 异常 - 我们会在下一章讨论错误和异常的处理. 内建函
数 open() 的基本语法是:
file_object = open(file_name, access_mode='r', buffering=-1)
file_name 是包含要打开的文件名字的字符串, 它可以是相对路径或者绝对路径. 可选变量
access_mode 也是一个字符串, 代表文件打开的模式. 通常, 文件使用模式 'r', 'w', 或是 'a'
模式来打开, 分别代表读取, 写入和追加. 还有个 'U' 模式, 代表通用换行符支持(见下).
使用 'r' 或 'U' 模式打开的文件必须是已经存在的. 使用 'w' 模式打开的文件若存在则首
先清空, 然后(重新)创建. 以 'a' 模式打开的文件是为追加数据作准备的, 所有写入的数据都将
追加到文件的末尾. 即使你 seek 到了其它的地方. 如果文件不存在, 将被自动创建, 类似以 'w'
模式打开文件. 如果你是一个 C 程序员, 就会发现这些也是 C 库函数 fopen() 中使用的模式.
其它 fopen() 支持的模式也可以工作在 Python 的 open() 下. 包括 '+' 代表可读可写, 'b'
代表二进制模式访问. 关于 'b' 有一点需要说明, 对于所有 POSIX 兼容的 Unix 系统(包括
Linux)来说, 'b'是可由可无的, 因为它们把所有的文件当作二进制文件, 包括文本文件. 下面是
从 Linux 手册的 fopen() 函数使用中摘录的一段, Python 语言中的 open() 函数就是从它衍生
出的:
指示文件打开模式的字符串中也可以包含字符 "b" , 但它不能做为第一个字符出现.这样做的
目的是为了严格地满足 ANSI C3.159-1989 (即 ANSI C)中的规定; 事实上它没有任何效果, 所有
POSIX 兼容系统, 包括 Linux , 都会忽略 "b" (其它系统可能会区分文本文件和二进制文件, 如果
你要处理一个二进制文件, 并希望你的程序可以移植到其它非 Unix 的环境中, 加上"b" 会是不错的
主意)。
你可以在表 9.1 中找到关于文件访问模式的详细列表, 包括 'b' 的使用 - 如果你选择使用
它的话. 如果没有给定 access_mode , 它将自动采用默认值 'r' .
另外一个可选参数 buffering 用于指示访问文件所采用的缓冲方式. 其中 0 表示不缓冲, 1
表示只缓冲一行数据, 任何其它大于 1 的值代表使用给定值作为缓冲区大小. 不提供该参数或者
给定负值代表使用系统默认缓冲机制, 既对任何类电报机( tty )设备使用行缓冲, 其它设备使用正
常缓冲. 一般情况下使用系统默认方式即可.
表 9.1   文件对象的访问模式
文件模式           操作
r          以读方式打开


rU 或 Ua    以读方式打开, 同时提供通用换行符支持 (PEP 278)
w          以写方式打开 (必要时清空)
a          以追加模式打开 (从 EOF 开始, 必要时创建新文件)
r+         以读写模式打开
w+         以读写模式打开 (参见 w )
a+         以读写模式打开 (参见 a )
rb         以二进制读模式打开
wb         以二进制写模式打开 (参见 w )
ab         以二进制追加模式打开 (参见 a )
rb+        以二进制读写模式打开 (参见 r+ )
wb+        以二进制读写模式打开 (参见 w+ )
ab+        以二进制读写模式打开 (参见 a+ )
a.         Python 2.3 中新增
这里是一些打开文件的例子:
fp = open('/etc/motd') # 以读方式打开
fp = open('test', 'w') # 以写方式打开
fp = open('data', 'r+') # 以读写方式打开
fp = open(r'c:\io.sys', 'rb') # 以二进制读模式打开
9.2.1       工厂函数 file()
在 Python 2.2 中,类型和类被统一了起来,这时,加入了内建函数 file(). 当时, 很多的内
建类型没有对应的内建函数来创建对象的实例。例如 dict(), bool(), file(), 等等, 然而,另一
些却有对应的内建函数, 例如 list(), str(), 等等.
open() 和 file() 函数具有相同的功能, 可以任意替换.
您所看到任何使用 open() 的地方, 都可以使用 file() 替换它.
可以预见, 在 将来的 Python 版本中, open() 和 file() 函数会同时存在, 完成相同的功能.
一般说来, 我们建议使用 open() 来读写文件, 在您想说明您在处理文件对象时使用 file() , 例
如 if instance(f, file) .
9.2.2 通用换行符支持(UNS)
在下一个核心笔记中, 我们将介绍如何使用 os 模块的一些属性来帮助你在不同平台下访问文
件, 不同平台用来表示行结束的符号是不同的, 例如 \n, \r, 或者 \r\n . 所以, Python 的解释


器也要处理这样的任务, 特别是在导入模块时分外重要。 你难道不希望 Python 用相同的方式处理
所有文件吗?
这就是 UNS 的关键所在, 作为 PEP 278 的结果, Python 2.3 引入了 UNS. 当你使用 'U' 标志
打开文件的时候, 所有的行分割符(或行结束符, 无论它原来是什么)通过 Python 的输入方法(例
如 read*() )返回时都会被替换为换行符 NEWLINE(\n). ('rU' 模式也支持 'rb' 选项) . 这个特性
还支持包含不同类型行结束符的文件. 文件对象的 newlines 属性会记录它曾“看到的”文件的行结
束符.
如果文件刚被打开, 程序还没有遇到行结束符, 那么文件的 newlines 为 None .在第一行被读
取后, 它被设置为第一行的结束符. 如果遇到其它类型的行结束符, 文件的 newlines 会成为一个
包含每种格式的元组. 注意 UNS 只用于读取文本文件. 没有对应的处理文件输出的方法.
在编译 Python 的时候,UNS 默认是打开的. 如果你不需要这个特性, 在运行 configure 脚本
时,你可以使用 --without-universal-newlines 开关关闭它. 如果你非要自己处理行结束符, 请
查阅核心笔记,使用 os 模块的相关属性.
9.3 文件内建方法
open() 成功执行并返回一个文件对象之后, 所有对该文件的后续操作都将通过这个"句柄"进
行. 文件方法可以分为四类: 输入, 输出, 文件内移动, 以及杂项操作. 所有文件对象的总结被
列在了表 9.3 . 我们现在来讨论每个类的方法.
9.3.1 输入
read() 方法用来直接读取字节到字符串中, 最多读取给定数目个字节. 如果没有给定 size
参数(默认值为 -1)或者 size 值为负, 文件将被读取直至末尾. 未来的某个版本可能会删除此方
法.
readline() 方法读取打开文件的一行(读取下个行结束符之前的所有字节). 然后整行,包括行
结束符,作为字符串返回. 和 read() 相同, 它也有一个可选的 size 参数, 默认为 -1, 代表读至
行结束符. 如果提供了该参数, 那么在超过 size 个字节后会返回不完整的行.
readlines() 方法并不像其它两个输入方法一样返回一个字符串. 它会读取所有(剩余的)行然
后把它们作为一个字符串列表返回. 它的可选参数 sizhint 代表返回的最大字节大小. 如果它大
于 0 , 那么返回的所有行应该大约有 sizhint 字节(可能稍微大于这个数字, 因为需要凑齐缓冲区
大小).


Python 2.1 中加入了一个新的对象类型用来高效地迭代文件的行: xreadlines 对象(可以在
xreadlines 模 块 中 找 到 ). 调 用 file.xreadlines() 等 价 于 xreadlines.xreadlines(file).
xreadlines() 不是一次性读取取所有的行, 而是每次读取一块, 所以用在 for 循环时可以减少对
内存的占用. 不过, 随着 Python 2.3 中迭代器和文件迭代的引入, 没有必要再使用 xreadlines()
方法, 因为它和使用 iter(file) 的效果是一样的, 或者在 for 循环中, 使用 for eachLine in
file 代替它. 它来得容易,去得也快。
另个废弃的方法是 readinto() , 它读取给定数目的字节到一个可写的缓冲器对象, 和废弃的
buffer() 内建函数返回的对象是同个类型. (由于 buffer() 已经不再支持, 所以 readinto() 被
废弃.)
9.3.2 输出
write() 内建方法功能与 read() 和 readline() 相反. 它把含有文本数据或二进制数据块的
字符串写入到文件中去.
和 readlines() 一样,writelines() 方法是针对列表的操作, 它接受一个字符串列表作为参
数, 将它们写入文件. 行结束符并不会被自动加入, 所以如果需要的话, 你必须在调用
writelines()前给每行结尾加上行结束符.
注意这里并没有 "writeline()" 方法, 因为它等价于使用以行结束符结尾的单行字符串调用
write() 方法.
核心笔记:保留行分隔符
当使用输入方法如 read() 或者 readlines() 从文件中读取行时, Python 并不会删除行结束
符. 这个操作被留给了程序员. 例如这样的代码在 Python 程序中很常见:
f = open('myFile', 'r')
data = [line.strip() for line in f.readlines()]
f.close()
类似地, 输出方法 write() 或 writelines() 也不会自动加入行结束符. 你应该在向文件写
入数据前自己完成:
9.3.3     文件内移动
seek() 方法(类似 C 中的 fseek() 函数)可以在文件中移动文件指针到不同的位置. offset
字节代表相对于某个位置偏移量. 位置的默认值为 0 , 代表从文件开头算起(即绝对偏移量), 1 代
表从当前位置算起, 2 代表从文件末尾算起. 如果你是一个 C 程序员,并且使用过了 fseek() , 那


么,0, 1, 2 分别对应着常量 SEEK_SET, SEEK_CUR, 以及 SEEK_END. 当人们打开文件进行读写操
作的时候就会接触到 seek()方法。
text() 方法是对 seek() 的补充; 它告诉你当前文件指针在文件中的位置 - 从文件起始算起,
单位为字节.
9.3.3 文件迭代
一行一行访问文件很简单:
for eachLine in f:
:
在这个循环里, eachLine 代表文本文件的一行(包括末尾的行结束符),你可以使用它做任何想
做的事情.
在 Python 2.2 之前, 从文件中读取行的最好办法是使用 file.readlines() 来读取所有数据,
这样程序员可以尽快释放文件资源. 如果不需要这样做, 那么程序员可以调用 file.readline()
一次读取一行. 曾有一段很短的时间, file.xreadlines() 是读取文件最高效的方法.
在 Python 2.2 中, 我们引进了迭代器和文件迭代, 这使得一切变得完全不同, 文件对象成为
了它们自己的迭代器, 这意味着用户不必调用 read*() 方法就可以在 for 循环中迭代文件的每一行.
另外我们也可以使用迭代器的 next 方法, file.next() 可以用来读取文件的下一行. 和其它迭代
器一样, Python 也会在所有行迭代完成后引发 StopIteration 异常.
所以请记得, 如果你见到这样的代码, 这是"完成事情的老方法", 你可以安全地删除对
readline() 的调用.
for eachLine in f.readline():
:
文件迭代更为高效, 而且写(和读)这样的 Python 代码更容易. 如果你是 Python 新人, 那
么请使用这些新特性, 不必担心它们过去是如何.
9.3.5 其它
close() 通过关闭文件来结束对它的访问. Python 垃圾收集机制也会在文件对象的引用计数降
至零的时候自动关闭文件. 这在文件只有一个引用时发生, 例如 fp = open(...), 然后 fp 在原文


件显式地关闭前被赋了另一个文件对象. 良好的编程习惯要求在重新赋另个文件对象前关闭这个文
件. 如果你不显式地关闭文件, 那么你可能丢失输出缓冲区的数据.
fileno() 方法返回打开文件的描述符. 这是一个整数, 可以用在如 os 模块(                        os.read() )的
一些底层操作上.
调用 flush() 方法会直接把内部缓冲区中的数据立刻写入文件, 而不是被动地等待输出缓冲
区被写入. isatty() 是一个布尔内建函数, 当文件是一个类 tty 设备时返回 True , 否则返回
False . truncate() 方法将文件截取到当前文件指针位置或者到给定 size , 以字节为单位.
9.3.6     文件方法杂项
我们现在重新实现第二章中的第一个文件例子:
filename = raw_input('Enter file name: ')
f = open(filename, 'r')
allLines = f.readlines()
f.close()
for eachLine in allLines:
print eachLine, # suppress print’s NEWLINE
我们曾经介绍过这个程序. 与大多数标准的文件访问方法相比, 它的不同在于它读完所有的行
才开始向屏幕输出数据. 很明显如果文件很大, 这个方法并不好. 这时最好还是回到最可靠的方法:
使用文件迭代器, 每次只读取和显示一行:
filename = raw_input('Enter file name: ')
f = open(filename, 'r')
for eachLine in f:
print eachLine, f.close()
核心笔记: 行分隔符和其它文件系统的差异
操作系统间的差异之一是它们所支持的行分隔符不同. 在 POSIX (Unix 系列或 Mac OS X)系统
上, 行分隔符是 换行符 NEWLINE ( \n ) 字符. 在旧的 MacOS 下是 RETURN ( \r ) , 而 DOS 和
Wind32 系统下结合使用了两者 ( \r\n ). 检查一下你所使用的操作系统用什么行分隔符。
另个不同是路径分隔符(POSIX 使用 "/", DOS 和 Windows 使用 "\", 旧版本的 MacOS 使用
":"), 它用来分隔文件路径名, 标记当前目录和父目录.
当我们创建要跨这三个平台的应用的时候, 这些差异会让我们感觉非常麻烦(而且支持的平台
越多越麻烦)。幸运的是 Python 的 os 模块设计者已经帮我们想到了这些问题. os 模块有五个很
有用的属性. 它们被列在了表 9.2 中.


Table 9.2 有助于跨平台开发的 os 模块属性
os 模块属性        描述
linesep        用于在文件中分隔行的字符串
sep         用来分隔文件路径名的字符串
pathsep        用于分隔文件路径的字符串
curdir         当前工作目录的字符串名称
pardir         (当前工作目录的)父目录字符串名称
不管你使用的是什么平台, 只要你导入了 os 模块, 这些变量自动会被设置为正确的值, 减少
了你的麻烦.
还要提醒大家的是: print 语句默认在输出内容末尾后加一个换行符, 而在语句后加一个逗号
就可以避免这个行为. readline() 和 readlines() 函数不对行里的空白字符做任何处理(参见本章
练习), 所以你有必要加上逗号. 如果你省略逗号, 那么显示出的文本每行后会有两个换行符, 其
中一个是输入是附带的, 另个是 print 语句自动添加的.
文件对象还有一个 truncate() 方法, 它接受一个可选的 size 作为参数. 如果给定, 那么文
件将被截取到最多 size 字节处. 如果没有传递 size 参数, 那么默认将截取到文件的当前位置.
例如, 你刚打开了一个文件, 然后立即调用 truncate() 方法, 那么你的文件(内容)实际上被删除,
这时候你是其实是从 0 字节开始截取的( tell() 将会返回这个数值 ).
在学习下一小节之前, 我们再来看两个例子, 第一个展示了如何输出到文件, 第二个展示了
文件的输出和输入, 以及用于文件定位的 seek() 和 tell() 方法的使用.
filename = raw_input('Enter file name: ')
fobj = open(filename, 'w')
while True:
aLine = raw_input("Enter a line ('.' to quit): ")
if aLine != ".":
fobj.write('%s%s' % (aLine, os.linesep)
else:
break
fobj.close()
这里我们每次从用户接收一行输入, 然后将文本保存到文件中. 由于 raw_input()不会保留用
户 输 入 的 换 行 符 , 调 用 write() 方 法 时 必 须 加 上 换 行 符 。 而 且 , 在 键 盘 上 很 难 输 入 一 个
EOF(end-of-file)字符,所以,程序使用句号( . )作为文件结束的标志, 当用户输入句号后会自动
结束输入并关闭文件.
第二个例子以可读可写模式创建一个新的文件(可能是清空了一个现有的文件). 在向文件写入
数据后, 我们使用 seek() 方法在文件内部移动, 使用 tell() 方法展示我们的移动过程.


>>> f = open('/tmp/x', 'w+')
>>> f.tell()
0
>>> f.write('test line 1\n') # 加入一个长为 12 的字符串 [0-11]
>>> f.tell()
12
>>> f.write('test line 2\n') # 加入一个长为 12 的字符串 [12-23]
>>> f.tell()    # 告诉我们当前的位置
24
>>> f.seek(-12, 1) # 向后移 12 个字节
>>> f.tell()    # 到了第二行的开头
12
>>> f.readline()
'test line 2\012'
>>> f.seek(0, 0) # 回到最开始
>>> f.readline()
'test line 1\012'
>>> f.tell() # 又回到了第二行
12
>>> f.readline()
'test line 2\012'
>>> f.tell()    # 又到了结尾
24
>>> f.close() # 关闭文件
表 9.3 文件对象的内建方法列表
文件对象的方法                        操作
file.close()              关闭文件
file.fileno()             返回文件的描述符(file descriptor ,FD, 整数值)
file.flush()             刷新文件的内部缓冲区
file.isatty()            判断 file 是否是一个类 tty 设备
file.nexta()            返回文件的下一行(类似于 file.readline() ), 或在没有其它行时
引发 StopIteration 异常
file.read(size=-1)       从文件读取 size 个字节, 当未给定 size 或给定负值的时候, 读
取剩余的所有字节, 然后作为字符串返回
b
file.readinto (buf, size) 从文件读取 size 个字节到 buf 缓冲器(已不支持)
file.readline(size=-1)      从文件中读取并返回一行(包括行结束符), 或返回最大 size


个字符
file.readlines(sizhint=0)    读取文件的所有行并作为一个列表返回(包含所有的行结束
符); 如果给定 sizhint 且大于 0 , 那么将返回总和大约为
sizhint 字节的行(大小由缓冲器容量的下一个值决定)( 比
如说缓冲器的大小只能为 4K 的倍数,如果 sizhint 为 15k,则
最后返回的可能是 16k———译者按)
c
file.xreadlines ()           用于迭代, 可以替换 readlines() 的一个更高效的方法
file.seek(off, whence=0)     在文件中移动文件指针, 从 whence ( 0 代表文件其始, 1 代
表当前位置, 2 代表文件末尾)偏移 off 字节
file.tell()                    返回当前在文件中的位置
file.truncate(size=file.tell())      截取文件到最大 size 字节, 默认为当前文件位置
file.write(str)               向文件写入字符串
file.writelines(seq)          向文件写入字符串序列 seq ; seq 应该是一个返回字符串的
可迭代对象; 在 2.2 前, 它只是字符串的列表
a.   Python 2.2 中新增
b.   Python 1.5.2 中新增, 不再支持
c.   Python 2.1 中新增, 在 Python 2.3 中废弃
9.4 文件内建属性
文件对象除了方法之外,还有一些数据属性. 这些属性保存了文件对象相关的附加数据, 例如
文件名(file.name ), 文件的打开模式 ( file.mode ), 文件是否已被关闭 ( file.closed), 以及
一 个 标 志 变 量 , 它 可 以 决 定 使 用 print 语 句 打 印 下 一 行 前 是 否 要 加 入 一 个 空 白 字 符
( file.softspace ). 表 9.4 列出了这些属性并做了简短说明。
表 9.4 文件对象的属性
文件对象的属性               描述
file.closed         True 表示文件已经被关闭, 否则为 False
file.encodinga       文件所使用的编码 - 当 Unicode 字符串被写入数据时, 它们将自动使
用 file.encoding 转换为字节字符串; 若 file.encoding 为 None 时使
用系统默认编码
file.mode           文件打开时使用的访问模式
file.name           文件名
file.newlinesa       未读取到行分隔符时为 None , 只有一种行分隔符时为一个字符串, 当
文件有多种类型的行结束符时,则为一个包含所有当前所遇到的行结束
符的列表
file.softspace        为 0 表示在输出一数据后,要加上一个空格符,1 表示不加。这个属性


一般程序员用不着,由程序内部使用。
a.   New in Python 2.3.
9.5 标准文件
一般说来, 只要你的程序一执行, 那么你就可以访问三个标准文件. 它们分别是标准输入(一
般是键盘), 标准输出(到显示器的缓冲输出)和标准错误(到屏幕的非缓冲输出). (这里所说的"缓冲
"和"非缓冲"是指 open() 函数的第三个参数.) 这些文件沿用的是 C 语言中的命名, 分别为
stdin , stdout 和 stderr . 我们说"只要你的程序一执行就可以访问这三个标准文件", 意思是这
些文件已经被预先打开了, 只要知道它们的文件句柄就可以随时访问这些文件.
Python 中可以通过 sys 模块来访问这些文件的句柄. 导入 sys 模块以后, 就可以使用
sys.stdin , sys.stdout 和 sys.stderr 访问. print 语句通常是输出到 sys.stdout ; 而内建
raw_input() 则通常从 sys.stdin 接受输入.
记得 sys.* 是文件, 所以你必须自己处理好换行符. 而 print 语句会自动在要输出的字符串
后加上换行符。
9.6 命令行参数
sys 模块通过 sys.argv 属性提供了对命令行参数的访问。 命令行参数是调用某个程序时除程
序名以外的其它参数. 这样命名是有历史原因的, 在一个基于文本的环境里(比如 UNIX 操作系统
的 shell 环境或者 DOS-shell ), 这些参数和程序的文件名一同被输入的. 但在 IDE 或者 GUI 环
境中可能就不会是这样了, 大多 IDE 环境都提供一个用来输入"命令行参数"的窗口; 这些参数最
后会像命令行上执行那样被传递给程序.
熟悉 C 语言的读者可能会问了, "argc 哪去了?" argc 和 argv 分别代表参数个数(argument
count)和参数向量(argument vector). argv 变量代表一个从命令行上输入的各个参数组成的字符
串数组; argc 变量代表输入的参数个数. 在 Python 中, argc 其实就是 sys.argv 列表的长度,
而该列表的第一项 sys.argv[0] 永远是程序的名称.
总结如下:
z sys.argv 是命令行参数的列表
z len(sys.argv) 是命令行参数的个数(也就是 argc)
我们来创建这个名为 argv.py 的测试程序:


import sys
print 'you entered', len(sys.argv), 'arguments...'
print 'they were:', str(sys.argv)
下面是该脚本程序运行的输出:
$ argv.py 76 tales 85 hawk
you entered 5 arguments...
they were: ['argv.py', '76', 'tales', '85', 'hawk']
命令行参数有用吗? Unix 操作系统中的命令通常会接受输入, 执行一些功能, 然后把结果作为
流输出出来. 这些输出的结果还可能被作为下一个程序的输入数据, 在完成了一些其它处理后, 再
把新的输出送到下一个程序, 如此延伸下去. 各个程序的输出一般是不保存的, 这样可以节省大量
的磁盘空间, 各个程序的输出通常使用"管道"实现到下个程序输入的转换.
这是通过向命令行提供数据或是通过标准输入实现的. 当一个程序显示或是发送它的输出到标
准输出文件时, 内容就会出现在屏幕上 - 除非该程序被管道连接到下一个程序, 那么此时程序的
标准输出就成为下个程序的标准输入. 你现在明白了吧?
命令行参数使程序员可以在启动一个程序的时候对程序行为做出选择. 在大多情况下, 这些
执行操作都不需要人为干预, 通过批处理执行. 命令行参数配合程序选项可以实现这样的处理功
能. 让计算机在夜里有空闲时完成一些需要大量处理的工作.
Python 还提供了两个模块用来辅助处理命令行参数. 其中一个(最原始的)是 getopt 模块,
它更简单些, 但是不是很精细. 而 Python 2.3 引入的 optparse 模块提供了一个更强大的工具,
而且它更面向对象. 如果你只是用到一些简单的选项, 我们推荐 getopt , 但如果你需要提供复杂
的选项, 那么请参阅 optparse .
9.7 文件系统
对文件系统的访问大多通过 Python 的 os 模块实现. 该模块是 Python 访问操作系统功能的主
要接口. os 模块实际上只是真正加载的模块的前端, 而真正的那个"模块"明显要依赖与具体的操作
系统. 这个"真正"的模块可能是以下几种之一: posix (适用于 Unix 操作系统), nt (Win32),
mac(旧版本的 MacOS), dos (DOS), os2 (OS/2), 等. 你不需要直接导入这些模块. 只要导入 os 模
块, Python 会为你选择正确的模块, 你不需要考虑底层的工作. 根据你系统支持的特性, 你可能无
法访问到一些在其它系统上可用的属性.


除了对进程和进程运行环境进行管理外, os 模块还负责处理大部分的文件系统操作, 应用程序
开发人员可能要经常用到这些. 这些功能包括删除/重命名文件, 遍历目录树, 以及管理文件访问
权限等. 表 9.5 列出 os 模块提供的一些常见文件或目录操作函数.
另一个模块 os.path 可以完成一些针对路径名的操作. 它提供的函数可以完成管理和操作文
件路径名中的各个部分, 获取文件或子目录信息, 文件路径查询等操作. 表 9.6 列出了 os.path
中的几个比较常用的函数.
这两个模块提供了与平台和操作系统无关的统一的文件系统访问方法. 例 9.1 (ospathex.py)
展示了 os 和 os.path 模块中部分函数的使用.
表 9.5 os 模块的文件/目录访问函数
函数                       描述
文件处理
mkfifo()/mknod()a      创建命名管道/创建文件系统节点
remove()/unlink()       Delete file 删除文件
b
rename()/renames()      重命名文件
c
*stat ()                返回文件信息
symlink()         创建符号链接
utime()               更新时间戳
tmpfile()         创建并打开('w+b')一个新的临时文件
a
walk()                生成一个目录树下的所有文件名
目录/文件夹
chdir()/fchdir()a 改变当前工作目录/通过一个文件描述符改变当前工作目录
d
chroot()              改变当前进程的根目录
listdir()             列出指定目录的文件
a
getcwd()/getcwdu() 返回当前工作目录/功能相同, 但返回一个 Unicode 对象
mkdir()/makedirs() 创建目录/创建多层目录
rmdir()/removedirs() 删除目录/删除多层目录
访问/权限
access()              检验权限模式
chmod()               改变权限模式
a
chown()/lchown()       改变 owner 和 group ID/功能相同, 但不会跟踪链接
umask()           设置默认权限模式
文件描述符操作
open()                 底层的操作系统 open (对于文件, 使用标准的内建 open() 函数)
read()/write()     根据文件描述符读取/写入数据
dup()/dup2()          复制文件描述符号/功能相同, 但是是复制到另一个文件描述符
设备号
makedev()a 从 major 和 minor 设备号创建一个原始设备号


major()a /minor()a 从原始设备号获得 major/minor 设备号
a.    New in Python 2.3.
b.    New in Python 1.5.2.
c.    Includes stat(), lstat(), xstat().
d.    New in Python 2.2.
表 9.6 os.path 模块中的路径名访问函数
函数                  描述
分隔
basename()       去掉目录路径, 返回文件名
dirname()        去掉文件名, 返回目录路径
join()           将分离的各部分组合成一个路径名
split()          返回 (dirname(), basename()) 元组
splitdrive()     返回 (drivename, pathname) 元组
splitext()       返回 (filename, extension) 元组
信息
getatime()           返回最近访问时间
getctime()           返回文件创建时间
getmtime()           返回最近文件修改时间
getsize()        返回文件大小(以字节为单位)
查询
exists()         指定路径(文件或目录)是否存在
isabs()      指定路径是否为绝对路径
isdir()      指定路径是否存在且为一个目录
isfile()     指定路径是否存在且为一个文件
islink()     指定路径是否存在且为一个符号链接
ismount()        指定路径是否存在且为一个挂载点
samefile()       两个路径名是否指向同个文件
例 9.1 os 和 os.path 模块例子(ospathex.py)
这段代码练习使用一些 os 和 os.path 模块中的功能. 它创建一个文本文件, 写入少量数据,
然后重命名, 输出文件内容. 同时还进行了一些辅助性的文件操作, 比如遍历目录树和文件路径名
处理.
1 #!/usr/bin/env python
2
3 import os


4 for tmpdir in ('/tmp', r'c:\temp'):
5 if os.path.isdir(tmpdir):
6 break
7 else:
8 print 'no temp directory available'
9 tmpdir = ''
10
11 if tmpdir:
12 os.chdir(tmpdir)
13 cwd = os.getcwd()
14 print '*** current temporary directory'
15 print cwd
16
17 print '*** creating example directory...'
18 os.mkdir('example')
19 os.chdir('example')
20 cwd = os.getcwd()
21 print '*** new working directory:'
22 print cwd
23 print '*** original directory listing:'
24 print os.listdir(cwd)
25
26 print '*** creating test file...'
27 fobj = open('test', 'w')
28 fobj.write('foo\n')
29 fobj.write('bar\n')
30 fobj.close()
31 print '*** updated directory listing:'
32 print os.listdir(cwd)
33
34 print "*** renaming 'test' to 'filetest.txt'"
35 os.rename('test', 'filetest.txt')
36 print '*** updated directory listing:'
37 print os.listdir(cwd)
38
39 path = os.path.join(cwd, os.listdir (cwd)[0])
40 print '*** full file pathname'
41 print path
42 print '*** (pathname, basename) =='
43 print os.path.split(path)


44 print '*** (filename, extension) =='
45 print os.path.splitext(os.path.basename(path))
46
47 print '*** displaying file contents:'
48 fobj = open(path)
49 for eachLine in fobj:
50 print eachLine,
51 fobj.close()
52
53 print '*** deleting test file'
54 os.remove(path)
55 print '*** updated directory listing:'
56 print os.listdir(cwd)
57 os.chdir(os.pardir)
58 print '*** deleting test directory'
59 os.rmdir('example')
60 print '*** DONE'
os 的子模块 os.path 更多用于文件路径名处理. 比较常用的属性列于表 9.6 中.
在 Unix 平台下执行该程序, 我们会得到如下输出:
$ ospathex.py
*** current temporary directory
/tmp
*** creating example directory...
*** new working directory:
/tmp/example
*** original directory listing:
[]
*** creating test file...
*** updated directory listing:
['test']
*** renaming 'test' to 'filetest.txt'
*** updated directory listing:
['filetest.txt']
*** full file pathname:
/tmp/example/filetest.txt
*** (pathname, basename) ==
('/tmp/example', 'filetest.txt')
*** (filename, extension) ==


('filetest', '.txt')
*** displaying file contents:
foo bar
*** deleting test file
*** updated directory listing:
[]
*** deleting test directory
*** DONE
在 DOS 窗口下执行这个例子我们会得到非常相似的输出:
C:\>python ospathex.py
*** current temporary directory c:\windows\temp
*** creating example directory...
*** new working directory:
c:\windows\temp\example
*** original directory listing:
[]
*** creating test file...
*** updated directory listing:
['test']
*** renaming 'test' to 'filetest.txt'
*** updated directory listing:
['filetest.txt']
*** full file pathname:
c:\windows\temp\example\filetest.txt
*** (pathname, basename) ==
('c:\\windows\\temp\\example', 'filetest.txt')
*** (filename, extension) ==
('filetest', '.txt')
*** displaying file contents:
foo bar
*** deleting test file
*** updated directory listing:
[]
*** deleting test directory
*** DONE
这里就不逐行解释这个例子了, 我们把这个留给读者做练习. 下面我们来看看一个类似的交互
式例子(包括错误), 我们会把代码分成几个小段, 然后依次进行讲解.


>>> import os
>>> os.path.isdir('/tmp')
True
>>> os.chdir('/tmp')
>>> cwd = os.getcwd()
>>> cwd
'/tmp'
代码的第一部分导入了 os 模块(同时也包含 os.path 模块). 然后检查并确认 '/tmp' 是一
个合法的目录, 并切换到这个临时目录开始我们的工作. 之后我们用 getcwd() 方法确认我们当前
位置.
>>> os.mkdir('example')
>>> os.chdir('example')
>>> cwd = os.getcwd()
>>> cwd
'/tmp/example'
>>>
>>> os.listdir() # oops, forgot name
Traceback (innermost last): File "<stdin>", line 1, in ?
TypeError: function requires at least one argument
>>>
>>> os.listdir(cwd) # that's better :)
[]
接下来, 我们在临时目录里创建了一个子目录, 然后用 listdir() 方法确认目录为空(因为我
们刚创建它). 第一次调用 listdir() 调用时出现的问题是因为我们没有传递要列目录的路径名.
我们马上在第二次调用时修正了这个失误.
>>> fobj = open('test', 'w')
>>> fobj.write('foo\n')
>>> fobj.write('bar\n')
>>> fobj.close()
>>> os.listdir(cwd)
['test']
这里我们创建了一个有两行内容的 test 文件, 之后列目录确认文件被成功创建.
>>> os.rename('test', 'filetest.txt')


>>> os.listdir(cwd)
['filetest.txt']
>>>
>>> path = os.path.join(cwd, os.listdir(cwd)[0])
>>> path
'/tmp/example/filetest.txt'
>>>
>>> os.path.isfile(path) True
>>> os.path.isdir(path) False
>>>
>>> os.path.split(path)
('/tmp/example', 'filetest.txt')
>>>
>>> os.path.splitext(os.path.basename(path))
('filetest', '.ext')
这一段代码使用了 os.path 的一些功能, 包括我们之前看到过的 join(), isfile(), isdir(),
split(), basename(), 以及 splitext() . 我们还调用了 os 下的 rename() 函数. 接下来, 我们
显示文件的内容, 之后, 删除之前创建的文件和目录:
>>> fobj = open(path)
>>> for eachLine in fobj:
... print eachLine,
... foo bar
>>> fobj.close()
>>> os.remove(path)
>>> os.listdir(cwd)
[]
>>> os.chdir(os.pardir)
>>> os.rmdir('example')
核心模块: os (和 os.path )
从上面这些长篇讨论可以看出, os 和 os.path 模块提供了访问计算机文件系统的不同方法.
我们在本章学习的只是文件访问方面, 事实上 os 模块可以完成更多工作. 我们可以通过它管理进
程环境, 甚至可以让一个 Python 程序直接与另外一个执行中的程序"对话". 你很快就会发现自己
离不开这个模块了. 更多关于 os 模块的内容请参阅第 14 章.
9.8 文件执行


无论你只是想简单地运行一个操作系统命令, 调用一个二进制可执行文件, 或者其它类型的脚
本(可能是 shell 脚本, Perl, 或是 Tcl/Tk), 都需要涉及到运行系统其它位置的其它文件. 尽管
不经常出现,但是有时甚至会需要启动另外一个 Python 解释器.我们将把这部分内容留到第 14 章
去讨论. 如果读者有兴趣了解如何启动其它程序,以及如何与它们进行通讯, 或者是 Python 执行
环境的一般信息, 都可以在 14 章里找到答案.
9.9 永久存储模块
在本书的很多练习里, 都需要用户输入数据. 这可能需要用户多次输入重复的数据. 尤其是如
果你要输入大批数据供以后使用时, 你肯定会厌烦这样做. 这就是永久储存大显身手的地方了, 它
可以把用户的数据归档保存起来供以后使用, 这样你就可以避免每次输入同样的信息. 在简单的磁
盘 文 件 已 经 不 能 满 足 你 的 需 要 , 而 使 用 完 整 的 关 系 数 据 库 管 理 系 统 (relational database
management systems 即 RDBMS) 又有些大材小用时, 简单的永久性储存就可以发挥它的作用. 大部
分永久性储存模块是用来储存字符串数据的, 但是也有方法来归档 Python 对象.
9.9.1 pickle 和 marshal 模块
Python 提供了许多可以实现最小化永久性储存的模块. 其中的一组( marshal 和 pickle )可
以用来转换并储存 Python 对象. 该过程将比基本类型复杂的对象转换为一个二进制数据集合,
这样就可以把数据集合保存起来或通过网络发送, 然后再重新把数据集合恢复原来的对象格式.
这个过程也被称为数据的扁平化, 数据的序列化, 或者数据的顺序化. 另外一些模块
(dbhash/bsddb, dbm, gdbm, dumbdbm 等)以及它们的"管理器"( anydbm )只提供了 Python 字
符串的永久性储存. 而最后一个模块( shelve ) 则两种功能都具备.
我们已经提到 marshal 和 pickle 模块都可以对 Python 对象进行储存转换. 这些模块本身
并没有提供"永久性储存"的功能, 因为它们没有为对象提供名称空间, 也没有提供对永久性储存对
象的并发写入访问( concurrent write access ). 它们只能储存转换 Python 对象, 为保存和传输
提供方便. 数据储存是有次序的(对象的储存和传输是一个接一个进行的). marshal 和 pickle 模
块的区别在于 marshal 只能处理简单的 Python 对象(数字, 序列, 映射, 以及代码对象), 而
pickle 还可以处理递归对象, 被不同地方多次引用的对象, 以及用户定义的类和实例. pickle 模
块还有一个增强的版本叫 cPickle , 使用 C 实现了相关的功能.
9.9.2 DBM 风格的模块
*db* 系 列 的 模 块 使 用 传 统 的 DBM 格 式 写 入 数 据 , Python 提 供 了 DBM 的 多 种 实 现 :
dbhash/bsddb, dbm,  gdbm, 以及 dumbdbm 等. 你可以随便按照你的爱好使用, 如果你不确定
的话, 那么最好使用 anydbm 模块, 它会自动检测系统上已安装的 DBM 兼容模块, 并选择"最好"


的一个. dumbdbm 模块是功能最少的一个, 在没有其它模块可用时, anydbm 才会选择它. 这些模块
为用户的对象提供了一个命名空间, 这些对象同时具备字典对象和文件对象的特点. 不过不足之处
在于它们只能储存字符串, 不能对 Python 对象进行序列化.
9.9.3 shelve 模块
最后, 我们来看一个更为完整的解决方案, shelve 模块. shelve 模块使用 anydbm 模块寻找
合适的 DBM 模块, 然后使用 cPickle 来完成对储存转换过程. shelve 模块允许对数据库文件进行
并发的读访问, 但不允许共享读/写访问. 这也许是我们在 Python 标准库里找到的最接近于永久
性储存的东西了. 可能有一些第三方模块实现了"真正"的永久性储存. 图 9-1 展示了储存转换模
块与永久性储存模块之间的关系, 以及为何 shelve 对象能成为两者的最好的选择的.
图 9-1 用于序列化和永久性储存的 Python 模块


核心模块: pickle 和 cPickle
你可以使用 pickle 模块把 Python 对象直接保存到文件里, 而不需要把它们转化为字符串,
也不用底层的文件访问操作把它们写入到一个二进制文件里. pickle 模块会创建一个 Python 语言
专用的二进制格式, 你不需要考虑任何文件细节, 它会帮你干净利索地完成读写对象操作, 唯一需
要的只是一个合法的文件句柄.
pickle 模块中的两个主要函数是 dump() 和 load() . dump() 函数接受一个文件句柄和一个
数据对象作为参数, 把数据对象以特定格式保存到给定文件里. 当我们使用 load() 函数从文件中
取出已保存的对象时, pickle 知道如何恢复这些对象到它们本来的格式. 我们建议你看一看
pickle 和更"聪明"的 shelve 模块, 后者提供了字典式的文件对象访问功能, 进一步减少了程序
员的工作.
cPickle 是 pickle 的一个更快的 C 语言编译版本.
9.10 相关模块
还有大量的其它模块与文件和输入/输出有关, 它们中的大多数都可以在主流平台上工作. 表
9.7 列出了一些文件相关的模块
表 9.7 文件相关模块
模块           内容
base64     提供二进制字符串和文本字符串间的编码/解码操作
binascii      提供二进制和 ASCII 编码的二进制字符串间的编码/解码操作
a
bz2         访问 BZ2 格式的压缩文件
a
csv        访问 csv 文件(逗号分隔文件)
b
filecmp     用于比较目录和文件
fileinput 提供多个文本文件的行迭代器
a
getopt/optparse    提供了命令行参数的解析/处理
glob/fnmatch     提供 Unix 样式的通配符匹配的功能
gzip/zlib 读写 GNU zip( gzip) 文件(压缩需要 zlib 模块)
shutil       提供高级文件访问功能
c/StringIO 对字符串对象提供类文件接口
tarfilea     读写 TAR 归档文件, 支持压缩文件
tempfile    创建一个临时文件(名)
uu           格式的编码和解码
c
zipfile   用于读取 ZIP 归档文件的工具
a. New in Python 2.3.
b. New in Python 2.0.
c. New in Python 1.6.
fileinput 模块遍历一组输入文件, 每次读取它们内容的一行, 类似 Perl 语言中的不带参数


的 "<>" 操作符. 如果没有明确给定文件名, 则默认从命令行读取文件名.
glob 和 fnmatch 模块提供了老式 Unix shell 样式文件名的模式匹配, 例如使用星号( * )通
配符代表任意字符串, 用问号( ? )匹配任意单个字符.
核心提示: 使用 os.path.expanduser() 的波浪号 ( ~ ) 进行扩展
虽然 glob 和 fnmatch 提供了 Unix 样式的模式匹配, 但它们没有提供对波浪号(用户目录)
字符, ~ 的支持. 你可以使用 os.path.expanduser() 函数来完成这个功能, 传递一个带波浪号的
目录, 然后它会返回对应的绝对路径. 这里是两个例子, 分别运行在 Unix 和 Win32 环境下:
>>> os.path.expanduser('~/py')
'/home/wesley/py'
>>> os.path.expanduser('~/py')
'C:\\Documents and Settings\\wesley/py'
另外 Unix 家族系统还支持 "~user" 这样的用法, 表示指定用户的目录. 还有, 注意 Win32
版本函数没有使用反斜杠来分隔目录路径.
gzip 和 zlib 模块提供了对 zlib 压缩库直接访问的接口. gzip 模块是在 zlib 模块上编写
的, 不但实现了标准的文件访问, 还提供了自动的 gzip 压缩/解压缩. bz2 类似于 gzip , 用于
操作 bzip 压缩的文件.
程序员可以通过 1.6 中新增的 zipfile 模块创建, 修改和读取 zip 归档文件. ( tarfile
文件实现了针对 tar 归档文件的相同功能 ). 在 2.3 版本中, Python 加入了导入归档 zip 文件
中模块的功能. 更多细节请参阅 12.5.7 小节.
shutil 模块提供高级的文件访问功能, 包括复制文件, 复制文件的访问权限, 递归地目录树
复制, 等等.
tempfile 模块用于生成临时文件(名).
在关于字符串一章中, 我们介绍了 StringIO 模块(和它的 C 语言版本 cStringIO ), 并且介
绍了它是如何在字符串对象顶层加入文件操作接口的. 这个接口包括文件对象的所有标准方法.
我们在前面永久性储存一节( 9.9 节) 中介绍的模块还有文件和字典对象混合样式的例子.
其它的 Python 类文件对象还有网络和文件 socket 对象( socket 模块), 用于管道连接的
popen*() 文件对象( os 和 popen2 模块), 用于底层文件访问的 fdopen() 文件对象(os 模块), 通
过 URL ( Uniform Resource Locator 统一资源定位器)建立的到指定 web 服务器的网络连接
( urllib 模块)等. 需要注意的是并非所有的标准文件方法都能在这些对象上实现, 同样的,这些
对象也提供了一些普通文件没有的功能.


具体内容请参考这些模块的相关文档. 你可以在下边这些地址中找到关于 file()/open() , 文
件, 文件对象的更多信息.
http://docs.python.org/lib/built-in-funcs.html
http://docs.python.org/lib/bltin-file-objects.html
http://www.python.org/doc/2.3/whatsnew/node7.html
http://www.python.org/doc/peps/pep-0278/
9.11    练习
9–1.    文件过滤. 显示一个文件的所有行, 忽略以井号( # )开头的行. 这个字符被用做
Python , Perl, Tcl, 等大多脚本文件的注释符号.
附加题: 处理不是第一个字符开头的注释.
9–2.    文件访问. 提示输入数字 N 和文件 F, 然后显示文件 F 的前 N 行.
9–3.    文件信息. 提示输入一个文件名, 然后显示这个文本文件的总行数.
9–4.    文件访问. 写一个逐页显示文本文件的程序. 提示输入一个文件名, 每次显示文本
文件的 25 行, 暂停并向用户提示"按任意键继续.", 按键后继续执行.
9–5.    考试成绩. 改进你的考试成绩问题(练习 5 -3 和 6-4), 要求能从多个文件中读入考
试成绩. 文件的数据格式由你自己决定.
9–6.    文件比较. 写一个比较两个文本文件的程序. 如果不同, 给出第一个不同处的行号和
列号.
9–7. 解析文件. Win32 用户: 创建一个用来解析 Windows .ini 文件的程序. POSIX 用户:
创建一个解析 /etc/serves 文件的程序. 其它平台用户: 写一个解析特定结构的系统配置文件的
程序.
9–8. 模块研究. 提取模块的属性资料. 提示用户输入一个模块名(或者从命令行接受输入).
然后使用 dir() 和其它内建函数提取模块的属性, 显示它们的名字, 类型, 值.
9–9.    Python 文档字符串. 进入 Python 标准库所在的目录. 检查每个 .py 文件看是否有
__doc__ 字符串, 如果有, 对其格式进行适当的整理归类. 你的程序执行完毕后, 应该会生成一个
漂亮的清单. 里边列出哪些模块有文档字符串, 以及文档字符串的内容. 清单最后附上那些没有文
档字符串模块的名字.
附加题: 提取标准库中各模块内全部类(class)和函数的文档.


9–10.    家庭理财. 创建一个家庭理财程序. 你的程序需要处理储蓄, 支票, 金融市场, 定
期存款等多种帐户. 为每种帐户提供一个菜单操作界面, 要有存款, 取款, 借, 贷等操作. 另外还
要提供一个取消操作选项. 用户退出这个程序时相关数据应该保存到文件里去(出于备份的目的,
程序执行过程中也要备份.)
9–11.    Web 站点地址.
a) 编写一个 URL 书签管理程序. 使用基于文本的菜单, 用户可以添加, 修改或者删除书签数
据项. 书签数据项中包含站点的名称, URL 地址, 以及一行简单说明(可选). 另外提供检索功能,
可以根据检索关键字在站点名称和 URL 两部分查找可能的匹配. 程序退出时把数据保存到一个磁
盘文件中去; 再次执行时候加载保存的数据.
b)改进 a) 的解决方案, 把书签输出到一个合法且语法正确的 HTML 文件(.html 或 htm )中,
这样用户就可以使用浏览器查看自己的书签清单. 另外提供创建"文件夹"功能, 对相关的书签进行
分组管理.
附加题: 请阅读 Python 的 re 模块了解有关正则表达式的资料, 使用正则表达式对用户输入
的 URL 进行验证.
9–12.    用户名和密码.
回顾练习 7-5 , 修改代码使之可以支持"上次登录时间". 请参阅 time 模块中的文档了解如
何记录用户上次登录的时间. 另外提供一个"系统管理员", 它可以导出所有用户的用户名, 密码
(如果想要的话,你可以把密码加密), 以及"上次登录时间".
a) 数 据 应 该 保 存 在 磁 盘 中 , 使 用 冒 号 ( : ) 分 割 , 一 次 写 入 一 行 , 例 如
"joe:boohoo:953176591.145", 文件中数据的行数应该等于你系统上的用户数.
b) 进一步改进你的程序, 不再一次写入一行, 而使用 pickle 模块保存整个数据对象. 请参
阅 pickle 模块的文档了解如何序列化/扁平化对象, 以及如何读写保存的对象. 一般来说, 这个
解决方案的代码行数要比 a) 的少.
c) 使用 shelve 模块替换 pickle 模块, 由于可以省去一些维护代码,这个解决方案的代码比
b) 的更少.
9–13.    命令行参数
a) 什么是命令行参数, 它们有什么用?
b) 写一个程序, 打印出所有的命令行参数.
9–14.   记录结果. 修改你的计算器程序(练习 5-6 )使之接受命令行参数. 例如:
$ calc.py 1 + 2
只输出计算结果. 另外, 把每个表达式和它的结果写入到一个磁盘文件中. 当使用下面的命令
时:
$ calc.py print


会把记录的内容显示到屏幕上, 然后重置文件. 这里是样例展示:
$ calc.py 1 + 2
3
$ calc.py  3 ^ 3
27
$ calc.py  print
1 + 2
3
3 ^ 3
27
$ calc.py  print
$
附加题: 处理输入时候的注释.
9–15.     复制文件. 提示输入两个文件名(或者使用命令行参数). 把第一个文件的内容复制
到第二个文件中去.
9–16.    文本处理. 人们输入的文字常常超过屏幕的最大宽度. 编写一个程序, 在一个文本
文件中查找长度大于 80 个字符的文本行. 从最接近 80 个字符的单词断行, 把剩余文件插入到
下一行处.
程序执行完毕后, 应该没有超过 80 个字符的文本行了.
9–17.     文本处理. 创建一个原始的文本文件编辑器. 你的程序应该是菜单驱动的, 有如下
这些选项:
1) 创建文件(提示输入文件名和任意行的文本输入),
2) 显示文件(把文件的内容显示到屏幕),
3) 编辑文件(提示输入要修改的行, 然后让用户进行修改),
4) 保存文件, 以及
5) 退出.
9–18.     搜索文件. 提示输入一个字节值(0 - 255)和一个文件名. 显示该字符在文件中出现
的次数.
9–19.     创建文件. 创建前一个问题的辅助程序. 创建一个随机字节的二进制数据文件, 但
某一特定字节会在文件中出现指定的次数. 该程序接受三个参数:
1) 一个字节值( 0 - 255 ),
2) 该字符在数据文件中出现的次数, 以及
3) 数据文件的总字节长度.


你的工作就是生成这个文件, 把给定的字节随机散布在文件里, 并且要求保证给定字符在文件
中只出现指定的次数, 文件应精确地达到要求的长度.
9–20.    压缩文件. 写一小段代码, 压缩/解压缩 gzip 或 bzip 格式的文件. 可以使用命令
行下的 gzip 或 bzip2 以及 GUI 程序 PowerArchiver , StuffIt , 或 WinZip 来确认你的 Python
支持这两个库.
9–21.    ZIP 归档文件. 创建一个程序, 可以往 ZIP 归档文件加入文件, 或从中提取文件,
有可能的话, 加入创建 ZIP 归档文件的功能.
9–22.    ZIP 归档文件. unzip -l 命令显示出的 ZIP 归档文件很无趣. 创建一个 Python
脚本 lszip.py , 使它可以显示额外信息: 压缩文件大小, 每个文件的压缩比率(通过比较压缩
前后文件大小), 以及完成的 time.ctime() 时间戳, 而不是只有日期和 HH:MM .
提示: 归档文件的 date_time 属性并不完整, 无法提供给 time.mktime() 使用....这由你自
己决定.
9–23. TAR 归档文件. 为 TAR 归档文件建立类似上个问题的程序. 这两种文件的不同之处
在于 ZIP 文件通常是压缩的, 而 TAR 文件不是, 只是在 gzip 和 bzip2 的支持下才能完成压缩
工作. 加入任意一种压缩格式支持.
附加题: 同时支持 gzip 和 bzip2 .
9–24. 归 档 文 件 转 换 . 参 考 前 两 个 问 题 的 解 决 方 案 , 写 一 个 程 序 , 在 ZIP (.zip) 和
TAR/gzip (.tgz/.tar.gz) 或 TAR/bzip2 (.tbz/.tar.bz2) 归档文件间移动文件. 文件可能是已经
存在的, 必要时请创建文件.
9–25. 通用解压程序. 创建一个程序, 接受任意数目的归档文件以及一个目标目录做为参数.
归档文件格式可以是 .zip, .tgz, .tar.gz, .gz, .bz2, .tar.bz2, .tbz 中的一种或几种. 程序
会把第一个归档文件解压后放入目标目录, 把其它归档文件解压后放入以对应文件名命名的目录下
( 不 包 括 扩 展 名 ). 例 如 输 入 的 文 件 名 为 header.txt.gz 和 data.tgz , 目 录 为 incoming ,
header.txt 会被解压到 incoming 而 data.tgz 中的文件会被放入 incoming/data .


错误和异常
本章主题
z 什么是异常?
z Python 中的异常
z 探测和处理异常
z 上下文管理
z 引发异常
z 断言
z 标准异常
z 创建异常
z 相关模块


程序员的一生中, 错误几乎每天都在发生. 在过去的一个时期, 错误要么对程序(可能还有机
器)是致命的, 要么产生一大堆无意义的输出, 无法被其他计算机或程序识别, 连程序远自己也可
能搞不懂它的意义. 一旦出现错误, 程序就会终止执行, 直到错误被修正, 程序重新执行. 所以,
人们需要一个"柔和"的处理错误的方法, 而不是终止程序. 同时, 程序本身也在不断发展, 并不是
每个错误都是致命的, 即使错误发生, 编译器或是在执行中的程序也可以提供更多更有用的诊断
信息, 帮助程序员尽快解决问题. 然而, 错误毕竟是错误, 一般都是停止编译或执行后才能去解
决它. 一小段代码只能让程序终止执行, 也许还能打印出一些模糊的提示. 当然, 这一切都是在
异常和异常处理出现之前的事了.
虽然目前还没有讨论到 Python 中的类和面向对象编程(OOP), 但我们这里要介绍的许多概念
已经涉及了类和类实例.[脚注 1] 我们提供了一小节介绍如何创建自定义的异常类.
------------------------------------
1 . 从 Python 1.5 开始, 所有的标准异常都使用类来实现. 如果你对类, 实例, 以及其他面
向对象相关术语不太了解, 请参阅第 13 章
----------------------------
本章将介绍什么是异常, 异常处理, 以及 Python 对异常的支持. 我们还会介绍如何在代码里
生成异常. 最后, 我们会涉及如何创建自定义的异常类.
10.1    什么是异常


10.1.1   错误
在深入介绍异常之前, 我们来看看什么是错误. 从软件方面来说, 错误是语法或是逻辑上的.
语法错误指示软件的结构上有错误, 导致不能被解释器解释或编译器无法编译. 这些错误必须在程
序执行前纠正.
当程序的语法正确后, 剩下的就是逻辑错误了. 逻辑错误可能是由于不完整或是不合法的输入
所致; 在其他情况下, 还可能是逻辑无法生成, 计算, 或是输出结果需要的过程无法执行. 这些错
误通常分别被称为域错误和范围错误.
当 Python 检测到一个错误时, 解释器就会指出当前流已经无法继续执行下去. 这时候就出现
了异常.
10.1.2   异常
对异常的最好描述是: 它是因为程序出现了错误而在正常控制流以外采取的行为. 这个行为又
分为两个阶段: 首先是引起异常发生的错误, 然后是检测(和采取可能的措施)阶段.
第一个阶段是在发生了一个异常条件(有时候也叫做例外的条件)后发生的. 只要检测到错误
并且意识到异常条件, 解释器会引发一个异常. 引发也可以叫做触发, 引发或者生成. 解释器通
过它通知当前控制流有错误发生. Python 也允许程序员自己引发异常. 无论是 Python 解释器还是
程序员引发的, 异常就是错误发生的信号. 当前流将被打断, 用来处理这个错误并采取相应的操作.
这就是第二阶段.
对异常的处理发生在第二阶段. 异常引发后, 可以调用很多不同的操作. 可以是忽略错误(记
录错误但不采取任何措施, 采取补救措施后终止程序), 或是减轻问题的影响后设法继续执行程序.
所有的这些操作都代表一种继续, 或是控制的分支. 关键是程序员在错误发生时可以指示程序如何
执行.
你可能已经得出这样一个结论: 程序运行时发生的错误主要是由于外部原因引起的, 例如非法
输入或是其他操作失败等等. 这些因素并不在程序员的直接控制下, 而程序员只能预见一部分错误,
编写常见的补救措施代码.
类似 Python 这样支持引发和处理异常(这更重要)的语言, 可以让开发人员可以在错误发生时
更直接地控制它们. 程序员不仅仅有了检测错误的能力, 还可以在它们发生时采取更可靠的补救措
施. 由于有了运行时管理错误的能力, 应用程序的健壮性有了很大的提高.
异常和异常处理并不是什么新概念. 它们同样存在于 Ada, Modula-3, C++, Eiffel, 以及 Java


中. 异常的起源可以追溯到处理系统错误和硬件中断这类异常的操作系统代码. 在 1965 年左右,
PL/1 作为第一个支持异常的主要语言出现, 而异常处理是作为一个它提供的软件工具. 和其他支
持异常处理的语言类似, Python 采用了 "try/尝试" 块和 "catching/捕获" 块的概念, 而且它在
异常处理方面更有"纪律性". 我们可以为不同的异常创建不同的处理器, 而不是盲目地创建一个
"catch-all/捕获所有"的代码.
10.2    Python 中的异常
在先前的一些章节里你已经执行了一些代码, 你一定遇到了程序"崩溃"或因未解决的错误而终
止的情况. 你会看到"traceback/跟踪返回"消息, 以及随后解释器向你提供的信息, 包括错误的名
称, 原因, 以及发生错误的行号. 不管你是通过 Python 解释器执行还是标准的脚本执行, 所有的
错误都符合相似的格式, 这提供了一个一致的错误接口. 所有错误, 无论是语意上的还是逻辑上的,
都是由于和 Python 解释器不相容导致的, 其后果就是引发异常.
我们来看几个异常的例子.
NameError:     尝试访问一个未申明的变量
>>> foo
Traceback (innermost last): File "<stdin>", line 1, in ?
NameError: name 'foo' is not defined
NameError 表示我们访问了一个没有初始化的变量. 在 Python 解释器的符号表没有找到那个
另人讨厌的变量. 我们将在后面的两章讨论名称空间, 现在大家可以认为它们是连接名字和对象的
"地址簿"就可以了. 任何可访问的变量必须在名称空间里列出. 访问变量需要由解释器进行搜索,
如果请求的名字没有在任何名称空间里找到, 那么将会生成一个 NameError 异常.
ZeroDivisionError:   除数为零
>>> 1/0
Traceback (innermost last): File "<stdin>", line 1, in ?
ZeroDivisionError: integer division or modulo by zero
我们边的例子使用的是整数, 但事实上, 任何数值被零除都会导致一个 ZeroDivisionError
异常.
SyntaxError:   Python 解释器语法错误
>>> for
File "<string>", line 1


for
^
SyntaxError: invalid syntax
SyntaxError 异常是唯一不是在运行时发生的异常. 它代表 Python 代码中有一个不正确的结
构, 在它改正之前程序无法执行. 这些错误一般都是在编译时发生, Python 解释器无法把你的脚本
转化为 Python 字节代码. 当然这也可能是你导入一个有缺陷的模块的时候.
IndexError:请求的索引超出序列范围
>>> aList = []
>>> aList[0]
Traceback (innermost last): File "<stdin>", line 1, in ?
IndexError: list index out of range
IndexError 在你尝试使用一个超出范围的值索引序列时引发.
KeyError:请求一个不存在的字典关键字
>>> aDict = {'host': 'earth', 'port': 80}
>>> print aDict['server'] Traceback (innermost last):
File "<stdin>", line 1, in ? KeyError: server
映射对象, 例如字典, 是依靠关键字(keys)访问数据值的. 如果使用错误的或是不存在的键请
求字典就会引发一个 KeyError 异常.
IOError:     输入/输出错误
>>> f = open("blah") Traceback (innermost last):
File "<stdin>", line 1, in ?
IOError: [Errno 2] No such file or directory: 'blah'
类似尝试打开一个不存在的磁盘文件一类的操作会引发一个操作系统输入/输出(I/O)错误. 任
何类型的 I/O 错误都会引发 IOError 异常.
AttributeError:     尝试访问未知的对象属性
>>>  class myClass(object):
...     pass
...
>>>  myInst = myClass()
>>>  myInst.bar = 'spam'
>>>  myInst.bar


'spam'
>>> myInst.foo
Traceback (innermost last): File "<stdin>", line 1, in ?
AttributeError: foo
在我们的例子中, 我们在 myInst.bar 储存了一个值, 也就是实例 myInst 的 bar 属性. 属
性被定义后, 我们可以使用熟悉的点/属性操作符访问它, 但如果是没有定义属性, 例如我们访问
foo 属性, 将导致一个 AttributeError 异常.
10.3 检测和处理异常
异常可以通过 try 语句来检测. 任何在 try 语句块里的代码都会被监测, 检查有无异常发
生.
try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你
只 能 使 用 其 中 的 一 种 . 一 个 try 语 句 可 以 对 应 一 个 或 多 个 except 子 句 , 但 只 能 对 应 一 个
finally 子句, 或是一个 try-except-finally 复合语句.
你可以使用 try-except 语句检测和处理异常. 你也可以添加一个可选的 else 子句处理没
有探测到异常的时执行的代码. 而 try-finally 只允许检测异常并做一些必要的清除工作(无论
发生错误与否), 没有任何异常处理设施. 正如你想像的,复合语句两者都可以做到.
10.3.1      try-except 语句
try-except 语句(以及其更复杂的形式)定义了进行异常监控的一段代码, 并且提供了处理异
常的机制.
最 常 见 的 try-except 语 句 语 法 如 下 所 示 . 它 由 try 块 和 except 块 (try_suite 和
except_suite )组成, 也可以有一个可选的错误原因.
try:
try_suite   # watch for exceptions here 监控这里的异常
except Exception[, reason]:
except_suite    # exception-handling code 异常处理代码
我们用一个例子说明这一切是如何工作的. 我们将使用上边的 IOError 例子, 把我们的代码
封装在 try-except 里, 让代码更健壮:


>>> try:
...        f = open('blah', 'r')
... except IOError, e:
...        print 'could not open file:', e
...
could not open file: [Errno 2] No such file or directory
如你所见, 我们的代码运行时似乎没有遇到任何错误. 事实上我们在尝试打开一个不存在的文
件时仍然发生了 IOError . 有什么区别么? 我们加入了探测和错误错误的代码. 当引发 IOError
异常时, 我们告诉解释器让它打印出一条诊断信息. 程序继续执行, 而不像以前的例子那样被"轰
出来" - 异常处理小小地显了下身手. 那么在代码方面发生了什么呢?
在程序运行时, 解释器尝试执行 try 块里的所有代码, 如果代码块完成后没有异常发生, 执
行流就会忽略 except 语句继续执行. 而当 except 语句所指定的异常发生后, 我们保存了错误的
原因, 控制流立即跳转到对应的处理器( try 子句的剩余语句将被忽略), 本例中我们显示出一个包
含错误原因的错误信息.
在我们上边的例子中, 我们只捕获 IOError 异常. 任何其他异常不会被我们指定的处理器捕
获. 举例说, 如果你要捕获一个 OSError , 你必须加入一个特定的异常处理器. 我们将在本章后
面详细地介绍 try-except 语法.
核心笔记: 忽略代码, 继续执行, 和向上移交
try 语句块中异常发生点后的剩余语句永远不会到达(所以也永远不会执行). 一旦一个异常被
引发, 就必须决定控制流下一步到达的位置. 剩余代码将被忽略, 解释器将搜索处理器, 一旦找到,
就开始执行处理器中的代码.
如果没有找到合适的处理器, 那么异常就向上移交给调用者去处理, 这意味着堆栈框架立即回
到之前的那个. 如果在上层调用者也没找到对应处理器, 该异常会继续被向上移交, 直到找到合适
处理器. 如果到达最顶层仍然没有找到对应处理器, 那么就认为这个异常是未处理的, Python 解释
器会显示出跟踪返回消息, 然后退出.
10.3.2     封装内建函数
我们现在给出一个交互操作的例子 - 从最基本的错误检测开始, 然后逐步改进它, 增强代码
的健壮性. 这里的问题是把一个用字符串表示的数值转换为正确的数值表示形式, 而且在过程中要
检测并处理可能的错误.
float() 内建函数的基本作用是把任意一个数值类型转换为一个浮点数. 从 Python 1.5 开始,
float() 增加了把字符串表示的数值转换为浮点数的功能, 没必要使用 string 模块中的 atof()
函数. 如果你使用的老版本的 Python , 请使用 string.atof() 替换这里的 float() .


>>> float(12345)
12345.0
>>> float('12345')
12345.0
>>> float('123.45e67')
1.2345e+069
不幸的是, float() 对输入很挑剔:
>>> float('foo')
Traceback (innermost last): File "<stdin>", line 1, in ?
float('foo')
ValueError: invalid literal for float(): foo
>>>
>>> float(['this is', 1, 'list']) Traceback (innermost last):
File "<stdin>", line 1, in ?
float(['this is', 1, 'list'])
TypeError: float() argument must be a string or a number
从上面的错误我们可以看出, float() 对不合法的参数很不客气. 例如, 如果参数的类型正确
(字符串), 但值不可转换为浮点数, 那么将引发 ValueError 异常, 因为这是值的错误. 列表也
是不合法的参数, 因为他的类型不正确, 所以, 引发一个 TypeError 异常.
我们的目标是"安全地"调用 float() 函数, 或是使用一个"安全的方式" 忽略掉错误, 因为它
们与我们转换数值类型的目标没有任何联系, 而且这些错误也没有严重到要让解释器终止执行. 为
了实现我们的目的, 这里我们创建了一个"封装"函数, 在 try-except 的协助下创建我们预想的环
境, 我们把他叫做 safe_float() . 在第一次改进中我们搜索并忽略 ValueError , 因为这是最常
发生的. 而 TypeError 并不常见, 我们一般不会把非字符串数据传递给 float().
def safe_float(obj):
try:
return float(obj)
except ValueError:
pass
我们采取的第一步只是"止血". 在上面的例子中, 我们把错误"吞了下去". 换句话说, 错误会
被探测到, 而我们在 except 从句里没有放任何东西(除了一个 pass , 这是为了语法上的需要.),
不进行任何处理, 忽略这个错误.


这个解决方法有一个明显的不足, 它在出现错误的时候没有明确地返回任何信息. 虽然返回了
None(当函数没有显式地返回一个值时, 例如没有执行到 return object 语句函数就结束了, 它就
返回 None), 我们并没有得到任何关于出错信息的提示. 我们至少应该显式地返回 None , 来使代
码更容易理解:
def safe_float(obj):
try:
retval = float(obj)
except ValueError:
retval = None
return retval
注意我们刚才做的修改, 我们只是添加了一个局部变量. 在设计良好的应用程序接口
(Application Programmer Interface, API)时, 返回值可以更灵活. 你可以在文档中这样写, 如果
传递给 safe_float() 合适的参数, 它将返回一个浮点数; 如果出现错误, 将返回一个字符串说明
输入数据有什么问题. 我们按照这个方案再修改一次代码, 如下所示:
def safe_float(obj):
try:
retval = float(obj)
except ValueError:
retval = 'could not convert non-number to float'
return retval
这里我们只是把 None 替换为一个错误字符串. 下面我们试试这个函数看看它表现如何:
>>> safe_float('12.34')
12.34
>>> safe_float('bad input')
'could not convert non-number to float'
我们有了一个好的开始 - 现在我们已经可以探测到非法的字符串输入了, 可如果传递的是一
个非法的对象, 还是会"受伤":
>>> safe_float({'a': 'Dict'})
Traceback (innermost last):
File "<stdin>", line 3, in ?
retval = float(obj)
TypeError: float() argument must be a string or a number


我们暂时只是指出这个缺点, 在进一步改进程序之前, 首先来看看 try-except 的其他灵活的
语法, 特别是 except 语句, 它有好几种变化形式.
10.3.3     带有多个 except 的 try 语句
在本章的前边, 我们已经介绍了 except 的基本语法:
except Exception[, reason]:
suite_for_exception_Exception
这种格式的 except 语句指定检测名为 Exception 的异常. 你可以把多个 except 语句连接
在一起, 处理一个 try 块中可能发生的多种异常, 如下所示:
except Exception1[, reason1]:
suite_for_exception_Exception1
except Exception2[, reason2]:
suite_for_exception_Exception2
:
同样, 首先尝试执行 try 子句, 如果没有错误, 忽略所有的 except 从句继续执行. 如果
发生异常, 解释器将在这一串处理器(except 子句)中查找匹配的异常. 如果找到对应的处理器,
执行流将跳转到这里.
我们的 safe_float() 函数已经可以检测到指定的异常了. 更聪明的代码能够处理好每一种异
常. 这就需要多个 except 语句, 每个 except 语句对应一种异常类型. Python 支持把 except 语
句串连使用 我们将分别为每个异常类型分别创建对应的错误信息, 用户可以得到更详细的关于错
误的信息:
def safe_float(obj):
try:
retval = float(obj)
except ValueError:
retval = 'could not convert non-number to float'
except TypeError:
retval = 'object type cannot be converted to float'
return retval
使用错误的参数调用这个函数, 我们得到下面的输出结果:


>>> safe_float('xyz')
'could not convert non-number to float'
>>> safe_float(())
'argument must be a string'
>>> safe_float(200L)
200.0
>>> safe_float(45.67000)
45.67
10.3.4     处理多个异常的 except 语句
我们还可以在一个 except 子句里处理多个异常. except 语句在处理多个异常时要求异常被放
在一个元组里:
except (Exception1, Exception2)[, reason]:
suite_for_Exception1_and_Exception2
上边的语法展示了如何处理同时处理两个异常. 事实上 except 语句可以处理任意多个异常,
前提只是它们被放入一个元组里 , 如下所示:
except (Exc1[, Exc2[, ... ExcN]])[, reason]:
suite_for_exceptions_Exc1_to_ExcN
如果由于其他原因, 也许是内存规定或是设计方面的因素, 要求 safe_float() 函数中的所有
异常必须使用同样的代码处理, 那么我们可以这样满足需求:
def safe_float(obj):
try:
retval = float(obj)
except (ValueError, TypeError):
retval = 'argument must be a number or numeric string'
return retval
现在, 错误的输入会返回相同的字符串:
>>> safe_float('Spanish Inquisition')
'argument must be a number or numeric string'
>>> safe_float([])


'argument must be a number or numeric string'
>>> safe_float('1.6')
1.6
>>> safe_float(1.6)
1.6
>>> safe_float(932)
932.0
10.3.5 捕获所有异常
使用前一节的代码, 我们可以捕获任意数目的指定异常, 然后处理它们. 如果我们想要捕获所
有的异常呢? 当然可以! 自版本 1.5 后, 异常成为类, 实现这个功能的代码有了很大的改进. 也
因为这点(异常成为类),我们现在有一个异常继承结构可以遵循.
如果查询异常继承的树结构, 我们会发现 Exception 是在最顶层的, 所以我们的代码可能看
起来会是这样:
try:
:
except Exception, e:
# error occurred, log 'e', etc.
另一个我们不太推荐的方法是使用 裸 except 子句:
try:
:
except:
# error occurred, etc.
这个语法不如前个 "Pythonic" . 虽然这样的代码捕获大多异常, 但它不是好的 Python 编程
样式. 一个主要原因是它不会考虑潜在的会导致异常的主要原因. 我们的 catch-all 语句可能不
会如你所想的那样工作, 它不会调查发生了什么样的错误, 如何避免它们.
我们没有指定任何要捕获的异常 - 这不会给我们任何关于可能发生的错误的信息. 另外它会
捕获所有异常, 你可能会忽略掉重要的错误, 正常情况下这些错误应该让调用者知道并做一定处理.
最后, 我们没有机会保存异常发生的原因. 当然, 你可以通过 sys.exc_info() 获得它, 但这样你
就不得不去导入 sys 模块, 然后执行函数 - 这样的操作本来是可以避免的, 尤其当我们需要立即
告诉用户为什么发生异常的时候.在 Python 的未来版本中很可能不再支持裸 except 子句. (参见
“核心风格”)


关于捕获所有异常, 你应当知道有些异常不是由于错误条件引起的. 它们是 SystemExit 和
KeyboardInterupt . SystemExit 是由于当前 Python 应用程序需要退出, KeyboardInterupt 代表
用户按下了 CTRL-C (^C) , 想要关闭 Python . 在真正需要的时候, 这些异常却会被异常处理捕获.
一个典型的迂回工作法代码框架可能会是这样:
try:
:
except (KeyboardInterupt, SystemExit):
# user wants to quit
raise     # reraise back to caller
except Exception:
# handle real errors
关于异常的一部分内容在 Python 2.5 有了一些变化. 异常被迁移到了 new-style class 上,
启用了一个新的"所有异常的母亲", 这个类叫做 BaseException , 异常的继承结构有了少许调整,
为了让人们摆脱不得不除创建两个处理器的惯用法. KeyboardInterrupt 和 SystemExit 被从
Exception 里移出, 和 Exception 平级:
- BaseException
|- KeyboardInterrupt
|- SystemExit
|- Exception
|- (all other current built-in exceptions) 所有当前内建异常
你可以在表 10.2 找到整个异常继承结构(变化前后).
这样, 当你已经有了一个 Exception 处理器后, 你不必为这两个异常创建额外的处理器. 代
码将会是这样:
try:
:
except Exception, e:
# handle real errors
如果你确实需要捕获所有异常, 那么你就得使用新的 BaseException :
try:
:
except BaseException, e:


# handle all errors
当然, 也可以使用不被推荐的裸 except 语句.
核心风格: 不要处理并忽略所有错误
Python 提供给程序员的 try-except 语句是为了更好地跟踪潜在的错误并在代码里准备好处
理异常的逻辑. 这样的机制在其他语言(例如 C ) 是很难实现的. 它的目的是减少程序出错的次数
并在出错后仍能保证程序正常执行. 作为一种工具而言, 只有正确得当地使用它, 才能使其发挥作
用.
一个不正确的使用方法就是把它作为一个大绷带"绑定"到一大片代码上. 也就是说把一大段程
序(如果还不是整个程序源代码的话)放入一个 try 块中, 再用一个通用的 except 语句 "过滤"
掉任何致命的错误, 忽略它们.
# this is really bad code
try:
large_block_of_code # bandage of large piece of code
except Exception:     # same as except:
pass    # blind eye ignoring all errors
很明显, 错误无法避免, try-except 的作用是提供一个可以提示错误或处理错误的机制, 而不
是一个错误过滤器. 上边这样的结构会忽略许多错误, 这样的用法是缺乏工程实践的表现, 我们
不赞同这样做.
底线: 避免把大片的代码装入 try-except 中然后使用 pass 忽略掉错误. 你可以捕获特定
的异常并忽略它们, 或是捕获所有异常并采取特定的动作. 不要捕获所有异常,然后忽略掉它们.
10.3.6      异常参数
异常也可以有参数, 异常引发后它会被传递给异常处理器. 当异常被引发后参数是作为附加帮
助信息传递给异常处理器的. 虽然异常原因是可选的, 但标准内建异常提供至少一个参数, 指示异
常原因的一个字符串.
异常的参数可以在处理器里忽略, 但 Python 提供了保存这个值的语法. 我们已经在上边接触
到相关内容: 要想访问提供的异常原因, 你必须保留一个变量来保存这个参数. 把这个参数放在
except 语句后, 接在要处理的异常后面. except 语句的这个语法可以被扩展为:
# single exception
except Exception[, reason]:
suite_for_Exception_with_Argument
# multiple exceptions
except (Exception1, Exception2, ..., ExceptionN)[, reason]:


suite_for_Exception1_to_ExceptionN_with_Argument
reason 将会是一个包含来自导致异常的代码的诊断信息的类实例. 异常参数自身会组成一个
元 组 , 并 存 储 为 类 实 例 ( 异 常 类 的 实 例 ) 的 属 性 . 上 边 的 第 一 种 用 法 中 , reason 将 会 是 一 个
Exception 类的实例.
对于大多内建异常, 也就是从 StandardError 派生的异常, 这个元组只包含一个指示错误原
因的字符串. 一般说来, 异常的名字已经是一个满意的线索了, 但这个错误字符串会提供更多的信
息. 操作系统或其他环境类型的错误, 例如 IOError , 元组中会把操作系统的错误编号放在错误字
符串前.
无论 reason 只包含一个字符串或是由错误编号和字符串组成的元组, 调用 str(reason) 总
会返回一个良好可读的错误原因. 不要忘记 reason 是一个类实例 - 这样做你其实是调用类的特
殊方法 __str__() . 我们将在第 13 章探索面向对象编程中的这些特殊方法.
唯一的问题就是某些第三方或是其他外部库并不遵循这个标准协议. 我们推荐你在引发你自己
的异常时遵循这个标准(参见核心风格笔记).
核心风格: 遵循异常参数规范
当你在自己的代码中引发内建(built-in)的异常时, 尽量遵循规范, 用和已有 Python 代码
一致错误信息作为传给异常的参数元组的一部分. 简单地说, 如果你引发一个 ValueError , 那么
最好提供和解释器引发 ValueError 时一致的参数信息, 如此类推. 这样可以在保证代码一致性,
同时也能避免其他应用程序在使用你的模块时发生错误.
如下边的例子, 它传参给内建 float 函数一个无效的对象, 引发 TypeError 异常:
>>> try:
...        float(['float() does not', 'like lists', 2])
... except TypeError, diag:# capture diagnostic info
...        pass
...
>>> type(diag)
<class 'exceptions.TypeError'>
>>>
>>> print diag
float() argument must be a string or a number
我们首先在一个 try 语句块中引发一个异常,随后简单的忽略了这个异常,但保留了错误的信
息。调用内置的 type()函数,我们可以确认我们的异常对象的确是 TypeError 异常类的实例。最后
我们对异常诊断参数调用 print 以显示错误。


为了获得更多的关于异常的信息,我们可以调用该实例的 __class__ 属性,它标示了实例是从
什么类实例化而来. 类对象也有属性, 比如文档字符串(documentation string)和进一步阐明错误
类型的名称字符串:
>>> diag    # exception instance object
<exceptions.TypeError instance at 8121378>
>>> diag.__class__    # exception class object
<class exceptions.TypeError at 80f6d50>
>>> diag.__class__.__doc__     # exception class documentation string
'Inappropriate argument type.'
>>> diag.__class__.__name__     # exception class name
'TypeError'
我们会在第 13 章"类和面向对象编程"发现, __class__ 属性存在于所有的类实例中,而__doc__
类属性存在于所有的定义了文档字符串的类中.
我们现在再次来改进我们的 saft_float()以包含异常参数,当 float()发生异常时传给解释器.
在前一次改进中,我们在一句话中同时捕获了 ValueError 和 TypeError 异常以满足某些需求.但还
是有瑕疵,那个解决方案中没有线索表明是哪一种异常引发了错误.它仅仅是返回了一个错误字符
串指出有无效的参数.现在,通过异常参数,可以改善这种状况.
因为每一个异常都将生成自己的异常参数,如果我们选择用这个字符串来而不是我们自定义的
信 息 , 可 以 提 供 一 个 更 好 的 线 索 来 指 出 问 题 . 下 面 的 代 码 片 段 中 , 我 们 用 字 符 串 化 (string
representation)的异常参数来替换单一的错误信息.
def safe_float(object):
try:
retval = float(object)
except (ValueError, TypeError), diag:
retval = str(diag)
return retval
在此基础上运行我们的新代码,当我们提供 sofe_float()的参数给不恰当时,虽然还是只有一条
捕获语句,但是可以获得如下(不同的)信息.
>>> safe_float('xyz')
'invalid literal for float(): xyz'
>>> safe_float({})
'object can't be converted to float'


10.3.7     在应用使用我们封装的函数
我们将在一个迷你应用中特地的使用这个函数.它将打开信用卡交易的数据文件
(carddata.txt),加载所有的交易,包括解释的字符串.下面是一个示例的 carddate.txt 文件:
% cat carddata.txt
# carddata.txt previous balance
25
debits
21.64
541.24
25
credits
-25
-541.24
finance charge/late fees
7.30
5
我们的程序,cardrun.py,见示例 10.1
示例 10.1 信用卡交易系统(cardrun.py)
我们用 safe_float()来处理信用卡交易文件,将其作为字符串读入.并用一个日志文件跟踪处理
进程.
1     #!/usr/bin/env python
2
3     def safe_float(obj):
4         'safe version of float()'
5         try:
6              retval = float(obj)
7         except (ValueError, TypeError), diag:
8             retval = str(diag)
9              return retval
10
11 def main():
12       'handles all the data processing'
13         log = open('cardlog.txt', 'w')
14         try:


15           ccfile = open('carddata.txt', 'r')
16       except IOError, e:
17           log.write('no txns this month\n')
18       log.close()
19       return
20
21       txns = ccfile.readlines()
22       ccfile.close()
23       total = 0.00
24       log.write('account log:\n')
25
26       for eachTxn in txns:
27           result = safe_float(eachTxn)
28           if isinstance(result, float):
29                total += result
30                log.write('data... processed\n')
31           else:
32              log.write('ignored: %s' % result)
33     print '$%.2f (new balance)' % (total)
34                log.close()
35
36 if __name__ == '__main__':
37       main()
逐行解读
行 3-9
这段代码是 safe_float()函数的主体
行 11-34
我们应用的核心部分有 3 个主要任务
(1)读入信用卡的数据文件
(2)处理输入
(3)显示结果
行 14-22
从文件中提取数据.你可以看到这里的文件打开被置于 try-except 语句段中.
同时还有一个处理的日志文件.在我们的例子中,我们假设这个日志文件可以不出错的打开.你
可以看到我们的处理进程伴随着这个日志文件.如果信用卡的数据文件不能够被访问,我们可以假设


该月没有信用卡交易(行 16 - 19).
数据被读入 txns(transactions 交易)列表,随后在 26-32 行遍历它.每次调用 safe_float()后,
我们用内建的 isinstance 函数检查结果类型.在我们例子中,我们检查 safe_float 是返回字符串还
是浮点数.任何字符串都意味着错误,表明该行不能转换为数字,同时所有的其他数字可以作为浮点
数累加入 total.在 main()函数的尾行会显示最终生成的余额.
行 36-37
这两行通常表明"仅在非导入时启动"的功能.运行我们程序,可以得到如下的输出
$ cardrun.py
$ 58.94 (new balance)
我们再看看 log 文件(cardlog.txt),我们可以看到在处理完 carddata.txt 中的交易后有其有如
下的记录条目:
$ cat cardlog.txt
account log:
ignored: invalid literal for float(): # carddata.txt
ignored: invalid literal for float(): previous balance
data... processed
ignored: invalid literal for float(): debits
data... processed
data... processed
data... processed
ignored: invalid literal for float(): credits
data... processed
10.3.8      else 子句
我们已经看过 else 语句段配合其他的 Python 语句,比如条件和循环.至于 try-except 语句段,
它的功能和你所见过的其他 else 没有太多的不同:在 try 范围中没有异常被检测到时,执行 else 子
句.
在 else 范围中的任何代码运行前,try 范围中的所有代码必须完全成功(也就是,结束前没有引发
异常).下面是用 Python 伪代码写的简短例子.
import 3rd_party_module


log = open('logfile.txt', 'w')
try:
3rd_party_module.function()
except:
log.write("*** caught exception in module\n")
else:
log.write("*** no exceptions caught\n")
log.close()
在前面的例子中,我们导入了一个外部的模块然后测试是否有错误.用一个日志文件来确定这个
第三方模块是有无缺陷.根据运行时是否引发异常,我们将在日志中写入不同的消息.
10.3.9     finally 子句
finally 子句是无论异常是否发生,是否捕捉都会执行的一段代码.你可以将 finally 仅仅配合
try 一起使用,也可以和 try-except(else 也是可选的)一起使用.独立的 try-finally 将会在下一章
介绍,我们稍后再来研究.
从 Python 2.5 开始,你可以用 finally 子句(再一次)与 try-except 或 try-except-else 一起
使用.之所以说是"再一次"是因为无论你相信与否,这并不是一个新的特性.回顾 Python 初期,这个特
性在早已存在,但是在 Python 0.9.6(1992 四月)中被移除.那时,这样可以简化字节码的生成,并方便
解析,另外就是范·罗萨姆认为一个标准化的 try-except(-else)-finally 无论如何不会太流行.然
而,十年时间改变了一切!
下面是 try-except-else-finally 语法的示例:
try:
A
except MyException: B
else: C
finally: D
等价于 Python 0.9.6 至 2.4.x 中如下的写法:
try:
try:
A


except MyException:
B
else: C
finally:
D
当然,无论如何,你都可以有不止一个的 except 子句,但最少有一个 except 语句,而 else 和
finally 都是可选的.A,B,C 和 D 是程序(代码块).程序会按预期的顺序执行.(注意:可能的顺序是
A-C-D[正常]或 A-B-D[异常]).无论异常发生在 A,B,和/或 C 都将执行 finally 块.旧式写法依然有效,
所以没有向后兼容的问题.
10.3.10      try-finally 语句
另一种使用 finally 的方式是 finally 单独和 try 连用.这个 try-finally 语句和 try-except
区别在于它不是用来捕捉异常的.作为替代,它常常用来维持一致的行为而无论异常是否发生.我们
得知无论 try 中是否有异常触发,finally 代码段都会被执行
try:
try_suite
finally:
finally_suite    #无论如何都执行
当在 try 范围中产生一个异常时,(这里)会立即跳转到 finally 语句段.当 finally 中的所有代
码都执行完毕后,会继续向上一层引发异常.
因而常常看到嵌套在 try-except 中的 try-finally 语句.当在读取 carddata.txt 中文本时可能
引发异常,我们可以在 cardrun.py 的这一处添加 try-finally 语句段来改进代码.在当前示例 10.1
的代码中,我们在读取阶段没有探测到错误(通过 readlines())
try:
ccfile = open('carddata.txt')
except IOError:
log.write('no txns this month\n')
txns = ccfile.readlines()
ccfile.close()
但有很多原因会导致 readlines()失败,其中一种就是 carddata.txt 存在于网络(或软盘)上,但
是变得不能读取.无论怎样,我们可以把这一小段读取数据的代码整个放入 try 子句的范围中:


try:
ccfile = open('carddata.txt', 'r')
txns = ccfile.readlines()
ccfile.close()
except IOError:
log.write('no txns this month\n')
我们所做的一切不过是将 readline()和 close()方法调用都移入了 try 语句段.尽管我们代码变
得更加的健壮了,但还有改进的空间.注意如果按照这样的顺序发生错误:打开成功,但是出于一些原
因 readlines()调用失败,异常处理会去继续执行 except 中的子句,而不去尝试关闭文件.难道没有一
种好的方式来关闭文件而无论错误是否发生?我们可以通过 try-finally 来实现:
ccfile = None
try:
try:
ccfile = open('carddata.txt', 'r')
txns = ccfile.readlines()
except IOError:
log.write('no txns this month\n')
finally:
if ccfile:
ccfile.close()
代码片段会尝试打开文件并且读取数据.如果在其中的某步发生一个错误,会写入日志,随后文
件 被 正 确 的 关 闭 . 如 果 没 有 错 误 发 生 , 文 件 也 会 被 关 闭 .( 同 样 的 功 能 可 以 通 过 上 面 标 准 化 的
try-except-finally 语句段实现).另一种可选的实现切换了 try-except 和 try-finally 包含的方式,
如:
ccfile = None
try:
try:
ccfile = open('carddata.txt', 'r')
txns = ccfile.readlines()
finally:
if ccfile:
ccfile.close()
except IOError:
log.write('no txns this month\n')


代码本质上干的是同一种工作,除了一些小小的不同.最显著的是关闭文件发生在异常处理器将
错误写入日志之前.这是因为 finally 会自动的重新引发异常.
一个这样写的理由是如果在 finally 的语句块内发生了一个异常,你可以创建一个同现有的异常
处理器在同一个(外)层次的异常处理器来处理它.这样,从本质上来说,就可以同时处理在原始的 try
语句块和 finally 语句块中发生的错误.这种方法唯一的问题是,当 finally 语句块中的确发生异常
时,你会丢失原来异常的上下文信息,除非你在某个地方保存了它.
反对这种写法的一个理由是:在很多情况下,异常处理器需要做一些扫尾工作,而如果你在异常
处理之前,用 finally 语句块中释放了某些资源,你就不能再去做这项工作了.简单的说,finally 语句
块并不是如你所想的是"最终的(final)"了.
一个最终的注意点:如果 finally 中的代码引发了另一个异常或由于 return,break,continue 语
法而终止,原来的异常将丢失而且无法重新引发.
10.3.11     try-except-else-finally:厨房一锅端
我们综合了这一章目前我们所见过的所有不同的可以处理异常的语法样式:
try:
try_suite
except Exception1:
suite_for_Exception1
except (Exception2, Exception3, Exception4):
suite_for_Exceptions_2_3_and_4
except Exception5, Argument5:
suite_for_Exception5_plus_argument
except (Exception6, Exception7), Argument67:
suite_for_Exceptions6_and_7_plus_argument
except:
suite_for_all_other_exceptions
else:
no_exceptions_detected_suite


finally:
always_execute_suite
回顾上面的,finally 子句和 try-except 或 try-except-else 联合使用是 Python 2.5 的"新"有
的.这一节最重要的是无论你选择什么语法,你至少要有一个 except 子句,而 else 和 finally 都是可
选的.
10.4    上下文管理
10.4.1     with 语句
如上所述的标准化的 try-except 和 try-finally 可以使得程序更加"Pythonic",其含义是,在许
多的其他特性之外,更加写地轻松,读地自在.Python 对隐藏细节已经做了大量的工作,因此需要你操
心的仅是如何解决你所遇到问题.(你能假想移植一个复杂的 Python 应用到 C++或 Java 吗?!?)
另一个隐藏低层次的抽象的例子是 with 语句,它在 Python 2.6 中正式启用.(Python2.5 尝试性
的引入了 with, 并对使用 with 作为标识符的应用程序发出这样的警告 - 在 Python 2.6 中,with
将会成为关键字. 如果你想在 Python 2.5 使用 with 语句, 你必须用 from __future__ import
with_statement 来导入它.)
类似 try-except-finally , with 语句也是用来简化代码的,这与用 try-except 和 try-finally
所想达到的目的前后呼应.try-except 和 try-finally 的一种特定的配合用法是保证共享的资源的
唯一分配,并在任务结束的时候释放它.比如文件(数据,日志,数据库等等),线程资源,简单同步,数
据库连接,等等. with 语句的目标就是应用在这种场景.
然而,with 语句的目的在于从流程图中把 try,except 和 finally 关键字和资源分配释放相关
代码统统去掉, 而不是像 try-except-finally 那样仅仅简化代码使之易用. with 语法的基本用法
看上去如下:
with context_expr [as var]:
with_suite
看起来如此简单,但是其背后还有一些工作要做.这并不如看上去的那么容易,因为你不能对
Python 的任意符号使用 with 语句.它仅能工作于支持上下文管理协议(context management
protocol)的对象.这显然意味着只有内建了"上下文管理"的对象可以和 with 一起工作.我们过一会
再来阐明它的含义.
现在,正如一个新的游戏硬件,每当有一个新的特性推出时,第一时间总有人开发出相应的新游
戏,从而你打开盒子就可以开始玩了.类似,目前已经有了一些支持该协议的对象.下面是第一批成员
的简短列表:


z   file
z   decimal.Context
z    thread.LockType
z    threading.Lock
z   threading.RLock
z   threading.Condition
z   threading.Semaphore
z   threading.BoundedSemaphore
既然 file 是上面的列表上的第一个也是最易于演示的,下面就给出一段和 with 一起使用的代码
片段.
with open('/etc/passwd', 'r') as f:
for eachLine in f:
# ...do stuff with eachLine or f...
这个代码片段干了什么呢...嗯,这是 Python,因而你很可能的已经猜到了.它会完成准备工作,
比如试图打开一个文件,如果一切正常,把文件对象赋值给 f.然后用迭代器遍历文件中的每一行,当
完成时,关闭文件.无论的在这一段代码的开始,中间,还是结束时发生异常,会执行清理的代码,此
外文件仍会被自动的关闭.
因为已经从你手边拿走了一堆细节,所以实际上只是进行了两层处理:
第一,发生用户层 —— 和 in 类似,你所需要关心的只是被使用的对象
第二,在对象层.既然这个对象支持上下文管理协议,它干的也就是"上下文管理".
10.4.2      *上下文管理协议
除非你打算自定义可以和 with 一起工作的类,比如:别的程序员会在他们的设计的应用中使用你
的对象.
绝大多数 Python 程序员仅仅需要使用 with 语句,可以跳过这一节.
我们不打算在这里对上下文管理做深入且详细的探讨,但会介绍兼容协议所必须的对象类型与
功能,使其能和 with 一起工作.
前面,我们在例子中描述了一些关于协议如何和文件对象协同工作.让我们在此进一步地研究.
上下文表达式(context_expr),上下文管理器


当 with 语句执行时,便执行上下文符号(译者注:就是 with 与 as 间内容)来获得一个上下文管理
器.上下文管理器的职责是提供一个上下文对象.这是通过调用__context__()方法来实现的.该方法
返回一个上下文对象,用于在 with 语句块中处理细节.有点需要注意的是上下文对象本身就可以是上
下文管理器.所以 context_expr 既可以为一个真正的上下文管理器,也可以是一个可以自我管理的上
下文对象.在后一种情况时,上下文对象仍然有__context__()方法,返回其自身,如你所想.
上下文对象,with 语句块
一旦我们获得了上下文对象,就会调用它的__enter()__方法.它将完成 with 语句块执行前的所
有准备工作.你可以注意到在上面的 with 行的语法中有一个可选的 as 声明变量跟随在 context_expr
之后.如果提供提供了变量,以__enter()__返回的内容来赋值;否则,丢弃返回值.在我们的文件对象
例子中,上下文对象的__enter()__返回文件对象并赋值给 f.
现在,执行了 with 语句块.当 with 语句块执行结束,无论是"和谐地"还是由于异常,都会调用上
下文对象的__exit()__方法.__exit__()有三个参数.如果 with 语句块正常结束,三个参数全部是
None.如果发生异常,三个参数的值的分别等于调用 sys.exc_info()函数(见 10.12)返回的三个值:类
型(异常类),值(异常实例),和回溯(traceback),相应的回溯对象.
你可以自己决定如何在__exit__()里面处理异常.惯例是当你处理完异常时不返回任何值,或
返回 None,或返回其他布尔值为 False 对象.这样可以使异常抛给你的用户来处理.如果你明确的想
屏蔽这个异常,返回一个布尔为 True 的值.如果没有发生异常或你在处理异常后返回 True,程序会继
续执行 with 子句后的下一段代码.
因为上下文管理器主要作用于共享资源,你可以想象到__enter()__和__exit()__方法基本是干
的需要分配和释放资源的低层次工作,比如:
数据库连接,锁分配,信号量加减,状态管理,打开/关闭文件,异常处理,等等.
为 了 帮 助 你 编 写 对 象 的 上 下 文 管 理 器 , 有 一 个 contextlib 模 块 , 包 含 了 实 用 的
functions/decorators, 你 可 以 用 在 你 的 函 数 / 对 象 上 而 不 用 去 操 心 关 于 类 或
__context__(),__enter()__,__enter()__,__exit()__这些方法的实现.
想了解更多关于上下文管理器的信息,查看官方的 Python 文档的 with 语法和 contextlib 模块,
类的指定方法(与 with 和 contexts 相关的),PEP 343,和“What’s New in Python 2.5(Python 2.5
的更新)”的文档.
10.5    *字符串作为异常
早在 Python 1.5 前,标准的异常是基于字符串实现的.然而,这样就限制了异常之间不能有相互
的关系.这种情况随着异常类的来临而不复存在.到 1.5 为止,所有的标准异常都是类了.程序员还是


可以用字符串作为自己的异常的,但是我们建议从现在起使用异常类.
为了向后兼容性,还是可以启用基于字符串的异常.从命令行以-X 为参数启动 Python 可以提供你
字符串方式的标准异常.从 Python1.6 起这个特性被视为废弃的.
Python 2.5 开始处理向来不赞成使用的字符串异常.在 2.5 中,触发字符串异常会导致一个警告.
在 2.6,捕获字符串异常会导致一个警告.由于它很少被使用而且已经被废弃,我们将不再在本书范围
内考虑字符串异常并且已经去除相关文字.(在本书的早期的版本中你会找到这些.)唯一也是最后的
中肯警告是:你可能用到仍然使用着字符串异常的外部或第三方的模块.字符串异常总而言之是一个
糟糕的想法.读者可以回想,有着拼写错误的 Linux RPM 异常如在眼前.
10.6    触发异常
到目前为止,我们所见到的异常都是由解释器引发的.由于执行期间的错误而引发.程序员在编
写 API 时也希望在遇到错误的输入时触发异常,为此,Python 提供了一种机制让程序员明确的触发异
常:这就是 raise 语句.
10.6.1    raise 语句
语法与惯用法
raise 语句对所支持是参数十分灵活,对应到语法上就是支持许多不同的格式.rasie 一般的用法
是:
raise [SomeException [, args [, traceback]]]
第一个参数,SomeExcpetion,是触发异常的名字.如果有,它必须是一个字符串,类或实例(详见
下文).如果有其他参数(arg 或 traceback),就必须提供 SomeExcpetion.Python 所有的标准异常见表
10.2.
第二个符号为可选的 args(比如参数,值),来传给异常.这可以是一个单独的对象也可以是一个
对象的元组.当异常发生时,异常的参数总是作为一个元组传入.如果 args 原本就是元组,那么就将其
传给异常去处理;如果 args 是一个单独的对象,就生成只有一个元素的元组(就是单元素元组).大多
数情况下,单一的字符串用来指示错误的原因.如果传的是元组,通常的组成是一个错误字符串,一个
错误编号,可能还有一个错误的地址,比如文件,等等.
最后一项参数,traceback,同样是可选的(实际上很少用它),如果有的话,则是当异常触发时新
生成的一个用于异常-正常化(exception—normally)的追踪(traceback)对象.当你想重新引发异常


时,第三个参数很有用(可以用来区分先前和当前的位置).如果没有这个参数,就填写 None.
最常见的用法为 SomeException 是一个类.不需要其他的参数,但如果有的话,可以是一个单一对
象参数,一个参数的元组,或一个异常类的实例.如果参数是一个实例,可以由给出的类及其派生类实
例化(已存在异常类的子集).若参数为实例,则不能有更多的其他参数.
更多的特殊/少见的惯用法
当参数是一个实例的时候会发生什么呢? 该实例若是给定异常类的实例当然不会有问题, 然而,
如果该实例并非这个异常类或其子类的实例时, 那么解释器将使用该实例的异常参数创建一个给定
异常类的新实例. 如果该实例是给定异常类子类的实例, 那么新实例将作为异常类的子类出现, 而
不是原来的给定异常类.
如果 raise 语句的额外参数不是一个实例——作为替代,是一个单件(singleton)或元组—那么,
将用这些作为此异常类的初始化的参数列表.如果不存在第二个参数或是 None,则参数列表为空.
如果 SomeException 是一个实例,我们就无需对什么进行实例化了.这种情况下,不能有额外的参
数或只能是 None.
异常的类型就是实例的类;也就是说,等价于触发此类异常,并用该实例为参数:比如 raise
instance.__class__,instance.
我们建议用异常类,不赞成用字符串异常.但如果用字符串作为 SomeException,那么会触发一
个用字符串标识的异常,还有一个可选的参量(args)作参数.
最后,这种不含任何参数的 raise 语句结构是在 Python1.5 中新引进的,会引发当前代码块(code
block)最近触发的一个异常.如果之前没有异常触发,会因为没可以有重新触发的异常而生成一个
TypeError 异常.
由于 raise 有许多不同格式有效语法(比如:SomeException 可以是类,实例或一个字符串),我们
提供表 10.1 来阐明 rasie 的不同用法.
表 10.1   raise 语句的用法
rasie 语法            描述
raise exclass       触发一个异常,从 exclass 生成一个实例(不含任何异常参数)
raise exclass()     同上,除了现在不是类;通过函数调用操作符(function calloperator:
"()")作用于类名生成一个新的 exclass 实例,同样也没有异常参数
raise exclass, args    同上,但同时提供的异常参数 args,可以是一个参数也可以元组
raise exclass(args)     同上
raise exclass,args, tb    同上,但提供一个追踪(traceback)对象 tb 供使用


raise exclass,instance    通过实例触发异常(通常是 exclass 的实例);如果实例是 exclass
的子类实例,那么这个新异常的类型会是子类的类型(而不是
exclass);如果实例既不是 exclass 的实例也不是 exclass 子类的
实例,那么会复制此实例为异常参数去生成一个新的 exclass 实例.
raise  instance            通 过 实 例 触 发 异 常 : 异 常 类 型 是 实 例 的 类 型 ; 等 价 于 raise
instance.__class__, instance (同上).
raise  string             (过时的) 触发字符串异常
raise  string, args       同上,但触发伴随着 args
raise  string, args, tb   同上,但提供了一个追踪(traceback)对象 tb 供使用
raise                   (1.5 新增)重新触发前一个异常,如果之前没有异常,触发 TypeError.
10.7     断言
断言是一句必须等价于布尔真的判定;此外,发生异常也意味着表达式为假.这些工作类似于 C 语
言预处理器中 assert 宏,但在 Python 中它们在运行时构建(与之相对的是编译期判别).
如果你刚刚接触断言这个概念,无妨.断言可以简简单单的想象为 raise-if 语句(更准确的说是
raise-if-not 语句).测试一个表达式,如果返回值是假,触发异常.
断言通过 assert 语句实现,在 1.5 版中引入.
10.7.1       断言语句
断言语句等价于这样的 Python 表达式,如果断言成功不采取任何措施(类似语句),否则触发
AssertionError(断言错误)的异常.assert 的语法如下:
assert expression[, arguments]
下面有一些演示 assert 用法的语句:
assert  1 == 1
assert  2 + 2 == 2 * 2
assert  len(['my list', 12]) < 10
assert  range(3) == [0, 1, 2]
AssertionError 异常和其他的异常一样可以用 try-except 语句块捕捉,但是如果没有捕捉,它将
终止程序运行而且提供一个如下的 traceback:


>>> assert 1 == 0
Traceback (innermost last): File "<stdin>", line 1, in ?
AssertionError
如同先前章节我们研究的 raise 语句,我们可以提供一个异常参数给我们的 assert 命令:
>>> assert 1 == 0, 'One does not equal zero silly!' Traceback (innermost last):
File "<stdin>", line 1, in ?
AssertionError: One does not equal zero silly!
下面是我们如何用 try-except 语句捕获 AssertionError 异常:
try:
assert 1 == 0, 'One does not equal zero silly!'
except AssertionError, args:
print '%s: %s' % (args.__class__.__name__, args)
从命令行执行上面的代码会导致如下的输出:
AssertionError: One does not equal zero silly!
为了让你更加了解 assert 如何运作,想象一下断言语句在 Python 中如何用函数实现.可以像下
面这样:
def assert(expr, args=None):
if __debug__ and not expr:
raise AssertionError, args
此处的 if 语句检查 assert 的语法是否合适,也就是 expr 必须是一个表达式.我们比较 expr
的类型和真正的表达式来确认.函数的第二部分对表达式求值然后根据结果选择性的引发异常.内建
的变量__debug__在通常情况下为 True,如果开启优化后为 False(命令行选项-O)(Python 2.2 后为
布尔值 True 和 False.)
10.8     标准异常
表 10.2 列出了所有的 Python 当前的标准异常集,所有的异常都是内建的. 所以它们在脚本启动
前或在互交命令行提示符出现时已经是可用的了.
表 10.2   Python 内建异常


异常名称                      描述
a
BaseException 所有异常的基类
SystemExitb            python 解释器请求退出
KeyboardInterruptc                 用户中断执行(通常是输入^C)
d
Exception            常规错误的基类
e
StopIteration               迭代器没有更多的值
a
GeneratorExit               生成器(generator)发生异常来通知退出
h
SystemExit             Python 解释器请求退出
g
StandardError                      所有的内建标准异常的基类
d
ArithmeticError                      所有数值计算错误的基类
d
FloatingPointError                    浮点计算错误
OverflowError                数值运算超出最大限制
ZeroDivisionError                      除(或取模)零 (所有数据类型)
d
AssertionError                      断言语句失败
AttributeError                     对象没有这个属性
EOFError                  没有内建输入,到达 EOF 标记
EnvironmentErrord                     操作系统错误的基类
IOError                         输入/输出操作失败
d
OSError                          操作系统错误
h
WindowsError                       Windows 系统调用失败
ImportError                    导入模块/对象失败
f
KeyboardInterrupt                     用户中断执行(通常是输入^C)
d
LookupError                    无效数据查询的基类
IndexError                       序列中没有没有此索引(index)
KeyError                          映射中没有这个键
MemoryError                 内存溢出错误(对于 Python 解释器不是致命的)
NameError               未声明/初始化对象 (没有属性)
UnboundLocalErrorh 访问未初始化的本地变量
ReferenceErrore 弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError              一般的运行时错误
NotImplementedErrord                尚未实现的方法
SyntaxError                     Python 语法错误
g
IndentationError 缩进错误
TabErrorg                      Tab 和空格混用
SystemError                  一般的解释器系统错误
TypeError          对类型无效的操作
ValueError           传入无效的参数
h
UnicodeError                   Unicode 相关的错误
i
UnicodeDecodeError                    Unicode 解码时的错误
i
UnicodeEncodeError                  Unicode 编码时错误


UnicodeTranslateErrorf    Unicode 转换时错误
j
Warning                警告的基类
j
DeprecationWarning 关于被弃用的特征的警告
FutureWarningi      关于构造将来语义会有改变的警告
k
OverflowWarning        旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarningi    关于特性将会被废弃的警告
j
RuntimeWarning       可疑的运行时行为(runtime behavior)的警告
j
SyntaxWarning          可疑的语法的警告
j
UserWarning         用户代码生成的警告
a. Python2.5 新增
b. 在 Python2.5 前,Exception 的子类 SystemExit
c.在 Python2.5 前,StandardError 的子类 KeyboardInterrupt
d.Python1.5 新增,用基于类的异常来替代字符串
e.Python2.2 新增
f.Python1.6 新增
g.Python2.0 新增
h.Python1.6 新增
i.Python2.3 新增
j.Python2.1 新增
k.Python2.2 新增,但在 Python2.4 时移除
所有的标准/内建异常都是从根异常派生的.目前,有 3 个直接从 BaseException 派生的异常子
类:SystemExit,KeyboardInterrupt 和 Exception.其他的所有的内建异常都是 Exception 的子类.表
10.2 中的每一层缩进都代表一次异常类的派生.
到了 Python2.5,所有的异常的都是新风格(new-style)的类,并且最终都是 BaseException 的子
类.在这一版中,SystemExit 和 KeyboardInterrupt 从 Exception 的继承中移到 BaseException 的继
承下.这样可以允许如 except Exception 的语句捕获所有非控制程序退出的异常.
从 Python1.5 到 Python2.4.x,异常是标准的类,在这之前,他们是字符串.从 Python2.5 开始,不
再支持构建基于字符串的异常并且被正式的弃用,也就是说你不能再触发一个字符串异常了.在 2.6,
你将不能捕获他们.还有一个要求就是所有新的异常最终都是 BaseException 的子类,以便于他们有
一个统一的接口.这将从 Python2.7 开始,并在余下的 Python2.x 发布版中延续.
10.9     *创建异常
尽管标准异常集包含的内容已经相当广泛,你还是可以创建自己的异常.一种情况是你想在特定
的标准异常和模块异常中添加额外的信息.我们将介绍两个例子,都与 IOError 有关.IOError 是一个


用于输入/输出的通用异常,可能在无效的文件访问或其他形式的通信中触发.假如我们想要更加明
确的标明问题的来源,比如:对于文件错误,我们希望有行为类似 IOError 的一个 FileError 异常,但
是名字表明是在执行文件操作.
我 们 将 查 看 的 另 一 个 异 常 与 套 接 字 (socket) 网 络 编 程 有 关 .socket 模 块 生 成 的 异 常 叫
socket.error,不是内建的异常.它从通用 Exception 类派生.然而 socket.error 这个异常的宗旨和
IOError 很类似,所以我们打算定义一个新的从 IOError 派生的 NetworkError 的异常,但是其包含了
socket.error 提供的信息.
如同类和面向对象编程,我们暂时不会正式介绍网络编程,如果你需要的话可以跳到 16 章.
我们现在给出一个叫做 myexc.py 的模块和我们自定义的新异常 FileError 与 NetworkError.代
码如 10.2.
例:10.2 创建异常(myexc.py)
此 模 块 定 义 了 两 个 新 的 异 常 ,FileError 和 NetworkError, 也 重 新 实 现 了 一 个 诊 断 版 的
open()[myopen()]和 socket.connect()[myconnect()].同时包含了一个测试函数[test()],当直接
运行文件时执行.
1   #!/usr/bin/env python
2
3    import os, socket, errno, types, tempfile
4
5    class NetworkError(IOError):
6    pass
7
8    class FileError(IOError):
9    pass
10
11    def updArgs(args, newarg=None):
12    if isinstance(args, IOError):
13    myargs = []
14    myargs.extend([arg for arg in args])
15    else:
16    myargs = list(args)
17
18    if newarg:
19    myargs.append(newarg)
20


21  return tuple(myargs)
22
23  def fileArgs(file, mode, args):
24  if args[0] == errno.EACCES and \
25  'access' in dir(os):
26  perms = ''
27  permd = { 'r': os.R_OK, 'w': os.W_OK,
28  'x': os.X_OK}
29  pkeys = permd.keys()
30  pkeys.sort()
31  pkeys.reverse()
32
33  for eachPerm in 'rwx':
34  if os.access(file, permd[eachPerm]):
35  perms += eachPerm
36  else:
37  perms += '-'
38
39  if isinstance(args, IOError):
40  myargs = []
41  myargs.extend([arg for arg in args])
42  else:
43  myargs = list(args)
44
45  myargs[1] = "'%s' %s (perms: '%s')" % \
46  (mode, myargs[1], perms)
47
48  myargs.append(args.filename)
49
50  else:
51  myargs = args
52
53  return tuple(myargs)
54
55  def myconnect(sock, host, port):
56  try:
57  sock.connect((host, port))
58
59  except socket.error, args:
60  myargs = updArgs(args)    # conv inst2tuple


61    if len(myargs) == 1:     # no #s on some errs
62    myargs = (errno.ENXIO, myargs[0])
63
64    raise NetworkError, \
65    updArgs(myargs, host + ':' + str(port))
66
67 def myopen(file, mode='r'):
68     try:
69    fo = open(file, mode)
70    except IOError, args:
71    raise FileError, fileArgs(file, mode, args)
72
73    return fo
74
75    def testfile():
76
77    file = mktemp()
78    f = open(file, 'w')
79    f.close()
80
81    for eachTest in ((0, 'r'), (0100, 'r'),
82    (0400, 'w'), (0500, 'w')):
83    try:
84    os.chmod(file, eachTest[0])
85    f = myopen(file, eachTest[1])
86
87    except FileError, args:
88    print "%s: %s" % \
89    (args.__class__.__name__, args)
90    else:
91    print file, "opened ok... perm ignored"
92    f.close()
93
94    os.chmod(file, 0777)# enable all perms
95    os.unlink(file)
96
97 def testnet():
98     s = socket.socket(socket.AF_INET,
99         socket.SOCK_STREAM)
100


101    for eachHost in ('deli', 'www'):
102    try:
103    myconnect(s, 'deli', 8080)
104    except NetworkError, args:
105    print "%s: %s" % \
106    (args.__class__.__name__, args)
107
108    if __name__ == '__main__':
109    testfile()
110    testnet()
行 1-3
模块的开始部分是 Unix 启动脚本和 socket,os,errno,types 和 tempfile 模块的导入.
行 5-9
无论你是否相信,这 5 行代码定义了我们的新异常.不是仅仅一个,而是两个.除了将要介绍的一
个新功能,创建一个新的异常仅需要从一个已经存在的异常类派生一个出子类.本例中,这个基类是
IOError. 我们也可以从 IOError 的基类 EnvironmentError 派生,但我们想明确表明我们的异常是
I/O 相关的.
我们选择 IOError 是因为它提供了两个参数,一个错误编号和一个错误字符串.文件相关[用
open()]的 IOError 异常甚至支持大部分异常没有的第三个参数,那个可以是文件名.我们将对这个在
主要元组之外的,名字叫"filename"的参数执行一些特定的操作.
行 11-21
updArgs()函数的全部意图就是"更新"异常的参数.我们这里的意思是原来的异常提供给我们一
个参数集.我们希望获取这些参数并让其成为我们新的异常的一部分,可能是嵌入或添加第三个参数
(如果没有传入,什么也不添加—None 是其默认值,我们下一章将会学习).我们的目标是提供更多的
细节信息给用户,这样当问题发生时能够尽快的捕捉到.
Lines 23–53
函数 fileArgs()仅在 myopen()中使用(如下).实际上,我们寻找表示"permissiondenied.(没有
权限.)"的错误 EACCES.其他所有的 IOError 异常我们将不加修改(行 54-55)的传递.如果你对 ENXIO,
EACCES 和其他的系统错误号感到好奇,你可以从 Unix 系统下/usr/include/sys/errno.h 或 Windows
系统下 Visula C++的 C:\Msdev\include\Errno.h 文件来对它们刨根究底.
在第 27 行,我们也确认了我们当前使用的机器支持 os.access()函数,它用来检查对任意一个特
定文件你所拥有的权限.除非我们收到权限错误同时也能够检查我们拥有的权限,否则我们什么不做.
当一切完毕,我们设置一个字典来帮助构建表示我们对文件所拥有的权限的字符串.


Unix 文件系统清晰标明用户(user),组(group,可以有多个用户属于一个组)和其他(other,不是
所有者,也不和所有者同组的用户)对文件的读,写,执行(‘r’, ‘w’, ‘x’)的权限.
Windows 支持这些权限中的一部分.现在可以来构建权限字符串了.如果对文件有某种权限,字符
串中就有相应的字母,否则用'-'替代..比如,字符串'rw-'标明你可以对其进行读/写访问.如果字符
串是'r-x',你仅可以对其进行读和执行操作;'---'标示没有任何权限.
当权限字符串构建完成后,我们创建了一个临时的参数列表.我们随后更改了错误字符串使之包
含权限字符串.(标准的 IOError 异常并没有提供权限字符串相关信息). 如果系统并没有告诉你具有
什么权限才能来解决这个问题,而只是显示"Permission denied(没有权限)" 这个错误信息,这似
乎是很愚蠢。 当然这是出于安全的考虑. 当入侵者没有权限访问某个数据的时候, 最好不要让他们
看到这个文件的权限是什么。不过, 我们的例子仅仅是一个练习, 所以我们可以暂时"违背安全"信
条。 问题的关键在于确认调用 os.chmod() 函数,它能够按照你的意愿来修改文件的权限。
最后一件事情我们把文件名加入参数列表,并以元组形式返回参数.
行 55-65
我们新的 myconnect()函数仅仅是简单的对套接字的函数 conect()进行包装当网络连接失败时
提供一个 IOError 类型的异常.和一般的 socket.error 不一样,我们还提供给程序员主机名和端口
号.
对于刚刚接触网络编程的,主机名和端口号可以想象为当你联系某人时的区号和电话号.在这
个例子中,我们试着去连接一个在远程主机上运行的程序,可能是某种服务. 因此我们需要知道主机
名和服务器监听的端口.
当失败发生时,错误号和错误字符很有帮助,但是如果结合更精确的主机-端口会更有帮助,因为
这一对可能是由某个数据库或名称服务动态生成或重新获得.这些值由我们版本的 connect()加入.
另一种情形是无法找到主机,socket.error 异常没有直接提供的错误号,我们为了遵循 IOError 协议,
提供了一个错误号-错误字符串对,我们查找最接近的错误号.我们选用的 ENXIO.
行 67-73
类似同类 myconnect(),myopen()也封装了已经存在的一些代码.这里,我们用的是 open()函数.
我们仅仅捕捉 IOError 异常.所有的其他都忽略并传给下一层(因为没有与他们相关的处理器).一旦
捕捉到 IOError 我们引发我们自己的异常并通过 fileArgs()返回值来定制参数.
行 75-95
我们首先测试文件,这里使用 testfile()函数.开始之前,我们需要新建一个测试文件,以便我们
可以手工的修改其权限来造成权限错误.这个 tempfile 模块包含了创建临时文件文件名和临时文件
的代码.当前我们仅仅需要文件名,然后用 myopen()函数来创建一个空的文件.注意,如果此次产生了
错误,我们不会捕获,我们的程序将致命的终止——测试程序当我们连文件都无法创建时不会继续.


我们的测试用了 4 种不同的权限配置.零标示没有任何权限,0100 表示仅能执行,0400 表示只
读,0500 表示只可读或执行(0400+0100).在所有的情况下,我们试图用一种无效的方式打开文
件.os.chmod()被用来改变文件的权限(注意:这些权限有前导的零,表明他们是八进制[基数 8]数)
如果发生错误,我们希望可以显示诊断的信息,类似 Python 解释器捕获异常时所做的那样. 这就
是给出异常名和紧跟其后的异常的参数.__class__属性表示实例化该实例的类对象. 比在此显示完
整的类名(myexc.FileError)更好的做法是通过类对象的__name__属性来显示类名(FileError),这
也是异常未被捕获时你在解释器所见到的.随后是我们在封装函数中辛辛苦苦聚到一起的参数.
如果文件被打开成功,也就是权限由于某种原因被忽略.我们通过诊断信息指明并关闭文件.当
所有的测试都完成时,我们对文件开启所有的权限然后用 os.unlink()移除(os.remove()等价于
os.unlink()).
行 97-106
下一段代码(testnet())测试了我们的网络异常.套接字是一个用来与其他主机建立连接的通信
端点.我们创建一个套接字,然后用它连接一个没有接受我们连接的服务器的主机和一个不存在于我
们网络的主机.
行 108-110
我们希望仅在直接调用我们脚本时执行 test*()函数,此处的代码完成了该功能.大多数脚本用
同样的格式给出了这段文本.
在 Unix 系的机器上运行这段脚本,我们得到了如下的输出:
$myexc.py
FileError: [Errno 13] 'r' Permission denied (perms: '---'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'r' Permission denied (perms: '--x'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r--'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'/usr/tmp/@18908.1'
NetworkError: [Errno 146] Connection refused: 'deli:8080' NetworkError: [Errno 6] host
not found: 'www:8080'
在 Win32 的机器上有些许的不同:
D:\python> python myexc.py
C:\WINDOWS\TEMP\~-195619-1 opened ok... perms ignored C:\WINDOWS\TEMP\~-195619-1


opened ok... perms ignored FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'C:\\WINDOWS\\TEMP\\~-195619-1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'C:\\WINDOWS\\TEMP\\~-195619-1'
NetworkError: [Errno 10061] winsock error: 'deli:8080' NetworkError: [Errno 6] host
not found: 'www:8080'
你可以看到 Windows 不支持文件的读权限,这就是前两次尝试文件打开成功的原因.在你的机器
和操作系统上的结果可能会大相径庭。
10.10     为什么用异常(现在)?
毫无疑问,错误的存在会伴随着软件的存在.区别在于当今快节奏的计算世界, 我们的执行环境
已经改变, 所以我们需要改变错误处理, 以准确反映我们软件的开发环境. 就现今应用来说, 普遍
的是自洽(self-contained)的图形用户界面(GUIs)或是客户机/服务器体系, 例如 Web.
在应用层处理错误的能力近来变得更为重要, 用户已不再是应用程序的的唯一的直接运行者.
随着互联网和网上电子商业应用越来越普及, web 服务器将成为应用软件的主要客户. 这意味着应用
程序再也不能只是直接的失败或崩溃, 因为如果这样, 系统错误导致浏览器的错误, 这反过来又
会让用户沮丧. 失去眼球意味着失去广告收入和和潜在的大量无可挽回的生意.
如果错误的确发生了, 它们一般都归因于用户输入的数据无效. 运行环境必须足够强健,来处
理应用级别的错误,并提供用户级别的错误信息.就服务器而言,这必须转化为一个"非错误" . 因为
应用必须要成功的完成, 即使所做的不过是返回一个错误的信息, 向用户是提供一个有效的超文本
标记语言(HTML)的网页指明错误.
如果你不清楚我在说什么, 那个一个简单的网页浏览器窗口,用大而黑的字体写到"内部服务器
错误"是否更耳熟?用一个弹出式窗口宣告"文件中没有数据"的致命错误如何?作为一个用户, 这
些词语对你有意义吗?没有, 当然没有(除非你是一个互联网软件工程师), 至于对普通用户来说,
这些是无休止的混乱和挫折感的来源. 这些错误导致在执行的程序时的失败. 应用不论是返回无效
的超文本传输协议( http)数据还是致命地终止, 都会导致 Web 服务器举手投降, 说: "我放弃" !
这种类型的执行错误不应该被允许, 无论情况如何. 随着系统变得更加复杂, 又牵涉到更多的
新手用户, 要采取额外的措施, 确保用户平滑的学到应用经验. 即使面对一个错误, 应用应该成功
的中止, 不至于灾难性的影响其执行环境. Python 异常处理促使成熟和正确的编程.
10.11 到底为什么要异常?
如果上文的动机不够充分, 试想 Python 编程没有程序级的异常处理. 第一件事需要担心的是客


户端程序员在自己的代码中遗忘控制. 举例来说, 如果你创造了一个交互的应用程序分配并使用了
大量的资源, 如果一个用户击中 Ctrl+C 或其他键盘中断, 应用程序将不会有机会执行清理工作, 可
能导致数据丢失或数据损坏. 此外, 也没有机制来给出可选的行为, 诸如提示用户, 以确认他们真
的是想退出或是他们意外的按下了 Ctrl 键.
另一个缺点就是函数必须重写来为错误的情形返回一个"特殊"的值, 如:None. 程序员要负责
检查每一个函数调用的返回值. 这可能是个麻烦, 因为你可能不得不检查返回值, 这和没有发生错
误时你期待结果也许不是同一类型的对象. 什么,你的函数要把 None 作为一个有效的数值返回?那
么, 你将不得不拿出另一个返回值, 也许是负数.我们也许并不需要提醒你, 在 Python 的环境下负
数下可能是有效的, 比如作为一个序列的索引. 作为一个写应用程序接口( API )的程序员, 你不
得不为每个一个用户输入可能遇到的返回错误写文档. 同时, 我们难以(而且乏味)在多层次的代
码中以传播错误(和原因).
没有一个简单的传播方法像异常一样做到这一点. 因为错误的数据需要在调用层次中向上转发,
但在前进的道路上可能被曲解. 一个不相干的错误可能会被宣布为起因,而实际上它与原始问题完
全无关.在一层一层的传递中,我们失去了对原始错误封装和保管的能力,更不用说完全地失去我们
原本关心的数据的踪影!异常不仅简化代码, 而且简化整个错误管理体系 --- 它不该在应用开发中
如此重要角色;而有了 Python 的异常处理能力, 也的确没有必要了.
10.12     异常和 sys 模块
另一种获取异常信息的途径是通过 sys 模块中 exc_info()函数. 此功能提供了一个 3 元组
(3-tuple)的信息, 多于我们单纯用异常参数所能获得. 让我们看看如何用 sys.exc_info() :
>>> try:
...     float('abc123')
... except:
...     import sys
...     exc_tuple = sys.exc_info()
...
>>> print exc_tuple
(<class exceptions.ValueError at f9838>, <exceptions. ValueError instance at 122fa8>,
<traceback object at 10de18>)
>>>
>>> for eachItem in exc_tuple:
...    print eachItem
... exceptions.ValueError
invalid literal for float(): abc123


<traceback object at 10de18>
我们从 sys.exc_info()得到的元组中是:
z exc_type: 异常类
z exc_value: 异常类的实例
z exc_traceback: 追踪(traceback)对象
我们所熟悉的前两项:实际的异常类, 和这个异常类的实例(和在上一节我们讨论的异常参数
是一样的) . 第三项, 是一个新增的追踪(traceback)对象. 这一对象提供了的发生异常的上下文.
它包含诸如代码的执行帧,异常发生时的行号等信息.
在旧版本中的 Python 中, 这三个值分别存在于 sys 模块, 为 sys.exc_type , sys.exc_value ,
sys.exc_traceback . 不幸的是, 这三者是全局变量而不是线程安全的. 我们建议亡羊补牢, 用
sys.exc_info()来代替. 在未来版本 Python 中,所有这三个变量都将被逐步停用,并最终移除.
10.13      相关模块
表 10.3 此章的相关模块
表 10.3 异常相关的标准库
模块       描述
exceptions     内建异常(永远不用导入这个模块)
contextliba 为使用 with 语句的上下文对象工具
sys         包含各种异常相关的对象和函数(见 sys.ex*)
a.   Python2.5 新增
10.14      练习
10–1.      引发异常. 以下的哪个因素会在程序执行时引发异常? 注意这里我们问的并不是异
常的原因.
a)  用户
b)  解释器
c)  程序
d)  以上所有
e)  只有 b) 和 c)
f)  只有 a) 和 c)


10–2.     引发异常. 参考上边问题的列表, 哪些因素会在执行交互解释器时引发异常?
10–3.     关键字. 用来引发异常的关键字有那些?
10–4.     关键字. try-except 和 try-finally 有什么不同?
10–5.     异常. 下面这些交互解释器下的 Python 代码段分别会引发什么异常(参阅表 10.2
给出的内建异常清单):
(a)    >>> if 3 < 4 then: print '3 IS less than 4!'
(b)    >>> aList = ['Hello', 'World!', 'Anyone', 'Home?']
>>> print 'the last string in aList is:', aList[len(aList)]
(c)    >>> x
(d)    >>> x = 4 % 0
(e)    >>> import math
>>> i = math.sqrt(-1)
10–6.      改进的 open(). 为内建的 open() 函数创建一个封装. 使得成功打开文件后, 返
回文件句柄; 若打开失败则返回给调用者 None , 而不是生成一个异常. 这样你打开文件时就不需
要额外的异常处理语句.
10–7.     异常. 下面两段 Python 伪代码 a) 和 b) 有什么区别? 考虑语句 A 和 B 的上下
文环境. (这么细致的区别要感谢 Guido )
(a)    try:
statement_A
except . . .:
. . .
else:
statement_B
(b)    try:
statement_A
statement_B
except . . .:
. . .
10–8.         改进的 raw_input() . 本章的开头, 我们给出了一个"安全"的 float() 函数,
它建立在内建函数 float() 上, 可以检测并处理 float() 可能会引发的两种不同异常. 同样,
raw_input() 函数也可能会生成两种异常, EOFError (文件末尾 EOF, 在 Unix 下是由于按下了
Ctrl+D 在 Dos 下 是 因 为 Ctrl+Z) 或 是 KeyboardInterrupt ( 取 消 输 入 , 一 般 是 由 于 按 下 了


Ctrl+C). 请创建一个封装函数 safe_input() , 在发生异常时返回 None .
10–9.    改进的 math.sqrt(). math 模块包含大量用于处理数值相关运算的函数和常量. 不
幸 的 是 , 它 不 能 识 别 复 数 , 所 以 我 们 创 建 了 cmath 模 块 来 支 持 复 数 相 关 运 算 . 请 创 建 一 个
safe_sqrt() 函数, 它封装 math.sqrt() 并能处理负值, 返回一个对应的复数.


函数和函数式编程
章节主题
z 什么是函数
z 调用函数
z 创建函数
z 传入函数
z 形参
z 变长参数
z 函数式编程
z 变量的作用域
z 递归
z 生成器


在第二章,我们引入了函数,并介绍了函数的创建和调用。这一章,我们将在前面内容的基础
上,详细的讲解函数的方方面面。除了预期特性之外, Python 中的函数还支持多种调用方式以及参
数类型并实现了一些函数式编程接口。最后我们将以对 Python 变量的作用域和递归函数的讨论来结
束本章的学习.
11.1 什么是函数?
函数是对程序逻辑进行结构化或过程化的一种编程方法。能将整块代码巧妙地隔离成易于管理
的小块,把重复代码放到函数中而不是进行大量的拷贝--这样既能节省空间,也
有助于保持一致性,因为你只需改变单个的拷贝而无须去寻找再修改大量复制代码的拷贝。
Python 中函数的基础部分与你熟悉的其他的语言没有什么不同.本章开始,我们先回顾一下函数基础,
然后将着重介绍 python 函数的其他特性.
函数可以以不同的形式出现。下面简单展示了一些创建、使用,或者引用函数的方法。
declaration/definition def foo(): print 'bar'
function object/reference foo
function call/invocation foo()
11.1.1 函数 vs 过程
我们经常拿函数和过程比较。两者都是可以被调用的实体,但是传统意义上的函数或者“黑盒”,
可能不带任何输入参数,经过一定的处理,最后向调用者传回返回值。其中一些函数则是布尔类型


的, 返回一个“是“或者“否“的回答,更确切地说,一个非零或者零值。而过程是简单,特殊,
没有返回值的函数。从后面内容你会看到,python 的过程就是函数,因为解释器会隐式地返回默认
值 None
11.1.2.返回值与函数类型
函数会向调用者返回一个值, 而实际编程中大偏函数更接近过程,不显示地返回任何东西。把
过程看待成函数的语言通常对于“什么都不返回”的函数设定了特殊的类型或者值的名字。这些函
数在 c 中默认为“void"的返回类型,意思是没有值返回。 在 python 中, 对应的返回对象类型是
none。
下面 hello()函数的行为就像一个过程,没有返回值。如果保存了返回值,该值为 None:
>>> def hello():
... print 'hello world'
>>>
>>> res = hello()
hello world
>>> res
>>> print res
None
>>> type(res)
<type 'None'>
另外,与其他大多数的语言一样,python 里的函数可以返回一个值或者对象。只是在返回一个容
器对象的时候有点不同,看起来像是能返回多个对象。好比说,你不能拿着大量零散的商品离开百
货店,但是你可以将它们放在一个购物袋里,然后带着这个袋子从商店走出去,合理合法。
def foo():
return ['xyz', 1000000, -98.6]
def bar():
return 'abc', [42, 'python'], "Guido"
foo()函数返回一个列表,bar()函数返回一个元组。由于元组语法上不需要一定带上圆括号, 所
以让人真的以为可以返回多个对象。如果我们要恰当地给这个元组加上括号, bar()的定义看起来
会是这样:
def bar():


return ('abc', [4-2j, 'python'], "Guido")
从返回值的角度来考虑, 可以通过很多方式来存储元组。接下来的 3 种保存返回值的方式是等
价的
>>> aTuple = bar()
>>> x, y, z = bar()
>>> (a, b, c) = bar()
>>>
>>> aTuple
('abc', [(4-2j), 'python'], 'Guido')
>>> x, y, z
('abc', [(4-2j), 'python'], 'Guido')
>>> (a, b, c)
('abc', [(4-2j), 'python'], 'Guido')
在对 x,y,z 和 a,b,c 的赋值中,根据值返回的顺序, 每个变量会接收到与之对应的返回值。而
aTuple 直接获得函数隐式返回的整个元组。回想一下,元组既可以被分解成为单独的变量,也可以直
接用单一变量对其进行引用。(参见 6.18.3)
简而言之,当没有显式地返回元素或者如果返回 None 时, python 会返回一个 None.那么调用
者接收的就是 python 返回的那个对象,且对象的类型仍然相同。如果函数返回多个对象,python 把
他们聚集起来并以一个元组返回。是的,尽管我们声称 python 比诸如 c 那样只允许一个返回值的语
言灵活的多,但是老实说,python 也遵循了相同的传统。只是让程序员误以为可以返回多个对象。
表 11.1 返回值及其类型
表 11.1 总结了从一个函数中返回的元素的数目,以及 python 实际返回的对象。


许多静态类型的语言主张一个函数的类型就是其返回值的类型。在 python 中, 由于 python 是
动态地确定类型而且函数能返回不同类型的值,所以没有进行直接的类型关联。因为重载并不是语
言特性,程序员需要使用 type()这个内建函数作为代理,来处理有着不同参数类型的函数的多重声
明以模拟类 C 语言的函数重载(以参数不同选择函数的多个原型)。
11.2    调用函数
11.2.1.函数操作符
同大多数语言相同,我们用一对圆括号调用函数。实际上,有些人认为(())是一个双字符操作
符。正如你可能意识到的,任何输入的参数都必须放置在括号中。作为函数声明的一部分,括号也
会用来定义那些参数。虽然我们没有正式地学习类和面向对象编程,但你将会发现在 python 中,函
数的操作符同样用于类的实例化。
11.2.2.关键字参数
关键字参数的概念仅仅针对函数的调用。这种理念是让调用者通过函数调用中的参数名字来区
分参数。这样规范允许参数缺失或者不按顺序,因为解释器能通过给出的关键字来匹配参数的值。
举个简单的例子,比如有一个函数 foo(),伪代码如下:
def foo(x):
foo_suite # presumably does some processing with 'x'
标准调用 foo():foo(42) foo('bar') foo(y)
关键字调用 foo():foo(x=42) foo(x='bar') foo(x=y)
再举个更实际的例子, 假设你有一个函数叫做 net_conn(),需要两个参数 host 和 port:
def net_conn(host, port):
net_conn_suite
只要按照函数声明中参数定义的顺序,输入恰当的参数,自然就可以调用这个函数:
net_conn('kappa', 8080)
host 参数得到字符串'kappa',port 参数得到整数 8080.当然也可以不按照函数声明中的参数顺
序输入,但是要输入相应的参数名,如下例:


net_conn(port=8080, host='chino')
当参数允许"缺失“的时候,也可以使用关键字参数.这取决于函数的默认参数, 我们将在下一
小节对它进行介绍。
11.2.3.默认参数
默认参数就是声明了默认值的参数。因为给参数赋予了默认值,所以, 在函数调用时,不向该
参数传入值也是允许的。我们将在 11.5.2 章对默认参数进行更全面的介绍。
11.2.4.参数组
Python 同样允许程序员执行一个没有显式定义参数的函数,相应的方法是通过一个把元组(非
关键字
参数)或字典(关键字参数)作为参数组传递给函数。我们将在本章中讨论这两种形式。基本
上,你可以将所有参数放进一个元组或者字典中,仅仅用这些装有参数的容器来调用一个函数,而
不必显式地将它们放在函数调用中:
func(*tuple_grp_nonkw_args, **dict_grp_kw_args)
其中的 tuple_grp_nonkw_args 是以元组形式体现的非关键字参数组, dict_grp_kw_args 是装有
关键字参数的字典。正如我们已经提到的,我们将在这章对这两者进行全面介绍,现在你只需知道,
存在这样的特性允许你把变量放在元组和/或者字典里,并在没有显式地对参数进行逐个声明的情况
下,调用函数。
实际上,你也可以给出形参!这些参数包括标准的位置参数和关键字参数,所以在 python 中允
许的函数调用的完整语法为:
func(positional_args, keyword_args,
*tuple_grp_nonkw_args, **dict_grp_kw_args)
该语法中的所有的参数都是可选的---从参数传递到函数的过程来看,在单独的函数调用时,每
个参数都是独立的。这可以有效地取代 apply()内建函数。(Prior to Python 1.6, such argument
objects could only be passed to apply() with the function object for invocation.)(在 Python
1.6 版本之前,这样的参数对象只能通过 apply()函数来调用)。
例子


在子 11.1 里的数学游戏中,我们用函数调用转换来生成一个有两个子项的参数列表,并把这个
列表发送给合的适算术函数.(我们也会指出在原来版本中哪些地方会用到 apply())
easyMath.py 程序是一个儿童算术游戏,可以随机选择算术加减法。我们通过函数 add(),sub()
等价+-运算符,这两者都可以在 operator 模块中找到。接着我们生成一个参数列表(该列表只有 2
个参数, 因为这些是二元运算符/运算)。接着选择任意的数字作为算子。因为我们没打算在这个程
序的基础版本中支持负数,所以我们将两个数字的列表按从大到小的顺序排序,然后用这个参数列
表和随机选择的算术运算符去调用相对应的函数,最后获得问题的正确解答。
例子 11.1 算术游戏(easyMath.py)
随机选择数字以及一个算术函数, 显示问题, 以及验证结果. 在 3 次错误的尝试以后给出结果,
等到用户输入一个正确的答案后便会继续运行.
1 #!/usr/bin/env python
2
3 from operator import add, sub
4 from random import randint, choice
5
6 ops = {'+': add, '-': sub}
7 MAXTRIES = 2
8
9 def doprob():
10 op = choice('+-')
11 nums = [randint(1,10) for i in range(2)]
12 nums.sort(reverse=True)
13 ans = ops[op](*nums)
14 pr = '%d %s %d = ' % (nums[0], op, nums[1])
15 oops = 0
16 while True:
17 try:
18 if int(raw_input(pr)) == ans:
19 print 'correct'
20 break
21 if oops == MAXTRIES:
22 print 'answer\n%s%d'%(pr, ans)
23 else:
24 print 'incorrect... try again'
25 oops += 1


26 except (KeyboardInterrupt, \
27  EOFError, ValueError):
28 print 'invalid input... try again'
29
30  def main():
31  while True:
32  doprob()
33  try:
34  opt = raw_input('Again? [y]').lower()
35  if opt and opt[0] == 'n':
36  break
37  except (KeyboardInterrupt, EOFError):
38  break
39
40  if __name__ == '__main__':
41  main()
逐行解释
Lines 1– 4
我们的代码从通常的 unix 启动行开始,接着从 operator 和 random 模块中,导入我们会用到
的函数。
Lines 6–7
在这个应用程序中我们用的全局变量有:一个包含了运算符和与其相关联的函数的集合(字典),
一个决定在给出正解之前,用户有多少次机会尝试给出答案的整型变量。函数字典的键值是运算符
的符号,程序通过查字典找到合适的算术函数。
Lines 9–28
doprob()函数是应用程序的核心引擎。该函数随机选择一个操作并生成两个操作数,同时为了
避免减法问题中的负数问题,将这两个算子按大到下进行排序。然后用这些值调用一个数学函数,
计算出正确的解。接着用一个等式来提示用户输入并给用户三次机会来输入一个正确的答案。
第十行用了 random.choice()函数。它用于获取一个序列----我们案例中运算符号的字符串--
并随机返回其中的元素。
第 11 行用了一个列表解析来随机地给我们的练习选择两个数。这个例子非常的简单以至于我们
可以仅仅用两次 randint()来获得我们的操作数,比如,nums = [randint(1,10), randint(1,10)],
但是为了让你能看看列表解析的又一个例子,我们没有这样做,而且使用列表解析更易于扩展和升
级,比如获得更多的数,这与我们使用循环来代替剪切和粘贴的原因相似。


第 12 行只能在 python2.4 以及更新的版本中运行,因为 list.sort()方法原本不支持倒转的标志
位。如果你使用的是更早一点的 python 版本,你要么:
z   增加一个反序的比较函数来获得倒转的排序,如:lambda x, y: cmp(y, x), 或者
z   在 nums.sort()后调用 nums.reverse()
如果你之前没有看见过 lambda,不用害怕。我们会在这章对 lambda 进行详述,而现在,你可以
认为它是一个单行的匿名函数。
如果你正使用 1.6 以前的 python,那第 13 行是可能会用到 apply()。对合适运算函数的调用要
这样写 apply(ops[op],nums),而不是 ops[op](*nums)
16-28 行描述了用来处理有效和无效输入的控制循环。while 循环是无限循环,直到有正确答案
输入或者允许尝试的次数(我们的程序中设定为 3 次)被耗尽才终止运行。这允许程序接受不合法
的输入,比如非数字或者各种键盘的控制字符。一旦用户超过了尝试最大的次数,程序就会给出答案
并“强制“用户给出正确的答案,只有给出答案,程序才会向下进行。
Lines 30–41
程序的主入口是 main(),如果直接运行脚本,程序将自顶向下的运行。如果被作为模块导入,
导入者要么调用 doprob()函数来开始执行,要么调用 main()来进入程序控制。main()简单地调用
doprob()使用户与脚本的主要功能进行交互, 并负责提示用户退出或者尝试下一个问题。
因为数值和运算符都是随机选择的,每次运行 easyMath.py 的结果应该都是不一样的。这是我
们今天的得到的(噢,你的答案也可能不一样!!!!):
$ easyMath.py
7 - 2 = 5 correct Again? [y]
7 * 6 = 42 correct Again? [y]
7 * 3 = 20
incorrect... try again
7 * 3 = 22
incorrect... try again
7 * 3 = 23
sorry... the answer is
7 * 3 = 21
7 * 3 = 21 correct Again? [y]
7 - 5 = 2 correct Again? [y] n


11.3     创建函数
11.3.1. def 语句
函数是用 def 语句来创建的,语法如下:
def function_name(arguments):
"function_documentation_string"
function_body_suite
标题行由 def 关键字,函数的名字,以及参数的集合(如果有的话)组成。def 子句的剩余部分
包括了一个虽然可选但是强烈推荐的文档字串,和必需的函数体。在本书中我们已经看到很多函数
的声明,这又是一个:
def helloSomeone(who):
'returns a salutory string customized with the input'
return "Hello " + str(who)
11.3.2.声明与定义比较
在某些编程语言里, 函数声明和函数定义区分开的。一个函数声明包括提供对函数名,参数的
名字(传统上还有参数的类型),但不必给出函数的任何代码,具体的代码通常属于函数定义的范畴。
在声明和定义有区别的语言中,往往是因为函数的定义可能和其声明放在不同的文件中。python
将这两者视为一体,函数的子句由声明的标题行以及随后的定义体组成的。
11.3.3     前向引用
和其他高级语言类似,Python 也不允许在函数未声明之前,对其进行引用或者调用.
我们下面给出几个例子来看一下:
def foo():
print 'in foo()'
bar()
如果我们调用函数 foo(),肯定会失败,因为函数 bar()还没有声明:
>>> foo()


in foo()
Traceback (innermost last): File "<stdin>", line 1, in ?
File "<stdin>", line 3, in foo
NameError: bar
我们现在定义函数 bar(),在函数 foo()前给出 bar()的声明:
def bar():
print 'in bar()'
def foo():
print 'in foo()'
bar()
现在我们可以安全的调用 foo(),而不会出现任何问题:
>>> foo() in foo() in bar()
事实上,我们甚至可以在函数 bar()前定义函数 foo():
def foo():
print 'in foo()'
bar()
def bar():
print 'in bar()'
太神奇了,这段代码可以非常好的运行,不会有前向引用的问题:
>>> foo()
in foo() in bar()
这段代码是正确的因为即使(在 foo()中)对 bar()进行的调用出现在 bar()的定义之前,但 foo()
本身不是在 bar()声明之前被调用的。          换句话说,我们声明 foo(),然后再声明 bar(),接着调用 foo(),
但是到那时,bar()已经存在了,所以调用成功。
注意 foo()在没有错误的情况下成功输出了'in foo()'。名字错误是当访问没有初始化的标识符
时才产生的异常


11.3.4.函数属性
在这一章中,我们稍后将对命名空间进行简短的讨论,尤其是它们与变量作用域的关系。在下
一章中会有对命名空间的更深入的探讨,然而,这里我们只是想要指出 python 名字空间的基本特征。
你可以获得每个 pyhon 模块,类,和函数中任意的名字空间。你可以在模块 foo 和 bar 里都有
名为 x 的一个变量,,但是在将这两个模块导入你的程序后,仍然可以使用这两个变量。所以,即使
在两个模块中使用了相同的变量名字,这也是安全的,因为句点属性标识对于两个模块意味了不同
的命名空间,比如说,在这段代码中没有名字冲突:
import foo, bar
print foo.x + bar.x
函数属性是 python 另外一个使用了句点属性标识并拥有名字空间的领域。(更多关于名字空间
将在本章的稍后部分以及第 12 章关于 python 的模块中进行讨论)
def foo():
'foo() -- properly created doc string'
def bar():
pass
bar.__doc__ = 'Oops, forgot the doc str above'
bar.version = 0.1
上面的 foo()中,我们以常规地方式创建了我们的文档字串,比如, 在函数声明后第一个没有
赋值的字串。当声明 bar()时,我们什么都没做,仅用了句点属性标识来增加文档字串以及其他属性。
我们可以接着任意地访问属性。下面是一个使用了交互解释器的例子。                     (你可能已经发现,用内建函
数 help()显示会比用__doc__属性更漂亮,但是你可以选择你喜欢的方式)
>>> help(foo)
Help on function foo in module __main__:
foo()
foo() -- properly created doc string
>>> print bar.version
0.1
>>> print foo.__doc__


foo() -- properly created doc string
>>> print bar.__doc__
Oops, forgot the doc str above
注意我们是如何在函数声明外定义一个文档字串。然而我们仍然可以就像平常一样,在运行时
刻访问它。然而你不能在函数的声明中访问属性。换句话说,在函数声明中没有'self‘这样的东西
让你可以进行诸如__dict__['version'] = 0.1 的赋值。这是因为函数体还没有被创建,但之后你有
了函数对象,就可以按我们在上面描述的那样方法来访问它的字典。另外一个自由的名字空间!
函数属性是在 2.1 中添加到 python 中的,你可以在 PEP232 中阅读到更多相关信息。
11.3.5 内部/内嵌函数
在函数体内创建另外一个函数(对象)是完全合法的。这种函数叫做内部/内嵌函数。因为现在
python 支持静态地嵌套域(在 2.1 中引入但是到 2.2 时才是标准),内部函数实际上很有用的。内嵌
函数对于较老的 python 版本没有什么意义,那些版本中只支持全局和一个局部域。那么如何去创造
一个内嵌函数呢?
最明显的创造内部函数的方法是在外部函数的定义体内定义函数(用 def 关键字),如在:
def foo():
def bar():
print 'bar() called'
print 'foo() called'
bar()
foo()
bar()
我们将以上代码置入一个模块中,如 inner.py,然后运行,我们会得到如下输出:
foo() called bar() called
Traceback (most recent call last): File "inner.py", line 11, in ?
bar()
NameError: name 'bar' is not defined
内部函数一个有趣的方面在于整个函数体都在外部函数的作用域(即是你可以访问一个对象的
区域;稍后会有更多关于作用域的介绍)之内。如果没有任何对 bar()的外部引用,那么除了在函数
体内,任何地方都不能对其进行调用,这就是在上述代码执行到最后你看到异常的原因
另外一个函数体内创建函数对象的方式是使用 lambda 语句。我们会在稍后的 11.7.1 小节进行


讲述。如果内部函数的定义包含了在外部函数里定义的对象的引用(这个对象甚至可以是在外部函
数之外),内部函数会变成被称为闭包(closure)的特别之物。在接下来的 11.8.4 小节,我们将对
闭包进行更多的学习。在下一小节中,我们将介绍装饰器,但是例子程序也包含了闭包的预览。
11.3.6 *函数(与方法)装饰器
装饰器背后的主要动机源自 python 面向对象编程。装饰器是在函数调用之上的修饰。这些修饰
仅是当声明一个函数或者方法的时候,才会应用的额外调用。
装饰器的语法以@开头,接着是装饰器函数的名字和可选的参数。紧跟着装饰器声明的是被修饰
的函数,和装饰函数的可选参数。装饰器看起来会是这样:
@decorator(dec_opt_args)
def func2Bdecorated(func_opt_args):
:
那么装饰器语法如何(以及为什么)产生的呢?装饰器背后的灵感是什么?唔,当静态方法和
类方法在 2.2 时被加入到 python 中的时候,实现方法很笨拙:
class MyClass(object):
def staticFoo():
:
staticFoo = staticmethod(staticFoo)
:
(要澄清的是对于那个发行版本,这不是最终的语法)在这个类的声明中,我们定义了叫
staticFoo()的方法。现在因为打算让它成为静态方法,我们省去它的 self 参数,而你会在 12 章中
看到,self 参数在标准的类方法中是必需的。接着用 staticmethod()内建函数来将这个函数“转化
“为静态方法,但是在 def staticFoo()后跟着 staticFoo = staticmethod (sta- ticFoo)显得有
多么的臃肿。使用装饰器,你现在可以用如下代码替换掉上面的:
class MyClass(object):
@staticmethod
def staticFoo():
:
此外,装饰器可以如函数调用一样“堆叠“起来,这里有一个更加普遍的例子,使用了多个装
饰器:


@deco2
@deco1
def func(arg1, arg2, ...): pass
这和创建一个组合函数是等价的。
def func(arg1, arg2, ...): pass
func = deco2(deco1(func))
函数组合用数学来定义就像这样: (g · f)(x) = g(f(x))。对于在 python 中的一致性
@g
@f
def foo():
:
......与 foo=g(f(foo))相同
有参数和无参数的装饰器
是的,装饰器语法一开始有点让你犯迷糊,但是一旦你适应了,唯一会困扰你的就是什么时候
使用带参数的装饰器。没有参数的情况,一个装饰器如:
@deco
def foo(): pass
....非常的直接
foo = deco(foo)
跟着是无参函数(如上面所见)组成。然而,带参数的装饰器 decomaker()
@decomaker(deco_args)
def foo(): pass
. . .
需要自己返回以函数作为参数的装饰器。换句话说,decomaker()用 deco_args 做了些事并返回
函数对象,而该函数对象正是以 foo 作为其参数的装饰器。简单的说来:
foo = decomaker(deco_args)(foo)
这里有一个含有多个装饰器的例子,其中的一个装饰器带有一个参数


@deco1(deco_arg)
@deco2
def func(): pass
This is equivalent to:这等价于:
func = deco1(deco_arg)(deco2(func))
我们希望如果你明白这里的这些例子,那么事情就变得更加清楚了。下面我们会给出简单实用
的脚本,该脚本中装饰器不带任何参数。例子 11.8 就是含有无参装饰器的中间脚本。
那么什么是装饰器?
现在我们知道装饰器实际就是函数。我们也知道他们接受函数对象。但它们是怎样处理那些函
数的呢?一般说来,当你包装一个函数的时候,你最终会调用它。最棒的是我们能在包装的环境下
在合适的时机调用它。我们在执行函数之前,可以运行些预备代码,如 post-morrem 分析,也可以在
执行代码之后做些清理工作。所以当你看见一个装饰器函数的时候,很可能在里面找到这样一些代
码,它定义了某个函数并在定义内的某处嵌入了对目标函数的调用或者至少一些引用。从本质上看,
这些特征引入了 java 开发者称呼之为 AOP(Aspect Oriented Programming,面向方面编程)的概念。
你可以考虑在装饰器中置入通用功能的代码来降低程序复杂度。例如,可以用装饰器来:
z   引入日志
z   增加计时逻辑来检测性能
z   给函数加入事务的能力
对于用 python 创建企业级应用,支持装饰器的特性是非常重要的。你将会看到上面的条例与我
们下面的例子有非常紧密地联系,这在例 11.2 中也得到了很好地体现。
修饰符举例
下面我们有个极其简单的例子,但是它应该能让你开始真正地了解装饰器是如何工作的。这个
例子通过显示函数执行的时间"装饰"了一个(没有用的)函数。这是一个"时戳装饰",与我们在 16
章讨论的时戳服务器非常相似。
例子 11.2 使用函数装饰器的例子(deco.py)
这个装饰器(以及闭包)示范表明装饰器仅仅是用来“装饰“(或者修饰)函数的包装,返回一
个修改后的函数对象,将其重新赋值原来的标识符,并永久失去对原始函数对象的访问。
1 #!/usr/bin/env python
2
3 from time import ctime, sleep
4


5 def tsfunc(func):
6 def wrappedFunc():
7 print '[%s] %s() called' % (
8 ctime(), func.__name__)
9 return func()
10 return wrappedFunc
11
12 @tsfunc
13 def foo():
14 pass
15
16 foo()
17 sleep(4)
18
19 for i in range(2):
20 sleep(1)
21 foo()
运行脚本,我们得到如下输出:
[Sun Mar 19 22:50:28 2006] foo() called
[Sun Mar 19 22:50:33 2006] foo() called
[Sun Mar 19 22:50:34 2006] foo() called
逐行解释
5-10 行
在启动和模块导入代码之后, tsfunc()函数是一个显示何时调用函数的时戳的装饰器。它定义
了一个内部的函数 wrappedFunc(),该函数增加了时戳以及调用了目标函数。装饰器的返回值是一个
“包装了“的函数。
Lines 12–21
我们用空函数体(什么都不做)来定义了 foo()函数并用 tsfunc()来装饰。为证明我们的设想,
立刻调用它,然后等待四秒,然后再调用两次,并在每次调用前暂停一秒。
结果,函数立刻被调用,第一次调用后,调用函数的第二个时间点应该为 5(4+1),第三次的时
间应该大约为之后的 1 秒。这与上面看见的函数输出十分吻合。
你可以在 python langugae reference, python2.4 中“What’s New in Python 2.4”的文档
以及 PEP 318 中来阅读更多关于装饰器的内容。


11.4 传递函数
当学习一门如 C 的语言时,函数指针的概念是一个高级话题,但是对于函数就像其他对象的
python 来说就不是那么回事了.函数是可以被引用的(访问或者以其他变量作为其别名),也作为参
数传入函数,以及作为列表和字典等等容器对象的元素
函数有一个独一无二的特征使它同其他对象区分开来,那就是函数是可调用的。
举例来说,可以通过函数操作来调用他们。(在 python 中有其他的可调用对象。更多信息,参
见 14 章)在以上的描述中,我们注意到可以用其他的变量来做作为函数的别名
因为所有的对象都是通过引用来传递的,函数也不例外。当对一个变量赋值时,实际是将相同
对象的引用赋值给这个变量。如果对象是函数的话,这个对象所有的别名都是可调用的。
>>> def foo():
... print 'in foo()'
...
>>> bar = foo
>>> bar()
in foo()
当我们把 foo 赋值给 bar 时,bar 和 foo 引用了同一个函数对象,所以能以和调用 foo()相同的
方式来调用 bar()。确定你明白"foo"(函数对象的引用)和"foo()"(函数对象的调用)的区别。
稍微深入下我们引用的例子,我们甚至可以把函数作为参数传入其他函数来进行调用。
>>> def bar(argfunc):
... argfunc()
...
>>> bar(foo)
in foo()
注意到函数对象 foo 被传入到 bar()中。bar()调用了 foo()(用局部变量 argfunc 来作为其别名
就如同在前面的例子中我们把 foo 赋给 bar 一样)。现在我们来研究下一个更加实际的例子,
numconv.py,代码在例子 11.3 中给出
例 11.3 传递和调用(内建)函数
(numConv.py)


一个将函数作为参数传递,并在函数体内调用这些函数,更加实际的例子。这个脚本用传入的
转换函数简单将一个序列的数转化为相同的类型。特别地,test()函数传入一个内建函数 int(),
long(), 或者 float()来执行转换。
1 #!/usr/bin/env python
2
3 def convert(func, seq):
4 'conv. sequence of numbers to same type'
5 return [func(eachNum) for eachNum in seq]
6
7 myseq = (123, 45.67, -6.2e8, 999999999L)
8 print convert(int, myseq)
9 print convert(long, myseq)
10 print convert(float, myseq)
如果我们运行这个程序,我们将会得到如下输出:
$ numconv.py
[123, 45, -620000000, 999999999]
[123L, 45L, -620000000L, 999999999L]
[123.0, 45.67, -620000000.0, 999999999.0]
11.5    形式参数
python 函数的形参集合由在调用时要传入函数的所有参数组成,这参数与函数声明中的参数列
表精确的配对。这些参数包括了所有必要参数(以正确的定位顺序来传入函数的),关键字参数(以
顺序或者不按顺序传入,但是带有参数列表中曾定义过的关键字),以及所有含有默认值,函数调用
时不必要指定的参数。          (声明函数时创建的)局部命名空间为各个参数值,创建了一个名字。一旦函
数开始执行,即能访问这个名字。
11.5.1 位置参数
这些我们都是熟悉的标准化参数。位置参数必须以在被调用函数中定义的准确顺序来传递。另
外,没有任何默认参数(见下一个部分)的话,传入函数(调用)的参数的精确的数目必须和声明
的数字一致。
>>> def foo(who): # defined for only 1 argument


... print 'Hello', who
...
>>> foo() # 0 arguments... BAD Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: not enough arguments; expected 1, got 0
>>>
>>> foo('World!') # 1 argument... WORKS Hello World!
>>>
>>> foo('Mr.', 'World!')# 2 arguments... BAD Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: too many arguments; expected 1, got 2
foo()函数有一个位置参数。那意味着任何对 foo()的调用必须有唯一的一个参数,不多,不少。
否则你会频频看到 TypeError。看看,python 的错误是多么具有信息性的。作为一个普遍的规则,
无论何时调用函数,都必须提供函数的所有位置参数。可以不按位置地将关键字参数传入函数,给
出关键字来匹配其在参数列表中的合适的位置是被准予的(可以回顾 11.2.2 小节)
由于默认参数的特质,他们是函数调用的可选部分。
11.5.2.默认参数
对于默认参数如果在函数调用时没有为参数提供值则使用预先定义的的默认值。这些定义在函
数声明的标题行中给出。c++也支持默认参数,和 python 有同样的语法:参数名等号默认值。这个
从句法上来表明如果没有值传递给那个参数,那么这个参数将取默认值。
python 中用默认值声明变量的语法是所有的位置参数必须出现在任何一个默认参数之前。
def func(posargs, defarg1=dval1, defarg2=dval2,...):
"function_documentation_string"
function_body_suite
每个默认参数都紧跟着一个用默认值的赋值语句。如果在函数调用时没有给出值,那么这个赋
值就会实现。
为什么用默认参数?
默认参数让程序的健壮性上升到极高的级别,因为它们补充了标准位置参数没有提供的一些灵
活性。这种简洁极大的帮助了程序员。当少几个需要操心的参数时候,生活不再那么复杂。这在一
个程序员刚接触到一个 API 接口时,没有足够的知识来给参数提供更对口的值时显得尤为有帮助。
使用默认参数的概念与在你的电脑上安装软件的过程类似。一个人会有多少次选择默认安装而
不是自定义安装?我可以说可能几乎都是默认安装。这既方便,易于操作,又能节省时间。如果你


是那些总是选择自定义安装的顽固分子,请记着你只是少数人之一
另外一个让开发者受益的地方在于,使开发者更好地控制为顾客开发的软件。当提供了默认值
的时候,他们可以精心选择“最佳“的默认值,所以用户不需要马上面对繁琐的选项。随着时间流
逝,当用户对系统或者 api 越来越熟悉的时候,他们最终能自行给出参数值,便不再需要使用“学
步车“了
下面这个例子中默认参数派得上用场,并在日益增长的电子商务中多少有些用处
>>> def
taxMe(cost,
rate=0.0825):
...
return cost
+ (cost * rate)
...
>>> taxMe(100)
108.25
>>>
>>> taxMe(100, 0.05)
105.0
在上面个例子中,taxMe()函数以一个项目的成本输入参数,计算出附加了销售税的销售价格。
成本是一个必需的参数,但税率是一个默认参数(在我们的例子中为 8.25%)。或许你是一个在线零
售商,生意上的大部分客户来自相同的州或者国家。不同地方税率的顾客期望看见他们与当地销售
税率相对应的购买价格总量。为了覆盖默认的税率,你所要做的就是提供一个参数值,比如在上面
的例子中的 taxMe(100,0.05)。通过指定 5%税率,你提供了一个参数作为税率参数,所以覆盖或者
说绕过了 0.0825 的默认值。
所有必需的参数都要在默认参数之前。为什么?简单说来就是因为它们是强制性的,但默认参
数不是。从句法构成上看,对于解释器来说,如果允许混合模式,确定什么值来匹配什么参数是不
可能的。如果没有按正确的顺序给出参数,就会产生一个语法错误。
>>> def taxMe2(rate=0.0825, cost):
... return cost * (1.0 + rate)
...
SyntaxError: non-default argument follows default argument


让我们再看下关键字参数,用我们的老朋友 net_conn()
def net_conn(host, port):
net_conn_suite
读者应该还记得,如果命名了参数,这里可以不按顺序给出参数。由于有了上述声明,我们可
以做出如下(规则的)位置或者关键字参数调用:
z   net_conn('kappa', 8000)
z   net_conn(port=8080, host='chino')
然而,如果我们将默认参数引入这个等式,情况就会不同,虽然上面的调用仍然有效。让我们
修改下 net_conn()的声明以使端口参数有默认值 80,再增加另外的名为 stype(服务器的类型)默认
值为‘tcp‘的参数:
def net_conn(host, port=80, stype='tcp'):
net_conn_suite
我们已经扩展了调用 net_conn()的方式。以下就是所有对 net_conn()有效的调用
z   net_conn('phaze', 8000, 'udp') # no def args used
z   net_conn('kappa') # both def args used
z   net_conn('chino', stype='icmp') # use port def arg
z   net_conn(stype='udp', host='solo') # use port def arg
z   net_conn('deli', 8080) # use stype def arg
z   net_conn(port=81, host='chino') # use stype def arg
在上面所有的例子中,我们发现什么是一直不变的?唯一的必须参数,host。host 没有默认值,
所以他必须出现在所有对 net_conn()的调用中。关键字参数已经被证明能给不按顺序的位置参数提
供参数,结合默认参数,它们同样也能被用于跳过缺失参数,上面例子就是极好的证据。
默认函数对象参数举例
我们现在将给出另外一个证明默认参数会让人受益的例子。grabWeb.py 脚本,在例子 11.4 中给
出,是一个主要目的是从互联网上抓取一个 Web 页面并暂时储存到一个本地文件中用于分析的简单
脚本。这类程序能用来测试 web 站点页面的完整性或者能监测一个服务器的负载(通过测量可链接
性或者下载速度)。process()函数可以做我们想要的任何事,表现出了无限种的用途。我们为这
个练习选择的用法是显示从 web 页面上获得的第一和最后的非空格行。虽然在现实中这个特别的例


子或许没有多少用处,但是你可以以这段代码为基础,举一反三。
例子 抓取网页
这段脚本下载了一个 web 页面(默认为本地的 www 服务器)并显示了 html 文件的第一个以及最
后一个非空格行。由于 download()函数的双默认参数允许用不同的 urls 或者指定不同的处理函数来
进行覆盖,灵活性得倒了提高。
1 #!/usr/bin/env python
2
3 from urllib import urlretrieve
4
5 def firstNonBlank(lines):
6 for eachLine in lines:
7 if not eachLine.strip():
8 continue
9 else:
10 return eachLine
11
12 def firstLast(webpage):
13 f = open(webpage)
14 lines = f.readlines()
15 f.close()
16 print firstNonBlank(lines),
17 lines.reverse()
18 print firstNonBlank(lines),
19
20 def download(url='http://www',
21 process=firstLast):
22 try:
23 retval = urlretrieve(url)[0]
24 except IOError:
25 retval = None
26 if retval: # do some processing
27 process(retval)
28
29 if __name__ == '__main__':
30 download()
在我们的环境下运行这个脚本会得到如下的输出,虽然你的内容是绝对不同的,因为你将浏览


一个完全不同的网页。
$ grabWeb.py
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
</HTML>
11.6 可变长度的参数
可能会有需要用函数处理可变数量参数的情况。这时可使用可变长度的参数列表。变长的参数
在函数声明中不是显式命名的,因为参数的数目在运行时之前是未知的(甚至在运行的期间,每次
函数调用的参数的数目也可能是不同的),这和常规参数(位置和默认)明显不同,常规参数都是在
函数声明中命名的。由于函数调用提供了关键字以及非关键字两种参数类型,python 用两种方法来
支持变长参数,
在 11.2.4 小节中,我们了解了在函数调用中使用*和**符号来指定元组和字典的元素作为非关
键字以及关键字参数的方法。在这个部分中,我们将再次使用相同的符号,但是这次在函数的声明
中,表示在函数调用时接收这样的参数。这语法允许函数接收在函数声明中定义的形参之外的参数。
11.6.1.非关键字可变长参数(元组)
当函数被调用的时候,所有的形参(必须的和默认的)都将值赋给了在函数声明中相对应的局
部变量。剩下的非关键字参数按顺序插入到一个元组中便于访问。可能你对 C 中的“varargs“很熟
悉(比如, va_list, va_arg,以及省略号[....])。Python 提供了与之相等的支持---迭代过所有的
元组元素和在 C 中用 va_arg 是相同的。对于那些不熟悉 C 或者"varargs"的人,这仅仅代表了在函
数调用时,接受一个不定(非固定)数目的参数。
可变长的参数元组必须在位置和默认参数之后,带元组(或者非关键字可变长参数)的函数普
遍的语法如下:
def function_name([formal_args,] *vargs_tuple):
"function_documentation_string"
function_body_suite
星号操作符之后的形参将作为元组传递给函数,元组保存了所有传递给函数的"额外"的参数(匹
配了所有位置和具名参数后剩余的)。如果没有给出额外的参数,元组为空。
正如我们先前看见的,只要在函数调用时给出不正确的函数参数数目,就会产生一个 TypeError
异常。通过末尾增加一个可变的参数列表变量,我们就能处理当超出数目的参数被传入函数的情形,
因为所有的额外(非关键字)参数会被添加到变量参数元组。                         (额外的关键字参数需要关键字变量参
数[参见下一小节].)正如预料的那样,由于和位置参数必须放在关键字参数之前一样的原因,所有


的形式参数必须先于非正式的参数之前出现。
def tupleVarArgs(arg1, arg2='defaultB', *theRest):
'display regular args and non-keyword variable args'
print 'formal arg 1:', arg1 print 'formal arg 2:', arg1 for eachXtrArg in theRest:
print 'another arg:', eachXtrArg
我们现在调用这个函数来说明可变参数元组是如何工作的。
>>> tupleVarArgs('abc')
formal arg 1: abc
formal arg 2: defaultB
>>>
>>> tupleVarArgs(23, 4.56)
formal arg 1: 23
formal arg 2: 4.56
>>>
>>> tupleVarArgs('abc', 123, 'xyz', 456.789)
formal arg 1: abc
formal arg 2: 123
another arg: xyz
another arg: 456.789
11.6.2.关键字变量参数(Dictionary)
在我们有不定数目的或者额外集合的关键字的情况中, 参数被放入一个字典中,字典中键为参
数名,值为相应的参数值。为什么一定要是字典呢?因为为每个参数-参数的名字和参数值--都是成
对给出---用字典来保存这些参数自然就最适合不过了。
这给出使用了变量参数字典来应对额外关键字参数的函数定义的语法:
def function_name([formal_args,][*vargst,] **vargsd):
function_documentation_string function_body_suite
为了区分关键字参数和非关键字非正式参数,使用了双星号(**)。 **是被重载了的以便不与
幂运算发生混淆。关键字变量参数应该为函数定义的最后一个参数,带**。我们现在展示一个如何
使用字典的例子:
def dictVarArgs(arg1, arg2='defaultB', **theRest):
'display 2 regular args and keyword variable args'


print 'formal arg1:', arg1
print 'formal arg2:', arg2
for eachXtrArg in theRest.keys():
print 'Xtra arg %s: %s' % \
(eachXtrArg, str(theRest[eachXtrArg]))
在解释器中执行这个代码,我们得到以下输出。
>>> dictVarArgs(1220, 740.0, c='grail')
formal arg1: 1220
formal arg2: 740.0
Xtra arg c: grail
>>>
>>> dictVarArgs(arg2='tales', c=123, d='poe', arg1='mystery')
formal arg1: mystery
formal arg2: tales
Xtra arg c: 123
Xtra arg d: poe
>>>
>>> dictVarArgs('one', d=10, e='zoo', men=('freud', 'gaudi'))
formal arg1: one
formal arg2: defaultB
Xtra arg men: ('freud', 'gaudi')
Xtra arg d: 10
Xtra arg e: zoo
关键字和非关键字可变长参数都有可能用在同一个函数中,只要关键字字典是最后一个参数并
且非关键字元组先于它之前出现,正如在如下例子中的一样:
def newfoo(arg1, arg2, *nkw, **kw):
display regular args and all variable args'
print 'arg1 is:', arg1 print 'arg2 is:', arg2 for eachNKW in nkw:
print 'additional non-keyword arg:', eachNKW
for eachKW in kw.keys():
print "additional keyword arg '%s': %s" % \
(eachKW, kw[eachKW])
在解释器中调用我们的函数,我们得到如下的输出:
>>> newfoo('wolf', 3, 'projects', freud=90, gamble=96)


arg1 is: wolf arg2 is: 3
additional non-keyword arg: projects
additional keyword arg 'freud': 90
additional keyword arg 'gamble': 96
11.6.3     调用带有可变长参数对象函数
在上面的 11.2.4 部分中,我们介绍了在函数调用中使用*和**来指定参数集合。接下来带着对
函数接受变长参数的些许偏见,我们会向你展示更多那种语法的例子,
我们现在将用在前面部分定义的,我们的老朋友 newfoo(),来测试新的调用语法。我们第一个
对 newfoo()的调用将会使用旧风格的方式来分别列出所有的参数,甚至跟在所有形式参数之后的变
长参数:
>>> newfoo(10, 20, 30, 40, foo=50, bar=60)
arg1 is: 10
arg2 is: 20
additional non-keyword arg: 30
additional non-keyword arg: 40
additional keyword arg 'foo': 50
additional keyword arg 'bar': 60
我们现在进行相似的调用;然而,我们将非关键字参数放在元组中将关键字参数放在字典中,
而不是逐个列出变量参数:
>>> newfoo(2, 4, *(6, 8), **{'foo': 10, 'bar': 12})
arg1 is: 2
arg2 is: 4
additional non-keyword arg: 6
additional non-keyword arg: 8
additional keyword arg 'foo': 10
additional keyword arg 'bar': 12
最终,我们将再另外进行一次调用,但是是在函数调用之外来创建我们的元组和字典。
>>> aTuple = (6, 7, 8)
>>> aDict = {'z': 9}
>>> newfoo(1, 2, 3, x=4, y=5, *aTuple, **aDict)
arg1 is: 1


arg2 is: 2
additional non-keyword arg: 3
additional non-keyword arg: 6
additional non-keyword arg: 7
additional non-keyword arg: 8
additional keyword arg 'z': 9
additional keyword arg 'x': 4
additional keyword arg 'y': 5
注意我们的元组和字典参数仅仅是被调函数中最终接收的元组和字典的子集。额外的非关键字
值‘3’以及‘x’和‘y'关键字对也被包含在最终的参数列表中,而它们不是’*‘和’**‘的可变
参数中的元素。
之前的 1.6,过去变长对象只能通过 apply()函数传递给被调用函数。现在的调用语法已经可
以有效取代 apply()的使用。下面演示了如何使用了这些符号来把任意类型任意个数的参数传递给
任意函数对象。
函数式编程举例
函数式编程的另外一个有用的应用出现在调试和性能测量方面上。你正在使用需要每夜都被完
全测试或通过衰退,或需要给对潜在改善进行多次迭代计时的函数来工作。你所要做的就是创建一
个设置测试环境的诊断函数,然后对有疑问的地方,调用函数。因为系统应该是灵活的, 所以想
testee 函数作为参数传入。那么这样的函数对,timeit()和 testit(),可能会对如今的软件开发者
有帮助。
我们现在将展示这样的一个 testit()函数的例子的源代码(见例子 11.5)。我们将留下 timeit()
函数作为读者的练习(见习题 11.12)
该模块给函数提供了一个执行测试的环境。testit()函数使用了一个函数和一些参数,然后在
异常处理的监控下,用给定的参数调用了那个函数。如果函数成功的完成, 会返回 True 和函数的
返回值给调用者。任何的失败都会导致 False 和异常的原因一同被返回。
(Exception 是所有运行时刻异常的根类:复习第 10 章以获得更详细的资料)
Example 11.5 Testing Functions (testit.py)
testit()用其参数地调用了一个给定的函数,成功的话,返回一个和那函数返回值打包的 True
的返回值,或者 False 和失败的原因。
1 #!/usr/bin/env python
2
3 def testit(func, *nkwargs, **kwargs):
4
5 try:


6 retval = func(*nkwargs, **kwargs)
7 result = (True, retval)
8 except Exception, diag:
9 result = (False, str(diag))
10 return result
11
12 def test():
13 funcs = (int, long, float)
14 vals = (1234, 12.34, '1234', '12.34')
15
16 for eachFunc in funcs:
17 print '-' * 20
18 for eachVal in vals:
19 retval = testit(eachFunc,
20 eachVal)
21 if retval[0]:
22 print '%s(%s) =' % \
23 (eachFunc.__name__, `eachVal`), retval[1]
24 else:
25 print '%s(%s) = FAILED:' % \
26 (eachFunc.__name__, `eachVal`), retval[1]
27
28 if __name__ == '__main__':
29 test()
单元测试函数 test()在一个为 4 个数字的输入集合运行了一个数字转换函数的集合。为了确定
这样的功能性,在测试中有两个失败的案例。这里是运行脚本的输出:
$ testit.py
--------------------
int(1234) = 1234 int(12.34)
= 12 int('1234') = 1234
int('12.34') = FAILED: invalid literal for int(): 12.34
--------------------
long(1234) = 1234L
long(12.34) = 12L
long('1234') = 1234L
long('12.34') = FAILED: invalid literal for long(): 12.34
--------------------
float(1234) = 1234.0


float(12.34) = 12.34
float('1234') = 1234.0
float('12.34') = 12.34
11.7 函数式编程
Python 不是也不大可能会成为一种函数式编程语言,但是它支持许多有价值的函数式编程语言
构建。也有些表现得像函数式编程机制但是从传统上也不能被认为是函数式编程语言的构建。Python
提供的以 4 种内建函数和 lambda 表达式的形式出现
11.7.1.匿名函数与 lambda
python 允许用 lambda 关键字创造匿名函数。匿名是因为不需要以标准的方式来声明,比如说,
使用 def 语句。(除非赋值给一个局部变量,这样的对象也不会在任何的名字空间内创建名字.)然而,
作为函数,它们也能有参数。一个完整的 lambda“语句”代表了一个表达式,这个表达式的定义体
必须和声明放在同一行。我们现在来演示下匿名函数的语法:
lambda [arg1[, arg2, ... argN]]: expression
参数是可选的,如果使用的参数话,参数通常也是表达式的一部分。
核心笔记:lambda 表达式返回可调用的函数对象。
用合适的表达式调用一个 lambda 生成一个可以像其他函数一样使用的函数对象。它们可被传入
给其他函数,用额外的引用别名化,作为容器对象以及作为可调用的对象被调用(如果需要的话,
可以带参数)。当被调用的时候,如过给定相同的参数的话,这些对象会生成一个和相同表达式等价
的结果。它们和那些返回等价表达式计算值相同的函数是不能区分的。
在我们看任何一个使用 lambda 的例子之前,我们意欲复习下单行语句,然后展示下 lambda 表
达式的相似之处。
def true():
return True
上面的函数没有带任何的参数并且总是返回 True。python 中单行函数可以和标题写在同一行。
如果那样的话,我们重写下我们的 true()函数以使其看其来像如下的东西:
def true(): return True
在整这个章节,我们将以这样的方式呈现命名函数,因为这有助于形象化与它们等价的 lamdba
表达式。至于我们的 true()函数,使用 lambda 的等价表达式(没有参数,返回一个 True)为:
lambda :True


命名的 true()函数的用法相当的明显,但 lambda 就不是这样。我们仅仅是这样用,或者我们
需要在某些地方用它进行赋值吗?一个 lambda 函数自己就是无目地服务,正如在这里看到的:
>>> lambda :True
<function <lambda> at f09ba0>
在上面的例子中,我们简单地用 lambda 创建了一个函数(对象),但是既没有在任何地方保存
它,也没有调用它。这个函数对象的引用计数在函数创建时被设置为 True,但是因为没有引用保存下
来,计数又回到零,然后被垃圾回收掉。为了保留住这个对象,我们将它保存到一个变量中,以后
可以随时调用。现在可能就是一个好机会。
>>> true = lambda :True
>>> true() True
这里用它赋值看起来非常有用。相似地,我们可以把 lambda 表达式赋值给一个如列表和元组的
数据结构,其中,基于一些输入标准,我们可以选择哪些函数可以执行,以及参数应该是什么。                                  (在
下个部分中,我们将展示如何去使用带函数式编程构建的 lambda 表达式。
我们现在来设计一个带 2 个数字或者字符串参数,返回数字之和或者已拼接的字符串的函数。
我们先将展示一个标准的函数,然后再是其未命名的等价物。
def add(x, y): return x + y ? lambda x, y: x + y
默认以及可变的参数也是允许的,如下例所示:
def usuallyAdd2(x, y=2): return x+y ? lambda x, y=2: x+y
def showAllAsTuple(*z): return z ? lambda *z: z
上去是一回事,所以我们现在将通过演示如何能在解释器中尝试这种做法,来努力着让你相信:
>>> a = lambda x, y=2: x + y
>>>  a(3)
5
>>>  a(3,5)
8
>>>  a(0)
2
>>>  a(0,9)
9
>>>
>>>  b = lambda *z: z


>>> b(23, 'zyx')
(23, 'zyx')
>>> b(42)
(42,)
关于 lambda 最后补充一点:虽然看起来 lambdda 是一个函数的单行版本,但是它不等同于 c++
的内联语句,这种语句的目的是由于性能的原因,在调用时绕过函数的栈分配。lambda 表达式运作
起来就像一个函数,当被调用时,创建一个框架对象。
11.7.2     内建函数 apply()、filter()、map()、reduce()
在这个部分中,我们将看看 apply(),filter(), map(), 以及 reduce()内建函数并给出一些如
何使用它们的例子。这些函数提供了在 python 中可以找到的函数式编程的特征。正如你想像的一样,
lambda 函数可以很好的和使用了这些函数的应用程序结合起来,因为它们都带了一个可执行的函数
对象,lambda 表达式提供了迅速创造这些函数的机制。
表 11.2 函数式编程的内建函数
内建函数                           描述
apply(func[, nkw][, kw]) a    用可选的参数来调用 func,nkw 为非关键字参数,kw           关
键字参数;返回值是函数调用的返回值。
b
filter(func, seq)         调用一个布尔函数 func 来迭代遍历每个 seq 中的元素; 返回一个
使 func 返回值为 ture 的元素的序列。
map(func, seq1[,seq2...])b 将函数 func 作用于给定序列(s)的每个元素,并用一个列表来提
供返回值;如果 func 为 None, func 表现为一个身份函数,返回
一个含有每个序列中元素集合的 n 个元组的列表。
reduce(func, seq[, init]) 将二元函数作用于 seq 序列的元素,每次携带一对(先前的结果
以及下一个序列元素),连续的将现有的结果和下雨给值作用在获
得的随后的结果上,最后减少我们的序列为一个单一的返回值;如
果初始值 init 给定,第一个比较会是 init 和第一个序列元素而不
是序列的头两个元素。
a.    可以有效的取代 1.6,在其后的 python 版本中逐渐淘汰。
b.由于在 python2.0 中,列表的综合使用的引入,部分被摈弃。
*apply()
正如前面提到的, 函数调用的语法, 现在允许变量参数的元组以及关键字可变参数的字典, 在
python1.6 中有效的摈弃了 apply()。 这个函数将来会逐步淘汰,在未来版本中最终会消失。 我们
在这里提及这个函数既是为了介绍下历史,也是出于维护具有 applay()函数的代码的目的。


filter()
在本章中我们研究的第二个内建函数是 filter()。想像下,去一个果园,走的时候带着一包你
从树上采下的苹果。 如果你能通过一个过滤器,将包裹中好的苹果留下,不是一件很令人开心的事
吗?这就是 filter()函数的主要前提。给定一个对象的序列和一个“过滤”函数,每个序列元素都
通过这个过滤器进行筛选, 保留函数返回为真的的对象。filter 函数为已知的序列的每个元素调用
给定布尔函数。每个 filter 返回的非零(true)值元素添加到一个列表中。返回的对象是一个从原
始队列中“过滤后”的队列
如果我们想要用纯 python 编写 filter(),它或许就像这样:
def filter(bool_func, seq):
filtered_seq = []
for eachItem in seq:
if bool_func(eachItem):
filtered_seq.append(eachItem)
return filtered_seq
一种更好地理解 filter()的方法就是形象化其行为。 图 11-1 试着那样做。
Figure 11–1      How the filter() built-in function works
在图 11-1 中,我们观察到我们原始队列在顶端, 一个大小为 n 的队列,元素从 eq[0],
seq[1], . . . seq[N-1]。每一次对 bool_func()的调用,举例来说,bool_func(seq[1]), bool_func
(seq[0])等等,每个为 True 或 False 的的返回值都会回现。                 (因为 Boolean 函数的每个定义--确保
你的函数确实返回一个真或假)。如果 bool_func()给每个序列的元返回一个真,那个元素将会被插
入到返回的序列中。当迭代整个序列已经完成, filter()返回一个新创建的序列。我们下面展示在
一个使用了 filer()来获得任意奇数的简短列表的脚本。该脚本产生一个较大的随机数集合,然后
过滤出所有的的偶数,留给我们一个需要的数据集。当一开始编写这个例子的时候,oddnogen.py 如
下所示:


from random import randint
def odd(n):
return n % 2
allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print filter(odd, allNums)
代码包括两个函数:odd(), 确定一个整数是奇数(真) 或者 偶数(假)Boolean 函数,以及
main(),主要的驱动部件。main()的目的是来产生 10 个在 1 到 100 之间的随机数:然后调用 filter()
来移除掉所有的偶数。最后,先显示出我们过滤列表的大小,然后是奇数的集合
导入和运行这个模块几次后,我们能得到如下输出:
$ python oddnogen.py
[9, 33, 55, 65]
$ python oddnogen.py
[39, 77, 39, 71, 1]
$ python oddnogen.py
[23, 39, 9, 1, 63, 91]
$ python oddnogen.py
[41, 85, 93, 53, 3]
第一次重构
在第二次浏览时,我们注意到 odd()是非常的简单的以致能用一个 lambda 表达式替换
from random import randint allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print filter(lambda n: n%2, allNums)
Refactoring Pass 2
我们已经提到 list 综合使用如何能成为 filter()合适的替代者,如下便是:
from random import randint


allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print [n for n in allNums if n%2]
Refactoring Pass 3
我们通过整合另外的列表解析将我们最后的列表放在一起,来进一步简化我们的代码。正如你
如下看到的一样, 由于列表解析灵活的语法,就不再需要一个暂时的变量了。(为了简单,我们用
一个较短的名字将 randint()倒入到我们的代码中)
from random import randint as ri
print [n for n in [ri(1,99) for i in range(9)] if n%2]
虽然比原来的长些, 但是这行扮演了该例子中核心部分的代码不再如其他人想的那么模糊不清。
map()
map()内建函数与 filter()相似,因为它也能通过函数来处理序列。然而,不像 filter(),map()
将函数调用“映射”到每个序列的元素上,并返回一个含有所有返回值的列表。
在最简单的形式中,map()带一个函数和队列, 将函数作用在序列的每个元素上, 然后创建
由每次函数应用组成的返回值列表。所以如果你的映射函数是给每个进入的数字加 2,并且你将这个
函数和一个数字的列表传给 map(),返回的结果列表是和原始集合相同的数字集合,但是每个数字
都加了 2.
如果我们要用 python 编写这个简单形式的 map()如何运作的, 它可能像在图 11-2 中阐释的
如下代码:
def map(func, seq):
mapped_seq = []
for eachItem in seq:
mapped_seq.append(func(eachItem))
return mapped_seq


Figure 11–2    How the map() built-in function works
我们可以列举一些简短的 lambda 函数来展示如何用 map()处理实际数据:
>>> map((lambda x: x+2), [0, 1, 2, 3, 4, 5])
[2, 3, 4, 5, 6, 7]
>>>
>>> map(lambda x: x**2, range(6))
[0, 1, 4, 9, 16, 25]
>>> [x+2 for x in range(6)]
[2, 3, 4, 5, 6, 7]
>>>
>>>[x**2 for x in range(6)]
[0, 1, 4, 9, 16, 25]
我们已经讨论了有时 map()如何被列表解析取代, 所以这里我们再分析下上面的两个例子。形
式更一般的 map()能以多个序列作为其输入。如果是这种情况, 那么 map()会并行地迭代每个序
列。在第一次调用时, map()会将每个序列的第一个元素捆绑到一个元组中, 将 func 函数作用到
map()上, 当 map()已经完成执行的时候,并将元组的结果返回到 mapped_seq 映射的,最终以
整体返回的序列上。图 11-2 阐释了一个 map()如何和单一的序列一起运行。如果我们用带有每个
序列有 N 个对象的 M 个序列来的 map(),我们前面的图表会转变成如图 11-3 中展示的图表那样。


图 11-3 内建函数 map()如何和>1 的序列一起运作。
这里有些使用带多个序列的 map()的例子
>>> map(lambda x, y: x + y, [1,3,5], [2,4,6])
[3, 7, 11]
>>>
>>> map(lambda x, y: (x+y, x-y), [1,3,5], [2,4,6])
[(3, -1), (7, -1), (11, -1)]
>>>
>>> map(None, [1,3,5], [2,4,6])
[(1, 2), (3, 4), (5, 6)]
上面最后的例子使用了 map()和一个为 None 的函数对象来将不相关的序列归并在一起。这种思
想在一个新的内建函数,zip,被加进来之前的 python2.0 是很普遍的。而 zip 是这样做的:
>>> zip([1,3,5], [2,4,6])
[(1, 2), (3, 4), (5, 6)]
reduce()
函数式编程的最后的一部分是 reduce(),reduce 使用了一个二元函数(一个接收带带两个值
作为输入,进行了一些计算然后返回一个值作为输出)                            ,一个序列,和一个可选的初始化器,卓有成
效地将那个列表的内容“减少”为一个单一的值,如同它的名字一样。在其他的语言中,这种概念
也被称作为折叠。
它通过取出序列的头两个元素,将他们传入二元函数来获得一个单一的值来实现。然后又用这


个值和序列的下一个元素来获得又一个值,然后继续直到整个序列的内容都遍历完毕以及最后的值
会被计算出来为止。
你可以尝试去形象化 reduce 如下面的等同的例子:
reduce(func, [1, 2, 3])    =  func(func(1, 2), 3)
有些人认为 reduce()合适的函数式使用每次只需要仅需要一个元素。在上面一开始的迭代中,
我们拿了两个元素因为我们没有从先前的值(因为我们没有任何先前的值)中获得的一个“结果”。
这就是可选初始化器出现的地方(参见下面的 init 变量)                       。如果给定初始化器, 那么一开始的迭代
会用初始化器和一个序列的元素来进行,接着和正常的一样进行。
如果我们想要试着用纯 python 实现 reduce(), 它可能会是这样:
if init is None: # initializer?
res = lseq.pop(0) #    no
else:
res = init # yes
for item in lseq: # reduce sequence
res = bin_func(res, item) # apply function
return res   # return result
从概念上说这可能 4 个中最难的一个, 所以我们应该再次向你演示一个例子以及一个函数式
图表(见图 11-4)。reduce()的“hello world”是其一个简单加法函数的应用或在这章前面看到的
与之等价的 lamda
z def mySum(x,y): return x+y
z lambda x,y: x+y
给定一个列表, 我们可以简单地创建一个循环, 迭代地遍历这个列表,再将现在元素加到前
面元素的累加和上,最后当循环结束就能获得所有值的总和。
>>> def mySum(x,y): return x+y
>>> allNums = range(5) # [0, 1, 2, 3, 4]
>>> total = 0


图 11-4 reduce()内建函数是如何工作的。
>>> for eachNum in allNums:
...    total = mySum(total, eachNum)
...
>>> print 'the total is:', total the total is: 10
使用 lambda 和 reduce(),我们可以以一行代码做出相同的事情。
>>> print 'the total is:', reduce((lambda x,y: x+y), range(5))
the total is: 10
给出了上面的输入,reduce()函数运行了如下的算术操作。
((((0 + 1) + 2) + 3) + 4) =>    10
用 list 的头两个元素(0,1)        ,调用 mySum()来得到 1,然后用现在的结果和下一个元素 2 来再
次调用 mySum(),再从这次调用中获得结果,与下面的元素 3 配对然后调用 mySum(),最终拿整个前
面的求和和 4 来调用 mySum()得到 10,10 即为最终的返回值。
11.7.3 偏函数应用


currying 的概念将函数式编程的概念和默认参数以及可变参数结合在一起。一个带 n 个参数,
curried 的函数固化第一个参数为固定参数,并返回另一个带 n-1 个参数函数对象,分别类似于 LISP
的原始函数 car 和 cdr 的行为。Currying 能泛化成为偏函数应用(PFA)                    , 这种函数将任意数量(顺
序)的参数的函数转化成另一个带剩余参数的函数对象。
在某种程度上,这似乎和不提供参数,就会使用默认参数情形相似。 在 PFA 的例子中, 参数
不需要调用函数的默认值,只需明确的调用集合。你可以有很多的偏函数调用,每个都能用不同的
参数传给函数,这便是不能使用默认参数的原因。
这个特征是在 python2.5 的时候被引入的,通过 functools 模块能很好的给用户调用。
简单的函数式例子
如何创建一个简单小巧的例子呢?我们来使用下两个简单的函数 add()和 mul(), 两者都来自
operator 模块。这两个函数仅仅是我们熟悉的+和*操作符的函数式接口,举例来说,add(x,y)与 x+y
一样。在我们的程序中,我们经常想要给和数字加一或者乘以 100
除了大量的,如 add(1,foo),add(1,bar),mul(100, foo), mul(100, bar)般的调用,拥
有已存在的并使函数调用简化的函数不是一件很美妙的事吗?举例来说,add1(foo), add1(bar),
mul100,但是却不用去实现函数 add1()和 mul100()?哦,现在用 PFAs 你就可以这样做。你可以通
过使用 functional 模块中的 partial()函数来创建 PFA:
>>> from operator import add, mul
>>> from functools import partial
>>> add1 = partial(add, 1)   # add1(x) == add(1, x)
>>> mul100 = partial(mul, 100) # mul100(x) == mul(100, x)
>>>
>>> add1(10)
11
>>> add1(1)
2
>>> mul100(10)
1000
>>> mul100(500)
50000
这个例子或许不能让你看到 PFAs 的威力,但是我们不得不从从某个地方开始。当调用带许多参
数的函数的时候,PFAs 是最好的方法。使用带关键字参数的 PFAs 也是较简单的, 因为能显示给出
特定的参数,要么作为 curried 参数,要么作为那些更多在运行时刻传入的变量, 并且我们不需担
心顺序。下面的一个例子来自 python 文档中关于在应用程序中使用,在这些程序中需要经常将二进


制(作为字符串)转换成为整数。
>>> baseTwo = partial(int, base=2)
>>> baseTwo.__doc__ = 'Convert base 2 string to an int.'
>>> baseTwo('10010')
18
这个例子使用了 int()内建函数并将 base 固定为 2 来指定二进制字符串转化。现在我们没有多
次用相同的第二参数(2)来调用 int(),比如('10010', 2),相反,可以只用带一个参数的新 baseTwo
()函数。接着给新的(部分)函数加入了新的文档并又一次很好地使用了“函数属性”                                        (见上面的
11.3.4 部分),这是很好的风格。要注意的是这里需要关键字参数 base
警惕关键字
如果你创建了不带 base 关键字的偏函数,比如, baseTwo- BAD = partial(int, 2),这可能
会让参数以错误的顺序传入 int(),因为固定参数的总是放在运行时刻参数的左边, 比如
baseTwoBAD(x) == int(2, x)。如果你调用它, 它会将 2 作为需要转化的数字,base 作为'10010'
来传入,接着产生一个异常:
>>> baseTwoBAD = partial(int, 2)
>>> baseTwoBAD('10010')
Traceback (most recent call last): File "<stdin>", line 1, in <module>
TypeError: an integer is required
由于关键字放置在恰当的位置, 顺序就得固定下来,因为,如你所知,关键字参数总是出现在
形参之后, 所以 baseTwo(x) == int(x, base=2).
简单 GUI 类的例子。
PFAs 也扩展到所有可调用的东西,如类和方法。一个使用 PFAs 的优秀的例子是提供了“部分
gui 模范化”。GUI 小部件通常有很多的参数,如文本,长度,最大尺寸, 背景和前景色,活动或者
非活动,等等。如果想要固定其中的一些参数, 如让所有的文本标签为蓝底白字, 你可以准确地
以 PFAs 的方式,自定义为相似对象的伪模板。
例 11.6 偏函数应用 GUI (ppfaGUI.py)
这是较有用的偏函数应用的例子,或者更准确的说,“部分类实例化” 。。                                  。。为什么呢?
1 #!/usr/bin/env python
2
3 from functools import partial


4 import Tkinter
5
6 root = Tkinter.Tk()
7 MyButton = partial(Tkinter.Button, root,
8 fg='white', bg='blue')
9 b1 = MyButton(text='Button 1')
10 b2 = MyButton(text='Button 2')
11 qb = MyButton(text='QUIT', bg='red',
12 command=root.quit)
13 b1.pack()
14 b2.pack()
15 qb.pack(fill=Tkinter.X, expand=True)
16 root.title('PFAs!')
17 root.mainloop()
在 7-8 行,我们给 Tkinter.Button 创建了"部分类实例化器”             (因为那便是它的名字,而不是偏
函数),固定好父类的窗口参数然后是前景色和背景色。我们创建了两个按钮 b1 和 b2 来与模板匹配,
只让文本标签唯一。quit 按钮(11-12 行)是稍微自定义过的,带有不同的背景色(红色, 覆盖了
默认的蓝色)并配置了一个回调的函数,当按钮被按下的时候,关闭窗口。(另外的的两个按钮没
有函数,当他们被按下的的时候)
没有 MyButton“模板”的话,你每次会不得不使用“完全”的语法(因为你仍然没有给全参数,
由于有大量你不传入的,含有默认]值的参数)
b1 = Tkinter.Button(root, fg='white', bg='blue', text='Button 1') b2 =
Tkinter.Button(root, fg='white', bg='blue', text='Button 2') qb = Tkinter.Button(root,
fg='white', text='QUIT', bg='red',
command=root.quit)
这就一个简单的 GUI 的截图:
当你的代码可以变得更紧凑和易读的时候,为什么要还有重复的做令人心烦的事?你能在 18 张
章找到更多关于 GUI 编程的资料, 在那我们着重描写了一个使用 PFAs 的例子。从你迄今为止看到
的内容中,可以发现,在以更函数化编程环境提供默认值方面,PFA 带有模板以及“style-sheeting”
的感觉。你可以在 Python Library Reference,“What’s New in Python 2.5”文档和指定的 PEP309


里,关于 functools 模块的文档中阅读到更多关于 pfa 的资料。
11.8 变量作用域
标识符的作用域是定义为其声明在程序里的可应用范围, 或者即是我们所说的变量可见性。换
句话说,就好像在问你自己,你可以在程序里的哪些部分去访问一个制定的标识符。变量可以是局
部域或者全局域。
11.8.1     全局变量与局部变量
定义在函数内的变量有局部作用域,在一个模块中最高级别的变量有全局作用域。在编译器理
论里有名的“龙“书中,Aho, Sethi, 和 ULLman 以这种方法进行了总结。
“声明适用的程序的范围被称为了声明的作用域。在一个过程中,如果名字在过程的声明之内,
它的出现即为过程的局部变量;否则的话,出现即为非局部的“
全局变量的一个特征是除非被删除掉,否则它们的存活到脚本运行结束,且对于所有的函数,
他们的值都是可以被访问的,然而局部变量,就像它们存放的栈,暂时地存在,仅仅只依赖于定义
它们的函数现阶段是否处于活动。当一个函数调用出现时,其局部变量就进入声明它们的作用域。
在那一刻,一个新的局部变量名为那个对象创建了,一旦函数完成,框架被释放,变量将会离开作
用域。
global_str = 'foo'
def foo():
local_str = 'bar'
return global_str + local_str
上面的例子中,global_str 是全局变量,而 local_str 是局部变量。foo()函数可以对全局和局
部变量进行访问,而代码的主体部分只能访问全局变量。
核心笔记:搜索标识符(aka 变量,名字,等等)
当搜索一个标识符的时候,python 先从局部作用域开始搜索。如果在局部作用域内没有找到那
个名字,那么就一定会在全局域找到这个变量否则就会被抛出 NameError 异常。
一个变量的作用域和它寄住的名字空间相关。我们会在 12 章正式介绍名字空间;对于现在只能
说子空间仅仅是将名字映射到对象的命名领域,现在使用的变量名字虚拟集合。作用域的概念和用
于找到变量的名字空间搜索顺序相关。当一个函数执行的时候,所有在局部命名空间的名字都在局
部作用域内。那就是当查找一个变量的时候,第一个被搜索的名字空间。如果没有在那找到变量的
话,那么就可能找到同名的全局变量。这些变量存储(搜索)在一个全局以及内建的名字空间,。
仅仅通过创建一个局部变量来“隐藏“或者覆盖一个全局变量是有可能的。回想一下,局部名


字空间是首先被搜索的,存在于其局部作用域。如果找到一个名字,搜索就不会继续去寻找一个全
局域的变量,所以在全局或者内建的名字空间内,可以覆盖任何匹配的名字。
同样,当使用全局变量同名的局部变量的时候要小心。如果在赋予局部变量值之前,你在函数
中(为了访问这个全局变量)使用了这样的名字,你将会得到一个异常(NAMEERROR 或者 Unbound-
LocalError),而这取决于你使用的 python 版本。
11.8.2. globa 语句
如果将全局变量的名字声明在一个函数体内的时候,全局变量的名字能被局部变量给覆盖掉。
这里有另外的例子,与第一个相似,但是该变量的全局和局部的特性就不是那么清晰了。
def foo():
print "\ncalling foo()..."
bar = 200
print "in foo(), bar is", bar
bar = 100
print "in __main__, bar is", bar foo()
print "\nin __main__, bar is (still)", bar
得到如下输出:
in __main__, bar is 100
calling foo()...
in foo(), bar is 200
in __main__, bar is (still) 100
我们局部的 bar 将全局的 bar 推出了局部作用域。为了明确地引用一个已命名的全局变量,必
须使用 global 语句。global 的语法如下:
global var1[, var2[, ... varN]]]
修改上面的例子,可以更新我们代码,这样我们便可以用全局版本的 is_this_global 而无须创
建一个新的局部变量。
>>> is_this_global = 'xyz'
>>> def foo():
...  global is_this_global
...  this_is_local = 'abc'
...  is_this_global = 'def'


... print this_is_local + is_this_global
...
>>> foo()
abcdef
>>> print is_this_global
def
11.8.3.作用域的数字
python 从句法上支持多个函数嵌套级别,就如在 python2.1 中的,匹配静态嵌套的作用域。然
而,在 2.1 至前的版本中,最多为两个作用域:一个函数的局部作用域和全局作用域。虽然存在多
个函数的嵌涛,但你不能访问超过两个作用域。
def foo():
m = 3
def bar():
n = 4
print m + n
print m bar()
虽然这代码在今天能完美的运行....
>>> foo()
3
7
. . .在 python2.1 之前执行它将会产生错误。
>>> foo()
Traceback (innermost last):
File "<stdin>", line 1, in ?
File "<stdin>", line 7, in foo
File "<stdin>", line 5, in bar
NameError: m
在函数 bar()内访问 foo()的局部变量 m 是非法的,因为 m 是声明为 foo()的局部变量。从 bar()
中可访问唯一的作用域为局部作用域和全局作用域。foo()的局部作用域没有包含在上面两个作用域
的列表中。注意'print m'语句的输出成功了,而而对 bar()的函数调用却失败了。幸运的是,由于
python 的现有嵌套作用语规则,今天就不存在这个问题了。


11.8.4 闭包
由于 python 的静态嵌套域,如我们早先看到的,定义内部函数变得很有用处。在下面的部分中,
我们将着重讨论作用域和 lambda,但是在 python2.1 之前,当作用域规改则变为今天这样之前,内
部函数也会遭受到相同的问题。如果在一个内部函数里,对在外部作用域(但不是在全局作用域)的
变量进行引用,那么内部函数就被认为是 closure。定义在外部函数内的但由内部函数引用或者使用
的变量被称为自由变量。closures 在函数式编程中是一个重要的概念,Scheme 和 Haskell 便是函数
式编程中两种。Closures 从句法上看很简单(和内部函数一样简单)但是仍然很有威力。
闭包将内部函数自己的代码和作用域以及外部函数的作用结合起来。闭包的词法变量不属于全
局名字空间域或者局部的--而属于其他的名字空间,带着“流浪"的作用域。(注意这不同于对象因
为那些变量是存活在一个对象的名字空间但是闭包变量存活在一个函数的名字空间和作用域)那么
为什么你会想要用 closues?
Closurs 对于安装计算,隐藏状态,以及在函数对象和作用域中随意地切换是很有用的。closurs
在 GUI 或者在很多 API 支持回调函数的事件驱动编程中是很有些用处的。以绝对相同的方式,应用
于获取数据库行和处理数据。回调就是函数。闭包也是函数,但是他们能携带一些额外的作用域。
它们仅仅是带了额外特征的函数......另外的作用域。
你可能会觉得闭包的使用和这章先前介绍的偏函数应用非常的相似,但是与闭包的使用相比,
PFA 更像是 currying, 因为闭包和函数调用没多少相关,而是关于使用定义在其他作用域的变量。
简单的闭包的例子
下面是使用闭包简单的例子。我们会模拟一个计数器,同样也通过将整数包裹为一个列表的单
一元素来模拟使整数易变。
def counter(start_at=0): count = [start_at] def incr():
count[0] += 1
return count[0]
return incr
counter()做的唯一一件事就是接受一个初始化的的值来开始计数,并将该值赋给列表 count 唯
一一个成员。然后定义一个 incr()的内部函数。通过在内部使用变量 count,我们创建了一个闭包
因为它现在携带了整个 counter()作用域。incr()增加了正在运行的 count 然后返回它。然后最后的
魔法就是 counter()返回一个 incr,一个(可调用的)函数对象。如我们交互地运行这个函数,我
们将得到如下的输出---------注意这看起来和实例化一个 counter 对象并执行这个实例有多么相似:
>>> count = counter(5)


>>> print count()
6
>>> print count()
7
>>>  count2 = counter(100)
>>>  print count2()
101
>>>  print count()
8
有点不同的是我们能够做些原来需要我们写一个类做的事,并且不仅仅是要写,而且必需覆盖
掉这个类的__call__()特别方法来使他的实例可调用。这里我们能够使用一对函数来做这事。
现在,在很多情况下,类是最适合使用的。闭包更适合需要一个必需有自己的作用域的回调函
数情况,尤其是回调函数是很小巧而且简单的,通常也很聪明。跟平常一样,如果你使用了闭包,
对你的代码进行注释或者用文档字符串来解释你正做的事是很不错的主意
追踪闭包词法的变量
下面两个部分包含了给高级读者的材料......如果你愿意的话,你可以跳过去。我们将讨论如何
能使用函数的 func_closure 属性来追踪自由变量。这里有个显示追踪的代码片断。如果我们运行
这段代码,将得到如下输入:
f2 closure vars: ['<cell at 0x5ee30: int object at
0x200377c>']
f3 closure vars: ['<cell at 0x5ee90: int object at
0x2003770>', '<cell at 0x5ee30: int object at
0x200377c>']
<int 'w' id=0x2003788 val=1>
<int 'x' id=0x200377c val=2>
<int 'y' id=0x2003770 val=3>
<int 'z' id=0x2003764 val=4>
例子 11.7 追踪闭包变量(closureVars.py)
这个例子说明了如何能通过使用函数的 func_closure 属性来追踪闭包变量
1 #!/usr/bin/env python
2
3 output = '<int %r id=%#0x val=%d>'


4 w = x = y = z = 1
5
6 def f1():
7 x = y = z = 2
8
9 def f2():
10 y = z = 3
11
12 def f3():
13 z = 4
14 print output % ('w', id(w), w)
15 print output % ('x', id(x), x)
16 print output % ('y', id(y), y)
17 print output % ('z', id(z), z)
18
19 clo = f3.func_closure
20 if clo:
21 print "f3 closure vars:", [str(c) for c in clo]
22 else:
23 print "no f3 closure vars"
24 f3()
25
26 clo = f2.func_closure
27 if clo:
28 print "f2 closure vars:", [str(c) for c in clo]
29 else:
30 print "no f2 closure vars"
31 f2()
32
33 clo = f1.func_closure
34 if clo:
35 print "f1 closure vars:", [str(c) for c in clo]
36 else:
37 print "no f1 closure vars"
38 f1()
逐行解释
Lines 1–4
这段脚本由创建模板来输出一个变量开始:它的名字,ID,以及值,然后设置变量 w,x,y 和 z。


我们定义了模板,这样便不需要多次拷贝相同输出格式的字符串
Lines 6–9, 26–31
f1()函数的定义包括创建一个局部变量 x,y 和 z,以及一个内部函数 f2()的定义。(注意所有的
局部变量遮蔽或者隐藏了对他们同名的全局变量的访问)。如果 f2()使用了任何的定义在 f1()作用
域的变量,比如说,非全局的和非 f2()的局部域的,那么它们便是自由变量,将会被 f1.func_closure
追踪到。
Lines 9–10, 19–24
这几行实际上是对 f1()的拷贝,对 f2()做相同的事,定义了局部变量 y 和 z,以及对一个内部
函数 f3().此外,这里的局部变量会遮蔽全局以及那些在中间局部化作用域的变量,比如,f1()的。
如果对于 f3()有任何的自由变量,他们会在这里显示出来。
毫无疑问,你会注意到对自由变量的引用是存储在单元对象里,或者简单的说,单元。这些东
西是什么呢?单元是在作用域结束后使自由变量的引用存活的一种基础方法。
举例来说,我们假设函数 f3()已经被传入到其他一些函数,这样便可在稍后,甚至是 f2()完成
之后,调用它。你不想要让 f2()的栈出现,因为即使我们仅仅在乎 f3()使用的自由变量,栈也会让
所有的 f2()'s 的变量保持存活。单元维持住自由变量以便 f2()的剩余部分能被释放掉。
Lines 12–17
这个部分描绘了 f3()的定义,创建一个局部的变量 z。接着显示 w,x,y,z,这 4 个变量从最内
部作用域逐步向外的追踪到的。在 f3(), f2(), 或者 f1()中都是找不到变量 w 的,所以,这是个全
局变量。在 f3()或者 f2()中,找不到变量 x,所以来自 f1()的闭包变量。相似地,y 是一个来自 f2()
的闭包变量。最后,z 是 f3()的局部变量。
Lines 33–38
main()中剩余的部分尝试去显示 f1()的闭包变量,但是什么都不会发生因为在全局域和 f1()的
作用域之间没有任何的作用域---没有 f1()可以借用的作用域,因此不会创建闭包---所以第 34 行的
条件表达式永远不会求得 True。这里的这段代码仅仅是有修饰的目的。
*高级闭包和装饰器的例子
回到 11.3.6 部分,我们看到了一个使用闭包和装饰器的简单例子,deco.py。接下来就是稍微
高级点的例子,来给你演示闭包的真正的威力。应用程序“logs"函数调用。用户选择是要在函数调
用之前或者之后,把函数调用写入日志。如果选择贴日志,执行时间也会显示出来。
例子 11.8 用闭包将函数调用写入日至。


这个例子演示了带参数的装饰器,该参数最终决定哪一个闭包会被用的。这也是闭包的威力的
特征。
1 #!/usr/bin/env python
2
3 from time import time
4
5 def logged(when):
6 def log(f, *args, **kargs):
7 print '''Called:
8 function: %s
9 args: %r
10 kargs: %r''' % (f, args, kargs)
11
12 def pre_logged(f):
13 def wrapper(*args, **kargs):
14 log(f, *args, **kargs)
15 return f(*args, **kargs)
16 return wrapper
17
18 def post_logged(f):
19 def wrapper(*args, **kargs):
20 now = time()
21 try:
22 return f(*args, **kargs)
23 finally:
24 log(f, *args, **kargs)
25 print "time delta: %s" % (time()-now)
26 return wrapper
27
28 try:
29 return {"pre": pre_logged,
30 "post": post_logged}[when]
31 except KeyError, e:
32 raise ValueError(e), 'must be "pre" or "post"'
33
34 @logged("post")
35 def hello(name):
36 print "Hello,", name
37


38 hello("World!")
如果执行这个脚本,你将会得到和下面相似的输出:
$ funcLog.py Hello, World! Called:
function: <function hello at 0x555f0>
args: ('World!',)
kargs: {}
time delta: 0.000471115112305
逐行解释
Lines 5–10, 28–32
这段代码描绘了 logged()函数的核心部分,其职责就是获得关于何时函数调用应该被写入日志
的用户请求。它应该在目标函数被调用前还是之后呢?logged()有 3 个在它的定义体之内的助手内
部函数:log(),pre_logged()以及 post_logged()。log()是实际上做日志写入的函数。它仅仅是显
示标准输出函数的名字和参数。如果你愿意在“真实的世界中”使用该函数的话,你很有可能会把
输出写到一个文件,数据库,或者标准错误(sys.stderr)。logged()在 28-32 行的最后的部分实际
上是函数中非函数声明的最开始的代码。读取用户的选择然后返回*logged()函数中的一个便能用
目标函调用并包裹它。
Lines 12–26
pre_logged()和 post_logged()都会包装目标函数然后根据它的名字写入日志,比如,当目标函
数已经执行之后,post_loggeed()会将函数调用写入日志,而 pre_logged()则是在执行之前。
根据用户的选择,pre_logged()和 post_logged()其中之一会被返回。当这个装饰器被调用的时
候,首先对装饰器和其参数进行求值,比如 logged(什么时候)                     。然后返回的函数对象作为目标的函
数的参数进行调用,比如,pre_logged(f)或者 post_logged(f).
两个*logged()函数都包括了一个名为 wrapper()的闭包。当合适将其写入日志的时候,它便会
调用目标函数。这个函数返回了包裹好的函数对象,该对象随后将被重新赋值给原始的目标函数标
识符。
Lines 34–38
这段脚本的主要部分简单地装饰了 hello()函数并将用修改过的函数对象一起执行它。当你在
38 行调用 hello()的时候,它和你在 35 行创建的函数对象已经不是一回事了。34 行的装饰器用特殊
的装饰将原始函数对象进行了包裹并返回这个包裹后的 hello()版本。
11.8.5     作用域和 lambda


python 的 lambda 匿名函数遵循和标准函数一样的作用域规则。一个 lambda 表达式定义了新的
作用域,就像函数定义,所以这个作用域除了局部 lambda/函数,对于程序其他部分,该作用域都是
不能对进行访问的。
那些声明为函数局部变量的 lambda 表达式在这个函数体内是可以访问的;然而,在 lambda 语
句中的表达式有和函数相同的作用域。你也可以认为函数和一个 lambda 表达式是同胞。
x = 10
def foo():
y = 5
bar = lambda :x+y
print bar()
我们现在知道这段代码能很好的运行。
>>> foo()
15
.....然而,我们必须在回顾下过去,去看下原来的 python 版本中让代码运行必需的,一种极
其普遍的做法。在 2.1 之前,我们将会得到一个错误,如同你在下面看到的一样,因为函数和 lambda
都可访问全局变量,但两者都不能访问彼此的局部作用域。
>>> foo()
Traceback (innermost last):
File "<stdin>", line 1, in ?
File "<stdin>", line 4, in foo
File "<stdin>", line 3, in <lambda>
NameError: y
在上面的例子中,虽然 lambda 表达式在 foo()的局部作用域中创建,但他仅仅只能访问两个作
用域:它自己的局部作用域和全局的作用域(同样见 Section 11.8.3).解决的方法是加入一个变量
作为默认参数,这样我们便能从外面的局部作用域传递一个变量到内部。在我们上面的例子中,我
们将 lambda 的那一行修改成这样:
bar = lambda y=y: x+y
由于这个改变,程序能运行了。外部 y 的值会作为一个参数传入,成为局部的 y(lambda 函数
的局部变量)。你可以在所有你遇到的 python 代码中看到这种普遍的做法;然而,这不表明存在改
变外部 y 值的可能性,比如:
x = 10


def foo():
y = 5
bar = lambda y=y: x+y
print bar()
y = 8
print bar()
输出“完全错误“
>>> foo()
15
15
原因是外部 y 的值被传入并在 lambda 中“设置“,所以虽然其值在稍后改变了,但是 lambda
的定义没有变。那时唯一替代的方案就是在 lambda 表达式中加入对函数局部变量 y 进行引用的局部
变量 z。
x = 10
def foo():
y = 5
bar = lambda z:x+z
print bar(y)
y = 8
print bar(y)
为了获得正确的输出所有的一切都是必需的:
>>> foo()
15
18
这同样也不可取因为现在所有调用 bar()的地方都必需改为传入一个变量。从 python2.1 开始,
在没有任何修改的情况下整个程序都完美的运行。
x = 10
def foo():
y = 5
bar = lambda :x+y
print bar(y)
y = 8


print bar(y)
>>> foo()
15
18
正确的静态嵌套域(最后)被加入到 python 中,你会不高兴吗?许多老前辈一定不会。你可以
在 pep227 中阅读到更多关于这个重要改变的信息。
11.8.6     变量作用域和名字空间。
从我们在这章的学习中,我们可以看见任何时候,总有一个或者两个活动的作用域---不多,不
少。我们要么在只能访问全局作用域的模块的最高级,要么在一个我们能访问函数局部作用域和全
局作用域的函数体内执行。名字空间是怎么和作用域关联的呢?
从 11.8.1 小节的核心笔记中,我们也可以发现,在任何给定的时间,存在两个或者三个的活动
的名字空间。从函数内部,局部作用域包围了局部名字空间,第一个搜寻名字的地方。如果名字存
在的话,那么将跳过检查全局作用域(全局和内建的名字空间)
我们现在将给出例子 11.9,一个到处混合了作用域的脚本。我们将确定此程序输出作为练习留
给读者。
例子 11.9 变量作用域(scope.py)
局部变量隐藏了全局变量,正如在这个变量作用程序中显示的。程序的输出会是什么呢?(以
及为什么)
1 #!/usr/bin/env python
2 j, k = 1, 2
3
4 def proc1():
5
6 j, k = 3, 4
7 print "j == %d and k == %d" % (j, k)
8k = 5
9
10 def proc2():
11


12   j = 6
13   proc1()
14   print "j == %d and k == %d" % (j, k)
15
16
17   k = 7
18   proc1()
19   print "j == %d and k == %d" % (j, k)
20
21   j = 8
22   proc2()
23   print "j == %d and k == %d" % (j, k)
12.3.1 小节有更多关于名字空间和变量作用域的信息。
11.9    *递归
如果函数包含了对其自身的调用,该函数就是递归的。根据 Aho, Sethi, 和 Ullman, ”[a] 如
果一个新的调用能在相同过程中较早的调用结束之前开始,那么该过程就是递归的“
递归广泛地应用于语言识别和使用递归函数的数学应用中。在本文的早先部分,我们第一次看
到了我们定义的阶乘函数
N! ? factorial(N) ? 1 * 2 * 3 ... * N
我们可以用这种方式来看阶乘:
factorial(N) = N!
= N * (N-1)!
= N * (N-1) * (N-2)!
:
= N * (N-1) * (N-2) ... * 3 * 2 * 1
我们现在可以看到阶乘是递归的,因为 factorial(N) = N* factorial(N-1).换句话说,为了获
得 factorial(N)的值,需要计算 factorial(N-1).而且,为了找到 factorial(N-1),需要计算
factorial(N-2)等等。我们现在给出阶乘函数的递归版本。
def factorial(n):
if n == 0 or n == 1: # 0! = 1! = 1
return 1


else:
return (n * factorial(n-1))
11.10 生成器
早先在第 8 章,我们讨论了迭代器背后的有效性以及它们如何给非序列对象一个像序列的迭代
器接口。这很容易明白因为他们仅仅只有一个方法,用于调用获得下个元素的 next()
然而,除非你实现了一个迭代器的类,迭代器真正的并没有那么“聪明“。难道调用函数还没
有强大到在迭代中以某种方式生成下一个值并且返回和 next()调用一样简单的东西?那就是生成器
的动机之一。
生成器的另外一个方面甚至更加强力.....协同程序的概念。协同程序是可以运行的独立函数调
用,可以暂停或者挂起,并从程序离开的地方继续或者重新开始。在有调用者和(被调用的)协同
程序也有通信。举例来说,当协同程序暂停的时候,我们能从其中获得一个中间的返回值,当调用
回到程序中时,能够传入额外或者改变了的参数,但仍能够从我们上次离开的地方继续,并且所有
状态完整。挂起返回出中间值并多次继续的协同程序被称为生成器,那就是 python 的生成器真正在
做的事。在 2.2 的时候,生成器被加入到 python 中接着在 2.3 中成为标准(见 PEP255),虽然之前
足够强大,但是在 Python2.5 的时候,得到了显著的提高(见 pep342)。这些提升让生成器更加接
近一个完全的协同程序,因为允许值(和异常)能传回到一个继续的函数中。同样地,当等待一个
生成器的时候,生成器现在能返回控制。在调用的生成器能挂起(返回一个结果)之前,调用生成
器返回一个结果而不是阻塞等待那个结果返回。让我们更进一步观察生成器自顶向下的启动.
什么是 python 式的生成器?从句法上讲,生成器是一个带 yield 语句的函数。一个函数或者子
程序只返回一次,但一个生成器能暂停执行并返回一个中间的结果----那就是 yield 语句的功能,返
回一个值给调用者并暂停执行。当生成器的 next()方法被调用的时候,它会准确地从离开地方继续
(当它返回[一个值以及]控制给调用者时)
当在 2.2 生成器被加入的时候,因为它引入了一个新的关键字,yield,为了向下兼容,你需要
从_future_模块中导入 generators 来使用生成器。从 2.3 开始,当生成器成为标准的时候,这就不
再是必需的了。
11.10.1.简单的生成器特性
与迭代器相似,生成器以另外的方式来运作:当到达一个真正的返回或者函数结束没有更多的
值返回(当调用 next()),一个 StopIteration 异常就会抛出。这里有个例子,简单的生成器:
def simpleGen():
yield 1
yield '2 --> punch!'


现在我们有自己的生成器函数,让我们调用他来获得和保存一个生成器对象(以便我们能调用它
的 next()方法从这个对象中获得连续的中间值)
>>> myG = simpleGen()
>>> myG.next()
1
>>> myG.next()
'2 --> punch!'
>>> myG.next()
Traceback (most recent call last):
File "", line 1, in ?
myG.next() StopIteration
由于 python 的 for 循环有 next()调用和对 StopIteration 的处理,使用一个 for 循环而不是手
动迭代穿过一个生成器(或者那种事物的迭代器)总是要简洁漂亮得多。
>>> for eachItem in simpleGen():
... print eachItem
...
1
'2 --> punch!'
当然这是个挺傻的例子:为什么不对这使用真正的迭代器呢?许多动机源自能够迭代穿越序列,
而这需要函数威力而不是已经在某个序列中静态对象。
在接下来的例子中,我们将要创建一个带序列并从那个序列中返回一个随机元素的随机迭代器:
from random import randint
def randGen(aList):
while len(aList) > 0:
yield aList.pop(randint(0, len(aList)))
不同点在于每个返回的元素将从那个队列中消失,像一个 list.pop()和 random.choice()的结
合的归类。
>>> for item in randGen(['rock', 'paper', 'scissors']):
... print item
...
scissors
rock


paper
在接下来的几章中,当我们谈到面向对象编程的时候,将看见这个生成器较简单(和无限)的
版本作为类的迭代器。在几章前的 8.12 小节中,我们讨论了生成器表达式的语法。使用这个语法返
回的对象是个生成器,但只以一个简单的形式,并允许使用过分简单化的列表解析的语法。
这些简单的例子应该让你有点明白生成器是如何工作的,但你或许会问。"在我的应用中,我可
以在哪使用生成器?“或许,你会问“最适合使用这些个强大的构建的地方在哪?“
使用生成器最好的地方就是当你正迭代穿越一个巨大的数据集合,而重复迭代这个数据集合是
一个很麻烦的事,比如一个巨大的磁盘文件,或者一个复杂的数据库查询。对于每行的数据,你希
望执行非元素的操作以及处理,但当正指向和迭代过它的时候,你“不想失去你的地盘“。
你想要抓取一块数据,比如,将它返回给调用者来处理以及可能的对(另外一个)数据库的插
入,接着你想要运行一次 next()来获得下一块的数据,等等。状态在挂起和再继续的过程中是保留
了的,所以你会觉得很舒服有一个安全的处理数据的环境。没有生成器的话,你的程序代码很有可
能会有很长的函数,里面有一个很长的循环。当然,这仅仅是因为一个语言这样的特征不意味着你
需要用它。如果在你程序里没有明显适合的话,那就别增加多余的复杂性!当你遇到合适的情况时,
你便会知道什么时候生成器正是要使用的东西。
11.10.2     加强的生成器特性
在 python2.5 中,一些加强特性加入到生成器中,所以除了 next()来获得下个生成的值,用户
可以将值回送给生成器[send()],在生成器中抛出异常,以及要求生成器退出[close()]
由于双向的动作涉及到叫做 send()的代码来向生成器发送值(以及生成器返回的值发送回来),
现在 yield 语句必须是一个表达式,因为当回到生成器中继续执行的时候,你或许正在接收一个进
入的对象。下面是一个展示了这些特性的,简单的例子。我们用简单的闭包例子,counter:
def counter(start_at=0):
count = start_at
while True:
val = (yield count) if val is not None:
count = val
else:
count += 1
生成器带有一个初始化的值,对每次对生成器[next()]调用以 1 累加计数。用户已可以选择重
置这个值,如果他们非常想要用新的值来调用 send()不是调用 next()。这个生成器是永远运行的,


所以如果你想要终结它,调用 close()方法。如果我们交互的运行这段代码,会得到如下输出:
>>> count = counter(5)
>>> count.next()
5
>>> count.next()
6
>>> count.send(9)
9
>>> count.next()
10
>>> count.close()
>>> count.next()
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
StopIteration
你可以在 PEP 的 255 和 342 中,以及给读者介绍 python2.2 中新特性的 linux 期刊文章中阅读
到更多关于生成器的资料:
http://www.linuxjournal.com/article/5597
11.11     练习
11–1.参数。比较下面 3 个函数:
def countToFour1():
for eachNum in range(5):
print eachNum,
def countToFour2(n):
for eachNum in range(n, 5):
print eachNum,
def countToFour3(n=1):
for eachNum in range(n, 5):
print eachNum,
给定如下的输入直到程序输出,你认为什么会发生?向下表 11.2 填入输出。如果你认为给定的
输入会发生错误的话填入“ERROR"或者如果没有输出的话填入“NONE"


11-2.函数。结合你对练习 5-2 的解,以便你创建一个带相同对数字并同时返回一它们之和以及
产物的结合函数。
表 11.2 问题 11-1 的输出图
11-3 函数。在这个练习中,我们将实现 max()和 min()内建函数。
(a) 写分别带两个元素返回一个较大和较小元素,简单的 max2()核 min2()函数。他们应该可以
用任意的 python 对象运作。举例来说,max2(4,8)和 min2(4,8)会各自每次返回 8 和 4。
(b) 创建使用了在 a 部分中的解来重构 max()和 min()的新函数 my_max()和 my_min().这些函
数分别返回非空队列中一个最大和最小值。它们也能带一个参数集合作为输入。用数字和字符串来
测试你的解。
11–4.    返回值。给你在 5-13 的解创建一个补充函数。创建一个带以分为单位的总时间以及
返回一个以小时和分为单位的等价的总时间。
11–5.
默认参数。更新你在练习 5-7 中创建的销售税脚本以便让销售税率不再是函数输入的必要之物。
创建使用你地方税率的默认参数如果在调用的时候没有值传入。
11–6.    变长参数。下一个称为 printf()的函数。有一个值参数,格式字符串。剩下的就是根
据格式化字符串上的值,要显示在标准输出上的可变参数,格式化字符串中的值允许特别的字符串
格式操作指示符,如%d, %f, etc。提示:解是很琐碎的----无需实现字符串操作符功能性,但你需
要显示用字符串格式化操作(%)
11–7. 用 map() 进 行 函 数 式 编 程 。 给 定 一 对 同 一 大 小 的 列 表 , 如 [1 , 2 , 3] 和
['abc','def','ghi',....],将两个标归并为一个由每个列表元素组成的元组的单一的表,以使我
们的结果看起来像这样:{[(1, 'abc'), (2, 'def'), (3, 'ghi'), ...}.(虽然这问题在本质上和
第六章的一个问题相似,那时两个解没有直接的联系)然后创建用 zip 内建函数创建另一个解。


11–8. 用 filer()进行函数式编程.使用练习 5-4 你给出的代码来决定闰年。更新你的代码一
边他成为一个函数如果你还没有那么做的话。然后写一段代码来给出一个年份的列表并返回一个只
有闰年的列表。然后将它转化为用列表解析。
11–9.    用 reduce()进行函数式编程。复习 11.7.2 部分,阐述如何用 reduce()数字集合的累
加的代码。修改它,创建一个叫 average()的函数来计算每个数字集合的简单的平均值。
11–10.用 filter()进行函数式编程。在 unix 文件系统中,在每个文件夹或者目录中都有两个
特别的文件:'.'表示现在的目录,'..'表示父目录。给出上面的知识,看下 os.listdir()函数的文
档并描述这段代码做了什么:
files = filter(lambda x: x and x[0] != '.', os. listdir(folder))
11–11.用 map()进行函数式编程。写一个使用文件名以及通过除去每行中所有排头和最尾的空
白来“清洁“文件。在原始文件中读取然后写入一个新的文件,创建一个新的或者覆盖掉已存在的。
给你的用户一个选择来决定执行哪一个。将你的解转换成使用列表解析。
11–12. 传递函数。给在这章中描述的 testit()函数写一个姊妹函数。timeit()会带一个函数
对象(和参数一起)以及计算出用了多少时间来执行这个函数,而不是测试执行时的错误。返回下
面的状态:函数返回值,消耗的时间。你可以用 time.clock()或者 time.time(),无论哪一个给你
提供了较高的精度。       (一般的共识是在 POSIX 上用 time.time(),在 win32 系统上用 time.clock())
注意:timeit()函数与 timeit 模块不相关(在 python2.3 中引入)
11–13.使用 reduce()进行函数式编程以及递归。在第 8 张中,我们看到 N 的阶乘或者 N!作为
从 1 到 N 所有数字的乘积。
(a) 用一分钟写一个带 x,y 并返回他们乘积的名为 mult(x,y)的简单小巧的函数。
(b)用你在 a 中创建 mult()函数以及 reduce 来计算阶乘。
(c)彻底抛弃掉 mult()的使用,用 lamda 表达式替代。
(d)在这章中,我们描绘了一个递归解决方案来找到 N!用你在上面问题中完成的 timeit()函数,
并给三个版本阶乘函数计时(迭代的,reduce()以及递归)
11–14. 递归。我们也来看下在第八章中的 Fibonacci 数字。重写你先前计算 Fibonacci 数字
的解(练习 8-9)以便你可以使用递归。
11–15.递归。从写练习 6-5 的解,用递归向后打印一个字符串。用递归向前以及向后打印一个
字符串。
11–16. 更新 easyMath.py。这个脚本,如例子 11.1 描绘的那样,以入门程序来帮助年轻人强
化他们的数学技能。通过加入乘法作为可支持的操作来更进一步提升这个程序。额外的加分:也加
入除法;这比较难做些因为你要找到有效的整数除数。幸运的是,已经有代码来确定分子比分母大,
所以不需要支持分数。


11–17.定义
(a) 描述偏函数应用和 currying 之间的区别。
(b)    偏函数应用和闭包之间有什么区别?
(c)    最后,迭代器和生成器是怎么区别开的?
11–18. 同步化函数调用。复习下第六章中当引入浅拷贝和深拷贝的时候,提到的丈夫和妻子
情形(6.20 小结)。他们共用了一个普通账户,同时对他们银行账户访问时会发生不利影响。
创建一个程序,让调用改变账户收支的函数必需同步。换句话说,在任意给定时刻只能有个
一进程或者线程来执行函数。一开始你试着用文件,但是一个真正的解决方法是用装饰器和在
threading 或者 mutex 模块中的同步指令。你看看第 17 张来获得更多的灵感。


模块
本章主题
z 什么是模块?
z 模块和文件
z 命名空间
z 导入模块
z 导入模块属性
z 模块内建函数包
z 模块的其他特性


本章将集中介绍 Python 模块和如何把数据从模块中导入到编程环境中。同时也会涉及包的相
关概念。模块是用来组织 Python 代码的方法, 而包则是用来组织模块的。本章最后还会讨论一些
与模块有关的其他方面的问题。
12.1  什么是模块
模块支持从逻辑上组织 Python 代码。 当代码量变得相当大的时候, 我们最好把代码分成一
些有组织的代码段,前提是保证它们的彼此交互。 这些代码片段相互间有一定的联系, 可能是一个
包含数据成员和方法的类, 也可能是一组相关但彼此独立的操作函数。 这些代码段是共享的,所以
Python 允许 "调入" 一个模块, 允许使用其他模块的属性来利用之前的工作成果, 实现代码重用.
这个把其他模块中属性附加到你的模块中的操作叫做导入(import) 。那些自我包含并且有组织的代
码片断就是模块( module )。
12.2 模块和文件
如果说模块是按照逻辑来组织 Python 代码的方法, 那么文件便是物理层上组织模块的方法。
因此, 一个文件被看作是一个独立模块, 一个模块也可以被看作是一个文件。 模块的文件名就是模
块的名字加上扩展名 .py 。这里我们需要讨论一些关于模块文件结构的问题。 与其它可以导入类
(class)的语言不同,在 Python 中你导入的是模块或模块属性。
12.2.1 模块名称空间


本章的后面会详细的讨论名称空间, 但从基本概念来说, 一个名称空间就是一个从名称到对象
的关系映射集合。 我们已经明确地知道, 模块名称是它们的属性名称中的一个重要部分。 例如
string 模块中的 atoi() 函数就是 string.atoi() 。给定一个模块名之后, 只可能有一个模块被
导入到 Python 解释器中, 所以在不同模块间不会出现名称交叉现象; 所以每个模块都定义了它自
己的唯一的名称空间。 如果我在我自己的模块 mymodule 里创建了一个 atoi() 函数, 那么它的名
字应该是 mymodule.atoi() 。 所以即使属性之间有名称冲突, 但它们的完整授权名称(fully
qualified name)——通过句点属性标识指定了各自的名称空间 - 防止了名称冲突的发生。
12.2.2 搜索路径和路径搜索
模块的导入需要一个叫做"路径搜索"的过程。 即在文件系统"预定义区域"中查找 mymodule.py
文件(如果你导入 mymodule 的话)。 这些预定义区域只不过是你的 Python 搜索路径的集合。路径
搜索和搜索路径是两个不同的概念, 前者是指查找某个文件的操作, 后者是去查找一组目录。 有时
候导入模块操作会失败:
>>> import xxx
Traceback (innermost last):
File "<interactive input>", line 1, in ?
ImportError: No module named xxx
发生这样的错误时, 解释器会告诉你它无法访问请求的模块, 可能的原因是模块不在搜索路
径里, 从而导致了路径搜索的失败。
默认搜索路径是在编译或是安装时指定的。 它可以在一个或两个地方修改。
一个是启动 Python 的 shell 或命令行的 PYTHONPATH 环境变量。 该变量的内容是一组用冒
号分割的目录路径。 如果你想让解释器使用这个变量, 那么请确保在启动解释器或执行 Python 脚
本前设置或修改了该变量。
解释器启动之后, 也可以访问这个搜索路径, 它会被保存在 sys 模块的 sys.path 变量里。
不过它已经不是冒号分割的字符串, 而是包含每个独立路径的列表。下面是一个 Unix 机器搜索路
径的样例。切记, 搜索路径在不同系统下一般是不同的。
>>> sys.path
['',    '/usr/local/lib/python2.x/',        '/usr/local/lib/      python2.x/plat-sunos5',
'/usr/local/lib/python2.x/    lib-tk',       '/usr/local/lib/python2.x/lib-dynload',       '/
usr/local/lib/Python2.x/site-packages',]
这只是个列表, 所以我们可以随时随地对它进行修改。 如果你知道你需要导入的模块是什么,
而它的路径不在搜索路径里, 那么只需要调用列表的 append() 方法即可, 就像这样:
sys.path.append('/home/wesc/py/lib')


修改完成后, 你就可以加载自己的模块了。 只要这个列表中的某个目录包含这个文件, 它就会
被正确导入。 当然, 这个方法是把目录追加在搜索路径的尾部。 如果你有特殊需要, 那么应该使
用列表的 insert() 方法操作 。 上面的例子里, 我们是在交互模式下修改 sys.path 的, 在脚本
程序中也完全可以达到同样的目的。这里是使用交互模式执行时遇到的错误:
>>> import sys
>>> import mymodule
Traceback (innermost last): File "<stdin>", line 1, in ?
ImportError: No module named mymodule
>>>
>>> sys.path.append('/home/wesc/py/lib')
>>> sys.path
['', '/usr/local/lib/python2.x/', '/usr/local/lib/
python2.x/plat-sunos5', '/usr/local/lib/python2.x/
lib-tk', '/usr/local/lib/python2.x/lib-dynload', '/usr/
local/lib/python2.x/site-packages’,'/home/wesc/py/lib']
>>>
>>> import mymodule
>>>
从另一方面看, 你可能有一个模块的很多拷贝。 这时, 解释器会使用沿搜索路径顺序找到的
第一个模块。
使用 sys.modules 可以找到当前导入了哪些模块和它们来自什么地方。 和 sys.path 不同,
sys.modules 是一个字典, 使用模块名作为键( key) , 对应物理地址作为值( value )。
12.3    名称空间
名称空间是名称(标识符)到对象的映射。 向名称空间添加名称的操作过程涉及到绑定标识符到
指定对象的操作(以及给该对象的引用计数加 1 )。《Python 语言参考》                      (Python Language Reference)
有如下的定义: 改变一个名字的绑定叫做重新绑定, 删除一个名字叫做解除绑定。
我们在第 11 章已经介绍过在执行期间有两个或三个活动的名称空间。 这三个名称空间分别是
局部名称空间, 全局名称空间和内建名称空间, 但局部名称空间在执行期间是不断变化的, 所以我
们说"两个或三个"。 从名称空间中访问这些名字依赖于它们的加载顺序, 或是系统加载这些名称空
间的顺序。
Python 解释器首先加载内建名称空间。 它由 __builtins__ 模块中的名字构成。 随后加载执
行模块的全局名称空间, 它会在模块开始执行后变为活动名称空间。 这样我们就有了两个活动的名
称空间。


核心笔记:       __builtins__ 和 __builtin__
__builtins__ 模块和 __builtin__ 模块不能混淆。 虽然它们的名字相似——尤其对于新手来
说。 __builtins__ 模块包含内建名称空间中内建名字的集合。 其中大多数(如果不是全部的话)来
自 __builtin__ 模块, 该模块包含内建函数, 异常以及其他属性。 在标准 Python 执行环境下,
__builtins__ 包含 __builtin__ 的所有名字。 Python 曾经有一个限制执行模式, 允许你修改
__builtins__ , 只保留来自 __builtin__ 的一部分, 创建一个沙盒(sandbox)环境。但是, 因为
它有一定的安全缺陷, 而且修复它很困难, Python 已经不再支持限制执行模式。(如版本 2.3 )
如果在执行期间调用了一个函数, 那么将创建出第三个名称空间, 即局部名称空间。 我们可以
通过 globals() 和 locals() 内建函数判断出某一名字属于哪个名称空间。我们将在本章后面详细
介绍这两个函数。
12.3.1      名称空间与变量作用域比较
好了, 我们已经知道了什么是名称空间, 那么它与变量作用域有什么关系呢? 它们看起来极其
相似。 事实上也确实如此。
名称空间是纯粹意义上的名字和对象间的映射关系, 而作用域还指出了从用户代码的哪些物
理位置可以访问到这些名字。 图 12 - 1 展示了名称空间和变量作用域的关系。
注意每个名称空间是一个自我包含的单元。但从作用域的观点来看, 事情是不同的. 所有局部
名称空间的名称都在局部作用范围内。局部作用范围以外的所有名称都在全局作用范围内。
还要记得在程序执行过程中, 局部名称空间和作用域会随函数调用而不断变化, 而全局名称空
间是不变的。
图 12 - 1     名称空间和变量作用域
学完这一节后, 我们建议读者在遇到名称空间的时候想想"它存在吗?", 遇到变量作用域的时
候想想"我能看见它吗?"


12.3.2 名称查找, 确定作用域, 覆盖
那么确定作用域的规则是如何联系到名称空间的呢? 它所要做的就是名称查询. 访问一个属性
时, 解释器必须在三个名称空间中的一个找到它。 首先从局部名称空间开始, 如果没有找到, 解释
器将继续查找全局名称空间. 如果这也失败了, 它将在内建名称空间里查找。 如果最后的尝试也失
败了, 你会得到这样的错误:
>>> foo
Traceback (innermost last): File "<stdin>", line 1, in ?
NameError: foo
这个错误信息体现了先查找的名称空间是如何"遮蔽"其他后搜索的名称空间的。 这体现了名称
覆盖的影响。 图 12 - 1 的灰盒子展示了遮蔽效应。 例如, 局部名称空间中找到的名字会隐藏全
局或内建名称空间的对应对象。 这就相当于"覆盖"了那个全局变量。 请参阅前面章节引入的这几
行代码:
def foo():
print "\ncalling foo()..."
bar = 200
print "in foo(), bar is", bar
bar = 100
print "in __main__, bar is", bar
foo()
执行代码, 我们将得到这样的输出:
in __main__, bar is 100
calling foo()...
in foo(), bar is 200
foo() 函数局部名称空间里的 bar 变量覆盖了全局的 bar 变量。 虽然 bar 存在于全局名称
空间里, 但程序首先找到的是局部名称空间里的那个, 所以"覆盖"了全局的那个。 关于作用域的更
多内容请参阅第 11.8 节。
12.3.3 无限制的名称空间
Python 的一个有用的特性在于你可以在任何需要放置数据的地方获得一个名称空间。 我们已
经在前一章见到了这一特性, 你可以在任何时候给函数添加属性(使用熟悉的句点属性标识)。


def foo():
pass
foo.__doc__ = 'Oops, forgot to add doc str above!'
foo.version = 0.2
在本章, 我们展示了模块是如何创建名称空间的, 你也可以使用相同的方法访问它们:
mymodule.foo()
mymodule.version
虽 然 我 们 还 没 介 绍 面 向 对 象 编 程 (OOP, 第 13 章 ), 但 我 们 可 以 看 看 一 个 简 单 的 "Hello
World!" 例子:
class MyUltimatePythonStorageDevice(object):
pass
bag = MyUltimatePythonStorageDevice()
bag.x = 100
bag.y = 200
bag.version = 0.1
bag.completed = False
你可以把任何想要的东西放入一个名称空间里。 像这样使用一个类(实例)是很好的, 你甚至
不需要知道一些关于 OOP 的知识(注解: 类似这样的变量叫做实例属性。) 不管名字如何, 这个实
例只是被用做一个名称空间。
随着学习的深入, 你会发现 OOP 是多么地有用, 比如在运行时临时(而且重要)变量的时候!
正如在《Python 之禅》(Zen of Python)中陈述的最后一条, "名字空间是一个响亮的杰出创意——
那就让我们多用用它们吧!"(在交互模式解释器下导入 this 模块就可以看到完整的 《Zen》 )。
12.4     导入模块
12.4.1 语句
使用 import 语句导入模块, 它的语法如下所示:
import module1
import module2[
:
import moduleN


也可以在一行内导入多个模块, 像这样
import module1[, module2[,... moduleN]]
但是这样的代码可读性不如多行的导入语句。 而且在性能上和生成 Python 字节代码时这两种
做法没有什么不同。 所以一般情况下, 我们使用第一种格式。
核心风格: import 语句的模块顺序
我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序:
z Python 标准库模块
z Python 第三方模块
z 应用程序自定义模块
然后使用一个空行分割这三类模块的导入语句。 这将确保模块使用固定的习惯导入, 有助于减
少每个模块需要的 import 语句数目。 其他的提示请参考《 Python 风格指南》(Python’s Style
Guide), PEP8 。
解释器执行到这条语句, 如果在搜索路径中找到了指定的模块, 就会加载它。该过程遵循作用
域原则, 如果在一个模块的顶层导入, 那么它的作用域就是全局的; 如果在函数中导入, 那么它的
作用域是局部的。
如果模块是被第一次导入, 它将被加载并执行。
12.4.2     from-import 语句
你可以在你的模块里导入指定的模块属性。 也就是把指定名称导入到当前作用域。 使用
from-import 语句可以实现我们的目的, 它的语法是:
from module import name1[, name2[,... nameN]]
12.4.3     多行导入
多行导入特性是 Python 2.4 为较长的 from-import 提供的。从一个模块导入许多属性时,
import 行会越来越长, 直到自动换行, 而且需要一个 \ 。下面是 PEP 328 提供的样例代码:
from Tkinter import Tk, Frame, Button, Entry, Canvas, \
Text, LEFT, DISABLED, NORMAL, RIDGE, END
你可以选择使用多行的 from-import 语句:


from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
我们不提倡使用不再流行的 from Tkinter import * 语句 (参考第 12.5.3 一节的“核心风格”)。
真正的 Python 程序员应该使用 Python 的标准分组机制(圆括号)来创建更合理的多行导入语句:
你可以在 PEP 328 找到更多关于多行导入的内容。
12.4.4 扩展的 import 语句(as)
有时候你导入的模块或是模块属性名称已经在你的程序中使用了, 或者你不想使用导入的名字。
可能是它太长不便输入什么的, 总之你不喜欢它。 这已经成为 Python 程序员的一个普遍需求: 使
用自己想要的名字替换模块的原始名称。一个普遍的解决方案是把模块赋值给一个变量:
>>> import longmodulename
>>> short = longmodulename
>>> del longmodulename
上边的例子中, 我们没有使用 longmodulename.attribute , 而是使用 short.attribute 来
访问相同的对象。 ( from-imoort 语句也可以解决类似的问题, 参见下面的例子。) 不过在程序
里一遍又一遍做这样的操作是很无聊的。 使用扩展的 import , 你就可以在导入的同时指定局部
绑定名称。 类似这样...
import Tkinter
from cgi import FieldStorage
. . . 可以替换为 . . .
import Tkinter as tk
from cgi import FieldStorage as form
Python 2.0 加入了这个特性。 不过那时 "as" 还不是一个关键字; Python 2.6 正式把它列为
一个关键字。 更多关于扩展导入语句的内容请参阅《 Python 语言参考》和 PEP 221。
12.5    模块导入的特性
12.5.1     载入时执行模块
加载模块会导致这个模块被"执行"。 也就是被导入模块的顶层代码将直接被执行。 这通常包
括设定全局变量以及类和函数的声明。 如果有检查 __name__ 的操作, 那么它也会被执行。


当然, 这样的执行可能不是我们想要的结果。 你应该把尽可能多的代码封装到函数。明确地说,
只把函数和模块定义放入模块的顶层是良好的模块编程习惯。
更多信息请参阅第 14.1.1 节以及相应的“核心笔记”。
Python 加入的一个新特性允许你把一个已经安装的模块作为脚本执行。 (当然, 执行你自己的
脚本很简单 [$ foo.py], 但执行一个标准库或是第三方包中的模块需要一定的技巧。) 你可以在第
14.4.3 一节了解更多。
12.5.2     导入(import )和加载(load)
一个模块只被加载一次, 无论它被导入多少次。 这可以阻止多重导入时代码被多次执行。 例
如你的模块导入了 sys 模块, 而你要导入的其他 5 个模块也导入了它, 那么每次都加载 sys (或
是其他模块)不是明智之举! 所以, 加载只在第一次导入时发生。
12.5.3      导入到当前名称空间的名称
调用 from-import 可以把名字导入当前的名称空间里去, 这意味着你不需要使用属性/句点
属性标识来访问模块的标识符。 例如, 你需要访问模块 module 中的 var 名字是这样被导入的:
from module import var
我们使用单个的 var 就可以访问它自身。 把 var 导入到名称空间后就再没必要引用模块了。
当然, 你也可以把指定模块的所有名称导入到当前名称空间里:
from module import *
核心风格:         限制使用 "from module import *"
在实践中, 我们认为 "from module import *" 不是良好的编程风格, 因为它"污染"当前名称
空间, 而且很可能覆盖当前名称空间中现有的名字; 但如果某个模块有很多要经常访问的变量或者
模块的名字很长, 这也不失为一个方便的好办法。
我们只在两种场合下建议使用这样的方法, 一个场合是:目标模块中的属性非常多, 反复键入
模 块 名 很 不 方 便 , 例 如 Tkinter (Python/Tk) 和 NumPy (Numeric Python) 模 块 , 可 能 还 有
socket 模块。另一个场合是在交互解释器下, 因为这样可以减少输入次数。
12.5.4        被导入到导入者作用域的名字
只从模块导入名字的另一个副作用是那些名字会成为局部名称空间的一部分。 这可能导致覆盖


一个已经存在的具有相同名字的对象。 而且对这些变量的改变只影响它的局部拷贝而不是所导入模
块的原始名称空间。 也就是说, 绑定只是局部的而不是整个名称空间。
这里我们提供了两个模块的代码: 一个导入者, impter.py , 一个被导入者, imptee.py 。
impter.py 使用 from-import 语句只创建了局部绑定。
#############
# imptee.py #
#############
foo = 'abc'
def show():
print 'foo from imptee:', foo
#############
# impter.py #
#############
from imptee import foo, show
show()
foo = 123
print 'foo from impter:', foo
show()
运行这个导入者程序, 我们发现从被导入者的观点看, 它的 foo 变量没有改变, 即使 我们
在 importer.py 里修改了它。
foo from imptee: abc
foo from impter: 123
foo from imptee: abc
唯一的解决办法是使用 import 和完整的标识符名称(句点属性标识)。
#############
# impter.py #
#############
import imptee
imptee.show()
imptee.foo = 123
print 'foo from impter:', imptee.foo
imptee.show()
完成相应修改后, 结果如我们所料:
foo from imptee: abc
foo from impter: 123
foo from imptee: 123


12.5.5     关于 __future__
回首 Python 2.0 , 我们认识到了由于改进, 新特性, 以及当前特性增强, 某些变化会影响到
当前功能。 所以为了让 Python 程序员为新事物做好准备, Python 实现了 __future__ 指令。
使用 from-import 语句"导入"新特性, 用户可以尝试一下新特性或特性变化, 以便在特性固
定下来的时候修改程序。 它的语法是:
from __future__ import new_feature
只 import __future__ 不会有任何变化,所以这是被禁止的。 (事实上这是允许的, 但它不会
如你所想的那样启用所有特性。) 你必须显示地导入指定特性。 你可以在 PEP 236 找到更多关于
__future__ 的资料。
12.5.6     警告框架
和 __future__ 指令类似, 有必要去警告用户不要使用一个即将改变或不支持的操作, 这样他
们会在新功能正式发布前采取必要措施。 这个特性是很值得讨论的, 我们这里分步讲解一下。
首先是应用程序(员)接口(Application programmers' interface , API)。 程序员应该有从
Python 程序(通过调用 warnings 模块)或是 C 中(通过 PyErr_Warn() 调用)发布警告的能力。
这个框架的另个部分是一些警告异常类的集合。 Warning 直接从 Exception 继承, 作为所有
警告的基类: UserWarning , DeprecationWarning , SyntaxWarning , 以及 RuntimeWarning 。 都
在第 10 章中有详细介绍。
另一个组件是警告过滤器, 由于过滤有多种级别和严重性, 所以警告的数量和类型应该是可控
制的。 警告过滤器不仅仅收集关于警告的信息(例如行号, 警告原因等等), 而且还控制是否忽略警
告, 是否显示——自定义的格式——或者转换为错误(生成一个异常)。
警告会有一个默认的输出显示到 sys.stderr , 不过有钩子可以改变这个行为, 例如,当运行
会引发警告的 Python 脚本时,可以记录它的输出记录到日志文件中,而不是直接显示给终端用户。
Python 还提供了一个可以操作警告过滤器的 API 。
最后, 命令行也可以控制警告过滤器。 你可以在启动 Python 解释器的时候使用 -W 选项。请
参阅 PEP 230 的文档获得你的 Python 版本的对应开关选项。 Python 2.1 第一次引入警告框架。
12.5.7      从 ZIP 文件中导入模块


在 2.3 版中, Python 加入了从 ZIP 归档文件导入模块的功能。 如果你的搜索路径中存在一
个包含 Python 模块(.py, .pyc, or .pyo 文件)的 .zip 文件, 导入时会把 ZIP 文件当作目录处
理, 在文件中搜索模块。
如果要导入的一个 ZIP 文件只包含 .py 文件, 那么 Python 不会为其添加对应的 .pyc 文件,
这意味着如果一个 ZIP 归档没有匹配的 .pyc 文件时, 导入速度会相对慢一点。
同时你也可以为 .zip 文件加入特定的(子)目录, 例如 /tmp/yolk.zip/lib 只会从 yolk 归
档的 lib/ 子目录下导入。 虽然 PEP 273 指定了这个特性, 但事实上使用了 PEP 302 提供的导入
钩子来实现它。
12.5.8     "新的"导入钩子
导入 ZIP 归档文件这一特性其实新导入钩子( import hook , PEP 302) 的 "第一个顾客"。我
们使用了"新"这个字, 因为在这之前实现自定义导入器只能是使用一些很古老的模块, 它们并不会
简化创建导入器。 另一个解决方法是覆盖 __import__() , 但这并不简单, 你需要(重新)实现整个
导入机制。
Python 2.3 引入的新导入钩子,从而简化了这个操作。 你只需要编写可调用的 import 类, 然
后通过 sys 模块"注册"(或者叫"安装")它。
你需要两个类: 一个查找器和一个载入器。 这些类的实例接受一个参数:模块或包的全名称。
查找器实例负责查找你的模块, 如果它找到, 那么它将返回一个载入器对象。查找器可以接受一个
路径用以查找子包(subpackages) 。载入器会把模块载入到内存。它负责完成创建一个 Python 模
块所需要的一切操作, 然后返回模块。
这些实例被加入到 sys.path_hooks 。 sys.path_importer_cache 只是用来保存这些实例, 这
样就只需要访问 path_hooks 一次。 最后, sys.meta_path 用来保存一列需要在查询 sys.path 之
前访问的实例, 这些是为那些已经知道位置而不需要查找的模块准备的。 meta-path 已经有了指
定模块或包的载入器对象的读取器。
12.6     模块内建函数
系统还为模块提供了一些功能上的支持. 现在我们将详细讨论他们.
12.6.1     __import__()
Python 1.5 加入了 __import__() 函数, 它作为实际上导入模块的函数, 这意味着 import 语


句调用 __import__() 函数完成它的工作。提供这个函数是为了让有特殊需要的用户覆盖它, 实现
自定义的导入算法。
__import__() 的语法是:
__import__(module_name[, globals[, locals[, fromlist]]])
module_name 变量是要导入模块的名称, globals 是包含当前全局符号表的名字的字典,
locals 是包含局部符号表的名字的字典, fromlist 是一个使用 from-import 语句所导入符号的
列表。
globals , locals , 以及 fromlist 参数都是可选的, 默认分别为 globals() , locals() 和
[] 。
调用 import sys 语句可以使用下边的语句完成:
sys = __import__('sys')
12.6.2 globals() 和 locals()
globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典。 在一个函数内
部, 局部名称空间代表在函数执行时候定义的所有名字, locals() 函数返回的就是包含这些名字
的字典。 globals() 会返回函数可访问的全局名字。
在全局名称空间下, globals() 和 locals() 返回相同的字典, 因为这时的局部名称空间就是
全局空间。 下边这段代码演示这两个函数的了使用:
def foo():
print '\ncalling foo()...'
aString = 'bar'
anInt = 42
print "foo()'s globals:", globals().keys()
print "foo()'s locals:", locals().keys()
print "__main__'s globals:", globals().keys()
print "__main__'s locals:", locals().keys() foo()
我们只在这里访问了字典的键 , 因为它的值在这里没有影响(而且他们会让行变得更长更难
懂)。
执行这个脚本, 我们得到如下的输出:
$ namespaces.py
__main__'s globals: ['__doc__', 'foo', '__name__', '__builtins__']
__main__'s locals: ['__doc__', 'foo', '__name__', '__builtins__']


calling foo()...
foo()'s globals: ['__doc__', 'foo', '__name__', '__builtins__']
foo()'s locals: ['anInt', 'aString']
12.6.3      reload()
reload() 内建函数可以重新导入一个已经导入的模块。 它的语法如下:
reload(module)
module 是你想要重新导入的模块。使用 reload() 的时候有一些标准。 首先模块必须是全部
导入(不是使用 from-import), 而且它必须被成功导入。另外 reload() 函数的参数必须是模块自
身而不是包含模块名的字符串。 也就是说必须类似 reload(sys) 而不是 reload('sys')。
模块中的代码在导入时被执行, 但只执行一次. 以后执行 import 语句不会再次执行这些代码,
只是绑定模块名称。 而 reload() 函数不同。
12.7 包
包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行
环境。Python 1.5 加入了包, 用来帮助解决如下问题:
z 为平坦的名称空间加入有层次的组织结构
z 允许程序员把有联系的模块组合到一起
z 允许分发者使用目录结构而不是一大堆混乱的文件
z 帮助解决有冲突的模块名称
与 类 和 模 块 相 同 , 包 也 使 用 句 点 属 性 标 识 来 访 问 他 们 的 元 素 。 使 用 标 准 的 import 和
from-import 语句导入包中的模块。
12.7.1 目录结构
假定我们的包的例子有如下的目录结构:
Phone/
__init__.py
common_util.py
Voicedta/
__init__.py
Pots.py


Isdn.py
Fax/
__init__.py
G3.py
Mobile/
__init__.py
Analog.py
igital.py
Pager/
__init__.py
Numeric.py
Phone 是最顶层的包, Voicedta 等是它的子包。 我们可以这样导入子包:
import Phone.Mobile.Analog
Phone.Mobile.Analog.dial()
你也可使用 from-import 实现不同需求的导入。
第一种方法是只导入顶层的子包, 然后使用属性/点操作符向下引用子包树:
from Phone import Mobile
Mobile.Analog.dial('555-1212')
此外, 我们可以还引用更多的子包:
from Phone.Mobile import Analog
Analog.dial('555-1212')
事实上, 你可以一直沿子包的树状结构导入:
from Phone.Mobile.Analog import dial
dial('555-1212')
在我们上边的目录结构中, 我们可以发现很多的 __init__.py 文件。 这些是初始化模块,
from-import 语句导入子包时需要用到它。 如果没有用到, 他们可以是空文件。 程序员经常忘记
为 它 们 的 包 目 录 加 入 __init__.py 文 件 , 所 以 从 Python 2.5 开 始 , 这 将 会 导 致 一 个
ImportWarning 信息。
不过, 除非给解释器传递了 -Wd 选项, 否则它会被简单地忽略。
12.7.2      使用 from-import 导入包


包同样支持 from-import all 语句:
from package.module import *
然而, 这样的语句会导入哪些文件取决于操作系统的文件系统. 所以我们在__init__.py 中加
入 __all__ 变量. 该变量包含执行这样的语句时应该导入的模块的名字. 它由一个模块名字符串
列表组成.。
12.7.3 绝对导入
包的使用越来越广泛, 很多情况下导入子包会导致和真正的标准库模块发生(事实上是它们的
名字)冲突。 包模块会把名字相同的标准库模块隐藏掉, 因为它首先在包内执行相对导入, 隐藏掉
标准库模块。
为 此 , 所 有 的 导 入 现 在 都 被 认 为 是 绝 对 的 , 也 就 是 说 这 些 名 字 必 须 通 过 Python 路 径
(sys.path 或是 PYTHONPATH )来访问。
这个决定的基本原理是子包也可以通过 sys.path 访问, 例如 import Phone.Mobile.Analog 。
在这个变化之前, 从 Mobile 子包内模块中导入 Analog 是合理的。作为一个折中方案, Python 允
许通过在模块或包名称前置句点实现相对导入。 更多信息请参阅第 12.7.4 节。
从 Python 2.7 开始, 绝对导入特性将成为默认功能。 ( 从 Python 2.5 开始, 你可以从
__future__ 导入 absolute_import , 体验这个功能。) 你可以参阅 PEP 328 了解更多相关内容。
12.7.4 相对导入
如前所述, 绝对导入特性限制了模块作者的一些特权。失去了 import 语句的自由, 必须有新
的特性来满足程序员的需求。这时候, 我们有了相对导入。 相对导入特性稍微地改变了 import 语
法, 让程序员告诉导入者在子包的哪里查找某个模块。因为 import 语句总是绝对导入的, 所以相
对导入只应用于 from-import 语句。
语法的第一部分是一个句点, 指示一个相对的导入操作。 之后的其他附加句点代表当前 from
起始查找位置后的一个级别。
我们再来看看上边的例子。在 Analog.Mobile.Digital , 也就是 Digital.py 模块中, 我们不
能简单地使用这样的语法。 下边的代码只能工作在旧版本的 Python 下, 在新的版本中它会导致一
个警告, 或者干脆不能工作:
import Analog
from Analog import dial


这是绝对导入的限制造成的。你需要在使用绝对导入或是相对导入中做出选择。下边是一些可
行的导入方法:
from Phone.Mobile.Analog import dial
from  .Analog import dial
from ..common_util import setup
from  ..Fax import G3.dial.
从 2.5 版 开始, 相对导入被加入到了 Python 中 。 在 Python 2.6 中, 在模块内部的导入如
果没有使用相对导入, 那么会显示一个警告信息。 你可以在 PEP 328 的文档中获得更多相关信息。
12.8    模块的其他特性
12.8.1 自动载入的模块
当 Python 解释器在标准模式下启动时, 一些模块会被解释器自动导入, 用于系统相关操作。
唯一一个影响你的是 __builtin__ 模块, 它会正常地被载入, 这和 __builtins__ 模块相同。
sys.modules 变量包含一个由当前载入(完整且成功导入)到解释器的模块组成的字典, 模块
名作为键, 它们的位置作为值。
例如在 Windows 下, sys.modules 变量包含大量载入的模块, 我们这里截短它, 只提供他们的
模块名, 通过调用字典的 keys() 方法:
>>> import sys
>>> sys.modules.keys()
['os.path', 'os', 'exceptions', '__main__', 'ntpath',
'strop', 'nt', 'sys', '__builtin__', 'site',
'signal', 'UserDict', 'string', 'stat']
Unix 下载入的模块很类似:
>>> import sys
>>> sys.modules.keys()
['os.path', 'os', 'readline', 'exceptions',
'__main__', 'posix', 'sys', '__builtin__', 'site',
'signal', 'UserDict', 'posixpath', 'stat']
12.8.2     阻止属性导入


如果你不想让某个模块属性被 "from module import *" 导入 , 那么你可以给你不想导入的属
性名称加上一个下划线( _ )。 不过如果你导入了整个模块或是你显式地导入某个属性(例如 import
foo._bar ), 这个隐藏数据的方法就不起作用了。
12.8.3     不区分大小的导入
有一些操作系统的文件系统是不区分大小写的。 Python 2.1 前, Python 尝试在不同平台下导
入模块时候"做正确的事情", 但随着 MacOS X 和 Cygwin 平台的流行, 这样的不足已经不能再被忽
视, 而需要被清除。
在 Unix(区分大小写)和 Win32(不区分大小写)下, 一切都很明了, 但那些新的不区分大小写
的系统不会被加入区分大小写的特性。 PEP 235 指定了这个特性, 尝试解决这个问题, 并避免那些
其他系统上"hack"式的解决方法。 底线就是为了让不区分大小写的导入正常工作, 必须指定一个叫
做 PYTHONCASEOK 的环境变量。 Python 会导入第一个匹配模块名( 使用不区分大小写的习惯 )。
否则 Python 会执行它的原生区分大小写的模块名称匹配, 导入第一个匹配的模块。
12.8.4 源代码编码
从 Python 2.3 开始, Python 的模块文件开始支持除 7 位 ASCII 之外的其他编码。 当然
ASCII 是默认的, 你只要在你的 Python 模块头部加入一个额外的编码指示说明就可以让导入者
使用指定的编码解析你的模块, 编码对应的 Unicode 字符串。 所以你使用纯 ASCII 文本编辑器的
时候不需要担心了(不需要把你的字符串放入 "Unicode 标签" 里) 。
一个 UTF-8 编码的文件可以这样指示:
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
如果你执行或导入了包含非 ASCII 的 Unicode 字符串而没有在文件头部说明, 那么你会在
Python 2.3 得到一个 DeprecationWarning , 而在 2.5 中这样做会导致语法错误。你可以在 PEP
263 中得到更多关于源文件编码的相关内容。
12.8.5     导入循环
实际上,在使用 Python 时, 你会发现是能够导入循环的。 如果你开发了大型的 Python 工程,
那么你很可能会陷入这样的境地。
我们来看一个例子。 假定我们的产品有一个很复杂的命令行接口( command-line interface ,
CLI)。 其中将会有超过一百万的命令, 结果你就有了一个“超冗余处理器”(overly massive handler,


OMH)子集。 每加入一个新特性, 将有一到三条的新命令加入, 用于支持新的特性。 下边是我们的
omh4cli.py 脚本:
from cli4vof import cli4vof
# command line interface utility function
def cli_util():
pass
# overly massive handlers for the command line interface
def omh4cli():
:
cli4vof()
:
omh4cli()
假定大多控制器都要用到这里的(其实是空的)工具函数。命令行接口的 OMH 都被封装在
omh4cli() 函数里。 如果我们要添加一个新的命令, 那么它会被调用。
现在这个模块不断地增长, 一些聪明的工程师会决定把新命令放入到隔离的模块里, 在原始模
块中只提供访问新东西的钩子。 这样, 管理代码会变得更简单, 如果在新加入内容中发现了 bug ,
那么你就不必在一个几兆的 Python 文件里搜索。
在我们的例子中, 有一个兴奋的经理要我们加入一个 "非常好的特性"。我们将创建一个新的
cli4vof.py 脚本, 而不是把新内容集成到 omh4cli.py 里:
import omh4cli
# command-line interface for a very outstanding feature
def cli4vof():
omh4cli.cli_util()
前边已经提到, 工具函数是每个命令必须的, 而且由于不能把代码从主控制器复制出来, 所以
我们导入了主模块, 在我们的控制器中添加对 omh , omh4cli() 的调用。
问题在于主控制器 omh4cli 会导入我们的 cli4vof 模块(获得新命令的函数), 而 cli4vof
也会导入 omh4cli (用于获得工具函数)。模块导入会失败, 这是因为 Python 尝试导入一个先前没
有完全导入的模块:
$ python omh4cli.py
Traceback (most recent call last):
File "omh4cli.py", line 3, in ? from cli4vof import cli4vof
File "/usr/prod/cli4vof.py", line 3, in ?
import omh4cli
File "/usr/prod/omh4cli.py", line 3, in ?
from cli4vof import cli4vof


ImportError: cannot import name cli4vof
注意跟踪返回消息中显示的对 cli4vof 的循环导入。 问题在于要想调用工具函数, cli4vof 必
须导入 omh4cli 。 如果它不需要这样做, 那么 omh4cli 将会成功导入 cli4vof , 程序正常执行。
但在这里, omh4cli 尝试导入 cli4vof , 而 cli4vof 也试着导入 omh4cli 。 最后谁也不会完成
导入工作, 引发错误。 这只是一个导入循环的例子。 事实上实际应用中会出现更复杂的情况。
解决这个问题几乎总是移除其中一个导入语句。 你经常会在模块的最后看到 import 语句。作
为一个初学者, 你只需要试着习惯它们, 如果你以前遇到在模块底部的 import 语句,现在你知道是
为什么了.。在我们的例子中, 我们不能把 import omh4cli 移到最后, 因为调用 cli4vof() 的时
候 omh4cli() 名字还没有被载入。
$ python omh4cli.py
Traceback (most recent call last): File "omh4cli.py", line 3, in ? from cli4vof import
cli4vof
File "/usr/prod/cli4vof.py", line 7, in ?
import omh4cli
File "/usr/prod/omh4cli.py", line 13, in ?
omh4cli()
File "/usr/prod/omh4cli.py", line 11, in omh4cli cli4vof()
File "/usr/prod/cli4vof.py", line 5, in cli4vof omh4cli.cli_util()
NameError: global name 'omh4cli' is not defined
我们的解决方法只是把 import 语句移到 cli4vof() 函数内部:
def cli4vof():
import omh4cli
omh4cli.cli_util()
这样, 从 omh4cli() 导入 cli4vof() 模块会顺利完成, 在 omh4cli() 被调用之前它会被正
确导入。 只有在执行到 cli4vof.cli4vof() 时候才会导入 omh4cli 模块。
12.8.5 模块执行
有很多方法可以执行一个 Python 模块: 通过命令行或 shell , execfile() , 模块导入, 解
释器的 -m 选项, 等等。这已经超出了本章的范围。 你可以参考 第 14 章 "执行环境", 里边全面
地介绍了这些特性。
12.9 相关模块


下 边 这 些 模 块 可 能 是 你 在 处 理 Python 模 块 导 入 时 会 用 到 的 辅 助 模 块 。 在 这 之 中 ,
modulefinder , pkgutil , 以及 zipimport 是 Python 2.3 新增内容, distutils 包在 Python 2.0
被引入。
z imp - 这个模块提供了一些底层的导入者功能。
z modulefinder - 该模块允许你查找 Python 脚本所使用的所有模块。你可以使用其中的
ModuleFinder 类或是把它作为一个脚本执行, 提供你要分析的(另个) Python 模块的文件
名。
z pkgutil - 该模块提供了多种把 Python 包打包为一个"包"文件分发的方法。 类似 site
模块, 它使用 *.pkg 文件帮助定义包的路径, 类似 site 模块使用的 *.pth 文件。
z site - 和 *.pth 文件配合使用, 指定包加入 Python 路径的顺序, 例如 sys.path ,
PYTHONPATH 。你不需要显式地导入它, 因为 Python 导入时默认已经使用该模块。你可能
需要使用 -S 开关在 Python 启动时关闭它。你也可以完成一些 site 相关的自定义操作,
例如在路径导入完成后在另个地方尝试。
z zipimport - 你可以使用该模块导入 ZIP 归档文件中的模块。 需要注意的是该功能已经"
自动"开启, 所以你不需要在任何应用中使用它。在这里我们提出它只是作为参考。
z distutils - 该模块提供了对建立、 安装、分发 Python 模块和包的支持。 它还可以帮助
建立使用 C/C++ 完成的 Python 扩展。 更多关于 distutils 的信息可以在 Python 文档
里找到, 参阅:
http://docs.python.org/dist/dist.html
http://docs.python.org/inst/inst.html
12.10     练习
12–1.    路径搜索和搜索路径。 路径搜索和搜索路径之间有什么不同?
12–2.    导入属性。 假设你的模块 mymodule 里有一个 foo() 函数。
(a) 把这个函数导入到你的名称空间有哪两种方法?
(b) 这两种方法导入后的名称空间有什么不同?
12–3.    导入. "import module" 和 "fromn module import *" 有什么不同?
12–4.    名称空间和变量作用域。名称空间和变量作用域有什么不同?
12–5.    使用 __import__().
(a) 使用 __import__ 把一个模块导入到你的名称空间。 你最后使用了什么样的语法?
(b) 和上边相同, 使用 __import__() 从指定模块导入特定的名字。
12–6.    扩展导入。创建一个 importAs() 函数. 这个函数可以把一个模块导入到你的名称空
间, 但使用你指定的名字, 而不是原始名字。 例如, 调用 newname=importAs('mymodule') 会导入
mymodule , 但模块和它的所有元素都通过新名称 newname 或 newname.attr 访问。 这是 Python
2.0 引入的扩展导入实现的功能。
12–7. 导入钩子。 研究 PEP 302 的导入钩子机制. 实现你自己的导入机制, 允许编码你的
模块(encryption, bzip2, rot13, 等), 这样解释器会自动解码它们并正确导入。你可以参看 zip
文件导入的实现 (参阅 第 12.5.7 节)。


面向对象编程
本章主题
z 引言
z 面向对象编程
z 类
z 实例
z 绑定与方法调用
z 子类,派生和继承
z 内建函数
z 定制类
z 私有性
z 授权与包装
z 新式类的高级特性
z 相关模块


在我们的描绘中,类最终解释了面向对象编程思想(OOP)。本章中,我们首先将给出一个总体上
的概述,涵盖了 Python 中使用类和 OOP 的所有主要方面。其余部分针对类,类实例和方法进行详细
探讨。我们还将描述 Python 中有关派生或子类化及继承机理。最后,Python 可以在特定功能方面定
制类,例如重载操作符,模拟 Python 类型等。我们将展示如何实现这些特殊的方法来自定义你的类,
以让它们表现得更像 Python 的内建类型。
然而,除了这些外,Python 的面向对象编程(00P)还有一些令人兴奋的变动。在版本 2.2 中,
Python 社区最终统一了类型(types)和类(classes),新式类具备更多高级的 OOP 特性,扮演了一个
经典类(或者说旧式类)超集的角色,后者是 Python 诞生时所创造的类对象。
下面,我们首先介绍在两种风格的类(译者注:新式类和旧式类)中都存在的核心特性,然后讲
解那些只有新式类才拥有的的高级特性。
13.1 介绍
在摸清 OOP 和类的本质之前,我们首先讲一些高级主题,然后通过几个简单的例子热一热身。
如果你刚学习面向对象编程,你可以先跳过这部分内容,直接进入第 13.2 节。如果你对有关面向对
象编程已经熟悉了,并且想了解它在 Python 中是怎样表现的,那么先看一下这部分内容,然后再进
入 13.3 节,看个究竟!
在 Python 中,面向对象编程主要有两个主题,就是类和类实例(见图 13-1)
类与实例
类与实例相互关联着:类是对象的定义,而实例是"真正的实物",它存放了类中所定义的对象
的具体信息。


下面的示例展示了如何创建一个类:
class MyNewObjectType(bases):
'define MyNewObjectType class'
class_suite #类体
关键字是 class,紧接着是一个类名。随后是定义类的类体代码。这里通常由各种各样的定义和
声明组成。新式类和经典类声明的最大不同在于,所有新式类必须继承至少一个父类,参数 bases
可以是一个(单继承)或多个(多重继承)用于继承的父类。
object 是“所有类之母”。如果你的类没有继承任何其他父类,object 将作为默认的父类。它
位于所有类继承结构的最上层。如果你没有直接或间接的子类化一个对象,那么你就定义了一个经
典类:
class MyNewObjectType:
'define MyNewObjectType classic class'
class_suite
如果你没有指定一个父类,或者如果所子类化的基本类没有父类,你这样就是创建了一个经典
类。很多 Python 类都还是经典类。即使经典类已经过时了,在以后的 Python 版本中,仍然可以使
用它们。不过我们强烈推荐你尽可能使用新式类,尽管对于学习来说,两者都行。


图 13-1 左边的工厂制造机器相当于类,而生产出来的玩具就是它们各个类的实例。尽管每个
实例都有一个基本的结构,但各自的属性像颜色或尺寸可以改变-----这就好比实例的属性。
创建一个实例的过程称作实例化,过程如下(注意:没有使用 new 关键字):
myFirstObject = MyNewObjectType()
类名使用我们所熟悉的函数操作符(               ()),以“函数调用”的形式出现。然后你通常会把这个新
建的实例赋给一个变量。赋值在语法上不是必须的,但如果你没有把这个实例保存到一个变量中,
它就没用了,会被自动垃圾收集器回收,因为任何引用指向这个实例。这样,你刚刚所做的一切,
就是为那个实例分配了一块内存,随即又释放了它。
只要你需要,类可以很简单,也可以很复杂。最简单的情况,类仅用作名称空间(namespaces)
(参见第 11 章)。这意味着你把数据保存在变量中,对他们按名称空间进行分组,使得他们处于同
样的关系空间中-----所谓的关系是使用标准 Python 句点属性标识。比如,你有一个本身没有任何
属性的类,使用它仅对数据提供一个名字空间,让你的类拥有像 Pascal 中的记录集(records)和 C
语言中的结构体(structures)一样的特性,或者换句话说,这样的类仅作为容器对象来共享名字
空间。
示例如下:
class MyData(object):
pass


注意有的地方在语法构成上需要有一行语句,但实际上不需要做任何操作,这时候可以使用 pass
语句。这种情况,必要的代码就是类体,但我们暂不想提供这些。上面定义的类没有任何方法或属
性。下面我们创建一个实例,它只使用类作为名称空间容器。
>>> mathObj = MyData()
>>> mathObj.x = 4
>>> mathObj.y = 5
>>> mathObj.x + mathObj.y
9
>>> mathObj.x * mathObj.y
20
我们当然也可以使用变量“x”,“y”来完成同样的事情,但本例中,实例名字 mathObj 将 mathObj.x
和 mathObj.y 关联起来。这就是我们所说的使用类作为名字空间容器。mathObj.x 和 mathObj.y 是
实例属性,因为它们不是类 MyData 的属性,而是实例对象(mathObj)的独有属性。本章后面,我
们将看到这些属性实质上是动态的:你不需要在构造器中,或其它任何地方为它们预先声明或者赋值。
方法
我们改进类的方式之一就是给类添加功能。类的功能有一个更通俗的名字叫方法。在 Python
中,方法定义在类定义中,但只能被实例所调用。也就是说,调用一个方法的最终途径必须是这样
的:(1)定义类(和方法),(2)创建一个实例(3)最后一步,用这个实例调用方法。例如:
class MyDataWithMethod(object): # 定义类
def printFoo(self):    # 定义方法
print 'You invoked printFoo()!'
你可能注意到了 self 参数,它在所有的方法声明中都存在。这个参数代表实例对象本身,当你
用实例调用方法时,由解释器悄悄地传递给方法的,所以,你不需要自己传递 self 进来,因为它是
自动传入的。举例说明一下,假如你有一个带两参数的方法,所有你的调用只需要传递第二个参数,
Python 把 self 作为第一个参数传递进来,如果你犯错的话,也不要紧。Python 将告诉你传入的参
数个数有误。总之,你只会犯一次错,下一次———你当然就记得了!
这种需要在每个方法中给出实例(self)的要求对于那些使用 C++或 Java 的人,可能是一种新
的体验,所以请意识到这点。
Python 的哲学本质上就是要明白清晰。在其它语言中,self 称为“this”                  。可以在 13.7 节的“核
心笔记”中找到有关 self 更多内容。一般的方法会需要这个实例(self),而静态方法或类方法不会,
其中类方法需要类而不是实例。在第 13.8 节中可以看到有关静态方法和类方法的更多内容。


现在我们来实例化这个类,然后调用那个方法:
>>> myObj = MyDataWithMethod() # 创建实例
>>> myObj.printFoo() # 现在调用方法
You invoked printFoo()!
在本节结束时,我们用一个稍复杂的例子来总结一下这部分内容,这个例子给出如何处理类(和
实例),还介绍了一个特殊的方法__init__(),子类化及继承。
对于已熟悉面向对象编程的人来说,__init__()类似于类构造器。如果你初涉 OOP 世界,可以
认为一个构造器仅是一个特殊的方法,它在创建一个新的对象时被调用。在 Python 中,__init__()
实际上不是一个构造器。你没有调用“new”来创建一个新对象。                       (Python 根本就没有“new”关键字)。
取而代之,Python 创建实例后,在实例化过程中,调用__init__()方法,当一个类被实例化时,就
可以定义额外的行为,比如,设定初始值或者运行一些初步诊断代码———主要是在实例被创建后,
实例化调用返回这个实例之前,去执行某些特定的任务或设置。
(我们将把 print 语句添加到方法中,这样我们就清楚什么时候方法被调用了。通常,我们不把
输入或输出语句放入函数中,除非预期代码体具有输出的特性。)
创建一个类(类定义)
class AddrBookEntry(object): # 类定义
'address book entry class'
def __init__(self, nm, ph): # 定义构造器
self.name = nm    # 设置 name
self.phone = ph # 设置 phone
print 'Created instance for:', self.name
def updatePhone(self, newph): # 定义方法
self.phone = newph
print 'Updated phone# for:', self.name
在 AddrBookEntry 类的定义中,定义了两个方法:__init__()和 updatePhone()。__init__()
在实例化时被调用,即,在 AddrBookEntry()被调用时。你可以认为实例化是对__init__()的一种隐
式的调用,因为传给 AddrBookEntry()的参数完全与__init__()接收到的参数是一样的(除了 self,
它是自动传递的)。
回忆一下,当方法在实例中被调用时,self(实例对象)参数自动由解释器传递,所以在上面
的__init__()中,需要的参数是 nm 和 ph,它们分别表示名字和电话号码。__init__()在实例化时,
设置这两个属性,以便,在实例从实例化调用中返回时,这两个属性对程序员是可见的了。你可能


已猜到,updatePhone()方法的目的是替换地址本条目的电话号码属性。
创建实例(实例化)
>>> john = AddrBookEntry('John Doe', '408-555-1212') #为 John Doe 创建实例
>>> jane = AddrBookEntry('Jane Doe', '650-555-1212') #为 Jane Doe 创建实例
这就是实例化调用,它会自动调用__init__()。self 把实例对象自动传入__init__()。你可以
在脑子里把方法中的 self 用实例名替换掉。在上面第一个例子中,当对象 john 被实例化后,它的
john.name 就被设置了,你可在下面得到证实。
另外,如果不存在默认的参数,那么传给__init__()的两个参数在实例化时是必须的。
访问实例属性
>>> john
<__main__.AddrBookEntry instance at 80ee610>
>>> john.name
'John Doe'
>>> john.phone
'408-555-1212'
>>> jane.name
'Jane Doe'
>>> jane.phone
'650-555-1212'
一旦实例被创建后,就可以证实一下,在实例化过程中,我们的实例属性是否确实被__init__()
设置了。我们可以通过解释器“转储”实例来查看它是什么类型的对象。                               (我们以后将学到如何定制
类来获得想要的 Python 对象字符串的输出形式,而不是现在看到的默认的 Python 对象字符串
(<...>))
方法调用(通过实例)
>>> john.updatePhone('415-555-1212') #更新 John Doe 的电话
>>> john.phone
'415-555-1212'
updatePhone()方法需要一个参数(不计 self 在内):新的电话号码。在 updatePhone()之后,
立即检查实例属性,可以证实已生效。


创建子类
靠继承来进行子类化是创建和定制新类类型的一种方式,新的类将保持已存在类所有的特性,
而不会改动原来类的定义(指对新类的改动不会影响到原来的类,译者注)。对于新的类类型来说,
这个新的子类可以定制只属于它的特定功能。除了与父类或基类的关系外,子类与通常的类没有什
么区别,也像一般类一样进行实例化。注意下面,子类声明中提到了父类:
class EmplAddrBookEntry(AddrBookEntry):
'Employee Address Book Entry class'#员工地址本类
def __init__(self, nm, ph, id, em):
AddrBookEntry.__init__(self, nm, ph)
self.empid = id
self.email = em
def updateEmail(self, newem):
self.email = newem
print 'Updated e-mail address for:', self.name
现在我们创建了第一个子类,EmplAddrBookEntry。Python 中,当一个类被派生出来,子类继
承了基类的属性,所以,在上面的类中,我们不仅定义了__init__(),updatEmail()方法,而且
EmplAddrBookEntry 还从 AddrBookEntry 中继承了 updatePhone()方法。
如果需要,每个子类最好定义它自己的构造器,不然,基类的构造器会被调用。然而,如果子
类重写基类的构造器,基类的构造器就不会被自动调用了--这样,基类的构造器就必须显式写出
才会被执行,像我们上面那样,用 AddrBookEntry.__init__()设置名字和电话号码。我们的子类在
构造器后面几行还设置了另外两个实例属性:员工 ID 和 E-mail 地址。
注意,这里我们要显式传递 self 实例对象给基类构造器,因为我们不是在其实例中调用那个方
法而是在一个子类实例中调用那个方法。因为我们不是通过实例来调用它,这种未绑定的方法调用
需要传递一个适当的实例(self)给方法。
本小节后面的例子,告诉我们如何创建子类的实例,访问它们的属性及调用它的方法,包括从
父类继承而来的方法。
使用子类
>>> john = EmplAddrBookEntry('John Doe', '408-555-1212',42, 'john@spam.doe')
Created instance for: John Doe #给 John Doe 创建实例
>>> john
<__main__.EmplAddrBookEntry object at 0x62030>


>>> john.name
'John Doe'
>>> john.phone
'408-555-1212'
>>> john.email
'john@spam.doe'
>>> john.updatePhone('415-555-1212') Updated phone# for: John Doe
>>> john.phone
'415-555-1212'
>>> john.updateEmail('john@doe.spam') Updated e-mail address for: John Doe
>>> john.email
'john@doe.spam'
核心笔记:命名类、属性和方法
类名通常由大写字母打头。这是标准惯例,可以帮助你识别类,特别是在实例化过程中(有时看
起来像函数调用)。还有,数据属性(译者注:变量或常量)听起来应当是数据值的名字,方法名应
当指出对应对象或值的行为。另一种表达方式是:数据值应该使用名词作为名字,方法使用谓词(动
词加对象)   。数据项是操作的对象、方法应当表明程序员想要在对象进行什么操作。在上面我们定义
的类中,遵循了这样的方针,数据值像“name”,“phone”和“email”,行为如“updatePhone”,
“updateEmail”。这就是常说的“混合记法(mixedCase)”或“骆驼记法(camelCase)”。Python 规
范推荐使用骆驼记法的下划线方式,比如,“update_phone”,“update_email”。类也要细致命名,
像“AddrBookEntry”  ,“RepairShop”等等就是很好的名字。
我希望你已初步理解如何在 Python 中进行面向对象编程了。本章其它小节将带你深入面向对象
编程,Python 类及实例的方方面面。
13.2 面向对象编程
编程的发展已经从简单控制流中按步的指令序列进入到更有组织的方式中,依靠代码块可以形
成命名子程序和完成既定的功能。结构化的或过程性编程可以让我们把程序组织成逻辑块,以便重
复或重用。创建程序的过程变得更具逻辑性;选出的行为要符合规范,才可以约束创建的数据。迪
特尔父子(这里指 DEITEL 系列书籍作者 Harvey M.Deitel 和 Paul James Deitel 父子,译者注)认
为结构化编程是“面向行为”的,因为事实上,即使没有任何行为的数据也必须“规定”逻辑性。
然而,如果我们能对数据加上动作呢?如果我们所创建和编写的数据片段,是真实生活中实体
的模型,内嵌数据体和动作呢?如果我们能通过一系列已定义的接口(又称存取函数集合)访问数据
属性,像自动取款机卡或能访问你的银行帐号的个人支票,我们就有了一个“对象”系统,从大的
方面来看,每一个对象既可以与自身进行交互,也可以与其它对象进行交互。


面向对象编程踩上了进化的步伐,增强了结构化编程,实现了数据与动作的融合:数据层和逻
辑层现在由一个可用以创建这些对象的简单抽象层来描述。现实世界中的问题和实体完全暴露了本
质,从中提供的一种抽象,可以用来进行相似编码,或者编入能与系统中对象进行交互的对象中。
类提供了这样一些对象的定义,实例即是这些定义的实现。二者对面向对象设计(object-oriented
design,OOD)来说都是重要的,OOD 仅意味来创建你采用面向对象方式架构来创建系统。
13.2.1 面向对象设计与面向对象编程的关系
面向对象设计(OOD)不会特别要求面向对象编程语言。事实上,OOD 可以由纯结构化语言来实
现,比如 C,但如果想要构造具备对象性质和特点的数据类型,就需要在程序上作更多的努力。当一
门语言内建 OO 特性,OO 编程开发就会更加方便高效。
另一方面,一门面向对象的语言不一定会强制你写 OO 方面的程序。例如 C++可以被认为“更好
的 C”;而 Java,则要求万物皆类,此外还规定,一个源文件对应一个类定义。然而,在 Python 中,
类和 OOP 都不是日常编程所必需的。尽管它从一开始设计就是面向对象的,并且结构上支持 OOP,但
Python 没有限定或要求你在你的应用中写 OO 的代码。OOP 是一门强大的工具,不管你是准备进入,
学习,过渡,或是转向 OOP,都可以任意支配。
13.2.2 现实世界中的问题
考虑用 OOD 来工作的一个最重要的原因,在于它直接提供建模和解决现实世界问题和情形的途
径。比如,让你来试着模拟一台汽车维修店,可以让你停车进行维修。我们需要建两个一般实体:
处在一个“系统”中并与其交互的人类,和一个修理店,它定义了物理位置,用于人类活动。因为
前者有更多不同的类型,我将首先对它进行描述,然后描述后者。在此类活动中,一个名为 Person
的类被创建以用来表示所有的人。Person 的实例可以包括消费者(Customer),技工(Mechanic),还
可能是出纳员(Cashier)。这些实例具有相似的行为,也有独一无二的行为。比如,他们能用声音进
行交流,都有 talk()方法,还有 drive_car()方法。不同的是,技工有 repair_car()方法,而出纳
有 ring_sale()方法。技工有一个 repair_certification 属性,而所有人都有一个 drivers_license
属性。
最后,所有这些实例都是一个检查(overseeing)类 RepairShop 的参与者,后者具有一个叫
operating_hours 的数据属性,它通过时间函数来确定何时顾客来修车,何时职员技工和出纳员来上
班。RepairShop 可能还有一个 AutoBay 类,拥有 SmogZone,TireBrakeZone 等实例,也许还有一个叫
GeneralRepair 的实例。
我们所编的 RepairShop 的一个关键点是要展示类和实例加上它们的行为是如何用来对现实生活
场景建模的。同样,你可以把诸如机场,餐厅,晶蕊,医院,其至一个邮订音乐公司想像为类,它
们完全具备各自的参与者和功能性。


13.2.3*常用术语
对于已熟悉有关 OOP 术语的朋友来说,看 Python 中是怎么称呼的:
抽象/实现
抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于
描绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。
对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户
程序应当是透明而且无关的。
封装/接口
封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端
直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的
一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在 Python 中,所有的类属
性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防
措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装
的数据属性。
合成
合成扩充了对类的描述,使得多个不同的类合成为一个大的类,来解决现实问题。合成描述了
一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为,
所有这些合在一起,彼此是“有一个”的关系。比如,RepairShop“有一个”技工(应该至少有一个
吧),还“有一个”顾客(至少一个)。
这些组件要么通过联合关系组在一块,意思是说,对子组件的访问是允许的(对 RepairShop 来
说,顾客可能请求一个 SmogCheck,客户程序这时就是与 RepairShop 的组件进行交互),要么是聚合
在一起,封装的组件仅能通过定义好的接口来访问,对于客户程序来说是透明的。继续我的例子,
客户程序可能会建立一个 SmogCheck 请求来代表顾客,但不能够同 RepairShop 的 SmogZone 部分进
行交互,因为 SmogZone 是由 RepairShop 内部控制的,只能通过 smogCheckCar()方法调用。Python
支持上述两种形式的合成。
派生/继承/继承结构
派生描述了子类的创建,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它
的自定义操作,都不会修改原类的定义。继承描述了子类属性从祖先类继承这样一种方式。从前面


的例子中,技工可能比顾客多个汽车技能属性,但单独的来看,每个都“是一个”人,所以,不管
对谁而言调用 talk()都是合法得,因为它是人的所有实例共有的。继承结构表示多“代”派生,可
以描述成一个“族谱”,连续的子类,与祖先类都有关系。
泛化/特化
泛化表示所有子类与其父类及祖先类有一样的特点,所以子类可以认为同祖先类是“是一个”
的关系,因为一个派生对象(实例)是祖先类的一个“例子”。比如,技工“是一个”人,车“是一
个”交通工具,等等。在上面我们间接提到的族谱图中,我们可以从子类到祖先类画一条线,表示
“是一个”的关系。特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。
多态
多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的
类。多态表明了动态(又名,运行时)绑定的存在,允计重载及运行时类型确定和验证。
自省/反射
自省表示给予你,程序员,某种能力来进行像“手工类型检查”的工作,它也被称为反射。这
个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么
能力,这样的功能不是很好吗?这是一项强大的特性,在本章中,你会时常遇到。如果 Python 不
支持某种形式的自省功能,dir()和 type()内建函数,将很难正常工作。请密切关注这些调用,还
有那些特殊属性,像__dict__,__name__及__doc__。可能你对其中一些已经很熟悉了!
13.3 类
回想一下,类是一种数据结构,我们可以用它来定义对象,后者把数据值和行为特性融合在一
起。类是现实世界的抽象的实体以编程形式出现。实例是这些对象的具体化。可以类比一下,类是
蓝图或者模型,用来产生真实的物体(实例)。因此为什么是术语“class”?这个术语很可能起源
于使用类来识别和归类特定生物所属的生物种族,类还可以派生出相似但有差异的子类。编程中类
的概念就应用了很多这样的特征。
在 Python 中,类声明与函数声明很相似,头一行用一个相应的关键字,接下来是一个作为它的
定义的代码体,如下所示:
def functionName(args):
'function documentation string' #函数文档字符串
function_suite #函数体
class ClassName(object):


'class documentation string' #类文档字符串
class_suite    #类体
二者都允许你在他们的声明中创建函数,闭包或者内部函数(即函数内的函数),还有在类中定
义的方法。最大的不同在于你运行函数,而类会创建一个对象。类就像一个 Python 容器类型。在这
部分,我们将特别留意类及它们有什么类型的属性。这只要记住,尽管类是对象(在 Python 中,一
切皆对象),但正被定义时,它们还不是对象的实现。在下节中会讲到实例,所以拭目以待吧。不过
现在,我们集中讲解类对象。
当你创建一个类,你就实际创建了一个你自己的数据类型。所以这个类的实例都是相似的,但
类之间彼此是有区别的(因此,不同类的实例自然也不可能相同了)                       。与其玩那些从玩具商那买来的
玩具礼物,为什么不设计并创造你自己的玩具来玩呢?
类还允许派生。你可以创建一个子类,它也是类,而且继续了父类所有的特征和属性。从
Python2.2 开始,你也可以从内建类型中派生子类,而不是仅仅从其它类。
13.3.1 创建类
Python 类使用 class 关键字来创建。简单的类的声明可以是关键字后紧跟类名:
class ClassName(bases):
'class documentation string' #'类文档字符串'
class_suite #类体
本章前面的概述中提到,基类是一个或多个用于继承的父类的集合;类体由所有声明语句,类
成员定义,数据属性和函数组成。类通常在一个模块的顶层进行定义,以便类实例能够在类所定义
的源代码文件中的任何地方被创建。
13.3.2     声明与定义
对于 Python 函数来说,声明与定义类没什么区别,因为他们是同时进行的,定义(类体)紧跟
在声明(含 class 关键字的头行[header line])和可选(但总是推荐使用)的文档字符串后面。同时,
所有的方法也必须同时被定义。如果对 OOP 很熟悉,请注意 Python 并不支持纯虚函数(像 C++)或
者抽象方法(如在 JAVA 中),这些都强制程序员在子类中定义方法。作为替代方法,你可以简单地
在基类方法中引发 NotImplementedError 异常,这样可以获得类似的效果。
13.4 类属性


什么是属性呢?属性就是属于另一个对象的数据或者函数元素,可以通过我们熟悉的句点属性
标识法来访问。一些 Python 类型比如复数有数据属性(实部和虚部),而另外一些,像列表和字典,
拥有方法(函数属性)。
有关属性的一个有趣的地方是,当你正访问一个属性时,它同时也是一个对象,拥有它自己的
属性,可以访问,这导致了一个属性链,比如,myThing,subThing,subSubThing.等等。常见例子如
下:
z sys.stdout.write('foo')
z print myModule.myClass.__doc__
z myList.extend(map(upper, open('x').readlines()))
类属性仅与其被定义的类相绑定,并且因为实例对象在日常 OOP 中用得最多,实例数据属性是
你将会一直用到的主要数据属性。类数据属性仅当需要有更加“静态”数据类型时才变得有用,它
和任何实例都无关,因此,这也是为什么下一节被表为高级主题,你可以选读。                           (如果你对静态不熟,
它表示一个值,不会因为函数调用完毕而消失,它在每两个函数调用的间隙都存在。或者说,一个
类中的一些数据对所有的实例来说,都是固定的。有关静态数据详细内容,见下一小节.)
接下来的一小节中,我们将简要描述,在 Python 中,方法是如何实现及调用的。通常,Python
中的所有方法都有一个限制:在调用前,需要创建一个实例。
13.4.1 类的数据属性
数据属性仅仅是所定义的类的变量。它们可以像任何其它变量一样在类创建后被使用,并且,
要么是由类中的方法来更新,要么是在主程序其它什么地方被更新。
这种属性已为 OO 程序员所熟悉,即静态变量,或者是静态数据。它们表示这些数据是与它们所
属的类对象绑定的,不依赖于任何类实例。如果你是一位 Java 或 C++程序员,这种类型的数据相当
于在一个变量声明前加上 static 关键字。
静态成员通常仅用来跟踪与类相关的值。大多数情况下,你会考虑用实例属性,而不是类属性。
在后面,我们正式介绍实例时,将会对类属性及实例属性进行比较。
看下面的例子,使用类数据属性(foo):
>>> class C(object):
... foo = 100
>>> print C.foo
100
>>> C.foo = C.foo + 1


>>> print C.foo
101
注意,上面的代码中,看不到任何类实例的引用。
13.4.2     方法
方法,比如下面,类 MyClass 中的 myNoActionMethod 方法,仅仅是一个作为类定义一部分定义
的函数.(这使得方法成为类属性)。这表示 myNoActionMethod 仅应用在 MyClass 类型的对象(实例)
上。这里,myNoActionMethod 是通过句点属性标识法与它的实例绑定的。
>>> class MyClass(object):
def myNoActionMethod(self):
pass
>>> mc = MyClass()
>>> mc.myNoActionMethod()
任何像函数一样对 myNoActionMethod 自身的调用都将失败:
>>> myNoActionMethod() Traceback (innermost last):
File "<stdin>", line 1, in ?
myNoActionMethod() NameError: myNoActionMethod
引 发 了 NameError 异 常 , 因 为 在 全 局 名 字 空 间 中 , 没 有 这 样 的 函 数 存 在 。 这 就 告 诉 你
myNoActionMethod 是 一 个 方 法 , 表 示 它 属 于 一 个 类 , 而 不 是 全 局 空 间 中 的 名 字 。 如 果
myNoActionMethod 是在顶层作为函数被定义的,那么我们的调用则会成功。
下面展示的是,甚至由类对象调用此方法也失败了。
>>> MyClass.myNoActionMethod() Traceback (innermost last):
File "<stdin>", line 1, in ?
MyClass.myNoActionMethod()
TypeError: unbound method must be called with class
instance 1st argument
TypeError 异常初看起来很让人困惑,因为你知道这种方法是类的一个属性,因此,一定很想知
道为何为失败吧?接下来将会解释这个问题。
绑定(绑定及非绑定方法)
为与 OOP 惯例保持一致,Python 严格要求,没有实例,方法是不能被调用的。这种限制即 Python


所描述的绑定概念(binding),在此,方法必须绑定(到一个实例)才能直接被调用。非绑定的方法
可能可以被调用,但实例对象一定要明确给出,才能确保调用成功。然而,不管是否绑定,方法都
是它所在的类的固有属性,即使它们几乎总是通过实例来调用的。在 13.7 节中,我们会更深入地探
索本主题。
13.4.2 决定类的属性
要知道一个类有哪些属性,有两种方法。最简单的是使用 dir()内建函数。另外是通过访问类的
字典属性__dict__,这是所有类都具备的特殊属性之一。看一下下面的例子:
>>> class MyClass(object):
...   'MyClass class definition' #MyClass 类定义
...   myVersion = '1.1' # static data 静态数据
...   def showMyVersion(self): # method 方法
...   print MyClass.myVersion
...
根据上面定义的类,让我们使用 dir()和特殊类属性__dict__来查看一下类的属性:
>>> dir(MyClass)
['__class__', '__delattr__', '__dict__', '__doc__',
'__getattribute__', '__hash__', '__init__', '__module__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__str__', '__weakref__', 'myVersion',
'showMyVersion']
>>> MyClass.__dict__
<dictproxy object at 0x62090>
>>> print MyClass.__dict__
{'showMyVersion': <function showMyVersion at 0x59370>,
'__dict__': <attribute '__dict__' of 'MyClass' objects>,
'myVersion': '1.1', '__weakref__': <attribute
'__weakref__' of 'MyClass' objects>, '__doc__':
'MyClass class definition'}
在新式类中,还新增加了一些属性,dir()也变得更健壮。作为比较,可以看下经典类是什么样
的:
>>> dir(MyClass)


['__doc__', '__module__', 'showMyVersion', 'myVersion']
>>>
>>> MyClass.__dict__
{'__doc__': None, 'myVersion': 1, 'showMyVersion':
<function showMyVersion at 950ed0>, '__module__':
'__main__'}
从上面可以看到,dir()返回的仅是对象的属性的一个名字列表,而__dict__返回的是一个字典,
它的键(keys)是属性名,键值(values)是相应的属性对象的数据值。
结果还显示了 MyClass 类中两个熟悉的属性,showMyVersion 和 myVersion,以及一些新的属
性。这些属性,__doc__及__module__,是所有类都具备的特殊类属性(另外还有__dict__)。。内建
的 vars()函数接受类对象作为参数,返回类的__dict__属性的内容。
13.4.3 特殊的类属性
对任何类C,表 13.1 显示了类C的所有特殊属性:
表 13.1 特殊类属性
C.__name__       类C的名字(字符串)
C.__doc__       类C的文档字符串
C.__bases__      类C的所有父类构成的元组
C.__dict__       类C的属性
C.__module__     类C定义所在的模块(1.5 版本新增)
C.__class__      实例C对应的类(仅新式类中)
根据上面定义的类 MyClass,有如下结果:
>>> MyClass.__name__
'MyClass'
>>> MyClass.__doc__
'MyClass class definition'
>>> MyClass.__bases__
(<type 'object'>,)
>>> print MyClass.__dict__
{'__doc__': None, 'myVersion': 1, 'showMyVersion':
<function showMyVersion at 950ed0>, '__module__': '__main__'}
>>> MyClass.__module__
'__main__'
>>> MyClass.__class__


<type 'type'>
__name__是给定类的字符名字。它适用于那种只需要字符串(类对象的名字),而非类对象本身
的情况。甚至一些内建的类型也有这个属性,我们将会用到其中之一来展示__name__字符串的益处。
类型对象是一个内建类型的例子,它有__name__的属性。回忆一下,type()返回被调用对象的
类型。这可能就是那种我们所说的仅需要一个字符串指明类型,而不需要一个对象的情况。我们能
可以使用类型对象的__name__属性来取得相应的字符串名。如下例示:
>>> stype = type('What is your quest?')
>>> stype # stype is a type object stype 是一个类型对象
<type 'string'>
>>> stype.__name__ # get type as a string 得到类型名(字符串表示)
'string'
>>>
>>> type(3.14159265) # also a type object 又一个类型对象
<type 'float'>
>>> type(3.14159265).__name__ # get type as a string 得到类型名(字符串表示)
'float'
__doc__是类的文档字符串,与函数及模块的文档字符串相似,必须紧随头行(header line)
后的字符串。文档字符串不能被派生类继承,也就是说派生类必须含有它们自己的文档字符串。
本章后面会讲到,__bases__用来处理继承,它包含了一个由所有父类组成的元组。
前述的__dict__属性包含一个字典,由类的数据属性组成。访问一个类属性的时候,Python 解
释器将会搜索字典以得到需要的属性。如果在__dict__中没有找到,将会在基类的字典中进行搜索,
采用“深度优先搜索”顺序。基类集的搜索是按顺序的,从左到右,按其在类定义时,定义父类参
数时的顺序。对类的修改会仅影响到此类的字典;基类的__dict__属性不会被改动的。
Python 支持模块间的类继承。为更清晰地对类进行描述,1。1,1.5 版本中引入了__module__,
这样类名就完全由模块名所限定。看一下下面的例子:
>>> class C(object):
... pass
...
>>> C
<class __main__.C at 0x53f90>
>>> C.__module__
'__main__'
类 C 的全名是“__main__.C”     ,比如,source_module.class_name。如果类 C 位于一个导入的


模块中,如 mymod,像下面的:
>>> from mymod import C
>>> C
<class mymod.C at 0x53ea0>
>>> C.__module__
'mymod'
在以前的版本中,没有特殊属性__module__,很难简单定位类的位置,因为类没有使用它们的
全名。
最后,由于类型和类的统一性,当访问任何类的__class__属性时,你将发现它就是一个类型对
象的实例。换句话说,一个类已是一种类型了。因为经典类并不认同这种等价性(一个经典类是一
个类对象,一个类型是一个类型对象),对这些对象来说,这个属性并未定义。
13.5 实例
如果说类是一种数据结构定义类型,那么实例则声明了一个这种类型的变量。换言之,实例是
有生命的类。就像设计完一张蓝图后,就是设法让它成为现实。实例是那些主要用在运行期时的对
象,类被实例化得到实例,该实例的类型就是这个被实例化的类。在 Python2.2 版本之前,实例是
“实例类型”,而不考虑它从哪个类而来。
13.5.1 初始化:通过调用类对象来创建实例
很多其它的 OO 语言都提供 new 关键字,通过 new 可以创建类的实例。Python 的方式更加简单。
一旦定义了一个类,创建实例比调用一个函数还容易------不费吹灰之力。实例化的实现,可以使
用函数操作符,如下示:
>>> class MyClass(object):   # define class 定义类
... pass
>>> mc = MyClass() # instantiate class 初始化类
可以看到,仅调用("calling")类:MyClass(),就创建了类 MyClass 的实例 mc。返回的对象是你
所调用类的一个实例。当使用函数记法来调用("call")一个类时,解释器就会实例化该对象,并且
调用 Python 所拥有与构造函数最相近的东西(如果你定义了的话)来执行最终的定制工作,比如设置
实例属性,最后将这个实例返回给你。
核心笔记:Python2.2 前后的类和实例
类和类型在 2.2 版本中就统一了,这使得 Python 的行为更像其它面向对象编程语言。任何类或


者类型的实例都是这种类型的对象。比如,如果你让 Python 告诉你,类 MyClass 的实例 mc 是否是
类 MyClass 的一个实例。回答是肯定的,Python 不会说谎。同样,它会告诉你零是 integer 类型的
一个实例:
>>> mc = MyClass()
>>> type(mc)
<class '__main__.MyClass'>
>>> type(0)
<type 'int'>
但如果你仔细看,比较 MyClass 和 int,你将会发现二者都是类型(type):
>>> type(MyClass)
<type 'type'>
>>> type(int)
<type 'type'>
对比一下,如果在 Python 早于 2.2 版本时,使用经典类,此时类是类对象,实例是实例对象。
在这两个对象类型之间没有任何关系,除了实例的__class__属性引用了被实例化以得到该实例的类。
把 MyClass 在 Python2.1 版本中作为经典类重新定义,并运行相同的调用(注意:int()那时还不具
备工厂功能...它还仅是一个通常的内建函数):
>>> type(mc)
<type 'instance'>
>>> type(0)
<type 'int'>
>>>
>>> type(MyClass)
<type 'class'>
>>> type(int)
<type 'builtin_function_or_method'>
为了避免任何混淆,你只要记住当你定义一个类时,你并没有创建一个新的类型,而是仅仅一
个类对象;而对 2.2 及后续版本,当你定义一个(新式的)类后,你已创建了一个新的类型。
13.5.2     __init__() "构造器"方法
当类被调用,实例化的第一步是创建实例对象。一旦对象创建了,Python 检查是否实现了
__init__()方法。默认情况下,如果没有定义(或覆盖)特殊方法__init__(),对实例不会施加任
何特别的操作.任何所需的特定操作,都需要程序员实现__init__(),覆盖它的默认行为。如果
__init__()没有实现,则返回它的对象,实例化过程完毕。
然而,如果__init__()已经被实现,那么它将被调用,实例对象作为第一个参数(self)被传递
进去,像标准方法调用一样。调用类时,传进的任何参数都交给了__init__()。实际中,你可以想
像成这样:把创建实例的调用当成是对构造器的调用。


总之,(a)你没有通过调用 new 来创建实例,你也没有定义一个构造器。是 Python 为你创建了
对象; (b) __init__(),是在解释器为你创建一个实例后调用的第一个方法,在你开始使用它之前,
这一步可以让你做些准备工作。
__init__()是很多为类定义的特殊方法之一。其中一些特殊方法是预定义的,缺省情况下,不
进行任何操作,比如__init__(),要定制,就必须对它进行重载,还有些方法,可能要按需要去实
现。本章中,我们会讲到很多这样的特殊方法。你将会经常看到__init__()的使用,在此,就不举
例说明了。
13.5.3    __new__() “构造器”方法
与__init__()相比,__new__()方法更像一个真正的构造器。类型和类在版本 2.2 就统一了,
Python 用户可以对内建类型进行派生,因此,需要一种途径来实例化不可变对象,比如,派生字符
串,数字,等等。
在这种情况下,解释器则调用类的__new__()方法,一个静态方法,并且传入的参数是在类实例
化操作时生成的。__new__()会调用父类的__new__()来创建对象(向上代理)。
为何我们认为__new__()比__init__()更像构造器呢?这是因为__new__()必须返回一个合法
的实例,这样解释器在调用__init__()时,就可以把这个实例作为 self 传给它。调用父类的__new__()
来创建对象,正像其它语言中使用 new 关键字一样。
__new__()和__init__()在类创建时,都传入了(相同)参数。13.11.3 节中有个例子使用了
__new__()。
13.5.4    __del__() "解构器"方法
同样,有一个相应的特殊解构器(destructor)方法名为__del__()。然而,由于 Python 具有
垃圾对象回收机制(靠引用计数),这个函数要直到该实例对象所有的引用都被清除掉后才会执行。
Python 中的解构器是在实例释放前提供特殊处理功能的方法,它们通常没有被实现,因为实例很少
被显式释放。
举例
在下面的例子中,我们分别创建(并覆盖)__init__()和__del__()构造及解构函数,然后,初
始化类并给同样的对象分配很多别名。id()内建函数可用来确定引用同一对象的三个别名。最后一
步是使用 del 语句清除所有的别名,显示何时,调用了多少次解构器。


class C(P): # class declaration 类声明
def __init__(self):    # "constructor" 构造器
print 'initialized'
def __del__(self): # "destructor" 解构器
P.__del__(self) # call parent destructor print 'deleted' 调用 父 类解构 器 来 打 印
'deleted'
>>> c1 = C()    # instantiation initialized 实例初始化
>>> c2 = c1 # create additional alias 创建另外一个别名
>>> c3 = c1 # create a third alias 创建第三个别名
>>> id(c1), id(c2), id(c3)    # all refer to same object 同一对象所有引用
(11938912, 11938912, 11938912)
>>> del c1 # remove one reference 清除一个引用
>>> del c2 # remove another reference 清除另一个引用
>>> del c3 # remove final reference deleted # destructor finally invoked 解构器最
后调用
注意,在上面的例子中,解构器是在类 C 实例所有的引用都被清除掉后,才被调用的,比如,
当引用计数已减少到 0。如果你预期你的__del__()方法会被调用,却实际上没有被调用,这意味着,
你的实例对象由于某些原因,其引用计数不为 0,这可能有别的对它的引用,而你并不知道这些让
你的对象还活着的引用所在。
另外,要注意,解构器只能被调用一次,一旦引用计数为 0,则对象就被清除了。这非常合理,
因为系统中任何对象都只被分配及解构一次。
总结:
z 不要忘记首先调用父类的__del__()。
z 调用 del x 不表示调用了 x.__del__() -----前面也看到,它仅仅是减少 x 的引用计数。
z 如果你有一个循环引用或其它的原因,让一个实例的引用逗留不去,该对象的__del__()可
能永远不会被执行。
z __del__()未捕获的异常会被忽略掉(因为一些在__del__()用到的变量或许已经被删除了)。
不要在__del__()中干与实例没任何关系的事情。
z 除非你知道你正在干什么,否则不要去实现__del__()。
z 如果你定义了__del__,并且实例是某个循环的一部分,垃圾回收器将不会终止这个循环—
—你需要自已显式调用 del。
核心笔记:跟踪实例
Python 没有提供任何内部机制来跟踪一个类有多少个实例被创建了,或者记录这些实例是些什
么东西。如果需要这些功能,你可以显式加入一些代码到类定义或者__init__()和__del__()中去。


最好的方式是使用一个静态成员来记录实例的个数。靠保存它们的引用来跟踪实例对象是很危险的,
因为你必须合理管理这些引用,不然,你的引用可能没办法释放(因为还有其它的引用)!看下面一
个例子:
class InstCt(object):
count = 0 # count is class attr count 是一个类属性
def __init__(self):   # increment count 增加 count
InstCt.count += 1
def __del__(self): # decrement count 减少 count
InstCt.count -= 1
def howMany(self): # return count 返回 count
return InstCt.count
>>> a = InstTrack()
>>> b = InstTrack()
>>> b.howMany()
2
>>> a.howMany()
2
>>> del b
>>> a.howMany()
1
>>> del a
>>> InstTrack.count
0
13.6 实例属性
实例仅拥有数据属性(方法严格来说是类属性)                         ,后者只是与某个类的实例相关联的数据值,并
且可以通过句点属性标识法来访问。这些值独立于其它实例或类。当一个实例被释放后,它的属性
同时也被清除了。
13.6.1     “实例化”实例属性(或创建一个更好的构造器)
设置实例的属性可以在实例创建后任意时间进行,也可以在能够访问实例的代码中进行。构造
器__init()__是设置这些属性的关键点之一。


核心笔记:实例属性
能够在“运行时”创建实例属性,是 Python 类的优秀特性之一,从 C++或 Java 转过来的人会被
小小的震惊一下,因为 C++或 Java 中所有属性在使用前都必须明确定义/声明。
Python 不仅是动态类型,而且在运行时,允许这些对象属性的动态创建。这种特性让人爱不释
手。当然,我们必须提醒读者,创建这样的属性时,必须谨慎。
一个缺陷是,属性在条件语句中创建,如果该条件语句块并未被执行,属性也就不存在,而你
在后面的代码中试着去访问这些属性,就会有错误发生。故事的精髓是告诉我们,Python 让你体验
从未用过的特性,但如果你使用它了,你还是要小心为好。
在构造器中首先设置实例属性
构造器是最早可以设置实例属性的地方,因为__init__()是实例创建后第一个被调用的方法。
再没有比这更早的可以设置实例属性的机会了。一旦__init__()执行完毕,返回实例对象,即完成
了实例化过程。
默认参数提供默认的实例安装
在实际应用中,带默认参数的__init__()提供一个有效的方式来初始化实例。在很多情况下,
默认值表示设置实例属性的最常见的情况,如果提供了默认值,我们就没必要显式给构造器传值了。
我们在 11.5.2 节中也提到默认参数的常见好处。需要明白一点,默认参数应当是不变的对象;像
列表(list)和字典(dictionary)这样的可变对象可以扮演静态数据,然后在每个方法调用中来维护
它们的内容。
例 13.1 描述了如何使用默认构造器行为来帮助我们计算在美国一些大都市中的旅馆中寄宿时,
租房总费用。
代码的主要目的是来帮助某人计算出每日旅馆租房费用,包括所有州销售税和房税。缺省为旧
金山附近的普通区域,它有 8.5%销售税及 10%的房间税。每日租房费用没有缺省值,因此在任何实
例被创建时,都需要这个参数。
例 13.1 使用缺省参数进行实例化
(hotel.py)
定义一个类来计算这个假想旅馆租房费用。__init__()构造器对一些实例属性进行初始化。
calcTotal()方法用来决定是计算每日总的租房费用还是计算所有天全部的租房费。
1 class HotelRoomCalc(object):
2 'Hotel room rate calculator'
3
4 def __init__(self, rt, sales=0.085, rm=0.1):


5 '''HotelRoomCalc default arguments:
6 sales tax == 8.5% and room tax == 10%'''
7 self.salesTax = sales
8 self.roomTax = rm
9 self.roomRate = rt
10
11 def calcTotal(self, days=1):
12 'Calculate total; default to daily rate'
13 daily = round((self.roomRate *14 (1 + self.roomTax + self.salesTax)), 2)
15 return float(days) * daily
设置工作是由__init__()在实例化之后完成的,如上第 4 到 8 行,其余部分的核心代码是
calcTotal()方法,从第 10 到 14 行。__init__()的工作即是设置一些参数值来决定旅馆总的基本租
房费用(不包括住房服务,电话费,或其它偶发事情)。calcTotal()可以计算每日所有费用,如果
提供了天数,那么将计算整个旅程全部的住宿费用。内建的 round()函数可以大约计算出最接近的费
用(两个小数位)。下面是这个类的用法:
>>> sfo = HotelRoomCalc(299) # new instance 新的实例
>>> sfo.calcTotal() # daily rate 日租金
354.32
>>> sfo.calcTotal(2) # 2-day rate 2天的租金
708.64
>>> sea = HotelRoomCalc(189, 0.086, 0.058) # new instance 新的实例
>>> sea.calcTotal()
216.22
>>> sea.calcTotal(4)
864.88
>>> wasWkDay = HotelRoomCalc(169, 0.045, 0.02) # new instance 新实例
>>> wasWkEnd = HotelRoomCalc(119, 0.045, 0.02) # new instance 新实例
>>> wasWkDay.calcTotal(5) + wasWkEnd.calcTotal() # 7-day rate 7 天的租金
1026.69
最开始的两个假想例子都是在旧金山(San Francisco), 使用了默认值,然后是在西雅图
(Seattle) , 这 里 我 们 提 供 了 不 同 的 销 售 税 和 房 间 税 率 。 最 后 一 个 例 子 在 华 盛 顿 特 区
(Washington.D.C)。经过计算更长的假想时间,来扩展通常的用法:停留五个工作日,外加一个周
六,此时有特价,假定是星期天出发回家。
不要忘记,函数所有的灵活性,比如默认参数,也可以应用到方法中去。在实例化时,可变长
度参数也是一个好的特性(当然,这要根据应用的需要)


__init__()应当返回 None
你也知道,采用函数操作符调用类对象会创建一个类实例,也就是说这样一种调用过程返回的
对象就是实例,下面示例可以看出:
>>> class MyClass(object):
... pass
>>> mc = MyClass()
>>> mc
<__main__.MyClass instance at 95d390>
如果定义了构造器,它不应当返回任何对象,因为实例对象是自动在实例化调用后返回的。相
应地,__init__()就不应当返回任何对象(应当为 None);否则,就可能出现冲突,因为只能返回实
例。试着返回非 None 的任何其它对象都会导致 TypeError 异常:
>>> class MyClass:
... def __init__(self):
... print 'initialized'
... return 1
...
>>> mc = MyClass()
initialized
Traceback (innermost last): File "<stdin>", line 1, in ?
mc = MyClass()
TypeError: __init__() should return None
13.6.2 查看实例属性
内建函数 dir()可以显示类属性,同样还可以打印所有实例属性:
>>> class C(object):
... pass
>>> c = C()
>>> c.foo = 'roger'
>>> c.bar = 'shrubber'
>>> dir(c)
['__class__', '__delattr__', '__dict__', '__doc__',
'__getattribute__', '__hash__', '__init__', '__module__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__str__', '__weakref__', 'bar', 'foo']
与类相似,实例也有一个__dict__特殊属性(可以调用 vars()并传入一个实例来获取),它是实
例属性构成的一个字典:


>>> c.__dict__
{'foo': 'roger', 'bar': 'shrubber'}
13.6.3 特殊的实例属性
实例仅有两个特殊属性(见表 13.2)。对于任意对象 I:
表 13.2 特殊实例属性
I.__class__      实例化 I 的类
I.__dict__       I 的属性
现在使用类 C 及其实例 C 来看看这些特殊实例属性:
>>> class C(object): # define class 定义类
... pass
...
>>> c = C() # create instance 创建实例
>>> dir(c)    # instance has no attributes 实例还没有属性
[]
>>> c.__dict__ # yep, definitely no attributes 也没有属性
{}
>>> c.__class__ # class that instantiated us 实例化 c 的类
<class '__main__.C'>
你可以看到,c 现在还没有数据属性,但我们可以添加一些再来检查__dict__属性,看是否添加
成功了:
>>> c.foo = 1
>>> c.bar = 'SPAM'
>>> '%d can of %s please' % (c.foo, c.bar)
'1 can of SPAM please'
>>> c.__dict__
{'foo': 1, 'bar': 'SPAM'}
__dict__属性由一个字典组成,包含一个实例的所有属性。键是属性名,值是属性相应的数据
值。字典中仅有实例属性,没有类属性或特殊属性。
核心风格:修改__dict__
对类和实例来说,尽管__dict__属性是可修改的,但还是建议你不要修改这些字典,除非你知
道你的目的。这些修改可能会破坏你的 OOP,造成不可预料的副作用。使用熟悉的句点属性标识来访


问及操作属性会更易于接受。需要你直接修改__dict__属性的情况很少,其中之一是你要重载
__setattr__特殊方法。实现__setattr__()本身是一个冒险的经历,满是圈套和陷阱,例如无穷递
归和破坏实例对象。这个故事还是留到下次说吧。
13.6.4 内建类型属性
内建类型也是类,它们有没有像类一样的属性呢?那实例有没有呢?对内建类型也可以使用
dir(),与任何其它对象一样,可以得到一个包含它属性名字的列表:
>>> x = 3+0.14j
>>> x.__class__
<type 'complex'>
>>> dir(x)
['__abs__', '__add__', '__class__', '__coerce__',
'__delattr__', '__div__', '__divmod__', '__doc__', '__eq__',
'__float__', '__floordiv__', '__ge__', '__getattribute__',
'__getnewargs__', '__gt__', '__hash__', '__init__',
'__int__', '__le__', '__long__', '__lt__', '__mod__',
'__mul__', '__ne__', '__neg__', '__new__', '__nonzero__',
'__pos__', '__pow__', '__radd__', '__rdiv__', '__rdivmod__',
'__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__',
'__rmod__', '__rmul__', '__rpow__', '__rsub__',
'__rtruediv__', '__setattr__', '__str__', '__sub__',
'__truediv__', 'conjugate', 'imag', 'real']
>>>
>>> [type(getattr(x, i)) for i in ('conjugate', 'imag',
'real')]
[<type 'builtin_function_or_method'>, <type 'float'>,
<type 'float'>]
既然我们知道了一个复数有什么样的属性,我们就可以访问它的数据属性,调用它的方法了:
>>> x.imag
2.0
>>> x.real
1.0
>>> x.conjugate()
(1-2j)
试着访问__dict__会失败,因为在内建类型中,不存在这个属性:
>>> x.__dict__


Traceback (innermost last): File "<stdin>", line 1, in ?
AttributeError: __dict__
13.6.5 实例属性 vs 类属性
我们已在 13.4.1 节中描述了类数据属性。这里简要提一下,类属性仅是与类相关的数据值,和
实例属性不同,类属性和实例无关。这些值像静态成员那样被引用,即使在多次实例化中调用类,
它们的值都保持不变。不管如何,静态成员不会因为实例而改变它们的值,除非实例中显式改变它
们的值。   (实例属性与类属性的比较,类似于自动变量和静态变量,但这只是笼统的类推。在你对自
动变量和静态变量还不是很熟的情况下,不要深究这些。
类和实例都是名字空间。类是类属性的名字空间,实例则是实例属性的。
关于类属性和实例属性,还有一些方面需要指出。你可采用类来访问类属性,如果实例没有同
名的属性的话,你也可以用实例来访问。
访问类属性
类属性可通过类或实例来访问。下面的示例中,类 C 在创建时,带一个 version 属性,这样通
过类对象来访问它是很自然的了,比如,C.version。当实例 c 被创建后,对实例 c 而言,访问
c.version 会失败,不过 Python 首先会在实例中搜索名字 version,然后是类,再就是继承树中的
基类。本例中,version 在类中被找到了:
>>> class C(object): # define class 定义类
...  version = 1.2 # static member 静态成员
...
>>> c = C() # instantiation 实例化
>>> C.version # access via class 通过类来访问
1.2
>>> c.version   # access via instance 通过实例来访问
1.2
>>> C.version += 0.1 # update (only) via class 通过类(只能这样)来更新
>>> C.version # class access 类访问
1.3
>>> c.version # instance access, which 实例访问它,其值已被改变
1.3  # also reflected change
然而,我们只有当使用类引用 version 时,才能更新它的值,像上面的 C.version 递增语句。
如 果 尝 试 在 实 例 中设定或更新类属性会创建一个实例属性 c.version,后者会阻止对类属性
C.versioin 的访问,因为第一个访问的就是 c.version,这样可以对实例有效地“遮蔽”类属性


C.version,直到 c.version 被清除掉。
从实例中访问类属性须谨慎
与通常 Python 变量一样,任何对实例属性的赋值都会创建一个实例属性(如果不存在的话)并
且对其赋值。如果类属性中存在同名的属性,有趣的副作用即产生。(经典类和新式类都存在)
>>> class Foo(object):
... x = 1.5
...
>>> foo = Foo()
>>> foo.x
1.5
>>> foo.x = 1.7 # try to update class attr 试着更新类属性
>>> foo.x # looks good so far... 现在看起来还不错
1.7
>>> Foo.x # nope, just created a new inst attr 呵呵,没有变,只是创建了一个新的实
例属性
1.5
在上面的代码片断中,创建了一个名为 version 的新实例属性,它覆盖了对类属性的引用。然
而,类属性本身并没有受到伤害,仍然存在于类域中,还可以通过类属性来访问它,如上例可以看
到的。好了,那么如果把这个新的 version 删除掉,会怎么样呢?为了找到结论,我们将使用 del
语句删除 c.version。
>>> del foo.x # delete instance attribute 删除实例属性
>>> foo.x # can now access class attr again 又可以访问到类属性
1.5
所以,给一个与类属性同名的实例属性赋值,我们会有效地“隐藏”类属性,但一旦我们删除
了这个实例属性,类属性又重见天日。现在再来试着更新类属性,但这次,我们只尝试一下“无辜”
的增量动作:
>>> foo.x += .2 # try to increment class attr 试着增加类属性
>>> foo.x
1.7
>>> Foo.x # nope, same thing 呵呵,照旧
1.5
还是没变。我们同样创建了一个新的实例属性,类属性原封不动。                      (深入理解 Python 相关知识:
属性已存于类字典[__dict__]中。通过赋值,其被加入到实例的__dict__中了。                        )赋值语句右边的表
达式计算出原类的变量,增加 0.2,并且把这个值赋给新创建的实例属性。注意下面是一个等价的赋


值方式,但它可能更加清楚些:
foo.x = Foo.x + 0.2
但...在类属性可变的情况下,一切都不同了:
>>> class Foo(object):
... x = {2003: 'poe2'}
...
>>> foo = Foo()
>>> foo.x
{2003: 'poe2'}
>>> foo.x[2004] = 'valid path'
>>> foo.x
{2003: 'poe2', 2004: 'valid path'}
>>> Foo.x # it works!!! 生效了
{2003: 'poe2', 2004: 'valid path'}
>>> del foo.x # no shadow so cannot delete 没有遮蔽所以不能删除掉
Traceback (most recent call last): File "<stdin>", line 1, in ?
del foo.x
AttributeError: x
>>>
类属性持久性
静态成员,如其名所言,任凭整个实例(及其属性)的如何进展,它都不理不采(因此独立于
实例)。同时,当一个实例在类属性被修改后才创建,那么更新的值就将生效。类属性的修改会影响
到所有的实例:
>>>  class C(object):
...   spam = 100 # class attribute 类属性
...
>>>  c1 = C()    # create an instance 创建一个实例
>>>  c1.spam # access class attr thru inst. 通过实例访问类属性
100
>>>  C.spam += 100 # update class attribute 更新类属性
>>>  C.spam # see change in attribute 查看属性值改变
200
>>>  c1.spam # confirm change in attribute 在实例中验证属性值改变
200
>>>  c2 = C()    # create another instance 创建另一个实例
>>>  c2.spam # verify class attribute 验证类属性


200
>>> del c1 # remove one instance 删除一个实例
>>> C.spam += 200 # update class attribute again 再次更新类属性
>>> c2.spam # verify that attribute changed 验证那个属性值改变
400
核心提示:使用类属性来修改自身(不是实例属性)
正如上面所看到的那样,使用实例属性来试着修改类属性是很危险的。原因在于实例拥有它们
自已的属性集,在 Python 中没有明确的方法来指示你想要修改同名的类属性,比如,没有 global
关键字可以用来在一个函数中设置一个全局变量(来代替同名的局部变量)。修改类属性需要使用类
名,而不是实例名。
13.7 从这里开始校对----------绑定和方法调用
现在我们需要再次阐述 Python 中绑定(binding)的概念,它主要与方法调用相关连。我们先
来回顾一下与方法相关的知识。首先,方法仅仅是类内部定义的函数。(这意味着方法是类属性而不
是实例属性)。
其次,方法只有在其所属的类拥有实例时,才能被调用。当存在一个实例时,方法才被认为是
绑定到那个实例了。没有实例时方法就是未绑定的。
最后,任何一个方法定义中的第一个参数都是变量 self,它表示调用此方法的实例对象。
核心笔记:self 是什么?
self 变量用于在类实例方法中引用方法所绑定的实例。因为方法的实例在任何方法调用中总是
作为第一个参数传递的,self 被选中用来代表实例。你必须在方法声明中放上 self(你可能已经注
意到了这点),但可以在方法中不使用实例(self)。如果你的方法中没有用到 self , 那么请考虑创建
一个常规函数,除非你有特别的原因。毕竟,你的方法代码没有使用实例,没有与类关联其功能,
这使得它看起来更像一个常规函数。在其它面向对象语言中,self 可能被称为 this。
13.7.1 调用绑定方法
方法,不管绑定与否,都是由相同的代码组成的。唯一的不同在于是否存在一个实例可以调用
此方法。在很多情况下,程序员调用的都是一个绑定的方法。假定现在有一个 MyClass 类和此类的
一个实例 mc,而你想调用 MyClass.foo()方法。因为已经有一个实例,你只需要调用 mc.foo()就可
以。记得 self 在每一个方法声明中都是作为第一个参数传递的。当你在实例中调用一个绑定的方法
时,self 不需要明确地传入了。这算是"必须声明 self 作为第一个参数"对你的报酬。当你还没有
一个实例并且需要调用一个非绑定方法的时候你必须传递 self 参数。


13.7.2 调用非绑定方法
调用非绑定方法并不经常用到。需要调用一个还没有任何实例的类中的方法的一个主要的场景
是:你在派生一个子类,而且你要覆盖父类的方法,这时你需要调用那个父类中想要覆盖掉的构造方
法。这里是一个本章前面介绍过的例子:
class EmplAddrBookEntry(AddrBookEntry):
'Employee Address Book Entry class' # 员工地址记录条目
def __init__(self, nm, ph, em):
AddrBookEntry.__init__(self, nm, ph)
self.empid = id
self.email = em
EmplAddrBookEntry 是 AddrBookEntry 的子类,我们重载了构造器__init__()。我们想尽可能多
地重用代码, 而不是去从父类构造器中剪切,粘贴代码。这样做还可以避免 BUG 传播,因为任何修
复都可以传递给子类。这正是我们想要的 --- 没有必要一行一行地复制代码。只需要能够调用父类
的构造器即可,但该怎么做呢?
我们在运行时没有 AddrBookEntry 的实例。那么我们有什么呢?我们有一个 EmplAddrBookEntry
的实例,它与 AddrBookEntry 是那样地相似,我们难道不能用它代替呢?当然可以!
当一个 EmplAddrBookEntry 被实例化,并且调用 __init__() 时,其与 AddrBookEntry 的实例
只有很少的差别,主要是因为我们还没有机会来自定义我们的 EmplAddrBookEntry 实例,以使它与
AddrBookEntry 不同。
这是调用非绑定方法的最佳地方了。我们将在子类构造器中调用父类的构造器并且明确地传递
(父类)构造器所需要的 self 参数(因为我们没有一个父类的实例)                    。子类中 __init__() 的第一
行就是对父类__init__()的调用。我们通过父类名来调用它,并且传递给它 self 和其他所需要的
参数。一旦调用返回,我们就能定义那些与父类不同的仅存在我们的(子)类中的(实例)定制。
13.8     静态方法和类方法
静态方法和类方法在 Python2.2 中引入。经典类及新式(new-style)类中都可以使用它。一对内
建函数被引入,用于将作为类定义的一部分的某一方法声明“标记”(tag),                        “强制类型转换”(cast)
或者“转换”(convert)为这两种类型的方法之一。
如果你有一定的 C++或者 Java 经验,静态方法和这些语言中的是一样的。它们仅是类中的函数(不


需要实例)。事实上,在静态方法加入到 Python 之前,用户只能在全局名字空间中创建函数,作为
这种特性的替代实现 - 有时在这样的函数中使用类对象来操作类(或者是类属性)。使用模块函数
比使用静态类方法更加常见。
回忆一下,通常的方法需要一个实例(self)作为第一个参数,并且对于(绑定的)方法调用来
说,self 是自动传递给这个方法的。而对于类方法而言,需要类而不是实例作为第一个参数,它是
由解释器传给方法。类不需要特别地命名, 类似 self,不过很多人使用 cls 作为变量名字。
13.8.1 staticmethod()和 classmethod()内建函数
现在让我们看一下在经典类中创建静态方法和类方法的一些例子(你也可以把它们用在新式类
中):
class TestStaticMethod:
def foo():
print 'calling static method foo()'
foo = staticmethod(foo)
class TestClassMethod:
def foo(cls):
print 'calling class method foo()'
print 'foo() is part of class:', cls.__name__
foo = classmethod(foo)
对应的内建函数被转换成它们相应的类型,并且重新赋值给了相同的变量名。如果没有调用这
两个函数,二者都会在 Python 编译器中产生错误,显示需要带 self 的常规方法声明。现在, 我们
可以通过类或者实例调用这些函数....这没什么不同:
>>> tsm = TestStaticMethod()
>>> TestStaticMethod.foo()
calling static method foo()
>>> tsm.foo()
calling static method foo()
>>>
>>> tcm = TestClassMethod()
>>> TestClassMethod.foo()
calling class method foo()
foo() is part of class: TestClassMethod
>>> tcm.foo()


calling class method foo()
foo() is part of class: TestClassMethod
13.8.2 使用函数修饰符
现在,看到像 foo=staticmethod(foo)这样的代码会刺激一些程序员。很多人对这样一个没意义
的语法感到心烦,即使 van Rossum 曾指出过,它只是临时的,有待社区对些语义进行处理。在第 11
章“函数”的 11.3.6 节中,我们了解了函数修饰符,一种在 Python2.4 中加入的新特征。你可以用
它把一个函数应用到另个函数对象上, 而且新函数对象依然绑定在原来的变量。我们正是需要它来
整理语法。通过使用 decorators,我们可以避免像上面那样的重新赋值:
class TestStaticMethod:
@staticmethod
def foo():
print 'calling static method foo()'
class TestClassMethod:
@classmethod
def foo(cls):
print 'calling class method foo()'
print 'foo() is part of class:', cls.__name__
13.9 组合
一个类被定义后,目标就是要把它当成一个模块来使用,并把这些对象嵌入到你的代码中去,
同其它数据类型及逻辑执行流混合使用。有两种方法可以在你的代码中利用类。第一种是组合
(composition)。就是让不同的类混合并加入到其它类中,来增加功能和代码重用性。你可以在一个
大点的类中创建你自已的类的实例,实现一些其它属性和方法来增强对原来的类对象。另一种方法
是通过派生,我们将在下一节中讨论它.
举例来说,让我们想象一个对本章一开始创建的地址本类的加强性设计。如果在设计的过程中,
为 names,addresses 等等创建了单独的类。那么最后我们可能想把这些工作集成到 AddrBookEntry
类中去,而不是重新设计每一个需要的类。这样就节省了时间和精力,而且最后的结果是容易维护
的代码 --- 一块代码中的 bugs 被修正,将反映到整个应用中。
这样的类可能包含一个 Name 实例,以及其它的像 StreetAddress, Phone ( home, work,
telefacsimile, pager, mobile, 等等),Email (home, work, 等等。),还可能需要一些 Date 实
例(birthday,wedding,anniversary,等等)。下面是一个简单的例子:


class NewAddrBookEntry(object): # class definition 类定义
'new address book entry class'
def __init__(self, nm, ph): # define constructor 定义构造器
self.name = Name(nm) # create Name instance 创建 Name 实例
self.phone = Phone(ph) # create Phone instance 创建 Phone 实例
print 'Created instance for:', self.name
NewAddrBookEntry 类由它自身和其它类组合而成。这就在一个类和其它组成类之间定义了一种
“has-a / 有一个”的关系。比如,我们的 NewAddrBookEntry 类“有一个” Name 类实例和一个 Phone
实例。
创建复合对象就可以实现这些附加的功能,并且很有意义,因为这些类都不相同。每一个类管
理它们自己的名字空间和行为。不过当对象之间有更接近的关系时,派生的概念可能对你的应用程
序来说更有意义,特别是当你需要一些相似的对象,但却有少许不同功能的时候。
13.10     子类和派生
当类之间有显著的不同,并且(较小的类)是较大的类所需要的组件时,组合表现得很好,但当
你设计“相同的类但有一些不同的功能”时,派生就是一个更加合理的选择了。
OOP 的更强大方面之一是能够使用一个已经定义好的类,扩展它或者对其进行修改,而不会影响
系统中使用现存类的其它代码片段。OOD 允许类特征在子孙类或子类中进行继承。这些子类从基类(或
称祖先类,超类)继承它们的核心属性。而且,这些派生可能会扩展到多代。在一个层次的派生关
系中的相关类(或者是在类树图中垂直相邻)是父类和子类关系。从同一个父类派生出来的这些类
(或者是在类树图中水平相邻)是同胞关系。父类和所有高层类都被认为是祖先。
使用前一节中的例子,如果我们必须创建不同类型的地址本。即,不仅仅是创建地址本的多个
实例,在这种情况下,所有对象几乎是相同的。如果我们希望 EmplAddrBookEntry 类中包含更多与
工作有关的属性,如员工 ID 和 e-mail 地址?这跟 PersonalAddrBookEntry 类不同,它包含更多基
于家庭的信息,比如家庭地址,关系,生日等等。
两种情况下,我们都不想到从头开始设计这些类,因为这样做会重复创建通用的 AddressBook
类时的操作。包含 AddressBook 类所有的特征和特性并加入需要的定制特性不是很好吗?这就是类
派生的动机和要求。
13.10.1      创建子类


创建子类的语法看起来与普通(新式)类没有区别,一个类名,后跟一个或多个需要从其中派生
的父类:
class SubClassName (ParentClass1[, ParentClass2, ...]):
'optional class documentation string'
class_suite
如果你的类没有从任何祖先类派生,可以使用 object 作为父类的名字。经典类的声明唯一不同
之处在于其没有从祖先类派生---此时,没有圆括号:
class ClassicClassWithoutSuperclasses:
pass
至此,我们已经看到了一些类和子类的例子,下面还有一个简单的例子:
class Parent(object): # define parent class 定义父类
def parentMethod(self):
print 'calling parent method'
class Child(Parent): # define child class 定义子类
def childMethod(self):
print 'calling child method'
>>> p = Parent() # instance of parent 父类的实例
>>> p.parentMethod()
calling parent method
>>>
>>> c = Child() # instance of child 子类的实例
>>> c.childMethod()    # child calls its method    子类调用它的方法
calling child method
>>> c.parentMethod() # calls parent's method      调用父类的方法
calling parent method
13.11 继承
继承描述了基类的属性如何“遗传”给派生类。一个子类可以继承它的基类的任何属性,不管
是数据属性还是方法。
举个例子如下。P 是一个没有属性的简单类。C 从 P 继承而来(因此是它的子类),也没有属性:
class P(object): # parent class 父类
pass
class C(P): # child class 子类


pass
>>> c = C() # instantiate child 实例化子类
>>> c.__class__ # child "is a" parent 子类“是一个”父类
<class '__main__.C'>
>>> C.__bases__ # child's parent class(es) 子类的父类
(<class '__main__.P'>,)
因为 P 没有属性,C 没有继承到什么。下面我们给 P 添加一些属性:
class P: # parent class 父类
'P class'
def __init__(self):
print 'created an instance of', \
self.__class__.__name__
class C(P): # child class 子类
pass
现在所创建的 P 有文档字符串(__doc__)和构造器,当我们实例化 P 时它被执行,如下面的
交互会话所示:
>>> p = P() # parent instance 父类实例
created an instance of P
>>> p.__class__ # class that created us 显示 p 所属的类名
<class '__main__.P'>
>>> P.__bases__ # parent's parent class(es) 父类的父类
(<type 'object'>,)
>>> P.__doc__ # parent's doc string 父类的文档字符串
'P class'
“created an instance”是由__init__()直接输出的。我们也可显示更多关于父类的信息。我
们现在来实例化 C,展示 __init__()(构造)方法在执行过程中是如何继承的:
>>> c = C() # child instance 子类实例
created an instance of C
>>> c.__class__ # class that created us 显示 c 所属的类名
<class '__main__.C'>
>>> C.__bases__ # child's parent class(es) 子类的父类
(<class '__main__.P'>,)
>>> C.__doc__ # child's doc string 子类的文档字符串
>>>


C 没有声明__init__()方法,然而在类 C 的实例 c 被创建时,还是会有输出信息。原因在于 C 继
承了 P 的__init__()。__bases__元组列出了其父类 P。需要注意的是文档字符串对类,函数/方法,
还有模块来说都是唯一的,所以特殊属性__doc__不会从基类中继承过来。
13.11.1     __bases__类属性
在第 13.4.4 节中,我们概要地介绍了__bases__类属性,对任何(子)类,它是一个包含其父类
(parent)的集合的元组。注意,我们明确指出“父类”是相对所有基类(它包括了所有祖先类)
而言的。那些没有父类的类,它们的__bases__属性为空。下面我们看一下如何使用__bases__的。
>>> class A(object): pass # define class A 定义类 A
...
>>> class B(A): pass # subclass of A A 的子类
...
>>> class C(B): pass # subclass of B (and indirectly, A) B 的子类(A 的间接子类)
...
>>> class D(A, B): pass # subclass of A and B A,B 的子类
...
>>> A.__bases__
(<type 'object'>,)
>>> C.__bases__
(<class __main__.B at 8120c90>,)
>>> D.__bases__
(<class __main__.A at 811fc90>, <class __main__.B at 8120c90>)
在上面的例子中,尽管 C 是 A 和 B 的子类(通过 B 传递继承关系),但 C 的父类是 B,这从它的
声明中可以看出,所以,只有 B 会在 C.__bases__中显示出来。另一方面,D 是从两个类 A 和 B 中继
承而来的。(多重继承参见 13.11.4)
13.11.2     通过继承覆盖(Overriding)方法
我们在 P 中再写一个函数,然后在其子类中对它进行覆盖。
class P(object):
def foo(self):
print 'Hi, I am P-foo()'
>>> p = P()


>>> p.foo()
Hi, I am P-foo()
现在来创建子类 C,从父类 P 派生:
class C(P):
def foo(self):
print 'Hi, I am C-foo()'
>>> c = C()
>>> c.foo()
Hi, I am C-foo()
尽管 C 继承了 P 的 foo()方法,但因为 C 定义了它自已的 foo()方法,所以 P 中的 foo() 方法
被覆盖。覆盖方法的原因之一是,你的子类可能需要这个方法具有特定或不同的功能。所以,你接
下来的问题肯定是:“我还能否调用那个被我覆盖的基类方法呢?”
答案是肯定的,但是这时就需要你去调用一个未绑定的基类方法,明确给出子类的实例,例如
下边:
>>> P.foo(c)
Hi, I am P-foo()
注意,我们上面已经有了一个 P 的实例 p,但上面的这个例子并没有用它。我们不需要 P 的实
例调用 P 的方法,因为已经有一个 P 的子类的实例 c 可用。典型情况下,你不会以这种方式调用父类
方法,你会在子类的重写方法里显式地调用基类方法。
class C(P):
def foo(self):
P.foo(self)
print 'Hi, I am C-foo()'
注意,在这个(未绑定)方法调用中我们显式地传递了 self. 一个更好的办法是使用 super()
内建方法:
class C(P):
def foo(self):
super(C, self).foo()
print 'Hi, I am C-foo()'
super()不但能找到基类方法,而且还为我们传进 self,这样我们就不需要做这些事了。现在我
们只要调用子类的方法,它会帮你完成一切:


>>> c = C()
>>> c.foo()
Hi, I am P-foo() Hi, I am C-foo()
核心笔记:重写__init__不会自动调用基类的__init__
类似于上面的覆盖非特殊方法,当从一个带构造器 __init()__的类派生,如果你不去覆盖
__init__(),它将会被继承并自动调用。但如果你在子类中覆盖了__init__(),子类被实例化时,
基类的__init__()就不会被自动调用。这可能会让了解 JAVA 的朋友感到吃惊。
class P(object):
def __init__(self):
print "calling P's constructor"
class C(P):
def __init__(self):
print "calling C's constructor"
>>> c = C()
calling C's constructor
如果你还想调用基类的 __init__(),你需要像上边我们刚说的那样,明确指出,使用一个子
类的实例去调用基类(未绑定)方法。相应地更新类 C,会出现下面预期的执行结果:
class C(P):
def __init__(self):
P.__init__(self)
print "calling C's constructor"
>>> c = C()
calling P's constructor
calling C's constructor
上边的例子中,子类的__init__()方法首先调用了基类的的__init__()方法。这是相当普遍(不
是强制)的做法,用来设置初始化基类,然后可以执行子类内部的设置。这个规则之所以有意义的
原因是,你希望被继承的类的对象在子类构造器运行前能够很好地被初始化或作好准备工作,因为它
(子类)可能需要或设置继承属性。
对 C++熟悉的朋友,可能会在派生类构造器声明时,通过在声明后面加上冒号和所要调用的所有
基类构造器这种形式来调用基类构造器。而在 JAVA 中,不管程序员如何处理,子类构造器都会去调
用基类的的构造器。
Python 使用基类名来调用类方法,对应在 JAVA 中,是用关键字 super 来实现的,这就是 super()
内建函数引入到 Python 中的原因,这样你就可以“依葫芦画瓢”了:
class C(P):


def __init__(self):
super(C, self).__init__()
print "calling C's constructor"
使用 super()的漂亮之处在于,你不需要明确给出任何基类名字...“跑腿事儿”,它帮你干了!
使用 super()的重点,是你不需要明确提供父类。这意味着如果你改变了类继承关系,你只需要改一
行代码(class 语句本身)而不必在大量代码中去查找所有被修改的那个类的名字。
13.11.3 从标准类型派生
经典类中,一个最大的问题是,不能对标准类型进行子类化。幸运的是,在 2.2 以后的版本中,
随着类型(types)和类(class)的统一和新式类的引入, 这一点已经被修正。下面,介绍两个子
类化 Python 类型的相关例子,其中一个是可变类型,另一个是不可变类型。
不可变类型的例子
假定你想在金融应用中,应用一个处理浮点数的子类。每次你得到一个贷币值(浮点数给出的),
你都需要通过四舍五入,变为带两位小数位的数值。(当然,Decimal 类比起标准浮点类型来说是个
用来精确保存浮点值的更佳方案,但你还是需要[有时候]对其进行舍入操作!)你的类开始可以
这样写:
class RoundFloat(float):
def __new__(cls, val):
return float.__new__(cls, round(val, 2))
我们覆盖了__new__()特殊方法来定制我们的对象,使之和标准 Python 浮点数(float)有一些
区别:我们使用 round()内建函数对原浮点数进行舍入操作,然后实例化我们的 float,RoundFloat。
我们是通过调用父类的构造器来创建真实的对象的,float.__new__()。注意,所有的__new()__方
法都是类方法,我们要显式传入类传为第一个参数,这类似于常见的方法如__init__()中需要的 self。
现在的例子还非常简单,比如,我们知道有一个 float,我们仅仅是从一种类型中派生而来等等.
通常情况下,最好是使用 super()内建函数去捕获对应的父类以调用它的__new()__方法,下面,对
它进行这方面的修改:
class RoundFloat(float):
def __new__(cls, val):
return super(RoundFloat, cls).__new__(cls, round(val, 2))
这个例子还远不够完整,所以,请留意本章我们将使它有更好的表现。下面是一些样例输出:


>>> RoundFloat(1.5955)
1.6
>>> RoundFloat(1.5945)
1.59
>>> RoundFloat(-1.9955)
-2.0
可变类型的例子
子类化一个可变类型与此类似,你可能不需要使用__new__() (或甚至__init__())                            ,因为通常
设置不多。一般情况下,你所继承到的类型的默认行为就是你想要的。下例中,我们简单地创建一
个新的字典类型,它的 keys()方法会自动排序结果:
class SortedKeyDict(dict):
def keys(self):
return sorted(super( SortedKeyDict, self).keys())
回忆一下,字典(dictionary)可以由 dict(),dict(mapping),dict(sequence_of_2_tuples),
或者 dict(**kwargs)来创建,看看下面使用新类的例子:
d = SortedKeyDict((('zheng-cai', 67), ('hui-jun', 68),('xin-yi', 2)))
print 'By iterator:'.ljust(12), [key for key in d]
print 'By keys():'.ljust(12), d.keys()
把上面的代码全部加到一个脚本中,然后运行,可以得到下面的输出:
By iterator: ['zheng-cai', 'xin-yi', 'hui-jun']
By keys(): ['xin-yi', 'hui-jun', 'zheng-cai']
在上例中,通过 keys 迭代过程是以散列顺序的形式,而使用我们(重写的)keys()方法则将
keys 变为字母排序方式了。
一定要谨慎,而且要意识到你正在干什么。如果你说,                          “你的方法调用 super()过于复杂”,取而
代之的是,你更喜欢 keys()简简单单(也容易理解)....,像这样:
def keys(self):
return sorted(self.keys())
这是本章后面的练习 13-19。


13.11.4 多重继承
同 C++一样,Python 允许子类继承多个基类。这种特性就是通常所说的多重继承。概念容易,
但最难的工作是,如何正确找到没有在当前(子)类定义的属性。当使用多重继承时,有两个不同
的方面要记住。首先,还是要找到合适的属性。另一个就是当你重写方法时,如何调用对应父类方
法以“发挥他们的作用”,同时,在子类中处理好自己的义务。我们将讨论两个方面,但侧重后者,
讨论方法解析顺序。
方法解释顺序(MRO)
在 Python 2.2 以前的版本中,算法非常简单:深度优先,从左至右进行搜索,取得在子类中使
用的属性。其它 Python 算法只是覆盖被找到的名字,多重继承则取找到的第一个名字。
由于类,类型和内建类型的子类,都经过全新改造, 有了新的结构,这种算法不再可行. 这样
一种新的 MRO 算法被开发出来,在 2.2 版本中初次登场,是一个好的尝试,但有一个缺陷(看下面
的核心笔记)。这在 2.3 版本中立即被修改,也就是今天还在使用的版本。
精确顺序解释很复杂,超出了本文的范畴,但你可以去阅读本节后面的参考书目提到的有关内
容。这里提一下,新的查询方法是采用广度优先,而不是深度优先。
核心笔记:Python 2.2 使用一种唯一但不完善的 MRO
Python 2.2 是首个使用新式 MRO 的版本,它必须取代经典类中的算法,原因在上面已谈到过。
在 2.2 版本中,算法基本思想是根据每个祖先类的继承结构,编译出一张列表,包括搜索到的类,
按策略删除重复的。然而,在 Python 核心开发人员邮件列表中,有人指出,在维护单调性方面失败
过(顺序保存),必须使用新的 C3 算法替换,也就是从 2.3 版开始使用的新算法。
下面的示例,展示经典类和新式类中,方法解释顺序有什么不同。
简单属性查找示例
下面这个例子将对两种类的方案不同处做一展示。脚本由一组父类,一组子类,还有一个子孙
类组成。
class P1: #(object): # parent class 1 父类 1
def foo(self):
print 'called P1-foo()'
class P2: #(object):   # parent class 2 父类 2
def foo(self):


print 'called P2-foo()'
def bar(self):
print 'called P2-bar()'
class C1(P1, P2): # child 1 der. from P1, P2 #子类 1,从 P1,P2 派生
pass
class C2(P1, P2): # child 2 der. from P1, P2 #子类 2,从 P1,P2 派生
def bar(self):
print 'called C2-bar()'
class GC(C1, C2): # define grandchild class #定义子孙类
pass # derived from C1 and C2          #从 C1,C2 派生
图 13-2    父类,子类及子孙类的关系图,还有它们各自定义的方法
在图 13-2 中,  我们看到父类,子类及子孙类的关系。P1 中定义了 foo(),                P2 定义了 foo()和 bar(),
C2 定义了 bar()。下面举例说明一下经典类和新式类的行为。
经典类
首先来使用经典类。通过在交互式解释器中执行上面的声明,我们可以验证经典类使用的解释
顺序,深度优先,从左至右:
>>> gc = GC()
>>> gc.foo()    # GC ==> C1 ==> P1
called P1-foo()
>>> gc.bar()    # GC ==> C1 ==> P1 ==> P2
called P2-bar()
当调用 foo()时,它首先在当前类(GC)中查找。如果没找到,就向上查找最亲的父类,C1。查找
未遂,就继续沿树上访到父类 P1,foo()被找到。


同样,对 bar()来说,它通过搜索 GC,C1,P1 然后在 P2 中找到。因为使用这种解释顺序的缘故,
C2.bar()根本就不会被搜索了。
现在,你可能在想,        “我更愿意调用 C2 的 bar()方法,因为它在继承树上和我更亲近些,这样才
会更合适。”在这种情况下,你当然还可以使用它,但你必须调用它的合法的全名,采用典型的非绑
定方式去调用,并且提供一个合法的实例:
>>> C2.bar(gc)
called C2-bar()
新式类
取消类 P1 和类 P2 声明中的对(object)的注释,重新执行一下。新式方法的查询有一些不同:
>>> gc = GC()
>>> gc.foo()    # GC ==> C1 ==> C2 ==> P1
called P1-foo()
>>> gc.bar() # GC ==> C1 ==> C2
called C2-bar()
与沿着继承树一步一步上溯不同,它首先查找同胞兄弟,采用一种广度优先的方式。当查找
foo(),它检查 GC,然后是 C1 和 C2,然后在 P1 中找到。如果 P1 中没有,查找将会到达 P2。foo()
的底线是,包括经典类和新式类都会在 P1 中找到它,然而它们虽然是同归,但殊途!
然而,bar()的结果是不同的。它搜索 GC 和 C1,紧接着在 C2 中找到了。这样,就不会再继续搜
索到祖父 P1 和 P2。这种情况下,新的解释方式更适合那种要求查找 GC 更亲近的 bar()的方案。当
然,如果你还需要调用上一级,只要按前述方法,使用非绑定的方式去做,即可。
>>> P2.bar(gc)
called P2-bar()
新式类也有一个__mro__属性,告诉你查找顺序是怎样的:
>>> GC.__mro__
(<class '__main__.GC'>, <class '__main__.C1'>, <class
'__main__.C2'>, <class '__main__.P1'>, <class
'__main__.P2'>, <type 'object'>)
菱形效应为难 MRO


经典类方法解释不会带来很多问题。它很容易解释,并理解。大部分类都是单继承的,多重继
承只限用在对两个完全不相关的类进行联合。这就是术语 mixin 类(或者“mix-ins”)的由来。
为什么经典类 MRO 会失败
在版本 2.2 中,类型与类的统一,带来了一个新的“问题”,波及所有从 object(所有类型的祖
先类)派生出来的(根)类,一个简单的继承结构变成了一个菱形。从 Guido van Rossum 的文章
中得到下面的灵感,打个比方,你有经典类 B 和 C,C 覆盖了构造器,B 没有,D 从 B 和 C 继承而来:
class B:
pass
class C:
def __init__(self):
print "the default constructor"
class D(B, C):
pass
当我们实例化 D,得到:
>>> d = D()
the default constructor
图 13.3 为 B,C 和 D 的类继承结构,现在把代码改为采用新式类的方式,问题也就产生了:
class B(object):
pass
class C(object):
def __init__(self):
print "the default constructor"


图 13.3 继承的问题是由于在新式类中,需要出现基类,这样就在继承结构中,形成了一个
菱形。D 的实例上溯时,不应当错过 C,但不能两次上溯到 A(因为 B 和 C 都从 A 派生)。去读读 Guido
van Rossum 的文章中有关"协作方法"的部分,可以得到更深地理解。
代码中仅仅是在两个类声明中加入了(object),对吗?没错,但从图中,你可以看出,继承结
构已变成了一个菱形;真正的问题就存在于 MRO 了。如果我们使用经典类的 MRO,当实例化 D 时,不
再得到 C.__init__()之结果.....而是得到 object.__init__()!这就是为什么 MRO 需要修改的真正
原因。
尽管我们看到了,在上面的例子中,类 GC 的属性查找路径被改变了,但你不需要担心会有大量
的代码崩溃。经典类将沿用老式 MRO,而新式类将使用它自己的 MRO。还有,如果你不需要用到新
式类中的所有特性,可以继续使用经典类进行开发,不会有问题的。
总结
经典类,使用深度优先算法。因为新式类继承自 object,新的菱形类继承结构出现,问题也就
接着而来了,所以必须新建一个 MRO。
你可以在下面的链接中读在更多有关新式类、MRO 的文章:
Guido van Rossum 的有关类型和类统一的文章:
http://www.python.org/download/releases/2.2.3/descrintro
PEP 252:使类型看起来更像类
http://www.python.org/doc/peps/pep-0252
“Python 2.2 新亮点” 文档
http://www.python.org/doc/2.2.3/whatsnew
论文:Python 2.3 方法解释顺序
http://python.org/download/releases/2.3/mro/


13.12     类、实例和其他对象的内建函数
13.12.1 issubclass()
issubclass() 布尔函数判断一个类是另一个类的子类或子孙类。它有如下语法:
issubclass(sub, sup)
issubclass() 返回 True 的情况:    给出的子类 sub 确实是父类 sup 的一个子类        (反之,则为 False)。
这个函数也允许“不严格”的子类,意味着,一个类可视为其自身的子类,所以,这个函数如果当
sub 就是 sup,或者从 sup 派生而来,则返回 True。(一个“严格的”子类是严格意义上的从一个类
派生而来的子类。)
从 Python 2.3 开始,issubclass()的第二个参数可以是可能的父类组成的 tuple(元组),这时,
只要第一个参数是给定元组中任何一个候选类的子类时,就会返回 True。
13.12.2     isinstance()
isinstance() 布尔函数在判定一个对象是否是另一个给定类的实例时,非常有用。它有如下
语法:
isinstance(obj1, obj2)
isinstance()在 obj1 是类 obj2 的一个实例,或者是 obj2 的子类的一个实例时,返回 True
(反之,则为 False),看下面的例子:
>>> class C1(object): pass
...
>>> class C2(object): pass
...
>>> c1 = C1()
>>> c2 = C2()
>>> isinstance(c1, C1) True
>>> isinstance(c2, C1) False
>>> isinstance(c1, C2) False
>>> isinstance(c2, C2) True
>>> isinstance(C2, c2) Traceback (innermost last):


File "<stdin>", line 1, in ?
isinstance(C2, c2)
TypeError: second argument must be a class
注意:第二个参数应当是类;不然,你会得到一个 TypeError。但如果第二个参数是一个类型对
象,则不会出现异常。这是允许的,因为你也可以使用 isinstance()来检查一个对象 obj1 是否是
obj2 的类型,比如:
>>> isinstance(4, int)
True
>>> isinstance(4, str)
False
>>> isinstance('4', str)
True
如果你对 Java 有一定的了解,那么你可能知道 Java 中有个等价函数叫 instanceof(),但由于
性能上的原因,instanceof()并不被推荐使用。调用 Python 的 isinstance()不会有性能上的问题,
主要是因为它只用来来快速搜索类族集成结构,以确定调用者是哪个类的实例,还有更重要的是,
它是用 C 写的!
同 issubclass()一样,isinstance()也可以使用一个元组(tuple)作为第二个参数。这个特
性是从 Python 2.2 版本中引进的。如果第一个参数是第二个参数中给定元组的任何一个候选类型
或类的实例时,就会返回 True。你还可以在 595 页,第 13.16.1 节中了解到更多有 isinstance()的
内容。
13.12.3     hasattr(), getattr(),setattr(), delattr()
*attr()系列函数可以在各种对象下工作,不限于类(class)和实例(instances)。然而,因
为在类和实例中使用极其频繁,就在这里列出来了。需要说明的是,当使用这些函数时,你传入你
正在处理的对象作为第一个参数,但属性名,也就是这些函数的第二个参数,是这些属性的字符串
名字。换句话说,在操作 obj.attr 时,就相当于调用*attr(obj,'attr'....)系列函数------下面
的例子讲得很清楚。
hasattr()函数是 Boolean 型的,它的目的就是为了决定一个对象是否有一个特定的属性,一
般用于访问某属性前先作一下检查。getattr()和 setattr()函数相应地取得和赋值给对象的属性,
getattr()会在你试图读取一个不存在的属性时,引发 AttributeError 异常,除非给出那个可选的
默认参数。setattr()将要么加入一个新的属性,要么取代一个已存在的属性。而 delattr()函数会
从一个对象中删除属性。
Here are some examples using all the *attr() BIFs:


下面一些例子使用到了*attr()系列函数:
>>> class myClass(object):
... def __init__(self):
...     self.foo = 100
...
>>> myInst = myClass()
>>> hasattr(myInst, 'foo')
True
>>> getattr(myInst, 'foo')
100
>>> hasattr(myInst, 'bar') False
>>> getattr(myInst, 'bar') Traceback (most recent call last):
File "<stdin>", line 1, in ?
getattr(myInst, 'bar')
AttributeError: myClass instance has no attribute 'bar'
>>> getattr(c, 'bar', 'oops!')
'oops!'
>>> setattr(myInst, 'bar', 'my attr')
>>> dir(myInst)
['__doc__', '__module__', 'bar', 'foo']
>>> getattr(myInst, 'bar') # same as myInst.bar #等同于 myInst.bar
'my attr'
>>> delattr(myInst, 'foo')
>>> dir(myInst)
['__doc__', '__module__', 'bar']
>>> hasattr(myInst, 'foo')
False
13.12.4     dir()
前面用到 dir()是在练习 2-12,2-13 和 4-7。在这些练习中,我们用 dir()列出一个模块所有属
性的信息。现在你应该知道 dir()还可以用在对象上。
在 Python 2.2 中, dir()得到了重要的更新。因为这些改变,那些 __members__和__methods__
数据属性已经被宣告即将不支持。dir()提供的信息比以前更加详尽。根据文档,“除了实例变量名
和常用方法外,它还显示那些通过特殊标记来调用的方法,像__iadd__(+=),__len__(len()),
__ne__(!=)。” 在 Python 文档中有详细说明。


z   dir()作用在实例上(经典类或新式类)时,显示实例变量,还有在实例所在的类及所有它
的基类中定义的方法和类属性。
z   dir()作用在类上(经典类或新式类)时,则显示类以及它的所有基类的__dict__中的内容。
但它不会显示定义在元类(metaclass)中的类属性。
z   dir()作用在模块上时,则显示模块的__dict__的内容。(这没改动)。
z   dir()不带参数时,则显示调用者的局部变量。(也没改动)。
z   关于更多细节:对于那些覆盖了__dict__或__class__属性的对象,就使用它们;出于向后兼
容的考虑,如果已定义了__members__和__methods__,则使用它们。
13.12.5     super()
super()函数在 Python2.2 版本新式类中引入。这个函数的目的就是帮助程序员找出相应的父类,
然后方便调用相关的属性。一般情况下,程序员可能仅仅采用非绑定方式调用祖先类方法。使用
super()可以简化搜索一个合适祖先的任务,并且在调用它时,替你传入实例或类型对象。
在第 13.11.4 节中,我们描述了文档解释顺序(MRO),用于在祖先类中查找属性。对于每个定
义的类,都有一个名为__mro__的属性,它是一个元组,按照他们被搜索时的顺序,列出了备搜索
的类。语法如下:
super(type[, obj])
给出 type,super()“返回此 type 的父类”          。如果你希望父类被绑定,你可以传入 obj 参数(obj
必须是 type 类型的).否则父类不会被绑定。obj 参数也可以是一个类型,但它应当是 type 的一个子
类。通常,当给出 obj 时:
z   如果 obj 是一个实例,isinstance(obj,type)就必须返回 True
z   如果 obj 是一个类或类型,issubclass(obj,type)就必须返回 True
事实上,super()是一个工厂函数,它创造了一个 super object,为一个给定的类使用__mro__
去查找相应的父类。很明显,它从当前所找到的类开始搜索 MRO。更多详情,请再看一下 Guido van
Rossum 有关统一类型和类的文章,他甚至给出了一个 super()的纯 Python 实现,这样,你可以加深
其印象,知道它是如何工作的!
最 后 想 到 .... super() 的 主 要 用 途 , 是 来 查 找 父 类 的 属 性 , 比 如 ,
super(MyClass,self).__init__()。如果你没有执行这样的查找,你可能不需要使用 super()。
有很多如何使用 super()的例子分散在本章中。记得阅读一下第 13.11.2 节中有关 super()的重
要提示,尤其是那节中的核心笔记。


13.12.6      vars()
vars()内建函数与 dir()相似,只是给定的对象参数都必须有一个__dict__属性。vars()返回一
个字典,它包含了对象存储于其__dict__中的属性(键)及值。如果提供的对象没有这样一个属性,
则会引发一个 TypeError 异常。如果没有提供对象作为 vars()的一个参数,它将显示一个包含本地
名字空间的属性(键)及其值的字典,也就是,locals()。我们来看一下例子,使用类实例调用 vars():
class C(object):
pass
>>> c = C()
>>> c.foo = 100
>>> c.bar = 'Python'
>>> c.__dict__
{'foo': 100, 'bar': 'Python'}
>>> vars(c)
{'foo': 100, 'bar': 'Python'}
表 13.3 概括了类和类实例的内建函数。
表 13.3 类,实例及其它对象的内建函数
内建函数                      描述
issubclass(sub, sup)      如果类 sub 是类 sup 的子类,则返回 True,反之,为 False。
isinstance(obj1, obj2)    如果实例 obj1 是类 obj2 或者 obj2 子类的一个实例;           或者如果 obj1
是 obj2 的类型,则返回 True;反之,为 False。
hasattr(obj, attr)        如果 obj 有属性 attr(用字符串给出),返回 True,反之,返回
表 13.3 类,实例及其它对象的内建函数(续)
内建函数                            描述
getattr(obj, attr[, default])    获取 obj 的 attr 属性;与返回 obj.attr 类似;如果 attr
不是 obj 的属性,如果提供了默认值,则返回默认值;不然,
就会引发一个 AttributeError 异常。
setattr(obj, attr, val)         设置 obj 的 attr 属性值为 val,替换任何已存在的属性值;
不然,就创建属性;类似于 obj.attr=val
delattr(obj, attr)               从 obj 中删除属性 attr(以字符串给出);类似于 del
obj.attr。
dir(obj=None)                    返回 obj 的属性的一个列表;如果没有给定 obj,dir()则


显示局部名字空间空间中的属性,也就是 locals().keys()
a
super(type, obj=None)           返回一个表示父类类型的代理对象;如果没有传入 obj,
则返 回的 super 对象是非绑定的;反之,如果 obj 是一个
type , issubclass(obj,type) 必 为 True ; 否 则 ,
isinstance(obj,type)就必为 True。
vars(obj=None)                 返回 obj 的属性及其值的一个字典;如果没有给出 obj,
vars()显示局部名字空间字典(属性及其值),也就是
locals()。
-----------------------------------------
a. Python2.2 中新增;仅对新式类有效
13.13     用特殊方法定制类
我们已在本章前面部分讲解了方法的两个重要方面:首先,方法必须在调用前被绑定(到它们
相应类的某个实例中);其次,有两个特殊方法可以分别作为构造器和析够器的功能,分别名为
__init__()和__del__()。
事实上,__init__()和__del__()只是可自定义特殊方法集中的一部分。它们中的一些有预定
义的默认行为,而其它一些则没有,留到需要的时候去实现。这些特殊方法是 Python 中用来扩充
类的强有力的方式。它们可以实现:
z   模拟标准类型
z   重载操作符
特殊方法允许类通过重载标准操作符+,*, 甚至包括分段下标及映射操作操作[] 来模拟标准
类型。如同其它很多保留标识符,这些方法都是以双下划线(__)开始及结尾的。表 13.4 列出了所有
特殊方法及其它的描述。
表 13.4 用来定制类的特殊方法
特殊方法                              描述
基本定制型
C.__init__(self[, arg1, ...])   构造器(带一些可选的参数)
C.__new__(self[, arg1, ...])a   构造器(带一些可选的参数);通常用在设置不变数据类
型的子类。
C.__del__(self)                  解构器
C.__str__(self)                  可打印的字符输出;内建 str()及 print 语句
C.__repr__(self)                运行时的字符串输出;内建 repr() 和‘                ‘ 操作符
C.__unicode__(self)b            Unicode 字符串输出;内建 unicode()


C.__call__(self, *args)             表示可调用的实例
C.__nonzero__(self)                 为 object 定义 False 值;内建 bool() (从 2.2 版开始)
C.__len__(self)                  “长度”(可用于类);内建 len()
-----------------------------------------
(待续)
表 13.4 可以定制类的特殊方法(续)
特殊方法                               描述
c
对象(值)比较
C.__cmp__(self, obj)                对象比较;内建 cmp()
C.__lt__(self, obj) and             小于/小于或等于;对应<及<=操作符
C.__gt__(self, obj) and             大于/大于或等于;对应>及>=操作符
C.__eq__(self, obj) and             等于/不等于;对应==,!=及<>操作符
属性
C.__getattr__(self, attr)           获取属性;内建 getattr();仅当属性没有找到时调用
C.__setattr__(self, attr, val)            设置属性
C.__delattr__(self, attr)           删除属性
a
C.__getattribute__(self, attr)               获取属性;内建 getattr();总是被调用
a
C.__get__(self, attr)                   (描述符)获取属性
a
C.__set__(self, attr, val)              (描述符)设置属性
a
C.__delete__(self, attr)                (描述符)删除属性
定制类/模拟类型
数值类型:二进制操作符
C.__*add__(self, obj)               加;+操作符
C.__*sub__(self, obj)               减;-操作符
C.__*mul__(self, obj)               乘;*操作符
C.__*div__(self, obj)               除;/操作符
e
C.__*truediv__(self, obj)                 True 除;/操作符
e
C.__*floordiv__(self, obj)                Floor 除;//操作符
C.__*mod__(self, obj)           取模/取余;%操作符
C.__*divmod__(self, obj)            除和取模;内建 divmod()
C.__*pow__(self, obj[, mod])        乘幂;内建 pow();**操作符
C.__*lshift__(self, obj)            左移位;<<操作符
表 13.4 可定制类的特殊方法(续)
特殊方法                       描述
定制类/模拟类型
数值类型:二进制操作符


C.__*rshift__(self, obj)         右移;>>操作符
C.__*and__(self, obj)            按位与;&操作符
C.__*or__(self, obj)             按位或;|操作符
C.__*xor__(self, obj)            按位与或;^操作符
数值类型:一元操作符
C.__neg__(self)              一元负
C.__pos__(self)              一元正
C.__abs__(self)              绝对值;内建 abs()
C.__invert__(self)           按位求反;~操作符
数值类型:数值转换
C.__complex__(self, com)         转为 complex(复数);内建 complex()
C.__int__(self)              转为 int;内建 int()
C.__long__(self)                 转为 long;内建 long()
C.__float__(self)                转为 float;内建 float()
数值类型:基本表示法(String)
C.__oct__(self)              八进制表示;内建 oct()
C.__hex__(self)              十六进制表示;内建 hex()
数值类型:数值压缩
C.__coerce__(self, num)        压缩成同样的数值类型;内建 coerce()
g
C.__index__(self)              在有必要时,压缩可选的数值类型为整型(比如:用于切片
索引等等)
----------------------------------------
续
表 13.4 定制类的特殊方法(续)
序列类型
C.__len__(self)              序列中项的数目
C.__getitem__(self, ind)         得到单个序列元素
C.__setitem__(self, ind,val)           设置单个序列元素
C.__delitem__(self, ind)         删除单个序列元素
特殊方法                                 描述
序列类型
C.__getslice__(self, ind1,ind2)         得到序列片断
C.__setslice__(self, i1, i2,val)        设置序列片断
C.__delslice__(self, ind1,ind2)         删除序列片断
f
C.__contains__(self, val)               测试序列成员;内建 in 关键字
C.__*add__(self,obj)             串连;+操作符
C.__*mul__(self,obj)             重复;*操作符
e
C.__iter__(self)             创建迭代类;内建 iter()


映射类型
C.__len__(self)              mapping 中的项的数目
C.__hash__(self)             散列(hash)函数值
C.__getitem__(self,key)          得到给定键(key)的值
C.__setitem__(self,key,val)            设置给定键(key)的值
C.__delitem__(self,key)          删除给定键(key)的值
C.__missing__(self,key)          给定键如果不存在字典中,则提供一个默认值
-----------------------------------------
a.Python 2.2 中新引入;仅用于新式类中。
b. Python 2.3 中新引入。
c. 除了 cmp()外,其余全是在 Python 新引入的。
d. "*" 代表''(selp OP obj), 'r'(obj OP self),或'i'(原位(in-place)操作, Py2.0 新增),
例如     __add__, __radd__, or __iadd__.
e. Python 2.2 中新引入。
f. “*” either nothing (self OP obj), “r” (obj OP self ), or “i” for in-place
operation (new in Python 1.6), i.e., __add__, __radd__, or __iadd__.
g. Python 2.5 中新引入。
基本的定制和对象(值)比较特殊方法在大多数类中都可以被实现,且没有同任何特定的类型
模型绑定。延后设置,也就是所谓的 Rich 比较,在 Python2.1 中加入。属性组帮助管理您的类的
实例属性。这同样独立于模型。还有一个,__getattribute__(),它仅用在新式类中,我们将在后
面的章节中对它进行描述。
特殊方法中数值类型部分可以用来模拟很多数值操作,包括那些标准(一元和二进制)操作符,
类型转换,基本表示法,及压缩。也还有用来模拟序列和映射类型的特殊方法。实现这些类型的特
殊方法将会重载操作符,以使它们可以处理你的类类型的实例。
另外,除操作符__*truediv__()和__*floordiv__()在 Python2.2 中加入,用来支持 Python 除
操作符中待定的更改---可查看 5.5.3 节。基本上,如果解释器启用新的除法,不管是通过一个开关
来启动 Python,还是通过"from __future__ import division",单斜线除操作(/)表示的将是 ture
除法,意思是它将总是返回一个浮点值,不管操作数是否为浮点数或者整数(复数除法保持不变)。
双斜线除操作(//)将提供大家熟悉的浮点除法,从标准编译型语言像 C/C++及 Java 过来的工程师
一定对此非常熟悉。同样,这些方法只能处理实现了这些方法并且启用了新的除操作的类的那些符
号。
表格中,在它们的名字中,用星号通配符标注的数值二进制操作符则表示这些方法有多个版本,
在名字上有些许不同。星号可代表在字符串中没有额外的字符,或者一个简单的“r”指明是一个右
结合操作。没有“r”,操作则发生在对于 self OP obj 的格式; “r”的出现表明格式 obj OP self。
比如,__add__(self,obj)是针对 self+obj 的调用,而__radd__(self,obj)则针对 obj+self 来调用。


增量赋值,起于 Python 2.0,介绍了“原位”操作符。一个“i”代替星号的位置,表示左结合
操作与赋值的结合,相当是在 self=self OP obj。举例,__iadd__(self,obj)相当于 self=self+obj
的调用。
随着 Python 2.2 中新式类的引入,有一些更多的方法增加了重载功能。然而,在本章开始部分
提到过,我们仅关注经典类和新式类都适应的核心部分,本章的后续部分,我们介绍新式类的高级
特性。
13.13.1 简单定制(RoundFloat2)
我们的第一个例子很普通。在某种程度上,它基于我们前面所看到的从 Python 类型中派生出的
派生类 RoundFloat。这个例子很简单。事实上,我们甚至不想去派生任何东西(当然,除 object 外)...
我们也不想采用与 floats 有关的所有“好东西”。不,这次,我们想创建一个苗条的例子,这样你
可以对类定制的工作方式有一个更好的理解。这种类的前提与其它类是一样的:我们只要一个类来
保存浮点数,四舍五入,保留两位小数位。
class RoundFloatManual(object):
def __init__(self, val):
assert isinstance(val, float), \
"Value must be a float!"
self.value = round(val, 2)
这个类仅接收一个浮点值----它断言了传递给构造器的参数类型必须为一个浮点数----并且将
其保存为实例属性值。让我们来试试,创建这个类的一个实例:
>>> rfm = RoundFloatManual(42)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "roundFloat2.py", line 5, in __init__
assert isinstance(val, float), \ AssertionError: Value must be a float!
>>> rfm = RoundFloatManual(4.2)
>>> rfm
<roundFloat2.RoundFloatManual object at 0x63030>
>>> print rfm
<roundFloat2.RoundFloatManual object at 0x63030>
你已看到,它因输入非法,而“噎住”                 ,但如果输入正确时,就没有任何输出了。可是,当把这


个对象转存在交互式解释器中时,看一下发生了什么。我们得到一些信息,却不是我们要找的。                           (我
们想看到数值,对吧?)调用 print 语句同样没有明显的帮助。
不幸的是,print(使用 str())和真正的字符串对象表示(使用 repr())都没能显示更多有关
我们对象的信息。一个好的办法是,去实现__str__()和__repr__()二者之一,或者两者都实现,这
样我们就能“看到”我们的对象是个什么样子了。换句话说,当你想显示你的对象,实际上是想看
到有意义的东西,而不仅仅是通常的 Python 对象字符串(<object object at id>)。让我们来添加
一个__str()__方法,以覆盖默认的行为:
def __str__(self):
return str(self.value)
现在我们得到下面的:
>>> rfm = RoundFloatManual(5.590464)
>>> rfm
<roundFloat2.RoundFloatManual object at 0x5eff0>
>>> print rfm
5.59
>>> rfm = RoundFloatManual(5.5964)
>>> print rfm
5.6
我们还有一些问题...一个问题是仅仅在解释器中转储(dump)对象时,仍然显示的是默认对象符
号,但这样做也算不错。如果我们想修复它,只需要覆盖__repr__()。因为字符串表示法也是 Python
对象,我们可以让__repr__()和__str__()的输出一致。
为了完成这些,只要把__str__()的代码复制给__repr__()。这是一个简单的例子,所以它没有
真正对我们造成负面影响,但作为程序员,你知道那不是一个最好的办法。如果__str__()中存在 bug,
那么我们会将 bug 也复制给__repr__()了。
最好的方案,在__str__()中的代码也是一个对象,同所有对象一样,引用可以指向它们,所以,
我们可以仅仅让__repr__()作为__str__()的一个别名:
__repr__ = __str__
在带参数 5.5964 的第二个例子中,我们看到它舍入值刚好为 5.6,但我们还是想显示带两位小
数的数。来玩玩一个更好的妙计吧,看下面:
def __str__(self):
return '%.2f' % self.value


这里就同时具备 str()和 repr()的输出了:
>>> rfm = RoundFloatManual(5.5964)
>>> rfm
5.60
>>> print rfm
5.60
例 13.2 基本定制(roundFloat2.py)
1 #!/usr/bin/env python
2
3 class RoundFloatManual(object):
4 def __init__(self, val):
5 assert isinstance(val, float), \
6 "Value must be a float!"
7 self.value = round(val, 2)
8
9 def __str__(self):
10 return '%.2f' % self.value
11
12 __repr__ = __str__
在本章开始部分,最初的 RoundFloat 例子,我们没有担心所有细致对象的显示问题;原因是
__str__()和__repr__()作为 float 类的一部分已经为我们定义好了。我们所要做的就是去继承它们。
增强版本“手册”中需要另外的工作。你发现派生是多么的有益了吗?我们甚至不需要知道解释器
在继承树上要执行多少步才能找到一个已声明的你正在使用却没有考虑过的方法。我们将在例 13.2
中列出这个类的全部代码。
现在开始一个稍复杂的例子。
13.13.2 数值定制(Time60)
作为第一个实际的例子,我们可以想象需要创建一个简单的应用,用来操作时间,精确到小时
和分。我们将要创建的这个类可用来跟踪职员工作时间,ISP 用户在线时间,数据库总的运行时间(不
包括备份及升级时的停机时间),在扑克比赛中玩家总时间,等等。
在 Time60 类中,我们将整数的小时和分钟作为输入传给构造器。
class Time60(object):         # ordered pair 顺序对


def __init__(self, hr, min):           # constructor 构造器
self.hr = hr             # assign hours 给小时赋值
self.min = min               # assign minutes 给分赋值
显示
同样,如前面的例子所示,在显示我们的实例的时候,我们需要一个有意义的输出,那么就要
覆盖__str__()(如果有必要的话,__repr__()也要覆盖)。我们都习惯看小时和分,用冒号分隔开的
格式,比如,“4:30”,表示四个小时,加半个小时(4 个小时及 30 分钟):
def __str__(self):
return '%d:%d' % (self.hr, self.min)
用此类,可以实例化一些对象。在下面的例子中,我们启动一个工时表来跟踪对应构造器的计
费小时数:
>>> mon = Time60(10, 30)
>>> tue = Time60(11, 15)
>>>
>>> print mon, tue
10:30 11:15
输出不错,正是我们想看到的。下一步干什么呢?可考虑与我们的对象进行交互。比如在时间
片的应用中,有必要把 Time60 的实例放到一起让我们的对象执行所有有意义的操作。我们更喜欢像
这样的:
>>> mon + tue
21:45
加法
Python 的重载操作符很简单。像加号(+),我们只需要重载__add__()方法,如果合适,还可以
用__radd__()及__iadd__()。稍后有更多有关这方面的描述。实现__add__()听起来不难----只要把
分和小时加在一块。大多数复杂性源于我们怎么处理这个新的总数。如果我们想看到“21:45”,就
必须认识到这是另一个 Time60 对象,我们没有修改 mon 或 tue,所以,我们的方法就应当创建另一
个对象并填入计算出来的总数。
实现__add__()特殊方法时,首先计算出个别的总数,然后调用类构造器返回一个新的对象:
def __add__(self, other):


return self.__class__(self.hr + other.hr, self.min + other.min)
和正常情况下一样,新的对象通过调用类来创建。唯一的不同点在于,在类中,你一般不直接
调 用 类 名 , 而 是 使 用 self 的 __class__ 属 性 , 即 实 例 化 self 的 那 个 类 , 并 调 用 它 。 由 于
self.__class__与 Time60 相同,所以调用 self.__class__()与调用 Time60()是一回事。
不管怎样,这是一个更面向对象的方式。另一个原因是,如果我们在创建一个新对象时,处处
使用真实的类名,然后,决定将其改为别的名字,这时,我们就不得不非常小心地执行全局搜索并
替换。如果靠使用 self.__class__,就不需要做任何事情,只需要直接改为你想要的类名。
好了,我们现在来使用加号重载,“增加”Time60 对象:
>>> mon = Time60(10, 30)
>>> tue = Time60(11, 15)
>>> mon + tue
<time60.Time60 object at 0x62190>
>>> print mon + tue
21:45
哎哟,我们忘记添加一个别名__repr__给__str__了,这很容易修复。你可能会问,                              “当我们试
着在重载情况下使用一个操作符,却没有定义相对应的特殊方法时还有很多需要优化和重要改良的
地方,会发生什么事呢?” 答案是一个 TypeError 异常:
>>> mon - tue
Traceback (most recent call last): File "<stdin>", line 1, in ?
TypeError: unsupported operand type(s) for -: 'Time60'
and 'Time60'
原位加法
有了增量赋值(在 Python 2.0 中引入),我们也许还有希望覆盖“原位”操作,比如,__iadd__()。
这是用来支持像 mon += tue 这样的操作符,并把正确的结果赋给 mon。重载一个__i*__()方法的唯
一秘密是它必须返回 self。把下面的片断加到我们例子中,以修复上面的 repr()问题,并支持增量
赋值:
__repr__ = __str__
def __iadd__(self, other):
self.hr += other.hr
self.min += other.min
return self


下面是结果输出:
>>> mon =Time60(10,30)
>>> tue =Time60(11,15)
>>> mon
10:30
>>> id(mon)
401872
>>> mon += tue
>>> id(mon)
401872
>>> mon
21:45
注意,使用 id()内建函数是用来确定一下,在原位加的前后,我们确实是修改了原来的对象,
而没有创建一个新的对象。对一个具有巨大潜能的类来说,这是很好的开始。在例 13.3 中给出了
Time60 的类的完全定义
例 13.3 中级定制(time60.py)
1 #!/usr/bin/env python
2
3 class Time60(object):
4 'Time60 - track hours and minutes'
5
6     def __init__(self, hr, min):
7    'Time60 constructor - takes hours and minutes'
8        self.hr = hr
9        self.min = min
10
11       def __str__(self):
12       'Time60 - string representation'
13           return '%d:%d' % (self.hr, self.min)
14
15 __repr__ = __str__
16
17       def __add__(self, other):
18           'Time60 - overloading the addition operator'
19           return self.__class__(self.hr + other.hr,self.min + other.min)


21
22        def __iadd__(self, other):
23        'Time60 - overloading in-place addition'
24            self.hr += other.hr
25            self.min += other.min
26            return self
例 13.4 随机序列迭代器(randSeq.py)
1 #!/usr/bin/env python
2
3 from random import choice
4
5 class RandSeq(object):
6     def __init__(self, seq):
7         self.data = seq
8
9     def __iter__(self):
10         return self
11
12     def next(self):
13          return choice(self.data)
升华
现在暂不管它了,但在这个类中,还有很多需要优化和改良的地方。比如,如果我们不传入两
个分离的参数,而传入一个 2 值元组给构造器作为参数,是不是更好些呢?如果是像“10:30”这样
的字符串的话,结果会怎样?
答案是肯定的,你可以这样做,在 Python 中很容易做到,但不是像很多其他面向对象语言一样
通过重载构造器来实现.Python 不允许用多个签名重载可调用对象.所以实现这个功能的唯一的方式
是使用单一的构造器,并由 isinstance()和(可能的)type()内建函数执行自省功能。
能支持多种形式的输入,能够执行其它操作像减法等,可以让我们的应用更健壮,灵活。当然
这些是可选的,就像“蛋糕上的冰”               ,但我们首先应该担心的是两个中等程度的缺点:1.当比十分钟
还少时,格式并不是我们所希望的,2. 不支持 60 进制(基数 60)的操作:
>>> wed = Time60(12, 5)
>>> wed
12:5


>>> thu = Time60(10, 30)
>>> fri = Time60(8, 45)
>>> thu + fri
18:75
---------------------------------------------------------------------------------
1.源自拉丁语的基数是 60 的名字;有时,六十进制会被用到,这是一种希腊词根“hexe”和拉
丁“gesmal”的混合。
显示 wed 结果是“12:05”,把 thu 和 fri 加起来结果会是“19:15”               。修改这些缺陷,实现上面
的改进建议可以实际性地提高你编写定制类技能。这方面的更新,更详细的描述在本章的练习 13.20
中。
我们希望,你现在对于操作符重载,为什么要使用操作符重载,以及如何使用特殊方法来实现
它已有了一个更好的理解了。接下来为选看章节内容,让我们来了解更多复杂的类定制的情况。
13.13.3      迭代器(RandSeq 和 AnyIter)
RandSeq
我们正式介绍迭代器是在第 8 章,但在全书中都在用它。它可以一次一个的遍历序列(或者是
类似序列对象)中的项。在第 8 章中,我们描述了如何利用一个类中的__iter__()和 next()方法,
来创建一个迭代器。我们在此展示两个例子。
第一个例子是 RandSeq(RANDom SEQuence 的缩写)。我们给我们的类传入一个初始序列,然后
让用户通过 next()去迭代(无穷)。
__init__()方法执行前述的赋值操作。__iter__()仅返回 self,这就是如何将一个对象声明为
迭代器的方式,最后,调用 next()来得到迭代器中连续的值。这个迭代器唯一的亮点是它没有终点。
这个例子展示了一些我们可以用定制类迭代器来做的与众不同的事情。一个是无穷迭代。因为
我们无损地读取一个序列,所以它是不会越界的。每次用户调用 next()时,它会得到下一个迭代值,
但我们的对象永远不会引发 StopIteration 异常。我们来运行它,将会看到下面的输出:
>>> from randseq import RandSeq
>>> for eachItem in RandSeq(
... ('rock', 'paper', 'scissors')):
... print eachItem
...
scissors


scissors
rock
paper
paper
scissors
:
例 13.5 任意项的迭代器(anyIter.py)
1      #!/usr/bin/env python
2
3      class AnyIter(object):
4         def __init__(self, data, safe=False):
5             self.safe = safe
6             self.iter = iter(data)
7
8         def __iter__(self):
9             return self
10
11          def next(self, howmany=1):
12             retval = []
13              for eachItem in range(howmany):
14                try:
15                    retval.append(self.iter.next())
16                except StopIteration:
17                   if self.safe:
18                       break
19                   else:
20                       raise
21            return retval
AnyIter
在第二个例子中,我们的确创建了一个迭代器对象,我们传给 next()方法一个参数,控制返回
条目的数目,而不是去一次一个地迭代每个项。下面是我们的代码(ANY number of items ITERator):
和 RandSeq 类的代码一样,类 AnyIter 很容易领会。我们在上面描述了基本的操作...它同其它
迭代器一样工作,只是用户可以请求一次返回 N 个迭代的项,而不仅是一个项。
我们给出一个迭代器和一个安全标识符(safe)来创建这个对象。如果这个标识符(safe)为真


(True),我们将在遍历完这个迭代器前,返回所获取的任意条目,但如果这个标识符为假(False),
则在用户请求过多条目时,将会引发一个异常。错综复杂的核心在于 next(),特别是它如何退出的
(14-21 行)。
在 next()的最后一部分中,我们创建用于返回的一个列表项,并且调用对象的 next()方法来获
得每一项条目。如果我们遍历完列表,得到一个 StopIteration 异常,这时则检查安全标识符(safe)。
如果不安全(即,self.safe=False),则将异常抛还给调用者(raise);否则, 退出(break)并返回
(return)已经保存过的所有项。
>>> a = AnyIter(range(10))
>>> i = iter(a)
>>> for j in range(1,5):
>>>  print j, ':', i.next(j)
1 : [0]
2 : [1, 2]
3 : [3, 4, 5]
4 : [6, 7, 8, 9]
上面程序的运行没有问题,因为迭代器正好符合项的个数。当情况出现偏差,会发生什么呢?
让我们首先试试“不安全(unsafe)”的模式,这也就是紧随其后创建我们的迭代器:
>>> i = iter(a)
>>> i.next(14)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "anyIter.py", line 15, in next retval.append(self.iter.next())
StopIteration
因为超出了项的支持量,所以出现了 StopIteration 异常,并且这个异常还被重新引发回调用
者(第 20 行)。如果我们使用“安全(safe)”模式重建迭代器,再次运行一次同一个例子的话,我
们就可以在项失控出现前得到迭代器所得到的元素:
>>> a = AnyIter(range(10), True)
>>> i = iter(a)
>>> i.next(14)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
13.13.4      *多类型定制(NumStr)


现在创建另一个新类,NumStr,由一个数字-字符对组成,相应地,记为 n 和 s,数值类型使用
整型(integer)。尽管这组顺序对的“合适的”记号是(n,s),但我们选用[n::s]来表示它,有点
不同。暂不管记号,这两个数据元素只要我们模型考虑好了,就是一个整体。可以创建我们的新类
了,叫做 NumStr,有下面的特征:
初始化
类应当对数字和字符串进行初始化;如果其中一个(或两)没有初始化,则使用 0 和空字符串,
也就是,n=0 且 s='',作为默认。
加法
我们定义加法操作符,功能是把数字加起来,把字符连在一起;要点部分是字符串要按顺序相
连。比如,NumStr1=[n1::s1]且 NumStr2=[n2::s2]。则 NumStr1+NumStr2 表示[n1+n2::s1+s2],
其中,+代表数字相加及字符相连接。
乘法
类似的,定义乘法操作符的功能为,数字相乘,字符累积相连,也就是,
NumStr1*NumStr2=[n1*n::s1*n]。
False 值
当数字的数值为 0 且字符串为空时,也就是当 NumStr=[0::'']时,这个实体即有一个 false 值。
比较
比较一对 NumStr 对象,比如,[n1::s1] vs. [n2::s2],我们可以发现九种不同的组合(即,n1>n2
and s1<s2,n1==n2 and s1>s2,等等)。对数字和字符串,我们一般按照标准的数值和字典顺
序的进行比较,即,如果 obj1<obj2,普通比较 cmp(obj1,obj2)的返回值是一个小于 0 的整数,当
obj1>obj2 时,比较的返回值大于 0,当两个对象有相同的值时,比较的返回值等于 0。
我们的类的解决方案是把这些值相加,然后返回结果。有趣的是 cmp()不会总是返回-1,0,或
1。上面提到过,它是一个小于,等于或大于 0 的整数。
为了能够正确的比较对象,我们需要让__cmp__()在(n1>n2) 且 (s1>s2)时,返回 1,在(n1<n2)
且(s1<s2)时,返回-1,而当数值和字符串都一样时,或是两个比较的结果正相反时(即(n1<n2)且
(s1>s2),或相反),返回 0.反之亦然。
例 13.6 多类型类定制(numstr.py)


1 #!/usr/bin/env python
2
3 class NumStr(object):
4
5 def __init__(self, num=0, string=''):
6     self.__num = num
7    self.__string = string
8
9 def __str__(self): # define for str()
10        return '[%d :: %r]' % \
11        self.__num, self.__string)
12 __repr__ = __str__
13
14 def __add__(self, other): # define for s+o
15        if isinstance(other, NumStr):
16            return self.__class__(self.__num + \
17                other.__num, \
18              self.__string + other.__string)
19      else:
20          raise TypeError, \
21          'Illegal argument type for built-in operation'
22
23 def __mul__(self, num): # define for o*n
24        if isinstance(num, int):
25            return self.__class__(self.__num * num
26            self.__string * num)
27        else:
28            raise TypeError, \
29            'Illegal argument type for built-in operation'
30
31 def __nonzero__(self): # False if both are
32        return self.__num or len(self.__string)
33
34 def __norm_cval(self, cmpres):# normalize cmp()
35        return cmp(cmpres, 0)
36
37 def __cmp__(self, other): # define for cmp()
38        return self.__norm_cval(
39            cmp(self.__num, other.__num)) + \


40           self.__norm_cval(
41           cmp(self.__string, other.__string))
根据上面的特征,我们列出 numstr.py 的代码,执行一些例子:
>>> a  = NumStr(3, 'foo')
>>> b  = NumStr(3, 'goo')
>>> c  = NumStr(2, 'foo')
>>> d  = NumStr()
>>> e  = NumStr(string='boo')
>>> f  = NumStr(1)
>>> a
[3 ::  'foo']
>>> b
[3 :: 'goo']
>>> c
[2 :: 'foo']
>>> d
[0 :: '']
>>> e
[0 :: 'boo']
>>> f
[1 :: '']
>>> a < b
True
>>> b < c
False
>>> a == a
True
>>> b * 2
[6 :: 'googoo']
>>> a * 3
[9 :: 'foofoofoo']
>>> b + e
[3 :: 'gooboo']
>>> e + b
[3 :: 'boogoo']
>>> if d: 'not false' # also bool(d)
...


>>> if e: 'not false' # also bool(e)
...
'not false'
>>> cmp(a,b)
-1
>>> cmp(a,c)
1
>>> cmp(a,a)
0
逐行解释
第 1-7 行
脚本的开始部分为构造器__init__(),通过调用 NumStr()时传入的值来设置实例,完成自身初
始化。如果有参数缺失,属性则使用 false 值,即默认的 0 或空字符,这取决于参数情况。
一个重要怪癖是命名属性时,双下划线的使用。我们在下一节中会看到,这是在信息隐藏时,
强加一个级别,尽管不够成熟。程序员导入一个模块时,就不能直接访问到这些数据元素。我们正
试着执行一种 OO 设计中的封装特性,只有通过存取函数才能访问。如果这种语法让你感觉有点怪
异,不舒服的话,你可以从实例属性中删除所有双下划线,程序同样可以良好地运行。
所有的由双下划线(__)开始的属性都被“混淆”(mangled)了,导致这些名字在程序运行时
很难被访问到。但是它们并没有用一种难于被逆向工程的方法来“混淆”。事实上,“混淆”属性的
方式已众所周知,很容易被发现。这里主要是为了防止这些属性在被外部模块导入时,由于被意外
使用而造成的名字冲突。我们将名字改成含有类名的新标志符,这样做,可以确保这些属性不会被
无意“访问”。更多信息,请参见 13.14 节中关于私有成员的内容。
第 9-12 行
我们把顺序对的字符串表示形式确定为“[num::'str']”,这样不论我们的实例用 str()还是包
含在 print 语句中时候,我们都可以用__str__()来提供这种表示方式。我们想强调一点,第二个元
素是一个字符串,如果用户看到由引号标记的字符串时,会更加直观。要做到这点,我们使用“repr()”
表示法对代码进行转换,把“%s”替换成“%r”                    。这相当于调用 repr()或者使用单反引号来给出字符
串的可求值版本--可求值版本的确要有引号:
>>> print a
[3 :: 'foo']
如果在 self.__string 中没有调用 repr()(去掉单反引号或使用“%s”)将导致字符串引号丢
失:
return '[%d :: %s]' % (self.__num, self.__string)


现在对实例再次调用 print,结果:
>>> print a
[3 :: foo]
没有引号,看起来会如何呢?不能信服“foo”是一个字符串,对吧?它看起来更像一个变量。
连作者可能也不能确定。(我们快点悄悄回到这一变化之前,假装从来没看到这个内容。)
代码中__str__()函数后的第一行是把这个函数赋给另一个特殊方法名,__repr__。我们决定我
们的实例的一个可求值的字符串表示应当与可打印字符串表示是一样的。而不是去定义一个完整的
新函数,成为__str__()的副本,我们仅去创建一个别名,复制其引用。当你实现__str__()后,一
旦使用那个对象作为参数来应用内建 str()函数,解释器就会调用这段代码.对__repr__()及 repr()
也一样。
如果不去实现__repr__(),我们的结果会有什么不同呢?如果赋值被取消,只有调用 str()的
print 语 句 才 会 显 示 对 象 的 内 容 。 而 可 求 值 字 符 串 表 示 恢 复 成 默 认 的 Python 标 准 形 式
<...some_object_ information...>
>>> print a # calls str(a)
[3 :: 'foo']
>>> a # calls repr(a)
<NumStr.NumStr instance at 122640>
第 14-21 行
我们想加到我们的类中的一个特征就是加法操作,前面已提到过。Python 用于定制类的特征之
一是,我们可以重载操作符,以使定制的这些类型更“实用”。调用一个函数,像“add(obj1,obj2)”
是为“add”对象 obj1 和 ojb2,这看起来好像加法,但如果能使用加号(+)来调用相同的操作是不是
更具竞争力呢?像这样,obj1+obj2。
重载加号,需要去为 self(SELF)和其它操作数实现(OTHER)__add__().__add__()函数考虑
Self+Other 的情况,但我们不需要定义__radd__()来处理 Other+Self,因为这可以由 Other 的
__add__()去考虑。数值加法不像字符串那样结果受到(操作数)顺序的影响.
加法操作把两个部分中的每一部分加起来,并用这个结果对形成一个新的对象----通过将结果
做为参数调用 self.__class__()来实例化(同样,在前面已解释过).碰到任何类型不正确的对象时,
我们会引发一个 TypeError 异常.
第 23-29 行
我们也可以重载星号[靠实现__mul__()],执行数值乘法和字符串重复,并同样通过实例化来创
建一个新的对象。因为重复只允许整数在操作数的右边,因此也必执行此规则。基于同样的原因,
我们在此也没有实现__rmul__()。


第 31-32 行
Python 对象任何时候都有一个 Boolean 值。对标准类型而言,对象有一个 false 值的情况为:
它是一个类似于 0 的数值,或是一个空序列,或者映射。就我们的类而言,我们选择数值必须为 0,
字符串要为空 作为一个实例有一个 false 值的条件。覆盖__nonzero__()方法,就是为此目的。其
它对象,像严格模拟序列或映射类型的对象,使用一个长度为 0 作为 false 值。这些情况,你需要
实现__len__()方法,以实现那个功能。
第 34-41 行
__norm_cval() (“normalize    cmp() value 的缩写”)不是一个特殊方法。它是一个帮助我们
重载__cmp__()的助手函数:唯一的目的就是把 cmp()返回的正值转为 1,负值转为-1。cmp()基于比
较的结果,通常返回任意的正数或负数(或 0),但为了我们的目的,需要严格规定返回值为-1,0 和 1。
对整数调用 cmp()及与 0 比较,结果即是我们所需要的,相当于如下代码片断:
def __norm_cval(self, cmpres):
if cmpres < 0:
return -1
elif cmpres > 0:
return 1
else:
return 0
两个相似对象的实际比较是比较数字,比较字符串,然后返回这两个比较结果的和。
13.14 私有化
默认情况下,属性在 Python 中都是“public”,类所在模块和导入了类所在模块的其他模块的
代码都可以访问到。很多 OO 语言给数据加上一些可见性,只提供访问函数来访问其值。这就是熟知
的实现隐藏,是对象封装中的一个关键部分。
大多数 OO 语言提供“访问控制符”来限定成员函数的访问。
双下划线(__)
Python 为类元素(属性和方法)的私有性提供初步的形式。由双下划线开始的属性在运行时被
“混淆”,所以直接访问是不允许的。实际上,会在名字前面加上下划线和类名。比如,以例
13.6(numstr.py)中的 self.__num 属性为例,被“混淆”后,用于访问这个数据值的标识就变成了
self._NumStr__num。把类名加上后形成的新的“混淆”结果将可以防止在祖先类或子孙类中的同名
冲突。
尽管这样做提供了某种层次上的私有化,但算法处于公共域中并且很容易被“击败”。这更多的


是一种对导入源代码无法获得的模块或对同一模块中的其他代码的保护机制.
这种名字混淆的另一个目的,是为了保护__XXX 变量不与父类名字空间相冲突。如果在类中有一
个__XXX 属性,它将不会被其子类中的__XXX 属性覆盖。(回忆一下,如果父类仅有一个 XXX 属性,
子类也定义了这个,这时,子类的 XXX 就是覆盖了父类的 XXX,这就是为什么你必须使用 PARENT.XXX
来调用父类的同名方法。) 使用__XXX,子类的代码就可以安全地使用__XXX,而不必担心它会影响
到父类中的__XXX。
单下划线(_)
与我们在第十二章发现的那样,简单的模块级私有化只需要在属性名前使用一个单下划线字符。
这就防止模块的属性用“from mymodule import *”来加载。这是严格基于作用域的,所以这同样
适合于函数。
在 Python 2.2 中引进的新式类,增加了一套全新的特征,让程序员在类及实例属性提供保护
的多少上拥有大量重要的控制权。尽管 Python 没有在语法上把 private,protected,friend 或
protected friend 等特征内建于语言中,但是可以按你的需要严格地定制访问权。我们不可能涵盖
所有的内容,但会在本章后面给你一些有关新式类属性访问的建议。
13.15     *授权
13.15.1     包装
“包装”在 Python 编程世界中经常会被提到的一个术语。它是一个通用的名字,意思是对一
个已存在的对象进行包装,不管它是数据类型,还是一段代码,可以是对一个已存在的对象,增加
新的,删除不要的,或者修改其它已存在的功能。
在 Python 2.2 版本前,从 Python 标准类型子类化或派生类都是不允许的。即使你现在可以对
新式类这样做,这一观念仍然很流行。你可以包装任何类型作为一个类的核心成员,以使新对象的
行为模仿你想要的数据类型中已存在的行为,并且去掉你不希望存在的行为;它可能会要做一些额
外的事情。这就是“包装类型”。在附录中,我们还将讨论如何扩充 Python,包装的另一种形式。
包装包括定义一个类,它的实例拥有标准类型的核心行为。换句话说,它现在不仅能唱能跳,
还能够像原类型一样步行,说话。图 15-4 举例说明了在类中包装的类型看起像个什么样子。在图的
中心为标准类型的核心行为,但它也通过新的或最新的功能,甚至可能通过访问实际数据的不同方
法得到提高。


类对象(其表现像类型)
你还可以包装类,但这不会有太多的用途,因为已经有用于操作对象的机制,并且在上面已描
述过,对标准类型有对其进行包装的方式。你如何操作一个已存的类,模拟你需要的行为,删除你
不喜欢的,并且可能让类表现出与原类不同的行为呢?我们前面已讨论过,就是采用派生。
图 13-4 包装类型
13.15.2  实现授权
授权是包装的一个特性,可用于简化处理有关 dictating 功能,采用已存在的功能以达到最大
限度的代码重用。
包装一个类型通常是对已存在的类型的一些定制。我们在前面提到过,这种做法可以新建,修
改或删除原有产品的功能。其它的则保持原样,或者保留已存功能和行为。授权的过程,即是所有
更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。
实现授权的关键点就是覆盖__getattr__()方法,在代码中包含一个对 getattr()内建函数的调
用。特别地,调用 getattr()以得到默认对象属性(数据属性或者方法)并返回它以便访问或调用。
特殊方法__getattr__()的工作方式是,当搜索一个属性时,任何局部对象首先被找到(定制的对象)。
如果搜索失败了,则__getattr__()会被调用,然后调用 getattr()得到一个对象的默认行为。
换言之,当引用一个属性时,Python 解释器将试着在局部名称空间中查找那个名字,比如一个
自定义的方法或局部实例属性。如果没有在局部字典中找到,则搜索类名称空间,以防一个类属性
被访问。最后,如果两类搜索都失败了,搜索则对原对象开始授权请求,此时,__getattr__()会被
调用。
包装对象的简例
看一个例子。这个类已乎可以包装任何对象,提供基本功能,比如使用 repr()和 str()来处理


字符串表示法。另外定制由 get()方法处理,它删除包装并且返回原始对象。所以保留的功能都授权
给对象的本地属性,在必要时,可由__getattr__()获得。
下面是包装类的例子:
class WrapMe(object):
def __init__(self, obj):
self.__data = obj
def get(self):
return self.__data
def __repr__(self):
return ‘self.__data‘
def __str__(self):
return str(self.__data)
def __getattr__(self, attr):
return getattr(self.__data, attr)
在第一个例子中,我们将用到复数,因为所有 Python 数值类型,只有复数拥有属性:数据属性,
及 conjugate()内建方法(求共轭复数,译者注!                   )。记住,属性可以是数据属性,还可以是函数或
方法:
>>> wrappedComplex = WrapMe(3.5+4.2j)
>>> wrappedComplex # wrapped object: repr() 包装的对象:repr()
(3.5+4.2j)
>>> wrappedComplex.real # real attribute 实部属性
3.5
>>> wrappedComplex.imag # imaginary attribute 虚部属性
42.2
>>> wrappedComplex.conjugate() # conjugate() method conjugate()方法
(3.5-4.2j)
>>> wrappedComplex.get() # actual object 实际对象
(3.5+4.2j)
一旦我们创建了包装的对象类型,只要由交互解释器调用 repr(),就可以得到一个字符串表示。
然后我们继续访问了复数的三种属性,我们的类中一种都没有定义。在例子中,寻找实部,虚部及
共轭复数的定义...they are not there!
对这些属性的访问,是通过 getattr()方法,授权给对象.最终调用 get()方法没有授权,因为
它是为我们的对象定义的----它返回包装的真实的数据对象。


下一个使用我们的包装类的例子用到一个列表。我们将会创建对象,然后执行多种操作,每次
授权给列表方法。
>>> wrappedList = WrapMe([123, 'foo', 45.67])
>>> wrappedList.append('bar')
>>> wrappedList.append(123)
>>> wrappedList
[123, 'foo', 45.67, 'bar', 123]
>>> wrappedList.index(45.67)
2
>>> wrappedList.count(123)
2
>>> wrappedList.pop()
123
>>> wrappedList
[123, 'foo', 45.67, 'bar']
注意,尽管我们正在我们的例子中使用实例,它们展示的行为与它们包装的数据类型非常相似。
然后,需要明白,只有已存在的属性是在此代码中授权的。
特殊行为没有在类型的方法列表中,不能被访问,因为它们不是属性。一个例子是,对列表的
切片操作,它是内建于类型中的,而不是像 append()方法那样作为属性存在的。从另一个角度来说,
切片操作符是序列类型的一部分,并不是通过__getitem__()特殊方法来实现的。
>>> wrappedList[3]
Traceback (innermost last): File "<stdin>", line 1, in ?
File "wrapme.py", line 21, in __getattr__
return getattr(self.data, attr)
AttributeError: __getitem__
AttributeError 异常出现的原因是切片操作调用了__getitem__()方法,且__getitme__()没有
作为一个类实例方法进行定义,也不是列表对象的方法。回忆一下,什么时候调用 getattr()呢?当
在实例或类字典中的完整搜索失败后,就调用它来查找一个成功的匹配。你在上面可以看到,对
getattr()的调用就是失败的那个,触发了异常。
然而,我们还有一种"作弊"的方法,访问实际对象[通过我们的 get()方法]和它的切片能力.
>>> realList = wrappedList.get()
>>> realList[3]
'bar'


你现在可能知道为什么我们实现 get()方法了----仅仅是为了我们需要取得对原对象进行访问
这种情况,我们可以从访问调用中直接访问对象的属性,而忽略局部变量(realList):
>>> wrappedList.get()[3]
'bar'
get()方法返回一个对象,随后被索引以得到切片片断。
>>> f = WrapMe(open('/etc/motd'))
>>> f
<wrapMe.WrapMe object at 0x40215dac>
>>> f.get()
<open file '/etc/motd', mode 'r' at 0x40204ca0>
>>> f.readline()
'Have a lot of fun...\012'
>>> f.tell()
21
>>> f.seek(0)
>>> print f.readline(),
Have a lot of fun...
>>> f.close()
>>> f.get()
<closed file '/etc/motd', mode 'r' at 0x40204ca0>
一旦你熟悉了对象的属性,你就能够开始理解一些信息片断从何而来,能够利用新得到的知识
来重复功能:
>>> print "<%s file %s, mode %s at %x>" % \
... (f.closed and 'closed' or 'open', 'f.name',
'f.mode', id(f.get()))
<closed file '/etc/motd', mode 'r' at 80e95e0>
这总结了我们的简单包装类的例子。我们还刚开始接触使用类型模拟来进行类自定义。你将会
发现你可以进行无限多的改进,来进一步增加你的代码的用途。一种改进方法是为对象添加时间戳。
在下一小节中,我们将对我们的包装类增加另一个维度(dimension):
更新简单的包裹类
创建时间,修改时间,及访问时间是文件的几个常见属性,但没人说,你不能为对象加上这类信
息。毕竟,一些应用能因有这些额外信息而受益。


如果你对使用这三类时间顺序(chronological)数据还不熟,我们将会对它们进行解释。创建时
间(或'ctime')是实例化的时间,修改时间(或'mtime')指的是核心数据升级的时间[通常会调
用新的 set()方法],而访问时间(或'atime')是最后一次对象的数据值被获取或者属性被访问时的
时间戳。
更新我们前面定义的类,可以创建一个模块 twrapme.py,看例 13.7。
如何更新这些代码呢?好,首先,你将会发现增加了三个新方法:gettimeval(),gettimestr(),
及 set()。我们还增加数行代码,根据所执行的访问类型,更新相应的时间戳。
例 13.7 包装标准类型(twrapme.py)
类定义包装了任何内建类型,增加时间属性;get(),set(),还有字符串表示的方法;并授权
所有保留的属性,访问这些标准类型。
1 #!/usr/bin/env python
2
3 from time import time, ctime
4
5 class TimedWrapMe(object):
6
7     def __init__(self, obj):
8         self.__data = obj
9         self.__ctime = self.__mtime = \
10            self.__atime = time()
11
12        def get(self):
13            self.__atime = time()
14            return self.__data
15
16        def gettimeval(self, t_type):
17            if not isinstance(t_type, str) or \
18                   t_type[0] not in 'cma':
19               raise TypeError, \
20                   "argument of 'c', 'm', or 'a' req'd"
21               return getattr(self, '_%s__%stime' % \
22                   (self.__class__.__name__, t_type[0]))
23
24        def gettimestr(self, t_type):


25          return ctime(self.gettimeval(t_type))
26
27      def set(self, obj):
28           self.__data = obj
29           self.__mtime = self.__atime = time()
30
31       def __repr__(self): # repr()
32           self.__atime = time()
33           return ‘self.__data‘
34
35       def __str__(self): # str()
36           self.__atime = time()
37           return str(self.__data)
38
39       def __getattr__(self, attr):         # delegate
40           self.__atime = time()
41           return getattr(self.__data, attr)
gettimeval()方法带一个简单的字符参数,“c”,“m”或“a”,相应地,对应于创建,修改或
访问时间,并返回相应的时间,以一个浮点值保存。gettimestr()仅仅返回一个经 time.ctime()
函数格式化的打印良好的字符串形式的时间。
为新的模块作一个测试驱动。我们已看到授权是如何工作的,所以,我们将包装没有属性的对
象,来突出刚加入的新的功能。在例子中,我们包装了一个整数,然后,将其改为字符串。
>>> timeWrappedObj = TimedWrapMe(932)
>>> timeWrappedObj.gettimestr('c')
‘Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj.gettimestr('m')
'Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj.gettimestr('a')
'Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj
932
>>> timeWrappedObj.gettimestr('c')
'Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj.gettimestr('m')
'Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj.gettimestr('a')
'Wed Apr 26 20:48:05 2006'


你将注意到,一个对象在第一次被包装时,创建,修改,及最后一次访问时间都是一样的。一
旦对象被访问,访问时间即被更新,但其它的没有动。如果使用 set()来置换对象,则修改和最后一
次访问时间会被更新。例子中,最后是对对象的读访问操作。
>>> timeWrappedObj.set('time is up!')
>>> timeWrappedObj.gettimestr('m')
'Wed Apr 26 20:48:35 2006'
>>> timeWrappedObj
'time is up!'
>>> timeWrappedObj.gettimestr('c')
'Wed Apr 26 20:47:41 2006'
>>> timeWrappedObj.gettimestr('m')
'Wed Apr 26 20:48:35 2006'
>>> timeWrappedObj.gettimestr('a')
'Wed Apr 26 20:48:46 2006'
改进包装一个特殊对象
下一个例子,描述了一个包装文件对象的类。我们的类与一般带一个异常的文件对象行为完全
一样:在写模式中,字符串只有全部为大写时,才写入文件。
这里,我们要解决的问题是,当你正在写一个文本文件,其数据将会被一台旧电脑读取。很多
老式机器在处理时,严格要求大写字母,所以,我们要实现一个文件对象,其中所有写入文件的文
本会自动转化为大写,程序员就不必担心了。
事实上,唯一值得注意的不同点是并不使用 open()内建函数,而是调用 CapOpen 类时行初始化。
尽管,参数同 open()完全一样。
例 13.8 展示那段代码,文件名是 capOpen.py。下面看一下例子中是如何使用这个类的:
>>> f = CapOpen('/tmp/xxx', 'w')
>>> f.write('delegation example\n')
>>> f.write('faye is good\n')
>>> f.write('at delegating\n')
>>> f.close()
>>> f
<closed file '/tmp/xxx', mode 'w' at 12c230>
例 13.8 包装文件对象(capOpen.py)


这个类扩充了 Python FAQs 中的一个例子,提供一个文件类对象,定制 write()方法,同时,给
文件对象授权其它的功能。
1 #!/usr/bin/env python
2
3 class CapOpen(object):
4 def __init__(self, fn, mode='r', buf=-1):
5     self.file = open(fn, mode, buf)
6
7 def __str__(self):
8     return str(self.file)
9
10 def __repr__(self):
11        return 'self.file'
12
13 def write(self, line):
14        self.file.write(line.upper())
15
16 def __getattr__(self, attr):
17      return getattr(self.file, attr)
可以看到,唯一不同的是第一次对 CapOpen()的调用,而不是 open()。如果你正与一个实际文
件对象,而非行为像文件对象的类实例进行交互,那么其它所有代码与你本该做的是一样的。除了
write(),所有属性都已授权给文件对象。为了确定代码是否正确,我们加载文件,并显示其内容。
(注:可以使用 open()或 CapOpen(),这里因在本例中用到,所以选用 CapOpen()。)
>>> f = CapOpen('/tmp/xxx', 'r')
>>> for eachLine in f:
...       print eachLine,
...
DELEGATION EXAMPLE FAYE IS GOOD
AT DELEGATING
13.16      新式类的高级特性 (Python 2.2+)
13.16.1 新式类的通用特性
我们已提讨论过有关新式类的一些特性。由于类型和类的统一,这些特性中最重要的是能够子
类化 Python 数据类型。其中一个副作用是,所有的 Python 内建的 “casting” 或转换函数现在都


是工厂函数。当这些函数被调用时,你实际上是对相应的类型进行实例化。
下面的内建函数,跟随 Python 多日,都已“悄悄地”(也许没有)转化为工厂函数:
z int(), long(), float(), complex()
z str(), unicode()
z list(), tuple()
z type()
还有,加入了一些新的函数来管理这些“散兵游勇”:
z basestring()1
z dict()
z bool()
z set(),2    frozenset()2
z object()
z classmethod()
z staticmethod()
z super()
z property()
z file()
这些类名及工厂函数使用起来,很灵活。不仅能够创建这些类型的新对象,它们还可以用来作
为基类,去子类化类型,现在还可以用于 isinstance()内建函数。使用 isinstance()能够用于替
换用烦了的旧风格,而使用只需少量函数调用就可以得到清晰代码的新风格。比如,为测试一个对
象是否是一个整数,旧风格中,我们必须调用 type()两次或者 import 相关的模块并使用其属性;但
现在只需要使用 isinstance(),甚至在性能上也有所超越:
OLD (not as good):
z if type(obj) == type(0)...
z if type(obj) == types.IntType...
BETTER:
z if type(obj) is type(0)...
EVEN BETTER:
z   if isinstance(obj, int)...
z   if isinstance(obj, (int, long))...
z   if type(obj) is int...
记住:尽管 isinstance()很灵活,但它没有执行“严格匹配”比较----如果 obj 是一个给定类
型的实例或其子类的实例,也会返回 True。但如果想进行严格匹配,你仍然需要使用 is 操作符。


1.   Python 2.3 中新增。
2.   Python 2.4 中新增。
请复习 13.12.2 节中有关 isinstance()的深入解释,还有在第 4 章中介绍这些调用是如何随同
Python 的变化而变化的。
13.16.2 __slots__类属性
字典位于实例的“心脏”。__dict__属性跟踪所有实例属性。举例来说,你有一个实例 inst.它
有一个属性 foo,那使用 inst.foo 来访问它与使用 inst.__dict__['foo']来访问是一致的。
字典会占据大量内存,如果你有一个属性数量很少的类,但有很多实例,那么正好是这种情况。
为内存上的考虑,用户现在可以使用__slots__属性来替代__dict__。
基本上,__slots__是一个类变量,由一序列型对象组成,由所有合法标识构成的实例属性的集
合来表示。它可以是一个列表,元组或可迭代对象。也可以是标识实例能拥有的唯一的属性的简单
字符串。任何试图创建一个其名不在__slots__中的名字的实例属性都将导致 AttributeError 异常:
class SlottedClass(object):
__slots__ = ('foo', 'bar')
>>> c = SlottedClass()
>>>
>>> c.foo = 42
>>> c.xxx = "don't think so" Traceback (most recent call last):
File "<stdin>", line 1, in ?
AttributeError: 'SlottedClass' object has no attribute
'xxx'
这种特性的主要目的是节约内存。其副作用是某种类型的"安全",它能防止用户随心所欲的动态
增 加 实 例 属 性 。 带 __slots__ 属 性 的 类 定 义 不 会 存 在 __dict__ 了 ( 除 非 你 在 __slots__ 中 增 加
'__dict__'元素)。更多有关__slots__的信息,请参见 Python(语言)参考手册中有关数据模型章
节。
13.16.3      特殊方法__getattribute__()
Python 类有一个名为__getattr__()的特殊方法,它仅当属性不能在实例的__dict__或它的类
(类的__dict__),或者祖先类(其__dict__)中找到时,才被调用。我们曾在实现授权中看到过使
用__getattr__()。


很多用户碰到的问题是,他们想要一个适当的函数来执行每一个属性访问,不光是当属性不能
找到的情况。这就是__getattribute__()用武之处了。它使用起来,类似__getattr__(),不同之处
在于,当属性被访问时,它就一直都可以被调用,而不局限于不能找到的情况。
如果类同时定义了__getattribute__()及__getattr__()方法,除非明确从__get-attribute__()
调用,或__getattribute__()引发了 AttributeError 异常,否则后者不会被调用.
如果你将要在此(译者注:__getattribute__()中)访问这个类或其祖先类的属性,请务必小心。
如果你在__getattribute__()中不知何故再次调用了__getattribute__(),你将会进入无穷递归。
为避免在使用此方法时引起无穷递归,为了安全地访问任何它所需要的属性,你总是应该调用祖先类
的同名方法;比如,super(obj,self).__getattribute__(attr)。此特殊方法只在新式类中有效。
同 __slots__ 一 样 , 你 可 以 参 考 Python ( 语 言 ) 参 考 手 册 中 数 据 模 型 章 节 , 以 得 到 更 多 有 关
__getattribute__()的信息。
13.16.4     描述符
描述符是 Python 新式类中的关键点之一。它为对象属性提供强大的 API。你可以认为描述符是
表示对象属性的一个代理。当需要属性时,可根据你遇到的情况,通过描述符(如果有)或者采用
常规方式(句点属性标识法)来访问它。
如你的对象有代理,并且这个代理有一个“get”属性(实际写法为__get__),当这个代理被调
用时,你就可以访问这个对象了。当你试图使用描述符(set)给一个对象赋值或删除一个属性
(delete)时,这同样适用。
__get__(),__set__(),__delete__()特殊方法
严格来说,描述符实际上可以是任何(新式)类,这种类至少实现了三个特殊方法
__get__(),__set__()及__delete__()中的一个,这三个特殊方法充当描述符协议的作用。刚才提到
过,__get__()可用于得到一个属性的值,__set__()是为一个属性进行赋值的,在采用 del 语句(或
其它,其引用计数递减)明确删除掉某个属性时会调__delete__()方法。三者中,后者很少被实现。
还有,也不是所有的描述符都实现了__set__()方法。它们被当作方法描述符,或更准确来说是,
非数据描述符来被引用。那些同时覆盖__get__()及__set__()的类被称作数据描述符,它比非数据
描述符要强大些。
The signatures for __get__(), __set__(), and __delete__() look like this:
__get__(),__set__()及__delete__()的原型,如下:
z def __get__(self, obj, typ=None) ==>           value
z def __set__(self, obj, val) ==>        None


z   def __delete__(self, obj) ==>      None
如果你想要为一个属性写个代理,必须把它作为一个类的属性,让这个代理来为我们做所有的
工作。当你用这个代理来处理对一个属性的操作时,你会得到一个描述符来代理所有的函数功能。
我们在前面的一节中已经讲过封装的概念。这里我们会进一步来探讨封装的问题。现在让我们来处
理更加复杂的属性访问问题,而不是将所有任务都交给你所写的类中的对象们。
__getattribute__() 特殊方法(二)
使用描述符的顺序很重要,有一些描述符的级别要高于其它的。整个描述符系统的心脏是
__getattribute__(),因为对每个属性的实例都会调用到这个特殊的方法。这个方法被用来查找类
的属性,同时也是你的一个代理,调用它可以进行属性的访问等操作。
回顾一下上面的原型,如果一个实例调用了__get__()方法,这就可能传入了一个类型或类的对
象。举例来说,给定类 X 和实例 x, x.foo 由__getattribute__()转化成:
type(x).__dict__['foo'].__get__(x, type(x))
如果类调用了__get__()方法,那么 None 将作为对象被传入(对于实例, 传入的是 self):
X.__dict__['foo'].__get__(None, X)
最后,如果 super()被调用了,比如,给定 Y 为 X 的子类,然后用 super(Y,obj).foo 在
obj.__class__.__mro__中紧接类 Y 沿着继承树来查找类 X,然后调用:
X.__dict__['foo'].__get__(obj, X)
然后,描述符会负责返回需要的对象。
优先级别
由于__getattribute__()的实现方式很特别,我们在此对__getattribute__()方法的执行方式
做一个介绍。因此了解以下优先级别的排序就非常重要了:
z   类属性
z   数据描述符
z   实例属性
z   非数据描述符
z   默认为__getattr__()


描述符是一个类属性,因此所有的类属性皆具有最高的优先级。你其实可以通过把一个描述符
的引用赋给其它对象来替换这个描述符。比它们优先级别低一等的是实现了__get__()和__set__()
方法的描述符。如果你实现了这个描述符,它会像一个代理那样帮助你完成所有的工作!
否则,它就默认为局部对象的__dict__的值,也就是说,它可以是一个实例属性。接下来是非
数据描述符。可能第一次听起来会吃惊,有人可能认为在这条“食物链”上非数据描述符应该比实
例属性的优先级更高,但事实并非如此。非数据描述符的目的只是当实例属性值不存在时,提供一
个 值 而 已 。 这 与 以 下 情 况 类 似 : 当 在 一 个 实 例 的 __dict__ 中 找 不 到 某 个 属 性 时 , 才 去 调 用
__getattr__()。
关于__getattr__()的说明,如果没有找到非数据描述符,那么__getattribute__()将会抛出一
个 AttributeError 异常,接着会调用__getattr__()做为最后一步操作,否则 AttributeError 会 返
回给用户。
描述符举例
让我们来看一个简单的例子...用一个描述符禁止对属性进行访问或赋值的请求。事实上,以下
所有示例都忽略了全部请求,但它们的功能逐步增多,我们希望你通过每个示例逐步掌握描述符的
使用:
class DevNull1(object):
def __get__(self, obj, typ=None):
pass
def __set__(self, obj, val):
pass
我们建立一个类,这个类使用了这个描述符,给它赋值并显示其值:
>>> class C1(object):
...      foo = DevNull1()
...
>>> c1 = C1()
>>> c1.foo = 'bar'
>>> print 'c1.foo contains:', c1.foo
c1.foo contains: None
That was not too terribly exciting ... how about one where the descriptor methods at
least give some output to show what is going on?
这并没有什么有趣的 ... 让我们来看看在这个描述符中写一些输出语句会怎么样?


class DevNull2(object):
def __get__(self, obj, typ=None):
print 'Accessing attribute... ignoring'
def __set__(self, obj, val):
print 'Attempt to assign %r... ignoring' % (val)
现在我们来看看修改后的结果:
>>> class C2(object):
...    foo = DevNull2()
...
>>> c2 = C2()
>>> c2.foo = 'bar'
Attempt to assign 'bar'... ignoring
>>> x = c2.foo
Accessing attribute... ignoring
>>> print 'c2.foo contains:', x
c2.foo contains: None
最后,我们在描述符所在的类中添加一个占位符,占位符包含有关于这个描述符的有用信息:
class DevNull3(object):
def __init__(self, name=None):
self.name = name
def __get__(self, obj, typ=None):
print 'Accessing [%s]... ignoring' %
self.name)
def __set__(self, obj, val):
print 'Assigning %r to [%s]... ignoring' %
val, self.name)
下面的输出结果表明我们前面提到的优先级层次结构的重要性,尤其是我们说过,一个完整的
数据描述符比实例的属性具有更高的优先级:
>>> class C3(object):
...      foo = DevNull3('foo')
...
>>> c3 = C3()
>>> c3.foo = 'bar'
Assigning 'bar' to [foo]... ignoring


>>> x = c3.foo
Accessing [foo]... ignoring
>>> print 'c3.foo contains:', x
c3.foo contains: None
>>> print 'Let us try to sneak it into c3 instance...'
Let us try to sneak it into c3 instance...
>>> c3.__dict__['foo'] = 'bar'
>>> x = c3.foo
Accessing [foo]... ignoring
>>> print 'c3.foo contains:', x
c3.foo contains: None
>>> print "c3.__dict__['foo'] contains: %r" % \
c3.__dict__['foo'], "... why?!?"
c3.__dict__['foo'] contains: 'bar' ... why?!?
请注意我们是如何给实例的属性赋值的。给实例属性 c3.foo 赋值为一个字符串“bar”                            。但由于
数据描述符比实例属性的优先级高,所赋的值“bar”被隐藏或覆盖了。
同样地,由于实例属性比非数据描述符的优先级高,你也可以将非数据描述符隐藏。这就和你
给一个实例属性赋值,将对应类的同名属性隐藏起来是同一个道理:
>>> class FooFoo(object):
...       def foo(self):
...          print 'Very important foo() method.'
...
>>>
>>> bar = FooFoo()
>>> bar.foo()
Very important foo() method.
>>>
>>> bar.foo = 'It is no longer here.'
>>> bar.foo
'It is no longer here.'
>>>
>>> del bar.foo
>>> bar.foo()
Very important foo() method.
这是一个直白的示例。我们将 foo 做为一个函数调用,然后又将它作为一个字符串访问,但我
们也可以使用另一个函数,而且保持相同的调用机制:


>>> def barBar():
...       print 'foo() hidden by barBar()'
...
>>> bar.foo = barBar
>>> bar.foo()
foo() hidden by barBar()
>>>
>>> del bar.foo
>>> bar.foo()
Very important foo() method.
要强调的是:函数是非数据描述符,实例属性有更高的优先级,我们可以遮蔽任一个非数据描
述符,只需简单的把一个对象赋给实例(使用相同的名字)就可以了。
我们最后这个示例完成的功能更多一些,它尝试用文件系统保存一个属性的内容,这是个雏形
版本。
第 1-10 行
在引入相关模块后,我们编写一个描述符类,类中有一个类属性(saved), 它用来记录描述符
访问的所有属性。描述符创建后,它将注册并且记录所有从用户处接收的属性名。
第 12-26 行
在获取描述符的属性之前,我们必须确保用户给它们赋值后才能使用。如果上述条件成立,接
着我们将尝试打开 pickle 文件以读取其中所保存的值。如果文件打开失败,将引发一个异常。文件
打开失败的原因可能有以下几种:文件已被删除了(或从未创建过),或是文件已损坏,或是由于某
种原因,不能被 pickle 模块反串行化。
第 18-38 行
将属性保存到文件中需要经过以下几个步骤:打开用于写入的 pickle 文件(可能是首次创建一
个新的文件,也可能是删掉旧的文件),将对象串行化到磁盘,注册属性名,使用户可以读取这些属
性值。如果对象不能被 pickle{待统一命名},将引发一个异常。注意,如果你使用的是 Python2.5
以前的版本,你就不能合并 try-except 和 try-finally 语句(第 30-38 行)。
例 13.9 使用文件来存储属性(descr.py)
这个类是一个雏形,但它展示了描述符的一个有趣的应用--可以在一个文件系统上保存属性
的内容。
1 #!/usr/bin/env python
2


3 import os
4 import pickle
5
6 class FileDescr(object):
7     saved = []
8
9     def __init__(self, name=None):
10            self.name = name
11
12        def __get__(self, obj, typ=None):
13            if self.name not in FileDescr.saved:
14               raise AttributeError, \
15                    "%r used before assignment" % self.name
16
17            try:
18               f = open(self.name, 'r')
19               val = pickle.load(f)
20               f.close()
21             return val
22           except(pickle.InpicklingError, IOError,
23                 EOFError, AttributeError,
24                 ImportError, IndexError), e:
25              raise AttributeError, \
26                    "could not read %r: %s" % self.name
27
28        def __set__(self, obj, val):
29            f = open(self.name, 'w')
30            try:
31               try:
32                    pickle.dump(val, f)
33                  FileDescr.saved.append(self.name)
34           except (TypeError, pickle.PicklingError), e:
35                  raise AttributeError, \
36                       "could not pickle %r" % self.name
37            finally:
38              f.close()
39
40       def __delete__(self, obj):
41           try:
42              os.unlink(self.name)


43              FileDescr.saved.remove(self.name)
44            except (OSError, ValueError), e:
45              pass
第 40-45 行
最后,如果属性被删除了,文件会被删除,属性名字也会被注销。以下是这个类的用法示例:
>>> class MyFileVarClass(object):
...
foo = FileDescr('foo')
...
bar = FileDescr('bar')
...
>>> fvc = MyFileVarClass()
>>> print fvc.foo
Traceback (most recent call last): File "<stdin>", line 1, in ?
File "descr.py", line 14, in __get__
raise AttributeError, \
AttributeError: 'foo' used before assignment
>>>
>>> fvc.foo = 42
>>> fvc.bar = 'leanna'
>>>
>>> print fvc.foo, fvc.bar
42 leanna
>>>
>>> del fvc.foo
>>> print fvc.foo, fvc.bar
Traceback (most recent call last): File "<stdin>", line 1, in ?
File "descr.py", line 14, in __get__
raise AttributeError, \
AttributeError: 'foo' used before assignment
>>>
>>> fvc.foo = __builtins__ Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "descr.py", line 35, in __set__
raise AttributeError, \ AttributeError: could not pickle 'foo'
属性访问没有什么特别的,程序员并不能准确判断一个对象是否能被打包后存储到文件系统中
(除非如最后示例所示,将模块 pickle,我们不该这样做)。我们也编写了异常处理的语句来处理文


件损坏的情况。在本例中,我们第一次在描述符中实现__delete__()方法。
请注意,在示例中,我们并没有用到 obj 的实例。别把 obj 和 self 搞混淆,这个 self 是指描
述符的实例,而不是类的实例。
描述符总结
你已经看到描述符是怎么工作的。静态方法、类方法、属性(见下面一节),甚至所有的函数都
是描述符。想一想:函数是 Python 中常见的对象。有内置的函数、用户自定义的函数、类中定义的
方法、静态方法、类方法。这些都是函数的例子。 它们之间唯一的区别在于调用方式的不同。通常,
函数是非绑定的。虽然静态方法是在类中被定义的,它也是非绑定的。但方法必须绑定到一个实例
上,类方法必须绑定到一个类上,对不?一个函数对象的描述符可以处理这些问题,描述符会根据
函数的类型确定如何“封装”这个函数和函数被绑定的对象,然后返回调用对象。它的工作方式是
这样的:函数本身就是一个描述符,函数的__get__()方法用来处理调用对象,并将调用对象返回给
你。描述符具有非常棒的适用性,因此从来不会对 Python 自己的工作方式产生影响。
属性和 property()内建函数
属性是一种有用的特殊类型的描述符。它们是用来处理所有对实例属性的访问,其工作方式和
我们前面说过的描述符相似。“一般”情况下,当你使用点属性符号来处理一个实例属性时,其实
你是在修改这个实例的__dict__属性。
表面上来看,你使用 property()访问和一般的属性访问方法没有什么不同,但实际上这种访问
的实现是不同的 - 它使用了函数(或方法)。在本章的前面,你已看到在 Python 的早期版本中,我
们一般用__getattr__() 和 __setattr__() 来处理和属性相关的问题。属性的访问会涉及到以上特
殊的方法(和__getattribute__()),但是如果我们用 property()来处理这些问题,你就可以写一个
和属性有关的函数来处理实例属性的获取(getting),赋值(setting),和删除(deleting)操作,而不
必再使用那些特殊的方法了(如果你要处理大量的实例属性,使用那些特殊的方法将使代码变得很臃
肿)。
property()内建函数有四个参数,它们是 :
property(fget=None, fset=None, fdel=None, doc=None)
请注意 property()的一般用法是,将它写在一个类定义中,property()接受一些传进来的函数
(其实是方法)作为参数。实际上,property()是在它所在的类被创建时被调用的,这些传进来的(作
为参数的)方法是非绑定的,所以这些方法其实就是函数!
下面的一个例子:在类中建立一个只读的整数属性,用逐位异或操作符将它隐藏起来:


class ProtectAndHideX(object):
def __init__(self, x):
assert isinstance(x, int), \
'"x" must be an integer!'
self.__x = ~x
def get_x(self):
return ~self.__x
x = property(get_x)
我们来运行这个例子,会发现它只保存我们第一次给出的值,而不允许我们对它做第二次修改:
>>> inst = ProtectAndHideX('foo')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "prop.py", line 5, in __init__
assert isinstance(x, int), \
AssertionError: "x" must be an integer!
>>> inst = ProtectAndHideX(10)
>>> print 'inst.x =', inst.x
inst.x = 10
>>> inst.x = 20
Traceback (most recent call last):
File "<stdin>", line 1, in ?
AttributeError: can't set attribute
下面是另一个关于 setter 的例子:
class HideX(object):
def __init__(self, x):
self.x = x
def get_x(self):
return ~self.__x
def set_x(self, x):
assert isinstance(x, int), \
'"x" must be an integer!'
self.__x = ~x


x = property(get_x, set_x)
本示例的输出结果:
>>> inst = HideX(20)
>>> print inst.x
20
>>> inst.x = 30
>>> print inst.x
30
属性成功保存到 x 中并显示出来,是因为在调用构造器给 x 赋初始值前,在 getter 中已经将~x
赋给了 self.__x.
你还可以给自己写的属性添加一个文档字符串,参见下面这个例子:
from math import pi
def get_pi(dummy):
return pi
class PI(object):
pi = property(get_pi, doc='Constant "pi"')
为了说明这是可行的实现方法,我们在 property 中使用的是一个函数而不是方法。注意在调用
函数时 self 作为第一个(也是唯一的)参数被传入,所以我们必须加一个伪变量把 self 丢弃。下面
是本例的输出:
>>> inst = PI()
>>> inst.pi
3.1415926535897931
>>> print PI.pi.__doc__
Constant "pi"
你明白 properties 是如何把你写的函数(fget, fset 和 fdel)影射为描述符的__get__(),
__set__(), 和__delete__()方法的吗?你不必写一个描述符类,并在其中定义你要调用的这些方法。
只要把你写的函数(或方法)全部传递给 property()就可以了。
在你写的类定义中创建描述符方法的一个弊端是它会搞乱类的名字空间。不仅如此,这种做法


也不会像 property()那样很好地控制属性访问。如果不用 property()这种控制属性访问的目的就不
可能实现。我们的第二个例子没有强制使用 property(),因为它允许对属性方法的访问(由于在类定
义中包含属性方法):
>>> inst.set_x(40) # can we require inst.x = 40?
>>> print inst.x
40
APNPC(ActiveState Programmer Network Python Cookbook)
(http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/205183) 上 的 一 条 精 明 的 办
法解决了以下问题:
z   “借用”一个函数的名字空间
z   编写一个用作内部函数的方法作为 property()的(关键字)参数
z   (用 locals())返回一个包含所有的(函数/方法)名和对应对象的字典
z   把字典传入 property(),然后
z  去掉临时的名字空间
这样,方法就不会再把类的名字空间搞乱了,因为定义在内部函数中的这些方法属于其它的
名字空间。由于这些方法所属的名字空间已超出作用范围,用户是不能够访问这些方法的,所以通
过使用属性 property()来访问属性就成为了唯一可行的办法。根据 APNPC 上方法,我们来修改这个
类:
class HideX(object):
def __init__(self, x):
self.x = x
@property
def x():
def fget(self):
return ~self.__x
def fset(self, x):
assert isinstance(x, int), \
'"x" must be an integer!'
self.__x = ~x
return locals()
我们的代码工作如初,但有两点明显不同:(1) 类的名字空间更加简洁,只有 ['__doc__',


'__init__', '__module__', 'x'], (2), 用户不能再通过 inst.set_x(40) 给属性赋值 ... 必须
使用 init.x = 40. 我们还使用函数修饰符 (@property) 将函数中的 x 赋值到一个属性对象。由于
修饰符是从 Python 2.4 版本开始引入的,如果你使用的是 Python 的早期版本 2.2.x 或 2.3.x,请
将修饰符@property 去掉,在 x()的函数声明后添加 x = property(**x())。
13.16.5      Metaclasses 和__metaclass__
元类(Metaclasses)是什么?
元类可能是添加到新风格类中最难以理解的功能了。元类让你来定义某些类是如何被创建的,
从根本上说,赋予你如何创建类的控制权。(你甚至不用去想类实例层面的东西。)早在 Python1.5
的时代,人们就在谈论这些功能(当时很多人都认为不可能实现),但现在终于实现了。
从根本上说,你可以把元类想成是一个类中类,或是一个类,它的实例是其它的类。实际上,
当你创建一个新类时,你就是在使用默认的元类,它是一个类型对象。(对传统的类来说,它们的元
类是 types.ClassType.)当某个类调用 type()函数时,你就会看到它到底是谁的实例:
class C(object):
pass
class CC:
pass
>>> type(C)
<type 'type'>
>>>
>>> type(CC)
<type 'classobj'>
>>>
>>> import types
>>> type(CC) is types.ClassType
True
什么时候使用元类?
元类一般用于创建类。在执行类定义时,解释器必须要知道这个类的正确的元类。解释器会先
寻找类属性__metaclass__,如果此属性存在,就将这个属性赋值给此类作为它的元类。如果此属性
没有定义,它会向上查找父类中的__metaclass__. 所有新风格的类如果没有任何父类,会从对象或
类型中继承。(type (object) 当然是类型).


如果还没有发现__metaclass__属性,解释器会检查名字为__metaclass__的全局变量,如果它
存在,就使用它作为元类。否则, 这个类就是一个传统类,并用 types.ClassType 作为此类的元类。
(注意:在这里你可以运用一些技巧... 如果你定义了一个传统类,并且设置它的__metaclass__ =
type,其实你是在将它升级为一个新风格的类!)
在执行类定义的时候,将检查此类正确的(一般是默认的)元类,元类(通常)传递三个参数(到构
造器):类名,从基类继承数据的元组,和(类的)属性字典。
谁在用元类?
元类这样的话题对大多数人来说属于理论化或纯面向对象思想的范畴,认为它在实际编程中没
有什么实际意义。从某种意义上讲这种想法是正确的;但最重要的请铭记在心的是,元类的最终使
用者不是用户,正是程序员自己。你通过定义一个元类来“迫使”程序员按照某种方式实现目标类,
这将既可以简化他们的工作,也可以使所编写的程序更符合特定标准。
元类何时被创建?
前面我们已提到创建的元类用于改变类的默认行为和创建方式。大多数 Python 用户都无须创
建或明确地使用元类。创建一个新风格的类或传统类的通用做法是使用系统自己所提供的元类的默
认方式。
用户一般都不会觉察到元类所提供的创建类(或元类实例化)的默认模板方式。虽然一般我们并
不创建元类,还是让我们来看下面一个简单的例子。(关于更多这方面的示例请参见本节末尾的文档
列表。)
元类示例 1
我们第一个关于元类的示例非常简单(希望如此)。它只是在用元类创建一个类时,显示时间标
签。(你现在该知道,这发生在类被创建的时候。)
看下面这个脚本。它包含的 print 语句散落在代码各个地方,便于我们了解所发生的事情:
#!/usr/bin/env python
from time import ctime
print '*** Welcome to Metaclasses!'
print '\tMetaclass declaration first.'


class MetaC(type):
def __init__(cls, name, bases, attrd):
super(MetaC, cls).__init__(name, bases, attrd)
print '*** Created class %r at: %s' % (name, ctime())
print '\tClass "Foo" declaration next.'
class Foo(object):
__metaclass__ = MetaC
def __init__(self):
print '*** Instantiated class %r at: %s' % (
self.__class__.__name__, ctime())
print '\tClass "Foo" instantiation next.'
f = Foo()
print '\tDONE'
当我们执行此脚本时,将得到以下输出:
*** Welcome to Metaclasses! Metaclass declaration first. Class "Foo" declaration next.
*** Created class 'Foo' at: Tue May 16 14:25:53 2006
Class "Foo" instantiation next.
*** Instantiated class 'Foo' at: Tue May 16 14:25:53 2006
DONE
当你明白了一个类的定义其实是在完成某些工作的事实以后,你就容易理解这是怎么一回事情
了。
元类示例 2
在第二个示例中,我们将创建一个元类,要求程序员在他们写的类中提供一个__str__()方法的
实现,这样用户就可以看到比我们在本章前面所见到的一般 Python 对象字符串(<object object at
id>)更有用的信息。
如果您还没有在类中覆盖__repr__()方法,元类会(强烈)提示您这么做,但这只是个警告。如
果未实现__str__()方法,将引发一个 TypeError 的异常,要求用户编写一个同名方法。以下是关于
元类的代码:
from warnings import warn


class ReqStrSugRepr(type):
def __init__(cls, name, bases, attrd):
super(ReqStrSugRepr, cls).__init__(
name, bases, attrd)
if '__str__' not in attrd:
raise TypeError("Class requires overriding of __str__()")
if '__repr__' not in attrd:
warn('Class suggests overriding of __repr__()\n', stacklevel=3)
我们编写了三个关于元类的示例,其中一个(Foo)重载了特殊方法__str__()和__repr__(),另一
个(Bar)只实现了特殊方法__str__(),还有一个(FooBar)没有实现__str__()和 __repr__(),这种
情况是错误的。完整的程序见示例 13.10.
执行此脚本,我们得到如下输出:
$ python meta.py
*** Defined ReqStrSugRepr (meta)class
*** Defined Foo class
sys:1: UserWarning: Class suggests overriding of
__repr__()
*** Defined Bar class
Traceback (most recent call last): File "meta.py", line 43, in ?
class FooBar(object):
File "meta.py", line 12, in __init__
raise TypeError(
TypeError: Class requires overriding of __str__()
示例 13.10     元类示例 (meta.py)
这个模块有一个元类和三个受此元类限定的类。每创建一个类,将打印一条输出语句。
1 #!/usr/bin/env python
2
3 from warnings import warn


4
5 class ReqStrSugRepr(type):
6
7     def __init__(cls, name, bases, attrd):
8          super(ReqStrSugRepr, cls).__init__(
9             name, bases, attrd)
10
11            if '__str__' not in attrd:
12                raise TypeError(
13               "Class requires overriding of __str__()")
14
15            if '__repr__' not in attrd:
16               warn(
17               'Class suggests overriding of __repr__()\n',
18                     stacklevel=3)
19
20 print '*** Defined ReqStrSugRepr (meta)class\n'
21
22 class Foo(object):
23       __metaclass__ = ReqStrSugRepr
24
25      def __str__(self):
26            return 'Instance of class:', \
27               self.__class__.__name__
28
29        def __repr__(self):
30            return self.__class__.__name__
31
32 print '*** Defined Foo class\n'
33
34 class Bar(object):
35        __metaclass__ = ReqStrSugRepr
36
37        def __str__(self):
38           return 'Instance of class:', \
39              self.__class__.__name__
40
41 print '*** Defined Bar class\n'
42
43 class FooBar(object):


44       __metaclass__ = ReqStrSugRepr
45
46   print '*** Defined FooBar class\n'
注意我们是如何成功声明 Foo 定义的;定义 Bar 时,提示警告__repr__()未实现;FooBar 的创
建没有通过安全检查,以致程序最后没有打印出关于 FooBar 的语句。另外要注意的是我们并没有创
建任何测试类的实例... 这些甚至根本不包括在我们的设计中。但别忘了这些类本身就是我们自己
的元类的实例。这个示例只显示了元类强大功能的一方面。
关于元类的在线文档众多,包括 Python 文档 PEPs 252 和 253,          《What’s New in Python 2.2》
文档,Guido van Rossum 所写的名为“Unifying Types and Classes in Python 2.2”的文章。在
Python 2.2.3 发布的主页上你也可以找到相关文档的链接地址。
13.17     相关模块和文档
我们在本章已经对核心语言做了讲述,而 Python 语言中有几个扩展了核心语言功能的经典类。
这些类为 Python 数据类型的子类化提供了方便。
模块好比速食品,方便即食。我们曾提到类可以有特殊的方法,如果实现了这些特殊方法,就
可以对类进行定制,这样当对一个标准类型封装时,可以给实例带来和类型一样的使用效果。
UserList 和 UserDict,还有新的 UserString(从 Python1.6 版本开始引入)分别代表对列表、字
典、字符串对象进行封装的类定义模块。这些模块的主要用处是提供给用户所需要的功能,这样你
就不必自己动手去实现它们了,同时还可以作为基类,提供子类化和进一步定制的功能。Python 语
言已经为我们提供了大量有用的内建类型,但这种"由你自己定制"类型的附加功能使得 Python 语言
更加强大。
在第四章里,我们介绍了 Python 语言的标准类型和其它内建类型。types 模块是进一步学习
Python 类型方面知识的好地方,其中的一些内容已超出了本书的讨论范围。types 模块还定义了一
些可以用于进行比较操作的类型对象。(这种比较操作在 Python 中很常见,因为它不支持方法的重
载 - 这简化的语言本身,同时又提供了一些工具,为貌似欠缺的地方添加功能.)
下面的代码检查传递到 foo 函数的数据对象是否是一个整数或一个字符串,不允许其他类型出
现(否则会引发一个异常):
def foo(data):
if isinstance(data, int):
print 'you entered an integer'
elif isinstance(data, str):


print 'you entered a string'
else:
raise TypeError, 'only integers or strings!'
最后一个相关模块是 operator 模块。这个模块提供了 Python 中大多数标准操作符的函数版本。
在某些情况下,这种接口类型比标准操作符的硬编码方式更通用。
请看下边的示例。在你阅读代码时,请设想一下如果此实现中使用的是一个个操作符的话,那
会多写多少行代码啊?
>>> from operator import *     # import all operators
>>> vec1 = [12, 24]
>>> vec2 = [2, 3, 4]
>>> opvec = (add, sub, mul, div) # using +, -, *, /
>>> for eachOp in opvec: # loop thru operators
...       for i in vec1:
...           for j in vec2:
...             print '%s(%d, %d) = %d' % \
...                   (eachOp.__name__, i, j, eachOp(i, j))
...
add(12, 2) = 14
add(12, 3) = 15
add(12, 4) = 16
add(24, 2) = 26
add(24, 3) = 27
add(24, 4) = 28
sub(12, 2) = 10
sub(12, 3) = 9
sub(12, 4) = 8
sub(24, 2) = 22
sub(24, 3) = 21
sub(24, 4) = 20
mul(12, 2) = 24
mul(12, 3) = 36
mul(12, 4) = 48
mul(24, 2) = 48
mul(24, 3) = 72
mul(24, 4) = 96
div(12, 2) = 6
div(12, 3) = 4


div(12,  4)  = 3
div(24,  2)  = 12
div(24,  3)  = 8
div(24,  4)  = 6
上面这段代码定义了三个向量,前两个包含着操作数,最后一个代表程序员打算对两个操作数
进行的一系列操作。最外层循环遍历每个操作运算,而最内层的两个循环用每个操作数向量中的元
素组成各种可能的有序数据对。最后,print 语句打印出将当前操作符应用在给定参数上所得的运算
结果。
我们前面介绍过的模块都列在表 13.5 中
表 13.5        与类相关的模块
模块                  说明
UserList         提供一个列表对象的封装类
UserDict         提供一个字典对象的封装类
UserString a    提供一个字符串对象的封装类;它又包括一个 MutableString 子类,如果有需
要,可以提供有关功能
types 定义所有 Python 对象的类型在标准 Python 解释器中的名字
operator 标准操作符的函数接口
a.   新出现于 Python 1.6 版本
在 Python FAQ 中,有许多与类和面向对象编程有关的问题。它对 Python 类库以及语言参考手
册都是很好的补充材料。关于新风格的类,请参考 PEPs252 和 253 和 Python2.2 以后的相关文档。
13.18     练习
13-1.    程序设计。请列举一些面向对象编程与传统旧的程序设计形式相比的先进之处。
13-2.    函数和方法的比较。函数和方法之间的区别是什么?
示例 13.11         金额转换程序 (moneyfmt.py)
字符串格式类用来对浮点数值进行"打包",使这个数值显示为带有正确符号的金额。
1 #!/usr/bin/env python
2
3 class MoneyFmt(object):
4 def __init__(self, value=0.0): # constructor #构造器


5 self.value = float(value)
6
7 def update(self, value=None): # allow updates #允许修改
8 ###
9 ### (a) complete this function
10 ###
11
12 def __repr__(self): # display as a float #显示为浮点数
13 return 'self.value'
14
15 def __str__(self): # formatted display             #格式化显示
16 val = ''
17
18 ###
19 ### (b) complete this function... do NOT
20 ### forget about negative numbers!!
21 ###
22
23 return val
24
25 def __nonzero__(self): # boolean test
26 ###
27 ### (c) find and fix the bug
28 ###
29
30 return int(self.value)
You will find the code skeleton for moneyfmt.py presented as Example 13.11. You will
find a fully documented (yet incomplete) version of moneyfmt.py on the Web site. If we were
to import the completed class within the interpreter, execution should behave similar to
the following:
>>> import moneyfmt
>>>
>>> cash = moneyfmt.MoneyFmt(123.45)
>>> cash
123.45
>>> print cash
$123.45
>>>


>>> cash.update(100000.4567)
>>> cash
100000.4567
>>> print cash
$100,000.46
>>>
>>> cash.update(-0.3)
>>> cash
-0.3
>>> print cash
-$0.30
>>> repr(cash)
'-0.3'
>>> 'cash'
'-0.3'
>>> str(cash)
'-$0.30'
13-3. 对类进行定制。写一个类,用来将浮点数值转换为金额。在本练习里,我们使用美国
货币,但读者也可以自选任意货币。
基本任务: 编写一个 dollarize()函数,它以一个浮点数值作为输入,返回一个字符串形式的
金额数。比如说:
dollarize(1234567.8901) ==> ‘$1,234,567.89.
dollarize()返回的金额数里应该允许有逗号(比如 1,000,000),和美元的货币符号。如果有负
号,它必须出现在美元符号的左边。完成这项工作后,你就可以把它转换成一个有用的类,名为
MoneyFmt。
MoneyFmt 类里只有一个数据值(即,金额),和五个方法(你可以随意编写其他方法)。__init__()
构造器对数据进行初始化,update()方法把数据值替换成一个新值,__nonzero__()是布尔型的,当
数据值非零时返回 True,__repr__()方法以浮点数的形式返回金额;而__str__()方法采用和
dollarize()一样的字符格式显示该值。
(a) 编写 update()方法,以实现数据值的修改功能。
(b) 以你已经编写的 dollarize()的代码为基础,编写__str__()方法的代码
(c) 纠正__nonzero__()方法中的错误,这个错误认为所有小于 1 的数值,例如,50 美分($0.50),
返回假值(False)。
(d) 附加题: 允许用户通过一个可选参数指定是把负数数值显示在一对尖括号里还是显示一个
负号。默认参数是使用标准的负号。
13-4.    用户注册。建立一个用户数据库(包括登录名、密码和上次登录时间戳)类(参考练习 7-5
和 9-12),来管理一个系统,该系统要求用户在登录后才能访问某些资源。这个数据库类对用户进行
管理,并在实例化操作时加载之前保存的用户信息,提供访问函数来添加或更新数据库的信息。在


数据修改后,数据库会在垃圾回收时将新信息保存到磁盘。(参见__del__()).
13-5.    几何. 创建一个由有序数值对(x, y) 组成的 Point 类,它代表某个点的 X 坐标和 Y 坐
标。X 坐标和 Y 坐标在实例化时被传递给构造器,如果没有给出它们的值,则默认为坐标的原点。
13-6.    几何. 创建一个直线/直线段类。除主要的数据属性:一对坐标值(参见上一个练习)外,
它还具有长度和斜线属性。你需要覆盖__repr__()方法(如果需要的话,还有__str__()方法),使得
代表那条直线(或直线段)的字符串表示形式是由一对元组构成的元组,即,((x1, y1), (x2, y2)).
总结:
__repr__   将直线的两个端点(始点和止点)显示成一对元组
length        返回直线段的长度 - 不要使用"len", 因为这样使人误解它是整数。
slope         返回此直线段的斜率(或在适当的时候返回 None)
13-7.    数据类。提供一个 time 模块的接口,允许用户按照自己给定时间的格式,比如:
“MM/DD/YY,” “MM/DD/YYYY,” “DD/MM/YY,” “DD/MM/ YYYY,” “Mon DD, YYYY,” 或是标准
的 Unix 日期格式:“Day Mon DD, HH:MM:SS YYYY” 来查看日期。你的类应该维护一个日期值,并
用给定的时间创建一个实例。如果没有给出时间值,程序执行时会默认采用当前的系统时间。还包
括另外一些方法:
update() 按给定时间或是默认的当前系统时间修改数据值
display() 以代表时间格式的字符串做参数,并按照给定时间的格式显示:
'MDY' ==> MM/DD/YY
'MDYY' ==> MM/DD/YYYY
'DMY' ==> DD/MM/YY
'DMYY' ==> DD/MM/YYYY
'MODYY' ==> Mon DD, YYYY
如果没有提供任何时间格式,默认使用系统时间或 ctime()的格式。附加题: 把这个类和练习
6-15 结合起来。
13-8.    堆栈类。一个堆栈(Stack)是一种具有后进先出(last-in-first-out,LIFO)特性的数
据结构。我们可以把它想象成一个餐盘架。最先放上去的盘子将是最后一个取下来的,而最后一个
放上去的盘子是最先被取下来的。你的类中应该有 push()方法(向堆栈中压入一个数据项)和 pop()
方法(从堆栈中移出一个数据项)。还有一个叫 isempty()的布尔方法,如果堆栈是空的,返回布尔值
1,否则返回 0;一个名叫 peek()的方法,取出堆栈顶部的数据项,但并不移除它。
注意,如果你使用一个列表来实现堆栈,那么 pop()方法从 Python1.5.2 版本起已经存在了。那
就在你编写的新类里,加上一段代码检查 pop()方法是否已经存在。如果经检查 pop()方法存在,就


调用这个内建的方法;否则就执行你自己编写的 pop()方法。你很可能要用到列表对象;如果用到它
时,不需要担心实现列表的功能(例如,切片)。只要确保你写的堆栈类能够正确实现上面的两项功
能就可以了。你可以用列表对象的子类或自己写个类似列表的对象,请参考示例 6.2.
13-9.   队列类。一个队列(queue)是一种具有先进先出(first-in-first-out,FIFO)特性的数
据结构。一个队列就像是一行队伍,数据从前端被移除,从后端被加入。这个类必须支持下面几种
方法:
enqueue()  在列表的尾部加入一个新的元素
dequeue()  在列表的头部取出一个元素,返回它并且把它从列表中删除。
请参见上面的练习和示例 6.3.
13-10.    堆栈和队列。编写一个类,定义一个能够同时具有堆栈(FIFO)和队列(LIFO)操作行为
的数据结构。这个类和 Perl 语言中数组相像。需要实现四个方法:
shift()    返回并删除列表中的第一个元素,类似于前面的 dequeue()函数。
unshift()  在列表的头部"压入"一个新元素
push()    在列表的尾部加上一个新元素,类似于前面的 enqueue()和 push()方法。
pop()     返回并删除列表中的最后一个元素,与前面的 pop()方法完全一样。
请参见练习 13-8 和 13-9.
13-11.    电子商务。
你需要为一家 B2C(商业到消费者)零售商编写一个基础的电子商务引擎。你需要写一个针对顾客
的类 User, 一个对应存货清单的类 Item, 还有一个对应购物车的类叫 Cart. 货物放到购物车里,顾
客可以有多个购物车。同时购物车里可以有多个货物,包括多个同样的货物。
13-12     聊天室. 你对目前的聊天室程序感到非常失望,并决心要自己写一个,创建一家新的
因特网公司,获得风险投资,把广告集成到你的聊天室程序中,争取在 6 个月的时间里让收入翻五
倍,股票上市,然后退休。但是,如果你没有一个非常酷的聊天软件,这一切都不会发生。
你需要三个类: 一个 Message 类,它包含一个消息字符串以及诸如广播、单方收件人等其他信
息,一个 User 类, 包含了进入你聊天室的某个人的所有信息。为了从风险投资者那里拿到启动资金,
你加了一个 Room 类,它体现了一个更加复杂的聊天系统,用户可以在聊天时创建单独的“聊天屋”,
并邀请其他人加入。附加题: 请为用户开发一个图形化用户界面应用程序。
13-13.    股票投资组合类.你的数据库中记录了每个公司的名字,股票代号,购买日期,购买
价格和持股数量。需要编写的方法包括:添加新代号(新买的股票)、删除代号(所有卖出股票),根
据当前价格(及日期)计算出的 YTD 或年回报率。请参见练习 7-6。


13-14.   DOS. 为 DOS 机器编写一个 UNIX 操作界面的 shell。你向用户提供一个命令行,使得
用户可以在那里输入 Unix 命令,你可以对这些命令进行解释,并返回相应的输出,例如:“ls”命
令调用“dir”来显示一个目录中的文件列表,                   “more”调用同名命令(分页显示一个文件),               “cat” 调
用 “type,” “cp” 调用“copy,” “mv” 调用 “ren,” “rm” 调用 “del,” 等.
13-15.   授权。示例 13.8 的执行结果表明我们的类 CapOpen 能成功完成数据的写入操作。在
我们的最后评论中,提到可以使用 CapOpen() 或 open()来读取文件中的文本。为什么呢?这两者使
用起来有什么差异吗?
13-16.   授权和函数编程。
(a) 请为示例 13.8 中的 CapOpen 类编写一个 writelines()方法。这个新函数将可以一次读入
多行文本,然后将文本数据转换成大写的形式,它与 write()方法的区别和通常意思上的 writelines()
与 write()方法之间的区别相似。注意:编写完这个方法后,writelines()将不再由文件对象"代理"。
(b) 在 writelines()方法中添加一个参数,用这个参数来指明是否需要为每行文本加上一个
换行符。此参数的默认值是 False,表示不加换行符。
13-17.   数值类型子类化。在示例 13.3 中所看到的 moneyfmt.py 脚本基础上修改它,使得它
可以扩展 Python 的浮点类型。请确保它支持所有操作,而且是不可变的。
13-18.   序列类型子类化。模仿前面练习 13-4 中的用户注册类的解决方案,编写一个子类。
要求允许用户修改密码,但密码的有效期限是 12 个月,过期后不能重复使用。附加题:支持“相
似密码”检测的功能(任何算法皆可),不允许用户使用与之前 12 个月期间所使用的密码相似的任何
密码。
13-19.   映射类型子类化。假设在 13.11.3 节中字典的子类,若将 keys()方法重写为:
def keys(self):
return sorted(self.keys())
(a)  What happens when keys() is called for a method?
(a)  当方法 keys()被调用,结果如何?
(b)  Why is this, and what makes our original solution work?
(b)  为什么会有这样的结果?如何使我们的原解决方案顺利工作?
13-20.   类的定制。改进脚本 time60.py,见 13.13.2 节,示例 13.3.
(a) 允许“空”实例化: 如果小时和分钟的值没有给出,默认为零小时、零分钟。
(b) 用零占位组成两位数的表示形式,因为当前的时间格式不符合要求。如下面的示例,wed
应该输出为“12:05.”


>>> wed = Time60(12, 5)
>>> wed
12:5
(c)除了用 hours (hr) 和 minutes (min)进行初始化外,还支持以下时间输入格式:
z 一个由小时和分钟组成的元组(10, 30)
z 一个由小时和分钟组成的字典({'hr': 10, 'min': 30})
z 一个代表小时和分钟的字符串("10:30")
附加题: 允许不恰当的时间字符串表示形式,如 “12:5”.
(d) 我们是否需要实现__radd__()方法? 为什么? 如果不必实现此方法,那我们什么时候可
以或应该覆盖它?
(e) __repr__()函数的实现是有缺陷而且被误导的。我们只是重载了此函数,这样我们可以省
去使用 print 语句的麻烦,使它在解释器中很好的显示出来。但是,这个违背了一个原则:对于可估
值的 Python 表达式,repr()总是应该给出一个(有效的)字符串表示形式。12:05 本身不是一个合法
的 Python 表达式,但 Time60('12:05')是合法的。请实现它。
(f)    添加六十进制(基数是 60)的运算功能。下面示例中的输出应该是 19:15,而不是 18:75:
>>> thu = Time60(10, 30)
>>> fri = Time60(8, 45)
>>> thu + fri
18:75
13-21.装饰符和函数调用语法。第 13.16.4 节末尾,我们使用过一个装饰函数符把 x 转化成一
个属性对象,但由于装饰符是 Python2.4 才有的新功能,我们给出了另一个适用于旧版本的语法:
X = property (**x()).
执行这个赋值语句时到底发生了什么呢?为什么它和使用装饰符语句是等价的?


执行环境
本章主题
z 可调用对象
z 代码对象
z 语句和内置函数
z 执行其他程序
z 终止执行
z 各类操作系统接口
z 相关模块


在 python 中有多种运行外部程序的方法,比如,运行操作系统命令或另外的 python 脚本,或
执行一个磁盘上的文件,或通过网络来运行文件。这完全取决于你想要干什么。有些特定的执行场
景包括:
z   在当前脚本继续运行
z   创建和管理子进程
z   执行外部命令或程序
z   执行需要输入的命令
z   通过网络来调用命令
z   执行命令来创建需要处理的输出
z   执行其他的 Python 脚本
z   执行一系列动态生成的 Python 语句
z   导入 Python 模块 (和执行它顶层的代码)
python 中,内建和外部模块都可以提供上述各种功能。程序员得根据实现的需要,从这些模块
中选择合适的处理方法。本章将对 python 执行环境进行全面的描述,但不会涉及如何启动 python
解释器和不同的命令行选项。读者可以从第二章中查阅到相关信息。
我们的 python 执行环境之旅从可调用对象开始,接着是代码对象,然后去看看什么样的 python
语句和内建函数适合支持我们需要的功能。        执行其他程序的能力不仅大大增强了 python 脚本的威力,
也节约了资源,因为重复实现这些代码肯定是不合逻辑的,更是浪费时间和人力。python 给当前脚
本环境提供了许多执行程序或者外部命令的机制,我们将介绍下最普遍的几个命令。接下来,我们


对 python 的受限执行环境作一个简短的概况,最后,介绍下各种终止执行的方法(而不是让程序正
常完成)。就从可调用对象开始我们的旅程吧。
14.1    可调用对象
许多的 python 对象都是我们所说的可调用的,即是任何能通过函数操作符“()”来调用的对象。
要调用可调用对象,函数操作符得紧跟在可调用对象之后。比方说,用“foo()”来调用函数"foo"。
可调用对象可以通过函数式编程接口来进行调用,如 apply(),filter(),map(),以及 reduce(),这
四个接口我们都在 11 章讨论过了。Python 有 4 种可调用对象:函数,方法,类,以及一些类的实例。
记住这些对象的任何引用或者别名都是可调用的。
14.1.1 函数
我们介绍的第一种可调用的对象是函数。python 有 3 种不同类型函数对象。第一种是内建函数。
内建函数(BIFs)
BIF 是用 c/c++写的,编译过后放入 python 解释器,然后把它们作为第一(内建)名字空间的
一部分加载进系统。如前面章节所提到的,这些函数在_bulitin_模块里,并作为__builtins__模
块导入到解释器中。
表 14.1 内建函数属性
BIF 属性               描述
bif.__doc__          文档字符串(或 None)
bif.__name__          字符串类型的文档名字
bif.__self__          设置为 None(保留给 built-in 方法)
bif.__module__        存放 bif 定义的模块名字(或 None)
BIF 有基础类型属性,其中一些独特的属性已列在表 14.1 中
你可以用 dir()列出函数的所有属性:
>>> dir(type)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__',
'__getattribute__', '__hash__', '__init__', '__module__',
'__name__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__self__', '__setattr__', '__str__']


从内部机制来看,因为 BIFs 和内建方法(BIMs)属于相同的类型,             所以对 BIF 或者 BIM 调用 type()
的结果是:
>>> type(dir)
<type 'builtin_function_or_method'>
注意这不能应用于工厂函数,因为 type()正好会返回产生对象的类型:
>>> type(int)
<type 'type'>
>>> type(type)
<type 'type'>
用户定义的函数(UDF)
UDF(User-Defined Function,用户定义的函数)通常是用 python 写的,定义在模块的最高级,
因此会作为全局名字空间的一部分(一旦创建好内建名字空间)装载到系统中。函数也可在其他的函
数体内定义,并且由于在 2.2 中嵌套作用域的改进,我们现在可以对多重嵌套作用域中的属性进行
访问。可以用 func_closure 属性来钩住在其他地方定义的属性。
表 14.2 用户自定义函数属性
UDF 属性             描述
udf.__doc__        文档字符串(也可以用 udf.func_doc)
udf.__name__       字符串类型的函数名字(也可以用 udf.func_name)
udf.func_code      字节编译的代码对象
udf.func_defaults     默认的参数元组
udf.func_globals   全局名字空间字典; 和从函数内部调用 globals(x)一样
udf.func_dict         函数属性的名字空间
udf.func_doc      (见上面的 udf.__doc__)
udf.func_name     (见上面的 udf.__name__)
udf.func_closure   包含了自由变量的引用的单元对象元组(自用变量在 UDF 中使用,但在别
处定义;参见 python[语言]参考手册)
如同上面的 BIFs,UDF 也有许多的属性。UDF 最让人感兴趣和最特殊的属性都列在下面的表 14.2
中
从内部机制来看,用户自定义的函数是“函数“类型的,如在下面的例子中用 type()表明的一
样:


>>> def foo(): pass
>>> type(foo)
<type 'function'>
lambda 表达式和用户自定义对函数相比,略有不同。虽然它们也是返回一个函数对象,但是
lambda 表达式不是用 def 语句创建的,而是用 lambda 关键字:
因为 lambda 表达式没有给命名绑定的代码提供基础结构,所以要通过函数式编程接口来调用,
或把它们的引用赋值给一个变量,然后就可以直接调用或者再通过函数来调用。变量仅是个别名,
并不是函数对象的名字。
通过 lambda 来创建函数的对象除了没有命名之外,享有和用户自定义函数相同的属性;__name__
或者 func_name 属性给定为字符串"<lambda>"。使用 type()工厂函数,我们来演示下 lambda 表达式
返回和用户自定义函数相同的函数对象。
>>> lambdaFunc = lambda x: x * 2
>>> lambdaFunc(100)
200
>>> type(lambdaFunc)
<type 'function'>
在上面的例子中,我们将表达式赋值给一个别名。我们也可以直接在一个 lambda 表达式上调
用 type():
>>> type(lambda:1)
<type 'function'>
我们快速的来看看 UDF 名字,使用上面的 lambdaFunc 和先前小节中的 foo():
>>> foo.__name__
'foo'
>>> lambdaFunc.__name__
'<lambda>'
从 11.9 小节中我们可以看到,一旦函数声明以后(且函数对象可用)                     ,程序员也可以自定义函
数属性。所有的新属性变成 udf.__dict__对象的一部分。在本章的稍后内容中,我们将讨论获取含
有 python 代码的字符串并执行该代码。到了本章最后,会有一个组合例子,着重描写函数属性和
python 代码(字符串)的动态求值和执行语句。


14.1.2 方法
在 13 章,我们研究了方法。用户自定义方法是被定义为类的一部分的函数。许多 python 数据
类型,比如列表和字典,也有方法,这些被称为内建方法。为了进一步说明“所有权“的类型,方
法通过对象的名字和句点属性标识进行命名。
14.3 内建方法(BIM)属性
BIM 属性          描述
bim.__doc__     文档字串
bim.__name__   字符串类型的函数名字
bim.__self__   绑定的对象
内建方法(BIMs)
在前面的小节中,我们讨论了内建方法与内建函数的类似之处。只有内建类型(BIT)有 BIM.正如
你在下面看到的,对于内建方法,type()工厂函数给出了和 BIF 相同的输出--注意,我们是如何提
供一个内建对象来访问 BIM:
>>> type([].append)
<type 'builtin_function_or_method'>
此外,BIM 和 BIF 两者也都享有相同属性。不同之处在于 BIM 的__self__属性指向一个 Python
对象,而 BIF 指向 None。
对于类和实例,都能以该对象为参数,通过内建函数 dir()来获得他们的数据和方法属性。这也
可以用在 BIM 上:
>>> dir([].append)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__',
'__getattribute__', '__hash__', '__init__', '__module__',
'__name__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__self__', '__setattr__', '__str__']
然而,不用多久就会发现,从功能上看,用实际的对象去访问其方法并不是非常有用,如最后
的例子。由于没有引用来保存这个对象,所以它立即被垃圾回收了。你处理这种访问的类型唯一的
用处就是显示 BIT 有什么方法。


用户定义的方法(UDM)
UDM(User-defined method,用户定义的方法)包含在类定义之中,只是拥有标准函数的包装,
仅有定义它们的类可以使用。如果没有在子类定义中被覆盖掉,也可以通过子类实例来调用它们。
正如在 13 章解释的那样, UDM 与类对象是关联的(非绑定方法),但是只能通过类的实例来调用(绑
定方法)。无论 UDMs 是否绑定,所有的 UMD 都是相同的类型——“实例方法“,如在下面例子看到
的 type()调用:
>>> class C(object): # define class # 定义类
... def foo(self): pass # define UDM # 定义 UDM
...
>>> c = C() # instantiation # 实例化
>>> type(C) # type of class # 类的类别
<type 'type'>
>>> type(c) # type of instance # 实例的类别
<class '__main__.C'>
>>> type(C.foo) # type of unbound method # 非绑定方法的类别
<type 'instancemethod'>
>>> type(c.foo) # type of bound method # 绑定方法的类别
<type 'instancemethod'>
表 11.4 中展示了 UDM 的属性。访问对象本身将会揭示你正在引用一个绑定方法还是非绑定方
法。正如你从下面看到的,绑定的方法揭示了方法绑定到哪一个实例。
>>> C.foo # unbound method object # 非绑定方法对象
<unbound method C.foo>
>>>
>>> c.foo # bound method object # 绑定方法对象
<bound method C.foo of <__main__.C object at 0x00B42DD0>
>>> c    # instance foo()'s bound to # foo()实例被绑定到......
<__main__.C object at 0x00B42DD0>
表 14.4 用户自定义属性
UDM 属性             描述
udm.__doc__       文档字符串(与 udm.im_fuc.__doc__相同)
udm.__name__        字符串类型的方法名字(与 umd.im_func.__name__相同)
udm.__module__    定义 udm 的模块的名字(或 none)
udm.im_class        方法相关联的类(对于绑定的方法;如果是非绑定,那么为要求 udm 的类)


udm.im_func      方法的函数对象(见 UDFs)
udm.im_self       如果绑定的话为相关联的实例,如果非绑定位为 none
14.1.3 类
我们可以利用类的可调用性来创建实例。                     “调用”类的结果便是创建了实例,即大家所知道的实
例化。类有默认构造函数,该函数什么都不做,基本上只有一个 pass 语句。程序员可以通过实现
__int__()方法,来自定义实例化过程。实例化调用的任何参数都会传入到构造函数里。
>>> class C(object):
def __init__(self, *args):
print 'Instantiated with these arguments:\n', args
>>> c1 = C() # invoking class to instantiate c1
Instantiated with these arguments:
()
>>> c2 = C('The number of the counting shall be', 3) Instantiated with these arguments:
('The number of the counting shall be', 3)
我们已经很熟悉实例化过程以及它是如何完成的,在这里将不再赘述。不过,一个新的问题是
如何让实例能够被调用。
14.1.4 类的实例
python 给类提供了名为__call__的特别方法,该方法允许程序员创建可调用的对象(实例)。默
认情况下,__call__()方法是没有实现的,这意味着大多数实例都是不可调用的。然而,如果在类
定义中覆盖了这个方法,那么这个类的实例就成为可调用的了。调用这样的实例对象等同于调用
__call__()方法。自然地,任何在实例调用中给出的参数都会被传入到__call()__中。......那么 foo()
就和 foo.__call__(foo)的效果相同, 这里 foo 也作为参数出现,因为是对自己的引用,实例将自
动成为每次方法调用的第一个参数。如果 ___call___()有参数,比如,(self, arg),那么 foo(arg)
就和调用 foo.__call__(foo, arg)一样。这里我们给出一个可调用实例的例子,和前面小节的例子
相似:
>>> class C(object):
... def __call__(self, *args):
... print "I'm callable! Called with args:\n", args
...


>>> c =
C()
# instantiation    # 实例化
>>> c
# our instance     # 我们的实例
<__main__.C instance at 0x00B42DD0>
>>> callable(c) # instance is callable #实例是可调用的
True
>>> c() # instance invoked # 调用实例
I'm callable! Called with arguments:
()
>>> c(3) # invoked with 1 arg # 呼叫的时候给出一个参数
I'm callable! Called with arguments:
(3,)
>>> c(3, 'no more, no less') # invoked with 2 args # 呼叫的时候给出两个参数
I'm callable! Called with arguments:
(3, 'no more, no less')
记住只有定义类的时候实现了__call__方法,类的实例才能成为可调用的。
14.2 代码对象
可调用的对象是 python 执行环境里最重要的部分,然而他们只是冰山一角。python 语句,赋值,
表达式,甚至还有模块构成了更宏大的场面。这些可执行对象无法像可调用物那样被调用。更确切
地说,这些对象只是构成可执行代码块的拼图的很小一部分,而这些代码块被称为代码对象。
每个可调用物的核心都是代码对象,由语句,赋值,表达式,以及其他可调用物组成。察看一
个模块意味着观察一个较大的、包含了模块中所有代码的对象。然后代码可以分成语句,赋值,表
达式,以及可调用物。可调用物又可以递归分解到下一层,那儿有自己的代码对象。
一般说来,代码对象可以作为函数或者方法调用的一部分来执行,也可用 exec 语句或内建函数
eval()来执行。从整体上看,一个 python 模块的代码对象是构成该模块的全部代码。
如果要执行 python 代码,那么该代码必须先要转换成字节编译的代码(又称字节码)。这才是
真正的代码对象。然而,它们不包含任何关于它们执行环境的信息,这便是可调用物存在的原因,
它被用来包装一个代码对象并提供额外的信息。
还记得前面的小节中 UDF 的 udf.func_code 属性吗?呃,想不到吧?那就是代码对象。UDM 的


udm.im_func 函数对象又是怎么一回事呢?因为那也是一个函数对象,所以他同样有它自己的
udm.im_func.func_code 代码对象。这样的话,你会发现,函数对象仅是代码对象的包装,方法则是
给函数对象的包装。你可以到处看看。当研究到最底层,你会发现便是一个代码对象
14.3 可执行的对象声明和内建函数
Python 提供了大量的 BIF 来支持可调用/可执行对象,其中包括 exec 语句。这些函数帮助程序
员执行代码对象,也可以用内建函数 complie()来生成代码对象。
表 14.5 可执行对象和内建函数
内建函数和语句                    描述
callable(obj)               如果 obj 可调用,返回 True,否则返回 FALSE
compile(string,file, type) 从 type 类型中创建代码对象;file 是代码存放的地方(通常设
为"")
eval(obj, glo- bals=globals(),
locals=locals())             对 obj 进行求值,obj 是已编译为代码对象的表达式,或是一个
字符串表达式;可以给出全局或者/和局部的名字空间
exec obj          执行 obj、单一的 python 语句或者语句的集合,也就是说格式
是代码对象或者字符串;obj 也可以是一个文件对象(已经打开的有
效 python 脚本中)
input(prompt='')      等同于 eval(raw_input(prompt=”))
14.3.1     callable()
callable()是一个布尔函数,确定一个对象是否可以通过函数操作符(())来调用。如果函数可
调用便返回 True,否则便是 False(对与 2.2 和较早的版本而言,分别是 1 和 0)                       。这里有些对象及
其对应的 callable 返回值
>>> callable(dir) # built-in function # 内建函数
True
>>> callable(1) # integer #整数
False
>>> def foo(): pass
...
>>> callable(foo) # user-defined function # 用户自定义函数
True
>>> callable('bar')    # string #字符串


False
>>> class C(object): pass
...
>>> callable(C) # class #类
True
14.3.2      compile()
compile()函数允许程序员在运行时刻迅速生成代码对象,然后就可以用 exec 语句或者内建函
数 eval()来执行这些对象或者对它们进行求值。一个很重要的观点是:exec 和 eval()都可以执行字
符串格式的 Python 代码。当执行字符串形式的代码时,每次都必须对这些代码进行字节编译处理。
compile()函数提供了一次性字节代码预编译,以后每次调用的时候,都不用编译了。
compile 的三个参数都是必需的,第一参数代表了要编译的 python 代码。第二个字符串,虽然
是必需的,但通常被置为空串。该参数代表了存放代码对象的文件的名字(字符串类型)。compile 的
通常用法是动态生成字符串形式的 Python 代码, 然后生成一个代码对象——代码显然没有存放在
任何文件。
最后的参数是个字符串,它用来表明代码对象的类型。有三个可能值:
'eval'    可求值的表达式[和 eval()一起使用]
'single'   单一可执行语句[和 exec 一起使用]
'exec'     可执行语句组[和 exec 一起使用]
可求值表达式
>>> eval_code = compile('100 + 200', '', 'eval')
>>> eval(eval_code)
300
单一可执行语句
>>> single_code = compile('print "Hello world!"', '', 'single')
>>> single_code
<code object ? at 120998, file "", line 0>
>>> exec single_code
Hello world!
可执行语句组


>>> exec_code = compile("""
... req = input('Count how many numbers? ')
... for eachNum in range(req):
... print eachNum
... """, '', 'exec')
>>> exec exec_code
Count how many numbers? 6
0
1
2
3
4
5
在最后的例子中,我们第一次看到 input()。一直以来,我们都是从 raw_input()中读取输入的。
内建函数 input()是我们将在本章稍后讨论的一个快捷函数。
14.3.3    eval()
eval()对表达式求值,后者可以为字符串或内建函数 complie()创建的预编译代码对象。这是
eval()第一个也是最重要的参数.......这便是你想要执行的对象。第二个和第三个参数,都为可选
的,分别代表了全局和局部名字空间中的对象。如果给出这两个参数,globals 必须是个字典,locals
可以是任意的映射对象,比如,一个实现了__getitem__()方法的对象。(在 2.4 之前,local 必须是
一个字典)如果都没给出这两个参数,分别默认为 globals()和 locals()返回的对象,如果只传入
了一个全局字典,那么该字典也作为 locals 传入。好了,我们一起来看看 eval():
>>> eval('932')
932
>>> int('932')
932
在这种情况下,eval()和 int()都返回相同的结果:整数 932。然而,它们采用的方式却不尽相
同。内建函数 eval()接收引号内的字符串并把它作为 python 表达式进行求值。内建函数 int()接收
代表整数的字符串并把它转换为整数。这只有在该字符串只由字符串 932 组成的时候才会成功,而
该字符串作为表达式返回值 932,932 也是字符串”932”所代表的整数。当我们用纯字符串表达式
的时候,两者便不再相同了:
>>> eval('100 + 200')


300
>>> int('100 + 200') Traceback (innermost last):
File "<stdin>", line 1, in ?
ValueError: invalid literal for int(): 100 + 200
在这种情况下,eval()接收一个字符串并把"100+200"作为表达式求值,当进行整数加法后,给
出返回值 300。而对 int()的调用失败了,因为字符串参数不是能代表整数的字符串, 因为在字符
串中有非法的文字,即,空格以及“+”字符。可以这样理解 eval()函数的工作方式:对表达式两端
的引号视而不见,接着假设“如果我是 python 解释器,我会怎样去观察表达式呢?”,换句话说,
如果以交互方式输入相同的表达式,解释器会做出怎么样的反应呢?按下回车后的结果应该和 eval()
返回的结果相同。
14.3.4      exec
和 eval()相似,exec 语句执行代码对象或字符串形式的 python 代码。类似地,用 compile()
预编译重复代码有助于改善性能,因为在调用时不必经过字节编译处理。exec 语句只接受一个参数,
下面便是它的通用语法:
exec obj
被执行的对象(obj)可以只是原始的字符串,比如单一语句或是语句组,它们也可以预编译成
一个代码对象(分别用'single'和'exec"参数)。下面的例子中,多个语句作为一个字符串发送给 exec:
>>> exec """
... x = 0
... print 'x is currently:', x
... while x < 5:
... x += 1
... print 'incrementing x to:', x
... """
x is currently: 0
incrementing x to: 1
incrementing x to: 2
incrementing x to: 3
incrementing x to: 4
incrementing x to: 5
最后, exec 还可以接受有效的 python 文件对象。如果我们用上面的多行代码创建一个叫
xcount.py 的文件,那么也可以用下面的方法执行相同的代码


>>> f = open('xcount.py') # open the file
>>> exec f # execute the file
x is currently: 0
incrementing x to: 1
incrementing x to: 2
incrementing x to: 3
incrementing x to: 4
incrementing x to: 5
>>> exec f    #尝试再一次执行
>>>          #哦,失败了....为什么?
14.3 可执行对象语句和内建函数
注意一旦执行完毕,继续对 exec 的调用就会失败。呃,并不是真正的失败。                              。。只是不再做任何
事,这或许让你感到吃惊。事实上,exec 已从文件中读取了全部的数据且停留在文件末尾(EOF)。当
用相同文件对象对 exec 进行调用的时候,便没有可以执行的代码了,所以 exec 什么都不做,如同
上面看见的行为。我们如何知道它在 EOF 呢?
我们用文件对象的 tell()方法来告诉我们处于文件的何处,然后用 os.path.getsize()来告诉
我们 xcount.py 脚本有多大。这样你就会发现,两个数字完全一样:
>>> f.tell()   # where are we in the file? # 我们在文件的什么地方?
116
>>> f.close() # close the file # 关闭文件
>>> from os.path import getsize
>>> getsize('xcount.py') # what is the file size? # 文件有多大?
116
如果想在不关闭和重新打开文件的情况下再次运行它,可以用 seek()到文件最开头并再次调用
exec 了。比如,假定我们还没有调用 f.close(),那么我们可以这样做:
>>> f.seek(0) # rewind to beginning 倒会文件开头
>>> exec f
x is currently: 0
incrementing x to: 1
incrementing x to: 2
incrementing x to: 3
incrementing x to: 4


incrementing x to: 5
>>> f.close()
14.3.5      input()
内 建 函 数 input()是 eval()和 raw_input()的组合,等价于 eval(raw_input())。类 似 于
raw_input(),input()有一个可选的参数,该参数代表了给用户的字符串提示。如果不给定参数的
话,该字符串默认为空串。
从功能上看,input 不同于 raw_input(),因为 raw_input()总是以字符串的形式,逐字地返回用
户的输入。input()履行相同的的任务;而且,它还把输入作为 python 表达式进行求值。这意味着
input()返回的数据是对输入表达式求值的结果:一个 python 对象。
下面的例子会让人更加清楚:当用户输入一个列表时,raw_input()返回一个列表的字符串描绘,
而 input()返回实际的列表:
>>> aString = raw_input('Enter a list: ') Enter a list: [ 123, 'xyz', 45.67 ]
>>> aString
"[ 123, 'xyz', 45.67 ]"
>>> type(aString)
<type 'str'>
上面用 raw_input()运行。正如你看见的,每样东西都是字符串。现在来看看当用 input()的时
候会发生什么:
>>> aList = input('Enter a list: ') Enter a list: [ 123, 'xyz', 45.67 ]
>>> aList
[123, 'xyz', 45.67]
>>> type(aList)
<type 'list'>
虽然用户输入字符串,但是 input()把输入作为 python 对象来求值并返回表达式的结果。
14.3.6 使用 Python 在运行时生成和执行 Python 代码
在这个小节中,我们将看到两个 python 脚本的例子,这两个例子在运行时刻把 python 代码作
为字符串并执行。第一个例子更加动态,但第二个突出了函数属性。


在运行时生成和执行 Python 代码
第一个例子是 loopmake.py 脚本,一个简单的、迅速生成和执行循环的计算机辅助软件工程
(CASE)。它提示用户给出各种参数(比如,循环类型(while 或 for), 迭代的数据类型[数字或序列]),
生成代码字串,并执行它
Example 14.1 动态生成和执行 Python 代码
(loopmake.py)
1 #!/usr/bin/env python
2
3 dashes = '\n' + '-' * 50 # dashed line
4 exec_dict = {
5
6'f': """ # for loop
7 for %s in %s:
8 print %s
9 """,
10
11 's': """ # sequence while loop
12 %s = 0
13 %s = %s
14 while %s < len(%s):
15 print %s[%s]
16 %s = %s + 1
17 """,
18
19 'n': """ # counting while loop
20 %s = %d
21 while %s < %d:
22 print %s
23 %s = %s + %d
24 """
25 }
26
27 def main():
28
29 ltype = raw_input('Loop type? (For/While) ')
30 dtype = raw_input('Data type? (Number/Seq) ')
31


32 if dtype == 'n':
33 start = input('Starting value? ')
34 stop = input('Ending value (non-inclusive)? ')
35 step = input('Stepping value? ')
36 seq = str(range(start, stop, step))
37
38 else:
39 seq = raw_input('Enter sequence: ')
40
41 var = raw_input('Iterative variable name? ')
42
43 if ltype == 'f':
44 exec_str = exec_dict['f'] % (var, seq, var)
45
46 elif ltype == 'w':
47 if dtype == 's':
48 svar = raw_input('Enter sequence name? ')
49 exec_str = exec_dict['s'] % \
50 (var, svar, seq, var, svar, svar, var, var, var)
52 elif dtype == 'n':
53 exec_str = exec_dict['n'] % \
54 (var, start, var, stop, var, var, var, step)
55
56 print dashes
57 print 'Your custom-generated code:' + dashes
58 print exec_str + dashes
59 print 'Test execution of the code:' + dashes
60 exec exec_str
61 print dashes
62
63 if __name__ == '__main__':
64 main()
以下脚本执行的例子
% loopmake.py
Loop type? (For/While) f
Data type? (Number/Sequence) n
Starting value? 0
Ending value (non-inclusive)? 4


Stepping value? 1
Iterative variable name? counter
--------------------------------------------------
The custom-generated code for you is:
--------------------------------------------------
for counter in [0, 1, 2, 3]:
print counter
--------------------------------------------------
Test execution of the code:
--------------------------------------------------
0
1
2
3
--------------------------------------------------
% loopmake.py
Loop type? (For/While) w
Data type? (Number/Sequence) n
Starting value? 0
Ending value (non-inclusive)? 4
Stepping value? 1
Iterative variable name? counter
--------------------------------------------------
Your custom-generated code:
--------------------------------------------------
counter = 0
while counter < 4:
print counter
counter = counter + 1
--------------------------------------------------
Test execution of the code:
--------------------------------------------------
0
1
2
3
--------------------------------------------------
% loopmake.py
Loop type? (For/While) f
Data type? (Number/Sequence) s


Enter sequence: [932, 'grail', 3.0, 'arrrghhh']
Iterative variable name? eachItem
--------------------------------------------------
Your custom-generated code:
--------------------------------------------------
for eachItem in [932, 'grail', 3.0, 'arrrghhh']:
print eachItem
--------------------------------------------------
Test execution of the code:
--------------------------------------------------
932
grail
3.0
arrrghhh
--------------------------------------------------
% loopmake.py
Loop type? (For/While) w
Data type? (Number/Sequence) s
Enter sequence: [932, 'grail', 3.0, 'arrrghhh']
Iterative variable name? eachIndex
Enter sequence name? myList
--------------------------------------------------
Your custom-generated code:
--------------------------------------------------
eachIndex = 0
myList = [932, 'grail', 3.0, 'arrrghhh']
while eachIndex < len(myList):
print myList[eachIndex]
eachIndex = eachIndex + 1
--------------------------------------------------
Test execution of the code:
--------------------------------------------------
932
grail
3.0
arrrghhh
--------------------------------------------------
逐行解释


Lines 1–25
在脚本的第一部分,我们设置了两个全局变量。第一个是由一行破折号(即是名字)组成的静
态字符串,第二个则是由用于生成循环的骨架代码组成的字典。for 循环的健值是'f',用于迭代序
列的 while 循环的则是"s",而记数 while 循环的是'n‘
Lines 27–30
这里我们提示用户输入他(她)想要的循环类型和数据类型
Lines 32–36
选定数字;给出开始,停止,以及增量值。在这个部分的代码中,第一次引入了内建函数 input()。
我们将在 14.3.5 小节中看到,input()和 raw_input()相似,因为它提示用户给出字符串输入,但是
不同于 raw_input(),input()会把输入当成 python 表达式来求值,即使用户以字符串的形式输入,
也会返回一个 python 对象
Lines 38–39
选定序列;这里以字符串的形式输入一个序列
Line 41
给出用户想要使用的迭代循环变量的名字
Lines 43–44
生成添加自定义内容的 for 循环。
Lines 46–50
生成迭代序列的 while 循环。
Lines 52–54
生成计数的 while 循环
Lines 56–61
输出生成的源代码及其执行后的结果
Lines 63–64
当直接调用该模块的时候,执行 main()
为了很好地控制脚本的大小,我们从原来的脚本中剔除了所有的注释和错误检测。在本书的 web
站点上,都可以找到原来的和修改后的版本。
扩展的版本包括了额外的特性,比如用于字符串输入的不必要的引号,输入数据的默认值,以
及检测无效的返回和标识符;也不允许以关键字和内建名字作为变量名字


有条件地执行代码
第二个例子着重描写了在第 11 章"函数"引入的函数属性,它是从 Python 增强提议 232(PEP 232)
中的例子得到的灵感。假设你是一位负责质量控制的软件开发者,你鼓励你的工程师将回归测试或
回归指令代码放到主代码中,但又不想让测试代码混合到产品代码中。你可以让工程师创建字符串
形式的测试代码。当你的测试框架执行的时候,它会检测函数是否定义了测试体,如果是的话,(求
值并)执行它。如果不是,便跳过,像通常一样执行。
Example 14.2    Function Attributes (funcAttrs.py)
调用 sys.exit()使 python 解释器退出。exit()的任何整数参数作为退出状态会返回给调用者,
该值默认为 0
1 #!/usr/bin/env python
2
3 def foo():
4 return True
5
6 def bar():
7 'bar() does not do much'
8 return True
9
10 foo.__doc__ = 'foo() does not do much'
11 foo.tester = '''
12 if foo():
13 print 'PASSED'
14 else:
15 print 'FAILED'
16 '''
17
18 for eachAttr in dir():
19 obj = eval(eachAttr)
20 if isinstance(obj, type(foo)):
21 if hasattr(obj, '__doc__'):
22 print '\nFunction "%s" has a doc
string:\n\t%s' % (eachAttr, obj.__doc__)
23 if hasattr(obj, 'tester'):
24 print 'Function "%s" has a tester... executing'% eachAttr
25 exec obj.tester


26 else:
27 print 'Function "%s" has no tester... skipping'% eachAttr
28 else:
29 print '"%s" is not a function' % eachAttr
Lines 1–8
我们在脚本的开始部分定义了 foo()和 bar()。两个函数都只是返回 True。不同点在于 foo()没
有属性而 bar()有文档字串。
Lines 10–16
使用函数属性,我们给 foo()加入了文档字串以及退化或单元测试字符串。注意检测字符串实际
上由 python 代码组成。
Lines 18–29
好了,真正的工作在这里开始。我们从用内建函数 dir()迭代现在(即全局)名字空间开始。它
返回的列表包含了所有对象的名字。因为这些都是字符串,我们需要在第 19 行将它们转化为真正的
python 对象。
除了预期的系统变量,比如,__builtins__,我们还期望显示函数。我们只对函数有兴趣;第
20 行的代码让我们跳过了所有遇到的非函数对象。一旦我们知道我们有某个函数,就可以检查它是
否有文档字串,如果有的话,把它显示出来。23-27 行表演了魔法。如果函数有检测属性,那么就
执行它,否则告诉用户没有可用的单元测试。最后的几行显示出遇到的非函数对象的名字。执行代
码后,我们得到如下的输出:
$ python funcAttr.py
"__builtins__" is not a function
"__doc__" is not a function
"__file__" is not a function
"__name__" is not a function
Function "bar" has a doc string:
bar() does not do much
Function "bar" has no tester... skipping
Function "foo" has a doc string:
foo() does not do much
Function "foo" has a tester... executing
PASSED


14.4 执行其他(Python)程序
当讨论执行其他程序时,我们把它们分类为 python 程序和其他所有的非 python 程序,后者包
括了二进制可执行文件或其他脚本语言的源代码。我们先讨论如何运行其他的 python 程序,然后是
如何用 os 模块调用外部程序。
14.4.1      导入
在运行时刻,有很多执行另外 python 脚本的方法。正如我们先前讨论的,第一次导入模块会执
行模块最高级的代码。不管你是否需要,这就是 python 导入的行为。提醒,只有属于模块最高级的
代码才是全局变量,全局类,和全局函数声明。
核心笔记:当模块导入后,就执行所有的模块
这只是一个善意的提醒:在先前的第 3 章和第 12 章已经谈过了,现在再说一次,当导入 python
模块后,就执行所有的模块!当导入 python 模块后,会执行该模块!当你导入 foo 模块时候,它运行
所有最高级别的(即没有缩进的)python 代码,比如,'main()’。如果 foo 含有 bar 函数的声明,
那么便执行 def foo(...)。再问一次为什么会这样做呢?...... 由于某些原因,bar 必须被识别为 foo
模块中一个有效的名字,也就是说 bar 在 foo 的名字空间中,其次,解释器要知道它是一个已声明
的函数,就像本地模块中的任何一个函数。现在我们知道要做什么了,那么如何处理那些不想每次
导入都执行的代码呢?缩进它,并放入 if __name__ == '__main__' 的内部。
跟着应该是一个 if 语句,它通过检测__name__来确定是否要调用脚本,比如,“if__name__ ==
'__main__'”。如果相等的话,你的脚本会执行 main 内代码;否则只是打算导入这个脚本,那么可
以在这个模块内对代码进行测试。
当导入 python 模块后,会执行该模块!当你导入 foo 模块时候,它运行所有最高级别的(即没
有缩进的)python 代码,...... 再问一次为什么会这样做呢?...... 由于某些原因,bar 必须被识别
为 foo 模块中一个有效的名字,也就是说 bar 在 foo 的名字空间中,其次,解释器要知道它是一个
已声明的函数,就像本地模块中的任何一个函数。现在我们知道要做什么了,那么如何处理那些不
想每次导入都执行的代码呢?缩进它,并放入 if __name__ == '__main__' 的内部。
# import1.py
print 'loaded import1'
import import2
这里是 import2.py 的内容:
# import2.py


print 'loaded import2'
这是当我们导入 import1 时的输出
>>> import import1 loaded import1 loaded import2
>>>
根据建议检测__name__值的迂回工作法,我们改变了 import1.py 和 import2.py 里的代码,这
样的情况就不会发生了
这里是修改后的 import.py 版本:
# import1.py
import import2
if __name__ == '__main__':
print 'loaded import1'
接着是 import2.py 的代码,以相同的方式修改:
# import2.py
if __name__ == '__main__'
print 'loaded import2'
当从 python 中导入 import1 的时候,我们不再会得到任何输出
>>> import import1
>>>
这不意味着在任何的情况下,都该这样编写代码。在某些情况中,你可能想要显示输出来确定
输入模块。这取决于你自身的情况。我们的目标是提供实效的编程例子来屏蔽副作用。
14.4.2      execfile()
显然,导入模块不是从另外的 python 脚本中执行 python 脚本最可取的方法。那也就不是导入
过程。导入模块的副作用是导致最高级代码运行。
这章一开始,我们描述了如何通过文件对象,使用 exec 语句来读取 python 脚本的内容并执行。
下面的代码给出了例子:


f = open(filename, 'r')
exec f f.close()
这 3 行可以调用 execfile()来换掉:
execfile(filename)
虽然上述代码执行了一个模块,但是仅可以在现有的执行环境下运行(比如,它自己的全局和
局部的名字空间)。在某些情况下,可能需要用不同全局和局部的名字空间集合,而不是默认的集合
来执行模块。execfile() 函数的语法非常类似于 eval()函数的。
execfile(filename, globals=globals(), locals=locals())
类似 eval(),globals 和 locals 都是可选的,如果不提供参数值的话,默认为执行环境的名字
空间。如果只给定 globals,那么 locals 默认和 globals 相同。如果提供 locals 值的话,它可以是
任何映射对象[一个定义/覆盖了__getitem__()的对象]。在在 2.4 之前,locals 必须是一个字典。
注意:  (在修改的时候)小心局部名字空间。比较安全的做法是传入一个虚假的"locals"字典并检查
是否有副作用。execfile()不保证不会修改局部名字空间。见 python 库参考手册对 execfile()的解
释
14.4.3     将模块作为脚本执行
python2.4 里加入了一个新的命令行选项(或开关)                     ,允许从 shell 或 DOS 提示符,直接把模块
作为脚本来执行。当以脚本的方式来书写你的模块的时候,执行它们是很容易的。你可以使用命令
行从你的工作目录调用你的脚本。
$ myScript.py # or $ python myScript.py
如果模块是标准库的一部分,安装在 site-packages 里,或者仅仅是包里面的模块,处理这样
的模块就不是那么容易了,尤其是它们共享了已存在的同名 python 模块。举例来说,你想运行免费
的 python web 服务器,以便创建和测试你自己的 web 页面和 CGI 脚本。
你将必须在命令行敲入如下的东西:
$ python /usr/local/lib/python2x/CGIHTTPServer.py
Serving HTTP on 0.0.0.0 port 8000 ...
这是段很长的命令,如果它是第三方的,你不得不深入到 site-packages 去找到它真正定位的
地方。如果没给出完全的路径名,可以从命令行运行一个模块,并让 python 的导入机制为我们做这


种跑腿工作吗?答案是肯定的。我们可以用 python -c 命令行开关:
$ python -c "import CGIHTTPServer; CGIHTTPServer.test()"
该选项允许你指定你想要运行的 python 语句。虽然它可以这样工作,但问题是__name__模块不
是‘__main__’........而是你正在使用的模块。(需要的话,你可以参阅前面的 3.4.1 小节复习
__name__)在最后一行,解释器通过 import 装载了你的模块,并不是它当作脚本。因为如此,所有
在 if __name__ == '__main__' 之下的代码是不会执行的,所以你不得不手动地调用模块的 test()
函数,就如同前面我们所做的一样。所以我们想同时要两者的优点——能够在类库中执行作为脚本
的模块而不是作为导入的模块。这就是-m 参数的动机。现在可以像这样运行脚本:
$ python -m CGIHTTPServer
这是不小的改进。尽管如此,还没有完全如预想那样实现特性。所以在 python2.5 中,-m 开关
有了更多的兼容性。从 2.5 开始,你可以用相同的参数来运行包内或需要特别加载的模块,比如 zip
文件里的模块,这是在 2.3 加入的特性(12.5.7 小节,396 页)                  。python2.4 只让你执行标准的库模
块。所以初始版本的-m 选项是不能运行特殊的模块如 PyCHecker(python 的 lint),或其他的
profiler(注意这些是装载和运行其他模块的模块)。但是 2.5 版本解决了这个问题。
14.5 执行其他(非 Python)程序
在 python 程序里我们也可以执行非 python 程序。这些程序包括了二进制可执行文件,其他的
shell 脚本等等。所有的要求只是一个有效的执行环境,比如,允许文件访问和执行,脚本文件必须
能访问它们的解释器(perl, bash,等等),二进制必须是可访问的(和本地机器的构架兼容)
最终,程序员必须考虑 python 脚本是否必须和其他将要执行的程序通信。有些程序需要输入,
而有的程序返回输出以及执行完成时的错误代码,也许有的两者都做。针对不同的环境,python 提
供了各种执行非 python 程序的方法。在本节讨论的所有函数都可以在 os 模块中找到。在表 14.6 中,
我们做了总结(我们会对那些只适合特定平台的函数进行标注),作为对本节剩余部分的介绍。
Table 14.6 执行外部程序的 os 模块函数
(u 只对 unix 有效, w 只对 windows 有效)
os 模块函数            描述
system(cmd)         执行程序 cmd(字符串),等待程序结束,返回退出代码(windows 下,
始终为 0)
fork()              创建一个和父进程并行的子进程[通常来说和 exec*()一起使用];返回两
次....一次给父进程一次给子进程
execl(file, arg0,arg1,...) 用参数列表 arg0, arg1 等等执行文件


execv(file, arglist)     除了使用参数向量列表,其他的和 execl()相同
execle(file, arg0,arg1,... env) 和 execl 相同,但提供了环境变量字典 env
execve(file,arglist, env) 除了带有参数向量列表,其他的和 execle()相同
execlp(cmd, arg0,arg1,...) 于 execl()相同,但是在用户的搜索路径下搜索完全的文件路径
名
execvp(cmd, arglist)     除了带有参数向量列表,与 execlp()相同
Table 14.6  执行外部程序的 os 模块函数(续表)(u 只对 unix 有效, w 只对 windows 有效)
os 模块函数         描述
execlpe(cmd, arg0, arg1,... env)      和 execlp 相同,但提供了环境变量字典 env
execvpe(cmd,arglist, env)               和 execvp 相同,但提供了环境变量字典 env
spawn*a(mode, file, args[, env])         spawn*()家族在一个新的进程中执行路径,args 作为
参数,也许还有环境变量的字典 env;模式(mode)是
个显示不同操作模式的魔术。
wait()                         等待子进程完成[通常和 fock 和 exec*()一起使用] ○               U
waitpid(pid,options)          等待指定的子进程完成[通常和 fock 和 exec*()一起使用] ○                  U
popen(cmd, mode='r',buffering=-1)            执行字符串 cmd,返回一个类文件对象作为运行程
序通信句柄,默认为读取模式和默认系统缓冲
b
startfile (path)                  用关联的应用程序执行路径 W
a. spawn*()函数命名与 exec*()相似(两个家族都有 8 个成员);spawnv()和 spawnve()在
python 1.5.2 加入,其他的六个 spawn*()函数在 python 1.6 加入;spawnlp(), spawnlpe(),
spawnvp() 和 spawnvpe()只适用于 unix 平台。
b. python2.0 是加入的
随着越来越接近软件的操作系统层面,你就会发现执行跨平台程序(甚至是 python 脚本)的一
致性开始有些不确定了。上面我们提到在这个小节中描述的程序在 os 模块中。事实上,有多个 os
模块。比如说,基于 Unix 衍生系统(例如 Linux,MacOS X, Solaris,BSD 等等)的模块是 posix 模
块,windows 的是 nt(无论你现在用的是哪个版本的 windows;dos 用户有 dos 模块)                         ,旧的 macOS 为
mac 模块。不用担心,当你调用 import os 的时候,python 会装载正确的模块。你不需要直接导入
特定的操作系统模块。
在我们看看每个模块函数之前,对于 python2.4 或者更新版本的用户,这里有个 subprocess 模
块,可以作为上面所有函数很好的替代品。我们本章稍后部分演示如何使用这些函数,然后在最后
给出 subprocess.Popen 类和 subprocess.call()函数的等价使用方法。
14.5.1      os.system()


我们列表中的第一个函数是 system(),一个非常简单的函数,接收字符串形式的系统命令并执
行它。当执行命令的时候,python 的运行是挂起的。当我们的执行完成之后,将会以 system()的返
回值形式给出退出状态,python 的执行也会继续。
system()保留了现有的标准文件,包括标准的输出,意味着执行任何的命令和程序显示输出都
会传到标准输出上。这里要当心,因为特定应用程序比如公共网关接口(CGI),如果将除了有效的超
文本标示语言(HTML)字符串之外的输出,经过标准输出发送回客户端,会引起 web 浏览器错误。
system()通常和不会产生输出的命令一起使用,其中的一些命令包括了压缩或转换文件的程序,挂
载磁盘到系统的程序,或其他执行特定任务的命令---通过退出状态显示成功或失败而不是通过输入
和/或输出通信。通常的约定是利用退出状态,0 表示成功,非零表示其他类型的错误。
为了给出一个例子,我们执行了两个从交互解释器中获取程序输入的命令,这样你便可以观察
system()是如何工作的
>>> import os
>>> result = os.system('cat /etc/motd') Have a lot of fun...
>>> result
0
>>> result = os.system('uname -a')
Linux solo 2.2.13 #1 Mon Nov 8 15:08:22 CET 1999 i586 unknown
>>> result
0
可以看到两个命令的输出和它们执行的退出状态,我们将其保存到 result 变量中。下面是一个
执行 dos 命令的例子:
14.5.2    os.popen()


popen()函数是文件对象和 system()函数的结合。它工作方式和 system()相同,但它可以建立
一个指向那个程序的单向连接,然后如访问文件一样访问这个程序。如果程序要求输入,那么你要
用'w'模式写入那个命令来调用 popen()。你发送给程序的数据会通过标准输入接收到。同样地,'r'
模式允许 spawn 命令,那么当它写入标准输出的时候,你就可以通过类文件句柄使用熟悉的 file 对
象的 read*()方法来读取输入。就像对于文件,当使用完毕以后,你应当 close()连接。在上面其中
一个使用 system()的例子中,我们调用了 unix 程序 uname 来来给我们提供机器和使用的操作系统的
相关信息。该命令产生了一行输出,并直接写到屏幕上。                             。如果想要把该字符串读入变量中并执行内
部操作或者把它存储到日志文件中,我们可以使用 popen()。实际上,代码如下所示:
>>> import os
>>> f = os.popen('uname -a')
>>> data = f.readline()
>>> f.close()
>>> print data,
Linux solo 2.2.13 #1 Mon Nov 8 15:08:22 CET 1999 i586 unknown
如你所见,popen()返回一个类文件对象;注意 readline(),往往,保留输入文本行尾的 newline
字符。
14.5.3      os.fork(), os.exec*(),os.wait*()
在这个小节中,我们不会对操作系统理论做详尽的介绍,只是稍稍地介绍一下进程(process)。
fork()采用称为进程的单一执行流程控制,如果你喜欢的话,可称之为创建“岔路口”。有趣的事情
发生了:用户系统同时接管了两个 fork——也就是说让用户拥有了两个连续且并行的程序。                                    (不用说,
它们运行的是同一个程序,因为两个进程都是紧跟在 fork()调用后的下一行代码开始执行的)。调用
fork()的原始进程称为父进程,而作为该调用结果新创建的进程则称为子进程。当子进程返回的时
候,其返回值永远是 0;当父进程返回时,其返回值永远是子进程的进程标识符(又称进程 ID,或 PID)
(这样父进程就可以监控所有的子进程了)PID 也是唯一可以区分他们的方式!我们提到了两个进程
会在调用 fork()后立刻运行。因为代码是相同的,如果没有其他的动作,我们将会看到同样的执行
结果。而这通常不是我们想要的结果。创建另外一个进程的主要目的是为了运行其他程序,所以我
们必须在父进程和子进程返回时采取分流措施。正如上面我们所说,它们的 PID 是不同的,而这正
是我们区分它们的方法。
对于那些有进程管理经验的人来说,接下来的这段代码是再熟悉不过了。但是,如果你是新手
的话,一开始就弄懂它是如何工作的可能就有点困难了,但是一旦你懂了,就会体会到其中的奥妙。
ret = os.fork() # spawn 2 processes, both return #产生两个进程,都返回
if ret == 0:    # child returns with PID of 0 #子进程返回的 PID 是 0
child_suite # child code #子进程的代码


else:   # parent returns with child's PID #父进程返回是子进程的 PID
parent_suite     # parent code #父进程的代码
在代码第一行便调用了 fork()。现在子进程和父进程同时在运行。子进程本身有虚拟内存地址
空间的拷贝,以及一份父进程地址空间的原样拷贝。-----是的,两者几乎都是相同的。fork()返回
两次,意味着父进程和子进程都返回了。你或许会问,如果它们两个同时返回,如何区分两者呢?
当父亲返回的时候,会带有进程的 PID。而当子进程返回的时候,其返回值为 0。这就是区分两个进
程的方法。
利用 if-else 语句,我们能给子进程(比如,if 子句)和父进程(else 子句)指定各自的执行
代码。在子进程的代码中,我们可以调用任何 exec*()函数来运行完全不同的程序,或者同一个程序
中的其他的函数(只要子进程和父进程用不同的路径执行)。普遍做法是让子进程做所有的脏活,而
父进程耐心等来子进程完成任务,或继续执行,稍后再来检查子进程是否正常结束。
所有的 exec*()函数装载文件或者命令,并用参数列表(分别给出或作为参数列表的一部分)来
执行它。如果适用的话,也可以给命令提供环境变量字典。这些变量普遍用于给程序提供对当前执
行环境的精确描述。其中一些著名的变量包括用户的名字,搜索路径,现在的 shell,终端类型,本
地化语言,机器类型,操作系统名字等等。
所有版本的 exec*()都会用给定文件作为现在要执行的程序取代当前(子)进程的 Python 解释
器。和 system()不一样,对于 Python 来说没有返回值(因为 Python 已经被替代了)。如果因为某
种原因,程序不能执行,那么 exec*()就会失败,进而导致引发异常。
接下来的代码在子进程中开始了一个称为“xbill"的可爱小巧的游戏,而父进程继续运行 Python
解释器。因为子进程从不返回,所以无需去顾虑调用 exec*()后的子进程代码。注意该命令也是参数
列表中的必须的第一个参数。
ret = os.fork()
if ret == 0:     # child code #子进程代码
execvp('xbill', ['xbill'])
else:        # parent code #父进程代码 os.wait()
在这段代码中,还可以看到对 wait()的调用。当子进程执行完毕,需要它们的父进程进行扫
尾工作。这个任务,称为”收获孩子”               (reaping a child),可以用 wati*()函数完成。紧跟在 fork()
之后,父进程可以等待子进程完成并在那进行扫尾。父进程也可以继续运行,稍后再扫尾,同样也
是用 wait*()函数中的一个。
不管父进程选择了那个方法,该工作都必须进行。当子进程完成执行,还没有被收获的时候,
它进入了闲置状态,变成了著名的僵尸进程。在系统中,应该尽量把僵尸进程的数目降到最少,因
为在这种状态下的子进程仍保留着在存活时期分配给它们的系统资源,而这些资源只能在父进程收


获它们之后才能释放掉。
调用 wait()会挂起执行(比如,waits)                 ,直到子进程(其他的子进程)正常执行完毕或通过
信号终止。wait()将会收获子进程,释放所有的资源。如果子进程已经完成,那么 wait()只是进行
些收获的过程。waitpid()具有和 wait()相同的的功能,但是多了一个参数 PID(指定要等待子进
程的进程标识符),以及选项(通常是零或用‘OR’组成的可选标志集合)
14.5.4    os.spawn*()
函数 spawn*()家族和 fork,exec*()相似,因为它们在新进程中执行命令;然而,你不需要分
别调用两个函数来创建进程,并让这个进程执行命令。你只需调用一次 spawn*()家族。由于其简单
性,你放弃了“跟踪”父进程和子进程执行的能力;该模型类似于在线程中启动函数。还有点不同
的是你必须知道传入 spawn*()的魔法模式参数。在其他的操作系统中(尤其是嵌入式实时操作系统
[RTOS]),spawn*()比 fork()快很多。不是这种情况的操作系统通常使用写实拷贝(copy-on-write)
技术。参阅 python 库参考手册来获得更多 spanw*()的资料。各种 spanw*()家族成员是在 1.5 和 1.6
(含 1.6)之间加入的。
14.5.5      subprocess 模块
在 python2.3 出来之后,一些关于 popen5 模块的工作开始展开。一开始该命名继承了先前
popen*()函数的传统,但是并没有延续下来,该模块最终被命名为 subproess,其中一个类叫 Popen,
集中了我们在这章讨论的大部分面向进程的函数。同样也有名为 call()的便捷函数,可以轻易地取
代了 os.system()。在 python2.4 中,subprocess 初次登场。下面就是演示该模块的例子:
替换 os.system()
Linux 上的例子:
>>> from subprocess import call
>>> import os
>>> res = call(('cat', '/etc/motd'))
Linux starship 2.4.18-1-686 #4 Sat Nov 29 10:18:26 EST 2003 i686
GNU/Linux
>>> res
0


Win32 例子
取代 os.popen()
创建 Popen()实例的语法只比调用 os.popen()函数复杂了一点
>>> from subprocess import Popen, PIPE
>>> f = Popen(('uname', '-a'), stdout=PIPE).stdout
>>> data = f.readline()
>>> f.close()
>>> print data,
Linux starship 2.4.18-1-686 #4 Sat Nov 29 10:18:26 EST 2003 i686
GNU/Linux
>>> f = Popen('who', stdout=PIPE).stdout
>>> data = [ eachLine.strip() for eachLine in f ]
>>> f.close()
>>> for eachLine in data:
... print eachLine
...
14.5.6 相关函数
表 14.7 列出了可以执行上述任务的函数(及其模块)


表 14.7 各种文件执行函数
文件对象 属性                描述
os/popen2.popen2a()   执行文件,打开文件,从新创建的运行程序读取(stdout),或者向
该程序写(stdin)
os/popen2.popen3a()   执行文件,打开文件,从新创建的运行程序读取(stdout 和 stder) ,
或者向该程序写(stdin)
os/popen2.popen4b()    执行文件,打开文件,从新创建的运行程序读取(结合 stdout,
stdout),或者向该程序写(stdin)
commands.getoutput()   在子进程中执行文件,以字符串返回所有的输出○                     U
subprocess.callc()     创建 subprocess 的便捷函数。 Popen 等待命令完成,然后返回状
态代码;与 os.system()类似,但是是较灵活的替代方案
a.   python2.0 版新加入
b.   python2.0 时加入到 os 和 popen2 模块中
c.   python2.4 时加入
14.6 受限执行
在 python 历史某个时期内,存在着使用了 rexec 和 bastion 模块的限制执行的概念。第一个
模块允许沙盒(sandbox)中的执行代码修改内建对象。第二个模块用来过滤属性和包装你的类。然
而,由于一个显著的缺点和弥补安全漏洞的困难,这些模块便被废弃了。那些维护使用了这些模块
的老代码的人员可能会用到这两个模块的文档。
14.6 结束执行
当程序运行完成,所有模块最高级的语句执行完毕后退出,我们便称这是干净的执行。可能有
很多情况,需要从 python 提前退出,比如某种致命错误,或是不满足继续执行的条件的时候。
在 python 中,有各种应对错误的方法。其中之一便是通过异常和异常处理。另外一个方法便是
建造一个“清扫器”方法,这样便可以把代码的主要部分放在 if 语句里,在没有错误的情况下执行,
因而可以让错误的情况“正常地“终结。然而,有时也需要在退出调用程序的时候,返回错误代码
以表明发生何种事件。
14.7.1     sys.exit() and SystemExit


立即退出程序并返回调用程序的主要方式是 sys 模块中的 exit()函数。sys.exit()的语法为:
sys.exit(status=0)
当调用 sys.exit()时,就会引发 systemExit()异常。除非对异常进行监控(在一个 try 语句和
合适的 except 子句中),异常通常是不会被捕捉到或处理的,解释器会用给定的状态参数退出,如
果没有给出的话,该参数默认为 0。System Exit 是唯一不看作错误的异常。它仅仅表示要退出 python
的愿望。
sys.exit()经常用在命令调用的中途发现错误之后,比如,如果参数不正确,无效,或者参数
数目不正确。下面的例子 14.4(args.py)仅仅是一个测试脚本,在正确执行之前需要给出确定数目
的参数。
执行这个脚本我们得到如下输出:
$ args.py
At least 2 arguments required (incl. cmd name). usage:   args.py           arg1 arg2
[arg3... ]
$ args.py XXX
At least 2 arguments required (incl. cmd name). usage: args.py arg1 arg2 [arg3... ]
$ args.py 123 abc
number of args entered: 3
args (incl. cmd name) were: ['args.py', '123', 'abc']
$ args.py -x -2 foo
number of args entered: 4
args (incl. cmd name) were: ['args.py', '-x', '-2',
'foo']
Example 14.4    Exiting Immediately (args.py) 立即退出 (args.py)
调用 sys.exit()使 python 解释器退出。exit()的任何整数参数都会以退出状态返回给调用者,
该值默认为 0;
1 #!/usr/bin/env python
2
3 import sys
4
5 def usage():
6 print 'At least 2 arguments (incl. cmd name).'
7 print 'usage: args.py arg1 arg2 [arg3... ]'


8 sys.exit(1)
9
10 argc = len(sys.argv)
11 if argc < 3:
12 usage()
13 print "number of args entered:", argc
14 print "args (incl. cmd name) were:", sys.argv
许多命令行驱动的程序在进行之前,用脚本的核心功能测试了输入的有效性。如果验证失败,
那么便调用 usage()函数去告知用户什么样的问题会导致这个错误,并"提示"用户如何才能正确地调
用脚本。
14.7.2     sys.exitfunc()
sys.exitfunc()默认是不可用的,但你可以改写它以提供额外的功能。当调用了 sys.exit()并
在解释器退出之前,就会用到这个函数了。这个函数不带任何参数的,所以你创建的函数也应该是
无参的。
如果 sys.exitfunc 已经被先前定义的 exit 函数覆盖了,最好的方法是把这段代码作为你 exit()
函数的一部分来执行。一般说来,exit 函数用于执行某些类型的关闭活动,比如关闭文件和网络连
接,最好用于完成维护任务,比如释放先前保留的系统资源。
下面的例子介绍了如何设置 exit()函数,如果已经被设置了,则确保执行该函数:
import sys
prev_exit_func = getattr(sys, 'exitfunc', None)
def my_exit_func(old_exit = prev_exit_func):
#:
# perform cleanup 进行清理
#:
if old_exit is not None and callable(old_exit):
old_exit()
sys.exitfunc = my_exit_func
在清理执行以后,我们执行了老的 exit()函数。getattr()调用只是检查了先前的 exitfunc()
是否已经定义。如果没有,那么 prev_exit_func 赋值为 None,否则, prev_exit_func 变成 exit 函


数新的别名,然后作为参数传入我们的新 exit 函数,my_exit_func。
对 getattr()的调用可以这样写:
if hasattr(sys, 'exitfunc'):
prev_exit_func = sys.exitfunc # getattr(sys, 'exitfunc')
else:
prev_exit_func = None
14.7.3     os._exit() Function               os._exit() 函数
os 模块的_exit()函数不应该在一般应用中使用。                     (平台相关,只适用特定的平台,比如基于 Unix
的平台,以及 Win32 平台)。其语法为:
os._exit(status)
这个函数提供的功能与 sys.exit()和 sys.exitfunc()相反,根本不执行任何清理便立即退出
python。与 sys.exit()不同,状态参数是必需的。通过 sys.exit()退出是退出解释器的首选方法。
14.7.4    os.kill() Function
os 模块的 kill()函数模拟传统的 unix 函数来发送信号给进程。kill()参数是进程标识数(PID)
和你想要发送到进程的信号。发送的典型信号为 SIGINT, SIGQUIT,或更彻底地,SIGKILL,来使进程
终结。
14.8    各种操作系统接口
在一章中,我们已看到各种通过 os 模块和操作系统进行交互的方法。我们看到的大多数函数都
是处理文件或外部进程执行。这里有些 方法允许对现在的用户和进程有较特殊的动作,我们将简要
地看看。表 14.8 中描述的大部分函数只在 posix 系统上工作,除非标明了适用于 Windows 环境。
Table 14.8   各种 os 模块属性
os 模块属性                  描述
uname()            获得系统信息(主机名,操作系统版本,补丁级别, 系统构架等等)
getuid()/setuid(uid)      获取/设置现在进程的真正的用户 ID
getpid()/getppid()       获取真正的现在/父进程 ID(PID) ○            W
getgid()/setgid(gid)      获取/设置现在进程的群组 ID


getsid()/setsid() 获取会话 ID(SID)或创建和返回新的 SID。
umask(mask)        设置现在的数字 unmask,同时返回先前的那个(mask 用于文件许可)○                   W
getenv(ev)/
putenv(ev, value),
environ              获取和设置 环境变量 ev 的值;os.envion 属性是描述当前所有环境变量
的字典○   W
geteuid()/setegid()    获取/设置当前进程的有效用户 ID(GID)
getegid()/setegid()    获取/设置当前进程的有效组 ID(GID)
getpgid(pid)/
setpgid(pid, pgrp)     获取和设置进程 GID 进程 PID;对于 get,如果 pid 为 0,便返回现在进
程的进程 GID
getlogin()            返回运行现在进程的用户登录
times()              返回各种进程时期的元组 ○                W
strerror(code)        返回和错误代码对应的错误信息
a
getloadavg()          返回代表在过去 1,5,15 分钟内的系统平均负载值的元组。
a.   python2.3 时加入
表 14.9        执行环境相关模块。
模块                        描述
atexita         注册当 python 解释器退出时候的执行句柄
popen2           提供额外的在 os.popen 之上的功能:             (提供通过标准文件和其他的进程交 互
的能力;对于 python2.4 和更新的版本,使用 subpross)
commands              提供额外的在 os.system 之上的功能:把所有的程序输出保存在返回的
字符串中(与输出到屏幕的相反)                 ;对于 python2.4 和更新的版本,使
用 subpross○ U
getopt                 在这样的应用程序中的处理选项和命令行参数
site               处理 site-specific 模块或包
platformb       底层平台和架构的属性
subprocessc         管理(计划替代旧的函数和模块,比如 os.system(), os.spawn*(),
os.popen*(), popen2.*, command.*)
a.   python2.0 时加入
b.       python2.3 时加入
c.   python2.4 时加入
14.9 相关模块


在表 14.9 中, 除了 os 和 sys 模块,你还可以找到与这章执行环境主题相关的模块列表。
14.10     练习
14–1.   可调用对象。说出 python 中的可调用对象。exec 语句和内建函数 eval()有什么不同?
14–2.   input()和 raw.input()。 内建函数 raw_input()和 input()有什么不同?
14–3.   执行环境。创建运行其他 python 脚本的 python 脚本
14–4. os.system()。选择熟悉的系统命令,该命令执行任务时不需要输入,也不输出到屏幕
或根本不输出任何东西。调用 os.system()运行程序
附加题:你的解决方案移植到 subprocess.call()
14–5.   commands.getoutput().用 commands.getoutput()解决前面的问题
14–6.    popen()家族。选择熟悉的系统命令,该命令从标准输入获得文本,操作或输出数据。
使用 os.popen()与程序进行通信。输出到哪儿呢?使用 popen2.popen2()代替。
14–7.    subprocess 模块。把先前问题的解决方案移植到 subprocess 模块。
14–8.    exit 函数。设计一个在程序退出时的函数。安装到 sys.exitfunc(),运行程序,演
示你 exit 函数确实被调用了。
14–9.    shells。创建 shell(操作系统接口)程序。给出接受操作系统命令的命令行接口(任
意平台)
附加题 1:支持管道(见 os 模块中的 dup(), dub2(),和 pipe()函数)。管道过程允许进程的标
准输入连接到另一个进程的标准输入。
附加题 2:用括号支持逆序的管道,给 shell 一个函数式编程接口。换句话说,支持更加函数
式风格如. . .sort(grep(ps -ef, root), -n, +1),而不是 ps -ef | grep root | sort -n +1. . .
这样的命令
14–10. fork()/exec*()和 spawn*()的比较.使用 fork()-exec*()对和 spawn*()家族函数有什
么不同?那一组的功能更强?
14–11.生成和执行 python 代码。用 funcAttrs.py 脚本(例 14.4)加入测试代码到已有程序的


函数中。创建一个测试框架,每次遇到你特殊的函数属性,它都会运行你的测试代码。


正则表达式
本章主题
z 引言/动机
z 特别的字符和符号
z 正则表达式与 Python
z re 模块


15.1 介绍/动机
处理文本和数据是件大事。如果您不相信我说的话,请仔细看看现如今的计算机主要都在做些
什么工作。文字处理、网页填表、来自数据库的信息流、股票报价信息、新闻列表,这个清单还会
不断地增长。因为我们可能不知道这些需要计算机编程处理文本或数据的具体内容,所以能把这些
文本或数据以某种可被计算机识别和处理的模式表达出来是非常有用的。
假设我在运营一个电子邮件档案公司,而您是我的一位顾客,比如说,您想获得自己去年二月
间收发的所有邮件,如果我能设计一个计算机程序来整理信息然后将它转发给您,而不是通过人工
方法通读您的邮件后再手动地处理您的请求,如此处理将会非常不错。因为如果有人会看遍您的邮
件信息,哪怕只是是用眼睛看一下邮件上的时间,您可能都会对此感到担心(甚至愤怒)。又比如,
您可能会认为凡是带有“ILOVEYOU”这样主题的邮件都是已感染病毒的信息,并要求从您的个人邮
箱中删除它们。这就引出一个问题,我们如何通过编程使计算机具有在文本中检索某种模式的能力。
正则表达式(RE)为高级文本模式匹配,以及搜索-替代等功能提供了基础。正则表达式(RE)是一
些由字符和特殊符号组成的字符串,它们描述了这些字符和字符的某种重复方式,因此能按某种模
式匹配一个有相似特征的字符串的集合,因此能按某模式匹配一系列有相似特征的字符串,见图 15
–1。换句话说,它们能匹配多个字符串 - 一个只能匹配一个字符串的 RE 模式是乏味且毫无作用的,
你说是不是?


图 15-1    你可以用这个正则表达式匹配有效的 Python 标志符。"[A-Za-z]\w+ " 的含义是:
第一个字符是字母,即,由大写字母 A 到 Z 或是小写字母 a 到 z 组成, 它后面至少(+)跟有一个由字
母或数字组成的字符(\w). 如图,你看到有很多字符串被过滤,只有那些符合我们要求的 RE 模式的
字符串被筛选出来。比如,“4xZ”,因为它是以数字开头的,所以被过滤了。
Python 通过标准库的 re 模块支持正则表达式(RE)。本节我们将向你简要地介绍这。限于篇幅,
内容将仅涉及 Python 编程中正则表达式(RE)方面最常见的内容。你们(对正则)的经验(熟悉程度)肯
定不同。我们强烈建议您阅读一些官方帮助文档和与此主题有关的文本。那么你对字符串的理解方
式就会有所改变。
核心笔记:查找与匹配的比较
本章通篇涉及到对查找和匹配用法的讲述。当我们完全讨论与字符串中模式有关的正则表达式
时,我们会用术语 “matching”(“匹配”),指的是术语 pattern-matching(模式匹配)。在 Python
专门术语中,有两种主要方法完成模式匹配:搜索(searching)和匹配(matching)。搜索,即在字符
串任意部分中查找匹配的模式,而匹配是指,判断一个字符串能否从起始处全部或部分的匹配某个
模式。搜索通过 search()函数或方法来实现,而匹配是以调用 match()函数或方法实现的。
总之,当我们说模式的时候,我们全部使用术语“matching”(“匹配”);我们按照 Python 如


何完成模式匹配的方式来区分“搜索”和“匹配”。
15.1.1 您的第一个正则表达式
我们上面已经提到,正则表达式是含有文本和特别字符的字符串,这些文本和特别字符描述的
模式可以识别各种字符串。我们还简单阐述了正则表达式字母表,以及用于匹配通用文本的正则表
达式字母表——所有大小写字母及数字的集合。也存在特别的字母表,比如,只含有字符"0"和"1"
的字母表. 该字母表可以表示所有二进制整数的集合,即,"0," "1," "00," "01," "10," "11,"
"100," 等.
让我们看看正则表达式的基本情况,虽然正则表达式常被视为是“高级主题”                                     ,有时候它们也是
非常简单的。我们列出一些用一般文本的标准字母组成简单的正则表达式及它们所描述的字符串。
以下的正则表达式是最基本,最普通的。它们仅由一个字符串定义了一个模式,该模式仅匹配这个字
符串本身,该字符串由正则表达式定义。以下是正则表达式(RE)和匹配它们的字符串。
RE Pattern         String(s) Matched
foo              foo
Python       Python
abc123             abc123
上表中第一个正则表达式模式是"foo"。这个模式不包含任何特殊符号去匹配其他符号,它仅匹
配自身所描述的,所以只有字符串"foo"匹配此模式。同理,                       “Python”和“abc123.”也一样。正则
表达式的强大之处在于特殊符号的应用,特殊符号定义了字符集合,子组匹配,模式重复次数。正
是这些特殊符号使得一个正则表达式可以匹配字符串集合而不只是一个字符串。
15.2 正则表达式使用的特殊符号和字符
现在,我们来介绍最常用的元字符(metacharacters)——特殊字符和符号,正是它们赋予了正则
表达式强大的功能和灵活性。正则表达式中最常见的符号和字符见表 15.1.
表 15.1 常用正则表达式符号和特殊字符
记号              说明                                 举例
Symbols


Symbols   描述                      正则表达式样例
符号
15.2.1 用管道符号( | )匹配多个正则表达式模式
管道符号( | ), 就是您键盘上的竖杠,表示一个或操作,它的意思是选择被管道符号分隔的
多个不同的正则表达式中的一个。例如,下面的一些使用或操作的模式,和它们所匹配的字符串:


正则表达式模式         匹配的字符串
有了这个符号,正则表达式的灵活性增强了,使得它可以匹配不止一个字符串,“或”(操作)
有时候也被叫做“联合”(union)或者逻辑或(OR)。
15.2.2 匹配任意一个单个的字符( . )
点字符或句号(.)符号匹配除换行符(NEWLINE)外的任意一个单个字符(Python 的正则表达式有
一个编译标识 [S or DOTALL],该标识能 去掉 这一限制,使 ( . ) 在匹配时包括换行符(NEWLINEs)。)
(这里括号缺一半) 无论是字母、数字、不包括“\n”的空白符、可打印的字符、还是非打印字符,
或是一个符号,“点”,( . )都可以匹配他们。
正表达式模式        匹配的字符串
f.o           在"f"和"o"中间的任何字符,如 fao, f9o, f#o 等
..            任意两个字符
.end          匹配在字符串 end 前面的任意一个字符
问:我怎样才能匹配点号(dot)或句号(period)?
答:为了明确地匹配一个点号(dot)本身,你必须(在前面)使用反斜线“\”对它进行转义。
15.2.4 从字符串的开头或结尾或单词边界开始匹配( ^/$ /\b /\B )
还有些符号和特殊字符是用来从字符串的开头或结尾开始搜索正则表达式模式的。如果想从字
符串的开头开始匹配一个模式,你必须用脱字符号( ^ , 即,Caret)或特殊字符 \A (大写字母 A 前
面加上一个反斜线). 后者主要是为那些没有 caret 符号的键盘使用的,比如说国际键盘。类似,美
元符号 ( $ ) 或 \Z 是用来(零宽度)匹配字符串的结尾的。
用这些符号的模式与我们将在本章讲述的其它大多数符号是不同的,因为这些符号指定了(匹配
字符)的位置。在上面的核心笔记里,我们曾说过 “matching”和“searching” 之间的区别,             “matching”
是试图从整个字符串的开头进行匹配,而 “searching” 则可从一个字符串的任意位置开始匹配。
正因为这几个字符和搜索的位置有关,所以需要和搜索模式一起使用。下面是几个“擦边球”的正
则表达式搜索模式:


正则表达式模式          匹配的字符串
^From            匹配任何以 From 开始的字符串
/bin/tcsh$       匹配任何以 /bin/tcsh 结束的字符串
^Subject: hi$    匹配仅由 Subject: hi 组成的字符串
特别说明,如果你想匹配这两个字符中的任何一个(或全部),就必须用反斜线进行转义。例如,
如果你想匹配任何以 美元符号($) 结尾的字符串,一个可行的解决办法是用正则表达式模式
“.*\$$”.
特殊字符 \b and \B 用来匹配单词边界。两者之间的区别是,\b 匹配的模式是一个单词边界,
就是说,与之对应的模式一定在一个单词的开头,不论这个单词的前面是有字符(该词在一个字符串
的中间),还是没有字符(该单词在一行的起始处)。同样地,\B 只匹配出现在一个单词中间的模式(即,
不在单词边界上的字符)。看下面几个例子:
RE Pattern       Strings Matched
the              任何包含有"the"的字符串
\bthe            任何以"the"开始的字符串
\bthe\b          仅匹配单词 “the”
\Bthe           任意包含“the”但不以“the”开头的单词
15.2.5 创建字符类( [ ] )
尽管点号可用来匹配任意字符,但有时候你需要匹配某些个特殊的字符。正因为如此,方括号
( [ ] )被发明出来。使用方括号的正则表达式会匹配方括号里的任何一个字符。几个例子如下:
正则表达式模式          匹配的字符串
b[aeiu]t          bat, bet, bit, but
[cr][23][dp][o2]    一个包含 4 个字符的字符串: 第一个字符是 “r” 或 “c”                ,后面是 “2”
或 “3”,再接下来是 “d” 或 “p”,最后是 “o” 或 “2“ ,例
如:c2do, r3p2, r2d2, c3po, 等等。
关于正则表达式 “[cr][23][dp][o2]” 的一点要说明: 如果只让 “r2d2” 或 “c3po” 成
为有效的字符串,就需要限定更为严格的正则表达式。但因为方括号只有"逻辑或"(“logical OR”)
的功能,所以用方括号不能实现这一限定要求。唯一的解决办法是用管道符号(pipe), 例如:
“r2d2|c3po”.
对仅有单个字符的正则表达式 ,使用管道符号和方括号的效果是等价的。举例来说,正则表达
式“ab” , 只匹配以"a"开头后面再跟一个"b"的字符串。如果我们只想要一个字母的字符串,即,
“a” 或者 “b” 中的一个,就可以使用正则表达式 “[ab]” 。因为 “a” 和 “b” 是单个的


字符串,我们也可以用正则表达式 “a|b”。但是,如果我们想用模式匹配"ab",后面接着是"cd"的
字符串,就不能用方括号了,因为方括号只适用于单个字符的情况。这样,唯一的办法是用“ab|cd”,
这和我们刚才提到的 “r2d2|c3po”的道理是相同的。
15.2.5     指定范围 ( - ) 和 否定( ^ )
方括号除匹配单个字符外,还可以支持所指定的字符范围。方括号里一对符号中间的连字符(-)
用来表示一个字符的范围,例如,A–Z, a–z, 或 0–9 分别代表大写字母、小写字母和十进制数
字。这是一个按字母顺序排序的范围,所以它不限于只用在字母和十进制数字上。另外,如果在左
方括号后第一个字符是上箭头符号(^),就表示不匹配指定字符集里的任意字符。
正则表达式模式           匹配的字符
z.[0-9]           字符"z",后面跟任意一个字符,然后是一个十进制数字
[r-u][env-y][us]   “r” “s,” “t” 或 “u” 中的任意一个字符,后面跟的是 “e,”
“n,” “v,” “w,” “x,” 或 “y”中的任意一个字符,再后面
是字符“u” 或 “s”.
[^aeiou]            一个非元音字符 (练习: 为什么我们说”非元音“, 而不说”辅
音字母“?)
[^\t\n]           除 TAB 制表符和换行符以外的任意一个字符
["-a]         在使用 ASCII 字符集的系统中,顺序值在‘"‘ 和 “a”之间         的
任意一个字符,即,顺序号在 34 和 97 之间的某一个字符。
15.2.6     使用闭包操作符 ( *, +, ?, {} ) 实现多次出现/重复匹配
现在我们来介绍最常用的正则表达式符号,即,特殊符号 “*”, “+”, 和 “?”, 它们可以
用于匹配字符串模式出现一次、多次、或未出现的情况。星号或称星号操作符匹配它左边那个正则
表达式出现
零次或零次以上的情况(在计算机语言和编译器原理里,此操作符被叫做 Kleene 闭包操作符)。
加号(+)操作符匹配它左边那个正则表达式模式至少出现一次的情况(它也被称为正闭包操作符),而
问号操作符( ? )匹配它左边那个正则表达式模式出现零次或一次的情况。
还有花括号操作符({ }), 花括号里可以是单个的值,也可以是由逗号分开的一对值。如果是
一个值,如,{N},则表示匹配 N 次出现;如果是一对值,即,{M, N},就表示匹配 M 次到 N 次出现。
可以在这些符号前用反斜线进行转义,使它们失去特殊作用,即, “\*” 将匹配星号本身等。
在上表中,我们注意到问号出现了不只一次(被重载),问号有两种含义:1.单独使用时表示匹配
出现零次或一次的情况,2.紧跟在表示重复的元字符后面时,表示要求搜索引擎匹配的字符串越短
越好。例如:(+?)


前面提到"越短越好..."是什么意思呢?当使用了表示重复的元字符(*+?{m,n})时,正则表达式
引擎在匹配模式时会尽量"吸收"更多的字符。这就叫做"贪心"。问号告诉正则表达式引擎尽可能地
偷懒,要求当前匹配消耗的字符越少越好,留下尽可能多的字符给后面的模式(如果存在)。 - 在本
章末尾,我们举一个有代表性的例子来说明必须使用非贪心模式的情况。
现在,让我们接着来看一些使用闭包操作符的例子:
RE Pattern         Strings Matched
[dn]ot?          字符"d"或"o", 后面是一个"o", 最后是最多一个字符"t",即,do, no, dot,
not
0?[1-9]             从 1 到 9 中的任意一位数字,前面可能还有一个"0". 例如:可以把它看
成一月到九月的数字表示形式,不管是一位数字还是两位数字的表示形
式。
[0-9]{15,16}      15 或 16 位数字表示,例如:信用卡号码
</?[^>]+>          匹配所有合法(和无效的)HTML 标签的字符串
[KQRBNP][a-h][1-8]-[a-h][1-8]          在“长代数”记谱法中,表示的国际象棋合法的棋盘。
即, “K,” “Q,” “R,” “B,” “N,” 或 “P” 等
字母后面加上两个用连字符连在一起的"a1"到"h8"之间
的棋盘坐标。前面的编号表示从哪里开始走棋,后面的
编号代表走到哪个位置(棋格)去。
15.2.7      特殊字符表示字符集
我们还提到有一些特殊字符可以用来代表字符集合。例如,你可以不使用 “0–9”这个范围
表示十进制数字,而改用简写“\d”表示。另一个特殊的字符 “\w” 可用来表示整个 字符数字的
字符集,即相当于“A-Za-z0-9_”的简写形式,特殊字符“\s” 代表空白字符。这些特殊字符的大
写形式表示不匹配,比如,“\D” 表示非十进制数字的字符(等价于 “[^0-9]”),等等。 我们来
看几个运用这些简写形式的稍复杂的例子:
正则表达式模式               匹配的字符串
\w+-\d+               一个由字母或数字组成的字符串,和至少一个数字,两部分中间由连
字符连接
[A-Za-z]\w*          第一个字符是字母,其余字符(如果存在的话),是字母或数字(它几乎
等价于 Python 语言中合法的标识符[见参考练习])
\d{3}-\d{3}-\d{4}     (美国)电话号码,前面带区号前缀,例如 800-555-1212
\w+@\w+\.com          简单的 XXX@YYY.com 格式的电子邮件地址


15.2.8     用圆括号(()) 组建组
现在,或许我们可以匹配一个字符串和丢弃那些不匹配的字符串了,但有时候,我们也许对匹
配的数据本身更有兴趣。我们不仅想知道是否整个字符串匹配我们的条件(正则表达式),还想在匹
配成功时取出某个特定的字符串或子字符串。要达到这个目的,只需要给正则表达式的两边加上一
对圆括号。
一对圆括号(()) 和正则表达式一起使用时可以实现以下任意一个(或两个)功能:
z   对正则表达式进行分组
z   匹配子组
有时你需要对正则表达式进行分组,其中一个很好的例子就是,你要用两个不同的正则表达式
去比较一个字符串。另一个理由是为整个正则表达式添加一个重复操作符(即不是仅重复单个字符或
单一字符集)。
使用圆括号的一个额外好处就是匹配的子串会被保存到一个子组,便于今后使用。这些子组可
以在同一次匹配或搜索中被重复调用,或被提取出来做进一步处理。在小节 15.3.9 的结尾你会读
到一些提取子组的例子。
为什么需要使用子组匹配呢? 主要是有时除了进行匹配操作外,你还想要提取匹配模式的内容。
如果想知道在成功的匹配中,是哪些字符串匹配了我们的正则表达式模式。例如,我们想用正则表
达式“\w+-\d+”匹配一些内容,但又想把第一部分的字符和第二部分的数字分别保存,该怎么做呢?
如果我们给两个子模式都加上圆括号,即,将它写成 “(\w+)-(\d+)” , 那我们就可以对这
两个匹配的子组分别进行访问了。当然你也可以使用其他方法达到同样目的,比如,先写一段代码判
断是否找到匹配的对象,然后再执行另一个程式(也必须再写一段代码)来解析整个匹配的部分,从
中提取出两个部分来。然而相比之下把正则表达式划分为子组是更好的实现办法,因为 Python 已经
在 re 模块里支持此功能,那为什么不让 Python 来做这项工作,而非要重复发明一个轮子呢?
正则表达式模式               匹配的字符串
\d+(\.\d*)?             表示简单的浮点数,即, 任意个十进制数字,后面跟一个可选的小
数点,然后再接零或多个十进制数字。例如:                   “0.004,”“2,”“75.”,
等等。
(Mr?s?\. )?[A-Z][a-z]* [ A-Za-z-]+        名字和姓氏,对名字的限制(首字母大写,其它字
母(如果存在)小写), 全名前有可选的称谓(“Mr.,”
“Mrs.,” “Ms.,” 或 “M.,”),姓氏没有什么
限制,允许有多个单词、横线、大写字母。


15.3 正则表达式和 Python 语言
既然我们已知道了有关正则表达式本身的所有知识,那让我们来详细研究当前 Python 的默认正
则表达式模块 re 模块吧. re 模块在 Python1.5 版本被引入。如果你正在使用 Python 的早期版本,
你将只能用已过时的 regex、regsub 模块。这些模块具有 Emacs 风格,功能不丰富,而且与现在的
re 模块也不兼容。regex 和 regsub 这两个模块已在 Python 2.5 版本时被移除了,在 Python2.5 及
其后续版本,引入这两个模块中的任何一个将会引发 Import Error 异常。
但正则表达式本身是不变的,所以本小节中的大多数基本概念仍然适用于旧版的 regex 和
reg-sub 模块。与旧模块形成鲜明对比的是,新的 re 模块支持功能更强大、更通用的 Perl 风格(具
体说是 Perl5 的风格)的正则表达式,允许多线程共享同一经过编译的正则表达式对象,同时它还支
持对正则表达式分组进行命名和按名字调用。另外, 有一个名叫 reconvert 的转换模块是帮助开发
者从 regex/regsub 模块 迁移到 re 模块的。但请注意,正则表达式有不同的风格,我们主要研究当
今 Python 语言中使用的正则表达式。
re 引擎已在 Python1.6 版本中被重写,改进了它的性能并添加了对 Unicode 的支持。接口并没
有改变,因此模块的名字也保持不变。新的 re 引擎,内部被叫做 sre, 替代了 1.5 版本中内部名为
pcre 的 re 引擎。
15.3.1    re 模块: 核心函数和方法
表 15.2 列出了 re 模块最常用的函数和方法。其中有很多函数也与已编译的正则表达式对象
(regex objects) 和正则"匹配对象"(RE “match objects”)的方法同名并且具有相同功能。
在本小节,我们来看两个主要的函数/方法,match() 和 search(), 以及 compile()函数。在下
一节我们还会再介绍更多个,但如果想进一步了解我们涉及或没有涉及的更多相关信息,我们建议
你参阅 Python 的文档。
表 15.2 常见的正则表达式函数与方法
函数/方法                            描述
re 模块的函数
compile(pattern,flags=0)       对正则表达式模式 pattern 进行编译,flags 是可选标志符,
并返回一个 regex 对象
re 模块的函数和 regex 对象的方法
match(pattern,string, flags=0)      尝试用正则表达式模式 pattern 匹配字符串 string,


flags 是可选标志符,如果匹配成功,则返回一个匹配对
象;否则返回 None
search(pattern,string, flags=0)        在字符串 string 中查找正则表达式模式 pattern 的第
一次出现,flags 是可选标志符,如果匹配成功,则返回
一个匹配对象;否则返回 None
a
findall(pattern,string[,flags])        在字符串 string 中查找正则表达式模式 pattern 的所有
(非重复)出现;返回一个匹配对象的列表
b
finditer(pattern,string[, flags]) 和 findall()相同,但返回的不是列表而是迭代器;对
于每个匹配,该迭代器返回一个匹配对象
表 15.3 常见的正则表达式函数与方法(继续)
函数/方法                                        描述
匹配对象的方法
split(pattern,string, max=0)       根据正则表达式 pattern 中的分隔符把字符 string 分割
为一个列表,返回成功匹配的列表,最多分割 max 次(默
认是分割所有匹配的地方)。
sub(pattern, repl, string, max=0) 把字符串 string 中所有匹配正则表达式 pattern 的地
方替换成字符串 repl,如果 max 的值没有给出,则对所有
匹配的地方进行替换(另外,请参考 subn(),它还会返回
一个表示替换次数的数值)。
group(num=0)          返回全部匹配对象(或指定编号是 num 的子组)
groups()          返回一个包含全部匹配的子组的元组(如果没有成功匹配,就返回一个空元
组)
a. Python 1.5.2 中新增; 2.4 中增加标识参数
b. Python 2.2 新增;2.4 中增加标识参数
核心笔记: RE 编译(何时应该使用 compile 函数?)
在第十四章,我们曾说过 Python 的代码最终会被编译为字节码,然后才被解释器执行。我们特
别提到用调用 eval() 或 exec()调用一个代码对象而不是一个字符串,在性能上会有明显地提升,
这是因为对前者来说, 编译过程不必执行。换句话说,使用预编译代码对象要比使用字符串快,因
为解释器在执行字符串形式的代码前必须先把它编译成代码对象。
这个概念也适用于正则表达式,在模式匹配之前,正则表达式模式必须先被编译成 regex 对象。
由于正则表达式在执行过程中被多次用于比较,我们强烈建议先对它做预编译,而且,既然正则表
达式的编译是必须的,那使用么预先编译来提升执行性能无疑是明智之举。re.compile() 就是用来
提供此功能的。
其实模块函数会对已编译对象进行缓存,所以不是所有使用相同正则表达式模式的 search()和
match()都需要编译。即使这样,你仍然节省了查询缓存,和用相同的字符串反复调用函数的性能开


销。 在 Python1.5.2 版本里, 缓存区可以容纳 20 个已编译的正则表达式对象,而在 1.6 版本里,
由于另外添加了对 Unicode 的支持,编译引擎的速度变慢了一些,所以缓存区被扩展到可以容纳 100
个已编译的 regex 对象。
15.3.2   使用 compile()编译正则表达式
我们稍后要讲到的大多数 re 模块函数都可以作为 regex 对象的方法。注意,尽管我们建议预编
译,但它并不是必需的。如果你需要编译,就用方法,如果不需要,可以使用函数。幸运的是无论
你用哪种方式-函数还是方法,名字都是相同的。(也许你曾对此好奇,这正是模块函数和方法完全
一样的原因,例如,search(), match()等等) 在后面的例子里,我们将用字符串,这样可以省去一
个小步骤。我们仍会用到几个预编译代码对象,这样你可以知道它的过程是怎么回事。
编译 rex 对象时给出一些可选标志符,可以得到特殊的编译对象。这些对象将允许不区别大小
写的匹配,或使用系统的本地设置定义的字母表进行匹配等。详情请参阅有关文档。这些标志符也
可以做为参数传给模块 (改字) 版本的 match()和 search()进行特定模式的匹配,其中一些标志符
已在前面做过简短介绍(例如,DOTALL,LOCALE) - 这些标志符多数用于编译,也正因如此它们可以
被传给模块版本的 match()和 search(),而 match()和 search()肯定要对正则表达式模式编译一次。
如果你想在 regex 对象的方法中使用这些标志符,则必须在编译对象时传递这些参数。
除下面的方法外,regex 对象还有一些数据属性,其中两个是创建时给定的编译标志符和正则
表达式模式。
15.3.3   匹配对象 和 group(), groups() 方法
在处理正则表达式时,除 regex 对象外,还有另一种对象类型 - 匹配对象。这些对象是在 match()
或 search()被成功调用之后所返回的结果。匹配对象有两个主要方法:group() 和 groups().
group()方法或者返回所有匹配对象或是根据要求返回某个特定子组。groups()则很简单,它返
回一个包含唯一或所有子组的元组。如果正则表达式中没有子组的话, groups() 将返回一个空元
组,而 group()仍会返回全部匹配对象。
Python 语言中的正则表达式支持对匹配对象进行命名的功能,这部分内容超出了本介绍性小节
对正则表达式的讨论范围。我们建议你阅读 re 模块的文档,里面有我们省略掉的关于这些高级主题
的详细内容。
15.3.4 用 match()匹配字符串


我们先来研究 re 模块的函数、正则表达式对象(regex object)的方法: match(). match()函
数尝试从字符串的开头开始对模式进行匹配。如果匹配成功,就返回一个匹配对象,而如果匹配失
败了,就返回 None。   匹配对象的 group() 方法可以用来显示那个成功的匹配。下面是如何运用 match()
[及 group()]的一个例子:
>>> m = re.match('foo', 'foo') # pattern matches string ,模式匹配字符串
>>> if m is not None: # show match if successful 如果成功,显示匹配
... m.group()
...
'foo'
模式"foo"完全匹配字符串"foo"。在交互解析器中,我们能确定 m 就是一个匹配对象的实例。
>>> m   # confirm match object returned         确定返回匹配对象
<re.MatchObject instance at 80ebf48>
这是当匹配失败时的例子,它返回 None:
>>> m = re.match('foo', 'bar')# pattern does not match string 模式不匹配字符串
>>> if m is not None: m.group()# (1-line version of if clause) 一行的 if 子句
...
>>>
上面的匹配失败,所以 m 被赋值为 None,因为我们写的 if 语句中没有什么行动,所以也没有什
么指令动作被执行。在以后的例子中,为了简洁,在可能的情况下,我们会省去 if 检查语句,但在
实际编程中,最好写上它,以防止出现 AttributeError 异常(失败后返回 None, 此时它是没有 group()
属性[方法]的)。
即使字符串比模式要长,匹配也可能成功;只要模式是从字符串的开始进行匹配的。例如,模
式"foo" 在字符串“food on the table”中找到一个匹配,因为它是从该字符串开头进行匹配的:
>>> m = re.match('foo', 'food on the table') # match succeeds            # 匹配成功
>>> m.group()
'foo'
如你看到的,尽管字符串比模式要长,但从字符串开头有一个成功的匹配。 子串 "foo"是从那
个较长的字符串中抽取出来的匹配部分。


我们甚至可以充分利用 Python 语言面向对象的特性,间接省略中间结果,将最终结果保存到一
起:
>>> re.match('foo', 'food on the table').group()
'foo'
注意,上面的例子中,如果匹配失败,会引发一个 AttributeError 异常.
15.3.5     search() 在一个字符串中查找一个模式 (搜索与匹配的比
较)
其实,你要搜索的模式出现在一个字符串中间的机率要比出现在字符串开头的机率更大一些。
这正是 search()派上用场的时候。search 和 match 的工作方式一样,不同之处在于 search 会检查
参数字符串任意位置的地方给定正则表达式模式的匹配情况。如果搜索到成功的匹配,会返回一个
匹配对象,否则返回 None。
现在我们来举例说明 match()和 search()之间的区别。让我们举一个对长字符串进行匹配的例
子。这次,我们用字符串"foo"去匹配“seafood”:
>>> m = re.match('foo', 'seafood') # no match 匹配失败
>>> if m is not None: m.group()
...
>>>
如你所见,这里没有匹配成功。match()尝试从字符串起始处进行匹配模式,即,模式中的"f"
试匹配到字符串中首字母"s"上, 这样匹配肯定是失败的。但字符串"foo" 确实出现在“seafood”
中,那我们如何才能让 Python 得出肯定的结果呢? 答案是用 search()函数。search() 查找字符串
中模式首次出现的位置,而不是尝试(在起始处)匹配。严格地说,search() 是从左到右进行搜索。
>>> m = re.search('foo', 'seafood') # use search() instead 改用 search()
>>> if m is not None: m.group()
...
'foo'    # search succeeds where match failed 用 search 成功匹配,用 match 匹配失败
>>>
在本小节以后的内容里,将通过大量的例子展示如何在 Python 语言中运用正则表达式,我们会
用到 regex 对象的方法 match()和 search(),匹配对象的方法 group()、groups(),以及正则表达式
语法中的绝大多数特殊字符和符号。


15.3.6 匹配多个字符串( | )
在 15.2 小节里,我们在正则表达式“bat|bet|bit”中使用了管道符号. 下面,我们把这个正
则表达式用到 Python 的代码里:
>>> bt = 'bat|bet|bit' # RE pattern: bat, bet, bit        #正则表达式模式: bat, bet, bit
>>> m = re.match(bt, 'bat') # 'bat' is a match            #'bat' 是匹配的
>>> if m is not None: m.group()
...
'bat'
>>> m = re.match(bt, 'blt') # no match for 'blt'             #没有匹配'blt'的模式
>>> if m is not None: m.group()
...
>>> m = re.match(bt, 'He bit me!')# does not match string                #不匹配字符串
>>> if m is not None: m.group()
...
>>> m = re.search(bt, 'He bit me!')# found 'bit' via search            #搜索到'bit'
>>> if m is not None: m.group()
...
'bit'
15.3.7 匹配任意单个字符( . )
以下的例子中,我们将说明点号是不能匹配换行符或非字符(即,空字符串)的:
>>> anyend = '.end'
>>> m = re.match(anyend, 'bend') # dot matches 'b'            #点号匹配'b'
>>> if m is not None: m.group()
...
'bend'
>>> m = re.match(anyend, 'end') # no char to match                  #没有字符匹配
>>> if m is not None: m.group()
...
>>> m = re.match(anyend, '\nend')       # any char except \n        #匹配字符(\n 除外)
>>> if m is not None: m.group()
...
>>> m = re.search('.end', 'The end.')# matches ' ' in search .                #匹配' '


>>> if m is not None: m.group()
...
' end'
下面的例子是来搜索一个真正点号(小数点)的正则表达式,在正则表达式中,用反斜线对它进
行转义,使点号失去它的特殊意义:
>>> patt314 = '3.14' # RE dot                #正则表达式点号
>>> pi_patt = '3\.14' # literal dot (dec. point)         #浮点(小数点)
>>> m = re.match(pi_patt, '3.14') # exact match          #完全匹配
>>> if m is not None: m.group()
...
'3.14'
>>> m = re.match(patt314, '3014') # dot matches '0'            #点号匹配 '0'
>>> if m is not None: m.group()
...
'3014'
>>> m = re.match(patt314, '3.14') # dot matches '.'            #点号匹配 '.'
>>> if m is not None: m.group()
...
'3.14'
15.3.8 创建字符集合( [ ] )
前面,我们曾讨论过 “[cr][23][dp][o2]”和“r2d2|c3po”是不同的。 从下面的例子中,可
以看出“r2d2|c3po” 与“[cr][23][dp][o2]” 相比有更加严格的限制:
>>> m = re.match('[cr][23][dp][o2]', 'c3po')# matches 'c3po'        #匹配'c3po'
>>> if m is not None: m.group()
...
'c3po'
>>> m = re.match('[cr][23][dp][o2]', 'c2do')# matches 'c2do'        #匹配'c2do'
>>> if m is not None: m.group()
...
'c2do'
>>> m = re.match('r2d2|c3po', 'c2do')# does not match 'c2do'        #不匹配'c2do'
>>> if m is not None: m.group()
...
>>> m = re.match('r2d2|c3po', 'r2d2')# matches 'r2d2'               #匹配'r2d2'


>>> if m is not None: m.group()
...
'r2d2'
15.3.9 重复、特殊字符和子组
正则表达式中最常见的情况包括特殊字符的使用,正则表达式模式的重复出现,以及使用圆括
号对匹配模式的各部分进行分组和提取操作。我们曾看到过一个关于简单电子邮件地址的正则表达
式(“\w+@\w+\.com”). 或许我们想要匹配的邮件地址比这个正则表达式的允许的要多。比如,为
了在域名前添加主机名称支持,即, 支持“www.xxx.com”,而不只是允许“xxx.com”做整个域名,
我们就必须修改现有的正则表达式。为了表示主机名是可选的,我们要写一个模式匹配主机名(后面
跟一个点号),然后用问号“?”表示此模式可出现 0 次或 1 次,表示此部分是可选的,再把这个可
选的正则表达式插入到我们前面的那个正则表达式中去:                           “\w+@(\w+\.)?\w+\.com” 。 从下面的例
子中可以看出,这个表达式容许“.com”前面有一个或两个名字:
>>> patt = '\w+@(\w+\.)?\w+\.com'
>>> re.match(patt, 'nobody@xxx.com').group()
'nobody@xxx.com'
>>> re.match(patt, 'nobody@www.xxx.com').group()
'nobody@www.xxx.com'
接下来,我们用以下模式进一步扩展我们的例子,允许任意数量的子域名存在。请特别注意细
节的变化,将 ? 改为 *:“\w+@(\w+\.)*\w+\.com”:
>>> patt = '\w+@(\w+\.)*\w+\.com'
>>> re.match(patt, 'nobody@www.xxx.yyy.zzz.com').group()
'nobody@www.xxx.yyy.zzz.com'
但我们必须要说明的是仅用字母或数字组成的字符不能满足邮件地址中可能出现的各种字符。
上述正则表达式不匹配如“xxx-yyy.com” 这样的域名或其他带有非单词字符(如“\W”等)的域名。
前面,我们曾讨论过用括号匹配并保存子组做进一步处理的好处,这样做比在确定正则表达式
匹配后,再单写一个子程序来解析一个字符串要好。我们还特别提到用来匹配 以"-"分隔的字母或
数字组成的字符串和数字串的正则表达式 “\w+-\d+” ,以及如何通过对此正则表达式划分子组以
构建一个新的正则表达式, “(\w+)-(\d+)” 来完成任务,下面是旧版正则表达式的执行情况:
>>> m = re.match('\w\w\w-\d\d\d', 'abc-123')
>>> if m is not None: m.group()
...


'abc-123'
>>> m = re.match('\w\w\w-\d\d\d', 'abc-xyz')
>>> if m is not None: m.group()
...
>>>
上面的代码中,一个正则表达式被用来匹配由三个字母或数字组成的字符串,再接着三个数字的
字符串。这个正则表达式匹配“abc-123”,但不匹配“abc-xyz”。我们现在来修改正则表达式,使
它能分别提取包含字母或数字的部分和仅含数字的部分。请注意我们是如何用 group()方法访问每个
子组以及用 groups()方法获取一个包含所有匹配子组的元组的:
>>> m = re.match('(\w\w\w)-(\d\d\d)', 'abc-123')
>>> m.group() # entire match 所有匹配部分
'abc-123'
>>> m.group(1) # subgroup 1     匹配的子组 1
'abc'
>>> m.group(2) # subgroup 2     匹配的子组 2
'123'
>>> m.groups() # all subgroups 所有匹配子组
('abc', '123')
如你所见,group()通常用来显示所有匹配部分,也可用来获取个别匹配的子组。我们可用
groups()方法获得一个包含所有匹配子组的元组。
下面这个简单的例子通过子组的不同排列组合,帮助我们理解得更透彻:
>>> m = re.match('ab', 'ab') # no subgroups         #无子组
>>> m.group() # entire match
'ab'
>>> m.groups() # all subgroups                      #所有匹配的子组
()
>>>
>>> m = re.match('(ab)', 'ab') # one subgroup       #一个子组
>>> m.group() # entire match                         #所有匹配
'ab'
>>> m.group(1) # subgroup 1                       #匹配的子组 1
'ab'
>>> m.groups() # all subgroups                      #所有匹配子组


('ab',)
>>>
>>> m = re.match('(a)(b)', 'ab') # two subgroups #两个子组
>>> m.group() # entire match
'ab'
>>> m.group(1) # subgroup 1     匹配的子组 1
'a'
>>> m.group(2) # subgroup 2     匹配的子组 2
'b'
>>> m.groups() # all subgroups       所有匹配子组的元组
('a', 'b')
>>>
>>> m = re.match('(a(b))', 'ab') # two subgroups         #两个子组
>>> m.group() # entire match                          #所有匹配部分
'ab'
>>> m.group(1) # subgroup 1                           #匹配的子组 1
'ab'
>>> m.group(2) # subgroup 2                           #匹配的子组 2
'b'
>>> m.groups() # all subgroups                               #所有匹配的子组的元组
('ab', 'b')
15.3.10 从字符串的开头或结尾匹配及在单词边界上的匹配
下面的例子强调了锚点性正则表达式操作符。这些锚点性正则表达式操作符主要被用于搜索而
不是匹配,因为 match()总是从字符串的开头进行匹配的。
>>> m = re.search('^The', 'The end.') # match                  #匹配
>>> if m is not None: m.group()
...
'The'
>>> m = re.search('^The', 'end. The') # not at beginning #不在开头
>>> if m is not None: m.group()
...
>>> m = re.search(r'\bthe', 'bite the dog') # at a boundary #在词边界
>>> if m is not None: m.group()
...
'the'
>>> m = re.search(r'\bthe', 'bitethe dog') # no boundary            #无边界


>>> if m is not None: m.group()
...
>>> m = re.search(r'\Bthe', 'bitethe dog') # no boundary            #无边界
>>> if m is not None: m.group()
...
'the'
你可能在这里注意到了原始字符串(raw strings) 的出现。在本章末尾的核心笔记中,有关于
它的说明。通常,在正则表达式中使用原始字符串是个好主意。
你还应该了解另外四个 re 模块函数和 regex 对象方法: findall(), sub(), subn() 和 split().
15.3.11 用 findall()找到每个出现的匹配部分
findall()自 Python1.5.2 版本被引入。它用于非重叠地查找某字符串中一个正则表达式模式出
现的情况。findall()和 search()相似之处在于二者都执行字符串搜索,但 findall()和 match()与
search()不同之处是,findall()总返回一个列表。如果 findall()没有找到匹配的部分,会返回空
列表;如果成功找到匹配部分,则返回所有匹配部分的列表(按从左到右出现的顺序排列)。
>>> re.findall('car', 'car')
['car']
>>> re.findall('car', 'scary')
['car']
>>> re.findall('car', 'carry the barcardi to the car')
['car', 'car', 'car']
包含子组的搜索会返回更复杂的一个列表,这样做是有意义的,因为子组是允许你从单个正则
表达式中抽取特定模式的一种机制,比如,匹配一个完整电话号码中的一部分(例如,区号),或完
整电子邮件地址的一部分(例如,登录名)。
正则表达式仅有一个子组时,findall()返回子组匹配的字符串组成的列表;如果表达式有多个
子组,返回的结果是一个元组的列表,元组中每个元素都是一个子组的匹配内容,像这样的元组(每
一个成功的匹配对应一个元组)构成了返回列表中的元素。这些内容初次听到可能令人费解,但如果
你看看各种例子,就会明白了。
15.3.12     用 sub()[和 subn()]进行搜索和替换
有两种函数/方法用于完成搜索和代替的功能: sub()和 subn(). 二者几乎是一样的,都是将某


字符串中所有匹配正则表达式模式的部分进行替换。用来替换的部分通常是一个字符串,但也可能
是一个函数,该函数返回一个用来替换的字符串。subn()和 sub()一样,但它还返回一个表示替换次
数的数字,替换后的字符串和表示替换次数的数字作为一个元组的元素返回。
>>> re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
'attn: Mr. Smith\012\012Dear Mr. Smith,\012'
>>>
>>> re.subn('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
('attn: Mr. Smith\012\012Dear Mr. Smith,\012', 2)
>>>
>>> print re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
attn: Mr. Smith
Dear Mr. Smith,
>>> re.sub('[ae]', 'X', 'abcdef')
'XbcdXf'
>>> re.subn('[ae]', 'X', 'abcdef')
('XbcdXf', 2)
15.3.13 用 split()分割(分隔模式)
re 模块和正则表达式对象的方法 split()与字符串的 split()方法相似,前者是根据正则表达式
模式分隔字符串,后者是根据固定的字符串分割,因此与后者相比,显著提升了字符分割的能力。如
果你不想在每个模式匹配的地方都分割字符串,你可以通过设定一个值参数(非零)来指定分割的最
大次数。
如 果 分 隔 符 没 有 使 用 由 特 殊 符 号 表 示 的 正 则 表 达 式 来 匹 配 多 个 模 式 , 那 re.split() 和
string.split()的执行过程是一样的,见以下的例子(在每一个冒号处分隔):
>>> re.split(':', 'str1:str2:str3')
['str1', 'str2', 'str3']
但运用正则表达式后,我们会发现 re.split()成了一个功能更强大的工具。比如,Unix 系统下
who 命令输出所有已登录系统的用户的信息:
% who
wesc console       Jun 20 20:33


wesc pts/9     Jun  22 01:38(192.168.0.6)
wesc  pts/1     Jun  20 20:33(:0.0)
wesc pts/2     Jun  20 20:33(:0.0)
wesc  pts/4     Jun  20 20:33(:0.0)
wesc  pts/3     Jun  20 20:33(:0.0)
wesc  pts/5     Jun  20 20:33(:0.0)
wesc  pts/6     Jun  20 20:33(:0.0)
wesc  pts/7     Jun  20 20:33(:0.0)
wesc  pts/8     Jun  20 20:33(:0.0)
假如我们想要保存用户的登录信息,比如说,登录名,用户登录时的电传,他们的登录的时间
以及登录地址。用上面的 string.split()很难有效果,因为分隔这些数据的空白符号是毫无规律且
不确定的。还有一个问题,就是在登录时间的数据中,月,日,时之间有一个空格。而我们一般想
把这些有关时间的数据排在一起。
你需要用某种方式来描述这样一种模式:“在两个或更多个空格符处进行分隔”。正则表达式很
容易做到这一点。我们能很快写出这个正则表达式模式:                            “\s\s+”,含义是至少 2 个空白字符。我们
来写一个名为 rewho.py 的程序,它读入 who 命令的输出 - 假设已保存到名为 whodata.txt 的文件
中。起初,我们写的 rewho.py 脚本看起来像这样:
import re
f = open('whodata.txt', 'r')
for eachLine in f.readlines():
print re.split('\s\s+', eachLine)
f.close()
我们现在执行 who 命令,将输出结果保存到文件 whodata.txt,然后调用 rewho.py 来看看结果:
% who > whodata.txt
% rewho.py
['wesc', 'console', 'Jun 20 20:33\012']
['wesc', 'pts/9', 'Jun 22 01:38\011(192.168.0.6)\012']
['wesc', 'pts/1', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/2', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/4', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/3', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/5', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/6', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/7', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/8', 'Jun 20 20:33\011(:0.0)\012']


这是不错的尝试,但还不完全正确。首先,我们原先没有预料到输出中会包含一个 TAB 符号(ASCII
\011) (它看上去像是至少两个空格,对不?)。而且, 我们可能对保存用来结束每行的换行符 NEWLINE
(ASCII \012) 也没什么兴趣。我们现在就做些改动来修正这些问题,同时提升程序的整体质量。
首先,我们改从脚本里执行 who 命令,而不是从外部调用它后将命令的输出结果保存到文件
whodata.txt - 这样重复的步骤很快会令人厌烦的。要从我们写的脚本里调用另一个程序,可以用
os.popen()命令,这个命令在 14.5.2 小节已介绍过。尽管 os.popen()只能在 Unix 系统中使用,但
本例子意在阐明 re.split()的用法,它可是跨系统平台的。
我们去掉每行行尾的换行符(NEWLINE),并添加检查单个 TAB 符号的模式,把 TAB 做为 re.split()
的可选分隔符。例 15.1,是脚本 rewho.py 的最终版本:
例 15.1 Unix 下 who 命令输出结果进行分隔 (rewho.py)
此脚本调用 who 命令,解析命令的输出结果,根据不同的空白符号分隔数据。
1 #!/usr/bin/env python
2
3 from os import popen
4 from re import split
5
6 f = popen('who', 'r')
7 for eachLine in f.readlines():
8 print split('\s\s+|\t', eachLine.strip())
9 f.close()
f.readlines() can be shortened to the file iterator f.
注:f.readlines()可以被简写成文件的迭代器 f.
运行脚本,我们得到如下(正确)结果:
% rewho.py
['wesc', 'console', 'Jun 20 20:33']
['wesc', 'pts/9', 'Jun 22 01:38', '(192.168.0.6)']
['wesc', 'pts/1', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/2', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/4', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/3', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/5', 'Jun 20 20:33', '(:0.0)']


['wesc', 'pts/6', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/7', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/8', 'Jun 20 20:33', '(:0.0)']
在 DOS/Windows 环境下,用 dir 命令代替 who 命令,也可完成此练习。
趁我们还熟悉 ASCII 字符,我们要提醒注意的是正则表达式的特殊字符和特殊 ASCII 字符是容
易混淆的。我们可能用\n 来表示一个 ASCII 换行字符,但也可以用\d 表示匹配一个数字的正则表达
式。如果同一个符号在 ASCII 和正则表达式中都可以用,就容易出问题了,所以在下页的核心笔记
中,我们推荐使用 Python 语言中的"原始字符串"来避免混淆。还要注意:                            “\w” and “\W”这两个
表示字母或数字的字符受 L 或 LOCALE 编译标志符的影响,在 Python 1.6 至 Python 2.0 以后的版
本中受(U 或 UNICODE 的)Unicode 标志符号影响。
核心笔记 : Python 原始字符串(raw strings)的用法
你可能已经看到前面关于原始字符串用法的一些例子了。原始字符串的产生正是由于有正则表
达式的存在。原因是 ASCII 字符和正则表达式特殊字符间所产生的冲突。比如,特殊符号“\b”在
ASCII 字符中代表退格键,但同时“\b”也是一个正则表达式的特殊符号,代表“匹配一个单词边界”                                。
为了让 RE 编译器把两个字符“\b”当成你想要表达的字符串,而不是一个退格键,你需要用另一个
反斜线对它进行转义,即可以这样写:“\\b”                     。
但这样做会把问题复杂化,特别是当你的正则表达式字符串里有很多特殊字符时,就更容
易令人困惑了。在第六章,我们曾介绍过原始字符串,它经常被用于简化正则表达式的复杂程度。
事实上,很多 Python 程序员在定义正则表达式时都只使用原始字符串。
下面的例子用来说明退格键“\b” 和正则表达式“\b”(包含或不包含原始字符串)之间的区别:
>>> m = re.match('\bblow', 'blow') # backspace, no match       #退格键,没有匹配
>>> if m is not None: m.group()
...
>>> m = re.match('\\bblow', 'blow') # escaped \, now it works #用\转义后,现在匹
配了
>>> if m is not None: m.group()
...
'blow'
>>> m = re.match(r'\bblow', 'blow') # use raw string instead        #改用原始字符串
>>> if m is not None: m.group()
...
'blow'
你可能注意到我们在正则表达式里使用“\d”                       ,没用原始字符串,也没出现什么问题。那是因为
ASCII 里没有对应的特殊字符,所以正则表达式编译器能够知道你指的是一个十进制数字。


15.4 正则表达式示例
现在我们来通读一个详细完整的例子,它展示了用正则表达式处理字符串的不同办法。第一步:
拿出一段代码用来生成随机数据,生成的数据用于以后操作。例 15.2 中,脚本 gendata.py 生成一个
数据集。虽然程序只是将生成的字符串显示到标准输出,但此输出结果也可以重定向到一个测试文
件中。
例 15.2 正则表达式练习的数据生成代码(gendata.py)
为练习使用正则表达式生成随机数据,并将产生的数据输出到屏幕.
1 #!/usr/bin/env python
2
3 from random import randint, choice
4 from string import lowercase
5 from sys import maxint
6 from time import ctime
7
8 doms = ( 'com', 'edu', 'net', 'org', 'gov' )
9
10 for i in range(randint(5, 10)):
11      randint(0, maxint-1) # pick date
12      ctime(dtint)   # date string
13
14 shorter = randint(4, 7) # login shorter
15 em = ''
16 for j in range(shorter): # generate login
17 em += choice(lowercase)
18
19 longer = randint(shorter, 12) # domain longer
20 dn = ''
21 for j in range(longer): # create domain
22 dn += choice(lowercase)
23
24 print '%s::%s@%s.%s::%d-%d-%d' % (dtstr, em,
25 dn, choice(doms), dtint, shorter, longer)
这个脚本生成 3 个字段,字段由一对冒号,或双冒号分隔。第一个字段是一个随机(32 位)整数,
被转换为一个日期(见旁边的核心笔记)。第二个字段是一个随机产生的电子邮件(e-mail)地址,最后


一个字段是由单个横线( - )分隔的一个整数集合。
执行这段代码,我们得到以下输出(你得到的输出肯定和本书中的不同),并把数据保存到本地
文件 redata.txt 中:
Thu Jul 22 19:21:19 2004::izsp@dicqdhytvhv.edu::1090549279-4-11
Sun Jul 13 22:42:11 2008::zqeu@dxaibjgkniy.com::1216014131-4-11
Sat May 5 16:36:23 1990::fclihw@alwdbzpsdg.edu::641950583-6-10
Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8
Thu Jun 26 19:08:59 2036::ugxfugt@jkhuqhs.net::2098145339-7-7
Tue Apr 10 01:04:45 2012::zkwaq@rpxwmtikse.com::1334045085-5-10
你或许能看出来,这个程序的输出数据适合用正则表达式来处理。在我们逐行解释后,会用几
个正则表达式对这些数据的进行操作,也为本章后面的练习做好准备。
逐行解释
第 1-6 行
在这个示例脚本里,我们要使用多个模块。但因为我们只需要用到这些模块中的一两个函数,
所以不必引入整个模块,只须引入模块中某些属性即可。我们用 from-import 而不是 import 正是
基于这个原因。代码第一行是 Unix 起始提示符,后面是 from-import 这几行。
第8行
domes 是一组简单的包含顶级域名的集合,我们将从中随机挑选一个来随机生成电子邮件地址。
第 10-12 行
每次 gendata.py 执行都会产生 5-10 行的输出。(这个脚本用函数 random.randint()生成我们需
要的所有随机整数。) 在每个输出行中,我们从整个可能的范围(0 到 2^31-1 即,[sys.maxint])
里,随机选一个整数,然后把这个整数用 time.ctime()转换成一个日期。大多数安装 Python 的基于
Unix 系统的计算机上,系统时间是根据 1970 年一月一日零点-纪元(“epoch”)至今的秒数来计算的。
如果我们选择 32 位整数,那系统日期就代表从纪元(epoch) 到纪元后 2^32 秒之间的某个时刻。
第 14-22 行
我们规定随机生成的邮箱地址中登录名的长度必须在 4 到 7 个字符之间。我们随机选择 4 到 7
个小写字母,依次将它们连结到一个字符串中。函数 random.choice()的用处就是根据指定序列,随
机返回该序列中的一个元素。在这里我们指定序列是 26 个小写字母,string.lowercase.我们规定
虚拟邮箱地址的域名长度在 4 到 12 个字符之间,但不能短于登录名的长度。最后,我们随机选择一
些小写字母,依次将它们连接起来组成域名。
第 24-25 行


这是本脚本的关键步骤:把随机数据组合到一起显示到输出行。以日期字符串开头,后面是分
隔符,然后是随机生成的电子邮件地址。这个任意的电子邮件地址是我们把登录名,“@”符号,域
名和一个随机选择的顶级域名连接到一起组成的。在最后一个双冒号后面,我们还加了一个随机整
数字符串,它的前部分是与所选随机日期对应是整数,后面的部分分别是登录名和域名的长度,这
几个整数之间由连字符分隔。
15.4.1     匹配一个字符串
在下面的练习里,写出你的正则表达式,包括宽松和限制性强的两个版本。我们建议你用前面
的例子 redata.txt(或你自己运行 gendata.py 生成的随机数据)来测试小程序里的这些正则表达式。
在做练习的时候,你还会再次用到这些数据。
在把正则表达式写入到我们的小程序之前,我们先要对它进行测试。我们先引入 re 模块,将
redata.txt 中的一行数据赋值到一个字符串变量中。下面的语句在以下的两个示例中都是这样,没
有变化。
>>> import re
>>> data = 'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'
在第一个例子中,我们将写一个正则表达式,用它从文件 redata.txt 的每一行中(仅)提取时
间戳中的有关星期的数据字段。我们将用到以下这个正则表达式:
“^Mon|^Tue|^Wed|^Thu|^Fri|^Sat|^Sun”
上例要求字符串是以所列出的七个字符串之一作为开头(“^”正则表达式操作符)。如果我们想
把上面的正则表达式“翻译”过来,它的意思大概是: ”字符串必须以“Mon,”“Tue,”. . . , “Sat,”
或 “Sun” 之一打头“。
或 者 , 我 们 可 以 只 用 一 个 "^" 符 号 , 将 日 期 字 符 串 归 为 一 组 :
“^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)”.
在这组字符串集合两边的圆括号表示是只有满足这些字符串之一匹配才能成功。这是比我们前
面看到的那个没有圆括号的正则表达式"更友好"。而且,使用这个修改后的正则表达式还有一个好
处,能使我们方便地访问被匹配字符串的那个子组:
>>> patt = '^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)'
>>> m = re.match(patt, data)
>>> m.group() # entire match
'Thu'
>>> m.group(1) # subgroup 1


'Thu'
>>> m.groups() # all subgroups
('Thu',)
我们在这个例子里所看到的功能似乎没有那么新鲜或与众不同,但它对于下面的例子或是通过
在正则表达式中添加额外数据来处理字符串匹配时就很有帮助了,即使这些字符并不是你感兴趣的
字符串中的某部分。上面的两个正则表达式都是限制性很强的,特别要求只含有某些字符串。但在
国际语言的系统环境中,使用各地区本地化时间和缩写的情况下,可能就行不通了。限制性更宽松
的正则表达式是:“^\w{3}”。
这个正则表达式只要求字符串以三个由字符或数字组成的字符作开头。要是把它翻译成白话,
就是,上箭头(^carat)表示以...开始,“\w”指任意一个由字符或数字组成的字符,“{3}”表示它
左边描述的正则表达式模式必须连续出现三次。注意,如果你要对这个正则表达式分组,请用圆括
号(),即,“^(\w{3})”:
>>> patt = '^(\w{3})'
>>> m = re.match(patt, data)
>>> if m is not None: m.group()
...
'Thu'
>>> m.group(1)
'Thu'
注意,要是把正则表达式写成“^(\w){3}”是不正确的。如果把“{3}”写在圆括号里((\w{3})),
表示匹配三个连续的由字符或数字组成的字符,再把这三个字符视为一个组。但如果把“{3}”挪到
圆括号的外边((\w){3}), 那现在它的含义就变成三个连续的单个由字符或数字组成的字符:
>>> patt = '^(\w){3}'
>>> m = re.match(patt, data)
>>> if m is not None: m.group()
...
'Thu'
>>> m.group(1)
'u'
访问子组 1 的数据时,只看到“u”是因为子组 1 中的数据被不断地替换成下一个字符。也就是
说,m.group(1)开始的结果是“T”,然后是“h”,最后又被替换成“u”。它们是三个独立(而且重复)
的组,每个组是由字符或数字所组成的字符,而不是由连续的三个字符或数字组成的字符所形成的
单个组。


在下一个(也是最后的)例子中,我们将写一个正则表达式来提取文件 redata.txt 中每行末尾的
数值字段。
15.4.2 搜索与匹配的比较,“贪婪”匹配
在我们写正则表达式前,先明确这些整数数据项是在字符串数据的末尾。这意味着我们有两种
选择:搜索(search)或匹配(match)。使用搜索更合适,因为我们确切地知道要查找的数据是什么(三
个整数的集合),它不在字符串的开头,也不是字符串的全部内容。如果我们用匹配(match)的方法,
就不得不写一个正则表达式来匹配整行内容,并用子组保存我们感兴趣的那部分数据。为说明它们
之间的区别,我们先用搜索查找,再尝试用匹配来做,向你证明搜索查找更适合。
因为我们要查找的是三个由连字符号(-)分隔的整数集,所以我们写出如下正则表达式:
“\d+-\d+-\d+”。这个正则表达式描述的是,              “任意数字(至少有一个),后面有连字符号(-),然后是
任意个数的数字(至少有一个),接着是另一个连字符号(-),最后还是任意数字(至少有一个)的集
合。”,我们用 search()来测试这个正则表达式:
>>> patt = '\d+-\d+-\d+'
>>> re.search(patt, data).group() # entire match        #全部匹配部分
'1171590364-6-8'
尝试用这个正则表达式来匹配数据会失败,这是为什么呢?因为匹配从字符串的起始位置开始
进行的,而我们要找的数值字符串在末尾。我们只能再写一个匹配全部字符串的正则表达式。还有
一个偷懒的办法,就是用“.+”来表示任意个字符集,后面再接上我们真正感兴趣的数据:
patt = '.+\d+-\d+-\d+'
>>> re.match(patt, data).group() # entire match       #全部匹配部分
'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'
这个方法不错,可是我们只想获得每行末尾数字的字段,而不是整个字符串,所以需要用圆括
号将我们感兴趣的那部分数据分成一组:
>>> patt = '.+(\d+-\d+-\d+)'
>>> re.match(patt, data).group(1)      # subgroup 1   #子组 1
'4-6-8'


图 15–2           为什么匹配错了:+ 是贪心的量词(操作符)
到底怎么回事呢? 我们本应该得到数据“1171590364-6-8”,而不应该是“4-6-8”啊。第一个
整数字段的前半部分到哪里去了呢? 原因是:正则表达式本身默认是贪心匹配的。也就是说,如果
正则表达式模式中使用到通配字,那它在按照从左到右的顺序求值时,会尽量“抓取”满足匹配的
最长字符串。在我们上面的例子里,               “.+”会从字符串的起始处抓取满足模式的最长字符,其中包括
我们想得到的第一个整数字段的中的大部分。“\d+”只需一位数字就可以匹配,所以它匹配了数字
“4”,而“.+” 则匹配了从字符串起始到这个第一位数字“4”之间的所有字符: “Thu Feb 15
17:46:04 2007::uzifzf@dpyivihw.gov::117159036”, 如下图 15–2.所示。
一个解决办法是用“非贪婪”操作符,                “?”. 这个操作符可以用在 “*”, “+”, 或 “?” 的
后面。它的作用是要求正则表达式引擎匹配的字符越少越好。因此,如果我们把“?”放在“.+”
的后面,我们就得到了想要的结果,见图 15–3.
>>> patt = '.+?(\d+-\d+-\d+)'
>>> re.match(patt, data).group(1)      # subgroup 1 # 子组 1
'1171590364-6-8'
图 15–3           解决“贪婪”匹配问题: ? 要求非“贪婪”匹配
另一种办法,更简单,注意运用 “::”做字段分隔符号。你可以用一般字符串的 strip('::') 方
法,得到全部字符,然后用 strip('-')得到你要找的三个整数字段。我们现在不采用这种方法,因
为我们的脚本 gendata.py 正是通过这种方法把字符组合到一起的。


最后一个例子:假设我们只想抽取三个整数字段里中间的那个整数部分。我们是这么做的(用搜
索,这样就不必匹配整个字符了):“-(\d+)-”。用这个模式“-(\d+)-”,我们得到:
>>> patt = '-(\d+)-'
>>> m = re.search(patt, data)
>>> m.group() # entire match          #整个匹配
'-6-'
>>> m.group(1) # subgroup 1           #子组 1
'6'
在本章中,有很多正则表达式的强大功能我们未能涉及,由于篇幅所限,我们无法详细介绍它
们。但我们希望所提供的信息和技巧对你的编程实践有所帮助。我们建议你参阅有关文档以获得更
多在 Python 语言中使用正则表达式的知识。要精通正则表达式,我们建议你阅读 Jeffrey E. F.
Friedl 所编写的 Mastering Regular Expressions 一书。
15.5 练习
正则表达式. 根据要求写出 练习 15–1 至 15–12 相应的正则表达式
15-1.   识别下列字符串:“bat,” “bit,” “but,” “hat,” “hit,” 或 “hut”
15–2.    匹配用一个空格分隔的任意一对单词,比如,名和姓。
15–3.    匹配用一个逗号和一个空格分开的一个单词和一个字母。例如,英文人名中的姓和名
的首字母。
15-4    匹配所有合法的 Python 标识符。
15–5.    请根据您(读者)本地关于地址的格式写法匹配一个街道地址(你写出的正则表达式要
尽可能通用以匹配任意数目的表示街道名字的单词,包括类型指示)。比如,美国的街道地址使用这
样的格式:1180 Bordeaux Drive. 使你写的正则表达式尽可能通用,要求能够匹配多个单词的街道
名字,如:3120 De la Cruz Boulevard.
15–6. 匹配简单的以“www.”开头,以“.com”作结尾的 Web 域名,例如:www.yahoo.com. 附
加题:使你写的正则表达式还支持其他顶级域名:.edu, .net 等,比如:www.ucsc.edu.
15-7. 匹配全体 Python 整数的字符串表示形式的集合。
15–8. 匹配全体 Python 长整数的字符串表示形式的集合。


15–9. 匹配全体 Python 浮点数的字符串表示形式的集合。
15–10. 匹配全体 Python 复数的字符串表示形式的集合。
15–11. 匹配所有合法的电子邮件地址(先写出一个限制比较宽松的正则表达式,然后尽可能加
强限制条件,但要保证功能的正确性)。
15–12.匹配所有合法的 Web 网站地址(URLs)(先写出一个限制比较宽松的正则表达式,然后尽
可能加强限制条件,但要保证功能的正确性)。
15–13.    type(). type()内建函数返回一个对象类型,此对象显示为 Python 的字符串形式,
如下所示:
>>> type(0)
<type 'int'>
>>> type(.34)
<type 'float'>
>>> type(dir)
<type 'builtin_function_or_method'>
请写一个正则表达式,能从这个字符串中提取出类型的名字。 你的函数能实现以下功能:如
果以字符串“<type 'int'>”做输入,会返回类型“int”.(返回其他类型也同理,如,返回类型‘float’,
‘builtin_function_or_method’等) 提示:正确的结果保存在类和某些内建类型的__name__属性
里。
15–14.正则表达式。在 15.2 小节里,我们给出一个匹配由一位或两位数字代表一月到九月的
字符串形式(“0?[1-9]”)。 请写出一个正则表达式表示标准日历上其它的三个月(十月、十一月、
十二月)。
15–15. 正则表达式。在 15.2 小节里,我们给出一个匹配信用卡卡号的模式:(“[0-9]{15,16}”).
但这个模式不允许用连字符号分割信用卡卡号中的数字。请写出一个允许使用连字符的正则表达式,
但要求连字符必须出现在正确的位置。例如,15 位的信用卡卡号的格式是 4-6-5,表示四个数字,一
个连字符,后面接六个数字、一个连字符,最后是五个数字。16 位的信用卡卡号的格式是 4-4-4-4,
数位不足时,添 0 补位。附加题:有一个用于确定某个信用卡卡号是否合法的算法。请写一段代码,
它不但能识别格式正确的信用卡卡号,还能验证它的有效性。
下面几个问题(练习 15–16 到 15–27)专门处理 gendata.py 生成的数据。在做练习 15–17 和
15–18 之前,请先把练习 15–16 和所有正则表达式做出来。


15–16. 修改脚本 gendata.py 的代码,使数据直接写入文件 redata.txt 中,而不是输出到屏
幕上。
15–17.   统计生成的 redata.txt 文件中,星期中的每一天出现的次数(或统计各月份出现的次
数)。
15–18.通过检查每个输出行中整数字段部分的第一个整数是否和该行开头的时间戳相匹配来
验证 redata.txt 中的数据是否完好。
根据各练习的要求写出相应的正则表达式:
15–19.    提取出每行中完整的时间戳字段。
15–20.    提取出每行中完整的电子邮件地址。
15–21.    只提取出时间戳字段中的月份。
15-22.   只提取出时间戳字段中的年份。
15–23.    只提取出时间戳字段中的值(格式:HH:MM:SS)。
15-24.   只从电子邮件地址中提取出登录名和域名(包括主域名和顶级域名,二者连在一起)。
15-25.   只从电子邮件地址中提取出登录名和域名(包括主域名和顶级域名,二者分别提取)。
15–26.    将每行中的电子邮件地址替换为你自己的电子邮件地址。
15–27.    提取出时间戳中的月、日、年,并按照格式“月 日,年”显示出来,且每行仅遍
历一次。
我们在小节 15.2 中使用的一个匹配电话号码的正则表达式,其中电话号码允许包含可选的区号
前缀 : \d{3}-\d{3}-\d{4}. 请在练习 15–28 和 15–29 中, 修改这个正则表达式,使它满足:
15–28.区号(第一组的三个数字和它后面的连字符)是可选的,即,你写的正则表达式对
800-555-1212 和 555-1212 都可以匹配。
15–29.区号中可以包含圆括号或是连字符,而且它们是可选的,就是说你写的正则表达式可以
匹配 800-555-1212, 或 555-1212, 或(800) 555-1212.


网络编程
本章主题
z 引言:客户/服务器架构
z 套接字:通信终点
z 面向连接与无连接套接字
z Python 中的网络编程
z Socket 模块
z 套接字对象方法
z TCP/IP 客户端和服务器
z UDP/IP 客户端和服务器
z SocketServer 模块
z Twisted 框架介绍
z 相关模块


在本节中,我们将简要的介绍如何使用套接字进行网络编程。首先,我们将给出一些网络编程
方面的背景资料和 Python 中使用套接字的方法,然后介绍如何使用 Python 的一些模块来创建网络
化的应用程序。
16.1 介绍
16.1.1 什么是客户/服务器架构?
什么是客户/服务器架构?不同的人有不同的答案。这要看你问的是什么人,以及指的是软件
系统还是硬件系统了。但是,有一点是共通的:服务器是一个软件或硬件,用于提供客户需要的“服
务”。服务器存在的唯一目的就是等待客户的请求,给这些客户服务,然后再等待其它的请求。
另一方面,客户连上一个(预先已知的)服务器,提出自己的请求,发送必要的数据,然后就
等待服务器的完成请求或说明失败原因的反馈。服务器不停地处理外来的请求,而客户一次只能提
出一个服务的请求,等待结果。然后结束这个事务。客户之后也可以再提出其它的请求,只是,这
个请求会被视为另一个不同的事务了。
图 16-1 Internet 上典型的客户/服务器概念。


图 16-1 展示了如今最常见的客户/服务器结构。一个用户或客户电脑通过 Internet 从服务器
上取数据。这的确是一个客户/服务器架构的系统,但还有更多类似的系统满足客户/服务器架构。
而且,客户/服务器架构也可以应用到电脑硬件上。
硬件的客户/服务器架构
打印(机)服务是一个硬件服务器的例子。它们处理打印任务,并把任务发给相连的打印机(或
其它打印设备)。这样的电脑一般是可以通过网络访问并且客户机器可以远程发送打印请求给它。
另一个硬件服务器的例子是文件服务器。它们一般拥有大量的存储空间,客户可以远程访问。
客户机器可以把服务器的磁盘映射到自己本地,就像本地磁盘一样使用它们。其中,
SunMicrosystems 公司的 Network File System(NFS)是使用最广泛的网络文件系统之一。如果你正
在访问网络磁盘,并且区分不出是本地的还是网络上的,那客户/服务器系统就很好的完成了它们
的工作。其目的就是要让用户使用起来感觉就像使用本地磁盘一样。                    “抽象”到一般的磁盘访问这一
层上后,所有的操作都是一样的,而让所有操作都一样的“实现”则要依靠各自的程序了。
软件客户/服务器架构
软件服务器也是运行在某个硬件上的。但不像硬件服务器那样,有专门的设备,如打印机,磁
盘等。软件服务器提供的服务主要是程序的运行,数据的发送与接收,合并,升级或其它的程序或
数据的操作。
如今,最常用的软件服务器是 Web 服务器。一台机器里放一些网页或 Web 应用程序,然后启动
服务。这样的服务器的任务就是接受客户的请求,把网页发给客户(如用户计算机上的浏览器),然
后等待下一个客户请求。这些服务启动后的目标就是“永远运行下去”                    。虽然它们不可能实现这样的
目标,但只要没有关机或硬件出错等外力干扰,它们就能运行非常长的一段时间。
数据库服务器是另一种软件服务器。它们接受客户的保存或读取请求,完成请求,然后再等待
其它的请求。它们也被设计为要能“永远”运行。
我们要讨论的最后一种软件服务器是窗口服务器。这些服务器几乎可以认为是硬件服务器。它
们运行于一个有显示器的机器上。窗口的客户是那些在运行时需要窗口环境的程序,它们一般会被
叫做图形界面(GUI)程序。在一个 DOS 窗口或 Unix 的 shell 中等没有窗口服务器的环境中,它们将
无法启动。一旦窗口服务器可以使用时,那一切就正常了。
当世界有了网络,那这样的环境就开始变得更有趣了。一般情况下,窗口客户的显示和窗口服
务器的提供都在同一台电脑上。但在 X Window 之类的网络化的窗口环境中,你可以选
择其它电脑的窗口服务器来做显示即你可以在一台电脑上运行 GUI 程序,而在另一台电脑上显
示它!


银行出纳是服务器?
理解客户/服务器架构的一个方法是,想像一个不吃不喝,不睡觉的银行出纳,他依次向排成
长龙的顾客们提供一个又一个的服务(图 16-2)       。有时,队伍可能很长,有时,也可能没人。但顾客
随时都可能出现。当然,在以前,是不可能有这样的出纳的。但现在的 ATM 机与这个模型很像。
当然,出纳就是一个运行在无限循环里的服务器。每一个顾客就是一个想要得到服务的客户。
顾客到了之后,就按先来先服务(FCFS)的原则得到服务。一个事务结束后,客户就离开了,而服
务器则要么马上为下一个顾客服务,要么坐着等待下一个顾客的到来。
为什么这些概念那么重要?因为,这些执行的方式就是客户/服务器架构的特点。现在你对此
已经有了大体的认识,我们就可以把客户/服务器架构模型应用到网络编程中。
图 16-2 在此图中的银行出纳“永远不停歇”地为客户提供服务。出纳运行在一个接收请求,处
理请求然后再处理其它请求或等待其它客户的无限循环中。客户有可能已经排起了长龙,也有可能
根本就没有客户。但是,无论如何,服务器都不会结束。
16.1.2 客户/服务器网络编程
在完成服务之前,服务器必需要先完成一些设置动作。先要创建一个通讯端点,让服务器能“监
听”请求。你可以把我们的服务器比做一个公司的接待员或回答公司总线电话的话务员,一旦电话
和设备安装完成,话务员也到了之后,服务就可以开始了。


在网络世界里,基本上也是这样——一旦通讯端点创建好之后,我们在“监听”的服务器就可
以进入它那等待和处理客户请求的无限循环中了。当然,我们也不能忘记在信纸上,杂志里,广告
中印上公司的电话号码。否则,就没有人会打电话进来了!
同样地,服务器在准备好之后,也要通知潜在的客户,让它们知道服务器已经准备好处理服务
了。否则,没有人会提请求的。比方说,你建立了一个全新的网站。这个网站非常的出色,非常的
吸引人,非常的有用,是所有网站中最酷的一个。但如果你不把网站的网址或者说统一资源定位符
(URL)广而告之的话,没有人会知道这个网站的存在的。这个网站也就永远不见天日了。对于公司
总部的新电话也是这样,你不把电话公之于众,那就没有人会打电话进来。
现在,你对服务器如何工作已经有了一个很好的认识。你已经完成了最难的那一部分。客户端
的编程相对服务器端来说就简单得多了。所有的客户只要创建一个通讯端点,建立到服务器的连接。
然后客户就可以提出请求,请求中,也可以包含必要的数据交互。一旦请求处理完成,客户收到了
结果,通讯就结束了。
16.2 套接字:通讯端点
16.2.1 什么是套接字?
套接字是一种具有之前所说的“通讯端点”概念的计算机网络数据结构。网络化的应用程序在
开始任何通讯之前都必需要创建套接字。就像电话的插口一样,没有它就完全没办法通讯。
套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,        即人们所说的 BSD Unix。
因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同
一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种,分别是基于文
件型的和基于网络型的。
Unix 套接字是我们要介绍的第一个套接字家族。其“家族名”为 AF_UNIX(在 POSIX1.g 标准中
也叫 AF_LOCAL),表示“地址家族:UNIX” 。包括 Python 在内的大多数流行平台上都使用术语“地址
家族”及其缩写“AF”。而老一点的系统中,地址家族被称为“域”或“协议家族”,并使用缩写“PF”
而不是“AF”。同样的,AF_LOCAL(在 2000-2001 年被列为标准)将会代替 AF_UNIX。不过,为了向后
兼容,很多系统上,两者是等价的。Python 自己则仍然使用 AF_UNIX。
由于两个进程都运行在同一台机器上,而且这些套接字是基于文件的。所以,它们的底层结构
是由文件系统来支持的。这样做相当有道理,因为,同一台电脑上,文件系统的确是不同的进程都
能访问的。
另一种套接字是基于网络的,它有自己的家族名字:AF_INET,或叫“地址家族:Internet”。
还有一种地址家族 AF_INET6 被用于网际协议第 6 版(IPv6)寻址上。还有一些其它的地址家族,不


过,它们要么是只用在某个平台上,要么就是已经被废弃,或是很少被使用,或是根本就还没有实
现。所有地址家族中,AF_INET 是使用最广泛的一个。Python 2.5 中加入了一种 Linux 套接字的支
持:AF_NETLINK(无连接[见下])套接字家族让用户代码与内核代码之间的 IPC 可以使用标准 BSD 套
接字接口。而且,相对之前那些往操作系统中加入新的系统调用,proc 文件系统支持或是“IOCTL”
等笨重的方案来说,这种方法显得更为优美,更为安全。
Python 只支持 AF_UNIX,AF_NETLINK,和 AF_INET 家族。由于我们只关心网络编程,所以在本
章的大部分时候,我们都只用 AF_INET。
16.2.2 套接字地址:主机与端口
如果把套接字比做电话的插口——即通讯的最底层结构,那主机与端口就像区号与电话号码的
一对组合。有了能打电话的硬件还不够,你还要知道你要打给谁,往哪打。一个 Internet 地址由网
络通讯所必需的主机与端口组成。而且不用说,另一端一定要有人在听才可以。否则,你就会听到
熟悉的声音“对不起,您拨的是空号,请查对后再播”。你在上网的时候,可能也见过类似的情况,
如“不能连接该服务器。服务器无响应或不可达”。
合法的端口号范围为 0 到 65535。其中,小于 1024 的端口号为系统保留端口。如果你所使用的
是 Unix 操作系统,保留的端口号(及其对应的服务/协议和套接字类型)可以通过/etc/services
文件获得。常用端口号列表可以从下面这个网站获得:
http://www.iana.org/assignments/port-numbers
16.2.3 面向连接与无连接
面向连接
无论你使用哪一种地址家族。套接字的类型只有两种。一种是面向连接的套接字,即在通讯之
前一定要建立一条连接,就像跟朋友打电话时那样。这种通讯方式也被称为“虚电路”或“流套接
字”。面向连接的通讯方式提供了顺序的,可靠的,不会重复的数据传输,而且也不会被加上数据边
界。这也意味着,每一个要发送的信息,可能会被拆分成多份,每一份都会不多不少地正确到达目
的地。然后被重新按顺序拼装起来,传给正在等待的应用程序。
实现这种连接的主要协议就是传输控制协议(即 TCP)。要创建 TCP 套接字就得在创建的时候,
指定套接字类型为 SOCK_STREAM。TCP 套接字采用 SOCK_STREAM 这个名字,表达了它做为流套接字的
特点。由于这些套接字使用 Internet 协议(IP)来查找网络中的主机,这样形成的整个系统,一般
会由这两个协议(TCP 和 IP)来提及,即 TCP/IP。


无连接
与虚电路完全相反的是数据报型的无连接套接字。这意味着,无需建立连接就可以进行通讯。
但这时,数据到达的顺序,可靠性及数据不重复性就无法保证了。数据报会保留数据边界,这就表
示,数据不会像面向连接的协议那样被拆分成小块。
使用数据报来传输数据就像邮政服务一样。邮件和包裹不一定会按它们发送的顺序到达。事实
上,它们还有可能根本到不了!而且,由于网络的复杂性,数据还可能被重复传送。
既然数据报有这么多缺点,为什么还要使用它呢?(一定有什么方面能胜过流套接字的!)由于
面向连接套接字要提供一些保证,以及要维持虚电路连接,这都是很重的额外负担。数据报没有这
些负担,所以它更“便宜”。通常能提供更好的性能,更适合某些应用场合。
实现这种连接的主要协议就是用户数据报协议(即 UDP)。要创建 UDP 套接字就得在创建的时候,
指定套接字类型为 SOCK_DGRAM。SOCK_DGRAM 这个名字,也许你已经猜到了,来自于单词“datagram”
(“数据报”)。由于这些套接字使用 Internet 协议来查找网络中的主机,这样形成的整个系统,一
般会由这两个协议(UDP 和 IP)来提及,即 UDP/IP。
16.3 Python 中的网络编程
现在,你已经有了足够的客户/服务器,套接字和网络方面的知识。我们现在就开始把这些概
念带到 Python 中来。本节中,我们将主要使用 socket 模块。模块中的 socket()函数被用来创建套
接字。套接字也有自己的一套函数来提供基于套接字的网络通讯。
16.3.1 socket()模块函数
要使用 socket.socket()函数来创建套接字。其语法如下:
socket(socket_family, socket_type, protocol=0)
socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。
这几个常量的意义可以参考之前的解释。protocol 一般不填,默认值为 0。
创建一个 TCP/IP 的套接字,你要这样调用 socket.socket():
tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


同样地,创建一个 UDP/IP 的套接字,你要这样:
udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
由于 socket 模块中有太多的属性。我们在这里破例使用了'from module import *'语句。使用
'from socket import *',我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能
大幅减短我们的代码。
tcpSock = socket(AF_INET, SOCK_STREAM)
当我们创建了套接字对象后,所有的交互都将通过对该套接字对象的方法调用进行。
16.3.2 套接字对象(内建)方法
表 16.1 中,我们列出了最常用的套接字对象的方法。在下一个小节中,我们将分别创建 TCP 和
UDP 的客户和服务器,它们都要用到这些方法。虽然我们只关心 Internet 套接字,但是这些方法在
Unix 套接字中的也有类似的意义。
表 16.1 套接字对象的常用函数
函数                       描述
服务器端套接字函数
s.bind()           绑定地址(主机,端口号对)到套接字
s.listen()         开始 TCP 监听
s.accept()         被动接受 TCP 客户的连接,(阻塞式)等待连接的到来
客户端套接字函数
s.connect()        主动初始化 TCP 服务器连接
s.connect_ex()     connect()函数的扩展版本,出错时返回出错码,而不是抛异常
公共用途的套接字函数
s.recv()          接收 TCP 数据
s.send()         发送 TCP 数据
s.sendall()      完整发送 TCP 数据
s.recvfrom()    接收 UDP 数据
s.sendto()       发送 UDP 数据
s.getpeername() 连接到当前套接字的远端的地址
s.getsockname() 当前套接字的地址
s.getsockopt() 返回指定套接字的参数
s.setsockopt() 设置指定套接字的参数
s.close()       关闭套接字


Blocking-Oriented Socket Methods
s.setblocking() 设置套接字的阻塞与非阻塞模式
s.settimeout()a 设置阻塞套接字操作的超时时间
s.gettimeout()a 得到阻塞套接字操作的超时时间
面向文件的套接字的函数
s.fileno()       套接字的文件描述符
s.makefile()     创建一个与该套接字关连的文件
a. Python 2.3 版本新加入的函数
核心提示:在运行网络应用程序时,最好在不同的电脑上执行服务器和客户端的程序。
在本章的例子中,你将大量看到代码和输出中提及“localhost”主机和 127.0.0.1 IP 地址。
我们的例子把客户与服务器运行在同一台电脑上,我们建议读者改掉主机名,并把代码放到不同的
电脑上运行。眼见着自己的代码在不同的电脑上进行通讯,这一时刻,你更能体会到开发的乐趣。
16.3.3 创建一个 TCP 服务器
我们首先将给出一个关于如何创建一个通用的 TCP 服务器的伪代码,然后解释我们都做了些
什么。要注意的是,这只是设计服务器的一种方法,当你对服务器的设计有了一定的了解之
后,你就能用你所希望的方式来修改这段伪代码:
ss = socket()         # 创建服务器套接字
ss.bind()              # 把地址绑定到套接字上
ss.listen()          # 监听连接
inf_loop:              # 服务器无限循环
cs = ss.accept()       # 接受客户的连接
comm_loop:           # 通讯循环
cs.recv()/cs.send() # 对话(接收与发送)
cs.close()           # 关闭客户套接字
ss.close()           # 关闭服务器套接字(可选)
所有的套接字都用 socket.socket()函数来创建。服务器需要“坐在某个端口上”等待请求。所
以它们必需要“绑定”到一个本地的地址上。由于 TCP 是一个面向连接的通讯系统,在 TCP 服务器
可以开始工作之前,要先完成一些设置。TCP 服务器必需要“监听”                   (进来的)连接,设置完成之后,
服务器就可以进入无限循环了。
一个简单的(单线程的)服务器会调用 accept()函数等待连接的到来。默认情况下,accept()
函数是阻塞式的,即程序在连接到来之前会处于挂起状态。套接字也支持非阻塞模式。请参阅相关
文档或操作系统手册以了解为何及如何使用非阻塞套接字。


一旦接收到一个连接,accept()函数就会返回一个单独的客户的套接字用于后续的通讯。使用
新的客户套接字就像把客户的电话转给一个客户服务人员。当一个客户打电话进来的时候,总机接
了电话,然后把电话转到合适的人那里来处理客户的需求。
这样就可以空出总机,也就是最初的那个服务器套接字,于是,话务员就可以等待下一个电话
(客户的请求),与此同时,前一个客户与对应的客户服务人员在另一条线路上进行着他们自己的对
话。同样的,当一个请求到来时,要创建一个新的端口,然后直接在那个端口上与客户对话,这样
就可以空出主端口来接受其它客户的连接。
核心提示:创建线程来处理客户的请求。
我们不打算在例子实现这样的功能。但是,创建一个新的线程或进程来完成与客户的通讯是一
种非常常用的手段。SocketServer 模块是一个基于 socket 模块的高级别的套接字通讯模块,它支持
在新的线程或进程中处理客户的请求。建议读者参阅相关文章及第 17 章多线程编程的习题,以了解
更多的信息。
在临时套接字创建好之后,通讯就可以开始了。客户与服务器都使用这个新创建的套接字进行
数据的发送与接收,直到通讯的某一方关闭了连接或发送了一个空字符串之后,通讯就结束了。
在代码中,当客户连接关闭后,服务器继续等待下一个客户的连接。代码的最后一行,会把服
务器的套接字关闭。由于服务器处在无限循环中,不可能会走到这一步,所以,这一步是可选的。
我们写这一句话的主要目的是要提醒读者,在设计一个更智能的退出方案的时候,比方说,服务器
被通知要关闭的时,要确保 close()函数会被调用。
在例 16.1 tsTserv.py 文件中,会创建一个 TCP 服务器程序,这个程序会把客户发送过来的字
符串加上一个时间戳(格式:'[时间]数据')返回给客户。
例 16.1 TCP 时间戳服务器 (tsTserv.py)
创建一个能接收客户的消息,在消息前加一个时间戳后返回的 TCP 服务器。
1  #!/usr/bin/env python
2
3  from socket import *
4  from time import ctime
5
6  HOST = ''
7  PORT = 21567
8  BUFSIZ = 1024
9  ADDR = (HOST, PORT)


10
11 tcpSerSock = socket(AF_INET, SOCK_STREAM)
12 tcpSerSock.bind(ADDR)
13 tcpSerSock.listen(5)
14
15 while True:
16 print 'waiting for connection...'
17 tcpCliSock, addr = tcpSerSock.accept()
18 print '...connected from:', addr
19
20 while True:
21 data = tcpCliSock.recv(BUFSIZ)
22 if not data:
23 break
24 tcpCliSock.send('[%s] %s' % (
25 ctime(), data))
26
27 tcpCliSock.close()
28 tcpSerSock.close()
逐行解释
1-4 行
第 1 行是 Unix 的启动信息行,随后我们导入了 time.ctime()函数和 socket 模块的所有属性。
6-13 行
HOST 变量为空,表示 bind()函数可以绑定在所有有效的地址上。我们还选用了一个随机生成的
未被占用的端口号。在程序中,我们把缓冲的大小设定为 1K。你可以根据你的网络情况和应用的需
要来修改这个大小。listen()函数的参数只是表示最多允许多少个连接同时连进来,后来的连接就
会被拒绝掉。
TCP 服务器的套接字(tcpSerSock)在第 11 行被生成。随后把套接字绑定到服务器的地址上,然
后开始 TCP 监听。
15-28 行
在进入到服务器的无限循环后,我们(被动地)等待连接的到来。当有连接时,我们进入对话循
环,等待客户发送数据。如果消息为空,表示客户已经退出,那就再去等待下一个客户的连接。得
到客户的消息后,我们在消息前加一个时间戳然后返回。最后一行不会被执行到,放在这里用于提
醒读者,在服务器要退出的时候,要记得调用 close()函数。


16.3.4 创建 TCP 客户端
创建 TCP 客户端相对服务器来说更为容易。与 TCP 服务器那段类似,我们也是先给出伪代码及
其解释,然后再给出真正的代码。
cs = socket()            # 创建客户套接字
cs.connect()             # 尝试连接服务器
comm_loop:              # 通讯循环
cs.send()/cs.recv()    # 对话(发送/接收)
cs.close()              # 关闭客户套接字
如之前所说,所有的套接字都由 socket.socket()函数创建。在客户有了套接字之后,马上就可
以调用 connect()函数去连接服务器。连接建立后,就可以与服务器开始对话了。在对话结束后,客
户就可以关闭套接字,结束连接。
在例 16.2 中,我们给出了 tcTlnt.py 的代码。程序连接到服务器,提示用户输入要传输的数据,
然后显示服务器返回的加了时间戳的结果。
逐行解释
1-3 行
第 1 行是 Unix 的启动信息行,随后我们导入了 socket 模块的所有属性。
例 16.2 TCP 时间戳客户端(tsTclnt.py)
创建一个 TCP 客户端,程序会提示用户输入要传给服务器的信息,显示服务器返回的加了
时间戳的结果。
1 #!/usr/bin/env python
2
3 from socket import *
4
5 HOST = 'localhost'
6 PORT = 21567
7 BUFSIZ = 1024
8 ADDR = (HOST, PORT)
9
10 tcpCliSock = socket(AF_INET, SOCK_STREAM)
11 tcpCliSock.connect(ADDR)
12


13 while True:
14  data = raw_input('> ')
15 if not data:
16  break
17  tcpCliSock.send(data)
18  data = tcpCliSock.recv(BUFSIZ)
19  if not data:
20  break
21  print data
22
23  tcpCliSock.close()
5-11 行
HOST 和 PORT 变量表示服务器的主机名与端口号。由于我们在同一台电脑上进行测试,所以 HOST
里放的是本机的主机名(如果你的服务器运行在其它电脑上,要做相应的修改)。端口号要与服务器
上的设置完全相同(不然就没办法通讯了)。缓冲区的大小还是设为 1K。
TCP 客户套接字(tcpCliSock)在第 10 行创建。然后就去连接服务器。
13-23 行
客户端也有一个无限循环,但这跟服务器的那个不期望退出的无限循环不一样。客户端的循环
在以下两个条件的任意一个发生后就退出:用户没有输入任何内容(14-16 行),或服务器由于某种
原因退出,导致 recv()函数失败(18-20 行)             。否则,在一般情况下,客户端会把用户输入的字符串
发给服务器进行处理,然后接收并显示服务器传回来的,加了时间戳的字符串。
16.3.5 运行我们的客户端与服务器程序
现在,我们来运行服务器和客户程序,看看它们的运行情况如何。我们应该先运行服务器还是
客户呢?很显然,如果我们先运行客户,由于没有服务器在等待请求,客户没办法做连接。服务器
是一个被动端,它先创建自己然后被动地等待连接。而客户则是主动端,由它主动地建立一个连接。
所以:要先开服务器,后开客户。
我们在运行客户和服务器的例子中,使用了同一台电脑。其实也可以把服务器放在其它的电脑
上,这时,只要改改主机名就好了。              (看到自己写的第一个网络程序运行在不同的电脑上,那是多么
激动人心的事啊)。
下面就是客户端的输入与输出,不输入数据,直接按回车键就可以退出程序:
$ tsTclnt.py


> hi
[Sat Jun 17 17:27:21 2006] hi
> spanish inquisition
[Sat Jun 17 17:27:37 2006] spanish inquisition
>
$
服务器的输出主要用于调试目的:
$ tsTserv.py
waiting for connection...
...connected from: ('127.0.0.1', 1040)
waiting for connection...
当有客户连接上来的时候,会显示一个“... connected from ...”信息。在客户接受服务的
时候,服务器又回去等待其它客户的连接。在从服务器退出的时候,我们要跳出那个无限循环,这
时会触发一个异常。避免这种错误的方法是采用一种更优美的退出方式。
核心提示:优美的退出和调用服务器的 close()函数
“友好地”退出的一个方法就是把服务器的无限循环放在一个 try-except 语句的 try 子句当
中,并捕获 EOFError 和 KeyboardInterrupt 异常。在异常处理子句中,调用 close()函数关闭服务
器的套接字。
这个简单的网络应用程序的有趣之处并不仅仅在于我们演示了数据怎样从客户传到服务器,然
后又传回给客户,而且我们还把这个服务器当成了“时间服务器”                       ,因为,字符串中的时间戳完全是
来自于服务器的。
16.3.6 创建一个 UDP 服务器
由于 UDP 服务器不是面向连接的,所以不用像 TCP 服务器那样做那么多设置工作。事实上,并
不用设置什么东西,直接等待进来的连接就好了。
ss = socket()                    # 创建一个服务器套接字
ss.bind()                         # 绑定服务器套接字
inf_loop:                       # 服务器无限循环
cs = ss.recvfrom()/ss.sendto() # 对话(接收与发送)
ss.close()                        # 关闭服务器套接字
从伪代码中可以看出,使用的还是那套先创建套接字然后绑定到本地地址(主机/端口对)的


方法。无限循环中包含了从客户那接收消息,返回加了时间戳的结果和回去等下一个消息这三步。
同样的,由于代码不会跳出无限循环,所以,close()函数调用是可选的。我们写这一句话的原因是
要提醒读者,在设计一个更智能的退出方案的时候,要确保 close()函数会被调用。
例 16.3 UDP 时间戳服务器 (tsUserv.py)
创建一个能接收客户的消息,在消息前加一个时间戳后返回的 UDP 服务器。
1 #!/usr/bin/env python
2
3 from socket import *
4 from time import ctime
5
6 HOST = ''
7 PORT = 21567
8 BUFSIZ = 1024
9 ADDR = (HOST, PORT)
10
11 udpSerSock = socket(AF_INET, SOCK_DGRAM)
12 udpSerSock.bind(ADDR)
13
14 while True:
15 print 'waiting for message...'
16 data, addr = udpSerSock.recvfrom(BUFSIZ)
17 udpSerSock.sendto('[%s] %s' % (
18 ctime(), data), addr)
19 print '...received from and returned to:', addr
20
21 udpSerSock.close()
UDP 和 TCP 服务器的另一个重要的区别是,由于数据报套接字是无连接的,所以无法把客户的连
接交给另外的套接字进行后续的通讯。这些服务器只是接受消息,需要的话,给客户返回一个结果
就可以了。
例 16.3 的 tsUserv.py 是之前那个 TCP 服务器的 UDP 版本,它接收客户的消息,加时间戳后返
回给客户。
逐行解释
1-4 行
就像 TCP 服务器的设置那样,在 Unix 的启动信息行后,我们导入了 time.ctime()函数和 socket


模块的所有属性。
6-12 行
HOST 和 PORT 变量与之前完全一样。socket()函数的调用有一些不同,我们现在要的是一个数据
报/UDP 的套接字类型。不过 bind()函数还是跟 TCP 版本的一样。同样地,由于 UDP 是无连接的,就
不用调用 listen()函数来监听进来的连接了。
14-21 行
在进入到服务器的无限循环后,我们(被动地)等待(数据报)消息的到来。当有消息进来时,就
处理它(在前面加时间戳),把结果返回回去,然后再去等等下一个消息。就像之前一样,那个 close()
函数只是一个演示而已。
16.3.7 创建一个 UDP 客户端
这一节中介绍的 4 段程序中,下面的这段 UDP 客户的代码是最短的。伪代码如下:
cs = socket()              # 创建客户套接字
comm_loop:                # 通讯循环
cs.sendto()/cs.recvfrom() # 对话(发送/接收)
cs.close()                # 关闭客户套接字
在套接字对象创建好之后,我们就进入一个与服务器的对话循环。在通讯结束后,套接字就被
关闭了。tsUclnt.py 真实的代码在例 16.4 中给出。
逐行解释
1-3 行
还是跟 TCP 版本的客户一样,在 Unix 的启动信息行后,我们导入了 socket 模块的所有属性。
5-10 行
因为我们的服务器也是运行在本机,我们的客户还是使用本机和相同的端口号。自然地,缓冲
的大小也还是 1K。创建套接字的方法跟 UDP 服务器中的一样。
12-22 行
UDP 客户的循环基本上与 TCP 客户的完全一样。唯一的区别就是,我们不用先去跟 UDP 服务器建
立连接,而是直接把消息发送出去,然后等待服务器的回复。得到加了时间戳的字符串后,把它显
示到屏幕上,然后再继续其它的消息。在输入结束后,退出循环,关闭套接字。
例 16.4 UDP 时间戳客户 (tsUclnt.py)


创建一个 UDP 客户端,程序会提示用户输入要传给服务器的信息,显示服务器返回的加了时间
戳的结果。
1 #!/usr/bin/env python
2
3 from socket import *
4
5 HOST = 'localhost'
6 PORT = 21567
7 BUFSIZ = 1024
8 ADDR = (HOST, PORT)
9
10 udpCliSock = socket(AF_INET, SOCK_DGRAM)
11
12 while True:
13 data = raw_input('> ')
14 if not data:
15 break
16 udpCliSock.sendto(data, ADDR)
17 data, ADDR = udpCliSock.recvfrom(BUFSIZ)
18 if not data:
19 break
20 print dataudpCliSock.close()
21
22 udpCliSock.close()
16.3.8 执行 UDP 服务器和客户端
UDP 客户与 TCP 客户的表现类似:
$ tsUclnt.py
> hi
[Sat Jun 17 19:55:36 2006] hi
> spam! spam! spam!
[Sat Jun 17 19:55:40 2006] spam! spam! spam!
>
$
服务器也差不多:


$ tsUserv.py
waiting for message...
...received from and returned to: ('127.0.0.1', 1025)
waiting for message...
我们输出客户信息的原因是,服务器可能会得到并回复多个客户的消息,这时,输出就可以让
我们了解消息来自哪里。对于 TCP 服务器来说,由于客户会创建一个连接,我们自然就能知道消息
来自哪里。注意,我们的提示信息写的是“waiting for message”(“等待消息”)而不是“waiting
for connection”(“等待连接”)。
16.3.9 套接字模块属性
除了我们已经很熟悉的 socket.socket()函数之外,socket 模块还有很多属性可供网络应用程
序使用。表 16.2 中列出了最常用的几个。
请参考 Python 手册中 socket 模块的文档以了解更多的信息。
表 16.2 socket 模块属性
属性名字                               描述
数据属性
AF_UNIX, AF_INET, AF_INET6a    Python 支持的套接字家族
SO_STREAM, SO_DGRAM            套接字类型 (TCP = 流, UDP = 数据报)
b
has_ipv6                       表示是否支持 IPv6 的标志变量
异常
error                         套接字相关错误
a
herror                         主机和地址相关的错误
a
gaierror                       地址相关的错误
b
timeout                          超时
函数
socket()           用指定的地址家族,套接字类型和协议类型(可选)创建一个套接字对象
c
socketpair()       用指定的地址家族,套接字类型和协议类型(可选)创建一对套接字对象
fromfd()            用一个已经打开的文件描述符创建一个套接字对象
数据属性
ssl()d                       在套接字初始化一个安全套接字层(SSL)。不做证书验证。
a
getaddrinfo()                得到地址信息
e
getfqdn()                    返回完整的域的名字
gethostname()                得到当前主机名


gethostbyname()           由主机名得到对应的 ip 地址
gethostbyname_ex()       gethostbyname()的扩展版本,返回主机名,主机所有的别名和
IP 地址列表。
gethostbyaddr()           由 IP 地址得到 DNS 信息,返回一个类似 gethostbyname_ex()
的 3 元组。
getprotobyname()         由协议名(如'tcp')得到对应的号码。
getservbyname()/         由服务名得到对应的端口号或相反
getservbyport()         两个函数中,协议名都是可选的。
ntohl()/ntohs()          把一个整数由网络字节序转为主机字节序
htonl()/htons()          把一个整数由主机字节序转为网络字节序
inet_aton()/           把 IP 地址转为 32 位整型,以及反向函数。(仅对 IPv4 地址有效)
inet_ntoa()
inet_pton()/           把 IP 地址转为二进制格式以及反向函数。(仅对 IPv4 地址有效)
inet_ntop()b
getdefaulttimeout()/   得到/设置默认的套接字超时时间,单位秒(浮点数)
setdefaulttimeout()b
a.   Python 2.2 新增.
b. Python 2.3 新增.
c. Python 2.4 新增.
d. Python 1.6 新增.
e. Python 2.0 新增.
16.4 *SocketServer 模块
SocketServer 是标准库中一个高级别的模块。用于简化网络客户与服务器的实现。模块中,
已经实现了一些可供使用的类。
表 16.3 SocketServer 模块的类
类                           描述
BaseServer            包含服务器的核心功能与混合(mix-in)类的钩子功能。这个类用于
派生,不要直接生成
这个类的类对象,可以考虑使用 TCPServer 和 UDPServer。
TCPServer/            基本的网络同步 TCP/UDP 服务器
UDPServer
UnixStreamServer/     基本的基于文件同步 TCP/UDP 服务器
UnixDatagramServer


ForkingMixIn/            实现了核心的进程化或线程化的功能,用于与服务器类进行混合
(mix-in),以提供一些异步特性。
ThreadingMixIn         不要直接生成这个类的对象
ForkingTCPServer/      ForkingMixIn 和 TCPServer/UDPServer 的组合
ForkingUDPServer
ThreadingTCPServer/    ThreadingMixIn 和 TCPServer/UDPServer 的组合
ThreadingUDPServer
BaseRequestHandler      包含处理服务请求的核心功能。只用于派生新的类,不要直接生成
这个类的对象,
可以考虑使用 StreamRequestHandler 或 DatagramRequestHandler
StreamRequestHandler/  TCP/UDP 服务器的请求处理类的一个实现
DatagramRequestHandler
我们将再次实现之前的那个基本 TCP 的例子。你会注意到新实现与之前有很多相似之处,但你
也要注意到,现在很多繁杂的事情已经被封装好了,你不用再去关心那个样板代码了。例子给出的
是一个最简单的同步服务器。记得要看看本章最后的把服务器改成异步的练习题。
为了要隐藏实现的细节。我们现在写程序时会使用类,这是与之前代码的另一个不同。用面向
对象的方法可以帮助我们更好的组织数据与逻辑功能。你也会注意到,我们的程序现在是“事件驱
动”了。这就意味着,只有在事件出现的时候,程序才有“反应”。
事件包含发送与接收数据两种。事实上,你会看到,我们的类定义中只包含了接收客户消息的
事件处理器。其它的功能从我们所使用的 SocketServer 继承而来。界面编程(第 18 章)也是事件
驱动的。你会注意到有一个相似之处,即在代码的最后一行都有一个服务器的无限循环,等待并处
理客户的服务请求。本章之前创建的基本 TCP 服务器也有一个类似的无限 while 循环。
在之前的服务循环中,我们阻塞等待请求,有请求来的时候就处理请求,然后再回去继续等待。
现在的服务循环中,就不用在服务器里写代码了,改成定义一个处理器,服务器在收到进来的请求
的时候,可以调用你的处理函数。
16.4.1 创建一个 SocketServerTCP 服务器
在代码中,先导入我们的服务器类,然后像之前一样定义主机常量。主机常量后就是我们的请
求处理器类,然后是启动代码。在下面的代码片断中可以看到更多细节。
逐行解释
1-9 行
最开始的部分是从 SocketServer 导入需要的类。注意,我们在使用 Python2.4 的多行导入的方
式。如果你使用老版本的 Python,那么你要使用模块的形如 module.attribute 的名字。或者在导入


的时候,把代码写在同一行里:
from SocketServer import TCPServer as TCP, StreamRequestHandler as SRH
例 16.5 SocketServer 时间戳服务器(tsTservSS.py)
使用 SocketServer 里的 TCPServer 和 StreamRequestHandler 类创建一个时间戳 TCP 服务器。
1 #!/usr/bin/env python
2
3 from SocketServer import (TCPServer as TCP,
4 StreamRequestHandler as SRH)
5 from time import ctime
6
7 HOST = ''
8 PORT = 21567
9 ADDR = (HOST, PORT)
10
11 class MyRequestHandler(SRH):
12 def handle(self):
13 print '...connected from:', self.client_address
14 self.wfile.write('[%s] %s' % (ctime(),
15 self.rfile.readline()))
16
17 tcpServ = TCP(ADDR, MyRequestHandler)
18 print 'waiting for connection...'
19 tcpServ.serve_forever()
11-15 行
主要的工作在这里。我们从 SocketServer 的 StreamRequestHandler 类中派生出一个子类,并
重写 handle()函数。在 BaseRequest 类中,这个函数什么也不做:
def handle(self):
pass
在有客户消息进来的时候,handle()函数就会被调用。StreamRequestHandler 类支持像操作文
件对象那样操作输入输出套接字。我们可以用 readline()函数得到客户消息,用 write()函数把字
符串发给客户。
为了保持一致性,我们要在客户与服务器两端的代码里都加上回车与换行。实际上,你在代码
中看不到这个,因为,我们重用了客户传过来的回车与换行。除了这些我们刚刚说到的不同之处外,


代码看上去与之前的那个服务器是一样的。
17-19 行
代码的最后部分用给定的主机信息和请求处理类创建 TCP 服务器。然后进入等待客户请求与处
理客户请求的无限循环中。
16.4.2 创建 SocketServerTCP 客户端
很自然地,我们的客户端与之前的客户端的代码很相似,比服务器相似得多。但客户端要做一
些相应地调整以适应新的服务器。
逐行解释
1-8 行
没什么特别的,与原来的客户端完全相同。
例 16.6 SocketServer 时间戳 TCP 客户端(tsTclntSS.py)
这是一个时间戳 TCP 客户端,它知道如何与 SocketServer 里 StreamRequestHandler 对象进行
通讯。
1 #!/usr/bin/env python
2
3 from socket import *
4
5 HOST = 'localhost'
6 PORT = 21567
7 BUFSIZ = 1024
8 ADDR = (HOST, PORT)
9
10 while True:
11 tcpCliSock = socket(AF_INET, SOCK_STREAM)
12 tcpCliSock.connect(ADDR)
13 data = raw_input('> ')
14 if not data:
15 break
16 tcpCliSock.send('%s\r\n' % data)
17 data = tcpCliSock.recv(BUFSIZ)
18 if not data:
19 break


20 print data.strip()
21 tcpCliSock.close()
10-21 行
SocketServer 的请求处理器的默认行为是接受连接,得到请求,然后就关闭连接。这使得我们
不能在程序的运行时,一直保持连接状态,要每次发送数据到服务器的时候都要创建一个新的套接
字。
这种行为使得 TCP 服务器的行为有些像 UDP 服务器。不过,这种行为也可以通过重写请求处理
器中相应的函数来改变。我们把这个留在本章最后的练习中。
现在,我们的客户端有点完全不一样了(我们得每次都创建一个连接)                        。其它的小区别在服务器
代码的逐行解释中已经看到了:我们使用的处理器类像文件一样操作套接字,所以我们每次都要发
送行结束字符(回车与换行)           。服务器只是保留并重用我们发送的行结束字符。当我们从服务器得到
数据的时候,我们使用 strip()函数去掉它们,然后使用 print 语句提供的回车。
16.4.2 执行 TCP 服务器和客户端
下面是我们 SocketServer TCP 客户端的输出:
$ tsTclntSS.py
> 'Tis but a scratch.
[Tue Apr 18 20:55:49 2006] 'Tis but a scratch.
> Just a flesh wound.
[Tue Apr 18 20:55:56 2006] Just a flesh wound.
>
$
下面是服务器的输出:
$ tsTservSS.py
waiting for connection...
...connected from: ('127.0.0.1', 53476)
...connected from: ('127.0.0.1', 53477)
输出与我们之前的 TCP 客户与服务器相似。不过,你能看到,我们连了服务器两次。
16.5 Twisted 框架介绍


Twisted 是一个完全事件驱动的网络框架。它允许你使用和开发完全异步的网络应用程序和协议。
在写本书的时候,它还不是 Python 标准库的一部分,要使用它,你必需另外下载并安装它(在本章
最后能找到链接)。它为你创建一个完整系统提供了很大的帮助。系统中可以有:网络协议,线程,
安全和认证,聊天/即时通讯,数据库管理,关系数据库集成,网页/互联网,电子邮件,命令行参
数,图形界面集成等。
使用 Twisted 来实现我们这个简单的例子有牛刀宰鸡的感觉。不过,学东西总要有切入点吧,
我们先实现一个“Hello World”的网络应用程序。
像 SocketServer 一样,Twisted 的大部分功能都在它的类里面。在我们的例子中,我们将使用
Twisted 的 Internet 组件中 reactor 和 protocol 包的类。
16.5.1 创建一个 Twisted Reactor TCP 服务器
你会发现我们的代码与 SocketServer 例子有些相似。我们创建一个协议类,并像安装回调函数
那样重写几个函数,而不是写一个处理器类。同样的,我们的例子是异步的。先来看服务器:
逐行解释
1-6 行
一开始的代码照常是模块导入部分。要注意 twisted.internet 中 protocol 和 reactor 包和端
口号常量。
8-14 行
我们从 Protocol 类中派生出 TSServProtocol 类做为时间戳服务器。然后重写 connectionMade()
函数,这个函数在有客户连接的时候被调用,以及 dataReceived()函数,这个函数在客户通过网络
发送数据过来时被调用。reactor 把数据当成参数传到这个函数中,这样我们就不用自己去解析数据
了。
例 16.7 Twisted Reactor 时间戳 TCP 服务器(tsTservTW.py)
这是一个使用 Twisted Internet 类的时间戳 TCP 服务器
1 #!/usr/bin/env python
2
3 from twisted.internet import protocol, reactor
4 from time import ctime
5
6 PORT = 21567


7
8 class TSServProtocol(protocol.Protocol):
9 def connectionMade(self):
10 clnt = self.clnt = self.transport.getPeer().host
11 print '...connected from:', clnt
12 def dataReceived(self, data):
13 self.transport.write('[%s] %s' % (
14 ctime(), data))
15
16 factory = protocol.Factory()
17 factory.protocol = TSServProtocol
18 print 'waiting for connection...'
19 reactor.listenTCP(PORT, factory)
20 reactor.run()
我们通过 transport 对象与客户进行通讯。你可以看到在 connectionMade()函数中,我们如何
得到主机的信息,以及在 dataReceived()函数中,我们如何把数据传回客户端的。
16-20 行
在服务器的最后一部分,我们创建一个 protocol 工厂。它被称为“工厂”是因为,每次我们
有连接进来的时候,它都会“生产”一个我们的 protocol 对象。然后在 reactor 中安装一个 TCP
监听器以等待服务请求。当有请求进来时,创建一个 TSServProtocol 实例来服务那个客户。
16.5.2 创建一个 Twisted Reactor TCP 客户端
与 SocketServer TCP 客户不一样的是,这个例子与之前的客户端看上去不大一样。它是完全
Twisted 的。
例 16.8 Twisted Reactor Timestamp TCP 客户端(tsTclntTW.py)
用 Twisted 重写我们已经熟悉的时间戳 TCP 客户端。
1  #!/usr/bin/env python
2
3  from twisted.internet import protocol, reactor
4
5  HOST = 'localhost'
6  PORT = 21567
7


8 class TSClntProtocol(protocol.Protocol):
9 def sendData(self):
10 data = raw_input('> ')
11 if data:
12 print '...sending %s...' % data
13 self.transport.write(data)
14 else:
15 self.transport.loseConnection()
16
17 def connectionMade(self):
18 self.sendData()
19
20 def dataReceived(self, data):
21 print data
22 self.sendData()
23
24 class TSClntFactory(protocol.ClientFactory):
25 protocol = TSClntProtocol
26 clientConnectionLost = clientConnectionFailed = \
27 lambda self, connector, reason: reactor.stop()
28
29 reactor.connectTCP(HOST, PORT, TSClntFactory())
30 reactor.run()
逐行解释
1-6 行
跟之前所有的客户端程序类似,这里还是导入 Twisted 的组件。
8-22 行
与服务器一样,我们扩展 Protocol,重写同样的函数 connectionMade()和 dataReceived()。这
两个函数的用途也跟服务器一样。我们新加一个自己的函数 sendData(),用于在需要发送数据时调
用。
由于我们现在是客户,所以我们要主动初始化跟服务器的对话。一旦连接建立好之后,我们先
发送一个消息,服务器回复这个消息,我们把收到的回复显示在屏幕上,然后再发送其它消息给服
务器。
这个过程会一直循环,直到用户没有给任何输入时,连接结束。结束时,就不是调用 transport
对象的 write()函数传数据给服务器了,而是调用 loseConnection()函数来关闭套接字。这时,工


厂的 clientConnectionLost()函数会被调用,同时,reactor 就被关闭,脚本的执行就结束了。由
于某些原因,clientConnectionFailed()被调用时,reactor 也会被关闭。
脚本的最后一部分是创建一个客户工厂,连接到服务器,然后运行 reactor。注意,我们在这里
实例化了客户端工厂,而不是像在服务器里那样把它传到 reactor 中。这是因为,我们不是等待客
户连接的服务器,服务器在有连接时要为每个连接创建一个新的 protocol 对象。我们只是一个客户,
所以我们只要创建一个 protocol 对象,连接到服务器,服务器的工厂会创建一个 protocol 对象来
与我们对话。
16.5.3 执行 TCP 服务器和客户端
Twisted 客户显示的内容与我们之前的客户类似:
$ tsTclntTW.py
> Where is hope
...sending Where is hope...
[Tue Apr 18 23:53:09 2006] Where is hope
> When words fail
...sending When words fail...
[Tue Apr 18 23:53:14 2006] When words fail
>
$
服务器又回到了只有一个连接的情况。Twisted 维护连接,不会在每个消息后都关闭
$ tsTservTW.py
waiting for connection...
...connected from: 127.0.0.1
“connection from”输出没有其它的信息,因为我们只问服务器的 transport 对象的 getPeer()
函数要了主机地址的信息。
16.6 相关模块
表 16.4 列出了其它与网络和套接字相关的 Python 模块。select 模块通常在底层套接字程序中
与 socket 模块联合使用。它提供的 select()函数可以同时管理多个套接字对象。
它最有用的功能就是同时监听多个套接字的连接。select()函数会阻塞,直到有至少一个套接


字准备好要进行通讯的时候才退出。
它提供了哪些套接字已经准备好可以开始读取的集合。                      (它也提供了哪些套接字已经准备好可以
开始写的集合,不过这个功能相对来说不大常用)
async*和 SocketServer 模块在创建服务器方面都提供了高层次的功能。由于是基于 socket 和
(或)select 模块,封装了所有的底层的代码,它们使得你可以快速开发客户/服务器的系统。你所
需要做的只是从适当的基类中派生出一个新的类。所有的东西就已经就绪了。就像之前所说的,
SocketServer 甚至提供了把线程或进程集成到服务器中的功能,以实现更好的对客户请求的并行处
理的能力。
虽然 async*是标准库提供的唯一的异步开发支持库。我们也可选择如 Twisted 这样的,相对标
准库更现代,更强大的第三方库。虽然这里看到的例子代码比之前的什么都自己处理的代码稍微长
那么一点,Twisted 提供了更为强大,更具弹性的框架。它已经实现了很多协议。你可以在下面的网
站找到更多有关 Twisted 的信息:
http://twistedmatrix.com
表 16.4 网络/套接字编程相关模块
模块             描述
socket        底层网络接口。本章讨论过。
asyncore/     为能异步处理客户请求的网络应用程序提供底层功能。
asynchat
select         在单线程网络服务器程序中,管理多个套接字连接。
SocketServer   包含了写网络应用程序服务器所需要的高级别模块。提供了完整的进程和线程
的版本。
我们本章所讨论的主题涵盖了在 Python 中用 socket 网络编程和如何用低级别的协议如 TCP/IP
和 UDP/IP 来创建应用程序。如果你想要开发高层次的网页和 Internet 应用程序,我们强烈建议你
阅读第 17 章和第 20 章。
16.7 练习
16-1     套接字。面向连接和无连接有什么区别?
16-2.    客户/服务器架构。用你自己的语言描述这个架构,并给出几个例子。
16-3.    套接字。TCP 和 UDP 中,哪一种服务器在接受连接后,把连接交给不同的套接字处理
与客户的通讯。
16-4.    客户。修改 TCP(tsTclnt.py)和 UDP(tsUclnt.py)客户端,让服务器的名字不要在代码


里写死,要允许用户指定一个主机名和端口,只有在两个值都没有输入的时候,才使用默认值。
16–5. Intenet 网络和套接字。找到 Python Library Reference 中 7.2.2 节贵铎 范 罗萨姆
的示例
TCP 客户/服务器程序,实现它并让它运行起来。先运行服务器,然后是客户端。源代码的
一个在线版本可以在这里找到:
http://www.python.org/doc/current/lib/ Socket_Example.html
你认为这个服务器太无聊了,决定要修改服务器,让它能识别以下命令:
date    服务器将返回它的当前时间 i.e., time.ctime(time.time())os 得到操作系统的信息
(os.name)
ls 得到当前目录的文件列表 (提示: os.listdir()可以得到目录列表,os.curdir 能得到当
前目录) 附加题: 要能接受“ls dir”指令,并返回 dir 目录的文件列表。
做这个作业的时候,你不一定要有网络——你的机器可以跟自己通讯。注:在服务器退出后,
要清除绑定后才能再次运行。否则,有可能得碰到“端口已经被使用”(“port already bound”                              )的
错误信息。操作系统一般会在 5 分钟内清除绑定。所以,请耐心等待。
16-6.   日期时间服务。使用 socket.getservbyname()函数得到 UDP 协议中,“daytime”服务
所 对 应 的 端 口 。 请 参 考 getservbyname() 函 数 的 文 档 , 查 阅 详 细 的 语 法 。( 即 :
socket.getservbyname.__doc__)。现在,写一个程序发送一个随便什么数据过去,等待回答。一
旦你收到了服务器的信息,显示到屏幕上。
16-7.   半双工聊天。创建一个简单的,半双工的聊天程序。“半双工”的意思是当创建一个
连接,服务启动的时候,只有一个人可以打字,另一个人只有在等到有消息通知他输入消息时,才
能说话。一旦消息发送出去后,要等到有回复了才能发送下一条消息。一个人是服务端,另一个人
是客户端。
16-8. 全双工聊天。修改你刚才的程序,改成全双工,即两个人可以独立地发送和接收消息。
16-9.   多用户全双工聊天。再次修改你的程序,把聊天服务改成支持多用户版本。
16-10. 多用户,多房间全双工聊天。现在把聊天服务改成支持多个用户,多个房间。
16-11. 网页客户。写一个 TCP 客户,连到你最喜欢的网站的 80 端口(去掉“http://”和其
它的后缀信息,只用主机名)。一旦创建了一个连接,发送 HTTP 命令字符串“GET /\n”,把服务
器返回的所有数据写到一个文件中。               (GET 命令用于得到网页,        “/”表示要得到的文件,          “\n”把
命令发送到服务器)。检查得到的文件的内容,它是什么?怎么检查你得到的数据是否正确?(注:
你可能要在命令后加一个或是两个回车,一般来说,一个就可以了。)
16-12. 休眠服务器。创建一个“休眠”服务器,客户可以要求要“休眠”几秒钟。服务器就
去做休眠的操作。休眠结束后,返回一个消息给客户,表示结束。客户在收到消息的时候,应该刚
好等待了指定的时间。这就是一个简单的“远程过程调用”(“remote procedure call”),即客户发
送一个指令,网络另一边的远程的机器执行这个命令。


16-13. 名字服务器。设计并实现一个名字服务器。这个服务器负责维护一个主机名-端口对的
数据库,以及一个描述这个服务器提供的服务的字符串。选择一个或几个服务器到你的名字服务器
上进程“注册”      。(注意,这时,这些服务器是名字服务器的客户)                。每一个客户在启动的时候,都不
知道它们想要找的服务器的信息。名字服务器的客户也是这样。这些客户应该发送一个请求到名字
服务器,说明它们想要得到什么服务。名字服务器返回一个主机名-端口对给客户,客户这时就可
以连到合适的服务器来处理它的请求。
附加题:
(1) 在名字服务器中,加入对常用请求的缓冲。
(2) 在名字服务器中,加入日志功能,记录下哪个服务器注册了,客户在请求哪一个服务。
(3) 名字服务器应该周期性地“ping”这些注册了的服务器的对应端口,以确定这些服务器
还在运行中。在连续数次 ping 失败后,就把这个服务器从列表中删除。
你可以实现一些真实的服务,来注册到你的名字服务器上,或者也可以使用一些哑服务(它们
根本不对请求做应答)。
16-14. 错误检查和优美的退出。本章中,我们所有客户和服务器的例子代码都没有做错误检查。
我们没有检查用户是否按下了^C 来退出服务,或^D 来结束客户输入,也没有检查 raw_input()函数
得到的输入的合法性,也没有检查网络错误。由于这些弱点,我们很可能会在退出程序的时候,没
有关闭套接字,也有可能会丢失数据。选择一对客户/服务器例子,加入足够的错误检查,让程序
能正常的退出。比方说会关闭网络连接。
16-15. 异步和 SocketServer。选取 TCP 服务器例子,使用某一个混合类(mix-in),让你的程序
成为一个异步服务器。测试你的服务器,创建并同时运行多个客户,在服务器的输出里查看你的服
务器是否在同时响应多个请求。
16-16. *扩展 SocketServer 类。在 SocketServer TCP 服务器代码中,我们不能使用原来的 TCP
客户,要做修改。这是因为 SocketServer 类在多个请求之间不保持连接。(a) 从 TCPServer 和
StreamRequestHandler 中派生出新的类,重新设计服务器的架构,让服务器能为每个客户只使用一
个连接。(而不是每个请求一个连接)
(b) 把你之前的问题的解决方案应用到(a)部分,让多个客户的请求可以被并行地处理。


网络客户端编程
本章主题
z 引言
z 文件传输
z 文件传输协议(FTP)
z 网络新闻、Usenet, 和新闻组
z 网络新闻传输协议(NNTP)
z 电子邮件
z 简单邮件传输协议(SMTP)
z 邮局协议 3(POP3)
z 相关模块


在之前的章节中,我们已经大致了解了那些使用套接字的低级别的网络通讯协议。这种网络互
连是当今互联网中大部分客户端/服务器协议的核心。这些网络协议包括文件传输(FTP, SCP 等),
阅读 Usenet 新闻组(NNTP),e-mail 发送(SMTP),从服务器上下载 e-mail(POP3, IMAP)等等。这些
协议的工作方式与之前在套接字编程中介绍的客户端/服务器的例子很像。唯一的不同在于,我们
已经使用过 TCP/IP 等低级别的协议,并基于此创建了新的,更具体的协议来实现我们刚刚描述的
服务。
17.1 什么是因特网客户端?
在着手研究这些协议之前,我们要先问一个问题:                      “因特网客户端到底是什么”?要回答这个问
题,我们把因特网简化成一个数据交换中心,数据交换的参与者是一个服务提供者和一个服务的使
用者。有的人把它称为“生产者-消费者”(虽然这个词一般只用在讲解操作系统相关信息时)。服
务器就是生产者,它提供服务,一般只有一个服务器(进程或主机等)                       ,和多个消费者,就像我们之
前看的客户端/服务器模型那样。虽然现在我们不再使用底级别的套接字来创建因特网客户端,但
模型是完全相同的。
这里,我们将详细了解三个因特网协议——FTP, NNTP 和 POP3,并写出它们的客户端程序。通
过这些程序,你将会发现这些协议的 API 是多么的相似——由于保持接口的一致性有很大的好处,
所以,这些相似性在设计之初就考虑到了——更重要的是,你还能学会如何写出这些协议与其它协
议实用的客户端程序来。虽然我们只着重说了这三个协议。在看完这些协议后,你就能有足够的信
心和能力写出任何因特网协议的客户端程序了。


17.2 文件传输
17.2.1 文件传输因特网协议
因特网中最流行的事情就是文件的交换。文件交换无处不在。有很多协议可以供因特网上传输
文件使用。最流行的有文件传输协议(FTP),Unix-to-Unix 复制协议(UUCP),以及网页的超文本传输
协议(HTTP)。另外,还有(Unix 下的)远程文件复制指令 rcp(以及更安全,更灵活的 scp 和 rsync)。
迄今为止,HTTP,FTP 和 scp/rsync 还是非常流行的。HTTP 主要用于网页文件的下载和访问 Web
服务上。它一般不要求用户输入登录的用户名密码就可以访问服务器上的文件和服务。HTTP 文件传
输请求主要是用于获取网页(文件下载)。
相对的,scp 和 rsync 要求用户登录到服务器,否则不能上传或下载文件。至于 FTP,跟 scp/rsync
一样,可以上传或下载文件,还采用了 Unix 的多用户的概念,用户一定要输入有效的用户名和密码
才能使用。不过,FTP 也允许匿名登录。接下来,我们先仔细看看 FTP。
17.2.2 文件传输协议(FTP)
文件传输协议由已故的 Jon Postel 和 Joyce Reynolds 开发,记录在 RFC(Request for
Comment)959 号文档中,于 1985 年 10 月发布。它主要用于匿名下载公共文件。也可以用于在两台
电脑之间传输文件,尤其是在使用 Unix 系统做为文件存储系统,使用其它机器来工作的情况。早
在网络流行之前,FTP 就是在因特网上文件传输,软件和源代码下载的主要手段之一。
FTP 要求输入用户名和密码才能访问远程的 FTP 服务器,但它也允许没有帐号的用户以匿名用户
登录。不过,管理员要先设置 FTP 服务器允许匿名用户登录。这时,匿名用户的用户名是“anonymous”,
密码一般是用户的 e-mail 地址。与特定的用户拥有特定的帐户不同,这有点像是把 FTP 公开出来让
大家访问。匿名用户通过 FTP 协议可以使用的命令与一般的用户相比来说,限制更多。
图 17-1 展示了这个协议,其工作流程如下:
1.  客户端连接远程的 FTP 服务器
2.  客户端输入用户名和密码(或“anonymous”和 e-mail 地址)
3.  客户端做各种文件传输和信息查询操作
4.  客户端登出远程 FTP 服务器,结束通讯
当然,这只是很泛的一个流程。有时,由于网络两边电脑的崩溃或是网络的问题,会导致整个
事务在完成之前被中断。一般,在客户端超过 15 分钟(900 秒)不活动之后,连接就会被关闭。


在底层上,FTP 只使用 TCP(见前面网络编程相关章节)——它不使用 UDP。而且,FTP 是客户
端/服务器编程中很“与众不同”的例子。客户端和服务器都使用两个套接字来通讯:一个是控制
和命令端口(21 号端口),另一个是数据端口(有时是 20 号端口)。
图 17-1 因特网上的 FTP 客户端和服务器。客户端和服务器使用指令和控制端口发送 FTP 协议,
而数据通过数据端口传输。
我们说“有时”是因为 FTP 有两种模式:主动和被动。只有在主动模式服务器才使用数据端口。
在服务器把 20 号端口设置为数据端口后,它“主动”连接客户端的数据端口。而被动模式中,服务
器只是告诉客户端它的随机端口的号码,客户端必须主动建立数据连接。在这种模式下,你会看到,
FTP 服务器在建立数据连接时是“被动”的。最后,现在已经有了一种扩展被动模式来支持第 6 版本
的因特网协议(IPv6)地址——见 RFC 2428。
Python 已经支持了包括 FTP 在内的大多数据因特网协议。支持各个协议的客户端模块可以在
http://docs.python.org/lib/internet.html 找到。现在看看用 Python 创建一个因特网客户端程
序有多简单。
17.2.3 Python 和 FTP
那么,我们怎么用 Python 写 FTP 客户端程序呢?其实,我们之前已经提到过一些了。现在还要
再加上相应的 Python 模块导入和调用的操作。现在再来回顾一下流程:
1.   连接到服务器
2.   登录
3.   发出服务请求 (有可能有返回信息)
4.   退出
在使用 Python 的 FTP 支持时,你所需要做的就是导入 ftplib 模块,并实例化一个 ftplib.FTP
类对象。所有的 FTP 操作(如登录,传输文件和登出等)都要使用这个对象来完成。下面是一段 Python
的伪代码:
from ftplib import FTP


f = FTP('ftp.python.org')
f.login('anonymous', 'guess@who.org')
:
f.quit()
在看真实的例子之前,我们要先熟悉一下 ftplib.FTP 类的方法,这些方法将在代码中用到。
17.2.4 ftplib.FTP 类方法
在表 17.1 中列出了最常用的方法,这个表并不全面——想查看所有的方法,请参阅模块源代码
——但这里列出的方法组成了我们在 Python 中 FTP 客户端编程的“API”。
也就是说,你不一定要使用其它的方法,因为它们或者是辅助函数,或者是管理函数,或者是
被 API 调用的。
表 17.1 FTP 对象的方法
方法                                       描述
login(user='anonymous',
passwd='', acct='')        登录到 FTP 服务器,所有的参数都是可选的
pwd()                      得到当前工作目录
cwd(path)                   把当前工作目录设置为 path
dir([path[,...[,cb]])        显示 path 目录里的内容,可选的参数 cb 是一个回调函数,它
会被传给 retrlines()方法
nlst([path[,...])            与 dir()类似,但返回一个文件名的列表,而不是显示这些文
件名
retrlines(cmd [, cb])         给定 FTP 命令(如“RETR filename”),用于下载文本文件。
可选的回调函数 cb 用于处理文件的每一行
retrbinary(cmd, cb[,
bs=8192[, ra]])              与 retrlines()类似,只是这个指令处理二进制文件。回调函
数 cb 用于处理每一块(块大小默认为 8K)下载的数据。
storlines(cmd, f)            给定 FTP 命令(如“STOR filename”),以上传文本文件。要
给定一个文件对象 f
storbinary(cmd, f[,
bs=8192])                    与 storlines()类似,只是这个指令处理二进制文件。要给定
一个文件对象 f,上传块大小 bs 默认为 8Kbs=8192])
rename(old, new)             把远程文件 old 改名为 new
delete(path)                 删除位于 path 的远程文件
mkd(directory)               创建远程目录


rmd(directory)              删除远程目录
quit()                      关闭连接并退出
在一般的 FTP 通讯中,要使用到的指令有 login(), cwd(), dir(), pwd(), stor*(), retr*()
和 quit()。有一些没有列出的 FTP 对象方法也是很有用的。请参阅 Python 的文档以得到更多关于
FTP 对象的信息:
http://python.org/docs/current/lib/ftp-objects.html
17.2.5 交互式 FTP 示例
在 Python 中使用 FTP 非常的简单,你甚至可以不用写脚本,直接在交互式解释器中实时地看到
交互与输出。下面这个例子是在几年前,python.org 还支持 ftp 服务的时候做的:
17.2.6 客户端 FTP 程序举例
之前我们说过,你可以不写脚本,在交互环境中使用 FTP。不过,下面我们还是要写一段脚本,
假设你要从 Mozilla 的网站下载最新的 Bugzilla 的代码。例 17.1 就是用来完成这个工作的。我们
在试着写一个应用程序,不过,你也可以交互式地运行这段代码。我们的程序使用 FTP 库来下载文
件,也做了一些错误检测。
不过,程序并不完全自动。你要自己决定什么时候要去下载。如果你在使用类 Unix 系统,你可
以设定一个“cron”任务来自动下载。另一个问题是,如果文件的文件名或目录名改了的话,程序
就不能正常工作了。


例 17.1 FTP 下载示例 (getLatestFTP.py)
这个程序用于下载网站中最新版本的文件。你可以修改这个程序让它下载你喜欢的程序。
1 #!/usr/bin/env python
2
3 import ftplib
4 import os
5 import socket
6
7 HOST = 'ftp.mozilla.org'
8 DIRN = 'pub/mozilla.org/webtools'
9 FILE = 'bugzilla-LATEST.tar.gz'
10
11 def main():
12 try:
13 f = ftplib.FTP(HOST)
14 except (socket.error, socket.gaierror), e:
15 print 'ERROR: cannot reach "%s"' % HOST
16 return
17 print '*** Connected to host "%s"' % HOST
18
19 try:
20 f.login()
21 except ftplib.error_perm:
22 print 'ERROR: cannot login anonymously’
23 f.quit()
24 return
25 print '*** Logged in as "anonymous"'
26
27 try:
28 f.cwd(DIRN)
29 except ftplib.error_perm:
30 print 'ERROR: cannot CD to "%s"' % DIRN
31 f.quit()
32 return
33 print '*** Changed to "%s" folder' % DIRN
34
35 try:


36 f.retrbinary('RETR %s' % FILE,
37 open(FILE, 'wb').write)
38 except ftplib.error_perm:
39 print 'ERROR: cannot read file "%s"' % FILE
40 os.unlink(FILE)
41 else:
42 print '*** Downloaded "%s" to CWD' % FILE
43 f.quit()
44 return
45
46 if __name__ == '__main__':
47 main()
如果运行脚本时没有出错,则会得到如下输出:
$ getLatestFTP.py
*** Connected to host "ftp.mozilla.org"
*** Logged in as "anonymous"
*** Changed to "pub/mozilla.org/webtools" folder
*** Downloaded "bugzilla-LATEST.tar.gz" to CWD
$
逐行解释
1-9 行
代码前几行导入要用的模块和设置一些常量
11-44 行
main()函数分为以下几步:创建一个 FTP 对象,尝试连接到 FTP 服务器(12-17 行)然后返回。
在有任何错误发生的时候退出。我们尝试用“anonymous”登录,如果不行就结束(19-25 行)。下一
步就是转到发布目录(27-33 行),最后,下载文件(35-44 行)。
在 35-36 行,我们传了一个回调函数给 retrbinary(),它在每接收到一块二进制数据的时候都
会被调用。这个函数就是我们创建的本地文件对应文件对象的 write 方法。                      在传输结束的时候,Python
解释器会自动关闭这个文件对象,而不会丢失数据。虽然这样方便,但最好还是不要这样做,做为
一个程序员,要尽量做到在资源不再被使用的时候就直接释放,而不是依赖其它代码来做释放操作。
在 这 里 , 我 们 应 该 把 文 件 对 象 保 存 到 一 个 变 量 中 , 如 变 量 loc , 然 后 把 loc.write 传 给
ftp.retrbinary()方法。
在代码中,如果由于某些原因我们无法保存这个文件,那要把存在的空文件给删掉,以防搞乱


文件系统(40 行)      。最后,我们使用了 try-except-else 子句(35-42 行)           ,而不是写两遍关闭 FTP
连接然后返回的代码。
46-47 行
这是运行独立脚本的惯用方法。
17.2.7 FTP 的其它方面
Python 同时支持主动和被动模式。注意,在 Python2.0 及以前版本中,被动模式支持默认是关
闭的,在 Python2.1 及以后版本中,默认是打开的。
以下是一些典型的 FTP 客户端类型:
z 命令行客户端程序:你可以使用一些 FTP 文件传输工具如/bin/ftp 或 NcFTP,它们允许用户
在命令行交互式的参与到 FTP 通讯中来。
z GUI 客户端程序:与命令行客户端程序相似,只是它是一个 GUI 程序。如 WsFTP 和 Fetch 等。
z 网页浏览器:在使用 HTTP 之外,大多数网页浏览器(也是一个客户端)可以进行 FTP 通讯。
URL/URI 的第一部分就用来表示所使用的协议,如“http://blahblah.”这就告诉浏览器要
使用 HTTP 做为与给定网站进行通讯的协议。修改协议部分,就可以发使用 FTP 的请求,如
“ftp://blahblah.”,这跟使用 HTTP 的网页的 URL 很像。      (当然,
“ftp://”      后面的“blahblah”
可以展开为“host/path?attributes”)。如果要登录,用户可以把登录信息(以明文方式)
放在 URL 里,如:“ftp://user:passwd@host/path?attr1=val1&attr2=val2. . .”.
z 定制程序:你自己写的用于 FTP 文件传输的程序。由于程序用于特殊目的,一般这种程序都
不允许用户与服务器接触。
这四种客户端类型都可以用 Python 来写。上面,我们用 ftplib 来创建了一个自己的定制程序,
你也可以自己做一个命令行的应用程序。在命令行的基础上,你可以使用一些界面工具包,如 Tk,
wxWidgets,GTK+,Qt,MFC,甚至 Swing(要导入相应的 Python[或 Jython]的接口模块)来创建一
个完整的 GUI 程序。最后,你可以使用 Python 的 urllib 模块来解析 FTP 的 URL 并进行 FTP 传输。
在 urllib 的内部也导入并使用了 ftplib,urllib 也是 ftplib 的客户端。
FTP 不仅可以用在下载应用程序上,还可以用在系统之间文件的转移上。比如,如果你是一个工
程师或是系统管理员,你需要传输文件。在跨网络的时候,很明显可以使用 scp 或 rsync 命令,或
者把文件放到一个外部能访问的服务器上。不过,在一个安全网络的内部机器之间移动大量的日志
或数据库文件,这种方法的开销就太大了,要注意安全性,加密,压缩,解压缩等。如果你想要做
的只是写一个 FTP 程序来帮助你在下班后自动移动文件,那用 Python 是一个非常好的主意。
从 FTP 协议定义/规范(RFC 959)中,你可以得到更多关于 FTP 的信息:
ftp://ftp.isi.edu/in-notes/rfc959.txt 以及网页
http://www.networksorcery.com/enp/protocol/ftp.htm。其它相关的 RFC 有 2228,2389,


2428,2577,2640 和 4217。想了解更多 Python 对 FTP 的支持,可以从这里开始:
http://python.org/docs/current/lib/module-ftplib.html.
17.3 网络新闻
17.3.1 Usenet 与新闻组
Usenet 新闻系统是一个全球存档的“电子公告板”                       。各种主题的新闻组一应俱全,从诗歌到政治,
从自然语言学到计算机语言,软件到硬件,种植到烹饪,招工,应聘,音乐,魔术,分手,求爱等。
新闻组可以是面向全球泛泛而谈,也可以是只面向某个地理区域。
整个系统是一个由大量计算机组成的一个庞大的全球网络,计算机之间共享 Usenet 上的帖子.如
果某一个用户发了一个帖子到本地的 Usenet 计算机上,这个帖子会被传播到其它相连的计算机上,
并再由这些计算机传到与它们相连的计算机上,直到这个帖子传播到了全世界,每个人都收到这个帖
子为止.
每个系统都有一个它已经“订阅”的新闻组的列表,它只接收它感兴趣的新闻组里的帖子——
而不是服务器上所有新闻组的帖子。Usenet 新闻组服务内容取决于服务提供者,很多都是可供公众
访问的,也有一些只允许特定的用户使用,例如付费用户,特定大学的学生等。如果 Usenet 系统
管理员设置了的话,有可能会要求输入用户名和密码。管理员也可以设置是否只允许上传或只允许
下载。
17.3.2 网络新闻传输协议(NNTP)
供用户在新闻组中下载或发表帖子的方法叫网络新闻传输协议(NNTP)。它由 Brain Kantor(加
利福尼亚大学圣地亚哥分校)和 Phil Lapsley(加利福尼亚大学伯克利分校)创建并记录在 RFC 977
中,于 1986 年 2 月公布。其后的更新记录在 RFC 2980,于 2000 年 10 月公布。
作为客户端/服务器架构的另一个例子,NNTP 与 FTP 的操作方式很像,而且简单得多。FTP 需
要不同的端口来做登录,数据传输和控制,而 NNTP 只使用一个标准端口 119 来做通讯。你给服务器
一个请求,它做相应的反馈,见图 17-2。


图 17-2 因特网上的 NNTP 客户端和服务器。客户端主要阅读新闻,有时也发帖子。文章会在服
务器之间做同步。
17.3.3 Python 和 NNTP
由于之前已经有了 Python 和 FTP 的经验,你也许可以猜到,一定有一个库 nntplib 和一个类
nntplib.NNTP,你要实例化这个类。你猜对了。用 FTP 一样,我们所要做的就是导入那个 Python
模块,然后调用相应的方法。我们先大致看一下这个协议:
1.  连接到服务器
2.  登录(如果需要的话)
3.  发送请求
4.  退出
是不是有点熟悉?是的,这几乎就是完全复制了 FTP 协议。唯一的不同就是根据 NNTP 服务器的
配置不一样,登录这一步是可选的。
下面是一段 Python 的伪代码:
from nntplib import NNTP
n = NNTP('your.nntp.server')
r,c,f,l,g = n.group('comp.lang.python')
...
n.quit()


一般来说,在你登录完成后,你要调用 group()方法来选择一个感兴趣的新闻组。方法返回服务
器的返回信息,文章的数量,第一个和最后一个文章的 ID,以及组的名字。在有了这些信息后,你
会做一些其它的操作,如从头到尾看文章,下载整个帖子(文章的标题和内容)                      ,或者发表一篇文章
等。
在看真实的例子之前,我们要先介绍一下 nntplib.NNTP 类的一些常用的方法。
17.3.4 nntplib.NNTP 类方法
跟前一节列出 ftplib.FTP 类的方法时一样,我们不会列出 nntplib.NNTP 的所有方法,只列出
你创建 NNTP 客户端程序时可能用得着的方法。
表 17.2 NNTP 对象的方法
方法                    描述
group(name)            选择一个组的名字,返回一个元组(rsp,ct,fst,lst,group):
服务器的返回信息,文章的数量,第一个和最后一个文章的号
码以及组名,所有数据都是字符串。(返回的 group 与我们传
进去的 name 应该是相同的)
xhdr(hdr, artrg,
[ofile])        返回文章范围 artrg('头-尾'的格式)内文章 hdr 头的列表,或
输出到文件 ofile 中
body(id[,
ofile])                 给定文章的 id,id 可以是消息的 ID(放在尖括号里),或一
个文章号(是一个字符串),返回一个元组(rsp, anum, mid,
data): 服务器的返回信息,文章号(是一个字符串),消息
的 ID(放在尖括号里),和文章所有行的列表或把数据输出到
文件 ofile 中。
head(id)                与 body()相似,只是返回的元组中那个行的列表中只包含了
文章的标题。
article(id)             也跟 body()一样,只是返回的元组中那个行的列表中包含了
文章的标题和内容。
stat(id)                让文章的“指针”指向 id(同上,是一个消息的 ID 或是文章
的号码)。返回一个跟 body 一样的元组(rsp, anum, mid),
但不包含文章的数据。
next()                  用法和 stat()类似,把文章指针移到下一篇文章,返回与
stat()相似的元组
last()                  用法和 stat()类似,把文章指针移到最后一篇文章,返回与
stat()相似的元组


post(ufile)                   上传 ufile 文件对象里的内容(使用 ufile.readline()),并
在当前新闻组发表。
quit()                        关闭连接,然后退出
跟上一节的 FTP 对象表一样,还有一些 NNTP 对象的方法没有提及。为了避免混乱,我们只列出
了你可能用得到的。其余的,我们再次建议你参考 Python 手册。
17.3.5 交互式 NNTP 举例
接下来,是一个如何使用 Python 中 NNTP 库的交互式的例子。它看上去跟交互式的 FTP 的例子
差不多。(出于保密的原因,e-mail 地址都做了修改)。
在调用表 17.2 中所列的 group()方法连接到一个组的时候,你会得到一个长度为 5 的元组。
>>> from nntplib import NNTP
>>> n = NNTP('your.nntp.server')
>>> rsp, ct, fst, lst, grp = n.group('comp.lang.python')
>>> rsp, anum, mid, data = n.article('110457')
>>> for eachLine in data:
...    print eachLine
From: "Alex Martelli" <alex@...> Subject: Re: Rounding Question
Date: Wed, 21 Feb 2001 17:05:36 +0100
"Remco Gerlich" <remco@...> wrote:
> Jacob Kaplan-Moss <jacob@...> wrote in comp.lang.python:
>> So I've got a number between 40 and 130 that I want to round up to
>> the nearest 10. That is:
>>
>> 40 --> 40, 41 --> 50, ..., 49 --> 50, 50 --> 50, 51 --> 60
>> Rounding like this is the same as adding 5 to the number and then
> rounding down. Rounding down is substracting the remainder if you were
> to divide by 10, for which we use the % operator in Python.
This will work if you use +9 in each case rather than +5 (note that he doesn't
really want rounding -- he wants 41 to 'round' to 50, for ex).
Alex
>>> n.quit()
'205 closing connection - goodbye!'
>>>


17.3.6 客户端程序 NNTP 举例
在 NNTP 客户端例子中,我们来点更复杂的。在之前的 FTP 客户端例子中,我们是下载最新的文
件,这一次,我们要下载 Python 语言新闻组 com.lang.python 里的最后一篇文章。
下载完成后,我们会显示文章的前 20 行,而且是前 20 行有意义的内容。有意义的内容是指那
些不是被引用的文本(引用以“>”或“|”开头),也不是像这样的文本“In article <. . .>,
soAndSo@some.domain wrote:”。
最后,我们要智能的处理空行。在文章中出现了一行空行,那我们就显示一行空行,但如果有
多行连续的空行,那只显示一行空行。只有有数据的行才算在“前 20 行”之中。所以,最多可能显
示 39 行输出,20 行实际数据间隔了 19 行空行。
如果脚本的运行正常的话,我们可能会看到这样的输出:
$ getLatestNNTP.py
*** Connected to host "your.nntp.server"
*** Found newsgroup "comp.lang.python"
*** Found last article (#471526):
From: "Gerard Flanagan" <grflanagan@...>
Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22
10:48:20 CEST 2006
*** First (<= 20) meaningful lines:
def partition(N=5):
vals = sorted( random.random() for _ in range(2*N) )
vals = [0] + vals + [1]
for j in range(2*N+1):
yield vals[j:j+2]
deltas = [ x[1]-x[0] for x in partition() ]
print deltas
print sum(deltas)
[0.10271966686994982, 0.13826576491042208, 0.064146913555132801,
0.11906452454467387, 0.10501198456091299, 0.011732423830768779,
0.11785369256442912, 0.065927165520102249, 0.098351305878176198,
0.077786747076205365, 0.099139810689226726]
1.0
$


例 17.2 NNTP 下载示例 (getFirstNNTP.py)
这个脚本下载并显示 Python 新闻组 comp.lang.python 最后一篇文章的前 20 个“有意义的”行。
1 #!/usr/bin/env python
2
3 import nntplib
4 import socket
5
6 HOST = 'your.nntp.server'
7 GRNM = 'comp.lang.python'
8 USER = 'wesley'
9 PASS = "you'llNeverGuess"
10
11 def main():
12
13 try:
14 n = nntplib.NNTP(HOST)
15 #, user=USER, password=PASS)
16 except socket.gaierror, e:
17 print 'ERROR: cannot reach host "%s"' % HOST
18 print ' ("%s")' % eval(str(e))[1]
19 return
20 except nntplib.NNTPPermanentError, e:
21 print 'ERROR: access denied on "%s"' % HOST
22 print ' ("%s")' % str(e)
23 return
24 print '*** Connected to host "%s"' % HOST
25
26 try:
27 rsp, ct, fst, lst, grp = n.group(GRNM)
28 except nntplib.NNTPTemporaryError, e:
29 print 'ERROR: cannot load group "%s"' % GRNM
30 print ' ("%s")' % str(e)
31 print ' Server may require authentication'
32 print ' Uncomment/edit login line above'
33 n.quit()
34 return
35 except nntplib.NNTPTemporaryError, e:


36 print 'ERROR: group "%s" unavailable' % GRNM
37 print ' ("%s")' % str(e)
38 n.quit()
39 return
40 print '*** Found newsgroup "%s"' % GRNM
41
42 rng = '%s-%s' % (lst, lst)
43 rsp, frm = n.xhdr('from', rng)
44 rsp, sub = n.xhdr('subject', rng)
45 rsp, dat = n.xhdr('date', rng)
46 print '''*** Found last article (#%s):
47
48 From: %s
49 Subject: %s
50 Date: %s
51 '''% (lst, frm[0][1], sub[0][1], dat[0][1])
52
53 rsp, anum, mid, data = n.body(lst)
54 displayFirst20(data)
55 n.quit()
56
57 def displayFirst20(data):
58 print '*** First (<= 20) meaningful lines:\n'
59 count = 0
60 lines = (line.rstrip() for line in data)
61 lastBlank = True
62 for line in lines:
63 if line:
64 lower = line.lower()
65 if (lower.startswith('>') and not \
66 lower.startswith('>>>')) or \
67 lower.startswith('|') or \
68 lower.startswith('in article') or \
69 lower.endswith('writes:') or \
70 lower.endswith('wrote:'):
71 continue
72 if not lastBlank or (lastBlank and line):
73 print ' %s' % line
74 if line:
75 count += 1


76  lastBlank = False
77  else:
78  lastBlank = True
79  if count == 20:
80  break
81
82  if __name__ == '__main__':
83  main()
这个输出显示了新闻组帖子的原始内容,如下:
From: "Gerard Flanagan" <grflanagan@...>
Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22
10:48:20 CEST 2006
Groups: comp.lang.python
Gerard Flanagan wrote:
> Anthony Liu wrote:
> > I am at my wit's end.
> > I want to generate a certain number of random numbers.
> > This is easy, I can repeatedly do uniform(0, 1) for
> > example.
> > But, I want the random numbers just generated sum up
> > to 1 .
> > I am not sure how to do this. Any idea? Thanks.
> --------------------------------------------------------------
> import random
> def partition(start=0,stop=1,eps=5):
> d = stop - start
> vals = [ start + d * random.random() for _ in range(2*eps) ]
> vals = [start] + vals + [stop]
> vals.sort()
> return vals
> P = partition()


> intervals = [ P[i:i+2] for i in range(len(P)-1) ]
> deltas = [ x[1] - x[0] for x in intervals ]
> print deltas
> print sum(deltas)
> ---------------------------------------------------------------
def partition(N=5):
vals = sorted( random.random() for _ in range(2*N) )
vals = [0] + vals + [1]
for j in range(2*N+1):
yield vals[j:j+2]
deltas = [ x[1]-x[0] for x in partition() ]
print deltas
print sum(deltas)
[0.10271966686994982, 0.13826576491042208, 0.064146913555132801,
0.11906452454467387, 0.10501198456091299, 0.011732423830768779,
0.11785369256442912, 0.065927165520102249, 0.098351305878176198,
0.077786747076205365, 0.099139810689226726]
1.0
当然,由于新文章不断的出现,输出经常会不一样。只要你的服务器里一有文章更新,输出就
会不一样了。
逐行解释
1-9 行
程序开始是一些导入语句和常量定义,跟 FTP 客户端差不多。
11-40 行
在第一部分,我们尝试连接到 NNTP 服务器,如果失败就退出(13-24 行)。第 15 行故意注释掉
了,如果需要输入用户名和密码进行认证的话,可以打开这一行,并修改第 14 行。后面是尝试读取
指定的新闻组。同样,如果新闻组不存在,服务器没有保存这个新闻组,或是需要认证的话,退出


(26-40 行)。
42-55 行
下面这一部分,我们读一些头信息,并显示出来(42-51 行)              。最有用处的头信息包括作者,主
题和日期。这些数据会被读取并显示给用户。在每一次调用 xhdr()方法时,都要给定想要提取信息
头的文章的范围。我们只想取一条信息,所以范围就是“X-X”,其中,X 是最后一条信息的号码。
xhdr()方法返回一个长度为 2 的元组,包含了服务器的返回信息(rsp)和我们指定范围的信息
头的列表。由于我们只指定了一个消息(最后一个),我们只取列表的第一个元素(hdr[0])。数据
元素是一个长度为 2 的元组,包含文章号和数据字符串。由于我们已经知道了文章号(我们在请求
中给出了),我们只关心第二个元素,数据字符串(hdr[0][1])。
最后一部分是下载文章的内容(53-55 行)          。先调用 body()方法,然后显示前 20 个有意义的行,
最后登出服务器,完成执行。
57-80 行
主要的处理任务由 displayFirst20()函数完成(57-80 行)     。它接受文章的所有行做为参数,并
做一些预处理,如把计数器清 0,创建一个生成器表达式对文章内容的所有行做一些处理,然后“假
装”我们刚碰到并显示了一行空行(59-61 行,稍后细说)。由于前导空格可能是 Python 代码的一
部分,所以在我们去掉字符串中的空格的时候,只删除字符串右边的空格(rstrip())。
我们要做的是,我们不要显示引用的文本和引用文本指示行。这就是 65-71 行(也包含 64 行)
的那个大 if 语句所要做的事。如果这一行不是空行的时候,才做这个检查(63 行)。检查的时候,
会把字符串转成小写,这样就能做到比较的时候大小写无关(64 行)。
如果一行以“>”或“|”开头,说明这一般是一个引用。不过,我们认为“>>>”是一个例外,
因为这有可能是交互命令行的提示,虽然这样可能有问题,因为它也可能是一段被引用了三次的消
息(1 段文本到第 4 个回复的帖子时被引用了 3 次)却被显示了。
现在来处理空行。我们想让程序聪明一些,它应该能显示文章中的空行,但对空行的处理要做
到智能。如果有多个连续的空行,则只显示第一个,这样用户不用看那么多行信息,导致有用的信
息却在屏幕之外。我们也不能把空行计算到 20 行有意义的行之中。所有这些要求都在 72-78 行内实
现。
72 行的 if 语句表示只有在上一行不为空,或者上一行为空但当前行不为空的时候才显示。也就
是说,如果显示了当前行的话,就说明要么当前行不为空,要么当前行为空但上一行不为空。这是
另一个比较有技巧的地方:如果我们碰到了一个非空行,计数器加 1,并设置 lastBlank 标志为 False,
以表示这一行非空(74-76 行)。否则,表示我们碰到了空行,把标志设为 True。
现在回到第 61 行,我们设 lastBlank 标志为 True,是因为,如果内容的第一行实际数据(不是


前导数据或是引用数据)是一个空行,我们不会显示它。因为我们想要看第一行实际数据!
最后,如果我们已经显示了 20 行非空行,则退出,放弃其余的行(79-80 行)。否则,我们应该
已经遍历了所有行,循环也正常结束了。
17.3.7 NNTP 的其它方面
从 NNTP 协议定义/规范(RFC 977)中,你可以得到更多关于 NNTP 的信息:
ftp://ftp.isi.edu/in-notes/rfc977.txt 以及网页
http://www.networksorcery.com/enp/protocol/nntp.htm。其它相关的 RFC 有 1036,2980。
想了解更多 Python 对 NNTP 的支持,可以从这里开始:
http://python.org/docs/current/lib/module-nntplib.html.
17.4 电子邮件
电子邮件既古老又现代。对于我们这些从很早就开始用因特网的人来说,e-mail 看上去是如此
的“古老”,尤其是相对于基于网页的在线聊天,即时聊天(IM),和数字电话即 VOIP(Voice Over
Internet Protocol)等更新更快的通讯方式来说更是如此。下一节中,我们将从宏观上介绍一下
e-mail 是如何工作的。如果你已经对此相当了解,只想看如何用 Python 做 e-mail 相关的开发,你
可以跳到后续章节。
在看 e-mail 的底层的结构之前,你有没有问过自己,e-mail 的确切定义到底是什么?根据 RFC
2822,“消息由头域(合起来叫消息头)以及后面可选的消息体组成”。对于一般用户来说,一说起
e-mail 就会让我们想到它的内容,不管它是一封真的邮件还是一封不请自来的商业广告(即 spam,
垃圾邮件),都应该有内容。不过,RFC 规定,邮件体是可选的,只有邮件头是必要的。这一点要特
别注意。
17.4.1 E-mail 系统组件和协议
不管你是怎么样想的,电子邮件(e-mail)实际上在现代的因特网出现之前就已经出现了。它一
开始用于 mainframe 的用户之间简单的交换信息。注意,由于他们都在使用同一台电脑,所以,这
里甚至都没有涉及到网络。后来,当网络成为现实的时候,用户就可以在不同的主机之间交换信息。
当然,由于用户使用着不同的电脑,电脑之间使用着不同的协议,信息交换成了一个很复杂的概念。
直到 20 世纪 80 年代,因特网上用 e-mail 进行信息交换才有了一个事实上的统一的标准。
在深入细节之前,我们先问问自己,e-mail 是怎么工作的?一条消息是如何从发件人那通过浩
瀚的因特网,到达收件人的?简单点来说,有一台发送电脑(发件人的消息从这里发送出去),和一


台目的电脑(收件人的信件服务器)           。最好的解决方案是发送电脑知道如何连接到接收电脑,这样一
来,它就可以直接把消息发送过去。不过,实际上一般并不这么顺利。
发送电脑要查询到某一台中间主机,这台中间主机能到达最后的收件主机。然后这台中间主机
要找一台离目的主机更近一些的主机。所以,在发送主机和目的主机之间,可能会有多台叫做“跳
板”的主机。如果你仔细看看你收到的 e-mail 的邮件头,你会看到一个“passport”标记,其中记
录了邮件寄给你这一路上都到过了哪些地方。
为了让描述清楚一些,让我们先看看 e-mail 系统的各个组件。最主要的组件是消息传输代理
(MTA)。这是一个在邮件交换主机上运行的一个服务器程序,它负责邮件的路由,队列和发送工作。
它们就是邮件从源主机到目的主机所要经过的跳板。所以也被称为是“信息传输”的“代理”。
要让所有这些工作起来,MTA 要知道两件事情:1) 如何找到消息应该去的下一台 MTA 2) 如何
与另一台 MTA 通讯。第一件事由域名服务(DNS)来查找目的域名的 MX(邮件交换 Mail eXchange)
来完成。这对于最后的收件人是不必要的,但对其它的跳板来说,则是必要的。对于第二件事,MTA
怎么把消息转给其它的 MTA 呢?
17.4.2 发送 E-mail
要能发送 e-mail,你的邮件客户端一定要连接到一个 MTA,它们靠某种协议进行通讯。MTA 之
间通讯所使用的协议叫消息传输系统(MTS)              。只有两个 MTA 都使用这个协议时,才能进行通讯。在
本节开始时就说过,由于以前存在很多不同的计算机系统,每个系统都使用不同的网络软件,这种
通讯很危险,具有不可预知性。更复杂的是,有的电脑使用互连的网络,而有的电脑使用调制解调
器拨号,消息的发送时间也是不可预知的。事实上,笔者曾经有一封邮件在发送 9 个月后才收到!
互连网的速度怎么会这么慢?出于对这些复杂度的考虑,现代 e-mail 的基础之一,简单邮件传输协
议(SMTP)于 1982 年出现了。
SMTP
SMTP 由已故的 Jonathan Postel(加利福尼亚大学信息学院)创建,记录在 RFC 821 中,于
1982 年 8 月公布。其后的修改记录在 RFC 2821 中,于 2001 年 4 月公布。一些已经实现了 SMTP
的著名 MTA 包括:
开源 MTA
z Sendmail
z Postfix
z Exim
z qmail (免费发布,但不开源)


商业 MTA
z Microsoft Exchange
z Lotus Notes Domino Mail Server
注意,虽然它们都实现了 RFC 2821 中定义的最小化 SMTP 协议,它们中的大多数,尤其是一些
商业 MTA,都在服务器中加入了协议定义之外的特有的功能。
SMTP 是在因特网上 MTA 之间用于消息交换的最常用的 MTS。它被 MTA 用来把 e-mail 从一台主机
传送到另一台主机。在你发 e-mail 的时候,你必须要连接到一个外部的 SMTP 服务器,这时,你的
邮件程序是一个 SMTP 客户端。你的 SMTP 服务器也因此成为了你的消息的第一个跳板。
17.4.3 Python 和 SMTP
是的,也存在一个 smtplib 模块和一个 smtplib.SMTP 类要实例化。再来看看这个已经熟悉的过
程吧:
1.   连接到服务器
2.   登录(如果需要的话)
3.   发出服务请求
4.   退出
像 NNTP 一样,登录是可选的,只有在服务器打开了 SMTP 认证(SMTP-AUTH)时才要登录。SMTP-AUTH
在 RFC 2554 中定义。还是跟 NNTP 一样,SMTP 通讯时,只要一个端口 25。
下面是一些 Python 的伪代码:
from smtplib import SMTP
n = SMTP('smtp.yourdomain.com')
...
n.quit()
在看真实的例子之前,我们要先介绍一下 smtplib.SMTP 类的一些常用的方法。
17.4.4 smtplib.SMTP 类方法
跟之前一样,我们会列出 smtplib.SMTP 类的方法,但不会列出所有的方法,只列出你创建 SMTP
客户端程序所需要的方法。对大多数 e-mail 发送程序来说,只有两个方法是必须的:sendmail()和
quit()。


sendmail()的所有参数都要遵循 RFC 2822,即 e-mail 地址必须要有正确的格式,消息体要有正
确的前导头,前导头后面是两个回车和换行(\r\n)对。
注意,实际的消息体不是必要的。根据 RFC 2822,“唯一要求的头信息只有发送日期和发送地址”,
即“Date:”和“From:”:(MAIL FROM, RCPT TO, DATA)
还有一些方法没有被提到,不过,一般来说,它们不是发送 e-mail 所必须的。请参考 Python
文档以获取 SMTP 对象的所有方法的信息。
表 17.3 SMTP 对象的方法
方法                      描述
Sendmail
(from, to, msg[,
mopts, ropts])         把 msg 从 from 发送给 to(列表或元组)。ESMTP 设置(mopts)和收
件人设置(ropts)为可选。
quit()                  关闭连接,然后退出
login(user, passwd)a    使用 user 用户和 passwd 密码登录到 SMTP 服务器
a. 只在有 SMTP-AUTH 时使用。
17.4.5 交互式 SMTP 示例
同样地,我们先给一个交互式的例子:
>>> from smtplib import SMTP as smtp
>>> s = smtp('smtp.python.is.cool')
>>> s.set_debuglevel(1)
>>> s.sendmail('wesley@python.is.cool', ('wesley@python.is.cool',
'chun@python.is.cool'), ''' From: wesley@python.is.cool\r\nTo:
wesley@python.is.cool, chun@python.is.cool\r\nSubject: test
msg\r\n\r\nxxx\r\n.''')
send: 'ehlo myMac.local\r\n'
reply: '250-python.is.cool\r\n'
reply: '250-7BIT\r\n'
reply: '250-8BITMIME\r\n'
reply: '250-AUTH CRAM-MD5 LOGIN PLAIN\r\n'
reply: '250-DSN\r\n'
reply: '250-EXPN\r\n'


reply: '250-HELP\r\n'
reply: '250-NOOP\r\n'
reply: '250-PIPELINING\r\n'
reply: '250-SIZE 15728640\r\n'
reply: '250-STARTTLS\r\n'
reply: '250-VERS V05.00c++\r\n'
reply: '250 XMVP 2\r\n'
reply: retcode (250); Msg: python.is.cool
7BIT
8BITMIME
AUTH CRAM-MD5 LOGIN PLAIN
DSN
EXPN
HELP
NOOP
PIPELINING
SIZE 15728640
STARTTLS
VERS V05.00c++
XMVP 2
send: 'mail FROM:<wesley@python.is.cool> size=108\r\n'
reply: '250 ok\r\n'
reply: retcode (250); Msg: ok
send: 'rcpt TO:<wesley@python.is.cool>\r\n'
reply: '250 ok\r\n'
reply: retcode (250); Msg: ok
send: 'data\r\n'
reply: '354 ok\r\n'
reply: retcode (354); Msg: ok
data: (354, 'ok')
send: 'From: wesley@python.is.cool\r\nTo:
wesley@python.is.cool\r\nSubject: test
msg\r\n\r\nxxx\r\n..\r\n.\r\n'
reply: '250 ok ; id=2005122623583701300or7hhe\r\n'
reply: retcode (250); Msg: ok ; id=2005122623583701300or7hhe
data: (250, 'ok ; id=2005122623583701300or7hhe')
{}
>>> s.quit()
send: 'quit\r\n'
reply: '221 python.is.cool\r\n'


reply: retcode (221); Msg: python.is.cool
17.4.6      SMTP 的其它方面
从 SMTP 协议定义/规范(RFC 2821)中,你可以得到更多关于 SMTP 的信息:
ftp://ftp.isi.edu/in-notes/rfc2821.txt 以及网页
http://www.networksorcery.com/enp/protocol/smtp.htm。
想了解更多 Python 对 SMTP 的支持,可以从这里开始:
http://python.org/docs/current/lib/module-smtplib.html.
我们还没有讨论的 e-mail 的一个很重要的方面是怎么正确的设定因特网地址的格式和 e-mail
消息。这些信息详细记录在因特网信息格式 RFC 2822 中。可以在
ftp://ftp.isi.edu/in-notes/rfc2822.txt 下载。
17.4.7 接收 E-mail
在以前,在因特网上用 e-mail 通讯的只有大学学生,研究人员和工商企业的雇员。桌面电脑还
都是类 Unix 操作系统。家庭用户只是拨号到 PC 上,并不真的使用 e-mail。在 20 世纪 90 年代中期
因特网大爆炸的时候,e-mail 进入了千家万户。
对于家族用户来说,在家里放一个工作站来运行 SMTP 是不现实的。必须要设计一种新的系统,
能够周期性地把信件下载到本地计算机,以供离线时使用。这样的系统就要有一套新的协议和新的
应用程序来与邮件服务器通讯。
在家用电脑中运行的应用程序叫邮件用户代理(MUA)。MUA 从服务器上下载邮件,在这个过程中
可能会自动删除它们(也可能不删除,留在服务器上,让用户手动删除)。不过,MUA 也必须要能发
送邮件。也就是说,在发送邮件的时候,它要能直接与 MTA 用 SMTP 进行通讯。在前面讲 SMTP 的章
节中,我们已经看过这种客户端了。那下载邮件的呢?
17.4.8 POP 和 IMAP
用于下载邮件的第一个协议叫邮局协议,记录在 RFC 918 中,于 1984 年 10 月公布。“邮局协议
(POP)的目的是让用户的工作站可以访问邮箱服务器里的邮件。邮件要能从工作站通过简单邮件传
输协议(SMTP)发送到邮件服务器”。POP 协议的最新版本是第 3 版,也叫 POP3。
POP3 在 RFC 1939 中定义,至今为止仍在被广泛地使用,                也是我们下面的客户端例子的主要内容。
在 POP 之后几年,出现了另一个协议,叫交互式邮件访问协议(IMAP)。第一个版本是实验性的,


直到第 2 版时,其 RFC 1064 才在 1988 年被公布。现在被使用的 IMAP 版本是 IMAP4rev1,它也被广
泛地使用。事实上,当今世界上占有邮件服务器大多数市场的 Microsoft Exchange 就使用 IMAP 作
为其下载机制。IMAP4rev1 协议定义在 RFC 3501,于 2003 年 3 月公布。IMAP 的目的是要提供一个更
全面的解决方案。不过,它比 POP 更为复杂。对 IMAP 的进一步讨论超出了本章剩余部分的范围。我
们建议感兴趣的用户参考上述 RFC 文档。图 17-3 展示的复杂系统就是我们所认为的简单的 e-mail。
图 17-3 因特网上的 E-Mail 发件人和收件人。客户端通过他们的 MUA 和相应的 MTA 进行通讯,
来下载和发送邮件。E-Mail 从一个 MTA“跳”到另一个 MTA,直到到达目的地为止。
17.4.9 Python 和 POP3
毫不奇怪,我们要做的是:导入 poplib,实例化 poplib.POP3 类。
标准的做法如下:
1.   连接到服务器
2.   登录
3.   发出服务请求
4.   退出
Python 的伪代码如下:
from poplib import POP3
p = POP3('pop.python.is.cool')
p.user(...)
p.pass_(...)
...
p.quit()
在看真实的例子之前,我们要先看一个交互式的例子以及介绍一下 poplib.POP3 类的一些基本
的方法。


17.4.10 交互式 POP3 举例
下面是使用 Python poplib 模块的交互式的例子:
>>> from poplib import POP3
>>> p = POP3('pop.python.is.cool')
>>> p.user('techNstuff4U')
'+OK'
>>> p.pass_('notMyPasswd')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "/usr/local/lib/python2.4/poplib.py", line 202,
in pass_
return self._shortcmd('PASS %s' % pswd)
File "/usr/local/lib/python2.4/poplib.py", line 165,
in _shortcmd
return self._getresp()
File "/usr/local/lib/python2.4/poplib.py", line 141,
in _getresp
raise error_proto(resp)
poplib.error_proto: -ERR directory status: BAD PASSWORD
>>> p.user('techNstuff4U')
'+OK'
>>> p.pass_('youllNeverGuess')
'+OK ready'
>>> p.stat()
(102, 2023455)
>>> rsp, msg, siz = p.retr(102)
>>> rsp, siz
('+OK', 480)
>>> for eachLine in msg:
... print eachLine
...
Date: Mon, 26 Dec 2005 23:58:38 +0000 (GMT)
Received: from c-42-32-25-43.smtp.python.is.cool
by python.is.cool (scmrch31) with ESMTP
id <2005122623583701300or7hhe>; Mon, 26 Dec 2005
23:58:37 +0000


From: wesley@python.is.cool
To: wesley@python.is.cool
Subject: test msg
xxx
.
>>> p.quit()
'+OK python.is.cool'
17.4.10 poplib.POP3 类方法
POP3 类有无数的方法来帮助你下载和离线管理你的邮箱。最常用的列在表 17.4 中。
表 17.4 POP3 对象的常用方法
方法                 描述
user(login)       发送用户名 login 到服务器,并等候服务器的正在等待用户密码的返回信息
pass_(passwd)     发送密码 passwd(在使用 user()登录之后使用)         。如果登录失败,引发一
个异常
stat()             返回邮件的状态,一个长度为 2 的元组(msg_ct, mbox_siz):消息的数
量和消息的总大小也即字节数
list([msgnum])     stat()的扩展,从服务器返回长度为 3 的元组的消息列表(rsp, msg_list,
rsp_siz):服务器的返回信息,消息的列表,返回信息的大小。如果给
了 msgnum 的话,只返回指定消息的数据。
retr(msgnum)         从服务器中得到消息 msgnum,并设置其“已读”标志。返回一个长度为
3 的元组(rsp, msglines, msgsiz)
:服务器的返回信息,消息 msgnum
的所有行,消息的字节数
dele(msgnum)       把消息 msgnum 标记为删除,大多数服务器在调用 quit()后执行删除操作。
quit()               登出,保存修改(如,执行“已读”和“删除”标记等),解锁邮箱,
结束连接,然后退出
在登录时,user()方法不仅向服务器发送了用户名,也要等待服务器正在等待用户密码的返回信
息。如果 pass_()方法认证失败,会引发一个 poplib.error_proto 的异常。
如果成功,会得到一个以'+'号开头的返回信息,如“+OK ready”,然后服务器上的该邮箱就被


锁定了,直到调用了 quit()方法为止。
调用 list()方法时,msg_list 的格式为:[‘msgnum msgsiz’,...],其中,msgnum 和 msgsiz
分别是每个消息的编号和消息的大小。
还有一些方法未被列出,想要了解更多信息,请参考 Python 手册里 poplib 的文档。
17.4.12 客户端程序 SMTP 和 POP3 举例
下面的例子演示了如何使用 SMTP 和 POP3 来创建一个既能接收和下载 e-mail 也能上传和发送
e-mail 的客户端。我们将要先用 SMTP 发一封 e-mail 给自己(或其它测试帐户),等待一段时间——
我们随便选了一个时间,10 秒钟——然后使用 POP3 下载这封 e-mail,下载下来的内容跟发送的内
容应该是完全一样的。如果程序悄无声息地结束,没有输出也没有异常,那就说明我们的操作都成
功了。
例 17.3 SMTP 和 POP3 示例 (myMail.py)
这个脚本(通过 SMTP 邮件服务器)发送一封测试 e-mail 到目的地址,并马上(通过 POP)把
e-mail 从服务器上收回来。要让程序能正常工作,你需要修改服务器的名字和 e-mail 的地址。
1 #!/usr/bin/env python
2
3 from smtplib import SMTP
4 from poplib import POP3
5 from time import sleep
6
7 SMTPSVR = 'smtp.python.is.cool'
8 POP3SVR = 'pop.python.is.cool'
9
10 origHdrs = ['From: wesley@python.is.cool',
11 'To: wesley@python.is.cool',
12 'Subject: test msg']
13 origBody = ['xxx', 'yyy', 'zzz']
14 origMsg = '\r\n\r\n'.join(['\r\n'.join(origHdrs),
'\r\n'.join(origBody)])
15
16 sendSvr = SMTP(SMTPSVR)
17 errs = sendSvr.sendmail('wesley@python.is.cool',
18 ('wesley@python.is.cool',), origMsg)


19 sendSvr.quit()
20 assert len(errs) == 0, errs
21 sleep(10) # wait for mail to be delivered
22
23 recvSvr = POP3(POP3SVR)
24 recvSvr.user('wesley')
25 recvSvr.pass_('youllNeverGuess')
26 rsp, msg, siz = recvSvr.retr(recvSvr.stat()[0])
27 # strip headers and compare to orig msg
28 sep = msg.index('')
29 recvBody = msg[sep+1:]
30 assert origBody == recvBody # assert identical
逐行解释
1-8 行
跟本章前面的例子一样,程序一开始是一些导入语句和常量的定义。常量分别是发送邮件和接
收邮件的服务器。
10-14 行
这几行是消息内容的准备工作。这里,我们放了三行消息头然后是消息体。From 和 To 两个头
分别表示消息的发件人和收件人。14 行把消息头和消息体放在一起组成一个可以发送的消息,按
RFC 2822 的要求,这两部分用空行隔开。
16-21 行
我们连接到发送(SMTP)服务器来发送我们的消息。这里还有一对 From 和 To 的地址,这些地
址是“真实”的 e-mail 地址,或者说是信封格式(envlelope)的地址。收件人参数应该是一个可迭
代的对象,如果传的是一个字符串,就会被转成一个只有一个元素的列表。不请自来的垃圾邮件中,
消息头和信封头总是不一致的。
sendmail()的第三个参数是 e-mail 信息本身。这个函数返回之后,我们就登出 SMTP 服务器,
并判断是否有错误发生过。我们要等待一段时间,等待服务器完成消息的发送与接收。
23-30 行
程序的最后一部分是下载刚刚发送的消息,并断言发送的和接收的消息是完全一样的。先给出
用户名和密码,连接到 POP3 服务器,在登录成功后,调用 stat()方法得到有效的消息的列表。我们
先选第一条消息([0]),然后调用 retr()下载这个消息。
我们用空行来分隔头和信息,去掉头部分,比较原始信息体和收到的信息体。如果它们相同,
什么都不显示,程序正常退出,否则,会出现一个断言失败的错误。


由于错误的类型太多,我们在这个脚本里不做错误检查,这样的好处是你可以直接看到出现了
什么错误。在本章末尾有一个习题就是做错误检查的。
现在,你对如何发送和接收 e-mail 有了一个很全面的了解。如果你想深入了解这一方面的编程,
请参阅下一章里介绍的 e-mail 相关的模块,它们在程序开发方面有相当大的帮助。
17.5 相关模块
Python 最好的一个方面就是它在标准库中提供了相当的全面的网络支持。尤其在因特网协议和
客户端开发方面的支持更为全面。下面列出了一些相关模块,首先是电子邮件相关的,随后是一般
用途的因特网协议相关的。
17.5.1 E-mail
Python 自带了很多 e-mail 模块和包可以帮助你创建应用程序。表 17.5 中列出了一部分。
表 17.5 E-Mail 相关模块
模块/包            描述
email          e-mail 处理的包 (也支持 MIME)
rfc822           RFC2822 邮件头解析器
smtpd           SMTP 服务器
base64          Base 16,32,和 64 数据编码(RFC 3548)
mhlib           处理 MH 文件夹和信息的类
mailbox         支持 mailbox 文件格式解析的类
mailcap        “mailcap” 文件的处理模块
mimetools      (不建议使用)MIME 信息解析工具(使用上面的 email)
mimetypes        在文件名或 URL 到相关的 MIME 类型之间转换的模块
MimeWriter      (不建议使用)MIME 信息处理模块(使用上面的 email)
mimify         (不建议使用)信息的 MIME 处理工具(使用上面的 email)
binascii        二进制和 ASCII 转换
binhex           Binhex4 编码和解码支持
17.5.2 其他网络协议
表 17.6 因特网协议相关的模块


模块           描述
ftplib      FTP 协议客户端
gopherlib  Gopher 协议客户端
httplib     HTTP 和 HTTPS 协议客户端
imaplib     IMAP4 协议客户端
nntplib     NNTP protocol client
nntplib     NNTP 协议客户端
poplib      POP3 协议客户端
smtplib   SMTP 协议客户端
telnetlib  Telnet 协议客户端类
17.6 练习
FTP
17-1. 简单 FTP 客户端。参考本章的 FTP 例子,写一个小的 FTP 客户端程序,能够去你喜欢的
网站下载你使用的软件的最新版本。这个脚本应该每几个月就运行一次,以确保你在用的软件是“最
新和最好的”。你应该把 FTP 地址,登录信息放在一个表里,省得每次都要修改。
17-2. 简单 FTP 客户端和模式匹配。在上一个练习的基础上创建一个新的 FTP 客户端程序。
它可以上传和下载指定模式的文件。比方说,如果想把一些 Python 的文件和 PDF 文件从一台电脑
传到另一台电脑上,那用户可以输入“*.py”或“doc*.pdf”,程序会只传这些文件名匹配的文件。
17-3. 智能 FTP 命令行客户端程序。创建一个跟 Unix 下/bin/ftp 类似的命令行下的 FTP 程序,
不过,这个 FTP 客户端要更好一些,能提供更有用的功能。你可以看看 http://ncftp.com 的 ncFTP
做为样板。它有以下功能:历史记录,书签(可以保存 FTP 地址和登录信息)                        ,下载进度显示等。你
可以使用 readline 来记录历史命令,用 curses 来控制屏幕。
17-4. FTP 和多线程。创建一个能使用 Python 的线程库下载文件的 FTP 客户端程序。你可以通
过修改上一个练习的程序或者重写一个简单的客户端来下载文件。你可以在命令行参数里指定要下
载的文件,也可以做一个 GUI,在界面中让用户选择要下载的文件。附加题:要能支持模式,如*.exe。
要使用不同的线程来下载每个文件。
17-5. FTP 和 GUI。在你上面写的 FTP 客户端程序中加入 GUI,让你的程序成为一个完整的 FTP
应用程序。你可以使用 Python 的任何 GUI 工具包。
17-6. 子类化。从 ftplib.FTP 派生出一个类 FTP2,在这个类中,你不用像之前那 4 个 retr*()
和 stor*()方法中那样要给定“STOR filename” 或“RETR filename”这样的命令。只要传文件名
就好了。你可以重写已有的方法也可以在方法后加一个 2,如 retrlines2()。


Python 发布包中有一个 Tools/scripts/ftpmirror.py 脚本,它使用 ftplib 模块,可以对整个
FTP 站点或 FTP 站点的一部分做镜像。它可以做为 ftplib 模块应用的扩展例子来使用。解答下面 5
个问题时,可以参考这个脚本。你可以直接使用 ftpmirror.py 里的代码,也可以以这个脚本为样板,
自己重新写一个。
17-7. 递归。ftpmirror.py 脚本递归的复制一个远程的目录。写一个与 ftpmirror.py 相似的
脚本,它的默认行为是不递归的。只有在传入了“-r”参数的时候,才递归的把文件复制到本地目
录。
17-8. 模式匹配。ftpmirror.py 脚本支持“-s”参数让用户指定能匹配模式的文件不下载,如
“*.exe”。重新写一个简单的 FTP 客户端程序或修改之前的程序,实现让用户指定通配符,程序只
下载能匹配模式的文件。可以在你之前练习的答案基础上实现。
17-9.  递归和模式匹配。写一个 FTP 客户端程序,把上面两个练习的脚本集成在一起。
17-10. 递归和 ZIP 文件。这个练习与上面的第一个递归练习有些相似,只是不再直接把文件
下载到本地文件系统,而是文件下载后压缩到一个 ZIP(或 TGZ,或 BZ2)文件中。同样,你可以在
之前脚本的基础上改,也可以重写一个。使用“-z”参数让用户可以自动地备份一个 FTP 站点。
17-11. 集成。实现一个最终的,全功能的 FTP 应用程序,包含上面几个练习的所有功能。即,
支持“-r”“-s”和“-z”参数。
NNTP
17-12. NNTP 介绍。修改例 17.2(getLatestNNTP.py),让它显示第一封(而不是最后一封)有
效文章的有意义的内容。
17-13. 代码改进。修正 getLatestNNTP.py 的会输出 3 次引用问题,这是因为我们想输出 Python
交互解释的内容,而不是被 3 次引用的文本。用检查“>>>”后的代码是否为合法 Python 代码的方
式来解决这个问题。如果合法,那就显示这一行数据,如果不合法,认为是引用文本,不显示。附
加题:你的解决方案再解决这样一个小问题:我们没有去掉前导的空格,因为它可能是
Python 代码的缩进。如果真的是代码的缩进,就显示它,否则,认为它是一般的文本,先对字
符串用 lstrip()方法处理后再显示。
17-14. 查找文章。写一个 NNTP 客户端程序,让用户能选择并登录感兴趣的新闻组。在登录成
功后,提示用户输入一些关键字,使用这些关键字来查找文章的标题。把符合要求的文章列出来显
示给用户。用户可以在列表中选择某一篇文章进行阅读,这时要能显示选定文章的内容。程序还要
有简单的导航功能,如分页等。如果没有给出搜索关键字,则显示所有的文章。


17-15. 搜索内容。修改上一题你的脚本,让脚本同时搜索主题和文章内容。允许关键字的“与”
(AND)和“或”(OR)的操作。也要允许指定在标题和文章内容的“与”(AND)和“或”(OR)即,
关键字要只在标题里出现,只在内容里出现或两者里面都要出现。
17-16. 线索化的新闻阅读工具。把不同的回帖组织到一个“文章线索”中。也就是说,把相
关的文章放在一起,与文章什么时候发的没有关系。同一个线索中的文章按时间顺序排列。
用户可以:
(a) 选择某一篇文章进行阅读,然后可以选择回到文章列表,顺序阅读当前线索的
前一篇文章或是后一篇文章。
(b) 允许回复线索,可以选择复制并引用之前文章,用跟贴的方式回复到整个新闻组。附加题:
也允许私下用 e-mail 进行回复。
(c) 永久地删除线索,即后续的相关文章不会在文章列表中显示。要实现这个功能,你应该把
要删除的文章的列表暂时记录下来。一个线索在几个月之后还没有人回复的话,你可以认为这个线
索已经死了。
17-17. GUI 新闻阅读工具。跟上面的 FTP 练习差不多,选择一个 GUI 工具包来实现一个完整的,
独立的 GUI 新闻阅读工具。
17-18.    重 构 。 跟 FTP 的 ftpmirror.py 一 样 。 NNTP 也 有 一 个 示 例 脚 本 :
Demo/scripts/newslist.py。运行它。这个脚本在很久之前就写好了,你可以做一些翻新工作。做
为练习,你要用 Python 新版本的一些特性和你的 Python 开发技巧来重构这个脚本。让这个脚本运
行得更快。你可以使用列表解析和生成器表达式,用更智能的字符串连接而不是调用不必要的函数
等。
17-19. 缓冲。如其作者所说,newslist.py 的另一个问题是,           “我应该把要忽略的空的新闻组
的列表保存下来,在每次运行的时候检查一下是否有新的文章,但我真的抽不出时间”。你来实现这
个功能。你可以直接修改它,也可以修改你之前的脚本。
E-MAIL
17-20. 标识符。POP3 的 pass_()方法用于在调用 login()方法传了用户名之后,传递密码。你
能不能说出,为什么这个方法命名时要在后面加一个下划线,即“pass_()”,而不是“pass()”?
17-21. IMAP。现在,你已经熟悉了 POP 是怎么工作的。这方面的经验对你写一个 IMAP 客户端
程序也是有帮助的。研究一下 IMAP 协议的 RFC 文档,使用 Python 的 imaplib 模块来实现一个 IMAP
客户端程序。
下面的练习题跟本章(例 17.3)中的 myMail.py 程序有关。
17-22.  e-mail 头。在 myMail.py 的最后几行,比较了发送的信息体与接收到的 e-mail 的信息


体。写一段相似的代码,比较信息头。注意,要忽略新加入的头。
17–23.   错误检查。加入 SMTP 和 POP3 的错误检查。
17-24. SMTP 和 IMAP。在简单的 myMail.py 中,加入 IMAP 的支持。附加题:支持两种邮件下
载协议,让用户选择要使用哪一种协议。
17-25.  撰写 e-mail。再次扩展你之前的程序,允许用户撰写和发送 e-mail。
17-26. e-mail 应用程序。再次扩展你的 e-mail 应用程序,           在其中加入更有用的邮箱管理功能。
你的程序要能读出当前所有 e-mail 的信息,并显示其主题。用户可以选择想要看的邮件。附加题:
要能支持用外部程序查看附件。
17-27.  GUI. 给你的脚本加入 GUI 的功能,让它成为一个实用的完整的 e-mail 应用程序。
17-28. 垃圾邮件的特点。不请自来的垃圾邮件(spam)是当今的一大问题。所幸,针对这个
问题有不少好的解决方案。我们不用你来重新发明轮子,我们想让你了解一些垃圾邮件的特点。
(a) “mbox”格式。在开始之前,我们要把你想处理的 e-mail 信息转为一个公共的格式。比
如"mbox"格式。(如果你愿意,你也可以使用别的格式。)如果你已经有了一些 mbox 格式的消息,
把它们合并到一个文件中。
(b) 头。很多 e-mail 的头上就看出有垃圾邮件的线索。(你可以用 email 包或自己解析头)。
写一段代码来回答以下问题:
- 发送这个消息的 e-mail 客户端软件是什么?(检查 X-Mailer 头)
- 报文 ID(Message-ID 头)的格式是否合法?
- From, Received 和 Return-Path 头的域名是否不匹配?域名和 IP 地址是否不匹配?有没有
X-Authentication-Warning 头?如果有的话,内容是什么?
(c) 信息服务器。一些服务器如 WHOIS, SenderBase.org 等可以根据 IP 地址或域名帮助你找
到 e-mail 来自何方。找到一些这样的服务,写一些代码来得到来源地的国别,城市,网络所有者的
名字,联系方法等。
(d) 关键字。垃圾邮件中,有一些字经常出现。你之前一定见过,它们是单个的字母,开头大
写的随机字母等。把你常见的一些大量在垃圾邮件中出现的词汇放在一个列表中。把出现了这些词
汇的邮件做为疑似垃圾邮件隔离。附加题:设计一种算法或加入一些关键字的变形来找出这些邮件。
(e) 钓鱼。这些垃圾邮件总是想把他们伪装成来自大银行或某个知名的网站的合法的 e-mail。
里面包含某种链接,引诱用户输入自己私密的或是敏感的信息,如登录用户名,密码和信用卡的卡
号等。这些骗子往往做得足以以假乱真。不过,他们还是免不了要让用户登录到与他们声称的并不
相符的网站。这里,就可能会透露出很多信息,如,看上去很乱七八糟的域名,只用了 IP 地址,或
是 32 位整数形式而不是字节形式的 IP 地址等。写一段代码来判断一封看上去像正式交流的 e-mail
是真的还是假的。


其它
可以在
http://www.networksorcery.com/enp/topic/ipsuite.htm#Application%20layer%20protocol
s
找到包含本章中所列的那些协议在内的各种因特网协议的列表。Python(当前)所支持的因特
网协议列表可以在 http://docs.python.org/lib/internet.html 找到。
17-29. 开发其它因特网客户端程序。现在,你已经看到了 4 个 Python 开发因特网客户端程序
的例子。选一种 Python 标准库中支持的其它协议,开发一个对应的客户端程序。
17-30. *开发一种新的因特网客户端程序。这个难度比较大:找到一个不常用的,或是还未成
型的 Python 尚未支持的协议,实现它。如果做得好的话,你可以考虑提交一个 PEP,把你的实现加
入到以后版本 Python 的标准库中发布。


多线程编程
本章主题
z 引言/动机
z 线程和进程
z 线程和 Python
z thread 模块
z threading 模块
z 生产者-消费者问题和 Queue 模块
z 相关模块


本节中,我们将探索在 Python 中,用多线程编程技术实现代码并行性的几种不同的方法。在前
面几节中,我们将介绍进程与线程的区别。然后介绍多线程编程的概念。           (已经熟悉多线程编程的读
者可以直接跳到第 18.3.5 节)
。本章的最后几节将演示在 Python 中如何使用 threading 和 Queue 模
块来实现多线程编程。
18.1 引言/动机
在多线程(MT)编程出现之前,电脑程序的运行由一个执行序列组成,执行序列按顺序在主机
的中央处理器(CPU)中运行。无论是任务本身要求顺序执行还是整个程序是由多个子任务组成,程
序都是按这种方式执行的。即使子任务相互独立,互相无关(即,一个子任务的结果不影响其它子
任务的结果)时也是这样。这样是不是有点不合逻辑?会不会想要并行运行这些相互独立的子任务
呢?这样的并行处理可以大幅度地提升整个任务的效率。这就是多线程编程的目的。
多线程编程对于某些任务来说,是最理想的。这些任务具有以下特点:它们本质上就是异步的,
需要有多个并发事务,各个事务的运行顺序可以是不确定的,随机的,不可预测的。这样的编程任
务可以被分成多个执行流,每个流都有一个要完成的目标。根据应用的不同,这些子任务可能都要
计算出一个中间结果,用于合并得到最后的结果。
运算密集型的任务一般都比较容易分隔成多个子任务,可以顺序执行或以多线程的方式执行。
单线程处理多个外部输入源的的任务就不是那么容易了。这种编程任务如果不用多线程的方式处理,
则一定要使用一个或多个计时器来实现。
一个顺序执行的程序要从每个 I/O(输入/输出)终端信道检查用户的输入时,程序无论如何也不
能在读取 I/O 终端信道的时候阻塞。因为用户输入的到达是不确定的,阻塞会导致其它 I/O 信息的


数据不能被处理。顺序执行的程序必须使用非阻塞 I/O,或是带有计时器的阻塞 I/O(这样才能保证
阻塞只是暂时的)。
由于顺序执行的程序只有一个线程在运行。它要保证它要做的多任务,不会有某个任务占用太
多的时间,而且要合理地分配用户的响应时间。执行多任务的顺序执行的程序一般程序控制流程都
很复杂,难以理解。
使用多线程编程和一个共享的数据结构如 Queue(本章后面会介绍的一种多线程队列数据结构),
这种程序任务可以用几个功能单一的线程来组织:
z   UserRequestThread: 负责读取客户的输入,可能是一个 I/O 信道。程序可能创建多个线程,
每个客户一个,请求会被放入队列中。
z   RequestProcessor: 一个负责从队列中获取并处理请求的线程,它为下面那种线程提供输出。
z   ReplyThread: 负责把给用户的输出取出来,如果是网络应用程序就把结果发送出去,否则
就保存到本地文件系统或数据库中。
把这种编程任务用多线程来组织可以降低程序的复杂度,并使得干净,有效和具有良好组织地
程序结构实现变得可能。每个线程的逻辑都不会很复杂,因为它要做的事情很清楚。例如,
UserRequestThread 只是从用户或某个数据源读取数据,放到一个队列中,等待其它线程进一步的
处理,等等,每个线程都有自己明确的任务。你只要设计好每个线程要做什么,并把要做的事做好
就可以了。对某些任务使用线程跟亨利福特制造汽车时使用的装配线模型有些相似。
18.2 线程和进程
18.2.1 什么是进程?
计算机程序只不过是磁盘中可执行的,二进制(或其它类型)的数据。它们只有在被读取到内
存中,被操作系统调用的时候才开始它们的生命期。进程(有时被称为重量级进程)是程序的一次
执行。每个进程都有自己的地址空间,内存,数据栈以及其它记录其运行轨迹的辅助数据。操作系
统管理在其上运行的所有进程,并为这些进程公平地分配时间。进程也可以通过 fork 和 spawn 操作
来完成其它的任务。不过各个进程有自己的内存空间,数据栈等,所以只能使用进程间通讯(IPC),
而不能直接共享信息。
18.2.2 什么是线程?
线程(有时被称为轻量级进程)跟进程有些相似,不同的是,所有的线程运行在同一个进程中,
共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。


线程有开始,顺序执行和结束三部分。它有一个自己的指令指针,记录自己运行到什么地方。
线程的运行可能被抢占(中断),或暂时的被挂起(也叫睡眠),让其它的线程运行,这叫做让步。
一个进程中的各个线程之间共享同一片数据空间,所以线程之间可以比进程之间更方便地共享数据
以及相互通讯。线程一般都是并发执行的,正是由于这种并行和数据共享的机制使得多个任务的合
作变为可能。实际上,在单 CPU 的系统中,真正的并发是不可能的,每个线程会被安排成每次只运
行一小会,然后就把 CPU 让出来,让其它的线程去运行。在进程的整个运行过程中,每个线程都只
做自己的事,在需要的时候跟其它的线程共享运行的结果。
当然,这样的共享并不是完全没有危险的。如果多个线程共同访问同一片数据,则由于数据访
问的顺序不一样,有可能导致数据结果的不一致的问题。这叫做竞态条件(race condition)。幸运
的是,大多数线程库都带有一系列的同步原语,来控制线程的执行和数据的访问。
另一个要注意的地方是,由于有的函数会在完成之前阻塞住,在没有特别为多线程做修改的情
况下,这种“贪婪”的函数会让 CPU 的时间分配有所倾斜。导致各个线程分配到的运行时间可能不
尽相同,不尽公平。
18.3 Python、线程和全局解释器锁
18.3.1 全局解释器锁(GIL)
Python 代码的执行由 Python 虚拟机(也叫解释器主循环)来控制。Python 在设计之初就考虑到
要在主循环中,同时只有一个线程在执行,就像单 CPU 的系统中运行多个进程那样,内存中可以存
放多个程序,但任意时刻,只有一个程序在 CPU 中运行。同样地,虽然 Python 解释器中可以“运行”
多个线程,但在任意时刻,只有一个线程在解释器中运行。
对 Python 虚拟机的访问由全局解释器锁(GIL)来控制,正是这个锁能保证同一时刻只有一个
线程在运行。在多线程环境中,Python 虚拟机按以下方式执行:
1.    设置 GIL
2.    切换到一个线程去运行
3.    运行:
a. 指定数量的字节码指令,或者
b. 线程主动让出控制(可以调用 time.sleep(0))
4.    把线程设置为睡眠状态
5.    解锁 GIL
6.    再次重复以上所有步骤
在调用外部代码(如 C/C++扩展函数)的时候,GIL 将会被锁定,直到这个函数结束为止(由于
在这期间没有 Python 的字节码被运行,所以不会做线程切换)。编写扩展的程序员可以主动解锁 GIL。


不过,Python 的开发人员则不用担心在这些情况下你的 Python 代码会被锁住。
例如,对所有面向 I/O 的(会调用内建的操作系统 C 代码的)程序来说,GIL 会在这个 I/O 调用之
前被释放,以允许其它的线程在这个线程等待 I/O 的时候运行。如果某线程并未使用很多 I/O 操作,
它会在自己的时间片内一直占用处理器(和 GIL)                      。也就是说,I/O 密集型的 Python 程序比计算密集
型的程序更能充分利用多线程环境的好处。
对源代码,解释器主循环和 GIL 感兴趣的人,可以看看 Python/ceval.c 文件。
18.3.2 退出线程
当一个线程结束计算,它就退出了。线程可以调用 thread.exit()之类的退出函数,也可以使用
Python 退出进程的标准方法,如 sys.exit()或抛出一个 SystemExit 异常等。不过,你不可以直接
“杀掉”("kill")一个线程。
在下面一节中,我们将要讨论两个跟线程有关的模块。这两个模块中,我们不建议使用 thread
模块。这样做有很多原因,很明显的一个原因是,当主线程退出的时候,所有其它线程没有被清除
就退出了。但另一个模块 threading 就能确保所有“重要的”子线程都退出后,进程才会结束。                           (我
们等一会会详细说明什么叫“重要的”,请参阅守护线程的核心提示)。
主线程应该是一个好的管理者,它要了解每个线程都要做些什么事,线程都需要什么数据和什
么参数,以及在线程结束的时候,它们都提供了什么结果。这样,主线程就可以把各个线程的结果
组合成一个有意义的最后结果。
18.3.3 在 Python 中使用线程
在 Win32 和 Linux, Solaris, MacOS, *BSD 等大多数类 Unix 系统上运行时,Python 支持多线程
编程。Python 使用 POSIX 兼容的线程,即 pthreads。
默认情况下,从源代码编译的(2.0 及以上版本的)Python 以及 Win32 的安装包里,线程支持是
打开的。想要从解释器里判断线程是否可用,只要简单的在交互式解释器里尝试导入 thread 模块就
行了,只要没出现错误就表示线程可用。
>>> import thread
>>>
如果你的 Python 解释器在编译时,没有打开线程支持,导入模块会失败:


>>> import thread
Traceback (innermost last): File "<stdin>", line 1, in ?
ImportError: No module named thread
这种情况下,你就要重新编译你的 Python 解释器才能使用线程。                      你可以在运行配置脚本的时候,
加上“--with-thread”参数。参考你的发布版的 README 文件,以获取如何编译支持线程的 Python
的相关信息。
18.3.4 没有线程支持的情况
第一个例子中,我们会使用 time.sleep()函数来演示线程是怎样工作的。time.sleep()需要一
个浮点型的参数,来指定“睡眠”的时间(单位秒)。这就意味着,程序的运行会被挂起指定的时间。
我们要创建两个“计时循环”             。一个睡眠 4 秒种,一个睡眠 2 秒种,分别是 loop0()和 loop1()。
(我们命名为“loop0”和“loop1”表示我们将有一个循环的序列)。如果我们像例 18.1 的 onethr.py
中那样,在一个进程或一个线程中,顺序地执行 loop0()和 loop1(),那运行的总时间为 6 秒。在启
动 loop0(),loop1(),和其它的代码时,也要花去一些时间,所以,我们看到的总时间也有可能会
是 7 秒钟。
例 18.1 单线程中运行的循环 (onethr.py)
在单线程中顺序执行两个循环。一定要一个循环结束后,另一个才能开始。总时间是各个循环
运行时间之和。
1 #!/usr/bin/env python
2
3 from time import sleep, ctime
4
5 def loop0():
6 print 'start loop 0 at:', ctime()
7 sleep(4)
8 print 'loop 0 done at:', ctime()
9
10 def loop1():
11 print 'start loop 1 at:', ctime()
12 sleep(2)
13 print 'loop 1 done at:', ctime()
14
15 def main():


16   print 'starting at:', ctime()
17   loop0()
18   loop1()
19   print 'all DONE at:', ctime()
20
21   if __name__ == '__main__':
22   main()
我们可以通过运行 onethr.py 来验证这一点,下面是运行的输出:
$ onethr.py
starting at: Sun Aug 13 05:03:34 2006
start loop 0 at: Sun Aug 13 05:03:34 2006
loop 0 done at: Sun Aug 13 05:03:38 2006
start loop 1 at: Sun Aug 13 05:03:38 2006
loop 1 done at: Sun Aug 13 05:03:40 2006
all DONE at: Sun Aug 13 05:03:40 2006
假定 loop0()和 loop1()里做的不是睡眠,而是各自独立的,不相关的运算,各自的运算结果
到最后将会汇总成一个最终的结果。这时,如果能让这些计算并行执行的话,那不是可以减少总的
运行时间吗?这就是我们现在要介绍的多线程编程的前提条件。
18.3.5 Python 的 threading 模块
Python 提供了几个用于多线程编程的模块,包括 thread, threading 和 Queue 等。thread 和
threading 模块允许程序员创建和管理线程。thread 模块提供了基本的线程和锁的支持,而 threading
提供了更高级别,功能更强的线程管理的功能。Queue 模块允许用户创建一个可以用于多个线程之间
共享数据的队列数据结构。我们将分别介绍这几个模块,并给出一些例子和中等大小的应用。
核心提示:避免使用 thread 模块
出于以下几点考虑,我们不建议您使用 thread 模块。首先,更高级别的 threading 模块更为先
进,对线程的支持更为完善,而且使用 thread 模块里的属性有可能会与 threading 出现冲突。其次,
低级别的 thread 模块的同步原语很少(实际上只有一个),而 threading 模块则有很多。
不过,出于对学习 Python 和线程的兴趣,我们将给出一点使用 thread 模块的例子。这些代码
只用于学习目的,让你对为什么应该避免使用 thread 模块有更深的认识,以及让你了解在把代码改
为使用 threading 和 Queue 模块时,我们能获得多大的便利。
另一个不要使用 thread 原因是,对于你的进程什么时候应该结束完全没有控制,当主线程结束
时,所有的线程都会被强制结束掉,没有警告也不会有正常的清除工作。我们之前说过,至少
threading 模块能确保重要的子线程退出后进程才退出。


只建议那些有经验的专家在想访问线程的底层结构的时候,才使用 thread 模块。而使用线程的
新手们则应该看看我们是如何把线程应用到我们的第一个程序,从而增加代码的可读性,以及第一
段例子如何进化到我们本章的主要的代码的。如果可以的话,你的第一个多线程程序应该尽可能地
使用 threading 等高级别的线程模块。
18.4 thread 模块
我们先看看 thread 模块都提供了些什么。除了产生线程外,thread 模块也提供了基本的同步数
据结构锁对象(lock object,也叫原语锁,简单锁,互斥锁,互斥量,二值信号量)。如之前所说,
同步原语与线程的管理是密不可分的。
表 18.1 中所列的是常用的线程函数以及 LockType 类型的锁对象的方法。
start_new_thread()函数是 thread 模块的一个关键函数,它的语法与内建的 apply()函数完全
一样,其参数为:函数,函数的参数以及可选的关键字参数。不同的是,函数不是在主线程里运行,
而是产生一个新的线程来运行这个函数。
现在,把线程加入到我们的 onethr.py 例子中。稍微改变一下 loop*()函数的调用方法,我们
得到了例 18.2 的 mtsleep1.py。
表 18.1 thread 模块和锁对象
函数                                 描述
thread 模块函数
start_new_thread(function,
args, kwargs=None)               产生一个新的线程,在新线程中用指定的参数和可选的
kwargs 来调用这个函数。
allocate_lock()               分配一个 LockType 类型的锁对象
exit()                        让线程退出
LockType 类型锁对象方法
acquire(wait=None)            尝试获取锁对象
locked()                     如果获取了锁对象返回 True,否则返回 False
release()                        释放锁
例 18.2 使用 thread 模块 (mtsleep1.py)
这儿执行的是和 onethr.py 中一样的循环,不同的是,这一次我们使用的是 thread 模块提供的
简单的多线程的机制。两个循环并发地被执行(显然,短的那个先结束)。总的运行时间为最慢的那
个线程的运行时间,而不是所有的线程的运行时间之和。


1 #!/usr/bin/env python
2
3 import thread
4 from time import sleep, ctime
5
6 def loop0():
7 print 'start loop 0 at:', ctime()
8 sleep(4)
9 print 'loop 0 done at:', ctime()
10
11 def loop1():
12 print 'start loop 1 at:', ctime()
13 sleep(2)
14 print 'loop 1 done at:', ctime()
15
16 def main():
17 print 'starting at:', ctime()
18 thread.start_new_thread(loop0, ())
19 thread.start_new_thread(loop1, ())
20 sleep(6)
21 print 'all DONE at:', ctime()
22
23 if __name__ == '__main__':
24 main()
start_new_thread()要求一定要有前两个参数。所以,就算我们想要运行的函数不要参数,我
们也要传一个空的元组。
这个程序的输出与之前的输出大不相同,之前是运行了 6,7 秒,而现在则是 4 秒,是最长的循
环的运行时间与其它的代码的时间总和。
$ mtsleep1.py
starting at: Sun Aug 13 05:04:50 2006
start loop 0 at: Sun Aug 13 05:04:50 2006
start loop 1 at: Sun Aug 13 05:04:50 2006
loop 1 done at: Sun Aug 13 05:04:52 2006
loop 0 done at: Sun Aug 13 05:04:54 2006
all DONE at: Sun Aug 13 05:04:56 2006


睡眠 4 秒和 2 秒的代码现在是并发执行的。这样,就使得总的运行时间被缩短了。你可以看到,
loop1 甚至在 loop0 前面就结束了。程序的一大不同之处就是多了一个“sleep(6)”的函数调用。为
什么要加上这一句呢?因为,如果我们没有让主线程停下来,那主线程就会运行下一条语句,显示
“all done”,然后就关闭运行着 loop0()和 loop1()的两个线程,退出了。
我们没有写让主线程停下来等所有子线程结束之后再继续运行的代码。这就是我们之前说线程
需要同步的原因。在这里,我们使用了 sleep()函数做为我们的同步机制。我们使用 6 秒是因为我们
已经知道,两个线程(你知道,一个要 4 秒,一个要 2 秒)在主线程等待 6 秒后应该已经结束了。
你也许在想,应该有什么好的管理线程的方法,而不是在主线程里做一个额外的延时 6 秒的操
作。因为这样一来,我们的总的运行时间并不比单线程的版本来得少。而且,像这样使用 sleep()
函数做线程的同步操作是不可靠的。如果我们的循环的执行时间不能事先确定的话,那怎么办呢?
这可能造成主线程过早或过晚退出。这就是锁的用武之地了。
上一次修改程序,我们去掉了 loop 函数,现在,我们要再一次修改程序为例 18.3 的 mtsleep2.py,
引入锁的概念。运行它,我们看到,其输出与 mtsleep1.py 很相似,唯一的区别是我们不用为线程
什么时候结束再做额外的等待。使用了锁,我们就可以在两个线程都退出后,马上退出。
$ mtsleep2.py
starting at: Sun Aug 13 16:34:41 2006
start loop 0 at: Sun Aug 13 16:34:41 2006
start loop 1 at: Sun Aug 13 16:34:41 2006
loop 1 done at: Sun Aug 13 16:34:43 2006
loop 0 done at: Sun Aug 13 16:34:45 2006
all DONE at: Sun Aug 13 16:34:45 2006
我们是怎么通过锁来完成任务的呢?先看一看代码吧。
例 18.3 使用线程和锁 (mtsleep2.py)
这里,使用锁比 mtsleep1.py 那里在主线程中使用 sleep()函数更合理。
1  #!/usr/bin/env python
2
3  import thread
4  from time import sleep, ctime
5
6  loops = [4,2]
7
8  def loop(nloop, nsec, lock):


9 print 'start loop', nloop, 'at:', ctime()
10 sleep(nsec)
11 print 'loop', nloop, 'done at:', ctime()
12 lock.release()
13
14 def main():
15 print 'starting at:', ctime()
16 locks = []
17 nloops = range(len(loops))
18
19 for i in nloops:
20 lock = thread.allocate_lock()
21 lock.acquire()
22 locks.append(lock)
23
24 for i in nloops:
25 thread.start_new_thread(loop,
26 (i, loops[i], locks[i]))
27
28 for i in nloops:
29 while locks[i].locked(): pass
30
31 print 'all DONE at:', ctime()
32
33 if __name__ == '__main__':
34 main()
逐行解释
1-6 行
在 Unix 启动信息行后面,我们导入了 thread 模块和 time 模块里我们早已熟悉的几个函数。我
们不再在函数里写死要等 4 秒和 2 秒,而是使用一个 loop()函数,把这些常量放在一个列表 loops
里。
8-12 行
loop()函数替换了我们之前的那几个 loop*()函数。在 loop()函数里,增加了一些锁的操作。
一个很明显的改变是,我们现在要在函数中记录下循环的号码和要睡眠的时间。最后一个不一样的
地方就是那个锁了。每个线程都会被分配一个事先已经获得的锁,在 sleep()的时间到了之后就释放
相应的锁以通知主线程,这个线程已经结束了。


14-34 行
主要的工作在包含三个循环的 main()函数中完成。我们先调用 thread.allocate_lock()函数创
建一个锁的列表,并分别调用各个锁的 acquire()函数获得锁。获得锁表示“把锁锁上”。锁上后,
我们就把锁放到锁列表 locks 中。下一个循环创建线程,每个线程都用各自的循环号,睡眠时间和
锁为参数去调用 loop()函数。为什么我们不在创建锁的循环里创建线程呢?有以下几个原因:(1) 我
们想到实现线程的同步,所以要让“所有的马同时冲出栅栏”。(2) 获取锁要花一些时间,如果你的
线程退出得“太快”,可能会导致还没有获得锁,线程就已经结束了的情况。
在线程结束的时候,线程要自己去做解锁操作。最后一个循环只是坐在那一直等(达到暂停主
线程的目的),直到两个锁都被解锁为止才继续运行。由于我们顺序检查每一个锁,所以我们可能会
要长时间地等待运行时间长且放在前面的线程,当这些线程的锁释放之后,后面的锁可能早就释放
了(表示对应的线程已经运行完了)           。结果主线程只能毫不停歇地完成对后面这些锁的检查。最后两
行代码的意思你应该已经知道了,就是只有在我们直接运行这个脚本时,才运行 main()函数
在核心笔记中我们就已经说过,使用 thread 模块只是为了给读者演示如何进行多线程编程。你
的多线程程序应该使用更高级别的模块,如 threading 等。现在我们就开始讨论它。
18.5 threading 模块
接下来,我们要介绍的是更高级别的 threading 模块,它不仅提供了 Thread 类,还提供了各
种非常好用的同步机制。表 18.2 列出了 threading 模块里所有的对象。
在这一节中,我们会演示如何使用 Thread 类来实现多线程。之前已经介绍过锁的基本概念,这
里我们将不会提到锁原语。而 Thread 类也有某种同步机制,所以,没有必要详细介绍锁原语。
表 18.2 threading 模块对象
threading 模块对象                 描述
Thread              表示一个线程的执行的对象
Lock               锁原语对象(跟 thread 模块里的锁对象相同)
RLock              可重入锁对象。使单线程可以再次获得已经获得了的锁(递归锁定)。
Condition           条件变量对象能让一个线程停下来,等待其它线程满足了某个“条件”。
如,状态的改变或值的改变。
Event               通用的条件变量。多个线程可以等待某个事件的发生,在事件发生后,
所有的线程都会被激活。
Semaphore           为等待锁的线程提供一个类似“等候室”的结构
BoundedSemaphore    与 Semaphore 类似,只是它不允许超过初始值
Timer               与 Thread 相似,只是,它要等待一段时间后才开始运行。


核心提示:守护线程
另一个避免使用 thread 模块的原因是,它不支持守护线程。当主线程退出时,所有的子线程不
论它们是否还在工作,都会被强行退出。有时,我们并不期望这种行为,这时,就引入了守护线程
的概念
threading 模块支持守护线程,它们是这样工作的:守护线程一般是一个等待客户请求的服务器,
如果没有客户提出请求,它就在那等着。如果你设定一个线程为守护线程,就表示你在说这个线程
是不重要的,在进程退出的时候,不用等待这个线程退出。就像你在第 16 章网络编程看到的,服务
器线程运行在一个无限循环中,一般不会退出。
如果你的主线程要退出的时候,不用等待那些子线程完成,那就设定这些线程的 daemon 属性。
即,在线程开始(调用 thread.start())之前,调用 setDaemon()函数设定线程的 daemon 标志
(thread.setDaemon(True))就表示这个线程“不重要”
如果你想要等待子线程完成再退出,那就什么都不用做,或者显式地调用
thread.setDaemon(False)以保证其 daemon 标志为 False。你可以调用 thread.isDaemon()函数来判
断其 daemon 标志的值。新的子线程会继承其父线程的 daemon 标志。整个 Python 会在所有的非守护
线程退出后才会结束,即进程中没有非守护线程存在的时候才结束。
18.5.1 Thread 类
threading 的 Thread 类是你主要的运行对象。          它有很多 thread 模块里没有的函数,详见表 18.3。
用 Thread 类,你可以用多种方法来创建线程。我们在这里介绍三种比较相像的方法。你可以任
选一种你喜欢的,或最适合你的程序以及最能满足程序可扩展性的(我们一般比较喜欢最后一个选
择):
z   创建一个 Thread 的实例,传给它一个函数
z   创建一个 Thread 的实例,传给它一个可调用的类对象
z   从 Thread 派生出一个子类,创建一个这个子类的实例
表 18.3 Thread 对象的函数
函数                     描述
start()           开始线程的执行
run()             定义线程的功能的函数(一般会被子类重写)
join(timeout=None) 程序挂起,直到线程结束;如果给了 timeout,则最多阻塞 timeout 秒
getName()         返回线程的名字
setName(name)      设置线程的名字
isAlive()        布尔标志,表示这个线程是否还在运行中
isDaemon()        返回线程的 daemon 标志


setDaemon(daemonic) 把线程的 daemon 标志设为 daemonic(一定要在调用 start()函数前调用)
创建一个 Thread 的实例,传给它一个函数
第一个例子的中,我们将初始化一个 Thread 对象,把函数(及其参数)像上一个例子那样传进
去。在线程开始执行的时候,这个函数会被执行。把 mtsleep2.py 脚本拿过来,做一些调整加入 Thread
对象的使用,就成了例 18.4 中的 mtsleep3.py。
运行的输出跟之前很相似:
$ mtsleep3.py
starting at: Sun Aug 13 18:16:38 2006
start loop 0 at: Sun Aug 13 18:16:38 2006
start loop 1 at: Sun Aug 13 18:16:38 2006
loop 1 done at: Sun Aug 13 18:16:40 2006
loop 0 done at: Sun Aug 13 18:16:42 2006
all DONE at: Sun Aug 13 18:16:42 2006
那么,都做了些什么修改呢?在使用 thread 模块时使用的锁没有了。新加了一些 Thread 对象。
在实例化每个 Thread 对象的时候,我们把函数(target)和参数(args)传进去,得到返回的 Thread
实例。实例化一个 Thread(调用 Thread())与调用 thread.start_new_thread()之间最大的区别就
是,新的线程不会立即开始。在你创建线程对象,但不想马上开始运行线程的时候,这是一个很有
用的同步特性。
例 18.4 使用 threading 模块 (mtsleep3.py)
threading 模块的 Thread 类有一个 join()函数,允许主线程等待线程的结束。
1 #!/usr/bin/env python
2
3 import threading
4 from time import sleep, ctime
5
6 loops = [4,2]
7
8 def loop(nloop, nsec):
9 print 'start loop', nloop, 'at:', ctime()
10 sleep(nsec)
11 print 'loop', nloop, 'done at:', ctime()
12
13 def main():


14 print 'starting at:', ctime()
15 threads = []
16 nloops = range(len(loops))
17
18 for i in nloops:
19 t = threading.Thread(target=loop,
20 args=(i, loops[i]))
21 threads.append(t)
22
23 for i in nloops: # start threads
24 threads[i].start()
25
26 for i in nloops: # wait for all
27 threads[i].join() # threads to finish
28
29 print 'all DONE at:', ctime()
30
31 if __name__ == '__main__':
32 main()
所有的线程都创建了之后,再一起调用 start()函数启动,而不是创建一个启动一个。而且,
不用再管理一堆锁(分配锁,获得锁,释放锁,检查锁的状态等),只要简单地对每个线程调用 join()
函数就可以了。
join()会等到线程结束,或者在给了 timeout 参数的时候,等到超时为止。使用 join()看上去
会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")
join()的另一个比较重要的方面是它可以完全不用调用。一旦线程启动后,就会一直运行,直
到线程的函数结束,退出为止。如果你的主线程除了等线程结束外,还有其它的事情要做(如处理
或等待其它的客户请求),那就不用调用 join(),只有在你要等待线程结束的时候才要调用 join()。
创建一个 Thread 的实例,传给它一个可调用的类对象
与传一个函数很相似的另一个方法是在创建线程的时候,传一个可调用的类的实例供线程启动
的时候执行——这是多线程编程的一个更为面向对象的方法。相对于一个或几个函数来说,由于类
对象里可以使用类的强大的功能,可以保存更多的信息,这种方法更为灵活。
把 ThreadFunc 类加入到 mtsleep3.py 代码中,并做一些其它的小修改后,就得到了例 18.5 中
的 mtsleep4.py。运行它,就会得到如下的输出:


$ mtsleep4.py
starting at: Sun Aug 13 18:49:17 2006
start loop 0 at: Sun Aug 13 18:49:17 2006
start loop 1 at: Sun Aug 13 18:49:17 2006
loop 1 done at: Sun Aug 13 18:49:19 2006
loop 0 done at: Sun Aug 13 18:49:21 2006
all DONE at: Sun Aug 13 18:49:21 2006
那么,这次又改了些什么呢?主要是增加了 ThreadFunc 类和创建 Thread 对象时会实例化一个
可调用类 ThreadFunc 的类对象。也就是说,            我们实例化了两个对象。下面,来仔细地看一看 ThreadFunc
类吧。
我们想让这个类在调用什么函数方面尽量地通用,并不局限于那个 loop()函数。所以,我们加
了一些修改,如,这个类保存了函数的参数,函数本身以及函数的名字字符串。构造函数__init__()
里做了这些值的赋值工作。
创建新线程的时候,Thread 对象会调用我们的 ThreadFunc 对象,这时会用到一个特殊函数
__call__()。由于我们已经有了要用的参数,所以就不用再传到 Thread()的构造函数中。由于我们
有一个参数的元组,这时要在代码中使用 apply()函数。如果你使用的是 Python1.6 或是更高版本,
你可以使用 11.6.3 节中所说的新的调用语法,而不用像第 16 行那样使用 apply()函数:
self.res = self.func(*self.args)
例 18.5 使用可调用的类 (mtsleep4.py)
此例中,我们传了一个可调用的类(的实例),而不是仅传一个函数。相对 mtsleep3.py 中的方
法来说,这样做更具面向对象的概念。
1 #!/usr/bin/env python
2
3 import threading
4 from time import sleep, ctime
5
6 loops = [4,2]
7
8 class ThreadFunc(object):
9
10 def __init__(self, func, args, name=''):
11 self.name = name
12 self.func = func


13 self.args = args
14
15 def __call__(self):
16 apply(self.func, self.args)
17
18 def loop(nloop, nsec):
19 print 'start loop', nloop, 'at:', ctime()
20 sleep(nsec)
21 print 'loop', nloop, 'done at:', ctime()
22
23 def main():
24 print 'starting at:', ctime()
25 threads = []
26 nloops = range(len(loops))
27
28 for i in nloops: # create all threads
29 t = threading.Thread(
30 target=ThreadFunc(loop, (i, loops[i]),
31 loop.__name__))
32 threads.append(t)
33
34 for i in nloops: # start all threads
35 threads[i].start()
36
37 for i in nloops: # wait for completion
38 threads[i].join()
39
40 print 'all DONE at:', ctime()
41
42 if __name__ == '__main__':
43 main()
从 Thread 派生出一个子类,创建一个这个子类的实例
最后一个例子介绍如何子类化 Thread 类,这与上一个例子中的创建一个可调用的类非常像。使
用子类化创建线程(第 29-30 行)使代码看上去更清晰明了。我们将在例 18.6 中给出 mtsleep5.py
的代码,以及代码运行的输出。比较 mtsleep5.py 和 mtsleep4.py 的任务则留给读者做为练习。
下面是 mtsleep5.py 的输出,同样,跟我们的期望一致:


$ mtsleep5.py
starting at: Sun Aug 13 19:14:26 2006
start loop 0 at: Sun Aug 13 19:14:26 2006
start loop 1 at: Sun Aug 13 19:14:26 2006
loop 1 done at: Sun Aug 13 19:14:28 2006
loop 0 done at: Sun Aug 13 19:14:30 2006
all DONE at: Sun Aug 13 19:14:30 2006
在读者比较 mtsleep4 和 mtsleep5 两个模块的代码之前,我们想指出最重要的两点改变:(1)我
们的 MyThread 子类的构造函数一定要先调用基类的构造函数(第 9 行),(2)之前的特殊函数
__call__()在子类中,名字要改为 run()。
现在,在 MyThread 类中,加入一些用于调试的输出信息,把代码保存到 myThread 模块中(见例
18.7),并在下面的例子中,导入这个类。除了简单地使用 apply()函数来运行这些函数之外,我们
还把结果保存到实现的 self.res 属性中,并创建一个新的函数 getResult()来得到结果。
18.5.4 斐波那契,阶乘和累加和
例 18.8 中的 mtfacfib.py 脚本比较了递归求斐波那契,阶乘和累加和函数的运行。脚本先在
单线程中运行这三个函数,然后在多线程中做同样的事,以说明多线程的好处。
例 18.6 子类化 Thread (mtsleep5.py)
我们现在要子类化 Thread 类,而不是创建它的实例。这样做可以更灵活地定制我们的线程对象,
而且在创建线程的时候也更简单。
1 #!/usr/bin/env python
2
3 import threading
4 from time import sleep, ctime
5
6 loops = (4, 2)
7
8 class MyThread(threading.Thread):
9 def __init__(self, func, args, name=''):
10 threading.Thread.__init__(self)
11 self.name = name
12 self.func = func
13 self.args = args


14
15 def run(self):
16 apply(self.func, self.args)
17
18 def loop(nloop, nsec):
19 print 'start loop', nloop, 'at:', ctime()
20 sleep(nsec)
21 print 'loop', nloop, 'done at:', ctime()
22
23 def main():
24 print 'starting at:', ctime()
25 threads = []
26 nloops = range(len(loops))
27
28 for i in nloops:
29 t = MyThread(loop, (i, loops[i]),
30 loop.__name__)
31 threads.append(t)
32
33 for i in nloops:
34 threads[i].start()
35
36 for i in nloops:
37 threads[i].join()
38
39 print 'all DONE at:', ctime()'
40
41 if __name__ == '__main__':
42 main()
例 18.7 MyThread 子类化 Thread (myThread.py)
为了让 mtsleep5.py 中,Thread 的子类更为通用,我们把子类单独放在一个模块中,并加上一
个 getResult()函数用以返回函数的运行结果。
1 #!/usr/bin/env python
2
3 import threading
4 from time import ctime
5


6 class MyThread(threading.Thread):
7 def __init__(self, func, args, name=''):
8 threading.Thread.__init__(self)
9 self.name = name
10 self.func = func
11 self.args = args
12
13 def getResult(self):
14 return self.res
15
16 def run(self):
17 print 'starting', self.name, 'at:', \
18 ctime()
19 self.res = apply(self.func, self.args)
20 print self.name, 'finished at:', \
21 ctime()
在单线程中运行只要简单地逐个调用这些函数,在函数结束后,显示对应的结果。在多线程中,
我们不马上显示结果。由于我们想让 MyThread 类尽可能地通用(能同时适应有输出和没输出的函数),
我们会等到要结束时才会调用 getResult()函数,并在最后显示每个函数的结果。
由于这些函数运行得很快(斐波那契函数会慢一些),你会看到,我们得在每个函数中加上一
个 sleep()函数,让函数慢下来,以便于我们能方便地看到多线程能在多大程度上加速程序的运行。
不过实际工作中,你一般不会想在程序中加上 sleep()函数的。下面是程序的输出:
$ mtfacfib.py
*** SINGLE THREAD
starting fib at: Sun Jun 18 19:52:20 2006
233
fib finished at: Sun Jun 18 19:52:24 2006
例 18.8 斐波那契,阶乘和累加和 (mtfacfib.py)
在这个多线程程序中,我们会分别在单线程和多线程环境中,运行三个递归函数。
1 #!/usr/bin/env python
2
3 from myThread import MyThread
4 from time import ctime, sleep
5


6 def fib(x):
7 sleep(0.005)
8 if x < 2: return 1
9 return (fib(x-2) + fib(x-1))
10
11 def fac(x):
12 sleep(0.1)
13 if x < 2: return 1
14 return (x * fac(x-1))
15
16 def sum(x):
17 sleep(0.1)
18 if x < 2: return 1
19 return (x + sum(x-1))
20
21 funcs = [fib, fac, sum]
22 n = 12
23
24 def main():
25 nfuncs = range(len(funcs))
26
27 print '*** SINGLE THREAD'
28 for i in nfuncs:
29 print 'starting', funcs[i].__name__, 'at:', \
30 ctime()
31 print funcs[i](n)
32 print funcs[i].__name__, 'finished at:', \
33 ctime()
34
35 print '\n*** MULTIPLE THREADS'
36 threads = []
37 for i in nfuncs:
38 t = MyThread(funcs[i], (n,),
39 funcs[i].__name__)
40 threads.append(t)
41
42 for i in nfuncs:
43 threads[i].start()
44
45 for i in nfuncs:


46 threads[i].join()
47 print threads[i].getResult()
48
49 print 'all DONE'
50
51 if __name__ == '__main__':
52 main()
starting fac  at: Sun Jun 18 19:52:24 2006
479001600
fac finished at: Sun Jun 18 19:52:26 2006
starting sum at: Sun Jun 18 19:52:26 2006
78
sum finished at: Sun Jun 18 19:52:27 2006
*** MULTIPLE THREADS
starting fib at: Sun Jun 18 19:52:27 2006
starting fac at: Sun Jun 18 19:52:27 2006
starting sum at: Sun Jun 18 19:52:27 2006
233
479001600
78
all DONE
18.5.5 threading 模块中的其它函数
除了各种同步对象和线程对象外,threading 模块还提供了一些函数。见表 18.4。
表 18.4 threading 模块的函数
函数                  描述
activeCount()      当前活动的线程对象的数量
currentThread() 返回当前线程对象
enumerate()        返回当前活动线程的列表
a
settrace(func)           为所有线程设置一个跟踪函数
a
setprofile(func) 为所有线程设置一个 profile 函数
a.   Python 2.3 新增


18.5.5 生产者-消费者问题和 Queue 模块
最后一个例子演示了生产者和消费者的场景。生产者生产货物,然后把货物放到一个队列
之类的数据结构中,生产货物所要花费的时间无法预先确定。消费者消耗生产者生产
的货物的时间也是不确定的。
表 18.5 常用的 Queue 模块的属性
函数               描述
Queue 模块函数
queue(size)     创建一个大小为 size 的 Queue 对象
Queue 对象函数
qsize()         返回队列的大小(由于在返回的时候,队列可能会被其它线程修改,所以这个
值是近似值)
empty()         如果队列为空返回 True,否则返回 False
full()          如果队列已满返回 True,否则返回 False
put(item,
block=0) 把 item 放到队列中,如果给了 block(不为 0),函数会一直阻塞到队列中有
空间为止
get(block=0)   从队列中取一个对象,如果给了 block(不为 0),函数会一直阻塞到
队列中有对象为止
Queue 模块可以用来进行线程间通讯,让各个线程之间共享数据。现在,我们创建一个队列,让
生产者(线程)把新生产的货物放进去供消费者(线程)使用。要达到这个目的,我们要使用到 Queue
模块的以下属性(见表 18.5)。
很容易地,我们就能写出例 18.9 的 prodcons.py 的代码。
下面是这个脚本的运行输出:
$ prodcons.py
starting writer at: Sun Jun 18 20:27:07 2006
producing object for Q... size now 1
starting reader at: Sun Jun 18 20:27:07 2006
consumed object from Q... size now 0
producing object for Q... size now 1
consumed object from Q... size now 0
producing object for Q... size now 1


producing object for Q... size now 2
producing object for Q... size now 3
consumed object from Q... size now 2
consumed object from Q... size now 1
writer finished at: Sun Jun 18 20:27:17 2006
consumed object from Q... size now 0
reader finished at: Sun Jun 18 20:27:25 2006
all DONE
如你所见,生产者和消费者不一定是轮流执行的(多亏有了随机数!)。实际上,真实生活总是
充满了随机性和不确定性。
逐行解释
1-6 行
在 这 个 模 块 中 , 我 们 要 使 用 Queue.Queue 对 象 以 及 我 们 在 例 18.7 中 给 出 的 的 线 程 类
myThread.MyThread。我们将使用 random.randint()函数来随机的进行生产和消耗。并从 time 模块
中导入了常用的属性。
8-16 行
writeQ()和 readQ()函数分别用来把对象放入队列和消耗队列中的一个对象。在这里我们使用
字符串'xxx'来表示队列中的对象。
18-26 行
writer()函数只做一件事,就是一次往队列中放入一个对象,等待一会,然后再做同样的事,
一共做指定的次数,这个次数是由脚本运行时随机生成的。reader()函数做的事比较类似,只是它
是用来消耗对象的。
你会注意到,writer 睡眠的时间一般会比 reader 睡眠的时间短。这可以减少 reader 尝试从空
队列中取数据的机会。writer 的睡眠时间短,那 reader 在想要数据的时候总是能拿到数据。
28-29 行
设置有多少个线程要被运行。
例 18.9 生产者-消费者问题 (prodcons.py)
这个实现中使用了 Queue 对象和随机地生产(和消耗)货物的方式。生产者和消费者相互独立
并且并发地运行。
1 #!/usr/bin/env python


2
3 from random import randint
4 from time import sleep
5 from Queue import Queue
6 from myThread import MyThread
7
8 def writeQ(queue):
9 print 'producing object for Q...',
10 queue.put('xxx', 1)
11 print "size now", queue.qsize()
12
13     def readQ(queue):
14 val = queue.get(1)
15 print 'consumed object from Q... size now', \
16 queue.qsize()
17
18     def writer(queue, loops):
19 for i in range(loops):
20 writeQ(queue)
21 sleep(randint(1, 3))
22
23     def reader(queue, loops):
24 for i in range(loops):
25 readQ(queue)
26 sleep(randint(2, 5))
27
28     funcs = [writer, reader]
29     nfuncs = range(len(funcs))
30
31     def main():
32 nloops = randint(2, 5)
33 q = Queue(32)
34
35 threads = []
36 for i in nfuncs:
37 t = MyThread(funcs[i], (q, nloops),
38 funcs[i].__name__)
39 threads.append(t)
40
41 for i in nfuncs:


42   threads[i].start()
43
44   for i in nfuncs:
45    threads[i].join()
46
47    print 'all DONE'
48
49     if __name__ == '__main__':
50    main()
31-47 行
最后,就到了 main()函数,它与之前的所有脚本的 main()函数都很像。先是创建所有的线程,
然后运行它们,最后,等两个线程都结束后,得到最后的运行结果。
从本例中,我们可以了解到,一个要完成多项任务的程序,可以考虑每个任务使用一个线程。
这样的程序在设计上相对于单线程做所有事的程序来说,更为清晰明了。
本章中,我们看到了单线程的程序在程序性能上的限制。尤其在有相互独立的,运行时间不确
定的多个任务的程序里,把多个任务分隔成多个线程同时运行会比顺序运行速度更快。由于 Python
解释器是单线程的,所以不是所有的程序都能从多线程中得到好处。不过,你已经对 Python 下的
多线程有所了解,在适当的时候,可以利用它来改善程序的性能。
18.6 相关模块
下表列出了一些多线程编程中可能用得到的模块:
表 18.6 多线程相关的标准库模块
模块      描述
thread 基本的,底级别的线程模块
threading 高级别的线程和同步对象
Queue    供多线程使用的同步先进先出(FIFO)队列
mutex    互斥对象
SocketServer    具有线程控制的 TCP 和 UDP 管理器
18.7 练习
18-1. 进程与线程。线程与进程的区别是什么?


18-2. Python 的线程。在 Python 中,哪一种多线程的程序表现得更好,I/O 密集型的还是计算
密集型的?
18-3. 线程。你认为,多 CPU 的系统与一般的系统有什么大的不同?多线程的程序在这种系统
上的表现会怎么样?
18-4. 线程和文件。把练习 9-19 的答案做一些改进。我们要得到一个字节值,一个文件名
然后显示在文件中那个字节出现了多少次。假设这个文件非常的大。文件是可以有多个
读者的,那我们就可以创建多个线程,每个线程负责文件的一部分。最后,把所有的线程
的结果相加。使用 timeit()对单线程和多线程分别进行计时,对性能的改进进行讨论。
18-5. 线程,文件和正则表达式。你有一个非常大的 mailbox 文件——如果没有的话,你可以
把你所有的 e-mail 的原始信息放到一个文本文件中。你现在要做的是,使用你在 15 章写的
识别 e-mail 地址和网页 URL 的正则表达式,分析出这个大文件里的所有的 e-mail 地址和 URL,
把这些链接写到一个.html(或.htm)文件中。在这个文件生成时,会自动显示一个浏览器,
打开这个文件,显示所有的链接。使用多线程来分隔处理大文件和把结果写到一个新的
.html 文件的操作。在浏览器中测试一下你的结果,确保那些链接都能正常工作。
18-6. 线程和网络。你在之前做的聊天服务器程序(练习 16-7 到 16-10)也许会用到重量
级线程或者说进程,把那个代码改成多线程的。
18-7. *线程和 Web 编程。练习 19.1 中的爬虫,是一个单线程的网页下载程序, 但可以利用
多线程提高性能。
修改 crawl.py(你可以叫它 mtcrawl.py),让它可以使用多个不相关的线
程来下载网页。注意要使用某种锁的机制以确保不会在访问链接队列的时候出现访问冲突。
18-8. 线程池。修改例 18.9 的代码,不再是一个生产者和一个消费者,而是可以有任意个
消费者线程(一个线程池),每个线程可以在任意时刻处理或消耗任意多个产品。
18-9. 文件。创建一些线程来计算一些(可能很大量的)文件中一共有多少行。你可以选择
要使用多少个线程。比较单线程与多线程的性能差异。提示:回顾一下第 9 章(文件和输入
输出)的练习。
18-10. 把你之前的解决方案应用到你选择的几个任务中,如,处理一些 e-mail,下载一些
网页,处理一些 RSS 和 Atom feeds,聊天时的消息处理,解一个迷题等。


图形用户界面编程
本章主题
z 引言
z Tkinter 与 Python 编程
z Tkinter 模块
z Tk 组件库
z Tkinter 使用举例
z 标签、按钮与进度条组件
z 一个使用 Tk 的中级范例
z 其他 GUI 简介(Tix, Pmw, wxPython, PyGTK)
z 相关模块和其他 GUI


本章我们将对图形用户界面(GUI)进行简介。不论您是初次涉及该领域还是想学到更多,抑或
只是想看看 Python 是如何做的,这一章都会适合您。在这短短的一章里我们无法对 GUI 程序开发介
绍得面面俱到,但我们将给您讲解最核心的内容。Python 的默认 GUI 工具集是 Tk,它也是我们将使
用的最基本的 GUI 工具集,我们可以通过 Python 接口 Tkinter 来使用 Tk(Tkinter 正是“Tk 接口”
之意)  。
Tk 并非“最强、最新”也不是包含 GUI 构建模块最多的工具集,但它非常简单,并且可以开发
出能运行于大多数平台的 GUI 程序。我们将用 Tkinter 举几个例子其中包括一个中级范例,随后我
们还将给出几个其他工具集的例子。一旦完成了本章的学习,您将掌握构建复杂应用程序的技巧,
也有能力转向那些更流行的图形工具集。Python 有许多对主流工具集的绑定(Binding)或转接
(Adaptor),其中不乏对商业系统的,这里就不多介绍了。
19.1 简介
19.1.1 什么是 Tcl、Tk 和 Tkinter?
Tkinter 是 Python 的默认 GUI 库,它基于 Tk 工具集,后者最初是为工具命令语言(Tcl)设计
的。Tk 流行后被移植到许多其他脚本语言中,包括 Perl(Perl/Tk)、Ruby(Ruby/Tk)和 Python
(Tkinter)。借助于 Tk 开发 GUI 的可移植性和灵活性,加上脚本语言的简洁和系统语言的强劲,我
们得到了一件可与商业软件相匹敌的利器,它可以用于快速开发各种 GUI 程序。
如果是初涉 GUI 编程,您会惊喜地发现一切竟如此简单。您也会发现 Python 搭配 Tkinter 提供
了一种高效的、激动人心的应用程序构建方式,可以用来开发出有趣(并且往往还有用)的程序。


而同样的程序如果直接使用 C/C++,基于本地窗口系统库开发将多花很长的时间。一旦设计好了程序
及相应外观,您接下来要做的只是用那些被称作组件的基本构造块去搭建想要的模块,最终再赋予
其功能就能让一切“活起来”。
如果您是个 Tk 老手,不论是使用过 Tcl 还是 Perl,都会发现 Python 提供了一种进行 GUI 编程
的全新方式。Python 基于 Tk 提供了一种更高效的快速原型系统用以创建应用。别忘了您同时还享有
Python 的系统访问、网络操作、XML、数字可视化、数据库访问、以及所有其他标准库和第三方模块。
一旦您在自己的系统中装好了 Tkinter,用不了 15 分钟就可以让您的第一个 GUI 程序运行起来!
19.1.2 安装和使用 Tkinter
类似于线程模块,您系统中的 Tkinter 未必是默认开启的。您可以通过尝试导入 Tkinter 模块
来判断它是否能被 Python 解释器使用。如果 Tkinter 是可用的,不会出现任何错误:
>>> import Tkinter
>>>
而如果您的 Python 解释器在编译时没有启用 Tkinter,导入过程将失败。
>>> import Tkinter
Traceback (innermost last):
File "<stdin>", line 1, in ?
File "/usr/lib/python1.5/lib-tk/Tkinter.py", line 8, in ?
import _tkinter # If this fails your Python may not be configured for Tk
ImportError: No module named _tkinter
这时您不得不重编译 Python 解释器来访问 Tkinter。这通常会涉及编辑 Modules/Setup 文件和
启用所有正确选项来编译您的 Python 解释器,以确保 Tkinter 能被选择安装在系统中。请检查您
Python 发行包中的 README 文件,里面有把 Tkinter 编译进系统的操作说明。请确定您编译完后启动
的是刚刚创建的新 Python 解释器,否则它会像那个旧的不含 Tkinter 的解释器一样工作(实际上,
它就是您那个旧解释器)。
19.1.3 客户端/服务器架构
在之前介绍的网络编程中,我们介绍了客户端/服务器计算模式的概念。窗口系统就是软件服务
器的另一个例子,它们运行在一个有显示设备的机器上,比如带有一个某种类型的显示器。当然还
有客户端(那些需要窗口环境来运行的程序,也就是我们所说的 GUI 程序)                                ,这些程序无法脱离窗口


系统单独运行。
这种架构混合网络应用将显得更加有趣。通常一个 GUI 程序被执行时会在启动它的机器上显示
(通过窗口服务器),但也可以在一些网络化的窗口环境中(例如 Unix 的 X Window 系统)选择其它
机器的窗口服务器去显示。这样,您就可以在一台机器上运行 GUI 程序而在另一台机器上显示它!
19.2   Tkinter 与 Python 编程
19.2.1 Tkinter 模块:把 Tk 引入您的程序
为了让 Tkinter 成为您程序的一部分,      应该怎么做呢?这并不是说您一定要先有一个应用程序。
只有您愿意,当然可以创建一个纯粹的 GUI 程序,但如果没有让人感兴趣的功能的话,这个程序也
许不会很有用。
要创建并运行您的 GUI 程序,下面五步是基本的:
1. 导入 Tkinter 模块(import Tkinter,或者,from Tkinter import *)。
2. 创建一个顶层窗口对象,来容纳您的整个 GUI 程序。
3. 在您的顶层窗口对象上(或者说在“其中”)创建所有的 GUI 模块(以及功能)。
4.  把这些 GUI 模块与底层程序代码相连接。
5. 进入主事件循环。
第一步很明显:所有使用 Tkinter 的 GUI 程序必须先导入 Tkinter 模块。第一步就是为了获得
Tkinter 的访问权(参加 19.1.1 小节)。
19.2.2   GUI 程序开发简介
在举例之前,我们将先从宏观上来给您简单介绍一下 GUI 程序开发。这将给您以后的学习提供
一些必要的背景知识。
创建 GUI 程序与画家作画有些相似。通常画家只会在一块画布上开展自己的创作。工作步骤或
许是这样的:首先要找来一块干净的石板,您将在这个“顶层”窗口对象上创建所有其他模块。可
以把这一步想象成一座房屋的地基或者某个画家的画架。换言之,在搭建各实物或展开画布之前,
您必须先给地基浇灌好混凝土或者架好画架。对 Tkinter 而言,这个基础被称为顶层窗口对象。
在 GUI 程序中,会有一个顶层根窗口对象,它包含着所有小窗口对象,它们共同组成一个完整
的 GUI 程序。这些小窗口对象可以是文字标签、按钮、列表框等等。这些独立的 GUI 构件就是所谓
的组件。所以当我们说创建一个顶层窗口的时候,我们实际上是指您需要一个放置所有组件的地方。


典型的 Python 语句如下行:
top = Tkinter.Tk() # 如果上文是“from Tkinter import *",Tk()就够了
Tkinter.Tk()返回的对象通常被称作根窗口,正因为如此,有些程序用 root 来指示它,而非 top。
顶层窗口是指那些在您的程序中独立显示的部分。您可以在 GUI 程序中创建多个顶层窗口,但它们
中只能有一个是根窗口。您可以采用先完全设计好组件再添加实际功能的开发方式,也可以二者同
时进行。(这意味着交替执行上述五步中的第三步和第四步。)
组件既可以是独立的也可以作为容器存在。如果一个组件“包含”其他组件,它就被认为是这
些组件的父组件。相应地,如果一个组件被“包含”在其他组件中,它就被认为是父组件的孩子,
父组件则是直接包围其外的那个容器组件。
通常,组件会有一些相应的行为,例如按钮被按下,或者文本框被写入。这种形式的用户行为
被称为事件,而 GUI 程序对事件所采取的响应动作被称为回调。
用户操作包括按下(以及释放)按钮、移动鼠标、按下 RETURN 或 Enter 键等等,所有的这些从
系统角度都被看作事件。GUI 程序正是由这伴随其始末的整套事件体系所驱动的。这个过程被称作事
件驱动处理。
一个事件及其回调的例子是鼠标移动。我们假设鼠标指针停在您 GUI 程序的某处。如果鼠标被
移到了程序的别处,一定是有什么东西引起了屏幕上指针的移动,从而表现这种位置的转移。系统
必须处理这些鼠标移动事件才能展现(并实现)鼠标在窗口上的移动。一旦您释放了鼠标,就不再
会有事件需要处理,相应地,屏幕上的一切又复归平静。
GUI 程序的事件驱动特性恰好体现出它的客户端/服务器架构。当您启动一个 GUI 程序时,它必
须执行一些初始化例程来为核心功能的运行做准备,正如启动一个网络服务器时必须先申请一个套
接字并把它绑定在一个本地地址上一样。Tk 有两个坐标管理器用来协助把组件放在正确的位置上;
您将经常用到的一个称为“包”,亦即 packer。另一个坐标管理器是网格(Grid)--您可以用它来把
GUI 组件放在网格坐标系中,Grid 将依据 GUI 中的网格坐标来生成每个对象。我们将紧扣 packer 讲
解。
一旦 packer 决定好您所有组件的尺寸和对齐方式,它将为您在屏幕上放置它们。当所有这些组
件,包括顶层窗口,最终显示在您屏幕上时,GUI 程序就会进入一个“服务器式”的无限循环。这个
无限循环包括等待 GUI 事件、处理事件、然后返回等待模式,等待下一个事件。
上述最后一步说明所有组件就绪后立即进入主循环。这正是我们提及的“服务器式”无限循环。
对 Tkinter 而言,相应代码如下:
Tkinter.mainloop()


这通常是您程序执行的最后一段代码。一旦进入主循环,GUI 便从此掌握控制权。所有其他动作
都来自回调函数,包括程序退出。当您拉下文件菜单点击“退出”菜单项或直接关闭窗口时,必须
要唤起一个回调来结束您的程序。
19.2.3 顶层窗口:Tkinter.Tk()
我们前面提到所有的主要组件都建立在顶层窗口对象内。这个对象是由 Tkinter 中的 Tk 类创建
的,并且是由普通构造函数创建的:
>>> import Tkinter
>>> top = Tkinter.Tk()
在这个窗口中,您可以放置独立组件或集成的模块来构建您的 GUI。那么,都有哪些组件可用呢?
我们下面就来介绍 Tk 组件。
19.2.4     Tk 组件
Tk 目前有 15 种组件。我们在表 19.1 中列出了它们。
我们不准备对所有 Tk 组件都一一详细讲解,因为已经有许多关于它们的很好的文章可供参考--
不论是从 Python 网站的 Tkinter 主题页面还是数量可观的 Tcl/Tk 印刷品,抑或是在线资源(其中
一些可以在附录 B 中找到)。然而,我们将讲解一些例子来帮您启航。
核心注释:缺省参数是您的朋友
GUI 开发从 Python 的缺省参数机制获益匪浅,因为 Tkinter 组件有大量的默认动作。除非您熟
知自己使用的每一个组件的每一个可用选项,否则最好只设置您关心的参数而把其他的交由系统处
理。这些缺省值是精心选出的。
如果您没有提供这些值也不必担心程序会在屏幕上表现怪异。作为一条基本规则,程序都由一
系列经优化的缺省值创建,并且只有当您明确知道如何配置您的组件时,才有必要用自己的值替换
这些缺省值。
组件      描述
Button 按钮。类似标签,但提供额外的功能,例如鼠标掠过、按下、释放以及键盘操作/事件
Canvas 画布。提供绘图功能(直线、椭圆、多边形、矩形);可以包含图形或位图
Checkbutton 选择按钮。一组方框,可以选择其中的任意个(类似 HTML 中的 checkbox)
Entry   文本框。单行文字域,用来收集键盘输入(类似 HTML 中的 text)
Frame   框架。包含其他组件的纯容器


Label    标签。用来显示文字或图片
Listbox 列表框。一个选项列表,用户可以从中选择
Menu     菜单。点下菜单按钮后弹出的一个选项列表,用户可以从中选择
Menubutton 菜单按钮。用来包含菜单的组件(有下拉式、层叠式等等)
Message 消息框。类似于标签,但可以显示多行文本
Radiobutton 单选按钮。一组按钮,其中只有一个可被“按下”(类似 HTML 中的 radio)
Scale    进度条。线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值
Scrollbar    滚动条。对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能
Text     文本域。多行文字区域,可用来收集(或显示)用户输入的文字(类似 HTML 中的 textarea)
Toplevel     顶级。类似框架,但提供一个独立的窗口容器。
<------------------------------------------------------------------------------
例 19.1 标签组件演示(tkhello1.py)
我们的第一个 Tkinter 例子是......还能是什么呢?“Hello World!”具体地说,是介绍我们
的第一个组件:标签。
1 #!/usr/bin/env python
2
3 import Tkinter
4
5 top = Tkinter.Tk()
6 label = Tkinter.Label(top, text='Hello World!')
7 label.pack()
8 Tkinter.mainloop()
------------------------------------------------------------------------------>
19.3    Tkinter 举例
19.3.1 标签组件
在例 19.1 中,我们展示了 Tkinter 版的“Hello World!" -- tkhello1.py。实际上,它利用组
件向您展示了如何创建一个 Tkinter 应用程序。
第一行,我们先创建了一个顶层窗口。随后是写着那串举世闻名的字符的标签组件。我们指明
用 packer 来管理和显示组件,并最终调用 mainloop()来运行 GUI 程序。图 19-1 展示了运行该 GUI
程序后,您将会看到的效果。


19.3.2 按钮组件
第二个例子和第一个很相似。但我们这次将创建一个按钮而不只是显示一个简单的文字标签。
例 19.2 是 tkhello2.py 的源码。
<------------------------------------------------------------------------------
Unix (twm)                  Windows
图 19–1       Tkinter Label widget
(tkhello1.py)
例 19.2 按钮组件演示(tkhello2.py)
本例和 tkhello1.py 完全相同,除了我们创建的是按钮组件而非标签组件。
1 #!/usr/bin/env python
2
3 import Tkinter
4
5 top = Tkinter.Tk()
6 quit = Tkinter.Button(top, text='Hello World!',
7 command=top.quit)
8 quit.pack()
9 Tkinter.mainloop()
------------------------------------------------------------------------------>
前面几行是相同的。不同的只是我们创建的是按钮组件。我们的按钮有一个额外的参数,
Tkinter.quit()方法。这将给我们的按钮安装一个回调函数,在按钮按下(并释放)后让整个程序
退出。最后的两行是通常的 pack()和进入 mainloop()。这个简单的按钮应用程序展示在图 19-2 中。
19.3.3 标签和按钮组件
我们把 tkhello1.py 和 tkhello2.py 组合到 tkhello3.py 中,得到一个同时包含标签和按钮的
脚本。另外,我们现在还使用了更多的参数,而不再满足于完全使用那些自动添入的缺省参数。例


19.3 给出了 tkhello3.py 的源码。
除了对组件新加的参数,我们还看到对 packer 的一些参数。fill 参数告诉 packer 让 QUIT 按钮
填充水平方向的剩余空间,而 expand 参数则引导 packer 填充了水平方向的所有可视空间,并拉伸
按钮到达窗口的左右边界。
<------------------------------------------------------------------------------
Unix                            Windows
图 19–2 Tkinter Label widget (tkhello1.py)
例 19.3 标签和按钮组件演示(tkhello3.py)
本例同时展示了标签和按钮组件。既然我们已经了解了按钮组件和如何配置它,我们就可以设
置的更多一些,而不必像以前那样大都使用缺省参数。
1 #!/usr/bin/env python
2
3 import Tkinter
4 top = Tkinter.Tk()
5
6 hello = Tkinter.Label(top, text='Hello World!')
7 hello.pack()
8
9 quit = Tkinter.Button(top, text='QUIT',
10 command=top.quit, bg='red', fg='white')
11 quit.pack(fill=Tkinter.X, expand=1)
12
13 Tkinter.mainloop()
------------------------------------------------------------------------------>
正如您在图 19-3 中看到的,对 packer 没有其他指令时,组件是按垂直顺序放置的(依次放在
其他组件的上面)。要水平放置则需要创建一个框架对象,再用它来添加按钮。作为父对象的唯一子
对象,框架将占据父对象的空间(参见 19.3.6 小节例 19.6 中 listdir.py 模块对按钮的处理)。


<------------------------------------------------------------------------------
Unix                   Windows
图 19–3       Tkinter Label and Button
widgets (tkhello3.py)
------------------------------------------------------------------------------>
19.3.4 标签、按钮和进度条组件
我们的最后一个小例子 tkhello4.py,增加了一个进度条组件。具体来说,这个进度条是用来和
标签组件交互的。进度条的滑块被用作控制标签组件文本大小的工具。滑块的位置值越大字体就越
大,反之亦然,越小的位置值意味着越小的字体。例 19.4 展示了 tkhello4.py 的源码。
<------------------------------------------------------------------------------
例 19.4 标签,按钮和进度条组件演示(tkhello4.py)
我们最后一个组件例子介绍了进度条组件,重点放在组件间通过回调函数的交互[诸如
resize()]。您对进度条组件的动作将影响标签组件上的文字。
1    #!/usr/bin/env python
2
3    from Tkinter import *
4
5    def resize(ev=None):
6        label.config(font='Helvetica -%d bold' % \
7    scale.get())
8
9    top = Tk()
10   top.geometry('250x150')
11
12   label = Label(top, text='Hello World!',
13        font='Helvetica -12 bold')


14  label.pack(fill=Y, expand=1)
15
16  scale = Scale(top, from_=10, to=40,
17       orient=HORIZONTAL, command=resize)
18  scale.set(12)
19  scale.pack(fill=X, expand=1)
20
21  quit = Button(top, text="QUIT",
22       command=top.quit, activeforeground='white',
23       activebackground='red')
24  quit.pack()
25
26  mainloop()
------------------------------------------------------------------------------>
这段脚本新增加的 resizing()回调函数(5-7 行)附加在进度条组件上。这段代码在进度条的
滑块被移动时激活,调整标签里文字的大小。
我们还限定了顶层窗口的尺寸(250×150)(第 10 行)。这段脚本和前 3 段的最后一个不同点
是用“from Tkinter import *”把 Tkinter 模块的属性引入我们的名字空间。虽然不建议这样做,
因为这会“污染”您的名字空间,但这个程序涉及大量对 Tkinter 属性的引用,这正是我们这样做
的主要原因。这种方式(译者注:原文这里表达的不够清晰,本意是指 import Tkinter 的方式)
要求访问每个属性时都使用它们的全部限定性名称。而通过这种不被推荐的快捷方式,我们可以在
访问属性时减少输入并且让代码易于理解,但同时也付出了一些代价。
正如您在图 19-4 所看到的,滑块装置及当前位置值都显示在窗口的显著位置。图 19-4 展示了
用户把进度条/滑块移动到 36 时的 GUI 程序状态。
<------------------------------------------------------------------------------
Unix


Windows
图 19–4      Tkinter Label, Button, and Scale
widgets (tkhello4.py)
------------------------------------------------------------------------------>
从代码中可以看出,进度条的初始值在程序启动时被设置为 12(第 18 行)。
19.3.5 偏函数应用举例
在看更大的 GUI 程序之前,我们先回顾一下第 11 章 11.7.3 节介绍的偏函数应用(PFA)。
Python2.5 新增了 PFA 等一系列新特性,它们显著提高了 Python 对函数编程的支持。
偏函数允许您“预存”一些函数变量并有效的“冻结”了这些预定参数,在运行时您获得了所
需的其他变量后再把它们“解冻”出来,用这些最终确定的参数去调用函数。
最妙的是,PFA 不仅仅局限于函数。它们对任何“可调用”的东西都有效,任何有函数接口的对
象,比如类、方法、或可调用对象,只要是有括号的。对于有许多待调对象并且许多调用都反复使
用相同参数的情况,用 PFA 是最合适不过的。
GUI 编程有很好的操作环境,因为很有可能您需要 GUI 组件有某些一致的外观和体验,而这些一
致性表现在可以使用相同的参数创建相似的对象。我们现在要展示的应用程序中,将有多个按钮有
着相同的前景色和背景色。对这些仅有细小差别的按钮,每次调相同的构造函数作初始化时都输入
些相同的参数实在是一种浪费:前景和背景色都一样,只是文字有细小差别。
我们将用交通指示牌作为例子,程序中尝试创造一种文字型的交通指示牌,并且把它们分成如
下几类:危急、警告、通知(正好和日志信息级别相)                            。指示牌的类型决定了它们在创建时的颜色格
局。例如,危急指示牌使用亮红文字和白色背景,警告指示牌使用黑色文字和金色背景,通知也就
是普通指示牌使用黑色文字和白色背景。我们约定“Do Not Enter”和“Wrong Way”标识为危急,
“Merging Traffic”和“Railroad Crossinig”标识为警告,“Speed Limit”和“One Way”标识


为通知。该程序创造“指示牌”,它们都只是些按钮。当用户点下按钮时,将简单的弹出一个 Tk 响
应对话框,显示危急/错误、警告、通知。这的确不够好玩,但如何创建这些按钮却很有趣。您将在
例 19.5 看到这里所描述的程序。
<------------------------------------------------------------------------------
例 19.5 运用 PFA 的路灯指示牌 GUI 程序(pfaGUI2.py)
按照指示类型创建适当前景、背景色的路灯指示牌。使用 PFA 帮助“模板化”常用 GUI 参数。
1    #!/usr/bin/env python
2
3    from functools import partial as pto
4     from Tkinter import Tk, Button, X
5     from tkMessageBox import showinfo, showwarning, showerror
6
7     WARN = 'warn'
8     CRIT = 'crit'
9     REGU = 'regu'
10
11    SIGNS = {
12 'do not enter': CRIT,
13 'railroad crossing': WARN,
14    '55\nspeed limit': REGU,
15    'wrong way': CRIT,
16    'merging traffic': WARN,
17    'one way': REGU,
18    }
19
20    critCB =  lambda: showerror('Error', 'Error Button Pressed!')
21    warnCB =  lambda: showwarning('Warning',
22    'Warning  Button Pressed!')
23    infoCB =  lambda: showinfo('Info', 'Info Button Pressed!')
24
25    top = Tk()
26    top.title('Road Signs')
27    Button(top, text='QUIT', command=top.quit,
28    bg='red', fg='white').pack()
29
30    MyButton = pto(Button, top)
31    CritButton = pto(MyButton, command=critCB, bg='white', fg='red')


32   WarnButton = pto(MyButton, command=warnCB, bg='goldenrod1')
33   ReguButton = pto(MyButton, command=infoCB, bg='white')
34
35   for eachSign in SIGNS:
36   signType = SIGNS[eachSign]
37   cmd = '%sButton(text=%r%s).pack(fill=X, expand=True)' % (
38   signType.title(), eachSign,
39   '.upper()' if signType == CRIT else '.title()')
40   eval(cmd)
41
42   top.mainloop()
图 19–5 Road signs PFA GUI application on XDarwin in
MacOS X (pfaGUI2.py)
------------------------------------------------------------------------------>
当您执行这个程序时,会看到一个类似图 19.5 的 GUI。
逐行注解
1-18 行
作为开始,我们导入了 functional.partial()、一些 Tkinter 属性以及 Tk 对话框(1-5 行)。
然后,我们定义了一些标识及其相应类型。
20-28 行
Tk 对话框被关联到按钮回调函数,我们将在创建按钮时使用它们(20-23 行)                                 。然后加载 Tk,设
置标题,并创建了一个 QUIT 按钮(25-28 行)。
30-33 行


这些行展示了 PFA 的魔力。我们通过两个步骤实现 PFA。第一步是模板化的按钮类及根窗口 top。
这样当每次我们调用 MyButton 时,它会转而调用 Button(Tkinter.Button()创建了一个按钮)并使
用 top 作为其第一个参数。我们把这一切“冻结”在了 MyButton 里。
PFA 的第二步使用了第一步的结果--MyButton--并再次对它模板化。我们对每个不同的指示类型
都创建了单独类型的按钮。当用户创建一个危急按钮 CritButton 时(通过调用 CritButton()),它
会转而调用 MyButton 并使用恰当的按钮回调和前景、背景色参数,这意味着用 top、按钮回调、前
景、后景去调用 Button。您看出它是如何展开并逐步调用低层直到按钮组件了吗?如果没有 PFA 这
个特性,它执行的那些调用本该由您自己执行。我们把同样的步骤应用到 WarnButton 和 ReguButton
上。
35-42 行
按钮类创建过程结束后,我们遍历了指示列表并创建出指示牌。我们使用了一个 Python 求值字
串,它由正确的按钮名字、作为按钮标签传入的 text 参数组成,然后再 pack()一下。如果这是个危
急指示牌,我们就把按钮文字全转成大写,否则的话就以标题形式显示。最后一步在第 39 行完成,
同时也展示了 Python2.5 引入的另一个特性,临时操作符。随后我们对每一个按钮创建字串施以
eval(),每次创建一个按钮,最终形成了前面看到的图形。最后我们进入主事件循环,启动 GUI。
这个应用程序使用了一些 Python2.5 的新特性,所以您不能在旧版上运行它。
19.3.6 中级 Tkinter 范例
我们以一个比较大型的例子来总结本节,listdir.py。这个应用程序是一个目录树遍历工具。
它从当前目录开始并提供文件列表功能。双击列表中的任意其他目录都会让该工具转向这个新的目
录,同时用新目录中的文件列表替换原有的文件列表。源码作为例 19.6 给出。
<------------------------------------------------------------------------------
例 19.6 GUI 文件遍历系统 (listdir.py)
这个稍高级一些的 GUI 程序扩大了组建的使用范围,演员名单里新增了列表框、文本框、和滚
动条。而且还有大量的回调函数,例如鼠标点击、键盘输入、和滚动条操作。
1 #!/usr/bin/env python
2
3 import os
4 from time import sleep
5 from Tkinter import *
6
7 class DirList(object):


8
9   def __init__(self, initdir=None):
10          self.top = Tk()
11          self.label = Label(self.top,
12                               text='Directory Lister v1.1')
13          self.label.pack()
14
15         self.cwd = StringVar(self.top)
16
17         self.dirl = Label(self.top, fg='blue',
18                               font=('Helvetica', 12, 'bold'))
19          self.dirl.pack()
20
21         self.dirfm = Frame(self.top)
22         self.dirsb = Scrollbar(self.dirfm)
23          self.dirsb.pack(side=RIGHT, fill=Y)
24          self.dirs = Listbox(self.dirfm, height=15,
25                               width=50, yscrollcommand=self.dirsb.set)
26        self.dirs.bind('<Double-1>', self.setDirAndGo)
27        self.dirsb.config(command=self.dirs.yview)
28        self.dirs.pack(side=LEFT, fill=BOTH)
29        self.dirfm.pack()
30
31          self.dirn = Entry(self.top, width=50,
32          textvariable=self.cwd)
33          self.dirn.bind('<Return>', self.doLS)
34          self.dirn.pack()
35
36          self.bfm = Frame(self.top)
37          self.clr = Button(self.bfm, text='Clear',
38                               command=self.clrDir,
39                               activeforeground='white',
40                               activebackground='blue')
41          self.ls = Button(self.bfm,
42                               text='List Directory',
43                               command=self.doLS,
44                               activeforeground='white',
45                               activebackground='green')
46          self.quit = Button(self.bfm, text='Quit',
47                               command=self.top.quit,


48                            activeforeground='white',
49                            activebackground='red')
50       self.clr.pack(side=LEFT)
51       self.ls.pack(side=LEFT)
52       self.quit.pack(side=LEFT)
53       self.bfm.pack()
54
55       if initdir:
56           self.cwd.set(os.curdir)
57           self.doLS()
58
59   def clrDir(self, ev=None):
60       self.cwd.set('')
61
62   def setDirAndGo(self, ev=None):
63       self.last = self.cwd.get()
64       self.dirs.config(selectbackground='red')
65       check = self.dirs.get(self.dirs.curselection())
66     if not check:
67         check = os.curdir
68     self.cwd.set(check)
69     self.doLS()
70
71  def doLS(self, ev=None):
72      error = ''
73   tdir = self.cwd.get()
74   if not tdir: tdir = os.curdir
75
76   if not os.path.exists(tdir):
77       error = tdir + ': no such file'
78   elif not os.path.isdir(tdir):
79       error = tdir + ': not a directory'
80
81   if error:
82          self.cwd.set(error)
83          self.top.update()
84          sleep(2)
85          if not (hasattr(self, 'last') \
86           and self.last):
87           self.last = os.curdir


88           self.cwd.set(self.last)
89           self.dirs.config(\
90           selectbackground='LightSkyBlue')
91           self.top.update()
92           return
93
94       self.cwd.set(\
95           'FETCHING DIRECTORY CONTENTS...')
96       self.top.update()
97       dirlist = os.listdir(tdir)
98       dirlist.sort()
99       os.chdir(tdir)
100      self.dirl.config(text=os.getcwd())
101      self.dirs.delete(0, END)
102      self.dirs.insert(END, os.curdir)
103      self.dirs.insert(END, os.pardir)
104      for eachFile in dirlist:
105          self.dirs.insert(END, eachFile)
106        self.cwd.set(os.curdir)
107        self.dirs.config(\
108            selectbackground='LightSkyBlue')
109
110 def main():
111 d = DirList(os.curdir)
112 mainloop()
113
114 if __name__ == '__main__':
115 main()


Windows
图 19–6 List directory GUI application in Windows (listdir.py)
------------------------------------------------------------------------------>
在图 19-6 中,我们展示了 Windows 环境中的 GUI 外观。
这个程序的 Unix 版本在图 19-7 中展示。
逐行注解
1-5 行
开始的几行包括通常的 Unix 启动行和导入 os 模块、time.sleep 函数、及 Tkinter 模块的所有
属性。
9-13 行
这些行定义了 DirList 类的构造函数,以及一个代表我们程序的对象。我们创建的第一个标签
包含了应用程序的主标题和它的版本号。


<------------------------------------------------------------------------------
Unix
图 19–7       List directory GUI application in Unix
(listdir.py)
------------------------------------------------------------------------------>
15-19 行
我们声明了一个名为 cwd 的 Tk 变量来保存当前所在目录的名字--我们马上就会看到这个值从哪
来。还创建了另一个标签来显示当前目录的名字。
21-29 行
这段代码定义了我们这个 GUI 程序的核心,dirs(列表框)包含了被列目录的文件列表。使用
一个滚动条以便用户在文件数目超过列表框窗口尺寸时移动列表。这两个组件都被包含在一个框架
组件中。列表框用 bind()方法把回调函数(setDirAndGo)和列表项绑定起来。
绑定意味着把一个回调函数连接在键盘输入、鼠标动作、或其他什么事件上,当这个事件被用
户触发时就会执行这个回调函数。当列表框中的任一项被双击时 setDirAndGo()函数就会被调用。滚
动条被 Scrollbar.config()方法贴附在列表框上。
31-34 行
随后我们创建了一个文本框让用户输入目录名,以便转到他/她想去的目录,并在列表框中显示
该目录中的文件。我们为该文字输入区加入了一个 RETURN 或 Enter 键的绑定,这样用户就能用敲
RETURN 的方法代替按钮点击,同样的事也会发生在上面提到的列表框中。当用户双击列表项时,效


果等同于用户在文本框中输入目录名然后点击“go”按钮。
36-53 行
接下来我们定义了一个按钮框架(bfm)来保管这三个按钮:一个“clear”按钮(clr),一个
“go”按钮(ls)     ,和一个“quit”按钮(quite)     。每一个按钮都有各自不同的配置和点击时的回调
函数。
55-57 行
构造函数的最后一部分初始化了这个 GUI 程序,程序将从当前工作目录开始。
59-60 行
clrDir()方法清空 Tk 字符串变量 cwd,其中保存着当前的“活动”目录。这个变量用来跟踪我
们当前所处的目录,更重要的是,在错误发生时协助返回上一个目录。您一定注意到了回调函数中
的 ev 参数的缺省值是 None。这样的任意值都可能由窗口系统传回,它们在您的回调函数里可以用也
可以不用。
62-69 行
setDirAndGo()方法设置了要到达的目录并产生一个对 doLS()方法的调用,后者负责实现其余的
一切。
71-108 行
现在看来,doLS()是整个 GUI 程序的关键。它负责所有的安全性检查(目标是否是一个目录以
及它是否存在?)如果有错误发生,最终目录会被设置为当前目录。如果一切正确,它调用
os.listdir()来取得新的文件集合并替换列表框中的列表。当后台忙于获取新目录信息时,高亮的
蓝色条会变成亮红色。当新目录设置完毕,它会恢复蓝色。
110-115 行
listdir.py 中的最后一段代码明显是代码的主体。main()函数只有在该脚本被直接调用时才会
执行,并且当它执行时会创建 GUI 程序,后者随之掌控该程序。
我们把该程序的所有其他方面都留给读者作为练习,再次提醒您,把整个程序看成是一系列组
件和功能的组合,一切就都会简单起来。如果您清楚的知道每个单独程序段的意思,那么整个脚本
就不会再显得可怕了。
但愿我们给了您一个够好的关于 Python 和 Tkinter 的 GUI 编程介绍。请记住熟悉 Tkinter 编程
最好的方法就是实践和模仿一些例子!Python 发行包附带了很多可供您学习的应用程序范例。
如果您下载了源码包,就会在 Lib/lib-tk、Lib/idlelib、和 Demo/tkinter 下发现 Tkinter 的
演示代码。如果您把 Win32 版本的 Python 安装在 C:\Python2.x,那么可以在 Lib\lib-tk 和
Lib\idlelib 下找到这些演示代码。最后那个目录包含了最出名的 Tkinter 例子程序:IDLE


IDE 本身。还有一些关于 Tk 编程的书籍供进一步参考,其中一本是专为 Tkinter 编写的。
19.4 其他 GUI 简介
我们期望最终能编写出独立的一章来对 GUI 编程作总体介绍,Python 拥有的大量图形工具集中
有很多内容值得一讲,然而,这只能是以后的事了。作为替代,我们将使用其中 4 种比较流行且可
用的工具集来编写同一个 GUI 程序示例:Tix(Tk Interface eXtensions)、Pmw(Python MegaWidgets
的 Tkinter 扩展)、wxPython(wxWidgets 的 Python 绑定)        、和 PyGTK(GTK+的 Python 绑定)。您可
以在本章末尾参考部分获取更多信息和下载这些工具集的地方。
Tix 模块包含在 Python 标准库中,已经可用了。其他工具集是第三方的,你必须自己下载。因
为 Pmw 只是对 Tkinter 的一个扩展,它的安装是最简便的(只需解压到您的网络包目录下)。wxPython
和 PyGTK 涉及下载多个文件并编译(除非您使用的是 Win32 版本,这样的话通常有安装包可用)                                 。一
旦这些工具集安装好并通过证,我们就能开始了。我们不打算局限在本章已经讲过的那些组件上,
我们准备在后面的例子中介绍一些更复杂的组件。
除过我们已经看到过的标签和按钮组件,我们准备介绍控制按钮(Control, 又叫微调按钮,
SpinButton)和组合框组件(ComboBox)。控制组件是一个文本组件和一对箭头按钮的组合,文本
值受旁边按钮的“控制”或者说“旋上、旋下”,而组合框则通常包括一个文本组件和一个下拉菜
单,菜单项列表中当前激活或选中的项目将显示在文本组件中。
我们的应用程序相当简单:成对的动物要被搬走,动物的总数在从一对到一打(译者注:12 只)
的范围内。用控制组件来显示总数,用组合框显示动物种类列表菜单供用户选择。注意默认的动物
数量是 2,且没有选择动物类型。
一旦我们开始执行这个程序,事物就变得不同了,图 19-9 就是例证,它显示的是在 Tix 程序中
改变一些元素后的结果。
下面,您将看到所有 4 个版本的 GUI 程序代码。您会发现尽管它们有些相似,但每一个都有自
己的特别之处。而且我们使用.pyw 作为文件后缀,这样可以防止弹出 Dos 命令窗口或终端窗口。
<------------------------------------------------------------------------------
Tix                           pygtk


Pmw                            wxPython
图 19–8      Application using various GUIs under Win32 (animal*.pyw)
Tix
图 19–9      After modifying the Tix GUI version of our application (animalTix.pyw)
------------------------------------------------------------------------------>
19.4.1    Tk Interface eXtensions (Tix)
我们从一个使用 Tix 模块的例子(19.7)开始。Tix 是对 Td/T(译者注:应该是 Tcl/Tk)的一
个扩展库,其中增加了许多新的组件、图像类型和其它一些命令,提高 Tk 作为 GUI 开发工具集的可
用性。我们现在来看看如何在 Python 中使用 Tix。
<------------------------------------------------------------------------------
Tix GUI 编程演示(animalTix.pyw)
我们的第一个例子使用 Tix 模块。Tix 已经是 Python 的一部分了!
1    #!/usr/bin/env python
2
3    from Tkinter import Label, Button, END
4    from Tix import Tk, Control, ComboBox
5
6    top = Tk()
7    top.tk.eval('package require Tix')
8
9    lb = Label(top,
10   text='Animals (in pairs; min: pair, max: dozen)')


11 lb.pack()
12
13 ct = Control(top, label='Number:',
14 integer=True, max=12, min=2, value=2, step=2)
15 ct.label.config(font='Helvetica -14 bold')
16 ct.pack()
17
18 cb = ComboBox(top, label='Type:', editable=True)
19 for animal in ('dog', 'cat', 'hamster', 'python'):
20 cb.insert(END, animal)
21 cb.pack()
22
23 qb = Button(top, text='QUIT',
24 command=top.quit, bg='red', fg='white')
25 qb.pack()
26
27 top.mainloop()
------------------------------------------------------------------------------>
逐行注解
1-7 行
这里都是些初始化代码,模块导入操作,以及基本的 GUI 操作。第 7 行的断言要求程序可以使
用 Tix 模块。
8-27 行
这些行创建了所有的组件:标签(9-11 行)、控制(13-16 行)、组合框(18-21 行)                            、以及退出
按钮(23-25 行)。组件构造函数里的参数都很浅显明了无需更多解释。最后,我们在第 27 行进入
GUI 主事件循环。
19.4.2     Python MegaWidgets (PMW)
下面通过例 19.8 让我们来看看 Python MegaWidgets。这个模块体现了 Tkinter 悠久的历史。它
基本上是通过在 GUI 工具集中添加一些新式的组件来延长 Tkinter 的寿命。
这个 Pmw 的例子和上面 Tix 的例子是如此的相似,以致我们不准备对读者逐行注解它。代码中
区别最大的一行是控制组件的构造函数,那个 Pmw 的控制组件。它提供了验证函数的入口。不同于
直接在组件构造函数中以关键字参数的形式传入最大、最小值,Pmw 使用“验证器”来确保值不会超


出我们可接受的范围。
现在我们终于要离开 Tk 的世界了。Tix 和 Pmw 分别扩展了 Tk 和 Tkinter,然而我们现在将改变
方向去看看完全不同的工具集,wxWidgets 和 GTK+。在使用这些现代的、健壮的 GUI 工具集时,您
将发现代码的行数增加了,这是因为我们使用了更多的面向对象特性。
19.4.3    wxWidgets 和 wxPython
wxWidgets(以前称作 wxWindows)是一个跨平台的工具集,用来构建图像用户程序。它用 C++
实现并在各种平台上广泛使用,wxWidgets 为这些平台定义了一致、通用的 API。wxWidgets 最大的
优点它在每个平台上都使用原生 GUI,所以您的程序将和所有其它桌面程序有相同的外观和用户体验。
另一个特点是您不会被局限于使用 C++开发 wxWidgets 应用程序。它有对 Python 和 Perl 的接口。例
19.9 使用 wxPython 展示了我们那个动物应用程序。
<------------------------------------------------------------------------------
Pmw GUI 程序演示(animalPmw.pyw)
我们的第二个例子使用 Python MegaWidgets 包。
1   #!/usr/bin/env python
2
3   from Tkinter import Button, END, Label, W
4    from Pmw import initialise, ComboBox, Counter
5
6    top = initialise()
7
8    lb = Label(top,
9    text='Animals (in pairs; min: pair, max: dozen)')
10   lb.pack()
11
12   ct = Counter(top, labelpos=W, label_text='Number:',
13             datatype='integer', entryfield_value=2,
14             increment=2, entryfield_validate={'validator':
15             'integer', 'min': 2, 'max': 12})
16   ct.pack()
17
18   cb = ComboBox(top, labelpos=W, label_text='Type:')
19   for animal in ('dog', 'cat', 'hamster', 'python'):
20   cb.insert(end, animal)
21   cb.pack()


22
23     qb = Button(top, text='QUIT',
24    command=top.quit, bg='red', fg='white')
25     qb.pack()
26
27     top.mainloop()
------------------------------------------------------------------------------>
逐行注解
5-37 行
这里我们先编写了一个框架类(5-8 行)                   ,它的唯一成员即其构造函数。这个方法的唯一实用目
的就是创建我们的组件。在框架组件中,我们创建了一个画板组件(panel)。在画板中我们用 BoxSizer
来包含所有其他组件并对其布局(第 10、36 行),这些组件是标签(12-14 行)、微调按钮(16-20
行)、列表框(22-27 行)和退出按钮(29-34 行)。
<------------------------------------------------------------------------------
wxPython GUI 程序演示(animalWx.pyw)
我们的第三个例子使用 wxPython(以及 wxWidgets)。注意我们把所有的组件都放在一个布局
管理器里,以及该程序中更多的面向对象本质。
1 #!/usr/bin/env python
2
3 import wx
4
5 class MyFrame(wx.Frame):
6      def __init__(self, parent=None, id=-1, title=''):
7          wx.Frame.__init__(self, parent, id, title,
8          size=(200, 140))
9          top = wx.Panel(self)
10             sizer = wx.BoxSizer(wx.VERTICAL)
11             font = wx.Font(9, wx.SWISS, wx.NORMAL, wx.BOLD)
12             lb = wx.StaticText(top, -1,
13                 'Animals (in pairs; min: pair, max: dozen)')
14             sizer.Add(lb)
15
16             c1 = wx.StaticText(top, -1, 'Number:')
17             c1.SetFont(font)
18             ct = wx.SpinCtrl(top, -1, '2', min=2, max=12)
19             sizer.Add(c1)


20           sizer.Add(ct)
21
22           c2 = wx.StaticText(top, -1, 'Type:')
23           c2.SetFont(font)
24          cb = wx.ComboBox(top, -1, '',
25           choices=('dog', 'cat', 'hamster','python'))
26           sizer.Add(c2)
27           sizer.Add(cb)
28
29           qb = wx.Button(top, -1, "QUIT")
30           qb.SetBackgroundColour('red')
31           qb.SetForegroundColour('white')
32           self.Bind(wx.EVT_BUTTON,
33               lambda e: self.Close(True), qb)
34           sizer.Add(qb)
35
36           top.SetSizer(sizer)
37           self.Layout()
38
39      class MyApp(wx.App):
40     def OnInit(self):
41         frame = MyFrame(title="wxWidgets")
42           frame.Show(True)
43           self.SetTopWindow(frame)
44           return True
45
46      def main():
47       app = MyApp()
48       app.MainLoop()
49
50      if __name__ == '__main__':
51       main()
------------------------------------------------------------------------------>
我们不得不手工为微调按钮和组合框组件添加标签,因为它们看起来并不包含标签。一旦我们
创建好这些,就把他们加到布局管理器中,再把布局管理器交给画板组件,并确定其中每个组件的
布局。您会注意到第 10 行说布局管理器是垂直走向的,这表明我们所有的组件都会按从上到下的顺
序排列。
微调按钮组件有一个弱点,它不支持“步进”功能。在其他 3 个例子中,我们可以点箭头按钮


让控制组件每次增加或减少 2,但对这个组件却不行。
39-51 行
我们的应用程序类实例化了一个刚才设计的框架对象,把它绘制在屏幕上,并设置成程序的顶
层窗口。最后,几行安装代码实例化了 GUI 应用程序对象并启动之。
19.4.4 GTK+ 和 PyGTK
最后是 PyGTK 版的例子,它和 wxPython GUI 程序非常相似(见例 19.10)                     。最大的不同是我们只
用一个类,还有那些设置对象--实际上就是按钮--前景、背景色的代码实在是很冗长。
逐行注解
1-6 行
我们导入了 3 个不同的模块和包,PyGTK、GTK 和 Pango。Pango 是一个用来布局和生成文本的库,
专用于实现 I18N。这里需要这个库是因为它体现了 GTK+(2.x)对文字和字体处理的核心思想。
<------------------------------------------------------------------------------
PyGTK GUI 程序演示(animalGtk.pyw)
我们最后一个例子使用 PyGTK(和 GTK+)               。类似 wxPython 的例子,这里对应用程序也用了一个
类。对比一下这两个 GUI 程序例子的相似和不同点是很有趣的。这种现象并不奇怪,它使得开发者
可以比较容易的转用其他工具集。
1 #!/usr/bin/env python
2
3 import pygtk
4 pygtk.require('2.0')
5 import gtk
6 import pango
7
8 class GTKapp(object):
9     def __init__(self):
10            top = gtk.Window(gtk.WINDOW_TOPLEVEL)
11            top.connect("delete_event", gtk.main_quit)
12            top.connect("destroy", gtk.main_quit)
13            box = gtk.VBox(False, 0)
14            lb = gtk.Label(
15                'Animals (in pairs; min: pair, max: dozen)')


16           box.pack_start(lb)
17
18           sb = gtk.HBox(False, 0)
19           adj = gtk.Adjustment(2, 2, 12, 2, 4, 0)
20           sl = gtk.Label('Number:')
21           sl.modify_font(
22               pango.FontDescription("Arial Bold 10"))
23           sb.pack_start(sl)
24           ct = gtk.SpinButton(adj, 0, 0)
25           sb.pack_start(ct)
26
27
28           cb = gtk.HBox(False, 0)
29           c2 = gtk.Label('Type:')
30           cb.pack_start(c2)
31           ce = gtk.combo_box_entry_new_text()
32           for animal in ('dog', 'cat','hamster', 'python'):
33               ce.append_text(animal)
34         cb.pack_start(ce)
35         box.pack_start(cb)
36
37         qb = gtk.Button("")
38           red = gtk.gdk.color_parse('red')
39          sty = qb.get_style()
40           for st in (gtk.STATE_NORMAL,
41               gtk.STATE_PRELIGHT, gtk.STATE_ACTIVE):
42               sty.bg[st] = red
43           qb.set_style(sty)
44           ql = qb.child
45           ql.set_markup('<span color="white">QUIT</span>')
46           qb.connect_object("clicked",
47               gtk.Widget.destroy, top)
48           box.pack_start(qb)
49           top.add(box)
50           top.show_all()
51
52 if __name__ == '__main__':
53       animal = GTKapp()
54       gtk.main()
------------------------------------------------------------------------------>


8-15 行
GTKapp 类反应了本程序中所有的组件。顶层窗口在这里创建(窗口管理器负责关闭它),而且还
创建了一个垂直走向的布局管理器(VBox)来掌管我们的主要组件。这些实际上和我们在 wxPython GUI
程序中作的一样。
然而,为了让微调按钮和组合框的静态文本能出现它们的左侧(wxPython 例子中出现在上方),
我们创建了小型的水平走向的方框来包括标签组件对(18-36 行),而且还把这些 HBox 完全置于 VBox
的掌控之下。
接下来我们创建了退出按钮并把 VBox 添加到顶层窗口中,然后把一切绘制到屏幕上。您一定注
意到我们刚开始用空标题创建了按钮。我们这样做是为了让标签(子)对象能作为按钮的一部分被
创建。在 45-46 行,我们取得标签的访问权并用白色字体设置了文字。
我们这样做的原因是如果您直接设置前景风格--通过 41-44 行的循环和辅助代码--那么前景只
会对按钮起作用而对其它--例如标签--却是无效的,假如您把前景设为白色并把焦点置在按钮上(通
过按 TAB 键可以“选中”它)        ,您将看到用来标识选中组件的内点画线是白色的,而标签文字却依然
是黑色的,除非您像我们在第 45 行那样改一下。
53-55 行
我们在这里创建了应用程序并进入主事件循环。
19.5 相关模块和其他 GUI
Python 还有一些其他的 GUI 开发系统。我们在表 19.2 中列出适当的模块及其对应的窗口系统。
表 19.2 Python 可用的 GUI 系统
GUI 模块或系统                 描述
Tk 相关模块
Tkinter           TK INTERface: Python 的默认 GUI 工具集
http://wiki.python.org/moin/TkInter
Pmw               Python MegaWidgets (Tkinter 扩展)
http://pmw.sf.net
Tix               Tk Interface eXtension (Tk 扩展)
http://tix.sf.net
TkZinc (Zinc)       Extended Tk canvas type (Tk 扩展)
http://www.tkzinc.org
EasyGUI (easygui)    非常简单的非事件驱动 GUI (Tkinter 扩展)
http://ferg.org/easygui


TIDE + (IDE Studio)      Tix 集成开发环境(包括 IDE Studio, 一个 Tix 加强版的标准 IDLE IDE)
http://starship.python.net/crew/mike
wxWidgets 相关模块
wxPython            Python 对 wxWidgets 的绑定,          一个跨平台的 GUI 框架库(早期称为 wxWindows)
http://wxpython.org
Boa Constructor           Python 集成开发环境兼 wxPython GUI 构造工具
http://boa-constructor.sf.net
PythonCard               基于 wxPython 的 GUI 桌面应用程序工具集(从 HyperCard 获得灵感)
http://pythoncard.sf.net
wxGlade                    另一个 wxPython GUI 设计工具 (从 Glade(GTK+/GNOME 的 GUI 构建
工具)受到启发)http://wxglade.sf.net
表 19.2 Python 可用的 GUI 系统(续)
GUI 模块或系统                    描述
GTK+/GNOME 相关模块
PyGTK                Python 对 GIMP 工具集(GTK+)的封装库 http://pygtk.org
GNOME-Python           Python 对 GNOME 桌面开发库的绑定
http://gnome.org/start/unstable/bindings
http://download.gnome.org/sources/gnome-python
Glade              一个针对 GTK+和 GNOME 的 GUI 构建工具
http://glade.gnome.org
PyGUI (GUI)          “Pythonic”式的跨平台 GUI 程序编程接口(MacOS X 中基于 Cocoa,
POSIX/X11         和          Win32  中     基          于     GTK+ )
http://www.cosc.canterbury.ac.nz/~greg/python_gui
Qt/KDE 相关模块
PyQt                 Trolltech 开发的 Python 对 Qt GUI/XML/SQL 工具集的绑定(双协议,部
分开源) http://riverbankcomputing.co.uk/pyqt
PyKDE                Python 对 KDE 桌面环境的绑定
http://riverbankcomputing.co.uk/pykde
eric Python           使用 QScintilla editor 组件编写的 PyQt 集成开发环境
http://die-offenbachs.de/detlev/eric3
http://ericide.python-hosting.com/
PyQtGPL                  包括 Qt(Win32 Cygwin 移植版)、Sip、QScintilla 和 PyQt 的工具包
http://pythonqt.vanrietpaap.nl
其他开源 GUI 工具集
FXPy                     Python 对 FOX 工具集的绑定 (http://fox-toolkit.org)
http://fxpy.sf.net


pyFLTK (fltk)           Python 对 FLTK 工具集的绑定 (http://fltk.org)
http://pyfltk.sf.net
PyOpenGL (OpenGL)        Python 对 OpenGL 的绑定 (http://opengl.org)
http://pyopengl.sf.net
表 19.2 Python 可用的 GUI 系统(续)
GUI 模块或系统                描述
商业软件
win32ui            Python 版的 Microsoft MFC (基于 Python 的 Windows 扩展)
http://starship.python.net/crew/mhammond/win32
swing             Python 版的 Sun Microsystems Java/Swing (基于 Jython)
http://jython.org
您还能从 Python 的 GUI 编程简介 wiki 页面 http://wiki.python.org/moin/GuiProgramming 上
找到更多有关 Python GUI 编程的东西。
19.6    练习
19–1.    客户端/服务器架构。请描述窗口服务器的角色和窗口客户端的角色。
19–2.   面向对象编程。请描述子窗口和父窗口的关系。
19–3.   标签组件。请修改 tkhello1.py 脚本,让它显示您自定义的消息而非“Hello World!”
19–4.    标签和按钮组件。请修改 tkhello3.py 脚本,除了 QUIT 按钮以外再新增 3 个按钮。
按下这 3 个按钮中的任意一个都将改变标签文字,显示被按下的按钮(组件)上的文字。
19–5. 标签、按钮和单选按钮组件。请对您上一问题的答案作修改,用 3 个单选按钮实现对
标签文字的选择。现在有两个按钮:QUIT 按钮和“更新”按钮。当更新按钮被按下时,标签里的文
字变成选中的单项按钮上的文字。如果没有选中任何单选按钮,则标签内容保持不变。
19–6. 标签、按钮和文本框组件。请对您上一问题的答案作修改,用一个单行的文本框组件
替换那 3 个单选按钮,文本框的默认值为“Hello World!”                  (和标签的初始字符串保持一致)。用户
可以编辑文本框,输入新的字符串,标签组件会在更新按钮被按下时显示这个新的字符串。
19–7. 标签、文本框组件及 Python I/O。创建包含一个文本框的 GUI 程序,用户可以在其中
输入一个文本文件名。打开该文件并读取,把其中的内容显示在标签组件上。附加题(菜单)                                    :把文
本框换成一个包含文件打开选项的菜单,它会弹出一个窗口供用户选择要读取的文件。再给菜单加
上一个 Exit 或 Quit 选项,这样就用不着 QUIT 按钮了。


19–8.   简单的文本编辑器。在您上一题答案的基础上创建一个简单的文本编辑器。可以用剪
贴板或读文件的方式在一个文本域里显示一些文字供用户编辑。当用户退出程序时(通过 QUIT 按钮
或 Quit/Exit 菜单项)会询问用户是否保存所作的修改。附加题:给您的脚本添加一个拼写检查接
口,增加一个按钮或菜单项来对文件进行拼写检查。拼写错误的词句应在文本域组件中用不同的背
景或前景色高亮显示出来。
19–9.   多线程聊天应用程序。第 13、16、17 章讲到的聊天程序可以完成了。创建一个全功
能的多线程聊天服务器。这个服务器其实并不需要有 GUI,除非您想给它创建一个前端配置界面,配
置诸如端口号、名称、到域名服务器的连接等。创建一个多线程的聊天客户端,使用单独的线程监
视用户输入(并以广播方式给服务器发送消息)                ,另一个线程用来接收消息并显示给用户。客户端的
GUI 聊天窗口应当由两部分组成:较大的部分用来多行显示所有的对话,较小的文本域用来接收用户
输入。
19–10.   使用其他 GUI。19.4 中的例子使用到了各种各样的工具集,这些 GUI 程序看起来很
相似;然而,它们并不完全一样。尽管不可能让所有的例子看起来完全一样,但请尽量调整它们,
让它们比现在看起来更一致些。
19–11.   使用 GUI 构建工具。下载 Boa Constructor(wxWidgets 平台)或 Glade(GTK+平台)
[或者都下载!],然后实现那个“动物”GUI 程序,只用从相应的工具栏拖拽一些组件就好了。给
您的新 GUI 加上回调函数,让它能有本章例子程序中我们所看到的那些行为。


Web 编程
本章主题
z 引言
z Python 的 Web 应用:简单的 Web 客户端
z urlparse 和 urllib 模块
z 高级的 Web 客户端
z 网络爬虫/蜘蛛/机器人
z CGI:帮助 Web 服务器处理客户端数据
z 创建 CGI 应用程序
z 在 CGI 中使用 Unicode
z 高级 CGI
z 创建 Web 服务器
z 相关模块


20.1 介绍
本章是有关 Web 编程的介绍,可以帮助你对出 Python 在因特网上的各种基础应用有个概要了
解,例如通过 Web 页面建立用户反馈表单,通过 CGI 动态生成输出页面
20.1.1  Web 应用:客户端/服务器计算
Web 应用遵循我们反复提到的客户端/服务器架构。这里,Web 的客户端是浏览器,应用程序允
许用户在万维网上查询文档。另外 Web 服务器端,进程运行在信息提供商的主机上。这些服务器等
待客户和文档请求,进行相应的处理,返回相关的数据。正如大多数客户端/服务器的服务器端一样,
Web 服务器端被设置为“永远”运行。图 20-1 列举了 Web 应用的体验。这里,一个用户执行一个像
浏览器的这类客户端程序与 Web 服务器取得连接,就可以在因特网上任何地方获得数据。
图 20-1 因特网上的 Web 客户端和 Web 服务器。在因特网上客户端向服务器端发送一个请求,然
后服务器端响应这个请求并将相应的数据返回给客户端。


客户端可能向服务器端发出各种请求。这些请求可能包括获得一个网页视图或者提交一个包含
数据的表单。这个请求经过服务器端的处理,然后会以特定的格式(HTML 等等)返回给客户端浏览。
Web 客户端和服务器端交互使用的“语言”,Web 交互的标准协议是 HTTP(超文本传输协议)          。HTTP
协议是 TCP/IP 协议的上层协议,这意味着 HTTP 协议依靠 TCP/IP 协议来进行低层的交流工作。它的
职责不是路由或者传递消息(TCP/IP 协议处理这些),而是通过发送、接受 HTTP 消息来处理客户端
的请求。
HTTP 协议属于无状态协议,它不跟踪从一个客户端到另一个客户端的的请求信息,这点和我们
现今使用的客户端/服务器端架构很像。服务器端持续运行,但是客户端的活动是按照这种结构独立
进行的:一旦一个客户的请求完成后,活动将被终止。可以随时发送新的请求,但是他们会被处理
成独立的服务请求。由于每个请求缺乏上下文背景,你可以注意到有些 URL 会有很长的变量和值作
为请求的一部分,以便提供一些状态信息。另外一个选项是“cookie”--保存在客户端的客户状态
信息。在本章的后面部分,我们将会看到如何使用 URL 和 cookie 来保存状态信息。
20.1.2 因特网
因特网是一个连接全球客户端和服务器端的变幻莫测的“迷雾”。客户端最终连接到服务器的
通路,实际包含了不定节点的连通。作为一个客户端用户,所有这些实现细节都会被隐藏起来。抽
象成为了从客户端到所访问的服务器端的直接连接。被隐藏起来的 HTTP, TCP/IP 协议将会处理所
有的繁重工作。中间的环节信息用户并不关心,所以将这些执行过程隐藏起来是有好处的。图 20-2
展示了因特网的扩展视图。


图 20-2 因特网的统览。左侧指明了在哪里你可以找到 Web 客户端,而右侧则暗示了 Web 服务
器的具体位置。
如图所示:因特网是由多种工作在一定规则下的(也许非连贯的)相互连接的网络组成的。图
表左侧的焦点是 Web 客户端,在家上网的用户通过拨号连接到 ISP(因特网供应商)上,上班族使用
的则是公司的局域网。
图表的右半部分关注的是 Web 服务器端及位置所在。具有大型 Web 站点的公司会将他们全部的
“Web 服务器” 放在 ISP 那里。这种物理安放被称为“整合”         ,这意味着你的服务器和其它客户的服
务器一同放在 ISP 处被“集中管理”。这些服务器或许为客户提供了不同的数据或者有一部分为应付
重负荷(高数量用户群)而设计成了可以存储重复数据的系统。小公司的 Web 站点或许不需要这么
大的硬盘或者网络设备,也许仅有一个或者几个“整合”服务器安放在他们的 ISP 处就可以了。
在任何一种情况下,大多数“整合”服务器被部署在大型 ISP 提供的骨干网上,这意味着他们
具有更高的“带宽”,如果你愿意,可以更接近因特网的核心点,从而可以更快的与因特网取得连接。


这就允许客户端可以绕过许多网络直接快速的访问服务器,从而在指定的时间内可以使得更多的客
户获得服务。
有一点需要记清楚,Web 应用是网络应用的一种最普遍的形式,但不是唯一的也不是最古老的一
种形式。因特网的出现早于 Web 近三十年。在 Web 出现之前,因特网主要用于教学和科研目的。因
特网上的大多数系统都是运行在 Unix 平台上的—一个多用户操作系统,许多最初的因特网协议至今
仍被沿用。
这些协议包括 telnet(允许用户在因特网上登录到远程的主机上,至今仍用),FTP 协议(文本
传输协议,用户通过上传和下载文件可以共享文件和数据,至今仍用),Gopher(Web 搜索引擎的雏
形—一个在互联网上爬动的小软件“gopher”可以自动寻找你感兴趣的数据),SMTP 或者叫做简单邮
件传输协议(这个协议用于最古老的也是应用最广泛的电子邮件),NNTP(新闻对新闻传输协议)。
由于 Python 的最初偏重就是因特网编程,除了其他一些东西外你还可以找到上边提及的所有协
议。可以这样区分“因特网编程”和“Web 编程”,后者仅包括针对 Web 的应用程序开发,也就是说
Web 客户端和服务器是本章的焦点。
因特网编程涵盖更多范围的应用程序:包括我们之前提及的一些因特网协议,例如:FTP, SMTP
等,同时也包括我们前一章提到的网络编程和套接字编程。
20.2    使用 Python 进行 Web 应用:创建一个简单的 Web 客户端
有一点需要记清楚,浏览器只是 Web 客户端的一种。任何一个通过向服务器端发送请求来获得
数据的应用程序都被认为是“客户端”           。当然,也可以建立其他的客户端从而在因特网上检索出文档
和数据。这样做的一个重要原因就是浏览器的能力有限,也就是说,它主要用于查看并同其他 Web
站点交互。另一方面,一个客户端程序,有能力做得更多—它不仅可以下载数据,同时也可以存储、
操作数据,甚或可以将其传送到另外一个地方或者传给另外一个应用。
一个使用 urllib 模块下载或者访问 Web 上的信息的应用程序[使用 urllib.urlopen() 或者
urllib.urlre- trieve()]可以被认为是简单的 Web 客户端。你所要做的就是提供一个有效的 Web 地
址。
20.2.1 统一资源定位符
简单的 Web 应用包扩使用被称为 URL(统一资源定位器)的 Web 地址。这个地址用来在 Web 上定
位一个文档,或者调用一个 CGI 程序来为你的客户端产生一个文档。URL 是大型标识符 URI(统一资
源标识)的一部分。这个超集是建立在已有的命名惯例基础上的。一个 URL 是一个简单的 URI,使用
已存在的协议或规划(也就是 http,ftp 等)作为地址的一部分。为了进一步描绘这些,我们将会


引入 non-URL 的 URI,有时这些被成为 URN(统一资源名称)                 ,但是在今天我们唯一使用的一种 URI
是 URL,至于 URI 和 URN 你也许没有听到太多,这或许已被保存成 XML 标识符了。
如街道地址一样,Web 地址也有一些结构。美国的街道地址通常是这种格式“号码 街道名称”,
例如 123 主大街。这个和其他国家不同,他们有自己的规则。URL 使用这种格式:
prot_sch://net_loc/path;params?query#frag
--------------------------------------------
Table 20.1 Web Address Components
URL 部件      描述
prot_sch    网络协议或者下载规划
net_loc     服务器位置(或许也有用户信息)
path        斜杠( / )限定文件或者 CGI 应用程序的路径。
Params      可选参数
query       连接符( & )连接键值对
frag        拆分文档中的特殊锚
--------------------------------------------
表 20.1 描述了各个部件
net_loc 可以进一步拆分成多个部件,有些是必备的,其他的是可选部件,net_loc 字符串如
下:
user:passwd@host:port
表 20.2 中分别描述了这些部件。
在这四个当中,host 主机名是最重要的。端口号只有在 Web 服务器运行其他非默认端口上时才
会被使用。(如果你不确定所使用的端口号,可以参到第十六章)。
用户名和密码部分只有在使用 FTP 连接时候才有可能用到,因为即使是使用 FTP,大多数的连接
都是使用匿名这时是不需要用户名和密码的。
--------------------------------------------
表 20.2 网络定位部件
net_loc
部件          描述
user        登录名
password    用户的密码
host        Web 服务器运行的机器名或地址(必须字段)
port        端口号(默认 80)
--------------------------------------------


Python 支持两种不同的模块,分别以不同的功能和兼容性来处理 URL。一种是 urlparse,一种
是 urllib。这里我们将会简单的介绍下它们的功能。
20.2.2 urlparse 模块
urlpasrse 模块提供了操作 URL 字符串的基本功能。这些功能包括 urlparse(), urlunparse()
和 urljoin().
urlparse()将 URL 字符串拆分成如上所描述的一些主要部件。语法结构如下:
urlparse(urlstr, defProtSch=None, allowFrag=None)
urlparse() 将 urlstr 解 析 成 一 个 6- 元 组 (prot_sch, net_loc,path, params, query,
frag).这里的每个部件在上边已经描述过了。如果 urlstr 中没有提供默认的网络协议或下载规划时
可以使用 defProtSch。allowFrag 标识一个 URL 是否允许使用零部件。下边是一个给定 URL 经
urlparse() 后的输出:
>>>urlparse.urlparse('http://www.python.org/doc/FAQ.html')
('http', 'www.python.org', '/doc/FAQ.html', '', '', '')
urlparse.urlunparse()
urlunparse()的功能与 urlpase()完全相反—它拼合一个 6-元组(prot_sch, net_loc, path,
params, query, frag)- urltup,它可能是一个 URL 经 urlparse()后的输出返回值。于是,我们可
以用如下方式表示:
urlunparse(urlparse(urlstr)) = urlstr
你或许已经猜到了 urlunpase()的语法:
urlunparse(urltup)
urlparse.urljoin()
在需要多个相关的 URL 时我们就需要使用 urljoin()的功能了,如,在一个 Web 页中生成的一系
列页面的 URL。Urljoin()的语法是:
urljoin(baseurl, newurl, allowFrag=None)
--------------------------------------------
Table 20.3 Core urlparse Module Functions


urlparse 功能                      描述
urlparse(urlstr,
defProtSch=None,
allowFrag=None)                将 urlstr 解析成各个部件,如果在 rulstr 中没有给定协议
或者规划将使用 defProtSch;allowFrag 决定是否允许有 URL
零部件。
urlunparse(urltup)               将 URL 数据(urltup)的一个元组反解析成一个 URL 字符串。
urljoin(baseurl,
newurl, allowFrag =None)     将 URL 的基部件 baseurl 和 newurl 拼合成一个完整的 URL;
allowFrag 的作用和 urlpase()中相同。
--------------------------------------------
urljoin()取得 baseurl,并将其基路径(net_loc 附加一个完整的路径,但是不包括终端的文件)
与 newurl 连接起来。例如:
>>> urlparse.urljoin('http://www.python.org/doc/FAQ.html', \
... 'current/lib/lib.htm')
'http://www.python.org/doc/current/lib/lib.html'
在表 20.3 中可以找到 urlparse 的功能概述。
20.2.3 urllib 模块
核心模块:urllib
urllib 模块提供了所有你需要的功能,除非你计划写一个更加低层的网络客户端。urllib 提供
了了一个高级的 Web 交流库,支持 Web 协议,HTTP, FTP 和 Gopher 协议,同时也支持对本地文件的
访问。urllib 模块的特殊功能是利用上述协议下载数据(从因特网、局域网、主机上下载)。使用这
个模块可以避免使用 httplib, ftplib 和 gopherlib 这些模块,除非你想用更低层的功能。在那些
情况下这些模块都是可选择的(注意:大多数以*lib 命名的模块用于客户端相关协议开发。并不是所
有情况都是这样的,或许 urllib 应该被命名为“internetlib”或者其他什么相似的名字)。
Urllib 模块提供了在给定的 URL 地址下载数据的功能,同时也可以通过字符串的编码、解码来
确保它们是有效 URL 字符串的一部分。我们接下来要谈的功能包括 urlopen(), urlretrieve(),
quote(),unquote(), quote_plus(), unquote_plus(), 和         urlencode() 。 我 们 可 以 使 用
urlopen()方法返回文件类型对象。你会觉得这些方法不陌生,因为在第九章我们已经涉及到了文件
方面的内容。
urllib.urlopen()
urlopen() 打开一个给定 URL 字符串与 Web 连接,并返回了文件类的对象。语法结构如下:


urlopen(urlstr, postQueryData=None)
urlopen()打开 urlstr 所指向的 URL。如果没有给定协议或者下载规划,或者文件规划早已传入,
urlopen()则会打开一个本地的文件。
对于所有的 HTTP 请求,常见的请求类型是“GET”                      。在这些情况中,向 Web 服务器发送的请求字
符串(编码键值或引用,如 urlencode()函数的字符串输出[如下])应该是 urlstr 的一部分。
如果要求使用“POST”方法,请求的字符串(编码的)应该被放到 postQueryData 变量中。                        (要
了解更多关于“GET”和“POST”方法的信息,请查看 CGI 应用编程部分的普通文档或者文本,这些
我们在下边也会讨论)。GET 和 POST 请求是向 Web 服务器上传数据的两种方法。
一旦连接成功,urlopen() 将会返回一个文件类型对象,就像在目标路径下打开了一个可读文
件。例如,如果我们的文件对象是 f,那么我们的“句柄”将会支持可读方法如:f.read(),
f.readline(), f.readlines(), f.close(),和 f.fileno().
此外,f.info()方法可以返回 MIME(Multipurpose Internet Mail Extension,多目标因特
网邮件扩展)头文件。这个头文件通知浏览器返回的文件类型可以用哪类应用程序打开。例如,浏
览器本身可以查看 HTML(HyperText Markup Language,超文本标记语言),纯文本文件,生成(指
由数据显示图像——译者注)PNG(Portable Network Graohics)文件,JPEG(Joint Photographic
Experts Group)或者 GIF(Graphics Interchange Format)文件。其他的如多媒体文件,特殊类
型文件需要通过扩展的应用程序才能打开。
--------------------------------------------
Table 20.4 urllib.urlopen() File-like Object Methods
urlopen() 对象方法        描述
f.read([bytes])       从 f 中读出所有或 bytes 个字节
f.readline()          从 f 中读出一行
f.readlines()         从 f 中读出所有行并返回一个列表
f.close()          关闭 f 的 URL 的连接
f.fileno()         返回 f 的文件句柄
f.info()           获得 f 的 MIME 头文件
f.geturl()         返回 f 所打开的真正的 URL
--------------------------------------------
最后,geturl()方法在考虑了所有可能发生的间接导向后,从最终打开的文件中获得真实的 URL,
这些文件类型对象的方法在表 20.4 中有描述。
如果你打算访问更加复杂的 URL 或者想要处理更复杂的情况如基于数字的权限验证,重定位,
coockie 等问题,我们建议你使用 urllib2 模块,这个在 1.6 版本中有介绍(多数是试验模块)。它


同时还有一个 urlopen()函数,但也提供了其他的可以打开各种 URL 的函数和类。关于 urllib2 的更
多信息,将会在本章的下一部分介绍。
urllib.urlretrieve()
如果你对整个 URL 文档的工作感兴趣,urlretrieve()可以帮你快速的处理一些繁重的工作。下
边是 urlretrieve()的语法:
urlretrieve(urlstr, localfile=None, downloadStatusHook=None)
除了像 urlopen()这样从 URL 中读取内容,urlretrieve()可以方便地将 urlstr 定位到的整个
HTML 文件下载到你本地的硬盘上。你可以将下载后的数据存成一个本地文件或者一个临时文件。如
果该文件已经被复制到本地或者已经是一个本地文件,后续的下载动作将不会发生。
如果可能,downloadStatusHook 这个函数将会在每块数据下载或传输完成后被调用。调用时使
用下边三个参数:目前读入的块数,块的字节数和文件的总字节数。如果你正在用文本的或图表的
视图向用户演示“下载状态”信息,这个函数将会是非常有用的。
urlretrieve()返回一个 2-元组,(filename, mime_hdrs).filename 是包含下载数据的本地文
件名,mime_hdrs 是对 Web 服务器响应后返回的一系列 MIME 文件头。要获得更多的信息,可以看
mimetools 的 Message 类。对本地文件来说 mime_hdrs 是空的。
关于 urlretrieve()的简单应用,可以看 11.4(grabweb.py)中的例子。在本章的 20.2 中将会
介绍 urlretrieve()更深层的应用。
urllib.quote() and urllib.quote_plus()
quote*()函数获取 URL 数据,并将其编码,从而适用于 URL 字符串中。尤其是一些不能被打印
的或者不被 Web 服务器作为有效 URL 接收的特殊字符串必须被转换。这就是 quote*()函数的功能。
quote*()函数的语法如下:
quote(urldata, safe='/')
逗号,下划线,句号,斜线和字母数字这类符号是不需要转化。其他的则均需要转换。另外,
那些不被允许的字符前边会被加上百分号(%)同时转换成 16 进制,例如:                          “%xx”,     “xx”代表这个字母
的 ASCII 码的十六进制值。当调用 quote*()时,urldata 字符串被转换成了一个可在 URL 字符串中
使用的等价值。safe 字符串可以包含一系列的不能被转换的字符。默认的是斜线(/).
quote_plus() 与 quote()很像,另外它还可以将空格编码成+号。下边是一个使用 quote()和
quote_plus()的例子:
--------------------------------------------
>>> name = 'joe mama'


>>> number = 6
>>> base = 'http://www/~foo/cgi-bin/s.py'
>>> final = '%s?name=%s&num=%d' % (base, name, number)
>>> final
'http://www/~foo/cgi-bin/s.py?name=joe mama&num=6'
>>>
>>> urllib.quote(final)
'http:%3a//www/%7efoo/cgi-bin/s.py%3fname%3djoe%20mama%26num%3d6'
>>>
>>> urllib.quote_plus(final)
'http%3a//www/%7efoo/cgi-bin/
s.py%3fname%3djoe+mama%26num%3d6'
--------------------------------------------
urllib.unquote() 和 urllib.unquote_plus()
也许和你猜到的一样,unquote*()函数与 quote*()函数的功能安全相反—它将所有编码为“%xx”
式的字母都转换成它们的 ASCII 码值。Unquote*()的语法如下:
unquote*(urldata)
调 用 unquote() 函 数 将 会 把 urldata 中 所 有 的 URL- 编 码 字 母 都 解 码 , 并 返 回 字 符 串 。
Unquote_plus()函数会将加号转换成空格符。
urllib.urlencode()
在 1.5.2 版的 Python 中,urlopen()函数接收字典的键-值对,并将其编译成 CGI 请求的 URL 字
符串的一部分。键值对的格式是“键=值”,以连接符(&)划分。更进一步,键和它们的值被传到
quote_plus()函数中进行适当的编码。下边是 urlencode()输出的一个例子:
>>> aDict = { 'name': 'Georgina Garcia', 'hmdir': '~ggarcia' }
>>> urllib.urlencode(aDict)
'name=Georgina+Garcia&hmdir=%7eggarcia'
urllib 和 urlparse 还有一些其他的功能,在这里我们就不一一概述了。阅读相关文档可以获得
更多信息。
安全套接字层支持
在 1.6 版中 urllib 模块通过安全套接字层(SSL)支持开放的 HTTP 连接.socket 模块的核心变化
是增加并实现了 SSL。 随后,urllib 和 httplib 模块被上传用于支持 URL 在“https”连接规划中
的应用。除了那两个模块以外,其他的含有 SSL 的模块还有: imaplib, poplib 和 smtplib。


在表 20.5 中可以看到关于本节讨论的 urllib 函数的概要总结。
--------------------------------------------
Table 20.5 Core urllib Module Functions
urllib 函数                 描述
urlopen(urlstr,
postQuery- Data=None)     打开 URL urlstr,如果必要则通过 postQueryData 发送请求。
urlretrieve(urlstr,
local- tusHook=None)      将 URL urlstr 定位的文件下载到 localfile 或临时文件中(当
localfile 没有给定时);如果文件已经存在 downloaStatusHook
将会获得下载的统计信息。
quote(urldata, safe='/') 将 urldata 的无效的 URL 字符编码;在 safe 列的则不必编码。
quote_plus(urldata,
safe='/')                  将空格编译成加(+)号(并非%20)外,其他功能与 quote()相似。
unquote(urldata)             将 urldata 中编码后的字母解码
unquote_plus(urldata)        除了将加好转换成空格后其他功能与 unquote()相似。
urlencode(dict)           将字典键-值对编译成有效的 CGI 请求字符串,用 quote_plus()
对键和值字符串分别编码。
--------------------------------------------
20.2.4 urllib2 模块
正如前面所提到的,urllib2 可以处理更复杂 URL 的打开问题。一个例子就是有基本认证(登录
名和密码)需求的 Web 站点。最简单的“获得已验证参数”的方法是使用前边章节中描述的 URL 部
件 net_loc,也就是说:http://user:passwd@www.python.org.这种解决方案的问题是不具有可编程
性。然而使用 urllib2,我们可以通过两种不同的方式来解决这个问题。
我们可以建立一个基础认证处理器(urllib2.HTTPBasicAuthHandler),同时在基本 URL 或域上注
册一个登录密码,这就意味着我们在 Web 站点上定义了个安全区域。(关于域的更多信息可以查看
RFC2617[HTTP 认证:基本数字认证])。一旦完成这些,你可以安装 URL 打开器,通过这个处理器打
开所有的 URL。
另一个可选的办法就是当浏览器提示的时候,输入用户名和密码 ,这样就发送了一个带有适当
用户请求的认证头。在 20.1 的例子中,我们可以很容易的区分出这两种方法。
逐行解释
1–7 行


普通的初始化过程,外加几个为后续脚本使用的常量。
9–15 行
代码的“handler”版本分配了一个前面提到的基本处理器类,并添加了认证信息。之后该处理
器被用于建立一个 URL-opener,并安装它以便所有已打开的 URL 能用到这些认证信息。这段代码和
urllib2 模块的 Python 官方文档是兼容的。
--------------------------------------------
Example 20.1 HTTP Auth Client (urlopenAuth.py)
This script uses both techniques described above for basic authentication.
1 #!/usr/bin/env python
2
3 import urllib2
4
5 LOGIN = 'wesc'
6 PASSWD = "you'llNeverGuess"
7 URL = 'http://localhost'
8
9 def handler_version(url):
10 from urlparse import urlparse as up
11 hdlr = urllib2.HTTPBasicAuthHandler()
12 hdlr.add_password('Archives', up(url)[1], LOGIN, PASSWD)
13 opener = urllib2.build_opener(hdlr)
14 urllib2.install_opener(opener)
15 return url
16
17 def request_version(url):
18 from base64 import encodestring
19 req = urllib2.Request(url)
20 b64str = encodestring('%s:%s' % (LOGIN, PASSWD))[:-1]
21 req.add_header("Authorization", "Basic %s" % b64str)
22 return req
23
24 for funcType in ('handler', 'request'):
25 print '*** Using %s:' % funcType.upper()
26 url = eval('%s_version')(URL)
27 f = urllib2.urlopen(url)
28 print f.readline()
29 f.close()
--------------------------------------------


17–22 行
这段代码的“request”版本创建了一个 Request 对象,并在 HTTP 请求中添加了基本的 base64
编码认证头信息。返回“main”后(译者注:指 for 循环)调用 urlopen()时,该请求被用来替换其
中的 URL 字符串。注意原始 URL 内建在 Requst 对象中,正因为如此在随后的 urllib2.urlopen()中
调用中替换 URL 字符串才不会产生问题。这段代码的灵感来自于 Mike Foord 和 Lee Harr 在 Python
Cookbook 上的回复,具体位置在:
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/305288
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/267197
如果能直接用 Harr 的 HTTPRealmFinder 类就更好了,那样我们就没必要在例子里使用硬编码了。
24–29 行
这个脚本的剩余部分只是用两种技术分别打开了给定的 URL,并显示服务器返回的 HTML 页面第
一行(舍弃了其他行),当然前提是要通过认证。注意如果认证信息无效的话会返回一个 HTTP 错误
(并且不会有 HTML)。
程序的输出应当如下所示:
$ python urlopen-auth.py
Using handler:
<html>
Using request:
<html>
还有一个很有用的文档可以在
http://www.voidspace.org.uk/python/articles/urllib2.shtml 找到,你可以把它作为 Python
官方文档的补充。
20.3 高级 Web 客户端
Web 浏览器是基本的 Web 客户端。主要用来在 Web 上查询或者下载文件。而 Web 的高级客户端并
不只是从因特网上下载文档。
高级 Web 客户端的一个例子就是网络爬虫(aka 蜘蛛和机器人)。这些程序可以基于不同目的在
因特网上探索和下载页面,其中包括:


z   为 Google 和 Yahoo 这类大型的搜索引擎建索引
z   脱机浏览—将文档下载到本地,重新设定超链接,为本地浏览器创建镜像。
z   下载并保存历史记录或框架
z   Web 页的缓存,节省再次访问 Web 站点的下载时间。
我们下边介绍网络爬虫:crawl.py,抓取 Web 的开始页面地址(URL)                    ,下载该页面和其它后续链
接页面,但是仅限于那些与开始页面有着相同域名的页面。如果没有这个限制的话,你的硬盘将会
被耗尽!crwal.py 的代码在例子 20.2 中展示。
逐行解释(一个类一个类的)
1–11 行
该脚本的开始部分包括 Python 在 Unix 上标准的初始化行以及一些模块属性的导入,它们都会
在本应用程序中用到。
13–49 行
Retriever 类的责任是从 Web 下载页面,解析每个文档中的链接并在必要的时候把它们加入
“to-do”队列。我们为每个从网上下载的页面都创建一个 Retriever 类的实例。Retriever 中的方
法展现了它的功能:构造器(__init__())、filename()、download()、和 parseAndGetLinks()。
filename()方法使用给定的 URL 找出安全、有效的相关文件名并存储在本地。大体上说,它会
去掉 URL 的“http://”前缀,使用剩余的部分作为文件名,并创建必要的文件夹路径。那些没有
文件名前缀的 URL 则会被赋予一个默认的文件名“index.htm”                  。(可以在调用 filename()时重新指定
这个名字。)
构造器实例化了一个 Retriever 对象,并把 URL 和通过 filename()获得的相应文件名都作为本
地属性保存起来。
--------------------------------------------
Example 20.2 Advanced Web Client: a Web Crawler (crawl.py)
这个爬虫程序包括两个类,一个管理真个 crawling 进程(Crawler),一个检索并解析每一个下
载的 Web 页面(Retriever)。
1 #!/usr/bin/env python
2
3 from sys import argv
4 from os import makedirs, unlink, sep
5 from os.path import dirname, exists, isdir, splitext
6 from string import replace, find, lower


7 from htmllib import HTMLParser
8 from urllib import urlretrieve
9 from urlparse import urlparse, urljoin
10     from formatter import DumbWriter, AbstractFormatter
11     from cStringIO import StringIO
12
13     class Retriever(object):# download Web pages
14
15 def __init__(self, url):
16 self.url = url
17 self.file = self.filename(url)
18
19 def filename(self, url, deffile='index.htm'):
20 parsedurl = urlparse(url, 'http:', 0) ## parse path
21 path = parsedurl[1] + parsedurl[2]
22 ext = splitext(path)
23 if ext[1] == '': # no file, use default
24 if path[-1] == '/':
25 path += deffile
26 else:
27 path += '/' + deffile
28 ldir = dirname(path) # local directory
29 if sep != '/':      # os-indep. path separator
30 ldir = replace(ldir, '/', sep)
31 if not isdir(ldir): # create archive dir if nec.
32 if exists(ldir): unlink(ldir)
33 makedirs(ldir)
34 return path
35
36 def download(self): # download Web page
37 try:
38 retval = urlretrieve(self.url, self.file)
39 except IOError:
40 retval = ('*** ERROR: invalid URL "%s"' %\
41 self.url,)
42 return retval
43
44 def parseAndGetLinks(self):# parse HTML, save links
45 self.parser = HTMLParser(AbstractFormatter(\
46 DumbWriter(StringIO())))


47   self.parser.feed(open(self.file).read())
48   self.parser.close()
49   return self.parser.anchorlist
50
51    class Crawler(object):# manage entire crawling process
52
53   count = 0 # static downloaded page counter
54
55   def __init__(self, url):
56   self.q = [url]
57   self.seen = []
58   self.dom = urlparse(url)[1]
59
60   def getPage(self, url):
61   r = Retriever(url)
62   retval = r.download()
63   if retval[0] == '*': # error situation, do not parse
64   print retval, '... skipping parse'
65 return
66 Crawler.count += 1
67 print '\n(', Crawler.count, ')'
68 print 'URL:', url
69   print 'FILE:', retval[0]
70   self.seen.append(url)
71
72   links = r.parseAndGetLinks() # get and process links
73   for eachLink in links:
74   if eachLink[:4] != 'http' and \
75   find(eachLink, '://') == -1:
76   eachLink = urljoin(url, eachLink)
77   print '* ', eachLink,
78
79   if find(lower(eachLink), 'mailto:') != -1:
80   print '... discarded, mailto link'
81   continue
82
83   if eachLink not in self.seen:
84   if find(eachLink, self.dom) == -1:
85   print '... discarded, not in domain'
86   else:


87   if eachLink not in self.q:
88   self.q.append(eachLink)
89   print '... new, added to Q'
90   else:
91   print '... discarded, already in Q'
92   else:
93   print '... discarded, already processed'
94
95   def go(self):# process links in queue
96   while self.q:
97   url = self.q.pop()
98   self.getPage(url)
99
100  def main():
101  if len(argv) > 1:
102  url = argv[1]
103  else:
104    try:
105    url = raw_input('Enter starting URL: ')
106    except (KeyboardInterrupt, EOFError):
107    url = ''
108
109  if not url: return
110  robot = Crawler(url)
111  robot.go()
112
113  if __name__ == '__main__':
114  main()
--------------------------------------------
正如你想象的,download()方法实际会连上网络去下载给定链接的页面。它使用 URL 调用
urllib.urlretrieve()函数并把结果保存在 filename 中(该值由 filename()返回)。如果下载成功,
parse()方法会被调用来解析刚从网络拷贝下来的页面;否则会返回一个错误字符串。
如果 Crawler 判定没有错误发生,它会调用 parseAndGetLinks()方法来解析新下载的页面并决
定该页面中每个链接的后续动作。
51-98 行
Crawler 类是这次演示中的“明星”,掌管在一个 Web 站点上的整个抓爬过程。如果我们为应用


程序添加线程,就可以为每个待抓爬的站点分别创建实例。Crawler 的构造器在初始化过程中存储了
3 样东西,第一个是 q,一个待下载链接的队列。这个队列在运行过程中会有涨落,有页面处理完毕
它就变短,在下载的页面中发现新的链接则会让它变长。
Crawler 包含的另两个数值是 seen,一个所有“我们已看过”                  (已下载)的链接的列表,和 dom,
我们把主链接的域名存储在这里,并用这个值来判定后续链接是否是该域的一部分。
Crawler 还有一个静态数据成员 count。这个计数器只是用来保存我们已经从网上下载的对象数
目。每有一个页面成功下载它就会增加。
除了构造器 Crawler 还有其他两个方法,getPage()和 go()。go()只是简单的启动 Crawler,它
在代码的主体部分被调用。go()中有一个循环,只有队列中还有待下载的新链接它就会不停的执行。
然而这个的真正工作者,却是 getPage()方法。
getPage()初始化了一个 Retriever 对象,并把第一个链接赋给它然后让它执行。如果页面下载
成功,计数器会增加并且链接会被加到“已看”列表。它会反复地检查每个已下载页面中的所有链
接并判决是否有链接要被加入待下载队列。go()中的主循环会不停的推进处理过程直到队列为空,
这时便大功告成。
属于其他域的链接、已经下载过的链接、已在队列中待处理的链接、以及“mailto:”类型的
链接在扩充队列时都会被忽略掉。
100-114 行
main()是程序运行的起点,它在该脚本被直接调用时执行。其他导入 crawl.py 的模块则需要调
用 main()来启动处理过程。main()需要一个 URL 来启动处理,如果在命令行指定了一个(例如这个
脚本被直接调用时),它就会使用这个指定的。否则,脚本进入交互模式,提示用户输入起始 URL。
一旦有了起始链接,Crawler 就会被实例化并启动开来。
一个调用 crawl.py 的例子如下所示:
--------------------------------------------
% crawl.py
Enter starting URL: http://www.null.com/home/index.html
( 1 )
URL: http://www.null.com/home/index.html
FILE: www.null.com/home/index.html
* SICP
Python	描述	中文版              
第一章	使用函数构建抽象          
    1.1	引言                      
    1.2	编程元素                  
    1.3	定义新的函数              
    1.4	实践指南:函数的艺术       
    1.5	控制                      
    1.6	高阶函数                  
第二章	使用对象构建抽象          
    2.1	引言                      
    2.2	数据抽象                  
    2.3	序列                      
    2.4	可变数据                  
    2.5	面向对象编程              
    2.6	实现类和对象              
    2.7	泛用方法                  
第三章	计算机程序的构造和解释   
    3.1	引言                      
    3.2	函数和所生成的过程        
    3.3	递归数据结构              
    3.4	异常                      
    3.5	组合语言的解释器          
    3.6	抽象语言的解释器          
第四章	分布式和并行计算          
第五章	序列和协程                
                                  
第一章	使用函数构建抽象
1.1	引言
计算机科学是一个极其宽泛的学科。全球的分布式系统、人工智能、机器人、图形、安全、
科学计算,计算机体系结构和许多新兴的二级领域,每年都会由于新技术和新发现而扩展。
计算机科学的快速发展广泛影响了人类生活。商业、通信、科学、艺术、休闲和政治都被计
算机领域彻底改造。
计算机科学的巨大生产力可能只是因为它构建在一系列优雅且强大的基础概念上。所有计算
都以表达信息、指定处理它所需的逻辑、以及设计管理逻辑复杂性的抽象作为开始。对这些
基础的掌握需要我们精确理解计算机如何解释程序以及执行计算过程。
这些基础概念在伯克利长期教授,使用由Harold	Abelson、Gerald	Jay	Sussman和Julie
Sussman创作的经典教科书《计算机科学的构造与解释》(SICP)。这个讲义大量借鉴了这
本书,原作者慷慨地使它可用于改编和复用。
我们的智力之旅一旦出发就不能回头了,我们也永远都不应该对此有所期待。
   我们将要学习计算过程的概念。计算过程是计算机中的抽象事物。在演化中,过程操纵
   着叫做数据的其它事物。过程的演化由叫做程序的一系列规则主导。人们创造程序来主
   导过程。实际上,我们使用我们的咒语来凭空创造出计算机的灵魂。
   我们用于创造过程的程序就像巫师的魔法。它们由一些古怪且深奥的编程语言中的符号
   表达式所组成,这些语言指定了我们想让过程执行的任务。
   在一台工作正确的计算机上,计算过程准确且严谨地执行程序。所以,就像巫师的学徒
   那样,程序员新手必须学会理解和预测他们的魔法产生的结果。
   --Abelson	&	Sussman,	SICP	(1993)
1.1.1	在Python中编程
   语言并不是你学到的东西,而是你参与的东西。
   --Arika	Okrent
为了定义计算过程,我们需要一种编程语言,最好是一种许多人和大量计算机都能懂的语
言。这门课中,我们将会使用Python语言。
                                                          5
1.1	引言
Python是一种广泛使用的编程语言,并且在许多职业中都有它的爱好者:Web程序员、游戏
工程师、科学家、学者,甚至新编程语言的设计师。当你学习Python时,你就加入到了一个
数百万人的开发者社群。开发者社群是一个极其重要的组织:成员可以互相帮助来解决问
题,分享他们的代码和经验,以及一起开发软件和工具。投入的成员经常由于他们的贡献而
出名,并且收到广泛的尊重。也许有一天你会被提名为Python开发者精英。
Python语言自身就是一个大型志愿者社群的产物,并且为其贡献者的多元化而自豪。这种语
言在20世纪80年代末由Guido	van	Rossum设计并首次实现。他的Python3教程的第一章解释
了为什么Python在当今众多语言之中如此流行。
Python适用于作为教学语言,因为纵观它的历史,Python的开发者强调了Python代码对人类
的解释性,并在Python之禅中美观、简约和可读的原则下进一步加强。Python尤其适用于课
堂,因为它宽泛的特性支持大量的不同编程风格,我们将要探索它们。在Python中编程没有
单一的解法,但是有一些习俗在开发者社群之间流传,它们可以使现有程序的阅读、理解,
以及扩展变得容易。所以,Python的灵活性和易学性的组合可以让学生们探索许多编程范
式,之后将它们新学到的知识用于数千个正在开发的项目中。
这些讲义通过使用抽象设计的技巧和严谨的计算模型,来快速介绍Python的特性。此外,这
些讲义提供了Python编程的实践简介,包含一些高级语言特性和展示示例。通过这门课,学
习Python将会变成自然而然的事情。
然而,Python是一门生态丰富的语言,带有大量特性和用法。我们讲到基本的计算机科学概
念时,会刻意慢慢地介绍他们。对于有经验的学生,他们打算一口气学完语言的所有细节,
我们推荐他们阅读Mark	Pilgrim的书Dive	Into	Python	3,它在网上可以免费阅读。这本书的主
题跟这门课极其不同,但是这本书包含了许多关于使用Python的宝贵的实用信息。事先告
知:不像这些讲义,Dive	Into	Python	3需要一些编程经验。
开始在Python中编程的最佳方法就是直接和解释器交互。这一章会描述如何安装Python3,使
用解释器开始交互式会话,以及开始编程。
1.1.2	安装Python3
就像所有伟大的软件一样,Python具有许多版本。这门课会使用Python3最新的稳定版本(本
书编写时是3.2)。许多计算机都已经安装了Python的旧版本,但是它们可能不满足这门课。
你应该可以在这门课上使用任何能安装Python3的计算机。不要担心,Python是免费的。
Dive	Into	Python	3拥有一个为所有主流平台准备的详细的安装指南。这个指南多次提到了
Python3.1,但是你最好安装3.2(虽然它们的差异在这门课中非常微小)。EECS学院的所有
教学机都已经安装了Python3.2。
1.1.3	交互式会话
                                                         6
1.1	引言
在Python交互式会话中,你可以在提示符 	>>>	之后键入一些Python代码。Python解释器读取
并求出你输入的东西,并执行你的各种命令。
有几种开始交互式会话的途径,并且具有不同的特性。把它们尝试一遍来找出你最喜欢的方
式。它们全部都在背后使用了相同的解释器(CPython)。
     最简单且最普遍的方式就是运行Python3应用。在终端提示符后(Mac/Unix/Linux)键
     入 	python3	,或者在Windows上打开Python3应用。(译者注:Windows上设置完Python
     的环境变量之后,就可以在 	cmd	或PowerShell中执行相同操作了。)
     有一个更加用户友好的应用叫做Idle3( 	idle3	),可用于学习这门语言。Idle会高亮你的
     代码(叫做语法高亮),弹出使用提示,并且标记一些错误的来源。Idle总是由Python自
     带,所以你已经安装它了。
     Emacs编辑器可以在它的某个缓冲区中运行交互式会话。虽然它学习起来有些挑战,
     Emacs是个强大且多功能的编辑器,适用于任何语言。请阅读61A的Emacs教程来开始。
     许多程序员投入大量时间来学习Emacs,之后他们就不再切换编辑器了。
在所有情况中,如果你看见了Python提示符 	>>>	,你就成功开启了交互式会话。这些讲义使
用提示符来展示示例,同时带有一些输入。
  >>>	2	+	2
  4
控制:每个会话都保留了你的历史输入。为了访问这些历史,需要按下 	<Control>-P	(上一
个)和 	<Control>-N	(下一个)。 	<Control>-D	会退出会话,这会清除所有历史。
1.1.4	第一个例子
   想像会把不知名的事物用一种形式呈现出来,诗人的笔再使它们具有如实的形象,空虚
   的无物也会有了居处和名字。
   --威廉·莎士比亚,《仲夏夜之梦》
为了介绍Python,我们会从一个使用多个语言特性的例子开始。下一节中,我们会从零开
始,一步一步构建整个语言。你可以将这章视为即将到来的特性的预览。
Python拥有常见编程功能的内建支持,例如文本操作、显示图形以及互联网通信。导入语句
  >>>	from	urllib.request	import	urlopen
为访问互联网上的数据加载功能。特别是,它提供了叫做 	urlopen	的函数,可以访问到统一
资源定位器(URL)处的内容,它是互联网上的某个位置。
语句和表达式:Python代码包含语句和表达式。广泛地说,计算机程序包含的语句
                                                             7
1.1	引言
 1.	 计算某个值
 2.	 或执行某个操作
语句通常用于描述操作。当Python解释器执行语句时,它执行相应操作。另一方面,表达式
通常描述产生值的运算。当Python求解表达式时,就会计算出它的值。这一章介绍了几种表
达式和语句。
赋值语句
  >>>	shakespeare	=	urlopen('http://inst.eecs.berkeley.edu/~cs61a/fa11/shakespeare.txt')
将名称 	shakespeare	和后面的表达式的值关联起来。这个表达式在URL上调用 	urlopen	函数,
URL包含了莎士比亚的37个剧本的完整文本,在单个文本文件中。
函数:函数封装了操作数据的逻辑。Web地址是一块数据,莎士比亚的剧本文本是另一块数
据。前者产生后者的过程可能有些复杂,但是我们可以只通过一个表达式来调用它们,因为
复杂性都塞进函数里了。函数是这一章的主要话题。
另一个赋值语句
  >>>	words	=	set(shakespeare.read().decode().split())
将名称 	words	关联到出现在莎士比亚剧本中的所有去重词汇的集合,总计33,721个。这个命
令链调用了 	read	、 	decode	和 	split	,每个都操作衔接的计算实体:从URL读取的数据、解
码为文本的数据、以及分割为单词的文本。所有这些单词都放在 	set	中。
对象:集合是一种对象,它支持取交和测试成员的操作。对象整合了数据和操作数据的逻
辑,并以一种隐藏其复杂性的方式。对象是第二章的主要话题。
表达式
  >>>	{w	for	w	in	words	if	len(w)	>=	5	and	w[::-1]	in	words}
  {'madam',	'stink',	'leets',	'rever',	'drawer',	'stops',	'sessa',
  'repaid',	'speed',	'redder',	'devil',	'minim',	'spots',	'asses',
  'refer',	'lived',	'keels',	'diaper',	'sleek',	'steel',	'leper',
  'level',	'deeps',	'repel',	'reward',	'knits'}
是一个复合表达式,求出正序或倒序出现的“莎士比亚词汇”集合。神秘的记号 	w[::-1]	遍历单
词中的每个字符,然而 	-1	表明倒序遍历( 	::	表示第一个和最后一个单词都使用默认值)。
当你在交互式会话中输入表达式时,Python会在随后打印出它的值,就像上面那样。
解释器:复合表达式的求解需要可预测的过程来精确执行解释器的代码。执行这个过程,并
求解复合表达式和语句的程序就叫解释器。解释器的设计与实现是第三章的主要话题。
与其它计算机程序相比,编程语言的解释器通常比较独特。Python在意图上并没有按照莎士
比亚或者回文来设计,但是它极大的灵活性让我们用极少的代码处理大量文本。
                                                                                         8
1.1	引言
最后,我们会发现,所有这些核心概念都是紧密相关的:函数是对象,对象是函数,解释器
是二者的实例。然而,对这些概念,以及它们在代码组织中的作用的清晰理解,是掌握编程
艺术的关键。
1.1.5	实践指南
Python正在等待你的命令。你应当探索这门语言,即使你可能不知道完整的词汇和结构。但
是,要为错误做好准备。虽然计算机极其迅速和灵活,它们也十分古板。在斯坦福的导论课
中,计算机的本性描述为
   计算机的基本等式是: 	计算机	=	强大	+	笨拙	
   计算机非常强大,能够迅速搜索大量数据。计算机每秒可以执行数十亿次操作,其中每
   个操作都非常简单。
   计算机也非常笨拙和脆弱。它们所做的操作十分古板、简单和机械化。计算机缺少任何
   类似真实洞察力的事情...它并不像电影中的HAL	9000。如果不出意外,你不应被计算机
   吓到,就像它拥有某种大脑一样。它在背后非常机械化。
   程序是一个人使用他的真实洞察力来构建出的一些实用的东西,它由这些简单的小操作
   所组成。
   —Francisco	Cai	&	Nick	Parlante,	斯坦福	CS101
在你实验Python解释器的时候,你会马上意识到计算机的古板:即使最小的拼写和格式修改
都会导致非预期的输出和错误。
学习解释错误和诊断非预期错误的原因叫做调试(debugging)。它的一些指导原则是:
 1.	 逐步测试:每个写好的程序都由小型的组件模块组成,这些组件可以独立测试。尽快测
     试你写好的任何东西来及早捕获错误,并且从你的组件中获得自信。
 2.	 隔离错误:复杂程序的输出、表达式、或语句中的错误,通常可以归于特定的组件模
     块。当尝试诊断问题时,在你能够尝试修正错误之前,一定要将它跟踪到最小的代码片
     段。
 3.	 检查假设:解释器将你的指令执行为文字	--	不多也不少。当一些代码不匹配程序员所相
     信的(或所假设的)行为,它们的输出就会是非预期的。了解你的假设,之后专注于验
     证你的假设是否整理来调试。
 4.	 询问他人:你并不是一个人!如果你不理解某个错误信息,可以询问朋友、导师或者搜
     索引擎。如果你隔离了一个错误,但是不知道如何改正,可以让其它人来看一看。在小
     组问题解决中,会分享一大堆有价值的编程知识。
逐步测试、模块化设计、明确假设和团队作业是贯穿这门课的主题。但愿它们也能够一直伴
随你的计算机科学生涯。
                                                9
1.1	引言
       10
1.2	编程元素
1.2	编程元素
   来源:1.2	The	Elements	of	Programming
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
编程语言是操作计算机来执行任务的手段,它也在我们组织关于过程的想法中,作为一种框
架。程序用于在编程社群的成员之间交流这些想法。所以,程序必须为人类阅读而编写,并
且仅仅碰巧可以让机器执行。
当我们描述一种语言时,我们应该特别注意这种语言的手段,来将简单的想法组合为更复杂
的想法。每个强大的语言都拥有用于完成下列任务的机制:
     基本的表达式和语句,它们由语言提供,表示最简单的构建代码块。
     组合的手段,复杂的元素由简单的元素通过它来构建,以及
     抽象的手段,复杂的元素可以通过它来命名,以及作为整体来操作。
在编程中,我们处理两种元素:函数和数据。(不久之后我们就会探索它们并不是真的非常
不同。)不正式地说,数据是我们想要操作的东西,函数描述了操作数据的规则。所以,任
何强大的编程语言都应该能描述基本数据和基本函数,并且应该拥有组合和抽象二者的方
式。
1.2.1	表达式
在实验	Python	解释器之后,我们现在必须重新开始,按照顺序一步步地探索	Python	语言。
如果示例看上去很简单,要有耐心	--	更刺激的东西还在后面。
我们以基本表达式作为开始。一种基本表达式就是数值。更精确地说,是你键入的,由	10	进
制数字表示的数值组成的表达式。
  >>>	42
  42
表达式表示的数值也许会和算数运算符组合,来形成复合表达式,解释器会求出它:
  >>>	-1	-	-1
  0
  >>>	1/2	+	1/4	+	1/8	+	1/16	+	1/32	+	1/64	+	1/128
  0.9921875
                                                   11
1.2	编程元素
这些算术表达式使用了中缀符号,其中运算符(例如 	+	、 	-	、 	*	、 	/	)出现在操作数(数
值)中间。Python包含许多方法来形成复合表达式。我们不会尝试立即将它们列举出来,而
是在进行中介绍新的表达式形式,以及它们支持的语言特性。
1.2.2	调用表达式
最重要的复合表达式就是调用表达式,它在一些参数上调用函数。回忆代数中,函数的数学
概念是一些输入值到输出值的映射。例如, 	max	函数将它的输入映射到单个输出,输出是输
入中的最大值。Python	中的函数不仅仅是输入输出的映射,它表述了计算过程。但是,
Python	表示函数的方式和数学中相同。
  >>>	max(7.5,	9.5)
  9.5
调用表达式拥有子表达式:运算符在圆括号之前,圆括号包含逗号分隔的操作数。运算符必
须是个函数,操作数可以是任何值。这里它们都是数值。当求解这个调用表达式时,我们
说 	max	函数以参数	7.5	和	9.5	调用,并且返回	9.5。
调用表达式中的参数的顺序极其重要。例如,函数 	pow	计算第一个参数的第二个参数次方。
  >>>	pow(100,	2)
  10000
  >>>	pow(2,	100)
  1267650600228229401496703205376
函数符号比中缀符号的数学惯例有很多优点。首先,函数可以接受任何数量的参数:
  >>>	max(1,	-2,	3,	-4)
  3
不会产生任何歧义,因为函数的名称永远在参数前面。
其次,函数符号可以以直接的方式扩展为嵌套表达式,其中元素本身是复合表达式。在嵌套
的调用表达式中,不像嵌套的中缀表达式,嵌套结构在圆括号中非常明显。
  >>>	max(min(1,	-2),	min(pow(3,	5),	-4))
  -2
(理论上)这种嵌套没有任何限制,并且	Python	解释器可以解释任何复杂的表达式。然而,
人们可能会被多级嵌套搞晕。你作为程序员的一个重要作用就是构造你自己、你的同伴以及
其它在未来可能会阅读你代码的人可以解释的表达式。
                                                   12
1.2	编程元素
最后,数学符号在形式上多种多样:星号表示乘法,上标表示乘方,横杠表示除法,屋顶和
侧壁表示开方。这些符号中一些非常难以打出来。但是,所有这些复杂事物可以通过调用表
达式的符号来统一。虽然	Python	通过中缀符号(比如 	+	和 	-	)支持常见的数学运算符,任
何运算符都可以表示为带有名字的函数。
1.2.3	导入库函数
Python	定义了大量的函数,包括上一节提到的运算符函数,但是通常不能使用它们的名字,
这样做是为了避免混乱。反之,它将已知的函数和其它东西组织在模块中,这些模块组成了
Python	库。需要导入它们来使用这些元素。例如, 	math	模块提供了大量的常用数学函数:
  >>>	from	math	import	sqrt,	exp
  >>>	sqrt(256)
  16.0
  >>>	exp(1)
  2.718281828459045
	operator	模块提供了中缀运算符对应的函数:
  >>>	from	operator	import	add,	sub,	mul
  >>>	add(14,	28)
  42
  >>>	sub(100,	mul(7,	add(8,	4)))
  16
	import	语句标明了模块名称(例如 	operator	或 	math	),之后列出被导入模块的具名属性
(例如 	sqrt	和 	exp	)。
Python	3	库文档列出了定义在每个模块中的函数,例如数学模块。然而,这个文档为了解整
个语言的开发者编写。到现在为止,你可能发现使用函数做实验会比阅读文档告诉你更多它
的行为。当你更熟悉	Python	语言和词汇时,这个文档就变成了一份有价值的参考来源。
1.2.4	名称和环境
编程语言的要素之一是它提供的手段,用于使用名称来引用计算对象。如果一个值被给予了
名称,我们就说这个名称绑定到了值上面。
在	Python	中,我们可以使用赋值语句来建立新的绑定,它包含 	=	左边的名称和右边的值。
  >>>	radius	=	10
  >>>	radius
  10
  >>>	2	*	radius
  20
名称也可以通过 	import	语句绑定:
                                                        13
1.2	编程元素
  >>>	from	math	import	pi
  >>>	pi	*	71	/	223
  1.0002380197528042
我们也可以在一个语句中将多个值赋给多个名称,其中名称和表达式由逗号分隔:
  >>>	area,	circumference	=	pi	*	radius	*	radius,	2	*	pi	*	radius
  >>>	area
  314.1592653589793
  >>>	circumference
  62.83185307179586
	=	符号在	Python(以及许多其它语言)中叫做赋值运算符。赋值是	Python	中的最简单的抽
象手段,因为它使我们可以使用最简单的名称来引用复合操作的结果,例如上面计算
的 	area	。这样,复杂的程序可以由复杂性递增的计算对象一步一步构建,
将名称绑定到值上,以及随后通过名称来检索这些值的可能,意味着解释器必须维护某种内
存来跟踪这些名称和值的绑定。这些内存叫做环境。
名称也可以绑定到函数。例如,名称 	max	绑定到了我们曾经用过的 	max	函数上。函数不像数
值,不易于渲染成文本,所以	Python	使用识别描述来代替,当我们打印函数时:
  >>>	max
  <built-in	function	max>
我们可以使用赋值运算符来给现有函数起新的名字:
  >>>	f	=	max
  >>>	f
  <built-in	function	max>
  >>>	f(3,	4)
  4
成功的赋值语句可以将名称绑定到新的值:
  >>>	f	=	2
  >>>	f
  2
在	Python	中,通过赋值绑定的名称通常叫做变量名称,因为它们在执行程序期间可以绑定到
许多不同的值上面。
1.2.5	嵌套表达式的求解
我们这章的目标之一是隔离程序化思考相关的问题。作为一个例子,考虑嵌套表达式的求
解,解释器自己会遵循一个过程:
                                                                  14
1.2	编程元素
为了求出调用表达式,Python	会执行下列事情:
    求出运算符和操作数子表达式,之后
    在值为操作数子表达式的参数上调用值为运算符子表达式的函数。
这个简单的过程大体上展示了一些过程上的重点。第一步表明为了完成调用表达式的求值过
程,我们首先必须求出其它表达式。所以,求值过程本质上是递归的,也就是说,它会调用
其自身作为步骤之一。
例如,求出
  >>>	mul(add(2,	mul(4,	6)),	add(3,	5))
  208
需要应用四次求值过程。如果我们将每个需要求解的表达式抽出来,我们可以可视化这一过
程的层次结构:
这个示例叫做表达式树。在计算机科学中,树从顶端向下生长。每一点上的对象叫做节点。
这里它们是表达式和它们的值。
求出根节点,也就是整个表达式,需要首先求出枝干节点,也就是子表达式。叶子节点(也
就是没有子节点的节点)的表达式表示函数或数值。内部节点分为两部分:表示我们想要应
用的求值规则的调用表达式,以及表达式的结果。观察这棵树中的求值,我们可以想象操作
数的值向上流动,从叶子节点开始,在更高的层上融合。
接下来,观察第一步的重复应用,这会将我们带到需要求值的地方,并不是调用表达式,而
是基本表达式,例如数字(比如 	2	),以及名称(比如 	add	),我们需要规定下列事物来谨
慎对待基本的东西:
1.2	编程元素
     数字求值为它标明的数值,
     名称求值为当前环境中这个名称所关联的值
要注意环境的关键作用是决定表达式中符号的含义。Python	中,在不指定任何环境信息,来
提供名称 	x	(以及名称 	add	)的含义的情况下,谈到这样一个表达式的值没有意义:
  >>>	add(x,	1)
环境提供了求值所发生的上下文,它在我们理解程序执行中起到重要作用。
这个求值过程并不符合所有	Python	代码的求解,仅仅是调用表达式、数字和名称。例如,它
并不能处理赋值语句。
  >>>	x	=	3
的执行并不返回任何值,也不求解任何参数上的函数,因为赋值的目的是将一个名称绑定到
一个值上。通常,语句不会被求值,而是被执行,它们不产生值,但是会改变一些东西。每
种语句或表达式都有自己的求值或执行过程,我们会在涉及时逐步介绍。
注:当我们说“数字求值为数值”的时候,我们的实际意思是	Python	解释器将数字求解为数
值。Python	的解释器使编程语言具有了这个意义。假设解释器是一个固定的程序,行为总是
一致,我们就可以说数字(以及表达式)自己在	Python	程序的上下文中会求解为值。
1.2.6	函数图解
当我们继续构建求值的形式模型时,我们会发现解释器内部状态的图解有助于我们跟踪求值
过程的发展。这些图解的必要部分是函数的表示。
纯函数:具有一些输入(参数)以及返回一些输出(调用结果)的函数。内建函数
  >>>	abs(-2)
  2
可以描述为接受输入并产生输出的小型机器。
	abs	是纯函数。纯函数具有一个特性,调用它们时除了返回一个值之外没有其它效果。
非纯函数:除了返回一个值之外,调用非纯函数会产生副作用,这会改变解释器或计算机的
一些状态。一个普遍的副作用就是在返回值之外生成额外的输出,例如使用 	print	函数:
                                              16
1.2	编程元素
  >>>	print(-2)
  -2
  >>>	print(1,	2,	3)
  1	2	3
虽然这些例子中的 	print	和 	abs	看起来很像,但它们本质上以不同方式工作。 	print	的返回
值永远是 	None	,它是一个	Python	特殊值,表示没有任何东西。Python	交互式解释器并不会
自动打印 	None	值。这里, 	print	自己打印了输出,作为调用中的副作用。
调用 	print	的嵌套表达式会凸显出它的非纯特性:
  >>>	print(print(1),	print(2))
  1
  2
  None	None
如果你发现自己不能预料到这个输出,画出表达式树来弄清为什么这个表达式的求值会产生
奇怪的输出。
要当心 	print	!它的返回值为 	None	,意味着它不应该在赋值语句中用作表达式:
  >>>	two	=	print(2)
  2
  >>>	print(two)
  None
签名:不同函数具有不同的允许接受的参数数量。为了跟踪这些必备条件,我们需要以一种
展示函数名称和参数名称的方式,画出每个函数。 	abs	函数值接受一个叫作 	number	的参数,
向它提供更多或更少的参数会产生错误。 	print	函数可以接受任意数量的参数,所以它渲染
为 	print(...)	。函数的可接受参数的描述叫做函数的签名。
1.3	定义新的函数
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
我们已经在	Python	中认识了一些在任何强大的编程语言中都会出现的元素:
 1.	 数值是内建数据,算数运算是函数。
 2.	 嵌套函数提供了组合操作的手段。
 3.	 名称到值的绑定提供了有限的抽象手段。
现在我们将要了解函数定义,一个更加强大的抽象技巧,名称通过它可以绑定到复合操作
上,并可以作为一个单元来引用。
我们通过如何表达“平方”这个概念来开始。我们可能会说,“对一个数求平方就是将这个数乘
上它自己”。在	Python	中就是:
  >>>	def	square(x):
  								return	mul(x,	x)
这定义了一个新的函数,并赋予了名称 	square	。这个用户定义的函数并不内建于解释器。它
表示将一个数乘上自己的复合操作。定义中的 	x	叫做形式参数,它为被乘的东西提供一个名
称。这个定义创建了用户定义的函数,并且将它关联到名称 	square	上。
函数定义包含 	def	语句,它标明了 	<name>	(名称)和一列带有名字
的 	<formal	parameters>	(形式参数)。之后, 	return	(返回)语句叫做函数体,指定了函
数的 	<return	expression>	(返回表达式),它是函数无论什么时候调用都需要求值的表达式。
  def	<name>(<formal	parameters>):
  				return	<return	expression>
第二行必须缩进!按照惯例我们应该缩进四个空格,而不是一个Tab,返回表达式并不是立即
求值,它储存为新定义函数的一部分,并且只在函数最终调用时会被求出。(很快我们就会
看到缩进区域可以跨越多行。)
定义了 	square	之后,我们使用调用表达式来调用它:
1.3	定义新的函数
  >>>	square(21)
  441
  >>>	square(add(2,	5))
  49
  >>>	square(square(3))
  81
我们也可以在构建其它函数时,将 	square	用作构建块。列入,我们可以轻易定
义 	sum_squares	函数,它接受两个数值作为参数,并返回它们的平方和:
  >>>	def	sum_squares(x,	y):
  								return	add(square(x),	square(y))
  >>>	sum_squares(3,	4)
  25
用户定义的函数和内建函数以同种方法使用。确实,我们不可能在 	sum_squares	的定义中分辨
出 	square	是否构建于解释器中,从模块导入还是由用户定义。
1.3.1	环境
我们的	Python	子集已经足够复杂了,但程序的含义还不是非常明显。如果形式参数和内建函
数具有相同名称会如何呢?两个函数是否能共享名称而不会产生混乱呢?为了解决这些疑
问,我们必须详细描述环境。
表达式求值所在的环境由帧的序列组成,它们可以表述为一些盒子。每一帧都包含了一些绑
定,它们将名称和对应的值关联起来。全局帧只有一个,它包含所有内建函数的名称绑定
(只展示了 	abs	和 	max	)。我们使用地球符号来表示全局。
赋值和导入语句会向当前环境的第一个帧添加条目。到目前为止,我们的环境只包含全局
帧。
  >>>	from	math	import	pi
  >>>	tau	=	2	*	pi
1.3	定义新的函数
	def	语句也将绑定绑定到由定义创建的函数上。定义 	square	之后的环境如图所示:
这些环境图示展示了当前环境中的绑定,以及它们所绑定的值(并不是任何帧的一部分)。
要注意函数名称是重复的,一个在帧中,另一个是函数的一部分。这一重复是有意的,许多
不同的名字可能会引用相同函数,但是函数本身只有一个内在名称。但是,在环境中由名称
检索值只检查名称绑定。函数的内在名称不在名称检索中起作用。在我们之前看到的例子
中:
  >>>	f	=	max
  >>>	f
  <built-in	function	max>
名称 	max	是函数的内在名称,以及打印 	f	时我们看到的名称。此外,名称 	max	和 	f	在全局
环境中都绑定到了相同函数上。
在我们介绍	Python	的附加特性时,我们需要扩展这些图示。每次我们这样做的时候,我们都
会列出图示可以表达的新特性。
新的环境特性:赋值和用户定义的函数定义。
1.3.2	调用用户定义的函数
1.3	定义新的函数
为了求出运算符为用户定义函数的调用表达式,Python	解释器遵循与求出运算符为内建函数
的表达式相似的过程。也就是说,解释器求出操作数表达式,并且对产生的实参调用具名函
数。
调用用户定义的函数的行为引入了第二个局部帧,它只能由函数来访问。为了对一些实参调
用用户定义的函数:
 1.	 在新的局部帧中,将实参绑定到函数的形式参数上。
 2.	 在当前帧的开头以及全局帧的末尾求出函数体。
函数体求值所在的环境由两个帧组成:第一个是局部帧,包含参数绑定,之后是全局帧,包
含其它所有东西。每个函数示例都有自己的独立局部帧。
这张图包含两个不同的	Python	解释器层面:当前的环境,以及表达式树的一部分,它和要求
值的代码的当前一行相关。我们描述了调用表达式的求值,用户定义的函数(蓝色)表示为
两部分的圆角矩形。点线箭头表示哪个环境用于在每个部分求解表达式。
     上半部分展示了调用表达式的求值。这个调用表达式并不在任何函数里面,所以他在全
     局环境中求值。所以,任何里面的名称(例如 	square	)都会在全局帧中检索。
     下半部分展示了 	square	函数的函数体。它的返回表达式在上面的步骤1引入的新环境中
     求值,它将 	square	的形式参数 	x	的名称绑定到实参的值 	-2	上。
环境中帧的顺序会影响由表达式中的名称检索返回的值。我们之前说名称求解为当前环境中
与这个名称关联的值。我们现在可以更精确一些:
     名称求解为当前环境中,最先发现该名称的帧中,绑定到这个名称的值。
1.3	定义新的函数
我们关于环境、名称和函数的概念框架建立了求值模型,虽然一些机制的细节仍旧没有指明
(例如绑定如何实现),我们的模型在描述解释器如何求解调用表示上,变得更准确和正
确。在第三章我们会看到这一模型如何用作一个蓝图来实现编程语言的可工作的解释器。
新的环境特性:函数调用。
1.3.3	示例:调用用户定义的函数
让我们再一次考虑两个简单的定义:
  >>>	from	operator	import	add,	mul
  >>>	def	square(x):
  								return	mul(x,	x)
  >>>	def	sum_squares(x,	y):
  								return	add(square(x),	square(y))
以及求解下列调用表达式的过程:
  >>>	sum_squares(5,	12)
Python	首先会求出名称 	sum_squares	,它在全局帧绑定了用户定义的函数。基本的数字表达
式	5	和	12	求值为它们所表达的数值。
之后,Python	调用了 	sum_squares	,它引入了局部帧,将 	x	绑定为	5,将 	y	绑定为	12。
1.3	定义新的函数
这张图中,局部帧指向它的后继,全局帧。所有局部帧必须指向某个先导,这些链接定义了
当前环境中的帧序列。
	sum_square	的函数体包含下列调用表达式:
  			add					(		square(x)		,		square(y)		)
  	________					_________					_________
  "operator"			"operand	0"			"operand	1"
全部三个子表达式在当前环境中求值,它开始于标记为 	sum_squares	的帧。运算符字表达
式 	add	是全局帧中发现的名称,绑定到了内建的加法函数上。两个操作数子表达式必须在加
法函数调用之前依次求值。两个操作数都在当前环境中求值,开始于标记为 	sum_squares	的
帧。在下面的环境图示中,我们把这一帧叫做 	A	,并且将指向这一帧的箭头同时替换为标
签 	A	。
在使用这个局部帧的情况下,函数体表达式 	mul(x,	x)	求值为	25。
我们的求值过程现在轮到了操作数	1, 	y	的值为	12。Python	再次求出 	square	的函数体。这
次引入了另一个局部环境帧,将 	x	绑定为	12。所以,操作数	1	求值为	144。
                                                      23
1.3	定义新的函数
最后,对实参	25	和	144	调用加法会产生 	sum_squares	函数体的最终值:169。
这张图虽然复杂,但是用于展示我们目前为止发展出的许多基础概念。名称绑定到值上面,
它延伸到许多局部帧中,局部帧在唯一的全局帧之上,全局帧包含共享名称。表达式为树形
结构,以及每次子表达式包含用户定义函数的调用时,环境必须被扩展。
所有这些机制的存在确保了名称在表达式中正确的地方解析为正确的值。这个例子展示了为
什么我们的模型需要所引入的复杂性。所有三个局部帧都包含名称 	x	的绑定。但是这个名称
在不同的帧中绑定到了不同的值上。局部帧分离了这些名称。
1.3.4	局部名称
函数实现的细节之一是实现者对形式参数名称的选择不应影响函数行为。所以,下面的函数
应具有相同的行为:
  >>>	def	square(x):
  								return	mul(x,	x)
  >>>	def	square(y):
  								return	mul(y,	y)
这个原则	--	也就是函数应不依赖于编写者选择的参数名称	--	对编程语言来说具有重要的结
果。最简单的结果就是函数参数名称应保留在函数体的局部范围中。
                                                  24
1.3	定义新的函数
如果参数不位于相应函数的局部范围中, 	square	的参数 	x	可能和 	sum_squares	中的参
数 	x	产生混乱。严格来说,这并不是问题所在:不同局部帧中的 	x	的绑定是不相关的。我们
的计算模型具有严谨的设计来确保这种独立性。
我们说局部名称的作用域被限制在定义它的用户定义函数的函数体中。当一个名称不能再被
访问时,它就离开了作用域。作用域的行为并不是我们模型的新事实,它是环境的工作方式
的结果。
1.3.5	实践指南:选择名称
可修改的名称并不代表形式参数的名称完全不重要。反之,选择良好的函数和参数名称对于
函数定义的人类可解释性是必要的。
下面的准则派生于	Python	的代码风格指南,可被所有(非反叛)Python	程序员作为指南。
一些共享的约定会使社区成员之间的沟通变得容易。遵循这些约定有一些副作用,我会发现
你的代码在内部变得一致。
 1.	 函数名称应该小写,以下划线分隔。提倡描述性的名称。
 2.	 函数名称通常反映解释器向参数应用的操作(例如 	print	、 	add	、 	square	),或者结
     果(例如 	max	、 	abs	、 	sum	)。
 3.	 参数名称应小写,以下划线分隔。提倡单个词的名称。
 4.	 参数名称应该反映参数在函数中的作用,并不仅仅是满足的值的类型。
 5.	 当作用非常明确时,单个字母的参数名称可以接受,但是永远不要使用 	l	(小写的 	L	)
     和 	O	(大写的 	o	),或者 	I	(大写的 	i	)来避免和数字混淆。
周期性对你编写的程序复查这些准则,不用多久你的名称会变得十分	Python	化。
1.3.6	作为抽象的函数
虽然 	sum_squares	十分简单,但是它演示了用户定义函数的最强大的特性。 	sum_squares	函数
使用 	square	函数定义,但是仅仅依赖于 	square	定义在输入参数和输出值之间的关系。
我们可以编写 	sum_squares	,而不用考虑如何计算一个数值的平方。平方计算的细节被隐藏
了,并可以在之后考虑。确实,在 	sum_squares	看来, 	square	并不是一个特定的函数体,而
是某个函数的抽象,也就是所谓的函数式抽象。在这个层级的抽象中,任何能计算平方的函
数都是等价的。
所以,仅仅考虑返回值的情况下,下面两个计算平方的函数是难以区分的。每个都接受数值
参数并且产生那个数的平方作为返回值。
1.3	定义新的函数
  >>>	def	square(x):
  								return	mul(x,	x)
  >>>	def	square(x):
  								return	mul(x,	x-1)	+	x
换句话说,函数定义应该能够隐藏细节。函数的用户可能不能自己编写函数,但是可以从其
它程序员那里获得它作为“黑盒”。用户不应该需要知道如何实现来调用。Python	库拥有这个
特性。许多开发者使用在这里定义的函数,但是很少有人看过它们的实现。实际上,许多
Python	库的实现并不完全用	Python	编写,而是	C	语言。
1.3.7	运算符
算术运算符(例如 	+	和 	-	)在我们的第一个例子中提供了组合手段。但是我们还需要为包含
这些运算符的表达式定义求值过程。
每个带有中缀运算符的	Python	表达式都有自己的求值过程,但是你通常可以认为他们是调用
表达式的快捷方式。当你看到
  >>>	2	+	3
  5
的时候,可以简单认为它是
  >>>	add(2,	3)
  5
的快捷方式。
中缀记号可以嵌套,就像调用表达式那样。Python	运算符优先级中采用了常规的数学规则,
它指导了如何解释带有多种运算符的复合表达式。
  >>>	2	+	3	*	4	+	5
  19
和下面的表达式的求值结果相同
  >>>	add(add(2,	mul(3,	4))	,	5)
  19
调用表达式的嵌套比运算符版本更加明显。Python	也允许括号括起来的子表达式,来覆盖通
常的优先级规则,或者使表达式的嵌套结构更加明显:
  >>>	(2	+	3)	*	(4	+	5)
  45
                                             26
1.3	定义新的函数
和下面的表达式的求值结果相同
  >>>	mul(add(2,	3),	add(4,	5))
  45
你应该在你的程序中自由使用这些运算符和括号。对于简单的算术运算,Python	在惯例上倾
向于运算符而不是调用表达式。
                                           27
1.4	实践指南:函数的艺术
1.4	实践指南:函数的艺术
   来源:1.4	Practical	Guidance:	The	Art	of	the	Function
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
函数是所有程序的要素,无论规模大小,并且在编程语言中作为我们表达计算过程的主要媒
介。目前为止,我们讨论了函数的形式特性,以及它们如何使用。我们现在跳转到如何编写
良好的函数这一话题。
    每个函数都应该只做一个任务。这个任务可以使用短小的名称来定义,使用一行文本来
    标识。顺序执行多个任务的函数应该拆分在多个函数中。
    不要重复劳动(DRY)是软件工程的中心法则。所谓的DRY原则规定多个代码段不应该
    描述重复的逻辑。反之,逻辑应该只实现一次,指定一个名称,并且多次使用。如果你
    发现自己在复制粘贴一段代码,你可能发现了一个使用函数抽象的机会。
    函数应该定义得通常一些,准确来说,平方并不是在	Python	库中,因为它是 	pow	函数的
    一个特例,这个函数计算任何数的任何次方。
这些准则提升代码的可读性,减少错误数量,并且通常使编写的代码总数最小。将复杂的任
务拆分为简洁的函数是一个技巧,它需要一些经验来掌握。幸运的是,Python	提供了一些特
性来支持你的努力。
1.4.1	文档字符串
函数定义通常包含描述这个函数的文档,叫做文档字符串,它必须在函数体中缩进。文档字
符串通常使用三个引号。第一行描述函数的任务。随后的一些行描述参数,并且澄清函数的
行为:
  >>>	def	pressure(v,	t,	n):
  								"""Compute	the	pressure	in	pascals	of	an	ideal	gas.
  								Applies	the	ideal	gas	law:	http://en.wikipedia.org/wiki/Ideal_gas_law
  								v	--	volume	of	gas,	in	cubic	meters
  								t	--	absolute	temperature	in	degrees	kelvin
  								n	--	particles	of	gas
  								"""
  								k	=	1.38e-23		#	Boltzmann's	constant
  								return	n	*	k	*	t	/	v
当你以函数名称作为参数来调用 	help	时,你会看到它的文档字符串(按下 	q	来退出	Python
帮助)。
                                                                                28
1.4	实践指南:函数的艺术
  >>>	help(pressure)
编写	Python	程序时,除了最简单的函数之外,都要包含文档字符串。要记住,代码只编写一
次,但是会阅读多次。Python	文档包含了文档字符串准则,它在不同的	Python	项目中保持
一致。
1.4.2	参数默认值
定义普通函数的结果之一就是额外参数的引入。具有许多参数的函数调用起来非常麻烦,也
难以阅读。
在Python中,我们可以为函数的参数提供默认值。调用这个函数时,带有默认值的参数是可
选的。如果它们没有提供,默认值就会绑定到形式参数的名称上。例如,如果某个应用通常
用来计算一摩尔粒子的压强,这个值就可以设为默认:
  >>>	k_b=1.38e-23		#	Boltzmann's	constant
  >>>	def	pressure(v,	t,	n=6.022e23):
  								"""Compute	the	pressure	in	pascals	of	an	ideal	gas.
  								v	--	volume	of	gas,	in	cubic	meters
  								t	--	absolute	temperature	in	degrees	kelvin
  								n	--	particles	of	gas	(default:	one	mole)
  								"""
  								return	n	*	k_b	*	t	/	v
  >>>	pressure(1,	273.15)
  2269.974834
这里,pressure	的定义接受三个参数,但是在调用表达式中只提供了两个。这种情况
下,n的值通过 	def	语句的默认值获得(它看起来像对 	n	的赋值,虽然就像这个讨论暗示
的那样,更大程度上它是条件赋值)。
作为准则,用于函数体的大多数数据值应该表示为具名参数的默认值,这样便于查看,以及
被函数调用者修改。一些值永远不会改变,就像基本常数 	k_b	,应该定义在全局帧中。
                                                              29
1.5	控制
1.5	控制
   来源:1.5	Control
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
我们现在可以定义的函数能力有限,因为我们还不知道一种方法来进行测试,并且根据测试
结果来执行不同的操作。控制语句可以让我们完成这件事。它们不像严格的求值子表达式那
样从左向右编写,并且可以从它们控制解释器下一步做什么当中得到它们的名称。这可能基
于表达式的值。
1.5.1	语句
目前为止,我们已经初步思考了如何求出表达式。然而,我们已经看到了三种语句:赋
值、 	def	和 	return	语句。这些	Python	代码并不是表达式,虽然它们中的一部分是表达式。
要强调的是,语句的值是不相干的(或不存在的),我们使用执行而不是求值来描述语句。
每个语句都描述了对解释器状态的一些改变,执行语句会应用这些改变。像我们之前看到
的 	return	和赋值语句那样,语句的执行涉及到求解所包含的子表达式。
表达式也可以作为语句执行,其中它们会被求值,但是它们的值会舍弃。执行纯函数没有什
么副作用,但是执行非纯函数会产生效果作为函数调用的结果。
考虑下面这个例子:
  >>>	def	square(x):
  								mul(x,	x)	#	Watch	out!	This	call	doesn't	return	a	value.
这是有效的	Python	代码,但是并不是想表达的意思。函数体由表达式组成。表达式本身是个
有效的语句,但是语句的效果是, 	mul	函数被调用了,然后结果被舍弃了。如果你希望对表
达式的结果做一些事情,你需要这样做:使用赋值语句来储存它,或者使用 	return	语句将它
返回:
  >>>	def	square(x):
  								return	mul(x,	x)
有时编写一个函数体是表达式的函数是有意义的,例如调用类似 	print	的非纯函数:
  >>>	def	print_square(x):
  								print(square(x))
                                                                   30
1.5	控制
在最高层级上,Python	解释器的工作就是执行由语句组成的程序。但是,许多有意思的计算
工作来源于求解表达式。语句管理程序中不同表达式之间的关系,以及它们的结果会怎么
样。
1.5.2	复合语句
通常,Python	的代码是语句的序列。一条简单的语句是一行不以分号结束的代码。复合语句
之所以这么命名,因为它是其它(简单或复合)语句的复合。复合语句一般占据多行,并且
以一行以冒号结尾的头部开始,它标识了语句的类型。同时,一个头部和一组缩进的代码叫
做子句(或从句)。复合语句由一个或多个子句组成。
  <header>:
  				<statement>
  				<statement>
  				...
  <separating	header>:
  				<statement>
  				<statement>
  				...
  ...
我们可以这样理解我们已经见到的语句:
    表达式、返回语句和赋值语句都是简单语句。
     	def	语句是复合语句。 	def	头部之后的组定义了函数体。
为每种头部特化的求值规则指导了组内的语句什么时候以及是否会被执行。我们说头部控制
语句组。例如,在 	def	语句的例子中,我们看到返回表达式并不会立即求值,而是储存起来
用于以后的使用,当所定义的函数最终调用时就会求值。
我们现在也能理解多行的程序了。
    执行语句序列需要执行第一条语句。如果这个语句不是重定向控制,之后执行语句序列
    的剩余部分,如果存在的话。
这个定义揭示出递归定义“序列”的基本结构:一个序列可以划分为它的第一个元素和其余元
素。语句序列的“剩余”部分也是一个语句序列。所以我们可以递归应用这个执行规则。这个序
列作为递归数据结构的看法会在随后的章节中再次出现。
这一规则的重要结果就是语句顺序执行,但是随后的语句可能永远不会执行到,因为有重定
向控制。
实践指南:在缩进代码组时,所有行必须以相同数量以及相同方式缩进(空格而不是Tab)。
任何缩进的变动都会导致错误。
1.5.3	定义函数	II:局部赋值
                                            31
1.5	控制
一开始我们说,用户定义函数的函数体只由带有一个返回表达式的一个返回语句组成。实际
上,函数可以定义为操作的序列,不仅仅是一条表达式。Python	复合语句的结构自然让我们
将函数体的概念扩展为多个语句。
无论用户定义的函数何时被调用,定义中的子句序列在局部环境内执行。 	return	语句会重定
向控制:无论什么时候执行 	return	语句,函数调用的流程都会中止,返回表达式的值会作为
被调用函数的返回值。
于是,赋值语句现在可以出现在函数体中。例如,这个函数以第一个数的百分数形式,返回
两个数量的绝对值,并使用了两步运算:
  >>>	def	percent_difference(x,	y):
  								difference	=	abs(x-y)
  								return	100	*	difference	/	x
  >>>	percent_difference(40,	50)
  25.0
赋值语句的效果是在当前环境的第一个帧上,将名字绑定到值上。于是,函数体内的赋值语
句不会影响全局帧。函数只能操作局部作用域的现象是创建模块化程序的关键,其中纯函数
只通过它们接受和返回的值与外界交互。
当然, 	percent_difference	函数也可以写成一个表达式,就像下面这样,但是返回表达式会
更加复杂:
  >>>	def	percent_difference(x,	y):
  								return	100	*	abs(x-y)	/	x
目前为止,局部赋值并不会增加函数定义的表现力。当它和控制语句组合时,才会这样。此
外,局部赋值也可以将名称赋为间接量,在理清复杂表达式的含义时起到关键作用。
新的环境特性:局部赋值。
1.5.4	条件语句
Python	拥有内建的绝对值函数:
  >>>	abs(-2)
  2
我们希望自己能够实现这个函数,但是我们当前不能直接定义函数来执行测试并做出选择。
我们希望表达出,如果 	x	是正的, 	abs(x)	返回 	x	,如果 	x	是	0, 	abx(x)	返回	0,否
则 	abs(x)	返回 	-x	。Python	中,我们可以使用条件语句来表达这种选择。
                                                            32
1.5	控制
  >>>	def	absolute_value(x):
  								"""Compute	abs(x)."""
  								if	x	>	0:
  												return	x
  								elif	x	==	0:
  												return	0
  								else:
  												return	-x
  >>>	absolute_value(-2)	==	abs(-2)
  True
	absolute_value	的实现展示了一些重要的事情:
条件语句。Python	中的条件语句包含一系列的头部和语句组:一个必要的 	if	子句,可选
的 	elif	子句序列,和最后可选的 	else	子句:
  if	<expression>:
  				<suite>
  elif	<expression>:
  				<suite>
  else:
  				<suite>
当执行条件语句时,每个子句都按顺序处理:
 1.	 求出头部中的表达式。
 2.	 如果它为真,执行语句组。之后,跳过条件语句中随后的所有子句。
如果能到达 	else	子句(仅当所有 	if	和 	elif	表达式值为假时),它的语句组才会被执行。
布尔上下文。上面过程的执行提到了“假值”和“真值”。条件块头部语句中的表达式也叫作布尔
上下文:它们值的真假对控制流很重要,但在另一方面,它们的值永远不会被赋值或返回。
Python	包含了多种假值,包括	0、 	None	和布尔值 	False	。所有其他数值都是真值。在第二
章中,我们就会看到每个	Python	中的原始数据类型都是真值或假值。
布尔值。Python	有两种布尔值,叫做 	True	和 	False	。布尔值表示了逻辑表达式中的真值。
内建的比较运算符, 	>	、 	<	、 	>=	、 	<=	、 	==	、 	!=	,返回这些值。
  >>>	4	<	2
  False
  >>>	5	>=	5
  True
第二个例子读作“5	大于等于	5”,对应 	operator	模块中的函数 	ge	。
  >>>	0	==	-0
  True
最后的例子读作“0	等于	-0”,对应 	operator	模块的 	eq	函数。要注意	Python	区分赋值
( 	=	)和相等测试( 	==	)。许多语言中都有这个惯例。
                                                         33
1.5	控制
布尔运算符。Python	也内建了三个基本的逻辑运算符:
  >>>	True	and	False
  False
  >>>	True	or	False
  True
  >>>	not	False
  True
逻辑表达式拥有对应的求值过程。这些过程揭示了逻辑表达式的真值有时可以不执行全部子
表达式而确定,这个特性叫做短路。
为了求出表达式 	<left>	and	<right>	:
 1.	 求出子表达式 	<left>	。
 2.	 如果结果 	v	是假值,那么表达式求值为 	v	。
 3.	 否则表达式的值为子表达式 	<right>	。
为了求出表达式 	<left>	or	<right>	:
 1.	 求出子表达式 	<left>	。
 2.	 如果结果 	v	是真值,那么表达式求值为 	v	。
 3.	 否则表达式的值为子表达式 	<right>	。
为了求出表达式 	not	<exp>	:
 1.	 求出 	<exp>	,如果值是 	True	那么返回值是假值,如果为 	False	则反之。
这些值、规则和运算符向我们提供了一种组合测试结果的方式。执行测试以及返回布尔值的
函数通常以 	is	开头,并不带下划线(例如 	isfinite	、 	isdigit	、 	isinstance	等等)。
1.5.5	迭代
除了选择要执行的语句,控制语句还用于表达重复操作。如果我们编写的每一行代码都只执
行一次,程序会变得非常没有生产力。只有通过语句的重复执行,我们才可以释放计算机的
潜力,使我们更加强大。我们已经看到了重复的一种形式:一个函数可以多次调用,虽然它
只定义一次。迭代控制结构是另一种将相同语句执行多次的机制。
考虑斐波那契数列,其中每个数值都是前两个的和:
  0,	1,	1,	2,	3,	5,	8,	13,	21,	...
每个值都通过重复使用“前两个值的和”的规则构造。为了构造第	n	个值,我们需要跟踪我们创
建了多少个值( 	k	),以及第	k	个值( 	curr	)和它的上一个值( 	pred	),像这样:
                                                               34
1.5	控制
  >>>	def	fib(n):
  								"""Compute	the	nth	Fibonacci	number,	for	n	>=	2."""
  								pred,	curr	=	0,	1			#	Fibonacci	numbers
  								k	=	2															#	Position	of	curr	in	the	sequence
  								while	k	<	n:
  												pred,	curr	=	curr,	pred	+	curr		#	Re-bind	pred	and	curr
  												k	=	k	+	1																							#	Re-bind	k
  								return	curr
  >>>	fib(8)
  13
要记住逗号在赋值语句中分隔了多个名称和值。这一行:
  pred,	curr	=	curr,	pred	+	curr
具有将 	curr	的值重新绑定到名称 	pred	上,以及将 	pred	+	curr	的值重新绑定到 	curr	上的效
果。所有 	=	右边的表达式会在绑定发生之前求出来。
	while	子句包含一个头部表达式,之后是语句组:
  while	<expression>:
  				<suite>
为了执行 	while	子句:
 1.	 求出头部表达式。
 2.	 如果它为真,执行语句组,之后返回到步骤	1。
在步骤	2	中,整个 	while	子句的语句组在头部表达式再次求值之前被执行。
为了防止 	while	子句的语句组无限执行,它应该总是在每次通过时修改环境的状态。
不终止的 	while	语句叫做无限循环。按下 	<Control>-C	可以强制让	Python	停止循环。
1.5.6	实践指南:测试
函数的测试是验证函数的行为是否符合预期的操作。我们的函数现在已经足够复杂了,我们
需要开始测试我们的实现。
测试是系统化执行这个验证的机制。测试通常写为另一个函数,这个函数包含一个或多个被
测函数的样例调用。返回值之后会和预期结果进行比对。不像大多数通用的函数,测试涉及
到挑选特殊的参数值,并使用它来验证调用。测试也可作为文档:它们展示了如何调用函
数,以及什么参数值是合理的。
要注意我们也将“测试”这个词用于 	if	或 	while	语句的头部中作为一种技术术语。当我们
将“测试”这个词用作表达式,或者用作一种验证机制时,它应该在语境中十分明显。
                                                                      35
1.5	控制
断言。程序员使用 	assert	语句来验证预期,例如测试函数的输出。 	assert	语句在布尔上下
文中只有一个表达式,后面是带引号的一行文本(单引号或双引号都可以,但是要一致)如
果表达式求值为假,它就会显示。
  >>>	assert	fib(8)	==	13,	'The	8th	Fibonacci	number	should	be	13'
当被断言的表达式求值为真时,断言语句的执行没有任何效果。当它是假时, 	asset	会造成
执行中断。
为 	fib	编写的 	test	函数测试了几个参数,包含 	n	的极限值:
  >>>	def	fib_test():
  								assert	fib(2)	==	1,	'The	2nd	Fibonacci	number	should	be	1'
  								assert	fib(3)	==	1,	'The	3nd	Fibonacci	number	should	be	1'
  								assert	fib(50)	==	7778742049,	'Error	at	the	50th	Fibonacci	number'
在文件中而不是直接在解释器中编写	Python	时,测试可以写在同一个文件,或者后缀
为 	_test.py	的相邻文件中。
Doctest。Python	提供了一个便利的方法,将简单的测试直接写到函数的文档字符串内。文
档字符串的第一行应该包含单行的函数描述,后面是一个空行。参数和行为的详细描述可以
跟随在后面。此外,文档字符串可以包含调用该函数的简单交互式会话:
  >>>	def	sum_naturals(n):
  								"""Return	the	sum	of	the	first	n	natural	numbers
  								>>>	sum_naturals(10)
  								55
  								>>>	sum_naturals(100)
  								5050
  								"""
  								total,	k	=	0,	1
  								while	k	<=	n:
  										total,	k	=	total	+	k,	k	+	1
  								return	total
之后,可以使用	doctest	模块来验证交互。下面的 	globals	函数返回全局变量的表示,解释器
需要它来求解表达式。
  >>>	from	doctest	import	run_docstring_examples
  >>>	run_docstring_examples(sum_naturals,	globals())
在文件中编写	Python	时,可以通过以下面的命令行选项启动	Python	来运行一个文档中的所
有	doctest。
  python3	-m	doctest	<python_source_file>
                                                                             36
1.5	控制
高效测试的关键是在实现新的函数之后(甚至是之前)立即编写(以及执行)测试。只调用
一个函数的测试叫做单元测试。详尽的单元测试是良好程序设计的标志。
                                        37
1.6	高阶函数
1.6	高阶函数
   来源:1.6	Higher-Order	Functions
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
我们已经看到,函数实际上是描述复合操作的抽象,这些操作不依赖于它们的参数值。
在 	square	中,
  >>>	def	square(x):
  								return	x	*	x
我们不会谈论特定数值的平方,而是一个获得任何数值平方的方法。当然,我们可以不定义
这个函数来使用它,通过始终编写这样的表达式:
  >>>	3	*	3
  9
  >>>	5	*	5
  25
并且永远不会显式提及 	square	。这种实践适合类似 	square	的简单操作。但是对于更加复杂
的操作会变得困难。通常,缺少函数定义会对我们非常不利,它会强迫我们始终工作在特定
操作的层级上,这在语言中非常原始(这个例子中是乘法),而不是高级操作。我们应该从
强大的编程语言索取的东西之一,是通过将名称赋为常用模式来构建抽象的能力,以及之后
直接使用抽象的能力。函数提供了这种能力。
我们将会在下个例子中看到,代码中会反复出现一些常见的编程模式,但是使用一些不同函
数来实现。这些模式也可以被抽象和给予名称。
为了将特定的通用模式表达为具名概念,我们需要构造可以接受其他函数作为参数的函数,
或者将函数作为返回值的函数。操作函数的函数叫做高阶函数。这一节展示了高阶函数可用
作强大的抽象机制,极大提升语言的表现力。
** 操作函数的函数叫做高阶函数
1.6.1	作为参数的函数
考虑下面三个函数,它们都计算总和。第一个, 	sum_naturals	,计算截至 	n	的自然数的和:
                                                   38
1.6	高阶函数
  >>>	def	sum_naturals(n):
  								total,	k	=	0,	1
  								while	k	<=	n:
  												total,	k	=	total	+	k,	k	+	1
  								return	total
  >>>	sum_naturals(100)
  5050
第二个, 	sum_cubes	,计算截至 	n	的自然数的立方和:
  >>>	def	sum_cubes(n):
  								total,	k	=	0,	1
  								while	k	<=	n:
  												total,	k	=	total	+	pow(k,	3),	k	+	1
  								return	total
  >>>	sum_cubes(100)
  25502500
第三个,计算这个级数中式子的和:
它会慢慢收敛于 	pi	。
  >>>	def	pi_sum(n):
  								total,	k	=	0,	1
  								while	k	<=	n:
  												total,	k	=	total	+	8	/	(k	*	(k	+	2)),	k	+	4
  								return	total
  >>>	pi_sum(100)
  3.121594652591009
这三个函数在背后都具有相同模式。它们大部分相同,只是名字、用于计算被加项的 	k	的函
数,以及提供 	k	的下一个值的函数不同。我们可以通过向相同的模板中填充槽位来生成每个
函数:
  def	<name>(n):
  				total,	k	=	0,	1
  				while	k	<=	n:
  								total,	k	=	total	+	<term>(k),	<next>(k)
  				return	total
这个通用模板的出现是一个强有力的证据,证明有一个实用抽象正在等着我们表现出来。这
些函数的每一个都是式子的求和。作为程序的设计者,我们希望我们的语言足够强大,便于
我们编写函数来自我表达求和的概念,而不仅仅是计算特定和的函数。我们可以在Python中
使用上面展示的通用模板,并且把槽位变成形式参数来轻易完成它。
>>>	def	summation(n,	term,	next):
total,	k	=	0,	1
while	k	<=	n:
total,	k	=	total	+	term(k),	next(k)
return	total
1.6	高阶函数
要注意summation接受上界n,以及函数term	和next作为参数。我们可以像任何函数那样
使用 summation	,它简洁地表达了求和。
>>>	def	cube(k):
return	pow(k,	3)
  >>>	def	successor(k):
  								return	k	+	1
  >>>	def	sum_cubes(n):
  								return	summation(n,	cube,	successor)
  >>>	sum_cubes(3)
使用 	identity	函数来返回参数自己,我们就可以对整数求和:
  >>>	def	identity(k):
  return	k
  >>>	def	sum_naturals(n):
  return	summation(n,	identity,	successor)
  >>>	sum_naturals(10)
  55
我们也可以逐步定义 	pi_sum	,使用我们的 	summation	抽象来组合组件。
  >>>	def	pi_term(k):
  								denominator	=	k	*	(k	+	2)
  								return	8	/	denominator
  >>>	def	pi_next(k):
  								return	k	+	4
  >>>	def	pi_sum(n):
  								return	summation(n,	pi_term,	pi_next)
  >>>	pi_sum(1e6)
  3.1415906535898936
1.6.2	作为一般方法的函数
我们引入的用户定义函数作为一种数值运算的抽象模式,便于使它们独立于涉及到的特定数
值。使用高阶函数,我们开始寻找更强大的抽象类型:一些函数表达了计算的一般方法,独
立于它们调用的特定函数。
尽管函数的意义在概念上扩展了,我们对于如何求解调用表达式的环境模型也优雅地延伸到
了高阶函数,没有任何改变。当一个用户定义函数以一些实参调用时,形式参数会在最新的
局部帧中绑定实参的值(它们可能是函数)。
考虑下面的例子,它实现了迭代改进的一般方法,并且可以用于计算黄金比例。迭代改进算
法以一个方程的解的guess(推测值)开始。它重复调用 	update	函数来改进这个推测值,并
且调用test	来检查是否当前的guess	“足够接近”所认为的正确值。
  >>>	def	iter_improve(update,	test,	guess=1):
  								while	not	test(guess):
  												guess	=	update(guess)
  								return	guess
1.6	高阶函数
	test	函数通常检查两个函数 	f	和 	g	在 	guess	值上是否彼此接近。测试 	f(x)	是否接近
于 	g(x)	也是计算的一般方法。
  >>>	def	near(x,	f,	g):
  								return	approx_eq(f(x),	g(x))
程序中测试相似性的一个常见方式是将数值差的绝对值与一个微小的公差值相比:
  >>>	def	approx_eq(x,	y,	tolerance=1e-5):
  								return	abs(x	-	y)	<	tolerance
黄金比例,通常叫做 	phi	,是经常出现在自然、艺术、和建筑中的数值。它可以通
过 	iter_improve	使用 	golden_update	来计算,并且在它的后继等于它的平方时收敛。
  >>>	def	golden_update(guess):
  								return	1/guess	+	1
  >>>	def	golden_test(guess):
  								return	near(guess,	square,	successor)
这里,我们已经向全局帧添加了多个绑定。函数值的描述为了简短而有所删节:
使用 	golden_update	和 	golden_test	参数来调用 	iter_improve	会计算出黄金比例的近似值。
  >>>	iter_improve(golden_update,	golden_test)
  1.6180371352785146
通过跟踪我们的求值过程的步骤,我们就可以观察结果如何计算。首先, 	iter_improve	的局
部帧以update	、 	test	和 	guess	构建。在 	iter_improve	的函数体中,名称 	test	绑定
到golden_test	上,它在初始值 	guess	上调用。之后, 	golden_test	调用 	near	,创建第三个
局部帧,它将形式参数 	f	和 	g	绑定到 	square	和 	successor	上。
                                                                   41
1.6	高阶函数
完成near	的求值之后,我们看到 	golden_test	为 	False	,因为	1	并不非常接近于	2。所
以, 	while	子句代码组内的求值过程,以及这个机制的过程会重复多次。
这个扩展后的例子展示了计算机科学中两个相关的重要概念。首先,命名和函数允许我们抽
象而远离大量的复杂性。当每个函数定义不重要时,由求值过程触发的计算过程是相当复杂
的,并且我们甚至不能展示所有东西。其次,基于事实,我们拥有了非常通用的求值过程,
小的组件组合在复杂的过程中。理解这个过程便于我们验证和检查我们创建的程序。
像通常一样,我们的新的一般方法 	iter_improve	需要测试来检查正确性。黄金比例可以提供
这样一个测试,因为它也有一个闭式解,我们可以将它与迭代结果进行比较。
  >>>	phi	=	1/2	+	pow(5,	1/2)/2
  >>>	def	near_test():
  								assert	near(phi,	square,	successor),	'phi	*	phi	is	not	near	phi	+	1'
  >>>	def	iter_improve_test():
  								approx_phi	=	iter_improve(golden_update,	golden_test)
  								assert	approx_eq(phi,	approx_phi),	'phi	differs	from	its	approximation'
新的环境特性:高阶函数。
附加部分:我们在测试的证明中遗漏了一步。求出公差值 	e	的范围,使得如
果 	tolerance	为 	e	的 	near(x,	square,	successor)	值为真,那么使用相同公差值
的 	approx_eq(phi,	x)	值为真。
1.6.3	定义函数	III:嵌套定义
上面的例子演示了将函数作为参数传递的能力如何提高了编程语言的表现力。每个通用的概
念或方程都能映射为自己的小型函数,这一方式的一个负面效果是全局帧会被小型函数弄
乱。另一个问题是我们限制于特定函数的签名: 	iter_improve	的update	参数必须只接受一个
参数。Python	中,嵌套函数的定义解决了这些问题,但是需要我们重新修改我们的模型。
让我们考虑一个新问题:计算一个数的平方根。重复调用下面的更新操作会收敛于 	x	的平方
根:
  >>>	def	average(x,y):
  				return	(x	+	y)/2
  >>>	def	sqrt_update(guess,	x):
  				return	average(guess,	x/guess)
这个带有两个参数的更新函数和 	iter_improve	不兼容,并且它只提供了一个介值。我们实际
上只关心最后的平方根。这些问题的解决方案是把函数放到其他定义的函数体中。
  >>>	def	square_root(x):
  								def	update(guess):
  												return	average(guess,	x/guess)
  								def	test(guess):
  												return	approx_eq(square(guess),	x)
  								return	iter_improve(update,	test)
就像局部赋值,局部的 	def	语句仅仅影响当前的局部帧。这些函数仅仅当 	square_root	求值
时在作用域内。和求值过程一致,局部的 	def	语句在 	square_root	调用之前并不会求值。
词法作用域。局部定义的函数也可以访问它们定义所在作用域的名称绑定。这个例子
中, 	update	引用了名称 	x	,它是外层函数 	square_root	的一个形参。这种在嵌套函数中共享
名称的规则叫做词法作用域。严格来说,内部函数能够访问定义所在环境(而不是调用所在
位置)的名称。
我们需要两个对我们环境的扩展来兼容词法作用域。
 1.	 每个用户定义的函数都有一个关联环境:它的定义所在的环境。
 2.	 当一个用户定义的函数调用时,它的局部帧扩展于函数所关联的环境。
回到 	square_root	,所有函数都在全局环境中定义,所以它们都关联到全局环境,当我们求
解 	square_root	的前两个子句时,我们创建了关联到局部环境的函数。在
  >>>	square_root(256)
  16.00000000000039
的调用中,环境首先添加了 	square_root	的局部帧,并且求出 	def	语句 	update	和 	test	(只
展示了 	update	):
                                                              43
1.6	高阶函数
随后, 	update	的名称解析到这个新定义的函数上,它是向 	iter_improve	传入的参数。
在 	iter_improve	的函数体中,我们必须以初始值	1	调用 	update	函数。最后的这个调用以一
开始只含有 	g	的局部帧创建了 	update	的环境,但是之前的 	square_root	帧上仍旧含有 	x	的
绑定。
这个求值过程中,最重要的部分是函数所关联的环境变成了局部帧,它是函数求值的地方。
这个改变在图中以蓝色箭头高亮。
                                                           44
1.6	高阶函数
以这种方式, 	update	的函数体能够解析名称 	x	。所以我们意识到了词法作用域的两个关键
优势。
     局部函数的名称并不影响定义所在函数外部的名称,因为局部函数的名称绑定到了定义
     处的当前局部环境中,而不是全局环境。
     局部函数可以访问外层函数的环境。这是因为局部函数的函数体的求值环境扩展于定义
     处的求值环境。
	update	函数自带了一些数据:也就是在定义处环境中的数据。因为它以这种方式封装信息,
局部定义的函数通常叫做闭包。
新的环境特性:局部函数定义。
1.6.4	作为返回值的函数
我们的程序可以通过创建返回值是它们本身的函数,获得更高的表现力。带有词法作用域的
编程语言的一个重要特性就是,局部定义函数在它们返回时仍旧持有所关联的环境。下面的
例子展示了这一特性的作用。
在定义了许多简单函数之后, 	composition	是包含在我们的编程语言中的自然组合法。也就是
说,提供两个函数 	f(x)	和 	g(x)	,我们可能希望定义 	h(x)	=	f(g(x))	。我们可以使用现有工
具来定义复合函数:
  >>>	def	compose1(f,	g):
  								def	h(x):
  												return	f(g(x))
  								return	h
  >>>	add_one_and_square	=	compose1(square,	successor)
  >>>	add_one_and_square(12)
  169
	compose1	中的 	1	表明复合函数和返回值都只接受一个参数。这种命名惯例并不由解释器强
制, 	1	只是函数名称的一部分。
这里,我们开始观察我们在计算的复杂模型中投入的回报。我们的环境模型不需要任何修改
就能支持以这种方式返回函数的能力。
1.6.5	Lambda	表达式
目前为止,每次我们打算定义新的函数时,我们都会给它一个名称。但是对于其它类型的表
达式,我们不需要将一个间接产物关联到名称上。也就是说,我们可以计算 	a*b	+	c*d	,而
不需要给子表达式 	a*b	或 	c*d	,或者整个表达式来命名。Python	中,我们可以使用	Lambda
表达式凭空创建函数,它会求值为匿名函数。Lambda	表达式是函数体具有单个返回表达式的
函数,不允许出现赋值和控制语句。
                                                          45
1.6	高阶函数
Lambda	表达式十分受限:它们仅仅可用于简单的单行函数,求解和返回一个表达式。在它们
适用的特殊情形中,Lambda	表达式具有强大的表现力。
  >>>	def	compose1(f,g):
  								return	lambda	x:	f(g(x))
我们可以通过构造相应的英文语句来理解	Lambda	表达式:
  					lambda												x												:										f(g(x))
  "A	function	that				takes	x				and	returns					f(g(x))"
一些程序员发现使用	Lambda	表达式作为匿名函数非常简短和直接。但是,复合的	Lambda
表达式非常难以辨认,尽管它们很简洁。下面的定义是是正确的,但是许多程序员不能很快
地理解它:
  >>>	compose1	=	lambda	f,g:	lambda	x:	f(g(x))
通常,Python	的代码风格倾向于显式的 	def	语句而不是	Lambda	表达式,但是允许它们在简
单函数作为参数或返回值的情况下使用。
这种风格规范不是准则,你可以想怎么写就怎么写,但是,在你编写程序时,要考虑某一天
可能会阅读你的程序的人们。如果你可以让你的程序更易于理解,你就帮了人们一个忙。
Lambda	的术语是一个历史的偶然结果,来源于手写的数学符号和早期打字系统限制的不兼
容。
   使用	lambda	来引入过程或函数看起来是不正当的。这个符号要追溯到	Alonzo	Church,
   他在	20	世纪	30	年代开始使用“帽子”符号;他把平方函数记为 	ŷ	.	y	×	y	。但是失败的
   打字员将这个帽子移到了参数左边,并且把它改成了大写的	lambda: 	Λy	.	y	×	y	;之
   后大写的	lambda	就变成了小写,现在我们就会在数学书里看到 	λy	.	y	×	y	,以及在
   Lisp	里看到 	(lambda	(y)	(*	y	y))	。
   --	Peter	Norvig	(norvig.com/lispy2.html)
尽管它的词源不同寻常,Lambda	表达式和函数调用相应的形式语言,以及	Lambda	演算都
成为了计算机科学概念的基础,并在	Python	编程社区广泛传播。当我们学习解释器的设计
时,我们将会在第三章中重新碰到这个话题。
1.6.6	示例:牛顿法
最后的扩展示例展示了函数值、局部定义和	Lambda	表达式如何一起工作来简明地表达通常
的概念。
                                                          46
1.6	高阶函数
牛顿法是一个传统的迭代方法,用于寻找使数学函数返回值为零的参数。这些值叫做一元数
学函数的根。寻找一个函数的根通常等价于求解一个相关的数学方程。
    16	的平方根是满足 	square(x)	-	16	=	0	的 	x	值。
    以	2	为底	32	的对数(例如	2	与某个指数的幂为	32)是满
    足 	pow(2,	x)	-	32	=	0	的 	x	值。
所以,求根的通用方法会向我们提供算法来计算平方根和对数。而且,我们想要计算根的等
式只包含简单操作:乘法和乘方。
在我们继续之前有个注解:我们知道如何计算平方根和对数,这个事实很容易当做自然的事
情。并不只是	Python,你的手机和计算机,可能甚至你的手表都可以为你做这件事。但是,
学习计算机科学的一部分是弄懂这些数如何计算,而且,这里展示的通用方法可以用于求解
大量方程,而不仅仅是内建于	Python	的东西。
在开始理解牛顿法之前,我们可以开始编程了。这就是函数抽象的威力。我们简单地将之前
的语句翻译成代码:
  >>>	def	square_root(a):
  								return	find_root(lambda	x:	square(x)	-	a)
  >>>	def	logarithm(a,	base=2):
  								return	find_root(lambda	x:	pow(base,	x)	-	a)
当然,在我们定义 	find_root	之前,现在还不能调用任何函数,所以我们需要理解牛顿法如
何工作。
牛顿法也是一个迭代改进算法:它会改进任何可导函数的根的推测值。要注意我们感兴趣的
两个函数都是平滑的。对于
     	f(x)	=	square(x)	-	16	(细线)
     	f(x)	=	pow(2,	x)	-	32	(粗线)
在二维平面上画出 	x	对 	f(x)	的图像,它展示了两个函数都产生了光滑的曲线,它们在某个
点穿过了	0。
                                                       47
1.6	高阶函数
由于它们是光滑的(可导的),这些曲线可以通过任何点上的直线来近似。牛顿法根据这些
线性的近似值来寻找函数的根。
想象经过点 	(x,	f(x))	的一条直线,它与函数 	f(x)	的曲线在这一点的斜率相同。这样的直线
叫做切线,它的斜率叫做 	f	在 	x	上的导数。
这条直线的斜率是函数值改变量与函数参数改变量的比值。所以,按照 	f(x)	除以这个斜率来
平移 	x	,就会得到切线到达	0	时的 	x	值。
我们的牛顿更新操作表达了跟随这条切线到零的计算过程。我们通过在非常小的区间上计算
函数斜率来近似得到函数的导数。
  >>>	def	approx_derivative(f,	x,	delta=1e-5):
  								df	=	f(x	+	delta)	-	f(x)
  								return	df/delta
  >>>	def	newton_update(f):
  								def	update(x):
  												return	x	-	f(x)	/	approx_derivative(f,	x)
  								return	update
最后,我们可以定义基于 	newton_update	(我们的迭代改进算法)的 	find_root	函数,以及一
个测试来观察 	f(x)	是否接近于	0。我们提供了一个较大的初始推测值来提升 	logarithm	的性
能。
  >>>	def	find_root(f,	initial_guess=10):
  								def	test(x):
  												return	approx_eq(f(x),	0)
  								return	iter_improve(newton_update(f),	test,	initial_guess)
  >>>	square_root(16)
  4.000000000026422
  >>>	logarithm(32,	2)
  5.000000094858201
                                                                     48
1.6	高阶函数
当你实验牛顿法时,要注意它不总是收敛的。 	iter_improve	的初始推测值必须足够接近于
根,而且函数必须满足各种条件。虽然具有这些缺陷,牛顿法是一个用于解决微分方程的强
大的通用计算方法。实际上,非常快速的对数算法和大整数除法也采用这个技巧的变体。
1.6.7	抽象和一等函数
这一节的开始,我们以观察用户定义函数作为关键的抽象技巧,因为它们让我们能够将计算
的通用方法表达为编程语言中的显式元素。现在我们已经看到了高阶函数如何让我们操作这
些通用方法来进一步创建抽象。
作为程序员,我们应该留意识别程序中低级抽象的机会,在它们之上构建,并泛化它们来创
建更加强大的抽象。这并不是说,一个人应该总是尽可能以最抽象的方式来编程;专家级程
序员知道如何选择合适于他们任务的抽象级别。但是能够基于这些抽象来思考,以便我们在
新的上下文中能使用它们十分重要。高阶函数的重要性是,它允许我们更加明显地将这些抽
象表达为编程语言中的元素,使它们能够处理其它的计算元素。
通常,编程语言会限制操作计算元素的途径。带有最少限制的元素被称为具有一等地位。一
些一等元素的“权利和特权”是:
 1.	 它们可以绑定到名称。
 2.	 它们可以作为参数向函数传递。
 3.	 它们可以作为函数的返回值返回。
 4.	 它们可以包含在好素具结构中。
Python	总是给予函数一等地位,所产生的表现力的收益是巨大的。另一方面,控制结构不能
做到:你不能像使用 	sum	那样将 	if	传给一个函数。
1.6.8	函数装饰器
Python	提供了特殊的语法,将高阶函数用作执行 	def	语句的一部分,叫做装饰器。
  >>>	def	trace1(fn):
  								def	wrapped(x):
  												print('->	',	fn,	'(',	x,	')')
  												return	fn(x)
  								return	wrapped
  >>>	@trace1
  				def	triple(x):
  								return	3	*	x
  >>>	triple(12)
  ->		<function	triple	at	0x102a39848>	(	12	)
  36
这个例子中,定义了高阶函数 	trace1	,它返回一个函数,这个函数在调用它的参数之前执
行 	print	语句来输出参数。 	triple	的 	def	语句拥有一个注解, 	@trace1	,它会影响 	def	的
执行规则。像通常一样,函数 	triple	被创建了,但是, 	triple	的名称并没有绑定到这个函
                                                                49
1.6	高阶函数
数上,而是绑定到了在新定义的函数 	triple	上调用 	trace1	的返回函数值上。在代码中,这
个装饰器等价于:
  >>>	def	triple(x):
  								return	3	*	x
  >>>	triple	=	trace1(triple)
附加部分:实际规则是,装饰器符号 	@	可以放在表达式前面( 	@trace1	仅仅是一个简单的表
达式,由单一名称组成)。任何产生合适的值的表达式都可以。例如,使用合适的值,你可
以定义装饰器 	check_range	,使用 	@check_range(1,	10)	来装饰函数定义,这会检查函数的结
果来确保它们是	1	到	10	的整数。调用 	check_range(1,10)	会返回一个函数,之后它会用在新
定义的函数上,在新定义的函数绑定到 	def	语句中的名称之前。感兴趣的同学可以阅读	Ariel
Ortiz	编写的一篇装饰器的简短教程来了解更多的例子。
                                                             50
第二章	使用对象构建抽象
第二章	使用对象构建抽象
             51
2.1	引言
2.1	引言
   来源:2.1	Introduction
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
在第一章中,我们专注于计算过程,以及程序设计中函数的作用。我们看到了如何使用原始
数据(数值)和原始操作(算术运算),如何通过组合和控制来形成复合函数,以及如何通
过给予过程名称来创建函数抽象。我们也看到了高阶函数通过操作通用计算方法来提升语言
的威力。这是编程的本质。
这一章会专注于数据。数据允许我们通过使用已经获得的计算工具,表示和操作与世界有关
的信息。脱离数据结构的编程可能会满足于探索数学特性,但是真实世界的情况,比如文
档、关系、城市和气候模式,都拥有复杂的结构,它最好使用复合数据类型来表现。归功于
互联网的高速发展,关于世界的大量结构信息可以免费从网上获得。
2.1.1	对象隐喻
在这门课的开始,我们区分了函数和数据:函数执行操作,而数据被操作。当我们在数据中
包含函数值时,我们承认数据也拥有行为。函数可以像数据一样被操作,但是也可以被调用
来执行计算。
在这门课中,对象作为我们对数据值的核心编程隐喻,它同样拥有行为。对象表示信息,但
是同时和它们所表示的抽象概念行为一致。对象如何和其它对象交互的逻辑,和编码对象值
的信息绑定在一起。在打印对象时,它知道如何以字母和数字把自己拼写出来。如果一个对
象由几部分组成,它知道如何按照要求展示这些部分。对象既是信息也是过程,它们绑定在
一起来展示复杂事物的属性、交互和行为。
Python	中所实现的对象隐喻具有特定的对象语法和相关的术语,我们会使用示例来介绍。日
期( 	date	)就是一种简单对象。
  >>>	from	datetime	import	date
	date	的名字绑定到了一个类上面。类表示一类对象。独立的日期叫做这个类的实例,它们可
以通过像函数那样在参数上调用这个类来构造,这些参数描述了实例。
  >>>	today	=	date(2011,	9,	12)
                                           52
2.1	引言
虽然 	today	从原始数值中构造,它的行为就像日期那样。例如,将它与另一个日期相减会得
到时间差,它可以通过调用 	str	来展示为一行文本:
  >>>	str(date(2011,	12,	2)	-	today)
  '81	days,	0:00:00'
对象拥有属性,它们是带有名字的值,也是对象的一部分。Python	中,我们使用点运算符来
访问对象属性:
  <expression>	.	<name>
上面的 	<expression>	求值为对象, 	<name>	是对象的某个属性名称。
不像我们之前见过的名称,这些属性名称在一般的环境中不可用。反之,属性名称是点运算
符之前的对象实例的特定部分。
  >>>	today.year
  2011
对象也拥有方法,它是值为函数的属性。在隐喻上,对象“知道”如何执行这些方法。方法从它
们的参数和对象中计算出它们的结果。例如, 	today	的 	strftime	方法接受一个指定如何展示
日期的参数(例如 	%A	表示星期几应该以全称拼写)。
  >>>	today.strftime('%A,	%B	%d')
  'Monday,	September	12'
计算 	strftime	的返回值需要两个输入:描述输出格式的字符串,以及绑定到 	today	的日期信
息。这个方法使用日期特定的逻辑来产生结果。我们从不会说	2011	年九月十二日是星期一,
但是知道一个人的工作日是日期的一部分。通过绑定行为和信息,Python	对象提供了可靠、
独立的日期抽象。
点运算符在	Python	中提供了另一种组合表达式。点运算符拥有定义好的求值过程。但是,点
运算符如何求值的精确解释,要等到我们引入面向对象编程的完整范式,在几节之后。
即使我们还不能精确描述对象如何工作,我们还是可以开始将数据看做对象,因为	Python	中
万物皆对象。
2.1.2	原始数据类型
Python	中每个对象都拥有一个类型。 	type	函数可以让我们查看对象的类型。
  >>>	type(today)
  <class	'datetime.date'>
                                                   53
2.1	引言
目前为止,我们学过的对象类型只有数值、函数、布尔值和现在的日期。我们也碰到了集合
和字符串,但是需要更深入地学习它们。有许多其它的对象类型	--	声音、图像、位置、数据
连接等等	--	它们的多数可以通过组合和抽象的手段来定义,我们在这一章会研究它们。
Python	只有一小部分内建于语言的原始或原生数据类型。
原始数据类型具有以下特性:
 1.	 原始表达式可以计算这些类型的对象,叫做字面值。
 2.	 内建的函数、运算符和方法可以操作这些对象。
像我们看到的那样,数值是原始类型,数字字面值求值为数值,算术运算符操作数值对象:
  >>>	12	+	3000000000000000000000000
  3000000000000000000000012
实际上,Python	包含了三个原始数值类型:整数( 	int	)、实数( 	float	)和复数
( 	complex	)。
  >>>	type(2)
  <class	'int'>
  >>>	type(1.5)
  <class	'float'>
  >>>	type(1+1j)
  <class	'complex'>
名称 	float	来源于实数在	Python	中表示的方式:“浮点”表示。虽然数值表示的细节不是这门
课的话题,一些 	int	和 	float	对象的高层差异仍然很重要。特别是, 	int	对象只能表示整
数,但是表示得更精确,不带有任何近似。另一方面, 	float	对象可以表示很大范围内的分
数,但是不能表示所有有理数。然而,浮点对象通常用于近似表示实数和有理数,舍入到某
个有效数字的数值。
扩展阅读。下面的章节介绍了更多的	Python	原始数据类型,专注于它们在创建实用数据抽象
中的作用。Dive	Into	Python	3	中的原始数据类型一章提供了所有	Python	数据类型的实用概
览,以及如何高效使用它们,还包含了许多使用示例和实践提示。你现在并不需要阅读它,
但是要考虑将它作为宝贵的参考。
                                                       54
2.2	数据抽象
2.2	数据抽象
   来源:2.2	Data	Abstraction
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
由于我们希望在程序中表达世界中的大量事物,我们发现它们的大多数都具有复合结构。日
期是年月日,地理位置是精度和纬度。为了表示位置,我们希望程序语言具有将精度和纬
度“粘合”为一对数据的能力	--	也就是一个复合数据结构	--	使我们的程序能够以一种方式操作
数据,将位置看做单个概念单元,它拥有两个部分。
复合数据的使用也让我们增加程序的模块性。如果我们可以直接将地理位置看做对象来操
作,我们就可以将程序的各个部分分离,它们根据这些值如何表示来从本质上处理这些值。
将某个部分从程序中分离的一般技巧是一种叫做数据抽象的强大的设计方法论。这个部分用
于处理数据表示,而程序用于操作数据。数据抽象使程序更易于设计、维护和修改。
数据抽象的特征类似于函数抽象。当我们创建函数抽象时,函数如何实现的细节被隐藏了,
而且特定的函数本身可以被任何具有相同行为的函数替换。换句话说,我们可以构造抽象来
使函数的使用方式和函数的实现细节分离。与之相似,数据抽象是一种方法论,使我们将复
合数据对象的使用细节与它的构造方式隔离。
数据抽象的基本概念是构造操作抽象数据的程序。也就是说,我们的程序应该以一种方式来
使用数据,对数据做出尽可能少的假设。同时,需要定义具体的数据表示,独立于使用数据
的程序。我们系统中这两部分的接口是一系列函数,叫做选择器和构造器,它们基于具体表
示实现了抽象数据。为了演示这个技巧,我们需要考虑如何设计一系列函数来操作有理数。
当你阅读下一节时,要记住当今编写的多数	Python	代码使用了非常高级的抽象数据类型,它
们内建于语言中,比如类、字典和列表。由于我们正在了解这些抽象的工作原理,我们自己
不能使用它们。所以,我们会编写一些不那么	Python	化的代码	--	它并不是在语言中实现我们
的概念的通常方式。但是,我们所编写的代码出于教育目的,它展示了这些抽象如何构建。
要记住计算机科学并不只是学习如何使用编程语言,也学习它们的工作原理。
2.2.1	示例:有理数的算术
有理数可表示为整数的比值,并且它组成了实数的一个重要子类。类似于 	1/3	或者 	17/29	的
有理数通常可编写为:
  <numerator>/<denominator>
                                                 55
2.2	数据抽象
其中, 	<numerator>	和 	<denominator>	都是值为整数的占位符。有理数的值需要两部分来描
述。
有理数在计算机科学中很重要,因为它们就像整数那样,可以准确表示。无理数(比如 	pi	
或者	 	e		或者	 	sqrt(2)	)会使用有限的二元展开代替为近似值。所以在原则上,有理数的处
理应该让我们避免算术中的近似误差。
但是,一旦我们真正将分子与分母相除,我们就会只剩下截断的小数近似值:
  >>>	1/3
  0.3333333333333333
当我们开始执行测试时,这个近似值的问题就会出现:
  >>>	1/3	==	0.333333333333333300000		#	Beware	of	approximations
  True
计算机如何将实数近似为定长的小数扩展,是另一门课的话题。这里的重要概念是,通过将
有理数表示为整数的比值,我们能够完全避免近似问题。所以出于精确,我们希望将分子和
分母分离,但是将它们看做一个单元。
我们从函数抽象中了解到,我们可以在了解某些部分的实现之前开始编出东西来。让我们一
开始假设我们已经拥有一种从分子和分母中构造有理数的方式。我们也假设,给定一个有理
数,我们都有办法来提取(或选中)它的分子和分母。让我们进一步假设,构造器和选择器
以下面三个函数来提供:
     	make_rat(n,	d)	返回分子为 	n	和分母为 	d	的有理数。
     	numer(x)	返回有理数 	x	的分子。
     	denom(x)	返回有理数 	x	的分母。
我们在这里正在使用一个强大的合成策略:心想事成。我们并没有说有理数如何表示,或
者 	numer	、 	denom	和 	make_rat	如何实现。即使这样,如果我们拥有了这三个函数,我们就可
以执行加法、乘法,以及测试有理数的相等性,通过调用它们:
  >>>	def	add_rat(x,	y):
  								nx,	dx	=	numer(x),	denom(x)
  								ny,	dy	=	numer(y),	denom(y)
  								return	make_rat(nx	*	dy	+	ny	*	dx,	dx	*	dy)
  >>>	def	mul_rat(x,	y):
  								return	make_rat(numer(x)	*	numer(y),	denom(x)	*	denom(y))
  >>>	def	eq_rat(x,	y):
  								return	numer(x)	*	denom(y)	==	numer(y)	*	denom(x)
现在我们拥有了由选择器函数 	numer	和 	denom	,以及构造器函数 	make_rat	定义的有理数操
作。但是我们还没有定义这些函数。我们需要以某种方式来将分子和分母粘合为一个单元。
                                                                    56
2.2	数据抽象
2.2.2	元组
为了实现我们的数据抽象的具体层面,Python	提供了一种复合数据结构叫做 	tuple	,它可以
由逗号分隔的值来构造。虽然并不是严格要求,圆括号通常在元组周围。
  >>>	(1,	2)
  (1,	2)
元组的元素可以由两种方式解构。第一种是我们熟悉的多重赋值:
  >>>	pair	=	(1,	2)
  >>>	pair
  (1,	2)
  >>>	x,	y	=	pair
  >>>	x
  1
  >>>	y
  2
实际上,多重赋值的本质是创建和解构元组。
访问元组元素的第二种方式是通过下标运算符,写作方括号:
  >>>	pair[0]
  1
  >>>	pair[1]
  2
Python	中的元组(以及多数其它编程语言中的序列)下标都以	0	开始,也就是说,下标	0	表
示第一个元素,下标	1	表示第二个元素,以此类推。我们对这个下标惯例的直觉是,下标表
示一个元素距离元组开头有多远。
与元素选择操作等价的函数叫做 	getitem	,它也使用下标以	0	开始的位置来在元组中选择元
素。
元素是原始类型,也就是说	Python	的内建运算符可以操作它们。我们不久之后再来看元素的
完整特性。现在,我们只对元组如何作为胶水来实现抽象数据类型感兴趣。
表示有理数。元素提供了一个自然的方式来将有理数实现为一对整数:分子和分母。我们可
以通过操作二元组来实现我们的有理数构造器和选择器函数。
  >>>	def	make_rat(n,	d):
  								return	(n,	d)
  >>>	def	numer(x):
  								return	getitem(x,	0)
  >>>	def	denom(x):
  								return	getitem(x,	1)
用于打印有理数的函数完成了我们对抽象数据结构的实现。
                                                57
2.2	数据抽象
  >>>	def	str_rat(x):
  								"""Return	a	string	'n/d'	for	numerator	n	and	denominator	d."""
  								return	'{0}/{1}'.format(numer(x),	denom(x))
将它与我们之前定义的算术运算放在一起,我们可以使用我们定义的函数来操作有理数了。
  >>>	half	=	make_rat(1,	2)
  >>>	str_rat(half)
  '1/2'
  >>>	third	=	make_rat(1,	3)
  >>>	str_rat(mul_rat(half,	third))
  '1/6'
  >>>	str_rat(add_rat(third,	third))
  '6/9'
就像最后的例子所展示的那样,我们的有理数实现并没有将有理数化为最简。我们可以通过
修改 	make_rat	来补救。如果我们拥有用于计算两个整数的最大公约数的函数,我们可以在构
造一对整数之前将分子和分母化为最简。这可以使用许多实用工具,例如	Python	库中的现存
函数。
  >>>	from	fractions	import	gcd
  >>>	def	make_rat(n,	d):
  								g	=	gcd(n,	d)
  								return	(n//g,	d//g)
双斜杠运算符 	//	表示整数除法,它会向下取整除法结果的小数部分。由于我们知道 	g	能整
除 	n	和 	d	,整数除法正好适用于这里。现在我们的
  >>>	str_rat(add_rat(third,	third))
  '2/3'
符合要求。这个修改只通过修改构造器来完成,并没有修改任何实现实际算术运算的函数。
扩展阅读。上面的 	str_rat	实现使用了格式化字符串,它包含了值的占位符。如何使用格式
化字符串和 	format	方法的细节请见	Dive	Into	Python	3	的格式化字符串一节。
2.2.3	抽象界限
在以更多复合数据和数据抽象的例子继续之前,让我们思考一些由有理数示例产生的问题。
我们使用构造器 	make_rat	和选择器 	numer	和 	denom	定义了操作。通常,数据抽象的底层概念
是,基于某个值的类型的操作如何表达,为这个值的类型确定一组基本的操作。之后使用这
些操作来操作数据。
我们可以将有理数系统想象为一系列层级。
                                                                         58
2.2	数据抽象
平行线表示隔离系统不同层级的界限。每一层上,界限分离了使用数据抽象的函数(上面)
和实现数据抽象的函数(下面)。使用有理数的程序仅仅通过算术函数来操作它
们: 	add_rat	、 	mul_rat	和 	eq_rat	。相应地,这些函数仅仅由构造器和选择
器 	make_rat	、 	numer	和 	and	denom	来实现,它们本身由元组实现。元组如何实现的字节和其
它层级没有关系,只要元组支持选择器和构造器的实现。
每一层上,盒子中的函数强制划分了抽象的边界,因为它们仅仅依赖于上层的表现(通过使
用)和底层的实现(通过定义)。这样,抽象界限可以表现为一系列函数。
抽象界限具有许多好处。一个好处就是,它们使程序更易于维护和修改。很少的函数依赖于
特定的表现,当一个人希望修改表现时,不需要做很多修改。
2.2.4	数据属性
我们通过实现算术运算来开始实现有理数,实现为这三个非特定函
数: 	make_rat	、 	numer	和 	denom	。这里,我们可以认为已经定义了数据对象	--	分子、分母
和有理数	--	上的运算,它们的行为由这三个函数规定。
但是数据意味着什么?我们还不能说“提供的选择器和构造器实现了任何东西”。我们需要保证
这些函数一起规定了正确的行为。也就是说,如果我们从整数 	n	和 	d	中构造了有理数 	x	,
那么 	numer(x)/denom(x)	应该等于 	n/d	。
通常,我们可以将抽象数据类型当做一些选择器和构造器的集合,并带有一些行为条件。只
要满足了行为条件(比如上面的除法特性),这些函数就组成了数据类型的有效表示。
                                                           59
2.2	数据抽象
这个观点可以用在其他数据类型上,例如我们为实现有理数而使用的二元组。我们实际上不
会谈论元组是什么,而是谈论由语言提供的,用于操作和创建元组的运算符。我们现在可以
描述二元组的行为条件,二元组通常叫做偶对,在表示有理数的问题中有所涉及。
为了实现有理数,我们需要一种两个整数的粘合形式,它具有下列行为:
    如果一个偶对 	p	由 	x	和 	y	构造,那么 	getitem_pair(p,	0)	返
    回 	x	, 	getitem_pair(p,	1)	返回 	y	。
我们可以实现 	make_pair	和 	getitem_pair	,它们和元组一样满足这个描述:
  >>>	def	make_pair(x,	y):
  								"""Return	a	function	that	behaves	like	a	pair."""
  								def	dispatch(m):
  												if	m	==	0:
  																return	x
  												elif	m	==	1:
  																return	y
  								return	dispatch
  >>>	def	getitem_pair(p,	i):
  								"""Return	the	element	at	index	i	of	pair	p."""
  								return	p(i)
使用这个实现,我们可以创建和操作偶对:
  >>>	p	=	make_pair(1,	2)
  >>>	getitem_pair(p,	0)
  1
  >>>	getitem_pair(p,	1)
  2
这个函数的用法不同于任何直观上的,数据应该是什么的概念。而且,这些函数满足于在我
们的程序中表示复合数据。
需要注意的微妙的一点是,由 	make_pair	返回的值是叫做 	dispatch	的函数,它接受参数 	m	并
返回 	x	或 	y	。之后, 	getitem_pair	调用了这个函数来获取合适的值。我们在这一章中会多
次返回这个调度函数的话题。
这个偶对的函数表示并不是	Python	实际的工作机制(元组实现得更直接,出于性能因素),
但是它可以以这种方式工作。这个函数表示虽然不是很明显,但是是一种足够完美来表示偶
对的方式,因为它满足了偶对唯一需要满足的条件。这个例子也表明,将函数当做值来操作
的能力,提供给我们表示复合数据的能力。
                                                            60
2.3	序列
2.3	序列
   来源:2.3	Sequences
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
序列是数据值的顺序容器。不像偶对只有两个元素,序列可以拥有任意(但是有限)个有序
元素。
序列在计算机科学中是强大而基本的抽象。例如,如果我们使用序列,我们就可以列出伯克
利的每个学生,或者世界上的每所大学,或者每所大学中的每个学生。我们可以列出上过的
每一门课,提交的每个作业,或者得到的每个成绩。序列抽象让数千个数据驱动的程序影响
着我们每天的生活。
序列不是特定的抽象数据类型,而是不同类型共有的一组行为。也就是说,它们是许多序列
种类,但是都有一定的属性。特别地,
长度。序列拥有有限的长度。
元素选择。序列的每个元素都拥有相应的非负整数作为下标,它小于序列长度,以第一个元
素的	0	开始。
不像抽象数据类型,我们并没有阐述如何构造序列。序列抽象是一组行为,它们并没有完全
指定类型(例如,使用构造器和选择器),但是可以在多种类型中共享。序列提供了一个抽
象层级,将特定程序如何操作序列类型的细节隐藏。
这一节中,我们开发了一个特定的抽象数据类型,它可以实现序列抽象。我们之后介绍实现
相同抽象的	Python	内建类型。
2.3.1	嵌套偶对
对于有理数,我们使用二元组将两个整数对象配对,之后展示了我们可以同样通过函数来实
现偶对。这种情况下,每个我们构造的偶对的元素都是整数。然而,就像表达式,元组可以
嵌套。每个偶对的元素本身也可以是偶对,这个特性在实现偶对的任意一个方法,元组或调
度函数中都有效。
可视化偶对的一个标准方法	--	这里也就是偶对 	(1,2)		--	叫做盒子和指针记号。每个值,复合
或原始,都描述为指向盒子的指针。原始值的盒子只包含那个值的表示。例如,数值的盒子
只包含数字。偶对的盒子实际上是两个盒子:左边的部分(箭头指向的)包含偶对的第一个
元素,右边的部分包含第二个。
                                                  61
2.3	序列
嵌套元素的	Python	表达式:
  >>>	((1,	2),	(3,	4))
  ((1,	2),	(3,	4))
具有下面的结构:
使用元组作为其它元组元素的能力,提供了我们编程语言中的一个新的组合手段。我们将这
种将元组以这种方式嵌套的能力叫做元组数据类型的封闭性。通常,如果组合结果自己可以
使用相同的方式组合,组合数据值的方式就满足封闭性。封闭性在任何组合手段中都是核心
能力,因为它允许我们创建层次数据结构	--	结构由多个部分组成,它们自己也由多个部分组
成,以此类推。我们在第三章会探索一些层次结构。现在,我们考虑一个特定的重要结构。
2.3.2	递归列表
我们可以使用嵌套偶对来构建任意长度的元素列表,它让我们能够实现抽象序列。下面的图
展示了四元素列表 	1,	2,	3,	4	的递归表示:
                                           62
2.3	序列
这个列表由一系列偶对表示。每个偶对的第一个元素是列表中的元素,而第二个元素是用于
表示列表其余部分的偶对。最后一个偶对的第二个元素是 	None	,它表明列表到末尾了。我们
可以使用嵌套的元组字面值来构造这个结构:
  >>>	(1,	(2,	(3,	(4,	None))))
  (1,	(2,	(3,	(4,	None))))
这个嵌套的结构通常对应了一种非常实用的序列思考方式,我们在	Python	解释器的执行规则
中已经见过它了。一个非空序列可以划分为:
    它的第一个元素,以及
    序列的其余部分。
序列的其余部分本身就是一个(可能为空的)序列。我们将序列的这种看法叫做递归,因为
序列包含其它序列作为第二个组成部分。
由于我们的列表表示是递归的,我们在实现中叫它 	rlist	,以便不会和	Python	内建
的 	list	类型混淆,我们会稍后在这一章介绍它。一个递归列表可以由第一个元素和列表的剩
余部分构造。 	None	值表示空的递归列表。
  >>>	empty_rlist	=	None
  >>>	def	make_rlist(first,	rest):
  								"""Make	a	recursive	list	from	its	first	element	and	the	rest."""
  								return	(first,	rest)
  >>>	def	first(s):
  								"""Return	the	first	element	of	a	recursive	list	s."""
  								return	s[0]
  >>>	def	rest(s):
  								"""Return	the	rest	of	the	elements	of	a	recursive	list	s."""
  								return	s[1]
这两个选择器和一个构造器,以及一个常量共同实现了抽象数据类型的递归列表。递归列表
唯一的行为条件是,就像偶对那样,它的构造器和选择器是相反的函数。
    如果一个递归列表 	s	由元素 	f	和列表 	r	构造,那么 	first(s)	返回 	f	,并且 	rest(s)	返
    回 	r	。
我们可以使用构造器和选择器来操作递归列表。
  >>>	counts	=	make_rlist(1,	make_rlist(2,	make_rlist(3,	make_rlist(4,	empty_rlist))))
  >>>	first(counts)
  1
  >>>	rest(counts)
  (2,	(3,	(4,	None)))
递归列表可以按序储存元素序列,但是它还没有实现序列的抽象。使用我们已经定义的数据
类型抽象,我们就可以实现描述两个序列的行为:长度和元素选择。
                                                                                       63
2.3	序列
  >>>	def	len_rlist(s):
  								"""Return	the	length	of	recursive	list	s."""
  								length	=	0
  								while	s	!=	empty_rlist:
  												s,	length	=	rest(s),	length	+	1
  								return	length
  >>>	def	getitem_rlist(s,	i):
  								"""Return	the	element	at	index	i	of	recursive	list	s."""
  								while	i	>	0:
  												s,	i	=	rest(s),	i	-	1
  								return	first(s)
现在,我们可以将递归列表用作序列了:
  >>>	len_rlist(counts)
  4
  >>>	getitem_rlist(counts,	1)		#	The	second	item	has	index	1
  2
两个实现都是可迭代的。它们隔离了嵌套偶对的每个层级,直到列表的末尾
(在 	len_rlist	中),或者到达了想要的元素(在 	getitem_rlist	中)。
下面的一系列环境图示展示了迭代过程, 	getitem_rlist	通过它找到了递归列表中下标 	1	中
的元素 	2	。
	while	头部中的表达式求值为真,这会导致 	while	语句组中的赋值语句被执行:
                                                                   64
2.3	序列
这里,局部名称 	s	现在指向以原列表第二个元素开始的子列表。现在, 	while	头中的表达式
求值为假,于是	Python	会求出 	getitem_rlist	最后一行中返回语句中的表达式。
最后的环境图示展示了调用 	first	的局部帧,它包含绑定到相同子列表的 	s	。 	first	函数挑
选出值 	2	并返回了它,完成了 	getitem_rlist	的调用。
                                                    65
2.3	序列
这个例子演示了递归列表计算的常见模式,其中迭代的每一步都操作原列表的一个逐渐变短
的后缀。寻找递归列表的长度和元素的渐进式处理过程需要一些时间来计算。(第三章中,
我们会学会描述这种函数的计算时间。)Python	的内建序列类型以不同方式实现,它对于计
算序列长度和获取元素并不具有大量的计算开销。
2.3.2	元组	II
实际上,我们引入用于形成原始偶对的 	tuple	类型本身就是完整的序列类型。元组比起我们
以函数式实现的偶对抽象数据结构,本质上提供了更多功能。
元组具有任意的长度,并且也拥有序列抽象的两个基本行为:长度和元素选择。下面
的 	digits	是一个四元素元组。
  >>>	digits	=	(1,	8,	2,	8)
  >>>	len(digits)
  4
  >>>	digits[3]
  8
此外,元素可以彼此相加以及与整数相乘。对于元组,加法和乘法操作并不对元素相加或相
乘,而是组合和重复元组本身。也就是说, 	operator	模块中的 	add	函数(以及 	+	运算符)
返回两个被加参数连接成的新元组。 	operator	模块中的 	mul	函数(以及 	*	运算符)接受整
数 	k	和元组,并返回含有元组参数 	k	个副本的新元组。
  >>>	(2,	7)	+	digits	*	2
  (2,	7,	1,	8,	2,	8,	1,	8,	2,	8)
映射。将一个元组变换为另一个元组的强大手段是在每个元素上调用函数,并收集结果。这
一计算的常用形式叫做在序列上映射函数,对应内建函数 	map	。 	map	的结果是一个本身不是
序列的对象,但是可以通过调用 	tuple	来转换为序列。它是元组的构造器。
  >>>	alternates	=	(-1,	2,	-3,	4,	-5)
  >>>	tuple(map(abs,	alternates))
  (1,	2,	3,	4,	5)
	map	函数非常重要,因为它依赖于序列抽象:我们不需要关心底层元组的结构,只需要能够
独立访问每个元素,以便将它作为参数传入用于映射的函数中(这里是 	abs	)。
2.3.4	序列迭代
映射本身就是通用计算模式的一个实例:在序列中迭代所有元素。为了在序列上映射函数,
我们不仅仅需要选择特定的元素,还要依次选择每个元素。这个模式非常普遍,Python	拥有
额外的控制语句来处理序列数据: 	for	语句。
                                                     66
2.3	序列
考虑一个问题,计算一个值在序列中出现了多少次。我们可以使用 	while	循环实现一个函数
来计算这个数量。
  >>>	def	count(s,	value):
  								"""Count	the	number	of	occurrences	of	value	in	sequence	s."""
  								total,	index	=	0,	0
  								while	index	<	len(s):
  												if	s[index]	==	value:
  																total	=	total	+	1
  												index	=	index	+	1
  								return	total
  >>>	count(digits,	8)
  2
Python	 	for	语句可以通过直接迭代元素值来简化这个函数体,完全不需要引入 	index	。例如
(原文是 	For	example	,为双关语),我们可以写成:
  >>>	def	count(s,	value):
  								"""Count	the	number	of	occurrences	of	value	in	sequence	s."""
  								total	=	0
  								for	elem	in	s:
  												if	elem	==	value:
  																total	=	total	+	1
  								return	total
  >>>	count(digits,	8)
  2
	for	语句按照以下过程来执行:
 1.	 求出头部表达式 	<expression>	,它必须产生一个可迭代的值。
 2.	 对于序列中的每个元素值,按顺序:
       i.	 在局部环境中将变量名 	<name>	绑定到这个值上。
      ii.	 执行语句组 	<suite>	。
步骤	1	引用了可迭代的值。序列是可迭代的,它们的元素可看做迭代的顺序。Python	的确拥
有其他可迭代类型,但是我们现在只关注序列。术语“可迭代对象”的一般定义会在第四章的迭
代器一节中出现。
这个求值过程的一个重要结果是,在 	for	语句执行完毕之后, 	<name>	会绑定到序列的最后一
个元素上。这个 	for	循环引入了另一种方式,其中局部环境可以由语句来更新。
序列解构。程序中的一个常见模式是,序列的元素本身就是序列,但是具有固定的长
度。 	for	语句可在头部中包含多个名称,将每个元素序列“解构”为各个元素。例如,我们拥有
一个偶对(也就是二元组)的序列:
  >>>	pairs	=	((1,	2),	(2,	2),	(2,	3),	(4,	4))
下面的 	for	语句的头部带有两个名词,会将每个名称 	x	和 	y	分别绑定到每个偶对的第一个
和第二个元素上。
                                                                        67
2.3	序列
  >>>	for	x,	y	in	pairs:
  								if	x	==	y:
  												same_count	=	same_count	+	1
  >>>	same_count
  2
这个绑定多个名称到定长序列中多个值的模式,叫做序列解构。它的模式和我们在赋值语句
中看到的,将多个名称绑定到多个值的模式相同。
范围。 	range	是另一种	Python	的内建序列类型,它表示一个整数范围。范围可以使
用 	range	函数来创建,它接受两个整数参数:所得范围的第一个数值和最后一个数值加一。
  >>>	range(1,	10)		#	Includes	1,	but	not	10
  range(1,	10)
在范围上调用 	tuple	构造器会创建与范围具有相同元素的元组,使元素易于查看。
  >>>	tuple(range(5,	8))
  (5,	6,	7)
如果只提供了一个元素,它会解释为最后一个数值加一,范围开始于	0。
  >>>	total	=	0
  >>>	for	k	in	range(5,	8):
  								total	=	total	+	k
  >>>	total
  18
常见的惯例是将单下划线字符用于 	for	头部,如果这个名称在语句组中不会使用。
  >>>	for	_	in	range(3):
  								print('Go	Bears!')
  Go	Bears!
  Go	Bears!
  Go	Bears!
要注意对解释器来说,下划线只是另一个名称,但是在程序员中具有固定含义,它表明这个
名称不应出现在任何表达式中。
2.3.5	序列抽象
我们已经介绍了两种原生数据类型,它们实现了序列抽象:元组和范围。两个都满足这一章
开始时的条件:长度和元素选择。Python	还包含了两种序列类型的行为,它们扩展了序列抽
象。
                                               68
2.3	序列
成员性。可以测试一个值在序列中的成员性。Python	拥有两个操作符 	in	和 	not	in	,取决于
元素是否在序列中出现而求值为 	True	和 	False	。
  >>>	digits
  (1,	8,	2,	8)
  >>>	2	in	digits
  True
  >>>	1828	not	in	digits
  True
所有序列都有叫做 	index	和 	count	的方法,它会返回序列中某个值的下标(或者数量)。
切片。序列包含其中的子序列。我们在开发我们的嵌套偶对实现时观察到了这一点,它将序
列切分为它的第一个元素和其余部分。序列的切片是原序列的任何部分,由一对整数指定。
就像 	range	构造器那样,第一个整数表示切片的起始下标,第二个表示结束下标加一。
Python	中,序列切片的表示类似于元素选择,使用方括号。冒号分割了起始和结束下标。任
何边界上的省略都被当作极限值:起始下标为	0,结束下标是序列长度。
  >>>	digits[0:2]
  (1,	8)
  >>>	digits[1:]
  (8,	2,	8)
Python	序列抽象的这些额外行为的枚举,给我们了一个机会来反思数据抽象通常由什么构
成。抽象的丰富性(也就是说它包含行为的多少)非常重要。对于使用抽象的用户,额外的
行为很有帮助,另一方面,满足新类型抽象的丰富需求是个挑战。为了确保我们的递归列表
实现支持这些额外的行为,需要一些工作量。另一个抽象丰富性的负面结果是,它们需要用
户长时间学习。
序列拥有丰富的抽象,因为它们在计算中无处不在,所以学习一些复杂的行为是合理的。通
常,多数用户定义的抽象应该尽可能简单。
扩展阅读。切片符号接受很多特殊情况,例如负的起始值,结束值和步长。Dive	Into	Python
3	中有一节叫做列表切片,完整描述了它。这一章中,我们只会用到上面描述的基本特性。
2.3.6	字符串
文本值可能比数值对计算机科学来说更基本。作为一个例子,Python	程序以文本编写和储
存。Python	中原生的文本数据类型叫做字符串,相应的构造器是 	str	。
关于字符串在	Python	中如何表示和操作有许多细节。字符串是丰富抽象的另一个示例,程序
员需要满足一些实质性要求来掌握。这一节是字符串基本行为的摘要。
字符串字面值可以表达任意文本,被单引号或者双引号包围。
                                                    69
2.3	序列
  >>>	'I	am	string!'
  'I	am	string!'
  >>>	"I've	got	an	apostrophe"
  "I've	got	an	apostrophe"
  >>>	'您好'
  '您好'
我们已经在代码中见过字符串了,在 	print	的调用中作为文档字符串,以及在 	assert	语句中
作为错误信息。
字符串满足两个基本的序列条件,我们在这一节开始介绍过它们:它们拥有长度并且支持元
素选择。
  >>>	city	=	'Berkeley'
  >>>	len(city)
  8
  >>>	city[3]
  'k'
字符串的元素本身就是包含单一字符的字符串。字符是字母表中的任意单一字符,标点符
号,或者其它符号。不像许多其它编程语言那样,Python	没有单独的字符类型,任何文本都
是字符串,表示单一字符的字符串长度为	1、
就像元组,字符串可以通过加法和乘法来组合:
  >>>	city	=	'Berkeley'
  >>>	len(city)
  8
  >>>	city[3]
  'k'
字符串的行为不同于	Python	中其它序列类型。字符串抽象没有实现我们为元组和范围描述的
完整序列抽象。特别地,字符串上实现了成员性运算符 	in	,但是与序列上的实现具有完全不
同的行为。它匹配子字符串而不是元素。
  >>>	'here'	in	"Where's	Waldo?"
  True
与之相似,字符串上的 	count	和 	index	方法接受子串作为参数,而不是单一字符。 	count	的
行为有细微差别,它统计字符串中非重叠字串的出现次数。
  >>>	'Mississippi'.count('i')
  4
  >>>	'Mississippi'.count('issi')
  1
多行文本。字符串并不限制于单行文本,三个引号分隔的字符串字面值可以跨越多行。我们
已经在文档字符串中使用了三个引号。
                                                       70
2.3	序列
   >>>	"""The	Zen	of	Python
   claims,	Readability	counts.
   Read	more:	import	this."""
   'The	Zen	of	Python\nclaims,	"Readability	counts."\nRead	more:	import	this.'
在上面的打印结果中, 	\n	(叫做“反斜杠加	n”)是表示新行的单一元素。虽然它表示为两个
字符(反斜杠和	n)。它在长度和元素选择上被认为是单个字符。
字符串强制。字符串可以从	Python	的任何对象通过以某个对象值作为参数调用 	str	构造函数
来创建,这个字符串的特性对于从多种类型的对象中构造描述性字符串非常实用。
   >>>	str(2)	+	'	is	an	element	of	'	+	str(digits)
   '2	is	an	element	of	(1,	8,	2,	8)'
	str	函数可以以任何类型的参数调用,并返回合适的值,这个机制是后面的泛用函数的主
题。
方法。字符串在	Python	中的行为非常具有生产力,因为大量的方法都返回字符串的变体或者
搜索其内容。一部分这些方法由下面的示例介绍。
   >>>	'1234'.isnumeric()
   True
   >>>	'rOBERT	dE	nIRO'.swapcase()
   'Robert	De	Niro'
   >>>	'snakeyes'.upper().endswith('YES')
   True
扩展阅读。计算机中的文本编码是个复杂的话题。这一章中,我们会移走字符串如何表示的
细节,但是,对许多应用来说,字符串如何由计算机编码的特定细节是必要的知识。Dive
Into	Python	3	的	4.1	~	4.3	节提供了字符编码和	Unicode	的描述。
2.3.7	接口约定
在复合数据的处理中,我们强调了数据抽象如何让我们设计程序而不陷入数据表示的细节,
以及抽象如何为我们保留灵活性来尝试备用表示。这一节中,我们引入了另一种强大的设计
原则来处理数据结构	--	接口约定的用法。
接口约定使在许多组件模块中共享的数据格式,它可以混合和匹配来展示数据。例如,如果
我们拥有多个函数,它们全部接受序列作为参数并且返回序列值,我们就可以把它们每一个
用于上一个的输出上,并选择任意一种顺序。这样,我们就可以通过将函数链接成流水线,
来创建一个复杂的过程,每个函数都是简单而专一的。
这一节有两个目的,来介绍以接口约定组织程序的概念,以及展示模块化序列处理的示例。
考虑下面两个问题,它们首次出现,并且只和序列的使用相关。
                                                                               71
2.3	序列
 1.	 对前 	n	个斐波那契数中的偶数求和。
 2.	 列出一个名称中的所有缩写字母,它包含每个大写单词的首字母。
这些问题是有关系的,因为它们可以解构为简单的操作,它们接受序列作为输入,并产出序
列作为输出。而且,这些操作是序列上的计算的一般方法的实例。让我们思考第一个问题,
它可以解构为下面的步骤:
  	enumerate					map				filter		accumulate
  -----------				---				------		----------
  naturals(n)				fib				iseven					sum
下面的 	fib	函数计算了斐波那契数(现在使用了 	for	语句更新了第一章中的定义)。
  >>>	def	fib(k):
  								"""Compute	the	kth	Fibonacci	number."""
  								prev,	curr	=	1,	0		#	curr	is	the	first	Fibonacci	number.
  								for	_	in	range(k	-	1):
  													prev,	curr	=	curr,	prev	+	curr
  								return	curr
谓词 	iseven	可以使用整数取余运算符 	%	来定义。
  >>>	def	iseven(n):
  								return	n	%	2	==	0
	map	和 	filter	函数是序列操作,我们已经见过了 	map	,它在序列中的每个元素上调用函数
并且收集结果。 	filter	函数接受序列,并且返回序列中谓词为真的元素。两个函数都返回间
接对象, 	map	和 	filter	对象,它们是可以转换为元组或求和的可迭代对象。
  >>>	nums	=	(5,	6,	-7,	-8,	9)
  >>>	tuple(filter(iseven,	nums))
  (6,	-8)
  >>>	sum(map(abs,	nums))
  35
现在我们可以实现 	even_fib	,第一个问题的解,使用 	map	、 	filter	和 	sum	。
  >>>	def	sum_even_fibs(n):
  								"""Sum	the	first	n	even	Fibonacci	numbers."""
  								return	sum(filter(iseven,	map(fib,	range(1,	n+1))))
  >>>	sum_even_fibs(20)
  3382
现在,让我们思考第二个问题。它可以解构为序列操作的流水线,包含 	map	和 	filter	。
  enumerate		filter			map			accumulate
  ---------		------		-----		----------
  		words				iscap			first				tuple
                                                                   72
2.3	序列
字符串中的单词可以通过字符串对象上的 	split	方法来枚举,默认以空格分割。
  >>>	tuple('Spaces	between	words'.split())
  ('Spaces',	'between',	'words')
单词的第一个字母可以使用选择运算符来获取,确定一个单词是否大写的谓词可以使用内建
谓词 	isupper	定义。
  >>>	def	first(s):
  								return	s[0]
  >>>	def	iscap(s):
  								return	len(s)	>	0	and	s[0].isupper()
这里,我们的缩写函数可以使用 	map	和 	filter	定义。
  >>>	def	acronym(name):
  								"""Return	a	tuple	of	the	letters	that	form	the	acronym	for	name."""
  								return	tuple(map(first,	filter(iscap,	name.split())))
  >>>	acronym('University	of	California	Berkeley	Undergraduate	Graphics	Group')
  ('U',	'C',	'B',	'U',	'G',	'G')
这些不同问题的相似解法展示了如何使用通用的计算模式,例如映射、过滤和累计,来组合
序列的接口约定上的操作。序列抽象让我们编写出这些简明的解法。
将程序表达为序列操作有助于我们设计模块化的程序。也就是说,我们的设计由组合相关的
独立片段构建,每个片段都对序列进行转换。通常,我们可以通过提供带有接口约定的标准
组件库来鼓励模块化设计,接口约定以灵活的方式连接这些组件。
生成器表达式。Python	语言包含第二个处理序列的途径,叫做生成器表达式。它提供了
与 	map	和 	reduce	相似的功能,但是需要更少的函数定义。
生成器表达式组合了过滤和映射的概念,并集成于单一的表达式中,以下面的形式:
  <map	expression>	for	<name>	in	<sequence	expression>	if	<filter	expression>
为了求出生成器表达式,Python	先求出 	<sequence	expression>	,它必须返回一个可迭代值。
之后,对于每个元素,按顺序将元素值绑定到 	<name>	,求出过滤器表达式,如果它产生真
值,就会求出映射表达式。
生成器表达式的求解结果值本身是个可迭代值。累计函数,比
如 	tuple	、 	sum	、 	max	和 	min	可以将返回的对象作为参数。
  >>>	def	acronym(name):
  								return	tuple(w[0]	for	w	in	name.split()	if	iscap(w))
  >>>	def	sum_even_fibs(n):
  								return	sum(fib(k)	for	k	in	range(1,	n+1)	if	fib(k)	%	2	==	0)
                                                                                73
2.3	序列
生成器表达式是使用可迭代(例如序列)接口约定的特化语法。这些表达式包含
了 	map	和 	filter	的大部分功能,但是避免了被调用函数的实际创建(或者,顺便也避免了环
境帧的创建需要调用这些函数)。
归约。在我们的示例中,我们使用特定的函数来累计结果,例如 	tuple	或者 	sum	。函数式编
程语言(包括	Python)包含通用的高阶累加器,具有多种名称。Python	在 	functools	模块中
包含 	reduce	,它对序列中的元素从左到右依次调用二元函数,将序列归约为一个值。下面的
表达式计算了五个因数的积。
  >>>	from	operator	import	mul
  >>>	from	functools	import	reduce
  >>>	reduce(mul,	(1,	2,	3,	4,	5))
  120
使用这个更普遍的累计形式,除了求和之外,我们也可以计算斐波那契数列中奇数的积,将
序列用作接口约定。
  >>>	def	product_even_fibs(n):
  								"""Return	the	product	of	the	first	n	even	Fibonacci	numbers,	except	0."""
  								return	reduce(mul,	filter(iseven,	map(fib,	range(2,	n+1))))
  >>>	product_even_fibs(20)
  123476336640
与 	map	、 	filter	和 	reduce	对应的高阶过程的组合会再一次在第四章出现,在我们思考多台
计算机之间的分布式计算方法的时候。
                                                                                    74
2.4	可变数据
2.4	可变数据
   来源:2.4	Mutable	Data
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
我们已经看到了抽象在帮助我们应对大型系统的复杂性时如何至关重要。有效的程序整合也
需要一些组织原则,指导我们构思程序的概要设计。特别地,我们需要一些策略来帮助我们
构建大型系统,使之模块化。也就是说,它们可以“自然”划分为可以分离开发和维护的各个相
关部分。
我们用于创建模块化程序的强大工具之一,是引入可能会随时间改变的新类型数据。这样,
单个数据可以表示独立于其他程序演化的东西。对象行为的改变可能会由它的历史影响,就
像世界中的实体那样。向数据添加状态是这一章最终目标:面向对象编程的要素。
我们目前引入的原生数据类型	--	数值、布尔值、元组、范围和字符串	--	都是不可变类型的对
象。虽然名称的绑定可以在执行过程中修改为环境中不同的值,但是这些值本身不会改变。
这一章中,我们会介绍一组可变数据类型。可变对象可以在程序执行期间改变。
2.4.1	局部状态
我们第一个可变对象的例子就是局部状态。这个状态会在程序执行期间改变。
为了展示函数的局部状态是什么东西,让我们对从银行取钱的情况进行建模。我们会通过创
建叫做 	withdraw	的函数来实现它,它将要取出的金额作为参数。如果账户中有足够的钱来取
出, 	withdraw	应该返回取钱之后的余额。否则, 	withdraw	应该返回消
息 	'Insufficient	funds'	。例如,如果我们以账户中的 	$100	开始,我们希望通过调
用 	withdraw	来得到下面的序列:
  >>>	withdraw(25)
  75
  >>>	withdraw(25)
  50
  >>>	withdraw(60)
  'Insufficient	funds'
  >>>	withdraw(15)
  35
观察表达式 	withdraw(25)	,求值了两次,产生了不同的值。这是一种用户定义函数的新行
为:它是非纯函数。调用函数不仅仅返回一个值,同时具有以一些方式修改函数的副作用,
使带有相同参数的下次调用返回不同的结果。我们所有用户定义的函数,到目前为止都是纯
                                                       75
2.4	可变数据
函数,除非他们调用了非纯的内建函数。它们仍旧是纯函数,因为它们并不允许修改任何在
局部环境帧之外的东西。
为了使 	withdraw	有意义,它必须由一个初始账户余额创建。 	make_withdraw	函数是个高阶函
数,接受起始余额作为参数, 	withdraw	函数是它的返回值。
  >>>	withdraw	=	make_withdraw(100)
	make_withdraw	的实现需要新类型的语句: 	nonlocal	语句。当我们调用 	make_withdraw	时,
我们将名称 	balance	绑定到初始值上。之后我们定义并返回了局部函数, 	withdraw	,它在调
用时更新并返回 	balance	的值。
  >>>	def	make_withdraw(balance):
  								"""Return	a	withdraw	function	that	draws	down	balance	with	each	call."""
  								def	withdraw(amount):
  												nonlocal	balance																	#	Declare	the	name	"balance"	nonlocal
  												if	amount	>	balance:
  																return	'Insufficient	funds'
  												balance	=	balance	-	amount							#	Re-bind	the	existing	balance	name
  												return	balance
  								return	withdraw
这个实现的新奇部分是 	nonlocal	语句,无论什么时候我们修改了名称 	balance	的绑定,绑定
都会在 	balance	所绑定的第一个帧中修改。回忆一下,在没有 	nonlocal	语句的情况下,赋值
语句总是会在环境的第一个帧中绑定名称。 	nonlocal	语句表明,名称出现在环境中不是第一
个(局部)帧,或者最后一个(全局)帧的其它地方。
我们可以将这些修改使用环境图示来可视化。下面的环境图示展示了每个调用的效果,以上
面的定义开始。我们省略了函数值中的代码,以及不在我们讨论中的表达式树。
我们的定义语句拥有平常的效果:它创建了新的用户定义函数,并且将名称 	make_withdraw	在
全局帧中绑定到那个函数上。
下面,我们使用初始的余额参数 	20	来调用 	make_withdraw	。
  >>>	wd	=	make_withdraw(20)
这个赋值语句将名称 	wd	绑定到全局帧中的返回函数上:
                                                                                     76
2.4	可变数据
所返回的函数,(内部)叫做 	withdraw	,和定义所在位置即 	make_withdraw	的局部环境相关
联。名称 	balance	在这个局部环境中绑定。在例子的剩余部分中, 	balance	名称只有这一个
绑定,这非常重要。
下面,我们求出以总数 	5	调用 	withdraw	的表达式的值:
  >>>	wd(5)
  15
名称 	wd	绑定到了 	withdraw	函数上,所以 	withdraw	的函数体在新的环境中求值,新的环境扩
展自 	withdraw	定义所在的环境。跟踪 	withdraw	求值的效果展示了	Python	中 	nonlocal	语句
的效果。
                                                                77
2.4	可变数据
	withdraw	的赋值语句通常在 	withdraw	的局部帧中为 	balance	创建新的绑定。由
于 	nonlocal	语句,赋值运算找到了 	balance	定义位置的第一帧,并在那里重新绑定名称。如
果 	balance	之前没有绑定到值上,那么 	nonlocal	语句会产生错误。
通过修改 	balance	绑定的行为,我们也修改了 	withdraw	函数。下次 	withdraw	调用的时候,
名称 	balance	会求值为 	15	而不是 	20	。
当我们第二次调用 	wd	时,
  >>>	wd(3)
  12
我们发现绑定到 	balance	的值的修改可在两个调用之间积累。
                                                           78
2.4	可变数据
这里,第二次调用 	withdraw	会创建第二个局部帧,像之前一样,但是, 	withdraw	的两个帧
都扩展自 	make_withdraw	的环境,它们都包含 	balance	的绑定。所以,它们共享特定的名称绑
定,调用 	withdraw	具有改变环境的副作用,并且会由之后的 	withdraw	调用继承。
实践指南。通过引入 	nonlocal	语句,我们发现了赋值语句的双重作用。它们修改局部绑定,
或者修改非局部绑定。实际上,赋值语句已经有了两个作用:创建新的绑定,或者重新绑定
现有名称。Python	赋值的许多作用使赋值语句的执行效果变得模糊。作为一个程序员,你应
该用文档清晰记录你的代码,使赋值的效果可被其它人理解。
2.4.2	非局部赋值的好处
非局部赋值是将程序作为独立和自主的对象观察的重要步骤,对象彼此交互,但是各自管理
各自的内部状态。
特别地,非局部赋值提供了在函数的局部范围中维护一些状态的能力,这些状态会在函数之
后的调用中演化。和特定 	withdraw	函数相关的 	balance	在所有该函数的调用中共享。但
是, 	withdraw	实例中的 	balance	绑定对程序的其余部分不可见。只有 	withdraw	关联到
了 	make_withdraw	的帧, 	withdraw	在那里被定义。如果 	make_withdraw	再次调用,它会创建
单独的帧,带有单独的 	balance	绑定。
我们可以继续以我们的例子来展示这个观点。 	make_withdraw	的第二个调用返回了第二
个 	withdraw	函数,它关联到了另一个环境上。
  >>>	wd2	=	make_withdraw(7)
                                                                 79
2.4	可变数据
第二个 	withdraw	函数绑定到了全局帧的名称 	wd2	上。我们使用星号来省略了表示这个绑定的
线。现在,我们看到实际上有两个 	balance	的绑定。名称 	wd	仍旧绑定到余额
为 	12	的 	withdraw	函数上,而 	wd2	绑定到了余额为 	7	的新的 	withdraw	函数上。
最后,我们调用绑定到 	wd2	上的第二个 	withdraw	函数:
  >>>	wd2(6)
  1
这个调用修改了非局部名称 	balance	的绑定,但是不影响在全局帧中绑定到名称 	wd	的第一
个 	withdraw	。
                                                           80
2.4	可变数据
这样, 	withdraw	的每个实例都维护它自己的余额状态,但是这个状态对程序中其它函数不可
见。在更高层面上观察这个情况,我们创建了银行账户的抽象,它管理自己的内部状态,但
以一种方式对真实世界的账户进行建模:它基于自己的历史提取请求来随时间变化。
2.4.3	非局部赋值的代价
我们扩展了我们的计算环境模型,用于解释非局部赋值的效果。但是,非局部复制与我们思
考名称和值的方式有一些细微差异。
之前,我们的值并没有改变,仅仅是我们的名称和绑定发生了变化。当两个名称 	a	和 	b	绑定
到 	4	上时,它们绑定到了相同的 	4	还是不同的 	4	并不重要。我们说,只有一个 	4	对象,并
且它永不会改变。
但是,带有状态的函数不是这样的。当两个名称 	wd	和 	wd2	都绑定到 	withdraw	函数时,它们
绑定到相同函数还是函数的两个不同实例,就很重要了。考虑下面的例子,它与我们之前分
析的那个正好相反:
  >>>	wd	=	make_withdraw(12)
  >>>	wd2	=	wd
  >>>	wd2(1)
  11
  >>>	wd(1)
  10
                                                     81
2.4	可变数据
这里,通过 	wd2	调用函数会修改名称为 	wd	的函数的值,因为两个名称都指向相同的函数。
这些语句执行之后的环境图示展示了这个现象:
两个名称指向同一个值在世界上不常见,但我们程序中就是这样。但是,由于值会随时间改
变,我们必须非常仔细来理解其它名称上的变化效果,它们可能指向这些值。
正确分析带有非局部赋值代码的关键是,记住只有函数调用可以创建新的帧。赋值语句始终
改变现有帧中的绑定。这里,除非 	make_withdraw	调用了两次, 	balance	还是只有一个绑定。
变与不变。这些细微差别出现的原因是,通过引入修改非局部环境的非纯函数,我们改变了
表达式的本质。只含有纯函数的表达式是引用透明(referentially	transparent)的。如果我们
将它的子表达式换成子表达式的值,它的值不会改变。
重新绑定的操作违反了引用透明的条件,因为它们不仅仅返回一个值。它们修改了环境。当
我们引入任意重绑定的时候,我们就会遇到一个棘手的认识论问题:它对于两个相同的值意
味着什么。在我们的计算环境模型中,两个分别定义的函数并不是相同的,因为其中一个的
改变并不影响另一个。
通常,只要我们不会修改数据对象,我们就可以将复合数据对象看做其部分的总和。例如,
有理数可以通过提供分子和分母来确定。但是这个观点在变化出现时不再成立了,其中复合
数据对象拥有一个“身份”,不同于组成它的各个部分。即使我们通过取钱来修改了余额,某个
银行账户还是“相同”的银行账户。相反,我们可以让两个银行账户碰巧具有相同的余额,但它
们是不同的对象。
                                                       82
2.4	可变数据
尽管它引入了新的困难,非局部赋值是个创建模块化编程的强大工具,程序的不同部分,对
应不同的环境帧,可以在程序执行中独立演化。而且,使用带有局部状态的函数,我们就能
实现可变数据类型。在这一节的剩余部分,我们介绍了一些最实用的	Python	内建数据类型,
以及使用带有非局部赋值的函数,来实现这些数据类型的一些方法。
2.4.4	列表
	list	是	Python	中最使用和灵活的洗了类型。列表类似于元组,但是它是可变的。方法调用
和赋值语句都可以修改列表的内容。
我们可以通过一个展示(极大简化的)扑克牌历史的例子,来介绍许多列表编辑操作。例子
中的注释描述了每个方法的效果。
扑克牌发明于中国,大概在	9	世纪。早期的牌组中有三个花色,它们对应钱的三个面额。
  >>>	chinese_suits	=	['coin',	'string',	'myriad']		#	A	list	literal
  >>>	suits	=	chinese_suits																									#	Two	names	refer	to	the	same	list
扑克牌传到欧洲(也可能通过埃及)之后,西班牙的牌组(oro)中之只保留了硬币的花色。
  >>>	suits.pop()													#	Removes	and	returns	the	final	element
  'myriad'
  >>>	suits.remove('string')		#	Removes	the	first	element	that	equals	the	argument
然后又添加了三个新的花色(它们的设计和名称随时间而演化),
  >>>	suits.append('cup')														#	Add	an	element	to	the	end
  >>>	suits.extend(['sword',	'club'])		#	Add	all	elements	of	a	list	to	the	end
意大利人把剑叫做“黑桃”:
  >>>	suits[2]	=	'spade'		#	Replace	an	element
下面是传统的意大利牌组:
  >>>	suits
  ['coin',	'cup',	'spade',	'club']
我们现在在美国使用的法式变体修改了前两个:
  >>>	suits[0:2]	=	['heart',	'diamond']		#	Replace	a	slice
  >>>	suits
  ['heart',	'diamond',	'spade',	'club']
                                                                                       83
2.4	可变数据
也存在用于插入、排序和反转列表的操作。所有这些修改操作都改变了列表的值,它们并不
创建新的列表对象。
共享和身份。由于我们修改了一个列表,而不是创建新的列表,绑定到名称 	chinese_suits	上
的对象也改变了,因为它与绑定到 	suits	上的对象是相同的列表对象。
  >>>	chinese_suits		#	This	name	co-refers	with	"suits"	to	the	same	list
  ['heart',	'diamond',	'spade',	'club']
列表可以使用 	list	构造函数来复制。其中一个的改变不会影响另一个,除非它们共享相同的
结构。
  >>>	nest	=	list(suits)		#	Bind	"nest"	to	a	second	list	with	the	same	elements
  >>>	nest[0]	=	suits					#	Create	a	nested	list
在最后的赋值之后,我们只剩下下面的环境,其中列表使用盒子和指针的符号来表示:
根据这个环境,修改由 	suites	指向的列表会影响 	nest	第一个元素的嵌套列表,但是不会影
响其他元素:
  >>>	suits.insert(2,	'Joker')		#	Insert	an	element	at	index	2,	shifting	the	rest
  >>>	nest
  [['heart',	'diamond',	'Joker',	'spade',	'club'],	'diamond',	'spade',	'club']
与之类似,在 	next	的第一个元素上撤销这个修改也会影响到 	suit	。
由于这个 	pop	方法的调用,我们返回到了上面描述的环境。
由于两个列表具有相同内容,但是实际上是不同的列表,我们需要一种手段来测试两个对象
是否相同。Python	引入了两个比较运算符,叫做 	is	和 	is	not	,测试了两个表达式实际上是
否求值为同一个对象。如果两个对象的当前值相等,并且一个对象的改变始终会影响另一
个,那么两个对象是同一个对象。身份是个比相等性更强的条件。
                                                                                  84
2.4	可变数据
   译者注:两个对象当且仅当在内存中的位置相同时为同一个对象。CPython	的实现直接
   比较对象的地址来确定。
  >>>	suits	is	nest[0]
  True
  >>>	suits	is	['heart',	'diamond',	'spade',	'club']
  False
  >>>	suits	==	['heart',	'diamond',	'spade',	'club']
  True
最后的两个比较展示了 	is	和 	==	的区别,前者检查身份,而后者检查内容的相等性。
列表推导式。列表推导式使用扩展语法来创建列表,与生成器表达式的语法相似。
例如, 	unicodedata	模块跟踪了	Unicode	字母表中每个字符的官方名称。我们可以查找与名
称对应的字符,包含这些卡牌花色的字符。
  >>>	from	unicodedata	import	lookup
  >>>	[lookup('WHITE	'	+	s.upper()	+	'	SUIT')	for	s	in	suits]
  ['♡',	'♢',	'♤',	'♧']
列表推导式使用序列的接口约定增强了数据处理的范式,因为列表是一种序列数据类型。
扩展阅读。Dive	Into	Python	3	的推导式一章包含了一些示例,展示了如何使用	Python	浏览
计算机的文件系统。这一章介绍了 	os	模块,它可以列出目录的内容。这个材料并不是这门课
的一部分,但是推荐给任何想要增加	Python	知识和技巧的人。
实现。列表是序列,就像元组一样。Python	语言并不提供给我们列表实现的直接方法,只提
供序列抽象,和我们在这一节介绍的可变方法。为了克服这一语言层面的抽象界限,我们可
以开发列表的函数式实现,再次使用递归表示。这一节也有第二个目的:加深我们对调度函
数的理解。
我们会将列表实现为函数,它将一个递归列表作为自己的局部状态。列表需要有一个身份,
就像任何可变值那样。特别地,我们不能使用 	None	来表示任何空的可变列表,因为两个空列
表并不是相同的值(例如,向一个列表添加元素并不会添加到另一个),但
是 	None	is	None	。另一方面,两个不同的函数足以区分两个两个空列表,它们都
将 	empty_rlist	作为局部状态。
我们的可变列表是个调度函数,就像我们偶对的函数式实现也是个调度函数。它检查输入“信
息”是否为已知信息,并且对每个不同的输入执行相应的操作。我们的可变列表可响应五个不
同的信息。前两个实现了序列抽象的行为。接下来的两个添加或删除列表的第一个元素。最
后的信息返回整个列表内容的字符串表示。
                                                              85
2.4	可变数据
  >>>	def	make_mutable_rlist():
  								"""Return	a	functional	implementation	of	a	mutable	recursive	list."""
  								contents	=	empty_rlist
  								def	dispatch(message,	value=None):
  												nonlocal	contents
  												if	message	==	'len':
  																return	len_rlist(contents)
  												elif	message	==	'getitem':
  																return	getitem_rlist(contents,	value)
  												elif	message	==	'push_first':
  																contents	=	make_rlist(value,	contents)
  												elif	message	==	'pop_first':
  																f	=	first(contents)
  																contents	=	rest(contents)
  																return	f
  												elif	message	==	'str':
  																return	str(contents)
  								return	dispatch
我们也可以添加一个辅助函数,来从任何内建序列中构建函数式实现的递归列表。只需要以
递归顺序添加每个元素。
  >>>	def	to_mutable_rlist(source):
  								"""Return	a	functional	list	with	the	same	contents	as	source."""
  								s	=	make_mutable_rlist()
  								for	element	in	reversed(source):
  												s('push_first',	element)
  								return	s
在上面的定义中,函数 	reversed	接受并返回可迭代值。它是使用序列的接口约定的另一个示
例。
这里,我们可以构造函数式实现的列表,要注意列表自身也是个函数。
  >>>	s	=	to_mutable_rlist(suits)
  >>>	type(s)
  <class	'function'>
  >>>	s('str')
  "('heart',	('diamond',	('spade',	('club',	None))))"
另外,我们可以像列表 	s	传递信息来修改它的内容,比如移除第一个元素。
  >>>	s('pop_first')
  'heart'
  >>>	s('str')
  "('diamond',	('spade',	('club',	None)))"
原则上,操作 	push_first	和 	pop_first	足以对列表做任意修改。我们总是可以清空整个列
表,之后将它旧的内容替换为想要的结果。
消息传递。给予一些时间,我们就能实现许多实用的	Python	列表可变操作,比
如 	extend	和 	insert	。我们有一个选择:我们可以将它们全部实现为函数,这会使用现有的
消息 	pop_first	和 	push_first	来实现所有的改变操作。作为代替,我们也可以向 	dispatch	函
                                                                                86
2.4	可变数据
数体添加额外的 	elif	子句,每个子句检查一个消息(例如 	'extend'	),并且直接
在 	contents	上做出合适的改变。
第二个途径叫做消息传递,它把数据值上面所有操作的逻辑封装在一个函数中,这个函数响
应不同的消息。一个使用消息传递的程序定义了调度函数,每个函数都拥有局部状态,通过
传递“消息”作为第一个参数给这些函数来组织计算。消息是对应特定行为的字符串。
可以想象,在 	dispatch	的函数体中通过名称来枚举所有这些消息非常无聊,并且易于出现错
误。Python	的字典提供了一种数据类型,会帮助我们管理消息和操作之间的映射,它会在下
一节中介绍。
2.4.5	字典
字典是	Python	内建数据类型,用于储存和操作对应关系。字典包含了键值对,其中键和值都
可以是对象。字典的目的是提供一种抽象,用于储存和获取下标不是连续整数,而是描述性
的键的值。
字符串通常用作键,因为字符串通常用于表示事物名称。这个字典字面值提供了不同罗马数
字的值。
  >>>	numerals	=	{'I':	1.0,	'V':	5,	'X':	10}
我们可以使用元素选择运算符,来通过键查找值,我们之前将其用于序列。
  >>>	numerals['X']
  10
字典的每个键最多只能拥有一个值。添加新的键值对或者修改某个键的已有值,可以使用赋
值运算符来完成。
  >>>	numerals['I']	=	1
  >>>	numerals['L']	=	50
  >>>	numerals
  {'I':	1,	'X':	10,	'L':	50,	'V':	5}
要注意, 	'L'	并没有添加到上面输出的末尾。字典是无序的键值对集合。当我们打印字典
时,键和值都以某种顺序来渲染,但是对语言的用户来说,不应假设顺序总是这样。
字典抽象也支持多种方法,来从整体上迭代字典中的内容。方法 	keys	、 	values	和 	items	都
返回可迭代的值。
  >>>	sum(numerals.values())
  66
                                                       87
2.4	可变数据
通过调用 	dict	构造函数,键值对的列表可以转换为字典。
  >>>	dict([(3,	9),	(4,	16),	(5,	25)])
  {3:	9,	4:	16,	5:	25}
字典也有一些限制:
    字典的键不能是可变内建类型的对象。
    一个给定的键最多只能有一个值。
第一条限制被绑定到了	Python	中字典的底层实现上。这个实现的细节并不是这门课的主题。
直觉上,键告诉了	Python	应该在内存中的哪里寻找键值对;如果键发生改变,键值对就会丢
失。
第二个限制是字典抽象的结果,它为储存和获取某个键的值而设计。如果字典中最多只存在
一个这样的值,我们只能获取到某个键的一个值。
由字典实现的一个实用方法是 	get	,如果键存在的话,它返回键的值,否则返回一个默认
值。 	get	的参数是键和默认值。
  >>>	numerals.get('A',	0)
  0
  >>>	numerals.get('V',	0)
  5
字典也拥有推导式语法,和列表和生成器表达式类似。求解字典推导式会产生新的字典对
象。
  >>>	{x:	x*x	for	x	in	range(3,6)}
  {3:	9,	4:	16,	5:	25}
实现。我们可以实现一个抽象数据类型,它是一个记录的列表,与字典抽象一致。每个记录
都是两个元素的列表,包含键和相关的值。
                                            88
2.4	可变数据
  >>>	def	make_dict():
  								"""Return	a	functional	implementation	of	a	dictionary."""
  								records	=	[]
  								def	getitem(key):
  												for	k,	v	in	records:
  																if	k	==	key:
  																				return	v
  								def	setitem(key,	value):
  												for	item	in	records:
  																if	item[0]	==	key:
  																				item[1]	=	value
  																				return
  												records.append([key,	value])
  								def	dispatch(message,	key=None,	value=None):
  												if	message	==	'getitem':
  																return	getitem(key)
  												elif	message	==	'setitem':
  																setitem(key,	value)
  												elif	message	==	'keys':
  																return	tuple(k	for	k,	_	in	records)
  												elif	message	==	'values':
  																return	tuple(v	for	_,	v	in	records)
  								return	dispatch
同样,我们使用了传递方法的消息来组织我们的实现。我们已经支持了四种消
息: 	getitem	、 	setitem	、 	keys	和 	values	。要查找某个键的值,我们可以迭代这些记录来
寻找一个匹配的键。要插入某个键的值,我们可以迭代整个记录来观察是否已经存在带有这
个键的记录。如果没有,我们会构造一条新的记录。如果已经有了带有这个键的记录,我们
将这个记录的值设为新的值。
我们现在可以使用我们的实现来储存和获取值。
  >>>	d	=	make_dict()
  >>>	d('setitem',	3,	9)
  >>>	d('setitem',	4,	16)
  >>>	d('getitem',	3)
  9
  >>>	d('getitem',	4)
  16
  >>>	d('keys')
  (3,	4)
  >>>	d('values')
  (9,	16)
这个字典实现并不为快速的记录检索而优化,因为每个响应 	getitem	消息都必须迭代整
个 	records	列表。内建的字典类型更加高效。
2.4.6	示例:传播约束
可变数据允许我们模拟带有变化的系统,也允许我们构建新的抽象类型。在这个延伸的实例
中,我们组合了非局部赋值、列表和字典来构建一个基于约束的系统,支持多个方向上的计
算。将程序表达为约束是一种声明式编程,其中程序员声明需要求解的问题结构,但是抽象
了问题解决方案如何计算的细节。
                                                                    89
2.4	可变数据
计算机程序通常组织为单方向的计算,它在预先设定的参数上执行操作,来产生合理的输
出。另一方面,我们通常希望根据数量上的关系对系统建模。例如,我们之前考虑过理想气
体定律,它通过波尔兹曼常数 	k	关联了理想气体的气压 	p	,体积 	v	,数量 	n	以及温度 	t	。
  p	*	v	=	n	*	k	*	t
这样一个方程并不是单方向的。给定任何四个数量,我们可以使用这个方程来计算第五个。
但将这个方程翻译为某种传统的计算机语言会强迫我们选择一个数量,根据其余四个计算出
来。所以计算气压的函数应该不能用于计算温度,即使二者的计算通过相同的方程完成。
这一节中,我们从零开始设计线性计算的通用模型。我们定义了数量之间的基本约束,例
如 	adder(a,	b,	c)	会严格保证数学关系 	a	+	b	=	c	。
我们也定义了组合的手段,使基本约束可以被组合来表达更复杂的关系。这样,我们的程序
就像一种编程语言。我们通过构造网络来组合约束,其中约束由连接器连接。连接器是一种
对象,它“持有”一个值,并且可能会参与一个或多个约束。
例如,我们知道华氏和摄氏温度的关系是:
  9	*	c	=	5	*	(f	-	32)
这个等式是 	c	和 	f	之间的复杂约束。这种约束可以看做包
含 	adder	、 	multiplier	和 	contant	约束的网络。
这张图中,我们可以看到,左边是一个带有三个终端的乘法器盒子,标记为 	a	, 	b	和 	c	。
它们将乘法器连接到网络剩余的部分:终端 	a	链接到了连接器 	celsius	上,它持有摄氏温
度。终端 	b	链接到了连接器 	w	上, 	w	也链接到持有 	9	的盒子上。终端 	c	,被乘法器盒子约
束为 	a	和 	b	的乘积,链接到另一个乘法器盒子上,它的 	b	链接到常数 	5	上,以及它的 	a	连
接到了求和约束的一项上。
这个网络上的计算会如下进行:当连接器被提供一个值时(被用户或被链接到它的约束
器),它会唤醒所有相关的约束(除了刚刚唤醒的约束)来通知它们它得到了一个值。每个
唤醒的约束之后会调查它的连接器,来看看是否有足够的信息来为连接器求出一个值。如果
可以,盒子会设置这个连接器,连接器之后会唤醒所有相关的约束,以此类推。例如,在摄
氏温度和华氏温度的转换中, 	w	、 	x	和 	y	会被常量盒子 	9	、 	5	和 	32	立即设置。连接器会
唤醒乘法器和加法器,它们判断出没有足够的信息用于处理。如果用户(或者网络的其它部
                                                         90
2.4	可变数据
分)将 	celsis	连接器设置为某个值(比如 	25	),最左边的乘法器会被唤醒,之后它会
将 	u	设置为 	25	*	9	=	225	。之后 	u	会唤醒第二个乘法器,它会将 	v	设置为 	45	,之后 	v	会
唤醒加法器,它将 	fahrenheit	连接器设置为 	77	。
使用约束系统。为了使用约束系统来计算出上面所描述的温度计算,我们首先创建了两个具
名连接器, 	celsius	和 	fahrenheit	,通过调用 	make_connector	构造器。
  >>>	celsius	=	make_connector('Celsius')
  >>>	fahrenheit	=	make_connector('Fahrenheit')
之后,我们将这些连接器链接到网络中,这个网络反映了上面的图示。函
数 	make_converter	组装了网络中不同的连接器和约束:
  >>>	def	make_converter(c,	f):
  								"""Connect	c	to	f	with	constraints	to	convert	from	Celsius	to	Fahrenheit."""
  								u,	v,	w,	x,	y	=	[make_connector()	for	_	in	range(5)]
  								multiplier(c,	w,	u)
  								multiplier(v,	x,	u)
  								adder(v,	y,	f)
  								constant(w,	9)
  								constant(x,	5)
  								constant(y,	32)
  >>>	make_converter(celsius,	fahrenheit)
我们会使用消息传递系统来协调约束和连接器。我们不会使用函数来响应消息,而是使用字
典。用于分发的字典拥有字符串类型的键,代表它接受的消息。这些键关联的值是这些消息
的响应。
约束是不带有局部状态的字典。它们对消息的响应是非纯函数,这些函数会改变所约束的连
接器。
连接器是一个字典,持有当前值并响应操作该值的消息。约束不会直接改变连接器的值,而
是会通过发送消息来改变,于是连接器可以提醒其他约束来响应变化。这样,连接器代表了
一个数值,同时封装了连接器的行为。
我们可以发送给连接器的一种消息是设置它的值。这里,我们( 	'user'	)将 	celsius	的值设
置为 	25	。
  >>>	celsius['set_val']('user',	25)
  Celsius	=	25
  Fahrenheit	=	77.0
不仅仅是 	celsius	的值变成了 	25	,它的值也在网络上传播,于是 	fahrenheit	的值也发生变
化。这些变化打印了出来,因为我们在构造这两个连接器的时候命名了它们。
现在我们可以试着将 	fahrenheit	设置为新的值,比如 	212	。
                                                                                       91
2.4	可变数据
  >>>	fahrenheit['set_val']('user',	212)
  Contradiction	detected:	77.0	vs	212
连接器报告说,它察觉到了一个矛盾:它的值是 	77.0	,但是有人尝试将其设置为 	212	。如
果我们真的想以新的值复用这个网络,我们可以让 	celsius	忘掉旧的值。
  >>>	celsius['forget']('user')
  Celsius	is	forgotten
  Fahrenheit	is	forgotten
连接器 	celsius	发现了 	user	,一开始设置了它的值,现在又想撤销这个值,所以 	celsius	同
意丢掉这个值,并且通知了网络的其余部分。这个消息最终传播给 	fahrenheit	,它现在发现
没有理由继续相信自己的值为 	77	。于是,它也丢掉了它的值。
现在 	fahrenheit	没有值了,我们就可以将其设置为 	212	:
  >>>	fahrenheit['set_val']('user',	212)
  Fahrenheit	=	212
  Celsius	=	100.0
这个新值在网络上传播,并强迫 	celsius	持有值 	100	。我们已经使用了非常相似的网络,提
供 	fahrenheit	来计算 	celsius	,以及提供 	celsius	来计算 	fahrenheit	。这个无方向的计算就
是基于约束的网络的特征。
实现约束系统。像我们看到的那样,连接器是字典,将消息名称映射为函数和数据值。我们
将要实现响应下列消息的连接器:
     	connector['set_val'](source,	value)		表示 	source	请求连接器将当前值设置为该值。
     	connector['has_val']()		返回连接器是否已经有了一个值。
     	connector['val']		是连接器的当前值。
     	connector['forget'](source)		告诉连接器, 	source	请求它忘掉当前值。
     	connector['connect'](source)		告诉连接器参与新的约束 	source	。
约束也是字典,接受来自连接器的以下两种消息:
     	constraint['new_val']()		表示连接到约束的连接器有了新的值。
     	constraint['forget']()		表示连接到约束的连接器需要忘掉它的值。
当约束收到这些消息时,它们适当地将它们传播给其它连接器。
	adder	函数在两个连接器上构造了加法器约束,其中前两个连接器必须加到第三个
上: 	a	+	b	=	c	。为了支持多方向的约束传播,加法器必须也规定从 	c	中减去 	a	会得
到 	b	,或者从 	c	中减去 	b	会得到 	a	。
                                                                      92
2.4	可变数据
  >>>	from	operator	import	add,	sub
  >>>	def	adder(a,	b,	c):
  								"""The	constraint	that	a	+	b	=	c."""
  								return	make_ternary_constraint(a,	b,	c,	add,	sub,	sub)
我们希望实现一个通用的三元(三个方向)约束,它使用三个连接器和三个函数来创建约
束,接受 	new_val	和 	forget	消息。消息的响应是局部函数,它放在叫做 	constraint	的字典
中。
  >>>	def	make_ternary_constraint(a,	b,	c,	ab,	ca,	cb):
  								"""The	constraint	that	ab(a,b)=c	and	ca(c,a)=b	and	cb(c,b)	=	a."""
  								def	new_value():
  												av,	bv,	cv	=	[connector['has_val']()	for	connector	in	(a,	b,	c)]
  												if	av	and	bv:
  																c['set_val'](constraint,	ab(a['val'],	b['val']))
  												elif	av	and	cv:
  																b['set_val'](constraint,	ca(c['val'],	a['val']))
  												elif	bv	and	cv:
  																a['set_val'](constraint,	cb(c['val'],	b['val']))
  								def	forget_value():
  												for	connector	in	(a,	b,	c):
  																connector['forget'](constraint)
  								constraint	=	{'new_val':	new_value,	'forget':	forget_value}
  								for	connector	in	(a,	b,	c):
  												connector['connect'](constraint)
  								return	constraint
叫做 	constraint	的字典是个分发字典,也是约束对象自身。它响应两种约束接收到的消息,
也在对连接器的调用中作为 	source	参数传递。
无论约束什么时候被通知,它的连接器之一拥有了值,约束的局部函数 	new_value	都会被调
用。这个函数首先检查是否 	a	和 	b	都拥有值,如果是这样,它告诉 	c	将值设为函数 	ab	的返
回值,在 	adder	中是 	add	。约束,也就是 	adder	对象,将自身作为 	source	参数传递给连接
器。如果 	a	和 	b	不同时拥有值,约束会检查 	a	和 	c	,以此类推。
如果约束被通知,连接器之一忘掉了它的值,它会请求所有连接器忘掉它们的值(只有由约
束设置的值会被真正丢掉)。
	multiplier	与 	adder	类似:
  >>>	from	operator	import	mul,	truediv
  >>>	def	multiplier(a,	b,	c):
  								"""The	constraint	that	a	*	b	=	c."""
  								return	make_ternary_constraint(a,	b,	c,	mul,	truediv,	truediv)
常量也是约束,但是它不会发送任何消息,因为它只包含一个单一的连接器,在构造的时候
会设置它。
  >>>	def	constant(connector,	value):
  								"""The	constraint	that	connector	=	value."""
  								constraint	=	{}
  								connector['set_val'](constraint,	value)
  								return	constraint
                                                                               93
2.4	可变数据
这三个约束足以实现我们的温度转换网络。
表示连接器。连接器表示为包含一个值的字典,但是同时拥有带有局部状态的响应函数。连
接器必须跟踪向它提供当前值的 	informant	,以及它所参与的 	constraints	列表。
构造器 	make_connector	是局部函数,用于设置和忘掉值,它响应来自约束的消息。
  >>>	def	make_connector(name=None):
  								"""A	connector	between	constraints."""
  								informant	=	None
  								constraints	=	[]
  								def	set_value(source,	value):
  												nonlocal	informant
  												val	=	connector['val']
  												if	val	is	None:
  																informant,	connector['val']	=	source,	value
  																if	name	is	not	None:
  																				print(name,	'=',	value)
  																inform_all_except(source,	'new_val',	constraints)
  												else:
  																if	val	!=	value:
  																				print('Contradiction	detected:',	val,	'vs',	value)
  								def	forget_value(source):
  												nonlocal	informant
  												if	informant	==	source:
  																informant,	connector['val']	=	None,	None
  																if	name	is	not	None:
  																				print(name,	'is	forgotten')
  																inform_all_except(source,	'forget',	constraints)
  								connector	=	{'val':	None,
  																					'set_val':	set_value,
  																					'forget':	forget_value,
  																					'has_val':	lambda:	connector['val']	is	not	None,
  																					'connect':	lambda	source:	constraints.append(source)}
  								return	connector
同时,连接器是一个分发字典,用于分发五个消息,约束使用它们来和连接器通信。前四个
响应都是函数,最后一个响应就是值本身。
局部函数 	set_value	在请求设置连接器的值时被调用。如果连接器当前并没有值,它会设置
该值并将 	informant	记为请求设置该值的 	source	约束。之后连接器会提醒所有参与的约束,
除了请求设置该值的约束。这通过使用下列迭代函数来完成。
  >>>	def	inform_all_except(source,	message,	constraints):
  								"""Inform	all	constraints	of	the	message,	except	source."""
  								for	c	in	constraints:
  												if	c	!=	source:
  																c[message]()
如果一个连接器被请求忘掉它的值,它会调用局部函数 	forget_value	,这个函数首先执行检
查,来确保请求来自之前设置该值的同一个约束。如果是的话,连接器通知相关的约束来丢
掉当前值。
对 	has_val	消息的响应表示连接器是否拥有一个值。对 	connect	消息的响应将 	source	约束添
加到约束列表中。
                                                                             94
2.4	可变数据
我们设计的约束程序引入了许多出现在面向对象编程的概念。约束和连接器都是抽象,它们
通过消息来操作。当连接器的值由消息改变时,消息不仅仅改变了它的值,还对其验证(检
查来源)并传播它的影响。实际上,在这一章的后面,我们会使用相似的字符串值的字典结
构和函数值来实现面向对象系统。
                                        95
2.5	面向对象编程
2.5	面向对象编程
   来源:2.5	Object-Oriented	Programming
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
面向对象编程(OOP)是一种用于组织程序的方法,它组合了这一章引入的许多概念。就像
抽象数据类型那样,对象创建了数据使用和实现之间的抽象界限。类似消息传递中的分发字
典,对象响应行为请求。就像可变的数据结构,对象拥有局部状态,并且不能直接从全局环
境访问。Python	对象系统提供了新的语法,更易于为组织程序实现所有这些实用的技巧。
但是对象系统不仅仅提供了便利;它也为程序设计添加了新的隐喻,其中程序中的几个部分
彼此交互。每个对象将局部状态和行为绑定,以一种方式在数据抽象背后隐藏二者的复杂
性。我们的约束程序的例子通过在约束和连接器之前传递消息,产生了这种隐喻。Python	对
象系统使用新的途径扩展了这种隐喻,来表达程序的不同部分如何互相关联,以及互相通
信。对象不仅仅会传递消息,还会和其它相同类型的对象共享行为,以及从相关的类型那里
继承特性。
面向对象编程的范式使用自己的词汇来强化对象隐喻。我们已经看到了,对象是拥有方法和
属性的数据值,可以通过点运算符来访问。每个对象都拥有一个类型,叫做类。Python	中可
以定义新的类,就像定义函数那样。
2.5.1	对象和类
类可以用作所有类型为该类的对象的模板。每个对象都是某个特定类的实例。我们目前使用
的对象都拥有内建类型,但是我们可以定义新的类,就像定义函数那样。类的定义规定了在
该类的对象之间共享的属性和方法。我们会通过重新观察银行账户的例子,来介绍类的语
句。
在介绍局部状态时,我们看到,银行账户可以自然地建模为拥有 	balance	的可变值。银行账
户对象应该拥有 	withdraw	方法,在可用的情况下,它会更新账户余额,并返回所请求的金
额。我们希望添加一些额外的行为来完善账户抽象:银行账户应该能够返回它的当前余额,
返回账户持有者的名称,以及接受存款。
	Account	类允许我们创建银行账户的多个实例。创建新对象实例的动作被称为实例化该类。
Python	中实例化某个类的语法类似于函数的调用语句。这里,我们使用参数 	'Jim'	(账户持
有者的名称)来调用 	Account	。
  >>>	a	=	Account('Jim')
                                                96
2.5	面向对象编程
对象的属性是和对象关联的名值对,它可以通过点运算符来访问。属性特定于具体的对象,
而不是类的所有对象,也叫做实例属性。每个 	Account	对象都拥有自己的余额和账户持有者
名称,它们是实例属性的一个例子。在更宽泛的编程社群中,实例属性可能也叫做字段、属
性或者实例变量。
  >>>	a.holder
  'Jim'
  >>>	a.balance
  0
操作对象或执行对象特定计算的函数叫做方法。方法的副作用和返回值可能依赖或改变对象
的其它属性。例如, 	deposit	是 	Account	对象 	a	上的方法。它接受一个参数,即需要存入的
金额,修改对象的 	balance	属性,并返回产生的余额。
  >>>	a.deposit(15)
  15
在	OOP	中,我们说方法可以在特定对象上调用。作为调用 	withdraw	方法的结果,要么取钱
成功,余额减少并返回,要么请求被拒绝,账户打印出错误信息。
  >>>	a.withdraw(10)		#	The	withdraw	method	returns	the	balance	after	withdrawal
  5
  >>>	a.balance							#	The	balance	attribute	has	changed
  5
  >>>	a.withdraw(10)
  'Insufficient	funds'
像上面展示的那样,方法的行为取决于对象属性的改变。两次以相同参数对 	withdraw	的调用
返回了不同的结果。
2.5.2	类的定义
用户定义的类由 	class	语句创建,它只包含单个子句。类的语句定义了类的名称和基类(会
在继承那一节讨论),之后包含了定义类属性的语句组:
  class	<name>(<base	class>):
  				<suite>
当类的语句被执行时,新的类会被创建,并且在当前环境第一帧绑定到 	<name>	上。之后会执
行语句组。任何名称都会在 	class	语句的 	<suite>	中绑定,通过 	def	或赋值语句,创建或修
改类的属性。
类通常围绕实例属性来组织,实例属性是名值对,不和类本身关联但和类的每个对象关联。
通过为实例化新对象定义方法,类规定了它的对象的实例属性。
                                                                                 97
2.5	面向对象编程
	class	语句的 	<suite>	部分包含 	def	语句,它们为该类的对象定义了新的方法。用于实例化
对象的方法在	Python	中拥有特殊的名称, 	__init__	( 	init	两边分别有两个下划线),它叫
做类的构造器。
  >>>	class	Account(object):
  								def	__init__(self,	account_holder):
  												self.balance	=	0
  												self.holder	=	account_holder
	Account	的 	__init__	方法有两个形参。第一个是 	self	,绑定到新创建的 	Account	对象上。
第二个参数, 	account_holder	,在被调用来实例化的时候,绑定到传给该类的参数上。
构造器将实例属性名称 	balance	与 	0	绑定。它也将属性名称 	holder	绑定
到 	account_holder	上。形参 	account_holder	是 	__init__	方法的局部名称。另一方面,通过最
后一个赋值语句绑定的名称 	holder	是一直存在的,因为它使用点运算符被存储为 	self	的属
性。
定义了 	Account	类之后,我们就可以实例化它:
  >>>	a	=	Account('Jim')
这个对 	Account	类的“调用”创建了新的对象,它是 	Account	的实例,之后以两个参数调用了构
造函数 	__init__	:新创建的对象和字符串 	'Jim'	。按照惯例,我们使用名称 	self	来命名构
造器的第一个参数,因为它绑定到了被实例化的对象上。这个惯例在几乎所有	Python	代码中
都适用。
现在,我们可以使用点运算符来访问对象的 	balance	和 	holder	。
  >>>	a.balance
  0
  >>>	a.holder
  'Jim'
身份。每个新的账户实例都有自己的余额属性,它的值独立于相同类的其它对象。
  >>>	b	=	Account('Jack')
  >>>	b.balance	=	200
  >>>	[acc.balance	for	acc	in	(a,	b)]
  [0,	200]
为了强化这种隔离,每个用户定义类的实例对象都有个独特的身份。对象身份使
用 	is	和 	is	not	运算符来比较。
  >>>	a	is	a
  True
  >>>	a	is	not	b
  True
                                                                  98
2.5	面向对象编程
虽然由同一个调用来构造,绑定到 	a	和 	b	的对象并不相同。通常,使用赋值将对象绑定到新
名称并不会创建新的对象。
  >>>	c	=	a
  >>>	c	is	a
  True
用户定义类的新对象只在类(比如 	Account	)使用调用表达式被实例化的时候创建。
方法。对象方法也由 	class	语句组中的 	def	语句定义。下面, 	deposit	和 	withdraw	都被定义
为 	Account	类的对象上的方法:
  >>>	class	Account(object):
  								def	__init__(self,	account_holder):
  												self.balance	=	0
  												self.holder	=	account_holder
  								def	deposit(self,	amount):
  												self.balance	=	self.balance	+	amount
  												return	self.balance
  								def	withdraw(self,	amount):
  												if	amount	>	self.balance:
  																return	'Insufficient	funds'
  												self.balance	=	self.balance	-	amount
  												return	self.balance
虽然方法定义和函数定义在声明方式上并没有区别,方法定义有不同的效果。由 	class	语句
中的 	def	语句创建的函数值绑定到了声明的名称上,但是只在类的局部绑定为一个属性。这
个值可以使用点运算符在类的实例上作为方法来调用。
每个方法定义同样包含特殊的首个参数 	self	,它绑定到方法所调用的对象上。例如,让我们
假设 	deposit	在特定的 	Account	对象上调用,并且传递了一个对象值:要存入的金额。对象
本身绑定到了 	self	上,而参数绑定到了 	amount	上。所有被调用的方法能够通过 	self	参数
来访问对象,所以它们可以访问并操作对象的状态。
为了调用这些方法,我们再次使用点运算符,就像下面这样:
  >>>	tom_account	=	Account('Tom')
  >>>	tom_account.deposit(100)
  100
  >>>	tom_account.withdraw(90)
  10
  >>>	tom_account.withdraw(90)
  'Insufficient	funds'
  >>>	tom_account.holder
  'Tom'
当一个方法通过点运算符调用时,对象本身(这个例子中绑定到了 	tom_account	)起到了双重
作用。首先,它决定了 	withdraw	意味着哪个名称; 	withdraw	并不是环境中的名称,而
是 	Account	类局部的名称。其次,当 	withdraw	方法调用时,它绑定到了第一个参
数 	self	上。求解点运算符的详细过程会在下一节中展示。
                                                             99
2.5	面向对象编程
2.5.3	消息传递和点表达式
方法定义在类中,而实例属性通常在构造器中赋值,二者都是面向对象编程的基本元素。这
两个概念很大程度上类似于数据值的消息传递实现中的分发字典。对象使用点运算符接受消
息,但是消息并不是任意的、值为字符串的键,而是类的局部名称。对象也拥有具名的局部
状态值(实例属性),但是这个状态可以使用点运算符访问和操作,并不需要在实现中使
用 	nonlocal	语句。
消息传递的核心概念,就是数据值应该通过响应消息而拥有行为,这些消息和它们所表示的
抽象类型相关。点运算符是	Python	的语法特征,它形成了消息传递的隐喻。使用带有内建对
象系统语言的优点是,消息传递能够和其它语言特性,例如赋值语句无缝对接。我们并不需
要不同的消息来“获取”和“设置”关联到局部属性名称的值;语言的语法允许我们直接使用消息
名称。
点表达式。类似 	tom_account.deposit	的代码片段叫做点表达式。点表达式包含一个表达式,
一个点和一个名称:
  <expression>	.	<name>
	<expression>	可为任意的	Python	有效表达式,但是 	<name>	必须是个简单的名称(而不是求
值为 	name	的表达式)。点表达式会使用提供的 	<name>	,对值为 	<expression>	的对象求出属
性的值。
内建的函数 	getattr	也会按名称返回对象的属性。它是等价于点运算符的函数。使
用 	getattr	,我们就能使用字符串来查找某个属性,就像分发字典那样:
  >>>	getattr(tom_account,	'balance')
  10
我们也可以使用 	hasattr	测试对象是否拥有某个具名属性:
  >>>	hasattr(tom_account,	'deposit')
  True
对象的属性包含所有实例属性,以及所有定义在类中的属性(包括方法)。方法是需要特别
处理的类的属性。
方法和函数。当一个方法在对象上调用时,对象隐式地作为第一个参数传递给方法。也就是
说,点运算符左边值为 	<expression>	的对象,会自动传给点运算符右边的方法,作为第一个
参数。所以,对象绑定到了参数 	self	上。
为了自动实现 	self	的绑定,Python	区分函数和绑定方法。我们已经在这门课的开始创建了
前者,而后者在方法调用时将对象和函数组合到一起。绑定方法的值已经将第一个函数关联
到所调用的实例,当方法调用时实例会被命名为 	self	。
                                                          100
2.5	面向对象编程
通过在点运算符的返回值上调用 	type	,我们可以在交互式解释器中看到它们的差异。作为类
的属性,方法只是个函数,但是作为实例属性,它是绑定方法:
  >>>	type(Account.deposit)
  <class	'function'>
  >>>	type(tom_account.deposit)
  <class	'method'>
这两个结果的唯一不同点是,前者是个标准的二元函数,带有参数 	self	和 	amount	。后者是
一元方法,当方法被调用时,名称 	self	自动绑定到了名为 	tom_account	的对象上,而名
称 	amount	会被绑定到传递给方法的参数上。这两个值,无论函数值或绑定方法的值,都和相
同的 	deposit	函数体所关联。
我们可以以两种方式调用 	deposit	:作为函数或作为绑定方法。在前者的例子中,我们必须
为 	self	参数显式提供实参。而对于后者, 	self	参数已经自动绑定了。
  >>>	Account.deposit(tom_account,	1001)		#	The	deposit	function	requires	2	arguments
  1011
  >>>	tom_account.deposit(1000)											#	The	deposit	method	takes	1	argument
  2011
函数 	getattr	的表现就像运算符那样:它的第一个参数是对象,而第二个参数(名称)是定
义在类中的方法。之后, 	getattr	返回绑定方法的值。另一方面,如果第一个参数是个
类, 	getattr	会直接返回属性值,它仅仅是个函数。
实践指南:命名惯例。类名称通常以首字母大写来编写(也叫作驼峰拼写法,因为名称中间
的大写字母像驼峰)。方法名称遵循函数命名的惯例,使用以下划线分隔的小写字母。
有的时候,有些实例变量和方法的维护和对象的一致性相关,我们不想让用户看到或使用它
们。它们并不是由类定义的一部分抽象,而是一部分实现。Python	的惯例规定,如果属性名
称以下划线开始,它只能在方法或类中访问,而不能被类的用户访问。
2.5.4	类属性
有些属性值在特定类的所有对象之间共享。这样的属性关联到类本身,而不是类的任何独立
实例。例如,让我们假设银行以固定的利率对余额支付利息。这个利率可能会改变,但是它
是在所有账户中共享的单一值。
类属性由 	class	语句组中的赋值语句创建,位于任何方法定义之外。在更宽泛的开发者社群
中,类属性也被叫做类变量或静态变量。下面的类语句以名称 	interest	为 	Account	创建了类
属性。
                                                                                      101
2.5	面向对象编程
  >>>	class	Account(object):
  								interest	=	0.02												#	A	class	attribute
  								def	__init__(self,	account_holder):
  												self.balance	=	0
  												self.holder	=	account_holder
  								#	Additional	methods	would	be	defined	here
这个属性仍旧可以通过类的任何实例来访问。
  >>>	tom_account	=	Account('Tom')
  >>>	jim_account	=	Account('Jim')
  >>>	tom_account.interest
  0.02
  >>>	jim_account.interest
  0.02
但是,对类属性的单一赋值语句会改变所有该类实例上的属性值。
  >>>	Account.interest	=	0.04
  >>>	tom_account.interest
  0.04
  >>>	jim_account.interest
  0.04
属性名称。我们已经在我们的对象系统中引入了足够的复杂性,我们需要规定名称如何解析
为特定的属性。毕竟,我们可以轻易拥有同名的类属性和实例属性。
像我们看到的那样,点运算符由表达式、点和名称组成:
  <expression>	.	<name>
为了求解点表达式:
 1.	 求出点左边的 	<expression>	,会产生点运算符的对象。
 2.	 	<name>	会和对象的实例属性匹配;如果该名称的属性存在,会返回它的值。
 3.	 如果 	<name>	不存在于实例属性,那么会在类中查找 	<name>	,这会产生类的属性值。
 4.	 这个值会被返回,如果它是个函数,则会返回绑定方法。
在这个求值过程中,实例属性在类的属性之前查找,就像局部名称具有高于全局的优先级。
定义在类中的方法,在求值过程的第三步绑定到了点运算符的对象上。在类中查找名称的过
程有额外的差异,在我们引入类继承的时候就会出现。
赋值。所有包含点运算符的赋值语句都会作用于右边的对象。如果对象是个实例,那么赋值
就会设置实例属性。如果对象是个类,那么赋值会设置类属性。作为这条规则的结果,对对
象属性的赋值不能影响类的属性。下面的例子展示了这个区别。
如果我们向账户实例的具名属性 	interest	赋值,我们会创建属性的新实例,它和现有的类属
性具有相同名称。
                                                         102
2.5	面向对象编程
  >>>	jim_account.interest	=	0.08
这个属性值会通过点运算符返回:
  >>>	jim_account.interest
  0.08
但是,类属性 	interest	会保持为原始值,它可以通过所有其他账户返回。
  >>>	tom_account.interest
  0.04
类属性 	interest	的改动会影响 	tom_account	,但是 	jim_account	的实例属性不受影响。
  >>>	Account.interest	=	0.05		#	changing	the	class	attribute
  >>>	tom_account.interest					#	changes	instances	without	like-named	instance	attributes
  0.05
  >>>	jim_account.interest					#	but	the	existing	instance	attribute	is	unaffected
  0.08
2.5.5	继承
在使用	OOP	范式时,我们通常会发现,不同的抽象数据结构是相关的。特别是,我们发现相
似的类在特化的程度上有区别。两个类可能拥有相似的属性,但是一个表示另一个的特殊情
况。
例如,我们可能希望实现一个活期账户,它不同于标准的账户。活期账户对每笔取款都收取
额外的	$1,并且具有较低的利率。这里,我们演示上述行为:
  >>>	ch	=	CheckingAccount('Tom')
  >>>	ch.interest					#	Lower	interest	rate	for	checking	accounts
  0.01
  >>>	ch.deposit(20)		#	Deposits	are	the	same
  20
  >>>	ch.withdraw(5)		#	withdrawals	decrease	balance	by	an	extra	charge
  14
	CheckingAccount	是 	Account	的特化。在	OOP	的术语中,通用的账户会作
为 	CheckingAccount	的基类,而 	CheckingAccount	是 	Account	的子类(术语“父类”和“超类”通常
等同于“基类”,而“派生类”通常等同于“子类”)。
子类继承了基类的属性,但是可能覆盖特定属性,包括特定的方法。使用继承,我们只需要
关注基类和子类之间有什么不同。任何我们在子类未指定的东西会自动假设和基类中相同。
                                                                                       103
2.5	面向对象编程
继承也在对象隐喻中有重要作用,不仅仅是一种实用的组织方式。继承意味着在类之间表
达“is-a”关系,它和“has-a”关系相反。活期账户是(is-a)一种特殊类型的账户,所以
让 	CheckingAccount	继承 	Account	是继承的合理使用。另一方面,银行拥有(has-a)所管理
的银行账户的列表,所以二者都不应继承另一个。反之,账户对象的列表应该自然地表现为
银行账户的实例属性。
2.5.6	使用继承
我们通过将基类放置到类名称后面的圆括号内来指定继承。首先,我们提供 	Account	类的完
整实现,也包含类和方法的文档字符串。
  >>>	class	Account(object):
  								"""A	bank	account	that	has	a	non-negative	balance."""
  								interest	=	0.02
  								def	__init__(self,	account_holder):
  												self.balance	=	0
  												self.holder	=	account_holder
  								def	deposit(self,	amount):
  												"""Increase	the	account	balance	by	amount	and	return	the	new	balance."""
  												self.balance	=	self.balance	+	amount
  												return	self.balance
  								def	withdraw(self,	amount):
  												"""Decrease	the	account	balance	by	amount	and	return	the	new	balance."""
  												if	amount	>	self.balance:
  																return	'Insufficient	funds'
  												self.balance	=	self.balance	-	amount
  												return	self.balance
	CheckingAccount	的完整实现在下面:
  >>>	class	CheckingAccount(Account):
  								"""A	bank	account	that	charges	for	withdrawals."""
  								withdraw_charge	=	1
  								interest	=	0.01
  								def	withdraw(self,	amount):
  												return	Account.withdraw(self,	amount	+	self.withdraw_charge)
这里,我们引入了类属性 	withdraw_charge	,它特定于 	CheckingAccount	类。我们将一个更低
的值赋给 	interest	属性。我们也定义了新的 	withdraw	方法来覆盖定义在 	Account	对象中的
行为。类语句组中没有更多的语句,所有其它行为都从基类 	Account	中继承。
  >>>	checking	=	CheckingAccount('Sam')
  >>>	checking.deposit(10)
  10
  >>>	checking.withdraw(5)
  4
  >>>	checking.interest
  0.01
                                                                                       104
2.5	面向对象编程
	checking.deposit	表达式是用于存款的绑定方法,它定义在 	Account	类中,当	Python	解析点
表达式中的名称时,实例上并没有这个属性,它会在类中查找该名称。实际上,在类中“查找
名称”的行为会在原始对象的类的继承链中的每个基类中查找。我们可以递归定义这个过程,
为了在类中查找名称:
 1.	 如果类中有带有这个名称的属性,返回属性值。
 2.	 否则,如果有基类的话,在基类中查找该名称。
在 	deposit	中,Python	会首先在实例中查找名称,之后在 	CheckingAccount	类中。最后,它
会在 	Account	中查找,这里是 	deposit	定义的地方。根据我们对点运算符的求值规则,由
于 	deposit	是在 	checking	实例的类中查找到的函数,点运算符求值为绑定方法。这个方法以
参数 	10	调用,这会以绑定到 	checking	对象的 	self	和绑定到 	10	的 	amount	调用 	deposit	方
法。
对象的类会始终保持不变。即使 	deposit	方法在 	Account	类中找到, 	deposit	以绑定
到 	CheckingAccount	实例的 	self	调用,而不是 	Account	的实例。
   译者注: 	CheckingAccount	的实例也是 	Account	的实例,这个说法是有问题的。
调用祖先。被覆盖的属性仍然可以通过类对象来访问。例如,我们可以通过以包
含 	withdraw_charge	的参数调用 	Account	的 	withdraw	方法,来实
现 	CheckingAccount	的 	withdraw	方法。
要注意我们调用 	self.withdraw_charge	而不是等价的 	CheckingAccount.withdraw_charge	。前者
的好处就是继承自 	CheckingAccount	的类可能会覆盖支取费用。如果是这样的话,我们希望我
们的 	withdraw	实现使用新的值而不是旧的值。
2.5.7	多重继承
Python	支持子类从多个基类继承属性的概念,这是一种叫做多重继承的语言特性。
假设我们从 	Account	继承了 	SavingsAccount	,每次存钱的时候向客户收取一笔小费用。
  >>>	class	SavingsAccount(Account):
  								deposit_charge	=	2
  								def	deposit(self,	amount):
  												return	Account.deposit(self,	amount	-	self.deposit_charge)
之后,一个聪明的总经理设想了 	AsSeenOnTVAccount	,它拥
有 	CheckingAccount	和 	SavingsAccount	的最佳特性:支取和存入的费用,以及较低的利率。它
将储蓄账户和活期存款账户合二为一!“如果我们构建了它”,总经理解释道,“一些人会注册
并支付所有这些费用。甚至我们会给他们一美元。”
                                                                         105
2.5	面向对象编程
  >>>	class	AsSeenOnTVAccount(CheckingAccount,	SavingsAccount):
  								def	__init__(self,	account_holder):
  												self.holder	=	account_holder
  												self.balance	=	1											#	A	free	dollar!
实际上,这个实现就完整了。存款和取款都需要费用,使用了定义
在 	CheckingAccount	和 	SavingsAccount	中的相应函数。
  >>>	such_a_deal	=	AsSeenOnTVAccount("John")
  >>>	such_a_deal.balance
  1
  >>>	such_a_deal.deposit(20)												#	$2	fee	from	SavingsAccount.deposit
  19
  >>>	such_a_deal.withdraw(5)												#	$1	fee	from	CheckingAccount.withdraw
  13
就像预期那样,没有歧义的引用会正确解析:
  >>>	such_a_deal.deposit_charge
  2
  >>>	such_a_deal.withdraw_charge
  1
但是如果引用有歧义呢,比如 	withdraw	方法的引用,它定义
在 	Account	和 	CheckingAccount	中?下面的图展示了 	AsSeenOnTVAccount	类的继承图。每个箭
头都从子类指向基类。
对于像这样的简单“菱形”,Python	从左到右解析名称,之后向上。这个例子中,Python	按下
列顺序检查名称,直到找到了具有该名称的属性:
  AsSeenOnTVAccount,	CheckingAccount,	SavingsAccount,	Account,	object
继承顺序的问题没有正确的解法,因为我们可能会给某个派生类高于其他类的优先级。但
是,任何支持多重继承的编程语言必须始终选择同一个顺序,便于语言的用户预测程序的行
为。
                                                                                106
2.5	面向对象编程
扩展阅读。Python	使用一种叫做	C3	Method	Resolution	Ordering	的递归算法来解析名称。
任何类的方法解析顺序都使用所有类上的 	mro	方法来查询。
  >>>	[c.__name__	for	c	in	AsSeenOnTVAccount.mro()]
  ['AsSeenOnTVAccount',	'CheckingAccount',	'SavingsAccount',	'Account',	'object']
这个用于查询方法解析顺序的算法并不是这门课的主题,但是	Python	的原作者使用一篇原文
章的引用来描述它。
2.5.8	对象的作用
Python	对象系统为使数据抽象和消息传递更加便捷和灵活而设计。类、方法、继承和点运算
符的特化语法都可以让我们在程序中形成对象隐喻,它能够提升我们组织大型程序的能力。
特别是,我们希望我们的对象系统在不同层面上促进关注分离。每个程序中的对象都封装和
管理程序状态的一部分,每个类语句都定义了一些函数,它们实现了程序总体逻辑的一部
分。抽象界限强制了大型程序不同层面之间的边界。
面向对象编程适合于对系统建模,这些系统拥有相互分离并交互的部分。例如,不同用户在
社交网络中互动,不同角色在游戏中互动,以及不同图形在物理模拟中互动。在表现这种系
统的时候,程序中的对象通常自然地映射为被建模系统中的对象,类用于表现它们的类型和
关系。
另一方面,类可能不会提供用于实现特定的抽象的最佳机制。函数式抽象提供了更加自然的
隐喻,用于表现输入和输出的关系。一个人不应该强迫自己把程序中的每个细微的逻辑都塞
到类里面,尤其是当定义独立函数来操作数据变得十分自然的时候。函数也强制了关注分
离。
类似	Python	的多范式语言允许程序员为合适的问题匹配合适的范式。为了简化程序,或使程
序模块化,确定何时引入新的类,而不是新的函数,是软件工程中的重要设计技巧,这需要
仔细关注。
                                                                                  107
2.6	实现类和对象
2.6	实现类和对象
   来源:2.6	Implementing	Classes	and	Objects
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
在使用面向对象编程范式时,我们使用对象隐喻来指导程序的组织。数据表示和操作的大部
分逻辑都表达在类的定义中。在这一节中,我们会看到,类和对象本身可以使用函数和字典
来表示。以这种方式实现对象系统的目的是展示使用对象隐喻并不需要特殊的编程语言。即
使编程语言没有面向对象系统,程序照样可以面向对象。
为了实现对象,我们需要抛弃点运算符(它需要语言的内建支持),并创建分发字典,它的
行为和内建对象系统的元素差不多。我们已经看到如何通过分发字典实现消息传递行为。为
了完整实现对象系统,我们需要在实例、类和基类之间发送消息,它们全部都是含有属性的
字典。
我们不会实现整个	Python	对象系统,它包含这篇文章没有涉及到的特性(比如元类和静态方
法)。我们会专注于用户定义的类,不带有多重继承和内省行为(比如返回实例的类)。我
们的实现并不遵循	Python	类型系统的明确规定。反之,它为实现对象隐喻的核心功能而设
计。
2.6.1	实例
我们从实例开始。实例拥有具名属性,例如账户余额,它可以被设置或获取。我们使用分发
字典来实现实例,它会响应“get”和“set”属性值消息。属性本身保存在叫做 	attributes	的局部
字典中。
就像我们在这一章的前面看到的那样,字典本身是抽象数据类型。我们使用列表来实现字
典,我们使用偶对来实现列表,并且我们使用函数来实现偶对。就像我们以字典实现对象系
统那样,要注意我们能够仅仅使用函数来实现对象。
为了开始我们的实现,我们假设我们拥有一个类实现,它可以查找任何不是实例部分的名
称。我们将类作为参数 	cls	传递给 	make_instance	。
                                                     108
2.6	实现类和对象
  >>>	def	make_instance(cls):
  								"""Return	a	new	object	instance,	which	is	a	dispatch	dictionary."""
  								def	get_value(name):
  												if	name	in	attributes:
  																return	attributes[name]
  												else:
  																value	=	cls['get'](name)
  																return	bind_method(value,	instance)
  								def	set_value(name,	value):
  												attributes[name]	=	value
  								attributes	=	{}
  								instance	=	{'get':	get_value,	'set':	set_value}
  								return	instance
	instance	是分发字典,它响应消息 	get	和 	set	。 	set	消息对应	Python	对象系统的属性赋
值:所有赋值的属性都直接储存在对象的局部属性字典中。在 	get	中,如果 	name	在局
部 	attributes	字典中不存在,那么它会在类中寻找。如果 	cls	返回的 	value	为函数,它必须
绑定到实例上。
绑定方法值。 	make_instance	中的 	get_value	使用 	get	寻找类中的具名属性,之后调
用 	bind_method	。方法的绑定只在函数值上调用,并且它会通过将实例插入为第一个参数,从
函数值创建绑定方法的值。
  >>>	def	bind_method(value,	instance):
  								"""Return	a	bound	method	if	value	is	callable,	or	value	otherwise."""
  								if	callable(value):
  												def	method(*args):
  																return	value(instance,	*args)
  												return	method
  								else:
  												return	value
当方法被调用时,第一个参数 	self	通过这个定义绑定到了 	instance	的值上。
2.6.2	类
类也是对象,在	Python	对象系统和我们这里实现的系统中都是如此。为了简化,我们假设类
自己并没有类(在	Python	中,类本身也有类,几乎所有类都共享相同的类,叫做 	type	)。
类可以接受 	get	和 	set	消息,以及 	new	消息。
  >>>	def	make_class(attributes,	base_class=None):
  								"""Return	a	new	class,	which	is	a	dispatch	dictionary."""
  								def	get_value(name):
  												if	name	in	attributes:
  																return	attributes[name]
  												elif	base_class	is	not	None:
  																return	base_class['get'](name)
  								def	set_value(name,	value):
  												attributes[name]	=	value
  								def	new(*args):
  												return	init_instance(cls,	*args)
  								cls	=	{'get':	get_value,	'set':	set_value,	'new':	new}
  								return	cls
                                                                                109
2.6	实现类和对象
不像实例那样,类的 	get	函数在属性未找到的时候并不查询它的类,而是查询它
的 	base_class	。类并不需要方法绑定。
实例化。 	make_class	中的 	new	函数调用了 	init_instance	,它首先创建新的实例,之后调用
叫做 	__init__	的方法。
  >>>	def	init_instance(cls,	*args):
  								"""Return	a	new	object	with	type	cls,	initialized	with	args."""
  								instance	=	make_instance(cls)
  								init	=	cls['get']('__init__')
  								if	init:
  												init(instance,	*args)
  								return	instance
最后这个函数完成了我们的对象系统。我们现在拥有了实例,它的 	set	是局部的,但
是 	get	会回溯到它们的类中。实例在它的类中查找名称之后,它会将自己绑定到函数值上来
创建方法。最后类可以创建新的( 	new	)实例,并且在实例创建之后立即调用它们
的 	__init__	构造器。
在对象系统中,用户仅仅可以调用 	create_class	,所有其他功能通过消息传递来使用。与之
相似,Python	的对象系统由 	class	语句来调用,它的所有其他功能都通过点表达式和对类的
调用来使用。
2.6.3	使用所实现的对象
我们现在回到上一节银行账户的例子。使用我们实现的对象系统,我们就可以创
建 	Account	类, 	CheckingAccount	子类和它们的实例。
	Account	类通过 	create_account_class	函数创建,它拥有类似于	Python	 	class	语句的结构,
但是以 	make_class	的调用结尾。
  >>>	def	make_account_class():
  								"""Return	the	Account	class,	which	has	deposit	and	withdraw	methods."""
  								def	__init__(self,	account_holder):
  												self['set']('holder',	account_holder)
  												self['set']('balance',	0)
  								def	deposit(self,	amount):
  												"""Increase	the	account	balance	by	amount	and	return	the	new	balance."""
  												new_balance	=	self['get']('balance')	+	amount
  												self['set']('balance',	new_balance)
  												return	self['get']('balance')
  								def	withdraw(self,	amount):
  												"""Decrease	the	account	balance	by	amount	and	return	the	new	balance."""
  												balance	=	self['get']('balance')
  												if	amount	>	balance:
  																return	'Insufficient	funds'
  												self['set']('balance',	balance	-	amount)
  												return	self['get']('balance')
  								return	make_class({'__init__':	__init__,
  																											'deposit':		deposit,
  																											'withdraw':	withdraw,
  																											'interest':	0.02})
                                                                                       110
2.6	实现类和对象
在这个函数中,属性名称在最后设置。不像	Python	的 	class	语句,它强制内部函数和属性名
称之间的一致性。这里我们必须手动指定属性名称和值的对应关系。
	Account	类最终由赋值来实例化。
  >>>	Account	=	make_account_class()
之后,账户实例通过 	new	消息来创建,它需要名称来处理新创建的账户。
  >>>	jim_acct	=	Account['new']('Jim')
之后, 	get	消息传递给 	jim_acct	,来获取属性和方法。方法可以调用来更新账户余额。
  >>>	jim_acct['get']('holder')
  'Jim'
  >>>	jim_acct['get']('interest')
  0.02
  >>>	jim_acct['get']('deposit')(20)
  20
  >>>	jim_acct['get']('withdraw')(5)
  15
就像使用	Python	对象系统那样,设置实例的属性并不会修改类的对应属性:
  >>>	jim_acct['set']('interest',	0.04)
  >>>	Account['get']('interest')
  0.02
继承。我们可以创建 	CheckingAccount	子类,通过覆盖类属性的子集。在这里,我们修
改 	withdraw	方法来收取费用,并且降低了利率。
  >>>	def	make_checking_account_class():
  								"""Return	the	CheckingAccount	class,	which	imposes	a	$1	withdrawal	fee."""
  								def	withdraw(self,	amount):
  												return	Account['get']('withdraw')(self,	amount	+	1)
  								return	make_class({'withdraw':	withdraw,	'interest':	0.01},	Account)
在这个实现中,我们在子类的 	withdraw	中调用了基类 	Account	的 	withdraw	函数,就像在
Python	内建对象系统那样。我们可以创建子类本身和它的实例,就像之前那样:
  >>>	CheckingAccount	=	make_checking_account_class()
  >>>	jack_acct	=	CheckingAccount['new']('Jack')
它们的行为相似,构造函数也一样。每笔取款都会在特殊的 	withdraw	函数中收费	$1,并
且 	interest	也拥有新的较低值。
                                                                                     111
2.6	实现类和对象
  >>>	jack_acct['get']('interest')
  0.01
  >>>	jack_acct['get']('deposit')(20)
  20
  >>>	jack_acct['get']('withdraw')(5)
  14
我们的构建在字典上的对象系统十分类似于	Python	内建对象系统的实现。Python	中,任何
用户定义类的实例,都有个特殊的 	__dict__	属性,将对象的局部实例属性储存在字典中,就
像我们的 	attributes	字典那样。Python	的区别在于,它区分特定的特殊方法,这些方法和内
建函数交互来确保那些函数能正常处理许多不同类型的参数。操作不同类型参数的函数是下
一节的主题。
                                                   112
2.7	泛用方法
2.7	泛用方法
   来源:2.7	Generic	Operations
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
这一章中我们引入了复合数据类型,以及由构造器和选择器实现的数据抽象机制。使用消息
传递,我们就能使抽象数据类型直接拥有行为。使用对象隐喻,我们可以将数据的表示和用
于操作数据的方法绑定在一起,从而使数据驱动的程序模块化,并带有局部状态。
但是,我们仍然必须展示,我们的对象系统允许我们在大型程序中灵活组合不同类型的对
象。点运算符的消息传递仅仅是一种用于使用多个对象构建组合表达式的方式。这一节中,
我们会探索一些用于组合和操作不同类型对象的方式。
2.7.1	字符串转换
我们在这一章最开始说,对象值的行为应该类似它所表达的数据,包括产生它自己的字符串
表示。数据值的字符串表示在类似	Python	的交互式语言中尤其重要,其中“读取-求值-打
印”的循环需要每个值都拥有某种字符串表示形式。
字符串值为人们的信息交流提供了基础的媒介。字符序列可以在屏幕上渲染,打印到纸上,
大声朗读,转换为盲文,或者以莫尔兹码广播。字符串对编程而言也非常基础,因为它们可
以表示	Python	表达式。对于一个对象,我们可能希望生成一个字符串,当作为	Python	表达
式解释时,求值为等价的对象。
Python	规定,所有对象都应该能够产生两种不同的字符串表示:一种是人类可解释的文本,
另一种是	Python	可解释的表达式。字符串的构造函数 	str	返回人类可读的字符串。在可能的
情况下, 	repr	函数返回一个	Python	表达式,它可以求值为等价的对象。 	repr	的文档字符
串解释了这个特性:
  repr(object)	->	string
  Return	the	canonical	string	representation	of	the	object.
  For	most	object	types,	eval(repr(object))	==	object.
在表达式的值上调用 	repr	的结果就是	Python	在交互式会话中打印的东西。
  >>>	12e12
  12000000000000.0
  >>>	print(repr(12e12))
  12000000000000.0
                                                            113
2.7	泛用方法
在不存在任何可以求值为原始值的表达式的情况中,Python	会产生一个代理:
  >>>	repr(min)
  '<built-in	function	min>'
	str	构造器通常与 	repr	相同,但是有时会提供更加可解释的文本表示。例如,我们可以看
到 	str	和 	repr	对于日期的不同:
  >>>	from	datetime	import	date
  >>>	today	=	date(2011,	9,	12)
  >>>	repr(today)
  'datetime.date(2011,	9,	12)'
  >>>	str(today)
  '2011-09-12'
	repr	函数的定义出现了新的挑战:我们希望它对所有数据类型都正确应用,甚至是那些
在 	repr	实现时还不存在的类型。我们希望它像一个多态函数,可以作用于许多(多)不同形
式(态)的数据。
消息传递提供了这个问题的解决方案: 	repr	函数在参数上调用叫做 	__repr__	的函数。
  >>>	today.__repr__()
  'datetime.date(2011,	9,	12)'
通过在用户定义的类上实现同一方法,我们就可以将 	repr	的适用性扩展到任何我们以后创建
的类。这个例子强调了消息传递的另一个普遍的好处:就是它提供了一种机制,用于将现有
函数的职责范围扩展到新的对象。
	str	构造器以类似的方式实现:它在参数上调用了叫做 	__str__	的方法。
  >>>	today.__str__()
  '2011-09-12'
这些多态函数是一个更普遍原则的例子:特定函数应该作用于多种数据类型。这里举例的消
息传递方法仅仅是多态函数实现家族的一员。本节剩下的部分会探索一些备选方案。
2.7.2	多重表示
使用对象或函数的数据抽象是用于管理复杂性的强大工具。抽象数据类型允许我们在数据表
示和用于操作数据的函数之间构造界限。但是,在大型程序中,对于程序中的某种数据类
型,提及“底层表示”可能不总是有意义。首先,一个数据对象可能有多种实用的表示,而且我
们可能希望设计能够处理多重表示的系统。
                                                  114
2.7	泛用方法
为了选取一个简单的示例,复数可以用两种几乎等价的方式来表示:直角坐标(虚部和实
部)以及极坐标(模和角度)。有时直角坐标形式更加合适,而有时极坐标形式更加合适。
复数以两种方式表示,而操作复数的函数可以处理每种表示,这样一个系统确实比较合理。
更重要的是,大型软件系统工程通常由许多人设计,并花费大量时间,需求的主题随时间而
改变。在这样的环境中,每个人都事先同意数据表示的方案是不可能的。除了隔离使用和表
示的数据抽象的界限,我们需要隔离不同设计方案的界限,以及允许不同方案在一个程序中
共存。进一步,由于大型程序通常通过组合已存在的模块创建,这些模块会单独设计,我们
需要一种惯例,让程序员将模块递增地组合为大型系统。也就是说,不需要重复设计或实现
这些模块。
我们以最简单的复数示例开始。我们会看到,消息传递在维持“复数”对象的抽象概念时,如何
让我们为复数的表示设计出分离的直角坐标和极坐标表示。我们会通过使用泛用选择器为复
数定义算数函数( 	add_complex	, 	mul_complex	)来完成它。泛用选择器可访问复数的一部
分,独立于数值表示的方式。所产生的复数系统包含两种不同类型的抽象界限。它们隔离了
高阶操作和低阶表示。此外,也有一个垂直的界限,它使我们能够独立设计替代的表示。
作为边注,我们正在开发一个系统,它在复数上执行算数运算,作为一个简单但不现实的使
用泛用操作的例子。复数类型实际上在	Python	中已经内建了,但是这个例子中我们仍然自己
实现。
就像有理数那样,复数可以自然表示为偶对。复数集可以看做带有两个正交轴,实数轴和虚
数轴的二维空间。根据这个观点,复数 	z	=	x	+	y	*	i	(其中 	i*i	=	-1	)可以看做平面上的
点,它的实数为 	x	,虚部为 	y	。复数加法涉及到将它们的实部和虚部相加。
对复数做乘法时,将复数以极坐标表示为模和角度更加自然。两个复数的乘积是,将一个复
数按照另一个的长度作为因数拉伸,之后按照另一个的角度来旋转它的所得结果。
                                                        115
2.7	泛用方法
所以,复数有两种不同表示,它们适用于不同的操作。然而,从一些人编写使用复数的程序
的角度来看,数据抽象的原则表明,所有操作复数的运算都应该可用,无论计算机使用了哪
个表示。
接口。消息传递并不仅仅提供用于组装行为和数据的方式。它也允许不同的数据类型以不同
方式响应相同消息。来自不同对象,产生相似行为的共享消息是抽象的有力手段。
像之前看到的那样,抽象数据类型由构造器、选择器和额外的行为条件定义。与之紧密相关
的概念是接口,它是共享消息的集合,带有它们含义的规定。响应 	__repr__	和 	__str__	特殊
方法的对象都实现了通用的接口,它们可以表示为字符串。
在复数的例子中,接口需要实现由四个消息组成的算数运
算: 	real	, 	imag	, 	magnitude	和 	angle	。我们可以使用这些消息实现加法和乘法。
我们拥有两种复数的抽象数据类型,它们的构造器不同。
     	ComplexRI	从实部和虚部构造复数。
     	ComplexMA	从模和角度构造复数。
使用这些消息和构造器,我们可以实现复数算数:
  >>>	def	add_complex(z1,	z2):
  								return	ComplexRI(z1.real	+	z2.real,	z1.imag	+	z2.imag)
  >>>	def	mul_complex(z1,	z2):
  								return	ComplexMA(z1.magnitude	*	z2.magnitude,	z1.angle	+	z2.angle)
术语“抽象数据类型”(ADT)和“接口”的关系是微妙的。ADT	包含构建复杂数据类的方式,以
单元操作它们,并且可以选择它们的组件。在面向对象系统中,ADT	对应一个类,虽然我们
已经看到对象系统并不需要实现	ADT。接口是一组与含义关联的消息,并且它可能包含选择
器,也可能不包含。概念上,ADT	描述了一类东西的完整抽象表示,而接口规定了可能在许
多东西之间共享的行为。
属性(Property)。我们希望交替使用复数的两种类型,但是对于每个数值来说,储存重复
的信息比较浪费。我们希望储存实部-虚部的表示或模-角度的表示之一。
Python	拥有一个简单的特性,用于从零个参数的函数凭空计算属性
(Attribute)。 	@property	装饰器允许函数不使用标准调用表达式语法来调用。根据实部和虚
部的复数实现展示了这一点。
                                                                             116
2.7	泛用方法
  >>>	from	math	import	atan2
  >>>	class	ComplexRI(object):
  								def	__init__(self,	real,	imag):
  												self.real	=	real
  												self.imag	=	imag
  								@property
  								def	magnitude(self):
  												return	(self.real	**	2	+	self.imag	**	2)	**	0.5
  								@property
  								def	angle(self):
  												return	atan2(self.imag,	self.real)
  								def	__repr__(self):
  												return	'ComplexRI({0},	{1})'.format(self.real,	self.imag)
第二种使用模和角度的实现提供了相同接口,因为它响应同一组消息。
  >>>	from	math	import	sin,	cos
  >>>	class	ComplexMA(object):
  								def	__init__(self,	magnitude,	angle):
  												self.magnitude	=	magnitude
  												self.angle	=	angle
  								@property
  								def	real(self):
  												return	self.magnitude	*	cos(self.angle)
  								@property
  								def	imag(self):
  												return	self.magnitude	*	sin(self.angle)
  								def	__repr__(self):
  												return	'ComplexMA({0},	{1})'.format(self.magnitude,	self.angle)
实际上,我们的 	add_complex	和 	mul_complex	实现并没有完成;每个复数类可以用于任何算数
函数的任何参数。对象系统不以任何方式显式连接(例如通过继承)这两种复数类型,这需
要给个注解。我们已经通过在两个类之间共享一组通用的消息和接口,实现了复数抽象。
  >>>	from	math	import	pi
  >>>	add_complex(ComplexRI(1,	2),	ComplexMA(2,	pi/2))
  ComplexRI(1.0000000000000002,	4.0)
  >>>	mul_complex(ComplexRI(0,	1),	ComplexRI(0,	1))
  ComplexMA(1.0,	3.141592653589793)
编码多种表示的接口拥有良好的特性。用于每个表示的类可以独立开发;它们只需要遵循它
们所共享的属性名称。这个接口同时是递增的。如果另一个程序员希望向相同程序添加第三
个复数表示,它们只需要使用相同属性创建另一个类。
特殊方法。内建的算数运算符可以以一种和 	repr	相同的方式扩展;它们是特殊的方法名称,
对应	Python	的算数、逻辑和序列运算的运算符。
为了使我们的代码更加易读,我们可能希望在执行复数加法和乘法时直接使用 	+	和 	*	运算
符。将下列方法添加到两个复数类中,这会让这些运算符,以及 	opertor	模块中
的 	add	和 	mul	函数可用。
                                                                              117
2.7	泛用方法
  >>>	ComplexRI.__add__	=	lambda	self,	other:	add_complex(self,	other)
  >>>	ComplexMA.__add__	=	lambda	self,	other:	add_complex(self,	other)
  >>>	ComplexRI.__mul__	=	lambda	self,	other:	mul_complex(self,	other)
  >>>	ComplexMA.__mul__	=	lambda	self,	other:	mul_complex(self,	other)
现在,我们可以对我们的自定义类使用中缀符号。
  >>>	ComplexRI(1,	2)	+	ComplexMA(2,	0)
  ComplexRI(3.0,	2.0)
  >>>	ComplexRI(0,	1)	*	ComplexRI(0,	1)
  ComplexMA(1.0,	3.141592653589793)
扩展阅读。为了求解含有 	+	运算符的表达式,Python	会检查表达式的左操作数和右操作数上
的特殊方法。首先,Python	会检查左操作数的 	__add__	方法,之后检查右操作数
的 	__radd__	方法。如果二者之一被发现,这个方法会以另一个操作数的值作为参数调用。
在	Python	中求解含有任何类型的运算符的表达值具有相似的协议,这包括切片符号和布尔运
算符。Python	文档列出了完整的运算符的方法名称。Dive	into	Python	3	的特殊方法名称一章
描述了许多用于	Python	解释器的细节。
2.7.3	泛用函数
我们的复数实现创建了两种数据类型,它们对于 	add_complex	和 	mul_complex	函数能够互相转
换。现在我们要看看如何使用相同的概念,不仅仅定义不同表示上的泛用操作,也能用来定
义不同种类、并且不共享通用结构的参数上的泛用操作。
我们到目前为止已定义的操作将不同的数据类型独立对待。所以,存在用于加法的独立的
包,比如两个有理数或者两个复数。我们没有考虑到的是,定义类型界限之间的操作很有意
义,比如将复数与有理数相加。我们经历了巨大的痛苦,引入了程序中各个部分的界限,便
于让它们可被独立开发和理解。
我们希望以某种精确控制的方式引入跨类型的操作。便于在不严重违反抽象界限的情况下支
持它们。在我们希望的结果之间可能有些矛盾:我们希望能够将有理数与复数相加,也希望
能够使用泛用的 	add	函数,正确处理所有数值类型。同时,我们希望隔离复数和有理数的细
节,来维持程序的模块化。
让我们使用	Python	内建的对象系统重新编写有理数的实现。像之前一样,我们在较低层级将
有理数储存为分子和分母。
  >>>	from	fractions	import	gcd
  >>>	class	Rational(object):
  								def	__init__(self,	numer,	denom):
  												g	=	gcd(numer,	denom)
  												self.numer	=	numer	//	g
  												self.denom	=	denom	//	g
  								def	__repr__(self):
  												return	'Rational({0},	{1})'.format(self.numer,	self.denom)
                                                                         118
2.7	泛用方法
这个新的实现中的有理数的加法和乘法和之前类似。
  >>>	def	add_rational(x,	y):
  								nx,	dx	=	x.numer,	x.denom
  								ny,	dy	=	y.numer,	y.denom
  								return	Rational(nx	*	dy	+	ny	*	dx,	dx	*	dy)
  >>>	def	mul_rational(x,	y):
  								return	Rational(x.numer	*	y.numer,	x.denom	*	y.denom)
类型分发。一种处理跨类型操作的方式是为每种可能的类型组合设计不同的函数,操作可用
于这种类型。例如,我们可以扩展我们的复数实现,使其提供函数用于将复数与有理数相
加。我们可以使用叫做类型分发的机制更通用地提供这个功能。
类型分发的概念是,编写一个函数,首先检测接受到的参数类型,之后执行适用于这种类型
的代码。Python	中,对象类型可以使用内建的 	type	函数来检测。
  >>>	def	iscomplex(z):
  								return	type(z)	in	(ComplexRI,	ComplexMA)
  >>>	def	isrational(z):
  								return	type(z)	==	Rational
这里,我们依赖一个事实,每个对象都知道自己的类型,并且我们可以使用Python
的 	type	函数来获取类型。即使 	type	函数不可用,我们也能根
据 	Rational	, 	ComplexRI	和 	ComplexMA	来实现 	iscomplex	和 	isrational	。
现在考虑下面的 	add	实现,它显式检查了两个参数的类型。我们不会在这个例子中显式使用
Python	的特殊方法(例如 	__add__	)。
  >>>	def	add_complex_and_rational(z,	r):
  												return	ComplexRI(z.real	+	r.numer/r.denom,	z.imag)
  >>>	def	add(z1,	z2):
  								"""Add	z1	and	z2,	which	may	be	complex	or	rational."""
  								if	iscomplex(z1)	and	iscomplex(z2):
  												return	add_complex(z1,	z2)
  								elif	iscomplex(z1)	and	isrational(z2):
  												return	add_complex_and_rational(z1,	z2)
  								elif	isrational(z1)	and	iscomplex(z2):
  												return	add_complex_and_rational(z2,	z1)
  								else:
  												return	add_rational(z1,	z2)
这个简单的类型分发方式并不是递增的,它使用了大量的条件语句。如果另一个数值类型包
含在程序中,我们需要使用新的语句重新实现 	add	。
我们可以创建更灵活的 	add	实现,通过以字典实现类型分发。要想扩展 	add	的灵活性,第一
步是为我们的类创建一个 	tag	集合,抽离两个复数集合的实现。
  >>>	def	type_tag(x):
  								return	type_tag.tags[type(x)]
  >>>	type_tag.tags	=	{ComplexRI:	'com',	ComplexMA:	'com',	Rational:	'rat'}
                                                                            119
2.7	泛用方法
下面,我们使用这些类型标签来索引字典,字典中储存了数值加法的不同方式。字典的键是
类型标签的元素,值是类型特定的加法函数。
  >>>	def	add(z1,	z2):
  								types	=	(type_tag(z1),	type_tag(z2))
  								return	add.implementations[types](z1,	z2)
这个基于字典的分发方式是递增的,因为 	add.implementations	和 	type_tag.tags	总是可以扩
展。任何新的数值类型可以将自己“安装”到现存的系统中,通过向这些字典添加新的条目。
当我们向系统引入一些复杂性时,我们现在拥有了泛用、可扩展的 	add	函数,可以处理混合
类型。
  >>>	add(ComplexRI(1.5,	0),	Rational(3,	2))
  ComplexRI(3.0,	0)
  >>>	add(Rational(5,	3),	Rational(1,	2))
  Rational(13,	6)
数据导向编程。我们基于字典的 	add	实现并不是特定于加法的;它不包含任何加法的直接逻
辑。它只实现了加法操作,因为我们碰巧将 	implementations	字典和函数放到一起来执行加
法。
更通用的泛用算数操作版本会将任意运算符作用于任意类型,并且使用字典来储存多种组合
的实现。这个完全泛用的实现方法的方式叫做数据导向编程。在我们这里,我们可以实现泛
用加法和乘法,而不带任何重复的逻辑。
  >>>	def	apply(operator_name,	x,	y):
  								tags	=	(type_tag(x),	type_tag(y))
  								key	=	(operator_name,	tags)
  								return	apply.implementations[key](x,	y)
在泛用的 	apply	函数中,键由操作数的名称(例如 	add	),和参数类型标签的元组构造。我
们下面添加了对复数和有理数的乘法支持。
  >>>	def	mul_complex_and_rational(z,	r):
  								return	ComplexMA(z.magnitude	*	r.numer	/	r.denom,	z.angle)
  >>>	mul_rational_and_complex	=	lambda	r,	z:	mul_complex_and_rational(z,	r)
  >>>	apply.implementations	=	{('mul',	('com',	'com')):	mul_complex,
  																													('mul',	('com',	'rat')):	mul_complex_and_rational,
  																													('mul',	('rat',	'com')):	mul_rational_and_complex,
  																													('mul',	('rat',	'rat')):	mul_rational}
我们也可以使用字典的 	update	方法,从 	add	中将加法实现添加到 	apply	。
  >>>	adders	=	add.implementations.items()
  >>>	apply.implementations.update({('add',	tags):fn	for	(tags,	fn)	in	adders})
                                                                                  120
2.7	泛用方法
既然已经在单一的表中支持了	8	种不同的实现,我们可以用它来更通用地操作有理数和复
数。
  >>>	apply('add',	ComplexRI(1.5,	0),	Rational(3,	2))
  ComplexRI(3.0,	0)
  >>>	apply('mul',	Rational(1,	2),	ComplexMA(10,	1))
  ComplexMA(5.0,	1)
这个数据导向的方式管理了跨类型运算符的复杂性,但是十分麻烦。使用这个一个系统,引
入新类型的开销不仅仅是为类型编写方法,还有实现跨类型操作的函数的构造和安装。这个
负担比起定义类型本身的操作需要更多代码。
当类型分发机制和数据导向编程的确能创造泛用函数的递增实现时,它们就不能有效隔离实
现的细节。独立数值类型的实现者需要在编程跨类型操作时考虑其他类型。组合有理数和复
数严格上并不是每种类型的范围。在类型中制定一致的责任分工政策,在带有多种类型和跨
类型操作的系统设计中是大势所趋。
强制转换。在完全不相关的类型执行完全不相关的操作的一般情况中,实现显式的跨类型操
作,尽管可能非常麻烦,是人们所希望的最佳方案。幸运的是,我们有时可以通过利用类型
系统中隐藏的额外结构来做得更好。不同的数据类通常并不是完全独立的,可能有一些方
式,一个类型的对象通过它会被看做另一种类型的对象。这个过程叫做强制转换。例如,如
果我们被要求将一个有理数和一个复数通过算数来组合,我们可以将有理数看做虚部为零的
复数。通过这样做,我们将问题转换为两个复数组合的问题,这可以通
过 	add_complex	和 	mul_complex	由经典的方法处理。
通常,我们可以通过设计强制转换函数来实现这个想法。强制转换函数将一个类型的对象转
换为另一个类型的等价对象。这里是一个典型的强制转换函数,它将有理数转换为虚部为零
的复数。
  >>>	def	rational_to_complex(x):
  								return	ComplexRI(x.numer/x.denom,	0)
现在,我们可以定义强制转换函数的字典。这个字典可以在更多的数值类型引入时扩展。
  >>>	coercions	=	{('rat',	'com'):	rational_to_complex}
任意类型的数据对象不可能转换为每个其它类型的对象。例如,没有办法将任意的复数强制
转换为有理数,所以在 	coercions	字典中应该没有这种转换的实现。
使用 	coercions	字典,我们可以编写叫做 	coerce_apply	的函数,它试图将参数强制转换为相
同类型的值,之后仅仅调用运算符。 	coerce_apply	的实现字典不包含任何跨类型运算符的实
现。
                                                        121
2.7	泛用方法
  >>>	def	coerce_apply(operator_name,	x,	y):
  								tx,	ty	=	type_tag(x),	type_tag(y)
  								if	tx	!=	ty:
  												if	(tx,	ty)	in	coercions:
  																tx,	x	=	ty,	coercions[(tx,	ty)](x)
  												elif	(ty,	tx)	in	coercions:
  																ty,	y	=	tx,	coercions[(ty,	tx)](y)
  												else:
  																return	'No	coercion	possible.'
  								key	=	(operator_name,	tx)
  								return	coerce_apply.implementations[key](x,	y)
	coerce_apply	的 	implementations	仅仅需要一个类型标签,因为它们假设两个值都共享相同的
类型标签。所以,我们仅仅需要四个实现来支持复数和有理数上的泛用算数。
  >>>	coerce_apply.implementations	=	{('mul',	'com'):	mul_complex,
  																																				('mul',	'rat'):	mul_rational,
  																																				('add',	'com'):	add_complex,
  																																				('add',	'rat'):	add_rational}
就地使用这些实现, 	coerce_apply	可以代替 	apply	。
  >>>	coerce_apply('add',	ComplexRI(1.5,	0),	Rational(3,	2))
  ComplexRI(3.0,	0)
  >>>	coerce_apply('mul',	Rational(1,	2),	ComplexMA(10,	1))
  ComplexMA(5.0,	1.0)
这个强制转换的模式比起显式定义跨类型运算符的方式具有优势。虽然我们仍然需要编程强
制转换函数来关联类型,我们仅仅需要为每对类型编写一个函数,而不是为每个类型组合和
每个泛用方法编写不同的函数。我们所期望的是,类型间的合理转换仅仅依赖于类型本身,
而不是要调用的特定操作。
强制转换的扩展会带来进一步的优势。一些更复杂的强制转换模式并不仅仅试图将一个类型
强制转换为另一个,而是将两个不同类型强制转换为第三个。想一想菱形和长方形:每个都
不是另一个的特例,但是两个都可以看做平行四边形。另一个强制转换的扩展是迭代的强制
转换,其中一个数据类型通过媒介类型被强制转换为另一种。一个整数可以转换为一个实
数,通过首先转换为有理数,接着将有理数转换为实数。这种方式的链式强制转换降低了程
序所需的转换函数总数。
虽然它具有优势,强制转换也有潜在的缺陷。例如,强制转换函数在调用时会丢失信息。在
我们的例子中,有理数是精确表示,但是当它们转换为复数时会变得近似。
一些编程语言拥有内建的强制转换函数。实际上,Python	的早期版本拥有对象上
的 	__coerce__	特殊方法。最后,内建强制转换系统的复杂性并不能支持它的使用,所以被移
除了。反之,特定的操作按需强制转换它们的参数。运算符被实现为用户定义类上的特殊方
法,比如 	__add__	和 	__mul__	。这完全取决于你,取决于用户来决定是否使用类型分发,数
据导向编程,消息传递,或者强制转换来在你的程序中实现泛用函数。
                                                                    122
2.7	泛用方法
         123
第三章	计算机程序的构造和解释
第三章	计算机程序的构造和解释
                124
3.1	引言
3.1	引言
   来源:3.1	Introduction
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
第一章和第二章描述了编程的两个基本元素:数据和函数之间的紧密联系。我们看到了高阶
函数如何将函数当做数据操作。我们也看到了数据可以使用消息传递和对象系统绑定行为。
我们已经学到了组织大型程序的技巧,例如函数抽象,数据抽象,类的继承,以及泛用函
数。这些核心概念构成了坚实的基础,来构建模块化,可维护和可扩展的程序。
这一章专注于编程的第三个基本元素:程序自身。Python	程序只是文本的集合。只有通过解
释过程,我们才可以基于文本执行任何有意义的计算。类似	Python	的编程语言很实用,因为
我们可以定义解释器,它是一个执行	Python	求值和执行过程的程序。把它看做编程中最基本
的概念并不夸张。解释器只是另一个程序,它确定编程语言中表达式的意义。
接受这一概念,需要改变我们自己作为程序员的印象。我们需要将自己看做语言的设计者,
而不只是由他人设计的语言用户。
3.1.1	编程语言
实际上,我们可以将许多程序看做一些语言的解释器。例如,上一章的约束传播器拥有自己
的原语和组合方式。约束语言是十分专用的:它提供了一种声明式的方式来描述数学关系的
特定种类,而不是一种用于描述计算的完全通用的语言。虽然我们已经设计了某种语言,这
章的材料会极大扩展我们可解释的语言范围。
编程语言在语法结构、特性和应用领域上差别很大。在通用编程语言中,函数定义和函数调
用的结构无处不在。另一方法,存在不包含对象系统、高阶函数或类似 	while	和 	for	语句的
控制结构的强大的编程语言。为了展示语言可以有多么不同,我们会引入Logo作为强大并且
具有表现力的编程语言的例子,它包含非常少的高级特性。
这一章中,我们会学习解释器的设计,以及在执行程序时,它们所创建的计算过程。为通用
语言设计解释器的想法可能令人畏惧。毕竟,解释器是执行任何可能计算的程序,取决于它
们的输入。但是,典型的解释器拥有简洁的通用结构:两个可变的递归函数,第一个求解环
境中的表达式,第二个在参数上调用函数。
这些函数都是递归的,因为它们互相定义:调用函数需要求出函数体的表达式,而求出表达
式可能涉及到调用一个或多个函数。这一章接下来的两节专注于递归函数和数据结构,它们
是理解解释器设计的基础。这一章的结尾专注于两个新的编程语言,以及为其实现解释器的
任务。
                                                125
3.1	引言
       126
3.2	函数和所生成的过程
3.2	函数和所生成的过程
   来源:3.2	Functions	and	the	Processes	They	Generate
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
函数是计算过程的局部演化模式。它规定了过程的每个阶段如何构建在之前的阶段之上。我
们希望能够创建有关过程整体行为的语句,而过程的局部演化由一个或多个函数指定。这种
分析通常非常困难,但是我们至少可以试图描述一些典型的过程演化模式。
在这一章中,我们会检测一些用于简单函数所生成过程的通用“模型”。我们也会研究这些过程
消耗重要的计算资源,例如时间和空间的比例。
3.2.1	递归函数
如果函数的函数体直接或者间接自己调用自己,那么这个函数是递归的。也就是说,递归函
数的执行过程可能需要再次调用这个函数。Python	中的递归函数不需要任何特殊的语法,但
是它们的确需要一些注意来正确定义。
作为递归函数的介绍,我们以将英文单词转换为它的	Pig	Latin	等价形式开始。Pig	Latin	是一
种隐语:对英文单词使用一种简单、确定的转换来掩盖单词的含义。Thomas	Jefferson	据推
测是先行者。英文单词的	Pig	Latin	等价形式将辅音前缀(可能为空)从开头移动到末尾,并
且添加 	-ay	元音。所以, 	pun	会变成 	unpay	, 	stout	会变成 	outstay	, 	all	会变
成 	allay	。
  >>>	def	pig_latin(w):
  								"""Return	the	Pig	Latin	equivalent	of	English	word	w."""
  								if	starts_with_a_vowel(w):
  												return	w	+	'ay'
  								return	pig_latin(w[1:]	+	w[0])
  >>>	def	starts_with_a_vowel(w):
  								"""Return	whether	w	begins	with	a	vowel."""
  								return	w[0].lower()	in	'aeiou'
这个定义背后的想法是,一个以辅音开头的字符串的	Pig	Latin	变体和另一个字符串的	Pig
Latin	变体相同:它通过将第一个字母移到末尾来创建。于是, 	sending	的	Pig	Latin	变体就
和 	endings	的变体( 	endingsay	)相同。 	smother	的	Pig	Latin	变体和 	mothers	的变体
( 	othersmay	)相同。而且,将辅音从开头移动到末尾会产生带有更少辅音前缀的更简单的
问题。在 	sending	的例子中,将 	s	移动到末尾会产生以元音开头的单词,我们的任务就完成
了。
即使 	pig_latin	函数在它的函数体中调用, 	pig_latin	的定义是完整且正确的。
                                                                      127
3.2	函数和所生成的过程
  >>>	pig_latin('pun')
  'unpay'
能够基于函数自身来定义函数的想法可能十分令人混乱:“循环”定义如何有意义,这看起来不
是很清楚,更不用说让计算机来执行定义好的过程。但是,我们能够准确理解递归函数如何
使用我们的计算环境模型来成功调用。环境的图示和描述 	pig_latin('pun')	求值的表达式树
展示在下面:
Python	求值过程的步骤产生如下结果:
 1.	 	pig_latin	的 	def	语句	被执行,其中:
        i.	 使用函数体创建新的 	pig_latin	函数对象,并且
       ii.	 将名称 	pig_latin	在当前(全局)帧中绑定到这个函数上。
 2.	 	starts_with_a_vowel	的 	def	语句类似地执行。
 3.	 求出 	pig_latin('pun')	的调用表达式,通过
        i.	 求出运算符和操作数子表达式,通过
              i.	 查找绑定到 	pig_latin	函数的 	pig_latin	名称
             ii.	 对字符串对象 	'pun'	求出操作数字符串字面值
       ii.	 在参数 	'pun'	上调用 	pig_latin	函数,通过
              i.	 添加扩展自全局帧的局部帧
             ii.	 将形参 	w	绑定到当前帧的实参 	'pun'	上。
            iii.	 在以当前帧起始的环境中执行 	pig_latin	的函数体
                                                     128
3.2	函数和所生成的过程
                i.	 最开始的条件语句没有效果,因为头部表达式求值为 	False	
               ii.	 求出最后的返回表达式 	pig_latin(w[1:]	+	w[0])	,通过
                      i.	 查找绑定到 	pig_latin	函数的 	pig_latin	名称
                     ii.	 对字符串对象 	'pun'	求出操作数表达式
                    iii.	 在参数 	'unp'	上调用 	pig_latin	,它会从 	pig_latin	函数体中的条件
                          语句组返回预期结果。
就像这个例子所展示的那样,虽然递归函数具有循环特征,他仍旧正确调用。 	pig_latin	函
数调用了两次,但是每次都带有不同的参数。虽然第二个调用来自 	pig_latin	自己的函数
体,但由名称查找函数会成功,因为名称 	pig_latin	在它的函数体执行前的环境中绑定。
这个例子也展示了	Python	的递归函数的求值过程如何与递归函数交互,来产生带有许多嵌套
步骤的复杂计算过程,即使函数定义本身可能包含非常少的代码行数。
3.2.2	剖析递归函数
许多递归函数的函数体中都存在通用模式。函数体以基本条件开始,它是一个条件语句,为
需要处理的最简单的输入定义函数行为。在 	pig_latin	的例子中,基本条件对任何以元音开
头的单词成立。这个时候,只需要返回末尾附加 	ay	的参数。一些递归函数会有多重基本条
件。
基本条件之后是一个或多个递归调用。递归调用有特定的特征:它们必须简化原始问题。
在 	pig_latin	的例子中, 	w	中最开始辅音越多,就需要越多的处理工作。在递归调
用 	pig_latin(w[1:]	+	w[0])	中,我们在一个具有更少初始辅音的单词上调用 	pig_latin		--	这
就是更简化的问题。每个成功的 	pig_latin	调用都会更加简化,直到满足了基本条件:一个
没有初始辅音的单词。
递归调用通过逐步简化问题来表达计算。与我们在过去使用过的迭代方式相比,它们通常以
不同方式来解决问题。考虑用于计算 	n	的阶乘的函数 	fact	,其中 	fact(4)	计算
了 	4!	=	4·3·2·1	=	24	。
使用 	while	语句的自然实现会通过将每个截至 	n	的正数相乘来求出结果。
  >>>	def	fact_iter(n):
  								total,	k	=	1,	1
  								while	k	<=	n:
  												total,	k	=	total	*	k,	k	+	1
  								return	total
  >>>	fact_iter(4)
  24
另一方面,阶乘的递归实现可以以 	fact(n-1)	(一个更简单的问题)来表示 	fact(n)	。递归
的基本条件是问题的最简形式: 	fact(1)	是 	1	。
                                                                          129
3.2	函数和所生成的过程
  >>>	def	fact(n):
  								if	n	==	1:
  												return	1
  								return	n	*	fact(n-1)
  >>>	fact(4)
  24
函数的正确性可以轻易通过阶乘函数的标准数学定义来验证。
  (n	−	1)!	=	(n	−	1)·(n	−	2)·	...	·	1
  n!	=	n·(n	−	1)·(n	−	2)·	...	·	1
  n!	=	n·(n	−	1)!
这两个阶乘函数在概念上不同。迭代的函数通过将每个式子,从基本条件 	1	到最终的总数逐
步相乘来构造结果。另一方面,递归函数直接从最终的式子 	n	和简化的问题 	fact(n-1)	构造
结果。
将 	fact	函数应用于更简单的问题实例,来展开递归的同时,结果最终由基本条件构建。下面
的图示展示了递归如何向 	fact	传入 	1	而终止,以及每个调用的结果如何依赖于下一个调
用,直到满足了基本条件。
                                                 130
3.2	函数和所生成的过程
虽然我们可以使用我们的计算模型展开递归,通常把递归调用看做函数抽象更清晰一些。也
就是说,我们不应该关心 	fact(n-1)	如何在 	fact	的函数体中实现;我们只需要相信它计算
了 	n-1	的阶乘。将递归调用看做函数抽象叫做递归的“信仰飞跃”(leap	of	faith)。我们以函
数自身来定义函数,但是仅仅相信更简单的情况在验证函数正确性时会正常工作。这个例子
中我们相信, 	fact(n-1)	会正确计算 	(n-1)!	;我们只需要检查,如果满足假设 	n!	是否正确
计算。这样,递归函数正确性的验证就变成了一种归纳证明。
函数 	fact_iter	和 	fact	也不一样,因为前者必须引入两个额外的名称, 	total	和 	k	,它们
在递归实现中并不需要。通常,迭代函数必须维护一些局部状态,它们会在计算过程中改
变。在任何迭代的时间点上,状态刻画了已完成的结果,以及未完成的工作总量。例如,
当 	k	为 	3	且 	total	为 	2	时,就还剩下两个式子没有处理, 	3	和 	4	。另一方面, 	fact	由单
一参数 	n	来刻画。计算的状态完全包含在表达式树的结果中,它的返回值起到 	total	的作
用,并且在不同的帧中将 	n	绑定到不同的值上,而不是显式跟踪 	k	。
递归函数可以更加依赖于解释器本身,通过将计算状态储存为表达式树和环境的一部分,而
不是显式使用局部帧中的名称。出于这个原因,递归函数通常易于定义,因为我们不需要试
着弄清必须在迭代中维护的局部状态。另一方面,学会弄清由递归函数实现的计算过程,需
要一些练习。
3.2.3	树形递归
另一个递归的普遍模式叫做树形递归。例如,考虑斐波那契序列的计算,其中每个数值都是
前两个的和。
  >>>	def	fib(n):
  								if	n	==	1:
  												return	0
  								if	n	==	2:
  												return	1
  								return	fib(n-2)	+	fib(n-1)
  >>>	fib(6)
  5
这个递归定义和我们之前的尝试有很大关系:它准确反映了斐波那契数的相似定义。考虑求
出 	fib(6)	所产生的计算模式,它展示在下面。为了计算 	fib(6)	,我们需要计
算 	fib(5)	和 	fib(4)	。为了计算 	fib(5)	,我们需要计算 	fib(4)	和 	fib(3)	。通常,这个演
化过程看起来像一棵树(下面的图并不是完整的表达式树,而是简化的过程描述;一个完整
的表达式树也拥有同样的结构)。在遍历这棵树的过程中,每个蓝点都表示斐波那契数的已
完成计算。
                                                                   131
3.2	函数和所生成的过程
调用自身多次的函数叫做树形递归。以树形递归为原型编写的函数十分有用,但是用于计算
斐波那契数则非常糟糕,因为它做了很多重复的计算。要注意整个 	fib(4)	的计算是重复的,
它几乎是一半的工作量。实际上,不难得出函数用于计算 	fib(1)	和 	fib(2)	(通常是树中的
叶子数量)的时间是 	fib(n+1)	。为了弄清楚这有多糟糕,我们可以证明 	fib(n)	的值随
着 	n	以指数方式增长。所以,这个过程的步骤数量随输入以指数方式增长。
我们已经见过斐波那契数的迭代实现,出于便利在这里贴出来:
  >>>	def	fib_iter(n):
  								prev,	curr	=	1,	0		#	curr	is	the	first	Fibonacci	number.
  								for	_	in	range(n-1):
  													prev,	curr	=	curr,	prev	+	curr
  								return	curr
这里我们必须维护的状态由当前值和上一个斐波那契数组成。 	for	语句也显式跟踪了迭代数
量。这个定义并没有像递归方式那样清晰反映斐波那契数的数学定义。但是,迭代实现中所
需的计算总数只是线性,而不是指数于 	n	的。甚至对于 	n	的较小值,这个差异都非常大。
然而我们不应该从这个差异总结出,树形递归的过程是没有用的。当我们考虑层次数据结
构,而不是数值上的操作时,我们发现树形递归是自然而强大的工具。而且,树形过程可以
变得更高效。
记忆。用于提升重复计算的递归函数效率的机制叫做记忆。记忆函数会为任何之前接受的参
数储存返回值。 	fib(4)	的第二次调用不会执行与第一次同样的复杂过程,而是直接返回第一
次调用的已储存结果。
记忆函数可以自然表达为高阶函数,也可以用作装饰器。下面的定义为之前的已计算结果创
建缓存,由被计算的参数索引。在这个实现中,这个字典的使用需要记忆函数的参数是不可
变的。
                                                                   132
3.2	函数和所生成的过程
  >>>	def	memo(f):
  								"""Return	a	memoized	version	of	single-argument	function	f."""
  								cache	=	{}
  								def	memoized(n):
  												if	n	not	in	cache:
  																cache[n]	=	f(n)
  												return	cache[n]
  								return	memoized
  >>>	fib	=	memo(fib)
  >>>	fib(40)
  63245986
由记忆函数节省的所需的计算时间总数在这个例子中是巨大的。被记忆的递归函数 	fib	和迭
代函数 	fib_iter	都只需要线性于输入 	n	的时间总数。为了计算 	fib(40)	, 	fib	的函数体只
执行	40	次,而不是无记忆递归中的	102,334,155	次。
空间。为了理解函数所需的空间,我们必须在我们的计算模型中规定内存如何使用,保留和
回收。在求解表达式过程中,我们必须保留所有活动环境和所有这些环境引用的值和帧。如
果环境为表达式树当前分支中的一些表达式提供求值上下文,那么它就是活动环境。
例如,当求值 	fib	时,解释器按序计算之前的每个值,遍历树形结构。为了这样做,它只需
要在计算的任何时间点,跟踪树中在当前节点之前的那些节点。用于求出剩余节点的内存可
以被回收,因为它不会影响未来的计算。通常,树形递归所需空间与树的深度成正比。
下面的图示描述了由求解 	fib(3)	生成的表达式树。在求解 	fib	最初调用的返回表达式的过程
中, 	fib(n-2)	被求值,产生值 	0	。一旦这个值计算出来,对应的环境帧(标为灰色)就不再
需要了:它并不是活动环境的一部分。所以,一个设计良好的解释器会回收用于储存这个帧
的内存。另一方面,如果解释器当前正在求解 	fib(n-1)	,那么由这次 	fib	调用(其
中 	n	为 	2	)创建的环境是活动的。与之对应,最开始在 	3	上调用 	fib	所创建的环境也是活
动的,因为这个值还没有成功计算出来。
                                                                         133
3.2	函数和所生成的过程
在 	memo	的例子中,只要一些名称绑定到了活动环境中的某个函数上,关联到所返回函数(它
包含 	cache	)的环境必须保留。 	cache	字典中的条目数量随传递给 	fib	的唯一参数数量线性
增长,它的规模线性于输入。另一方面,迭代实现只需要两个数值来在计算过程中跟
踪: 	prev	和 	curr	,所以是常数大小。
我们使用记忆函数的例子展示了编程中的通用模式,即通常可以通过增加所用空间来减少计
算时间,反之亦然。
3.2.4	示例:找零
考虑下面这个问题:如果给你半美元、四分之一美元、十美分、五美分和一美分,一美元有
多少种找零的方式?更通常来说,我们能不能编写一个函数,使用一系列货币的面额,计算
有多少种方式为给定的金额总数找零?
这个问题可以用递归函数简单解决。假设我们认为可用的硬币类型以某种顺序排列,假设从
大到小排列。
使用 	n	种硬币找零的方式为:
 1.	 使用所有除了第一种之外的硬币为 	a	找零的方式,以及
 2.	 使用 	n	种硬币为更小的金额 	a	-	d	找零的方式,其中 	d	是第一种硬币的面额。
                                                     134
3.2	函数和所生成的过程
为了弄清楚为什么这是正确的,可以看出,找零方式可以分为两组,不使用第一种硬币的方
式,和使用它们的方式。所以,找零方式的总数等于不使用第一种硬币为该金额找零的方式
数量,加上使用第一种硬币至少一次的方式数量。而后者的数量等于在使用第一种硬币之
后,为剩余的金额找零的方式数量。
因此,我们可以递归将给定金额的找零问题,归约为使用更少种类的硬币为更小的金额找零
的问题。仔细考虑这个归约原则,并且说服自己,如果我们规定了下列基本条件,我们就可
以使用它来描述算法:
 1.	 如果 	a	正好是零,那么有一种找零方式。
 2.	 如果 	a	小于零,那么有零种找零方式。
 3.	 如果 	n	小于零,那么有零种找零方式。
我们可以轻易将这个描述翻译成递归函数:
  >>>	def	count_change(a,	kinds=(50,	25,	10,	5,	1)):
  								"""Return	the	number	of	ways	to	change	amount	a	using	coin	kinds."""
  								if	a	==	0:
  												return	1
  								if	a	<	0	or	len(kinds)	==	0:
  												return	0
  								d	=	kinds[0]
  								return	count_change(a,	kinds[1:])	+	count_change(a	-	d,	kinds)
  >>>	count_change(100)
  292
	count_change	函数生成树形递归过程,和 	fib	的首个实现一样,它是重复的。它会花费很长
时间来计算出 	292	,除非我们记忆这个函数。另一方面,设计迭代算法来计算出结果的方式
并不是那么明显,我们将它留做一个挑战。
3.2.5	增长度
前面的例子表明,不同过程在花费的时间和空间计算资源上有显著差异。我们用于描述这个
差异的便捷方式,就是使用增长度的概念,来获得当输入变得更大时,过程所需资源的大致
度量。
令 	n	为度量问题规模的参数, 	R(n)	为处理规模为 	n	的问题的过程所需的资源总数。在我们
前面的例子中,我们将 	n	看做给定函数所要计算出的数值。但是还有其他可能。例如,如果
我们的目标是计算某个数值的平方根近似值,我们会将 	n	看做所需的有效位数的数量。通
常,有一些问题相关的特性可用于分析给定的过程。与之相似, 	R(n)	可用于度量所用的内存
总数,所执行的基本的机器操作数量,以及其它。在一次只执行固定数量操作的计算中,用
于求解表达式的所需时间,与求值过程中执行的基本机器操作数量成正比。
我们说, 	R(n)	具有 	Θ(f(n))	的增长度,写作 	R(n)=Θ(f(n))	(读作“theta	 	f(n)	”),如果存在
独立于 	n	的常数 	k1	和 	k2	,那么对于任何足够大的 	n	值:
                                                                               135
3.2	函数和所生成的过程
  k1·f(n)	<=	R(n)	<=	k2·f(n)
也就是说,对于较大的 	n	, 	R(n)	的值夹在两个具有 	f(n)	规模的值之间:
    下界 	k1·f(n)	,以及
    上界 	k2·f(n)	。
例如,计算 	n!	所需的步骤数量与 	n	成正比,所以这个过程的所需步骤以 	Θ(n)	增长。我们也
看到了,递归实现 	fact	的所需空间以 	Θ(n)	增长。与之相反,迭代实现 	fact_iter	花费相似
的步骤数量,但是所需的空间保持不变。这里,我们说这个空间以 	Θ(1)	增长。
我们的树形递归的斐波那契数计算函数 	fib	的步骤数量,随输入 	n	指数增长。尤其是,我们
可以发现,第	n	个斐波那契数是距离 	φ^(n-2)/√5	的最近整数,其中 	φ	是黄金比例:
  φ	=	(1	+	√5)/2	≈	1.6180
我们也表示,步骤数量随返回值增长而增长,所以树形递归过程需要 	Θ(φ^n)	的步骤,它的一
个随 	n	指数增长的函数。
增长度只提供了过程行为的大致描述。例如,需要 	n^2	个步骤的过程和需要 	1000·n^2	个步骤
的过程,以及需要 	3·n^2+10·n+17	个步骤的过程都拥有 	Θ(n^2)	的增长度。在特定的情况下,
增长度的分析过于粗略,不能在函数的两个可能实现中做出判断。
但是,增长度提供了实用的方法,来表示在改变问题规模的时候,我们应如何预期过程行为
的改变。对于 	Θ(n)	(线性)的过程,使规模加倍只会使所需的资源总数加倍。对于指数的过
程,每一点问题规模的增长都会使所用资源以固定因数翻倍。接下来的例子展示了一个增长
度为对数的算法,所以使问题规模加倍,只会使所需资源以固定总数增加。
3.2.6	示例:求幂
考虑对给定数值求幂的问题。我们希望有一个函数,它接受底数 	b	和正整数指数 	n	作为参
数,并计算出 	b^n	。一种方式就是通过递归定义:
  b^n	=	b·b^(n-1)
  b^0	=	1
这可以翻译成递归函数:
  >>>	def	exp(b,	n):
  								if	n	==	0:
  												return	1
  								return	b	*	exp(b,	n-1)
                                                       136
3.2	函数和所生成的过程
这是个线性的递归过程,需要 	Θ(n)	的步骤和空间。就像阶乘那样,我们可以编写等价的线性
迭代形式,它需要相似的步骤数量,但只需要固定的空间。
  >>>	def	exp_iter(b,	n):
  								result	=	1
  								for	_	in	range(n):
  												result	=	result	*	b
  								return	result
我们可以以更少的步骤求幂,通过逐次平方。例如,我们这样计算 	b^8	:
  b·(b·(b·(b·(b·(b·(b·b))))))
我们可以使用三次乘法来计算它:
  b^2	=	b·b
  b^4	=	b^2·b^2
  b^8	=	b^4·b^4
这个方法对于	2	的幂的指数工作良好。我们也可以使用这个递归规则,在求幂中利用逐步平
方的优点:
我们同样可以将这个方式表达为递归函数:
  >>>	def	square(x):
  								return	x*x
  >>>	def	fast_exp(b,	n):
  								if	n	==	0:
  												return	1
  								if	n	%	2	==	0:
  												return	square(fast_exp(b,	n//2))
  								else:
  												return	b	*	fast_exp(b,	n-1)
  >>>	fast_exp(2,	100)
  1267650600228229401496703205376
	fast_exp	所生成的过程的空间和步骤数量随 	n	以对数方式增长。为了弄清楚它,可以看出,
使用 	fast_exp	计算 	b^2n	比计算 	b^n	只需要一步额外的乘法操作。于是,我们能够计算的指
数大小,在每次新的乘法操作时都会(近似)加倍。所以,计算 	n	的指数所需乘法操作的数
量,增长得像以 	2	为底 	n	的对数那样慢。这个过程拥有 	Θ(log	n)	的增长
度。 	Θ(log	n)	和 	Θ(n)	之间的差异在 	n	非常大时变得显著。例
如, 	n	为 	1000	时, 	fast_exp	仅仅需要 	14	个乘法操作,而不是 	1000	。
                                                      137
3.2	函数和所生成的过程
              138
3.3	递归数据结构
3.3	递归数据结构
   来源:3.3	Recursive	Data	Structures
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
在第二章中,我们引入了偶对的概念,作为一种将两个对象结合为一个对象的机制。我们展
示了偶对可以使用内建元素来实现。偶对的封闭性表明偶对的每个元素本身都可以为偶对。
这种封闭性允许我们实现递归列表的数据抽象,它是我们的第一种序列类型。递归列表可以
使用递归函数最为自然地操作,就像它们的名称和结构表示的那样。在这一节中,我们会讨
论操作递归列表和其它递归结构的自定义的函数。
3.3.1	处理递归列表
递归列表结构将列表表示为首个元素和列表的剩余部分的组合。我们之前使用函数实现了递
归列表,但是现在我们可以使用类来重新实现。下面,长度( 	__len__	)和元素选择
( 	__getitem__	)被重写来展示处理递归列表的典型模式。
  >>>	class	Rlist(object):
  								"""A	recursive	list	consisting	of	a	first	element	and	the	rest."""
  								class	EmptyList(object):
  												def	__len__(self):
  																return	0
  								empty	=	EmptyList()
  								def	__init__(self,	first,	rest=empty):
  												self.first	=	first
  												self.rest	=	rest
  								def	__repr__(self):
  												args	=	repr(self.first)
  												if	self.rest	is	not	Rlist.empty:
  																args	+=	',	{0}'.format(repr(self.rest))
  												return	'Rlist({0})'.format(args)
  								def	__len__(self):
  												return	1	+	len(self.rest)
  								def	__getitem__(self,	i):
  												if	i	==	0:
  																return	self.first
  												return	self.rest[i-1]
	__len__	和 	__getitem__	的定义实际上是递归的,虽然不是那么明显。Python	内建函
数 	len	在自定义对象的参数上调用时会寻找叫做 	__len__	的方法。与之类似,下标运算符会
寻找叫做 	__getitem__	的方法。于是,这些定义最后会调用对象自身。剩余部分上的递归调用
是递归列表处理的普遍模式。这个递归列表的类定义与	Python	的内建序列和打印操作能够合
理交互。
                                                                             139
3.3	递归数据结构
  >>>	s	=	Rlist(1,	Rlist(2,	Rlist(3)))
  >>>	s.rest
  Rlist(2,	Rlist(3))
  >>>	len(s)
  3
  >>>	s[1]
  2
创建新列表的操作能够直接使用递归来表示。例如,我们可以定义 	extend_rlist	函数,它接
受两个递归列表作为参数并将二者的元素组合到新列表中。
  >>>	def	extend_rlist(s1,	s2):
  								if	s1	is	Rlist.empty:
  												return	s2
  								return	Rlist(s1.first,	extend_rlist(s1.rest,	s2))
  >>>	extend_rlist(s.rest,	s)
  Rlist(2,	Rlist(3,	Rlist(1,	Rlist(2,	Rlist(3)))))
与之类似,在递归列表上映射函数展示了相似的模式:
  >>>	def	map_rlist(s,	fn):
  								if	s	is	Rlist.empty:
  												return	s
  								return	Rlist(fn(s.first),	map_rlist(s.rest,	fn))
  >>>	map_rlist(s,	square)
  Rlist(1,	Rlist(4,	Rlist(9)))
过滤操作包括额外的条件语句,但是也拥有相似的递归结构。
  >>>	def	filter_rlist(s,	fn):
  								if	s	is	Rlist.empty:
  												return	s
  								rest	=	filter_rlist(s.rest,	fn)
  								if	fn(s.first):
  												return	Rlist(s.first,	rest)
  								return	rest
  >>>	filter_rlist(s,	lambda	x:	x	%	2	==	1)
  Rlist(1,	Rlist(3))
列表操作的递归实现通常不需要局部赋值或者 	while	语句。反之,递归列表可以作为函数调
用的结果来拆分和构造。所以,它们拥有步骤数量和所需空间的线性增长度。
3.3.2	层次结构
层次结构产生于数据的封闭特性,例如,元组可以包含其它元组。考虑这个数值 	1	到 	4	的嵌
套表示。
  >>>	((1,	2),	3,	4)
  ((1,	2),	3,	4)
                                                            140
3.3	递归数据结构
这个元组是个长度为	3	的序列,它的第一个元素也是一个元组。这个嵌套结构的盒子和指针
的图示表明,它可以看做拥有四个叶子的树,每个叶子都是一个数值。
在树中,每个子树本身都是一棵树。作为基本条件,任何本身不是元组的元素都是一个简单
的树,没有任何枝干。也就是说,所有数值都是树,就像在偶对 	(1,	2)	和整个结构中那样。
递归是用于处理树形结构的自然工具,因为我们通常可以将树的操作降至枝干的操作,它会
相应产生枝干的枝干的操作,以此类推,直到我们到达了树的叶子。例如,我们可以实
现 	count_leaves	函数,它返回树的叶子总数。
  >>>	t	=	((1,	2),	3,	4)
  >>>	count_leaves(t)
  4
  >>>	big_tree	=	((t,	t),	5)
  >>>	big_tree
  ((((1,	2),	3,	4),	((1,	2),	3,	4)),	5)
  >>>	count_leaves(big_tree)
  9
正如 	map	是用于处理序列的强大工具,映射和递归一起为树的操作提供了强大而通用的计算
形式。例如,我们可以使用高阶递归函数 	map_tree	将树的每个叶子平方,它的结构类似
于 	count_leaves	。
  >>>	def	map_tree(tree,	fn):
  								if	type(tree)	!=	tuple:
  												return	fn(tree)
  								return	tuple(map_tree(branch,	fn)	for	branch	in	tree)
  >>>	map_tree(big_tree,	square)
  ((((1,	4),	9,	16),	((1,	4),	9,	16)),	25)
内部值。上面描述的树只在叶子上存在值。另一个通用的树形结构表示也在树的内部节点上
存在值。我们使用类来表示这种树。
                                                                141
3.3	递归数据结构
  >>>	class	Tree(object):
  								def	__init__(self,	entry,	left=None,	right=None):
  												self.entry	=	entry
  												self.left	=	left
  												self.right	=	right
  								def	__repr__(self):
  												args	=	repr(self.entry)
  												if	self.left	or	self.right:
  																args	+=	',	{0},	{1}'.format(repr(self.left),	repr(self.right))
  												return	'Tree({0})'.format(args)
例如, 	Tree	类可以为 	fib	的递归实现表示表达式树中计算的值。 	fib	函数用于计算斐波那
契数。下面的函数 	fib_tree(n)	返回 	Tree	,它将第	n	个斐波那契树作为 	entry	,并将所有之
前计算出来的斐波那契数存入它的枝干中。
  >>>	def	fib_tree(n):
  								"""Return	a	Tree	that	represents	a	recursive	Fibonacci	calculation."""
  								if	n	==	1:
  												return	Tree(0)
  								if	n	==	2:
  												return	Tree(1)
  								left	=	fib_tree(n-2)
  								right	=	fib_tree(n-1)
  								return	Tree(left.entry	+	right.entry,	left,	right)
  >>>	fib_tree(5)
  Tree(3,	Tree(1,	Tree(0),	Tree(1)),	Tree(2,	Tree(1),	Tree(1,	Tree(0),	Tree(1))))
这个例子表明,表达式树可以使用树形结构编程表示。嵌套表达式和树形数据结构的联系,
在我们这一章稍后对解释器设计的讨论中起到核心作用。
3.3.3	集合
除了列表、元组和字典之外,Python	拥有第四种容器类型,叫做 	set	。集合字面值遵循元素
以花括号闭合的数学表示。重复的元素在构造中会移除。集合是无序容器,所以打印出来的
顺序可能和元素在集合字面值中的顺序不同。
  >>>	s	=	{3,	2,	1,	4,	4}
  >>>	s
  {1,	2,	3,	4}
Python	的集合支持多种操作,包括成员测试、长度计算和标准的交集并集操作。
  >>>	3	in	s
  True
  >>>	len(s)
  4
  >>>	s.union({1,	5})
  {1,	2,	3,	4,	5}
  >>>	s.intersection({6,	5,	4,	3})
  {3,	4}
                                                                                  142
3.3	递归数据结构
除了 	union	和 	intersection	,Python	的集合还支持多种其它操作。断
言 	isdisjoint	、 	issubset	和 	issuperset	提供了集合比较操作。集合是可变的,并且可以使
用 	add	、 	remove	、 	discard	和 	pop	一次修改一个元素。额外的方法提供了多元素的修改,
例如 	clear	和 	update	。Python	集合文档十分详细并足够易懂。
实现集合。抽象上,集合是不同对象的容器,支持成员测试、交集、并集和附加操作。向集
合添加元素会返回新的集合,它包含原始集合的所有元素,如果没有重复的话,也包含新的
元素。并集和交集运算返回出现在任意一个或两个集合中的元素构成的集合。就像任何数据
抽象那样,我们可以随意实现任何集合表示上的任何函数,只要它们提供这种行为。
在这章的剩余部分,我们会考虑三个实现集合的不同方式,它们在表示上不同。我们会通过
分析集合操作的增长度,刻画这些不同表示的效率。我们也会使用这一章之前
的 	Rlist	和 	Tree	类,它们可以编写用于集合元素操作的简单而优雅的递归解决方案。
作为无序序列的集合。一种集合的表示方式是看做没有出现多于一次的元素的序列。空集由
空序列来表示。成员测试会递归遍历整个列表。
  >>>	def	empty(s):
  								return	s	is	Rlist.empty
  >>>	def	set_contains(s,	v):
  								"""Return	True	if	and	only	if	set	s	contains	v."""
  								if	empty(s):
  												return	False
  								elif	s.first	==	v:
  												return	True
  								return	set_contains(s.rest,	v)
  >>>	s	=	Rlist(1,	Rlist(2,	Rlist(3)))
  >>>	set_contains(s,	2)
  True
  >>>	set_contains(s,	5)
  False
这个 	set_contains	的实现需要 	Θ(n)	的时间来测试元素的成员性,其中 	n	是集合 	s	的大小。
使用这个线性时间的成员测试函数,我们可以将元素添加到集合中,也是线性时间。
  >>>	def	adjoin_set(s,	v):
  								"""Return	a	set	containing	all	elements	of	s	and	element	v."""
  								if	set_contains(s,	v):
  												return	s
  								return	Rlist(v,	s)
  >>>	t	=	adjoin_set(s,	4)
  >>>	t
  Rlist(4,	Rlist(1,	Rlist(2,	Rlist(3))))
那么问题来了,我们应该在设计表示时关注效率。计算两个集合 	set1	和 	set2	的交集需要成
员测试,但是这次每个 	set1	的元素必须测试 	set2	中的成员性,对于两个大小为 	n	的集合,
这会产生步骤数量的平方增长度 	Θ(n^2)	。
                                                                         143
3.3	递归数据结构
  >>>	def	intersect_set(set1,	set2):
  								"""Return	a	set	containing	all	elements	common	to	set1	and	set2."""
  								return	filter_rlist(set1,	lambda	v:	set_contains(set2,	v))
  >>>	intersect_set(t,	map_rlist(s,	square))
  Rlist(4,	Rlist(1))
在计算两个集合的并集时,我们必须小心避免两次包含任意一个元素。 	union_set	函数也需
要线性数量的成员测试,同样会产生包含 	Θ(n^2)	步骤的过程。
  >>>	def	union_set(set1,	set2):
  								"""Return	a	set	containing	all	elements	either	in	set1	or	set2."""
  								set1_not_set2	=	filter_rlist(set1,	lambda	v:	not	set_contains(set2,	v))
  								return	extend_rlist(set1_not_set2,	set2)
  >>>	union_set(t,	s)
  Rlist(4,	Rlist(1,	Rlist(2,	Rlist(3))))
作为有序元组的集合。一种加速我们的集合操作的方式是修改表示,使集合元素递增排列。
为了这样做,我们需要一些比较两个对象的方式,使我们能判断哪个更大。Python	中,许多
不同对象类型都可以使用 	<	和 	>	运算符比较,但是我们会专注于这个例子中的数值。我们会
通过将元素递增排列来表示数值集合。
有序的一个优点会在 	set_contains	体现:在检查对象是否存在时,我们不再需要扫描整个集
合。如果我们到达了大于要寻找的元素的集合元素,我们就知道这个元素不在集合中:
  >>>	def	set_contains(s,	v):
  								if	empty(s)	or	s.first	>	v:
  												return	False
  								elif	s.first	==	v:
  												return	True
  								return	set_contains(s.rest,	v)
  >>>	set_contains(s,	0)
  False
这节省了多少步呢?最坏的情况中,我们所寻找的元素可能是集合中最大的元素,所以步骤
数量和无序表示相同。另一方面,如果我们寻找许多不同大小的元素,我们可以预料到有时
我们可以在列表开头的位置停止搜索,其它情况下我们仍旧需要检测整个列表。平均上我们
应该需要检测集合中一半的元素。所以,步骤数量的平均值应该是 	n/2	。这还是 	Θ(n)	的增
长度,但是它确实会在平均上为我们节省之前实现的一半步骤数量。
我们可以通过重新实现 	intersect_set	获取更加可观的速度提升。在无序表示中,这个操作需
要 	Θ(n^2)	的步骤,因为我们对 	set1	的每个元素执行 	set2	上的完整扫描。但是使用有序的
实现,我们可以使用更加机智的方式。我们同时迭代两个集合,跟踪 	set1	中的元
素 	e1	和 	set2	中的元素 	e2	。当 	e1	和 	e2	相等时,我们在交集中添加该元素。
但是,假设 	e1	小于 	e2	,由于 	e2	比 	set2	的剩余元素更小,我们可以立即推断出 	e1	不会出
现在 	set2	剩余部分的任何位置,因此也不会出现在交集中。所以,我们不再需要考虑 	e1	,
我们将它丢弃并来到 	set1	的下一个元素。当 	e2	<	e1	时,我们可以使用相似的逻辑来步
进 	set2	中的元素。下面是这个函数:
                                                                                  144
3.3	递归数据结构
  >>>	def	intersect_set(set1,	set2):
  								if	empty(set1)	or	empty(set2):
  												return	Rlist.empty
  								e1,	e2	=	set1.first,	set2.first
  								if	e1	==	e2:
  												return	Rlist(e1,	intersect_set(set1.rest,	set2.rest))
  								elif	e1	<	e2:
  												return	intersect_set(set1.rest,	set2)
  								elif	e2	<	e1:
  												return	intersect_set(set1,	set2.rest)
  >>>	intersect_set(s,	s.rest)
  Rlist(2,	Rlist(3))
为了估计这个过程所需的步骤数量,观察每一步我们都缩小了至少集合的一个元素的大小。
所以,所需的步骤数量最多为 	set1	和 	set2	的大小之和,而不是无序表示所需的大小之积。
这是 	Θ(n)	而不是 	Θ(n^2)	的增长度	--	即使集合大小适中,它也是一个相当可观的加速。例
如,两个大小为 	100	的集合的交集需要	 	200	步,而不是无序表示的	10000	步。
表示为有序序列的集合的添加和并集操作也以线性时间计算。这些实现都留做练习。
作为二叉树的集合。我们可以比有序列表表示做得更好,通过将几个元素重新以树的形式排
列。我们使用之前引入的 	Tree	类。树根的 	entry	持有集合的一个元素。 	left	分支的元素包
括所有小于树根元素的元素。 	right	分支的元素包括所有大于树根元素的元素。下面的图展
示了一些树,它们表示集合 	{1,	3,	5,	7,	9,	11}	。相同的集合可能会以不同形式的树来表
示。有效表示所需的唯一条件就是所有 	left	子树的元素应该小于 	entry	,并且所
有 	right	子树的元素应该大于它。
树形表示的优点是:假设我们打算检查 	v	是否在集合中。我们通过将 	v	于 	entry	比较开始。
如果 	v	小于它,我们就知道了我们只需要搜索 	left	子树。如果 	v	大于它,我们只需要搜
索 	right	子树。现在如果树是“平衡”的,每个这些子树都约为整个的一半大小。所以,每一步
中我们都可以将大小为 	n	的树的搜索问题降至搜索大小为 	n/2	的子树。由于树的大小在每一
步减半,我们应该预料到,用户搜索树的步骤以 	Θ(log	n)	增长。比起之前的表示,它的速度
对于大型集合有可观的提升。 	set_contains	函数利用了树形集合的有序结构:
                                                                    145
3.3	递归数据结构
  >>>	def	set_contains(s,	v):
  								if	s	is	None:
  												return	False
  								elif	s.entry	==	v:
  												return	True
  								elif	s.entry	<	v:
  												return	set_contains(s.right,	v)
  								elif	s.entry	>	v:
  												return	set_contains(s.left,	v)
向集合添加元素与之类似,并且也需要 	Θ(log	n)	的增长度。为了添加值 	v	,我们
将 	v	与 	entry	比较,来决定 	v	应该添加到 	right	还是 	left	分支,以及是否已经将 	v	添加
到了合适的分支上。我们将这个新构造的分支与原始的 	entry	和其它分支组合。如果 	v	等
于 	entry	,我们就可以返回这个节点。如果我们被要求将 	v	添加到空的树中,我们会生成一
个 	Tree	,它包含 	v	作为 	entry	,并且 	left	和 	right	都是空的分支。下面是这个函数:
  >>>	def	adjoin_set(s,	v):
  								if	s	is	None:
  												return	Tree(v)
  								if	s.entry	==	v:
  												return	s
  								if	s.entry	<	v:
  												return	Tree(s.entry,	s.left,	adjoin_set(s.right,	v))
  								if	s.entry	>	v:
  												return	Tree(s.entry,	adjoin_set(s.left,	v),	s.right)
  >>>	adjoin_set(adjoin_set(adjoin_set(None,	2),	3),	1)
  Tree(2,	Tree(1),	Tree(3))
搜索该树可以以对数步骤数量执行,我们这个叙述基于树是“平衡”的假设。也就是说,树的左
子树和右子树都拥有相同数量的相应元素,使每个子树含有母树一半的元素。但是我们如何
确定,我们构造的树就是平衡的呢?即使我们以一颗平衡树开始,使用 	adjoin_set	添加元素
也会产生不平衡的结果。由于新添加的元素位置取决于如何将元素与集合中的已有元素比
较,我们可以预测,如果我们“随机”添加元素到树中,树在平均上就会趋向于平衡。
但是这不是一个保证。例如,如果我们以空集开始,并向序列中添加	1	到	7,我们就会在最
后得到很不平衡的树,其中所有左子树都是空的,所以它与简单的有序列表相比并没有什么
优势。一种解决这个问题的方式是定义一种操作,它将任意的树转换为具有相同元素的平衡
树。我们可以在每个 	adjoin_set	操作之后执行这个转换来保证我们的集合是平衡的。
交集和并集操作可以在树形集合上以线性时间执行,通过将它们转换为有序的列表,并转换
回来。细节留做练习。
Python	集合实现。Python	内建的 	set	类型并没有使用上述任意一种表示。反之,Python	使
用了一种实现,它的成员测试和添加操作是(近似)常量时间的,基于一种叫做哈希(散
列)的机制,这是其它课程的话题。内建的	Python	集合不能包含可变的数据类型,例如列
表、字典或者其它集合。为了能够嵌套集合,Python	也提供了一种内建的不可
变 	frozenset	类,除了可变操作和运算符之外,它拥有和 	set	相同的方法。
                                                                   146
3.3	递归数据结构
           147
3.4	异常
3.4	异常
   来源:3.4	Exceptions
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
程序员必须总是留意程序中可能出现的错误。例子数不胜数:一个函数可能不会收到它预期
的信息,必需的资源可能会丢失,或者网络上的连接可能丢失。在设计系统时,程序员必须
预料到可能产生的异常情况并且采取适当地措施来处理它们。
处理程序中的错误没有单一的正确方式。为提供一些持久性服务而设计的程序,例如	Web	服
务器	应该对错误健壮,将它们记录到日志中为之后考虑,而且在尽可能长的时间内继续接受
新的请求。另一方面,Python	解释器通过立即终止以及打印错误信息来处理错误,便于程序
员在错误发生时处理它。在任何情况下,程序员必须决定程序如何对异常条件做出反应。
异常是这一节的话题,它为程序的错误处理提供了通用的机制。产生异常是一种技巧,终止
程序正常执行流,发射异常情况产生的信号,并直接返回到用于响应异常情况的程序的封闭
部分。Python	解释器每次在检测到语句或表达式错误时抛出异常。用户也可以使
用 	raise	或 	assert	语句来抛出异常。
抛出异常。异常是一个对象实例,它的类直接或间接继承自 	BaseException	类。第一章引入
的 	assert	语句产生 	AssertionError	类的异常。通常,异常实例可以使用 	raise	语句来抛
出。 	raise	语句的通用形式在	Python	文档中描述。 	raise	的最常见的作用是构造异常实例
并抛出它。
  >>>	raise	Exception('An	error	occurred')
  Traceback	(most	recent	call	last):
  		File	"<stdin>",	line	1,	in	<module>
  Exception:	an	error	occurred
当异常产生时,当前代码块的语句不会继续执行。除非异常被解决了(下面会描述),解释
器会直接返回到“读取-求值-打印”交互式循环中,或者在	Python	以文件参数启动的情况下会
完全终止。此外,解释器会打印栈回溯,它是结构化的文本块,描述了执行分支中的一系列
嵌套的活动函数,它们是异常产生的位置。在上面的例子中,文件名称 	<stdin>	表示异常由
用户在交互式会话中产生,而不是文件中的代码。
处理异常。异常可以使用封闭的 	try	语句来处理。 	try	语句由多个子句组成,第一个子句
以 	try	开始,剩下的以 	except	开始。
                                                            148
3.4	异常
  try:
  				<try	suite>
  except	<exception	class>	as	<name>:
  				<except	suite>
  ...
当 	try	语句执行时, 	<try	suite>	总是会立即执行。 	except	子句组只在 	<try	suite>	执行过
程中的异常产生时执行。每个 	except	子句指定了需要处理的异常的特定类。例如,如
果 	<exception	class>	是 	AssertionError	,那么任何继承自 	AssertionError	的类实例都会被处
理,标识符 	<name>	绑定到所产生的异常对象上,但是这个绑定在 	<except	suite>	之外并不有
效。
例如,我们可以使用 	try	语句来处理异常,在异常发生时将 	x	绑定为 	0	。
  >>>	try:
  								x	=	1/0
  				except	ZeroDivisionError	as	e:
  								print('handling	a',	type(e))
  								x	=	0
  handling	a	<class	'ZeroDivisionError'>
  >>>	x
  0
	try	语句能够处理产生在函数体中的异常,函数在 	<try	suite>	中调用。当异常产生时,控
制流会直接跳到最近的 	try	语句的能够处理该异常类型的 	<except	suite>	的主体中。
  >>>	def	invert(x):
  								result	=	1/x		#	Raises	a	ZeroDivisionError	if	x	is	0
  								print('Never	printed	if	x	is	0')
  								return	result
  >>>	def	invert_safe(x):
  								try:
  												return	invert(x)
  								except	ZeroDivisionError	as	e:
  												return	str(e)
  >>>	invert_safe(2)
  Never	printed	if	x	is	0
  0.5
  >>>	invert_safe(0)
  'division	by	zero'
这个例子表明, 	invert	中的 	print	表达式永远不会求值,反之,控制流跳到了 	handler	中
的 	except	子句组中。将 	ZeroDivisionError	e	强制转为字符串会得到
由 	handler:	'division	by	zero'	返回的人类可读的字符串。
3.4.1	异常对象
异常对象本身就带有属性,例如在 	assert	语句中的错误信息,以及有关异常产生处的信息。
用户定义的异常类可以携带额外的属性。
                                                                      149
3.4	异常
在第一章中,我们实现了牛顿法来寻找任何函数的零点。下面的例子定义了一个异常类,无
论何时 	ValueError	出现,它都返回迭代改进过程中所发现的最佳猜测值。数学错误
( 	ValueError	的一种)在 	sqrt	在负数上调用时产生。这个异常由抛出 	IterImproveError	处
理,它将牛顿迭代法的最新猜测值储存为参数。
首先,我们定义了新的类,继承自 	Exception	。
  >>>	class	IterImproveError(Exception):
  								def	__init__(self,	last_guess):
  												self.last_guess	=	last_guess
下面,我们定义了 	IterImprove	,我们的通用迭代改进算法的一个版本。这个版本通过抛
出 	IterImproveError	异常,储存最新的猜测值来处理任何 	ValueError	。像之前一
样, 	iter_improve	接受两个函数作为参数,每个函数都接受单一的数值参数。 	update	函数返
回新的猜测值,而 	done	函数返回布尔值,表明改进是否收敛到了正确的值。
  >>>	def	iter_improve(update,	done,	guess=1,	max_updates=1000):
  								k	=	0
  								try:
  												while	not	done(guess)	and	k	<	max_updates:
  																guess	=	update(guess)
  																k	=	k	+	1
  												return	guess
  								except	ValueError:
  												raise	IterImproveError(guess)
最后,我们定义了 	find_root	,它返回 	iter_improve	的结果。 	iter_improve	应用于
由 	newton_update	返回的牛顿更新函数。 	newton_update	定义在第一章,在这个例子中无需任
何改变。 	find_root	的这个版本通过返回它的最后一个猜测之来处理 	IterImproveError	。
  >>>	def	find_root(f,	guess=1):
  								def	done(x):
  												return	f(x)	==	0
  								try:
  												return	iter_improve(newton_update(f),	done,	guess)
  								except	IterImproveError	as	e:
  												return	e.last_guess
考虑使用 	find_root	来寻找 	2	*	x	**	2	+	sqrt(x)	的零点。这个函数的一个零点是 	0	,但是
在任何负数上求解它会产生 	ValueError	。我们第一章的牛顿法实现会产生异常,并且不能返
回任何零点的猜测值。我们的修订版实现在错误之前返回了最新的猜测值。
  >>>	from	math	import	sqrt
  >>>	find_root(lambda	x:	2*x*x	+	sqrt(x))
  -0.030211203830201594
虽然这个近似值仍旧距离正确的答案 	0	很远,一些应用更倾向于这个近似值而不
是 	ValueError	。
                                                                 150
3.4	异常
异常是另一个技巧,帮助我们将程序细节划分为模块化的部分。在这个例子中,Python	的异
常机制允许我们分离迭代改进的逻辑,它在 	try	子句组中没有发生改变,以及错误处理的逻
辑,它出现在 	except	子句中。我们也会发现,异常在使用	Python	实现解释器时是个非常实
用的特性。
                                                 151
3.5	组合语言的解释器
3.5	组合语言的解释器
   来源:3.5	Interpreters	for	Languages	with	Combination
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
运行在任何现代计算机上的软件都以多种编程语言写成。其中有物理语言,例如用于特定计
算机的机器语言。这些语言涉及到基于独立储存位和原始机器指令的数据表示和控制。机器
语言的程序员涉及到使用提供的硬件,为资源有限的计算构建系统和功能的高效实现。高阶
语言构建在机器语言之上,隐藏了表示为位集的数据,以及表示为原始指令序列的程序的细
节。这些语言拥有例如过程定义的组合和抽象的手段,它们适用于组织大规模的软件系统。
元语言抽象	--	建立了新的语言	--	并在所有工程设计分支中起到重要作用。它对于计算机编程
尤其重要,因为我们不仅仅可以在编程中构想出新的语言,我们也能够通过构建解释器来实
现它们。编程语言的解释器是一个函数,它在语言的表达式上调用,执行求解表达式所需的
操作。
我们现在已经开始了技术之旅,通过这种技术,编程语言可以建立在其它语言之上。我们首
先会为计算器定义解释器,它是一种受限的语言,和	Python	调用表达式具有相同的语法。我
们之后会从零开始开发	Scheme	和	Logo	语言的解释器,它们都是	Lisp	的方言,Lisp	是现在
仍旧广泛使用的第二老的语言。我们所创建的解释器,在某种意义上,会让我们使用	Logo	编
写完全通用的程序。为了这样做,它会实现我们已经在这门课中开发的求值环境模型。
3.5.1	计算器
我们的第一种新语言叫做计算器,一种用于加减乘除的算术运算的表达式语言。计算器拥有
Python	调用表达式的语法,但是它的运算符对于所接受的参数数量更加灵活。例如,计算器
运算符 	mul	和 	add	可接受任何数量的参数:
  calc>	add(1,	2,	3,	4)
  10
  calc>	mul()
  1
	sub	运算符拥有两种行为:传入一个运算符,它会对运算符取反。传入至少两个,它会从第
一个参数中减掉剩余的参数。 	div	运算符拥有	Python	的 	operator.truediv	的语义,只接受
两个参数。
                                                          152
3.5	组合语言的解释器
  calc>	sub(10,	1,	2,	3)
  4
  calc>	sub(3)
  -3
  calc>	div(15,	12)
  1.25
就像	Python	中那样,调用表达式的嵌套提供了计算器语言中的组合手段。为了精简符号,我
们使用运算符的标准符号来代替名称:
  calc>	sub(100,	mul(7,	add(8,	div(-12,	-3))))
  16.0
  calc>	-(100,	*(7,	+(8,	/(-12,	-3))))
  16.0
我们会使用	Python	实现计算器解释器。也就是说,我们会编写	Python	程序来接受字符串作
为输入,并返回求值结果。如果输入是符合要求的计算器表达式,结果为字符串,反之会产
生合适的异常。计算器语言解释器的核心是叫做 	calc_eval	的递归函数,它会求解树形表达
式对象。
表达式树。到目前为止,我们在描述求值过程中所引用的表达式树,还是概念上的实体。我
们从没有显式将表达式树表示为程序中的数据。为了编写解释器,我们必须将表达式当做数
据操作。在这一章中,许多我们之前介绍过的概念都会最终以代码实现。
计算器中的基本表达式只是一个数值,类型为 	int	或 	float	。所有复合表达式都是调用表达
式。调用表达式表示为拥有两个属性实例的 	Exp	类。计算器的 	operator	总是字符串:算数运
算符的名称或符号。 	operands	要么是基本表达式,要么是 	Exp	的实例本身。
  >>>	class	Exp(object):
  								"""A	call	expression	in	Calculator."""
  								def	__init__(self,	operator,	operands):
  												self.operator	=	operator
  												self.operands	=	operands
  								def	__repr__(self):
  												return	'Exp({0},	{1})'.format(repr(self.operator),	repr(self.operands))
  								def	__str__(self):
  												operand_strs	=	',	'.join(map(str,	self.operands))
  												return	'{0}({1})'.format(self.operator,	operand_strs)
	Exp	实例定义了两个字符串方法。 	__repr__	方法返回	Python	表达式,而 	__str__	方法返回
计算器表达式。
  >>>	Exp('add',	[1,	2])
  Exp('add',	[1,	2])
  >>>	str(Exp('add',	[1,	2]))
  'add(1,	2)'
  >>>	Exp('add',	[1,	Exp('mul',	[2,	3,	4])])
  Exp('add',	[1,	Exp('mul',	[2,	3,	4])])
  >>>	str(Exp('add',	[1,	Exp('mul',	[2,	3,	4])]))
  'add(1,	mul(2,	3,	4))'
                                                                                      153
3.5	组合语言的解释器
最后的例子演示了 	Exp	类如何通过包含作为 	operands	元素的 	Exp	的实例,来表示表达式树
中的层次结构。
求值。 	calc_eval	函数接受表达式作为参数,并返回它的值。它根据表达式的形式为表达式
分类,并且指导它的求值。对于计算器来说,表达式的两种句法形式是数值或调用表达式,
后者是 	Exp	的实例。数值是自求值的,它们可以直接从 	calc_eval	中返回。调用表达式需要
使用函数。
调用表达式首先通过将 	calc_eval	函数递归映射到操作数的列表,计算出参数列表来求值。
之后,在第二个函数 	calc_apply	中,运算符会作用于这些参数上。
计算器语言足够简单,我们可以轻易地在单一函数中表达每个运算符的使用逻辑。
在 	calc_apply	中,每种条件子句对应一个运算符。
  >>>	from	operator	import	mul
  >>>	from	functools	import	reduce
  >>>	def	calc_apply(operator,	args):
  								"""Apply	the	named	operator	to	a	list	of	args."""
  								if	operator	in	('add',	'+'):
  												return	sum(args)
  								if	operator	in	('sub',	'-'):
  												if	len(args)	==	0:
  																raise	TypeError(operator	+	'	requires	at	least	1	argument')
  												if	len(args)	==	1:
  																return	-args[0]
  												return	sum(args[:1]	+	[-arg	for	arg	in	args[1:]])
  								if	operator	in	('mul',	'*'):
  												return	reduce(mul,	args,	1)
  								if	operator	in	('div',	'/'):
  												if	len(args)	!=	2:
  																raise	TypeError(operator	+	'	requires	exactly	2	arguments')
  												numer,	denom	=	args
  												return	numer/denom
上面,每个语句组计算了不同运算符的结果,或者当参数错误时产生合适
的 	TypeError	。 	calc_apply	函数可以直接调用,但是必须传入值的列表作为参数,而不是运
算符表达式的列表。
  >>>	calc_apply('+',	[1,	2,	3])
  6
  >>>	calc_apply('-',	[10,	1,	2,	3])
  4
  >>>	calc_apply('*',	[])
  1
  >>>	calc_apply('/',	[40,	5])
  8.0
	calc_eval	的作用是,执行合适的 	calc_apply	调用,通过首先计算操作数子表达式的值,之
后将它们作为参数传入 	calc_apply	。于是, 	calc_eval	可以接受嵌套表达式。
                                                                              154
3.5	组合语言的解释器
  >>>	e	=	Exp('add',	[2,	Exp('mul',	[4,	6])])
  >>>	str(e)
  'add(2,	mul(4,	6))'
  >>>	calc_eval(e)
  26
	calc_eval	的结构是个类型(表达式的形式)分发的例子。第一种表达式是数值,不需要任
何的额外求值步骤。通常,基本表达式不需要任何额外的求值步骤,这叫做自求值。计算器
语言中唯一的自求值表达式就是数值,但是在通用语言中可能也包括字符串、布尔值,以及
其它。
“读取-求值-打印”循环。和解释器交互的典型方式是“读取-求值-打印”循环(REPL),它是一
种交互模式,读取表达式、对其求值,之后为用户打印出结果。Python	交互式会话就是这种
循环的例子。
REPL	的实现与所使用的解释器无关。下面的 	read_eval_print_loop	函数使用内建的 	input	函
数,从用户接受一行文本作为输入。它使用语言特定的 	calc_parse	函数构建表达式
树。 	calc_parse	在随后的解析一节中定义。最后,它打印出对由 	calc_parse	返回的表达式树
调用 	calc_eval	的结果。
  >>>	def	read_eval_print_loop():
  								"""Run	a	read-eval-print	loop	for	calculator."""
  								while	True:
  												expression_tree	=	calc_parse(input('calc>	'))
  												print(calc_eval(expression_tree))
	read_eval_print_loop	的这个版本包含所有交互式界面的必要组件。一个样例会话可能像这
样:
  calc>	mul(1,	2,	3)
  6
  calc>	add()
  0
  calc>	add(2,	div(4,	8))
  2.5
这个循环没有实现终端或者错误处理机制。我们可以通过向用户报告错误来改进这个界面。
我们也可以允许用户通过发射键盘中断信号( 	Control-C	),或文件末尾信号( 	Control-D	)
来退出循环。为了实现这些改进,我们将原始的 	while	语句组放在 	try	语句中。第一
个 	except	子句处理了由 	calc_parse	产生的 	SyntaxError	异常,也处理了由 	calc_eval	产生
的 	TypeError	和 	ZeroDivisionError	异常。
                                                                    155
3.5	组合语言的解释器
  >>>	def	read_eval_print_loop():
  								"""Run	a	read-eval-print	loop	for	calculator."""
  								while	True:
  												try:
  																expression_tree	=	calc_parse(input('calc>	'))
  																print(calc_eval(expression_tree))
  												except	(SyntaxError,	TypeError,	ZeroDivisionError)	as	err:
  																print(type(err).__name__	+	':',	err)
  												except	(KeyboardInterrupt,	EOFError):		#	<Control>-D,	etc.
  																print('Calculation	completed.')
  																return
这个循环实现报告错误而不退出循环。发生错误时不退出程序,而是在错误消息之后重新开
始循环可以让用户回顾他们的表达式。通过导入 	readline	模块,用户甚至可以使用上箭头
或 	Control-P	来回忆他们之前的输入。最终的结果提供了错误信息报告的界面:
  calc>	add
  SyntaxError:	expected	(	after	add
  calc>	div(5)
  TypeError:	div	requires	exactly	2	arguments
  calc>	div(1,	0)
  ZeroDivisionError:	division	by	zero
  calc>	^DCalculation	completed.
在我们将解释器推广到计算器之外的语言时,我们会看到, 	read_eval_print_loop	由解析函
数、求值函数,和由 	try	语句处理的异常类型参数化。除了这些修改之外,任何	REPL	都可
以使用相同的结构来实现。
3.5.2	解析
解析是从原始文本输入生成表达式树的过程。解释这些表达式树是求值函数的任务,但是解
析器必须提供符合格式的表达式树给求值器。解析器实际上由两个组件组成,词法分析器和
语法分析器。首先,词法分析器将输入字符串拆成标记(token),它们是语言的最小语法单
元,就像名称和符号那样。其次,语法分析器从这个标记序列中构建表达式树。
  >>>	def	calc_parse(line):
  								"""Parse	a	line	of	calculator	input	and	return	an	expression	tree."""
  								tokens	=	tokenize(line)
  								expression_tree	=	analyze(tokens)
  								if	len(tokens)	>	0:
  												raise	SyntaxError('Extra	token(s):	'	+	'	'.join(tokens))
  								return	expression_tree
标记序列由叫做 	tokenize	的词法分析器产生,并被叫做 	analyze	语法分析器使用。这里,我
们定义了 	calc_parse	,它只接受符合格式的计算器表达式。一些语言的解析器为接受以换行
符、分号或空格分隔的多种表达式而设计。我们在引入	Logo	语言之前会推迟实现这种复杂
性。
                                                                                156
3.5	组合语言的解释器
词法分析。用于将字符串解释为标记序列的组件叫做分词器(tokenizer	),或者词法分析
器。在我们的视线中,分词器是个叫做 	tokenize	的函数。计算器语言由包含数值、运算符名
称和运算符类型的符号(比如 	+	)组成。这些符号总是由两种分隔符划分:逗号和圆括号。
每个符号本身都是标记,就像每个逗号和圆括号那样。标记可以通过向输入字符串添加空
格,之后在每个空格处分割字符串来分开。
  >>>	def	tokenize(line):
  								"""Convert	a	string	into	a	list	of	tokens."""
  								spaced	=	line.replace('(','	(	').replace(')','	)	').replace(',',	'	,	')
  								return	spaced.split()
对符合格式的计算器表达式分词不会损坏名称,但是会分开所有符号和分隔符。
  >>>	tokenize('add(2,	mul(4,	6))')
  ['add',	'(',	'2',	',',	'mul',	'(',	'4',	',',	'6',	')',	')']
拥有更加复合语法的语言可能需要更复杂的分词器。特别是,许多分析器会解析每种返回标
记的语法类型。例如,计算机中的标记类型可能是运算符、名称、数值或分隔符。这个分类
可以简化标记序列的解析。
语法分析。将标记序列解释为表达式树的组件叫做语法分析器。在我们的实现中,语法分析
由叫做 	analyze	的递归函数完成。它是递归的,因为分析标记序列经常涉及到分析这些表达
式树中的标记子序列,它本身作为更大的表达式树的子分支(比如操作数)。递归会生成由
求值器使用的层次结构。
	analyze	函数接受标记列表,以符合格式的表达式开始。它会分析第一个标记,将表示数值
的字符串强制转换为数字的值。之后要考虑计算机中的两个合法表达式类型。数字标记本身
就是完整的基本表达式树。复合表达式以运算符开始,之后是操作数表达式的列表,由圆括
号分隔。我们以一个不检查语法错误的实现开始。
  >>>	def	analyze(tokens):
  								"""Create	a	tree	of	nested	lists	from	a	sequence	of	tokens."""
  								token	=	analyze_token(tokens.pop(0))
  								if	type(token)	in	(int,	float):
  												return	token
  								else:
  												tokens.pop(0)		#	Remove	(
  												return	Exp(token,	analyze_operands(tokens))
  >>>	def	analyze_operands(tokens):
  								"""Read	a	list	of	comma-separated	operands."""
  								operands	=	[]
  								while	tokens[0]	!=	')':
  												if	operands:
  																tokens.pop(0)		#	Remove	,
  												operands.append(analyze(tokens))
  								tokens.pop(0)		#	Remove	)
  								return	operands
                                                                                  157
3.5	组合语言的解释器
最后,我们需要实现 	analyze_token	。 	analyze_token	函数将数值文本转换为数值。我们并不
自己实现这个逻辑,而是依靠内建的	Python	类型转换,使用 	int	和 	float	构造器来将标记
转换为这种类型。
  >>>	def	analyze_token(token):
  								"""Return	the	value	of	token	if	it	can	be	analyzed	as	a	number,	or	token."""
  								try:
  												return	int(token)
  								except	(TypeError,	ValueError):
  												try:
  																return	float(token)
  												except	(TypeError,	ValueError):
  																return	token
我们的 	analyze	实现就完成了。它能够正确将符合格式的计算器表达式解析为表达式树。这
些树由 	str	函数转换回计算器表达式。
  >>>	expression	=	'add(2,	mul(4,	6))'
  >>>	analyze(tokenize(expression))
  Exp('add',	[2,	Exp('mul',	[4,	6])])
  >>>	str(analyze(tokenize(expression)))
  'add(2,	mul(4,	6))'
	analyse	函数只会返回符合格式的表达式树,并且它必须检测输入中的语法错误。特别是,
它必须检测表达式是否完整、正确分隔,以及只含有已知的运算符。下面的修订版本确保了
语法分析的每一步都找到了预期的标记。
  >>>	known_operators	=	['add',	'sub',	'mul',	'div',	'+',	'-',	'*',	'/']
  >>>	def	analyze(tokens):
  								"""Create	a	tree	of	nested	lists	from	a	sequence	of	tokens."""
  								assert_non_empty(tokens)
  								token	=	analyze_token(tokens.pop(0))
  								if	type(token)	in	(int,	float):
  												return	token
  								if	token	in	known_operators:
  												if	len(tokens)	==	0	or	tokens.pop(0)	!=	'(':
  																raise	SyntaxError('expected	(	after	'	+	token)
  												return	Exp(token,	analyze_operands(tokens))
  								else:
  												raise	SyntaxError('unexpected	'	+	token)
  >>>	def	analyze_operands(tokens):
  								"""Analyze	a	sequence	of	comma-separated	operands."""
  								assert_non_empty(tokens)
  								operands	=	[]
  								while	tokens[0]	!=	')':
  												if	operands	and	tokens.pop(0)	!=	',':
  																raise	SyntaxError('expected	,')
  												operands.append(analyze(tokens))
  												assert_non_empty(tokens)
  								tokens.pop(0)		#	Remove	)
  								return	elements
  >>>	def	assert_non_empty(tokens):
  								"""Raise	an	exception	if	tokens	is	empty."""
  								if	len(tokens)	==	0:
  												raise	SyntaxError('unexpected	end	of	line')
                                                                                       158
3.5	组合语言的解释器
大量的语法错误在本质上提升了解释器的可用性。在上面, 	SyntaxError	异常包含所发生的问
题描述。这些错误字符串也用作这些分析函数的定义文档。
这个定义完成了我们的计算器解释器。你可以获取单独的	Python	3	源码	 	calc.py	来测试。我
们的解释器对错误健壮,用户在 	calc>	提示符后面的每个输入都会求值为数值,或者产生合
适的错误,描述输入为什么不是符合格式的计算器表达式。
                                                   159
3.6	抽象语言的解释器
3.6	抽象语言的解释器
   来源:3.6	Interpreters	for	Languages	with	Abstraction
   译者:飞龙
   协议:CC	BY-NC-SA	4.0
计算器语言提供了一种手段,来组合一些嵌套的调用表达式。然而,我们却没有办法定义新
的运算符,将值赋给名称,或者表达通用的计算方法。总之,计算器并不以任何方式支持抽
象。所以,它并不是特别强大或通用的编程语言。我们现在转到定义一种通用编程语言的任
务中,这门语言通过将名称绑定到值以及定义新的操作来支持抽象。
我们并不是进一步扩展简单的计算器语言,而是重新开始,并且为	Logo	语言开发解释器。
Logo	并不是为这门课发明的语言,而是一种经典的命令式语言,拥有许多解释器实现和自己
的开发者社区。
上一章,我们将完整的解释器表示为	Python	源码,这一章使用描述性的方式。某个配套工程
需要你通过构建完整的	Logo	函数式解释器来实现这里展示的概念。
3.6.1	Scheme	语言
Scheme	是	Lisp	的一种方言,Lisp	是现在仍在广泛使用的第二老(在	Fortran	之后)的编程
语言。Scheme首次在	1975	年由	Gerald	Sussman	和	Guy	Steele	描述。Revised(4)	Report
on	the	Algorithmic	Language	Scheme	的引言中写道:
   编程语言不应该通过堆砌特性,而是应该通过移除那些使额外特性变得必要的缺点和限
   制来设计。Scheme	表明,用于组成表达式的非常少量的规则,在没有组合方式的限制
   的情况下,足以组成实用并且高效的编程语言,它足够灵活,在使用中可以支持多数当
   今的主流编程范式。
我们将这个报告推荐给你作为	Scheme	语言的详细参考。我们这里只会涉及重点。下面的描
述中,我们会用到报告中的例子。
虽然	Scheme	非常简单,但它是一种真正的编程语言,在许多地方都类似于	Python,但
是“语法糖[1]”会尽量少。基本上,所有运算符都是函数调用的形式。这里我们会描述完整的
Scheme	语言的在报告中描述的可展示的子集。
   [1]	非常遗憾,这对于	Scheme	语言的最新版本并不成立,就像	Revised(6)	Report	中的
   那样。所以这里我们仅仅针对之前的版本。
                                                                   160
3.6	抽象语言的解释器
Scheme	有多种可用的实现,它们添加了额外的过程。在	UCB,我们使用Stk	解释器的一个
修改版,它也在我们的教学服务器上以 	stk	提供。不幸的是,它并不严格遵守正式规范,但
它可用于我们的目的。
使用解释器。就像	Python	解释器[2]那样,向	Stk	键入的表达式会由“读取-求值-打印”循环求
值并打印:
  >>>	3
  3
  >>>	(-	(/	(*	(+	3	7	10)	(-	1000	8))	992)	17)
  3
  >>>	(define	(fib	n)	(if	(<	n	2)	n	(+	(fib	(-	n	2))	(fib	(-	n	1)))))
  fib
  >>>	'(1	(7	19))
  (1	(7	19))
   [2]	在我们的例子中,我们使用了和	Python	相同的符号 	>>>	和 	...	,来表示解释器的输
   入行,和非前缀输出的行。实际上,Scheme	解释器使用不同的提示符。例如,Stk
   以 	STk>	来提示,并且不提示连续行。然而	Python	的惯例使输入和输出更加清晰。
Scheme	中的值。Scheme	中的值通常与	Python	对应。
布尔值
真值和假值,使用 	#t	和 	#f	来表示。Scheme	中唯一的假值(按照	Python	的含义)就
是 	#f	。
数值
这包括任意精度的整数、有理数、复数,和“不精确”(通常是浮点)数值。整数可用标准的十
进制表示,或者通过在数字之前添加 	#o	(八进制)、 	#x	(十六进制)或 	#b	(二进制),
以其他进制表示。
符号
符号是一种字符串,但是不被引号包围。有效的字符包括字母、数字和:
  !		$		%		&		*		/		:		<		=	>		?		^		_		~		+		-		.		@
在使用 	read	函数输入时,它会读取	Scheme	表达式(也是解释器用于输入程序文本的东
西),不区分符号中的大小写(在STk	实现中会转为小写)。两个带有相同表示的符号表示
同一对象(并不是两个碰巧拥有相同内容的对象)。
偶对和列表
偶对是含有两个(任意类型)成员的对象,叫做它的 	car	和 	cdr	。 	car	为 	A	且 	cdr	为 	B	的
偶对可表示为 	(A	.	B)	。偶对(就像	Python	中的元组)可以表示列表、树和任意的层次结
构。
                                                                      161
3.6	抽象语言的解释器
标准的	Scheme	列表包含空的列表值(记为 	()	),或者包含一个偶对,它的 	car	是列表第
一个元素, 	cdr	是列表的剩余部分。所以,包含整数 	1,	2,	3	的列表可表示为:
  (1	.	(2	.	(3	.	())))
列表无处不在,Scheme	允许我们将 	(a	.	())	缩略为 	(a)	,将 	(a	.	(b	...))	缩略
为 	(a	b	...)	。所以,上面的列表通常写为:
  (1	2	3)
过程(函数)
就像	Python	中一样,过程(或函数)值表示一些计算,它们可以通过向函数提供参数来调
用。过程要么是原始的,由	Scheme	的运行时系统提供,要么从	Scheme	表达式和环境构造
(就像	Python	中那样)。没有用于函数值的直接表示,但是有一些绑定到基本函数的预定义
标识符,也有一些	Scheme	表达式,在求值时会产生新的过程值。
其它类型
Scheme	也支持字符和字符串(类似	Python	的字符串,除了	Scheme	区分字符和字符串),
以及向量(就像	Python	的列表)。
程序表示。就像其它	Lisp	版本,Scheme	的数据值也用于表示程序。例如,下面的	Scheme
列表:
  (+	x	(*	10	y))
取决于如何使用,可表示为三个元素的列表(它的最后一个元素也是三个元素的列表),或
者表达为用于计算 	x+10y	的	Scheme	表达式。为了将	Scheme	值求值为程序,我们需要考虑
值的类型,并按以下步骤求值:
    整数、布尔值、字符、字符串和向量都求值为它们自己。所以,表达式 	5	求值为	5。
    纯符号看做变量。它们的值由当前被求值环境来决定,就像	Python	那样。
    非空列表以两种方式解释,取决于它们的第一个成员:
         如果第一个成员是特殊形式的符号(在下面描述),求值由这个特殊形式的规则执
         行。
         所有其他情况(叫做组合)中,列表的成员会以非特定的顺序(递归)求值。第一
         个成员必须是函数值。这个值会被调用,以列表中剩余成员的值作为参数。
    其他	Scheme	值(特别是,不是列表的偶对)在程序中是错误的。
例如:
                                                            162
3.6	抽象语言的解释器
  >>>	5														;	A	literal.
  5
  >>>	(define	x	3)			;	A	special	form	that	creates	a	binding	for	symbol
  x																			;	x.
  >>>	(+	3	(*	10	x))	;	A	combination.		Symbol	+	is	bound	to	the	primitive
  33																		;	add	function	and	*	to	primitive	multiply.
基本的特殊形式。特殊形式将东西表示为	Python	中的控制结构、函数调用或者类的定义:在
调用时,这些结构不会简单地立即求值。
首先,一些通用的结构以这种形式使用:
	EXPR-SEQ	
只是表达式的序列,例如:
  (+	3	2)	x	(*	y	z)
当它出现在下面的定义中时,它指代从左到右求值的表达式序列,序列中最后一个表达式的
值就是它的值。
	BODY	
一些结构拥有“主体”,它们是	 	EXPR-SEQ	,就像上面一样,可能由一个或多个定义处理。它们
的值就是	 	EXPR-SEQ		的值。这些定义的解释请见内部定义一节。
下面是这些特殊形式的代表性子集:
定义
定义可以出现在程序的顶层(也就是不包含在其它结构中)。
	(define	SYM	EXPR)	
求出 	EXPR	并在当前环境将其值绑定到符号 	SYM	上。
	(define	(SYM	ARGUMENTS)	BODY)	
等价于 	(define	SYM	(lambda	(ARGUMENTS)	BODY))	。
	(lambda	(ARGUMENTS)	BODY)	
求值为函数。 	ARGUMENTS	通常为(可能非空的)不同符号的列表,向函数提供参数名称,并
且表明它们的数量。 	ARGUMENTS	也可能具有如下形式:
  (sym1	sym2	...	symn	.	symr)
(也就是说,列表的末尾并不像普通列表那样是空的,最后的 	cdr	是个符号。)这种情况
下, 	symr	会绑定到列表的尾后参数值(后面的第	n+1	个参数)。
                                                                          163
3.6	抽象语言的解释器
当产生的函数被调用时, 	ARGUMENTS	在一个新的环境中绑定到形参的值上,新的环境扩展
自 	lambda	表达式求值的环境(就像	Python	那样)。之后 	BODY	会被求值,它的值会作为调
用的值返回。
	(if	COND-EXPR	TRUE-EXPR	OPTIONAL-FALSE-EXPR)	
求出 	COND-EXPR	,如果它的值不是 	#f	,那么求出 	TRUE-EXPR	,结果会作为 	if	的值。如
果 	COND-EXPR	值为 	#f	而且 	OPTIONAL-FALSE-EXPR	存在,它会被求值为并作为 	if	的值。如果
它不存在, 	if	值是未定义的。
	(set!	SYMBOL	EXPR)	
求出 	EXPR	使用该值替换 	SYMBOL	的绑定。 	SYMBOL	必须已经绑定,否则会出现错误。和
Python	的默认情况不同,它会在定义它的第一个环境帧上替换绑定,而不总是最深处的帧。
	(quote	EXPR)		或	 	'EXPR	
将	Scheme	数据结构用于程序表示的一个问题,是需要一种方式来表示打算被求值的程序文
本。 	quote	形式求值为 	EXPR	自身,而不进行进一步的求值(替代的形式使用前导的单引号,
由	Scheme	表达式读取器转换为第一种形式)。例如:
  >>>	(+	1	2)
  3
  >>>	'(+	1	2)
  (+	1	2)
  >>>	(define	x	3)
  x
  >>>	x
  3
  >>>	(quote	x)
  x
  >>>	'5
  5
  >>>	(quote	'x)
  (quote	x)
派生的特殊形式
派生结构时可以翻译为基本结构的结构。它们的目的是让程序对于读取器更加简洁可读。在
Scheme	中:
	(begin	EXPR-SEQ)	
简单地求值并产生 	EXPR-SEQ	的值。这个结构是个简单的方式,用于在需要单个表达式的上下
文中执行序列或表达式。
	(and	EXPR1	EXPR2	...)	
每个 	EXPR	从左到右执行,直到碰到了 	#f	,或遍历完 	EXPRs	。值是最后求值的 	EXPR	,如
果 	EXPRs	列表为空,那么值为 	#t	。例如:
                                                                 164
3.6	抽象语言的解释器
  >>>	(and	(=	2	2)	(>	2	1))
  #t
  >>>	(and	(<	2	2)	(>	2	1))
  #f
  >>>	(and	(=	2	2)	'(a	b))
  (a	b)
  >>>	(and)
  #t
	(or	EXPR1	EXPR2	...)	
每个 	EXPR	从左到右求值,直到碰到了不为 	#f	的值,或遍历完 	EXPRs	。值为最后求值
的 	EXPR	,如 	EXPRs	列表为空,那么值为 	#f	。例如:
  >>>	(or	(=	2	2)	(>	2	3))
  #t
  >>>	(or	(=	2	2)	'(a	b))
  #t
  >>>	(or	(>	2	2)	'(a	b))
  (a	b)
  >>>	(or	(>	2	2)	(>	2	3))
  #f
  >>>	(or)
  #f
	(cond	CLAUSE1	CLAUSE2	...)	
每个 	CLAUSEi	都依次处理,直到其中一个处理成功,它的值就是 	cond	的值。如果没有子句处
理成功,值是未定义的。每个子句都有三种可能的形式。
如果 	TEST-EXPR	求值为不为 	#f	的值, 	(TEST-EXPR	EXPR-SEQ)	形式执行成功。这种情况下,它
会求出 	EXPR-SEQ	并产生它的值。 	EXPR-SEQ	可以不写,这种情况下值为 	TEST-EXPR	本身。
最后一个子句可为 	(else	EXPR-SEQ)	的形式,它等价于 	(#t	EXPR-SEQ)	。
最后,如果 	(TEST_EXPR	=>	EXPR)	的形式在 	TEST_EXPR	求值为不为 	#f	的值(叫做 	V	)时求值
成功。如果求值成功, 	cond	结构的值是由 	(EXPR	V)	返回的值。也就是说, 	EXPR	必须求值为
单参数的函数,在 	TEST_EXPR	的值上调用。
例如:
  >>>	(cond	((>	3	2)	'greater)
  ...								((<	3	2)	'less)))
  greater
  >>>	(cond	((>	3	3)	'greater)
  ...								((<	3	3)	'less)
  ...								(else	'equal))
  equal
  >>>	(cond	((if	(<	-2	-3)	#f	-3)	=>	abs)
  ...								(else	#f))
  3
	(case	KEY-EXPR	CLAUSE1	CLAUSE2	...)	
                                                                 165
3.6	抽象语言的解释器
	KEY-EXPR	的求值会产生一个值 	K	。之后将 	K	与每个 	CLAUSEi	一次匹配,直到其中一个成
功,并且返回该子句的值。如果没有子句成功,值是未定义的。每个子句都拥
有 	((DATUM1	DATUM2	...)	EXPR-SEQ)	的形式。其中 	DATUMs	是	Scheme	值(它们不会被求
值)。如果 	K	匹配了 	DATUM	的值之一(由下面描述的 	eqv?	函数判断),子句就会求值成
功,它的 	EXPR-SEQ	就会被求值,并且它的值会作为 	case	的值。最后的子句可
为 	(else	EXPR-SEQ)	的形式,它总是会成功,例如:
  >>>	(case	(*	2	3)
  ...					((2	3	5	7)	'prime)
  ...					((1	4	6	8	9)	'composite))
  composite
  >>>	(case	(car	'(a	.	b))
  ...					((a	c)	'd)
  ...					((b	3)	'e))
  d
  >>>	(case	(car	'(c	d))
  ...				((a	e	i	o	u)	'vowel)
  ...				((w	y)	'semivowel)
  ...				(else	'consonant))
  consonant
	(let	BINDINGS	BODY)	
	BINDINGS	是偶对的列表,形式为:
  (	(VAR1	INIT1)	(VAR2	INIT2)	...)
其中 	VARs	是(不同的)符号,而 	INITs	是表达式。首先会求出 	INIT	表达式,之后创建新的
帧,将这些值绑定到 	VARs	,再然后在新环境中求出 	BODY	,返回它的值。换句话说,它等价
于调用
  ((lambda	(VAR1	VAR2	...)	BODY)
  INIT1	INIT2	...)
所以,任何 	INIT	表达式中的 	VARs	引用都指向这些符号在 	let	结构外的定义(如果存在的
话),例如:
  >>>	(let	((x	2)	(y	3))
  ...							(*	x	y))
  6
  >>>	(let	((x	2)	(y	3))
  ...							(let	((x	7)	(z	(+	x	y)))
  ...												(*	z	x)))
  35
	(let*	BINDINGS	BODY)	
	BINDINGS	的语法和 	let	相同。它等价于
                                                                   166
3.6	抽象语言的解释器
  (let	((VAR1	INIT1))
  ...
  (let	((VARn	INITn))
  BODY))
也就是说,它就像 	let	表达式那样,除了 	VAR1	的新绑定对 	INITs	子序列以及 	BODY	中可
见, 	VAR2	与之类似,例如:
  >>>	(define	x	3)
  x
  >>>	(define	y	4)
  y
  >>>	(let	((x	5)	(y	(+	x	1)))	y)
  4
  >>>	(let*	((x	5)	(y	(+	x	1)))	y)
  6
	(letrec	BINDINGS	BODY)	
同样,语法类似于 	let	。这里,首先会创建新的绑定(带有未定义的值),之后 	INITs	被求
值并赋给它们。如果某个 	INITs	使用了某个 	VAR	的值,并且没有为其赋初始值,结果是未定
义的。这个形式主要用于定义互相递归的函数(lambda	本身并不会使用它们提到过的值;这
只会在它们被调用时随后发生)。例如:
  (letrec	((even?
  						(lambda	(n)
  													(if	(zero?	n)
  																		#t
  																		(odd?	(-	n	1)))))
  					(odd?
  						(lambda	(n)
  														(if	(zero?	n)
  																		#f
  																		(even?	(-	n	1))))))
  (even?	88))
内部定义。当 	BODY	以 	define	结构的序列开始时,它们被看作“内部定义”,并且在解释上与
顶层定义有些不同。特别是,它们就像 	letrec	那样。
     首先,会为所有由 	define	语句定义的名称创建绑定,一开始绑定到未定义的值上。
     之后,值由定义来填充。
所以,内部函数定义的序列是互相递归的,就像	 	Python	中嵌套在函数中的	def`语句那样:
                                                         167
3.6	抽象语言的解释器
  >>>	(define	(hard-even?	x)					;;	An	outer-level	definition
  ...						(define	(even?	n)						;;	Inner	definition
  ...										(if	(zero?	n)
  ...														#t
  ...														(odd?	(-	n	1))))
  ...						(define	(odd?	n)							;;	Inner	definition
  ...										(if	(zero?	n)
  ...														#f
  ...														(even?	(-	n	1))))
  ...						(even?	x))
  >>>	(hard-even?	22)
  #t
预定义函数。预定义函数有很多,都在全局环境中绑定到名称上,我们只会展示一小部分。
其余的会在	Revised(4)	Scheme	报告中列出。函数调用并不是“特殊的”,因为它们都使用相
同的完全统一的求值规则:递归求出所有项目(包括运算符),并且之后在操作数的值上调
用运算符的值(它必须是个函数)。
     算数:Scheme	提供了标准的算数运算符,许多都拥有熟悉的表示,虽然它们统一出现
     在操作数前面:
      >>>	;	Semicolons	introduce	one-line	comments.
      >>>	;	Compute	(3+7+10)*(1000-8)	//	992	-	17
      >>>	(-	(quotient	(*	(+	3	7	10)	(-	1000	8)))	17)
      3
      >>>	(remainder	27	4)
      3
      >>>	(-	17)
      -17
     与之相似,存在通用的数学比较运算符,为可接受多于两个参数而扩展:
      >>>	(<	0	5)
      #t
      >>>	(>=	100	10	10	0)
      #t
      >>>	(=	21	(*	7	3)	(+	19	2))
      #t
      >>>	(not	(=	15	14))
      #t
      >>>	(zero?	(-	7	7))
      #t
     随便提一下, 	not	是个函数,并不是 	and	或 	or	的特殊形式,因为他的运算符必须求
     值,所以不需要特殊对待。
     列表和偶对。很多操作用于处理偶对和列表(它们同样由偶对和空列表构建)。
                                                              168
3.6	抽象语言的解释器
     >>>	(cons	'a	'b)
     (a	.	b)
     >>>	(list	'a	'b)
     (a	b)
     >>>	(cons	'a	(cons	'b	'()))
     (a	b)
     >>>	(car	(cons	'a	'b))
     a
     >>>	(cdr	(cons	'a	'b))
     b
     >>>	(cdr	(list	a	b))
     (b)
     >>>	(cadr	'(a	b))			;	An	abbreviation	for	(car	(cdr	'(a	b)))
     b
     >>>	(cddr	'(a	b))			;	Similarly,	an	abbreviation	for	(cdr	(cdr	'(a	b)))
     ()
     >>>	(list-tail	'(a	b	c)	0)
     (a	b	c)
     >>>	(list-tail	'(a	b	c)	1)
     (b	c)
     >>>	(list-ref	'(a	b	c)	0)
     a
     >>>	(list-ref	'(a	b	c)	2)
     c
     >>>	(append	'(a	b)	'(c	d)	'()	'(e))
     (a	b	c	d	e)
     >>>	;	All	but	the	last	list	is	copied.		The	last	is	shared,	so:
     >>>	(define	L1	(list	'a	'b	'c))
     >>>	(define	L2	(list	'd))
     >>>	(define	L3	(append	L1	L2))
     >>>	(set-car!	L1	1)
     >>>	(set-car!	L2	2)
     >>>	L3
     (a	b	c	2)
     >>>	(null?	'())
     #t
     >>>	(list?	'())
     #t
     >>>	(list?	'(a	b))
     #t
     >>>	(list?	'(a	.	b))
     #f
    相等性: 	=	运算符用于数值。通常对于值的相等性,Scheme	区分 	eq?	(就像	Python
    的 	is	), 	eqv?	(与之类似,但是和数值上的 	=	一样),和 	equal?	(比较列表结构或
    字符串的内容)。通常来说,除了在比较符号、布尔值或者空列表的情况中,我们都使
    用 	eqv?	和 	equal?	。
     >>>	(eqv?	'a	'a)
     #t
     >>>	(eqv?	'a	'b)
     #f
     >>>	(eqv?	100	(+	50	50))
     #t
     >>>	(eqv?	(list	'a	'b)	(list	'a	'b))
     #f
     >>>	(equal?	(list	'a	'b)	(list	'a	'b))
     #t
    类型。每个值的类型都只满足一个基本的类型断言。
                                                                             169
3.6	抽象语言的解释器
     >>>	(boolean?	#f)
     #t
     >>>	(integer?	3)
     #t
     >>>	(pair?	'(a	b))
     #t
     >>>	(null?	'())
     #t
     >>>	(symbol?	'a)
     #t
     >>>	(procedure?	+)
     #t
    输入和输出:Scheme	解释器通常执行“读取-求值-打印”循环,但是我们可以在程序控制
    下显式输出东西,使用与解释器内部相同的函数:
     >>>	(begin	(display	'a)	(display	'b)	(newline))
     ab
    于是, 	(display	x)	与	Python	的
     print(str(x),	end="")
    相似,并且 	(newline)	类似于 	print()	。
    对于输入来说, 	(read)	从当前“端口”读取	Scheme	表达式。它并不会解释表达式,而是
    将其读作数据:
     >>>	(read)
     >>>	(a	b	c)
     (a	b	c)
    求值。 	apply	函数提供了函数调用运算的直接访问:
     >>>	(apply	cons	'(1	2))
     (1	.	2)
     >>>	;;	Apply	the	function	f	to	the	arguments	in	L	after	g	is
     >>>	;;	applied	to	each	of	them
     >>>	(define	(compose-list	f	g	L)
     ...					(apply	f	(map	g	L)))
     >>>	(compose-list	+	(lambda	(x)	(*	x	x))	'(1	2	3))
     14
    这个扩展允许开头出现“固定”参数:
     >>>	(apply	+	1	2	'(3	4	5))
     15
    下面的函数并不在	Revised(4)	Scheme	中,但是存在于我们的解释器版本中(警告:非
    标准的过程在	Scheme	的后续版本中并不以这种形式定义):
                                                                  170
3.6	抽象语言的解释器
       >>>	(eval	'(+	1	2))
       3
    也就是说, 	eval	求解一块	Scheme	数据,它表示正确的	Scheme	表达式。这个版本在
    全局环境中求解表达式的参数。我们的解释器也提供了一种方式,来规定求值的特定环
    境:
       >>>	(define	(incr	n)	(lambda	(x)	(+	n	x)))
       >>>	(define	add5	(incr	5))
       >>>	(add5	13)
       18
       >>>	(eval	'n	(procedure-environment	add5))
       5
3.6.2	Logo	语言
Logo	是	Lisp	的另一种方言。它为教育用途而设计,所以	Logo	的许多设计决策是为了让语言
对新手更加友好。例如,多数	Logo	过程以前缀形式调用(首先是过程名称,其次是参数),
但是通用的算术运算符以普遍的中缀形式提供。Logo	的伟大之处是,它的简单亲切的语法仍
旧为高级程序员提供了惊人的表现力。
Logo	的核心概念是,它的内建容器类型,也就是	Logo	 	sentence	(也叫作列表),可以轻易
储存	Logo	源码,这也是它的强大表现力的来源。Logo	的程序可以编写和执行	Logo	表达
式,作为求值过程的一部分。许多动态语言都支持代码生成,包括	Python,但是没有语言像
Logo	一样使代码生成如此有趣和易用。
你可能希望下载完整的	Logo	解释器来体验这个语言。标准的实现是	Berkeley	Logo(也叫做
UCBLogo),由	Brian	Harvey	和他的	Berkeley	学生开发。对于苹果用户,ACSLogo	兼容
Mac	OSX	的最新版本,并带有一份介绍	Logo	语言许多特性的用户指南。
基础。Logo	设计为会话式。它的读取-求值循环的提示符是一个问号( 	?	),产生了“我下面
应该做什么?”的问题。我们自然想让它打印数值:
  ?	print	5
  5
Logo	语言使用了非标准的调用表达式语法,完全不带括号分隔符。上面,参数 	5	转给
了 	print	,它打印了它的参数。描述	Logo	程序结构的术语有些不同于	Python。Logo	拥有过
程而不是	Python	中等价的函数,而且过程输出值而不是返回值。和	python	类似, 	print	过
程总是输出 	None	,但也打印出参数的字符串表示作为副作用。(过程的参数在	Logo	中也通
常叫做输入,但是为了清晰起见,这篇文章中我们仍然称之为参数。)
                                                           171
3.6	抽象语言的解释器
Logo	中最常见的数据类型是单词,它是不带空格的字符串。单词用作可以表示数值、名称和
布尔值的通用值。可以解释为数值或布尔值的记号,比如 	5	,直接求值为单词。另一方面,
类似 	five	的名称解释为过程调用:
  ?	5
  You	do	not	say	what	to	do	with	5.
  ?	five
  I	do	not	know	how	to	five.
	5	和 	five	以不同方式解释,Logo	的读取-求值循环也以不同方式报错。第一种情况的问题
是,Logo	在顶层表达式不求值为	None	时报错。这里,我们看到了第一个	Logo	不同于计算
器的结构;前者的接口是读取-解释循环,期待用户来打印结果。后者使用更加通用的读取-求
值-打印循环,自动打印出返回值。Python	采取了混合的方式,非 	None	的值使用 	repr	强制
转换为字符串并自动打印。
Logo	的行可以顺序包含多个表达式。解释器会一次求出每个表达式。如果行中任何顶层表达
式不求值为 	None	,解释器会报错。一旦发生错误,行中其余的表达式会被忽略。
  ?	print	1	print	2
  1
  2
  ?	3	print	4
  You	do	not	say	what	to	do	with	3.
Logo	的调用表达式可以嵌套。在	Logo	的实现版本中,每个过程接受固定数量的参数。所
以,当嵌套调用表达式的操作数完整时,Logo	解释器能够唯一地判断。例如,考虑两个过
程 	sum	和 	difference	,它们相应输出两个参数的和或差。
  ?	print	sum	10	difference	7	3
  14
我们可以从这个嵌套的例子中看到,分隔调用表达式的圆括号和逗号不是必须的。在计算器
解释器中,标点符号允许我们将表达式树构建为纯粹的句法操作,没有任何运算符名称的判
断。在	Logo	中,我们必须使用我们的知识,关于每个过程接受多少参数,来得出嵌套表达式
的正确结构。下一节中,问题的细节会深入探讨。
Logo	也支持中缀运算符,例如 	+	和 	*	。这些运算符的优先级根据代数的标准规则来解析。
乘法和除法优于加法和减法:
  ?	2	+	3	*	4
  14
如何实现运算符优先级和前缀运算符来生成正确的表达式树的细节留做练习。对于下面的讨
论,我们会专注于使用前缀语法的调用表达式。
                                                    172
3.6	抽象语言的解释器
引用。一个名称会被解释为调用表达式的开始部分,但是我们也希望将单词引用为数据。以
双引号开始的记号解释为单词字面值。要注意单词字面值在	Logo	中并没有尾后的双引号。
  ?	print	"hello
  hello
在	Lisp	的方言中(而	Logo	是它的方言),任何不被求值的表达式都叫做引用。这个引用的
概念来自于事物之间的经典哲学。例如一只狗,它可以到处乱跑和叫唤,而单词“狗”只是用于
指代这种事物的语言结构。当我们以引号使用“狗”的时候,我们并不是指特定的哪一只,而是
这个单词。在语言中,引号允许我们谈论语言自身,Logo	中也一样。我们可以按照名称引
用 	sum	过程,而不会实际调用它,通过这样引用它:
  ?	print	"sum
  sum
除了单词,Logo	包含句子类型,可以叫做列表。句子由方括号包围。 	print	过程并不会打印
方括号,以维持	Logo	的惯例风格,但是方括号可以使用 	show	过程打印到输出:
  ?	print	[hello	world]
  hello	world
  ?	show	[hello	world]
  [hello	world]
句子也可以使用三个不同的二元过程来构造。 	sentence	过程将参数组装为句子。它是多态过
程,如果参数是单词,会将它的参数放入新的句子中;如果参数是句子,则会将拼接参数。
结果通常是一个句子:
  ?	show	sentence	1	2
  [1	2]
  ?	show	sentence	1	[2	3]
  [1	2	3]
  ?	show	sentence	[1	2]	3
  [1	2	3]
  ?	show	sentence	[1	2]	[3	4]
  [1	2	3	4]
	list	过程从两个元素创建句子,它允许用户创建层次数据结构:
  ?	show	list	1	2
  [1	2]
  ?	show	list	1	[2	3]
  [1	[2	3]]
  ?	show	list	[1	2]	3
  [[1	2]	3]
  ?	show	list	[1	2]	[3	4]
  [[1	2]	[3	4]]
最后, 	fput	过程从第一个元素和列表的剩余部分创建列表,就像这一章之前的	Python
	RList	构造器那样:
                                               173
3.6	抽象语言的解释器
  ?	show	fput	1	[2	3]
  [1	2	3]
  ?	show	fput	[1	2]	[3	4]
  [[1	2]	3	4]
我们在	Logo	中可以调用 	sentence	、 	list	和 	fput	句子构造器。在	Logo	中将句子解构
为 	first	和剩余部分(叫做 	butfirst	)也非常直接,所以,我们也拥有一系列句子的选择器
过程。
  ?	print	first	[1	2	3]
  1
  ?	print	last	[1	2	3]
  3
  ?	print	butfirst	[1	2	3]
  [2	3]
作为数据的表达式。句子的内容可以直接当做未求值的引用。所以,我们可以打印出	Logo	表
达式而不求值:
  ?	show	[print	sum	1	2]
  [print	sum	1	2]
将	Logo	表示表达式表示为句子的目的通常不是打印它们,而是使用 	run	过程来求值。
  ?	run	[print	sum	1	2]
  3
通过组合引用和句子构造器,以及 	run	过程,我们获得了一个非常通用的组合手段,它凭空
构建	Logo	表达式并对其求值:
  ?	run	sentence	"print	[sum	1	2]
  3
  ?	print	run	sentence	"sum	sentence	10	run	[difference	7	3]
  14
最后一个例子的要点是为了展示,虽然 	sum	和 	difference	过程在	Logo	中并不是一等的构造
器(它们不能直接放在句子中),它们的名称是一等的,并且 	run	过程可以将它们的名称解
析为所引用的过程。
将代码表示为数据,并且稍后将其解释为程序的一部分的功能,是	Lisp	风格语言的特性。程
序可以重新编写自己来执行是一个强大的概念,并且作为人工智能(AI)早期研究的基础。
Lisp	在数十年间都是	AI	研究者的首选语言。Lisp	语言由	John	McCarthy	发明,他也发明
了“人工智能”术语,并且在该领域的定义中起到关键作用。Lisp	方言的“代码即数据”的特性,
以及它们的简洁和优雅,今天仍继续吸引着	Lisp	程序员。
                                                             174
3.6	抽象语言的解释器
海龟制图(Turtle	graphics)。所有	Logo	的实现都基于	Logo	海龟	来完成图形输出。这个
海龟以画布的中点开始,基于过程移动和转向,并且在它的轨迹上画线。虽然海龟为鼓励青
少年实践编程而发明,它对于高级程序员来说也是有趣的图形化工具。
在执行	Logo	程序的任意时段,Logo	海龟都在画布上拥有位置和朝向。类似
于 	forward	和 	right	的一元过程能修改海龟的位置和朝向。常用的过程都有缩
写: 	forward	也叫作 	fd	,以及其它。下面的嵌套表达式画出了每个端点带有小星星的大星
星:
  ?	repeat	5	[fd	100	repeat	5	[fd	20	rt	144]	rt	144]
海龟过程的全部指令也内建于	Python	的 	turtle	模块中。这些函数的有限子集也在这一章的
配套项目中提供。
赋值。Logo	支持绑定名称和值。就像	Python	中那样,Logo	环境由帧的序列组成,每个帧中
的某个名称都最多绑定到一个值上。名称使用 	make	过程来绑定,它接受名称和值作为参数。
  ?	make	"x	2
任何以冒号起始的单词,例如 	:x	都叫做变量。变量求值为其名称在当前环境中绑定的值。
	make	过程和	Python	的赋值语句具有不同的作用。传递给 	make	的名称要么已经绑定了值,
要么当前未绑定。
 1.	 如果名称已经绑定, 	make	在找到它的第一帧中重新绑定该名称。
 2.	 如果没有绑定, 	make	在全局帧中绑定名称。
这个行为与	Python	赋值语句的语义很不同,后者总是在当前环境中的第一帧中绑定名称。上
面的第一条规则类似于遵循 	nonlocal	语句的	Python	赋值。第二条类似于遵循 	global	语句的
全局赋值。
过程。Logo	支持用户使用以 	to	关键字开始的定义来定义过程。定义是	Logo	中的最后一个
表达式类型,在调用表达式、基本表达式和引用表达式之后。定义的第一行提供了新过程的
名称,随后是作为变量的形参。下面的行是过程的主体,它可以跨越多行,并且必须以只包
含 	end	记号的一行结束。Logo	的读取-求值循环使用 	>	连接符来提示用户输入过程体。用户
定义过程使用 	output	过程来输出一个值。
                                                        175
3.6	抽象语言的解释器
  ?	to	double	:x
  >	output	sum	:x	:x
  >	end
  ?	print	double	4
  8
Logo	的用户定义过程所产生的调用过程和	Python	中的过程类似。在一系列参数上调用过程
以使用新的帧扩展当前环境,以及将过程的形参绑定到实参开始,之后在开始于新帧的环境
中求出过程体的代码行。
	output	的调用在	Logo	中与	Python	中的 	return	语句有相同作用:它会中止过程体的执行,
并返回一个值。Logo	过程可以通过调用 	stop	来不带任何值返回。
  ?	to	count
  >	print	1
  >	print	2
  >	stop
  >	print	3
  >	end
  ?	count
  1
  2
作用域。Logo	是动态作用域语言。类似	Python	的词法作用域语言并不允许一个函数的局部
名称影响另一个函数的求值,除非第二个函数显式定义在第一个函数内。两个顶层函数的形
参完全是隔离的。在动态作用域的语言中,没有这种隔离。当一个函数调用另一个函数时,
绑定到第一个函数局部帧的名称可在第二个函数的函数体中访问:
  ?	to	print_last_x
  >	print	:x
  >	end
  ?	to	print_x	:x
  >	print_last_x
  >	end
  ?	print_x	5
  5
虽然名称 	x	并没有在全局帧中绑定,而是在 	print_x	的局部帧中,也就是首先调用的函数。
Logo	的动态作用域规则允许函数 	print_last_x	引用 	x	,它被绑定到 	print_x	的形式参数
上。
动态作用域只需要一个对计算环境模型的简单修改就能实现。由用户函数调用创建的帧总是
扩展自当前环境(调用处)。例如,上面的 	print_x	调用引入了新的帧,它扩展自当前环
境,当前环境中包含 	print_x	的局部帧和全局帧。所以,在 	print_last_x	的主体中查找 	x	会
发现局部帧中该名称绑定到 	5	。与之相似,在	Python	的词法作用域下, 	print_last_x	的帧
只扩展自全局帧(定义处),而并不扩展自 	print_x	的局部帧(调用处)。
动态作用域语言拥有一些好处,它的过程可能不需要接受许多参数。例如, 	print_last_x	上
面的过程没有接受参数,但是它的行为仍然由内层作用域参数化。
                                                            176
3.6	抽象语言的解释器
常规编程。我们的	Logo	之旅就到此为止了。我们还没有介绍任何高级特性,例如,对象系
统、高阶过程,或者语句。学会在	Logo	中高效编程需要将语言的简单特性组合为有效的整
体。
Logo	中没有条件表达式类型。过程 	if	和 	ifelse	使用调用表达式的求值规则。 	if	的第一个
参数是个布尔单词, 	True	或者 	False	。第二个参数不是输出值,而是一个句子,包含如果第
一个参数为 	True	时需要求值的代码行。这个设计的重要结果是,第二个函数的内容如果不被
用到就不会全部求值。
  ?	1/0
  div	raised	a	ZeroDivisionError:	division	by	zero
  ?	to	reciprocal	:x
  >	if	not	:x	=	0	[output	1	/	:x]
  >	output	"infinity
  >	end
  ?	print	reciprocal	2
  0.5
  ?	print	reciprocal	0
  infinity
Logo	的条件语句不仅仅不需要特殊语法,而且它实际上可以使用 	word	和 	run	实
现。 	ifelse	的基本过程接受三个函数:布尔单词、如果单词为 	True	需要求值的句子,和如
果单词为 	False	需要求值的句子。通过适当命名形式参数,我们可以实现拥有相同行为的用
户定义过程 	ifelse2	。
  ?	to	ifelse2	:predicate	:True	:False
  >	output	run	run	word	":	:predicate
  >	end
  ?	print	ifelse2	emptyp	[]	["empty]	["full]
  empty
递归过程不需要任何特殊语法,它们可以和 	run	、 	sentence	、 	first	和 	butfirst	一起使
用,来定义句子上的通用序列操作。例如,我们可以通过构建二元句子并执行它,来在参数
上调用过程。如果参数是个单词,它必须被引用。
  ?	to	apply_fn	:fn	:arg
  >	output	run	list	:fn	ifelse	word?	:arg	[word	""	:arg]	[:arg]
  >	end
下面,我们可以定义一个过程,它在句子 	:s	上逐步映射函数 	:fn	。
  ?	to	map_fn	:fn	:s
  >	if	emptyp	:s	[output	[]]
  >	output	fput	apply_fn	:fn	first	:s	map_fn	:fn	butfirst	:s
  >	end
  ?	show	map	"double	[1	2	3]
  [2	4	6]
	map_fn	主体的第二行也可以使用圆括号编写,表明调用表达式的嵌套结构。但是,圆括号表
示了调用表达式的开始和末尾,而不是包围在操作数和非运算符周围。
                                                                177
3.6	抽象语言的解释器
  >	(output	(fput	(apply_fn	:fn	(first	:s))	(map_fn	:fn	(butfirst	:s))))
圆括号在	Logo	中并不必须,但是它们通常帮助程序员记录嵌套表达式的结构。许多	Lisp	的
方言都需要圆括号,所以就拥有了显式嵌套的语法。
作为最后一个例子,Logo	可以以非常紧凑的形式使用海龟制图来递归作图。谢尔宾斯基三角
是个分形图形,它绘制每个三角形的同时还绘制邻近的三个三角形,它们的顶点是包含它们
的三角形的边上的中点。它可以由这个	Logo	程序以有限的递归深度来绘制。
  ?	to	triangle	:exp
  >	repeat	3	[run	:exp	lt	120]
  >	end
  ?	to	sierpinski	:d	:k
  >	triangle	[ifelse	:k	=	1	[fd	:d]	[leg	:d	:k]]
  >	end
  ?	to	leg	:d	:k
  >	sierpinski	:d	/	2	:k	-	1
  >	penup	fd	:d	pendown
  >	end
	triangle	过程是个通用方法,它重复三次绘制过程,并在每个重复之后左转。 	sierpinski	过
程接受长度和递归深度。如果深度为 	1	,它画出纯三角形,否则它画出由 	log	的调用所组成
的三角形。 	leg	过程画出谢尔宾斯基递归三角型的一条边,通过递归调用 	sierpinski	填充这
条边长度的上一半,之后将海龟移动到另一个顶点上。过程 	up	和 	down	通过将笔拿起并在之
后放下,在海龟移动过程中停止画图。 	sierpinski	和 	leg	之间的多重递归产生了如下结果:
  ?	sierpinski	400	6
                                                                         178
3.6	抽象语言的解释器
3.6.3	结构
这一节描述了	Logo	解释器的通常结构。虽然这一章是独立的,它也确实引用了配套项目。完
成这个项目会从零制造出这一章描述的解释器的有效实现。
Logo	的解释器可以拥有和计算器解释器相同的结构。解析器产生表达式数据结构,它们可由
求值器来解释。求值函数检查表达式的形式,并且对于调用表达式,它在一些参数上调用函
数来应用某个过程。但是,还是存在一些结构上的不同以适应	Logo	的特殊语法。
行。Logo	解析器并不读取一行代码,而是读取可能按序包含多个表达式的整行代码。它不返
回表达式树,而是返回	Logo	句子。
解析器实际上只做微小的语法分析。特别是,解析工作并不会将调用表达式的运算符和操作
数子表达式区分为树的不同枝干。反之,调用表达式的组成部分顺序排列,嵌套调用表达式
表示为摊平的记号序列。最终,解析工作并不判断基本表达式,例如数值的类型,因为	Logo
没有丰富的类型系统。反之,每个元素都是单词或句子。
  >>>	parse_line('print	sum	10	difference	7	3')
  ['print',	'sum',	'10',	'difference',	'7',	'3']
解析器做了很微小的分析,因为	Logo	的动态特性需要求值器解析嵌套表达式的结构。
解析器并不会弄清句子的嵌套结构,句子中的句子表示为	Python	的嵌套列表。
  >>>	parse_line('print	sentence	"this	[is	a	[deep]	list]')
  ['print',	'sentence',	'"this',	['is',	'a',	['deep'],	'list']]
	parse_line	的完整实现在配套项目的 	logo_parser.py	中。
求值。Logo	一次求值一行。求值器的一个框架实现定义在配套项目的 	logo.py	中。
从 	parse_line	返回的句子传给了 	eval_line	函数,它求出行中的每个表达式。 	eval_line	函
数重复调用 	logo_eval	,它求出行中的下一个完整的表达式,直到这一行全部求值完毕,之
后返回最后一个值。 	logo_eval	函数求出单个表达式。
	logo_eval	函数求出不同形式的表达式:基本、变量、定义、引用和调用表达式,我们已经
在上一节中介绍过它们了。Logo	中多元素表达式的形式可以由检查第一个元素来判断。表达
式的每个形式都有自己的求值规则。
 1.	 基本表达式(可以解释为数值、 	True	或 	False	的单词)求值为自身。
                                                                179
3.6	抽象语言的解释器
 2.	 变量在环境中查找。环境会在下一节中详细讨论。
 3.	 定义处理为特殊情况。用户定义过程也在下一节中详细讨论。
 4.	 引用表达式求值为引用的文本,它是个去掉前导引号的字符串。句子(表示为	Python	列
     表)也看做引用,它们求值为自身。
 5.	 调用表达式在当前环境中查找运算符名称,并且调用绑定到该名称的过程。
下面是 	logo_apply	的简单实现。我们去掉了一些错误检查,以专注于我们的讨论。配套项目
中有更加健壮的实现。
  >>>	def	logo_eval(line,	env):
  								"""Evaluate	the	first	expression	in	a	line."""
  								token	=	line.pop()
  								if	isprimitive(token):
  												return	token
  								elif	isvariable(token):
  												return	env.lookup_variable(variable_name(token))
  								elif	isdefinition(token):
  												return	eval_definition(line,	env)
  								elif	isquoted(token):
  												return	text_of_quotation(token)
  								else:
  												procedure	=	env.procedures.get(token,	None)
  												return	apply_procedure(procedure,	line,	env)
上面的最后情况调用了第二个过程,表达为函数 	apply_procedure	。为了调用由运算符记号命
名的过程,这个运算符会在当前环境中查找。在上面的定义中, 	env	是 	Environment	类的实
例,会在下一节中描述。 	env.procedures	属性是个储存运算符名称和过程之间映射的字典。
在	Logo	中,环境拥有单词的这种映射,并且没有局部定义的过程。而且,Logo	为过程名称
和变量名称维护分离的映射,叫做分离的命名空间。但是,以这种方式复用名称并不推荐。
过程调用。过程调用以调用 	apply_procedure	函数开始,它被传入由 	logo_apply	查找到的函
数,并带有代码的当前行和当前环境。Logo	中过程调用的过程比计算器中的 	calc_apply	更加
通用。特别是, 	apply_procedure	必须检查打算调用的过程,以便在求解 	n	个运算符表达式
之前,判断它的参数数量 	n	。这里我们会看到,为什么	Logo	解析器不能仅仅由语法分析构
建表达式树,因为树的结构由过程决定。
	apply_procedure	函数调用 	collect_args	函数,它必须重复调用 	logo_eval	来求解行中的
下 	n	个表达式。之后,计算完过程的参数之后, 	apply_procedure	调用了 	logo_apply	,实际
上这个函数在参数上调用过程。下面的调用图示展示了这个过程。
                                                                 180
3.6	抽象语言的解释器
最终的函数	 	logo_apply	接受两种参数:基本过程和用户定义的过程,二者都是 	Procedure	的
实例。 	Procedure	是一个	Python	对象,它拥有过程的名称、参数数量、主体和形式参数作为
实例属性。 	body	属性可以拥有不同类型。基本过程在	Python	中已经实现,所以它
的 	body	就是	Python	函数。用户定义的过程(非基本)定义在	Logo	中,所以它的	 	body	就
是	Logo	代码行的列表。 	Procedure	也拥有两个布尔值属性。一个用于表明是否是基本过程,
另一个用于表明是否需要访问当前环境。
  >>>	class	Procedure():
  								def	__init__(self,	name,	arg_count,	body,	isprimitive=False,
  																					needs_env=False,	formal_params=None):
  												self.name	=	name
  												self.arg_count	=	arg_count
  												self.body	=	body
  												self.isprimitive	=	isprimitive
  												self.needs_env	=	needs_env
  												self.formal_params	=	formal_params
基本过程通过在参数列表上调用主体,并返回它的返回值作为过程输出来应用。
  >>>	def	logo_apply(proc,	args):
  								"""Apply	a	Logo	procedure	to	a	list	of	arguments."""
  								if	proc.isprimitive:
  												return	proc.body(*args)
  								else:
  												"""Apply	a	user-defined	procedure"""
用户定义过程的主体是代码行的列表,每一行都是	Logo	句子。为了在参数列表上调用过程,
我们在新的环境中求出主体的代码行。为了构造这个环境,我们向当前环境中添加新的帧,
过程的形式参数在里面绑定到实参上。这个过程的重要结构化抽象是,求出用户定义过程的
主体的代码行,需要递归调用 	eval_line	。
求值/应用递归。实现求值过程的函数, 	eval_line	和 	logo_eval	,以及实现函数应用过程的
函数, 	apply_procedure	、 	collect_args	和 	logo_apply	,是互相递归的。无论何时调用表达
式被发现,求值操作都需要调用它。应用操作使用求值来求出实参中的操作数表达式,以及
求出用户定义过程的主体。这个互相递归过程的通用结构在解释器中非常常见:求值以应用
定义,应用又使用求值定义。
                                                                       181
3.6	抽象语言的解释器
这个递归循环终止于语言的基本类型。求值的基本条件是,求解基本表达式、变量、引用表
达式或定义。函数调用的基本条件是调用基本过程。这个互相递归的结构,在处理表达式形
式的求值函数,和处理函数及其参数的应用之间,构成了求值过程的本质。
3.6.4	环境
既然我们已经描述了	Logo	解释器的结构,我们转而实现 	Environment	类,便于让它使用动态
作用域正确支持赋值、过程定义和变量查找。 	Environment	实例表示名称绑定的共有集合,可
以在程序执行期间的某一点上访问。绑定在帧中组织,而帧以	Python	字典实现。帧包含变量
的名称绑定,但不包含过程。运算符名称和 	Procedure	实例之间的绑定在	Logo	中是单独储存
的。在这个实现中,包含变量名称绑定的帧储存为字典的列表,位
于 	Environment	的 	_frames	属性中,而过程名称绑定储存在值为字典的 	procedures	属性中。
帧不能直接访问,而是通过两个 	Environment	的方
法: 	lookup_variable	和 	set_variable_value	。前者实现了一个过程,与我们在第一章的计算
环境模型中引入的查找过程相同。名称在当前环境第一帧(最新添加)中与值匹配。如果它
被找到,所绑定的值会被返回。如果没有找到,会在被当前帧扩展的帧中寻找。
	set_variable_value	也会寻找与变量名称匹配的绑定。如果找到了,它会更新为新的值,如
果没有找到,那么会在全局帧上创建新的绑定。这些方法的实现留做配套项目中的练习。
	lookup_variable	方法在求解变量名称时由 	logo_eval	调
用。 	set_variable_value	由 	logo_make	函数调用,它用作	Logo	中 	make	基本过程的主体。
                                                                   182
3.6	抽象语言的解释器
除了变量和 	make	基本过程之外,我们的解释器支持它的第一种抽象手段:将名称绑定到值
上。在	Logo	中,我们现在可以重复我们第一章中的第一种抽象步骤。
  ?	make	"radius	10
  ?	print	2	*	:radius
  20
赋值只是抽象的一种有限形式。我们已经从这门课的开始看到,即使对于不是很大的程序,
用户定义函数也是管理复杂性的关键工具。我们需要两个改进来实现	Logo	中的用户定义过
程。首先,我们必须描述 	eval_definition	的实现,如果当前行是定义, 	logo_eval	会调用这
个	Python	函数。其次,我们需要在 	logo_apply	中完成我们的描述,它在一些参数上调用用
户过程。这两个改动都需要利用上一节定义的 	Procedure	类。
定义通过创建新的 	Procedure	实例来求值,它表示用户定义的过程。考虑下面的	Logo	过程定
义:
  ?	to	factorial	:n
  >	output	ifelse	:n	=	1	[1]	[:n	*	factorial	:n	-	1]
  >	end
  ?	print	fact	5
  120
定义的第一行提供了过程的名称 	factorial	和形参 	n	。随后的一些行组成了过程体。这些行
并不会立即求值,而是为将来使用而储存。也就是说,这些行由 	eval_definition	读取并解
析,但是并不传递给 	eval_line	。主体中的行一直读取,直到出现了只包含 	end	的行。在
Logo	中, 	end	并不是需要求值的过程,也不是过程体的一部分。它是个函数定义末尾的语法
标记。
	Procedure	实例从这个过程的名称、形参列表以及主体中创建,并且在环境中
的 	procedures	的字典属性中注册。不像	Python,在	Logo	中,一旦过程绑定到一个名称,其
它定义都不能复用这个名称。
	logo_apply	将 	Procedure	实例应用于一些参数,它是表示为字符串的	Logo	值(对于单
词),或列表(对于句子)。对于用户定义过程, 	logo_apply	创建了新的帧,它是一个字典
对象,键是过程的形参,值是实参。在动态作用域语言例如	Logo	中,这个新的帧总是扩展自
过程调用处的当前环境。所以,我们将新创建的帧附加到当前环境上。之后,主体中的每一
行都依次传递给 	eval_line	。最后,在主体完成求值后,我们可以从环境中移除新创建的
帧。由于	Logo	并不支持高阶或一等过程,在程序执行期间,我们并不需要一次跟踪多于一个
环境。
下面的例子演示了帧的列表和动态作用域规则,它们由调用这两个	Logo	用户定义过程产生:
                                                         183
3.6	抽象语言的解释器
  ?	to	f	:x
  >	make	"z	sum	:x	:y
  >	end
  ?	to	g	:x	:y
  >	f	sum	:x	:x
  >	end
  ?	g	3	7
  ?	print	:z
  13
由这些表达式的求值创建的环境分为过程和帧,它们维护在分离的命名空间中。帧的顺序由
调用顺序决定。
3.6.5	数据即程序
在思考求值	Logo	表达式的程序时,一个类比可能很有帮助。程序含义的一个可取观点是,程
序是抽象机器的描述。例如,再次思考下面的计算阶乘的过程:
  ?	to	factorial	:n
  >	output	ifelse	:n	=	1	[1]	[:n	*	factorial	:n	-	1]
  >	end
我们可以在	Python	中表达为等价的程序,使用传统的表达式。
  >>>	def	factorial(n):
  								return	1	if	n	==	1	else	n	*	factorial(n	-	1)
我们可能将这个程序看做机器的描述,它包含几个部分,减法、乘法和相等性测试,并带有
两相开关和另一个阶乘机器(阶乘机器是无限的,因为它在其中包含另一个阶乘机器)。下
面的图示是一个阶乘机器的流程图,展示了这些部分是怎么组合到一起的。
                                                       184
3.6	抽象语言的解释器
与之相似,我们可以将	Logo	解释器看做非常特殊的机器,它接受机器的描述作为输入。给定
这个输入,解释器就能配置自己来模拟描述的机器。例如,如果我们向解释器中输入阶乘的
定义,解释器就可以计算阶乘。
从这个观点得出,我们的	Logo	解释器可以看做通用的机器。当输入以	Logo	程序描述时,它
就能模拟其它机器。它在由我们的编程语言操作的数据对象,和编程语言自身之间起到衔接
作用。想象一下,一个用户在我们正在运行的	Logo	解释器中输入了	Logo	表达式。从用户的
角度来看,类似 	sum	2	2	的输入表达式是编程语言中的表达式,解释器应该对其求值。但
是,从解释器的角度来看,表达式只是单词组成的句子,可以根据定义好的一系列规则来操
作它。
用户的程序是解释器的数据,这不应该是混乱的原因。实际上,有时候忽略这个差异会更方
便,以及让用户能够显式将数据对象求值为表达式。在	Logo	中,无论我们何时使用 	run	过
程,我们都使用了这种能力。Python	中也存在相似的函数: 	eval	函数会求出	Python	表达
式, 	exec	函数会求出	Python	语句,所以:
  >>>	eval('2+2')
  4
和
                                                    185
3.6	抽象语言的解释器
  >>>	2+2
  4
返回了相同的结果。求解构造为指令的一部分的表达式是动态编程语言的常见和强大的特
性。这个特性在	Logo	中十分普遍,很少语言是这样,但是在程序执行期间构造和求解表达式
的能力,对任何程序员来说都是有价值的工具。
                                          186
第四章	分布式和并行计算
第四章	分布式和并行计算
  来源:Chapter	4:	Distributed	and	Parallel	Computing
  译者:飞龙
  协议:CC	BY-NC-SA	4.0
4.1	引言
目前为止,我们专注于如何创建、解释和执行程序。在第一章中,我们学会使用函数作为组
合和抽象的手段。第二章展示了如何使用数据结构和对象来表示和操作数据,以及向我们介
绍了数据抽象的概念。在第三章中,我们学到了计算机程序如何解释和执行。结果是,我们
理解了如何设计程序,它们在单一处理器上运行。
这一章中,我们跳转到协调多个计算机和处理器的问题。首先,我们会观察分布式系统。它
们是互相连接的独立计算机,需要互相沟通来完成任务。它们可能需要协作来提供服务,共
享数据,或者甚至是储存太大而不能在一台机器上装下的数据。我们会看到,计算机可以在
分布式系统中起到不同作用,并且了解各种信息,计算机需要交换它们来共同工作。
接下来,我们会考虑并行计算。并行计算是这样,当一个小程序由多个处理器使用共享内存
执行时,所有处理器都并行工作来使任务完成得更快。并发(或并行)引入了新的挑战,并
且我们会开发新的机制来管理并发程序的复杂性。
4.2	分布式系统
分布式系统是自主的计算机网络,计算机互相通信来完成一个目标。分布式系统中的计算机
都是独立的,并且没有物理上共享的内存或处理器。它们使用消息来和其它计算机通信,消
息是网络上从一台计算机到另一台计算机传输的一段信息。消息可以用于沟通许多事情:计
算机可以让其它计算机来执行一个带有特定参数的过程,它们可以发送和接受数据包,或者
发送信号让其它计算机执行特定行为。
分布式系统中的计算机具有不同的作用。计算机的作用取决于系统的目标,以及计算机自身
的硬件和软件属性。分布式系统中,有两种主要方式来组织计算机,一种叫客户端-服务端架
构(C/S	架构),另一种叫做对等网络架构(P2P	架构)。
4.2.1	C/S	系统
                                                   187
第四章	分布式和并行计算
C/S	架构是一种从中心来源分发服务的方式。只有单个服务端提供服务,多台客户端和服务
器通信来消耗它的产出。在这个架构中,客户端和服务端都有不同的任务。服务端的任务就
是响应来自客户端的服务请求,而客户端的任务就是使用响应中提供的数据来执行一些任
务。
C/S	通信模型可以追溯到二十世纪七十年代	Unix	的引入,但这一模型由于现代万维网
(WWW)中的使用而变得具有影响力。一个C/S	交互的例子就是在线阅读纽约时报。
当 	www.nytimes.com	上的服务器与浏览器客户端(比如	Firefox)通信时,它的任务就是发送
回来纽约时报主页的	HTML。这可能涉及到基于发送给服务器的用户账户信息,计算个性化
的内容。这意味着需要展示图片,安排视觉上的内容,展示不同的颜色、字体和图形,以及
允许用户和渲染后的页面交互。
客户端和服务端的概念是强大的函数式抽象。客户端仅仅是一个提供服务的单位,可能同时
对应多个客户端。客户端是消耗服务的单位。客户端并不需要知道服务如何提供的细节,或
者所获取的数据如何储存和计算,服务端也不需要知道数据如何使用。
在网络上,我们认为客户端和服务端都是不同的机器,但是,一个机器上的系统也可以拥有
C/S	架构。例如,来自计算机输入设备的信号需要让运行在计算机上的程序来访问。这些程
序就是客户端,消耗鼠标和键盘的输入数据。操作系统的设备驱动就是服务端,接受物理的
信号并将它们提供为可用的输入。
C/S	系统的一个缺陷就是,服务端是故障单点。它是唯一能够分发服务的组件。客户端的数
量可以是任意的,它们可以交替,并且可以按需出现和消失。但是如果服务器崩溃了,整个
系统就会停止工作。所以,由	C/S	架构创建的函数式抽象也使它具有崩溃的风险。
C/S	系统的另一个缺陷是,当客户端非常多的时候,资源就变得稀缺。客户端增加系统上的
命令而不贡献任何计算资源。C/S	系统不能随着不断变化的需求缩小或扩大。
4.2.2	P2P	系统
                                                      188
第四章	分布式和并行计算
C/S	模型适合于服务导向的情形。但是,还有其它计算目标,适合使用更加平等的分工。P2P
的术语用于描述一种分布式系统,其中劳动力分布在系统的所有组件中。所有计算机发送并
接受数据,它们都贡献一些处理能力和内存。随着分布式系统的规模增长,它的资源计算能
力也会增长。在	P2P	系统中,系统的所有组件都对分布式计算贡献了一些处理能力和内存。
所有参与者的劳动力的分工是	P2P	系统的识别特征。也就是说,对等者需要能够和其它人可
靠地通信。为了确保消息到达预定的目的地,P2P	系统需要具有组织良好的网络结构。这些
系统中的组件协作来维护足够的其它组件的位置信息并将消息发送到预定的目的地。
在一些	P2P	系统中,维护网络健康的任务由一系列特殊的组件执行。这种系统并不是纯粹的
P2P	系统,因为它们具有不同类型的组件类型,提供不同的功能。支持	P2P	网络的组件就像
脚手架那样:它们有助于网络保持连接,它们维护不同计算机的位置信息,并且它们新来者
来邻居中找到位置。
P2P	系统的最常见应用就是数据传送和存储。对于数据传送,系统中的每台计算机都致力于
网络上的数据传送。如果目标计算机是特定计算机的邻居,那台计算机就一起帮助传送数
据。对于数据存储,数据集可以过于庞大,不能在任何单台计算机内装下,或者储存在单台
计算机内具有风险。每台计算机都储存数据的一小部分,不同的计算机上可能会储存相同数
据的多个副本。当一台计算机崩溃时,上面的数据可以由其它副本恢复,或者在更换替代品
之后放回。
Skype,一个音频和视频聊天服务,是采用	P2P	架构的数据传送应用的示例。当不同计算机
上的两个人都使用	Skype	交谈时,它们的通信会拆成由	1	和	0	构成的数据包,并且通过	P2P
网络传播。这个网络由电脑上注册了	Skype	的其它人组成。每台计算机都知道附近其它人的
位置。一台计算机通过将数据包传给它的邻居,来帮助将它传到目的地,它的邻居又将它传
给其它邻居,以此类推,直到数据包到达了它预定的目的地。Skype	并不是纯粹的	P2P	系
统。一个超级节点组成的脚手架网络用于用户登录和退出,维护它们的计算机的位置信息,
并且修改网络结构来处理用户进入和离开。
4.2.3	模块化
我们刚才考虑的两个架构	--	P2P	和	C/S	--	都为强制模块化而设计。模块化是一个概念,系统
的组件对其它组件来说应该是个黑盒。组件如何实现行为应该并不重要,只要它提供了一个
接口:规定了输入应该产生什么输出。
在第二章中,我们在调度函数和面向对象编程的上下文中遇到了接口。这里,接口的形式为
指定对象应接收的信息,以及对象应如何响应它们。例如,为了提供“表示为字符串”的接口,
对象必须回复 	__repr__	和 	__str__	信息,并且在响应中输出合适的字符串。那些字符串的生
成如何实现并不是接口的一部分。
在分布式系统中,我们必须考虑涉及到多台计算机的程序设计,所以我们将接口的概念从对
象和消息扩展为整个程序。接口指定了应该接受的输入,以及应该在响应中返回给输入的输
出。
                                                    189
第四章	分布式和并行计算
接口在真实世界的任何地方都存在,我们经常习以为常。一个熟悉的例子就是	TV	遥控器。你
可以买到许多牌子的遥控器或者	TV,它们都能工作。它们的唯一共同点就是“TV	遥控器”的接
口。只要当你按下电院、音量、频道或者其它任何按钮(输入)时,一块电路向你的	TV	发送
正确的信号(输出),它就遵循“TV	遥控器”接口。
模块化给予系统许多好处,并且是一种沉思熟虑的系统设计。首先,模块化的系统易于理
解。这使它易于修改和扩展。其次,如果系统中什么地方发生错误,只需要更换有错误的组
件。再者,bug	或故障可以轻易定位。如果组件的输出不符合接口的规定,而且输入是正确
的,那么这个组件就是故障来源。
4.2.4	消息传递
在分布式系统中,组件使用消息传递来互相沟通。消息有三个必要部分:发送者、接收者和
内容。发送者需要被指定,便于接受者得知哪个组件发送了信息,以及将回复发送到哪里。
接收者需要被指定,便于任何协助发送消息的计算机知道发送到哪里。消息的内容是最宝贵
的。取决于整个系统的函数,内容可以是一段数据、一个信号,或者一条指令,让远程计算
机来以一些参数求出某个函数。
消息传递的概念和第二章的消息传递机制有很大关系,其中,调度函数或字典会响应值为字
符串的信息。在程序中,发送者和接受者都由求值规则标识。但是在分布式系统中,接受者
和发送者都必须显式编码进消息中。在程序中,使用字符串来控制调度函数的行为十分方
便。在分布式系统中,消息需要经过网络发送,并且可能需要存放许多不同种类的信号作
为“数据”,所以它们并不始终编码为字符串。但是在两种情况中,消息都服务于相同的函数。
不同的组件(调度函数或计算机)交换消息来完成一个目标,它需要多个组件模块的协作。
在较高层面上,消息内容可以是复杂的数据结构,但是在较低层面上,消息只是简单的	1	和
0	的流,在网络上传输。为了变得易用,所有网络上发送的消息都需要根据一致的消息协议格
式化。
消息协议是一系列规则,用于编码和解码消息。许多消息协议规定,消息必须符合特定的格
式,其中特定的比特具有固定的含义。固定的格式实现了固定的编码和解码规则来生成和读
取这种格式。分布式系统中的所有组件都必须理解协议来互相通信。这样,它们就知道消息
的哪个部分对应哪个信息。
消息协议并不是特定的程序或软件库。反之,它们是可以由大量程序使用的规则,甚至以不
同的编程语言编写。所以,带有大量不同软件系统的计算机可以加入相同的分布式系统,只
需要遵守控制这个系统的消息协议。
4.2.5	万维网上的消息
HTTP(超文本传输协议的缩写)是万维网所支持的消息协议。它指定了在	Web	浏览器和服
务器之间交换的消息格式。所有	Web	浏览器都使用	HTTP	协议来请求服务器上的页面,而且
所有	Web	服务器都使用	HTTP	格式来发回它们的响应。
                                             190
第四章	分布式和并行计算
当你在	Web	浏览器上键入	URL	时,比如	http://en.wikipedia.org/wiki/UC_Berkeley,你实际
上就告诉了你的计算机,使用	"HTTP"	协议,从	"http://en.wikipedia.org/wiki/UC_Berkeley"
的服务器上请求	"wiki/UC_Berkeley"	页面。消息的发送者是你的计算机,接受者是
en.wikipedia.org,以及消息内容的格式是:
  GET	/wiki/UC_Berkeley	HTTP/1.1
第一个单词是请求类型,下一个单词是所请求的资源,之后是协议名称(HTTP)和版本
(1.1)。(请求还有其它类型,例如	PUT、POST	和	HEAD,Web	浏览器也会使用它
们。)
服务器发回了回复。这时,发送者是	en.wikipedia.org,接受者是你的计算机,消息内容的格
式是由数据跟随的协议头:
  HTTP/1.1	200	OK
  Date:	Mon,	23	May	2011	22:38:34	GMT
  Server:	Apache/1.3.3.7	(Unix)	(Red-Hat/Linux)
  Last-Modified:	Wed,	08	Jan	2011	23:11:55	GMT
  Content-Type:	text/html;	charset=UTF-8
  ...	web	page	content	...
第一行,单词	"200	OK"	表示没有发生错误。协议头下面的行提供了有关服务器的信息,日期
和发回的内容类型。协议头和页面的实际内容通过一个空行来分隔。
如果你键入了错误的	Web	地址,或者点击了死链,你可能会看到类似于这个错误的消息:
  404	Error	File	Not	Found
它的意思是服务器发送回了一个	HTTP	协议头,以这样起始:
  HTTP/1.1	404	Not	Found
一系列固定的响应代码是消息协议的普遍特性。协议的设计者试图预料通过协议发送的常用
消息,并且赋为固定的代码来减少传送大小,以及建立通用的消息语义。在	HTTP	协议中,
200	响应代码表示成功,而	404	表示资源没有找到的错误。其它大量响应代码也存在于
HTTP	1.1	标准中。
HTTP	是用于通信的固定格式,但是它允许传输任意的	Web	页面。其它互联网上的类似协议
是	XMPP,即时消息的常用协议,以及	FTP,用于在客户端和服务器之间下载和上传文件的
协议。
4.3	并行计算
                                                                   191
第四章	分布式和并行计算
计算机每一年都会变得越来越快。在	1965	年,英特尔联合创始人戈登·摩尔预测了计算机将
如何随时间而变得越来越快。仅仅基于五个数据点,他推测,一个芯片中的晶体管数量每两
年将翻一倍。近50年后,他的预测仍惊人地准确,现在称为摩尔定律。
尽管速度在爆炸式增长,计算机还是无法跟上可用数据的规模。根据一些估计,基因测序技
术的进步将使可用的基因序列数据比处理器变得更快的速度还要快。换句话说,对于遗传数
据,计算机变得越来越不能处理每年需要处理的问题规模,即使计算机本身变得越来越快。
为了规避对单个处理器速度的物理和机械约束,制造商正在转向另一种解决方案:多处理
器。如果两个,或三个,或更多的处理器是可用的,那么许多程序可以更快地执行。当一个
处理器在做一些计算的一个切面时,其他的可以在另一个切面工作。所有处理器都可以共享
相同的数据,但工作并行执行。
为了能够合作,多个处理器需要能够彼此共享信息。这通过使用共享内存环境来完成。该环
境中的变量、对象和数据结构对所有的进程可见。处理器在计算中的作用是执行编程语言的
求值和执行规则。在一个共享内存模型中,不同的进程可能执行不同的语句,但任何语句都
会影响共享环境。
4.3.1	共享状态的问题
多个进程之间的共享状态具有单一进程环境没有的问题。要理解其原因,让我们看看下面的
简单计算:
  x	=	5
  x	=	square(x)
  x	=	x	+	1
	x	的值是随时间变化的。起初它是	5,一段时间后它是	25,最后它是	26。在单一处理器的
环境中,没有时间依赖性的问题。 	x	的值在结束时总是	26。但是如果存在多个进程,就不能
这样说了。假设我们并行执行了上面代码的最后两行:一个处理器执行 	x	=	square(x)	而另一
个执行 	x	=	x	+	1	。每一个这些赋值语句都包含查找当前绑定到 	x	的值,然后使用新值更新
绑定。让我们假设 	x	是共享的,同一时间只有一个进程读取或写入。即使如此,读和写的顺
序可能会有所不同。例如,下面的例子显示了两个进程的每个进程的一系列步
骤, 	P1	和 	P2	。每一步都是简要描述的求值过程的一部分,随时间从上到下执行:
  P1																				P2
  read	x:	5
  																						read	x:	5
  calculate	5*5:	25					calculate	5+1:	6
  write	25	->	x
  																						write	x->	6
在这个顺序中, 	x	的最终值为	6。如果我们不协调这两个过程,我们可以得到另一个顺序的
不同结果:
                                                 192
第四章	分布式和并行计算
 P1																				P2
 																						read	x:	5
 read	x:	5													calculate	5+1:	6
 calculate	5*5:	25					write	x->6
 write	25	->	x
在这个顺序中, 	x	将是	25。事实上存在多种可能性,这取决于进程执行代码行的顺
序。 	x	的最终值可能最终为	5,25,或预期值	26。
前面的例子是无价值的。 	square(x)	和 	x	=	x	+	1	是简单快速的计算。我们强迫一条语句跑在
另一条的后面,并不会失去太多的时间。但是什么样的情况下,并行化是必不可少的?这种
情况的一个例子是银行业。在任何给定的时间,可能有成千上万的人想用他们的银行账户进
行交易:他们可能想在商店刷卡,存入支票,转帐,或支付账单。即使一个帐户在同一时间
也可能有活跃的多个交易。
让我们看看第二章的 	make_withdraw	函数,下面是修改过的版本,在更新余额之后打印而不是
返回它。我们感兴趣的是这个函数将如何并发执行。
 >>>	def	make_withdraw(balance):
 								def	withdraw(amount):
 												nonlocal	balance
 												if	amount	>	balance:
 																print('Insufficient	funds')
 												else:
 																balance	=	balance	-	amount
 																print(balance)
 								return	withdraw
现在想象一下,我们以	10	美元创建一个帐户,让我们想想,如果我们从帐户中提取太多的钱
会发生什么。如果我们顺序执行这些交易,我们会收到资金不足的消息。
 >>>	w	=	make_withdraw(10)
 >>>	w(8)
 2
 >>>	w(7)
 'Insufficient	funds'
但是,在并行中可以有许多不同的结果。下面展示了一种可能性:
 P1:	w(8)																								P2:	w(7)
 read	balance:	10
 read	amount:	8																		read	balance:	10
 8	>	10:	False																			read	amount:	7
 if	False																								7	>	10:	False
 10	-	8:	2																							if	False
 write	balance	->	2														10	-	7:	3
 read	balance:	2																	write	balance	->	3
 print	2																									read	balance:	3
 																																print	3
                                                     193
第四章	分布式和并行计算
这个特殊的例子给出了一个不正确结果	3。就好像 	w(8)	交易从来没有发生过。其他可能的结
果是	2,和 	'Insufficient	funds'	。这个问题的根源是:如果 	P2		在 	P1	写入值前读取余
额, 	P2	的状态是不一致的(反之亦然)。 	P2	所读取的余额值是过时的,因为 	P1	打算改变
它。 	P2	不知道,并且会用不一致的值覆盖它。
这个例子表明,并行化的代码不像把代码行分给多个处理器来执行那样容易。变量读写的顺
序相当重要。
一个保证执行正确性的有吸引力的方式是,两个修改共享数据的程序不能同时执行。不幸的
是,对于银行业这将意味着,一次只可以进行一个交易,因为所有的交易都修改共享数据。
直观地说,我们明白,让	2	个不同的人同时进行完全独立的帐户交易应该没有问题。不知何
故,这两个操作不互相干扰,但在同一帐户上的相同方式的同时操作就相互干扰。此外,当
进程不读取或写入时,让它们同时运行就没有问题。
4.3.2	并行计算的正确性
并行计算环境中的正确性有两个标准。第一个是,结果应该总是相同。第二个是,结果应该
和串行执行的结果一致。
第一个条件表明,我们必须避免在前面的章节中所示的变化,其中在不同的方式下的交叉读
写会产生不同的结果。例子中,我们从	10	美元的帐户取出了 	w(8)	和 	w(7)	。这个条件表
明,我们必须始终返回相同的答案,独立于 	P1	和 	P2	的指令执行顺序。无论如何,我们必须
以这样一种方式来编写我们的程序,无论他们如何相互交叉,他们应该总是产生同样的结
果。
第二个条件揭示了许多可能的结果中哪个是正确的。例子中,我们从	10	美元的帐户取出
了 	w(8)	和 	w(7)	,这个条件表明结果必须总是余额不足,而不是	2	或者	3。
当一个进程在程序的临界区影响另一个进程时,并行计算中就会出现问题。这些都是需要执
行的代码部分,它们看似是单一的指令,但实际上由较小的语句组成。一个程序会以一系列
原子硬件指令执行,由于处理器的设计,这些是不能被打断或分割为更小单元的指令。为了
在并行的情况下表现正确,程序代码的临界区需要具有原子性,保证他们不会被任何其他代
码中断。
为了强制程序临界区在并发下的原子性,需要能够在重要的时刻将进程序列化或彼此同步。
序列化意味着同一时间只运行一个进程	--	这一瞬间就好像串行执行一样。同步有两种形式。
首先是互斥,进程轮流访问一个变量。其次是条件同步,在满足条件(例如其他进程完成了
它们的任务)之前进程一直等待,之后继续执行。这样,当一个程序即将进入临界区时,其
他进程可以一直等待到它完成,然后安全地执行。
4.3.3	保护共享状态:锁和信号量
                                                             194
第四章	分布式和并行计算
在本节中讨论的所有同步和序列化方法都使用相同的基本思想。它们在共享状态中将变量用
作信号,所有过程都会理解并遵守它。这是一个相同的理念,允许分布式系统中的计算机协
同工作	--	它们通过传递消息相互协调,根据每一个参与者都理解和遵守的一个协议。
这些机制不是为了保护共享状态而出现的物理障碍。相反,他们是建立相互理解的基础上。
和出现在十字路口的各种方向的车辆能够安全通行一样,是同一种相互理解。这里没有物理
的墙壁阻止汽车相撞,只有遵守规则,红色意味着“停止”,绿色意味着“通行”。同样,没有什
么可以保护这些共享变量,除非当一个特定的信号表明轮到某个进程了,进程才会访问它
们。
锁。锁,也被称为互斥体( 	mutex	),是共享对象,常用于发射共享状态被读取或修改的信
号。不同的编程语言实现锁的方式不同,但是在	Python	中,一个进程可以调用 	acquire()	方
法来尝试获得锁的“所有权”,然后在使用完共享变量的时候调用 	release()	释放它。当进程获
得了一把锁,任何试图执行 	acquire()	操作的其他进程都会自动等待到锁被释放。这样,同
一时间只有一个进程可以获得一把锁。
对于一把保护一组特定的变量的锁,所有的进程都需要编程来遵循一个规则:一个进程不拥
有特定的锁就不能访问相应的变量。实际上,所有进程都需要在锁
的 	acquire()	和 	release()	语句之间“包装”自己对共享变量的操作。
我们可以把这个概念用于银行余额的例子中。该示例的临界区是从余额读取到写入的一组操
作。我们看到,如果一个以上的进程同时执行这个区域,问题就会发生。为了保护临界区,
我们需要使用一把锁。我们把这把锁称为 	balance_lock	(虽然我们可以命名为任何我们喜欢
的名字)。为了锁定实际保护的部分,我们必须确保试图进入这部分时调用 	acquire()	获取
锁,以及之后调用 	release()	释放锁,这样可以轮到别人。
 >>>	from	threading	import	Lock
 >>>	def	make_withdraw(balance):
 								balance_lock	=	Lock()
 								def	withdraw(amount):
 												nonlocal	balance
 												#	try	to	acquire	the	lock
 												balance_lock.acquire()
 												#	once	successful,	enter	the	critical	section
 												if	amount	>	balance:
 																print("Insufficient	funds")
 												else:
 																balance	=	balance	-	amount
 																print(balance)
 												#	upon	exiting	the	critical	section,	release	the	lock
 												balance_lock.release()
如果我们建立和之前一样的情形:
 w	=	make_withdraw(10)
现在就可以并行执行 	w(8)	和 	w(7)	了:
                                                                   195
第四章	分布式和并行计算
 P1																																		P2
 acquire	balance_lock:	ok
 read	balance:	10																				acquire	balance_lock:	wait
 read	amount:	8																						wait
 8	>	10:	False																							wait
 if	False																												wait
 10	-	8:	2																											wait
 write	balance	->	2																		wait
 read	balance:	2																					wait
 print	2																													wait
 release	balance_lock																wait
 																																				acquire	balance_lock:ok
 																																				read	balance:	2
 																																				read	amount:	7
 																																				7	>	2:	True
 																																				if	True
 																																				print	'Insufficient	funds'
 																																				release	balance_lock
我们看到了,两个进程同时进入临界区是可能的。某个进程实例获取到了 	balance_lock	,另
一个就得等待,直到那个进程退出了临界区,它才能开始执行。
要注意程序不会自己终止,除非 	P1	释放了 	balance_lock	。如果它没有释
放 	balance_lock	, 	P2	永远不可能获取它,而是一直会等待。忘记释放获得的锁是并行编程
中的一个常见错误。
信号量。信号量是用于维持有限资源访问的信号。它们和锁类似,除了它们可以允许某个限
制下的多个访问。它就像电梯一样只能够容纳几个人。一旦达到了限制,想要使用资源的进
程就必须等待。其它进程释放了信号量之后,它才可以获得。
例如,假设有许多进程需要读取中心数据库服务器的数据。如果过多的进程同时访问它,它
就会崩溃,所以限制连接数量就是个好主意。如果数据库只能同时支持 	N=2	的连接,我们就
可以以初始值 	N=2	来创建信号量。
 >>>	from	threading	import	Semaphore
 >>>	db_semaphore	=	Semaphore(2)	#	set	up	the	semaphore
 >>>	database	=	[]
 >>>	def	insert(data):
 								db_semaphore.acquire()	#	try	to	acquire	the	semaphore
 								database.append(data)		#	if	successful,	proceed
 								db_semaphore.release()	#	release	the	semaphore
 >>>	insert(7)
 >>>	insert(8)
 >>>	insert(9)
信号量的工作机制是,所有进程只在获取了信号量之后才可以访问数据库。只有 	N=2	个进程
可以获取信号量,其它的进程都需要等到其中一个进程释放了信号量,之后在访问数据库之
前尝试获取它。
                                                                196
第四章	分布式和并行计算
  P1																										P2																											P3
  acquire	db_semaphore:	ok				acquire	db_semaphore:	wait			acquire	db_semaphore:	ok
  read	data:	7																wait																									read	data:	9
  append	7	to	database								wait																									append	9	to	database
  release	db_semaphore:	ok				acquire	db_semaphore:	ok					release	db_semaphore:	ok
  																												read	data:	8
  																												append	8	to	database
  																												release	db_semaphore:	ok
值为	1	的信号量的行为和锁一样。
4.3.4	保持同步:条件变量
条件变量在并行计算由一系列步骤组成时非常有用。进程可以使用条件变量,来用信号告知
它完成了特定的步骤。之后,等待信号的其它进程就会开始它们的任务。一个需要逐步计算
的例子就是大规模向量序列的计算。在计算生物学,Web	范围的计算,和图像处理及图形学
中,常常需要处理非常大型(百万级元素)的向量和矩阵。想象下面的计算:
我们可以通过将矩阵和向量按行拆分,并把每一行分配到单独的线程上,来并行处理每一
步。作为上面的计算的一个实例,想象下面的简单值:
我们将前一半(这里是第一行)分配给一个线程,后一半(第二行)分配给另一个线程:
在伪代码中,计算是这样的:
                                                                                    197
第四章	分布式和并行计算
  def	do_step_1(index):
  		A[index]	=	B[index]	+	C[index]
  def	do_step_2(index):
  								V[index]	=	M[index]	.	A
进程	1	执行了:
  do_step_1(1)
  do_step_2(1)
进程	2	执行了:
  do_step_1(2)
  do_step_2(2)
如果允许不带同步处理,就造成下面的不一致性:
  P1																										P2
  read	B1:	2
  read	C1:	0
  calculate	2+0:	2
  write	2	->	A1															read	B2:	0
  read	M1:	(1	2)														read	C2:	5
  read	A:	(2	0)															calculate	5+0:	5
  calculate	(1	2).(2	0):	2				write	5	->	A2
  write	2	->	V1															read	M2:	(1	2)
  																												read	A:	(2	5)
  																												calculate	(1	2).(2	5):12
  																												write	12	->	V2
问题就是 	V	直到所有元素计算出来时才会计算出来。但是, 	P1	在 	A	的所有元素计算出来之
前,完成 	A	=	B+C	并且移到 	V	=	MA	。所以它与 	M	相乘时使用了 	A	的不一致的值。
我们可以使用条件变量来解决这个问题。
条件变量是表现为信号的对象,信号表示某个条件被满足。它们通常被用于协调进程,这些
进程需要在继续执行之前等待一些事情的发生。需要满足一定条件的进程可以等待一个条件
变量,直到其它进程修改了条件变量来告诉它们继续执行。
Python	中,任何数量的进程都可以使用 	condition.wait()	方法,用信号告知它们正在等待某
个条件。在调用该方法之后,它们会自动等待到其它进程调用
了 	condition.notify()	或 	condition.notifyAll()	函数。 	notify()	方法值唤醒一个进程,其它
进程仍旧等待。 	notifyAll()	方法唤醒所有等待中的进程。每个方法在不同情形中都很实用。
由于条件变量通常和决定条件是否为真的共享变量相联系,它们也提供
了 	acquire()	和 	release()	方法。这些方法应该在修改可能改变条件状态的变量时使用。任何
想要用信号告知条件已经改变的进程,必须首先使用 	acquire()	来访问它。
                                                                        198
第四章	分布式和并行计算
在我们的例子中,在执行第二步之前必须满足的条件是,两个进程都必须完成了第一步。我
们可以跟踪已经完成第一步的进程数量,以及条件是否被满足,通过引入下面两个变量:
  step1_finished	=	0
  start_step2	=	Condition()
我们在 	do_step_2	的开头插入 	start_step_2().wait()	。每个进程都会在完成步骤	1	之后自
增 	step1_finished	,但是我们只会在 	step_1_finished	=	2	时发送信号。下面的伪代码展示了
它:
  step1_finished	=	0
  start_step2	=	Condition()
  def	do_step_1(index):
  		A[index]	=	B[index]	+	C[index]
  		#	access	the	shared	state	that	determines	the	condition	status
  		start_step2.acquire()
  		step1_finished	+=	1
  		if(step1_finished	==	2):	#	if	the	condition	is	met
  								start_step2.notifyAll()	#	send	the	signal
  		#release	access	to	shared	state
  		start_step2.release()
  def	do_step_2(index):
  		#	wait	for	the	condition
  		start_step2.wait()
  		V[index]	=	M[index]	.	A
在引入条件变量之后,两个进程会一起进入步骤	2,像下面这样:
  P1																												P2
  read	B1:	2
  read	C1:	0
  calculate	2+0:	2
  write	2	->	A1																	read	B2:	0
  acquire	start_step2:	ok							read	C2:	5
  write	1	->	step1_finished					calculate	5+0:	5
  step1_finished	==	2:	false				write	5->	A2
  release	start_step2:	ok							acquire	start_step2:	ok
  start_step2:	wait													write	2->	step1_finished
  wait																										step1_finished	==	2:	true
  wait																										notifyAll	start_step_2:	ok
  start_step2:	ok															start_step2:ok
  read	M1:	(1	2)																read	M2:	(1	2)
  read	A:(2	5)
  calculate	(1	2).	(2	5):	12				read	A:(2	5)
  write	12->V1																		calculate	(1	2).	(2	5):	12
  																														write	12->V2
在进入 	do_step_2	的时候, 	P1	需要在 	start_step_2	之前等待,直到 	P2	自增
了 	step1_finished	,发现了它等于	2,之后向条件发送信号。
4.3.5	死锁
                                                                   199
第四章	分布式和并行计算
虽然同步方法对保护共享状态十分有效,但它们也带来了麻烦。因为它们会导致一个进程等
待另一个进程,这些进程就有死锁的风险。死锁是一种情形,其中两个或多个进程被卡住,
互相等待对方完成。我们已经提到了忘记释放某个锁如何导致进程无限卡住。但是即
使 	acquire()	和 	release()	调用的数量正确,程序仍然会构成死锁。
死锁的来源是循环等待,像下面展示的这样。没有进程能够继续执行,因为它们正在等待其
它进程,而其它进程也在等待它完成。
作为一个例子,我们会建立两个进程的死锁。假设有两把锁, 	x_lock	和 	y_lock	,并且它们
像这样使用:
 >>>	x_lock	=	Lock()
 >>>	y_lock	=	Lock()
 >>>	x	=	1
 >>>	y	=	0
 >>>	def	compute():
 								x_lock.acquire()
 								y_lock.acquire()
 								y	=	x	+	y
 								x	=	x	*	x
 								y_lock.release()
 								x_lock.release()
 >>>	def	anti_compute():
 								y_lock.acquire()
 								x_lock.acquire()
 								y	=	y	-	x
 								x	=	sqrt(x)
 								x_lock.release()
 								y_lock.release()
如果 	compute()	和 	anti_compute()	并行执行,并且恰好像下面这样互相交错:
 P1																										P2
 acquire	x_lock:	ok										acquire	y_lock:	ok
 acquire	y_lock:	wait								acquire	x_lock:	wait
 wait																								wait
 wait																								wait
 wait																								wait
 ...																									...
                                                    200
第四章	分布式和并行计算
所产生的情形就是死锁。 	P1	和 	P2	每个都持有一把锁,但是它们需要两把锁来执行。 	P1	正
在等待 	P2	释放 	y_lock	,而 	P2	正在等待 	P1	释放 	x_lock	。所以,没有进程能够继续执行。
                                                            201
第五章	序列和协程
第五章	序列和协程
  来源:Chapter	5:	Sequences	and	Coroutines
  译者:飞龙
  协议:CC	BY-NC-SA	4.0
5.1	引言
在这一章中,我们通过开发新的工具来处理有序数据,继续讨论真实世界中的应用。在第二
章中,我们介绍了序列接口,在	Python	内置的数据类型例如 	tuple	和 	list	中实现。序列支
持两个操作:获取长度和由下标访问元素。第三章中,我们开发了序列接口的用户定义实
现,用于表示递归列表的 	Rlist	类。序列类型具有高效的表现力,并且可以让我们高效访问
大量有序数据集。
但是,使用序列抽象表示有序数据有两个重要限制。第一个是长度为 	n	的序列的要占据比例
为 	n	的内存总数。于是,序列越长,表示它所占的内存空间就越大。
第二个限制是,序列只能表示已知且长度有限的数据集。许多我们想要表示的有序集合并没
有定义好的长度,甚至有些是无限的。两个无限序列的数学示例是正整数和斐波那契数。无
限长度的有序数据集也出现在其它计算领域,例如,所有推特状态的序列每秒都在增长,所
以并没有固定的长度。与之类似,经过基站发送出的电话呼叫序列,由计算机用户发出的鼠
标动作序列,以及飞机上的传感器产生的加速度测量值序列,都在世界演化过程中无限扩
展。
在这一章中,我们介绍了新的构造方式用于处理有序数据,它为容纳未知或无限长度的集合
而设计,但仅仅使用有限的内存。我们也会讨论这些工具如何用于一种叫做协程的程序结
构,来创建高效、模块化的数据处理流水线。
5.2	隐式序列
序列可以使用一种程序结构来表示,它不将每个元素显式储存在内存中,这是高效处理有序
数据的核心概念。为了将这个概念用于实践,我们需要构造对象来提供序列中所有元素的访
问,但是不要事先把所有元素计算出来并储存。
这个概念的一个简单示例就是第二章出现的 	range	序列类型。 	range	表示连续有界的整数序
列。但是,它的每个元素并不显式在内存中表示,当元素从 	range	中获取时,才被计算出
来。所以,我们可以表示非常大的整数范围。只有范围的结束位置才被储存为 	range	对象的
一部分,元素都被凭空计算出来。
                                                     202
第五章	序列和协程
  >>>	r	=	range(10000,	1000000000)
  >>>	r[45006230]
  45016230
这个例子中,当构造范围示例时,并不是这个范围内的所有	999,990,000	个整数都被储存。
反之,范围对象将第一个元素	10,000	与下标相加	45,006,230	来产生第	45,016,230	个元素。
计算所求的元素值并不从现有的表示中获取,这是惰性计算的一个例子。计算机科学将惰性
作为一种重要的计算工具加以赞扬。
迭代器是提供底层有序数据集的有序访问的对象。迭代器在许多编程语言中都是内建对象,
包括	Python。迭代器抽象拥有两个组成部分:一种获取底层元素序列的下一个元素的机制,
以及一种标识元素序列已经到达末尾,没有更多剩余元素的机制。在带有内建对象系统的编
程语言中,这个抽象通常相当于可以由类实现的特定接口。Python	的迭代器接口会在下一节
中描述。
迭代器的实用性来源于一个事实,底层数据序列并不能显式在内存中表达。迭代器提供了一
种机制,可以依次计算序列中的每个值,但是所有元素不需要连续储存。反之,当下个元素
从迭代器获取的时候,这个元素会按照请求计算,而不是从现有的内存来源中获取。
范围可以惰性计算序列中的元素,因为序列的表示是统一的,并且任何元素都可以轻易从范
围的起始和结束位置计算出来。迭代器支持更广泛的底层有序数据集的惰性生成,因为它们
不需要提供底层序列任意元素的访问途径。反之,它们仅仅需要按照顺序,在每次其它元素
被请求的时候,计算出序列的下一个元素。虽然不像序列可访问任意元素那样灵活(叫做随
机访问),有序数据序列的顺序访问对于数据处理应用来说已经足够了。
5.2.1	Python	迭代器
Python	迭代器接口包含两个消息。 	__next__	消息向迭代器获取所表示的底层序列的下一个元
素。为了对 	__next__	方法调用做出回应,迭代器可以执行任何计算来获取或计算底层数据序
列的下一个元素。 	__next__	的调用让迭代器产生变化:它们向前移动迭代器的位置。所以多
次调用 	__next__	会有序返回底层序列的元素。在 	__next__	的调用过程中,Python	通
过 	StopIteration	异常,来表示底层数据序列已经到达末尾。
下面的 	Letters	类迭代了从 	a	到 	d	字母的底层序列。成员变量 	current	储存了序列中的当前
字母。 	__next__	方法返回这个字母,并且使用它来计算 	current	的新值。
  >>>	class	Letters(object):
  								def	__init__(self):
  												self.current	=	'a'
  								def	__next__(self):
  												if	self.current	>	'd':
  																raise	StopIteration
  												result	=	self.current
  												self.current	=	chr(ord(result)+1)
  												return	result
  								def	__iter__(self):
  												return	self
                                                         203
第五章	序列和协程
	__iter__	消息是	Python	迭代器所需的第二个消息。它只是简单返回迭代器,它对于提供迭
代器和序列的通用接口很有用,在下一节会描述。
使用这个类,我们就可以访问序列中的字母:
  >>>	letters	=	Letters()
  >>>	letters.__next__()
  'a'
  >>>	letters.__next__()
  'b'
  >>>	letters.__next__()
  'c'
  >>>	letters.__next__()
  'd'
  >>>	letters.__next__()
  Traceback	(most	recent	call	last):
  		File	"<stdin>",	line	1,	in	<module>
  		File	"<stdin>",	line	12,	in	next
  StopIteration
	Letters	示例只能迭代一次。一旦 	__next__()	方法产生了 	StopIteration	异常,它就从此之
后一直这样了。除非创建新的实例,否则没有办法来重置它。
迭代器也允许我们表示无限序列,通过实现永远不会产生 	StopIteration	异常的 	__next__	方
法。例如,下面展示的 	Positives	类迭代了正整数的无限序列:
  >>>	class	Positives(object):
  								def	__init__(self):
  												self.current	=	0;
  								def	__next__(self):
  												result	=	self.current
  												self.current	+=	1
  												return	result
  								def	__iter__(self):
  												return	self
5.2.2	 	for	语句
Python	中,序列可以通过实现 	__iter__	消息用于迭代。如果一个对象表示有序数据,它可以
在 	for	语句中用作可迭代对象,通过回应 	__iter__	消息来返回迭代器。这个迭代器应拥
有 	__next__()	方法,依次返回序列中的每个元素,最后到达序列末尾时产
生 	StopIteration	异常。
  >>>	counts	=	[1,	2,	3]
  >>>	for	item	in	counts:
  								print(item)
  1
  2
  3
在上面的实例中, 	counts	列表返回了迭代器,作为 	__iter__()	方法调用的回应。 	for	语句
之后反复调用迭代器的 	__next__()	方法,并且每次都将返回值赋给 	item	。这个过程一直持
续,直到迭代器产生了 	StopIteration	异常,这时 	for	语句就终止了。
                                                             204
第五章	序列和协程
使用我们关于迭代器的知识,我们可以拿 	while	、赋值和 	try	语句实现 	for	语句的求值规
则:
  >>>	i	=	counts.__iter__()
  >>>	try:
  								while	True:
  												item	=	i.__next__()
  												print(item)
  				except	StopIteration:
  								pass
  1
  2
  3
在上面,调用 	counts	的 	__iter__	方法所返回的迭代器绑定到了名称 	i	上面,便于依次获取
每个元素。 	StopIteration	异常的处理子句不做任何事情,但是这个异常的处理提供了退
出 	while	循环的控制机制。
5.2.3	生成器和 	yield	语句
上面的 	Letters	和 	Positives	对象需要我们引入一种新的字段, 	self.current	,来跟踪序列
的处理过程。在上面所示的简单序列中,这可以轻易实现。但对于复杂序列, 	__next__()	很
难在计算中节省空间。生成器允许我们通过利用	Python	解释器的特性定义更复杂的迭代。
生成器是由一类特殊函数,叫做生成器函数返回的迭代器。生成器函数不同于普通的函数,
因为它不在函数体中包含 	return	语句,而是使用 	yield	语句来返回序列中的元素。
生成器不使用任何对象属性来跟踪序列的处理过程。它们控制生成器函数的执行,每
次 	__next__	方法调用时,它们执行到下一个 	yield	语句。 	Letters	迭代可以使用生成器函数
实现得更加简洁。
  >>>	def	letters_generator():
  								current	=	'a'
  								while	current	<=	'd':
  												yield	current
  												current	=	chr(ord(current)+1)
  >>>	for	letter	in	letters_generator():
  								print(letter)
  a
  b
  c
  d
即使我们永不显式定义 	__iter__()	或 	__next__()	方法,Python	会理解当我们使用 	yield	语
句时,我们打算定义生成器函数。调用时,生成器函数并不返回特定的产出值,而是返回一
个生成器(一种迭代器),它自己就可以返回产出的值。生成器对象拥
有 	__iter__	和 	__next__	方法,每个对 	__next__	的调用都会从上次停留的地方继续执行生成
器函数,直到另一个 	yield	语句执行的地方。
                                                               205
第五章	序列和协程
	__next__	第一次调用时,程序从 	letters_generator	的函数体一直执行到进入 	yield	语句。
之后,它暂停并返回 	current	值。 	yield	语句并不破坏新创建的环境,而是为之后的使用保
留了它。当 	__next__	再次调用时,执行在它停留的地方恢复。 	letters_generator	作用域
中 	current	和任何所绑定名称的值都会在随后的 	__next__	调用中保留。
我们可以通过手动调用 	__next__()	来遍历生成器:
  >>>	letters	=	letters_generator()
  >>>	type(letters)
  <class	'generator'>
  >>>	letters.__next__()
  'a'
  >>>	letters.__next__()
  'b'
  >>>	letters.__next__()
  'c'
  >>>	letters.__next__()
  'd'
  >>>	letters.__next__()
  Traceback	(most	recent	call	last):
  		File	"<stdin>",	line	1,	in	<module>
  StopIteration
在第一次 	__next__()	调用之前,生成器并不会开始执行任何生成器函数体中的语句。
5.2.4	可迭代对象
Python	中,迭代只会遍历一次底层序列的元素。在遍历之后,迭代器在 	__next__()	调用时会
产生 	StopIteration	异常。许多应用需要迭代多次元素。例如,我们需要对一个列表迭代多次
来枚举所有的元素偶对:
  >>>	def	all_pairs(s):
  								for	item1	in	s:
  												for	item2	in	s:
  																yield	(item1,	item2)
  >>>	list(all_pairs([1,	2,	3]))
  [(1,	1),	(1,	2),	(1,	3),	(2,	1),	(2,	2),	(2,	3),	(3,	1),	(3,	2),	(3,	3)]
序列本身不是迭代器,但是它是可迭代对象。Python	的可迭代接口只包含一个消
息, 	__iter__	,返回一个迭代器。Python	中内建的序列类型在 	__iter__	方法调用时,返回
迭代器的新实例。如果一个可迭代对象在每次调用 	__iter__	时返回了迭代器的新实例,那么
它就能被迭代多次。
新的可迭代类可以通过实现可迭代接口来定义。例如,下面的可迭代对象 	LetterIterable	类
在每次调用 	__iter__	时返回新的迭代器来迭代字母。
  >>>	class	LetterIterable(object):
  								def	__iter__(self):
  												current	=	'a'
  												while	current	<=	'd':
  																yield	current
  																current	=	chr(ord(current)+1)
                                                                           206
第五章	序列和协程
	__iter__	方法是个生成器函数,它返回一个生成器对象,产出从 	'a'	到 	'd'	的字母。
	Letters	迭代器对象在单次迭代之后就被“用完”了,但是 	LetterIterable	对象可被迭代多次。
所以, 	LetterIterable	示例可以用于 	all_pairs	的参数。
  >>>	letters	=	LetterIterable()
  >>>	all_pairs(letters).__next__()
  ('a',	'a')
5.2.5	流
流提供了一种隐式表示有序数据的最终方式。流是惰性计算的递归列表。就像第三章
的 	Rlist	类那样, 	Stream	实例可以响应对其第一个元素和剩余部分的获取请求。同
样, 	Stream	的剩余部分还是 	Stream	。然而不像 	RList	,流的剩余部分只在查找时被计算,
而不是事先存储。也就是说流的剩余部分是惰性计算的。
为了完成这个惰性求值,流会储存计算剩余部分的函数。无论这个函数在什么时候调用,它
的返回值都作为流的一部分,储存在叫做 	_rest	的属性中。下划线表示它不应直接访问。可
访问的属性 	rest	是个方法,它返回流的剩余部分,并在必要时计算它。使用这个设计,流可
以储存计算剩余部分的方式,而不用总是显式储存它们。
  >>>	class	Stream(object):
  								"""A	lazily	computed	recursive	list."""
  								def	__init__(self,	first,	compute_rest,	empty=False):
  												self.first	=	first
  												self._compute_rest	=	compute_rest
  												self.empty	=	empty
  												self._rest	=	None
  												self._computed	=	False
  								@property
  								def	rest(self):
  												"""Return	the	rest	of	the	stream,	computing	it	if	necessary."""
  												assert	not	self.empty,	'Empty	streams	have	no	rest.'
  												if	not	self._computed:
  																self._rest	=	self._compute_rest()
  																self._computed	=	True
  												return	self._rest
  								def	__repr__(self):
  												if	self.empty:
  																return	'<empty	stream>'
  												return	'Stream({0},	<compute_rest>)'.format(repr(self.first))
  >>>	Stream.empty	=	Stream(None,	None,	True)
递归列表可使用嵌套表达式来定义。例如,我们可以创建 	RList	,来表达 	1	和 	5	的序列,像
下面这样:
  >>>	r	=	Rlist(1,	Rlist(2+3,	Rlist.empty))
与之类似,我们可以创建一个 	Stream	来表示相同序列。 	Stream	在请求剩余部分之前,并不
会实际计算下一个元素 	5	。
                                                                              207
第五章	序列和协程
 >>>	s	=	Stream(1,	lambda:	Stream(2+3,	lambda:	Stream.empty))
这里, 	1	是流的第一个元素,后面的 	lambda	表达式是用于计算流的剩余部分的函数。被计
算的流的第二个元素又是一个返回空流的函数。
访问递归列表 	r	和流 	s	中的元素拥有相似的过程。但是, 	5	储存在了 	r	之中,而对于 	s	来
说,它在首次被请求时通过加法来按要求计算。
 >>>	r.first
 1
 >>>	s.first
 1
 >>>	r.rest.first
 5
 >>>	s.rest.first
 5
 >>>	r.rest
 Rlist(5)
 >>>	s.rest
 Stream(5,	<compute_rest>)
当 	make_integer_stream	首次被调用时,它返回了一个流,流的 	first	是序列中第一个整数
(默认为 	1	)。但是, 	make_integer_stream	实际是递归的,因为这个流的 	compute_rest	以
自增的参数再次调用了 	make_integer_stream	。这会让 	make_integer_stream	变成递归的,同时
也是惰性的。
 >>>	ints.first
 1
 >>>	ints.rest.first
 2
 >>>	ints.rest.rest
 Stream(3,	<compute_rest>)
无论何时请求整数流的 	rest	,都仅仅递归调用 	make_integer_stream	。
操作序列的相同高阶函数	--	 	map	和 	filter		--	同样可应用于流,虽然它们的实现必须修改来
惰性调用它们的参数函数。 	map_stream	在一个流上映射函数,这会产生一个新的流。局部定
义的 	compute_rest	函数确保了无论什么时候 	rest	被计算出来,这个函数都会在流的剩余部
分上映射。
 >>>	def	map_stream(fn,	s):
 								if	s.empty:
 												return	s
 								def	compute_rest():
 												return	map_stream(fn,	s.rest)
 								return	Stream(fn(s.first),	compute_rest)
流可以通过定义 	compute_rest	函数来过滤,这个函数在流的剩余部分上调用过滤器函数。如
果过滤器函数拒绝了流的第一个元素,剩余部分会立即计算出来。因为 	filter_stream	是递归
的,剩余部分可能会多次计算直到找到了有效的 	first	元素。
                                                                208
第五章	序列和协程
  >>>	def	filter_stream(fn,	s):
  								if	s.empty:
  												return	s
  								def	compute_rest():
  												return	filter_stream(fn,	s.rest)
  								if	fn(s.first):
  												return	Stream(s.first,	compute_rest)
  								return	compute_rest()
	map_stream	和 	filter_stream	展示了流式处理的常见模式:无论流的剩余部分何时被计算,
局部定义的 	compute_rest	函数都会对流的剩余部分递归调用某个处理函数。
为了观察流的内容,我们需要将其截断为有限长度,并转换为	Python	 	list	。
  >>>	def	truncate_stream(s,	k):
  								if	s.empty	or	k	==	0:
  												return	Stream.empty
  								def	compute_rest():
  												return	truncate_stream(s.rest,	k-1)
  								return	Stream(s.first,	compute_rest)
  >>>	def	stream_to_list(s):
  								r	=	[]
  								while	not	s.empty:
  												r.append(s.first)
  												s	=	s.rest
  								return	r
这些便利的函数允许我们验证 	map_stream	的实现,使用一个非常简单的例子,从 	3	到 	7	的
整数平方。
  >>>	s	=	make_integer_stream(3)
  >>>	s
  Stream(3,	<compute_rest>)
  >>>	m	=	map_stream(lambda	x:	x*x,	s)
  >>>	m
  Stream(9,	<compute_rest>)
  >>>	stream_to_list(truncate_stream(m,	5))
  [9,	16,	25,	36,	49]
我们可以使用我们的 	filter_stream	函数来定义素数流,使用埃拉托斯特尼筛法(sieve	of
Eratosthenes),它对整数流进行过滤,移除第一个元素的所有倍数数值。通过成功过滤出每
个素数,所有合数都从流中移除了。
  >>>	def	primes(pos_stream):
  								def	not_divible(x):
  												return	x	%	pos_stream.first	!=	0
  								def	compute_rest():
  												return	primes(filter_stream(not_divible,	pos_stream.rest))
  								return	Stream(pos_stream.first,	compute_rest)
通过截断 	primes	流,我们可以枚举素数的任意前缀:
                                                                         209
第五章	序列和协程
 >>>	p1	=	primes(make_integer_stream(2))
 >>>	stream_to_list(truncate_stream(p1,	7))
 [2,	3,	5,	7,	11,	13,	17]
流和迭代器不同,因为它们可以多次传递给纯函数,并且每次都产生相同的值。素数流并没
有在转换为列表之后“用完”。也就是说,在将流的前缀转换为列表之后, 	p1	的第一个元素仍
旧是 	2	。
 >>>	p1.first
 2
就像递归列表提供了序列抽象的简单实现,流提供了简单、函数式的递归数据结构,它通过
高阶函数的使用实现了惰性求值。
5.3	协程
这篇文章的大部分专注于将复杂程序解构为小型、模块化组件的技巧。当一个带有复杂行为
的函数逻辑划分为几个独立的、本身为函数的步骤时,这些函数叫做辅助函数或者子过程。
子过程由主函数调用,主函数负责协调子函数的使用。
                                            210
第五章	序列和协程
这一节中,我们使用协程,引入了一种不同的方式来解构复杂的计算。它是一种针对有序数
据的任务处理方式。就像子过程那样,协程会计算复杂计算的一小步。但是,在使用协程
时,没有主函数来协调结果。反之,协程会自发链接到一起来组成流水线。可能有一些协程
消耗输入数据,并把它发送到其它协程。也可能有一些协程,每个都对发送给它的数据执行
简单的处理步骤。最后可能有另外一些协程输出最终结果。
协程和子过程的差异是概念上的:子过程在主函数中位于下级,但是协程都是平等的,它们
协作组成流水线,不带有任何上级函数来负责以特定顺序调用它们。
这一节中,我们会学到	Python	如何通过 	yield	和 	send()	语句来支持协程的构建。之后,我
们会看到协程在流水线中的不同作用,以及协程如何支持多任务。
5.3.1	Python	协程
在之前一节中,我们介绍了生成器函数,它使用 	yield	来返回一个值。Python	的生成器函数
也可以使用 	(yield)	语句来接受一个值。生成器对象上有两个额外的方
法: 	send()	和 	close()	,创建了一个模型使对象可以消耗或产出值。定义了这些对象的生成
器函数叫做协程。
协程可以通过 	(yield)	语句来消耗值,向像下面这样:
  value	=	(yield)
使用这个语法,在带参数调用对象的 	send	方法之前,执行流会停留在这条语句上。
  coroutine.send(data)
                                                      211
第五章	序列和协程
之后,执行会恢复, 	value	会被赋为 	data	的值。为了发射计算终止的信号,我们需要使
用 	close()	方法来关闭协程。这会在协程内部产生 	GeneratorExit	异常,它可以
由 	try/except	子句来捕获。
下面的例子展示了这些概念。它是一个协程,用于打印匹配所提供的模式串的字符串。
 >>>	def	match(pattern):
 								print('Looking	for	'	+	pattern)
 								try:
 												while	True:
 																s	=	(yield)
 																if	pattern	in	s:
 																				print(s)
 								except	GeneratorExit:
 												print("===	Done	===")
我们可以使用一个模式串来初始化它,之后调用 	__next__()	来开始执行:
 >>>	m	=	match("Jabberwock")
 >>>	m.__next__()
 Looking	for	Jabberwock
对 	__next__()	的调用会执行函数体,所以 	"Looking	for	jabberwock"	会被打印。语句会一直
持续执行,直到遇到 	line	=	(yield)	语句。之后,执行会暂停,并且等待一个发送给 	m	的
值。我们可以使用 	send	来将值发送给它。
 >>>	m.send("the	Jabberwock	with	eyes	of	flame")
 the	Jabberwock	with	eyes	of	flame
 >>>	m.send("came	whiffling	through	the	tulgey	wood")
 >>>	m.send("and	burbled	as	it	came")
 >>>	m.close()
 ===	Done	===
当我们以一个值调用 	m.send	时,协程 	m	内部的求值会在 	line	=	(yield)	语句处恢复,这里
会把发送的值赋给 	line	变量。 	m	中的语句会继续求值,如果匹配的话会打印出那一行,并
继续执行循环,直到再次进入 	line	=	(yield)	。之后, 	m	中的求值会暂停,并在 	m.send	调
用后恢复。
我们可以将使用 	send()	和 	yield	的函数链到一起来完成复杂的行为。例如,下面的函数将名
为 	text	的字符串分割为单词,并把每个单词发送给另一个协程。
每个单词都发送给了绑定到 	next_coroutine	的协程,使 	next_coroutine	开始执行,而且这个
函数暂停并等待。它在 	next_coroutine	暂停之前会一直等待,随后这个函数恢复执行,发送
下一个单词或执行完毕。
如果我们将上面定义的 	match	和这个函数链到一起,我们就可以创建出一个程序,只打印出
匹配特定单词的单词。
                                                              212
第五章	序列和协程
  >>>	text	=	'Commending	spending	is	offending	to	people	pending	lending!'
  >>>	matcher	=	match('ending')
  >>>	matcher.__next__()
  Looking	for	ending
  >>>	read(text,	matcher)
  Commending
  spending
  offending
  pending
  lending!
  ===	Done	===
	read	函数向协程 	matcher	发送每个单词,协程打印出任何匹配 	pattern	的输入。
在 	matcher	协程中, 	s	=	(yield)	一行等待每个发送进来的单词,并且在执行到这一行之后将
控制流交还给 	read	。
5.3.2	生产、过滤和消耗
协程基于如何使用 	yield	和 	send()	而具有不同的作用:
     生产者创建序列中的物品,并使用 	send()	,而不是 	(yield)	。
     过滤器使用 	(yield)	来消耗物品并将结果使用 	send()	发送给下一个步骤。
     消费者使用 	(yield)	来消耗物品,但是从不发送。
上面的 	read	函数是一个生产者的例子。它不使用 	(yield)	,但是使用 	send	来生产数据。函
数 	match	是个消费者的例子。它不使用 	send	发送任何东西,但是使用 	(yield)	来消耗数据。
我们可以将 	match	拆分为过滤器和消费者。过滤器是一个协程,只发送与它的模式相匹配的
字符串。
                                                                           213
第五章	序列和协程
 >>>	def	match_filter(pattern,	next_coroutine):
 								print('Looking	for	'	+	pattern)
 								try:
 												while	True:
 																s	=	(yield)
 																if	pattern	in	s:
 																				next_coroutine.send(s)
 								except	GeneratorExit:
 												next_coroutine.close()
消费者是一个函数,只打印出发送给它的行:
 >>>	def	print_consumer():
 								print('Preparing	to	print')
 								try:
 												while	True:
 																line	=	(yield)
 																print(line)
 								except	GeneratorExit:
 												print("===	Done	===")
当过滤器或消费者被构建时,必须调用它的 	__next__	方法来开始执行:
 >>>	printer	=	print_consumer()
 >>>	printer.__next__()
 Preparing	to	print
 >>>	matcher	=	match_filter('pend',	printer)
 >>>	matcher.__next__()
 Looking	for	pend
 >>>	read(text,	matcher)
 spending
 pending
 ===	Done	===
即使名称 	filter	暗示移除元素,过滤器也可以转换元素。下面的函数是个转换元素的过滤器
的示例。它消耗字符串并发送一个字典,包含了每个不同的字母在字符串中的出现次数。
 >>>	def	count_letters(next_coroutine):
 								try:
 												while	True:
 																s	=	(yield)
 																counts	=	{letter:s.count(letter)	for	letter	in	set(s)}
 																next_coroutine.send(counts)
 								except	GeneratorExit	as	e:
 												next_coroutine.close()
我们可以使用它来计算文本中最常出现的字母,并使用一个消费者,将字典合并来找出最常
出现的键。
                                                                        214
第五章	序列和协程
  >>>	def	sum_dictionaries():
  								total	=	{}
  								try:
  												while	True:
  																counts	=	(yield)
  																for	letter,	count	in	counts.items():
  																				total[letter]	=	count	+	total.get(letter,	0)
  								except	GeneratorExit:
  												max_letter	=	max(total.items(),	key=lambda	t:	t[1])[0]
  												print("Most	frequent	letter:	"	+	max_letter)
为了在文件上运行这个流水线,我们必须首先按行读取文件。之后,将结果发送
给 	count_letters	,最后发送给 	sum_dictionaries	。我们可以服用 	read	协程来读取文件中的
行。
  >>>	s	=	sum_dictionaries()
  >>>	s.__next__()
  >>>	c	=	count_letters(s)
  >>>	c.__next__()
  >>>	read(text,	c)
  Most	frequent	letter:	n
5.3.3	多任务
生产者或过滤器并不受限于唯一的下游。它可以拥有多个协程作为它的下游,并使
用 	send()	向它们发送数据。例如,下面是 	read	的一个版本,向多个下游发送字符串中的单
词:
  >>>	def	read_to_many(text,	coroutines):
  								for	word	in	text.split():
  												for	coroutine	in	coroutines:
  																coroutine.send(word)
  								for	coroutine	in	coroutines:
  												coroutine.close()
我们可以使用它来检测多个单词中的相同文本:
  >>>	m	=	match("mend")
  >>>	m.__next__()
  Looking	for	mend
  >>>	p	=	match("pe")
  >>>	p.__next__()
  Looking	for	pe
  >>>	read_to_many(text,	[m,	p])
  Commending
  spending
  people
  pending
  ===	Done	===
  ===	Done	===
                                                                     215
第五章	序列和协程
首先, 	read_to_many	在 	m	上调用了 	send(word)	。这个协程正在等待循环中
的 	text	=	(yield)	,之后打印出所发现的匹配,并且等待下一个 	send	。之后执行流返回到
了 	read_to_many	,它向 	p	发送相同的行。所以, 	text	中的单词会按照顺序打印出来。
                                                       216
