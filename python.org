* 学一门语言？ 学语言更要学编译器
* 什么是python option?
-d      提供调试输出
-O      生成优化的字节码(生成 .pyo 文件)
-S      不导入 site 模块以在启动时查找 Python 路径
-v      冗余输出(导入语句详细追踪)
-m mod  将一个模块以脚本形式运行
-Q opt  除法选项(参阅文档)
-c cmd  运行以命令行字符串形式提交的 Python 脚本
file    从给定的文件运行 Python 脚本(参阅后文)
* 什么是python？
** 什么是Python 环境变量? 跟C中一样，就是查一些python专用的配置环境
 PYTHONPATH	PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。
 PYTHONSTARTUP 	Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此文件中变量指定的执行代码。
 PYTHONCASEOK 	加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.
 PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。
** 什么是Python 中文编码？ 可以对中文的长编码进行正确的显示
 默认编码格式是 ASCII 格式
  # -*- coding: UTF-8 -*- 或者 #coding=utf-8.
  encoding='UTF-8'
** 什么是Python (变量)?
1. List（列表）list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] list[1:2]
2. 元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )!元组不让更新
3. 字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'} 
冰箱={'苹果':3,'梨子':5,'橘子':3}
** 什么是类型 type？
** 什么是算术运算符?
   **	幂 - 返回x的y次幂	a**b 为10的20次方， 输出结果 100000000000000000000
   //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
** 什么是条件语句?
#+BEGIN_SRC python
if 判断条件：
    执行语句……
else：
    执行语句……
#+END_SRC
** 什么是循环语句?
while循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
循环控制
break
continue
** 什么是帮助
help()  dir()
** 什么是pass 语句 空语句 ，替换 为其他语言的占位符 ;
** 什么是Python 模块
*** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
import module1[, module2[,... moduleN]
*** From…import 语句
: Python的from语句让你从模块中导入一个指定的部分到当前命名空间中
*** globals()和locals()函数
: 根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
*** reload()函数
: 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
: 因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数
*** Python中的包 相当于c中的头文件
** 什么是Python 文件I/O
*** 键盘输入
**** : raw_input函数
: raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
**** : input函数
: input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回
*** 打开和关闭文件 
**** open 
**** close
**** write
**** read
**** 文件定位
**** 重命名和删除文件
**** remove()方法
*** 目录
**** mkdir()方法 
**** chdir()方法 
**** rmdir()方法 
** 什么是Python 异常处理
*** 捕捉异常可以使用try/except语句
#+BEGIN_SRC python
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** 什么是Python 的类
   class
   #+BEGIN_SRC python
   class wa:
    def __init__(self, items={}):
        '''items'''
        if type(item)!=type({}):
            raise TypeError("类型错误")
        self.items=items
        return
   #+END_SRC
*** 类
*** 类的继承
*** 类属性与方法
**** 类的私有属性
     __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
     类的方法
     在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数
**** 类的私有方法
     __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
** 什么是Python CGI编程 引入python cgi库
: CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等
*** Web服务器支持及配置

在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。

Apache 支持CGI 配置：

设置好CGI目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的HTTP服务器执行CGI程序都保存在一个预先配置的目录。这个目录被称为CGI目录，并按照惯例，它被命名为/var/www/cgi-bin目录。

CGI文件的扩展名为.cgi，python也可以使用.py扩展名。

默认情况下，Linux服务器配置运行的cgi-bin目录中为/var/www。

如果你想指定其他运行CGI脚本的目录，可以修改httpd.conf配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个CGI程序

我们使用Python创建第一个CGI程序，文件名为hello.py，文件位于/var/www/cgi-bin目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一CGI程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI环境变量
: 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。
CONTENT_LENGTH	如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。
QUERY_STRING	如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。
REMOTE_HOST	这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI脚本的完整路径
SCRIPT_NAME	CGI脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或IP地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)
** 什么是python操作mysql数据库 MySQLdb
** 什么是Python 网络编程
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
** 什么是Python 多线程
** 什么是python GUI编程(Tkinter)
** 什么是Python JSON
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
    
    pip install --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5"
* 显示对象的属性? dir()
* 显示文档字符串？   help([obj])
  没有显示注释
而__doc__方法 只返回文档字符串，文档字符串在 定义下面标记
* 对象的长度？  len(obj), 整数没有长度
* 打开文件？  open(fn, mode) 以 mode('r' = 读, 'w'= 写)方式打开一个文件名为 fn 的文件
* 读键盘？ input(str)
* 对象type? 还能判断是类 还是实例, 还可以直接用isinstance()判断
* 切片？ 相当于从 排序的东西 选择 某种间隔的东西, 符号代表反向
 #+BEGIN_SRC python
foostr = 'abcde'
foostr[::-1]
 #+END_SRC 
* and or? 没有C 中的 || 和&& 了
*  is, is not? 比较两个东西一样不一样
  N_SRC python
a  'hat', -9.3]
b 
a 
Tr
a  b
Fa
  SRC
* not? 逻辑否定
* TODO 什么是python只有双精度浮点型？ 简单了，取消了单精度，但是浮点型是
不精确的，如果想用更加精度的(精度位数多了)，可以导入 decimals, 但其实还是没算对
设置精度后可能就算对了，没想
#+BEGIN_SRC python
设置精度
  >>> from decimal import *
  >>> getcontext()
  Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
          capitals=1, flags=[], traps=[Overflow, DivisionByZero,
          InvalidOperation])

  >>> getcontext().prec = 7       # Set a new precision
#+END_SRC
* 下约进 的整除？ // 就是这个符号
* 位运算？
整算符
位                       功能 
~n                 单目运算,对数的每一位取反。结果为  要取反的数 和 结果+1 的和是0, 不知道有个屁用
nunum2             Num1 左移 num2 位 
nunum2             Num1 右移 num2 位 
nuum2              num1 与 num2 按位 与
nuum2             num1 异或 num2
nuum2             num1 与 num2 按位 或
* 比大小? cmp(num1, num2)
  n3 没有了，要导入包operator, 
  N_SRC python3
  or.lt(a, b)
op.le(a, b)
op.eq(a, b)
op.ne(a, b)
op.ge(a, b)
op.gt(a, b)
op.__lt__(a, b)
op.__le__(a, b)
op.__eq__(a, b)
op.__ne__(a, b)
op.__ge__(a, b)
op.__gt__(a, b)
  SRC
* 转换函数？
  r, base)      ==> int 
  (num)            ==> str 
  (num)            ==> str 
  (num)           ==> str
* 数据？ 能表示任何东西，不管多少
字字 类
tu列(1, 3, 4)[0]
注特别灵活
字: "AA", 'bb': "BB"}['bb'][1]
集含键，因为数据不能重复
* 中文报错？ SyntaxError: Non-ASCII character '\xe6' 
设考虑多语言  
脚加
#cgbk
#cutf-8
#-ing: UTF-8 -*- 
* 变量？ 下文处理上文的数据，怎么标示
* 范围？ range
rastart,]stop[,step]) 。起始值为 start, 结束值为 stop - 1; start
默 0, step默认值为1。
* continue? 被打断或者没意义了需要重新做
* 异常？
  N_SRC python
  
  )
exxception as e:
   Exception.message
   "hello"
  SRC
* 模块？ 人穿衣服，导入就像人穿衣服
  块，文件就是模块, 创建文件
  块 模块名.东西
  载的模块 list(sys.modules.keys())
  ys.modules.pop('modulename']
  载 sys.modules['modulename']  /或 reload(modulename)
* sys模块？ 穿的工作服，工作服有什么特点，简练，正式 import, 或者 from 模块 import 对象 或 *
*是命令行参数？ sys.argv变量
*是
*是
*是
*是
* 包？ 目录, 并且目录中有 __init__.py 文件, 然后在目录里放模块文件，
在__.py 下写 import 的模块，那么 类就归属包，模块也归属包，既然是继承，就直接包名调用
* 文件? 人的身体是实物，人也是实物
  rite close readline
  h.isfile
* 操作文件？ 模块 shutil
  hutil.move()
  
  od
  ir os.mkdirs
  ir 空目录
  .rmtree 包含子目录一起删
  lob.glob("/home/wuming/M*") 好像要绝对路径，不应该啊
* Python 函数
 #_SRC python
 dctionname( parameters ):
  _文档字符串"
  ion_suite
  n [expression]
 #RC
* lambda? 希腊文字的第十一个字母(入), 函数做参数, 用在filter中，这个函数比较难写
  N_SRC python
  r_me = [1, 2, 4, 5, 6, 8, 9]
  lt = filter(lambda x: x % 2 == 0, fiter_me)
  SRC
  句
#+SRC python
fuambda x: x % 2 == 0
re filter(func, fiter_me)

#+C

ma
#+SRC python
  =['a', 'b', 'c']
  =map(lambda x: "前缀 is %s" & x, map_me)
  result
#+C
* 列表解析？ 
* getopt 模块？
* os.fork()? 进程, 复制这程序到别的地方，就有两个东西运行
  d 是0，说明复制人在干活，不来，是本人在干活
* os.execl()? 复制人干活了，我没有了，而上面的我还在
  N_SRC python
pi.fork()
precond test"
if= 0:
  t("this is the child")
  t("i'm going to exec another program now")
  xecl("/bin/cat", 'cat', '/etc/networks')
el
  t("the child is pid %d" % pid)
os)

wa父进程什么不做，等子进程返回
  SRC
* 线程？
* 内置函数 dir(__builtins__)
* 网络库？
urllib
urlparse
httplib
ftplib
gopher
poplib  pop3服务器
imaplib imap服务器
nntplib nntp服务器
smtplib 标准邮件服务器
* pdb 调试模块
* 时间模块 
* 优化模块
* copy模块
* cmd 模块
* 
