 #+TITLE: JavaScript 简介
#+TAGS: JavaScript 
#+CATEGORIES: 语言使用
#+DESCRIPTION: JavaScript 简介
#+DATE: <2019-06-02 05:07:53>

* Javascript 
** 简介  
   #+begin_verse
   计算机语言，想象下你作为一个 *CPU* ，会怎样解释语言代码。
   面向对象的语言
   #+end_verse
   #+HTML: <!-- more -->
   
** 语言核心
*** 词法结构 
**** 字符集    
     Unicode 且区分大小写。
**** 保留字
    有些字不能作为变量名。 
*** 类型，值，变量
*** 数组
    #+begin_src js -n
      var arr = [
          {a: 1},
          [1, 2, 3],
          function() {return true;}
      ];

      arr[0] // Object {a: 1}
      arr[1] // [1, 2, 3]
      arr[2] // function (){return true;}
    #+end_src

    in 运算符,检查键名是否存在
    #+begin_src js -n
      var arr = [ 'a', 'b', 'c' ];
      2 in arr  // true
      '2' in arr // true
      4 in arr // false
    #+end_src
      
    `for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。
    #+begin_src js
      var a = [1, 2, 3];
      a.foo = true;

      for (var key in a) {
          console.log(key);
      }
    #+end_src

    forEach 
    #+begin_src js -n
      var colors = ['red', 'green', 'blue'];
      colors.forEach(function (color) {
          console.log(color);
      });
      // red
      // green
      // blue
    #+end_src
      
    delete ,会产生空位
    : 但是 length 属性不变，要注意
      
    #+begin_src js -n
      var a = [1, 2, 3];
      delete a[1];

      a[1] // undefined
      a.length // 3
    #+end_src

    push 方法
   对象转数组  
   #+begin_src js -n
     var arr = Array.prototype.slice.call(arrayLike);
     //或

     function print(value, index) {
         console.log(index + ' : ' + value);
     }

     Array.prototype.forEach.call(arrayLike, print);

   #+end_src

*** 函数
**** 声明方式 
     1. function 命令
     #+begin_src js -n
       function print(s) {
           console.log(s);
       }
     #+end_src

     2. 函数表达式
     #+begin_src js -n
       var print = function(s) {
           console.log(s);
       };
     #+end_src
     3. Function 构造函数
     #+begin_src js -n
       var add = new Function(
           'x',
           'y',
           'return x + y'
       );

       // 等同于
       function add(x, y) {
           return x + y;
       }
     #+end_src
**** 属性 
     看它的结构 ,包含者属性
       
     函数名属性 name
       
     函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
       
     函数的`toString`方法返回一个字符串，内容是函数的源码。

**** 递归 [ 每次只做一部分，循环调用自身的过程 (记得把余下的部分作参数哦)]

     #+begin_src js -n
       function fib(num) {
           if (num === 0) return 0;
           if (num === 1) return 1;
           return fib(num - 2) + fib(num - 1);
       }

       fib(6) // 8
     #+end_src
       
**** 闭包
     定义在一个函数内部的函数，就是能获取函数内部属性
     #+begin_src js -n
       function createIncrementor(start) {
           return function () {
               return start++;
           };
       }

       var inc = createIncrementor(5);

       inc() // 5
       inc() // 6
       inc() // 7
     #+end_src
       
*** Object 
    读取对象的属性
    #+begin_src js -n
      var obj = {
          p: 'Hello World'
      };

      obj.p // "Hello World"
      obj['p'] // "Hello World"
    #+end_src

    #+begin_verse
    静态方法
    返回对象的属性: keys 
    #+end_verse
      
    #+begin_verse
    实例方法
    属性的删除：delete 命令 ,继承的属性不能删 ,比如 toString
    该对象求值: valueOf 
    #+end_verse
      
** 错误处理
*** Try...Catch 
    #+BEGIN_SRC js
      var txt=""
      function message()
      {
          try
          {
              adddlert("Welcome guest!")
          }
          catch(err)
          {
              txt="此页面存在一个错误。\n\n"
              txt+="错误描述: " + err.description + "\n\n"
              txt+="点击 OK 继续。\n\n"
              alert(txt)
          }
      }
    #+END_SRC
* 标准库
** Date 
   #+BEGIN_SRC js
     日期 Date() getTime() setFullYear() toUTString getDay()
     new Date() // 当前日期和时间
     new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数
     new Date(dateString)
     new Date(year, month, day, hours, minutes, seconds, milliseconds)

     milliseconds 毫秒（0-999）1 秒=1000 毫秒
     var today = new Date()
     var d1 = new Date("October 13, 1975 11:13:00")
     var d2 = new Date(79,5,24)
     var d3 = new Date(79,5,24,11,33,0)
     设置日期
     var myDate=new Date();
     myDate.setFullYear(2010,0,14);

     设置日期为 5 天后
     var myDate=new Date();
     myDate.setDate(myDate.getDate()+5);
     getTime 获取毫秒时间
   #+END_SRC
** Number
   MAX_VALUE 
   MIN_VALUE
** Math
   #+begin_verse
   abs 绝对值
   E 自然对数
   LN2 2 的自然对数
   PI 圆周率
   Math.SQRT2 2 的平方根
   sqrt 平方根
   pow(x, y) x 的 y 次方
   max 取最大值
   min 取最小值
   ceil 上
   floor 下
   round 四舍五入
   #+end_verse
** JSON
  - 对象转字符串  JSON.stringify(arr);
  - 字符串转对象  JSON.parse(strify);
** Array
*** 数组创建[ 推介用字面量] 
    #+begin_src js -n
    var arr1 = new Array(); //创建一个空数组
    var arr2 = new Array(20); // 创建一个包含 20 项的数组
    var arr3 = new Array("lily","lucy","Tom"); // 创建一个包含 3 个字符串的数组
    #+end_src
    创建数组的第二种基本方式是使用数组字面量表示法：

    #+begin_src js -n
    var arr4 = []; //创建一个空数组
    var arr5 = [20]; // 创建一个包含 1 项的数组
    var arr6 = ["lily","lucy","Tom"]; // 创建一个包含 3 个字符串的数组
    #+end_src
    在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：

    #+begin_src js
    arr.length = arr.length-1; //将数组的最后一项删除
    #+end_src

*** 数组方法
**** Array.isArray()  [ 静态方法 ] 
     判断是否数组 
**** Array.prototype [ 静态方法 ]
    调用函数 call 
    
     #+begin_src js
     Array.prototype.join.call(['hello','world'],'----');
     #+end_src
     
     含义等于

     #+begin_src js
     ['hello','world'].join('---')
     #+end_src
     
**** join(separator) [ 实例方法 ]
     : 将数组的元素组起一个字符串，以 separator 为分隔符，省略的话则用默认用逗号为分隔符
     #+begin_src js -n
       var arr = [1,2,3];
       console.log(arr.join()); // 1,2,3
       console.log(arr.join("-")); // 1-2-3
       console.log(arr); // [1, 2, 3]（原数组不变）
     #+end_src
     
     通过 join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重
     复后的字符串，函数如下：

     #+begin_src js -n
       function repeatString(str, n) {
           return new Array(n + 1).join(str);
       }
       console.log(repeatString("abc", 3)); // abcabcabc
       console.log(repeatString("Hi", 5)); // HiHiHiHiHi
       #+end_src
     : 其实就是创建一个多一位的空数组，然后用 分隔符子串填充     
**** push()和 pop()
     #+begin_verse
     push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 
     pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。
     #+end_verse

     #+begin_src js -n
       var arr = ["Lily","lucy","Tom"];
       var count = arr.push("Jack","Sean");
       console.log(count); // 5
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]
       var item = arr.pop();
       console.log(item); // Sean
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack"]
     #+end_src
**** shift() 和 unshift()
#+begin_src js -n
     shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回 undefined。 
     unshift:将参数添加到原数组开头，并返回数组的长度 。
#+end_src

     这组方法和上面的 push()和 pop()方法正好对应，一个是操作数组的开头，一个是操
     作数组的结尾。

     #+begin_src js -n
     var arr = ["Lily","lucy","Tom"];
     var count = arr.unshift("Jack","Sean");
     console.log(count); // 5
     console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]
     var item = arr.shift();
     console.log(item); // Jack
     console.log(arr); // ["Sean", "Lily", "lucy", "Tom"]
     #+end_src
**** sort()
     #+begin_src js -n
     sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。
     在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，因此会出现以下的这种情况：
     #+end_src

     #+begin_src js -n
       var arr1 = ["a", "d", "c", "b"];
       console.log(arr1.sort()); // ["a", "b", "c", "d"]
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort()); // [13, 24, 3, 51]
       console.log(arr2); // [13, 24, 3, 51](元数组被改变)
     #+end_src
     为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个
     值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前
     则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后
     则返回一个正数。以下就是一个简单的比较函数：

     #+begin_src js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return -1;
           } else if (value1 > value2) {
               return 1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [3, 13, 24, 51]
     #+end_src
     如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：
     #+begin_src  js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return 1;
           } else if (value1 > value2) {
               return -1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [51, 24, 13, 3]
     #+end_src
**** reverse()
     reverse()：反转数组项的顺序。

     #+begin_src js -n
     var arr = [13, 24, 51, 3];
     console.log(arr.reverse()); //[3, 51, 24, 13]
     console.log(arr); //[3, 51, 24, 13](原数组改变)
     #+end_src
**** concat()
     concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

     #+begin_src js -n
     var arr = [1,3,5,7];
     var arrCopy = arr.concat(9,[11,13]);
     console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
     console.log(arr); // [1, 3, 5, 7](原数组未被修改)
     #+end_src
     从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？

     #+begin_src js -n
     var arrCopy2 = arr.concat([9,[11,13]]);
     console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
     console.log(arrCopy2[5]); //[11, 13]
     #+end_src
     上述代码中，arrCopy2 数组的第五项是一个包含两项的数组，也就是说 concat 方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到 arrCopy2 中。
**** slice()
     slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
#+begin_src js -n
     var arr = [1,3,5,7,9,11];
     var arrCopy = arr.slice(1);
     var arrCopy2 = arr.slice(1,4);
     var arrCopy3 = arr.slice(1,-2);
     var arrCopy4 = arr.slice(-4,-1);
     console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
     console.log(arrCopy); //[3, 5, 7, 9, 11]
     console.log(arrCopy2); //[3, 5, 7]
     console.log(arrCopy3); //[3, 5, 7]
     console.log(arrCopy4); //[5, 7, 9]
#+end_src
     arrCopy 只设置了一个参数，也就是起始下标为 1，所以返回的数组为下标 1（包括下标 1）开始到数组最后。 
     arrCopy2 设置了两个参数，返回起始下标（包括 1）开始到终止下标（不包括 4）的子数组。 
     arrCopy3 设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从 1 开始到 4（不包括）的子数组。 
     arrCopy4 中两个参数都是负数，所以都加上数组长度 6 转换成正数，因此相当于 slice(2,5)。
**** splice()
     splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。

     删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
     插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入 4 和 6。
     替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。
     splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。
     #+begin_src js -n
       var arr = [1,3,5,7,9,11];
       var arrRemoved = arr.splice(0,2);
       console.log(arr); //[5, 7, 9, 11]
       console.log(arrRemoved); //[1, 3]
       var arrRemoved2 = arr.splice(2,0,4,6);
       console.log(arr); // [5, 7, 4, 6, 9, 11]
       console.log(arrRemoved2); // []
       var arrRemoved3 = arr.splice(1,1,2,4);
       console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
       console.log(arrRemoved3); //[7]
#+end_src
**** indexOf()和 lastIndexOf()
#+begin_verse
     indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 
     lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。
#+end_verse

     这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

     #+begin_src js -n
     var arr = [1,3,5,7,7,5,3,1];
     console.log(arr.indexOf(5)); //2
     console.log(arr.lastIndexOf(5)); //5
     console.log(arr.indexOf(5,2)); //2
     console.log(arr.lastIndexOf(5,4)); //2
     console.log(arr.indexOf("5")); //-1
     #+end_src
**** forEach()
     forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是 function 类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。

     #+begin_src js -n 
     var arr = [1, 2, 3, 4, 5];
     arr.forEach(function(x, index, a){
     console.log(x + '|' + index + '|' + (a === arr));
     });
     // 输出为：
     // 1|0|true
     // 2|1|true
     // 3|2|true
     // 4|3|true
     // 5|4|true
     #+end_src
**** map()
#+begin_verse
     map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
#+end_verse

     下面代码利用 map 方法实现数组中每个数求平方。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.map(function(item){
     return item*item;
     });
     console.log(arr2); //[1, 4, 9, 16, 25]
#+end_src
**** filter()

     filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
#+begin_src js -n
     var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     var arr2 = arr.filter(function(x, index) {
     return index % 3 === 0 || x >= 8;
     }); 
     console.log(arr2); //[1, 4, 7, 8, 9, 10]
#+end_src
**** every()
     every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.every(function(x) {
     return x < 10;
     }); 
     console.log(arr2); //true
     var arr3 = arr.every(function(x) {
     return x < 3;
     }); 
     console.log(arr3); // false
#+end_src
**** some()

     some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.some(function(x) {
     return x < 3;
     }); 
     console.log(arr2); //true
     var arr3 = arr.some(function(x) {
     return x < 1;
     }); 
     console.log(arr3); // false
#+end_src
**** reduce()和 reduceRight()
#+begin_verse
     这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
     这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
     传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
#+end_verse

     下面代码用 reduce()实现数组求和，数组一开始加了一个初始值 10。
#+begin_src js -n
     var values = [1,2,3,4,5];
     var sum = values.reduceRight(function(prev, cur, index, array){
     return prev + cur;
     },10);
     console.log(sum); //25
#+end_src
** 定时器
   #+begin_verse
   执行一次 setTimeout
   重复执行 setInterval
   #+end_verse
   
* web 移动开发最佳实践
** 避免使用全局变量和函数
   #+begin_src js
     var myApp = {
         lang: "en",
         debug: true,
     };

     myApp.setLang = function (arg) {
         this.lang = arg;
     }
   #+end_src
** 高效的使用 try catch 语句
   #+begin_src js
     var object = ['foo', 'bar'], i;
     try {
         for (i = 0; i < object.length; i++) {
             // do something
         }
     } catch (e) {
         // handle exception
     }
   #+end_src
** 使用赋值运算来连接字符串
   #+begin_src js
     str += "x";
     str += "y";
   #+end_src
** 避免使用 eval()方法
** 使用事件委托
   在处理 DOM 事件的时候，你可以仅对一个父元素绑定一个事件而不是每一个子元素。
   这种技术即事件委托，它利用事件冒泡来分配事件处理程序，可以提高脚本的性能

   #+begin_src html
   <a href="javascript:handleClick();">Click</a>
   <button id="btn1" onclick="handleClick();">One</button>
   <button id="btn2" onclick="handleClick();">Two</button>
   #+end_src
   
   为了提高代码的性能，我们可以加一个 div 父元素，事件会向上冒泡，直到被处理。事件对象是触发事件的元素，我们可以根据它的 id 属性来判断是哪一个元素触发了事件：
 

   #+begin_src html
     <div id="btngroup">
       <button id="btn1">One</button>
       <button id="btn2">Two</button>
     </div>
   #+end_src
   #+begin_src js
     document.getElementById("btngroup").addEventListener("click", function (event) {
         switch (event.srcElement.id) {　　//firefox 下为 event.target.id
                                       case "btn1":
                                       handleClick();
                                       break;
                                       default:
                                       handleClick();
                                      }
     }, false); // type, listener, useCapture (true=beginning, false=end)
   #+end_src
** 尽量减少 DOM 操作
** 减少页面重绘
* 模块
  Javascript 不是一种模块化编程语言，在 es6 以前，它是不支持”类”（class），所以也
  就没有”模块”（module）了。
  
  ES6 标准发布后，module 成为标准，标准使用是以 export 指令导出接口，以 import
  引入模块，但是在我们一贯的 node 模块中，我们依然采用的是 CommonJS 规范，使用
  require 引入模块，使用 module.exports 导出接口。
