 #+TITLE: JavaScript 简介
#+TAGS: JavaScript 
#+CATEGORIES: 语言使用
#+DESCRIPTION: JavaScript 简介
#+DATE: <2019-06-02 05:07:53>

* Javascript 
** 简介  
   #+begin_verse
   计算机语言，想象下你作为一个 *CPU* ，会怎样解释代码文章，或者想象你觉得代码文章应该怎么写简约。
   简单来说，计算机语言就是 *行为* 与 *事物* 的的文字表达。
   #+end_verse
   #+HTML: <!-- more -->
   #+begin_quote
   对于资源文件，如音频，图片，用的是二进制文字，我们一般直接看不懂的啊，要算的。
   #+end_quote
   
** 语言核心
*** 数组
    #+begin_src js -n
      var arr = [
          {a: 1},
          [1, 2, 3],
          function() {return true;}
      ];

      arr[0] // Object {a: 1}
      arr[1] // [1, 2, 3]
      arr[2] // function (){return true;}
    #+end_src

    in 运算符,检查键名是否存在
    #+begin_src js -n
      var arr = [ 'a', 'b', 'c' ];
      2 in arr  // true
      '2' in arr // true
      4 in arr // false
    #+end_src
      
    `for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。
    #+begin_src js
      var a = [1, 2, 3];
      a.foo = true;

      for (var key in a) {
          console.log(key);
      }
    #+end_src

    forEach 
    #+begin_src js -n
      var colors = ['red', 'green', 'blue'];
      colors.forEach(function (color) {
          console.log(color);
      });
      // red
      // green
      // blue
    #+end_src
      
    delete ,会产生空位
    : 但是 length 属性不变，要注意
      
    #+begin_src js -n
      var a = [1, 2, 3];
      delete a[1];

      a[1] // undefined
      a.length // 3
    #+end_src

    push 方法
   对象转数组  
   #+begin_src js -n
     var arr = Array.prototype.slice.call(arrayLike);
     //或

     function print(value, index) {
         console.log(index + ' : ' + value);
     }

     Array.prototype.forEach.call(arrayLike, print);

   #+end_src

*** 函数
**** 声明方式 
     1. function 命令
     #+begin_src js -n
       function print(s) {
           console.log(s);
       }
     #+end_src

     2. 函数表达式
     #+begin_src js -n
       var print = function(s) {
           console.log(s);
       };
     #+end_src
     3. Function 构造函数
     #+begin_src js -n
       var add = new Function(
           'x',
           'y',
           'return x + y'
       );

       // 等同于
       function add(x, y) {
           return x + y;
       }
     #+end_src
**** 属性 
     看它的结构 ,包含者属性
       
     函数名属性 name
       
     函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
       
     函数的`toString`方法返回一个字符串，内容是函数的源码。

**** 递归 [ 每次只做一部分，循环调用自身的过程 (记得把余下的部分作参数哦)]

     #+begin_src js -n
       function fib(num) {
           if (num === 0) return 0;
           if (num === 1) return 1;
           return fib(num - 2) + fib(num - 1);
       }

       fib(6) // 8
     #+end_src
       
**** 闭包
     定义在一个函数内部的函数，就是能获取函数内部属性
     #+begin_src js -n
       function createIncrementor(start) {
           return function () {
               return start++;
           };
       }

       var inc = createIncrementor(5);

       inc() // 5
       inc() // 6
       inc() // 7
     #+end_src
       
*** Object 
    读取对象的属性
    #+begin_src js -n
      var obj = {
          p: 'Hello World'
      };

      obj.p // "Hello World"
      obj['p'] // "Hello World"
    #+end_src

    #+begin_verse
    静态方法
    返回对象的属性: keys 
    #+end_verse
      
    #+begin_verse
    实例方法
    属性的删除：delete 命令 ,继承的属性不能删 ,比如 toString
    该对象求值: valueOf 
    #+end_verse
      
** 错误处理
*** Try...Catch 
    #+BEGIN_SRC js
      var txt=""
      function message()
      {
          try
          {
              adddlert("Welcome guest!")
          }
          catch(err)
          {
              txt="此页面存在一个错误。\n\n"
              txt+="错误描述: " + err.description + "\n\n"
              txt+="点击 OK 继续。\n\n"
              alert(txt)
          }
      }
    #+END_SRC
* web 移动开发最佳实践
** 避免使用全局变量和函数
   #+begin_src js
     var myApp = {
         lang: "en",
         debug: true,
     };

     myApp.setLang = function (arg) {
         this.lang = arg;
     }
   #+end_src
** 高效的使用 try catch 语句
   #+begin_src js
     var object = ['foo', 'bar'], i;
     try {
         for (i = 0; i < object.length; i++) {
             // do something
         }
     } catch (e) {
         // handle exception
     }
   #+end_src
** 使用赋值运算来连接字符串
   #+begin_src js
     str += "x";
     str += "y";
   #+end_src
** 避免使用 eval()方法
** 使用事件委托
   在处理 DOM 事件的时候，你可以仅对一个父元素绑定一个事件而不是每一个子元素。
   这种技术即事件委托，它利用事件冒泡来分配事件处理程序，可以提高脚本的性能

   #+begin_src html
   <a href="javascript:handleClick();">Click</a>
   <button id="btn1" onclick="handleClick();">One</button>
   <button id="btn2" onclick="handleClick();">Two</button>
   #+end_src
   
   为了提高代码的性能，我们可以加一个 div 父元素，事件会向上冒泡，直到被处理。事件对象是触发事件的元素，我们可以根据它的 id 属性来判断是哪一个元素触发了事件：
 

   #+begin_src html
     <div id="btngroup">
       <button id="btn1">One</button>
       <button id="btn2">Two</button>
     </div>
   #+end_src
   #+begin_src js
     document.getElementById("btngroup").addEventListener("click", function (event) {
         switch (event.srcElement.id) {　　//firefox 下为 event.target.id
                                       case "btn1":
                                       handleClick();
                                       break;
                                       default:
                                       handleClick();
                                      }
     }, false); // type, listener, useCapture (true=beginning, false=end)
   #+end_src
** 尽量减少 DOM 操作
** 减少页面重绘
* 模块
  Javascript 不是一种模块化编程语言，在 es6 以前，它是不支持”类”（class），所以也
  就没有”模块”（module）了。
  
  ES6 标准发布后，module 成为标准，标准使用是以 export 指令导出接口，以 import
  引入模块，但是在我们一贯的 node 模块中，我们依然采用的是 CommonJS 规范，使用
  require 引入模块，使用 module.exports 导出接口。
