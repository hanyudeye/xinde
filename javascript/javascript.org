 #+TITLE: JavaScript 使用简介
#+DATE: <2019-06-02 05:07:53>
#+TAGS: JavaScript 
#+CATEGORIES: 语言使用
#+DESCRIPTION: 写点关于 JavaScript 这门语言的使用方法

* Javascript 
** 简介  
  通常是给浏览器用的 ~客户端脚本~ ，配合 CSS 用来渲染 文档树(DOM) ,现在也出了 此语言写的 ~服务端脚本~ 

  #+begin_verse
  一般称 ~前端语言~ ，[客户端] ，[浏览器端] ，怎么称呼无所谓啦!
  ~前端语言~ ，包括 ~HTML~, ~CSS~ ，他们，但现在有了很多封装的框架，顺便 ~框架语言~ 也要一并学的哦
  
  语言特点 ：开发时间短 , 功能又多 , so 有些功能的语法有点怪异 。
  #+end_verse
 
 #+HTML: <!-- more -->

 #+begin_quote
 从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。阅读本书的过程中，你会诧异于 JavaScript 语法的灵活性。

 JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如`Array`、`Date`、`Math`等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。

- 浏览器控制类：操作浏览器 (BOM)
- DOM 类：操作网页的各种元素
- Web 类：实现互联网的各种功能

如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API 等等。这些你都可以在 Node 环境中找到。
 #+end_quote



 #+begin_quote
 老道认为 JavaScript 优美的特性如下:
 1. 函数是头等对象(可以作为其他函数的参数和返回值 ，支持闭包)
 2. 基于原型继承的动态对象
 3. 对象字面量和数组字面量(构成 JSON 的基础)

  对于鸡肋和糟粕, 使用 ~JSLint~ 测试  
 1. hasOwnProperty ，老道说它糟粕的原因是因为这不是一个关键字 ，而是一个 Object。
    prototype 上可以被重写的方法。那么这个告诉我们 ，并不是不要用 hasOwnProperty
    ，而是要注意不要覆盖它。

 2. eval 的主要问题是性能 ，大量的 eval(类 eval)语句降低了 JS 引擎的性能。少量可用
 #+end_quote

: Javascript 语言的发展: 现在使用越来越广啦
: 包括 Node ，数据库操作 [NoSQL] ,移动平台开发,内嵌脚本语言 [GNOME ,Acrobat]，跨平台的桌面应用程序 [这都 独立程序了 ]
: 现代浏览器都编译执行了
** 配套工具 
*** 解析器 
    安装浏览器,用控制台 
    - 打开控制台: 按键 @@html:<kbd>@@ Ctrl  + Shift + J @@html:</kbd>@@ 
    - 换行继续打命令    @@html:<kbd>@@ Shift +  Enter @@html:</kbd>@@ 
    - 执行命令  @@html:<kbd>@@  Enter @@html:</kbd>@@
    
    或者
    - 安装 node.js 解析器
    
*** 测试工具 
** 用法
*** 简介  
    #+begin_verse
   文字化最好的方法就是自然语言啦，中国用汉语，外国用外语 
   不过汉语编程语言用的不多，一般用来写文档、注释或伪代码
    #+end_verse
   
    语句: 就是表达一句意思 ，自然语言用  ~。~ 隔开，程序语言用 ~;~ 隔开.有的语句是一块的，代表多个用处，放一块了。
    一般先要定义一个东西，然后再使用它。被定义的东西叫变量，通过给它起个名字，就可以反复访问它了，当然看你是否必要。
    还能定义函数，一样通过名字访问
    #+begin_src js -n
      //定义 a 是一个数字
      var a = 1 + 3;

      // 定义 show 是一个操作 
      function show(arr){
          console.log(arr);
      }

      //使用 show 操作  a . 计算机，你去 用 show  操作  a
      show(a);
    #+end_src
   
    复制到 浏览器的 ~Console~  ， 按回车，就可以执行了
    
*** 被操作对象 [ Javascript 解释器能直接理解的对象 ]
    其实有很多 ，简单写一些
    
    数字 [ 整数，小数 ]  用法: 直接写
    #+begin_src js -n
      //整数,默认 10 进制 
      123, 7893 ,3

      //科学技术法
      1e3  //返回 1 乘以 10 的

      //八进制表示 第一位必须是 0
      012  //返回 10

      //十六进制 
      0xA   //返回 10

      //负数，负数只能 10 进制哦
          -10,-21

      //小数
      1.2,3.323
    #+end_src
    
    
    文字，用法: 用引号引起来。不加会面临文字中空格如何表示问题。
    看不见的字前面加转义符号 ~\~
    : Javascript 认可的是两个字节的 Unicode，对于四字节字符的无法识别，会认为是两个字节。
    

    
    #+begin_src js -n 
      "我是一段话" 

      'and me'

      '这是一行包含特殊字符的一段话 \n'
    #+end_src
    
    Object [ 对象对象,包含数据和功能 ]  用法  
    #+begin_src js -n 
      var woshiduixiang = {
          name:"阿明",
          lastName:"Huang" ,

          //方法
          whatsName:function(){
              alert(this.name+" "+this.lastName);   
          },
      }
    #+end_src
     
    对象有两种读取成员的方法：点结构（`object.key`）和方括号结构（`object[key]`）。
    但是，对于数值的键名，不能使用点结构。 ~arr.0~  的写法不合法


**** 基本对象 
     Function [ 函数对象 ] 
     Boolean [ 布尔型对象 ] [ true, false]
     Symbol [ 字符串 ]
     Error
     EvalError
     InternalError
     RangeError
     ReferenceError
     SyntaxError
     TypeError
     URIError
     Infinity
     NaN
     undefined 
     null 
     literal  [ 字面量 ]
     globalThis
 
**** Numbers and dates
     Number
     Math
     Date

****  Text processing
     These objects represent strings and support manipulating them.

     String
     RegExp

****  Indexed collections
     These objects represent collections of data which are ordered by an index
     value. This includes (typed) arrays and array-like constructs.

     Array
     Int8Array
     Uint8Array
     Uint8ClampedArray
     Int16Array
     Uint16Array
     Int32Array
     Uint32Array
     Float32Array
     Float64Array

****  Keyed collections
     These objects represent collections which use keys; these contain elements
     which are iterable in the order of insertion.

     Map
     Set
     WeakMap
     WeakSet

****  Structured data
     These objects represent and interact with structured data buffers and data
     coded using JavaScript Object Notation (JSON).

     ArrayBuffer
     SharedArrayBuffer 
     Atomics 
     DataView
     JSON

*** 功能 [ 被操作对象的功能,功能与对象要配才行哦 ? 你不会拿着自行车去种地吧 ]
**** 基本操作 
***** 数字操作
      整数小数 ，更复杂的功能用 ~Math~  库
     
      #+begin_src js -n
        //加减运算
        1+3;
        3-7;
        33*3;
        3.5/2;

        //数字是否相等，小数因为存储问题最好不要直接这样判断
        3==3.0  //true
        3===3.0   //true
        0.1 + 0.2 === 0.3  //false

      #+end_src
      
      将字符串转换整数 parseInt
      #+begin_src js -n
        parseInt('12.34') // 12
        parseInt('15e2') // 15
        parseInt('abc') // NaN
        parseInt('.3') // NaN
        parseInt('0x10') // 16
        parseInt('011') // 11
        parseInt('1000', 2) // 8
        parseInt('1000', 6) // 216

      #+end_src
      
      parseFloat     
      #+begin_src js -n
        parseFloat('314e-2') // 3.14
        parseFloat('0.0314E+2') // 3.14
        parseFloat('3.14more non-digit characters') // 3.14
        parseFloat('FF2') // NaN

      #+end_src

      isNaN()
      #+begin_src js -n
        isNaN(NaN) // true
        isNaN(123) // false
      #+end_src

      isFinite(),表示某个值是否为正常的数值

      #+begin_src js -n
        isFinite(Infinity) // false
        isFinite(-Infinity) // false
      #+end_src

***** 字符串操作
      获取长度  "hello".length
      
      Base64 转码
      一种编码方法，可以将任意值转成 0～9、A～Z、a-z、`+`和`/`这 64 个字符组成的可打印字符
    
    #+begin_src js -n
      var string = 'Hello World!';
      btoa(string) // "SGVsbG8gV29ybGQh"
      atob('SGVsbG8gV29ybGQh') // "Hello World!"
    #+end_src
    : 注意，这两个方法不适合非 ASCII 码的字符，会报错。

    索引位置
    #+BEGIN_SRC js
      var s="helo world";
      var i=s.search(/wo/i);
      i: 不区分大小写
    #+END_SRC

***** 数组 [ 特殊对象]
      任何类型的数据，都可以放入数组。
      也有 length 属性

      #+begin_src js -n
        var arr = [
            {a: 1},
            [1, 2, 3],
            function() {return true;}
        ];

        arr[0] // Object {a: 1}
        arr[1] // [1, 2, 3]
        arr[2] // function (){return true;}
      #+end_src

      in 运算符,检查键名是否存在
      #+begin_src js -n
        var arr = [ 'a', 'b', 'c' ];
        2 in arr  // true
        '2' in arr // true
        4 in arr // false
      #+end_src
      
      for...in 循环和数组的遍历
      `for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。

      #+begin_src js
        var a = [1, 2, 3];
        a.foo = true;

        for (var key in a) {
            console.log(key);
        }
        // 0
        // 1
        // 2
        // foo
      #+end_src

      forEach ,内部行为好像
      #+begin_src js -n
        var colors = ['red', 'green', 'blue'];
        colors.forEach(function (color) {
            console.log(color);
        });
        // red
        // green
        // blue
      #+end_src
      
      delete ,会产生空位
      : 但是 length 属性不变，要注意
      
      #+begin_src js -n
        var a = [1, 2, 3];
        delete a[1];

        a[1] // undefined
        a.length // 3
      #+end_src

      push 方法
     对象转数组  
     #+begin_src js -n
       var arr = Array.prototype.slice.call(arrayLike);
       //或

       function print(value, index) {
           console.log(index + ' : ' + value);
       }

       Array.prototype.forEach.call(arrayLike, print);

     #+end_src

***** 函数 [ 具有执行功能的变量 ] [ 其他变量存值,它存方法 ]
****** 声明方式 
       1. function 命令
       #+begin_src js -n
         function print(s) {
             console.log(s);
         }
       #+end_src

       2. 函数表达式
       #+begin_src js -n
         var print = function(s) {
             console.log(s);
         };
       #+end_src
       3. Function 构造函数
       #+begin_src js -n
         var add = new Function(
             'x',
             'y',
             'return x + y'
         );

         // 等同于
         function add(x, y) {
             return x + y;
         }
       #+end_src
****** 属性 
       看它的结构 ,包含者属性
       
       函数名属性 name
       
       函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
       
       函数的`toString`方法返回一个字符串，内容是函数的源码。

****** 递归 [ 每次只做一部分，循环调用自身的过程 (记得把余下的部分作参数哦)]

       #+begin_src js -n
         function fib(num) {
             if (num === 0) return 0;
             if (num === 1) return 1;
             return fib(num - 2) + fib(num - 1);
         }

         fib(6) // 8
       #+end_src
       
****** 闭包
       定义在一个函数内部的函数，就是能获取函数内部属性
       #+begin_src js -n
         function createIncrementor(start) {
             return function () {
                 return start++;
             };
         }

         var inc = createIncrementor(5);

         inc() // 5
         inc() // 6
         inc() // 7
       #+end_src
       
***** Object 
      读取对象的属性
      #+begin_src js -n
        var obj = {
            p: 'Hello World'
        };

        obj.p // "Hello World"
        obj['p'] // "Hello World"
      #+end_src

      #+begin_verse
      静态方法
      返回对象的属性: keys 
      #+end_verse
      
      #+begin_verse
      实例方法
      属性的删除：delete 命令 ,继承的属性不能删 ,比如 toString
      该对象求值: valueOf 
      #+end_verse
      
**** 流程控制 [ 条件语句 ，满足条件才做事情  ]
***** if - else  结构  
      #+begin_src js -n
        if (m === 3) {
            // 满足条件时，执行的语句
        } else {
            // 不满足条件时，执行的语句
        }
      #+end_src
***** switch 结构   
      #+begin_src js -n
        switch (fruit) {
        case "banana":
            // ...
            break;
        case "apple":
            // ...
            break;
        default:
            // ...
        }
      #+end_src

      
      if...else
      Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.
      switch
      Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.
      throw
      Throws a user-defined exception.
      try...catch
      Marks a block of statements to try, and specifies a response, should an exception be thrown.
***** while 循环
      #+begin_src js -n
        while (条件)
        语句;

        // 或者
        while (条件) 语句;
      #+end_src
***** for 循环 
      #+begin_src js -n
        for (初始化表达式; 条件; 递增表达式)
        语句

        // 或者

        for (初始化表达式; 条件; 递增表达式) {
            语句
        }
      #+end_src
**** 声明语句
***** var Declares a variable, optionally initializing it to a value.
***** let Declares a block scope local variable, optionally initializing it to a value.
***** const Declares a read-only named constant.
**** 其他
***** export
      Used to export functions to make them available for imports in external
      modules, and other scripts.
***** import
      Used to import functions exported from an external module, another script.
*** 错误处理
**** Try...Catch 
     #+BEGIN_SRC js
       var txt=""
       function message()
       {
           try
           {
               adddlert("Welcome guest!")
           }
           catch(err)
           {
               txt="此页面存在一个错误。\n\n"
               txt+="错误描述: " + err.description + "\n\n"
               txt+="点击 OK 继续。\n\n"
               alert(txt)
           }
       }
     #+END_SRC
*** 类 [ 现在面向对象了，可以用面向对象的一套概念了 ]
**** ES5 模拟类  
     #+begin_src javascript
       function PersonES5(p) {
           this.age = p.age;
           this.name = p.name;
           this.sex = p.sex;
       }

       PersonES5.prototype.showInfo = function() {
           console.log(this);
       };

       var person = new PersonES5({
           age:18,
           name:'tom',
           sex:'boy'
       });

       person.showInfo();
     #+end_src
**** ES6
     #+begin_src js
       class PersonES6 {
           constructor(p) {
               this.age = p.age;
               this.name = p.name;
               this.sex = p.sex;
           }
           showInfo() {
               console.log(this);
           }
       }


       var person = new PersonES6({
           age:18,
           name:'tom',
           sex:'boy'
       });

       person.showInfo();
     #+end_src
* 标准库
** Date 
   #+BEGIN_SRC js
     日期 Date() getTime() setFullYear() toUTString getDay()
     new Date() // 当前日期和时间
     new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数
     new Date(dateString)
     new Date(year, month, day, hours, minutes, seconds, milliseconds)

     milliseconds 毫秒（0-999）1 秒=1000 毫秒
     var today = new Date()
     var d1 = new Date("October 13, 1975 11:13:00")
     var d2 = new Date(79,5,24)
     var d3 = new Date(79,5,24,11,33,0)
     设置日期
     var myDate=new Date();
     myDate.setFullYear(2010,0,14);

     设置日期为 5 天后
     var myDate=new Date();
     myDate.setDate(myDate.getDate()+5);
     getTime 获取毫秒时间
   #+END_SRC
** Number
   MAX_VALUE 
   MIN_VALUE
** Math
   #+begin_verse
   abs 绝对值
   E 自然对数
   LN2 2 的自然对数
   PI 圆周率
   Math.SQRT2 2 的平方根
   sqrt 平方根
   pow(x, y) x 的 y 次方
   max 取最大值
   min 取最小值
   ceil 上
   floor 下
   round 四舍五入
   #+end_verse
** JSON
  - 对象转字符串  JSON.stringify(arr);
  - 字符串转对象  JSON.parse(strify);
** Array
*** 数组创建[ 推介用字面量] 
    #+begin_src js -n
    var arr1 = new Array(); //创建一个空数组
    var arr2 = new Array(20); // 创建一个包含 20 项的数组
    var arr3 = new Array("lily","lucy","Tom"); // 创建一个包含 3 个字符串的数组
    #+end_src
    创建数组的第二种基本方式是使用数组字面量表示法：

    #+begin_src js -n
    var arr4 = []; //创建一个空数组
    var arr5 = [20]; // 创建一个包含 1 项的数组
    var arr6 = ["lily","lucy","Tom"]; // 创建一个包含 3 个字符串的数组
    #+end_src
    在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：

    #+begin_src js
    arr.length = arr.length-1; //将数组的最后一项删除
    #+end_src

*** 数组方法
**** Array.isArray()  [ 静态方法 ] 
     判断是否数组 
**** Array.prototype [ 静态方法 ]
    调用函数 call 
    
     #+begin_src js
     Array.prototype.join.call(['hello','world'],'----');
     #+end_src
     
     含义等于

     #+begin_src js
     ['hello','world'].join('---')
     #+end_src
     
**** join(separator) [ 实例方法 ]
     : 将数组的元素组起一个字符串，以 separator 为分隔符，省略的话则用默认用逗号为分隔符
     #+begin_src js -n
       var arr = [1,2,3];
       console.log(arr.join()); // 1,2,3
       console.log(arr.join("-")); // 1-2-3
       console.log(arr); // [1, 2, 3]（原数组不变）
     #+end_src
     
     通过 join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重
     复后的字符串，函数如下：

     #+begin_src js -n
       function repeatString(str, n) {
           return new Array(n + 1).join(str);
       }
       console.log(repeatString("abc", 3)); // abcabcabc
       console.log(repeatString("Hi", 5)); // HiHiHiHiHi
       #+end_src
     : 其实就是创建一个多一位的空数组，然后用 分隔符子串填充     
**** push()和 pop()
     #+begin_verse
     push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 
     pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。
     #+end_verse

     #+begin_src js -n
       var arr = ["Lily","lucy","Tom"];
       var count = arr.push("Jack","Sean");
       console.log(count); // 5
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]
       var item = arr.pop();
       console.log(item); // Sean
       console.log(arr); // ["Lily", "lucy", "Tom", "Jack"]
     #+end_src
**** shift() 和 unshift()
#+begin_src js -n
     shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回 undefined。 
     unshift:将参数添加到原数组开头，并返回数组的长度 。
#+end_src

     这组方法和上面的 push()和 pop()方法正好对应，一个是操作数组的开头，一个是操
     作数组的结尾。

     #+begin_src js -n
     var arr = ["Lily","lucy","Tom"];
     var count = arr.unshift("Jack","Sean");
     console.log(count); // 5
     console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]
     var item = arr.shift();
     console.log(item); // Jack
     console.log(arr); // ["Sean", "Lily", "lucy", "Tom"]
     #+end_src
**** sort()
     #+begin_src js -n
     sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。
     在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，因此会出现以下的这种情况：
     #+end_src

     #+begin_src js -n
       var arr1 = ["a", "d", "c", "b"];
       console.log(arr1.sort()); // ["a", "b", "c", "d"]
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort()); // [13, 24, 3, 51]
       console.log(arr2); // [13, 24, 3, 51](元数组被改变)
     #+end_src
     为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个
     值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前
     则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后
     则返回一个正数。以下就是一个简单的比较函数：

     #+begin_src js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return -1;
           } else if (value1 > value2) {
               return 1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [3, 13, 24, 51]
     #+end_src
     如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：
     #+begin_src  js -n
       function compare(value1, value2) {
           if (value1 < value2) {
               return 1;
           } else if (value1 > value2) {
               return -1;
           } else {
               return 0;
           }
       }
       arr2 = [13, 24, 51, 3];
       console.log(arr2.sort(compare)); // [51, 24, 13, 3]
     #+end_src
**** reverse()
     reverse()：反转数组项的顺序。

     #+begin_src js -n
     var arr = [13, 24, 51, 3];
     console.log(arr.reverse()); //[3, 51, 24, 13]
     console.log(arr); //[3, 51, 24, 13](原数组改变)
     #+end_src
**** concat()
     concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

     #+begin_src js -n
     var arr = [1,3,5,7];
     var arrCopy = arr.concat(9,[11,13]);
     console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
     console.log(arr); // [1, 3, 5, 7](原数组未被修改)
     #+end_src
     从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？

     #+begin_src js -n
     var arrCopy2 = arr.concat([9,[11,13]]);
     console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
     console.log(arrCopy2[5]); //[11, 13]
     #+end_src
     上述代码中，arrCopy2 数组的第五项是一个包含两项的数组，也就是说 concat 方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到 arrCopy2 中。
**** slice()
     slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
#+begin_src js -n
     var arr = [1,3,5,7,9,11];
     var arrCopy = arr.slice(1);
     var arrCopy2 = arr.slice(1,4);
     var arrCopy3 = arr.slice(1,-2);
     var arrCopy4 = arr.slice(-4,-1);
     console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
     console.log(arrCopy); //[3, 5, 7, 9, 11]
     console.log(arrCopy2); //[3, 5, 7]
     console.log(arrCopy3); //[3, 5, 7]
     console.log(arrCopy4); //[5, 7, 9]
#+end_src
     arrCopy 只设置了一个参数，也就是起始下标为 1，所以返回的数组为下标 1（包括下标 1）开始到数组最后。 
     arrCopy2 设置了两个参数，返回起始下标（包括 1）开始到终止下标（不包括 4）的子数组。 
     arrCopy3 设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从 1 开始到 4（不包括）的子数组。 
     arrCopy4 中两个参数都是负数，所以都加上数组长度 6 转换成正数，因此相当于 slice(2,5)。
**** splice()
     splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。

     删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
     插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入 4 和 6。
     替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。
     splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。
     #+begin_src js -n
       var arr = [1,3,5,7,9,11];
       var arrRemoved = arr.splice(0,2);
       console.log(arr); //[5, 7, 9, 11]
       console.log(arrRemoved); //[1, 3]
       var arrRemoved2 = arr.splice(2,0,4,6);
       console.log(arr); // [5, 7, 4, 6, 9, 11]
       console.log(arrRemoved2); // []
       var arrRemoved3 = arr.splice(1,1,2,4);
       console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
       console.log(arrRemoved3); //[7]
#+end_src
**** indexOf()和 lastIndexOf()
#+begin_verse
     indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 
     lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。
#+end_verse

     这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

     #+begin_src js -n
     var arr = [1,3,5,7,7,5,3,1];
     console.log(arr.indexOf(5)); //2
     console.log(arr.lastIndexOf(5)); //5
     console.log(arr.indexOf(5,2)); //2
     console.log(arr.lastIndexOf(5,4)); //2
     console.log(arr.indexOf("5")); //-1
     #+end_src
**** forEach()
     forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是 function 类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。

     #+begin_src js -n 
     var arr = [1, 2, 3, 4, 5];
     arr.forEach(function(x, index, a){
     console.log(x + '|' + index + '|' + (a === arr));
     });
     // 输出为：
     // 1|0|true
     // 2|1|true
     // 3|2|true
     // 4|3|true
     // 5|4|true
     #+end_src
**** map()
#+begin_verse
     map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
#+end_verse

     下面代码利用 map 方法实现数组中每个数求平方。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.map(function(item){
     return item*item;
     });
     console.log(arr2); //[1, 4, 9, 16, 25]
#+end_src
**** filter()

     filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
#+begin_src js -n
     var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     var arr2 = arr.filter(function(x, index) {
     return index % 3 === 0 || x >= 8;
     }); 
     console.log(arr2); //[1, 4, 7, 8, 9, 10]
#+end_src
**** every()
     every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.every(function(x) {
     return x < 10;
     }); 
     console.log(arr2); //true
     var arr3 = arr.every(function(x) {
     return x < 3;
     }); 
     console.log(arr3); // false
#+end_src
**** some()

     some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true。
#+begin_src js -n

     var arr = [1, 2, 3, 4, 5];
     var arr2 = arr.some(function(x) {
     return x < 3;
     }); 
     console.log(arr2); //true
     var arr3 = arr.some(function(x) {
     return x < 1;
     }); 
     console.log(arr3); // false
#+end_src
**** reduce()和 reduceRight()
#+begin_verse
     这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
     这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。
     传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
#+end_verse

     下面代码用 reduce()实现数组求和，数组一开始加了一个初始值 10。
#+begin_src js -n
     var values = [1,2,3,4,5];
     var sum = values.reduceRight(function(prev, cur, index, array){
     return prev + cur;
     },10);
     console.log(sum); //25
#+end_src
** 时钟对象
   执行一次 setTimeout
   
   重复执行 setInterval
   #+BEGIN_SRC js -n
     var str = "这个是测试用的范例文字";
     var seq = 0;
     var second=1000; //间隔时间 1 秒钟

     function scroll() {
         msg = str.substring(0, seq+1);
         document.getElementByIdx_x_x('word').innerHTML = msg;
         seq++;
         if (seq >= str.length) seq = 0;
     }

     setInterval('scroll()',second)

     var myVar=setInterval(function(){myTimer()},1000);
     function myTimer(){
         var d=new Date();
         var t=d.toLocaleTimeString();
         // document.getElementById("demo").innerHTML=t;
         console.log(t);
     }

     function myStopFunction(){
         clearInterval(myVar);
     }

   #+END_SRC
* web 移动开发最佳实践
** 避免使用全局变量和函数
   #+begin_src js
     var myApp = {
         lang: "en",
         debug: true,
     };

     myApp.setLang = function (arg) {
         this.lang = arg;
     }
   #+end_src
** 高效的使用 try catch 语句
   #+begin_src js
     var object = ['foo', 'bar'], i;
     try {
         for (i = 0; i < object.length; i++) {
             // do something
         }
     } catch (e) {
         // handle exception
     }
   #+end_src
** 使用赋值运算来连接字符串
   #+begin_src js
     str += "x";
     str += "y";
   #+end_src
** 避免使用 eval()方法
** 使用事件委托
   在处理 DOM 事件的时候，你可以仅对一个父元素绑定一个事件而不是每一个子元素。
   这种技术即事件委托，它利用事件冒泡来分配事件处理程序，可以提高脚本的性能

   #+begin_src html
   <a href="javascript:handleClick();">Click</a>
   <button id="btn1" onclick="handleClick();">One</button>
   <button id="btn2" onclick="handleClick();">Two</button>
   #+end_src
   
   为了提高代码的性能，我们可以加一个 div 父元素，事件会向上冒泡，直到被处理。事件对象是触发事件的元素，我们可以根据它的 id 属性来判断是哪一个元素触发了事件：
 

   #+begin_src html
     <div id="btngroup">
       <button id="btn1">One</button>
       <button id="btn2">Two</button>
     </div>
   #+end_src
   #+begin_src js
     document.getElementById("btngroup").addEventListener("click", function (event) {
         switch (event.srcElement.id) {　　//firefox 下为 event.target.id
                                       case "btn1":
                                       handleClick();
                                       break;
                                       default:
                                       handleClick();
                                      }
     }, false); // type, listener, useCapture (true=beginning, false=end)
   #+end_src
** 尽量减少 DOM 操作
   DOM 是一个包含了很多信息的复杂的 API，因此即使是很小的操作可能会花费较长的时
   间执行（如果要重绘页面的话）。为了提高程序性能，应尽量减少 DOM 操作，这里有一
   些建议：
*** 1.减少 DOM 的数目
    DOM 节点的数目会影响与它相关的所有操作，要尽量使 DOM 树小一些：

    避免多余的标记和嵌套的表格
    元素数尽量控制在 500 个以内（document.getElementsByTagName('*').length）
*** 2.缓存已经访问过的节点
    当访问过一个 DOM 元素后，就应该把它缓存起来，因为你的程序往往要重复访问某个对象的，例如：

    #+begin_src js
      for (var i = 0; i < document.images.length; i++) {
          document.images[i].src = "blank.gif";
      }
    #+end_src
    以上例子中，docum.images 对象被访问了多次，这并不高效，因为每一次循环中，浏
    览器都要查找这个元素两次：第一次读取它的长度，第二次改变相应的 src 值。更好
    的做法是先把这个对象存储起来：

    #+begin_src js
    var imgs = document.images;
    for (var i = 0; i < imgs.length; i++) {　　//当然也可以把 imgs.length 提前算出来，这里不是重点
    imgs[i].src = "blank.gif";
    }
    #+end_src
** 减少页面重绘
   在控制 DOM 元素数目的同时，你还可以通过减少修改元素（减少页面的重绘）的方法来提高性能。重绘有两种方式：repaint、reflow。

   1.repaint，也叫 redraw，即改变了元素的视觉效果，但是不影响它的排版（比如改变背景颜色）
   2.reflow，会影响部分或者全部页面的排版，浏览器不仅要计算该元素的位置，还要计算它影响到的周围的元素位置

   当你要改变页面布局的时候，reflow 就发生了，主要有如下情况：

   增加或删除 DOM 节点
   改变元素的位置
   改变元素的尺寸（如 margin，padding，border，font，width，height 等）
   调整浏览器窗口的尺寸
   增加或删除 css
   改变内容（如用户输入表单）
   命中 css 选择器（如 hover）
   更改了 class 属性
   利用脚本更改了 DOM
   检索一个必须被计算的尺寸（如 offsetWidth，offsetHeight）
   设置了一个 css 属性
   这里有一些减少页面重绘的建议：

 css 的建议：

 改变 class 属性时应尽量少的影响到周围的元素节点
 避免声明多个内联的样式（把多个样式放在一个外部文件里）
 有动画的元素使用绝对定位，这样不会影响其他元素
 避免使用 table 来排版，如果需要使用保存数据，那么要固定排版（table-layout:fixed）
 js 的建议：

 缓存计算过的样式
 对于固定的样式，改变 class 的名词而不是样式；对于动态的样式，改变 cssText 属性：

 // bad - changing the stle - accessing DOM multiple times
 var myElement = document.getElementById('mydiv');
 myElement.style.borderLeft = '2px';
 myElement.style.borderRight = '3px';
 myElement.style.padding = '5px';
 
 // good - use cssText and modify DOM once
 var myElement = document.getElementById('mydiv');
 myElement.style.cssText = 'border-left: 2px; border-right: 3px; padding: 5px;';

 当你要对一个 DOM 元素做出很多修改时，可以先进行一些‘预处理’，批量修改后再替换原始的元素
 创建一个副本（cloneNode()），对这个副本进行更新，然后替代原来的节点

 // slower - multiple reflows
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster - create a copy
 var orig = document.getElementById('container'),
     clone = orig.cloneNode(true), // create a copy
     list = ['foo', 'bar', 'baz'], elem, contents;
 clone.setAttribute('width', '50%');

 修改一个不可见的元素，可以先让其不可见（display:none），修改完成后，再恢复其可见（display:block），这样就会减少 reflow 的次数

 // slower
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.appendChild(subElem);
 elem.style.width = '320px';
             
 // faster
 var subElem = document.createElement('div'),
     elem = document.getElementById('animated');
 elem.style.display = 'none'; // will not be repainted
 elem.appendChild(subElem);
 elem.style.width = '320px';
 elem.style.display = 'block';

 创建一个文档片段（使用 DocumentFragment()），修改完成后，再把它追加到原始文档中

 // slower
 var list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     elem.appendChild(content);
     document.body.appendChild(elem); // multiple reflows
 }
             
 // faster
 var fragment = document.createDocumentFragment(),
     list = ['foo', 'bar', 'baz'], elem, contents;
 for (var i = 0; i < list.length; i++) {
     elem = document.createElement('div');
     content = document.createTextNode(list[i]);
     fragment.appendChild(content);
 }
 document.body.appendChild(fragment); // one reflow

* 异步操作
** 同步任务和异步任务
   程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。
   
   同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

   异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。

   举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。

   ## 任务队列和事件循环

   JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）

   首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

   异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

   JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。[维基百科](http://en.wikipedia.org/wiki/Event_loop)的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。

 ## 异步操作的模式

 下面总结一下异步操作的几种模式。

 ### 回调函数

 回调函数是异步操作最基本的方法。

 下面是两个函数`f1`和`f2`，编程的意图是`f2`必须等到`f1`执行完成，才能执行。

 ```javascript
 function f1() {
   // ...
 }

 function f2() {
   // ...
 }

 f1();
 f2();
 ```

 上面代码的问题在于，如果`f1`是异步操作，`f2`会立即执行，不会等到`f1`结束再执行。

 这时，可以考虑改写`f1`，把`f2`写成`f1`的回调函数。

 ```javascript
 function f1(callback) {
   // ...
   callback();
 }

 function f2() {
   // ...
 }

 f1(f2);
 ```

 回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](http://en.wikipedia.org/wiki/Coupling_(computer_programming))（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

 ### 事件监听

 另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

 还是以`f1`和`f2`为例。首先，为`f1`绑定一个事件（这里采用的 jQuery 的[写法](http://api.jquery.com/on/)）。

 ```javascript
 f1.on('done', f2);
 ```

 上面这行代码的意思是，当`f1`发生`done`事件，就执行`f2`。然后，对`f1`进行改写：

 ```javascript
 function f1() {
   setTimeout(function () {
     // ...
     f1.trigger('done');
   }, 1000);
 }
 ```

 上面代码中，`f1.trigger('done')`表示，执行完成后，立即触发`done`事件，从而开始执行`f2`。

 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”[去耦合](http://en.wikipedia.org/wiki/Decoupling)“（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。

 ### 发布/订阅

 事件完全可以理解成”信号“，如果存在一个”信号中心“，某个任务执行完成，就向信号中心”发布“（publish）一个信号，其他任务可以向信号中心”订阅“（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](http://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](http://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。

 这个模式有多种[实现](http://msdn.microsoft.com/en-us/magazine/hh201955.aspx)，下面采用的是 Ben Alman 的 [Tiny Pub/Sub](https://gist.github.com/661855)，这是 jQuery 的一个插件。

 首先，`f2`向信号中心`jQuery`订阅`done`信号。

 ```javascript
 jQuery.subscribe('done', f2);
 ```

 然后，`f1`进行如下改写。

 ```javascript
 function f1() {
   setTimeout(function () {
     // ...
     jQuery.publish('done');
   }, 1000);
 }
 ```

 上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。

 `f2`完成执行后，可以取消订阅（unsubscribe）。

 ```javascript
 jQuery.unsubscribe('done', f2);
 ```

 这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

 ## 异步操作的流程控制

 如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。

 ```javascript
 function async(arg, callback) {
   console.log('参数为 ' + arg +' , 1 秒后返回结果');
   setTimeout(function () { callback(arg * 2); }, 1000);
 }
 ```

 上面代码的`async`函数是一个异步任务，非常耗时，每次执行需要 1 秒才能完成，然后再调用回调函数。

 如果有六个这样的异步任务，需要全部完成后，才能执行最后的`final`函数。请问应该如何安排操作流程？

 ```javascript
 function final(value) {
   console.log('完成: ', value);
 }

 async(1, function(value){
   async(value, function(value){
     async(value, function(value){
       async(value, function(value){
         async(value, function(value){
           async(value, final);
         });
       });
     });
   });
 });
 ```

 上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。

 ### 串行执行

 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。

 ```javascript
 var items = [ 1, 2, 3, 4, 5, 6 ];
 var results = [];

 function async(arg, callback) {
   console.log('参数为 ' + arg +' , 1 秒后返回结果');
   setTimeout(function () { callback(arg * 2); }, 1000);
 }

 function final(value) {
   console.log('完成: ', value);
 }

 function series(item) {
   if(item) {
     async( item, function(result) {
       results.push(result);
       return series(items.shift());
     });
   } else {
     return final(results[results.length - 1]);
   }
 }

 series(items.shift());
 ```

 上面代码中，函数`series`就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行`final`函数。`items`数组保存每一个异步任务的参数，`results`数组保存每一个异步任务的运行结果。

 注意，上面的写法需要六秒，才能完成整个脚本。

 ### 并行执行

 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行`final`函数。

 ```javascript
 var items = [ 1, 2, 3, 4, 5, 6 ];
 var results = [];

 function async(arg, callback) {
   console.log('参数为 ' + arg +' , 1 秒后返回结果');
   setTimeout(function () { callback(arg * 2); }, 1000);
 }

 function final(value) {
   console.log('完成: ', value);
 }

 items.forEach(function(item) {
   async(item, function(result){
     results.push(result);
     if(results.length === items.length) {
       final(results[results.length - 1]);
     }
   })
 });
 ```

 上面代码中，`forEach`方法会同时发起六个异步任务，等到它们全部完成以后，才会执行`final`函数。

 相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。

 ### 并行与串行的结合

 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行`n`个异步任务，这样就避免了过分占用系统资源。

 ```javascript
 var items = [ 1, 2, 3, 4, 5, 6 ];
 var results = [];
 var running = 0;
 var limit = 2;

 function async(arg, callback) {
   console.log('参数为 ' + arg +' , 1 秒后返回结果');
   setTimeout(function () { callback(arg * 2); }, 1000);
 }

 function final(value) {
   console.log('完成: ', value);
 }

 function launcher() {
   while(running < limit && items.length > 0) {
     var item = items.shift();
     async(item, function(result) {
       results.push(result);
       running--;
       if(items.length > 0) {
         launcher();
       } else if(running == 0) {
         final(results);
       }
     });
     running++;
   }
 }

 launcher();
 ```

 上面代码中，最多只能同时运行两个异步任务。变量`running`记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于`0`，就表示所有任务都执行完了，这时就执行`final`函数。

 这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节`limit`变量，达到效率和资源的最佳平衡。
* 模块
  Javascript 不是一种模块化编程语言，在 es6 以前，它是不支持”类”（class），所以也
  就没有”模块”（module）了。
  
  ES6 标准发布后，module 成为标准，标准使用是以 export 指令导出接口，以 import
  引入模块，但是在我们一贯的 node 模块中，我们依然采用的是 CommonJS 规范，使用
  require 引入模块，使用 module.exports 导出接口。
