#+TITLE: java 简介
#+DESCRIPTION: java 简介
#+TAGS: java
#+CATEGORIES: 语言使用
#+DATE: <2019-06-28 07:01:24>

* java 
** 简介 
   ~java~ 的世界观 是 世界是 ~对象们~ 的世界 , 对象在里面 ~生老 病死~ 是不可能的，对象在里面可以操作别的对象 。
   #+begin_quote
   其实还有静态对象(就是静态类)
   计算机语言好多都继承了数学那种写法简洁的特点。
   #+end_quote
   
   #+begin_verse
   虽然负责操作的是对象，但对象是由对象的模板生成的，也叫类型,类，数据类型。(差不多这个意思啦)   
   对于两个本质差不多的类型，科学家发明了衍生的含义，就是一个类可以拷贝另一个类的东西，叫 ~继承~ 另一个类的东西。
   继承过来的类，如果自己的属性和和操作方法有点区别的 ，就重写里面的属性和操作。
   #+end_verse

   #+HTML: <!-- more -->
   #+begin_quote
   为什么加入继承的概念呢？我觉得是便于组件化，所以有相识的对象，可以用继承拷贝啦，就不用费力再写一遍了。
   #+end_quote

   类如果不想把某个属性或操作给人家使用，可以用 ~private~ (私有的) 说明一下。
** 简单类
   #+begin_verse
   byte,Byte
   int,Integer
   short,Short
   long,Long
   float,Float f = 1.1f;  1.1 是 double 类型
   char,Character,UTF-16 结构,编码都是两个字节
   不要在程序中用 char 类型 
   字符串 String
   boolean,Boolean 只有两个值,true/false
   大数值 BigInteger BigDecimal
   
   数组的数据  类型 [框]  名字 = {值 1,值 2},哈这样也挺简单
   遍历数组的简写形式用 foreach
   for(类型 变量名 : 数组变量名)  
   数组拷贝
   Array.copyof(数组源，数组长)
   数组会了，多维数组也会的吧，我想。
   
   不规则数组 double[] temp = ban[i];
   ban[i]=ban[i+1];
   #+end_verse
** 对象 
*** 变量(可以改变里面属性的对象)
    创建对象 
    #+begin_src java
      ClassName ObjName = new ClassName();
    #+end_src

    改变对象的属性 , 用个点号 
    #+begin_src java
      ObjName.PropertyName=Value;
    #+end_src

    #+begin_quote
    不用销毁对象，java 控制程序会自己操作
    #+end_quote
*** 常量 (雷打不动的对象) 
    定义常量
    #+begin_src java
      final ClassName ObjName = new ClassName();
    #+end_src
** 面向对象的其他用法
   #+begin_verse
   继承语法 class B extends A{}
   阻止类的继承  final class C extends{},C 就不能继承了
   类中成员有隐私性，如果公开就为 public ,不公开为 private,家庭成员才能访问 protected
   对于安全性很重视的伙伴，这非常重要的.
   类的静态，相当于类的属性，不能被实例了。!!! 不允许有静态类哦，只允许有静态内部类
   方法的静态，方法的属性，表示此方法不能创建实例。
   构造函数把函数名取成类名，就是构造函数了，这个也挺好的设计。调用内部构造器时，要会用 this 哦,父的用 parent。
   析构函数必须要有一个名字了，一般用 finalize(结束) 表示。 
   默认类私有的哦，其他类要想访问，要加公开属性 public 
  
   抽象类 abstract ，抽象方法，介意就声明下就好，不要定义实体.
  
   反射功能的主要使用者是工具开发者，而不是普通程序员
   反射返回类的结构 .
   reflect 包中有三个类 Field ,Method ,Constructor
  

   接口 interface, public interface Interface1{}
   泛型接口 public interface Interface1<T>{}
   接口的实现 class Em implements Interface1,Interface2{}
   #+end_verse

*** 类的分组方式，包
    #+begin_verse
    包，可以将类组织起来，包的属性就是名字，包有一个名字，用 package 表示这个文件是包了。
    包的结构决定目录结构的哦。
    import 命名空间.类.*; 导入类下的所有方法。
    import 可以导入类，也可以导入包。
    静态导入 import static 命名空间.类.*; 静态导入就不要在写类名了，方法是全局的了,注意只有类内的静态方法或字段才能这样使用哦。  
   
    javac com/wuming/hello/App.java  或 在 hello 目录内 , javac App.java 
    java com.wuming.hello.App  ,执行的化名字要完整的哦,不来不知道哪个类。
   
    设置类的路径( CLASSPATH)环境变量后,java 也会在此查找类哦，注意！
    不光可以包含文件夹，还能包含 jar 文件哦，jar 其实也是文件夹啦，打包了而已哦。
    #+end_verse
   
*** 泛型
    给类也创建个模板
    #+BEGIN_SRC java
      public class Box<T> {
          // T stands for "Type"
          private T t;
          public void set(T t) { this.t = t; }
          public T get() { return t; }
      }
    #+END_SRC
* 工具
** 安装设置
   下载 JDK,然后安装
   
   配置环境变量  
   #+begin_src sh
   export JAVA_HOME=/usr/lib/jvm/jdk-11.0.1
   export CLASSPATH=.:${JAVA_HOME}/lib
   #+end_src
   
** 编译程序 javac 
   | classpath Path | 指定要加载类的路径     |
   | d Dir          | 指定编译后的类存放路径 |
   | g              | 生成调试表             |
   | nowarn         | 关闭警告               |
   | verbose        | 打开详细信息           |
   | o              | 优化                   |
   
** 运行程序 java
   java [options] classname [args]
   java [options] -jar filename [args]
   java -classpath PATH fileName.java
   
   启用断言 java -enableassertions App
** 文档生成器 javadoc 
   javadoc [options...] [package names...] [source filenames...]
   
   javadoc -d DocDir  nameofPackage 或 className
*** 注释样式,支持 HTML 格式
    /** 开始 */ 结束
    javadoc 文件名
    @see reference 链接或文本
    #deprecated text 不鼓励
    @version text
    @author name
    @param variable description
    @return description
    @throws class description
** 反编译 javap
