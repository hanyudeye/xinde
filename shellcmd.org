* shell 命令
** 内核管理
    apt install linux-head-generic linux-image-genric linux-head
    sudo update-grub
** 软件管理
*** deb 软件
    安装 sudo dpkg -i *.deb  进行安装
*** apt 
    apt-get source <package> 获取源码
    apt-cache search 'expression'
    列表位于/etc/apt/sources.list
    维护好依赖, 都是 deb 文件
    路径  /var/cache/apt/archives
    
    debian系linux更新时，提示“由于没有公钥，无法验证下列签名”
    解决方法
1. 下载导入公钥
# apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  8B48AD6246925553
# apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  7638D0442B90D010
# 此处的8B48AD6246925553、7638D0442B90D010是错误提示中的：NO_PUBKEY 8B48AD6246925553  NO_PUBKEY 7638D0442B90D010 

*** aptitude    
    查找
    aptitude search package_name
    安装
    sudo aptitude install wine
    更新
    aptitude safe-upgrade   
    aptitude full-upgrade 相比上面的，不会检查包的依赖关系 
    aptitude dist-upgrade 
    卸载 
    sudo aptitude purge wine
    
    软件仓库
    /etc/apt/sources.list
    
    deb (or deb-src) address  distribution_name  package_type_list
    deb 或deb-src 的值表明了软件包的类型。deb 值说明这是一个已编译程序源，而deb-src 值则说明这
    是一个源代码的源。

    address 条目是软件仓库的Web地址。distribution_name 条目是这个特定软件仓库的发行版版本的名称
    最后，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到
    诸如main、restricted、universe和partner这样的值。
*** yum(基于Red Hat的系统)
    列出已安装包   yum list installed
    安装 yum install package_name
    本地安装 yum localinstall package_name.rpm

    更新 yum list updates
    yum update package_name

    只删除软件包而保留配置文件和数据文件，就用如下命令：
    yum remove package_name

    要删除软件和它所有的文件，就用erase 选项：
    yum erase package_name

    yum update --skip-broken
    --skip-broken 选项允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。这可能救不了损坏
    的包，但至少可以更新系统上的其他包。

*** 软件安装
**** 依赖库
**** 依赖库降级 
     libpng12-dev : Depends: libpng12-0 (= 1.2.54-1ubuntu1) but 1.2.54-1ubuntu1k1 is to be installed 
     E: Unable to correct problems, you have held broken packages
     解决办法
     sudo apt install libpng12-0=1.2.54-1ubuntu1
**** deb 软件
     安装 sudo dpkg -i *.deb  进行安装
**** apt 
     apt-get source <package> 获取源码
     apt-cache search 'expression'
     列表位于/etc/apt/sources.list
     维护好依赖, 都是 deb 文件
     路径  /var/cache/apt/archives
*** Snap
#查询已经安装了的软件 sudo snap list
#搜索要安装的Snap软件包 sudo snap find xxxx
#查看Snap软件的更多信息 sudo snap info xxxx
#安装Snap软件包 sudo snap install xxxx
#更换软件安装通道 sudo snap switch –channel=xxxx xxxx
#更新Snap软件包 sudo snap refresh xxxx
#还原到之前版本 sudo snap revert xxxx
#卸载Snap软件 sudo snap remove xxxx
当然光靠命令你想搜索什么snap软件包也是一头雾水吧！可以去uappexplorer里查询下，有什么snap软件包呢！喜欢的就都安装上。
#Uappexplorer
https://uappexplorer.com/snaps
** 任务管理
*** 任务放在前、后台
    fg bg jobs 
*** w 登录任务列表
*** ps 任务列表
   #+BEGIN_SRC conf
     -e   显示所有进程 
     -f    全格式
     -h   不显示标题
     -l    长格式
     -w     宽输出
     a    显示终端上的所有进程，包括其他用户的进程。
     r    只显示正在运行的进程。
     u 　以用户为主的格式来显示程序状况。
     x     显示所有程序，不以终端机来区分。

     ps -ef 显示出的结果：
         1.UID       用户 ID
         2.PID        进程 ID
         3.PPID      父进程 ID
         4.C           CPU 占用率
         5.STIME     开始时间
         6.TTY         开始此进程的 TTY----终端设备
         7.TIME       此进程运行的总时间
         8.CMD       命令名
   #+END_SRC
   
   init init进程是所有Linux进程的父进程
*** crontab 执行周期任务
   init init 进程是所有 Linux 进程的父进程
*** crontab 周期性执行
**** 命令
     crontab [ -u user ] file
     crontab [ -u user ] [ -i ] { -e | -l | -r } |
     -e 编辑 crontab 文件
     -l　列出 crontab 文件内容
     -r 删除 crontab 文件
**** 开启日志     
    修改 rsyslog 文件，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的#删掉；
    重启 rsyslog 服务 service rsyslog restart；
    重启 cron 服务 service cron restart；

    more /var/log/cron.log；
    就可以查看运行时的日志文件，如果在日志文件中出现：No MTA installed, discarding output

    那么就是说，crontab 执行脚本时是不会直接错误的信息输出，而是会以邮件的形式发送到你的邮箱里，这时候就需要邮件服务器了，
    如果你没有安装邮件服务器，它就会报这个错。如果是测试，可以用下面的办法来解决：

    在每条定时脚本后面加入：
    ?
    001
    >/dev/null 2>&1
    就可以解决 No MTA installed, discarding output 的问题
**** 编辑文件, 其实编辑好后就会自动执行
    crontab -e  

    # m h  dom mon dow   command  
    */2 * * * * date >> ~/time.log  
**** 执行     
     sudo service cron restart  

     对于自己的，只要执行下自己的 crontab　文件即可
     crontab -u wuming crontabfile

 | 分钟 | 0 - 59                                                                     |
 | 小时 | 0 - 23                                                                     |
 | 天   | 1 - 31                                                                     |
 | 月   | 1 - 12                                                                     |
 | 星期 | 0 - 6   0 表示星期天                                                        |
 | 星号 | 表示任意值，比如在小时部分填写 * 代表任意小时（每小时）                    |
 | 逗号 | 可以允许在一个部分中填写多个值，比如在分钟部分填写 1,3 表示一分钟或三分钟  |
 | 斜线 | 一般配合 * 使用，代表每隔多长时间，比如在小时部分填写 */2 代表每隔两分钟。 |
\* * * * *                  # 每隔一分钟执行一次任务  
0 * * * *                  # 每小时的0点执行一次任务，比如6:00，10:00  
6,10 * 2 * *            # 每个月2号，每小时的6分和10分执行一次任务  
0 * * * *                  # 每小时的 0 点执行一次任务，比如 6:00，10:00  
6,10 * 2 * *            # 每个月 2 号，每小时的 6 分和 10 分执行一次任务  
*** pkill 杀死进程按照进程名
0 * * * *                  # 每小时的 0 点执行一次任务，比如 6:00，10:00  
6,10 * 2 * *            # 每个月 2 号，每小时的 6 分和 10 分执行一次任务  
*** pkill 可以按照进程名杀死进程
*** 进程属性
    ls /proc/PID 
    cwd 进程运行目录
    exe 程序绝对路径
    cmdline 运行时的命令行命令
    environ 环境变量
    fd 打开或使用的文件的符号链接
** 用户管理
*** 添加
     useradd -m -g users -G wheel -s /bin/bash ikke
     passwd ikke
*** 组织
**** sudo 组
      打开 /etc/sudoers 
*** 忘记密码
   1,启动时在启动的 linux 系统（或 grub 到计时结束前）上按下“e”键
   2，选中类似“于 kernel /boot/vmlinuz-2.4.18-14 ”按“e”键
   3,修改命令行，加入 linux single，结果如下：
   kernel /vmlinuz-2.6.18-8.el5  ro root=LABEL=/ rhgb quiet linux single
   4,回车返回，按 b 键,进入命令行
   5, #vi /etc/shadow 编辑 shadow
   将第一行，即以 root 开头的一行中 root:后和下一个:前的内容删除，
   第一行将类似于
   root::……
   保存
   (如果保存不了，是文件属性的问题，就chmod 755 /etc/shadow，这样就OK了)
6. #reboot重启，root密码为空
   (如果保存不了，是文件属性的问题，就 chmod 755 /etc/shadow，这样就 OK 了)
6. #reboot 重启，root 密码为空
*** 显示 w 
*** 用户通信 write USERNAME 终端
    终端通过who获取
    write wuming pts/0
*** 拒绝通信 mesg n 
** 设备管理
*** 查看设备 
    ls /dev/
*** 硬盘设备 
    查看容量 df
**** mount
     mount 用于加载文件系统到指定的加载点
    mount  [-t vfstype] [-o options] device dir
    1.-t vfstype 文件系统类型
    　　光盘或光盘镜像：iso9660
    　　DOS fat16 文件系统：msdos
    　　Windows 9x fat32 文件系统：vfat
    　　Windows NT ntfs 文件系统：ntfs
    　　Mount Windows 文件网络共享：smbfs
    　　UNIX(LINUX) 文件网络共享：nfs
    2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
    　　loop：用来把一个文件当成硬盘分区挂接上系统
    　　ro：采用只读方式挂接设备
    　　rw：采用读写方式挂接设备
    　　iocharset：指定访问文件系统所用字符集,不能显示中文 iocharset=cp936
    3.device 要挂接(mount)的设备。
    4.dir 设备在系统上的挂接点(mount point)。
    sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览 windows 共享文件夹
**** fstab 
***** 挂载的限制
      1、根目录是必须挂载的，而且一定要先于其他mount point被挂载。因为mount是所有
      目录的跟目录，其他木有都是由根目录 /衍生出来的。

      2、挂载点必须是已经存在的目录。
   
      3、挂载点的指定可以任意，但必须遵守必要的系统目录架构原则

      4、所有挂载点在同一时间只能被挂载一次

      5、所有分区在同一时间只能挂在一次

      6、若进行卸载，必须将工作目录退出挂载点（及其子目录）之外。

***** /etc/fstab文件中的参数
   一共有六列
   # <file system> <mount point>   <type>  <options>       <dump>  <pass>

****** 第一列：Device：磁盘设备文件或者该设备的Label或者UUID
******** 1）查看分区的label和uuid
        Label就是分区的标签，在最初安装系统时填写的挂载点就是标签的名字。可以通过查看一个分区的superblock中的信息找到UUID和Label name。

        例如:我们要查看/dev/sda1这个设备的uuid和label name
        sudo dumpe2fs -h /dev/sda1

        对于ntfs文件系统 
        sudo ntfsinfo -m /dev/sdb1 
 
        只查看UUID
        sudo blkid /dev/vda1

        要显示分区的基本信息请运行：
        $ lsblk -f
******** 2）使用设备名和label及uuid作为标识的不同
        使用设备名称（/dev/sda)来挂载分区时是被固定死的，一旦磁盘的插槽顺序发生了变
        化，就会出现名称不对应的问题。因为这个名称是会改变的。

        不过使用label(volume name)挂载就不用担心插槽顺序方面的问题。不过要随时注意你的Label name。至
        于UUID，每个分区被格式化以后都会有一个UUID作为唯一的标识号。使用uuid挂载的话就
        不用担心会发生错乱的问题了。

****** 第二列：Mount point：设备的挂载点，就是你要挂载到哪个目录下。
****** 第三列：filesystem：磁盘文件系统的格式，包括ext2、ext3、reiserfs、nfs、vfat等
****** 第四列：parameters：文件系统的参数
       Async/sync 设置是否为同步方式运行，默认为async

       auto - 在启动时或键入了 mount -a 命令时自动挂载。
       noauto - 只在你的命令下被挂载。

       rw/ro 是否以以只读或者读写模式挂载

       exec/noexec 限制此文件系统内是否能够进行"执行"的操作

       user/nouser 是否允许用户使用mount命令挂载

       suid/nosuid 是否允许SUID的存在

       Usrquota 启动文件系统支持磁盘配额模式

       Grpquota 启动文件系统对群组磁盘配额模式的支持

       sync - I/O 同步进行。
       async - I/O 异步进行。
    
       Defaults 同时具有rw,suid,dev,exec,auto,nouser,async等默认参数的设置
****** 第五列：能否被dump备份命令作用：dump是一个用来作为备份的命令。通常这个参数的值为0或者1
       0 代表不要做dump备份
       1 代表要每天进行dump的操作
       2 代表不定日期的进行dump操作
****** 第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整（clean）。
       0 不要检验
       1 最早检验（一般根目录会选择）
       2 1级别检验完成之后进行检验
******  /dev/hdc1 /c vfat defaults 0 0
        (/c 是事先建立的文件夹，作为c盘的挂载点。)
        当你修改了/etc/fstab后，一定要重新引导系统才会有效。
****** 修改fstab 后, 执行 mount -a 生效
****** 内核名称
       你可以使用 fdisk -l 来获得内核名称，前缀是 dev.

   自动挂载
   如果 /home 分区较大，可以让不依赖 /home 分区的服务先启动。把下面的参数添加到 /etc/fstab 文件中 /home 项目的参数部分即可：
   noauto,x-systemd.automount
   这样 /home 分区只有需要访问时才会被挂载。内核会缓存所有的文件操作，直到 /home 分区准备完成。

   注意: 这样做会使 /home 的文件系统类型被识别为 autofs，造成 mlocate 查询时忽略该目录。实际加速效果因配置而异，所以请自己权衡是否需要。
   挂载远程文件系统也是同理。如果你仅想在需要的时候才挂载，也可以添加 noauto,x-systemd.automount 参数。另外，可以设置 x-systemd.device-timeout=# 参数，设置超时时间，以防止网络资源不能访问的时候浪费时间。
   如果你的加密文件系统需要密钥，则需要添加 noauto 参数到 /etc/crypttab 文件中的对应位置。systemd 开机的时候就不会打开这个加密设备，会一直等待到设备被访问时再使用密钥文件挂载。比如在使用加密RAID设备的时候可以节省一定的时间，因为 systemd 不必等到设备可用后才能访问。例如：
   /etc/crypttab
   data /dev/md0 /root/key noauto
   交换分区 UUID
   如果交换分区没有 UUID，可以手动加入。如果使用 lsblk -f 命令没有列出交换分区的 UUID 就说明发生了这种情况。下面是为交换分区指定 UUID 的步骤：

   确定交换分区：

   # swapon -s
   禁用交换分区：

   # swapoff /dev/sda7
   用新 UUID 重新创建交换分区：

   # mkswap -U random /dev/sda7
   激活交换分区:

   # swapon /dev/sda7
   路径名有空格
   如果挂载的路径中有空格，可以使用 "\040" 转义字符来表示空格（以三位八进制数来进行表示）

   /etc/fstab
   UUID=47FA-4071     /home/username/Camera\040Pictures   vfat  defaults,noatime      0  2
   /dev/sda7          /media/100\040GB\040(Storage)       ext4  defaults,noatime,user  0  0
   .....</nowiki>}}

   外部设备
   外部设备在插入时挂载，在未插入时忽略。这需要 nofail 选项，可以在启动时若设备不存在直接忽略它而不报错.

   /etc/fstab
    /dev/sdg1    /media/backup    jfs    defaults,nofail    0  2
   atime 参数
   使用 noatime, nodiratime 或 relatime 可以提升 ext2， ext3 及 ext4 格式磁盘的性能。 Linux 在默认情况下使用atime选项，每次在磁盘上读取（或写入）数据时都会产生一个记录。这是为服务器设计的，在桌面使用中意义不大。默认的 atime 选项最大的问题在于即使从页面缓存读取文件(从内存而不是磁盘读取)，也会产生磁盘写操作！

   使用 noatime 选项阻止了读文件时的写操作。大部分应用程序都能很好工作。只有少数程序如 Mutt 需要这些信息。Mutt 的用户应该使用 relatime 选项。使用 relatime 选项后，只有文件被修改时才会产生文件访问时间写操作。nodiratime 选项仅对目录禁用了文件访问时间。relatime 是比较好的折衷，Mutt 等程序还能工作，但是仍然能够通过减少访问时间更新提升系统性能。

   注意: noatime 已经包含了 nodiratime。不需要同时指定。
   tmpfs
   tmpfs 是一个临时文件系统，驻留于你的交换分区或是内存中（取决于你的使用情况）。使用它可以提高文件访问速度，并能保证重启时会自动清除这些文件。

   经常使用 tmpfs 的目录有 /tmp, /var/lock and /var/run. 不要将之使用于 /var/tmp,
   因为这一目录中的临时文件在重启过程中需要被保留。使用 tmpfs /run 目录，/var/run
   和 /var/lock 是为了兼容老版本建立的链接。默认 /etc/fstab中的的/tmp也是 tmpfs.

   默认情况下， tmpfs 分区被设置为你总的内存的一半，当然你可以自由设定这一值。注意
   实际中内存和交换分区的使用情况取决于你的使用情况，而 tmpfs 分区在其真正使用前是
   不会占用存储空间的。

   要将 /tmp 放到 tmpfs，将下行加入 /etc/fstab：

   /etc/fstab ..... tmpfs /tmp tmpfs nodev,nosuid 0 0 ..... 
   可以指定大小，但不要修
   改 mode 选项，以保证文件具有正确的访问权限(1777)。在上例中 /tmp 将最多使用一半内
   存，要指定最大空间，使用 size 挂载选项：

   /etc/fstab
   .....
   tmpfs /tmp      tmpfs nodev,nosuid,size=2G          0 0
   .....

   这里有一个更高级的例子，展示如何为用户添加 tmpfs 挂载。这对于网站、mysql 临时文
   件, ~/.vim/, 和其他情况很有用。尝试并获得理想的挂载选项来完成目标是很重要的。目
   标是尽量采用安全的策略来防止滥用。限制大小，同时指定 uid 和 gid 加上 mode 是非常
   安全的。更多信息.

   /etc/fstab
   tmpfs /www/cache tmpfs rw,size=1G,nr_inodes=5k,noexec,nodev,nosuid,uid=648,gid=648,mode=1700 0 0

   参阅 mount 命令 man 手册以获得更多的内容。

   重启后方能生效。注意不要直接执行 mount -a 命令，因为可能造成无法访问当前目录中的
   文件（比如你应该保证 lockfiles 的正常存在）。然而，如果它们都是空的，那么就可以
   直接执行 mount -a 而不必重启电脑。

   应用更改后，可以通过 findmnt 检查是否生效：

   $ findmnt --target /tmp
   TARGET SOURCE FSTYPE OPTIONS
   /tmp   tmpfs  tmpfs  rw,nosuid,nodev,relatime
   使用

   一般需要大量读写操作的程序在使用 tmpfs 时都会提升性能。有些程序把共享内存放到
   tmpfs 上时性能会大幅提升，例如将 Firefox Profile 文件夹放到内存后，Firefox 性能
   大幅提升。

   Note: tmpfs 目录(/tmp) 挂载时需要去掉 noexec 参数，否则有些编译程序无法执行，此
   外，tmpfs 的默认大小是内存的一般，可能会产生空间不够的问题。下面命令可以让
   makepkg在tmpfs目录进行编辑，也可以在在/etc/makepkg.conf中进行设置:

   $ BUILDDIR=/tmp/makepkg makepkg
   普通用户读写 FAT32
   为了取得对 FAT32 分区的写权限，你必须修改/etc/fstab文件。

   /etc/fstab /dev/sdxY /mnt/some_folder vfat user,rw,umask=000 0 0 

   “users”标签的意思是任何用户（甚至非 root 用户）都可以挂载或卸载分区 '/dev/sdX'。
   “rw”标签则分配读写的使用权。但我不知道“umask”标签的意义（umask 是权限掩码命
   令 umask=000 指任何人没有特权，且权限为777，即所有人都可以读、写、执行）。我曾试
   图在“man mount”中查询，但是没有什么结果。

   比如你的 FAT32 分区在 '/dev/sda9'，你想将其挂载到 '/mnt/fat32'，那么你需要输入并
   运行

   /etc/fstab
   /dev/sda9    /mnt/fat32        vfat   user,rw,umask=111,dmask=000    0  0
**** umount
** 文件系统
** 文件管理
*** 查看 cat less more head tac tail wc
*** 排序查看 sort uniq
*** 修改 vim/emacs
*** 新增文件 目录  mkdir
*** 删除 remove rmdir
*** 比较 diff
*** 文件类型 file 
*** 改名 mv
*** 编辑
**** sed 命令编辑器
***** 选项 
      sed [options] 'command' file(s)
      sed [options] -f scriptfile file(s)
      -e<script>或--expression=<script>：以选项中的指定的 script 来处理输入的文本文件；
      -f<script 文件>或--file=<script 文件>：以选项中指定的 script 文件来处理输入的文本文件；
***** 功能
      a\ 在当前行下面插入文本。
      i\ 在当前行上面插入文本。
      c\ 把选定的行改为新的文本。
      d 删除，删除选择的行。
      D 删除模板块的第一行。
      s 替换指定字符 sed 's/aa/bb/' file 注意/ 符,用来分界
      h 拷贝模板块的内容到内存中的缓冲区。
      H 追加模板块的内容到内存中的缓冲区。
      g 获得内存缓冲区的内容，并替代当前模板块中的文本。
      G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
      l 列表不能打印字符的清单。
      n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
      N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
      p 打印模板块的行。(显示两遍)
      P(大写) 打印模板块的第一行。
      q 退出 Sed。
      b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
      r file 从 file 中读行。
      t label if 分支，从最后一行开始，条件一旦满足或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
      T label 错误分支，从最后一行开始，一旦发生错误或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
      w file 写并追加模板块到 file 末尾。  
      W file 写并追加模板块的第一行到 file 末尾。  
      ! 表示后面的命令对所有没有被选定的行发生作用。  
      = 打印当前行号码。  
      # 把注释扩展到下一个换行符以前。  

      sed 替换标记
      g 表示行内全面替换。  
      p 表示打印行。  
      w 表示把行写入一个文件。  
      x 表示互换模板块中的文本和缓冲区中的文本。  
      y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
      \1 子串匹配标记
      & 已匹配字符串标记

      sed 元字符集
      ^ 匹配行开始，如：/^sed/匹配所有以 sed 开头的行。
      $ 匹配行结束，如：/sed$/匹配所有以 sed 结尾的行。
      . 匹配一个非换行符的任意字符，如：/s.d/匹配 s 后接一个任意字符，最后是 d。
      [* 匹配 0 个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟 sed 的行。
      [] 匹配一个指定范围内的字符，如/[ss]ed/匹配 sed 和 Sed。  
      [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含 A-R 和 T-Z 的一个字母开头，紧跟 ed 的行。
      \(..\) 匹配子串，保存匹配的字符，如 s/\(love\)able/\1rs，loveable 被替换成 lovers。
      & 保存搜索字符用来替换其他字符，如 s/love/**&**/，love 这成**love**。
      \< 匹配单词的开始，如:/\<love/匹配包含以 love 开头的单词的行。
      \> 匹配单词的结束，如/love\>/匹配包含以 love 结尾的单词的行。
      x\{m\} 重复字符 x，m 次，如：/0\{5\}/匹配包含 5 个 0 的行。
      x\{m,\} 重复字符 x，至少 m 次，如：/0\{5,\}/匹配至少有 5 个 0 的行。
      x\{m,n\} 重复字符 x，至少 m 次，不多于 n 次，如：/0\{5,10\}/匹配 5~10 个 0 的行。 

***** sed 用法实例
****** 替换：s
      sed 's/book/books/' file

      -n 选项和 p 命令一起使用表示只打印那些发生替换的行：
      sed -n 's/test/TEST/p' file

      直接编辑文件选项-i，会匹配 file 文件中每一行的第一个 book 替换
      为 books：
      sed -i 's/book/books/g' file
****** 全面替换标记 g
      sed 's/book/books/g' file
****** 替换 1 行中第 N 处匹配开始替换时，可以使用 /Ng：
      echo sksksksksksk | sed 's/sk/SK/2g'
      skSKSKSKSKSK
****** 使用定界符
      sed 's:test:TEXT:g'
      sed 's|test|TEXT|g'

      定界符出现在样式内部时，需要进行转义：
      sed 's/\/bin/\/usr\/local\/bin/g'

****** 删除操作：d 命令
****** 删除空白行：
      sed '/^$/d' file

****** 删除文件的第 2 行：
      sed '2d' file
****** 删除文件的第 2 行到末尾所有行：
      sed '2,$d' file
****** 删除文件最后一行：
      sed '$d' file
****** 删除文件中所有开头是 test 的行：
      sed '/^test/'d file
****** 已匹配字符串标记&
      正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之
      前所匹配到的单词：

      echo this is a test line | sed 's/\w\+/[&]/g'
      [this] [is] [a] [test] [line]

      所有以 192.168.0.1 开头的行都会被替换成它自已加 localhost：

      sed 's/^192.168.0.1/&localhost/' file
      192.168.0.1localhost
****** 子串匹配标记\1
      匹配给定样式的其中一部分：
      echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
      this is 7 in a number

      命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，\(..\)
      用于匹配子串，对于匹配到的第一个子串就标记为 \1，依此类推匹
      配到的第二个结果就是 \2，例如：

      echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
      BBB aaa

      love 被标记为 1，所有 loveable 会被替换成 lovers，并打印出来：

      sed -n 's/\(love\)able/\1rs/p' file
****** 组合多个表达式
      sed '表达式' | sed '表达式'

      等价于：

      sed '表达式; 表达式'

      引用

      sed 表达式可以使用单引号来引用，但是如果表达式内部包含变量字
      符串，就需要使用双引号。

      test=hello
      echo hello WORLD | sed "s/$test/HELLO"
      HELLO WORLD

      选定行的范围：,（逗号）

      所有在模板 test 和 check 所确定的范围内的行都被打印：

      sed -n '/test/,/check/p' file

      打印从第 5 行开始到第一个包含以 test 开始的行之间的所有行：

      sed -n '5,/^test/p' file

      对于模板 test 和 west 之间的行，每行的末尾用字符串 aaa bbb 替换：

      sed '/test/,/west/s/$/aaa bbb/' file

      多点编辑：e 命令

      -e 选项允许在同一行里执行多条命令：

      sed -e '1,5d' -e 's/test/check/' file

      上面 sed 表达式的第一条命令删除 1 至 5 行，第二条命令用 check 替换
      test。命令的执行顺序对结果有影响。如果两个命令都是替换命令
      ，那么第一个替换命令将影响第二个替换命令的结果。

      和 -e 等价的命令是 --expression：

      sed --expression='s/test/check/' --expression='/love/d' file

      从文件读入：r 命令

      file 里的内容被读进来，显示在与 test 匹配的行后面，如果匹配多
      行，则 file 的内容将显示在所有匹配行的下面：

      sed '/test/r file' filename

      写入文件：w 命令  

      在 example 中所有包含 test 的行都被写入 file 里：

      sed -n '/test/w file' example

      追加（行下）：a\命令

      将 this is a test line 追加到以 test 开头的行后面：

      sed '/^test/a\this is a test line' file

      在 test.conf 文件第 2 行之后插入 this is a test line：

      sed -i '2a\this is a test line' test.conf

      插入（行上）：i\命令

      将 this is a test line 追加到以 test 开头的行前面：

      sed '/^test/i\this is a test line' file

      在 test.conf 文件第 5 行之前插入 this is a test line：

      sed -i '5i\this is a test line' test.conf

      下一个：n 命令

      如果 test 被匹配，则移动到匹配行的下一行，替换这一行的 aa，变
      为 bb，并打印该行，然后继续：

      sed '/test/{ n; s/aa/bb/; }' file

      变形：y 命令

      把 1~10 行内所有 abcde 转变为大写，注意，正则表达式元字符不能使
      用这个命令：

      sed '1,10y/abcde/ABCDE/' file

      退出：q 命令

      打印完第 10 行后，退出 sed

      sed '10q' file

      保持和获取：h 命令和 G 命令

      在 sed 处理文件的时候，每一行都被保存在一个叫模式空间的临时缓
      冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将
      打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。

      sed -e '/test/h' -e '$G' file

      在这个例子里，匹配 test 的行被找到后，将存入模式空间，h 命令将
      其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的
      意思是，当到达最后一行后，G 命令取出保持缓冲区的行，然后把它
      放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾
      。在这个例子中就是追加到最后一行。简单来说，任何包含 test 的
      行都被复制并追加到该文件的末尾。

      保持和互换：h 命令和 x 命令

      互换模式空间和保持缓冲区的内容。也就是把包含 test 与 check 的行
      互换：

      sed -e '/test/h' -e '/check/x' file

      脚本 scriptfile

      sed 脚本是一个 sed 的命令清单，启动 Sed 时以-f 选项引导脚本文件名
      。Sed 对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空
      白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行
      为注释行，且不能跨行。

      sed [options] -f scriptfile file(s)

      打印奇数行或偶数行

      方法 1：

      sed -n 'p;n' test.txt  #奇数行
      sed -n 'n;p' test.txt  #偶数行

      方法 2：

      sed -n '1~2p' test.txt  #奇数行
      sed -n '2~2p' test.txt  #偶数行

      打印匹配字符串的下一行

      grep -A 1 SCC URFILE
      sed -n '/SCC/{n;p}' URFILE
      awk '/SCC/{getline; print}' URFILE
***** 修改 更改 
**** emacs 可视化编辑器
**** join 行号及行内文本同，则显示
     按两个文件的相同字段合并
**** tr 替换或删除字符
*** 查找文件内容 grep
*** 改变权限 chmod 
*** 权限 setuid 执行中文件有文件所有者权限  setgid 文件所属组权限
*** grep 文本搜索
     -C 5 foo file  显示 file 文件中匹配 foo 字串那行以及上下 5 行
     -B 5 foo file  显示 foo 及前 5 行
     -A 5 foo file  显示 foo 及后 5 行
     －c：只输出匹配行的计数。
     －I：不区分大 小写(只适用于单字符)。
     －h：查询多文件时不显示文件名。
     －l：查询多文件时只输出包含匹配字符的文件名。
     －n：显示匹配行及 行号。
     －s：不显示不存在或无匹配文本的错误信息。
     －v：显示不包含匹配文本的所有行。
     pattern 正则表达式主要参数：
     \： 忽略正则表达式中特殊字符的原有含义。
     ^：匹配正则表达式的开始行。
     $: 匹配正则表达式的结束行。
     \<：从匹配正则表达 式的行开始。
     \>：到匹配正则表达式的行结束。
     [ ]：单个字符，如[A]即 A 符合要求 。
     [ - ]：范围，如[A-Z]，即 A、B、C 一直到 Z 都符合要求 。
     .：所有的单个字符。
     $ grep ‘test’ d*
     显示所有以 d 开头的文件中包含 test 的行。
     $ grep ‘test’ aa bb cc
     显示在 aa，bb，cc 文件中匹配 test 的行。
     $ grep ‘[a-z]\{5\}’ aa
     显示所有包含每个字符串至少有 5 个连续小写字符的字符串的行。
     $ grep ‘w\(es\)t.*\1′ aa
     如果 west 被匹配，则 es 就被存储到内存中，并标记为 1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个 es(\1)，找到就显示该行。如果用 egrep 或 grep -E，就不用"\"号进行转义，直接写成’w(es)t.*\1′就可以了。

     grep 命令使用复杂实例
     假设您正在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件：
     $ grep magic /usr/src/Linux/Doc/*
     sysrq.txt:* How do I enable the magic SysRQ key?
     sysrq.txt:* How do I use the magic SysRQ key?
     其中文件’sysrp.txt’包含该字符串，讨论的是 SysRQ 的功能。
     默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：
     grep: sound: Is a directory
     这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：
     明确要求搜索子目录：grep -r
     或忽略子目录：grep -d skip
     如果有很多 输出时，您可以通过管道将其转到’less’上阅读：
     $ grep magic /usr/src/Linux/Documentation/* | less
     这样，您就可以更方便地阅读。

     -q 静静地 ，存在则返回 0, 不存在返回 1
     下面还有一些有意思的命令行参数：
     grep -i pattern files：不区分大小写地搜索。默认情况区分大小写，
     grep -l pattern files：只列出匹配的文件名，
     grep -L pattern files：列出不匹配的文件名，
     grep -w pattern files：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
     grep -C number pattern files：匹配的上下文分别显示[number]行，
     grep pattern1 | pattern2 files：显示匹配 pattern1 或 pattern2 的行，
     grep pattern1 files | grep pattern2：显示既匹配 pattern1 又匹配 pattern2 的行。
     grep -n pattern files  即可显示行号信息
     grep -c pattern files  即可查找总行数

*** find 
    find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]
    pathname -options [-print -exec -ok ...]
    关系操作
    -a and
    -or -o or
    -n not 
     : -exec：find 命令对匹配的文件执行该参数所给出的 shell 命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
     : -ok：和-exec 的作用相同，只不过以一种更为安全的模式来执行该参数所给出的 shell 命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
     : -name   按照文件名查找文件。
     : -perm   按照文件权限来查找文件。
     : -prune  使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用-depth 选项，那么-prune 将被 find 命令忽略。
     : -user   按照文件属主来查找文件。
     : -group  按照文件所属的组来查找文件。
     : -mtime -n +n  按照文件的更改时间来查找文件， - n 表示文件更改时间距
     : 现在 n 天以内，+ n 表示文件更改时间距现在 n 天以前。find 命令还有-atime 和-ctime 选项，但它们都和-m time 选项。
     : -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups 中不存在。
     : -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd 中不存在。
     : -newer file1 ! file2  查找更改时间比文件 file1 新但比文件 file2 旧的文件。
     : -iname 忽略大小写
**** -type  查找某一类型的文件，诸如：
     + b - 块设备文件。
     + d - 目录。
     + c - 字符设备文件。
     + p - 管道文件。
     + l - 符号链接文件。
     + f - 普通文件。
**** -size n：[c] 查找文件长度为 n 块的文件，带有 c 时表示文件长度以字节计。
**** -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
**** -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab 中找到，该配置文件中包含了本系统中有关文件系统的信息。
**** -mount：在查找文件时不跨越文件系统 mount 点。
**** -follow：如果 find 命令遇到符号链接文件，就跟踪至链接所指向的文件。
**** -cpio：对匹配的文件使用 cpio 命令，将这些文件备份到磁带设备中。
**** -maxdepth 1 深度  mindepth
**** time
     : -amin n   查找系统中最后 N 分钟访问的文件  -n n 天以内;+n n 天之前
     : -atime n  查找系统中最后 n*24 小时访问的文件
     : -cmin n   查找系统中最后 N 分钟被改变文件状态的文件
     : -ctime n  查找系统中最后 n*24 小时被改变文件状态的文件
     : -mmin n   查找系统中最后 N 分钟被改变文件数据的文件
     : -mtime n  查找系统中最后 n*24 小时被改变文件数据的文件
     : find  ./    -mtime    -1    -type f    -ok   ls -l    {} \;  
     : find .    -perm -007    -exec ls -l {} \;  
     : ! 否定参数
** 系统信息
*** 系统名字 hostname 
*** 日期时间 date calendar
** 任务工具
*** 终止任务 kill  
*** 任务放后台 bg
*** 调到前台 fg
*** 查看任务 ps
** 工具
*** 文本转换 unix2dos dos2unix 
*** 压缩 bzip2  -v 显示文件的详细信息 bzip -v aa.jpg 
*** 改变shell chsh 重登有效 更改的是/etc/passwd 中的shell 内容
*** 屏幕截图
   import -frame window.tif
**** shutter 
     1. 里面的快捷键命令用：shutter -s 或者 shutter –select
     2. 截取当前活动窗口：shutter -a（a 表示 active）
     3. 截取拖拉区域：shutter -s（s 是 select 之意），拖拉出矩形区域后按 Enter。 

*** 中文语音朗读 ekho
   (如果保存不了，是文件属性的问题，就 chmod 755 /etc/shadow，这样就 OK 了)
6. #reboot 重启，root 密码为空
*** info
    -d：添加包含info格式帮助文档的目录；
    -f：指定要读取的info格式的帮助文档；
    -n：指定首先访问的info帮助文件的节点；
    -o：输出被选择的节点内容到指定文件。

    下载info文件 ，在emacs源码提取，然后用gzip 压缩
* 网络
  已知 ip 地址，查主机名最简单的方法就是使用命令，以下是两种方法：
  1、使用 ping 命令加上参数-a 的方法反解析 IP 地址，可以得到主机名。
  2、使用 nbtstat 命令加上-a 参数再加上 IP 地址的方法。
  bunzip2 linux-2.6.13.tar.bz2 | tar xvf -
* 常用命令
** 安装包管理类
   //centos
   yum provides */libgcc_s.so.1    //根据文件名检查所属的包 
   yum search python       //查找与指定关键词相关的包
   yum info python         //查看指定包的信息
   yum list python         //查看指定包的简要信息
   yum install net-tools       //安装指定的包(net-tools 包含 netstat 和 ifconfig 命令)
   yum remove libevent     //删除指定的包
   rpm -ivh xxxx.rpm --test    //安装指定的 rpm 包，加上--test 代表只是测试
   rpm -e --nodeps openjavasdk //强行删除指定的包
   rpm -q python           //查询是否安装了该包
   rpm -ql python          //查询包安装涉及的目录
   rpm -qR python          //显示依赖项目，R=Require

   //ubuntu
   apt-cache show package  //获取包的相关信息，如说明、大小、版本等   
   apt-cache search package    //搜索软件包，同 yum search
   apt-cache showpkg package_name  //显示软件包的依赖关系信息
   apt-cache depends package_name  //显示指定软件包所依赖的软件包。
   sudo dpkg -I iptux.deb#查看 iptux.deb 软件包的详细信息，包括软件名称、版本以及大小等（其中-I 等价于--info）
   sudo dpkg -c iptux.deb#查看 iptux.deb 软件包中包含的文件结构（其中-c 等价于--contents）
   sudo dpkg -i iptux.deb#安装 iptux.deb 软件包（其中-i 等价于--install）
   sudo dpkg -l iptux#查看 iptux 软件包的信息（软件名称可通过 dpkg -I 命令查看，其中-l 等价于--list）
   sudo dpkg -L iptux#查看 iptux 软件包安装的所有文件（软件名称可通过 dpkg -I 命令查看，其中-L 等价于--listfiles）
   sudo dpkg -s iptux#查看 iptux 软件包的详细信息（软件名称可通过 dpkg -I 命令查看，其中-s 等价于--status）
   sudo dpkg -r iptux#卸载 iptux 软件包（软件名称可通过 dpkg -I 命令查看，其中-r 等价于--remove）
   注：dpkg 命令无法自动解决依赖关系。如果安装的 deb 包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。

** 文件管理类
   find 路径 -iname "*.jar" -exec cp {} 目标目录 \;    //find 和 cp 联动操作
** 进程\网络查看类
   ps -aux         //查看所有进程
   pgrep cron      //查询应用是否在运行，成功则返回 pid
   netstat –apn        //查看所有占用了网络端口的应用
   netstat -tl     //参数“-t”是显示 tcp 数据包的连接行为，参数“-l”是显示监听状态。如果"netstat -tl"输出结果如上面代码所示，则说明服务器端 ssh 服务已启动。
   ip addr         //查看 ip 地址
** 后台运行
linux 命令行重定向：在 shell 中，分别用 0，1，2 分别代表标准输入，标准输出，异常输出。 
在 linux 中，有个特殊的文件/dev/null，向其写入数据都会被丢弃。

 nohup ./startWebLogic.sh &  //让程序在后台运行，输出文件为 nohup.out
 nohup command > myout.file 2>&1 &   //输出文件重定向为 myout.file
 nohup command >/dev/null 2>$1 &    //×××忽略所有输出，重要×××
 jobs -l               //查看当前正在运行的 job
 fg %s                 //关闭指定的 job
** 定时运行
cron 是 linux 中用于处理定时任务的工具，关键信息格式：分时日月周

分钟　（0-59） 
小时　（0-23） 
日期　（1-31） 
月份　（1-12） 
星期　（0-7）//0 7 代表星期天 #周月日不可同时存在，否则语法错误。

*/3 * * * *    ls       #   每三分钟执行一次 ls

crontab -e      //编辑当前用户的 cron 任务
crontab -l      //列出当前用户的 cron 任务
crontab -r      //删除当前任务的 cron 任务

service crond start|stop|restart|reload //对 cron 服务进行控制

系统定时任务配置

目录位置	描述
/etc/cron.hourly	目录下的脚本会每个小时让执行一次，在每小时的 17 分钟时运行；
/etc/cron.daily	目录下的脚本会每天让执行一次，在每天的 6 点 25 分时运行；
/etc/cron.weekly	目录下的脚本会每周让执行一次，在每周第七天的 6 点 47 分时运行；
/etc/cron.mouthly	目录下的脚本会每月让执行一次，在每月 1 号的 6 点 52 分时运行；
** 创建快捷方式
linux 的快捷方式都存放于 /usr/share/applications，后缀名为.desktop,范例如下：

[Desktop Entry]
Name=eclipse
Comment=eclipse ide
Exec=/opt/eclipse_j2ee/eclipse
Icon=/opt/eclipse_j2ee/icon.xpm
Terminal=false
Type=Application
Categories=Application;Development;
StartupNotify=true
** 清理空间
   BleachBit
** 清理 boot 内核
ubuntu 使用时间长了后，积累了不少已经过期的内核，导致 boot 区不够用。
#查询
dpkg --get-selections |grep linux-image
#查看当前内核版本
uname -a
#清理指定版本内核（重要：可别把当前版本给清理了）
sudo apt-get purge linux-image-3.5.0-17-generic
#也可以使用自动删除(比较安全，定期执行下即可)
sudo apt-get autoremove

** 修改 ip 地址
ip addr #查看当前的 ip 地址
cat /etc/resolv.conf    #查看 dns 网络地址
vim /etc/sysconfig/network-scripts/ifcfg-exxx   #编辑网卡配置文件

BOOTPROTO="static" 网卡获得 ip 地址的方式，static（静态 ip 地址）dhcp（通过 dhcp 协议获取 ip）
IPADDR="192.168.211.144"
GATEWAY="192.168.211.2" #重要：虚拟机 linux 设静态 ip 必须设置 Gateway，而且一定指向 x.x.x.2 那个地址
ONBOOT="yes" 系统启动时是否设置此网络接口，设置为 yes 时，系统启动时激活此设备。默认设置为 yes
 * 企业运维命令
** 文件和目录操作命令(18 个)
ls 全拼 list，功能是列出目录的内容及其内容属性信息。
cd 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。
cp 全拼 copy，其功能为复制文件或目录。
find 查找的意思，用于查找目录及目录下的文件。
mkdir 全拼 make directories，其功能是创建目录。
mv 全拼 move，其功能是移动或重命名文件。
pwd 全拼 print working directory，其功能是显示当前工作目录的绝对路径。
rename 用于重命名文件。
rm 全拼 remove，其功能是删除一个或多个文件或目录。
rmdir 全拼 remove empty directories，功能是删除空目录。
touch 创建新的空文件，改变已有文件的时间戳属性。
tree 功能是以树形结构显示目录下的内容。
basename 显示文件名或目录名。
dirname 显示文件或目录路径。
chattr 改变文件的扩展属性。
lsattr 查看文件扩展属性。
file 显示文件的类型。
md5sum 计算和校验文件的 MD5 值。
** 查看文件及内容处理命令（21 个） 
cat 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。
tac tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。
more 分页显示文件内容。
less 分页显示文件内容，more 命令的相反用法。
head 显示文件内容的头部。
tail 显示文件内容的尾部。
cut 将文件的每一行按指定分隔符分割并输出。
split 分割文件为不同的小片段。
paste 按行合并文件内容。
sort 对文件的文本内容排序。
uniq 去除重复行。oldboy
wc 统计文件的行数、单词数或字节数。
iconv 转换文件的编码格式。
dos2unix 将 DOS 格式文件转换成 UNIX 格式。
diff 全拼 difference，比较文件的差异，常用于文本文件。
vimdiff 命令行可视化文件比较工具，常用于文本文件。
rev 反向输出文件内容。
grep/egrep 过滤字符串，三剑客老三。
join 按两个文件的相同字段合并。
tr 替换或删除字符。
vi/vim 命令行文本编辑器。
** 文件压缩及解压缩命令（4 个）
   tar 打包压缩。
   unzip 解压文件。
   unzip -O CP936 xxx.zip (用GBK, GB18030也可以)
   gzip gzip 压缩工具。
   zip 压缩工具。
** 信息显示命令（11 个）
   uname 显示操作系统相关信息的命令。
   hostname 显示或者设置当前系统的主机名。
   dmesg 显示开机信息，用于诊断系统故障。
   uptime 显示系统运行时间及负载。
   stat 显示文件或文件系统的状态。
   du 计算磁盘空间使用情况。
   df 报告文件系统磁盘空间的使用情况。
   top 实时显示系统资源使用情况。
   free 查看系统内存。
   date 显示与设置系统时间。
   cal 查看日历等时间信息。
** 搜索文件命令（4 个） 
which 查找二进制命令，按环境变量 PATH 路径查找。
find 从磁盘遍历查找文件或目录。
whereis 查找二进制命令，按环境变量 PATH 路径查找。
locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。
** 用户管理命令（10 个） 
useradd 添加用户。 
usermod 修改系统已经存在的用户属性。
userdel 删除用户。 
groupadd 添加用户组。
passwd 修改用户密码。
chage 修改用户密码有效期限。
id 查看用户的 uid,gid 及归属的用户组。
su 切换用户身份。
visudo 编辑/etc/sudoers 文件的专属命令。
sudo 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。

** 基础网络操作命令（11 个）
telnet 使用 TELNET 协议远程登录。
ssh 使用 SSH 加密协议远程登录。
scp 全拼 secure copy，用于不同主机之间复制文件。
wget 命令行下载文件。

ping

测试主机之间网络的连通性。

route

显示和设置 linux 系统的路由表。

ifconfig

查看、配置、启用或禁用网络接口的命令。

ifup

启动网卡。

ifdown

关闭网卡。

netstat

查看网络状态。

ss

查看网络状态。

深入网络操作命令（9 个）

nmap

网络扫描命令。

lsof

全名 list open files，也就是列举系统中已经被打开的文件。

mail

发送和接收邮件。

mutt

邮件管理命令。

nslookup

交互式查询互联网 DNS 服务器的命令。

dig

查找 DNS 解析过程。

host

查询 DNS 的命令。

traceroute

追踪数据传输路由状况。

tcpdump

命令行的抓包工具。

有关磁盘与文件系统的命令（16 个）

mount

挂载文件系统。

umount

卸载文件系统。

fsck

检查并修复 Linux 文件系统。

dd

转换或复制文件。

dumpe2fs

导出 ext2/ext3/ext4 文件系统信息。

dump

ext2/3/4 文件系统备份工具。

* parted
磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。

mkfs

格式化创建 Linux 文件系统。

partprobe

更新内核的硬盘分区表信息。

e2fsck

检查 ext2/ext3/ext4 类型文件系统。

mkswap

创建 Linux 交换分区。

swapon

启用交换分区。

swapoff

关闭交换分区。

sync

将内存缓冲区内的数据写入磁盘。

resize2fs

调整 ext2/ext3/ext4 文件系统大小。

系统权限及用户授权相关命令（4 个）

chmod

改变文件或目录权限。

chown

改变文件或目录的属主和属组。

chgrp

更改文件用户组。

umask

显示或设置权限掩码。

查看系统用户登陆信息的命令（7 个）

whoami

显示当前有效的用户名称，相当于执行 id -un 命令。

who

显示目前登录系统的用户信息。

w

显示已经登陆系统的用户列表，并显示用户正在执行的指令。

last

显示登入系统的用户。

lastlog

显示系统中所有用户最近一次登录信息。

users

显示当前登录系统的所有用户的用户列表。

finger

查找并显示用户信息。

内置命令及其它（19 个）

echo

打印变量，或直接输出指定的字符串

printf

将结果格式化输出到标准输出。

rpm

管理 rpm 包的命令。

yum

自动化简单化地管理 rpm 包的命令。

watch

周期性的执行给定的命令，并将命令的输出以全屏方式显示。

alias

设置系统别名。

unalias

取消系统别名。

date

查看或设置系统时间。

clear

清除屏幕，简称清屏。

history

查看命令执行的历史纪录。

eject

弹出光驱。

time

计算命令执行时间。

nc

功能强大的网络工具。

xargs

将标准输入转换成命令行参数。

exec

调用并执行指令的命令。

export

设置或者显示环境变量。

unset

删除变量或函数。

type

用于判断另外一个命令是否是内置命令。

bc

命令行科学计算器

系统管理与性能监视命令(9 个)

chkconfig

管理 Linux 系统开机启动项。

vmstat

虚拟内存统计。

mpstat

显示各个可用 CPU 的状态统计。

iostat

统计系统 IO。

sar

全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、CPU 中断和网络等性能数据。

ipcs

用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。

ipcrm

用来删除一个或更多的消息队列、信号量集或者共享内存标识。

strace

用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。

ltrace

命令会跟踪进程的库函数调用,它会显现出哪个库函数被调用。

关机/重启/注销和查看系统信息的命令（6 个）

shutdown

关机。

halt

关机。

poweroff

关闭电源。

logout

退出当前登录的 Shell。

exit

退出当前登录的 Shell。

Ctrl+d

退出当前登录的 Shell 的快捷键。

进程管理相关命令（15 个）

bg

将一个在后台暂停的命令，变成继续执行  （在后台执行）。

fg

将后台中的命令调至前台继续运行。

jobs

查看当前有多少在后台运行的命令。

kill

终止进程。

killall

通过进程名终止进程。

pkill

通过进程名终止进程。

crontab

定时任务命令。

ps

显示进程的快照。

pstree

树形显示进程。

nice/renice

调整程序运行的优先级。

nohup

忽略挂起信号运行指定的命令。

pgrep

查找匹配条件的进程。

runlevel

查看系统当前运行级别。

init

切换运行级别。

service

启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。

** 虚拟机
*** qemu 
    qemu-system-i386 qemu-system-x86_64
**** 安装qemu kvm
     $:apt install qemu kvm qemu-kvm

     由于kvm需要CPU硬件支持，使用lscpu查看cpu是否指出vx-d or vx-t，其次要在bios使能
     kvm，使用kvm-ok查看是否在bios中打开了kvm支持，其次是将kernel中kvm相关的feature打
     开，这些都可以在kvm-ok的输出中得到信息。如果kernel中没有打开就需要重新编译kernel
     并重启机器。
     
    源码安装 
     $ tar -zxvf qemu-0.14.0.tar.gz
     $ cd qemu-0.14.0

    运行配置脚本。我们将针对 i386 架构进行编译。 (它也可为其他架构编译，如 ARM、PPC、
    SPARC 等。) 接下来我们要在虚拟机里面安装 Ubuntu 发行版——这就是我们为什么选择针对
    i386 架构编译 QEMU：

    $ ./configure –target-list=i386-softmmu

**** KVM虚拟机 
     Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之
     后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于
     Xen，其核心源码很少。KVM目前已成为学术界的主流VMM之一。KVM的虚拟化需要硬件支持
     （如Intel VT技术或者AMD V技术)。是基于硬件的完全虚拟化。而Xen早期则是基于软件模
     拟的Para-Virtualization，新版本则是基于硬件支持的完全虚拟化。但Xen本身有自己的进
     程调度器，存储管理模块等，所以代码较为庞大。广为流传的商业系统虚拟化软件VMware
     ESX系列是基于软件模拟的Full-Virtualization。
***** 安装方法
      一、安装准备
      1.确定机器有VT
      终端输入命令： grep vmx /proc/cpuinfo (INTEL芯片)
 grep svm /proc/cpuinfo (AMD芯片)
 不知道芯片的生产厂商则输入：egrep '(vmx|svm)' /proc/cpuinfo
 如果flags: 里有vmx 或者svm就说明支持VT；如果没有任何的输出，说明你的cpu不支持，将无法成功安装KVM虚拟机。
 2. 确保BIOS里开启VT
 Intel(R) Virtualization Tech [Enabled]
 如有必要，还需在BIOS中开启VT-d
 3. 确保内核版本较新，支持KVM
 用uname -r查看内核版本，如果在2.6.20以下的linux版本，需升级内核。
*****  二、安装KVM
 下面就Ubuntu和CentOS下安装使用KVM虚拟机做介绍：
 Ubuntu 中用guest登陆，安装KVM的命令为：
 sudo apt-get install kvm qemu qemu-kvm virt-manager kernel-package linux-source kqemu-source build-essential
 kvm安装成功后会有/dev/kvm，如果无需图形管理器，只需要安装前三个即可。
 再来查看下KVM是否安装成功,执行：virsh -c qemu:///system list
 如果输入结果像下面这样的，那么成功了：
 Connecting to uri: qemu:///system
 Id Name State
 ----------------------------------
 注1：CentOS中安装时，先要选择Selinux为enable，使用命令
 #system-config-securitylevel-tui
 可查看或修改selinux的状态。
 注2: CentOS中用root登陆时则安装命令为：
 yum install kvm kmod-kvm qemu
 再装入kvm模块：modprobe kvm-intel (Intel机器) 或者 modprobe kvm-amd (amd机器)
 注3：可以用以下命令来检查是否装入kvm模块：
 /sbin/lsmod | grep kvm
 如果输出关于kvm版本的信息则已装入kvm模块
 注4: 安装好后，可使用qemu-kvm命令，输入该命令，如果系统显示未知的命令，可查看/usr/libexec中是否有qemu-kvm可执行文件，如果有，将其拷贝到/bin目录下即可。如果确实按照上面的步骤进行了，却在/bin，/usr/libexec，/usr/bin，/usr/sbin里都找不到qemu-kvm可执行文件，可执行以下命令：
 #yum provides "*/qemu-kvm"
 注5：安装新内核后，可能有部分软件版本过低，不兼容。比如firefox因版本过低，无法启动。
 CentOS下可使用如下命令更新该软件(以firefox为例)：
 #yum update firefox
 三、在KVM下安装虚拟机
 1.用QEMU创建磁盘镜像
 sudo qemu-img create –f qcow windows.img 8G
 注：在CentOS和新版Qemu中为：qemu-img create –f qcow2 windows.img 8G
 2.使用KVM安装Guest VM
 光盘安装：
 sudo kvm –localtime –cdrom /dev/cdrom -m 512 -boot d win2.img
 硬盘安装：
 sudo kvm –localtime –m 512 –hda windows.img –cdrom winxp.iso –boot d –clock –rtc –no-acpi
 注：官方推荐使用 -no-acpi 参数，原因是 qemu/kvm不太支持，可能造成 cpu 的占用偏高。
 注1：CentOS下硬盘安装为 qemu-kvm –localtime –m 512 –hda windows.img –cdrom winxp.iso –boot d –no-acpi 即需要去掉了-clock rtc选项，否则会出现无法初始化时钟。
 注2：CentOS quest mouse: export SDL_VIDEO_X11_DGAMOUSE=0可解决VM中无法识别USB鼠标的问题。
 注3: 安装win 7时，不能使用-no-acpi选项。
 使用编辑
 KVM启动Guest
 ① sudo kvm –boot c –m 512
 –hda windows.img
 ② sudo kvm -boot c
 -m 512
 -hda /home/lm/kvm/winxp.img
 -localtime
 -net nic,vlan=0,macaddr=52-54-00-12-34-01 -net tap,vlan=0,df=h,ifname=tap0,script=no
 -clock rtc
 -soundhw es1370
 -smp 2
 注意：在KVM－87下，请去掉df=h
 -m 512 分配512MB的内存
 -hda /home/lm/kvm/winxp.img
 -localtime 使用本地时间（一定要加这个参数，不然虚拟机时间会有问题）
 -net nic,vlan=0,macaddr=52-54-00-12-34-01 -net tap,vlan=0,df=h,ifname=tapo,script=no
 使用网络，并连接到一个存在的网络设备tap0,注意mac地址一定要自己编一个，特别是如果你虚拟了多个系统并且要同时运行的话，不然就MAC冲突了，在KVM－87下去掉df=h
 -boot d 从光盘启动 （从镜像启动也是用这个。从硬盘启动则为 -boot c )
 -smp 2 smp处理器个数为2个，如果你是4核处理器，后面的数字就为4
 -clock rtc
 使用rtc时钟（如果不开启此选项，WINXP可能会很慢）
**** 1.命令参数: 
     -L dir :指向 BIOS 和 VGA BIOS 所在目录(一般我们使用”-L .”) 

     -hda/-hdb/-hdd/-hdc “文件名” :虚拟机系统安装文件 

     -cdrom “文件名” :使用“文件名”作为光盘景象（文件应该是 ISO 类型） 
     *Windows 下，可以通过下列命令使用实体光盘: -cdrom //./x: -> x 代表光盘名称/位置
     例如:-cdrom //./e: -> 使用 E:\ 为光盘* 

     -fda/-fdb “文件名” :使用“文件名”作为磁盘 0/1 镜像. 

     -boot [a|b|c] :使用磁盘 a，光盘 d，或者硬盘 c 启动. 
     
     -m 容量 :指定内存的大小，单位是 MB. 

     -soundhw c1,„: 使用声卡设备. 

     -soundhw ? :列出所有可使用的声卡 -soundhw all 使用全部声卡 

     -usb :允许使用 usb 设备. 

     -usbdevice :名字 添加一个 usb 设备“名字”. 

     -net nic :创建一块新的网卡. 
**** 3.1.打开 CMD 窗口,切到 F 盘的 qemu 程序目录下.然后输入命令: 
     创建虚拟磁盘 
     qemu-img create -f qcow f:\system-virtual\windowsxp\windowsxp.img 8G  

     create 参数表示创建 windowsxp 所需的虚拟磁盘 

     -f 参数表示创建文件格式，后边所带的子参数 qcow 表示 qemu 镜像格式 

     f:\system-virtual\windowsxp\windowsxp.img 为虚拟磁盘文件放置路径及名称 
     
     8G 为所创建虚拟机文件的上限大小，也就是虚拟机的硬盘大小 

建议大家不要创建 qcow 格式的磁盘文件.它生成的磁盘文件比较占用空间.该命令是常规命

令.兜兜建议使用 VMWare 的磁盘文件来安装虚拟系统.命令如下: 
qemu-img create -f vmdk f:\system-virtual\windowsxp\windowsxp.vmdk 8G 

两种创建方式,在使用的过程中没有很大区别,唯一的区别在于磁盘占用率上.随各位自己喜欢咯. 

 3.2.好了.给虚拟系统的硬盘分区已经分割好了.什么?什么时候分割的?晕!上面那

一步创建虚拟磁盘文件就是为新的系统准备空间啊!接下来开始安装系统了.大家可以

简单回想一下,在裸机或者 vmware 中安装新系统,需要拿些东西? 

光驱,指定内存大小,指定硬盘空间„.需要指定 USB,声卡..等等吗?暂时不需要的.看下面

这段安装时候要用到的命令吧. 
安装系统
qemu.exe -kernel-kqemu -L . -m 512 -hda f:\system-virtual\windowsxp\windowsxp. 
vmdk -cdrom e:\my-lab\iso\windowsxp-en.iso -boot d 

-kernel-kqemu 加快 qemu 速度 

-m 512 为虚拟机分配 512m 内存 

 -hda f:\system-virtual\windowsxp\windowsxp.vmdk 系统安装到哪里去,就安装

到刚才建立的虚拟磁盘文件中去 

 -cdrom e:\my-lab\iso\windowsxp-en.iso 为 qemu 的虚拟光驱中插入光盘镜像 

 -boot d 设置 qemu 的 BIOS 由光驱启动. 

把这段命令输入到记事本里,然后保存在 qemu for win 程序的根目录里.命名为:Install w

indowsxp.bat .完全是为了方便才这样的,如果你不嫌麻烦,你可以直接进入 CMD,切到 qemu

 for win 的目录下,输入那一段命令,就会弹出窗口,开始 windowsxp 的安装过程了. 

安装的问题,兜兜就不赘述了.这里要注意的是,当你把鼠标定位到了虚拟 windowsxp 窗口中,

要把鼠标释放出来,需要按组合键: ctrl+alt

4
4.安装过程完毕了.关闭虚拟机.你可以直接XX关闭,建议按照windows的正常关机流程来操

作,当虚拟系统关闭,窗口也会消失.接下来,该编写虚拟系统运行的命令了.同样的,建议使

用批处理的方式.免得每次要启动系统都需要输入一大串命令. 

命令其实和安装雷同.如下: 

qemu.exe -kernel-kqemu -L . -m 512 -hda f:\system-virtual\windowsxp\windowsxp.

vmdk -boot c 

保存到 qemu for win 程序目录下,命名为:start windowsxp.bat 

如果你想挂载光驱,在命令里补上-cdrom 就可以了.当然,你如果需要挂载其他的硬件设备,

加上相应的参数即可.参数在文上部有说明. 

 

END
经验内容仅供参考，如果您需解决具体问题(尤其法律、医学等领域)，建议您详细咨询相关领域专业人士。举报
投票(0)
有得(0)
我有疑问(0)  
**** 创建新虚拟机
     如果你熟悉其他的虚拟化软件，你可能好奇如何使用 QEMU 创建一个新的虚拟机。第一步是
     为虚拟机创建一个硬盘镜像。然后就可以安装 Ubuntu 9.10 了；这里我们创建一个 10GB
     的硬盘镜像就足够了。使用以下命令创建：

     $ qemu-img create ubuntu.img 10G
     $ ls -lh ubuntu.img
     -rw-r--r--. 1 root root 10G Mar 11 11:54 ubuntu.img

     下一步是安装 Ubuntu (我已经下载好了 Ubuntu 9.10 (Karmic) 的 ISO 镜像，放在我的工
     作目录下) ：

     $ qemu -hda ubuntu.img -boot d -cdrom ./ubuntu-9.10-desktop-i386.iso -m 512
     
     $ qemu-system-x86_64 -hda ubuntu.img -boot d -cdrom ./ubuntu-9.10-desktop-i386.iso -m 512
     
     在上面的命令中，-hda 选项用来指定磁盘镜像文件；-cdrom 用来指定 CD-ROM 或者
     ISO 镜像来作为虚拟机的光驱。-m 选项指定虚拟机所使用的内存大小 (此种情况下，
     内存大小我申请为 512MB；你可以根据自己的需要和硬件状况来决定) 。最后，我们
     使用 -boot d 选项让 QEMU 从 ISO 镜像启动虚拟机。运行上述命令后，虚拟机启动，
     然后出现 Ubuntu 启动菜单 (见图2) 。

     下面就像你在真机上安装系统一样的操作。安装完成后，你可以直接使用以下命令从硬盘镜
     像启动虚拟机。
     
     启动虚拟机
     $ qemu -m 512 -hda ubuntu.img

**** QEMU 网络设置
     设置 QEMU 虚拟机的网络是很麻烦的事情。我们使用与硬件以太网设备不同的内核虚拟网络
     设备 TAP 和 TUN；TAP 和 TUN 只有内核支持 (如，只在软件中) 。TAP 工作在数据链层，
     而 TUN 工作在网络层。

     QEMU 可以使用 TAP 接口为虚拟机提供完整的网络支持。在此之前，我们需要在宿主机上安
     装 VPN (虚拟专用网) 软件包，然后在 host 和 guest 之间建立桥接。安装 openvpn 和
     bridge-utils 软件包：

     $ yum install openvpn
     $ yum install bridge-utils
     
     现在，用以下内容创建 qemu—qemu-ifup 和 qemu-ifdown 两个脚本：

#qemu-ifup
/sbin/ifconfig eth1 down
/sbin/ifconfig eth1 0.0.0.0 promisc up
openvpn --mktun --dev tap0
ifconfig tap 0 0.0.0.0 up
brctl addbr br0
brctl addif br0 eth1
brctl addif br0 tap0
brctl stp br0 off
ifconfig br0 10.10.10.2 netmask
255.255.255.0

上面这个脚本用来开启 QEMU 网络设置，第一行，禁用 Ethernet 设备，由于 Ethernet 接
口是桥接网络的一部分，所以我们在第二行将其 IP 地址设置为 0.0.0.0。在第三、四行，
我们创建了并且启动了 TAP/tap0。下面几步，使用 eth1 和 tap0 创建桥接。最后，给桥
指定一个 IP 地址。

下面是 qemu-ifdown 脚本：
#qemu-ifdown
ifconfig eth1 down
ifconfig eth1 -promisc
ifup eth1
ifconfig br0 down
brctl delbr br0
openvpn --rmtun --dev tap0
这个脚本用来关闭 QEMU 网络；见文知义，关闭两个接口，删除网桥，和 tap0 设备。

把这两个脚本复制到你的 /etc 目录下，然后进行测试：

$ /etc/qemu-ifup
Wed Apr 6 15:53:50 2011 TUN/TAP device tap0 opened
Wed Apr 6 15:53:50 2011 Persist state set to: ON
$ ifconfig br0
br0       Link encap:Ethernet HWaddr 00:25:11:74:5B:0C
          inet addr:10.10.10.2 Bcast:10.10.10.255 Mask:255.255.255.0
          inet6 addr: fe80::225:11ff:fe74:5b0c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:29 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 b)  TX bytes:7539 (7.3 KiB)
$ ifconfig tap0
tap0      Link encap:Ethernet HWaddr C2:10:27:8C:B8:35
          UP BROADCAST MULTICAST MTU:1500 Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
虚拟设备 tap0 和网桥 br0 都启动了，脚本运行正常。

1
2
3
4
$ /etc/qemu-ifdown
Error: Connection activation failed: Device not managed by NetworkManager
Wed Apr 6 15:56:44 2011 TUN/TAP device tap0 opened
Wed Apr 6 15:56:44 2011 Persist state set to: OFF
一切设置正常；是时候启动完整网络支持的 Ubuntu 虚拟机了。
开启网络 (使用 root 用户) ：

1
$ /etc/qemu-ifup
然后启动虚拟机 (使用普通用户) :

$ qemu -m 512 -hda ubuntu.img -net nic -net tap,ifname=tap0,script=no
当机器启动之后，在虚拟机里设置 eth0 接口的IP地址：

$ sudo ifconfig eth0 10.10.10.100 netmask 255.255.255.0
试着 ping 以下网桥的 IP (结果见图4) ：

$ ping 10.10.10.2
 
图4：QEMU 使用内核网络虚拟设备

现在虚拟机的网络正常了，可以做一些实验了。试着在 host 上建立一个代理服务器，然后
从 guest 连接到网络。
**** QEMU是一款高效而实用的模拟器及虚拟机监管器，本系列博客试图从最基本的安装使用开始，逐层深入地介绍QEMU。本篇文章从QEMU最基础的知识讲起，介绍了QEMU的安装使用、系统模拟的基本原理以及如何利用QEMU来创建和管理虚拟机。
QEMU 虚拟化
一、QEMU简介
QEMU是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)。QEMU主要提供两种功能给用户使用。一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。二是作为虚拟机监管器，模拟全系统，利用其他VMM(Xen, KVM, etc)来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。

用户可以通过不同Linux发行版所带有的软件包管理器来安装QEMU。如在Debian系列的发行版上可以使用下面的命令来安装：

sudo apt-get install qemu

或者在红帽系列的发行版上使用如下命令安装：

sudo yum install qemu -y

除此之外，也可以选择从源码安装。

获取QEMU源码
可以从QEMU官网上下载QEMU源码的tar包，以命令行下载2.0版本的QEMU为例：

$wget http://wiki.qemu-project.org/download/qemu-2.0.0.tar.bz2
$tar xjvf qemu-2.0.0.tar.bz2
如果需要参与到QEMU的开发中，最好使用Git获取源码：

$git clone git://git.qemu-project.org/qemu.git

编译及安装
获取源码后，可以根据需求来配置和编译QEMU。

$cd qemu-2.0.0 //如果使用的是git下载的源码，执行cd qemu
$./configure --enable-kvm --enable-debug --enable-vnc --enable-werror  --target-list="x86_64-softmmu"
$make -j8
$sudo make install
configure脚本用于生成Makefile，其选项可以用./configure --help查看。这里使用到的选项含义如下：

--enable-kvm：编译KVM模块，使QEMU可以利用KVM来访问硬件提供的虚拟化服务。
--enable-vnc：启用VNC。
--enalbe-werror：编译时，将所有的警告当作错误处理。
--target-list：选择目标机器的架构。默认是将所有的架构都编译，但为了更快的完成编译，指定需要的架构即可。
二、基本原理
QEMU作为系统模拟器时，会模拟出一台能够独立运行操作系统的虚拟机。如下图所示，每个虚拟机对应主机(Host)中的一个QEMU进程，而虚拟机的vCPU对应QEMU进程的一个线程。

QEMU结构图

系统虚拟化最主要是虚拟出CPU、内存及I/O设备。虚拟出的CPU称之为vCPU，QEMU为了提升效率，借用KVM、XEN等虚拟化技术，直接利用硬件对虚拟化的支持，在主机上安全地运行虚拟机代码(需要硬件支持)。虚拟机vCPU调用KVM的接口来执行任务的流程如下(代码源自QEMU开发者Stefan的技术博客)：

open("/dev/kvm")
ioctl(KVM_CREATE_VM)
ioctl(KVM_CREATE_VCPU)
for (;;) {
     ioctl(KVM_RUN)
     switch (exit_reason) {
     case KVM_EXIT_IO:  /* ... */
     case KVM_EXIT_HLT: /* ... */
     }
}
QEMU发起ioctrl来调用KVM接口，KVM则利用硬件扩展直接将虚拟机代码运行于主机之上，一旦vCPU需要操作设备寄存器，vCPU将会停止并退回到QEMU，QEMU去模拟出操作结果。

虚拟机内存会被映射到QEMU的进程地址空间，在启动时分配。在虚拟机看来，QEMU所分配的主机上的虚拟地址空间为虚拟机的物理地址空间。

QEMU在主机用户态模拟虚拟机的硬件设备，vCPU对硬件的操作结果会在用户态进行模拟，如虚拟机需要将数据写入硬盘，实际结果是将数据写入到了主机中的一个镜像文件中。

三、创建及使用虚拟机
命令行创建及启动虚拟机
成功安装QEMU之后便可创建自己的虚拟机。具体步骤如下：

1, 使用qemu-img创建虚拟机镜像。虚拟机镜像用来模拟虚拟机的硬盘，在启动虚拟机之前需要创建镜像文件。

[kelvin@kelvin tmp]$ qemu-img create -f qcow2 fedora.img 10G
Formatting 'fedora.img', fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off 
[kelvin@kelvin tmp]$ ls
fedora.img
-f选项用于指定镜像的格式，qcow2格式是QEMU最常用的镜像格式，采用写时复制技术来优化性能。fedora.img是镜像文件的名字，10G是镜像文件大小。镜像文件创建完成后，可使用qemu-system-x86来启动x86架构的虚拟机：

qemu-system-x86_64 fedora.img

此时会弹出一个窗口来作为虚拟机的显示器，显示内容如下：

QEMU虚拟机显示器输出

因为fedora.img中并未给虚拟机安装操作系统，所以会提示“No bootable device”，无可启动设备。

2, 准备操作系统镜像。

可以从不同Linux发行版的官方网站上获取安装镜像，以fedora20为例：

[kelvin@kelvin tmp]$ wget http://ftp6.sjtu.edu.cn/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso

3, 检查KVM是否可用。

QEMU使用KVM来提升虚拟机性能，如果不启用KVM会导致性能损失。要使用KVM，首先要检查硬件是否有虚拟化支持：

[kelvin@kelvin ~]$ grep -E 'vmx|svm' /proc/cpuinfo

如果有输出则表示硬件有虚拟化支持。其次要检查kvm模块是否已经加载：

[kelvin@kelvin ~]$ lsmod | grep kvm
kvm_intel             142999  0 
kvm                   444314  1 kvm_intel
如果kvm_intel/kvm_amd、kvm模块被显示出来，则kvm模块已经加载。最后要确保qemu在编译的时候使能了KVM，即在执行configure脚本的时候加入了–enable-kvm选项。

4, 启动虚拟机安装操作系统。

执行下面的命令启动带有cdrom的虚拟机：

[kelvin@kelvin tmp]$ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img -cdrom ./Fedora-Live-Desktop-x86_64-20-1.iso

-m 指定虚拟机内存大小，默认单位是MB， -enable-kvm使用KVM进行加速，-cdrom添加fedora的安装镜像。可在弹出的窗口中操作虚拟机，安装操作系统，安装完成后重起虚拟机便会从硬盘(fedora.img)启动。之后再启动虚拟机只需要执行：

[kelvin@kelvin tmp]$ qemu-system-x86_64 -m 2048 -enable-kvm fedora.img

即可。

图形界面创建及启动虚拟机
命令行启动虚拟机比较繁琐，适合开发者，但对于普通用户来说，采用图形界面管理虚拟机则更为方便。采用图形界面管理QEMU虚拟机需要安装virt-manager，红帽系列的发行版只需要执行命令：

$sudo yum install virt-manager -y

安装完成后用root用户启动virt-manager：

$su -
*** 安装语句：

$ sudo apt-get install qemu

安装之后终端输入qemu进行测试，如果可行，则表明安装成功，如果不可行，需要注意，再输入qemu-system-i386进行测试，如果这个可行，表明安装成功，为了后期方便使用，我们对其进行链接，语句如下：
$ sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu


此时我们可以在终端下输入qemu进行使用了，此处需要注意qemu需要在图形界面下使用，否则会报如下错误：

Could not initialize SDL(No available video device) - exiting
--------------------- 
作者：夜月xl 
来源：CSDN 
原文：https://blog.csdn.net/u013045749/article/details/53575639 
版权声明：本文为博主原创文章，转载请附上博文链接！
*** 在x86上用qemu起虚拟机是比较容易的。qemu是一款可以从ISA(instructure system arch）开始模拟硬件架构的工具。比如在x86上可以模拟arm架构的机器，它可以不断将guest虚拟机需要的机器指令转换成host指令来模拟不同架构。因此它的性能相当差。因此一般通过联合kvm这种半虚拟化工具达到提高性能的目的，一般有kvm加持的虚拟机速度堪比host。

1 安装qemu kvm

$:apt install qemu kvm qemu-kvm

由于kvm需要CPU硬件支持，使用lscpu查看cpu是否指出vx-d or vx-t，其次要在bios使能
kvm，使用kvm-ok查看是否在bios中打开了kvm支持，其次是将kernel中kvm相关的feature打
开，这些都可以在kvm-ok的输出中得到信息。如果kernel中没有打开就需要重新编译kernel
并重启机器。

2 下载Ubuntu 镜像文件

百度或谷歌搜索Ubuntu cloud imge可以找到下载点，下载x86的ubuntu*.iso 或者 disk镜像。这里推荐iso镜像因为不知道disk起来后的用户名和密码。

3 创建磁盘

$:qemu-img create -q -f qcow2 ubuntu.img 10G

这样就可以创建一个qemu可用的磁盘文件作为虚拟机的磁盘使用。

4 安装虚拟机

$:qemu-system-x86_64 -m 1024 -cdrom ubuntu*.iso --enable-kvm ubuntu.img 

上面的iso镜像相当于光盘，上面的操作是给虚拟机的磁盘装系统，装好后Ubuntu.img 就可以当作含有系统的硬盘正常启动了，安装过程与给真是的物理机安装系统一样，非常简单。

5启动虚拟机

$:qemu-system-x86_64 -m 1024 --enable-kvm ubuntu.img

这样就可以正常启动虚拟机了，因为有kvm的帮助，启动速冻非常快。enjoy！
--------------------- 
* ubuntu自定义登录xsession和桌面环境
linux
查看系统内置的xsession

$ ls /usr/share/xsessions/
gnome-classic.desktop  gnome-fallback.desktop  ubuntu-2d.desktop  xsession.desktop
gnome.desktop          gnome-shell.desktop     ubuntu.desktop     xterm.desktop
修改默认登陆的xsession

$ sudo vim /etc/lightdm/lightdm.conf
[SeatDefaults]
greeter-session=unity-greeter
user-session=ubuntu    #修改为如上的xsession即可
……
切换X管理程序
以下命令需要远程操作，因为停止X管理程序会导致黑屏

$ sudo apt-get install gdm
$ sudo dpkg-reconfigure gdm  #切换显示管理器(将lightdm换为gdm)
$ sudo /etc/init.d/lightdm stop  #注意此时会黑屏
$ ps -ef | grep Xorg         #找到Xorg的进程，并kill之
$ sudo /etc/init.d/gdm start #然后就会发现桌面恢复了
启用XDMCP登陆
根据Ubuntu的官方WIKI介绍，Ubuntu12.04以后的版本，默认使用lightdm作为X Server程序

$ sudo cat /etc/lightdm/lightdm.conf    #确保有如下两行
……
[XDMCPServer]
enabled=true
……

$ sudo restart lightdm    #重启服务就可以使用XDMCP了
对于Ubuntu 10.04以前的版本，由于默认使用GDM作为X管理程序，需要做如下设置

$ sudo vim /etc/gdm/custom.conf  #手动建立此文件，输入如下内容
[daemon]
RemoteGreeter=/usr/lib/gdm/gdmlogin

[xdmcp]
Enable=true
DisplaysPerHost=1
Port=177

$ sudo service gdm restart    #重启服务就可以使用XDMCP了
更多GDM的配置参数可以参考GNOME官方的这篇文章。

XDMCP初探

$ sudo netstat -anup | grep :177      #监听UDP177端口
udp6       0      0 :::177                  :::*                                12472/gdm-binary

$ sudo netstat -anp | grep 6000       #连接建立以后使用TCP协议监听客户端的6000端口
tcp        0      0 192.168.137.129:42359   192.168.137.1:6000      ESTABLISHED 12655/pulseaudio
tcp        0      0 192.168.137.129:42337   192.168.137.1:6000      ESTABLISHED 13530/unity-2d-shel
tcp        0      0 192.168.137.129:42345   192.168.137.1:6000      ESTABLISHED 13539/bluetooth-app
tcp        0      0 192.168.137.129:42331   192.168.137.1:6000      ESTABLISHED 13452/gnome-session
tcp        0      0 192.168.137.129:42342   192.168.137.1:6000      ESTABLISHED 13542/bamfdaemon
tcp        0      0 192.168.137.129:42365   192.168.137.1:6000      ESTABLISHED 13770/telepathy-ind
tcp        0      0 192.168.137.129:42347   192.168.137.1:6000      ESTABLISHED 13540/nm-applet 
tcp        0      0 192.168.137.129:42333   192.168.137.1:6000      ESTABLISHED 13511/gnome-setting
tcp        0      0 192.168.137.129:42330   192.168.137.1:6000      ESTABLISHED 13499/dbus-launch
tcp        0      0 192.168.137.129:42361   192.168.137.1:6000      ESTABLISHED 13714/gdu-notificat
tcp        0      0 192.168.137.129:42343   192.168.137.1:6000      ESTABLISHED 13537/polkit-gnome-
tcp        0      0 192.168.137.129:42368   192.168.137.1:6000      ESTABLISHED 13868/update-notifi
tcp        0      0 192.168.137.129:42348   192.168.137.1:6000      ESTABLISHED 13529/unity-2d-pane
XDMCP常见错误处理
当我们在Windows系统中使用Xmanager去连接一个Linux系统时，Windows是服务端，而Linux才是客户端，客户端（Linux）的UDP 177端口用于向服务端发起XDMCP连接，而服务端（Windows）上的TCP 6000-6100 端口则用于向远程客户端传递X。

由于这种特殊的性质，当XDMCP无法连接时，常见的处理方式为：
第一步，检查Linux上的UDP 177端口是否有程序在监听；
第二步，则是检查服务端（Windows）方面的日志，见下图：
XDMCP常见错误处理

打开日志后，会看到本地的错误日志。目前已知的可能出现的错误有：
1，XDMCP fatal error: Session declined Maximum number of open sessions from your host reached
原因及解决办法：
这是由于Xmanager是经过router来连接host的，session超出了host允许的最大值，
修改/etc/gdm/custom.conf，在[xdmcp]下面添加一行DisplaysPerHost=5

2，Xdmcp: Timed out, state 8. Retransmissions: N
原因及解决办法：
可能是客户端本地的防火墙阻止了连接。当我们在Windows系统中使用Xmanager去连接一个Linux系统时，Windows是服务端，而Linux才是客户端，客户端（Linux）的UDP 177端口用于向服务端发起XDMCP连接，而服务端（Windows）上的TCP 6000-6100 端口则用于向远程客户端传递X。因此，需要检查以下内容：
(1),客户端IP和服务端IP可以双向PING通（如果客户端和服务端处于不同的子网，而又没有添加正确的路由表的情况下，极有可能可以单向PING通，但不能双向PING通）
(2),Windows的IP是否为本地连接的IP？（我就遇到一回，Xmanager的日志中显示Windows系统的IP并不是我本地连接的IP，而是VMware生成的虚拟网卡的IP，无语。）
(3),防火墙(网关)是否会阻止UDP协议的连接？是否会阻止6000-6100端口的连接？

参考文章1
参考文章2

后记：
============================
2015.03.09
系统用户较多，在登陆界面，用户列表显示不全，想了很多办法，最后决定禁用用户列表（要求输入用户名）来解决：

sudo gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type Boolean --set /apps/gdm/simple-greeter/disable_user_list True
2015.03.23
检查Ubuntu系统是否打开了3D加速：

glxinfo | grep rendering
/usr/lib/nux/unity_support_test -p
* 网易云音乐 
  /usr/bin/netease-cloud-music

* fdisk 创建 mdr 和 gpt 分区
Linux fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。

语法
fdisk [必要参数][选择参数]
必要参数：

-l 列出素所有分区表
-u 与"-l"搭配使用，显示分区数目
选择参数：

-s<分区编号> 指定分区
-v 版本信息
菜单操作说明

m ：显示菜单和帮助信息
a ：活动分区标记/引导分区
d ：删除分区
l ：显示分区类型
n ：新建分区
p ：显示分区信息
q ：退出不保存
t ：设置分区号
v ：进行分区检查
w ：保存修改
x ：扩展应用，高级功能
实例
显示当前分区情况：

# fdisk -l

Disk /dev/sda: 10.7 GB, 10737418240 bytes
255 heads, 63 sectors/track, 1305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

  Device Boot   Start     End   Blocks  Id System
/dev/sda1  *      1     13   104391  83 Linux
/dev/sda2       14    1305  10377990  8e Linux LVM

Disk /dev/sdb: 5368 MB, 5368709120 bytes
255 heads, 63 sectors/track, 652 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

Disk /dev/sdb doesn't contain a valid partition table
显示SCSI硬盘的每个分区情况

# fdisk -lu  

Disk /dev/sda: 10.7 GB, 10737418240 bytes
255 heads, 63 sectors/track, 1305 cylinders, total 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes

  Device Boot   Start     End   Blocks  Id System
/dev/sda1  *     63   208844   104391  83 Linux
/dev/sda2     208845  20964824  10377990  8e Linux LVM

Disk /dev/sdb: 5368 MB, 5368709120 bytes
255 heads, 63 sectors/track, 652 cylinders, total 10485760 sectors
Units = sectors of 1 * 512 = 512 bytes

Disk /dev/sdb doesn't contain a valid partition table

磁盘分区命令，适用于 2TB 以下磁盘分区。
* gdisk /dev/sda 创建 gpt 分区 
* timedatectl status
查看一下系统时间状态，如果时间不对的话可以输入
