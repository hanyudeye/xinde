* linux操作系统命令
** 软件管理
*** deb软件
    安装 sudo dpkg -i *.deb  进行安装
*** apt 
    apt-get source <package> 获取源码
    apt-cache search 'expression'
    列表位于/etc/apt/sources.list
    维护好依赖, 都是 deb文件
    路径  /var/cache/apt/archives
    
    debian系linux更新时，提示“由于没有公钥，无法验证下列签名”
    解决方法
1. 下载导入公钥
# apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  8B48AD6246925553
# apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  7638D0442B90D010
# 此处的8B48AD6246925553、7638D0442B90D010是错误提示中的：NO_PUBKEY 8B48AD6246925553  NO_PUBKEY 7638D0442B90D010 

*** aptitude    
    查找
    aptitude search package_name
    安装
    sudo aptitude install wine
    更新
    aptitude safe-upgrade   
    aptitude full-upgrade 相比上面的，不会检查包的依赖关系 
    aptitude dist-upgrade 
    卸载 
    sudo aptitude purge wine
    
    软件仓库
    /etc/apt/sources.list
    
    deb (or deb-src) address  distribution_name  package_type_list
    deb 或deb-src 的值表明了软件包的类型。deb 值说明这是一个已编译程序源，而deb-src 值则说明这
    是一个源代码的源。

    address 条目是软件仓库的Web地址。distribution_name 条目是这个特定软件仓库的发行版版本的名称
    最后，package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到
    诸如main、restricted、universe和partner这样的值。
*** yum(基于Red Hat的系统)
    列出已安装包   yum list installed
    安装 yum install package_name
    本地安装 yum localinstall package_name.rpm

    更新 yum list updates
    yum update package_name

    只删除软件包而保留配置文件和数据文件，就用如下命令：
    yum remove package_name

    要删除软件和它所有的文件，就用erase 选项：
    yum erase package_name

    yum update --skip-broken
    --skip-broken 选项允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。这可能救不了损坏
    的包，但至少可以更新系统上的其他包。

*** 软件安装
**** 依赖库
**** 依赖库降级 
     libpng12-dev : Depends: libpng12-0 (= 1.2.54-1ubuntu1) but 1.2.54-1ubuntu1k1 is to be installed 
     E: Unable to correct problems, you have held broken packages
     解决办法
     sudo apt install libpng12-0=1.2.54-1ubuntu1
**** deb 软件
     安装 sudo dpkg -i *.deb  进行安装
**** apt 
     apt-get source <package> 获取源码
     apt-cache search 'expression'
     列表位于/etc/apt/sources.list
     维护好依赖, 都是 deb 文件
     路径  /var/cache/apt/archives
*** Snap
#查询已经安装了的软件 sudo snap list
#搜索要安装的Snap软件包 sudo snap find xxxx
#查看Snap软件的更多信息 sudo snap info xxxx
#安装Snap软件包 sudo snap install xxxx
#更换软件安装通道 sudo snap switch –channel=xxxx xxxx
#更新Snap软件包 sudo snap refresh xxxx
#还原到之前版本 sudo snap revert xxxx
#卸载Snap软件 sudo snap remove xxxx
当然光靠命令你想搜索什么snap软件包也是一头雾水吧！可以去uappexplorer里查询下，有什么snap软件包呢！喜欢的就都安装上。
#Uappexplorer
https://uappexplorer.com/snaps
** 任务管理
*** 任务放在前、后台
    fg bg jobs 
*** w 登录任务列表
*** ps 任务列表
   #+BEGIN_SRC conf
     -e   显示所有进程 
     -f    全格式
     -h   不显示标题
     -l    长格式
     -w     宽输出
     a    显示终端上的所有进程，包括其他用户的进程。
     r    只显示正在运行的进程。
     u 　以用户为主的格式来显示程序状况。
     x     显示所有程序，不以终端机来区分。

     ps -ef 显示出的结果：
         1.UID       用户 ID
         2.PID        进程 ID
         3.PPID      父进程 ID
         4.C           CPU 占用率
         5.STIME     开始时间
         6.TTY         开始此进程的 TTY----终端设备
         7.TIME       此进程运行的总时间
         8.CMD       命令名
   #+END_SRC
   
   init init进程是所有Linux进程的父进程
*** crontab 执行周期任务
=======
   init init 进程是所有 Linux 进程的父进程
*** crontab 周期性执行
**** 命令
     crontab [ -u user ] file
     crontab [ -u user ] [ -i ] { -e | -l | -r } |
     -e 编辑 crontab 文件
     -l　列出 crontab 文件内容
     -r 删除 crontab 文件
**** 开启日志     
    修改 rsyslog 文件，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的#删掉；
    重启 rsyslog 服务 service rsyslog restart；
    重启 cron 服务 service cron restart；

    more /var/log/cron.log；
    就可以查看运行时的日志文件，如果在日志文件中出现：No MTA installed, discarding output

    那么就是说，crontab 执行脚本时是不会直接错误的信息输出，而是会以邮件的形式发送到你的邮箱里，这时候就需要邮件服务器了，
    如果你没有安装邮件服务器，它就会报这个错。如果是测试，可以用下面的办法来解决：

    在每条定时脚本后面加入：
    ?
    001
    >/dev/null 2>&1
    就可以解决 No MTA installed, discarding output 的问题
**** 编辑文件, 其实编辑好后就会自动执行
    crontab -e  

    # m h  dom mon dow   command  
    */2 * * * * date >> ~/time.log  
**** 执行     
     sudo service cron restart  

     对于自己的，只要执行下自己的 crontab　文件即可
     crontab -u wuming crontabfile

 | 分钟 | 0 - 59                                                                     |
 | 小时 | 0 - 23                                                                     |
 | 天   | 1 - 31                                                                     |
 | 月   | 1 - 12                                                                     |
 | 星期 | 0 - 6   0 表示星期天                                                        |
 | 星号 | 表示任意值，比如在小时部分填写 * 代表任意小时（每小时）                    |
 | 逗号 | 可以允许在一个部分中填写多个值，比如在分钟部分填写 1,3 表示一分钟或三分钟  |
 | 斜线 | 一般配合 * 使用，代表每隔多长时间，比如在小时部分填写 */2 代表每隔两分钟。 |
\* * * * *                  # 每隔一分钟执行一次任务  
0 * * * *                  # 每小时的0点执行一次任务，比如6:00，10:00  
6,10 * 2 * *            # 每个月2号，每小时的6分和10分执行一次任务  
*** pkill 杀死进程按照进程名
=======
0 * * * *                  # 每小时的 0 点执行一次任务，比如 6:00，10:00  
6,10 * 2 * *            # 每个月 2 号，每小时的 6 分和 10 分执行一次任务  
*** pkill 可以按照进程名杀死进程
*** 进程属性
    ls /proc/PID 
    cwd 进程运行目录
    exe 程序绝对路径
    cmdline 运行时的命令行命令
    environ 环境变量
    fd 打开或使用的文件的符号链接
** 用户管理
*** 添加
     useradd -m -g users -G wheel -s /bin/bash ikke
     passwd ikke
*** 组织
**** sudo 组
      打开 /etc/sudoers 
*** 忘记密码
   1,启动时在启动的 linux 系统（或 grub 到计时结束前）上按下“e”键
   2，选中类似“于 kernel /boot/vmlinuz-2.4.18-14 ”按“e”键
   3,修改命令行，加入 linux single，结果如下：
   kernel /vmlinuz-2.6.18-8.el5  ro root=LABEL=/ rhgb quiet linux single
   4,回车返回，按 b 键,进入命令行
   5, #vi /etc/shadow 编辑 shadow
   将第一行，即以 root 开头的一行中 root:后和下一个:前的内容删除，
   第一行将类似于
   root::……
   保存
   (如果保存不了，是文件属性的问题，就chmod 755 /etc/shadow，这样就OK了)
6. #reboot重启，root密码为空
   (如果保存不了，是文件属性的问题，就 chmod 755 /etc/shadow，这样就 OK 了)
6. #reboot 重启，root 密码为空
*** 显示 w 
*** 用户通信 write USERNAME 终端
    终端通过who获取
    write wuming pts/0
*** 拒绝通信 mesg n 
** 设备管理
*** 查看设备 
    ls /dev/
*** 硬盘设备 
    查看容量 df
**** 使用 mount
     mount 用于加载文件系统到指定的加载点
    mount  [-t vfstype] [-o options] device dir
    1.-t vfstype 文件系统类型
    　　光盘或光盘镜像：iso9660
    　　DOS fat16 文件系统：msdos
    　　Windows 9x fat32 文件系统：vfat
    　　Windows NT ntfs 文件系统：ntfs
    　　Mount Windows 文件网络共享：smbfs
    　　UNIX(LINUX) 文件网络共享：nfs
    2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
    　　loop：用来把一个文件当成硬盘分区挂接上系统
    　　ro：采用只读方式挂接设备
    　　rw：采用读写方式挂接设备
    　　iocharset：指定访问文件系统所用字符集,不能显示中文 iocharset=cp936
    3.device 要挂接(mount)的设备。
    4.dir 设备在系统上的挂接点(mount point)。
    sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览 windows 共享文件夹
**** 取消使用 umount
** 文件系统
** 文件管理
*** 查看 cat less more head tac tail wc
*** 排序查看 sort uniq
*** 修改 vim/emacs
*** 新增文件 目录  mkdir
*** 删除 remove rmdir
*** 比较 diff
*** 文件类型 file 
*** 改名 mv
*** 查找文件 find whereis which
*** 编辑
**** sed 命令编辑器
***** 选项 
      sed [options] 'command' file(s)
      sed [options] -f scriptfile file(s)
      -e<script>或--expression=<script>：以选项中的指定的 script 来处理输入的文本文件；
      -f<script 文件>或--file=<script 文件>：以选项中指定的 script 文件来处理输入的文本文件；
***** 功能
      a\ 在当前行下面插入文本。
      i\ 在当前行上面插入文本。
      c\ 把选定的行改为新的文本。
      d 删除，删除选择的行。
      D 删除模板块的第一行。
      s 替换指定字符 sed 's/aa/bb/' file 注意/ 符,用来分界
      h 拷贝模板块的内容到内存中的缓冲区。
      H 追加模板块的内容到内存中的缓冲区。
      g 获得内存缓冲区的内容，并替代当前模板块中的文本。
      G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
      l 列表不能打印字符的清单。
      n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
      N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
      p 打印模板块的行。(显示两遍)
      P(大写) 打印模板块的第一行。
      q 退出 Sed。
      b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
      r file 从 file 中读行。
      t label if 分支，从最后一行开始，条件一旦满足或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
      T label 错误分支，从最后一行开始，一旦发生错误或者 T，t 命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
      w file 写并追加模板块到 file 末尾。  
      W file 写并追加模板块的第一行到 file 末尾。  
      ! 表示后面的命令对所有没有被选定的行发生作用。  
      = 打印当前行号码。  
      # 把注释扩展到下一个换行符以前。  

      sed 替换标记
      g 表示行内全面替换。  
      p 表示打印行。  
      w 表示把行写入一个文件。  
      x 表示互换模板块中的文本和缓冲区中的文本。  
      y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
      \1 子串匹配标记
      & 已匹配字符串标记

      sed 元字符集
      ^ 匹配行开始，如：/^sed/匹配所有以 sed 开头的行。
      $ 匹配行结束，如：/sed$/匹配所有以 sed 结尾的行。
      . 匹配一个非换行符的任意字符，如：/s.d/匹配 s 后接一个任意字符，最后是 d。
      [* 匹配 0 个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟 sed 的行。
      [] 匹配一个指定范围内的字符，如/[ss]ed/匹配 sed 和 Sed。  
      [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含 A-R 和 T-Z 的一个字母开头，紧跟 ed 的行。
      \(..\) 匹配子串，保存匹配的字符，如 s/\(love\)able/\1rs，loveable 被替换成 lovers。
      & 保存搜索字符用来替换其他字符，如 s/love/**&**/，love 这成**love**。
      \< 匹配单词的开始，如:/\<love/匹配包含以 love 开头的单词的行。
      \> 匹配单词的结束，如/love\>/匹配包含以 love 结尾的单词的行。
      x\{m\} 重复字符 x，m 次，如：/0\{5\}/匹配包含 5 个 0 的行。
      x\{m,\} 重复字符 x，至少 m 次，如：/0\{5,\}/匹配至少有 5 个 0 的行。
      x\{m,n\} 重复字符 x，至少 m 次，不多于 n 次，如：/0\{5,10\}/匹配 5~10 个 0 的行。 

***** sed 用法实例
****** 替换：s
      sed 's/book/books/' file

      -n 选项和 p 命令一起使用表示只打印那些发生替换的行：
      sed -n 's/test/TEST/p' file

      直接编辑文件选项-i，会匹配 file 文件中每一行的第一个 book 替换
      为 books：
      sed -i 's/book/books/g' file
****** 全面替换标记 g
      sed 's/book/books/g' file
****** 替换 1 行中第 N 处匹配开始替换时，可以使用 /Ng：
      echo sksksksksksk | sed 's/sk/SK/2g'
      skSKSKSKSKSK
****** 使用定界符
      sed 's:test:TEXT:g'
      sed 's|test|TEXT|g'

      定界符出现在样式内部时，需要进行转义：
      sed 's/\/bin/\/usr\/local\/bin/g'

****** 删除操作：d 命令
****** 删除空白行：
      sed '/^$/d' file

****** 删除文件的第 2 行：
      sed '2d' file
****** 删除文件的第 2 行到末尾所有行：
      sed '2,$d' file
****** 删除文件最后一行：
      sed '$d' file
****** 删除文件中所有开头是 test 的行：
      sed '/^test/'d file
****** 已匹配字符串标记&
      正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之
      前所匹配到的单词：

      echo this is a test line | sed 's/\w\+/[&]/g'
      [this] [is] [a] [test] [line]

      所有以 192.168.0.1 开头的行都会被替换成它自已加 localhost：

      sed 's/^192.168.0.1/&localhost/' file
      192.168.0.1localhost
****** 子串匹配标记\1
      匹配给定样式的其中一部分：
      echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
      this is 7 in a number

      命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，\(..\)
      用于匹配子串，对于匹配到的第一个子串就标记为 \1，依此类推匹
      配到的第二个结果就是 \2，例如：

      echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
      BBB aaa

      love 被标记为 1，所有 loveable 会被替换成 lovers，并打印出来：

      sed -n 's/\(love\)able/\1rs/p' file
****** 组合多个表达式
      sed '表达式' | sed '表达式'

      等价于：

      sed '表达式; 表达式'

      引用

      sed 表达式可以使用单引号来引用，但是如果表达式内部包含变量字
      符串，就需要使用双引号。

      test=hello
      echo hello WORLD | sed "s/$test/HELLO"
      HELLO WORLD

      选定行的范围：,（逗号）

      所有在模板 test 和 check 所确定的范围内的行都被打印：

      sed -n '/test/,/check/p' file

      打印从第 5 行开始到第一个包含以 test 开始的行之间的所有行：

      sed -n '5,/^test/p' file

      对于模板 test 和 west 之间的行，每行的末尾用字符串 aaa bbb 替换：

      sed '/test/,/west/s/$/aaa bbb/' file

      多点编辑：e 命令

      -e 选项允许在同一行里执行多条命令：

      sed -e '1,5d' -e 's/test/check/' file

      上面 sed 表达式的第一条命令删除 1 至 5 行，第二条命令用 check 替换
      test。命令的执行顺序对结果有影响。如果两个命令都是替换命令
      ，那么第一个替换命令将影响第二个替换命令的结果。

      和 -e 等价的命令是 --expression：

      sed --expression='s/test/check/' --expression='/love/d' file

      从文件读入：r 命令

      file 里的内容被读进来，显示在与 test 匹配的行后面，如果匹配多
      行，则 file 的内容将显示在所有匹配行的下面：

      sed '/test/r file' filename

      写入文件：w 命令  

      在 example 中所有包含 test 的行都被写入 file 里：

      sed -n '/test/w file' example

      追加（行下）：a\命令

      将 this is a test line 追加到以 test 开头的行后面：

      sed '/^test/a\this is a test line' file

      在 test.conf 文件第 2 行之后插入 this is a test line：

      sed -i '2a\this is a test line' test.conf

      插入（行上）：i\命令

      将 this is a test line 追加到以 test 开头的行前面：

      sed '/^test/i\this is a test line' file

      在 test.conf 文件第 5 行之前插入 this is a test line：

      sed -i '5i\this is a test line' test.conf

      下一个：n 命令

      如果 test 被匹配，则移动到匹配行的下一行，替换这一行的 aa，变
      为 bb，并打印该行，然后继续：

      sed '/test/{ n; s/aa/bb/; }' file

      变形：y 命令

      把 1~10 行内所有 abcde 转变为大写，注意，正则表达式元字符不能使
      用这个命令：

      sed '1,10y/abcde/ABCDE/' file

      退出：q 命令

      打印完第 10 行后，退出 sed

      sed '10q' file

      保持和获取：h 命令和 G 命令

      在 sed 处理文件的时候，每一行都被保存在一个叫模式空间的临时缓
      冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将
      打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。

      sed -e '/test/h' -e '$G' file

      在这个例子里，匹配 test 的行被找到后，将存入模式空间，h 命令将
      其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的
      意思是，当到达最后一行后，G 命令取出保持缓冲区的行，然后把它
      放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾
      。在这个例子中就是追加到最后一行。简单来说，任何包含 test 的
      行都被复制并追加到该文件的末尾。

      保持和互换：h 命令和 x 命令

      互换模式空间和保持缓冲区的内容。也就是把包含 test 与 check 的行
      互换：

      sed -e '/test/h' -e '/check/x' file

      脚本 scriptfile

      sed 脚本是一个 sed 的命令清单，启动 Sed 时以-f 选项引导脚本文件名
      。Sed 对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空
      白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行
      为注释行，且不能跨行。

      sed [options] -f scriptfile file(s)

      打印奇数行或偶数行

      方法 1：

      sed -n 'p;n' test.txt  #奇数行
      sed -n 'n;p' test.txt  #偶数行

      方法 2：

      sed -n '1~2p' test.txt  #奇数行
      sed -n '2~2p' test.txt  #偶数行

      打印匹配字符串的下一行

      grep -A 1 SCC URFILE
      sed -n '/SCC/{n;p}' URFILE
      awk '/SCC/{getline; print}' URFILE
***** 修改 更改 
**** emacs 可视化编辑器
**** join 行号及行内文本同，则显示
     按两个文件的相同字段合并
**** tr 替换或删除字符
*** 查找文件内容 grep
*** 改变权限 chmod 
*** 权限 setuid 执行中文件有文件所有者权限  setgid 文件所属组权限
*** grep 文本搜索
     -C 5 foo file  显示 file 文件中匹配 foo 字串那行以及上下 5 行
     -B 5 foo file  显示 foo 及前 5 行
     -A 5 foo file  显示 foo 及后 5 行
     －c：只输出匹配行的计数。
     －I：不区分大 小写(只适用于单字符)。
     －h：查询多文件时不显示文件名。
     －l：查询多文件时只输出包含匹配字符的文件名。
     －n：显示匹配行及 行号。
     －s：不显示不存在或无匹配文本的错误信息。
     －v：显示不包含匹配文本的所有行。
     pattern 正则表达式主要参数：
     \： 忽略正则表达式中特殊字符的原有含义。
     ^：匹配正则表达式的开始行。
     $: 匹配正则表达式的结束行。
     \<：从匹配正则表达 式的行开始。
     \>：到匹配正则表达式的行结束。
     [ ]：单个字符，如[A]即 A 符合要求 。
     [ - ]：范围，如[A-Z]，即 A、B、C 一直到 Z 都符合要求 。
     .：所有的单个字符。
     $ grep ‘test’ d*
     显示所有以 d 开头的文件中包含 test 的行。
     $ grep ‘test’ aa bb cc
     显示在 aa，bb，cc 文件中匹配 test 的行。
     $ grep ‘[a-z]\{5\}’ aa
     显示所有包含每个字符串至少有 5 个连续小写字符的字符串的行。
     $ grep ‘w\(es\)t.*\1′ aa
     如果 west 被匹配，则 es 就被存储到内存中，并标记为 1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个 es(\1)，找到就显示该行。如果用 egrep 或 grep -E，就不用"\"号进行转义，直接写成’w(es)t.*\1′就可以了。

     grep 命令使用复杂实例
     假设您正在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件：
     $ grep magic /usr/src/Linux/Doc/*
     sysrq.txt:* How do I enable the magic SysRQ key?
     sysrq.txt:* How do I use the magic SysRQ key?
     其中文件’sysrp.txt’包含该字符串，讨论的是 SysRQ 的功能。
     默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：
     grep: sound: Is a directory
     这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：
     明确要求搜索子目录：grep -r
     或忽略子目录：grep -d skip
     如果有很多 输出时，您可以通过管道将其转到’less’上阅读：
     $ grep magic /usr/src/Linux/Documentation/* | less
     这样，您就可以更方便地阅读。

     -q 静静地 ，存在则返回 0, 不存在返回 1
     下面还有一些有意思的命令行参数：
     grep -i pattern files：不区分大小写地搜索。默认情况区分大小写，
     grep -l pattern files：只列出匹配的文件名，
     grep -L pattern files：列出不匹配的文件名，
     grep -w pattern files：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
     grep -C number pattern files：匹配的上下文分别显示[number]行，
     grep pattern1 | pattern2 files：显示匹配 pattern1 或 pattern2 的行，
     grep pattern1 files | grep pattern2：显示既匹配 pattern1 又匹配 pattern2 的行。
     grep -n pattern files  即可显示行号信息
     grep -c pattern files  即可查找总行数

*** find 
    pathname -options [-print -exec -ok ...]
    关系操作
    -a and
    -or -o or
    -n not 
     : -exec：find 命令对匹配的文件执行该参数所给出的 shell 命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
     : -ok：和-exec 的作用相同，只不过以一种更为安全的模式来执行该参数所给出的 shell 命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
     : -name   按照文件名查找文件。
     : -perm   按照文件权限来查找文件。
     : -prune  使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用-depth 选项，那么-prune 将被 find 命令忽略。
     : -user   按照文件属主来查找文件。
     : -group  按照文件所属的组来查找文件。
     : -mtime -n +n  按照文件的更改时间来查找文件， - n 表示文件更改时间距
     : 现在 n 天以内，+ n 表示文件更改时间距现在 n 天以前。find 命令还有-atime 和-ctime 选项，但它们都和-m time 选项。
     : -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups 中不存在。
     : -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd 中不存在。
     : -newer file1 ! file2  查找更改时间比文件 file1 新但比文件 file2 旧的文件。
     : -iname 忽略大小写
**** -type  查找某一类型的文件，诸如：
     + b - 块设备文件。
     + d - 目录。
     + c - 字符设备文件。
     + p - 管道文件。
     + l - 符号链接文件。
     + f - 普通文件。
**** -size n：[c] 查找文件长度为 n 块的文件，带有 c 时表示文件长度以字节计。
**** -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
**** -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab 中找到，该配置文件中包含了本系统中有关文件系统的信息。
**** -mount：在查找文件时不跨越文件系统 mount 点。
**** -follow：如果 find 命令遇到符号链接文件，就跟踪至链接所指向的文件。
**** -cpio：对匹配的文件使用 cpio 命令，将这些文件备份到磁带设备中。
**** time
     : -amin n   查找系统中最后 N 分钟访问的文件  -n n 天以内;+n n 天之前
     : -atime n  查找系统中最后 n*24 小时访问的文件
     : -cmin n   查找系统中最后 N 分钟被改变文件状态的文件
     : -ctime n  查找系统中最后 n*24 小时被改变文件状态的文件
     : -mmin n   查找系统中最后 N 分钟被改变文件数据的文件
     : -mtime n  查找系统中最后 n*24 小时被改变文件数据的文件
     : find  ./    -mtime    -1    -type f    -ok   ls -l    {} \;  
     : find .    -perm -007    -exec ls -l {} \;  
     : ! 否定参数
** 系统信息
*** 系统名字 hostname 
*** 日期时间 date calendar
** 任务工具
*** 终止任务 kill  
*** 任务放后台 bg
*** 调到前台 fg
*** 查看任务 ps
** 工具
*** 文本转换 unix2dos dos2unix 
*** 压缩 bzip2  -v 显示文件的详细信息 bzip -v aa.jpg 
*** 改变shell chsh 重登有效 更改的是/etc/passwd 中的shell 内容
*** 屏幕截图
   import -frame window.tif
**** shutter 
     1. 里面的快捷键命令用：shutter -s 或者 shutter –select
     2. 截取当前活动窗口：shutter -a（a 表示 active）
     3. 截取拖拉区域：shutter -s（s 是 select 之意），拖拉出矩形区域后按 Enter。 

*** 中文语音朗读 ekho
*** 7z 
    解压
    7z x  dist.7z -r -o/home/Baby/Desktop
    x 代表解压缩文件，并且是按原始目录解压
    dist.7z 是压缩文件，如果不在当前目录下要带上完整的目录
    -r 表示递归所有的子文件夹
    -o 是指定解压到的目录，（注意-o 后是没有空格的直接接目录）

    压缩文件／文件夹
    7z a -t7z -r  dist.7z   /web/source/*
    a 代表添加文件／文件夹到压缩包
    -t 是指定压缩类型 
    -r 表示递归所有的子文件夹
    dist.7z 是压缩好后的压缩包名
    /web/source/* 是要压缩的目录，＊是表示该目录下所有的文件
*** unzip 
    -l     list archive files (short format)
*** 安装字体
    # mkdir /usr/share/fonts/arial
    # cp arial*.ttf /usr/share/fonts/arial/
    设置同步
    # cd /usr/share/font/arial
    # fc-cache -fv
** 数据库
*** mysql 
***** 导出
      1、导出数据和表结构：
      mysqldump -u 用户名 -p 密码 数据库名 > 数据库名.sql
      #/usr/local/mysql/bin/   mysqldump -uroot -p abc > abc.sql
      
      2、只导出表结构
      mysqldump -u 用户名 -p 密码 -d 数据库名 > 数据库名.sql
      #/usr/local/mysql/bin/   mysqldump -uroot -p -d abc > abc.sql

***** 导入    

      1、首先建空数据库
mysql>create database abc;

2、导入数据库
方法一：
（1）选择数据库
mysql>use abc;
（2）设置数据库编码
mysql>set names utf8;
（3）导入数据（注意 sql 文件的路径）
mysql>source /home/abc/abc.sql;
方法二：
mysql -u 用户名 -p 密码 数据库名 < 数据库名.sql
#mysql -uabc_f -p abc < abc.sql

建议使用第二种方法导入。

** 网络工具
*** 电子邮件 
*** 聊天
**** IRC
   /server irc.debian.org
   /join #debian
   /part #debian  离开
   /quit
   要给 foo 发送一条内容为 "Hello Mr. Foo"的私人消息,请输入
   /msg foo Hello Mr. Foo
***** irc 频道
      #linuxba 国内 linux 贴吧
      #c_lang_cn C 语言中文 irc 频道
      ##g 讲到这里，必须得推广下自己的频道，##g，作为一个大水比，同时也是小白，
      #archlinux-cn 
      #emacs
      #orz
      #debiancn
      #kali
      #osdev 操作系统开发频道
      *** remmina 远程桌面
*** 无线网
   iwconfig ath0 essid lincoln 这样就意味着你正在加入一个 ESSID 为 lincoln 的无线网络
   nm-connection-editor
*** 网速 nload
*** 网络请求 
**** curl
     curl 是一个命令行方式下传输数据的开源传输工具，支持多种协议：FTP、HTTP、HTTPS、IMAP、POP3、TELNET 等，功能超级强大。
***** curl Post Json
      post  curl -i -X POST -H 'Content-type':'application/json' -d {"BTime":""$btime""} http://api.baidu.com
      $ curl -i -X POST -H "'Content-type':'application/x-www-form-urlencoded', 'charset':'utf-8', 'Accept': 'text/plain'" -d 'json_data={"a":"aaa","b":"bbb","data":[{"c":"ccc","d":"ddd","keywords":[{"e": "eee", "f":"fff", "g":"ggg"}]}]}' url
      返回信息：
     
      HTTP/1.1 200 OK
      Server: Apache-Coyote/1.1
      Set-Cookie: JSESSIONID=02565379F21852B33D0367FB7982FE1C; Path=/; HttpOnly
      Content-Type: application/json;charset=UTF-8
      Transfer-Encoding: chunked
      Date: Tue, 22 Oct 2013 10:48:24 GMT
     
      这里想要 post Json 数据到接口上，需要设置好 Header，也就是：'Content-type':'application/x-www-form-urlencoded', 'charset':'utf-8', 'Accept': 'text/plain'。
      之前一直认为是设置好 Content-Type=application/json 即可，但是如果有中文就会遇到需要 encode 的地方了。
***** get 
      curl http://mywebsite.com/index.php?a=1&b=2&c=3
      $_GET 只能获取到参数 a
      由于 url 中有&，其他参数获取不到，在 linux 系统中& 会使进程系统后台运行
      必须对&进行下转义才能$_GET 获取到所有参数

      curl http://mywebsite.com/index.php?a=1\&b=2\&c=3
      url 为 http://mywebsite.com/index.php?a=1&b=2&c=3
     
      或加“”
      curl  -s  "http://mywebsite.com/index.php?a=1&b=2&c=3"
***** POST 提交    通过 --data/-d 方式指定使用 POST 方式传递数据
      curl  -d  'name=1&pagination=2' demoapp.sinap.com/worker.php
      demoapp.sinap.com 站点中的 worker.php 脚本，就能得到 $_POST['name'] 和 $_POST[''pagination] 对应的值     
***** curl 获得网站信息的方法（ -s 表示静默  --head 表示取得 head 信息 ）
      curl  -s  --head  www.sina.com
***** 模拟 form 表单提交文件  --form/-F 模拟 form 表单提交文件
      curl -F "image=@./index.php"  www.learn.com/phptest/index.php
      "image=@./1.png"     image 相当于<input type='file' name='image'>中 name 的 value   @后面是文件路径
*** 重启网络 
  sudo   /etc/init.d/networking restart
  systemctl status networking.server
*** 网络
  1. OSI 七层网络模型
  　　TCP/IP 协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开 TCP/IP 协议。不管是 OSI 七层模型还是 TCP/IP 的四层、五层模型，每一层中都要自己的专属协议，
  完成自己相应的工作以及与上下层级之间进行沟通。由于 OSI 七层模型为网络的标准层次划分，所以我们以 OSI 七层模型为例从下向上进行一一介绍。
  　　1）物理层（Physical Layer）
  　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。
  物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。
  　　2）数据链路层（Data Link Layer）
  　　数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，
  数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；
  如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、
  维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
  　　有关数据链路层的重要知识点：
  　　1> 数据链路层为网络层提供可靠的数据传输；
  　　2> 基本数据单位为帧；
  　　3> 主要的协议：以太网协议；
  　　4> 两个重要设备名称：网桥和交换机。
  　　3）网络层（Network Layer）
  　　网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。
  如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。
  　　网络层中涉及众多的协议，其中包括最重要的协议，也是 TCP/IP 的核心协议——IP 协议。IP 协议非常简单，仅仅提供不可靠、无连接的传送服务。IP 协议的主要功能有：
  无连接数据报传输、数据报路由选择和差错控制。与 IP 协议配套使用实现其功能的还有地址解析协议 ARP、逆地址解析协议 RARP、因特网报文协议 ICMP、因特网组管理协议 IGMP。
  具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：
  　　1> 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；
  　　2> 基本数据单位为 IP 数据报；
  　　3> 包含的主要协议：
  　　IP 协议（Internet Protocol，因特网互联协议）;
  　　ICMP 协议（Internet Control Message Protocol，因特网控制报文协议）;
  　　ARP 协议（Address Resolution Protocol，地址解析协议）;
  　　RARP 协议（Reverse Address Resolution Protocol，逆地址解析协议）。
  　　4> 重要的设备：路由器。
  　　4）传输层（Transport Layer）
  　　第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

  　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。
  　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。
  　　有关网络层的重点：
  　　1> 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；
  　　2> 包含的主要协议：TCP 协议（Transmission Control Protocol，传输控制协议）、UDP 协议（User Datagram Protocol，用户数据报协议）；
  　　3> 重要设备：网关。

  　　5）会话层
  　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
  　　6）表示层
  　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。

  　　7）应用层
  　　为操作系统或网络应用程序提供访问网络服务的接口。
  　　会话层、表示层和应用层重点：
  　　1> 数据传输基本单位为报文；
  　　2> 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3 协议（邮局协议），HTTP 协议（Hyper Text Transfer Protocol）。

  1. IP 地址
  　　1）网络地址

  　　IP 地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全 0，网络地址代表着整个网络。

  　　2）广播地址

  　　广播地址通常称为直接广播地址，是为了区分受限广播地址。

  　　广播地址与网络地址的主机号正好相反，广播地址中，主机号为全 1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

  　　3）组播地址

  　　D 类地址就是组播地址。

  　　先回忆下 A，B，C，D 类地址吧：

  　　A 类地址以 0 开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)

  　　B 类地址以 10 开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;

  　　C 类地址以 110 开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。

  　　D 类地址以 1110 开头，地址范围是 224.0.0.0~239.255.255.255，D 类地址作为组播地址（一对多的通信）；

  　　E 类地址以 1111 开头，地址范围是 240.0.0.0~255.255.255.255，E 类地址为保留地址，供以后使用。

  　　注：只有 A,B,C 有网络号和主机号之分，D 类地址和 E 类地址没有划分网络号和主机号。

  　　4）255.255.255.255

  　　该 IP 地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机 192.168.1.1/30 上的直接广播数据包后，另外一个网段 192.168.1.5/30 也能收到该数据报；若发送受限广播数据报，则不能收到。

  　　注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。

  　　5）0.0.0.0

  　　常用于寻找自己的 IP 地址，例如在我们的 RARP，BOOTP 和 DHCP 协议中，若某个未知 IP 地址的无盘机想要知道自己的 IP 地址，它就以 255.255.255.255 为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送 IP 请求分组。

  　　6）回环地址

  　　127.0.0.0/8 被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是 127.0.0.1。

  　　7）A、B、C 类私有地址

  　　私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。

  　　A 类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255

  　　B 类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255

  　　C 类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

  1. 子网掩码及网络划分
  　　随着互连网应用的不断扩大，原先的 IPv4 的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用 NAT 在企业内部利用保留地址自行分配以外，通常都对一个高类别的 IP 地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。

  　　这里主要是为了在网络分段情况下有效地利用 IP 地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。

  　　什么是子网掩码？

  　　子网掩码是标志两个 IP 地址是否同属于一个子网的，也是 32 位二进制地址，其每一个为 1 代表该位是网络位，为 0 代表主机位。它和 IP 地址一样也是使用点式十进制来表示的。如果两个 IP 地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。

  　　在计算子网掩码时，我们要注意 IP 地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的 IP 地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。

  　　子网掩码的计算：

  　　对于无须再划分成子网的 IP 地址来说，其子网掩码非常简单，即按照其定义即可写出：如某 B 类 IP 地址为 10.12.3.0，无须再分割子网，则该 IP 地址的子网掩码 255.255.0.0。如果它是一个 C 类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个 IP 地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。

  　　下面总结一下有关子网掩码和网络划分常见的面试考题：

  　　1）利用子网数来计算

  　　在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。

  　　(1) 将子网数目转化为二进制来表示;

  　　如欲将 B 类 IP 地址 168.195.0.0 划分成 27 个子网：27=11011；

  　　(2) 取得该二进制的位数，为 N；

  　　该二进制为五位数，N = 5

  　　(3) 取得该 IP 地址的类子网掩码，将其主机地址部分的的前 N 位置 1 即得出该 IP 地址划分子网的子网掩码。

  　　将 B 类地址的子网掩码 255.255.0.0 的主机地址前 5 位置 1，得到 255.255.248.0

  　　2）利用主机数来计算

  　　如欲将 B 类 IP 地址 168.195.0.0 划分成若干子网，每个子网内有主机 700 台：

  　　(1) 将主机数目转化为二进制来表示；

  　　700=1010111100；

  　　(2) 如果主机数小于或等于 254（注意去掉保留的两个 IP 地址），则取得该主机的二进制位数，为 N，这里肯定 N<8。如果大于 254，则 N>8，这就是说主机地址将占据不止 8 位；

  　　该二进制为十位数，N=10；

  　　(3) 使用 255.255.255.255 来将该类 IP 地址的主机地址位数全部置 1，然后从后向前的将 N 位全部置为 0，即为子网掩码值。

  　　将该 B 类地址的子网掩码 255.255.0.0 的主机地址全部置 1，得到 255.255.255.255，然后再从后向前将后 10 位置 0,即为：11111111.11111111.11111100.00000000，即 255.255.252.0。这就是该欲划分成主机为 700 台的 B 类 IP 地址 168.195.0.0 的子网掩码。

  　　3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。

  　　比如一个子网有 10 台主机，那么对于这个子网需要的 IP 地址是：

  　　10＋1＋1＋1＝13

  　　注意：加的第一个 1 是指这个网络连接时所需的网关地址，接着的两个 1 分别是指网络地址和广播地址。

  　　因为 13 小于 16（16 等于 2 的 4 次方），所以主机位为 4 位。而 256－16＝240，所以该子网掩码为 255.255.255.240。

  　　如果一个子网有 14 台主机，不少人常犯的错误是：依然分配具有 16 个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为 14＋1＋1＋1＝17，17 大于 16，所以我们只能分配具有 32 个地址（32 等于 2 的 5 次方）空间的子网。这时子网掩码为：255.255.255.224。

  回到顶部
  5. ARP/RARP 协议
  　　地址解析协议，即 ARP（Address Resolution Protocol），是根据 IP 地址获取物理地址的一个 TCP/IP 协议。主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送 ARP 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 ARP 缓存；由此攻击者就可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 ARP 欺骗。ARP 命令可用于查询本机 ARP 缓存中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等。

  　　ARP 工作流程举例：

  　　主机 A 的 IP 地址为 192.168.1.1，MAC 地址为 0A-11-22-33-44-01；
  　　主机 B 的 IP 地址为 192.168.1.2，MAC 地址为 0A-11-22-33-44-02；
  　　当主机 A 要与主机 B 通信时，地址解析协议可以将主机 B 的 IP 地址（192.168.1.2）解析成主机 B 的 MAC 地址，以下为工作流程：
  　　（1）根据主机 A 上的路由表内容，IP 确定用于访问主机 B 的转发 IP 地址是 192.168.1.2。然后 A 主机在自己的本地 ARP 缓存中检查主机 B 的匹配 MAC 地址。
  　　（2）如果主机 A 在 ARP 缓存中没有找到映射，它将询问 192.168.1.2 的硬件地址，从而将 ARP 请求帧广播到本地网络上的所有主机。源主机 A 的 IP 地址和 MAC 地址都包括在 ARP 请求中。本地网络上的每台主机都接收到 ARP 请求并且检查是否与自己的 IP 地址匹配。如果主机发现请求的 IP 地址与自己的 IP 地址不匹配，它将丢弃 ARP 请求。
  　　（3）主机 B 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将主机 A 的 IP 地址和 MAC 地址映射添加到本地 ARP 缓存中。
  　　（4）主机 B 将包含其 MAC 地址的 ARP 回复消息直接发送回主机 A。
  　　（5）当主机 A 收到从主机 B 发来的 ARP 回复消息时，会用主机 B 的 IP 和 MAC 地址映射更新 ARP 缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机 B 的 MAC 地址一旦确定，主机 A 就能向主机 B 发送 IP 通信了。
  　　逆地址解析协议，即 RARP，功能和 ARP 协议相对，其将局域网中某个主机的物理地址转换为 IP 地址，比如局域网中有一台主机只知道物理地址而不知道 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。

  　　RARP 协议工作流程：

  　　（1）给主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；

  　　（2）本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；

  　　（3）如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；
  　　（4）如果不存在，RARP 服务器对此不做任何的响应；
  　　（5）源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。
  回到顶部
  6. 路由选择协议
  　　常见的路由选择协议有：RIP 协议、OSPF 协议。

  　　RIP 协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是 15 跳，如果大于 15 跳，它就会丢弃数据包。

  　　OSPF 协议 ：Open Shortest Path First 开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
  回到顶部
  7. TCP/IP 协议
  　　TCP/IP 协议是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成。通俗而言：TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址。
  　　IP 层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP 或 UDP 层；相反，IP 层也把从 TCP 或 UDP 层接收来的数据包传送到更低层。IP 数据包是不可靠的，因为 IP 并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP 数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。
   　　TCP 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于 TCP 是面向连接的所以只能用于端到端的通讯。TCP 提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP 还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

  　　TCP 报文首部格式：



  　　TCP 协议的三次握手和四次挥手：
  　　TCP 连接建立过程：首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。

  　　TCP 连接断开过程：假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说"我 Client 端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，"告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，"告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了"。Client 端收到 FIN 报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，"就知道可以断开连接了"。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！

  　　为什么要三次挥手？

  　　在只有两次“握手”的情形下，假设 Client 想跟 Server 建立连接，但是却因为中途连接请求的数据报丢失了，故 Client 端不得不重新发送一遍；这个时候 Server 端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候 Client 端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下 Server 端将先后收到 2 次请求，并持续等待两个 Client 请求向他发送数据...问题就在这里，Cient 端实际上只有一次请求，而 Server 端却有 2 个响应，极端的情况可能由于 Client 端多次重新发送请求数据而导致 Server 端最后建立了 N 多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

  　　为什么要四次挥手？

  　　试想一下，假如现在你是客户端你想断开跟 Server 的所有连接该怎么做？第一步，你自己先停止向 Server 端发送数据，并等待 Server 的回复。但事情还没有完，虽然你自身不往 Server 发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故 Server 端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

  　　使用 TCP 的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和 SMTP 相对，用于接收邮件）、HTTP 协议等。
  1. UDP 协议　
  　　UDP 用户数据报协议，是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。
  　　UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP 不被应用于那些使用虚电路的面向连接的服务，UDP 主要用于那些面向查询---应答的服务，例如 NFS。相对于 FTP 或 Telnet，这些服务需要交换的信息量较小。
  　　每个 UDP 报文分 UDP 报头和 UDP 数据区两部分。报头由四个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP 报头由 4 个域组成，其中每个域各占用 2 个字节，具体如下：
  　　（1）源端口号；
  　　（2）目标端口号；
  　　（3）数据报长度；
  　　（4）校验值。
  　　使用 UDP 协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。
  　　TCP 与 UDP 的区别：TCP 是面向连接的，可靠的字节流服务；UDP 是面向无连接的，不可靠的数据报服务。
  回到顶部
  9. DNS 协议
  　　DNS 是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将 URL 转换为 IP 地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的 IP 地址，在 Internet 上域名与 IP 地址之间是一一对应的，DNS 就是进行域名解析的服务器。DNS 命名用于 Internet 等 TCP/IP 网络中，通过用户友好的名称查找计算机和服务。
  回到顶部
  10. NAT 协议
  　　NAT 网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法 IP 地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。原因很简单，NAT 不仅完美地解决了 lP 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

  回到顶部
  11. DHCP 协议
  　　DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

  回到顶部
  12. HTTP 协议
  　　超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。
  　　HTTP 协议包括哪些请求？

  　　GET：请求读取由 URL 所标志的信息。

  　　POST：给服务器添加信息（如注释）。

  　　PUT：在给定的 URL 下存储一个文档。

  　　DELETE：删除给定的 URL 所标志的资源。

  　　HTTP 中，POST 与 GET 的区别

  　　1）Get 是从服务器上获取数据，Post 是向服务器传送数据。

  　　2）Get 是把参数数据队列加到提交表单的 Action 属性所指向的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。

  　　3）Get 传送的数据量小，不能大于 2KB；Post 传送的数据量较大，一般被默认为不受限制。

  　　4）根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。

  　　I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

  　　II. 幂等 的意味着对同一 URL 的多个请求应该返回同样的结果。

  回到顶部
  13. 一个举例
  　　在浏览器中输入 www.baidu.com  后执行的全部过程

  　　现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com,而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：

  　　1）客户端浏览器通过 DNS 解析到 www.baidu.com 的 IP 地址 220.181.27.48，通过这个 IP 地址找到客户端到服务器的路径。客户端浏览器发起一个 HTTP 会话到 220.161.27.48，然后通过 TCP 进行封装数据包，输入到网络层。

  　　2）在客户端的传输层，把 HTTP 会话请求分成报文段，添加源和目的端口，如服务器使用 80 端口监听客户端的请求，客户端由系统随机选择一个端口如 5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用 IP 层的 IP 地址查找目的端。

  　　3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

  　　4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。
*** Wget 实现整站下载
**** 下载整站数据，只需一条简单的命令：
  #下面的命令会在终端所在目录创建一个 www.qingsword.com 目录，将网站 www.qingsword.com 上的数据全部下载到这个目录中
  qing@qingsword.com$ wget -rck -np www.qingsword.com
  #对应参数解释：
  #-r，递归下载
  #-c，断点续传，若网站长时间未响应或中途断开，此参数可以让数据断点续传
  #-k，转换链接为本地链接
  #-np，--no-parent 不追溯至父级
**** 仅下载指定后缀的文件
  #参数-A 指定，仅下载 png 与 css 后缀的文件，网站中其他类型的文件将不会被下载
  qing@qingsword.com$ wget -rck -np -A '*.png','*.css' www.qingsword.com
**** 不下载指定后缀的文件
  #参数-R 指定，除了 html 以及 css 后缀的文件外，下载其余所有文件
  qing@qingsword.com$ wget -rck -np -R '*.html','*.css' www.qingsword.com
*** server
    按照 man service 的说明, service 本身是个命令, 这个 service 命令是用来启动 service 服务的, 其语法格式为:
    service SCRIPT COMMAND [OPTIONS]
    其解释为: service 运行一个位于/etc/init.d/下的脚本 SCRIPT, 或者是一个位于/etc/init 下 upstart 程序. upstart 是 ubuntu 中用来代替以前的 sysvinit 的启动程序(笔者猜测可能是由于以前 svsvinit 中叫做 startup, 所以现在较 upstart).
    本文先介绍/etc/init.d 下的服务, 说明一下怎么手动的添加一个服务, 并且让它自启动(如果你需要的话). 本文这是简单并且直观的介绍一下 service, 并不一定所有概念都准确, 如果读者想要更加准确的概念和更加全面的方法, 可以网上自己搜, 遍地都是.
**** 手动添加一个服务
     基于上面的解释, 其实添加一个服务很简单, 只需要添加一个脚本到/etc/init.d/并赋予它可执行权限即可. 如:

  sudo touch /etc/init.d/hello
  chmod +x /etc/init.d/hello
  这是 ubuntu 就认为有个叫 hello 的服务了. 可以试试键入 sudo service hell 再敲 TAB 键, 这时候应该就可以 tab 出来 hello 了, 这说明系统已经识别出来它是一个服务了.
   如果此时报错: hello.service not found, 则可能需要执行一下:

  sudo update-rc.d hello defaults
  下面来测试一下, 在 hello 中加入一行:

  #!/bin/bash
  echo "hello"
  第一行的"#!/bin/bash"一定要有, 否则有可能会报错.

  然后运行命令:

  sudo service hello start
  这时便会打印输出 hello(如果没有打印可以尝试用 sudo systemctl status sss.service 查看). 如果 hello 中的命令为 echo "hello" $1, 则会打印 hello start. 可见, 我们平时输入的 sudo service xxx start 中的 start, 也就是 man 中说的 COMMAND, 只不过是 service 传给 xxx 服务的第一个参数而已.

  至此, 我们已经有了一个可以简单显示 hello 的服务, 但是它不会自动启动, 这就如前文所说的, 服务不一定非要随开机自启动的. 后文会介绍如何添加自启动.

  3 service start / stop
  下面我们介绍如何添加 service 的 start / stop 等, 其实很简单, 只需要在上文所建的/etc/init.d/hello 加入:

  case "$1" in
      start)
          echo start
          ;;
      stop)
          echo stop
          ;;
      restart)
          echo restart
          ;;
  esac
  在对应的 case 中进行想要的工作即可.

**** 4 控制服务的自启动
  4.1 说明
  简单的说, 要让服务的自启动, 只需要在/etc/rc{RUNLEVEL}.d/中加入 S12ServiceName 的软链接, 指向/etc/init.d 中对应的脚本(如本文的 hello). 这里先且看说明, 稍后会介绍方法而不用手动一个个的添加:

  说明:

  S12ServiceName 中:
  表示该服务随启动自动启动, 如果是 K, 则表示 Kill(杀死进程);
  12 表示优先级, 数越小, 越是先执行.
  ServiceName 即服务名, 起始叫什么都行, 真正起作用的是软链接的目标, 不过一般最好与服务同名.
  其中的 RUNLEVEL 为系统的运行级别, 一般的 linux 分 8 个级别: 0-6 和一个'S'级别.
  0 代表关机(halt);
  6 代表重启(restart);
  1 级别是单用户模式(single),
  2-5 各有不同. 但是在 userlinux(包括 ubuntu)中 2-5 级别是毫无差别的.
  'S'级别是一个比较特殊的级别, 他应该是先于其他级别运行的级别(这一点有待考证).
  这里说明一下, 0-6 级别的运行是互斥的, 而不是叠加运行, 也就是说如果进入(move into)4 级别, 不是指 0-3 都要运行, 而只是完成 4 级别里所规定的服务.

  如果要查看系统当前的运行级别可以使用命令:

  runlevel
  显示的数字就是当前运行级别, 一般 ubuntu 桌面版在我们平时使用时进入的应该是 level 2.

**** 4.2 使用 update-rc.d 添加自启动
  虽然可以按照上文方法来手动添加, 但是更简单的是使用 update-rc.d 命令来添加. 如:

  sudo update-rc.d hello defaults
  如果要删除这个服务, 则:

  sudo update-rc.d hello remove
  可以看到, 运行添加时, 终端会显示:

  update-rc.d: warning: /etc/init.d/hello missing LSB information
  update-rc.d: see <http://wiki.debian.org/LSBInitScripts>
   Adding system startup for /etc/init.d/hello ...
     /etc/rc0.d/K20hello -> ../init.d/hello
     /etc/rc1.d/K20hello -> ../init.d/hello
     /etc/rc6.d/K20hello -> ../init.d/hello
     /etc/rc2.d/S20hello -> ../init.d/hello
     /etc/rc3.d/S20hello -> ../init.d/hello
     /etc/rc4.d/S20hello -> ../init.d/hello
     /etc/rc5.d/S20hello -> ../init.d/hello
  然后就可以看到在上述列表中的各个级别下, 创建了对应的软链接.

  remove 方法如果/etc/init.d/脚本还存在, 则需要使用-f 参数:

  sudo update-rc.d -f hello remove
  这样会删除各个软链接, 但是并不会删除/etc/init.d/下的脚本本身.
*** samba
**** samba 方式
  yum install samba-client.x86_64 #安装 samba 客户端
  smbclient //192.168.211.1/test_samba    #通过 samba 打开 windows 共享目录
  smbclient //192.168.1.1/smb_share/ -U smb_user  #系统提示输入 smb_user_passwd
  smbclient //192.168.1.1/smb_share/ smb_user_passwd -U smb_user  #不提示输入密码
  出现提示符： 
  smb: >

  get 下载文件

  put 上传文件

  cd 切换 windows 目录

  lcd 切换本地目录

  help 显示帮助

  ? 显示帮助

  ! 表示执行 liunx 本地的命令，如:!ls 显示本地目录下的内容

  smb 命令	说明	–
  ?或 help [command]	提供关于帮助或某个命令的帮助	
  ![shell command]	执行所用的 SHELL 命令，或让用户进入 SHELL 提示符	–
  cd [目录]	切换到服务器端的指定目录，如未指定，则 smbclient 返回当前本地目录	
  lcd [目录]	切换到客户端指定的目录	
  dir 或 ls	列出当前目录下的文件；	
  exit 或 quit	退出 smbclient	
  get file1 [file2]	从服务器上下载 file1，并以文件名 file2 存在本地机上；如果不想改名，可以把 file2 省略	
  mget file1 file2 file3 filen	从服务器上下载多个文件；	
  md 或 mkdir 目录	在服务器上创建目录	
  rd 或 rmdir 目录	删除服务器上的目录	
  put file1 [file2]	向服务器上传一个文件 file1,传到服务器上改名为 file2；	
  mput file1 file2 filen	向服务器上传多个文件	
  –	–	–
  mount 方式
  yum install cifs-utils #安装 cifs 工具包 （用于取代被淘汰的 smbfs）

  #首先创建被挂载的目录：
  $ mkdir windows

  #将共享文件夹挂载到 windows 文件夹：
  $ sudo mount -t cifs -o username=share,password=share //192.168.66.198/share ./windows

  mkdir /mnt/挂载点名称 #（创建一个挂载点）
  vi /etc/fstab #添加以下内容让操作系统启动后自动挂载 windows 机器上的共享文件夹到挂载点

  1
  //你的 windows 机器名/共享文件夹名 /mnt/你创建的挂载点 cifs rw,credentials=/etc/.smbpasswd 0 0

  mount -a #（让系统重新挂载所有在/etc/fstab 文件里面定义的挂载点）
  cd /mnt/挂载点名称 #（进入 windows 机器上的共享文件夹）
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11
  12
  13
  14
  15
  16
  其中几个参数表示含义：

  –	–
  cifs	Common Internet File System，可以理解为网络文件系统
  usrname	访问共享文件夹的用户名
  password	访问密码
  //192.168.66.198/share	表示网络文件夹的地址，注意这里最后不能加/，如果是//192.168.66.198/share/则会报如下错误：mount: //192.168.66.198/share/ is not a valid block device
  Tips：使用 mount 挂载的方法在系统重新启动后就会失效，如果希望开机时自动挂载，将下面设置加入/etc/fstab 文件最后面就可以了。

  SSH 方式
  假设 A 机(有 shell 环境，linux 或 win 下安装 cygwin)想要无密码访问 B 机（linux），则进行如下步骤 
  1、在 A 机用 ssh-keygen 生成公钥私钥（-t RSA 即可） 
  2、在 A 机用 ssh-copyid 将公钥发给 B 机并完成配置（用 ssh-copyid 要比手工配置 ssh 目录方便很多） 
  3、ssh username@b.ip 测试是否正常 
  4、scp 开始使用

  FTP 方式
  [待补充]
**** smb
***** 安装:
      sudo apt-get insall samba
      sudo apt-get install smbfs
***** 创建共享目录:
  mkdir /home/phinecos/share
  sudo chmod 777 /home/phinecos/share
***** 创建 Samba 配置文件:
  保存现有的配置文件
  sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak

  修改现配置文件
  sudo gedit /etc/samba/smb.conf
  在 smb.conf 最后添加

  [share]
  path = /home/phinecos/share
  available = yes
  browsealbe = yes
  public = yes
  writable = yes
***** 创建 samba 帐户
    sudo touch /etc/samba/smbpasswd
    sudo smbpasswd -a phinecos
  然后会要求你输入 samba 帐户的密码

   ［如果没有第四步，当你登录时会提示 session setup failed: NT_STATUS_LOGON_FAILURE］

***** 重启 samba 服务器
       sudo /etc/init.d/samba restart
       后来想起来，16.04 的服务是使用 systemd 进行管理了，查了一下相关的资料，发现重启服务的命令如下
       sudo systemctl restart  smbd.service

   或者
   Debian and debian-derivatives changed the service name from 'samba' to 'smbd'.
   Try service smbd restart.
***** 六. 测试
       smbclient -L //localhost/share
    
   win7 加个 -m SMB2
   smbclient -L //192.168.1.14/soft -m SMB2
***** 七，使用
   可以到 windows 下输入 ip 使用了，在文件夹处输入 "\\" + "Ubuntu 机器的 ip 或主机名" + "\\" + "share"

   Linux 上 smbclient 

   密码登录改配置
   主要就是把 security 改成 user guest ok 改成 no
***** smbclinet 命令说明  pwd 目录必须是传文件的目录
   ?或 help [command] 提供关于帮助或某个命令的帮助
   ![shell command] 执行所用的 SHELL 命令，或让用户进入 SHELL 提示符
   cd [目录] 切换到服务器端的指定目录，如未指定，则 smbclient 返回当前本地目录
   lcd [目录] 切换到客户端指定的目录；  
   dir 或 ls 列出当前目录下的文件；
   exit 或 quit 退出 smbclient
   get file1 file2 从服务器上下载 file1，并以文件名 file2 存在本地机上；
   如果不想改名，可以把 file2 省略
   mget file1 file2 file3 filen 从服务器上下载多个文件；
   md 或 mkdir 目录 在服务器上创建目录
   rd 或 rmdir 目录 删除服务器上的目录
   put file1 [file2] 向服务器上传一个文件 file1,传到服务器上改名为 file2；
   put file1 file2 filen 向服务器上传多个文件

*** ssh
 1、复制 SSH 密钥到目标主机，开启无密码 SSH 登录
 ssh-copy-id user@host
 如果还没有密钥，请使用 ssh-keygen 命令生成。

 2、从某主机的 80 端口开启到本地主机 2001 端口的隧道
 ssh -N -L2001:localhost:80 somemachine
 现在你可以直接在浏览器中输入 http://localhost:2001 访问这个网站。

 3、将你的麦克风输出到远程计算机的扬声器
 dd if=/dev/dsp | ssh -c arcfour -C username@host dd of=/dev/dsp
 这样来自你麦克风端口的声音将在 SSH 目标计算机的扬声器端口输出，但遗憾的是，声音质量很差，你会听到很多嘶嘶声。

 4、比较远程和本地文件
 ssh user@host cat /path/to/remotefile | diff /path/to/localfile –
 在比较本地文件和远程文件是否有差异时这个命令很管用。

 5、通过 SSH 挂载目录/文件系统
 sshfs name@server:/path/to/folder /path/to/mount/point
 从 http://fuse.sourceforge.net/sshfs.html 下载 sshfs，它允许你跨网络安全挂载一个目录。

 6、通过中间主机建立 SSH 连接
 ssh -t reachable_host ssh unreachable_host
 Unreachable_host 表示从本地网络无法直接访问的主机，但可以从 reachable_host 所在网络访问，这个命令通过到 reachable_host 的"隐藏"连接，创建起到 unreachable_host 的连接。

 7、将你的 SSH 公钥复制到远程主机，开启无密码登录 – 简单的方法
 ssh-copy-id username@hostname

 8、直接连接到只能通过主机 B 连接的主机 A
 ssh -t hostA ssh hostB
 当然，你要能访问主机 A 才行。

 9、创建到目标主机的持久化连接
 ssh -MNf <user>@<host>
 在后台创建到目标主机的持久化连接，将这个命令和你~/.ssh/config 中的配置结合使用：

 Host host
 ControlPath ~/.ssh/master-%r@%h:%p
 ControlMaster no

 所有到目标主机的 SSH 连接都将使用持久化 SSH 套接字，如果你使用 SSH 定期同步文件（使用 rsync/sftp/cvs/svn），这个命令将非常有用，因为每次打开一个 SSH 连接时不会创建新的套接字。

 10、通过 SSH 连接屏幕
 ssh -t remote_host screen –r
 直接连接到远程屏幕会话（节省了无用的父 bash 进程）。

 11、端口检测（敲门）
 knock <host> 3000 4000 5000 && ssh -p <port> user@host && knock <host> 5000 4000 3000
 在一个端口上敲一下打开某个服务的端口（如 SSH），再敲一下关闭该端口，需要先安装 knockd，下面是一个配置文件示例。

 [options]
 logfile = /var/log/knockd.log
 [openSSH]
 sequence = 3000,4000,5000
 seq_timeout = 5
 command = /sbin/iptables -A INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPT
 tcpflags = syn
 [closeSSH]
 sequence = 5000,4000,3000
 seq_timeout = 5
 command = /sbin/iptables -D INPUT -i eth0 -s %IP% -p tcp –dport 22 -j ACCEPT
 tcpflags = syn

 12、删除文本文件中的一行内容，有用的修复
 ssh-keygen -R <the_offending_host>
 在这种情况下，最好使用专业的工具。

 13、通过 SSH 运行复杂的远程 shell 命令
 ssh host -l user $(<cmd.txt)

 更具移植性的版本：
 ssh host -l user "`cat cmd.txt`"

 14、通过 SSH 将 MySQL 数据库复制到新服务器
 mysqldump –add-drop-table –extended-insert –force –log-error=error.log -uUSER -pPASS OLD_DB_NAME | ssh -C user@newhost "mysql -uUSER -pPASS NEW_DB_NAME"

 通过压缩的 SSH 隧道 Dump 一个 MySQL 数据库，将其作为输入传递给 mysql 命令，我认为这是迁移数据库到新服务器最快最好的方法。

 15、删除文本文件中的一行，修复"SSH 主机密钥更改"的警告
 sed -i 8d ~/.ssh/known_hosts

 16、从一台没有 SSH-COPY-ID 命令的主机将你的 SSH 公钥复制到服务器
 cat ~/.ssh/id_rsa.pub | ssh user@machine "mkdir ~/.ssh; cat >> ~/.ssh/authorized_keys"
 如果你使用 Mac OS X 或其它没有 ssh-copy-id 命令的*nix 变种，这个命令可以将你的公钥复制到远程主机，因此你照样可以实现无密码 SSH 登录。

 17、实时 SSH 网络吞吐量测试
 yes | pv | ssh $host "cat > /dev/null"

 通过 SSH 连接到主机，显示实时的传输速度，将所有传输数据指向/dev/null，需要先安装 pv。
 如果是 Debian：
 apt-get install pv

 如果是 Fedora：
 yum install pv
 （可能需要启用额外的软件仓库）。

 18、如果建立一个可以重新连接的远程 GNU screen
 ssh -t user@some.domain.com /usr/bin/screen –xRR

 人们总是喜欢在一个文本终端中打开许多 shell，如果会话突然中断，或你按下了"Ctrl-a d"，远程主机上的 shell 不会受到丝毫影响，你可以重新连接，其它有用的 screen 命令有"Ctrl-a c"（打开新的 shell）和"Ctrl-a a"（在 shell 之间来回切换），请访问 http://aperiodic.net/screen/quick_reference 阅读更多关于 screen 命令的快速参考。

 19、继续 SCP 大文件
 rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file

 它可以恢复失败的 rsync 命令，当你通过 VPN 传输大文件，如备份的数据库时这个命令非常有用，需要在两边的主机上安装 rsync。

 rsync –partial –progress –rsh=ssh $file_source $user@$host:$destination_file local -> remote

 或

 rsync –partial –progress –rsh=ssh $user@$host:$remote_file $destination_file remote -> local

 20、通过 SSH W/ WIRESHARK 分析流量
 ssh root@server.com ‘tshark -f "port !22″ -w -' | wireshark -k -i –

 使用 tshark 捕捉远程主机上的网络通信，通过 SSH 连接发送原始 pcap 数据，并在 wireshark 中显示，按下 Ctrl+C 将停止捕捉，但也会关闭 wireshark 窗口，可以传递一个"-c #"参数给 tshark，让它只捕捉"#"指定的数据包类型，或通过命名管道重定向数据，而不是直接通过 SSH 传输给 wireshark，我建议你过滤数据包，以节约带宽，tshark 可以使用 tcpdump 替代：

 ssh root@example.com tcpdump -w – ‘port !22′ | wireshark -k -i –

 21、保持 SSH 会话永久打开
 autossh -M50000 -t server.example.com ‘screen -raAd mysession’

 打开一个 SSH 会话后，让其保持永久打开，对于使用笔记本电脑的用户，如果需要在 Wi-Fi 热点之间切换，可以保证切换后不会丢失连接。

 22、更稳定，更快，更强的 SSH 客户端
 ssh -4 -C -c blowfish-cbc
 强制使用 IPv4，压缩数据流，使用 Blowfish 加密。

 23、使用 cstream 控制带宽
 tar -cj /backup | cstream -t 777k | ssh host ‘tar -xj -C /backup’

 使用 bzip 压缩文件夹，然后以 777k bit/s 速率向远程主机传输。Cstream 还有更多的功能，请访问 http://www.cons.org/cracauer/cstream.html#usage 了解详情，例如：

 echo w00t, i’m 733+ | cstream -b1 -t2

 24、一步将 SSH 公钥传输到另一台机器
 ssh-keygen; ssh-copy-id user@host; ssh user@host

 这个命令组合允许你无密码 SSH 登录，注意，如果在本地机器的~/.ssh 目录下已经有一个 SSH 密钥对，ssh-keygen 命令生成的新密钥可能会覆盖它们，ssh-copy-id 将密钥复制到远程主机，并追加到远程账号的~/.ssh/authorized_keys 文件中，使用 SSH 连接时，如果你没有使用密钥口令，调用 ssh user@host 后不久就会显示远程 shell。

 25、将标准输入（stdin）复制到你的 X11 缓冲区
 ssh user@host cat /path/to/some/file | xclip
 你是否使用 scp 将文件复制到工作用电脑上，以便复制其内容到电子邮件中？xclip 可以帮到你，它可以将标准输入复制到 X11 缓冲区，你需要做的就是点击鼠标中键粘贴缓冲区中的内容。

*** 搜索引擎
**** 查找文件 google 中可以加 filetype:doc
* 软件
** 编程
*** gcc 基于 C/C++的预处理器和编译器
    -o：指定生成的输出文件,所以编译多个文件是,-o 没有意义；
    -E：仅执行编译预处理； .i
    -S：将 C 代码转换为汇编代码；.s
    -wall：显示警告信息；
    -c：仅执行编译操作，不进行连接操作。.o
**** 1. 预处理 gcc -E test.c -o test.i
     -C:
     -H:
     -include:
**** 2. 编译为汇编代码   gcc -S test.i -o test.s
     masm=intel	汇编代码 
     -std 指定使用的语言标准
**** 3. gas  gcc -c test.s -o test.o
     :-Wa,option
     :-llibrary 连接名为 library 的库文件
     :-L 指定额外路径
     :-m32
**** 4. ld  gcc test.o -o test
     :-lobjc 这个-l 选项的特殊形式用于连接 Objective C 程序.
     :-nostartfiles 不连接系统标准启动文件,而标准库文件仍然正常使用.
     :-nostdlib 不连接系统标准启动文件和标准库文件.只把指定的文件传递给连接器.
     :-static 在支持动态连接(dynamic linking)的系统上,阻止连接共享库.该选项在其他系统上无效.
     :-shared 生成一个共享目标文件,他可以和其他目标文件连接产生可执行文件.只有部分系统支持该选项.
     :-symbolic 建立共享目标文件的时候,把引用绑定到全局符号上.对所有无法解析的引用作出警
     告(除非用连接编辑选项 `-Xlinker -z -Xlinker defs'取代).只有部分系统支持该选项.
     :-u symbol 使连接器认为取消了 symbol 的符号定义,从而连接库模块以取得定义.你可以使用多
     个 `-u'选项,各自跟上不同的符号,使得连接器调入附加的库模块.
     : [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
     : -lAR	在连 接文件列表中增加归档库文件 AR.可以多次使用这个选项. 凡指定一项 AR,ld 就会在路径列表中增加一项对 libar.a 的搜索.
     : -LSEARCHDIR   这个选项将路径 SEARCHDIR 添加到路径列表, ld 在这个列表中搜索归档库.
     可以多次使用这个选项.缺省的搜索路径集(不使用-L 时)取决于 ld 使用的
     模拟模式(emulation)及其配置.在连接脚本中,可以用 SEARCH_DIR 命令指定路径. 
     : -Tbss org
     : -Tdata org
     : -Ttext org
     把 org 作为输出文件的段起始地址 --- 特别是 --- bss,data,或 text 段.org 必须是十六进制整数. 
     : -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
     : -x    删除 全部 局部符号. 
     : -m 指定仿真环境,这里要与 gcc 的选项 -m32 一致; -V 显示 支持的仿真：本机支持   elf_x86_64   
     elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
     LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
     : 注意,如果连接器通过被编译器驱动来间接引用(比如 gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
     gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
     : `-b INPUT-FORMAT'
     `--format=INPUT-FORMAT' [binary]
     'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
     你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
     : `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld 的缺省输出格式配置
     为/各个机器上最常用的/ 格式. output-format 是一个 字符串,BFD 库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
     : [`-N']|[`--omagic']
     把 text 和 data 节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
     支持 Unix 风格的 magic number, 把输出标志为'OMAGIC'. 
**** 5. 检错
     : -Wall 产生尽可能多的警告信息
     : -Werror GCC 会在所有产生警告的地方停止编译
**** 6. 库文件连接 .a .so
     : 包含文件 -I /usr/dirpath    
     : 库   -L /dirpath   -llibname  不要.a 或.so 后缀
     : 强制静态库 gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
     静态库链接时搜索路径顺序：
     1. ld 会去找 GCC 命令中的参数-L
     2. 再找 gcc 的环境变量 LIBRARY_PATH
     3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初 compile gcc 时写在程序内的

     动态链接时、执行时搜索路径顺序:
     1. 编译目标代码时指定的动态库搜索路径
     2. 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径
     3. 配置文件/etc/ld.so.conf 中指定的动态库搜索路径
     4. 默认的动态库搜索路径/lib
     5. 默认的动态库搜索路径/usr/lib
     有关环境变量：
     LIBRARY_PATH 环境变量：指定程序静态链接库文件搜索路径
     LD_LIBRARY_PATH 环境变量：指定程序动态链接库文件搜索路径
**** 7. 调试
     -g:
     -gstabs:
     -gcoff:
     -gdwarf:
**** 8. 优化
     -O0 不优化
     -fcaller-saves: 
**** 9. 目标机选项(Target Option) 交叉编译
     -b machine 
     -V version 哪个版本的 gcc
**** 10.配置相关选项(Configuration Dependent Option)
     M680x0 选项
     i386 选项
**** 11.总体选项(Overall Option)
     -x language
     明确指出后面输入文件的语言为 language (而不是从文件名后缀得到的默认选择).

**** 12.目录选项(DIRECTORY OPTION)
     :-Idir 在头文件的搜索路径列表中添加 dir 目录.
     :-Ldir 在`-l'选项的搜索路径列表中添加 dir 目录.

**** 13.C 文件与 汇编文件编译
     以下涉及到不同编译器对符号的处理问题。比如我们写个汇编文件，汇编后，汇编文件中的符号未变，但是当我们写个 C 文件再生成目标文件后，源文件中的符号前可能加了下划线，当两者之间发生引用关系时可能无法连接，此时我们会用到下面的命令。
     : --change-leading-char
     : --remove-leading-char
     : --prefix-symbols=string
*** ldconfig 动态链接库管理命令
*** readelf 用于显示 elf 格式文件的信息
    : -a       --all
**** elf header
     描述了这个 elf 文件的一些信息，如数据格式是 big-endian 或者 little-endian
     运行平台、section header 的个数等。
***** section headers 是一个表，表中的每个条目描述了一个 section，
      如 section 在文件中的偏移，大小等。
***** section 中就是 elf 文件中"真正"的信息了。

*** objdump 显示二进制文件信息
    : -a|--archive-header 列出 archive 头/列表用'ar tv'
    : -d 反汇编
    : -S|--source
    : -m MACHINE| --architecture=MACHINE
    : -G|--stabs
*** gdb 功能强大的程序调试器
**** options gdb <program> [core]|[PID]
     -d 指定远程调试时串行接口的线路速度
     -batch 以批处理模式运行
     -c 指定要分析的核心转储文件
     -cd 指定工作目录
     -d 指定搜索源文件的目录
     -e 指定要执行的文件
     -f 调试时以标准格式输出文件名和行号
     -q 安静模式
     -s 指定符号的文件名
     -se 指定符号和要执行的文件名
     -tty 设置标准输出和输入设备
     -x 从指定的文件执行 gdb 命令
**** 常用的调试命令
     shell <command>
     make <make -args>

     运行参数
     set args 设定参数
     show args 查看运行参数
     运行环境
     path<dir> 设定程序的运行路径。
     show paths 查看程序的运行路径。
     set environment varname[=value]设置环境变量。如:set env USER=hchen
     show environment[varname]查看环境变量
     工作目录
     cd <dir>相当于 shell 的 cd 命令。
     pwd 显示当前的工作目录。
     程序的输入输出
     info terminal 显示程序用到的终端的模式
     使用重定向空值程序输出。如 run>outfile
     tty 命令可以指定写输入输出的终端设备。如 tty /dev/ttyb
     列出源码 ;l 3（开始行） 根据本地文件,没有就列不出 
     设置断点 ;b filename: <行号>;break +offset -offset 当前行号前后
     b filename: <函数名称>;
     b *<函数名称>;
     b *<代码地址> 
     break...if<condition>
     调试程序 ;r 
     继续执行 ;c
     删除断点 ;clear <行号>
     删除断点 ;d <编号>
     执行一行 ;n /s
     结束循环 ;until
     p $1 ($1 为历史记录变量); 
     p <数组名>显示数组元素;
     p <*数组指针>显示数组 int a[N]的特定值：
     p &var 显示变量地址
     显示变量类型;    whatis p
     显示各类信息   info b 显示断点信息
     finish 退出函数
     info r 寄存器信息
     info local 当前函数中的局部变量信息;
     info prog 显示被调试程序的执行状态
     break *_start+1 由于 gnu 调试时忽略开始处断点, 需要在开始标签处执行一个空指令
     print/d 显示十进制数字
     print/t 显示二进制数字
     print/x 显示 16 进制数字

     x/FMT ADDRESS.
     ADDRESS is an expression for the memory address to examine.
     FMT is a repeat count followed by a format letter and a size letter.
     Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
     t(binary), f(float), a(address), i(instruction), c(char), s(string)
     and z(hex, zero padded on the left).
     Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
     The specified number of objects of the specified size are printed
     according to the format.
     7.0 版本以上 gdb 的 disas 命令可以携带/m 参数，让汇编与 c 源码同时显示：disas /m main

     使用 x 命令可以查看特定内存的值:
     x/nyz
     其中 n 为要显示的字段数
     y 时输出格式, 它可以是:
     c 用于字符, d 用于十进制, x 用于 16 进制
     z 是要显示的字段长度, 它可以是:
     b 用于字节, h 用于 16 字节, w 用于 32 位字
     如:
     x/42cb 用于显示前 42 字节
     print-stack      查看堆栈               
     u start end      反汇编内存                       
     trace on          反汇编每一条                    
     trace-reg on    每执行一条打印 cpu               
     xp /32bx 0x90000  查询从 0x90000 开始的 32 个字节内容 
*** make GNU 的工程化编译工具
*** eclipse
**** eclipse 快捷键
   1. 常用快捷键
   这是使用工具的第一步，熟练使用快捷键对于我们编写程序会起到相当大帮助，所以这里笔者列出的快捷键建议大家必须都掌握。
   Ctrl + 鼠标左键（类、方法、属性的变量名词）：定位跟踪某变量声明或定义的位置
   Ctrl + S：保存当前文件
   Ctrl + X：剪切
   Ctrl + C：复制
   Ctrl + V：粘贴
   Ctrl + D：删除当前行
   Ctrl + F：查找/替换（当前编辑窗口）
   Ctrl + H：全局搜索
   Ctrl + /：注释当前行或多行代码
   Ctrl + Shift + C：注释当前行或多行代码
   Ctrl + Shift + F：格式化当前代码
   Ctrl + Shift + O：缺少的 Import 语句被加入，多余的 Import 语句被删除（先把光标定位到需导入包的类名上）
   Ctrl + Shift + S：保存所有文件
   Ctrl + Shift + X：把当前选中的文本全部变为大写
   Ctrl + Shift + Y：把当前选中的文本全部变为小写
   Alt + /：代码智能提示
   Alt + Shift + R：重命名（包括文件名、类名、方法名、变量名等等，非常好用）
   Alt + Shift + J：生成类或方法的注释
   Alt + Shift + S：打开 Source 窗口（生成 get、set 方法，实现、覆盖接口或类的方法，很常用）
   Alt + Shift + D, J：如果有 main 方法入口，则以 Debug 方式执行代码
   Alt + Shift + X, J：如果有 main 方法入口，则以 Run 方式执行代码
 
 
   2. 插件推荐
   Eclipse 默认情况下是一个纯净版的，所以功能简单，而开源 IDE 最为强大的莫过于各种插件，通过使用插件可以帮助我们减少大量编写代码的工作量，
   也帮助我们降低了编写代码的难度，所以懂得安装必要插件，也是熟练使用 IDE 的鉴证。
   ① hibernate Tools
   Hibernate Tools 是一套全新而且完整的面向 Hibernate3 的工具集合，它包含了 Eclipse 插件和 Ant 编译流程，是 JBoss Tools 的核心组件。使用该插件能大大减少我们
   使用 Hibernate 的工作量，支持自动生成全部 Hibernate 的 xml 文件、javabean、HTML 表单文件等。
   安装地址：http://download.jboss.org/jbosstools/updates/development/indigo/
   ② spring IDE
   Spring IDE 是 Spring 官方网站推荐的 Eclipse 插件，可提供在开发 Spring 时对 Bean 定义文件进行提示、验证并以可视化的方式查看各个 Bean 之间
   的依赖关系等，对基于 spring 框架的项目开发提供了有力的支持。
   安装地址：http://dist.springsource.com/release/TOOLS/update/e3.6/
   ③ Subclipse
   Subclipse 是基于 Eclipse 的 SVN 插件，支持所有版本的 Eclipse，团队开发必备插件。
   安装地址：http://subclipse.tigris.org/update_1.8.x
   ④ Findbugs
   FindBugs 是一个能静态分析源代码中可能会出现 Bug 的 Eclipse 插件工具。它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。
   利用这个工具，就可以在不实际运行程序的情况对软件进行分析。它可以帮助改进代码的质量。
   安装地址：http://findbugs.cs.umd.edu/eclipse/
   ⑤ Sysdeo Tomcat Launcher Plugin
   Sysdeo Tomcat Launcher Plugin 是 Tomcat 的 Eclipse 插件，帮助我们自动部署 tomcat 服务器。该插件不是必要插件，可以不装。
   下载地址：http://www.eclipsetotale.com/tomcatPlugin/tomcatPluginV33.zip
 
   插件安装方法
   插件大概有三种安装方法：
   第一种：知道在线安装地址。Eclipse→Help→Install New Software...→地址栏（Work with）中输入安装地址→
   勾选要安装的插件→Next→同意安装协议→Finish→等待安装完毕→按要求重启 Eclipse
   第二种：手动从官网下载好插件并手动与 Eclipse 集成。这种方法一般的思路是：先关闭 Eclipse，然后将下载好的插件解压后，复制到 Eclipse 安装目
   录下的 plugins 文件夹和 features 文件夹下，如果必要的话再创建一个 link 文件，再重新打开 Eclipse。
   第三种：在线搜索安装。Eclipse→Help→Eclipse Marketplace...→在搜索栏输入要查找的插件→点击 Install 按钮→等待安装完毕→按要求重启 Eclipse
   这里笔者推荐第一种，如果不知道安装地址，那么就用第三种，第二种方法有时操作错误的话就会出现问题，风险较大，所以不推荐。
 
   3. tomcat
   ① 配置
   Window→Preferences→Server→Runtime Environment→Add→Apache→选择 tomcat 版本→Next→更改显示名称（Name）
   →Browse...浏览选择事先解压好的 tomcat 文件夹→选择 jre→Finish→OK→打开 Servers 窗体→右击选择 New→Server→选择 tomcat 版本→
   选择刚配置好的 tomcat→Next→选择项目→Finish
   ② 使用心得
   当我们修改某处代码后，启动 tomcat 发现页面没有变化时，要先关掉 tomcat，右击 Servers 窗口中 tomcat 服务器图标，选择 Clean...
   来清理下编译后的源码，再启动 tomcat 来重新编译下源码。
   而且如果部署多个，或 tomcat 异常时，右击 Servers 窗口中 tomcat 服务器图标，选择 Properties，检查 General 选项右侧 Location 是否正确，
   如果不正确则点击 Switch Location。
   虽然一个 tomcat 支持同时启动多个项目，但项目多启动时会很慢，所以如果不是工程项目需要的话，建议 tomcat 只部署启动一个项目，将暂时无用的项目移除。
   当 web 项目启动加载时间过长导致 tomcat 启动失败的话，可适当延长 tomcat 启动超时的时间（默认 45 秒），双击 Servers 窗口中 tomcat
   服务器打开 tomcat 属性窗口，点击右上方 Timeouts 选项，修改 Start(in seconds)的时间。
   eclipse 默认情况下是调用 tomcat 接口模拟启动 tomcat，而不是真正启动 tomcat，所以大家经常会遇到一件怪事：启动 tomcat 后，虽然能正常进 web 项目首页，
   却仅不了 tomcat 小猫首页（即 http://localhost:8080/），并且 web 项目部署编译后生成的文件也不在 tomcat 文件目录下的 work 目录下。
   解决办法：如果 tomcat 服务器下已经部署了项目，就先要将其全部移除，即右击 Servers 窗口中 tomcat 服务器图标，选择 Add and Remove...，
   单击 Remove All 按钮，单击 Finish 按钮。之后先 Clean 清理下，再双击 tomcat 服务器图标打开属性窗口，选择左侧中间 Server Locations 选项，
   选择下方第二个单选按钮（Use Tomcat installation），并将 Deploy path 文本框中的"wtpwebapps"（默认值）改为 webapps，也就是 tomcat 中发布
   项目所在的文件夹名字，最好再将项目重新部署到 tomcat 上，启动 tomcat 后，就可以看到熟悉的小猫页面了，同时在 tomcat 文件目录下的 work 文件夹下也能
   看见熟悉的编译后的页面文件了。
   如果代码出现引入 javax.servlet.http.*报错，说明是缺少 tomcat 的 jar 包，引入即可。方法：在左侧资源管理器右击项目，选择 Build Path 下的
   Configure Build Path...，右侧点击 Add Library...按钮，选择 Server Runtime，点击 Next 后选择 tomcat，Finish。
 
   4. eclipse 常见配置
   ● 字体大小
   Window→Preferences→General→Appearance→Colors and Fonts→右侧窗口→Basic 选项→双击 Text Font
   ● 修改打开文件的编辑浏览器
   Window→Preferences→General→Editors→File Associations→选择要修改的文件类型→在下方选择编辑浏览器
   ● 显示/隐藏代码行号
   Window→Preferences→General→Editors→勾选 Show line numbers
   ● 添加自定义 jar 包 Libraries
   Window→Preferences→Java→Build Path→User Libraries→右侧点击 New...→输入名称→点击 Add JARs...→浏览选择相应的 jar 文件
   ● 配置 tomcat 等服务器
   Window→Preferences→Server→Runtime Environment→Add...→选择需要的服务器（以 tomcat 为例请见上面 tomcat 配置）
   ● 修改格式化代码的换行判定
   Window→Preferences→Java→Code Style→Formatter→右侧点击 New...→输入名称→点击 OK→在弹出的窗口选择 Line Wrapping 选项卡→修改 Maixmum line width 文本框的值（默认 80）
   ● 添加 xml 的 dtd、xsd 等 xml 语法规则文件，实现代码自动提示
   Window→Preferences→XML→XML Catalog→右侧点击 Add...→Key type 选择 Public ID→Location 浏览选择你所下载的 DTD 文件的物理位置→Key 填入 xml 文档头部 <!DOCTYPE sqlMapConfig PUBLIC 后面的那些 url 地址→OK
   ● 修改编码格式
   右击你要修改的项目/包/类→选择 Properties→在 Resource 选项右侧的 Text file encoding 下选择你需要的编码格式
   ● 相同名称（包括类名、方法名、变量名等等）以不同背景色标识出来
   见下图：

   或者按快捷键：Alt + Shift + O
 
   在 Window→Preferences 下有许多配置，这里并不可能介绍很全，所以只列出最为常用的，大家有时间可能多进这里看看，再多点点多试试就明白了。
 
 
   5. SVN
   ● 上传项目至 SVN 服务器
   右击要上传的项目→Team→Share Project...→SVN→创建新的资源库位置/使用现有的资源库→Next→（输入 URL 地址）→Next→使用项目名称作为文件夹名→Next→Finish→（输入用户名/密码）
   注意："使用项目名称作为文件夹名"时，要保证 SVN 服务器端已创建与项目名称相同的文件夹，否则会导入失败。如果 SVN 端创建的文件夹名与项目名称不符，则在该步骤选择"使用指定的模块名"以确保 SVN 服务器端与项目名称一致。
   ● 下载项目从 SVN 服务器
   在资源管理器空白处右击→Import...→选择 SVN 文件夹→从 SVN 检出项目→创建新的资源库位置/使用现有的资源库→Next→（输入 URL 地址）→Next→做为新项目检出，并使用新建项目向导进行配置→Finish→Yes→配置新建项目（如输入项目名称）→OK
   注意：这个"输入 URL 地址"与上面上传项目的不同，这个 URL 地址需要输入项目具体所在的文件夹，而上一个因为有"使用项目名称作为文件夹名"这步，所以不需要带文件夹名称。
   ● 提交、更新、还原文件
   选中需要提交的文件、jar包、javabean等文件然后右击→Team→选择相应的操作。（这个基本地球人看看都会，所以就不多说了）
** xclip 这个剪切板和 图形下的剪切板不是同一个
*** 保存到内部剪切板
   ls -al | xclip
*** 文件内容 到剪切板中
   xclip /etc/apt/sources.list
*** 输出到系统剪切板
   xclip -o
** softether vpn 客户端
    Please execute './vpnclient start' to run the SoftEther VPN Client Background Service.
    And please execute './vpncmd' to run the SoftEther VPN Command-Line Utility to configure SoftEther VPN Client.

  创建连接配置
  Create your connection setting using your assigned RapidVPN server details. Your file content must be similar to:
  #+BEGIN_SRC c++

  declare root
  {
  bool CheckServerCert false
  uint64 CreateDateTime 0
  uint64 LastConnectDateTime 0
  bool StartupAccount false
  uint64 UpdateDateTime 0
  declare ClientAuth
  {
  uint AuthType 1
  string Username rapidvpnusername
  }
  declare ClientOption
  {
  string AccountName rapidvpn1
  uint AdditionalConnectionInterval 1
  uint ConnectionDisconnectSpan 0
  string DeviceName se
  bool DisableQoS false
  bool HalfConnection false
  bool HideNicInfoWindow false
  bool HideStatusWindow false
  string Hostname x.x.x.x
  string HubName default
  uint MaxConnection 1
  bool NoRoutingTracking false
  bool NoTls1 false
  bool NoUdpAcceleration false
  uint NumRetry 4294967295
  uint Port 443
  uint PortUDP 0
  string ProxyName $
  byte ProxyPassword $
  uint ProxyPort 0
  uint ProxyType 0
  string ProxyUsername $
  bool RequireBridgeRoutingMode false
  bool RequireMonitorMode false
  uint RetryInterval 15
  bool UseCompress false
  bool UseEncrypt true
  }
  }

  #+END_SRC
  创建网卡
  VPN Client>remoteenable
  VPN Client>niccreate

  导入配置 VPN Client>accountimport
  配置连接名的密码 AccountUsernameSet rapidvpn1
  AccountPasswordSet rapidvpn1
  连接账号  accountconnect wum
  动态更新地址 #sudo dhclient vpn_se
  断开连接 accountdisconnect wum

  访问外网，则需要手动增加路由
  先配置 "/etc/sysctl.conf": #net.ipv4.ip_forward=1
**** 添加路由
  显示   route -n
  添加 sudo route add  -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.20.1 dev vpn_vpn_hua
  删除 route del -net  -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.20.1 dev vpn_vpn_hua

  ifup {interface}
  ifdown {interface}
** 触摸板和小红点
    关闭:sudo modprobe -r psmouse
    开启:sudo modprobe  psmouse
    只关闭触摸板: synclient touchpadoff=1
    开启:synclient touchpadoff=0
** 日志  
*** 启动日志
    /var/log/boot.log 
** 电源管理
    立刻关机：
  sudo halt
  sudo init 0
  sudo shutdown -h now
  sudo shutdown -h 0

  定时/延时关机：

  sudo shutdown -h 19:30
  sudo shutdown -h +30   ##单位为分钟
  重启：
  sudo reboot
  sudo init 6
  sudo shutdown -r now
  休眠：
  sudo pm-hibernate
  echo “disk” > /sys/power/state
  sudo hibernate-disk
  待机(挂起)：
  sudo pm-suspend
  sudo pm-suspend-hybrid

  echo “mem” > /sys/power/state

  sudo hibernate-ram
** 蓝牙连接
**** 蓝牙上电  
     [NEW] Controller 74:2F:68:6A:37:44 moon-0 [default] 
     [NEW] Device 00:07:61:76:8E:78 Logitech diNovo Edge 
     Agent registered 
     [bluetooth]# list 
     Controller 74:2F:68:6A:37:44 moon-0 [default] 
     [bluetooth]# show 
     Controller 74:2F:68:6A:37:44 
     Name: moon 
     Alias: moon-0 
     Class: 0x000000 
     Powered: no 
     Discoverable: no 
     Pairable: yes 
     UUID: PnP Information (00001200-0000-1000-8000-00805f9b34fb) 
     UUID: Generic Access Profile (00001800-0000-1000-8000-00805f9b34fb) 
     UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb) 
     UUID: A/V Remote Control (0000110e-0000-1000-8000-00805f9b34fb) 
     UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb) 
     Modalias: usb:v1D6Bp0246d0509 
     Discovering: no 
     [bluetooth]# power on 
     Failed to set power on: org.bluez.Error.Blocked 
     [bluetooth]# scan on 
     Failed to start discovery: org.bluez.Error.NotReady 
  [bluetooth]# devices 
  Device 00:07:61:76:8E:78 Logitech diNovo Edge 
  [bluetooth]# info 00:07:61:76:8E:78 
  Device 00:07:61:76:8E:78 
  Name: Logitech diNovo Edge 
  Alias: Logitech diNovo Edge 
  Class: 0x002540 
  Icon: input-keyboard 
  Paired: yes 
  Trusted: yes 
  Blocked: no 
  Connected: no 
  LegacyPairing: no 
  UUID: Human Interface Device… (00001124-0000-1000-8000-00805f9b34fb) 
  UUID: PnP Information (00001200-0000-1000-8000-00805f9b34fb) 
  Modalias: usb:v046DpB309d011B 
  [bluetooth]# connect 00:07:61:76:8E:78 
  Attempting to connect to 00:07:61:76:8E:78 
  Failed to connect: org.bluez.Error.Failed 
  原因及解决办法： 
  这是由于蓝牙设备没有上电造成的，可通过如下命令解决此问题： 
  rfkill unblock bluetooth 
  hciconfig hci0 up
** 服务
systemctl status networking.service
** traceroute 追踪数据传输路由状况。
tcpdump 命令行的抓包工具。
** 磁盘管理
   fdisk 磁盘分区命令，适用于2TB以下磁盘分区。 
parted 磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。
mkfs 格式化创建Linux文件系统。
partprobe 更新内核的硬盘分区表信息。
e2fsck 检查ext2/ext3/ext4类型文件系统。
mkswap 创建Linux交换分区。
swapon 启用交换分区。
swapoff 关闭交换分区。

** 安装包管理类
   //centos
   yum provides */libgcc_s.so.1    //根据文件名检查所属的包 
   yum search python       //查找与指定关键词相关的包
   yum info python         //查看指定包的信息
   yum list python         //查看指定包的简要信息
   yum install net-tools       //安装指定的包(net-tools包含netstat和ifconfig命令)
   yum remove libevent     //删除指定的包
   rpm -ivh xxxx.rpm --test    //安装指定的rpm包，加上--test代表只是测试
   rpm -e --nodeps openjavasdk //强行删除指定的包
   rpm -q python           //查询是否安装了该包
   rpm -ql python          //查询包安装涉及的目录
   rpm -qR python          //显示依赖项目，R=Require

   //ubuntu
   apt-cache show package  //获取包的相关信息，如说明、大小、版本等   
   apt-cache search package    //搜索软件包，同yum search
   apt-cache showpkg package_name  //显示软件包的依赖关系信息
   apt-cache depends package_name  //显示指定软件包所依赖的软件包。
   sudo dpkg -I iptux.deb#查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于--info）
   sudo dpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构（其中-c等价于--contents）
   sudo dpkg -i iptux.deb#安装iptux.deb软件包（其中-i等价于--install）
   sudo dpkg -l iptux#查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于--list）
   sudo dpkg -L iptux#查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）
   sudo dpkg -s iptux#查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于--status）
   sudo dpkg -r iptux#卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）
   
   查看系统已经安装的内核版本
   dpkg --get-selections |grep linux-image
   注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。

** 文件管理类
   find 路径 -iname "*.jar" -exec cp {} 目标目录 \;    //find和cp联动操作
** 进程\网络查看类
   ps -aux         //查看所有进程
   pgrep cron      //查询应用是否在运行，成功则返回pid
   netstat –apn        //查看所有占用了网络端口的应用
   netstat -tl     //参数“-t”是显示tcp数据包的连接行为，参数“-l”是显示监听状态。如果"netstat -tl"输出结果如上面代码所示，则说明服务器端ssh服务已启动。
   ip addr         //查看ip地址
** 后台运行
   linux命令行重定向：在shell中，分别用0，1，2分别代表标准输入，标准输出，异常输出。 
   在linux中，有个特殊的文件/dev/null，向其写入数据都会被丢弃。
 nohup ./startWebLogic.sh &  //让程序在后台运行，输出文件为nohup.out
 nohup command > myout.file 2>&1 &   //输出文件重定向为myout.file
 nohup command >/dev/null 2>$1 &    //×××忽略所有输出，重要×××
 jobs -l               //查看当前正在运行的job
 fg %s                 //关闭指定的job
** 定时运行
   cron是linux中用于处理定时任务的工具，关键信息格式：分时日月周
   分钟　（0-59） 
   小时　（0-23） 
   日期　（1-31） 
   月份　（1-12） 
   星期　（0-7）//0 7代表星期天 #周月日不可同时存在，否则语法错误。

*/3 * * * *    ls       #   每三分钟执行一次ls

crontab -e      //编辑当前用户的cron任务
crontab -l      //列出当前用户的cron任务
crontab -r      //删除当前任务的cron任务

service crond start|stop|restart|reload //对cron服务进行控制

系统定时任务配置

目录位置	描述
/etc/cron.hourly	目录下的脚本会每个小时让执行一次，在每小时的17分钟时运行；
/etc/cron.daily	目录下的脚本会每天让执行一次，在每天的6点25分时运行；
/etc/cron.weekly	目录下的脚本会每周让执行一次，在每周第七天的6点47分时运行；
/etc/cron.mouthly	目录下的脚本会每月让执行一次，在每月1号的6点52分时运行；
** 创建快捷方式
linux的快捷方式都存放于 /usr/share/applications，后缀名为.desktop,范例如下：

[Desktop Entry]
Name=eclipse
Comment=eclipse ide
Exec=/opt/eclipse_j2ee/eclipse
Icon=/opt/eclipse_j2ee/icon.xpm
Terminal=false
Type=Application
Categories=Application;Development;
StartupNotify=true

** 修改ip地址
ip addr #查看当前的ip地址
cat /etc/resolv.conf    #查看dns网络地址
vim /etc/sysconfig/network-scripts/ifcfg-exxx   #编辑网卡配置文件

BOOTPROTO="static" 网卡获得ip地址的方式，static（静态 ip地址）dhcp（通过dhcp协议获取ip）
IPADDR="192.168.211.144"
GATEWAY="192.168.211.2" #重要：虚拟机linux设静态ip必须设置Gateway，而且一定指向x.x.x.2那个地址
ONBOOT="yes" 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。默认设置为yes
** shell 
*** guake 
*** tilda  
* 一般问题
** 中文乱码  
*** unzip 中文乱码 
    zip 中文乱码 unzip -O cp936 /-O gbk gb18030 都可以
    指定目录 -d
    或 7z 或
#+BEGIN_SRC python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import zipfile

#print "Processing File " + sys.argv[1]

file=zipfile.ZipFile(sys.argv[1],"r");
for name in file.namelist():
    utf8name=name.decode('gbk')
#    print "Extracting " + utf8name
    pathname = os.path.dirname(utf8name)
    if not os.path.exists(pathname) and pathname!= "":
        os.makedirs(pathname)
    data = file.read(name)
    if not os.path.exists(utf8name):
        fo = open(utf8name, "w")
        fo.write(data)
        fo.close
file.close()
#+END_SRC

** 重启输入法
   #!/bin/sh
   pidof fcitx | xargs kill
   pidof sogou-qimpanel | xargs kill
   nohup fcitx  1>/dev/null 2>/dev/null &
   nohup sogou-qimpanel  1>/dev/null 2>/dev/null &
** xrandr 
    关闭笔记本，开外置：xrandr --output VGA-1-1 --auto --output LVDS-1-1 --off
** 识别 usb
   最近项目需要在 Android 源码中进行开发，于是在 Virtual Box 中安装 Ubuntu，郁闷的是插上 usb 连接线，连接上手机，Ubuntu 不能自动识别连接设备。在网上搜索了很多解决办法，各抒己见，最终找到一种可行的解决方案：
   1、安装 usbmount
   $ sudo apt-get install usbmount  
   2、更改 usbmount 配置文件
   $ sudo gedit /etc/usbmount/usbmount.conf  
 3、在打开的文件中找到 FILESYSTEM，并在其中添加 vfat,ntfs
 4、FS_MOUNTOPTIONS 这个选项里加入”"-fstype= vfat,iocharset=utf8,codepage=936,umask=000,users”
 5、重启 udev
 $sudo /etc/init.d/udev restart  
 6、重启 Ubuntu
 $ sudo reboot  
 重启之后即可识别 USB。
** 服务 systemctl 
   systemctl is-enabled servicename.service #查询服务是否开机启动
   systemctl enable *.service #开机运行服务
   systemctl disable *.service #取消开机运行
 systemctl start *.service #启动服务
 systemctl stop *.service #停止服务
 systemctl restart *.service #重启服务
 systemctl reload *.service #重新加载服务配置文件
 systemctl status *.service #查询服务运行状态 
** 开机启动
   update-rc.d 使用
   update-rc.d 是一个 Perl 脚本，是用来自动升级 System V 类型初始化脚本，简单来说就是哪些东西是你想要在系统引导初始化的时候运行的，哪些是希望在关机或重启时候停止的，都可以用它来帮你设置。这些脚本的连接位于/etc/rcX.d/下（X 代表 0～6），对应脚本位于/etc/init.d/下。
   1、设置启动项：
   update-rc.d <serviceName> start <order> <runlevel>
  
 2、设置停止项：
 update-rc.d <serviceName> stop <order> <runlevel>
 设置启动和停止可以写在一起，例如：
 sudo update-rc.d <serviceName> start 20 1 2 3 4 5 . stop 60 0 6 .   
 一定要注意，写在一起的时候后面的两个“.”符号一定要有，不然报错。

 3、从所有的运行级别中删除制定的启动项
 update-rc.d -f <serviceName> remove
 示例
 根据上面的介绍，如何将一个软件安装为服务也就比较清楚了，那就是在/etc/init.d 添加一个服务的启动脚本，然后在需要启动服务的对应级别中/etc/rc[0~6].d 按照文件名格式添加一个指向/etc/init.d 的脚本符号链接。
 以 apache2 为例，默认情况下，apache2 编译安装在/usr/local/apache2，apache2 的服务器启动脚本是/usr/local/apache2/bin/apachectl，那么安装服务就是要把此 apachectl 拷贝到需要启动 apache2 服务器的运行级别对应的/etc/rc[0~6].d 目录下，一半来说 ubuntu 的运行级别为 2，所以也就是拷贝到/etc/rc2.d 下。

 sudo cp /usr/local/apache2/bin/apachectl /etc/init.d/apache2  
 如果手动添加的话：
 sudo ln -s /etc/init.d/apache2 /etc/rc2.d/S80apache2  
 重启服务器后，就可以看到 apache2 自动启动了。
 这时如果想要停止或重启 apache2 也可以使用以下命令：

 service apache2 stop  
 service apache2 restart  

** 查看错误
   vi /var/log/message
   然后查找你所需要的内容把    
   您也可以 grep warning 这样的条目
   使用 tail 和 grep 只是为了使您查看起来更方便简捷更有针对性而已哦
** 临时域名
    ./natapp -authtoken=e5eb817e91aeee83 
** emacs 中文 
   最简单的办法是替换 emacs 的启动文件，就是那个.desktop 文件 
   在/usr/share/applications/下面。
   直接改成
   Exec=env LC_CTYPE=zh_CN.UTF-8 emacs25 %F
* 网络
  已知 ip 地址，查主机名最简单的方法就是使用命令，以下是两种方法：
  1、使用 ping 命令加上参数-a 的方法反解析 IP 地址，可以得到主机名。
  2、使用 nbtstat 命令加上-a 参数再加上 IP 地址的方法。
  bunzip2 linux-2.6.13.tar.bz2 | tar xvf -
* 测试Web地址 
  Web地址会发生变化。这些地址有时候似乎每天都在变。所以在脚本中测试地址的有效性就非常重
  要。可以使用wget 工具的--spider 选项完成这项任务。
  
  $ url=www.quotationspage.com/qotd.html
  $ wget --spider $url
* 常用命令
** 安装包管理类
   //centos
   yum provides */libgcc_s.so.1    //根据文件名检查所属的包 
   yum search python       //查找与指定关键词相关的包
   yum info python         //查看指定包的信息
   yum list python         //查看指定包的简要信息
   yum install net-tools       //安装指定的包(net-tools 包含 netstat 和 ifconfig 命令)
   yum remove libevent     //删除指定的包
   rpm -ivh xxxx.rpm --test    //安装指定的 rpm 包，加上--test 代表只是测试
   rpm -e --nodeps openjavasdk //强行删除指定的包
   rpm -q python           //查询是否安装了该包
   rpm -ql python          //查询包安装涉及的目录
   rpm -qR python          //显示依赖项目，R=Require

   //ubuntu
   apt-cache show package  //获取包的相关信息，如说明、大小、版本等   
   apt-cache search package    //搜索软件包，同 yum search
   apt-cache showpkg package_name  //显示软件包的依赖关系信息
   apt-cache depends package_name  //显示指定软件包所依赖的软件包。
   sudo dpkg -I iptux.deb#查看 iptux.deb 软件包的详细信息，包括软件名称、版本以及大小等（其中-I 等价于--info）
   sudo dpkg -c iptux.deb#查看 iptux.deb 软件包中包含的文件结构（其中-c 等价于--contents）
   sudo dpkg -i iptux.deb#安装 iptux.deb 软件包（其中-i 等价于--install）
   sudo dpkg -l iptux#查看 iptux 软件包的信息（软件名称可通过 dpkg -I 命令查看，其中-l 等价于--list）
   sudo dpkg -L iptux#查看 iptux 软件包安装的所有文件（软件名称可通过 dpkg -I 命令查看，其中-L 等价于--listfiles）
   sudo dpkg -s iptux#查看 iptux 软件包的详细信息（软件名称可通过 dpkg -I 命令查看，其中-s 等价于--status）
   sudo dpkg -r iptux#卸载 iptux 软件包（软件名称可通过 dpkg -I 命令查看，其中-r 等价于--remove）
   注：dpkg 命令无法自动解决依赖关系。如果安装的 deb 包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。

** 文件管理类
   find 路径 -iname "*.jar" -exec cp {} 目标目录 \;    //find 和 cp 联动操作
** 进程\网络查看类
   ps -aux         //查看所有进程
   pgrep cron      //查询应用是否在运行，成功则返回 pid
   netstat –apn        //查看所有占用了网络端口的应用
   netstat -tl     //参数“-t”是显示 tcp 数据包的连接行为，参数“-l”是显示监听状态。如果"netstat -tl"输出结果如上面代码所示，则说明服务器端 ssh 服务已启动。
   ip addr         //查看 ip 地址
** 后台运行
linux 命令行重定向：在 shell 中，分别用 0，1，2 分别代表标准输入，标准输出，异常输出。 
在 linux 中，有个特殊的文件/dev/null，向其写入数据都会被丢弃。

 nohup ./startWebLogic.sh &  //让程序在后台运行，输出文件为 nohup.out
 nohup command > myout.file 2>&1 &   //输出文件重定向为 myout.file
 nohup command >/dev/null 2>$1 &    //×××忽略所有输出，重要×××
 jobs -l               //查看当前正在运行的 job
 fg %s                 //关闭指定的 job
** 定时运行
cron 是 linux 中用于处理定时任务的工具，关键信息格式：分时日月周

分钟　（0-59） 
小时　（0-23） 
日期　（1-31） 
月份　（1-12） 
星期　（0-7）//0 7 代表星期天 #周月日不可同时存在，否则语法错误。

*/3 * * * *    ls       #   每三分钟执行一次 ls

crontab -e      //编辑当前用户的 cron 任务
crontab -l      //列出当前用户的 cron 任务
crontab -r      //删除当前任务的 cron 任务

service crond start|stop|restart|reload //对 cron 服务进行控制

系统定时任务配置

目录位置	描述
/etc/cron.hourly	目录下的脚本会每个小时让执行一次，在每小时的 17 分钟时运行；
/etc/cron.daily	目录下的脚本会每天让执行一次，在每天的 6 点 25 分时运行；
/etc/cron.weekly	目录下的脚本会每周让执行一次，在每周第七天的 6 点 47 分时运行；
/etc/cron.mouthly	目录下的脚本会每月让执行一次，在每月 1 号的 6 点 52 分时运行；
** 创建快捷方式
linux 的快捷方式都存放于 /usr/share/applications，后缀名为.desktop,范例如下：

[Desktop Entry]
Name=eclipse
Comment=eclipse ide
Exec=/opt/eclipse_j2ee/eclipse
Icon=/opt/eclipse_j2ee/icon.xpm
Terminal=false
Type=Application
Categories=Application;Development;
StartupNotify=true
** 清理空间
   BleachBit
** 清理 boot 内核
ubuntu 使用时间长了后，积累了不少已经过期的内核，导致 boot 区不够用。
#查询
dpkg --get-selections |grep linux-image
#查看当前内核版本
uname -a
#清理指定版本内核（重要：可别把当前版本给清理了）
sudo apt-get purge linux-image-3.5.0-17-generic
#也可以使用自动删除(比较安全，定期执行下即可)
sudo apt-get autoremove

** 修改 ip 地址
ip addr #查看当前的 ip 地址
cat /etc/resolv.conf    #查看 dns 网络地址
vim /etc/sysconfig/network-scripts/ifcfg-exxx   #编辑网卡配置文件

BOOTPROTO="static" 网卡获得 ip 地址的方式，static（静态 ip 地址）dhcp（通过 dhcp 协议获取 ip）
IPADDR="192.168.211.144"
GATEWAY="192.168.211.2" #重要：虚拟机 linux 设静态 ip 必须设置 Gateway，而且一定指向 x.x.x.2 那个地址
ONBOOT="yes" 系统启动时是否设置此网络接口，设置为 yes 时，系统启动时激活此设备。默认设置为 yes
* 企业运维命令
** 文件和目录操作命令(18 个)
ls 全拼 list，功能是列出目录的内容及其内容属性信息。
cd 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。
cp 全拼 copy，其功能为复制文件或目录。
find 查找的意思，用于查找目录及目录下的文件。
mkdir 全拼 make directories，其功能是创建目录。
mv 全拼 move，其功能是移动或重命名文件。
pwd 全拼 print working directory，其功能是显示当前工作目录的绝对路径。
rename 用于重命名文件。
rm 全拼 remove，其功能是删除一个或多个文件或目录。
rmdir 全拼 remove empty directories，功能是删除空目录。
touch 创建新的空文件，改变已有文件的时间戳属性。
tree 功能是以树形结构显示目录下的内容。
basename 显示文件名或目录名。
dirname 显示文件或目录路径。
chattr 改变文件的扩展属性。
lsattr 查看文件扩展属性。
file 显示文件的类型。
md5sum 计算和校验文件的 MD5 值。
** 查看文件及内容处理命令（21 个） 
cat 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。
tac tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。
more 分页显示文件内容。
less 分页显示文件内容，more 命令的相反用法。
head 显示文件内容的头部。
tail 显示文件内容的尾部。
cut 将文件的每一行按指定分隔符分割并输出。
split 分割文件为不同的小片段。
paste 按行合并文件内容。
sort 对文件的文本内容排序。
uniq 去除重复行。oldboy
wc 统计文件的行数、单词数或字节数。
iconv 转换文件的编码格式。
dos2unix 将 DOS 格式文件转换成 UNIX 格式。
diff 全拼 difference，比较文件的差异，常用于文本文件。
vimdiff 命令行可视化文件比较工具，常用于文本文件。
rev 反向输出文件内容。
grep/egrep 过滤字符串，三剑客老三。
join 按两个文件的相同字段合并。
tr 替换或删除字符。
vi/vim 命令行文本编辑器。
** 文件压缩及解压缩命令（4 个）
tar 打包压缩。oldboy
unzip 解压文件。
gzip gzip 压缩工具。
zip 压缩工具。

** 信息显示命令（11 个）
   uname 显示操作系统相关信息的命令。
   hostname 显示或者设置当前系统的主机名。
   dmesg 显示开机信息，用于诊断系统故障。
   uptime 显示系统运行时间及负载。
   stat 显示文件或文件系统的状态。
   du 计算磁盘空间使用情况。
   df 报告文件系统磁盘空间的使用情况。
   top 实时显示系统资源使用情况。
   free 查看系统内存。
   date 显示与设置系统时间。
   cal 查看日历等时间信息。
** 搜索文件命令（4 个） 
which 查找二进制命令，按环境变量 PATH 路径查找。
find 从磁盘遍历查找文件或目录。
whereis 查找二进制命令，按环境变量 PATH 路径查找。
locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。
** 用户管理命令（10 个） 
useradd 添加用户。 
usermod 修改系统已经存在的用户属性。
userdel 删除用户。 
groupadd 添加用户组。
passwd 修改用户密码。
chage 修改用户密码有效期限。
id 查看用户的 uid,gid 及归属的用户组。
su 切换用户身份。
visudo 编辑/etc/sudoers 文件的专属命令。
sudo 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。

** 基础网络操作命令（11 个）
telnet 使用 TELNET 协议远程登录。
ssh 使用 SSH 加密协议远程登录。
scp 全拼 secure copy，用于不同主机之间复制文件。
wget 命令行下载文件。

ping

测试主机之间网络的连通性。

route

显示和设置 linux 系统的路由表。

ifconfig

查看、配置、启用或禁用网络接口的命令。

ifup

启动网卡。

ifdown

关闭网卡。

netstat

查看网络状态。

ss

查看网络状态。

深入网络操作命令（9 个）

nmap

网络扫描命令。

lsof

全名 list open files，也就是列举系统中已经被打开的文件。

mail

发送和接收邮件。

mutt

邮件管理命令。

nslookup

交互式查询互联网 DNS 服务器的命令。

dig

查找 DNS 解析过程。

host

查询 DNS 的命令。

traceroute

追踪数据传输路由状况。

tcpdump

命令行的抓包工具。

有关磁盘与文件系统的命令（16 个）

mount

挂载文件系统。

umount

卸载文件系统。

fsck

检查并修复 Linux 文件系统。

dd

转换或复制文件。

dumpe2fs

导出 ext2/ext3/ext4 文件系统信息。

dump

ext2/3/4 文件系统备份工具。

fdisk

磁盘分区命令，适用于 2TB 以下磁盘分区。

parted

磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。

mkfs

格式化创建 Linux 文件系统。

partprobe

更新内核的硬盘分区表信息。

e2fsck

检查 ext2/ext3/ext4 类型文件系统。

mkswap

创建 Linux 交换分区。

swapon

启用交换分区。

swapoff

关闭交换分区。

sync

将内存缓冲区内的数据写入磁盘。

resize2fs

调整 ext2/ext3/ext4 文件系统大小。

系统权限及用户授权相关命令（4 个）

chmod

改变文件或目录权限。

chown

改变文件或目录的属主和属组。

chgrp

更改文件用户组。

umask

显示或设置权限掩码。

查看系统用户登陆信息的命令（7 个）

whoami

显示当前有效的用户名称，相当于执行 id -un 命令。

who

显示目前登录系统的用户信息。

w

显示已经登陆系统的用户列表，并显示用户正在执行的指令。

last

显示登入系统的用户。

lastlog

显示系统中所有用户最近一次登录信息。

users

显示当前登录系统的所有用户的用户列表。

finger

查找并显示用户信息。

内置命令及其它（19 个）

echo

打印变量，或直接输出指定的字符串

printf

将结果格式化输出到标准输出。

rpm

管理 rpm 包的命令。

yum

自动化简单化地管理 rpm 包的命令。

watch

周期性的执行给定的命令，并将命令的输出以全屏方式显示。

alias

设置系统别名。

unalias

取消系统别名。

date

查看或设置系统时间。

clear

清除屏幕，简称清屏。

history

查看命令执行的历史纪录。

eject

弹出光驱。

time

计算命令执行时间。

nc

功能强大的网络工具。

xargs

将标准输入转换成命令行参数。

exec

调用并执行指令的命令。

export

设置或者显示环境变量。

unset

删除变量或函数。

type

用于判断另外一个命令是否是内置命令。

bc

命令行科学计算器

系统管理与性能监视命令(9 个)

chkconfig

管理 Linux 系统开机启动项。

vmstat

虚拟内存统计。

mpstat

显示各个可用 CPU 的状态统计。

iostat

统计系统 IO。

sar

全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、CPU 中断和网络等性能数据。

ipcs

用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。

ipcrm

用来删除一个或更多的消息队列、信号量集或者共享内存标识。

strace

用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。

ltrace

命令会跟踪进程的库函数调用,它会显现出哪个库函数被调用。

关机/重启/注销和查看系统信息的命令（6 个）

shutdown

关机。

halt

关机。

poweroff

关闭电源。

logout

退出当前登录的 Shell。

exit

退出当前登录的 Shell。

Ctrl+d

退出当前登录的 Shell 的快捷键。

进程管理相关命令（15 个）

bg

将一个在后台暂停的命令，变成继续执行  （在后台执行）。

fg

将后台中的命令调至前台继续运行。

jobs

查看当前有多少在后台运行的命令。

kill

终止进程。

killall

通过进程名终止进程。

pkill

通过进程名终止进程。

crontab

定时任务命令。

ps

显示进程的快照。

pstree

树形显示进程。

nice/renice

调整程序运行的优先级。

nohup

忽略挂起信号运行指定的命令。

pgrep

查找匹配条件的进程。

runlevel

查看系统当前运行级别。

init

切换运行级别。

service

启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。
>>>>>>> b78813fb51481d8d9e0e2178a5c96fdc0c31ef5a
