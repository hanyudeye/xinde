#+TITLE: thinkphp 简介
#+DESCRIPTION: thinkphp 简介
#+TAGS: thinkphp 
#+CATEGORIES: 框架使用
#+DATE: <2019-09-18 07:18:21>
#+LAYOUT: noshow

* Thinkphp 简介
 #+begin_verse
 此框架遵循 *MVC* 模式 ，做了一下 逻辑和视图的封装，使得程序的逻辑处理(完成事情)和界面设计(把事情的结果美化)可以分工化，专注于一方面。
 这些程序框架是便于结构化写具体功能的啊，通用的都给你弄好了。
 #+end_verse
 
#+HTML: <!-- more -->

** 测试运行
   启动服务:php	-S	localhost:8888	router.php
   运行 localhost:8888/模块/控制器类名/类方法
** 架构
*** 路由 (对 url 路径的设计，你会如何设计?)
**** 默认路由
     http://serverName/index.php/module/controller/function/arg/value...
**** 普通形式
     php index.php(或者其它应用入口文件) 模块/控制器/操作?参数名=参数值&...
**** 自定义规则
** 配置
*** 配置目录 APP_PATH
    config.php 应用配置文件
    database.php 数据库配置文件
    route.php 路由配置文件
    
    // 定义配置文件目录和应用目录同级
    define('CONF_PATH', __DIR__.'/../config/');

*** 配置格式  数组方式
    
    #+begin_src php
      return [
          // 应用命名空间
          'app_namespace'          => 'app'
      ];
    #+end_src
*** 配置加载 自动
    其他目录 Config::load('配置文件名');

*** 读取配置
    #+begin_src php
      use think\Config;
      echo config('配置参数 1');

      Config::has('配置参数 2');
      // 或者 config('?配置参数 2');

      echo Config::get('配置参数.二级参数');
      echo config('配置参数.二级参数');
    #+end_src

*** 动态配置
    #+begin_src php
      Config::set([
          '配置参数 1'=>'配置值',
          '配置参数 2'=>'配置值'
      ]);
      // 或者使用助手函数
      config([
          '配置参数 1'=>'配置值',
          '配置参数 2'=>'配置值'
      ]);
    #+end_src

*** 独立配置
*** 配置作用域  (作用域隔离)
    #+begin_src php
      // 导入 my_config.php 中的配置参数,并纳入 user 作用域
      Config::load('my_config.php','','user');
      // 解析并导入 my_config.ini 中的配置参数,读入 test 作用域
      Config::parse('my_config.ini','ini','test');
      // 设置 user_type 参数,并纳入 user 作用域
      Config::set('user_type',1,'user');
      // 批量设置配置参数,并纳入 test 作用域
      Config::set($config,'test');
      // 读取 user 作用域的 user_type 配置参数
      echo Config::get('user_type','user');
      // 读取 user 作用域下面的所有配置参数
      dump(Config::get('','user'));
      dump(config('',null,'user')); // 同上
      // 判断在 test 作用域下面是否存在 user_type 参数
      Config::has('user_type','test');

    #+end_src
*** 环境变量配置
    配置文件 ROOT/.env
    格式,不支持数组 
    #+begin_src ini
app_debug = true
app_trace = true

database_username = root
database_password = 123456

[database]
username = root
password = 123456
     #+end_src

     //获取环境变量，如果不存在则使用默认值 root
    Env::get('database.username', 'root');
** 路由
*** 路由模式
*** 路由定义
    Route::rule('路由表达式','路由地址','请求类型','路由参数(数组)','变量规则(数组)');
    
    #+begin_src php
    use think\Route;
    // 注册路由到 index 模块的 News 控制器的 read 操作
    Route::rule('new/:id','index/News/read');
    #+end_src
    访问 http://serverName/new/5
    路由到 http://serverName/index/news/read/id/5


    可以在 rule 方法中指定请求类型,不指定的话默认为任何请求类型,例如:
    Route::rule('new/:id','News/update','POST');
    
    系统提供了为不同的请求类型定义路由规则的简化方法,例如:
    Route::get('new/:id','News/read'); // 定义 GET 请求路由规则
    Route::post('new/:id','News/update'); // 定义 POST 请求路由规则
    Route::put('new/:id','News/update'); // 定义 PUT 请求路由规则
    Route::delete('new/:id','News/delete'); // 定义 DELETE 请求路由规则
    Route::any('new/:id','News/read'); // 所有请求都支持的路由规则
    如果要定义 get 和 post 请求支持的路由规则,也可以用:
    Route::rule('new/:id','News/read','GET|POST');

*** 批量注册
*** 变量规则
*** 组合变量
*** 路由参数
*** 路由地址
*** 资源路由
*** 快捷路由
*** 路由别名
*** 路由分组
*** MISS 路由
*** 闭包支持
*** 路由绑定
*** 绑定模型
*** 域名路由
*** URL 生成
** 控制器
*** 控制器定义
*** 控制器初始化
    #+begin_src php
      namespace app\index\controller;
      use think\Controller;
      class Index extends Controller
      {
          public function _initialize()
          {
              echo 'init<br/>';
          }
          public function hello()
          {
              return 'hello';
          }
      }
      public function data()
      {
          return 'data';
      }

    #+end_src
*** 前置操作
*** 跳转和重定向
    #+begin_src php
      $this->success('新增成功', 'User/list');
      $this->error('新增失败');
      $this->redirect('News/category', ['cate_id' => 2]);
      //重定向到指定的 URL 地址 并且使用 302
      $this->redirect('http://thinkphp.cn/blog/2',302);

    #+end_src

*** 空操作
*** 空控制器
*** 多级控制器
*** 分层控制器
*** Rest 控制器
*** 自动定位控制器
*** 资源控制器
** 请求
*** 请求信息
    #+begin_src php
      $request = Request::instance();
      // 或
      $request = request();
    #+end_src

    #+begin_src php
      $request = Request::instance();
      // 获取当前域名
      echo 'domain: ' . $request->domain() . '<br/>';
      // 获取当前入口文件
      echo 'file: ' . $request->baseFile() . '<br/>';
      // 获取当前 URL 地址 不含域名
      echo 'url: ' . $request->url() . '<br/>';
      // 获取包含域名的完整 URL 地址
      echo 'url with domain: ' . $request->url(true) . '<br/>';
      // 获取当前 URL 地址 不含 QUERY_STRING
      echo 'url without query: ' . $request->baseUrl() . '<br/>';
      // 获取 URL 访问的 ROOT 地址
      echo 'root:' . $request->root() . '<br/>';
      // 获取 URL 访问的 ROOT 地址
      echo 'root with domain: ' . $request->root(true) . '<br/>';
      // 获取 URL 地址中的 PATH_INFO 信息
      echo 'pathinfo: ' . $request->pathinfo() . '<br/>';
      // 获取 URL 地址中的 PATH_INFO 信息 不含后缀
      echo 'pathinfo: ' . $request->path() . '<br/>';
      // 获取 URL 地址中的后缀信息
      echo 'ext: ' . $request->ext() . '<br/>';

    #+end_src
    
#+begin_src php
    //设置/获取 模块/控制器/操作名称
    $request = Request::instance();
    echo "当前模块名称是" . $request->module();
    echo "当前控制器名称是" . $request->controller();
    echo "当前操作名称是" . $request->action();

  //获取请求参数
  $request = Request::instance();
  echo '请求方法:' . $request->method() . '<br/>';
  echo '资源类型:' . $request->type() . '<br/>';
  echo '访问地址:' . $request->ip() . '<br/>';
  echo '是否 AJax 请求:' . var_export($request->isAjax(), true) . '<br/>';
  echo '请求参数:';
  dump($request->param());
  echo '请求参数:仅包含 name';
  dump($request->only(['name']));
  echo '请求参数:排除 name';
  dump($request->except(['name']));

#+end_src
*** 输入变量
    #+begin_src php
      // 获取当前请求的 name 变量
      Request::instance()->param('name');
      // 获取当前请求的所有变量(经过过滤)
      Request::instance()->param();
      // 获取当前请求的所有变量(原始数据)
      Request::instance()->param(false);
      // 获取当前请求的所有变量(包含上传文件)
      Request::instance()->param(true);

      //使用助手函数实现:
      input('param.name');
      input('param.');
      //或者
      input('name');
      input('');

    #+end_src
    
#+begin_src php
  //获取 GET 变量
  Request::instance()->get('id'); // 获取某个 get 变量
  Request::instance()->get('name'); // 获取 get 变量
  Request::instance()->get(); // 获取所有的 get 变量(经过过滤的数组)
  Request::instance()->get(false); // 获取所有的 get 变量(原始数组)
  //助手函数
  input('get.id');
  input('get.name');
  input('get.');

#+end_src


#+begin_src php
  //获取 Cookie 变量
  Request::instance()->cookie('user_id'); // 获取某个 cookie 变量
  Request::instance()->cookie(); // 获取全部的 cookie 变量
  //使用助手函数实现:
  input('cookie.user_id');
  input('cookie.');
#+end_src
*** 更改变量
*** 请求类型
    #+begin_src php
// 是否为 GET 请求
if (Request::instance()->isGet()) echo "当前为 GET 请求";
// 是否为 POST 请求
if (Request::instance()->isPost()) echo "当前为 POST 请求";
// 是否为 PUT 请求
if (Request::instance()->isPut()) echo "当前为 PUT 请求";
// 是否为 DELETE 请求
if (Request::instance()->isDelete()) echo "当前为 DELETE 请求";
// 是否为 Ajax 请求
if (Request::instance()->isAjax()) echo "当前为 Ajax 请求";
// 是否为 Pjax 请求
if (Request::instance()->isPjax()) echo "当前为 Pjax 请求";
// 是否为手机访问
if (Request::instance()->isMobile()) echo "当前为手机访问";
// 是否为 HEAD 请求
if (Request::instance()->isHead()) echo "当前为 HEAD 请求";
// 是否为 Patch 请求
if (Request::instance()->isPatch()) echo "当前为 PATCH 请求";
// 是否为 OPTIONS 请求
if (Request::instance()->isOptions()) echo "当前为 OPTIONS 请求";
// 是否为 cli
if (Request::instance()->isCli()) echo "当前为 cli";
// 是否为 cgi
if (Request::instance()->isCgi()) echo "当前为 cgi";
//助手函数
// 是否为 GET 请求
if (request()->isGet()) echo "当前为 GET 请求";

    #+end_src
*** 请求伪装
*** HTTP 头信息
    #+begin_src php
$info = Request::instance()->header();
echo $info['accept'];
echo $info['accept-encoding'];
echo $info['user-agent'];

    #+end_src
*** 伪静态
*** 方法注入
*** 属性注入
*** 参数绑定
*** 依赖注入
*** 请求缓存
** 数据库
*** 连接数据库
*** 基本使用
*** 查询构造器
*** 查询数据
*** 添加数据
*** 更新数据
*** 删除数据
*** 查询方法
*** 查询语法
*** 链式操作
*** where
*** table
*** alias
*** field
*** order
*** limit
*** page
*** group
*** having
*** join
*** union
*** distinct
*** lock
*** cache
*** comment
*** fetchSql
*** force
*** bind
*** partition
*** strict
*** failException
*** sequence
*** 聚合查询
*** 时间查询
*** 高级查询
*** 视图查询
*** 子查询
*** 原生查询
*** 查询事件
*** 事务操作
*** 监听 SQL
*** 存储过程
*** 数据集
*** 分布式数据库
*** 模型
*** 定义
*** 模型初始化
*** 新增
*** 更新
*** 删除
*** 查询
*** 聚合
*** 获取器
*** 修改器
*** 时间戳
*** 只读字段
*** 软删除
*** 类型转换
*** 数据完成
*** 查询范围
*** 模型分层
*** 数组访问和转换
*** JSON 序列化
*** 事件
*** 关联
*** 一对一关联
*** 一对多关联
*** 远程一对多
*** 多对多关联
*** 多态关联
*** 动态属性
*** 关联预载入
*** 关联统计
*** 聚合模型
** 数据库操作    
*** 原生操作
    #+BEGIN_SRC php
                  Db::query('select*fromthink_userwhereid=?', [8]);
                  Db::execute('insertintothink_user(id, name)values(?, ?)', [8, 'thinkphp']);
      也支持命名占位符绑定, 例如:
          Db::query('select*fromthink_userwhereid=:id', ['id'=>8]);
            Db::execute('insertintothink_user(id, name)values(:id, :name)', ['id'=>8, 'name'=>'t
      hinkphp']);

    #+END_SRC

*** 查询　find /select/ 查值　value('字段名') 列　column('name', 'id')   
    #+BEGIN_SRC php
      Db::table('think_user')->chunk(100, function($users){
          foreach($usersas$user){
              //
          }
      });
      //或者交给回调方法 myUserIterator 处理
      Db::table('think_user')->chunk(100, 'myUserIterator');

      JSON 类型数据查询(mysql V5.0.1 )
          //查询 JSON 类型字段(info 字段为 json 类型)
          Db::table('think_user')->where('info$.email', 'thinkphp@qq.com')->find();

      $map['id']		=	['>',1];
      $map['mail']		=	['like','%thinkphp@qq.com%'];

      Db::table('think_user')->alias('a')->join('__DEPT__	b	','b.user_id=	a.id')->select();
      字段中使用函数 Db::table('think_user')->field('id'=>'ID',SUM(score)')->select();
        字段排除　 Db::table('think_user')->field('id', true)->select(); 排除 id
              Db::table('think_article')->limit('10,25')->select();

              page 方法还可以和 limit 方法配合使用,例如:
                  Db::table('think_article')->limit(25)->page(3)->select();
              它会自己计算

                  返回单条不重复的 distinct(true)
                  这里可以用本地缓存方法 Db::table('think_user')->where('id=5')->cache(true)->find();
              $result	=	Db::table('think_user')->cache('key',60)->find();
              外部可以获取了
                  $data	=	\think\Cache::get('key');

              count 统计数量,参数是要统计的字段名(可选)
                  max 获取最大值,参数是要统计的字段名(必须)
                  min 获取最小值,参数是要统计的字段名(必须)
                  avg 获取平均值,参数是要统计的字段名(必须)
                  sum 获取总分,参数是要统计的字段名(必须)
                  对时间的比较     
                  whereTime('birthday',	'>=',	'1970-10-1')
                  关键字 today,yesterday,week,last week, month,last month,year,last year
                  2 hours,
                  区间查询

                  构建子查询,就是返回 sql 语句而不执行
                  1.select(false)
                  2.fetchSql(true)
                  3.buildSql();

      #+END_SRC
*** 添加　insert/getLastInsID()/insertGetId($data)/insertAll
*** 更新　update /setField('name', 'val')更新字段/setInc/setDec('字段’)或 setDec('字段', 5) 减 5
*** 删除　delete
*** 获取表信息
#+BEGIN_SRC php
//	获取`think_user`表所有信息
Db::getTableInfo('think_user');
//	获取`think_user`表所有字段
Db::getTableInfo('think_user',	'fields');
//	获取`think_user`表所有字段的类型
Db::getTableInfo('think_user',	'type');
//	获取`think_user`表的主键
Db::getTableInfo('think_user',	'pk');
#+END_SRC
*** cache ->cache(true, 60)
    可以指定缓存标志 cache('key', 60)
获取 \think\Cache::get('key')
*** fetchSql 返回 SQL
$result = Db::table('t')->fetchSql(true)->find(1);
*** partition 水平分表
*** 聚合统计
count() 数量 max(arg)字段最大值 min(arg) avg(arg)字段平均 sum(arg) 求和
*** 时间比较
    where('createTime', '> time', '2017-1-1');
    where('createTime', 'between time', ['2017-1-1', '2018-1-1']);
    或 whereTime
    'month'
** 视图
*** 视图实例化
*** 模板引擎
*** 模板赋值
*** 模板渲染
*** 输出替换
** 模型
*** 初始化 
    #+begin_src php
      namespace app\index\model;
      use think\Model;
      class Index extends Model
      {
      }
      //自定义初始化
      protected function initialize()
      {
          //需要调用`Model`的`initialize`方法
          parent::initialize();
          //TODO:自定义的初始化
      }
    #+end_src
*** 新增数据
    #+begin_src php
      //第一种是实例化模型对象后赋值并保存:
      $user = new User;
      $user->name = 'thinkphp';
      $user->email = 'thinkphp@qq.com';
      $user->save();
      //也可以使用 data 方法批量赋值:
      $user = new User;
      $user->data([
          'name' => 'thinkphp',
          'email' => 'thinkphp@qq.com'
      ]);
      $user->save();
      //或者直接在实例化的时候传入数据
      $user = new User([
          'name' => 'thinkphp',
          'email' => 'thinkphp@qq.com'
      ]);
      $user->save();

    #+end_src

** 模板
*** 模板定位
*** 模板标签
*** 变量输出
*** 系统变量
*** 请求参数
*** 使用函数
*** 使用默认值
*** 使用运算符
*** 三元运算
*** 原样输出
*** 模板注释
*** 模板布局
*** 模板继承
*** 包含文件
*** 标签库
*** 内置标签
*** 循环输出标签
*** 比较标签
*** 条件判断
*** 资源文件加载
*** 标签嵌套
*** 原生 PHP
*** 定义标签
** 日志
*** 介绍
*** 日志 \think\Log 
*** 初始化
    #+BEGIN_SRC php
      Log::init([
          'type'		=>		'File',
          'path'		=>		APP_PATH.'logs/'
      ]);
    #+END_SRC
*** 手动记录
    Log::record('测试日志信息,这是警告级别','notice');
    #+BEGIN_SRC ini 
log	常规日志,用于记录日志
error	错误,一般会导致程序的终止
notice	警告,程序可以运行但是还不够完美的错误
    #+END_SRC
*** 清空
    Log::clear();
*** 日志驱动
*** 日志写入
*** 独立日志
*** 日志清空
*** 写入授权
** 错误和调试
*** 调试模式
    APP_DEBUG = true
*** 异常处理
*** 抛出异常
*** Trace 调试
*** 变量调试
*** 性能调试
*** SQL 调试
*** 远程调试
*** 404 页面
** 验证
*** 验证器
*** 验证规则
*** 错误信息
*** 验证场景
*** 控制器验证
*** 模型验证
*** 内置规则
*** 静态调用
*** 表单令牌
** 安全
*** 输入安全
*** 数据库安全
*** 上传安全
*** 其它安全建议
** 杂项
*** 缓存
*** Session(临时会话）
    {$Think.session.user_id}	//	输出$_SESSION['user_id']变量
    Session::set('name','thinkphp');
    Session::get('name');
    //	判断(当前作用域)是否赋值
    Session::has('name');
    //	判断 think 作用域下面是否赋值
    Session::has('name','think');
    清空
    //	清除 session(当前作用域)
    Session::clear();
    //	清除 think 作用域
    Session::clear('think');

    {if	condition="($name	==	1)	OR	($name	>	100)	"}	value1
    {elseif	condition="$name	eq	2"/}value2
    {else	/}	value3
    {/if}

    获取请求信息 $request = Request::instance();
    $request->domain() 获取当前域名
    $request->baseFile() 当前 URL 地址
    url(),baseUrl(),root,pathinfo(),path(),ext()
    module(),controller(),action() 获取模块/控制器/操作
    isAjax(),param() only(['name'])仅包含 name except(['name']排除 name
    检测变量 has('id','get') has('id','post')  
    或具体的 get() / post()
    server()/session()/cookie()/head()
    还可以对 input 进行过滤 filter('filter_method') 这是全局的
    单独的 Request::instance()->param('username','','method1,method2')
    变量修饰 input('get.id/d')
    |s|强制转换为字符串|
    |d|整型|
    |b|布尔|
    |a|数组|
    |f|浮点|
    参数绑定方式:1.按参数名 2. 按参数顺序
    定义缓存 Route::get('new/:id','News/read',['cache'=>3600]); //设置 3600 秒的缓存
*** Cookie
*** 多语言
*** 分页
*** 上传
*** 验证码
*** 图像处理
*** 文件处理
*** 单元测试
*** 扩展
*** 函数
*** 类库
*** 行为
*** 驱动
*** Composer 包
*** Time
*** 数据库迁移工具
*** Workerman
*** MongoDb
*** SAE
*** 标签扩展
