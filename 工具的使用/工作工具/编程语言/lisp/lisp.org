* lisp
** Emacs Lisp Basics
*** Printing
 #+BEGIN_SRC emacs-lisp
     ; printing
     (message "hi")

     ; printing variable values
     (message "Her age is: %d" 16)        ; %d is for number
     (message "Her name is: %s" "Vicky")  ; %s is for string
     (message "My list is: %S" (list 8 2 3))  ; %S is for any lisp expression
 #+END_SRC
*** Arithmetic
 #+BEGIN_SRC emacs-lisp
     (+ 4 5 1)  ; 10
     (- 9 2)    ; 7
     (- 9 2 3)  ; 4
     (* 2 3)    ; 6
     (* 2 3 2)  ; 12

     ;; integer part of quotient
     (/ 7 2)    ; 3

     ;; division
     (/ 7 2.0)  ; 3.5

     ;; mod, remainder
     (% 7 4)    ; 3

     ;; power; exponential
     (expt 2 3) ; 8
 #+END_SRC

 WARNING: single digit decimal number such as =2.= needs a zero after the
 dot, like this: =2.0=. For example, =(/ 7 2.)= returns 3, not 3.5.

 #+BEGIN_SRC emacs-lisp
     ;; 3. is a integer, 3.0 is a float
     (integerp 3.) ;  t
     (floatp 3.) ;  nil
     (floatp 3.0) ;  t
 #+END_SRC

 Function names that end with a “p” often means it return either true or
 false. (The “p” stands for “predicate”) =t= means true; =nil= means
 false.

*** Convert Float/Integer
 #+BEGIN_SRC emacs-lisp
     ;; int to float
     (float 3) ; 3.0

     (truncate 3.3) ; 3

     (floor 3.3) ; 3

     (ceiling 3.3) ; 4

     (round 3.4) ; 3
 #+END_SRC

**** Convert String and Number
 #+BEGIN_SRC emacs-lisp
     (string-to-number "3")
     (number-to-string 3)
 #+END_SRC

*** True, False
 In elisp, the symbol =nil= is false, anything else is true. Also, =nil=
 is equivalent to the empty list =()=, so =()= is also false.

 #+BEGIN_SRC emacs-lisp
     ;; all the following are false. They all evaluate to nil
     (if nil "yes" "no") ;  "no"
     (if () "yes" "no") ;  "no"
     (if '() "yes" "no") ;  "no"
     (if (list) "yes" "no") ;  "no", because (list) eval to a empty list, same as ()
 #+END_SRC

 By convention, the symbol =t= is used for true.

 #+BEGIN_SRC emacs-lisp
     (if t "yes" "no") ;  "yes"
     (if 0 "yes" "no") ;  "yes"
     (if "" "yes" "no") ;  "yes"
     (if [] "yes" "no") ;  "yes". The [] is vector of 0 elements
 #+END_SRC

 There is no “boolean datatype” in elisp. Just remember that =nil= and
 empty list =()= are false, anything else is true.

**** Boolean Functions
 Here's =and= and =or=.

 #+BEGIN_SRC emacs-lisp
     (and t nil) ;  nil
     (or t nil) ;  t

     ;; can take multiple args
     (and t nil t t t t) ;  nil
 #+END_SRC

 Comparing numbers:

 #+BEGIN_SRC emacs-lisp
     (< 3 4) ; less than
     (> 3 4) ; greater than

     (<= 3 4) ; less or equal to
     (>= 3 4) ; greater or equal to

     (= 3 3)   ;  t
     (= 3 3.00000000000000001) ;  t

     (/= 3 4) ; not equal. ⇒ t
 #+END_SRC

 Comparing strings:

 #+BEGIN_SRC emacs-lisp
     ;; compare string
     (equal "abc" "abc") ;  t

     ;; dedicated function for comparing string
     (string-equal "abc" "abc") ;  t

     (string-equal "abc" "Abc") ;  nil. Case matters

     ;; can be used to compare string and symbol
     (string-equal "abc" 'abc) ;  t
 #+END_SRC

 For generic equality test, use =equal=. It tests if two values have the
 same datatype and value.

 #+BEGIN_SRC emacs-lisp
     ;; test if two values have the same datatype and value.

     (equal 3 3) ;  t
     (equal 3.0 3.0) ;  t

     (equal 3 3.0) ;  nil. Because datatype doesn't match.

     ;; test equality of lists
     (equal '(3 4 5) '(3 4 5))  ;  t
     (equal '(3 4 5) '(3 4 "5")) ;  nil

     ;; test equality of strings
     (equal "e" "e") ;  t

     ;; test equality of symbols
     (equal 'abc 'abc) ;  t
 #+END_SRC

 There's also the function =eq=, it returns =t= if the two args are the
 same Lisp object. This is usually not what you want. =(eq "e" "e")=
 returns =nil=.

 To test for inequality, the =/== is for numbers only, and doesn't work
 for strings and other lisp data. Use =not= to negate your equality test,
 like this:

 #+BEGIN_SRC emacs-lisp
     (not (= 3 4)) ;  t
     (/= 3 4) ;  t. “/=” is for comparing numbers only

     (not (equal 3 4)) ;  t. General way to test inequality.
 #+END_SRC

**** even, odd
 #+BEGIN_SRC emacs-lisp
     (= (% n 2) 0) ; test even

     (= (% n 2) 1) ; test odd
 #+END_SRC

*** Variables
**** Global Variables
 =setq= is used to set variables. Variables need not be declared, and is
 global.

 #+BEGIN_SRC emacs-lisp
     (setq x 1) ; assign 1 to x
     (setq a 3 b 2 c 7) ; multiple assignment
 #+END_SRC

**** Local Variables
 To define local variables, use =let=. The form is:

 =(let (var1 var2 …) body)=

 where body is (one or more) lisp expressions. The body's last
 expression's value is returned.

 #+BEGIN_SRC emacs-lisp
     (let (a b)
      (setq a 3)
      (setq b 4)
      (+ a b)
     ) ;  7
 #+END_SRC

 Another form of =let= is this:

 =(let ((var1 val1) (var2 val2) …) body)=

 #+BEGIN_SRC emacs-lisp
     (let ((a 3) (b 4))
      (+ a b)
     ) ;  7
 #+END_SRC

 This form lets you set values to variable without using many =setq= in
 the body. This form is convenient if you just have a few simple local
 vars with known values.
*** If Then Else
 The form for “if” expression is:

 =(if test body)=

 or

 =(if test true_body false_body)=

 #+BEGIN_SRC emacs-lisp
     (if (< 3 2) 7 8 ) ; 8

     ;; no false expression, return nil
     (if (< 3 2) (message "yes") ) ; nil
 #+END_SRC

 If you do not need a “else” part, you should use the function =when=
 instead, because it is more clear. The form is:

 =(when test expr1 expr2 …)=

 Its meaning is the same as

 =(if test (progn expr1 expr2 …))=

*** Block of Expressions
 Sometimes you need to group several expressions together as one single
 expression. This can be done with =progn=.

 #+BEGIN_SRC emacs-lisp
     (progn (message "a") (message "b"))
     ;; is equivalent to
     (message "a") (message "b")
 #+END_SRC

 The purpose of =(progn …)= is similar to a block of code ={…}= in C-like
 languages. It is used to group together a bunch of expressions into one
 single parenthesized expression. Most of the time it's used inside “if”.

 #+BEGIN_SRC emacs-lisp
     (if something
         (progn ; true
         …
         )
         (progn ; else
         …
         )
     )
 #+END_SRC

 =progn= returns the last expression in its body.

 #+BEGIN_SRC emacs-lisp
     (progn 3 4 ) ; 4
 #+END_SRC

*** Loop
 Most basic loop in elisp is with =while=.

 =(while test body)=

 , where body is one or more lisp expressions.

 #+BEGIN_SRC emacs-lisp
     (setq x 0)

     (while (< x 4)
       (print (format "number is %d" x))
       (setq x (1+ x)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; inserts Unicode chars 32 to 126
     (let ((x 32))
       (while (< x 127)
         (insert-char x)
         (setq x (+ x 1))))
 #+END_SRC

 Usually it's better to use =dolist= or =dotimes=.
*** Define a Function
 Basic function definition is of the form:

 =(defun function_name (param1 param2 …) "doc_string" body)=

 #+BEGIN_SRC emacs-lisp
     (defun myFunction ()
       "testing"
       (message "Yay!"))
 #+END_SRC

 When a function is called, the last expression in the function's
 definition body is returned. (there's no “return statement”.)
**** Define a Command
 A command is a function that emacs user can call by
 =execute-extended-command= 【Alt+x】.

 When a function is also a command, we say that the function is available
 for interactive use.

 To make a function available for interactive use, add =(interactive)=
 right after the doc string.

 Evaluate the following code. Then, you can call it by
 =execute-extended-command= 【Alt+x】

 #+BEGIN_SRC emacs-lisp
     (defun yay ()
       "Insert “Yay!” at cursor position."
       (interactive)
       (insert "Yay!"))
 #+END_SRC

 Here is a function definition template that majority of elisp commands
 follow:

 #+BEGIN_SRC emacs-lisp
     (defun myCommand ()
       "One sentence summary of what this command do.

     More detailed documentation here."
       (interactive)
       (let (localVar1 localVar2 …)
         ; do something here …
         ; …
         ; last expression is returned
       )
     )
 #+END_SRC

** Overview of Text-Processing in Emacs Lisp
 In emacs, a user can program it using the embedded language (called
 Emacs Lisp, or elisp) so that he can have custom functions to insert
 texts, templates, process files, and many other features of emacs.

 Emacs provides functions for text manipulation.

 For example, there is a lisp function that returns the cursor position
 in a buffer. A function that returns the beginning/ending position of
 the text selection. Functions that move the cursor to a given position,
 or delete a region of text of given positions. Functions that insert a
 string at a given position. Functions that open or save files. Functions
 that list opened files. Functions that list buffer names. Functions that
 colors text , ... and much more.

*** Example of Simple Elisp Functions
**** Cursor Position
 #+BEGIN_SRC emacs-lisp
     ;; current cursor position is called “point”.
     ;; Left of first char in buffer is 1
     ;; This returns the current cursor position
     (point)

     ;; returns the position of the beginning/end of region (selection)
     (region-beginning)
     (region-end)

     ;; position for beginning/ending of current line
     (line-beginning-position)
     (line-end-position)

     ;; returns the position for the beginning/end of buffer, taking account of narrow-to-region
     (point-min)
     (point-max)
 #+END_SRC

 Note: position is considered between characters. The left of the first
 character in buffer has position 1.

 By default, cursor is shown as black square ▮ over a character, the
 position is to the left of the black square.

 Try this. Type

 =(point)=

 in a buffer. Then, place cursor after the right parenthesis, then Alt+x
 =eval-last-sexp= 【Ctrl+x Ctrl+e】

 The result is current cursor position.

**** Move Cursor, Search Text
 #+BEGIN_SRC emacs-lisp
     ;; move cursor to position 39
     (goto-char 39)

     ;; move cursor by 4 chars
     (forward-char 4)
     (backward-char 4)

     ;; move cursor to the location of a string
     ;; returns the new position
     (search-forward "some") ; to end of “some”
     (search-backward "some") ; to beginning of “some”

     ;; move cursor to the location matched by a regex
     ;; returns the new position
     (re-search-forward "[0-9]") ; digit
     (re-search-backward "[0-9]")

     ;; move cursor to the first char that's not “a to z”
     ;; Returns the distance traveled.
     (skip-chars-forward "a-z")
     (skip-chars-backward "a-z")
 #+END_SRC

**** Delete, Insert, Change, Text
 #+BEGIN_SRC emacs-lisp
     ;; delete 9 chars starting at current cursor pos
     (delete-char 9)

     ;; deleting text from pos 3 to 10
     (delete-region 3 10)

     ;; insert string at current cursor position
     (insert "i ♥ cats")

     ;; get the string from pos 71 to 300
     (setq x (buffer-substring 71 300))

     ;; capitalize letters in a region
     (capitalize-region 71 300)
 #+END_SRC

**** String
 #+BEGIN_SRC emacs-lisp
     ;; length
     (length "abc")
     ; returns 3

     ;; substring
     (substring "abcdefg" 3 4)
     ; returns "d"

     ;; change a given string using regex
     (replace-regexp-in-string "[0-9]" "X" "abc123")
     ;; returns "abcXXX"
 #+END_SRC

**** Buffer
 #+BEGIN_SRC emacs-lisp
     ;; return the name of current buffer
     (buffer-name)

     ;; return the full path of current file
     (buffer-file-name)

     ;; switch to the buffer named xyz
     (set-buffer "xyz")

     ;; save current buffer
     (save-buffer)

     ;; close a buffer named xyz
     (kill-buffer "xyz")

     ;; temporarily sets a buffer as current to work with
     (with-current-buffer "xyz"
       ;; do something here. delete/insert text, etc.
     )
 #+END_SRC

**** File
 #+BEGIN_SRC emacs-lisp
     ;; open a file (in a buffer)
     (find-file "~/")

     ;; same as “Save As”.
     (write-file path)

     ;; insert file into current position
     (insert-file-contents path)

     ;; append a text block to file
     (append-to-file start-pos end-pos path)

     ;; renaming file
     (rename-file file-name new-name)

     ;; copying file
     (copy-file old-name new-name)

     ;; deleting file
     (delete-file file-name)

     ;; get dir path
     (file-name-directory full-path)

     ;; get filename part
     (file-name-nondirectory full-path)

     ;; get filename's suffix
     (file-name-extension file-name)

     ;; get filename sans suffix
     (file-name-sans-extension file-name)
 #+END_SRC

*** A Simple Example
 This code shows how to insert a string, then position cursor somewhere
 inside.

 #+BEGIN_SRC emacs-lisp
     (defun insert-p-tag ()
       "Insert <p></p> at cursor point."
       (interactive)
       (insert "<p></p>")
       (backward-char 4))
 #+END_SRC

 Copy and paste the above into any buffer, then select the whole code,
 Alt+x =eval-region=.

 To call the command, Alt+x insert-p-tag.

*** Programing a Major/Minor Mode
 Programing emacs is more than text processing. For example, all of the
 following major modes are written in elisp:

 - =org-mode= [see [[file:emacs_org_markup.html][Emacs: Org Mode Markup
   Cheatsheet]]]
 - • =python-mode= • =js-mode= • =ruby-mode=
 - Alt+x =tetris=
 - [[file:file_management.html][Emacs: File Manager, dired]]
 - [[file:eshell.html][Emacs: eshell]]
 - [[file:emacs_eww_web_browser.html][Emacs: Eww Web Browser]]

 Tasks of writing a mode is more complex, because it involves
 understanding many of emacs's systems: keyboard input event, display
 (windows and fonts), user interface (menu, windows, scroll bar, tool
 bar), major/minor mode's structure, coloring text, package structure,
 etc.

 You should have some experience doing text processing in elisp before
 writing a major mode.

** Elisp: Simple Emacs Lisp Examples

 This page shows very simple and useful emacs lisp commands that are
 shorter than 10 lines. They show you the basic programing in elisp.

*** Insert Text
 This code shows how to insert a string, and also position cursor after
 the insertion.

 #+BEGIN_SRC emacs-lisp
     (defun insert-p-tag ()
       "Insert <p></p> at cursor point."
       (interactive)
       (insert "<p></p>")
       (backward-char 4))
 #+END_SRC

 You can use this code to insert your {signature, template, headers,
 footers, ...}.

 Put cursor after the last parenthesis, then Alt+x =eval-last-sexp=
 【Ctrl+x Ctrl+e】.

 Then, you can call the command you just defined by name. For example,
 Alt+x insert-p-tag.

 [see [[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

 To see a function's documentation, Alt+x =describe-function= 【Ctrl+h
 f】.

 [see [[file:elisp_doc_lookup.html][Elisp: Documentation Lookup]]]

*** Insert Around Region
 This code shows how to place a string at the beginning and end of a
 region.

 #+BEGIN_SRC emacs-lisp
     (defun wrap-markup-region ()
       "Insert a markup <b></b> around a region."
       (interactive)
       (save-excursion
         (goto-char (region-end))
         (insert "</b>")
         (goto-char (region-beginning))
         (insert "<b>")))
 #+END_SRC

 You can use this code to add HTML begin/end tag on a selected text, or
 add brackets around a selection.

 Exercise: modify this do ask user what html tag use.

*** Select Current Word
 This code shows you how to set a mark (select text) programmatically.

 #+BEGIN_SRC emacs-lisp
     ;; turn on highlight selection
     (transient-mark-mode 1)

     (defun select-current-word ()
       "Select the word under cursor.
     “word” here is considered any alphanumeric sequence with “_” or “-”."
       (interactive)
       (let (pt)
         (skip-chars-backward "-_A-Za-z0-9")
         (setq pt (point))
         (skip-chars-forward "-_A-Za-z0-9")
         (set-mark pt)))
 #+END_SRC

*** Select Current Line
 #+BEGIN_SRC emacs-lisp
     ;; turn on highlight selection
     (transient-mark-mode 1)

     (defun select-current-line ()
       "Select the current line"
       (interactive)
       (let ((pos (line-beginning-position)))
         (end-of-line)
         (set-mark pos)))
 #+END_SRC

 See also: [[file:emacs_region.html][Elisp: Region, Active Region]].

 Exercise: write a command to select current text block. (text block are
 separated by empty lines.)

*** Find Replace String in Region
 Here's how to do text replacements on a region.

 #+BEGIN_SRC emacs-lisp
     (defun replace-greek-region ()
       "Replace “alpha” to “α” and other greek letters in current region."
       (interactive)
       (let (
             (p1 (region-beginning))
             (p2 (region-end)))
         (save-restriction
           (narrow-to-region p1 p2)
           (goto-char (point-min))
           (while (search-forward " alpha" nil t)
             (replace-match " α" nil t))
           (goto-char (point-min))
           (while (search-forward " beta" nil t)
             (replace-match " β" nil t))
           (goto-char (point-min))
           (while (search-forward " gamma" nil t)
             (replace-match " γ" nil t)))))
 #+END_SRC

 You can modify the code to do other replacements. For example, HTML XML
 Entities. [see [[http://xahlee.info/js/html_xml_entities.html][HTML/XML
 Entity List]]]

 Exercise: make this do current buffer, or current line.

*** Delete Enclosed Text

 This code shows how to delete text enclosed by any pairs of delimiters.

 For example, if you are editing HTML code, suppose you have text

 =<p>something something long …</p>=

 and your cursor is somewhere in between the tags. You want to quickly
 delete all texts inside the p tags. The following function will do. It
 will also, delete any text between quotes or parenthesis.

 #+BEGIN_SRC emacs-lisp
     (defun delete-enclosed-text ()
       "Delete texts between any pair of delimiters."
       (interactive)
       (save-excursion
         (let (p1 p2)
           (skip-chars-backward "^([<>“")
           (setq p1 (point))
           (skip-chars-forward "^)]<>”")
           (setq p2 (point))
           (delete-region p1 p2))))
 #+END_SRC

*** Delete Linebreaks

 This example shows how to temporarily change a predefined variable's
 value, then call a function whose behavior depends on the var.

 #+BEGIN_SRC emacs-lisp
     (defun remove-line-breaks ()
       "Remove line endings in current paragraph."
       (interactive)
       (let ((fill-column (point-max)))
         (fill-paragraph nil)))
 #+END_SRC

 For detail, see: [[file:emacs_unfill-paragraph.html][Emacs: Hard Wrap
 Lines]].

*** Inserting a Random Number

 #+BEGIN_SRC emacs-lisp
     (random t) ; seed it randomly

     (defun insert-random-number ()
       "Insert a random number between 0 to 999999."
       (interactive)
       (insert (number-to-string (random 999999))) )
 #+END_SRC

 For more, see: [[file:elisp_insert_random_number_string.html][Emacs:
 Insert Random Number/Hex/String]]

*** Reference Lookup

 This example shows the use of =thing-at-point= and =browse-url=.

 It will look up the word under the cursor in a online dictionary.

 #+BEGIN_SRC emacs-lisp
     (defun word-definition-lookup ()
     "Look up the word under cursor in a browser."
      (interactive)
      (browse-url
        (concat "http://www.answers.com/main/ntquery?s=" (thing-at-point 'symbol))))
 #+END_SRC

 For detail, see: [[file:emacs_lookup_ref.html][Emacs: Lookup Google,
 Dictionary, Documentation]].

*** Change Newline Character

 This example shows how to define a function that takes a file path and
 process the file.

 #+BEGIN_SRC emacs-lisp
     (defun to-unix-eol (fPath)
       "Change file's line ending to unix convention."
       (let ((myBuffer (find-file fPath)))
         (set-buffer-file-coding-system 'unix) ; or 'mac or 'dos
         (save-buffer)
         (kill-buffer myBuffer)))
 #+END_SRC

 For example, if the file =~/readme.txt= is a Windows file, you can
 change its line ending by evaluating the following:

 #+BEGIN_SRC emacs-lisp
     (to-unix-eol "~/readme.txt")
 #+END_SRC

 The following example shows how to apply a file processing function to a
 list of files.

 #+BEGIN_SRC emacs-lisp
     (mapc 'to-unix-eol
      (list
     "~/myfile1"
     "~/myfile2"
     "~/myfile3"
     ; …
       )
     )
 #+END_SRC

 The following wraps it as a command, so can be called in dired. It acts
 on all marked files.

 #+BEGIN_SRC emacs-lisp
     (defun dired-2unix-marked-files ()
       "Change to unix line ending for marked (or next arg) files."
       (interactive)
       (mapc 'to-unix-eol (dired-get-marked-files))
     )
 #+END_SRC

*** Delete Current File

 This example shows command that lets you delete the current file. Note
 here that elisp is used to: {manipulate buffer, manipulate file, prompt
 user}.

 #+BEGIN_SRC emacs-lisp
     (defun delete-current-file ()
       "Delete the file associated with the current buffer.
     Delete the current buffer too.
     If no file is associated, just close buffer without prompt for save."
       (interactive)
       (let ((currentFile (buffer-file-name)))
         (when (yes-or-no-p (concat "Delete file?: " currentFile))
           (kill-buffer (current-buffer))
           (when currentFile
             (delete-file currentFile)))))
 #+END_SRC

 Detail at [[file:elisp_delete-current-file.html][Emacs: Delete Current
 File]].

*** Highlighting Lines

 This example shows you how to make lines containing the words “ERROR:”
 or “NOTE:” highlighted, whenever a file ending in “log” is opened.

 #+BEGIN_SRC emacs-lisp
     (defun highlite-it ()
       "Highlight certain lines…"
       (interactive)
       (if (equal "log" (file-name-extension (buffer-file-name)))
           (progn
             (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
             (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b))))

     (add-hook 'find-file-hook 'highlite-it)
 #+END_SRC

 The =add-hook= line will make emacs call “highlite-it” whenever a file
 is opened. It works by adding the function “highlite-it” to the list in
 the variable find-file-hook.

 =find-file= is the function that open files. find-file-hook is a
 variable containing list of functions that will run when find-file is
 run.

*** Insert Vertical Column of Numbers

 This commands insert a vertical column of numbers into a block of text,
 like this:

 #+BEGIN_SRC emacs-lisp
     1. x
     2. x
     3. x
     4. x
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun insert-column-counter (n)
       "Insert a sequence of numbers vertically.
     For example:

     a▮b
     c d
     e f

     becomes:

     a1 b
     c2 d
     e3 f

     If there are not enough existing lines after the cursor
     when this function is called, it aborts at the last line.

     This command is conveniently used together with `kill-rectangle' and `string-rectangle'.
     Version 2019-01-27"
       (interactive "nEnter the max integer: ")
       (let ((i 1) colpos )
         (setq colpos (- (point) (line-beginning-position)))
         (while (<= i n)
           (insert (number-to-string i))
           (forward-line)
           (beginning-of-line)
           (forward-char colpos)
           (setq i (1+ i)))))
 #+END_SRC

 Note: Emacs 24 [see [[file:emacs24_features.html][Emacs 24.1 Features
 (released 2012-06)]]] has a new command =rectangle-number-lines=.

 Thanks to Marcin Milewski for correction on “wrap-markup-region”.

** Emacs: Evaluate Elisp Code
 To evaluate a single lisp expression, move your cursor to the right of
 the last closing parenthesis, and Alt+x =eval-last-sexp= 【Ctrl+x
 Ctrl+e】.

 To evaluate all elisp code in a text selection, Alt+x =eval-region=.

 eval emacs lisp code basics.

 Here's ways to eval elisp code, roughly in order of usefulness:

 1. =eval-last-sexp= → eval lisp expression to the left of cursor.
 2. =eval-region= → eval text selection.
 3. =eval-buffer= → eval whole buffer.
 4. =load-file= → eval a file. It prompts.
 5. =eval-defun= → eval function definition block the cursor is in. (the
    elisp code must be well-indended, otherwise emacs may have problem
    finding function.) [see
    [[file:emacs_narrow-to-defun_eval-defun_bug.html][Emacs:
    narrow-to-defun, eval-defun, bug]]]
 6. =eval-expression= → prompts you to type code.

*** Emacs Lisp Command Line Interface (REPL)

 Alt+x =ielm= to start emacs interactive emacs lisp shell.

 [[file:feed_0/article_9/images/img2.png]]

 emacs lisp interactive command line interface (REPL) =ielm=

 I recommend working in a buffer instead of REPL.

 Working in a buffer (sometimes called notebook inteface) allows you to
 use full editing power, and eval any expression, in any order, anytime,
 anywhere.




** Elisp: Documentation Lookup


*** Look Up Function Doc String

 The following function you will use often when you code elisp.

 Alt+x =describe-function= 【Ctrl+h f】, then type the function name.

 (if the function name is under cursor, you don't need to type the name,
 just hit Enter.)

 [[file:feed_0/article_10/images/img1_u1.png]]

 emacs =describe-function= output

 You can use the asterisk * as a wildcard when looking up function doc.
 For example, type Ctrl+h f *file Tab and emacs will list all functions
 whose name ends in “file”.

 Once the function's doc string page comes up, you can jump to the
 function's location in source code by clicking on underlined file name
 (or press Tab to move your cursor to the link then press Enter).

*** Look Up Variable Doc String

 Alt+x =describe-variable= 【Ctrl+h v】 for doc string of variables.

 Some words (symbols) in elisp source code are variables, not function.

 For example, sentence-end-double-space is a variable.





** Elisp: Search Documentation


*** Search for Function

 To search command by name, Alt+x =apropos-command= 【Ctrl+h a】.

 To search both function and command names, Alt+x =apropos-command= with
 a empty argument, like this: Ctrl+u Ctrl+h a.

 (In emacs, “commands” are a subset of “functions”. Commands are
 functions that can be called interactively (by typing Alt+x).)

 To search variable names, Alt+x =apropos-variable=.

 To search variable values, Alt+x =apropos-value=.

 To search all symbols space (commands, functions, variables, faces),
 Alt+x =apropos=.

*** Search in Elisp Manual

 Emacs is bundled with emacs lisp manual in “Texinfo” format.

 [see [[file:emacs_view_info_page.html][Emacs: View Info Page]]]

 Alt+x =elisp-index-search= to find a function's documentation in the
 emacs lisp manual.

 [[../emacs_manual/elisp/index.html][(info "(elisp) index")]]

 Alt+x =emacs-index-search= to find a function's documentation in the
 emacs manual.

 [[../emacs_manual/emacs/index.html][(info "(emacs) index")]]






** Emacs: How to Edit Lisp Code


 This page shows you how to edit lisp code with plain emacs efficiently.

*** Highlight Brackets: show-paren-mode

 [[file:emacs_highlight_parenthesis.html][Emacs: Highlight Brackets
 ()[]{}]]

*** Insert Brackets by Pair

 [[file:emacs_insert_brackets_by_pair.html][Emacs: Auto Brackets
 electric-pair-mode]]

 You should ALWAYS insert brackets by pair.

*** Delete Brackets by Pair

 [[file:emacs_delete_backward_char_or_bracket_text.html][Emacs: Delete
 Brackets ()[]{} by Pair]]

 You should ALWAYS delete brackets by pair.

*** Move Cursor to Bracket

 [[file:emacs_navigating_keys_for_brackets.html][Emacs: Move Cursor to
 Bracket/Quote]]

 It's critical to have keys that move cursor to previous opening bracket
 and next closing bracket.

*** Navigate Lisp Code as Tree

 [[file:emacs_navigate_lisp_code.html][Emacs: Navigate Lisp Code as
 Tree]]

 You can move cursor to brackets in such way as navigating a tree.

 This is less useful than the freely moving to any bracket.

*** Select Lisp Expression by Unit

 Alt+x =mark-sexp= 【Ctrl+Alt+Space】 to select a complete parenthesized
 expression. Your cursor must be on the left bracket.

 To select a complete sexp, type Ctrl+Alt+↑ (=backward-up-list=) then
 Ctrl+Alt+Space.

*** Xah Emacs Lisp Mode

 You may try my elisp mode. It provides better syntax coloring, and lots
 abbrev and function parameter templates.

 [[../emacs/xah-elisp-mode.html][Emacs: Xah Emacs Lisp Mode]]






** Elisp: Cursor Position Functions


 Here's the most useful cursor related functions.

*** Get Cursor Position

 =point= → return cursor's current position.

 #+BEGIN_SRC emacs-lisp
     ;; returns cursor's current position
     (point)
     ;; beginning of buffer is 1
 #+END_SRC

 =region-beginning= → return start position of text selection.

 =region-end= → return end position of text selection.

 #+BEGIN_SRC emacs-lisp
     ;; returns the position of the beginning/end of region
     (region-beginning)
     (region-end)
 #+END_SRC

 =point-min= → return the start position of visible buffer. (respect
 =narrow-to-region=)

 =point-max= → return the end position of visible buffer. (respect
 =narrow-to-region=)

 #+BEGIN_SRC emacs-lisp
     ;; return the beginning position of buffer
     (point-min)

     ;; returns the position for the end of buffer, respect narrow-to-region
     (point-max)
 #+END_SRC

*** Move Cursor

 =goto-char= → move cursor to a given position.

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to position 392
     (goto-char 392)
 #+END_SRC

 =forward-char= → move cursor by given number of characters.

 #+BEGIN_SRC emacs-lisp
     ;; move cursor by 9 chars
     (forward-char 9)
     (backward-char 9)
 #+END_SRC

 =beginning-of-line= → move cursor to beginning of physcal line.

 =end-of-line= → move cursor to end of physcal line.

 #+BEGIN_SRC emacs-lisp
     ;; move to beginning/end of line
     (beginning-of-line)
     (end-of-line)
 #+END_SRC

 [see [[file:elisp_all_about_lines.html][Elisp: Functions on Line]]]

*** Search Text and Move Cursor

 =search-forward= →
 =(search-forward STRING &optional BOUND NOERROR COUNT)= move cursor
 forward by searching for given string. Cursor stops at end of matched
 string.

 Also =search-backward=. Cursor stops at beginning of matched string.

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to the location of string "cat"
     ;; returns the new position
     (search-forward "cat")
     (search-backward "cat")
 #+END_SRC

 =re-search-forward= →
 =(re-search-forward REGEXP &optional BOUND NOERROR COUNT)= move cursor
 forward by searching for regex pattern. Cursor stops at end of matched
 pattern.

 Also =re-search-backward=. Cursor stops at beginning of matched string.

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to the location matched by regex
     ;; returns the new position
     (re-search-forward myRegex)
     (re-search-backward myRegex)
 #+END_SRC

 =skip-chars-forward= → =(skip-chars-forward STRING &optional LIM)= move
 cursor forward by skip a given set of characters.

 Also =skip-chars-backward=.

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to the first char that's not a newline or tab
     ;; Returns the distance traveled
     (skip-chars-forward "\n\t")
     (skip-chars-backward "\n\t")
 #+END_SRC

 [[../emacs_manual/elisp/Motion.html][(info "(elisp) Motion")]]

 [see [[file:emacs_regex.html][Emacs: Regex Tutorial]]]

*** Save Cursor Position

 When moving cursor, you often want to preserve user's original cursor
 position, so the cursor won't end up somewhere unexpected when your
 command finished.

 =save-excursion= → =(save-excursion &rest BODY)= run BODY, and restore
 cursor position and buffer to user's original.

 #+BEGIN_SRC emacs-lisp
     ;; preserve {point, mark, current buffer}
     (save-excursion
       ;; lisp code here
     )
 #+END_SRC

 See also: [[file:elisp_narrow_to_region.html][Elisp: Save
 narrow-to-region]]






** Elisp: Text Editing Functions


 Here's the most used functions related to text editing.

*** Insert Text

 #+BEGIN_SRC emacs-lisp
     ;; insert string at current cursor position
     (insert "sun and moon")
 #+END_SRC

 [[../emacs_manual/elisp/Text.html][(info "(elisp) Text")]]

*** Delete Text

 =delete-char= → delete n characters to the right. Argument can be
 negative, to delete to the left.

 #+BEGIN_SRC emacs-lisp
     ;; delete 9 chars starting at cursor pos
     (delete-char 9)
 #+END_SRC

 =delete-region= → delete text btween 2 positions.

 #+BEGIN_SRC emacs-lisp
     ;; deleting text btween positions 59 and 896
     (delete-region 59 896)
 #+END_SRC

 =erase-buffer= → delete all next in buffer, ignores =narrow-to-region=.

 #+BEGIN_SRC emacs-lisp
     (erase-buffer)
 #+END_SRC

 =delete-and-extract-region= → Delete between 2 positions and return the
 deleted text.

 #+BEGIN_SRC emacs-lisp
     (delete-and-extract-region 3 20)
 #+END_SRC






** Elisp: String Functions


 Here are the most basic string functions in elisp.

*** Length

 #+BEGIN_SRC emacs-lisp
     ;; length
     (length "abc") ; returns 3
 #+END_SRC

*** Substring

 #+BEGIN_SRC emacs-lisp
     ;; Extract a substring
     (substring myStr myStartPos myEndPos)
 #+END_SRC

*** Join Strings

 #+BEGIN_SRC emacs-lisp
     ;; join strings
     (concat "some" "thing")
 #+END_SRC

*** Match String by Regex

 #+BEGIN_SRC emacs-lisp
     ;; check if a string matches a pattern
     (string-match myRegex myStr)
 #+END_SRC

 See also:

 - [[file:emacs_regex.html][Emacs: Regex Tutorial]]
 - [[file:elisp_regex.html][Elisp: Regex Tutorial]]

*** Get Captured String from Regex Match

 In emacs, most functions that take a regex argument, after being called,
 will save/modify info in “match data”, such as caputured groups.

 Match data can be accessed by the function =match-data=, and other
 functions.

 The most useful is =match-string=, which returns the captured string.

 #+BEGIN_SRC emacs-lisp
     ;; get captured match
     ;; second argument is optional, but required if the last match is done by “string-match”
     (match-string 1 myStr)
 #+END_SRC

*** Replace in String

 #+BEGIN_SRC emacs-lisp
     ;; change a given string using regex. Returns changed string.
     (replace-regexp-in-string myRegex myReplacement myStr)
 #+END_SRC

*** Split String

 #+BEGIN_SRC emacs-lisp
     ;; split string into parts, returns a list
     (split-string "xy_007_cat" "_")
 #+END_SRC

*** String To/From Number

 #+BEGIN_SRC emacs-lisp
     (string-to-number "3") ; change datatype
     (number-to-string 3) ; convert to string
     (format "%d" 3) ; similar to number-to-string but with fine control
 #+END_SRC

*** Buffer Text to String

 [[../emacs/elisp_buffer_string.html][Elisp: Get Buffer String]]

*** String to Buffer

 Emacs has only a few functions that takes a string as argument. Any
 non-trivial string processing is done with a buffer.

 If you got a big string already somehow, you can put into a buffer by
 using =with-temp-buffer=, then insert your string, process it, then use
 =buffer-string= to get the whole buffer content.

 #+BEGIN_SRC emacs-lisp
     ;; process string in a temp buffer

     (with-temp-buffer
       (insert bigString)

       (goto-char (point-min))

       ;; code to manipulate string. eg delete char, etc

       ;; return whole buffer string
       (buffer-string))
 #+END_SRC

*** Trim String and Others

 Emacs 24.4 added many string functions. [see
 [[file:emacs24.4_features.html][Emacs 24.4 Features (released
 2014-10)]]]

 These are new string functions:

 - =string-blank-p=
 - =string-empty-p=
 - =string-join=
 - =string-reverse=
 - =string-trim-left=
 - =string-trim-right=
 - =string-trim=
 - =string-remove-prefix=
 - =string-remove-suffix=

 To use them, you need to first =(require 'subr-x)=.

 #+BEGIN_SRC emacs-lisp
     (require 'subr-x)
     (string-trim " abc  ")
 #+END_SRC

 [[../emacs_manual/elisp/Strings-and-Characters.html][(info "(elisp)
 Strings and Characters")]]






** Elisp: Buffer Functions


 Here's the most useful functions for buffer.

 Most buffer functions assume the current buffer if no argument is given.
 Some requires a argument. The argument can usually be a buffer's name,
 or a buffer object.

*** Get Buffer Name

 =buffer-name= → return the name of current buffer.

 #+BEGIN_SRC emacs-lisp
     ;; return the name of current buffer
     (buffer-name)
 #+END_SRC

 =buffer-file-name= → return the full path of the file, or =nil= if not a
 file.

 #+BEGIN_SRC emacs-lisp
     ;; return the full path of the file
     (buffer-file-name)
 #+END_SRC

*** Switch Buffer

 =with-current-buffer= → temporarily make a buffer current.

 Most of the time, you want to use this. Because it takes care of
 switching back to the original buffer when the function is done.

 #+BEGIN_SRC emacs-lisp
     ;; make myBuf current temporarily
     (with-current-buffer myBuf
       ;; code to edit text here
     )
 #+END_SRC

 =set-buffer= → switch to a given buffer. (but does not make the buffer
 visible.)

 #+BEGIN_SRC emacs-lisp
     (save-current-buffer

       ;; switch to myBuf
       (set-buffer myBuf)

       ;; do stuff, such as insert/delete text
       )
 #+END_SRC

 Note, there is also =switch-to-buffer=, but it's not designed to be used
 in lisp code. Use it only if you need the buffer to be visible.

*** Create Buffer

 =with-temp-buffer=

 =(with-temp-buffer &rest BODY)=

 Create a temporary buffer, and evaluate BODY there like =progn=.

 #+BEGIN_SRC emacs-lisp
     ;; use a temp buffer to manipulate string

     (setq myStr "big text")

     (with-temp-buffer
       (insert myStr)

       ;; manipulate the string here

       ;; print whole buffer content
       (message "%s" (buffer-string)))
 #+END_SRC

 Note: most of the time, you should just use =with-temp-buffer= to create
 new buffers. Because that saves you code of creating buffer, switching
 to it, do something, possibly close it, and restore (switch back) to the
 buffer that was current.

 =generate-new-buffer= → create a new buffer, returns it.

 =(generate-new-buffer NAME)=

 Create and return a buffer with a name based on NAME. Buffer name is
 created by calling =generate-new-buffer-name=.

 Typically used like this:

 #+BEGIN_SRC emacs-lisp
     ;; name for new buffer. If start with space, undo is disabled
     (setq newBufName " xyz")

     ;; create a new buffer, save it to a var, so later you can switch to it or kill it
     (setq newBuf (generate-new-buffer newBufName))

     ;; make it current (but does not make it visible), so all insert etc operations works on it.
     (set-buffer newBuf)
 #+END_SRC

 =get-buffer-create=

 =(get-buffer-create BUFFER-OR-NAME)=

 - Returns the buffer, but doesn't make it current. use =set-buffer= to
   make it current.
 - BUFFER-OR-NAME can be a string or buffer.

 If BUFFER-OR-NAME is a buffer datatype and the buffer exists, it's just
 returned. if not exist, new is created. If BUFFER-OR-NAME is a string
 and start with a space, undo is not enabled.

 #+BEGIN_SRC emacs-lisp
     ;; create new buffer, without undo info. make sure the string passed is unique and has space in front
     (setq newBuf (get-buffer-create " xyz"))

     ;; make it current (but does not make it visible), so all insert etc operations works on it.
     (set-buffer newBuf)
 #+END_SRC

*** Kill Buffer

 =kill-buffer= → close current buffer or a specified buffer.

 =(kill-buffer &optional BUFFER-OR-NAME)=

 #+BEGIN_SRC emacs-lisp
     ;; close a given buffer
     (kill-buffer myBuffer)
 #+END_SRC

 [[../emacs_manual/elisp/Buffers.html][(info "(elisp) Buffers")]]






** Elisp: Read/Write File
 Here's the most useful functions for working with file.

 Emacs work with files via buffer. Typically, read/write file is always
 done via a buffer.
*** Open File

 =find-file= → open a file.

 =(find-file FILENAME &optional WILDCARDS)=

 FILENAME can be a full path or just a file name.

 #+BEGIN_SRC emacs-lisp
     ;; open a file (returns a buffer)
     (find-file "~/test.txt")
 #+END_SRC

*** Write File

 =write-region= → the most useful function for writing buffer content to
 file.

 =(write-region START END FILENAME &optional APPEND VISIT LOCKNAME MUSTBENEW)=
 START and END are buffer positions, and FILENAME is a file path or name
 relative to default-directory.

 It'll write the region text to the file.

 #+BEGIN_SRC emacs-lisp
     ;; write whole buffer to a file. overwrites the file content
     (write-region (point-min) (point-max) "text.txt" )
 #+END_SRC

 =save-buffer= → save current buffer.

 =(save-buffer &optional ARG)=

 #+BEGIN_SRC emacs-lisp
     ;; save current buffer (write to the associated file)
     (save-buffer)
 #+END_SRC

 =write-file= → write buffer content into a new file, like “save as”, and
 open that file.

 =(write-file FILENAME &optional CONFIRM)=

 #+BEGIN_SRC emacs-lisp
     ;; like “Save As”. Save current buffer, close it, and open the new saved
     (write-file "~/new.txt")
 #+END_SRC

*** Append File

 =append-to-file= → append text between 2 positions in current buffer to
 a file.

 =(append-to-file START END FILENAME)=

 #+BEGIN_SRC emacs-lisp
     ;; append text between positions 100 to 200 to file
     (append-to-file 100 200 "~/test.txt")
 #+END_SRC

*** Close File

 =kill-buffer= → close buffer.

 =(kill-buffer &optional BUFFER-OR-NAME)=

 #+BEGIN_SRC emacs-lisp
     ;; close a buffer
     (kill-buffer myBuffName)
 #+END_SRC

*** Create New File

 There are several ways to create a file, depending on what you want to
 do exactly.

 =find-file= can be used to create a new file.

 =(find-file FILENAME &optional WILDCARDS)=

 FILENAME can be a full path. if FILENAME does not exist, a new file will
 be created, but only when the buffer is saved.

 #+BEGIN_SRC emacs-lisp
     ;; open a file (returns a buffer)
     (find-file "~/test.txt")
 #+END_SRC

 Here's another way to create a file, with more control.

 To create a file, just create a buffer, and save it to a file path.

 #+BEGIN_SRC emacs-lisp
     ;; name for new buffer. If start with space, undo is disabled
     (setq newBufName " xyz")

     ;; create a new buffer, save it to a var, so later you can switch to it or kill it
     (setq newBuf (generate-new-buffer newBufName))

     ;; make it current (but does not make it visible), so all insert etc operations works on it.
     (set-buffer newBuf)

     ;; like “Save As”. Save current buffer, close it, and open the new saved
     (write-file "~/new.txt")

     ;; close it
     (kill-buffer newBuf)
 #+END_SRC

 [see [[file:elisp_buffer_file_functions.html][Elisp: Buffer Functions]]]

*** with-temp-file

 =with-temp-file= → =(with-temp-file FILE BODY).=
 Create a new buffer, make it current, evaluate BODY, and write the
 buffer to FILE. The value returned is the value of the last form in
 BODY.

 #+BEGIN_SRC emacs-lisp
     ;; create a file with text hello

     (with-temp-file "test.txt"
       (insert "hello"))
 #+END_SRC

 [[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]





** Elisp: File and Directory Functions


 Here's the most useful functions for file and directory.

*** Functions on File

 Basic functions on file and directory.

 - =file-exists-p=
 - =rename-file=
 - =copy-file=
 - =delete-file=
 - =set-file-modes=

 #+BEGIN_SRC emacs-lisp
     (rename-file "/home/joe/test1.txt" "/home/joe/test2.txt")

     (copy-file "/home/joe/test1.txt" "/home/joe/test2.txt")

     (delete-file "/home/joe/test2.txt")
 #+END_SRC

 - [[../emacs_manual/elisp/Changing-Files.html][(info "(elisp) Changing
   Files")]]
 - [[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]

*** Functions on Directory

 - =directory-files=
 - =make-directory=
 - =delete-directory=
 - =copy-directory=

 #+BEGIN_SRC emacs-lisp
     (copy-directory "/home/joe/stuff" "/home/joe/stuff-backup")

     ;; delete a whole dir. new in emacs 23
     (delete-directory "/home/joe/stuff" t)
 #+END_SRC

 [[../emacs_manual/elisp/Files.html][(info "(elisp) Files")]]

 Example:

 #+BEGIN_SRC emacs-lisp
     (defun make-backup ()
       "Make a backup copy of current buffer's file.
     Create a backup of current buffer's file.
     The new file name is the old file name with trailing “~”, in the same dir.
     If such a file already exist, append more “~”.
     If the current buffer is not associated with a file, its a error."
       (interactive)
       (let ((fName (buffer-file-name))
              backupName )
         (if (not fname)
             (error "current buffer is not a file." )
           (progn
             (setq backupName (concat fName "~"))
             (while (file-exists-p backupName)
               (setq backupName (concat backupName "~")))
             (copy-file fName backupName t)
             (message (concat "Backup saved as: " (file-name-nondirectory backupName)))))))
 #+END_SRC

*** File Path Functions

 Basic functions on file path.

 - =file-name-directory=
 - =file-name-nondirectory=
 - =file-name-extension=
 - =file-name-sans-extension=
 - =file-relative-name=
 - =expand-file-name=
 - default-directory → variable. The current dir.

 #+BEGIN_SRC emacs-lisp
     ;; get the dir path part
     (file-name-directory "/home/joe/xyz.txt") ; "/home/joe/"

     ;; get filename part
     (file-name-nondirectory "/home/joe/xyz.txt") ; "xyz.txt"

     ;; get filename's extension
     (file-name-extension "/home/joe/cat.txt.jpg") ; "jpg"

     ;; get filename without extension
     (file-name-sans-extension "/home/joe/cat.txt.jpg") ; "/home/joe/cat.txt"

     ;; get relative path
     (file-relative-name "/home/joe/b/cat.jpg" "/home/joe/") ; "b/cat.jpg"

     ;; get full path
     (expand-file-name "test.el")
     ;; sample output
     ;; "/home/joe/misc/emacs/test.el"
 #+END_SRC

 [[../emacs_manual/elisp/File-Names.html][(info "(elisp) File Names")]]

*** Traverse Directory

 [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]






** Elisp: How to Write Commands


 Here's the basics of how to write a emacs command that user can call by
 Alt+x name.

*** Command Template

 This is the typical template for user-defined emacs commands.

 #+BEGIN_SRC emacs-lisp
     (defun my-command ()
       "One sentence summary of what this command do.

     More details here. Be sure to mention the return value if relevant.
     Lines here should not be longer than 70 chars,
     and don't indent them."
       (interactive)
       (let (var1 var2 …)
         (setq var1 …)
         (setq var2 …)
         ;; do something …
         ))
 #+END_SRC

 In your doc string, if you want clickable URL, or clickable reference to
 other commands, etc., See: [[file:inline_doc.html][Elisp: Doc String
 Markup]].

 be sure to also read [[file:elisp_examples.html][Elisp: Simple Emacs
 Lisp Examples]]





** Elisp: Region, Active Region


 Here's how to work with region, active region, and =transient-mark-mode=
 in emacs lisp.

*** What's Mark?

 *mark* → a position in buffer that user can set, for the purpose of
 making a text selection, or jump to a position later.

 Alt+x =set-mark-command= 【Ctrl+Space】 to set a mark.

 In lisp code, you should call =push-mark= or =set-mark=.

*** What's Region?

 *region* → The last marked position to the current cursor position.

 Once a user sets a mark in a buffer, a region exists. So, *almost
 always, there exists a region in a buffer.*

 You can get the positions of region by the functions
 {=region-beginning=, =region-end=}.

 #+BEGIN_SRC emacs-lisp
     (defun ff ()
       "sample code to show region begin/end positions"
       (interactive)
       (message "begin at %s\nend at %s"
                (region-beginning)
                (region-end)))
 #+END_SRC

 By convention, commands ending in the word “-region” acts on the region.
 Example: =kill-region=, =comment-region=, =fill-region=, =indent-region=
 .

*** What's Active Region?

 Because a region exists once a user sets a mark, and always having a
 section of text highlighted to the cursor position is annoying, so
 there's a new concept of Active Region.

 A Region is Active when the variable mark-active is true. (in elisp,
 =nil= and =()= are false, everything else is true. True is represented
 by =t= by convention.)

*** Highlighting of Region: transient-mark-mode

 Emacs has a minor mode called =transient-mark-mode=. When on, it will
 highlight the region when it's active.

 variable transient-mark-mode → when true, transient-mark-mode is on.

 =transient-mark-mode= is introduced in emacs 19 (released in 1994).

 =transient-mark-mode= is on by default since Emacs 23.1 [see
 [[../emacs/emacs23_features.html][Emacs 23.1 Features (released
 2009-07)]]]

**** When is a Region Active?

 Typically, when =set-mark-command= is called, the region becomes active
 (highlighted). When a command is called, it typically set the region
 status to inactive.

 This means, when you set mark using the keyboard or the mouse, text
 selection become highlighted, then after you called some command, the
 region returns to inactive again (and the highlighting goes away).

**** What's Text Selection?

 Emacs's concept of “active region” is practically the same as the modern
 term “Text Selection”.

 Text Selection = when region is active, and is not empty.

 When you want your command to act on a text selection when there is one,
 check on =use-region-p=.

 #+BEGIN_SRC emacs-lisp
     (defun my-is-region-active ()
       "print whether region is active."
       (interactive)
       (if (use-region-p)
           (message "region active")
         (message "region not active")))
 #+END_SRC

 The function =use-region-p= basically checks 3 things:

 1. =transient-mark-mode= is on.
 2. mark-active is true.
 3. region isn't empty by checking use-empty-active-region.

**** Create Active Region

 The following example sets a mark, and activates the region.

 #+BEGIN_SRC emacs-lisp
     (defun my-select-line ()
       "Select current line."
       (interactive)
       (let (p1 p2)
         (setq p1 (line-beginning-position))
         (setq p2 (line-end-position))
         (goto-char p1)
         (push-mark p2)
         (setq mark-active t)))
 #+END_SRC

 Note: Emacs commands should not change/modify/activate region, unless
 it's the part of the purpose of the command. Because, it's confusing to
 user when a command changes text selection or mark.

*** Get Active Region or Current {Word, Line, Text Block, File Path,
 Buffer, etc}

 Often you want a command that automatically act on a text unit such as
 current {word, line, text block, file path, buffer, etc}, when there is
 no text selection, and use text selection if there is one.

 Here's a example of getting current word, or active region.

 #+BEGIN_SRC emacs-lisp
     (defun downcase-word-or-region ()
       "Downcase current word or region."
     (interactive)
     (let (pos1 pos2 bds)
       (if (use-region-p)
          (setq pos1 (region-beginning) pos2 (region-end))
         (progn
           (setq bds (bounds-of-thing-at-point 'symbol))
           (setq pos1 (car bds) pos2 (cdr bds))))

       ;; now, pos1 and pos2 are the starting and ending positions of the
       ;; current word, or current text selection if exist.
       (downcase-region pos1 pos2)
       ))
 #+END_SRC

 For detail on other text unit, see
 [[file:elisp_thing-at-point.html][Elisp: Using thing-at-point]]

*** Emacs 23 Changes

 Starting with Emacs 23 (released in 2009), =transient-mark-mode= is on
 by default, and many command's behavior changed. If there is a text
 selection, the command acts on it, else it acts on the current word,
 line, paragraph, buffer (or whatever is its default input).

 [see [[file:emacs23_features.html][Emacs 23.1 Features (released
 2009-07)]]]

 Commands with this new behavior includes: {=fill-paragraph=,
 =ispell-word=, =indent-for-tab-command=, =comment-dwim=}. The number of
 commands that are sensitive to existence of text selection will probably
 increase.

 Note that commands ending in “-region” still should act on region as
 before, regardless of the region activeness status.

 This change is good, because users don't need to think about which of
 the region or non-region command to call.

 [[../emacs_manual/elisp/The-Mark.html][(info "(elisp) The Mark")]]






** Elisp: Get Buffer String


*** Get String from Region

 Grab text of given begin / end positions.

 #+BEGIN_SRC emacs-lisp
     ;; return string between position 3 to 99
     (buffer-substring-no-properties 3 99)
 #+END_SRC

*** Get Text Selection

 #+BEGIN_SRC emacs-lisp
     (buffer-substring-no-properties (region-beginning) (region-end))
 #+END_SRC

 [see [[file:emacs_region.html][Elisp: Region, Active Region]]]

*** Get Current Word

 #+BEGIN_SRC emacs-lisp
     ;; return the identifier under cursor
     ;; this is actually current symbol
     (current-word)
     ;; usually includes underscore _ , may include hyphen -, dollar $, etc, depending on current syntax table

     ;; return the word cursor is on, usually not including underscore _
     (current-word t t)
 #+END_SRC

 Exactly what characters is considered a part of word depends on current
 buffer's syntax table.

 For example, if you have =$ite▮m_blue-red=, and cursor is before m,
 result is one of the following:

 - =$item_blue-red= (include $ _ -)
 - =item_blue-red= (include _ -)
 - =item_blue= (include _)
 - =item= (not include any $ _ -)

 If you are beginner in elisp, don't worry about syntax table. The
 current major mode usually sets the syntax table correctly for
 programing language identifiers.

 [see [[file:elisp_syntax_table.html][Elisp: Syntax Table]]]

 Here's how to control exactly the sequence of string you want. Suppose,
 you want any letter A to Z, a to z, 0 to 9, and including LOW LINE _,
 but exclude HYPHEN-MINUS -.

 #+BEGIN_SRC emacs-lisp
     (defun my-get-word ()
       "print the word under cursor.
     Word here is any A to Z, a to z, and low line _"
       (interactive)
       (let (
             p1
             p2
             (case-fold-search t))
         (save-excursion
           (skip-chars-backward "_a-z0-9" )
           (setq p1 (point))
           (skip-chars-forward "_a-z0-9" )
           (setq p2 (point))
           (message "%s" (buffer-substring-no-properties p1 p2)))))
 #+END_SRC

*** Get Current Line

 #+BEGIN_SRC emacs-lisp
     ;; return current line as string
     (buffer-substring-no-properties (line-beginning-position) (line-end-position) )
 #+END_SRC

*** Get Thing at Point

 =thing-at-point= is a way to get the “thing” under cursor.

 The thing can be {word, symbol, line, sentence, URL, file name, ...}.

 #+BEGIN_SRC emacs-lisp
     ;; grab a “thing” at point. The “thing” is text unit. It can be 'word 'symbol 'list 'sexp 'defun 'filename 'url 'email 'sentence 'whitespace 'line 'number 'page

     ;; grab the current filename
     (setq str (thing-at-point 'filename))
 #+END_SRC

 Sometimes, you need to not just grab current word, but do other things
 such as delete the word. You need to know the beginning and ending
 positions of the region you are interested.

 Use =bounds-of-thing-at-point=

 [see [[file:elisp_thing-at-point.html][Elisp: Using thing-at-point]]]

*** Get Text Between Brackets

 Grab the current text between delimiters such as between angle brackets
 =<…>=, parens =(…)=, double quotes ="…"=, etc.

 The trick is to use =skip-chars-backward= and =skip-chars-forward=. In
 the following example, the p1 is set to the position of the double quote
 to the left of cursor (the first char to the right of the quote).
 Similarly, for p2 to the right of cursor.

 #+BEGIN_SRC emacs-lisp
     (defun my-select-inside-quotes ()
       "Select text between double straight quotes
     on each side of cursor."
       (interactive)
       (let (p1 p2)
         (skip-chars-backward "^\"")
         (setq p1 (point))
         (skip-chars-forward "^\"")
         (setq p2 (point))

         (goto-char p1)
         (push-mark p2)
         (setq mark-active t)))
 #+END_SRC

 More examples: [[file:modernization_mark-word.html][Emacs: Select Line,
 between Quotes, Extend Selection]]

*** Reference

 [[../emacs_manual/elisp/Buffer-Contents.html][(info "(elisp) Buffer
 Contents")]]






** Elisp: Functions on Line


 In emacs lisp, there are lots of ways to move by line or grab lines.
 Here are some functions or variables that are related to lines:

 - =line-beginning-position=, =line-end-position=
 - =move-beginning-of-line=, =move-end-of-line=
 - =next-line=, =previous-line=
 - =forward-line=
 - =search-forward=. For example: =(search-forward "\n")=,
   =(search-backward "\n")=
 - =line-move-visual=
 - line-move-visual
 - =thing-at-point=. For example: =(thing-at-point 'line)=

 Do you know the differences? Also, there are issues such as:

 - Is a line defined by newline char or screen line (wrapped at window
   edge)?
 - When grabbing a line, does it includes the newline char?
 - What happens if the line is at end of buffer and there's no newline
   char? Do you get a error?
 - Which is faster?

 Following are best ways to do them.

*** Get Position of Beginning/End of Line

 #+BEGIN_SRC emacs-lisp
     ;; return line beginning's position
     (line-beginning-position)

     ;; return line end's position
     (line-end-position)
 #+END_SRC

 These are written in C.

*** Move Cursor to Beginning/End of Line

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to beginning/end of current line
     (beginning-of-line)
     ;; better than (goto-char (line-beginning-position))

     (end-of-line)
     ;; better than (goto-char (line-end-position))
 #+END_SRC

 These are written in C. So, they are much faster than other functions
 that are written in elisp.

 They don't have problems when the line is at the beginning/end of
 buffer.

 They work by newline char. That is, not soft-wrapped line.

 Do not use =(search-forward "\n")= for moving cursor to end of line.
 Because you'll have special cases if the line is at the end of buffer
 and doesn't have a newline char. It is also slower.

 Do not use =move-beginning-of-line= or =move-end-of-line=. Because these
 are designed for interactive use.

*** Move Cursor to Previous/Next Line

 #+BEGIN_SRC emacs-lisp
     ;; move cursor to previous/next line. Cursor will be at beginning of line
     (forward-line -1) ; prev line
     (forward-line 1)  ; next line
 #+END_SRC

 It is written in C. It moves the cursor to the beginning of
 previous/next line.

 Do not use =next-line= or =previous-line=. Because these are for
 interactive use. Their behavior changes depending on the variable
 line-move-visual.

*** Get Current Line as String

 To grab current line, use:

 #+BEGIN_SRC emacs-lisp
     (setq myLine
           (buffer-substring-no-properties
            (line-beginning-position)
            (line-end-position)
            ))
 #+END_SRC

 Do not use =(thing-at-point 'line)=. Normally, =thing-at-point= will
 include the newline char, but if the line is at the end of buffer, then
 it won't. So, if you use it, you have to do extra work to detect special
 cases. Also, =thing-at-point= is complex elisp code and is slower.

*** Get All Lines in a File into a List

 [[file:elisp_read_file_content.html][Elisp: Read File Content as String
 or List of Lines]]

 See also: [[file:elisp_process_lines.html][Process a File line-by-line
 in Emacs Lisp]].

*** Screen Lines

 If you want to move cursor across lines as defined by the screen
 (wrapped at edge of screen), you can use these.

 - =next-line=
 - =previous-line=
 - =line-move-visual=
 - line-move-visual

 line-move-visual is variable that controls whether =next-line= and
 =previous-line= move by newline char or screen.

*** What Character Does Emacs Use for Newline

 In emacs buffer, newline char is ="\n"=, in any operating system (Mac,
 Linux, Microsoft Windows ). So, you can use =(search-forward "\n")=.
 However, if you are on the last line, there may not be a ending ="\n"=.

 ~2010 Thanks to Uday S Reddy [[[http://www.cs.bham.ac.uk/~udr/]]] and
 Alan Mackenzie [[[http://www.emacswiki.org/emacs/AlanMackenzie]]] for
 tips.






** Elisp: Cut Copy Paste to/from kill-ring


*** Copy Region to Kill Ring

 #+BEGIN_SRC emacs-lisp
     ;; push text between buffer positions to kill-ring
     (copy-region-as-kill 1 100)
 #+END_SRC

*** Kill Region to Kill Ring

 #+BEGIN_SRC emacs-lisp
     ;; delete text between buffer positions and push to kill-ring
     (kill-region 247 528)
 #+END_SRC

 Note: User's kill-ring content should not change unexpectedly. Emacs
 lisp function should not use the kill-ring as temp storage of text. If
 your command is specifically designed to put text to the kill-ring so
 that user can paste it later, then good. Else, just save text to a
 variable for your elisp program's use. e.g.
 =(setq x (buffer-substring-no-properties pos1 pos2))=

*** String to Kill Ring

 If you already have a string, use =kill-new=

 #+BEGIN_SRC emacs-lisp
     ;; push a string into kill-ring
     (kill-new "cute cat")
 #+END_SRC

*** Append String to Kill Ring

 #+BEGIN_SRC emacs-lisp
     ;; append string to the latest in kill-ring
     (kill-append "cute cat" nil)
     ;; if second arg is t, do prepend
 #+END_SRC

*** Paste from Kill Ring

 #+BEGIN_SRC emacs-lisp
     ;; paste from kill-ring
     (yank)
 #+END_SRC

*** Mark a Region

 To mark a region, do =(push-mark positon)=. The current cursor positon
 to positon will become the new region.

 To make the region active, use =(setq mark-active t)=.

 [see [[file:emacs_region.html][Elisp: Region, Active Region]]]

 #+BEGIN_SRC emacs-lisp
     (defun my-select-text-in-quote ()
       "Select text between the nearest left and right quotes."
       (interactive)
       (let ($pos
             ($skipChars "^\""))
         (skip-chars-backward $skipChars)
         (setq $pos (point))
         (skip-chars-forward $skipChars)
         (push-mark $pos)
         (setq mark-active t)))
 #+END_SRC

 [[../emacs_manual/elisp/The-Kill-Ring.html][(info "(elisp) The Kill
 Ring")]]






** Elisp: Get User Input


*** Get User Input with Name Completion and Input History

 The most useful functions for getting user input with completion or
 command history support are:

 - =read-string=
 - =read-file-name=
 - =read-directory-name=
 - =read-regexp=

 Command history means, user can press ↑ key to enter previous input.
 (e.g. Alt+x =shell-command=) Also, some commands provide name completion
 (e.g. Alt+x =dired=).

*** Prompt for File Name

 =read-file-name= example:

 #+BEGIN_SRC emacs-lisp
     (defun ff ()
       "Prompt user to enter a file name, with completion and history support."
       (interactive)
       (message "String is %s" (read-file-name "Enter file name:")))
 #+END_SRC

 Try it. You'll have file name completion feature. Pressing ↑ will show
 previous file name you used.

*** Prompt for Directory

 =read-directory-name= example:

 #+BEGIN_SRC emacs-lisp
     (defun ff ()
       "Prompt user to enter a dir path, with path completion and input history support."
       (interactive)
       (message "Path is %s" (read-directory-name "Directory:")))
 #+END_SRC

*** Prompt for String

 =read-string= example:

 #+BEGIN_SRC emacs-lisp
     (defun ff ()
       "Prompt user to enter a string, with input history support."
       (interactive)
       (message "String is %s" (read-string "Enter your name:")))
 #+END_SRC

*** Prompt for Regex String

 =read-regexp= example:

 #+BEGIN_SRC emacs-lisp
     (defun ff ()
       "Prompt user to enter a elisp regex, with input history support."
       (interactive)
       (message "Regex is %s" (read-regexp "Type a regex:")))
 #+END_SRC

 The most general command is =read-from-minibuffer=. All the above are
 implemented on top of it.

 [[../emacs_manual/elisp/Minibuffers.html][(info "(elisp) Minibuffers")]]

*** Select from a List

 The best way to ask user to select from a list, is by
 =ido-completing-read=.

 #+BEGIN_SRC emacs-lisp
     (require 'ido)

     (defun my-pick-one ()
       "Prompt user to pick a choice from a list."
       (interactive)
       (let ((choices '("cat" "dog" "dragon" "tiger")))
         (message "%s" (ido-completing-read "Open bookmark:" choices ))))
 #+END_SRC

*** Query User for Yes/No

 =y-or-n-p= → Ask user a “y or n” question. Return t if answer is “y” and
 nil if it is “n”.

 #+BEGIN_SRC emacs-lisp
     (if (y-or-n-p "Do it?")
         (progn
           ;; code to do something here
         )
       (progn
         ;; code if user answered no.
       )
     )
 #+END_SRC

 [[../emacs_manual/elisp/Yes_002dor_002dNo-Queries.html][(info "(elisp)
 Yes-or-No Queries")]]

*** Get User Input as Function's Arguments

 [[file:elisp_interactive_form.html][Elisp: Interactive Form]]

*** Get User Input from universal-argument

 [[file:elisp_universal_argument.html][Elisp: Get universal-argument]]






** Elisp: Interactive Form


 A common way of getting user input is by the “interactive” form.

 =(interactive "code_letter_and_promp_string")=

 The =interactive= expression must come right after the doc string.

 Example:

 #+BEGIN_SRC emacs-lisp
     (defun ask-name (x)
       "Ask name."
       (interactive "sEnter your name: ")
       (message "Name: %s" x))
 #+END_SRC

*** Purpose of Interactive Form

 The =interactive= has 2 purposes.

 1. Make elisp function callable as interactive command.
 2. A mechanism for passing arguments to function when called
    interactively.

 A function with the =interactive= clause is called a *command*, and can
 be called by =execute-extended-command= (that is, pressing Alt+x).

*** Get String as Argument

 =(interactive "sprompt_string")= → prompt user, pass as first argument
 of function as string.

 #+BEGIN_SRC emacs-lisp
     (defun ask-name (x)
       "Ask name."
       (interactive "sEnter your name: ")
       (message "Name: %s" x))
 #+END_SRC

*** Get Number as Argument

 =(interactive "nprompt_string")= → prompt user, pass answer as first
 argument of function as string.

 #+BEGIN_SRC emacs-lisp
     (defun ask-age (x)
       "Ask age."
       (interactive "nEnter your age: ")
       (message "Name: %d" x))
 #+END_SRC

*** Get Region Begin End Positions as Argument

 =(interactive "r")= → pass answer region begin and end as arguments to
 function.

 #+BEGIN_SRC emacs-lisp
     (defun print-region-boundary (x y)
       "Prints region start and end positions"
       (interactive "r")
       (message "Region begin at: %d, end at: %d" x y))
 #+END_SRC

*** Passing Interactive a List

 =(interactive list_expression)= → pass the list that's the value of
 list_expression to function as arguments.

 This is the most general way of using =interactive=. The list_expression
 can be any lisp code, it just need to return a list. The lisp code can
 contain prompts, such as =read-string=, =read-file-name=, etc. [see
 [[file:elisp_idioms_prompting_input.html][Elisp: Get User Input]]]

 #+BEGIN_SRC emacs-lisp
     (defun do-something (x y)
       "Ask name and age"
       (interactive
        ;; complex code here that returns a list
        (list "Mary" 22))
       (message "Name is: %s, Age is: %d" x y))
 #+END_SRC

*** Ways to Call Interactive

 There are 3 forms of =interactive=:

 1. =(interactive)= → No argument. This simply makes the function as
    command, and does not pass any argument to the function.
 2. =(interactive string)= → The first character (or first few character
    in same cases) in string tells emacs how to interpret the user input
    (such as string, number, file name, directory name, regex, lisp
    expression, key stroke, etc) and what datatype (string, number, etc)
    it should be converted to as your function's argument. The rest of
    string are use as prompt. However, if string contains multiple lines,
    each line's beginning are taken as what-to-do code.
 3. =(interactive (list …))= → This is the most general way to fill
    function arguments from user input. This list elements will be passed
    as arguments to your function. Usually, it's like this
    =(interactive some_lisp_code)= where some_lisp_code evaluates to a
    list.

 There are about 30 string codes for =interactive string= , the most
 useful are shown on this page.

 For complete list of interactive code, see
 [[../emacs_manual/elisp/Defining-Commands.html][(info "(elisp) Defining
 Commands")]]

 If your function takes multiple inputs, you can promp user multiple
 times, using a single =interactive= call, with mulitple lines, each line
 begin with a prompt code.

 #+BEGIN_SRC emacs-lisp
     (defun ask-name-and-age (x y)
       "Ask name and age"
       (interactive "sEnter you name:
     nEnter your age: ")
       (message "Name is: %s, Age is: %d" x y))
 #+END_SRC






** Elisp: Get universal-argument


 This page shows you how to make your emacs command accept
 =universal-argument= 【Ctrl+u】 given by user.

*** Problem

 You have written a emacs command. You want the command's behavior to be
 different if user presses Ctrl+u before calling your command.

**** Detail

 Emacs has a mechanism for a command to have variant behavior if user
 calls =universal-argument= 【Ctrl+u】.

 The purpose of =universal-argument= is:

 - A convenient way to let user pass numerical argument to a command.
   (What the command do with number argument depends on the command.)
 - To simply have a alternate behavior of a command. (e.g. copy file name
   normally, or copy full path.)

 For example:

 - in dired, typing w will copy the file name
   (=dired-copy-filename-as-kill=), but if you type Ctrl+u 0 w, the
   copied name will be file full path.
 - Type Ctrl+u 5 e and it'll insert e 5 times.

*** Solution

 To make your command aware of universal argument, there are 3 simple
 ways:

 - The global variable current-prefix-arg holds the value of universal
   argument.
 - Add =(interactive "P")= to your function. It passes the value of
   current-prefix-arg as your function's first parameter.
 - Add =(interactive "p")= to your function. It passes converted
   numerical value of current-prefix-arg to your function's first
   argument.

 [see [[file:elisp_interactive_form.html][Elisp: Interactive Form]]]

 Example:

 #+BEGIN_SRC emacs-lisp
     (defun f (x)
       "print argument received"
       (interactive "P")
       (message "%s" x)
       ;; value of x is from universal argument, or nil if universal-argument isn't called
     )
 #+END_SRC

**** Possible Values of Universal Argument

 Here's the possible values of current-prefix-arg.

 | Key Input                  | Value of current-prefix-arg   | Numerical Value   |
 | No universal arg called.   | =nil=                         | 1                 |
 | Ctrl+u -                   | Symbol =-=                    | -1                |
 | Ctrl+u - 2                 | Number =-2=                   | -2                |
 | Ctrl+u 1                   | Number =1=                    | 1                 |
 | Ctrl+u 4                   | Number =4=                    | 4                 |
 | Ctrl+u                     | List ='(4)=                   | 4                 |
 | Ctrl+u Ctrl+u              | List ='(16)=                  | 16                |

 #+BEGIN_SRC emacs-lisp
     (defun g ()
       "print `current-prefix-arg'"
       (interactive )
       (message "%s" current-prefix-arg))

     ;; try
     ;; M-x g
     ;; C-u M-x g
     ;; C-u C-u M-x g
     ;; C-u 1 M-x g
     ;; C-u 2 M-x g
 #+END_SRC

*** Checking current-prefix-arg

 Here's a example that expect all possible use of =universal-argument=
 values, by manually checking the value of current-prefix-arg, and feed
 it to the function's arguments.

 #+BEGIN_SRC emacs-lisp
     (defun utest (arg1 &optional arg2 arg3)
       "Sample command to test `universal-argument'."
       (interactive
        (cond
         ((equal current-prefix-arg nil) ; no C-u
          (list 1 nil nil))
         ((equal current-prefix-arg '(4)) ; C-u
          (list 1 2 nil))
         ((equal current-prefix-arg 2) ; C-u 2
          (list 1 2 3))
         ;; more special case here

         (t ; all other cases, prompt
          (list
           (read-string "arg1:" )
           (read-string "arg2:" )
           (read-string "arg3:" )))))

       ;; now, all the parameters of your function is filled.
       ;; code body here

       (message "args are: %s %s %s" arg1 arg2 arg3)
       ;;
       )
 #+END_SRC

 The =(interactive …)= is used to fill out the parameters.

 [see [[file:elisp_interactive_form.html][Elisp: Interactive Form]]]

 The =read-string= is to prompt user for input.

 [see [[file:elisp_idioms_prompting_input.html][Elisp: Get User Input]]]

 --------------




 --------------
** Elisp: Find Replace String in Buffer


 This page shows you how to do Find Replace in emacs lisp.

*** Find Replace Text in Buffer

 #+BEGIN_SRC emacs-lisp
     ;; idiom for string replacement in current buffer

     (let ((case-fold-search t)) ; or nil

       (goto-char (point-min))
       (while (search-forward "myStr1" nil t)
         (replace-match "myReplaceStr1"))

       (goto-char (point-min))
       (while (search-forward "myStr2" nil t)
         (replace-match "myReplaceStr2"))

       ;; repeat for other string pairs
       )

     ;; if you need regexp, use search-forward-regexp
 #+END_SRC

**** Letter Case Sensitivity in Search

 To control the letter case of search, locally set case-fold-search to
 =t= or =nil=. By default, it's t.

 #+BEGIN_SRC emacs-lisp
     (let (
           (case-fold-search nil) ; case sensitive search
           )
       ;; find replace code here
       )
 #+END_SRC

**** Letter Case Sensitivity in Replacement

 To control letter case of the replacement, use the optional arguments in
 =replace-match= function.

 =(replace-match NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)=

 Use =t= for FIXEDCASE.

**** Match Data

 Whenever you use regex in emacs lisp, the captured text is stored in
 =match-string=.

***** Get Match String

 =match-string=

 #+BEGIN_SRC emacs-lisp
     ;; the second captured string
     (match-string 2)
 #+END_SRC

***** Get Boundary Positions of Match String

 =match-beginning= and =match-end= returns the beginning and end
 positions of the matched string.

 #+BEGIN_SRC emacs-lisp
     ;; get the positions of the 2nd captured string
     (setq pos1 (match-beginning 2)
           pos2 (match-end 2))
 #+END_SRC

 Complete match data can be accessed by the function =match-data=.

*** Find Replace in a Region Boundary

 If you need to do find replace on a region only, wrap the code with
 =save-restriction= and =narrow-to-region=. Example:

 #+BEGIN_SRC emacs-lisp
     ;; idiom for string replacement within a region
     (save-restriction
       (narrow-to-region pos1 pos2)

       (goto-char (point-min))
       (while (search-forward "myStr1" nil t)
         (replace-match "myReplaceStr1"))

       ;; repeat for other string pairs
       )
 #+END_SRC

 If you need to find replace multiple pairs frequently, see:
 [[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

**** WARNING: Boundary Change After Find Replace

 Whenever you work in a region, remember that the boundaries of the text
 that you are interested is changed when you add or remove text in that
 region. For example, suppose {p1, p2} is the boundary of some text you
 are interested. After doing some change there, suppose you want to do
 some more change. Don't just call =(something-region p1 p2)= again,
 because p2 is no longer the correct boundary.

 Use =save-restriction= and =narrow-to-region=, like this:

 #+BEGIN_SRC emacs-lisp
     (save-restriction
       (narrow-to-region pos1 pos2)
       (something1-region (point-min) (point-max))
       (something2-region (point-min) (point-max))
       …
     )
 #+END_SRC

 --------------




 --------------
** Elisp: Using thing-at-point


 This page shows you how to use =thing-at-point= function to get text
 unit such as current {word, line, text block, file path, buffer, etc}
 from buffer into a string.

*** thing-at-point

 When writing interactive commands, one of the most useful function is
 =thing-at-point=.

 =thing-at-point= lets you get the current word under cursor into a
 string. (or, current line, current sentence, paragraph, file, URL,
 defun, etc.)

 Here's a example.

 #+BEGIN_SRC emacs-lisp
     (defun xx ()
       "print current word."
       (interactive)
       (message "%s" (thing-at-point 'word)))
 #+END_SRC

 Evaluate the code, then try it. [see
 [[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

*** Finding the Positions of a Thing's Boundary

 Sometimes you also need to know a thing's boundary, because you may need
 to delete it (using =(delete-region position1 position2)=).

 =bounds-of-thing-at-point= returns the boundary positions of the text
 unit under cursor.

 #+BEGIN_SRC emacs-lisp
     (defun my-get-boundary-and-thing ()
       "example of using `bounds-of-thing-at-point'"
       (interactive)
       (let (bounds pos1 pos2 mything)
         (setq bounds (bounds-of-thing-at-point 'symbol))
         (setq pos1 (car bounds))
         (setq pos2 (cdr bounds))
         (setq mything (buffer-substring-no-properties pos1 pos2))

         (message
          "thing begin at [%s], end at [%s], thing is [%s]"
          pos1 pos2 mything)))
 #+END_SRC

*** thing-at-point and Syntax Table

 The exact meaning of “thing”, depends on current buffer's syntax table.

 [see [[file:elisp_syntax_table.html][Elisp: Syntax Table]]]

 --------------




 --------------
** Elisp: Get Text Block


 Often, you want a interactive command to work on a text block, without
 user having to manually select it. (text block is group of lines
 separated by empty lines, similar to a paragraph.)

 Commands working on text block is especially useful in programing
 language source code.

 Here's command that gets the beginning and ending positions of text
 block the cursor is in.

 #+BEGIN_SRC emacs-lisp
     (defun get-text-block-positions ()
       "Return a vector [begin end] of text block,
      Return a vector [begin end] that's the begin and end positions of text block the cursor is in.
     Text block is group of lines separated by blank lines.

     Version 2020-06-10"
       (interactive)
       (let ($p1 $p2)
         (save-excursion
           (if (re-search-backward "\n[ \t]*\n" nil "move")
               (progn (re-search-forward "\n[ \t]*\n")
                      (setq $p1 (point)))
             (setq $p1 (point)))
           (if (re-search-forward "\n[ \t]*\n" nil "move")
               (progn (re-search-backward "\n[ \t]*\n")
                      (setq $p2 (point)))
             (setq $p2 (point))))
         (vector $p1 $p2)
         (message "%s" (vector $p1 $p2))))
 #+END_SRC

 --------------




 --------------
** Elisp: Save narrow-to-region


 Emacs has a =narrow-to-region= command. It lets users make the buffor
 show only the selected region, as if the entire buffer is just that
 text. This is convenient when you want to do some editing only in this
 region. Alt+x =widen= will make buffer show whole buffer again.

 The =narrow-to-region= is also super useful in elisp code. However, when
 you command is done, you should return to the narrow region state of the
 user before the command was called. Emacs lisp provides
 =save-restriction= for this purpose.

 =save-restriction= → =(save-restriction &rest BODY)= Execute BODY,
 saving and restoring user's =narrow-to-region= .

 In elisp code, when you call =narrow-to-region=, you almost always want
 to wrap it with =save-restriction=, like this:

 #+BEGIN_SRC emacs-lisp
     ;; preserve user's narrow-to-region
     ;; useful when you want to narrow-to-region in your code to work in just that region
     (save-restriction
       (narrow-to-region pos1 pos2)
       ;; lisp code here
     )
 #+END_SRC

 [[../emacs_manual/elisp/Positions.html][(info "(elisp) Positions")]]

 --------------




 --------------
** Elisp: Run Elisp Script in Shell


 You can run emacs lisp script in shell (terminal), using the =--script=
 option. For example:

 #+BEGIN_SRC emacs-lisp
     emacs --script process_log.el
 #+END_SRC

 Here's a table of most useful options for running emacs lisp as a
 script.

 - =--no-init-file= or =-q= :: Do not load your init files {=~/.emacs=,
   =~/.emacs.el=, =~/.emacs.d/init.el=} nor site-wide =default.el=.
 - =--no-site-file= :: Do not load the site-wide =site-start.el=.
 - =--batch= :: Do not launch emacs as a editor. Use it together with
   =--load= to specify a lisp file. This implies =--no-init-file= but not
   =--no-site-file=.
 - =--load="path"= or =-l path= :: Execute the elisp file at path.
 - =--script path= :: Run emacs like =--batch= with =--load= set to path.

*** What's site-start.el?
 The =site-start.el= is a init file for site-wide running of emacs.

 It pretty much means a init file for all users of this emacs
 installation. It may be added by a sys admin, or it may be part of a
 particular emacs distribution (For example, Carbon Emacs, Aquamacs
 Emacs, etc.).

 You can usually find this file in the directory where emacs is
 installed, if it exists. Typically in a directory named “site-lisp”. For
 example, =~/apps/emacs-25.1/site-lisp/=. But the file can be anywhere in
 emacs load-path.

*** Prepare Your Emacs Lisp Script to Run in Batch Mode

 When you write a elisp script to run in batch, make sure your elisp file is:

 1. self-contained; Doesn't depend on anything from your emacs init file.
 2. Explicitly load all libraries it needs (using =require= or =load=).
 3. Has necessary load path set in the script (For example,
    =(add-to-list 'load-path lib_path)=) if it needs libs that's not part
    of standard GNU emacs install, just like you would with a Python or
    Ruby script.

*** How to start emacs on a Mac from command line?

 If you are on a Mac, call it from the command line like this:

 #+BEGIN_SRC emacs-lisp
     /Applications/Emacs.app/Contents/MacOS/Emacs --script=name.el
 #+END_SRC


** Elisp: Get Command Line Arguments
 when you run emacs lisp script from terminal

 =emacs --script do.el arg1 arg2=

 You can get the arguments in elisp from the variable argv

 argv → a built-in variable. Its value is a list. Each element is a item
 from the command line.

 #+BEGIN_SRC emacs-lisp
     (message "argv 0: %s" (elt argv 0)) ; %s is for string
     (message "argv 1: %s" (elt argv 1))
     (message "argv 2: %s" (elt argv 2))
     (message "argv 3: %s" (elt argv 3))
 #+END_SRC

 Save and name the above script as =test.el= and run it like this:

 #+BEGIN_SRC emacs-lisp
     emacs --script test.el uni 2 -tri
 #+END_SRC

 Here's the output:

 #+BEGIN_SRC emacs-lisp
     $ emacs --script test.el uni 2 -tri
     argv 0: "uni"
     argv 1: "2"
     argv 2: "-tri"
     argv 3: nil
 #+END_SRC

 [[../emacs_manual/elisp/Command_002dLine-Arguments.html][(info "(elisp)
 Command-Line Arguments")]]

 2011-07-22 Thanks to Piotr Chamera 〔piotr_cham...@poczta.onet.pl〕,
 Swami Tota Ram Shankar 〔tota_...@india.com〕.

 --------------




 --------------
** Elisp: Read File


 If you don't care about speed, use

 - =find-file=
 - =find-file-read-only=

 to open a file into buffer. Then you can process it. and call
 =save-buffer= to save, like you would with using emacs.

 #+BEGIN_SRC emacs-lisp
     (find-file "~/test.html")
 #+END_SRC

 If the file doesn't exit, it'll be created when you save it.

 Note that =find-file= has lots side-effects. It will call all functions
 in find-file-hook. Many packages and major modes add stuff to that hook.
 It'll load a major mode (which does syntax coloring, usually very slow),
 it'll record undo for any modification in the buffer.

 [see [[../emacs/elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp
 Text Processing: find-file vs with-temp-buffer]]]

*** Open File for Reading in Batch Script

 To process thousands of files, read only, use =with-temp-buffer=.

 #+BEGIN_SRC emacs-lisp
     (defun my-process-file (fPath)
       "Process the file at path FPATH …"
       (with-temp-buffer
         (insert-file-contents fPath)
         ;; process it …
         ))
 #+END_SRC

 [[../emacs_manual/elisp/Current-Buffer.html][(info "(elisp) Current
 Buffer")]]

*** Read File as String or List of Lines

 [[file:elisp_read_file_content.html][Elisp: Read File Content as String
 or List of Lines]]

 --------------




 --------------
** Elisp: Read File Content as String or List of Lines


*** Read File Content into a String

 #+BEGIN_SRC emacs-lisp
     (defun get-string-from-file (filePath)
       "Return filePath's file content."
       (with-temp-buffer
         (insert-file-contents filePath)
         (buffer-string)))
     ;; thanks to “Pascal J Bourguignon” and “TheFlyingDutchman 〔zzbba…@aol.com〕”. 2010-09-02
 #+END_SRC

*** Read File Content as List of Lines

 #+BEGIN_SRC emacs-lisp
     (defun read-lines (filePath)
       "Return a list of lines of a file at filePath."
       (with-temp-buffer
         (insert-file-contents filePath)
         (split-string (buffer-string) "\n" t)))
 #+END_SRC

 Once you have a list, you can use =mapcar= to process each element in
 the list. If you don't need the resulting list, use =mapc=.

 Note: in elisp, it's more efficient to process text in a buffer than
 doing complicated string manipulation with string data type. But, if
 your lines are all short and you don't need to know the text that comes
 before or after current line, then, list of lines can be easier to work
 with.

 --------------




 --------------
** Elisp: Write File


*** Write Region to File

 To write to a file in a batch script, most of the time you want
 =write-region=

 #+BEGIN_SRC emacs-lisp
     ;; write current buffer's content to ~/temp.el
     (write-region (point-min) (point-max) "~/temp.el")
 #+END_SRC

 Note: in batch script you should not use =write-file=. “write-file” is
 like other editor's “Save As”. It has side-effects such as opening the
 file, run its major mode and hooks, and is slow. [see
 [[../emacs/elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp Text
 Processing: find-file vs with-temp-buffer]]]

*** Write String to File

 #+BEGIN_SRC emacs-lisp
     (write-region "something something" nil "filepath")
 #+END_SRC

*** Open, Read, Possibly Write

 If you want to write to file ONLY when you actually changed the file,
 you can create flag variable and use =write-region=, like this:

 #+BEGIN_SRC emacs-lisp
     (defun my-process-file (fPath)
       "Process the file at path FPATH …"
       (let ((fileChanged-p nil))
         (with-temp-buffer
           (insert-file-contents fPath)

           ;; process text
           ;; set fileChanged-p to t or nil

           (when fileChanged-p (write-region 1 (point-max) fPath)))))
 #+END_SRC

*** Create New File

 If you want to create new file, use =with-temp-file=.

 =(with-temp-file path &rest body)=

 it'll create a new buffer, then run body, then it'll write to file at
 path. Existing file at path are overwritten.

 #+BEGIN_SRC emacs-lisp
     ;; create new buffer, do things, then write to file at fpath
     (with-temp-file fpath
       (insert-file-contents fpath)

       ;; insert text here

       )
 #+END_SRC

*** Append to File

 =(append-to-file START END FILENAME)=
 #+BEGIN_SRC emacs-lisp
     ;; append whole buffer content to a file
     (append-to-file (point-min) (point-max) "filePath")
 #+END_SRC

 [[../emacs_manual/elisp/Writing-to-Files.html][(info "(elisp) Writing to
 Files")]]

 --------------




 --------------
** Elisp: Print, Output


 Here's a summary of most basic elisp printing functions:

 • =message= → =(message FORMAT-STRING &rest ARGS)= print a format string
 to the message buffer.

 • =insert= → =(insert &rest ARGS)= instert string to current buffer, at
 cursor position.

 • =print= → =(print OBJECT &optional PRINTCHARFUN)= print lisp object.
 Output can be read back by function =read=. Optional arg for a target
 buffer, or other functions.

 • =prin1= → =(prin1 OBJECT &optional PRINTCHARFUN)= like print, but does
 not add newline at end.

 • =princ= → =(princ OBJECT &optional PRINTCHARFUN)= print without
 newline nor delimiters. For human reading.

*** Simple Printing with “message”

 The most basic printing function is =message=. Here's a example:

 #+BEGIN_SRC emacs-lisp
     ; printing
     (message "hi")

     ; printing variable values

     ;; %d is decimal number
     (message "age is: %d " 16)

     ;; %s is for string
     (message "name is: %s " "Joe")

     ;; %c is char by unicode codepoint in decimal
     (message "Mid init is: %c " 65)
     ;; 65 is A
 #+END_SRC

 You can see past output of the =message= function in the buffer named
 “*Messages*”. You can view the buffer by Alt+x =view-echo-area-messages=
 【Ctrl+h e】.

 The “*Messages*” buffer is a special buffer, because it is the general
 output destination for any messages from emacs.

 For example, it automatically truncates the top entries when the buffer
 reaches some size (see variable messages-buffer-max-lines). Also, when a
 message is repeated many times, it automatically condenses the repeated
 lines. And if a message is a huge line, the line is truncated
 automatically. Here's a example.

 #+BEGIN_SRC emacs-lisp
     ;; print a line many times
     (setq xx 1)
     (while (< xx 20)
       (message "yay")
       (setq xx (1+ xx))
       )
     (switch-to-buffer "*Messages*")
 #+END_SRC

 In the above example, it prints “yay [19 times]” instead of the “yay”
 line for 19 times.

 [[../emacs_manual/elisp/Displaying-Messages.html][(info
 "(elisp)Displaying Messages")]]

*** Print to Your Own Buffer

 When writing a elisp script that does batch processing, it's best to
 print to your own buffer, because the Messages buffer scrolls off.

 #+BEGIN_SRC emacs-lisp
     (setq xbuff (generate-new-buffer "*my output*"))

     (print "something" xbuff)

     (switch-to-buffer xbuff )
 #+END_SRC

 [see [[file:elisp_buffer_file_functions.html][Elisp: Buffer Functions]]]

*** “print” and “prin1” function

 Elisp provides the =print= function. The basic syntax is this:

 =(print OBJECT)=

 The “OBJECT” is any elisp object you want to print. It can be any lisp
 datatype, such as string, number, list, buffer, frame, ..., etc.

 There's also a function named =prin1=. This is same as =print= except it
 doesn't add a newline.

*** “princ” for Human-Friendly Output

 The =princ= is similar to =print=, except that the output is meant to be
 human-friendly. For example, it does not print the delimiters of
 strings.

 #+BEGIN_SRC emacs-lisp
     (princ '("x" "y")) ; (x y)

     (prin1 '("x" "y")) ; ("x" "y")
 #+END_SRC

 [[../emacs_manual/elisp/Output-Functions.html][(info "(elisp) Output
 Functions")]]

*** with-output-to-temp-buffer

 =with-output-to-temp-buffer= →
 =(with-output-to-temp-buffer BUFNAME &rest BODY)= Bind ‘standard-output'
 to buffer BUFNAME, eval BODY, then show that buffer. This construct
 makes buffer BUFNAME empty before running BODY. It does not make the
 buffer current for BODY. Instead it binds ‘standard-output' to that
 buffer, so that output generated with ‘prin1' and similar functions in
 BODY goes into the buffer.

 #+BEGIN_SRC emacs-lisp
     (setq xbuff (generate-new-buffer "*my output*"))

     (with-output-to-temp-buffer xbuff

       ;; this is inserted in current buffer
       (insert "xyz")

       ;; this is printed in buffer xbuff
       (print "abc"))

     (switch-to-buffer xbuff )
 #+END_SRC

 --------------




 --------------
** Elisp: Format String


 How a lisp object is converted to string for printing is done by the
 =format= function. It takes a input string, and several other arguments
 of lisp objects, and output a string. Alt+x =describe-function= to
 lookup its doc string. Here's a excerpt:

 #+BEGIN_SRC emacs-lisp
     (format STRING &rest OBJECTS)

     Format a string out of a format-string and arguments.
     The first argument is a format control string.
     The other arguments are substituted into it to make the result, a string.

     The format control string may contain %-sequences meaning to substitute
     the next available argument:

     %s means print a string argument.  Actually, prints any object, with `princ'.
     %d means print as number in decimal (%o octal, %x hex).
     %X is like %x, but uses upper case.
     %e means print a number in exponential notation.
     %f means print a number in decimal-point notation.
     %g means print a number in exponential notation
       or decimal-point notation, whichever uses fewer characters.
     %c means print a number as a single character.
     %S means print any object as an s-expression (using `prin1').

     …
 #+END_SRC

 For example, if you want to print a date format in yyyy-mm-dd, padding
 with leading “0”, you can do:

 #+BEGIN_SRC emacs-lisp
     ;; format yyyy-mm-dd, ISO 8601 format
     (print (format "%04d-%02d-%02d" 2012 4 10))
 #+END_SRC

 --------------




 --------------
** Elisp: Get Dired Marked Files


 To get marked files in dired, use =dired-get-marked-files=

 Then, you can map a function to all the files.

 #+BEGIN_SRC emacs-lisp
     ;; apply a function to dired's marked files

     (require 'dired)

     (defun xah-open-dired-marked ()
       "Open marked files in dired."
       (interactive)
       (mapc 'find-file (dired-get-marked-files))
     )

     ;; test
     ;; M-x dired, then mark some files, then M-x xah-open-dired-marked

     ;; replace find-file to your own function
 #+END_SRC

 --------------




 --------------
** Elisp: Walk Directory


 Here's how to walk directory.

*** List Directory

 =(directory-files DIRECTORY &optional FULL MATCH NOSORT)= → Return a
 list of names of files in DIRECTORY. If FULL is non-nil, return absolute
 file names. If MATCH is non-nil, only return matched files. If NOSORT is
 non-nil, the list is not sorted, order is unpredictable.

 #+BEGIN_SRC emacs-lisp
     ;; walk dir

     (mapc
      (lambda (x) (insert x "\n"))
      (directory-files "/Users/x/em/emacs/i" nil "\.jpg$" t))

     ;; sample output

     ;; ztn_emacs_pinky_wedge_2018-02-24.jpg
     ;; xah_lee_photo_2018-06-28.jpg
     ;; xah-fly-keys_kinesis_2017-09_60363.jpg
     ;; todo_list_crossout_nothing.jpg
     ;; the_book_of_shen_lang.jpg
     ;; sun_type_6_keyboard_meta_compose_altgraph_keys.jpg
 #+END_SRC

 [see [[file:elisp_regex.html][Elisp: Regex Tutorial]]]

 Note: in unix, directory is considered a special file. So, in emacs doc
 and other unix doc, the term “file name” may also refer to directory
 name.

*** List Directory and All Subdir

 =(directory-files-recursively DIR REGEXP &optional INCLUDE-DIRECTORIES)=

 Return list of all files under DIR and all its subdir that have file
 names matching REGEXP. (note, the match is done against file name only,
 not full path.) Returned list elements are full path. Optional argument
 INCLUDE-DIRECTORIES non-nil means also include in the output directories
 whose names match REGEXP.

 #+BEGIN_SRC emacs-lisp
     ;; walk dir and all subdir

     (mapc (lambda (x) (insert x "\n"))
           (directory-files-recursively "/Users/x/em/" "\.jpg$" ))

     ;; sample output

     ;; /Users/x/em/emacs/i/Apple_G4_iBook_Snow_Euro_layout_keyboard_62224.jpg
     ;; /Users/x/em/emacs/i/Apple_iBook_G4_Snow_77735.jpg
     ;; /Users/x/em/misc/i/typing_of_the_dead_36588.jpg
     ;; /Users/x/em/misc/i/vim_fitness.jpg
     ;; /Users/x/em/tn/emacs/emacs_logo/emacs_logo_large.jpg
     ;; /Users/x/em/tn/emacs/i/unicode/Carbon_emacs_22_unicode.jpg
 #+END_SRC

*** Skipping Subdir

 In other programing languages (perl python golang), usually the dir
 walker lets you skip some specified directory. The walker calls a doFile
 function you write, and pass current dir or file, so you can skip it to
 prevent going into.

 In elisp, there's a package find-lisp.el that lets you use a regex to
 filter dir, but is very slow. I do not recommend it.
 [[[../emacs/elisp_find_lisp.html][Elisp: find-lisp.el]]]

 To skip some subdir, it's faster if you just use
 =directory-files-recursively= then filter result.

 #+BEGIN_SRC emacs-lisp
     (setq
      skipDirs
      [
       "ergoemacs_org/emacs_manual/"
       "xahlee_info/REC-SVG11-20110816/"
       "xahlee_info/clojure-doc-1.8/"
       "xahlee_info/js_es2016/"
       "xahlee_info/python_doc_3.3.3/"
       ])

     (seq-filter
      (lambda (path)
        (not (seq-some
              (lambda (x) (string-match x path))
              skipDirs )))
 #+END_SRC

 =seq-filter= and =seq-some= are in emacs 25.

 [see [[../emacs/elisp_sequence_functions.html][Elisp: Sequence
 Functions]]]

** Elisp: Call Shell Command
*** Call Shell Command, Wait, Get Result
 - =shell-command= → call a shell command, wait for it to finish.
 - =shell-command-to-string= → call a shell command and get its output

 #+BEGIN_SRC emacs-lisp
     ; call a shell command
     (shell-command "ls")
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ; call a shell command and get its output
     (shell-command-to-string "ls")
 #+END_SRC

*** Call Shell, Don't Wait
 Call a shell command, but don't wait for it to finish before continuing,
 use =start-process= or =start-process-shell-command=

 #+BEGIN_SRC emacs-lisp
     ;; open files in Linux desktop
     (mapc
      (lambda (x)
        (let ((process-connection-type nil))
          (start-process "" nil "xdg-open" x)) )
      filePathList)
 #+END_SRC

*** Call PowerShell

 Here's a example of how to call a PowerShell Core command.

 #+BEGIN_SRC emacs-lisp
     ;; on Microsoft Windows 10, call PowerShell Core to generate UUID
     (shell-command "pwsh.exe -Command [guid]::NewGuid().toString()" t)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; on macOS, call PowerShell Core to generate UUID
     (shell-command "pwsh -Command '[guid]::NewGuid().toString()'" t)
 #+END_SRC

*** Reference

 [[../emacs_manual/elisp/Asynchronous-Processes.html][(info "(elisp)
 Asynchronous Processes")]]

 --------------




 --------------
** Elisp: Get Script Name at Run Time, Call by Relative Path


*** Get Current Script's Name Programmatically

 #+BEGIN_SRC emacs-lisp
     ;; get the current elisp script's name at run time
     (or load-file-name buffer-file-name)
 #+END_SRC

 Explanation: If user ran your script by =eval-buffer=, then
 load-file-name's value would be nil. So, using both {load-file-name,
 =buffer-file-name= } is a good way to get the script name regardless
 whether the script is executed by load or eval buffer.

 If you want the directory, call =file-name-directory= on the result.

*** Get Full Path from Relative Path at Run Time

 If you have file A, that calls =load= to load a file at B, and B calls
 =load= on file C using a relative path, then Emacs will complain about
 unable to find C. Because, emacs does not switch current directory with
 =load=.

 The following function solves this problem.

 #+BEGIN_SRC emacs-lisp
     (defun xah-get-fullpath (@file-relative-path)
       "Return the full path of *file-relative-path, relative to caller's file location.

     Example: If you have this line
      (xah-get-fullpath \"../xyz.el\")
     in the file at
      /home/joe/emacs/emacs_lib.el
     then the return value is
      /home/joe/xyz.el
     Regardless how or where emacs_lib.el is called.

     This function solves 2 problems.

     ① If you have file A, that calls the `load' on a file at B, and B calls `load' on file C using a relative path, then Emacs will complain about unable to find C. Because, emacs does not switch current directory with `load'.

     To solve this problem, when your code only knows the relative path of another file C, you can use the variable `load-file-name' to get the current file's full path, then use that with the relative path to get a full path of the file you are interested.

     ② To know the current file's full path, emacs has 2 ways: `load-file-name' and `buffer-file-name'. If the file is loaded by `load', then `load-file-name' works but `buffer-file-name' doesn't. If the file is called by `eval-buffer', then `load-file-name' is nil. You want to be able to get the current file's full path regardless the file is run by `load' or interactively by `eval-buffer'."

       (concat (file-name-directory (or load-file-name buffer-file-name)) @file-relative-path)
     )
 #+END_SRC

 See also: [[file:elisp_library_system.html][What's the difference
 between load-file, load, require, autoload?]].

 --------------




 --------------
** Elisp: List


 Emacs Lisp's list datatype is known as linked list in computer science.

 Here's a high-level tutorial on how to use it.

*** Create List

 To create a list, write it like this =(list a b …)=.

 #+BEGIN_SRC emacs-lisp
     ; assign a list to a var
     (setq mylist (list 1 "b" 3))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ; prints a list
     (message "%S" mylist)
 #+END_SRC

 If you do not want the elements evaluated, write it like this:

 ='(a b …)=

 This is equivalent to

 =(quote (list a b …))=

 #+BEGIN_SRC emacs-lisp
     ; assign a list to a var
     (setq mylist '(a b c))

     ; prints a list
     (message "%S" mylist)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; create a list of values of variables
     (let ((x 3) (y 4) (z 5))
       (message "%S" (list x y z))
       ) ; prints "(3 4 5)"
 #+END_SRC

 =(make-list LENGTH INIT)= → create a list of length LENGTH, and all
 elements with value INIT.

 #+BEGIN_SRC emacs-lisp
     (make-list 4 0) ;; (0 0 0 0)
 #+END_SRC

*** Empty List, nil

 In elisp, empty list is equivalent to =nil=. The following are all
 equivalent.

 - ='()=
 - =(list)=
 - =nil=

 #+BEGIN_SRC emacs-lisp
     (eq '() (list ) ) ; t
     (eq '() nil); t
     (eq (list ) nil ) ; t
 #+END_SRC

*** List of Numbers (aka Range Function)

 =(number-sequence n m step)= → returns a list of a range of numbers,
 from n to m, in increment of step.

 =(number-sequence n m)= → default step 1.

 =(number-sequence n)= → returns a list of 1 element of value n.

 #+BEGIN_SRC emacs-lisp
     ;; creating a range of numbers

     ;; just 1 element
     (number-sequence 5) ; (5)

     ;; n to m, inclusive
     (number-sequence 2 5) ; (2 3 4 5)

     ;; using 3 as step
     (number-sequence 0 9 3) ; (0 3 6 9)

     ;; step can be negative
     (number-sequence 5 0 -1) ; (5 4 3 2 1 0)

     ;; boundaries can be float but will not include
     (number-sequence 2.2 5.3) ; (2.2 3.2 4.2 5.2)
 #+END_SRC

*** Length

 =(length list)= → return number of elements.

 #+BEGIN_SRC emacs-lisp
     (length '("a" "b" "c") ) ; 3
 #+END_SRC

*** Get 1 Element from a List

 - =(car list)= → first element
 - =(nth n list)= → nth element
 - =(car (last list))= → last element

 List index count starts from 0.

 #+BEGIN_SRC emacs-lisp
     (car (list "a" "b" "c") )   ; "a"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (nth 1 (list "a" "b" "c") ) ; "b"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (car (last (list "a" "b" "c")) )   ; "c"
 #+END_SRC

*** Get Sublist

 - =(cdr list)= → 2nd to last elements.
 - =(nthcdr n list)= → nth to last elements.
 - =(butlast list n)= → without the last n elements.

 #+BEGIN_SRC emacs-lisp
     (cdr (list "a" "b" "c") )   ; ("b" "c")
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (butlast (list "a" "b" "c" "d") )   ; ("a" "b" "c")
     (butlast (list "a" "b" "c" "d") 2)   ; ("a" "b")
 #+END_SRC

*** Prepend to list

 =(cons x list)= → Return a new list, with x added to front. (prepend)

 #+BEGIN_SRC emacs-lisp
     (cons "a" (list "c" "d") ) ; ("a" "c" "d")

     (cons (list "a" "b") (list "c" "d") ) ; (("a" "b") "c" "d")
 #+END_SRC

*** Append, Join Lists

 =(append sequence1 sequence2 …)= → join any sequence types and return a
 list. Warning: if you want it to return a propert list, the last element
 must be a list, or nil.

 #+BEGIN_SRC emacs-lisp
     (equal
      (list 1 2 3 4)
      (append (list 1 2) (list 3 4))
      )
     ;; t
 #+END_SRC

*** Modify List Variable

 - =(push list)= → Add a element to the front variable. Returns the new
   list.
 - =(pop list)= → Remove first element from the variable. Returns the
   removed element.
 - =(nbutlast list n)= → Remove last n elements from the variable.
   Returns the new value of the variable.
 - =(setcar list x)= → replaces the first element in list with x. Returns
   x.
 - =(setcdr list x)= → replaces the rest of elements in list with x.
   Returns x.

 #+BEGIN_SRC emacs-lisp
     (let ((x '(1)))
       (push 2 x)
       (equal x '(2 1)) ; true
       )
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (setq mylist '("a" "b" "c"))
     (pop mylist)   ; "a"
     (print mylist) ; ("b" "c")
 #+END_SRC

 The weird names {car, cdr, cons} are like that for historical reasons.

*** List to String

 Ways to convert a list to string.

 #+BEGIN_SRC emacs-lisp
     ;; convert a list to string
     (mapconcat 'number-to-string '(1 2 3) ",")
     ;; "1,2,3"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; convert a list to string
     (mapconcat 'identity '("a" "b" "c") ",")
     ;; "a,b,c"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; convert list to string

     (format "%s" '(1 "two" 3))
     ;; "(1 two 3)"

     (substring (format "%s" '(1 "two" 3)) 1 -1)
     ;; "1 two 3"
 #+END_SRC

*** Reference

 [[../emacs_manual/elisp/Lists.html][(info "(elisp) Lists")]]

 --------------




 --------------
** Elisp: Vector


 Emacs lisp vector datatype is similar to
 [[http://xahlee.info/java-a-day/arrays.html][Java's Array]].

 1. Vector is a ordered sequence of values.
 2. Each element can be any type.
 3. Element's value can be changed.
 4. Number of elements cannot change. (i.e. Vector's length is fixed.)
 5. Reading/Writing a element has constant random access time.

*** Create Vector

 =(make-vector 5 0)= → create a vector of length 5, value 0 for all
 elements.

 #+BEGIN_SRC emacs-lisp
     ;; create a vector of length 5, value 0 for all elements
     (make-vector 5 0) ;; [0 0 0 0 0]
 #+END_SRC

 =(vector a b …)= → create a vector with elements a b ....

 #+BEGIN_SRC emacs-lisp
     ;; create a vector and set to var v
     (setq v (vector 3 4 5))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (setq x 7)

     ;; each element will be evaluated
     (setq v (vector 3 x 5))

     v ; [3 7 5]
 #+END_SRC

 If you do not want the elements evaluated, write it like this:

 =[a b …]=

 #+BEGIN_SRC emacs-lisp
     (setq n 7)

     ;; create a vector of elements 3 n 5. each element is NOT evaluated
     (setq v [3 n 5])

     v ; [3 n 5]
     ;; the n remains a symbol, not 7
 #+END_SRC

*** Fill Vector

 =(fillarray array val)= → make all elements of array to have value val

 #+BEGIN_SRC emacs-lisp
     (setq aa [3 4 5])
     (fillarray aa nil) ;; [nil nil nil]
 #+END_SRC

*** Length

 #+BEGIN_SRC emacs-lisp
     (length (vector 7 4 5)) ; 3
 #+END_SRC

*** Get Element

 =(aref array n)= → Return the element of array at index n.

 =(elt sequence n)= → Return element of sequence at index n.

 When emacs doc mentions “ARRAY”, you can think of it as “vector or
 string”.

 When emacs doc mentions “SEQUENCE”, you can think of it as “list or
 array”.

 #+BEGIN_SRC emacs-lisp
     ;; get a element from vector
     (aref ["a" "b" "c"] 0) ; ⇒ "a"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; get a element from vector
     (elt ["a" "b" "c"] 0) ; ⇒ "a"
 #+END_SRC

**** What's the difference between =aref= and =elt=?

 =elt= is more general. It works on vector and list.

 But if you know it's vector, you should use =aref=, because it's precise
 and faster.

 [see [[file:elisp_list_vs_vector.html][Elisp: Sequence Type]]]

*** Change Element

 =(aset ARRAY IDX NEWELT)= → Store into the element of ARRAY at index IDX
 the value NEWELT. Return NEWELT.

 #+BEGIN_SRC emacs-lisp
     (setq v [3 4 5])
     (aset v 0 "b")
     v  ; ⇒ ["b" 4 5]
 #+END_SRC

*** Nested Vector

 Vector can be nested in any way, because the elements can be any type.

 #+BEGIN_SRC emacs-lisp
     ;; nested vector
     [[1 2] [3 4]] ; 2 by 2 matrix
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; random nested vector
     [8 [3 [2 9] c] 7 [4 "b"]]
 #+END_SRC

*** Join Vectors, Convert List to Vector

 =(vconcat sequence1 sequence2 …)= → join any sequence types and return a
 vector. (List and vector are both sequence types.)

 #+BEGIN_SRC emacs-lisp
     ;; join any sequence types
     (vconcat [3 4] ["a" "b"]) ; ⇒ [3 4 "a" "b"]

     (vconcat [3 4] '("a" "b")) ; ⇒ [3 4 "a" "b"]

     (vconcat [3 4] "ab") ; ⇒ [3 4 97 98]
     ;; string elements are converted to char.
     ;; 97 is the codepoint for the char a
 #+END_SRC

*** Convert Vector to List

 =(append sequence1 sequence2 …)= → join any sequence types and return a
 list. (List and vector are both sequence types.)

 Warning: if you want it to return a propert list, the last element must
 be a list, or nil.

 #+BEGIN_SRC emacs-lisp
     ;; convert vector to list
     (append [1 2 3] nil)
     ; ⇒ (1 2 3)

     (append [1 2 3] [4 5] )
     ;; (1 2 3 . [4 5])
     ;; this is improper list

     (append [1 2 3] [4 5] nil)
     ;; (1 2 3 4 5)
     ;; proper list

     (append [1 2 3] [4 5] '(6))
     ;; (1 2 3 4 5 6)
     ;; proper list
 #+END_SRC

*** Reference

 [[../emacs_manual/elisp/Vectors.html][(info "(elisp) Vectors")]]

 [[../emacs_manual/elisp/Vector-Functions.html][(info "(elisp) Vector
 Functions")]]

 --------------




 --------------
** Elisp: Sequence Type


 Here's a chart of elisp's most important list-like datatypes.

 [[file:feed_0/article_44/images/img1_u2.svg]]

 Most commonly used list-like data structure in elisp. (note: there's
 also char-table and bool-vector datatypes, which are sub-types of of
 array type. They are more specialized.)

 Note: “Sequence” and “Array” are not actual datatypes in elisp. They are
 grouping names for other actual datatypes.

 When a function's doc says that an argument is a sequence type, it means
 that it can be list, vector, or string. (e.g. =mapcar=)

 When a function's doc says an argument is a array type, it means that it
 can be vector, or string. (e.g. =aref=)

 List and Vector both hold a ordered sequence of values, each value can
 be any type.

*** Differences Between List and Vector

 Here's the primary differences between list and vector:

 - Vector, access time to any element is constant.
 - Vector's length cannot change. (if you create a new copy of a vector,
   the time required is proportional to the vector's length)
 - List, access time to a element is proportional to the distance of the
   element's position in the list.
 - List's length can grow by prepending element, and can shorten by
   removing first element. These operations have constant time.

 In short, list can grow or shorten, but if you have a long list, say 1
 thousand items, accessing 900th item is slow.

 Vector has fixed length. Accessing any element is fast.

*** Reference

 [[../emacs_manual/elisp/Sequences-Arrays-Vectors.html][(info "(elisp)
 Sequences Arrays Vectors")]]

 --------------




 --------------
** Elisp: Sequence Functions


 Here's a collection of functions that works on
 [[../emacs/elisp_list_vs_vector.html][Sequence type]].

 Note, this page does not include functions for
 [[file:elisp_association_list.html][Association List]] nor
 [[file:elisp_property_list.html][Property List]] .

*** Create List

 - =(number-sequence n m step)= → returns a list of a range of numbers,
   from n to m, in increment of step.

*** Get Element from List

 - =(car list)= → first element
 - =(cdr list)= → rest elements
 - =(nth n list)= → nth element
 - =(nthcdr N LIST)= → rest starting at n.
 - =(last LIST &optional N)= → last as a list. i.e. return
   =(cons lastElement nil)=. To get the actual last item of a list, do
   =(car (last list))=

*** Add to List

 - =(cons x list)= → Return a new list, with x added to left.
 - =(add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FN)=
 - =(add-to-ordered-list LIST-VAR ELEMENT &optional ORDER)=

*** Modify List Variable

 - =(push list)= → Add a element to the front variable. Returns the new
   list.
 - =(pop list)= → Remove first element from the variable. Returns the
   removed element.
 - =(nbutlast list n)= → Remove last n elements from the variable.
   Returns the new value of the variable.
 - =(setcar list x)= → replaces the first element in list with x. Returns
   x.
 - =(setcdr list x)= → replaces the rest of elements in list with x.
   Returns x.

*** List to Vector

 - =(vconcat sequence1 sequence2 …)= → join any sequence types and return
   a vector.

*** Sequence to List

 - =(append sequence1 sequence2 …)= → join any sequence types and return
   a list. Warning: if you want it to return a propert list, the last
   element must be a list, or nil.

*** Sequence to String

 - =(format "%s" sequence)=

*** Sequence Functions

 These functions work on any sequence type. (list,vector, string).

 Those starting with “seq-” are new in emacs 25.1, released in 2016-09.
 They are from “seq.el”, and the file is loaded when emacs starts. You
 may want to explicitly declare =(require 'seq)=.

 Some of these provide new functionalities, some gives a unified
 interface to old functions.

 - =length=
 - =sequencep=
 - =elt=
 - =copy-sequence=
 - =reverse=
 - =nreverse=
 - =sort=
 - =seq-elt=
 - =seq-length=
 - =seqp=
 - =seq-drop=
 - =seq-take=
 - =seq-take-while=
 - =seq-drop-while=
 - =seq-do=
 - =seq-map=
 - =seq-mapn=
 - =seq-filter=
 - =seq-remove=
 - =seq-reduce=
 - =seq-some=
 - =seq-find=
 - =seq-every-p=
 - =seq-empty-p=
 - =seq-count=
 - =seq-sort=
 - =seq-contains=
 - =seq-position=
 - =seq-uniq=
 - =seq-subseq=
 - =seq-concatenate=
 - =seq-mapcat=
 - =seq-partition=
 - =seq-intersection=
 - =seq-difference=
 - =seq-group-by=
 - =seq-into=
 - =seq-min=
 - =seq-max=
 - =seq-doseq=
 - =seq-let=

*** Check Existence

 =(member x list)= → check if x is in list. If so, return a list starting
 with the first occurrence of object. Else return =nil=. Comparison done
 using =equal=.

 =(memq x list)= → same as =member=, but comparison done using =eq=.

 =(memql x list)= → same as =member=, but comparison done using =eql=.

 #+BEGIN_SRC emacs-lisp
     (member "4" '("3" "4" "5")) ;; ("4" "5")
 #+END_SRC

 Note: =(eq "s" "s")= is false, and =(eq 1.2 1.2)= also false.

 (The difference of =eq= and =eql= is that the latter will return t for
 same floating point numbers.)

 =(member-ignore-case x list)= → same as =member=, except that x should
 be a string, and comparison ignores letter-case.

 #+BEGIN_SRC emacs-lisp
     (member-ignore-case "A" '("b" "a")) ; ("a")
 #+END_SRC

*** Delete All X in Sequence

 =(delete x sequence)= → remove all x in sequence. The original sequence
 is destroyed. Returns a new sequence. The comparison is done with
 =equal=.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(3 4 5))

     ;; always set result to the same var. because original is usually destroyed
     (setq xx (delete 4 xx)) ; (3 5)

     ;; on vector
     (setq xx [3 4 5])
     (setq xx (delete 4 xx)) ; [3 5]
 #+END_SRC

 =(remove x sequence)= → same as =delete=, except sequence is not
 destroyed.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(3 4 5))
     (remove 4 xx) ;; (3 5)
     xx ; (3 4 5)
 #+END_SRC

 =(delq x sequence)= → Same as =delete=, except the comparison is done
 with =eq=.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(3 4 5))

     ;; always set result to the same var
     (setq xx (delq 4 xx)) ; (3 5)
 #+END_SRC

 =(remq x list)= → same as =delq=, except it does not destroy the
 original list.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(3 4 5))
     (remq 4 xx) ; (3 5)
     xx ; (3 4 5)
 #+END_SRC

*** Delete Duplicates

 =(delete-dups list)= → This function destructively removes all
 duplicates from list, return a new list. The first one is kept among
 duplicates.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(3 4 5 3 2))
     (setq xx (delete-dups xx)) ; (3 4 5 2)
 #+END_SRC

*** Misc

 - =nconc=

*** Reference

 [[../emacs_manual/elisp/Sequence-Functions.html][(info "(elisp) Sequence
 Functions")]]

 See also: [[../emacs_manual/elisp/Sets-And-Lists.html][(info "(elisp)
 Sets And Lists")]]

 --------------




 --------------
** Elisp: Map List/Vector


*** Map: mapcar

 Typical way to go thru a [[file:elisp_list_vs_vector.html][Sequence]] is
 using =mapcar=. Note that it returns a list, even if input is a vector.

 =(mapcar FUNCTION SEQUENCE)= → Apply FUNCTION to each element of
 SEQUENCE, and make a list of the results. The result is a list, with
 same length as SEQUENCE. SEQUENCE may be a list, a vector, a
 bool-vector, or a string.

 #+BEGIN_SRC emacs-lisp
     ;; add 1 to each vector element
     (mapcar '1+ [3 4 5] ) ; (4 5 6)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; add one to each list element
     (mapcar '1+ '(3 4 5)) ; (4 5 6)
 #+END_SRC

 =1+= is a lisp function. It adds 1 to argument and returns it. For
 example, =(1+ 2)= returns 3.

 To use a function in =mapcar=, you need to quote the function's name.

 =1+= is a function, so we quote it and have ='1+= or =(quote 1+)=

 Here's another example.

 #+BEGIN_SRC emacs-lisp
     ; take the 1st element of each
     (mapcar 'car '((1 2) (3 4) (5 6))) ; (1 3 5)
 #+END_SRC

*** mapcar with lambda

 mapcar is most commonly used with lambda. Here's a example:

 #+BEGIN_SRC emacs-lisp
     ;; get first element of each row
     (mapcar
      (lambda (x) (elt x 0))
      [[1 2] [3 4]] ) ; ⇒ (1 3)
 #+END_SRC

 =lambda= means function, often known as “anonymous function”. It let you
 define a function in the middle of your code.

 The form is =(lambda (args) body)=.

 For example, =(lambda (x y) (+ x y))= is a function that takes two
 arguments, x and y, and returns their sum.

 More examples with lambda:

 #+BEGIN_SRC emacs-lisp
     ; add one to each list member
     (mapcar
      (lambda (x) (+ x 1))
      (list 1 2 3 4)
     ) ; (2 3 4 5)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; take the 2nd element of each
     (mapcar (lambda (x) (nth 1 x))
             '((1 2) (3 4) (5 6))) ; (2 4 6)
 #+END_SRC

*** mapc (foreach)

 If you don't need map to return the sequence, use =mapc=.

 =mapc= → like =mapcar=, but returns nil.

 #+BEGIN_SRC emacs-lisp
     ;; apply a file processing function to a list of files
     (mapc 'my-update-html-footer
           (list
            "~/file1.html"
            "~/file2.html"
            "~/file3.html"
            ))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; example of mapc on vector
     (mapc
      (lambda (x)
        (insert (number-to-string (aref x 0))))
      [[1 2] [3 4]] )

     ;; insert first element of each row into buffer
     ;; (it inserts 13)
     ;; returns nil
 #+END_SRC

*** dolist

 =(dolist (VAR LIST) BODY)= → Loop over a list. Evaluate BODY with VAR
 bound to each element from LIST, returns nil.

 =(dolist (VAR LIST RESULT) BODY)= → returns RESULT.

 #+BEGIN_SRC emacs-lisp
     (let (
           (xlist (number-sequence 97 122)) ;; list 97 to 122
           )
       (dolist (n xlist) (insert n)))

     ;; inserts
     ;; abcdefghijklmnopqrstuvwxyz
 #+END_SRC

 The major difference between =dolist= and =mapc= is that =dolist= uses
 expression, =mapc= uses a function. Also, =dolist= work with list only,
 =mapc= works with list and vectors.

*** dotimes

 =dotimes= is useful when you want to go thru a list by a increasing
 index.

 =(dotimes (VAR COUNT) BODY …)= → Loop a certain number of times.
 Evaluate BODY with VAR bound to successive integers running from 0,
 inclusive, to COUNT, exclusive. Returns nil

 =(dotimes (VAR COUNT RESULT) BODY …)= → After loop, evaluate RESULT to
 get the return value.

 #+BEGIN_SRC emacs-lisp
     (dotimes (i 4)
       (insert (number-to-string i)))
     ;; inserts "0123", returns nil
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (let ((v [3 4 5]))
       (dotimes (i (length v))
         (insert
          (number-to-string
           (elt v i))))) ; inserts 345
 #+END_SRC

*** while Loop

 Another common form to loop thru a list is using the =while= function.
 In each iteration, =pop= is used to reduce the list.

 #+BEGIN_SRC emacs-lisp
     (let ((mylist '(a b c)))
       (while mylist
         (message "%s" (pop mylist))
         (sleep-for 1)))
 #+END_SRC

 Example with vector:

 #+BEGIN_SRC emacs-lisp
     (setq v [3 4 5])
     (setq i 0)

     (while (< i (length v))
       (insert (format "%d" (elt v i)))
       (setq i (1+ i))) ; inserts "345"
 #+END_SRC

*** Exit Loop/Function, catch/throw

 [[file:elisp_break_loop.html][Elisp: throw, catch]]

 --------------


 <<index.html>>


 --------------
** Elisp: throw, catch


 To exit a loop or exit a function:

 - Use =catch= and =throw= to exit loop/function. These are like “break”,
   “goto” in other programing languages.
 - Use =error= or =user-error= to signal a error and exit.

*** Exit a Function

 To exit a function, put

 =throw 'tagname value=

 at the place you want to exit, and wrap your function body with a

 =catch 'tagname=

 for the target exit position.

 Here's example.

 #+BEGIN_SRC emacs-lisp
     (defun test-exit-f ()
       "example. using catch/throw to exit function"
       (interactive)
       (catch 'aaa
         (if (y-or-n-p "exit?")
             (progn
               (message "existing")
               (throw 'aaa 3) ; if yes, exit right away, return 3 to catch
               )
           (progn ; else, go on
             (message "went on")
             4 ; return 4
             ))))
 #+END_SRC

*** Exit by Error

 You can exit by calling =error= or =user-error= .

 #+BEGIN_SRC emacs-lisp
     (defun test-exit-f ()
       "example"
       (interactive)
       (if (y-or-n-p "invoke user-error to exit?")
           (user-error "Error, because: %s" "you said so!")
         (progn ; else, go on
           (message "went on")
           )))
 #+END_SRC

*** Exit a map

 You can also use =throw= and =catch= to exit a map or loop.

 =(catch 'tagname body)= → evaluates body and return body's last
 expression, but if body contains =(throw …)= and it is called, return
 the value throw passes.

 =(throw tagName passValue)= → jump to a outer =(catch 'tagName)= and
 continue there, passing the value of passValue to it. Both tagName
 passValue are evaluated.

 #+BEGIN_SRC emacs-lisp
     (setq myList [0 1 2 3 4 5])

     ;; map lambda onto a list. If value 3 is found, return 3, else nil
     (catch 'bbb
       (mapc
        (lambda (x)
          (message "%s" x)
          (when (equal x 3) (throw 'bbb x)))
        myList)
       nil
       )
 #+END_SRC

 [[../emacs_manual/elisp/Catch-and-Throw.html][(info "(elisp) Catch and
 Throw")]]

*** Exit a While Loop by Flag

 Here's a sample of setting flag:

 #+BEGIN_SRC emacs-lisp
     (let ((myList [0 1 2 3 4 5] )
           (foundFlag-p nil )
           (i 0))

       (while (and
               (not foundFlag-p)
               (<= i (length myList)))

         ;; if found, set foundFlag-p
         (when (equal (elt myList i) 3)
           (setq foundFlag-p t ))

         (message "value: %s" i)
         (setq i (1+ i))))
 #+END_SRC

 --------------




 --------------
** Elisp: Association List


 Associative List (aka “alist”) is a value type in Emacs Lisp.

 Alist is a list, where each element is a cons pair, like this
 =(cons key value)=.

 Note: =(cons a b)= can also be written as =(a . b)=.

 In each cons pair, the key and value can be any value type.

 Items in alist can have duplicate keys, and order is maintained.

 If you have more than a thousand items, and need fast random access,
 better is to use [[file:elisp_hash_table.html][Hash Table]] .

**** What's the Difference Between Alist and Hash Table?

 - Alist is ordered.
 - Alist can have duplicate keys.
 - Hash Table keys are unique.
 - Hash Table items are not ordered.
 - Hash Table is faster for random access when there are huge number of
   items (over thousands).

*** Create a Alist

 #+BEGIN_SRC emacs-lisp
     ;; set x to a alist
     (setq x
           '(("mary" . 23)
             ("john" . 24)
             ("smith" . 33)))
 #+END_SRC

 Note, alist is a [[file:elisp_list.html][List]] , any function that
 works on list also works on alist.

 [see [[file:elisp_sequence_functions.html][Elisp: Sequence Functions]]]

*** Alist Functions

 Here's the most useful functions designed for working with alist.

**** Get Pair by Key

 =assoc=

 =(assoc key alist)= → Return the first found pair with the key. If key
 do not exist, return =nil=. (key existence is checked by =equal=.)

 #+BEGIN_SRC emacs-lisp
     ;; set x to a alist
     (setq x
           '(("mary" . 23)
             ("john" . 24)
             ("smith" . 33)))

     ;; get the pair with key "john"
     (assoc "john" x)
     ; returns ("john" . 24)
 #+END_SRC

 After you got the cons pair, you can use =car= to get the first element,
 and use =cdr= to get the last element.

 #+BEGIN_SRC emacs-lisp
     ;; set x to a alist
     (setq x
           '(("mary" . 23)
             ("john" . 24)
             ("smith" . 33)))

     ;; get the value with key "john"
     (cdr (assoc "john" x))
     ; returns 24
 #+END_SRC

**** Get Pair by Value

 You can search alist by value.

 =rassq=

 =(rassq value alist)= → return the first association with value value in
 alist. It returns =nil= if no association in alist has a CDR =eq= to
 value.

 #+BEGIN_SRC emacs-lisp
     ;; set x to a alist
     (setq x
           '(("mary" . 23)
             ("john" . 24)
             ("smith" . 33)))

     ;; get the pair with value 24
     (rassoc 24 x)
     ; returns ("john" . 24)
 #+END_SRC

*** More Alist Functions

 [[../emacs_manual/elisp/Association-Lists.html][(info "(elisp)
 Association Lists")]]

 --------------




 --------------
** Elisp: Property List


*** What's Property List

 Property list (in short, plist) is a list, but to be interpreted as list
 of pairs, like this:

 ='(key1 val1 key2 val2 …)=

 Property list is not supposed to have duplicate keys, and should always
 have even length.

 Key should be lisp symbols, value can be any lisp object.

 [[../emacs_manual/elisp/Property-Lists.html][(info "(elisp) Property
 Lists")]]

*** Use of Property List

 Property List is used as a simplest form of key/value pairs.

 Property list is used extensively in emacs.

 The 2 major use of property list are:

 - Symbol's property list. Each symbol, is associated with a property
   list. Used primarily to store info related to the symbol, such as
   compiler info, but can be anything. [see
   [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]
 - Text Properties. Any character or string in a buffer, can have a
   property list, used to store syntax color info, special keyboard
   shortcut, etc. [see [[file:elisp_text_properties.html][Elisp: Text
   Properties]]]

 Property list isn't a generic data structure. If you have more than 100
 items, you probably should use Association List instead. [see
 [[file:elisp_association_list.html][Elisp: Association List]]]

*** Get a Key's Value

 =(plist-get= PLIST PROP) → return the value of key PROP from property
 list PLIST. If key does not exist, return =nil=. Existence of key is
 checked with =eq=.

 =lax-plist-get= → similar to =plist-get=, but compare key using =equal=.

 #+BEGIN_SRC emacs-lisp
     (plist-get '(x 1 y 2) 'y) ; 2
     (plist-get '(x 1 y 2) 'b) ; nil
 #+END_SRC

*** Add/Modify item

 =(plist-put= PLIST PROP VAL) → add or change the value of key PROP in
 PLIST to VAL. The new plist is returned. Use
 =(setq x (plist-put x prop val))= to be sure to use the new value.
 Existence of key is checked with =eq=.

 =lax-plist-put= → similar to =plist-put=, but compare key using =equal=.

 #+BEGIN_SRC emacs-lisp
     ;; create a property list xx
     (setq xx '(a 1 b 2))

     ;; set value to a existing key
     (setq xx (plist-put xx 'b 3))

     xx
     ;; (a 1 b 3)
 #+END_SRC

*** Check Key Existence

 =(plist-member= PLIST PROP) → Return true if PLIST has the property
 PROP. . PROP is a symbol. Unlike =plist-get=, this allows you to
 distinguish between a missing property and a property with the value
 =nil=. The value is actually the tail of PLIST whose car is PROP.

 #+BEGIN_SRC emacs-lisp
     (setq xx '(a 1 b 2))

     ;; check if a key exist
     (plist-member xx 'b)
     ;; (b 2)
 #+END_SRC

 [[../emacs_manual/elisp/Plist-Access.html][(info "(elisp) Plist
 Access")]]

*** Symbol's Property List

 Each elisp symbol, can be attached a property list. Such is called
 “*symbol plist*”.

 [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]

*** Text Properties

 Text in a buffer region can be attached a property list. Such is called
 “*Text Properties*”.

 [[file:elisp_text_properties.html][Elisp: Text Properties]]

 --------------




 --------------
** Elisp: Symbol Property List


 Each lisp symbol is associated with a “property list”.

 [see [[file:elisp_property_list.html][Elisp: Property List]]]

 This property list is stored in the symbol's property list cell. [see
 [[file:elisp_symbol.html][Elisp: Lisp Symbol]]]

 Emacs lisp property list is used extensively in emacs. It is also very
 useful if you want to write a function with state. You can store the
 state info with the symbol itself, instead of using a global variable.

*** Set Whole Plist

 (=setplist= SYMBOL NEWPLIST) → Set SYMBOL's property list to NEWPLIST,
 and return NEWPLIST.

 #+BEGIN_SRC emacs-lisp
     ;; set the value of symbol ff's property list
     (setplist 'ff '(a 1 b 2))
 #+END_SRC

*** Get Whole Plist

 =(symbol-plist= SYMBOL) → Return SYMBOL's property list.

 #+BEGIN_SRC emacs-lisp
     ;; get the value of symbol ff's property list
     (symbol-plist 'ff )
 #+END_SRC

*** Add/Set a Key's Value

 (=put= SYMBOL PROPNAME VALUE) → Store SYMBOL's PROPNAME property with
 value VALUE.

 #+BEGIN_SRC emacs-lisp
     ;; set the value of key xx, of symbol ff's property list
     (put 'ff 'xx 5)
 #+END_SRC

*** Get a Key's Value

 (=get= SYMBOL PROPNAME) → Return the value of SYMBOL's PROPNAME
 property.

 #+BEGIN_SRC emacs-lisp
     ;; get the value of key xx, of symbol ff's property list
     (get 'ff 'xx)
 #+END_SRC

*** Reference

 [[../emacs_manual/elisp/Symbol-Properties.html][(info "(elisp) Symbol
 Properties")]]

*** Example of Using Symbol Properties

 [[file:elisp_toggle_command.html][Elisp: How to Write a Toggle Command]]

 --------------




 --------------
** Elisp: Hash Table


 Emacs lisp has 2 types of collection of key/value pairs.

 - [[file:elisp_association_list.html][Association List]] (aka alist). →
   a ordered list of key val pairs. Keys may repeat.
 - Hash Table. → unordered set of key val pairs. No duplicate keys.
   Constant access time.

*** Create Hash Table

 =(make-hash-table :test 'equal)= → returns a new hashtable.

 #+BEGIN_SRC emacs-lisp
     ;; create a hash table
     (setq myHash (make-hash-table :test 'equal))
 #+END_SRC

 The =:test 'equal= is to specify what function to use to test key
 existence. For example, if your keys are integers or lisp symbols, you
 can use =:test eq=. If your keys are strings, you must use
 =:test equal=, because =(eq "x" "x")= returns =nil=.

 Key or Value can be any lisp object (aka datatype).

 There are more options for =make-hash-table=. Alt+x =describe-function=
 for detail.

*** Literal Expression for Hashtable

 You can create a hash table by a literal expression, like this:

 #+BEGIN_SRC emacs-lisp
     (setq myHash
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))

     ;; test
     (gethash "joe" myHash ) ; 3
 #+END_SRC

 [[../emacs_manual/elisp/Creating-Hash.html][(info "(elisp) Creating
 Hash")]]

*** Add Entry

 #+BEGIN_SRC emacs-lisp
     (puthash "joe" 19 myHash)
 #+END_SRC

*** Remove Entry

 #+BEGIN_SRC emacs-lisp
     (remhash "liz" myHash)
 #+END_SRC

*** Get Key's Value

 #+BEGIN_SRC emacs-lisp
     (gethash "jane" myHash)
 #+END_SRC

*** Number of Entries

 #+BEGIN_SRC emacs-lisp
     (hash-table-count myHash)
 #+END_SRC

*** Remove All Entries

 #+BEGIN_SRC emacs-lisp
     (clrhash myHash)
 #+END_SRC

*** Check Key Exist

 =gethash=

 - =(gethash key table)= → check if a key exist. If so, return the value.
   Else, return =nil=
 - =(gethash key table default)= → return default if key does not exist.

 #+BEGIN_SRC emacs-lisp
     (let ((myHash (make-hash-table :test 'equal)))
       (puthash 'aa 9 myHash)
       (gethash 'bb myHash)    ; ⇒ nil
       (gethash 'bb myHash 10) ; ⇒ 10
       )
 #+END_SRC

*** Apply a Function to All Entries

 =maphash=

 =(maphash myfun myHashtable)= → apply a function to all entries in a
 hash table. The function myfun must take 2 arguments, key and value.

 #+BEGIN_SRC emacs-lisp
     (setq myHash (make-hash-table :test 'equal))
     (puthash "joe" 19 myHash)
     (puthash "jane" 20 myHash)
     (puthash "carrie" 17 myHash)
     (puthash "liz" 21 myHash)

     (maphash
        (lambda (k v)
          (princ (format "%s , %s" k v))
          (princ "\n"))
        myHash
        )
 #+END_SRC

*** Get All Keys

 =hash-table-keys=

 =(require 'subr-x) (hash-table-keys hash) =

 new in emacs 24.4

 #+BEGIN_SRC emacs-lisp
     ;; get all keys from a hash table

     (setq myHash
           #s(hash-table
              size 30
              test equal
              data (
                    "joe" 3
                    "jane" 9
                    "liz" 5 )))

     ;; get all keys
     (require 'subr-x)
     (hash-table-keys myHash) ; ("joe" "jane" "liz")
 #+END_SRC

*** Get All Values

 =hash-table-values=

 =(require 'subr-x) (hash-table-values hash) =

 new in emacs 24.4

 #+BEGIN_SRC emacs-lisp
     ;; getting all keys from a hash table.

     ;; creating a hash
     (setq myHash (make-hash-table :test 'equal))
     (puthash "joe" "19" myHash)
     (puthash "jane" "20" myHash)

     ;; get all keys.
     (require 'subr-x)          ; emacs 24.4
     (hash-table-values myHash) ; ⇒ ("20" "19")
 #+END_SRC

*** Hash to List

 #+BEGIN_SRC emacs-lisp
     (defun xah-hash-to-list (@hash-table)
       "Return a list that represent the @HASH-TABLE
     Each element is a list: '(key value).

     Version 2019-06-11"
       (let ($result)
         (maphash
          (lambda (k v)
            (push (list k v) $result))
          @hash-table)
         $result))
 #+END_SRC

*** Print Hashtable

 #+BEGIN_SRC emacs-lisp
     (print myHash)

     ;; sample output
     ;; #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data ("joe" 19 "jane" 16 "carrie" 17 ...))
 #+END_SRC

 Here's a pretty print function:

 #+BEGIN_SRC emacs-lisp
     (defun my-print-hash (hashtable)
       "Prints the hashtable, each line is key, val"
       (maphash
        (lambda (k v)
          (princ (format "%s , %s" k v))
          (princ "\n"))
        hashtable
        ))

     ;; test

     (setq myHash (make-hash-table :test 'equal))
     (puthash "joe" 19 myHash)
     (puthash "jane" 20 myHash)
     (puthash "carrie" 17 myHash)
     (puthash "liz" 21 myHash)

     (my-print-hash myHash)
 #+END_SRC

*** Sort Hash

 To sort, first change it to a list.

 #+BEGIN_SRC emacs-lisp
     (setq myHash (make-hash-table :test 'equal))
     (puthash "joe" 19 myHash)
     (puthash "jane" 20 myHash)
     (puthash "carrie" 17 myHash)
     (puthash "liz" 21 myHash)

     ;; get the hash table into a list
     (setq myList (xah-hash-to-list myHash))

     (setq myList (sort myList (lambda (a b) (string< (car a) (car b)))))

     (print myList)
 #+END_SRC

 Warning: elisp's =sort= function is destructive. Once =sort= is used on
 a variable, that variable's value is essentially destroyed. (the sorted
 result is returned.) If you want to keep the variable, make a copy
 first.

 [[../emacs_manual/elisp/Rearrangement.html][(info "(elisp)
 Rearrangement")]]

 [[../emacs_manual/elisp/Hash-Tables.html][(info "(elisp) Hash Tables")]]

 --------------




 --------------
** Elisp: Lisp Symbol


 Lisp has symbols concept. Lisp's concept of “symbols” is somewhat like
 identifiers in other languages, except that:

 - lisp symbol can be held unevaluated, simply as itself, a inert name.
   In this sense, it's like a string.
 - lisp symbol stores more than one value.

*** The Concept of Symbols in Lisp

 LISP differs from most programing languages such as C, Java, Ruby,
 Python, in that it deals with symbols, as opposed to just identifiers
 and values.

 For example, in most languages, once you defined =x=3=, you cannot
 manipulate the variable “x” because it gets evaluated to 3 right away.
 If you want, you have to build a string ="x"= and manipulate this
 string, then use =eval(lots string join here)= to achieve the effect.
 (for example, you have a variable x, and it has integer 3 as value. you
 want to rename the variable so the new name is var_name + var_value.)

 In lisp, after =(setq x 3)= then =x= would evaluate to 3, but
 =(quote x)= evaluates to the symbol x itself.

 In practice, having a language dealing with “symbols” directly means
 that transformation of expressions in source code is possible at
 run-time. (In lisp, this is the lisp macro feature, which is a limited
 form of term rewriting languages such as Wolfram Language.)
 [[../emacs_manual/elisp/Macros.html][(info "(elisp) Macros")]]

*** Symbol's Cells

 Each lisp symbol has the following “cells” to store things:

 - “*print name*” cell → a string, the same as the symbol. Automatically
   set, cannot be changed.
 - “*value*” cell → stores the symbol's value. When value cell is not
   void, the symbol is considered as a variable.
 - “*function*” cell → stores function definition object, lisp macros, or
   other objects that can act as function.
 - “*property list*” cell → hold a list of name/value pairs. Used for
   storing meta info about the symbol, such as function state, font face
   spec (for syntax coloring), deprecation flag, etc.

 A symbol's value cell or function cell may be empty. If so, it's said to
 be “void”. When you try to get a cell's value that's void, it's a lisp
 error. (a empty cell is not the same as having value of =nil=.)

 Normally, you don't need to worry about any of these tech details. The
 only thing that's useful for most elisp code is property list.

 [see [[file:elisp_property_list.html][Elisp: Property List]]]

 [see [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]

 Understanding Lisp Symbol is important when you do advanced lisp
 programing. For example: macros, create and call functions at run-time,
 nested functions, manipulate evaluation, implementing a language, or any
 sort of meta-programing. If you don't have a need, you should not
 exploit these facilities in your program. Keep your code simple.

 [[../emacs_manual/elisp/Symbols.html][(info "(elisp) Symbols")]]

*** Quoting Symbol

 A symbol, typically gets evaluated to its value. But you can stop this,
 by =quote=. e.g. =(quote x)=. You can think of =quote= as “hold
 evaluation”.

 =quote= has a shortcut syntax.

 =(quote x)= is syntactically equivalent to ='x=

 [[../emacs_manual/elisp/Quoting.html][(info "(elisp) Quoting")]]

*** When to Quote Symbol?

 Some functions, automatically quote the argument for you, as a
 convenience.

 For example, =setq= always automatically quotes its first argument.
 Because you basically always want the argument passed as a symbol. So,
 you write =(setq x 3)= instead of =(set 'x 3)=.

 The function =set= is almost the same as =setq=, except that =set= does
 not automatically quote the first argument. So, you write =(set 'x 3)=.
 [[../emacs_manual/elisp/Setting-Variables.html][(info "(elisp) Setting
 Variables")]]

 Some functions, require you to quote the argument yourself. Because
 sometimes you want a symbol's value passed, and sometimes the symbol
 itself.

 For example, =mapcar='s arguments are not automatically quoted. You may
 or may not want to quote them, depending on your use.

 Here's two examples of using mapcar, where in one example we want to
 quote the argument, and in the other example we do not want to quote the
 argument.

 #+BEGIN_SRC emacs-lisp
     ;; suppose we have many functions
     (setq f '1+)
     (setq f 'cos)
     (setq f 'sqrt)
     ;; we use f as a wrapper because we are not sure which function we want until run time

     ;; here's our data
     (setq mylist '(1 2 3))

     ;; normally, when using mapcar, we want first arg quoted
     (mapcar '1+ mylist) ; (2 3 4)

     ;; here, we don't want first arg quoted
     (mapcar f mylist) ; (1.0 1.4142135623730951 1.7320508075688772)
 #+END_SRC

*** Check If a Value is Symbol

 #+BEGIN_SRC emacs-lisp
     ;; check if a variable eval to a lisp symbol

     ;; make symbol x1's value cell to be 123
     (setq x1 123 )

     (symbolp x1) ; nil
     ;; nil, because x1 is evaluated, and that value is 123, not a symbol

     (symbolp 'x1) ; t
 #+END_SRC

*** Get Value of Symbol's Cells

 Here's how to get various cell's values.

 Here's a example of getting cell values, with symbol “sin” (=sin= is a
 builtin math function).

 #+BEGIN_SRC emacs-lisp
     ;; get symbol's name cell value
     (symbol-name 'sin) ; "sin"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; get symbol's value cell value
     (symbol-value 'sin) ; void-variable error
     ;; because the value cell of the symbol sin is void
     ;; or, we just say that sin isn't a variable
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; get symbol's function cell value
     (symbol-function 'sin) ;#<subr sin>
     ;; the value is a primitive function (written in C), and has print form of #<subr sin>
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; get symbol's property list cell value
     (symbol-plist 'sin) ; (side-effect-free t)
 #+END_SRC

 Here's another example with a user defined symbol.

 #+BEGIN_SRC emacs-lisp
     ;; get symbol cell values

     ;; this makes symbol x1's value cell to contain the number 3
     (setq x1 3) ; 3

     ;; get symbol's name cell value
     (symbol-name 'x1) ; "x1"

     ;; get symbol's value cell value
     (symbol-value 'x1) ; 3

     ;; get symbol's function cell value
     (symbol-function 'x1) ; nil
     ;; in emacs 24.3.1, this is a void-function error
     ;; in emacs 25.1, this returns nil
     ;; elisp manual 24 and 25.1  say it should be error

     ;; get symbol's property list cell value
     (symbol-plist 'x1) ;nil
 #+END_SRC

*** Set Symbol's Name Cell

 Symbol's name cell is automatically set, as a string of the symbol name.
 Symbol name cell cannot be changed.

*** Set Symbol's Value Cell

 The normal way to set a symbol's value cell is using =setq=.

 #+BEGIN_SRC emacs-lisp
     ;; set a symbol's value cell
     (setq y "yes yes")

     ;; get it
     (symbol-value 'y) ; "yes yes"
 #+END_SRC

 [[../emacs_manual/elisp/Setting-Variables.html][(info "(elisp) Setting
 Variables")]]

 You can also check if a symbol's value cell is not empty, by =boundp=.
 (we think of it as checking if a variable is defined.)

 #+BEGIN_SRC emacs-lisp
     (boundp 'h) ; nil

     (setq h 4)

     (boundp 'h) ; t
 #+END_SRC

*** Set Symbol's Function Cell

 The normal way to set a symbol's function cell is using =defun= or
 =defmacro=.

 #+BEGIN_SRC emacs-lisp
     ;; a function that returns 4
     (defun z () 4)
     ;; Note: return value of defun is not defined

     ;; get a symbol's function cell value
     (symbol-function 'z) ; (lambda nil 4)
 #+END_SRC

 [[../emacs_manual/elisp/Defining-Functions.html][(info "(elisp) Defining
 Functions")]]

 [[../emacs_manual/elisp/Function-Cells.html][(info "(elisp) Function
 Cells")]]

 You can check if a symbol's function cell is not empty, by =fboundp=.

 #+BEGIN_SRC emacs-lisp
     (fboundp 'f) ; nil

     ;; define a function that return 3
     (defun f () 3)

     ;; now the fuction cell is filled
     (fboundp 'f) ; t
 #+END_SRC

 Because a symbol can both hold a value and a function, a symbol can be
 both a variable and function. For example, the symbol =buffer-file-name=
 is both a variable and function. (you can try =describe-function= and
 =describe-variable= on it.)

*** Set Symbol's Property List Cell

 [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]

*** Convert Symbol to String

 #+BEGIN_SRC emacs-lisp
     ;; convert a symbol to string
     (symbol-name 'defun)
 #+END_SRC

*** Convert String to Symbol

 #+BEGIN_SRC emacs-lisp
     ;; convert a string to symbol

     ;; if the symbol does not already exist in obarray, create it, put it in obarray
     (intern "x")

     ;; if the symbol does not already exist in obarray, return nil
     (intern-soft "x")
 #+END_SRC

 --------------




 --------------
** Elisp: Lisp Special Form


 Normally, arguments passed to a function are evaluated, in order. In
 elisp, this is called *standard evaluation strategy*.

 However, for some function, evaluating arguments in order does not make
 sense. For example, conditional construct =if=, or local variable
 construct =let=. These functions, are said to have *non-standard
 evaluation strategy*.

 Of functions that are non-standard evaluation, they are either *macro*
 or *special form*.

 Macros are defined by lisp expressions with =defmacro=. User can define
 them.

 Special Forms are written in C.

 Example of special forms:

 1.  =and=
 2.  =or=
 3.  =catch=
 4.  =if=
 5.  =while=
 6.  =cond=
 7.  =condition-case=
 8.  =defconst=
 9.  =defvar=
 10. =let=
 11. =let*=
 12. =prog1=
 13. =prog2=
 14. =progn=
 15. =setq=
 16. =setq-default=
 17. =interactive=
 18. =lambda=
 19. =quote=
 20. =function=
 21. =save-current-buffer=
 22. =save-excursion=
 23. =save-restriction=
 24. =track-mouse=
 25. =unwind-protect=

 [[../emacs_manual/elisp/Macros.html][(info "(elisp) Macros")]]

 [[../emacs_manual/elisp/Special-Forms.html][(info "(elisp) Special
 Forms")]]

 --------------




 --------------
** Elisp: What's Function


 Emacs Lisp manual uses the following terms to distinguish different
 behavior of functions. For advanced lisp programing, you need to
 understand them.

 1. *lambda expression* → Anonymous function. Usually temp functions.
    Usually created by =lambda=.
 2. *Primitive* → (aka subr, builtin function.) elisp function
    implemented in C. For example: {=list=, =car=, =append=, =point=, ,
    ...}. Typically the most fundamental ones.
 3. *special form* → a function that doesn't eval in the normal way and
    implemented in C. For example: {=if=, =cond=, =and=, =or=, =while=,
    =progn=}. (normally, arguments to a function are all evaluated
    first.)
 4. *macro* → Similar to “special form”, but defined by lisp expression,
    by =defmacro=. i.e. the arguments are not eval'd, and you can
    manipulate them and eval them.
 5. *command* → functions that can be called by =command-execute=.
    Typically, =defun= with =interactive= clause. All functions you can
    call by “M-x” are commands.
 6. *Function* → The catch all. Lambda expression, primitive, special
    form, macro, command, are all functions. And a function not any of
    the above is also a function. Usually created by =defun=.

 Note: these are not classification of functions. Most of these are not
 mutually exclusive. For example, =forward-word= is a command, but is
 also a primitive (that is, implemented in C.), any special form by
 definition is also a primitive.

 These distinction of functions are useful because they help you
 understand if arguments are evaluated in standard way or not (For
 example, special form and macro do not.), and whether a function is
 user-oriented (For example, command), and whether a function is a
 primitive, it usually means it's fast and fundamental to elisp.

 Note: there are more, but the above are the basics. For detail, see
 [[../emacs_manual/elisp/What-Is-a-Function.html][(info "(elisp) What Is
 a Function")]]

*** Classification of Symbols in Emacs Lisp Manual

 In emacs lisp manual, each symbol has one of these indicator prefix:

 | Kind               | Predicate          | Example                 |
 | *Special Form*     | =special-form-p=   | =progn=                 |
 | *Macro*            | =macrop=           | =when=                  |
 | *Command*          | =commandp=         | =count-words=           |
 | *Prefix Command*   | none               | =help-command=          |
 | *Function*         | =functionp=        | =file-name-directory=   |
 | *Constant*         | none               | dir-locals-file         |
 | *User Option*      | none               | after-save-hook         |
 | *Variable*         | =boundp=           | buffer-file-name        |

 Note: there are only 1 Prefix Command in elisp manual: =help-command=

 Note: there are only 2 constants in elisp manual: • dir-locals-file •
 display-buffer-fallback-action

 See also: [[file:elisp_symbol.html][Elisp: Lisp Symbol]]

*** How to Check a Symbol's “type”

 Here's how to check if a symbol is which:

 #+BEGIN_SRC emacs-lisp
     ;; check if a symbol is special form
     (special-form-p 'progn)       ; t

     ;; check if a symbol is macro
     (macrop 'when )               ; t

     ;; check if a symbol is command
     (commandp 'count-words )      ; t

     ;; check if a symbol is function (this includes special form and macro). In other words, the symbol is callable
     (functionp 'buffer-file-name) ; t

     ;; check if a symbol is variable
     (boundp 'buffer-file-name)    ; t
 #+END_SRC

 The following doesn't have predicate to check:

 1. *Prefix Command*
 2. *Constant*
 3. *User Option*

 Moust useful are =fboundp= and =boundp=.

 =fboundp= → return true if a function is defined first. (that is,
 symbol's function cell is not empty. [see
 [[file:elisp_symbol.html][Elisp: Lisp Symbol]]] )

 =boundp= → return true if a variable is defined. (That is, symbol's
 value cell is not empty) [see [[file:elisp_check_defined.html][Elisp:
 Check If a {function, variable, feature} is Defined/Loaded]]]

**** How to Check for Primitive

 Use =subrp= on a symbol's function cell to check if a function is a
 primitive.

 #+BEGIN_SRC emacs-lisp
     ;; check if a function is a elisp primitive; i.e. a elisp function written in C
     ;; arg to subrp must be a lisp object, not symbol

     ;; these are core lisp functions, implemented in C
     (subrp (symbol-function 'list))         ;t
     (subrp (symbol-function '+))            ;t

     ;; these are special forms, implemented in C
     (subrp (symbol-function 'while))        ;t
     (subrp (symbol-function 'save-excursion)) ;t

     ;; these are commands, implemented in C
     (subrp (symbol-function 'goto-char))    ;t
     (subrp (symbol-function 'beginning-of-line)) ;t
     (subrp (symbol-function 'forward-word)) ;t

     ;; lambda is a macro.
     (subrp (symbol-function 'lambda))       ;nil

     ;; Return a symbol's function cell value
     (symbol-function 'setq)                 ;#<subr setq>
 #+END_SRC

**** Command vs Non-Command

 For practical emacs lisp programing, the most important concept here is
 “command”. Commands are basically =(defun …)= with =(interactive …)=
 clause. Function defined without the “interactive” can only be called by
 other elisp functions. The “interactive” function also provide many ways
 to automatically feed arguments to your function when emacs user calls
 your function. [see [[file:elisp_idioms_prompting_input.html][Elisp: Get
 User Input]]] ([[../emacs_manual/elisp/Defining-Commands.html][(info
 "(elisp) Defining Commands")]])

 When looking for a function, Alt+x =apropos-command=, with
 =universal-argument= 【Ctrl+u】 first. It'll then also list functions.
 [see [[file:elisp_search_documentation.html][Elisp: Search
 Documentation]]]

 To search all symbols, Alt+x =apropos=.

 --------------





 --------------



 This page shows you how to check if a {function, variable} is defined,
 or if a “feature” is loaded, and find out what Operating System your
 emacs is running on.

**** Check Function

 Check if a function is defined.

 #+BEGIN_SRC emacs-lisp
     ;; check if a function is defined
     (fboundp 'info)                         ; t
     (fboundp 'setq)                         ; t

     (fboundp 'xyz)                          ; nil
 #+END_SRC

**** Check Variable

 Check if a variable is defined.

 #+BEGIN_SRC emacs-lisp
     ;; check if a variable is defined
     (boundp 'auto-mode-alist)               ; t
     (boundp 'default-input-method)          ; t
     (boundp 'nil)                           ; t

     (boundp 'xyz)                           ; nil
 #+END_SRC

 The =fboundp= actually check a symbol's function cell. Similarly, the
 =boundp= checks a symbol's value cell. [see
 [[file:elisp_symbol.html][Emacs Lisp Symbol]]]

**** Check Feature

 Check if a “feature” is loaded.

 #+BEGIN_SRC emacs-lisp
     ;; check if a “feature” (package) has been loaded
     (featurep 'ibuffer)
 #+END_SRC

 [see [[file:elisp_library_system.html][Elisp: load, load-file,
 autoload]]]

 See also: [[file:elisp_determine_OS_version.html][Elisp: Find/Determine
 OS and Emacs Version]].

 --------------





 --------------



 This page shows you how to print current date time in various formats.

 See also: [[file:elisp_parse_time.html][Elisp: Parse Date Time]].

 For a ready-to-use command, see
 [[../emacs/elisp_insert-date-time.html][Emacs: Insert Date Time]]

*** Format yyyy-mm-dd

 #+BEGIN_SRC emacs-lisp
     (format-time-string "%Y-%m-%d")
     ;; "2018-09-10"
 #+END_SRC

**** ISO 8601 Format

 ISO 8601 format, example =2018-09-10T17:39:31-07:00=

 #+BEGIN_SRC emacs-lisp
     (concat
      (format-time-string "%Y-%m-%dT%T")
      ((lambda (x) (concat (substring x 0 3) ":" (substring x 3 5)))
       (format-time-string "%z")))

     ;; sample output
     ;; 2018-09-10T17:39:31-07:00
 #+END_SRC

*** Unix Time Format

 (number of seconds since 1970-01-01.)

 #+BEGIN_SRC emacs-lisp
     ;; unix time
     (format-time-string "%s") ; "1291104066"
 #+END_SRC

*** Names for Month and Week

 #+BEGIN_SRC emacs-lisp
     ;; full month name
     (format-time-string "%B") ; "November"

     ;; abbreviated month name
     (format-time-string "%b") ; "Nov"
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     ;; full week name
     (format-time-string "%A") ; "Tuesday"

     ;; abbreviated week name
     (format-time-string "%a") ; "Tue"
 #+END_SRC

*** Ordinal Date Format

 =format-time-string= also supports ordinal date format. For example:

 - “2010 January 1st” = “2010-001”
 - “2010 December 31” = “2010-365”

 #+BEGIN_SRC emacs-lisp
     (format-time-string "%Y-%j") ; "2010-334" for 2010-11-30
 #+END_SRC

 [[../emacs_manual/elisp/Time-Parsing.html][(info "(elisp) Time
 Parsing")]]

 [[../emacs_manual/elisp/Time-of-Day.html][(info "(elisp) Time of Day")]]

***** Datetime

 - [[file:elisp_insert-date-time.html][Insert Date Time]]
 - [[file:elisp_datetime_parser.html][xah-fix-datetime]]
   Print Date Time]]
 - [[file:elisp_parse_time.html][Elisp: Parse Date Time]]

 --------------





 --------------



 This page shows you how to parse date time string.

*** Problem

 Write a elisp function. The function will take a string argument that's
 any of common date time format, example

 - =2011-09-02T05:29:26-07:00= (ISO 8601)
 - =2011-09-02= (ISO 8601)
 - =Fri, 2 Sep 2011 11:14:11 +0200= (unixy)
 - =09/02/2011= (USA)
 - =Sep 2, 2011=
 - =2 Sep, 2011=
 - =2 September, 2011=

 and output a canonical form =2011-09-02T11:14:11+0200=.

*** Solution

 Two builtin lib to parse datetime:

 - =parse-time-string=, from =parse-time.el=. =(require 'parse-time)=.
 - =iso8601-parse=, from =iso8601.el=. =(require 'iso8601)=. (new in
   emacs 27)

 =(parse-time-string STRING)= return a list like this:
 =(SEC MIN HOUR DAY MON YEAR DOW DST TZ)=

 - SEC is an integer or Lisp timestamp representing a nonnegative value
   less than 60 (or less than 61 if the operating system supports leap
   seconds).
 - MIN is an integer between 0 and 59.
 - HOUR is an integer between 0 and 23.
 - DAY is an integer between 1 and 31.
 - MONTH is an integer between 1 and 12.
 - YEAR is the year number, an integer; 0 represents 1 BC.
 - DOW is the day of week, an integer between 0 and 6, where 0 is Sunday.
 - DST is t if daylight saving time is in effect, nil if it is not in
   effect, and -1 if daylight saving information is not available.
 - TZ is an integer indicating the UTC offset in seconds, i.e., the
   number of seconds east of Greenwich.

 any values that are unknown are returned as nil. in emacs 27, unknown
 DST value is returned as -1.

 =(iso8601-parse STRING &optional FORM)= return the same format.
 =iso8601-parse= is designed for parsing ISO 1601 time formats.

**** Supported Formats of parse-time-string

 #+BEGIN_SRC emacs-lisp
     ;; testing what time formats parse-time-string supports
     ;; As of GNU Emacs 27.1 of 2020-08-11

     (require 'parse-time)

     ;; parse-time-string returns
     ;; (SEC MIN HOUR DAY MON YEAR DOW DST TZ)
     ;; if a element is nil or -1, it means unknown

     (parse-time-string "Date: Mon, 01 Aug 2011 12:24:51 -0400")
     ;; (51 24 12 1 8 2011 1 -1 -14400)
     ;; yes

     (parse-time-string "Local: Mon, Aug 1 2011 9:24 am")
     ;; (0 24 9 1 8 2011 1 -1 nil)
     ;; yes

     (parse-time-string "2007, August 1")
     ;; (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "August 1, 2007")
     ;; (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "august 1, 2007")
     ;; (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "August 1st, 2007")
     ;; (nil nil nil nil 8 2007 nil -1 nil)
     ;; no. The date is nil

     (parse-time-string "aug 1, 2007")
     (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "1 aug, 2007")
     ;; (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "8/1/2007")
     ;; (nil nil nil 8 nil 2001 nil -1 nil)
     ;; no. Takes the 8 as date, 1 as nil

     (parse-time-string "08/01/2007")
     ;; (nil nil nil 8 nil 2001 nil -1 nil)
     ;; no. Takes the 8 as date, 1 as nil

     (parse-time-string "8,1,2007")
     (nil nil nil 8 nil 2001 nil -1 nil)
     ;; no

     (parse-time-string "2007-08-01")
     ;; (nil nil nil 1 8 2007 nil -1 nil)
     ;; yes

     (parse-time-string "2007")
     ;; (nil nil nil nil nil 2007 nil -1 nil)
     ;; yes

     (parse-time-string "2007-08")
     ;; (nil nil nil nil nil nil nil -1 nil)
     ;; no

     (parse-time-string "2011-08-01T11:55:37-07:00")
     ;; (nil nil nil nil nil nil nil -1 nil)
     ;; no
 #+END_SRC

*** Datetime Parser Function

 [[file:elisp_datetime_parser.html][Elisp: xah-fix-datetime]]

***** Datetime

 - [[file:elisp_insert-date-time.html][Insert Date Time]]
 - [[file:elisp_datetime_parser.html][xah-fix-datetime]]
 - [[file:elisp_datetime.html][Elisp: Print Date Time]]
   Parse Date Time]]

 --------------





 --------------



 This page shows you how to define function with optional and rest
 parameters.

*** Optional Parameters

 Emacs's function parameter's features and syntax is very basic. It is
 simply a list of items. If you want optional parameters, just add
 =&optional=. Any parameter after that will be optional.

 #+BEGIN_SRC emacs-lisp
     ;; defining a function with 2 optional params named cc and dd

     (defun myfun (aa bb &optional cc dd)
       "test optional arguments"
       (insert aa bb cc dd)
       )

     ;; call it
     (myfun "1" "2" "3" "4")
 #+END_SRC

 When a optional parameter is not given, its value is =nil=.

 If you want to give a argument to some optional parameters but not all,
 use =nil= for those you don't care. For example, to call “myfun” in the
 above with a argument for “dd” but you don't care for “cc”. Example:

 #+BEGIN_SRC emacs-lisp
     ;; calling a function with 3rd parameter omitted
     (myfun "myaa" "mybb" nil "mydd")
 #+END_SRC

 If a function received a =nil= as argument for one of its optional
 parameter, there is no way for a function to know if it is specified by
 user or omitted.

*** Unspecified Number of Parameters (Rest Args)

 You can have a function that takes unspecified any number of arguments.

 Examples of builtin functions that takes rest arg include: { =+=,
 =message=, =insert= =concat= }.

 To specify unspecified number of parameters, add =&rest name= after the
 last argument. The value of name will be a list, or =nil= if none given.

 #+BEGIN_SRC emacs-lisp
     ;; defining a function with rest args

     (defun ff (aa bb &rest cc)
       "test rest arguments"
       (message "%s" cc) ; cc is a list
       )

     ;; test
     (ff "1" "2" "3" "4")
     ;; ("3" "4")
 #+END_SRC

 You can have both =&optional= and =&rest=, in that order.

 [[../emacs_manual/elisp/Argument-List.html][(info "(elisp) Argument
 List")]]

*** No Named Parameter

 Emacs lisp *does not support named parameter*, nor any sort of parameter
 type checking.

 There's also no optional parameter with default values.

 You can define your function to take a association list as argument to
 emulate these features. [see [[file:elisp_association_list.html][Elisp:
 Association List]]]

*** Optional Parameter in Documentation

 Doc string of a function also show optional parameters the same way. For
 example, Alt+x =describe-function= then give =search-forward=, and the
 output is:

 #+BEGIN_QUOTE
   #+BEGIN_SRC emacs-lisp
       …
       (search-forward string &optional bound noerror count)
       …
   #+END_SRC
 #+END_QUOTE

 This means the function takes 4 arguments, and the last 3 is optional.

 Same in the elisp doc. For example, Alt+x =elisp-index-search= , then
 =search-forward=. It shows:

 #+BEGIN_QUOTE
   #+BEGIN_SRC emacs-lisp
        -- Command: search-forward string &optional limit noerror repeat
            This function searches forward from point for an exact match for
            STRING.  If successful, it sets point to the end of the occurrence
            found, and returns the new value of point.  If no match is found,
            the value and side effects depend on NOERROR (see below).
   #+END_SRC
 #+END_QUOTE

 --------------





 --------------



 This page is a tutorial on using regex in emacs lisp code.

 [[file:feed_0/article_59/images/img1_u2.png]]

 emacs lisp regex toothpick syndrome

*** Regex Syntax

 If you are not familiar with emacs regex syntax, first see:

 [[file:emacs_regex.html][Emacs: Regex Tutorial]]

*** Test Regex in Elisp Code

 One simple way to test regex is to create a file with the following
 content:

 #+BEGIN_SRC emacs-lisp
     (re-search-forward "yourRegex")

     whatever text to search here
 #+END_SRC

 Then, put your cursor to the right of the closing parenthesis, then
 Alt+x =eval-last-sexp= 【Ctrl+x Ctrl+e】. If your regex matches, it'll
 move cursor to the last char of the matched text. If you get a lisp
 error saying search failed, then your regex didn't match. If you get a
 lisp syntax error, then you probably screwed up on the backslashs.

*** Newline Character and Tab

 Inside elisp string, =\t= is TAB char (Unicode codepoint 9), and =\n= is
 newline. You can use =[\t\n ]+= for sequence of {tab, newline, space}.

 When a file is opened in Emacs, newline is always =\n=, regardless
 whether your file is from {Unix, Windows, Mac}. Do NOT manually do find
 replace on newline chars for changing file newline convention. [see
 [[file:emacs_line_ending_char.html][Emacs: Newline Representations ^M ^J
 ^L]]]

*** Double Backslash in Lisp Code

 Regex string in emacs lisp needs to have lots double backslash.

 First of all, remember these:

 - ="\n"= → newline. Only 1 backslash.
 - ="\t"= → tab. Only 1 backslash.
 - ="\""= → literal double quote

 then, any other backslash needs to double.

 Example,

 this =\( a.d\)= for capturing group for words like “and”, “add”, “aid”.


 And, literal interpretation instead of regex (such as square bracket),
 you need double backslashs in front, because double backslashs in string
 represents 1 backslash.

 Example:

 To match any lowercase English letter, do ="[a-z]"=


 Here's bigger example, suppose you have this text:

 #+BEGIN_SRC emacs-lisp
     <img src="cat.jpg" alt="my cat" width="795" height="183" />
 #+END_SRC

 When you call a command such as =list-matching-lines= , you can type the
 regex in the prompt. Example:

 #+BEGIN_SRC emacs-lisp
     <img src="\([^"]+?\)" alt="\([^"]+?\)" width="\([0-9]+\)" height="\([0-9]+\)" />
 #+END_SRC

 But in lisp code, the same regex needs to have many backslash escapes,
 like this:

 #+BEGIN_SRC emacs-lisp
     (re-search-forward
 #+END_SRC

 [[../emacs_manual/elisp/Regular-Expressions.html][(info "(elisp) Regular
 Expressions")]]

*** Use emacs to Convert Regex to Elisp Regex String

 There is a easy way to get the backslashes right.

 1. First, Alt+x =list-matching-lines= to do what you want.
 2. Immediately call =repeat-complex-command=. The elisp regex syntax
    will be shown in minibuffer. (with all correct backslashes if needed)

 [[file:feed_0/article_59/images/img2_u2.png]]

 Alt+x =list-matching-lines= , followed by Alt+x =repeat-complex-command=

*** Unicode Representation in String

 [[file:elisp_unicode_representation_in_string.html][Elisp: Unicode
 Escape Sequence]]

*** Find Replace Text

 [[file:elisp_find_replace_text.html][Elisp: Find Replace String in
 Buffer]]

*** Regex in Elisp Syntax: rx Package

 There is a elisp package rx that uses lisp style syntax to represent
 regex syntax.

 #+BEGIN_SRC emacs-lisp
     (require 'rx)

     ;; this
     (rx (one-or-more blank) line-end)

     ;; returns this
     ;; "[[:blank:]]+$"
 #+END_SRC

 I do not recommend it. Because it's a middleman. Just learn and use raw
 regex directly.

*** Regex and Syntax Table

 *Warning*: the meaning of a character class in emacs is dependent on the
 current major mode's syntax table. For example, what chars are
 considered “word” in =[[:word:]]= depends on how its defined in syntax
 table of current major mode.

 For a example showing the difference, see:
 [[file:elisp_regex_and_syntax_table.html][Elisp: Regex Patterns and
 Syntax Table]]

 Syntax table is hard to work with, and regex using it may be
 unpredictable. Best is just to put the chars you want explicitly in your
 regex, for example, =[A-Za-z]=.

*** Elisp Regex Video Tutorial

 unicode inverted text, emacs regex and in emacs lisp 2019-09-06

 --------------





 --------------



 This page shows emacs function/command's doc string convention and
 markup.

 [[file:feed_0/article_60/images/img1.png]]

 emacs =describe-function= screen. (note the clickable links.)

 When you lookup a function's doc by Alt+x =describe-function= 【Ctrl+h
 f】, you'll notice these features:

 - function's parameters are italicized.
 - mention of other function's name can be clicked to jump to.
 - URL can be clicked to jump to web browser.
 - keyboard shortcuts will show correctly even if user have changed it.

 To have these features, you need to put markups in your inline string.

 Here's a summary:

 - =ALLCAPS= → function argument.
 - =`sort-lines'= → link to other function.
 - =URL `http://example.org/'= → link to URL.
 - =Info node `(emacs) Dired'= → link to Info doc node.
   for displaying keys in the rest of this doc string.

 Example:

 #+BEGIN_SRC emacs-lisp
     (defun something (arg1 arg2)
       "no more than 67 chars summary here.

     detail. Mention return value. No indentation.

     • ARG1 is…. Parameters should be all caps.

     • See URL `http://example.com/' (clickable url)

     • See `dired' (clickable function/variable name)

     • See `(emacs) Dired'. (link to info doc)


     • clickable list of all keys of a given keymap name.
       (interactive)
       (message "%s" "do something.")
       )
 #+END_SRC

 The following are details of each case.

*** Short Summary in First Line

 The first line of your doc string should be a one sentence summary of
 the function. Because, =apropos-command= 【Ctrl+h a】 will display just
 that line.

 The first line should be no more than 67 characters.

 The doc string should be formatted into lines each about 70 chars,
 instead of one long line of hundreds chars. (you can use
 =fill-paragraph= for this.)

*** Italized Parameter Names

 When your function takes arguments, their names in the inline string
 should be all CAPS. Example:

 #+BEGIN_SRC emacs-lisp
     (defun read-lines (file-path)
       "Return a list of lines of a file at FILE-PATH."
       (with-temp-buffer
         (insert-file-contents file)
         (split-string (buffer-string) "\n" t)))
 #+END_SRC

 This way, when =describe-function= displays it, the arg will be
 automatically italized.

*** Clickable Function/Variable Names

 If your doc mentions another function, user can click on it, so it takes
 them to that function's doc string. To make it clickable, you need to
 quote it with =`…'=. Example:

 #+BEGIN_SRC emacs-lisp
     (defun auto-fill-mode (&optional arg)
       "Toggle Auto Fill mode.
     With ARG, turn Auto Fill mode on if and only if ARG is positive.
     In Auto Fill mode, inserting a space at a column beyond `current-fill-column'
     automatically breaks the line at a previous space.

     The value of `normal-auto-fill-function' specifies the function to use
     for `auto-fill-function' when turning Auto Fill mode on."
       ;…
         ))
 #+END_SRC

 Some elisp names are both function and variable. (For example,
 =linum-mode=). In that case, if you want emacs to link to the function,
 precede it with the word “function” or any of the word {variable,
 option, command}. Example:

 #+BEGIN_SRC emacs-lisp
     (defun my-linum-numbering-mode ()
       "…

     See also: command `linum-mode' and variable `linum-mode'"
       ;; …
         )
 #+END_SRC

*** Clickable URL

 To have a clickable URL, do like this: =URL `http://example.org/'=.
 Example:

 #+BEGIN_SRC emacs-lisp
     (defun xlsl-mode ()
       "See URL `http://xahsl.org/sl/ls-emacs.html'."
     )
 #+END_SRC

*** Links to Emacs Info Doc

 Sometimes you want clickable links to emacs's doc. You can mark it like
 this: =Info node `(elisp)Font Lock Basics'=.

 #+BEGIN_SRC emacs-lisp
     (defun xx ()
       "See Info node `(emacs) Dired'."
       )
 #+END_SRC

 Remember, each page in info doc is identified by a string, for examples:
 =(emacs) Dired=, =(elisp)Font Lock Basics=. The first part in paren is
 the doc name, followed by the node's name. When you are in info page,
 pressing c will copy this node's id to the kill-ring.

 But also note, emacs's info node may change or disappear with new emacs
 versions. [see [[file:emacs_manual_persistent_nodes.html][Emacs Manual
 Node Persistency Issues]]]

*** Auto Generate Shortcut Keys

 In your doc string you may need to tell users about pressing a keyboard
 shortcut to do something. For example, in =dired=, when you Alt+x
 =describe-mode=, the doc says: “Type C to Copy files.”. If a user has
 customized dired's keys, the doc string will correctly display the new
 key.

 To make the key of a command automatically show correctly, you need to
 =dired=:

 #+BEGIN_SRC emacs-lisp
     (defun dired-mode (&optional dirname switches)
       "\
     Mode for \"editing\" directory listings.
     …
     …"
     )
 #+END_SRC

 Sometimes the command you mentioned may have different keys in your mode

 keymap to use for processing the rest of doc string. Example:

 #+BEGIN_SRC emacs-lisp
     (defun dired-mode (&optional dirname switches)
       "…

     The buffer is read-only.  Digits are prefix arguments.
     …"
     )
 #+END_SRC

*** Auto Generated Keybinding List

 A major mode usually has its own set of keyboard shortcuts (its own
 keymap). For example, in =c-mode=, Alt+x =describe-mode=, you'll see
 this:

 #+BEGIN_QUOTE
   #+BEGIN_SRC emacs-lisp
       Key bindings:
       key             binding
       ---             -------

       C-c             Prefix Command
       C-d             c-electric-delete-forward
       TAB             c-indent-line-or-region
       …
   #+END_SRC
 #+END_QUOTE

 This is automatically generated. You just need to quote the keymap name
 documentation. Example:

 #+BEGIN_SRC emacs-lisp
     (defun c-mode ()
       "Major mode for editing K&R and ANSI C code.
     c-mode buffer.  This automatically sets up a mail buffer with version
     information already added.  You just need to add a description of the
     problem, including a reproducible test case, and send the message.


     The hook `c-mode-common-hook' is run with no args at mode
     initialization, then `c-mode-hook'.

     Key bindings:
     ;…
     )
 #+END_SRC

*** Reference

 - [[../emacs_manual/elisp/Documentation-Tips.html][(info
   "(elisp)Documentation Tips")]]
 - [[../emacs_manual/elisp/Keys-in-Documentation.html][(info "(elisp)
   Keys in Documentation")]]

 2014-05-27 thanks to [[http://irreal.org/blog/?p=2715][jcs]] for tips.

 --------------





 --------------



 In emacs lisp string, you can have Unicode characters directly (For
 example, ="I ♥ 😸"=), or, you can represent Unicode char by the following
 syntax:

 - ="\uxxxx"= → A Unicode char. xxxx must be 4 hexadecimal digits,
   representing the char's codepoint in hex. You need to pad it with 0 if
   the codepoint is less than 4 hex digits.
 - ="\U00xxxxxx"= → A Unicode char. xxxxxx must be 6 hexadecimal digits,
   representing the char's codepoint in hex. You need to pad it with 0 if
   the codepoint is less than 6 hex digits.

 Note: the syntax is a bit ugly. Which one to use depends on whether the
 Unicode is in the range of 0 to 4 hex digits. (Each Unicode char is
 given a integer id, called its “codepoint”. [see
 [[file:unicode_basics.html][Unicode Basics]]])

 #+BEGIN_SRC emacs-lisp
     ;; examples of Unicode char representation in string

     ;; lower case “a”
     (search-forward "\u0061" )

     ;; ♥ BLACK HEART SUIT codepoint 9829, #x2665
     (search-forward "\u2665" )

     ;; 😸 GRINNING CAT FACE WITH SMILING EYES codepoint 128568, #x1f638
     (search-forward "\U0001f638" )

     ;; ♥ 😸
 #+END_SRC

 in the above example, the letter a's Unicode hex is just “61”, so you
 need to pad it with “00”.

 in the above example, the grinning cat 😸's codepoint in hex is 5 digits.
 So, you need to use the ="\U00xxxxxx"= form, and because it's less than
 6 digits, so you need to pad it with “0”, resulting “000” there.

 Note: you can find a Unicode char's codepoint by Alt+x =describe-char=.

 [see [[file:emacs_n_unicode.html][Emacs: Unicode Tutorial]]]

*** Why is Encoded Unicode Char Useful?

 The use of encoded representation is useful when you want to represent
 non-printable chars, such as {RIGHT-TO-LEFT MARK, ZERO WIDTH NO-BREAK
 SPACE, NO-BREAK SPACE}. Example:

 #+BEGIN_SRC emacs-lisp
     (defun replace-BOM-mark-etc ()
       "Query replace some invisible Unicode chars.
     The chars to be searched are:
      RIGHT-TO-LEFT MARK 8207 x200f
      ZERO WIDTH NO-BREAK SPACE 65279 xfeff

     start on cursor position to end."
       (interactive)
 #+END_SRC

 [[../emacs_manual/elisp/General-Escape-Syntax.html][(info "(elisp)
 General Escape Syntax")]]

** Practical Emacs Tutorial



 [[file:emacs_logo.html][[[file:feed_0/article_0/emacs_logo/emacs_logo.svg]]]]

 This tutorial is designed for writers, scientists, engineers, to get
 started on emacs quickly. Each page teaches you something practical you
 can use right away. No emacs jargons. No need programing experience.

 [[file:which_emacs.html][Download Emacs for Windows, Mac, Linux]]

 Those marked with a rocket ship 🚀 means it's a enhanced, efficient
 command. They are part of [[../misc/ergoemacs_vi_mode.html][Emacs: Xah
 Fly Keys]]

**** About This Tutorial

 [[file:feed_0/article_0/i/learning_gnu_emacs.png]]
 [[file:feed_0/article_0/images/img1.jpg]]

 emacs books from 1990s.

 If you were to spend 3 months reading 3 emacs books, it is more
 efficient to just read Xah Emacs Tutorial for just 1 month. Xah tutorial
 focus on actually using emacs in practice, and on efficiency of using
 emacs, as well as efficiency of learning.

 - This tutorial skips the emacs parts that are rarely used. Every single
   one thousand emacs C-x commands are looked, the practical ones are
   presented to you.
 - The writing style is concrete, and example based. No story telling, no
   joke, just what you need to know to use emacs in the most efficient
   way.
 - This tutorial does not force emacs jargons and emacs hacker methods.
   If you are new to emacs, you will understand it. If you are old time
   hacker, you will improve your efficiency of using emacs.
 - This tutorial covers emacs lisp, more extensive than any existing
   emacs lisp book (except the elisp manual) or elisp tutorial online. A
   little elisp makes you a far better emacs user and understanding
   emacs. [see [[file:elisp.html][Practical Emacs Lisp]]]
 - There are more examples and elisp code in Xah Emacs Tutorial than all
   existing emacs books or web sites combined. You do not need to read it
   all, but any time spent reading this tutorial, you'll learn more
   useful things than same amount of time spent elsewhere.

 The author lives in emacs since 1999. And has been obsessively writing
 emacs tutorial since 2006.

*** Buy Xah Emacs Tutorial

 Buy my tutorial to support the site.

 Buy Xah Emacs Tutorial]]

*** What Do People Say?

 [[file:user_comments.html][Testimonial on Xah Emacs Tutorial]]

 --------------





 --------------


 This sections shows you how to customize emacs by editing the init file.

 Start at [[file:emacs_make_modern.html][Emacs: Init File Tutorial]]

 --------------





 --------------


 The essence of using emacs is commands and keys.

 [[file:keyboard_shortcuts.html][Emacs: How to Define Keys]]

 or watch a video:

 dvorak colemak minimak layouts, ergodox, keyboard firmware, keybinding,
 ergodox, programable keypads 2019-09-20

 [[file:feed_0/article_2/images/img1_u1.jpg]]

 “Emacs user at work”. (by
 [[http://earlcolour.deviantart.com/][earlcolour.deviantart.com]])


 --------------





 --------------


 [[file:lisp_logo.html][[[file:feed_0/article_3/images/img1.svg]]]]

 Buy Xah Emacs Tutorial]]

 Emacs is possible because of the embedded programing language emacs
 lisp. Learning a bit emacs lisp will increase your understanding of
 emacs by a lot.

 This is a example based tutorial on emacs lisp, with focus on how-to.

 [[file:elisp_basics.html][Emacs Lisp Basics]]

 or watch a video:

 Xah Lee Live Stream. emacs lisp for beginner.

 --------------





 --------------


 This section is collection of simple emacs lisp examples. They are great
 for studying elisp but also as practical useful commands.

 [[file:elisp_title_case_text.html][Emacs: Change to Title Case]]

 Note, you can also use other programing language and call them in emacs.
 see [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands Using
 Python, Ruby, ...]]

 --------------





 --------------



 Here's emacs command to change letter case by title convention.

 For example, “A Tale of Two Cities”, not “A Tale Of Two Cities”.

 #+BEGIN_SRC emacs-lisp
     (defun xah-title-case-region-or-line (@begin @end)
       "Title case text between nearest brackets, or current line, or text selection.
     Capitalize first letter of each word, except words like {to, of, the, a, in, or, and, …}. If a word already contains cap letters such as HTTP, URL, they are left as is.

     When called in a elisp program, *begin *end are region boundaries.
     Version 2017-01-11"
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (let (
                $p1
                $p2
                ($skipChars "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕"))
            (progn
              (skip-chars-backward $skipChars (line-beginning-position))
              (setq $p1 (point))
              (skip-chars-forward $skipChars (line-end-position))
              (setq $p2 (point)))
            (list $p1 $p2))))
       (let* (
              ($strPairs [
                          [" A " " a "]
                          [" And " " and "]
                          [" At " " at "]
                          [" As " " as "]
                          [" By " " by "]
                          [" Be " " be "]
                          [" Into " " into "]
                          [" In " " in "]
                          [" Is " " is "]
                          [" It " " it "]
                          [" For " " for "]
                          [" Of " " of "]
                          [" Or " " or "]
                          [" On " " on "]
                          [" Via " " via "]
                          [" The " " the "]
                          [" That " " that "]
                          [" To " " to "]
                          [" Vs " " vs "]
                          [" With " " with "]
                          [" From " " from "]
                          ["'S " "'s "]
                          ["'T " "'t "]
                          ]))
         (save-excursion
           (save-restriction
             (narrow-to-region @begin @end)
             (upcase-initials-region (point-min) (point-max))
             (let ((case-fold-search nil))
               (mapc
                (lambda ($x)
                  (goto-char (point-min))
                  (while
                      (search-forward (aref $x 0) nil t)
                    (replace-match (aref $x 1) "FIXEDCASE" "LITERAL")))
                $strPairs))))))
 #+END_SRC

 --------------





 --------------



 This page shows a emacs command to escape/unescape quotes.

 For example,

 #+BEGIN_SRC emacs-lisp
     "xyz"
 #+END_SRC

 becomes

 #+BEGIN_SRC emacs-lisp
     \"xyz\"
 #+END_SRC

 This is very useful when coding lisp to process other languages.

 For example, when you have this =x = "…"=, and you want
 =(search-forward "x = \"…\"") =

 Here's the code.

 #+BEGIN_SRC emacs-lisp
     (defun xah-escape-quotes (@begin @end)
     See also: `xah-unescape-quotes'

     Version 2017-01-11"
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list (line-beginning-position) (line-end-position))))
       (save-excursion
           (save-restriction
             (narrow-to-region @begin @end)
             (goto-char (point-min))
             (while (search-forward "\"" nil t)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun xah-unescape-quotes (@begin @end)
     See also: `xah-escape-quotes'

     Version 2017-01-11"
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list (line-beginning-position) (line-end-position))))
       (save-excursion
         (save-restriction
           (narrow-to-region @begin @end)
           (goto-char (point-min))
             (replace-match "\"" "FIXEDCASE" "LITERAL")))))
 #+END_SRC

 You can assign keys to them. [see [[file:keyboard_shortcuts.html][Emacs:
 How to Define Keys]]]

 --------------





 --------------



 Here's a emacs command that removes accent marks, or, convert some
 Unicode characters into ASCII. (aka Zap Gremlins)

 For example:

 - “café” ⇒ “cafe”
 - “naïve” ⇒ “naive”

 #+BEGIN_SRC emacs-lisp
     (defun xah-asciify-text (&optional @begin @end)
       "Remove accents in some letters and some
     Change European language characters into equivalent ASCII ones, e.g. “café” ⇒ “cafe”.
     When called interactively, work on current line or text selection.

     Version 2018-11-12"
       (interactive)
       (let (($charMap
              [
               ["ß" "ss"]
               ["æ" "ae"]
               ["þ" "th"]
               ["ĩ" "i"]
               ["ť" "t"]
               [" " " "]       ; thin space etc
               ["–" "-"]       ; dash
               ])
             $begin $end
             )
         (if (null @begin)
             (if (use-region-p)
                 (setq $begin (region-beginning) $end (region-end))
               (setq $begin (line-beginning-position) $end (line-end-position)))
           (setq $begin @begin $end @end))
         (let ((case-fold-search t))
           (save-restriction
             (narrow-to-region $begin $end)
             (mapc
              (lambda ($pair)
                (goto-char (point-min))
                (while (search-forward-regexp (elt $pair 0) (point-max) t)
                  (replace-match (elt $pair 1))))
              $charMap)))))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun xah-asciify-string (@string)
       "Returns a new string. European language chars are changed ot ASCII ones e.g. “café” ⇒ “cafe”.
     See `xah-asciify-text'
     Version 2015-06-08"
       (with-temp-buffer
           (insert @string)
           (xah-asciify-text (point-min) (point-max))
           (buffer-string)))
 #+END_SRC

 [see [[http://wordyenglish.com/musing/diacritics.html][Accent Marks:
 Trema, Umlaut, Macron, Circumflex]]]

 (2015-06-08 thanks to robert_nagy for adding chars)

*** Accumulator vs Parallel Programing

 This problem makes a good parallel programing exercise. See:
 [[http://xahlee.info/comp/parallel_programing_exercise_asciify-string.html][Parallel
 Programing Exercise: asciify-string]].

*** Alternative Solution with “iconv” or perl

 2011-03-08

 Yuri Khan and Teemu Likonen suggested using the “iconv” shell command.
 See =man iconv=. Here's Teemu's code.

 #+BEGIN_SRC emacs-lisp
     (defun asciify-string (string)
     "Convert STRING to ASCII string.
     For example:
     “passé” becomes “passe”"
     ;; Code originally by Teemu Likonen
       (with-temp-buffer
         (insert string)
         (call-process-region (point-min) (point-max) "iconv" t t nil "--to-code=ASCII//TRANSLIT")
         (buffer-substring-no-properties (point-min) (point-max))))
 #+END_SRC

 Julian Bradfield suggested Perl. Here's his one-liner, it removes chars
 with accent marks.

 #+BEGIN_SRC emacs-lisp
     perl -e 'use encoding utf8; use Unicode::Normalize; while ( <> ) { $_ = NFKD($_); s/\pM//g; print; }'
 #+END_SRC

 [[http://groups.google.com/group/comp.emacs/msg/8d58b6e9b2bd07fd]]

 Though, it would be nice to have a pure elisp solution, because “iconv”
 is not in Windows or Mac OS X as of 2011-03-08.

 --------------





 --------------



 Here's a command to convert straight quote to curly quotes.

 #+BEGIN_SRC emacs-lisp
     (defun xah-replace-straight-quotes (@begin @end)
       "Replace straight double quotes to curly ones, and others.
     Works on current text block or selection.

     Examples of changes:
      「\"…\"」 → 「“…”」
      「...」 → 「…」
      「I’m」 → 「I'm」
      「--」 → 「—」
      「~=」 → 「≈」

     When called in lisp code, @begin and @end are region begin/end positions.

     WARNING: this command does not guarantee 100% correct conversion of quotes, because it impossible. You should double check highlighted places after.

     Version 2018-03-02"
       ;; some examples for debug
       ;; do "‘em all -- done..."
       ;; I’am not
       ;; said "can’t have it, can’t, just can’t"
       ;; ‘I’ve can’t’
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (let ($p1 $p2)
            (save-excursion
              (if (re-search-backward "\n[ \t]*\n" nil "move")
                  (progn (re-search-forward "\n[ \t]*\n")
                         (setq $p1 (point)))
                (setq $p1 (point)))
              (if (re-search-forward "\n[ \t]*\n" nil "move")
                  (progn (re-search-backward "\n[ \t]*\n")
                         (setq $p2 (point)))
                (setq $p2 (point))))
            (list $p1 $p2))))

       (let ( (case-fold-search nil))
         (save-excursion
           (save-restriction
             (narrow-to-region @begin @end )
             ;; Note: order is important since this is huristic.
             (xah-replace-pairs-region
              (point-min) (point-max)
              [
               ;; dash and ellipsis etc
               ["--" " — "]
               ["—" " — "]
               ["..." "…"]
               [" & " " ＆ "]
               [" :)" " ☺"]
               [" :(" " ☹"]
               [" ;)" " 😉"]
               ["~=" "≈"]
               [" --> " " ⟶ "]
               [" , " ", "]
               ;; fix GNU style ASCII quotes
               ["``" "“"]
               ["''" "”"]
               ;; double straight quote → double curly quotes
               ["\n\"" "\n“"]
               [">\"" ">“"]
               ["(\"" "(“"]
               [" \"" " “"]
               ["\" " "” "]

               ["\", " "”, "]
               ["\",\n" "”,\n"]

               ["\". " "”. "]
               ["\".\n" "”.\n"]
               ["\"?" "”?"]
               ["\";" "”;"]
               ["\":" "”:"]
               ["\")" "”)"]
               ["\"]" "”]"]

               ;; ["\"[" "\”["]

               [".\"" ".”"]
               [",\"" ",”"]
               ["!\"" "!”"]
               ["?\"" "?”"]
               ["\"<" "”<"]
               ["\"\n" "”\n"]
               ] "REPORT" "HILIGHT")

             (xah-replace-pairs-region
              (point-min) (point-max)
              [
               ["  —  " " — "] ; rid of extra space in em-dash
               ] "REPORT" "HILIGHT")

             (xah-replace-pairs-region
              (point-min) (point-max)
              [
               [" —-> " " ⟶ "]
               [" <= " " ≤ "]
               [" >= " " ≥ "]
               ] "REPORT" "HILIGHT")

             ;; fix straight double quotes by regex
             (xah-replace-regexp-pairs-region
              (point-min) (point-max)
              [
               ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

             ;; fix single quotes to curly
             (xah-replace-pairs-region
              (point-min) (point-max)
              [
               [">\'" ">‘"]
               [" \'" " ‘"]
               ["\' " "’ "]
               ["\'," "’,"]
               [".\'" ".’"]
               ["!\'" "!’"]
               ["?\'" "?’"]
               ["(\'" "(‘"]
               ["\')" "’)"]
               ["\']" "’]"]
               ] "REPORT" "HILIGHT")

             (xah-replace-regexp-pairs-region
              (point-min) (point-max)
              [

               ["s’ " "s' "]
               ["s’\n" "s'\n"]

               ["\"$" "”"]
               ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

             ;; fix back escaped quotes in code
             (xah-replace-pairs-region
              (point-min) (point-max)
              [
               ] "REPORT" "HILIGHT")

             ;; fix back. quotes in HTML code
             (xah-replace-regexp-pairs-region
              (point-min) (point-max)
              [
               ["=”" "=\""]
               ["/” " "/\" "]
               ] "FIXEDCASE" nil "HILIGHT"
              )

             ))))
 #+END_SRC

 You need the elisp library
 [[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

 --------------





 --------------



 This page shows commands to convert to/from Full-Width/Half-Width
 characters. (全角 半角 转换)

 If you type Chinese or Japanese mixed with English, then often you'll
 have mixed Asian/Western punctuations, and is hard to fix manually.

 - . ↔ 。 (U+3002: IDEOGRAPHIC FULL STOP)
 - , ↔ ， (U+FF0C: FULLWIDTH COMMA)
 - ? ↔ ？ (U+FF1F: FULLWIDTH QUESTION MARK)
 - ; ↔ ； (U+FF1B: FULLWIDTH SEMICOLON)

 [see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
 Full-Width Characters]]]

*** Convert English Chinese Punctuation

 #+BEGIN_SRC emacs-lisp
     (defun xah-convert-english-chinese-punctuation (@begin @end &optional @to-direction)
       "Convert punctuation from/to English/Chinese characters.

     When called interactively, do current line or selection. The conversion direction is automatically determined.

     If `universal-argument' is called, ask user for change direction.

     When called in lisp code, *begin *end are region begin/end positions. *to-direction must be any of the following values: 「\"chinese\"」, 「\"english\"」, 「\"auto\"」.

     See also: `xah-remove-punctuation-trailing-redundant-space'.

     Version 2015-10-05"
       (interactive
        (let ($p1 $p2)
          (if (use-region-p)
              (progn
                (setq $p1 (region-beginning))
                (setq $p2 (region-end)))
            (progn
              (setq $p1 (line-beginning-position))
              (setq $p2 (line-end-position))))
          (list
           $p1
           $p2
           (if current-prefix-arg
               (ido-completing-read
                "Change to: "
                '( "english"  "chinese")
                "PREDICATE"
                "REQUIRE-MATCH")
             "auto"
             ))))
       (let (
             ($input-str (buffer-substring-no-properties @begin @end))
             ($replacePairs
              [
               [". " "。"]
               [".\n" "。\n"]
               [", " "，"]
               [",\n" "，\n"]
               [": " "："]
               ["; " "；"]
               ["? " "？"] ; no space after
               ["! " "！"]

               ;; for inside HTML
               [".</" "。</"]
               ["?</" "？</"]
               [":</" "：</"]
               [" " "　"]
               ]
              ))

         (when (string= @to-direction "auto")
           (setq
            @to-direction
            (if
                (or
                 (string-match "　" $input-str)
                 (string-match "。" $input-str)
                 (string-match "，" $input-str)
                 (string-match "？" $input-str)
                 (string-match "！" $input-str))
                "english"
              "chinese")))
         (save-excursion
           (save-restriction
             (narrow-to-region @begin @end)
             (mapc
              (lambda ($x)
                (progn
                  (goto-char (point-min))
                  (while (search-forward (aref $x 0) nil "noerror")
                    (replace-match (aref $x 1)))))
              (cond
               ((string= @to-direction "chinese") $replacePairs)
               ((string= @to-direction "english") (mapcar (lambda (x) (vector (elt x 1) (elt x 0))) $replacePairs))
               (t (user-error "Your 3rd argument 「%s」 isn't valid" @to-direction))))))))
 #+END_SRC

*** Remove Punctuation Trailing Redundant Spaces

 Here's helpful command to remove redundant spaces after punctuation.

 - In English text, the convention is to have 1 space after punctuation
   (sometimes 2, after the Full Stop sign).
 - In Chinese text, the convention is to have no space after punctuation.

 #+BEGIN_SRC emacs-lisp
     (defun xah-remove-punctuation-trailing-redundant-space (@begin @end)
       "Remove redundant whitespace after punctuation.
     Works on current line or text selection.

     When called in emacs lisp code, the *begin *end are cursor positions for region.

     See also `xah-convert-english-chinese-punctuation'.

     version 2015-08-22"
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list (line-beginning-position) (line-end-position))))
       (require 'xah-replace-pairs)
       (xah-replace-regexp-pairs-region
        @begin @end
        [
         ;; clean up. Remove extra space.
         [" +," ","]
         [",  +" ", "]
         ["?  +" "? "]
         ["!  +" "! "]

         ;; fullwidth punctuations
         ["， +" "，"]
         ["。 +" "。"]
         ["： +" "："]
         ["？ +" "？"]
         ["； +" "；"]
         ["！ +" "！"]
         ["、 +" "、"]
         ]
        "FIXEDCASE" "LITERAL"))
 #+END_SRC

 These commands are useful for Twitter too, for saving a few character in
 Twitter's character limit. Because, English punctuation takes 2 char
 each, while Chinese version needs just one char, the space is included
 in the punctuation symbol.

*** Convert Half-Width Full-Width Characters

 This command convert all English letters and digits and punctuations,
 from/to half-width and full-width.

 [see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
 Full-Width Characters]]]

 #+BEGIN_SRC emacs-lisp
     (defun xah-convert-fullwidth-chars (@begin @end &optional @to-direction)
       "Convert ASCII chars to/from Unicode fullwidth version.
     Works on current line or text selection.

     The conversion direction is determined like this: if the command has been repeated, then toggle. Else, always do to-Unicode direction.

     If `universal-argument' is called first:

      no C-u → Automatic.
      C-u → to ASCII
      C-u 1 → to ASCII
      C-u 2 → to Unicode

     When called in lisp code, @begin @end are region begin/end positions. @to-direction must be any of the following values: 「\"unicode\"」, 「\"ascii\"」, 「\"auto\"」.

     See also: `xah-remove-punctuation-trailing-redundant-space'.

     Version 2018-08-02"
       (interactive
        (let ($p1 $p2)
          (if (use-region-p)
              (progn
                (setq $p1 (region-beginning))
                (setq $p2 (region-end)))
            (progn
              (setq $p1 (line-beginning-position))
              (setq $p2 (line-end-position))))
          (list $p1 $p2
                (cond
                 ((equal current-prefix-arg nil) "auto")
                 ((equal current-prefix-arg '(4)) "ascii")
                 ((equal current-prefix-arg 1) "ascii")
                 ((equal current-prefix-arg 2) "unicode")
                 (t "unicode")))))
       (let* (
              ($ascii-unicode-map
               [
                ["0" "０"] ["1" "１"] ["2" "２"] ["3" "３"] ["4" "４"] ["5" "５"] ["6" "６"] ["7" "７"] ["8" "８"] ["9" "９"]
                ["A" "Ａ"] ["B" "Ｂ"] ["C" "Ｃ"] ["D" "Ｄ"] ["E" "Ｅ"] ["F" "Ｆ"] ["G" "Ｇ"] ["H" "Ｈ"] ["I" "Ｉ"] ["J" "Ｊ"] ["K" "Ｋ"] ["L" "Ｌ"] ["M" "Ｍ"] ["N" "Ｎ"] ["O" "Ｏ"] ["P" "Ｐ"] ["Q" "Ｑ"] ["R" "Ｒ"] ["S" "Ｓ"] ["T" "Ｔ"] ["U" "Ｕ"] ["V" "Ｖ"] ["W" "Ｗ"] ["X" "Ｘ"] ["Y" "Ｙ"] ["Z" "Ｚ"]
                ["a" "ａ"] ["b" "ｂ"] ["c" "ｃ"] ["d" "ｄ"] ["e" "ｅ"] ["f" "ｆ"] ["g" "ｇ"] ["h" "ｈ"] ["i" "ｉ"] ["j" "ｊ"] ["k" "ｋ"] ["l" "ｌ"] ["m" "ｍ"] ["n" "ｎ"] ["o" "ｏ"] ["p" "ｐ"] ["q" "ｑ"] ["r" "ｒ"] ["s" "ｓ"] ["t" "ｔ"] ["u" "ｕ"] ["v" "ｖ"] ["w" "ｗ"] ["x" "ｘ"] ["y" "ｙ"] ["z" "ｚ"]
                ["," "，"] ["." "．"] [":" "："] [";" "；"] ["!" "！"] ["?" "？"] ["\"" "＂"] ["'" "＇"] ["`" "｀"] ["^" "＾"] ["~" "～"] ["¯" "￣"] ["_" "＿"]
                [" " "　"]
                ]
               )
              ($reverse-map
               (mapcar
                (lambda (x) (vector (elt x 1) (elt x 0)))
                $ascii-unicode-map))

              ($stateBefore
               (if (get 'xah-convert-fullwidth-chars 'state)
                   (get 'xah-convert-fullwidth-chars 'state)
                 (progn
                   (put 'xah-convert-fullwidth-chars 'state 0)
                   0
                   )))
              ($stateAfter (if (eq $stateBefore 0) 1 0 )))


         ;; (message "before %s" $stateBefore)
         ;; (message "after %s" $stateAfter)
         ;; (message "@to-direction %s" @to-direction)
         ;; (message "real-this-command  %s" real-this-command)
         ;; (message "real-last-command %s" real-last-command)
         ;; (message "this-command  %s" this-command)
         ;; (message "last-command %s" last-command)

         (let ((case-fold-search nil))
           (xah-replace-pairs-region
            @begin @end
            (cond
             ((string= @to-direction "unicode") $ascii-unicode-map)
             ((string= @to-direction "ascii") $reverse-map)
             ((string= @to-direction "auto")
              (if (eq $stateBefore 0)
                  $reverse-map
                $ascii-unicode-map )

              ;; 2018-08-02 this doesn't work when using smex
              ;; (if (eq last-command this-command)
              ;;     (progn
              ;;       (message "%s" "repeated")
              ;;       (if (eq $stateBefore 0)
              ;;           $reverse-map
              ;;         $ascii-unicode-map ))
              ;;   (progn
              ;;     (message "%s" "not repeated")
              ;;     $ascii-unicode-map))

              ;;

              )
             (t (user-error "Your 3rd argument 「%s」 isn't valid" @to-direction)))
            t t ))
         (put 'xah-convert-fullwidth-chars 'state $stateAfter)))
 #+END_SRC

***** Emacs Chinese Topics

 - [[file:elisp_chinese_char_linkify.html][Elisp: Chinese Char To
   Reference Link]]
   Convert Full-Width/Half-Width Punctuations]]
 - [[file:emacs_chinese_input.html][Emacs Chinese Input]]

 --------------





 --------------



 The color package =color.el=, in emacs 24.1, lets you convert colors
 from various models and formats. For example: RGB, HSL, HSV, named color
 values, and things like finding the color complement.

 This page shows you:

 - How to use =color.el=.
 - Command to convert color format under cursor.

*** Convert RGB to HSL

 #+BEGIN_SRC emacs-lisp
     ;; convert RGB color to HSL.
     ;; all input and output are in the range {0, 1}

     (require 'color )

     (color-rgb-to-hsl 1 0 0) ; ⇒  (0.0 1 0.5) red

     (color-rgb-to-hsl 0 1 0) ; ⇒ (0.3333333333333333 1 0.5) green

     (color-rgb-to-hsl 0 0 1) ; ⇒ (0.6666666666666666 1 0.5) blue

     (color-rgb-to-hsl 1 1 1) ; ⇒ (0.0 0.0 1.0) white

     (color-rgb-to-hsl 0 0 0) ; ⇒ (0.0 0.0 0.0) black
 #+END_SRC

 Note that if you are converting from hex valued RGB format such as
 =#aabbcc=, you must first convert the hex to integer, then re-scale from
 {0 to 255} based range to {0 to 1} based range, then feed that to
 =color-rgb-to-hsl=.

 For explanation of the HSL color model, see:
 [[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]

*** Convert HSL to RGB

 #+BEGIN_SRC emacs-lisp
     ;; convert HSL color to RGB.
     ;; all input and output are in the range {0 to 1}

     (require 'color )

     (color-hsl-to-rgb 0 1 .5) ; (1.0 0.0 0.0) red

     (color-hsl-to-rgb .3 1 .5) ; ⇒ (0.19999999999999996 1.0 0.0) greenish

     (color-hsl-to-rgb .6 1 .5) ; ⇒ (0.0 0.3999999999999999 1.0) blueish

     (color-hsl-to-rgb 0 0 1) ; ⇒ (1 1 1) white

     (color-hsl-to-rgb 0 0 0) ; ⇒ (0 0 0) black
 #+END_SRC

*** Convert RGB Hexadecimal Format to Emacs Lisp Vector Format

 #+BEGIN_SRC emacs-lisp
     (defun xah-css-convert-color-hex-to-vec (@rrggbb)
       "Convert color *rrggbb from “\"rrggbb\"” string to a elisp vector [r g b], where the values are from 0 to 1.
     Example:
      (xah-css-convert-color-hex-to-vec \"00ffcc\") ⇒ [0.0 1.0 0.8]

     Note: The input string must NOT start with “#”.
     Version 2016-07-19"
       (vector
        (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 0 2) 16) 255)
        (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 2 4) 16) 255)
        (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 4) 16) 255)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun xah-css-normalize-number-scale (@val @range-max)
       "Scale *val from range [0, *range-max] to [0, 1]
     The arguments can be int or float.
     Return value is float.
     Version 2016-07-19"
       (/ (float @val) (float @range-max)))
 #+END_SRC

*** Command to Convert RGB Color to HSL

 Here's a command that convert between CSS's RGB hexadecimal format to
 HSL format. For example, =#ffefd5= → =hsl(37,100%,91%)=

 It works on the word under cursor.

 #+BEGIN_SRC emacs-lisp
     (defun xah-css-hex-color-to-hsl ()
       "Convert color spec under cursor from “#rrggbb” to CSS HSL format.
      e.g. #ffefd5 ⇒ hsl(37,100%,91%)
     Version 2016-07-19"
       (interactive)
       (let* (
              ($bds (bounds-of-thing-at-point 'word))
              ($p1 (car $bds))
              ($p2 (cdr $bds))
              ($currentWord (buffer-substring-no-properties $p1 $p2)))
             (progn
               (delete-region $p1 $p2 )
               (when (equal (char-before) 35) ; 35 is #
                 (delete-char -1))
               (insert (xah-css-hex-to-hsl-color $currentWord )))
           (progn
             (user-error "The current word 「%s」 is not of the form #rrggbb." $currentWord)))))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun xah-css-hex-to-hsl-color (@hex-str)
       "Convert *hex-str color to CSS HSL format.
     Return a string. Example:  \"ffefd5\" ⇒ \"hsl(37,100%,91%)\"
     Note: The input string must NOT start with “#”.
     Version 2016-07-19"
       (let* (
              ($colorVec (xah-css-convert-color-hex-to-vec @hex-str))
              ($R (elt $colorVec 0))
              ($G (elt $colorVec 1))
              ($B (elt $colorVec 2))
              ($hsl (color-rgb-to-hsl $R $G $B))
              ($H (elt $hsl 0))
              ($S (elt $hsl 1))
              ($L (elt $hsl 2)))
         (format "hsl(%d,%d%%,%d%%)" (* $H 360) (* $S 100) (* $L 100))))
 #+END_SRC

 The code is from [[file:xah-css-mode.html][Emacs: Xah CSS Mode]].

 =color.el= is written by Julien Danjou
 [[[https://julien.danjou.info/blog/]] ] , Drew Adams
 [[[http://www.emacswiki.org/emacs/DrewAdams]] ] Thanks guys.

 - [[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]
 - [[file:emacs_CSS_colors.html][Emacs: Working with CSS Color Values]]

 --------------





 --------------



 Here's several ways to convert between Hexadecimal to Decimal in emacs.

*** Using calc

 - Alt+x =calc=.
 - Type any number. For example, 10.
 - Type “d6” to turn the display into hexadecimal form.
 - Type “d0” to turn the display into decimal form.

 To type a hex number, type =#=, then type “16#aa” for the hex “aa”.

*** Using Emacs Lisp

 Here's how to convert decimal to hexadecimal:

 #+BEGIN_SRC emacs-lisp
     ;; decimal to hex. Returns 「a」
     (format "%x" 10)
 #+END_SRC

 Here's how to convert hexadecimal to decimal:

 #+BEGIN_SRC emacs-lisp
     ;; hex 「a」 to decimal. Returns 「10」.
     (format "%d" #xa)
 #+END_SRC

 Select the code, then Alt+x =eval-region=.

 [see [[file:elisp_eval_lisp_code.html][Emacs: Evaluate Elisp Code]]]

*** Emacs Lisp Command

 Here's a elisp command that prints the decimal value of a hexadecimal
 string under cursor.

 #+BEGIN_SRC emacs-lisp
     (defun xah-show-hexadecimal-value ()
       "Prints the decimal value of a hexadecimal string under cursor.

     Samples of valid input:

       ffff → 65535
       0xffff → 65535
       #xffff → 65535
       FFFF → 65535
       0xFFFF → 65535
       #xFFFF → 65535

     more test cases
       64*0xc8+#x12c 190*0x1f4+#x258
       100 200 300   400 500 600

     Version 2020-02-17"
       (interactive )
       (let ($inputStr $tempStr $p1 $p2 )
         (if (region-active-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (progn
             (save-excursion
               (skip-chars-backward "0123456789abcdefABCDEF#x")
               (setq $p1 (point))
               (skip-chars-forward "0123456789abcdefABCDEF#x" )
               (setq $p2 (point)))))
         (setq $inputStr (buffer-substring-no-properties $p1 $p2))
         (let ((case-fold-search nil))
           )
         (message "input 「%s」, Hex 「%s」 is 「%d」" $inputStr $tempStr (string-to-number $tempStr 16))))
 #+END_SRC

 --------------





 --------------



 [[file:feed_0/article_16/images/img1_u4.png]]

 Here's a command to convert Greek to unicode symbols.

 #+BEGIN_SRC emacs-lisp
     (require 'xah-replace-pairs)

     (defun xah-replace-greek-letter-name-to-symbol (@begin @end)
       "Replace alpha to α, beta to β etc in current line or selection.

     Version 2016-10-05"
       (interactive
        (if (use-region-p)
            (list (region-beginning) (region-end))
          (list (line-beginning-position) (line-end-position))))
       (let ((case-fold-search nil))
         (xah-replace-pairs-region
          @begin
          @end
          '(
            ["Alpha" "Α"]
            ["Beta" "Β"]
            ["Gamma" "Γ"]
            ["Delta" "Δ"]
            ["Epsilon" "Ε"]
            ["Zeta" "Ζ"]
            ["Eta" "Η"]
            ["Theta" "Θ"]
            ["Iota" "Ι"]
            ["Kappa" "Κ"]
            ["Lambda" "Λ"]
            ["Mu" "Μ"]
            ["Nu" "Ν"]
            ["Xi" "Ξ"]
            ["Omicron" "Ο"]
            ["Pi" "Π"]
            ["Rho" "Ρ"]
            ["Sigma" "Σ"]
            ["Tau" "Τ"]
            ["Upsilon" "Υ"]
            ["Phi" "Φ"]
            ["Chi" "Χ"]
            ["Psi" "Ψ"]
            ["Omega" "Ω"]

            ["alpha" "α"]
            ["beta" "β"]
            ["gamma" "γ"]
            ["delta" "δ"]
            ["epsilon" "ε"]
            ["zeta" "ζ"]
            ["eta" "η"]
            ["theta" "θ"]
            ["iota" "ι"]
            ["kappa" "κ"]
            ["lambda" "λ"]
            ["mu" "μ"]
            ["nu" "ν"]
            ["xi" "ξ"]
            ["omicron" "ο"]
            ["pi" "π"]
            ["rho" "ρ"]
            ["sigmaf" "ς"]
            ["sigma" "σ"]
            ["tau" "τ"]
            ["upsilon" "υ"]
            ["phi" "φ"]
            ["chi" "χ"]
            ["psi" "ψ"]
            ["omega" "ω"]
            ["thetasym" "ϑ"]
            ["upsih" "ϒ"]
            ["piv" "ϖ"]
            ) 'REPORT 'HILIGHT )))
 #+END_SRC

 You need the elisp library
 [[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

 --------------





 --------------



 Here's a emacs lisp command that shortens text to fit twitter's 140
 chars.

 #+BEGIN_SRC emacs-lisp
     (defun xah-twitterfy ()
       "Shorten words for Twitter 280 char limit on current line or selection.

     If `universal-argument' is called first, ask for conversion direction (shorten/lenthen).

     Note: calling this function twice in opposite direction does not necessarily return the origial, because the map is not one-to-one.

     Version 2019-01-16"
       (interactive)
       (let (
             $p1 $p2
             $direction

             ($shorten-map
              [
               ["e.g. " "eg "]
               ["\bto\b" "2"]
               [" your" " ur "]
               ["because" "∵"]
               ["therefore " "∴"]
               [" at " " @ "]
               [" love " " ♥ "]
               [" one " " 1 "]
               [" two " " 2 "]
               [" three " " 3 "]
               [" four " " 4 "]
               [" zero " " 0 "]
               ["hexadecimal " "hex "]
               ["Emacs: " "#emacs "]
               ["JavaScript: " "#JavaScript "]
               ["Python: " "#python "]
               ["Ruby: " "#ruby "]
               ["Perl: " "#perl "]
               ["Emacs Lisp: " "#emacs #lisp "]
               ["Elisp: " "#emacs #lisp "]
               [", " "，"]
               [": " "："]
               ["! " "！"]]
              )
             ($lengeth-map
              [
               ["eg " "e.g. "]
               [" 2 " " to "]
               [" @ " " at "]
               [" ♥ " " love "]
               [" 1 " " one "]
               [" 2 " " two "]
               [" 3 " " three "]
               [" 4 " " four "]
               [" 0 " " zero "]
               ["hex " "hexadecimal "]
               ["，" ", "]
               ["…" "..."]
               ["。" ". "]
               ["？" "? "]
               ["：" ": "]
               ["！" "! "]
               ]
              ))
         (if (region-active-p)
             (setq $p1 (region-beginning) $p2 (region-end))
           (save-excursion
             (if (re-search-backward "\n[ \t]*\n" nil "move")
                 (progn
                   (setq $p1 (point))
                   (re-search-forward "\n[ \t]*\n"))
               (setq $p1 (point)))
             (progn
               (re-search-forward "\n[ \t]*\n" nil "move")
               (setq $p2 (point)))))
         (setq $direction
               (if current-prefix-arg
                   (ido-completing-read
                    "Direction: "
                    '( "shorten"  "lengthen")
                    "PREDICATE"
                    "REQUIRE-MATCH")
                 "auto"
                 ))
         (save-restriction
           (narrow-to-region $p1 $p2)
           (when (string= $direction "auto")
             (goto-char (point-min))
             (setq $direction
                       "lengthen" "shorten"
                       )))
           (let ( (case-fold-search nil))
             (mapc
              (lambda ($x)
                (goto-char (point-min))
                (while (re-search-forward (elt $x 0) nil t)
                  (replace-match (elt $x 1) "FIXEDCASE" "LITERAL")))
              (if (string= $direction "shorten")
                  $shorten-map
                $lengeth-map))
             (goto-char (point-min))
             (while (re-search-forward "  +" nil t)
               (replace-match " " "FIXEDCASE" "LITERAL")))
           (goto-char (+ (point-min) 280)))))
 #+END_SRC

 2019-01-16 am still refining this command. So you may see some bad code
 here.

 --------------





 --------------



 Here's a command that fix datetime under cursor into yyyy-mm-dd format.

 #+BEGIN_SRC emacs-lisp
     (defun xah-fix-datetime (@begin @end)
       "Change timestamp under cursor into a yyyy-mm-dd format.
     If there's a text selection, use that as input, else use current line.
     Replace the text in selection or current line.

     Any “day of week”, or “time” info, or any other parts of the string, are discarded.
     For example:
      TUESDAY, FEB 15, 2011 05:16 ET → 2011-02-15
      November 28, 1994              → 1994-11-28
      Nov. 28, 1994                  → 1994-11-28
      11/28/1994                     → 1994-11-28
      1994/11/28                     → 1994-11-28

     Version 2020-09-08"
       (interactive
        (list
         (if (region-active-p) (region-beginning))
         (if (region-active-p) (region-end))))
       (require 'parse-time)
       (let ($p1 $p2 $in)
         (if @begin
             (setq $p1 @begin $p2 @end)
           (setq $p1 (line-beginning-position) $p2 (line-end-position)))
       ; remove white spaces

         (setq $in
               (cond

                ;; yyyy/mm/dd
                 (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))

                ;; mm/dd/yyyy
                 (concat (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
                ;; m/dd/yyyy
                 (concat (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

                ;; USA convention of mm/dd/yy
                 (concat (format-time-string "%C") (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
                ;; USA convention of m/dd/yy
                 (concat (format-time-string "%C") (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

                ;; some ISO 8601. yyyy-mm-ddThh:mm
                 (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
                ;; some ISO 8601. yyyy-mm-dd
                 (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
                ;; some ISO 8601. yyyy-mm
                 (concat (match-string 1 $in) "-" (match-string 2 $in)))

                ;; else
                (t
                 (progn
                   (setq $in (replace-regexp-in-string "January " "Jan. " $in))
                   (setq $in (replace-regexp-in-string "February " "Feb. " $in))
                   (setq $in (replace-regexp-in-string "March " "Mar. " $in))
                   (setq $in (replace-regexp-in-string "April " "Apr. " $in))
                   (setq $in (replace-regexp-in-string "May " "May. " $in))
                   (setq $in (replace-regexp-in-string "June " "Jun. " $in))
                   (setq $in (replace-regexp-in-string "July " "Jul. " $in))
                   (setq $in (replace-regexp-in-string "August " "Aug. " $in))
                   (setq $in (replace-regexp-in-string "September " "Sep. " $in))
                   (setq $in (replace-regexp-in-string "October " "Oct. " $in))
                   (setq $in (replace-regexp-in-string "November " "Nov. " $in))
                   (setq $in (replace-regexp-in-string "December " "Dec. " $in))


                   (let ($dateList $year $month $date $yyyy $mm $dd )
                     (setq $dateList (parse-time-string $in))
                     (setq $year (nth 5 $dateList))
                     (setq $month (nth 4 $dateList))
                     (setq $date (nth 3 $dateList))

                     (setq $yyyy (number-to-string $year))
                     (setq $mm (if $month (format "%02d" $month) "" ))
                     (setq $dd (if $date (format "%02d" $date) "" ))
                     (concat $yyyy "-" $mm "-" $dd))))))
         (delete-region $p1 $p2 )
         (insert $in)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun xah-fix-datetime-string (@datetime)
       "Return a new string of @datetime in yyyy-mm-dd format.
     Other datetime info such as hours, minutes, time zone, are discarded. This function calls `xah-fix-datetime' to do work.

     Version 2020-09-08"
       (with-temp-buffer
         (insert @datetime)
         (xah-fix-datetime (point-min) (point-max))
         (buffer-substring-no-properties (point-min) (point-max))))
 #+END_SRC

 The whole code is just one giant conditional test.

 #+BEGIN_SRC emacs-lisp
     (cond
      (TEST2 BODY)
      (TEST2 BODY)
      …
      )
 #+END_SRC

 In the code, the first few tests are regex match of forms like
 =nn/nn/nnnn= where each “n” is a digit. When any of these match, then
 basically i got what i want, and the code exits.

 When none of these match, then it goes to the end of the test
 =(t BODY)=, where the “t” there is always true, and run a big chunk of
 BODY. In the BODY, first i replace each full spelling of month names by
 their abbrev using =replace-regexp-in-string=, example

 #+BEGIN_SRC emacs-lisp
     (setq $str (replace-regexp-in-string "January " "Jan. " $str))
 #+END_SRC

 This is done because in emacs 22 the =parse-time-string= doesn't
 understand fully spelled month names. (this has been fixed in 23.2.1 or
 earlier.)

 Then, i also replace {1st, 2nd, nth} etc by {1, 2, n}, because emacs's
 =parse-time-string= doesn't understand those. Then, i simply feed it to
 =parse-time-string= and get a parsed date time as a list. After that,
 just extract the elements from the list and reformat the way i want
 using =format=.

***** Datetime

 - [[file:elisp_insert-date-time.html][Insert Date Time]]
 - [[file:elisp_datetime.html][Elisp: Print Date Time]]
 - [[file:elisp_parse_time.html][Elisp: Parse Date Time]]

 --------------





 --------------



 A little emacs lisp exercise. Writing command to count words.

 In emacs 23, there's =count-lines=, but no command to count words or
 characters. (=count-words= is now built-in in in emacs 24. [see
 [[file:emacs24_features.html][Emacs 24.1 Features (released 2012-06)]]])

 Here's how to write it.

 #+BEGIN_SRC emacs-lisp
     (defun my-count-words-region (posBegin posEnd)
       "Print number of words and chars in region."
       (interactive "r")
       (message "Counting …")
       (save-excursion
         (let (wordCount charCount)
           (setq wordCount 0)
           (setq charCount (- posEnd posBegin))
           (goto-char posBegin)
           (while (and (< (point) posEnd)
             (setq wordCount (1+ wordCount)))

           (message "Words: %d. Chars: %d." wordCount charCount)
           )))
 #+END_SRC

*** How It Works

 The function has this skeleton:

 #+BEGIN_SRC emacs-lisp
     (defun my-count-words-region (pos1 pos2)
       "…"
       (interactive "r")
       ; …
       )
 #+END_SRC

 the =(interactive "r")= means emacs will automatically fill your dummy
 variables {pos1, pos2} by region beginning/end positions. (region
 positions are integers) [see [[file:emacs_region.html][Elisp: Region,
 Active Region]]] [see [[file:elisp_interactive_form.html][Elisp:
 Interactive Form]]]

 The next part of the function is this:

 #+BEGIN_SRC emacs-lisp
     (save-excursion
      (let (var1 var2 …))
      (setq var1 …)
      (setq var2 …)
      …
     )
 #+END_SRC

 The =let= is lisp's way to have a block of local variables.

 The =(save-excursion …)= will run its body, then restore the cursor
 position and mark position. We need it because in the code we are going
 to move cursor around. When the command is finished, the cursor will be
 placed back to the position when user started the command.

 Now, to count the char, it is just the length of the beginning and
 ending position of the region. So, it is simple, like this:

 #+BEGIN_SRC emacs-lisp
     (setq charCount (- posEnd posBegin))
 #+END_SRC

 Now, we move the char to beginning of region, like this:
 =(goto-char posBegin)=. The next part, count the words, like this:

 #+BEGIN_SRC emacs-lisp
     (while (and (< (point) posEnd)
             (setq wordCount (1+ wordCount)))
 #+END_SRC

 The =(< (point) posEnd)= is for checking that the cursor havn't reached
 the end of region yet.

 cursor forward by regex search a word pattern. The “posEnd” argument
 there means don't search beyond the end of region. And the “t” there
 means don't report error if no more found.

 =search-forward= and =re-search-forward= are one of the top 10 most
 useful functions in elisp for text processing. If you are not familiar
 with them, lookup their doc string (with =describe-function=).

 So, the above “while” block, basically means keep moving the cursor and
 count words, until the cursor is at the end of region.

 Finally, the program just print out the result, by:

 #+BEGIN_SRC emacs-lisp
     (message "Words: %d. Chars: %d." wordCount charCount)
 #+END_SRC

*** Note

 The code shown on this page count words by emacs's syntax table, because
 character is classified into one or more categories. For example, the
 English alphabets are in the “word” class, punctuations characters are
 in “punctuation” class, etc. The current syntax table often depends on
 the major mode. [[../emacs_manual/elisp/Syntax-Tables.html][(info
 "(elisp) Syntax Tables")]]

 The disadvantage of syntax table is that, the result is unpredictable,
 dependent what the current major mode (and any minor mode or lisp code
 can change it). For example, this file (at this moment), is 1325 words
 when in “Fundamental” mode, but 1316 words when in “text-mode”. (863 by
 unix “wc” command.)

*** count-words-region-or-line

 Here's a version that will count the current line, if there's no text
 selection.

 #+BEGIN_SRC emacs-lisp
     (defun xah-count-words-region-or-line ()
       "Print number of words and chars in text selection or line.
     In emacs 24, you can use `count-words'."
       (interactive)
       (let (p1 p2)
         (if (region-active-p)
             (progn (setq p1 (region-beginning))
                    (setq p2 (region-end)))
           (progn (setq p1 (line-beginning-position))
                  (setq p2 (line-end-position))))
         (save-excursion
           (let (wCnt charCnt)
             (setq wCnt 0)
             (setq charCnt (- p2 p1))
             (goto-char p1)
               (setq wCnt (1+ wCnt)))
             (message "Words: %d. Chars: %d." wCnt charCnt)))))
 #+END_SRC

**** Introduction to Programming in Emacs Lisp by Robert J Chassell

 Note: “my-count-words-region” is largely from 〈Introduction to
 Programming in Emacs Lisp〉
 [[http://www.amazon.com/dp/1882114027/?tag=xahh-20][Buy at amazon]] by
 Robert J Chassell.

 This book is bundled with emacs since version 22. To view it in emacs,
 Alt+x =info= 【Ctrl+h i】, then click on the “Emacs Lisp Intro”.

 I was reading it sometimes in 2005. That tutorial is for people who
 never programed before. It was quite frustrating to read, because for
 every thing you learn, you have to scan some 10 pages of things you
 already know about programing, such as the meaning of {variables,
 assignment, syntax, ...}. In the end, i didn't really read that book.
 This function is about the only thing i got out of it.

 --------------





 --------------



 Here's a handy emacs lisp wrapper for converting current buffer's python
 2 script to python 3.

 #+BEGIN_SRC emacs-lisp
     (defun xah-python-2to3-current-file ()
       "Convert current buffer from python 2 to python 3.
     This command calls python3's script 「2to3」.
     Version 2016-02-16"
       (interactive)
       (let* (
              (fName (buffer-file-name))
              (fSuffix (file-name-extension fName)))
         (when (buffer-modified-p)
           (save-buffer))
         (if (or (string-equal fSuffix "py") (string-equal fSuffix "py3"))
             (progn
               (shell-command (format "2to3 -w %s" fName))
               (revert-buffer  "IGNORE-AUTO" "NOCONFIRM" "PRESERVE-MODES"))
           (error "file 「%s」 doesn't end in “.py” or “.py3”." fName))))
 #+END_SRC

 A handy command to go with it is
 [[file:elisp_run_current_file.html][Emacs: Run Current File]]

 See also: [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands
 Using Python, Ruby, ...]]

 --------------





 --------------



 This page shows a example of writing a emacs command to move a text
 block into a predefined set of files.

 when this command is called, it'll prompt you to select a category, then
 move the current block of text into a corresponding file.

 here it is:

 #+BEGIN_SRC emacs-lisp
     (defun xwe-move-word-to-page (@category)
       "Take current selection or block of text, ask which page to move it to."
       (interactive
        (list (ido-completing-read "Which:" '("specialwords"
                                              "arcane"
                                              "combowords"
                                              "easy"
                                              "foreignwords"
                                              "gre"
                                              "hyphwords"
                                              "informal"
                                              "slang"
                                              "noun"
                                              "noun_things"
                                              "noun_abs"
                                              "poesy"
                                              "satwords"
                                              "writerwords"))))
       (let (
             p1
             p2
             $wordText
             ($destFile (concat @category ".html")))
         (if (use-region-p)
             (progn
               (setq p1 (region-beginning))
               (setq p2 (region-end)))
           (save-excursion
             (if (re-search-backward "\n[ \t]*\n" nil "move")
                 (progn (re-search-forward "\n[ \t]*\n")
                        (setq p1 (point)))
               (setq p1 (point)))
             (if (re-search-forward "\n[ \t]*\n" nil "move")
                 (progn (re-search-backward "\n[ \t]*\n")
                        (setq p2 (point)))
               (setq p2 (point)))))

         (setq $wordText (buffer-substring-no-properties p1 p2))
         (delete-region p1 p2 )

         (find-file (concat (xahsite-server-root-path) "wordyenglish_com/words/" $destFile))
         (goto-char 1)
         (search-forward "<section class=\"word\">") (search-backward "<")
         (insert $wordText "\n\n")
         (save-buffer )
         (kill-buffer )
         (message "Word moved to 「%s」" $destFile)

         (let*
             ;; save the working buffer, but make backup first
             (($fname (buffer-file-name))
              ($backupName (concat $fname "~" (format-time-string "%Y%m%d_%H%M%S") "~")))
           (copy-file $fname $backupName t)
           (save-buffer ))))
 #+END_SRC

 So now, i press a key, then the text block under cursor is moved to a
 appropriate file in the appropriate location. This is used for my
 vocabulary collection page:
 [[http://wordyenglish.com/words/vocabulary.html][Wordy English:
 Vocabulary Compilation with Usage Examples]].

 Now, to move the current paragraph to a file, it takes me just 2
 seconds. Otherwise, it'll take about 15 seconds (using all emacs tricks
 to cut current text block, open/switch to the appropriate file, locate
 the position to insert, insert, save and close).

 You can use this code to refactor programing source code. You'll need to
 modify the list of category, and the section of
 =xahsite-server-root-path=

 --------------





 --------------



 This page shows a example of writing a emacs lisp command that updates a
 web feed file (Atom/RSS) on Local file system.

*** Problem

 Write a command, when called, the current text selection will be added
 as a entry in a Atom webfeed file.

 You'll learn how to write a command that grabs the region text, switch
 buffer, search string to locate position for inserting text, insert the
 text, and update date field in a file.

**** Detail

 I run several blogs on my personal website. For example, blog on
 [[file:blog.html][Emacs]],
 [[http://xahlee.info/kbd/keyboard_blog.html][keyboard]]
 [[http://xahlee.info/comp/blog.html][Programing]]. Each of these has a
 webfeed in Atom format.

 Let's take the emacs blog for example. The file name is =blog.html=.
 Typically, i open that file, write there, then save. The file sits on my
 local disk, and is periodically synced to my web server. For each of the
 blog file, there's also a corresponding webfeed, so that readers can
 subscribe to it.

 To create a webfeed, i've chosen the Atom format. Basically, it is a XML
 file with tags for blog entries. [see
 [[http://xahlee.info/js/atom.html][Atom Webfeed Tutorial]]]

 The Atom file is named =blog.xml= in the same dir.

 After i wrote some entry in my blog file =blog.html=, i'd like to be
 able to press a button, so the current text selection will automatically
 be added into my atom webfeed file =blog.xml= as a new entry.

*** Solution

 In the beginning few months, i just manually add the new writing from
 =blog.html= into the =blog.xml= file. But after a while, the pattern is
 clear, and can be automated. So, here are the major steps:

 - Grab the current text selection, lets call this “inputStr”. This will
   be the main content for the webfeed entry.
 - Open the Atom file corresponding to the current file.
 - Update the =<updated>= tag in the Atom file.
 - Insert a entry tag template into the Atom file at the right place.
 - Insert the “inputStr” in the proper location in the template entry.

 Here's various pieces of code that is required. I'll start to show, from
 the smallest components, to the final code that makes all this work.

**** Insert Time Stamp

 Here's a command to insert date stamp.

 #+BEGIN_SRC emacs-lisp
     (defun current-date-time-string ()
       "Returns current date-time string in full ISO 8601 format.
     Example: 「2012-04-05T21:08:24-07:00」.

     Note, for the time zone offset, both the formats 「hhmm」 and 「hh:mm」 are valid ISO 8601. However, Atom Webfeed spec seems to require 「hh:mm」."
       (concat
        (format-time-string "%Y-%m-%dT%T")
        ((lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")) )
       )
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     (defun insert-date-time ()
       "Insert current date-time string in full ISO 8601 format.
     Example: 「2010-11-29T23:23:35-08:00」.

     Replaces currents text selection if there's one.
     This function calls: `current-date-time-string'."
       (interactive)
       (when (use-region-p)
         (delete-region (region-beginning) (region-end) )
         )
       (insert (current-date-time-string)))
 #+END_SRC

 One returns a string, the other inserts it at current cursor position.

**** Generate a new Atom Entry ID

 Each atom entry has a “id” element like this:

 #+BEGIN_SRC emacs-lisp
     <id>‹id string›</id>
 #+END_SRC

 This id should be unique in the world. It should be in a URI format, and
 some other requirements, but otherwise there's no standardized method on
 what the string should be. [see [[http://xahlee.info/js/atom.html][Atom
 Webfeed Tutorial]]]

 Here's the code to generate this id that i've adopted, based on domain
 name, date, and unix epoch seconds.

 #+BEGIN_SRC emacs-lisp
     (defun new-atom-id-tag (&optional domainName)
       "Returns a newly generated ATOM webfeed's “id” element string.
     Example of return value: 「tag:xahlee.org,2010-03-31:022128」

     If DOMAINNAME is given, use that for the domain name.
     Else, use “xahlee.org”."
         (format "tag:%s%s" (if domainName domainName "xahlee.org") (format-time-string ",%Y-%m-%d:%H%M%S" (current-time) 1)) )
 #+END_SRC

**** Insert Atom Entry Template

 A entry in Atom format looks like this:

 #+BEGIN_SRC emacs-lisp
      <entry>
        <title>How To Insert Text In Emacs Lisp</title>
        <id>tag:xahlee.org,2010-01-02:234451</id>
        <updated>2010-01-02T15:44:51-08:00</updated>
        <summary>a short tutorial</summary>
        <content type="xhtml">
     <div xmlns="http://www.w3.org/1999/xhtml">
     <p>hi there, today i did this and that.</p>
     <p>and more HTML of the full content here …</p>
     </div>
        </content>
       <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
      </entry>
 #+END_SRC

 So, i need a command to insert this entry template.

 #+BEGIN_SRC emacs-lisp
     (defun insert-atom-entry (altLinkUrl)
       "Insert a Atom webfeed entry template,
      in the current buffer's cursor position."
       (interactive)
       (let (textToInsert domainName )
         (setq domainName "xahlee.org")
         (insert (format "
      <entry>
        <title>�</title>
        <id>%s</id>
        <updated>%s</updated>
        <summary>�</summary>
        <content type=\"xhtml\">
     <div xmlns=\"http://www.w3.org/1999/xhtml\">
     </div>
        </content>
       <link rel=\"alternate\" href=\"%s\"/>
      </entry>

     "
          (new-atom-id-tag domainName)
          (current-date-time-string)
          altLinkUrl
          ))
          ) )
 #+END_SRC

 Each Atom entry requires a link element, like this:

 #+BEGIN_SRC emacs-lisp
     <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
 #+END_SRC

 This link element is supposed to point to the perm link of the full
 article. This is set as a argument “altLinkUrl” to this function. The
 caller will fill it.

 The timestamp for the =<updated>= tag, and also id string for =<id>=
 tag, are auto-generated from the functions we wrote before.

 The content for =<title>…</title>= and =<summary>…</summary>= are not
 automatically created, because usually i don't have a title or summary
 for short blogs. Title and Summary are required by Atom, so i write them
 on the spot. I use a Unicode symbol REPLACEMENT CHARACTER � as a
 marker/reminder to fill them.

**** Updating Blog Date

 In the Atom file, at top there's a tag named “updated” that looks like
 this:

 #+BEGIN_SRC emacs-lisp
     <updated>2010-01-02T15:44:51-08:00</updated>
 #+END_SRC

 This needs to be updated whenever you have a new entry. So, here's the
 code for that:

 #+BEGIN_SRC emacs-lisp
     (progn
           (goto-char 1)
           (search-forward "<updated>" nil t)
           (delete-char 25)
           (insert-date-time))
 #+END_SRC

 It uses the function =insert-date-time= that we have defined earlier.

**** Final Code

 Finally, here's the command that calls all the above functions to do
 what i want.

 #+BEGIN_SRC emacs-lisp
     (defun make-blog-entry (begin end)
       "Create a Atom (RSS) entry of my emacs blog webfeed.
     Using selected text as Atom entry content.

     Also update the Atom file's overall “updated” tag.

     The feed is at 〔~/web/xahlee_org/emacs/blog.xml〕."
       (interactive "r")
       (let (inputStr currentFileDir currentFileName blogFileName blogFilePath altUrl)

         (setq inputStr (buffer-substring-no-properties begin end))
         (setq currentFileName (file-name-nondirectory (buffer-file-name)))
         (setq currentFileDir (file-name-directory (buffer-file-name))) ; ends in slash
         (setq blogFileName (concat (file-name-sans-extension (file-name-nondirectory currentFileName)) ".xml"))
         (setq blogFilePath (concat currentFileDir blogFileName))
         (setq altUrl "http://xahlee.org/emacs/blog.html")

         (find-file blogFilePath)
         (goto-char 1)
         (search-forward "<entry>" nil t)
         (beginning-of-line)
         (insert-atom-entry altUrl)
         (search-backward "<div xmlns=\"http://www.w3.org/1999/xhtml\">" nil t)
         (search-forward ">" nil t)
         (insert "\n" inputStr)
         ;; update atom date
         (progn
           (goto-char 1)
           (search-forward "<updated>" nil t)
           (delete-char 25)
           (insert-date-time))
         (search-forward ">�" nil t)
     )
     )
 #+END_SRC

 The code is pretty simple. First, it sets the current selected text to
 the variable “inputStr”, by
 =(setq inputStr (buffer-substring-no-properties begin end))=.

 Then, it sets several paths. The current buffer's file path, name, dir,
 and the corresponding blog file's path, name.

 After the several =setq=, then it opens the webfeed file, go to the
 beginning of file, search for the first occurrence of =<entry>=, and
 that's the point a new entry should be inserted.

 It then call =(insert-atom-entry altUrl)= to insert a new entry
 template.

 Then, it searches backward for the string
 =<div xmlns="http://www.w3.org/1999/xhtml">=. This is where the
 “content” part of the entry should be. The code then insert my content
 “inputStr” there.

 After that, we update the blog updated date, then we just move pointer
 to the next occurrence of �, so that when this code is done, the cursor
 is right at the Title tag part for user to edit.

 Emacs ♥

 --------------





 --------------



 This page shows a example of writing a emacs lisp function that update
 the page navigation tag of several files.

*** Problem

 I want to write a command, so that, when invoked, emacs will update
 several HTML page's page navigation tag.

 You will you learn how to grab the region text, parse them into a list,
 then use the list to generate a string, then go thru the list to open
 each file, insert the string, and do other modification on the file.

**** Detail

 I have a website of few thousand pages. Many of them are projects that
 span several HTML pages. At the bottom of each page is a navigation bar,
 like this:

 [[file:feed_0/article_23/images/img1.png]]

 The HTML looks like this:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page:
     <a href="projectB.html">1</a>,
     2,
     <a href="projectB-3.html">3</a>,
     <a href="projectB-4.html">4</a>
     </div>
 #+END_SRC

 If i want to add a new file for this series, let's say
 =projectB-5.html=, i have to manually edit every file's page navigation
 bar.

 It would be nice, if i could just list the file names in the current new
 page i just created, like this:

 #+BEGIN_SRC emacs-lisp
     projectB.html
     projectB-2.html
     projectB-3.html
     projectB-4.html
     projectB-5.html
 #+END_SRC

 Then, select them, press a button, and have all the page tags of all
 files updated. I decided to write this command.

*** Solution

 Here's the basic steps.

 - Get all the files names in text selection. (they should be one file
   name per line)
 - Delete this region's text.
 - Generate a new page nav string base on the file names we got.
 - Open each file, find the old page nav string. Delete it. Insert the
   new.
 - Optionally, save and close the files.

 Here's the code:

 #+BEGIN_SRC emacs-lisp
     (defun xah-update-page-tag (p1 p2)
       "Update HTML page navigation tags.

     The input is a text selection.
     Each line should a file name
     Update each file's page navigation tag.

     Each file name is a file path without dir, and relative to current dir.

     Example text selection for input::

     combowords.html
     combowords-2.html
     combowords-3.html
     combowords-4.html
     "
       (interactive "r")
       (let (fileList pageNavStr (i 1))
         (setq fileList
               (split-string (buffer-substring-no-properties p1 p2) "\n" t)
               )

         (delete-region p1 p2)

         ;; generate the page nav string
         (setq pageNavStr "<div class=\"pages\">Goto Page: ")

         (while (<= i (length fileList))
           (setq pageNavStr
                 (concat pageNavStr
                         "<a href=\""
                         (nth (- i 1) fileList)
                         "\">"
                         (number-to-string i)
                         "</a>, ")
                 )
           (setq i (1+ i))
           )

         (setq pageNavStr (substring pageNavStr 0 -2) ) ; remove the last ", "
         (setq pageNavStr (concat pageNavStr "</div>"))

         ;; open each file, inseart the page nav string, remove link in the
         ;; nav string that's the current page
         (mapc
          (lambda (thisFile)
            (message "%s" thisFile)
            (find-file thisFile)
            (goto-char (point-min))
            (search-forward "<div class=\"pages\">")
            (beginning-of-line)
            (kill-line 1)
            (insert pageNavStr)
            (search-backward (file-name-nondirectory buffer-file-name))
            (sgml-delete-tag 1)
     ;;        (save-buffer)
     ;;        (kill-buffer)
            )
          fileList)
     ))
 #+END_SRC

 First, we define the function with 2 parameters named {p1, p2}, and use
 =(interactive "r")=. This will automatically fill the parameters {p1,
 p2} with the beginning and ending positions of text selection.

 The next task is to grab this block of text, and turn it into a list,
 using =split-string=. This is done like this:

 #+BEGIN_SRC emacs-lisp
     (setq fileList
           (split-string (buffer-substring-no-properties p1 p2) "\n" t)
           )
 #+END_SRC

 Then, we want to generate the navbar string. This is done by using a
 =while= loop with a counter “i”. In each iteration, a string for the
 current file is generated, and is then appended to pageNavStr.

 This gives us the navbar string. The value of pageNavStr may be like
 this:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page:
     <a href="projB.html">1</a>,
     <a href="projB-2.html">2</a>,
     <a href="projB-3.html">3</a>
     </div>
 #+END_SRC

 However, it is not the final form. If current page is 2, then the navbar
 string should be like this:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page:
     <a href="projB.html">1</a>,
     2,
     <a href="projB-3.html">3</a>
     </div>
 #+END_SRC

 The next step is to open each file, insert the navbar string in the
 proper place, then take out the link of the current page. This is done
 by this code:

 #+BEGIN_SRC emacs-lisp
     (mapc
      (lambda (thisFile)
        (message "%s" thisFile)
        (find-file thisFile)
        (goto-char (point-min))
        (search-forward "<div class=\"pages\">")
        (beginning-of-line)
        (kill-line 1)
        (insert pageNavStr)
        (search-backward (file-name-nondirectory buffer-file-name))
        (sgml-delete-tag 1)
        )
      fileList)
 #+END_SRC

 The logic is this: We map a function to each file. The function will
 locate the existing navbar string, then delete that line, then insert
 the new navbar string, then move back to the location where the link to
 current file is at, then remove the link.

 The function =mapc= has this form: =(mapc function list)=, where it will
 apply function to each element in the list. =mapc= is different from
 =mapcar=. If you want the result to be a list, you need to use =mapcar=.
 Since we don't care for the resulting list, so we use =mapc=.

 The lambda above is our function. =lambda= has the form
 =(lambda (x) body)=, where x is the function's parameter, and body is
 one or more lisp expressions. In the “body” part, any x will be replaced
 with the argument received by lambda.

 In our lambda body, first we print out a messag informing user the
 current file it's working on, then we open the file, then search-forward
 to move the cursor to the navbar string location, delete it, then insert
 the new navbar string, then we use search-bacward to search for the
 current file's name. The current file's name is generated by calling
 =(file-name-nondirectory buffer-file-name)=. Once the cursor is at the
 location of current file in the navbar string, we call
 =sgml-delete-tag=, which will delete both the opening and closing HTML
 tags the cursor is on. The =sgml-delete-tag= is defined in =html-mode=.

 If we want to, we can add a =(save-buffer)= and =(kill-buffer)= to save
 and close the file, but for now i decided to leave the processed files
 open because sometimes i'm in the middle of editing them. It is easy to
 save and close a bunch of files using =ibuffer=.

 So, now with this function, suppose i created a new page =projB-5.html=.
 All i have to do is to list all the relevant files in the current
 buffer. This is easily done in emacs by Ctrl+u Alt+x =shell-command=,
 then type =ls projB*html=. Then, emacs will insert to the current buffer
 this text:

 #+BEGIN_SRC emacs-lisp
     projB.html
     projB-2.html
     projB-3.html
     projB-4.html
     projB-5.html
 #+END_SRC

 Then, i select them, then Alt+x =xah-update-page-tag=, then all the
 pages will be updated for me.

 Note that my file names are not necessarily regular like {“1.html”,
 “2.html”, “3.html”, ...}. Otherwise, our function doesn't need to take a
 list of file names from the region. It can just take one name and
 generate all others.

 --------------





 --------------



 This page shows emacs lisp commands to insert random {number, string,
 hexadecimal}.

 First, in your emacs init file, you should change the random seed, like
 this:

 #+BEGIN_SRC emacs-lisp
     (random t) ; seed random number
 #+END_SRC

 Else, every emacs restart, the sequence of random will be the same.

*** Insert Random Number

 #+BEGIN_SRC emacs-lisp
     (defun xah-insert-random-number (NUM)
       "Insert NUM random digits.
     NUM default to 5.
     Call `universal-argument' before for different count.
     Version 2017-05-24"
       (interactive "P")
       (let (($charset "1234567890" )
             ($baseCount 10))
         (dotimes (_ (if (numberp NUM) (abs NUM) 5 ))
           (insert (elt $charset (random $baseCount))))))
 #+END_SRC

*** Insert Random Hexadecimal

 #+BEGIN_SRC emacs-lisp
     (defun xah-insert-random-hex (NUM)
       "Insert NUM random hexadecimal digits.
     NUM default to 5.
     Call `universal-argument' before for different count.
     Version 2017-08-03"
       (interactive "P")
       (let (($n (if (numberp NUM) (abs NUM) 5 )))
         (insert (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n)))))))
 #+END_SRC

*** Insert Random String

 #+BEGIN_SRC emacs-lisp
     (defun xah-insert-random-string (NUM)
       "Insert a random alphanumerics string of length 5.
     The possible chars are: A to Z, a to z, 0 to 9.
     Call `universal-argument' before for different count.
     Version 2018-08-03"
       (interactive "P")
       (let* (($charset "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
              ($baseCount (length $charset)))
         (dotimes (_ (if (numberp NUM) (abs NUM) 5))
           (insert (elt $charset (random $baseCount))))))
 #+END_SRC

*** Insert Random UUID

 [[file:elisp_generate_uuid.html][Elisp: Insert Random UUID]]

 O emacs! ♥

 2010 Thanks to Teemu Likonen [tliko...@iki.fi] for improvement.

 --------------





 --------------



 Here's a emacs command to insert a UUID.

 #+BEGIN_SRC emacs-lisp
     (defun xah-insert-random-uuid ()
       "Insert a UUID.
     This commands calls “uuidgen” on MacOS, Linux, and calls PowelShell on Microsoft Windows.
     Version 2020-06-04"
       (interactive)
       (cond
        ((string-equal system-type "windows-nt")
         (shell-command "pwsh.exe -Command [guid]::NewGuid().toString()" t))
        ((string-equal system-type "darwin") ; Mac
         (shell-command "uuidgen" t))
        ((string-equal system-type "gnu/linux")
         (shell-command "uuidgen" t))
        (t
         ;; code here by Christopher Wellons, 2011-11-18.
         ;; and editted Hideki Saito further to generate all valid variants for "N" in xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx format.
         (let ((myStr (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                                   (user-uid)
                                   (emacs-pid)
                                   (system-name)
                                   (user-full-name)
                                   (current-time)
                                   (emacs-uptime)
                                   (garbage-collect)
                                   (buffer-string)
                                   (random)
                                   (recent-keys)))))
           (insert (format "%s-%s-4%s-%s%s-%s"
                           (substring myStr 0 8)
                           (substring myStr 8 12)
                           (substring myStr 13 16)
                           (format "%x" (+ 8 (random 4)))
                           (substring myStr 17 20)
                           (substring myStr 20 32)))))))
 #+END_SRC

 Thanks to Christopher Wellons [[[http://nullprogram.com/]]] , Hideki
 Saito [[http://hideki.hclippr.com/2014/02/02/on-generating-uuid/]] . And
 [Yuri Khan +https://plus.google.com/+YuriKhan/posts+], Jon Snader
 [[http://irreal.org/blog/]] for discussion about UUID.

 --------------





 --------------



 This page shows you how to write a emacs lisp script to search files,
 similar to unix grep.

 Here's a very simple version. It reports number of matches.

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; print file names of files that have n occurrences of a string, of a given dir
     ;; version 2019-01-13

     ;; input dir
     ;; In elisp, dir path should end with a slash
     (setq inputDir "/Users/xah/web/ergoemacs_org/" )

     (setq findStr "stuff")

     (defun my-process-file (fPath)
       "Process the file at FPATH "
       (let (myBuffer p1 p2 (ii 0) searchStr)
         (when (and (not (string-match "/xx" fPath))) ; exclude some dir

           (with-temp-buffer
             (insert-file-contents fPath nil nil nil t)

             (setq searchStr findStr  )

             (goto-char 1)
             (while (search-forward searchStr nil t)
               (setq ii (1+ ii)))

             ;; report if the occurrence is not n times
             (when (not (= ii 0))
               (princ (format "%d %s\n" ii fPath)))))))

     ;; walk the dir
     (let (outputBuffer)
       (setq outputBuffer "*my find output*" )
       (with-output-to-temp-buffer outputBuffer
         (mapc 'my-process-file
               (directory-files-recursively inputDir "\.html$" ))
         (princ "Done")))
 #+END_SRC

 At the bottom, the code visits every file in a dir. For each file, it
 calls =my-process-file= . That function creates a temp buffer, inserts
 the file content in it, then do search inside the temp buffer. We use a
 temp buffer because it's faster. [see
 [[file:elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp Text
 Processing: find-file vs with-temp-buffer]]]

 To run the file, just Alt+x =eval-buffer=. [see
 [[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

 On 9838 html files, the script takes 40 seconds on a “Late 2014” Mac
 Mini computer, when files are not cached, on a spinning harddisk.

 When running a second time, it just take 6 seconds.

**** What's wrong with unix grep command?

 See: [[file:emacs_grep_problem.html][Problems of Calling Unix grep in
 Emacs]].

**** Emacs Package: xah-find.el

 For the full featured version of this command, see the package
 [[file:elisp-xah-find-text.html][Emacs: xah-find.el, Find Replace in
 Pure Elisp]].

***** Find Replace Scripts

 - [[http://xahlee.info/golang/goland_find_string.html][Golang: Find
   String (grep)]]
 - [[http://xahlee.info/golang/goland_find_replace.html][Golang: Find
   Replace Script]]
 - [[http://xahlee.info/python/find_replace_dir.html][Python: Find
   Replace in a Dir]]
 - [[http://xahlee.info/python/findreplace_regex.html][Python: Find
   Replace by Regex]]
 - [[http://xahlee.info/perl/perl_find_replace_in_dir.html][Perl: Find
   Replace String Pairs in Directory]]
   Write grep]]
   xah-find.el, Find Replace in Pure Elisp]]

 --------------





 --------------



 This page shows a emacs lisp script that search files, similar to unix
 grep, but with the condition that the string must happen inside a
 specific HTML tag.

*** Problem

 I need to list all files that contains a given string, and only if the
 string is inside a given HTML tag. That is, the condition that some
 strig must happen before and after the string we want.

 This is something grep and linux shell commands cannot do easily, and
 difficult to do even with Perl, Python, unless you use a HTML parser
 (which gets complex).

*** Solution

 Here's the code:

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2011-02-25, 2019-01-13
     ;; print files that meet this condition:
     ;; contains <div class="xnote">…</div>
     ;; where the text content contains more than one bullet char •

     (setq inputDir "/Users/xah/web/wordyenglish_com/arabian_nights/" ) ; dir should end with a slash

     ;; need sgml-skip-tag-forward
     (require 'sgml-mode)

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (myBuffer
             p3 p4  (bulletCount 0) )

         ;; (print fPath)

         (when
             (and (not (string-match "/xx" fPath))) ; skip some dir

           (setq myBuffer (get-buffer-create " myTemp"))
           (set-buffer myBuffer)
           (insert-file-contents fPath nil nil nil t)

           (setq bulletCount 0 )
           (goto-char 1)
           (while
               (search-forward "<div class=\"xnote\">"  nil t)

             (setq p3 (point)) ; beginning of innerText, after <div class="xnote">
             (backward-char)
             (sgml-skip-tag-forward 1)
             (backward-char 6)
             (setq p4 (point)) ; end of innerText, before </div>

             (setq bulletCount (count-matches "•" p3 p4))

             (when (> bulletCount 1)
               (princ (format "Found: %d %s\n" bulletCount fPath))))

           (kill-buffer myBuffer))))

     (let (outputBuffer)
       (setq outputBuffer "*my output*" )
       (with-output-to-temp-buffer outputBuffer
         (mapc 'my-process-file
               (directory-files-recursively inputDir "\.html$" ))
         (princ "Done")))
 #+END_SRC

*** Find Replace Applications

 Find, or Find Replace, has extensive use in text processing. Here's some
 examples of variations, all of which i need on weekly basis and have
 several elisp scripts to do the job:

 - List file that contains a string.
 - Show adjacent text around a string.
 - List a file only if it contains more than 1 occurence of a string. (or
   more than n, less than n, exactly n.)
 - List file if it contains a given set of strings.
 - Replace text based on file's name.
 - List file only if its HTML title and heading doesn't match.
 - Find/Report/Replace only if the string is at a particular position in
   the file. (For example, near top, near bottom.)
 - List a file only if the string is inside a tag.

*** Why I Wrote This Code

 Here's a little story on why i wrote this one.

 I have about 30 classic literature with annotations. For example:
 [[http://wordyenglish.com/arabian_nights/index.html][The Arabian
 Nights]].

 Each annotation are in the tag =<div class="xnote">…</div>=. e.g.

 #+BEGIN_SRC emacs-lisp
     <div class="xnote">• provaunt ⇒ provide. Provant is a verb meaning: To supply with provender or provisions.</div>
 #+END_SRC

 However, some “xnote” block is multiple annotations in one. e.g.

 #+BEGIN_SRC emacs-lisp
     <div class="xnote">• stint ⇒ a fixed amount or share work.
     • might and main ⇒ with all effort and strength.
     • skein ⇒ A quantity of yarn, thread, or the like, put up together, after it is taken from the reel.
     • buffet ⇒ hit, beat, especially repeatedly.
     • fain ⇒ with joy; satisfied; contented.
     </div>
 #+END_SRC

 Each of the annotation are marked by a bullet “•” symbol, followed by a
 word. Each word corresponds to the same word in the main text marked by
 =<span class="xnt">…</span>=.

 This annotation system is not perfect. It is static HTML/CSS. Recently
 i've been thinking of making it more dynamic based on JavaScript. With
 JavaScript, it's possible to have features such as hide/show annotation
 when mouse over the the word.

 [see [[http://xahlee.info/js/js.html][JavaScript in Depth]]]

 To make that possible, i need to make sure of few things:

 - ① My custom markup must have precise semantics.
 - ② The syntax should be as simple as possible. (else the JavaScript
   will have to do more work.)
 - ③ The HTML annotation markup must follow strict form. (else JavaScript
   will fail silently)

 With my current system, a annotation block is contained in a “xnote”
 tag, and within that block, each annotation is marked by a bullet. This
 semantic is precise, but isn't simple enough. If i want JavaScript to
 automatically highlight the annotation text when user mouse-over a
 annotated word, the js will have to do some parsing of text in the
 “xnote” block.

 It would be simpler, if each “xnote” block contains just ONE annotation.
 This means, i will first change all my files that contain
 multi-annotation blocks to make them 1-annotation per xnote block. This
 is a text processing job. (Hello emacs lisp!)

 Before doing text transformation on the xnote blocks, first i need to
 make sure the text has correct syntax. For example: make sure that each
 “xnote” do indeed contain at least one bullet symbol, and make sure that
 each =<span class="xnt">…</span>= has a corresponding
 =<div class="xnote">…</div>=.

 So, that's why i wrote this script. I wanted to get some idea of how
 many “xnote” blocks in which files actually contain multi-annotations.

 The elisp code to split xnote block to multiple is very similar to the
 elisp code here.

 --------------





 --------------



 Here's a command to check if parentheses or brackets or curly quotes are
 balanced.

 #+BEGIN_SRC emacs-lisp
     (defun xah-check-parens-balance ()
       "Check if there are unbalanced parentheses/brackets/quotes in current bufffer or selection.
     If so, place cursor there, print error to message buffer.

     Version 2018-07-03"
       (interactive)
       (let* (
              ($bracket-alist
               '( (?“ . ?”) (?‹ . ?›) (?« . ?») (?【 . ?】) (?〖 . ?〗) (?〈 . ?〉) (?《 . ?》) (?「 . ?」) (?『 . ?』) (?{ . ?}) (?\[ . ?\]) (?\( . ?\))))
              ;; regex string of all pairs to search.
              ($bregex
               (let (($tempList nil))
                 (mapc
                  (lambda (x)
                    (push (char-to-string (car x)) $tempList)
                    (push (char-to-string (cdr x)) $tempList))
                  $bracket-alist)
                 (regexp-opt $tempList )))
              $p1
              $p2
              ;; each entry is a vector [char position]
              ($stack '())
              ($char nil)
              $pos
              $is-closing-char-p
              $matched-open-char
              )
         (if (region-active-p)
             (setq $p1 (region-beginning) $p2 (region-end))
           (setq $p1 (point-min) $p2 (point-max)))

         (save-excursion
           (save-restriction
             (narrow-to-region $p1 $p2)
             (progn
               (goto-char 1)
               (while (re-search-forward $bregex nil "move")
                 (setq $pos (point))
                 (setq $char (char-before))
                 (progn
                   (setq $is-closing-char-p (rassoc $char $bracket-alist))
                   (if $is-closing-char-p
                       (progn
                         (setq $matched-open-char
                               (if $is-closing-char-p
                                   (car $is-closing-char-p)
                                 (error "logic error 64823. The char %s has no matching pair."
                                        (char-to-string $char))))
                         (if $stack
                             (if (eq (aref (car $stack) 0) $matched-open-char )
                                 (pop $stack)
                               (push (vector $char $pos) $stack ))
                           (progn
                             (goto-char $pos)
                             (error "First mismtach found. the char %s has no matching pair."
                                    (char-to-string $char)))))
                     (push (vector $char $pos) $stack ))))
               (if $stack
                   (progn
                     (goto-char (aref (car $stack) 1))
                     (message "Mismtach found. The char %s has no matching pair." $stack))
                 (print "All brackets/quotes match.")))))))
 #+END_SRC

 --------------



 <<index.html>>


 --------------



 This page shows you how to write a elisp script that checks thousands of
 files for mismatched brackets.

*** Problem

 Write a emacs lisp script to process 5 thousands files and check for
 mismatched brackets.

 The matching pairs includes these: () {} [] “” ‹› «» 〈〉 《》 【】 〖〗
 「」 『』. [see
 [[http://xahlee.info/comp/unicode_matching_brackets.html][Unicode:
 Brackets, Quotes «»「」【】《》]]]

 The program should be able to check all files in a dir, and report any
 file that has mismatched bracket, and also indicate the line number or
 position where a mismatch occurs.

*** Solution

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8; lexical-binding: t; -*-
     ;; 2011-07-15 , 2020-04-12
     ;; spec at http://xahlee.org/comp/validate_matching_brackets.html
     ;; by Xah Lee.

     ;; go thru a file, check if all brackets are properly matched.
     ;; e.g. good: (…{…}… “…”…)
     ;; bad: ( [)]
     ;; bad: ( ( )

     (setq inputFile "xx_test_file.txt" ) ; a test file.
     (setq inputDir "/Users/xah/web/ergoemacs_org/emacs/") ; must end in slash

     (defvar matchPairs '() "a alist. For each pair, the car is opening char, cdr is closing char.")
     (setq matchPairs '(
                        ;; ("(" . ")")
                        ;; ("{" . "}")
                        ;; ("[" . "]")
                        ;; ("“" . "”")
                        ;; ("‹" . "›")
                        ;; ("«" . "»")
                        ("【" . "】")
                        ;; ("〖" . "〗")
                        ;; ("〈" . "〉")
                        ;; ("《" . "》")
                        ;; ("「" . "」")
                        ;; ("『" . "』")
                        )
           )

     (defvar searchRegex "" "regex string of all pairs to search.")
     (setq searchRegex "")
     (mapc
      (lambda (mypair) ""
        (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
        )
      matchPairs)

     (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”


     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (myBuffer myStack $char $pos)

         (setq myStack '()) ; each entry is a vector [char position]
         (setq $char "")     ; the current char found

         (when t
           ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

           (setq myBuffer (get-buffer-create " myTemp"))
           (set-buffer myBuffer)
           (insert-file-contents fPath nil nil nil t)

           (goto-char 1)
           (while (re-search-forward searchRegex nil t)
             (setq $pos (point))
             (setq $char (buffer-substring-no-properties $pos (- $pos 1)))


             (let ((isClosingCharQ nil) (matchedOpeningChar nil))
               (setq isClosingCharQ (rassoc $char matchPairs))
               (when isClosingCharQ (setq matchedOpeningChar (car isClosingCharQ)))

               ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
               ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

               (if
                   (and
                    (car myStack) ; not empty
                    (equal (elt (car myStack) 0) matchedOpeningChar ))
                   (progn
                     ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                     (setq myStack (cdr myStack)))
                 (progn
                   ;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
                   (setq myStack (cons (vector $char $pos) myStack)))))
             ;; (princ "current stack: " )
             ;; (princ myStack )
             ;; (terpri )
             )

           (when (not (equal myStack nil))
             (princ "Error file: ")
             (princ fPath)
             (print (car myStack)))
           (kill-buffer myBuffer))))

     (let (outputBuffer)
       (setq outputBuffer "*xah match pair output*" )
       (with-output-to-temp-buffer outputBuffer
         ;; (my-process-file inputFile) ; use this to test one one single file
         (mapc 'my-process-file
         (princ "Done deal!")))
 #+END_SRC

 I added many comments and debug code for easy understanding. If you are
 not familiar with the many elisp idioms such as opening file, buffers,
 printing to output, see: [[file:elisp_idioms.html][Elisp: How to Write
 Commands]] • [[file:elisp_idioms_batch.html][Text Processing with Emacs
 Lisp Batch Style]].

 To run the code, simply open it in emacs. Edit the line at the top for
 “inputDir”. Then call =eval-buffer=.

 Here's a sample output:

 #+BEGIN_SRC emacs-lisp
     Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter_orig.txt
     [")" 3625]
     Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter.txt
     [")" 2338]
     Error file: c:/Users/h3/web/xahlee_org/p/arabian_nights/xx/v1fn.txt
     ["”" 185795]
     Done deal!
 #+END_SRC

*** Code Explanation

 Here's outline of steps.

 - Go thru the file char-by-char, find a bracket char.
 - Check if the one on stack is a matching opening char. If so remove it.
   Else, push the current onto the stack. (think of stack as stack of
   books. You put one on top (called =push=), and take one out from top
   too (called =pop=).)
 - Repeat the above till no more bracket char in the file.
 - If the stack is not empty, then the file got mismatched brackets.
   Report it.
 - Do the above on all files.

 Here's some interesting use of lisp features to implement the above.

**** Define Matching Pair Chars as “alist”

 We begin by defining the chars we want to check, as a “association
 list”. Like this:

 #+BEGIN_SRC emacs-lisp
     (setq matchPairs '(
                        ("(" . ")")
                        ("{" . "}")
                        ("[" . "]")
                        ("“" . "”")
                        ("‹" . "›")
                        ("«" . "»")
                        ("【" . "】")
                        ("〖" . "〗")
                        ("〈" . "〉")
                        ("《" . "》")
                        ("「" . "」")
                        ("『" . "』")
                        )
           )
 #+END_SRC

 [see [[file:elisp_association_list.html][Elisp: Association List]]]

 If you care only to check for curly quotes, you can remove elements
 above. This is convenient because some files necessarily have mismatched
 pairs such as the parenthesis, because that char is used for many
 non-bracketing purposes (For example, ASCII smiley).

**** Generate Regex String from alist

 To search for a set of chars in emacs, we can read the buffer
 char-by-char, or, we can simply use =search-forward-regexp=. To use
 that, first we need to generate a regex string from our matchPairs
 alist. For example, if we want to search “〈〉《》”, then our regex

 First, we define/declare the string. Not a necessary step, but we do it
 for clarity.

 #+BEGIN_SRC emacs-lisp
     (setq searchRegex "")
 #+END_SRC

 Then we go thru the matchPairs alist. For each pair, we use =car= and
 =cdr= to get the chars and =concat= it to the string. Like this:

 #+BEGIN_SRC emacs-lisp
     (mapc
      (lambda (mypair) ""
        (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
        )
      matchPairs)
 #+END_SRC

 Then we remove the ending =|=.

 #+BEGIN_SRC emacs-lisp
     (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending “|”
 #+END_SRC

 “regex or” is =\|=. Elisp does not have a special regex string syntax,
 it only understands normal strings. So, to feed to regex =\|=, you need
 to espace the first backslash. So, the string for regex needs to be

 #+BEGIN_SRC emacs-lisp
 #+END_SRC

 See also: [[file:emacs_regex.html][emacs regex tutorial]].

**** Implement Stack Using Lisp List

 Stack is done using lisp's list. For example: ='(1 2 3)=. The top of
 stack is the first element. To add to the stack, do it like this:
 =(setq mystack (cons newitem mystack))=. To remove a item from stack is
 this: =(setq mystack (cdr mystack))=. The stack start as a empty list:
 ='()=.

 For each entry in the stack, we put the char and also its position, so
 that we can report the position if the file does have mismatched pairs.

 We use a vector as entries for the stack. Each entry is like this:
 =(vector char pos)=. [see [[file:elisp_vector.html][Elisp: Vector]]]

 Here's how to fetch a char from alist, and push to stack, pop from
 stack.

 #+BEGIN_SRC emacs-lisp
     ; check if current char is a closing char and is in our match pairs alist.
     ; use “rassoc” to check alist's set of “values”.
     ; It returns the first key/value pair found, or nil
     (rassoc char matchPairs)

     ; add to stack
     (setq myStack (cons (vector char pos) myStack) )

     ; pop stack
     (setq myStack (cdr myStack) )
 #+END_SRC

**** Advantages of Emacs Lisp

 Note that the great advantage of using elisp for text processing,
 instead of {Perl, Python, Ruby, ...} is that many things are taken care
 by the emacs environment.

 I don't need to write code to deal with file encoding (emacs
 automatically does it). No reading file is involved. Just “open” or
 “save” the file. Processing a file is simply moving cursor thru
 characters or lines, changing parts of it. No code needed for doing
 safety backup. Emacs automatically does backup if you made any changes,
 and can be turned off by setting the built-in var “make-backup-files” to
 nil. For file paths in the output, you can easily open it by a click or
 key press. I can add just 2 lines so that clicking on the error char in
 the output jumps to the location in the file.

 Any elisp script you write inside emacs automatically becomes a
 extension of emacs and can be used in a interactive way. Or, you could
 run it in a command line shell, for example,
 =emacs --script process_log.el=.

 This problem is posted to a few comp.lang newsgroups as a fun challenge.
 See:
 [[http://xahlee.info/comp/validate_matching_brackets.html][Programing
 Exercise, Validate Matching Brackets]].

 --------------





 --------------

** Elisp: Generate Web Links Report

 Here's how to use elisp to process files in a directory, searching for a
 text pattern, and generate a report.

*** Problem

 You have 7 thousand HTML files. You want to generate a report that lists
 all links to Wikipedia, and the file path the link is from.

 In this tutorial, you'll learn:

 - how to walk a directory. [see [[file:elisp_traverse_dir.html][Elisp:
   Walk Directory]]]
 - how to build a hash-table. [see [[file:elisp_hash_table.html][Elisp:
   Hash Table]]]
 - elisp idiom for fast opening large number of files.

*** Solution

 Here are the basic steps we need:

 - Given a file, extract links and put them into a hash table.
 - Use elisp to traverse a given directory, open each file.
 - Some pretty printing functions. For example, convert a URL string into
   HTML link string.

 Once we have the data in a hash-table, it is very flexible. We can then
 generate a report in plain text or HTML, or do other processing.

**** Hash Table

 First, we'll need to know how to use hash table in emacs. Here's a
 simple example:

 #+BEGIN_SRC emacs-lisp
     ;; create a hash table
     (setq myhash (make-hash-table :test 'equal))

     ;; add entries
     (puthash "Joe" "19" myhash)
     (puthash "Jane" "20" myhash)
     (puthash "Liz" "21" myhash)

     ;; add/modify
     (puthash "Jane" "16" myhash)

     ;; get or check existence
     (setq val (gethash "Jane" myhash))

     (message val) ; print it
 #+END_SRC

 [see [[file:elisp_hash_table.html][Elisp: Hash Table]]]

**** Process a Single File

 we want the hash table key to be the full URL string, and the value a
 list. Each element in the list is the full path of the file that
 contains the link.

 Here is the code that processes a single file. It opens the file, search
 for URL, if found, check if it exist in hash, if not, add it, else
 append to the existing entry.

 #+BEGIN_SRC emacs-lisp
     (setq myfile "/Users/xah/web/ergoemacs_org/emacs/GNU_Emacs_dev_inefficiency.html")

     (setq myhash (make-hash-table :test 'equal))

     (defun ff ()
       "test code to process a single file"
       (interactive)
       (let ( myBuff url)

         (setq myBuff (find-file myfile)) ; open file

         (goto-char (point-min))

         ;; search for URL till not found
         (while
             (re-search-forward
              nil t)

           (when (match-string 0)        ; if URL found
             (setq url (match-string 1)) ; set the url to matched string

             (print url)

             ;; if exist in hash, prepend to existing entry, else just add
             (if (gethash url myhash)
                 (puthash url (cons myfile (gethash url myhash)) myhash)
               (puthash url (list myfile) myhash))))

         (kill-buffer myBuff) ; close file
         ))

     (ff)

     (print myhash)
 #+END_SRC

**** Walk a Directory

 #+BEGIN_SRC emacs-lisp
     (mapc
      'ff
      (directory-files-recursively "~/web/ergoemacs_org/" "\.html$" ))
 #+END_SRC

 [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]

**** Pretty Print Helpers

 Given a Wikipedia URL, returns a HTML link string.

 For example:

 =http://en.wikipedia.org/wiki/Emacs=

 becomes

 =<a href="http://en.wikipedia.org/wiki/Emacs">Emacs</a>=

 #+BEGIN_SRC emacs-lisp
     (require 'gnus-util) ; for gnus-url-unhex-string

     (defun wikipedia-url-to-link (url)
       "Return the URL as HTML link string.
     Example:
      http://en.wikipedia.org/wiki/Emacs%20Lisp
     becomes
      <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
     "
       (let ((linkText url))
         (setq linkText (gnus-url-unhex-string linkText nil)) ; decode percent encoding. For example: %20
         (setq linkText (car (last (split-string linkText "/")))  ) ; get last part
         (setq linkText (replace-regexp-in-string "_" " " linkText )  ) ; low line → space
         (format "<a href=\"%s\">%s</a>" url linkText)
         ))
 #+END_SRC

 Given a file path, return a link string.

 For example:

 =/Users/xah/web/ergoemacs_org/index.html=

 becomes

 =<a href="../index.html">ErgoEmacs</a>=

 , where the link text came from the file's “title” tag.

 #+BEGIN_SRC emacs-lisp
     (defun get-html-file-title (fName)
       "Return FNAME <title> tag's text.
     Assumes that the file contains the string
     “<title>…</title>”."
       (with-temp-buffer
           (insert-file-contents fName nil nil nil t)
           (goto-char 1)
           (buffer-substring-no-properties
            (search-forward "<title>") (- (search-forward "</title>") 8))
           ))
 #+END_SRC

*** Putting It All Together

 #+BEGIN_SRC emacs-lisp
      ;; -*- coding: utf-8; lexical-binding: t; -*-
     ;; emacs lisp.

     ;; started: 2008-01-03.
     ;; version: 2019-06-11
     ;; author: Xah Lee
     ;; purpose: generate a report of wikipedia links.

     ;; traverse a given dir, visiting every html file, find links to Wikipedia in those files, collect them, and generate a html report of these links and the files they are from, then write it to a given file. (overwrite if exist)

     &#12;

     (setq InputDir "/Users/xah/web/ergoemacs_org/" )

     ;; Overwrites existing
     (setq OutputPath "/Users/xah/web/xahlee_org/wikipedia_links.html")

     &#12;

     ;; add a ending slash to InputDir if not there
     (when (not (string= "/" (substring InputDir -1) )) (setq InputDir (concat InputDir "/") ) )

     (when (not (file-exists-p InputDir)) (error "input dir does not exist: %s" InputDir))

     (setq XahHeaderText
     "<!doctype html><html><head><meta charset=\"utf-8\" />
     <title>Links to Wikipedia from Xah Sites</title>
     </head>
     <body>

     <nav class=\"n1\"><a href=\"index.html\">XahLee.org</a></nav>
     ")

     (setq XahFooterText
       "
     </body></html>
     "
     )

     &#12;

     ;; hash table. key is string Wikipedia url, value is a list of file paths.
     (setq LinksHash (make-hash-table :test 'equal :size 8000))

     &#12;

     (defun xah-add-link-to-hash (filePath hashTableVar)
       "Get links in filePath and add it to hash table at the variable hashTableVar."
       (let ( $wUrl)
         (with-temp-buffer
           (insert-file-contents filePath nil nil nil t)
           (goto-char 1)
           (while
               (re-search-forward
                nil t)
             (setq $wUrl (match-string 1))
             (when (and
                    $wUrl ; if url found
                    (not (string-match "=" $wUrl )) ; do not includes links that are not Wikipedia articles. e.g. user profile pages, edit history pages, search result pages
                    (not (string-match "%..%.." $wUrl )) ; do not include links that's lots of unicode
                    )

               ;; if exist in hash, prepend to existing entry, else just add
               (if (gethash $wUrl hashTableVar)
                   (puthash $wUrl (cons filePath (gethash $wUrl hashTableVar)) hashTableVar) ; not using add-to-list because each Wikipedia URL likely only appear once per file
                 (puthash $wUrl (list filePath) hashTableVar)) )) ) ) )

     (defun xah-print-each (ele)
       "Print each item. ELE is of the form (url (list filepath1 filepath2 …)).
     Print it like this:
     ‹link to url› : ‹link to file1›, ‹link to file2›, …"
       (let ($wplink $files)
         (setq $wplink (car ele))
         (setq $files (cadr ele))

         (insert "<li>")
         (insert (wikipedia-url-to-linktext $wplink))
         (insert "—")

         (dolist (xx $files nil)
           (insert
            (format "<a href=\"%s\">%s</a>•"
                    (xahsite-filepath-to-href-value xx OutputPath )
                    (xah-html-get-html-file-title xx))))
         (delete-char -1)
         (insert "</li>\n"))
       )

     &#12;

     (defun wikipedia-url-to-linktext (@url)
       "Return the title of a Wikipedia link.
     Example:
     http://en.wikipedia.org/wiki/Emacs
     becomes
     Emacs"
       (require 'url-util)
       (decode-coding-string
        (url-unhex-string
         (replace-regexp-in-string
          "_" " "
          (replace-regexp-in-string
           "&" "＆"
           (car
            (last
             (split-string
              @url "/")))))) 'utf-8))

     (defun wikipedia-url-to-link (@url)
       "Return the @url as html link string.\n
     Example:
     http://en.wikipedia.org/wiki/Emacs
     becomes
     <a href=\"http://en.wikipedia.org/wiki/Emacs\">Emacs</a>"
       (format "<a href=\"%s\">%s</a>" @url (wikipedia-url-to-linktext @url)))

     (defun xah-hash-to-list (@hash-table)
       "Return a list that represent the @HASH-TABLE
     Each element is a list: '(key value).

     Version 2019-06-11"
       (let ($result)
         (maphash
          (lambda (k v)
            (push (list k v) $result))
          @hash-table)
         $result))

     &#12;
     ;;;; main

     ;; fill LinksHash
     (mapc
        (lambda ($x) (xah-add-link-to-hash $x LinksHash ))
        (directory-files-recursively InputDir  "\.html$" ))

     ;; fill LinksList
     (setq LinksList
           (sort (xah-hash-to-list LinksHash)
                 ;; (hash-table-keys LinksHash)
                 (lambda (a b) (string< (downcase (car a)) (downcase (car b))))))

     ;; write to file
     (with-temp-file OutputPath
       (insert XahHeaderText)
       (goto-char (point-max))

       (insert
        "<h1>Links To Wikipedia from XahLee.org</h1>\n\n"
        "<p>This page contains all existing links from xah sites to Wikipedia, as of ")

       (insert (format-time-string "%Y-%m-%d"))

       (insert
        ". There are a total of " (number-to-string (length LinksList)) " links.</p>\n\n"

     "
        )

       (insert "<ol>\n")

       (mapc 'xah-print-each LinksList)

       (insert "</ol>

     ")

       (insert XahFooterText)
       (goto-char (point-max)))

     ;; clear memory
     ;; (clrhash LinksHash)
     ;; (setq LinksList nil)

     ;; open the file
     (find-file OutputPath )
 #+END_SRC

 Emacs ♥

 --------------





 --------------

** Elisp: Create Sitemap

 This page shows how to use emacs lisp to create a sitemap.

*** Problem

 Write a elisp script to generate a sitemap. That is: create a file of
 sitemap format that lists all files in a directory.

**** Detail

 A sitemap is a XML file that lists URLs of all files in a website for
 web crawlers to crawl.

 A sitemap file looks like this:

 #+BEGIN_SRC emacs-lisp
     <?xml version="1.0" encoding="UTF-8"?>
     <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

        <url>
           <loc>http://www.example.com/</loc>
           <lastmod>2005-01-01</lastmod>
           <changefreq>monthly</changefreq>
           <priority>0.8</priority>
        </url>

        …

     </urlset>
 #+END_SRC

 1. The file can have many =<url>…</url>= item.
 2. Each =<url>= container represent a file and other info.
 3. The =<loc>= is a URL of the file.
 4. The =<lastmod>=, =<changefreq>=, =<priority>= are optional.
 5. A sitemap file can list a max of 50k URLs.

 The purpose of sitemap file is for web crawlers to easily know all files
 that exist on your site.

*** Solution

 The general plan is very simple. Here's one way to do it.

 1. Create a new file, insert XML header tags.
 2. Traverse the web root dir. For each file, determine whether it should
    be listed in the sitemap.
 3. If so, generate the proper URL tag and insert it into the new file.
 4. When done visiting files, insert the XML footer tags. Save the file.

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8; lexical-binding: t; -*-
     ;; version: 2019-06-11
     ;; home page: /Users/xah/web/ergoemacs_org/emacs/make_sitemap.html

     (require 'seq)

     (setq xah-web-root-path "/Users/xah/web/" )

     (defvar xahsite-external-docs nil "A vector of dir paths.")
     (setq  xahsite-external-docs
            [
             "ergoemacs_org/emacs_manual/"
             "xahlee_info/REC-SVG11-20110816/"
             "xahlee_info/clojure-doc-1.8/"
             "xahlee_info/css_2.1_spec/"
             "xahlee_info/css_transitions/"
             "xahlee_info/js_es2011/"
             "xahlee_info/js_es2015/"
             "xahlee_info/js_es2015_orig/"
             "xahlee_info/js_es2016/"
             "xahlee_info/js_es2018/"
             "xahlee_info/node_api/"
             ])

     (defun xahsite-generate-sitemap (@domain-name)
       "Generate a sitemap.xml.gz file of xahsite at doc root.
     @domain-name must match a existing one.
     Version 2018-09-17"
       (interactive
       (let (
             ($sitemapFileName "sitemap.xml" )
         ;; (print (concat "begin: " (format-time-string "%Y-%m-%dT%T")))
         (let (
               ($filePath (concat $websiteDocRootPath $sitemapFileName ))
               ($sitemapBuffer (generate-new-buffer "sitemapbuff")))
           (with-current-buffer $sitemapBuffer
             (set-buffer-file-coding-system 'unix)
             (insert "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
     <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">
     "))
           (mapc
            (lambda ($f)
              (setq $pageMoved-p nil)
              (when (not (or
                          (string-match "/xx" $f) ; ; dir/file starting with xx are not public
                          (string-match "403error.html" $f)
                          (string-match "404error.html" $f)))
                (with-temp-buffer
                  (insert-file-contents $f nil 0 100)
                  (when (search-forward "page_moved_64598" nil t)
                    (setq $pageMoved-p t)))
                (when (not $pageMoved-p)
                  (with-current-buffer $sitemapBuffer
                    (insert "<url><loc>"
                            "http://" @domain-name "/" (substring $f (length $websiteDocRootPath))
                            "</loc></url>\n"
                            )))))
            (seq-filter
             (lambda (path)
               (not (seq-some
                     (lambda (x) (string-match x path))
                     xahsite-external-docs
                     )))
           (with-current-buffer $sitemapBuffer
             (insert "</urlset>")
             (write-region (point-min) (point-max) $filePath nil 3)
             (kill-buffer ))
           (find-file $filePath)
           )
         ;; (print (concat "done: " (format-time-string "%Y-%m-%dT%T")))
         ))

     (defun xahsite-generate-sitemap-all ()
       "do all
     2016-08-15"
       (interactive)
       (xahsite-generate-sitemap "wordyenglish.com" )
       (xahsite-generate-sitemap "xaharts.org" )
       (xahsite-generate-sitemap "xahlee.info" )
       (xahsite-generate-sitemap "xahlee.org" )
       (xahsite-generate-sitemap "xahmusic.org" )
       (xahsite-generate-sitemap "xahsl.org"  ))
 #+END_SRC

 On a site with 3515 html files (10 times more if counting image files
 etc), the script takes 5 seconds to run. (e.g. timing based on running
 it a second time, thus not counting disk reading time. )

 See also: [[http://xahlee.info/golang/golang_gen_sitemap.html][Golang:
 Generate Sitemap]]

 --------------





 --------------

** Emac Lisp: Complex HTML Processing: Creating Downloadable zip Archive
*** Problem
    I create a downloadable version of a website for people to read offline.

    This is a fairly complex text processing task. In this tutorial, you'll
    learn:

    - How to call shell commands to copy, delete, zip, files or dir.
    - How to use nested =mapc=.
    - How to traverse a directory.
    - how to use regex and search-forward etc to find relative links, and insert, etc, to change them.
    - The use of relative/full name, current file dir, etc, to help determine and process links.
    - Efficiently open and modify thousands of files.

**** Detail
     Consider this emacs tutorial you are reading.

     One simple solution is to make a copy of the directory, zip it, and let
     people download that. This won't work, because many links will be broken.

     Here's what we need to do:

     - All local links, including links to CSS or inline images, need to be
       processed. If they point to a dir outside the target dir, or to the
       parent of target dir, either the parent dir must be included in
       archive, or the linked file be included in the archive and link
       changed.
     - All external links need to be looked at. For example, inline images
       that uses “http://” form. The image file needs to be included, and the
       link needs to be changed to relative path.
     - Remove JavaScript code for Google traffic tracker, Google Ads, web
       comment widget, etc.
     - {templates, temp files, temp dir, emacs backup files, ...} need to be
       removed. For example: {.DS_Store, backup~, temp-notes.txt, scheduled
       publish log dir, ...}

     It would be nice, if i could just press a button in emacs, and have this
     archive generated automatically. And whenever i have updated my emacs
     tutorial, i can run the script again to regenerate a fresh downloadable
     version.

*** Solution
    The general plan is simple:

    1. Copy the directories into a destination directory.
    2. Call shell commands to delete temp files such as emac's backup files
       in the destination dir.
    3. Have a function that process each HTML, to change relative links and
       take out Google Analytics's JavaScript code.
    4. Call shell commands to archive this dir.

    First, we define some user input parameters for the script:

    #+BEGIN_SRC emacs-lisp
      ;; web root dir
      (setq webroot "/Users/xah/web/") ; must end in slash

      ;; list of source dirs i want to make a archive
      ;; Each is relative to webroot. Must not end in slash.
      (setq sourceDirsList (list "emacs" "elisp"))

      ;; Destination dir path, relative to webroot
      ;; This is the dir i want the archive to be at
      (setq destDirRelativePath "diklo")

      ;; dest zip archive name (without the “.zip” suffix)
      ;; for example here, the download file will be xah_emacs_tutorial.zip
      (setq zipCoreName "xah_emacs_tutorial")

      ;; whether to use gzip or zip.
      (setq use-gzip-p nil)
    #+END_SRC

    Then, we define some convenient constant.

    #+BEGIN_SRC emacs-lisp
      (setq destRoot (concat webroot destDirRelativePath "/"))
      (setq destDir (concat destRoot zipCoreName "/"))
    #+END_SRC

    So, destRoot would be like =/Users/xah/web/diklo/= and destDir would be
    like =/Users/xah/web/diklo/xah_emacs_tutorial=. The final download
    archive would be =/Users/xah/web/diklo/xah_emacs_tutorial.tar.gz=.

    Now, we copy the source dirs to destination.

    #+BEGIN_SRC emacs-lisp
      ;;; copy to destination
      (mapc
       (lambda (x)
         (let (fromDir toDir)
           (setq fromDir (concat webroot x))
           (setq toDir
                 (drop-last-slashed-substring
                  (concat webroot destDirRelativePath "/" zipCoreName "/" x)) )
           (make-directory toDir t)
           (shell-command (concat "cp -R " fromDir " " toDir))
           )
         )
       sourceDirsList)
    #+END_SRC

    The above code used the function =mapc=. The function has the form
    “(mapc 'myfunc myList)”, where the function myfunc will be applied to
    each element of myList. The function we used above is “(lambda (x)
    ...)”, with “x” being the argument. The source dir and dest dir's paths
    are constructed inside the lambda function, then command line string is
    constructed, then =make-directory= is called. It will create all parent
    dirs of a given full path. Then, finally we call =shell-command= to copy
    the dirs.

    Also, we called “drop-last-slashed-substring”, which is defined as
    follows:

    #+BEGIN_SRC emacs-lisp
      (defun drop-last-slashed-substring (path)
        "Drop the last path separated by “/”.
      For example:
      “/a/b/c/d” → “/a/b/c”
      “/a/b/c/d/” → “/a/b/c/d”
      “/” → “”
      “//” → “/”
      “” → “”"
        (substring path 0 (1- (match-end 0)))
        path))
    #+END_SRC

    Copying a bunch of directories seems a trivial operation, but it
    actually took me a couple hours to arrive at the final code, due to some
    “smart” behavior of unix =cp -R=.

    Originally, i thought the code would be something simple like several
    =(shell-command (concat "cp -R " fromDir " " toDir))=, one for each
    source dir, where fromDir and toDir are full paths. However, it turns
    out the problem is slightly more complex. Here's a summary:

    ① The copying behavior depends on whether the destination node exists.
    When the destination node exists, it copies the source node itself,
    otherwise, it copies the source node's children (and creates the
    non-existant destination node). ② However, when the destination node's
    parent doesn't exist, it's a error.

    Now, we copy my site's style sheets.

    #+BEGIN_SRC emacs-lisp
      ;; copy the style sheets over, and icons dir
      (shell-command (concat "cp /Users/xah/web/style1.css " destDir))
      (shell-command (concat "cp /Users/xah/web/style2.css " destDir))
      (shell-command (concat "cp /Users/xah/web/style3.css " destDir))
      (shell-command (concat "cp -R /Users/xah/web/ics " destDir))
    #+END_SRC

    Now, do some file cleanup.

    #+BEGIN_SRC emacs-lisp
                                              ; remove emacs backup files, temp files, mac os x files, etc.
    #+END_SRC

    Now, we need to modify the relative links so that, if a link pointing to
    a file that is not part of the downloadable copy, change it to a
    〔http://xahlee.org/...〕 based link.

    For example, in my emacs tutorial at =/Users/xah/web/emacs/xxx.html= it
    contains the link =<a href="../python/index.html">Python tutorial</a>=,
    which points to a file outside the emacs dir. When user download my
    emacs tutorial, this link will then points to a file that doesn't exist
    on his disk. The link =../python/index.html= should be changed to
    “http://xahlee.org/python/index.html”.

    Also, in my HTML files, they contain a JavaScript for Google Analytics,
    like this:
    =<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript"> _uacct = "UA-104620-2"; urchinTracker();</script>=.
    This allows me to see my web traffic statistics. The downloaded version
    shouldn't have this line.

    Here's the code to process each HTML file for the above problems:

    #+BEGIN_SRC emacs-lisp
      ;;; change local links to “http://” links.
      ;;; Delete the google JavaScript snippet, and other small fixes.
      (setq make-backup-files nil)
      (require 'find-lisp)
      (mapc (lambda (x)
              (mapc
               (lambda (fPath) (clean-file fPath (concat webroot (substring fPath (length destDir)))))
               )
              sourceDirsList
              )
    #+END_SRC

    In the above code, we use =mapc= to apply a function to all HTML files.
    The “find-lisp-find-files” will generate a list of all files in a dir.
    Here, we actually calls mapc twice, one inside the other.

    The sourceDirsList is a list of dirs. So, the first mapc maps a function
    to each of the dir. Now, for each dir, we want to apply a function to
    all HTML files. That's the inner mapc is for. The function that actually
    does process the HTML file is the “clean-file”. The “clean-file”
    function takes 2 arguments. The first is the full path to the HTML file
    to be processed, the second is a full path to the “same” file at source
    dir. The second argument is necessary, because we need the original
    directory structure to compute the correct URL for the relative link
    that needs to be fixed. Here's the code:

    #+BEGIN_SRC emacs-lisp
      (defun clean-file (fPath originalFilePath)
        "Modify the HTML file at fPath, to make it ready for download bundle.

      This function change local links to “http://” links,
      Delete the google JavaScript snippet, and other small changes,
      so that the file is nicer to be viewed offline at some computer
      without the entire xahlee.org's web dir structure.

      The google JavaScript is the Google Analytics web bug that tracks
       web stat to xahlee.org.

      fPath is the full path to the HTML file that will be processed.
      originalFilePath is full path to the “same” file in the original web structure.
      originalFilePath is used to construct new relative links."
        (let (myBuffer bds p1 p2 linkPath linkPathSansJumper)

          (setq myBuffer (find-file fPath))

          (goto-char (point-min)) ;in case buffer already open
          (while (search-forward "<script src=\"http://www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\"> _uacct = \"UA-104620-2\"; urchinTracker();</script>" nil t)
            (replace-match ""))

          (goto-char (point-min))
          (while (search-forward "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee</a>" nil t)
            (replace-match "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee↗</a>"))

          ;; go thru each link, if the link is local,
          ;;then check if the file exist.
          ;;if not, replace the link with proper http://xahlee.org/ url
          (goto-char (point-min)) ; in case buffer already open

          (while (re-search-forward "<[[:blank:]]*a[[:blank:]]+href[[:blank:]]*=[[:blank:]]*" nil t)
            (forward-char 1)
            (setq bds (bounds-of-thing-at-point 'filename))
            (setq p1 (car bds))
            (setq p2 (cdr bds))
            (setq linkPath (buffer-substring-no-properties p1 p2))

            (when (not (string-match "^http://" linkPath))

              ;; get rid of trailing jumper, for example, “Abstract-Display.html#top”

              (when (not (file-exists-p linkPathSansJumper))
                (delete-region p1 p2)
                (let (newLinkPath)
                  (setq newLinkPath
                        (compute-url-from-relative-link originalFilePath linkPath webroot "xahlee.org"))
                  (insert newLinkPath))
                (search-forward "</a>")
                (backward-char 4)
                (insert "↗")
                )
              )
            )
          (save-buffer)
          (kill-buffer myBuffer)))
    #+END_SRC

    In the above function “clean-file”, the hard part is to construct the
    correct URL for a relative link.

    Given a file, there are many relative links. The link may or may not be
    good in the download copy version. For example, if the relative link
    does not start with =../=, then it is still good. However, if it starts
    with =../=, it may or may not be still good. For example, in my emacs
    tutorial project, both =/Users/xah/web/emacs/= and
    =/Users/xah/web/elisp/= are part of the download archive. So, if some
    file under the emacs dir has a relative link starting with =../elisp/=,
    then it is still a good link. We don't want to replace that with a
    〔http://...〕 version. To compute the correct relative link, we
    actually need to know the original dir structure.

    Computing relative links is conceptually trivial. Basically, each
    occurrence of =../= means one dir level up. But actually coding it
    correctly took a while due to various little issues. For example, some
    link will have a trailing jumper of this form
    =Abstract-Display.html#top=. The trailing =#top= will need to be removed
    if we want to use the string to check if file exists. Theoretically, all
    it takes to determine a relative link is the file path of the file that
    contains the link, the relative link string, and the dir tree structure
    surrounding the file. Specifically, when we move a dir, and wish to
    construct or fix relative links, we do not need to check if the linked
    file still exists in the new dir. In practice, it's much simpler, to
    first determine whether the relative link is still good, by checking if
    the linked file exists at the new download copy's dir structure.

    In the clean-file function, it first grab the relative link string from
    the HTML file, then determine whether this link needs to be fixed, then
    calls “compute-url-from-relative-link” that returns the proper “http://”
    based URL. The function compute-url-from-relative-link takes 4
    parameters: fPath, linkPath, webDocRoot, hostName. See the doc string
    below:

    #+BEGIN_SRC emacs-lisp
      (defun compute-url-from-relative-link (fPath linkPath webDocRoot hostName)
        "returns a “http://” based URL of a given linkPath,
      based on its fPath, webDocRoot, hostName.

      fPath is the full path to a HTML file.
      linkPath is a string that's relative path to another file,
      from a “<a href=\"…\"> tag.”
      webDocRoot is the full path to a parent dir of fPath.
      Returns a URL of the form “http://hostName/‹urlPath›”
      that points to the same file as linkPath.

      For example, if
      fPath is /Users/xah/web/Periodic_dosage_dir/t2/mirrored.html
      linkPath is ../../p/demonic_males.html
      webDocRoot is /Users/xah/web/
      hostName is xahlee.org
      then result is http://xahlee.org/p/demonic_males.html

      Note that webDocRoot may or may not end in a slash."
        (concat "http://" hostName "/"
                (substring
                 (file-truename (concat (file-name-directory fPath) linkPath))
                 (length (file-name-as-directory (directory-file-name webDocRoot))))))
    #+END_SRC

    Finally, we zip up the dest dir.

    #+BEGIN_SRC emacs-lisp
      ;; zip the dir
      (let (ff)
        (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".zip"))
        (when (file-exists-p ff) (delete-file ff))
        (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".tar.gz"))
        (when (file-exists-p ff) (delete-file ff)))

      (setq default-directory (concat webroot destDirRelativePath "/"))

      (when (equal
             0
             (if use-gzip-p
                 (shell-command (concat "tar cfz " zipCoreName ".tar.gz " zipCoreName))
               (shell-command (concat "zip -r " zipCoreName ".zip " zipCoreName))
               ))
        (shell-command (concat "rm -R " destDir))
        )
    #+END_SRC

    In the above code, first we delete the previous archive if it exists.

    Now, all is done. With all the code above in a buffer, i can just
    eval-buffer to generate my downloadable archive, or i can call the
    script in OS's command line like =emacs --script make_download_copy.el=.
    I decided to go one step further, by wrapping the whole script into a
    function. Like this:

    #+BEGIN_SRC emacs-lisp
      (defun make-downloadable-copy (webroot sourceDirsList destDirRelativePath
                                             zipCoreName &optional use-gzip-p)
        "Make a copy of web dir of XahLee.org for download.

      This function depends on the structure of XahLee.org,
      and is not useful in general.

      • webroot is the website doc root dir. (must end in slash)
      For example: <code class=\"path-abc\">/Users/xah/web/」

      • sourceDirsList is a list of dir paths relative to webroot,
      to be copied for download. Must not end in slash.
      For example: (list \"p/time_machine\")

      • destDirRelativePath is the destination dir of the download.
      it's a dir path, relative to webroot.
      For example: “diklo”

      • zipCoreName is the downloable archive name, without the suffix.
      For example: “time_machine”

      use-gzip-p means whether to use gzip, else zip for the final archive.
      If non-nil, use gzip."
        (let (…)
          ;; all the code above here except functions.
          )
        )
    #+END_SRC

    Here's how i call it:

    #+BEGIN_SRC emacs-lisp
      ;; emacs tutorial and elisp manual in one download archive
      ;; gzip format
      (make-downloadable-copy
       "/Users/xah/web/"
       (list "emacs" "elisp")
       "diklo" "xah_emacs_tutorial" "gzip")

      ;; elisp manual. zip format.
      (make-downloadable-copy
       "/Users/xah/web/"
       (list "elisp")
       "diklo" "elisp_manual")
    #+END_SRC

    Emacs ♥

    --------------





    --------------

** Elisp: Process File line-by-line

   This page gives a example of how to use emacs lisp to process a file
   line by line, in a buffer, not as string of lines.

*** Problem

    Given a file of many lines, like this:

    #+BEGIN_SRC emacs-lisp
      at_target(integer tnum, vector targetpos, vector ourpos)
    #+END_SRC

    For each line, create a file of the same name as first part of the line.
    For example: 〔at_target.txt〕

    The file content should be the whole line, with other static text, like
    this:

    #+BEGIN_SRC emacs-lisp
      # --
      at_target(integer tnum, vector targetpos, vector ourpos)
      {
      $0
      }
    #+END_SRC

**** Detail

     I'm writing a major mode for [[http://xahsl.org/sl/ls.html][Linden
     Script Language]] (LSL). LSL is a scripting language used for the
     virtual world [[http://xahsl.org/sl/index.html][Second Life]]. It has
     few hundred functions, and each one has parameters that is unusual as
     compared to normal programing languages. For example, this is a LSL
     function:

     #+BEGIN_SRC emacs-lisp
       at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
       // …
       }
     #+END_SRC

     So, i want a function template feature in my major mode. If a programer
     has typed “at_rot_target”, then, he can press a button, and it expands
     to:

     #+BEGIN_SRC emacs-lisp
       at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
       ▮
       }
     #+END_SRC

     There is a easy-to-use template system package for emacs, called
     YASnippet. [see [[file:emacs_templates.html][YASnippet tutorial]]] So, i
     decided to use this instead of implementing my own template system.

     With yasnippet, it uses a plain text for template definition. To define
     a template, you need to create a file. For example, in LSL there's a
     function named “collision” with this syntax
     =collision(integer num_detected) {…}=. This means, i must have a file
     named “collision” in the template dir, and the file content must be like
     this:

     #+BEGIN_SRC emacs-lisp
       # --
       collision(integer num_detected)
       {
       $0
       }
     #+END_SRC

     This means, when my mode xlsl-mode is on, and yasnippet minor mode is
     on, then user can type “collision” followed by a hotkey for template
     completion, then the function form will be inserted and cursor will be
     placed between the braces.

     I have prepared a file that is over 300 lines that are the LSL functions
     and parameters. For example, part of the file looks like this:

     #+BEGIN_SRC emacs-lisp
       at_rot_target(integer tnum, rotation targetrot, rotation ourrot)
       at_target(integer tnum, vector targetpos, vector ourpos)
       attach(key id)
       changed(integer change)
       collision(integer num_detected)
       collision_end(integer num_detected)
       collision_start(integer num_detected)
       control(key id, integer held, integer change)
     #+END_SRC

     (Save the above text in a file name it =xx_event_forms.txt= for later
     testing of elisp code.)

     Now, the task is to parse this file, and for each line, create the
     template file for it.

*** Solution

    The task has these steps:

    - Open the file.
    - Read each line.
    - Parse the line into 2 parts. The first part is everything before the
      opening paren (call it stringA). The second part is the rest of the
      line (call it stringB).
    - Create a file and name it stringA.
    - Insert into the file the whole line, and other text such as =# --= and
      ={ $0 }=.

    These are simple tasks. There are a lot ways to do this in elisp. We can
    for example grab the whole file's text, then use =split-string= by
    newline char to get a list of lines. Then we loop thru the list.

**** Read File Content as List of Lines

     [[file:elisp_read_file_content.html][Elisp: Read File Content as String
     or List of Lines]]

**** Process Each Line in a Buffer

     Another way more idiomatic to emacs lisp, is to simply open the file in
     a buffer, then move cursor one line at a time, each time grab the line
     and do what we need to do.

     For this task, the split lines into a list method is probably simpler.
     But since we are learning emacs lisp, let's use the emacs buffer method.

     First, we define few global vars.

     #+BEGIN_SRC emacs-lisp
       ;; input file
       (setq inputFile "xx_event_forms.txt")

       ;; other vars
       (setq splitPos 0) ;; cursor position of split, for each line
       (setq fName "")
       (setq restLine "")
       (setq moreLines t ) ;; whether there are more lines to parse
     #+END_SRC

     Now, we open the file, like this:

     #+BEGIN_SRC emacs-lisp
       ;; open the file
       (find-file inputFile)
       (goto-char 1) ;; needed in case the file is already open.
     #+END_SRC

     Now, we loop thru the lines, like this:

     #+BEGIN_SRC emacs-lisp
       (while moreLines
         (search-forward "(")

         (setq splitPos (1- (point)))
         (beginning-of-line)
         (setq fName (buffer-substring-no-properties (point) splitPos))

         (end-of-line)
         (setq restLine (buffer-substring-no-properties splitPos (point) ))

         ;; create the file
         (find-file fName)
         (insert "# --\n")
         (insert fName restLine "\n{\n$0\n}" )
         (save-buffer)
         (kill-buffer (current-buffer))

         (setq moreLines (= 0 (forward-line 1)))
         )
     #+END_SRC

     In the above, we use =search-forward= to move cursor to the opening
     paren. Then, save the position to splitPos. Everything before that
     should be the template file name, so we save it in fName. Everything
     after that is restLine.

     Now, we create the file fName using =(find-file fName)=, then, insert
     the content, save it, close it.

     Lastly, we move cursor to the next line by =(forward-line 1)=. Note that
     if the cursor is at the last line, and when =forward-line= is unable to
     move forward, it will return a number indicating how many lines it
     failed to pass. So, normally it returns 0. If not, that means we are on
     the last line.

     After we processed the lines, we just close the input buffer, like this:

     #+BEGIN_SRC emacs-lisp
       (kill-buffer (current-buffer)) ;; close the input file
     #+END_SRC

     To test the above, first create a sample input file. Take the sample
     input lines above and save it as =xx_event_forms.txt=. Then, grab all
     the above lisp code and save it in a file =test_line_process.el=. Now,
     open the lisp file and Alt+x =eval-buffer=. Then all the template files
     will be created in the same dir.

     Emacs ♥

     See also: [[file:elisp_all_about_lines.html][Elisp: Functions on Line]]

     --------------





     --------------

** Emacs Lisp Power: Text-Soup Automation

 This page showcases a example of emacs lisp power, in dealing with
 text-soup processing that requires human interaction.

*** Problem

 I have a [[http://xaharts.org/movie/best_movies.html][favorite movies
 page]]. The page contain about 70 amazon links like this:

 #+BEGIN_SRC emacs-lisp
     <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
 #+END_SRC

 It's a mystery what the link is, unless you visit the link. I want them
 to have a “title” attribute, like this:

 #+BEGIN_SRC emacs-lisp
     <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>
 #+END_SRC

 It's a thorny problem. You have to write a script to fetch the amazon
 page then parse the result to get the product title then insert them at
 the right place. Amazon may block crawlers, and even if not, the parsing
 of the complex HTML to extract the title may take hours to code. You
 don't even know if product title is clearly marked by a specific tag.

 Luckily, my page is written so that for each amazon link, the movie
 title is within the paragraph, preceding the link, and usually in the
 form of a Wikipedia link. Here's a sample paragraph:

 #+BEGIN_SRC emacs-lisp
     <p><a href="http://en.wikipedia.org/wiki/To_sleep_with_a_vampire">To sleep with a vampire</a>
      (1993) ◇ Director: Adam Friedman.
     <a class="amz" href="http://www.amazon.com/dp/B0000648YN/?tag=xahh-20">amazon</a>
     </p>
 #+END_SRC

*** Solution

 So, the plan is to write a elisp script. Here's the basic steps:

 1. open the file
 2. find a amazon link.
 3. search backward for the Wikipedia link that contains the movie title.
 4. insert the “title” attribute in the amazon link.
 5. Repeat.

 This is a job perfect for elisp, and can be done interactively,
 [[file:elisp_text_processing_lang.html][far better than any Perl,
 Python, Ruby]], due to emacs lisp's buffer system. I imagine it's a 20
 min scripting job. Here's the code:

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2010-11-03
     ;; add 「title="product title"」 to amazon links on a HTML page.

     ;; rough steps:
     ;; find amazon link of the form
     ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

     ;; find a Wikipedia link above it, of this form
     ;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
     ;; extract the movie title

     ;; insert the attribute
     ;; title="…"
     ;; into the amazon link. Like this
     ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

     (setq outputBuffer "*xah output*" )
     (with-output-to-temp-buffer outputBuffer

       (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
       (goto-char 1)

       (while
           (re-search-forward "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

         (progn
           ;; set points for amazon link
           (backward-char 11)
           (setq amzLinkInsertPoint (point) )

           ;; get title from preceding Wikipedia link
           (setq titleText (match-string 1 ) )

           (when (yes-or-no-p titleText)
             (goto-char amzLinkInsertPoint)
             (insert (concat " title=\"" titleText "; movie\"")) )
           )

         (progn (print "not found"))
         )

       (princ "Done deal!")
       )
 #+END_SRC

 Emacs is fantastic!

 (In practice, the job took close to one hour to complete, counting all
 mistakes, and whatnot when actually coding. For example, in the process
 i noticed that 2 of the amazon links are preceded by Wikipedia links
 that are not actually related to the amazon link, and this and other
 miscellaneous irregularities are actually expected. The code above is
 actually slightly cleaned up, but is still meant to be one-time-use
 code. It always looks easy when seeing someone's published code than
 actually coding from scratch.)

 There are few hundred amazon links on my site of 4k pages. They all need
 a similar fix. The job will be slightly different, because the links are
 arbitrary product or book names. But typically, the product name is
 usually marked like this 〈book title〉 or “song cd” or some other way
 in the text before the link, but not always. Also, some amazon links may
 already have a “title” attribute. The point is that it's a
 [[file:emacs_power_story.html][text-soup situation and requires human
 baby-sitting]] for correct completion, and elisp excels at this.
 Tomorrow or so, i'll write a elisp script to fix these few hundred
 amazon links among 4k pages. Total time for the task is expected to be 2
 to 4 hours. (For a keyboard macro solution i needed to do in this, see:
 [[file:emacs_macro_example2.html][Emacs Key Macro Example: Add HTML
 Attribute]].)

 2010-11-08

 Aaron Culich wrote a elisp script that does the same thing but using
 several interesting techniques, among them is using DOM/XPATH in elisp
 to process HTML, and also yahoo's Yahoo Query Language (YQL), both of
 which i don't have any experience with. His code can be seen here:
 [[https://github.com/aculich/misc-elisp/blob/master/query-html.el]]

 Here's a excerpt of his comment:

 #+BEGIN_QUOTE
   I often find myself having to do some xpath myself and since want to
   do this sort of thing inside emacs myself from time to time instead of
   busting out python, so I've been playing around with your Dr.
   Strangelove movie example (a favorite movie of mine, btw) using emacs
   and xpath. You can find my results here:
   https://github.com/aculich/misc-elisp

   I tried using 3 methods.

   - ① First with pure elisp using the dom/xpath stuff on emacswiki.
     Unfortunately the processing is broken and at least in some of the
     cases I tried, gobbled up all available memory. I didn't look at it
     closely, but I have a feeling the elisp implementation would a fair
     amount of work to get working and even still would probably not be
     very fast for large documents. Also, you still probably want to run
     the input through tidy first so that you're not dealing with broken
     HTML (which it seems nearly every website in the universe has).
   - ② Using a few handy unix utilities not uncommon on most systems:
     wget, tidy, and xmlstarproc. You'll need to first install those
     before using this method.
   - ③ Yahoo's YQL web service is handy for this sort of thing. And the
     nice thing is that if you need to process a large document, all of
     it will be done remotely.

   #3 is the default method that I use in my elisp code since it only
   relies on modules that ship with most recent versions of emacs
   (specifically json.el and url.el and w3m.el) and doesn't require any
   special binaries to be installed the way #2 does.

   Also, since #1 was so broken I did not include any example
   implementation for it. Anyway, if you find the code useful, let me
   know.
 #+END_QUOTE

 --------------





 --------------

** Elisp: HTML Processing: Split Annotation

 This page shows a example of emacs lisp for processing HTML. The HTML
 files are classic novels, with annotations. The annotation markups need
 to change from one format into another. There are hundreds of such pages
 that need to be processed.

*** Problem

 For all HTML files in a directory, find any annotation markup containing
 the bullet “•” symbol:

 #+BEGIN_SRC emacs-lisp
     <div class="annotate27223">A … • B … • C …</div>
 #+END_SRC

 Split the annotation into multiple markups, like this:

 #+BEGIN_SRC emacs-lisp
     <div class="annotate27223">A … </div>
     <div class="annotate27223">B … </div>
     <div class="annotate27223">C … </div>
 #+END_SRC

**** Detail

 If you are a contract web dev programer, then you know that 99.99% of
 websites are a messy text soup. They are created by hundreds of tools or
 languages. Word processors, HTML generators, tens of lightweight markup
 languages, different frameworks from different languages PHP, Perl,
 Python, from different web era, from different programers in the past.
 Even emacs has several modes that generate HTML. They are not in any
 consistent form. Often, they have mis-matched tags too as invalid HTML.

 It is in these situations, emacs shines thru, because emacs's powerful
 embedded language lisp, and its interactive nature, lets you maximize
 automation. Interactively when you are still feeling the pattern, then
 by [[file:emacs_macro_example.html][Keyboard Macro]] or emacs lisp for
 parts that can be automated.

 For my website, i take the time to make sure that all my HTML are
 consistent. But still, they are written in the span of 15 years.
 Periodically i take the time to improve the markup. For example, when
 new versions of CSS or HTML became mature and widely adopted by web
 browsers. (CSS1 to 2 to 3, HTML 3 to 4 to
 [[http://xahlee.info/js/html5_tags.html][HTML5]].)

 I have hundreds of pages of classic novels as HTML documents. These
 documents contain annotations in a special HTML markup. For example,
 here's sample annotation from
 [[http://wordyenglish.com/titus/act1.html][“Titus Andronicus” Act 1
 Scene 1]]:

 #+BEGIN_SRC emacs-lisp
     SATURNINUS. 'Tis good, sir. You are very short with us;
       But if we live we'll be as sharp with you.
 #+END_SRC

 • sharp ⇒ Fierce, impetuous, hash, severe... (AHD)

 Here's the raw HTML:

 #+BEGIN_SRC emacs-lisp
     <div class="annotate27223">• short ⇒ rudely brief. (AHD)<br>
     • sharp ⇒ Fierce, impetuous, hash, severe… (AHD)</div>

     <pre class="text48074">SATURNINUS. 'Tis good, sir. You are very <span class="xntt">short</span> with us;
       But if we live we'll be as <span class="xntt">sharp</span> with you.
     </pre>
 #+END_SRC

 Here's how the tag works. Each =<span class="xntt">= markup a word in
 main text. When a word is marked by “span.xntt”, that means it has a
 sidebar annotation. The sidebar section is marked by
 =<div class="annotate27223">=. Inside the “div.annotate27223”, there may
 be more than one entries. Each entry starts with the bullet symbol “•”.
 For example, in the above, the words “short” and “sharp” are both
 entries inside a “div.annotate27223” sidebar.

 But recently, i think it is better to have one entry per sidebar. This
 way, it makes the logic simpler, and is much easier if i want to add
 [[http://xahlee.info/js/js.html][JavaScript]] functionality. For
 example, when mouse hovers on a word in main text, the corresponding
 annotation would be highlighted.

 So, i want to write a elisp script to process all my files. If you
 simply read the spec for this job, of splitting a markup by a particular
 character, you may think it's trivial and can be done in any language in
 10 minutes. Why then the elaborate discussion about text soup situation?

 The important thing is that i DO NOT know what needs to be done to begin
 with. Only after having used emacs power together with lisp script i
 wrote before to look at and check my existing markup in hundreds of
 files, then i know what state they are and decide on what i want to do.
 Also, this change must be done with the ability to visually check that
 all changes are done correctly, because the input may not be in the
 format i expect. (it might be missing the bullet “•”.)

 For those Scheme Lisp academic computer science folks, you might wonder,
 when i started with these annotations, why didn't i “design” it well to
 begin with. The reason is that, when i write a blog article, or my
 literature annotation project, i really want to focus on the writing
 first, the content, get it done, rather than get distracted by the
 CSS/HTML markup design. (one thing i do make sure is that whatever
 CSS/HTML i device, i made sure that they can be easily changed
 systematically later by a simple parsing.) I devote significantly more
 time on design than most people, but many factors necessitate change.
 For example, CSS in practice is rather complex and it takes years of
 experience to learn its quirks and tricks. Similarly, the best practices
 of HTML changes with time. (For example, see:
 [[http://xahlee.info/UnixResource_dir/writ/html5_vs_intelligence.html][Are
 You Intelligent Enough to Understand HTML5?]].) Browsers change,
 standards changes (For example, HTML → XHTML → HTML5. See:
 [[http://xahlee.info/js/html5_validation_doctype.html][HTML5 Doctype,
 Validation, X-UA-Compatible, and Why Do I Hate Hackers]].), thoughts of
 best practices change, and my needs for the annotation also changed
 through-out the years.

*** Solution

 Here's the outline of steps:

 - Open the file. Search for the tag we want.
 - Check if the tag contains a bullet “•”.
 - If so, replace the bullet char with new end tag and beginning tag. For
   example: =•= ⇒ =</div> <div>=
 - Do this for all files in a dir. (or a given list of files)

 Here's the code:

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2011-08-13
     ;; process all files in a dir.
     ;; split any markup like this:
     ;; <div class="annotate27223">… • … • …</div>
     ;; by the bullet •
     ;; into several annotate27223 tags

     (setq inputDir "~/web/xahlee_org/p/" )

     ;; add a ending slash if not there
     (when (not (string= "/" (substring inputDir -1) )) (setq inputDir (concat inputDir "/") ) )

     ;; files to process
     (setq fileList
     [
     "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin4_1.html"
     "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin3.html"
     ]
     )

     (defun my-process-file-xnote (fPath)
       "Process the file at FPATH …"
       (let (myBuffer ($counter 0) p1 p2 $meat
                      $meatNew
                      (changedItems '())
                      (tagBegin "<div class=\"annotate27223\">" )
                      (tagEnd "</div>" )
                      )

         (require 'sgml-mode)
         (when t

           (setq myBuffer (find-file fPath))
           (goto-char 1)
           (while (search-forward "<div class=\"annotate27223\">" nil t)

             ;; capture the annotate27223 tag text
             (setq p1 (point))
             (backward-char 1)
             (sgml-skip-tag-forward 1)
             (backward-char 6)
             (setq p2 (point))
             (setq $meat (buffer-substring-no-properties p1 p2))

             ;; if it contains a bullet
             (when (string-match "•" $meat)
               (setq $counter (1+ $counter))

               ;; clean the text. Remove some newline and <br> that's no longer needed
               (setq $meat (replace-regexp-in-string "\n*• *" "•" $meat t t ) )
               (setq $meat (replace-regexp-in-string "\n$" "" $meat t t ) ) ; delete ending eol
               (setq $meat (replace-regexp-in-string "<br>•" "•" $meat t t ) )

               ;; put the new entries into a list, for later reporting
               (setq changedItems (split-string $meat  "•" t) )

               ;; break the bullet into new end/begin tags
               (setq $meatNew (replace-regexp-in-string "•" (concat tagEnd "\n" tagBegin) $meat t t ) )

               (goto-char p1)
               (delete-region p1 p2)
               (insert $meatNew)

               ;; remove the newline before end tag
               (when (looking-back "\n") (delete-backward-char 1))
               )
             )

           ;; report if the occurrence is not n times
           (when (not (= $counter 0))
               (princ (format "%d %s\n\n" $counter fPath))

               (mapc (lambda ($x) (princ (format "%s\n\n" $x)) ) changedItems)
             )

             ;; close buffer if there's no change. Else leave it open.
             (when (not (buffer-modified-p myBuffer)) (kill-buffer myBuffer) )
           )
         ))

     (require 'find-lisp)

     (let (outputBuffer)
       (setq outputBuffer "*xah annotate27223 output*" )
       (with-output-to-temp-buffer outputBuffer
         ;; (mapc 'my-process-file-xnote fileList)
       (princ "Done deal!")
         )
       )
 #+END_SRC

 Here's a sample output:
 [[file:elisp_text_processing_split_annotation.txt]]

 I've put lots comments in the code. It should be easy to understand. If
 any part you don't understand, ask me. If you are new to elisp, checkout
 the first few section of [[file:elisp.html][Emacs Lisp Tutorial]].

 I ♥ emacs.

 --------------




 --------------

** Elisp: Fix Dead Links

 This page shows you how to write a elisp script that checks thousands of
 HTML files and fix dead links.

*** Problem

 I have 2 thousands HTML files that contains about 70 dead local links. I
 need to write a elisp script to change these links to non-links. For
 example, this is a dead link:

 #+BEGIN_SRC emacs-lisp
     <a href="../widget/index.html#Top">Introduction</a>
 #+END_SRC

 I need it to be:

 #+BEGIN_SRC emacs-lisp
     <span class="εlink" title="../widget/index.html#Top">Introduction</span>
 #+END_SRC

 The script should run in batch. And it should generate a report of all
 changed links.

**** Detail

 I have a copy of the emacs manuals, at:

 - [[../emacs_manual/emacs/index.html][GNU Emacs Manual]] (~690 files)
 - [[../emacs_manual/elisp/index.html][GNU Emacs Lisp Reference Manual]]
   (~900 files)

 These manual sometimes have links to other info files that's not emacs.
 For example, on this page
 [[../emacs_manual/elisp/Changing-Files.html][Changing Files - GNU Emacs
 Lisp Reference Manual]], it contains a link to GNU coreutils like this:

 #+BEGIN_SRC emacs-lisp
     <a href="../coreutils/File-Permissions.html">File Permissions</a>
 #+END_SRC

 I need to change these links to non-links.

*** Solution

 Here's outline of steps.

 1. Open each file.
 2. Search for “href=”.
 3. Get the link URL.
 4. Check if the link is a local file and exists.
 5. If not, change the entire link tag into a “span” tag.
 6. Repeat the above, until no link found.

 First, we start like this:

 #+BEGIN_SRC emacs-lisp
     (setq inputDir "~/web/xahlee_org/emacs_manual/" )

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       …
     )

     ;; traverse the directory on all HTML files
     (require 'find-lisp)
 #+END_SRC

 The important part is the “my-process-file” function. Here's the basic
 code:

 #+BEGIN_SRC emacs-lisp
     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (…)

         ;; open file
         (setq myBuff (find-file fPath))

         (while
             ;; search local link
             (search-forward "href=\"../" nil t)

           ;; get the URL string
           (setq urlStr (thing-at-point 'filename) )

           ;; if the URL is a dead link
           (when (not (file-exists-p urlStr))
             (progn

               ;; set p1 and p2 to be the start/end of the link tag
               ;; and get the entire link string
               (sgml-skip-tag-backward 1)
               (setq p1 (point) ) ; start of link tag
               (sgml-skip-tag-forward 1)
               (setq p2 (point) ) ; end of link tag
               (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

               ;; get link text
               (search-backward "</a>")
               (setq p4 (point) ) ; end of link text
               (search-backward ">")
               (forward-char 1)
               (setq p3 (point) ) ; start of link text
               (setq linkText (buffer-substring-no-properties p3 p4) )

               ;; remove the link, replace it with a non-link span text.
               (delete-region p1 p2)
               (insert
                "<span class=\"εlink\" title=\""
                urlStr
                "\">"
                linkText
                "</span>"
                )
               )
             )
           )

         ;; close the file if no changes made
         (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

         ) )
 #+END_SRC

*** Complete Code

 Here's the complete code.

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2011-09-25
     ;; replace dead links in emacs manual on my website
     ;;
     ;; Example. This:
     ;; <a href="../widget/index.html#Top">Introduction</a>
     ;;
     ;; should become this
     ;;
     ;; <span class="εlink" title="../widget/index.html#Top">Introduction</span>
     ;;
     ;; do this for all files in a dir.

     ;; rough steps:
     ;; go thru each file
     ;; search for link
     ;; if the link is 「../xx/」 where the file doesn't exist, then replace the whole link tag.

     (setq inputDir "~/web/xahlee_org/emacs_manual/" ) ; dir should end with a slash

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (
             myBuff
             urlStr
             linkText
             wholeLinkStr
             p1 p2
             p3 p4
             )
         (setq myBuff (find-file fPath))
         (widen) ; in case it's open and narrowed
         (goto-char (point-max)) ; work from bottom, so that changes in point are preserved. (actually, doesn't really matter for this script)

         (while
             (search-backward "href=\"../" nil t)
           (forward-char 7)

           (when (not (file-exists-p urlStr))
             (progn
               (sgml-skip-tag-backward 1)
               (setq p1 (point) )                      ; start of link tag
               (sgml-skip-tag-forward 1)
               (setq p2 (point) )                      ; end of link tag

               (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

               (search-backward "</a>")
               (setq p4 (point) )                      ; end of link text
               (search-backward ">")
               (forward-char 1)
               (setq p3 (point) )                      ; start of link text

               (setq linkText (buffer-substring-no-properties p3 p4) )

               (princ (buffer-file-name))
               (princ "\n")
               (princ wholeLinkStr)
               (princ "\n")

               (delete-region p1 p2)
               (insert
                "<span class=\"εlink\" title=\""
                urlStr
                "\">"
                linkText
                "</span>"
                )
               )
             )
           )

         (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

         ) )

     (require 'find-lisp)

     (font-lock-mode 0)

     (with-output-to-temp-buffer "*xah elisp dead link replace output*"
         (princ "Done deal!")
         )

     (font-lock-mode 1)
 #+END_SRC

 Here's few interesting parts.

**** Turn Syntax Coloring Off

 We turn font lock off, by =(font-lock-mode 0)=. When font lock is on,
 processing 2 thousand HTML files will take ~50 minutes. With syntax
 coloring off, it's 3 minutes.

**** Leave Changed Files Open

 If there are changes in the file, we leave it open. This way, we don't
 have to revert to backup files if there's a mistake. If we like the
 result, just call =ibuffer= and press * u to mark all un-saved, then S
 to save all. Then press D to close them all. If you do not want to save
 them, simply mark all unsaved * u then press D to close all.

 This is extremely useful while you are still working on the code and
 doing some test runs. This interactive nature of emacs is what beats
 {Perl, Python, ...} for text processing.

 If you do want to save the file in the script, simply call
 =(save-buffer)= or =(write-file (buffer-file-name))=

 When the file is not modified, we close it. Like this:
 =(when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )=.

**** Use sgml-skip-tag-forward

 The =sgml-skip-tag-forward= and =sgml-skip-tag-backward= are from
 =html-mode=. They move the cursor to the beginning or ending of a tag.
 They are extremely useful. It saves you a lot time in writing code to
 parse tags, especially when tags are nested. Here's how we used it.

 Suppose there's this link in a file:

 #+BEGIN_SRC emacs-lisp
     <a href="../widget/index.html#Top">Introduction</a>
 #+END_SRC

 After we did the search with

 #+BEGIN_SRC emacs-lisp
      (while
       (search-backward "href=\"../" nil t)
       …
      )
 #+END_SRC

 the cursor is on the “h”. While the cursor is inside the tag, we call:

 #+BEGIN_SRC emacs-lisp
     (sgml-skip-tag-backward 1)
      (setq p1 (point) ) ; start of link tag
      (sgml-skip-tag-forward 1)
      (setq p2 (point) ) ; end of link tag

      (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )
 #+END_SRC

 This sets the value of wholeLinkStr to the entire anchor tag
 =<a …>…</a>=.

**** Print Output to Your Own Buffer

 Printing output is done here using =with-output-to-temp-buffer= and
 =princ=. Like this:

 #+BEGIN_SRC emacs-lisp
     (with-output-to-temp-buffer "*xah elisp dead link replace output*"
         (princ "Done deal!")
         )
 #+END_SRC

 Inside the “my-process-file” function, we write:

 #+BEGIN_SRC emacs-lisp
     (princ (buffer-file-name))
      (princ "\n")
      (princ wholeLinkStr)
      (princ "\n")
 #+END_SRC

 Here's a output from the script:
 [[file:elisp_fix_dead_links_output.txt]]. It lets me easily see if there
 are any errors. There are a total of 68 changes.

 For detail about printing in elisp, see:
 [[file:elisp_printing.html][Elisp: Print, Output]].

 --------------




 --------------

** Emacs Lisp vs Perl: Validate Local File Links


 This page shows 2 scripts to validate HTML local file links (i.e. check

 The 2 script's algorithms are not artificially made to be the same, but
 follow the natural style/idiom for each lang. They do the same job for
 my need.

*** Perl

 For each file, call “process_file”. That function then calls
 =get_links($file_full_path)= to get a list of links, then print the link
 if it leads to a non-existent file.

 The heart of the algorithm is the “get_links” function. It reads the
 whole file content as one big string, then split the string by the char
 “<”, then, for each segment of text, it proceed to find a link using
 regex.

 #+BEGIN_SRC emacs-lisp
     # -*- coding: utf-8 -*-
     # perl
     # 2004-09-21, …, 2012-04-07

     # given a dir, check all local links and inline images in the HTML files there. Print a report.
     # XahLee.org

     use strict;
     use Data::Dumper;
     use File::Find;
     use File::Basename;

     my $inDirPath = q{c:/Users/h3/web/xahlee_org/};

     # $inDirPath = $ARGV[0]; # should give a full path; else the $File::Find::dir won't give full path.

     die qq{dir $inDirPath doesn't exist! $!} unless -e $inDirPath;

     ##################################################
     # subroutines

     # get_links($file_full_path) returns a list of values in <a href="…">. Sample elements:  q[http://xahlee.org], q[../image.png], q[ab/some.html], q[file.nb], q[mailto:xah@xahlee.org], q[#reference], q[javascript:f('pop_me.html')]
     sub get_links ($) {
       my $full_file_path = $_[0];
       my @myLinks = ();
       open (FF, "<$full_file_path") or die qq[error: can not open $full_file_path $!];

       # read each line. Split on char “<”. Then use regex on 「href=…」 or 「src=…」 to get the url. This assumes that a tag 「<…>」 is not broken into more than one line.
       while (my $fileContent = <FF>) {
         my @textSegments = ();
         @textSegments = split(m/</, $fileContent);
         for my $oneLine (@textSegments) {
           if ($oneLine =~ m{href\s*=\s*"([^"]+)".*>}i) { push @myLinks, $1; }
           if ($oneLine =~ m{src\s*=\s*\"([^"]+)".*>}i) { push @myLinks, $1; }
         } }
       close FF;
       return @myLinks;
     }

     sub process_file {
       if (
           $File::Find::name =~ m[\.html$] &&
           $File::Find::dir !~ m(/xx)
          ) {
         my @myLinks = get_links($File::Find::name);

         map {
           s/#.+//; # delete url fragment identifier, eg http://example.com/index.html#a
           s/%20/ /g; # decode percent encode url
           s/%27/'/g;
           if ((!m[^http:|^https:|^mailto:|^irc:|^ftp:|^javascript:]i) && (not -e qq[$File::Find::dir/$_]) ) { print qq[• $File::Find::name $_\n];} }
           @myLinks;
      } }

     find(\&process_file, $inDirPath);

     print "\nDone checking. (any errors are printed above.)\n";
 #+END_SRC

 full updated code at
 [[http://xahlee.info/perl/perl_validate_local_links.html][Perl: Validate
 Local Links]]

*** Emacs Lisp

 For each file, call “my-process-file”. Then, the file is put into a
 buffer. Then, it uses regex search, and moving cursor, etc, to make sure
 that we find links we want to check.

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; elisp
     ;; 2012-02-01
     ;; check links of all HTML files in a dir

     ;; check only local file links in text patterns of the form:
     ;; < … href="link" …>
     ;; < … src="link" …>

     (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let ( $url $path p1 p2 p-current p-mb (checkPathQ nil) )

         ;; open file
         ;; search for a “href=” or “src=” link
         ;; check if that link points to a existing file
         ;; if not, report it

         (when (not (string-match "/xx" fPath)) ; skip file whose name starts with “xx”
           (with-temp-buffer
             (insert-file-contents fPath)
             (while
               (setq p-current (point) )
               (setq p-mb (match-beginning 0) )
               (setq $url (match-string 1))

               (save-excursion
                 (search-backward "<" nil t)
                 (setq p1 (point))
                 (search-forward ">" nil t)
                 (setq p2 (point))
                 )

               (when (and (< p1 p-mb) (< p-current p2) ) ; the “href="…"” is inside <…>
                 ;; set checkPathQ to true for non-local links and xahlee site, eg http://xahlee.info/
                       (setq $path (xahsite-url-to-filepath (replace-regexp-in-string "#.+$" "" $url))) ; remove trailing jumper url. For example: href="…#…"
                       (setq checkPathQ t)
                       )
                   (progn
                     (setq $path (replace-regexp-in-string "%27" "'" (replace-regexp-in-string "#.+$" "" $url)) )
                     (setq checkPathQ t)
                     )
                   )

                 (when checkPathQ
                   (when (not (file-exists-p (expand-file-name $path (file-name-directory fPath))))
                     (princ (format "• %s %s\n" (replace-regexp-in-string "^c:/Users/h3" "~" fPath) $url) )
                     )
                   (setq checkPathQ nil) )

                 ) ) ) ) ) )

     (require 'find-lisp)

     (let (outputBuffer)
       (setq outputBuffer "*xah check links output*" )
       (with-output-to-temp-buffer outputBuffer
         (princ "Done deal!")
         )
       )
 #+END_SRC

*** What's Valid HTML

 Note that the HTML files are assumed to be W3C valid (i.e. no missing
 closing tags or missing “>”). However, my code are not general enough to
 cover arbitrary valid HTML. SGML based HTML are very complex, and isn't
 just nested tags, but such HTML are basically never used. The perl and
 elisp code here work correctly (get all links) for perhaps 99.9% HTML
 files out there. (symbolic links or other alias mechanisms on file
 system are not considered.)

**** Edge Case Examples

 Here's some edge cases. These examples show that you cannot simply use
 regex to search for the pattern =<a href="…" …>=. Here's a most basic
 example:

 #+BEGIN_SRC emacs-lisp
     <a href="math.html" title="x > y">math</a>
 #+END_SRC

 Note that the above is actually valid HTML according to W3C's validator.
 Also, note that pages passing W3C validator are not necessarily valid by
 W3C's HTML spec. [see
 [[http://xahlee.info/js/w3c_html_validator_problem.html][W3C HTML
 Validator Invalid]]]

 One cannot simply use regex to search for pattern =<a href="…" …>=, and
 this is especially so because some HTML pages contains sample HTML code
 for teaching HTML, and ohters are programing tutorials containing code
 example of using regex to parse HTML. So, the HTML is sometimes HTML
 embedded in HTML, or HTML code in regex in python code on a HTML page.

 The following shows that patterns such as =href="…"= or =src="…"= are
 not necessarily HTML links.

 [[file:feed_0/article_37/images/img1_u3.png]]

 HTML in HTML, and HTML in regex in python code in HTML.

*** Perl vs Emacs Lisp

 One thing interesting is to compare the approaches in perl and emacs
 lisp.

 For our case, regex is not powerful enough to deal with the problem by
 itself, due to the nested nature of HTML. This is why, in my perl code,
 i split the file by “<” into segments first, then, use regex to deal
 with now the non-nested segment. This will break if you have
 =<a title="x < href=z" href="math.html">math</a>=. This cannot be worked
 around unless you really start to write a real parser.

 The elisp here is more powerful, not because of any lisp features, but
 because emacs's buffer datatype. You can think of it as a glorified
 string datatype, that you can move a cursor back and forth, or use regex
 to search forward or backward, or save cursor positions (index) and grab
 parts of text for further analysis.

 also, might checkout my perl tutorial
 [[http://xahlee.info/perl/perl_basics_1.html][Learn Perl in 1 Hour]]

***** Validate HTML File Local Links

 - [[http://xahlee.info/golang/golang_validate_links.html][Golang]]
 - [[http://xahlee.info/perl/perl_validate_local_links.html][Perl]]
   Lisp]]

 - [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
   Perl]]
 - [[file:elisp_basics.html][Emacs Lisp Basics]]
 - [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
 - [[http://xahlee.info/UnixResource_dir/writ/notations_mma.html][Intro
   to Mathematica Pattern Matching for Lisp Programers]]
 - [[http://xahlee.info/UnixResource_dir/writ/Mathematica_expressiveness.html][Normalize
   Function in Haskell, Ruby, Python, Perl, Scheme Lisp, JavaScript,
   Java, C]]

***** Misc Technical Essays on Emacs Lisp

 - [[../misc/elisp_naming_convention.html][Emacs Lisp Naming Convention]]
 - [[../misc/emacs_lisp_some_and_every.html][Elisp: Some and Every]]
 - [[../misc/emacs_lisp_what_is_fn.html][Elisp: What is the Function
   fn?]]
 - [[../misc/elisp_symbol_vs_string_for_non_nil.html][Emacs Lisp: Symbol
   vs String]]
 - [[../misc/elisp_list_function_type_syntax_coloring.html][Meaning of
   Lisp List, Function Type, and Syntax Coloring]]
   Lisp vs Perl: Validate Local File Links]]
 - [[../emacs/elisp_text_processing_lang.html][Text Processing: Emacs
   Lisp vs Perl]]
 - [[../emacs/elisp_namespace_solution_copying_javascript_practice.html][Can
   Emacs Lisp Fix Its Namespace Problem by Copying JavaScript Practice?]]
 - [[../misc/js_tutorial_and_emacs_lisp_vs_javascript.html][Emacs Lisp vs
   JavaScript?]]
 - [[../emacs/elisp_common_lisp_in_emacs.html][Controversy of Common Lisp
   Package in Emacs Lisp]]
 - [[../emacs/lisp_list_problem.html][Lisp's List Problem]]
 - [[../emacs/lisp1_vs_lisp2.html][Lisp-1 vs Lisp-2]]
 - [[../emacs/modernization_elisp_lib_problem.html][Emacs Lisp Problems:
   Trim String, Regex Match Data, Lacking Namespace]]
 - [[../emacs/thing-at-point_chaining_functions.html][Functional
   Programing: Function Output Should Always Have the Same Structure]]

 --------------




 --------------

** Elisp: Text Processing, Transforming Page Tag


 This page shows a example of using emacs lisp for text processing. It is

*** Problem

 You have hundreds of HTML pages that have a nav bar like this:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page:
     <a href="1.html">1</a>,
     <a href="2.html">2</a>,
     <a href="3.html">3</a>,
     …
     </div>
 #+END_SRC

 It looks like this in browser (with
 [[http://xahlee.info/js/css_index.html][CSS]]):

 [[file:feed_0/article_38/images/img1_u1.png]]

 This is the page navigation bar. Note that the page contains a link to
 itself.

 You want to remove the self-link. The result should look like this:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page:
     1,
     <a href="2.html">2</a>,
     <a href="3.html">3</a>,
     …
     </div>
 #+END_SRC

 [[file:feed_0/article_38/images/img2.png]]

*** Solution

 Here are the steps we need to do for each file:

 1. open the file.
 2. move cursor to the beginning of page navigation string.
 3. move cursor to file name.
 4. call =sgml-delete-tag= to remove the anchor tag. (=sgml-delete-tag=
    is from =html-mode=)
 5. save file.
 6. close buffer.

 We begin by writing a test code to process a single file.

 #+BEGIN_SRC emacs-lisp
     (defun my-process-file-navbar (fPath)
       "Modify the HTML file at fPath."
       (let (fName myBuffer)
         (setq fName (file-name-nondirectory fPath))
         (setq myBuffer (find-file fPath))
         (widen) ; in case buffer already open, and narrow-to-region is in effect
         (goto-char 1)
         (search-forward "<div class=\"pages\">Goto Page:")
         (search-forward fName)
         (sgml-delete-tag 1)
         (save-buffer)
         (kill-buffer myBuffer)))

     (my-process-file-navbar "~/test1.html")
 #+END_SRC

 For testing, create files {=test1.html=, =test2.html=, =test3.html=} in
 a temp directory for testing this code. Place the following content into
 each file:

 #+BEGIN_SRC emacs-lisp
     <div class="pages">Goto Page: <a href="test1.html">XYZ Overview</a>, <a href="test2.html">Second Page</a>, <a href="test3.html">Summary Z</a></div>
 #+END_SRC

 (note that the link text may not be 1, 2, 3.)

 The elisp code above is very basic.

 - =find-file= → open file. [[../emacs_manual/elisp/Files.html][(info
   "(elisp) Files")]]
 - =search-forward= → move cursor.
   [[../emacs_manual/elisp/Buffers.html][(info "(elisp) Buffers")]]
 - =kill-buffer= → close buffer.
   [[../emacs_manual/elisp/Searching-and-Matching.html][(info "(elisp)
   Searching and Matching")]].

 =sgml-delete-tag= is from =html-mode= (which is automatically loaded
 when a HTML file is opened).

 =sgml-delete-tag= deletes the opening/closing tags tags the cursor is
 on.

 All we need to do now is to feed it a bunch of file paths.

 To get the list of files that contains the page-nav tag, we can simply
 use linux's “find” and “grep”, like this:

 #+BEGIN_SRC emacs-lisp
     find . -name "*\.html" -exec grep -l '<div class="pages">' {} \;
 #+END_SRC

 From the output, we can use
 [[file:emacs_string-rectangle_ascii-art.html][string-rectangle]] and
 [[file:emacs_find_replace.html][query-replace]], to construct the
 following code:

 #+BEGIN_SRC emacs-lisp
     (mapc 'my-process-file-navbar
           [
            "~/web/cat1html"
            "~/web/dog.html"
            "~/web/something.html"
            "~/web/xyz.html"
            ]
           )
 #+END_SRC

 The =mapc= is a lisp idiom of looping thru a
 [[file:elisp_list.html][list]] or [[file:elisp_vector.html][vector]].
 The first argument is a function. The function will be applied to every
 element in the list. The single quote in front of the function is
 necessary. It prevents the symbol “my-process-file-navbar” from being
 evaluated (as a expression of a variable).

 Emacs ♥

 - [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
   Transform FAQ Tags]]
 - [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
   Perl]]

 --------------




 --------------

** Process HTML with Emacs Lisp: Transform FAQ Tags


 This page shows a example of using emacs lisp to do a text processing
 Python for processing nested text.

*** Problem

 I want to write a elisp program, that process a HTML file in a somewhat
 complex way. Specifically, certain strings must be replaced only if they
 appear inside a tag and or only if they are first child.

**** Detail

 I have many web pages that are in Questions And Answers format. The
 following is a sample screenshot.

 [[file:feed_0/article_39/images/img1_u2.png]]

 The following is a example of the raw HTML:

 #+BEGIN_SRC emacs-lisp
     <p class="q">Q: Why …</p>
     <p class="a">A: Because …</p>
     <p class="a">You need to do …</p>
     …
     <p class="q">Q: How …</p>
     <p class="a">A: Do this …</p>
     <p class="a">And that …</p>
     …
 #+END_SRC

 Basically, each Question section is a paragraph of class “q”, and each
 Answer section is several =<p>= tags with class “a”.

 After a few years with this format, i started to use a better format.
 Specifically, a Answer section should just be wrapped with a single
 =<div class="a">…</div>=. And, the “Q: ” and “A: ” string are removed
 from content (because CSS can insert that automatically, like this:
 =p.q:before {content:"Q: "}=.). Here's a example of the new format:

 #+BEGIN_SRC emacs-lisp
     <p class="q">Why?</p>

     <div class="a">
     <p>Because this.</p>
     <p>You need to that.</p>
     </div>
 #+END_SRC

 The task i have now, is to transform existing pages to this new format.
 Here's what needs to be done precisely:

 For any consecutive blocks of =<p class="a">…</p>=, wrap them with a
 =<div class="a">= and =</div>=, then replace those =<p class="a">= by
 =<p>=. Also, remove those “Q: ” and “A: ”.

 Although this is simple in principle, but without using a HTML parser,
 it's hard to code it as described. Using a HTML parser has its own
 problems. The HTML/DOM model would make the code much more complex, and
 the output will change the placement of whitspaces. Unless we are doing
 XML transformation on a larger scale, the HTML/DOM parser is usually not
 what we want. A text-based search-and-replace algorithm to achieve the
 above is as follows:

 For each occurrence of =<p class="q">=, do the following:

 - Add a =<div class="a">= right after =<p class="q">…</p>=.
 - Add a =</div>= right before =<p class="q">=.
 - Replace =<p class="q">Q: = by =<p class="q">=, replace
   =<p class="a">A: = by =<p class="a">=

 then:

 - Replace the first occurrence of =</div>= that happens before the first
   occurrence of =<p class="q">=.
 - Add a =</div>= that happens after the last =<p class="a">…</p>= tag.
 - Replace all =<p class="a">= to =<p>=.

 We proceed to write a elisp code to solve this problem.

*** Solution

 The algorithm described sounds simple, but isn't trivial if you do it in
 Perl or Python. For example, one of the step is:

 #+BEGIN_QUOTE
   Add a =<div class="a">= right after =<p class="q">…</p>=.
 #+END_QUOTE

 It would involve some coding to get the meaning of “right after”
 correct. Similarly, other steps involves finding a string immediately
 before or after occurrences of another string, with condition such as no
 more of a string comes after.

 With emacs, this is much easier, because emacs has buffer representation
 of files with a pointer that can move back and forth. So, we can just
 search by regex forward or backward and freely move our cursor and
 compare positions to locate the right piece of text.

 First, we write a prototype that just works on a single file. Here's the
 code:

 #+BEGIN_SRC emacs-lisp
     (defun xx ()
       "temp test function"
       (interactive)
       (find-file "elisp_process_html_sample.html")
       (goto-char 1)

     ;; add opening and closing tags for answer section
     ;; this is done by locating the opening question tag,
     ;; then move to the end of tag, then insert <div class="a">
     ;; then, locate the next opening question tag but move backward to </p>,
     ;; then insert </div>
       (while (search-forward "<p class=\"q\">" nil t)
         (search-forward "<p class=\"a\">")
         (replace-match "<div class=\"a\">\n<p class=\"a\">")
         (if (search-forward "<p class=\"q\">" nil t)
             (progn
               (search-backward "</p>")
               (forward-char 4)
               (insert "\n</div>")
               )
           )
         )

     ;; add the last closing tag for answer section
       (end-of-buffer)
       (search-backward "<p class=\"a\">")
       (search-forward "</p>")
       (insert "\n</div>")

     ;; take out the “Q: ” and “A: ”
       (beginning-of-buffer)
       (while (search-forward "<p class=\"q\">Q: " nil t)
         (replace-match "<p class=\"q\">"))

     ;; replace “<p class="a">” by “<p>”.
       (beginning-of-buffer)
       (while (search-forward "<p class=\"a\">A: " nil t)
         (replace-match "<p>"))
     )
 #+END_SRC

 This is a simple code. It uses emac's power of buffer data structure for
 files, by moving a pointer back and forth to a desired place, then do
 search and replace text or insert. With the ability of moving a point to
 a particular string, we are able to locate the places we want the tag
 insertion to happen, without explicitly going by the DOM model of
 parent-child relationship of tags.

 In the above code, the =search-forward= function moves the cursor to the
 end of matched text. It returns “nil” if not found. The
 =search-backward= works similarly, but put the point on the beginning of
 matched text.

 The =replace-match= just replaces previously matched text. The
 =end-of-buffer= moves the point to the end of buffer. Similarly for
 =beginning-of-buffer=.

 [[../emacs_manual/elisp/String-Search.html][(info "(elisp) String
 Search")]]

 Now, if we want to process many files, first we need to change the code
 to take a file path, and add code to save buffer and close buffer. Like
 this:

 #+BEGIN_SRC emacs-lisp
     (defun my-process-html (fPath)
       "Process a file at FPATH…"
       (let (myBuffer)
         (setq myBuffer (find-file fPath))
         ; code body here
         (save-buffer)
         (kill-buffer myBuffer)
       )
     )
 #+END_SRC

 To get the list of files containing the Q and A section, we can simply
 use unix's “find” and “grep”, like this:
 =find . -name "*\.html" -exec grep -l '<p class="q">' {} \;=. (or just
 use emacs. See: [[file:elisp_grep_script.html][Elisp: Write grep]].)

 Then, place the list of files into a list and map over the list, like
 this:

 #+BEGIN_SRC emacs-lisp
     (mapc 'my-process-html
             (list
     "/Users/xah/web/emacs/emacs_adv_tips.html"
     "/Users/xah/web/emacs/emacs_display_faq.html"
     "/Users/xah/web/emacs/emacs_esoteric.html"
     "/Users/xah/web/emacs/emacs_html.html"
     "/Users/xah/web/emacs/emacs_n_unicode.html"
     "/Users/xah/web/emacs/emacs_unix.html"
     "/Users/xah/web/emacs/keyboard_shortcuts.html"
     "/Users/xah/web/emacs/modernization.html"
     "/Users/xah/web/img/imagemagic.html"
     "/Users/xah/web/java-a-day/abstract_class.html"
     "/Users/xah/web/sl/build_q.html"
     "/Users/xah/web/sl/q.html"
     "/Users/xah/web/UnixResource_dir/macosx.html"
     "/Users/xah/web/UnixResource_dir/writ/mshatredfaq.html"
     "/Users/xah/web/UnixResource_dir/writ/tabs_vs_spaces.html"
              )
     )
 #+END_SRC

 The =mapc= is a lisp idiom of applying a function to all elements in a
 list. The first argument is a function. The second argument is a list.
 The single quote in front of the function is necessary. It prevents the
 function from being evaluated. Otherwise, normally lisp evaluates all
 arguments in the expression =(f a b c …)=.

 (thanks to Ivanov Dmitry for a correction in the elisp code.)

 Emacs ♥

 - [[file:elisp_text_processing.html][Elisp: Text Processing,
   Transforming Page Tag]]
 - [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
   Perl]]

 --------------




 --------------

** Elisp: Process HTML, span, code, Key, Title, Markups


 This page is a tutorial, showing a real-world example of using emacs

*** Problem

 I need to transform many HTML tags. Typically, they are of the form
 =begin_delimiter…end_delimiter=, where the delimiters may be curly
 quotes =“…”=, or it may be a HTML tag such as
 =<span class="xyz">…</span>=.

 I need to apply the transformation on over 4 thousand HTML pages, and
 needs it to be accurate, mostly on a case-by-case base with human watch.

 Also, the delimiters may be nested, so regex won't work. They either
 getting too much text (using default greedy match) or getting not enough
 text (using shy group). With a elisp script, you can use =if= and other
 emacs functions, to correctly find the matching ending tag, as well
 automatically skip cases that this transform should not apply, so
 drastically reduce the need for human watch.

**** Detail

 In the past week, i spend about 2 days and done a lot text processing
 with elisp on the 4 thousand files of my site. Here's the changes i've
 made:

 - book title. For example: “Art Of Programing” ⇒ 〈Art Of Programing〉
 - article title. For example: “How to Edit Elisp Code with Emacs” ⇒
   〈How to Edit Elisp Code with Emacs〉
 - computer code. For example: “(setq x 1)” ⇒ 「(setq x 1)」
 - file path. For example: “~/Documents/emacs/” ⇒ 〔~/Documents/emacs/〕
 - keyboard shortcut notation. For example: “Ctrl+c” ⇒ 【Ctrl+c】

 The purpose of the change is to make the syntactical markup more
 semantically precise. Before, they are all marked by double curly
 quotes. Now, if i want to find all books i cited on my site, i can do so
 easily by a simple search on a special bracket for book titles. These
 changes also make the text easier to read. In the future, if i want all
 book titles to be colored red for example, i can easily do that by
 changing the 《》 to a HTML markup (For example,
 =<span class="title">…</span>=), or use a JavaScript to do that on the
 fly. Same for emacs keybinding. For example, with this clear syntax,
 it's easier to write a [[http://xahlee.info/js/js.html][JavaScript]] so
 that when mouse is hovering over the keybinding notation, it shows a
 balloon of the command name for that key. [see
 [[http://xahlee.info/js/tooltips.html][JavaScript: How to Create
 Tooltip/Balloon]]]

 All this is part of the
 [[http://xahlee.info/js/html_microformat.html][HTML Microformat]], which
 is part of semantic web concept. The basic ideas is that, the syntax
 encodes semantics. This advantage is part of the major reason XML
 becomes so useful. (the other reason is its regular syntax.)

 For info on various brackets used, see:
 [[http://wordyenglish.com/musing/chinese_punctuation.html][Intro to
 Chinese Punctuation]] and
 [[http://xahlee.info/comp/unicode_matching_brackets.html][Matching
 Brackets in Unicode]].

 Also, much of the HTML markup on my site has been cleaned up. For
 example:

 - =<span class="code">…</span>= ⇒ =<code>…</code>=
 - =“<span class="code">…</span>”= ⇒ =<code>…</code>= (Remove the
   redundant curly quote. Was a struggle to make a decision on this. Note
   that it can be auto added with
   [[http://xahlee.info/js/index.html][Cascading Style Sheet (CSS)]] if
   needed.)
 - =<span class="key">…</span>= ⇒ =<kbd>…</kbd>= (Change to standard tag;
   reduce char count.)
 - =<span class="kbd">…</span>= ⇒ =…= (Remove the tag. Was designed to
   mark emacs key notation, but doesn't make much sense. Now, 【】 does
   it.)

 There are several advantages in these changes. For example, =<code>= is
 much shorter than =<span class="code">=, and it has a standard meaning.
 It is also more unique than “span” tag, so that reduce parsing
 complexity when i need to process “span” tags.

 [see
 [[http://xahlee.info/kbd/keyboard_notation_design_issues.html][Keyboard
 Notation Design Issues]]]

*** Solution

 To do these tag transformations, simple cases such as

 #+BEGIN_SRC emacs-lisp
     “file path” ⇒ 〔file path〕
 #+END_SRC

 , where the delimiters are single characters and there's no nesting,
 they can be done with emacs's =dired-do-query-replace-regexp=. [see
 [[file:find_replace_inter.html][Emacs: Find Replace Text in Directory]]]

 More complicated cases with nested HTML tags, can be done with a elisp
 script. Here's the general plan.

 1. Open the file
 2. Search for the tag
 3. If found, move to the beginning of tag, mark positions of begin/end
    of the opening tag
 4. Use =sgml-skip-tag-forward= to move to the end matching tag
 5. Mark positions of begin/end of the ending tag
 6. Replace the begin/end tags with new tags
 7. Repeat

 To open the file, we can use =find-file=.

 To search for the tag, we do:

 #+BEGIN_SRC emacs-lisp
     (while
      (search-forward "<span class=\"code\">"  nil t)
     …
     )
 #+END_SRC

 We give “t” for the third argument. It means don't complain if not
 found.

 The next step is to get the begin/end positions of the opening tag. The
 end position is simply the current cursor position, because the
 search-forward automatically place it there. To get the beginning
 position, we just use search-backward on “<”

 Now, we need to get the begin/end positions of the matching end tag.
 This may be a problem because the tags are nested, so there may be many
 =</span>= before the one we want.

 The good thing is that emacs's =html-mode= has =sgml-skip-tag-forward=
 function. It will move cursor from a beginning tag to its matching end
 tag.

 Once we got the begin/end positions for the begin/end tags, we can now
 easily do replacement. Just use =delete-region=, then use =insert= to
 insert the new tag we want. One thing important is that we should do
 replacement with the ending tag first, because if we replace the
 beginning tag first, the positions of the ending tag will be changed.

**** Complete Code

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2010-08-25

     ;; change
     ;; <span class="code">…</span>
     ;; to
     ;; 「…」

     (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

     (defun my-process-file (fPath)
       "process the file at fullpath fPath …"
       (let ( myBuff changedQ p3 p4 p8 p9)

         ;; open the file
         ;; search for the tag
         ;; if found, move to the beginning of tag, mark positions of begin/end of < and >
         ;; use sgml-skip-tag-forward to move to the end matching tag </span>
         ;; mark positions of begin/end of < and >
         ;; replace them with 「 and 」
         ;; repeat
         (setq myBuff (find-file fPath ) )
         (setq changedQ nil )

         (goto-char 1)
         (while
             (search-forward "<span class=\"code\">"  nil t)
           (backward-char 1)
           (if (looking-at ">")
               (setq p4 (1+ (point)) )
             (error "expecting <" )
             )

           ;; go to beginning of "<span class="code">"
           (sgml-skip-tag-backward 1)
           (if (looking-at "<")
               (setq p3 (point) )
             (error "expecting <" )
             )
           (forward-char 2)

           ;; go to end of </span>
           (sgml-skip-tag-forward 1)
           (backward-char 1)
           (if (looking-at ">")
               (setq p9 (1+ (point)) )
             (error "expecting >" )
             )

           ;; go to beginning of </span>
           (backward-char 6)
           (if (looking-at "<")
               (setq p8 (point) )
             (error "expecting <" )
             )

           (when (y-or-n-p "change? ")
             (delete-region p8 p9  )
             (insert "」")
             (delete-region p4 p3 )
             (goto-char p3)
             (insert "「")
             (setq changedQ t )
             ))

         ;; if not changed, close it. Else, leave buffer open
         (if changedQ
             (progn (make-backup))                        ; leave it open
           (progn (kill-buffer myBuff))
           )
         ))

     (require 'find-lisp)

     (let (outputBuffer)
       (setq outputBuffer "*span tag to code tag*" )
       (with-output-to-temp-buffer outputBuffer
         (princ "Done deal!")
         )
       )
 #+END_SRC

 In the code above, i also put extra checks to make sure that the
 position of beginning tag is really the =<= char. Same for ending tag.
 (probably redundant, but i tend to be extra careful.)

 Also, i used a =y-or-n-p= function, so emacs will prompt me for each
 change that i can visually check.

 For those files that are changed, i leave them open. So, if i decided on
 a whim i don't want all these to happen on potentially hundreds of files
 that i've changed, i can simply close all the buffer with 4 keystrokes
 with =ibuffer=. Same if i want to save them all. [see
 [[file:emacs_buffer_management.html][Emacs: ibuffer tutorial]]]

 For files that no change takes place, the buffer is simply closed.

 In the above, i also called “make-backup”. I want to make a backup of
 changed file, but not relying on emac's automatic backup mechanism (i
 have it turned off). For the code, see:
 [[file:elisp_make-backup.html][Emacs: Backup Current File]].

 Emacs is fantastic!

 - [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
   Transform FAQ Tags]]
 - [[file:elisp_text_processing.html][Elisp: Text Processing,
   Transforming Page Tag]]
 - [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
   Perl]]

 --------------




 --------------

** Elisp: Batch Transform HTML to HTML5 “figure” Tag


 Another triumph of using elisp for text processing over {Perl, Python}.
*** Problem

 I want batch transform the image tags in 5 thousand HTML files to use
 HTML5's new “figure” and “figcaption” tags.

 I want to be able to view each change interactively, while optionally
 give it a “go ahead” to do the whole job in batch.

 Interactive eyeball verification on many cases lets me be reasonably
 sure the transform is done correctly. It also lets me see whether i want
 to push forward with this change.

**** Detail

 [[http://xahlee.info/js/html5_tags.html][HTML5]] has the following new
 tags: “figure” and “figcaption”. They are used like this:

 #+BEGIN_SRC emacs-lisp
     <figure>
     <img src="cat.jpg" alt="my cat" width="167" height="106">
     <figcaption>my cat!</figcaption>
     </figure>
 #+END_SRC

 (For detail, see:
 [[http://xahlee.info/js/html5_figure_figurecaption.html][HTML5 “figure”
 and “figurecaption” Tags Browser Support]])

 On my website, i used a similar structure. They look like this:

 #+BEGIN_SRC emacs-lisp
     <div class="img">
     <img src="cat.jpg" alt="my cat" width="167" height="106">
     <p class="cpt">my cat!</p>
     </div>
 #+END_SRC

 So, i want to replace them with the HTML5's new tags. This can be done
 with a regex. Here's the “find” regex:

 #+BEGIN_SRC emacs-lisp
     <div class="img">
     ?<img src="\([^"]+?\)" alt="\([^"]+?\)" width="\([0-9]+?\)" height="\([0-9]+?\)">?
     <p class="cpt">\([^<]+?\)</p>
     ?</div>
 #+END_SRC

 Here's the replacement string:

 #+BEGIN_SRC emacs-lisp
     <figure>
     <img src="\1" alt="\2" width="\3" height="\4">
     <figcaption>\5</figcaption>
     </figure>
 #+END_SRC

 Then, you can use =find-dired= and dired's
 =dired-do-query-replace-regexp= to work on your 5 thousand pages. Nice.
 [see [[file:find_replace_inter.html][Emacs: Find Replace Text in
 Directory]]]

 However, the problem here is more complicated. There may be more than
 one image per group. Also, the caption part may also contain complicated
 HTML. Here's some examples:

 #+BEGIN_SRC emacs-lisp
     <div class="img">
     <img src="cat1.jpg" alt="my cat" width="200" height="200">
     <img src="turtle.jpg" alt="my turtle" width="200" height="200">
     <p class="cpt">my cat and my turtle</p>
     </div>
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
     <div class="img">
     <img src="jamie_cat.jpg" alt="jamie's cat" width="167" height="106">
     <p class="cpt">jamie's cat! Her blog is <a href="http://example.com/jamie/">http://example.com/jamie/</a></p>
     </div>
 #+END_SRC

 So, a solution by regex is out.

*** Solution

 The solution is pretty simple. Here's the major steps:

 1. Use =find-lisp-find-files= to traverse a dir. Needes
    =(require 'find-lisp)=.
 2. For each file, open it.
 3. Search for the string =<div class="img">=.
 4. Use =sgml-skip-tag-forward= to jump to its closing tag.
 5. Save the positions of these tag begin/end positions.
 6. Ask user if she wants to replace. If so, do it. (using
    =delete-region= and =insert=)
 7. Repeat.

 Here's the code:

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2011-07-03
     ;; replace image tags to use HTML5's “figure”  and “figcaption” tags.

     ;; Example. This:
     ;; <div class="img">…</div>
     ;; should become this
     ;; <figure>…</figure>

     ;; do this for all files in a dir.

     ;; rough steps:
     ;; find the <div class="img">
     ;; use sgml-skip-tag-forward to move to the ending tag.
     ;; save their positions.
     ;; ask user whether to replace, if so, delete them and insert new string

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (myBuff p1 p2 p3 p4 )
         (setq myBuff (find-file fPath))

         (widen)
         (goto-char 1) ;; in case buffer already open

         (while (search-forward "<div class=\"img\">" nil t)
           (progn
             (setq p2 (point) )
             (backward-char 17) ; beginning of “div” tag
             (setq p1 (point) )

             (forward-char 1)
             (sgml-skip-tag-forward 1) ; move to the closing tag
             (setq p4 (point) )
             (backward-char 6) ; beginning of the closing div tag
             (setq p3 (point) )
             (narrow-to-region p1 p4) 

             (when (y-or-n-p "replace?")
               (progn 
                 (delete-region p3 p4 )
                 (goto-char p3)
                 (insert "</figure>")

                 (delete-region p1 p2 )
                 (goto-char p1)
                 (insert "<figure>")
                 (widen) ) ) ) )

         (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

         ) )

     (require 'find-lisp)

     (let (outputBuffer)
       (setq outputBuffer "*xah img/figure replace output*" )
       (with-output-to-temp-buffer outputBuffer 
         (princ "Done deal!")
         ) )
 #+END_SRC

 Seems pretty simple right?

 The “p1” and “p2” variables are the positions of start/end of
 =<div class="img">=. The “p3” and “p4” is the start/end of its closing
 tag =</div>=.

 We also used a little trick with =widen= and =narrow-to-region=. It lets
 me see just the part that i'm interested. It narrows to the
 beginning/end of the div.img. This makes eyeballing a bit easier.

 The real time-saver is the =sgml-skip-tag-forward= function from
 =html-mode=. Without that, one'd have to write a mini-parser to deal
 with HTML's nested ways to be able to locate the proper ending tag.

 Using the above code, i can comfortably eyeball and press “y” at the
 rate of about 5 per second. That makes 300 replacements per minute. I
 have 5000+ files. If we assume there are 6k replacement to be made, then
 at 5 per second means 20 minutes sitting there pressing “y”. Quite
 tiresome.

 So, now, the next step is simply to remove the asking
 =(y-or-n-p "replace?")=. Or, if i'm absolutely paranoid, i can make
 emacs write into a log buffer for every replacement it makes (together
 with the file path). When the batch replacement is done (probably takes
 1 or 2 minutes), i can simply scan thru the log to see if any
 replacement went wrong. For a example of that, see:
 [[file:elisp_replace_title_tags.html][Elisp: Multi-Pair String
 Replacement with Report]].

 Also note that i left each changed file unsaved in emacs. If i decided i
 didn't want to commit the changes, i can exit emacs without saving. Or,
 i can go to =ibuffer= and press 3 keys to save and close them all * u S.
 But if you want them saved with elisp, you can just add =(save-buffer)=.
 Note that emacs automatically makes a backup~ of the original files if
 you haven't turned that off.

 But what about replacing =<p class="cpt">…</p>= with
 =<figcaption>…</figcaption>=?

 I simply copy-pasted the above code into a new file, and make changes in
 4 places. So, the replacing figcaption part is done in a separete second
 batch job. Of course, one could spend extra hour to make the code do
 them both in one pass, but that extra time of thinking and coding isn't
 worthwhile for this one-time job.

 I ♥ Emacs, do you?

**** Change in Current Buffer

 Here's the code that changes both {div.img, p.cpt} to {figure,
 figcaption} in one shot, on the current buffer. It output the changes to
 a temp buffer, so you can scan it.

 #+BEGIN_SRC emacs-lisp
     (defun xah-fix-wrap-img-figure ()
       "Change current buffer's <div class=\"img\"> to <figure> and <p class=\"cpt\"> to <figcaption>."
       (interactive)

       (save-excursion 
         (let (p1 p2 p3 p4 
                  myStr
                  $changes
                  (changedItems '())
                  (myBuff (current-buffer))
                  )

           (goto-char (point-min)) ;; in case buffer already open
           (while (search-forward "<div class=\"img\">" nil t)
             (progn
               (setq p2 (point) )
               (backward-char 17)
               (setq p1 (point) )

               (forward-char 1)
               (sgml-skip-tag-forward 1)
               (setq p4 (point) )
               (backward-char 6)
               (setq p3 (point) )

               (when t
                 (setq myStr (buffer-substring-no-properties p1 p4))
                 (setq changedItems (cons myStr changedItems ) )
                
                 (progn 
                   (delete-region p3 p4 )
                   (goto-char p3)
                   (insert "</figure>")

                   (delete-region p1 p2 )
                   (goto-char p1)
                   (insert "<figure>")
                    )
                 ) ) )

           (goto-char (point-min)) ;; in case buffer already open
           (while (search-forward "<p class=\"cpt\">" nil t)
             (progn
               (setq p2 (point) )
               (backward-char 15)
               (setq p1 (point) )

               (forward-char 1)
               (sgml-skip-tag-forward 1)
               (setq p4 (point) )
               (backward-char 4)
               (setq p3 (point) )

               (when t
                 (setq myStr (buffer-substring-no-properties p1 p4))
                 (setq changedItems (cons myStr changedItems ) )
                
                 (progn 
                   (delete-region p3 p4 )
                   (goto-char p3)
                   (insert "</figcaption>")

                   (delete-region p1 p2 )
                   (goto-char p1)
                   (insert "<figcaption>")
                    )
                 ) ) )

           (with-output-to-temp-buffer "*changed items*" 
             (mapc (lambda ( $changes) (princ $changes) (princ "\n\n") ) changedItems)
             (set-buffer "*changed items*")
             (funcall 'html-mode)
             (set-buffer myBuff)
             ) )) )
 #+END_SRC

 PS if you are wondering about that weird char “ξ” in the variable name,
 don't mind it, it's my personal experiment in variable naming. See:
 [[http://xahlee.info/comp/programing_variable_naming.html][Variable
 Naming: English Words Considered Harmful]].

 - [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
   Perl]]
 - [[file:elisp_batch_html_tag_transform_bold.html][Elisp: Processing
   HTML: Transform Tags from “span.w” to “b”]]

 --------------




 --------------

** Elisp: Transform HTML Tags from “span” to “b”


 This page shows a simple practical elisp script for HTML tag

*** Problem

 I want transform the HTML tag

 =<span class="w">…</span>=

 to

 =<b>…</b>=

 , for over a hundred files. Also, print a report of the changes.

*** Solution

 Here's outline of steps.

 1. Open the file. Use regex to search the span markup.
 2. Make the replacement.
 3. Add the replacement to a list, for later report.
 4. Repeat the above until no more found.
 5. Use a dir traverse function to apply the above to every file. [see
    [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]]
 6. When done, print the list of changes.

 Here's the code:

 #+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8 -*-
     ;; 2011-07-18
     ;; replace <span class="w">…</span> to <b>…</b>
     ;;
     ;; do this for all files in a dir.

     (setq inputDir "~/web/vocabulary/" ) ; dir should end with a slash

     (setq changedItems '())

     (defun my-process-file (fPath)
       "Process the file at FPATH …"
       (let (myBuff myWord)
         (setq myBuff (find-file fPath))

         (widen) (goto-char 1) ;; in case buffer already open

           (setq myWord (match-string 1))
           (when (< (length myWord) 15) ; a little double check in case of possible mismatched tag
             (replace-match (concat "<b>" myWord "</b>" )  t)
             (setq changedItems (cons (substring-no-properties myWord) changedItems ) )
             ) )

         ;; close buffer if there's no change. Else leave it open.
         (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )
         ) )

     (require 'find-lisp)

     (setq make-backup-files t)
     (setq case-fold-search nil)
     (setq case-replace nil)

     (let (outputBuffer)
       (setq outputBuffer "*xah span.w to b replace output*" )
       (with-output-to-temp-buffer outputBuffer
         (print changedItems)
         (princ "Done deal!")
         )
       )
 #+END_SRC

 Here's the output:
 [[file:elisp_batch_html_tag_transform_bold_output.txt]].

 There are over 1k changes. The output is extremely useful because i can
 just take a few seconds to glance at the output to know there are no
 errors. Errors are possible because whenever using regex to parse HTML,
 a missing tag in HTML or even a unexpected nested tag, can mean
 disaster.

 The code is simple. If you don't understand it, see:

 - [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
 - [[file:elisp_idioms.html][Elisp: How to Write Commands]]

 --------------




 --------------

** Elisp: How to Write a Toggle Command


 This page is a tutorial on how to write a command to toggle something.
 Here's a example to toggle background color.

 #+BEGIN_SRC emacs-lisp
     (defun xah-toggle-background-color ()
       "Toggle background color between seashell and honeydew.
     Version 2015-12-17"
       (interactive)
       ;; use a property “state”. Value is t or nil
       (if (get 'xah-toggle-background-color 'state)
           (progn
             (set-background-color "seashell")
             (put 'xah-toggle-background-color 'state nil))
         (progn
           (set-background-color "honeydew")
           (put 'xah-toggle-background-color 'state t))))
 #+END_SRC

 The gist to toggle, is to have a variable that we can set as current
 state.

 But usually, we don't want to use a global variable.

 The trick here, is to create a property for the function. In Emacs lisp,
 each symbol can have one or more properties. A property is basically a
 variable, but associated with the symbol only.

 [see [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]

 Here, we create a property named “state”. The value is =t= or =nil=.

*** Cycle Among States

 You can create a command that cycle between many states.

 Here's a example.

 #+BEGIN_SRC emacs-lisp
     (defun xah-cycle-background-color (@n)
       "Cycle background color among a preset list.

     If `universal-argument' is called first, cycle n steps. Default is 1 step.

     Version 2015-12-17"
       (interactive "p")
       ;; uses a property “state”. Value is a integer.
       (let* (
              ($values ["cornsilk" "pale green" "pale turquoise" "thistle" "seashell" "honeydew"])
              ($index-before
               (if (get 'xah-cycle-background-color 'state)
                   (get 'xah-cycle-background-color 'state)
                 0))
              ($index-after (% (+ $index-before (length $values) @n) (length $values)))
              ($next-value (aref $values $index-after)))

         (put 'xah-cycle-background-color 'state $index-after)

         (set-background-color $next-value)
         (message "background color changed to %s" $next-value)))
 #+END_SRC

 Here, we create a property named “state”. The value is a integer.

 In the function body, we have a variable that is the list of possible
 values. The property “state”, is used as index to this list.

 Each time the command is called, we check current state, then, use
 modular arithmetic over the length of states list to get the next value
 (integer index). Then, we set the value, and update the state.

 To create your own cycle something command, simply change the value list
 to what you want.

 --------------




 --------------

** Emacs: Uncolor Region/Buffer


 Normally, you can Alt+x =font-lock-mode= to turn off syntax coloring.
 But if you copied some text from another buffer into a new buffer,
 turning off =font-lock-mode= won't remove existing coloring.

 Here's a command that lets removes syntax coloring.

 #+BEGIN_SRC emacs-lisp
     (defun xah-unfontify-region-or-buffer ()
       "Unfontify text selection or buffer.
     Version 2017-05-31"
       (interactive)
       (if (use-region-p)
           (font-lock-unfontify-region (region-beginning) (region-end))
         (font-lock-unfontify-buffer)))
 #+END_SRC

 --------------




 --------------

** Emacs: Setup Mouse Click to Highlight Matching Words


 You can set mouse right-click to call =isearch-forward-symbol-at-point=

 Here's the command.

 #+BEGIN_SRC emacs-lisp
     (defun xah-mouse-click-to-search (@click)
       "Mouse click to start `isearch-forward-symbol-at-point' (emacs 24.4) at clicked point.
     Version 2016-07-18"
       (interactive "e")
       (let ((p1 (posn-point (event-start @click))))
         (goto-char p1)
         (isearch-forward-symbol-at-point)))
 #+END_SRC

 Here's the code to set the mouse (this example is for Linux only):

 #+BEGIN_SRC emacs-lisp
     ;; set mouse
     (cond
      ((string-equal system-type "windows-nt") ; Windows
       nil
       )
      ((string-equal system-type "gnu/linux")
       (global-set-key (kbd "<mouse-3>") 'xah-click-to-search) ; right button
       )
      ((string-equal system-type "darwin") ; Mac
       nil
       ) )
 #+END_SRC

 Note: mouse button and wheel have different syntax on {Microsoft
 Windows, Mac OS X, Linux}. To find the syntax, Alt+x =describe-key=,
 then press the button or wheel. [see
 [[file:emacs_mouse_wheel_config.html][Emacs: Mouse Config]]]

 --------------


