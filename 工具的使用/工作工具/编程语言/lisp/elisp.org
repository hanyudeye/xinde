* [[https://www.emacswiki.org/emacs?search=%22ElispCookbook%22][Elisp Cookbook]]
** Strings
   The empty string (zero-length string, null string, ...):

   #+BEGIN_EXAMPLE
   (string-equal  ""  "")
   ==> t
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   (equal  ""  "")
   ==> t
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
           (zerop (length  ""))
           ==> t
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
            ;; ` string-empty-p' was added in 24.4.
           ( eval-when-compile ( require ' subr-x))
           (string-empty-p  "")
           ==> t
   #+END_EXAMPLE

   As a (very minor) space and performance optimization, starting with Emacs 23, Emacs keeps an interned copy of the empty string as a single object

   #+BEGIN_EXAMPLE
           (eq  ""  "")
           ==> t  ; nil prior to Emacs 23
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
           (eq  "" (purecopy  ""))
           ==> t  ; nil prior to Emacs 23
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
           (eq  "" (propertize  "" 'face 'italic))
           ==> t  ; nil prior to Emacs 23
   #+END_EXAMPLE

*** Strings vs buffer text
    While it is quite common in other programming languages to work on strings contained in [[https://www.emacswiki.org/emacs/variable][variable]]s, in Emacs it is also common to work on text in [[https://www.emacswiki.org/emacs/buffer][buffer]]s.

*** Substrings
    #+BEGIN_EXAMPLE
            (substring  "abcdefg" 0 3)
            ==>  "abc"
            (substring  "abcdefg" -3 -1)
            ==>  "ef"
    #+END_EXAMPLE

    The TO argument is optional:

    #+BEGIN_EXAMPLE
            (substring  "abcdefg" -3)
            ==>  "efg"
    #+END_EXAMPLE

    Buffers:

    #+BEGIN_EXAMPLE
            ( with-temp-buffer (insert  "abcdefg") (buffer-substring 2 4))
            ==>  "bc"
    #+END_EXAMPLE

*** starts-with and ends-with predicates
    Standard functions:

    #+BEGIN_EXAMPLE
             ;; Since Emacs 23.1
            (string-prefix-p  "bull"  "bulldozer")    ; optional ignore case argument too
            ==> t
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
             ;; Since Emacs 24.4.
            (string-suffix-p  "dozer"  "bulldozer")   ; optional ignore case argument too
            ==> t
    #+END_EXAMPLE

    Custom functions:

    #+BEGIN_EXAMPLE
            ( defun  string/ends-with (s ending)
               "Return non-nil if string S ends with ENDING."
              ( cond ((>= (length s) (length ending))
                     (string= (substring s (- (length ending))) ending))
                    (t nil)))
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
            ( defun  string/starts-with (s begins)
               "Return non-nil if string S starts with BEGINS."
              ( cond ((>= (length s) (length begins))
                     (string-equal (substring s 0 (length begins)) begins))
                    (t nil)))
    #+END_EXAMPLE

    Alternatively, match using a [[https://www.emacswiki.org/emacs/RegularExpression][RegularExpression]]:

    #+BEGIN_EXAMPLE
            ( defun  string/ends-with (string suffix)
               "Return t if STRING ends with SUFFIX."
              (and (string-match (rx-to-string `(: ,suffix eos) t)
                                 string)
                   t))
    #+END_EXAMPLE

    The first argument to rx-to-string =`(: ,suffix eos)= is a regular expression in sexp form. The help page for “rx” elucidates the syntax:

    #+BEGIN_EXAMPLE
            (: SEXP1 SEXP2 ...)
            matches what SEXP1 matches, followed by what SEXP2 matches, etc.
    #+END_EXAMPLE

    =,suffix= is SEXP1 and =eos= is SEXP2 ='(: suffix eos)= would create a list of three elements: The symbol named “:”, the symbol named “suffix”, and the symbol named “eos”. But that's not what this function wants. It wants the *value* of the symbol named “suffix”, not the symbol itself. =`= is special syntax (note the backtick, not just tick) that allows some things in the list to be preceded by a comma, which are then evaluated. =`(: ,suffix eos)= is convenience syntax for =(list ': suffix 'eos)=. The only symbol that is evaluated is suffix. Because there is no =,= before =:= or =eos=, both =:= and =eos= are not evaluated. Symbols are not evaluated by default in the =`( ... )= syntax and require a =,= if you want them to be evaluated. Thanks to on #emacs-beginners irc channel for the explanation. See also [[https://www.emacswiki.org/emacs/BackquoteSyntax][BackquoteSyntax]].

    #+BEGIN_EXAMPLE
            ( defun  string/starts-with (string prefix)
               "Return t if STRING starts with prefix."
              (and (string-match (rx-to-string `(: bos ,prefix) t)
                                 string)
                   t))
    #+END_EXAMPLE

*** Processing characters


    Reversing a string:

    #+BEGIN_EXAMPLE
            ( defun  string/reverse (str)
               "Reverse the str where str is a string"
              (apply #'string 
                 (reverse 
                  (string-to-list str))))
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
             ;; Since 24.4
            ( require ' subr-x)
            (string-reverse  "abc")
            ==>  "cba"
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
             ;; Since 25.1
            (reverse  "abc")
            ==>  "cba"
    #+END_EXAMPLE

    See [[https://www.emacswiki.org/emacs/CharacterProcessing][CharacterProcessing]] and [[https://www.emacswiki.org/emacs/StringModification][StringModification]]. See [[https://www.emacswiki.org/emacs/tr][tr]] for an example mixing strings and characters.

    Looking at characters in a temporary buffer:

    #+BEGIN_EXAMPLE
            ( with-temp-buffer
              (insert  "abcdefg")
              (goto-char (point-min))
              ( while (not (= (char-after) ?b)) (forward-char))
              (point))
            ==> 2
    #+END_EXAMPLE

*** Trim whitespace
    Since 24.4, you can use =‘string-trim’=, =‘string-trim-left’=, and =‘string-trim-right’= from =‘subr-x’=.

    Otherwise, trim whitespace from the end of a string:

    #+BEGIN_EXAMPLE
            (setq test-str  "abcdefg  ")
            ( when (string-match  "[  \t]*$" test-str)
              (message (concat  "[" (replace-match  "" nil nil test-str)  "]")))
    #+END_EXAMPLE

    Trim whitespace from a string with a Perl-like chomp function:

    #+BEGIN_EXAMPLE
            ( defun  chomp (str)
               "Chomp leading and tailing whitespace from STR."
              ( while (string-match  " \\` \n+ \\|^ \\s-+ \\| \\s-+$ \\| \n+ \\'"
                                   str)
                (setq str (replace-match  "" t t str)))
              str)
    #+END_EXAMPLE

    Let's not overcomplicate matters:

    #+BEGIN_EXAMPLE
            ( defun  chomp-end (str)
               "Chomp tailing whitespace from STR."
              (replace-regexp-in-string (rx (* (any  "  \t \n")) eos)
                                         ""
                                        str))
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
            ( defun  chomp (str)
               "Chomp leading and tailing whitespace from STR."
              (replace-regexp-in-string (rx (or (: bos (* (any  "  \t \n")))
                                                (: (* (any  "  \t \n")) eos)))
                                         ""
                                        str))
    #+END_EXAMPLE

*** Splitting strings


    See [[https://www.emacswiki.org/emacs/SplitString][SplitString]].

*** Joining strings


    Use =‘mapconcat’= to join strings, interpolating a separator string and possibly transforming each string before joining.

    For no transformation ( =‘identity’=), use this:

    #+BEGIN_EXAMPLE
          (mapconcat 'identity '( ""  "home"  "alex "  "elisp"  "erc")  "/")
            ==>  "/home/alex /elisp/erc"
    #+END_EXAMPLE

    If you have an Emacs version greater than 25.3 then you can alternatively use =‘string-join’= for that simple case:

    #+BEGIN_EXAMPLE
          (string-join '( "foo"  "bar"  "baz")  ", ")
            ==>  "foo, bar, baz"
    #+END_EXAMPLE

    ( =‘string-join’= is just =‘mapconcat’= with =‘identity’= for the transformation.)

    For the even simpler case where you have no separator (it is =""=, you can just use =‘concat’= or =‘format’=:

    #+BEGIN_EXAMPLE
          (concat  "hello, "  "world")
            ==>  "hello, world"
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
          (format  "%s%s"  "hello, "  "world")
            ==>  "hello, world"
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
          (format  "%s, %s"  "hello"  "world")
            ==>  "hello, world"
    #+END_EXAMPLE

*** Serialization


    Convert forms to strings using =‘prin1-to-string’=, then convert back from a string using =‘read’=.

    #+BEGIN_EXAMPLE
          (length (read (prin1-to-string (make-list 1000000 '(x)))))
            ==> 1000000
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
          (read (prin1-to-string  "Hello World!"))
            ==>  "Hello World!"
    #+END_EXAMPLE

    This works only in the simplest cases. Unfortunately, it doesn't work for all [[https://www.emacswiki.org/emacs/EmacsLisp][EmacsLisp]] data types.

    #+BEGIN_EXAMPLE
          (read (prin1-to-string (make-hash-table)))  ;; Error before Emacs 23.
            ==> #s(hash-table size 65 test eql rehash-size 1.5 [...] data ())
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
          (read (prin1-to-string (current-buffer)))
            ==> Lisp error: (invalid-read-syntax  "#")
    #+END_EXAMPLE

*** Formatting

** Killing text
   As the [[https://www.emacswiki.org/emacs/ElispManual][ElispManual]] says, “Most of the kill commands are primarily for interactive use [...] When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents.”

   The following mimic the =‘kill-’= commands but without disturbing the [[https://www.emacswiki.org/emacs/kill_ring][kill ring]]. To make them kill, use =‘kill-region’= instead of =‘delete-region’=.

*** Delete region
    The Lisp equivalent of =‘kill-region’= ( =‘C-w’=) but without kill-ring side effects::

    #+BEGIN_EXAMPLE
          (delete-region (region-beginning) (region-end))
    #+END_EXAMPLE

    According to the [[https://www.emacswiki.org/emacs/ElispManual][ElispManual]], “Few programs need to use the =‘region-beginning’= and =‘region-end’= functions.” This is because Lisp code should not rely on nor “alter the mark unless altering the mark is part of the user-level functionality of the command. (And, in that case, this effect should be documented.) To remember a location for internal use in the Lisp program, store it in a Lisp variable. For example: [...]”

*** Delete line
    The equivalent of =‘kill-line’= ( =‘C-k’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg (point)))
           (forward-line 1)
           (forward-char -1)
           (delete-region beg (point)))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region (point) (line-end-position))
    #+END_EXAMPLE

    Or just: =(delete-region (point) (line-end-position))=

    The examples with =‘forward-line’= are shown for comparison with other examples, below.

*** Delete line backwards


    The equivalent of killing the line backwards ( =‘C-0 C-k’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg (point)))
           (forward-line 0)
           (delete-region (point) beg))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region ( progn (forward-line 0) (point))
                         (point))
    #+END_EXAMPLE

    Or just: =(delete-region (line-beginning-position) (point))=

*** Delete line to next line
    The equivalent of killing the line and the newline ( =‘C-1 C-k’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg (point)))
           (forward-line 1)
           (delete-region beg (point)))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region (point) ( progn (forward-line 1) (point)))
    #+END_EXAMPLE

*** Delete whole line
    The equivalent of =‘kill-whole-line’= ( =‘C-S-DEL’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg ( progn (forward-line 0)
                           (point))))
           (forward-line 1)
           (delete-region beg (point)))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region ( progn (forward-line 0) (point))
                         ( progn (forward-line 1) (point)))
    #+END_EXAMPLE

    Or just:

    #+BEGIN_EXAMPLE
          (delete-region (line-beginning-position)
                         (line-end-position))
    #+END_EXAMPLE

*** Delete word
    The equivalent of =‘kill-word’= ( =‘M-d’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg (point)))
           (forward-word 1)
           (delete-region beg (point)))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region (point) ( progn (forward-word 1) (point)))
    #+END_EXAMPLE

*** Delete sentence


    The equivalent of =‘kill-sentence’= ( =‘M-k’=) but without kill-ring side effects:

    #+BEGIN_EXAMPLE
         ( let ((beg (point)))
           (forward-sentence 1)
           (delete-region beg (point)))
    #+END_EXAMPLE

    Alternatively, replacing the =‘let’= with =‘progn’=.

    #+BEGIN_EXAMPLE
          (delete-region (point) ( save-excursion
                                   (forward-sentence 1)
                                   (point)))
    #+END_EXAMPLE

** Numbers
*** Test whether a string represents a number


#+BEGIN_EXAMPLE
     ( defun  string-integer-p (string)
       ( if (string-match  " \\`[-+]?[0-9]+ \\'" string)
           t
         nil))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-integer-p  "1234")
       ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-integer-p  "x1234")
       ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-integer-p  "3.141592653589793")
       ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     ( defun  string-float-p (string)
       ( if (string-match  " \\`[-+]?[0-9]+ \\.[0-9]* \\'" string)
           t
         nil))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-float-p  "1234")
       ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-float-p  "3.141592653589793")
       ==> t
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-float-p  ".1")
       ==> nil
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     (string-float-p  "1.")
       ==> t
#+END_EXAMPLE

*** String to number


The following example is for instruction. Normally standard function =‘string-to-number’= would be used.

#+BEGIN_EXAMPLE
      ( defun  decimal-number (string)
        ( let ((n (string-to-number string)))
          ( save-match-data
            ( if (and (not (zerop n))
                     (string-match  " \\` \\s-*0+ \\.?0* \\s-* \\'" string))
                n
              nil))))
      
      (decimal-number  "536870911")
      ==> 536870911
      
      (decimal-number  "536870912")
      ==> 536870912.0
      
      (decimal-number  "3.141592653589793")
      ==> 3.141592653589793
      
      (decimal-number  "042")
      ==> 42
      
      (decimal-number  " 0 ")
      ==> 0
      
      (decimal-number  "000")
      ==> 0
      
      (decimal-number  "0.0")
      ==> 0.0
#+END_EXAMPLE

*** Random numbers


#+BEGIN_EXAMPLE
      (random 2)   ;coin toss (0 or 1)
      (+ (random 6) 1)   ;dice
#+END_EXAMPLE

*** Put commas in numbers


#+BEGIN_EXAMPLE
      ( defun  group-number (num  &optional size char)
         "Format NUM as string grouped to SIZE with CHAR."
         ;; Based on code for ` math-group-float' in calc-ext.el
        ( let* ((size (or size 3))
               (char (or char  ","))
               (str ( if (stringp num)
                        num
                      (number-to-string num)))
                 ;; omitting any trailing non-digit chars
                 ;; NOTE: Calc supports BASE up to 36 (26 letters and 10 digits ;)
               (pt (or (string-match  "[ ^0-9a-zA-Z]" str) (length str))))
          ( while (> pt size)
            (setq str (concat (substring str 0 (- pt size))
                              char
                              (substring str (- pt size)))
                  pt (- pt size)))
          str))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      (group-number 299792458)
      ==>  "299,792,458"
      (group-number  "149597870691" 4  " ")
      ==>  "1495 9787 0691"
#+END_EXAMPLE

*** Increment numbers


See [[https://www.emacswiki.org/emacs/IncrementNumber][IncrementNumber]].

*** Dates and times


**** Today's date


#+BEGIN_EXAMPLE
      ( defun  today-is ()
         "Display current time."
        (interactive)
        (message (format-time-string  "Today is %Y-%m-%d %T")))
#+END_EXAMPLE

See [[https://www.emacswiki.org/emacs/InsertingTodaysDate][InsertingTodaysDate]].

**** Formatting dates


Use the function =‘format-time-string’= which is a build in function in both Emacsen and works like =‘strftime’=:

#+BEGIN_EXAMPLE
         ;; Year-Month-Day:
        (insert (format-time-string  "%Y-%m-%d"))
         ;; Hour :Minutes :Seconds
        (insert (format-time-string  "%H:%M:%S"))
#+END_EXAMPLE

**** Conversions


Read a date from a string.

#+BEGIN_EXAMPLE
      ( let ((time (date-to-time  "Tue, 27-Sep-83 12:35:59 EST")))
        (set-time-zone-rule t)  ;; Use Universal time.
        ( prog1 (format-time-string  "%Y-%m-%d %T UTC" time)
          (set-time-zone-rule nil)))  ;; Reset to default time zone.
      ==>  "1983-09-27 17:35:59 UTC"
#+END_EXAMPLE

Decode a time object.

#+BEGIN_EXAMPLE
      (decode-time (date-to-time  "Tue, 27-Sep-83 12:35:59 EST"))
      ==> (59 35 13 27 9 1983 2 t -14400)
#+END_EXAMPLE

Get the seconds from the unix epoch.

#+BEGIN_EXAMPLE
      ( let ((time (date-to-time  "13 Feb 2009 23:31:30 UTC")))
        (float-time time))
      ==> 1234585890.0
#+END_EXAMPLE

Find the date for seconds from the unix epoch.

#+BEGIN_EXAMPLE
      (format-time-string  "%Y-%m-%d %T UTC" (seconds-to-time 1234585890))
      ==>  "2009-02-13 23:31:30 UTC"
#+END_EXAMPLE

Find the date 30 seconds in the future.

#+BEGIN_EXAMPLE
      (format-time-string  "%Y-%m-%d %T UTC" (time-add (current-time)
                                                      (seconds-to-time 30)))
      ==>  "2012-02-13 10:07:11 UTC"
#+END_EXAMPLE

Formatting elapsed time in years, days, hours, minutes and seconds.

#+BEGIN_EXAMPLE
      (format-seconds  "%Y %D %h:%m:%s" (1- (* 367 24 3600)))
      ==>  "1 year 1 day 23:59:59"
#+END_EXAMPLE

Find the days between two dates.

#+BEGIN_EXAMPLE
      ( let ((days1 (time-to-days (date-to-time  "Tue, 27-Sep-83 12:35:59 EST")))
            (days2 (time-to-days (date-to-time  "2009-02-13 23:31:30 UTC"))))
        (- days2 days1))
      ==> 9271
#+END_EXAMPLE

Getting the day in the year.

#+BEGIN_EXAMPLE
      (time-to-day-in-year (current-time))
      ==> 44
#+END_EXAMPLE

Build a date based on the day of the year.

#+BEGIN_EXAMPLE
      (format-time-string  "%j"
                          (encode-time 0 0 0 44 1 2012))
      ==>  "044"
#+END_EXAMPLE

** Pattern matching
“Patterns” refers to [[https://www.emacswiki.org/emacs/RegularExpression][RegularExpression]]s.

There's a set of functions that work in strings, and a set that work in buffers.

*** Finding


#+BEGIN_EXAMPLE
        (string-match  "foo*"  "Fight foo for food!")
        ==> 6
#+END_EXAMPLE

Using a temporary buffer instead:

#+BEGIN_EXAMPLE
        ( with-temp-buffer
          (insert  "Fight foo for food!")
          (goto-char (point-min))
          (re-search-forward  "foo*")
          (point))
        ==> 10
#+END_EXAMPLE

Alternative without regular expressions: =‘search-forward’=.

The functions working on buffers move [[https://www.emacswiki.org/emacs/point][point]] to the end of the occurrence found and return it. That's why the result is 10 instead of 6.

*** Verifying


Sometimes you just want to check whether you're at the right place:

#+BEGIN_EXAMPLE
        ( with-temp-buffer
          (insert  "Fight foo for food!")
          (goto-char (point-min))
          (looking-at  "fight"))
        ==> t
#+END_EXAMPLE

*** Search and replace


#+BEGIN_EXAMPLE
        (replace-regexp-in-string  "foo*"  "fu"  "Fight foo for food!")
        ==>  "Fight fu fur fud!"
#+END_EXAMPLE

Using a temporary buffer instead:

#+BEGIN_EXAMPLE
        ( with-temp-buffer
           (insert  "Fight foo for food!")
           (goto-char (point-min))
           ( while (re-search-forward  "foo*" nil t)
             (replace-match  "fu"))
           (buffer-string))
        ==>  "Fight fu fur fud!"
#+END_EXAMPLE

Alternative without regular expressions: =‘search-forward’=.

See also [[https://www.emacswiki.org/emacs/StringSearchAndReplace][StringSearchAndReplace]].

*** Search and do something with match


This finds numbers and increments them by one. It depends on =‘decimal-number’= that was defined above. See also [[https://www.emacswiki.org/emacs/IncrementNumber][IncrementNumber]].

#+BEGIN_EXAMPLE
      ( while (re-search-forward  "[0-9]" nil t)
        (goto-char (match-beginning 0))
        ( when (and (looking-at  "[-+]?[0-9]+ \\.?[0-9]*")
                   (decimal-number (match-string 0)))
          (replace-match
           (number-to-string (1+ (string-to-number (match-string 0)))))
          (goto-char (match-end 0))))
#+END_EXAMPLE

This loads [[https://www.emacswiki.org/emacs/EmacsLisp][EmacsLisp]] files listed one per line in a text file.

#+BEGIN_EXAMPLE
      ( with-current-buffer (find-file-noselect  "~/load-files.txt")
        ( while (re-search-forward  "^.* \\.el \\( \\.gz \\)?$" nil t)
          ( let ((filename (match-string 0)))
            ( when (file-exists-p filename)
              (load-file filename)))))
#+END_EXAMPLE

*** Extracting submatches from a regex match


Like in most other regex implementations, if you use grouping parentheses in a regular expression, you can extract the text that matched each parenthesized group. Groups are numbered from the opening parenthesis, left to right. These are also called back references, or backrefs, or matching groups.

#+BEGIN_EXAMPLE
        ( save-match-data  ; is usually a good idea
          (and (string-match  " \\` \\([ ^@]+ \\)@ \\([ ^@]+ \\) \\'" email)
               (setq user (match-string 1 email)
                     domain (match-string 2 email) ) ))
#+END_EXAMPLE

Usually you would use =*let*= instead of =*setq*= but this is just a simple self-contained example. See also [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][DynamicBindingVsLexicalBinding]].

*** Mapping with a regex


This invokes a function at every match of a [[https://www.emacswiki.org/emacs/regexp][regexp]]:

#+BEGIN_EXAMPLE
       ( defun  map-regex (buffer regex fn)
          "Map the REGEX over the BUFFER executing FN.

       FN is called with the match-data of the regex.

       Returns the results of the FN as a list."
         ( with-current-buffer buffer
           ( save-excursion
             (goto-char (point-min))
             ( let (res)
               ( save-match-data
                 ( while (re-search-forward regex nil t)
                   ( let ((f (match-data)))
                     (setq res
                           (append res
                                   (list
                                    ( save-match-data
                                      (funcall fn f))))))))
               res))))
#+END_EXAMPLE

An example use might be:

#+BEGIN_EXAMPLE
        (map-regex
         (find-file-noselect  "~/work/elnode-auth/build-parts.txt")
          "^ \\(.*.el \\( \\.gz \\)* \\)$"
         ( lambda (md)
           ( let ((filename (match-string 0)))
             ( when (file-exists-p filename)
               (load-file filename))))))
#+END_EXAMPLE

*** Finding all the strings that match


If you want to list all the matching strings, including subexpressions:

#+BEGIN_EXAMPLE
      ( defun  match-strings-all ( &optional string)
         "Return the list of all expressions matched in last search.
      
      STRING is optionally what was given to ` string-match'."
        ( let ((n-matches (1- (/ (length (match-data)) 2))))
          (mapcar ( lambda (i) (match-string i string))
                  (number-sequence 0 n-matches))))
#+END_EXAMPLE

Here's an example:

#+BEGIN_EXAMPLE
        ( let ((str  "time help"))
          (string-match  "time  \\([A-Za-z]+ \\)$" str)
          (match-strings-all str))
        ==> ( "time help"  "help")
#+END_EXAMPLE

Another variant which does something similar, but without subexpressions:

#+BEGIN_EXAMPLE
        ( defun  regexp-list (regex string)
           "Return a list of all REGEXP matches in STRING."
           ;; source: http://emacs.stackexchange.com/questions/7148/get-all-regexp-matches-in-buffer-as-a-list
          ( let ((pos 0)         ; string marker
                (matches ()))   ; return list
            ( while (string-match regex string pos)
              (push (match-string 0 string) matches)
              (setq pos (match-end 0)))
            (setq matches (reverse matches))
            matches))
#+END_EXAMPLE

And an example which locates HTML tags in the title of a publication:

#+BEGIN_EXAMPLE
        (regexp-list  "<[[ :alnum:][ :blank:]/= \"-]*?>"  "An article title concerning CO2 emissions.")
        ==> ( ""  "")
#+END_EXAMPLE

** Code Comments
Move to the beginning of the current comment:

#+BEGIN_EXAMPLE
        ( require ' newcomment)
        (comment-beginning)
#+END_EXAMPLE

Move to the text after a comment:

#+BEGIN_EXAMPLE
        (comment-search-forward (line-end-position) t)
#+END_EXAMPLE

See also [[https://www.emacswiki.org/emacs/EndOfLineNoComments][EndOfLineNoComments]].

** Sequences
Datatypes used to represent sequences of things:

#+BEGIN_EXAMPLE
         _____________________________________________
        |                                             |
        |          Sequence                           |
        |  ______   ________________________________  |
        | |      | |                                | |
        | | List | |             Array              | |
        | |      | |    ________       ________     | |
        | |______| |   |        |     |        |    | |
        |          |   | Vector |     | String |    | |
        |          |   |________|     |________|    | |
        |          |  ____________   _____________  | |
        |          | |            | |             | | |
        |          | | Char-table | | Bool-vector | | |
        |          | |____________| |_____________| | |
        |          |________________________________| |
        |_____________________________________________|
#+END_EXAMPLE

*** Lists
List basics are explained at [[https://www.emacswiki.org/emacs/ListStructure][ListStructure]]. Lists can shrink and grow, but access to elements towards the end of the list is slow if the list is long.

Use =‘cons’=, =‘push’=, or =‘add-to-list’= to prepend a new element to a list. Use =‘nth’= to access an element of a list.

#+BEGIN_EXAMPLE
        ( let ((words '( "fight"  "foo"  "for"  "food!")))
          ( when (string=  "foo" (nth 1 words))
            (setq words (cons  "bar" words)))
          words)
        ==> ( "bar"  "fight"  "foo"  "for"  "food!")
#+END_EXAMPLE

See [[https://www.emacswiki.org/emacs/ListModification][ListModification]] for more ways of changing a list.

Iteration:

#+BEGIN_EXAMPLE
        ( let ((result  ()))
          ( dolist (word  '( "fight"  "foo"  "for"  "food!"))
            ( when (string-match  "o" word) (push word result)))
          (nreverse result))
        ==> ( "foo"  "for"  "food!")
#+END_EXAMPLE

Note how =‘push’= adds an element to the front of the list, so that usually the list has to be reversed after the loop. =‘nreverse’= is particularly efficient because it does this destructively. See [[https://www.emacswiki.org/emacs/DestructiveOperations][DestructiveOperations]] for more about this.

Copying:

Use =‘copy-sequence’= to make a shallow copy of a list without changing the original.

#+BEGIN_EXAMPLE
        ( let* ((orig '((1 2) (3 4)))
               (copy (copy-sequence orig)))
          (setcdr copy '((5 6)))
          (list orig copy))
        ==> (((1 2) (3 4)) ((1 2) (5 6)))
#+END_EXAMPLE

The elements in the copy remain in the original. More importantly, they are in fact the same elements (i.e., =‘eq’=), not copies. The list is copied, but its elements are shared with the original list.

#+BEGIN_EXAMPLE
        ( let* ((orig '((1 2) (3 4)))
               (copy (copy-sequence orig)))
          (setcdr (cadr copy) '(0))
          (list orig copy))
        ==> (((1 2) (3 0)) ((1 2) (3 0)))
#+END_EXAMPLE

=‘copy-tree’= is the recursive version of =‘copy-sequence’=.

#+BEGIN_EXAMPLE
        ( let* ((orig '((1 2) (3 4)))
               (copy (copy-tree orig)))
          (setcdr (cadr copy) '(0))
          (list orig copy))
        ==> (((1 2) (3 4)) ((1 2) (3 0)))
#+END_EXAMPLE

Filtering:

A =‘filter’= macro has been added to the Emacs development tree. It does what you expect: filters a list, returning a copy that keeps elements that satisfy a predicate and omitting elements that do not satisfy it.

If your Emacs does not yet have this built in, you can use =‘dolist’= or =‘mapcar’= to iterate over a list with a conditional, and then use =‘delq’= to remove the =‘nil’= values.

#+BEGIN_EXAMPLE
      ( defun  my-filter (condp lst)
        (delq nil
              (mapcar ( lambda (x) (and (funcall condp x) x)) lst)))
#+END_EXAMPLE

Therefore,

#+BEGIN_EXAMPLE
      (my-filter 'identity my-list)
#+END_EXAMPLE

is equivalent to

#+BEGIN_EXAMPLE
      (delq nil my-list)
#+END_EXAMPLE

For example:

#+BEGIN_EXAMPLE
      ( let ((num-list '(1 'a 2  "nil" 3 nil 4)))
        (my-filter 'numberp num-list))
      ==> (1 2 3 4)
#+END_EXAMPLE

Package =‘cl-seq’= has functions =‘remove-if’= and =‘remove-if-not’=. The latter can be used instead of =‘my-filter’=.

#+BEGIN_EXAMPLE
      ( let ((num-list '(1 'a 2  "nil" 3 nil 4)))
        (remove-if-not 'numberp num-list))
      ==> (1 2 3 4)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      ( let ((num-list '(1 'a 2  "nil" 3 nil 4)))
        (remove-if 'numberp num-list))
      ==> ((quote a)  "nil" nil)
#+END_EXAMPLE

Here is a version of quicksort:

#+BEGIN_EXAMPLE
      ( defun  quicksort (lst)
         "Implement the quicksort algorithm."
        ( if (null lst) nil
          ( let* ((spl (car lst))
                 (rst (cdr lst))
                 (smalp ( lambda (x)
                       (< x spl))))
            (append (quicksort (remove-if-not smalp rst))
                    (list spl)
                    (quicksort (remove-if smalp rst))))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      (quicksort '(5 7 1 3 -9 8 7 -4 0))
      ==> (-9 -4 0 1 3 5 7 7 8)
#+END_EXAMPLE

The following function was written by [[https://www.emacswiki.org/emacs/tali713][tali713]] in response to [[https://www.emacswiki.org/emacs/hypnocat][hypnocat]]'s question regarding a filter function in [[http://www.emacswiki.org/emacs/EmacsChannel][#emacs]]:

#+BEGIN_EXAMPLE
        ( defun  keep-when (pred seq)
          ( let ((del (make-symbol  "del")))
            (remove del (mapcar ( lambda (el)
                      ( if (funcall pred el) el del)) seq))))
#+END_EXAMPLE

Use:

#+BEGIN_EXAMPLE
      (keep-when 'atom '(1 2 3 (4 5) 6 nil t foo))
      ==> (1 2 3 6 nil t foo)
#+END_EXAMPLE

Updated 31/05/2013.

Tranposing:

Create a list from multiple lists:

#+BEGIN_EXAMPLE
     (( lambda ( &rest args)
        (mapcar ( lambda (n)
                  (delq nil (mapcar ( lambda (arg) (nth n arg)) args)))
                (number-sequence 0 (1- (apply 'max (mapcar 'length args))))))
      '(1 2 3) '(a b c) '(A B C))
      ==> ((1 a A) (2 b B) (3 c C))
#+END_EXAMPLE

A more concise version is possible with the the higher-arity version of =‘mapcar’= available from library =‘cl’=.

#+BEGIN_EXAMPLE
      (( lambda ( &rest args)
         (apply (function mapcar*) (function list) args))
       '(1 2 3) '(a b c) '(A B C))
      ==> ((1 a A) (2 b B) (3 c C))
#+END_EXAMPLE

Searching:

You can check for presence of a value in a list using =‘member’= or =‘memq’=.

#+BEGIN_EXAMPLE
      ( let ((words  '( "fight"  "foo"  "for"  "food!")))
        (car (member  "for" words)))
      ==>  "for"
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      ( let ((re     " \\wo \\b")
            (words '( "fight"  "foo"  "for"  "food!")))
        (consp (memq t
                 (mapcar ( lambda (s) (numberp (string-match re s))) words))))
      ==> t
#+END_EXAMPLE

In the latter, a more efficient algorithm would use a loop (a non-local exit).

*** Association lists


The [[https://www.emacswiki.org/emacs/ElispManual][ElispManual]] has examples of finding and deleting values in an [[https://www.emacswiki.org/emacs/alist][association list]], or alist. Here are cases when the car values are strings.

#+BEGIN_EXAMPLE
      (assoc  "2" '(( "2" . 2) ( "1" . 1) ( "2") ( "3" . 3)))
      ==> ( "2" . 2)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      (mapcar ( lambda (c) (cons c (string c))) (number-sequence 56 65))
      ==> ((56 .  "8") (57 .  "9") (58 .  ":") (59 .  " ;") (60 .  "<")
           (61 .  "=") (62 .  ">") (63 .  "?") (64 .  "@") (65 .  "A"))
      (assq 64
            (mapcar ( lambda (c) (cons c (string c))) (number-sequence 56 65)))
      ==> (64 .  "@")
      (assq 55
            (mapcar ( lambda (c) (cons c (string c))) (number-sequence 56 65)))
      ==> nil
#+END_EXAMPLE

Deleting:

#+BEGIN_EXAMPLE
      ( let ((alist '(( "a" . 1) ( "b" . 2))))
        (delq (assoc  "a" alist) alist))
      ==> (( "b" . 2))
#+END_EXAMPLE

Matches with a test function other than =‘equal’=:

#+BEGIN_EXAMPLE
      ( let ((alist '(( "ab" . 1) ( "bc" . 2) ( "cd" . 3))))
        (assoc-default  "c" alist ( lambda (x y) (string-match y x))))
      ==> 2
#+END_EXAMPLE

The alist functions are useful for finding the first instance of a value in any list, not just association lists, and even when there are duplicates.

The following uses =‘mapcar’= to associate the =‘major-mode’= to each buffer returned by =‘buffer-list’=, then =‘assq’= to find the first buffer where the major mode is =‘fundamental-mode’=.

#+BEGIN_EXAMPLE
      (assq 'fundamental-mode
            (mapcar
             ( lambda (b)
               (cons (buffer-local-value 'major-mode b) b))
             (buffer-list)))
      ==> (fundamental-mode . #)
#+END_EXAMPLE

You can also find values in regular lists, by converting them to association lists with a null cdr.

Here's an association list of random numbers with no associated value.

#+BEGIN_EXAMPLE
      '((8 . nil) (3 . nil) (1 . nil) (7 . nil) (3 . nil) (6 . nil) (9 . nil))
      ==> ((8) (3) (1) (7) (3) (6) (9))
#+END_EXAMPLE

This is really just making a list for each number -- a “list of lists” -- which can be done with =‘mapcar’= and =‘list’=.

#+BEGIN_EXAMPLE
      (mapcar 'list '(8 3 1 7 3 6 9))
      ==> ((8) (3) (1) (7) (3) (6) (9))
      (assq 3 (mapcar 'list '(8 3 1 7 3 6 9)))
      ==> (3)
#+END_EXAMPLE

To group elements by a function:

#+BEGIN_EXAMPLE
      ( defun  group-by-eq (f lst)
         "Build `assq`-list based on result of F on Xs in LST."
        ( let ((alist))
          ( dolist (x lst)
            ( let* ((key (funcall f x))       ;; This should give an `eq`-able value.
                   (vals (assq key alist)))  ;; Look for it in the association list.
              ( if (null vals)
                  (setq alist (cons (list key x) alist))
                (setcdr vals (cons x (cdr vals))))))
          (nreverse alist)))
#+END_EXAMPLE

To group cons-cells by their car:

#+BEGIN_EXAMPLE
        (group-by-eq 'car '((a 0) (b 0) (b 1)))
        ==> ((a (a 0)) (b (b 1) (b 0)))
#+END_EXAMPLE

To group a list of integers by their negativity:

#+BEGIN_EXAMPLE
        (group-by-eq ( lambda (x) (< x 0)) '(0 -1 2 -3 4 -5))
        ==> ((t -5 -3 -1) (nil 4 2 0))
#+END_EXAMPLE

*** Vectors


Vectors are fixed in size, and their elements can be accessed in constant time (neither of which is the case for lists).

#+BEGIN_EXAMPLE
        ( let ((words [ "fight"  "foo"  "for"  "food!"]))
          ( when (string=  "foo" (aref words 1))
            (aset words 1  "bar"))
          words)
        ==> [ "fight"  "bar"  "for"  "food!"]
#+END_EXAMPLE

**** Convert vector to list


All vectors are sequences and the map functions work on sequences, so:

#+BEGIN_EXAMPLE
    (mapcar 'identity [1 2 3 4]) 
      ==> (1 2 3 4)
#+END_EXAMPLE

Here is another Lisp idiom for the same thing:

#+BEGIN_EXAMPLE
    (append [1 2 3 4] ())
      ==> (1 2 3 4)
#+END_EXAMPLE

** Hash tables


Hash tables map keys to values. They are similar to alists, but they are typically more efficient for a large number of keys.

See [[https://www.emacswiki.org/emacs/HashMap][HashMap]].

*** Storing and retrieving keys and values


By default, hash tables use =‘eql’= to compare keys. This is not appropriate for strings: =(eql "alex" "alex")= ⇒ nil. Use =‘equal’= in such cases:

#+BEGIN_EXAMPLE
        ( let ((nick-table (make-hash-table  :test 'equal)))
          (puthash  "kensanata"  "Alex Schroeder" nick-table)
          (gethash  "kensanata" nick-table))
        ==>  "Alex Schroeder"
#+END_EXAMPLE

Iterate:

#+BEGIN_EXAMPLE
        ( let ((nick-table (make-hash-table  :test 'equal))
              nicks)
          (puthash  "kensanata"  "Alex Schroeder" nick-table)
          (puthash  "e1f"  "Luis Fernandes" nick-table)
          (puthash  "pjb"  "Pascal J. Bourguignon" nick-table)
          (maphash ( lambda (nick real-name)
                     (setq nicks (cons nick nicks)))
                   nick-table)
          nicks)
          ==> ( "pjb"  "e1f"  "kensanata")
#+END_EXAMPLE

*** Sorting keys


Use =‘maphash’= to build up a list of keys, sort it, and then loop through the list:

#+BEGIN_EXAMPLE
        ( let ((nick-table (make-hash-table  :test 'equal))
              nicks)
          (puthash  "kensanata"  "Alex Schroeder" nick-table)
          (puthash  "e1f"  "Luis Fernandes" nick-table)
          (puthash  "pjb"  "Pascal J. Bourguignon" nick-table)
          (maphash ( lambda (nick real-name)
                     (setq nicks (cons nick nicks)))
                   nick-table)
          (mapcar ( lambda (nick)
                    (concat nick  " => " (gethash nick nick-table)))
                  (sort nicks 'string<)))
          ==> ( "e1f => Luis Fernandes"
                "kensanata => Alex Schroeder"
                "pjb => Pascal J. Bourguignon")
#+END_EXAMPLE

** Files
*** Read


A file can be inserted at point with =‘insert-file-contents’= or =‘insert-file-contents-literally’=. To get a file as a string,

#+BEGIN_EXAMPLE
      ( defun  file-string (file)
         "Read the contents of a file and return as a string."
        ( with-temp-buffer
          (insert-file-contents file)
          (buffer-string)))
#+END_EXAMPLE

On the chance that a buffer may already be actively visiting the file, consider using =‘find-file-noselect’=

#+BEGIN_EXAMPLE
      ( defun  file-string (file)
         "Read the contents of a file and return as a string."
        ( with-current-buffer (find-file-noselect file)
          (buffer-string)))
#+END_EXAMPLE

*** Filter


Processing a file is usually done with a temporary buffer:

#+BEGIN_EXAMPLE
     ( defun  process-file (file)
        "Read the contents of a file into a temp buffer and then do
     something there."
       ( when (file-readable-p file)
         ( with-temp-buffer
           (insert-file-contents file)
           (goto-char (point-min))
           ( while (not (eobp))
              ;; do something here with buffer content
             (forward-line)))))
#+END_EXAMPLE

*** Write


To write something to a file you can create a temporary buffer, insert the things to write there and write the buffer contents to a file. The following example read a string and a filename (with completion, but doesn't need to exist, see [[https://www.emacswiki.org/emacs/InteractiveCodeChar][InteractiveCodeChar]] F) and write the string to that file.

#+BEGIN_EXAMPLE
     ( defun  write-string-to-file (string file)
       (interactive  "sEnter the string:  \nFFile to save to: ")
       ( with-temp-buffer
         (insert string)
         ( when (file-writable-p file)
           (write-region (point-min)
                         (point-max)
                         file))))
#+END_EXAMPLE

Another way to do this is via with-temp-file:

#+BEGIN_EXAMPLE
     ( defun  write-string-to-file (string file)
       (interactive  "sEnter the string:  \nFFile to save to: ")
       ( with-temp-file file
         (insert string)))
#+END_EXAMPLE

*** Input and output (I/O)


This is a nice and simple way to edit a file with Emacs Lisp, especially when there's a chance the file might be already be visited in Emacs and its ok to edit the existing buffer.

#+BEGIN_EXAMPLE
      ( with-current-buffer (find-file-noselect  "~/logfile")
        (goto-char (point-max))
        (insert (format  "Hash of last line: %s"
                 (md5
                  ( save-excursion
                    (forward-line -1)
                    (buffer-substring-no-properties (point)
                                                    (line-end-position))))))
        (newline)
        ( with-temp-message  "Writing file..."
          (save-buffer))
        (message  "Writing file...done"))
#+END_EXAMPLE

*** Searching within a File


If you don't have grep, then you may need to write some Lisp which can find a match in a file.

#+BEGIN_EXAMPLE
       ;; Visit file unless its already open.
      ( with-current-buffer (find-file-noselect  "~/.emacs")
        ( save-excursion  ;; Don't change location of point.
          (goto-char (point-min))  ;; From the beginning...
          ( if (re-search-forward  ".*load-path.*" nil t 1)
              (match-string-no-properties 0)
            ( error  "Search failed"))))
      ==>  "(add-to-list 'load-path  \"/usr/share/emacs/site-lisp/ \")"
#+END_EXAMPLE

*** Locking


#+BEGIN_EXAMPLE
        ( unless (file-locked-p (buffer-file-name))
           (lock-buffer))
#+END_EXAMPLE

*** Stat


An interface to the kernel's stat(2) is provided by the function file-attributes.

#+BEGIN_EXAMPLE
        ( let* ((attrs (file-attributes (buffer-file-name)))
               (atime (nth 4 attrs))
               (mtime (nth 5 attrs))
               (ctime (nth 6 attrs)))
          (concat  "File last accessed on "
                  (format-time-string  "%Y-%m-%d %T" atime)  " \n"
                   "File last modified on "
                  (format-time-string  "%Y-%m-%d %T" mtime)  " \n"
                   "File last changed on "
                  (format-time-string  "%Y-%m-%d %T" ctime)  " \n"))
#+END_EXAMPLE

*** Deleting


#+BEGIN_EXAMPLE
      ( if (file-exists-p filename)
          (delete-file filename))
#+END_EXAMPLE

*** Copy, move and rename


#+BEGIN_EXAMPLE
      (copy-file file new-name)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      (rename-file file new-dir)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
      (rename-file file new-name)
#+END_EXAMPLE

*** Copy the buffer filename for yanking


#+BEGIN_EXAMPLE
    ( defun  copy-buffer-file-truename ( &optional as-host-os-path)
       "Copy the buffer-file-truename to the kill ring.
    Also, display it in the ` *Messages*' buffer.

    If AS-HOST-OS-PATH is nil, use the Emacs representation,
    otherwise use 'something suitable for the OS'."
      (interactive  "P")
      ( if (not buffer-file-truename)
          ( error  "%s"  "This buffer has no filename")
        (set 'path (expand-file-name buffer-file-truename))
        (kill-new ( if as-host-os-path (convert-standard-filename path) path))
        (message  "%s" (current-kill 0 t))))
#+END_EXAMPLE

** Directories


*** Listing


All files in a directory sorted by name:

#+BEGIN_EXAMPLE
      (directory-files  "~/")
      ==> ( "."  ".."  ".bash_history"  ".bashrc"  ".emacs"  ".emacs.d"  "diary"  "local"  "public_html")
#+END_EXAMPLE

File names matching a regular expression and in no particular order.

#+BEGIN_EXAMPLE
      (directory-files  "~/" (not 'absolute)  " \\` \\." 'nosort)
      ==> ( ".emacs.d"  ".emacs"  ".bash_history"  ".bashrc"  ".."  ".")
#+END_EXAMPLE

File names matching a wildcard expression sorted by name.

#+BEGIN_EXAMPLE
      ( let ((default-directory  "~/"))
        (file-expand-wildcards  "?emacs*"))
      ==> ( ".emacs"  ".emacs.d")
#+END_EXAMPLE

All files sorted by modification time:

#+BEGIN_EXAMPLE
      ( let ((default-directory  "~/"))
        (sort
          (directory-files default-directory (not 'absolute) nil 'nosort)
          ( lambda (a b)
            (time-less-p (nth 5 (file-attributes a))
                         (nth 5 (file-attributes b))))))
      ==> ( ".bashrc"  "diary"  "public_html"  "local"  ".bash_history"  ".."  ".emacs"  ".emacs.d"  ".")
#+END_EXAMPLE

*** Recursion


Here's an example of using =‘directory-files’= to find all subdirectories in a subdirectory.

Could potentially surpass =‘max-lisp-eval-depth’= if the filesystem has a suffienctly complex number of subdirectories.

#+BEGIN_EXAMPLE
      ( defun  directory-dirs (dir)
         "Find all directories in DIR."
        ( unless (file-directory-p dir)
          ( error  "Not a directory ` %s'" dir))
        ( let ((dir (directory-file-name dir))
              (dirs '())
              (files (directory-files dir nil nil t)))
            ( dolist (file files)
              ( unless (member file '( "."  ".."))
                ( let ((file (concat (file-name-as-directory dir) file)))
                  ( when (file-directory-p file)
                    (setq dirs (append (cons file
                                             (directory-dirs file))
                                       dirs))))))
            dirs))
#+END_EXAMPLE

Giving =‘directory-dirs’= an absolute file name:

#+BEGIN_EXAMPLE
      (directory-dirs  "/emacs/lisp")
      ==> ( "/usr/share/emacs/23.2/lisp/calc"  "/usr/share/emacs/23.2/lisp/calendar"
            "/usr/share/emacs/23.2/lisp/cedet"  "/usr/share/emacs/23.2/lisp/cedet/ede" ...)
#+END_EXAMPLE

Setting the =‘default-directory’= to a directory allows =‘directory-dirs’= to return relative file names for subdirectories.

#+BEGIN_EXAMPLE
      ( let ((default-directory  "/usr/share/emacs/23.2/lisp"))
        (directory-dirs  "."))
      ==> ( "./calc"  "./calendar"  "./cedet"  "./cedet/ede" ...)
#+END_EXAMPLE

*** Traversing


A file-tree-walk function has been added to the Emacs development tree. Until it lands in your version, you can use this:

#+BEGIN_EXAMPLE
        ( defun  walk-path (dir action)
            "walk DIR executing ACTION with (dir file)"
           ( cond ((file-directory-p dir)
                  (or (char-equal ?/ (aref dir(1- (length dir))))
                      (setq dir (file-name-as-directory dir)))
                  ( let ((lst (directory-files dir nil nil t))
                         fullname file)
                    ( while lst
                      (setq file (car lst))
                      (setq lst (cdr lst))
                      ( cond ((member file '( "."  "..")))
                            (t
                             (and (funcall action dir file)
                                  (setq fullname (concat dir file))
                                  (file-directory-p fullname)
                                  (walk-path fullname action)))))))
                 (t
                  (funcall action
                           (file-name-directory dir)
                           (file-name-nondirectory dir)))))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
        ( defun  walk-path-visitor (dir file)
            "Called by walk-path for each file found"
           (message (concat  dir file)))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
        (walk-path  "~/" 'walk-path-visitor)
#+END_EXAMPLE

*** Path splitting


Splitting the path can be done with =‘split-string’= and with the slash. Previously, Emacs would determine the character separating directory names with =‘directory-sep-char’=. However, the variable is obselete with Emacs 21.1.

#+BEGIN_EXAMPLE
      (split-string default-directory  "/")
      ==> ( ""  "usr"  "share"  "emacs"  "22.2"  "lisp"  "")
#+END_EXAMPLE

For splitting a path variable, Emacs already has the =‘parse-colon-path’= function.

#+BEGIN_EXAMPLE
      (parse-colon-path (getenv  "PATH"))
      ==> ( "/usr/lib/qt-3.3/bin/"  "/usr/kerberos/bin/"  "/usr/local/bin/"  "/usr/bin/"  "/bin/"  "/usr/local/sbin/"  "/usr/sbin/"  "/sbin/")
#+END_EXAMPLE

** Processes


*** Running a program


Run a command without caring about its output.

#+BEGIN_EXAMPLE
      (async-shell-command  "emacs")
#+END_EXAMPLE

Run a command and put its output in the current buffer.

#+BEGIN_EXAMPLE
      (shell-command  "seq 8 12 | sort" t)
      10
      11
      12
      8
      9
#+END_EXAMPLE

Run a command and put its output in a new buffer.

#+BEGIN_EXAMPLE
      (shell-command  "seq 8 12 | sort"
                     (get-buffer-create  "*Standard output*"))
#+END_EXAMPLE

Run a command return its output as a string.

#+BEGIN_EXAMPLE
      (shell-command-to-string  "seq 8 12 | sort")
#+END_EXAMPLE

Run a command return and insert its output at point in the current buffer.

#+BEGIN_EXAMPLE
      (insert (shell-command-to-string  "date"))
#+END_EXAMPLE

*** Handling signals

** Sockets


*** Tcp client


*** Tcp server


Perhaps [[https://www.emacswiki.org/emacs/EmacsEchoServer][EmacsEchoServer]] and [[https://www.emacswiki.org/emacs/EmacsDaytimeServer][EmacsDaytimeServer]] can be useful here. Also [[https://github.com/stsquad/emacs_chrome/blob/master/servers/edit-server.el][Edit with Emacs' edit-server.el]] which is a more complete server implementation.

** Keys
*** Call function bound to key
#+BEGIN_EXAMPLE
      (funcall (key-binding (kbd  "M-TAB")))
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
      (call-interactively (key-binding (kbd  "M-TAB")))
#+END_EXAMPLE

*** Documenting key binding to lambda
See [[https://www.emacswiki.org/emacs/DocumentingKeyBindingToLambda][DocumentingKeyBindingToLambda]]

** Test code
Sometimes you might want to insert some demonstration code in a module. The code should not be run when the module is loaded via =‘require’= or =‘load’= but when you =‘eval-current-buffer’=. All you need to do add is add a test condition of =‘eval-buffer-list’=:

#+BEGIN_EXAMPLE
      (dont-compile
        ( when (eq (car eval-buffer-list) (current-buffer))
          ...))
#+END_EXAMPLE

