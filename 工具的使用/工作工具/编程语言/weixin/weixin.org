* 小程序
** 框架
*** 逻辑层 App Service
**** 注册小程序
   #+BEGIN_EXAMPLE
       // app.js
       App({
         onLaunch (options) {
           // Do something initial when launch.
         },
         onShow (options) {
           // Do something when show.
         },
         onHide () {
           // Do something when hide.
         },
         onError (msg) {
           console.log(msg)
         },
         globalData: 'I am global data'
       })
   #+END_EXAMPLE

**** 注册页面
***** 使用 Page
   #+BEGIN_EXAMPLE
       //index.js
       Page({
         data: {
           text: "This is page data."
         },
         onLoad: function(options) {
           // 页面创建时执行
         },
         onShow: function() {
           // 页面出现在前台时执行
         },
         onReady: function() {
           // 页面首次渲染完毕时执行
         },
         onHide: function() {
           // 页面从前台变为后台时执行
         },
         onUnload: function() {
           // 页面销毁时执行
         },
         onPullDownRefresh: function() {
           // 触发下拉刷新时执行
         },
         onReachBottom: function() {
           // 页面触底时执行
         },
         onShareAppMessage: function () {
           // 页面被用户分享时执行
         },
         onPageScroll: function() {
           // 页面滚动时执行
         },
         onResize: function() {
           // 页面尺寸变化时执行
         },
         onTabItemTap(item) {
           // tab 点击时执行
           console.log(item.index)
           console.log(item.pagePath)
           console.log(item.text)
         },
         // 事件响应函数
         viewTap: function() {
           this.setData({
             text: 'Set some data for updating view.'
           }, function() {
             // this is setData callback
           })
         },
         // 自由数据
         customData: {
           hi: 'MINA'
         }
       })
   #+END_EXAMPLE
***** 在页面中使用 behaviors
   #+BEGIN_EXAMPLE
       // my-behavior.js
       module.exports = Behavior({
         data: {
           sharedText: 'This is a piece of data shared between pages.'
         },
         methods: {
           sharedMethod: function() {
             this.data.sharedText === 'This is a piece of data shared between pages.'
           }
         }
       })
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
       // page-a.js
       var myBehavior = require('./my-behavior.js')
       Page({
         behaviors: [myBehavior],
         onLoad: function() {
           this.data.sharedText === 'This is a piece of data shared between pages.'
         }
       })
   #+END_EXAMPLE

***** 使用 Component
   #+BEGIN_EXAMPLE
       Component({
         data: {
           text: "This is page data."
         },
         methods: {
           onLoad: function(options) {
             // 页面创建时执行
           },
           onPullDownRefresh: function() {
             // 下拉刷新时执行
           },
           // 事件响应函数
           viewTap: function() {
             // ...
           }
         }
       })
   #+END_EXAMPLE

**** 页面路由
***** 页面栈
  框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下：

  | 路由方式     | 页面栈表现                          |
  |--------------+-------------------------------------|
  | 初始化       | 新页面入栈                          |
  | 打开新页面   | 新页面入栈                          |
  | 页面重定向   | 当前页面出栈，新页面入栈            |
  | 页面返回     | 页面不断出栈，直到目标返回页        |
  | Tab 切换     | 页面全部出栈，只留下新的 Tab 页面   |
  | 重加载       | 页面全部出栈，只留下新的页面        |

  开发者可以使用 =getCurrentPages()= 函数获取当前页面栈。

***** 路由方式
  对于路由的触发方式以及页面生命周期函数如下：

  | 路由方式   | 触发时机                                         | 路由前页面 | 路由后页面         |
  |------------+--------------------------------------------------+------------+--------------------|
  | 初始化     | 小程序打开的第一个页面                           |            | onLoad, onShow     |
  | 打开新页面 | 调用 API [[../../api/route/wx.navigateTo.html][wx.navigateTo]]                           | onHide     | onLoad, onShow     |
  |            | 使用组件 [[../../component/navigator.html][<navigator open-type="navigateTo"/>=]]    |            |                    |
  | 页面重定向 | 调用 API [[../../api/route/wx.redirectTo.html][wx.redirectTo]]                         | onUnload   | onLoad, onShow     |
  |            | 使用组件 [[../../component/navigator.html][<navigator open-type="redirectTo"/>=]]    |            |                    |
  | 页面返回   | 调用 API [[../../api/route/wx.navigateBack.html][wx.navigateBack]]                       | onUnload   | onShow             |
  |            | 使用组件[[../../component/navigator.html][<navigator open-type="navigateBack">=]]  |            |                    |
  |            | 用户按左上角返回按钮                             |            |                    |
  | Tab 切换   | 调用 API [[../../api/route/wx.switchTab.html][wx.switchTab]]                          |            | 各种情况请参考下表 |
  |            | 使用组件 <navigator open-type="switchTab"/>      |            |                    |
  |            | 用户切换 Tab                                     |            |                    |
  | 重启动     | 调用 API [[../../api/route/wx.reLaunch.html][wx.reLaunch]]                           | onUnload   | onLoad, onShow     |
  |            | 使用组件 [[../../component/navigator.html][<navigator open-type="reLaunch"/>]]       |            |                    |

  Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：
  
  | 当前页面          | 路由后页面      | 触发的生命周期（按顺序）                             |
  |-------------------+-----------------+------------------------------------------------------|
  | A                 | A               | Nothing happend                                      |
  | A                 | B               | A.onHide(), B.onLoad(), B.onShow()                   |
  | A                 | B（再次打开）   | A.onHide(), B.onShow()                               |
  | C                 | A               | C.onUnload(), A.onShow()                             |
  | C                 | B               | C.onUnload(), B.onLoad(), B.onShow()                 |
  | D                 | B               | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   |
  | D（从转发进入）   | A               | D.onUnload(), A.onLoad(), A.onShow()                 |
  | D（从转发进入）   | B               | D.onUnload(), B.onLoad(), B.onShow()                 |


 


  *Tips*:

  -  =navigateTo=, =redirectTo= 只能打开非 tabBar 页面。
  -  =switchTab= 只能打开 tabBar 页面。
  -  =reLaunch= 可以打开任意页面。
  -  页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有
     tabBar。
  -  调用页面路由带的参数可以在目标页面的=onLoad=中获取。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html]]

  \\
  \\




 













  --------------


 










****** [[index_u44.html#模块化][#]] 模块化


  
  

    可以将一些公共的代码抽离成为一个单独的 js
    文件，作为一个模块。模块只有通过
    [[../../reference/api/module.html][=module.exports=]] 或者 =exports=
    才能对外暴露接口。

    注意：

    -  =exports= 是 [[../../reference/api/module.html][=module.exports=]]
       的一个引用，因此在模块里边随意更改 =exports=
       的指向会造成未知的错误。所以更推荐开发者采用 =module.exports=
       来暴露模块接口，除非你已经清晰知道这两者的关系。
    -  小程序目前不支持直接引入 =node_modules= , 开发者需要使用到
       =node_modules=
       时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的
       [[../../devtools/npm.html][npm]] 功能。





    #+BEGIN_EXAMPLE
        // common.js
        function sayHello(name) {
          console.log(`Hello ${name} !`)
        }
        function sayGoodbye(name) {
          console.log(`Goodbye ${name} !`)
        }

        module.exports.sayHello = sayHello
        exports.sayGoodbye = sayGoodbye
    #+END_EXAMPLE


 


    在需要使用这些模块的文件中，使用 =require= 将公共代码引入





    #+BEGIN_EXAMPLE
        var common = require('common.js')
        Page({
          helloMINA: function() {
            common.sayHello('MINA')
          },
          goodbyeMINA: function() {
            common.sayGoodbye('MINA')
          }
        })
    #+END_EXAMPLE


 


******* [[index_u44.html#文件作用域][#]] 文件作用域
    在 JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同
    名字的变量和函数，不会互相影响。

    通过全局函数 =getApp= 可以获取全局的应用实例，如果需要全局的数据可以在=App()=
    中设置，如：

    #+BEGIN_EXAMPLE
        // app.js
        App({
          globalData: 1
        })
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
        // a.js
        // The localValue can only be used in file a.js.
        var localValue = 'a'
        // Get the app instance.
        var app = getApp()
        // Get the global data and change it.
        app.globalData++
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
        // b.js
        // You can redefine localValue in file b.js, without interference with the localValue in a.js.
        var localValue = 'b'
        // If a.js it run before b.js, now the globalData shoule be 2.
        console.log(getApp().globalData)
    #+END_EXAMPLE

**** API
***** 事件监听 API
   我们约定，以 =on= 开头的 API用来监听某个事件是否触发，如：[[../../api/network/websocket/wx.onSocketOpen.html][wx.onSocketOpen]]， [[../../api/device/compass/wx.onCompassChange.html][wx.onCompassChange]]等。

   这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

   #+BEGIN_EXAMPLE
       wx.onCompassChange(function (res) {
         console.log(res.direction)
       })
   #+END_EXAMPLE

***** 同步 API
      我们约定，以 =Sync= 结尾的 API 都是同步 API， 如[[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]，
      [[../../api/base/system/system-info/wx.getSystemInfoSync.html][wx.getSystemInfoSync]]等。此外，也有一些其他的同步 API，如[[../../api/worker/wx.createWorker.html][wx.createWorker]]，
      [[../../api/media/background-audio/wx.getBackgroundAudioManager.html][wx.getBackgroundAudioManager]]等，详情参见 API 文档中的说明。

      同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

      *代码示例*

      #+BEGIN_EXAMPLE
          try {
            wx.setStorageSync('key', 'value')
          } catch (e) {
            console.error(e)
          }
      #+END_EXAMPLE


***** 异步 API

      大多数 API 都是异步 API，如[[../../api/network/request/wx.request.html][wx.request]]，[[../../api/open-api/login/wx.login.html][wx.login]]等。这类 API 接口通常都接受一
      个 =Object=类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

      *Object 参数说明*
      | 参数名     | 类型       | 必填   | 说明                                               |
      |------------+------------+--------+----------------------------------------------------|
      | success    | function   | 否     | 接口调用成功的回调函数                             |
      | fail       | function   | 否     | 接口调用失败的回调函数                             |
      | complete   | function   | 否     | 接口调用结束的回调函数（调用成功、失败都会执行）   |
      | 其他       | Any        | -      | 接口定义的其他参数                                 |

      *回调函数的参数*

      =success=，=fail=，=complete= 函数调用时会传入一个 =Object=类型参数，包含以下
      字段：

      | 属性    | 类型   | 说明                                                                 |
      |---------+--------+----------------------------------------------------------------------|
      | errMsg  | string | 错误信息，如果调用成功返回 =${apiName}:ok=                           |
      | errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 =0=。 |
      | 其他    | Any    | 接口返回的其他数据                                                   |

      异步 API 的执行结果需要通过 =Object=
      类型的参数中传入的对应回调函数获取。部分异步 API
      也会有返回值，可以用来实现更丰富的功能，如
      [[../../api/network/request/wx.request.html][wx.request]]，[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
      等。

      *代码示例*

      #+BEGIN_EXAMPLE
          wx.login({
            success(res) {
              console.log(res.code)
            }
          })
      #+END_EXAMPLE

***** 异步 API 返回 Promise
      1. 部分接口如 =downloadFile=, =request=, =uploadFile=, =connectSocket=,
         =createCamera=（小游戏）本身就有返回值， 它们的 promisify需要开发者自行封
         装。
      2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail
         逻辑， 会报错提示 =Uncaught (in promise)=，开发者可通过 catch
         来进行捕获。
      3. [[../../api/base/app/app-event/wx.onUnhandledRejection.html][wx.onUnhandledRejection]]
         可以监听未处理的 Promise 拒绝事件。

      *代码示例*
      #+BEGIN_EXAMPLE
          // callback 形式调用
          wx.chooseImage({
            success(res) {
              console.log('res:', res)
            }
          })

          // promise 形式调用
          wx.chooseImage().then(res => console.log('res: ', res))
      #+END_EXAMPLE

*** 视图层 View
**** WXML
****** 数据绑定

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <view> {{message}} </view>
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           // page.js
           Page({
             data: {
               message: 'Hello MINA!'
             }
           })
       #+END_EXAMPLE




****** 列表渲染

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <view wx:for="{{array}}"> {{item}} </view>
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           // page.js
           Page({
             data: {
               array: [1, 2, 3, 4, 5]
             }
           })
       #+END_EXAMPLE




****** 条件渲染

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
           <view wx:elif="{{view == 'APP'}}"> APP </view>
           <view wx:else="{{view == 'MINA'}}"> MINA </view>
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           // page.js
           Page({
             data: {
               view: 'MINA'
             }
           })
       #+END_EXAMPLE

****** 模板

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <template name="staffName">
             <view>
               FirstName: {{firstName}}, LastName: {{lastName}}
             </view>
           </template>

           <template is="staffName" data="{{...staffA}}"></template>
           <template is="staffName" data="{{...staffB}}"></template>
           <template is="staffName" data="{{...staffC}}"></template>
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           // page.js
           Page({
             data: {
               staffA: {firstName: 'Hulk', lastName: 'Hu'},
               staffB: {firstName: 'Shang', lastName: 'You'},
               staffC: {firstName: 'Gideon', lastName: 'Lin'}
             }
           })
       #+END_EXAMPLE

**** WXSS
****** 尺寸单位

       -  rpx（responsive pixel）:
         可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6
         上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px =
         750 物理像素，1rpx = 0.5px = 1 物理像素。
****** 样式导入

       使用 =@import= 语句可以导入外联样式表， =@import= 后跟需要导入的外联样式表的相对路径，用 =;= 表示语句结束。

       #+BEGIN_EXAMPLE
           /** common.wxss **/
           .small-p {
             padding:5px;
           }
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           /** app.wxss **/
           @import "common.wxss";
           .middle-p {
             padding:15px;
           }
       #+END_EXAMPLE

****** 内联样式
       #+BEGIN_EXAMPLE
           <view style="color:{{color}};" />
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           <view class="normal_view" />
       #+END_EXAMPLE




****** 选择器
       | 选择器             | 样例               | 样例描述                                         |
       |--------------------+--------------------+--------------------------------------------------|
       | .class             | =.intro=           | 选择所有拥有 class="intro" 的组件                |
       | #id                | =#firstname=       | 选择拥有 id="firstname" 的组件                   |
       | element            | =view=             | 选择所有 view 组件                               |
       | element, element   | =view, checkbox=   | 选择所有文档的 view 组件和所有的 checkbox 组件   |
       | ::after            | =view::after=      | 在 view 组件后边插入内容                         |
       | ::before           | =view::before=     | 在 view 组件前边插入内容                         |


 

**** WXS
     WXS（WeiXin Script）是小程序的一套脚本语言，结合=WXML=，可以构建出页面的结构。

****** 页面渲染

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <wxs module="m1">
           var msg = "hello world";

           module.exports.message = msg;
           </wxs>

           <view> {{m1.message}} </view>
       #+END_EXAMPLE

       页面输出：

       #+BEGIN_EXAMPLE
           hello world
       #+END_EXAMPLE




****** 数据处理

       #+BEGIN_EXAMPLE
           // page.js
           Page({
             data: {
               array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
             }
           })
       #+END_EXAMPLE

       #+BEGIN_EXAMPLE
           <!--wxml-->
           <!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
           <wxs module="m1">
           var getMax = function(array) {
             var max = undefined;
             for (var i = 0; i < array.length; ++i) {
               max = max === undefined ?
                 array[i] :
                 (max >= array[i] ? max : array[i]);
             }
             return max;
           }

           module.exports.getMax = getMax;
           </wxs>

           <!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
           <view> {{m1.getMax(array)}} </view>
       #+END_EXAMPLE

       页面输出：

       #+BEGIN_EXAMPLE
           5
       #+END_EXAMPLE

*** 事件详解
**** 事件分类
     WXML 的冒泡事件列表：

     | 类型               | 触发条件                                                                                  |
     |--------------------+-------------------------------------------------------------------------------------------|
     | touchstart         | 手指触摸动作开始                                                                          |
     | touchmove          | 手指触摸后移动                                                                            |
     | touchcancel        | 手指触摸动作被打断，如来电提醒，弹窗                                                      |
     | touchend           | 手指触摸动作结束                                                                          |
     | tap                | 手指触摸后马上离开                                                                        |
     | longpress          | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
     | longtap            | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                              |
     | transitionend      | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                 |
     | animationstart     | 会在一个 WXSS animation 动画开始时触发                                                    |
     | animationiteration | 会在一个 WXSS animation 一次迭代结束时触发                                                |
     | animationend       | 会在一个 WXSS animation 动画完成时触发                                                    |
     | touchforcechange   | 在支持 3D Touch 的 iPhone 设备，重按时会触发                                              |

  
     *注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如[[../../../component/form.html][form]]的
     =submit=事件，[[../../../component/input.html][input]]的=input=事件，[[../../../component/scroll-view.html][scroll-view]]的=scroll=事件，(详见各个[[../../../component][组件]])*

**** 绑定并阻止事件冒泡
     除 =bind= 外，也可以用 =catch= 来绑定事件。与 =bind= 不同， =catch=会阻止事件
     向上冒泡。

     例如在下边这个例子中，点击 inner view会先后调用=handleTap3=和=handleTap2=(因为
     tap 事件会冒泡到 middle view，而middle view 阻止了 tap 事件冒泡，不再向父节点
     传递)，点击 middle view会触发=handleTap2=，点击 outer view 会触发=handleTap1=。

     #+BEGIN_EXAMPLE
         <view id="outer" bindtap="handleTap1">
           outer view
           <view id="middle" catchtap="handleTap2">
             middle view
             <view id="inner" bindtap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+END_EXAMPLE



**** 互斥事件绑定
     自基础库版本 [[../../compatibility.html][2.8.2]] 起，除 =bind= 和=catch= 外，还可以使用 =mut-bind= 来绑定事
     件。一个 =mut-bind=触发后，如果事件冒泡到其他节点上，其他节点上的 =mut-bind=绑
     定函数不会被触发，但 =bind= 绑定函数和 =catch= 绑定函数依旧会被触发。

     换而言之，所有 =mut-bind=是“互斥”的，只会有其中一个绑定函数被触发。同时，它
     完全不影响 =bind= 和=catch= 的绑定效果。

     例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
     =handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。

     #+BEGIN_EXAMPLE
         <view id="outer" mut-bind:tap="handleTap1">
           outer view
           <view id="middle" bindtap="handleTap2">
             middle view
             <view id="inner" mut-bind:tap="handleTap3">
               inner view
             </view>
           </view>
         </view>
     #+END_EXAMPLE



**** 事件对象

     如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

     *BaseEvent 基础事件对象属性列表：*

     | 属性          | 类型    | 说明                           |
     |---------------+---------+--------------------------------|
     | [[index_u100.html#type][type]]          | String  | 事件类型                       |
     | [[index_u100.html#timeStamp][timeStamp]]     | Integer | 事件生成时的时间戳             |
     | [[index_u100.html#target][target]]        | Object  | 触发事件的组件的一些属性值集合 |
     | [[index_u100.html#currenttarget][currentTarget]] | Object  | 当前组件的一些属性值集合       |
     | [[index_u100.html#mark][mark]]          | Object  | 事件标记数据                   |
 
     *CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：*

     | 属性                                 | 类型     | 说明         |
     |--------------------------------------+----------+--------------|
     | [[index_u100.html#detail][detail]]   | Object   | 额外的信息   |

     *TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：*
     | 属性                                                 | 类型    | 说明                                           |
     |------------------------------------------------------+---------+------------------------------------------------|
     | [[index_u100.html#touches][touches]]                 | Array   | 触摸事件，当前停留在屏幕中的触摸点信息的数组   |
     | [[index_u100.html#changedTouches][changedTouches]]   | Array   | 触摸事件，当前变化的触摸点信息的数组           |

     *特殊事件： [[../../../component/canvas.html][canvas]]
     中的触摸事件不可冒泡，所以没有 currentTarget。*

*** 简易双向绑定
**** 双向绑定语法
     在 WXML 中，普通的属性的绑定是单向的。例如：

     #+BEGIN_EXAMPLE
         <input value="{{value}}" />
     #+END_EXAMPLE

     如果使用 =this.setData({ value: 'leaf' })= 来更新 =value=，=this.data.value=
     和输入框的中显示的值都会被更新为 =leaf=；但如果用户修改了输入框里的值，却不会
     同时改变 =this.data.value= 。

     如果需要在用户输入的同时改变 =this.data.value=，需要借助简易双向绑定机制。此时，
     可以在对应项目之前加入 =model:= 前缀：

     #+BEGIN_EXAMPLE
         <input model:value="{{value}}" />
     #+END_EXAMPLE

     这样，如果输入框的值被改变了， =this.data.value= 也会同时改变。同时，WXML 中所
     有绑定了 =value= 的位置也会被一同更新，[[../custom-component/observer.html][数据监听器]] 也会被正常触发。

     用于双向绑定的表达式有如下限制：

     1. 只能是一个单一字段的绑定，如

     #+BEGIN_EXAMPLE
         <input model:value="值为 {{value}}" />
         <input model:value="{{ a + b }}" />
     #+END_EXAMPLE

     都是非法的；

     2. 目前，尚不能 data 路径，如
     #+BEGIN_EXAMPLE
         <input model:value="{{ a.b }}" />
     #+END_EXAMPLE

     这样的表达式目前暂不支持。

**** 在自定义组件中传递双向绑定

     双向绑定同样可以使用在自定义组件上。如下的自定义组件：

     #+BEGIN_EXAMPLE
         // custom-component.js
         Component({
           properties: {
             myValue: String
           }
         })
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         <!-- custom-component.wxml -->
         <input model:value="{{myValue}}" />
     #+END_EXAMPLE

     这个自定义组件将自身的 =myValue= 属性双向绑定到了组件内输入框的 =value=属性上。
     这样，如果页面这样使用这个组件：

     #+BEGIN_EXAMPLE
         <custom-component model:my-value="{{pageValue}}" />
     #+END_EXAMPLE

     当输入框的值变更时，自定义组件的 =myValue= 属性会同时变更，这样，页面的
     =this.data.pageValue= 也会同时变更，页面 WXML 中所有绑定了 =pageValue=的位置也
     会被一同更新。

**** 在自定义组件中触发双向绑定更新

     自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData设置自身的属性。例
     如：
     #+BEGIN_EXAMPLE
         // custom-component.js
         Component({
           properties: {
             myValue: String
           },
           methods: {
             update: function() {
               // 更新 myValue
               this.setData({
                 myValue: 'leaf'
               })
             }
           }
         })
     #+END_EXAMPLE

     如果页面这样使用这个组件：

     #+BEGIN_EXAMPLE
         <custom-component model:my-value="{{pageValue}}" />
     #+END_EXAMPLE

     当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=也会同时变
     更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。

*** 基础组件
***** 公共属性

      | 属性名         | 类型         | 描述           | 注解                                     |
      |----------------+--------------+----------------+------------------------------------------|
      | id             | String       | 组件的唯一标示 | 保持整个页面唯一                         |
      | class          | String       | 组件的样式类   | 在对应的 WXSS 中定义的样式类             |
      | style          | String       | 组件的内联样式 | 可以动态设置的内联样式                   |
      | hidden         | Boolean      | 组件是否显示   | 所有组件默认显示                         |
      | data-*         | Any          | 自定义属性     | 组件上触发的事件时，会发送给事件处理函数 |
      | bind* / catch* | EventHandler | 组件的事件     | 详见[[file:wxml/event.html][事件]]                                 |

*** 获取界面上的节点信息
**** WXML 节点信息
     [[../../api/wxml/wx.createSelectorQuery.html][节点信息查询 API]]可以用于获取节点属性、样式、在界面上的位置等信息。

     最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

     *示例代码：*

     #+BEGIN_EXAMPLE
         const query = wx.createSelectorQuery()
         query.select('#the-id').boundingClientRect(function(res){
           res.top // #the-id 节点的上边界坐标（相对于显示区域）
         })
         query.selectViewport().scrollOffset(function(res){
           res.scrollTop // 显示区域的竖直滚动位置
         })
         query.exec()
     #+END_EXAMPLE

     上述示例中， =#the-id= 是一个节点选择器，与 CSS的选择器相近但略有区别，请参见
     [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]]的相关说明。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createSelectorQuery= 来代替
     [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
     ，这样可以确保在正确的范围内选择节点。

**** WXML 节点布局相交状态

     [[../../api/wxml/wx.createIntersectionObserver.html][节点布局相交状态API]]可用于监听两个或多个组件节点在布局位置上的相交状态。这一组
     API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

     这一组 API 涉及的主要概念如下。

     -  参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的
       *交集* 作为参照区域。页面显示区域也可作为参照区域之一。
     -  目标节点：监听的目标，默认只能是一个节点（使用 =selectAll=
       选项时，可以同时监听多个节点）。
     -  相交区域：目标节点的布局区域与参照区域的相交区域。
     -  相交比例：相交区域占参照区域的比例。
     -  阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

     以下示例代码可以在目标节点（用选择器 =.target-class=
     指定）每次进入或离开页面显示区域时，触发回调函数。

     *示例代码：*

     #+BEGIN_EXAMPLE
         Page({
           onLoad: function(){
             wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
               res.id // 目标节点 id
               res.dataset // 目标节点 dataset
               res.intersectionRatio // 相交区域占目标节点的布局区域的比例
               res.intersectionRect // 相交区域
               res.intersectionRect.left // 相交区域的左边界坐标
               res.intersectionRect.top // 相交区域的上边界坐标
               res.intersectionRect.width // 相交区域的宽度
               res.intersectionRect.height // 相交区域的高度
             })
           }
         })
     #+END_EXAMPLE

     以下示例代码可以在目标节点（用选择器 =.target-class=指定）与参照节点（用选择器
     =.relative-class=指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节
     点布局区域的 20%和 50%时，触发回调函数。

     *示例代码：*

     #+BEGIN_EXAMPLE
         Page({
           onLoad: function(){
             wx.createIntersectionObserver(this, {
               thresholds: [0.2, 0.5]
             }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
               res.intersectionRatio // 相交区域占目标节点的布局区域的比例
               res.intersectionRect // 相交区域
               res.intersectionRect.left // 相交区域的左边界坐标
               res.intersectionRect.top // 相交区域的上边界坐标
               res.intersectionRect.width // 相交区域的宽度
               res.intersectionRect.height // 相交区域的高度
             })
           }
         })
     #+END_EXAMPLE

     注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是
     “布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中overflow
     样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。

     在自定义组件或包含自定义组件的页面中，推荐使用
     =this.createIntersectionObserver= 来代替[[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]，这样可
     以确保在正确的范围内选择节点。

*** 响应显示区域变化
**** 显示区域尺寸
     显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺
     寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

***** 在手机上启用屏幕旋转支持

      从小程序基础库版本 [[../compatibility.html][2.4.0]]开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持
      屏幕旋转的方法是：在=app.json= 的 =window= 段中设置 ="pageOrientation":
      "auto"= ，或在页面json 文件中配置 ="pageOrientation": "auto"= 。

      以下是在单个页面 json 文件中启用屏幕旋转的示例。

      *代码示例：*

      #+BEGIN_EXAMPLE
          {
            "pageOrientation": "auto"
          }
      #+END_EXAMPLE





      如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

      从小程序基础库版本 [[../compatibility.html][2.5.0]] 开始，=pageOrientation= 还可以被设置为 =landscape= ，
      表示固定为横屏显示。

***** [[index_u26.html#在-iPad-上启用屏幕旋转支持][#]] 在 iPad
      上启用屏幕旋转支持


  
 

      从小程序基础库版本 [[../compatibility.html][2.3.0]] 开始，在 iPad
      上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在
      =app.json= 中添加 ="resizable": true= 。

      *代码示例：*





      #+BEGIN_EXAMPLE
          {
            "resizable": true
          }
      #+END_EXAMPLE





      如果小程序添加了上述声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。注意：在
      iPad 上不能单独配置某个页面是否支持屏幕旋转。

**** [[index_u26.html#Media-Query][#]] Media Query


  
 

     有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 media
     query 来解决大多数问题。

     *代码示例：*





     #+BEGIN_EXAMPLE
         .my-class {
           width: 40px;
         }

         @media (min-width: 480px) {
           /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
           .my-class {
             width: 200px;
           }
         }
     #+END_EXAMPLE





     在 WXML 中，可以使用 [[../../component/match-media.html][match-media]]
     组件来根据 media query 匹配状态展示、隐藏节点。

     此外，可以在页面或者自定义组件 JS 中使用
     =this.createMediaQueryObserver()= 方法来创建一个
     [[../../api/wxml/MediaQueryObserver.html][=MediaQueryObserver=]]
     对象，用于监听指定的 media query 的匹配状态。

     [[https://developers.weixin.qq.com/s/TtFaFjmb7aiy][在开发者工具中预览效果<<>>]]

**** [[index_u26.html#屏幕旋转事件][#]] 屏幕旋转事件


  
 

     有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js
     作为辅助。

     在 js 中读取页面的显示区域尺寸，可以使用
     [[../../api/wxml/SelectorQuery.selectViewport.html][selectorQuery.selectViewport]]
     。

     页面尺寸发生改变的事件，可以使用页面的 =onResize=
     来监听。对于自定义组件，可以使用 resize
     生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本
     [[../compatibility.html][2.4.0]] 开始支持。）

     *代码示例：*





     #+BEGIN_EXAMPLE
         Page({
           onResize(res) {
             res.size.windowWidth // 新的显示区域宽度
             res.size.windowHeight // 新的显示区域高度
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         Component({
           pageLifetimes: {
             resize(res) {
               res.size.windowWidth // 新的显示区域宽度
               res.size.windowHeight // 新的显示区域高度
             }
           }
         })
     #+END_EXAMPLE





     此外，还可以使用
     [[../../api/ui/window/wx.onWindowResize.html][wx.onWindowResize]]
     来监听（但这不是推荐的方式）。

     *Bug & tips:*

     -  Bug： Android 微信版本 6.7.3 中， =live-pusher=
       组件在屏幕旋转时方向异常。













     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html]]

     \\
     \\




 













     --------------


 







*** 动画
**** 界面动画的常见方式
     在小程序中，通常可以使用[[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions][CSS渐变<<>>]] 和[[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations][CSS动画<<>>]] 来创建简易的界面动画。

     动画过程中，可以使用 =bindtransitionend= =bindanimationstart=
     =bindanimationiteration= =bindanimationend= 来监听动画事件。

     | 事件名               | 含义                                                                                                 |
     |----------------------+------------------------------------------------------------------------------------------------------|
     | transitionend        | CSS 渐变结束或 [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]] 结束一个阶段   |
     | animationstart       | CSS 动画开始                                                                                         |
     | animationiteration   | CSS 动画结束一个阶段                                                                                 |
     | animationend         | CSS 动画结束                                                                                         |

     注意：这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。

**** 关键帧动画

     从小程序基础库 [[../compatibility.html][2.9.0]]开始支持一种更友好的动画创建方式，用于代替旧的
     [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]。它具有更好的性能和更可控的接口。

     在页面或自定义组件中，当需要进行关键帧动画时，可以使用 =this.animate=
     接口：

     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, callback)
     #+END_EXAMPLE

     *参数说明*

     | 属性      | 类型     | 默认值 | 必填 | 说明                       |
     | keyframes | Array    |        | 是   | 关键帧信息                 |
     | duration  | Number   |        | 是   | 动画持续时长（毫秒为单位） |
     | callback  | function |        | 否   | 动画完成后的回调函数       |

     *keyframes 中对象的结构*

     | 属性            | 类型          | 默认值 | 必填                              | 说明                                    |
     |-----------------+---------------+--------+-----------------------------------+-----------------------------------------|
     | offset          | Number        |        | 否                                | 关键帧的偏移，范围[0-1]                 |
     | ease            | String        | linear | 否                                | 动画缓动函数                            |
     | transformOrigin | String        | 否     | 基点位置，即 CSS transform-origin |                                         |
     | backgroundColor | String        |        | 否                                | 背景颜色，即 CSS background-color       |
     | bottom          | Number/String |        | 否                                | 底边位置，即 CSS bottom                 |
     | height          | Number/String |        | 否                                | 高度，即 CSS height                     |
     | left            | Number/String |        | 否                                | 左边位置，即 CSS left                   |
     | width           | Number/String |        | 否                                | 宽度，即 CSS width                      |
     | opacity         | Number        |        | 否                                | 不透明度，即 CSS opacity                |
     | right           | Number        |        | 否                                | 右边位置，即 CSS right                  |
     | top             | Number/String |        | 否                                | 顶边位置，即 CSS top                    |
     | matrix          | Array         |        | 否                                | 变换矩阵，即 CSS transform matrix       |
     | matrix3d        | Array         |        | 否                                | 三维变换矩阵，即 CSS transform matrix3d |
     | rotate          | Number        |        | 否                                | 旋转，即 CSS transform rotate           |
     | rotate3d        | Array         |        | 否                                | 三维旋转，即 CSS transform rotate3d     |
     | rotateX         | Number        |        | 否                                | X 方向旋转，即 CSS transform rotateX    |
     | rotateY         | Number        |        | 否                                | Y 方向旋转，即 CSS transform rotateY    |
     | rotateZ         | Number        |        | 否                                | Z 方向旋转，即 CSS transform rotateZ    |
     | scale           | Array         |        | 否                                | 缩放，即 CSS transform scale            |
     | scale3d         | Array         |        | 否                                | 三维缩放，即 CSS transform scale3d      |
     | scaleX          | Number        |        | 否                                | X 方向缩放，即 CSS transform scaleX     |
     | scaleY          | Number        |        | 否                                | Y 方向缩放，即 CSS transform scaleY     |
     | scaleZ          | Number        |        | 否                                | Z 方向缩放，即 CSS transform scaleZ     |
     | skew            | Array         |        | 否                                | 倾斜，即 CSS transform skew             |
     | skewX           | Number        |        | 否                                | X 方向倾斜，即 CSS transform skewX      |
     | skewY           | Number        |        | 否                                | Y 方向倾斜，即 CSS transform skewY      |
     | translate       | Array         |        | 否                                | 位移，即 CSS transform translate        |
     | translate3d     | Array         |        | 否                                | 三维位移，即 CSS transform translate3d  |
     | translateX      | Number        |        | 否                                | X 方向位移，即 CSS transform translateX |
     | translateY      | Number        |        | 否                                | Y 方向位移，即 CSS transform translateY |
     | translateZ      | Number        |        | 否                                | Z 方向位移，即 CSS transform translateZ |


 

**** [[index_u59.html#滚动驱动的动画][#]] 滚动驱动的动画


  
 

     我们发现，根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库
     [[../compatibility.html][2.9.0]] 开始支持一种由滚动驱动的动画机制。

     基于上述的关键帧动画接口，新增一个 =ScrollTimeline=
     的参数，用来绑定滚动元素（目前只支持 scroll-view）。接口定义如下：





     #+BEGIN_EXAMPLE
         this.animate(selector, keyframes, duration, ScrollTimeline)
     #+END_EXAMPLE





     *ScrollTimeline 中对象的结构*





     | 属性                | 类型     | 默认值     | 必填   | 说明                                                                                              |
     |---------------------+----------+------------+--------+---------------------------------------------------------------------------------------------------|
     | scrollSource        | String   |            | 是     | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度                          |
     | orientation         | String   | vertical   | 否     | 指定滚动的方向。有效值为 horizontal 或 vertical                                                   |
     | startScrollOffset   | Number   |            | 是     | 指定开始驱动动画进度的滚动偏移量，单位 px                                                         |
     | endScrollOffset     | Number   |            | 是     | 指定停止驱动动画进度的滚动偏移量，单位 px                                                         |
     | timeRange           | Number   |            | 是     | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms   |


 


**** [[index_u59.html#示例代码-2][#]] 示例代码


  
 

     [[https://developers.weixin.qq.com/s/994o8jmY7FcQ][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
           this.animate('.avatar', [{
             borderRadius: '0',
             borderColor: 'red',
             transform: 'scale(1) translateY(-20px)',
             offset: 0,
           }, {
             borderRadius: '25%',
             borderColor: 'blue',
             transform: 'scale(.65) translateY(-20px)',
             offset: .5,
           }, {
             borderRadius: '50%',
             borderColor: 'blue',
             transform: `scale(.3) translateY(-20px)`,
             offset: 1
           }], 2000, {
             scrollSource: '#scroller',
             timeRange: 2000,
             startScrollOffset: 0,
             endScrollOffset: 85,
           })

           this.animate('.search_input', [{
             opacity: '0',
             width: '0%',
           }, {
             opacity: '1',
             width: '100%',
           }], 1000, {
             scrollSource: '#scroller',
             timeRange: 1000,
             startScrollOffset: 120,
             endScrollOffset: 252
           })
     #+END_EXAMPLE





**** [[index_u59.html#高级的动画方式][#]] 高级的动画方式


  
 

     在一些复杂场景下，上述的动画方法可能并不适用。

     [[file:interactive-animation.html][WXS 响应事件]] 的方式可以通过使用 WXS
     来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style
     属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

     连续使用 setData
     来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的
     setData 改为 [[../custom-component][自定义组件]] 中的 setData
     来提升性能。下面的例子是使用 setData 来实现秒表动画的示例。

     [[https://developers.weixin.qq.com/s/cRTvdPmO7d5T][在开发者工具中预览效果<<>>]]


 



 






     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html]]

     \\
     \\




 













     --------------


 







*** 初始渲染缓存
**** 初始渲染缓存工作原理

     小程序页面的初始化分为两个部分。

     -  逻辑层初始化：载入必需的小程序代码、初始化页面 this对象（也包括它涉及到的所
       有自定义组件的 this对象）、将相关数据发送给视图层。
     -  视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发
       送的数据，最后渲染页面。

     在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

     启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始
     data
     的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

     -  在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
     -  在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
     -  如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

     利用初始渲染缓存，可以：

     -  快速展示出页面中永远不会变的部分，如导航栏；
     -  预先展示一个骨架页，提升用户体验；
     -  展示自定义的加载提示；
     -  提前展示广告，等等。

**** [[index_u95.html#支持的组件][#]] 支持的组件

     在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

     目前支持的内置组件：

     -  =<view />=
     -  =<text />=
     -  =<button />=
     -  =<image />=
     -  =<scroll-view />=
     -  =<rich-text />=

     自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**** [[index_u95.html#静态初始渲染缓存][#]] 静态初始渲染缓存


  
 

     若想启用初始渲染缓存，最简单的方法是在页面的 =json= 文件中添加配置项
     ="initialRenderingCache": "static"= ：





     #+BEGIN_EXAMPLE
         {
           "initialRenderingCache": "static"
         }
     #+END_EXAMPLE





     如果想要对所有页面启用，可以在 =app.json= 的 =window=
     配置段中添加这个配置：





     #+BEGIN_EXAMPLE
         {
           "window": {
             "initialRenderingCache": "static"
           }
         }
     #+END_EXAMPLE





     添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

     注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML
     上的结果，不包含任何 setData 的结果。

     例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 =loading=
     数据字段控制：





     #+BEGIN_EXAMPLE
         <view wx:if="{{loading}}">正在加载</view>
     #+END_EXAMPLE





     这种情况下， =loading= 应当在 =data= 中指定为 =true= ，如：





     #+BEGIN_EXAMPLE
         // 正确的做法
         Page({
           data: {
             loading: true
           }
         })
     #+END_EXAMPLE





     而不能通过 =setData= 将 =loading= 置为 =true= ：





     #+BEGIN_EXAMPLE
         // 错误的做法！不要这么做！
         Page({
           data: {},
           onLoad: function() {
             this.setData({
               loading: true
             })
           }
         })
     #+END_EXAMPLE





     换而言之，这种做法只包含页面 =data= 的渲染结果，即页面的纯静态成分。

**** [[index_u95.html#在初始渲染缓存中添加动态内容][#]] 在初始渲染缓存中添加动态内容
     有些场景中，只是页面 =data=
     的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片
     URL 等。

     这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置
     ="initialRenderingCache": "dynamic"= ：





     #+BEGIN_EXAMPLE
         {
           "initialRenderingCache": "dynamic"
         }
     #+END_EXAMPLE





     此时，初始渲染缓存不会被自动启用，还需要在页面中调用
     =this.setInitialRenderingCache(dynamicData)= 才能启用。其中，
     =dynamicData= 是一组数据，与 =data= 一起参与页面 WXML 渲染。





     #+BEGIN_EXAMPLE
         Page({
           data: {
             loading: true
           },
           onReady: function() {
             this.setInitialRenderingCache({
               loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
             })
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         <view wx:if="{{loading}}">{{loadingHint}}</view>
     #+END_EXAMPLE





     从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用
     =this.setInitialRenderingCache=
     ，如果在一个页面内多次调用，仅最后一次调用生效。

     注意：

     -  =this.setInitialRenderingCache= 调用时机不能早于 =Page= 的 =onReady=
       或 =Component= 的 =ready= 生命周期，否则可能对性能有负面影响。
     -  如果想禁用初始渲染缓存，调用 =this.setInitialRenderingCache(null)= 。













     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html]]

     \\
     \\




 













     --------------


 
** 自定义组件
   开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可
   以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础
   组件非常相似。

**** [[index_u7.html#创建自定义组件][#]] 创建自定义组件

     类似于页面，一个自定义组件由 =json= =wxml= =wxss= =js=
     4 个文件组成。要编写一个自定义组件，首先需要在 =json=
     文件中进行自定义组件声明（将 =component= 字段设为 =true=
     可将这一组文件设为自定义组件）：

     #+BEGIN_EXAMPLE
         {
           "component": true
         }
     #+END_EXAMPLE





     同时，还要在 =wxml= 文件中编写组件模板，在 =wxss=
     文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见
     [[file:wxml-wxss.html][组件模板和样式]] 。

     *代码示例：*

     #+BEGIN_EXAMPLE
         <!-- 这是自定义组件的内部WXML结构 -->
         <view class="inner">
           {{innerText}}
         </view>
         <slot></slot>
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
         /* 这里的样式只应用于这个自定义组件 */
         .inner {
           color: red;
         }
     #+END_EXAMPLE





     *注意：在组件 wxss 中不应使用 ID 选择器、属性选择器和标签名选择器。*

     在自定义组件的 =js= 文件中，需要使用 =Component()=
     来注册组件，并提供组件的属性定义、内部数据和自定义方法。

     组件的属性值和内部数据将被用于组件 =wxml=
     的渲染，其中，属性值是可由组件外部传入的。更多细节参见
     [[file:component.html][Component构造器]] 。

     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           properties: {
             // 这里定义了innerText属性，属性值可以在组件使用时指定
             innerText: {
               type: String,
               value: 'default value',
             }
           },
           data: {
             // 这里是一些组件内部数据
             someData: {}
           },
           methods: {
             // 这里是一个自定义方法
             customMethod: function(){}
           }
         })
     #+END_EXAMPLE

**** [[index_u7.html#使用自定义组件][#]] 使用自定义组件
     使用已注册的自定义组件前，首先要在页面的 =json=
     文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：





     #+BEGIN_EXAMPLE
         {
           "usingComponents": {
             "component-tag-name": "path/to/the/custom/component"
           }
         }
     #+END_EXAMPLE





     这样，在页面的 =wxml=
     中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

     #+BEGIN_QUOTE
     开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明
     usingComponents
     字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。
     #+END_QUOTE

     *代码示例：*

     [[https://developers.weixin.qq.com/s/OMfVAKmZ6KZT][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         <view>
           <!-- 以下是对一个自定义组件的引用 -->
           <component-tag-name inner-text="Some text"></component-tag-name>
         </view>
     #+END_EXAMPLE

     自定义组件的 =wxml= 节点结构在与数据结合之后，将被插入到引用位置内。

**** [[index_u7.html#细节注意事项][#]] 细节注意事项
     一些需要注意的细节：

     -  因为 WXML
       节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
     -  自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用
       =usingComponents= 字段）。
     -  自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

     注意，是否在页面文件中使用 =usingComponents= 会使得页面的 =this=
     对象的原型稍有差异，包括：

     -  使用 =usingComponents= 页面的原型与不使用时不一致，即
       =Object.getPrototypeOf(this)= 结果不同。
     -  使用 =usingComponents= 时会多一些方法，如 =selectComponent= 。
     -  出于性能考虑，使用 =usingComponents= 时， =setData=
       内容不会被直接深复制，即 =this.setData({ field: obj })= 后
       =this.data.field === obj= 。（深复制会在这个值被组件间传递时发生。）

     如果页面比较复杂，新增或删除 =usingComponents=
     定义段时建议重新测试一下。

*** [[index_u90.html#组件模板和样式][#]] 组件模板和样式

    类似于页面，自定义组件拥有自己的 =wxml= 模板和 =wxss= 样式。

***** [[index_u90.html#组件模板][#]] 组件模板


  
 

      组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

      在组件模板中可以提供一个 =<slot>= 节点，用于承载组件引用时提供的子节点。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/1udXLnmi6KY2][在开发者工具中预览效果<<>>]]





      #+BEGIN_EXAMPLE
          <!-- 组件模板 -->
          <view class="wrapper">
            <view>这里是组件的内部节点</view>
            <slot></slot>
          </view>
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          <!-- 引用组件的页面模板 -->
          <view>
            <component-tag-name>
              <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
              <view>这里是插入到组件slot中的内容</view>
            </component-tag-name>
          </view>
      #+END_EXAMPLE





      注意，在模板中引用到的自定义组件及其对应的节点名需要在 =json=
      文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为[[file:generics.html][抽象节点]]。

***** [[index_u90.html#模板数据绑定][#]] 模板数据绑定


  
 

      与普通的 WXML
      模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/8ZhcXBme7djX][在开发者工具中预览效果<<>>]]





      #+BEGIN_EXAMPLE
          <!-- 引用组件的页面模板 -->
          <view>
            <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
              <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
              <view>这里是插入到组件slot中的内容</view>
            </component-tag-name>
          </view>
      #+END_EXAMPLE





      在以上例子中，组件的属性 =propA= 和 =propB=
      将收到页面传递的数据。页面可以通过 =setData= 来改变绑定的数据字段。

      注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本
      [[../compatibility.html][2.0.9]]
      开始，还可以在数据中包含函数（但这些函数不能在 WXML
      中直接调用，只能传递给子组件）。

***** [[index_u90.html#组件-wxml-的-slot][#]] 组件 wxml 的 slot


  
 

      在组件的 wxml 中可以包含 =slot= 节点，用于承载组件使用者提供的 wxml
      结构。

      默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot
      时，可以在组件 js 中声明启用。





      #+BEGIN_EXAMPLE
          Component({
            options: {
              multipleSlots: true // 在组件定义时的选项中启用多slot支持
            },
            properties: { /* ... */ },
            methods: { /* ... */ }
          })
      #+END_EXAMPLE





      此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 =name= 来区分。





      #+BEGIN_EXAMPLE
          <!-- 组件模板 -->
          <view class="wrapper">
            <slot name="before"></slot>
            <view>这里是组件的内部细节</view>
            <slot name="after"></slot>
          </view>
      #+END_EXAMPLE





      使用时，用 =slot= 属性来将节点插入到不同的 slot 上。





      #+BEGIN_EXAMPLE
          <!-- 引用组件的页面模板 -->
          <view>
            <component-tag-name>
              <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
              <view slot="before">这里是插入到组件slot name="before"中的内容</view>
              <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
              <view slot="after">这里是插入到组件slot name="after"中的内容</view>
            </component-tag-name>
          </view>
      #+END_EXAMPLE





***** [[index_u90.html#组件样式][#]] 组件样式


  
 

      组件对应 =wxss=
      文件的样式，只对组件 wxml 内的节点生效。编写组件样式时，需要注意以下几点：

      -  组件和引用组件的页面不能使用 id 选择器（=#a=）、属性选择器（=[a]=）和标签名选择器，请改用 class 选择器。
      -  组件和引用组件的页面中使用后代选择器（=.a .b=）在一些极端情况下会有非预期的表现，如遇，请避免使用。
      -  子元素选择器（=.a>.b=）只能用于 =view=
        组件与其子节点之间，用于其他组件可能导致非预期的情况。
      -  继承样式，如 =font= 、 =color= ，会从组件外继承到组件内。
      -  除继承样式外， =app.wxss=
        中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。





      #+BEGIN_EXAMPLE
          #a { } /* 在组件中不能使用 */
          [a] { } /* 在组件中不能使用 */
          button { } /* 在组件中不能使用 */
          .a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */
      #+END_EXAMPLE





      除此以外，组件可以指定它所在节点的默认样式，使用 =:host=
      选择器（需要包含基础库 [[../compatibility.html][1.7.2]]
      或更高版本的开发者工具支持）。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/jAgvwKm16bZD][在开发者工具中预览效果<<>>]]





      #+BEGIN_EXAMPLE
          /* 组件 custom-component.wxss */
          :host {
            color: yellow;
          }
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          <!-- 页面的 WXML -->
          <custom-component>这段文本是黄色的</custom-component>
      #+END_EXAMPLE





***** [[index_u90.html#组件样式隔离][#]] 组件样式隔离


  
 

      默认情况下，自定义组件的样式只受到自定义组件 wxss
      的影响。除非以下两种情况：

      -  =app.wxss= 或页面的 =wxss=
        中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
      -  指定特殊的样式隔离选项 =styleIsolation= 。





      #+BEGIN_EXAMPLE
          Component({
            options: {
              styleIsolation: 'isolated'
            }
          })
      #+END_EXAMPLE





      [[https://developers.weixin.qq.com/s/xPQhJcm37e7h][在开发者工具中预览效果<<>>]]

      =styleIsolation= 选项从基础库版本 [[../compatibility.html][2.6.5]]
      开始支持。它支持以下取值：

      -  =isolated= 表示启用样式隔离，在自定义组件内外，使用 class
        指定的样式将不会相互影响（一般情况下的默认值）；
      -  =apply-shared= 表示页面 wxss 样式将影响到自定义组件，但自定义组件
        wxss 中指定的样式不会影响页面；
      -  =shared= 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss
        中指定的样式也会影响页面和其他设置了 =apply-shared= 或 =shared=
        的自定义组件。（这个选项在插件中不可用。）

      *使用后两者时，请务必注意组件间样式的相互影响。*

      如果这个 [[file:component.html][Component 构造器用于构造页面]]
      ，则默认值为 =shared= ，且还有以下几个额外的样式隔离选项可用：

      -  =page-isolated= 表示在这个页面禁用 app.wxss ，同时，页面的 wxss
        不会影响到其他自定义组件；
      -  =page-apply-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
        样式不会影响到其他自定义组件，但设为 =shared=
        的自定义组件会影响到页面；
      -  =page-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
        样式会影响到其他设为 =apply-shared= 或 =shared=
        的自定义组件，也会受到设为 =shared= 的自定义组件的影响。

      从小程序基础库版本 [[../compatibility.html][2.10.1]]
      开始，也可以在页面或自定义组件的 json 文件中配置 =styleIsolation=
      （这样就不需在 js 文件的 =options= 中再配置）。例如：





      #+BEGIN_EXAMPLE
          {
            "styleIsolation": "isolated"
          }
      #+END_EXAMPLE





      此外，小程序基础库版本 [[../compatibility.html][2.2.3]] 以上支持
      =addGlobalClass= 选项，即在 =Component= 的 =options= 中设置
      =addGlobalClass: true= 。 这个选项等价于设置
      =styleIsolation: apply-shared= ，但设置了 =styleIsolation=
      选项后这个选项会失效。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/VkTd7Fm37ggl][在开发者工具中预览效果<<>>]]





      #+BEGIN_EXAMPLE
          /* 组件 custom-component.js */
          Component({
            options: {
              addGlobalClass: true,
            }
          })
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          <!-- 组件 custom-component.wxml -->
          <text class="red-text">这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text>
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          /* app.wxss */
          .red-text {
            color: red;
          }
      #+END_EXAMPLE





***** [[index_u90.html#外部样式类][#]] 外部样式类


  
 

      #+BEGIN_QUOTE
      基础库 1.9.90
      开始支持，低版本需做[[../compatibility.html][兼容处理]]。
      #+END_QUOTE

      有时，组件希望接受外部传入的样式类。此时可以在 =Component= 中用
      =externalClasses= 定义段定义若干个外部样式类。

      这个特性可以用于实现类似于 =view= 组件的 =hover-class=
      属性：页面可以提供一个样式类，赋予 =view= 的 =hover-class=
      ，这个样式类本身写在页面中而非 =view= 组件的实现中。

      *注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。*

      *代码示例：*





      #+BEGIN_EXAMPLE
          /* 组件 custom-component.js */
          Component({
            externalClasses: ['my-class']
          })
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          <!-- 组件 custom-component.wxml -->
          <custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
      #+END_EXAMPLE





      这样，组件的使用者可以指定这个样式类对应的 class
      ，就像使用普通属性一样。在 [[../compatibility.html][2.7.1]]
      之后，可以指定多个对应的 class 。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/rbgNNKmE6bZK][在开发者工具中预览效果<<>>]]





      #+BEGIN_EXAMPLE
          <!-- 页面的 WXML -->
          <custom-component my-class="red-text" />
          <custom-component my-class="large-text" />
          <!-- 以下写法需要基础库版本 2.7.1 以上 -->
          <custom-component my-class="red-text large-text" />
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          .red-text {
            color: red;
          }
          .large-text {
            font-size: 1.5em;
          }
      #+END_EXAMPLE





***** [[index_u90.html#引用页面或父组件的样式][#]] 引用页面或父组件的样式


  
 

      #+BEGIN_QUOTE
      基础库 2.9.2 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
      #+END_QUOTE

      即使启用了样式隔离 =isolated=
      ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

      例如，如果在页面 wxss 中定义了：





      #+BEGIN_EXAMPLE
          .blue-text {
            color: blue;
          }
      #+END_EXAMPLE





      在这个组件中可以使用 =~= 来引用这个类的样式：





      #+BEGIN_EXAMPLE
          <view class="~blue-text"> 这段文本是蓝色的 </view>
      #+END_EXAMPLE





      如果在一个组件的父组件 wxss 中定义了：





      #+BEGIN_EXAMPLE
          .red-text {
            color: red;
          }
      #+END_EXAMPLE





      在这个组件中可以使用 =^= 来引用这个类的样式：





      #+BEGIN_EXAMPLE
          <view class="^red-text"> 这段文本是红色的 </view>
      #+END_EXAMPLE





      也可以连续使用多个 =^= 来引用祖先组件中的样式。

      *注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。*

***** [[index_u90.html#虚拟化组件节点][#]] 虚拟化组件节点


  
 

      #+BEGIN_QUOTE
      基础库 2.11.2
      开始支持，低版本需做[[../compatibility.html][兼容处理]]。
      #+END_QUOTE

      默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置
      =class= =style= 、动画、 flex 布局等，就如同普通的 view 组件节点一样。





      #+BEGIN_EXAMPLE
          <!-- 页面的 WXML -->
          <view style="display: flex">
            <!-- 默认情况下，这是一个普通的节点 -->
            <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>
          </view>
      #+END_EXAMPLE





      但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex
      布局等，而是希望自定义组件内部的第一层节点能够响应 flex
      布局或者样式由自定义组件本身完全决定。

      这种情况下，可以将这个自定义组件设置为“虚拟的”：





      #+BEGIN_EXAMPLE
          Component({
            options: {
              virtualHost: true
            },
            properties: {
              style: { // 定义 style 属性可以拿到 style 属性上设置的值
                type: String,
              }
            },
            externalClasses: ['class'], // 可以将 class 设为 externalClasses
          })
      #+END_EXAMPLE





      这样，可以将 flex 放入自定义组件内：





      #+BEGIN_EXAMPLE
          <!-- 页面的 WXML -->
          <view style="display: flex">
            <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
            <custom-component style="color: blue">不是蓝色的</custom-component>
          </view>
      #+END_EXAMPLE









      #+BEGIN_EXAMPLE
          <!-- custom-component.wxml -->
          <view style="flex: 1">
            满宽的
            <slot></slot>
          </view>
      #+END_EXAMPLE





      需要注意的是，自定义组件节点上的 =class= =style=
      和动画将不再生效，但仍可以：

      -  将 style 定义成 =properties= 属性来获取 style 上设置的值；
      -  将 class 定义成 =externalClasses= 外部样式类使得自定义组件 wxml
        可以使用 class 值。

      *代码示例：*

      [[https://developers.weixin.qq.com/s/AlV9fEmF7Dh8][在开发者工具中预览效果<<>>]]


 



 






      --------------


      [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html]]

      \\
      \\




 













      --------------


 










*** [[index_u72.html#Component-构造器][#]] Component 构造器


  
 

    =Component= 构造器可用于定义组件，调用 =Component=
    构造器时可以指定组件的属性、数据、方法等。

    详细的参数含义和使用请参考
    [[../../reference/api/Component.html][Component 参考文档]]。





    #+BEGIN_EXAMPLE
        Component({

          behaviors: [],

          properties: {
            myProperty: { // 属性名
              type: String,
              value: ''
            },
            myProperty2: String // 简化的定义方式
          },

          data: {}, // 私有数据，可用于模板渲染

          lifetimes: {
            // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
            attached: function () { },
            moved: function () { },
            detached: function () { },
          },

          // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
          attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
          ready: function() { },

          pageLifetimes: {
            // 组件所在页面的生命周期函数
            show: function () { },
            hide: function () { },
            resize: function () { },
          },

          methods: {
            onMyButtonTap: function(){
              this.setData({
                // 更新属性和数据的方法与更新页面数据的方法类似
              })
            },
            // 内部方法建议以下划线开头
            _myPrivateMethod: function(){
              // 这里将 data.A[0].B 设为 'myPrivateData'
              this.setData({
                'A[0].B': 'myPrivateData'
              })
            },
            _propertyChange: function(newVal, oldVal) {

            }
          }

        })
    #+END_EXAMPLE





**** [[index_u72.html#使用-Component-构造器构造页面][#]] 使用 Component
     构造器构造页面


  
 

     事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用
     =Component=
     构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json
     文件中包含 =usingComponents= 定义段。

     此时，组件的属性可以用于接收页面的参数，如访问页面
     =/pages/index/index?paramA=123&paramB=xyz= ，如果声明有属性 =paramA= 或
     =paramB= ，则它们会被赋值为 =123= 或 =xyz= 。

     页面的生命周期方法（即 =on= 开头的方法），应写在 =methods= 定义段中。

     *代码示例：*





     #+BEGIN_EXAMPLE
         {
           "usingComponents": {}
         }
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         Component({

           properties: {
             paramA: Number,
             paramB: String,
           },

           methods: {
             onLoad: function() {
               this.data.paramA // 页面参数 paramA 的值
               this.data.paramB // 页面参数 paramB 的值
             }
           }

         })
     #+END_EXAMPLE





     使用 =Component= 构造器来构造页面的一个好处是可以使用 =behaviors=
     来提取所有页面中公用的代码段。

     例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到
     =behaviors= 中。

     *代码示例：*





     #+BEGIN_EXAMPLE
         // page-common-behavior.js
         module.exports = Behavior({
           attached: function() {
             // 页面创建时执行
             console.info('Page loaded!')
           },
           detached: function() {
             // 页面销毁时执行
             console.info('Page unloaded!')
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 页面 A
         var pageCommonBehavior = require('./page-common-behavior')
         Component({
           behaviors: [pageCommonBehavior],
           data: { /* ... */ },
           methods: { /* ... */ },
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 页面 B
         var pageCommonBehavior = require('./page-common-behavior')
         Component({
           behaviors: [pageCommonBehavior],
           data: { /* ... */ },
           methods: { /* ... */ },
         })
     #+END_EXAMPLE

















     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html]]

     \\
     \\




 













     --------------


 










*** [[index_u65.html#组件间通信与事件][#]] 组件间通信与事件


  
 
**** [[index_u65.html#组件间通信][#]] 组件间通信


  
 

     组件间的基本通信方式有以下几种。

     -  WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON
       兼容数据（自基础库版本 [[../compatibility.html][2.0.9]]
       开始，还可以在数据中包含函数）。具体在
       [[file:wxml-wxss.html][组件模板和样式]] 章节中介绍。
     -  事件：用于子组件向父组件传递数据，可以传递任意数据。
     -  如果以上两种方式不足以满足需要，父组件还可以通过
       =this.selectComponent=
       方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

**** [[index_u65.html#监听事件][#]] 监听事件


  
 

     事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见
     [[../view/wxml/event.html][事件]] 。

     监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

     *代码示例：*





     #+BEGIN_EXAMPLE
         <!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->
         <component-tag-name bindmyevent="onMyEvent" />
         <!-- 或者可以写成 -->
         <component-tag-name bind:myevent="onMyEvent" />
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         Page({
           onMyEvent: function(e){
             e.detail // 自定义组件触发事件时提供的detail对象
           }
         })
     #+END_EXAMPLE




**** [[index_u65.html#触发事件][#]] 触发事件


  
 

     自定义组件触发事件时，需要使用 =triggerEvent=
     方法，指定事件名、detail 对象和事件选项：

     *代码示例：*

     [[https://developers.weixin.qq.com/s/DFfYSKmI6vZD][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         <!-- 在自定义组件中 -->
         <button bindtap="onTap">点击这个按钮将触发“myevent”事件</button>
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         Component({
           properties: {},
           methods: {
             onTap: function(){
               var myEventDetail = {} // detail对象，提供给事件监听函数
               var myEventOption = {} // 触发事件的选项
               this.triggerEvent('myevent', myEventDetail, myEventOption)
             }
           }
         })
     #+END_EXAMPLE





     触发事件的选项包括：





     | 选项名         | 类型      | 是否必填   | 默认值   | 描述                                                                                              |
     |----------------+-----------+------------+----------+---------------------------------------------------------------------------------------------------|
     | bubbles        | Boolean   | 否         | false    | 事件是否冒泡                                                                                      |
     | composed       | Boolean   | 否         | false    | 事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部   |
     | capturePhase   | Boolean   | 否         | false    | 事件是否拥有捕获阶段                                                                              |


 


     关于冒泡和捕获阶段的概念，请阅读 [[../view/wxml/event.html][事件]]
     章节中的相关说明。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/UGfljKm66zZ1][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         // 页面 page.wxml
         <another-component bindcustomevent="pageEventListener1">
           <my-component bindcustomevent="pageEventListener2"></my-component>
         </another-component>
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 组件 another-component.wxml
         <view bindcustomevent="anotherEventListener">
           <slot />
         </view>
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 组件 my-component.wxml
         <view bindcustomevent="myEventListener">
           <slot />
         </view>
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 组件 my-component.js
         Component({
           methods: {
             onTap: function(){
               this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
               this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
               this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
             }
           }
         })
     #+END_EXAMPLE




**** [[index_u65.html#获取组件实例][#]] 获取组件实例


  
 

     可在父组件里调用 =this.selectComponent=
     ，获取子组件的实例对象。（插件的自定义组件将返回 =null=）

     调用时需要传入一个匹配选择器
     =selector=，如：=this.selectComponent(".my-component")=。

     =selector= 详细语法可查看
     [[../../api/wxml/SelectorQuery.select.html][selector 语法参考文档]]。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/oQ64sFmm7rhD][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         // 父组件
         Page({
           data: {},
           getChildComponent: function () {
             const child = this.selectComponent('.my-component');
             console.log(child)
           }
         })
     #+END_EXAMPLE





     在上例中，父组件将会获取 =class= 为 =my-component=
     的子组件实例对象，即子组件的 =this= 。

     若需要自定义 =selectComponent= 返回的数据，可使用内置 =behavior=:
     =wx://component-export=

     从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

     使自定义组件中支持 =export= 定义段，这个定义段可以用于指定组件被
     =selectComponent= 调用时的返回值。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/ZtosuRmK741Y][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         // 自定义组件 my-component 内部
         Component({
           behaviors: ['wx://component-export'],
           export() {
             return { myField: 'myValue' }
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         <!-- 使用自定义组件时 -->
         <my-component id="the-id" />
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // 父组件调用
         const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
     #+END_EXAMPLE





     在上例中，父组件获取 =id= 为 =the-id= 的子组件实例的时候，得到的是对象
     ={ myField: 'myValue' }= 。


 



 






     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html]]

     \\
     \\




 













     --------------


 









*** [[index_u94.html#组件生命周期][#]] 组件生命周期


  
 

    组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

    其中，最重要的生命周期是 =created= =attached= =detached=
    ，包含一个组件实例生命流程的最主要时间点。

    -  组件实例刚刚被创建好时， =created= 生命周期被触发。此时，组件数据
      =this.data= 就是在 =Component= 构造器中定义的数据 =data= 。
      *此时还不能调用 =setData= 。*
      通常情况下，这个生命周期只应该用于给组件 =this=
      添加一些自定义属性字段。
    -  在组件完全初始化完毕、进入页面节点树后， =attached=
      生命周期被触发。此时， =this.data=
      已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
    -  在组件离开页面节点树后， =detached=
      生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则
      =detached= 会被触发。

**** [[index_u94.html#定义生命周期方法][#]] 定义生命周期方法


  
 

     生命周期方法可以直接定义在 =Component= 构造器的第一级参数中。

     自小程序基础库版本 [[../compatibility.html][2.2.3]]
     起，组件的的生命周期也可以在 =lifetimes=
     字段内进行声明（这是推荐的方式，其优先级最高）。

     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           lifetimes: {
             attached: function() {
               // 在组件实例进入页面节点树时执行
             },
             detached: function() {
               // 在组件实例被从页面节点树移除时执行
             },
           },
           // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
           attached: function() {
             // 在组件实例进入页面节点树时执行
           },
           detached: function() {
             // 在组件实例被从页面节点树移除时执行
           },
           // ...
         })
     #+END_EXAMPLE





     在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors
     中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个
     behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

     可用的全部生命周期如下表所示。





     | 生命周期   | 参数             | 描述                                       | 最低版本                           |
     |------------+------------------+--------------------------------------------+------------------------------------|
     | created    | 无               | 在组件实例刚刚被创建时执行                 | [[../compatibility.html][1.6.3]]   |
     | attached   | 无               | 在组件实例进入页面节点树时执行             | [[../compatibility.html][1.6.3]]   |
     | ready      | 无               | 在组件在视图层布局完成后执行               | [[../compatibility.html][1.6.3]]   |
     | moved      | 无               | 在组件实例被移动到节点树另一个位置时执行   | [[../compatibility.html][1.6.3]]   |
     | detached   | 无               | 在组件实例被从页面节点树移除时执行         | [[../compatibility.html][1.6.3]]   |
     | error      | =Object Error=   | 每当组件方法抛出错误时执行                 | [[../compatibility.html][2.4.1]]   |


 


**** [[index_u94.html#组件所在页面的生命周期][#]] 组件所在页面的生命周期


  
 

     还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在
     =pageLifetimes= 定义段中定义。其中可用的生命周期包括：





     | 生命周期   | 参数            | 描述                           | 最低版本                           |
     |------------+-----------------+--------------------------------+------------------------------------|
     | show       | 无              | 组件所在的页面被展示时执行     | [[../compatibility.html][2.2.3]]   |
     | hide       | 无              | 组件所在的页面被隐藏时执行     | [[../compatibility.html][2.2.3]]   |
     | resize     | =Object Size=   | 组件所在的页面尺寸变化时执行   | [[../compatibility.html][2.4.0]]   |


 


     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           pageLifetimes: {
             show: function() {
               // 页面被展示
             },
             hide: function() {
               // 页面被隐藏
             },
             resize: function(size) {
               // 页面尺寸变化
             }
           }
         })
     #+END_EXAMPLE

















     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html]]

     \\
     \\




 













     --------------


 










*** [[index_u79.html#behaviors][#]] behaviors


  
 

    =behaviors= 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins”
    或 “traits”。

    每个 =behavior=
    可以包含一组属性、数据、生命周期函数和方法。*组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。*
    每个组件可以引用多个 =behavior= ，=behavior= 也可以引用其它 =behavior=
    。

    详细的参数含义和使用请参考 [[../../reference/api/Behavior.html][Behavior
    参考文档]]。

**** [[index_u79.html#组件中使用][#]] 组件中使用


  
 

     组件引用时，在 =behaviors= 定义段中将它们逐个列出即可。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/Yq4RqCm87thO][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         // my-component.js
         var myBehavior = require('my-behavior')
         Component({
           behaviors: [myBehavior],
           properties: {
             myProperty: {
               type: String
             }
           },
           data: {
             myData: 'my-component-data'
           },
           created: function () {
             console.log('[my-component] created')
           },
           attached: function () { 
             console.log('[my-component] attached')
           },
           ready: function () {
             console.log('[my-component] ready')
           },
           methods: {
             myMethod: function () {
               console.log('[my-component] log by myMethod')
             },
           }
         })
     #+END_EXAMPLE





     在上例中， =my-component= 组件定义中加入了 =my-behavior=，

     而 =my-behavior= 结构为：

     -  属性：=myBehaviorProperty=
     -  数据字段：=myBehaviorData=
     -  方法：=myBehaviorMethod=
     -  生命周期函数：=attached=、=created=、=ready=

     这将使 =my-component= 最终结构为：

     -  属性：=myBehaviorProperty=、=myProperty=
     -  数据字段：=myBehaviorData=、=myData=
     -  方法：=myBehaviorMethod=、=myMethod=
     -  生命周期函数：=attached=、=created=、=ready=

     当组件触发生命周期时，上例生命周期函数执行顺序为：

     1. =[my-behavior] created=
     2. =[my-component] created=
     3. =[my-behavior] attached=
     4. =[my-component] attached=
     5. =[my-behavior] ready=
     6. =[my-component] ready=

     详细规则参考 *同名字段的覆盖和组合规则*。

**** [[index_u79.html#同名字段的覆盖和组合规则][#]]
     同名字段的覆盖和组合规则


  
 

     组件和它引用的 =behavior=
     中可以包含同名的字段，对这些字段的处理方法如下：

     -  如果有同名的属性 (properties) 或方法 (methods)：

       1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 =behavior=
          中的同名属性或方法；
       2. 若组件本身无这个属性或方法，则在组件的 =behaviors=
          字段中定义靠后的 =behavior=
          的属性或方法会覆盖靠前的同名属性或方法；
       3. 在 2 的基础上，若存在嵌套引用 =behavior=
          的情况，则规则为：=父 behavior= 覆盖 =子 behavior=
          中的同名属性或方法。

     -  如果有同名的数据字段 (data)：

       -  若同名的数据字段都是对象类型，会进行对象合并；
       -  其余情况会进行数据覆盖，覆盖规则为：组件 > =父 behavior= >
         =子 behavior= 、 =靠后的 behavior= >
         =靠前的 behavior=。（优先级高的覆盖优先级低的，最大的为优先级最高）

     -  生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：

       -  对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
       -  对于同种生命周期函数，遵循如下规则：

         -  =behavior= 优先于组件执行；
         -  =子 behavior= 优先于 =父 behavior= 执行；
         -  =靠前的 behavior= 优先于 =靠后的 behavior= 执行；

       -  如果同一个 =behavior=
         被一个组件多次引用，它定义的生命周期函数只会被执行一次。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/CI5omDmT7khB][在开发者工具中预览效果<<>>]]

**** [[index_u79.html#内置-behaviors][#]] 内置 behaviors


  
 

     自定义组件可以通过引用内置的 =behavior= 来获得内置组件的一些行为。





     #+BEGIN_EXAMPLE
         Component({
           behaviors: ['wx://form-field']
         })
     #+END_EXAMPLE





     在上例中， =wx://form-field= 代表一个内置 =behavior=
     ，它使得这个自定义组件有类似于表单控件的行为。

     内置 =behavior=
     往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的
     =type= 或添加 =observer= 。

***** [[index_u79.html#wx-form-field][#]] wx://form-field


  
 

      使自定义组件有类似于表单控件的行为。 form
      组件可以识别这些自定义组件，并在 submit
      事件中返回组件的字段名及其对应字段值。

      详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-form-field-group][#]] wx://form-field-group


  
 

      从基础库版本 [[../compatibility.html][2.10.2]] 开始提供支持。

      使 form 组件可以识别到这个自定义组件内部的所有表单控件。

      详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-form-field-button][#]] wx://form-field-button


  
 

      从基础库版本 [[../compatibility.html][2.10.3]] 开始提供支持。

      使 form 组件可以识别到这个自定义组件内部的 button
      。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form
      接受。

      详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-component-export][#]] wx://component-export


  
 

      从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

      使自定义组件支持 =export= 定义段。这个定义段可以用于指定组件被
      =selectComponent= 调用时的返回值。

      详细用法以及代码示例可见：[[file:events][selectComponent 参考文档]]


 



 






      --------------


      [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html]]

      \\
      \\




 













      --------------


 










*** [[index_u80.html#组件间关系][#]] 组件间关系


  
 

**** [[index_u80.html#定义和使用组件间关系][#]] 定义和使用组件间关系


  
 

     有时需要实现这样的组件：





     #+BEGIN_EXAMPLE
         <custom-ul>
           <custom-li> item 1 </custom-li>
           <custom-li> item 2 </custom-li>
         </custom-ul>
     #+END_EXAMPLE





     这个例子中， =custom-ul= 和 =custom-li=
     都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入
     =relations= 定义段，可以解决这样的问题。示例：

     [[https://developers.weixin.qq.com/s/0kfvzKm56NZy][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         // path/to/custom-ul.js
         Component({
           relations: {
             './custom-li': {
               type: 'child', // 关联的目标节点应为子节点
               linked: function(target) {
                 // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
               },
               linkChanged: function(target) {
                 // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
               },
               unlinked: function(target) {
                 // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
               }
             }
           },
           methods: {
             _getAllLi: function(){
               // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
               var nodes = this.getRelationNodes('path/to/custom-li')
             }
           },
           ready: function(){
             this._getAllLi()
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // path/to/custom-li.js
         Component({
           relations: {
             './custom-ul': {
               type: 'parent', // 关联的目标节点应为父节点
               linked: function(target) {
                 // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
               },
               linkChanged: function(target) {
                 // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
               },
               unlinked: function(target) {
                 // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
               }
             }
           }
         })
     #+END_EXAMPLE





     *注意：必须在两个组件定义中都加入 relations 定义，否则不会生效。*

**** [[index_u80.html#关联一类组件][#]] 关联一类组件


  
 

     [[https://developers.weixin.qq.com/s/LFEVaqmh6zYU][在开发者工具中预览效果<<>>]]

     有时，需要关联的是一类组件，如：





     #+BEGIN_EXAMPLE
         <custom-form>
           <view>
             input
             <custom-input></custom-input>
           </view>
           <custom-submit> submit </custom-submit>
         </custom-form>
     #+END_EXAMPLE





     =custom-form= 组件想要关联 =custom-input= 和 =custom-submit=
     两个组件。此时，如果这两个组件都有同一个 behavior：





     #+BEGIN_EXAMPLE
         // path/to/custom-form-controls.js
         module.exports = Behavior({
           // ...
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // path/to/custom-input.js
         var customFormControls = require('./custom-form-controls')
         Component({
           behaviors: [customFormControls],
           relations: {
             './custom-form': {
               type: 'ancestor', // 关联的目标节点应为祖先节点
             }
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         // path/to/custom-submit.js
         var customFormControls = require('./custom-form-controls')
         Component({
           behaviors: [customFormControls],
           relations: {
             './custom-form': {
               type: 'ancestor', // 关联的目标节点应为祖先节点
             }
           }
         })
     #+END_EXAMPLE





     则在 =relations=
     关系定义中，可使用这个 behavior 来代替组件路径作为关联的目标节点：





     #+BEGIN_EXAMPLE
         // path/to/custom-form.js
         var customFormControls = require('./custom-form-controls')
         Component({
           relations: {
             'customFormControls': {
               type: 'descendant', // 关联的目标节点应为子孙节点
               target: customFormControls
             }
           }
         })
     #+END_EXAMPLE





**** [[index_u80.html#relations-定义段][#]] relations 定义段


  
 

     =relations= 定义段包含目标组件路径及其对应选项，可包含的选项见下表。





     | 选项          | 类型       | 是否必填   | 描述                                                                                                   |
     |---------------+------------+------------+--------------------------------------------------------------------------------------------------------|
     | type          | String     | 是         | 目标组件的相对关系，可选的值为 =parent= 、 =child= 、 =ancestor= 、 =descendant=                       |
     | linked        | Function   | 否         | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件 attached 生命周期之后                 |
     | linkChanged   | Function   | 否         | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件 moved 生命周期之后                  |
     | unlinked      | Function   | 否         | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件 detached 生命周期之后                       |



 



 



 






     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html]]

     \\
     \\




 













     --------------


 










*** [[index_u35.html#数据监听器][#]] 数据监听器


  
 

    数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本
    [[../compatibility.html][2.6.1]] 开始支持。

**** [[index_u35.html#使用数据监听器][#]] 使用数据监听器


  
 

     有时，在一些数据字段被 setData 设置时，需要执行一些操作。

     例如， =this.data.sum= 永远是 =this.data.numberA= 与 =this.data.numberB=
     的和。此时，可以使用数据监听器进行如下实现。





     #+BEGIN_EXAMPLE
         Component({
           attached: function() {
             this.setData({
               numberA: 1,
               numberB: 2,
             })
           },
           observers: {
             'numberA, numberB': function(numberA, numberB) {
               // 在 numberA 或者 numberB 被设置时，执行这个函数
               this.setData({
                 sum: numberA + numberB
               })
             }
           }
         })
     #+END_EXAMPLE





     [[https://developers.weixin.qq.com/s/FUZF9ams7g6N][在开发者工具中预览效果<<>>]]

**** [[index_u35.html#监听字段语法][#]] 监听字段语法


  
 

     数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData
     最多触发每个监听器一次。

     同时，监听器可以监听子数据字段，如下例所示。





     #+BEGIN_EXAMPLE
         Component({
           observers: {
             'some.subfield': function(subfield) {
               // 使用 setData 设置 this.data.some.subfield 时触发
               // （除此以外，使用 setData 设置 this.data.some 也会触发）
               subfield === this.data.some.subfield
             },
             'arr[12]': function(arr12) {
               // 使用 setData 设置 this.data.arr[12] 时触发
               // （除此以外，使用 setData 设置 this.data.arr 也会触发）
               arr12 === this.data.arr[12]
             },
           }
         })
     #+END_EXAMPLE





     如果需要监听所有子数据字段的变化，可以使用通配符 =**= 。





     #+BEGIN_EXAMPLE
         Component({
           observers: {
             'some.field.**': function(field) {
               // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
               // （除此以外，使用 setData 设置 this.data.some 也会触发）
               field === this.data.some.field
             },
           },
           attached: function() {
             // 这样会触发上面的 observer
             this.setData({
               'some.field': { /* ... */ }
             })
             // 这样也会触发上面的 observer
             this.setData({
               'some.field.xxx': { /* ... */ }
             })
             // 这样还是会触发上面的 observer
             this.setData({
               'some': { /* ... */ }
             })
           }
         })
     #+END_EXAMPLE





     特别地，仅使用通配符 =**= 可以监听全部 setData 。





     #+BEGIN_EXAMPLE
         Component({
           observers: {
             '**': function() {
               // 每次 setData 都触发
             },
           },
         })
     #+END_EXAMPLE





     *Bugs & Tips:*

     -  数据监听器监听的是 setData
       涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
     -  如果在数据监听器函数中使用 setData
       设置本身监听的数据字段，可能会导致死循环，需要特别留意。
     -  数据监听器和属性的 observer
       相比，数据监听器更强大且通常具有更好的性能。













     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html]]

     \\
     \\




 













     --------------


 










*** [[index_u48.html#纯数据字段][#]] 纯数据字段


  
 

    纯数据字段是一些不用于界面渲染的 data
    字段，可以用于提升页面更新性能。从小程序基础库版本
    [[../compatibility.html][2.8.2]] 开始支持。

**** [[index_u48.html#组件数据中的纯数据字段][#]] 组件数据中的纯数据字段


  
 

     有些情况下，某些 =data= 中的字段（包括 =setData=
     设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

     此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在
     =this.data= 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

     指定“纯数据字段”的方法是在 =Component= 构造器的 =options= 定义段中指定
     =pureDataPattern=
     为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

     [[https://developers.weixin.qq.com/s/DKWiBXmb7jaB][在开发者工具中预览效果<<>>]]

     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           options: {
             pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
           },
           data: {
             a: true, // 普通数据字段
             _b: true, // 纯数据字段
           },
           methods: {
             myMethod() {
               this.data._b // 纯数据字段可以在 this.data 中获取
               this.setData({
                 c: true, // 普通数据字段
                 _d: true, // 纯数据字段
               })
             }
           }
         })
     #+END_EXAMPLE





     上述组件中的纯数据字段不会被应用到 WXML 上：





     #+BEGIN_EXAMPLE
         <view wx:if="{{a}}"> 这行会被展示 </view>
         <view wx:if="{{_b}}"> 这行不会被展示 </view>
     #+END_EXAMPLE





**** [[index_u48.html#组件属性中的纯数据字段][#]] 组件属性中的纯数据字段


  
 

     属性也可以被指定为纯数据字段（遵循 =pureDataPattern= 的正则表达式）。

     属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的
     WXML 中。

     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           options: {
             pureDataPattern: /^_/
           },
           properties: {
             a: Boolean,
             _b: {
               type: Boolean,
               observer() {
                 // 不要这样做！这个 observer 永远不会被触发
               }
             },
           }
         })
     #+END_EXAMPLE





     注意：属性中的纯数据字段的属性 observer
     永远不会触发！如果想要监听属性值变化，使用
     [[file:observer.html][数据监听器]] 代替。

     从小程序基础库版本 [[../compatibility.html][2.10.1]]
     开始，也可以在页面或自定义组件的 json 文件中配置 =pureDataPattern=
     （这样就不需在 js 文件的 =options=
     中再配置）。此时，其值应当写成字符串形式：





     #+BEGIN_EXAMPLE
         {
           "pureDataPattern": "^_"
         }
     #+END_EXAMPLE





**** [[index_u48.html#使用数据监听器监听纯数据字段][#]]
     使用数据监听器监听纯数据字段


  
 

     [[file:observer.html][数据监听器]]
     可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

     下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

     [[https://developers.weixin.qq.com/s/fcWA1Xmd7tak][在开发者工具中预览效果<<>>]]

     *代码示例：*





     #+BEGIN_EXAMPLE
         Component({
           options: {
             pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
           },
           properties: {
             timestamp: Number,
           },
           observers: {
             timestamp: function () {
               // timestamp 被设置时，将它展示为可读时间字符串
               var timeString = new Date(this.data.timestamp).toLocaleString()
               this.setData({
                 timeString: timeString
               })
             }
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         <view>{{timeString}}</view>
     #+END_EXAMPLE

















     --------------


     [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html]]

     \\
     \\




 













     --------------


 










*** [[index_u28.html#抽象节点][#]] 抽象节点


  
 

    这个特性自小程序基础库版本 [[../compatibility.html][1.9.6]] 开始支持。

**** [[index_u28.html#在组件中使用抽象节点][#]] 在组件中使用抽象节点


  
 

     有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

     例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的
     wxml 可以这样编写：

     *代码示例：*

     [[https://developers.weixin.qq.com/s/ztPzoImW7E7P][在开发者工具中预览效果<<>>]]





     #+BEGIN_EXAMPLE
         <!-- selectable-group.wxml -->
         <view wx:for="{{labels}}">
           <label>
             <selectable disabled="{{false}}"></selectable>
             {{item}}
           </label>
         </view>
     #+END_EXAMPLE





     其中，“selectable”不是任何在 json 文件的 =usingComponents=
     字段中声明的组件，而是一个抽象节点。它需要在 =componentGenerics=
     字段中声明：





     #+BEGIN_EXAMPLE
         {
           "componentGenerics": {
             "selectable": true
           }
         }
     #+END_EXAMPLE





**** [[index_u28.html#使用包含抽象节点的组件][#]] 使用包含抽象节点的组件


  
 

     在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件：





     #+BEGIN_EXAMPLE
         <selectable-group generic:selectable="custom-radio" />
     #+END_EXAMPLE





     这样，在生成这个 selectable-group
     组件的实例时，“selectable”节点会生成“custom-radio”组件实例。类似地，如果这样使用：





     #+BEGIN_EXAMPLE
         <selectable-group generic:selectable="custom-checkbox" />
     #+END_EXAMPLE





     “selectable”节点则会生成“custom-checkbox”组件实例。

     注意：上述的 =custom-radio= 和 =custom-checkbox= 需要包含在这个 wxml
     对应 json 文件的 =usingComponents= 定义段中。





     #+BEGIN_EXAMPLE
         {
           "usingComponents": {
             "custom-radio": "path/to/custom/radio",
             "custom-checkbox": "path/to/custom/checkbox"
           }
         }
     #+END_EXAMPLE





**** [[index_u28.html#抽象节点的默认组件][#]] 抽象节点的默认组件
     抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在
     =componentGenerics= 字段中指定：

     #+BEGIN_EXAMPLE
         {
           "componentGenerics": {
             "selectable": {
               "default": "path/to/default/component"
             }
           }
         }
     #+END_EXAMPLE
     *Tips:*

     -  节点的 generic 引用 =generic:xxx="yyy"= 中，值 =yyy=
       只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。


*** [[index_u8.html#自定义组件扩展][#]] 自定义组件扩展
**** [[index_u8.html#扩展后的效果][#]] 扩展后的效果

     #+BEGIN_EXAMPLE
         // behavior.js
         module.exports = Behavior({
           definitionFilter(defFields) {
             defFields.data.from = 'behavior'
           },
         })

         // component.js
         Component({
           data: {
             from: 'component'
           },
           behaviors: [require('behavior.js')],
           ready() {
             console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
           }
         })
     #+END_EXAMPLE





     通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，上述例子就是修改了自定义组件中的
     =data= 定义段里的内容。

**** [[index_u8.html#使用扩展][#]] 使用扩展
     =Behavior()= 构造器提供了新的定义段 =definitionFilter=，用于支持自定义组件扩展。
     =definitionFilter=是一个函数，在被调用时会注入两个参数，第一个参数是使用该
     behavior 的component/behavior 的定义对象，第二个参数是该 behavior 所使用的
     behavior的 =definitionFilter= 函数列表。

     以下举个例子来说明：





     #+BEGIN_EXAMPLE
         // behavior3.js
         module.exports = Behavior({
             definitionFilter(defFields, definitionFilterArr) {},
         })

         // behavior2.js
         module.exports = Behavior({
           behaviors: [require('behavior3.js')],
           definitionFilter(defFields, definitionFilterArr) {
             // definitionFilterArr[0](defFields)
           },
         })

         // behavior1.js
         module.exports = Behavior({
           behaviors: [require('behavior2.js')],
           definitionFilter(defFields, definitionFilterArr) {},
         })

         // component.js
         Component({
           behaviors: [require('behavior1.js')],
         })
     #+END_EXAMPLE





     上述代码中声明了 1 个自定义组件和 3 个 behavior，每个 behavior 都使用了
     =definitionFilter= 定义段。那么按照声明的顺序会有如下事情发生：

     1. 当进行 behavior2 的声明时就会调用 behavior3 的 =definitionFilter=
        函数，其中 =defFields= 参数是 behavior2 的定义段，
        =definitionFilterArr= 参数即为空数组，因为 behavior3 没有使用其他的
        behavior 。
     2. 当进行 behavior1 的声明时就会调用 behavior2 的 =definitionFilter=
        函数，其中 =defFields= 参数是 behavior1 的定义段，
        =definitionFilterArr=
        参数是一个长度为 1 的数组，=definitionFilterArr[0]= 即为 behavior3 的
        =definitionFilter= 函数，因为 behavior2 使用了
        behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用
        behavior3 的 =definitionFilter= 函数，如果需要调用，在此处补充代码
        =definitionFilterArr[0](defFields)= 即可，=definitionFilterArr=
        参数会由基础库补充传入。
     3. 同理，在进行 component 的声明时就会调用 behavior1 的
        =definitionFilter= 函数。

     简单概括，=definitionFilter= 函数可以理解为当 A 使用了 B 时，A
     声明就会调用 B 的 =definitionFilter= 函数并传入 A 的定义对象让 B
     去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和
     D 的 =definitionFilter= 函数去过滤 A 的定义对象。

     *代码示例：*

     [[https://developers.weixin.qq.com/s/WaqPbxmN7E1j][在开发者工具中预览效果<<>>]]

**** [[index_u8.html#真实案例][#]] 真实案例


  
 

     下面利用扩展简单实现自定义组件的计算属性功能:





     #+BEGIN_EXAMPLE
         // behavior.js
         module.exports = Behavior({
           lifetimes: {
             created() {
               this._originalSetData = this.setData // 原始 setData
               this.setData = this._setData // 封装后的 setData
             }
           },
           definitionFilter(defFields) {
             const computed = defFields.computed || {}
             const computedKeys = Object.keys(computed)
             const computedCache = {}

             // 计算 computed
             const calcComputed = (scope, insertToData) => {
               const needUpdate = {}
               const data = defFields.data = defFields.data || {}

               for (let key of computedKeys) {
                 const value = computed[key].call(scope) // 计算新值
                 if (computedCache[key] !== value) needUpdate[key] = computedCache[key] = value
                 if (insertToData) data[key] = needUpdate[key] // 直接插入到 data 中，初始化时才需要的操作
               }

               return needUpdate
             }

             // 重写 setData 方法
             defFields.methods = defFields.methods || {}
             defFields.methods._setData = function (data, callback) {
               const originalSetData = this._originalSetData // 原始 setData
               originalSetData.call(this, data, callback) // 做 data 的 setData
               const needUpdate = calcComputed(this) // 计算 computed
               originalSetData.call(this, needUpdate) // 做 computed 的 setData
             }

             // 初始化 computed
             calcComputed(defFields, true) // 计算 computed
           }
         })
     #+END_EXAMPLE





     在组件中使用：





     #+BEGIN_EXAMPLE
         const beh = require('./behavior.js')
         Component({
           behaviors: [beh],
           data: {
             a: 0,
           },
           computed: {
             b() {
               return this.data.a + 100
             },
           },
           methods: {
             onTap() {
               this.setData({
                 a: ++this.data.a,
               })
             }
           }
         })
     #+END_EXAMPLE









     #+BEGIN_EXAMPLE
         <view>data: {{a}}</view>
         <view>computed: {{b}}</view>
         <button bindtap="onTap">click</button>
     #+END_EXAMPLE





     实现原理很简单，对已有的 setData 进行二次封装，在每次 setData
     的时候计算出 computed 里各字段的值，然后设到 data
     中，已达到计算属性的效果。

     #+BEGIN_QUOTE
     此实现只是作为一个简单案例来展示，请勿直接在生产环境中使用。
     #+END_QUOTE


*** [[index_u11.html#获取更新性能统计信息][#]] 获取更新性能统计信息
    如果想要知道 setData引发界面更新的开销，可以使用更新性能统计信息接口。它将返回
    每次更新中主要更新步骤发生的时间戳，可以用来大体上估计自定义组件（或页面）更新
    性能。例如：

    #+BEGIN_EXAMPLE
        Component({
          attached() { // 调用时机不能早于 attached
            this.setUpdatePerformanceListener({withDataPaths: true}, (res) => {
              console.log(res)
            })
          }
        })
    #+END_EXAMPLE

    =setUpdatePerformanceListener= 方法接受一个 =options= 对象和回调函数=listener=
    作为参数。

    其中， =options= 对象包含以下字段：





    | 字段            | 类型      | 说明                           |
    |-----------------+-----------+--------------------------------|
    | withDataPaths   | Boolean   | 是否返回变更的 data 字段信息   |





    =listeners= 返回携带一个 =res= 对象，表示一次由 setData 引发的
    *更新过程* 。根据 setData 调用时机的不同，更新过程大体可以分为三类：

    1. *基本更新* ，它有一个唯一的 =updateProcessId= ；
    2. *子更新* ，它是另一个基本更新的一个子步骤，也有唯一的
       =updateProcessId= ，但还有一个 =parentUpdateProcessId= ；
    3. *被合并更新*
       ，它被合并到了另一个基本更新或子更新过程中，无法被独立统计。

    每次成功的 setData 调用都会产生一个更新过程，使得 =listener=
    回调一次。不过 setData
    究竟触发了哪类更新过程很难判断，更新性能好坏与其具体是哪类更新也没有必然联系，只是它们的返回值参数有所不同。

    =res= 中包含以下字段：





    | 字段                    | 类型      | 说明                                                                       |
    |-------------------------+-----------+----------------------------------------------------------------------------|
    | updateProcessId         | Number    | 此次更新过程的 ID                                                          |
    | parentUpdateProcessId   | Number    | 对于子更新，返回它所属的更新过程 ID                                        |
    | isMergedUpdate          | Boolean   | 是否是被合并更新，如果是，则 =updateProcessId= 表示被合并到的更新过程 ID   |
    | dataPaths               | Array     | 此次更新的 data 字段信息，只有 =withDataPaths= 设为 =true= 时才会返回      |
    | pendingStartTimestamp   | Number    | 此次更新进入等待队列时的时间戳                                             |
    | updateStartTimestamp    | Number    | 更新运算开始时的时间戳                                                     |
    | updateEndTimestamp      | Number    | 更新运算结束时的时间戳                                                     |





    说明：

    -  =setUpdatePerformanceListener= 只会激活当前组件或页面的统计，
      =parentUpdateProcessId= 有可能是其他组件或者页面的更新过程 ID
      而未被统计回调，如果想要知道页面内所有的更新过程，需要在所有组件中都调用
      =setUpdatePerformanceListener= ；
    -  统计本身有一点点开销，如果想要禁用统计，调用
      =setUpdatePerformanceListener= 时传入第二个参数 =listener= 为 =null=
      即可。













    --------------


    [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/update-perf-stat.html]]

    \\
    \\


















    --------------


* 详解微信小程序开发
**  *五、基础文件目录详解*
   project.config.json: 小程序的配置文件，包含项目打包配置、上传代码自动压缩等等，是一些开发、打包之类的配置。

app.json: 当前项目的配置文件。包括项目的页面引入、导航条颜色、导航条标题 等等，是项目具体到代码开发上的配置。介绍几个配置：

pages： 包含的页面。每次新增页面都得在这里引入，否则新页面的 json 配置等无法生效。 注意 pages 中页面先写的先渲染，所以数组第一条也就是我们的首页。

window： 配置所有页面导航条字体、颜色、背景色等

app.js: 小程序入口文件。生成小程序实例，App({}), 通常在这获取用户信息、授权信息、定义全局变量等。

app.wxss: 小程序全局 style 文件。对整个项目页面生效。通常规定项目的 字体、基础颜色，定义一些公共样式。

utils: 工具函数目录。通常用来放一些公共的 js 方法。比如封装的 request 请求，一些别的处理数据什么的方法。

pages: 小程序的页面目录。所有的小程序页面，都写在这里面。

**  *六、完善项目目录*
   上边大致解释了一下小程序的基础文件，现在按照常见的规范完善一下项目目录，这里
   面包含一些个人见解，有需要的参考即可。先看一下结果：

现在解释一下这些目录：
components： 我们封装的小程序可复用组件。
constants： 一些项目中的常亮。
image： 用到的图片。
services： 用到的所有接口目录

大致就新建了这几个，如果有别的需求，根据自己的情况增加。

** *八、实现页面跳转*
   和通常的 web 开发一样，小程序页面跳转页分 2 中，wxml 中的 vavigator 标签，以
   及 js 的 navigator 相关的 api。路由跳转的方法有好几个，这里不一一赘述了，常用
   的直接跳转

#+BEGIN_EXAMPLE
    wx.navigateTo，重定向 wx.redirectTo等等，具体的请看官方文档。这里强调一下路由传参，很简单： 
    1、少量数据。直接问号传参。然后在目标页面的onLoad方法中通过options参数接收。 
    2、大量数据。直接塞到全局变量里面。
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     //  wxml跳转页面
          {{item.name}}
           
     // js跳转页面
     wx.navigateTo({
          url: `/pages/my/appointDetail/index?_id=${ this .data.marker.id}`
        }) 
     
    //路由传参如何接收 
onLoad: function (options) {
　　 console.log(options)
},

#+END_EXAMPLE

** *九、wx.request 的封装*
 在 utils 中新建 request.js，简单封装了一下，一些数据要全局配置的都引进来，然后
 做了些错误的统一处理，没什么难度， 不过要特别注意一下 cookie 的携带。具体代码如
 下：

 #+BEGIN_EXAMPLE
     const app =  getApp()
     export  default  function request(url, options =  {}) {
        return  new Promise( function  (resolve, reject) {
         wx.request({
           url: `${app.origin}${url}`,
           method: 'GET' ,
           ...options,
           data: options.data,
           header: {
             'content-type': 'application/json' ,
             'cookie': wx.getStorageSync("cookie" )
           },
           success:  function  (res) {
              // 重新授权登录
              if (res.statusCode === 401 ){ 
               wx.redirectTo({url: '/pages/login/index' })
                return 
             } else  if (res.statusCode !== 200 ) { 
               reject({ error: '服务器忙，请稍后重试', code: 500  });
                return 
             }  else  {
                if (url === '/api/cdz/user/weixin/login' ) {
                 const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"]; 
     　　　　　　　　
                  if (cookie) wx.setStorageSync("cookie" , cookie);
               }
               resolve(res.data);
             }
           },
           fail:  function  (res) {
              //  fail调用接口失败
              if (url === '/api/cdz/user/weixin/login' ) {
               const cookie = res.header["set-cookie" ] || res.header["Set-Cookie"];
                if (cookie) wx.setStorageSync("cookie" , cookie);
             } 
             reject({ error: '网络错误', code: 0  });
           }
         })
       })
     }
 #+END_EXAMPLE

然后我们使用的时候直接使用封装好的 request 方法，这样所有的 api 就封装成一个个函数。我们在页面中直接 import 引入调用即可。

 #+BEGIN_EXAMPLE
     import request from "../utils/request" ;
     import { stringify } from "../utils/util" 

     export  function  testPost(data) {
        return request(`/api/test/post`, {
         method: 'PUT' ,
         data,
       })
     }

     export  function  testGet(data) {
        return request(`/api/test/get`)
     }
 #+END_EXAMPLE

** *十、使用 npm （引入 weui、moment 等插件）*
因为小程序使用的是不完整的浏览器对象，所以很多 js 包都是不好使的，比如 jquery
之类的。所以 npm 基本是废了，能用的依赖包很少，具体哪些能用得自己发掘了。这里还
是要介绍一下小程序如何使用 npm，毕竟有些包还是要用的。

1、打开 微信开发者工具 -- 点击 详情 -- 勾选 使用 npm 模块
2、打开命令行，进入项目的根目录下， npm init 初始化 npm
3、npm i 。。。安装你需要的依赖
4、打开 微信开发者工具 -- 点击 工具 -- 点击 构建 npm。 此时小程序会将 node_modules 文件编译打包，生成新目录 miniprogram_npm ，
5、在需要用到的页面的 js 文件中，const moment= require('moment') 引入，直接使用即可
6、最后记得忽略文件。新建 .gitignore 文件，node_modules 、 package_lock.json 等文件不需要上传，最好只保留小程序的 npm 构建包，用什么依赖也是的那个下载。这个到不是必须的
 
　　ps: 特殊注意一下 weui 的引入，这个 ui 库是纯 css 的，没有 js 文件，所以他没法用 npm 引入，而是直接下载文件，我直接丢到根目录下，然后在 app.wxss 文件的开头引入

#+BEGIN_EXAMPLE
@import 'weui.wxss';，这样使用的
#+END_EXAMPLE

* 组件和 api
** 组件
   - [view](https://mp.weixin.qq.com/debug/wxadoc/dev/component/view.html)
   - [scroll-view](https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html)
   - [swiper](https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html)

   - [icon](https://mp.weixin.qq.com/debug/wxadoc/dev/component/icon.html)
   - [text](https://mp.weixin.qq.com/debug/wxadoc/dev/component/text.html)
   - [progress](https://mp.weixin.qq.com/debug/wxadoc/dev/component/progress.html)

   ### 表单组件

   - [button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/button.html)
   - [checkbox](https://mp.weixin.qq.com/debug/wxadoc/dev/component/checkbox.html)
   - [form](https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html)
   - [input](https://mp.weixin.qq.com/debug/wxadoc/dev/component/input.html)
   - [label](https://mp.weixin.qq.com/debug/wxadoc/dev/component/label.html)
   - [picker](https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html)
   - [radio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/radio.html)
   - [slider](https://mp.weixin.qq.com/debug/wxadoc/dev/component/slider.html)
   - [switch](https://mp.weixin.qq.com/debug/wxadoc/dev/component/switch.html)
   - [textarea](https://mp.weixin.qq.com/debug/wxadoc/dev/component/textarea.html)

   ### 导航

   - [navigator](https://mp.weixin.qq.com/debug/wxadoc/dev/component/navigator.html)

   ### 媒体组件

   - [audio](https://mp.weixin.qq.com/debug/wxadoc/dev/component/audio.html)
   - [image](https://mp.weixin.qq.com/debug/wxadoc/dev/component/image.html)
   - [video](https://mp.weixin.qq.com/debug/wxadoc/dev/component/video.html)

   ### 地图

   - [map](hhttps://mp.weixin.qq.com/debug/wxadoc/dev/component/map.html%20#map)

   ### 画布

   - [canvas](https://mp.weixin.qq.com/debug/wxadoc/dev/component/canvas.html)

   ### 客服会话

   - [contact-button](https://mp.weixin.qq.com/debug/wxadoc/dev/component/contact-button.html)

** api
   ## [API](https://mp.weixin.qq.com/debug/wxadoc/dev/api/)

   ### [网络](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-network.html)

   #### [发起请求](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html)

   - `wx.request`   `wx.request` 发起的是 HTTPS 请求

   #### [上传、下载](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-file.html)

   - `wx.uploadFile`   将本地资源上传到开发者服务器
   - `wx.downloadFile` 下载文件资源到本地

   #### [WebSocket](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

   - `wx.connectSocket`  创建一个 WebSocket 连接
   - `wx.onSocketOpen`   监听 WebSocket 连接打开事件
   - `wx.onSocketError`  监听 WebSocket 错误
   - `wx.sendSocketMessage`  通过 WebSocket 连接发送数据
   - `wx.onSocketMessage`  监听 WebSocket 接受到服务器的消息事件
   - `wx.closeSocket`    关闭 WebSocket 连接
   - `wx.onSocketClose`  监听 WebSocket 关闭

   ### [媒体](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)

   #### [图片](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-picture.html)

   - `wx.chooseImage`  从本地相册选择图片或使用相机拍照
   - `wx.previewImage` 预览图片
   - `wx.getImageInfo` 获取图片信息

   #### [录音](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-record.html)

   - `wx.startRecord`  开始录音
   - `wx.stopRecord`   主动调用停止录音

   #### [音频播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-voice.html)

   - `wx.playVoice`    开始播放语音
   - `wx.pauseVoice`   暂停正在播放的语音
   - `wx.stopVoice`    结束播放语音

   #### [音乐播放控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/media-background-audio.html)

   - `wx.getBackgroundAudioPlayerState`  获取音乐播放状态
   - `wx.playBackgroundAudio`  播放音乐，同时只能有一首音乐正在播放
   - `wx.pauseBackgroundAudio` 暂停播放音乐
   - `wx.seekBackgroundAudio`  控制音乐播放进度
   - `wx.stopBackgroundAudio`  停止播放音乐
   - `wx.onBackgroundAudioPlay`  监听音乐播放
   - `wx.onBackgroundAudioPause` 监听音乐暂停
   - `wx.onBackgroundAudioStop`  监听音乐停止

   #### [音频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

   - `wx.createAudioContext` 创建并返回 audio 上下文 `audioContext` 对象

   #### [视频](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

   - `wx.chooseVideo`  拍摄视频或从手机相册中选视频，返回视频的临时文件路径

   #### [视频组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

   - `wx.createVideoContext`  创建并返回 video 上下文 `videoContext` 对象

   ### [文件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html)

   - `wx.saveFile` 保存文件到本地
   - `wx.getSavedFileList` 获取本地已保存的文件列表
   - `wx.getSavedFileInfo` 获取本地文件的文件信息
   - `wx.removeSavedFile` 删除本地存储的文件
   - `wx.openDocument` 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx

   ### [数据缓存](https://mp.weixin.qq.com/debug/wxadoc/dev/api/data.html)

   - `wx.setStorage`   将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口
   - `wx.setStorageSync` 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口
   - `wx.getStorage`  从本地缓存中异步获取指定 key 对应的内容
   - `wx.getStorageSync` 从本地缓存中同步获取指定 key 对应的内容
   - `wx.getStorageInfo` 异步获取当前 storage 的相关信息
   - `wx.getStorageInfoSync` 同步获取当前 storage 的相关信息
   - `wx.removeStorage`  从本地缓存中异步移除指定 key
   - `wx.removeStorageSync`  从本地缓存中同步移除指定 key
   - `wx.clearStorage` 清理本地数据缓存
   - `wx.clearStorageSync` 同步清理本地数据缓存

   ### [位置](https://mp.weixin.qq.com/debug/wxadoc/dev/api/location.html)

   #### 获取位置

   - `wx.getLocation` 获取当前的地理位置、速度
   - `wx.chooseLocation` 打开地图选择位置

   #### 查看位置

   - `wx.openLocation` 使用微信内置地图查看位置

   #### [地图组件控制](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-map.html)

   - `wx.createMapContext` 创建并返回 map 上下文 mapContext 对象

   ### [设备](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)

   #### [系统信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/systeminfo.html)

   - `wx.getSystemInfo` 获取系统信息
   - `wx.getSystemInfoSync` 获取系统信息同步接口

   #### [网络状态](https://mp.weixin.qq.com/debug/wxadoc/dev/api/device.html)

   - `wx.getNetworkType` 获取网络类型

   #### [重力感应](https://mp.weixin.qq.com/debug/wxadoc/dev/api/accelerometer.html)

   - `wx.onAccelerometerChange`  监听重力感应数据，频率：5次/秒

   #### [罗盘](https://mp.weixin.qq.com/debug/wxadoc/dev/api/campass.html)

   - `wx.onCompassChange`  监听罗盘数据，频率：5次/秒

   #### [拨打电话](https://mp.weixin.qq.com/debug/wxadoc/dev/api/phonecall.html)

   - `wx.makePhoneCall`  拨打电话

   #### [扫码](https://mp.weixin.qq.com/debug/wxadoc/dev/api/scancode.html)

   - `wx.scanCode` 调起客户端扫码界面，扫码成功后返回对应的结果

   ### [界面](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)

   #### [交互反馈](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html)

   - `wx.showToast` 显示消息提示框
   - `wx.hideToast` 隐藏消息提示框
   - `wx.showModal` ​显示模态弹窗
   - `wx.showActionSheet` 显示操作菜单

   #### [设置导航条](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui.html)

   - `wx.setNavigationBarTitle` 动态设置当前页面的标题
   - `wx.showNavigationBarLoading` 在当前页面显示导航条加载动画
   - `wx.hideNavigationBarLoading` 隐藏导航条加载动画

   #### [导航](https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html)

   - `wx.navigateTo`  保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack` 可以返回到原页面
   - `wx.redirectTo` 关闭当前页面，跳转到应用内的某个页面
   - `wx.switchTab`  跳转到 `tabBar` 页面，并关闭其他所有非 `tabBar` 页面
   - `wx.navigateBack`  关闭当前页面，返回上一页面或多级页面。可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层

   #### [动画](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-animation.html)

   - `wx.createAnimation`  创建一个动画实例 `animation`。调用实例的方法来描述动画。最后通过动画实例的`export` 方法导出动画数据传递给组件的 `animation` 属性。
   - animation
   - 动画队列

   #### [绘图](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)

   - [简介 intro](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/intro.html)
   - [Canvas 坐标系](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/coordinates.html)
   - [渐变](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/gradient.html)
   - [API 接口索引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html)
   - [wx.createCanvasContext](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/create-canvas-context.html) 创建 canvas 绘图上下文（指定 canvasId）
   - [wx.canvasToTempFilePath](https://mp.weixin.qq.com/debug/wxadoc/dev/api/canvas/reference.html) 把当前画布的内容导出生成图片，并返回文件路径

   #### [下拉刷新](https://mp.weixin.qq.com/debug/wxadoc/dev/api/pulldown.html)

   - `Page.onPullDownRefresh` 在 `Page` 中定义 `onPullDownRefresh` 处理函数，监听该页面用户下拉刷新事件
   - `wx.stopPullDownRefresh` 停止当前页面下拉刷新

   ### [开放接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)

   #### [登录](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)

   - `wx.login` 调用接口获取登录凭证（code）进而换取用户登录态信息
   - `code` 换取 `session_key`
   - 登录态维护
     - 登录时序图
     - `wx.checkSession` 检查登陆态是否过期
   - [用户数据的签名验证和加解密](https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html)
     - 数据签名校验
     - 加密数据解密算法

   #### [用户信息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html)

   - `wx.getUserInfo` 获取用户信息，需要先调用 `wx.login` 接口说明
   - `UnionID` 机制说明

   #### [微信支付](https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html)

   - `wx.requestPayment` 发起微信支付

   #### [模板消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html)

   - 使用说明
   - 接口说明
     - 获取 access_token
     - 发送模板消息
     - 下发条件说明
     - 审核说明
     - 违规说明
     - 处罚说明

   #### 客服消息

   - [接收消息和事件](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/receive.html)
     - 文本消息
     - 图片消息
     - 进入会话事件
   - [发送客服消息](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/conversation.html)
   - [临时素材接口](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/material.html)
     - 获取临时素材
     - 新增临时素材
   - [接入指引](https://mp.weixin.qq.com/debug/wxadoc/dev/api/custommsg/callback_help.html)

   #### [分享](https://mp.weixin.qq.com/debug/wxadoc/dev/api/share.html)

   - Page.onShareAppMessage

   ----

   ## [工具](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html)

   ### [概览](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html)

   ### [程序调试](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/debug.html)

   - 模拟器
   - 调试工具
     - Wxml panel
     - Sources panel
     - Network panel
     - Appdata panel
     - Storage panel
     - Console panel
   - 小程序操作区
