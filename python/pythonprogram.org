#+TITLE: python 系统编程
#+DESCRIPTION: 
#+TAGS: 
#+CATEGORIES: 软件使用

* python 系统编程，python 为了跟系统交互，创建了接口，我们可以直接用
** 系统工具接口,操作系统 os 
*** 系统编程，涉及流，命令行参数，环境变量 
    系统编程需要导入自带的 sys,os 模块
    看看模块里都有哪些属性，方法 dir(MODULE),返回一个数组，统计有多少东西 len(dir(MODULE)) 
    os.path  是 os 中的嵌套模块，子模块嘛,具体的应该是类集。
    可以用 dir 看下系统模块的具体内容，有些还能执行下。
    
    显示模块搜索路径  sys.path
    # 显示加载的模块 print(sys.modules)

  | 环境变量 Shell variables         | os.environ                                                                 |
  | 运行程序 Running programs        | os.system, os.popen, os.execv, os.spawnv                                   |
  | 进程处理 Spawning processes      | os.fork, os.pipe, os.waitpid, os.kill                                      |
  | 文件描述 Descriptor files, locks | os.open, os.read, os.write                                                 |
  | 文件处理 File processing         | os.remove, os.rename, os.mkfifo, os.mkdir, os.rmdir                        |
  | 管理员工具 Administrative tools  | os.getcwd, os.chdir, os.chmod, os.getpid, os.listdir, os.access            |
  | 移植工具 Portability tools       | os.sep(文件路径分割符), os.pathsep(路径分隔符，看看 PATH 环境变量怎么设置的), os.curdir, os.path.split, os.path.join  |
  | 路径名称工具 Pathname tools      | os.path.exists('path'), os.path.isdir('path'), os.path.getsize('path')     |

  路径合理化 os.path.normpath
  绝对路径 abspath
  
  运行程序 
  os.system('python helloshell.py') # run a Python program

  把进程赋予变量
  output = os.popen('python helloshell.py').read()
  output

子进程模块 
import subprocess
  # 行分隔符
  print("%d"  % ord( os.linesep ))

*** python 为预处理文件,目录和目录树提供的工具
*** 处理并行的标准工具,进程,线程，队列，管道，信号等
*** 字符串操作
    屏蔽转义 os.path.getsize(r'C:\autoexec.bat')
**** 截断文本到文本行列表,去除换行符 splitlines  
     能识别的字符,都当做换行符，分隔  
     \n 换行
     \r 回程
     \r\n 回车+换行
     \v  或\x0b 行列表
     \f 或 \x0c 换页
     \x1c 文件分隔符
     \x1d 组分隔符
**** 截断文本，但不去除换行符 split 
     例子 
     #+begin_src python
       line = 'aaa\nbbb\nccc\n'

       >>> line.split('\n')
       ['aaa', 'bbb', 'ccc', '']

       >>> line.splitlines()
       ['aaa', 'bbb', 'ccc']
     #+end_src
**** 查找需要的字符串所在索引号  find
     str.find("hello")
     找不到，就返回 -1
**** 替换
     #+begin_src python
       #替换字符串的一部分
       r=mystr.replace("nice","很高兴")
       print(r)
     #+end_src
**** 字符串是否包含  "str1"  in "str2"
     返回布尔 
**** 是否 isappha,isdigit,
**** 大小转换
**** string 库
     string.ascii_lowercase
     whitespace 空格字符
     
*** 输入输出,输入输出是函数，不再是语句了,注意用法,不然报错
**** print 
     错误的用法  print  "hello,world"
     正确用法 print("hello","world") 用逗号的参数，拼接时会自动加一个空格
    
    模板 print("I'm %s. I'm %d year old" % ('Vamei', 99))
    字典输出 print("I'm %(name)s. I'm %(age)d year old" % {'name':'Vamei', 'age':99})
    
   - 格式符
     - %s    字符串 (采用 str()的显示)
     - %r    字符串 (采用 repr()的显示)
     - %c    单个字符
     - %b    二进制整数
     - %d    十进制整数
     - %i    十进制整数
     - %o    八进制整数
     - %x    十六进制整数
     - %e    指数 (基底写为 e)
     - %E    指数 (基底写为 E)
     - %f    浮点数
     - %F    浮点数，与上相同
     - %g    指数(e) 或浮点数 (根据显示长度)
     - %G    指数(E)或浮点数 (根据显示长度)
     - %%    字符"%"

 
   - 对格式进行进一步的控制： %[(name)][flags][width].[precision]typecode
     - (name)为命名
     - flags 可以有+,-,' '或 0。+表示右对齐。-表示左对齐。' '为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用 0 填充。
     - width 表示显示宽度
     - precision 表示小数点后精度

   - 比如：
     -print("%+10x" % 10)
     -print("%04d" % 5)
     -print("%6.3f" % 2.3)

** 进程  
*** 线程与进程 
*** 进程
    Python 中的多线程其实并不是真正的多线程，如果想要充分地使用多核 CPU 的资源，在
    Python 中大部分情况需要使用多进程。Python 提供了非常好用的多进程包
    multiprocessing，只需要定义一个函数，Python 会完成其他所有事情。借助这个包，可以
    轻松完成从单进程到并发执行的转换。multiprocessing 支持子进程、通信和共享数据、执
    行不同形式的同步，提供了 Process、Queue、Pipe、Lock 等组件。
**** 类 Process
*****  创建进程的类：`Process([group [, target [, name [, args [, kwargs]]]]])`
      target 表示调用对象
      args 表示调用对象的位置参数元组
      kwargs 表示调用对象的字典
      name 为别名
      group 实质上不使用

    下面看一个创建函数并将其作为多个进程的例子：
  #+begin_src python

    #!/usr/bin/env python3
    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    def worker(interval, name):
        print(name + '【start】')
        time.sleep(interval)
        print(name + '【end】')


    if __name__ == "__main__":
        p1 = multiprocessing.Process(target=worker, args=(2, '两点水 1'))
        p2 = multiprocessing.Process(target=worker, args=(3, '两点水 2'))
        p3 = multiprocessing.Process(target=worker, args=(4, '两点水 3'))

        p1.start()
        p2.start()
        p3.start()

        print("The number of CPU is:" + str(multiprocessing.cpu_count()))
        for p in multiprocessing.active_children():
            print("child   p.name:" + p.name + "\tp.id" + str(p.pid))
        print("END!!!!!!!!!!!!!!!!!")

  #+end_src
***** 把进程创建成类
    当然我们也可以把进程创建成一个类，如下面的例子，当进程 p 调用 start() 时，自
    动调用 run() 方法。

  #+begin_src python

    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    class ClockProcess(multiprocessing.Process):
        def __init__(self, interval):
            multiprocessing.Process.__init__(self)
            self.interval = interval

        def run(self):
            n = 5
            while n > 0:
                print("当前时间: {0}".format(time.ctime()))
                time.sleep(self.interval)
                n -= 1


    if __name__ == '__main__':
        p = ClockProcess(3)
        p.start()

  #+end_src
***** daemon 属性

    想知道 daemon 属性有什么用，看下下面两个例子吧，一个加了 daemon 属性，一个没有加，对比输出的结果：

    没有加 deamon 属性的例子：

  #+begin_src python
    # -*- coding: UTF-8 -*-
    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.start()
        print('【EMD】')

  #+end_src
    输出结果：

    ```txt
    【EMD】
    工作开始时间：Mon Oct  9 17:47:06 2017
    工作结果时间：Mon Oct  9 17:47:09 2017
    ```

    在上面示例中，进程 p 添加 daemon 属性：

    ```python
    # -*- coding: UTF-8 -*-

    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.daemon = True
        p.start()
        print('【EMD】')
    ```

    输出结果：

    ```txt
    【EMD】
    ```


    根据输出结果可见，如果在子进程中添加了 daemon 属性，那么当主进程结束的时候，子
    进程也会跟着结束。所以没有打印子进程的信息。
***** join 方法
    结合上面的例子继续，如果我们想要让子线程执行完该怎么做呢？
    那么我们可以用到 join 方法，join 方法的主要作用是：阻塞当前进程，直到调用 join 方法的那个进程执行完，再继续执行当前进程。
    因此看下加了 join 方法的例子：

  #+begin_src python
    import multiprocessing
    import time


    def worker(interval):
        print('工作开始时间：{0}'.format(time.ctime()))
        time.sleep(interval)
        print('工作结果时间：{0}'.format(time.ctime()))


    if __name__ == '__main__':
        p = multiprocessing.Process(target=worker, args=(3,))
        p.daemon = True
        p.start()
        p.join()
        print('【EMD】')
  #+end_src
    输出的结果：

    ```txt
    工作开始时间：Tue Oct 10 11:30:08 2017
    工作结果时间：Tue Oct 10 11:30:11 2017
    【EMD】
    ```
***** Pool

    如果需要很多的子进程，难道我们需要一个一个的去创建吗？

    当然不用，我们可以使用进程池的方法批量创建子进程。

    例子如下：

    ```python
    # -*- coding: UTF-8 -*-

    from multiprocessing import Pool
    import os, time, random


    def long_time_task(name):
        print('进程的名称：{0} ；进程的 PID: {1} '.format(name, os.getpid()))
        start = time.time()
        time.sleep(random.random() * 3)
        end = time.time()
        print('进程 {0} 运行了 {1} 秒'.format(name, (end - start)))


    if __name__ == '__main__':
        print('主进程的 PID：{0}'.format(os.getpid()))
        p = Pool(4)
        for i in range(6):
            p.apply_async(long_time_task, args=(i,))
        p.close()
        # 等待所有子进程结束后在关闭主进程
        p.join()
        print('【End】')
    ```

    输出的结果如下：

    ```txt
    主进程的 PID：7256
    进程的名称：0；进程的 PID: 1492
    进程的名称：1；进程的 PID: 12232
    进程的名称：2；进程的 PID: 4332
    进程的名称：3；进程的 PID: 11604
    进程 2 运行了 0.6500370502471924 秒
    进程的名称：4；进程的 PID: 4332
    进程 1 运行了 1.0830621719360352 秒
    进程的名称：5；进程的 PID: 12232
    进程 5 运行了 0.029001712799072266 秒
    进程 4 运行了 0.9720554351806641 秒
    进程 0 运行了 2.3181326389312744 秒
    进程 3 运行了 2.5331451892852783 秒
    【End】
    ```

    这里有一点需要注意： `Pool` 对象调用 `join()` 方法会等待所有子进程执行完毕，调
    用 `join()` 之前必须先调用 `close()` ，调用`close()` 之后就不能继续添加新的
    Process 了。

    请注意输出的结果，子进程 0，1，2，3 是立刻执行的，而子进程 4 要等待前面某个子
    进程完成后才执行，这是因为 Pool 的默认大小在我的电脑上是 4，因此，最多同时执行
    4 个进程。这是 Pool 有意设计的限制，并不是操作系统的限制。如果改成：

    ```python
    p = Pool(5)
    ```

    就可以同时跑 5 个进程。
***** 进程间通信

    Process 之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python
    的 multiprocessing 模块包装了底层的机制，提供了 Queue、Pipes 等多种方式来交换
    数据。

    以 Queue 为例，在父进程中创建两个子进程，一个往 Queue 里写数据，一个从 Queue 里读数据：

    ```python
    #!/usr/bin/env python3
    # -*- coding: UTF-8 -*-

    from multiprocessing import Process, Queue
    import os, time, random


    def write(q):
        # 写数据进程
        print('写进程的 PID:{0}'.format(os.getpid()))
        for value in ['两点水', '三点水', '四点水']:
            print('写进 Queue 的值为：{0}'.format(value))
            q.put(value)
            time.sleep(random.random())


    def read(q):
        # 读取数据进程
        print('读进程的 PID:{0}'.format(os.getpid()))
        while True:
            value = q.get(True)
            print('从 Queue 读取的值为：{0}'.format(value))


    if __name__ == '__main__':
        # 父进程创建 Queue，并传给各个子进程
        q = Queue()
        pw = Process(target=write, args=(q,))
        pr = Process(target=read, args=(q,))
        # 启动子进程 pw
        pw.start()
        # 启动子进程 pr
        pr.start()
        # 等待 pw 结束:
        pw.join()
        # pr 进程里是死循环，无法等待其结束，只能强行终止
        pr.terminate()

    ```

    输出的结果为：

    ```txt
    读进程的 PID:13208
    写进程的 PID:10864
    写进 Queue 的值为：两点水
    从 Queue 读取的值为：两点水
    写进 Queue 的值为：三点水
    从 Queue 读取的值为：三点水
    写进 Queue 的值为：四点水
    从 Queue 读取的值为：四点水
    ```
** CGI 对象
*** Web 服务器支持及配置
    指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示：
    #+begin_src conf
      <Directory "/var/www/cgi-bin">
      AllowOverride None
      Options +ExecCGI
      Order allow,deny
      Allow from all
      </Directory>
      #+end_src

    在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：
    添加响应
    AddHandler cgi-script .cgi .pl .py
    
    激活模块 sudo a2enmod cgi
    

或者放一起

    #+begin_src conf
    <Directory /srv/www/yoursite/public_html>
        Options +ExecCGI
        AddHandler cgi-script .py
    </Directory>
    #+end_src
    
*** 创建 CGI 程序
#+begin_src python
  #!/usr/bin/python
  # -*- coding: UTF-8 -*-

  print "Content-type:text/html"
  print                               # 空行，告诉服务器结束头部
  print '<html>'
  print '<head>'
  print '<meta charset="utf-8">'
  print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
  print '</head>'
  print '<body>'
  print '<h2>Hello Word! 我是来自菜鸟教程的第一 CGI 程序</h2>'
  print '</body>'
  print '</html>'
#+end_src

文件保存后修改 hello.py，修改文件权限为 755：
chmod 755 hello.py 
*** CGI 环境变量
: 所有的 CGI 程序都接收以下的环境变量，这些变量在 CGI 程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的 MIME 类型。目前，环境变量 CONTENT_TYPE 一般都是：application/x-www-form-urlencoded,他表示数据来自于 HTML 表单。
CONTENT_LENGTH	如果服务器与 CGI 程序信息的传递方式是 POST，这个环境变量即使从标准输入 STDIN 中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在 CGI 程序名之后的其他路径信息。它常常作为 CGI 程序的参数出现。
QUERY_STRING	如果服务器与 CGI 程序信息的传递方式是 GET，这个环境变量的值即使所传递的信息。这个信息经跟在 CGI 程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的 IP 地址，例如上面的 192.168.1.67。这个值总是存在的。而且它是 Web 客户机需要提供给 Web 服务器的唯一标识，可以在 CGI 程序中用它来区分不同的 Web 客户机。
REMOTE_HOST	这个环境变量的值包含发送 CGI 请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI 脚本的完整路径
SCRIPT_NAME	CGI 脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或 IP 地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用 CGI 程序的 HTTP 服务器的名称和版本号。例如，上面的值为 Apache/2.2.14(Unix)
** 网络对象
***  低级别的网络服务支持基本的 Socket
    它提供了标准的 BSD Sockets API，可以访问底层操作系统 Socket 接口的全部方法。
***  高级别的网络服务模块 SocketServer
    它提供了服务器中心类，可以简化网络服务器的开发。
** 正则表达式
   比如在一段字符串中寻找是否含有某个字符或某些字符，通常我们使用内置函数来实现，
   如下：

 ```python
 re.findall(pattern, string[, flags])
 ```

 该函数实现了在字符串中找到正则表达式所匹配的所有子串，并组成一个列表返回,具体操作如下：

 ```python

 import re

 # 设定一个常量
 a = '两点水|twowater|liangdianshui|草根程序员|ReadingWithU'

 # 正则表达式

 findall = re.findall('两点水', a)
 print(findall)

 if len(findall) > 0:
     print('a 含有“两点水”这个字符串')
 else:
     print('a 不含有“两点水”这个字符串')

 ```

 输出的结果：

 ```txt
 ['两点水']
 a 含有“两点水”这个字符串
 ```

 从输出结果可以看到，可以实现和内置函数一样的功能，可是在这里也要强调一点，上面这
 个例子只是方便我们理解正则表达式，这个正则表达式的写法是毫无意义的。为什么这样说
 呢？

 因为用 Python 自带函数就能解决的问题，我们就没必要使用正则表达式了，这样做多此一
 举。而且上面例子中的正则表达式设置成为了一个常量，并不是一个正则表达式的规则，正
 则表达式的灵魂在于规则，所以这样做意义不大。

 那么正则表达式的规则怎么写呢？先不急，我们一步一步来，先来一个简单的，找出字符串
 中的所有小写字母。首先我们在 `findall` 函数中第一个参数写正则表达式的规则，其中
 `[a-z]` 就是匹配任何小写字母，第二个参数只要填写要匹配的字符串就行了。具体如下：

 ```python

 import re

 # 设定一个常量
 a = '两点水|twowater|liangdianshui|草根程序员|ReadingWithU'

 # 选择 a 里面的所有小写英文字母

 re_findall = re.findall('[a-z]', a)

 print(re_findall)

 ```

 输出的结果：

 ```txt
 ['t', 'w', 'o', 'w', 'a', 't', 'e', 'r', 'l', 'i', 'a', 'n', 'g', 'd', 'i', 'a', 'n', 's', 'h', 'u', 'i', 'e', 'a', 'd', 'i', 'n', 'g', 'i', 't', 'h']
 ```

 这样我们就拿到了字符串中的所有小写字母了。
 # 字符集


 好了，通过上面的几个实例我们初步认识了 Python 的正则表达式，可能你就会问，正则表
 达式还有什么规则，什么字母代表什么意思呢？

 其实，这些都不急，在本章后面会给出对应的正则表达式规则列表，而且这些东西在网上随
 便都能 Google 到。所以现在，我们还是进一步加深对正则表达式的理解，讲一下正则表达
 式的字符集。

 字符集是由一对方括号 “[]” 括起来的字符集合。使用字符集，可以匹配多个字符中的一个。

 举个例子，比如你使用 `C[ET]O` 匹配到的是 CEO 或 CTO，也就是说 `[ET]` 代表的是一
 个 E 或者一个 T。像上面提到的 `[a-z]` ,就是所有小写字母中的其中一个，这里使用了
 连字符 “-” 定义一个连续字符的字符范围。当然，像这种写法，里面可以包含多个字符
 范围的，比如：`[0-9a-fA-F]` ,匹配单个的十六进制数字，且不分大小写。注意了，字符
 和范围定义的先后顺序对匹配的结果是没有任何影响的。

 其实说了那么多，只是想证明，字符集一对方括号 “[]” 里面的字符关系是或关系，下面看一个例子：

 ```Python

 import re
 a = 'uav,ubv,ucv,uwv,uzv,ucv,uov'

 # 字符集

 # 取 u 和 v 中间是 a 或 b 或 c 的字符
 findall = re.findall('u[abc]v', a)
 print(findall)
 # 如果是连续的字母，数字可以使用 - 来代替
 l = re.findall('u[a-c]v', a)
 print(l)

 # 取 u 和 v 中间不是 a 或 b 或 c 的字符
 re_findall = re.findall('u[^abc]v', a)
 print(re_findall)

 ```

 输出的结果：

 ```txt
 ['uav', 'ubv', 'ucv', 'ucv']
 ['uav', 'ubv', 'ucv', 'ucv']
 ['uwv', 'uzv', 'uov']
 ```

 在例子中，使用了取反字符集，也就是在左方括号 “[” 后面紧跟一个尖括号 “^”，就
 会对字符集取反。需要记住的一点是，取反字符集必须要匹配一个字符。比如：`q[^u]` 并
 不意味着：匹配一个 q，后面没有 u 跟着。它意味着：匹配一个 q，后面跟着一个不是 u
 的字符。具体可以对比上面例子中输出的结果来理解。

 我们都知道，正则表达式本身就定义了一些规则，比如 `\d`,匹配所有数字字符,其实它是
 等价于 [0-9]，下面也写了个例子，通过字符集的形式解释了这些特殊字符。

 ```Python
 import re

 a = 'uav_ubv_ucv_uwv_uzv_ucv_uov&123-456-789'

 # 概括字符集

 # \d 相当于 [0-9] ,匹配所有数字字符
 # \D 相当于 [^0-9] ， 匹配所有非数字字符
 findall1 = re.findall('\d', a)
 findall2 = re.findall('[0-9]', a)
 findall3 = re.findall('\D', a)
 findall4 = re.findall('[^0-9]', a)
 print(findall1)
 print(findall2)
 print(findall3)
 print(findall4)

 # \w 匹配包括下划线的任何单词字符，等价于 [A-Za-z0-9_]
 findall5 = re.findall('\w', a)
 findall6 = re.findall('[A-Za-z0-9_]', a)
 print(findall5)
 print(findall6)

 ```

 输出结果：

 ```txt
 ['1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '&', '-', '-']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '&', '-', '-']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 ['u', 'a', 'v', '_', 'u', 'b', 'v', '_', 'u', 'c', 'v', '_', 'u', 'w', 'v', '_', 'u', 'z', 'v', '_', 'u', 'c', 'v', '_', 'u', 'o', 'v', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 ```
** 调用 shell 程序
   #+begin_src python
          import os
          os.system("ls")
   #+end_src

连接 shell 输出 

text= os.popen("type hello.py").read()
** 子进程
   #+begin_src python
     import subprocess 
     subprocess.call('python helloshello.py')
   #+end_src

* python 环境
  git clone https://github.com/yyuu/pyenv.git ~/.pyenv
  git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv
  echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
  echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshrc
  echo 'eval "$(pyenv init -)"' >> ~/.zshrc
  echo 'eval "$(pyenv virtualenv-init -)"' >> ~/.zshrc
  
  # 不喜写兼容代码，所有代码均向 3.5+ 靠拢
  v=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v
  v=3.6.0|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v
  v=2.7.9|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v

# 设置 Global Python 为 2.7.9, 备注：尽量不要把 Py3 设置为全局，否则由于 Homebrew 本身有一些应用是依赖于 Py2 的，设置为 Py2 容易出现一些奇怪的问题。
pyenv global 2.7.9
pip install -i https://pypi.doubanio.com/simple requests
# 下面这个是用于安装基本的代码补全功能
pip install -i https://pypi.doubanio.com/simple --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5" flake8 pytest autoflake hy

# 先激活环境??? 
pyenv virtualenv 3.5.2 py3-daily
pyenv activate py3-daily
pip install -i https://pypi.doubanio.com/simple requests
pip install -i https://pypi.doubanio.com/simple beatutifulsoup4
pip install -i https://pypi.doubanio.com/simple ipython[notebook]
pip install -i https://pypi.doubanio.com/simple jupyter
# 下面这个是用于安装基本的代码补全功能
pip install -i https://pypi.doubanio.com/simple --upgrade "jedi>=0.9.0" "json-rpc>=1.8.1" "service_factory>=0.1.5" flake8 pytest autoflake hy
pyenv deactivate
# pyenv uninstall py3-daily

2.1 代码补全
当你按照前面的所有配置走一圈下来，基本上就已经可以完美的进行补全了。
比如，当我编辑一个 py 文件的时候，
# 先激活虚拟环境
pyenv activate 3.5.2/envs/py3-daily
emacs py.py

如图所示，因为请求，numpy 这种第三方库都可以完美补全，其他自然不在话下。

代码补全

代码补全还有另一个神器，就是可以内嵌 lisp 的 Snippet 模板 -  yasnippet，由于模板功能基本上和其他编辑器相同，而使用 elisp 语言进行编写动态 Snippet 模板则需要会 elisp，这以后有机会再学学。
2.2 代码跳转

文件代码跳转 spc-spc-helm-imenu 查看文件结构
文件跳转在 normal-mode 下，gd 即可跳转到函数定义上，但是不能跨文件跳转。






单文件使用 helm_imenu 进行浏览






使用 ag 进行代码搜索

2.3 pytest 测试

spc-ms-py3-daily 进入选择 py3-daily 虚拟环境
spc-spc-pytest-all 进入即可运行所有 pytest 测试。

测试过程：
运行测试失败，运行测试失败，使用 cwj 跳转到下面窗口，对红色标记处输入，即可跳转到出错文件行。





pytest 运行测试失败

修正运行测试成功，如图：





pytest 运行测试成功

×03。IPython 笔记本
通常情况下我使用 IPython Notebook 都是在 Web 端，因为是 Web 端，实际上大量的 Dom 渲染对浏览器的渲染速度还是有一定的影响的，我还是比较喜欢客户端，因为客户端的快捷键可以定制，而 Web 端的快捷键实在是相当的不方便。
是不是 IPython Notebook 的 web 端没有好处呢？有的，比如我可以借用外部的 JS 可视化图表对 js 进行可视化呀。
比如我发在简书上的这篇技术文 IPython Notebook 引入 ECharts 做可视化
但，如果不需要 js 功能的话，还是用客户端舒服一些。
3.1 IPython Notebook 基本配置
spacemacs 貌似只支持密码访问 IPython Notebook，那么我们就生成密码。
# 首先激活 py3-daily 环境
python -c "from notebook.auth import passwd;print(passwd())" | pbcopy
# 恩，于是剪切板上就有如下的字符串
sha1:9bf4c48a6b83:26bc24a78a1e4aea7baa36874f5e86bafac0dbb9
# 打开 config 文件取消注释并修改 c.NotebookApp.password
vim ~/.jupyter/jupyter_notebook_config.py
c.NotebookApp.password = 'sha1:35543659622f:f9a78f0b20132f3e04aa1d4ed4060f9fd9eb7663'

3.2 Emacs IPython Notebook
# 首先在终端打开 IPython Notebook
ipython notebook

接着打开 emacs，输入 spc-ain，默认端口，然后输入密码即可。首次登陆后还需要在输入一次 spc-ain 即可看到 IPython Notebook 的主界面。





IPYNB 的主界面

光标移到[新笔记本]键击进入新建 IPython Notebook。
输入如下代码：
# The %... is an iPython thing, and is not part of the Python language.
# In this case we're just telling the plotting library to draw things on
# the notebook, instead of on a separate window.
%matplotlib inline
# See all the "as ..." contructs? They're just aliasing the package names.
# That way we can call methods like plt.plot() instead of matplotlib.pyplot.plot().
import numpy as np
import scipy as sp
import matplotlib as mpl
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import pandas as pd
import time
pd.set_option('display.width', 1000)
pd.set_option('display.max_columns', 100)
pd.set_option('display.notebook_repr_html', True)
import seaborn as sns
sns.set_style("darkgrid")
sns.set_context("poster")
sns.set()

# Load the example flights dataset and conver to long-form
flights_long = sns.load_dataset("flights")
flights = flights_long.pivot("month", "year", "passengers")

# Draw a heatmap with the numeric values in each cell
sns.heatmap(flights, annot=True, fmt="d", linewidths=.5)


shift + enter，咣
热力图就出来了





热力图

0×04。扩展
看完上文，就可以深入文档进行探索了。

作者：无与童比
链接：https://www.jianshu.com/p/c5cc672aae63
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
* 语言配套工具
** 包管理工具 
*** pip 
    安装 pip install requests
    查找 pip search xml
    明细 pip show beautifulsoup4
    卸载 pip uninstall requests
    国内源 pip install -i https://pypi.douban.com/simple virtualenv
*** pipenv
    更高级别的工具，可以简化常见用例的依赖关系管理。
    
    pip install  pipenv
    
    为项目安装包
    $ cd project_folder
    $ pipenv install requests
    
** 虚拟环境 virtualenv 管理包
   环境，就是用某个环境的工具执行代码喽，激活了环境记得关闭此环境哦
   
*** 创建虚拟环境
    创建 env 环境目录   virtualenv env
    创建目录，并选用 python3 的解释器 virtualenv -p /usr/local/bin/python3 venv
*** 启动虚拟环境 source ./bin/activate
    Virtualenv 附带有 pip 安装工具，因此需要安装的 packages 可以直接运行：
*** 退出虚拟环境 deactivate
*** 删除虚拟环境 rm -rf 
*** 虚拟环境管理工具 Virtualenvwrapper 
**** 创建虚拟机 mkvirtualenv env
**** 列出虚拟环境列表 workon 或者 lsvirtualenv
**** 启动/切换虚拟环境 workon [virtual-name]
**** 删除虚拟环境 rmvirtualenv  [virtual-name]
**** 离开虚拟环境 deactivate
** 版本管理 pyenv,管理 python 版本
   通过在 PATH 最前面插入 shims 来决定应用使用的 python 版本，从而将你的命令传递
   给正确的 python 程序
   
   安装 pyenv   curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
   
   配置环境变量
   
   #+begin_src shell
     export PYENV_ROOT="$HOME/.pyenv"
     export PATH="$PYENV_ROOT/bin:$PATH"
     eval "$(pyenv init -)"
     eval "$(pyenv virtualenv-init -)"
     export PYENV_VIRTUALENV_DISABLE_PROMPT=1
   #+end_src


   常用命令 
   pyenv versions – 查看系统当前安装的 python 列表
   pyenv version – 查看系统当前使用的 python 版本
   pyenv install -v 3.5.3 – 安装 python
   pyenv uninstall 2.7.13 – 卸载 python
   pyenv rehash – 为所有已安装的可执行文件（如：~/.pyenv/versions/bin/）创建 shims， 因此每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）
   
   版本切换
   pyenv global 3.5.3 – 设置全局的 Python 版本，通过将版本号写入~/.pyenv/version 文件的方式
   pyenv local 2.7.13 – 设置面向程序的本地版本，通过将版本号写入当前目录下的.python-version 文件的方式。 通过这种方式设置的 Python 版本优先级较 global 高。
   pyenv shell 2.7.13 - 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式
   优先级: shell > local > global

   卸载 pyenv
   禁用 pyenv 很简单，只需要在~/.bash_profile 中的 pyenv init 那行删了即可。
   完全移除 pyenv，先执行上面第 1 步，然后删了 pyenv 的根目录: rm -rf $(pyenv root)
   插件 pyenv-virtualenv
   
   安装插件    官网地址: https://github.com/pyenv/pyenv-virtualenv

   使用自动安装 pyenv 后，它会自动安装部分插件，通过 pyenv-virtualenv 插件可以很好的和 virtualenv 结合

   另外，一个可选配置是在~/.bash_profile 最后添加:

   eval "$(pyenv virtualenv-init -)"
   
   可以实现自动激活虚拟环境，这个特性非常有用建议都加上。

   创建虚拟环境: pyenv virtualenv 2.7.13 virtual-env-2.7.13，默认使用当前环境 python 版本。 在文件夹$(pyenv root)/versions/my-virtual-env-2.7.13 中创建一个基于 Python 2.7.13 的虚拟环境。
   列出虚拟环境: pyenv virtualenvs，对每个 virtualenv 显示 2 个, 短的只是个链接，那个*表示当前激活的。
   激活虚拟环境: pyenv activate virtual-env-2.7.13
   退出虚拟环境: pyenv deactivate
   删除虚拟环境: pyenv uninstall virtual-env-2.7.13
   
   如果 eval "$(pyenv virtualenv-init -)"写在你的 shell 配置中(比如上面
   的~/.bash_profile), 那么当 pyenv-virtualenv 进入/离开某个含有.python-version
   目录时会自动激活/退出虚拟环境。
   
   场景使用流程:

   # 先创建一个虚拟环境
   pyenv versions
   pyenv virtualenv 2.7.13 virtual-env-2.7.13
   # 进入某个目录比如/root/work/flask-demo
   pyenv local virtual-env-2.7.13
   # 然后再不需要去手动激活了
   使用 pyenv 来管理多版本的 python 命令，使用 pyenv-virtualenv 插件来管理多版本
   python 包环境。爽歪歪~
