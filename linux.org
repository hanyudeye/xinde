* Linux学习基本步骤
** 初级阶段：
 1． 命令是必须要学的，linux常用的命令大概在80个左右，这些常用命令一定要熟练掌握。
 2． 掌握linux软件包的常用安装方法，例如源码安装，rpm方式安装等等。
 3． 学习安装设备驱动程序（比如网卡、显卡驱动） 
 4． 熟悉Grub/Lilo引导程序及简单的修复操作。 
 5． 熟悉Linux文件系统和目录结构以及linux基本运行原理。 
 6． 掌握vi，gcc，gdb等常用编辑器，编译器，调试器。 
 7． 理解shell别名、管道、I/O重定向、输入和输出以及shell简单脚本编程。 
 8． 学习Linux环境下的网络基本组建。
** 高级阶段:
 1:尝试阅读linux内核源码：

 这需要具有一定的C、C++语言基础，因为C、C++是linux/unix的核心语言，系统代码都是C
 写的。

 2:尝试编译安装和调试自己的linux内核：
 在阅读源码了解了linux底层的运行原理后，完全可以编译一个适合自己的linux系统来。

 3:深入学习shell， perl，cgi等脚本语言：

 这些脚本语言在linux下非常强大，它们能完成你想做的任何事情，熟练掌握这些语言，可
 以让你在linux系统下游刃有余，如鱼得水。

 4:构建企业级linux高可用集群系统：

 linux下有很多开源免费的集群软件，利用这些免费的集群软件完全可以构建出与商业unix
 系统想媲美的集群系统来。
* linux
  组成 内核,Shell,文件系统，应用程序
** 启动顺序  
  执行顺序为：/etc/profile -> (~/.bash_profile | ~/.bash_login | ~/.profile) ->
~/.bashrc -> /etc/bashrc -> ~/.bash_logout
** 启动过程
*** 内核的引导
    首先读入 /boot 目录下的内核文件
*** 运行 init
    配置文件： /etc/inittab, /etc/init/*.conf
*** 系统初始化
    在 init 的配置文件中有这么一行：si::sysinit:/etc/rc.d/rc.sysinit　它调用执行
    了/etc/rc.d/rc.sysinit l5:5:wait:/etc/rc.d/rc 5这一行表示以 5 为参数运行
    /etc/rc.d/rc，/etc/rc.d/rc 是一个 Shell 脚本，它接受 5 作为参数，去执行
    /etc/rc.d/rc5.d/目录下的所有的 rc 启动脚本，/etc/rc.d/rc5.d/目录中的这些启动
    脚本实际上都是一些连接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际
    上都是放在/etc/rc.d/init.d/目录下。
*** 建立终端 
    1:2345:respawn:/sbin/mingetty tty1
    2:2345:respawn:/sbin/mingetty tty2
    3:2345:respawn:/sbin/mingetty tty3
    4:2345:respawn:/sbin/mingetty tty4
    5:2345:respawn:/sbin/mingetty tty5
    6:2345:respawn:/sbin/mingetty tty6
*** 用户登录系统
    （1）命令行登录
    （2）ssh 登录
    （3）图形界面登录
*** 图形模式与文字模式切换
    Ctrl + Alt + F1 ~ F6
*** 关机
    正确的关机流程为：sync > shutdown > reboot > halt
    关机指令为：shutdown -h +10 10 分钟后
    
    最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数
    据写到磁盘中。
** 系统管理 
*** 关机
**** who
     在关机前需要先使用 who 命令查看有没有其它用户在线。
**** sync
     为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因
     此关机之前需要先进行 sync 同步操作。
**** shutdown
#+BEGIN_SRC shell
  # shutdown [-krhc] 时间 [信息]
  -k ： 不会关机，只是发送警告信息，通知所有在线的用户
  -r ： 将系统的服务停掉后就重新启动
  -h ： 将系统的服务停掉后就立即关机
  -c ： 取消已经在进行的 shutdown 指令内容
#+END_SRC
*** 软件安装卸载工具
    对于发行版，最主要的是两种包.1.RPM 2.DPKG
+ RPM(Redhat Package Manager)
+ DPKG(Debian Package)
*** sudo (用户提权）
    sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中
    添加的用户才能使用该指令。
** 文件系统管理   
*** 分区
**** 分区表
  磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的
  GPT 分区表。
***** MBR
  MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区
  表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。

  分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩
  展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因
  此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。

  Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如
  /dev/sda1。注意，逻辑分区的编号从 5 开始。
***** GPT
  不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有
  磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小
  为 512 bytes。

  GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把
  最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这
  个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码
  (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份
  分区进行恢复。

  GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 *
  32 = 128 个分区。

  MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup> TB = 8 ZB。
**** 开机检测程序
***** BIOS
  BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件
  中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。

  BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁
  盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，
  这个开机管理程序会加载操作系统的核心文件。

  主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其
  它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开
  机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择
  启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。

***** UEFI
      BIOS 不可以读取 GPT 分区表，而 UEFI 可以。

**** 文件
***** 结构 
****** inode：一个文件占用一个 inode，记录文件的属性 ，同时记录此文件的内容所在的 block 编号；
****** block：记录文件的内容，文件太大时，会占用多个 block。
****** superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
****** block bitmap：记录 block 是否被使用的位域。
**** 文件读取
**** 磁盘碎片
  指一个文件内容所在的 block 过于分散。

**** block
  在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单
  个文件和文件系统的最大大小。

  | 大小         | 1KB  | 2KB   | 4KB  |
  | 最大单一文件 | 16GB | 256GB | 2TB  |
  | 最大文件系统 | 2TB  | 8TB   | 16TB |

  一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量
  的小文件，那么最好选用比较小的 block。

**** inode

  inode 具体包含以下信息：

  - 权限 (read/write/excute)；
  - 拥有者与群组 (owner/group)；
  - 容量；
  - 建立或状态改变的时间 (ctime)；
  - 最近一次的读取时间 (atime)；
  - 最近修改的时间 (mtime)；
  - 定义文件特性的旗标 (flag)，如 SetUID...；
  - 该文件真正内容的指向 (pointer)。

  inode 具有以下特点：

  - 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；
  - 每个文件都仅会占用一个 inode。

  inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。

** 设备管理
*** 磁盘 
**** 接口方式
***** IDE 
     IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。
***** SATA
***** SCSI
***** SAS
 SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。
**** 磁盘文件名(操作对象命名规范)
     Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常
     见磁盘的文件名如下：
 - IDE 磁盘：/dev/hd[a-d]
 - SATA/SCSI/SAS 磁盘：/dev/sd[a-p]

 文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。
**** 分区
***** MBR
  MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区
  表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。

  分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩
  展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因
  此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。

  Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如
  /dev/sda1。注意，逻辑分区的编号从 5 开始。
***** GPT
  不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有
  磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小
  为 512 bytes。

  GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把
  最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这
  个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码
  (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份
  分区进行恢复。

  GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 *
  32 = 128 个分区。MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup>
  TB = 8 ZB。
**** 开机检测程序
***** BIOS  
***** UEFI
      BIOS 不可以读取 GPT 分区表，而 UEFI 可以。
*** 软盘

** 进程管理
*** 查看进程
**** ps

  查看某个时间点的进程信息

  示例一：查看自己的进程

  # ps -l
  示例二：查看系统所有进程

  # ps aux
  示例三：查看特定的进程

  # ps aux | grep threadx
**** pstree

  查看进程树

  示例：查看所有进程树

  # pstree -A
**** top

  实时显示进程信息

  示例：两秒钟刷新一次

  # top -d 2
**** netstat

  查看占用端口的进程

  示例：查看特定端口的进程

  # netstat -anp | grep port
  进程状态

  状态	说明
  R	running or runnable (on run queue)
  D	uninterruptible sleep (usually I/O)
  S	interruptible sleep (waiting for an event to complete)
  Z	zombie (terminated but not reaped by its parent)
  T	stopped (either by a job control signal or because it is being traced)
** 配置文件
   $ cat /proc/cpuinfo
   $ cat /proc/meminfo
   $ cat /proc/net/sockstat
** 模块 
    rmmod 从运行的内核中移除指定的内核模块
    insmod 将给定的模块加载到内核中
    lsmod 显示已载入系统的模块
* qaq
** 忘记密码
 3 秒之内要按一下回车，出现如下界面
 然后输入 e
 在 第二行最后边输入 single，有一个空格。具体方法为按向下尖头移动到第二行，按"e"进入编辑模式
 在后边加上 single 回车
 最后按"b"启动，启动后就进入了单用户模式了
 此时已经进入到单用户模式了，你可以更改 root 密码了。更密码的命令为 passwd
* linux0.12
** 文件系统(货物架)  
   取货权限 permission 读/写/执行权限
*** 货物架属性
    #+BEGIN_SRC c
      struct d_inode
      {
        unsigned short i_mode;	// 货架可以拿东西，或者存东西
        unsigned short i_uid;		// 货架是谁的
        unsigned long i_size;		// 文件大小（字节数）。
        unsigned long i_time;		// 修改时间
        unsigned char i_gid;		// 货架归属组
        unsigned char i_nlinks;	// 链接数（多少个文件目录项指向该i 节点）。
        unsigned short i_zone[9];	// 直接(0-6)、间接(7)或双重间接(8)逻辑块号。
      // zone 是区的意思，可译成区段，或逻辑块。
      };
    #+END_SRC
*** 货物属性(文件属性)
    #+BEGIN_SRC c

      struct m_inode
      {
        unsigned short i_mode;	//货物属性
        unsigned short i_uid;		// 用户id（文件拥有者标识符）。
        unsigned long i_size;		// 文件大小（字节数）。
        unsigned long i_mtime;	// 修改时间（自1970.1.1:0 算起，秒）。
        unsigned char i_gid;		// 组id(文件拥有者所在的组)。
        unsigned char i_nlinks;	// 文件目录项链接数。
        unsigned short i_zone[9];	// 直接(0-6)、间接(7)或双重间接(8)逻辑块号。
      /* these are in memory also */
        struct task_struct *i_wait;	//是谁拿去用
        unsigned long i_atime;	// 最后访问时间。
        unsigned long i_ctime;	// i 节点自身修改时间。
        unsigned short i_dev;		// 货物归属 哪个设备 i 节点所在的设备号。
        unsigned short i_num;		// 货物的身份证号 i 节点号。
        unsigned short i_count;	// i 节点被使用的次数，0 表示该i 节点空闲。
        unsigned char i_lock;		// 锁定标志。
        unsigned char i_dirt;		// 已修改(脏)标志。
        unsigned char i_pipe;		// 管道标志。
        unsigned char i_mount;	// 安装标志。
        unsigned char i_seek;		// 搜寻标志(lseek 时)。
        unsigned char i_update;	// 更新标志。
      };

    #+END_SRC
