* 表
** 列-字段
** 行
* mysql
** 查 
select * from emp;  #注释
** 进入
mysql -h 主机地址 -u 用户名 －p 用户密码 
** MySql用户管理
mysql -uroot -p databasename;

** 增加用户
#格式:grant 权限 on 数据库.* to 用户名@登录主机 identified by '密码'
/*
如，增加一个用户user1密码为password1，让其可以在本机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令： 
grant select,insert,update,delete on *.* to user1@localhost Identified by "password1"; 
如果希望该用户能够在任何机器上登陆mysql，则将localhost改为"%"。 
如果你不想user1有密码，可以再打一个命令将密码去掉。 
grant select,insert,update,delete on mydb.* to user1@localhost identified by ""; 
*/

grant all privileges on wpj1105.* to sunxiao@localhost identified by '123';   #all privileges 所有权限

#----------------------------
** MySql数据库操作基础
*** #显示数据库
    show databases;

*** #判断是否存在数据库wpj1105,有的话先删除
    drop database if exists wpj1105;

*** #创建数据库
    create database wpj1105;

*** #删除数据库
    drop database wpj1105;

*** #使用该数据库
use wpj1105;

*** #显示数据库中的表
    show tables;

*** #先判断表是否存在,存在先删除
    drop table if exists student;

*** #创建表
create table student(
id int auto_increment primary key,
name varchar(50),
sex varchar(20),
date varchar(50),
content varchar(100)
)default charset=utf8;

*** #删除表
drop table student;

*** #查看表的结构
describe student;  #可以简写为desc student;

*** #插入数据
insert into student values(null,'aa','男','1988-10-2','......');
insert into student values(null,'bb','女','1889-03-6','......');
insert into student values(null,'cc','男','1889-08-8','......');
insert into student values(null,'dd','女','1889-12-8','......');
insert into student values(null,'ee','女','1889-09-6','......');
insert into student values(null,'ff','null','1889-09-6','......');
*** #查询表中的数据
select * from student;
select id,name from student;

*** #修改某一条数据
update student set sex='男' where id=4;

*** #删除数据
delete from student where id=5;
*** # and 且
select * from student where date>'1988-1-2' and date<'1988-12-1';

# or 或
select * from student where date<'1988-11-2' or date>'1988-12-1';
   
#between
select * from student where date between '1988-1-2' and '1988-12-1';

*** #in 查询制定集合内的数据
select * from student where id in (1,3,5);

*** #排序 asc 升序  desc 降序
select * from student order by id asc;

#分组查询 #聚合函数 
select max(id),name,sex from student group by sex;

select min(date) from student;

select avg(id) as '求平均' from student;

select count(*) from student;   #统计表中总数

select count(sex) from student;   #统计表中性别总数  若有一条数据中sex为空的话,就不予以统计~

select sum(id) from student;

#查询第i条以后到第j条的数据(不包括第i条)
select * from student limit 2,5;  #显示3-5条数据

*** #巩固练习
create table c(
 id int primary key auto_increment,
 name varchar(10) not null,
 sex varchar(50) ,  #DEFAULT '男' ,
 age int unsigned, #不能为负值(如为负值 则默认为0)
 sno int unique    #不可重复
);

drop table c;
desc c;

insert into c (id,name,sex,age,sno) values (null,'涛哥','男',68,1);
insert into c (id,name,sex,age,sno) values (null,'aa','男',68,2);
insert into c (id,name,sex,age,sno) values (null,'平平','男',35,3);
...

select * from c;

#修改数据 
update c set age=66 where id=2;
update c set name='花花',age=21,sex='女' where id=2
delete from c where age=21;

#常用查询语句
select name,age ,id from c
select * from c where age>40 and age<60;  #and
select * from c where age<40 or age<60;  #or
select * from c where age between 40 and 60 #between
select * from c where age in (30,48,68,99);     #in 查询指定集合内的数据
select * from c order by age desc;      #order by （asc升序 des降序）

#分组查询
select name,max(age) from c group by sex;  #按性别分组查年龄最大值
#聚合函数
select min(age) from c;
select avg(age) as '平均年龄 ' from c;
select count(*) from c;  #统计表中数据总数
select sum(age) from c;

#修改表的名字
#格式:alter table tbl_name rename to new_name
alter table c rename to a;
 
#表结构修改
create table test
(
id int not null auto_increment primary key, #设定主键
name varchar(20) not null default 'NoName', #设定默认值
department_id int not null,
position_id int not null,
unique (department_id,position_id) #设定唯一值
);

#修改表的名字
#格式:alter table tbl_name rename to new_name
alter table test rename to test_rename;

#向表中增加一个字段(列)
#格式:alter table tablename add columnname type;/alter table tablename add(columnname type);
alter table test add  columnname varchar(20);

#修改表中某个字段的名字
alter table tablename change columnname newcolumnname type;  #修改一个表的字段名
alter table test change name uname varchar(50);

select * from test;

#表position 增加列test
alter table position add(test char(10));
#表position 修改列test
alter table position modify test char(20) not null;
#表position 修改列test 默认值
alter table position alter test set default 'system';
#表position 去掉test 默认值
alter table position alter test drop default;
#表position 去掉列test
alter table position drop column test;
#表depart_pos 删除主键
alter table depart_pos drop primary key;
#表depart_pos 增加主键
alter table depart_pos add primary key PK_depart_pos
(department_id,position_id);

#用文本方式将数据装入数据库表中（例如D:/mysql.txt）
load data local infile "D:/mysql.txt" into table MYTABLE;

*** #导入.sql文件命令（例如D:/mysql.sql）
source d:/mysql.sql;  #或者  /. d:/mysql.sql;
* ms sqlserver 密码 Wuming123
  sqlcmd -S localhost -U SA -P '<YourPassword>'
  tsql -S 127.0.0.1 -U sa -P Wuming123  
** 安装
*** Import the public repository GPG keys:
   wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -

*** Register the Microsoft SQL Server Ubuntu repository:(添加到仓库列表)
    sudo add-apt-repository "$(wget -qo- https://packages.microsoft.com/config/ubuntu/16.04/mssql-server-2017.list)"
*** 安装
    sudo apt-get update
    sudo apt-get install -y mssql-server
*** 设置sa 的密码
    sudo /opt/mssql/bin/mssql-conf setup
*** 验证是否运行
    systemctl status mssql-server
*** 远程连接, 防火墙打开 1433端口
*** 命令行工具
    To create a database, you need to connect with a tool that can run Transact-SQL statements on the SQL Server.
    The following steps install the SQL Server command-line tools: sqlcmd and bcp.

**** Import the public repository GPG keys:
     wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -

**** Register the Microsoft Ubuntu repository:
     sudo add-apt-repository "$(wget -qO- https://packages.microsoft.com/config/ubuntu/16.04/prod.list)"

**** 安装工具
sudo apt-get update
sudo apt-get install -y mssql-tools unixodbc-dev
**** 设置环境变量
For convenience, add /opt/mssql-tools/bin/ to your PATH environment variable. 
This enables you to run the tools without specifying the full path. Run the following commands 
to modify the PATH for both login sessions and interactive/non-login sessions:

echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
source ~/.bashrc

Sqlcmd is just one tool for connecting to SQL Server to run queries and perform management and development tasks. Other tools include:

mssql-cli (Preview)

** Connect locally(本地连接)
   sqlcmd -S localhost -U SA -P '<YourPassword>'
   tsql -S 127.0.0.1 -U sa -P Wuming123  
   If you later decide to connect remotely, specify the machine name or IP address for the -S parameter, and make sure port 1433 is open on your firewall.
   远程连接 确保端口1433打开
* sqlmode
** 特性  
*** 语法高亮 
  - ANSI
  - DB2
  - Informix
  - Ingres
  - Interbase
  - Linter
  - Microsoft
  - MySQL
  - Oracle
  - Postgres
  - Solid
  - SQLite
  - Sybase
  - Vertica
*** 交互
- REPL support via =SQLi= buffer.
*** 语法检查
	gem install sqlint
*** 开头大写
    sql-capitalize-keywords t
    黑名单  sql-capitalize-keywords-blacklist '("name" "varchar")
*** MS SQL server with ms-sql
If you’re trying to use MS SQL Server in sql-mode, and the Microsoft command-line query processors osql and isql are not available to you, try jisql, a free, Java-based “workalike” provided by the clever (and generous) folks at Xigole Systems, Inc. http://www.xigole.com/software/jisql.jsp. Apache license.

Another option for users lacking access to osql/isql is sqsh, another Java-based command-line SQL client. The primary advantage to sqsh is that it is in the Debian/Ubuntu repositories (I can’t speak for Fedora, etc.) making it easier to install. When using sqsh to connect to SQL Server, use M-x sql-sybase, not sql-ms. Otherwise, Emacs won’t pass the right command-line parameters and it won’t connect.

I wrote a Python utility that is a drop in replacement for sqlcmd/osql as far as SQLi is concerned. You can find it in https://github.com/sebasmonia/sqlcmdline. It uses ODBC so in theory should work in platforms other than Windows. customize-group SQL, change Sql Ms Program to “/path/to/sqlcmdline” (or compiled/batch if under Windows), and for Emacs up to version 25 you still need to fix the prompt-regex as mentioned below.

– SebastianMonia
** Key bindings
*** Highlighting

 | Key Binding | Description                       |
 |-------------+-----------------------------------|
 | ~SPC m h k~ | select a SQL dialect to highlight |

*** Inferior Process Interactions (SQLi)
 | Key Binding | Description                 |
 |-------------+-----------------------------|
 | ~SPC m b b~ | show the SQLi buffer name   |
 | ~SPC m b s~ | set the SQLi buffer         |
 | ~SPC m l a~ | List all objects            |
 | ~SPC m l t~ | list all objects in a table |

**** Send SQL queries to SQLi:

 | Key Binding | Description                                                                           |
 |-------------+---------------------------------------------------------------------------------------|
 | ~SPC m s b~ | Send the whole buffer to the SQLi buffer                                              |
 | ~SPC m s B~ | Send the whole buffer to the SQLi buffer and switch to it in =insert state=           |
 | ~SPC m s i~ | Start the SQLi process                                                                |
 | ~SPC m s f~ | Send the paragraph around point to the SQLi buffer                                    |
 | ~SPC m s F~ | Send the paragraph around point to the SQLi buffer and switch to it in =insert state= |
 | ~SPC m s q~ | Prompt for a string to send to the SQLi buffer                                        |
 | ~SPC m s Q~ | Prompt for a string to send to the SQLi buffer and switch to it in =insert state=     |
 | ~SPC m s r~ | Send the selected region to the SQLi buffer                                           |
 | ~SPC m s R~ | Send the selected region to the SQLi buffer and switch to it in =insert state=        |

*** SQLi buffer
 | Key Binding | Description                                                  |
 |-------------+--------------------------------------------------------------|
 | ~SPC m b r~ | rename buffer (follow up in the SQL buffer with ~SPC m b s~) |
 | ~SPC m b S~ | save the current connection                                  |

*** Code Formating

 | ~SPC m = c~ | capitalize SQL keywords in region (if capitalize is enabled) |
* Tsql
  T-SQL代表Transact Structure Query Language，它是Microsoft产品，是SQL语言的扩展。
** T-SQL - 数据类型
   SQL Server数据类型是指定任何对象的数据类型的属性。 每个列，变量和表达式在SQL Server中具有相关的数据类型。 创建表时可以使用这些数据类型。 您可以根据需要为表列选择特定的数据类型。
*** 精确数值类型
    类型	从	至
    bigint	-9,223,372,036,854,775,808	9,223,372,036,854,775,807
    int	2,147,483,648	2,147,483,647
    smallint	-32,768	32,767
    tinyint	0	255
    bit	0	1
    decimal	-10 ^ 38加1	10 ^ 38 -1
    numeric	-10 ^ 38加1	10 ^ 38 -1
    money	-922,337,203,685,477.5808	+922,337,203,685,477.5807
    smallmoney	-214,748.3648	+214,748.3647
    数字和小数是固定精度和标度数据类型，在功能上等效。

*** 近似数值类型
    类型	从	至
    Float	-1.79E + 308	1.79E + 308
    Real	-3.40E + 38	3.40E + 38
*** 日期和时间类型
    类型	从	至
    datetime (3.33毫秒精度)
    1753年1月1日	9999年12月31日
    
    smalldatetime(1分钟精度)
    1900年1月1日	2079年6月6日
    
    date(1天的精度。在SQL Server 2008中引入)
    0001年1月1日	9999年12月31日
    
    datetimeoffset(100纳秒的精度。在SQL Server 2008中引入)
    0001年1月1日
    9999年12月31日
    
    datetime2(100纳秒的精度。在SQL Server 2008中引入)
    0001年1月1日	9999年12月31日
    
    time(100纳秒的精度。在SQL Server 2008中引入)
    00：00：00.0000000	23：59：59.9999999
*** 字符型
Sr.No	类型及说明
1 char 固定长度的非Unicode字符数据，最大长度为8,000个字符。
2 varchar 最大长度为8,000个字符的可变长度非Unicode数据。
3 Varchar (max) 可变长度的非Unicode数据，最大长度为231个字符（在SQL Server 2005中引入）。
4 text 可变长度非Unicode数据，最大长度为2,147,483,647个字符。

*** Unicode
Sr.No	类型及说明
1 nchar 固定长度的Unicode数据，最大长度为4,000个字符。
2 nvarchar 最大长度为4,000个字符的可变长度Unicode数据。
3 Nvarchar (max) 最大长度为230个字符的可变长度Unicode数据（在SQL Server 2005中引入）。
4 ntext 最大长度为1,073,741,823个字符的可变长度Unicode数据。

*** 二进制字符串
Sr.No	类型及说明
1 binary 固定长度二进制数据，最大长度为8,000字节。
2 varbinary 最大长度为8,000字节的可变长度二进制数据。
3 varbinary(max) 最大长度为231字节的可变长度二进制数据（在SQL Server 2005中引入）。
4 image 最大长度为2,147,483,647字节的可变长度二进制数据。

*** 其他数据类型
    SQL_VARIANT -存储各种SQL Server支持的数据类型的值，text，ntext和timestamp除外。
    TIMESTAMP -时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
    UNIQUEIDENTIFIER  -存储全局唯一标识符（GUID）。
    XML -存储XML数据。 您可以将XML实例存储在列或变量中（在SQL Server 2005中引入）。
    CURSOR -对游标的引用。
    TABLE -存储结果集以供稍后处理。
    HIERARCHYID -用于表示层次结构中位置的可变长度的系统数据类型（在SQL Server 2008中引入）。

** 查看表是否存在
   exec sp_columns TABLENAME
** T-SQL - 创建表
   创建一个基本表,包括表名,字段名称,以及每个字段的数据类型。
   
   在这个例子中，我们将创建一张名称为CUSTOMERS表,ID为主键,NOT NULL表示这些字段在添加记录时,值不能为空。
#+BEGIN_SRC sql

CREATE TABLE CUSTOMERS( 
   ID   INT              NOT NULL, 
   NAME VARCHAR (20)     NOT NULL, 
   AGE  INT              NOT NULL, 
   ADDRESS  CHAR (25) , 
   SALARY   DECIMAL (18, 2),        
   PRIMARY KEY (ID));
#+END_SRC

** T-SQL - 删除表
DROP TABLE table_name;
** T-SQL- INSERT语句  字符串用单引号
INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]   
VALUES (value1, value2, value3,...valueN); 

如果要为表的所有列添加值，则不需要在SQL查询中指定列名。 但请确保值的顺序与表中的列的顺序相同。 
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );
  
INSERT INTO CUSTOMERS VALUES (7, 'Muffy', 24, 'Indore', 10000.00 );

** 使用另一个表填充一个表
您可以通过SELECT语句将数据填充到表中，而另一个表提供另一个表具有一组字段，这是填充第一个表所必需的。 以下是基本语法:

INSERT INTO first_table_name  
   SELECT column1, column2, ...columnN  
      FROM second_table_name 
      [WHERE condition];
** T-SQL - SELECT语句
SQL Server SELECT语句用于从以结果表的形式返回从数据库中提取的数据。 这些结果表称为结果集。

SELECT column1, column2, columnN FROM table_name;
其中，column1，column2 ...是您要获取其值的表的字段。 如果要获取所有可用字段，则可以使用以下语法。

SELECT * FROM table_name;
** T-SQL - UPDATE语句
您可以使用WHERE子句与UPDATE查询更新所选行，否则所有行都会受到影响。

UPDATE table_name 
SET column1 = value1, column2 = value2...., columnN = valueN 
WHERE [condition];

您可以使用AND或OR运算符组合N个条件。

** T-SQL - DELETE语句
DELETE FROM table_name 
WHERE [condition]; 

您可以使用AND或OR运算符组合N个条件。

** T-SQL - WHERE子句
您可以使用比较或逻辑运算符（如>，<，=，LIKE，NOT等）指定条件。以下示例将介绍此概念。
** T-SQL - LIKE子句
MS SQL Server LIKE子句用于使用通配符运算符将值与类似值进行比较。 有两个通配符与LIKE运算符结合使用:

百分号（％）
下划线（_）
百分号表示零个，一个或多个字符。 下划线表示单个数字或字符。 符号可以组合使用。

语法
以下是 '％' 和 '_' 的基本语法。

SELECT *\column-list FROM table_name 
WHERE column LIKE 'XXXX%' 
 
or   

SELECT *\column-list FROM table_name 
WHERE column LIKE '%XXXX%'  

or  

SELECT *\column-list FROM table_name 
WHERE column LIKE 'XXXX_'  

or  

SELECT *\column-list FROM table_name 
WHERE column LIKE '_XXXX'  

or  

SELECT  *\column-list FROM table_name 
WHERE column LIKE '_XXXX_' 
您可以使用AND或OR运算符组合N个条件。 XXXX可以是任何数字或字符串值。

WHERE SALARY LIKE'％_00“ 查找在第二和第三位置中具有00的所有值
WHERE SALARY LIKE'2 _％_％“ 查找以2开头且长度至少为3个字符的所有值
WHERE SALARY LIKE'％_2 3' 查找在第二个位置有2，并以3结束的所有值
WHERE SALARY LIKE'2___3“ 查找以2开头并以3结尾的五位数字中的任何值

** T-SQL - ORDER BY子句
MS SQL Server ORDER BY子句用于根据一个或多个列以升序或降序对数据进行排序。 默认情况下，一些数据库排序查询结果按升序排列。

语法
以下是ORDER BY子句的基本语法。

SELECT column-list  
FROM table_name  
[WHERE condition]  
[ORDER BY column1, column2, .. columnN] [ASC | DESC];
您可以在ORDER BY子句中使用多个列。 确保您使用的任何列进行排序，该列应该在列表中。

例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
以下命令是一个示例，它将按NAME和SALARY的升序对结果进行排序。

SELECT * FROM CUSTOMERS 
   ORDER BY NAME, SALARY 
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS           SALARY 
4   Chaitali   25        Mumbai            6500.00 
5   Hardik     27        Bhopal            8500.00 
3   kaushik    23        Kota              2000.00 
2   Khilan     25        Delhi             1500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00 
1   Ramesh     32        Ahmedabad         2000.00 
以下命令是一个示例，它将按NAME的降序对结果进行排序。

SELECT * FROM CUSTOMERS 
   ORDER BY NAME DES
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00
7   Muffy      24        Indore             10000.00  
6   Komal      22        MP                 4500.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00
5   Hardik     27        Bhopal             8500.00
4   Chaitali   25        Mumbai             6500.00  
T-SQL - GROUP BY子句
SQL Server GROUP BY子句与SELECT语句协作使用，以将相同的数据分组。

GROUP BY子句位于SELECT语句中的WHERE子句之后，位于ORDER BY子句之前。

语法
以下是GROUP BY子句的基本语法，GROUP BY子句必须遵循WHERE子句中的条件，并且必须在使用ORDER BY子句之前。

SELECT column1, column2 
FROM table_name 
WHERE [ conditions ] 
GROUP BY column1, column2 
ORDER BY column1, column2 
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS          SALARY 
1   Ramesh     32        Ahmedabad        2000.00 
2   Khilan     25        Delhi            1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
如果你想知道每个客户的工资总额，那么可以使用以下的GROUP BY查询方式:

SELECT NAME, SUM(SALARY) as [sum of salary] FROM CUSTOMERS 
   GROUP BY NAME;
上述命令将产生以下结果集:

NAME        sum of salary 
Chaitali    6500.00 
Hardik      8500.00 
kaushik     2000.00 
Khilan      1500.00 
Komal       4500.00 
Muffy       10000.00 
Ramesh      2000.00
现在让我们考虑存在重复名称的情况,请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS           SALARY 
1   Ramesh     32        Ahmedabad         2000.00 
2   Khilan     25        Delhi             1500.00 
3   kaushik    23        Kota              2000.00 
4   Chaitali   25        Mumbai            6500.00 
5   Hardik     27        Bhopal            8500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00 
如果我们想知道每个客户的工资总额，那么可以使用以下的GROUP BY查询方式:

SELECT NAME, SUM(SALARY) as [sum of salary] FROM CUSTOMERS 
   GROUP BY NAME 
上述命令将产生以下结果集:

NAME        sum of salary 
Hardik      8500.00 
kaushik     8500.00 
Komal       4500.00 
Muffy       10000.00 
Ramesh      3500.00 
T-SQL - DISTINCT子句
MS SQL Server DISTINCT关键字与SELECT语句一起使用，以消除所有重复记录并仅提取唯一记录。

可能存在表中有多个重复记录的情况。 在获取此类记录时，更有意义的是仅提取唯一记录，而不是提取重复记录。

语法
以下是DISTINCT关键字的基本语法，用于删除重复记录。

SELECT DISTINCT column1, column2,.....columnN  
FROM table_name 
WHERE [condition] 
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
让我们先来看下未使用DISTINCT关键字情况下SELECT查询返回的结果集:

SELECT SALARY FROM CUSTOMERS 
   ORDER BY SALARY 
其中，工资为2000的记录出现了两次，这是因为CUSTOMERS表中存在两条SALARY为2000的记录。

SALARY 
1500.00 
2000.00 
2000.00 
4500.00 
6500.00 
8500.00 
10000.00
现在让我们使用DISTINCT关键字对CUSTOMERS表进行SELECT查询并查看结果:

SELECT DISTINCT SALARY FROM CUSTOMERS 
   ORDER BY SALARY 
上述命令将产生以下结果集，我们可以发现，并未出现重复记录

SALARY 
1500.00 
2000.00 
4500.00 
6500.00 
8500.00 
10000.00 
T-SQL - 连接表
MS SQL Server Joins子句用于合并数据库中两个或多个表的记录。 JOIN是通过使用每个表共有的值来组合两个表的字段的手段。

请参考具有以下记录的两张表，(a)表CUSTOMERS表记录如下:

ID  NAME       AGE       ADDRESS             SALARY 
1   Ramesh     32        Ahmedabad           2000.00 
2   Khilan     25        Delhi               1500.00 
3   kaushik    23        Kota                2000.00 
4   Chaitali   25        Mumbai              6500.00 
5   Hardik     27        Bhopal              8500.00 
6   Komal      22        MP                  4500.00 
7   Muffy      24        Indore              10000.00 
另一张(b)表ORDERS表记录如下:

OID  DATE                       CUSTOMER_ID        AMOUNT 
100  2009-10-08 00:00:00.000    3                  1500.00 
101  2009-11-20 00:00:00.000    2                  1560.00 
102  2009-10-08 00:00:00.000    3                  3000.00 
103  2008-05-20 00:00:00.000    4                  2060.00 
让我们在我们的SELECT语句中加入这两个表，如下所示

SELECT ID, NAME, AGE, AMOUNT 
   FROM CUSTOMERS, ORDERS 
   WHERE  CUSTOMERS.ID = ORDERS.CUSTOMER_ID 
OR 
SELECT A.ID, A.NAME, A.AGE, B.AMOUNT 
   FROM CUSTOMERS A inner join  ORDERS B on A.ID = B.Customer_ID 
上述命令将产生以下结果集:

ID   NAME      AGE    AMOUNT 
2    Khilan    25     1560.00 
3    kaushik   23     1500.00 
3    kaushik   23     3000.00 
4    Chaitali  25     2060.00 
值得注意的是，连接是在WHERE子句中执行的。 可以使用几个运算符来连接表，例如=，<，>，<>，<=，> =，！=，BETWEEN，LIKE和NOT; 它们都可以用于连接表。 然而，最常见的运算符是等号。

MS SQL Server连接类型:

   在MS SQL Server中有不同类型的连接 --

INNER JOIN -当两个表中都有匹配项时返回行。

LEFT JOIN -返回左侧表中的所有行，即使右表中没有匹配项。

RIGHT JOIN -返回右表中的所有行，即使左表中没有匹配项。

FULL JOIN -在其中一个表中存在匹配项时返回行。

SELF JOIN -这用于将表连接到自身，就像该表是两个表，临时重命名MS SQL Server语句中的至少一个表。

CARTESIAN JOIN -返回两个或多个联接表中的记录集的笛卡尔乘积。

T-SQL - 子查询

子查询或内部查询或嵌套查询是另一个SQL Server查询内的查询，并嵌入在WHERE子句中。 子查询用于返回将在主查询中使用的数据作为进一步限制要检索的数据的条件。

子查询可以与SELECT，INSERT，UPDATE和DELETE语句以及诸如=，<，>，> =，<=，IN，BETWEEN等运算符一起使用。

子查询必须遵循几个规则

子查询语句必须写在括号内。

子查询必须包括SELECT子句和FROM子句。

子查询可以使用WHERE，GROUP BY和HAVING子句。

子查询不能使用COMPUTE或FOR BROWSE子句。

只有在使用了TOP子句时，才能使用ORDER BY子句。

您可以嵌套最多32个级别的子查询。

带SELECT语句的子查询
语法
子查询最常用于SELECT语句，以下是基本语法:

SELECT column_name [, column_name ] 
FROM   table1 [, table2 ] 
WHERE  column_name OPERATOR 
   (SELECT column_name [, column_name ] 
   FROM table1 [, table2 ] 
   [WHERE]) 
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
让我们使用SELECT语句应用以下子查询:

SELECT *  
   FROM CUSTOMERS
   WHERE ID IN (SELECT ID FROM CUSTOMERS WHERE SALARY > 4500)
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS          SALARY 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
7   Muffy      24        Indore           10000.00 
带有INSERT语句的子查询
子查询也可以与INSERT语句一起使用。INSERT语句使用从子查询返回的数据插入到另一个表中。可以使用字符，日期或数字函数中的任何一个修改子查询中选定的数据。

语法
下面是基本的语法。

INSERT INTO table_name [ (column1 [, column2 ]) ] 
   SELECT [ *|column1 [, column2 ] 
   FROM table1 [, table2 ] 
   [ WHERE VALUE OPERATOR ]
例
创建一张命名为CUSTOMERS_BKP的表,表结构与CUSTOMERS表相同，并将CUSTOMERS表的数据复制到CUSTOMERS_BKP表中。

以下是将完整的CUSTOMERS表数据复制到CUSTOMERS_BKP的语法:

INSERT INTO CUSTOMERS_BKP 
   SELECT * FROM CUSTOMERS  
   WHERE ID IN (SELECT ID FROM CUSTOMERS)
带有UPDATE语句的子查询
子查询可以与UPDATE语句结合使用。 当使用带有UPDATE语句的子查询时，可以更新表中的单个或多个列。

语法
以下是基本语法。

UPDATE table 
SET column_name = new_value 
[ WHERE OPERATOR [ VALUE ] 
   (SELECT COLUMN_NAME 
   FROM TABLE_NAME) 
   [ WHERE) ] 
例
以下命令对CUSTOMERS表中AGE大于或等于27的所有客户的SALARY乘以0.25。

UPDATE CUSTOMERS 
   SET SALARY = SALARY * 0.25 
   WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP WHERE AGE >= 27 )
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS             SALARY 
1   Ramesh     32        Ahmedabad           500.00 
2   Khilan     25        Delhi               1500.00 
3   kaushik    23        Kota                2000.00 
4   Chaitali   25        Mumbai              6500.00 
5   Hardik     27        Bhopal              2125.00 
6   Komal      22        MP                  4500.00 
7   Muffy      24        Indore              10000.00 
使用DELETE语句的子查询
子查询可以与DELETE语句一起使用，就像上面提到的任何其他语句一样。

语法
以下是基本语法。

DELETE FROM TABLE_NAME 
[ WHERE OPERATOR [ VALUE ] 
   (SELECT COLUMN_NAME 
   FROM TABLE_NAME) 
   [ WHERE) ] 
例
以下命令将删除CUSTOMERS表中所有的年龄大于或等于27的客户的记录。

DELETE FROM CUSTOMERS 
   WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP WHERE AGE >=27 )
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS          SALARY 
2   Khilan     25        Delhi            1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00  
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
T-SQL - 存储过程
MS SQL Server存储过程用于通过将相同的数据存储在数据库中来节省写入代码的时间，并通过传递参数获得所需的输出。

语法
以下是存储过程创建的基本语法:

Create procedure <procedure_Name> 
As 
Begin 
<SQL Statement> 
End 
Go
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
以下命令是从Testdb数据库中的CUSTOMERS表中获取所有记录的示例。

CREATE PROCEDURE SelectCustomerstabledata 
AS 
SELECT * FROM Testdb.Customers 
GO
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS           SALARY 
1   Ramesh     32        Ahmedabad         2000.00 
2   Khilan     25        Delhi             1500.00 
3   kaushik    23        Kota              2000.00 
4   Chaitali   25        Mumbai            6500.00 
5   Hardik     27        Bhopal            8500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00 
T-SQL - 事务

事务是针对数据库执行的工作单元。 事务是以逻辑顺序完成的单元或工作序列，无论是以用户的手动方式还是以某种数据库程序自动进行。

事务是将一个或多个执行命令发送到数据库。例如，你正在创建记录,修改记录或者从表中删除记录，这些行为都是对表进行事务操作。事务对于确保数据完整性和处理数据库错误是非常重要的。

实际上，你常常会将许多SQL操作分成一组事务一起执行。

事务属性
事务具有以下四个标准属性，通常由首字母缩写ACID简称 -

原子性 -确保工作单元内的所有操作成功完成; 否则，事务在故障点处中止，并且先前的操作被回滚到它们的原先状态。

一致性 -确保数据库在成功提交的事务后正确更改状态。

隔离性 -事务之间是独立运行互不相关的。

持久性 -事务一旦被执行,即使系统故障,其结果依然有效。

事务控制
一下命令用于控制事务

COMMIT-提交事务。

ROLLBACK -回滚事务。

SAVEPOINT -创建事务的回滚节点。

SET TRANSACTION -设置事务名称。

事务控制命令仅与DML命令INSERT，UPDATE和DELETE一起使用。 在创建表或删除它们时，不能使用它们，因为这些操作会在数据库中自动提交。

为了在MS SQL Server中使用事务控制命令，我们必须以“begin tran”或begin transaction命令开始事务，否则这些命令将不起作用。

commit命令
COMMIT命令是用于将事务调用的更改保存到数据库的事务命令。 此命令将自上次COMMIT或ROLLBACK命令以来将所有事务保存到数据库。

语法
以下是COMMIT命令的语法。

COMMIT; 
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS           SALARY 
1   Ramesh     32        Ahmedabad         2000.00 
2   Khilan     25        Delhi             1500.00 
3   kaushik    23        Kota              2000.00 
4   Chaitali   25        Mumbai            6500.00 
5   Hardik     27        Bhopal            8500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00 
以下命令示例将从删除从CUSTOMERS表中删除所有年龄等于25的用户记录。

Begin Tran 
DELETE FROM CUSTOMERS 
   WHERE AGE = 25 
COMMIT 
上述命令将产生以下结果集:

ID  NAME       AGE       ADDRESS           SALARY 
1   Ramesh     32        Ahmedabad         2000.00
3   kaushik    23        Kota              2000.00
5   Hardik     27        Bhopal            8500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00 
ROLLBACK命令
ROLLBACK命令是用于撤销尚未保存到数据库的事务的事务性命令。 此命令只能用于在发出最后一个COMMIT或ROLLBACK命令后撤消事务。

语法
以下是ROLLBACK命令的语法。

ROLLBACK
例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
下面的命令将从CUSTOMERS表中删除年龄等于25的用户记录，然后使用ROLLBACK命令,回滚数据。

Begin Tran 
DELETE FROM CUSTOMERS 
   WHERE AGE = 25; 
ROLLBACK
使用ROLLBACK命令,删除操作不会影响表中的数据,执行后CUSTOMERS表结果集如下:

ID  NAME       AGE       ADDRESS          SALARY 
1   Ramesh     32        Ahmedabad        2000.00 
2   Khilan     25        Delhi            1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
SAVEPOINT命令
SAVEPOINT命令可以使事务回滚到某个点节点，而不回滚整个事务。

语法
以下是SAVEPOINT命令的语法。

SAVE TRANSACTION SAVEPOINT_NAME
此命令仅用于在事务语句之间创建SAVEPOINT。 ROLLBACK命令用于撤消一组事务。

以下是回滚到一个事务节点的语法。

ROLLBACK TO SAVEPOINT_NAME
在下面的示例中，我们将从CUSTOMERS表中删除三个不同的记录。 我们将在每次删除之前创建一个SAVEPOINT，以便我们可以随时将ROLLBACK任何SAVEPOINT返回到其原始状态的相应数据。

例
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS          SALARY 
1   Ramesh     32        Ahmedabad        2000.00 
2   Khilan     25        Delhi            1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
以下是一系列操作

Begin Tran 
SAVE Transaction SP1 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 1  
1 row deleted. 
SAVE Transaction SP2 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 2 
1 row deleted.
SAVE Transaction SP3 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 3 
1 row deleted.
三个删除已经发生，但是，我们改变了主意，决定ROLLBACK到SAVEPOINT，我们确定为SP2。 因为SP2是在第一次删除后创建的，所以最后两个删除被撤消

ROLLBACK Transaction SP2 
Rollback complete. 
请注意，我们回滚到SP2后，相当于只发生了第一次删除。

SELECT * FROM CUSTOMERS 
查询后的结果为6条记录:

ID  NAME       AGE       ADDRESS          SALARY 
2   Khilan     25        Ahmedabad        1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
SET TRANSACTION命令
SET TRANSACTION命令可用于启动数据库事务。 此命令用于指定随后事务的特性。

语法
以下是SET TRANSACTION语法。

SET TRANSACTION ISOLATION LEVEL <Isolationlevel_name>
T-SQL - 索引

索引是数据库搜索引擎用来加速数据检索的特殊查找表。 简单地说，一个索引是一个指向表中数据的指针。 数据库中的索引与书本目录的索引方式非常相似。

例如，如果您要引用一本书中讨论某个主题的所有页面，则可以参考索引，该索引按字母顺序列出所有主题，然后指定了这些主题的页码。

索引加快了SELECT查询和WHERE子句，但它降低了UPDATE和INSERT语句的数据输入速度。创建或删除索引不会对数据有影响。

创建索引涉及CREATE INDEX语句，它允许你对索引进行命名，指定表和要索引的列，并指示索引是按升序还是按降序排列。

索引也可以是唯一的，类似于UNIQUE约束，索引防止在具有索引的列的组合中出现重复条目。

CREATE INDEX命令
以下是CREATE INDEX的基本语法。

语法
CREATE INDEX index_name ON table_name
单列索引
单列索引是基于仅一个表的单列创建的索引。以下是基本语法。

语法
CREATE INDEX index_name 
ON table_name (column_name)
例
CREATE INDEX singlecolumnindex 
ON customers (ID)
唯一索引
唯一索引不仅用于查找性能的提升，还可用于约束数据的完整性。唯一索引不允许将任何重复值插入到表中。以下是基本语法。

语法
CREATE UNIQUE INDEX index_name 
on table_name (column_name)
例
CREATE UNIQUE INDEX uniqueindex 
on customers (NAME)
复合索引
复合索引是对表的两个或多个列设置索引。以下是基本语法。

语法
CREATE INDEX index_name on table_name (column1, column2) 
例
CREATE INDEX compositeindex 
on customers (NAME, ID)
无论是创建单列索引还是复合索引，请考虑您可能在查询的WHERE子句中频繁使用的列作为过滤条件。

如果只使用一列，则应该选择单列索引。 如果在WHERE子句中经常使用两个或多个列作为过滤器，则复合索引将是最佳选择。

隐式索引
隐式索引是在创建对象时由数据库服务器自动创建的索引。 一般情况下数据库会将自动为主键约束和唯一约束创建索引。

DROP INDEX命令
可以使用MS SQL SERVER DROP命令删除索引。 丢弃索引时应小心，因为性能可能会减慢，也可能得到改善。

语法
下面是基本的语法。

DROP INDEX tablename.index_name
什么时候避免索引？
虽然索引旨在提高数据库的性能，但有时应避免使用它们。以下几种情况应重新考虑是否使用索引

不应在小表上使用索引。

经常进行大批量更新或插入操作的表不应设置索引。

不应在可能含大量NULL值的列上使用索引。

频繁操作的列不应设置索引。

T-SQL - 函数
MS SQL Server有许多内置功能上的字符串或数字数据进行处理。下面是所有有用的SQL内置函数列表 -

SQL Server的计数功能 -在SQL Server COUNT聚合函数用于计算在数据库表中的行数。

SQL Server的max函数 -在SQL Server MAX聚合功能可以选择某列的最高（最大）值。

SQL Server的MIN功能 -在SQL Server MIN聚合函数允许选择了某列的最低（最小）值。

SQL Server的AVG功能 -在SQL Server AVG聚合函数选择对某些表列的平均值。

SQL Server的SUM函数 -在SQL Server SUM聚合函数允许选择总让数字列。

SQL Server的SQRT功能 -这用于产生一个给定数目的平方根。

SQL Server的RAND函数 -这是用于产生使用SQL命令的随机数。

SQL Server的concat函数 -这是用来连接多个参数的参数。

SQL Server的数值函数 -在SQL处理数字所需的SQL功能的完整列表。

SQL Server的字符串函数 -来操作字符串在SQL需要SQL函数的完整列表。

T-SQL - 字符串函数
SQLServer字符串函数扫描应用于字符串值，或返回字符串值或数字数据。

下面是带有示例的String函数列表。

ASCII（）
ASCII代码值将作为字符表达式的输出。

例
以下查询将给出给定字符的ASCII代码值。

Select ASCII ('word') 
CHAR（）
字符将作为给定ASCII代码或整数的输出。

例
以下查询将给出给定整数的字符。

Select CHAR(97)
NCHAR（）
Unicode字符将作为给定整数的输出。

例
以下查询将给出给定整数的Unicode字符。

Select NCHAR(300)
CHARINDEX（）
给定搜索表达式的起始位置将作为给定字符串表达式中的输出。

例
以下查询将给出给定字符串表达式“KING”的“G”字符的起始位置。

Select CHARINDEX('G', 'KING')
LEFT（）
给定字符串的左边部分，直到指定的字符数作为给定字符串的输出。

例
下面的查询将给出“WORLD”字符串作为字符串给定字符串'WORLD'的4个字符。

Select LEFT('WORLD', 4)
RIGHT（）
给定字符串的右边部分，直到指定的字符数作为给定字符串的输出。

例
下面的查询将给出'DIA'字符串3个给定字符串'INDIA'的字符数。

Select RIGHT('INDIA', 3)
SUBSTRING（）
基于开始位置值和长度值的字符串的一部分将作为给定字符串的输出。

例
以下查询将给出分别对于给定字符串“WORLD”提供（1,3），（3,3）和（2,3）作为开始和长度值的“WOR”，“DIA”，“ING” ，'INDIA'和'KING'。

Select SUBSTRING ('WORLD', 1,3) 
Select SUBSTRING ('INDIA', 3,3) 
Select SUBSTRING ('KING', 2,3)
LEN（）
字符数将作为给定字符串表达式的输出。

例
以下查询将为5提供“HELLO”字符串表达式。

Select LEN('HELLO') 
LOWER（）
小写字符串将作为给定字符串数据的输出。

例
以下查询将为'SQL Server'字符数据提供'sql server'。

Select LOWER('SQLServer') 
UPPER（）
大写字符串将作为给定字符串数据的输出。

例
以下查询将为“Sql Server”字符数据提供“SQL SERVER”。

Select UPPER('SqlServer')
LTRIM（）
字符串表达式将在删除前导空白后作为给定字符串数据的输出。

例
以下查询将为“WORLD”字符数据提供“WORLD”。

Select LTRIM('   WORLD')
RTRIM（）
字符串表达式将在删除尾部空格后作为给定字符串数据的输出。

例
下面的查询将给出'INDIA'字符数据的'INDIA'。

Select RTRIM('INDIA   ') 
REPLACE（）
在用指定字符替换指定字符的所有出现后，字符串表达式将作为给定字符串数据的输出。

例
以下查询将为'INDIA'字符串数据提供'KNDKA'字符串。

Select REPLACE('INDIA', 'I', 'K')
REPLICATE（）
重复字符串表达式将作为指定次数的给定字符串数据的输出。

例
以下查询将为“WORLD”字符串数据提供“WORLDWORLD”字符串。

Select REPLICATE('WORLD', 2)
REVERSE（）
反向字符串表达式将作为给定字符串数据的输出。

例
下面的查询将给出'WORLD'字符串数据的'DLROW'字符串。

Select REVERSE('WORLD')
SOUNDEX（）
返回四字符（SOUNDEX）代码，以评估两个给定字符串的相似性。

例
下面的查询将为'Smith'，'Smyth'字符串给出'S530'。

Select SOUNDEX('Smith'), SOUNDEX('Smyth')
DIFFERENCE（）
整数值将作为给定的两个表达式的输出。

例
以下查询将给出4个“Smith”，“Smyth”表达式。

Select Difference('Smith','Smyth') 
注 -如果输出值为0，表示给定2个表达式之间的相似度较弱或没有相似性。

SPACE（）
字符串来作为的空格指定数量的输出。

例
下面的查询将给出'I LOVE INDIA'。

Select 'I'+space(1)+'LOVE'+space(1)+'INDIA'
STUFF（）
字符串表达式将作为给定字符串数据的输出，在从起始字符替换为指定字符的指定长度之后。

例
下面的查询将给出'ABCDEFGH'字符串数据的'AIJKFGH'字符串作为给定的起始字符和长度分别为2和4，'IJK'作为指定的目标字符串。

Select STUFF('ABCDEFGH', 2,4,'IJK') 
STR（）
字符数据将作为给定数字数据的输出。

例
以下查询将给定187.37的187.37，基于指定的长度为6和十进制为2。

Select STR(187.369,6,2) 
UNICODE（）
整数值将作为给定表达式的第一个字符的输出。

例
以下查询将为82提供“RAMA”表达式。

Select UNICODE('RAMA') 
QUOTENAME（）
给定字符串将作为输出与指定的分隔符。

例
以下查询将为给定的“RAMA”字符串指定“RAMA”，因为我们指定双引号作为分隔符。

Select QUOTENAME('RAMA','"') 
PATINDEX（）
需要从指定的“I”位置的给定表达式开始第一个出现的位置。

例
下面的查询将给出'INDIA'的1。

Select PATINDEX('I%','INDIA') 
FORMAT（）
给定表达式将作为具有指定格式的输出。

例
下面的查询将给出'星期一，2015年11月16日'的getdate函数按照指定的格式，'D'表示星期名称。

SELECT FORMAT ( getdate(), 'D') 
CONCAT（）
单个字符串将作为输出，连接给定的参数值后。

例
以下查询将给出给定参数的'A，B，C'。

Select CONCAT('A',',','B',',','C') 
T-SQL - 日期函数
以下是MS SQL Server中的日期函数列表。

GETDATE（）
它将返回当前日期和时间。

语法
上述函数的语法:

GETDATE()
例
以下查询将返回当前日期以及MS SQL Server中的时间。

Select getdate() as currentdatetime
DATEPART（）
它将返回日期或时间的一部分。

语法
上述函数的语法:

DATEPART(datepart, datecolumnname)
例
示例1 -以下查询将返回MS SQL Server中当前日期的一部分。

Select datepart(day, getdate()) as currentdate
示例2 -以下查询将返回当前月份在MS SQL Server中的部分。

Select datepart(month, getdate()) as currentmonth
DATEADD（）
它将通过加或减日期和时间间隔显示日期和时间。

语法
上述函数的语法:

DATEADD(datepart, number, datecolumnname)
例
以下查询将返回MS SQL Server中当前日期和时间之后10天的日期和时间。

Select dateadd(day, 10, getdate()) as after10daysdatetimefromcurrentdatetime 
DATEDIFF（）
它将显示两个日期之间的日期和时间。

语法
上述函数的语法:

DATEDIFF(datepart, startdate, enddate)
例
以下查询将返回MS SQL Server中2015-11-16和2015-11-11之间的时间差异。

Select datediff(hour, 2015-11-16, 2015-11-11) as 
differencehoursbetween20151116and20151111 
CONVERT（）
它将以不同的格式显示日期和时间。

语法
上述函数的语法:

CONVERT(datatype, expression, style)
例
以下查询将以不同格式在MS SQL Server中返回日期和时间。

SELECT CONVERT(VARCHAR(19),GETDATE()) 
SELECT CONVERT(VARCHAR(10),GETDATE(),10) 
SELECT CONVERT(VARCHAR(10),GETDATE(),110)
T-SQL - 数值函数
MS SQL Server数字函数可以应用于数值数据，并返回数值数据。

下面是带有示例的数值函数列表。

ABS（）
输出给定值的绝对值。

例
以下查询将输出-22的绝对值:22。

Select ABS(-22)
ACOS（）
输出给定值的反余弦值。

例
以下查询将输出0的反余弦值:1.5707963267948966。

Select ACOS(0)
ASIN（）
输出给定值的正弦值。

例
以下查询将输出0的正弦值:0。

Select ASIN(0)
ATAN（）
输出给定值的反正切值。

例
以下查询将输出0的反正切值:0。

Select ATAN(0)
ATN2（）
输出给定值的方位角，也可以理解为计算复数 x+yi 的幅角。

例
以下查询将输出(0,-1)的方位角:0。

Select ATN2(0, -1)
请参考具有以下记录的CUSTOMERS表:

ID  NAME       AGE       ADDRESS             SALARY 
1   Ramesh     32        Ahmedabad           2000.00 
2   Khilan     25        Delhi               1500.00 
3   kaushik    23        Kota                2000.00 
4   Chaitali   25        Mumbai              6500.00 
5   Hardik     27        Bhopal              8500.00 
6   Komal      22        MP                  4500.00 
7   Muffy      24        Indore              10000.00 
BETWEEN（）
输出给定的两个表达式之间的值。

例
以下实例将输出薪水区间在2000到8500之间的所有薪水值:

SELECT salary from customers where salary between 2000 and 8500
上述命令将产生以下结果集:

salary 
2000.00 
2000.00 
6500.00 
8500.00 
4500.00
MIN（）
输出给定参数的最小值。

例
以下查询将给出customers表中'salary'最低值'1500.00'。

Select MIN(salary)from CUSTOMERS
MAX（）
输出给定参数的最大值。

例
以下查询将给出customers表中'salary'最大值'10000.00'。

Select MAX(salary)from CUSTOMERS
SQRT（）
输出给定值的平方根。

例
以下查询将输出4的平方根:2。

Select SQRT(4)
PI（）
该函数会输出PI(Π)的值。

例
下面的查询将输出3.14159265358979

Select PI()
CEILING（）
给定值向上舍入(正向无穷大的方向)后输出。

例
下面的查询将输出124。

Select CEILING(123.25)
FLOOR（）
给定值向下舍入(正向无穷小的方向)后输出。

例
下面的查询将输出123。

Select FLOOR(123.25) 
LOG（）
输出给定值的对数。

例
下面的查询将输出0。

Select LOG(1) 

* Create and query data
    The following sections walk you through using sqlcmd to create a new database, add data, and run a simple query.

    Create a new database
    The following steps create a new database named TestDB.
    
    From the sqlcmd command prompt, paste the following Transact-SQL command to create a test database:

#+BEGIN_SRC sql
CREATE DATABASE TestDB
#+END_SRC
On the next line, write a query to return the name of all of the databases on your server:
#+BEGIN_SRC sql 
SELECT Name from sys.Databases
#+END_SRC

The previous two commands were not executed immediately. You must type GO on a new line to execute the previous commands:
#+BEGIN_SRC sql 
GO
#+END_SRC

Insert data
Next create a new table, Inventory, and insert two new rows.

From the sqlcmd command prompt, switch context to the new TestDB database:
#+BEGIN_SRC sql
  
  USE TestDB
  Create new table named Inventory:

  CREATE TABLE Inventory (id INT, name NVARCHAR(50), quantity INT)
  Insert data into the new table:
#+END_SRC

#+BEGIN_SRC sql

INSERT INTO Inventory VALUES (1, 'banana', 150); INSERT INTO Inventory VALUES (2, 'orange', 154);
#+END_SRC

Type GO to execute the previous commands:

Select data
Now, run a query to return data from the Inventory table.

From the sqlcmd command prompt, enter a query that returns rows from the Inventory table where the quantity is greater than 152:
#+BEGIN_SRC sql
SELECT * FROM Inventory WHERE quantity > 152;
#+END_SRC

To end your sqlcmd session, type QUIT:
#+BEGIN_SRC sql
    QUIT
#+END_SRC

Connect from Windows
SQL Server tools on Windows connect to SQL Server instances on Linux in the same way they would connect to any remote SQL Server instance.

If you have a Windows machine that can connect to your Linux machine, try the same steps in this topic from a Windows command-prompt running sqlcmd. Just verify that you use the target Linux machine name or IP address rather than localhost, and make sure that TCP port 1433 is open. If you have any problems connecting from Windows, see connection troubleshooting recommendations.

For other tools that run on Windows but connect to SQL Server on Linux, see:

SQL Server Management Studio (SSMS)
Windows PowerShell
SQL Server Data Tools (SSDT)
Additional resources
For other installation scenarios, see the following resources:

Upgrade	Learn how to upgrade an existing installation of SQL Server on Linux
Uninstall	Uninstall SQL Server on Linux
Unattended install	Learn how to script the installation without prompts
Offline install	Learn how to manually download the packages for offline installation
To explore other ways to connect and manage SQL Server, explore the following tools:

Visual Studio Code	A cross-platform GUI code editor that run Transact-SQL statements with the mssql extension.
SQL Server Operations Studio	A cross-platform GUI database management utility.
mssql-cli	A cross-platform command-line interface for running Transact-SQL commands.
SQL Server Management Studio	A Windows-based GUI database management utility that can connect to and manage SQL Server instances on Linux.
