* 表视图
桶, 文件柜
|   |   |   |   |   |
|---+---+---+---+---|
|   |   |   |   |   |
|---+---+---+---+---|
|   |   |   |   |   |
| + | + | + | + | + |
|   |   |   |   |   |
|   |   |   |   |   |
表

| ID | name   | age | address  | phone |
|----+--------+-----+----------+-------|
|  1 | xiaoli |  30 | changzou | 12345 |
|  2 | xiaom  |  32 | suzou    | 12334 |
|  3 | hy     |  23 | nixia    | 32322 |

* mysql
** 查 
select * from emp;  #注释
** 进入
mysql -h 主机地址 -u 用户名 －p 用户密码 
** MySql 用户管理
mysql -uroot -p databasename;

** 增加用户
#格式:grant 权限 on 数据库.* to 用户名@登录主机 identified by '密码'
/*
如，增加一个用户 user1 密码为 password1，让其可以在本机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以 root 用户连入 mysql，然后键入以下命令： 
grant select,insert,update,delete on *.* to user1@localhost Identified by "password1"; 
如果希望该用户能够在任何机器上登陆 mysql，则将 localhost 改为"%"。 
如果你不想 user1 有密码，可以再打一个命令将密码去掉。 
grant select,insert,update,delete on mydb.* to user1@localhost identified by ""; 
*/

grant all privileges on wpj1105.* to sunxiao@localhost identified by '123';   #all privileges 所有权限

#----------------------------
** MySql 数据库操作基础
*** #显示数据库
    show databases;

*** #判断是否存在数据库 wpj1105,有的话先删除
    drop database if exists wpj1105;

*** #创建数据库
    create database wpj1105;

*** #删除数据库
    drop database wpj1105;

*** #使用该数据库
use wpj1105;

*** #显示数据库中的表
    show tables;

*** #先判断表是否存在,存在先删除
    drop table if exists student;

*** #创建表
create table student(
id int auto_increment primary key,
name varchar(50),
sex varchar(20),
date varchar(50),
content varchar(100)
)default charset=utf8;

*** #删除表
drop table student;

*** #查看表的结构
describe student;  #可以简写为 desc student;

*** #插入数据
insert into student values(null,'aa','男','1988-10-2','......');
insert into student values(null,'bb','女','1889-03-6','......');
insert into student values(null,'cc','男','1889-08-8','......');
insert into student values(null,'dd','女','1889-12-8','......');
insert into student values(null,'ee','女','1889-09-6','......');
insert into student values(null,'ff','null','1889-09-6','......');
*** #查询表中的数据
select * from student;
select id,name from student;

*** #修改某一条数据
update student set sex='男' where id=4;

*** #删除数据
delete from student where id=5;
*** # and 且
select * from student where date>'1988-1-2' and date<'1988-12-1';

# or 或
select * from student where date<'1988-11-2' or date>'1988-12-1';
   
#between
select * from student where date between '1988-1-2' and '1988-12-1';

*** #in 查询制定集合内的数据
select * from student where id in (1,3,5);

*** #排序 asc 升序  desc 降序
select * from student order by id asc;

#分组查询 #聚合函数 
select max(id),name,sex from student group by sex;

select min(date) from student;

select avg(id) as '求平均' from student;

select count(*) from student;   #统计表中总数

select count(sex) from student;   #统计表中性别总数  若有一条数据中 sex 为空的话,就不予以统计~

select sum(id) from student;

#查询第 i 条以后到第 j 条的数据(不包括第 i 条)
select * from student limit 2,5;  #显示 3-5 条数据

*** #巩固练习
create table c(
 id int primary key auto_increment,
 name varchar(10) not null,
 sex varchar(50) ,  #DEFAULT '男' ,
 age int unsigned, #不能为负值(如为负值 则默认为 0)
 sno int unique    #不可重复
);

drop table c;
desc c;

insert into c (id,name,sex,age,sno) values (null,'涛哥','男',68,1);
insert into c (id,name,sex,age,sno) values (null,'aa','男',68,2);
insert into c (id,name,sex,age,sno) values (null,'平平','男',35,3);
...

select * from c;

#修改数据 
update c set age=66 where id=2;
update c set name='花花',age=21,sex='女' where id=2
delete from c where age=21;

#常用查询语句
select name,age ,id from c
select * from c where age>40 and age<60;  #and
select * from c where age<40 or age<60;  #or
select * from c where age between 40 and 60 #between
select * from c where age in (30,48,68,99);     #in 查询指定集合内的数据
select * from c order by age desc;      #order by（asc 升序 des 降序）

#分组查询
select name,max(age) from c group by sex;  #按性别分组查年龄最大值
#聚合函数
select min(age) from c;
select avg(age) as '平均年龄 ' from c;
select count(*) from c;  #统计表中数据总数
select sum(age) from c;

#修改表的名字
#格式:alter table tbl_name rename to new_name
alter table c rename to a;
 
#表结构修改
create table test
(
id int not null auto_increment primary key, #设定主键
name varchar(20) not null default 'NoName', #设定默认值
department_id int not null,
position_id int not null,
unique (department_id,position_id) #设定唯一值
);

#修改表的名字
#格式:alter table tbl_name rename to new_name
alter table test rename to test_rename;

#向表中增加一个字段(列)
#格式:alter table tablename add columnname type;/alter table tablename add(columnname type);
alter table test add  columnname varchar(20);

#修改表中某个字段的名字
alter table tablename change columnname newcolumnname type;  #修改一个表的字段名
alter table test change name uname varchar(50);

select * from test;

#表 position 增加列 test
alter table position add(test char(10));
#表 position 修改列 test
alter table position modify test char(20) not null;
#表 position 修改列 test 默认值
alter table position alter test set default 'system';
#表 position 去掉 test 默认值
alter table position alter test drop default;
#表 position 去掉列 test
alter table position drop column test;
#表 depart_pos 删除主键
alter table depart_pos drop primary key;
#表 depart_pos 增加主键
alter table depart_pos add primary key PK_depart_pos
(department_id,position_id);

#用文本方式将数据装入数据库表中（例如 D:/mysql.txt）
load data local infile "D:/mysql.txt" into table MYTABLE;

*** #导入.sql 文件命令（例如 D:/mysql.sql）
source d:/mysql.sql;  #或者  /. d:/mysql.sql;
* sqlmode
** 特性  
*** 语法高亮 
  - ANSI
  - DB2
  - Informix
  - Ingres
  - Interbase
  - Linter
  - Microsoft
  - MySQL
  - Oracle
  - Postgres
  - Solid
  - SQLite
  - Sybase
  - Vertica
*** 交互
- REPL support via =SQLi= buffer.
*** 语法检查
	gem install sqlint
*** 开头大写
    sql-capitalize-keywords t
    黑名单  sql-capitalize-keywords-blacklist '("name" "varchar")
*** MS SQL server with ms-sql
If you’re trying to use MS SQL Server in sql-mode, and the Microsoft command-line query processors osql and isql are not available to you, try jisql, a free, Java-based “workalike” provided by the clever (and generous) folks at Xigole Systems, Inc. http://www.xigole.com/software/jisql.jsp. Apache license.

Another option for users lacking access to osql/isql is sqsh, another Java-based command-line SQL client. The primary advantage to sqsh is that it is in the Debian/Ubuntu repositories (I can’t speak for Fedora, etc.) making it easier to install. When using sqsh to connect to SQL Server, use M-x sql-sybase, not sql-ms. Otherwise, Emacs won’t pass the right command-line parameters and it won’t connect.

I wrote a Python utility that is a drop in replacement for sqlcmd/osql as far as SQLi is concerned. You can find it in https://github.com/sebasmonia/sqlcmdline. It uses ODBC so in theory should work in platforms other than Windows. customize-group SQL, change Sql Ms Program to “/path/to/sqlcmdline” (or compiled/batch if under Windows), and for Emacs up to version 25 you still need to fix the prompt-regex as mentioned below.

– SebastianMonia
** Key bindings
*** Highlighting

 | Key Binding | Description                       |
 |-------------+-----------------------------------|
 | ~SPC m h k~ | select a SQL dialect to highlight |

*** Inferior Process Interactions (SQLi)
 | Key Binding | Description                 |
 |-------------+-----------------------------|
 | ~SPC m b b~ | show the SQLi buffer name   |
 | ~SPC m b s~ | set the SQLi buffer         |
 | ~SPC m l a~ | List all objects            |
 | ~SPC m l t~ | list all objects in a table |

**** Send SQL queries to SQLi:

 | Key Binding | Description                                                                           |
 |-------------+---------------------------------------------------------------------------------------|
 | ~SPC m s b~ | Send the whole buffer to the SQLi buffer                                              |
 | ~SPC m s B~ | Send the whole buffer to the SQLi buffer and switch to it in =insert state=           |
 | ~SPC m s i~ | Start the SQLi process                                                                |
 | ~SPC m s f~ | Send the paragraph around point to the SQLi buffer                                    |
 | ~SPC m s F~ | Send the paragraph around point to the SQLi buffer and switch to it in =insert state= |
 | ~SPC m s q~ | Prompt for a string to send to the SQLi buffer                                        |
 | ~SPC m s Q~ | Prompt for a string to send to the SQLi buffer and switch to it in =insert state=     |
 | ~SPC m s r~ | Send the selected region to the SQLi buffer                                           |
 | ~SPC m s R~ | Send the selected region to the SQLi buffer and switch to it in =insert state=        |

*** SQLi buffer
 | Key Binding | Description                                                  |
 |-------------+--------------------------------------------------------------|
 | ~SPC m b r~ | rename buffer (follow up in the SQL buffer with ~SPC m b s~) |
 | ~SPC m b S~ | save the current connection                                  |

*** Code Formating
 | ~SPC m = c~ | capitalize SQL keywords in region (if capitalize is enabled) |
* oracle
1、查找表的所有索引（包括索引名，类型，构成列）：
select t.*,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表
2、查找表的主键（包括名称，构成列）：

select cu.* from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'P' and au.table_name = 要查询的表

3、查找表的唯一性约束（包括名称，构成列）：
select column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'U' and au.table_name = 要查询的表

4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：
select * from user_constraints c where c.constraint_type = 'R' and c.table_name = 要查询的表

查询外键约束的列名：
select * from user_cons_columns cl where cl.constraint_name = 外键名称

查询引用表的键的列名：
select * from user_cons_columns cl where cl.constraint_name = 外键引用表的键名

5、查询表的所有列及其属性
select t.*,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表

6、查询所有表
select* from tabs
* sqlserver2008 快捷键                                                                 
    CTRL       +       SHIFT       +       B                 生成解决方案       
    CTRL       +       F7                                           生成编译       
    CTRL       +       O                                            打开文件       
    CTRL       +       SHIFT       +       O                   打开项目       
    CTRL       +       SHIFT       +       C                显示类视图窗口       
    F4                                                               显示属性窗口       
    SHIFT       +       F4                                      显示项目属性窗口       
    CTRL       +       SHIFT       +       E                显示资源视图       
    F12                                                                转到定义       
    CTRL       +       F12                                        转到声明       
    CTRL       +       ALT       +       J                       对象浏览       
    CTRL       +       ALT       +       F1                     帮助目录       
    CTRL       +       F1                                          动态帮助           
    F1                                                                    帮助       
    SHIFT       +       F1                                     当前窗口帮助       
    CTRL       +       ALT       +       F3                   帮助-搜索       
    SHIFT       +       ALT       +       ENTER             全屏显示       
    CTRL       +       -                                           向后定位       
    CTRL       +       SHIFT       +       -                    向前定位       
    CTRL       +       F4                                      关闭文档窗口       
    CTRL       +       PAGE       DOWN                 光标定位到窗口上方       
    CTRL       +       PAGE       UP                       光标定位到窗口下方       
    CTRL       +       F6       
    CTRL       +       TAB                                   下一个文档窗口       
    CTRL       +       SHIFT       +       F6       
    CTRL       +       SHIFT       +       TAB           上一个文档窗口       
    ALT       +       F6                                       下一个面板窗口       
    CTRL       +       K,       CTRL       +       L      取消 remark       
    CTRL       +       K,       CTRL       +       C     注释选择的代码       
    CTRL       +       K,       CTRL       +       U     取消对选择代码的注释       
    CTRL       +       M,       CTRL       +       O      折叠代码定义       
    CTRL       +       M,       CTRL       +       L     展开代码定义       
    CTRL       +       DELETE                              删除至词尾       
    CTRL       +       BACKSPACE                        删除至词头       
    SHIFT       +       TAB                                  取消制表符       
    CTRL       +       U                                         转小写       
    CTRL       +       SHIFT       +       U                转大写       
    CTRL       +       SHIFT       +       END        选择至文档末尾       
    CTRL       +       SHIFT       +       HOME      选择至文档末尾开始       
    SHIFT       +       END                                选择至行尾       
    SHIFT       +       HOME                              选择至行开始处       
    SHIFT       +       ALT       +       END           　　垂直选择到最后尾       
    SHIFT       +       ALT       +       HOME         　　　　　　　　垂直选择到最前面       
    CTRL       +       A                                    　　　　　　　　 全选       
    CTRL       +       W　　　　　　　　　　　　　　　　　　　　　　选择当前单词       
    CTRL       +       SHIFT       +       PAGE       UP　　　　　　选择至本页前面       
    CTRL       +       SHIFT       +       PAGE       DOWN　　　　选择至本页后面       
    CTRL       +       END　　　　　　　　　　　　　　　　　　　　文档定位到最后       
    CTRL       +       HOME　　　　　　　　　　　　　　　　　　　文档定位到最前       
    CTRL       +       G 转到…       
    CTRL       +       K,       CTRL       +       P　　　　　　　　　　　上一个标签       
    CTRL       +       K,       CTRL       +       N　　　　　　　　　　　　下一个标签       
    ALT       +       F10　　　　　　　　　　　　　　　　　　　　调试-ApplyCodeChanges           
    CTRL       +       ALT+       Break　　　　　　　　　　　　　　停止调试       
    CTRL       +       SHIFT       +       F9      　　　　　　　　　　取消所有断点       
    CTRL       +       F9　　　　　　　　　　　　　　　　　　　　　允许中断       
    CTRL       +       SHIFT       +       F5   　　　　　　　　　　　　调试-重新开始       
    F5　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　运行调试       
    CTRL       +       F5　　　　　　　　　　　　　　　　　　　　　　运行不调试       
    F10　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　跨过程序执行       
    F11　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　单步逐句执行       
    CTRL       +       J　　　　　　　　　　　　　　　　　　　　　　　列出成员           
    CTRL       +       PAGE       DOWN　　　　　　　　　　　　　　下一个视图       
    CTRL       +       B　　　　　　　　　　　　　　　　　　　　　　格式-粗体       
    CTRL       +       SHIFT       +       T　　　　　　　　　　　　格式-文字缩进   

怀仁怀朴，唯真唯实。
* T-SQL 的一些关键字
  Print  向客户端返回用户信息
例：　　print '青苹果'         屏幕上就会显示“青苹果三个字“
Go      用来通知 SQL 一批语句的结束
Distinct   去掉重复值
Declare    用来声明变量(局部变量?????)
例：　　declare @a int
Set    为变量赋值

例：　　set @a='青苹果'
While  在 SQL 中用来循环(好像在 SQL 中用来做循环的关键字不多)

复制代码
语法：　　　　WHILE <条件表达式>
                 BEGIN
                    <命令行或程序块>
                   [BREAK]
                   [CONTINUE]
                   [命令行或程序块]
                 END
复制代码
While 比较重要，我们来做个例子加深一下对 While 循环的理解：

复制代码
declare @a int
set @a=1
while @a<5
begin 
print '青苹果'
set @a=@a+1
end

输出结果：青苹果
　　　　　青苹果
　　　　　青苹果
　　　　　青苹果
复制代码
if else    判断语句

判断语句用的还是比较多的我们还是来做个例子说明一下；

求：a、b、c 三个数的最大值？

复制代码
declare  @a int,@b int,@c int,@max  int
set @a=1 set @b=2 set @c=3 
if  @a>@b               
   set  @max=@a
else
   set  @max=@b
if  @max<@c
   set  @max=@c      
print   @max

输出结果：3

复制代码
begin end  用来设定一个程序块，将在 BEGIN…END 内的所有程序视为一个单元执行。

Exists     判断是否存在

Case   也是用来判断的，和 IF 语句差不多，它的格式为：

　CASE  <运算式>
     　　 WHEN <运算式 1> THEN  <结果 1>
          … 
           WHEN<运算式 n> THEN   <结果 n>
          [ELSE  <结果 n+1>]
  END
 Return 　　用于结束当前程序的执行，返回到上一个调用它的程序或其它程序。在括号内可指定一个返回值。

Goto 标示符  用来改变程序执行的流程，使程序跳到标有标识符的指定的程序行再继续往下执行。要注意的是作为跳转目标的标识符可为数字与字符的组合，但必须以“：”结尾，如：“1023：” “qingpingguo:”

复制代码
例子：
        declare @a int 
     　　set @a = 1  
　　　　　qingpignguo:       
　　　　　print @a       
     　　set @a = @a + 1 
     　　while @a < 6   
  　　　　goto qingpignguo

输出结果：12345
复制代码
最后一个给大家看个好玩的：

Waitfor    用来暂停程序执行，直到等待指定时间之后，或所设定的时间已到才继续往下运行程序。

语法：　　waitfor {delay '时间'|time '时间'}
解释：

（1）‘时间’必须为 DATETIME 类型数据，且不能包括日期，如‘10:12:05’

（2）DELAY:用来设定等待的时间长短，最多为 24 小时。(是一个时间间隔)

（3）TIME：用来设定等待结束的时间点（是一个具体的时间)

例子：
    waitfor  delay '00:00:03'
 　　print '你好,我是青苹果'
 　　go
以上就是 T-SQL 的所有内容了，接下来我们来利用最后的时间画几个图形：

直角三角形：

复制代码
declare @a int 
set @a=1
while(@a<11)
begin
print replace(space(@a),' ','*')
set @a=@a+1
end
复制代码
直角三角形 输出结果：

 

正方形：

复制代码
declare @a int
declare @b int
declare @c nvarchar(100)
set @a=1
set @b=1
set @c=''
while (@a<9)
begin
   while (@b<15)
   begin 
    set @c=@c+'*'
    set @b=@b+1
   end
    print @c 
set @a=@a+1
end
复制代码
 

正方形 输出结果：

 

菱形：

复制代码
declare @a int,@b int
set @a=1 set @b=15

if(@b%2!=1)
print '数字必须都是奇数'
else
while(@a<=@b)
begin
if(@a%2=1)
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
set @a=@a+1
end
set @a=@a-2
while (@a<=@b)
begin
if(@a%2=1)
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
set @a=@a-1    
if (@a<0)
break
end
复制代码
菱形 输出结果：

 

梯形：

复制代码
declare @a int,@b int
set @a=7 set @b=21
if(@a%2=1)
while(@a<@b)
begin
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
set @a=@a+2
end
复制代码
梯形 输出结果：

 

矩形：

复制代码
declare @a int
declare @b int
declare @c nvarchar(100)
set @a=1
set @b=1
set @c=''
while (@a<9)
begin
   while (@b<23)
   begin 
    set @c=@c+'*'
    set @b=@b+1
   end
    print @c 
set @a=@a+1
end
复制代码
矩形 输出结果：

 

圆形：

复制代码
declare @a int,@b int
set @a=9 set @b=13

while (@a<=@b)
begin
if(@a%2=1)
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
set @a=@a+1
end
set @a=@a-1
begin
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
end
while (@a<=@b)
begin
if(@a%2=1)
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
set @a=@a-1
if(@a<10)
break
end
set @a=@a-2
begin
print space((@b-@a)/2)+replace(space(@a),' ','*')+space((@b-@a)/2)
end
* Tsql
** 安装
   sqlcmd -S localhost -U SA -P '<YourPassword>'
   tsql -S 127.0.0.1 -U sa -P Wuming123  
*** 安装
**** Import the public repository GPG keys:
    wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -

**** Register the Microsoft SQL Server Ubuntu repository:(添加到仓库列表)
     sudo add-apt-repository "$(wget -qo- https://packages.microsoft.com/config/ubuntu/16.04/mssql-server-2017.list)"
**** 安装
     sudo apt-get update
     sudo apt-get install -y mssql-server
**** 设置 sa 的密码
     sudo /opt/mssql/bin/mssql-conf setup
**** 是否运行
     systemctl status mssql-server
**** 远程连接, 防火墙打开 1433 端口
**** 命令行工具
***** Import the public repository GPG keys:
      wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -

***** Register the Microsoft Ubuntu repository:
      sudo add-apt-repository "$(wget -qO- https://packages.microsoft.com/config/ubuntu/16.04/prod.list)"

***** 安装工具
 sudo apt-get update
 sudo apt-get install -y mssql-tools unixodbc-dev
***** 设置环境变量
      For convenience, add /opt/mssql-tools/bin/ to your PATH environment variable. 
      This enables you to run the tools without specifying the full path. Run the following commands 
      to modify the PATH for both login sessions and interactive/non-login sessions:
      
      echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
      echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
      source ~/.bashrc
      Sqlcmd is just one tool for connecting to SQL Server to run queries and perform management and development tasks. Other tools include:
*** 连接
    sqlcmd -S localhost -U SA -P '<YourPassword>'
    tsql -S 127.0.0.1 -U sa -P Wuming123  
    If you later decide to connect remotely, specify the machine name or IP address for the -S parameter, and make sure port 1433 is open on your firewall.
    远程连接 确保端口 1433 打开
** 数据类型
*** 精确数值类型
    bigint	-9,223,372,036,854,775,808	9,223,372,036,854,775,807
    int	2,147,483,648	2,147,483,647
    smallint	-32,768	32,767
    tinyint	0	255
    bit	0	1
    decimal	-10 ^ 38 加 1	10 ^ 38 -1
    numeric	-10 ^ 38 加 1	10 ^ 38 -1
    money	-922,337,203,685,477.5808	+922,337,203,685,477.5807
    smallmoney	-214,748.3648	+214,748.3647
    数字和小数是固定精度和标度数据类型，在功能上等效。

*** 近似数值类型
    Float	-1.79E + 308	1.79E + 308
    Real	-3.40E + 38	3.40E + 38
*** 日期和时间类型
    datetime (3.33 毫秒精度)
    1753 年 1 月 1 日	9999 年 12 月 31 日
    
    smalldatetime(1 分钟精度)
    1900 年 1 月 1 日	2079 年 6 月 6 日
    
    date(1 天的精度。在 SQL Server 2008 中引入)
    0001 年 1 月 1 日	9999 年 12 月 31 日
    
    datetimeoffset(100 纳秒的精度。在 SQL Server 2008 中引入)
    0001 年 1 月 1 日
    9999 年 12 月 31 日
    
    datetime2(100 纳秒的精度。在 SQL Server 2008 中引入)
    0001 年 1 月 1 日	9999 年 12 月 31 日
    
    time(100 纳秒的精度。在 SQL Server 2008 中引入)
    00：00：00.0000000	23：59：59.9999999
*** 字符型
     char 固定长度的非 Unicode 字符数据，最大长度为 8,000 个字符。
     varchar 最大长度为 8,000 个字符的可变长度非 Unicode 数据。
     Varchar (max) 可变长度的非 Unicode 数据，最大长度为 231 个字符（在 SQL Server 2005 中引入）。
     text 可变长度非 Unicode 数据，最大长度为 2,147,483,647 个字符。

*** Unicode
    nchar 固定长度的 Unicode 数据，最大长度为 4,000 个字符。
    nvarchar 最大长度为 4,000 个字符的可变长度 Unicode 数据。
    Nvarchar (max) 最大长度为 230 个字符的可变长度 Unicode 数据（在 SQL Server 2005 中引入）。
    ntext 最大长度为 1,073,741,823 个字符的可变长度 Unicode 数据。

*** 二进制字符串
 binary 固定长度二进制数据，最大长度为 8,000 字节。
 varbinary 最大长度为 8,000 字节的可变长度二进制数据。
 varbinary(max) 最大长度为 231 字节的可变长度二进制数据（在 SQL Server 2005 中引入）。
 image 最大长度为 2,147,483,647 字节的可变长度二进制数据。

*** 其他数据类型
    SQL_VARIANT -存储各种 SQL Server 支持的数据类型的值，text，ntext 和 timestamp 除外。
    TIMESTAMP -时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒(北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒)起至现在的总秒数。
    UNIQUEIDENTIFIER  -存储全局唯一标识符（GUID）。
    XML -存储 XML 数据。 您可以将 XML 实例存储在列或变量中（在 SQL Server 2005 中引入）。
    CURSOR -对游标的引用。
    TABLE -存储结果集以供稍后处理。
    HIERARCHYID -用于表示层次结构中位置的可变长度的系统数据类型（在 SQL Server 2008 中引入）。

** 运算符
*** 比较
    >，<，=，
*** 逻辑
    LIKE，NOT LIKE
    通配符
    百分号（％）百分号表示零个，一个或多个字符
    下划线（_）下划线表示单个数字或字符
** 使用
*** 显示库属性
**** 显示库 
     select [name] from [sysdatabases] order by [name]
     select name from sysdatabases
**** 显示库表
     select [id], [name] from [sysobjects] where [type] = 'u' order by [name]
     SELECT name FROM sysobjects WHERE xtype = 'U'
**** 查看表是否存在
     exec sp_columns TABLENAME
**** 查询表中字段 
     select [name] from [syscolumns] where [name] = 'tableXXX'order by [colid]
*** 操作库
**** 创建
     CREATE DATABASE $DATABASENAME
**** 删除
     DROP DATBASE $DATABASENAME
**** 使用某个库
     use $NAME
*** 操作表
**** 创建表
     字段自增 IDENTITY(1, 1)
  #+BEGIN_SRC sql
      CREATE TABLE $tablename( 
       ID   INT              NOT NULL, 
       NAME VARCHAR (20)     NOT NULL, 
       AGE  INT              NOT NULL, 
       ADDRESS  CHAR (25) , 
       SALARY   DECIMAL (18, 2),        
       PRIMARY KEY (ID));
  #+END_SRC
**** 删除表
     DROP TABLE $table_name;
**** 插入记录
     INSERT INTO $table_name [(column1, column2, column3,...columnN)]   
     VALUES (value1, value2, value3,...valueN); 

     所有列添加值，请确保值的顺序与表中的列的顺序相同。 
     INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
**** 使用另一个表填充一个表
     #+BEGIN_SRC sql
       INSERT INTO first_table_name  
               SELECT column1, column2, ...columnN  
                 FROM second_table_name 
                     [WHERE condition];
     #+END_SRC
**** 查询
     SELECT 语句用于从以结果表的形式返回从数据库中提取的数据。 这些结果表称为结果集。
     SELECT column1, column2, columnN FROM table_name;
**** 查几条
     SELECT TOP $N * FROM $tablename
**** 更新（UPDATE)
     #+BEGIN_SRC sql
         UPDATE table_name 
         SET column1 = value1, column2 = value2...., columnN = valueN 
         WHERE [condition];
     #+END_SRC

  您可以使用 AND 或 OR 运算符组合 N 个条件。

**** 删除（DELETE)
     #+BEGIN_SRC sql
     DELETE FROM table_name 
     WHERE [condition]; 
     #+END_SRC
**** 排序 ORDER BY
     #+BEGIN_SRC sql
          SELECT column-list  
       FROM table_name  
       [WHERE condition]  
       [ORDER BY column1, column2, .. columnN] [ASC | DESC];
       您可以在 ORDER BY 子句中使用多个列。 确保您使用的任何列进行排序，该列应该在列表中。
     #+END_SRC
**** 分组 GROUP BY
  #+BEGIN_SRC sql
  SELECT column1, column2 
  FROM table_name 
  WHERE [ conditions ] 
  GROUP BY column1, column2 
  ORDER BY column1, column2 

  SELECT NAME, SUM(SALARY) as [sum of salary] FROM CUSTOMERS 
     GROUP BY NAME;

  SELECT NAME, SUM(SALARY) as [sum of salary] FROM CUSTOMERS 
     GROUP BY NAME 
  #+END_SRC
**** 唯一 DISTINCT
     消除所有重复记录并仅提取唯一记录。
 #+BEGIN_SRC 
  SELECT DISTINCT column1, column2,.....columnN  
  FROM table_name 
  WHERE [condition] 
 #+END_SRC
**** 连接表
 #+BEGIN_SRC sql

  SELECT ID, NAME, AGE, AMOUNT 
     FROM CUSTOMERS, ORDERS 
     WHERE  CUSTOMERS.ID = ORDERS.CUSTOMER_ID 
  OR 

  SELECT A.ID, A.NAME, A.AGE, B.AMOUNT 
  FROM CUSTOMERS A inner join  ORDERS B on A.ID = B.Customer_ID 
 #+END_SRC
***** 连接类型:
   INNER JOIN -当两个表中都有匹配项时返回行。
   LEFT JOIN -返回左侧表中的所有行，即使右表中没有匹配项。
   RIGHT JOIN -返回右表中的所有行，即使左表中没有匹配项。
   FULL JOIN -在其中一个表中存在匹配项时返回行。
   SELF JOIN -这用于将表连接到自身，就像该表是两个表，临时重命名 MS SQL Server 语句中的至少一个表。
   CARTESIAN JOIN -返回两个或多个联接表中的记录集的笛卡尔乘积。

**** 子查询
  #+BEGIN_SRC sql
    SELECT column_name [, column_name ] 
    FROM   table1 [, table2 ] 
    WHERE  column_name OPERATOR 
       (SELECT column_name [, column_name ] 
       FROM table1 [, table2 ] 
       [WHERE]) 
   
    SELECT *  
       FROM CUSTOMERS
       WHERE ID IN (SELECT ID FROM CUSTOMERS WHERE SALARY > 4500)


    INSERT INTO table_name [ (column1 [, column2 ]) ] 
       SELECT [ *|column1 [, column2 ] 
       FROM table1 [, table2 ] 
       [ WHERE VALUE OPERATOR ]

    UPDATE table 
    SET column_name = new_value 
    [ WHERE OPERATOR [ VALUE ] 
       (SELECT COLUMN_NAME 
       FROM TABLE_NAME) 
       [ WHERE) ] 
   
    DELETE FROM TABLE_NAME 
    [ WHERE OPERATOR [ VALUE ] 
       (SELECT COLUMN_NAME 
       FROM TABLE_NAME) 
       [ WHERE) ] 
  #+END_SRC
**** 联合表 union
     字段必须相同, 字段值必须不同 
    字段值相同 ，用 union all 
    
** 存储过程
用于通过将相同的数据存储在数据库中来节省写入代码的时间，并通过传递参数获得所需的输出。

!可以用 ALERT 代替 Create
#+BEGIN_SRC sql
Create procedure <procedure_Name> 
As 
Begin 
<SQL Statement> 
End 
Go
#+END_SRC
#+BEGIN_SRC sql

    CREATE PROCEDURE SelectCustomerstabledata 
    AS 
    SELECT * FROM Testdb.Customers 
    GO
#+END_SRC
** 事务
   事务是针对数据库执行的工作单元。 事务是以逻辑顺序完成的单元或工作序列，无论是以用户的手动方式还是以某种数据库程序自动进行。
   实际上，你常常会将许多 SQL 操作分成一组事务一起执行。
*** 事务属性
事务具有以下四个标准属性，通常由首字母缩写 ACID 简称 -
原子性 -确保工作单元内的所有操作成功完成; 否则，事务在故障点处中止，并且先前的操作被回滚到它们的原先状态。
一致性 -确保数据库在成功提交的事务后正确更改状态。
隔离性 -事务之间是独立运行互不相关的。
持久性 -事务一旦被执行,即使系统故障,其结果依然有效。
*** 事务控制
    COMMIT-提交事务。
    ROLLBACK -回滚事务。
    SAVEPOINT -创建事务的回滚节点。
    SET TRANSACTION -设置事务名称。
    
    事务控制命令仅与 DML 命令 INSERT，UPDATE 和 DELETE 一起使用。 在创建表或删除它们时，不能使用它们，因为这些操作会在数据库中自动提交。
    为了在 MS SQL Server 中使用事务控制命令，我们必须以“begin tran”或 begin transaction 命令开始事务，否则这些命令将不起作用。

**** commit 命令
     COMMIT 命令是用于将事务调用的更改保存到数据库的事务命令。 此命令将自上次 COMMIT 或 ROLLBACK 命令以来将所有事务保存到数据库。
     
Begin Tran 
DELETE FROM CUSTOMERS 
   WHERE AGE = 25 
COMMIT 

**** ROLLBACK 命令
     ROLLBACK 命令是用于撤销尚未保存到数据库的事务的事务性命令。 此命令只能用于在发出最后一个 COMMIT 或 ROLLBACK 命令后撤消事务。

语法
以下是 ROLLBACK 命令的语法。

ROLLBACK
例
请参考具有以下记录的 CUSTOMERS 表:

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 
下面的命令将从 CUSTOMERS 表中删除年龄等于 25 的用户记录，然后使用 ROLLBACK 命令,回滚数据。

Begin Tran 
DELETE FROM CUSTOMERS 
   WHERE AGE = 25; 
ROLLBACK
使用 ROLLBACK 命令,删除操作不会影响表中的数据,执行后 CUSTOMERS 表结果集如下:
**** SAVEPOINT 命令
SAVEPOINT 命令可以使事务回滚到某个点节点，而不回滚整个事务。

语法
以下是 SAVEPOINT 命令的语法。

SAVE TRANSACTION SAVEPOINT_NAME
此命令仅用于在事务语句之间创建 SAVEPOINT。ROLLBACK 命令用于撤消一组事务。

以下是回滚到一个事务节点的语法。

ROLLBACK TO SAVEPOINT_NAME
在下面的示例中，我们将从 CUSTOMERS 表中删除三个不同的记录。 我们将在每次删除之前创建一个 SAVEPOINT，以便我们可以随时将 ROLLBACK 任何 SAVEPOINT 返回到其原始状态的相应数据。

例
请参考具有以下记录的 CUSTOMERS 表:

ID  NAME       AGE       ADDRESS          SALARY 
1   Ramesh     32        Ahmedabad        2000.00 
2   Khilan     25        Delhi            1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
以下是一系列操作

Begin Tran 
SAVE Transaction SP1 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 1  
1 row deleted. 
SAVE Transaction SP2 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 2 
1 row deleted.
SAVE Transaction SP3 
Savepoint created. 
DELETE FROM CUSTOMERS WHERE ID = 3 
1 row deleted.
三个删除已经发生，但是，我们改变了主意，决定 ROLLBACK 到 SAVEPOINT，我们确定为 SP2。 因为 SP2 是在第一次删除后创建的，所以最后两个删除被撤消

ROLLBACK Transaction SP2 
Rollback complete. 
请注意，我们回滚到 SP2 后，相当于只发生了第一次删除。

SELECT * FROM CUSTOMERS 
查询后的结果为 6 条记录:

ID  NAME       AGE       ADDRESS          SALARY 
2   Khilan     25        Ahmedabad        1500.00 
3   kaushik    23        Kota             2000.00 
4   Chaitali   25        Mumbai           6500.00 
5   Hardik     27        Bhopal           8500.00 
6   Komal      22        MP               4500.00 
7   Muffy      24        Indore           10000.00 
SET TRANSACTION 命令
SET TRANSACTION 命令可用于启动数据库事务。 此命令用于指定随后事务的特性。

语法
以下是 SET TRANSACTION 语法。

SET TRANSACTION ISOLATION LEVEL <Isolationlevel_name>
** 索引
 数据库中的索引与书本目录的索引方式非常相似
 索引加快了 SELECT 查询和 WHERE 子句，但它降低了 UPDATE 和 INSERT 语句的数据输入速度

 创建索引涉及 CREATE INDEX 语句，它允许你对索引进行命名，指定表和要索引的列，并指示索引是按升序还是按降序排列。
 索引也可以是唯一的，类似于 UNIQUE 约束，索引防止在具有索引的列的组合中出现重复条目。

CREATE INDEX 命令
以下是 CREATE INDEX 的基本语法。

语法
CREATE INDEX index_name ON table_name
单列索引
单列索引是基于仅一个表的单列创建的索引。以下是基本语法。

语法
CREATE INDEX index_name 
ON table_name (column_name)
例
CREATE INDEX singlecolumnindex 
ON customers (ID)
唯一索引
唯一索引不仅用于查找性能的提升，还可用于约束数据的完整性。唯一索引不允许将任何重复值插入到表中。以下是基本语法。

语法
CREATE UNIQUE INDEX index_name 
on table_name (column_name)
例
CREATE UNIQUE INDEX uniqueindex 
on customers (NAME)
复合索引
复合索引是对表的两个或多个列设置索引。以下是基本语法。

语法
CREATE INDEX index_name on table_name (column1, column2) 
例
CREATE INDEX compositeindex 
on customers (NAME, ID)
无论是创建单列索引还是复合索引，请考虑您可能在查询的 WHERE 子句中频繁使用的列作为过滤条件。

如果只使用一列，则应该选择单列索引。 如果在 WHERE 子句中经常使用两个或多个列作为过滤器，则复合索引将是最佳选择。

隐式索引
隐式索引是在创建对象时由数据库服务器自动创建的索引。 一般情况下数据库会将自动为主键约束和唯一约束创建索引。

DROP INDEX 命令
可以使用 MS SQL SERVER DROP 命令删除索引。 丢弃索引时应小心，因为性能可能会减慢，也可能得到改善。

语法
下面是基本的语法。

DROP INDEX tablename.index_name
什么时候避免索引？
虽然索引旨在提高数据库的性能，但有时应避免使用它们。以下几种情况应重新考虑是否使用索引

不应在小表上使用索引。

经常进行大批量更新或插入操作的表不应设置索引。

不应在可能含大量 NULL 值的列上使用索引。

频繁操作的列不应设置索引。

** 函数
*** 内置函数列表
    计数- COUNT 聚合函数用于计算在数据库表中的行数。
    max- MAX 聚合功能可以选择某列的最高（最大）值。
    MIN- MIN 聚合函数允许选择了某列的最低（最小）值。
    AVG- AVG 聚合函数选择对某些表列的平均值。
    SUM- SUM 聚合函数允许选择总让数字列。
    SQRT-这用于产生一个给定数目的平方根。
    RAND-这是用于产生使用 SQL 命令的随机数。
    concat-这是用来连接多个参数的参数。
*** 字符串函数
    ASCII('word') 字符转 ascii 码 
    CHAR() 输出 Ascii 码对应的字符
    Select CHAR(97)
    
    NCHAR（） 输出 Unicode 值对应的字符
    Select NCHAR(300)

    CHARINDEX（） 索引值, 忽略大小写
    Select CHARINDEX('G', 'KING') 
    以下查询将给出给定字符串表达式“KING”的“G”字符的起始位置。

    LEFT（） 制定长度的串
    给定字符串的左边部分，直到指定的字符数作为给定字符串的输出。
    Select LEFT('WORLD', 4)

RIGHT（）
给定字符串的右边部分，直到指定的字符数作为给定字符串的输出。
下面的查询将给出'DIA'字符串 3 个给定字符串'INDIA'的字符数。
Select RIGHT('INDIA', 3)

SUBSTRING（）
基于开始位置值和长度值的字符串的一部分将作为给定字符串的输出。
Select SUBSTRING ('WORLD', 1,3) 

LEN（）
字符数将作为给定字符串表达式的输出。
Select LEN('HELLO') 

LOWER（）
小写字符串将作为给定字符串数据的输出。

UPPER（）
大写字符串将作为给定字符串数据的输出。
Select UPPER('SqlServer')

LTRIM（）
字符串表达式将在删除前导空白后作为给定字符串数据的输出。
Select LTRIM('   WORLD')

RTRIM（）
字符串表达式将在删除尾部空格后作为给定字符串数据的输出。
Select RTRIM('INDIA   ') 

REPLACE（）
在用指定字符替换指定字符的所有出现后，字符串表达式将作为给定字符串数据的输出。
Select REPLACE('INDIA', 'I', 'K')

REPLICATE（）
重复字符串表达式将作为指定次数的给定字符串数据的输出。
以下查询将为“WORLD”字符串数据提供“WORLDWORLD”字符串。
Select REPLICATE('WORLD', 2)

REVERSE（）
反向字符串表达式将作为给定字符串数据的输出。
下面的查询将给出'WORLD'字符串数据的'DLROW'字符串。
Select REVERSE('WORLD')

SOUNDEX（）
返回四字符（SOUNDEX）代码，以评估两个给定字符串的相似性。
下面的查询将为'Smith'，'Smyth'字符串给出'S530'。
Select SOUNDEX('Smith'), SOUNDEX('Smyth')

DIFFERENCE（）
整数值将作为给定的两个表达式的输出。
以下查询将给出 4 个“Smith”，“Smyth”表达式。

Select Difference('Smith','Smyth') 
注 -如果输出值为 0，表示给定 2 个表达式之间的相似度较弱或没有相似性。

SPACE（）
字符串来作为的空格指定数量的输出。
下面的查询将给出'I LOVE INDIA'。

Select 'I'+space(1)+'LOVE'+space(1)+'INDIA'
STUFF（）
字符串表达式将作为给定字符串数据的输出，在从起始字符替换为指定字符的指定长度之后。

例
下面的查询将给出'ABCDEFGH'字符串数据的'AIJKFGH'字符串作为给定的起始字符和长度分别为 2 和 4，'IJK'作为指定的目标字符串。

Select STUFF('ABCDEFGH', 2,4,'IJK') 
STR（）
字符数据将作为给定数字数据的输出。

例
以下查询将给定 187.37 的 187.37，基于指定的长度为 6 和十进制为 2。

Select STR(187.369,6,2) 
UNICODE（）
整数值将作为给定表达式的第一个字符的输出。

例
以下查询将为 82 提供“RAMA”表达式。

Select UNICODE('RAMA') 
QUOTENAME（）
给定字符串将作为输出与指定的分隔符。

例
以下查询将为给定的“RAMA”字符串指定“RAMA”，因为我们指定双引号作为分隔符。

Select QUOTENAME('RAMA','"') 
PATINDEX（）
需要从指定的“I”位置的给定表达式开始第一个出现的位置。

下面的查询将给出'INDIA'的 1。
Select PATINDEX('I%','INDIA') 

FORMAT（）
给定表达式将作为具有指定格式的输出。
下面的查询将给出'星期一，2015 年 11 月 16 日'的 getdate 函数按照指定的格式，'D'表示星期名称。
SELECT FORMAT ( getdate(), 'D') 

CONCAT（）
单个字符串将作为输出，连接给定的参数值后。
以下查询将给出给定参数的'A，B，C'。

Select CONCAT('A',',','B',',','C') 
*** 日期函数
    GETDATE（）
    它将返回当前日期和时间。

    DATEPART（）
    它将返回日期或时间的一部分。

DATEPART(datepart, datecolumnname)
例
示例 1 -以下查询将返回 MS SQL Server 中当前日期的一部分。

Select datepart(day, getdate()) as currentdate
示例 2 -以下查询将返回当前月份在 MS SQL Server 中的部分。

Select datepart(month, getdate()) as currentmonth
DATEADD（）
它将通过加或减日期和时间间隔显示日期和时间。

语法
上述函数的语法:

DATEADD(datepart, number, datecolumnname)
例
以下查询将返回 MS SQL Server 中当前日期和时间之后 10 天的日期和时间。

Select dateadd(day, 10, getdate()) as after10daysdatetimefromcurrentdatetime 
DATEDIFF（）
它将显示两个日期之间的日期和时间。

语法
上述函数的语法:

DATEDIFF(datepart, startdate, enddate)
例
以下查询将返回 MS SQL Server 中 2015-11-16 和 2015-11-11 之间的时间差异。

Select datediff(hour, 2015-11-16, 2015-11-11) as 
differencehoursbetween20151116and20151111 
CONVERT（）
它将以不同的格式显示日期和时间。

语法
上述函数的语法:

CONVERT(datatype, expression, style)
例
以下查询将以不同格式在 MS SQL Server 中返回日期和时间。

SELECT CONVERT(VARCHAR(19),GETDATE()) 
SELECT CONVERT(VARCHAR(10),GETDATE(),10) 
SELECT CONVERT(VARCHAR(10),GETDATE(),110)
*** 数值函数
MS SQL Server 数字函数可以应用于数值数据，并返回数值数据。

下面是带有示例的数值函数列表。

ABS（）
输出给定值的绝对值。

例
以下查询将输出-22 的绝对值:22。

Select ABS(-22)
ACOS（）
输出给定值的反余弦值。

例
以下查询将输出 0 的反余弦值:1.5707963267948966。

Select ACOS(0)
ASIN（）
输出给定值的正弦值。

例
以下查询将输出 0 的正弦值:0。

Select ASIN(0)
ATAN（）
输出给定值的反正切值。

例
以下查询将输出 0 的反正切值:0。

Select ATAN(0)
ATN2（）
输出给定值的方位角，也可以理解为计算复数 x+yi 的幅角。

例
以下查询将输出(0,-1)的方位角:0。

Select ATN2(0, -1)
请参考具有以下记录的 CUSTOMERS 表:

ID  NAME       AGE       ADDRESS             SALARY 
1   Ramesh     32        Ahmedabad           2000.00 
2   Khilan     25        Delhi               1500.00 
3   kaushik    23        Kota                2000.00 
4   Chaitali   25        Mumbai              6500.00 
5   Hardik     27        Bhopal              8500.00 
6   Komal      22        MP                  4500.00 
7   Muffy      24        Indore              10000.00 
BETWEEN（）
输出给定的两个表达式之间的值。

例
以下实例将输出薪水区间在 2000 到 8500 之间的所有薪水值:

SELECT salary from customers where salary between 2000 and 8500
上述命令将产生以下结果集:

salary 
2000.00 
2000.00 
6500.00 
8500.00 
4500.00
MIN（）
输出给定参数的最小值。

例
以下查询将给出 customers 表中'salary'最低值'1500.00'。

Select MIN(salary)from CUSTOMERS
MAX（）
输出给定参数的最大值。

例
以下查询将给出 customers 表中'salary'最大值'10000.00'。

Select MAX(salary)from CUSTOMERS
SQRT（）
输出给定值的平方根。

例
以下查询将输出 4 的平方根:2。

Select SQRT(4)
PI（）
该函数会输出 PI(Π)的值。

例
下面的查询将输出 3.14159265358979

Select PI()
CEILING（）
给定值向上舍入(正向无穷大的方向)后输出。

例
下面的查询将输出 124。

Select CEILING(123.25)
FLOOR（）
给定值向下舍入(正向无穷小的方向)后输出。

Select FLOOR(123.25) 
下面的查询将输出 0。Select LOG(1) 
** 语句
*** return
命令用于结束当前程序的执行,返回到上一个调用它的程序或其他程序,其语法格式如下:

return   整数值或变量

return 语句要指定返回值,如果没有指定返回值,SQL Server 系统会根据程序执行的结果返回一个内定值,返回值含义如下所示:

返回值                        含义

0                                 程序执行成功

-1                               找不到对象

-2                               数据类型错误

-3                               死锁

-4                               违反权限原则

-5                               语法错误

-6                               用户造成的一般错误

-7                               资源错误

-8                               非致使的内部错误

-9                               已经达到系统的权限

-10,-11                      致使的内部不一致错误

-12                             表或指针破坏

-13                             数据库破坏

-14                             硬件错误
*** 流程控制
    BEGIN...END
    BREAK
    GOTO
    CONTINUE
    IF...ELSE
    WHILE
    RETURN
    WAITFOR
** 例子
   #+BEGIN_SRC sql
       DECLARE @var INT
          SET @var=5
          IF (@var>3)
          PRINT 'var 大于 3'
          ELSE
          PRINT 'here'
          go
   #+END_SRC
** set @docdate1=DATEADD(mm,  DATEDIFF(mm,0,@Monthid),  0)   --本月第一天
--set @ThisMonthBeginDay=dateadd(day,27,dateadd(month,-1,DATEADD(mm,  DATEDIFF(mm,0,@Monthid),  0))) --上月 28 号零点
--set @ThisMonthEndDay=dateadd(ms,-3,dateadd(day,27,DATEADD(mm,DATEDIFF(mm,0,@Monthid),0)))    --本月 27 号 23 点 59 分 59 秒
set @docdate2=DATEADD(ms,-3,DATEADD(mm,1,DATEADD(mm,DATEDIFF(mm,0,@Monthid),0)))  --本月最后一天 23 点 59 分 59
**  子查询
   -- 筛   选
   #+BEGIN_SRC sql
       SELECT * from  (
       SELECT   1  AS ID , 'zs' AS  CustomerName
       union
       SELECT   2  AS ID , 'lis' AS  CustomerName
       )a where ID=1
   #+END_SRC
** if  
   
if exists (select 1 where 1<>1)
	begin
		select 'hell'
	end
  
select a from atable
where exists (select * from xx)

any 
where x< ANY (select Y ...) 读成 “ where , for some Y,  X is less than Y"
** 权限管理 ( 保护数据 )
*** 赋予权限 
    GRANT INSERT
      ON customers
      TO mary
给 mary 对表 customers 插入的权限
** 检索数据
** 修改
*** 修改表结构 
    alter table
*** 视图
    create view
    drop view
*** 索引
    create index
    drop index
*** 模式
    create schema
*** Domain
*** 访问控制
    grant 
    revoke
*** 事务控制
    commit
    rollback
    set transaction
*** 编程 sql
    declare 定义查询游标
    explain
    open 
    fetch
    close 关闭游标
    prepare
    execute
** 常量 
   DAYS 天
** 字符串函数
   --截取字符串左边 3 个字符--
   select LEFT('Welcome to China!',7) as 结果 1
   --截取字符串右边 4 个字符--
   select RIGHT('Welcome to China!',6) as 结果 2
--截取字符串中间 6 个字符（第二个从哪个字符下标开始）
select SUBSTRING('Welcome to China!',9,2) as 结果 3
FIBillAmount
FIBillLackAmount
=======
*** 时间常量 
** 日期时间格式
   yyyy-mm-dd hh:mm:ss
** 浮点函数
 fabs(f1-f2)
 if( fabs(f1-f2) < 预先指定的精度）
* sp_executesql
  execute 相信大家都用的用熟了，简写为 exec,除了用来执行存储过程，一般都用来执行动态 Sql 
  sp_executesql，sql2005 中引入的新的系统存储过程，也是用来处理动态 sql 的, 如： 
  
  exec sp_executesql @sql, N'@count int out,@id varchar(20)', @cou out ,@id 
@sql 为拼成的动态 sql 
N'@count int out,@id varchar(20)'为拼成的动态 sql 内的参数列表 
@cou out,@id 为为动态 sql 内参数列表提供值的外部参数列表 

那么它们之间有什么区别呢？ 

１，它们之间最大的区别是嵌入式的参数，如下面一个语句 
#+BEGIN_SRC sql
  declare @sql   nvarchar(2000) 
  declare @id varchar(20) 
  set @id='1' 
  set @sql='select count(*) from emp where id=' + @id 
  exec @sql 
#+END_SRC
我想把得到的 count(*)传出来，用传统的 exec 是不好办到的，但是用 sp_executesql 则很容易就办到了： 
#+BEGIN_SRC sql
  declare @sql nvarchar(2000) 
  declare @cou int 
  declare @id varchar(20) 
  set @id='1' 
  set @sql='select @count=count(*) from emp where id=@id' 
  exec sp_executesql @sql, N'@count int out,@id varchar(20)', @cou out ,@id 
  print @cou 
#+END_SRC

2.性能 
可以看到，如果用 exec，由于每次传入的@id 不一样，所以每次生成的@sql 就不一样，这样每执行一次 Sql2005 就必须重新将要执行的动态 Sql 重新编译一次 
但是 sp_executesql 则不一样，由于将数值参数化，要执行的动态 Sql 永远不会变化，只是传入的参数的值在变化，那每次执行的时候就秒用重新编译，速度自然快多了哈！ 

注意： 
１.sp_executesql 要求动态 Sql 和动态 Sql 参数列表必须是 Nvarchar，比如上个例子的@sql,N'@count int out,@id varchar(20)'我记得在 sql2005 中 Varchar 也可以的，但是我打了 Sp3 补丁后就不行了，必须为 Nvarchar 
２.动态 Sql 的参数列表与外部提供值的参数列表顺序必需一致，如： 
N'@count int out,@id varchar(20)', @cou out,@id 
@count 对应 @cou,@id 对应@id 
如果不一致，必须显式标明，如： 
N'@count int out,@id varchar(20)', @id＝@id, @count=@cou out 
３.动态 SQl 的参数列表与外部提供参数的参数列表参数名可以同名
----------------------------------------------------------------------------------------------------------------------------------------------------------------

语法

 
sp_executesql [ @statement = ] statement
[ 
    { , [ @params = ] N'@parameter_name data_type [ OUT | OUTPUT ][ ,...n ]' } 
     { , [ @param1 = ] 'value1' [ ,...n ] }
]
参数

[ @statement = ] statement
包含 Transact-SQL 语句或批处理的 Unicode 字符串。statement 必须是 Unicode 常量或 Unicode 变量。不允许使用更复杂的 Unicode 表达式（例如使用 + 运算符连接两个字符串）。不允许使用字符常量。如果指定了 Unicode 常量，则必须使用 N 作为前缀。例如，Unicode 常量 N'sp_who' 是有效的，但是字符常量 'sp_who' 则无效。字符串的大小仅受可用数据库服务器内存限制。在 64 位服务器中，字符串大小限制为 2 GB，即 nvarchar(max) 的最大大小。

注意：
stmt 可以包含与变量名形式相同的参数，例如：N'SELECT * FROM HumanResources.Employee WHERE EmployeeID = @IDParameter'
stmt 中包含的每个参数在 @params 参数定义列表和参数值列表中均必须有对应项。

[ @params = ] N'@parameter_name data_type [ ,... n ] '
包含 stmt 中嵌入的所有参数定义的字符串。字符串必须是 Unicode 常量或 Unicode 变量。每个参数定义由参数名称和数据类型组成。n 是表示附加参数定义的占位符。在 statement 中指定的每个参数都必须在 @params 中定义。如果 stmt 中的 Transact-SQL 语句或批处理不包含参数，则不需要 @params。该参数的默认值为 NULL。

[ @param1 = ] 'value1'
参数字符串中定义的第一个参数的值。该值可以是 Unicode 常量，也可以是 Unicode 变量。必须为 stmt 中包含的每个参数提供参数值。如果 stmt 中的 Transact-SQL 语句或批处理没有参数，则不需要这些值。

[ OUT | OUTPUT ]
指示参数是输出参数。除非是公共语言运行 (CLR) 过程，否则 text、ntext 和 image 参数均可用作 OUTPUT 参数。使用 OUTPUT 关键字的输出参数可以为游标占位符，CLR 过程除外。

n
附加参数值的占位符。这些值只能为常量或变量，不能是很复杂的表达式（例如函数）或使用运算符生成的表达式。

返回代码值

0（成功）或非零（失败）

结果集

从生成 SQL 字符串的所有 SQL 语句返回结果集。

注释

在批处理、名称作用域和数据库上下文方面，sp_executesql 与 EXECUTE 的行为相同。sp_executesql stmt 参数中的 Transact-SQL 语句或批处理在执行 sp_executesql 语句时才编译。随后，将编译 stmt 中的内容，并将其作为执行计划运行。该执行计划独立于名为 sp_executesql 的批处理的执行计划。sp_executesql 批处理不能引用调用 sp_executesql 的批处理中声明的变量。sp_executesql 批处理中的本地游标或变量对调用 sp_executesql 的批处理是不可见的。对数据库上下文所做的更改只在 sp_executesql 语句结束前有效。

如果只更改了语句中的参数值，则 sp_executesql 可用来代替存储过程多次执行 Transact-SQL 语句。因为 Transact-SQL 语句本身保持不变，仅参数值发生变化，所以 SQL Server 查询优化器可能重复使用首次执行时所生成的执行计划。

注意：
若要改善性能，请在语句字符串中使用完全限定对象名。
sp_executesql 支持独立于 Transact-SQL 字符串设置参数值，如以下示例所示。

 	 
DECLARE @IntVariable int;
DECLARE @SQLString nvarchar(500);
DECLARE @ParmDefinition nvarchar(500);

/* Build the SQL string one time.*/
SET @SQLString =
     N'SELECT BusinessEntityID, NationalIDNumber, JobTitle, LoginID
       FROM AdventureWorks2008R2.HumanResources.Employee 
       WHERE BusinessEntityID = @BusinessEntityID';
SET @ParmDefinition = N'@BusinessEntityID tinyint';
/* Execute the string with the first parameter value. */
SET @IntVariable = 197;
EXECUTE sp_executesql @SQLString, @ParmDefinition,
                      @BusinessEntityID = @IntVariable;
/* Execute the same string with the second parameter value. */
SET @IntVariable = 109;
EXECUTE sp_executesql @SQLString, @ParmDefinition,
                      @BusinessEntityID = @IntVariable;
输出参数也可用于 sp_executesql。以下示例从 AdventureWorks2008R2.HumanResources.Employee 表中检索职务，并在输出参数@max_title 中返回它。

 	 
DECLARE @IntVariable int;
DECLARE @SQLString nvarchar(500);
DECLARE @ParmDefinition nvarchar(500);
DECLARE @max_title varchar(30);

SET @IntVariable = 197;
SET @SQLString = N'SELECT @max_titleOUT = max(JobTitle) 
   FROM AdventureWorks2008R2.HumanResources.Employee
   WHERE BusinessEntityID = @level';
SET @ParmDefinition = N'@level tinyint, @max_titleOUT varchar(30) OUTPUT';

EXECUTE sp_executesql @SQLString, @ParmDefinition, @level = @IntVariable, @max_titleOUT=@max_title OUTPUT;
SELECT @max_title;
替换 sp_executesql 中的参数的能力，与使用 EXECUTE 语句执行字符串相比，有下列优点：

因为在 sp_executesql 字符串中，Transact-SQL 语句的实际文本在两次执行之间并未改变，所以查询优化器应该能将第二次执行中的 Transact-SQL 语句与第一次执行时生成的执行计划匹配。因此，SQL Server 不必编译第二条语句。

Transact-SQL 字符串只生成一次。

整数参数按其本身格式指定。不需要转换为 Unicode。

权限

要求具有 public 角色的成员身份。

示例

A. 执行简单的 SELECT 语句

以下示例将创建并执行一个简单的 SELECT 语句，其中包含名为 @level 的嵌入参数。

 	 
EXECUTE sp_executesql 
          N'SELECT * FROM AdventureWorks2008R2.HumanResources.Employee 
          WHERE BusinessEntityID = @level',
          N'@level tinyint',
          @level = 109;
B. 执行动态生成的字符串

以下示例显示使用 sp_executesql 执行动态生成的字符串。该示例中的存储过程用于向一组表中插入数据，这些表用于划分一年的销售数据。一年中的每个月均有一个表，格式如下：

 	 
CREATE TABLE May1998Sales
    (OrderID int PRIMARY KEY,
    CustomerID int NOT NULL,
    OrderDate  datetime NULL
        CHECK (DATEPART(yy, OrderDate) = 1998),
    OrderMonth int
        CHECK (OrderMonth = 5),
    DeliveryDate datetime  NULL,
        CHECK (DATEPART(mm, OrderDate) = OrderMonth)
    )
此示例存储过程将动态生成并执行 INSERT 语句，以便向正确的表中插入新订单。此示例使用订货日期生成应包含数据的表的名称，然后将此名称并入 INSERT 语句中。

注意：
这是一个简单的 sp_executesql 示例。此示例不包含错误检查以及业务规则检查，例如确保订单号在各个表之间不重复。
 	 
CREATE PROCEDURE InsertSales @PrmOrderID INT, @PrmCustomerID INT,
                 @PrmOrderDate DATETIME, @PrmDeliveryDate DATETIME
AS
DECLARE @InsertString NVARCHAR(500)
DECLARE @OrderMonth INT

-- Build the INSERT statement.
SET @InsertString = 'INSERT INTO ' +
       /* Build the name of the table. */
       SUBSTRING( DATENAME(mm, @PrmOrderDate), 1, 3) +
       CAST(DATEPART(yy, @PrmOrderDate) AS CHAR(4) ) +
       'Sales' +
       /* Build a VALUES clause. */
       ' VALUES (@InsOrderID, @InsCustID, @InsOrdDate,' +
       ' @InsOrdMonth, @InsDelDate)'

/* Set the value to use for the order month because
   functions are not allowed in the sp_executesql parameter
   list. */
SET @OrderMonth = DATEPART(mm, @PrmOrderDate)

EXEC sp_executesql @InsertString,
     N'@InsOrderID INT, @InsCustID INT, @InsOrdDate DATETIME,
       @InsOrdMonth INT, @InsDelDate DATETIME',
     @PrmOrderID, @PrmCustomerID, @PrmOrderDate,
     @OrderMonth, @PrmDeliveryDate

GO
在该过程中使用 sp_executesql 比使用 EXECUTE 执行字符串更有效。使用 sp_executesql 时，只生成 12 个版本的 INSERT 字符串，每个月的表对应 1 个字符串。使用 EXECUTE 时，因为参数值不同，每个 INSERT 字符串均是唯一的。尽管两种方法生成的批处理数相同，但因为 sp_executesql 生成的 INSERT 字符串都相似，所以查询优化器更有可能重复使用执行计划。

C. 使用 OUTPUT 参数

以下示例使用 OUTPUT 参数将由 SELECT 语句生成的结果集存储于 @SQLString 参数中。然后将执行两个使用 OUTPUT 参数值的 SELECT 语句。

 	 
USE AdventureWorks2008R2;
GO
DECLARE @SQLString nvarchar(500);
DECLARE @ParmDefinition nvarchar(500);
DECLARE @SalesOrderNumber nvarchar(25);
DECLARE @IntVariable int;
SET @SQLString = N'SELECT @SalesOrderOUT = MAX(SalesOrderNumber)
    FROM Sales.SalesOrderHeader
    WHERE CustomerID = @CustomerID';
SET @ParmDefinition = N'@CustomerID int,
    @SalesOrderOUT nvarchar(25) OUTPUT';
SET @IntVariable = 22276;
EXECUTE sp_executesql
    @SQLString
    ,@ParmDefinition
    ,@CustomerID = @IntVariable
    ,@SalesOrderOUT = @SalesOrderNumber OUTPUT;
-- This SELECT statement returns the value of the OUTPUT parameter.
SELECT @SalesOrderNumber;
-- This SELECT statement uses the value of the OUTPUT parameter in
-- the WHERE clause.
SELECT OrderDate, TotalDue
FROM Sales.SalesOrderHeader
WHERE SalesOrderNumber = @SalesOrderNumber;
* 游标
  #+BEGIN_SRC sql
         use database1
         declare my_cursor cursor scroll dynamic
     /**//*scroll 表示可随意移动游标指针（否则只能向前），dynamic 表示可以读写游标（否则游标只读）*/
    for
    select productname from  product
    open my_cursor
    declare @pname sysname
    fetch next from my_cursor into @pname
    while(@@fetch_status=0)
      begin
        print 'Product Name: ' + @pname
        fetch next from my_cursor into @pname
      end
--    fetch first from my_cursor into @pname -- 获取第一个
 --   print @pname
    /**//*update product set productname='zzg' where current of my_cursor */
    /**//*delete from product where current of my_cursor */
    close my_cursor
    deallocate my_cursor
  #+END_SRC

  


					----更新已开发票数量和未开发票数量
					UPDATE CP_ProductOutSub
					SET FIBillLackAmount =Outqty -ISNULL(FIBillAmount,0) - @BillAmount,
					FIBillAmount =ISNULL(FIBillAmount,0) + @BillAmount				
					WHERE (ID = @CP_ProductOutSub_ID)

					IF @@ROWCOUNT<>1 OR @@error<>0
						BEGIN
							ROLLBACK TRAN
							RAISERROR('更新成品已开发票数量和未开发票数量出错，请核实!',16,1) WITH SETERROR
							RETURN
						END
* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
　　right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
　　inner join(等值连接) 只返回两个表中联结字段相等的行
* sqlserver 日期与字符串之间的转换
** 1、日期时间转字符串

Select CONVERT(varchar(100), GETDATE(), 0): 05 16 2006  10:57AM
Select CONVERT(varchar(100), GETDATE(), 1): 05/16/06
Select  CONVERT(varchar(100), GETDATE(), 2): 06.05.16
Select CONVERT(varchar(100),  GETDATE(), 3): 16/05/06
Select CONVERT(varchar(100), GETDATE(), 4):  16.05.06
Select CONVERT(varchar(100), GETDATE(), 5): 16-05-06
Select  CONVERT(varchar(100), GETDATE(), 6): 16 05 06
Select CONVERT(varchar(100),  GETDATE(), 7): 05 16, 06
Select CONVERT(varchar(100), GETDATE(), 8):  10:57:46
Select CONVERT(varchar(100), GETDATE(), 9): 05 16 2006  10:57:46:827AM
Select CONVERT(varchar(100), GETDATE(), 10):  05-16-06
Select CONVERT(varchar(100), GETDATE(), 11): 06/05/16
Select  CONVERT(varchar(100), GETDATE(), 12): 060516
Select CONVERT(varchar(100),  GETDATE(), 13): 16 05 2006 10:57:46:937
Select CONVERT(varchar(100),  GETDATE(), 14): 10:57:46:967
Select CONVERT(varchar(100), GETDATE(), 20):  2006-05-16 10:57:47
Select CONVERT(varchar(100), GETDATE(), 21): 2006-05-16  10:57:47.157
Select CONVERT(varchar(100), GETDATE(), 22): 05/16/06 10:57:47  AM
Select CONVERT(varchar(100), GETDATE(), 23): 2006-05-16
Select  CONVERT(varchar(100), GETDATE(), 24): 10:57:47
Select CONVERT(varchar(100),  GETDATE(), 25): 2006-05-16 10:57:47.250
Select CONVERT(varchar(100),  GETDATE(), 100): 05 16 2006 10:57AM
Select CONVERT(varchar(100), GETDATE(),  101): 05/16/2006
Select CONVERT(varchar(100), GETDATE(), 102):  2006.05.16
Select CONVERT(varchar(100), GETDATE(), 103): 16/05/2006
Select  CONVERT(varchar(100), GETDATE(), 104): 16.05.2006
Select  CONVERT(varchar(100), GETDATE(), 105): 16-05-2006
Select  CONVERT(varchar(100), GETDATE(), 106): 16 05 2006
Select  CONVERT(varchar(100), GETDATE(), 107): 05 16, 2006
Select  CONVERT(varchar(100), GETDATE(), 108): 10:57:49
Select CONVERT(varchar(100),  GETDATE(), 109): 05 16 2006 10:57:49:437AM
Select CONVERT(varchar(100),  GETDATE(), 110): 05-16-2006
Select CONVERT(varchar(100), GETDATE(), 111):  2006/05/16
Select CONVERT(varchar(100), GETDATE(), 112): 20060516
Select  CONVERT(varchar(100), GETDATE(), 113): 16 05 2006 10:57:49:513
Select  CONVERT(varchar(100), GETDATE(), 114): 10:57:49:547
Select  CONVERT(varchar(100), GETDATE(), 120): 2006-05-16 10:57:49
Select  CONVERT(varchar(100), GETDATE(), 121): 2006-05-16 10:57:49.700
Select  CONVERT(varchar(100), GETDATE(), 126): 2006-05-16T10:57:49.827
Select  CONVERT(varchar(100), GETDATE(), 130): 18 ???? ?????? 1427  10:57:49:907AM
Select CONVERT(varchar(100), GETDATE(), 131): 18/04/1427  10:57:49:920AM

** 2、Sql Server 日期与时间函数

1.  当前系统日期、时间
select getdate()

2. dateadd  在向指定日期加上一段时间的基础上，返回新的 datetime 值
例如：向日期加上 2 天
select dateadd(day,2,'2004-10-15')  --返回：2004-10-17 00:00:00.000

3. datediff 返回跨两个指定日期的日期和时间边界数。
select datediff(day,'2004-09-01','2004-09-18')   --返回：17

4. datepart 返回代表指定日期的指定日期部分的整数。
SELECT DATEPART(month, '2004-10-15')  --返回 10

5. datename 返回代表指定日期的指定日期部分的字符串
SELECT datename(weekday, '2004-10-15')  --返回：星期五

6. day(), month(),year() --可以与 datepart 对照一下
select 当前日期=convert(varchar(10),getdate(),120) ,当前时间=convert(varchar(8),getdate(),114)
select datename(dw,'2004-10-15')
select 本年第多少周=datename(week,'2004-10-15'),今天是周几=datename(weekday,'2004-10-15')

3、SQL Server 日期函数     参数/功能
GetDate( )    返回系统目前的日期与时间

DateDiff (interval,date1,date2)   以 interval 指定的方式，返回 date2 与 date1 两个日期之间的差值 date2-date1

DateAdd (interval,number,date)   以 interval 指定的方式，加上 number 之后的日期

DatePart (interval,date)    返回日期 date 中，interval 指定部分所对应的整数值

DateName (interval,date)   返回日期 date 中，interval 指定部分所对应的字符串名称

参数 interval 的设定值如下：

值缩写（Sql Server） (Access 和 ASP) 说明

Year Yy yyyy 年 1753 ~ 9999

Quarter Qq q   季 1 ~ 4

Month Mm m   月 1 ~ 12

Day of year Dy y  一年的日数,一年中的第几日 1-366

Day Dd d   日，1-31

Weekday Dw w 一周的日数，一周中的第几日 1-7

Week Wk ww  周，一年中的第几周 0 ~ 51

Hour Hh h   时 0 ~ 23

Minute Mi n  分钟 0 ~ 59

Second Ss s 秒 0 ~ 59

Millisecond Ms - 毫秒 0 ~ 999

Access 和 Asp 中用 date()和 now()取得系统日期时间；其中 DateDiff,DateAdd,DatePart 也同是能用于 Access 和 asp 中，这些函数的用法也类似。

4、SQL Server 日期函数举例

1.GetDate() 用于 sql server :select GetDate()

2.DateDiff('s','2005-07-20','2005-7-25 22:56:32')返回值为 514592 秒

DateDiff('d','2005-07-20','2005-7-25 22:56:32')返回值为 5 天

3.DatePart('w','2005-7-25 22:56:32')返回值为 2 即星期一(周日为 1，周六为 7)

DatePart('d','2005-7-25 22:56:32')返回值为 25 即 25 号

DatePart('y','2005-7-25 22:56:32')返回值为 206 即这一年中第 206 天

DatePart('yyyy','2005-7-25 22:56:32')返回值为 2005 即 2005 年
* 字符转换为日期时,Style 的使用

--1. Style=101 时,表示日期字符串为:mm/dd/yyyy 格式
SELECT CONVERT(datetime,'11/1/2003',101)
--结果:2003-11-01 00:00:00.000

--2. Style=101 时,表示日期字符串为:dd/mm/yyyy 格式
SELECT CONVERT(datetime,'11/1/2003',103)
--结果:2003-01-11 00:00:00.000

 

/*== 日期转换为字符串 ==*/
DECLARE @dt datetime
SET @dt='2003-1-11'

--1. Style=101 时,表示将日期转换为:mm/dd/yyyy 格式
SELECT CONVERT(varchar,@dt,101)
--结果:01/11/2003

--2. Style=103 时,表示将日期转换为:dd/mm/yyyy 格式
SELECT CONVERT(varchar,@dt,103)
--结果:11/01/2003


/*== 这是很多人经常犯的错误,对非日期型转换使用日期的 style 样式 ==*/
SELECT CONVERT(varchar,'2003-1-11',101)
--结果:2003-1-11

--1.
/*--说明
SET DATEFORMAT 设置对使用 CONVERT 把字符型日期转换为日期的处理也具有影响
但不影响明确指定了 style 的 CONVERT 处理。
--*/

--示例 ，在下面的示例中，第一个 CONVERT 转换未指定 style，转换的结果受 SET DATAFORMAT 的影响，第二个 CONVERT 转换指定了 style，转换结果受 style 的影响。
--设置输入日期顺序为 日/月/年
SET DATEFORMAT DMY

--不指定 Style 参数的 CONVERT 转换将受到 SET DATEFORMAT 的影响
SELECT CONVERT(datetime,'2-1-2005')
--结果: 2005-01-02 00:00:00.000

--指定 Style 参数的 CONVERT 转换不受 SET DATEFORMAT 的影响
SELECT CONVERT(datetime,'2-1-2005',101)
--结果: 2005-02-01 00:00:00.000
GO

--2.
/*--说明

如果输入的日期包含了世纪部分，则对日期进行解释处理时
年份的解释不受 SET DATEFORMAT 设置的影响。
--*/

--示例，在下面的代码中，同样的 SET DATEFORMAT 设置，输入日期的世纪部分与不输入日期的世纪部分，解释的日期结果不同。
DECLARE @dt datetime

--设置 SET DATEFORMAT 为:月日年
SET DATEFORMAT MDY

--输入的日期中指定世纪部分
SET @dt='01-2002-03'
SELECT @dt
--结果: 2002-01-03 00:00:00.000

--输入的日期中不指定世纪部分
SET @dt='01-02-03'
SELECT @dt
--结果: 2003-01-02 00:00:00.000
GO

--3.
/*--说明

如果输入的日期不包含日期分隔符，那么 SQL Server 在对日期进行解释时
将忽略 SET DATEFORMAT 的设置。
--*/

--示例，在下面的代码中，不包含日期分隔符的字符日期，在不同的 SET DATEFORMAT 设置下，其解释的结果是一样的。
DECLARE @dt datetime

--设置 SET DATEFORMAT 为:月日年
SET DATEFORMAT MDY
SET @dt='010203'
SELECT @dt
--结果: 2001-02-03 00:00:00.000

--设置 SET DATEFORMAT 为:日月年
SET DATEFORMAT DMY
SET @dt='010203'
SELECT @dt
--结果: 2001-02-03 00:00:00.000

--输入的日期中包含日期分隔符
SET @dt='01-02-03'
SELECT @dt
--结果: 2003-02-01 00:00:00.000

--以下示例演示了在不同的语言环境(SET LANGUAGE)下，DATENAME 与 CONVERT 函数的不同结果。
USE master

--设置会话的语言环境为: English
SET LANGUAGE N'English'
SELECT 
DATENAME(Month,GETDATE()) AS [Month],
DATENAME(Weekday,GETDATE()) AS [Weekday],
CONVERT(varchar,GETDATE(),109) AS [CONVERT]
/*--结果:
Month    Weekday   CONVERT
------------- -------------- -------------------------------
March    Tuesday   Mar 15 2005 8:59PM
--*/

--设置会话的语言环境为: 简体中文
SET LANGUAGE N'简体中文'
SELECT 
DATENAME(Month,GETDATE()) AS [Month],
DATENAME(Weekday,GETDATE()) AS [Weekday],
CONVERT(varchar,GETDATE(),109) AS [CONVERT]
/*--结果
* 字符串转日期时间：
convert(datetime,'2017-12-12 00:00:01', 20)
日期时间转字符串：
Select CONVERT(varchar(100), GETDATE(), 0): 05 16 2006 10:57AM   
Select CONVERT(varchar(100), GETDATE(), 1): 05/16/06   
Select CONVERT(varchar(100), GETDATE(), 2): 06.05.16   
Select CONVERT(varchar(100), GETDATE(), 3): 16/05/06   
Select CONVERT(varchar(100), GETDATE(), 4): 16.05.06   
Select CONVERT(varchar(100), GETDATE(), 5): 16-05-06   
Select CONVERT(varchar(100), GETDATE(), 6): 16 05 06   
Select CONVERT(varchar(100), GETDATE(), 7): 05 16, 06   
Select CONVERT(varchar(100), GETDATE(), 8): 10:57:46   
Select CONVERT(varchar(100), GETDATE(), 9): 05 16 2006 10:57:46:827AM   
Select CONVERT(varchar(100), GETDATE(), 10): 05-16-06   
Select CONVERT(varchar(100), GETDATE(), 11): 06/05/16   
Select CONVERT(varchar(100), GETDATE(), 12): 060516   
Select CONVERT(varchar(100), GETDATE(), 13): 16 05 2006 10:57:46:937   
Select CONVERT(varchar(100), GETDATE(), 14): 10:57:46:967   
Select CONVERT(varchar(100), GETDATE(), 20): 2006-05-16 10:57:47   
Select CONVERT(varchar(100), GETDATE(), 21): 2006-05-16 10:57:47.157   
Select CONVERT(varchar(100), GETDATE(), 22): 05/16/06 10:57:47 AM   
Select CONVERT(varchar(100), GETDATE(), 23): 2006-05-16   
Select CONVERT(varchar(100), GETDATE(), 24): 10:57:47   
Select CONVERT(varchar(100), GETDATE(), 25): 2006-05-16 10:57:47.250   
Select CONVERT(varchar(100), GETDATE(), 100): 05 16 2006 10:57AM   
Select CONVERT(varchar(100), GETDATE(), 101): 05/16/2006   
Select CONVERT(varchar(100), GETDATE(), 102): 2006.05.16   
Select CONVERT(varchar(100), GETDATE(), 103): 16/05/2006   
Select CONVERT(varchar(100), GETDATE(), 104): 16.05.2006   
Select CONVERT(varchar(100), GETDATE(), 105): 16-05-2006   
Select CONVERT(varchar(100), GETDATE(), 106): 16 05 2006   
Select CONVERT(varchar(100), GETDATE(), 107): 05 16, 2006   
Select CONVERT(varchar(100), GETDATE(), 108): 10:57:49   
Select CONVERT(varchar(100), GETDATE(), 109): 05 16 2006 10:57:49:437AM   
Select CONVERT(varchar(100), GETDATE(), 110): 05-16-2006   
Select CONVERT(varchar(100), GETDATE(), 111): 2006/05/16   
Select CONVERT(varchar(100), GETDATE(), 112): 20060516   
Select CONVERT(varchar(100), GETDATE(), 113): 16 05 2006 10:57:49:513   
Select CONVERT(varchar(100), GETDATE(), 114): 10:57:49:547   
Select CONVERT(varchar(100), GETDATE(), 120): 2006-05-16 10:57:49   
Select CONVERT(varchar(100), GETDATE(), 121): 2006-05-16 10:57:49.700   
Select CONVERT(varchar(100), GETDATE(), 126): 2006-05-16T10:57:49.827   
Select CONVERT(varchar(100), GETDATE(), 130): 18 ???? ?????? 1427 10:57:49:907AM  
在 SQL 数据库中，有一类函数是不得不提的，那就是 SQL Server 日期时间函数，这是 SQL Server 处理日期和时间最常用的函数，下面就将为介绍这类函数。


Sql Server 日期与时间函数:

1.  当前系统日期、时间 

select getdate() 
1. dateadd  在向指定日期加上一段时间的基础上，返回新的 datetime 值
例如：向日期加上 2 天 
select dateadd(day,2,'2004-10-15')  --返回：2004-10-17 00:00:00.000
1. datediff 返回跨两个指定日期的日期和时间边界数。
select datediff(day,'2004-09-01','2004-09-18')   --返回：17
1. datepart 返回代表指定日期的指定日期部分的整数。
SELECT DATEPART(month, '2004-10-15')  --返回 10
1. datename 返回代表指定日期的指定日期部分的字符串
SELECT datename(weekday, '2004-10-15')  --返回：星期五
1. day(), month(),year() --可以与 datepart 对照一下
select 当前日期=convert(varchar(10),getdate(),120) ,当前时间=convert(varchar(8),getdate(),114)
select datename(dw,'2004-10-15')
select 本年第多少周=datename(week,'2004-10-15'),今天是周几=datename(weekday,'2004-10-15')


SQL Server 日期函数     参数/功能

GetDate( )    返回系统目前的日期与时间
DateDiff (interval,date1,date2)   以 interval 指定的方式，返回 date2 与 date1 两个日期之间的差值 date2-date1
DateAdd (interval,number,date)   以 interval 指定的方式，加上 number 之后的日期
DatePart (interval,date)    返回日期 date 中，interval 指定部分所对应的整数值
DateName (interval,date)   返回日期 date 中，interval 指定部分所对应的字符串名称
参数 interval 的设定值如下：
值缩写（Sql Server） (Access 和 ASP) 说明
Year Yy yyyy 年 1753 ~ 9999
Quarter Qq q   季 1 ~ 4
Month Mm m   月 1 ~ 12
Day of year Dy y  一年的日数,一年中的第几日 1-366
Day Dd d   日，1-31
Weekday Dw w 一周的日数，一周中的第几日 1-7
Week Wk ww  周，一年中的第几周 0 ~ 51
Hour Hh h   时 0 ~ 23
Minute Mi n  分钟 0 ~ 59
Second Ss s 秒 0 ~ 59
Millisecond Ms - 毫秒 0 ~ 999
Access 和 Asp 中用 date()和 now()取得系统日期时间；其中 DateDiff,DateAdd,DatePart 也同是能用于 Access 和 asp 中，这些函数的用法也类似。


SQL Server 日期函数举例：


1.GetDate() 用于 sql server :select GetDate()
2.DateDiff('s','2005-07-20','2005-7-25 22:56:32')返回值为 514592 秒
DateDiff('d','2005-07-20','2005-7-25 22:56:32')返回值为 5 天
3.DatePart('w','2005-7-25 22:56:32')返回值为 2 即星期一(周日为 1，周六为 7)
DatePart('d','2005-7-25 22:56:32')返回值为 25 即 25 号
DatePart('y','2005-7-25 22:56:32')返回值为 206 即这一年中第 206 天
DatePart('yyyy','2005-7-25 22:56:32')返回值为 2005 即 2005 年
* commit transcation :SQL 多步操作之后，提交事务，此时数据才真正保存到数据库
rollback transcation:SQL 多步操作发生错误，调用此语句，数据回滚到最初始状态。
* 以下是出现错误的 SQL 部分语句：

BEGIN TRAN
--进行判断，不符合条件就回滚，不执行其他操作
IF NOT EXISTS(SELECT [ID] FROM [TestTable] WHERE NO='123')
BEGIN
ROLLBACK TRAN;
END

--这里执行其他 SQL 操作语句。
UPDATE TestTable SET NO='312' WHERE NO='122'

--如果有错误就回滚，没错误就提交
IF(@@ERROR<>0)
BEGIN  
     ROLLBACK TRAN;
END
ELSE
BEGIN
     COMMIT TRAN;
END
此错误的原因是由于一个事务只能对应一个操作，要么回滚要么提交，所以执行了 ROLLBACK TRAN 语句后一定不能再执行
COMMIT TRAN 语句！！！而无论是回滚事务还是提交事务，都是不会中断 SQL 处理流程的，要想中断流程就需要使用 RETURN 语句。

上面范例中的语句先执行了 ROLLBACK TRAN 回滚操作（这里造成事务已经处理完成），但是并没有中断流程，
所以后面的语句依然会继续执行。执行过程中由于没有任何异常错误，最终导致重复执行了底部的 COMMIT TRAN 事务提交操作，
最后一次事务操作没有找到相匹配的事务声明，就会提示"COMMIT TRANSACTION(事务提交) 请求没有对应的 BEGIN TRANSACTION(事务声明)"这个错误。

所以要跳出事务，在进行回滚 ROLLBACK 操作后，还必须马上使用 RETURN 语句跳出执行流程。以下为修改后的语句：

BEGIN TRAN
--进行判断，不符合条件就回滚，不执行其他操作
IF NOT EXISTS(SELECT [ID] FROM [TestTable] WHERE NO='123')
BEGIN
     ROLLBACK TRAN;
     --------------------------------
     --这里需要添加 RETURN，中断处理流程，防止重复执行事务提交！
     RETURN;
     --------------------------------
END

--这里执行其他 SQL 操作语句。
UPDATE TestTable SET NO='312' WHERE NO='122'

--如果有错误就回滚，没错误就提交
IF(@@ERROR<>0)
BEGIN
     ROLLBACK TRAN;
END

ELSE
BEGIN  
     COMMIT TRAN;
END

这里在做一个简单测试，有助于理解所谓的一个事务只能对应一个事务操作的意思，在 SQL 中输入下图的三行代码并执行：

简单测试还原错误

事务的语法只能一一对应，我们只有一个事务声明但是却有两个事务操作，最后一个事务操作无法找到匹配的事务声明，自然就出错。
* 查看存储过程
  select * from sys.objects where type ='P'
  或者：SSMS=〉数据库=〉对应数据库=〉可编程性=〉存储过程
* 空时间日期
  CAST(NULL AS DATETIME) AS AgreementDate
* 判断是否为空
  使用指定的替换值替换 NULL。

语法：ISNULL ( check_expression , replacement_value )
and (ProductBatch=@BatchNo or isnull(@BatchNo,'')='')
* 四舍五入
select cast(362315*1.0/10000 as numeric(18,2))
select convert(decimal(18, 2), 362315 * 1.0 / 10000)

1. ROUND(该函数，只是负责四舍五入到两位小数，但是不负责截断 只留两位小数，例如下例：)

关于 ROUND 函数，我们平常理解为 4 舍 5 入，如：

print ROUND(13.145, 2);

结果为：13.150
 

2. 使用转换类型，才能达到保留两位小数位的目的： 

select cast(13.145 as   decimal(10,   2))

结果为：13.15
* 2018/8/3 经典 SQL 语句大全
一、基础
1、说明：创建数据库
CREATE DATABASE database-name
2、说明：删除数据库
drop database dbname
3、说明：备份 sql server
--- 创建 备份数据的 device
USE master
EXEC sp_addumpdevice 'disk', 'testBack', 'c:\mssql7backup\MyNwind_1.dat'
--- 开始 备份
BACKUP DATABASE pubs TO testBack
4、说明：创建新表
create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)
根据已有的表创建新表：
A：create table tab_new like tab_old (使用旧表创建新表)
B：create table tab_new as select col1,col2… from tab_old definition only
5、说明：删除新表
drop table tabname
6、说明：增加一个列
Alter table tabname add column col type
注：列增加后将不能删除。DB2 中列加上后数据类型也不能改变，唯一能改变的是增加 varchar 类型
的长度。
7、说明：添加主键：Alter table tabname add primary key(col)
说明：删除主键：Alter table tabname drop primary key(col)
8、说明：创建索引：create [unique] index idxname on tabname(col….)
删除索引：drop index idxname
注：索引是不可更改的，想更改必须删除重新建。
9、说明：创建视图：create view viewname as select statement
删除视图：drop view viewname
10、说明：几个简单的基本的 sql 语句
选择：select * from table1 where 范围
插入：insert into table1(field1,field2) values(value1,value2)
删除：delete from table1 where 范围
更新：update table1 set field1=value1 where 范围
查找：select * from table1 where field1 like ’%value1%’ ---like 的语法很精妙，查资料!
排序：select * from table1 order by field1,field2 [desc]
总数：select count as totalcount from table1
求和：select sum(field1) as sumvalue from table1
平均：select avg(field1) as avgvalue from table1
最大：select max(field1) as maxvalue from table1
最小：select min(field1) as minvalue from table1
11、说明：几个高级查询运算词
A：UNION 运算符
UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派
生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况
下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。
B：EXCEPT 运算符
EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一
个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。
C：INTERSECT 运算符
INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结
果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。
注：使用运算词的几个查询结果行必须是一致的。
12、说明：使用外连接
A、left（outer）join：
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 2/13
左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。
SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
B：right（outer）join:
右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。
C：full/cross（outer）join：
全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。
12、分组:Group by:
一张表，一旦分组 完成后，查询后只能得到组相关的信息。
    组相关的信息：（统计信息）count,sum,max,min,avg 分组的标准)
在 SQLServer 中分组时：不能以 text,ntext,image 类型的字段作为分组依据
在 selecte 统计函数中的字段，不能和普通的字段放在一起；
13、对数据库进行操作：
分离数据库：sp_detach_db;附加数据库：sp_attach_db 后接表明，附加需要完整的路
径名
14.如何修改数据库的名称:
sp_renamedb 'old_name', 'new_name'
二、提升
1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access 可用)
法一：select * into b from a where 1<>1（仅用于 SQlServer）
法二：select top 0 * into b from a
2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access 可用)
insert into b(a, b, c) select d,e,f from b;
3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access 可用)
insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件
例子：..from b in '"&Server.MapPath(".")&"\data.mdb" &"' where..
4、说明：子查询(表名 1：a 表名 2：b)
select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN
(1,2,3)
5、说明：显示文章、提交人和最后回复时间
select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from tabl
e where table.title=a.title) b
6、说明：外连接查询(表名 1：a 表名 2：b)
select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
7、说明：在线视图查询(表名 1：a )
select * from (SELECT a,b,c FROM a) T where t.a > 1;
8、说明：between 的用法,between 限制查询数据范围时包括了边界值,not between 不包括
select * from table1 where time between time1 and time2
select a,b,c, from table1 where a not between 数值 1 and 数值 2
9、说明：in 的使用方法
select * from table1 where a [not] in (‘值 1’,’值 2’,’值 4’,’值 6’)
10、说明：两张关联表，删除主表中已经在副表中没有的信息
delete from table1 where not exists ( select * from table2 where table1.field1=table2.f
ield1 )
11、说明：四表联查问题：
select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 3/13
on a.a=d.d where .....
12、说明：日程安排提前五分钟提醒
SQL: select * from 日程安排 where datediff('minute',f 开始时间,getdate())>5
13、说明：一条 sql 语句搞定数据库分页
select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where
b.主键字段 = a.主键字段 order by a.排序字段
具体实现：
关于数据库分页：
  declare @start int,@end int
  @sql  nvarchar(600)
  set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select
top’+str(@str-1)+’Rid from T where Rid>-1)’
  exec sp_executesql @sql
注意：在 top 后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid 为一个
标识列，如果 top 后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top 的字段如
果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一
致，而查询时如果处在索引则首先查询索引）
14、说明：前 10 条记录
select top 10 * form table1 where 范围
15、说明：选择在每一组 b 值相同的数据中对应的 a 最大的记录的所有信息(类似这样的用法可以用
于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)
select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=
ta.b)
16、说明：包括所有在 TableA 中但不在 TableB 和 TableC 中的行并消除所有重复行而派生出一
个结果表
(select a from tableA ) except (select a from tableB) except (select a from tableC)
17、说明：随机取出 10 条数据
select top 10 * from tablename order by newid()
18、说明：随机选择记录
select newid()
19、说明：删除重复记录
1),delete from tablename where id not in (select max(id) from tablename group by col1,c
ol2,...)
2),select distinct * into temp from tablename
  delete from tablename
  insert into tablename select * from temp
评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作
3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位
置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段
alter table tablename
--添加一个自增列
add  column_b int identity(1,1)
 delete from tablename where column_b not in(
select max(column_b)  from tablename group by column1,column2,...)
alter table tablename drop column column_b
20、说明：列出数据库里所有的表名
select name from sysobjects where type='U' // U 代表用户
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 4/13
21、说明：列出表里的所有的列名
select name from syscolumns where id=object_id('TableName')
22、说明：列示 type、vender、pcs 字段，以 type 字段排列，case 可以方便地实现多重选择，类似
select 中的 case。
select type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then
pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by t
ype
显示结果：
type vender pcs
电脑 A 1
电脑 A 1
光盘 B 2
光盘 A 2
手机 B 3
手机 C 3
23、说明：初始化表 table1
TRUNCATE TABLE table1
24、说明：选择从 10 到 15 的记录
select top 5 * from (select top 15 * from table order by id asc) table_别名 order by i
d desc
三、技巧
1、1=1，1=2 的使用，在 SQL 语句组合时用的较多
“where 1=1” 是表示选择全部 “where 1=2”全部不选，
如：
if @strWhere !=''
begin
set @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhere
end
else
begin
set @strSQL = 'select count(*) as Total from [' + @tblName + ']'
end
我们可以直接写成
错误！未找到目录项。
set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 安定'+ @st
rWhere 2、收缩数据库
--重建索引
DBCC REINDEX
DBCC INDEXDEFRAG
--收缩数据和日志
DBCC SHRINKDB
DBCC SHRINKFILE
3、压缩数据库
dbcc shrinkdatabase(dbname)
4、转移数据库给新用户以已存在用户权限
exec sp_change_users_login 'update_one','newname','oldname'
go
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 5/13
5、检查备份集
RESTORE VERIFYONLY from disk='E:\dvbbs.bak'
6、修复数据库
ALTER DATABASE [dvbbs] SET SINGLE_USER
GO
DBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCK
GO
ALTER DATABASE [dvbbs] SET MULTI_USER
GO
7、日志清除
SET NOCOUNT ON
DECLARE @LogicalFileName sysname,
 @MaxMinutes INT,
 @NewSize INT
USE tablename -- 要操作的数据库名
SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名
@MaxMinutes = 10, -- Limit on time allowed to wrap log.
 @NewSize = 1  -- 你想设定的日志文件的大小(M)
Setup / initialize
DECLARE @OriginalSize int
SELECT @OriginalSize = size
 FROM sysfiles
 WHERE name = @LogicalFileName
SELECT 'Original Size of ' + db_name() + ' LOG is ' +
 CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' +
 CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB'
 FROM sysfiles
 WHERE name = @LogicalFileName
CREATE TABLE DummyTrans
 (DummyColumn char (8000) not null)
DECLARE @Counter    INT,
 @StartTime DATETIME,
 @TruncLog   VARCHAR(255)
SELECT @StartTime = GETDATE(),
 @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'
DBCC SHRINKFILE (@LogicalFileName, @NewSize)
EXEC (@TruncLog)
-- Wrap the log if necessary.
WHILE @MaxMinutes > DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired
 AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)  
 AND (@OriginalSize * 8 /1024) > @NewSize  
 BEGIN -- Outer loop.
SELECT @Counter = 0
 WHILE   ((@Counter < @OriginalSize / 16) AND (@Counter < 50000))
 BEGIN -- update
 INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans
 SELECT @Counter = @Counter + 1
 END
 EXEC (@TruncLog)  
 END
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 6/13
SELECT 'Final Size of ' + db_name() + ' LOG is ' +
 CONVERT(VARCHAR(30),size) + ' 8K pages or ' +
 CONVERT(VARCHAR(30),(size*8/1024)) + 'MB'
 FROM sysfiles
 WHERE name = @LogicalFileName
DROP TABLE DummyTrans
SET NOCOUNT OFF
8、说明：更改某个表
exec sp_changeobjectowner 'tablename','dbo'
9、存储更改全部表
CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch
@OldOwner as NVARCHAR(128),
@NewOwner as NVARCHAR(128)
AS
DECLARE @Name    as NVARCHAR(128)
DECLARE @Owner   as NVARCHAR(128)
DECLARE @OwnerName   as NVARCHAR(128)
DECLARE curObject CURSOR FOR
select 'Name'    = name,
   'Owner'    = user_name(uid)
from sysobjects
where user_name(uid)=@OldOwner
order by name
OPEN   curObject
FETCH NEXT FROM curObject INTO @Name, @Owner
WHILE(@@FETCH_STATUS=0)
BEGIN     
if @Owner=@OldOwner
begin
   set @OwnerName = @OldOwner + '.' + rtrim(@Name)
   exec sp_changeobjectowner @OwnerName, @NewOwner
end
-- select @name,@NewOwner,@OldOwner
FETCH NEXT FROM curObject INTO @Name, @Owner
END
close curObject
deallocate curObject
GO
10、SQL SERVER 中直接循环写入数据
declare @i int
set @i=1
while @i<30
begin
insert into test (userid) values(@i)
set @i=@i+1
end
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 7/13
案例：
有如下表，要求就裱中所有沒有及格的成績，在每次增長 0.1 的基礎上，使他們剛好及格:
    Name     score
    Zhangshan   80
    Lishi       59
    Wangwu      50
    Songquan    69
while((select min(score) from tb_table)<60)
begin
update tb_table set score =score*1.01
where score<60
if (select min(score) from tb_table)>60
break
else
continue
end
数据开发-经典
1.按姓氏笔画排序:
Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到
多
2.数据库加密:
select encrypt('原始密码')
select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')
select pwdencrypt('原始密码')
select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同
3.取回表中字段:
declare @list varchar(1000),
@sql nvarchar(1000)
select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name
='表 A'
set @sql='select '+right(@list,len(@list)-1)+' from 表 A'
exec (@sql)
4.查看硬盘分区:
EXEC master..xp_fixeddrives
5.比较 A,B 表是否相等:
if (select checksum_agg(binary_checksum(*)) from A)
     =
    (select checksum_agg(binary_checksum(*)) from B)
print '相等'
else
print '不相等'
6.杀掉所有的事件探察器进程:
DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysproce
sses
WHERE program_name IN('SQL profiler',N'SQL 事件探查器')
EXEC sp_msforeach_worker '?'
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 8/13
7.记录搜索:
开头到 N 条记录
Select Top N * From 表
-------------------------------
N 到 M 条记录(要有主索引 ID)
Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc
----------------------------------
N 到结尾记录
Select Top N * From 表 Order by ID Desc
案例
例如 1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个 SQL 语句， 找
出表的第 31 到第 40 个记录。
 select top 10 recid from A where recid not  in(select top 30 recid from A)
分析：如果这样写会产生某些问题，如果 recid 在表中存在逻辑索引。
    select top 10 recid from A where……是从索引中查找，而后面的 select top 30 recid
from A 则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到
的不是本来的欲得到的数据。
解决方案
1，用 order by select top 30 recid from A order by ricid 如果该字段不是自增长，
就会出现问题
2，在那个子查询中也加条件：select top 30 recid from A where recid>-1
例 2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。
set @s = 'select top 1 * from T where pid not in (select top ' + str(@count-1) + ' pid from T)'
print @s exec sp_executesql @s
9：获取当前数据库中的所有用户表
select Name from sysobjects where xtype='u' and status>=0
10：获取某一个表的所有字段
select name from syscolumns where id=object_id('表名')
select name from syscolumns where id in (select id from sysobjects where type = 'u'
and name = '表名')
两种方式的效果相同
11：查看与某一个表相关的视图、存储过程、函数
select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like '%表
名%'
12：查看当前数据库中所有存储过程
select name as 存储过程名称 from sysobjects where xtype='P'
13：查询用户创建的所有数据库
select * from master..sysdatabases D where sid not in(select sid from master..syslogin
s where name='sa')
或者
select dbid, name AS DB_NAME from master..sysdatabases where sid <> 0x01
14：查询某一个表的字段和数据类型
select column_name,data_type from information_schema.columns
where table_name = '表名'
15：不同服务器数据库之间的数据操作
--创建链接服务器
exec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或 ip 地址 '
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 9/13
exec sp_addlinkedsrvlogin  'ITSV ', 'false ',null, '用户名 ', '密码 '
--查询示例
select * from ITSV.数据库名.dbo.表名
--导入示例
select * into 表 from ITSV.数据库名.dbo.表名
--以后不再使用时删除链接服务器
exec sp_dropserver  'ITSV ', 'droplogins '
--连接远程/局域网数据(openrowset/openquery/opendatasource)
--1、openrowset
--查询示例
select * from openrowset( 'SQLOLEDB ', 'sql 服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
--生成本地表
select * into 表 from openrowset( 'SQLOLEDB ', 'sql 服务器名 '; '用户名 '; '密码 ',数据库名.dbo.
表名)
--把本地表导入远程表
insert openrowset( 'SQLOLEDB ', 'sql 服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
select *from 本地表
--更新本地表
update b
set b.列 A=a.列 A
 from openrowset( 'SQLOLEDB ', 'sql 服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner j
oin 本地表 b
on a.column1=b.column1
--openquery 用法需要创建一个连接
--首先创建一个连接创建链接服务器
exec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或 ip 地址 '
--查询
select *
FROM openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')
--把本地表导入远程表
insert openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')
select * from 本地表
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 10/13
--更新本地表
update b
set b.列 B=a.列 B
FROM openquery(ITSV,  'SELECT * FROM 数据库.dbo.表名 ') as a 
inner join 本地表 b on a.列 A=b.列 A
--3、opendatasource/openrowset
SELECT   *
FROM   opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码 '
).test.dbo.roy_ta
--把本地表导入远程表
insert opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码').数据
库.dbo.表名
select * from 本地表
SQL Server 基本函数
SQL Server 基本函数
1.字符串函数 长度与分析用
1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格
2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start 为起始位
置，length 为字符串长度，实际应用中以 len(expression)取得其长度
3,right(char_expr,int_expr) 返回字符串右边第 int_expr 个字符，还用 left 于之相反
4,isnull( check_expression , replacement_value )如果 check_expression 為空，則返回 r
eplacement_value 的值，不為空，就返回 check_expression 字符操作类
5,Sp_addtype 自定義數據類型
例如：EXEC sp_addtype birthday, datetime, 'NULL'
6,set nocount {on|off}
使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一
些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET
NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。SET NOCOUNT 为 ON 时，不返回
计数（表示受 Transact-SQL 语句影响的行数）。
SET NOCOUNT
为 OFF 时，返回计数
常识
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 11/13
在 SQL 查询中：from 后最多可以跟多少张表或视图：256 在 SQL 语句中出现 Order by,查询时，先排序，后取在
SQL 中，一个字段的最大容量是 8000，而对于 nvarchar(4000),由于 nvarchar 是 Unicode 码。
SQLServer2000
同步复制技术实现步骤
一、 预备工作
1.发布服务器,订阅服务器都创建一个同名的 windows 用户,并设置相同的密码,做为发布快照文件夹的有效访问用
户--管理工具--计算机管理--用户和组--右键用户--新建用户--建立一个隶属于 administrator 组的登陆 windows 的
用户（SynUser）2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:
我的电脑--D:\ 新建一个目录,名为: PUB
--右键这个新建的目录--属性--共享--选择"共享该文件夹"--通过"权限"按纽来设置具体的用户权限,保证第一步
中创建的用户(SynUser) 具有对该文件夹的所有权限
--确定 3.设置 SQL 代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)
开始--程序--管理工具--服务
--右键 SQLSERVERAGENT--属性--登陆--选择"此账户"--输入或者选择第一步中创建的 windows 登录用户名
（SynUser）--"密码"中输入该用户的密码 4.设置 SQL Server 身份验证模式,解决连接时的权限问题(发布/订阅服务
器均做此设置)
企业管理器
--右键 SQL 实例--属性--安全性--身份验证--选择"SQL Server 和 Windows"--确定 5.在发布服务器和订阅服务器
上互相注册
企业管理器
--右键 SQL Server 组--新建 SQL Server 注册...--下一步--可用的服务器中,输入你要注册的远程服务器名--添加--
下一步--连接使用,选择第二个"SQL Server 身份验证"--下一步--输入用户名和密码（SynUser）--下一步--选择
SQL Server 组,也可以创建一个新组--下一步--完成 6.对于只能用 IP,不能用计算机名的,为其注册服务器别名（此
步在实施中没用到） (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的 IP)
开始--程序--Microsoft SQL Server--客户端网络实用工具
--别名--添加--网络库选择"tcp/ip"--服务器别名输入 SQL 服务器名--连接参数--服务器名称中输入 SQL 服务器 ip 地
址--如果你修改了 SQL 的端口,取消选择"动态决定端口",并输入对应的端口号
二、 正式配置
1、配置发布服务器
打开企业管理器，在发布服务器（B、C、D）上执行以下步骤:
(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导(2) [下一
步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他 sql 的服务器（选择自己）(3) [下一
步] 设置快照文件夹
采用默认\\servername\Pub
(4) [下一步] 自定义配置
可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置
否,使用下列默认设置（推荐）
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 12/13
(5) [下一步] 设置分发数据库名称和位置 采用默认值(6) [下一步] 启用发布服务器 选择作为发布的服务器
(7) [下一步] 选择需要发布的数据库和发布类型(8) [下一步] 选择注册订阅服务器(9) [下一步] 完
成配置 2、创建出版物
发布服务器 B、C、D 上
(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令(2)选择要创建出版物的数据库，然后单击[创建发
布](3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类
型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)(4)单击[下一步]系统要求指定可以
订阅该发布的数据库服务器类型,SQLSERVER 允许在不同的数据库如 orACLE 或 ACCESS 之间进行数据复制。
但是在这里我们选择运行"SQL SERVER 2000"的数据库服务器
(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表
注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表
(6)选择发布名称和描述(7)自定义发布属性 向导提供的选择:
是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性
否 根据指定方式创建发布 （建议采用自定义的方式）
(8)[下一步] 选择筛选发布的方式(9)[下一步] 可以选择是否允许匿名订阅 1)如果选择署名订阅,则需要在发布
服务器上添加订阅服务器
方法: [工具]->[复制]->[配置发布、订阅服务器和分发的属性]->[订阅服务器] 中添加
否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅
如果仍然需要匿名订阅则用以下解决办法
[企业管理器]->[复制]->[发布内容]->[属性]->[订阅选项] 选择允许匿名请求订阅 2)如果选择匿名订阅,则配置
订阅服务器时不会出现以上提示(10)[下一步] 设置快照 代理程序调度(11)[下一步] 完成配置
当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库
有数据
srv1.库名..author 有字段:id,name,phone, srv2.库名..author 有字段:id,name,telphone,adress
要求：
srv1.库名..author 增加记录则 srv1.库名..author 记录增加 srv1.库名..author 的 phone 字段更新，则 srv1.库
名..author 对应字段 telphone 更新
--*/
--大致的处理步骤--1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步 exec
sp_addlinkedserver 'srv2','','SQLOLEDB','srv2 的 sql 实例名或 ip' exec sp_addlinkedsrvlogin
'srv2','false',null,'用户名','密码'
go
--2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动
。我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动
类型设置为自动启动
go
--然后创建一个作业定时调用上面的同步处理存储过程就行了
企业管理器
2018/8/3 经典 SQL 语句大全
http://www.360doc.com/content/16/0215/11/19756206_534732237.shtml 13/13
--管理--SQL Server 代理--右键作业--新建作业--"常规"项中输入作业名称--"步骤"项--新建--"步骤名"中输入步
骤名--"类型"中选择"Transact-SQL 脚本(TSQL)" --"数据库"选择执行命令的数据库--"命令"中输入要执行的语
句: exec p_process --确定--"调度"项--新建调度--"名称"中输入调度名称--"调度类型"中选择你的作业执行安
排--如果选择"反复出现" --点"更改"来设置你的时间安排
然后将 SQL Agent 服务启动,并设置为自动启动,否则你的作业不会被执行
设置方法:
我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择"自动启动"--确定.
--3.实现同步处理的方法 2,定时同步
--在 srv1 中创建如下的同步处理存储过程
create proc p_process
as
--更新修改过的数据
update b set name=i.name,telphone=i.telphone
from srv2.库名.dbo.author b,author i
where b.id=i.id and
(b.name <> i.name or b.telphone <> i.telphone)
--插入新增的数据 insert srv2.库名.dbo.author(id,name,telphone)
select id,name,telphone from author i
where not exists(
select * from srv2.库名.dbo.author where id=i.id)
--删除已经删除的数据(如果需要的话)
delete b
from srv2.库名.dbo.author b
where not exists(
select * from author where id=b.id)
go
63
* 当天日期
    convert(date ,PLDate)=convert(date ,@LJDate)
* 成功的 checkmsg , 注意前面是 1
  
select 1 as CheckResult,'批号为'+ @BatchNo +'的产品需先删除'+cast(@CardNum-@TodayQty as nvarchar(10))+'张流程卡'   as CheckMsg
* 游标
DECLARE @id INT;
DECLARE tempCursor CURSOR
FOR
    ( SELECT    id
      FROM      HrmResource
      WHERE     status IN ( 0, 1, 2, 3 )
    )
    ORDER BY id;								--创建游标 tempCursor，并定义游标所指向的集合   
OPEN tempCursor;								--打开游标  
FETCH NEXT FROM tempCursor INTO @id;			--游标读取下一个数据  
WHILE @@fetch_status = 0                        --游标读取下一个数据的状态，0 表示读取成功  
    BEGIN  
        PRINT ( @id )							--打印 id
		SELECT * FROM HrmResource WHERE id = @id;
        FETCH NEXT FROM tempCursor INTO @id;    --继续用游标读取下一个数据  
    END  
CLOSE tempCursor;								--关闭游标
DEALLOCATE tempCursor;							--释放游标

* 月初 月末
select DATEADD(mm,DATEDIFF(mm,0,GETDATE()),0) AS docdate1,
DATEADD(ms,-3,DATEADD(mm,1,DATEADD(mm,DATEDIFF(mm,0,GETDATE()),0))) AS docdate2
