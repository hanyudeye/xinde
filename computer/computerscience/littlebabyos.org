#+TITLE: 娃娃操作系统
#+DESCRIPTION: 娃娃操作系统
#+TAGS: os
#+CATEGORIES: 软件使用
#+DATE: <2019-06-22 22:41:52>

* littleos
** 使用 BIOS 以及直接写显存绘制图形
   3.内存映射图形
   
   对于内存映射图形视频模式 0x13 最容易使用。这时屏幕像素映射为一个字节数组，每
   个像素一个字节。
   
   共有 320*200 个像素，因为有 256 种颜色，所以每个像素一个字节。左上角像素对应地址 0xa0000。
   模式 0x13 中，每个整数色彩值表示调色板的色彩表的索引。调色板中每个项都由三个独立的整数（0～63）构成，称为 RGB 值。调色板的第 0 项控制着屏幕的背景色。
   有两个输出端口用于控制视频调色板：送往端口 0x3c8 的值表示要修改的调色板表项，送往端口 0x3c9 的是要修改的颜色值。
   示例：
   # This program draws color pixels at mode 0x13
   # 2012-12-24 21:31
   # guzhoudiaoke@126.com
 
   .section .text
   .global _start
   .code16
 
   _start:
	 jmp		main
 
   #--------------------------------------------------------------
   # 清屏函数：
   #	设置屏幕背景色，调色板的索引 0 指代的颜色为背景色
   clear_screen:				# 清屏函数
	 movb	$0x06,	%ah		# 功能号 0x06
	 movb	$0,		%al		# 上卷全部行，即清屏
	 movb	$0,		%ch		# 左上角行
	 movb	$0,		%ch		# 左上角列	
	 movb	$24,	%dh		# 右下角行
	 movb	$79,	%dl		# 右下角列
	 movb	$0x07,	%bh		# 空白区域属性
	 int		$0x10
	 ret
 
   #----------------------------------------------------------------
   # 设置显示模式函数
   set_video_mode:
	 movb	$0,			%ah			# 功能号 0x0
	 movb	$MODE_0X13,	%al			# 显示模式
	 int		$0x10
	 ret
 
   #---------------------------------------------------------------
   # 显示一些文字函数：
   #	使用 INT 0x10 中断 0x13 功能，显示计算机当前工作的显示模式
   draw_some_text:
	 movw	$msg_str,	%bp			# ES：BP 为字符串地址
	 movw	msg_len,	%cx			# 显示字符数
	 movb	$0x13,		%ah			# 功能号
	 movb	$0,			%al			# 显示模式
	 movb	$TEXT_COLOR,%bl			# 属性值
	 movb	$0,			%bh			# 视频页
	 movb	$TEXT_ROW,	%dh			# 显示起始行
	 movb	$TEXT_COL,	%dl			# 显示起始列
	 int		$0x10
 
	 ret
 
   #----------------------------------------------------------------
   # 设置背景颜色为深蓝色
   set_screen_bk_color:
	 movw	$VIDEO_PALLETE_PORT,	%dx
	 movb	$PA_INDEX_BACKGROUND,	%al
	 outb	%al,					%dx
 
	 movw	$COLOR_SELECTION_PORT,	%dx
	 movb	$0,						%al		# 红
	 outb	%al,					%dx
	 movb	$0,						%al		# 绿
	 outb	%al,					%dx
	 movb	$18,					%al		# 蓝（亮度 18/63）
	 outb	%al,					%dx
	 ret
 
   #----------------------------------------------------------------
   # 通过写显存绘制一些像素点：
   #	首先设置调色板索引 1 处的颜色为白色
   #	然后通过写显存的方式，向 ES：DI 写入数据（PA_INDEX_WHITE）
   draw_some_pixels:
	 # 把索引 1 处的颜色改为白色（63，63，63）
	 movw	$VIDEO_PALLETE_PORT,	%dx
	 movb	$PA_INDEX_WHITE,		%al
	 outb	%al,					%dx
	 movw	$COLOR_SELECTION_PORT,	%dx
	 movb	$63,					%al		# 红
	 outb	%al,					%dx
	 movb	$63,					%al		# 绿
	 outb	%al,					%dx
	 movb	$63,					%al		# 蓝
	 outb	%al,					%dx
 
	 # 设置 ES 的值
	 movw	$VIDEO_SEG_GRAPHIC,		%ax
	 movw	%ax,					%es
 
	 # 设置要显示的像素位置的显存地址（目的地址）
	 movw	$(PIXEL_ROW_ST*320 + PIXEL_COL_ST),	%di
	 movb	$PA_INDEX_WHITE,		%al
	 movw	$PIXEL_COUNT,			%cx
 
   draw_a_pixel:
	 stosb
	 addw	$5,						%di
	 loop	draw_a_pixel
 
	 ret
 
   main:
	 movw	%cx,	%ax
	 movw	%ax,	%ds
	 movw	%ax,	%es
 
	 call	clear_screen		# 清屏
	 call	set_video_mode		# 设置显示模式
	 call	set_screen_bk_color	# 设置背景颜色
	 call	draw_some_text		# 绘制字符串
	 call	draw_some_pixels	# 绘制像素
 
   1:
	 jmp		1b
 
   # 常量定义：
	 VIDEO_SEG_TEXT		= 0xb800
	 VIDEO_SEG_GRAPHIC	= 0xa000
 
	 VIDEO_PALLETE_PORT	= 0x3c8
	 COLOR_SELECTION_PORT= 0x3c9
	
	 MODE_0X13			= 0x13
 
	 PA_INDEX_BACKGROUND	= 0x0
	 PA_INDEX_WHITE		= 0x1
 
	 TEXT_ROW			= 0x01
	 TEXT_COL			= 0x00
	 TEXT_COLOR			= 0x04
 
	 PIXEL_ROW_ST		= 100
	 PIXEL_COL_ST		= 160-5*10
	 PIXEL_COUNT			= 20
 
   msg_str:
   msg_mode:
	 .asciz	"video mode: 0x13"
	 .org	msg_mode+40,		0
   msg_scr_res:
	 .asciz	"screen resolution:320x200"
	 .org	msg_scr_res+40,		0
   msg_color_num:
	 .asciz	"color num:256"
	 .org	msg_color_num+40*4,	0
   msg_babyos:
	 .asciz	"The new Baby OS will have a GUI,but now it can only draw some pixels, haha..And merry Christmas!"
   msg_len:
	 .int	. - msg_str - 1
 
	 .org	0x1fe,	0x90
	 .word	0xaa55

   结果:



   注释：

   文字是用的 BIOS INT 0x10 显示的，VGA 的 0x13 模式下显示的文字为 40 列 x25 行，
   字符框 8x8，看上去有点丑，以后再研究下超级 VGA（SVGA）吧～
** 利用 BIOS INT 0x13 读取软盘
   昨天学习了 VGA 显示的一些东西，今天准备学习一下读取软盘的知识。

   1.babyos 将使用的引导过程
   1）系统上电或 reset 时，处理器执行一些初始化，CPU 处于实模式
   2）处理器会执行一个位于已知位置处的代码，PC 中这个位置位于 BIOS，它保存在主板上的闪存中
   3）控制权交给 BIOS 后，它寻找一个可引导的设备（软盘、硬盘等），BIOS 读取引导扇区（512 字节）到内存 0x7c00 处，并跳转到该地址执行
   4）引导扇区中存放的指令可以使用 BIOS 中断，它将会读取软盘中内核部分到一个临时地址（如 0x10000，不覆盖 0x7c00 处的 boot 代码即可）
   5）将内核前 512 字节（load.s, 它主要负责将内核剩余部分拷贝到 load.s 后面)移动到 0x0 处，将 GDT 拷贝到 0x80000 处。为什么不一次全部将内核放到 0x0 处呢？因为内核可能较大，会覆盖掉 0x7c00 处的代码。
   6）开启 A20 总线，置位 CR0 的 bit 0，开启保护模式，加载 GDT 到 GDTR，跳转到 GDT 第二项（第一项为空 GDT），即 load.s 处执行
   7）load.s 将内核剩余部分移动到 load.s 后面，即 0x200 开始的地址处。然后执行初始化代码。
   8）初始化代码，至此系统启动成功。

   所以首当其冲的问题就是如何读软盘。

   2.软盘的结构
   3.5 寸 1.44M 软盘，如图 floppy_struct.png 所示,有两个磁头，正反两面各一个；80 个磁道（即 80 个圆圈）；每个磁道有 18 个扇区；每个扇区为 512 字节。
   容量 = 512 字节/扇区 * 2 面 * 80 磁道（柱面）/面 * 18 扇区/磁道 = 1440 KB

   磁头，即面：编号[0, 1]
   80 个磁道，即柱面（圆圈）：编号[0, 79]
   18 个扇区：编号[1, 18]

   相对扇区号[0, 2879]：
   相对扇区号按照柱面排序，即从最外头的圆圈到最里头的圆圈。
   0 柱面正面（即磁头号为 0）的 1-18 扇区为 0-17 号相对扇区，0 柱面反面（即磁头号为 2）的 1-18 扇区为 18-35 号相对扇区，然后是 1 柱面，2 柱面，直到 79 柱面。如下：
   0 柱面，0 磁头，1 扇区			0
   0 柱面，0 磁头，2 扇区			1
   ……
   0 柱面，0 磁头，18 扇区		17
   0 柱面，1 磁头，1 扇区			18
   ……
   0 柱面，1 磁头，18 扇区		35
   1 柱面，0 磁头，1 扇区			36
   ……
   1 柱面，0 磁头，18 扇区		53
   1 柱面，1 磁头，1 扇区			54
   ……
   1 柱面，1 磁头，18 扇区		71
   2 柱面，0 磁头，1 扇区			72
   ……

   3.利用 BIOS 中断读取软盘
   -------------------------------------------------------------------
	 INT 0x13，功能 02
   -----------------------------------------------------------
   参数：
	 AH		02
	 AL		读取扇区数
	 CH		柱面[0, 79]
	 CL		扇区[1, 18]
	 DH		磁头[0, 1]
	 DL		驱动器（0x0 ~ 0x7f 表示软盘，0x80 ~ 0xff 表示硬盘）
	 ES：BX	缓冲区地址，即数据读到这里
   返回值：
	 CF = 0 表示操作成功，此时 AH=0，AL=传输的扇区数
	 CF = 1 即 carry 位置位（可用 JC 表示跳转）表示操作失败，AH=状态代码
   --------------------------------------------------------------------
   4.相对扇区号的计算
   1）知道柱面号，磁头号，扇区号计算相对扇区号
   由上面可知 0 号柱面包含了相对扇区号[0,35]，1 号柱面包含相对扇区号[36,71]，依次类推。
   设相对扇区号为 N，则
   柱面号 CH = N / 36；
   令 x = N % 36；
   则 x 范围为[0,35]，其中[0,17] 为磁头号 0， [18,35]为磁头号 1.
   则磁头号 DH = x / 18；
   零 y = x % 18; y 范围[0, 17]
   则扇区号 CL = y + 1。

   2）知道相对扇区号，计算柱面号、磁头号、扇区号
   N = 36*CH + 18*DH + CL;
   由此式子，也可计算：
   CH = N / 36
   DH = (N % 36) / 18
   CL = (N % 36) % 18 + 1

   5.读取一个扇区
   实验：将一些数据写入软盘的第二个扇区（第一个扇区是引导扇区），然后用 BIOS 中断读取该扇区的数据，并显示在屏幕上。然后看读取的数据是否与写入的数据相同。注：第二个扇区相对扇区号为 1.
   写数据的 C 代码：
   /*************************************************************************
	 > File:		write_data.c
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2012 年 12 月 26 日 星期三 01 时 20 分 26 秒
   ************************************************************************/
 
   #include <stdio.h>
   #include <string.h>
 
   int main()
   {
	 FILE *fp;
	 fp = fopen("./data", "wb");
	
	 int i;
	 char *str = "baby os, guzhoudiaoke@126.com ";
	 int len = strlen(str);
	
	 for (i = 0; i < len; i++)
	 fprintf(fp, "%c", str[i]);
 
	 for (i = 512-len; i > 0; i--)
	 fprintf(fp, "%c", i % 26 + 'A');
 
	 return 0;
   }
 
   汇编代码：
   # This program draws color pixels at mode 0x13
   # 2012-12-26 01:31
   # guzhoudiaoke@126.com
 
   .include "boot.inc"
 
   .section .text
   .global _start
   .code16
 
   _start:
	 jmp		main
 
   #--------------------------------------------------------------
   # 清屏函数：
   #	设置屏幕背景色，调色板的索引 0 指代的颜色为背景色
   clear_screen:				# 清屏函数
	 movb	$0x06,	%ah		# 功能号 0x06
	 movb	$0,		%al		# 上卷全部行，即清屏
	 movb	$0,		%ch		# 左上角行
	 movb	$0,		%ch		# 左上角列	
	 movb	$24,	%dh		# 右下角行
	 movb	$79,	%dl		# 右下角列
	 movb	$0x07,	%bh		# 空白区域属性
	 int		$0x10
	 ret
 
   #---------------------------------------------------------------
   # 直接写显存显示一些文字函数：
   #	调用前需要设置 DS：SI 为源地址，DI 为显示位置，
   #	CX 为显示的字符个数, AL 为颜色属性
   draw_some_text:
	 # ES:DI is the dst address, DS:SI is the src address
	 movw	$VIDEO_SEG_TEXT,	%bx
	 movw	%bx,				%es
	
   copy_a_char:
	 movsb
	 stosb
	 loop	copy_a_char
	 ret
 
   #----------------------------------------------------------------
   # 读取软盘第二个扇区：
   #	使用 BIOS INT 0x13 中断，使用前需要设置 ES：BX 作为缓冲区
   read_one_sect:
	 movb	$0x02,	%ah		# 功能号
	 movb	$0x01,	%al		# 读取扇区数
	 movb	$0x00,	%ch		# 柱面号
	 movb	$0x02,	%cl		# 扇区号
	 movb	$0x00,	%dh		# 磁头号
	 movb	$0x00,	%dl		# 驱动器号
 
   re_read:					# 若调用失败则重新调用
	 int		$0x13
	 jc		re_read			# 若进位位（CF）被置位，表示调用失败
	
	 ret
 
   main:
	 movw	%cx,	%ax
	 movw	%ax,	%ds
	 movw	%ax,	%es
 
	 call	clear_screen		# 清屏
 
	 movw	$0,			%ax
	 movw	%ax,		%ds
	 leaw	msg_str,	%si
	 xorw	%di,		%di
	 movw	msg_len,	%cx
	 movb	$TEXT_COLOR,%al
	 call	draw_some_text		# 绘制字符串
 
	 movw	$BUFFER_SEG,%ax		
	 movw	%ax,		%es		# ES:BX 为缓冲区地址
	 xorw	%bx,		%bx
	 call	read_one_sect
 
	 # 下面调用绘制函数，在屏幕上显示读取的信息
	 movw	$BUFFER_SEG,%ax
	 movw	%ax,		%ds		# ds:si 为源地址
	 xorw	%si,		%si
	 movw	$160,		%di		# 第一行已经打印了 msg_str，从第二行开始显示
	 movw	$512,		%cx		# 显示 512 个字符
	 movb	$0x01,		%al
	 call	draw_some_text
 
   1:
	 jmp		1b
 
   msg_str:
	 .asciz	"The data of the second sect of the floppy (sect 1):"
   msg_len:
	 .int	. - msg_str - 1
 
	 .org	0x1fe,	0x90
	 .word	0xaa55
   实验结果：




   6.读取任意扇区（给定相对扇区号）
   实验，写用 C 语言写入文件，该文件包含 512 个‘a’，512 个 1……512 个‘z’, 循环 50 次，将该文件写入软盘（相对扇区号 1～50*26），然后读取给定的相对扇区号的扇区，将读取的内容打印到屏幕上。并与写入的数据比较，验证读取的正确性。

   C 代码用于写文件：
   /*************************************************************************
	 > File:		write_data.c
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2012 年 12 月 26 日 星期三 20 时 16 分 45 秒
   ************************************************************************/
 
   #include <stdio.h>
   #include <string.h>
 
   int main(int argc, char *argv[])
   {
	 if (argc != 2)
	 {
	 printf("usage: ./write_data file_name");
	 exit(0);
	 }
 
	 FILE *fp;
	 fp = fopen(argv[1], "wb");
	
	 int i, j, k;
 
	 for (i = 0; i < 50; i++)
	 {
	 for (j = 'a'; j <= 'z'; j++)
	 {
	 for (k = 0; k < 512; k++)
	 {
	 fprintf(fp, "%c", (char)j);
	 }
	 }
	 }
 
	 return 0;
   }
 
   汇编代码：
   # This program draws color pixels at mode 0x13
   # 2012-12-26 20:23:42
   # guzhoudiaoke@126.com
 
   .include "boot.inc"
 
   .section .text
   .global _start
   .code16
 
   _start:
	 jmp		main
 
   #--------------------------------------------------------------
   # 清屏函数：
   #	设置屏幕背景色，调色板的索引 0 指代的颜色为背景色
   clear_screen:				# 清屏函数
	 movb	$0x06,	%ah		# 功能号 0x06
	 movb	$0,		%al		# 上卷全部行，即清屏
	 movb	$0,		%ch		# 左上角行
	 movb	$0,		%ch		# 左上角列	
	 movb	$24,	%dh		# 右下角行
	 movb	$79,	%dl		# 右下角列
	 movb	$0x07,	%bh		# 空白区域属性
	 int		$0x10
	
	 ret
 
   #---------------------------------------------------------------
   # 直接写显存显示一些文字函数：
   #	调用前需要设置 DS：SI 为源地址，DI 为在屏幕上的显示位置，
   #	CX 为显示的字符个数, AL 为颜色属性
   draw_some_text:
	 # ES:DI is the dst address, DS:SI is the src address
	 movw	$VIDEO_SEG_TEXT,	%bx
	 movw	%bx,				%es
	
   copy_a_char:
	 movsb
	 stosb
	 loop	copy_a_char
 
	 ret
 
   #----------------------------------------------------------------
   # 读取软盘一个扇区：
   #	使用 BIOS INT 0x13 中断，使用前需要设置 ES：BX 作为缓冲区
   #	AX 为相对扇区号
   read_one_sect:
	 movb	$36,	%dl
	 divb	%dl
	 movb	%al,	%ch		# 柱面号=N / 36, 假设 x = N % 36
	
	 movb	%ah,	%al		# AL = N % 36
	 movb	$0,		%ah		# AX = N % 36
	 movb	$18,	%dl
	 divb	%dl
	 movb	%al,	%dh		# 磁头号 DH = x / 18
	 movb	%ah,	%cl		
	 incb	%cl				# 扇区号 CL = x % 18 + 1
 
	 movb	$0x00,	%dl		# 驱动器号 DL
 
	 movb	$0x02,	%ah		# 功能号
	 movb	$0x01,	%al		# 读取扇区数
 
   re_read:					# 若调用失败则重新调用
	 int		$0x13
	 jc		re_read			# 若进位位（CF）被置位，表示调用失败
	
	 ret
 
   #-------------------------------------------------------------------
   # 该函数读取指定的若干扇区号
   #	需要指定 ES：BX 作为缓冲区
   read_sects:
	 movw	$0x00,			%si		# 已经读取的扇区数
	 leaw	sect_no,		%di
   1:	
	 movw	(%di),			%ax		# 获取相对扇区号
	 addw	$2,				%di
	
	 call	read_one_sect
	
 
	 incw	%si
	 incw	%bx
	 cmpw	num_to_read,	%si
	 jne		1b
 
	 ret
 
   main:
	 movw	%cx,	%ax
	 movw	%ax,	%ds
	 movw	%ax,	%es
 
	 call	clear_screen		# 清屏
 
	 # 显示提示信息
	 movw	$0,			%ax
	 movw	%ax,		%ds
	 leaw	msg_str,	%si
	 xorw	%di,		%di
	 movw	msg_len,	%cx
	 movb	$TEXT_COLOR,%al
	 call	draw_some_text		# 绘制字符串
 
	 # 读取软盘
	 movw	$BUFFER_SEG,		%ax		
	 movw	%ax,				%es		# ES:BX 为缓冲区地址
	 xorw	%bx,				%bx
	 call	read_sects
	
   # 在屏幕上显示读取的信息
   #	movw	$BUFFER_SEG,%ax
   #	movw	%ax,		%ds		# ds:si 为源地址
   #	movw	$0,			%si
   #	movw	$320,		%di		# 第一行已经打印了 msg_str，从第二行开始显示
   #	movw	$512,		%cx		# 显示字符数
   #	movb	$0x01,		%al
   #	call	draw_some_text
	
	 # 将缓冲区中前 data_len 个字节拷贝到 data_save
	 xorw	%ax,		%ax
	 movw	%ax,		%ds
	 movw	num_to_read,%cx
	
	 movw	$BUFFER_SEG,%ax
	 movw	%ax,		%ds
	 xorw	%ax,		%ax
	 movw	%ax,		%es
	 movw	$0,			%si
	 movw	$data_save,	%di
 
	 cld
	 rep		movsb
 
	 # 下面调用绘制函数，在屏幕上显示读取的信息
	 xorw	%ax,		%ax
	 movw	%ax,		%ds		# ds:si 为源地址
	 leaw	data_save,	%si
	 movw	$160,		%di		# 第一行已经打印了 msg_str，从第二行开始显示
	 movw	num_to_read,%cx		# 显示字符数
	 movb	$0x01,		%al
	 call	draw_some_text
 
   1:
	 jmp		1b
 
   msg_str:
	 .asciz	"The data read from floppy:"
   msg_len:
	 .short	. - msg_str - 1
 
   sect_no:
	 # 下面的扇区数据为："babyosguzhoudiaoke"
	 # sect:	2+26*1,		1+26*2,		2+26*3,		25+26*4,	15+26*5,	19+26*6,	
	 #		7+26*11,	21+26*12,	26+26*13,	8+26*14,	15+26*15,	21+26*16,
	 #		4+26*31,	9+26*32,	1+26*33,	15+26*34,	11+26*35,	5+26*36
	 .short	28,			53,			80,			129,		145,		175	
	 .short	293,		333,		364,		372,		379,		411
	 .short	810,		841,		859,		899,		921,		941
   num_to_read:
	 .short	18
 
   data_save:
	 .asciz	"XXXXXXXXXXXXXXXXXX"
	
	 .org	0x1fe,	0x90
	 .word	0xaa55
** SVGA、VBE 基础与切换到髙分辨率模式
   1.VGA
   VGA（Video Graphics Array）即视频图形阵列，是 IBM 在 1987 年随 PS/2 机推出的。
   
   VGA 主要由七大块组成：图形控制器、显示存储器、定序器、CRT 控制器、数据串行发
   生器、属性控制器和数模转换器 DAC。

   2.VBE
   
   IBM 的 VGA 标准是显示卡发展史上的一块丰碑。但后来无法满足人们的需要，于是市场
   上出现了 TVGA、S3 系列、Cirrus Logic、ET 等为首的一批显示卡，提供了比 VGA 分
   辨率更高，颜色更丰富的显示模式，又兼容 VGA 显示卡，它们被统称为 Super
   VGA（SVGA）。
   
   各种不同的 SVGA 之间的显示控制各不相同，带来软件兼容性问题，为此视频电子学标
   
   准协会 VESA（Video Electronics Standards Association）提出了一组附加的 BIOS
   
   功能调用借口——VBE（VESA BIOS EXTENSION）标准，从而在软件接口层次上实现了各种
   
   SVGA 显示卡之间的兼容性。时至今日，所有的显示卡 OEM 厂商都提供了符合 VESA
   
   SUPER 标准的扩展 BIOS。通过一组 INT 10H 中断调用（AH=4FH），可以方便地使用
   
   VESA SVGA 的扩展功能而不必了解各种显示卡的硬件细节。
   
   各 Super VGA 卡提供的分辨率远高于 VGA，VESA VBE 均赋予一个标准的 16 位模式号
   （实际上是 9 位，其他各位为标志位或留给以后扩充）。

   3.VBE 功能调用和返回值
   VBE 功能调用的共同点：
   1）AH 必须等于 4FH，表明是 VBE 标准；
   2）AL 等于 VBE 功能号，0<= AL <= 0BH；
   3）BL 等于子功能号，也可以没有子功能；
   4）调用 INT 10H；
   5）返回值

   VBE 返回值一般在 AX 中：
   1）AL=4FH：支持该功能
   2）AL!=4FH：不支持该功能；
   3）AH=00H：调用成功；
   4）AH=01H：调用失败；
   5）AH=02H：当前硬件配置不支持该功能；
   6）AH=03H：当前的显示模式不支持该功能；

   4.VBE 功能
   -----------------------------------------------------------
	 功能 0x00：返回 VBE 信息
   ------------------------------------------------------
   入口：
	 AX			0x4F00
	 ES：DI		指向 VBE 信息块的指针
   出口：
	 AX			VBE 返回值
   ------------------------------------------------------------
 
   -----------------------------------------------------------
	 功能 0x01：返回 VBE 特定模式信息
   ------------------------------------------------------
   入口：
	 AX			0x4F01
	 CX			模式号
	 ES：DI		指向 VBE 特定模式信息块的指针
   出口：
	 AX			VBE 返回值
   ------------------------------------------------------------
 
   -----------------------------------------------------------
	 功能 0x02：设置 VESA VBE 模式
   ------------------------------------------------------
   入口：
	 AX			0x4F02
	 BX			模式号
   出口：
	 AX			VBE 返回值
   ------------------------------------------------------------
   当设置模式失败时，返回错误代码，一般返回 AH=01H
 
   VESA 2.0 以上增加了 BX 中 D14，D15 的位定义，完整定义如下：
   BX = 模式号
	 D0～D8：9 位模式号
	 D9～D13：保留，必须为 0
	 D14 = 0：使用普通的窗口页面缓存模式，用 VBE 功能 05H 切换显示页面
	 = 1：使用大的线性缓存区，其地址可从 VBE 功能 01H 的返回信息 ModeInfo 获得
	 D15 = 0：清除显示内存
	 = 1：不清除显示内存
   ------------------------------------------------------------

   5.示例
   检查 VBE 可否使用、版本、模式 0x103，并切换到模式 0x103（800*600，256 色）：

   # 本程序测试 VBE（VESA BIOS EXTENSION）显示模式,然后切换到 1024*768 256 色模式，
   # 并通过软盘读取 Baby OS 的简单 LOGO，显示在屏幕上
   # 2012-12-28 21:03
   # guzhoudiaoke@126.com
 
   .section .text
   .global _start
   .code16
 
   _start:
	 jmp		main
 
   #--------------------------------------------------------------
   # 清屏函数：
   #	设置屏幕背景色，调色板的索引 0 指代的颜色为背景色
   clear_screen:				# 清屏函数
	 movb	$0x06,	%ah		# 功能号 0x06
	 movb	$0,		%al		# 上卷全部行，即清屏
	 movb	$0,		%ch		# 左上角行
	 movb	$0,		%ch		# 左上角列	
	 movb	$24,	%dh		# 右下角行
	 movb	$79,	%dl		# 右下角列
	 movb	$0x07,	%bh		# 空白区域属性
	 int		$0x10
	 ret
 
   #----------------------------------------------------------------
   # 设置 VGA 0x13 显示模式函数
   set_video_mode_0x13:
	 movb	$0,			%ah			# 功能号 0x0
	 movb	$MODE_0x13,	%al			# 显示模式
	 int		$0x10
 
	 movw	$0x13,		video_mode
	 movw	$320,		screen_x
	 movw	$200,		screen_y
	 movl	$0xb8000,	video_ram
	
	 ret
 
   #----------------------------------------------------------------
   # 设置 VBE 0x103 显示模式
   #	因第一次写此类程序，只考虑了可读性，未考虑效率，比如 al、ah 分开赋值等
   set_video_mode_vbe_0x103:
	 # 确认 VBE 是否存在
	 movw	$BUFFER_SEG,		%ax
	 movw	%ax,				%es
	 movw	%ax,				%ds
	 xorw	%di,				%di
	
	 # 下面检查是否支持 VBE 及 VBE 版本
	 movb	$0x4f,				%ah			# VBE 标准
	 movb	$0x00,				%al			# 功能号
	 int		$0x10
 
	 cmp		$0x004f,			%ax			# 若有 VBE，AX 应该为 0x004f
	 jne		1f
	 movw	0x04(%di),			%ax
	 cmp		$0x0200,			%ax			# 若 VBE 版本不是 2.0 以上，不能使用髙分辨率
	 jb		1f
 
	 # 下面检查 MODE_VBE_0x13 的参数
	 movw	$MODE_VBE_0x103,	%cx
	 movb	$0x4f,				%ah			# 表明 VBE 标准
	 movb	$0x01,				%al			# 子功能号
	 int		$0x10
 
	 cmpb	$0x00,				%ah			# 是否调用成功
	 jne		1f
	 cmpb	$0x4f,				%al			# 是否支持该模式
	 jne		1f
	 cmpb	$8,					0x19(%di)	# 颜色是否占 8bit
	 jne		1f
	 cmpb	$4,					0x1b(%si)	# 颜色的指定方法是否为 4，即调色板方式
	 jne		1f
	 movw	(%di),				%ax
	 andw	$0x0080,			%ax
	 jz		1f								# AX 第 7 个比特是否为 1，该位表示线性帧缓存是否有效
 
	 # 下面设置模式
	 movw	$MODE_VBE_0x103,	%bx
	 addw	$0x4000,			%bx			# BX 第 14 个比特表示是否使用大的线性缓存区，故置位
	 movb	$0x4f,				%ah			# 表示使用 VBE 标准
	 movb	$0x02,				%al			# 功能号，表示设置模式
	 int		$0x10
 
	 # 下面记录切换到的模式的一些参数信息
	 movw	$MODE_VBE_0x103,	video_mode
	 movw	0x12(%di),			%ax
	 movw	%ax,				screen_x
	 movw	0x02(%di),			%ax
	 movw	%ax,				screen_y
	 movl	0x28(%di),			%eax
	 movl	%eax,				video_ram
	 movw	$1,					%ax
	 ret
   1:
	 movw	$0,					%ax
	 ret
 
	
   #----------------------------------------------------------------
   # 设置背景颜色为深蓝色
   set_screen_bk_color:
	 movw	$VIDEO_PALLETE_PORT,	%dx
	 movb	$PA_INDEX_BACKGROUND,	%al
	 outb	%al,					%dx
 
	 movw	$COLOR_SELECTION_PORT,	%dx
	 movb	$0,						%al		# 红
	 outb	%al,					%dx
	 movb	$0,						%al		# 绿
	 outb	%al,					%dx
	 movb	$18,					%al		# 蓝（亮度 18/63）
	 outb	%al,					%dx
	 ret
 
   #----------------------------------------------------------------
   # 通过写显存绘制一些像素点：
   #	首先设置调色板索引 1 处的颜色为白色
   #	然后通过写显存的方式，向 ES：DI 写入数据（PA_INDEX_WHITE）
   draw_some_pixels:
	 # 把索引 1 处的颜色改为白色（63，63，63）
	 movw	$VIDEO_PALLETE_PORT,	%dx
	 movb	$PA_INDEX_WHITE,		%al
	 outb	%al,					%dx
	 movw	$COLOR_SELECTION_PORT,	%dx
	 movb	$63,					%al		# 红
	 outb	%al,					%dx
	 movb	$63,					%al		# 绿
	 outb	%al,					%dx
	 movb	$63,					%al		# 蓝
	 outb	%al,					%dx
 
	 # 设置 ES 的值
	 movw	$VIDEO_SEG_GRAPHIC,		%ax
	 movw	%ax,					%es
 
	 # 设置要显示的像素位置的显存地址（目的地址）
	 movw	$(800*5),				%di		# 从第五行像素开始开始
	 movb	$PA_INDEX_WHITE,		%al
	 movw	$800,					%cx		# 画 800 个连续像素即一条直线
 
   draw_a_pixel:
	 stosb
	 #addl	$799,					%edi
	 loop	draw_a_pixel
 
	 ret
 
   main:
	 movw	%cx,	%ax
	 movw	%ax,	%ds
	 movw	%ax,	%es
 
	 call	clear_screen					# 清屏
	 call	set_video_mode_vbe_0x103		# 设置显示模式
 
	 cmpw	$0,		%ax
	 jne		1f
	 call	set_video_mode_0x13
   1:
	 call	set_screen_bk_color	# 设置背景颜色
	 call	draw_some_pixels	# 绘制像素
 
   1:
	 jmp		1b
 
   # 常量定义：
	 VIDEO_SEG_TEXT		= 0x0e00
	 VIDEO_SEG_GRAPHIC	= 0xa000
	 BUFFER_SEG			= 0x800
 
	 VIDEO_PALLETE_PORT	= 0x3c8
	 COLOR_SELECTION_PORT= 0x3c9
	
	 MODE_0x13			= 0x13
	 MODE_VBE_0x105		= 0x0105
	 MODE_VBE_0x103		= 0x0103
 
	 PA_INDEX_BACKGROUND	= 0x0
	 PA_INDEX_WHITE		= 0x1
 
   video_mode:
	 .short	0
   screen_x:
	 .short	0
   screen_y:
	 .short	0
   video_ram:
	 .long	0
 
	 .org	0x1fe,	0x90
	 .word	0xaa55

** babyos（五）—— 跳转到保护模式并显示一个 LOGO
   保护模式
   参考资料：
   《Intel 64 and IA-32 Architectures Software Developer's Manual》
   《Orange's 一个操作系统的实现'》
   《X86/X64 体系探测及编程》
   《30 天自制操作系统》
   《Linux 内核完全剖析》


   0.概述
   Intel IA 32 下，CUP 有两种工作模式：实模式和保护模式。打开 PC，开始时 CPU 工作在实模式下，即此前几篇东西写的代码都是在实模式下的。
   实模式下有 16 位的寄存器、16 位的数据总线、及 20 位的地址总线，1MB 的寻址能力。物理地址的计算方法：
   物理地址（Physical Address） = 段值（Segment）* 16 + 偏移值(Offset) 其中段和偏移都是 16 位的。
   从 80386 开始，Intel 的 CPU 进入 32 位时代，80386 有 32 位地址总线，寻址能力达到 4GB.
   保护模式保护处理器的某些资源不能被随意访问，如处理器的硬件资源和系统的软件资源，如 CR0 等控制寄存器，GDT、IDT 等系统级的数据结构，OS kernel 的代码和数据等。
   x86 的 segmentation 和 paging 即分段和分页机制是实施保护措施的手段。分段和分页实行了不同的内存管理模式和访问控制。

   1.权限和环境
   4 个权限级别：0～3，0 为最高级别。
   3 种权限类型：CPL、DPL、RPL：
   1）CPL（current privilege level）：当前的权限级别，指示当前代码在哪个权限级别，CPL 的值存放在 CS 寄存器 Selector 域的 RPL。（另外，SS 寄存器的 Selector 的 RPL 总等于 CPL）。
   2）DPL（Descriptor Privilege Level）：DPL 存放在描述符 Descriptor（包括段描述符 Segment Descriptor 和门描述符 Gate Descriptor）里的 DPL 域，它指示访问这些 segment 所需要的权限级别
   3）RPL（Requested Privilege Level）：存放在访问者所使用的选择子 Selector 的 Bit0 和 Bit1，指示发起访问的访问者使用什么样的权限对目标进行访问。
   若 CPL > DPL 表示当前运行的代码的权限级别不足，不能对 segment 或 gate 进行访问。

   从实模式进入保护模式，段式管理机制必须建立，分页机制是可选的，当分页机制关闭时，从段式内存管理中得到的线性地址（linear address）就是物理地址。

   2.段式管理所使用的资源
   硬件资源：
   1）CR0、CR4
   2）GDTR、LDTR（可选）、IDTR、TR
   3）段选择子寄存器：ES、CS、SS、DS、FS、GS 寄存器

   数据结构：
   1）GDT、LDT（可选）、IDT
   2）TSS
   3）段描述符（Segment Descriptor）：系统(System)段描述符、代码(Code)/数据(Data)段描述符
   4）门描述符（Gate Descriptor）：包括调用门（Call-gate），中断/陷阱门（Interrupt/Trap-gate）和任务门（Task-gate）
   5）选择子（Selector）：存放在段寄存器里。

   分段机制的内存管理职责：从逻辑地址（Logic address）转换为处理器的线性地址(Linear address).

   3.分页机制使用的资源：
   1）控制寄存器：CR0、CR2、CR3、CR4
   2）IA32_EFER
   页转换表：
   1）PDPT（Page Directory Pointer Table）
   2）PDT（Page Directory Table）
   3）PT（Page Table）

   分页机制内存管理职责：从处理器的线性地址（即 virtual address）映射到物理地址。

   read/write 的内存设备 RAM（DRAM）、read-only 的内存设备 ROM（EPROM），及 memory mapped I/O 设备都可以映射到物理地址空间上。
   典型的 ROM 设备映射到物理地址空间的高端和低端，Video 和 IGD 设备的 buffer 映射到 A0000H 到 BFFFFH 的物理地址空间，PCIe 等设备映射到物理地址空间的 E0000000 位置上，I/O APIC 设备映射到 FEC00000 以上的位置，等等。
   经过页式转换形成的物理地址，可以映射到 DRAM 或外部存储设备 Disk 上。

   4.段式内存管理
   两方面的管理：
   1）内存管理：为地址的转换提供基础
   Linear Address = base + offset
   与实模式下的原理是一致的，实模式下段的 base = selector << 4; 保护模式下，base 从 segment descriptor 里加载而来。
   2）保护措施：对访问行为的控制
   对段的 limit、type、privilege 检查

   5.段式管理的数据结构
   1）段选择子（Segment Selector）
   RPL：bit0～bit1，请求访问者所使用的权限级别
   TI：Table Indicator，描述符表索引位,bit2, TI=0 表示 GDT，TI=1 表示 LDT。
   Index：Descriptor Index，它是 Descriptor 在 GDT/LDT 中的序号。bit3~bit15,13 位，范围 0～8191，即可寻址 8192 个 descriptor。

   2）描述符表（Descriptor Table）
   Segment Selector 用于在 Descriptor Table 中查找 descriptor。
   描述符表由描述符表寄存器进行定位，对应 GDT，LDT，IDT 有 GDTR，LDTR，IDTR。在 IA32 中，这三个寄存器都是 48 位，包括低 16 位为 Limit 和髙 32 位为 Base，加载描述符表方法为 lgdt, lldt, lidt。
   其中 Limit 用于检查 Selector 是否超出 GDT 的 limit，如同数组的长度一样，判断数组是否越界。

   3）段描述符（Segment Descriptor）
   段描述符要么存放在描述符表里，要么被加载到段寄存器里。被加载到段寄存器后，它所描述的段变成了 active 状态。
   描述符有两大类：段描述符和门描述符。

   6.切换到保护模式
   Intel 推荐的步骤：
   1）关中断，包括可屏蔽中断和不可屏蔽中断
   2）使用 lgdt 加载 GDTR
   3）置 cr0 的 PE 位，切换到保护模式
   4）使用 far jmp/call，提供一个同级权限的 CS Selector 更新 CS 寄存器
   5）若需要使用 LDT，用 lldt 加载 LDTR
   6）使用 ltr 加载 TR
   7）更新 SS、DS 寄存器
   8）使用 lidt 加载 IDTR
   9）开中断


   程序源码：

   boot.s:

   #--------------------------------------------------------------
   # 文件：boot.s
   # 描述：1.清屏
   #		2.设置显示模式为 0x103（800*600，256 色）
   #		3.读取软盘，将内核加载到内存
   #		4.将内核第一个扇区(load.s)移动到内存 0x0000 位置
   #		5.将引导扇区中的 GDT 及新显示模式的一些参数移动到指定位置
   #		6.开启 A20 总线，置位 cr0 寄存器的 PE 位，进入保护模式
   # 时间：2012-12-29 21:47:12
   # 作者：guzhoudiaoke@126.com
   #--------------------------------------------------------------
 
   .include "include/kernel.inc"
 
   .section .text
   .global _start
   .code16
 
   _start:
	 jmp		main
 
   #---------------------------------------------------------------
   # 清屏：
   #	设置屏幕背景色，调色板的索引 0 指代的颜色为背景色
   #	先不考虑效率，只考虑可读性，故 ah，al 分开赋值
   #---------------------------------------------------------------
   clear_screen:				# 清屏函数
	 movb	$0x06,	%ah		# 功能号 0x06
	 movb	$0,		%al		# 上卷全部行，即清屏
	 movb	$0,		%ch		# 左上角行
	 movb	$0,		%ch		# 左上角列	
	 movb	$24,	%dh		# 右下角行
	 movb	$79,	%dl		# 右下角列
	 movb	$0x07,	%bh		# 空白区域属性
	 int		$0x10
	
	 ret
 
   #--------------------------------------------------------------------
   # 设置显示模式：
   #	1.检查 VBE 是否存在，即显卡是否支持 VESA BIOS EXTENSION
   #	2.检查 VBE 版本，是否为 2.0 以上
   #	3.检查要设置的 mode 的一些参数，看是否符合要求
   #	4.设置显示模式为 VBE 0x103（800*600，256 色）
   #	5.记录新显示模式的一些参数
   #	6.若上面检查或设置失败，则设置显示模式为 VGA 0x13（320*200，256 色）
   #--------------------------------------------------------------------
   set_video_mode:
	 movw	$0x800,				%ax
	 movw	%ax,				%es
	 movw	%ax,				%ds
	 xorw	%di,				%di
   check_vbe:
	 movb	$0x4f,				%ah			# 表示使用 VBE 标准
	 movb	$0x00,				%al			# 功能号
	 int		$0x10
	 cmp		$0x004f,			%ax			# 若有 VBE，AX 应该为 0x004f
	 jne		set_mode_vga_0x13
	 movw	0x04(%di),			%ax
	 cmp		$0x0200,			%ax			# 若 VBE 版本不是 2.0 以上
	 jb		set_mode_vga_0x13
   check_vbe_mode:								# 检查 MODE_VBE_0x13 的参数
	 movw	$VIDEO_MODE_0x103,	%cx
	 movb	$0x4f,				%ah			# 表明 VBE 标准
	 movb	$0x01,				%al			# 子功能号
	 int		$0x10
	 cmpb	$0x00,				%ah			# 是否调用成功
	 jne		set_mode_vga_0x13
	 cmpb	$0x4f,				%al			# 是否支持该模式
	 jne		set_mode_vga_0x13
	 cmpb	$8,					0x19(%di)	# 颜色是否占 8bit
	 jne		set_mode_vga_0x13
	 cmpb	$4,					0x1b(%di)	# 颜色的指定方法为 4(调色板方式)
	 jne		set_mode_vga_0x13
	 movw	(%di),				%ax
	 andw	$0x0080,			%ax
	 jz		set_mode_vga_0x13				# AX 第 bit7 是否为 1(线性帧缓存是否有效)
   set_mode_vbe:								# 下面设置模式
	 movw	$VIDEO_MODE_0x103,	%bx
	 addw	$0x4000,			%bx			# BX 第 14 个比特表示是否使用大的线性缓存区
	 movb	$0x4f,				%ah			# 表示使用 VBE 标准
	 movb	$0x02,				%al			# 功能号，表示设置模式
	 int		$0x10
   save_video_mode_info:						# 记录切换到的模式的一些参数信息
	 movw	$VIDEO_MODE_0x103,	video_mode
	 movw	0x12(%di),			%ax
	 movw	%ax,				screen_x
	 movw	0x14(%di),			%ax
	 movw	%ax,				screen_y
	 movl	0x28(%di),			%eax
	 movl	%eax,				video_ram
	 movw	$1,					%ax
	 ret
   set_mode_vga_0x13:							# 若不支持 VBE 则设置为 VGA 0x13 mode
	 movb	$0,					%ah			# 功能号 0x0
	 movb	$VIDEO_MODE_0x13,	%al			# 显示模式
	 int		$0x10
	 movw	$0x13,				video_mode
	 movw	$320,				screen_x
	 movw	$200,				screen_y
	 movl	$0xb8000,			video_ram
	
	 ret
   #----------------------------------------------------------------
   # 读取软盘一个扇区：
   #	使用 BIOS INT 0x13 中断读软盘，使用前需要设置 ES：BX 作为缓冲区
   #	AX 为相对扇区号，基于相对扇区号，为学习软盘的知识，使用了由
   #	相对扇区号来读软盘的方式，也可以直接设置读取扇区数而读连续的
   #	多个扇区。但好像有不能跨越磁道、不能超过 64KB 等限制，要小心。
   #	柱面号、磁头号、扇区号计算公式如下：
   #	柱面号 CH = N / 36，令 x = N % 36
   #	磁头号 DH = x / 18，扇区号 CL = x % 18 + 1（因为从 1 开始，故加 1）
   #-----------------------------------------------------------------
   read_a_sect:
	 movb	$36,	%dl
	 divb	%dl
	 movb	%al,	%ch		# 柱面号=N / 36, 假设 x = N % 36
	 movb	%ah,	%al		# AL = N % 36
	 xorb	%ah,	%ah		# AH = 0, 则 AX = AL = N % 36
	 movb	$18,	%dl
	 divb	%dl
	 movb	%al,	%dh		# 磁头号 DH = x / 18
	 movb	%ah,	%cl		# CL = x % 18
	 incb	%cl				# 扇区号 CL = x % 18 + 1
 
	 movb	$0x00,	%dl		# 驱动器号 DL = 0，表示第一个软盘即 floppya
	 movb	$0x02,	%ah		# 功能号 0x02 表示读软盘
	 movb	$0x01,	%al		# 读取一个扇区数
 
   re_read:					# 若调用失败（可能是软盘忙损坏等）则重新调用
	 int		$0x13
	 jc		re_read			# 若进位位（CF）被置位，表示调用失败
	
	 ret
 
   #-------------------------------------------------------------------
   # 读取内核到内存
   #	该函数读取 baby OS 的内核到内存，第一个扇区为引导扇区，需要读取
   #	的是从第二个扇区（相对扇区号 1）开始的 KERNEL_SECT_NUM 个扇区
   #	ES：BX 为缓冲区，为读取内核的临时位置 0x10000
   #-------------------------------------------------------------------
   read_kernel:
	 movw	$0x1000,			%ax		
	 movw	%ax,				%es		# ES:BX 为缓冲区地址
	 xorw	%bx,				%bx
	 movw	$0x00,				%si		# 已经读取的扇区数
	 movw	$0x01,				%di		# 相对扇区号
   1:	
	 movw	%di,				%ax		# 将相对扇区号传给 AX 作为参数
	 call	read_a_sect
 
	 incw	%si
	 incw	%di
	 addw	$512,				%bx
	 cmpw	$KERNEL_SECT_NUM,	%si
	 jne		1b
 
	 ret
 
   #--------------------------------------------------------------------
   # 移动内核第一个扇区：
   #	内核从软盘读取到内存的一个临时位置，现在将第一个扇区移动到内存
   #	0x0000 处，第一个扇区即 load.s，它将会把内核剩余部分移动到它的后面，
   #	之所以分两次移动，是因为若内核较大，一次移动会覆盖 0x7c00 处的代码，
   #	即引导扇区的代码，导致运行出错。
   #--------------------------------------------------------------------
   move_first_sect_of_kernel:
	 cli									# 指明 SI，DI 递增
	 movw	$0x1000,			%ax
	 movw	%ax,				%ds		# DS:SI 为源地址
	 xorw	%si,				%si
	 movw	$0x00,				%ax
	 movw	%ax,				%es		# ES:DI 为目标地址
	 xorw	%di,				%di
	 movw	$512 >> 2,			%cx		# 移动 512/4 次
	 rep		movsl						# 每次移动 4 个 byte
 
	 ret
 
 
   #--------------------------------------------------------------------
   # 移动 GDT 及新显示模式的参数信息到指定位置
   #	该函数把 GDT 及参数信息移动到指定的位置，以便于以后使用
   #--------------------------------------------------------------------
   move_gdt_and_video_info:
	 xorw	%ax,						%ax
	 movw	%ax,						%ds		# DS:SI 为源地址
	 leaw	gdt,						%si
	 movw	$GDT_ADDR >> 4,				%ax		# 由要保存的地址来计算段基址
	 movw	%ax,						%es		# ES:DI 为目的地址
	 xorw	%di,						%di
	 movw	$GDT_SIZE+VIDEO_INFO_SIZE,	%cx		# 移动的双字个数
	 rep		movsb
 
	 ret
 
   #--------------------------------------------------------------------
   # 开启保护模式：	
   #	1.关中断
   #	2.加载 GDT
   #	3.开启 A20 总线，置 cr0 的 PE 位，切换到保护模式
   #	4.far jmp/call，用一个 CS Selector 更新 CS 寄存器，开始执行新代码
   #--------------------------------------------------------------------
   enter_protected_mode:
	 cli									# 关中断
	 lgdt	gdt_ptr						# 加载 GDT
 
   enable_a20:	
	 inb		$0x64,			%al			# 从端口 0x64 读取数据
	 testb	$0x02,			%al			# 测试读取数据第二个 bit
	 jnz		enable_a20					# 忙等待
 
	 movb	$0xdf,			%al
	 outb	%al,			$0x64		# 将 0xdf 写入端口 0x60
 
	 movl	%cr0,			%eax		# 读取 cr0 寄存器
	 orl		$0x01,			%eax		# 置位最后以为即 PE 位
	 movl	%eax,			%cr0		# 写 cr0 寄存器
 
	 ljmp	$CODE_SELECTOR,	$0x00		# 跳转到代码段，即 load.s 处开始执行
	
	 ret 
 
   #--------------------------------------------------------------------
   # 开始执行后，会跳转到此处开始执行
   #--------------------------------------------------------------------	
   main:
	 movw	%cx,		%ax
	 movw	%ax,		%ds
	 movw	%ax,		%es
	 movw	%ax,		%ss
	 movw	$0x1000,	%sp
 
	 call	clear_screen				# 清屏
	 call	set_video_mode				# 设置显示模式
	 call	read_kernel					# 从软盘读取内核
	 call	move_first_sect_of_kernel	# 将内核第一个扇区 load.s 移动到 0x0000
	 call	move_gdt_and_video_info		# 将 GDT 和显示模式信息保存起来
	 call	enter_protected_mode		# 进入包含模式
 
   1:
	 jmp		1b
 
   gdt:
	 .quad	0x0000000000000000			# 空描述符
	 .quad	0x00cf9a000000ffff			# 代码段描述符
	 .quad	0x00cf92000000ffff			# 数据段描述符
	 .quad	000000000000000000			# 留待以后使用
	 .quad	000000000000000000			# 留待以后使用
   video_mode:								# 显示模式
	 .short	0
   screen_x:								# 水平分辨率
	 .short	0 
   screen_y:								# 垂直分辨率
	 .short	0	
   video_ram:								# video_ram 地址
	 .long	0
   gdt_ptr:								# 用与 lgdt 加载 GDT
	 .word	screen_x - gdt - 1			# GDT 段限长
	 .long	GDT_ADDR					# GDT 基地址
 
	 .org	0x1fe,	0x90				# 用 nop 指令填充
	 .word	0xaa55						# 引导扇区标志

   load.s:
   #*************************************************************************
   #	> File:		load.s
   #	> Desc:		1.设置新的数据段等
   #				2.将内核剩余部分移动到 load.s 后面
   #				3.显示 babyos 加载成功的 Logo
   #	> Author:	孤舟钓客
   #	> Mail:		guzhoudiaoke@126.com 
   #	> Time:		2012 年 12 月 30 日 星期日 22 时 23 分 55 秒
   #*************************************************************************
 
   .include "include/kernel.inc"
 
   .section .text
   .global	_start
 
   .org	0
 
   _start:
	 movl	$DATA_SELECTOR,			%eax
	 movw	%ax,					%ds
	 movw	%ax,					%es
	 movw	%ax,					%fs
	 movw	%ax,					%gs
	 movw	%ax,					%ss
	 movl	$STACK_BOTTOM,			%esp
 
   load_lefted_kernel:
	 cld
	 movl	$0x10200,				%esi
	 movl	$0x200,					%edi
	 movl	$(KERNEL_SECT_NUM-1)<<7,%ecx
	 rep		movsl
 
   show_logo:
	 movl	$0xe0000000,			%edi
	 addl	$272 + 800*10,			%edi
	 movl	$0x400,					%esi
 
	 movl	$128,					%ebx
	 movl	$1,						%eax
   1:	
	 movl	$256,					%ecx
   set_line_mem:	
	 cmpb	$255,					(%esi)
	 je		2f
	 movb	%al,					(%edi)
   2:
	 inc		%esi
	 inc		%edi
	 loop	set_line_mem
	
	 addl	$800-256,				%edi
	 decl	%ebx
	 jnz		1b
 
   3:	
	 jmp		3b
 
	 .org	512,	0x90	

   baby os 暂时使用下面的简单 logo：
** babyos（六）—— 显示 ASCII 字符和汉字
   本以为要在裸机上显示个汉字是极难的，没想到亲自动手做一下，也不甚难做。“天下
   事有难易乎？为之，则难者亦易矣，不为，则易者亦难亦” 古人诚不我欺。

   参考：

   http://blog.sina.com.cn/s/blog_8c7bf19701010rhn.html

   《30 天自制操作系统》



   0.实验结果：




   1.测试点阵字体 ASC16 和 HZK16
   关于点阵字体 ASC16、HZK16 详见上述参考的博客，此一篇足矣。

   下面是我的测试代码（当时只为测试，随手写的）：


   /*************************************************************************
	 > File:		test.c
	 > Describe:	尝试使用点阵字体显示 ASCII 码和汉字
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 01 日 星期二 00 时 47 分 17 秒
   ************************************************************************/
 
   #include <stdio.h>
 
   unsigned char font_asc[4096];
   unsigned char font_hzk[267616];
 
   int load_asc()
   {
	 FILE *fp;
	
	 fp = fopen("./resource/font/ASC16", "rb");
	 if (fp == NULL)
	 {
	 printf ("read ASC16 file failed!");
	 return 0;
	 }
 
	 fread(font_asc, 1, 4096, fp);
	 fclose(fp);
 
	 return 1;
   }
 
   int load_hzk()
   {
	 FILE *fp;
	
	 fp = fopen("./resource/font/HZK16", "rb");
	 if (fp == NULL)
	 {
	 printf ("read HZK16 file failed!");
	 return 0;
	 }
 
	 fread(font_hzk, 1, 267616, fp);
	 fclose(fp);
 
	 return 1;
   }
 
   int disp_asc(unsigned char c)
   {
	 unsigned char *pc = font_asc + (int)c * 16;
 
	 int i, j;
	 for (i = 0; i < 16; i++)
	 {
	 unsigned char test_bit = 128;
	 for (j = 0; j < 8; j++)
	 {
	 if (*pc & test_bit)
	 printf("*");
	 else
	 printf(" ");
 
	 test_bit >>= 1;
	 }
	 printf("\n");
	 pc++;
	 }
 
	 return 1;
   }
 
   int disp_hzk(unsigned char ch[3])
   {
	 unsigned char qu_no	 = ch[0] - 0xa0;
	 unsigned char wei_no = ch[1] - 0xa0;
	 unsigned long offset = (94*(qu_no-1) + (wei_no-1)) * 32;
	 unsigned char *pc = font_hzk + offset;
	
	 int i, j;
	 for (i = 0; i < 32; i++)
	 {
	 unsigned char test_bit = 128;
	 for (j = 0; j < 8; j++)
	 {
	 if (*pc & test_bit)
	 printf("@");
	 else
	 printf(" ");
 
	 test_bit >>= 1;
	 }
 
	 pc++;
	 if (i & 1)
	 printf("\n");
	 }
	
	 return 1;
   }
 
   int main()
   {
	 if (!load_asc() || !load_hzk())
	 {
	 printf("load font error!");
	 return 0;
	 }
 
	 unsigned char c = 'G';
	 disp_asc(c);
 
	 unsigned char hz[3] = "钓";
	 disp_hzk(hz);
	 disp_hzk("客");
 
	 return 0;
   }
   结果：





   2.增加 Babyos kernel 扇区数，将点阵字体加载到内存
   本 blog 只为记录开发过程，以供日后参考，所以不会每次贴所有代码，只贴新的内容，前面若有更改，会指出。

   在此过程中，修改两个地方：

   1）增加 kernel 扇区后发现系统不能正常运行。后又发现最多只能支持 128 个扇区。经 bochs 单步调试若干次，最后发现每读一个扇区后 bx 增加 512，会导致读入 128 个扇区后溢出，也就是超出了一个段 64KB 寻址的能力，所以导致后面的内容覆盖前面的内容，以至于系统不能正常运行。改为每次增加 es：


   read_kernel:
	 movw	$0x1000,			%si		
	 movw	%si,				%es		# ES:BX 为缓冲区地址
	 xorw	%bx,				%bx
	 movw	$0x01,				%di		# 相对扇区号
   1:	
	 movw	%di,				%ax		# 将相对扇区号传给 AX 作为参数
	 call	read_a_sect
 
	 addw	$512>>4,			%si
	 movw	%si,				%es
	 incw	%di
	 cmpw	$KERNEL_SECT_NUM+1,	%di
	 jne		1b
 
	 ret
   2）在 init.c 中简单定一个了一个指向前面的 VIDEO_INFO 的结构体指针，发现结果不对。调试发现结构体内存对齐问题。于是简单增加了两个显示模式的参数。

   video_mode:								# 显示模式
	 .short	0
   screen_x:								# 水平分辨率
	 .short	0 
   screen_y:								# 垂直分辨率
	 .short	0	
   bits_per_pixel:
	 .byte	0
   memory_model:
	 .byte	0
   video_ram:								# video_ram 地址
	 .long	0
   当然，也可以修改 init.c 中结构体的定义中的内存对齐方式。


   3.显示
   load.s 中最后调用 init，进入 C 语言文件 init.c 中定义的 init()函数。

   init.c 本不应有下面的代码，但目前只为测试正确性，所以没有考虑代码的组织，后面这部分代码将会重新组织到其他文件中。


   /*************************************************************************
	 > File:		init.c
	 > Author:	孤舟钓客
	 > Describe:	主要完成初始化工作
	 0.绘制矩形，测试 C 直接写显存以及测试保存的 VIDEO_INFO 正确性
	 1.测试显示 ASCI 字符
	 2.测试显示汉字
	 3.显示 ASCII 与汉字混合的字符串
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 01 日 星期二 17 时 25 分 24 秒
   ************************************************************************/
 
   #include "include/types.h"
   #include "include/kernel.h"
 
   typedef struct struct_video_info {
	 WORD	video_mode;
	 WORD	screen_x;
	 WORD	screen_y;
	 BYTE	bits_per_pixel;
	 BYTE	memory_model;
	 BYTE*	p_vram;
   } struct_video_info;
 
   const struct_video_info* p_video_info = (struct_video_info*)(VIDEO_INFO_ADDR);
   COLOR current_color = 6;
 
 
   static void fill_rectangle(WORD left, WORD right, WORD top, WORD bottom)
   {
	 BYTE* p_vram = p_video_info->p_vram + top*p_video_info->screen_x;
 
	 int row, col;
	 for (row = top; row < bottom; row++) 
	 {
	 for (col = left; col < right; col++)
	 p_vram[col] = current_color;
	 p_vram += 800;
	 }
   }
 
   void display_asc(char ch, int x, int y)
   {
	 BYTE* p_asc = (BYTE*)(FONT_ASC_ADDR) + ch * 16;
	 BYTE* p_vram = p_video_info->p_vram + y*p_video_info->screen_x;
 
	 int i, j;
	 for (i = 0; i < 16; i++)
	 {
	 BYTE test_bit = 128;
	 BYTE* p_cur_vram = p_vram+x;
		
	 for (j = 0; j < 8; j++)
	 {
	 if (*p_asc & test_bit)
	 p_cur_vram[j] = 3;
	 else
	 p_cur_vram[j] = 0;
 
	 test_bit >>= 1;
	 }
		
	 p_asc++;
	 p_vram += p_video_info->screen_x;
	 }
   }
 
   void display_hzk(char ch[3], int x, int y)
   {
	 BYTE qu_no  = (BYTE)ch[0] - 0xa0;
	 BYTE wei_no = (BYTE)ch[1] - 0xa0;
	 DWORD offset= (94*(qu_no-1) + (wei_no-1)) * 32;
 
	 BYTE* p_hzk = (BYTE*)(FONT_HZK_ADDR) + offset;
	 BYTE* p_vram = p_video_info->p_vram + y*p_video_info->screen_x;
 
	 int i, j, k;
	 for (i = 0; i < 16; i++)
	 {
	 for (j = 0; j < 2; j++)
	 {
	 BYTE test_bit = 128;
	 BYTE* p_cur_vram = p_vram+x+j*8;
		
	 for (k = 0; k < 8; k++)
	 {
	 if (*p_hzk & test_bit)
	 p_cur_vram[k] = 3;
	 else
	 p_cur_vram[k] = 0;
 
	 test_bit >>= 1;
	 }
		
	 p_hzk++;
	 }
	 p_vram += p_video_info->screen_x;
	 }
   }
 
   void test_vram(void)
   {
	 int i;
	 BYTE* p = p_video_info->p_vram;
	 for (i = 800*15; i < 800*20; i++)
	 *(p+i) = 2;
   }
 
 
   void show_logo(int x, int y)
   {
	 BYTE* p_vram = p_video_info->p_vram + y*p_video_info->screen_x;
	 BYTE* p_logo = (BYTE*)(LOGO_ADDR);
	
	 int i, j;
	 for (i = 0; i < LOGO_CY; i++)
	 {
	 BYTE* p_cur = p_vram + x;
	 for (j = 0; j < LOGO_CX; j++)
	 {
	 if (p_logo[j] != 0xff)
	 p_cur[j] = 4;
	 else
	 p_cur[j] = 0;
	 }
	 p_vram += p_video_info->screen_x;
	 p_logo += LOGO_CX;
	 }
   }
 
   /* 实现一个简陋的打印字符串程序，暂不能只能换行，过几天重写 */
   void display_string(char* str, int x, int y)
   {
	 char* p = str;
	 WORD cur_x = x, cur_y = y;
	 char hzk[3];
	 hzk[2] = '\0';
 
	 while (*p != '\0')
	 {
	 if ((*p & 0x80) == 0)
	 {
	 display_asc(*p, cur_x, cur_y);
	 cur_x += 8;
	 p++;
	 }
	 else
	 {
	 hzk[0] = *p++;
	 hzk[1] = *p++;
	 display_hzk(hzk, cur_x, cur_y);
	 cur_x += 16;
	 }
	 }
   }
 
   void init(void)
   {
	 test_vram();
	
	 show_logo(400-128, 20);
 
	 fill_rectangle(256, 512, 150, 200);
 
	 display_asc('B', 300 + 8*0, 200);
	 display_asc('a', 300 + 8*1, 200);
	 display_asc('b', 300 + 8*2, 200);
	 display_asc('y', 300 + 8*3, 200);
	 display_asc(' ', 300 + 8*4, 200);
	 display_asc('O', 300 + 8*5, 200);
	 display_asc('S', 300 + 8*6, 200);
 
	 display_hzk("孤", 358 + 16*0, 200);
	 display_hzk("舟", 358 + 16*1, 200);
	 display_hzk("钓", 358 + 16*2, 200);
	 display_hzk("客", 358 + 16*3, 200);
 
	 display_string("测试 display_string 能不能行～", 300, 220);
 
	 display_string("天下风云出我辈，", 300, 250+18*0);
	 display_string("一入江湖岁月催。", 300, 250+18*1);
	 display_string("皇图霸业谈笑中，", 300, 250+18*2);
	 display_string("不胜人生一场醉。", 300, 250+18*3);
	 display_string("只叹尘事如潮，",   300, 250+18*4);
	 display_string("人如水！何时归！", 300, 250+18*5);
	 display_string("提剑跨骑挥鬼蜮，", 300, 250+18*6);
	 display_string("白骨如山鸟惊飞。", 300, 250+18*7);
	 display_string("尘事如潮人如水，", 300, 250+18*8);
	 display_string("只叹江湖几人回。", 300, 250+18*9);
	 display_string("夜雨八方战孤城，", 300, 250+18*10);
	 display_string("平明剑气看刀声。", 300, 250+18*11);
	 display_string("侠骨千年寻不见，", 300, 250+18*12);
	 display_string("碧血红叶醉秋风。", 300, 250+18*13);
   }

   胡思乱想一下后面的任务——憧憬一下而已，实现顺序没仔细考虑，能否实现也没考虑：
   1）绘制一个简单的界面

   2）重新组织这些代码

   3）实现一个稍微优雅些的 kprintf 函数

   4）中断和异常

   5）键盘、鼠标、时钟中断

   6）任务切换

   7）输入（要实现输入中文难道要自己写个输入法？？这个毕业后去搜狗干两年该容易了。。。）

   8）内存管理

   9）系统调用

   10）文件系统

   11）终端

   12）几个简单应用程序（写过好几次的拼图游戏一定得实现一个！）

   13）其他待定



   ^_^，路曼曼其修远兮～慢慢来，Just for fun。在此中收获一份成就感，收获一份喜悦，足矣。
** babyos（七）—— 简易图形库
   2013 年 01 月 04 日 02:29:01 孤舟钓客 阅读数：3785
   版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/guzhou_diaoke/article/details/8462880
   注：以下代码为原创，若发现 bug，万望指出，若有问题，欢迎交流，转载请指明出处。若能有助于一二访客，幸甚。

   与裸机做斗争真是其乐无穷啊～～

   终究是能画点、线、矩形、圆、填充矩形、字符、汉字、LOGO 了。且做了目前我能做到的最好的代码组织。下一步就是用这些函数实现一个简单的界面。







   整理绘图功能的函数，组织成一个简易的图形库

   1.绘制点直线、圆、矩形、填充矩形的函数放到 graphic.c 中

   /*************************************************************************
	 > File:		graphics.c
	 > Describe:      实现基本绘图功能
	 > Author:	       孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 02 日 星期三 22 时 21 分 31 秒
   ************************************************************************/
 
   #include <graphics.h>
   #include <kernel.h>
   #include <math.h>
 
   static video_info_t* p_video_info = (video_info_t*)(VIDEO_INFO_ADDR);
   static u32 screen_cx = 0;
   static u32 screen_cy = 0;
 
   static color8 current_color = 0;
   static u32 current_x = 0;
   static u32 current_y = 0;
 
   static u8* p_vram_base;
 
   BOOL init_video()
   {
	 screen_cx = p_video_info->resolution_cx;
	 screen_cy = p_video_info->resolution_cy;
 
	 current_x = 0;
	 current_y = 0;
	 current_color = 0;
 
	 p_vram_base = p_video_info->p_vram_base;
 
	 return TRUE;
   }
 
   static BOOL set_color8(color8 color)
   {
	 current_color = color;
	 return TRUE;
   }
 
   BOOL set_pixel(s32 x, s32 y)
   {
	 /* 超出屏幕范围 */
	 if (x < 0 || y < 0 || (u32)x >= screen_cx || (u32)y >= screen_cy)
	 return FALSE;
	
	 *(p_vram_base + y*screen_cx + x) = current_color;
 
	 return TRUE;
   }
 
   /* Bresenham line algorithm */
   static BOOL bresenham_line(s32 start_x, s32 start_y, s32 end_x, s32 end_y)
   {
	 s32 dx, dy, x, y, p, k;
 
	 dx = abs(end_x - start_x);
	 dy = abs(end_y - start_y);
	 k  = (end_x-start_x) * (end_y-start_y);
 
	 if (dx >= dy)
	 {
	 p = 2*dy - dx;
	 if (start_x < end_x)
	 {
	 x = start_x;
	 y = start_y;
	 }
	 else
	 {
	 y = end_y;
	 x = end_x;
	 end_x = start_x;
	 }
 
	 while (x < end_x)
	 {
	 set_pixel(x, y);
	 ++x;
 
	 if (p < 0)
	 p += 2*dy;
	 else
	 {
	 if (k > 0) ++y;
	 else --y;
 
	 p += 2*dy - 2*dx;
	 }
	 }
	 }
	 else
	 {
	 p = 2*dx - dy;
	 if (start_y < end_y)
	 {
	 x = start_x;
	 y = start_y;
	 }
	 else
	 {
	 y = end_y;
	 x = end_x;
	 end_y = start_y;
	 }
 
	 while (y < end_y)
	 {
	 set_pixel(x, y);
	 ++y;
 
	 if (p < 0)
	 p += 2*dx;
	 else
	 {
	 if (k > 0) ++x;
	 else --x;
 
	 p += 2*dx - 2*dy;
	 }
	 }
	 }
 
	 return TRUE;
   }
 
   BOOL draw_line(s32 start_x, s32 start_y, s32 end_x, s32 end_y)
   {
	 return bresenham_line(start_x, start_y, end_x, end_y);
   }
 
   BOOL draw_circle(s32 center_x, s32 center_y, u32 radius)
   {
	 s32 x, y, p;
	 x = 0, y = radius, p = 1-radius;
 
	 while (x < y)
	 {
	 set_pixel(center_x + x, center_y + y);
	 set_pixel(center_x - x, center_y + y);
	 set_pixel(center_x - x, center_y - y);
	 set_pixel(center_x + x, center_y - y);
	 set_pixel(center_x + y, center_y + x);
	 set_pixel(center_x - y, center_y + x);
	 set_pixel(center_x - y, center_y - x);
	 set_pixel(center_x + y, center_y - x);
 
	 x++;
	 if (p < 0) p += 2*x + 1;
	 else
	 {
	 y--;
	 p += 2*x - 2*y + 1;
	 }
	 }
 
	 return TRUE;
   }
 
   BOOL draw_rectangle(s32 left, s32 top, u32 width, u32 height)
   {
	 u8* p_vram1;
	 u8* p_vram2;
	 s32 right, bottom, x, y;
	
	 right = left + width;
	 bottom = top + height;
 
	 if (left < 0) left = 0;
	 if (top  < 0) top  = 0;
	 if ((u32)left >= screen_cx || (u32)top >= screen_cy)
	 return FALSE;
 
	 if (right < 0 || bottom < 0)
	 return FALSE;
 
	 if ((u32)right  > screen_cx) right  = screen_cx;
	 if ((u32)bottom > screen_cy) bottom = screen_cy;
 
	 p_vram1 = p_vram_base + top*screen_cx + left;
	 p_vram2 = p_vram_base + top*screen_cx + right;
	 for (y = top; y < bottom; y++) 
	 {
	 *p_vram1 = current_color;
	 *p_vram2 = current_color;
 
	 p_vram1 += screen_cx;
	 p_vram2 += screen_cx;
	 }
 
	 p_vram1 = p_vram_base + top*screen_cx + left;
	 p_vram2 = p_vram_base + bottom*screen_cx + left;
	 for (x = left; x < right; x++)
	 {
	 *(p_vram1++) = current_color;
	 *(p_vram2++) = current_color;
	 }
	
	 return TRUE;
   }
 
   BOOL fill_rectangle(s32 left, s32 top, u32 width, u32 height)
   {
	 u8* p_vram;
	 s32 right, bottom, x, y;
	
	 right	= left + width;
	 bottom	= top  + height;
 
	 /* 超出边界，截取在屏幕中的部分 */
	 if (left < 0) left = 0;
	 if (top  < 0)  top = 0;
 
	 /* 完全在屏幕外 */
	 if ((u32)left >= screen_cx || (u32)top >= screen_cy)
	 return FALSE;
 
	 /* 完全在屏幕外 */
	 if (right < 0 || bottom < 0)
	 return FALSE;
 
	 /* 超出边界，截取在屏幕中的部分 */
	 if ((u32)right  > screen_cx)  right = screen_cx;
	 if ((u32)bottom > screen_cy) bottom = screen_cy;
 
	 p_vram = p_vram_base + top*screen_cx;
 
	 for (y = top; y < bottom; y++) 
	 {
	 for (x = left; x < right; x++)
	 p_vram[x] = current_color;
		
	 p_vram += screen_cx;
	 }
 
	 return TRUE;
   }
 
 
   BOOL set_color(color8 color)
   {
	 return set_color8(color);
   }

   2.绘制字符和汉字的函数放到 font.c 中

   /*************************************************************************
	 > File:		font.c
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 03 日 星期四 16 时 40 分 52 秒
   ************************************************************************/
 
   #include <font.h>
   #include <kernel.h>
   #include <graphics.h>
 
   static u8* p_font_asc16_base = (u8*)(FONT_ASC_ADDR);
   static u8* p_font_hzk16_base = (u8*)(FONT_HZK_ADDR);
 
   static BOOL draw_asc16(char ch, s32 left, s32 top)
   {
	 u8* p_asc;
	 s32 x, y;
 
	 p_asc = p_font_asc16_base + ch * FONT_ASC16_SIZE;
	 for (y = 0; y < FONT_ASC16_HEIGHT; y++)
	 {
	 u8 test_bit = 1 << 7;
		
	 for (x = 0; x < FONT_ASC16_WIDTH; x++)
	 {
	 if (*p_asc & test_bit)
	 set_pixel(left+x, top+y);
 
	 test_bit >>= 1;
	 }
		
	 p_asc++;
	 }
 
	 return TRUE;
   }
 
   static BOOL draw_hzk16(char ch[3], s32 left, s32 top)
   {
	 u8 qu_no, wei_no;
	 u32 offset;
	 s32 y, x;
	 u8* p_hzk;
 
	 qu_no  = (u8)ch[0] - 0xa0;
	 wei_no = (u8)ch[1] - 0xa0;
	 offset= (94*(qu_no-1) + (wei_no-1)) * FONT_HZK16_SIZE;
	 p_hzk = p_font_hzk16_base + offset;
 
	 for (y = 0; y < FONT_HZK16_HEIGHT; y++)
	 {
	 u8 test_bit = 1 << 7;
		
	 for (x = 0; x < FONT_HZK16_WIDTH; x++)
	 {
	 if (*(p_hzk + (x & 8 ? 1 : 0)) & test_bit)
	 set_pixel(left+x, top+y);	
 
	 if ((test_bit >>= 1) == 0)
	 test_bit = 1 << 7;
	 }
	 p_hzk += 2;
	 }
 
	 return TRUE;
   }
 
   /* 实现一个简陋的打印字符串程序 */
   static BOOL draw_string16(char* str, s32 left, s32 top)
   {
	 char* p = str;
	 char hzk[3];
	 s32 cur_x, cur_y;
 
	 hzk[2] = '\0';
	 cur_x = left;
	 cur_y = top;
 
	 while (*p != '\0')
	 {
	 if ((*p & 0x80) == 0)
	 {
	 draw_asc16(*p, cur_x, cur_y);
	 cur_x += 8;
	 p++;
	 }
	 else
	 {
	 hzk[0] = *p++;
	 hzk[1] = *p++;
	 draw_hzk16(hzk, cur_x, cur_y);
	 cur_x += 16;
	 }
	 }
 
	 return TRUE;
   }
 
   BOOL draw_asc(char ch, int left, int top)
   {
	 return draw_asc16(ch, left, top);
   }
 
   BOOL draw_hzk(char ch[3], int left, int top)
   {
	 return draw_hzk16(ch, left, top);
   }
 
   BOOL draw_string(char *str, int left, int top)
   {
	 return draw_string16(str, left, top);
   }

   3.绘制 logo 的函数放到 logo.c 中

   /*************************************************************************
	 > File:		logo.c
	 > Describe: 显示那个可爱的小篆字体的 LOGO	
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 03 日 星期四 17 时 05 分 11 秒
   ************************************************************************/
 
   #include <logo.h>
   #include <kernel.h>
   #include <graphics.h>
 
 
   static u8* p_logo_base = (u8*)(LOGO_ADDR);
   static u32 logo_cx = (u32)(LOGO_CX);
   static u32 logo_cy = (u32)(LOGO_CY);
 
 
   BOOL draw_logo(s32 left, s32 top)
   {
	 u32 y, x;
	 u8* p_logo = p_logo_base;
 
	 for (y = 0; y < logo_cy; y++)
	 {
	 for (x = 0; x < logo_cx; x++)
	 {
	 if (p_logo[x] != 0xff)
	 set_pixel(left+x, top+y);
	 }
	 p_logo += logo_cx;
	 }
 
	 return TRUE;
   }
** babyos（八）—— 简单图形界面
   2013 年 01 月 05 日 18:20:40 孤舟钓客 阅读数：3062
   版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/guzhou_diaoke/article/details/8470023
   注：以下代码为原创，若发现 bug，万望指出，若有问题，欢迎交流，转载请指明出处。若能有助于一二访客，幸甚。

   欢迎关注 babyos 的成长历程和宝贝计划：https://github.com/guzhoudiaoke/babyos/wiki



   前面已经实现了一个简易的图形库，那么实现一个简单的图形界面是理所当然的事。

   babyos 走的是好玩、可爱、漂亮的路线，怎么好玩怎么来，怎么漂亮怎么来，所以这个图形界面还是着实费了一番功夫的，属于高级山寨。虽然没有什么技术含量，但画面着实焕然一新，也算作一点进步。

   系统已经定名为 babyos，翻译作宝贝/宝宝操作系统，则她画出来的界面叫做“涂鸦”也是情理之中的事儿，当然这是高级山寨涂鸦喽～

   图形界面暂时定名为 graffiti，译作“涂鸦”，虽然是髙仿真 Ubuntu Gnome 的一种情景模式，但实现方法与它毫无关系（当然是水的多了）。

   注：此前 babyos 已经切换到 800x600 24bit 颜色显示模式——不为别的，只为与《30 天》不同，或者内心深处希望比鬼子做的好一点，所以界面是髙仿真 linux 以与《30 天》低仿真 windows 做比较～o(∩∩)o...哈哈

   实验结果：





   主要代码：


   /*************************************************************************
	 > File:		graffiti.c
	 > Describe: 系统叫 baby，其界面名曰 graffiti，取儿童涂鸦之意
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 05 日 星期六 00 时 29 分 31 秒
   ************************************************************************/
   #include <graffiti.h>
 
   static u32 screen_cx;
   static u32 screen_cy;
 
 
   static BOOL init_graffiti()
   {
	 screen_cx = get_screen_width();
	 screen_cy = get_screen_height();
 
	 return TRUE;
   }
 
 
   /* 绘制桌面背景 */
   BOOL draw_background()
   {
	 color24 old_color = set_color(RGB(background_color.r, background_color.g, background_color.b));
	 fill_rectangle(0, 0, screen_cx, screen_cy);
	 set_color(old_color);
 
	 return TRUE;
   }
 
   /* position 暂时只支持 0 或 1，0 表示在屏幕最上面画，1 表示在最下面 */
   BOOL draw_panel(u8 position)
   {
	 s32 top, bottom, y;
	 color24 old_color;
 
	 if (position == 0)
	 {
	 top = 0; bottom = PANEL_HEIGHT;
	 }
	 else
	 {
	 bottom = screen_cy; top = bottom-PANEL_HEIGHT;
	 }
 
	 old_color = get_current_color();
	
	 for (y = top; y < bottom; y++)
	 {
	 set_color_t(panel_color[y-top]);
	 fill_rectangle(0, y, screen_cx, 1);
	 }
	
	 set_color(old_color);
 
	 return position;
   }
 
   /* 绘制一个窗口 */
   BOOL draw_window(s32 left, s32 top, u32 width, u32 height)
   {
	 s32 right, bottom, y, i;
	 color24 old_color;
 
	 if (width < MIN_WINDOW_WIDTH) 
	 width = MIN_WINDOW_WIDTH;
 
	 right = left + width;
	 bottom = top + height + W_HEAD_HEIGHT;
	
	 y = top;
	 i = 0;
	 old_color = get_current_color();
	
	 /* 窗体头 */
	 for (i = 0; i < W_ROUND_RECT_HEIGHT; i++)
	 {
	 set_color_t(w_head_color[i]);
	 fill_rectangle(left+w_round_rect_width[i], y++, width-w_round_rect_width[i]*2, 1);
	 }
		
	 set_color_t(w_head_color[0]);
	 for (i = 0; i < W_ROUND_RECT_POINT_NUM; i++)
	 {
	 set_pixel(left+w_round_rect_border_points[i].x, top+w_round_rect_border_points[i].y);
	 set_pixel(right-w_round_rect_border_points[i].x-1, top+w_round_rect_border_points[i].y);
	 }
 
	 for (; i < W_HEAD_HEIGHT; i++)
	 {
	 set_color_t(w_head_color[i]);
	 fill_rectangle(left, y++, width, 1);
	 }
 
	 /* 窗体 */
	 set_color_t(w_boday_color);
	 fill_rectangle(left, top+W_HEAD_HEIGHT, width, height-W_ROUND_RECT_HEIGHT);
 
	 y = bottom - 1;
	 for (i = 0; i < W_ROUND_RECT_HEIGHT; i++)
	 {
	 fill_rectangle(left+w_round_rect_width[i], y--, width-w_round_rect_width[i]*2, 1);
	 }
 
	 set_color_t(w_bottom_color);
	 for (i = 0; i < W_ROUND_RECT_POINT_NUM; i++)
	 {
	 set_pixel(left+w_round_rect_border_points[i].x, bottom-w_round_rect_border_points[i].y-1);
	 set_pixel(right-w_round_rect_border_points[i].x-1, bottom-w_round_rect_border_points[i].y-1);
	 }
 
	 /* 窗体边框 */
	 set_color_t(w_bottom_color);
	 fill_rectangle(left+w_round_rect_border_points[0].x, bottom-1, width-w_round_rect_border_points[0].x*2, 1);
 
	 for (i = 0; i < W_BORDER_WIDTH; i++)
	 {
	 set_color_t(w_border_color[i]);
	 fill_rectangle(left+i, top+W_HEAD_HEIGHT, 1, height-W_ROUND_RECT_HEIGHT);
	 fill_rectangle(right-i-1, top+W_HEAD_HEIGHT, 1, height-W_ROUND_RECT_HEIGHT);
	 }
 
	 /* 关闭按钮 */
 
	 set_color(old_color);
	
	 return TRUE;
   }
 
 
   /* 安装 graffiti 界面 */
   BOOL install_graffiti()
   {
	 init_graffiti();
	
	 draw_background();
	
	 draw_panel(0);
	 draw_panel(1);
 
	 return TRUE;
** babyos（九） —— 显示 bitmap
   2013 年 01 月 06 日 16:09:11 孤舟钓客 阅读数：2327 标签：babyos Bitmap bitmap BitMap  更多
   个人分类：BabyOS
   版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/guzhou_diaoke/article/details/8473446
   注：以下代码为原创，若发现 bug，万望指出，若有问题，欢迎交流，转载请指明出处。若能有助于一二访客，幸甚。



   上次完成了基本图形界面的绘制，但没有关闭、最小化、最大化按钮，终究是不爽，而试着用直线、矩形绘制了一个，感觉不好看，于是就到了让 baby 能够绘制 bitmap 图像的时候了～

   结果如下，就是把我现在用的 Ubuntu Gnome 的一种主题模式的三个按钮截了个图，加载到内存，然后绘制在窗口上了。





   实现方法也不太难，就是写的时候只考虑了前两个结构体的内存对齐，没有考虑 bitmap_t 的内存对齐，于是不能绘制，bochs 调试一番未果，于是实现了一个在屏幕上绘制 16 进制数的简单代码，用于调试，打印变量信息若干，才发现问题。

   注：只考虑了 24 位位图、倒立的。


   /*************************************************************************
	 > File:		bitmap.c
	 > Describe:	识别和显示 bmp 图像
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 05 日 星期六 22 时 57 分 16 秒
   ************************************************************************/
 
   #include <bitmap.h>
   #include <graphics.h>
   #include <font.h>
   #include <math.h>
 
   BOOL draw_bitmap24(bitmap_t* p_bmp, s32 dst_x, s32 dst_y, u32 width, u32 height, s32 src_x, s32 src_y)
   {
	 s32 x, y, bmp_cx, bmp_cy, bmp_x, bmp_y, line_byte_count;
	 color24 old_color;
 
	 u8* p_bmp_data_base = (u8*)p_bmp + sizeof(p_bmp->file_head) + sizeof(p_bmp->info_head);
	 u8* p_data;
 
	 /* 不是 24 位位图 */
	 if (p_bmp->info_head.bi_bit_count != 24)
	 return FALSE;
 
	 /* 图像的宽、髙 */
	 bmp_cx = abs(p_bmp->info_head.bi_width);
	 bmp_cy = abs(p_bmp->info_head.bi_height);
 
	 if (src_x > bmp_cx || src_y > bmp_cy || (s32)(src_x+width) < 0 || (s32)(src_y+height) < 0)
	 return FALSE;
 
	 line_byte_count = (((bmp_cx*p_bmp->info_head.bi_bit_count + 31) >> 5) << 2);
	 old_color = get_current_color();
 
	 for (y = dst_y; y < (s32)(dst_y + height); y++)
	 {
	 bmp_y = src_y + height - 1 + dst_y - y;
		
	 if (bmp_y < 0) continue;
	 if (bmp_y == bmp_cy) break;
 
	 for (x = dst_x; x < (s32)(dst_x + width); x++)
	 {
	 bmp_x = src_x + x - dst_x;
	 if (bmp_x < 0) continue;
	 if (bmp_x == bmp_cx) break;
			
	 p_data = p_bmp_data_base + line_byte_count*bmp_y + 3*bmp_x;
 
	 set_color(RGB(p_data[2], p_data[1], p_data[0]));
	 set_pixel(x, y);
	 }
	 }
 
	 set_color(old_color);
 
	 return TRUE;
   }
 
   BOOL draw_bitmap(bitmap_t* p_bmp, s32 dst_x, s32 dst_y, u32 width, u32 height, s32 src_x, s32 src_y)
   {
	 return draw_bitmap24(p_bmp, dst_x, dst_y, width, height, src_x, src_y);
   }
** babyos（十） —— 通过 IO 端口读取硬盘扇区
   2013 年 01 月 07 日 23:05:58 孤舟钓客 阅读数：7346
   版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/guzhou_diaoke/article/details/8479033
   注：以下代码为原创，若发现 bug，万望指出，若有问题，欢迎交流，转载请指明出处。若能有助于一二访客，幸甚。

   欢迎关注 babyos 的成长历程和宝贝计划：https://github.com/guzhoudiaoke/babyos/wiki



   上次实现了显示 bitmap 的功能，却只显示了几个按钮，很不爽，但引导软盘只有 1.44M，实在装不下太大的图片。而要想做个桌面背景，需要读取 800x600 的图片。所以是时候让 baby 学会读硬盘扇区了。当然只是通过 IO 端口读取硬盘扇区，而不会设计文件的概念。



   1.硬盘长什么样
   硬盘拆开盖，如下图所示：


   2.物理结构
   一个简单的物理模型：


   3.磁头、磁道、柱面、扇区
   1）磁头：如上图所示，它是硬盘中最贵的部分了，读写操作就靠它，它通过感应旋转的盘片上磁场的变化来读取数据，通过改变盘片上的磁场来写入数据。磁头从 0 开始编号。
   一个硬盘有很多个盘片（一个盘片有两个盘面），它们垂直排列成圆柱，所以也有很多个磁头来读写不同的盘面。
   2）磁道：硬盘转动时磁头是不动的，动的是盘片。则磁头会在盘片上划出一个个圆形轨迹，这些轨迹就是磁道。磁道由外向内编号，编号从 0 开始。
   3）柱面：硬盘有很多个盘片，从上到下排成柱状，不同盘片，相同磁道，组成的就叫柱面（cylinder）。

   柱面从 0 开始编号，柱面号即磁道号。
   4）扇区：磁盘上每个磁道被等分成若干个弧段，这些弧段就是扇区。
   一个扇区通常 512byte，扇区从 1 开始编号。



   4.寻址
   如何找到我们想要的数据呢？即如何在硬盘上找到任意一个物理地址。
   1）CHS 模式（Cylinder/Head/Sector）
   就是给定柱面号、磁头号、扇区号。柱面号给定在哪一个圆环上，磁头号指定了在哪一层，扇区号指定了圆上的位置，于是就定位到了一个准确的扇区了。
   2）LBA（Logical Block Addressing，逻辑块寻址）
   就是只给一个逻辑号码，根据硬盘的柱面数、每个柱面的磁头数、每个磁道的扇区数来计算柱面号、磁头号、扇区号。
   编号方法：
   按照柱面、磁头、扇区顺序来编，即编完 0 号柱面 0 号磁头所在磁道的若干扇区后，再编 0 号柱面 1 号磁头所在磁道的所以扇区，编完 0 号柱面的所有磁头后再编 1 号柱面。

   3）相互转换
   LBA = （柱面号 * 一个柱面的磁头数 + 磁头号） * 一个磁道上的扇区数 + （扇区号-1）

   柱面号 = LBA / （一个柱面的磁头数 * 每个磁道扇区数）
   令   x = LBA % （一个柱面的磁头数 * 每个磁道扇区数）
   磁头号 = x / 每个磁道上的扇区数
   扇区号 = x % 每个磁道上的扇区数 + 1

   5.硬盘操作
   CPU 与外设、存储器的连接和数据交换都需要通过接口设备来实现。
   每个连接到 I/O 总线上的设备都由自己的 I/O 地址集，即所谓的 I/O 端口（I/O port）。
   每个设备的 I/O 端口都被组织成一组专用的寄存器，CPU 可给控制寄存器发命令对设备进行控制、从状态寄存器读取设备状态、可以向输出寄存器写入数据来把数据输出到设备、可通过读取输入寄存器的内容来从设备取得数据。
   总之就是通过读写端口来控制设备。

   一个普通的 PC 主板上通常有两个 IDE 口，分别对应两个 IDE 通道:primary 和 secondary 有时也成 IDE0 和 IDE1。
   每个 IDE 通道又能连接两个设备，称为主设备（Master）和从设备（Slave），对不同的 IDE 通道的访问是通过 I/O 端口来区分的。
   IDE（integrated drive electronics）即电子集成驱动器，主要接硬盘和光驱。
   接到主设备上的硬盘称为 0 号硬盘。

   与 0 号硬盘有关的 I/O 端口：
   1F0H　　 0 号硬盘数据寄存器
   1F1H　　 0 号硬盘错误寄存器（读时）、0 号硬盘 Features 寄存器（写时）
   1F2H　　 0 号硬盘数据扇区计数

   1F3H　　 0 号硬盘扇区数
   1F4H　　 0 号硬盘柱面（低字节）
   1F5H　　 0 号硬盘柱面（高字节）
   1F6H　　 0 号硬盘驱动器/磁头寄存器

   1F7H　　 0 号硬盘状态寄存器（读时）、0 号硬盘命令寄存器（写时）

   注：下图来自于渊《Orange‘s 一个操作系统的实现》，他使用的是 LBA 方式，babyos 暂时使用 CHS 方式，故 bit0～bit3 表示磁头号，bit4 为驱动器号为 0，bit6 为 0，表示使用 CHS 方式。
   /*	
   |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |  1  |  L  |  1  | DRV | HS3 | HS2 | HS1 | HS0 |
   +-----+-----+-----+-----+-----+-----+-----+-----+
	 |           |   \_____________________/
	 |           |              |
	 |           |              `------------ If L=0, Head Select.
   |           |                                   These four bits select the head number.
   |           |                                   HS0 is the least significant.
   |           |                            If L=1, HS0 through HS3 contain bit 24-27 of the LBA.
   |           `--------------------------- Drive. When DRV=0, drive 0 (master) is selected. 
   |                                               When DRV=1, drive 1 (slave) is selected.
   `--------------------------------------- LBA mode. This bit selects the mode of operation.
   When L=0, addressing is by 'CHS' mode.
   When L=1, addressing is by 'LBA' mode.
   */

   即：
   可以从端口 0x1F0 读取数据；
   若发生错误可以从 0x1F1 读取错误；
   若要从硬盘读数据可以从 0x1F2 指定读取的扇区数，0x1F3、0x1F4、0x1F5、0x1F6 指定 CHS（也可以是 LBA，此处暂时不研究）
   可以从 0x1F7 读取硬盘状态或向硬盘发送命令。

   接口控制方式：
   1）程序查询方式：CPU 通过 I/O 指令询问指定外设当前状态，如果外设准备就绪，进行操作，否则 CPU 等待，循环查询。
   2）中断处理方式：外设数据交换准备就绪，向 CPU 提出服务请求。
   3）DMA（直接存储器存取）：采用一个专门的控制器来控制内存与外设直接的数据交流，无须 CPU 介入。

   下面将要使用的方式是程序查询方式，因为 babyos 还没有实现中断。

   6.读取若干个扇区
   现在只学习最简单的硬盘操作——从硬盘读取若干个扇区，其他功能以后学习文件系统时再研究。
   步骤：
   1）通过状态寄存器查询硬盘状态，看是否空闲，若忙，则等待
   2）把读取扇区的个数、CHS 写入相应端口
   3）通过命令寄存器向硬盘发送读命令
   4）从数据寄存器读取数据

   注：
   babyos 目前只想从硬盘读若干个扇区，不想实现高级的硬盘操作功能和文件系统；
   只考虑主硬盘；
   暂时使用 CHS 方式，但会实现一个 LBA 到 CHS 的转换方法；
   /*************************************************************************
	 > File:		harddisk.c
	 > Describe: 实现基本硬盘操作功能
	 > Author:	孤舟钓客
	 > Mail:		guzhoudiaoke@126.com 
	 > Time:		2013 年 01 月 06 日 星期日 17 时 40 分 32 秒
   ************************************************************************/
 
   #include <harddisk.h>
   #include <io.h>
   #include <font.h>
   #include <graphics.h>
 
 
   BOOL harddisk_read(u32 lba, u32 sects_to_read, u8* buffer)
   {
	 u32 cylinder_no, head_no, sect_no, temp;
	 u32 num_of_dwords;
 
	 cylinder_no = lba / (HD0_HEAD_PER_CYLINDER * HD0_SECT_PER_TRACK);
	 temp		= lba % (HD0_HEAD_PER_CYLINDER * HD0_SECT_PER_TRACK);
	 head_no		= temp / HD0_SECT_PER_TRACK;
	 sect_no		= temp % HD0_SECT_PER_TRACK + 1;
 
	 /* 检查硬盘是否忙，忙则等待 */
	 while ((inb(HD_PORT_STATUS) & 0x80) != 0)
	 ;
	 /* 设置读取的扇区数和 CHS，
	 HD_PORT_DRIVE_HEAD 端口 bit7、bit5 需要为 1，bit6 为 0 时 bit0～bit3 表示磁头号，
	 bit4 为驱动器号，0 表示 HD0，故下面 head_no 要或操作 10100000 即 0xa0 */
	 outb(sects_to_read, HD_PORT_SECT_COUNT);
	 outb(sect_no, HD_PORT_SECT_NO);
	 outb(cylinder_no, HD_PORT_CYLINDER_LOW);
 
	 cylinder_no >>= 8;
	 outb((cylinder_no), HD_PORT_CYLINDER_HIGH);
 
	 head_no |= 0xa0;
	 outb((head_no), HD_PORT_DRIVE_HEAD);
 
	 /* 发送读命令 */
	 outb(HD_CMD_READ, HD_PORT_COMMAND);
 
	 num_of_dwords = (sects_to_read << 7);
 
	 /* 从 HD_PORT_DATA 读取数据，每个扇区 512 字节，即 sects_to_read << 7 个双字 */
	 insl(HD_PORT_DATA, buffer, num_of_dwords);
 
	 return TRUE;
   }



   
