<<titlepage.xhtml>>

#+BEGIN_HTML
  <svg xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewbox="0 0 889 1186" preserveaspectratio="none">
#+END_HTML

#+BEGIN_HTML
  </svg>
#+END_HTML

<<index_u11.html>>

[[file:mastheadImage.jpg]]

[Âõõ, 01 10Êúà 2020]

- [[file:feed_0/index_u13.html][thinkphp3]]

<<index_u13.html>>

** thinkphp3
   :PROPERTIES:
   :CLASS: calibre_feed_title
   :END:

- [[file:article_0/index_u30.html][Emacs Tutorial]]
- [[file:article_1/index_u8.html][Emacs Init]]
- [[file:article_2/index_u2.html][Emacs Keys]]
- [[file:article_3/index_u40.html][ELisp]]
- [[file:article_4/index_u29.html][ELisp Examples]]
- [[file:article_7/index_u9.html][Title Case]]
- [[file:article_10/index_u26.html][Escape Quotes]]
- [[file:article_11/index_u42.html][Remove √Ñ√ßƒç√©√±≈• Marks]]
- [[file:article_12/index_u7.html][Straight to Curly Quotes]]
- [[file:article_13/index_u33.html][Convert English/Chinese
  Punctuations]]
- [[file:article_14/index_u22.html][Convert RGB/HSL/HSV]]
- [[file:article_15/index_u16.html][Decimal ‚Üí Hexadecimal]]
- [[file:article_16/index_u31.html][Replace Greek Letter Names to
  Unicode]]
- [[file:article_17/index_u24.html][Twitterfy Text]]
- [[file:article_18/index_u14.html][xah-fix-datetime]]
- [[file:article_19/index_u5.html][Count Words]]
- [[file:article_20/index_u38.html][Python 2to3 Wrapper]]
- [[file:article_21/index_u36.html][Move Code to Files]]
- [[file:article_22/index_u43.html][Update Web Feed]]
- [[file:article_23/index_u18.html][Updating Page Tags]]
- [[file:article_24/index_u17.html][Insert Random ID]]
- [[file:article_25/index_u37.html][Insert Random UUID]]
- [[file:article_26/index_u19.html][Write grep in Elisp]]
- [[file:article_27/index_u35.html][Find String Inside HTML Tag]]
- [[file:article_28/index_u28.html][Check Brackets Balance]]
- [[file:article_29/index.html][Validate Matching Brackets]]
- [[file:article_30/index_u23.html][Generate Links Report]]
- [[file:article_31/index_u6.html][Generate Sitemap]]
- [[file:article_32/index_u3.html][Archive Website For Reader Download]]
- [[file:article_33/index_u41.html][Process File line-by-line]]
- [[file:article_34/index_u20.html][Text-Soup Automation]]
- [[file:article_35/index_u15.html][Split HTML Annotation]]
- [[file:article_36/index_u39.html][Fixing Dead Links]]
- [[file:article_37/index_u10.html][Elisp vs Perl: Validate Local File
  Links]]
- [[file:article_38/index_u21.html][Transform Page Tag]]
- [[file:article_39/index_u27.html][Transform HTML FAQ Tags]]
- [[file:article_40/index_u4.html][Transform HTML Tags]]
- [[file:article_41/index_u25.html][‚Äúfigure‚Äù to ‚Äúfigcaption‚Äù]]
- [[file:article_42/index_u32.html][‚Äúspan.w‚Äù to ‚Äúb‚Äù]]
- [[file:article_43/index_u1.html][Toggle Something]]
- [[file:article_44/index_u12.html][Uncolor Region/Buffer]]
- [[file:article_45/index_u34.html][Mouse Click to Highlight Matching
  Words]]

<<index_u30.html>>

| [[../article_1/index_u8.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_0][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

--------------

* Practical Emacs Tutorial
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2005-12-30. Last updated: 2020.

the church of emacs filling,\\
of chars lispy and binding,\\
buffers insert yank,\\
meta sexp add-hook,\\
Eight M-bites And C. Swapping.\\

[[file:emacs_logo.html][[[file:feed_0/article_0/emacs_logo/emacs_logo.svg]]]]

This tutorial is designed for writers, scientists, engineers, to get
started on emacs quickly. Each page teaches you something practical you
can use right away. No emacs jargons. No need programing experience.

Start at\\
[[file:which_emacs.html][Download Emacs for Windows, Mac, Linux]]

Those marked with a rocket ship üöÄ means it's a enhanced, efficient
command. They are part of [[../misc/ergoemacs_vi_mode.html][Emacs: Xah
Fly Keys]]

*** About This Tutorial
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[file:feed_0/article_0/i/learning_gnu_emacs.png]]
[[file:feed_0/article_0/images/img1.jpg]]

emacs books from 1990s.

If you were to spend 3 months reading 3 emacs books, it is more
efficient to just read Xah Emacs Tutorial for just 1 month. Xah tutorial
focus on actually using emacs in practice, and on efficiency of using
emacs, as well as efficiency of learning.

- This tutorial skips the emacs parts that are rarely used. Every single
  one thousand emacs C-x commands are looked, the practical ones are
  presented to you.
- The writing style is concrete, and example based. No story telling, no
  joke, just what you need to know to use emacs in the most efficient
  way.
- This tutorial does not force emacs jargons and emacs hacker methods.
  If you are new to emacs, you will understand it. If you are old time
  hacker, you will improve your efficiency of using emacs.
- This tutorial covers emacs lisp, more extensive than any existing
  emacs lisp book (except the elisp manual) or elisp tutorial online. A
  little elisp makes you a far better emacs user and understanding
  emacs. [see [[file:elisp.html][Practical Emacs Lisp]]]
- There are more examples and elisp code in Xah Emacs Tutorial than all
  existing emacs books or web sites combined. You do not need to read it
  all, but any time spent reading this tutorial, you'll learn more
  useful things than same amount of time spent elsewhere.

The author lives in emacs since 1999. And has been obsessively writing
emacs tutorial since 2006.

** Buy Xah Emacs Tutorial
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Buy my tutorial to support the site.

[[file:buy_xah_emacs_tutorial.html][[[file:feed_0/article_0/images/img2.jpg]]\\
Buy Xah Emacs Tutorial]]

** What Do People Say?
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:user_comments.html][Testimonial on Xah Emacs Tutorial]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs.html]]

\\
\\
| [[../index_u13.html#article_0][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u8.html>>

| [[../article_2/index_u2.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_1][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_0/index_u30.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs Init Setup
  :PROPERTIES:
  :CLASS: calibre9
  :END:

This sections shows you how to customize emacs by editing the init file.

Start at [[file:emacs_make_modern.html][Emacs: Init File Tutorial]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_init_index.html]]

\\
\\
| [[../index_u13.html#article_1][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u2.html>>

| [[../article_3/index_u40.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_2][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_1/index_u8.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs Keys
  :PROPERTIES:
  :CLASS: calibre9
  :END:

The essence of using emacs is commands and keys.

This section shows you how to customize emacs keys. Start at\\
[[file:keyboard_shortcuts.html][Emacs: How to Define Keys]]

or watch a video:

dvorak colemak minimak layouts, ergodox, keyboard firmware, keybinding,
ergodox, programable keypads 2019-09-20

[[file:feed_0/article_2/images/img1_u1.jpg]]

‚ÄúEmacs user at work‚Äù. (by
[[http://earlcolour.deviantart.com/][earlcolour.deviantart.com]])

\\

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_keys_index.html]]

\\
\\
| [[../index_u13.html#article_2][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u40.html>>

| [[../article_4/index_u29.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_3][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_2/index_u2.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Practical Emacs Lisp
  :PROPERTIES:
  :CLASS: calibre9
  :END:

[[file:lisp_logo.html][[[file:feed_0/article_3/images/img1.svg]]]]

[[file:buy_xah_emacs_tutorial.html][[[file:feed_0/article_3/i/spell_striker_79774-s250x250.jpg]]\\
Buy Xah Emacs Tutorial]]

Emacs is possible because of the embedded programing language emacs
lisp. Learning a bit emacs lisp will increase your understanding of
emacs by a lot.

This is a example based tutorial on emacs lisp, with focus on how-to.

Start at\\
[[file:elisp_basics.html][Emacs Lisp Basics]]

or watch a video:

Xah Lee Live Stream. emacs lisp for beginner.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp.html]]

\\
\\
| [[../index_u13.html#article_3][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u29.html>>

| [[../article_5/index.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_4][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_3/index_u40.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs Lisp Examples
  :PROPERTIES:
  :CLASS: calibre9
  :END:

This section is collection of simple emacs lisp examples. They are great
for studying elisp but also as practical useful commands.

Start at:\\
[[file:elisp_title_case_text.html][Emacs: Change to Title Case]]

Note, you can also use other programing language and call them in emacs.
see [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands Using
Python, Ruby, ...]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_command_examples_index.html]]

\\
\\
| [[../index_u13.html#article_4][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u9.html>>

| [[../article_8/index.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_7][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_6/index.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Change to Title Case
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-11-06. Last updated: 2017-01-11.

Here's emacs command to change letter case by title convention.

For example, ‚ÄúA Tale of Two Cities‚Äù, not ‚ÄúA Tale Of Two Cities‚Äù.

#+BEGIN_SRC emacs-lisp
    (defun xah-title-case-region-or-line (@begin @end)
      "Title case text between nearest brackets, or current line, or text selection.
    Capitalize first letter of each word, except words like {to, of, the, a, in, or, and, ‚Ä¶}. If a word already contains cap letters such as HTTP, URL, they are left as is.

    When called in a elisp program, *begin *end are region boundaries.
    URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (let (
               $p1
               $p2
               ($skipChars "^\"<>(){}[]‚Äú‚Äù‚Äò‚Äô‚Äπ‚Ä∫¬´¬ª„Äå„Äç„Äé„Äè„Äê„Äë„Äñ„Äó„Ää„Äã„Äà„Äâ„Äî„Äï"))
           (progn
             (skip-chars-backward $skipChars (line-beginning-position))
             (setq $p1 (point))
             (skip-chars-forward $skipChars (line-end-position))
             (setq $p2 (point)))
           (list $p1 $p2))))
      (let* (
             ($strPairs [
                         [" A " " a "]
                         [" And " " and "]
                         [" At " " at "]
                         [" As " " as "]
                         [" By " " by "]
                         [" Be " " be "]
                         [" Into " " into "]
                         [" In " " in "]
                         [" Is " " is "]
                         [" It " " it "]
                         [" For " " for "]
                         [" Of " " of "]
                         [" Or " " or "]
                         [" On " " on "]
                         [" Via " " via "]
                         [" The " " the "]
                         [" That " " that "]
                         [" To " " to "]
                         [" Vs " " vs "]
                         [" With " " with "]
                         [" From " " from "]
                         ["'S " "'s "]
                         ["'T " "'t "]
                         ]))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (upcase-initials-region (point-min) (point-max))
            (let ((case-fold-search nil))
              (mapc
               (lambda ($x)
                 (goto-char (point-min))
                 (while
                     (search-forward (aref $x 0) nil t)
                   (replace-match (aref $x 1) "FIXEDCASE" "LITERAL")))
               $strPairs))))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_title_case_text.html]]

\\
\\
| [[../index_u13.html#article_7][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u26.html>>

| [[../article_11/index_u42.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_10][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_9/index.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Escape Quotes Command
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-08-16. Last updated: 2017-01-11.

This page shows a emacs command to escape/unescape quotes.

For example,

#+BEGIN_SRC emacs-lisp
    "xyz"
#+END_SRC

becomes

#+BEGIN_SRC emacs-lisp
    \"xyz\"
#+END_SRC

This is very useful when coding lisp to process other languages.

For example, when you have this =x = "‚Ä¶"=, and you want
=(search-forward "x = \"‚Ä¶\"") =

Here's the code.

#+BEGIN_SRC emacs-lisp
    (defun xah-escape-quotes (@begin @end)
      "Replace „Äå\"„Äç by „Äå\\\"„Äç in current line or text selection.
    See also: `xah-unescape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (goto-char (point-min))
            (while (search-forward "\"" nil t)
              (replace-match "\\\"" "FIXEDCASE" "LITERAL")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-unescape-quotes (@begin @end)
      "Replace  „Äå\\\"„Äç by „Äå\"„Äç in current line or text selection.
    See also: `xah-escape-quotes'

    URL `http://ergoemacs.org/emacs/elisp_escape_quotes.html'
    Version 2017-01-11"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (save-excursion
        (save-restriction
          (narrow-to-region @begin @end)
          (goto-char (point-min))
          (while (search-forward "\\\"" nil t)
            (replace-match "\"" "FIXEDCASE" "LITERAL")))))
#+END_SRC

You can assign keys to them. [see [[file:keyboard_shortcuts.html][Emacs:
How to Define Keys]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_escape_quotes.html]]

\\
\\
| [[../index_u13.html#article_10][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u42.html>>

| [[../article_12/index_u7.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_11][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_10/index_u26.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Remove Accent Marks
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-03-07. Last updated: 2018-11-12.

Here's a emacs command that removes accent marks, or, convert some
Unicode characters into ASCII. (aka Zap Gremlins)

For example:

- ‚Äúcaf√©‚Äù ‚áí ‚Äúcafe‚Äù
- ‚Äúna√Øve‚Äù ‚áí ‚Äúnaive‚Äù

#+BEGIN_SRC emacs-lisp
    (defun xah-asciify-text (&optional @begin @end)
      "Remove accents in some letters and some
    Change European language characters into equivalent ASCII ones, e.g. ‚Äúcaf√©‚Äù ‚áí ‚Äúcafe‚Äù.
    When called interactively, work on current line or text selection.

    URL `http://ergoemacs.org/emacs/emacs_zap_gremlins.html'
    Version 2018-11-12"
      (interactive)
      (let (($charMap
             [
              ["√ü" "ss"]
              ["√°\\|√†\\|√¢\\|√§\\|ƒÅ\\|«é\\|√£\\|√•\\|ƒÖ\\|ƒÉ\\|·∫°\\|·∫£\\|·∫£\\|·∫•\\|·∫ß\\|·∫©\\|·∫´\\|·∫≠\\|·∫Ø\\|·∫±\\|·∫≥\\|·∫∑" "a"]
              ["√¶" "ae"]
              ["√ß\\|ƒç\\|ƒá" "c"]
              ["√©\\|√®\\|√™\\|√´\\|ƒì\\|ƒõ\\|ƒô\\|·∫π\\|·∫ª\\|·∫Ω\\|·∫ø\\|·ªÅ\\|·ªÉ\\|·ªÖ\\|·ªá" "e"]
              ["√≠\\|√¨\\|√Æ\\|√Ø\\|ƒ´\\|«ê\\|·ªâ\\|·ªã" "i"]
              ["√±\\|≈à\\|≈Ñ" "n"]
              ["√≥\\|√≤\\|√¥\\|√∂\\|√µ\\|«í\\|√∏\\|≈ç\\|·ªì\\|∆°\\|·ªç\\|·ªè\\|·ªë\\|·ªï\\|·ªó\\|·ªô\\|·ªõ\\|·ªù\\|·ªü\\|·ª£" "o"]
              ["√∫\\|√π\\|√ª\\|√º\\|≈´\\|≈©\\|∆∞\\|·ª•\\|·ªß\\|·ª©\\|·ª´\\|·ª≠\\|·ªØ\\|·ª±"     "u"]
              ["√Ω\\|√ø\\|·ª≥\\|·ª∑\\|·ªπ"     "y"]
              ["√æ" "th"]
              ["ƒè\\|√∞\\|ƒë" "d"]
              ["ƒ©" "i"]
              ["ƒæ\\|ƒ∫\\|≈Ç" "l"]
              ["≈ô\\|≈ï" "r"]
              ["≈°\\|≈õ" "s"]
              ["≈•" "t"]
              ["≈æ\\|≈∫\\|≈º" "z"]
              ["‚Äâ" " "]       ; thin space etc
              ["‚Äì" "-"]       ; dash
              ["‚Äî\\|‰∏Ä" "--"] ; em dash etc
              ])
            $begin $end
            )
        (if (null @begin)
            (if (use-region-p)
                (setq $begin (region-beginning) $end (region-end))
              (setq $begin (line-beginning-position) $end (line-end-position)))
          (setq $begin @begin $end @end))
        (let ((case-fold-search t))
          (save-restriction
            (narrow-to-region $begin $end)
            (mapc
             (lambda ($pair)
               (goto-char (point-min))
               (while (search-forward-regexp (elt $pair 0) (point-max) t)
                 (replace-match (elt $pair 1))))
             $charMap)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-asciify-string (@string)
      "Returns a new string. European language chars are changed ot ASCII ones e.g. ‚Äúcaf√©‚Äù ‚áí ‚Äúcafe‚Äù.
    See `xah-asciify-text'
    Version 2015-06-08"
      (with-temp-buffer
          (insert @string)
          (xah-asciify-text (point-min) (point-max))
          (buffer-string)))
#+END_SRC

[see [[http://wordyenglish.com/musing/diacritics.html][Accent Marks:
Trema, Umlaut, Macron, Circumflex]]]

(2015-06-08 thanks to robert_nagy for adding chars)

** Accumulator vs Parallel Programing
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This problem makes a good parallel programing exercise. See:
[[http://xahlee.info/comp/parallel_programing_exercise_asciify-string.html][Parallel
Programing Exercise: asciify-string]].

** Alternative Solution with ‚Äúiconv‚Äù or perl
   :PROPERTIES:
   :CLASS: calibre17
   :END:

2011-03-08

Yuri Khan and Teemu Likonen suggested using the ‚Äúiconv‚Äù shell command.
See =man iconv=. Here's Teemu's code.

#+BEGIN_SRC emacs-lisp
    (defun asciify-string (string)
    "Convert STRING to ASCII string.
    For example:
    ‚Äúpass√©‚Äù becomes ‚Äúpasse‚Äù"
    ;; Code originally by Teemu Likonen
      (with-temp-buffer
        (insert string)
        (call-process-region (point-min) (point-max) "iconv" t t nil "--to-code=ASCII//TRANSLIT")
        (buffer-substring-no-properties (point-min) (point-max))))
#+END_SRC

Julian Bradfield suggested Perl. Here's his one-liner, it removes chars
with accent marks.

#+BEGIN_SRC emacs-lisp
    perl -e 'use encoding utf8; use Unicode::Normalize; while ( <> ) { $_ = NFKD($_); s/\pM//g; print; }'
#+END_SRC

[[http://groups.google.com/group/comp.emacs/msg/8d58b6e9b2bd07fd]]

Though, it would be nice to have a pure elisp solution, because ‚Äúiconv‚Äù
is not in Windows or Mac OS X as of 2011-03-08.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_zap_gremlins.html]]

\\
\\
| [[../index_u13.html#article_11][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u7.html>>

| [[../article_13/index_u33.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_12][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_11/index_u42.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Convert Straight/Curly Quotes
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2015-04-29. Last updated: 2018-03-02.

Here's a command to convert straight quote to curly quotes.

#+BEGIN_SRC emacs-lisp
    (defun xah-replace-straight-quotes (@begin @end)
      "Replace straight double quotes to curly ones, and others.
    Works on current text block or selection.

    Examples of changes:
     „Äå\"‚Ä¶\"„Äç ‚Üí „Äå‚Äú‚Ä¶‚Äù„Äç
     „Äå...„Äç ‚Üí „Äå‚Ä¶„Äç
     „ÄåI‚Äôm„Äç ‚Üí „ÄåI'm„Äç
     „Äå--„Äç ‚Üí „Äå‚Äî„Äç
     „Äå~=„Äç ‚Üí „Äå‚âà„Äç

    When called in lisp code, @begin and @end are region begin/end positions.

    WARNING: this command does not guarantee 100% correct conversion of quotes, because it impossible. You should double check highlighted places after.

    URL `http://ergoemacs.org/emacs/elisp_straight_curly_quotes.html'
    Version 2018-03-02"
      ;; some examples for debug
      ;; do "‚Äòem all -- done..."
      ;; I‚Äôam not
      ;; said "can‚Äôt have it, can‚Äôt, just can‚Äôt"
      ;; ‚ÄòI‚Äôve can‚Äôt‚Äô
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (let ($p1 $p2)
           (save-excursion
             (if (re-search-backward "\n[ \t]*\n" nil "move")
                 (progn (re-search-forward "\n[ \t]*\n")
                        (setq $p1 (point)))
               (setq $p1 (point)))
             (if (re-search-forward "\n[ \t]*\n" nil "move")
                 (progn (re-search-backward "\n[ \t]*\n")
                        (setq $p2 (point)))
               (setq $p2 (point))))
           (list $p1 $p2))))

      (let ( (case-fold-search nil))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end )
            ;; Note: order is important since this is huristic.
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ;; dash and ellipsis etc
              ["--" " ‚Äî "]
              ["‚Äî" " ‚Äî "]
              ["..." "‚Ä¶"]
              [" & " " ÔºÜ "]
              [" :)" " ‚ò∫"]
              [" :(" " ‚òπ"]
              [" ;)" " üòâ"]
              ["~=" "‚âà"]
              [" --> " " ‚ü∂ "]
              [" , " ", "]
              ;; fix GNU style ASCII quotes
              ["``" "‚Äú"]
              ["''" "‚Äù"]
              ;; double straight quote ‚Üí double curly quotes
              ["\n\"" "\n‚Äú"]
              [">\"" ">‚Äú"]
              ["(\"" "(‚Äú"]
              [" \"" " ‚Äú"]
              ["\" " "‚Äù "]

              ["\", " "‚Äù, "]
              ["\",\n" "‚Äù,\n"]

              ["\". " "‚Äù. "]
              ["\".\n" "‚Äù.\n"]
              ["\"?" "‚Äù?"]
              ["\";" "‚Äù;"]
              ["\":" "‚Äù:"]
              ["\")" "‚Äù)"]
              ["\"]" "‚Äù]"]

              ;; ["\"[" "\‚Äù["]

              [".\"" ".‚Äù"]
              [",\"" ",‚Äù"]
              ["!\"" "!‚Äù"]
              ["?\"" "?‚Äù"]
              ["\"<" "‚Äù<"]
              ["\"\n" "‚Äù\n"]
              ] "REPORT" "HILIGHT")

            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ["  ‚Äî  " " ‚Äî "] ; rid of extra space in em-dash
              ] "REPORT" "HILIGHT")

            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              [" ‚Äî-> " " ‚ü∂ "]
              [" <= " " ‚â§ "]
              [" >= " " ‚â• "]
              ] "REPORT" "HILIGHT")

            ;; fix straight double quotes by regex
            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["\\`\"" "‚Äú"]
              ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

            ;; fix single quotes to curly
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              [">\'" ">‚Äò"]
              [" \'" " ‚Äò"]
              ["\' " "‚Äô "]
              ["\'," "‚Äô,"]
              [".\'" ".‚Äô"]
              ["!\'" "!‚Äô"]
              ["?\'" "?‚Äô"]
              ["(\'" "(‚Äò"]
              ["\')" "‚Äô)"]
              ["\']" "‚Äô]"]
              ] "REPORT" "HILIGHT")

            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["\\bcan‚Äôt\\b" "can't"]
              ["\\bdon‚Äôt\\b" "don't"]
              ["\\bdoesn‚Äôt\\b" "doesn't"]
              ["\\bwon‚Äôt\\b" "won't"]
              ["\\bisn‚Äôt\\b" "isn't"]
              ["\\baren‚Äôt\\b" "aren't"]
              ["\\bain‚Äôt\\b" "ain't"]
              ["\\bdidn‚Äôt\\b" "didn't"]
              ["\\baren‚Äôt\\b" "aren't"]
              ["\\bwasn‚Äôt\\b" "wasn't"]
              ["\\bweren‚Äôt\\b" "weren't"]
              ["\\bcouldn‚Äôt\\b" "couldn't"]
              ["\\bshouldn‚Äôt\\b" "shouldn't"]

              ["\\b‚Äôve\\b" "'ve"]
              ["\\b‚Äôre\\b" "'re"]
              ["\\b‚Äòem\\b" "'em"]
              ["\\b‚Äôll\\b" "'ll"]
              ["\\b‚Äôm\\b" "'m"]
              ["\\b‚Äôd\\b" "'d"]
              ["\\b‚Äôs\\b" "'s"]
              ["s‚Äô " "s' "]
              ["s‚Äô\n" "s'\n"]

              ["\"$" "‚Äù"]
              ] "FIXEDCASE" "LITERAL-P" "HILIGHT")

            ;; fix back escaped quotes in code
            (xah-replace-pairs-region
             (point-min) (point-max)
             [
              ["\\‚Äù" "\\\""]
              ["\\‚Äù" "\\\""]
              ] "REPORT" "HILIGHT")

            ;; fix back. quotes in HTML code
            (xah-replace-regexp-pairs-region
             (point-min) (point-max)
             [
              ["‚Äù \\([-a-z]+\\)="       "\" \\1="] ; any „Äå‚Äù some-thing=„Äç
              ["=‚Äù" "=\""]
              ["/‚Äù " "/\" "]
              ["\\([0-9]+\\)‚Äù "     "\\1\" "]
              ] "FIXEDCASE" nil "HILIGHT"
             )

            ))))
#+END_SRC

You need the elisp library
[[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_straight_curly_quotes.html]]

\\
\\
| [[../index_u13.html#article_12][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u33.html>>

| [[../article_14/index_u22.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_13][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_12/index_u7.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Convert Full-Width/Half-Width Punctuations
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-10. Last updated: 2018-08-02.

This page shows commands to convert to/from Full-Width/Half-Width
characters. (ÂÖ®Ëßí ÂçäËßí ËΩ¨Êç¢)

If you type Chinese or Japanese mixed with English, then often you'll
have mixed Asian/Western punctuations, and is hard to fix manually.

- . ‚Üî „ÄÇ (U+3002: IDEOGRAPHIC FULL STOP)
- , ‚Üî Ôºå (U+FF0C: FULLWIDTH COMMA)
- ? ‚Üî Ôºü (U+FF1F: FULLWIDTH QUESTION MARK)
- ; ‚Üî Ôºõ (U+FF1B: FULLWIDTH SEMICOLON)

[see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
Full-Width Characters]]]

** Convert English Chinese Punctuation
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-convert-english-chinese-punctuation (@begin @end &optional @to-direction)
      "Convert punctuation from/to English/Chinese characters.

    When called interactively, do current line or selection. The conversion direction is automatically determined.

    If `universal-argument' is called, ask user for change direction.

    When called in lisp code, *begin *end are region begin/end positions. *to-direction must be any of the following values: „Äå\"chinese\"„Äç, „Äå\"english\"„Äç, „Äå\"auto\"„Äç.

    See also: `xah-remove-punctuation-trailing-redundant-space'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    Version 2015-10-05"
      (interactive
       (let ($p1 $p2)
         (if (use-region-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (progn
             (setq $p1 (line-beginning-position))
             (setq $p2 (line-end-position))))
         (list
          $p1
          $p2
          (if current-prefix-arg
              (ido-completing-read
               "Change to: "
               '( "english"  "chinese")
               "PREDICATE"
               "REQUIRE-MATCH")
            "auto"
            ))))
      (let (
            ($input-str (buffer-substring-no-properties @begin @end))
            ($replacePairs
             [
              [". " "„ÄÇ"]
              [".\n" "„ÄÇ\n"]
              [", " "Ôºå"]
              [",\n" "Ôºå\n"]
              [": " "Ôºö"]
              ["; " "Ôºõ"]
              ["? " "Ôºü"] ; no space after
              ["! " "ÔºÅ"]

              ;; for inside HTML
              [".</" "„ÄÇ</"]
              ["?</" "Ôºü</"]
              [":</" "Ôºö</"]
              [" " "„ÄÄ"]
              ]
             ))

        (when (string= @to-direction "auto")
          (setq
           @to-direction
           (if
               (or
                (string-match "„ÄÄ" $input-str)
                (string-match "„ÄÇ" $input-str)
                (string-match "Ôºå" $input-str)
                (string-match "Ôºü" $input-str)
                (string-match "ÔºÅ" $input-str))
               "english"
             "chinese")))
        (save-excursion
          (save-restriction
            (narrow-to-region @begin @end)
            (mapc
             (lambda ($x)
               (progn
                 (goto-char (point-min))
                 (while (search-forward (aref $x 0) nil "noerror")
                   (replace-match (aref $x 1)))))
             (cond
              ((string= @to-direction "chinese") $replacePairs)
              ((string= @to-direction "english") (mapcar (lambda (x) (vector (elt x 1) (elt x 0))) $replacePairs))
              (t (user-error "Your 3rd argument „Äå%s„Äç isn't valid" @to-direction))))))))
#+END_SRC

** Remove Punctuation Trailing Redundant Spaces
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's helpful command to remove redundant spaces after punctuation.

- In English text, the convention is to have 1 space after punctuation
  (sometimes 2, after the Full Stop sign).
- In Chinese text, the convention is to have no space after punctuation.

#+BEGIN_SRC emacs-lisp
    (defun xah-remove-punctuation-trailing-redundant-space (@begin @end)
      "Remove redundant whitespace after punctuation.
    Works on current line or text selection.

    When called in emacs lisp code, the *begin *end are cursor positions for region.

    See also `xah-convert-english-chinese-punctuation'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    version 2015-08-22"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (require 'xah-replace-pairs)
      (xah-replace-regexp-pairs-region
       @begin @end
       [
        ;; clean up. Remove extra space.
        [" +," ","]
        [",  +" ", "]
        ["?  +" "? "]
        ["!  +" "! "]
        ["\\.  +" ". "]

        ;; fullwidth punctuations
        ["Ôºå +" "Ôºå"]
        ["„ÄÇ +" "„ÄÇ"]
        ["Ôºö +" "Ôºö"]
        ["Ôºü +" "Ôºü"]
        ["Ôºõ +" "Ôºõ"]
        ["ÔºÅ +" "ÔºÅ"]
        ["„ÄÅ +" "„ÄÅ"]
        ]
       "FIXEDCASE" "LITERAL"))
#+END_SRC

These commands are useful for Twitter too, for saving a few character in
Twitter's character limit. Because, English punctuation takes 2 char
each, while Chinese version needs just one char, the space is included
in the punctuation symbol.

** Convert Half-Width Full-Width Characters
   :PROPERTIES:
   :CLASS: calibre17
   :END:

This command convert all English letters and digits and punctuations,
from/to half-width and full-width.

[see [[http://xahlee.info/comp/unicode_full-width_chars.html][Unicode
Full-Width Characters]]]

#+BEGIN_SRC emacs-lisp
    (defun xah-convert-fullwidth-chars (@begin @end &optional @to-direction)
      "Convert ASCII chars to/from Unicode fullwidth version.
    Works on current line or text selection.

    The conversion direction is determined like this: if the command has been repeated, then toggle. Else, always do to-Unicode direction.

    If `universal-argument' is called first:

     no C-u ‚Üí Automatic.
     C-u ‚Üí to ASCII
     C-u 1 ‚Üí to ASCII
     C-u 2 ‚Üí to Unicode

    When called in lisp code, @begin @end are region begin/end positions. @to-direction must be any of the following values: „Äå\"unicode\"„Äç, „Äå\"ascii\"„Äç, „Äå\"auto\"„Äç.

    See also: `xah-remove-punctuation-trailing-redundant-space'.

    URL `http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html'
    Version 2018-08-02"
      (interactive
       (let ($p1 $p2)
         (if (use-region-p)
             (progn
               (setq $p1 (region-beginning))
               (setq $p2 (region-end)))
           (progn
             (setq $p1 (line-beginning-position))
             (setq $p2 (line-end-position))))
         (list $p1 $p2
               (cond
                ((equal current-prefix-arg nil) "auto")
                ((equal current-prefix-arg '(4)) "ascii")
                ((equal current-prefix-arg 1) "ascii")
                ((equal current-prefix-arg 2) "unicode")
                (t "unicode")))))
      (let* (
             ($ascii-unicode-map
              [
               ["0" "Ôºê"] ["1" "Ôºë"] ["2" "Ôºí"] ["3" "Ôºì"] ["4" "Ôºî"] ["5" "Ôºï"] ["6" "Ôºñ"] ["7" "Ôºó"] ["8" "Ôºò"] ["9" "Ôºô"]
               ["A" "Ôº°"] ["B" "Ôº¢"] ["C" "Ôº£"] ["D" "Ôº§"] ["E" "Ôº•"] ["F" "Ôº¶"] ["G" "Ôºß"] ["H" "Ôº®"] ["I" "Ôº©"] ["J" "Ôº™"] ["K" "Ôº´"] ["L" "Ôº¨"] ["M" "Ôº≠"] ["N" "ÔºÆ"] ["O" "ÔºØ"] ["P" "Ôº∞"] ["Q" "Ôº±"] ["R" "Ôº≤"] ["S" "Ôº≥"] ["T" "Ôº¥"] ["U" "Ôºµ"] ["V" "Ôº∂"] ["W" "Ôº∑"] ["X" "Ôº∏"] ["Y" "Ôºπ"] ["Z" "Ôº∫"]
               ["a" "ÔΩÅ"] ["b" "ÔΩÇ"] ["c" "ÔΩÉ"] ["d" "ÔΩÑ"] ["e" "ÔΩÖ"] ["f" "ÔΩÜ"] ["g" "ÔΩá"] ["h" "ÔΩà"] ["i" "ÔΩâ"] ["j" "ÔΩä"] ["k" "ÔΩã"] ["l" "ÔΩå"] ["m" "ÔΩç"] ["n" "ÔΩé"] ["o" "ÔΩè"] ["p" "ÔΩê"] ["q" "ÔΩë"] ["r" "ÔΩí"] ["s" "ÔΩì"] ["t" "ÔΩî"] ["u" "ÔΩï"] ["v" "ÔΩñ"] ["w" "ÔΩó"] ["x" "ÔΩò"] ["y" "ÔΩô"] ["z" "ÔΩö"]
               ["," "Ôºå"] ["." "Ôºé"] [":" "Ôºö"] [";" "Ôºõ"] ["!" "ÔºÅ"] ["?" "Ôºü"] ["\"" "ÔºÇ"] ["'" "Ôºá"] ["`" "ÔΩÄ"] ["^" "Ôºæ"] ["~" "ÔΩû"] ["¬Ø" "Ôø£"] ["_" "Ôºø"]
               [" " "„ÄÄ"]
               ["&" "ÔºÜ"] ["@" "Ôº†"] ["#" "ÔºÉ"] ["%" "ÔºÖ"] ["+" "Ôºã"] ["-" "Ôºç"] ["*" "Ôºä"] ["=" "Ôºù"] ["<" "Ôºú"] [">" "Ôºû"] ["(" "Ôºà"] [")" "Ôºâ"] ["[" "Ôºª"] ["]" "ÔºΩ"] ["{" "ÔΩõ"] ["}" "ÔΩù"] ["(" "ÔΩü"] [")" "ÔΩ†"] ["|" "ÔΩú"] ["¬¶" "Ôø§"] ["/" "Ôºè"] ["\\" "Ôºº"] ["¬¨" "Ôø¢"] ["$" "ÔºÑ"] ["¬£" "Ôø°"] ["¬¢" "Ôø†"] ["‚Ç©" "Ôø¶"] ["¬•" "Ôø•"]
               ]
              )
             ($reverse-map
              (mapcar
               (lambda (x) (vector (elt x 1) (elt x 0)))
               $ascii-unicode-map))

             ($stateBefore
              (if (get 'xah-convert-fullwidth-chars 'state)
                  (get 'xah-convert-fullwidth-chars 'state)
                (progn
                  (put 'xah-convert-fullwidth-chars 'state 0)
                  0
                  )))
             ($stateAfter (if (eq $stateBefore 0) 1 0 )))

      ;"Ôºê\\|Ôºë\\|Ôºí\\|Ôºì\\|Ôºî\\|Ôºï\\|Ôºñ\\|Ôºó\\|Ôºò\\|Ôºô\\|Ôº°\\|Ôº¢\\|Ôº£\\|Ôº§\\|Ôº•\\|Ôº¶\\|Ôºß\\|Ôº®\\|Ôº©\\|Ôº™\\|Ôº´\\|Ôº¨\\|Ôº≠\\|ÔºÆ\\|ÔºØ\\|Ôº∞\\|Ôº±\\|Ôº≤\\|Ôº≥\\|Ôº¥\\|Ôºµ\\|Ôº∂\\|Ôº∑\\|Ôº∏\\|Ôºπ\\|Ôº∫\\|ÔΩÅ\\|ÔΩÇ\\|ÔΩÉ\\|ÔΩÑ\\|ÔΩÖ\\|ÔΩÜ\\|ÔΩá\\|ÔΩà\\|ÔΩâ\\|ÔΩä\\|ÔΩã\\|ÔΩå\\|ÔΩç\\|ÔΩé\\|ÔΩè\\|ÔΩê\\|ÔΩë\\|ÔΩí\\|ÔΩì\\|ÔΩî\\|ÔΩï\\|ÔΩñ\\|ÔΩó\\|ÔΩò\\|ÔΩô\\|ÔΩö"

        ;; (message "before %s" $stateBefore)
        ;; (message "after %s" $stateAfter)
        ;; (message "@to-direction %s" @to-direction)
        ;; (message "real-this-command  %s" real-this-command)
        ;; (message "real-last-command %s" real-last-command)
        ;; (message "this-command  %s" this-command)
        ;; (message "last-command %s" last-command)

        (let ((case-fold-search nil))
          (xah-replace-pairs-region
           @begin @end
           (cond
            ((string= @to-direction "unicode") $ascii-unicode-map)
            ((string= @to-direction "ascii") $reverse-map)
            ((string= @to-direction "auto")
             (if (eq $stateBefore 0)
                 $reverse-map
               $ascii-unicode-map )

             ;; 2018-08-02 this doesn't work when using smex
             ;; (if (eq last-command this-command)
             ;;     (progn
             ;;       (message "%s" "repeated")
             ;;       (if (eq $stateBefore 0)
             ;;           $reverse-map
             ;;         $ascii-unicode-map ))
             ;;   (progn
             ;;     (message "%s" "not repeated")
             ;;     $ascii-unicode-map))

             ;;

             )
            (t (user-error "Your 3rd argument „Äå%s„Äç isn't valid" @to-direction)))
           t t ))
        (put 'xah-convert-fullwidth-chars 'state $stateAfter)))
#+END_SRC

**** Emacs Chinese Topics
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[file:elisp_chinese_char_linkify.html][Elisp: Chinese Char To
  Reference Link]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_13/elisp_convert_chinese_punctuation.xhtml][Emacs:
  Convert Full-Width/Half-Width Punctuations]]
- [[file:emacs_chinese_input.html][Emacs Chinese Input]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_convert_chinese_punctuation.html]]

\\
\\
| [[../index_u13.html#article_13][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u22.html>>

| [[../article_15/index_u16.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_14][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_13/index_u33.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Convert Color Formats: RGB, HSL, HSV
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2013-05-27. Last updated: 2017-04-15.

The color package =color.el=, in emacs 24.1, lets you convert colors
from various models and formats. For example: RGB, HSL, HSV, named color
values, and things like finding the color complement.

This page shows you:

- How to use =color.el=.
- Command to convert color format under cursor.

** Convert RGB to HSL
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert RGB color to HSL.
    ;; all input and output are in the range {0, 1}

    (require 'color )

    (color-rgb-to-hsl 1 0 0) ; ‚áí  (0.0 1 0.5) red

    (color-rgb-to-hsl 0 1 0) ; ‚áí (0.3333333333333333 1 0.5) green

    (color-rgb-to-hsl 0 0 1) ; ‚áí (0.6666666666666666 1 0.5) blue

    (color-rgb-to-hsl 1 1 1) ; ‚áí (0.0 0.0 1.0) white

    (color-rgb-to-hsl 0 0 0) ; ‚áí (0.0 0.0 0.0) black
#+END_SRC

Note that if you are converting from hex valued RGB format such as
=#aabbcc=, you must first convert the hex to integer, then re-scale from
{0 to 255} based range to {0 to 1} based range, then feed that to
=color-rgb-to-hsl=.

For explanation of the HSL color model, see:
[[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]

** Convert HSL to RGB
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; convert HSL color to RGB.
    ;; all input and output are in the range {0 to 1}

    (require 'color )

    (color-hsl-to-rgb 0 1 .5) ; (1.0 0.0 0.0) red

    (color-hsl-to-rgb .3 1 .5) ; ‚áí (0.19999999999999996 1.0 0.0) greenish

    (color-hsl-to-rgb .6 1 .5) ; ‚áí (0.0 0.3999999999999999 1.0) blueish

    (color-hsl-to-rgb 0 0 1) ; ‚áí (1 1 1) white

    (color-hsl-to-rgb 0 0 0) ; ‚áí (0 0 0) black
#+END_SRC

** Convert RGB Hexadecimal Format to Emacs Lisp Vector Format
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-css-convert-color-hex-to-vec (@rrggbb)
      "Convert color *rrggbb from ‚Äú\"rrggbb\"‚Äù string to a elisp vector [r g b], where the values are from 0 to 1.
    Example:
     (xah-css-convert-color-hex-to-vec \"00ffcc\") ‚áí [0.0 1.0 0.8]

    Note: The input string must NOT start with ‚Äú#‚Äù.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (vector
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 0 2) 16) 255)
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 2 4) 16) 255)
       (xah-css-normalize-number-scale (string-to-number (substring @rrggbb 4) 16) 255)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-css-normalize-number-scale (@val @range-max)
      "Scale *val from range [0, *range-max] to [0, 1]
    The arguments can be int or float.
    Return value is float.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (/ (float @val) (float @range-max)))
#+END_SRC

** Command to Convert RGB Color to HSL
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a command that convert between CSS's RGB hexadecimal format to
HSL format. For example, =#ffefd5= ‚Üí =hsl(37,100%,91%)=

It works on the word under cursor.

#+BEGIN_SRC emacs-lisp
    (defun xah-css-hex-color-to-hsl ()
      "Convert color spec under cursor from ‚Äú#rrggbb‚Äù to CSS HSL format.
     e.g. #ffefd5 ‚áí hsl(37,100%,91%)
    URL `http://ergoemacs.org/emacs/elisp_convert_rgb_hsl_color.html'
    Version 2016-07-19"
      (interactive)
      (let* (
             ($bds (bounds-of-thing-at-point 'word))
             ($p1 (car $bds))
             ($p2 (cdr $bds))
             ($currentWord (buffer-substring-no-properties $p1 $p2)))
        (if (string-match "[a-fA-F0-9]\\{6\\}" $currentWord)
            (progn
              (delete-region $p1 $p2 )
              (when (equal (char-before) 35) ; 35 is #
                (delete-char -1))
              (insert (xah-css-hex-to-hsl-color $currentWord )))
          (progn
            (user-error "The current word „Äå%s„Äç is not of the form #rrggbb." $currentWord)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-css-hex-to-hsl-color (@hex-str)
      "Convert *hex-str color to CSS HSL format.
    Return a string. Example:  \"ffefd5\" ‚áí \"hsl(37,100%,91%)\"
    Note: The input string must NOT start with ‚Äú#‚Äù.
    URL `http://ergoemacs.org/emacs/emacs_CSS_colors.html'
    Version 2016-07-19"
      (let* (
             ($colorVec (xah-css-convert-color-hex-to-vec @hex-str))
             ($R (elt $colorVec 0))
             ($G (elt $colorVec 1))
             ($B (elt $colorVec 2))
             ($hsl (color-rgb-to-hsl $R $G $B))
             ($H (elt $hsl 0))
             ($S (elt $hsl 1))
             ($L (elt $hsl 2)))
        (format "hsl(%d,%d%%,%d%%)" (* $H 360) (* $S 100) (* $L 100))))
#+END_SRC

The code is from [[file:xah-css-mode.html][Emacs: Xah CSS Mode]].

=color.el= is written by Julien Danjou
[[[https://julien.danjou.info/blog/]] ] , Drew Adams
[[[http://www.emacswiki.org/emacs/DrewAdams]] ] Thanks guys.

- [[http://xahlee.info/js/css_hsl_color.html][CSS: HSL Color]]
- [[file:emacs_CSS_colors.html][Emacs: Working with CSS Color Values]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_convert_rgb_hsl_color.html]]

\\
\\
| [[../index_u13.html#article_14][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u16.html>>

| [[../article_16/index_u31.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_15][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_14/index_u22.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Convert Decimal/Hexadecimal
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-10-03. Last updated: 2020-02-17.

Here's several ways to convert between Hexadecimal to Decimal in emacs.

** Using calc
   :PROPERTIES:
   :CLASS: calibre17
   :END:

- Alt+x =calc=.
- Type any number. For example, 10.
- Type ‚Äúd6‚Äù to turn the display into hexadecimal form.
- Type ‚Äúd0‚Äù to turn the display into decimal form.

To type a hex number, type =#=, then type ‚Äú16#aa‚Äù for the hex ‚Äúaa‚Äù.

** Using Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's how to convert decimal to hexadecimal:

#+BEGIN_SRC emacs-lisp
    ;; decimal to hex. Returns „Äåa„Äç
    (format "%x" 10)
#+END_SRC

Here's how to convert hexadecimal to decimal:

#+BEGIN_SRC emacs-lisp
    ;; hex „Äåa„Äç to decimal. Returns „Äå10„Äç.
    (format "%d" #xa)
#+END_SRC

Select the code, then Alt+x =eval-region=.

[see [[file:elisp_eval_lisp_code.html][Emacs: Evaluate Elisp Code]]]

** Emacs Lisp Command
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a elisp command that prints the decimal value of a hexadecimal
string under cursor.

#+BEGIN_SRC emacs-lisp
    (defun xah-show-hexadecimal-value ()
      "Prints the decimal value of a hexadecimal string under cursor.

    Samples of valid input:

      ffff ‚Üí 65535
      0xffff ‚Üí 65535
      #xffff ‚Üí 65535
      FFFF ‚Üí 65535
      0xFFFF ‚Üí 65535
      #xFFFF ‚Üí 65535

    more test cases
      64*0xc8+#x12c 190*0x1f4+#x258
      100 200 300   400 500 600

    URL `http://ergoemacs.org/emacs/elisp_converting_hex_decimal.html'
    Version 2020-02-17"
      (interactive )
      (let ($inputStr $tempStr $p1 $p2 )
        (if (region-active-p)
            (progn
              (setq $p1 (region-beginning))
              (setq $p2 (region-end)))
          (progn
            (save-excursion
              (skip-chars-backward "0123456789abcdefABCDEF#x")
              (setq $p1 (point))
              (skip-chars-forward "0123456789abcdefABCDEF#x" )
              (setq $p2 (point)))))
        (setq $inputStr (buffer-substring-no-properties $p1 $p2))
        (let ((case-fold-search nil))
          (setq $tempStr (replace-regexp-in-string "\\`0x" "" $inputStr )) ; C, Perl, ‚Ä¶
          (setq $tempStr (replace-regexp-in-string "\\`#x" "" $tempStr )) ; elisp ‚Ä¶
          (setq $tempStr (replace-regexp-in-string "\\`#" "" $tempStr )) ; CSS ‚Ä¶
          )
        (message "input „Äå%s„Äç, Hex „Äå%s„Äç is „Äå%d„Äç" $inputStr $tempStr (string-to-number $tempStr 16))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_converting_hex_decimal.html]]

\\
\\
| [[../index_u13.html#article_15][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u31.html>>

| [[../article_17/index_u24.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_16][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_15/index_u16.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Replace Greek Letter Names to Unicode
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2016-10-05.

[[file:feed_0/article_16/images/img1_u4.png]]

Here's a command to convert Greek to unicode symbols.

#+BEGIN_SRC emacs-lisp
    (require 'xah-replace-pairs)

    (defun xah-replace-greek-letter-name-to-symbol (@begin @end)
      "Replace alpha to Œ±, beta to Œ≤ etc in current line or selection.

    URL `http://ergoemacs.org/emacs/elisp_replace_greeks_to_symbols.html'
    Version 2016-10-05"
      (interactive
       (if (use-region-p)
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-end-position))))
      (let ((case-fold-search nil))
        (xah-replace-pairs-region
         @begin
         @end
         '(
           ["Alpha" "Œë"]
           ["Beta" "Œí"]
           ["Gamma" "Œì"]
           ["Delta" "Œî"]
           ["Epsilon" "Œï"]
           ["Zeta" "Œñ"]
           ["Eta" "Œó"]
           ["Theta" "Œò"]
           ["Iota" "Œô"]
           ["Kappa" "Œö"]
           ["Lambda" "Œõ"]
           ["Mu" "Œú"]
           ["Nu" "Œù"]
           ["Xi" "Œû"]
           ["Omicron" "Œü"]
           ["Pi" "Œ†"]
           ["Rho" "Œ°"]
           ["Sigma" "Œ£"]
           ["Tau" "Œ§"]
           ["Upsilon" "Œ•"]
           ["Phi" "Œ¶"]
           ["Chi" "Œß"]
           ["Psi" "Œ®"]
           ["Omega" "Œ©"]

           ["alpha" "Œ±"]
           ["beta" "Œ≤"]
           ["gamma" "Œ≥"]
           ["delta" "Œ¥"]
           ["epsilon" "Œµ"]
           ["zeta" "Œ∂"]
           ["eta" "Œ∑"]
           ["theta" "Œ∏"]
           ["iota" "Œπ"]
           ["kappa" "Œ∫"]
           ["lambda" "Œª"]
           ["mu" "Œº"]
           ["nu" "ŒΩ"]
           ["xi" "Œæ"]
           ["omicron" "Œø"]
           ["pi" "œÄ"]
           ["rho" "œÅ"]
           ["sigmaf" "œÇ"]
           ["sigma" "œÉ"]
           ["tau" "œÑ"]
           ["upsilon" "œÖ"]
           ["phi" "œÜ"]
           ["chi" "œá"]
           ["psi" "œà"]
           ["omega" "œâ"]
           ["thetasym" "œë"]
           ["upsih" "œí"]
           ["piv" "œñ"]
           ) 'REPORT 'HILIGHT )))
#+END_SRC

You need the elisp library
[[file:elisp_replace_string_region.html][Emacs: xah-replace-pairs.el]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_replace_greeks_to_symbols.html]]

\\
\\
| [[../index_u13.html#article_16][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u24.html>>

| [[../article_18/index_u14.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_17][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_16/index_u31.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Twitterfy
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2015-02-04. Last updated: 2019-01-16.

Here's a emacs lisp command that shortens text to fit twitter's 140
chars.

#+BEGIN_SRC emacs-lisp
    (defun xah-twitterfy ()
      "Shorten words for Twitter 280 char limit on current line or selection.

    If `universal-argument' is called first, ask for conversion direction (shorten/lenthen).

    Note: calling this function twice in opposite direction does not necessarily return the origial, because the map is not one-to-one.

    URL `http://ergoemacs.org/emacs/elisp_twitterfy.html'
    Version 2019-01-16"
      (interactive)
      (let (
            $p1 $p2
            $direction

            ($shorten-map
             [
              ["\\bare\\b" "r"]
              ["\\byou\\b" "u"]
              ["e.g. " "eg "]
              ["\bto\b" "2"]
              [" your" " ur "]
              ["\\band\\b" "ÔºÜ"]
              ["because" "‚àµ"]
              ["therefore " "‚à¥"]
              [" at " " @ "]
              [" love " " ‚ô• "]
              [" one " " 1 "]
              [" two " " 2 "]
              [" three " " 3 "]
              [" four " " 4 "]
              [" zero " " 0 "]
              ["hexadecimal " "hex "]
              ["Emacs: " "#emacs "]
              ["JavaScript: " "#JavaScript "]
              ["Python: " "#python "]
              ["Ruby: " "#ruby "]
              ["Perl: " "#perl "]
              ["Emacs Lisp: " "#emacs #lisp "]
              ["Elisp: " "#emacs #lisp "]
              [", " "Ôºå"]
              ["\\.\\.\\." "‚Ä¶"]
              ["\\. " "„ÄÇ"]
              ["\\? " "Ôºü"]
              [": " "Ôºö"]
              ["! " "ÔºÅ"]]
             )
            ($lengeth-map
             [
              ["\\bu\\b" "you"]
              ["\\br\\b" "are"]
              ["eg " "e.g. "]
              [" 2 " " to "]
              ["\\bur\\b" "your"]
              ["\\bÔºÜ\\b" "and"]
              ["\\bcuz\\b" "because"]
              ["\\b‚à¥\\b" "therefore "]
              [" @ " " at "]
              [" ‚ô• " " love "]
              [" 1 " " one "]
              [" 2 " " two "]
              [" 3 " " three "]
              [" 4 " " four "]
              [" 0 " " zero "]
              ["hex " "hexadecimal "]
              ["Ôºå" ", "]
              ["‚Ä¶" "..."]
              ["„ÄÇ" ". "]
              ["Ôºü" "? "]
              ["Ôºö" ": "]
              ["ÔºÅ" "! "]
              ]
             ))
        (if (region-active-p)
            (setq $p1 (region-beginning) $p2 (region-end))
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn
                  (setq $p1 (point))
                  (re-search-forward "\n[ \t]*\n"))
              (setq $p1 (point)))
            (progn
              (re-search-forward "\n[ \t]*\n" nil "move")
              (setq $p2 (point)))))
        (setq $direction
              (if current-prefix-arg
                  (ido-completing-read
                   "Direction: "
                   '( "shorten"  "lengthen")
                   "PREDICATE"
                   "REQUIRE-MATCH")
                "auto"
                ))
        (save-restriction
          (narrow-to-region $p1 $p2)
          (when (string= $direction "auto")
            (goto-char (point-min))
            (setq $direction
                  (if (re-search-forward "„ÄÇ\\|Ôºå\\|Ôºü\\|ÔºÅ" nil t)
                      "lengthen" "shorten"
                      )))
          (let ( (case-fold-search nil))
            (mapc
             (lambda ($x)
               (goto-char (point-min))
               (while (re-search-forward (elt $x 0) nil t)
                 (replace-match (elt $x 1) "FIXEDCASE" "LITERAL")))
             (if (string= $direction "shorten")
                 $shorten-map
               $lengeth-map))
            (goto-char (point-min))
            (while (re-search-forward "  +" nil t)
              (replace-match " " "FIXEDCASE" "LITERAL")))
          (goto-char (+ (point-min) 280)))))
#+END_SRC

2019-01-16 am still refining this command. So you may see some bad code
here.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_twitterfy.html]]

\\
\\
| [[../index_u13.html#article_17][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u14.html>>

| [[../article_19/index_u5.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_18][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_17/index_u24.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: xah-fix-datetime
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2020-09-08.

Here's a command that fix datetime under cursor into yyyy-mm-dd format.

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-datetime (@begin @end)
      "Change timestamp under cursor into a yyyy-mm-dd format.
    If there's a text selection, use that as input, else use current line.
    Replace the text in selection or current line.

    Any ‚Äúday of week‚Äù, or ‚Äútime‚Äù info, or any other parts of the string, are discarded.
    For example:
     TUESDAY, FEB 15, 2011 05:16 ET ‚Üí 2011-02-15
     November 28, 1994              ‚Üí 1994-11-28
     Nov. 28, 1994                  ‚Üí 1994-11-28
     11/28/1994                     ‚Üí 1994-11-28
     1994/11/28                     ‚Üí 1994-11-28

    URL `http://ergoemacs.org/emacs/elisp_datetime_parser.html'
    Version 2020-09-08"
      (interactive
       (list
        (if (region-active-p) (region-beginning))
        (if (region-active-p) (region-end))))
      (require 'parse-time)
      (let ($p1 $p2 $in)
        (if @begin
            (setq $p1 @begin $p2 @end)
          (setq $p1 (line-beginning-position) $p2 (line-end-position)))
        (setq $in (replace-regexp-in-string "^ *\\(.+\\) *$" "\\1" (buffer-substring-no-properties $p1 $p2)))
      ; remove white spaces

        (setq $in
              (cond

               ;; yyyy/mm/dd
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))

               ;; mm/dd/yyyy
               ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9][0-9][0-9]\\)" $in)
                (concat (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
               ;; m/dd/yyyy
               ((string-match "\\([0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9][0-9][0-9]\\)" $in)
                (concat (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

               ;; USA convention of mm/dd/yy
               ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (format-time-string "%C") (match-string 3 $in) "-" (match-string 1 $in) "-" (match-string 2 $in)))
               ;; USA convention of m/dd/yy
               ((string-match "\\([0-9]\\)/\\([0-9][0-9]\\)/\\([0-9][0-9]\\)" $in)
                (concat (format-time-string "%C") (match-string 3 $in) "-0" (match-string 1 $in) "-" (match-string 2 $in)))

               ;; some ISO 8601. yyyy-mm-ddThh:mm
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)T[0-9][0-9]:[0-9][0-9]" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
               ;; some ISO 8601. yyyy-mm-dd
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in) "-" (match-string 3 $in)))
               ;; some ISO 8601. yyyy-mm
               ((string-match "\\([0-9][0-9][0-9][0-9]\\)-\\([0-9][0-9]\\)" $in)
                (concat (match-string 1 $in) "-" (match-string 2 $in)))

               ;; else
               (t
                (progn
                  (setq $in (replace-regexp-in-string "January " "Jan. " $in))
                  (setq $in (replace-regexp-in-string "February " "Feb. " $in))
                  (setq $in (replace-regexp-in-string "March " "Mar. " $in))
                  (setq $in (replace-regexp-in-string "April " "Apr. " $in))
                  (setq $in (replace-regexp-in-string "May " "May. " $in))
                  (setq $in (replace-regexp-in-string "June " "Jun. " $in))
                  (setq $in (replace-regexp-in-string "July " "Jul. " $in))
                  (setq $in (replace-regexp-in-string "August " "Aug. " $in))
                  (setq $in (replace-regexp-in-string "September " "Sep. " $in))
                  (setq $in (replace-regexp-in-string "October " "Oct. " $in))
                  (setq $in (replace-regexp-in-string "November " "Nov. " $in))
                  (setq $in (replace-regexp-in-string "December " "Dec. " $in))

                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)st" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)nd" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]+\\)rd" "\\1" $in))
                  (setq $in (replace-regexp-in-string "\\([0-9]\\)th" "\\1" $in))

                  (let ($dateList $year $month $date $yyyy $mm $dd )
                    (setq $dateList (parse-time-string $in))
                    (setq $year (nth 5 $dateList))
                    (setq $month (nth 4 $dateList))
                    (setq $date (nth 3 $dateList))

                    (setq $yyyy (number-to-string $year))
                    (setq $mm (if $month (format "%02d" $month) "" ))
                    (setq $dd (if $date (format "%02d" $date) "" ))
                    (concat $yyyy "-" $mm "-" $dd))))))
        (delete-region $p1 $p2 )
        (insert $in)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-datetime-string (@datetime)
      "Return a new string of @datetime in yyyy-mm-dd format.
    Other datetime info such as hours, minutes, time zone, are discarded. This function calls `xah-fix-datetime' to do work.

    URL `http://ergoemacs.org/emacs/elisp_datetime_parser.html'
    Version 2020-09-08"
      (with-temp-buffer
        (insert @datetime)
        (xah-fix-datetime (point-min) (point-max))
        (buffer-substring-no-properties (point-min) (point-max))))
#+END_SRC

The whole code is just one giant conditional test.

#+BEGIN_SRC emacs-lisp
    (cond
     (TEST2 BODY)
     (TEST2 BODY)
     ‚Ä¶
     )
#+END_SRC

In the code, the first few tests are regex match of forms like
=nn/nn/nnnn= where each ‚Äún‚Äù is a digit. When any of these match, then
basically i got what i want, and the code exits.

When none of these match, then it goes to the end of the test
=(t BODY)=, where the ‚Äút‚Äù there is always true, and run a big chunk of
BODY. In the BODY, first i replace each full spelling of month names by
their abbrev using =replace-regexp-in-string=, example

#+BEGIN_SRC emacs-lisp
    (setq $str (replace-regexp-in-string "January " "Jan. " $str))
#+END_SRC

This is done because in emacs 22 the =parse-time-string= doesn't
understand fully spelled month names. (this has been fixed in 23.2.1 or
earlier.)

Then, i also replace {1st, 2nd, nth} etc by {1, 2, n}, because emacs's
=parse-time-string= doesn't understand those. Then, i simply feed it to
=parse-time-string= and get a parsed date time as a list. After that,
just extract the elements from the list and reformat the way i want
using =format=.

**** Datetime
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[file:elisp_insert-date-time.html][Insert Date Time]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_18/elisp_datetime_parser.xhtml][xah-fix-datetime]]
- [[file:elisp_datetime.html][Elisp: Print Date Time]]
- [[file:elisp_parse_time.html][Elisp: Parse Date Time]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_datetime_parser.html]]

\\
\\
| [[../index_u13.html#article_18][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u5.html>>

| [[../article_20/index_u38.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_19][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_18/index_u14.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Count Lines, Words, Chars
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-23. Last updated: 2015-11-29.

A little emacs lisp exercise. Writing command to count words.

In emacs 23, there's =count-lines=, but no command to count words or
characters. (=count-words= is now built-in in in emacs 24. [see
[[file:emacs24_features.html][Emacs 24.1 Features (released 2012-06)]]])

Here's how to write it.

#+BEGIN_SRC emacs-lisp
    (defun my-count-words-region (posBegin posEnd)
      "Print number of words and chars in region."
      (interactive "r")
      (message "Counting ‚Ä¶")
      (save-excursion
        (let (wordCount charCount)
          (setq wordCount 0)
          (setq charCount (- posEnd posBegin))
          (goto-char posBegin)
          (while (and (< (point) posEnd)
                      (re-search-forward "\\w+\\W*" posEnd t))
            (setq wordCount (1+ wordCount)))

          (message "Words: %d. Chars: %d." wordCount charCount)
          )))
#+END_SRC

** How It Works
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The function has this skeleton:

#+BEGIN_SRC emacs-lisp
    (defun my-count-words-region (pos1 pos2)
      "‚Ä¶"
      (interactive "r")
      ; ‚Ä¶
      )
#+END_SRC

the =(interactive "r")= means emacs will automatically fill your dummy
variables {pos1, pos2} by region beginning/end positions. (region
positions are integers) [see [[file:emacs_region.html][Elisp: Region,
Active Region]]] [see [[file:elisp_interactive_form.html][Elisp:
Interactive Form]]]

The next part of the function is this:

#+BEGIN_SRC emacs-lisp
    (save-excursion
     (let (var1 var2 ‚Ä¶))
     (setq var1 ‚Ä¶)
     (setq var2 ‚Ä¶)
     ‚Ä¶
    )
#+END_SRC

The =let= is lisp's way to have a block of local variables.

The =(save-excursion ‚Ä¶)= will run its body, then restore the cursor
position and mark position. We need it because in the code we are going
to move cursor around. When the command is finished, the cursor will be
placed back to the position when user started the command.

Now, to count the char, it is just the length of the beginning and
ending position of the region. So, it is simple, like this:

#+BEGIN_SRC emacs-lisp
    (setq charCount (- posEnd posBegin))
#+END_SRC

Now, we move the char to beginning of region, like this:
=(goto-char posBegin)=. The next part, count the words, like this:

#+BEGIN_SRC emacs-lisp
    (while (and (< (point) posEnd)
                      (re-search-forward "\\w+\\W*" posEnd t))
            (setq wordCount (1+ wordCount)))
#+END_SRC

The =(< (point) posEnd)= is for checking that the cursor havn't reached
the end of region yet.

The =(re-search-forward "\\w+\\W*" posEnd t)= means keep moving the
cursor forward by regex search a word pattern. The ‚ÄúposEnd‚Äù argument
there means don't search beyond the end of region. And the ‚Äút‚Äù there
means don't report error if no more found.

=search-forward= and =re-search-forward= are one of the top 10 most
useful functions in elisp for text processing. If you are not familiar
with them, lookup their doc string (with =describe-function=).

So, the above ‚Äúwhile‚Äù block, basically means keep moving the cursor and
count words, until the cursor is at the end of region.

Finally, the program just print out the result, by:

#+BEGIN_SRC emacs-lisp
    (message "Words: %d. Chars: %d." wordCount charCount)
#+END_SRC

** Note
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The code shown on this page count words by emacs's syntax table, because
the regex for word =\\w+= is dependent on syntax table. In emacs, each
character is classified into one or more categories. For example, the
English alphabets are in the ‚Äúword‚Äù class, punctuations characters are
in ‚Äúpunctuation‚Äù class, etc. The current syntax table often depends on
the major mode. [[../emacs_manual/elisp/Syntax-Tables.html][(info
"(elisp) Syntax Tables")]]

The disadvantage of syntax table is that, the result is unpredictable,
dependent what the current major mode (and any minor mode or lisp code
can change it). For example, this file (at this moment), is 1325 words
when in ‚ÄúFundamental‚Äù mode, but 1316 words when in ‚Äútext-mode‚Äù. (863 by
unix ‚Äúwc‚Äù command.)

** count-words-region-or-line
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a version that will count the current line, if there's no text
selection.

#+BEGIN_SRC emacs-lisp
    (defun xah-count-words-region-or-line ()
      "Print number of words and chars in text selection or line.
    In emacs 24, you can use `count-words'."
      (interactive)
      (let (p1 p2)
        (if (region-active-p)
            (progn (setq p1 (region-beginning))
                   (setq p2 (region-end)))
          (progn (setq p1 (line-beginning-position))
                 (setq p2 (line-end-position))))
        (save-excursion
          (let (wCnt charCnt)
            (setq wCnt 0)
            (setq charCnt (- p2 p1))
            (goto-char p1)
            (while (and (< (point) p2) (re-search-forward "\\w+\\W*" p2 t))
              (setq wCnt (1+ wCnt)))
            (message "Words: %d. Chars: %d." wCnt charCnt)))))
#+END_SRC

*** Introduction to Programming in Emacs Lisp by Robert J Chassell
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Note: ‚Äúmy-count-words-region‚Äù is largely from „ÄàIntroduction to
Programming in Emacs Lisp„Äâ
[[http://www.amazon.com/dp/1882114027/?tag=xahh-20][Buy at amazon]] by
Robert J Chassell.

This book is bundled with emacs since version 22. To view it in emacs,
Alt+x =info= „ÄêCtrl+h i„Äë, then click on the ‚ÄúEmacs Lisp Intro‚Äù.

I was reading it sometimes in 2005. That tutorial is for people who
never programed before. It was quite frustrating to read, because for
every thing you learn, you have to scan some 10 pages of things you
already know about programing, such as the meaning of {variables,
assignment, syntax, ...}. In the end, i didn't really read that book.
This function is about the only thing i got out of it.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_count-region.html]]

\\
\\
| [[../index_u13.html#article_19][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u38.html>>

| [[../article_21/index_u36.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_20][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_19/index_u5.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Python 2to3 Wrapper
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2013-02-16. Last updated: 2016-02-16.

Here's a handy emacs lisp wrapper for converting current buffer's python
2 script to python 3.

#+BEGIN_SRC emacs-lisp
    (defun xah-python-2to3-current-file ()
      "Convert current buffer from python 2 to python 3.
    This command calls python3's script „Äå2to3„Äç.
    URL `http://ergoemacs.org/emacs/elisp_python_2to3.html'
    Version 2016-02-16"
      (interactive)
      (let* (
             (fName (buffer-file-name))
             (fSuffix (file-name-extension fName)))
        (when (buffer-modified-p)
          (save-buffer))
        (if (or (string-equal fSuffix "py") (string-equal fSuffix "py3"))
            (progn
              (shell-command (format "2to3 -w %s" fName))
              (revert-buffer  "IGNORE-AUTO" "NOCONFIRM" "PRESERVE-MODES"))
          (error "file „Äå%s„Äç doesn't end in ‚Äú.py‚Äù or ‚Äú.py3‚Äù." fName))))
#+END_SRC

A handy command to go with it is
[[file:elisp_run_current_file.html][Emacs: Run Current File]]

See also: [[file:elisp_perl_wrapper.html][Elisp: Write Emacs Commands
Using Python, Ruby, ...]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_python_2to3.html]]

\\
\\
| [[../index_u13.html#article_20][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u36.html>>

| [[../article_22/index_u43.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_21][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_20/index_u38.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Refactoring, Move Code to Files
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-12-05. Last updated: 2014-11-06.

This page shows a example of writing a emacs command to move a text
block into a predefined set of files.

when this command is called, it'll prompt you to select a category, then
move the current block of text into a corresponding file.

here it is:

#+BEGIN_SRC emacs-lisp
    (defun xwe-move-word-to-page (@category)
      "Take current selection or block of text, ask which page to move it to."
      (interactive
       (list (ido-completing-read "Which:" '("specialwords"
                                             "arcane"
                                             "combowords"
                                             "easy"
                                             "foreignwords"
                                             "gre"
                                             "hyphwords"
                                             "informal"
                                             "slang"
                                             "noun"
                                             "noun_things"
                                             "noun_abs"
                                             "poesy"
                                             "satwords"
                                             "writerwords"))))
      (let (
            p1
            p2
            $wordText
            ($destFile (concat @category ".html")))
        (if (use-region-p)
            (progn
              (setq p1 (region-beginning))
              (setq p2 (region-end)))
          (save-excursion
            (if (re-search-backward "\n[ \t]*\n" nil "move")
                (progn (re-search-forward "\n[ \t]*\n")
                       (setq p1 (point)))
              (setq p1 (point)))
            (if (re-search-forward "\n[ \t]*\n" nil "move")
                (progn (re-search-backward "\n[ \t]*\n")
                       (setq p2 (point)))
              (setq p2 (point)))))

        (setq $wordText (buffer-substring-no-properties p1 p2))
        (delete-region p1 p2 )

        (find-file (concat (xahsite-server-root-path) "wordyenglish_com/words/" $destFile))
        (goto-char 1)
        (search-forward "<section class=\"word\">") (search-backward "<")
        (insert $wordText "\n\n")
        (save-buffer )
        (kill-buffer )
        (message "Word moved to „Äå%s„Äç" $destFile)

        (let*
            ;; save the working buffer, but make backup first
            (($fname (buffer-file-name))
             ($backupName (concat $fname "~" (format-time-string "%Y%m%d_%H%M%S") "~")))
          (copy-file $fname $backupName t)
          (save-buffer ))))
#+END_SRC

So now, i press a key, then the text block under cursor is moved to a
appropriate file in the appropriate location. This is used for my
vocabulary collection page:
[[http://wordyenglish.com/words/vocabulary.html][Wordy English:
Vocabulary Compilation with Usage Examples]].

Now, to move the current paragraph to a file, it takes me just 2
seconds. Otherwise, it'll take about 15 seconds (using all emacs tricks
to cut current text block, open/switch to the appropriate file, locate
the position to insert, insert, save and close).

You can use this code to refactor programing source code. You'll need to
modify the list of category, and the section of
=xahsite-server-root-path=

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_move_code_to_files.html]]

\\
\\
| [[../index_u13.html#article_21][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u43.html>>

| [[../article_23/index_u18.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_22][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_21/index_u36.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Command to Update RSS/Atom Webfeed
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2009-01-21. Last updated: 2020-04-24.

This page shows a example of writing a emacs lisp command that updates a
web feed file (Atom/RSS) on Local file system.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a command, when called, the current text selection will be added
as a entry in a Atom webfeed file.

You'll learn how to write a command that grabs the region text, switch
buffer, search string to locate position for inserting text, insert the
text, and update date field in a file.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I run several blogs on my personal website. For example, blog on
[[file:blog.html][Emacs]],
[[http://xahlee.info/kbd/keyboard_blog.html][keyboard]]
[[http://xahlee.info/comp/blog.html][Programing]]. Each of these has a
webfeed in Atom format.

Let's take the emacs blog for example. The file name is =blog.html=.
Typically, i open that file, write there, then save. The file sits on my
local disk, and is periodically synced to my web server. For each of the
blog file, there's also a corresponding webfeed, so that readers can
subscribe to it.

To create a webfeed, i've chosen the Atom format. Basically, it is a XML
file with tags for blog entries. [see
[[http://xahlee.info/js/atom.html][Atom Webfeed Tutorial]]]

The Atom file is named =blog.xml= in the same dir.

After i wrote some entry in my blog file =blog.html=, i'd like to be
able to press a button, so the current text selection will automatically
be added into my atom webfeed file =blog.xml= as a new entry.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

In the beginning few months, i just manually add the new writing from
=blog.html= into the =blog.xml= file. But after a while, the pattern is
clear, and can be automated. So, here are the major steps:

- Grab the current text selection, lets call this ‚ÄúinputStr‚Äù. This will
  be the main content for the webfeed entry.
- Open the Atom file corresponding to the current file.
- Update the =<updated>= tag in the Atom file.
- Insert a entry tag template into the Atom file at the right place.
- Insert the ‚ÄúinputStr‚Äù in the proper location in the template entry.

Here's various pieces of code that is required. I'll start to show, from
the smallest components, to the final code that makes all this work.

*** Insert Time Stamp
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's a command to insert date stamp.

#+BEGIN_SRC emacs-lisp
    (defun current-date-time-string ()
      "Returns current date-time string in full ISO 8601 format.
    Example: „Äå2012-04-05T21:08:24-07:00„Äç.

    Note, for the time zone offset, both the formats „Äåhhmm„Äç and „Äåhh:mm„Äç are valid ISO 8601. However, Atom Webfeed spec seems to require „Äåhh:mm„Äç."
      (concat
       (format-time-string "%Y-%m-%dT%T")
       ((lambda ($x) (format "%s:%s" (substring $x 0 3) (substring $x 3 5))) (format-time-string "%z")) )
      )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (defun insert-date-time ()
      "Insert current date-time string in full ISO 8601 format.
    Example: „Äå2010-11-29T23:23:35-08:00„Äç.

    Replaces currents text selection if there's one.
    This function calls: `current-date-time-string'."
      (interactive)
      (when (use-region-p)
        (delete-region (region-beginning) (region-end) )
        )
      (insert (current-date-time-string)))
#+END_SRC

One returns a string, the other inserts it at current cursor position.

*** Generate a new Atom Entry ID
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Each atom entry has a ‚Äúid‚Äù element like this:

#+BEGIN_SRC emacs-lisp
    <id>‚Äπid string‚Ä∫</id>
#+END_SRC

This id should be unique in the world. It should be in a URI format, and
some other requirements, but otherwise there's no standardized method on
what the string should be. [see [[http://xahlee.info/js/atom.html][Atom
Webfeed Tutorial]]]

Here's the code to generate this id that i've adopted, based on domain
name, date, and unix epoch seconds.

#+BEGIN_SRC emacs-lisp
    (defun new-atom-id-tag (&optional domainName)
      "Returns a newly generated ATOM webfeed's ‚Äúid‚Äù element string.
    Example of return value: „Äåtag:xahlee.org,2010-03-31:022128„Äç

    If DOMAINNAME is given, use that for the domain name.
    Else, use ‚Äúxahlee.org‚Äù."
        (format "tag:%s%s" (if domainName domainName "xahlee.org") (format-time-string ",%Y-%m-%d:%H%M%S" (current-time) 1)) )
#+END_SRC

*** Insert Atom Entry Template
    :PROPERTIES:
    :CLASS: calibre14
    :END:

A entry in Atom format looks like this:

#+BEGIN_SRC emacs-lisp
     <entry>
       <title>How To Insert Text In Emacs Lisp</title>
       <id>tag:xahlee.org,2010-01-02:234451</id>
       <updated>2010-01-02T15:44:51-08:00</updated>
       <summary>a short tutorial</summary>
       <content type="xhtml">
    <div xmlns="http://www.w3.org/1999/xhtml">
    <p>hi there, today i did this and that.</p>
    <p>and more HTML of the full content here ‚Ä¶</p>
    </div>
       </content>
      <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
     </entry>
#+END_SRC

So, i need a command to insert this entry template.

#+BEGIN_SRC emacs-lisp
    (defun insert-atom-entry (altLinkUrl)
      "Insert a Atom webfeed entry template,
     in the current buffer's cursor position."
      (interactive)
      (let (textToInsert domainName )
        (setq domainName "xahlee.org")
        (insert (format "
     <entry>
       <title>ÔøΩ</title>
       <id>%s</id>
       <updated>%s</updated>
       <summary>ÔøΩ</summary>
       <content type=\"xhtml\">
    <div xmlns=\"http://www.w3.org/1999/xhtml\">
    </div>
       </content>
      <link rel=\"alternate\" href=\"%s\"/>
     </entry>

    "
         (new-atom-id-tag domainName)
         (current-date-time-string)
         altLinkUrl
         ))
         ) )
#+END_SRC

Each Atom entry requires a link element, like this:

#+BEGIN_SRC emacs-lisp
    <link rel="alternate" href="http://xahlee.org/emacs/elisp_examples.html"/>
#+END_SRC

This link element is supposed to point to the perm link of the full
article. This is set as a argument ‚ÄúaltLinkUrl‚Äù to this function. The
caller will fill it.

The timestamp for the =<updated>= tag, and also id string for =<id>=
tag, are auto-generated from the functions we wrote before.

The content for =<title>‚Ä¶</title>= and =<summary>‚Ä¶</summary>= are not
automatically created, because usually i don't have a title or summary
for short blogs. Title and Summary are required by Atom, so i write them
on the spot. I use a Unicode symbol REPLACEMENT CHARACTER ÔøΩ as a
marker/reminder to fill them.

*** Updating Blog Date
    :PROPERTIES:
    :CLASS: calibre14
    :END:

In the Atom file, at top there's a tag named ‚Äúupdated‚Äù that looks like
this:

#+BEGIN_SRC emacs-lisp
    <updated>2010-01-02T15:44:51-08:00</updated>
#+END_SRC

This needs to be updated whenever you have a new entry. So, here's the
code for that:

#+BEGIN_SRC emacs-lisp
    (progn
          (goto-char 1)
          (search-forward "<updated>" nil t)
          (delete-char 25)
          (insert-date-time))
#+END_SRC

It uses the function =insert-date-time= that we have defined earlier.

*** Final Code
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Finally, here's the command that calls all the above functions to do
what i want.

#+BEGIN_SRC emacs-lisp
    (defun make-blog-entry (begin end)
      "Create a Atom (RSS) entry of my emacs blog webfeed.
    Using selected text as Atom entry content.

    Also update the Atom file's overall ‚Äúupdated‚Äù tag.

    The feed is at „Äî~/web/xahlee_org/emacs/blog.xml„Äï."
      (interactive "r")
      (let (inputStr currentFileDir currentFileName blogFileName blogFilePath altUrl)

        (setq inputStr (buffer-substring-no-properties begin end))
        (setq currentFileName (file-name-nondirectory (buffer-file-name)))
        (setq currentFileDir (file-name-directory (buffer-file-name))) ; ends in slash
        (setq blogFileName (concat (file-name-sans-extension (file-name-nondirectory currentFileName)) ".xml"))
        (setq blogFilePath (concat currentFileDir blogFileName))
        (setq altUrl "http://xahlee.org/emacs/blog.html")

        (find-file blogFilePath)
        (goto-char 1)
        (search-forward "<entry>" nil t)
        (beginning-of-line)
        (insert-atom-entry altUrl)
        (search-backward "<div xmlns=\"http://www.w3.org/1999/xhtml\">" nil t)
        (search-forward ">" nil t)
        (insert "\n" inputStr)
        ;; update atom date
        (progn
          (goto-char 1)
          (search-forward "<updated>" nil t)
          (delete-char 25)
          (insert-date-time))
        (search-forward ">ÔøΩ" nil t)
    )
    )
#+END_SRC

The code is pretty simple. First, it sets the current selected text to
the variable ‚ÄúinputStr‚Äù, by
=(setq inputStr (buffer-substring-no-properties begin end))=.

Then, it sets several paths. The current buffer's file path, name, dir,
and the corresponding blog file's path, name.

After the several =setq=, then it opens the webfeed file, go to the
beginning of file, search for the first occurrence of =<entry>=, and
that's the point a new entry should be inserted.

It then call =(insert-atom-entry altUrl)= to insert a new entry
template.

Then, it searches backward for the string
=<div xmlns="http://www.w3.org/1999/xhtml">=. This is where the
‚Äúcontent‚Äù part of the entry should be. The code then insert my content
‚ÄúinputStr‚Äù there.

After that, we update the blog updated date, then we just move pointer
to the next occurrence of ÔøΩ, so that when this code is done, the cursor
is right at the Title tag part for user to edit.

Emacs ‚ô•

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_update_atom.html]]

\\
\\
| [[../index_u13.html#article_22][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u18.html>>

| [[../article_24/index_u17.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_23][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_22/index_u43.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Writing a Interactive Command to Update HTML Page Tags
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-11-25. Last updated: 2015-09-04.

This page shows a example of writing a emacs lisp function that update
the page navigation tag of several files.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want to write a command, so that, when invoked, emacs will update
several HTML page's page navigation tag.

You will you learn how to grab the region text, parse them into a list,
then use the list to generate a string, then go thru the list to open
each file, insert the string, and do other modification on the file.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have a website of few thousand pages. Many of them are projects that
span several HTML pages. At the bottom of each page is a navigation bar,
like this:

[[file:feed_0/article_23/images/img1.png]]

The HTML looks like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projectB.html">1</a>,
    2,
    <a href="projectB-3.html">3</a>,
    <a href="projectB-4.html">4</a>
    </div>
#+END_SRC

If i want to add a new file for this series, let's say
=projectB-5.html=, i have to manually edit every file's page navigation
bar.

It would be nice, if i could just list the file names in the current new
page i just created, like this:

#+BEGIN_SRC emacs-lisp
    projectB.html
    projectB-2.html
    projectB-3.html
    projectB-4.html
    projectB-5.html
#+END_SRC

Then, select them, press a button, and have all the page tags of all
files updated. I decided to write this command.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the basic steps.

- Get all the files names in text selection. (they should be one file
  name per line)
- Delete this region's text.
- Generate a new page nav string base on the file names we got.
- Open each file, find the old page nav string. Delete it. Insert the
  new.
- Optionally, save and close the files.

Here's the code:

#+BEGIN_SRC emacs-lisp
    (defun xah-update-page-tag (p1 p2)
      "Update HTML page navigation tags.

    The input is a text selection.
    Each line should a file name
    Update each file's page navigation tag.

    Each file name is a file path without dir, and relative to current dir.

    Example text selection for input::

    combowords.html
    combowords-2.html
    combowords-3.html
    combowords-4.html
    "
      (interactive "r")
      (let (fileList pageNavStr (i 1))
        (setq fileList
              (split-string (buffer-substring-no-properties p1 p2) "\n" t)
              )

        (delete-region p1 p2)

        ;; generate the page nav string
        (setq pageNavStr "<div class=\"pages\">Goto Page: ")

        (while (<= i (length fileList))
          (setq pageNavStr
                (concat pageNavStr
                        "<a href=\""
                        (nth (- i 1) fileList)
                        "\">"
                        (number-to-string i)
                        "</a>, ")
                )
          (setq i (1+ i))
          )

        (setq pageNavStr (substring pageNavStr 0 -2) ) ; remove the last ", "
        (setq pageNavStr (concat pageNavStr "</div>"))

        ;; open each file, inseart the page nav string, remove link in the
        ;; nav string that's the current page
        (mapc
         (lambda (thisFile)
           (message "%s" thisFile)
           (find-file thisFile)
           (goto-char (point-min))
           (search-forward "<div class=\"pages\">")
           (beginning-of-line)
           (kill-line 1)
           (insert pageNavStr)
           (search-backward (file-name-nondirectory buffer-file-name))
           (sgml-delete-tag 1)
    ;;        (save-buffer)
    ;;        (kill-buffer)
           )
         fileList)
    ))
#+END_SRC

First, we define the function with 2 parameters named {p1, p2}, and use
=(interactive "r")=. This will automatically fill the parameters {p1,
p2} with the beginning and ending positions of text selection.

The next task is to grab this block of text, and turn it into a list,
using =split-string=. This is done like this:

#+BEGIN_SRC emacs-lisp
    (setq fileList
          (split-string (buffer-substring-no-properties p1 p2) "\n" t)
          )
#+END_SRC

Then, we want to generate the navbar string. This is done by using a
=while= loop with a counter ‚Äúi‚Äù. In each iteration, a string for the
current file is generated, and is then appended to pageNavStr.

This gives us the navbar string. The value of pageNavStr may be like
this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projB.html">1</a>,
    <a href="projB-2.html">2</a>,
    <a href="projB-3.html">3</a>
    </div>
#+END_SRC

However, it is not the final form. If current page is 2, then the navbar
string should be like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="projB.html">1</a>,
    2,
    <a href="projB-3.html">3</a>
    </div>
#+END_SRC

The next step is to open each file, insert the navbar string in the
proper place, then take out the link of the current page. This is done
by this code:

#+BEGIN_SRC emacs-lisp
    (mapc
     (lambda (thisFile)
       (message "%s" thisFile)
       (find-file thisFile)
       (goto-char (point-min))
       (search-forward "<div class=\"pages\">")
       (beginning-of-line)
       (kill-line 1)
       (insert pageNavStr)
       (search-backward (file-name-nondirectory buffer-file-name))
       (sgml-delete-tag 1)
       )
     fileList)
#+END_SRC

The logic is this: We map a function to each file. The function will
locate the existing navbar string, then delete that line, then insert
the new navbar string, then move back to the location where the link to
current file is at, then remove the link.

The function =mapc= has this form: =(mapc function list)=, where it will
apply function to each element in the list. =mapc= is different from
=mapcar=. If you want the result to be a list, you need to use =mapcar=.
Since we don't care for the resulting list, so we use =mapc=.

The lambda above is our function. =lambda= has the form
=(lambda (x) body)=, where x is the function's parameter, and body is
one or more lisp expressions. In the ‚Äúbody‚Äù part, any x will be replaced
with the argument received by lambda.

In our lambda body, first we print out a messag informing user the
current file it's working on, then we open the file, then search-forward
to move the cursor to the navbar string location, delete it, then insert
the new navbar string, then we use search-bacward to search for the
current file's name. The current file's name is generated by calling
=(file-name-nondirectory buffer-file-name)=. Once the cursor is at the
location of current file in the navbar string, we call
=sgml-delete-tag=, which will delete both the opening and closing HTML
tags the cursor is on. The =sgml-delete-tag= is defined in =html-mode=.

If we want to, we can add a =(save-buffer)= and =(kill-buffer)= to save
and close the file, but for now i decided to leave the processed files
open because sometimes i'm in the middle of editing them. It is easy to
save and close a bunch of files using =ibuffer=.

So, now with this function, suppose i created a new page =projB-5.html=.
All i have to do is to list all the relevant files in the current
buffer. This is easily done in emacs by Ctrl+u Alt+x =shell-command=,
then type =ls projB*html=. Then, emacs will insert to the current buffer
this text:

#+BEGIN_SRC emacs-lisp
    projB.html
    projB-2.html
    projB-3.html
    projB-4.html
    projB-5.html
#+END_SRC

Then, i select them, then Alt+x =xah-update-page-tag=, then all the
pages will be updated for me.

Note that my file names are not necessarily regular like {‚Äú1.html‚Äù,
‚Äú2.html‚Äù, ‚Äú3.html‚Äù, ...}. Otherwise, our function doesn't need to take a
list of file names from the region. It can just take one name and
generate all others.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_update_pagetag.html]]

\\
\\
| [[../index_u13.html#article_23][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u17.html>>

| [[../article_25/index_u37.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_24][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_23/index_u18.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Insert Random Number/Hex/String
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-27. Last updated: 2018-08-03.

This page shows emacs lisp commands to insert random {number, string,
hexadecimal}.

First, in your emacs init file, you should change the random seed, like
this:

#+BEGIN_SRC emacs-lisp
    (random t) ; seed random number
#+END_SRC

Else, every emacs restart, the sequence of random will be the same.

** Insert Random Number
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-number (NUM)
      "Insert NUM random digits.
    NUM default to 5.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2017-05-24"
      (interactive "P")
      (let (($charset "1234567890" )
            ($baseCount 10))
        (dotimes (_ (if (numberp NUM) (abs NUM) 5 ))
          (insert (elt $charset (random $baseCount))))))
#+END_SRC

** Insert Random Hexadecimal
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-hex (NUM)
      "Insert NUM random hexadecimal digits.
    NUM default to 5.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2017-08-03"
      (interactive "P")
      (let (($n (if (numberp NUM) (abs NUM) 5 )))
        (insert (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n)))))))
#+END_SRC

** Insert Random String
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-string (NUM)
      "Insert a random alphanumerics string of length 5.
    The possible chars are: A to Z, a to z, 0 to 9.
    Call `universal-argument' before for different count.
    URL `http://ergoemacs.org/emacs/elisp_insert_random_number_string.html'
    Version 2018-08-03"
      (interactive "P")
      (let* (($charset "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
             ($baseCount (length $charset)))
        (dotimes (_ (if (numberp NUM) (abs NUM) 5))
          (insert (elt $charset (random $baseCount))))))
#+END_SRC

** Insert Random UUID
   :PROPERTIES:
   :CLASS: calibre17
   :END:

[[file:elisp_generate_uuid.html][Elisp: Insert Random UUID]]

O emacs! ‚ô•

2010 Thanks to Teemu Likonen [tliko...@iki.fi] for improvement.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_insert_random_number_string.html]]

\\
\\
| [[../index_u13.html#article_24][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u37.html>>

| [[../article_26/index_u19.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_25][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_24/index_u17.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Insert Random UUID
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-11-07. Last updated: 2020-06-04.

Here's a emacs command to insert a UUID.

#+BEGIN_SRC emacs-lisp
    (defun xah-insert-random-uuid ()
      "Insert a UUID.
    This commands calls ‚Äúuuidgen‚Äù on MacOS, Linux, and calls PowelShell on Microsoft Windows.
    URL `http://ergoemacs.org/emacs/elisp_generate_uuid.html'
    Version 2020-06-04"
      (interactive)
      (cond
       ((string-equal system-type "windows-nt")
        (shell-command "pwsh.exe -Command [guid]::NewGuid().toString()" t))
       ((string-equal system-type "darwin") ; Mac
        (shell-command "uuidgen" t))
       ((string-equal system-type "gnu/linux")
        (shell-command "uuidgen" t))
       (t
        ;; code here by Christopher Wellons, 2011-11-18.
        ;; and editted Hideki Saito further to generate all valid variants for "N" in xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx format.
        (let ((myStr (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                                  (user-uid)
                                  (emacs-pid)
                                  (system-name)
                                  (user-full-name)
                                  (current-time)
                                  (emacs-uptime)
                                  (garbage-collect)
                                  (buffer-string)
                                  (random)
                                  (recent-keys)))))
          (insert (format "%s-%s-4%s-%s%s-%s"
                          (substring myStr 0 8)
                          (substring myStr 8 12)
                          (substring myStr 13 16)
                          (format "%x" (+ 8 (random 4)))
                          (substring myStr 17 20)
                          (substring myStr 20 32)))))))
#+END_SRC

Thanks to Christopher Wellons [[[http://nullprogram.com/]]] , Hideki
Saito [[http://hideki.hclippr.com/2014/02/02/on-generating-uuid/]] . And
[Yuri Khan +https://plus.google.com/+YuriKhan/posts+], Jon Snader
[[http://irreal.org/blog/]] for discussion about UUID.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_generate_uuid.html]]

\\
\\
| [[../index_u13.html#article_25][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u19.html>>

| [[../article_27/index_u35.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_26][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_25/index_u37.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Write grep
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-07. Last updated: 2019-01-16.

This page shows you how to write a emacs lisp script to search files,
similar to unix grep.

Here's a very simple version. It reports number of matches.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; print file names of files that have n occurrences of a string, of a given dir
    ;; version 2019-01-13

    ;; input dir
    ;; In elisp, dir path should end with a slash
    (setq inputDir "/Users/xah/web/ergoemacs_org/" )

    (setq findStr "stuff")

    (defun my-process-file (fPath)
      "Process the file at FPATH "
      (let (myBuffer p1 p2 (ii 0) searchStr)
        (when (and (not (string-match "/xx" fPath))) ; exclude some dir

          (with-temp-buffer
            (insert-file-contents fPath nil nil nil t)

            (setq searchStr findStr  )

            (goto-char 1)
            (while (search-forward searchStr nil t)
              (setq ii (1+ ii)))

            ;; report if the occurrence is not n times
            (when (not (= ii 0))
              (princ (format "%d %s\n" ii fPath)))))))

    ;; walk the dir
    (let (outputBuffer)
      (setq outputBuffer "*my find output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\.html$" ))
        (princ "Done")))
#+END_SRC

At the bottom, the code visits every file in a dir. For each file, it
calls =my-process-file= . That function creates a temp buffer, inserts
the file content in it, then do search inside the temp buffer. We use a
temp buffer because it's faster. [see
[[file:elisp_find-file_vs_with-temp-buffer.html][Emacs Lisp Text
Processing: find-file vs with-temp-buffer]]]

To run the file, just Alt+x =eval-buffer=. [see
[[file:elisp_eval_lisp_code.html][Evaluate Emacs Lisp Code]]]

On 9838 html files, the script takes 40 seconds on a ‚ÄúLate 2014‚Äù Mac
Mini computer, when files are not cached, on a spinning harddisk.

When running a second time, it just take 6 seconds.

*** What's wrong with unix grep command?
    :PROPERTIES:
    :CLASS: calibre14
    :END:

See: [[file:emacs_grep_problem.html][Problems of Calling Unix grep in
Emacs]].

*** Emacs Package: xah-find.el
    :PROPERTIES:
    :CLASS: calibre14
    :END:

For the full featured version of this command, see the package
[[file:elisp-xah-find-text.html][Emacs: xah-find.el, Find Replace in
Pure Elisp]].

**** Find Replace Scripts
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[http://xahlee.info/golang/goland_find_string.html][Golang: Find
  String (grep)]]
- [[http://xahlee.info/golang/goland_find_replace.html][Golang: Find
  Replace Script]]
- [[http://xahlee.info/python/find_replace_dir.html][Python: Find
  Replace in a Dir]]
- [[http://xahlee.info/python/findreplace_regex.html][Python: Find
  Replace by Regex]]
- [[http://xahlee.info/perl/perl_find_replace_in_dir.html][Perl: Find
  Replace String Pairs in Directory]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_26/elisp_grep_script.xhtml][Elisp:
  Write grep]]
- [[http://ergoemacs.org/emacs/elisp-xah-find-text.html][Emacs:
  xah-find.el, Find Replace in Pure Elisp]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_grep_script.html]]

\\
\\
| [[../index_u13.html#article_26][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u35.html>>

| [[../article_28/index_u28.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_27][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_26/index_u19.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Find String Inside HTML Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-02-27. Last updated: 2019-01-16.

This page shows a emacs lisp script that search files, similar to unix
grep, but with the condition that the string must happen inside a
specific HTML tag.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I need to list all files that contains a given string, and only if the
string is inside a given HTML tag. That is, the condition that some
strig must happen before and after the string we want.

This is something grep and linux shell commands cannot do easily, and
difficult to do even with Perl, Python, unless you use a HTML parser
(which gets complex).

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-02-25, 2019-01-13
    ;; print files that meet this condition:
    ;; contains <div class="xnote">‚Ä¶</div>
    ;; where the text content contains more than one bullet char ‚Ä¢

    (setq inputDir "/Users/xah/web/wordyenglish_com/arabian_nights/" ) ; dir should end with a slash

    ;; need sgml-skip-tag-forward
    (require 'sgml-mode)

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (myBuffer
            p3 p4  (bulletCount 0) )

        ;; (print fPath)

        (when
            (and (not (string-match "/xx" fPath))) ; skip some dir

          (setq myBuffer (get-buffer-create " myTemp"))
          (set-buffer myBuffer)
          (insert-file-contents fPath nil nil nil t)

          (setq bulletCount 0 )
          (goto-char 1)
          (while
              (search-forward "<div class=\"xnote\">"  nil t)

            (setq p3 (point)) ; beginning of innerText, after <div class="xnote">
            (backward-char)
            (sgml-skip-tag-forward 1)
            (backward-char 6)
            (setq p4 (point)) ; end of innerText, before </div>

            (setq bulletCount (count-matches "‚Ä¢" p3 p4))

            (when (> bulletCount 1)
              (princ (format "Found: %d %s\n" bulletCount fPath))))

          (kill-buffer myBuffer))))

    (let (outputBuffer)
      (setq outputBuffer "*my output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\.html$" ))
        (princ "Done")))
#+END_SRC

** Find Replace Applications
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Find, or Find Replace, has extensive use in text processing. Here's some
examples of variations, all of which i need on weekly basis and have
several elisp scripts to do the job:

- List file that contains a string.
- Show adjacent text around a string.
- List a file only if it contains more than 1 occurence of a string. (or
  more than n, less than n, exactly n.)
- List file if it contains a given set of strings.
- Replace text based on file's name.
- List file only if its HTML title and heading doesn't match.
- Find/Report/Replace only if the string is at a particular position in
  the file. (For example, near top, near bottom.)
- List a file only if the string is inside a tag.

** Why I Wrote This Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's a little story on why i wrote this one.

I have about 30 classic literature with annotations. For example:
[[http://wordyenglish.com/arabian_nights/index.html][The Arabian
Nights]].

Each annotation are in the tag =<div class="xnote">‚Ä¶</div>=. e.g.

#+BEGIN_SRC emacs-lisp
    <div class="xnote">‚Ä¢ provaunt ‚áí provide. Provant is a verb meaning: To supply with provender or provisions.</div>
#+END_SRC

However, some ‚Äúxnote‚Äù block is multiple annotations in one. e.g.

#+BEGIN_SRC emacs-lisp
    <div class="xnote">‚Ä¢ stint ‚áí a fixed amount or share work.
    ‚Ä¢ might and main ‚áí with all effort and strength.
    ‚Ä¢ skein ‚áí A quantity of yarn, thread, or the like, put up together, after it is taken from the reel.
    ‚Ä¢ buffet ‚áí hit, beat, especially repeatedly.
    ‚Ä¢ fain ‚áí with joy; satisfied; contented.
    </div>
#+END_SRC

Each of the annotation are marked by a bullet ‚Äú‚Ä¢‚Äù symbol, followed by a
word. Each word corresponds to the same word in the main text marked by
=<span class="xnt">‚Ä¶</span>=.

This annotation system is not perfect. It is static HTML/CSS. Recently
i've been thinking of making it more dynamic based on JavaScript. With
JavaScript, it's possible to have features such as hide/show annotation
when mouse over the the word.

[see [[http://xahlee.info/js/js.html][JavaScript in Depth]]]

To make that possible, i need to make sure of few things:

- ‚ë† My custom markup must have precise semantics.
- ‚ë° The syntax should be as simple as possible. (else the JavaScript
  will have to do more work.)
- ‚ë¢ The HTML annotation markup must follow strict form. (else JavaScript
  will fail silently)

With my current system, a annotation block is contained in a ‚Äúxnote‚Äù
tag, and within that block, each annotation is marked by a bullet. This
semantic is precise, but isn't simple enough. If i want JavaScript to
automatically highlight the annotation text when user mouse-over a
annotated word, the js will have to do some parsing of text in the
‚Äúxnote‚Äù block.

It would be simpler, if each ‚Äúxnote‚Äù block contains just ONE annotation.
This means, i will first change all my files that contain
multi-annotation blocks to make them 1-annotation per xnote block. This
is a text processing job. (Hello emacs lisp!)

Before doing text transformation on the xnote blocks, first i need to
make sure the text has correct syntax. For example: make sure that each
‚Äúxnote‚Äù do indeed contain at least one bullet symbol, and make sure that
each =<span class="xnt">‚Ä¶</span>= has a corresponding
=<div class="xnote">‚Ä¶</div>=.

So, that's why i wrote this script. I wanted to get some idea of how
many ‚Äúxnote‚Äù blocks in which files actually contain multi-annotations.

The elisp code to split xnote block to multiple is very similar to the
elisp code here.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_grep_string_inside_tag.html]]

\\
\\
| [[../index_u13.html#article_27][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u28.html>>

| [[../article_29/index.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_28][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_27/index_u35.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Check Parenthesis/Brackets Balance
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2017-08-06. Last updated: 2018-07-03.

Here's a command to check if parentheses or brackets or curly quotes are
balanced.

#+BEGIN_SRC emacs-lisp
    (defun xah-check-parens-balance ()
      "Check if there are unbalanced parentheses/brackets/quotes in current bufffer or selection.
    If so, place cursor there, print error to message buffer.

    URL `http://ergoemacs.org/emacs/emacs_check_parens_balance.html'
    Version 2018-07-03"
      (interactive)
      (let* (
             ($bracket-alist
              '( (?‚Äú . ?‚Äù) (?‚Äπ . ?‚Ä∫) (?¬´ . ?¬ª) (?„Äê . ?„Äë) (?„Äñ . ?„Äó) (?„Äà . ?„Äâ) (?„Ää . ?„Äã) (?„Äå . ?„Äç) (?„Äé . ?„Äè) (?{ . ?}) (?\[ . ?\]) (?\( . ?\))))
             ;; regex string of all pairs to search.
             ($bregex
              (let (($tempList nil))
                (mapc
                 (lambda (x)
                   (push (char-to-string (car x)) $tempList)
                   (push (char-to-string (cdr x)) $tempList))
                 $bracket-alist)
                (regexp-opt $tempList )))
             $p1
             $p2
             ;; each entry is a vector [char position]
             ($stack '())
             ($char nil)
             $pos
             $is-closing-char-p
             $matched-open-char
             )
        (if (region-active-p)
            (setq $p1 (region-beginning) $p2 (region-end))
          (setq $p1 (point-min) $p2 (point-max)))

        (save-excursion
          (save-restriction
            (narrow-to-region $p1 $p2)
            (progn
              (goto-char 1)
              (while (re-search-forward $bregex nil "move")
                (setq $pos (point))
                (setq $char (char-before))
                (progn
                  (setq $is-closing-char-p (rassoc $char $bracket-alist))
                  (if $is-closing-char-p
                      (progn
                        (setq $matched-open-char
                              (if $is-closing-char-p
                                  (car $is-closing-char-p)
                                (error "logic error 64823. The char %s has no matching pair."
                                       (char-to-string $char))))
                        (if $stack
                            (if (eq (aref (car $stack) 0) $matched-open-char )
                                (pop $stack)
                              (push (vector $char $pos) $stack ))
                          (progn
                            (goto-char $pos)
                            (error "First mismtach found. the char %s has no matching pair."
                                   (char-to-string $char)))))
                    (push (vector $char $pos) $stack ))))
              (if $stack
                  (progn
                    (goto-char (aref (car $stack) 1))
                    (message "Mismtach found. The char %s has no matching pair." $stack))
                (print "All brackets/quotes match.")))))))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_check_parens_balance.html]]

\\
\\
| [[../index_u13.html#article_28][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index.html>>

| [[../article_30/index_u23.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_29][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_28/index_u28.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Batch Script to Validate Matching Brackets
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-19. Last updated: 2020-04-12.

This page shows you how to write a elisp script that checks thousands of
files for mismatched brackets.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a emacs lisp script to process 5 thousands files and check for
mismatched brackets.

The matching pairs includes these: () {} [] ‚Äú‚Äù ‚Äπ‚Ä∫ ¬´¬ª „Äà„Äâ „Ää„Äã „Äê„Äë „Äñ„Äó
„Äå„Äç „Äé„Äè. [see
[[http://xahlee.info/comp/unicode_matching_brackets.html][Unicode:
Brackets, Quotes ¬´¬ª„Äå„Äç„Äê„Äë„Ää„Äã]]]

The program should be able to check all files in a dir, and report any
file that has mismatched bracket, and also indicate the line number or
position where a mismatch occurs.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; 2011-07-15 , 2020-04-12
    ;; spec at http://xahlee.org/comp/validate_matching_brackets.html
    ;; by Xah Lee.

    ;; go thru a file, check if all brackets are properly matched.
    ;; e.g. good: (‚Ä¶{‚Ä¶}‚Ä¶ ‚Äú‚Ä¶‚Äù‚Ä¶)
    ;; bad: ( [)]
    ;; bad: ( ( )

    (setq inputFile "xx_test_file.txt" ) ; a test file.
    (setq inputDir "/Users/xah/web/ergoemacs_org/emacs/") ; must end in slash

    (defvar matchPairs '() "a alist. For each pair, the car is opening char, cdr is closing char.")
    (setq matchPairs '(
                       ;; ("(" . ")")
                       ;; ("{" . "}")
                       ;; ("[" . "]")
                       ;; ("‚Äú" . "‚Äù")
                       ;; ("‚Äπ" . "‚Ä∫")
                       ;; ("¬´" . "¬ª")
                       ("„Äê" . "„Äë")
                       ;; ("„Äñ" . "„Äó")
                       ;; ("„Äà" . "„Äâ")
                       ;; ("„Ää" . "„Äã")
                       ;; ("„Äå" . "„Äç")
                       ;; ("„Äé" . "„Äè")
                       )
          )

    (defvar searchRegex "" "regex string of all pairs to search.")
    (setq searchRegex "")
    (mapc
     (lambda (mypair) ""
       (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
       )
     matchPairs)

    (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending ‚Äú|‚Äù

    (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t)) ; change | to \\| for regex ‚Äúor‚Äù operation

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (myBuffer myStack $char $pos)

        (setq myStack '()) ; each entry is a vector [char position]
        (setq $char "")     ; the current char found

        (when t
          ;; (not (string-match "/xx" fPath)) ; in case you want to skip certain files

          (setq myBuffer (get-buffer-create " myTemp"))
          (set-buffer myBuffer)
          (insert-file-contents fPath nil nil nil t)

          (goto-char 1)
          (while (re-search-forward searchRegex nil t)
            (setq $pos (point))
            (setq $char (buffer-substring-no-properties $pos (- $pos 1)))

            ;; (princ (format "-----------------------------\nfound char: %s\n" $char) )

            (let ((isClosingCharQ nil) (matchedOpeningChar nil))
              (setq isClosingCharQ (rassoc $char matchPairs))
              (when isClosingCharQ (setq matchedOpeningChar (car isClosingCharQ)))

              ;; (princ (format "isClosingCharQ is: %s\n" isClosingCharQ) )
              ;; (princ (format "matchedOpeningChar is: %s\n" matchedOpeningChar) )

              (if
                  (and
                   (car myStack) ; not empty
                   (equal (elt (car myStack) 0) matchedOpeningChar ))
                  (progn
                    ;; (princ (format "matched this top item on stack: %s\n" (car myStack)) )
                    (setq myStack (cdr myStack)))
                (progn
                  ;; (princ (format "did not match this top item on stack: %s\n" (car myStack)) )
                  (setq myStack (cons (vector $char $pos) myStack)))))
            ;; (princ "current stack: " )
            ;; (princ myStack )
            ;; (terpri )
            )

          (when (not (equal myStack nil))
            (princ "Error file: ")
            (princ fPath)
            (print (car myStack)))
          (kill-buffer myBuffer))))

    (let (outputBuffer)
      (setq outputBuffer "*xah match pair output*" )
      (with-output-to-temp-buffer outputBuffer
        ;; (my-process-file inputFile) ; use this to test one one single file
        (mapc 'my-process-file
              (directory-files-recursively inputDir "\\.html$" )) ; do all HTML files
        (princ "Done deal!")))
#+END_SRC

I added many comments and debug code for easy understanding. If you are
not familiar with the many elisp idioms such as opening file, buffers,
printing to output, see: [[file:elisp_idioms.html][Elisp: How to Write
Commands]] ‚Ä¢ [[file:elisp_idioms_batch.html][Text Processing with Emacs
Lisp Batch Style]].

To run the code, simply open it in emacs. Edit the line at the top for
‚ÄúinputDir‚Äù. Then call =eval-buffer=.

Here's a sample output:

#+BEGIN_SRC emacs-lisp
    Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter_orig.txt
    [")" 3625]
    Error file: c:/Users/h3/web/xahlee_org/p/time_machine/Hettie_Potter.txt
    [")" 2338]
    Error file: c:/Users/h3/web/xahlee_org/p/arabian_nights/xx/v1fn.txt
    ["‚Äù" 185795]
    Done deal!
#+END_SRC

** Code Explanation
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

- Go thru the file char-by-char, find a bracket char.
- Check if the one on stack is a matching opening char. If so remove it.
  Else, push the current onto the stack. (think of stack as stack of
  books. You put one on top (called =push=), and take one out from top
  too (called =pop=).)
- Repeat the above till no more bracket char in the file.
- If the stack is not empty, then the file got mismatched brackets.
  Report it.
- Do the above on all files.

Here's some interesting use of lisp features to implement the above.

*** Define Matching Pair Chars as ‚Äúalist‚Äù
    :PROPERTIES:
    :CLASS: calibre14
    :END:

We begin by defining the chars we want to check, as a ‚Äúassociation
list‚Äù. Like this:

#+BEGIN_SRC emacs-lisp
    (setq matchPairs '(
                       ("(" . ")")
                       ("{" . "}")
                       ("[" . "]")
                       ("‚Äú" . "‚Äù")
                       ("‚Äπ" . "‚Ä∫")
                       ("¬´" . "¬ª")
                       ("„Äê" . "„Äë")
                       ("„Äñ" . "„Äó")
                       ("„Äà" . "„Äâ")
                       ("„Ää" . "„Äã")
                       ("„Äå" . "„Äç")
                       ("„Äé" . "„Äè")
                       )
          )
#+END_SRC

[see [[file:elisp_association_list.html][Elisp: Association List]]]

If you care only to check for curly quotes, you can remove elements
above. This is convenient because some files necessarily have mismatched
pairs such as the parenthesis, because that char is used for many
non-bracketing purposes (For example, ASCII smiley).

*** Generate Regex String from alist
    :PROPERTIES:
    :CLASS: calibre14
    :END:

To search for a set of chars in emacs, we can read the buffer
char-by-char, or, we can simply use =search-forward-regexp=. To use
that, first we need to generate a regex string from our matchPairs
alist. For example, if we want to search ‚Äú„Äà„Äâ„Ää„Äã‚Äù, then our regex
string should be ="„Äà\\|„Äâ\\|„Ää\\|„Äã"=.

First, we define/declare the string. Not a necessary step, but we do it
for clarity.

#+BEGIN_SRC emacs-lisp
    (setq searchRegex "")
#+END_SRC

Then we go thru the matchPairs alist. For each pair, we use =car= and
=cdr= to get the chars and =concat= it to the string. Like this:

#+BEGIN_SRC emacs-lisp
    (mapc
     (lambda (mypair) ""
       (setq searchRegex (concat searchRegex (regexp-quote (car mypair)) "|" (regexp-quote (cdr mypair)) "|") )
       )
     matchPairs)
#+END_SRC

Then we remove the ending =|=.

#+BEGIN_SRC emacs-lisp
    (setq searchRegex (substring searchRegex 0 -1)) ; remove the ending ‚Äú|‚Äù
#+END_SRC

Then, change =|= to =\\|=. In elisp regex, the =|= is literal. The
‚Äúregex or‚Äù is =\|=. Elisp does not have a special regex string syntax,
it only understands normal strings. So, to feed to regex =\|=, you need
to espace the first backslash. So, the string for regex needs to be
=\\|=. Here's how we do it:

#+BEGIN_SRC emacs-lisp
    (setq searchRegex (replace-regexp-in-string "|" "\\|" searchRegex t t)) ; change | to \\| for regex ‚Äúor‚Äù operation
#+END_SRC

See also: [[file:emacs_regex.html][emacs regex tutorial]].

*** Implement Stack Using Lisp List
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Stack is done using lisp's list. For example: ='(1 2 3)=. The top of
stack is the first element. To add to the stack, do it like this:
=(setq mystack (cons newitem mystack))=. To remove a item from stack is
this: =(setq mystack (cdr mystack))=. The stack start as a empty list:
='()=.

For each entry in the stack, we put the char and also its position, so
that we can report the position if the file does have mismatched pairs.

We use a vector as entries for the stack. Each entry is like this:
=(vector char pos)=. [see [[file:elisp_vector.html][Elisp: Vector]]]

Here's how to fetch a char from alist, and push to stack, pop from
stack.

#+BEGIN_SRC emacs-lisp
    ; check if current char is a closing char and is in our match pairs alist.
    ; use ‚Äúrassoc‚Äù to check alist's set of ‚Äúvalues‚Äù.
    ; It returns the first key/value pair found, or nil
    (rassoc char matchPairs)

    ; add to stack
    (setq myStack (cons (vector char pos) myStack) )

    ; pop stack
    (setq myStack (cdr myStack) )
#+END_SRC

*** Advantages of Emacs Lisp
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Note that the great advantage of using elisp for text processing,
instead of {Perl, Python, Ruby, ...} is that many things are taken care
by the emacs environment.

I don't need to write code to deal with file encoding (emacs
automatically does it). No reading file is involved. Just ‚Äúopen‚Äù or
‚Äúsave‚Äù the file. Processing a file is simply moving cursor thru
characters or lines, changing parts of it. No code needed for doing
safety backup. Emacs automatically does backup if you made any changes,
and can be turned off by setting the built-in var ‚Äúmake-backup-files‚Äù to
nil. For file paths in the output, you can easily open it by a click or
key press. I can add just 2 lines so that clicking on the error char in
the output jumps to the location in the file.

Any elisp script you write inside emacs automatically becomes a
extension of emacs and can be used in a interactive way. Or, you could
run it in a command line shell, for example,
=emacs --script process_log.el=.

This problem is posted to a few comp.lang newsgroups as a fun challenge.
See:
[[http://xahlee.info/comp/validate_matching_brackets.html][Programing
Exercise, Validate Matching Brackets]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_validate_matching_brackets.html]]

\\
\\
| [[../index_u13.html#article_29][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u23.html>>

| [[../article_31/index_u6.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_30][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_29/index.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Generate Web Links Report
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-01-30. Last updated: 2019-06-11.

Here's how to use elisp to process files in a directory, searching for a
text pattern, and generate a report.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You have 7 thousand HTML files. You want to generate a report that lists
all links to Wikipedia, and the file path the link is from.

In this tutorial, you'll learn:

- how to walk a directory. [see [[file:elisp_traverse_dir.html][Elisp:
  Walk Directory]]]
- how to build a hash-table. [see [[file:elisp_hash_table.html][Elisp:
  Hash Table]]]
- elisp idiom for fast opening large number of files.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here are the basic steps we need:

- Given a file, extract links and put them into a hash table.
- Use elisp to traverse a given directory, open each file.
- Some pretty printing functions. For example, convert a URL string into
  HTML link string.

Once we have the data in a hash-table, it is very flexible. We can then
generate a report in plain text or HTML, or do other processing.

*** Hash Table
    :PROPERTIES:
    :CLASS: calibre14
    :END:

First, we'll need to know how to use hash table in emacs. Here's a
simple example:

#+BEGIN_SRC emacs-lisp
    ;; create a hash table
    (setq myhash (make-hash-table :test 'equal))

    ;; add entries
    (puthash "Joe" "19" myhash)
    (puthash "Jane" "20" myhash)
    (puthash "Liz" "21" myhash)

    ;; add/modify
    (puthash "Jane" "16" myhash)

    ;; get or check existence
    (setq val (gethash "Jane" myhash))

    (message val) ; print it
#+END_SRC

[see [[file:elisp_hash_table.html][Elisp: Hash Table]]]

*** Process a Single File
    :PROPERTIES:
    :CLASS: calibre14
    :END:

we want the hash table key to be the full URL string, and the value a
list. Each element in the list is the full path of the file that
contains the link.

Here is the code that processes a single file. It opens the file, search
for URL, if found, check if it exist in hash, if not, add it, else
append to the existing entry.

#+BEGIN_SRC emacs-lisp
    (setq myfile "/Users/xah/web/ergoemacs_org/emacs/GNU_Emacs_dev_inefficiency.html")

    (setq myhash (make-hash-table :test 'equal))

    (defun ff ()
      "test code to process a single file"
      (interactive)
      (let ( myBuff url)

        (setq myBuff (find-file myfile)) ; open file

        (goto-char (point-min))

        ;; search for URL till not found
        (while
            (re-search-forward
             "href=\"\\(https://..\\.wikipedia\\.org/[^\"]+\\)\">\\([^<]+\\)</a>"
             nil t)

          (when (match-string 0)        ; if URL found
            (setq url (match-string 1)) ; set the url to matched string

            (print url)

            ;; if exist in hash, prepend to existing entry, else just add
            (if (gethash url myhash)
                (puthash url (cons myfile (gethash url myhash)) myhash)
              (puthash url (list myfile) myhash))))

        (kill-buffer myBuff) ; close file
        ))

    (ff)

    (print myhash)
#+END_SRC

*** Walk a Directory
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    (mapc
     'ff
     (directory-files-recursively "~/web/ergoemacs_org/" "\.html$" ))
#+END_SRC

[[file:elisp_traverse_dir.html][Elisp: Walk Directory]]

*** Pretty Print Helpers
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Given a Wikipedia URL, returns a HTML link string.

For example:

=http://en.wikipedia.org/wiki/Emacs=

becomes

=<a href="http://en.wikipedia.org/wiki/Emacs">Emacs</a>=

#+BEGIN_SRC emacs-lisp
    (require 'gnus-util) ; for gnus-url-unhex-string

    (defun wikipedia-url-to-link (url)
      "Return the URL as HTML link string.
    Example:
     http://en.wikipedia.org/wiki/Emacs%20Lisp
    becomes
     <a href=\"http://en.wikipedia.org/wiki/Emacs%20Lisp\">Emacs Lisp</a>
    "
      (let ((linkText url))
        (setq linkText (gnus-url-unhex-string linkText nil)) ; decode percent encoding. For example: %20
        (setq linkText (car (last (split-string linkText "/")))  ) ; get last part
        (setq linkText (replace-regexp-in-string "_" " " linkText )  ) ; low line ‚Üí space
        (format "<a href=\"%s\">%s</a>" url linkText)
        ))
#+END_SRC

Given a file path, return a link string.

For example:

=/Users/xah/web/ergoemacs_org/index.html=

becomes

=<a href="../index.html">ErgoEmacs</a>=

, where the link text came from the file's ‚Äútitle‚Äù tag.

#+BEGIN_SRC emacs-lisp
    (defun get-html-file-title (fName)
      "Return FNAME <title> tag's text.
    Assumes that the file contains the string
    ‚Äú<title>‚Ä¶</title>‚Äù."
      (with-temp-buffer
          (insert-file-contents fName nil nil nil t)
          (goto-char 1)
          (buffer-substring-no-properties
           (search-forward "<title>") (- (search-forward "</title>") 8))
          ))
#+END_SRC

** Putting It All Together
   :PROPERTIES:
   :CLASS: calibre17
   :END:

#+BEGIN_SRC emacs-lisp
     ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; emacs lisp.

    ;; started: 2008-01-03.
    ;; version: 2019-06-11
    ;; author: Xah Lee
    ;; url: http://ergoemacs.org/emacs/elisp_link_report.html
    ;; purpose: generate a report of wikipedia links.

    ;; traverse a given dir, visiting every html file, find links to Wikipedia in those files, collect them, and generate a html report of these links and the files they are from, then write it to a given file. (overwrite if exist)

    &#12;

    (setq InputDir "/Users/xah/web/ergoemacs_org/" )

    ;; Overwrites existing
    (setq OutputPath "/Users/xah/web/xahlee_org/wikipedia_links.html")

    &#12;

    ;; add a ending slash to InputDir if not there
    (when (not (string= "/" (substring InputDir -1) )) (setq InputDir (concat InputDir "/") ) )

    (when (not (file-exists-p InputDir)) (error "input dir does not exist: %s" InputDir))

    (setq XahHeaderText
    "<!doctype html><html><head><meta charset=\"utf-8\" />
    <title>Links to Wikipedia from Xah Sites</title>
    </head>
    <body>

    <nav class=\"n1\"><a href=\"index.html\">XahLee.org</a></nav>
    ")

    (setq XahFooterText
      "
    </body></html>
    "
    )

    &#12;

    ;; hash table. key is string Wikipedia url, value is a list of file paths.
    (setq LinksHash (make-hash-table :test 'equal :size 8000))

    &#12;

    (defun xah-add-link-to-hash (filePath hashTableVar)
      "Get links in filePath and add it to hash table at the variable hashTableVar."
      (let ( $wUrl)
        (with-temp-buffer
          (insert-file-contents filePath nil nil nil t)
          (goto-char 1)
          (while
              (re-search-forward
               "href=\"\\(https://..\\.wikipedia\\.org/[^\"]+\\)\">\\([^<]+\\)</a>"
               nil t)
            (setq $wUrl (match-string 1))
            (when (and
                   $wUrl ; if url found
                   (not (string-match "=" $wUrl )) ; do not includes links that are not Wikipedia articles. e.g. user profile pages, edit history pages, search result pages
                   (not (string-match "%..%.." $wUrl )) ; do not include links that's lots of unicode
                   )

              ;; if exist in hash, prepend to existing entry, else just add
              (if (gethash $wUrl hashTableVar)
                  (puthash $wUrl (cons filePath (gethash $wUrl hashTableVar)) hashTableVar) ; not using add-to-list because each Wikipedia URL likely only appear once per file
                (puthash $wUrl (list filePath) hashTableVar)) )) ) ) )

    (defun xah-print-each (ele)
      "Print each item. ELE is of the form (url (list filepath1 filepath2 ‚Ä¶)).
    Print it like this:
    ‚Äπlink to url‚Ä∫ : ‚Äπlink to file1‚Ä∫, ‚Äπlink to file2‚Ä∫, ‚Ä¶"
      (let ($wplink $files)
        (setq $wplink (car ele))
        (setq $files (cadr ele))

        (insert "<li>")
        (insert (wikipedia-url-to-linktext $wplink))
        (insert "‚Äî")

        (dolist (xx $files nil)
          (insert
           (format "<a href=\"%s\">%s</a>‚Ä¢"
                   (xahsite-filepath-to-href-value xx OutputPath )
                   (xah-html-get-html-file-title xx))))
        (delete-char -1)
        (insert "</li>\n"))
      )

    &#12;

    (defun wikipedia-url-to-linktext (@url)
      "Return the title of a Wikipedia link.
    Example:
    http://en.wikipedia.org/wiki/Emacs
    becomes
    Emacs"
      (require 'url-util)
      (decode-coding-string
       (url-unhex-string
        (replace-regexp-in-string
         "_" " "
         (replace-regexp-in-string
          "&" "ÔºÜ"
          (car
           (last
            (split-string
             @url "/")))))) 'utf-8))

    (defun wikipedia-url-to-link (@url)
      "Return the @url as html link string.\n
    Example:
    http://en.wikipedia.org/wiki/Emacs
    becomes
    <a href=\"http://en.wikipedia.org/wiki/Emacs\">Emacs</a>"
      (format "<a href=\"%s\">%s</a>" @url (wikipedia-url-to-linktext @url)))

    (defun xah-hash-to-list (@hash-table)
      "Return a list that represent the @HASH-TABLE
    Each element is a list: '(key value).

    http://ergoemacs.org/emacs/elisp_hash_table.html
    Version 2019-06-11"
      (let ($result)
        (maphash
         (lambda (k v)
           (push (list k v) $result))
         @hash-table)
        $result))

    &#12;
    ;;;; main

    ;; fill LinksHash
    (mapc
       (lambda ($x) (xah-add-link-to-hash $x LinksHash ))
       (directory-files-recursively InputDir  "\.html$" ))

    ;; fill LinksList
    (setq LinksList
          (sort (xah-hash-to-list LinksHash)
                ;; (hash-table-keys LinksHash)
                (lambda (a b) (string< (downcase (car a)) (downcase (car b))))))

    ;; write to file
    (with-temp-file OutputPath
      (insert XahHeaderText)
      (goto-char (point-max))

      (insert
       "<h1>Links To Wikipedia from XahLee.org</h1>\n\n"
       "<p>This page contains all existing links from xah sites to Wikipedia, as of ")

      (insert (format-time-string "%Y-%m-%d"))

      (insert
       ". There are a total of " (number-to-string (length LinksList)) " links.</p>\n\n"
       "<p>This file is automatically generated by a <a href=\"http://ergoemacs.org/emacs/elisp_link_report.html\">emacs lisp script</a>.</p>

    "
       )

      (insert "<ol>\n")

      (mapc 'xah-print-each LinksList)

      (insert "</ol>

    ")

      (insert XahFooterText)
      (goto-char (point-max)))

    ;; clear memory
    ;; (clrhash LinksHash)
    ;; (setq LinksList nil)

    ;; open the file
    (find-file OutputPath )
#+END_SRC

Emacs ‚ô•

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_link_report.html]]

\\
\\
| [[../index_u13.html#article_30][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u6.html>>

| [[../article_32/index_u3.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_31][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_30/index_u23.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Create Sitemap
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-07-30. Last updated: 2019-06-11.

This page shows how to use emacs lisp to create a sitemap.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Write a elisp script to generate a sitemap. That is: create a file of
sitemap format that lists all files in a directory.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

A sitemap is a XML file that lists URLs of all files in a website for
web crawlers to crawl.

A sitemap file looks like this:

#+BEGIN_SRC emacs-lisp
    <?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

       <url>
          <loc>http://www.example.com/</loc>
          <lastmod>2005-01-01</lastmod>
          <changefreq>monthly</changefreq>
          <priority>0.8</priority>
       </url>

       ‚Ä¶

    </urlset>
#+END_SRC

1. The file can have many =<url>‚Ä¶</url>= item.
2. Each =<url>= container represent a file and other info.
3. The =<loc>= is a URL of the file.
4. The =<lastmod>=, =<changefreq>=, =<priority>= are optional.
5. A sitemap file can list a max of 50k URLs.

The purpose of sitemap file is for web crawlers to easily know all files
that exist on your site.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The general plan is very simple. Here's one way to do it.

1. Create a new file, insert XML header tags.
2. Traverse the web root dir. For each file, determine whether it should
   be listed in the sitemap.
3. If so, generate the proper URL tag and insert it into the new file.
4. When done visiting files, insert the XML footer tags. Save the file.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8; lexical-binding: t; -*-
    ;; version: 2019-06-11
    ;; home page: /Users/xah/web/ergoemacs_org/emacs/make_sitemap.html

    (require 'seq)

    (setq xah-web-root-path "/Users/xah/web/" )

    (defvar xahsite-external-docs nil "A vector of dir paths.")
    (setq  xahsite-external-docs
           [
            "ergoemacs_org/emacs_manual/"
            "xahlee_info/REC-SVG11-20110816/"
            "xahlee_info/clojure-doc-1.8/"
            "xahlee_info/css_2.1_spec/"
            "xahlee_info/css_transitions/"
            "xahlee_info/js_es2011/"
            "xahlee_info/js_es2015/"
            "xahlee_info/js_es2015_orig/"
            "xahlee_info/js_es2016/"
            "xahlee_info/js_es2018/"
            "xahlee_info/node_api/"
            ])

    (defun xahsite-generate-sitemap (@domain-name)
      "Generate a sitemap.xml.gz file of xahsite at doc root.
    @domain-name must match a existing one.
    Version 2018-09-17"
      (interactive
       (list (ido-completing-read "choose:" '( "ergoemacs.org" "wordyenglish.com" "xaharts.org" "xahlee.info" "xahlee.org" "xahmusic.org" "xahsl.org" ))))
      (let (
            ($sitemapFileName "sitemap.xml" )
            ($websiteDocRootPath (concat xah-web-root-path (replace-regexp-in-string "\\." "_" @domain-name "FIXEDCASE" "LITERAL") "/")))
        ;; (print (concat "begin: " (format-time-string "%Y-%m-%dT%T")))
        (let (
              ($filePath (concat $websiteDocRootPath $sitemapFileName ))
              ($sitemapBuffer (generate-new-buffer "sitemapbuff")))
          (with-current-buffer $sitemapBuffer
            (set-buffer-file-coding-system 'unix)
            (insert "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
    <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">
    "))
          (mapc
           (lambda ($f)
             (setq $pageMoved-p nil)
             (when (not (or
                         (string-match "/xx" $f) ; ; dir/file starting with xx are not public
                         (string-match "403error.html" $f)
                         (string-match "404error.html" $f)))
               (with-temp-buffer
                 (insert-file-contents $f nil 0 100)
                 (when (search-forward "page_moved_64598" nil t)
                   (setq $pageMoved-p t)))
               (when (not $pageMoved-p)
                 (with-current-buffer $sitemapBuffer
                   (insert "<url><loc>"
                           "http://" @domain-name "/" (substring $f (length $websiteDocRootPath))
                           "</loc></url>\n"
                           )))))
           (seq-filter
            (lambda (path)
              (not (seq-some
                    (lambda (x) (string-match x path))
                    xahsite-external-docs
                    )))
            (directory-files-recursively $websiteDocRootPath "\\.html$" )))
          (with-current-buffer $sitemapBuffer
            (insert "</urlset>")
            (write-region (point-min) (point-max) $filePath nil 3)
            (kill-buffer ))
          (find-file $filePath)
          )
        ;; (print (concat "done: " (format-time-string "%Y-%m-%dT%T")))
        ))

    (defun xahsite-generate-sitemap-all ()
      "do all
    2016-08-15"
      (interactive)
      (xahsite-generate-sitemap "ergoemacs.org" )
      (xahsite-generate-sitemap "wordyenglish.com" )
      (xahsite-generate-sitemap "xaharts.org" )
      (xahsite-generate-sitemap "xahlee.info" )
      (xahsite-generate-sitemap "xahlee.org" )
      (xahsite-generate-sitemap "xahmusic.org" )
      (xahsite-generate-sitemap "xahsl.org"  ))
#+END_SRC

On a site with 3515 html files (10 times more if counting image files
etc), the script takes 5 seconds to run. (e.g. timing based on running
it a second time, thus not counting disk reading time. )

See also: [[http://xahlee.info/golang/golang_gen_sitemap.html][Golang:
Generate Sitemap]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/make_sitemap.html]]

\\
\\
| [[../index_u13.html#article_31][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u3.html>>

| [[../article_33/index_u41.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_32][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_31/index_u6.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emac Lisp: Complex HTML Processing: Creating Downloadable zip Archive
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-07-04. Last updated: 2013-05-09.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I create a downloadable version of a website for people to read offline.

This is a fairly complex text processing task. In this tutorial, you'll
learn:

- How to call shell commands to copy, delete, zip, files or dir.
- How to use nested =mapc=.
- How to traverse a directory. [see
  [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]]
- how to use regex and search-forward etc to find relative links, and
  insert, etc, to change them.
- The use of relative/full name, current file dir, etc, to help
  determine and process links.
- Efficiently open and modify thousands of files.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Consider this emacs tutorial you are reading.

One simple solution is to make a copy of the directory, zip it, and let
people download that. This won't work, because many links will be
broken.

Here's what we need to do:

- All local links, including links to CSS or inline images, need to be
  processed. If they point to a dir outside the target dir, or to the
  parent of target dir, either the parent dir must be included in
  archive, or the linked file be included in the archive and link
  changed.
- All external links need to be looked at. For example, inline images
  that uses ‚Äúhttp://‚Äù form. The image file needs to be included, and the
  link needs to be changed to relative path.
- Remove JavaScript code for Google traffic tracker, Google Ads, web
  comment widget, etc.
- {templates, temp files, temp dir, emacs backup files, ...} need to be
  removed. For example: {.DS_Store, backup~, temp-notes.txt, scheduled
  publish log dir, ...}

It would be nice, if i could just press a button in emacs, and have this
archive generated automatically. And whenever i have updated my emacs
tutorial, i can run the script again to regenerate a fresh downloadable
version.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The general plan is simple:

1. Copy the directories into a destination directory.
2. Call shell commands to delete temp files such as emac's backup files
   in the destination dir.
3. Have a function that process each HTML, to change relative links and
   take out Google Analytics's JavaScript code.
4. Call shell commands to archive this dir.

First, we define some user input parameters for the script:

#+BEGIN_SRC emacs-lisp
    ;; web root dir
    (setq webroot "/Users/xah/web/") ; must end in slash

    ;; list of source dirs i want to make a archive
    ;; Each is relative to webroot. Must not end in slash.
    (setq sourceDirsList (list "emacs" "elisp"))

    ;; Destination dir path, relative to webroot
    ;; This is the dir i want the archive to be at
    (setq destDirRelativePath "diklo")

    ;; dest zip archive name (without the ‚Äú.zip‚Äù suffix)
    ;; for example here, the download file will be xah_emacs_tutorial.zip
    (setq zipCoreName "xah_emacs_tutorial")

    ;; whether to use gzip or zip.
    (setq use-gzip-p nil)
#+END_SRC

Then, we define some convenient constant.

#+BEGIN_SRC emacs-lisp
    (setq destRoot (concat webroot destDirRelativePath "/"))
    (setq destDir (concat destRoot zipCoreName "/"))
#+END_SRC

So, destRoot would be like =/Users/xah/web/diklo/= and destDir would be
like =/Users/xah/web/diklo/xah_emacs_tutorial=. The final download
archive would be =/Users/xah/web/diklo/xah_emacs_tutorial.tar.gz=.

Now, we copy the source dirs to destination.

#+BEGIN_SRC emacs-lisp
    ;;; copy to destination
    (mapc
     (lambda (x)
       (let (fromDir toDir)
         (setq fromDir (concat webroot x))
         (setq toDir
               (drop-last-slashed-substring
                (concat webroot destDirRelativePath "/" zipCoreName "/" x)) )
         (make-directory toDir t)
         (shell-command (concat "cp -R " fromDir " " toDir))
         )
       )
     sourceDirsList)
#+END_SRC

The above code used the function =mapc=. The function has the form
‚Äú(mapc 'myfunc myList)‚Äù, where the function myfunc will be applied to
each element of myList. The function we used above is ‚Äú(lambda (x)
...)‚Äù, with ‚Äúx‚Äù being the argument. The source dir and dest dir's paths
are constructed inside the lambda function, then command line string is
constructed, then =make-directory= is called. It will create all parent
dirs of a given full path. Then, finally we call =shell-command= to copy
the dirs.

Also, we called ‚Äúdrop-last-slashed-substring‚Äù, which is defined as
follows:

#+BEGIN_SRC emacs-lisp
    (defun drop-last-slashed-substring (path)
      "Drop the last path separated by ‚Äú/‚Äù.
    For example:
    ‚Äú/a/b/c/d‚Äù ‚Üí ‚Äú/a/b/c‚Äù
    ‚Äú/a/b/c/d/‚Äù ‚Üí ‚Äú/a/b/c/d‚Äù
    ‚Äú/‚Äù ‚Üí ‚Äú‚Äù
    ‚Äú//‚Äù ‚Üí ‚Äú/‚Äù
    ‚Äú‚Äù ‚Üí ‚Äú‚Äù"
      (if (string-match "\\(.*/\\)+" path)
          (substring path 0 (1- (match-end 0)))
        path))
#+END_SRC

Copying a bunch of directories seems a trivial operation, but it
actually took me a couple hours to arrive at the final code, due to some
‚Äúsmart‚Äù behavior of unix =cp -R=.

Originally, i thought the code would be something simple like several
=(shell-command (concat "cp -R " fromDir " " toDir))=, one for each
source dir, where fromDir and toDir are full paths. However, it turns
out the problem is slightly more complex. Here's a summary:

‚ë† The copying behavior depends on whether the destination node exists.
When the destination node exists, it copies the source node itself,
otherwise, it copies the source node's children (and creates the
non-existant destination node). ‚ë° However, when the destination node's
parent doesn't exist, it's a error.

Now, we copy my site's style sheets.

#+BEGIN_SRC emacs-lisp
    ;; copy the style sheets over, and icons dir
    (shell-command (concat "cp /Users/xah/web/style1.css " destDir))
    (shell-command (concat "cp /Users/xah/web/style2.css " destDir))
    (shell-command (concat "cp /Users/xah/web/style3.css " destDir))
    (shell-command (concat "cp -R /Users/xah/web/ics " destDir))
#+END_SRC

Now, do some file cleanup.

#+BEGIN_SRC emacs-lisp
    ; remove emacs backup files, temp files, mac os x files, etc.
    (shell-command (concat "find " destDir " -name \"*~\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -name \"#*#\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -name \"xx*\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -name \"\\.DS_Store\"  -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type f -empty -exec rm {} \\;"))
    (shell-command (concat "find " destDir " -type d -empty -exec rmdir {} \\;"))
    (shell-command (concat "find " destDir " -type d -name \"xx*\" -exec rm -R {} \\;"))
#+END_SRC

Now, we need to modify the relative links so that, if a link pointing to
a file that is not part of the downloadable copy, change it to a
„Äîhttp://xahlee.org/...„Äï based link.

For example, in my emacs tutorial at =/Users/xah/web/emacs/xxx.html= it
contains the link =<a href="../python/index.html">Python tutorial</a>=,
which points to a file outside the emacs dir. When user download my
emacs tutorial, this link will then points to a file that doesn't exist
on his disk. The link =../python/index.html= should be changed to
‚Äúhttp://xahlee.org/python/index.html‚Äù.

Also, in my HTML files, they contain a JavaScript for Google Analytics,
like this:
=<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript"> _uacct = "UA-104620-2"; urchinTracker();</script>=.
This allows me to see my web traffic statistics. The downloaded version
shouldn't have this line.

Here's the code to process each HTML file for the above problems:

#+BEGIN_SRC emacs-lisp
    ;;; change local links to ‚Äúhttp://‚Äù links.
    ;;; Delete the google JavaScript snippet, and other small fixes.
    (setq make-backup-files nil)
    (require 'find-lisp)
    (mapc (lambda (x)
            (mapc
             (lambda (fPath) (clean-file fPath (concat webroot (substring fPath (length destDir)))))
             (find-lisp-find-files (concat destDir "/" x) "\\.html$"))
            )
          sourceDirsList
    )
#+END_SRC

In the above code, we use =mapc= to apply a function to all HTML files.
The ‚Äúfind-lisp-find-files‚Äù will generate a list of all files in a dir.
Here, we actually calls mapc twice, one inside the other.

The sourceDirsList is a list of dirs. So, the first mapc maps a function
to each of the dir. Now, for each dir, we want to apply a function to
all HTML files. That's the inner mapc is for. The function that actually
does process the HTML file is the ‚Äúclean-file‚Äù. The ‚Äúclean-file‚Äù
function takes 2 arguments. The first is the full path to the HTML file
to be processed, the second is a full path to the ‚Äúsame‚Äù file at source
dir. The second argument is necessary, because we need the original
directory structure to compute the correct URL for the relative link
that needs to be fixed. Here's the code:

#+BEGIN_SRC emacs-lisp
    (defun clean-file (fPath originalFilePath)
      "Modify the HTML file at fPath, to make it ready for download bundle.

    This function change local links to ‚Äúhttp://‚Äù links,
    Delete the google JavaScript snippet, and other small changes,
    so that the file is nicer to be viewed offline at some computer
    without the entire xahlee.org's web dir structure.

    The google JavaScript is the Google Analytics web bug that tracks
     web stat to xahlee.org.

    fPath is the full path to the HTML file that will be processed.
    originalFilePath is full path to the ‚Äúsame‚Äù file in the original web structure.
    originalFilePath is used to construct new relative links."
      (let (myBuffer bds p1 p2 linkPath linkPathSansJumper)

        (setq myBuffer (find-file fPath))

        (goto-char (point-min)) ;in case buffer already open
        (while (search-forward "<script src=\"http://www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\"> _uacct = \"UA-104620-2\"; urchinTracker();</script>" nil t)
          (replace-match ""))

        (goto-char (point-min))
        (while (search-forward "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee</a>" nil t)
          (replace-match "<a href=\"http://xahlee.org/PageTwo_dir/more.html\">Xah Lee‚Üó</a>"))

        ;; go thru each link, if the link is local,
        ;;then check if the file exist.
        ;;if not, replace the link with proper http://xahlee.org/ url
        (goto-char (point-min)) ; in case buffer already open

        (while (re-search-forward "<[[:blank:]]*a[[:blank:]]+href[[:blank:]]*=[[:blank:]]*" nil t)
          (forward-char 1)
          (setq bds (bounds-of-thing-at-point 'filename))
          (setq p1 (car bds))
          (setq p2 (cdr bds))
          (setq linkPath (buffer-substring-no-properties p1 p2))

          (when (not (string-match "^http://" linkPath))

            ;; get rid of trailing jumper, for example, ‚ÄúAbstract-Display.html#top‚Äù
            (setq linkPathSansJumper (replace-regexp-in-string "^\\([^#]+\\)#.+" "\\1" linkPath t))

            (when (not (file-exists-p linkPathSansJumper))
              (delete-region p1 p2)
              (let (newLinkPath)
                (setq newLinkPath
                      (compute-url-from-relative-link originalFilePath linkPath webroot "xahlee.org"))
                (insert newLinkPath))
              (search-forward "</a>")
              (backward-char 4)
              (insert "‚Üó")
              )
            )
          )
        (save-buffer)
        (kill-buffer myBuffer)))
#+END_SRC

In the above function ‚Äúclean-file‚Äù, the hard part is to construct the
correct URL for a relative link.

Given a file, there are many relative links. The link may or may not be
good in the download copy version. For example, if the relative link
does not start with =../=, then it is still good. However, if it starts
with =../=, it may or may not be still good. For example, in my emacs
tutorial project, both =/Users/xah/web/emacs/= and
=/Users/xah/web/elisp/= are part of the download archive. So, if some
file under the emacs dir has a relative link starting with =../elisp/=,
then it is still a good link. We don't want to replace that with a
„Äîhttp://...„Äï version. To compute the correct relative link, we
actually need to know the original dir structure.

Computing relative links is conceptually trivial. Basically, each
occurrence of =../= means one dir level up. But actually coding it
correctly took a while due to various little issues. For example, some
link will have a trailing jumper of this form
=Abstract-Display.html#top=. The trailing =#top= will need to be removed
if we want to use the string to check if file exists. Theoretically, all
it takes to determine a relative link is the file path of the file that
contains the link, the relative link string, and the dir tree structure
surrounding the file. Specifically, when we move a dir, and wish to
construct or fix relative links, we do not need to check if the linked
file still exists in the new dir. In practice, it's much simpler, to
first determine whether the relative link is still good, by checking if
the linked file exists at the new download copy's dir structure.

In the clean-file function, it first grab the relative link string from
the HTML file, then determine whether this link needs to be fixed, then
calls ‚Äúcompute-url-from-relative-link‚Äù that returns the proper ‚Äúhttp://‚Äù
based URL. The function compute-url-from-relative-link takes 4
parameters: fPath, linkPath, webDocRoot, hostName. See the doc string
below:

#+BEGIN_SRC emacs-lisp
    (defun compute-url-from-relative-link (fPath linkPath webDocRoot hostName)
      "returns a ‚Äúhttp://‚Äù based URL of a given linkPath,
    based on its fPath, webDocRoot, hostName.

    fPath is the full path to a HTML file.
    linkPath is a string that's relative path to another file,
    from a ‚Äú<a href=\"‚Ä¶\"> tag.‚Äù
    webDocRoot is the full path to a parent dir of fPath.
    Returns a URL of the form ‚Äúhttp://hostName/‚ÄπurlPath‚Ä∫‚Äù
    that points to the same file as linkPath.

    For example, if
    fPath is /Users/xah/web/Periodic_dosage_dir/t2/mirrored.html
    linkPath is ../../p/demonic_males.html
    webDocRoot is /Users/xah/web/
    hostName is xahlee.org
    then result is http://xahlee.org/p/demonic_males.html

    Note that webDocRoot may or may not end in a slash."
      (concat "http://" hostName "/"
              (substring
               (file-truename (concat (file-name-directory fPath) linkPath))
               (length (file-name-as-directory (directory-file-name webDocRoot))))))
#+END_SRC

Finally, we zip up the dest dir.

#+BEGIN_SRC emacs-lisp
    ;; zip the dir
    (let (ff)
      (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".zip"))
      (when (file-exists-p ff) (delete-file ff))
      (setq ff (concat webroot destDirRelativePath "/" zipCoreName ".tar.gz"))
      (when (file-exists-p ff) (delete-file ff)))

    (setq default-directory (concat webroot destDirRelativePath "/"))

    (when (equal
           0
           (if use-gzip-p
               (shell-command (concat "tar cfz " zipCoreName ".tar.gz " zipCoreName))
             (shell-command (concat "zip -r " zipCoreName ".zip " zipCoreName))
             ))
      (shell-command (concat "rm -R " destDir))
    )
#+END_SRC

In the above code, first we delete the previous archive if it exists.

Now, all is done. With all the code above in a buffer, i can just
eval-buffer to generate my downloadable archive, or i can call the
script in OS's command line like =emacs --script make_download_copy.el=.
I decided to go one step further, by wrapping the whole script into a
function. Like this:

#+BEGIN_SRC emacs-lisp
    (defun make-downloadable-copy (webroot sourceDirsList destDirRelativePath
    zipCoreName &optional use-gzip-p)
      "Make a copy of web dir of XahLee.org for download.

    This function depends on the structure of XahLee.org,
    and is not useful in general.

    ‚Ä¢ webroot is the website doc root dir. (must end in slash)
    For example: <code class=\"path-abc\">/Users/xah/web/„Äç

    ‚Ä¢ sourceDirsList is a list of dir paths relative to webroot,
    to be copied for download. Must not end in slash.
    For example: (list \"p/time_machine\")

    ‚Ä¢ destDirRelativePath is the destination dir of the download.
    it's a dir path, relative to webroot.
    For example: ‚Äúdiklo‚Äù

    ‚Ä¢ zipCoreName is the downloable archive name, without the suffix.
    For example: ‚Äútime_machine‚Äù

    use-gzip-p means whether to use gzip, else zip for the final archive.
    If non-nil, use gzip."
      (let (‚Ä¶)
      ;; all the code above here except functions.
      )
    )
#+END_SRC

Here's how i call it:

#+BEGIN_SRC emacs-lisp
    ;; emacs tutorial and elisp manual in one download archive
    ;; gzip format
    (make-downloadable-copy
    "/Users/xah/web/"
    (list "emacs" "elisp")
     "diklo" "xah_emacs_tutorial" "gzip")

    ;; elisp manual. zip format.
    (make-downloadable-copy
    "/Users/xah/web/"
    (list "elisp")
     "diklo" "elisp_manual")
#+END_SRC

Emacs ‚ô•

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/make_download_copy.html]]

\\
\\
| [[../index_u13.html#article_32][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u41.html>>

| [[../article_34/index_u20.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_33][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_32/index_u3.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Process File line-by-line
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2008-12-05. Last updated: 2012-04-16.

This page gives a example of how to use emacs lisp to process a file
line by line, in a buffer, not as string of lines.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Given a file of many lines, like this:

#+BEGIN_SRC emacs-lisp
    at_target(integer tnum, vector targetpos, vector ourpos)
#+END_SRC

For each line, create a file of the same name as first part of the line.
For example: „Äîat_target.txt„Äï

The file content should be the whole line, with other static text, like
this:

#+BEGIN_SRC emacs-lisp
    # --
    at_target(integer tnum, vector targetpos, vector ourpos)
    {
    $0
    }
#+END_SRC

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I'm writing a major mode for [[http://xahsl.org/sl/ls.html][Linden
Script Language]] (LSL). LSL is a scripting language used for the
virtual world [[http://xahsl.org/sl/index.html][Second Life]]. It has
few hundred functions, and each one has parameters that is unusual as
compared to normal programing languages. For example, this is a LSL
function:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
    // ‚Ä¶
    }
#+END_SRC

So, i want a function template feature in my major mode. If a programer
has typed ‚Äúat_rot_target‚Äù, then, he can press a button, and it expands
to:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot) {
    ‚ñÆ
    }
#+END_SRC

There is a easy-to-use template system package for emacs, called
YASnippet. [see [[file:emacs_templates.html][YASnippet tutorial]]] So, i
decided to use this instead of implementing my own template system.

With yasnippet, it uses a plain text for template definition. To define
a template, you need to create a file. For example, in LSL there's a
function named ‚Äúcollision‚Äù with this syntax
=collision(integer num_detected) {‚Ä¶}=. This means, i must have a file
named ‚Äúcollision‚Äù in the template dir, and the file content must be like
this:

#+BEGIN_SRC emacs-lisp
    # --
    collision(integer num_detected)
    {
    $0
    }
#+END_SRC

This means, when my mode xlsl-mode is on, and yasnippet minor mode is
on, then user can type ‚Äúcollision‚Äù followed by a hotkey for template
completion, then the function form will be inserted and cursor will be
placed between the braces.

I have prepared a file that is over 300 lines that are the LSL functions
and parameters. For example, part of the file looks like this:

#+BEGIN_SRC emacs-lisp
    at_rot_target(integer tnum, rotation targetrot, rotation ourrot)
    at_target(integer tnum, vector targetpos, vector ourpos)
    attach(key id)
    changed(integer change)
    collision(integer num_detected)
    collision_end(integer num_detected)
    collision_start(integer num_detected)
    control(key id, integer held, integer change)
#+END_SRC

(Save the above text in a file name it =xx_event_forms.txt= for later
testing of elisp code.)

Now, the task is to parse this file, and for each line, create the
template file for it.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The task has these steps:

- Open the file.
- Read each line.
- Parse the line into 2 parts. The first part is everything before the
  opening paren (call it stringA). The second part is the rest of the
  line (call it stringB).
- Create a file and name it stringA.
- Insert into the file the whole line, and other text such as =# --= and
  ={ $0 }=.

These are simple tasks. There are a lot ways to do this in elisp. We can
for example grab the whole file's text, then use =split-string= by
newline char to get a list of lines. Then we loop thru the list.

*** Read File Content as List of Lines
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[file:elisp_read_file_content.html][Elisp: Read File Content as String
or List of Lines]]

*** Process Each Line in a Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Another way more idiomatic to emacs lisp, is to simply open the file in
a buffer, then move cursor one line at a time, each time grab the line
and do what we need to do.

For this task, the split lines into a list method is probably simpler.
But since we are learning emacs lisp, let's use the emacs buffer method.

First, we define few global vars.

#+BEGIN_SRC emacs-lisp
    ;; input file
    (setq inputFile "xx_event_forms.txt")

    ;; other vars
    (setq splitPos 0) ;; cursor position of split, for each line
    (setq fName "")
    (setq restLine "")
    (setq moreLines t ) ;; whether there are more lines to parse
#+END_SRC

Now, we open the file, like this:

#+BEGIN_SRC emacs-lisp
    ;; open the file
    (find-file inputFile)
    (goto-char 1) ;; needed in case the file is already open.
#+END_SRC

Now, we loop thru the lines, like this:

#+BEGIN_SRC emacs-lisp
    (while moreLines
      (search-forward "(")

      (setq splitPos (1- (point)))
      (beginning-of-line)
      (setq fName (buffer-substring-no-properties (point) splitPos))

      (end-of-line)
      (setq restLine (buffer-substring-no-properties splitPos (point) ))

      ;; create the file
      (find-file fName)
      (insert "# --\n")
      (insert fName restLine "\n{\n$0\n}" )
      (save-buffer)
      (kill-buffer (current-buffer))

      (setq moreLines (= 0 (forward-line 1)))
    )
#+END_SRC

In the above, we use =search-forward= to move cursor to the opening
paren. Then, save the position to splitPos. Everything before that
should be the template file name, so we save it in fName. Everything
after that is restLine.

Now, we create the file fName using =(find-file fName)=, then, insert
the content, save it, close it.

Lastly, we move cursor to the next line by =(forward-line 1)=. Note that
if the cursor is at the last line, and when =forward-line= is unable to
move forward, it will return a number indicating how many lines it
failed to pass. So, normally it returns 0. If not, that means we are on
the last line.

After we processed the lines, we just close the input buffer, like this:

#+BEGIN_SRC emacs-lisp
    (kill-buffer (current-buffer)) ;; close the input file
#+END_SRC

To test the above, first create a sample input file. Take the sample
input lines above and save it as =xx_event_forms.txt=. Then, grab all
the above lisp code and save it in a file =test_line_process.el=. Now,
open the lisp file and Alt+x =eval-buffer=. Then all the template files
will be created in the same dir.

Emacs ‚ô•

See also: [[file:elisp_all_about_lines.html][Elisp: Functions on Line]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_process_lines.html]]

\\
\\
| [[../index_u13.html#article_33][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u20.html>>

| [[../article_35/index_u15.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_34][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_33/index_u41.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs Lisp Power: Text-Soup Automation
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-11-03

This page showcases a example of emacs lisp power, in dealing with
text-soup processing that requires human interaction.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I have a [[http://xaharts.org/movie/best_movies.html][favorite movies
page]]. The page contain about 70 amazon links like this:

#+BEGIN_SRC emacs-lisp
    <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>
#+END_SRC

It's a mystery what the link is, unless you visit the link. I want them
to have a ‚Äútitle‚Äù attribute, like this:

#+BEGIN_SRC emacs-lisp
    <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>
#+END_SRC

It's a thorny problem. You have to write a script to fetch the amazon
page then parse the result to get the product title then insert them at
the right place. Amazon may block crawlers, and even if not, the parsing
of the complex HTML to extract the title may take hours to code. You
don't even know if product title is clearly marked by a specific tag.

Luckily, my page is written so that for each amazon link, the movie
title is within the paragraph, preceding the link, and usually in the
form of a Wikipedia link. Here's a sample paragraph:

#+BEGIN_SRC emacs-lisp
    <p><a href="http://en.wikipedia.org/wiki/To_sleep_with_a_vampire">To sleep with a vampire</a>
     (1993) ‚óá Director: Adam Friedman.
    <a class="amz" href="http://www.amazon.com/dp/B0000648YN/?tag=xahh-20">amazon</a>
    </p>
#+END_SRC

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

So, the plan is to write a elisp script. Here's the basic steps:

1. open the file
2. find a amazon link.
3. search backward for the Wikipedia link that contains the movie title.
4. insert the ‚Äútitle‚Äù attribute in the amazon link.
5. Repeat.

This is a job perfect for elisp, and can be done interactively,
[[file:elisp_text_processing_lang.html][far better than any Perl,
Python, Ruby]], due to emacs lisp's buffer system. I imagine it's a 20
min scripting job. Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2010-11-03
    ;; add „Äåtitle="product title"„Äç to amazon links on a HTML page.

    ;; rough steps:
    ;; find amazon link of the form
    ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20">amazon</a>

    ;; find a Wikipedia link above it, of this form
    ;; <a href="http://en.wikipedia.org/wiki/Dr._Strangelove">Dr. Strangelove</a>
    ;; extract the movie title

    ;; insert the attribute
    ;; title="‚Ä¶"
    ;; into the amazon link. Like this
    ;; <a class="amz" href="http://www.amazon.com/dp/B000055Y0X/?tag=xahh-20" title="Dr. Strangelove; movie">amazon</a>

    (setq outputBuffer "*xah output*" )
    (with-output-to-temp-buffer outputBuffer

      (find-file "~/web/xahlee_org/Periodic_dosage_dir/skina/nelci_skina.html" )
      (goto-char 1)

      (while
          (re-search-forward "<a class=\"amz\" href=\"http://www.amazon.com/dp/[^\"]+?\">amazon</a>"  nil t)

        (progn
          ;; set points for amazon link
          (backward-char 11)
          (setq amzLinkInsertPoint (point) )

          ;; get title from preceding Wikipedia link
          (re-search-backward "<a href=\"http://...wikipedia.org/wiki/[^\"]+?\">\\([^<]+?\\)</a>")
          (setq titleText (match-string 1 ) )

          (when (yes-or-no-p titleText)
            (goto-char amzLinkInsertPoint)
            (insert (concat " title=\"" titleText "; movie\"")) )
          )

        (progn (print "not found"))
        )

      (princ "Done deal!")
      )
#+END_SRC

Emacs is fantastic!

(In practice, the job took close to one hour to complete, counting all
mistakes, and whatnot when actually coding. For example, in the process
i noticed that 2 of the amazon links are preceded by Wikipedia links
that are not actually related to the amazon link, and this and other
miscellaneous irregularities are actually expected. The code above is
actually slightly cleaned up, but is still meant to be one-time-use
code. It always looks easy when seeing someone's published code than
actually coding from scratch.)

There are few hundred amazon links on my site of 4k pages. They all need
a similar fix. The job will be slightly different, because the links are
arbitrary product or book names. But typically, the product name is
usually marked like this „Äàbook title„Äâ or ‚Äúsong cd‚Äù or some other way
in the text before the link, but not always. Also, some amazon links may
already have a ‚Äútitle‚Äù attribute. The point is that it's a
[[file:emacs_power_story.html][text-soup situation and requires human
baby-sitting]] for correct completion, and elisp excels at this.
Tomorrow or so, i'll write a elisp script to fix these few hundred
amazon links among 4k pages. Total time for the task is expected to be 2
to 4 hours. (For a keyboard macro solution i needed to do in this, see:
[[file:emacs_macro_example2.html][Emacs Key Macro Example: Add HTML
Attribute]].)

2010-11-08

Aaron Culich wrote a elisp script that does the same thing but using
several interesting techniques, among them is using DOM/XPATH in elisp
to process HTML, and also yahoo's Yahoo Query Language (YQL), both of
which i don't have any experience with. His code can be seen here:
[[https://github.com/aculich/misc-elisp/blob/master/query-html.el]]

Here's a excerpt of his comment:

#+BEGIN_QUOTE
  I often find myself having to do some xpath myself and since want to
  do this sort of thing inside emacs myself from time to time instead of
  busting out python, so I've been playing around with your Dr.
  Strangelove movie example (a favorite movie of mine, btw) using emacs
  and xpath. You can find my results here:
  https://github.com/aculich/misc-elisp

  I tried using 3 methods.

  - ‚ë† First with pure elisp using the dom/xpath stuff on emacswiki.
    Unfortunately the processing is broken and at least in some of the
    cases I tried, gobbled up all available memory. I didn't look at it
    closely, but I have a feeling the elisp implementation would a fair
    amount of work to get working and even still would probably not be
    very fast for large documents. Also, you still probably want to run
    the input through tidy first so that you're not dealing with broken
    HTML (which it seems nearly every website in the universe has).
  - ‚ë° Using a few handy unix utilities not uncommon on most systems:
    wget, tidy, and xmlstarproc. You'll need to first install those
    before using this method.
  - ‚ë¢ Yahoo's YQL web service is handy for this sort of thing. And the
    nice thing is that if you need to process a large document, all of
    it will be done remotely.

  #3 is the default method that I use in my elisp code since it only
  relies on modules that ship with most recent versions of emacs
  (specifically json.el and url.el and w3m.el) and doesn't require any
  special binaries to be installed the way #2 does.

  Also, since #1 was so broken I did not include any example
  implementation for it. Anyway, if you find the code useful, let me
  know.
#+END_QUOTE

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text-soup_automation.html]]

\\
\\
| [[../index_u13.html#article_34][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u15.html>>

| [[../article_36/index_u39.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_35][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_34/index_u20.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: HTML Processing: Split Annotation
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-08-16

This page shows a example of emacs lisp for processing HTML. The HTML
files are classic novels, with annotations. The annotation markups need
to change from one format into another. There are hundreds of such pages
that need to be processed.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For all HTML files in a directory, find any annotation markup containing
the bullet ‚Äú‚Ä¢‚Äù symbol:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">A ‚Ä¶ ‚Ä¢ B ‚Ä¶ ‚Ä¢ C ‚Ä¶</div>
#+END_SRC

Split the annotation into multiple markups, like this:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">A ‚Ä¶ </div>
    <div class="annotate27223">B ‚Ä¶ </div>
    <div class="annotate27223">C ‚Ä¶ </div>
#+END_SRC

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

If you are a contract web dev programer, then you know that 99.99% of
websites are a messy text soup. They are created by hundreds of tools or
languages. Word processors, HTML generators, tens of lightweight markup
languages, different frameworks from different languages PHP, Perl,
Python, from different web era, from different programers in the past.
Even emacs has several modes that generate HTML. They are not in any
consistent form. Often, they have mis-matched tags too as invalid HTML.

It is in these situations, emacs shines thru, because emacs's powerful
embedded language lisp, and its interactive nature, lets you maximize
automation. Interactively when you are still feeling the pattern, then
by [[file:emacs_macro_example.html][Keyboard Macro]] or emacs lisp for
parts that can be automated.

For my website, i take the time to make sure that all my HTML are
consistent. But still, they are written in the span of 15 years.
Periodically i take the time to improve the markup. For example, when
new versions of CSS or HTML became mature and widely adopted by web
browsers. (CSS1 to 2 to 3, HTML 3 to 4 to
[[http://xahlee.info/js/html5_tags.html][HTML5]].)

I have hundreds of pages of classic novels as HTML documents. These
documents contain annotations in a special HTML markup. For example,
here's sample annotation from
[[http://wordyenglish.com/titus/act1.html][‚ÄúTitus Andronicus‚Äù Act 1
Scene 1]]:

#+BEGIN_SRC emacs-lisp
    SATURNINUS. 'Tis good, sir. You are very short with us;
      But if we live we'll be as sharp with you.
#+END_SRC

‚Ä¢ short ‚áí rudely brief. (AHD)\\
‚Ä¢ sharp ‚áí Fierce, impetuous, hash, severe... (AHD)

Here's the raw HTML:

#+BEGIN_SRC emacs-lisp
    <div class="annotate27223">‚Ä¢ short ‚áí rudely brief. (AHD)<br>
    ‚Ä¢ sharp ‚áí Fierce, impetuous, hash, severe‚Ä¶ (AHD)</div>

    <pre class="text48074">SATURNINUS. 'Tis good, sir. You are very <span class="xntt">short</span> with us;
      But if we live we'll be as <span class="xntt">sharp</span> with you.
    </pre>
#+END_SRC

Here's how the tag works. Each =<span class="xntt">= markup a word in
main text. When a word is marked by ‚Äúspan.xntt‚Äù, that means it has a
sidebar annotation. The sidebar section is marked by
=<div class="annotate27223">=. Inside the ‚Äúdiv.annotate27223‚Äù, there may
be more than one entries. Each entry starts with the bullet symbol ‚Äú‚Ä¢‚Äù.
For example, in the above, the words ‚Äúshort‚Äù and ‚Äúsharp‚Äù are both
entries inside a ‚Äúdiv.annotate27223‚Äù sidebar.

But recently, i think it is better to have one entry per sidebar. This
way, it makes the logic simpler, and is much easier if i want to add
[[http://xahlee.info/js/js.html][JavaScript]] functionality. For
example, when mouse hovers on a word in main text, the corresponding
annotation would be highlighted.

So, i want to write a elisp script to process all my files. If you
simply read the spec for this job, of splitting a markup by a particular
character, you may think it's trivial and can be done in any language in
10 minutes. Why then the elaborate discussion about text soup situation?

The important thing is that i DO NOT know what needs to be done to begin
with. Only after having used emacs power together with lisp script i
wrote before to look at and check my existing markup in hundreds of
files, then i know what state they are and decide on what i want to do.
Also, this change must be done with the ability to visually check that
all changes are done correctly, because the input may not be in the
format i expect. (it might be missing the bullet ‚Äú‚Ä¢‚Äù.)

For those Scheme Lisp academic computer science folks, you might wonder,
when i started with these annotations, why didn't i ‚Äúdesign‚Äù it well to
begin with. The reason is that, when i write a blog article, or my
literature annotation project, i really want to focus on the writing
first, the content, get it done, rather than get distracted by the
CSS/HTML markup design. (one thing i do make sure is that whatever
CSS/HTML i device, i made sure that they can be easily changed
systematically later by a simple parsing.) I devote significantly more
time on design than most people, but many factors necessitate change.
For example, CSS in practice is rather complex and it takes years of
experience to learn its quirks and tricks. Similarly, the best practices
of HTML changes with time. (For example, see:
[[http://xahlee.info/UnixResource_dir/writ/html5_vs_intelligence.html][Are
You Intelligent Enough to Understand HTML5?]].) Browsers change,
standards changes (For example, HTML ‚Üí XHTML ‚Üí HTML5. See:
[[http://xahlee.info/js/html5_validation_doctype.html][HTML5 Doctype,
Validation, X-UA-Compatible, and Why Do I Hate Hackers]].), thoughts of
best practices change, and my needs for the annotation also changed
through-out the years.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the outline of steps:

- Open the file. Search for the tag we want.
- Check if the tag contains a bullet ‚Äú‚Ä¢‚Äù.
- If so, replace the bullet char with new end tag and beginning tag. For
  example: =‚Ä¢= ‚áí =</div> <div>=
- Do this for all files in a dir. (or a given list of files)

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-08-13
    ;; process all files in a dir.
    ;; split any markup like this:
    ;; <div class="annotate27223">‚Ä¶ ‚Ä¢ ‚Ä¶ ‚Ä¢ ‚Ä¶</div>
    ;; by the bullet ‚Ä¢
    ;; into several annotate27223 tags

    (setq inputDir "~/web/xahlee_org/p/" )

    ;; add a ending slash if not there
    (when (not (string= "/" (substring inputDir -1) )) (setq inputDir (concat inputDir "/") ) )

    ;; files to process
    (setq fileList
    [
    "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin4_1.html"
    "~/web/xahlee_org/p/arabian_nights/aladdin/aladdin3.html"
    ]
    )

    (defun my-process-file-xnote (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (myBuffer ($counter 0) p1 p2 $meat
                     $meatNew
                     (changedItems '())
                     (tagBegin "<div class=\"annotate27223\">" )
                     (tagEnd "</div>" )
                     )

        (require 'sgml-mode)
        (when t

          (setq myBuffer (find-file fPath))
          (goto-char 1)
          (while (search-forward "<div class=\"annotate27223\">" nil t)

            ;; capture the annotate27223 tag text
            (setq p1 (point))
            (backward-char 1)
            (sgml-skip-tag-forward 1)
            (backward-char 6)
            (setq p2 (point))
            (setq $meat (buffer-substring-no-properties p1 p2))

            ;; if it contains a bullet
            (when (string-match "‚Ä¢" $meat)
              (setq $counter (1+ $counter))

              ;; clean the text. Remove some newline and <br> that's no longer needed
              (setq $meat (replace-regexp-in-string "\n*‚Ä¢ *" "‚Ä¢" $meat t t ) )
              (setq $meat (replace-regexp-in-string "\n$" "" $meat t t ) ) ; delete ending eol
              (setq $meat (replace-regexp-in-string "<br>‚Ä¢" "‚Ä¢" $meat t t ) )

              ;; put the new entries into a list, for later reporting
              (setq changedItems (split-string $meat  "‚Ä¢" t) )

              ;; break the bullet into new end/begin tags
              (setq $meatNew (replace-regexp-in-string "‚Ä¢" (concat tagEnd "\n" tagBegin) $meat t t ) )

              (goto-char p1)
              (delete-region p1 p2)
              (insert $meatNew)

              ;; remove the newline before end tag
              (when (looking-back "\n") (delete-backward-char 1))
              )
            )

          ;; report if the occurrence is not n times
          (when (not (= $counter 0))
              (princ "-------------------------------------------\n")
              (princ (format "%d %s\n\n" $counter fPath))

              (mapc (lambda ($x) (princ (format "%s\n\n" $x)) ) changedItems)
            )

            ;; close buffer if there's no change. Else leave it open.
            (when (not (buffer-modified-p myBuffer)) (kill-buffer myBuffer) )
          )
        ))

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah annotate27223 output*" )
      (with-output-to-temp-buffer outputBuffer
        ;; (mapc 'my-process-file-xnote fileList)
        (mapc 'my-process-file-xnote (find-lisp-find-files inputDir "\\.html$"))
      (princ "Done deal!")
        )
      )
#+END_SRC

Here's a sample output:
[[file:elisp_text_processing_split_annotation.txt]]

I've put lots comments in the code. It should be easy to understand. If
any part you don't understand, ask me. If you are new to elisp, checkout
the first few section of [[file:elisp.html][Emacs Lisp Tutorial]].

I ‚ô• emacs.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text_processing_split_annotation.html]]

\\
\\
| [[../index_u13.html#article_35][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u39.html>>

| [[../article_37/index_u10.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_36][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_35/index_u15.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Fix Dead Links
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-09-25. Last updated: 2012-05-11.

This page shows you how to write a elisp script that checks thousands of
HTML files and fix dead links.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I have 2 thousands HTML files that contains about 70 dead local links. I
need to write a elisp script to change these links to non-links. For
example, this is a dead link:

#+BEGIN_SRC emacs-lisp
    <a href="../widget/index.html#Top">Introduction</a>
#+END_SRC

I need it to be:

#+BEGIN_SRC emacs-lisp
    <span class="Œµlink" title="../widget/index.html#Top">Introduction</span>
#+END_SRC

The script should run in batch. And it should generate a report of all
changed links.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have a copy of the emacs manuals, at:

- [[../emacs_manual/emacs/index.html][GNU Emacs Manual]] (~690 files)
- [[../emacs_manual/elisp/index.html][GNU Emacs Lisp Reference Manual]]
  (~900 files)

These manual sometimes have links to other info files that's not emacs.
For example, on this page
[[../emacs_manual/elisp/Changing-Files.html][Changing Files - GNU Emacs
Lisp Reference Manual]], it contains a link to GNU coreutils like this:

#+BEGIN_SRC emacs-lisp
    <a href="../coreutils/File-Permissions.html">File Permissions</a>
#+END_SRC

I need to change these links to non-links.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

1. Open each file.
2. Search for ‚Äúhref=‚Äù.
3. Get the link URL.
4. Check if the link is a local file and exists.
5. If not, change the entire link tag into a ‚Äúspan‚Äù tag.
6. Repeat the above, until no link found.

First, we start like this:

#+BEGIN_SRC emacs-lisp
    (setq inputDir "~/web/xahlee_org/emacs_manual/" )

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      ‚Ä¶
    )

    ;; traverse the directory on all HTML files
    (require 'find-lisp)
    (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
#+END_SRC

The important part is the ‚Äúmy-process-file‚Äù function. Here's the basic
code:

#+BEGIN_SRC emacs-lisp
    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (‚Ä¶)

        ;; open file
        (setq myBuff (find-file fPath))

        (while
            ;; search local link
            (search-forward "href=\"../" nil t)

          ;; get the URL string
          (setq urlStr (thing-at-point 'filename) )

          ;; if the URL is a dead link
          (when (not (file-exists-p urlStr))
            (progn

              ;; set p1 and p2 to be the start/end of the link tag
              ;; and get the entire link string
              (sgml-skip-tag-backward 1)
              (setq p1 (point) ) ; start of link tag
              (sgml-skip-tag-forward 1)
              (setq p2 (point) ) ; end of link tag
              (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

              ;; get link text
              (search-backward "</a>")
              (setq p4 (point) ) ; end of link text
              (search-backward ">")
              (forward-char 1)
              (setq p3 (point) ) ; start of link text
              (setq linkText (buffer-substring-no-properties p3 p4) )

              ;; remove the link, replace it with a non-link span text.
              (delete-region p1 p2)
              (insert
               "<span class=\"Œµlink\" title=\""
               urlStr
               "\">"
               linkText
               "</span>"
               )
              )
            )
          )

        ;; close the file if no changes made
        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )
#+END_SRC

** Complete Code
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's the complete code.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-09-25
    ;; replace dead links in emacs manual on my website
    ;;
    ;; Example. This:
    ;; <a href="../widget/index.html#Top">Introduction</a>
    ;;
    ;; should become this
    ;;
    ;; <span class="Œµlink" title="../widget/index.html#Top">Introduction</span>
    ;;
    ;; do this for all files in a dir.

    ;; rough steps:
    ;; go thru each file
    ;; search for link
    ;; if the link is „Äå../xx/„Äç where the file doesn't exist, then replace the whole link tag.

    (setq inputDir "~/web/xahlee_org/emacs_manual/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (
            myBuff
            urlStr
            linkText
            wholeLinkStr
            p1 p2
            p3 p4
            )
        (setq myBuff (find-file fPath))
        (widen) ; in case it's open and narrowed
        (goto-char (point-max)) ; work from bottom, so that changes in point are preserved. (actually, doesn't really matter for this script)

        (while
            (search-backward "href=\"../" nil t)
          (forward-char 7)
          (setq urlStr (replace-regexp-in-string "\\.html#.+" ".html" (thing-at-point 'filename) ) )

          (when (not (file-exists-p urlStr))
            (progn
              (sgml-skip-tag-backward 1)
              (setq p1 (point) )                      ; start of link tag
              (sgml-skip-tag-forward 1)
              (setq p2 (point) )                      ; end of link tag

              (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )

              (search-backward "</a>")
              (setq p4 (point) )                      ; end of link text
              (search-backward ">")
              (forward-char 1)
              (setq p3 (point) )                      ; start of link text

              (setq linkText (buffer-substring-no-properties p3 p4) )

              (princ (buffer-file-name))
              (princ "\n")
              (princ wholeLinkStr)
              (princ "\n")
              (princ "----------------------------\n")

              (delete-region p1 p2)
              (insert
               "<span class=\"Œµlink\" title=\""
               urlStr
               "\">"
               linkText
               "</span>"
               )
              )
            )
          )

        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )

    (require 'find-lisp)

    (font-lock-mode 0)

    (with-output-to-temp-buffer "*xah elisp dead link replace output*"
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )

    (font-lock-mode 1)
#+END_SRC

Here's few interesting parts.

*** Turn Syntax Coloring Off
    :PROPERTIES:
    :CLASS: calibre14
    :END:

We turn font lock off, by =(font-lock-mode 0)=. When font lock is on,
processing 2 thousand HTML files will take ~50 minutes. With syntax
coloring off, it's 3 minutes.

*** Leave Changed Files Open
    :PROPERTIES:
    :CLASS: calibre14
    :END:

If there are changes in the file, we leave it open. This way, we don't
have to revert to backup files if there's a mistake. If we like the
result, just call =ibuffer= and press * u to mark all un-saved, then S
to save all. Then press D to close them all. If you do not want to save
them, simply mark all unsaved * u then press D to close all.

This is extremely useful while you are still working on the code and
doing some test runs. This interactive nature of emacs is what beats
{Perl, Python, ...} for text processing.

If you do want to save the file in the script, simply call
=(save-buffer)= or =(write-file (buffer-file-name))=

When the file is not modified, we close it. Like this:
=(when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )=.

*** Use sgml-skip-tag-forward
    :PROPERTIES:
    :CLASS: calibre14
    :END:

The =sgml-skip-tag-forward= and =sgml-skip-tag-backward= are from
=html-mode=. They move the cursor to the beginning or ending of a tag.
They are extremely useful. It saves you a lot time in writing code to
parse tags, especially when tags are nested. Here's how we used it.

Suppose there's this link in a file:

#+BEGIN_SRC emacs-lisp
    <a href="../widget/index.html#Top">Introduction</a>
#+END_SRC

After we did the search with

#+BEGIN_SRC emacs-lisp
     (while
      (search-backward "href=\"../" nil t)
      ‚Ä¶
     )
#+END_SRC

the cursor is on the ‚Äúh‚Äù. While the cursor is inside the tag, we call:

#+BEGIN_SRC emacs-lisp
    (sgml-skip-tag-backward 1)
     (setq p1 (point) ) ; start of link tag
     (sgml-skip-tag-forward 1)
     (setq p2 (point) ) ; end of link tag

     (setq wholeLinkStr (buffer-substring-no-properties p1 p2) )
#+END_SRC

This sets the value of wholeLinkStr to the entire anchor tag
=<a ‚Ä¶>‚Ä¶</a>=.

*** Print Output to Your Own Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Printing output is done here using =with-output-to-temp-buffer= and
=princ=. Like this:

#+BEGIN_SRC emacs-lisp
    (with-output-to-temp-buffer "*xah elisp dead link replace output*"
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
#+END_SRC

Inside the ‚Äúmy-process-file‚Äù function, we write:

#+BEGIN_SRC emacs-lisp
    (princ (buffer-file-name))
     (princ "\n")
     (princ wholeLinkStr)
     (princ "\n")
     (princ "----------------------------\n")
#+END_SRC

Here's a output from the script:
[[file:elisp_fix_dead_links_output.txt]]. It lets me easily see if there
are any errors. There are a total of 68 changes.

For detail about printing in elisp, see:
[[file:elisp_printing.html][Elisp: Print, Output]].

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_fix_dead_links.html]]

\\
\\
| [[../index_u13.html#article_36][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u10.html>>

| [[../article_38/index_u21.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_37][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_36/index_u39.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs Lisp vs Perl: Validate Local File Links
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2012-04-07. Last updated: 2020-05-11.

This page shows 2 scripts to validate HTML local file links (i.e. check
file existence of local links). One written in perl, one in elisp.

The 2 script's algorithms are not artificially made to be the same, but
follow the natural style/idiom for each lang. They do the same job for
my need.

** Perl
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For each file, call ‚Äúprocess_file‚Äù. That function then calls
=get_links($file_full_path)= to get a list of links, then print the link
if it leads to a non-existent file.

The heart of the algorithm is the ‚Äúget_links‚Äù function. It reads the
whole file content as one big string, then split the string by the char
‚Äú<‚Äù, then, for each segment of text, it proceed to find a link using
regex.

#+BEGIN_SRC emacs-lisp
    # -*- coding: utf-8 -*-
    # perl
    # 2004-09-21, ‚Ä¶, 2012-04-07

    # given a dir, check all local links and inline images in the HTML files there. Print a report.
    # XahLee.org

    use strict;
    use Data::Dumper;
    use File::Find;
    use File::Basename;

    my $inDirPath = q{c:/Users/h3/web/xahlee_org/};

    # $inDirPath = $ARGV[0]; # should give a full path; else the $File::Find::dir won't give full path.

    die qq{dir $inDirPath doesn't exist! $!} unless -e $inDirPath;

    ##################################################
    # subroutines

    # get_links($file_full_path) returns a list of values in <a href="‚Ä¶">. Sample elements:  q[http://xahlee.org], q[../image.png], q[ab/some.html], q[file.nb], q[mailto:xah@xahlee.org], q[#reference], q[javascript:f('pop_me.html')]
    sub get_links ($) {
      my $full_file_path = $_[0];
      my @myLinks = ();
      open (FF, "<$full_file_path") or die qq[error: can not open $full_file_path $!];

      # read each line. Split on char ‚Äú<‚Äù. Then use regex on „Äåhref=‚Ä¶„Äç or „Äåsrc=‚Ä¶„Äç to get the url. This assumes that a tag „Äå<‚Ä¶>„Äç is not broken into more than one line.
      while (my $fileContent = <FF>) {
        my @textSegments = ();
        @textSegments = split(m/</, $fileContent);
        for my $oneLine (@textSegments) {
          if ($oneLine =~ m{href\s*=\s*"([^"]+)".*>}i) { push @myLinks, $1; }
          if ($oneLine =~ m{src\s*=\s*\"([^"]+)".*>}i) { push @myLinks, $1; }
        } }
      close FF;
      return @myLinks;
    }

    sub process_file {
      if (
          $File::Find::name =~ m[\.html$] &&
          $File::Find::dir !~ m(/xx)
         ) {
        my @myLinks = get_links($File::Find::name);

        map {
          s/#.+//; # delete url fragment identifier, eg http://example.com/index.html#a
          s/%20/ /g; # decode percent encode url
          s/%27/'/g;
          if ((!m[^http:|^https:|^mailto:|^irc:|^ftp:|^javascript:]i) && (not -e qq[$File::Find::dir/$_]) ) { print qq[‚Ä¢ $File::Find::name $_\n];} }
          @myLinks;
     } }

    find(\&process_file, $inDirPath);

    print "\nDone checking. (any errors are printed above.)\n";
#+END_SRC

full updated code at
[[http://xahlee.info/perl/perl_validate_local_links.html][Perl: Validate
Local Links]]

** Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

For each file, call ‚Äúmy-process-file‚Äù. Then, the file is put into a
buffer. Then, it uses regex search, and moving cursor, etc, to make sure
that we find links we want to check.

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; elisp
    ;; 2012-02-01
    ;; check links of all HTML files in a dir

    ;; check only local file links in text patterns of the form:
    ;; < ‚Ä¶ href="link" ‚Ä¶>
    ;; < ‚Ä¶ src="link" ‚Ä¶>

    (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let ( $url $path p1 p2 p-current p-mb (checkPathQ nil) )

        ;; open file
        ;; search for a ‚Äúhref=‚Äù or ‚Äúsrc=‚Äù link
        ;; check if that link points to a existing file
        ;; if not, report it

        (when (not (string-match "/xx" fPath)) ; skip file whose name starts with ‚Äúxx‚Äù
          (with-temp-buffer
            (insert-file-contents fPath)
            (while
                (re-search-forward "\\(?:href\\|src\\)[ \n]*=[ \n]*\"\\([^\"]+?\\)\"" nil t)
              (setq p-current (point) )
              (setq p-mb (match-beginning 0) )
              (setq $url (match-string 1))

              (save-excursion
                (search-backward "<" nil t)
                (setq p1 (point))
                (search-forward ">" nil t)
                (setq p2 (point))
                )

              (when (and (< p1 p-mb) (< p-current p2) ) ; the ‚Äúhref="‚Ä¶"‚Äù is inside <‚Ä¶>
                ;; set checkPathQ to true for non-local links and xahlee site, eg http://xahlee.info/
                (if (string-match "^http://\\|^https://\\|^mailto:\\|^irc:\\|^ftp:\\|^javascript:" $url)
                    (when (string-match "^http://xahlee\.org\\|^http://xahlee\.info\\|^http://ergoemacs\.org" $url)
                      (setq $path (xahsite-url-to-filepath (replace-regexp-in-string "#.+$" "" $url))) ; remove trailing jumper url. For example: href="‚Ä¶#‚Ä¶"
                      (setq checkPathQ t)
                      )
                  (progn
                    (setq $path (replace-regexp-in-string "%27" "'" (replace-regexp-in-string "#.+$" "" $url)) )
                    (setq checkPathQ t)
                    )
                  )

                (when checkPathQ
                  (when (not (file-exists-p (expand-file-name $path (file-name-directory fPath))))
                    (princ (format "‚Ä¢ %s %s\n" (replace-regexp-in-string "^c:/Users/h3" "~" fPath) $url) )
                    )
                  (setq checkPathQ nil) )

                ) ) ) ) ) )

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah check links output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
      )
#+END_SRC

** What's Valid HTML
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Note that the HTML files are assumed to be W3C valid (i.e. no missing
closing tags or missing ‚Äú>‚Äù). However, my code are not general enough to
cover arbitrary valid HTML. SGML based HTML are very complex, and isn't
just nested tags, but such HTML are basically never used. The perl and
elisp code here work correctly (get all links) for perhaps 99.9% HTML
files out there. (symbolic links or other alias mechanisms on file
system are not considered.)

*** Edge Case Examples
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's some edge cases. These examples show that you cannot simply use
regex to search for the pattern =<a href="‚Ä¶" ‚Ä¶>=. Here's a most basic
example:

#+BEGIN_SRC emacs-lisp
    <a href="math.html" title="x > y">math</a>
#+END_SRC

Note that the above is actually valid HTML according to W3C's validator.
Also, note that pages passing W3C validator are not necessarily valid by
W3C's HTML spec. [see
[[http://xahlee.info/js/w3c_html_validator_problem.html][W3C HTML
Validator Invalid]]]

One cannot simply use regex to search for pattern =<a href="‚Ä¶" ‚Ä¶>=, and
this is especially so because some HTML pages contains sample HTML code
for teaching HTML, and ohters are programing tutorials containing code
example of using regex to parse HTML. So, the HTML is sometimes HTML
embedded in HTML, or HTML code in regex in python code on a HTML page.

The following shows that patterns such as =href="‚Ä¶"= or =src="‚Ä¶"= are
not necessarily HTML links.

[[file:feed_0/article_37/images/img1_u3.png]]

HTML in HTML, and HTML in regex in python code in HTML.

** Perl vs Emacs Lisp
   :PROPERTIES:
   :CLASS: calibre17
   :END:

One thing interesting is to compare the approaches in perl and emacs
lisp.

For our case, regex is not powerful enough to deal with the problem by
itself, due to the nested nature of HTML. This is why, in my perl code,
i split the file by ‚Äú<‚Äù into segments first, then, use regex to deal
with now the non-nested segment. This will break if you have
=<a title="x < href=z" href="math.html">math</a>=. This cannot be worked
around unless you really start to write a real parser.

The elisp here is more powerful, not because of any lisp features, but
because emacs's buffer datatype. You can think of it as a glorified
string datatype, that you can move a cursor back and forth, or use regex
to search forward or backward, or save cursor positions (index) and grab
parts of text for further analysis.

also, might checkout my perl tutorial
[[http://xahlee.info/perl/perl_basics_1.html][Learn Perl in 1 Hour]]

**** Validate HTML File Local Links
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[http://xahlee.info/golang/golang_validate_links.html][Golang]]
- [[http://xahlee.info/perl/perl_validate_local_links.html][Perl]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_37/elisp_vs_perl_validate_links.xhtml][Emacs
  Lisp]]

- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]
- [[file:elisp_basics.html][Emacs Lisp Basics]]
- [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
- [[http://xahlee.info/UnixResource_dir/writ/notations_mma.html][Intro
  to Mathematica Pattern Matching for Lisp Programers]]
- [[http://xahlee.info/UnixResource_dir/writ/Mathematica_expressiveness.html][Normalize
  Function in Haskell, Ruby, Python, Perl, Scheme Lisp, JavaScript,
  Java, C]]

**** Misc Technical Essays on Emacs Lisp
     :PROPERTIES:
     :CLASS: calibre25
     :END:

- [[../misc/elisp_naming_convention.html][Emacs Lisp Naming Convention]]
- [[../misc/emacs_lisp_some_and_every.html][Elisp: Some and Every]]
- [[../misc/emacs_lisp_what_is_fn.html][Elisp: What is the Function
  fn?]]
- [[../misc/elisp_symbol_vs_string_for_non_nil.html][Emacs Lisp: Symbol
  vs String]]
- [[../misc/elisp_list_function_type_syntax_coloring.html][Meaning of
  Lisp List, Function Type, and Syntax Coloring]]
- [[http://ergoemacs.org/tmp/calibre_4.99.4_tmp_hiyl7u9l/7uvjt9eg_plumber/feed_0/article_37/elisp_vs_perl_validate_links.xhtml][Emacs
  Lisp vs Perl: Validate Local File Links]]
- [[../emacs/elisp_text_processing_lang.html][Text Processing: Emacs
  Lisp vs Perl]]
- [[../emacs/elisp_namespace_solution_copying_javascript_practice.html][Can
  Emacs Lisp Fix Its Namespace Problem by Copying JavaScript Practice?]]
- [[../misc/js_tutorial_and_emacs_lisp_vs_javascript.html][Emacs Lisp vs
  JavaScript?]]
- [[../emacs/elisp_common_lisp_in_emacs.html][Controversy of Common Lisp
  Package in Emacs Lisp]]
- [[../emacs/lisp_list_problem.html][Lisp's List Problem]]
- [[../emacs/lisp1_vs_lisp2.html][Lisp-1 vs Lisp-2]]
- [[../emacs/modernization_elisp_lib_problem.html][Emacs Lisp Problems:
  Trim String, Regex Match Data, Lacking Namespace]]
- [[../emacs/thing-at-point_chaining_functions.html][Functional
  Programing: Function Output Should Always Have the Same Structure]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_vs_perl_validate_links.html]]

\\
\\
| [[../index_u13.html#article_37][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u21.html>>

| [[../article_39/index_u27.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_38][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_37/index_u10.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Text Processing, Transforming Page Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-10-29. Last updated: 2015-05-08.

This page shows a example of using emacs lisp for text processing. It is
used to update HTML page's navigation bar.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You have hundreds of HTML pages that have a nav bar like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    <a href="1.html">1</a>,
    <a href="2.html">2</a>,
    <a href="3.html">3</a>,
    ‚Ä¶
    </div>
#+END_SRC

It looks like this in browser (with
[[http://xahlee.info/js/css_index.html][CSS]]):

[[file:feed_0/article_38/images/img1_u1.png]]

This is the page navigation bar. Note that the page contains a link to
itself.

You want to remove the self-link. The result should look like this:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page:
    1,
    <a href="2.html">2</a>,
    <a href="3.html">3</a>,
    ‚Ä¶
    </div>
#+END_SRC

[[file:feed_0/article_38/images/img2.png]]

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here are the steps we need to do for each file:

1. open the file.
2. move cursor to the beginning of page navigation string.
3. move cursor to file name.
4. call =sgml-delete-tag= to remove the anchor tag. (=sgml-delete-tag=
   is from =html-mode=)
5. save file.
6. close buffer.

We begin by writing a test code to process a single file.

#+BEGIN_SRC emacs-lisp
    (defun my-process-file-navbar (fPath)
      "Modify the HTML file at fPath."
      (let (fName myBuffer)
        (setq fName (file-name-nondirectory fPath))
        (setq myBuffer (find-file fPath))
        (widen) ; in case buffer already open, and narrow-to-region is in effect
        (goto-char 1)
        (search-forward "<div class=\"pages\">Goto Page:")
        (search-forward fName)
        (sgml-delete-tag 1)
        (save-buffer)
        (kill-buffer myBuffer)))

    (my-process-file-navbar "~/test1.html")
#+END_SRC

For testing, create files {=test1.html=, =test2.html=, =test3.html=} in
a temp directory for testing this code. Place the following content into
each file:

#+BEGIN_SRC emacs-lisp
    <div class="pages">Goto Page: <a href="test1.html">XYZ Overview</a>, <a href="test2.html">Second Page</a>, <a href="test3.html">Summary Z</a></div>
#+END_SRC

(note that the link text may not be 1, 2, 3.)

The elisp code above is very basic.

- =find-file= ‚Üí open file. [[../emacs_manual/elisp/Files.html][(info
  "(elisp) Files")]]
- =search-forward= ‚Üí move cursor.
  [[../emacs_manual/elisp/Buffers.html][(info "(elisp) Buffers")]]
- =kill-buffer= ‚Üí close buffer.
  [[../emacs_manual/elisp/Searching-and-Matching.html][(info "(elisp)
  Searching and Matching")]].

=sgml-delete-tag= is from =html-mode= (which is automatically loaded
when a HTML file is opened).

=sgml-delete-tag= deletes the opening/closing tags tags the cursor is
on.

All we need to do now is to feed it a bunch of file paths.

To get the list of files that contains the page-nav tag, we can simply
use linux's ‚Äúfind‚Äù and ‚Äúgrep‚Äù, like this:

#+BEGIN_SRC emacs-lisp
    find . -name "*\.html" -exec grep -l '<div class="pages">' {} \;
#+END_SRC

From the output, we can use
[[file:emacs_string-rectangle_ascii-art.html][string-rectangle]] and
[[file:emacs_find_replace.html][query-replace]], to construct the
following code:

#+BEGIN_SRC emacs-lisp
    (mapc 'my-process-file-navbar
          [
           "~/web/cat1html"
           "~/web/dog.html"
           "~/web/something.html"
           "~/web/xyz.html"
           ]
          )
#+END_SRC

The =mapc= is a lisp idiom of looping thru a
[[file:elisp_list.html][list]] or [[file:elisp_vector.html][vector]].
The first argument is a function. The function will be applied to every
element in the list. The single quote in front of the function is
necessary. It prevents the symbol ‚Äúmy-process-file-navbar‚Äù from being
evaluated (as a expression of a variable).

Emacs ‚ô•

- [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
  Transform FAQ Tags]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_text_processing.html]]

\\
\\
| [[../index_u13.html#article_38][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u27.html>>

| [[../article_40/index_u4.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_39][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_38/index_u21.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Process HTML with Emacs Lisp: Transform FAQ Tags
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2007-11-30. Last updated: 2012-04-18.

This page shows a example of using emacs lisp to do a text processing
job; It shows how emacs buffer type has significant advantage than Perl,
Python for processing nested text.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want to write a elisp program, that process a HTML file in a somewhat
complex way. Specifically, certain strings must be replaced only if they
appear inside a tag and or only if they are first child.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

I have many web pages that are in Questions And Answers format. The
following is a sample screenshot.

[[file:feed_0/article_39/images/img1_u2.png]]

The following is a example of the raw HTML:

#+BEGIN_SRC emacs-lisp
    <p class="q">Q: Why ‚Ä¶</p>
    <p class="a">A: Because ‚Ä¶</p>
    <p class="a">You need to do ‚Ä¶</p>
    ‚Ä¶
    <p class="q">Q: How ‚Ä¶</p>
    <p class="a">A: Do this ‚Ä¶</p>
    <p class="a">And that ‚Ä¶</p>
    ‚Ä¶
#+END_SRC

Basically, each Question section is a paragraph of class ‚Äúq‚Äù, and each
Answer section is several =<p>= tags with class ‚Äúa‚Äù.

After a few years with this format, i started to use a better format.
Specifically, a Answer section should just be wrapped with a single
=<div class="a">‚Ä¶</div>=. And, the ‚ÄúQ: ‚Äù and ‚ÄúA: ‚Äù string are removed
from content (because CSS can insert that automatically, like this:
=p.q:before {content:"Q: "}=.). Here's a example of the new format:

#+BEGIN_SRC emacs-lisp
    <p class="q">Why?</p>

    <div class="a">
    <p>Because this.</p>
    <p>You need to that.</p>
    </div>
#+END_SRC

The task i have now, is to transform existing pages to this new format.
Here's what needs to be done precisely:

For any consecutive blocks of =<p class="a">‚Ä¶</p>=, wrap them with a
=<div class="a">= and =</div>=, then replace those =<p class="a">= by
=<p>=. Also, remove those ‚ÄúQ: ‚Äù and ‚ÄúA: ‚Äù.

Although this is simple in principle, but without using a HTML parser,
it's hard to code it as described. Using a HTML parser has its own
problems. The HTML/DOM model would make the code much more complex, and
the output will change the placement of whitspaces. Unless we are doing
XML transformation on a larger scale, the HTML/DOM parser is usually not
what we want. A text-based search-and-replace algorithm to achieve the
above is as follows:

For each occurrence of =<p class="q">=, do the following:

- Add a =<div class="a">= right after =<p class="q">‚Ä¶</p>=.
- Add a =</div>= right before =<p class="q">=.
- Replace =<p class="q">Q: = by =<p class="q">=, replace
  =<p class="a">A: = by =<p class="a">=

then:

- Replace the first occurrence of =</div>= that happens before the first
  occurrence of =<p class="q">=.
- Add a =</div>= that happens after the last =<p class="a">‚Ä¶</p>= tag.
- Replace all =<p class="a">= to =<p>=.

We proceed to write a elisp code to solve this problem.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The algorithm described sounds simple, but isn't trivial if you do it in
Perl or Python. For example, one of the step is:

#+BEGIN_QUOTE
  Add a =<div class="a">= right after =<p class="q">‚Ä¶</p>=.
#+END_QUOTE

It would involve some coding to get the meaning of ‚Äúright after‚Äù
correct. Similarly, other steps involves finding a string immediately
before or after occurrences of another string, with condition such as no
more of a string comes after.

With emacs, this is much easier, because emacs has buffer representation
of files with a pointer that can move back and forth. So, we can just
search by regex forward or backward and freely move our cursor and
compare positions to locate the right piece of text.

First, we write a prototype that just works on a single file. Here's the
code:

#+BEGIN_SRC emacs-lisp
    (defun xx ()
      "temp test function"
      (interactive)
      (find-file "elisp_process_html_sample.html")
      (goto-char 1)

    ;; add opening and closing tags for answer section
    ;; this is done by locating the opening question tag,
    ;; then move to the end of tag, then insert <div class="a">
    ;; then, locate the next opening question tag but move backward to </p>,
    ;; then insert </div>
      (while (search-forward "<p class=\"q\">" nil t)
        (search-forward "<p class=\"a\">")
        (replace-match "<div class=\"a\">\n<p class=\"a\">")
        (if (search-forward "<p class=\"q\">" nil t)
            (progn
              (search-backward "</p>")
              (forward-char 4)
              (insert "\n</div>")
              )
          )
        )

    ;; add the last closing tag for answer section
      (end-of-buffer)
      (search-backward "<p class=\"a\">")
      (search-forward "</p>")
      (insert "\n</div>")

    ;; take out the ‚ÄúQ: ‚Äù and ‚ÄúA: ‚Äù
      (beginning-of-buffer)
      (while (search-forward "<p class=\"q\">Q: " nil t)
        (replace-match "<p class=\"q\">"))

    ;; replace ‚Äú<p class="a">‚Äù by ‚Äú<p>‚Äù.
      (beginning-of-buffer)
      (while (search-forward "<p class=\"a\">A: " nil t)
        (replace-match "<p>"))
    )
#+END_SRC

This is a simple code. It uses emac's power of buffer data structure for
files, by moving a pointer back and forth to a desired place, then do
search and replace text or insert. With the ability of moving a point to
a particular string, we are able to locate the places we want the tag
insertion to happen, without explicitly going by the DOM model of
parent-child relationship of tags.

In the above code, the =search-forward= function moves the cursor to the
end of matched text. It returns ‚Äúnil‚Äù if not found. The
=search-backward= works similarly, but put the point on the beginning of
matched text.

The =replace-match= just replaces previously matched text. The
=end-of-buffer= moves the point to the end of buffer. Similarly for
=beginning-of-buffer=.

[[../emacs_manual/elisp/String-Search.html][(info "(elisp) String
Search")]]

Now, if we want to process many files, first we need to change the code
to take a file path, and add code to save buffer and close buffer. Like
this:

#+BEGIN_SRC emacs-lisp
    (defun my-process-html (fPath)
      "Process a file at FPATH‚Ä¶"
      (let (myBuffer)
        (setq myBuffer (find-file fPath))
        ; code body here
        (save-buffer)
        (kill-buffer myBuffer)
      )
    )
#+END_SRC

To get the list of files containing the Q and A section, we can simply
use unix's ‚Äúfind‚Äù and ‚Äúgrep‚Äù, like this:
=find . -name "*\.html" -exec grep -l '<p class="q">' {} \;=. (or just
use emacs. See: [[file:elisp_grep_script.html][Elisp: Write grep]].)

Then, place the list of files into a list and map over the list, like
this:

#+BEGIN_SRC emacs-lisp
    (mapc 'my-process-html
            (list
    "/Users/xah/web/emacs/emacs_adv_tips.html"
    "/Users/xah/web/emacs/emacs_display_faq.html"
    "/Users/xah/web/emacs/emacs_esoteric.html"
    "/Users/xah/web/emacs/emacs_html.html"
    "/Users/xah/web/emacs/emacs_n_unicode.html"
    "/Users/xah/web/emacs/emacs_unix.html"
    "/Users/xah/web/emacs/keyboard_shortcuts.html"
    "/Users/xah/web/emacs/modernization.html"
    "/Users/xah/web/img/imagemagic.html"
    "/Users/xah/web/java-a-day/abstract_class.html"
    "/Users/xah/web/sl/build_q.html"
    "/Users/xah/web/sl/q.html"
    "/Users/xah/web/UnixResource_dir/macosx.html"
    "/Users/xah/web/UnixResource_dir/writ/mshatredfaq.html"
    "/Users/xah/web/UnixResource_dir/writ/tabs_vs_spaces.html"
             )
    )
#+END_SRC

The =mapc= is a lisp idiom of applying a function to all elements in a
list. The first argument is a function. The second argument is a list.
The single quote in front of the function is necessary. It prevents the
function from being evaluated. Otherwise, normally lisp evaluates all
arguments in the expression =(f a b c ‚Ä¶)=.

(thanks to Ivanov Dmitry for a correction in the elisp code.)

Emacs ‚ô•

- [[file:elisp_text_processing.html][Elisp: Text Processing,
  Transforming Page Tag]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_process_html.html]]

\\
\\
| [[../index_u13.html#article_39][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u4.html>>

| [[../article_41/index_u25.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_40][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_39/index_u27.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Process HTML, span, code, Key, Title, Markups
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-08-29. Last updated: 2014-01-05.

This page is a tutorial, showing a real-world example of using emacs
lisp to do many tag transformation.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I need to transform many HTML tags. Typically, they are of the form
=begin_delimiter‚Ä¶end_delimiter=, where the delimiters may be curly
quotes =‚Äú‚Ä¶‚Äù=, or it may be a HTML tag such as
=<span class="xyz">‚Ä¶</span>=.

I need to apply the transformation on over 4 thousand HTML pages, and
needs it to be accurate, mostly on a case-by-case base with human watch.

Also, the delimiters may be nested, so regex won't work. They either
getting too much text (using default greedy match) or getting not enough
text (using shy group). With a elisp script, you can use =if= and other
emacs functions, to correctly find the matching ending tag, as well
automatically skip cases that this transform should not apply, so
drastically reduce the need for human watch.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

In the past week, i spend about 2 days and done a lot text processing
with elisp on the 4 thousand files of my site. Here's the changes i've
made:

- book title. For example: ‚ÄúArt Of Programing‚Äù ‚áí „ÄàArt Of Programing„Äâ
- article title. For example: ‚ÄúHow to Edit Elisp Code with Emacs‚Äù ‚áí
  „ÄàHow to Edit Elisp Code with Emacs„Äâ
- computer code. For example: ‚Äú(setq x 1)‚Äù ‚áí „Äå(setq x 1)„Äç
- file path. For example: ‚Äú~/Documents/emacs/‚Äù ‚áí „Äî~/Documents/emacs/„Äï
- keyboard shortcut notation. For example: ‚ÄúCtrl+c‚Äù ‚áí „ÄêCtrl+c„Äë

The purpose of the change is to make the syntactical markup more
semantically precise. Before, they are all marked by double curly
quotes. Now, if i want to find all books i cited on my site, i can do so
easily by a simple search on a special bracket for book titles. These
changes also make the text easier to read. In the future, if i want all
book titles to be colored red for example, i can easily do that by
changing the „Ää„Äã to a HTML markup (For example,
=<span class="title">‚Ä¶</span>=), or use a JavaScript to do that on the
fly. Same for emacs keybinding. For example, with this clear syntax,
it's easier to write a [[http://xahlee.info/js/js.html][JavaScript]] so
that when mouse is hovering over the keybinding notation, it shows a
balloon of the command name for that key. [see
[[http://xahlee.info/js/tooltips.html][JavaScript: How to Create
Tooltip/Balloon]]]

All this is part of the
[[http://xahlee.info/js/html_microformat.html][HTML Microformat]], which
is part of semantic web concept. The basic ideas is that, the syntax
encodes semantics. This advantage is part of the major reason XML
becomes so useful. (the other reason is its regular syntax.)

For info on various brackets used, see:
[[http://wordyenglish.com/musing/chinese_punctuation.html][Intro to
Chinese Punctuation]] and
[[http://xahlee.info/comp/unicode_matching_brackets.html][Matching
Brackets in Unicode]].

Also, much of the HTML markup on my site has been cleaned up. For
example:

- =<span class="code">‚Ä¶</span>= ‚áí =<code>‚Ä¶</code>=
- =‚Äú<span class="code">‚Ä¶</span>‚Äù= ‚áí =<code>‚Ä¶</code>= (Remove the
  redundant curly quote. Was a struggle to make a decision on this. Note
  that it can be auto added with
  [[http://xahlee.info/js/index.html][Cascading Style Sheet (CSS)]] if
  needed.)
- =<span class="key">‚Ä¶</span>= ‚áí =<kbd>‚Ä¶</kbd>= (Change to standard tag;
  reduce char count.)
- =<span class="kbd">‚Ä¶</span>= ‚áí =‚Ä¶= (Remove the tag. Was designed to
  mark emacs key notation, but doesn't make much sense. Now, „Äê„Äë does
  it.)

There are several advantages in these changes. For example, =<code>= is
much shorter than =<span class="code">=, and it has a standard meaning.
It is also more unique than ‚Äúspan‚Äù tag, so that reduce parsing
complexity when i need to process ‚Äúspan‚Äù tags.

[see
[[http://xahlee.info/kbd/keyboard_notation_design_issues.html][Keyboard
Notation Design Issues]]]

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

To do these tag transformations, simple cases such as

#+BEGIN_SRC emacs-lisp
    ‚Äúfile path‚Äù ‚áí „Äîfile path„Äï
#+END_SRC

, where the delimiters are single characters and there's no nesting,
they can be done with emacs's =dired-do-query-replace-regexp=. [see
[[file:find_replace_inter.html][Emacs: Find Replace Text in Directory]]]

More complicated cases with nested HTML tags, can be done with a elisp
script. Here's the general plan.

1. Open the file
2. Search for the tag
3. If found, move to the beginning of tag, mark positions of begin/end
   of the opening tag
4. Use =sgml-skip-tag-forward= to move to the end matching tag
5. Mark positions of begin/end of the ending tag
6. Replace the begin/end tags with new tags
7. Repeat

To open the file, we can use =find-file=.

To search for the tag, we do:

#+BEGIN_SRC emacs-lisp
    (while
     (search-forward "<span class=\"code\">"  nil t)
    ‚Ä¶
    )
#+END_SRC

We give ‚Äút‚Äù for the third argument. It means don't complain if not
found.

The next step is to get the begin/end positions of the opening tag. The
end position is simply the current cursor position, because the
search-forward automatically place it there. To get the beginning
position, we just use search-backward on ‚Äú<‚Äù

Now, we need to get the begin/end positions of the matching end tag.
This may be a problem because the tags are nested, so there may be many
=</span>= before the one we want.

The good thing is that emacs's =html-mode= has =sgml-skip-tag-forward=
function. It will move cursor from a beginning tag to its matching end
tag.

Once we got the begin/end positions for the begin/end tags, we can now
easily do replacement. Just use =delete-region=, then use =insert= to
insert the new tag we want. One thing important is that we should do
replacement with the ending tag first, because if we replace the
beginning tag first, the positions of the ending tag will be changed.

*** Complete Code
    :PROPERTIES:
    :CLASS: calibre14
    :END:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2010-08-25

    ;; change
    ;; <span class="code">‚Ä¶</span>
    ;; to
    ;; „Äå‚Ä¶„Äç

    (setq inputDir "~/web/xahlee_org/" ) ; dir should end with a slash

    (defun my-process-file (fPath)
      "process the file at fullpath fPath ‚Ä¶"
      (let ( myBuff changedQ p3 p4 p8 p9)

        ;; open the file
        ;; search for the tag
        ;; if found, move to the beginning of tag, mark positions of begin/end of < and >
        ;; use sgml-skip-tag-forward to move to the end matching tag </span>
        ;; mark positions of begin/end of < and >
        ;; replace them with „Äå and „Äç
        ;; repeat
        (setq myBuff (find-file fPath ) )
        (setq changedQ nil )

        (goto-char 1)
        (while
            (search-forward "<span class=\"code\">"  nil t)
          (backward-char 1)
          (if (looking-at ">")
              (setq p4 (1+ (point)) )
            (error "expecting <" )
            )

          ;; go to beginning of "<span class="code">"
          (sgml-skip-tag-backward 1)
          (if (looking-at "<")
              (setq p3 (point) )
            (error "expecting <" )
            )
          (forward-char 2)

          ;; go to end of </span>
          (sgml-skip-tag-forward 1)
          (backward-char 1)
          (if (looking-at ">")
              (setq p9 (1+ (point)) )
            (error "expecting >" )
            )

          ;; go to beginning of </span>
          (backward-char 6)
          (if (looking-at "<")
              (setq p8 (point) )
            (error "expecting <" )
            )

          (when (y-or-n-p "change? ")
            (delete-region p8 p9  )
            (insert "„Äç")
            (delete-region p4 p3 )
            (goto-char p3)
            (insert "„Äå")
            (setq changedQ t )
            ))

        ;; if not changed, close it. Else, leave buffer open
        (if changedQ
            (progn (make-backup))                        ; leave it open
          (progn (kill-buffer myBuff))
          )
        ))

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*span tag to code tag*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (princ "Done deal!")
        )
      )
#+END_SRC

In the code above, i also put extra checks to make sure that the
position of beginning tag is really the =<= char. Same for ending tag.
(probably redundant, but i tend to be extra careful.)

Also, i used a =y-or-n-p= function, so emacs will prompt me for each
change that i can visually check.

For those files that are changed, i leave them open. So, if i decided on
a whim i don't want all these to happen on potentially hundreds of files
that i've changed, i can simply close all the buffer with 4 keystrokes
with =ibuffer=. Same if i want to save them all. [see
[[file:emacs_buffer_management.html][Emacs: ibuffer tutorial]]]

For files that no change takes place, the buffer is simply closed.

In the above, i also called ‚Äúmake-backup‚Äù. I want to make a backup of
changed file, but not relying on emac's automatic backup mechanism (i
have it turned off). For the code, see:
[[file:elisp_make-backup.html][Emacs: Backup Current File]].

Emacs is fantastic!

- [[file:elisp_process_html.html][Process HTML with Emacs Lisp:
  Transform FAQ Tags]]
- [[file:elisp_text_processing.html][Elisp: Text Processing,
  Transforming Page Tag]]
- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_transform_html_tags.html]]

\\
\\
| [[../index_u13.html#article_40][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u25.html>>

| [[../article_42/index_u32.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_41][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_40/index_u4.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Batch Transform HTML to HTML5 ‚Äúfigure‚Äù Tag
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-03

Another triumph of using elisp for text processing over {Perl, Python}.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want batch transform the image tags in 5 thousand HTML files to use
HTML5's new ‚Äúfigure‚Äù and ‚Äúfigcaption‚Äù tags.

I want to be able to view each change interactively, while optionally
give it a ‚Äúgo ahead‚Äù to do the whole job in batch.

Interactive eyeball verification on many cases lets me be reasonably
sure the transform is done correctly. It also lets me see whether i want
to push forward with this change.

*** Detail
    :PROPERTIES:
    :CLASS: calibre14
    :END:

[[http://xahlee.info/js/html5_tags.html][HTML5]] has the following new
tags: ‚Äúfigure‚Äù and ‚Äúfigcaption‚Äù. They are used like this:

#+BEGIN_SRC emacs-lisp
    <figure>
    <img src="cat.jpg" alt="my cat" width="167" height="106">
    <figcaption>my cat!</figcaption>
    </figure>
#+END_SRC

(For detail, see:
[[http://xahlee.info/js/html5_figure_figurecaption.html][HTML5 ‚Äúfigure‚Äù
and ‚Äúfigurecaption‚Äù Tags Browser Support]])

On my website, i used a similar structure. They look like this:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="cat.jpg" alt="my cat" width="167" height="106">
    <p class="cpt">my cat!</p>
    </div>
#+END_SRC

So, i want to replace them with the HTML5's new tags. This can be done
with a regex. Here's the ‚Äúfind‚Äù regex:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    ?<img src="\([^"]+?\)" alt="\([^"]+?\)" width="\([0-9]+?\)" height="\([0-9]+?\)">?
    <p class="cpt">\([^<]+?\)</p>
    ?</div>
#+END_SRC

Here's the replacement string:

#+BEGIN_SRC emacs-lisp
    <figure>
    <img src="\1" alt="\2" width="\3" height="\4">
    <figcaption>\5</figcaption>
    </figure>
#+END_SRC

Then, you can use =find-dired= and dired's
=dired-do-query-replace-regexp= to work on your 5 thousand pages. Nice.
[see [[file:find_replace_inter.html][Emacs: Find Replace Text in
Directory]]]

However, the problem here is more complicated. There may be more than
one image per group. Also, the caption part may also contain complicated
HTML. Here's some examples:

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="cat1.jpg" alt="my cat" width="200" height="200">
    <img src="turtle.jpg" alt="my turtle" width="200" height="200">
    <p class="cpt">my cat and my turtle</p>
    </div>
#+END_SRC

#+BEGIN_SRC emacs-lisp
    <div class="img">
    <img src="jamie_cat.jpg" alt="jamie's cat" width="167" height="106">
    <p class="cpt">jamie's cat! Her blog is <a href="http://example.com/jamie/">http://example.com/jamie/</a></p>
    </div>
#+END_SRC

So, a solution by regex is out.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

The solution is pretty simple. Here's the major steps:

1. Use =find-lisp-find-files= to traverse a dir. Needes
   =(require 'find-lisp)=.
2. For each file, open it.
3. Search for the string =<div class="img">=.
4. Use =sgml-skip-tag-forward= to jump to its closing tag.
5. Save the positions of these tag begin/end positions.
6. Ask user if she wants to replace. If so, do it. (using
   =delete-region= and =insert=)
7. Repeat.

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-07-03
    ;; replace image tags to use HTML5's ‚Äúfigure‚Äù  and ‚Äúfigcaption‚Äù tags.

    ;; Example. This:
    ;; <div class="img">‚Ä¶</div>
    ;; should become this
    ;; <figure>‚Ä¶</figure>

    ;; do this for all files in a dir.

    ;; rough steps:
    ;; find the <div class="img">
    ;; use sgml-skip-tag-forward to move to the ending tag.
    ;; save their positions.
    ;; ask user whether to replace, if so, delete them and insert new string

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (myBuff p1 p2 p3 p4 )
        (setq myBuff (find-file fPath))

        (widen)
        (goto-char 1) ;; in case buffer already open

        (while (search-forward "<div class=\"img\">" nil t)
          (progn
            (setq p2 (point) )
            (backward-char 17) ; beginning of ‚Äúdiv‚Äù tag
            (setq p1 (point) )

            (forward-char 1)
            (sgml-skip-tag-forward 1) ; move to the closing tag
            (setq p4 (point) )
            (backward-char 6) ; beginning of the closing div tag
            (setq p3 (point) )
            (narrow-to-region p1 p4) 

            (when (y-or-n-p "replace?")
              (progn 
                (delete-region p3 p4 )
                (goto-char p3)
                (insert "</figure>")

                (delete-region p1 p2 )
                (goto-char p1)
                (insert "<figure>")
                (widen) ) ) ) )

        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )

        ) )

    (require 'find-lisp)

    (let (outputBuffer)
      (setq outputBuffer "*xah img/figure replace output*" )
      (with-output-to-temp-buffer outputBuffer 
        (mapc 'my-process-file (find-lisp-find-files "~/web/xahlee_org/emacs/" "\\.html$"))
        (princ "Done deal!")
        ) )
#+END_SRC

Seems pretty simple right?

The ‚Äúp1‚Äù and ‚Äúp2‚Äù variables are the positions of start/end of
=<div class="img">=. The ‚Äúp3‚Äù and ‚Äúp4‚Äù is the start/end of its closing
tag =</div>=.

We also used a little trick with =widen= and =narrow-to-region=. It lets
me see just the part that i'm interested. It narrows to the
beginning/end of the div.img. This makes eyeballing a bit easier.

The real time-saver is the =sgml-skip-tag-forward= function from
=html-mode=. Without that, one'd have to write a mini-parser to deal
with HTML's nested ways to be able to locate the proper ending tag.

Using the above code, i can comfortably eyeball and press ‚Äúy‚Äù at the
rate of about 5 per second. That makes 300 replacements per minute. I
have 5000+ files. If we assume there are 6k replacement to be made, then
at 5 per second means 20 minutes sitting there pressing ‚Äúy‚Äù. Quite
tiresome.

So, now, the next step is simply to remove the asking
=(y-or-n-p "replace?")=. Or, if i'm absolutely paranoid, i can make
emacs write into a log buffer for every replacement it makes (together
with the file path). When the batch replacement is done (probably takes
1 or 2 minutes), i can simply scan thru the log to see if any
replacement went wrong. For a example of that, see:
[[file:elisp_replace_title_tags.html][Elisp: Multi-Pair String
Replacement with Report]].

Also note that i left each changed file unsaved in emacs. If i decided i
didn't want to commit the changes, i can exit emacs without saving. Or,
i can go to =ibuffer= and press 3 keys to save and close them all * u S.
But if you want them saved with elisp, you can just add =(save-buffer)=.
Note that emacs automatically makes a backup~ of the original files if
you haven't turned that off.

But what about replacing =<p class="cpt">‚Ä¶</p>= with
=<figcaption>‚Ä¶</figcaption>=?

I simply copy-pasted the above code into a new file, and make changes in
4 places. So, the replacing figcaption part is done in a separete second
batch job. Of course, one could spend extra hour to make the code do
them both in one pass, but that extra time of thinking and coding isn't
worthwhile for this one-time job.

I ‚ô• Emacs, do you?

*** Change in Current Buffer
    :PROPERTIES:
    :CLASS: calibre14
    :END:

Here's the code that changes both {div.img, p.cpt} to {figure,
figcaption} in one shot, on the current buffer. It output the changes to
a temp buffer, so you can scan it.

#+BEGIN_SRC emacs-lisp
    (defun xah-fix-wrap-img-figure ()
      "Change current buffer's <div class=\"img\"> to <figure> and <p class=\"cpt\"> to <figcaption>."
      (interactive)

      (save-excursion 
        (let (p1 p2 p3 p4 
                 myStr
                 $changes
                 (changedItems '())
                 (myBuff (current-buffer))
                 )

          (goto-char (point-min)) ;; in case buffer already open
          (while (search-forward "<div class=\"img\">" nil t)
            (progn
              (setq p2 (point) )
              (backward-char 17)
              (setq p1 (point) )

              (forward-char 1)
              (sgml-skip-tag-forward 1)
              (setq p4 (point) )
              (backward-char 6)
              (setq p3 (point) )

              (when t
                (setq myStr (buffer-substring-no-properties p1 p4))
                (setq changedItems (cons myStr changedItems ) )
                
                (progn 
                  (delete-region p3 p4 )
                  (goto-char p3)
                  (insert "</figure>")

                  (delete-region p1 p2 )
                  (goto-char p1)
                  (insert "<figure>")
                   )
                ) ) )

          (goto-char (point-min)) ;; in case buffer already open
          (while (search-forward "<p class=\"cpt\">" nil t)
            (progn
              (setq p2 (point) )
              (backward-char 15)
              (setq p1 (point) )

              (forward-char 1)
              (sgml-skip-tag-forward 1)
              (setq p4 (point) )
              (backward-char 4)
              (setq p3 (point) )

              (when t
                (setq myStr (buffer-substring-no-properties p1 p4))
                (setq changedItems (cons myStr changedItems ) )
                
                (progn 
                  (delete-region p3 p4 )
                  (goto-char p3)
                  (insert "</figcaption>")

                  (delete-region p1 p2 )
                  (goto-char p1)
                  (insert "<figcaption>")
                   )
                ) ) )

          (with-output-to-temp-buffer "*changed items*" 
            (mapc (lambda ( $changes) (princ $changes) (princ "\n\n") ) changedItems)
            (set-buffer "*changed items*")
            (funcall 'html-mode)
            (set-buffer myBuff)
            ) )) )
#+END_SRC

PS if you are wondering about that weird char ‚ÄúŒæ‚Äù in the variable name,
don't mind it, it's my personal experiment in variable naming. See:
[[http://xahlee.info/comp/programing_variable_naming.html][Variable
Naming: English Words Considered Harmful]].

- [[file:elisp_text_processing_lang.html][Text Processing: Emacs Lisp vs
  Perl]]
- [[file:elisp_batch_html_tag_transform_bold.html][Elisp: Processing
  HTML: Transform Tags from ‚Äúspan.w‚Äù to ‚Äúb‚Äù]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_batch_html5_tag_transform.html]]

\\
\\
| [[../index_u13.html#article_41][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u32.html>>

| [[../article_43/index_u1.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_42][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_41/index_u25.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: Transform HTML Tags from ‚Äúspan‚Äù to ‚Äúb‚Äù
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2011-07-18. Last updated: 2017-06-17.

This page shows a simple practical elisp script for HTML tag
transformation.

** Problem
   :PROPERTIES:
   :CLASS: calibre17
   :END:

I want transform the HTML tag

=<span class="w">‚Ä¶</span>=

to

=<b>‚Ä¶</b>=

, for over a hundred files. Also, print a report of the changes.

** Solution
   :PROPERTIES:
   :CLASS: calibre17
   :END:

Here's outline of steps.

1. Open the file. Use regex to search the span markup.
2. Make the replacement.
3. Add the replacement to a list, for later report.
4. Repeat the above until no more found.
5. Use a dir traverse function to apply the above to every file. [see
   [[file:elisp_traverse_dir.html][Elisp: Walk Directory]]]
6. When done, print the list of changes.

Here's the code:

#+BEGIN_SRC emacs-lisp
    ;; -*- coding: utf-8 -*-
    ;; 2011-07-18
    ;; replace <span class="w">‚Ä¶</span> to <b>‚Ä¶</b>
    ;;
    ;; do this for all files in a dir.

    (setq inputDir "~/web/vocabulary/" ) ; dir should end with a slash

    (setq changedItems '())

    (defun my-process-file (fPath)
      "Process the file at FPATH ‚Ä¶"
      (let (myBuff myWord)
        (setq myBuff (find-file fPath))

        (widen) (goto-char 1) ;; in case buffer already open

        (while (re-search-forward "<span class=\"w\">\\([^<]+?\\)</span>" nil t)
          (setq myWord (match-string 1))
          (when (< (length myWord) 15) ; a little double check in case of possible mismatched tag
            (replace-match (concat "<b>" myWord "</b>" )  t)
            (setq changedItems (cons (substring-no-properties myWord) changedItems ) )
            ) )

        ;; close buffer if there's no change. Else leave it open.
        (when (not (buffer-modified-p myBuff)) (kill-buffer myBuff) )
        ) )

    (require 'find-lisp)

    (setq make-backup-files t)
    (setq case-fold-search nil)
    (setq case-replace nil)

    (let (outputBuffer)
      (setq outputBuffer "*xah span.w to b replace output*" )
      (with-output-to-temp-buffer outputBuffer
        (mapc 'my-process-file (find-lisp-find-files inputDir "\\.html$"))
        (print changedItems)
        (princ "Done deal!")
        )
      )
#+END_SRC

Here's the output:
[[file:elisp_batch_html_tag_transform_bold_output.txt]].

There are over 1k changes. The output is extremely useful because i can
just take a few seconds to glance at the output to know there are no
errors. Errors are possible because whenever using regex to parse HTML,
a missing tag in HTML or even a unexpected nested tag, can mean
disaster.

The code is simple. If you don't understand it, see:

- [[file:elisp_idioms_batch.html][Elisp: Writing Elisp Script]]
- [[file:elisp_idioms.html][Elisp: How to Write Commands]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_batch_html_tag_transform_bold.html]]

\\
\\
| [[../index_u13.html#article_42][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u1.html>>

| [[../article_44/index_u12.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_43][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_42/index_u32.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Elisp: How to Write a Toggle Command
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-03-20. Last updated: 2020-04-19.

This page is a tutorial on how to write a command to toggle something.

Here's a example to toggle background color.

#+BEGIN_SRC emacs-lisp
    (defun xah-toggle-background-color ()
      "Toggle background color between seashell and honeydew.
    URL `http://ergoemacs.org/emacs/elisp_toggle_command.html'
    Version 2015-12-17"
      (interactive)
      ;; use a property ‚Äústate‚Äù. Value is t or nil
      (if (get 'xah-toggle-background-color 'state)
          (progn
            (set-background-color "seashell")
            (put 'xah-toggle-background-color 'state nil))
        (progn
          (set-background-color "honeydew")
          (put 'xah-toggle-background-color 'state t))))
#+END_SRC

The gist to toggle, is to have a variable that we can set as current
state.

But usually, we don't want to use a global variable.

The trick here, is to create a property for the function. In Emacs lisp,
each symbol can have one or more properties. A property is basically a
variable, but associated with the symbol only.

[see [[file:elisp_symbol_plist.html][Elisp: Symbol Property List]]]

Here, we create a property named ‚Äústate‚Äù. The value is =t= or =nil=.

** Cycle Among States
   :PROPERTIES:
   :CLASS: calibre17
   :END:

You can create a command that cycle between many states.

Here's a example.

#+BEGIN_SRC emacs-lisp
    (defun xah-cycle-background-color (@n)
      "Cycle background color among a preset list.

    If `universal-argument' is called first, cycle n steps. Default is 1 step.

    URL `http://ergoemacs.org/emacs/elisp_toggle_command.html'
    Version 2015-12-17"
      (interactive "p")
      ;; uses a property ‚Äústate‚Äù. Value is a integer.
      (let* (
             ($values ["cornsilk" "pale green" "pale turquoise" "thistle" "seashell" "honeydew"])
             ($index-before
              (if (get 'xah-cycle-background-color 'state)
                  (get 'xah-cycle-background-color 'state)
                0))
             ($index-after (% (+ $index-before (length $values) @n) (length $values)))
             ($next-value (aref $values $index-after)))

        (put 'xah-cycle-background-color 'state $index-after)

        (set-background-color $next-value)
        (message "background color changed to %s" $next-value)))
#+END_SRC

Here, we create a property named ‚Äústate‚Äù. The value is a integer.

In the function body, we have a variable that is the list of possible
values. The property ‚Äústate‚Äù, is used as index to this list.

Each time the command is called, we check current state, then, use
modular arithmetic over the length of states list to get the next value
(integer index). Then, we set the value, and update the state.

To create your own cycle something command, simply change the value list
to what you want.

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_toggle_command.html]]

\\
\\
| [[../index_u13.html#article_43][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u12.html>>

| [[../article_45/index_u34.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_44][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_43/index_u1.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Uncolor Region/Buffer
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2010-01-09. Last updated: 2017-05-31.

Normally, you can Alt+x =font-lock-mode= to turn off syntax coloring.

But if you copied some text from another buffer into a new buffer,
turning off =font-lock-mode= won't remove existing coloring.

Here's a command that lets removes syntax coloring.

#+BEGIN_SRC emacs-lisp
    (defun xah-unfontify-region-or-buffer ()
      "Unfontify text selection or buffer.
    URL `http://ergoemacs.org/emacs/elisp_uncolor_region.html'
    Version 2017-05-31"
      (interactive)
      (if (use-region-p)
          (font-lock-unfontify-region (region-beginning) (region-end))
        (font-lock-unfontify-buffer)))
#+END_SRC

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/elisp_uncolor_region.html]]

\\
\\
| [[../index_u13.html#article_44][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |

<<index_u34.html>>

| [[../../feed_1/index.html][‰∏ã‰∏ÄÈ°π]] |
[[../index_u13.html#article_45][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
[[../article_44/index_u12.html][‰∏ä‰∏ÄÈ°π]] |

--------------

* Emacs: Setup Mouse Click to Highlight Matching Words
  :PROPERTIES:
  :CLASS: calibre9
  :END:

By Xah Lee. Date: 2014-03-11. Last updated: 2016-07-18.

You can set mouse right-click to call =isearch-forward-symbol-at-point=
(highlight clicked word).

Here's the command.

#+BEGIN_SRC emacs-lisp
    (defun xah-mouse-click-to-search (@click)
      "Mouse click to start `isearch-forward-symbol-at-point' (emacs 24.4) at clicked point.
    URL `http://ergoemacs.org/emacs/emacs_mouse_click_highlight_word.html'
    Version 2016-07-18"
      (interactive "e")
      (let ((p1 (posn-point (event-start @click))))
        (goto-char p1)
        (isearch-forward-symbol-at-point)))
#+END_SRC

Here's the code to set the mouse (this example is for Linux only):

#+BEGIN_SRC emacs-lisp
    ;; set mouse
    (cond
     ((string-equal system-type "windows-nt") ; Windows
      nil
      )
     ((string-equal system-type "gnu/linux")
      (global-set-key (kbd "<mouse-3>") 'xah-click-to-search) ; right button
      )
     ((string-equal system-type "darwin") ; Mac
      nil
      ) )
#+END_SRC

Note: mouse button and wheel have different syntax on {Microsoft
Windows, Mac OS X, Linux}. To find the syntax, Alt+x =describe-key=,
then press the button or wheel. [see
[[file:emacs_mouse_wheel_config.html][Emacs: Mouse Config]]]

If you have a question, put $5 at
[[https://www.patreon.com/xahlee][patreon]] and message me.\\
Or [[http://ergoemacs.org/emacs/buy_xah_emacs_tutorial.html][Buy Xah
Emacs Tutorial]]\\
Or buy [[http://xahlee.info/js/js.html][JavaScript in Depth]]

--------------

This article was downloaded by *calibre* from
[[http://ergoemacs.org/emacs/emacs_mouse_click_highlight_word.html]]

\\
\\
| [[../index_u13.html#article_45][ÊÆµËêΩËèúÂçï]] |
[[../../index_u11.html#feed_0][‰∏ªËèúÂçï]] |
