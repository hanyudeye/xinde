* 对象
*** window 对象 代表一个浏览器窗口或一个框架(当前对象[全局对象]),
**** 属性
closed 	返回窗口是否已被关闭
defaultStatus 	设置或返回窗口状态栏中的默认文本
document 	对 Document 对象的只读引用。请参阅 Document 对象。
history 	对 History 对象的只读引用。请参数 History 对象。 
innerheight 	返回窗口的文档显示区的高度。
innerwidth 	返回窗口的文档显示区的宽度。
length 	设置或返回窗口中的框架数量。
location 	用于窗口或框架的 Location 对象。请参阅 Location 对象。 
name 	            设置或返回窗口的名称。
Navigator 	对 Navigator 对象的只读引用。请参数 Navigator 对象。
opener 	返回对创建此窗口的窗口的引用。 	
outerheight 	返回窗口的外部高度。 
outerwidth 	返回窗口的外部宽度。 
pageXOffset 	设置或返回当前页面相对于窗口显示区左上角的 X 位置。
pageYOffset 	设置或返回当前页面相对于窗口显示区左上角的 Y 位置。
parent 	返回父窗口。 	
Screen 	对 Screen 对象的只读引用。请参数 Screen 对象。
self 	            返回对当前窗口的引用。等价于 Window 属性。 	
status 	            设置窗口状态栏的文本。
top 	            返回最顶层的先辈窗口。
window 	window 属性等价于 self 属性，它包含了对窗口自身的引用。
screenLeft        IE、Safari 和 Opera 支持 screenLeft 和 screenTop
screenTop
screenX             Firefox 和 Safari 支持 screenX 和 screenY。   
screenY             只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。

**** 方法
alert() 	           显示带有一段消息和一个确认按钮的警告框。
blur() 	           把键盘焦点从顶层窗口移开。
clearInterval() 	取消由 setInterval() 设置的 timeout。 
clearTimeout() 取消由 setTimeout() 方法设置的 timeout。
close() 	关闭浏览器窗口。 
confirm() 	显示带有一段消息以及确认按钮和取消按钮的对话框。
createPopup() 	创建一个 pop-up 窗口
focus() 	把键盘焦点给予一个窗口
moveBy() 	可相对窗口的当前坐标把它移动指定的像素
moveTo() 	把窗口的左上角移动到一个指定的坐标。
open() 	打开一个新的浏览器窗口或查找一个已命名的窗口
print()    	打印当前窗口的内容。
prompt() 	显示可提示用户输入的对话框。 
resizeBy() 	按照指定的像素调整窗口的大小。
resizeTo() 	把窗口的大小调整到指定的宽度和高度。
scrollBy() 	按照指定的像素值来滚动内容。 
scrollTo() 	把内容滚动到指定的坐标。
setInterval() 	按照指定的周期（以毫秒计）来调用函数或计算表达式。
setTimeout() 	在指定的毫秒数后调用函数或计算表达式。
*** Navigator JavaScript对象
**** 属性
appCodeName 	返回浏览器的代码名。 
appMinorVersion 	返回浏览器的次级版本。
appName 	返回浏览器的名称。 
appVersion 	返回浏览器的平台和版本信息。
browserLanguage 	返回当前浏览器的语言。
cookieEnabled 	返回指明浏览器中是否启用 cookie 的布尔值。
cpuClass 	返回浏览器系统的 CPU 等级。 
onLine 	返回指明系统是否处于脱机模式的布尔值。
platform 	返回运行浏览器的操作系统平台。 
systemLanguage 	返回 OS 使用的默认语言。
userAgent 	返回由客户机发送服务器的 user-agent 头部的值。 
userLanguage 	返回 OS 的自然语言设置。
**** 方法
javaEnabled() 	规定浏览器是否启用 Java。
taintEnabled() 	规定浏览器是否启用数据污点 (data tainting)
*** screen
**** 属性
availHeight 	返回显示屏幕的高度 (除 Windows 任务栏之外)。
availWidth 	返回显示屏幕的宽度 (除 Windows 任务栏之外)。 
bufferDepth 	设置或返回在 off-screen bitmap buffer 中调色板的比特深度。
colorDepth 	返回目标设备或缓冲器上的调色板的比特深度。
deviceYDPI 	返回显示屏幕的每英寸垂直点数。 
fontSmoothingEnabled 	返回用户是否在显示控制面板中启用了字体平滑
height 	返回显示屏幕的高度。 
logicalXDPI 	返回显示屏幕每英寸的水平方向的常规点数。 
logicalYDPI 	返回显示屏幕每英寸的垂直方向的常规点数。 
pixelDepth 	返回显示屏幕的颜色分辨率（比特每像素）
width 	            返回显示器屏幕的宽度。 
*** history
**** 属性
length              返回浏览器历史列表中的 URL 数量
**** 方法
back() 	            加载 history 列表中的前一个 URL 	
forward() 	加载 history 列表中的下一个 URL 
go() 	            加载 history 列表中的某个具体页面 [Num|URL] e: -1 前一个页面	
*** Location
**** 属性
hash 	            设置或返回从井号 (#) 开始的 URL（锚）。
host 	            设置或返回主机名和当前 URL 的端口号。 
hostname 	设置或返回当前 URL 的主机名。 
href 	            设置或返回完整的 URL。
pathname 	设置或返回当前 URL 的路径部分。 
port 	            设置或返回当前 URL 的端口号。
protocol 	设置或返回当前 URL 的协议。 
search 	设置或返回从问号 (?) 开始的 URL（查询部分）。
**** 方法
assign() 	加载新的文档。 
reload() 	重新加载当前文档。
replace() 	用新的文档替换当前文档。 
*** document
**** 集合
all[]       	提供对文档中所有 HTML 元素的访问。 document.all[0],不会用样式,script
anchors[] 	返回对文档中所有 Anchor 对象的引用。 
applets 	返回对文档中所有 Applet 对象的引用。
forms[] 	返回对文档中所有 Form 对象引用。
images[] 	返回对文档中所有 Image 对象引用。
links[] 	            返回对文档中所有 Area 和 Link 对象引用。
**** 属性
body    	提供对 <body> 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 <frameset>。 	  	  	  	 
cookie 	设置或返回与当前文档有关的所有 cookie。
domain 	返回当前文档的域名。 	
lastModified 	返回文档被最后修改的日期和时间。 该值来自于 Last-Modified HTTP 头部，它是由 Web 服务器发送的可选项	
referrer 	返回载入当前文档的文档的 URL。
title 	            返回当前文档的标题。 
URL 	            返回当前文档的 URL。 
**** 方法
close() 	           关闭用 document.open() 方法打开的输出流，并显示选定的数据。 
getElementById() 	返回对拥有指定 id 的第一个对象的引用。
getElementsByName() 	返回带有指定名称的对象集合。 	
getElementsByTagName() 	返回带有指定标签名的对象集合。
getElementsByClassName() 	返回带有指定 class 的对象集合。
open() 	           打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。
write()    	向文档写 HTML 表达式 或 JavaScript 代码。 
writeln() 	等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 
#+BEGIN_SRC javascript
<script type="text/javascript">
function createNewDoc()
  {
  var newDoc=document.open("text/html","replace");
  var txt="<html><body>学习 DOM 非常有趣！</body></html>";
  newDoc.write(txt);
  newDoc.close();
  }
</script>
#+END_SRC
*** 公共属性
className 	Sets or returns the class attribute of an element
dir 	(设置文字方向) ltr默认。从左向右的文本方向。rtl 	从右向左的文本方向。	
lang 	Sets or returns the language code for an element
title 	Sets or returns an element's advisory title 
*** document.forms[0] 文档中第一个表单节点
**** 集合
elements[] 	包含表单中所有元素的数组。
**** 属性
acceptCharset 	服务器可接受的字符集。 
action    	设置或返回表单的 action 属性。 
enctype 	设置或返回表单用来编码内容的 MIME 类型。 	
id        	设置或返回表单的 id。 
length 	返回表单中的元素数目。 
method 	设置或返回将数据发送到服务器的 HTTP 方法。
name   	设置或返回表单的名称。 
target   	设置或返回表单提交结果的 Frame 或 Window 名。

**** 方法
reset() 	把表单的所有输入元素重置为它们的默认值。 
submit() 	提交表单。
**** 事件
onreset 	在重置表单元素之前调用。 
onsubmit 	在提交表单之前调用。 
*** images
**** 属性
align    	设置或返回与内联内容的对齐方式。 
border 	设置或返回图像周围的边框。
complete 	返回浏览器是否已完成对图像的加载。 
height 	设置或返回图像的高度。 
hspace 	设置或返回图像左侧和右侧的空白。
id        	设置或返回图像的 id。
isMap  	返回图像是否是服务器端的图像映射。
longDesc 	设置或返回指向包含图像描述的文档的 URL。 
lowsrc 	设置或返回指向图像的低分辨率版本的 URL。
name   	设置或返回图像的名称。 
src       	设置或返回图像的 URL。
useMap 	设置或返回客户端图像映射的 usemap 属性的值。 
vspace 	设置或返回图像的顶部和底部的空白。 
width   	设置或返回图像的宽度。 
**** 事件
onabort 	当用户放弃图像的装载时调用的事件句柄。
onerror 	在装载图像的过程中发生错误时调用的事件句柄。
onload 	当图像装载完毕时调用的事件句柄。
*** link  元素可定义两个链接文档之间的关系,包括超链接
**** 属性
charset 	设置或返回目标 URL 的字符编码 	
disabled 	设置或返回目标 URL 是否当被禁用 	
href 	            设置或返回被链接资源的 URL 
hreflang 	设置或返回目标 URL 的基准语言 	
id 	设置或返回某个 <link> 元素的 id 	
media 	设置或返回文档显示的设备类型 	
name 	设置或返回 <link> 元素的名称 
rel 	设置或返回当前文档与目标 URL之间的关系 
rev 	设置或返回目标 URL 与当前文档之间的关系 
type 	设置或返回目标 URL 的 MIME 类型 
*** meta 元信息
**** 属性
content 	设置或返回 <meta> 元素的 content 属性的值
httpEquiv 	把 content 属性连接到一个 HTTP 头部 	
name  	把 content 属性连接到某个名称 	
scheme 	设置或返回用于解释 content 属性的值的格式 
*** Style 对象代表一个单独的样式声明。可从应用样式的文档或元素访问Style 对象
document.getElementById("id").style.property="值"
**** 属性
***** 背景
background 	在一行中设置所有的背景属性 
backgroundAttachment 	设置背景图像是否固定或随页面滚动 
backgroundColor 	设置元素的背景颜色 
backgroundImage 	设置元素的背景图像 
backgroundPosition 	设置背景图像的起始位置 
backgroundPositionX 	设置backgroundPosition属性的X坐标 
backgroundPositionY 	设置backgroundPosition属性的Y坐标 
backgroundRepeat 	设置是否及如何重复背景图像
***** 边框和边距
border             	在一行设置四个边框的所有属性 	
borderBottom  	在一行设置底边框的所有属性 
borderBottomColor 	设置底边框的颜色 	
borderBottomStyle 	设置底边框的样式 	
borderBottomWidth 	设置底边框的宽度 	
borderColor     	设置所有四个边框的颜色 (可设置四种颜色) 	
borderLeft       	在一行设置左边框的所有属性 
borderLeftColor 	设置左边框的颜色 	
borderLeftStyle 	设置左边框的样式 	
borderLeftWidth 	设置左边框的宽度 	
borderRight 	            在一行设置右边框的所有属性
borderRightColor 	设置右边框的颜色 	
borderRightStyle 	设置右边框的样式 	
borderRightWidth 	设置右边框的宽度 	
borderStyle 	            设置所有四个边框的样式 (可设置四种样式) 
borderTop 	            在一行设置顶边框的所有属性 
borderTopColor 	设置顶边框的颜色 		
borderTopStyle 	设置顶边框的样式 		
borderTopWidth 	设置顶边框的宽度 		
borderWidth 	设置所有四条边框的宽度 (可设置四种宽度) 
margin 	设置元素的边距 (可设置四个值)
marginBottom 设置元素的底边距
marginLeft 	设置元素的左边距 	
marginRight 	设置元素的右边据
marginTop 	设置元素的顶边距 	
outline 	在一行设置所有的outline属性 
outlineColor 	设置围绕元素的轮廓颜色 	
outlineStyle 	设置围绕元素的轮廓样式 	
outlineWidth 	设置围绕元素的轮廓宽度 	
padding 	设置元素的填充 (可设置四个值)
paddingBottom设置元素的下填充
paddingLeft 	设置元素的左填充
paddingRight 	设置元素的右填充
paddingTop 	设置元素的顶填充 	
***** 布局
clear    	设置在元素的哪边不允许其他的浮动元素 	
clip      	设置元素的形状 	
content 	设置元信息 	
counterIncrement 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器的增量。默认是1。
counterReset 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器被设置的值。默认是0。
cssFloat 	设置图像或文本将出现（浮动）在另一元素中的何处。 	
cursor   	设置显示的指针类型 
direction 	设置元素的文本方向 	
display 	设置元素如何被显示 	inherit父的属性继承
height 	设置元素的高度 
markerOffset 	设置marker box的principal box距离其最近的边框边缘的距离
marks 	            设置是否cross marks或crop marks应仅仅被呈现于page box边缘之外 	
maxHeight 	设置元素的最大高度 	
maxWidth 	设置元素的最大宽度 	
minHeight 	设置元素的最小高度 	
minWidth 	设置元素的最小宽度 	
****** overflow 	规定如何处理不适合元素盒的内容 	
overflow-x: hidden;隐藏水平滚动条
verticalAlign 	设置对元素中的内容进行垂直排列 
visibility 	设置元素是否可见 
width 	            设置元素的宽度
***** 列表
listStyle 	在一行设置列表的所有属性 
listStyleImage 	把图像设置为列表项标记 
listStylePosition改变列表项标记的位置 	
listStyleType 	设置列表项标记的类型
***** 定位
bottom 	设置元素的底边缘距离父元素底边缘的之上或之下的距离 	
left       	置元素的左边缘距离父元素左边缘的左边或右边的距离 	
position 	把元素放置在static, relative, absolute 或 fixed 的位置 	
right 	            置元素的右边缘距离父元素右边缘的左边或右边的距离 	
top 	            设置元素的顶边缘距离父元素顶边缘的之上或之下的距离 	
zIndex 	设置元素的堆叠次序
***** 文本
color 	设置文本的颜色 
font 	在一行设置所有的字体属性 
fontFamily 	设置元素的字体系列。
fontSize 	设置元素的字体大小。
fontSizeAdjust 	设置/调整文本的尺寸 
fontStretch 	设置如何紧缩或伸展字体
fontStyle 	设置元素的字体样式 
fontVariant 	用小型大写字母字体来显示文本 
fontWeight 	设置字体的粗细 
letterSpacing 	设置字符间距 
lineHeight 	设置行间距 
quotes 	设置在文本中使用哪种引号 
textAlign 	排列文本 
textDecoration 	设置文本的修饰 
textIndent 	缩紧首行的文本 
textShadow 	设置文本的阴影效果
textTransform 	对文本设置大写效果 
whiteSpace 	设置如何设置文本中的折行和空白符 	
wordSpacing 	设置文本中的词间距 
***** Table 
borderCollapse 	设置表格边框是否合并为单边框，或者像在标准的HTML中那样分离。 
borderSpacing 	设置分隔单元格边框的距离 
captionSide 	设置表格标题的位置 	
emptyCells 	设置是否显示表格中的空单元格
tableLayout 	设置用来显示表格单元格、行以及列的算法
*** node
**** 节点属性
***** innerHTML: 获取元素内容,很多东西
***** nodeName 规定节点的名称
***** nodeValue 规定节点的值 (文本节点有值)
***** nodeType 返回节点的类型。nodeType 是只读的
#+BEGIN_SRC 
元素 	1
属性 	2
文本 	3
注释 	8
文档 	9
#+END_SRC
: 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
****  修改
***** 创建新的 HTML 元素
#+BEGIN_SRC 
var para=document.createElement("p");
var node=document.createTextNode("This is new.");
para.appendChild(node);
#+END_SRC
**** HTML DOM - 元素
***** 创建新的 HTML 元素 - appendChild()您首先必须创建该元素，然后把它追加到已有的元素上。
***** 创建新的 HTML 元素 - insertBefore()
***** 删除已有的 HTML 元素
#+BEGIN_SRC 
var child=document.getElementById("p1");
child.parentNode.removeChild(child);
#+END_SRC
***** 替换 HTML 元素
: 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：
#+BEGIN_SRC 
var parent=document.getElementById("div1");
var child=document.getElementById("p1");
parent.replaceChild(para,child);
#+END_SRC

**** HTML DOM事件
***** window 事件属性
+ onload 页面结束加载之后触发。   
+ onresize  当浏览器窗口被调整大小时触发。 
***** FORM 事件
+ onselect      script 在元素中文本被选中后触发。            
+ onsubmit      script 在提交表单时触发。                   
***** 键盘事件
+ onkeydown  script 在用户按下按键时触发。
+ onkeypress script 在用户敲击按钮时触发。
+ onkeyup    script 当用户释放按键时触发。
***** Mouse事件
+ onclick
+ ondblclick
+ onmousedown
+ onscroll
***** Media事件
+ onabort
+ onplay
***** onmousedown、onmouseup 以及 onclick 事件
**** HTML DOM导航
***** 根节点
: document.documentElement - 全部文档
: document.body - 文档的主体

***** 节点列表
#+BEGIN_SRC 
 var x=document.getElementsByTagName("p");
可以通过下标号访问这些节点。如需访问第二个 <p>，您可以这么写：
y=x[1]; 
#+END_SRC
***** length 属性定义节点列表中节点的数量

*** console用来可以查看错误信息、打印调试信息、调试js代码，还可以当作Javascript API查看
**** log 输出变量值
**** console.dir(dom) 查看dom API
*** XML xmldoc
*** 浏览器
* HTML5 文本    
都是有结构的标签,表示的含义是元素,元素包含属性
** 标题
<h1>-<h6>
** 段落
<p>
** 格式化
<b>粗体 <em>着重文字<i> <small>
** 链接
<a>
** <head>
*** <title> 文档标题
*** <base> 定义页面中所有链接默认的链接目标地址,就像定义PATH路径一样,这会影响所有路径属性,不要用
*** <meta>有两个属性,分别是http-equiv 和name
**** 1、name 属性 ：
　　<meta name="Generator" contect="">用以说明生成工具（如Microsoft FrontPage 4.0）等；
　　<meta name="KEYWords" contect="">向搜索引擎说明你的网页的关键词；
　　<meta name="DEscription" contect="">告诉搜索引擎你的站点的主要内容；
　　<meta name="Author" contect="姓名">告诉搜索引擎你的站点的制作的作者；
　　<meta name="Robots" contect= "all|none|index|noindex|follow|nofollow">
　　其中的属性说明如下：
　　设定为all：文件将被检索，且页面上的链接可以被查询；
　　设定为none：文件将不被检索，且页面上的链接不可以被查询；
　　设定为index：文件将被检索；
　　设定为follow：页面上的链接可以被查询；
　　设定为noindex：文件将不被检索，但页面上的链接可以被查询；
　　设定为nofollow：文件将被检索，页面上的链接不可以被查询。

**** 2、http-equiv属性 ：
　　<meta http-equiv="Content-Type" contect="text/html";charset=gb_2312-80">
　　<meta http-equiv="Content-Language" contect="zh-CN">
　　用以说明主页制作所使用的文字以及语言；
　　<meta http-equiv="Refresh" contect="n;url=http://yourlink">
　　定时让网页在指定的时间n内，跳转到页面http://yourlink；
　　<meta http-equiv="Expires" contect="Mon,12 May 2001 00:20:00 GMT">
　　可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。
　　需要注意的是必须使用GMT时间格式；
　　<meta http-equiv="Pragma" contect="no-cache">
　　是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；
　　<meta http-equiv="set-cookie" contect="Mon,12 May 2001 00:20:00 GMT">
　　cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；
　　<meta http-equiv="Pics-label" contect="">
　　网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，
　　而网站的限制级别就是通过meta属性来设置的；
　　<meta http-equiv="windows-Target" contect="_top">
　　强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；
　　<meta http-equiv="Page-Enter" contect="revealTrans(duration=10,transtion= 50)">
　　<meta http-equiv="Page-Exit" contect="revealTrans(duration=20，transtion=6)">
　　设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。
*** <link> 标签定义了文档与外部资源之间的关系。
<link> 标签通常用于链接到样式表:
<link rel="stylesheet" type="text/css" href="mystyle.css">
*** <style> 
#+BEGIN_SRC 
<style type="text/css">
body {background-color:yellow}
p {color:blue}
</style>
#+END_SRC
*** <script>
** <img>
<img src="url" alt="some_text" width="304" height="228"> 
** <table>
** 列表
*** 有序列表 order list(顺序)
ol li
*** 无序列表
ul li
** div 和span 
HTML 可以通过 <div> 和 <span>将元素组合起来
** 表单 <form>
*** 输入元素 
**** 文本域
<input type="text" name="name">
**** 密码字段
<input type="password" name="pwd">
**** 单选按钮（Radio Buttons）
<input type="radio" name="sex" value="male">Male<br>
<input type="radio" name="sex" value="female">Female
**** 复选框
<input type="checkbox" name="vehicle" value="Bike">I have a bike<br>
<input type="checkbox" name="vehicle" value="Car">I have a car 
**** 提交按钮
<input type="submit" value="Submit">
**** 下拉列表
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>
**** 按钮
<input type="button" value="Hello world!">
**** 文本域
<textarea rows="10" cols="30">
我是一个文本框。
</textarea>
**** <datalist>定义选项列表。请与 input 元素配合使用该元素
#+BEGIN_SRC 
<input list="browsers">
 
<datalist id="browsers">
  <option value="Internet Explorer">
  <option value="Firefox">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>
#+END_SRC
** 框架
<iframe src="demo_iframe.htm" frameborder="0"></iframe>
** canvas
<canvas> 	标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API
canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成
#+BEGIN_SRC 
<!DOCTYPE html> 
<html>
<head> 
<meta charset="utf-8"> 
<title>菜鸟教程(runoob.com)</title> 
</head> 
<body>

<canvas id="myCanvas">你的浏览器不支持 HTML5 canvas 标签。</canvas>

<script>
var c=document.getElementById('myCanvas');
var ctx=c.getContext('2d');
ctx.fillStyle='#FF0000';
ctx.fillRect(0,0,80,100);
</script>

</body>
</html>
#+END_SRC
#+BEGIN_SRC 
<canvas id="myCanvas" width="200" height="100" style="border:1px solid #000000;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
#+END_SRC
** 多媒体
*** <audio>支持 MP3,Wav,Ogg
#+BEGIN_SRC 
<audio controls>
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
  您的浏览器不支持 audio 元素。
</audio>
#+END_SRC
属性
autoplayNew 	autoplay 	如果出现该属性，则音频在就绪后马上播放。
controlsNew 	controls 	如果出现该属性，则向用户显示音频控件（比如播放/暂停按钮）。
loopNew 	loop 	如果出现该属性，则每当音频结束时重新开始播放。
mutedNew 	muted 	如果出现该属性，则音频输出为静音。
preloadNew 	auto
metadata
none 	规定当网页加载时，音频是否默认被加载以及如何被加载。
srcNew 	URL 	规定音频文件的 URL。
*** <video>
*** <source>定义多媒体资源 <video> 和 <audio>
** 新的语义和结构:为了创建更好的页面结构
*** <article>>    定义文档内的文章
*** <aside>      定义页面内容之外的内容
*** <bdi>        定义与其他文本不同的文本方向
*** <details>    定义用户可查看或隐藏的额外细节
*** <dialog>     定义对话框或窗口
*** <figcaption> 定义 <figure> 元素的标题
*** <figure>     定义自包含内容，比如图示、图表、照片、代码清单
*** <footer>     定义文档或节的页脚
*** <header>     定义文档或节的页眉
*** <main>       定义文档的主内容                        
*** <mark>       定义重要或强调的内容
*** <menuitem>   定义用户能够从弹出菜单调用的命令/菜单项目
*** <meter>      定义已知范围（尺度）内的标量测量
*** <nav>        定义文档内的导航链接
*** <progress>   定义任务进度
*** <rp>         定义在不支持 ruby 注释的浏览器中显示什么
*** <rt>         定义关于字符的解释/发音（用于东亚字体）
*** <ruby>       定义 ruby 注释（用于东亚字体）
*** <section>    定义文档中的节
*** <summary>    定义 <details> 元素的可见标题 
*** <time>       定义日期/时间。
*** <wbr>        定义可能的折行（line-break）
**** <frame>      框架
***** <p>
****** <h1>
****** <!--> 
****** 格式化<b><big><em><i><code><kbd><ins>
****** <a>
****** <img>
****** <table>!!!少用
****** <ul><ol>

* 样式 CSS 样式定义如何显示 HTML 元素
** 选择器,依赖DOM
*** 派生选择器
+ li strong {a:v;b:v}  
*** id选择器
+ #red {color:red;}
*** 类选择器
+ .center {text-align: center}
*** 属性选择器
+ input [title="value"] //也可以不要value修饰

** 样式
*** CSS 样式
**** CSS 背景(包含padding,和border) 不继承
background-color: 默认 transparent 透明
background-image:默认 none,url(path) 可以放两张背景
background-repeat:默认padding左上角开始 repeat-x repeat-y no-repeat(重复图像) 
background-position: top ,center,bottom,left,center,right(上中下,左中右) 100px 4com 2%,一个值得话,纵坐标默认居中
background-attachment:fixed/scroll/local 背景关联
fixed->元素范围大,背景范围小,元素动,背景不动
scroll->背景在元素的定位已经固定,元素动,背景也动
local->未知??
em是相对长度单位。相对于当前对象内文本的字体尺寸。如未被设定,则相对于浏览器默认字体尺寸.
background-size: 长宽 px 或 %,相对于父元素而不是图形
background-origin 背景图片相对于(content-box、padding-box 或 border-box )的定位
background-clip:content-box; 规定背景的绘制区域
**** CSS 文本(字操作)
text-indent: -5em 2% 2px 用于块元素,行元素可以用padding,可以继承
text-align: left,center,right 行内元素
word-spacing:定义为由空白符包围的一个字符串,中英文混合文本中。其默认值 normal 与设置值为 0 是一样的
letter-spacing:字间距离
text-transform:capitalize uppercase lowercase 
text-decoration:underline overline(上划线) line-through(穿透线) blink(闪烁)文本装饰
white-space:normal(空格和换行是不解释的)
| 值       | 空白符 | 换行符 | 自动换行 |
| pre-line | 合并   | 保留   | 允许     |
| normal   | 合并   | 忽略   | 允许     |
| nowrap   | 合并   | 忽略   | 不允许   |
| pre      | 保留   | 保留   | 不允许   |
| pre-wrap | 保留   | 保留   | 允许     |
direction：ltr 和 rtl 文本方向
text-shadow:5px 5px 5px #FF0000;
word-wrap: 长单词,(超过一行)允许截断到下一行 break-word /normal
text-outline: 文本轮廓
**** CSS 字体
font-family: 使用字体系列,字体名中有空格时 要用引号
font-style:字体风格 normal italic(normal版本的倾斜改动) oblique(字体的倾斜版本)
font-variant:字体变形 small-caps (另一种格式的大写英文)
font-weigth: bold 100~900 九级加粗度数字 400 等价于 normal，而 700 等价于 bold。浏览器分不出那么多级,就normal和bold
font-size:默认大小是 16 像素 (16px=1em(当前尺寸,当前是16px))
使用自己的字体,客户能够下载:“自己的”的字体是在 CSS3 @font-face 规则中定义的。
#+BEGIN_SRC 
使用您需要的字体
在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。
如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：
实例

<style> 
@font-face
{
font-family: myFirstFont;
src: url('Sansation_Light.ttf'),
     url('Sansation_Light.eot'); /* IE9+ */
}

div
{
font-family:myFirstFont;
}
</style>

#+END_SRC
**** CSS 链接
链接的四种状态：
    a:link - 普通的、未被访问的链接
    a:visited - 用户已访问的链接
    a:hover - 鼠标指针位于链接的上方
    a:active - 链接被点击的时刻
text-decoration 属性大多用于去掉链接中的下划线
**** CSS 列表
从某种意义上讲，不是描述性的文本的任何内容都可以认为是列表。人口普查、太阳系、家谱、参观菜单，甚至你的所有朋友都可以表示为一个列表或者是列表的列表。
由于列表如此多样，这使得列表相当重要，所以说，CSS 中列表样式不太丰富确实是一大憾事。
list-style-type: squre(方块)circle,decimal
list-style-image: url(xxx.gif) 点,用图像替代
list-style-position
该属性用于声明列表标志相对于列表项内容的位置。外部 (outside)默认值。保持标记位于文本的左侧。
内部 (inside) 标志处理为好像它们是插入在列表项内容最前面的行内元素一样
**** CSS 表格
**** CSS 轮廓
轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
CSS outline 属性规定元素轮廓的样式、颜色和宽度,!轮廓的宽度会占用margin的一部分
outline-color:
outline-style
outline-width
*** CSS 框模型(根据元素width来)
**** CSS 内边距
padding
**** CSS 边框
border-style
border-width
border-color:transparent 有宽度的不可见边框
border-radius: 边框圆角 四个角顺序是 top right bottom left
box-shadow:边框阴影 (灯光的照射形成的)
box-shadow: h-shadow v-shadow blur spread color inset;
h-shadow 	必需。水平阴影的位置。允许负值。 
v-shadow 	必需。垂直阴影的位置。允许负值。 
blur 	            可选。模糊距离。 
spread 	可选。阴影的尺寸。 
color 	可选。阴影的颜色。请参阅 CSS 颜色值。
inset 	可选。将外部阴影 (outset) 改为内部阴影。
--------
border-image-source 	用在边框的图片的路径。(特别要注意图片是框型的,跟border设定要一样,就是把图片套到边框上面) 	
border-image-slice 	图片边框向内偏移。 	
border-image-width 	图片边框的宽度。 	
border-image-outset 	边框图像区域超出边框的量。 	
border-image-repeat 	图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。
**** CSS 外边距
margin
**** CSS 外边距合并 当两个垂直外边距相遇时，它们将形成一个外边距。
*** CSS 定位
**** CSS 相对定位 (相对当前布局)
position:relative
left:-20px
top right bottom
**** CSS 绝对定位(
元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样
**** CSS 浮动 
**** 堆叠顺序,先要设定position属性
z-index 正数,接近用户,负数,远离用户
*** 2D转换
Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。
Chrome 和 Safari 需要前缀 -webkit-。
注释：Internet Explorer 9 需要前缀 -ms-。
transform:
translate()转化,平移 px em %
rotate()旋转,正时针 -30deg 角度,角(degree)
scale(2,4) 原始宽度的2 倍和高度的4倍 会变形的
skew(30deg,20deg)倾斜,歪斜 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度
matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。
transform-origin 	允许你改变被转换元素的位置
*** 3D转换 
rotateX() 元素围绕其 X 轴以给定的度数进行旋转。
rotateY() 
*** CSS3 过渡(是一种事件样的)挺好玩的
是元素从一种样式逐渐改变为另一种的效果
transition 转化,过度
!   规定您希望把效果添加到哪个 CSS 属性上,可以多个属性
!   规定效果的时长
#+BEGIN_SRC 
div{transition:width 2s;}
div:hover{width:300px;}
#+END_SRC
transition-property 	规定应用过渡的 CSS 属性的名称。 
transition-duration 	定义过渡效果花费的时间。默认是 0。
transition-timing-function 	规定过渡效果的时间曲线。默认是 "ease"。
transition-delay 	规定过渡效果何时开始。默认是 0。
*** CSS3动画
如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。用户创建动画
#+BEGIN_SRC 
@keyframes myfirst
{
from {background: red;}
to {background: yellow;}
}

@-moz-keyframes myfirst /* Firefox */
{
from {background: red;}
to {background: yellow;}
}

@-webkit-keyframes myfirst /* Safari 和 Chrome */
{
from {background: red;}
to {background: yellow;}
}

@-o-keyframes myfirst /* Opera */
{
from {background: red;}
to {background: yellow;}
}
#+END_SRC
#+BEGIN_SRC 
通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：

    规定动画的名称
    规定动画的时长

实例

把 "myfirst" 动画捆绑到 div 元素，时长：5 秒：

div
{
animation: myfirst 5s;
-moz-animation: myfirst 5s;	/* Firefox */
-webkit-animation: myfirst 5s;	/* Safari 和 Chrome */
-o-animation: myfirst 5s;	/* Opera */
}
#+END_SRC
*** CSS3 多列
*** CSS3 用户界面
* 客户端脚本 javascript
** 对象
*** 内建对象,String;Date;Array
*** 对象构造器
#+BEGIN_SRC javascript
    function person(firstname,lastname,age,eyecolor)
    {
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;
    }
#+END_SRC
** JavaScript for...in 语句循环遍历对象的属性。
** 日期 Date() getTime() setFullYear() toUTString getDay()
** 数组 concat() join() sort() Array()
*** RegExp 对象有 3 个方法：test()、exec() 以及 compile()。
*** window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。
****  * location.hostname 返回 web 主机的域名
****  * location.pathname 返回当前页面的路径和文件名
****  * location.port 返回 web 主机的端口（80 或 443）
****  * location.protocol 返回所使用的 web 协议（http:// 或
    https://）
****    location.href
**** location.assign()  加载新的文档
**** window.navigator 对象包含有关访问者浏览器的信息。

* 客户端脚本jQuery javascript库,简化
** 引入脚本执行<script src="my_jquery_functions.js"></script>
** jQuery 选择器 $()
*** 元素选择器 $("p")
*** #id 选择器 $("#test") 
*** .class 选择器 $(".class")
*** 选取所有元素 $("*") 	
*** document和 this
#+BEGIN_SRC javascript -n
$(document).ready(function(){
  $("button").click(function(){
    $(this).hide();
  });
});
#+END_SRC
*** 嵌套 $("a[target='_blank']") 	选取所有 target 属性值等于 "_blank" 的 <a> 元素
** jQuery 效果
*** jQuery  fade(淡出) 方法：
****    fadeIn()
****    fadeOut()
****    fadeToggle()
****    fadeTo()
*** jQuery 滑动方法
****    slideDown(speed,callback)
****    slideUp()
****    slideToggle()
*** jQuery 动画 - animate() 方法
**** $(selector).animate({params},speed,callback);
*** jQuery 停止动画
jQuery stop() 方法用于在动画或效果完成前对它们进行停止。
** jQuery HTML
*** jQuery - 获取内容和属性 | 配置
**** 获得内容 - text()、html() 以及 val()
#+BEGIN_SRC 
    text() - 设置或返回所选元素的文本内容
    html() - 设置或返回所选元素的内容（包括 HTML 标记）
    val() - 设置或返回表单字段的值
#+END_SRC
**** 获取属性值 - attr()
*** jQuery - 添加元素
****    append() - 在被选元素的结尾插入内容
****    prepend() - 在被选元素的开头插入内容
****    after() - 在被选元素之后插入内容
****    before() - 在被选元素之前插入内容
*** jQuery - 删除元素
****     remove() - 删除被选元素（及其子元素）
****    empty() - 从被选元素中删除子元素
*** jQuery - 获取并设置 CSS 类
**** jQuery addClass() 方法
#+BEGIN_SRC 
$("button").click(function(){
  $("h1,h2,p").addClass("blue");
  $("div").addClass("important");
});
#+END_SRC
**** jQuery removeClass() 方法
**** jQuery toggleClass() 方法
*** jQuery css() 方法
: css() 方法设置或返回被选元素的一个或多个样式属性。
**** 返回 CSS 属性
: css("propertyname");
**** 设置 CSS 属性
: css("propertyname","value");
**** 设置多个 CSS 属性
: css({"propertyname":"value","propertyname":"value",...});
#+BEGIN_SRC css
$("p").css({"background-color":"yellow","font-size":"200%"});
#+END_SRC
*** jQuery 尺寸
: 通过 jQuery，很容易处理元素和浏览器窗口的尺寸。
[元素(width)]padding(innerwidth)]border(outerwidth)]margin(outerwidth(true))]
****    width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。
****    height()
****    innerWidth() 方法返回元素的宽度（包括内边距）
****    innerHeight()
****    outerWidth()方法返回元素的宽度（包括内边距和边框）
****    outerHeight()
*** jQuery 遍历
**** 向上遍历 DOM 树
*****    parent()返回被选元素的直接父元素
*****    parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)
*****    parentsUntil() 返回介于两个给定元素之间的所有祖先元素
#+BEGIN_SRC 
$(document).ready(function(){
  $("span").parentsUntil("div");
});
#+END_SRC
**** jQuery 遍历 - 后代
*****  children()
*****  find()方法返回被选元素的后代元素，一路向下直到最后一个后代
#+BEGIN_SRC 
$(document).ready(function(){
  $("div").find("span");
});
#+END_SRC
**** jQuery 遍历 - 同胞(siblings)
*****    siblings()返回被选元素的所有同胞元素
*****    next()返回被选元素的下一个同胞元素
*****    nextAll()
*****    nextUntil()返回介于两个给定参数之间的所有跟随的同胞元素
*****    prev() 方向相反
*****    prevAll()
*****    prevUntil()
**** jQuery 遍历- 过滤
***** jQuery first() 方法first() 方法返回被选元素的首个元素。
***** last()
***** eq()返回被选元素中带有指定索引号的元素。从0开始
** jQuery Ajax 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。
*** jQuery load() 方法
**** load() 方法从服务器加载数据，并把返回的数据放入被选元素中。
: $(selector).load(URL,data,callback);
: 必需的 URL 参数规定您希望加载的 URL。
: 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。
: 可选的 callback 参数是 load() 方法完成后所执行的函数名称。
#+BEGIN_SRC 
$("#div1").load("demo_test.txt #p1");
#+END_SRC
对象要符合DOM
#+BEGIN_SRC 
可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：
    responseTxt - 包含调用成功时的结果内容
    statusTXT - 包含调用的状态
    xhr - 包含 XMLHttpRequest 对象
下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示"外部内容加载成功！"，而如果失败，则显示错误消息：
实例
$("button").click(function(){
  $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){
    if(statusTxt=="success")
      alert("外部内容加载成功!");
    if(statusTxt=="error")
      alert("Error: "+xhr.status+": "+xhr.statusText);
  });
});
#+END_SRC
*** jQuery - AJAX get() 和 post() 方法
: jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。
**** $.get() 方法通过 HTTP GET 请求从服务器上请求数据。
: $.get(URL,callback);
必需的 URL 参数规定您希望请求的 URL。
可选的 callback 参数是请求成功后所执行的函数名。
下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：
#+BEGIN_SRC 
$("button").click(function(){
  $.get("demo_test.php",function(data,status){
    alert("数据: " + data + "\n状态: " + status);
  });
});
#+END_SRC
**** $.post() 方法通过 HTTP POST 请求从服务器上请求数据。
$.post(URL,data,callback);
必需的 URL 参数规定您希望请求的 URL。
可选的 data 参数规定连同请求发送的数据。
可选的 callback 参数是请求成功后所执行的函数名。
下面的例子使用 $.post() 连同请求一起发送数据：
#+BEGIN_SRC 
$("button").click(function(){
    $.post("/try/ajax/demo_test_post.php",
    {
        name:"菜鸟教程",
        url:"http://www.runoob.com"
    },
        function(data,status){
        alert("数据: \n" + data + "\n状态: " + status);
    });
});
#+END_SRC
*** 事件
**** ready将函数绑定到文档的就绪事件
**** click /dblclick/focus/mouseover
**** onchange 事件(text 对象)
**** onmouseover 和 onmouseout 事件

*** 文字两端对齐
<html>
<head>
    <style type="text/css">
        h1 {
            text-align: justify;
            overflow-x: hidden;
            overflow-y: hidden;
            width: 800px;
            height: 40px;
        }

            h1:after {
                display: inline-block;
                content: '';
                overflow-x: hidden;
                overflow-y: hidden;
                width: 600px;
                height: 40px;
            }
    </style>
</head>
<body>
    <h1>实现单行文本的内容两端对齐</h1>
</body>
</html>  

* 术语
** utf-8签名与不签名
区别:有了签名后,浏览器直接根据签名即可判断出使用UTF-8编码简析.
不带签名,浏览器根据内容判断.所以签名的更容易被浏览器以正确的方式解析.
** jQuery ajax() 方法
      $.ajax({
          type: "POST",
          url: url,
          data: config,
          datatype: "html",
          success: function (data) {

              var strJSON = data; //得到的JSON
              var d = eval("(" + strJSON + ")");
              if (d.Issuccess) {

                  VodkaTool.GotoUrl(tourl);
              } else {
                  VodkaTool.MessageBox(d.msg, false);
                  $("#servername").focus();
                  return false;
              }
          }
      });

* html5揭秘
web 浏览器请求一个页面时,Web服务器会在发送实际页面内容前,先发送一些头信息(header)
浏览器需要这些头信息解析随后的页面内容..(交流嘛)
Content-Type:text/html (内容类型或MIME类型)
MIME类型(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型,是描述消息内容类型的因特网标准。
| jpeg       | image/jpeg               |
| png        | image/png                |
| javascript | application/x-javascript |
| css        | text/css                 |
| xhtml      | application/xhtml+xml(严格形式,但一般用宽松形式) |

当浏览器渲染Web页面的时候,它会构造一个文档对象模型(DOM),用一个对象的集合表示
页面上的HTML元素.除此还有window和document这些不和特定页面元素绑定的全局对象.
对象有共有属性
还有私有属性
** 第1章 从开始到现在 
*** 1.2 MIME类型 
*** 1.3 很长的题外话：一份标准是如何诞生的？ 
*** 1.4 未曾间断的路线 
*** 1.5 HTML发展史：从1997到2004年 
*** 1.6 你所知道的关于XHTML的一切都是错误的 
*** 1.7 一个竞争愿景 11
*** 1.8 WHAT工作小组？ 12
*** 1.9 回到W3C 13
** 第2章 HTML5特性检测 
*** 2.1 引言 
*** 2.2 检测技术 
1. 全局对象是否拥有HTML5特性
2.创建个元素,然后检测元素的DOM对象
3. 检测DOM对象的方法
4. 检测DOM对象的属性
*** 2.3 Modernizr：一个HTML5特性检测库 
#+BEGIN_SRC 
<!DOCTYPE html>
<html>
<head>
<script src="modernizr.min.js"></script>
</head>
</html>

然后把HTML5元素 灵活处理//注意Modernizr 'M'要大写
if(Modernizr.canvas){
//开始画写什么吧!
}else{
//对于不支持canvas的浏览器
}
#+END_SRC

*** 2.4 画布 <canvas>依赖分辨率的位图画布
自己写的 元素支持某方法
#+BEGIN_SRC 
function supports_canvas(){
return !!document.createElement('canvas').getContext;
}
浮游在内存中,测试是否拥有getcontext()方法,用双重否定强制让这个检测方法返回一个布尔值
#+END_SRC
*** 2.5 画布文本 
!! 注意:canvas 文本api 比canvas api 晚
#+BEGIN_SRC javascript
function supports_canvas_text(){
if(!supports_canvas()){return false;}
var dummy_canvas = document.createElement('canvas');
var context = dummy_canvas.getContext('2d');
return typeof context.fillText == 'function';
}
或者使用 Modernizr.canvastext
#+END_SRC
*** 2.6 视频 <video> 视频控制需要用到JavaScript
检测
return !!document.createElement('video').canPlayType;
or Modernizr.video
*** 2.7 视频格式 
检测,,晕 +_+
return document.createElement('video').canPlayType('video/mp4; codecs="avc1.42E1E, mp4a.40.2"');
返回值不再是bool,而是string
"probably"   浏览器有充分把握可以播放此格式
"maybe"     有可能
""(空字符串")   无法播放

#+BEGIN_SRC javascript
检测 ogg格式 ;;这要学习视频 编码
function supports_ogg_theora_video(){
if(!support_video()){return false;}
var v= document.createElement("video");
return v.canPlayType('video/ogg;codecs="theora,vorbis"');
}
or Modernizr.video.ogg
#+END_SRC
*** 2.8 本地存储 
与cookie 类似,不过容量更大
cookie 每次请求页面总会发送回服务器,而本地存储可以在本地用javascript获取
检测 如果window对象有一个localStorage属性,则支持
return ('localStorage' in window) && window['localStorage'] !==null;
Modernizr.localstorage   Modernizr库中的属性名都是小写
*** 2.9 Web Workers (多线程支持)
return !!window.Worker;
or Modernizr.webworkers
*** 2.10 离线Web应用 
return !!window.applicationCache
or Modernizr.applicationcache
*** 2.11 地理位置 不属于html5标准
return !!navigator.geolocation
Modernizr.geolocation
*** 2.12 输入框类型 
<input type="search"> 搜索框
number 数字输入框
range 范围选择滑块
color 颜色选择器
url 网址输入框
email 邮件
date  日期;精确到年月日
month 月份;精确到月份
week 星期 
time 时间戳;精确到小时 分钟
datetime 精确日期/时间戳
datetime-local 当地时间和日期,本地化 年月日 时分秒

检测
return document.createElement("input").setAttribute("type","color").type !== "text";
Modernizr.inputtypes.date ....
*** 2.13 占位文本 
就是 placeholder属性
*** 2.14 表单自动聚焦 
autofocus 属性
return 'autofocus' in document.createElement("input")
Modernizr.input.autofocus
*** 2.15 微数据 
return !!document.getItems;
Modernizr 目前不支持,没查过
** 第3章 从这一切的含义 
*** 3.1  original html
#+BEGIN_SRC html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
: doctype 渲染模式; 默认quirks 模式 ;html 标准模式 ;准标准模式
:一般 <!DOCTYPE html> 标准模式就好了
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
:xmlns xml 过时了 ;lang 指定语种
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
:Content-Type: text/html; charset="utf-8" 服务器发送的字节编码 ,不懂
:html5 中 <meta charset="utf-8" />
  <meta name="robots" content="noindex" />
  <title>My Weblog</title>
  <link rel="stylesheet" type="text/css" href="style-original.css" />
:普通的链接(<a href>) 只是简单地链到另一个网页
:链接关系(link relations) 提供一种方式解释为什么要链接到那个页面,就像做一种解释
:一样,如"我链接到另一个网页,是因为...."
.....他是一个样式表,包含浏览器应当用于当前文档上的CSS规则.
.....他提供一个包含页面内容的标准订阅格式(如RSS)
:ctylesheet type可以去掉,因为只有一种css类型
  <link rel="alternate" type="application/atom+xml" title="My Weblog feed" href="/feed/" />
:tyle 可以是RSS或Atom等,表示Xml 格式的atom聚合内容
  <link rel="search" type="application/opensearchdescription+xml" title="My Weblog search" href="opensearch.xml" />
</head>
: rel="archives" 表示所引用的文档描述了一组收藏,如blog可以链到该博客的索引目录
: rel="author"  链到该页面作者的相关信息.可以是一个"关于作者"页面,或 mailto:地址
: rel="shortcut icon" href="/xx.ico" 就是地址栏旁的小图标
<body>

  <div id="header">
    <h1>My Weblog</h1>
    <p class="tagline">A lot of effort went into making this effortless.</p>

    <div id="nav">
      <ul>
        <li><a href="../semantics.html">home</a></li>
        <li><a href="../semantics.html">blog</a></li>
        <li><a href="../semantics.html">gallery</a></li>
        <li><a href="../semantics.html">about</a></li>
      </ul>
    </div>

  </div>

  <div class="entry">
    <p class="post-date">October 22, 2009</p>
    <h2>
      <a href="../semantics.html" rel="bookmark" title="link to this post">Travel day</a>
    </h2>

    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec hendrerit felis accumsan turpis pretium tempor. Duis eu turpis nunc, ut euismod nisl. Aliquam erat volutpat. Proin eu eros mollis dui fringilla sodales. Curabitur venenatis tincidunt felis ac congue. Maecenas at odio dui, sit amet congue sapien. Proin placerat feugiat eros, non mollis quam pharetra at. Duis gravida eleifend ligula nec auctor. Fusce nulla diam, fringilla non ultrices in, iaculis eu tellus. Sed mollis consequat turpis sit amet facilisis. Donec pretium luctus aliquet. Curabitur placerat varius purus vel congue. Aliquam erat volutpat. Curabitur vitae eros sed turpis sollicitudin mattis. Morbi venenatis pulvinar nunc, at vulputate massa placerat a. Nam et tortor id nisi consequat tempor eget sit amet risus. Praesent bibendum, velit eu hendrerit porttitor, elit mauris posuere nisl, non pellentesque est leo a quam.</p>

  </div>

  <div class="entry">
    <p class="post-date">October 17, 2009</p>
    <h2>
      <a href="../semantics.html" rel="bookmark" title="link to this post">I'm going to Prague!</a>
    </h2>

    <p>Sed ante mi, sagittis sed euismod sit amet, convallis et nibh. Etiam sit amet odio dui, id semper turpis. Mauris risus mauris, imperdiet pulvinar vehicula et, hendrerit vitae dui. Phasellus ultrices lacus rhoncus purus posuere rutrum. Maecenas mattis eleifend scelerisque. Nulla quam sem, facilisis ac ultrices et, tincidunt eu dolor. Mauris arcu est, porttitor eu blandit nec, pulvinar sed enim. Praesent diam felis, cursus at facilisis eu, mollis ut elit. Praesent rutrum porta euismod. Nulla facilisi. Suspendisse potenti. In auctor ultricies eleifend. Proin erat dolor, malesuada non tempus nec, tincidunt in mi.</p>

  </div>

  <p class="c sectionSign"></p>

<table id="arc">
<tr><th>October</th><td></td></tr>
<tr><th>5</th><td><a href="../semantics.html">Vos vestros servate, meos mihi linquite mores</a></td></tr>
<tr><th>September</th><td></td></tr>
<tr><th>30</th><td><a href="../semantics.html">Ut sementem feceris ita metes</a></td></tr>
<tr><th>August</th><td></td></tr>
<tr><th>4</th><td><a href="../semantics.html">Risu inepto res ineptior nulla est</a></td></tr>
<tr><th>July</th><td></td></tr>
<tr><th>6</th><td><a href="../semantics.html">Vitanda est improba siren desidia</a></td></tr>
<tr><th>April</th><td></td></tr>
<tr><th>21</th><td><a href="../semantics.html">Mendacem oportet esse memorem</a></td></tr>
<tr><th>7</th><td><a href="../semantics.html">Libenter homines id quod volunt credunt</a></td></tr>
<tr><th>March</th><td></td></tr>
<tr><th>27</th><td><a href="../semantics.html">Gutta cavat lapidem</a></td></tr>
<tr><th>21</th><td><a href="../semantics.html">Amoto quaeramus seria ludo</a></td></tr>
<tr><th>18</th><td><a href="../semantics.html">Non est ars quae ad effectum casu venit</a></td></tr>
<tr><th>January</th><td></td></tr>
<tr><th>11</th><td><a href="../semantics.html">Quid rides?...De te fabula narratur</a></td></tr>
</table>

  <div id="footer">

    <p class=sectionSign>

    <p>&copy; 2009 <a href="../semantics.html">Mark Pilgrim</a></p>

  </div>

</body>
</html>

#+END_SRC
*** 3.2 html5
#+BEGIN_SRC html
<!DOCTYPE html>
<meta charset="utf-8">
<title>Dive Into HTML5</title>
<link rel="alternate" type="application/atom+xml" href="https://github.com/diveintomark/diveintohtml5/commits/master.atom">
<link rel="stylesheet" href="screen.css">
<style>
h1:before{content:''}
h1,h2,h3{padding:0;margin:0;border:0;line-height:128px;text-align:center;clear:both}
h1{margin-top:128px;font-size:72px;text-transform:uppercase}
h2{font-size:48px}
ol{margin:1em 0 0 0;padding:0}
li{clear:both;width:100%;margin:0 0 1em 0;padding:0;overflow:hidden}
.title,.number{background:#fff}
.title{float:left;padding-right:3px}
.number{margin:0;float:right;padding-left:3px}
.f{margin-top:6.224em}
</style>
<link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="mobile.css">
<link rel="prefetch" href="introduction.html">
<hgroup>
<h1>Dive Into HTML5</h1>
<h2>by<br>Mark Pilgrim</h2>
<h3>with contributions from the community</h3>
</hgroup>

<p class="a rotatedFloralHeartBullet">

<p class="f">Dive Into <abbr>HTML5</abbr> elaborates on a hand-picked selection of features from the <a href="http://www.whatwg.org/html5">HTML5</a> specification and other fine standards. We encourage you to <a href="//www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027">buy the printed work</a> &mdash; Mark Pilgrim&rsquo;s artfully titled &ldquo;HTML5: Up <i class="baa">&amp;</i> Running&rdquo; &mdash; published on paper by O&rsquo;Reilly, under the Google Press imprint. Your kind and sincere <a href="about.html">feedback is always welcome</a>, and this work shall remain online under the <a rel="license" href="//creativecommons.org/licenses/by/3.0/">CC-BY-3.0 license</a>.

<p>This particular edition of Dive Into HTML5 is advanced by <a href="//github.com/diveintomark?tab=members">the diveintomark team</a>. We work hard to add and update content, links, APIs, and actively maintain this fine resource; refreshing and reflecting the relevant and current state of HTML5, just as Mark Pilgrim did during his tenure. We attribute this work in the manner specified by Mark, and we make modifications to the site's content. We do not in any way suggest that he endorses us or our use of his work. We hope you do.

<h3>Table of Contents</h3>

<!-- toc -->
<ol>
<li><a href="introduction.html">Introduction: Five Things You Should Know About <abbr>HTML5</abbr></a>
<li><a href="past.html">A Quite Biased History of <abbr>HTML5</abbr></a>
<li><a href="detect.html">Detecting <abbr>HTML5</abbr> Features: It&rsquo;s Elementary, My Dear Watson</a>
<li><a href="semantics.html">What Does It All Mean?</a>
<li><a href="canvas.html">Let&rsquo;s Call It a Draw(ing Surface)</a>
<li><a href="video.html">Video in a Flash (Without That Other Thing)</a>
<li><a href="geolocation.html">You Are Here (And So Is Everybody Else)</a>
<li><a href="storage.html">A Place To Put Your Stuff</a>
<li><a href="offline.html">Let&rsquo;s Take This Offline</a>
<li><a href="forms.html">A Form of Madness</a>
<li><a href="extensibility.html">&ldquo;Distributed,&rdquo; &ldquo;Extensibility,&rdquo; And Other Fancy Words</a>
<li><a href="history.html">Manipulating History for Fun <i>&amp;</i> Profit</a>
<li class="app"><a href="everything.html">The All-In-One Almost-Alphabetical Guide to Detecting Everything</a>
<li class="app"><a href="peeks-pokes-and-pointers.html"><abbr>HTML5</abbr> Peeks, Pokes and Pointers</a>
</ol>
<!-- /toc -->

<p class="a rotatedFloralHeartBullet">

<p class="c">&ldquo;If you&rsquo;re good at something, never do it for free.&rdquo; <span class="u">&mdash;</span><cite>The Joker</cite><br>(but that doesn&rsquo;t mean you should keep it to yourself)

<p class="c">Copyright MMIX&ndash;MMXI <a href="about.html">Mark Pilgrim</a>

<form action="http://www.google.com/cse"><div><input type="hidden" name="cx" value="017884302975346027366:bgclqh8nvse"><input type="hidden" name="ie" value="UTF-8"><input type="search" name="q" size="25" placeholder="powered by Google&trade;">&nbsp;<input type="submit" name="sa" value="Search"></div></form>
<script src="j/jquery.js"></script>
<script src="j/dih5.js"></script>
<script>
$(function() {
  $("ol").css("list-style", "none");
  $("li").each(function(i) {
    var num = i;
    if ($(this).hasClass("app")) {
      num = String.fromCharCode(53+num);
    }
    $(this).wrapInner('<span class="title"></span>').append('<span class="number">'+num+'</span>').css("background", "#fff url(i/dot.png) repeat-x 0 0.8em");
  });
});
window._gaq=[['_setAccount','UA-26147692-1'],['_setDomainName', 'diveintohtml5.info'],['_setAllowHash', false],['_trackPageview'],['_trackPageLoadTime']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
#+END_SRC
*** 3.3 根元素 
*** 3.4 <head>元素 
*** 3.4.1 字符编码 
*** 3.4.2 朋友和（链接）关系 
*** 3.5 HTML5中新增的语义元素 
**** <article>>    定义文档内的文章
**** <aside>      定义页面内容之外的内容
**** <bdi>        定义与其他文本不同的文本方向
**** <details>    定义用户可查看或隐藏的额外细节
**** <dialog>     定义对话框或窗口
**** <figcaption> 定义 <figure> 元素的标题
**** <figure>     定义自包含内容，比如图示、图表、照片、代码清单
**** <footer>     定义文档或节的页脚
**** <header>     定义文档或节的页眉
**** <main>       定义文档的主内容                        
**** <mark>       定义重要或强调的内容
**** <menuitem>   定义用户能够从弹出菜单调用的命令/菜单项目
**** <meter>      定义已知范围（尺度）内的标量测量
**** <nav>        定义文档内的导航链接
**** <progress>   定义任务进度
**** <rp>         定义在不支持 ruby 注释的浏览器中显示什么
**** <rt>         定义关于字符的解释/发音（用于东亚字体）
**** <ruby>       定义 ruby 注释（用于东亚字体）
**** <section>    定义文档中的节
**** <summary>    定义 <details> 元素的可见标题 
**** <time>       定义日期/时间。
**** <wbr>        定义可能的折行（line-break）
***** <frame>      框架
****** <p>
******* <h1>
******* <!--> 
******* 格式化<b><big><em><i><code><kbd><ins>
******* <a>
******* <img>
******* <table>!!!少用
******* <ul><ol>

*** 3.6 题外话：浏览器如何处理未知元素 
浏览器有支持清单列表 nsElementTable.cpp 

IE 问题 是 对于不能识别的 元素不应用样式,解决方法是 用js;如 <scritp>document.createElement("unknow");</script>
unknow{display:block;border:f1px solid red}
多个解决方法
var e=("abbr,article,aside,audio,...").split(',');
for(var i=0;i<e.length;i++){document.createElement(e[i]);
或直接使用开源版本 
<!--[if lt IE 9]
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
记得放在头部欧!!!
*** 3.7 页头 
<div> 元素没任何语义,so 使用
<header>
</header>
这里的问题是 <header>中的标题怎么弄
#+BEGIN_SRC html
<header>
  <hgroup>
    <h1>MY weblog</h1>
    <h2>副标题 主要写一些感兴趣的东西,欢迎拍砖</h2>
  </hgroup>
#+END_SRC
测试 https://gsnedders.html5.org/outliner/
*** 3.8 文章 
可以用
<article> 而不是无语义的<div> 而对于 大纲 h1-6的算法已经改了,可以有多个h1
#+BEGIN_SRC html
<article>
  <header>
    <p class="post-date">october 22,2009</p>
    <h1>
      <a href="#"
         rel="bookmark"
         title="link to this post">
         Tralel day
      </a>
     </h1>
   </header>
  ......
</article>
#+END_SRC
*** 3.9 日期和时间 
啊啊啊 ,上面的 <p>也要改改了
<time datetime="2009-10-22" pubdate>October 22, 2009</time>
机器可识别的时间戳,datetime 格式要正确
人可识别的文本内容
可选的pubdate 如果在 <article>中,指此article的发布时间,不是,指整个文档的发布时间
*** 3.10 导航 
原始的
#+BEGIN_SRC html
<div id="nav">
 <ul>
  <li><a>home</a></li>
  <li><a>blog</a></li>
  ...
 </ul>
</div>
#+END_SRC
html5
#+BEGIN_SRC html
<nav>
 <ul>
  <li><a>home</a></li>
  <li><a>blog</a></li>
  ...
 </ul>
</nav>
#+END_SRC
*** 3.11 页脚 
<footer></footer>
*** 3.12 扩展阅读 
*** 第4章 Canvas绘图 
*** 4.1 引言 
*** 4.2 简单的图形 
每个canvas 都有一个上下文环境
 var b_context=canvasobject.getContext("2d");
有了2d上下文,就可以开始绘制了2d图形了
b.context.fillRect(50,25,150,100);

:fillStyle 可以设置CSS颜色,默认黑色
:fileRect(x,y,width,height) 矩形
:strokeStyle 和fillStyle 一样,可以设置CSS颜色,图案或颜色渐变
:strokeRect(x,y,width,height)只绘制矩形边缘
:clearRect(x,y,width,height)清除指定矩形区域的像素
*** 4.3 Canvas坐标系 
坐标(0,0)位于canvas左上角
*** 4.4 路径 
moveTo(x,y)把铅笔移动到指定点并作为线条的开始
lineTo(x,y)绘制线条到指定的结束点

*** 4.5 文本 
*** 4.6 颜色渐变 
*** 4.7 图片 
*** 4.8 IE怎么办？ 
*** 4.9 一个完整的例子 
*** 4.10 扩展阅读 
*** 第5章 网络上的视频 
*** 5.1 前言 
*** 5.2 视频容器 
*** 5.3 视频编解码器 
*** 5.3.1 H.264 
*** 5.3.2 Theora 
*** 5.3.3 VP8 
*** 5.4 音频编解码器 
*** 5.4.1 MPEG-1 音频层 3 
*** 5.4.2 高级音频编码 
*** 5.4.3 Vorbis 
*** 5.5 在网页中怎么工作 
*** 5.6 H.264视频的授权问题 
*** 5.7 使用Firefogg编码Ogg视频 
*** 5.8 使用ffmpegtheora批量编码Ogg视频 
*** 5.9 使用HandBrake编码H.264视频 
*** 5.10 使用HandBrake批量编码H.264视频 
*** 5.11 使用ffmpeg编码WebM视频 
*** 5.12 最后，标记 
*** 5.12.1 MIME类型很重要 
*** 5.13 IE怎么办？
*** 5.14 完整的例子
*** 5.14 扩展阅读 
*** 第6章 地理位置 
*** 6.1 引言 
*** 6.2 地理位置API 
*** 6.3 代码展示 
*** 6.4 容错处理 
*** 6.5 方案！我要方案！ 
*** 6.6 那IE怎么办？ 
*** 6.7 geo.js来拯救 
*** 6.8 一个完整的例子 
*** 6.9 扩展阅读 
*** 第7章 Web应用本地存储的过去、现在和未来 
*** 7.1 引言 
*** 7.2 HTML5之前的伪本地存储简史 
*** 7.3 HTML5存储介绍 
*** 7.4 使用HTML5存储 
*** 7.4.1 跟踪HTML5存储区的改动 
*** 7.4.2 现有浏览器的局限性 
*** 7.5 HTML5存储实践 
*** 7.6 超越键值对的存储形式 
*** 7.7 扩展阅读 
*** 第8章 离线Web应用 
*** 8.1 引言 
*** 8.2 缓存清单 
*** 8.2.1 “网络”段 
*** 8.2.2 “默认”部分 
*** 8.3 事件流 
*** 8.4 调试的艺术——杀了我！现在就杀了我！ 
*** 8.5 让我们来构建一个离线Web应用！ 
*** 8.6 扩展阅读 
*** 第9章 疯狂的表单 
*** 9.1 引言 
*** 9.2 占位文本 
*** 9.3 自动聚焦 
*** 9.4 Email地址 
*** 9.5 Web地址 
*** 9.6 数字类型输入框：数字选择器 
*** 9.7 数字类型输入框：滑块 
*** 9.8 日期选择器 
*** 9.9 搜索框 
*** 9.10 颜色选择器 
*** 9.11 还有一点…… 
*** 9.12 扩展阅读 
*** 第10章 “分布式”、“可扩展性”及其他华丽词藻 
*** 10.1 引言 
*** 10.2 什么是微数据？ 
*** 10.3 微数据的数据模型 
*** 10.4 标注“人” 
*** 10.4.1 Google Rich Snippets介绍 
*** 10.5 标注“组织” 
*** 10.6 标注“事件” 
*** 10.6.1 Google Rich Snippets的回归 
*** 10.7 标注“点评” 
*** 10.8 扩展阅读 
*** 

附录A 全方位特性检测指南 
元素列表 

简单对Web请求响应如何处理进行的整理，难免有理解不到位，理解有偏差的地方，如有理解有误的地方，希望大牛批评指正。

1.Web开发的定义
首先看看微软对Web开发的定义:
Web开发是一个指代网页或网站编写过程的广义术语。网页使用 HTML、CSS 和 JavaScript编写。这些页面可能是类似于文档的简单文本和图形。页面也可以是交互式的，或显示变化的信息。编写交互式服务器页面略微复杂一些，但却可以实现更丰富的网站。如今的大多数页面都是交互式的，并提供了购物车、动态可视化甚至复杂的社交网络等现代在线服务。

通俗的说,Web开发就是我们说的做网站.它分为网页部分和逻辑部分也就是我们说的前台页面展示与后台业务逻辑处理。前台负责与用户的交互显示数据，用到HTML标签布局页面,CSS样式渲染页面,JavaScript脚本(或AJAX、JQuery、Extjs)编写动态交互性强的页面；后台编写处理一些复杂业务逻辑的程序.可以用C#,JAVA,PHP等语言。

2.Web请求响应简单理解
客户端浏览器对服务器端进行一次请求的演示图：
[[../image/webserver.jpg]]

<1>.客户端发送请求。客户端浏览器向服务器发送请求URL；
<2>.服务器接收请求。服务器接收到该浏览器发送的请求；
<3>.服务器生成HTML。服务器解析请求的URL，根据URL确定请求的目标资源文件；
　　 这个资源文件通常是一个动态页面（如ASP，PHP，JSP，ASPX等文件）的网络地址（MVC结构的程序例外）。Web服务器根据动态页面文件的内容和URL中的参数，调用相应的资源（数据库数据或图片文件等等）组织数据，生成HTML页面。
<4>.服务端响应请求。生成HTML文档以后，服务器响应浏览器的请求，将生成的HTML文档发送给客户端浏览器；
<5>.客户端接收响应。浏览器接收服务端发出的请求得来HTML文档；
<6>.客户端解析HTML。浏览器对HTML文档进行解析，并加载相关的资源文件（JS，CSS，多媒体资源，内嵌网页）等，(在这里浏览器解悉完HTML文档以后，就会进行呈现，但同时也会向服务器发送请求来请求其它相关的资源文件)
<7>.服务器发送资源文件。服务器接到浏览器对资源文件的请求，将相应的资源文件响应给客户端浏览器；
<8>.客户端加载资源文件。客户端浏览器将接收服务器发送的资源文件，整理并呈现到页面中；
<9>.客户端从上到下加载。在进行页面呈现的时候，浏览器会从上到下执行HTML文档，当遇到相应的页面脚本的时候，会对脚本进行分析，并解释执行相应的脚本代码。

在第6步以后，我们就可以看到一部分页面内容了，不过可能是纯文本内容，没有样式，没有图片或其它资源。待到浏览器请求得到某资源的时候就会进行组织呈现，直到整个页面所有资源加载完毕,显示完成，请求响应完毕。

3.客户端解析HTML
<1>.解析HTML结构；
<2>.加载外部脚本和样式表文件；
<3>.解析并执行脚本代码；
<4>.构造HTML DOM模型；
<5>.加载图片等外部文件。

加载顺序实例：
复制代码
复制代码

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
<title>Title</title>
<style type="text/css">
body
{
font-sie: 12px;
}
</style>
<link href="style.css" rel="stylesheet" type="text/css" media="all" />
<script src="js.js" type="text/javascript"></script>
</head>
<body>
<div>
<script type="text/javascript">
function f1() { }
</script>
<img src="1.gif" />
</div>
<script type="text/javascript">
function f2() { }
</script>
</body>
</html>

复制代码
复制代码

html → head → title → #text(网页标题) → style → 加载样式 → 解析样式 → link → 加载外部样式表文件 → 解析外部样式表 → script → 加载外部脚本文件 → 解析外部脚本文件 → 执行外部脚本 → body → div → script → 加载脚本 → 解析脚本 → 执行脚本 → img → script → 加载脚本 → 解析脚本 → 执行脚本 → 加载外部图像文件 → 页面初始化完毕

4.onload和ready的差异
这里需要注意的是onload和ready的差异：
一是ready，表示DOM文档树已经加载解析解析完成（不包含图片等非文字媒体文件）；
二是onload，指页面上所有的资源(包含图片等文件在内的所有元素)都加载完毕。

说ready比onload快最显著的是比如一个页面上有一个很大的图片，加载要好久，onload只有在图片加载完成之后执行，而ready不必等图片加载完成。
这种差异与window.onload和$(document).ready()的区别也是一致的吧。
* VodkaTool
** post
***  VodkaTool.PostAjax(url, config, tourl);
***  VodkaTool.StateChange(state_a, url, id);
***  VodkaTool.GotoUrl(url);

* 手机版
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"> 
* javascript
第1章 JavaScript简史
1.1 JavaScript的起源
1.2 DOM  
1.3 浏览器战争    
1.3.1 DHTML    
1.3.2 浏览器之间的冲突 
1.4 制定标准    
1.4.1 浏览器以外的考虑
1.4.2 浏览器战争的结局
1.4.3 崭新的起点    
1.5 小结    
第2章 JavaScript语法
2.1 准备工作    
# javascript 需要写在html中
# 或者 在 head 引入
# 但最好的做法是把<script>.标签放到 HTML文档的最后，</body>标签之前: 
# web 浏览器中有JavaScript解释器
2.2 语法    
2.2.1 语句    
2.2.2 注释    
2.2.3 变量    
2.2.4 数据类型    
2.2.5 数组    
var light=array(3);
2.2.6 对象    
var lennon=Object();
lennon.name="john"
lennon.year=1999 
简洁语法
var lennon={name:"john",year:1999};
2.3 操作    
2.4 条件语句    
2.4.1 比较操作符    
2.4.2 逻辑操作符    
2.5 循环语句    
2.5.1 while循环    
2.5.2 for循环    
2.6 函数    
2.7 对象    
2.7.1 内建对象    
2.7.2 宿主对象    
2.8 小结    
第3章 DOM    
3.1 文档：DOM中的“D”    
3.2 对象：DOM中的“O”    
3.3 模型：DOM中的“M”    
3.4 节点    
3.4.1 元素节点    
3.4.2 文本节点    
3.4.3 属性节点    
3.4.4 CSS    
3.4.5 获取元素    
getElementById()
getElementsByTagName(tagname)
getElementsByClassName(classname)
3.4.6 盘点知识点    
3.5 获取和设置属性    
3.5.1 getAttribute    
3.5.2 setAttribute    
3.6 小结    
第4章 案例研究：JavaScript图片库    
4.1 标记    
4.2 JavaScript    
4.2.1 非DOM解决方案    
4.2.2 最终的函数代码清单    
4.3 应用这个JavaScript函数    
onmouseover 
onmouseout
onclick
4.4 对这个函数进行扩展    
this 关键字
onclick=showPic(this)
window.onload=functionname();

4.4.1 childNodes属性    
4.4.2 nodeType属性    
4.4.3 在标记里增加一段描述    
4.4.4 用JavaScript改变这段描述    
4.4.5 nodeValue属性    
4.4.6 firstChild和lastChild属性    
4.4.7 利用nodeValue属性刷新这段描述    
4.5 小结    
第5章 最佳实践    
5.1 过去的错误    
5.1.1 不要怪罪JavaScript    
5.1.2 Flash的遭遇    
5.1.3 质疑一切    
5.2 平稳退化    
5.2.1 “javascript:”伪协议    
5.2.3 谁关心这个    
5.3 向CSS学习    
5.4 分离JavaScript    
5.5.1 对象检测    
5.5.2 浏览器嗅探技术    
5.6 性能考虑    
5.6.1 尽量少访问DOM和尽量减少标记    
5.6.2 合并和放置脚本    
5.6.3 压缩脚本    
5.7 小结    
第6章 案例研究：图片库改进版    
6.2 它支持平稳退化吗    
6.3 它的JavaScript与HTML标记是分离的吗    
6.3.1 添加事件处理函数    
6.3.2 共享onload事件    
6.4 不要做太多的假设    
6.5 优化    
6.6 键盘访问    
6.7 把JavaScript与CSS结合起来    
6.8 DOM Core和HTML-DOM    
6.9 小结    
第7章 动态创建标记    
7.1 一些传统方法    
7.1.1 document.write    
7.1.2 innerHTML属性    
7.2 DOM方法    
7.2.1 createElement方法    
7.2.2 appendChild方法    
7.2.3 createTextNode方法    
7.2.4 一个更复杂的组合    
7.3 重回图片库    
7.3.1 在已有元素前插入一个新元素    
7.3.2 在现有方法后插入一个新元素    
7.3.3 图片库二次改进版    
7.4 Ajax    
7.4.1 XMLHttpRequest对象    
7.4.2 渐进增强与Ajax    
7.4.3 Hijax    
7.5 小结    
第8章 充实文档的内容    
8.1 不应该做什么    
8.2 把“不可见”变成“可见”    
8.3 内容    
8.3.1 选用HTML、XHTML还是HTML5    
8.3.2 CSS    
8.3.3 JavaScript    
8.4 显示“缩略语列表”    
8.4.1 编写displayAbbreviations函数    
8.4.2 创建标记    
8.4.3 一个浏览器“地雷”    
8.5 显示“文献来源链接表”   
* firebug
省查页面中的元素 快捷键 C-S-c
* jQuery 选择器


jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 
 
$("#myELement")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 
$("div")           选择所有的div标签元素，返回div元素数组 
$(".myClass")      选择使用myClass类的css的所有元素 
$("*")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 
 
层叠选择器： 
$("form input")         选择所有的form元素中的input元素 
$("#main > *")          选择id值为main的所有的子元素 
$("label + input")     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 
$("#prev ~ div")       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 
 
基本过滤选择器： 
$("tr:first")               选择所有tr元素的第一个 
$("tr:last")                选择所有tr元素的最后一个 
$("input:not(:checked) + span")   
 
过滤掉：checked的选择器的所有的input元素 
 
$("tr:even")               选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） 
 
$("tr:odd")                选择所有的tr元素的第1，3，5... ...个元素 
$("td:eq(2)")             选择所有的td元素中序号为2的那个td元素 
$("td:gt(4)")             选择td元素中序号大于4的所有td元素 
$("td:ll(4)")              选择td元素中序号小于4的所有的td元素 
$(":header") 
$("div:animated") 
内容过滤选择器： 
 
$("div:contains('John')") 选择所有div中含有John文本的元素 
$("td:empty")           选择所有的为空（也不包括文本节点）的td元素的数组 
$("div:has(p)")        选择所有含有p标签的div元素 
$("td:parent")          选择所有的以td为父节点的元素数组 
可视化过滤选择器： 
 
$("div:hidden")        选择所有的被hidden的div元素 
$("div:visible")        选择所有的可视化的div元素 
属性过滤选择器： 
 
$("div[id]")              选择所有含有id属性的div元素 
$("input[name='newsletter']")    选择所有的name属性等于'newsletter'的input元素 
 
$("input[name!='newsletter']") 选择所有的name属性不等于'newsletter'的input元素 
 
$("input[name^='news']")         选择所有的name属性以'news'开头的input元素 
$("input[name$='news']")         选择所有的name属性以'news'结尾的input元素 
$("input[name*='man']")          选择所有的name属性包含'news'的input元素 
 
$("input[id][name$='man']")    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 
 
子元素过滤选择器： 
 
$("ul li:nth-child(2)"),$("ul li:nth-child(odd)"),$("ul li:nth-child(3n + 1)") 
 
$("div span:first-child")          返回所有的div元素的第一个子节点的数组 
$("div span:last-child")           返回所有的div元素的最后一个节点的数组 
$("div button:only-child")       返回所有的div中只有唯一一个子节点的所有子节点的数组 
 
表单元素选择器： 
 
$(":input")                  选择所有的表单输入元素，包括input, textarea, select 和 button 
 
$(":text")                     选择所有的text input元素 
$(":password")           选择所有的password input元素 
$(":radio")                   选择所有的radio input元素 
$(":checkbox")            选择所有的checkbox input元素 
$(":submit")               选择所有的submit input元素 
$(":image")                 选择所有的image input元素 
jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 
 
$("#myELement")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 
$("div")           选择所有的div标签元素，返回div元素数组 
$(".myClass")      选择使用myClass类的css的所有元素 
$("*")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 
 
层叠选择器： 
$("form input")         选择所有的form元素中的input元素 
$("#main > *")          选择id值为main的所有的子元素 
$("label + input")     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 
$("#prev ~ div")       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 
 
基本过滤选择器： 
$("tr:first")               选择所有tr元素的第一个 
$("tr:last")                选择所有tr元素的最后一个 
$("input:not(:checked) + span")   
 
过滤掉：checked的选择器的所有的input元素 
 
$("tr:even")               选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） 
 
$("tr:odd")                选择所有的tr元素的第1，3，5... ...个元素 
$("td:eq(2)")             选择所有的td元素中序号为2的那个td元素 
$("td:gt(4)")             选择td元素中序号大于4的所有td元素 
$("td:ll(4)")              选择td元素中序号小于4的所有的td元素 
$(":header") 
$("div:animated") 
内容过滤选择器： 
 
$("div:contains('John')") 选择所有div中含有John文本的元素 
$("td:empty")           选择所有的为空（也不包括文本节点）的td元素的数组 
$("div:has(p)")        选择所有含有p标签的div元素 
$("td:parent")          选择所有的以td为父节点的元素数组 
可视化过滤选择器： 
 
$("div:hidden")        选择所有的被hidden的div元素 
$("div:visible")        选择所有的可视化的div元素 
属性过滤选择器： 
 
$("div[id]")              选择所有含有id属性的div元素 
$("input[name='newsletter']")    选择所有的name属性等于'newsletter'的input元素 
 
$("input[name!='newsletter']") 选择所有的name属性不等于'newsletter'的input元素 
 
$("input[name^='news']")         选择所有的name属性以'news'开头的input元素 
$("input[name$='news']")         选择所有的name属性以'news'结尾的input元素 
$("input[name*='man']")          选择所有的name属性包含'news'的input元素 
 
$("input[id][name$='man']")    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 
 
子元素过滤选择器： 
 
$("ul li:nth-child(2)"),$("ul li:nth-child(odd)"),$("ul li:nth-child(3n + 1)") 
 
$("div span:first-child")          返回所有的div元素的第一个子节点的数组 
$("div span:last-child")           返回所有的div元素的最后一个节点的数组 
$("div button:only-child")       返回所有的div中只有唯一一个子节点的所有子节点的数组 
 
表单元素选择器： 
 
$(":input")                  选择所有的表单输入元素，包括input, textarea, select 和 button 
 
$(":text")                     选择所有的text input元素 
$(":password")           选择所有的password input元素 
$(":radio")                   选择所有的radio input元素 
$(":checkbox")            选择所有的checkbox input元素 
$(":submit")               选择所有的submit input元素 
$(":image")                 选择所有的image input元素 
$(":reset")                   选择所有的reset input元素 
$(":button")                选择所有的button input元素 
$(":file")                     选择所有的file input元素 
$(":hidden")               选择所有类型为hidden的input元素或表单的隐藏域 
 
表单元素过滤选择器： 
 
$(":enabled")             选择所有的可操作的表单元素 
$(":disabled")            选择所有的不可操作的表单元素 
$(":checked")            选择所有的被checked的表单元素 
$("select option:selected") 选择所有的select 的子元素中被selected的元素 
 
  
 
选取一个 name 为”S_03_22″的input text框的上一个td的text值
$(”input[@ name =S_03_22]“).parent().prev().text() 
 
名字以”S_”开始，并且不是以”_R”结尾的
$(”input[@ name ^='S_']“).not(”[@ name $='_R']“) 
 
一个名为 radio_01的radio所选的值
$(”input[@ name =radio_01][@checked]“).val(); 
 
  
 
  
 
$("A B") 查找A元素下面的所有子节点，包括非直接子节点
$("A>B") 查找A元素下面的直接子节点
$("A+B") 查找A元素后面的兄弟节点，包括非直接子节点
$("A~B") 查找A元素后面的兄弟节点，不包括非直接子节点 
 
1. $("A B") 查找A元素下面的所有子节点，包括非直接子节点 
 
例子：找到表单中所有的 input 元素 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("form input") 
结果: 
 
[ <input name="name" />, <input name="newsletter" /> ] 
 
2. $("A>B") 查找A元素下面的直接子节点 
例子：匹配表单中所有的子级input元素。 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("form > input") 
结果: 
 
[ <input name="name" /> ] 
 
3. $("A+B") 查找A元素后面的兄弟节点，包括非直接子节点 
例子：匹配所有跟在 label 后面的 input 元素 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("label + input") 
结果: 
* javscript

org模式自动换行 .emacs
(add-hook 'org-mode-hook (lambda () (setq truncate-lines nil))) 



javascript的self和this使用小结
revert 
一、self
这个非常简单。我们知道，打开任何一个网页，浏览器会首先创建一个窗口，这个窗口就是一个window对象，也是js运行所依附的全局环境对象和全局作用域对象。self 指窗口本身，它返回的对象跟window对象是一模一样的。也正因为如此，window对象的常用方法和函数都可以用self代替window。举个例子，常见的写法如“self.close();”，把它放在<a>标记中：“<a href="javascript:self.close();">关闭窗口</a>”，单击“关闭窗口”链接，当前页面关闭。
二、this关键字
在讲this之前，看下面的一段代码：


<body>
<script type="text/javascript">
function thisTest()
  {
      this.textValue = 'this的dom测试';
      this.element= document.createElement('span');
      this.element.innerHTML = this.textValue;
      this.element.style.color = "blue";
      this.element.style.cursor = "pointer";
      this.element.attachEvent('onclick', this.ToString);
  }
   
  thisTest.prototype.RenderDom = function()
  {
      document.body.appendChild(this.element);
  }     

  thisTest.prototype.ToString = function()
  {
      alert("单击我："+this.textValue);
  };
  var test= new thisTest();
  test.RenderDom(); 
  //test.ToString();
</script>
</body>

本来的目的是想在body中添加一个span元素，对于这个span元素，制定了它的字体颜色，悬浮在它上面的鼠标样式和单击触发事件。问题就出现在它的单击事件上（弹出"单击我:undefined"）。也许有人会说你丫傻呀，写这么多sb代码还不就是为了实现下面这个东东吗？
<span style='cursor:pointer;color:blue;' onclick="alert(this.innerHTML)">this的dom测试</span>

你看多简单直观，而且还不容易出错？！kao，我晕。我正要讲的是您正在使用的this.innerHTML中的this呀。
1、this到底指什么？
我们熟悉的c#有this关键字，它的主要作用就是指代当前对象实例（参数传递和索引器都要用到this）。在javascript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）。
2、常见使用方式
（1）、直接在dom元素中使用
<input id="btnTest" type="button" value="提交" onclick="alert(this.value))" />

分析：对于dom元素的一个onclick（或其他如onblur等）属性，它为所属的html元素所拥有，直接在它触发的函数里写this，this应该指向该html元素。
（2）、给dom元素注册js函数
a、不正确的方式
复制代码
<script type="text/javascript">
  function thisTest(){
  alert(this.value); // 弹出undefined, this在这里指向??
}
</script>

<input id="btnTest" type="button" value="提交" onclick="thisTest()" />
复制代码

 分析：onclick事件直接调用thisTest函数，程序就会弹出undefined。因为thisTest函数是在window对象中定义的，
所以thisTest的拥有者（作用域）是window，thisTest的this也是window。而window是没有value属性的，所以就报错了。
b、正确的方式

<input id="btnTest" type="button" value="提交" />

<script type="text/javascript">
  function thisTest(){
  alert(this.value); 
}
document.getElementById("btnTest").onclick=thisTest; //给button的onclick事件注册一个函数
</script>

分析：在前面的示例中，thisTest函数定义在全局作用域（这里就是window对象），所以this指代的是当前的window对象。而通过document.getElementById("btnTest").onclick=thisTest;这样的形式，其实是将btnTest的onclick属性设置为thisTest函数的一个副本，在btnTest的onclick属性的函数作用域内，this归btnTest所有，this也就指向了btnTest。其实如果有多个dom元素要注册该事件，我们可以利用不同的dom元素id，用下面的方式实现：
document.getElementById("domID").onclick=thisTest; //给button的onclick事件注册一个函数。
因为多个不同的HTML元素虽然创建了不同的函数副本，但每个副本的拥有者都是相对应的HTML元素，各自的this也都指向它们的拥有者，不会造成混乱。
为了验证上述说法，我们改进一下代码，让button直接弹出它们对应的触发函数：

<input id="btnTest1" type="button" value="提交1" onclick="thisTest()" />
<input id="btnTest2" type="button" value="提交2" />

<script type="text/javascript">
function thisTest(){
this.value="提交中";
}
var btn=document.getElementById("btnTest1");
alert(btn.onclick); //第一个按钮函数

var btnOther=document.getElementById("btnTest2");
btnOther.onclick=thisTest;
alert(btnOther.onclick); //第二个按钮函数
</script>

其弹出的结果是：
复制代码
//第一个按钮
function onclick(){
  thisTest()
}
 
//第二个按钮
function thisTest(){
  this.value="提交中";
}
复制代码

从上面的结果你一定理解的更透彻了。
By the way，每新建一个函数的副本，程序就会为这个函数副本分配一定的内存。而实际应用中，大多数函数并不一定会被调用，于是这部分内存就被白白浪费了。所以我们通常都这么写：

<input id="btnTest1" type="button" value="提交1" onclick="thisTest(this)" />
<input id="btnTest2" type="button" value="提交2" onclick="thisTest(this)" />
<input id="btnTest3" type="button" value="提交3" onclick="thisTest(this)" />
<input id="btnTest4" type="button" value="提交4" onclick="thisTest(this)" />

<script type="text/javascript">
  function thisTest(obj){
  alert(obj.value); 
}
</script>

这是因为我们使用了函数引用的方式，程序就只会给函数的本体分配内存，而引用只分配指针。这样写一个函数，调用的地方给它分配一个（指针）引用，这样效率就高很多。当然，如果你觉得这样注册事件不能兼容多种浏览器，可以写下面的注册事件的通用脚本：

//js事件 添加 EventUtil.addEvent(dom元素,事件名称,事件触发的函数名) 移除EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)
var EventUtil = new eventManager();

//js事件通用管理器 dom元素 添加或者移除事件
function eventManager() {
    //添加事件
    //oDomElement:dom元素,如按钮,文本,document等; ****** oEventType:事件名称(如:click,如果是ie浏览器,自动将click转换为onclick);****** oFunc:事件触发的函数名
    this.addEvent = function(oDomElement, oEventType, oFunc) {
        //ie
        if (oDomElement.attachEvent) {
            oDomElement.attachEvent("on" + oEventType, oFunc);
        }
        //ff,opera,safari等
        else if (oDomElement.addEventListener) {
            oDomElement.addEventListener(oEventType, oFunc, false);
        }
        //其他
        else {
            oDomElement["on" + oEventType] = oFunc;
        }
    }

    this.removeEvent = function(oDomElement, oEventType, oFunc) {
        //ie
        if (oDomElement.detachEvent) {
            oDomElement.detachEvent("on" + oEventType, oFunc);
        }
        //ff,opera,safari等
        else if (oDomElement.removeEventListener) {
            oDomElement.removeEventListener(oEventType, oFunc, false);
        }
        //其他
        else {
            oDomElement["on" + oEventType] = null;
        }
    }
}

 正像注释写的那样，要注册dom元素事件，用EventUtil.addEvent(dom元素,事件名称,事件触发的函数名)即可， 移除时可以这样写：EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)。这是题外话，不说了。
(3)、类定义中使用this关键字
这个其实再常见不过，看示例：

function thisTest()
  {
      var tmpName = 'jeff wong';
      this.userName= 'jeff wong';
  }

var test= new thisTest();
alert(test.userName==test.tmpName);//false
alert(test.userName); //jeff wong
alert(test.tmpName); //undefined

 分析一下结果，其实这里的this和c#里的是类似的。
（4）、为脚本对象添加原形方法
理解这里的前提是你必须了解js里的原型概念（说道这里，kao，我还真的需要面壁一下）：js中对象的prototype属性，是用来返回对象类型原型的引用的。所有js内部对象都有只读的prototype属性，可以向其原型中动态添加功能(属性和方法)，
但该对象不能被赋予不同的原型。但是对于用户定义的对象可以被赋给新的原型。看个简单的示例：

//js的内部对象String,向其原型中动态添加功能(属性和方法)
//去掉字符串两端的空白字符
String.prototype.Trim = function() {
    return this.replace(/(^\s+)|(\s+$)/g, "");
}

function thisTest()
  {
      var tmpName = 'jeff wong';
      this.userName= '      jeff wong  ';
  }
//给用户定义的对象添加原型方法
thisTest.prototype.ToString = function()
  {
      alert(this.userName); //jeff wong(*有空格*)
      alert(this.userName.Trim()); //jeff wong (*无空格*)
      //alert(tmpName); //脚本错误,tmpName未定义
  }

var test= new thisTest();
test.ToString(); //调用原型的ToString()

function myTest(){
  this.userName= '  test ';
}
var test1=new myTest();
//test1.ToString(); //这里暂时不支持调用ToString()方法

//用户定义的对象被赋给新的原型
myTest.prototype = new thisTest();
test1.ToString(); //调用原型的ToString()

测试结果显示，这里的this指代的是被添加原形（方法或属性）的类的实例，和（3）中的定义基本相似。
（5）、在函数的内部函数中使用this关键字
这个你要是理解作用域和闭包，问题就迎刃而解。看最典型的示例：

function thisTest()
  {
      this.userName= 'outer userName';
      function innerThisTest(){
        var userName="inner userName";
        alert(userName); //inner userName
        alert(this.userName); //outer userName
      }
     return innerThisTest;
  }

thisTest()();

分析：thisTest()调用内部的innerThisTest函数，形成一个闭包。innerThisTest执行时，第一次弹出innerUserName，是因为innerThisTest函数作用域内有一个变量叫userName，所以直接弹出当前作用域下变量的指定值；第二次弹出outer  userName是因为innerThisTest作用域内没有userName属性（示例中的this.userName）,所以它向上一级作用域中找userName属性，这次在thisTest中找到（示例中的this.userName= 'outer userName';），所以弹出对应值。
（6）通过Function的call和apply函数指定特定的this
这个指定来指定去，this就有可能造成“你中有我，我中有你”的局面，不想把自己弄晕了的话，了解一下就可以了。改变this指定对象对于代码维护也是一件很不好的事情。贴出旧文中的示例代码结束吧：

function myFuncOne() {
    this.p = "myFuncOne-";
    this.A = function(arg) {
        alert(this.p + arg);
