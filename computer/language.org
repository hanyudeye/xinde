* c 
** 程序结构
预处理器指令
函数
变量
定义 int i; //声明，也是定义
声明 extern int i; //声明，不是定义
常量
使用 #define 预处理器。 //预处理器会处理掉,不用编译器处理
使用 const 关键字。
*** C 存储类 定义 C 程序中变量/函数的范围（可见性）和生命周期
**** auto 存储类是所有局部变量默认的存储类
**** register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量,最大尺寸等于寄存器的大小
: 不能对它应用一元的 '&' 运算符（因为它没有内存位置
**** static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁
**** extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
语句 & 表达式
注释 /* comment */ or //
C 结构体
#+BEGIN_SRC c
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables]; 
#+END_SRC
C 共用体
#+BEGIN_SRC c
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];  
#+END_SRC
C 位域 (节省空间)
#+BEGIN_SRC c
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
#+END_SRC
C typedef (别名)
: typedef unsigned char BYTE;
*** C 输入 & 输出
**** getchar() & putchar() 函数
int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。
int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。
**** gets() & puts() 函数
char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。
int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。
**** scanf() 和 printf() 函数
int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。
int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。
*** C 文件读写
**** 打开 FILE *fopen( const char * filename, const char * mode );
**** 关闭 int fclose( FILE *fp );
**** 写入 int fputc( int c, FILE *fp ); /int fputs( const char *s, FILE *fp );
**** 读取 char *fgets( char *buf, int n, FILE *fp );
*** 头文件
#+BEGIN_SRC c
#ifndef HEADER_FILE
#define HEADER_FILE
the entire header file file
#endif
#+END_SRC
**** 多系统
#+BEGIN_SRC c
 #define SYSTEM_H "system_1.h"
 ...
 #include SYSTEM_H
#+END_SRC
*** C 错误处理
: 大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 <error.h> 头文件中找到各种各样的错误代码。
: 开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。
**** perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
**** strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
**** 程序退出状态
*****  exit(EXIT_FAILURE) 调用系统宏
*****  exit(EXIT_SUCCESS)
*** C 递归 调用自己
*** C 可变参数
*** C 内存管理 动态内存分配与管理 <stdlib.h>
**** void *calloc(int num, int size);该函数分配一个带有 num 个元素的数组，每个元素的大小为 size 字节。
**** void free(void *address);该函数释放 address 所指向的h内存块。
**** void *malloc(int num);该函数分配一个 num 字节的数组，并把它们进行初始化。
**** void *realloc(void *address, int newsize);该函数重新分配内存，把内存扩展到 newsize。
*** C 命令行参数 int main( int argc, char *argv[] ) 
** C 标准库
*** <assert.h>
 C 标准库的 assert.h头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。
已定义的宏 assert 指向另一个宏 NDEBUG，宏 NDEBUG 不是 <assert.h> 的一部分。如果已在引用 <assert.h> 的源文件中定义 NDEBUG 为宏名称，则 assert 宏的定义如下：
#define assert(ignore) ((void)0)
<ctype.h>
这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。
int isalnum(int c)该函数检查所传的字符是否是字母和数字。
int isalpha(int c)该函数检查所传的字符是否是字母。
int iscntrl(int c)该函数检查所传的字符是否是控制字符。
int isdigit(int c)该函数检查所传的字符是否是十进制数字。
int isgraph(int c)该函数检查所传的字符是否有图形表示法。
int islower(int c)该函数检查所传的字符是否是小写字母。
int isprint(int c)该函数检查所传的字符是否是可打印的。
int ispunct(int c)该函数检查所传的字符是否是标点符号字符。
int isspace(int c)该函数检查所传的字符是否是空白字符。
int isupper(int c)该函数检查所传的字符是否是大写字母。
int isxdigit(int c)该函数检查所传的字符是否是十六进制数字。
int tolower(int c)该函数把大写字母转换为小写字母。
int toupper(int c)该函数把小写字母转换为大写字母。
<float.h>
库宏
下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。
| FLT_ROUNDS          | 定义浮点加法的舍入模式，-1,不确定;0,趋于0;1,去最近的值;2,正无穷;3,负无穷            |
| FLT_RADIX 2         | 定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。 |
| FLT_MANT_DIG        | 这些宏定义了 FLT_RADIX 基数中的位数。                                               |
| FLT_DIG 6           | 这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。                     |
| FLT_MIN_EXP         | 这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。          |
| LDBL_MIN_10_EXP -37 | 这些宏定义了基数为 10 时的指数的最小负整数值。                 |
| LDBL_MAX_EXP        | 这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。                                 |
| LDBL_MAX_10_EXP +37 | 这些宏定义了基数为 10 时的指数的最大整数值。                                        |
| LDBL_MAX 1E+37      | 这些宏定义最大的有限浮点值。                                                        |
| LDBL_EPSILON 1E-9   | 这些宏定义了可表示的最小有效数字。                                                  |
| LDBL_MIN 1E-37      | 这些宏定义了最小的浮点值。                                                          |
*** limits.h
*** float.h
*** string.h
* apue
***  Files and Directories
filesystem  filename 文件属性
文件名
路径名 /开头的是绝对路径
***  Input and Output        
***  Programs and Processes  
***  Error Handling        
***  User Identification   
***  Signals         
***  Time Values                                                    
***  System Calls and Library Functions                             
***  Summary                                                        
*** Chapter 2.   UNIX Standardization and Implementations                
***  Introduction                                                    
***  UNIX Standardization                                            
***  ISO C                                                         
    sert.h>         verify program assertion 
    mplex.h>        complex arithmetic support 
    ype.h>          character classiﬁcation and mapping support 
    rno.h>          error codes (Section 1.7) 
    nv.h>           ﬂoating-point environment 
    oat.h>          ﬂoating-point constants and characteristics 
    ttypes.h>       integer type format conversion 
    o646.h>         macros for assignment, relational, and unary operators 
    mits.h>         implementation constants (Section 2.5) 
    cale.h>         locale categories and related deﬁnitions 
    th.h>           mathematical function and type declarations and constants 
    tjmp.h>         nonlocal goto (Section 7.10) 
    gnal.h>         signals (Chapter 10) 
    darg.h>         variable argument lists 
    dbool.h>        Boolean type and values 
    ddef.h>         standard deﬁnitions 
    dint.h>         integer types 
    dio.h>          standard I/O library (Chapter 5) 
    dlib.h>         utility functions 
    ring.h>         string operations 
    math.h>         type-generic math macros 
    me.h>           time and date (Section 6.10) 
    har.h>          extended multibyte and wide character support 
    type.h>         wide character classiﬁcation and mapping support 

***  IEEE POSIX                                                    
         <aio.h>              asynchronous I/O 
         <cpio.h>             cpio archive values 
         <dirent.h>           directory entries (Section 4.22) 
         <dlfcn.h>            dynamic linking 
         <fcntl.h>            ﬁle control (Section 3.14) 
         <fnmatch.h>          ﬁlename-matching types 
         <glob.h>             pathname pattern-matching and generation 
         <grp.h>              group ﬁle (Section 6.4) 
         <iconv.h>            codeset conversion utility 
         <langinfo.h>         language information constants 
         <monetary.h>         monetary types and functions 
         <netdb.h>            network database operations 
         <nl_types.h>         message catalogs 
         <poll.h>             poll function (Section 14.4.2) 
         <pthread.h>          threads (Chapters 11 and 12) 
         <pwd.h>              password ﬁle (Section 6.2) 
         <regex.h>            regular expressions 
         <sched.h>            execution scheduling 
         <semaphore.h>        semaphores 
         <strings.h>          string operations 
         <tar.h>              tar archive values 
         <termios.h>          terminal I/O (Chapter 18) 
         <unistd.h>           symbolic constants 
         <wordexp.h>          word-expansion deﬁnitions 
         <arpa/inet.h>        Internet deﬁnitions (Chapter 16) 
         <net/if.h>           socket local interfaces (Chapter 16) 
         <netinet/in.h>       Internet address family (Section 16.3) 
         <netinet/tcp.h>      Transmission Control Protocol deﬁnitions 
         <sys/mman.h>         memory management declarations 
         <sys/select.h>       selectfunction (Section 14.4.1) 
         <sys/socket.h>       sockets interface (Chapter 16) 
         <sys/stat.h>         ﬁle status (Chapter 4) 
         <sys/statvfs.h>      ﬁle system information 
         <sys/times.h>        process times (Section 8.17) 
         <sys/types.h>        primitive system data types (Section 2.8) 
         <sys/un.h>           UNIX domain socket deﬁnitions (Section 17.2) 
         <sys/utsname.h>      system name (Section 6.9) 
         <sys/wait.h>         process control (Section 8.6) 

***  The Single UNIX Specification                                 
***  FIPS                                                          
***  UNIX System Implementations                                     
***  UNIX System V Release 4                                       
*** 2.3.4  Linux                                                         
*** 2.3.5  Mac OS X                                                      
*** 2.3.6  Solaris                                                       
*** 2.3.7  Other UNIX Systems                                            
*** 2.4  Relationship of Standards and Implementations                     
***                                                                      
*** 2.5  Limits                                                          
*** 2.5.1  ISO C Limits                                                  
*** 2.5.2  POSIX Limits                                                  
*** 2.5.3  XSI Limits                                                    
*** 2.5.4  sysconf, pathconf, and fpathconf Functions                      
***                                                                      
*** 
*** 2.5.5  Indeterminate Runtime Limits                                  
*** 2.6  Options                                                         
*** 2.7  Feature Test Macros                                             
*** 2.8  Primitive System Data Types     
*** 2.9  Differences Between Standards   
*** 2.10  Summary         
*** Chapter 3.   File I/O                                               
*** 3.1  Introduction                                                   
*** 3.2  File Descriptors                                               
*** 3.3  open and openat Functions                                      
*** 3.4  creat Function                                                 
*** 3.5  close Function                                                 
*** 3.6  lseek Function                                                 
*** 3.7  read Function                                                  
*** 3.8  write Function                                                 
*** 3.9  I/O Efficiency                                                 
*** 3.10  File Sharing                                                  
*** 3.11  Atomic Operations                                             
*** 3.12  dup and dup2 Functions                                        
*** 3.13  sync, fsync, and fdatasync Functions                          
*** 3.14  fcntl Function                                                
*** 3.15  ioctl Function                                                
*** 3.16  /dev/fd                                                       
*** 3.17  Summary                                                       
*** Chapter 4.   Files and Directories                                  
*** 4.1  Introduction                                                   
*** 4.2  stat, fstat, fstatat, and lstat Functions                         
***                                                                     
*** 4.3  File Types                                                     
*** 4.4  Set-User-ID and Set-Group-ID                                   
*** 4.5  File Access Permissions                                        
*** 4.6  Ownership of New Files and Directories                            
*** 
*** 4.7  access and faccessat Functions      
*** 4.8  umask Function       
*** 4.9  chmod, fchmod, and fchmodat Functions      
*** 4.10  Sticky Bit       
*** 4.11  chown, fchown, fchownat, and lchown Functions                    
***                                                                    
*** 4.12  File Size                                                    
*** 4.13  File Truncation                                              
*** 4.14  File Systems                                                 
*** 4.15  link, linkat, unlink, unlinkat, and remove                       
*** Functions                                                          
*** 4.16  rename and renameat Functions                                
*** 4.17  Symbolic Links                                               
*** 4.18  Creating and Reading Symbolic Links                          
*** 4.19  File Times                                                   
*** 4.20  futimens, utimensat, and utimes Functions                        
***                                                                    
*** 4.21  mkdir, mkdirat, and rmdir Functions                          
*** 4.22  Reading Directories                                          
*** 4.23  chdir, fchdir, and getcwd Functions                          
*** 4.24  Device Special Files                                         
*** 4.25  Summary of File Access Permission Bits                           
***                                                                    
*** 4.26  Summary                                                      
*** Chapter 5.   Standard I/O Library                                  
*** 5.1  Introduction                                                  
*** 5.2  Streams and FILE Objects                                      
*** 5.3  Standard Input, Standard Output, and Standard                     
*** Error                                                              
*** 5.4  Buffering                                                     
*** 5.5  Opening a Stream                                              
*** 5.6  Reading and Writing a Stream                                  
*** 5.7  Line-at-a-Time I/O                                            
*** 5.8  Standard I/O Efficiency                                       
*** 5.9  Binary I/O                                                    
*** 5.10  Positioning a Stream                                         
*** 5.11  Formatted I/O                                                
*** 5.12  Implementation Details                                       
*** 5.13  Temporary Files                                              
*** 5.14  Memory Streams                                               
*** 5.15  Alternatives to Standard I/O                                 
*** 5.16  Summary                                                      
*** Chapter 6.   System Data Files and Information                     
*** 6.1  Introduction                                                  
*** 6.2  Password File                                                 
*** 6.3  Shadow Passwords                                              
*** 6.4  Group File                                                    
*** 6.5  Supplementary Group IDs                                       
*** 6.6  Implementation Differences                                    
*** 6.7  Other Data Files                                              
*** 6.8  Login Accounting                                              
*** 6.9  System Identification                                         
*** 6.10  Time and Date Routines                                       
*** 6.11  Summary                                                      
*** Chapter 7.   Process Environment                                   
*** 7.1  Introduction                                                  
*** 7.2  main Function                                                 
*** 7.3  Process Termination                                           
*** 7.4  Command-Line Arguments                                        
*** 7.5  Environment List                                              
*** 7.6  Memory Layout of a C Program                                  
*** 7.7  Shared Libraries                                              
*** 7.8  Memory Allocation                                             
*** 7.9  Environment Variables                                         
*** 7.10  setjmp and longjmp Functions                                 
*** 7.11  getrlimit and setrlimit Functions                            
*** 7.12  Summary                                                      
*** Chapter 8.   Process Control                                       
*** 8.1  Introduction                                                  
*** 8.2  Process Identifiers                                           
*** 8.3  fork Function                                                 
*** 8.4  vfork Function                                                
*** 8.5  exit Functions                                                
*** 8.6  wait and waitpid Functions                                    
*** 8.7  waitid Function                                               
*** 8.8  wait3 and wait4 Functions                                     
*** 8.9  Race Conditions                                               
*** 8.10  exec Functions                                               
*** 8.11  Changing User IDs and Group IDs                              
*** 8.12  Interpreter Files                                            
*** 8.13  system Function                                              
*** 8.14  Process Accounting                                           
*** 8.15  User Identification                                          
*** 8.16  Process Scheduling                                           
*** 8.17  Process Times                                                
*** 8.18  Summary                                                      
*** Chapter 9.   Process Relationships                                 
*** 9.1  Introduction                                                  
*** 9.2  Terminal Logins                                               
*** 9.3  Network Logins                                                
*** 9.4  Process Groups                                                
*** 9.5  Sessions                                                      
*** 9.6  Controlling Terminal                                          
*** 9.7  tcgetpgrp, tcsetpgrp, and tcgetsid Functions                      
***                                                                    
*** 9.8  Job Control                                                   
*** 9.9  Shell Execution of Programs                                   
*** 9.10  Orphaned Process Groups                                      
*** 9.11  FreeBSD Implementation                                       
*** 9.12  Summary                                                      
*** Chapter.   Signals                                              
*** 10.1  Introduction                                                 
*** 10.2  Signal Concepts                                              
*** 10.3  signal Function                                              
*** 10.4  Unreliable Signals                                           
*** 10.5  Interrupted System Calls                                     
*** 10.6  Reentrant Functions                                          
*** 10.7  SIGCLD Semantics                                             
*** 10.8  Reliable-Signal Terminology and Semantics      
*** 10.9  kill and raise Functions                                     
*** 10.10  alarm and pause Functions                                   
*** 10.11  Signal Sets                                                 
*** 10.12  sigprocmask Function                                        
*** 10.13  sigpending Function                                         
*** 10.14  sigaction Function                                          
*** 10.15  sigsetjmp and siglongjmp Functions                          
*** 10.16  sigsuspend Function                                         
*** 10.17  abort Function                                              
*** 10.18  system Function                                             
*** 10.19  sleep, nanosleep, and clock_nanosleep Functions                 
***                                                                    
*** 10.20  sigqueue Function                                           
*** 10.21  Job-Control Signals                                         
*** 10.22  Signal Names and Numbers                                    
*** 10.23  Summary                                                     
*** Chapter 11.   Threads                                              
*** 11.1  Introduction                                                 
*** 11.2  Thread Concepts                                              
*** 11.3  Thread Identification                                        
*** 11.4  Thread Creation                                              
*** 11.5  Thread Termination                                           
*** 11.6  Thread Synchronization                                       
*** 11.6.1  Mutexes                                                    
*** 11.6.2  Deadlock Avoidance                                         
*** 11.6.3  pthread_mutex_timedlock Function                           
*** 11.6.4  Reader-Writer Locks                                        
*** 11.6.5  Reader-Writer Locking with Timeouts
*** 11.6.6  Condition Variables                                        
*** 11.6.7  Spin Locks                                                 
*** 11.6.8  Barriers                                                   
*** 11.7  Summary                                                      
*** Chapter 12.   Thread Control                                       
*** 12.1  Introduction                                                 
*** 12.2  Thread Limits                                                
*** 12.3  Thread Attributes                                            
*** 12.4  Synchronization Attributes                                   
*** 12.4.1  Mutex Attributes                                           
*** 12.4.2  Reader-Writer Lock Attributes                              
*** 12.4.3  Condition Variable Attributes                              
*** 12.4.4  Barrier Attributes                                         
*** 12.5  Reentrancy                                                   
*** 12.6  Thread-Specific Data                                         
*** 12.7  Cancel Options                                               
*** 12.8  Threads and Signals                                          
*** 12.9  Threads and fork                                             
*** 12.10  Threads and I/O                                             
*** 12.11  Summary                                                     
*** Chapter 13.   Daemon Processes                                     
*** 13.1  Introduction                                                 
*** 13.2  Daemon Characteristics                                       
*** 13.3  Coding Rules                                                 
*** 13.4  Error Logging                                                
*** 13.5  Single-Instance Daemons                                      
*** 13.6  Daemon Conventions                                           
*** 13.7  Client-Server Model                                          
*** 13.8  Summary                                                      
*** Chapter 14.   Advanced I/O                                         
*** 14.1  Introduction                                                 
*** 14.2  Nonblocking I/O                                              
*** 14.3  Record Locking                                               
*** 14.4  I/O Multiplexing                                             
*** 14.4.1  select and pselect Functions                               
*** 14.4.2  poll Function                                              
*** 14.5  Asynchronous I/O                                             
*** 14.5.1  System V Asynchronous I/O                                  
*** 14.5.2  BSD Asynchronous I/O                                       
*** 14.5.3  POSIX Asynchronous I/O                                     
*** 14.6  readv and writev Functions                                   
*** 14.7  readn and writen Functions                                   
*** 14.8  Memory-Mapped I/O                                            
*** 14.9  Summary                                                      
*** Chapter 15.   Interprocess Communication                           
*** 15.1  Introduction                                                 
*** 15.2  Pipes                                                        
*** 15.3  popen and pclose Functions                                   
*** 15.4  Coprocesses                                                  
*** 15.5  FIFOs                                                        
*** 15.6  XSI IPC                                                      
*** 15.6.1  Identifiers and Keys                                       
*** 15.6.2  Permission Structure                                       
*** 15.6.3  Configuration Limits                                       
*** 15.6.4  Advantages and Disadvantages                               
*** 15.7  Message Queues                                               
*** 15.8  Semaphores                                                   
*** 15.9  Shared Memory                                                
*** 15.10  POSIX Semaphores                                            
*** 15.11  Client-Server Properties                                    
*** 15.12  Summary                                                     
*** Chapter 16.   Network IPC: Sockets                                 
*** 16.1  Introduction                                                 
*** 16.2  Socket Descriptors                                           
*** 16.3  Addressing                                                   
*** 16.3.1  Byte Ordering                                              
*** 16.3.2  Address Formats                                            
*** 16.3.3  Address Lookup                                             
*** 16.3.4  Associating Addresses with Sockets                         
*** 16.4  Connection Establishment                                     
*** 16.5  Data Transfer                                                
*** 16.6  Socket Options                                               
*** 16.7  Out-of-Band Data                                             
*** 16.8  Nonblocking and Asynchronous I/O                             
*** 16.9  Summary                                                      
*** Chapter 17.   Advanced IPC                                         
*** 17.1  Introduction                                                 
*** 17.2  UNIX Domain Sockets                                          
*** 17.2.1  Naming UNIX Domain Sockets                                 
*** 17.3  Unique Connections                                           
*** 17.4  Passing File Descriptors                                     
*** 17.5  An Open Server, Version 1                                    
*** 17.6  An Open Server, Version 2                                    
*** 17.7  Summary                                                      
*** Chapter 18.   Terminal I/O                                         
*** 18.1  Introduction                                                 
*** 18.2  Overview                                                     
*** 18.3  Special Input Characters                                     
*** 18.4  Getting and Setting Terminal Attributes                          
***                                                                    
*** 18.5  Terminal Option Flags                                        
*** 18.6  stty Command                                                 
*** 18.7  Baud Rate Functions                                          
*** 18.8  Line Control Functions                                       
*** 18.9  Terminal Identification                                      
*** 18.10  Canonical Mode                                              
*** 18.11  Noncanonical Mode                                           
*** 18.12  Terminal Window Size                                        
*** 18.13  termcap, terminfo, and curses                               
*** 18.14  Summary                                                     
*** Chapter 19.   Pseudo Terminals                                     
*** 19.1  Introduction                                                 
*** 19.2  Overview                                                     
*** 19.3  Opening Pseudo-Terminal Devices                              
*** 19.4  pty_fork Function                                            
*** 19.5  pty Program                                                  
*** 19.6  Using the pty Program                                        
*** 19.7  Advanced Features                                            
*** 19.8  Summary                                                      
*** Chapter 20.   A Database Library                                   
*** 20.1  Introduction                                                 
*** 20.2  History                                                      
*** 20.3  The Library                                                  
*** 20.4  Implementation Overview                                      
*** 20.5  Centralized or Decentralized?                                
*** 20.6  Concurrency                                                  
*** 20.7  Building the Library                                         
*** 20.8  Source Code                                                  
*** 20.9  Performance                                                  
*** 20.10  Summary                                                     
*** Chapter 21.   Communicating with a Network Printer                 
*** 21.1  Introduction                                                 
*** 21.2  The Internet Printing Protocol                               
*** 21.3  The Hypertext Transfer Protocol                              
*** 21.4  Printer Spooling                                             
*** 21.5  Source Code                                                  
*** 21.6  Summary                                                      
*** Appendix A.   Function Prototypes                                  
*** Appendix B.   Miscellaneous Source Code                            
*** B.1  Our Header File                                               
*** B.2  Standard Error Routines                                       
*** Appendix C.   Solutions to Selected Exercises                      
** 文件I/O
(UNIX 文件io)
(文件 打开 读 写..)
(文件 open read write lseek close)
(文件 文件描述符 )
(惯例打开使用 STDIN_FILENO STDOUT_FILENO STDERR_FILENO)
(linux 进程 (文件描述符 1048576))
(include fcntl.h)
int open(const char *pathname, int oflag,... /*mode_t mode */);
可选一个
O_RDONLY  只读打开
O_WRONLY  只写打开
O_RDWR    读写打开

可选多个
O_APPEND
O_CREAT
O_EXCL
O_TRUNC
O_NONBLOCK

O_DSYNC
O_RSYNC
O_SYNC
LINUX 三者相同 
(特点 open 描述符 返回最小 描述符数值)

(创建文件 creat(const char *pathname,mode_t mode) open(pathname, o_wronly | o_creat | o_trunc, mode))
* PHP
** 变量
四种标量类型：
boolean（布尔型）
integer（整型）
float（浮点型，也称作 double)
string（字符串）

两种复合类型：
array（数组）
object（对象）class  

最后是两种特殊类型：
resource（资源）
NULL（无类型）

在下列情况下一个变量被认为是 NULL：
被赋值为 NULL。
尚未被赋值。
被 unset()。

为了确保代码的易读性，本手册还介绍了一些伪类型：
mixed（混合类型）
number（数字类型）
callback（回调类型）
一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。
可以理解为 在某种情况下执行某种方法，而不是直接执行.对于类的参数，则要更详细，要给出类名.
1. call_user_func(array('MyClass', 'myCallbackMethod')); 
2. call_user_func('MyClass::myCallbackMethod');
3. call_user_func(array('B', 'parent::who')); // A   对于继承的类,要引用A的方法时

变量作用域
local（局部）
global（全局）来自于$var= $GLOBALS["var"] === global $var(建立一个引用,不能赋值)
static（静态）
***** 服务器数据 $_SERVER
	$_SERVER["SERVER_PORT"]  //获取端口  
	$_SERVER['HTTP_HOST']  	 //获取域名或主机地址 如test.cn
  	$_SERVER['SERVER_NAME']  //获取域名或主机地址 注：只是主域名如test.cn
	$_SERVER["REQUEST_URI"]  //获取域名后的详细地址 如：/index.php?id=123 ...  
	$_SERVER['SERVER_ROOT']  //请求的网页主目录
: $_SERVER['SCRIPT_NAME']  //包含当前脚本的路径
: $_SERVER['PHP_SELF']  //获取PHP文件名 
: 以 CGI 方式運行，二者就有明顯不同的差異,一般差不多的
	$_SERVER["QUERY_STRING"]  //获取PHP后的网址参数  
	$_SERVER['HTTP_REFERER']  //来源网页的详细地址  
	HTTPReferer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，
	服务器基此可以获得一些信息用于处理
  $_SESSION["7ad25498e6faec7e_userid"]=$manager['adminid'];
***** 客户机数据 $_POST  $_GET 

** 常量数据
   定义 define("const",33);
   预定义(全局)==魔术常量 
   __file__ | __FILE__ 函数返回的是脚本所在在的路径
   __line__ 文件中的当前行号。
*** 生成器
**** 函数 调用的参数是一份拷贝
***** 定义 function
***** 定义引用返回function &functionname
引用返回用在当你想用函数找到引用该被绑定的一个变量上面.
#+BEGIN_SRC php -n -r 
    function &find_var($param){
return $found_var;
}
$foo=&find_var($bar);
$foo->x=2;
#+END_SRC
**** 库函数
***** array 
	  foreach($array as $key=>$value){}遍历数组
	  each() 函数返回当前元素的键名和键值，并将内部指针向前移动。
	  该元素的键名和键值会被返回带有四个元素的数组中。两个元素（1 和 Value）包含键值，两个元素（0 和 Key）包含键名。
	  array()创建数组
	  current() - 返回数组中的当前元素的值
	  end() - 将内部指针指向数组中的最后一个元素，并输出
	  next() - 将内部指针指向数组中的下一个元素，并输出
	  prev() - 将内部指针指向数组中的上一个元素，并输出
	  reset() - 将内部指针指向数组中的第一个元素，并输出
	  array_values() 函数返回一个包含给定数组中所有键值的数组，但不保留键名。
	  int count ( mixed $var [, int $mode = COUNT_NORMAL ] )统计一个数组里的所有元素，或者一个对象里的东西。
	  is_array() - 检测变量是否是数组
	  array_count_values() 返回一个数组，统计的是每个值的数量，相等，数量加１
	  array_unique(array) 删除数组中重复的值,返回新数组
	  array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )  过滤器,把每个值传给callback函数,如果返回值为真，就返回过来
	  usort()	使用用户自定义的比较函数对数组进行排序。
	  array_slice(array,start,length,preserve) 函数在数组中根据条件取出一段值，并返回。
	  array()	创建数组。
	  array_change_key_case()	把数组中所有键更改为小写或大写。
	  array_chunk()	把一个数组分割为新的数组块。
	  array_column()	返回输入数组中某个单一列的值。
	  array_combine()	通过合并两个数组来创建一个新数组。
	  array_count_values()	用于统计数组中所有值出现的次数。
	  array_diff()	比较数组，返回差集（只比较键值）。
	  array_diff_assoc()	比较数组，返回差集（比较键名和键值）。
	  array_diff_key()	比较数组，返回差集（只比较键名）。
	  array_diff_uassoc()	比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。
	  array_diff_ukey()	比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。
	  array_fill()	用给定的键值填充数组。
	  array_fill_keys()	用指定键名的给定键值填充数组。
	  array_filter()	用回调函数过滤数组中的元素。
	  array_flip()	交换数组中的键和值。
	  array_intersect()	比较数组，返回交集（只比较键值）。
	  array_intersect_assoc()	比较数组，返回交集（比较键名和键值）。
	  array_intersect_key()	比较数组，返回交集（只比较键名）。
	  array_intersect_uassoc()	比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。
	  array_intersect_ukey()	比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。
	  array_key_exists()	检查指定的键名是否存在于数组中。
	  array_keys()	返回数组中所有的键名。
	  array_map()	把数组中的每个值发送到用户自定义函数，返回新的值。
	  array_merge()	把一个或多个数组合并为一个数组。
	  array_merge_recursive()	递归地合并一个或多个数组。
	  array_multisort()	对多个数组或多维数组进行排序。
	  array_pad()	用值将数组填补到指定长度。
	  array_pop()	删除数组的最后一个元素（出栈）。
	  array_product()	计算数组中所有值的乘积。
	  array_push()	将一个或多个元素插入数组的末尾（入栈）。
	  array_rand()	返回数组中一个或多个随机的键。
	  array_reduce()	通过使用用户自定义函数，以字符串返回数组。
	  array_replace()	使用后面数组的值替换第一个数组的值。
	  array_replace_recursive()	递归地使用后面数组的值替换第一个数组的值。
	  array_reverse()	以相反的顺序返回数组。
	  array_search()	搜索数组中给定的值并返回键名。
	  array_shift()	删除数组中首个元素，并返回被删除元素的值。
	  array_slice()	返回数组中被选定的部分。
	  array_splice()	删除并替换数组中指定的元素。
	  array_sum()	返回数组中值的和。
	  array_udiff()	比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。
	  array_udiff_assoc()	比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	  array_udiff_uassoc()	比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。
	  array_uintersect()	比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。
	  array_uintersect_assoc()	比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
	  array_uintersect_uassoc()	比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。
	  array_unique()	删除数组中的重复值。
	  array_unshift()	在数组开头插入一个或多个元素。
:  int array_unshift ( array &$array , mixed $var [, mixed $... ] )
	  array_values()	返回数组中所有的值。
	  array_walk()	对数组中的每个成员应用用户函数。
	  array_walk_recursive()	对数组中的每个成员递归地应用用户函数。
	  arsort()	对关联数组按照键值进行降序排序。
	  asort()	对关联数组按照键值进行升序排序。
	  compact()	创建包含变量名和它们的值的数组。
	  count()	返回数组中元素的数目。
	  current()	返回数组中的当前元素。
	  each()	返回数组中当前的键／值对。
	  end()	将数组的内部指针指向最后一个元素。
	  extract()	从数组中将变量导入到当前的符号表。
	  in_array()	检查数组中是否存在指定的值。
: bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )
: 在 haystack[干草堆] 中搜索 needle[针]，如果没有设置 strict[严格的] 则使用宽松的比较。 
	  key()	从关联数组中取得键名。
	  krsort()	对数组按照键名逆向排序。
	  ksort()	对数组按照键名排序。
	  list()	把数组中的值赋给一些变量。
	  natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。
	  natsort()	用“自然排序”算法对数组排序。
	  next()	将数组中的内部指针向前移动一位。
	  pos()	current() 的别名。
	  prev()	将数组的内部指针倒回一位。
	  range()	创建包含指定范围单元的数组。
	  reset()	将数组的内部指针指向第一个元素。
	  rsort()	对数组逆向排序。
	  shuffle()	将数组打乱。
	  sizeof()	count() 的别名。
	  sort()	对数组排序。
	  uasort()	使用用户自定义的比较函数对数组中的键值进行排序。
	  uksort()	使用用户自定义的比较函数对数组中的键名进行排序。
      
: print_r(array_filter($array1, "odd"));
***** date
	 date(Y年m月d日l星期/M英文月,而不是数字)
	 ((int)date('h')+8)时间,东八区要加8小时
	 h - 带有首位零的 12 小时小时格式
	 i - 带有首位零的分钟 (minute)
	 s - 带有首位零的秒（00 -59）(second)
	 a - 小写的午前和午后（am 或 pm）ante (before) meridiem post meridiem
	 cal_days_in_month()	针对指定的年份和历法，返回一个月中的天数。
	 cal_from_jd()	把儒略日计数转换为指定历法的日期。
	 cal_info()	返回有关指定历法的信息。
	 cal_to_jd()	把指定历法中的日期转换为儒略日计数。
	 easter_date()	返回指定年份的复活节午夜的 Unix 时间戳。
	 easter_days()	返回指定年份的复活节与 3 月 21 日之间的天数。
	 frenchtojd()	把法国共和历的日期转换成为儒略日计数。
	 gregoriantojd()	把格利高里历法的日期转换成为儒略日计数。
	 jddayofweek()	返回日期在周几。
	 jdmonthname()	返回月的名称。
	 jdtofrench()	把儒略日计数转换为法国共和历的日期。
	 jdtogregorian()	将格利高里历法转换成为儒略日计数。
	 jdtojewish()	把儒略日计数转换为犹太历法的日期。
	 jdtojulian()	把儒略日计数转换为儒略历法的日期。
	 jdtounix()	把儒略日计数转换为 Unix 时间戳。
	 jewishtojd()	把犹太历法的日期转换为儒略日计数。
	 juliantojd()	把儒略历法的日期转换为儒略日计数。
	 unixtojd()	把 Unix 时间戳转换为儒略日计数。

	 Date/Time 函数的行为受到 php.ini 中设置的影响：
	 date.timezone 	默认时区（所有的 Date/Time 函数使用该选项） 	
	 date.default_latitude 	默认纬度（date_sunrise() 和 date_sunset() 使用该选项）
	 date.default_longitude 	默认经度（date_sunrise() 和 date_sunset() 使用该选项）
	 date.sunrise_zenith 	默认日出天顶（date_sunrise() 和 date_sunset() 使用该选项）
	 date.sunset_zenith 	默认日落天顶（date_sunrise() 和 date_sunset() 使用该选项）
	 PHP 5 Date/Time 函数
	 函数 	描述
	 checkdate() 	验证格利高里日期。
	 date_add() 	添加日、月、年、时、分和秒到日期。
	 date_create_from_format() 	返回根据指定格式进行格式化的新的 DateTime 对象。
	 date_create() 	返回新的 DateTime 对象。
	 date_date_set() 	设置新日期。
	 date_default_timezone_get() 	返回由所有的 Date/Time 函数使用的默认时区。
	 date_default_timezone_set() 	设置由所有的 Date/Time 函数使用的默认时区。
	 date_diff() 	返回两个日期间的差值。
	 date_format() 	返回根据指定格式进行格式化的日期。
	 date_get_last_errors() 	返回日期字符串中的警告/错误。
	 date_interval_create_from_date_string() 	从字符串的相关部分建立 DateInterval。
	 date_interval_format() 	格式化时间间隔。
	 date_isodate_set() 	设置 ISO 日期。
	 date_modify() 	修改时间戳。
	 date_offset_get() 	返回时区偏移。
	 date_parse_from_format() 	根据指定的格式返回带有关于指定日期的详细信息的关联数组。
	 date_parse() 	返回带有关于指定日期的详细信息的关联数组。
	 date_sub() 	从指定日期减去日、月、年、时、分和秒。
	 date_sun_info() 	返回包含有关指定日期与地点的日出/日落和黄昏开始/黄昏结束的信息的数组。
	 date_sunrise() 	返回指定日期与位置的日出时间。
	 date_sunset() 	返回指定日期与位置的日落时间。
	 date_time_set() 	设置时间。
	 date_timestamp_get() 	返回 Unix 时间戳。
	 date_timestamp_set() 	设置基于 Unix 时间戳的日期和时间。
	 date_timezone_get() 	返回给定 DateTime 对象的时区。
	 date_timezone_set() 	设置 DateTime 对象的时区。
	 date() 	格式化本地日期和时间。
	 getdate() 	返回某个时间戳或者当前本地的日期/时间的日期/时间信息。
	 gettimeofday() 	返回当前时间。
	 gmdate() 	格式化 GMT/UTC 日期和时间。
	 gmmktime() 	返回 GMT 日期的 UNIX 时间戳。
	 gmstrftime() 	根据区域设置对 GMT/UTC 日期和时间进行格式化。
	 idate() 	将本地时间/日期格式化为整数。
	 localtime() 	返回本地时间。
	 microtime() 	返回当前时间的微秒数。
	 mktime() 	返回日期的 Unix 时间戳。
	 strftime() 	根据区域设置对本地时间/日期进行格式化。
	 strptime() 	解析由 strftime() 生成的时间/日期。
	 strtotime() 	将任何英文文本的日期或时间描述解析为 Unix 时间戳。
	 time() 	返回当前时间的 Unix 时间戳。
	 timezone_abbreviations_list() 	返回包含夏令时、偏移量和时区名称的关联数组。
	 timezone_identifiers_list() 	返回带有所有时区标识符的索引数组。
	 timezone_location_get() 	返回指定时区的位置信息。
	 timezone_name_from_abbr() 	根据时区缩略语返回时区名称。
	 timezone_name_get() 	返回时区的名称。
	 timezone_offset_get() 	返回相对于 GMT 的时区偏移。
	 timezone_open() 	创建新的 DateTimeZone 对象。
	 timezone_transitions_get() 	返回时区的所有转换。
	 timezone_version_get() 	返回时区数据库的版本。

***** file
	  fopen("filename",'w')  //可以指定绝对路径或相对路径
	  "r" 	只读方式打开，将文件指针指向文件头。
	  "r+" 	读写方式打开，将文件指针指向文件头。
	  "w" 	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	  "w+" 	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。
	  "a" 	写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	  "a+" 	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。
	  "x" 	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则报错.
	  basename() 	返回路径中的文件名部分。
	  chgrp() 	改变文件组。 	
	  chmod() 	改变文件模式。 
	  chown() 	改变文件所有者。 	
	  clearstatcache() 	清除文件状态缓存。 	
	  fopen() 可以通过http路径打开,可以在php.ini 中配置allow_url_fopen   //unix中要注意文件的访问权限
	  copy() 	复制文件。
	  fread(filepoint,length)	读取打开的文件。
	  fwrite(file,string,length)   
	  file_get_contents(filepath) 函数把整个文件读入一个字符串中。
	  file_put_contents(filepath,filecontent) 在ftp中要用到flags和context标志
	  basename()
	  is_readable()
	  fgets()
	  fgetss() 去掉文件中的html格式
	  readfile(filename) 输出到浏览器
	  file(file) 返回值是文件内容
	  fgetc()
	  file_exists()
	  filesize()
	  unlink() 删除文件
	  rewind()
	  fseek()
	  ftell()
	  delete() 	参见 unlink() 或 unset()。 	 
	  dirname() 	返回路径中的目录名称部分。 	
	  disk_free_space() 	返回目录的可用空间。 	
	  disk_total_space() 	返回一个目录的磁盘总容量。
	  diskfreespace() 	disk_free_space() 的别名。
	  fclose() 	关闭打开的文件。 	
	  feof() 	测试文件指针是否到了文件结束的位置。 	
	  fflush() 	向打开的文件输出缓冲内容。 
	  fgetc() 	从打开的文件中返回字符。 
	  fgetcsv() 	从打开的文件中解析一行，校验 CSV 字段。 	
	  fgets() 	从打开的文件中返回一行。 	
	  fgetss() 	从打开的文件中读取一行并过滤掉 HTML 和 PHP 标记。 	  file() 	把文件读入一个数组中。 	
	  file_exists() 	检查文件或目录是否存在。
	  file_get_contents() 	将文件读入字符串。 	
	  file_put_contents() 	将字符串写入文件。 	
	  fileatime() 	返回文件的上次访问时间。 	
	  filectime() 	返回文件的上次改变时间。 	
	  filegroup() 	返回文件的组 ID。 	
	  fileinode() 	返回文件的 inode 编号。 
	  filemtime() 	返回文件的上次修改时间。
	  fileowner() 	文件的 user ID （所有者）。
	  fileperms() 	返回文件的权限。 	
	  filesize() 	返回文件大小。 	
	  filetype() 	返回文件类型。 	
	  flock() 	锁定或释放文件。
	  fnmatch() 	根据指定的模式来匹配文件名或字符串。 	
	  fopen() 	打开一个文件或 URL。 	
	  fpassthru() 	从打开的文件中读数据，直到 EOF，并向输出缓冲写结果
	  fputcsv() 	将行格式化为 CSV 并写入一个打开的文件中。 	
	  fputs() 	fwrite() 的别名。 	
	  fread() 	读取打开的文件。 	
	  fscanf() 	根据指定的格式对输入进行解析。
	  fseek() 	在打开的文件中定位。 	
	  fstat() 	返回关于一个打开的文件的信息。
	  ftell() 	返回文件指针的读/写位置 
	  ftruncate() 	将文件截断到指定的长度。
	  fwrite() 	写入文件。 	
	  glob() 	返回一个包含匹配指定模式的文件名/目录的数组。 	
	  is_dir() 	判断指定的文件名是否是一个目录。 	
	  is_executable() 	判断文件是否可执行。 	
	  is_file() 	判断指定文件是否为常规的文件。 	
	  is_link() 	判断指定的文件是否是连接。 	
	  is_readable() 	判断文件是否可读。 	
	  is_uploaded_file() 	判断文件是否是通过 HTTP POST 上传的。 	
	  is_writable() 	判断文件是否可写。 	
	  is_writeable() 	is_writable() 的别名。 	
	  link() 	创建一个硬连接。 	
	  linkinfo() 	返回有关一个硬连接的信息。 	
	  lstat() 	返回关于文件或符号连接的信息。 	
	  mkdir() 	创建目录。 	
	  move_uploaded_file() 	将上传的文件移动到新位置。 	
	  parse_ini_file() 	解析一个配置文件。 	
	  pathinfo() 	返回关于文件路径的信息。 	
	  pclose() 	关闭有 popen() 打开的进程。 	
	  popen() 	打开一个进程。 	
	  readfile() 	读取一个文件，并输出到输出缓冲。 	
	  readlink() 	返回符号连接的目标。 	
	  realpath() 	返回绝对路径名。 	
	  rename() 	重名名文件或目录。 	
	  rewind() 	倒回文件指针的位置。 	
	  rmdir() 	删除空的目录。 	
	  set_file_buffer() 	设置已打开文件的缓冲大小。 	
	  stat() 	返回关于文件的信息。 	
	  symlink() 	创建符号连接。 	
	  tempnam() 	创建唯一的临时文件。
	  tmpfile() 	建立临时文件。 	
	  touch() 	设置文件的访问和修改时间。 	
	  umask() 	改变文件的文件权限。 	
	  unlink() 	删除文件。

	  isset(varname)判断变量是否已经配置，就是变量存不存在值
	  unset(varname)取消配置；
	  empty(varname) 对于值是0的数返回true，这里要当心

***** Directory 函数
	 chdir()	改变当前的目录。
	 chroot()	改变根目录。
	 closedir()	关闭目录句柄。
	 dir()	返回 Directory 类的实例。
	 getcwd()	返回当前工作目录。
	 opendir()	打开目录句柄。
	 readdir()	返回目录句柄中的条目。
	 rewinddir()	重置目录句柄。
	 scandir()	返回指定目录中的文件和目录的数组。

***** PHP 过滤器用于对来自非安全来源的数据（比如用户输入）进行验证和过滤。
	  filter_has_var() 	检查是否存在指定输入类型的变量。 	5
	  filter_id() 	返回指定过滤器的 ID 号。 	5
	  filter_input() 	从脚本外部获取输入，并进行过滤。 	5
	  filter_input_array() 	从脚本外部获取多项输入，并进行过滤。 	5
	  filter_list() 	返回包含所有得到支持的过滤器的一个数组。 	5
	  filter_var_array() 	获取多项变量，并进行过滤。 	5
	  filter_var() 	获取一个变量，并进行过滤。
***** HTTP 函数允许您在其他输出被发送之前，对由 Web 服务器发送到浏览器的信息进行操作。
	  header() 	向客户端发送原始的 HTTP 报头。
	  headers_list() 	返回已发送的（或待发送的）响应头部的一个列表。
	  headers_sent() 	检查 HTTP 报头是否发送/已发送到何处。
	  setcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie。
	  setrawcookie() 	定义与 HTTP 报头的其余部分一共发送的 cookie（不进行 URL 编码）。

***** 数学 (Math) 函数能处理 integer 和 float 范围内的值。
	  abs() 	绝对值。 	3
	  acos() 	反余弦。 	3
	  acosh() 	反双曲余弦。 	4
	  asin() 	反正弦。 	3
	  asinh() 	反双曲正弦。 	4
	  atan() 	反正切。 	3
	  atan2() 	两个参数的反正切。 	3
	  atanh() 	反双曲正切。 	4
	  base_convert() 	在任意进制之间转换数字。 	3
	  bindec() 	把二进制转换为十进制。 	3
	  ceil() 	向上舍入为最接近的整数。 	3
	  cos() 	余弦。 	3
	  cosh() 	双曲余弦。 	4
	  decbin() 	把十进制转换为二进制。 	3
	  dechex() 	把十进制转换为十六进制。 	3
	  decoct() 	把十进制转换为八进制。 	3
	  deg2rad() 	将角度转换为弧度。 	3
	  exp() 	返回 Ex 的值。 	3
	  expm1() 	返回 Ex - 1 的值。 	4
	  floor() 	向下舍入为最接近的整数。 	3
	  fmod() 	返回除法的浮点数余数。 	4
	  getrandmax() 	显示随机数最大的可能值。 	3
	  hexdec() 	把十六进制转换为十进制。 	3
	  hypot() 	计算直角三角形的斜边长度。 	4
	  is_finite() 	判断是否为有限值。 	4
	  is_infinite() 	判断是否为无限值。 	4
	  is_nan() 	判断是否为合法数值。 	4
	  lcg_value() 	返回范围为 (0, 1) 的一个伪随机数。 	4
	  log() 	自然对数。 	3
	  log10() 	以 10 为底的对数。 	3
	  log1p() 	返回 log(1 + number)。 	4
	  max() 	返回最大值。 	3
	  min() 	返回最小值。 	3
	  mt_getrandmax() 	显示随机数的最大可能值。 	3
	  mt_rand() 	使用 Mersenne Twister 算法返回随机整数。 	3
	  mt_srand() 	播种 Mersenne Twister 随机数生成器。 	3
	  octdec() 	把八进制转换为十进制。 	3
	  pi() 	返回圆周率的值。 	3
	  pow() 	返回 x 的 y 次方。 	3
	  rad2deg() 	把弧度数转换为角度数。 	3
	  rand() 	返回随机整数。 	3
	  round() 	对浮点数进行四舍五入。 	3
	  sin() 	正弦。 	3
	  sinh() 	双曲正弦。 	4
	  sqrt() 	平方根。 	3
	  srand() 	播下随机数发生器种子。 	3
	  tan() 	正切。 	3
	  tanh() 	双曲正切。

***** string	
      mb_substr(strip_tags( $list["content"]),0,20) 截取字符串 对中文的支持
      ucfirst(string)->string第一个字大写
      addcslashes — 以 C 语言风格使用反斜线转义字符串中的字符
      addslashes — 使用反斜线引用字符串
      bin2hex — 函数把包含数据的二进制字符串转换为十六进制值
      chop — rtrim 的别名
      chr — 返回指定的字符
      chunk_split — 将字符串分割成小块
      convert_cyr_string — 将字符由一种 Cyrillic 字符转换成另一种
      convert_uudecode — 解码一个 uuencode 编码的字符串
      convert_uuencode — 使用 uuencode 编码一个字符串
      count_chars — 返回字符串所用字符的信息
      crc32 — 计算一个字符串的 crc32 多项式
      crypt — 单向字符串散列
******    explode — 使用一个字符串分割另一个字符串
: array explode ( string $delimiter , string $string [, int $limit ] )
    fprintf — 将格式化后的字符串写入到流
    get_html_translation_table — 返回使用 htmlspecialchars 和 htmlentities 后的转换表
    hebrev — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）
    hebrevc — 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符
    hex2bin — 转换十六进制字符串为二进制字符串
    html_entity_decode — Convert all HTML entities to their applicable characters
    htmlentities — Convert all applicable characters to HTML entities
    htmlspecialchars_decode — 将特殊的 HTML 实体转换回普通字符
    htmlspecialchars — Convert special characters to HTML entities
    implode — 将一个一维数组的值转化为字符串
    join — 别名 implode
    lcfirst — 使一个字符串的第一个字符小写
    levenshtein — 计算两个字符串之间的编辑距离
    localeconv — Get numeric formatting information
    ltrim — 删除字符串开头的空白字符（或其他字符）
    md5_file — 计算指定文件的 MD5 散列值
    md5 — 计算字符串的 MD5 散列值
    metaphone — Calculate the metaphone key of a string
    money_format — 将数字格式化成货币字符串
    nl_langinfo — Query language and locale information
    nl2br — 在字符串所有新行之前插入 HTML 换行标记
    number_format — 以千位分隔符方式格式化一个数字
    ord — 返回字符的 ASCII 码值
    parse_str — 将字符串解析成多个变量
    print — 输出字符串;    实际不是函数,没参数
    printf — 输出格式化字符串
    quoted_printable_decode — 将 quoted-printable 字符串转换为 8-bit 字符串
    quoted_printable_encode — 将 8-bit 字符串转换成 quoted-printable 字符串
    quotemeta — 转义元字符集
    rtrim — 删除字符串末端的空白字符（或者其他字符）
    setlocale — 设置地区信息
    sha1_file — 计算文件的 sha1 散列值
    sha1 — 计算字符串的 sha1 散列值
    similar_text — 计算两个字符串的相似度
    soundex — Calculate the soundex key of a string
    sprintf — Return a formatted string
    sscanf — 根据指定格式解析输入的字符
    str_getcsv — 解析 CSV 字符串为一个数组
    str_ireplace — str_replace 的忽略大小写版本
    str_pad — 使用另一个字符串填充字符串为指定长度
    str_repeat — 重复一个字符串
    str_replace — 子字符串替换
    str_rot13 — 对字符串执行 ROT13 转换
    str_shuffle — 随机打乱一个字符串
    str_split — 将字符串转换为数组
    str_word_count — 返回字符串中单词的使用情况
    strcasecmp — 二进制安全比较字符串（不区分大小写）
    strchr — 别名 strstr
    strcmp — 二进制安全字符串比较
    strcoll — 基于区域设置的字符串比较
    strcspn — 获取不匹配遮罩的起始子字符串的长度
    strip_tags — 从字符串中去除 HTML 和 PHP 标记
    stripcslashes — 反引用一个使用 addcslashes 转义的字符串
    stripos — 查找字符串首次出现的位置（不区分大小写）
    stripslashes — 反引用一个引用字符串
    stristr — strstr 函数的忽略大小写版本
    strlen — 获取字符串长度
    strnatcasecmp — 使用“自然顺序”算法比较字符串（不区分大小写）
    strnatcmp — 使用自然排序算法比较字符串
    strncasecmp — 二进制安全比较字符串开头的若干个字符（不区分大小写）
    strncmp — 二进制安全比较字符串开头的若干个字符
    strpbrk — 在字符串中查找一组字符的任何一个字符
    strpos — 查找字符串首次出现的位置
    strrchr — 查找指定字符在字符串中的最后一次出现
    strrev — 反转字符串
    strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）
    strrpos — 计算指定字符串在目标字符串中最后一次出现的位置
    strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。
    strstr — 查找字符串的首次出现
    strtok — 标记分割字符串
    strtolower — 将字符串转化为小写
    strtoupper — 将字符串转化为大写
    strtr — 转换指定字符
    substr_compare — 二进制安全比较字符串（从偏移位置比较指定长度）
    substr_count — 计算字串出现的次数
    substr_replace — 替换字符串的子串
    substr — 返回字符串的子串
    trim — 去除字符串首尾处的空白字符（或者其他字符）
    ucfirst — 将字符串的首字母转换为大写
    ucwords — 将字符串中每个单词的首字母转换为大写
    vfprintf — 将格式化字符串写入流
    vprintf — 输出格式化字符串
    vsprintf — 返回格式化字符串
    wordwrap — 打断字符串为指定数量的字串

***** 网络 函数
      checkdnsrr — 给指定的主机（域名）或者IP地址做DNS通信检查
      closelog — 关闭系统日志链接
      define_syslog_variables — Initializes all syslog related variables
      dns_check_record — 别名 checkdnsrr
      dns_get_mx — 别名 getmxrr
      dns_get_record — 获取指定主机的DNS记录
      fsockopen — 打开一个网络连接或者一个Unix套接字连接
      gethostbyaddr — 获取指定的IP地址对应的主机名  //这个只能查到本机的主机名,可能跟域名反向解析有关,不能反向解析,只能解析host文件里面的
      gethostbyname — Get the IPv4 address corresponding to a given Internet host name
      gethostbynamel — Get a list of IPv4 addresses corresponding to a given Internet host name
      gethostname — Gets the host name
      getmxrr — Get MX records corresponding to a given Internet host name
      getprotobyname — Get protocol number associated with protocol name
      getprotobynumber — Get protocol name associated with protocol number
      getservbyname — Get port number associated with an Internet service and protocol
      getservbyport — Get Internet service which corresponds to port and protocol
      header_register_callback — Call a header function
      header_remove — Remove previously set headers
      header — 发送原生 HTTP 头
      headers_list — Returns a list of response headers sent (or ready to send)
      headers_sent — Checks if or where headers have been sent
      http_response_code — Get or Set the HTTP response code
      inet_ntop — Converts a packed internet address to a human readable representation
      inet_pton — Converts a human readable IP address to its packed in_addr representation
      ip2long — 将一个IPV4的字符串互联网协议转换成数字格式
      long2ip — Converts an long integer address into a string in (IPv4) Internet standard dotted format
      openlog — Open connection to system logger
      pfsockopen — 打开一个持久的网络连接或者Unix套接字连接。
      setcookie — Send a cookie
      setrawcookie — Send a cookie without urlencoding the cookie value
      socket_get_status — 别名 stream_get_meta_data
      socket_set_blocking — 别名 stream_set_blocking
      socket_set_timeout — 别名 stream_set_timeout
      syslog — Generate a system log message

***** pthreads
		  Threaded — Threaded 类
          Threaded::chunk — 操作
          Threaded::count — Manipulation
          Threaded::extend — Runtime Manipulation
          Threaded::from — Creation
          Threaded::getTerminationInfo — Error Detection
          Threaded::isRunning — State Detection
          Threaded::isTerminated — State Detection
          Threaded::isWaiting — State Detection
          Threaded::lock — Synchronization
          Threaded::merge — Manipulation
          Threaded::notify — Synchronization
          Threaded::pop — Manipulation
          Threaded::run — Execution
          Threaded::shift — Manipulation
          Threaded::synchronized — Synchronization
          Threaded::unlock — Synchronization
          Threaded::wait — Synchronization
		  Thread — Thread 类
          Thread::detach — 执行
          Thread::getCreatorId — 识别
          Thread::getCurrentThread — 识别
          Thread::getCurrentThreadId — 识别
          Thread::getThreadId — 识别
          Thread::globally — 执行
          Thread::isJoined — 状态监测
          Thread::isStarted — 状态检测
          Thread::join — 同步
          Thread::kill — 执行
          Thread::start — 执行
***** Worker — Worker 类
          Worker::getStacked — 栈分析
          Worker::isShutdown — 状态检测
          Worker::isWorking — 状态检测
          Worker::shutdown — 同步
          Worker::stack — 栈操作
          Worker::unstack — 栈操作
	  Collectable — The Collectable class
          Collectable::isGarbage — Determine whether an object has been marked as garbage
          Collectable::setGarbage — Mark an object as garbage
      Modifiers — 方法修饰符
***** Pool — Pool 类
          Pool::collect — 回收已完成任务的引用
          Pool::__construct — 创建新的 Worker 对象池
          Pool::resize — 改变 Pool 对象的可容纳 Worker 对象的数量
          Pool::shutdown — 停止所有的 Worker 对象
          Pool::submit — 提交对象以执行
          Pool::submitTo — 提交对象以执行
***** Mutex — Mutex 类
          Mutex::create — 创建一个互斥量
          Mutex::destroy — 销毁互斥量
          Mutex::lock — 给互斥量加锁
          Mutex::trylock — 尝试给互斥量加锁
          Mutex::unlock — 释放互斥量上的锁
***** Cond — Cond 类
          Cond::broadcast — 广播条件变量
          Cond::create — 创建一个条件变量
          Cond::destroy — 销毁条件变量
          Cond::signal — 发送唤醒信号
          Cond::wait — 等待
		  
***** PCRE 函数 Perl Compatible Regular Expressions 兼容正则
******    preg_filter — 执行一个正则表达式搜索和替换
******    preg_grep — 返回匹配模式的数组条目
******    preg_last_error — 返回最后一个PCRE正则执行产生的错误代码
******    preg_match_all — 执行一个全局正则表达式匹配
******    preg_match — 执行一个正则表达式匹配
******    preg_quote — 转义正则表达式字符
******    preg_replace_callback_array — Perform a regular expression search and replace using callbacks
******    preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换
******    preg_replace — 执行一个正则表达式的搜索和替换
: mixed preg_replace( mixed pattern, mixed replacement, mixed subject [, int limit ] )
: $str = preg_replace('/\s/','-',$str);  这里要注意,匹配模式要加载/ /中间
pattern 	正则表达式
replacement 	替换的内容
subject 	需要匹配替换的对象
limit 	可选，指定替换的个数，如果省略 limit 或者其值为 -1，则所有的匹配项都会被替换

    replacement 可以包含 \\n 形式或 $n 形式的逆向引用，首选使用后者。每个此种引用将被替换为与第 n 个被捕获的括号内的子模式所匹配的文本。n 可以从 0 到 99，其中 \\0 或 $0 指的是被整个模式所匹配的文本。对左圆括号从左到右计数（从 1 开始）以取得子模式的数目。
    对替换模式在一个逆向引用后面紧接着一个数字时（如 \\11），不能使用 \\ 符号来表示逆向引用。因为这样将会使 preg_replace() 搞不清楚是想要一个 \\1 的逆向引用后面跟着一个数字 1 还是一个 \\11 的逆向引用。解决方法是使用 \${1}1。这会形成一个隔离的 $1 逆向引用，而使另一个 1 只是单纯的文字。
    上述参数除 limit 外都可以是一个数组。如果 pattern 和 replacement 都是数组，将以其键名在数组中出现的顺序来进行处理，这不一定和索引的数字顺序相同。如果使用索引来标识哪个 pattern 将被哪个 replacement 来替换，应该在调用 preg_replace() 之前用 ksort() 函数对数组进行排序。

    int preg_match ( string pattern, string subject [, array matches [, int flags]])
  在 subject 字符串中搜索与 pattern 给出的正则表达式相匹配的内容。
 如果提供了 matches，则其会被搜索的结果所填充。$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推    
模式修正符 	说明
i 	模式中的字符将同时匹配大小写字母
m 	字符串视为多行
s 	将字符串视为单行，换行符作为普通字符
x 	将模式中的空白忽略
e 	preg_replace() 函数在替换字符串中对逆向引用作正常的替换，将其作为 PHP 代码求值，并用其结果来替换所搜索的字符串。
A 	强制仅从目标字符串的开头开始匹配
D 	模式中的 $ 元字符仅匹配目标字符串的结尾
U 	匹配最近的字符串
u 	模式字符串被当成 UTF-8 

******    preg_split — 通过一个正则表达式分隔字符串		
***** JSON 函数 
json_decode — 对 JSON 格式的字符串进行解码
json_encode — 对变量进行 JSON 编码
json_last_error_msg — Returns the error string of the last json_encode() or json_decode() call
json_last_error — 返回最后发生的错误

***** Socket 函数

      socket_accept — Accepts a connection on a socket
      socket_bind — 给套接字绑定名字
      socket_clear_error — 清除套接字或者最后的错误代码上的错误
      socket_close — 关闭套接字资源
      socket_cmsg_space — Calculate message buffer size
      socket_connect — 开启一个套接字连接
      socket_create_listen — Opens a socket on port to accept connections
      socket_create_pair — Creates a pair of indistinguishable sockets and stores them in an array
      socket_create — 创建一个套接字（通讯节点）
      socket_get_option — Gets socket options for the socket
      socket_getopt — 别名 socket_get_option
      socket_getpeername — Queries the remote side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
      socket_getsockname — Queries the local side of the given socket which may either result in host/port or in a Unix filesystem path, dependent on its type
      socket_import_stream — Import a stream
      socket_last_error — Returns the last error on the socket
      socket_listen — Listens for a connection on a socket
      socket_read — Reads a maximum of length bytes from a socket
      socket_recv — 从已连接的socket接收数据
      socket_recvfrom — Receives data from a socket whether or not it is connection-oriented
      socket_recvmsg — Read a message
      socket_select — Runs the select() system call on the given arrays of sockets with a specified timeout
      socket_send — Sends data to a connected socket
      socket_sendmsg — Send a message
      socket_sendto — Sends a message to a socket, whether it is connected or not
      socket_set_block — Sets blocking mode on a socket resource
      socket_set_nonblock — Sets nonblocking mode for file descriptor fd
      socket_set_option — Sets socket options for the socket
      socket_setopt — 别名 socket_set_option
      socket_shutdown — Shuts down a socket for receiving, sending, or both
      socket_strerror — Return a string describing a socket error
      socket_write — Write to a socket
** 执行运算符
`` 等效于 shell_exec()
** 类与对象
构造函数
__construct()
parent::__construct();
析构函数
__destruct()
*** 类的属性
: __set()和__get()只对私有属性起作用，对于用public定义的属性，它们两个都懒理搭理
*** 类的常量 const 
: 调用 $this::PI / 类名::PI (双冒号)  注意写法,要不只是创建新的属性
*** 静态成员 供所有类的实例共享的字段或方法
**** 调用
类的外部，“类名::$成员名”
类的内部, “self::$成员名”
**** 修改
对于用public定义的静态成员，可以在外部更改它的值。private等则不行。
*** 调用
（一）this关键字：用于类的内部指代类的本身。来访问属性或方法或常量，如$this->属性名或方法名。$this::常量名。this还可以用在该类的子类中，来指代本身的属性或方法。
（二）双冒号“::”关键字：用于调用常量、静态成员。
（三）self关键字:在类的内部与双冒号配合调用静态成员，如 self::$staticVar.，在类的内部，不能用$this来调用静态成员。
以后统一在调用方法或属性时用 “-> “,调用常量则用双冒号“::”，不会搞晕。
*** 成员访问属性
public(默认，可省略，也等同于php6的var声明),private（私有，也不能由子类使用），protected(私有，但可由子类使用) ，abstract(抽象，参下文)，final(阻止在子类中覆盖—也称重载，阻止被继承，用于修饰类名及方法，如final class test{ final function fun(){}} ，但不能用于属性),static(静态)
**** 抽象类和抽象方法（abstract——注意：没有所谓抽象属性）:
抽象可以理解成父类为子类定义了一个模板或基类。作用域abstract只在父类中声明，但在子类中实现。注意事项：
1、抽象类不能被实例化，只能被子类（具体类）继承后实现。
2、抽象类必须在其子类中实现该抽象类的所有抽象方法。否则会出错。
3、在抽象方法中，只是声明，但不能具体实现：如abstract function gettow(){ return $this->p; }是错的，只能声明这个方法：abstract function gettow();（连方括号{}都不要出现）,抽象方法和抽象类主要用于复杂的类层次关系中。该层次关系需要确保每一个子类都包含并重载了某些特定的方法。这也可以通过接口实现
4、属性不能被命名为抽象属性，如abstract $p = 5是错的。
5、只有声明为抽象的类可以声明抽象方法，但如果方法声明为抽象，就不能具体实现。
*** 类的管理
**** instanceof 用于分析一个对象是否是某一个类的实例或子类或是实现了某个特定的接口：但要注意： 类名没有任何引号等定界符，否则会出错。如test不能用'test'
**** 确定类是否存在：boolean class_exists(string class_name): class_exists(‘test');
**** 返回类名：string get_class(object)，成功时返回实例的类名，失败则返回FALSE：
**** 了解类的公用属性：array get_class_vars(‘className') ,返回关键数组：包含所有定义的public属性名及其相应的值。这个函数不能用实例名做变量
**** 返回类方法：get_class_methods(‘test'); //或： get_class_methods($a);可用实例名做参数，返回包括构造函数在内的所有非私有方法。
**** print_r(get_declared_classes())了解当前PHP版本中所有的类名。PHP5有149个。
**** get_object_vars($a)返回实例中所有公用的属性及其值的关联数组。注意它和get_class_vars()的区别：
/* (1) get_object_vars($a)是用实例名做参数，而get_class_vars(‘test')是用类名做参数。
 get_object_vars($a)获得的属性值是实例运行后的值，而get_class_vars(‘test')获得的属性值是类中的初始定义。
 两者均返回关联数组，且均对未赋值的属性返回NULL的值。如类test中有定义了public $q;则返回Array ( [v] => 5 [q]=>) ,
**** 返回父类的名称：get_parent_class($b);//或get_parent_class(‘test2′); 返回test
**** 确定接口是否存在：boolean interface_exists($string interface[,boolean autoload])
**** 确定对象类型： boolean is_a($obj,'className')，当$obj属于CLASSNAME类时，或属于其子类时，返回TRUE，如果$obj与class类型无关则返回FALSE。如：is_a($a,'test')
**** 确定是否是某类的子对象：当$b是继承自TEST类时，返回TRUE，否则FALSE。boolean is_subclass_of($b,'test');
**** 确定类或实例中，是否存在某方法。method_exists($a,'getv') //或用method_exists(‘test','getv')，此函数适用于非public定义的作用域的方法。
*** 对象克隆：
*** 在子类中调用父类的属性或方法：
1、调用父类方法：在子类中调用父类的方法，有3种方法：
$this->ParentFunction(); 或
父类名::ParentFunction(); 或
parent::parentFun();

2、调用父类属性：只能用$this->ParentProperty;
*** 接口
接口：interface，可以理解成一组功能的共同规范，最大意义可能就是在多人协作时，为各自的开发规定一个共同的方法名称。
** 发展规范
*** PHP 包含文件
: require 引入或者包含外部php文件
: include     
*** 命名空间 namespace XXX\yyy ;调用 1.include/require 2.XXX\yyy\classname as classnamealias
use XXX\yyy;
*** Errors
**** 错误显示
     ini_set("display_errors", "On");   
     error_reporting(E_ALL); //-1是关闭
     更改了Php.ini后要重启IIS,点击 “开始”->“运行”，输入iisreset 回车。
**** Error 和 Logging 函数
	 debug_backtrace() 	生成 backtrace。
	 debug_print_backtrace() 	打印 backtrace。
	 error_get_last() 	返回最后发生的错误。
	 error_log() 	向服务器错误记录、文件或远程目标发送错误消息。
	 error_reporting() 	规定报告哪个错误。
	 restore_error_handler() 	恢复之前的错误处理程序。
	 restore_exception_handler() 	恢复之前的异常处理程序。
	 set_error_handler() 	设置用户自定义的错误处理函数。
	 set_exception_handler() 	设置用户自定义的异常处理函数。
	 trigger_error() 	创建用户级别的错误消息。
	 user_error() 	trigger_error() 的别名。
	 PHP Filesystem 函数

*** 异常处理
try{
throw new Exception("wrong");
}catch(Exception $e){
$e->getMessage();
getCode
getLine
}
*** 引用的解释
*** 预定义变量
*** 预定义异常
*** 预定义接口
*** 上下文（Context）选项和参数
*** 支持的协议和封装协议
* php 扩展
** zip
 Windows 用户需要在 php.ini 里使 php_zip.dll 可用，以便使用这些函数。
Linux 系统 ¶
为了使用这些函数，必须在编译 PHP 时用 --enable-zip 配置选项来提供 zip 支持。
** PECL php扩展仓库
下载: pecl install extname
这里可以指定版本   extname-0.1
或者svn: $ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
然后在php.ini 中激活扩展
php-config  php配置信息
* thinkphp
** composer
* CI php框架(报刊/杂志)
** 应用程序流程图
***    index.php 文件作为前端控制器，初始化运行 CodeIgniter 所需的基本资源；
: index.php 是唯一入口,因为其他文件开头都有
: defined('BASEPATH') OR exit('No direct script access allowed');
***    Router 检查 HTTP 请求，以确定如何处理该请求；
***    如果存在缓存文件，将直接输出到浏览器，不用走下面正常的系统流程；
***    在加载应用程序控制器之前，对 HTTP 请求以及任何用户提交的数据进行安全检查；
***    控制器加载模型、核心类库、辅助函数以及其他所有处理请求所需的资源；
***    最后一步，渲染视图并发送至浏览器，如果开启了缓存，视图被会先缓存起来用于 后续的请求。
** 模型-视图-控制器  //用户请求一个资源  (数据库中存放资源/找到资源并构图/返回资源给用户)
** 判断请求(生成资源/存储资源)通过浏览器返回给他页面
** 安装(设备安装一下)
1:  解压缩安装包；
2:  将 CodeIgniter 文件夹及里面的文件上传到服务器，通常 index.php 文件将位于网站的根目录；
3:  使用文本编辑器打开 application/config/config.php 文件设置你网站的根 URL，如果你想使用加密或会话，在这里设置上你的加密密钥；
4:  如果你打算使用数据库，打开 application/config/database.php 文件设置数据库参数。
** 请求流程
*** 1.弄到URL http://example.com/news/latest/10
*** 2.分析,路由  routes.php //路由的作用是分析成类和方法调用,路由条目中没有,就不分析了
    $route['default_controller']='pages/view'; 控制器路径
    $route['(:any)'] = 'pages/view/$1';  通配规则
*** 3.制造控制器 News
#+BEGIN_SRC php
class News extends CI_Controller{
}    
#+END_SRC
*** 4.制造数据模型 News_model
****    1.创建数据库表
#+BEGIN_SRC sql
CREATE TABLE news (
    id int(11) NOT NULL AUTO_INCREMENT,
    title varchar(128) NOT NULL,
    slug varchar(128) NOT NULL,
    text text NOT NULL,
    PRIMARY KEY (id),
    KEY slug (slug)
);
#+END_SRC
****    2.在application/models/目录
#+BEGIN_SRC php
class News_model extends CI_Model{

public function __construct()
{
$this->load->database();
}

public function get_news($slug=FALSE)
{
if ($slug===FALSE)
{
$query=$this->db->get('news');
return $query->result_array();
}
$query=$this->db->get_where('news',array('slug'=>$slug));
return $query->row_array();
}
}
#+END_SRC
*** 5.控制器中使用model
#+BEGIN_SRC php
class News externs CI_controller{
public function __construct(){
parent::__construct();
$this->load->model('news_model');
$this->load->helper('url_help');
}
public function index()
{
$data['news']=$this->news_model->get_news();
}
public function view($slug){
$data['news_item']=$this->news_model->get_news($slug);
}
}
#+END_SRC
*** 6.控制器中把数据传递给视图
#+BEGIN_SRC php
public function index(){
: $data['news']=$this->news_model->get_news();
$data['title']="Hello,world";

$this->load->view('templates/header',$data);
$this->load->view('news/index',$data);
$this->load->view('templates/footer');   此视图不传数据
}
#+END_SRC
*** 7.视图中调用数据 application/views/news/index.php ;这里就是前台啦
#+BEGIN_SRC php
<h2><?php echo $title; ?></h2>
<?php foreach($news as $new_item):?>
<h3><?php echo $news_item['title']; ?></h3>
<div class="main">
<?php echo $new_item['text']; ?>
</div>
<?php endforch; ?>
#+END_SRC
*** 8.修改路由
#+BEGIN_SRC php
$route['news/(:any)'] = 'news/view/$1';
$route['news'] = 'news';
#+END_SRC
** 创建数据 
*** 1.表单或jquery
*** 2.控制器验证并插入数据
#+BEGIN_SRC php
class News extends CI_Controller{
public function create()
{
if(INPUT==RIGHT)
{
$this->news_model->set_news();
$this->load->view('news/success');    创建成功返回页面
}
}
}
#+END_SRC
*** 3.插入数据的模块
#+BEGIN_SRC php
public function set_news()
{
$data=array(
'title'=>$this->input->post('title'),
'slug'=>$slug,
'text'=>$this->input->post('text')
);
return $this->db->insert('news',$data);
}
#+END_SRC
** 常规主题
*** CodeIgniter URL
**** (默认) URI分段方式 : example.com/class/function/ID
**** 查询字符串格式 : index.php?c=controller&m=method
*** 配置文件 config/config.php
**** 后缀 .html
**** 启用查询字符串格式
#+BEGIN_SRC php
$config['enable_query_strings'] = FALSE;
$config['controller_trigger'] = 'c';
$config['function_trigger'] = 'm';
#+END_SRC
**** 管理应用程序目录 $application_folder = 'application';
*** 控制器
**** 默认控制器 当 URI 没有分段参数时加载
#+BEGIN_SRC php
$route['default_controller'] = 'blog';
#+END_SRC
**** _remap
: 如果你的控制包含一个 _remap() 方法，那么无论 URI 中包含什么参数时都会调用该方法
**** 处理输出 
: 如果你的控制器含有一个 _output() 方法，输出类将会调用该方法来显示数据， 而不是直接显示数据。该方法的第一个参数包含了最终输出的数据。
#+BEGIN_SRC php
public function _output($output)
{
    echo $output;
}
#+END_SRC
**** 私有方法
只要简单的将方法声明为 private 或 protected 或 _methodname [名字前加下划线]
*** 视图
**** 加载视图$this->load->view('view_name');
**** 将视图作为数据返回
: 如果你将该参数设置为 TRUE ， 该方法返回字符串，默认情况下为 FALSE ，视图将显示到浏览器。
: $string = $this->load->view('myfile', '', TRUE);
*** 模型  
模型是专门用来和数据库打交道的 PHP 类
**** 加载模型 $this->load->model('model_name');
*** 辅助函数
**** 加载辅助函数 $this->load->helper('url');
*** 类库 位于 /system/libraries
**** 加载类库$this->load->library('class_name');
*** 网页缓存
**** 开始缓存$this->output->cache($n);
**** 删除缓存
#+BEGIN_SRC php
// Deletes cache for the currently requested URI
$this->output->delete_cache();
// Deletes cache for /foo/bar
$this->output->delete_cache('/foo/bar');
#+END_SRC
*** 以 CLI 方式运行
: $ php index.php tools message 重新路由了,单一入口
*** 处理环境
: ENVIRONMENT 常量
: define('ENVIRONMENT', isset($_SERVER['CI_ENV']) ? $_SERVER['CI_ENV'] : 'development');
*** URI安全
: CodeIgniter 严格限制 URI 中允许出现的字符，以此来减少恶意数据传到你的应用程序的可能性。
* 对象
*** window 对象 代表一个浏览器窗口或一个框架(当前对象[全局对象]),
**** 属性
closed 	返回窗口是否已被关闭
defaultStatus 	设置或返回窗口状态栏中的默认文本
document 	对 Document 对象的只读引用。
history 	对 History 对象的只读引用。
innerheight 	返回窗口的文档显示区的高度。
innerwidth 	返回窗口的文档显示区的宽度。
length 	设置或返回窗口中的框架数量。
location 	用于窗口或框架的 Location 对象。请参阅 Location 对象。 
name 	            设置或返回窗口的名称。
Navigator 	对 Navigator 对象的只读引用。请参数 Navigator 对象。
opener 	返回对创建此窗口的窗口的引用。 	
outerheight 	返回窗口的外部高度。 
outerwidth 	返回窗口的外部宽度。 
pageXOffset 	设置或返回当前页面相对于窗口显示区左上角的 X 位置。
pageYOffset 	设置或返回当前页面相对于窗口显示区左上角的 Y 位置。
parent 	返回父窗口。 	
Screen 	对 Screen 对象的只读引用。请参数 Screen 对象。
self 	            返回对当前窗口的引用。等价于 Window 属性。 	
status 	            设置窗口状态栏的文本。
top 	            返回最顶层的先辈窗口。
window 	window 属性等价于 self 属性，它包含了对窗口自身的引用。
screenLeft        IE、Safari 和 Opera 支持 screenLeft 和 screenTop
screenTop
screenX             Firefox 和 Safari 支持 screenX 和 screenY。   
screenY             只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。

**** 方法
alert() 	           显示带有一段消息和一个确认按钮的警告框。
blur() 	           把键盘焦点从顶层窗口移开。
clearInterval() 	取消由 setInterval() 设置的 timeout。 
clearTimeout() 取消由 setTimeout() 方法设置的 timeout。
close() 	关闭浏览器窗口。 
confirm() 	显示带有一段消息以及确认按钮和取消按钮的对话框。
createPopup() 	创建一个 pop-up 窗口
focus() 	把键盘焦点给予一个窗口
moveBy() 	可相对窗口的当前坐标把它移动指定的像素
moveTo() 	把窗口的左上角移动到一个指定的坐标。
open() 	打开一个新的浏览器窗口或查找一个已命名的窗口
print()    	打印当前窗口的内容。
prompt() 	显示可提示用户输入的对话框。 
resizeBy() 	按照指定的像素调整窗口的大小。
resizeTo() 	把窗口的大小调整到指定的宽度和高度。
scrollBy() 	按照指定的像素值来滚动内容。 
scrollTo() 	把内容滚动到指定的坐标。
setInterval() 	按照指定的周期（以毫秒计）来调用函数或计算表达式。
setTimeout() 	在指定的毫秒数后调用函数或计算表达式。
*** Navigator JavaScript对象
**** 属性
appCodeName 	返回浏览器的代码名。 
appMinorVersion 	返回浏览器的次级版本。
appName 	返回浏览器的名称。 
appVersion 	返回浏览器的平台和版本信息。
browserLanguage 	返回当前浏览器的语言。
cookieEnabled 	返回指明浏览器中是否启用 cookie 的布尔值。
cpuClass 	返回浏览器系统的 CPU 等级。 
onLine 	返回指明系统是否处于脱机模式的布尔值。
platform 	返回运行浏览器的操作系统平台。 
systemLanguage 	返回 OS 使用的默认语言。
userAgent 	返回由客户机发送服务器的 user-agent 头部的值。 
userLanguage 	返回 OS 的自然语言设置。
**** 方法
javaEnabled() 	规定浏览器是否启用 Java。
taintEnabled() 	规定浏览器是否启用数据污点 (data tainting)
*** screen
**** 属性
availHeight 	返回显示屏幕的高度 (除 Windows 任务栏之外)。
availWidth 	返回显示屏幕的宽度 (除 Windows 任务栏之外)。 
bufferDepth 	设置或返回在 off-screen bitmap buffer 中调色板的比特深度。
colorDepth 	返回目标设备或缓冲器上的调色板的比特深度。
deviceYDPI 	返回显示屏幕的每英寸垂直点数。 
fontSmoothingEnabled 	返回用户是否在显示控制面板中启用了字体平滑
height 	返回显示屏幕的高度。 
logicalXDPI 	返回显示屏幕每英寸的水平方向的常规点数。 
logicalYDPI 	返回显示屏幕每英寸的垂直方向的常规点数。 
pixelDepth 	返回显示屏幕的颜色分辨率（比特每像素）
width 	            返回显示器屏幕的宽度。 
*** history
**** 属性
length              返回浏览器历史列表中的 URL 数量
**** 方法
back() 	            加载 history 列表中的前一个 URL 	
forward() 	加载 history 列表中的下一个 URL 
go() 	            加载 history 列表中的某个具体页面 [Num|URL] e: -1 前一个页面	
*** Location
**** 属性
hash 	            设置或返回从井号 (#) 开始的 URL（锚）。
host 	            设置或返回主机名和当前 URL 的端口号。 
hostname 	设置或返回当前 URL 的主机名。 
href 	            设置或返回完整的 URL。
pathname 	设置或返回当前 URL 的路径部分。 
port 	            设置或返回当前 URL 的端口号。
protocol 	设置或返回当前 URL 的协议。 
search 	设置或返回从问号 (?) 开始的 URL（查询部分）。
**** 方法
assign() 	加载新的文档。 
reload() 	重新加载当前文档。
replace() 	用新的文档替换当前文档。 
*** document
**** 集合
all[]       	提供对文档中所有 HTML 元素的访问。 document.all[0],不会用样式,script
anchors[] 	返回对文档中所有 Anchor 对象的引用。 
applets 	返回对文档中所有 Applet 对象的引用。
forms[] 	返回对文档中所有 Form 对象引用。
images[] 	返回对文档中所有 Image 对象引用。
links[] 	            返回对文档中所有 Area 和 Link 对象引用。
**** 属性
body    	提供对 <body> 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 <frameset>。 	  	  	  	 
cookie 	设置或返回与当前文档有关的所有 cookie。
domain 	返回当前文档的域名。 	
lastModified 	返回文档被最后修改的日期和时间。 该值来自于 Last-Modified HTTP 头部，它是由 Web 服务器发送的可选项	
referrer 	返回载入当前文档的文档的 URL。
title 	            返回当前文档的标题。 
URL 	            返回当前文档的 URL。 
**** 方法
close() 	           关闭用 document.open() 方法打开的输出流，并显示选定的数据。 
getElementById() 	返回对拥有指定 id 的第一个对象的引用。
getElementsByName() 	返回带有指定名称的对象集合。 	
getElementsByTagName() 	返回带有指定标签名的对象集合。
getElementsByClassName() 	返回带有指定 class 的对象集合。
open() 	           打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。
write()    	向文档写 HTML 表达式 或 JavaScript 代码。 
writeln() 	等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 
#+BEGIN_SRC javascript
<script type="text/javascript">
function createNewDoc()
  {
  var newDoc=document.open("text/html","replace");
  var txt="<html><body>学习 DOM 非常有趣！</body></html>";
  newDoc.write(txt);
  newDoc.close();
  }
</script>
#+END_SRC
*** 公共属性
className 	Sets or returns the class attribute of an element
dir 	(设置文字方向) ltr默认。从左向右的文本方向。rtl 	从右向左的文本方向。	
lang 	Sets or returns the language code for an element
title 	Sets or returns an element's advisory title 
*** document.forms[0] 文档中第一个表单节点
**** 集合
elements[] 	包含表单中所有元素的数组。
**** 属性
acceptCharset 	服务器可接受的字符集。 
action    	设置或返回表单的 action 属性。 
enctype 	设置或返回表单用来编码内容的 MIME 类型。 	
id        	设置或返回表单的 id。 
length 	返回表单中的元素数目。 
method 	设置或返回将数据发送到服务器的 HTTP 方法。
name   	设置或返回表单的名称。 
target   	设置或返回表单提交结果的 Frame 或 Window 名。

**** 方法
reset() 	把表单的所有输入元素重置为它们的默认值。 
submit() 	提交表单。
**** 事件
onreset 	在重置表单元素之前调用。 
onsubmit 	在提交表单之前调用。 
*** images
**** 属性
align    	设置或返回与内联内容的对齐方式。 
border 	设置或返回图像周围的边框。
complete 	返回浏览器是否已完成对图像的加载。 
height 	设置或返回图像的高度。 
hspace 	设置或返回图像左侧和右侧的空白。
id        	设置或返回图像的 id。
isMap  	返回图像是否是服务器端的图像映射。
longDesc 	设置或返回指向包含图像描述的文档的 URL。 
lowsrc 	设置或返回指向图像的低分辨率版本的 URL。
name   	设置或返回图像的名称。 
src       	设置或返回图像的 URL。
useMap 	设置或返回客户端图像映射的 usemap 属性的值。 
vspace 	设置或返回图像的顶部和底部的空白。 
width   	设置或返回图像的宽度。 
**** 事件
onabort 	当用户放弃图像的装载时调用的事件句柄。
onerror 	在装载图像的过程中发生错误时调用的事件句柄。
onload 	当图像装载完毕时调用的事件句柄。
*** link  元素可定义两个链接文档之间的关系,包括超链接
**** 属性
charset 	设置或返回目标 URL 的字符编码 	
disabled 	设置或返回目标 URL 是否当被禁用 	
href 	            设置或返回被链接资源的 URL 
hreflang 	设置或返回目标 URL 的基准语言 	
id 	设置或返回某个 <link> 元素的 id 	
media 	设置或返回文档显示的设备类型 	
name 	设置或返回 <link> 元素的名称 
rel 	设置或返回当前文档与目标 URL之间的关系 
rev 	设置或返回目标 URL 与当前文档之间的关系 
type 	设置或返回目标 URL 的 MIME 类型 
*** meta 元信息
**** 属性
content 	设置或返回 <meta> 元素的 content 属性的值
httpEquiv 	把 content 属性连接到一个 HTTP 头部 	
name  	把 content 属性连接到某个名称 	
scheme 	设置或返回用于解释 content 属性的值的格式 
*** Style 对象代表一个单独的样式声明。可从应用样式的文档或元素访问Style 对象
document.getElementById("id").style.property="值"
**** 属性
***** 背景
background 	在一行中设置所有的背景属性 
backgroundAttachment 	设置背景图像是否固定或随页面滚动 
backgroundColor 	设置元素的背景颜色 
backgroundImage 	设置元素的背景图像 
backgroundPosition 	设置背景图像的起始位置 
backgroundPositionX 	设置backgroundPosition属性的X坐标 
backgroundPositionY 	设置backgroundPosition属性的Y坐标 
backgroundRepeat 	设置是否及如何重复背景图像
***** 边框和边距
border             	在一行设置四个边框的所有属性 	
borderBottom  	在一行设置底边框的所有属性 
borderBottomColor 	设置底边框的颜色 	
borderBottomStyle 	设置底边框的样式 	
borderBottomWidth 	设置底边框的宽度 	
borderColor     	设置所有四个边框的颜色 (可设置四种颜色) 	
borderLeft       	在一行设置左边框的所有属性 
borderLeftColor 	设置左边框的颜色 	
borderLeftStyle 	设置左边框的样式 	
borderLeftWidth 	设置左边框的宽度 	
borderRight 	            在一行设置右边框的所有属性
borderRightColor 	设置右边框的颜色 	
borderRightStyle 	设置右边框的样式 	
borderRightWidth 	设置右边框的宽度 	
borderStyle 	            设置所有四个边框的样式 (可设置四种样式) 
borderTop 	            在一行设置顶边框的所有属性 
borderTopColor 	设置顶边框的颜色 		
borderTopStyle 	设置顶边框的样式 		
borderTopWidth 	设置顶边框的宽度 		
borderWidth 	设置所有四条边框的宽度 (可设置四种宽度) 
margin 	设置元素的边距 (可设置四个值)
marginBottom 设置元素的底边距
marginLeft 	设置元素的左边距 	
marginRight 	设置元素的右边据
marginTop 	设置元素的顶边距 	
outline 	在一行设置所有的outline属性 
outlineColor 	设置围绕元素的轮廓颜色 	
outlineStyle 	设置围绕元素的轮廓样式 	
outlineWidth 	设置围绕元素的轮廓宽度 	
padding 	设置元素的填充 (可设置四个值)
paddingBottom设置元素的下填充
paddingLeft 	设置元素的左填充
paddingRight 	设置元素的右填充
paddingTop 	设置元素的顶填充 	
***** 布局
clear    	设置在元素的哪边不允许其他的浮动元素 	
clip      	设置元素的形状 	
content 	设置元信息 	
counterIncrement 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器的增量。默认是1。
counterReset 	设置其后是正数的计数器名称的列表。其中整数指示每当元素出现时计数器被设置的值。默认是0。
cssFloat 	设置图像或文本将出现（浮动）在另一元素中的何处。 	
cursor   	设置显示的指针类型 
direction 	设置元素的文本方向 	
display 	设置元素如何被显示 	inherit父的属性继承
height 	设置元素的高度 
markerOffset 	设置marker box的principal box距离其最近的边框边缘的距离
marks 	            设置是否cross marks或crop marks应仅仅被呈现于page box边缘之外 	
maxHeight 	设置元素的最大高度 	
maxWidth 	设置元素的最大宽度 	
minHeight 	设置元素的最小高度 	
minWidth 	设置元素的最小宽度 	
****** overflow 	规定如何处理不适合元素盒的内容 	
overflow-x: hidden;隐藏水平滚动条
verticalAlign 	设置对元素中的内容进行垂直排列 
visibility 	设置元素是否可见 
width 	            设置元素的宽度
***** 列表
listStyle 	在一行设置列表的所有属性 
listStyleImage 	把图像设置为列表项标记 
listStylePosition改变列表项标记的位置 	
listStyleType 	设置列表项标记的类型
***** 定位
bottom 	设置元素的底边缘距离父元素底边缘的之上或之下的距离 	
left       	置元素的左边缘距离父元素左边缘的左边或右边的距离 	
position 	把元素放置在static, relative, absolute 或 fixed 的位置 	
right 	            置元素的右边缘距离父元素右边缘的左边或右边的距离 	
top 	            设置元素的顶边缘距离父元素顶边缘的之上或之下的距离 	
zIndex 	设置元素的堆叠次序
***** 文本
color 	设置文本的颜色 
font 	在一行设置所有的字体属性 
fontFamily 	设置元素的字体系列。
fontSize 	设置元素的字体大小。
fontSizeAdjust 	设置/调整文本的尺寸 
fontStretch 	设置如何紧缩或伸展字体
fontStyle 	设置元素的字体样式 
fontVariant 	用小型大写字母字体来显示文本 
fontWeight 	设置字体的粗细 
letterSpacing 	设置字符间距 
lineHeight 	设置行间距 
quotes 	设置在文本中使用哪种引号 
textAlign 	排列文本 
textDecoration 	设置文本的修饰 
textIndent 	缩紧首行的文本 
textShadow 	设置文本的阴影效果
textTransform 	对文本设置大写效果 
whiteSpace 	设置如何设置文本中的折行和空白符 	
wordSpacing 	设置文本中的词间距 
***** Table 
borderCollapse 	设置表格边框是否合并为单边框，或者像在标准的HTML中那样分离。 
borderSpacing 	设置分隔单元格边框的距离 
captionSide 	设置表格标题的位置 	
emptyCells 	设置是否显示表格中的空单元格
tableLayout 	设置用来显示表格单元格、行以及列的算法
*** node
**** 节点属性
***** innerHTML: 获取元素内容,很多东西
***** nodeName 规定节点的名称
***** nodeValue 规定节点的值 (文本节点有值)
***** nodeType 返回节点的类型。nodeType 是只读的
#+BEGIN_SRC 
元素 	1
属性 	2
文本 	3
注释 	8
文档 	9
#+END_SRC
: 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
****  修改
***** 创建新的 HTML 元素
#+BEGIN_SRC 
var para=document.createElement("p");
var node=document.createTextNode("This is new.");
para.appendChild(node);
#+END_SRC
**** HTML DOM - 元素
***** 创建新的 HTML 元素 - appendChild()您首先必须创建该元素，然后把它追加到已有的元素上。
***** 创建新的 HTML 元素 - insertBefore()
***** 删除已有的 HTML 元素
#+BEGIN_SRC 
var child=document.getElementById("p1");
child.parentNode.removeChild(child);
#+END_SRC
***** 替换 HTML 元素
: 如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法：
#+BEGIN_SRC 
var parent=document.getElementById("div1");
var child=document.getElementById("p1");
parent.replaceChild(para,child);
#+END_SRC

**** HTML DOM事件
***** window 事件属性
+ onload 页面结束加载之后触发。   
+ onresize  当浏览器窗口被调整大小时触发。 
***** FORM 事件
+ onselect      script 在元素中文本被选中后触发。            
+ onsubmit      script 在提交表单时触发。                   
***** 键盘事件
+ onkeydown  script 在用户按下按键时触发。
+ onkeypress script 在用户敲击按钮时触发。
+ onkeyup    script 当用户释放按键时触发。
***** Mouse事件
+ onclick
+ ondblclick
+ onmousedown
+ onscroll
***** Media事件
+ onabort
+ onplay
***** onmousedown、onmouseup 以及 onclick 事件
**** HTML DOM导航
***** 根节点
: document.documentElement - 全部文档
: document.body - 文档的主体

***** 节点列表
#+BEGIN_SRC 
 var x=document.getElementsByTagName("p");
可以通过下标号访问这些节点。如需访问第二个 <p>，您可以这么写：
y=x[1]; 
#+END_SRC
***** length 属性定义节点列表中节点的数量

*** console用来可以查看错误信息、打印调试信息、调试js代码，还可以当作Javascript API查看
**** log 输出变量值
**** console.dir(dom) 查看dom API
*** XML xmldoc
*** 浏览器
* HTML5 文本    
都是有结构的标签,表示的含义是元素,元素包含属性
** 标题
<h1>-<h6>
** 段落
<p>
** 格式化
<b>粗体 <em>着重文字<i> <small>
** 链接
<a>
** <head>
*** <title> 文档标题
*** <base> 定义页面中所有链接默认的链接目标地址,就像定义PATH路径一样,这会影响所有路径属性,不要用
*** <meta>有两个属性,分别是http-equiv 和name
**** 1、name 属性 ：
　　<meta name="Generator" contect="">用以说明生成工具（如Microsoft FrontPage 4.0）等；
　　<meta name="KEYWords" contect="">向搜索引擎说明你的网页的关键词；
　　<meta name="DEscription" contect="">告诉搜索引擎你的站点的主要内容；
　　<meta name="Author" contect="姓名">告诉搜索引擎你的站点的制作的作者；
　　<meta name="Robots" contect= "all|none|index|noindex|follow|nofollow">
　　其中的属性说明如下：
　　设定为all：文件将被检索，且页面上的链接可以被查询；
　　设定为none：文件将不被检索，且页面上的链接不可以被查询；
　　设定为index：文件将被检索；
　　设定为follow：页面上的链接可以被查询；
　　设定为noindex：文件将不被检索，但页面上的链接可以被查询；
　　设定为nofollow：文件将被检索，页面上的链接不可以被查询。

**** 2、http-equiv属性 ：
　　<meta http-equiv="Content-Type" contect="text/html";charset=gb_2312-80">
　　<meta http-equiv="Content-Language" contect="zh-CN">
　　用以说明主页制作所使用的文字以及语言；
　　<meta http-equiv="Refresh" contect="n;url=http://yourlink">
　　定时让网页在指定的时间n内，跳转到页面http://yourlink；
　　<meta http-equiv="Expires" contect="Mon,12 May 2001 00:20:00 GMT">
　　可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。
　　需要注意的是必须使用GMT时间格式；
　　<meta http-equiv="Pragma" contect="no-cache">
　　是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；
　　<meta http-equiv="set-cookie" contect="Mon,12 May 2001 00:20:00 GMT">
　　cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；
　　<meta http-equiv="Pics-label" contect="">
　　网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，
　　而网站的限制级别就是通过meta属性来设置的；
　　<meta http-equiv="windows-Target" contect="_top">
　　强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；
　　<meta http-equiv="Page-Enter" contect="revealTrans(duration=10,transtion= 50)">
　　<meta http-equiv="Page-Exit" contect="revealTrans(duration=20，transtion=6)">
　　设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。
*** <link> 标签定义了文档与外部资源之间的关系。
<link> 标签通常用于链接到样式表:
<link rel="stylesheet" type="text/css" href="mystyle.css">
*** <style> 
#+BEGIN_SRC 
<style type="text/css">
body {background-color:yellow}
p {color:blue}
</style>
#+END_SRC
*** <script>
** <img>
<img src="url" alt="some_text" width="304" height="228"> 
** <table>
** 列表
*** 有序列表 order list(顺序)
ol li
*** 无序列表
ul li
** div 和span 
HTML 可以通过 <div> 和 <span>将元素组合起来
** 表单 <form>
*** 输入元素 
**** 文本域
<input type="text" name="name">
**** 密码字段
<input type="password" name="pwd">
**** 单选按钮（Radio Buttons）
<input type="radio" name="sex" value="male">Male<br>
<input type="radio" name="sex" value="female">Female
**** 复选框
<input type="checkbox" name="vehicle" value="Bike">I have a bike<br>
<input type="checkbox" name="vehicle" value="Car">I have a car 
**** 提交按钮
<input type="submit" value="Submit">
**** 下拉列表
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>
**** 按钮
<input type="button" value="Hello world!">
**** 文本域
<textarea rows="10" cols="30">
我是一个文本框。
</textarea>
**** <datalist>定义选项列表。请与 input 元素配合使用该元素
#+BEGIN_SRC 
<input list="browsers">
 
<datalist id="browsers">
  <option value="Internet Explorer">
  <option value="Firefox">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>
#+END_SRC
** 框架
<iframe src="demo_iframe.htm" frameborder="0"></iframe>
** canvas
<canvas> 	标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API
canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成
#+BEGIN_SRC 
<!DOCTYPE html> 
<html>
<head> 
<meta charset="utf-8"> 
<title>菜鸟教程(runoob.com)</title> 
</head> 
<body>

<canvas id="myCanvas">你的浏览器不支持 HTML5 canvas 标签。</canvas>

<script>
var c=document.getElementById('myCanvas');
var ctx=c.getContext('2d');
ctx.fillStyle='#FF0000';
ctx.fillRect(0,0,80,100);
</script>

</body>
</html>
#+END_SRC
#+BEGIN_SRC 
<canvas id="myCanvas" width="200" height="100" style="border:1px solid #000000;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
#+END_SRC
** 多媒体
*** <audio>支持 MP3,Wav,Ogg
#+BEGIN_SRC 
<audio controls>
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
  您的浏览器不支持 audio 元素。
</audio>
#+END_SRC
属性
autoplayNew 	autoplay 	如果出现该属性，则音频在就绪后马上播放。
controlsNew 	controls 	如果出现该属性，则向用户显示音频控件（比如播放/暂停按钮）。
loopNew 	loop 	如果出现该属性，则每当音频结束时重新开始播放。
mutedNew 	muted 	如果出现该属性，则音频输出为静音。
preloadNew 	auto
metadata
none 	规定当网页加载时，音频是否默认被加载以及如何被加载。
srcNew 	URL 	规定音频文件的 URL。
*** <video>
*** <source>定义多媒体资源 <video> 和 <audio>
** 新的语义和结构:为了创建更好的页面结构
*** <article>>    定义文档内的文章
*** <aside>      定义页面内容之外的内容
*** <bdi>        定义与其他文本不同的文本方向
*** <details>    定义用户可查看或隐藏的额外细节
*** <dialog>     定义对话框或窗口
*** <figcaption> 定义 <figure> 元素的标题
*** <figure>     定义自包含内容，比如图示、图表、照片、代码清单
*** <footer>     定义文档或节的页脚
*** <header>     定义文档或节的页眉
*** <main>       定义文档的主内容                        
*** <mark>       定义重要或强调的内容
*** <menuitem>   定义用户能够从弹出菜单调用的命令/菜单项目
*** <meter>      定义已知范围（尺度）内的标量测量
*** <nav>        定义文档内的导航链接
*** <progress>   定义任务进度
*** <rp>         定义在不支持 ruby 注释的浏览器中显示什么
*** <rt>         定义关于字符的解释/发音（用于东亚字体）
*** <ruby>       定义 ruby 注释（用于东亚字体）
*** <section>    定义文档中的节
*** <summary>    定义 <details> 元素的可见标题 
*** <time>       定义日期/时间。
*** <wbr>        定义可能的折行（line-break）
**** <frame>      框架
***** <p>
****** <h1>
****** <!--> 
****** 格式化<b><big><em><i><code><kbd><ins>
****** <a>
****** <img>
****** <table>!!!少用
****** <ul><ol>

* 样式 CSS 样式定义如何显示 HTML 元素
** 选择器,依赖DOM
*** 派生选择器
+ li strong {a:v;b:v}  
*** id选择器
+ #red {color:red;}
*** 类选择器
+ .center {text-align: center}
*** 属性选择器
+ input [title="value"] //也可以不要value修饰

** 样式
*** CSS 样式
**** CSS 背景(包含padding,和border) 不继承
background-color: 默认 transparent 透明
background-image:默认 none,url(path) 可以放两张背景
background-repeat:默认padding左上角开始 repeat-x repeat-y no-repeat(重复图像) 
background-position: top ,center,bottom,left,center,right(上中下,左中右) 100px 4com 2%,一个值得话,纵坐标默认居中
background-attachment:fixed/scroll/local 背景关联
fixed->元素范围大,背景范围小,元素动,背景不动
scroll->背景在元素的定位已经固定,元素动,背景也动
local->未知??
em是相对长度单位。相对于当前对象内文本的字体尺寸。如未被设定,则相对于浏览器默认字体尺寸.
background-size: 长宽 px 或 %,相对于父元素而不是图形
background-origin 背景图片相对于(content-box、padding-box 或 border-box )的定位
background-clip:content-box; 规定背景的绘制区域
**** CSS 文本(字操作)
text-indent: -5em 2% 2px 用于块元素,行元素可以用padding,可以继承
text-align: left,center,right 行内元素
word-spacing:定义为由空白符包围的一个字符串,中英文混合文本中。其默认值 normal 与设置值为 0 是一样的
letter-spacing:字间距离
text-transform:capitalize uppercase lowercase 
text-decoration:underline overline(上划线) line-through(穿透线) blink(闪烁)文本装饰
white-space:normal(空格和换行是不解释的)
| 值       | 空白符 | 换行符 | 自动换行 |
| pre-line | 合并   | 保留   | 允许     |
| normal   | 合并   | 忽略   | 允许     |
| nowrap   | 合并   | 忽略   | 不允许   |
| pre      | 保留   | 保留   | 不允许   |
| pre-wrap | 保留   | 保留   | 允许     |
direction：ltr 和 rtl 文本方向
text-shadow:5px 5px 5px #FF0000;
word-wrap: 长单词,(超过一行)允许截断到下一行 break-word /normal
text-outline: 文本轮廓
**** CSS 字体
font-family: 使用字体系列,字体名中有空格时 要用引号
font-style:字体风格 normal italic(normal版本的倾斜改动) oblique(字体的倾斜版本)
font-variant:字体变形 small-caps (另一种格式的大写英文)
font-weigth: bold 100~900 九级加粗度数字 400 等价于 normal，而 700 等价于 bold。浏览器分不出那么多级,就normal和bold
font-size:默认大小是 16 像素 (16px=1em(当前尺寸,当前是16px))
使用自己的字体,客户能够下载:“自己的”的字体是在 CSS3 @font-face 规则中定义的。
#+BEGIN_SRC 
使用您需要的字体
在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。
如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：
实例

<style> 
@font-face
{
font-family: myFirstFont;
src: url('Sansation_Light.ttf'),
     url('Sansation_Light.eot'); /* IE9+ */
}

div
{
font-family:myFirstFont;
}
</style>

#+END_SRC
**** CSS 链接
链接的四种状态：
    a:link - 普通的、未被访问的链接
    a:visited - 用户已访问的链接
    a:hover - 鼠标指针位于链接的上方
    a:active - 链接被点击的时刻
text-decoration 属性大多用于去掉链接中的下划线
**** CSS 列表
从某种意义上讲，不是描述性的文本的任何内容都可以认为是列表。人口普查、太阳系、家谱、参观菜单，甚至你的所有朋友都可以表示为一个列表或者是列表的列表。
由于列表如此多样，这使得列表相当重要，所以说，CSS 中列表样式不太丰富确实是一大憾事。
list-style-type: squre(方块)circle,decimal
list-style-image: url(xxx.gif) 点,用图像替代
list-style-position
该属性用于声明列表标志相对于列表项内容的位置。外部 (outside)默认值。保持标记位于文本的左侧。
内部 (inside) 标志处理为好像它们是插入在列表项内容最前面的行内元素一样
**** CSS 表格
**** CSS 轮廓
轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
CSS outline 属性规定元素轮廓的样式、颜色和宽度,!轮廓的宽度会占用margin的一部分
outline-color:
outline-style
outline-width
*** CSS 框模型(根据元素width来)
**** CSS 内边距
padding
**** CSS 边框
border-style
border-width
border-color:transparent 有宽度的不可见边框
border-radius: 边框圆角 四个角顺序是 top right bottom left
box-shadow:边框阴影 (灯光的照射形成的)
box-shadow: h-shadow v-shadow blur spread color inset;
h-shadow 	必需。水平阴影的位置。允许负值。 
v-shadow 	必需。垂直阴影的位置。允许负值。 
blur 	            可选。模糊距离。 
spread 	可选。阴影的尺寸。 
color 	可选。阴影的颜色。请参阅 CSS 颜色值。
inset 	可选。将外部阴影 (outset) 改为内部阴影。
--------
border-image-source 	用在边框的图片的路径。(特别要注意图片是框型的,跟border设定要一样,就是把图片套到边框上面) 	
border-image-slice 	图片边框向内偏移。 	
border-image-width 	图片边框的宽度。 	
border-image-outset 	边框图像区域超出边框的量。 	
border-image-repeat 	图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。
**** CSS 外边距
margin
**** CSS 外边距合并 当两个垂直外边距相遇时，它们将形成一个外边距。
*** CSS 定位
**** CSS 相对定位 (相对当前布局)
position:relative
left:-20px
top right bottom
**** CSS 绝对定位(
元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样
**** CSS 浮动 
**** 堆叠顺序,先要设定position属性
z-index 正数,接近用户,负数,远离用户
*** 2D转换
Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。
Chrome 和 Safari 需要前缀 -webkit-。
注释：Internet Explorer 9 需要前缀 -ms-。
transform:
translate()转化,平移 px em %
rotate()旋转,正时针 -30deg 角度,角(degree)
scale(2,4) 原始宽度的2 倍和高度的4倍 会变形的
skew(30deg,20deg)倾斜,歪斜 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度
matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。
transform-origin 	允许你改变被转换元素的位置
*** 3D转换 
rotateX() 元素围绕其 X 轴以给定的度数进行旋转。
rotateY() 
*** CSS3 过渡(是一种事件样的)挺好玩的
是元素从一种样式逐渐改变为另一种的效果
transition 转化,过度
!   规定您希望把效果添加到哪个 CSS 属性上,可以多个属性
!   规定效果的时长
#+BEGIN_SRC 
div{transition:width 2s;}
div:hover{width:300px;}
#+END_SRC
transition-property 	规定应用过渡的 CSS 属性的名称。 
transition-duration 	定义过渡效果花费的时间。默认是 0。
transition-timing-function 	规定过渡效果的时间曲线。默认是 "ease"。
transition-delay 	规定过渡效果何时开始。默认是 0。
*** CSS3动画
如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。用户创建动画
#+BEGIN_SRC 
@keyframes myfirst
{
from {background: red;}
to {background: yellow;}
}

@-moz-keyframes myfirst /* Firefox */
{
from {background: red;}
to {background: yellow;}
}

@-webkit-keyframes myfirst /* Safari 和 Chrome */
{
from {background: red;}
to {background: yellow;}
}

@-o-keyframes myfirst /* Opera */
{
from {background: red;}
to {background: yellow;}
}
#+END_SRC
#+BEGIN_SRC 
通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：

    规定动画的名称
    规定动画的时长

实例

把 "myfirst" 动画捆绑到 div 元素，时长：5 秒：

div
{
animation: myfirst 5s;
-moz-animation: myfirst 5s;	/* Firefox */
-webkit-animation: myfirst 5s;	/* Safari 和 Chrome */
-o-animation: myfirst 5s;	/* Opera */
}
#+END_SRC
*** CSS3 多列
*** CSS3 用户界面
* 客户端脚本 javascript
** 对象
*** 内建对象,String;Date;Array
*** 对象构造器
#+BEGIN_SRC javascript
    function person(firstname,lastname,age,eyecolor)
    {
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;
    }
#+END_SRC
** JavaScript for...in 语句循环遍历对象的属性。
** 日期 Date() getTime() setFullYear() toUTString getDay()
** 数组 concat() join() sort() Array()
*** RegExp 对象有 3 个方法：test()、exec() 以及 compile()。
*** window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。
****  * location.hostname 返回 web 主机的域名
****  * location.pathname 返回当前页面的路径和文件名
****  * location.port 返回 web 主机的端口（80 或 443）
****  * location.protocol 返回所使用的 web 协议（http:// 或
    https://）
****    location.href
**** location.assign()  加载新的文档
**** window.navigator 对象包含有关访问者浏览器的信息。

* 客户端脚本jQuery javascript库,简化
** 引入脚本执行<script src="my_jquery_functions.js"></script>
** jQuery 选择器 $()
*** 元素选择器 $("p")
*** #id 选择器 $("#test") 
*** .class 选择器 $(".class")
*** 选取所有元素 $("*") 	
*** document和 this
#+BEGIN_SRC javascript -n
$(document).ready(function(){
  $("button").click(function(){
    $(this).hide();
  });
});
#+END_SRC
*** 嵌套 $("a[target='_blank']") 	选取所有 target 属性值等于 "_blank" 的 <a> 元素
** jQuery 效果
*** jQuery  fade(淡出) 方法：
****    fadeIn()
****    fadeOut()
****    fadeToggle()
****    fadeTo()
*** jQuery 滑动方法
****    slideDown(speed,callback)
****    slideUp()
****    slideToggle()
*** jQuery 动画 - animate() 方法
**** $(selector).animate({params},speed,callback);
*** jQuery 停止动画
jQuery stop() 方法用于在动画或效果完成前对它们进行停止。
** jQuery HTML
*** jQuery - 获取内容和属性 | 配置
**** 获得内容 - text()、html() 以及 val()
#+BEGIN_SRC 
    text() - 设置或返回所选元素的文本内容
    html() - 设置或返回所选元素的内容（包括 HTML 标记）
    val() - 设置或返回表单字段的值
#+END_SRC
**** 获取属性值 - attr()
*** jQuery - 添加元素
****    append() - 在被选元素的结尾插入内容
****    prepend() - 在被选元素的开头插入内容
****    after() - 在被选元素之后插入内容
****    before() - 在被选元素之前插入内容
*** jQuery - 删除元素
****     remove() - 删除被选元素（及其子元素）
****    empty() - 从被选元素中删除子元素
*** jQuery - 获取并设置 CSS 类
**** jQuery addClass() 方法
#+BEGIN_SRC 
$("button").click(function(){
  $("h1,h2,p").addClass("blue");
  $("div").addClass("important");
});
#+END_SRC
**** jQuery removeClass() 方法
**** jQuery toggleClass() 方法
*** jQuery css() 方法
: css() 方法设置或返回被选元素的一个或多个样式属性。
**** 返回 CSS 属性
: css("propertyname");
**** 设置 CSS 属性
: css("propertyname","value");
**** 设置多个 CSS 属性
: css({"propertyname":"value","propertyname":"value",...});
#+BEGIN_SRC css
$("p").css({"background-color":"yellow","font-size":"200%"});
#+END_SRC
*** jQuery 尺寸
: 通过 jQuery，很容易处理元素和浏览器窗口的尺寸。
[元素(width)]padding(innerwidth)]border(outerwidth)]margin(outerwidth(true))]
****    width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。
****    height()
****    innerWidth() 方法返回元素的宽度（包括内边距）
****    innerHeight()
****    outerWidth()方法返回元素的宽度（包括内边距和边框）
****    outerHeight()
*** jQuery 遍历
**** 向上遍历 DOM 树
*****    parent()返回被选元素的直接父元素
*****    parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)
*****    parentsUntil() 返回介于两个给定元素之间的所有祖先元素
#+BEGIN_SRC 
$(document).ready(function(){
  $("span").parentsUntil("div");
});
#+END_SRC
**** jQuery 遍历 - 后代
*****  children()
*****  find()方法返回被选元素的后代元素，一路向下直到最后一个后代
#+BEGIN_SRC 
$(document).ready(function(){
  $("div").find("span");
});
#+END_SRC
**** jQuery 遍历 - 同胞(siblings)
*****    siblings()返回被选元素的所有同胞元素
*****    next()返回被选元素的下一个同胞元素
*****    nextAll()
*****    nextUntil()返回介于两个给定参数之间的所有跟随的同胞元素
*****    prev() 方向相反
*****    prevAll()
*****    prevUntil()
**** jQuery 遍历- 过滤
***** jQuery first() 方法first() 方法返回被选元素的首个元素。
***** last()
***** eq()返回被选元素中带有指定索引号的元素。从0开始
** jQuery Ajax 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。
*** jQuery load() 方法
**** load() 方法从服务器加载数据，并把返回的数据放入被选元素中。
: $(selector).load(URL,data,callback);
: 必需的 URL 参数规定您希望加载的 URL。
: 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。
: 可选的 callback 参数是 load() 方法完成后所执行的函数名称。
#+BEGIN_SRC 
$("#div1").load("demo_test.txt #p1");
#+END_SRC
对象要符合DOM
#+BEGIN_SRC 
可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数：
    responseTxt - 包含调用成功时的结果内容
    statusTXT - 包含调用的状态
    xhr - 包含 XMLHttpRequest 对象
下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示"外部内容加载成功！"，而如果失败，则显示错误消息：
实例
$("button").click(function(){
  $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){
    if(statusTxt=="success")
      alert("外部内容加载成功!");
    if(statusTxt=="error")
      alert("Error: "+xhr.status+": "+xhr.statusText);
  });
});
#+END_SRC
*** jQuery - AJAX get() 和 post() 方法
: jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。
**** $.get() 方法通过 HTTP GET 请求从服务器上请求数据。
: $.get(URL,callback);
必需的 URL 参数规定您希望请求的 URL。
可选的 callback 参数是请求成功后所执行的函数名。
下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：
#+BEGIN_SRC 
$("button").click(function(){
  $.get("demo_test.php",function(data,status){
    alert("数据: " + data + "\n状态: " + status);
  });
});
#+END_SRC
**** $.post() 方法通过 HTTP POST 请求从服务器上请求数据。
$.post(URL,data,callback);
必需的 URL 参数规定您希望请求的 URL。
可选的 data 参数规定连同请求发送的数据。
可选的 callback 参数是请求成功后所执行的函数名。
下面的例子使用 $.post() 连同请求一起发送数据：
#+BEGIN_SRC 
$("button").click(function(){
    $.post("/try/ajax/demo_test_post.php",
    {
        name:"菜鸟教程",
        url:"http://www.runoob.com"
    },
        function(data,status){
        alert("数据: \n" + data + "\n状态: " + status);
    });
});
#+END_SRC
*** 事件
**** ready将函数绑定到文档的就绪事件
**** click /dblclick/focus/mouseover
**** onchange 事件(text 对象)
**** onmouseover 和 onmouseout 事件

*** 文字两端对齐
<html>
<head>
    <style type="text/css">
        h1 {
            text-align: justify;
            overflow-x: hidden;
            overflow-y: hidden;
            width: 800px;
            height: 40px;
        }

            h1:after {
                display: inline-block;
                content: '';
                overflow-x: hidden;
                overflow-y: hidden;
                width: 600px;
                height: 40px;
            }
    </style>
</head>
<body>
    <h1>实现单行文本的内容两端对齐</h1>
</body>
</html>  

* html5揭秘
web 浏览器请求一个页面时,Web服务器会在发送实际页面内容前,先发送一些头信息(header)
浏览器需要这些头信息解析随后的页面内容..(交流嘛)
Content-Type:text/html (内容类型或MIME类型)
MIME类型(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型,是描述消息内容类型的因特网标准。
| jpeg       | image/jpeg               |
| png        | image/png                |
| javascript | application/x-javascript |
| css        | text/css                 |
| xhtml      | application/xhtml+xml(严格形式,但一般用宽松形式) |

当浏览器渲染Web页面的时候,它会构造一个文档对象模型(DOM),用一个对象的集合表示
页面上的HTML元素.除此还有window和document这些不和特定页面元素绑定的全局对象.
对象有共有属性
还有私有属性
** 第1章 从开始到现在 
*** 1.2 MIME类型 
*** 1.3 很长的题外话：一份标准是如何诞生的？ 
*** 1.4 未曾间断的路线 
*** 1.5 HTML发展史：从1997到2004年 
*** 1.6 你所知道的关于XHTML的一切都是错误的 
*** 1.7 一个竞争愿景 11
*** 1.8 WHAT工作小组？ 12
*** 1.9 回到W3C 13
** 第2章 HTML5特性检测 
*** 2.1 引言 
*** 2.2 检测技术 
1. 全局对象是否拥有HTML5特性
2.创建个元素,然后检测元素的DOM对象
3. 检测DOM对象的方法
4. 检测DOM对象的属性
*** 2.3 Modernizr：一个HTML5特性检测库 
#+BEGIN_SRC 
<!DOCTYPE html>
<html>
<head>
<script src="modernizr.min.js"></script>
</head>
</html>

然后把HTML5元素 灵活处理//注意Modernizr 'M'要大写
if(Modernizr.canvas){
//开始画写什么吧!
}else{
//对于不支持canvas的浏览器
}
#+END_SRC

*** 2.4 画布 <canvas>依赖分辨率的位图画布
自己写的 元素支持某方法
#+BEGIN_SRC 
function supports_canvas(){
return !!document.createElement('canvas').getContext;
}
浮游在内存中,测试是否拥有getcontext()方法,用双重否定强制让这个检测方法返回一个布尔值
#+END_SRC
*** 2.5 画布文本 
!! 注意:canvas 文本api 比canvas api 晚
#+BEGIN_SRC javascript
function supports_canvas_text(){
if(!supports_canvas()){return false;}
var dummy_canvas = document.createElement('canvas');
var context = dummy_canvas.getContext('2d');
return typeof context.fillText == 'function';
}
或者使用 Modernizr.canvastext
#+END_SRC
*** 2.6 视频 <video> 视频控制需要用到JavaScript
检测
return !!document.createElement('video').canPlayType;
or Modernizr.video
*** 2.7 视频格式 
检测,,晕 +_+
return document.createElement('video').canPlayType('video/mp4; codecs="avc1.42E1E, mp4a.40.2"');
返回值不再是bool,而是string
"probably"   浏览器有充分把握可以播放此格式
"maybe"     有可能
""(空字符串")   无法播放

#+BEGIN_SRC javascript
检测 ogg格式 ;;这要学习视频 编码
function supports_ogg_theora_video(){
if(!support_video()){return false;}
var v= document.createElement("video");
return v.canPlayType('video/ogg;codecs="theora,vorbis"');
}
or Modernizr.video.ogg
#+END_SRC
*** 2.8 本地存储 
与cookie 类似,不过容量更大
cookie 每次请求页面总会发送回服务器,而本地存储可以在本地用javascript获取
检测 如果window对象有一个localStorage属性,则支持
return ('localStorage' in window) && window['localStorage'] !==null;
Modernizr.localstorage   Modernizr库中的属性名都是小写
*** 2.9 Web Workers (多线程支持)
return !!window.Worker;
or Modernizr.webworkers
*** 2.10 离线Web应用 
return !!window.applicationCache
or Modernizr.applicationcache
*** 2.11 地理位置 不属于html5标准
return !!navigator.geolocation
Modernizr.geolocation
*** 2.12 输入框类型 
<input type="search"> 搜索框
number 数字输入框
range 范围选择滑块
color 颜色选择器
url 网址输入框
email 邮件
date  日期;精确到年月日
month 月份;精确到月份
week 星期 
time 时间戳;精确到小时 分钟
datetime 精确日期/时间戳
datetime-local 当地时间和日期,本地化 年月日 时分秒

检测
return document.createElement("input").setAttribute("type","color").type !== "text";
Modernizr.inputtypes.date ....
*** 2.13 占位文本 
就是 placeholder属性
*** 2.14 表单自动聚焦 
autofocus 属性
return 'autofocus' in document.createElement("input")
Modernizr.input.autofocus
*** 2.15 微数据 
return !!document.getItems;
Modernizr 目前不支持,没查过
** 第3章 从这一切的含义 
*** 3.1  original html
#+BEGIN_SRC html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
: doctype 渲染模式; 默认quirks 模式 ;html 标准模式 ;准标准模式
:一般 <!DOCTYPE html> 标准模式就好了
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
:xmlns xml 过时了 ;lang 指定语种
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
:Content-Type: text/html; charset="utf-8" 服务器发送的字节编码 ,不懂
:html5 中 <meta charset="utf-8" />
  <meta name="robots" content="noindex" />
  <title>My Weblog</title>
  <link rel="stylesheet" type="text/css" href="style-original.css" />
:普通的链接(<a href>) 只是简单地链到另一个网页
:链接关系(link relations) 提供一种方式解释为什么要链接到那个页面,就像做一种解释
:一样,如"我链接到另一个网页,是因为...."
.....他是一个样式表,包含浏览器应当用于当前文档上的CSS规则.
.....他提供一个包含页面内容的标准订阅格式(如RSS)
:ctylesheet type可以去掉,因为只有一种css类型
  <link rel="alternate" type="application/atom+xml" title="My Weblog feed" href="/feed/" />
:tyle 可以是RSS或Atom等,表示Xml 格式的atom聚合内容
  <link rel="search" type="application/opensearchdescription+xml" title="My Weblog search" href="opensearch.xml" />
</head>
: rel="archives" 表示所引用的文档描述了一组收藏,如blog可以链到该博客的索引目录
: rel="author"  链到该页面作者的相关信息.可以是一个"关于作者"页面,或 mailto:地址
: rel="shortcut icon" href="/xx.ico" 就是地址栏旁的小图标
<body>

  <div id="header">
    <h1>My Weblog</h1>
    <p class="tagline">A lot of effort went into making this effortless.</p>

    <div id="nav">
      <ul>
        <li><a href="../semantics.html">home</a></li>
        <li><a href="../semantics.html">blog</a></li>
        <li><a href="../semantics.html">gallery</a></li>
        <li><a href="../semantics.html">about</a></li>
      </ul>
    </div>

  </div>

  <div class="entry">
    <p class="post-date">October 22, 2009</p>
    <h2>
      <a href="../semantics.html" rel="bookmark" title="link to this post">Travel day</a>
    </h2>

    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec hendrerit felis accumsan turpis pretium tempor. Duis eu turpis nunc, ut euismod nisl. Aliquam erat volutpat. Proin eu eros mollis dui fringilla sodales. Curabitur venenatis tincidunt felis ac congue. Maecenas at odio dui, sit amet congue sapien. Proin placerat feugiat eros, non mollis quam pharetra at. Duis gravida eleifend ligula nec auctor. Fusce nulla diam, fringilla non ultrices in, iaculis eu tellus. Sed mollis consequat turpis sit amet facilisis. Donec pretium luctus aliquet. Curabitur placerat varius purus vel congue. Aliquam erat volutpat. Curabitur vitae eros sed turpis sollicitudin mattis. Morbi venenatis pulvinar nunc, at vulputate massa placerat a. Nam et tortor id nisi consequat tempor eget sit amet risus. Praesent bibendum, velit eu hendrerit porttitor, elit mauris posuere nisl, non pellentesque est leo a quam.</p>

  </div>

  <div class="entry">
    <p class="post-date">October 17, 2009</p>
    <h2>
      <a href="../semantics.html" rel="bookmark" title="link to this post">I'm going to Prague!</a>
    </h2>

    <p>Sed ante mi, sagittis sed euismod sit amet, convallis et nibh. Etiam sit amet odio dui, id semper turpis. Mauris risus mauris, imperdiet pulvinar vehicula et, hendrerit vitae dui. Phasellus ultrices lacus rhoncus purus posuere rutrum. Maecenas mattis eleifend scelerisque. Nulla quam sem, facilisis ac ultrices et, tincidunt eu dolor. Mauris arcu est, porttitor eu blandit nec, pulvinar sed enim. Praesent diam felis, cursus at facilisis eu, mollis ut elit. Praesent rutrum porta euismod. Nulla facilisi. Suspendisse potenti. In auctor ultricies eleifend. Proin erat dolor, malesuada non tempus nec, tincidunt in mi.</p>

  </div>

  <p class="c sectionSign"></p>

<table id="arc">
<tr><th>October</th><td></td></tr>
<tr><th>5</th><td><a href="../semantics.html">Vos vestros servate, meos mihi linquite mores</a></td></tr>
<tr><th>September</th><td></td></tr>
<tr><th>30</th><td><a href="../semantics.html">Ut sementem feceris ita metes</a></td></tr>
<tr><th>August</th><td></td></tr>
<tr><th>4</th><td><a href="../semantics.html">Risu inepto res ineptior nulla est</a></td></tr>
<tr><th>July</th><td></td></tr>
<tr><th>6</th><td><a href="../semantics.html">Vitanda est improba siren desidia</a></td></tr>
<tr><th>April</th><td></td></tr>
<tr><th>21</th><td><a href="../semantics.html">Mendacem oportet esse memorem</a></td></tr>
<tr><th>7</th><td><a href="../semantics.html">Libenter homines id quod volunt credunt</a></td></tr>
<tr><th>March</th><td></td></tr>
<tr><th>27</th><td><a href="../semantics.html">Gutta cavat lapidem</a></td></tr>
<tr><th>21</th><td><a href="../semantics.html">Amoto quaeramus seria ludo</a></td></tr>
<tr><th>18</th><td><a href="../semantics.html">Non est ars quae ad effectum casu venit</a></td></tr>
<tr><th>January</th><td></td></tr>
<tr><th>11</th><td><a href="../semantics.html">Quid rides?...De te fabula narratur</a></td></tr>
</table>

  <div id="footer">

    <p class=sectionSign>

    <p>&copy; 2009 <a href="../semantics.html">Mark Pilgrim</a></p>

  </div>

</body>
</html>

#+END_SRC
*** 3.2 html5
#+BEGIN_SRC html
<!DOCTYPE html>
<meta charset="utf-8">
<title>Dive Into HTML5</title>
<link rel="alternate" type="application/atom+xml" href="https://github.com/diveintomark/diveintohtml5/commits/master.atom">
<link rel="stylesheet" href="screen.css">
<style>
h1:before{content:''}
h1,h2,h3{padding:0;margin:0;border:0;line-height:128px;text-align:center;clear:both}
h1{margin-top:128px;font-size:72px;text-transform:uppercase}
h2{font-size:48px}
ol{margin:1em 0 0 0;padding:0}
li{clear:both;width:100%;margin:0 0 1em 0;padding:0;overflow:hidden}
.title,.number{background:#fff}
.title{float:left;padding-right:3px}
.number{margin:0;float:right;padding-left:3px}
.f{margin-top:6.224em}
</style>
<link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="mobile.css">
<link rel="prefetch" href="introduction.html">
<hgroup>
<h1>Dive Into HTML5</h1>
<h2>by<br>Mark Pilgrim</h2>
<h3>with contributions from the community</h3>
</hgroup>

<p class="a rotatedFloralHeartBullet">

<p class="f">Dive Into <abbr>HTML5</abbr> elaborates on a hand-picked selection of features from the <a href="http://www.whatwg.org/html5">HTML5</a> specification and other fine standards. We encourage you to <a href="//www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027">buy the printed work</a> &mdash; Mark Pilgrim&rsquo;s artfully titled &ldquo;HTML5: Up <i class="baa">&amp;</i> Running&rdquo; &mdash; published on paper by O&rsquo;Reilly, under the Google Press imprint. Your kind and sincere <a href="about.html">feedback is always welcome</a>, and this work shall remain online under the <a rel="license" href="//creativecommons.org/licenses/by/3.0/">CC-BY-3.0 license</a>.

<p>This particular edition of Dive Into HTML5 is advanced by <a href="//github.com/diveintomark?tab=members">the diveintomark team</a>. We work hard to add and update content, links, APIs, and actively maintain this fine resource; refreshing and reflecting the relevant and current state of HTML5, just as Mark Pilgrim did during his tenure. We attribute this work in the manner specified by Mark, and we make modifications to the site's content. We do not in any way suggest that he endorses us or our use of his work. We hope you do.

<h3>Table of Contents</h3>

<!-- toc -->
<ol>
<li><a href="introduction.html">Introduction: Five Things You Should Know About <abbr>HTML5</abbr></a>
<li><a href="past.html">A Quite Biased History of <abbr>HTML5</abbr></a>
<li><a href="detect.html">Detecting <abbr>HTML5</abbr> Features: It&rsquo;s Elementary, My Dear Watson</a>
<li><a href="semantics.html">What Does It All Mean?</a>
<li><a href="canvas.html">Let&rsquo;s Call It a Draw(ing Surface)</a>
<li><a href="video.html">Video in a Flash (Without That Other Thing)</a>
<li><a href="geolocation.html">You Are Here (And So Is Everybody Else)</a>
<li><a href="storage.html">A Place To Put Your Stuff</a>
<li><a href="offline.html">Let&rsquo;s Take This Offline</a>
<li><a href="forms.html">A Form of Madness</a>
<li><a href="extensibility.html">&ldquo;Distributed,&rdquo; &ldquo;Extensibility,&rdquo; And Other Fancy Words</a>
<li><a href="history.html">Manipulating History for Fun <i>&amp;</i> Profit</a>
<li class="app"><a href="everything.html">The All-In-One Almost-Alphabetical Guide to Detecting Everything</a>
<li class="app"><a href="peeks-pokes-and-pointers.html"><abbr>HTML5</abbr> Peeks, Pokes and Pointers</a>
</ol>
<!-- /toc -->

<p class="a rotatedFloralHeartBullet">

<p class="c">&ldquo;If you&rsquo;re good at something, never do it for free.&rdquo; <span class="u">&mdash;</span><cite>The Joker</cite><br>(but that doesn&rsquo;t mean you should keep it to yourself)

<p class="c">Copyright MMIX&ndash;MMXI <a href="about.html">Mark Pilgrim</a>

<form action="http://www.google.com/cse"><div><input type="hidden" name="cx" value="017884302975346027366:bgclqh8nvse"><input type="hidden" name="ie" value="UTF-8"><input type="search" name="q" size="25" placeholder="powered by Google&trade;">&nbsp;<input type="submit" name="sa" value="Search"></div></form>
<script src="j/jquery.js"></script>
<script src="j/dih5.js"></script>
<script>
$(function() {
  $("ol").css("list-style", "none");
  $("li").each(function(i) {
    var num = i;
    if ($(this).hasClass("app")) {
      num = String.fromCharCode(53+num);
    }
    $(this).wrapInner('<span class="title"></span>').append('<span class="number">'+num+'</span>').css("background", "#fff url(i/dot.png) repeat-x 0 0.8em");
  });
});
window._gaq=[['_setAccount','UA-26147692-1'],['_setDomainName', 'diveintohtml5.info'],['_setAllowHash', false],['_trackPageview'],['_trackPageLoadTime']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
#+END_SRC
*** 3.3 根元素 
*** 3.4 <head>元素 
*** 3.4.1 字符编码 
*** 3.4.2 朋友和（链接）关系 
*** 3.5 HTML5中新增的语义元素 
**** <article>>    定义文档内的文章
**** <aside>      定义页面内容之外的内容
**** <bdi>        定义与其他文本不同的文本方向
**** <details>    定义用户可查看或隐藏的额外细节
**** <dialog>     定义对话框或窗口
**** <figcaption> 定义 <figure> 元素的标题
**** <figure>     定义自包含内容，比如图示、图表、照片、代码清单
**** <footer>     定义文档或节的页脚
**** <header>     定义文档或节的页眉
**** <main>       定义文档的主内容                        
**** <mark>       定义重要或强调的内容
**** <menuitem>   定义用户能够从弹出菜单调用的命令/菜单项目
**** <meter>      定义已知范围（尺度）内的标量测量
**** <nav>        定义文档内的导航链接
**** <progress>   定义任务进度
**** <rp>         定义在不支持 ruby 注释的浏览器中显示什么
**** <rt>         定义关于字符的解释/发音（用于东亚字体）
**** <ruby>       定义 ruby 注释（用于东亚字体）
**** <section>    定义文档中的节
**** <summary>    定义 <details> 元素的可见标题 
**** <time>       定义日期/时间。
**** <wbr>        定义可能的折行（line-break）
***** <frame>      框架
****** <p>
******* <h1>
******* <!--> 
******* 格式化<b><big><em><i><code><kbd><ins>
******* <a>
******* <img>
******* <table>!!!少用
******* <ul><ol>

*** 3.6 题外话：浏览器如何处理未知元素 
浏览器有支持清单列表 nsElementTable.cpp 

IE 问题 是 对于不能识别的 元素不应用样式,解决方法是 用js;如 <scritp>document.createElement("unknow");</script>
unknow{display:block;border:f1px solid red}
多个解决方法
var e=("abbr,article,aside,audio,...").split(',');
for(var i=0;i<e.length;i++){document.createElement(e[i]);
或直接使用开源版本 
<!--[if lt IE 9]
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
记得放在头部欧!!!
*** 3.7 页头 
<div> 元素没任何语义,so 使用
<header>
</header>
这里的问题是 <header>中的标题怎么弄
#+BEGIN_SRC html
<header>
  <hgroup>
    <h1>MY weblog</h1>
    <h2>副标题 主要写一些感兴趣的东西,欢迎拍砖</h2>
  </hgroup>
#+END_SRC
测试 https://gsnedders.html5.org/outliner/
*** 3.8 文章 
可以用
<article> 而不是无语义的<div> 而对于 大纲 h1-6的算法已经改了,可以有多个h1
#+BEGIN_SRC html
<article>
  <header>
    <p class="post-date">october 22,2009</p>
    <h1>
      <a href="#"
         rel="bookmark"
         title="link to this post">
         Tralel day
      </a>
     </h1>
   </header>
  ......
</article>
#+END_SRC
*** 3.9 日期和时间 
啊啊啊 ,上面的 <p>也要改改了
<time datetime="2009-10-22" pubdate>October 22, 2009</time>
机器可识别的时间戳,datetime 格式要正确
人可识别的文本内容
可选的pubdate 如果在 <article>中,指此article的发布时间,不是,指整个文档的发布时间
*** 3.10 导航 
原始的
#+BEGIN_SRC html
<div id="nav">
 <ul>
  <li><a>home</a></li>
  <li><a>blog</a></li>
  ...
 </ul>
</div>
#+END_SRC
html5
#+BEGIN_SRC html
<nav>
 <ul>
  <li><a>home</a></li>
  <li><a>blog</a></li>
  ...
 </ul>
</nav>
#+END_SRC
*** 3.11 页脚 
<footer></footer>
*** 3.12 扩展阅读 
*** 第4章 Canvas绘图 
*** 4.1 引言 
*** 4.2 简单的图形 
每个canvas 都有一个上下文环境
 var b_context=canvasobject.getContext("2d");
有了2d上下文,就可以开始绘制了2d图形了
b.context.fillRect(50,25,150,100);

:fillStyle 可以设置CSS颜色,默认黑色
:fileRect(x,y,width,height) 矩形
:strokeStyle 和fillStyle 一样,可以设置CSS颜色,图案或颜色渐变
:strokeRect(x,y,width,height)只绘制矩形边缘
:clearRect(x,y,width,height)清除指定矩形区域的像素
*** 4.3 Canvas坐标系 
坐标(0,0)位于canvas左上角
*** 4.4 路径 
moveTo(x,y)把铅笔移动到指定点并作为线条的开始
lineTo(x,y)绘制线条到指定的结束点

*** 4.5 文本 
*** 4.6 颜色渐变 
*** 4.7 图片 
*** 4.8 IE怎么办？ 
*** 4.9 一个完整的例子 
*** 4.10 扩展阅读 
*** 第5章 网络上的视频 
*** 5.1 前言 
*** 5.2 视频容器 
*** 5.3 视频编解码器 
*** 5.3.1 H.264 
*** 5.3.2 Theora 
*** 5.3.3 VP8 
*** 5.4 音频编解码器 
*** 5.4.1 MPEG-1 音频层 3 
*** 5.4.2 高级音频编码 
*** 5.4.3 Vorbis 
*** 5.5 在网页中怎么工作 
*** 5.6 H.264视频的授权问题 
*** 5.7 使用Firefogg编码Ogg视频 
*** 5.8 使用ffmpegtheora批量编码Ogg视频 
*** 5.9 使用HandBrake编码H.264视频 
*** 5.10 使用HandBrake批量编码H.264视频 
*** 5.11 使用ffmpeg编码WebM视频 
*** 5.12 最后，标记 
*** 5.12.1 MIME类型很重要 
*** 5.13 IE怎么办？
*** 5.14 完整的例子
*** 5.14 扩展阅读 
*** 第6章 地理位置 
*** 6.1 引言 
*** 6.2 地理位置API 
*** 6.3 代码展示 
*** 6.4 容错处理 
*** 6.5 方案！我要方案！ 
*** 6.6 那IE怎么办？ 
*** 6.7 geo.js来拯救 
*** 6.8 一个完整的例子 
*** 6.9 扩展阅读 
*** 第7章 Web应用本地存储的过去、现在和未来 
*** 7.1 引言 
*** 7.2 HTML5之前的伪本地存储简史 
*** 7.3 HTML5存储介绍 
*** 7.4 使用HTML5存储 
*** 7.4.1 跟踪HTML5存储区的改动 
*** 7.4.2 现有浏览器的局限性 
*** 7.5 HTML5存储实践 
*** 7.6 超越键值对的存储形式 
*** 7.7 扩展阅读 
*** 第8章 离线Web应用 
*** 8.1 引言 
*** 8.2 缓存清单 
*** 8.2.1 “网络”段 
*** 8.2.2 “默认”部分 
*** 8.3 事件流 
*** 8.4 调试的艺术——杀了我！现在就杀了我！ 
*** 8.5 让我们来构建一个离线Web应用！ 
*** 8.6 扩展阅读 
*** 第9章 疯狂的表单 
*** 9.1 引言 
*** 9.2 占位文本 
*** 9.3 自动聚焦 
*** 9.4 Email地址 
*** 9.5 Web地址 
*** 9.6 数字类型输入框：数字选择器 
*** 9.7 数字类型输入框：滑块 
*** 9.8 日期选择器 
*** 9.9 搜索框 
*** 9.10 颜色选择器 
*** 9.11 还有一点…… 
*** 9.12 扩展阅读 
*** 第10章 “分布式”、“可扩展性”及其他华丽词藻 
*** 10.1 引言 
*** 10.2 什么是微数据？ 
*** 10.3 微数据的数据模型 
*** 10.4 标注“人” 
*** 10.4.1 Google Rich Snippets介绍 
*** 10.5 标注“组织” 
*** 10.6 标注“事件” 
*** 10.6.1 Google Rich Snippets的回归 
*** 10.7 标注“点评” 
*** 10.8 扩展阅读 
*** 

附录A 全方位特性检测指南 
元素列表 

简单对Web请求响应如何处理进行的整理，难免有理解不到位，理解有偏差的地方，如有理解有误的地方，希望大牛批评指正。

1.Web开发的定义
首先看看微软对Web开发的定义:
Web开发是一个指代网页或网站编写过程的广义术语。网页使用 HTML、CSS 和 JavaScript编写。这些页面可能是类似于文档的简单文本和图形。页面也可以是交互式的，或显示变化的信息。编写交互式服务器页面略微复杂一些，但却可以实现更丰富的网站。如今的大多数页面都是交互式的，并提供了购物车、动态可视化甚至复杂的社交网络等现代在线服务。

通俗的说,Web开发就是我们说的做网站.它分为网页部分和逻辑部分也就是我们说的前台页面展示与后台业务逻辑处理。前台负责与用户的交互显示数据，用到HTML标签布局页面,CSS样式渲染页面,JavaScript脚本(或AJAX、JQuery、Extjs)编写动态交互性强的页面；后台编写处理一些复杂业务逻辑的程序.可以用C#,JAVA,PHP等语言。

2.Web请求响应简单理解
客户端浏览器对服务器端进行一次请求的演示图：
[[../image/webserver.jpg]]

<1>.客户端发送请求。客户端浏览器向服务器发送请求URL；
<2>.服务器接收请求。服务器接收到该浏览器发送的请求；
<3>.服务器生成HTML。服务器解析请求的URL，根据URL确定请求的目标资源文件；
　　 这个资源文件通常是一个动态页面（如ASP，PHP，JSP，ASPX等文件）的网络地址（MVC结构的程序例外）。Web服务器根据动态页面文件的内容和URL中的参数，调用相应的资源（数据库数据或图片文件等等）组织数据，生成HTML页面。
<4>.服务端响应请求。生成HTML文档以后，服务器响应浏览器的请求，将生成的HTML文档发送给客户端浏览器；
<5>.客户端接收响应。浏览器接收服务端发出的请求得来HTML文档；
<6>.客户端解析HTML。浏览器对HTML文档进行解析，并加载相关的资源文件（JS，CSS，多媒体资源，内嵌网页）等，(在这里浏览器解悉完HTML文档以后，就会进行呈现，但同时也会向服务器发送请求来请求其它相关的资源文件)
<7>.服务器发送资源文件。服务器接到浏览器对资源文件的请求，将相应的资源文件响应给客户端浏览器；
<8>.客户端加载资源文件。客户端浏览器将接收服务器发送的资源文件，整理并呈现到页面中；
<9>.客户端从上到下加载。在进行页面呈现的时候，浏览器会从上到下执行HTML文档，当遇到相应的页面脚本的时候，会对脚本进行分析，并解释执行相应的脚本代码。

在第6步以后，我们就可以看到一部分页面内容了，不过可能是纯文本内容，没有样式，没有图片或其它资源。待到浏览器请求得到某资源的时候就会进行组织呈现，直到整个页面所有资源加载完毕,显示完成，请求响应完毕。

3.客户端解析HTML
<1>.解析HTML结构；
<2>.加载外部脚本和样式表文件；
<3>.解析并执行脚本代码；
<4>.构造HTML DOM模型；
<5>.加载图片等外部文件。

加载顺序实例：
复制代码
复制代码

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
<title>Title</title>
<style type="text/css">
body
{
font-sie: 12px;
}
</style>
<link href="style.css" rel="stylesheet" type="text/css" media="all" />
<script src="js.js" type="text/javascript"></script>
</head>
<body>
<div>
<script type="text/javascript">
function f1() { }
</script>
<img src="1.gif" />
</div>
<script type="text/javascript">
function f2() { }
</script>
</body>
</html>

复制代码
复制代码

html → head → title → #text(网页标题) → style → 加载样式 → 解析样式 → link → 加载外部样式表文件 → 解析外部样式表 → script → 加载外部脚本文件 → 解析外部脚本文件 → 执行外部脚本 → body → div → script → 加载脚本 → 解析脚本 → 执行脚本 → img → script → 加载脚本 → 解析脚本 → 执行脚本 → 加载外部图像文件 → 页面初始化完毕

4.onload和ready的差异
这里需要注意的是onload和ready的差异：
一是ready，表示DOM文档树已经加载解析解析完成（不包含图片等非文字媒体文件）；
二是onload，指页面上所有的资源(包含图片等文件在内的所有元素)都加载完毕。

说ready比onload快最显著的是比如一个页面上有一个很大的图片，加载要好久，onload只有在图片加载完成之后执行，而ready不必等图片加载完成。
这种差异与window.onload和$(document).ready()的区别也是一致的吧。
* javascript
# javascript 需要写在html中
# 或者 在 head 引入
# 但最好的做法是把<script>.标签放到 HTML文档的最后，</body>标签之前: 
# web 浏览器中有JavaScript解释器
数组    
var light=array(3);
对象    
var lennon=Object();
lennon.name="john"
lennon.year=1999 
简洁语法
var lennon={name:"john",year:1999};
2.4 条件语句    
2.4.1 比较操作符    
2.4.2 逻辑操作符    
2.5 循环语句    
2.5.1 while循环    
2.5.2 for循环    
2.6 函数    
2.7 对象    
2.7.1 内建对象    
2.7.2 宿主对象    
2.8 小结    
第3章 DOM    
3.1 文档：DOM中的“D”    
3.2 对象：DOM中的“O”    
3.3 模型：DOM中的“M”    
3.4 节点    
3.4.1 元素节点    
3.4.2 文本节点    
3.4.3 属性节点    
3.4.4 CSS    
3.4.5 获取元素    
getElementById()
getElementsByTagName(tagname)
getElementsByClassName(classname)
3.4.6 盘点知识点    
3.5 获取和设置属性    
3.5.1 getAttribute    
3.5.2 setAttribute    
3.6 小结    
第4章 案例研究：JavaScript图片库    
4.1 标记    
4.2 JavaScript    
4.2.1 非DOM解决方案    
4.2.2 最终的函数代码清单    
4.3 应用这个JavaScript函数    
onmouseover 
onmouseout
onclick
4.4 对这个函数进行扩展    
this 关键字
onclick=showPic(this)
window.onload=functionname();

4.4.1 childNodes属性    
4.4.2 nodeType属性    
4.4.3 在标记里增加一段描述    
4.4.4 用JavaScript改变这段描述    
4.4.5 nodeValue属性    
4.4.6 firstChild和lastChild属性    
4.4.7 利用nodeValue属性刷新这段描述    
4.5 小结    
第5章 最佳实践    
5.1 过去的错误    
5.1.1 不要怪罪JavaScript    
5.1.2 Flash的遭遇    
5.1.3 质疑一切    
5.2 平稳退化    
5.2.1 “javascript:”伪协议    
5.2.3 谁关心这个    
5.3 向CSS学习    
5.4 分离JavaScript    
5.5.1 对象检测    
5.5.2 浏览器嗅探技术    
5.6 性能考虑    
5.6.1 尽量少访问DOM和尽量减少标记    
5.6.2 合并和放置脚本    
5.6.3 压缩脚本    
5.7 小结    
第6章 案例研究：图片库改进版    
6.2 它支持平稳退化吗    
6.3 它的JavaScript与HTML标记是分离的吗    
6.3.1 添加事件处理函数    
6.3.2 共享onload事件    
6.4 不要做太多的假设    
6.5 优化    
6.6 键盘访问    
6.7 把JavaScript与CSS结合起来    
6.8 DOM Core和HTML-DOM    
6.9 小结    
第7章 动态创建标记    
7.1 一些传统方法    
7.1.1 document.write    
7.1.2 innerHTML属性    
7.2 DOM方法    
7.2.1 createElement方法    
7.2.2 appendChild方法    
7.2.3 createTextNode方法    
7.2.4 一个更复杂的组合    
7.3 重回图片库    
7.3.1 在已有元素前插入一个新元素    
7.3.2 在现有方法后插入一个新元素    
7.3.3 图片库二次改进版    
7.4 Ajax    
7.4.1 XMLHttpRequest对象    
7.4.2 渐进增强与Ajax    
7.4.3 Hijax    
7.5 小结    
第8章 充实文档的内容    
8.1 不应该做什么    
8.2 把“不可见”变成“可见”    
8.3 内容    
8.3.1 选用HTML、XHTML还是HTML5    
8.3.2 CSS    
8.3.3 JavaScript    
8.4 显示“缩略语列表”    
8.4.1 编写displayAbbreviations函数    
8.4.2 创建标记    
8.4.3 一个浏览器“地雷”    
8.5 显示“文献来源链接表”   
*** jQuery 选择器
 tt
 时时
j  Query 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 
 ##
$  ("#myELement")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 
$  ("div")           选择所有的div标签元素，返回div元素数组 
$##(".myClass")      选择使用myClass类的css的所有元素 
$**("*")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 
   
层  叠选择器： 
$  ("form input")         选择所有的form元素中的input元素 
$  ("#main > *")          选择id值为main的所有的子元素 
$  ("label + input")     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 
$  ("#prev ~ div")       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 
   
基  本过滤选择器： 
$  ("tr:first")               选择所有tr元素的第一个 
$  ("tr:last")                选择所有tr元素的最后一个 
$  ("input:not(:checked) + span")   
   
过  滤掉：checked的选择器的所有的input元素 
   
$  ("tr:even")               选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） 
   
$  ("tr:odd")                选择所有的tr元素的第1，3，5... ...个元素 
$  ("td:eq(2)")             选择所有的td元素中序号为2的那个td元素 
$  ("td:gt(4)")             选择td元素中序号大于4的所有td元素 
$  ("td:ll(4)")              选择td元素中序号小于4的所有的td元素 
$  (":header") 
$  ("div:animated") 
内  容过滤选择器： 
   
$  ("div:contains('John')") 选择所有div中含有John文本的元素 
$  ("td:empty")           选择所有的为空（也不包括文本节点）的td元素的数组 
$  ("div:has(p)")        选择所有含有p标签的div元素 
$  ("td:parent")          选择所有的以td为父节点的元素数组 
可**视化过滤选择器： 
 **
$**("div:hidden")        选择所有的被hidden的div元素 
$**("div:visible")        选择所有的可视化的div元素 
属  性过滤选择器： 
   
$  ("div[id]")              选择所有含有id属性的div元素 
$  ("input[name='newsletter']")    选择所有的name属性等于'newsletter'的input元素 
   
$  ("input[name!='newsletter']") 选择所有的name属性不等于'newsletter'的input元素 
   
$  ("input[name^='news']")         选择所有的name属性以'news'开头的input元素 
$  ("input[name$='news']")         选择所有的name属性以'news'结尾的input元素 
$**("input[name*='man']")          选择所有的name属性包含'news'的input元素 
 **
$**("input[id][name$='man']")    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 
 **
子**元素过滤选择器： 
 ss
$ee("ul li:nth-child(2)"),$("ul li:nth-child(odd)"),$("ul li:nth-child(3n + 1)") 
 qq
$vv("div span:first-child")          返回所有的div元素的第一个子节点的数组 
$cc("div span:last-child")           返回所有的div元素的最后一个节点的数组 
$ll("div button:only-child")       返回所有的div中只有唯一一个子节点的所有子节点的数组 
 LL
表hh单元素选择器： 
 HH
$aa(":input")                  选择所有的表单输入元素，包括input, textarea, select 和 button 
 AA
$ii(":text")                     选择所有的text input元素 
$II(":password")           选择所有的password input元素 
$上上(":radio")                   选择所有的radio input元素 
$注注(":checkbox")            选择所有的checkbox input元素 
$**(":submit")               选择所有的submit input元素 
$##(":image")                 选择所有的image input元素 
j  Query 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 
   
$##("#myELement")    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素 
$**("div")           选择所有的div标签元素，返回div元素数组 
$对对(".myClass")      选择使用myClass类的css的所有元素 
$##("*")             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 
 则则
层[[叠选择器： 
$  ("form input")         选择所有的form元素中的input元素 
$**("#main > *")          选择id值为main的所有的子元素 
$##("label + input")     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素 
$##("#prev ~ div")       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 
   
基  本过滤选择器： 
$  ("tr:first")               选择所有tr元素的第一个 
$##("tr:last")                选择所有tr元素的最后一个 
$  ("input:not(:checked) + span")   
 **
过滤掉：checked的选择器的所有的input元素 
 
$("tr:even")               选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） 
 
$("tr:odd")                选择所有的tr元素的第1，3，5... ...个元素 
$("td:eq(2)")             选择所有的td元素中序号为2的那个td元素 
$("td:gt(4)")             选择td元素中序号大于4的所有td元素 
$("td:ll(4)")              选择td元素中序号小于4的所有的td元素 
$(":header") 
$("div:animated") 
内容过滤选择器： 
 
$("div:contains('John')") 选择所有div中含有John文本的元素 
$("td:empty")           选择所有的为空（也不包括文本节点）的td元素的数组 
$("div:has(p)")        选择所有含有p标签的div元素 
$("td:parent")          选择所有的以td为父节点的元素数组 
可视化过滤选择器： 
 
$("div:hidden")        选择所有的被hidden的div元素 
$("div:visible")        选择所有的可视化的div元素 
属性过滤选择器： 
 
$("div[id]")              选择所有含有id属性的div元素 
$("input[name='newsletter']")    选择所有的name属性等于'newsletter'的input元素 
 
$("input[name!='newsletter']") 选择所有的name属性不等于'newsletter'的input元素 
 
$("input[name^='news']")         选择所有的name属性以'news'开头的input元素 
$("input[name$='news']")         选择所有的name属性以'news'结尾的input元素 
$("input[name*='man']")          选择所有的name属性包含'news'的input元素 
 
$("input[id][name$='man']")    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 
 
子元素过滤选择器： 
 
$("ul li:nth-child(2)"),$("ul li:nth-child(odd)"),$("ul li:nth-child(3n + 1)") 
 
$("div span:first-child")          返回所有的div元素的第一个子节点的数组 
$("div span:last-child")           返回所有的div元素的最后一个节点的数组 
$("div button:only-child")       返回所有的div中只有唯一一个子节点的所有子节点的数组 
 
表单元素选择器： 
 
$(":input")                  选择所有的表单输入元素，包括input, textarea, select 和 button 
 
$(":text")                     选择所有的text input元素 
$(":password")           选择所有的password input元素 
$(":radio")                   选择所有的radio input元素 
$(":checkbox")            选择所有的checkbox input元素 
$(":submit")               选择所有的submit input元素 
$(":image")                 选择所有的image input元素 
$(":reset")                   选择所有的reset input元素 
$(":button")                选择所有的button input元素 
$(":file")                     选择所有的file input元素 
$(":hidden")               选择所有类型为hidden的input元素或表单的隐藏域 
 
表单元素过滤选择器： 
 
$(":enabled")             选择所有的可操作的表单元素 
$(":disabled")            选择所有的不可操作的表单元素 
$(":checked")            选择所有的被checked的表单元素 
$("select option:selected") 选择所有的select 的子元素中被selected的元素 
 
  
 
选取一个 name 为”S_03_22″的input text框的上一个td的text值
$(”input[@ name =S_03_22]“).parent().prev().text() 
 
名字以”S_”开始，并且不是以”_R”结尾的
$(”input[@ name ^='S_']“).not(”[@ name $='_R']“) 
 
一个名为 radio_01的radio所选的值
$(”input[@ name =radio_01][@checked]“).val(); 
 
  
 
  
 
$("A B") 查找A元素下面的所有子节点，包括非直接子节点
$("A>B") 查找A元素下面的直接子节点
$("A+B") 查找A元素后面的兄弟节点，包括非直接子节点
$("A~B") 查找A元素后面的兄弟节点，不包括非直接子节点 
 
1. $("A B") 查找A元素下面的所有子节点，包括非直接子节点 
 
例子：找到表单中所有的 input 元素 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("form input") 
结果: 
 
[ <input name="name" />, <input name="newsletter" /> ] 
 
2. $("A>B") 查找A元素下面的直接子节点 
例子：匹配表单中所有的子级input元素。 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("form > input") 
结果: 
 
[ <input name="name" /> ] 
 
3. $("A+B") 查找A元素后面的兄弟节点，包括非直接子节点 
例子：匹配所有跟在 label 后面的 input 元素 
 
HTML 代码: 
 
<form>
<label>Name:</label>
<input name="name" />
<fieldset>
      <label>Newsletter:</label>
      <input name="newsletter" />
</fieldset>
</form>
<input name="none" /> 
jQuery 代码: 
 
$("label + input") 
结果: 
* javscript
javascript的self和this使用小结
revert 
一、self
这个非常简单。我们知道，打开任何一个网页，浏览器会首先创建一个窗口，这个窗口就是一个window对象，也是js运行所依附的全局环境对象和全局作用域对象。self 指窗口本身，它返回的对象跟window对象是一模一样的。也正因为如此，window对象的常用方法和函数都可以用self代替window。举个例子，常见的写法如“self.close();”，把它放在<a>标记中：“<a href="javascript:self.close();">关闭窗口</a>”，单击“关闭窗口”链接，当前页面关闭。
二、this关键字
在讲this之前，看下面的一段代码：


<body>
<script type="text/javascript">
function thisTest()
  {
      this.textValue = 'this的dom测试';
      this.element= document.createElement('span');
      this.element.innerHTML = this.textValue;
      this.element.style.color = "blue";
      this.element.style.cursor = "pointer";
      this.element.attachEvent('onclick', this.ToString);
  }
   
  thisTest.prototype.RenderDom = function()
  {
      document.body.appendChild(this.element);
  }     

  thisTest.prototype.ToString = function()
  {
      alert("单击我："+this.textValue);
  };
  var test= new thisTest();
  test.RenderDom(); 
  //test.ToString();
</script>
</body>

本来的目的是想在body中添加一个span元素，对于这个span元素，制定了它的字体颜色，悬浮在它上面的鼠标样式和单击触发事件。问题就出现在它的单击事件上（弹出"单击我:undefined"）。也许有人会说你丫傻呀，写这么多sb代码还不就是为了实现下面这个东东吗？
<span style='cursor:pointer;color:blue;' onclick="alert(this.innerHTML)">this的dom测试</span>

你看多简单直观，而且还不容易出错？！kao，我晕。我正要讲的是您正在使用的this.innerHTML中的this呀。
1、this到底指什么？
我们熟悉的c#有this关键字，它的主要作用就是指代当前对象实例（参数传递和索引器都要用到this）。在javascript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）。
2、常见使用方式
（1）、直接在dom元素中使用
<input id="btnTest" type="button" value="提交" onclick="alert(this.value))" />

分析：对于dom元素的一个onclick（或其他如onblur等）属性，它为所属的html元素所拥有，直接在它触发的函数里写this，this应该指向该html元素。
（2）、给dom元素注册js函数
a、不正确的方式
复制代码
<script type="text/javascript">
  function thisTest(){
  alert(this.value); // 弹出undefined, this在这里指向??
}
</script>

<input id="btnTest" type="button" value="提交" onclick="thisTest()" />
复制代码

 分析：onclick事件直接调用thisTest函数，程序就会弹出undefined。因为thisTest函数是在window对象中定义的，
所以thisTest的拥有者（作用域）是window，thisTest的this也是window。而window是没有value属性的，所以就报错了。
b、正确的方式

<input id="btnTest" type="button" value="提交" />

<script type="text/javascript">
  function thisTest(){
  alert(this.value); 
}
document.getElementById("btnTest").onclick=thisTest; //给button的onclick事件注册一个函数
</script>

分析：在前面的示例中，thisTest函数定义在全局作用域（这里就是window对象），所以this指代的是当前的window对象。而通过document.getElementById("btnTest").onclick=thisTest;这样的形式，其实是将btnTest的onclick属性设置为thisTest函数的一个副本，在btnTest的onclick属性的函数作用域内，this归btnTest所有，this也就指向了btnTest。其实如果有多个dom元素要注册该事件，我们可以利用不同的dom元素id，用下面的方式实现：
document.getElementById("domID").onclick=thisTest; //给button的onclick事件注册一个函数。
因为多个不同的HTML元素虽然创建了不同的函数副本，但每个副本的拥有者都是相对应的HTML元素，各自的this也都指向它们的拥有者，不会造成混乱。
为了验证上述说法，我们改进一下代码，让button直接弹出它们对应的触发函数：

<input id="btnTest1" type="button" value="提交1" onclick="thisTest()" />
<input id="btnTest2" type="button" value="提交2" />

<script type="text/javascript">
function thisTest(){
this.value="提交中";
}
var btn=document.getElementById("btnTest1");
alert(btn.onclick); //第一个按钮函数

var btnOther=document.getElementById("btnTest2");
btnOther.onclick=thisTest;
alert(btnOther.onclick); //第二个按钮函数
</script>

其弹出的结果是：
复制代码
//第一个按钮
function onclick(){
  thisTest()
}
 
//第二个按钮
function thisTest(){
  this.value="提交中";
}
复制代码

从上面的结果你一定理解的更透彻了。
By the way，每新建一个函数的副本，程序就会为这个函数副本分配一定的内存。而实际应用中，大多数函数并不一定会被调用，于是这部分内存就被白白浪费了。所以我们通常都这么写：

<input id="btnTest1" type="button" value="提交1" onclick="thisTest(this)" />
<input id="btnTest2" type="button" value="提交2" onclick="thisTest(this)" />
<input id="btnTest3" type="button" value="提交3" onclick="thisTest(this)" />
<input id="btnTest4" type="button" value="提交4" onclick="thisTest(this)" />

<script type="text/javascript">
  function thisTest(obj){
  alert(obj.value); 
}
</script>

这是因为我们使用了函数引用的方式，程序就只会给函数的本体分配内存，而引用只分配指针。这样写一个函数，调用的地方给它分配一个（指针）引用，这样效率就高很多。当然，如果你觉得这样注册事件不能兼容多种浏览器，可以写下面的注册事件的通用脚本：

//js事件 添加 EventUtil.addEvent(dom元素,事件名称,事件触发的函数名) 移除EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)
var EventUtil = new eventManager();

//js事件通用管理器 dom元素 添加或者移除事件
function eventManager() {
    //添加事件
    //oDomElement:dom元素,如按钮,文本,document等; ****** oEventType:事件名称(如:click,如果是ie浏览器,自动将click转换为onclick);****** oFunc:事件触发的函数名
    this.addEvent = function(oDomElement, oEventType, oFunc) {
        //ie
        if (oDomElement.attachEvent) {
            oDomElement.attachEvent("on" + oEventType, oFunc);
        }
        //ff,opera,safari等
        else if (oDomElement.addEventListener) {
            oDomElement.addEventListener(oEventType, oFunc, false);
        }
        //其他
        else {
            oDomElement["on" + oEventType] = oFunc;
        }
    }

    this.removeEvent = function(oDomElement, oEventType, oFunc) {
        //ie
        if (oDomElement.detachEvent) {
            oDomElement.detachEvent("on" + oEventType, oFunc);
        }
        //ff,opera,safari等
        else if (oDomElement.removeEventListener) {
            oDomElement.removeEventListener(oEventType, oFunc, false);
        }
        //其他
        else {
            oDomElement["on" + oEventType] = null;
        }
    }
}

 正像注释写的那样，要注册dom元素事件，用EventUtil.addEvent(dom元素,事件名称,事件触发的函数名)即可， 移除时可以这样写：EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)。这是题外话，不说了。
(3)、类定义中使用this关键字
这个其实再常见不过，看示例：

function thisTest()
  {
      var tmpName = 'jeff wong';
      this.userName= 'jeff wong';
  }

var test= new thisTest();
alert(test.userName==test.tmpName);//false
alert(test.userName); //jeff wong
alert(test.tmpName); //undefined

 分析一下结果，其实这里的this和c#里的是类似的。
（4）、为脚本对象添加原形方法
理解这里的前提是你必须了解js里的原型概念（说道这里，kao，我还真的需要面壁一下）：js中对象的prototype属性，是用来返回对象类型原型的引用的。所有js内部对象都有只读的prototype属性，可以向其原型中动态添加功能(属性和方法)，
但该对象不能被赋予不同的原型。但是对于用户定义的对象可以被赋给新的原型。看个简单的示例：

//js的内部对象String,向其原型中动态添加功能(属性和方法)
//去掉字符串两端的空白字符
String.prototype.Trim = function() {
    return this.replace(/(^\s+)|(\s+$)/g, "");
}

function thisTest()
  {
      var tmpName = 'jeff wong';
      this.userName= '      jeff wong  ';
  }
//给用户定义的对象添加原型方法
thisTest.prototype.ToString = function()
  {
      alert(this.userName); //jeff wong(*有空格*)
      alert(this.userName.Trim()); //jeff wong (*无空格*)
      //alert(tmpName); //脚本错误,tmpName未定义
  }

var test= new thisTest();
test.ToString(); //调用原型的ToString()

function myTest(){
  this.userName= '  test ';
}
var test1=new myTest();
//test1.ToString(); //这里暂时不支持调用ToString()方法

//用户定义的对象被赋给新的原型
myTest.prototype = new thisTest();
test1.ToString(); //调用原型的ToString()

测试结果显示，这里的this指代的是被添加原形（方法或属性）的类的实例，和（3）中的定义基本相似。
（5）、在函数的内部函数中使用this关键字
这个你要是理解作用域和闭包，问题就迎刃而解。看最典型的示例：

function thisTest()
  {
      this.userName= 'outer userName';
      function innerThisTest(){
        var userName="inner userName";
        alert(userName); //inner userName
        alert(this.userName); //outer userName
      }
     return innerThisTest;
  }

thisTest()();

分析：thisTest()调用内部的innerThisTest函数，形成一个闭包。innerThisTest执行时，第一次弹出innerUserName，是因为innerThisTest函数作用域内有一个变量叫userName，所以直接弹出当前作用域下变量的指定值；第二次弹出outer  userName是因为innerThisTest作用域内没有userName属性（示例中的this.userName）,所以它向上一级作用域中找userName属性，这次在thisTest中找到（示例中的this.userName= 'outer userName';），所以弹出对应值。
（6）通过Function的call和apply函数指定特定的this
这个指定来指定去，this就有可能造成“你中有我，我中有你”的局面，不想把自己弄晕了的话，了解一下就可以了。改变this指定对象对于代码维护也是一件很不好的事情。贴出旧文中的示例代码结束吧：

function myFuncOne() {
    this.p = "myFuncOne-";
    this.A = function(arg) {
        alert(this.p + arg);
* python
** Python 环境变量
: PYTHONPATH	PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。
: PYTHONSTARTUP 	Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此文件中变量指定的执行代码。
: PYTHONCASEOK 	加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写.
: PYTHONHOME 	另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。
** Python 中文编码
 默认编码格式是 ASCII 格式
  # -*- coding: UTF-8 -*- 或者 #coding=utf-8.
** 变量
1. List（列表）list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] list[1:2]
2. 元组 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )!元组不让更新
3. 字典 tinydict = {'name': 'john','code':6734, 'dept': 'sales'} 
冰箱={'苹果':3,'梨子':5,'橘子':3}
** 类型 type
** 算术运算符
 **	幂 - 返回x的y次幂	a**b 为10的20次方， 输出结果 100000000000000000000
 //	取整除 - 返回商的整数部分	9//2 输出结果 4 , 9.0//2.0 输出结果 4.0
** 条件语句
#+BEGIN_SRC python
if 判断条件：
    执行语句……
else：
    执行语句……
#+END_SRC
** 循环语句
*** while循环
#+BEGIN_SRC 
while 判断条件：
    执行语句……
#+END_SRC
*** for 循环
#+BEGIN_SRC python
for iterating_var in sequence:
   statements(s)
#+END_SRC
*** 循环控制
**** break
**** continue
** 帮助
help()  dir()
** pass 语句 空语句 ，替换 为其他语言的占位符 ;
** Python 函数
 #+BEGIN_SRC python
 def functionname( parameters ):
   "函数_文档字符串"
   function_suite
   return [expression]
 #+END_SRC
** Python 模块
*** import 语句 导入模块,一个模块只会执行一次,不管插入多少语句
import module1[, module2[,... moduleN]
*** From…import 语句
: Python的from语句让你从模块中导入一个指定的部分到当前命名空间中
*** globals()和locals()函数
: 根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
*** reload()函数
: 当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
: 因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数
*** Python中的包 相当于c中的头文件
** Python 文件I/O
*** 键盘输入
**** : raw_input函数
: raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：
**** : input函数
: input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回
*** 打开和关闭文件 
**** open 
**** close
**** write
**** read
**** 文件定位
**** 重命名和删除文件
**** remove()方法
*** 目录
**** mkdir()方法 
**** chdir()方法 
**** rmdir()方法 
** Python 异常处理
*** 捕捉异常可以使用try/except语句
#+BEGIN_SRC python
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
#+END_SRC
*** 触发异常
: raise [Exception [, args [, traceback]]]
** Python 面向对象
*** 类
*** 类的继承
*** 类属性与方法
**** 类的私有属性
__private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
类的方法
在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数
**** 类的私有方法
__private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 
** Python CGI编程 引入python cgi库
: CGI程序可以是Python脚本，PERL脚本，SHELL脚本，C或者C++程序等
*** Web服务器支持及配置

在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。

Apache 支持CGI 配置：

设置好CGI目录：

ScriptAlias /cgi-bin/ /var/www/cgi-bin/

所有的HTTP服务器执行CGI程序都保存在一个预先配置的目录。这个目录被称为CGI目录，并按照惯例，它被命名为/var/www/cgi-bin目录。

CGI文件的扩展名为.cgi，python也可以使用.py扩展名。

默认情况下，Linux服务器配置运行的cgi-bin目录中为/var/www。

如果你想指定其他运行CGI脚本的目录，可以修改httpd.conf配置文件，如下所示：

<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options +ExecCGI
   Order allow,deny
   Allow from all
</Directory>

在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件：

AddHandler cgi-script .cgi .pl .py
*** 第一个CGI程序

我们使用Python创建第一个CGI程序，文件名为hello.py，文件位于/var/www/cgi-bin目录中，内容如下：

#!/usr/bin/python
# -*- coding: UTF-8 -*-

print "Content-type:text/html"
print                               # 空行，告诉服务器结束头部
print '<html>'
print '<head>'
print '<meta charset="utf-8">'
print '<title>Hello Word - 我的第一个 CGI 程序！</title>'
print '</head>'
print '<body>'
print '<h2>Hello Word! 我是来自菜鸟教程的第一CGI程序</h2>'
print '</body>'
print '</html>'

文件保存后修改 hello.py，修改文件权限为 755：

chmod 755 hello.py 
*** CGI环境变量
: 所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用：
CONTENT_TYPE	这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。
CONTENT_LENGTH	如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。
HTTP_COOKIE	客户机内的 COOKIE 内容。
HTTP_USER_AGENT	提供包含了版本数或其他专有数据的客户浏览器信息。
PATH_INFO	这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。
QUERY_STRING	如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号'?'分隔。
REMOTE_ADDR	这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。
REMOTE_HOST	这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。
REQUEST_METHOD	提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。
SCRIPT_FILENAME	CGI脚本的完整路径
SCRIPT_NAME	CGI脚本的的名称
SERVER_NAME	这是你的 WEB 服务器的主机名、别名或IP地址。
SERVER_SOFTWARE	这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix)
** python操作mysql数据库 MySQLdb
** Python 网络编程
***  低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。
***  高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。
** Python 多线程
** python GUI编程(Tkinter)
** Python JSON
*** encode 	将 Python 对象编码成 JSON 字符串
*** decode	将已编码的 JSON 字符串解码为 Python 对象
* core python 
**** 2.14　列表解析
**** 2.15　文件和内建函数open（）、file（）
**** 2.16　错误和异常
**** 2.17　函数
**** 2.17.1　如何定义函数
**** 2.17.2　如何调用函数
**** 2.17.3　默认参数
**** 2.18　类
**** 2.19　模块
**** 2.19.1　如何导入模块
**** 2.19.2　如何访问一个模块函数或访问一个模块变量
**** 2.20　实用的函数
**** 2.21　练习
**** 第3章　Python基础
**** 3.1　语句和语法
**** 3.1.1　注释（#）
**** 3.1.2　继续（\）
**** 3.1.3　多个语句构成代码组（:）
**** 3.1.4　代码组由不同的缩进分隔
**** 3.1.5　同一行书写多个语句（;）
**** 3.1.6　模块
**** 3.2　变量赋值
**** 3.2.1　赋值操作符
**** 3.2.2　增量赋值
**** 3.2.3　多重赋值
**** 3.2.4　“多元”赋值
**** 3.3　标识符
**** 3.3.1　合法的Python标识符
**** 3.3.2　关键字
**** 3.3.3　内建
**** 3.3.4　专用下划线标识符
**** 3.4　基本风格指南
**** 3.4.1　模块结构和布局
**** 3.4.2　在主程序中书写测试代码
**** 3.5　内存管理
**** 3.5.1　变量定义
**** 3.5.2　动态类型
**** 3.5.3　内存分配
**** 3.5.4　引用计数
**** 3.5.5　垃圾收集
**** 3.6　第一个Python程序
**** 3.7　相关模块和开发工具
**** 3.8　练习
**** 第4章　Python对象
**** 4.1　Python 对象
**** 4.2　标准类型
**** 4.3　其他内建类型
**** 4.3.1　类型对象和type类型对象
**** 4.3.2　None--Python的Null对象
**** 4.4　内部类型
**** 4.4.1　代码对象
**** 4.4.2　帧对象
**** 4.4.3　跟踪记录对象
**** 4.4.4　切片对象
**** 4.4.5　省略对象
**** 4.4.6　XRange 对象
**** 4.5　标准类型操作符
**** 4.5.1　对象值的比较
**** 4.5.2　对象身份比较
**** 4.5.3　布尔类型
**** 4.6　标准类型内建函数
**** 4.6.1　type（）
**** 4.6.2　cmp（）
**** 4.6.3　str（）和repr（）（及``操作符）
**** 4.6.4　type（）和isinstance（）
**** 4.6.5　Python类型操作符和内建函数总结
**** 4.7　类型工厂函数
**** 4.8　标准类型的分类
**** 4.8.1　存储模型
**** 4.8.2　更新模型
**** 4.8.3　访问模型
**** 4.9　不支持的类型
**** 4.10　练习
**** 第5章　数字
**** 5.1　数字简介
**** 5.1.1　如何创建数值对象并用其赋值（数字对象）
**** 5.1.2　如何更新数字对象
**** 5.1.3　如何删除数字对象
**** 5.2　整型
**** 5.2.1　布尔型
**** 5.2.2　标准整型
**** 5.2.3　长整型
**** 5.2.4　整型和长整型的统一
**** 5.3　双精度浮点型
**** 5.4　复数
**** 5.5　操作符
**** 5.5.1　混合模式操作符
**** 5.5.2　标准类型操作符
**** 5.5.3　算术操作符
**** 5.5.4　*位操作符（只适用于整型）
**** 5.6　内建函数与工厂函数
**** 5.6.1　标准类型函数
**** 5.6.2　数字类型函数
**** 5.6.3　仅用于整型的函数
**** 5.7　其他数字类型
**** 5.7.1　布尔“数”
**** 5.7.2　十进制浮点型
**** 5.8　相关模块
**** 5.9　练习
**** 第6章　序列：字符串、列表和元组
**** 6.1　序列
**** 6.1.1　标准类型操作符
**** 6.1.2　序列类型操作符
**** 6.1.3　内建函数（BIF）
**** 6.2　字符串
**** 6.3　字符串和操作符
**** 6.3.1　标准类型操作符
**** 6.3.2　序列操作符切片（[]和[:]）
**** 6.4　只适用于字符串的操作符
**** 6.4.1　格式化操作符（％）
**** 6.4.2　字符串模板: 更简单的替代品
**** 6.4.3　原始字符串操作符（r/R）
**** 6.4.4　Unicode字符串操作符（u/U）
**** 6.5　内建函数
**** 6.5.1　标准类型函数
**** 6.5.2　序列类型函数
**** 6.5.3　字符串类型函数
**** 6.6　字符串内建函数
**** 6.7　字符串的独特特性
**** 6.7.1　特殊字符串和控制字符
**** 6.7.2　三引号
**** 6.7.3　字符串不变性
**** 6.8　Unicode
**** 6.8.1　术语
**** 6.8.2　什么是Unicode
**** 6.8.3　怎样使用Unicode
**** 6.8.4　Codec是什么
**** 6.8.5　编码解码
**** 6.8.6　把Unicode应用到实际应用中
**** 6.8.7　从现实中得来的教训
**** 6.8.8　Python的Unicode支持
**** 6.9　相关模块
**** 6.10　字符串关键点总结
**** 6.11　列表
**** 6.12　操作符
**** 6.12.1　标准类型操作符
**** 6.12.2　序列类型操作符
**** 6.12.3　列表类型操作符和列表解析
**** 6.13　内建函数
**** 6.13.1　标准类型函数
**** 6.13.2　序列类型函数
**** 6.13.3　列表类型内建函数
**** 6.14　列表类型的内建函数
**** 6.15　列表的特殊特性
**** 6.16　元组
**** 6.17　元组操作符和内建函数
**** 6.17.1　标准类型操作符、序列类型操作符和内建函数
**** 6.17.2　元组类型操作符和内建函数、内建方法
**** 6.18　元组的特殊特性
**** 6.18.1　不可变性给元组带来了什么影响
**** 6.18.2　元组也不是那么“不可变”
**** 6.18.3　默认集合类型
**** 6.18.4　单元素元组
**** 6.18.5　字典的关键字
**** 6.19　相关模块
**** 6.20　*拷贝Python对象、浅拷贝和深拷贝
**** 6.21　序列类型小结
**** 6.22　练习
**** 第7章　映像和集合类型
**** 7.1　映射类型：字典
**** 7.1.1　如何创建字典和给字典赋值
**** 7.1.2　如何访问字典中的值
**** 7.1.3　如何更新字典
**** 7.1.4　如何删除字典元素和字典
**** 7.2　映射类型操作符
**** 7.2.1　标准类型操作符
**** 7.2.2　映射类型操作符
**** 7.3　映射类型的内建函数和工厂函数
**** 7.3.1　标准类型函数[type（）、str（）和cmp（）]
**** 7.3.2　映射类型相关的函数
**** 7.4　映射类型内建方法
**** 7.5　字典的键
**** 7.5.1　不允许一个键对应多个值
**** 7.5.2　键必须是可哈希的
**** 7.6　集合类型
**** 7.6.1　如何创建集合类型和给集合赋值
**** 7.6.2　如何访问集合中的值
**** 7.6.3　如何更新集合
**** 7.6.4　如何删除集合中的成员和集合
**** 7.7　集合类型操作符
**** 7.7.1　标准类型操作符（所有的集合类型）
**** 7.7.2　集合类型操作符（所有的集合类型）
**** 7.7.3　集合类型操作符（仅适用于可变集合）
**** 7.8　内建函数
**** 7.8.1　标准类型函数
**** 7.8.2　集合类型工厂函数
**** 7.9　集合类型内建方法
**** 7.9.1　方法（所有的集合方法）
**** 7.9.2　方法（仅适用于可变集合）
**** 7.9.3　操作符和内建方法比较
**** 7.10　集合类型总结表
**** 7.11　相关模块
**** 7.12　练习
**** 第8章　条件和循环
**** 8.1　if语句
**** 8.1.1　多重条件表达式
**** 8.1.2　单一语句的代码块
**** 8.2　else语句
**** 8.3　elif（即else-if）语句
**** 8.4　条件表达式（即“三元操作符”）
**** 8.5　while语句
**** 8.5.1　一般语法
**** 8.5.2　计数循环
**** 8.5.3　无限循环
**** 8.6　for语句
**** 8.6.1　一般语法
**** 8.6.2　用于序列类型
**** 8.6.3　用于迭代器类型
**** 8.6.4　range（）内建函数
**** 8.6.5　xrange（） 内建函数
**** 8.6.6　与序列相关的内建函数
**** 8.7　break语句
**** 8.8　continue语句
**** 8.9　pass语句
**** 8.10　再谈else语句
**** 8.11　迭代器和iter（）函数
**** 8.11.1　什么是迭代器
**** 8.11.2　为什么要迭代器
**** 8.11.3　如何迭代
**** 8.11.4　使用迭代器
**** 8.11.5　可变对象和迭代器
**** 8.11.6　如何创建迭代器
**** 8.12　列表解析
**** 8.13　生成器表达式
**** 8.14　相关模块
**** 8.15　练习
**** 第9章　文件和输入输出
**** 9.1　文件对象
**** 9.2　文件内建函数（open（）和file（））
**** 9.2.1　工厂函数file（）
**** 9.2.2　通用换行符支持（UNS）
**** 9.3　文件内建方法
**** 9.3.1　输入
**** 9.3.2　输出
**** 9.3.3　文件内移动
**** 9.3.4　文件迭代
**** 9.3.5　其他
**** 9.3.6　文件方法杂项
**** 9.4　文件内建属性
**** 9.5　标准文件
**** 9.6　命令行参数
**** 9.7　文件系统
**** 9.8　文件执行
**** 9.9　永久存储模块
**** 9.9.1　pickle和marshal模块
**** 9.9.2　DBM风格的模块
**** 9.9.3　shelve模块
**** 9.10　相关模块
**** 9.11　练习
**** 第10章　错误和异常
**** 10.1　什么是异常
**** 10.1.1　错误
**** 10.1.2　异常
**** 10.2　Python 中的异常
**** 10.3　检测和处理异常
**** 10.3.1　try-except语句
**** 10.3.2　包装内建函数
**** 10.3.3　带有多个except的try语句
**** 10.3.4　处理多个异常的except语句
**** 10.3.5　捕获所有异常
**** 10.3.6　“异常参数”
**** 10.3.7　在应用使用我们封装的函数
**** 10.3.8　else子句
**** 10.3.9　finally子句
**** 10.3.10　try-finally语句
**** 10.3.11　try-except-else-finally：厨房一锅端
**** 10.4　上下文管理
**** 10.4.1　with语句
**** 10.4.2　*上下文管理协议
**** 10.5　*字符串作为异常
**** 10.6　触发异常
**** 10.7　断言
**** 10.8　标准异常
**** 10.9　*创建异常
**** 10.10　（现在）为什么用异常
**** 10.11　到底为什么要异常
**** 10.12　异常和sys模块
**** 10.13　相关模块
**** 10.14　练习
**** 第11章　函数和函数式编程
**** 11.1　什么是函数？
**** 11.1.1　函数vs过程
**** 11.1.2　返回值与函数类型
**** 11.2　调用函数
**** 11.2.1　函数操作符
**** 11.2.2　关键字参数
**** 11.2.3　默认参数
**** 11.2.4　参数组
**** 11.3　创建函数
**** 11.3.1　def语句
**** 11.3.2　声明与定义比较
**** 11.3.3　前向引用
**** 11.3.4　函数属性
**** 11.3.5　内部/内嵌函数
**** 11.3.6　*函数（与方法）装饰器
**** 11.4　传递函数
**** 11.5　Formal Arguments
**** 11.5.1　位置参数
**** 11.5.2　默认参数
**** 11.6　可变长度的参数
**** 11.6.1　非关键字可变长参数（元组）
**** 11.6.2　关键字变量参数（字典）
**** 11.6.3　调用带有可变长参数对象函数
**** 11.7　函数式编程
**** 11.7.1　匿名函数与lambda
**** 11.7.2　内建函数apply（）、filter（）、map（）、reduce（）
**** 11.7.3　偏函数应用
**** 11.8　变量作用域
**** 11.8.1　全局变量与局部变量
**** 11.8.2　globa语句
**** 11.8.3　作用域的数字
**** 11.8.4　闭包
**** 11.8.5　作用域和lambda
**** 11.8.6　变量作用域和名称空间
**** 11.9　*递归
**** 11.10　生成器
**** 11.10.1　简单的生成器特性
**** 11.10.2　加强的生成器特性
**** 11.11　练习
**** 第12章　模块
**** 12.1　什么是模块
**** 12.2　模块和文件
**** 12.2.1　模块名称空间
**** 12.2.2　搜索路径和路径搜索
**** 12.3　名称空间
**** 12.3.1　名称空间与变量作用域比较
**** 12.3.2　名称查找、确定作用域、覆盖
**** 12.3.3　无限制的名称空间
**** 12.4　导入模块
**** 12.4.1　import语句
**** 12.4.2　from-import语句
**** 12.4.3　多行导入
**** 12.4.4　扩展的import语句（as）
**** 12.5　模块导入的特性
**** 12.5.1　载入时执行模块
**** 12.5.2　导入（import）和加载（load）
**** 12.5.3　导入到当前名称空间的名称
**** 12.5.4　被导入到导入者作用域的名字
**** 12.5.5　关于__future__
**** 12.5.6　警告框架
**** 12.5.7　从ZIP文件中导入模块
**** 12.5.8　“新的”导入钩子
**** 12.6　模块内建函数
**** 12.6.1　__import__（）
**** 12.6.2　globals（）和locals（）
**** 12.6.3　reload（）
**** 12.7　包
**** 12.7.1　目录结构
**** 12.7.2　使用from-import导入包
**** 12.8　模块的其他特性
**** 12.8.1　自动载入的模块
**** 12.8.2　阻止属性导入
**** 12.8.3　不区分大小的导入
**** 12.8.4　源代码编码
**** 12.8.5　导入循环
**** 12.8.6　模块执行
**** 12.9　相关模块
**** 12.10　练习
**** 第13章　面向对象编程
**** 13.1　引言
**** 13.2　面向对象编程
**** 13.2.1　面向对象设计与面向对象编程的关系
**** 13.2.2　现实中的问题
**** 13.2.3　*常用术语
**** 13.3　类
**** 13.3.1　创建类
**** 13.3.2　声明与定义
**** 13.4　类属性
**** 13.4.1　类的数据属性
**** 13.4.2　Methods
**** 13.4.3　决定类的属性
**** 13.4.4　特殊的类属性
**** 13.5　实例
**** 13.5.1　初始化：通过调用类对象来创建实例
**** 13.5.2　__init__（）“构造器”方法
**** 13.5.3　__new__（）“构造器”方法
**** 13.5.4　__del__（）“解构器”方法
**** 13.6　实例属性
**** 13.6.1　“实例化”实例属性（或创建一个更好的构造器）
**** 13.6.2　查看实例属性
**** 13.6.3　特殊的实例属性
**** 13.6.4　建类型属性
**** 13.6.5　实例属性vs类属性
**** 13.7　绑定和方法调用
**** 13.7.1　调用绑定方法
**** 13.7.2　调用非绑定方法
**** 13.8　静态方法和类方法
**** 13.8.1　staticmethod（）和classmethod（）内建函数
**** 13.8.2　使用函数修饰符
**** 13.9　组合
**** 13.10　子类和派生
**** 13.11　继承
**** 13.11.1　__bases__类属性
**** 13.11.2　通过继承覆盖方法
**** 13.11.3　从标准类型派生
**** 13.11.4　多重继承
**** 13.12　类、实例和其他对象的内建函数
**** 13.12.1　issubclass（）
**** 13.12.2　isinstance（）
**** 13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）
**** 13.12.4　dir（）
**** 13.12.5　super（）
**** 13.12.6　vars（）
**** 13.13　用特殊方法定制类
**** 13.13.1　简单定制（RoundFloat2）
**** 13.13.2　数值定制（Time60）
**** 13.13.3　迭代器（RandSeq和AnyIter）
**** 13.13.4　*多类型定制（NumStr）
**** 13.14　私有化
**** 13.15　*授权
**** 13.15.1　包装
**** 13.15.2　实现授权
**** 13.16　新式类的高级特性（Python 2.2+）
**** 13.16.1　新式类的通用特性
**** 13.16.2　__slots__类属性
**** 13.16.3　__getattribute__（）特殊方法
**** 13.16.4　描述符
**** 13.16.5　元类和__metaclass__
**** 13.17　相关模块和文档
**** 13.18　练习
**** 第14章　执行环境
**** 14.1　可调用对象
**** 14.1.1　函数
**** 14.1.2　方法
**** 14.1.3　类
**** 14.1.4　类的实例
**** 14.2　代码对象
**** 14.3　可执行的对象声明和内建函数
**** 14.3.1　callable（）
**** 14.3.2　compile（）
**** 14.3.3　eval（）
**** 14.3.4　exec
**** 14.3.5　input（）
**** 14.3.6　使用Python在运行时生成和执行Python代码
**** 14.4　执行其他（Python）程序
**** 14.4.1　导入
**** 14.4.2　execfile（）
**** 14.4.3　将模块作为脚本执行
**** 14.5　执行其他（非Python）程序
**** 14.5.1　os.system（）
**** 14.5.2　os.popen（）
**** 14.5.3　os.fork（）、os.exec*（）、os.wait*（）
**** 14.5.4　os.spawn*（）
**** 14.5.5　subprocess 模块
**** 14.5.6　相关函数
**** 14.6　受限执行
**** 14.7　结束执行
**** 14.7.1　sys.exit（） and SystemExit
**** 14.7.2　sys.exitfunc（）
**** 14.7.3　os._exit（） 函数
**** 14.7.4　os.kill（） Function
**** 14.8　各种操作系统接口
**** 14.9　相关模块
**** 14.10　练习
**** 第2部分　高级主题
**** 第15章　正则表达式
**** 15.1　引言/动机
**** 15.2　正则表达式使用的特殊符号和字符
**** 15.2.1　用管道符号（|）匹配多个正则表达式模式
**** 15.2.2　匹配任意一个单个的字符（.）
**** 15.2.3　从字符串的开头或结尾或单词边界开始匹配（^/$ /\b /\B ）
**** 15.2.4　创建字符类（[]）
**** 15.2.5　指定范围（-）和否定（^）
**** 15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现/重复匹配
**** 15.2.7　特殊字符表示、字符集
**** 15.2.8　用圆括号（（））组建组
**** 15.3　正则表达式和Python语言
**** 15.3.1　re模块：核心函数和方法
**** 15.3.2　使用compile（）编译正则表达式
**** 15.3.3　匹配对象和group（）、groups（）方法
**** 15.3.4　用match（）匹配字符串
**** 15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）
**** 15.3.6　匹配多个字符串（|）
**** 15.3.7　匹配任意单个字符（.）
**** 15.3.8　创建字符集合（[]）
**** 15.3.9　重复、特殊字符和子组
**** 15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配
**** 15.3.11　用findall（）找到每个出现的匹配部分
**** 15.3.12　用sub（）（和subn（））进行搜索和替换
**** 15.3.13　用split（）分割（分隔模式）
**** 15.4　正则表达式示例
**** 15.4.1　匹配一个字符串
**** 15.4.2　搜索与匹配的比较，“贪婪”匹配
**** 15.5　练习
**** 第16章　网络编程
**** 16.1　引言
**** 16.1.1　什么是客户端/服务器架构
**** 16.1.2　客户端/服务器网络编程
**** 16.2　套接字：通信端点
**** 16.2.1　什么是套接字
**** 16.2.2　套接字地址：主机与端口
**** 16.2.3　面向连接与无连接
**** 16.3　Python中的网络编程
**** 16.3.1　socket（）模块函数
**** 16.3.2　套接字对象（内建）方法
**** 16.3.3　创建一个TCP服务器
**** 16.3.4　创建TCP客户端
**** 16.3.5　运行我们的客户端与TCP服务器
**** 16.3.6　创建一个UDP服务器
**** 16.3.7　创建一个UDP客户端
**** 16.3.8　执行UDP服务器和客户端
**** 16.3.9　Socket模块属性
**** 16.4　*SocketServer模块
**** 16.4.1　创建一个SocketServerTCP服务器
**** 16.4.2　创建SocketServerTCP客户端
**** 16.4.3　执行TCP服务器和客户端
**** 16.5　Twisted框架介绍
**** 16.5.1　创建一个Twisted Reactor TCP服务器
**** 16.5.2　创建一个Twisted Reactor TCP客户端
**** 16.5.3　执行TCP服务器和客户端
**** 16.6　相关模块
**** 16.7　练习
**** 第17章　网络客户端编程
**** 17.1　什么是因特网客户端
**** 17.2　文件传输
**** 17.2.1　文件传输网际协议
**** 17.2.2　文件传输协议（FTP）
**** 17.2.3　Python和FTP
**** 17.2.4　ftplib.FTP类方法
**** 17.2.5　交互式FTP示例
**** 17.2.6　客户端FTP程序举例
**** 17.2.7　FTP的其他方面
**** 17.3　网络新闻
**** 17.3.1　Usenet与新闻组
**** 17.3.2　网络新闻传输协议（NNTP）
**** 17.3.3　Python和NNTP
**** 17.3.4　nntplib.NNTP类方法
**** 17.3.5　交互式NNTP举例
**** 17.3.6　客户端程序NNTP举例
**** 17.3.7　NNTP的其他方面
**** 17.4　电子邮件
**** 17.4.1　电子邮件系统组件和协议
**** 17.4.2　发送电子邮件
**** 17.4.3　Python和SMTP
**** 17.4.4　smtplib.SMTP类方法
**** 17.4.5　交互式SMTP示例
**** 17.4.6　SMTP的其他方面
**** 17.4.7　接收电子邮件
**** 17.4.8　POP和IMAP
**** 17.4.9　Python和POP3
**** 17.4.10　交互式POP3举例
**** 17.4.11　poplib.POP3类方法
**** 17.4.12　客户端程序SMTP和POP3举例
**** 17.5　相关模块
**** 17.5.1　电子邮件
**** 17.5.2　其他网络协议
**** 17.6　练习
**** 第18章　多线程编程
**** 18.1　引言/动机
**** 18.2　线程和进程
**** 18.2.1　什么是进程
**** 18.2.2　什么是线程
**** 18.3　Python、线程和全局解释器锁
**** 18.3.1　全局解释器锁（GIL）
**** 18.3.2　退出线程
**** 18.3.3　在Python中使用线程
**** 18.3.4　没有线程支持的情况
**** 18.3.5　Python的threading模块
**** 18.4　thread模块
**** 18.5　threading模块
**** 18.5.1　Thread类
**** 18.5.2　斐波那契、阶乘和累加和
**** 18.5.3　threading模块中的其他函数
**** 18.5.4　生产者-消费者问题和Queue模块
**** 18.6　相关模块
**** 18.7　练习
**** 第19章　图形用户界面编程
**** 19.1　简介
**** 19.1.1　什么是Tcl、Tk和Tkinter
**** 19.1.2　安装和使用Tkinter　533
**** 19.1.3　客户端/服务器架构　534
**** 19.2　Tkinter与Python编程　534
**** 19.2.1　Tkinter模块：把Tk引入你的程序
**** 19.2.2　GUI程序开发简介
**** 19.2.3　顶层窗口：Tkinter.Tk（）
**** 19.2.4　Tk组件
**** 19.3　Tkinter举例
**** 19.3.1　标签组件
**** 19.3.2　按钮组件
**** 19.3.3　标签和按钮组件
**** 19.3.4　标签、按钮和进度条组件
**** 19.3.5　偏函数应用举例
**** 19.3.6　中级Tkinter范例
**** 19.4　其他GUI简介
**** 19.4.1　Tk Interface eXtensions （Tix）
**** 19.4.2　Python MegaWidgets （PMW）
**** 19.4.3　wxWidgets和wxPython
**** 19.4.4　GTK+和PyGTK
**** 19.5　相关模块和其他GUI
**** 19.6　练习
**** 第20章　Web编程
**** 20.1　介绍
**** 20.1.1　Web应用：客户端/服务器计算
**** 20.1.2　因特网
**** 20.2　使用Python进行Web应用：创建一个简单的Web客户端
**** 20.2.1　统一资源定位符
**** 20.2.2　urlparse模块
**** 20.2.3　urllib模块
**** 20.2.4　urllib2模块
**** 20.3　高级Web客户端
**** 20.4　CGI：帮助Web服务器处理客户端数据
**** 20.4.1　CGI介绍
**** 20.4.2　CGI应用程序
**** 20.4.3　cgi模块
**** 20.5　建立CGI应用程序
**** 20.5.1　建立Web服务器
**** 20.5.2　建立表单页
**** 20.5.3　生成结果页
**** 20.5.4　生成表单和结果页面
**** 20.5.5　全面交互的Web站点
**** 20.6　在CGI中使用Unicode编码
**** 20.7　高级CGI
**** 20.7.1　Mulitipart表单提交和文件的上传
**** 20.7.2　多值字段
**** 20.7.3　cookie
**** 20.7.4　使用高级CGI
**** 20.8　Web（HTTP）服务器
**** 20.9　相关模块
**** 20.10　练习
**** 第21章　数据库编程
**** 21.1　介绍
**** 21.1.1　持久存储
**** 21.1.2　基本的数据库操作和SQL语言
**** 21.1.3　数据库和Python
**** 21.2　Python数据库应用程序程序员接口（DB-API）
**** 21.2.1　模块属性
**** 21.2.2　连接对象
**** 21.2.3　游标对象
**** 21.2.4　类型对象和构造器
**** 21.2.5　关系数据库
**** 21.2.6　数据库和Python：接口程序
**** 21.2.7　使用数据库接口程序举例
**** 21.3　对象-关系管理器（ORM）
**** 21.3.1　考虑对象，而不是SQL
**** 21.3.2　Python和ORM
**** 21.3.3　雇员数据库举例
**** 21.3.4　总结
**** 21.4　相关模块
**** 21.5　练习
**** 第22章　扩展Python　623
**** 22.1　引言/动机
**** 22.1.1　什么是扩展
**** 22.1.2　为什么要扩展Python
**** 22.2　创建Python扩展
**** 22.2.1　创建您的应用程序代码
**** 22.2.2　用样板来包装你的代码
**** 22.2.3　编译
**** 22.2.4　导入和测试
**** 22.2.5　引用计数
**** 22.2.6　线程和全局解释器锁（GIL）
**** 22.3　相关话题
**** 22.4　练习
**** 第23章　其他话题
**** 23.1　Web服务
**** 23.2　用Win32的COM来操作微软Office
**** 23.2.1　客户端COM编程
**** 23.2.2 微软Excel
**** 23.2.3　微软Word　第1部分　Python核心
**** 23.2.4　微软PowerPoint
**** 23.2.5　微软Outlook
**** 23.2.6　中等规模的例子
**** 23.3　用Jython写Python和Java的程序
**** 23.3.1　什么是Jython
**** 23.3.2　Swing GUI开发（Java或者Python!）
**** 23.4　练习
**** 23.2.4　微软PowerPoint
**** 23.2.5　微软Outlook
**** 23.2.6　中等规模的例子
**** 23.3　用Jython写Python和Java的程序
**** 23.3.1　什么是Jython
**** 23.3.2　Swing GUI开发（Java或者Python!）
* <!--php 例子-->
<?php
ini_set("display_errors", "On");  
error_reporting(E_ALL | E_STRICT);
echo __FILE__;
echo "</br>";
echo __file__;
die();
?>


<?php
$segs;
$segs[]=3;
$segs[]=6;
$segs[]=7;
print_r($segs);
     die();
?>
<?php
class upDateNameClass
{
    function UpdateFunc()
    {
        echo "hello";
    }
}
$upobj=new upDatenameclass();
$upobj->updatefunc();

die();
 ?>


<?php
    $a=31;
$b=5;
function f(){
  $tmp1=  $GLOBALS['a'];
  $tmp2=  $GLOBALS['b'];
  $a=$tmp1+$tmp2;
    return $a;
}
$aa=f();
echo $aa;
    die();
?>

<?php
//这两方法用于处理类中未声明的属性访问.如果属性可见性为private or protected,也调用该方法
class TestclassB{
    private $privateField;
    public $publicField;
    
    public function __construct(){
        $this->publicField="this is a public field.\n";
        $this->privateField="this is a private field.\n";
    }
    public function __get($property)
    {
        print "__get()is called.\n";
        $method="get${property}";
        if(method_exists($this,$method)){
            return $this->$method();
        }
        return "this is underfined field.\n";
    }
    public function __set($method, $value)
    {
        print "__set is called\n";
        $m="set${method}";
        if(method_exists($this,$m))
        {
            $this->$m($value);
        }else
        {
            print "this is an underfined field.\n";
        }
    }
    public function getPrivateField(){
        return $this->privateField;
    }
    
    public function setPrivateField($value){
        $this->privateField=$value;
    }
}
$testb=new TestclassB();
print $testb->PrivateField;
print $testb->undefinedField;
print $testb->publicField;
echo "<br/>";

$testb->privateField="this is a private on set";
$testb->undefinedField="this is a undefinedField on set";
$testb->publicField="this is a publicField on set";
print $testb->PrivateField;
echo "<br/>";
print $testb->undefinedField;
echo "<br/>";
print $testb->publicField;
die();
?>
<?php
//当打印对象是,该类定义了此方法,就打印该方法的返回值,否则按照缺省返回错误
class TestClassa{
    public function __toString(){
        return "this is testclass::__toString.\n";
    }
}
$testa=new TestClassa();
print $testa;
die();
?>
<?php
//析构方法的作用和构造方法_construct相反,在对象被垃圾收集器收集之前自动调用,可以做清理;;垃圾收集不知道什么时候运行,测试shi
//print 先于 __destruct方法先运行
class TestClass{
function __destruct(){
    print "Testclass destructor is called.\n";
}
}
$testo=new TestClass();
unset($test);
print "Application will exit .\n";
die();
?>

<?php
//static 关键字和self和parent 一样,static还可以作为静态方法调用的标识符,甚至是从非静态上下文中调用


abstract class Basea{
    private $ownedGroup;
    public function __construct(){
    //这里的static 和上面的例子一样,表示当前调用该方法的实际类//这里static方法的含义与众不同
        //这里getGroup 用静态方法或普通类方法都能调用,如果是普通类方法,建议用$this
        $this->ownedGroup=static::getGroup();
    }
    public function printGroup()
    {
        print "My Group is ".$this->ownedGroup."\n";
    }
     public static function getInstance() {
        return new static();
    }
    public static function getGroup() {
        return "default";
    }
}

class A extends Basea {}
class B extends Basea{
    public static function getGroup()
    {
        return "SubB";
    }
}
A::getInstance()->printGroup();
B::getInstance()->printGroup();

die();
?>

<?php
//类实现接口要使用implements,实现其中的抽象方法.一个类可以实现多个接口,接口的意义在于后面一节继续说的多态,而不是多继承,因为没继承实现呀
interface People
{
    const MAX=30;
    function setName($name);
    function getName();
}

class NormalPeople implements People
{
    private $name;
    function getName()
    {
        return $this->name;
    }
    function setName($name)
    {
        $this->name=$name;
    }
}
$nope=new NormalPeople();
$nope->setName("xiaoming");
echo "name is".$nope->getName();
echo "Max value".People::MAX; //静态常量
die();
?>

<?php
//接口是一种特殊的抽象类，这种抽象类中只包含抽象方法和静态常量。
interface People
{
    const MAX=30;
    function setName($name);
    function getName();
}

die();
?>

<?php
//用abstract 修饰的类表示这个方法是一个抽象方法.
abstract class User
{
    protected $sal =0;
    abstract function getSal();
    abstract function setSal($sal);
    
    public function __toString(){
        return get_class($this);
    }
}

class NormalUser extends User{
    function getSal(){
    }
    function setSal($sal){
    }
}
die();

?>


<?php
//抽象类不能实例化
abstract class abstractclass
{
    public function __toString()
    {
        return get_class($this);
    }
    
}

class realclass extends abstractclass{

}
$ac=new realclass();  
return $ac->__toString();
die();
?>



<?php

//静态类比动态类快的原因（前提是调用多次）,静态类生成一次,动态类每调用一次就要先生成一次

//这里介绍的static 关键字主要用于延迟静态绑定功能
abstract class Base{
    
    public static function getInstance(){
    //这里的new static()实例化的是调用该静态方法的当前类.
        return new static();
    }
    
    abstract public function printSelf();

}

class SubA extends Base{
    public function printSelf(){
        print "This is SubA:printSELF.\n";
    }
}

class SubB extends Base{
    public function printSelf(){
        print "This is SubB:printSELF.\n";
    }
}

SubA::getInstance()->printSelf();
SubB::getInstance()->printSelf();

die();
?>


<?php
//在类内调用该类静态成员和静态方法的前缀修饰,对于非静态成员变量和函数则使用this
// this 实例指针  parent 父类指针 self 当前类指针    /?? 类其实也要 在内存生成的 ,实例化的是数据  ;;静态变量能改值 new static()实例静态方法

class StaticTest{
	static public $arg1="Hello,this is static field!";
	
	static public function SayHello()
	{
		print self::$arg1;
	}
	
	
}

	print StaticTest::$arg1;
	StaticTest::SayHello();
	StaticTest::$arg1=3;
	print StaticTest::$arg1;
	
	die();
?>

<?php
//类的继承(数据和方法)

	
class baseclass
{
	protected $arg1;
	protected $arg2;
	
	function __construct($arg1,$arg2)
	{
		$this->arg1=$arg1;
		$this->arg2=$arg2;
		print "__construct is called..\n";
	}
	
	function getAttributes()
	{
		return "arg1 is".$this->arg1."\targ2 is ".$this->arg2;
	}
}
	
class  subclass extends baseclass
{
	protected $arg3;
	
	function __construct($baseArg1,$baseArg2,$subArg)
	{
		parent::__construct($baseArg1,$baseArg2);
		$this->arg3=$subArg;
	}
	
	function getAttributes()
	{
		return parent::getAttributes().'$arg3 is'.$this->arg3;
		
	}
}	

$test=new subclass("arg1v","arg2v","arg3v")	;
print $test->getAttributes();
	
	
die();
?>


<?php
//类中的构造函数的用法
 ini_set("display_errors", "On");   
	error_reporting(E_ALL);
	
class test{
	private $arg1;
	private $arg2;
	
	public function __construct($arg1,$arg2)
	{
		$this->arg1=$arg1;
		$this->arg2=$arg2;
		print "__construct is called..\n";
	}
	
	public function printAttributes()
	{
		print 'arg1 ='.$this->arg1.'arg2='.$this->arg2;
		
	}
}	

$testobj=new test("arg1v","arg2v");
$testobj->printAttributes();
die();
?>
* Shell 编程
** 变量及声明, 不声明,默认是字符串类型;变量有两个属性,
赋值属性,这里是一个框 引用属性,这里是框里的内容,要加$
declare -i a=3
-a : 数组
-f: function
-i: integer
-r:readonly
-x:通过环境输出变量
** 逻辑判断
# TITLE shell 的逻辑判断式
| 功能     | 逻辑标识 | 表示意思                    |
|----------+----------+-----------------------------|
| 文件目录 | -f       | 文件是否存在                |
|          | -d       | 目录                        |
|          | -b       | block                       |
|          | -c       | character文件               |
|          | -S       | socket                      |
|          | -L       | 符号链接                    |
|          | -e       | 某个东西                    |
|----------+----------+-----------------------------|
| 程序     | -G       | 是否由GID所执行的程序所拥有 |
|          | -O       | UID                         |
|          | -p       | name pipe or FIFO           |
|----------+----------+-----------------------------|
| 文件属性 | -r       | 可读                        |
|          | -w       | 写                          |
|          | -x       | 执行                        |
|          | -s       | 非空白                      |
|          | -u       | SUID属性                    |
|          | -g       | SGID                        |
|----------+----------+-----------------------------|
| 文件间   | -nt      | 第一个比第二个新            |
|          | -ot      | 旧                          |
|          | -ef      | 同一文件(link之类)          |
|----------+----------+-----------------------------|
| 逻辑     | &&       | AND的意思                   |
|          | 两竖     | OR                          |
|----------+----------+-----------------------------|

** 运算符
= != > < -eq -ne -lt -gt -le -ge -a (and) -o (or) -z (空字符)
-n (非空)

** 条件判断
#+BEGIN_SRC bash
if [[ one && two ]];then
elif [[ && ]];then
else
fi
#+END_SRC
#+BEGIN_SRC bash
case 种类方式(string) in
   one)
       xx
       ;;
   two)
       xx
       ;;
     *)
       xx
       exit 1;
esac
#+END_SRC
#+BEGIN_SRC bash
for ((i=1;i<=100;i=i+1))
do
    xx
done

where []
do
done

until []
do
done
#+END_SRC
** 调试 sh [-nvx] scripts
-n:查询语法,不执行
-v:显示脚本内容,执行
-x:将有使用到的脚本显示,跟-v略有不同

** 例子
整数比较
-eq 等于,如:if [ "$a" -eq "$b" ]
-ne 不等于,如:if [ "$a" -ne "$b" ]
-gt 大于,如:if [ "$a" -gt "$b" ]
-ge 大于等于,如:if [ "$a" -ge "$b" ]
-lt 小于,如:if [ "$a" -lt "$b" ]
-le 小于等于,如:if [ "$a" -le "$b" ]
< 小于(需要双括号),如:(("$a" < "$b"))
<= 小于等于(需要双括号),如:(("$a" <= "$b"))
> 大于(需要双括号),如:(("$a" > "$b"))
>= 大于等于(需要双括号),如:(("$a" >= "$b"))

字符串比较
= 等于,如:if [ "$a" = "$b" ]
== 等于,如:if [ "$a" == "$b" ],与=等价
注意:==的功能在[[]]和[]中的行为是不同的,如下:

1 [[ $a == z* ]] # 如果$a以"z"开头(模式匹配)那么将为true
2 [[ $a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true
3
4 [ $a == z* ] # File globbing 和word splitting将会发生
5 [ "$a" == "z*" ] # 如果$a等于z*(字符匹配),那么结果为true

一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.
但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.

!= 不等于,如:if [ "$a" != "$b" ]
这个操作符将在[[]]结构中使用模式匹配.
< 小于,在ASCII字母顺序下.如:
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]
注意:在[]结构中"<"需要被转义.
> 大于,在ASCII字母顺序下.如:
if [[ "$a" > "$b" ]]
if [ "$a" \> "$b" ]
注意:在[]结构中">"需要被转义.
具体参考Example 26-11来查看这个操作符应用的例子.
-z 字符串为"null".就是长度为0.
-n 字符串不为"null"

注意:

使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z
或者就是未用""引用的字符串本身,放到[]结构中。虽然一般情况下可
以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.

awk '{print $2}' class.txt | grep '^[0-9.]' > res

SHELL下的数字比较及计算

比较：

方法一： if [ ${A} -lt ${B} ]; then ...
这是最基本的比较方法，使用lt(小于),gt(大于),le(小于等于),ge(大于等于)，优点：还没发现；缺点：只能比较整数，使用lt,gt等不直
观

方法二： if ((${A} < ${B})) then ...
这是CShell风格比较，优点：不用使用lt,gt等难记的字符串；缺点：还是只能比较整数

方法三： if (echo ${A} ${B} | awk '!($1>$2){exit 1}') then ...
这是使用awk比较，优点：可以比较小数；缺点：表达式太复杂，难记

方法四： if (echo ${A} - ${B} | bc -q | grep -q "^-"); then ...
这是使用bc计算比较，优点：可以比较小数；缺点：表达式更复杂，难记

计算：
方法一：typeset C=$(expr ${A} + ${B});
SHELL中的基本工具，优点：方便检测变量是否为数字；缺点：只能计算整数，且只能计算加减法，不能计算乘除法

方法二：let "C=${A}+${B}"; 或 let "C=A+B"
内嵌命令计算，优点：能计算乘除法及位运算等；缺点：只能计算整数

方法三：typeset C=$((A+B))
CShell风格的计算，优点：能计算乘除法及位运算等，简介，编写方便；缺点：不能计算小数

方法四：typeset C=${echo ${A} ${B} | awk '{print $1+$2}')
使用awk计算，优点：能计算小数，可以实现多种计算方式，计算灵活；缺点：表达式太复杂

方法五：typeset C=${echo ${A} + ${B} | bc -q)
使用awk计算，优点：能计算小数，计算方式比awk还多，计算灵活；缺点：表达式太复杂，小数点后面的位数必须使用scale=N来设置，否
则可能会将结果截断为整数

特殊字符

符号使用
；一般情况我们输出完一个命令需要按一个回车，如果你想在一行执行多个命令，中间可以用；号分割 cd /home ; ls
\* 表示任意字符（正则）
? 任一个字符
[abc] 列表项之一
[^abc] 对于列表取非也可以使用范围 [a-z] [0-9] [A-Z](所有字符和数字)
{} 循环列表时用 touch_{1,2,3}时就会建立touch_1,touch_2,touch_3循环出这三个文件，也会用 echo ${ab}c
~ home目录cd ~ （普通通话进入的是/home目录下用户自己的家目录）
$ 提取变量值
`` $() 命令替换touch `date +%F_\`date +%T\`` touch $(date +%F_$(date +%T))
$[] 整数计算 echo $[2+3] - * / % 浮点数用 echo "scale=3; 10/3" | bc -l (bc用于计算的)
\ 转义后面的字符串 echo \\ 输出\ 转义特殊字符，为防止被SHELL解释bash中的特殊字符
"" '' 带空格串将空格视为串的一部分 echo "abc xyz" echo 'abc xyz'
`` 命令替换取命令的执行结果
$() 同上，但它弥补了``的嵌套缺陷
@ 无特殊含义
# 注释（一般编程都需要加注释，让其他团队队员对自己写的程序功能了解）
$ 变量取值
$() 命令替换
${} 变量名的范围
% 杀后台经常jobs号，取模运算(大家对取模应该并不陌生)
^ 取非和！雷同
& 用进程后台处理， &&用于逻辑与
\* 匹配任意字符串；计算乘法
() 子进程执行
- 减号，区间，cd - 回到上层目录，杀掉当前jobs

_ （下划线）无特殊含义
+ 加号；杀掉当前jobs（进程）
= 赋值
| 管道，|| 逻辑或
\ 转义当一些特殊符号如$是一个变量需要转义才不被bash解析
{} 命令列表 {ls;cd /;}
[] 字符通配符，[]也是用于测试命令
：空命令真值
；命令结束符
"" 软引 '' 硬引
< 输入重定向
> 输出重定向
>& 合并2和1输出
, 枚举分隔符
. 当前目录
/ 目录分隔符
? 单个字符
回车命令执行

这篇文章主要介绍了Linux Shell中的特殊符号和含义简明总结,本文汇总了包含了绝大部份的Shell特殊符号,对每一个符号的作用做了总
结,需要的朋友可以参考下

在Linux Shell中有很多的特殊符号，这对于我们写Shell脚本时要特别留意：一方面要知道这些特殊符号的用法，这些符号用好了可以达到
事半功倍的效果；但另一方面要避免这些特殊符号的过度使用而导致脚本难以调试、难以阅读。

这些特殊符号罗列出来大致如下：
复制代码代码如下:
# ; ;; . , / / ‘string'| ! $ ${} $? $$ $* “string”* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || && {xx,yy,zz,…}~ ~+ ~- &
/ + – %= == !=

输出/输入重导向：
复制代码代码如下:
> >> < << : > &> 2&> 2<>>& >&2

下面就逐一介绍这些特殊符号的含义和用法……

# 井号 (comments)
这几乎是个满场都有的符号。
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo “a = $a” # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo “a = $a” # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。

~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user
或者当成是路径的一部份：~/bin；~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd 的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs

; 分号 (Command separator)
在 shell 中，担任”连续指令”功能的符号就是”分号”。譬如以下的例子：cd ~/backup ; mkdir startup ; cp ~/.* startup/.

;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case “$fop” inhelp) echo “Usage: Command -help -version filename” ;;version) echo “version 0.1″ ;;esac

. 逗号 (dot)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regular expression 中，一个
dot 代表匹配一个字元。

‘string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量
替换。
heyyou=homeecho ‘$heyyou' # We get $heyyou

“string” 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho “$heyyou” # We get home
`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo “Today $fdv”
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。

, 逗点 (comma)
这个符号常运用在运算当中当做”区隔”用途。如下例
#!/bin/bashlet “t1 = ((a = 5 + 3, b = 7 – 1, c = 15 / 3))”echo “t1 = $t1, a = $a, b = $b”

/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let “num1 = ((a = 10 / 2, b = 25 / 5))”

\ 倒斜线 (escape)
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases 的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令
的最末端，表示指令连接下一行。
# type rm
rm is aliased to `rm -i'
# \rm .\*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home
# echo “Backup dir, \$bkdir = $bkdir”
Backup dir, $bkdir = /home
上例 echo 内的 \$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir 则会输出变数的内容 /home。

| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。

! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于”
if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
在规则表达式中她担任 “反逻辑” 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 …. a9 这几个文件的其他文件。

: 冒号
在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null > f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if 这类的做
法，基本上也可以处理，但都比不上上例的简洁与效率。
除了上述之外，还有一个地方必须使用冒号
PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla
在使用者自己的HOME 目录下的 .bash_profile 或任何功能相似的档案中，设定关于”路径”的场合中，我们都使用冒号，来做区隔。

? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。

\* 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 “乘法”。
let “fmult=2*3″
除了内建指令 let，还有一个关于运算的指令 expr，星号在这里也担任”乘法”的角色。不过在使用上得小心，他的前面必须加上escape 字
元。

\** 次方运算
两个星号在运算时代表 “次方” 的意思。
let “sus=2**3″echo “sus = $sus” # sus = 8

$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo “vrs = $vrs” # vrs = 123
另外，在 Regular Expressions 里被定义为 “行” 的最末端 (end-of-line)。这个常用在 grep、sed、awk 以及 vim(vi) 当中。

${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length}
${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/
string} ${parameter//pattern/string}

$*引用script 的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}…..
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo “$*”
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。

$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。
$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo “$#”

$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行
状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho “$?”$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script 会需要产生临时文件，用来存放必要的资料。而此
script 亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。
符号$$ 或许可以符合这种需求。它代表当前shell 的 PID。
echo “$HOSTNAME, $USER, $MAIL” > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果 script 执
行完毕后仍不加以清除，会产生其他问题。
() 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ; echo $vcgh)，指令群组
有一个特性，shell会以产生 subshell 来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e “/n $a /n”)echo $a# ./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape 字元才能使用的场合，如运算式。

(())
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let 指令要好许多。
#!/bin/bash(( a = 10 ))echo -e “inital value, a = $a/n”(( a++ ))echo “after a++, a = $a”

{} 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以”分号”做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e “/n $a /n”}echo $a# ./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 “函数” 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script 也
是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。
此外，大括号还有另一种用法，如下
{xx,yy,zz,…}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin, userB-data, userC-home, userC-bin, userC-data，这几个目
录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！

[] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。

[[]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与 && 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak < 9 ]]thenecho $akfi || 逻辑符号这个会时常看到，代表 or 逻辑的符号。 && 逻辑符号这
个也会常看到，代表 and 逻辑的符号。 & 后台工作单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 tar
cvfz data.tar.gz data > /dev/null &
/ 单字边界
这组符号在规则表达式中，被定义为”边界”的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there 的一部份。如果我们要必免这种情况，就得加上
“边界” 的符号
grep ‘/' FileA

+ 加号 (plus)
在运算式中，她用来表示 “加法”。
expr 1 + 2 + 3
此外在规则表达式中，用来表示”很多个”的前面字元的意思。
# grep '10/+9′ fileB109100910000910000931010009#这个符号在使用时，前面必须加上 escape 字元。

- 减号 (dash)
在运算式中，她用来表示 “减法”。
expr 10 – 2
此外也是系统指令的选项符号。
ls -expr 10 – 2
在 GNU 指令中，如果单独使用 – 符号，不加任何该加的文件名称时，代表”标准输入”的意思。这是 GNU 指令的共通选项。譬如下例
tar xpvf -
这里的 – 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到”上一次”工作目录。

% 除法 (Modulo)
在运算式中，用来表示 “除法”。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。
** i/o
   read
** 命令行参数
$1 $2 $0 
** Shell 输入/输出重定向
command > file 	将输出重定向到 file。
command < file 	将输入重定向到 file。
command >> file 	将输出以追加的方式重定向到 file。
n > file 	将文件描述符为 n 的文件重定向到 file。
n >> file 	将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m 	将输出文件 m 和 n 合并。
n <& m 	将输入文件 m 和 n 合并。
<< tag 	将开始标记 tag 和结束标记 tag 之间的内容作为输入。
** Shell 文件包含
#+BEGIN_SRC 
. filename   # 注意点号(.)和文件名中间有一空格
或
source filename
#+END_SRC
*** 命令替换 $(locate XXX)= `command`
# 管道
* elisp
***   1.8 Arguments
****       1.8.1 Arguments’ Data Types
****       1.8.2 An Argument as the Value of a Variable or List
(+ 2 fill-column)
(number-to-string (+ 2 fill-column))
int-to-string
****        1.8.3 Variable Number of Arguments
****       1.8.4 Using the Wrong Type Object as an Argument 
(+ 2 'hello)
****       1.8.5 The message Function 
(message "The name of this buffer is :%s." (buffer-name))
***    1.9 Setting the Value of a Variable
****       1.9.1 Using set 
(set 'flowers '(rose violet daisy buttercup))
****       1.9.2 Using setq
(setq flowers '(rose violet daisy buttercupaa))
****       1.9.3 Counting 
(setq count 0) (setq count (+ count 3)) count
** 2   Practicing Evaluation 
***    2.1   Buffer Names
(buffer-name) (buffer-file-name) (current-buffer) (other-buffer)
***   2.2   Getting Buffers
***   2.3   Switching Buffers 
(switch-to-buffer (other-buffer))
***   2.4   Buffer Size and the Location of Point
(buffer-size)
(other-window) (point)
** 3   How To Write Function Definitions
***   3.1 The defun Special Form
(defun function-name(arguments ...)
"optional-documentation..."
(interactive argument-passing-info) ;optional
body ...)
#+BEGIN_SRC lisp
(defun multiply-by-seven (num)
"返回乘以7的值"
(interactive "p\ncZap to char: ")
(* 7 num))
#+END_SRC
#+BEGIN_SRC lisp
    In this function, the expression, (interactive "p"), is a list of two elements.
The "p" tells Emacs to pass the prefix argument to the function and use its value
for the argument of the function.
前缀参数,在M-Number中指定的
#+END_SRC
***   3.2 Install a Function Definition
****       3.2.1 Change a Function Definition
***   3.3 Make a Function Interactive 
****      3.3.1 An Interactive multiply-by-seven 
***   3.4 Different Options for interactive
***   3.5 Install Code Permanently
***   3.6 let
****       3.6.1 The Parts of a let Expression
#+BEGIN_SRC 
      (let ((variable value )
              (variable value )
              ...)
         body ...)
#+END_SRC
****       3.6.2 Sample let Expression
#+BEGIN_SRC lisp
      (let ((zebra 'stripes)
              (tiger 'fierce))
         (message "One kind of animal has %s and another is %s."
                    zebra tiger))

#+END_SRC
****        3.6.3 Uninitialized Variables in a let Statement 
***    3.7 The if Special Form
     (if true-or-false-test
          action-to-carry-out-if-test-is-true )
*****        3.7.1 The type-of-animal Function in Detail 
***    3.8 If then else Expressions 
***    3.9 Truth and Falsehood in Emacs Lisp 
***    3.10 save-excursion
****        3.10.1 Template for a save-excursion Expression 
**    3.11 Review 
**    3.12 Exercises 
** 4   A Few Buffer Related Functions 
**    4.1 Finding More Information
**    4.2 A Simplified beginning-of-buffer Definition 
**    4.3 The Definition of mark-whole-buffer
**        4.3.1 Body of mark-whole-buffer 
**    4.4 The Definition of append-to-buffer
**        4.4.1 The append-to-buffer Interactive Expression 
**        4.4.2 The Body of append-to-buffer
**        4.4.3 save-excursion in append-to-buffer 
**    4.5 Review 
**    4.6 Exercises 
** 5   A Few More Complex Functions 
**    5.1 The Definition of copy-to-buffer 
**    5.2 The Definition of insert-buffer 
**        5.2.1 The Interactive Expression in insert-buffer 
**            A Read-only Buffer 
**            ‘b’ in an Interactive Expression 
**        5.2.2 The Body of the insert-buffer Function 
**        5.2.3 insert-buffer With an if Instead of an or 
**        5.2.4 The or in the Body 
**        5.2.5 The let Expression in insert-buffer 
**        5.2.6 New Body for insert-buffer 
**    5.3 Complete Definition of beginning-of-buffer 
**       5.3.1 Optional Arguments 
**       5.3.2 beginning-of-buffer with an Argument 
**           What happens in a large buffer 
**           What happens in a small buffer 
**       5.3.3 The Complete beginning-of-buffer .
**    5.4 Review 
**    5.5 optional Argument Exercise 
** 6   Narrowing and Widening 
**    6.1 The save-restriction Special Form 
**    6.2 what-line 
**    6.3 Exercise with Narrowing 
** 7   car, cdr, cons: Fundamental Functions 
**    7.1 car and cdr 
**    7.2 cons 
**       7.2.1 Find the Length of a List: length 
**    7.3 nthcdr 
**    7.4 nth 
**    7.5 setcar 
**    7.6 setcdr 
**    7.7 Exercise 
** 8   Cutting and Storing Text 
**    8.1 zap-to-char 
**       8.1.1 The interactive Expression 
**       8.1.2 The Body of zap-to-char 
**       8.1.3 The search-forward Function 
**       8.1.4 The progn Special Form 
**       8.1.5 Summing up zap-to-char 
**    8.2 kill-region 
**       8.2.1 condition-case .
**       8.2.2 Lisp macro 
**    8.3 copy-region-as-kill .
**       8.3.1 The Body of copy-region-as-kill
**           The kill-append function 
**           The kill-new function 
**    8.4 Digression into C 
**    8.5 Initializing a Variable with defvar 
**       8.5.1 defvar and an asterisk 
**    8.6 Review 
**    8.7 Searching Exercises 
** Table of Contents                                                                                                                         v
** 9   How Lists are Implemented
**    9.1 Symbols as a Chest of Drawers 
**    9.2 Exercise 
** 10    Yanking Text Back 
**    10.1 Kill Ring Overview 
**    10.2 The kill-ring-yank-pointer Variable
**    10.3 Exercises with yank and nthcdr 
** 11    Loops and Recursion 
**    11.1 while 
**        11.1.1 A while Loop and a List 
**        11.1.2 An Example: print-elements-of-list .
**        11.1.3 A Loop with an Incrementing Counter 
**           Example with incrementing counter 
**           The parts of the function definition 
**           Putting the function definition together 
**        11.1.4 Loop with a Decrementing Counter 
**           Example with decrementing counter 
**           The parts of the function definition 
**           Putting the function definition together 
**    11.2 Save your time: dolist and dotimes 
**           The dolist Macro 
**           The dotimes Macro 
**    11.3 Recursion 
**        11.3.1 Building Robots: Extending the Metaphor 
**        11.3.2 The Parts of a Recursive Definition 
**        11.3.3 Recursion with a List 
**        11.3.4 Recursion in Place of a Counter 
**           An argument of 3 or 4 
**        11.3.5 Recursion Example Using cond 
**        11.3.6 Recursive Patterns 
**           Recursive Pattern: every 
**           Recursive Pattern: accumulate 
**           Recursive Pattern: keep 
**        11.3.7 Recursion without Deferments 
**        11.3.8 No Deferment Solution 
**    11.4 Looping Exercise 
** vi
** 12    Regular Expression Searches 
**    12.1 The Regular Expression for sentence-end 
**    12.2 The re-search-forward Function 
**    12.3 forward-sentence .
**       The while loops
**       The regular expression search 
**    12.4 forward-paragraph: a Goldmine of Functions 
**       The let* expression 
**       The forward motion while loop
**    12.5 Create Your Own ‘TAGS’ File 
**    12.6 Review 
**    12.7 Exercises with re-search-forward .
** 13    Counting: Repetition and Regexps 
**    13.1 The count-words-region Function 
**       13.1.1 The Whitespace Bug in count-words-region .
**    13.2 Count Words Recursively 
**    13.3 Exercise: Counting Punctuation 
** 14    Counting Words in a defun 
**    14.1 What to Count? 
**    14.2 What Constitutes a Word or Symbol?
**    14.3 The count-words-in-defun Function 
**    14.4 Count Several defuns Within a File 
**    14.5 Find a File 
**    14.6 lengths-list-file in Detail 
**    14.7 Count Words in defuns in Different Files 
**       14.7.1 The append Function 
**    14.8 Recursively Count Words in Different Files 
**    14.9 Prepare the Data for Display in a Graph 
**       14.9.1 Sorting Lists 
**       14.9.2 Making a List of Files 
**       14.9.3 Counting function definitions 
** 15    Readying a Graph 
**    15.1  The graph-body-print Function 
**    15.2  The recursive-graph-body-print Function 
**    15.3  Need for Printed Axes 
**    15.4  Exercise 
** Table of Contents                                                                                                                            vii
** 16    Your ‘.emacs’ File 
**    16.1   Site-wide Initialization Files 
**    16.2   Specifying Variables using defcustom 
**    16.3   Beginning a ‘.emacs’ File 
**    16.4   Text and Auto Fill Mode 
**    16.5   Mail Aliases 
**    16.6   Indent Tabs Mode 
**    16.7   Some Keybindings 
**    16.8   Keymaps 
**    16.9   Loading Files 
**    16.10   Autoloading 
**    16.11   A Simple Extension: line-to-top-of-window .
**    16.12   X11 Colors 
**    16.13   Miscellaneous Settings for a ‘.emacs’ File 
**    16.14   A Modified Mode Line 
** 17    Debugging 
**    17.1   debug 
**    17.2   debug-on-entry
**    17.3   debug-on-quit and (debug) 
**    17.4   The edebug Source Level Debugger 

** 数据
integer
#b101100 ⇒ 44(二进制)
#o54 ⇒ 44(八进制)
#x2a ⇒ 44(十六进制)
#24r1b ⇒ 35(RADIXrINTEGER) #表示 b+INTEGER*RADIX 
most-positive-fixnum
most-negative-fixnum
float
-0.01
非法求值 返回 NaN (/ 0.0 0.0)
positive infinity
     1.0e+INF
negative infinity
     `-1.0e+INF'
Not-a-number
     `0.0e+NaN' or `-0.0e+NaN'.
****** 方法
floatp
integerp
numberp 
natnump 是否自然数
zerop
eq(同一类型,不光数字) / = (number类型)
/= 整除
< > <= >=
max min
****** 转换
truncate 截断小数部分,向下转换
floor 基数,和上面差不多
ceiling 向上转换
****** 算数操作
(setq val (2+  3))
(+ val 5)
****** 位操作
(lsh 5 1) => 10 (lsh -1 -2)
(ash 5 1) =>算数左移(ash -1 -2)
***** strings
****** 方法
(make-string 5 ?x) =>"xxxxx"
(string ?a ?b ?c) =>"abc"
(substring "abcdefg" 0 3) =>"abc"
(concat "abc" "-def") =>"abc-def"
(split-string "   two words  ")=>("two" "words")
(char-equal ?x ?x) =>t
(string= "abc" "abc")=>t
***** lists
****** 方法
(consp '(3 3))=>t 组合体
(consp (cons 3 5))=>t 
(atom '(3 3)) =>t 原子
(listp '(1)) =>t  (listp '(1 3 3)) nlistp
(null '()) =>t 
(car '(a b c)) cdr (car-safe object) (cdr-safe object)
(pop listname) (nth n list) (nth 2 '(1 2 3 4))=>3
(nthcdr n list) (nthcdr 1 '(1 2 3 4))=>(2 3 4)
(list 1 2 '(3 4) 5) (make-list 3 'pig)
(append '(x y) 'z) =>( x y . z)
***** sequences
***** 方法
sequencep (length sequence)
(elt [1 2 3 4] 2) =>3 (element)
(arrayp [a])
(make-vectory length object)
**** 类型自定义,lisp knows it's 类型,不会执行
**** 特定类型
***** editing types
****** buffer
*** Symbols a unique name
**** 方法
symbolp
(make-symbol "foo")
(get symbol property)
(put symbol property value)
**** variable (当符号用于操作求值时)
(setq a 123) =>123 
(eval 'a)=>123
a =>123 
***** global variables
(setq x '(a b))
***** constant variables 
nil
***** local variables
(setq y 2)
(let ((y 1) (z y)) (list y z))
***** void variables
**** form
(fset 'first 'car)
** 方法
*** functions
**** lambda expression
**** primitive 原始的
written in C. primitives
**** special form ( evaluate only some of the arguments)
if while and 
**** macros
**** command
能被'command-execute'调用的对象
键盘 "bound"能调用
**** closure 闭包
**** byte-code function 被编译的函数对象

**** autoload object (lisp library)
as "eval-buffer"
***** load function
autoload /require/load
*** function test
functionp
subrp object  :test a built-in funciton
(symbol-function 'message)
** 控制结构
*** if progn cond and  or while
** 排错
catch throw
error 
** debugging
** keymaps
*** key sequences 

* lisp
; LISP 原子常量： 数值，字符串(带双引号的文本)，紧跟单引号的列表
3.1415926 [在这里按 C-x C-e 查看结果]
"i ahadd"
("i ahadd") ; ERROR 不紧跟 ' 号的列表第一个符号必须是已定义的函数名
'("i ahadd")
'(one two three four)
'(this list has (a list inside of it)) [在这里按 C-x C-e 查看结果]

; 求值，非常类似于前缀表达式
(* (+ 2 3) (- 1 3))
'(* (+ 2 3) (- 1 3)) ; 注意，这是一个文本

string 操作 (concat "abc" "def")	   
(substring "The quick brown fox jumped. " 16 19)

; 全局变量定义 set setq 
(set 'PI 3.1415926) ; 第一个变量符号必须紧跟单引号 '
PI
(setq E 2.71) ; 第一个变量会自动加上单引号 '
E

; 局部变量定义 let
(let
( (person 'me)
(dream '(a house))
)
(message "%s dream is %s." person dream)
)

person ; Error: person 未定义

; 一个计数器
(setq counter 0)
(setq counter (+ 32 1))
counter

fill-column ; EMACS 内建变量
(* 2 fill-column)
(fill-column) ; ERROR： fill-column 是未定义的函数


(this is an unquoted list) ; Error： this 是未定义的函数
(error info) ; Error： info 是未定义的变量

; 内建函数 message， 类似于 C 的 prinf
(message "the name of this buffer is %s." (buffer-name))
(message "the buffer is %s." (current-buffer))
(message "the name of this buffer is %s." (buffer-file-name))
(message "the value of this fill-column is %d." fill-column)

; buffer-size point 等都是内建函数，只是不需任何参数列表
(buffer-size)
(point)
(point-max)
(point-min)
(other-buffer)
(switch-to-buffer (other-buffer))

; 函数定义
(defun multiply(x y)
"将给定的两个数相乘"
(* x y)
)
(multiply 3 5)


; if 测试
; (if (expr) (action-if-true) (action-if-false)[可选])
; LISP nil为假 ， 非 nil 为真 
(if () 'true 'false) ; 空列表() 视为假
(if (- 1 1) 'true 'false) ; 零 非假，因为它不是空列表，而是 0

; while 测试
; (while (expr) (action1-if-true) (action2-if-true) ... (actionN-if-true))

(let ((i 10) (result ""))
(while (>= i 0)
(setq result (append result (list i)))
(setq i (1- i))
)
(message "result = %s." result)
)

; cond 测试
; (cond (expr1 action1-if-true)
; (expr2 action2-if-true)
; ...
; (exprN actionN-if-true)
; 
; )
; 类似于 switch-case
(defun signof(num)
"测试给定数的符号"
(let ((sign))
(cond
((> num 0) (message "%d is a positive." num))
((eq num 0) (message "%d is zero." num))
((< num 0) (message "%d is a negative." num))
)
)
)
(signof 1)
(signof -1)
(signof 0)

; 交互函数定义
(defun IsGreaterThanZero(num)
"测试是否给定参数是否大于零"
(interactive "p")
(if (> num 0)
(message "%d is greater than 0. " num)
(message "%d is not greater than 0." num)
)
)
; 可以作为非交互函数调用
(IsGreaterThanZero 0)
(IsGreaterThanZero 1)
(IsGreaterThanZero -1)

; 调用内建函数
(concat "abc" "123")
(concat "oh" (list 1 2) "god!" )
(substring "hei, look!" 5 9)
(concat "hei, " (substring "hei, look!" 5 9) "!") ; 嵌套表达式

; 带任意数量参数的函数
(*) (* 3) (* 1 2 3 4 5)
(+) (+ 3) (+ 1 2 3 4 5)
(concat) (concat "1") (concat "1" () "(+ 33 44)")

; 参数类型出错 hello 必须是数值
(+ "hello" 2) ; ERROR

; 这是给出的错误消息
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p "hello")

; 递归函数
(defun refac(num)
"递归计算阶乘 n! = 1 * 2 * ... * n"
(interactive "p")
(if (eq num 0) 1
(* (refac(1- num)) num)
)
)
(defun printfac(num)
"打印阶乘值"
(interactive "p")
(message "%d! = %d." num (refac num))
)
(refac 0)
(refac 1)
(refac 3)
* Peter Norvig：自学编程，十年磨一剑
让我们来仔细看看《3天学会C++》这种速成教材实际上意味着什么：
●学会：在3天时间里你几乎没有时间去写任何有意义的程序，就更不要谈什么从编程中获得经验和教训这种事情了。你也不可能有时间和有经验的程序员一起工作和交流，也不会体验到在真正的C++环境下工作是什么感觉。长话短说吧，你就是没时间，也学不到什么。所以这种书籍最多也就让你有个粗浅的印象，但是绝对不可能有深入的理解。就像亚历山大教皇说的那样，“浅尝辄止是很危险的”。
●C++: 如果你有其他编程语言的基础，那么3天之内你也许可以学到C++的一些语法，但即使是这样，你还是无法了解如何使用该语言编程。简言之，如果你之前是一个Basic程序员，那么经过3天的学习，你会成为一个“能使用C++语法编写Basic风格程序的程序员”，不过这样是没法发挥出C++语言本身的优势的（说句不好听的，你连怎么犯C++的典型错误都不会）。仅仅知道一点语法意味着什么呢？Allan Perlis曾经说过：“一个无法改变你思维方式的编程语言是不值得学习的。”；另一种可能性是，你可以只学一点点C++知识(类似的，或者一点点JavaScript,或者一点点Flex Script)，然后就可以利用现有的工具制作应用接口，完成特定的编程任务了。但是这样的行为并不意味着你“会”编程了，你只是会使用这个工具完成任务而已。
●3天：很不幸，3天是远远不够的，往下看你就知道了。

研究人员(Bloom (1985)、 Bryan & Harter (1899，见文后参考书目)、Hayes (1989)、Simmon & Chase (1973，见文后参考书目) 的一系列调查研究显示，在各个领域内，要想获得专业级别的水平，大约需要10年时间的努力。参与此项调查的领域包括：国际象棋，作曲，发报，绘画，钢琴演奏，游泳，网球等。科学家们从神经心理学和拓扑学的角度对这些领域进行研究，并得出结论。若要在某一领域内达到专家级的水平，其关键在于“审慎地重复”，也就是说，并非是机械地，一遍又一遍地练习，而是要不断地挑战自我，试图超越自身当前的水平，通过不断的尝试挑战，并在尝试的过程中和尝试之后对自身的表现进行分析和总结，吸取经验，纠正之前犯过的各种错误。把这一“审慎”的过程不断重复，才能取得成功。
所谓的“捷径”是不存在的，即使对于莫扎特这种天才来说，也没有捷径可走，尽管4岁就开始作曲，可是他也花了13年的时间，才真正地写出了世界级的作品。再举一个例子，甲壳虫乐队（The Beatles）,他们似乎在1964年凭借一系列热门单曲和其在艾德沙利文秀（The Ed Sullivan show）上的演出一炮而红，但是你也许不知道，他们早在1957年就在利物浦和汉堡两地进行小规模演出了，而在此之前的非正式演出更是不计其数。甲壳虫乐队的主要成名曲《Sgt. Peppers》，则是1967年才发行的。Malcolm Gladwell公布了他对柏林音乐学院所作的一项研究的报告，该研究对比了一个班里的学习成绩为上、中下三个档次的学生，并逐一询问他们进行音乐练习的时间
这三个档次中的所有人，大约都是在5岁的时候开始练习音乐的，一开始的时候大家练习音乐的时间都差不多，大约一周2到3小时。但是到了八岁左右，大家的区别就开始体现了。后来成为班里最好的那一部分学生开始比别的学生练习得更多，大概每周6到9小时，12岁的时候每周8小时，14岁的时候每周16小时，往后则越来越多，直到20岁左右，他们每周练习音乐的时间已经超过30小时了。在20岁的年纪，那些精英级别的演奏家们都有累计超过10000小时的音乐练习时间。相比之下，仅有部分优等生能达到8000小时的累计练习时间，而那些音乐教师级别的学生，他们的累计练习时间只有4000小时左右。
所以，也许这个让你能达到专业等级的神奇时间应该是10000小时，而不是10年。（Henri Cartier-Bresson (1908-2004)说过，“（作为摄影师），你所拍摄的头10000张照片都是垃圾”，但即使是垃圾作品，他拍一张照片也要花接近一小时。）Samuel Johnson (1709-1784)认为这个时间应该更长：“在任何一个领域要想做到极好,势必穷尽一生的精力，否则根本无法企及。” Chaucer (1340-1400)也发出过“生命如此短暂，技能如此高深”的感叹。Hippocrates (c. 400BC)因写下了如下的句子而被人称颂：“ars longa, vita brevis”，该句是来自于一个更长的引用：”Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, 这段话翻译成英语就是：“生命很短暂，但是技艺却很高深，机遇转瞬即逝，探索难以捉摸，抉择困难重重”。这段话是用拉丁文写的。在拉丁文里，ars可以翻译为“技艺”或者“艺术”，但是在古希腊文里，ars只能做“技能”的意思，而没有“艺术”的意思。

 

你想当程序员么？

下面是我列举的程序员成功“食谱”

●沉醉于编程，编程是为了兴趣。保持这种充满兴趣的感觉，以便于你能将其投入到你的10年/10000小时的编程时间中。
●程序. 最好的学习方式是“在实践中学习”。更技术一些地说：“一个人在某个专业领域方面能够达到最高水平，并不是因为这个人经验增长了以后而自动获得的，而是这个人为了进步所做出了专门的努力之后产生的结果。”(p. 366)“最有效的学习包括如下几个要素：明确并且难度适当的任务，适应学习者个人情况，及时的信息反馈，有重新开始和改正错误的机会）(p. 20-21) 《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书提供了上述有趣的观点
●同其他程序员交流，多阅读其他人写的程序。这些远比你看书或者上培训班重要
●如果你愿意的话，就选择去读一个计算机科学专业吧（当然你还可以去念这个专业的研究生）。如果你能做到这点，那么你就有机会找到一些需要计算机学位认证的工作，也会让你对这个行业有更深的理解。不过，如果你不是上学的料，那么你可以（当然需要有足够的毅力）靠自己学习，或者通过工作来积累经验。无论你采用哪种途径，光依靠书本是远远不够的。“如果说仅仅靠学习油画和调色技术无法创造出顶尖的画家的话，那么光学习计算机科学课程更不能造就顶尖的程序员。”，Eric Raymond这样说过，他著有《新黑客字典》一书。我所聘用过的最好的程序员仅仅只有高中文凭; 他写了很多伟大的软件，他有他自己的新闻组，并且通过股权赚够了钱，还开了家属于自己的夜店。（作者说的这个人是Jamie Zawinski，他是网景浏览器（Netscape）的早期开发这者之一，也是开源项目Mozilla和XEmacs的主要贡献者，他开了一家叫做DNA_lounge的夜店，位于旧金山的SoMa区——译者注）
●与其他程序员一起做项目。在某些项目中要尽量做到最好，在某些项目中却别做那么好。当你是最好的时候，你的领导能力就会得到锻炼，并激发你高瞻远瞩的视野。当你做得不好的时候，你就能知道你的领导怎么做事，以及他们不喜欢哪些事（因为领导总是把那些他们不爱做的杂事丢给他们认为不得力的人去做）
●尝试跟随其他程序员一起做项目。尝试去理解其他人所写的代码。看看如果你无法找到代码的作者本人的情况下，理解和修正他写的代码需要花费什么样的代价。同时也思考，如何规划你自己的程序代码，让它们更容易被其他人理解和维护。
●至少学习半打编程语言。包括一种支持类抽象的语言（例如Java或者C++），一种支持函数抽象的语言（例如Lisp或者ML）,一种支持语法抽象的语言（例如Lisp）,一种支持声明式编程的语言（例如Prolog或者C++模板），一种支持协同程序的语言（例如Icon或者Scheme）,一种支持平行并发编程的语言（例如Sial）
●牢记“计算机科学”中包含着“计算机”这个词。了解计算机需要花多长的时间执行一条指令，花多长时间从内存中获取一个字(word)（包括缓存命中和不命中两种情况），如果连续从磁盘中获取数据，时间消耗如何？以及需要花多少时间才能再磁盘上定位一个新的位置？
●尽量参与语言的标准化过程。往大了说，你可以试着加入ANSI C++委员会这样的专业组织，往小了讲，你也可以从自己的代码规范入手，限定代码缩进是需要2个空格宽还是4个空格宽。无论采用哪种方式，你都需要了解其他人对于语言的喜好，以及他们的喜好的程度，甚至你要知道他们为什么产生这样的喜好的原因。
●有良好的意识，能尽快适应语言标准化的成果。

要掌握上面所说的所有内容，光靠看书学习应该是很难做到的。当我的第一个孩子出生的时候，我几乎阅读了市面上所有的《如何…》指南书籍，但是我读完了以后还是觉得自己是个菜鸟。30个月以后，我的第二个孩子快出生时，我难道还要做一个书虫么？不！相反，我此时更依赖我的个人经验，这些经验相比于那些上千页的书籍，则更加有效和让我放心。
Fred Brooks所著的著名的论文《No Silver Bullets| 没有银弹》里向我们揭示了发现和培养软件设计人才的三步骤：
1.有组织地辨认顶尖的软件设计人才，越早越好
2.安排一个职业导师，为其职业前景指点迷津，并谨慎对待自己的职业履历
3.为成长中的设计师们提供机会，让他们能够互相激发促进。
即使一部分人已经具备了成为优秀软件设计人员的潜质，也需要经历工作的慢慢琢磨，方可展现才华。Alan Perlis则说得更加直接：“任何人都可以被‘教’成一个雕塑匠，但米开朗基罗则被‘教’如何不要成为一个雕塑匠，因为他要做的是雕塑大师，。这个道理放到编程大师身上同样管用。”Perlis认为，伟大的软件开发人员都有一种内在的特质，这种特质往往比他们所接受的训练更重要。但是这些特质是从哪里来的呢？是与生俱来的？还是通过后天勤奋而来？正如Auguste Gusteau（动画电影《料理鼠王》里的幻象大厨）所说，“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我很情愿地说，将你生命中的大部分时间花在审慎地练习和提高上，这很重要！但是“无所畏惧”的精神，才是将促使这些练习成果凝聚成形的途径。或者，就像是《料理鼠王》里那个与Gusteau作对的刻薄的美食评论家Anton Ego说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家在成名前可能是任何人。”
所以尽管去书店大买Java/Ruby/Javascript/PHP书籍吧；你也许会发现他们真的挺管用。但是这样做不会改变你的人生，也不会让你在整体经验上有什么提高。24小时，几天，几周，做一个真正的程序员？光靠读书可读不出来。你尝试过连续24个月不懈努力提高自己么？呵呵，如果你做到了，好吧，那么你开始上路了……

== 启动Emacs, 缓冲区和工作模式==
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; 第一步首先启动Emacs: (在windows中可以双击emacs图标，在Linux中可以输入% emacs & )，
;; 然后在键盘上键入q 跳过系统欢迎的信息，
;; 先观察在Emacs屏幕的底部，会给出一堆关于当前的工作情况的信息，其中灰色的一行叫做状态行，
;; 在其中你会发现 *scratch* 的字样，这表示你当前的缓冲区(buffer)的名字。
;; 缓冲区也叫做工作区，在Emacs中打开一个文件，实际只是在Emacs中构造该文件的一个副本，放到缓冲区中，
;; 在Emacs中对该文件的编辑也是针对该副本的编辑，唯有保存改动时，Emacs才会把缓冲区中的内容在复制到原文件中去。
;; 状态行下面的那行，叫做辅助输入区(minibuffer),该minibuffer用于显示计算结果，以及和用户做交互。
;;
;; 
;; 如何切换Emacs的工作模式 
;; Emacs有各种各样功能各异的模式，工作模式的含义其实就是Emacs对当前的文本编辑工作
;; 更加的敏感，比如高亮和缩进，并且支持一些特殊的命令。
;; 为了实验本教程中的lisp命令，我们要让Emacs工作在lisp-interaction-mode工作模式下，
;; 这个模式可以让我们在缓冲区中和Emacs进行互动，并且直接执行Lisp命令,得到结果。
;; 进入lisp-interaction-mode的方法： 把光标移动到辅助输入区，键入M-x lisp-interaction-mode 
;; 然后回车。
 
== 表达式，变量和函数 ==
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 冒号在Lisp中表示注释
;; 在Elisp中做运算，调用函数的最简单的方式是
;; (function arg1 arg2) 
;; 这相当于通常的function(arg1,arg2)，下面的表达式，对两个数字进行加法运算
(+ 2 2)
 
;; Elisp中表达式可以通过括号来嵌套
(+ 2 (+ 1 1))

4
 
;; 在lisp-interaction-mode模式中，我们可以直接计算一个表达式,计算的方法是
(+ 3 (+ 1 2))
;; 
6
^ 把光标放在这里，并且键入Ctrl-j (之后将简写成C-j)
;; C-j是一个快捷命令，在后台，该快捷键将调用求值命令，并且把计算的结果
;; 插入到当前的缓冲区中
 
;; 如果不希望Emacs在缓冲区中插入计算结果，我们还可以在表达式的末尾使用C-x C-e组合键
;; C-x C-e的意思是: 先按下Ctrl-x 再按下Ctrl-e 
;; 这个命令会让Emacs在辅助缓冲区，也就是Emacs窗口的最底部那行显示计算结果
 
;; ELisp中的赋值函数是是setq，下面的表达式给变量my-name赋值"Bastien"
(setq my-name "Bastien")
;; ^ 把光标停在这里，再键入C-x C-e
 
;; 下面insert函数的作用是在光标所在出插入字符Hello
(insert "Hello!")
;; ^ 把光标停在这里，再键入C-x C-e
 
;; insert函数还可以两个常量字符，比如
(insert "Hello" " world!")

;; insert函数还可以接受变量作为参数，我们之前已经给my-name变量赋过值了
;; 所以下面命令的输出结果是 "Hello, I am Bastien"
(insert "Hello, I am " my-name)

;; defun命令用来定义一个函数,语法是
;; (defun 函数名 (参数列表) (函数体))
(defun hello () (insert "Hello, I am " my-name))
;; ^ 把光标停在这里，再键入C-x C-e 执行defun命令来定义函数
;; 通过defun命令，你已经在Emacs中安装了这个hello函数，这个函数就成为了Emacs的一部分，知道你退出Emacs或者改变hello的定义
 
;; 从下面开始，我们将不再提醒读者使用C-x C-e来定义函数和执行ELisp指令
 
;; 在Elisp中直接输入函数的名称就是调用该函数。
;; 下面的命令的输入结果是: Hello, I am Bastien
(hello)
 
;; 前面定义的hello函数不接受任何参数,过于简单，
;; 现在我们重新定义hello函数，让它接受一个参数name。 
(defun hello (name) (insert "Hello " name))
 
;; 然后调用新的hello函数，并且提供一个参数。
;; 下面命令的输出结果是"Hello you"
(hello "you")
 
== progn,let和交互式函数== 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 执行switch-to-buffer-other-window命令，将在在一个新的窗口中打开一个buffer
;; 该buffer命名叫做 test, 并且把光标移到新的buffer的窗口中。
(switch-to-buffer-other-window "*test*")
 
;; 要回到原来的buffer中，可以使用鼠标点击原来的buffer
;; 或者使用组合键 C-x o 
;; C-x o的意思是: 先按下Ctrl-x 再按下o
 
;; 如果要执行一系列的指令，可以使用流程函数progn，把函数命令连接起来.
;; 下面的命令,先打开一个新的buffer,再执行hello函数，该hello函数的参数是"you"
(progn
(switch-to-buffer-other-window "*test*")
(hello "you"))
 
;; 如果要清空一个buffer,可以调用erase-buffer函数。下面的命令先清空test buffer,再调用hello函数做打印
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "there"))
 
;; 在这一系列的质量后面再添加调用一个other-window函数，这样在hello函数被调用完毕之后
;; 光标自动回到之前的buffer窗口中
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "you")
(other-window 1))
 
;; let函数用来做局部变量的定义 下面的一系列命令中
;; let函数首先定义local-name变量的值为“you”
;; 然后接着执行括号中其它的语句块部分，这个功能和progn类似
(let ((local-name "you"))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello local-name)
(other-window 1))
 
;; format函数可以用做格式化的输出 其中%s表示该s的地方将被之后提供的一个字符串,即visitor替换
;; \n表示换行
(format "Hello %s!\n" "visitor")
 
;; 现在我们利用format函数来改进之前定义的hello函数
(defun hello (name)
(insert (format "Hello %s!\n" name)))
 
;; 执行这个函数结果是"Hello you"，并且光标换到下一行
(hello "you")
 
;; 下面我们再设计一个greeting函数，该函数接受一个参数name,
;; 在函数体的内部又使用了let函数，给一个局部变量your-name赋值
;; 最后把参数和局部变量格式化的打印出来
(defun greeting (name)
(let ((your-name "Bastien"))
(insert (format "Hello %s!\n\nI am %s."
name 
your-name ; 局部变量
))))
 
;; 执行greeting函数，并提供"you"字符串作为参数
(greeting "you")
 
;; read-from-minibuffer函数提供和用户交互的功能，这个函数可以帮助Elisp程序从用户处得到输入
(read-from-minibuffer "Enter your name: ")
 
;; 比如如果我们希望greeting函数能够从用户处得到姓名，并且做打印格式化的欢迎信息。
;; 可以先调用read-from-minibuffer在minibuffer中提示用户输入姓名，
;; 然后把得到的结果赋给局部变量your-name，
;; 最后insert函数在当前buffer中插入格式化的输出
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(insert (format "Hello!\n\nI am %s and you are %s."
from-name ; 格式化输出参数1
your-name ; 格式化输出参数2
))))
 
;; 执行这个函数
(greeting "Bastien")
 
;; 再稍加改进greeting 把结果打印在新的buffer中
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(insert (format "Hello %s!\n\nI am %s." your-name from-name))
(other-window 1)))
 
;; 执行这个函数
(greeting "Bastien")
 
== 列表和综合实例 ==
 
;; Lisp中使用括号构造列表，使用setq给变量赋值。
;; 下面的命令先构造一个列表，再把这个列表赋给list-of-names变量
(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
;; ^这里的单引号表示这是一个列表
 
;; 如果想要得到列表中的第一个元素，可以使用car函数
(car list-of-names)
 
;; 如果想要得到列表中的除第一个元素以外的其它元素，可以使用cdr函数
(cdr list-of-names)
 
;; 以后push函数可以在列表的头部插入新的元素，所以下面的命令将改变list-of-name中元素的个数
(push "Stephanie" list-of-names)
 
;; mapcar函数对列表中的把列表中的每一个元素分别取出来，赋给hello函数
(mapcar 'hello list-of-names)
 
;; 重新定义greeting函数，在一个新的，清空的buffer中，对list-of-names列表中的每一个元素，调用hello函数
;; 调用完毕之后，再让光标回到原的buffer中
(defun greeting ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(mapcar 'hello list-of-names)
(other-window 1))
 
;;执行这个函数，我们将得到一个名叫test的buffer，其中的内容是
;; Hello Stephanie!
;; Hello Sarah!
;; Hello Chloe!
;; Hello Mathilde!
;; 暂时先不要关闭这个buffer!后面还有用！ 
(greeting)
 
;; 下面我们对buffer做一些更有意思的事情！
;; 定义一个replace-hello-by-bonjour函数，顾名思义，就是把hello替换成bonjour
;; 该函数首先把光标移到一个叫做test的buffer中
;; 再把光标移到该buffer的开头
;; 从头开始搜索字符串Hello,并且替换成Bonjour
;; 结束之后在把光标移会到一开始的buffer中。
(defun replace-hello-by-bonjour ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min)) ;该函数把光标移到buffer的开头
(while (search-forward "Hello")
(replace-match "Bonjour"))
(other-window 1))
 
;; 其中 (search-forward "Hello") 在当前的buffer中做前向搜索
;; (while x y) 当x 的条件满足时执行y指令 ，当x返回nil时，while循环结束
 
;; 执行这个函数 替换test buffer中的hello
(replace-hello-by-bonjour)
 
;; test buffer中的结果如下
;; Bonjour Stephanie!
;; Bonjour Sarah!
;; Bonjour Chloe!
;; Bonjour Mathilde!
 
;; 在minibuff中，还会有一条错误信息 "Search failed: Hello".
;; 把(search-forward "Hello")一句换成如下就不会有错误信息了
;; (search-forward "Hello" nil t)
 
;; 其中 nil参数表示 搜索的区域不加限制，直到buffer结束
;; 其中t参数指示search-foward函数 跳过错误信息 直接退出
 
;; 新hello-to-bonjour如下：
(defun hello-to-bonjour ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
;; 对list-of-names列表中的每个元素 使用hello函数
(mapcar 'hello list-of-names)
(goto-char (point-min))
;; 搜索Hello替换成Bonjour
(while (search-forward "Hello" nil t)
(replace-match "Bonjour"))
(other-window 1))
 
;; 执行这个函数
(hello-to-bonjour)
 
;; 下面的boldify-names 函数 ，
;; 首先把光标挪到名叫test的buffer的开头，
;; 然后使用regular expression 搜索 “Bonjour + 其它任何内容” 的pattern，
;; 然后对找到的字符加粗。 
(defun boldify-names ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min))
(while (re-search-forward "Bonjour \\(.+\\)!" nil t)
(add-text-properties (match-beginning 1) ;返回匹配模式中，最先匹配的位置
(match-end 1) ;返回最后匹配的位置
(list 'face 'bold)))
(other-window 1))
 
;; 执行这个函数 
(boldify-names)
 
== 帮助和参考==
 
;; 在Emacs中我们可以通过如下的方式得到变量和函数的帮助信息
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; 下面的命令将打开整个Emacs Manual
;;
;; C-h i m elisp RET
;;
;; Emacs Lisp 教程
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html
 
;; Thanks to these people for their feedback and suggestions:
;; - Wes Hardaker
;; - notbob
;; - Kevin Montuori
;; - Arne Babenhauserheide
;; - Alan Schmitt
;; - LinXitoW
* asm
** nasm
-f [TYPE] 编译成 elf32 elf64 coff aout 等格式
-o o 输出obj文件 -l 输出列表文件
-h 帮助 -hf 针对格式的帮助
*** 寻址
mov ax,[var] 取地址  
mov ax,var 取值
** gas 
NASM 分别使用 dd、dw 和 db 指令声明 32 位、16 位和 8 位数字，而 GAS 分别使用 .long、.int 和 .byte。
GAS 还有其他指令，比如 .ascii、.asciz 和 .string。
在 GAS 中，像声明其他标签一样声明变量（使用冒号），但是在 NASM 中，只需在内存分配指令（dd、dw 等等）前面输入变量名，后面加上变量的值。
NASM 使用方括号间接引用一个内存位置指向的地址值：[var1]。
GAS 使用$引用同样的值：$var1)。 