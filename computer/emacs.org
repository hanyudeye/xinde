* info 树的导航
** node
n next node (相对于当前(自身)节点)
p 
^ 
d  <root node == info node>
<  file top node 
>  file last node 
[  backward node
] forward node 
f Follow a cross reference. 文件之间的 交叉参考，交叉引用
l Move back in history to the last node you were at. 历史记录中跳转
r Move forward in history to the node you returned from after using l.
L Go to menu of visited nodes. 历史列表
T Go to table of contents of the current Info file. 把info 文件用列表形式展示
s 搜索
SPC scroll forward
DEL scroll backward
* elisp
***   1.8 Arguments
****       1.8.1 Arguments’ Data Types
****       1.8.2 An Argument as the Value of a Variable or List
(+ 2 fill-column)
(number-to-string (+ 2 fill-column))
int-to-string
****        1.8.3 Variable Number of Arguments
****       1.8.4 Using the Wrong Type Object as an Argument 
(+ 2 'hello)
****       1.8.5 The message Function 
(message "The name of this buffer is :%s." (buffer-name))
***    1.9 Setting the Value of a Variable
****       1.9.1 Using set 
(set 'flowers '(rose violet daisy buttercup))
****       1.9.2 Using setq
(setq flowers '(rose violet daisy buttercupaa))
****       1.9.3 Counting 
(setq count 0) (setq count (+ count 3)) count
** 2   Practicing Evaluation 
***    2.1   Buffer Names
(buffer-name) (buffer-file-name) (current-buffer) (other-buffer)
***   2.2   Getting Buffers
***   2.3   Switching Buffers 
(switch-to-buffer (other-buffer))
***   2.4   Buffer Size and the Location of Point
(buffer-size)
(other-window) (point)
** 3   How To Write Function Definitions
***   3.1 The defun Special Form
(defun function-name(arguments ...)
"optional-documentation..."
(interactive argument-passing-info) ;optional
body ...)
#+BEGIN_SRC lisp
(defun multiply-by-seven (num)
"返回乘以7的值"
(interactive "p\ncZap to char: ")
(* 7 num))
#+END_SRC
#+BEGIN_SRC lisp
    In this function, the expression, (interactive "p"), is a list of two elements.
The "p" tells Emacs to pass the prefix argument to the function and use its value
for the argument of the function.
前缀参数,在M-Number中指定的
#+END_SRC
***   3.2 Install a Function Definition
****       3.2.1 Change a Function Definition
***   3.3 Make a Function Interactive 
****      3.3.1 An Interactive multiply-by-seven 
***   3.4 Different Options for interactive
***   3.5 Install Code Permanently
***   3.6 let
****       3.6.1 The Parts of a let Expression
#+BEGIN_SRC 
      (let ((variable value )
              (variable value )
              ...)
         body ...)
#+END_SRC
****       3.6.2 Sample let Expression
#+BEGIN_SRC lisp
      (let ((zebra 'stripes)
              (tiger 'fierce))
         (message "One kind of animal has %s and another is %s."
                    zebra tiger))

#+END_SRC
****        3.6.3 Uninitialized Variables in a let Statement 
***    3.7 The if Special Form
     (if true-or-false-test
          action-to-carry-out-if-test-is-true )
*****        3.7.1 The type-of-animal Function in Detail 
***    3.8 If–then–else Expressions 
***    3.9 Truth and Falsehood in Emacs Lisp 
***    3.10 save-excursion .
****        3.10.1 Template for a save-excursion Expression 
**    3.11 Review 
**    3.12 Exercises 
** 4   A Few Buffer–Related Functions 
**    4.1 Finding More Information
**    4.2 A Simplified beginning-of-buffer Definition 
**    4.3 The Definition of mark-whole-buffer.
**        4.3.1 Body of mark-whole-buffer .
**    4.4 The Definition of append-to-buffer .
**        4.4.1 The append-to-buffer Interactive Expression 
**        4.4.2 The Body of append-to-buffer .
**        4.4.3 save-excursion in append-to-buffer 
**    4.5 Review 
**    4.6 Exercises 
** 5   A Few More Complex Functions 
**    5.1 The Definition of copy-to-buffer .
**    5.2 The Definition of insert-buffer 
**        5.2.1 The Interactive Expression in insert-buffer 
**            A Read-only Buffer 
**            ‘b’ in an Interactive Expression 
**        5.2.2 The Body of the insert-buffer Function 
**        5.2.3 insert-buffer With an if Instead of an or 
**        5.2.4 The or in the Body 
**        5.2.5 The let Expression in insert-buffer 
**        5.2.6 New Body for insert-buffer 
**    5.3 Complete Definition of beginning-of-buffer .
** iv
**       5.3.1 Optional Arguments 
**       5.3.2 beginning-of-buffer with an Argument 
**           What happens in a large buffer 
**           What happens in a small buffer 
**       5.3.3 The Complete beginning-of-buffer .
**    5.4 Review 
**    5.5 optional Argument Exercise 
** 6   Narrowing and Widening 
**    6.1 The save-restriction Special Form 
**    6.2 what-line 
**    6.3 Exercise with Narrowing 
** 7   car, cdr, cons: Fundamental Functions 
**    7.1 car and cdr 
**    7.2 cons 
**       7.2.1 Find the Length of a List: length 
**    7.3 nthcdr 
**    7.4 nth 
**    7.5 setcar 
**    7.6 setcdr 
**    7.7 Exercise 
** 8   Cutting and Storing Text 
**    8.1 zap-to-char 
**       8.1.1 The interactive Expression 
**       8.1.2 The Body of zap-to-char 
**       8.1.3 The search-forward Function 
**       8.1.4 The progn Special Form 
**       8.1.5 Summing up zap-to-char 
**    8.2 kill-region 
**       8.2.1 condition-case .
**       8.2.2 Lisp macro 
**    8.3 copy-region-as-kill .
**       8.3.1 The Body of copy-region-as-kill
**           The kill-append function 
**           The kill-new function 
**    8.4 Digression into C 
**    8.5 Initializing a Variable with defvar 
**       8.5.1 defvar and an asterisk 
**    8.6 Review 
**    8.7 Searching Exercises 
** Table of Contents                                                                                                                         v
** 9   How Lists are Implemented
**    9.1 Symbols as a Chest of Drawers 
**    9.2 Exercise 
** 10    Yanking Text Back 
**    10.1 Kill Ring Overview 
**    10.2 The kill-ring-yank-pointer Variable
**    10.3 Exercises with yank and nthcdr 
** 11    Loops and Recursion 
**    11.1 while 
**        11.1.1 A while Loop and a List 
**        11.1.2 An Example: print-elements-of-list .
**        11.1.3 A Loop with an Incrementing Counter 
**           Example with incrementing counter 
**           The parts of the function definition 
**           Putting the function definition together 
**        11.1.4 Loop with a Decrementing Counter 
**           Example with decrementing counter 
**           The parts of the function definition 
**           Putting the function definition together 
**    11.2 Save your time: dolist and dotimes 
**           The dolist Macro 
**           The dotimes Macro 
**    11.3 Recursion 
**        11.3.1 Building Robots: Extending the Metaphor 
**        11.3.2 The Parts of a Recursive Definition 
**        11.3.3 Recursion with a List 
**        11.3.4 Recursion in Place of a Counter 
**           An argument of 3 or 4 
**        11.3.5 Recursion Example Using cond 
**        11.3.6 Recursive Patterns 
**           Recursive Pattern: every 
**           Recursive Pattern: accumulate 
**           Recursive Pattern: keep 
**        11.3.7 Recursion without Deferments 
**        11.3.8 No Deferment Solution 
**    11.4 Looping Exercise 
** vi
** 12    Regular Expression Searches 
**    12.1 The Regular Expression for sentence-end 
**    12.2 The re-search-forward Function 
**    12.3 forward-sentence .
**       The while loops
**       The regular expression search 
**    12.4 forward-paragraph: a Goldmine of Functions 
**       The let* expression 
**       The forward motion while loop
**    12.5 Create Your Own ‘TAGS’ File 
**    12.6 Review 
**    12.7 Exercises with re-search-forward .
** 13    Counting: Repetition and Regexps 
**    13.1 The count-words-region Function 
**       13.1.1 The Whitespace Bug in count-words-region .
**    13.2 Count Words Recursively 
**    13.3 Exercise: Counting Punctuation 
** 14    Counting Words in a defun 
**    14.1 What to Count? 
**    14.2 What Constitutes a Word or Symbol?
**    14.3 The count-words-in-defun Function 
**    14.4 Count Several defuns Within a File 
**    14.5 Find a File 
**    14.6 lengths-list-file in Detail 
**    14.7 Count Words in defuns in Different Files 
**       14.7.1 The append Function 
**    14.8 Recursively Count Words in Different Files 
**    14.9 Prepare the Data for Display in a Graph 
**       14.9.1 Sorting Lists 
**       14.9.2 Making a List of Files 
**       14.9.3 Counting function definitions 
** 15    Readying a Graph 
**    15.1  The graph-body-print Function 
**    15.2  The recursive-graph-body-print Function 
**    15.3  Need for Printed Axes 
**    15.4  Exercise 
** Table of Contents                                                                                                                            vii
** 16    Your ‘.emacs’ File 
**    16.1   Site-wide Initialization Files 
**    16.2   Specifying Variables using defcustom 
**    16.3   Beginning a ‘.emacs’ File 
**    16.4   Text and Auto Fill Mode 
**    16.5   Mail Aliases 
**    16.6   Indent Tabs Mode 
**    16.7   Some Keybindings 
**    16.8   Keymaps 
**    16.9   Loading Files 
**    16.10   Autoloading 
**    16.11   A Simple Extension: line-to-top-of-window .
**    16.12   X11 Colors 
**    16.13   Miscellaneous Settings for a ‘.emacs’ File 
**    16.14   A Modified Mode Line 
** 17    Debugging 
**    17.1   debug 
**    17.2   debug-on-entry
**    17.3   debug-on-quit and (debug) 
**    17.4   The edebug Source Level Debugger 

** 数据
integer
#b101100 ⇒ 44(二进制)
#o54 ⇒ 44(八进制)
#x2a ⇒ 44(十六进制)
#24r1b ⇒ 35(RADIXrINTEGER) #表示 b+INTEGER*RADIX 
most-positive-fixnum
most-negative-fixnum
float
-0.01
非法求值 返回 NaN (/ 0.0 0.0)
positive infinity
     1.0e+INF
negative infinity
     `-1.0e+INF'
Not-a-number
     `0.0e+NaN' or `-0.0e+NaN'.
****** 方法
floatp
integerp
numberp 
natnump 是否自然数
zerop
eq(同一类型,不光数字) / = (number类型)
/= 整除
< > <= >=
max min
****** 转换
truncate 截断小数部分,向下转换
floor 基数,和上面差不多
ceiling 向上转换
****** 算数操作
(setq val (2+  3))
(+ val 5)
****** 位操作
(lsh 5 1) => 10 (lsh -1 -2)
(ash 5 1) =>算数左移(ash -1 -2)
***** strings
****** 方法
(make-string 5 ?x) =>"xxxxx"
(string ?a ?b ?c) =>"abc"
(substring "abcdefg" 0 3) =>"abc"
(concat "abc" "-def") =>"abc-def"
(split-string "   two words  ")=>("two" "words")
(char-equal ?x ?x) =>t
(string= "abc" "abc")=>t
***** lists
****** 方法
(consp '(3 3))=>t 组合体
(consp (cons 3 5))=>t 
(atom '(3 3)) =>t 原子
(listp '(1)) =>t  (listp '(1 3 3)) nlistp
(null '()) =>t 
(car '(a b c)) cdr (car-safe object) (cdr-safe object)
(pop listname) (nth n list) (nth 2 '(1 2 3 4))=>3
(nthcdr n list) (nthcdr 1 '(1 2 3 4))=>(2 3 4)
(list 1 2 '(3 4) 5) (make-list 3 'pig)
(append '(x y) 'z) =>( x y . z)
***** sequences
***** 方法
sequencep (length sequence)
(elt [1 2 3 4] 2) =>3 (element)
(arrayp [a])
(make-vectory length object)
**** 类型自定义,lisp knows it's 类型,不会执行
**** 特定类型
***** editing types
****** buffer
*** Symbols a unique name
**** 方法
symbolp
(make-symbol "foo")
(get symbol property)
(put symbol property value)
**** variable (当符号用于操作求值时)
(setq a 123) =>123 
(eval 'a)=>123
a =>123 
***** global variables
(setq x '(a b))
***** constant variables 
nil
***** local variables
(setq y 2)
(let ((y 1) (z y)) (list y z))
***** void variables
**** form
(fset 'first 'car)
** 方法
*** functions
**** lambda expression
**** primitive 原始的
written in C. primitives
**** special form ( evaluate only some of the arguments)
if while and 
**** macros
**** command
能被'command-execute'调用的对象
键盘 "bound"能调用
**** closure 闭包
**** byte-code function 被编译的函数对象

**** autoload object (lisp library)
as "eval-buffer"
***** load function
autoload /require/load
*** function test
functionp
subrp object  :test a built-in funciton
(symbol-function 'message)
** 控制结构
*** if progn cond and  or while
** 排错
catch throw
error 
** debugging
** keymaps
*** key sequences 

* emacs 
** emacs(选项)(参数)
+<行号>：启动emacs编辑器，并将光标移动到制定行号的行；
-q：启动emacs编辑器，而不加载初始化文件；
-u<用户>：启动emacs编辑器时，加载指定用户的初始化文件；
-t<文件>：启动emacs编辑器时，把指定的文件作为中端，不适用标准输入（stdin）与标准输出（stdout）；
-f<函数>：执行指定lisp（广泛应用于人工智能领域的编程语言）函数；
-l<lisp代码文件>：加载指定的lisp代码文件；
-batch：以批处理模式运行emacs编辑器。
--debug-init
调试
gdb –annotate=3 test
无论上面的那种情况，都出现了一个现象：程序的输出不能显示，只有在程序退出的时候才显示出来。无论上面的那种情况，都出现了一个现象：程序的输出不能显示，只有在程序退出的时候才显示出来。无论上面的那种情况，都出现了一个现象：程序的输出不能显示，只有在程序退出的时候才显示出来。
gdb-many-windows 切换单窗格/多窗格模式
gdb-restore-windows 恢复窗格布局	
** Emacs 插件	
# ido, 类似于helm,和helm各有千秋我都用,五五开,
# imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置
# flymake 实时语法检查,通吃所有语言
# flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
*** emacs-w3m
     C-x C-w 保存
     q	关闭窗口
     Q	直接离开
     U	打开 URL
     C-x-k	关闭当前标签页
     G	在标签页中打开一个网址
     B	后退
     ESC I	图片另存为 
     =   	显示当前页面属性 
     N	前进
     R	刷新
     F   	提交表单 
     a	添加当前页到书签
     ESC a	添加该URL到书签
     v   显示书签
     E   编辑书签
     C-k 删除书签
     C-_ 撤消书签
     M   用外部浏览器打开链接
     C-c C-k	停止载入

** Chapter 1.   Emacs Basics
*** Section 1.2.   Files and Buffers Screen
**** frame 框架
menu/scroll bar/mode line/[tool bar]/the window(show buffer content)/echo area
**** point 
**** Echo area  === Minibuffer (when input)
**** Mode line
**** menu bar
*** Section 1.3.   A Word About Modes
Majode
Texundamental /View /Shell  /Outline /Indented text /Paragraph indent text /Picture 
HtmML/LateX/Compilation/cc/Java/Perl/SQL/Emacs Lisp/Lisp/Lisp interaction 
Minode
autll(enables word wrap)/Overwrite(replaces characters instead of inserting them)/Auto-save/Isearch/Flyspell/flyspell prog/
abbparagraph indent/refill/Artist(creating ASCII drawings using the mouse/ISO accents/Font lock(highlighting text)
comtion /Enriched/Info/VC (various version control systems)

*** Section 1.5.   About the Emacs Display
****  mode line
*** Section 1.6.   Emacs Commands
*** Section 1.7.   Opening a File
insertfile/find file
C-x i 插入文件
C-x C-v  find-alternate-file
*** Section 1.8.   Saving Files
wriile/save-buffer
*** Section 1.9.   Leaving Emacs
savffers-kill-terminal
*** Section 1.10.  Getting Help
describe-function/describe-key/describe-variable
** Chapter 2.   Editing
*** Section 2.1.   Moving the Cursor
refill-mode(不满一行80个字就要凑满) auto-fill fill-paragraph fill-region
 C-f              forward-char                 Move forward one character (right).
 C-b              backward-char                Move backward one character (left).
 C-p              previous-line                Move to previous line (up).
 C-n              next-line                    Move to next line (down).
 M-f              forward-word                 Move one word forward .
 M-b              backward-word                Move one word backward .
 C-a              beginning-of-line            Move to beginning of line.
 C-e              end-of-line                  Move to end of line.
 M-e              forward-sentence             Move forward one sentence.
 M-a              backward-sentence            Move backward one sentence.
 M-}              forward-paragraph            Move forward one paragraph.
 M-{              backward-paragraph           Move backward one paragraph.
 C-v              scroll-up                    Move forward one screen.
 M-v              scroll-down                  Move backward one screen.
 C-x >           scroll-right
 C-x <           scroll-left
 C-x ]            forward-page                 Move forward one page.
 C-x [            backward-page                Move backward one page.
 M-<              beginning-of-buffer    Move to beginning of file.
 M->              end-of-buffer          Move to end of file.
 (none )          goto-line              Go to line n of file.
 (none )          goto-char              Go to character n of file.
 C-l              recenter               Redraw screen with current line in the center.
 M- n             digit-argument         Repeat the next command n times.
 C-u n            universal-argument     Repeat the next command n times (four times if you omit n)
*** Section 2.2.   Deleting Text
kill-ring
C-d             delete-char                 Delete character under cursor.
Del             delete-backward-char        Delete previous character.
M-d             kill-word                   Delete next word.
M-Del           backward-kill-word          Delete previous word.
C-k             kill-line                   Delete from cursor to end of line.
M-k             kill-sentence               Delete next sentence.
C-x Del         backward-kill-sentence      Delete previous sentence.
C-y             yank                        Restore what you've deleted.
C-w Edit    Cut kill-region                 Delete a marked region (see next section).
(none )         kill-paragraph              Delete next paragraph.
(none )         backward-kill-paragraph     Delete previous paragraph.

*** Section 2.3.   Marking Text to Delete, Move, or Copy
 C-@ or C-Space        set-mark-command                 Mark the beginning (or end) of a region.
 C-x C-x               exchange-point-and-mark          Exchange location of cursor and mark.
 C-w                   kill-region                      Delete the region.
 C-y                   yank                             Paste most recently killed or copied text.
 M-w                   kill-ring-save                   Copy the region (so it can be pasted with C-y).
 M-h                   mark-paragraph                   Mark paragraph.
 C-x C-p               mark-page                        Mark page.
 C-x h                 mark-whole-buffer                Mark buffer.
 M-y                   yank-pop                         After C-y , pastes earlier deletion.
*** Section 2.4.   Emacs and the Clipboard
*** Section 2.5.   Editing Tricks and Shortcuts
 C-t             transpose-chars                       Transpose two letters.
 M-t             transpose-words                       Transpose two words.
 C-x C-t         transpose-lines                       Transpose two lines.
 (none )         transpose-sentences                   Transpose two sentences.
 (none )         transpose-paragraphs                  Transpose two paragraphs.
 M-c             capitalize-word                       Capitalize first letter of word.
 M-u             upcase-word                           Uppercase word.
 M-l             downcase-word                         Lowercase word.
 Meta - M-c      negative-argument; capitalize-word    Capitalize previous word.
 Meta - M-u      negative-argument; upcase-word        Uppercase previous word.
 Meta - M-l      negative-argument; downcase-word      Lowercase previous word
*** Section 2.6.   Canceling Commands and Undoing Changes
 C-g             keyboard-quit                         Abort current command.
 C-x u           advertised-undo [8]                   Undo last edit (can be done repeatedly).
 C-_             undo                                  Undo last edit (can be done repeatedly).
 (none )         revert-buffer                         Restore buffer to the state it was in when the file was last saved (or auto-saved).
*** Section 2.7.   Making Emacs Work the Way You Want
(define-key global-map "\C-x\C-u" 'undo)
** Chapter 3.   Search and Replace
*** Section 3.1.    Different Kinds of Searches
*** Section 3.2.   Search and Replace
C-M-s Enter    Search     re-search-forward          Search for a regular expression
C-M-r Enter    Search     re-search-backward         Search for a regular expression
C-M-s Edit     Search     isearch-forward-regexp     regular expression.
C-M-% Edit     Replace    query-replace-regexp       Query-replace a regular expression.
M-%   query-replace
replace-string
C-s     isearch-forward
*** Section 3.3.   Checking Spelling Using Ispell
ispell-change-directory
ispell-buffer
ispell-word
ispell-complete-word
ispell-region
flyspell-buffer
*** Section 3.4.   Word Abbreviations
      (setq-default abbrev-mode t)
      (read-abbrev-file "~/.abbrev_defs")
      (setq save-abbrevs t)

** Chapter 4.    Using Buffers, Windows, and Frames
*** Section 4.1.    Understanding Buffers, Windows, and Frames
*** Section 4.2.    Working with Multiple Buffers
*** Section 4.3.   Working with Windows
M-x windmove-left /right /down/up
*** Section 4.4.   Working with Frames
C-x 5 1/2/3/0 : 对frame类似的操作
0:(delete-frame)
1:只剩一个frame了 (delete-other-frames)
2:分割成两个frame (make-frame-command)

*** Section 4.5.   More About Buffers
C-x C-q            Read-Only Buffers
*** Section 4.6.   More About Windows
balance-windows    C-x +
compare-windows
*** Section 4.7.    Holding Your Place with Bookmarks
C-x r m : 设置书签bookmark
C-x r b : 跳到bookmark处
** Chapter 5.    Emacs as a Work Environment
*** Section 5.1.    Executing Commands in Shell Buffers
*** Section 5.2.    Using Dired, the Directory Editor
 A                dired-do-search                                   Do a regular expression search on marked files;
 B                dired-do-byte-compile
 C                dired-do-copy    
 d                dired-flag-file-deletion
 D                dired-do-delete     Query for immediate deletion.
 e                dired-find-file     Edit file.
 f                dired-advertised-find-file
 g                revert-buffer       Reread the directory from disk.
 G                dired-do-chgrp      Change group permissions.
 h                describe-mode       Display descriptive help text for Dired.
 H                dired-do-hardlink   Create a hard link to this file;                                           
 i                dired-maybe-insert-subdir         
 k                dired-do-kill-lines Remove line from display (don't delete file).
 L                dired-do-load       Load file.
 m or * m Mark    dired-mark          Mark with * .
 M                dired-do-chmod      Use chmod command on this file.
 n                dired-next-line     Move to next line.
 o                dired-find-file-other-window
 C-o              dired-display-file  Find file in another window; don't move there.
 O                dired-do-chown      Change ownership of file.
 p                dired-previous-line
 P                dired-do-print      Print file.
 q                quit-window         Quit Dired.
 Q                dired-do-query-replace        Query replace string in marked files.
 R                dired-do-rename    Rename file.
 S                dired-do-symlink
 s                dired-sort-toggle-or-edit
 t                dired-toggle-marks
 u                dired-unmark       Remove mark.
 v                dired-view-file    View file (read-only).
 w                dired-copy-filename-as-kill
 x                dired-do-flagged-delete
 y                dired-show-file-type   Display information on the type of the file using the file command.
 Z                dired-do-compress      Compress or uncompress file.
 ~                dired-flag-backup-files Flag backup files for deletion; C-u ~ removes flags
 #                dired-flag-auto-save-files            Flag auto-save files for deletion; C-u # removes flags.
 &                dired-flag-garbage-files    Flag "garbage" files for deletion.
 .                dired-clean-directory       Flag numbered backups for deletion (if any).
 =                dired-diff                  Compare this file to another file (the one at the mark).
 M-=              dired-backup-diff           Compare this file with its backup file.
 !                dired-do-shell-command      Ask for shell command to execute on the current
 +                dired-create-directory      Create a directory.
 >                dired-next-dirline          Move to next directory.
 <                dired-prev-dirline          Move to previous directory.
 ^                dired-up-directory          Find the parent directory in a new Dired buffer.
 $                dired-hide-subdir           Hide or show the current directory or                
 M-$              dired-hide-all              Hide all subdirectories, leaving only their names;
C-M-n             dired-next-subdir   Move to next subdirectory (if you've inserted subdirectories using i ).
C-M-p             dired-prev-subdir  Move to previous subdirectory (if you've inserted subdirectories using i ).                 
C-M-u             dired-tree-up                  If you've inserted subdirectories using i , move to the parent directory in this buffer.
\**                dired-mark- executables
\* / Mark    dired-mark-directories
\* @ Mark         dired-mark-symlinks
M-}                 dired-next-marked-file
% d Regexp           dired-flag-files-regexp 
% g Regexp           dired-mark-files-containing-regexp
% l Regexp            dired-downcase  
% R Regexp           dired-do-rename-regexp                
% u Regexp           dired-upcase     
*** Section 5.3.   Printing from Emacs
print-buffer lpr-bufferf
print-region lpr-region
ps-print-buffer-with-faces   postscript file
*** Section 5.4.    Reading Manpages in Emacs
man
*** Section 5.5.    Using Time Management Tools
calendar
(setq calendar-week-start-day 1) weeks start on Monday ,default on Sunday
 C-f                           calendar-forward-day          Move forward a day.
 C-b                           calendar-backward-day         Move backward a day.
 C-n                           calendar-forward-week         Move forward a week.
 C-p                           calendar-backward-week        Move backward a week.
 M-}                           calendar-forward-month        Move forward one month.
 M-{                           calendar-backward-month       Move backward a month.
 M-r : 将光标移动到屏幕中间那行
 C-x ]                         calendar-forward-year         Move forward a year.
 C-x [                         calendar-backward-year        Move backward a year.
diary
(setq european-calendar-style 't)指定欧洲日历类型
** Chapter 6.   Writing Macros
*** Section 6.1.   Defining a Macro
F3 or C-x ( 
F4 or C-x )
*** Section 6.2.    Tips for Creating Good Macros
*** Section 6.3.    A More Complicated Macro Example
*** Section 6.4.   Editing a Macro
edit-kbd-macro C-x C-k e
exit the macro editing buffer C-c C-c
*** Section 6.5.   The Macro Ring
 kmacro-view-macro
 C-x C-k C-d (for kmacro-delete-ring-head ). This deletes the most recently defined keyboard macro.
 C-x C-k C-t (for kmacro-swap-ring ). This transposes macros 1 and 2.
 C-c C-k C-p (for kmacro-cycle-ring-previous ).
 C-x C-k C-p to move to the previous macro.
*** Section 6.6.    Binding Your Macro to a Key
 The key sequences C-x C-k 0 through 9 and capital A through Z are reserved for user macro bindings.
 C-x C-k n (for name-last-kbd-macro ) 调用时用Ｍ-x name
 C-x C-k r (for apply-macro-to-region-lines ) 在一块region(选区)执行macro
*** Section 6.7.    Naming, Saving, and Executing Your Macros
*** Section 6.8.   Building More Complicated Macros
*** Section 6.9.    Executing Macros on a Region
*** Section 6.10.    Beyond Macros
 C-u C-x q      (none)                   Insert a recursive edit in a macro definition.
 C-M-c          exit-recursive-edit      Exit a recursive edit.
 C-x C-k b      kmacro-bind-to-key       Bind a macro to a key (C-x C-k 0 -9 and A -Z are reserved for macro bindings).
** Chapter 7.    Simple Text Formatting and Specialized Editing
*** Section 7.1.   Using Tabs
edit-tab-stops (设定tab的宽度)
typewriter-style tabs, press C-q Tab
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)Emacs inserts only spaces when you press Tab 
*** Section 7.2.   Indenting Text
C-j (for newline-and-indent )
C-x Tab (for indent-rigidly )
C-M \ (for indent-region)
C-M-o (for split-line )
       increase-left-margin
       decrease-left-margin
       increase-right-margin
       decrease-right-margin
*** Section 7.3.   Centering Text
word wrap auto-fill mode
center-region
center-line
center-paragraph
set-justification-center                 Center selected text.
*** Section 7.4.   Using Outline Mode
*** Section 7.5.   Rectangle Editing
C-x r y : 执行矩形区域的粘贴
C-x r t  (string-rectangle START END STRING)  replace rectangle contents with STRING on each line
C-x r k  kill-rectangle 执行矩形区域的剪切 [范围是光标处到缓冲头的一个矩形],可以选择区块

*** Section 7.6.   Making Simple Drawings
** Chapter 8.   Markup Language Support
*** Section 8.1.   Comments
M-; ( indent-for-comment ).
C-x ; ( set-comment-column ).
comment-region
kill-comment
*** Section 8.2.   Font-Lock Mode  
for coloring code to make it easier to read.
*** Section 8.3.   Writing HTML
C-c C-t (for sgml-tag ) 
(setq user-mail-address "cdickens@great-beyond.com")
(setq user-full-name "Charles Dickens")
C-c Tab sgml-tags-invisible(网页视图模式)
C-c C-v(for browse-url-of-buffer )
C-c C-s(html-autoview-mode )开关 html-autoview-mode每次保存浏览器打开
*** Section 8.4.   Writing XML
*** Section 8.5.    Marking up Text for TEX and LATEX
** Chapter 9.   Computer Language Support
*** Section 9.1.    Emacs as an IDE
C-x `            next-error
C-c C-c    Visit the source code for the current error message.
*** Section 9.2.   Writing Code
(autoload 'function "filename" "description" t)
(autoload 'php-mode "php-mode" "PHP editing mode." t)
(setq auto-mode-alist (cons '("\\.php$" . php-mode) auto-mode-alist))
C-h s (for describe-syntax )
C-M-\         indent-region             Indent each line between the cursor and mark.
M-m           back-to-indentation       Move to the first nonblank character on the line.
M-^           delete-indentation        Join this line to the previous one.
etags
etags *.[ch]
visit-tags-table(default is TAGS file)
M- . find-tag
C-x 4 . (for find-tag-other-window )
M- , (for tags-loop-continue ) 
tags-query-replace
list-tags

Fonts and Font-lock Mode
font-lock-mode
(global-font-lock-mode t)
*** Section 9.3.    C and C++ Support

*** Section 9.4.   Java Support
*** Section 9.5.    The Java Development Environment for Emacs (JDEE)
CEDET ->(http://cedet.sourceforge.net/ )
cd cedet
shell$make EMACS=/path/to/emacs
update .emacs file:
;; Turn on CEDET's fun parts
(setq semantic-load-turn-useful-things-on t)
;; Load CEDET
(load-file "/path-to-cedet/common/cedet.el")
*** Section 9.6.   Perl Support
*** Section 9.7.   SQL Support
*** Section 9.8.   The Lisp Modes
  C-M-b         backward-sexp         Move backward by one S-expression.
  C-M-f         forward-sexp          Move forward by one S-expression.
  C-M-t         transpose-sexps Transpose the two S-expressions around the cursor.
** Chapter 10.   Customizing Emacs
*** Section 10.1.    Using Custom
customize-apropos(恰当的)
*** Section 10.2.    Modifying the .emacs File Directly
**** `~/.emacs',or `~/.emacs.el',or `~/.emacs.d/init.el'
**** lisp libraries
***** load-path
*** Section 10.3.    Modifying Fonts and Colors
*** section 10.3.    Input mode
**** 输入法切换 `C-\' (toggle-input-method')
*** Section 10.4.    Customizing Your Key Bindings
(define-key keymap "keystroke" 'command-name)
(global-set-key "keystroke" 'command-name)==(define-key global-map ...) 
(local-set-key "keystroke" 'command-name)
 \C-x                                          C-x (where x is any letter)
 \C-[ or \e                                    Esc
 \M                                            Meta
 \C-j or \n                                    Newline
 \C-m or \r                                    Enter
 \C-i or \t                                    Tab
*** Section 10.5.    Setting Emacs Variables
(setq-default left-margin 4)
*** Section 10.6.    Finding Emacs Lisp Packages
C-h p (for finder-by-keyword )
*** Section 10.7.    Starting Modes via Auto-Mode Customization
*** Section 10.8.    Making Emacs Work the Way You Think It Should
--no-init-file , -q load neither ~/.emacs nor default.el
--no-site-file do not load site-start.el
-debug
(setq inhibit-default-init t) ; no global initialization(不会加载初始化文件了,一行的.emacs)
emacs -u xxx 使用xxx的配置文件
*** seciton 10.9.     编码
**** 查看文件当前编码/显示文件编码顺序
describe-coding-system
**** 编码设置
(setq buffer-file-coding-system 'utf-8)  默认buffer编码是utf-8,(写文件)
(prefer-coding-system 'utf-8)   指定文件编码,此时buffer新建和读取
都默认是utf-8,也可以M-x prefer-coding-system 只执行一次
**** 匹配文件编码
***** 保存文件时采用的编码C-x <RET> f coding <RET>
(setq buffer-file-coding-system 'utf-8) 这样修改文件后,或打开文件后,就用这种编码保存
***** 接下来用什么编码编写文件 C-x <RET> c coding <RET>
***** 重新用编码载入文件 C-x <RET> r coding <RET>
***** 一块区域重新编码 M-x recode-region <RET> rightcoding <RET> wrongcoding
**** 输入二进制值,非格式化字符查看ascii表
(quoted-insert ARG)    C-q ARG ARG是八进制形式的
(setq read-quoted-char-radix 10) 改成十进制形式
(setq read-quoted-char-radix 16) 十六进制形式
** Chapter 11.   Emacs Lisp Programming
*** Section 11.1.    Introduction to Lisp
(function-name argument1 argument2 ...)=== method_name (argument1,argument2,...) java
number:5489, 5.489e3, 548.9e1, and so on   
characters (+ ?a 3) (+ ?\t 2) (+ ?\C-b 1) ?A
string "hello world,\" nimeide .\" "
bool t nil false(不存在)
symbol to refer with a single quote (')
# global variable
(setq var 3) (+ var 2)  
(setq thisvar 2
       thatvar 1
       theothervar 3 )
Defining Functions
   (defun count-words-buffer ( )
      (let ((count 0))
        (save-excursion
           (goto-char (point-min))
           (while (< (point) (point-max))
              (forward-word 1)
              (setq count (1+ count)))
           (message "buffer contains %d words." count))))
# execute
(count-words-buffer)
# make it available for interactive use
(interactive "prompt-string")
 Code                                     User is prompted for :
 b       Name of an existing buffer
 e       Event (mouse action or function key press)
 f       Name of an existing file
 n       Number (integer)
 s       String
         Most of these have uppercase variations
 B       Name of a buffer that may not exist
 F       Name of a file that may not exist
 N       Number, unless command is invoked with a prefix argument, in which case use the
         prefix argument and skip this prompt
 S       Symbol
(interactive "nPercent: ") 
(defun replace-string (from to)
   (interactive "sReplace string: \nsReplace string %s with: ")
   ...)

# let 设定local variable
(let ((var1 value1) (var2 value2) ... )   
   statement-block)
(+ (let ((chang 2) (kuan 3)) (+ chang kuan)) 1)
# save-excursion tells emacs to remember the location of cursor at the beginning of the function,and go back there after executing
# any statements in its body.
(while condition           statement-block)
# message
 %s                   String or symbol
 %c                   Character
 %d                   Integer
 %e                   Floating point in scientific notation 
 %f                   Floating point in decimal-point notation
 %g                   Floating point in whichever format yields the shortest string
For example:
(message "\"%s\" is a string, %d is a number, and %c is a character"
             "hi there" 142 ?q)
(message "This book was printed in %f, also known as %e." 2004 2004)
(message "This book was printed in %.3e, also known as %.0f." 2004 2004)

#+BEGIN_SRC lisp
(defun count-words-buffer ( )
   "Count the number of words in the current buffer;
print a message in the minibuffer with the result."
   (interactive)
   (save-excursion
     (let ((count 0))
         (goto-char (point-min))
         (while (< (point) (point-max))
           (forward-word 1)
           (setq count (1+ count)))
(message "buffer contains %d words." count))))
#+END_SRC
*** Section 11.2.    Lisp Primitive Functions
 Arithmetic      +,-,*,/
                 % (remainder)  得到余数
                 1+ (increment)     (参数加上1)
                 1- (decrement)
                 max , min (function 返回最大/小的值)
 Comparison > , < , >= , <=
                 /= (not equal)
                 = (for numbers and characters)  只能是比较整数和字符
                 equal (for strings and other complex objects)
 Logic           and , or , not
(and (> 4 2) (> 3 1) (> 2 3))

Statement Blocks/返回值是最后一个表达式的值
    (progn
       statement-block) 
       # let 可以省略 progn
    (let (var1 var2 ...)    
       statement-block)
(let ( kuai (chang 2))
(+ chang 1)
)

(if condition true-case false-block)

*** Section 11.3.    Syntax of Regular Expressions
**** special character ‘$^.*+?[\’ 需要加\ 转义
(replace-regexp "\\<program\\('s\\|s\\)?\\>" "module\\1")
 .                                   Match any character except a new line.
 *                                   Match 0 or more occurrences of preceding char or group. 默认最大匹配,加了?就可以限制长度了
 +                                   Match 1 or more occurrences of preceding char or group. 'ca+r'   car caaar ..
 ?                                   Match 0 or 1 occurrences of preceding char or group.  ‘ca?r’ar car
 [...]                               Set of characters; 字符集中的一个/ ^ ;特殊字符不用转义了 ‘[]a]’
 '[:alnum:]'  character class 形式 letter or digit
 \\(                                 Begin a group.
 \\)                                 End a group.
 \\|                                 Match the subexpression before or after \\|.
 ^                                   At beginning of regexp, match beginning of line or string. 换行符后面开始匹配
 $                                   At end of regexp, match end of line or string. 这个匹配换行符
 \n                                  Match Newline within a regexp.
 \t                                  Match Tab within a regexp.
 \\<                                 Match beginning of word.
 \\>                                 Match end of word.
‘\{N\}’ 重复N次 ‘x\{4\}’ matches the string ‘xxxx’ and nothing else.
‘\{N,M\}' 重复 N到M次   xxx xxxx xxxxx 


*** Section 11.4.    Building an Automatic Template System
*** Section 11.5.    Programming a Major Mode
*** Section 11.6.    Customizing Existing Modes
*** Section 11.7.    Building Your Own Lisp Library
***Chapter 12.   Version Control
*** Section 12.1.    The Uses of Version Control
*** Section 12.2.    Version Control Concepts
*** Section 12.3.    How VC Helps with Basic Operations
*** Section 12.4.    Editing Comment Buffers
*** Section 12.5.    VC Command Summary
*** Section 12.6.    VC Mode Indicators
*** Section 12.7.    Which Version Control System?
*** Section 12.8.    Individual VC Commands
*** Section 12.9.    Customizing VC
*** Section 12.10.    Extending VC
*** Section 12.11.     What VC Is Not
*** Section 12.12.    Using VC Effectively
*** Section 12.13.    Comparing with Ediff
***Chapter 13.   Platform-Specific Considerations
*** Section 13.1.    Emacs and Unix
*** Section 13.2.    Emacs and Mac OS X
*** Section 13.3.    Emacs and Windows
***Chapter 14.   The Help System
*** Section 14.1.    Using the Tutorial
*** Section 14.2.    Help Commands
*** Section 14.3.    Help with Complex Emacs Commands
*** Section 14.4.    Navigating Emacs Documentation
*** Section 14.5.   Completion
***Appendix A.   Emacs Variables
Appendix B.    Emacs Lisp Packages
Appendix C.    Bugs and Bug Fixes
Appendix D.   Online Resources
 Appendix E. Quick Reference
 
不敢独享，与大家分享。也可以在Emacs中用C-x C-h列出全部命令，查找C-x r c，所有列模式命令都是以C-x r开始的
C-x r C-@                    point-to-register
C-x r SPC                    point-to-register
C-x r +        increment-register
C-x r b        bookmark-jump
C-x r c        clear-rectangle
先用C-space或者C-@设一个mark，移动光标到另一点，使用C-x r c可以清楚mark到光标处的矩形区域，该区域留下空白。
C-x r d        delete-rectangle
删除矩形区域，不留空白，后面的字符前移
C-x r f        frame-configuration-to-register
C-x r g        insert-register
C-x r i        insert-register
将某个寄存器的内容插入某处
C-x r j        jump-to-register
C-x r k        kill-rectangle
就是剪切某个选定的矩形区域，用C-x r y可以贴上
C-x r l        bookmark-bmenu-list
C-x r m        bookmark-set
C-x r n        number-to-register
C-x r o        open-rectangle
在选定的矩形区域插入空白
C-x r r        copy-rectangle-to-register
将选定的矩形区域复制到某个寄存器
C-x r s        copy-to-register
C-x r t        string-rectangle
在选定区域所有列前插入同样的字符
C-x r w        window-configuration-to-register
C-x r x        copy-to-register
C-x r y        yank-rectangle
类似于矩形区域的粘贴，就是将刚用C-x r k剪切的矩形区域粘贴过来
C-x r C-SPC    point-to-register
* lisp
; LISP 原子常量： 数值，字符串(带双引号的文本)，紧跟单引号的列表
3.1415926 [在这里按 C-x C-e 查看结果]
"i ahadd"
("i ahadd") ; ERROR 不紧跟 ' 号的列表第一个符号必须是已定义的函数名
'("i ahadd")
'(one two three four)
'(this list has (a list inside of it)) [在这里按 C-x C-e 查看结果]

; 求值，非常类似于前缀表达式
(* (+ 2 3) (- 1 3))
'(* (+ 2 3) (- 1 3)) ; 注意，这是一个文本

string 操作 (concat "abc" "def")	   
(substring "The quick brown fox jumped. " 16 19)


; 全局变量定义 set setq 
(set 'PI 3.1415926) ; 第一个变量符号必须紧跟单引号 '
PI
(setq E 2.71) ; 第一个变量会自动加上单引号 '
E

; 局部变量定义 let
(let
( (person 'me)
(dream '(a house))
)
(message "%s dream is %s." person dream)
)

person ; Error: person 未定义

; 一个计数器
(setq counter 0)
(setq counter (+ counter 1))
counter

fill-column ; EMACS 内建变量
(* 2 fill-column)
(fill-column) ; ERROR： fill-column 是未定义的函数


(this is an unquoted list) ; Error： this 是未定义的函数
(error info) ; Error： info 是未定义的变量

; 内建函数 message， 类似于 C 的 prinf
(message "the name of this buffer is %s." (buffer-name))
(message "the buffer is %s." (current-buffer))
(message "the name of this buffer is %s." (buffer-file-name))
(message "the value of this fill-column is %d." fill-column)

; buffer-size point 等都是内建函数，只是不需任何参数列表
(buffer-size)
(point)
(point-max)
(point-min)
(other-buffer)
(switch-to-buffer (other-buffer))

; 函数定义
(defun multiply(x y)
"将给定的两个数相乘"
(* x y)
)
(multiply 3 5)


; if 测试
; (if (expr) (action-if-true) (action-if-false)[可选])
; LISP nil为假 ， 非 nil 为真 
(if () 'true 'false) ; 空列表() 视为假
(if (- 1 1) 'true 'false) ; 零 非假，因为它不是空列表，而是 0

; while 测试
; (while (expr) (action1-if-true) (action2-if-true) ... (actionN-if-true))

(let ((i 10) (result ""))
(while (>= i 0)
(setq result (append result (list i)))
(setq i (1- i))
)
(message "result = %s." result)
)

; cond 测试
; (cond (expr1 action1-if-true)
; (expr2 action2-if-true)
; ...
; (exprN actionN-if-true)
; 
; )
; 类似于 switch-case
(defun signof(num)
"测试给定数的符号"
(let ((sign))
(cond
((> num 0) (message "%d is a positive." num))
((eq num 0) (message "%d is zero." num))
((< num 0) (message "%d is a negative." num))
)
)
)
(signof 1)
(signof -1)
(signof 0)

; 交互函数定义
(defun IsGreaterThanZero(num)
"测试是否给定参数是否大于零"
(interactive "p")
(if (> num 0)
(message "%d is greater than 0. " num)
(message "%d is not greater than 0." num)
)
)
; 可以作为非交互函数调用
(IsGreaterThanZero 0)
(IsGreaterThanZero 1)
(IsGreaterThanZero -1)

; 调用内建函数
(concat "abc" "123")
(concat "oh" (list 1 2) "god!" )
(substring "hei, look!" 5 9)
(concat "hei, " (substring "hei, look!" 5 9) "!") ; 嵌套表达式

; 带任意数量参数的函数
(*) (* 3) (* 1 2 3 4 5)
(+) (+ 3) (+ 1 2 3 4 5)
(concat) (concat "1") (concat "1" () "(+ 33 44)")

; 参数类型出错 hello 必须是数值
(+ "hello" 2) ; ERROR

; 这是给出的错误消息
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p "hello")

; 递归函数
(defun refac(num)
"递归计算阶乘 n! = 1 * 2 * ... * n"
(interactive "p")
(if (eq num 0) 1
(* (refac(1- num)) num)
)
)
(defun printfac(num)
"打印阶乘值"
(interactive "p")
(message "%d! = %d." num (refac num))
)
(refac 0)
(refac 1)
(refac 3)
* Peter Norvig：自学编程，十年磨一剑
让我们来仔细看看《3天学会C++》这种速成教材实际上意味着什么：
●学会：在3天时间里你几乎没有时间去写任何有意义的程序，就更不要谈什么从编程中获得经验和教训这种事情了。你也不可能有时间和有经验的程序员一起工作和交流，也不会体验到在真正的C++环境下工作是什么感觉。长话短说吧，你就是没时间，也学不到什么。所以这种书籍最多也就让你有个粗浅的印象，但是绝对不可能有深入的理解。就像亚历山大教皇说的那样，“浅尝辄止是很危险的”。
●C++: 如果你有其他编程语言的基础，那么3天之内你也许可以学到C++的一些语法，但即使是这样，你还是无法了解如何使用该语言编程。简言之，如果你之前是一个Basic程序员，那么经过3天的学习，你会成为一个“能使用C++语法编写Basic风格程序的程序员”，不过这样是没法发挥出C++语言本身的优势的（说句不好听的，你连怎么犯C++的典型错误都不会）。仅仅知道一点语法意味着什么呢？Allan Perlis曾经说过：“一个无法改变你思维方式的编程语言是不值得学习的。”；另一种可能性是，你可以只学一点点C++知识(类似的，或者一点点JavaScript,或者一点点Flex Script)，然后就可以利用现有的工具制作应用接口，完成特定的编程任务了。但是这样的行为并不意味着你“会”编程了，你只是会使用这个工具完成任务而已。
●3天：很不幸，3天是远远不够的，往下看你就知道了。

研究人员(Bloom (1985)、 Bryan & Harter (1899，见文后参考书目)、Hayes (1989)、Simmon & Chase (1973，见文后参考书目) 的一系列调查研究显示，在各个领域内，要想获得专业级别的水平，大约需要10年时间的努力。参与此项调查的领域包括：国际象棋，作曲，发报，绘画，钢琴演奏，游泳，网球等。科学家们从神经心理学和拓扑学的角度对这些领域进行研究，并得出结论。若要在某一领域内达到专家级的水平，其关键在于“审慎地重复”，也就是说，并非是机械地，一遍又一遍地练习，而是要不断地挑战自我，试图超越自身当前的水平，通过不断的尝试挑战，并在尝试的过程中和尝试之后对自身的表现进行分析和总结，吸取经验，纠正之前犯过的各种错误。把这一“审慎”的过程不断重复，才能取得成功。
所谓的“捷径”是不存在的，即使对于莫扎特这种天才来说，也没有捷径可走，尽管4岁就开始作曲，可是他也花了13年的时间，才真正地写出了世界级的作品。再举一个例子，甲壳虫乐队（The Beatles）,他们似乎在1964年凭借一系列热门单曲和其在艾德沙利文秀（The Ed Sullivan show）上的演出一炮而红，但是你也许不知道，他们早在1957年就在利物浦和汉堡两地进行小规模演出了，而在此之前的非正式演出更是不计其数。甲壳虫乐队的主要成名曲《Sgt. Peppers》，则是1967年才发行的。Malcolm Gladwell公布了他对柏林音乐学院所作的一项研究的报告，该研究对比了一个班里的学习成绩为上、中下三个档次的学生，并逐一询问他们进行音乐练习的时间
这三个档次中的所有人，大约都是在5岁的时候开始练习音乐的，一开始的时候大家练习音乐的时间都差不多，大约一周2到3小时。但是到了八岁左右，大家的区别就开始体现了。后来成为班里最好的那一部分学生开始比别的学生练习得更多，大概每周6到9小时，12岁的时候每周8小时，14岁的时候每周16小时，往后则越来越多，直到20岁左右，他们每周练习音乐的时间已经超过30小时了。在20岁的年纪，那些精英级别的演奏家们都有累计超过10000小时的音乐练习时间。相比之下，仅有部分优等生能达到8000小时的累计练习时间，而那些音乐教师级别的学生，他们的累计练习时间只有4000小时左右。
所以，也许这个让你能达到专业等级的神奇时间应该是10000小时，而不是10年。（Henri Cartier-Bresson (1908-2004)说过，“（作为摄影师），你所拍摄的头10000张照片都是垃圾”，但即使是垃圾作品，他拍一张照片也要花接近一小时。）Samuel Johnson (1709-1784)认为这个时间应该更长：“在任何一个领域要想做到极好,势必穷尽一生的精力，否则根本无法企及。” Chaucer (1340-1400)也发出过“生命如此短暂，技能如此高深”的感叹。Hippocrates (c. 400BC)因写下了如下的句子而被人称颂：“ars longa, vita brevis”，该句是来自于一个更长的引用：”Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, 这段话翻译成英语就是：“生命很短暂，但是技艺却很高深，机遇转瞬即逝，探索难以捉摸，抉择困难重重”。这段话是用拉丁文写的。在拉丁文里，ars可以翻译为“技艺”或者“艺术”，但是在古希腊文里，ars只能做“技能”的意思，而没有“艺术”的意思。

 

你想当程序员么？

下面是我列举的程序员成功“食谱”

●沉醉于编程，编程是为了兴趣。保持这种充满兴趣的感觉，以便于你能将其投入到你的10年/10000小时的编程时间中。
●程序. 最好的学习方式是“在实践中学习”。更技术一些地说：“一个人在某个专业领域方面能够达到最高水平，并不是因为这个人经验增长了以后而自动获得的，而是这个人为了进步所做出了专门的努力之后产生的结果。”(p. 366)“最有效的学习包括如下几个要素：明确并且难度适当的任务，适应学习者个人情况，及时的信息反馈，有重新开始和改正错误的机会）(p. 20-21) 《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书提供了上述有趣的观点
●同其他程序员交流，多阅读其他人写的程序。这些远比你看书或者上培训班重要
●如果你愿意的话，就选择去读一个计算机科学专业吧（当然你还可以去念这个专业的研究生）。如果你能做到这点，那么你就有机会找到一些需要计算机学位认证的工作，也会让你对这个行业有更深的理解。不过，如果你不是上学的料，那么你可以（当然需要有足够的毅力）靠自己学习，或者通过工作来积累经验。无论你采用哪种途径，光依靠书本是远远不够的。“如果说仅仅靠学习油画和调色技术无法创造出顶尖的画家的话，那么光学习计算机科学课程更不能造就顶尖的程序员。”，Eric Raymond这样说过，他著有《新黑客字典》一书。我所聘用过的最好的程序员仅仅只有高中文凭; 他写了很多伟大的软件，他有他自己的新闻组，并且通过股权赚够了钱，还开了家属于自己的夜店。（作者说的这个人是Jamie Zawinski，他是网景浏览器（Netscape）的早期开发这者之一，也是开源项目Mozilla和XEmacs的主要贡献者，他开了一家叫做DNA_lounge的夜店，位于旧金山的SoMa区——译者注）
●与其他程序员一起做项目。在某些项目中要尽量做到最好，在某些项目中却别做那么好。当你是最好的时候，你的领导能力就会得到锻炼，并激发你高瞻远瞩的视野。当你做得不好的时候，你就能知道你的领导怎么做事，以及他们不喜欢哪些事（因为领导总是把那些他们不爱做的杂事丢给他们认为不得力的人去做）
●尝试跟随其他程序员一起做项目。尝试去理解其他人所写的代码。看看如果你无法找到代码的作者本人的情况下，理解和修正他写的代码需要花费什么样的代价。同时也思考，如何规划你自己的程序代码，让它们更容易被其他人理解和维护。
●至少学习半打编程语言。包括一种支持类抽象的语言（例如Java或者C++），一种支持函数抽象的语言（例如Lisp或者ML）,一种支持语法抽象的语言（例如Lisp）,一种支持声明式编程的语言（例如Prolog或者C++模板），一种支持协同程序的语言（例如Icon或者Scheme）,一种支持平行并发编程的语言（例如Sial）
●牢记“计算机科学”中包含着“计算机”这个词。了解计算机需要花多长的时间执行一条指令，花多长时间从内存中获取一个字(word)（包括缓存命中和不命中两种情况），如果连续从磁盘中获取数据，时间消耗如何？以及需要花多少时间才能再磁盘上定位一个新的位置？
●尽量参与语言的标准化过程。往大了说，你可以试着加入ANSI C++委员会这样的专业组织，往小了讲，你也可以从自己的代码规范入手，限定代码缩进是需要2个空格宽还是4个空格宽。无论采用哪种方式，你都需要了解其他人对于语言的喜好，以及他们的喜好的程度，甚至你要知道他们为什么产生这样的喜好的原因。
●有良好的意识，能尽快适应语言标准化的成果。

要掌握上面所说的所有内容，光靠看书学习应该是很难做到的。当我的第一个孩子出生的时候，我几乎阅读了市面上所有的《如何…》指南书籍，但是我读完了以后还是觉得自己是个菜鸟。30个月以后，我的第二个孩子快出生时，我难道还要做一个书虫么？不！相反，我此时更依赖我的个人经验，这些经验相比于那些上千页的书籍，则更加有效和让我放心。
Fred Brooks所著的著名的论文《No Silver Bullets| 没有银弹》里向我们揭示了发现和培养软件设计人才的三步骤：
1.有组织地辨认顶尖的软件设计人才，越早越好
2.安排一个职业导师，为其职业前景指点迷津，并谨慎对待自己的职业履历
3.为成长中的设计师们提供机会，让他们能够互相激发促进。
即使一部分人已经具备了成为优秀软件设计人员的潜质，也需要经历工作的慢慢琢磨，方可展现才华。Alan Perlis则说得更加直接：“任何人都可以被‘教’成一个雕塑匠，但米开朗基罗则被‘教’如何不要成为一个雕塑匠，因为他要做的是雕塑大师，。这个道理放到编程大师身上同样管用。”Perlis认为，伟大的软件开发人员都有一种内在的特质，这种特质往往比他们所接受的训练更重要。但是这些特质是从哪里来的呢？是与生俱来的？还是通过后天勤奋而来？正如Auguste Gusteau（动画电影《料理鼠王》里的幻象大厨）所说，“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我很情愿地说，将你生命中的大部分时间花在审慎地练习和提高上，这很重要！但是“无所畏惧”的精神，才是将促使这些练习成果凝聚成形的途径。或者，就像是《料理鼠王》里那个与Gusteau作对的刻薄的美食评论家Anton Ego说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家在成名前可能是任何人。”
所以尽管去书店大买Java/Ruby/Javascript/PHP书籍吧；你也许会发现他们真的挺管用。但是这样做不会改变你的人生，也不会让你在整体经验上有什么提高。24小时，几天，几周，做一个真正的程序员？光靠读书可读不出来。你尝试过连续24个月不懈努力提高自己么？呵呵，如果你做到了，好吧，那么你开始上路了……

== 启动Emacs, 缓冲区和工作模式==
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; 第一步首先启动Emacs: (在windows中可以双击emacs图标，在Linux中可以输入% emacs & )，
;; 然后在键盘上键入q 跳过系统欢迎的信息，
;; 先观察在Emacs屏幕的底部，会给出一堆关于当前的工作情况的信息，其中灰色的一行叫做状态行，
;; 在其中你会发现 *scratch* 的字样，这表示你当前的缓冲区(buffer)的名字。
;; 缓冲区也叫做工作区，在Emacs中打开一个文件，实际只是在Emacs中构造该文件的一个副本，放到缓冲区中，
;; 在Emacs中对该文件的编辑也是针对该副本的编辑，唯有保存改动时，Emacs才会把缓冲区中的内容在复制到原文件中去。
;; 状态行下面的那行，叫做辅助输入区(minibuffer),该minibuffer用于显示计算结果，以及和用户做交互。
;;
;; 
;; 如何切换Emacs的工作模式 
;; Emacs有各种各样功能各异的模式，工作模式的含义其实就是Emacs对当前的文本编辑工作
;; 更加的敏感，比如高亮和缩进，并且支持一些特殊的命令。
;; 为了实验本教程中的lisp命令，我们要让Emacs工作在lisp-interaction-mode工作模式下，
;; 这个模式可以让我们在缓冲区中和Emacs进行互动，并且直接执行Lisp命令,得到结果。
;; 进入lisp-interaction-mode的方法： 把光标移动到辅助输入区，键入M-x lisp-interaction-mode 
;; 然后回车。
 
== 表达式，变量和函数 ==
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 冒号在Lisp中表示注释
;; 在Elisp中做运算，调用函数的最简单的方式是
;; (function arg1 arg2) 
;; 这相当于通常的function(arg1,arg2)，下面的表达式，对两个数字进行加法运算
(+ 2 2)
 
;; Elisp中表达式可以通过括号来嵌套
(+ 2 (+ 1 1))

4
 
;; 在lisp-interaction-mode模式中，我们可以直接计算一个表达式,计算的方法是
(+ 3 (+ 1 2))
;; 
6
^ 把光标放在这里，并且键入Ctrl-j (之后将简写成C-j)
;; C-j是一个快捷命令，在后台，该快捷键将调用求值命令，并且把计算的结果
;; 插入到当前的缓冲区中
 
;; 如果不希望Emacs在缓冲区中插入计算结果，我们还可以在表达式的末尾使用C-x C-e组合键
;; C-x C-e的意思是: 先按下Ctrl-x 再按下Ctrl-e 
;; 这个命令会让Emacs在辅助缓冲区，也就是Emacs窗口的最底部那行显示计算结果
 
;; ELisp中的赋值函数是是setq，下面的表达式给变量my-name赋值"Bastien"
(setq my-name "Bastien")
;; ^ 把光标停在这里，再键入C-x C-e
 
;; 下面insert函数的作用是在光标所在出插入字符Hello
(insert "Hello!")
;; ^ 把光标停在这里，再键入C-x C-e
 
;; insert函数还可以两个常量字符，比如
(insert "Hello" " world!")

;; insert函数还可以接受变量作为参数，我们之前已经给my-name变量赋过值了
;; 所以下面命令的输出结果是 "Hello, I am Bastien"
(insert "Hello, I am " my-name)

;; defun命令用来定义一个函数,语法是
;; (defun 函数名 (参数列表) (函数体))
(defun hello () (insert "Hello, I am " my-name))
;; ^ 把光标停在这里，再键入C-x C-e 执行defun命令来定义函数
;; 通过defun命令，你已经在Emacs中安装了这个hello函数，这个函数就成为了Emacs的一部分，知道你退出Emacs或者改变hello的定义
 
;; 从下面开始，我们将不再提醒读者使用C-x C-e来定义函数和执行ELisp指令
 
;; 在Elisp中直接输入函数的名称就是调用该函数。
;; 下面的命令的输入结果是: Hello, I am Bastien
(hello)
 
;; 前面定义的hello函数不接受任何参数,过于简单，
;; 现在我们重新定义hello函数，让它接受一个参数name。 
(defun hello (name) (insert "Hello " name))
 
;; 然后调用新的hello函数，并且提供一个参数。
;; 下面命令的输出结果是"Hello you"
(hello "you")
 
== progn,let和交互式函数== 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 执行switch-to-buffer-other-window命令，将在在一个新的窗口中打开一个buffer
;; 该buffer命名叫做 test, 并且把光标移到新的buffer的窗口中。
(switch-to-buffer-other-window "*test*")
 
;; 要回到原来的buffer中，可以使用鼠标点击原来的buffer
;; 或者使用组合键 C-x o 
;; C-x o的意思是: 先按下Ctrl-x 再按下o
 
;; 如果要执行一系列的指令，可以使用流程函数progn，把函数命令连接起来.
;; 下面的命令,先打开一个新的buffer,再执行hello函数，该hello函数的参数是"you"
(progn
(switch-to-buffer-other-window "*test*")
(hello "you"))
 
;; 如果要清空一个buffer,可以调用erase-buffer函数。下面的命令先清空test buffer,再调用hello函数做打印
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "there"))
 
;; 在这一系列的质量后面再添加调用一个other-window函数，这样在hello函数被调用完毕之后
;; 光标自动回到之前的buffer窗口中
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "you")
(other-window 1))
 
;; let函数用来做局部变量的定义 下面的一系列命令中
;; let函数首先定义local-name变量的值为“you”
;; 然后接着执行括号中其它的语句块部分，这个功能和progn类似
(let ((local-name "you"))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello local-name)
(other-window 1))
 
;; format函数可以用做格式化的输出 其中%s表示该s的地方将被之后提供的一个字符串,即visitor替换
;; \n表示换行
(format "Hello %s!\n" "visitor")
 
;; 现在我们利用format函数来改进之前定义的hello函数
(defun hello (name)
(insert (format "Hello %s!\n" name)))
 
;; 执行这个函数结果是"Hello you"，并且光标换到下一行
(hello "you")
 
;; 下面我们再设计一个greeting函数，该函数接受一个参数name,
;; 在函数体的内部又使用了let函数，给一个局部变量your-name赋值
;; 最后把参数和局部变量格式化的打印出来
(defun greeting (name)
(let ((your-name "Bastien"))
(insert (format "Hello %s!\n\nI am %s."
name 
your-name ; 局部变量
))))
 
;; 执行greeting函数，并提供"you"字符串作为参数
(greeting "you")
 
;; read-from-minibuffer函数提供和用户交互的功能，这个函数可以帮助Elisp程序从用户处得到输入
(read-from-minibuffer "Enter your name: ")
 
;; 比如如果我们希望greeting函数能够从用户处得到姓名，并且做打印格式化的欢迎信息。
;; 可以先调用read-from-minibuffer在minibuffer中提示用户输入姓名，
;; 然后把得到的结果赋给局部变量your-name，
;; 最后insert函数在当前buffer中插入格式化的输出
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(insert (format "Hello!\n\nI am %s and you are %s."
from-name ; 格式化输出参数1
your-name ; 格式化输出参数2
))))
 
;; 执行这个函数
(greeting "Bastien")
 
;; 再稍加改进greeting 把结果打印在新的buffer中
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(insert (format "Hello %s!\n\nI am %s." your-name from-name))
(other-window 1)))
 
;; 执行这个函数
(greeting "Bastien")
 
== 列表和综合实例 ==
 
;; Lisp中使用括号构造列表，使用setq给变量赋值。
;; 下面的命令先构造一个列表，再把这个列表赋给list-of-names变量
(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
;; ^这里的单引号表示这是一个列表
 
;; 如果想要得到列表中的第一个元素，可以使用car函数
(car list-of-names)
 
;; 如果想要得到列表中的除第一个元素以外的其它元素，可以使用cdr函数
(cdr list-of-names)
 
;; 以后push函数可以在列表的头部插入新的元素，所以下面的命令将改变list-of-name中元素的个数
(push "Stephanie" list-of-names)
 
;; mapcar函数对列表中的把列表中的每一个元素分别取出来，赋给hello函数
(mapcar 'hello list-of-names)
 
;; 重新定义greeting函数，在一个新的，清空的buffer中，对list-of-names列表中的每一个元素，调用hello函数
;; 调用完毕之后，再让光标回到原的buffer中
(defun greeting ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(mapcar 'hello list-of-names)
(other-window 1))
 
;;执行这个函数，我们将得到一个名叫test的buffer，其中的内容是
;; Hello Stephanie!
;; Hello Sarah!
;; Hello Chloe!
;; Hello Mathilde!
;; 暂时先不要关闭这个buffer!后面还有用！ 
(greeting)
 
;; 下面我们对buffer做一些更有意思的事情！
;; 定义一个replace-hello-by-bonjour函数，顾名思义，就是把hello替换成bonjour
;; 该函数首先把光标移到一个叫做test的buffer中
;; 再把光标移到该buffer的开头
;; 从头开始搜索字符串Hello,并且替换成Bonjour
;; 结束之后在把光标移会到一开始的buffer中。
(defun replace-hello-by-bonjour ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min)) ;该函数把光标移到buffer的开头
(while (search-forward "Hello")
(replace-match "Bonjour"))
(other-window 1))
 
;; 其中 (search-forward "Hello") 在当前的buffer中做前向搜索
;; (while x y) 当x 的条件满足时执行y指令 ，当x返回nil时，while循环结束
 
;; 执行这个函数 替换test buffer中的hello
(replace-hello-by-bonjour)
 
;; test buffer中的结果如下
;; Bonjour Stephanie!
;; Bonjour Sarah!
;; Bonjour Chloe!
;; Bonjour Mathilde!
 
;; 在minibuff中，还会有一条错误信息 "Search failed: Hello".
;; 把(search-forward "Hello")一句换成如下就不会有错误信息了
;; (search-forward "Hello" nil t)
 
;; 其中 nil参数表示 搜索的区域不加限制，直到buffer结束
;; 其中t参数指示search-foward函数 跳过错误信息 直接退出
 
;; 新hello-to-bonjour如下：
(defun hello-to-bonjour ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
;; 对list-of-names列表中的每个元素 使用hello函数
(mapcar 'hello list-of-names)
(goto-char (point-min))
;; 搜索Hello替换成Bonjour
(while (search-forward "Hello" nil t)
(replace-match "Bonjour"))
(other-window 1))
 
;; 执行这个函数
(hello-to-bonjour)
 
;; 下面的boldify-names 函数 ，
;; 首先把光标挪到名叫test的buffer的开头，
;; 然后使用regular expression 搜索 “Bonjour + 其它任何内容” 的pattern，
;; 然后对找到的字符加粗。 
(defun boldify-names ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min))
(while (re-search-forward "Bonjour \\(.+\\)!" nil t)
(add-text-properties (match-beginning 1) ;返回匹配模式中，最先匹配的位置
(match-end 1) ;返回最后匹配的位置
(list 'face 'bold)))
(other-window 1))
 
;; 执行这个函数 
(boldify-names)
 
== 帮助和参考==
 
;; 在Emacs中我们可以通过如下的方式得到变量和函数的帮助信息
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; 下面的命令将打开整个Emacs Manual
;;
;; C-h i m elisp RET
;;
;; Emacs Lisp 教程
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html
 
;; Thanks to these people for their feedback and suggestions:
;; - Wes Hardaker
;; - notbob
;; - Kevin Montuori
;; - Arne Babenhauserheide
;; - Alan Schmitt
;; - LinXitoW
