** 前言
第4章,文字处理工具
该章介绍的是一些文字处理的软件工具，这些在shell脚本编写时，都会一再地使用。其中重要的有sort和uniq，在重组与降低数据量上 ，他们扮演很重要
的角色。本章还会带你看看如何重新编排段落、计算文字单位、显示文件以及取出文件的前几行、后几行数据。
第5章，管道的神奇魔力
该章以几个小型脚本为例，展示结合简单的Unix工具程序能够产生更强大、更灵活的工具。本章的内容采取cookbook（问题描述与解决方案）的
形式，他们共同的部分在于所有的解决方案都组合自线性的管道（pipelines）。
第6章，变量、判断、重复动作
该章介绍shell语言里不可或缺的部分。包含了shell变量与算法、退出状态的重要概念、如何判断，以及shell循环的处理。最后以shell的函数
作结束。
第7章，输入/输出、文件与命令执行
该章其实早就涉及到了，只是深化一下内容，shell语法的各种简式调用，替换、加引号、命令执行顺序，以及shell内置命令。
第8章，产生脚本
我们在这里会示范如何结合Unix的工具以处理更复杂的文本处理工作。
第9章，awk的惊人表现
该章介绍的是awk语言必备的组成部分。awk是一套功能强大且自给自足的语言。而awk程序更可以用来与其他软件工具箱里的其他程序
结合，以执行简单的数据提取、处理与格式编排工作。
第10章，文件处理
该章介绍了文件处理的几个重要工具。包括列出文件、产生临时文件，以及利用指定标准寻找文件的find命令。另外还有两个与磁盘
空间有关的重要命令，以及比较文件异同的几个程序。
第11章，扩展实例，合并用户数据库
将所有东西串起来，解决既有趣又难易适中的挑战性工作。
第12章，拼写检查
该章利用拼写检查工具，通过词典，ispell与aspell，适用于批处理的拼写检查。我们以awk写一个工具，来展现其厉害。
第13章，进程
job与job管理。sleep命令，这在脚本要等待某个命令时很重要。该章也教你怎么使用trap工具，他可以让shell脚本控制Unix的信号。
第14章，shell的可移植性议题 与扩展
这里说的更有用，哈哈，我们只是循序渐进教你，因为难题是只会越来越复杂，所以道高一尺魔高一丈，必须创造更复杂的工具来应对，
他们是对立统一的，不可分割。。该章最后会讨论各种不同的shell实现间，shell初始化与终结的差异。
第15章，安全的shell脚本：起点
该章讨论了项目中应该考虑的数据安全问题，而在之前的章节中我们都是忽略这种真是的客观环境的。
附录:编写手册页
该附录讲如何编写手册页。这个必备的技术，在传统的Unix的书籍里常被忽略。这里假设你已经是程序员，并且以完成了自己的项目，
编写帮助文档是你必须要面对的问题。
附录B，文件与文件系统
这个附录会介绍Unix的字节流文件系统，并与较复杂的文件系统对照，然后解释其简洁的好处。
附录c，重要的Unix命令列表
把重要的Unix命令列出，列出选项，可以速查该 表。

本书惯例
我们假设你已经知道，输入shell命令时，最后会按下Enter。Enter在某些键盘上被表示为Return。
提到Ctrl-x,X指的是任意字母，而不是x，所以代表的是键盘上的两个键而不是其他的何种东东。
其他特殊符号有换行好（ctrl-j）表示的符号，这在文本输入的时候起格式化作用，其他图片或程序中
是没有用处的。Backspace同于Ctrl-H，Esc，Tab，与Del，这些都是控制字符。
本书使用下面的字体惯例
斜体（Italic）
字体格式，多用在电子邮件、Internet URL、使用手册的引用。还用以表示参数，表示你在使用时，可以将他
置换为你要的值，以及为范例提供说明性文字。
等宽字体（Constant Width)
提及Unix文件名、扩展与内置命令、命令选项时，我们就会用到这个字体。正文段大部分都是这种紫铜。
粗体等宽字体（constant width bold）
这种字体用以区分比对文字中的正则表达式与shell通配符样式，在范例中，显示用户与shell交互的输入输出部分。起到强调的作用。

我们用的参考文件一般是man page,如grep(1)表示section为1 的man page。
2是系统函数，3是c库函数。

Windows系统下的Unix工具程序
许多的程序员初次接触Unix系统，
cygwin，模拟器还包括了berkeley socket api的tcp/ip网络。
cygwin环境使用自己的shell，自己的c编译器gcc，设计精良的mount命令提供了将Windows c:\path 的标记方式对应的unix 文件名。
djgpp提供了c/c++开发系统。dj.delorie 同志将gnu c++ 编译器g++ 移植到ms-dos.
uwin包是David Korn 与同事为了在Microsoft Windows 下使用UNIX环境而产生的项目。共享程序库posix.dll 提供了Unix系统调用
API的模拟器。 

背景。计算机追根溯源可以到巴蓓奇那时的齿轮分析机，那种机器用穿孔卡带 作为软件部分，而且已经还是不是10进制的，已经是
可编程的了。所以虽百年过去了，计算机的核心 概念，本质，还是没有变。就是作为一种解释器。
unix 是给解释器解释的一种程序，这种程序起到管理其他程序 和数据的 功能，原先只有批处理，后来称作操作系统。
特点：将设备视作文件，
系统的使用人员都是计算机科学家，是对计算机很了解的人，所以创造的系统也非一般的人善于使用，必须学习相关只是。
计算机科学家设计的东西简短，不复杂，非常优美。大而乱不是他们的设计哲学。所以要摒弃掉有事百度的毛病。
系统文档的缺失。本书将重点放在文本，而非二进制的处理，也是来源于Unix早期的要求。
要完成复杂的工作，那时的条件也不好，机器性能不高，很注重算法，机器语言什么的。所以开发效率很低，普通人玩不起
啊，所以追求软件的小而精。精悍，不容易出错。最初的Unix机器，不能运行大型程序。所以处理复杂问题时，必须分块
完成，最后连接起来。某种常见的工具，如从数据行中取出某些字段、替换文本，等等，因为用的多，最后都成了标准工具。
人们认为这种自然现象是一种好事，你想想，mulix不就是因为大而最终失败了吗！更小，更简单的库，更专用的程序。

许多人在Unix的使用上用了半独立的工作方式，重复套用彼此间的程序。由于版本之间的差异，而且不需要标准化，导致
许多日常程序的发展日渐分歧。如，grep 在某些系统用-i表示忽略大小写，但在另一个系统中，却使用-y来代表同样的事～
无独有偶，其他程序也产生了这种同样功能，不同调用的方式。为了使人们的工作能够不重复，就必须制定标准。POSIX。
系统文档分成两个部分，参考手册与使用手册。当然你也可以参考这两本手册来学会unix
xpg标准在措辞上可能不够严谨，但其内容却较为广泛，
软件工具的原则
随着时间的流逝，人们开发出了一套设计与编写软件工具的原则。在本书，我们会展示给你看使用这种原则的具体示例。
一般来说，好的软件工具应该具备下列特点：
一次做好一件事
想一想一次做好一件事，所以不要追求速度，要追求质量。这居然是最重要的原则。你敢说你把他做好了吗？虽然很短，
却有必要时时提醒自己。
具体在设计、编写、调试、维护，以及生成文件的过程中，都是要遵循 这个原则。这个原则的结果，自然就是会不断
产出更小、更专用于特定功能的程序。所以明白各个过程中数据的类型是很重要的事情。而文本很容易展示其类型。
在网络之间传输数据，如果也用文本，那么更利于自定义工具与现存的Unix程序之间的结合。
使用正则表达式。
这不是用于搜索文本这种复杂行为吗？且效率也不是那么的高。可适度简化编写命令脚本的工作。不要太复杂。* ? .这些符号
用起来也能省很多的力气。
basic regular expressions extended regular expressions

默认使用标准输入/输出
在未明确指定文件名的情况下，程序默认会从他的标准输入读取数据，将数据写到他的标准输出，至于错误信息则会传送到
标准错误输出。以这种方式来编写程序，可以让他们成为数据过滤器，filter，如组成规模越大，越要复杂的管道或脚本来处理。
避免喋喋不休
软件工具的执行过程不该像在“聊天”chatty。Unix程序一向遵循“你叫他做什么，你就会得到什么”的设计原则。
输出格式必须与可接受的输入格式一致
专业的工具程序认为遵循某种格式的输入数据，例如标题行之后接着数据行，或在
还有个原则
让工具去做困难的部分
虽然Unix程序并非完全符合你的要求，但是现有的工具或许已经可以为你完成90%的工作了。接下来，你可以编写一个功能特定的小型程序来完成剩下
的工作。
构建特定工具前，先想想
若现存系统里没有需要的程序，可以花点时间构建满足所需的工具，想想你要构建的程序，是否可以抽象成一般，下次就可以应用于相应的场景了。
小结
Unix来自于贝尔实验室，继承与multix.之所以在这指出软件工具的设计原则，主要是为了提供开发与使用Unix工具集的指导方针。有助于编写简洁
的shell程序或其他语言开发的程序。

第2章
当需要计算机帮你做些什么时，最好用对工具。你不会用文字编辑器来做支票簿的核对，也不会用计算器来写策划方案。
shell脚本用于系统管理工作，或是用于结合现有的程序以完成小型的、特定的工作。一旦你找出完成工作的方法，可以把用到的命令
 本章，我们从脚本 语言和编译型语言做一个概念上的说明。再从如何编写简单的shell脚本开始介绍起。
脚本编程语言与编译型语言的差异
这个我会了嘛，跳过。要不来没完没了了。
脚本语言通常是解释型的。这类程序，由编译器读入源代码，并将其转换成内部的形式，再执行。解释器是一般的编译型程序。
为什么用shell脚本、
使用脚本的好处是，他们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象。缺点是:他们的效率通常
不如编译型语言。不过权衡之下。层级高，代码量少，对象比较高级，花一个小时编写的简单脚本，同样的功能用c或c++来编写
实现，可能需要两天，而且一般来说，脚本执行的速度已经足够快了，快到1秒钟不到，脚本语言的例子有awk，perl、Python与ruby。
使用shell脚本的依据是：
简单语法简单 
可移植性
开发容易、、
一个简单的脚本
我们从简单的脚本开始。假如你想知道系统上有多少人登录。可以用who
在大型的、多用户的系统上，所列出的列表可能很长，在你能够计算用户个数之前，列表早就到超出屏幕了，计算用户的方法尚未提到。对此，我们可以
用wc（字数计算）程序，他可以计算出line Word 与character。这边，我们用的是wc -l ，只能计算出行数 
| 符号可以把标准输出，作为wc的输入。这里是输出，不是错误。
下一步则是将此管道转变成一个独立的命令。方法是把这条命令输入一个一般的文件中，然后使用chmod 为该文件设置执行的权限，

cat > nusers who | wc -l
自给自足的脚本：位于第一行的#！
在shell执行程序时，会要求Unix内核启动一个新的进程（process），以便在该进程里执行所指定的程序。我们的nusers shell脚本并
非编译型程序。shell收到此错误信息时，就会说“啊哈，这不是编译型程序，那么一定是shell脚本”，接着会启动一新的/bin/sh
副本来执行该程序。
当系统只有一个shell时，“退回到/bin/sh"的机制非常方便。但现在的unix系统都有好几个shell，因此需要知道Unix内核应该以哪个
shell来执行指定的shell脚本。 事实上，这么做有助于执行机制的通用化，让用户得以直接引用任何的程序语言解释器，而非只是一个
命令shell。方法是，通过脚本文件中特殊的第一行来设置：在第一行放置两个特殊的字符#！。当一个文件中开头的两个字符是#！时，
内核会扫描该行其余部分，看是否存在可用来执行程序的解释器的完整路径。此外，内核还会扫描是否有一个选项要传递给解释器。内核
会以被指定的选项来引用解释器，再搭配命令行的其他部分。如，假设有一个csh脚本，名为/usr/ucb/whizprog,他的第一行如下所示：
#！/bin/csh -f ,当用户键入whizprog -q /dev/tty01 这个命令，内核解析#！这行内容后，便会以如下的方式来引用csh:
/bin/csh -f /usr/ucb/whizprog -q /dev/tty01
这样的机制让我们得以轻松地引用任何的解释器。例如我们可以这样引用独立的awk程序
#！/bin/awk -f
shell 脚本通常一开始都是#!/bin/sh.  以下是几个初级陷阱（gotchas),请特别留意。
。当今的系统，对#！这一行的长度会有一个限制，有63个字符的，有到1024个的。请尽量不要超过64个字符，避免内核的解释出问题
。在某些系统，命令行部分包含了命令的完整路径名称，有些则是命令行会原封不动地传给程序。因此，脚本是否具有可移植性，取决于
是否有完整的路径名。这里要特别注意正则符号，要少用，尽量写出完整路径。
。别在选项之后放置任何空白，因为空白也会跟着选项一起传递给被引用的程序。
。你需要知道解释器的完整路径名称。这可以用来规避可移植性问题，因为不同的厂商可能将同样的东西放在不同的路径下面。
。一些较旧的系统上，内核不具备解释#！的能力，有些shell会自行处理，这些shell对于#！与紧随其后的解释器名称之间是否可以有空白，
可能有不同的解释。这些在开发过程中最好都考虑进去，避免系统障碍。
POSIX标准对#！的行为模式保留未定义（unspecified)状态。此状态是”只要一直保持POSIX兼容性，这是一个扩展功能的说法。“
所以说，这个并不是含义明确的。
我们书中都是有#！行的。所以重新该写过的nusers脚本如下：
#!/bin/sh -
who | wc -l
这里 sh 后加上一个- 线是基于安全上的考虑，可避免某种程度的欺骗式攻击（spoofing attack）
shell 的基本元素
本节要介绍的是，适用于所有shell脚本的基本元素。通过以交互的方式使用shell，你会慢慢熟悉的。
命令和参数
shell最基本的工作就是执行脚本。以互动的方式来使用shell很容易了解这一点：每键入一道命令，shell就会执行。
就像这样
cd work; ls -l whizprog.c
变量，是每个语言都有的概念。变量名称的字符长度并无限制。shell变量可用来保存字符串值，所能保存的字符数同样没有限制。
变量名字，起的很长，但不会破坏语义，确实是一个很好的方法。
变量赋值的方式是先写变量名称，再给那个符号赋予另一个符号，作为他的值。他的值有能用文字直接显示的，也能是一个资源，但资源在
编辑器中不能显示其语义呀，默认常常会要求只是资源的路径。
基本的一些常识平时不会深究，但在重建概念时必须要考虑进去的。
简单echo输出,居然能产生格式化的输出，说明echo命令还是挺高级的了。格式有制表符，换行符，退格符，垂直制表符/将字符表示成1到3位
的八进制数值
.由于echo有版本的差异，与会成员无法标准化echo上，对选项没有标准化，所以看具体实现，然后参照其文档说明。
用于复杂的格式化输出一般使用printf命令，模仿了c库中的printf函数。
printf 与echo 最大的不同是，不会自动在行尾加格式换行，必须显示指定。
printf 的第一部分是一个字串，第二个是特殊的占位符，用来描述如何显示相应的参数。
如果参数的个数比格式声明的还多，则printf会循环且依次地使用格式字符串里的格式声明，直到处理完参数。格式声明分成两部分：百分比
符号%和指示符specifier。最常用的格式指示符有两个 format specifier ，%用于字符串，而%d用于十进制整数。
格式字符串中，一般字符会按字面显示。转义序列则像echo那样，解释后再输出成相应的字符。

基于i/o的重定向
标准输入/输出可能是软件设计原则里最重要的概念了。这个概念就是：程序应该有数据来源、数据的目的端以及报告
问题的地方，他们分别被称为standard input standard output and standard error 。程序不必关心他的输入和输出
背后是什么设备：是磁盘上的文件、终端机、网络连接或是另一个执行中的程序。
许多Unix程序都遵循这一设计原则。默认情况下，他们会读取标准输入、写入标准输出，并将错误信息传递到标准错误输出。这类程序常常
叫做过滤器,filter,你马上会知道是什么原因。其实默认的输出 错误都打开，当然还有输入，你可以输入任何东西，但不保证程序能够
理解。
cat使用默认的标准输入和标准输出如果你不用参数。
你可能想知道，是谁打开了程序中的标准输入输出。答案是你登录时，Unix便将默认的标准输入、输出以及错误安排成你的终端。
i/o重定向就是你通过与终端交互，或是在shell脚本里设置，安排从哪里输出到哪里。
重定向与管道
shell 提供了数种语法标记，可以用来改变默认i/o 的来源端与目的端。此处会先介绍基本用法，稍后再提供完整的说明。让我们由浅入深地
依次介绍如下：
以< 改变标准输入 program < filename|devicename 可将program 的标准输入改为filename 或devicename
以> 改变标准输出 program > file ，program的输出就不会在显示器上显示了，转到file中。
以>> 追加到文件 program >> file, 可将program 的输出附加到file 的结尾处。 
以|建立管道
因为工具一般是有关联的，上个工具产生的结果可以供下个工具使用，所以
program1 | program2 就起到这样的作用了。这么做的好处是执行速度比使用中间临时文件的程序快上十倍。


tr工具 tr [option] source-char-list replace-char-list
转换工具，常用选项
-c 取source-char-list 的反义。tr 要转换的字符，变成未列在source-char-list 中的字符。
-d 从标准输入删除source-char-list 里所列的字符，而不是转换他们。
-s 浓缩重复的字符，如果标准输入重复出现source-char-list 里所列的字符，则将其浓缩成一个。
警告 根据posix 标准，-c 处理的是二进制字节值，而-C处理的是现行locale所定义的字符。直到2005年初，仍有许多系统不支持-C选项。
使用Unix工具时，将数据想象成水管里的水。未经处理的水，将流向净水厂，经过各类过滤器的处理，最后产生适合人类饮用的水。
同样，编写脚本时，你通常已有某种输入格式定义下的原始数据，而需要处理这些数据后产生结果。处理一词表示很多意思，例如排序
加减/平均。格式化以便打印）
如果你是Unix的新手，可以把《》想象成数据的漏斗 funnels -- 数据会从大的一端进去，从小的一端出来。
如果有个过程可以让数据变少，尽量把他放在前面，这样可以减少后段程序的工作量，提高性能。
特殊文件：/dev/null 与/dev/tty
Unix提供了两个对shell编程特别有用的特殊文件。第一个是/dev/null,就是垃圾桶。 bit bucket . 
如果你需要的是程序的退出状态而非他的输出，这个功能很抽风。
例如测试一个文件是否有某数据
if grep hello filename > /dev/null
then
 dosomething
else
 dosomethingelse
fi
相对的，读取/dev/null 会立刻返回文件EOF 符。
另一个特殊文件为/dev/tty . 当程序打开此文件时，Unix会自动将他重定向到一个终端【一个实体的控制台或串行端口】,也可能是一个
通过网络与窗口登录的伪终端 这些程序必须读取人工输入时，特别有用，产生错误信息也很方便。
stty (set tty ) 用来控制终端的各种设置。-echo 用来关闭自动打印每个输入字符的功能；stty echo 用来恢复该功能。
基本命令查找
我们知道，shell 是通过$PATH 这个变量来查找命令的。$PATH 是一个冒号隔开的字符串。默认路径包含/bin /usr/bin /usr/X11R6/bin /usr/local
/bin 
如果你要执行自己的程序，可以把程序放在一个特定的文件夹下，然后在$PATH 中引入。
如果要永久实现，必须写入永久存储器，你可以写入硬盘的.profile 文件，shell启动时会用到这个文件，那么就会认识到你写的程序了。  
path 里还有空项目，表示当前路径，在行首或行尾都是一个冒号，在中间是两个，shell是按照Path 中的先后顺序先到先得的。
一般来说，你根本不能在查找路径中包含空项目，因为这会有安全上的问题。
命令行参数的具体形式下面就向你展示。
基于历史原因，当参数的数量大于9时，就必须用大括号扩起来。
第一个参数为 $1 ,$2 ,以此类推。
另外，通过特殊变量，我们还可以取得参数的数量，
如果你想知道某个用户当前使用的终端，通过变量你也可以的到，
这个程序还没达到完美，如果我没给参数，会发生什么？

简单的执行跟踪，就是调试一样。程序是调试出来的。你不知到 会犯错误有多少，要经常碰碰。
这会使得shell显示每个被执行到的命令，并在前面加上“+”：一个加号后面跟着一个空格。
就像下面这样执行程序
sh -x nusers
你可以在脚本里，用set -x 命令将执行跟踪的功能打开，用set +x 关闭此功能。
这个可以在脚本内部调试 某一程序段 。
总的来说，跟踪就是列出一行原始码，然后把原始码的结果打印出来让你比较，看结果是否和你想要的那样。

国际化和本土化
编写程序给全世界的人使用，是艰难的。整个工作通常分成两个部分：国际化(internationalization,缩写为i18）internationalization
以及localization,缩写为l10。
一般，消息的译文就放在软件附带的文本文件中，再通过gencat或msgfmt编译成紧凑的二进制文件，以利于快速查询。编译后的信息文件
会被安装到特定的系统目录树中，如/usr/share/locale 与 /usr/local/share/locale ，中 。 详情可以见setlocale(3) catgets
与gettext
各种Locale 环境变量 
lang 未设置任何lc_xxx 变量时默认所使用的值
lc_all 用来覆盖掉其他任何lc_xxx的变量的值
lc_collate  使用所指定地区的排序规则
lc_ctype 使用所指定地区的字符集
lc_messages 使用所指定地区的响应与信息。
lc_monetary 使用所指定地区的货币格式】
lc_numeric 数字格式
lc_time 日期与时间格式

一般，你可以用lc_all 来强制设置单一的locale;而LANG则用来设置默认值。大多时候，应避免为任何lc_xxx变量赋值。当你使用sort命令
可能会出现要你正确设置lc_collate 的信息，也可能在lc_all 已设置的情况下被忽略，所以这里所说的是你如果单一设置变量的值后，有
可能会应先后顺序发生冲突或不起作用。
locale 变量的名称并未标准化，一般会用ISO 639 语言代码表示。中国地域在这里表示为zh_cn。
zh 语言代码，下划线和一个国家代码 iso 3166-1 的两个大写字母，最后可能会加上一个点好、字符集编码、@符号与modifier word 修饰符。

你可以用locale -a 来列出一些例子
我们发现，在某些系统上，要提供locale的支持，可能需要用到约300MB的文件系统。

我们可以用下面这种方法来查看特种语言的帮助文档
LC_ALL=en_US ls --help
程序名称及选项名称不能翻译，这会影响程序的可移植性。
我们写的程序常常会受到locale 的影响，这要注意，特别是collation order  以及regular expression 的方括号 bracket - expression
里面的字符范围。大多unix 很难从locale 文件与工具来判定哪些排序可用，这说明国际化任务比较繁重。locale的支持仍然没有成熟。
gnu gettext 或许可用来支持shell脚本的国际化。这个高级主题我们不讨论.你可以查看相应文档来学习其中包含的内容。
脚本语言通常用于快速开发程序，shell是Unix系统中最重要、也是广为使用的脚本语言。因为他的无所不在，而且遵循POSIX标准，使
他可以用在很多相似的系统上。
第3章，查找与替换
我们说过，程序员偏好处理文本的行和列。文本型数据比二进制数据更具有灵活性，且Unix系统提供了许多相应的工具。
在本章，我们讨论编写shell脚本时常用的操作。文本的查找与替换。系统管理中命令的输入输出格式和文件名 命令名很多用的都是文本。
所以查找文本挺实用的。
正则表达式能提供功能更强大的标记法，以单个表达式匹配各种实际的文本段。本章会介绍两种不同的风格。
然后会讲怎么提取文本，怎么重排文本。

grep 来匹配文本是相当方便的，在Unix中，专业术语是匹配，而不是查找。含义是一样的。
在POSIX系统上，grep 可以在两种正则表达式风格中选择一种，或是执行简单的字符串匹配。
传统上，有三种程序可以来查找整个文件。
grep 
egrep  extended grep 这个程序使用扩展正则表达式。这是一套功能更加强大的正则表达式。
fgrep 快速grep，这个版本匹配固定字符串而非正则表达式，他使用优化的算法，所以就叫他fast嘛！ 也是唯一一个能匹配多个字符串的
程序。
posix 将三个整合成一个，行为是通过不同的参数加以控制。在POSIX标准里，fgrep 和egrep 都没有了，但在实际的系统上还是存在的。

grep 默认使用Fix 行为模式

下面我们来重点讲解正则表达式。我们查找，有时并非查找某一具体的字符，而是 查找这类字符串。所以不能用具体的字符串定死，就创造
了这个所谓的正则表达式，其实就是像转义字符一样，用一种特定的符号表示某类相关的东西。我们比较字符串中有大小写的区别，还有就是
可能数字会插入其中，还有控制字符，空格格式符等等，所以用一些特定的符号区分，那么离我们想要的东西更为接近。
grep 的使用方法是
grep [options...] pattern-spec [files ...]
时常会作为管道的第一步，以便对匹配的数据做进一步处理
主要的选项
-E 使用扩展正则表达式
-F 使用固定字符串进行匹配
-e pat-list
通常，第一个非选项的参数会指定要匹配的模式，模式以减号开头时，grep会混淆，而将他视为选项。-e 可以指定其参数的行为模式
-f pattern-file 从pat-file 中读取模式作匹配
-i 模式匹配时忽略大小写差异
-l 列出匹配模式的文件名称，而不是打印匹配的行
-q 静默地。如果模式匹配成功，则不会将匹配的东西输出，而是静静地离开。
-s 不显示错误信息，同q并用。
-v 显示不匹配的模式的行。

多于一个文件时，会在每一行前面加上文件名和冒号。
因为正则表达式是Unix工具使用和构建模型上的基础，花些时间学习，你会不断地从各个层面得到充分的回报。

特殊字符有
\
. 匹配任何单个字符，但nul除外。
* 匹配在他之前的任何数目的单个字符,他会取最多的匹配。
 abcd abcccd abccd abccd
^ 匹配紧接着的正则表达式，在行或字符串的起始处

gbcdef^geh 
abcdef^geh 
$ 匹配前面的正则表达式，在字符串或行结尾处。
[] 匹配方括号内的任一字符。
\{n,m\} 表示它前面的单个字符重新的次数

abbbbbbbc
abc
abbc
abbbc
\( \) 将\( \) 之间的模式存储在特殊的“保留空间”，最多可以将9个独立的子模式
 abc edf 
abcdefgdsgab
abab
abdcdlasabab
\n 
+ 匹配前面正则表达式的一个或多个实例
? 匹配前面的零个或一个实例
| 匹配于 | 前或后的表达式 |
abc def
acc dff

此外，可用以在匹配及排序字符串数据时，将序列里的字符视为一个独立单位。
字符集
character class[: :] 将关键字组合括起来的posix 字符集。
collating symbol 
排序符号指的是将多字符序列视为一个单位 。他使用[. 与 .] 将字符组合括起来。排序符号在系统所使用的特定locale 上各有其定义。
等价字符集 [= =] 扩住
如[[:alpha:]!]匹配任一英文字符或惊叹号；在法文French的国际化中，或者在中文的同义词中 [[=一样=]] 跟完全，相同都是同一个意思。
在这里应该是不能使用的。不知道搜索引擎能不能匹配。
对于字符集
[:alnum:]
[:alpha:]
[:digit:]
[:lower:]
[:print:]
[:punct:]标点符号
[:space:]空格符
[:upper:]控制字符
[:cntrl:]
[:graph:][:xdigit:]
以及字符集，这些是方括号表达式最后出现的组成部分。接下来，我们就要说明他们的构造方式
为了匹配需要，某些成对的字符必须视为单个字符。像这样的成对字符，当他们与语言里的单个字符比较时，都有其排序的定义方式。
例如，在。。就是词组差不多的意思。
排序是指给予成组的排序顺序的操作。就是匹配一个词汇了哇
[ab[.你好.]de]
ab 你好 de 

最后一个特殊组成部分：字符集，他表示字符的类别，例如数字，小写与大写字母、标点符号
排序元素、等价字符集以及字符集，都仅在方括号表达式的方括号内认可，对于[:alpha:]这样的表达式，只有一层的化，仅匹配 : a l p h
在方括号表达式中，所有的元字符 meta 都会失去其含义。要将]加入该集合，可以将它放在列表的最前面：[]*\.]
若你需要右方括号与减号同时在列表中，请将右方括号放在第一个字符、减号放在最后一个字符 []*\.-]

后向引用
指的是“匹配于正则表达式匹配的先前的部分”。使用后向引用的步骤有两个。第一步是将子表达式包围在\( 与 \) 里；单个模式里可
包括至多9个表达式
下一步是在同一模式之后使用\digit,digit 是介于1至9的数字，指的是“匹配于第n个先前方括号内字表达式匹配成功的字符”。

abcdcdab\ abcdeeecdab abcdddeeffcdab
\([[:alpha:]_][[:alnum:]_]*\) = \1; 匹配简易的c/c++ 赋值语句
\1 就是 第一个() 中的内容
后向引用在寻找重复字以及匹配引号时特别有用
\(["']\).*\1 匹配以单引号或双引号括起来的字，如'foo' 或"bar"

在这种方法下，就无需担心是单引号或是双引号先找到。
匹配多字符最简单的方法就是把他们一个一个列出来。

\{n,m\} 的值介于0 至RE_DUP_MAX 之间。re_dup_max是POSIX定义的符号型常数，且可以通过getconf 命令取得。
方式为 getconf RE_DUP_MAX ,在Linux 上是一个很大的数字，32767
再介绍两个meta字符就完成这个bre的介绍了。他们是 ^ 和 $ 符号，他们指的是anchor,因为他们针对的是字符串的头部和尾部进行匹配。
^$ 表示空行 
扩展文件里头时常包含空行或空白比较多
cc -E foo.c | grep -v '^$' > foo.out 删除空行

在扩展正则表达式里 [ ] \ - 都是有含义的，所以要用\ 转义
ere 里没有向后引用，在ere里，\( 与\)匹配的是字面上的括号

aaaaaaa
区间表达 时，要查找5个a 或几个a 时 ，用 a{5,10},不要加反斜杠
交替运算符 | ，可以用于匹配多个,用这个挺有用的

扩展正则表达式 \< \> 表示匹配单词
\<abc

abc helabc acbc abcdef abcefg 
虽然POSIX标准化的只有ex编辑器，但在所有商用unix 系统上，ed ex  以及vi 都支持单词匹配。
另外还有额外的gnu 正则表达式运算符

\w [[:alnum:]_]
\W  

一般来说，执行了文本查找，我们可能会进一步做替换来修改文本。此时用到的工具一般是 sed stream edtior . sed 的设计就是用来
以批处理的方式，而不是交互的方式来编辑文件。当你知道要做好几个变更。 
我们发现，在shell脚本里，sed 主要用于一些简单的文本替换，所以我们先从他开始。

基本用法，你可能常会在管道中间，用sed 的替换 s 用法 
sed 's/:.*//’ /etc/passwd | sort -u 删除重复的行

为了编辑他的输入流，将结果生成到标准输出，而非以交互式编辑器的方式来编辑文件。虽然sed 的命令很多，通常只是作为管道的一部分，
给 下一个程序做最终处理
行为模式
读取每个输入文件的每一行，加入没有文件的话，则是标准输入。以每一行来说，sed会执行每一个应用到输入行的editing command. 
结果会写到标准输出（默认状态下，或是显示地使用p 命令及-n 选项） 。 
在这里，/ 字符扮演定界符（delimiter)的角色，从而分割正则表达式与替代文本。在本例中，替代文本是空的，实际上会有效地删除匹配的文本，
在处理文件名称时，通常会以标点符号字符作为定界符，因为在文件名中/ 是有特殊含义的。
find /home/xx -type d  -print | sed 's;/home/tolstoy/;/home/lt/;'|修改名称，注意：这里使用的是分号作为定界符
sed 's/^/mkdir /' | sh -x 
上述脚本将/home/tolstoy 目录结构建立一份副本在/home/lt 下 这个脚本 使用了产生命令的手法，这是一个功能很强且很常见的技巧

替换细节
前面提到，定界符不光是/ 还可以是任何标点；对于这些特殊字符的替换，需要用到转义符。
不过这么做让人很难看懂。看下面这个替换
sed 's/\/home\/tolstoy\//\/home\/lt\//' 
sed 's|/home/tolstoy/|/home/lt|' 这个就看的清楚了
sed 's&/home/tolstoy/&/home/lt&' 这样就更清楚

sed 也知道向后引用，他也认得正则表达式。他知道从这替换匹配的文本
举个例子
echo /home/tolstoy/ | sed 's;\(/home\)/tolstoy/;\1/lt/;'
sed 将\1 替换为匹配与正则表达式的/home 部分。在这里，任何表达式都可以在括号，向后引用最多9个，不能多哦

向后引用
sed 's/\(ab\)/\1nimei\1/'
有些其他字符在替代文本里也有特殊含义。 我们已经提过需要使用反斜杠转义定界符的情况
还有 & 在替代文本的含义是，就像是代表这个匹配的不懂，并可以在后面追加字符
sed 's/hello/& world/' 'hello !'
在s 命令里以 g 结尾表示global，表示替代每个匹配。默认只会匹配第一个
如果结尾跟数字，则表示为第 数字 次出现才匹配

到目前，我们都是讲的一次替换一个，但一次替换多个也能实现。 就是使用-e 选项。 每个编辑命令使用一个 -e 
sed -e 's/foo/bar/g' -e 's/chicken/cow/g' file.xml > myfile.xml

不过，如果你有很多项目要编辑，这种形式很恐怖，将编辑命令全部放在脚本里，再搭配 -f 使用，会更好 
cat fixup.sed
s/foo/bar/g
s/chicken/cow/g
s/animal/horse/g


以后只要修改文件就好了，这是对于修复bug来挺有用的。另外，POSIX标准也允许使用分号将不同的命令隔开
sed 's/foo/bar/g; s/chicken/cow/g' myfile.xml > myfile2.xml

sed 的工作方式是对于行来说的，每次读取一行，进行操作。

sed -n '/hello/p' xx.file  这个有点像grep 的查找功能，显示匹配的一行 ，不做替换
匹配特定的行，而不是每一行都作处理，现在我们就来学习sed 的这一功能。
行编号，上面的有点笼统 ，最后一行 用 $l $p 表示
有了行编号，就可以具体到哪一行了
还可以取一个范围，也是由行编号来的，用逗号隔开。
s 是替换命令 p 是打印命令
sed '/foo/,/bar/ s/baz/quux/g' 仅替换范围内的行。这个范围并不是以行号来限定的，而是根据正文内容。挺有用的。
像ed ex 或 vi 内的冒号命令，都认识此语法。当然，在emacs的evil模式下也是认得的。
否定正则表达式
有时，将命令应用于不匹配于特定模式的每一行，也很有用。在下面的例子来说明

假如这一行没有这么一个东西，就把xx 改成yy
 /used/!s/new/used/g   将没有used 的每一行的new 改成used
sed 还可以作为head 使用
语法是 sed 3q file  打印头三行

写的灵活点就是
count=$1
sed ${count}q $2
q 要求sed马上离开，不再读取其他输入，或执行任何命令。
了解行与字符串的差异是相当重要的。大部分简易程序都是处理输入数据的行，在这些情况下，不会有内嵌的换行字符出现在将要匹配的数据中。
但字符串就不同了，他可能包括换行符，可能还有空字符。这种情况下，^ 与 $ 就无法匹配内嵌的换行字符。他们只是用来匹配字符串的开头
和结尾。也就是在这种程序语言中，工具的含义发生了微妙变化。
字段处理，一行表示一个记录。对于一行内分割字段的惯例，是用空格或制表符 空白
或用特定的定界符

使用cut 选定字段
用法如下 
cut -d : -f 1,5 /etc/passwd 取出第一段 和第五段内容
cut -c list [file...] 以字符为主，执行剪下的操作。list为字符编号或一段范围的列表，以逗号隔开 如 1,2,5-10,34 剪下字符
cut -f list [-d delim] [file...] field 剪下字段

join 连接
join [options ...] file1 file2
以共同的一个键值，将已存储文件内的记录加以结合
-1 field1
-2 field2 标明要结合的字段，-1 field1指从file1中取出field1,-2 field2 是指从file2 中取出field2，字段编号自1开始，而非0
-o file.field 输出file中的field 字段。
-t separator 
使用separator 作为输入字段分割字符，而非使用空白。

这个有点难 
现在讲到重点了，awk工具
本节，我们介绍awk 的基本概念，随后，你看到这样的 单命令行程序 （one-liners) 就会比较了解了。
模式与操作
awk ‘program ' [file...]
awk 读取命令行上所指定的各个文件，一次读取一行，在针对每一行，应用命令。awk 基本架构为
pattern {action}
pattern 可以是任何表达式，但在单命令行程序里，他通常是由斜括号扩起来的 ege。action 为awk语句 
对于每条记录