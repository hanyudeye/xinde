#+TITLE: gradle 简介
#+DESCRIPTION: 程序源码到程序成品的处理形式
#+TAGS: gradle,java
#+CATEGORIES: 软件使用
#+DATE: <2019-06-14 20:16:16>

* gradle 
** 简介 
  在 Grade 中，我们常见的几个关键术语有 Project、Plugin 以及 Task。

和 Maven 一样，Gradle 只是提供了构建项目的一个框架，真正起作用的是 Plugin。
Gradle 在默认情况下为我们提供了许多常用的 Plugin，其中包括有构建 Java 项目的
Plugin，还有 War，Ear 等。与 Maven 不同的是，Gradle 不提供内建的项目生命周期管理，
只是 Java Plugin 向 Project 中添加了许多 Task，这些 Task 依次执行，为我们营造了一
种如同 Maven 般项目构建周期。换言之，Project 为 Task 提供了执行上下文，所有的
Plugin 要么向 Project 中添加用于配置的 Property，要么向 Project 中添加不同的 Task。
一个 Task 表示一个逻辑上较为独立的执行过程，比如编译 Java 源代码，拷贝文件，打包
Jar 文件，甚至可以是执行一个系统命令或者调用 Ant。另外，一个 Task 可以读取和设置
Project 的 Property 以完成特定的操作。


** 安装
   #+begin_src sh
     sudo apt install gradle 
     export GRADLE_HOME=/opt/gradle-5.2.1
     export PATH=${GRADLE_HOME}/bin:${PATH}
   #+end_src
   
** 构建工程 
*** build.gradle
*** 构建 [project ,task]
    Gradle 由两个基本概念：Project 和 Task
**** Project
     构建产物（比如 Jar 包）或实施产物（将应用程序部署到生产环境），Project 由一些
     组件组成，如一个 Project 可以代表一个 JAR 库或者一个 WEB 应用程序，也可能包含
     其他项目生成的 JAR 包
**** Task
     不可分的最小工作单元，执行构建工作（比如编译项目或执行测试），Task 可以是编译
     一些 Java 类，或者创建一个 JAR 包，或者是生成 JavaDoc，或者是发布文档到仓库，
     Task 作为原子工作存在

     每个 gradle build 由一到多个 Project 组成
     每个 Project 由一到多个 Task 组成
**** 构建脚本（build.gradle）
     #+begin_src groovy    
       task hello {
           doLast{
               println 'Hello world !'
           }
       }
     #+end_src
**** 属性文件（gradle.properties）
**** 设置文件（gradle.settings）
**** 脚本基础
     可以通过 gradle 命令运行一个 Gradle 构建
   
     gradle 命令会在当前目录中查找一个叫 build.gradle 的文件. 我们称这个
     build.gradle 文件为一个构建脚本 (build script), 但是严格来说它是一个构建配置
     脚本 (build configuration script). 这个脚本定义了一个 project 和它的 tasks

     脚本 1
     新建文件 build.gradle


     task hello  {
     doLast {
     println 'Hello World!'
     }
     }

     在命令行下执行 gradle -q hello
   
     脚本定义了一个名为 hello 的任务，运行 gradle hello 时，执行 hello，并依次执行
     任务中定义的动作。
   
     其简洁的定义为：
     task hello {
     println 'Hello World!'
     }


     脚本 2

     task upper {
     String someString = 'MyName'
     println "Original: " + someString
     println "Upper case: " + someString.toUpperCase()
     }

     执行 gradle -q upper，显示

     Original：MyName
     Upper case: MYNAME


     脚本 3

     task count << {
     4.times {
     print "$it "
     }
     }

     显示

     0 1 2 3


     脚本 4

     task hello << {
     println 'Hello World!'
     }
     task intro(dependsOn: hello) << {
     println "I'm Gradle"
     }

     显示

     Hello World!
     I'm Gradle


     脚本 5

     4.times { counter ->
     task "task$counter" << {
     println "I'm task number $counter"
     }
     }

     执行 gradle -q task2，显示

     I'm task number 2
*** 构建 java 项目
    编译并打包你的代码, 但是并不运行单元测试.其他插件会在这个任务里加入更多的步
    骤.举个例子,如果你使用 War 插件,这个任务还将根据你的项目生成一个 WAR 文件

    check
    编译并测试你的代码. 其他的插件会加入更多的检查步骤.举个例子, 如果你使用 checkstyle 插
    件, 这个任务将会运行 Checkstyle 来检查你的代码.
**** 外部依赖(jar 文件位于仓库中) 
     repositories {
     mavenCentral()
     }
     
     加入依赖
     dependencies {
     compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
     testCompile group: 'junit', name: 'junit', version: '4.+'
     }
**** 属性
     设置属性
     sourceCompatibility = 1.5
     version = '1.0'
     jar {
     manifest {
     attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version
     }
     }

     显示属性 
     gradle properties
**** 发布 JAR 文件
     uploadArchives {
     repositories {
     flatDir {
     dirs 'repos'
     }
     }
     }
** gradle 插件
*** 基本 Java 插件   
    apply plugin: 'java'
*** 安卓插件 
    buildscript {
    repositories {
    mavenCentral()
    }
    
    dependencies {
    classpath 'com.android.tools.build:gradle:0.11.1'
    }
    }
    
    apply plugin: 'android'
    
    android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"
    }
** 命令
*** Gradle Wrapper [gradle 版本包装器]
    安装包装器   gradle wrapper
    安装指定版本 gradle wrapper --gradle-version 2.14.1

    升级 gradle wrapper --gradle-version 3.0-milestone-2
*** gradlew ( gradle wrapper) 
    查看项目的 gradle 版本  ./gradlew -v
    下载 gradle 依赖　./gradlew clean
    编译 apk 文件   ./gradlew build
    编译并打 Debug 包  ./gradlew assembleDebug 
    编译并打 Release 的包  ./gradlew assembleRelease 

*** 初始化 Gradle 项目
    要创建使用 testng 测试框架的 Java Gradle 项目，您可以使用以下命令：
    $ gradle init --type java-library --test-framework testng

    如果你想用 JUnit，那就别加上--test-framework
    $ gradle init --type java-library

    你也可以创建 groovy 和 scala 项目
    $ gradle init --type scala-library

    $ gradle init --type groovy-library

*** 查看依赖图表
    gradle dependencies

*** 创建构建脚本 build.gradle
*** 构建单独的工程 gradle api:rest:build
*** 执行项目 gradle run
*** 排除某些任务
    gradle clean build -x test
*** 分析你的构建
    Gradle 内置了对分析的支持。 如果您遇到性能问题，应该使用--profile 选项来生成配置
    文件报告。 报告 会显示不同任务花费的时间。 假设我们想要分析构建任务，然后我们可
    以运行以下命令：

    $ gradle --profile build
    这将在目录 build/reports/profile 下生成报告。

    gradle-profile

*** Perform dry run
    有时你想要查看所有在编译中将被执行的所有任务担忧不想执行它们。这个场景下 Gradle
    提供``--dry-run```命令：

    $ gradle build --dry-run

*** 安置项目 jar 包到本地 Maven 仓库
    $ gradle install

*** 查看 Gradle 任务
    $ gradle tasks

    这个命令并不会列出所有任务。要用--all 来运行：
    $ gradle tasks --all

*** 使用 Gradle 守护程序(Daemon)
    加快 Gradle 构建的最简单办法就是用 Gradle 守护进程进行构建。Gradle 守护进程是一
    个长时间存活的后台进程，在其生命周期内只执行一次引导。 默认情况下未启用 Gradle
    守护程序。 要使用 Gradle 守护进程，您可以在构建命令中使用--daemon 标志。

    $ gradle build --daemon


    它将在 3.0 版本默认开启

    每次传递--daemon 标志都很麻烦，因此您可以通过在开发机器上的~/.gradle/gradle.properties 文件中添加此标志来启用它。
    org.gradle.daemon=true

*** 多线程构建
    打开~/.gradle/gradle.properties 并添加以下行。
    org.gradle.parallel=true

*** 自定义 Gradle 任务
    您可以通过覆盖其 doFirst 和 doLast 生命周期方法来自定义任何 Gradle 任务。 让我们
    假设我们想在执行测试之前和之后添加打印语句，我们可以通过以下操作：

    apply plugin:'java'
    test.doFirst {
    println("running tests...")
    }
    test.doLast {
    println("done executing tests...")
    }

*** 为 Gradle 守护进程提供 JVM 参数
    您可以通过在~/.gradle/gradle.properties 中输入一行来为 Gradle 守护程序指定 JVM 参数，如下所示：
    org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8

*** 用离线模式运行
    $ gradle build --offline

*** 按需配置
    按需配置是 Gradle 的孵化功能，因此默认情况下不启用。
    $ gradle clean build --configure-on-demand

    如果您希望将其设置为默认选项，则可以通过向~/.gradle/gradle.properties 中添加以下代码为全局提供此选项
    org.gradle.configureondemand=true

*** 刷新 Gradle 依赖缓存
    $ gradle clean build --refresh-dependencies

    你也可以手动删除 ~/.gradle/caches.。下一次你构建的时候它会下载所有依赖并加入到缓存中。
    假设你在 Gradle 中用于放置 jar 文件的目录为 lib。
    dependencies {
    compile files('libs/myjar.jar')
    }

    也能像下面这样做：
    repositories {
    flatDir {
    dirs 'libs'
    }
    }

    dependencies {
    compile name: 'myjar'
    }

*** 将本地目录中的所有 jar 加入依赖
    如果你需要把一个目录下的所有 libs 加入依赖，那你就可以像下面这样做：
    dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    }

    Tip 18: 构建项目和所有它所依赖的项目
    $ gradle api:model:buildNeeded

    Tip 19: 构建项目和所有依赖它的
    $ gradle api:rest:buildDependents

    Tip 20: 为构建脚本提供默认任务
    为项目定义默认任务是一个很好的做法，以便初次使用者可以轻松开始您的项目。 在您的 Gradle 脚本中，定义 defaultTasks 变量来传递它应该执行的任务。
    defaultTasks "clean","build"

    现在如果一个用户运行 gradle 命令，默认任务将被执行
*** 创建文件的校验和
    apply plugin: 'java'

    archivesBaseName = 'checksum-sample'

    jar.doLast { task ->
    ant.checksum file: task.archivePath
    }

    Tip 22: 给构建文件取不同的名字
    默认的文件名为 build.gradle。你可以在 settings.gradle 用以下方法进行重命名：
    rootProject.buildFileName = "gradle-tips.gradle"

    现在把你的 build.gradle 改名成了 gradle-tips.gradle
    Tip 23: 在多项目 Gradle 工程中为构建脚本取不同的名字
    为了方便，我们用 build.gradle 作为 Gradle 构建脚本的名称。当你在多项目 Gradle 工程中，对构建脚本使用不同的名称是有意义的。 我们假设我们的多模块项目如下所示：
    app
    api
    core
    web
    itests

    默认情况下，所有这些子项目都将 build.gradle 作为他们的 Gradle 构建文件。 我们可以通过在 settings.gradle 中改变。
    rootProject.children.each {
    it.buildFileName = it.name + '.gradle'
    }

    现在你可以用 build.gradle 作为根项目的构建文件而子工程中为 api.gradle, core.gradle, web.gradle, 和 itests.gradle。
    Tip 24: 使用 Gradle 可视化界面
    你可以在命令行中用以下代码启动 Gradle 可视化界面：
    $ gradle --gui

    它将开启下图所示的可视化界面：


    gradle-gui

    Tip 25: 创建 untar 任务
    task untar( type : Copy) {
    from tarTree(‘dist.tar.gz’)
    into ‘destFolder’
    }

    Tip 26: 版本冲突时的配置
    在你的构建脚本中，定义了一个如下的配置块：
    configurations {
    compile.resolutionStrategy.failOnVersionConflict()
    }

    Tip 27: 在 Gradle 中使用作用域
    你可以用 gradle2.12 版本以上提供的 compileOnly 作用域来使用 Maven
    dependencies {
    compileOnly 'javax.servlet:servlet-api:3.0-alpha-1'
    }

    Tip 28: 显式设置 Java 编译编码
    在你的 build.gradle 中添加如下代码：
    compileJava.options.encoding = 'UTF-8'

    Tip 29: 禁用传递依赖关系解析
    为整个配置关闭传递依赖关系：
    configurations {
    compile.transitive = false
    }

*** 查看 Gradle 版本
    用下列代码查看 Gradle 版本：
    $ gradle -v

    ------------------------------------------------------------
    Gradle 2.14.1
    ------------------------------------------------------------

    Build time:   2016-07-18 06:38:37 UTC
    Revision:     d9e2113d9fb05a5caabba61798bdb8dfdca83719

    Groovy:       2.4.4
    Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
    JVM:          1.8.0_60 (Oracle Corporation 25.60-b23)
    OS:           Mac OS X 10.10.5 x86_64

    你可以用 GradleVersion.current()查看当前 Gradle 版本。 你可以创建一个任务来做这个工作：
    task gradleVersion {
    group = "help"
    description = "Prints Gradle version"

    doLast {
    logger.quiet("You are using [${GradleVersion.current()}]")
    }
    }

    当你运行时你会看到：
    $ gradle gradleVersion

    :gradleVersion
    You are using [Gradle 2.14.1]

    BUILD SUCCESSFUL

    Total time: 0.667 secs

    Tip 31: 禁用一个任务
    taskName.enabled = false

    如果你想禁用测试任务，用下列代码：
    test.enabled = false

*** 签名文件
    apply plugin: 'signing'
    signing {
    sign configurations.archives
    }

    如果你只想在发布的版本中签名而在快照版本中不签名，那你可以这样做：
    apply plugin: 'signing'
    signing {
    required { !version.endsWith("SNAPSHOT”) }
    }

*** 并行运行测试
    test {
    maxParallelForks = 2
    }

    Tip 35: 为测试设置内存
    test {
    minHeapSize = ‘512m'
    maxHeapSize = ‘1024m'
    }

    Tip 36: 用任务的短名
    如果你有个任务 buildServerDistribution，想用它的短名，你可以用如下方法：
    $ gradle bSD

    你必须保证它在所有任务中是唯一的，如有另一个任务 buildSafeDistribution，你需要做以下区分
    $ gradle bSeD

    Tip 37: 查看 Gradle 任务的相关信息
    $ gradle help --task <task name>

    $ gradle help --task dependencies

*** 用调试模式运行 Gradle
    $ gradle clean build --debug

*** 当任务失败后继续执行任务
    $ gradle clean build --continue

*** 将 Maven 工程转移至 Gradle
    到 Maven 项目中运行以下命令：
    $ gradle init --type pom

*** 强制 Gradle 重运行即使它是最新的
    $ gradle build --rerun-tasks

*** 在依赖中使用确切的版本号
    你在声明依赖时不要使用+号，而该用确切的版本号，这回让你构建过程更快更安全
*** 启用连续构建
    如果你希望连续地运行构建，那你可以使用--continuous 标识。它将查找文件改变，找到一处九江重新运行命令，用下列方法启用连续测试：
    $ gradle test --continuous
*** 运行一个测试事务
    有时我们只需要运行一个测试事务而不是运行所有测试。用下列命令即可：
    $ gradle test --tests tips.CalculatorTest

    想运行 CalculatorTest 中的某个部分可以这样做：
    $ gradle test --tests tips.CalculatorTest.shouldAddTwoNumbers

    您还可以使用正则表达式来指定多个测试：
    $ gradle test --tests "tips.Calculator*Test"

    你也可以多次用--test 标识
    $ gradle test --tests tips.CalculatorTest --tests tips.Calculator1Test

    在一个子模块的测试中你可以这样做：
    $ gradle api:test --tests app.api.PingResourceTest

    Tip 45: 生成源文件和 java 文档 jar 包
    task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
    }

    artifacts {
    archives sourcesJar, javadocJar
    }

    Tip 46: 在构建脚本中访问环境变量
    你可以用很多方法在构建脚本中访问环境变量：
    println(System.getenv("HOME"))
    println("$System.env.HOME")
*** 配置测试日志
    Gradle 默认只会在控制台打印测试错误的日志。这会限制任务如何运行的可见性。Gradle 允许你用 testLogging 参数来配置它。打印所有日志如下。更多信息看这里.
    test {
    testLogging {
    events "passed", "skipped", "failed"
    }
    }

    现在当你运行./gradlew clean build 时，你也会看到通过测试的日志了。
    $ gradle clean test

    :clean
    :compileJava
    :processResources UP-TO-DATE
    :classes
    :compileTestJava
    :processTestResources UP-TO-DATE
    :testClasses
    :test
    tips.CalculatorTest > shouldSubtractTwoNumbers PASSED

    tips.CalculatorTest > shouldAddTwoNumbers PASSED

    tips.CalculatorTest > shouldSubtractTwoNumbers1 PASSED

    有一点要记住的是，Gradle 测试命令只有当改变时才会执行。因此如果你在没有改动的情况下再次执行它将不会有任何结果产生。你将看到:test UP-TO-DATE，这意味着没有检测到改动。你可以用./gradlew cleanTest test 指令强制 Gradle 每次都运行测试。
    Tip 48: 在测试执行期间显示标准输出和错误流
    test {
    testLogging {
    events "passed", "skipped", "failed"
    showStandardStreams = true
    }

    }

*** 存储凭据
    您不应该在 build.gradle 中硬编码凭据，而应该依靠您的用户 home~/ .gradle / gradle.properties 来存储凭据。 假设你想使用受凭证保护的 Maven 存储库。 指定凭据的一种方法是在 build.gradle 中对它们进行硬编码，如下所示。
    repositories {
    maven {
    credentials {
    username "admin"
    password "admin123"
    }
    url "http://nexus.mycompany.com/"
    }
    }

    更好的方法是改变你自己的~/ .gradle / gradle.properties
    nexusUsername = admin
    nexusPassword = admin123

    现在，在 build.gradle 中引用这个
    repositories {
    maven {
    credentials {
    username "$nexusUsername"
    password "$nexusPassword"
    }
    url "http://nexus.mycompany.com/"
    }
    }

*** 调试 Java 可执行应用程序
    如果将应用程序打包成可以通过 Gradle 运行的可执行 jar，那么可以通过--debug-jvm 选项来调试它。Spring Boot 应用程序作为可执行 jar 运行。 您可以使用 gradle bootRun 来运行应用程序。 要在端口 5005 上调试应用程序，您可以在调试模式下启动应用程序。
    $ gdw <taskname> --debug-jvm

    $ gradle bootRun --debug-jvm

*** 使用本地 Maven 仓库
    要用本地 ~/.m2 仓库,你需要在 build.gradle 中添加这些：
    repositories {
    mavenLocal()
    }

*** 排除传递性的依赖
    用下述方法排除传递性的依赖
    compile('org.hibernate:hibernate:3.1') {

    exclude module: 'cglib' //by artifact name

    exclude group: 'org.jmock' //by group

    }
** 帮助
   https://guides.gradle.org/creating-new-gradle-builds/

* Gradle 依赖管理工具   
** app/build.gradle 项目的最主要的配置文件
** wrapper.properties  gradle 的配置文件 
** build.gradle 整个项目的的基本配置
** settings.gradle 项目的全局的配置文件
