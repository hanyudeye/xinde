* C
** C 环境设置
*** C 编译器 gcc
** C 程序结构
*** 预处理器指令
*** 函数
*** 变量
**** 定义 int i; //声明，也是定义
**** 声明 extern int i; //声明，不是定义
*** 常量
**** 定义常量
*****    使用 #define 预处理器。 //预处理器会处理掉,不用编译器处理
*****    使用 const 关键字。
*** C 存储类 定义 C 程序中变量/函数的范围（可见性）和生命周期
**** auto 存储类是所有局部变量默认的存储类
**** register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量,最大尺寸等于寄存器的大小
: 不能对它应用一元的 '&' 运算符（因为它没有内存位置
**** static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁
**** extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
*** 语句 & 表达式
*** 注释 /* comment */ or //
*** C 结构体
#+BEGIN_SRC c
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables]; 
#+END_SRC
*** C 共用体
#+BEGIN_SRC c
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];  
#+END_SRC
*** C 位域 (节省空间)
#+BEGIN_SRC c
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
#+END_SRC
*** C typedef
: typedef unsigned char BYTE;
*** C 输入 & 输出
**** getchar() & putchar() 函数
int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。
int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。
**** gets() & puts() 函数
char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。
int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。
**** scanf() 和 printf() 函数
int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。
int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。
*** C 文件读写
**** 打开 FILE *fopen( const char * filename, const char * mode );
**** 关闭 int fclose( FILE *fp );
**** 写入 int fputc( int c, FILE *fp ); /int fputs( const char *s, FILE *fp );
**** 读取 char *fgets( char *buf, int n, FILE *fp );
*** 头文件
**** 只引入一次
#+BEGIN_SRC c
#ifndef HEADER_FILE
#define HEADER_FILE

the entire header file file

#endif
#+END_SRC
**** 多系统
#+BEGIN_SRC c
 #define SYSTEM_H "system_1.h"
 ...
 #include SYSTEM_H
#+END_SRC
*** C 错误处理
: 大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 <error.h> 头文件中找到各种各样的错误代码。
: 开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。
**** perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
**** strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。
**** 程序退出状态
*****  exit(EXIT_FAILURE) 调用系统宏
*****  exit(EXIT_SUCCESS)
*** C 递归 调用自己
*** C 可变参数
*** C 内存管理 动态内存分配与管理 <stdlib.h>
**** void *calloc(int num, int size);该函数分配一个带有 num 个元素的数组，每个元素的大小为 size 字节。
**** void free(void *address);该函数释放 address 所指向的h内存块。
**** void *malloc(int num);该函数分配一个 num 字节的数组，并把它们进行初始化。
**** void *realloc(void *address, int newsize);该函数重新分配内存，把内存扩展到 newsize。
*** C 命令行参数 int main( int argc, char *argv[] ) 
** 数据类型
*** 	基本类型：
它们是算术类型，包括两种类型：整数类型和浮点类型。
*** 	枚举类型：
它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。
*** 	void 类型：
类型说明符 void 表明没有可用的值。
*** 	派生类型：
它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。
** C 标准库
*** <assert.h>
 C 标准库的 assert.h头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。
已定义的宏 assert 指向另一个宏 NDEBUG，宏 NDEBUG 不是 <assert.h> 的一部分。如果已在引用 <assert.h> 的源文件中定义 NDEBUG 为宏名称，则 assert 宏的定义如下：
#define assert(ignore) ((void)0)
*** <ctype.h>
这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。
**** int isalnum(int c)该函数检查所传的字符是否是字母和数字。
**** int isalpha(int c)该函数检查所传的字符是否是字母。
**** int iscntrl(int c)该函数检查所传的字符是否是控制字符。
**** int isdigit(int c)该函数检查所传的字符是否是十进制数字。
**** int isgraph(int c)该函数检查所传的字符是否有图形表示法。
**** int islower(int c)该函数检查所传的字符是否是小写字母。
**** int isprint(int c)该函数检查所传的字符是否是可打印的。
**** int ispunct(int c)该函数检查所传的字符是否是标点符号字符。
**** int isspace(int c)该函数检查所传的字符是否是空白字符。
**** int isupper(int c)该函数检查所传的字符是否是大写字母。
**** int isxdigit(int c)该函数检查所传的字符是否是十六进制数字。
**** int tolower(int c)该函数把大写字母转换为小写字母。
**** int toupper(int c)该函数把小写字母转换为大写字母。
*** <float.h>
库宏
下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。
| FLT_ROUNDS          | 定义浮点加法的舍入模式，-1,不确定;0,趋于0;1,去最近的值;2,正无穷;3,负无穷            |
| FLT_RADIX 2         | 定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。 |
| FLT_MANT_DIG        | 这些宏定义了 FLT_RADIX 基数中的位数。                                               |
| FLT_DIG 6           | 这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。                     |
| FLT_MIN_EXP         | 这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。                               |
| LDBL_MIN_10_EXP -37 | 这些宏定义了基数为 10 时的指数的最小负整数值。                                      |
| LDBL_MAX_EXP        | 这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。                                 |
| LDBL_MAX_10_EXP +37 | 这些宏定义了基数为 10 时的指数的最大整数值。                                        |
| LDBL_MAX 1E+37      | 这些宏定义最大的有限浮点值。                                                        |
| LDBL_EPSILON 1E-9   | 这些宏定义了可表示的最小有效数字。                                                  |
| LDBL_MIN 1E-37      | 这些宏定义了最小的浮点值。                                                          |
