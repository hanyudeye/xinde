* Linux应用 在线文档 LDP(Linux document project)
** 系统管理
*** 系统安全
**** syslog 系统默认的日志守护进程
**** openssl 强大的安全套接字层密码库
**** logwatch 可定制和可插入式的日志监视系统
**** lastb 列出登入系统失败的用户相关信息
**** sudo 以其他身份来执行命令
sudo -i 切换为root用户
**** lastlog 显示系统中所有用户最近一次登录信息
**** logrotate 统日志进行轮转、压缩和删除
**** chroot 把根目录换成指定的目的目录
**** logsave 将命令的输出信息保存到指定的日志文件
**** last 列出目前与过去登入系统的用户相关信息

*** 进程和作业管理
**** ipcrm 删除消息队列、信号集、或者共享内存标识
**** systemctl 系统服务管理器指令
**** w 显示目前登入系统的用户信息
**** watch 周期性的方式执行给定的指令
**** pidof 查找指定名称的进程的进程号ID号　
**** skill 向选定的进程发送信号冻结进程
**** pgrep 设置用户的认证信息，包括用户密码、密码过期时间等
**** renice 修改正在运行的进程的调度优先级
**** nohup 将程序以忽略挂起信号的方式运行起来
**** ipcs 分析消息队列共享内存和信号量
**** pmap 报告进程的内存映射关系
**** nice 改变程序执行的优先权等级
**** service 控制系统服务的实用工具
**** pstree 以树状图的方式展现进程之间的派生关系
**** telint 切换当前正在运行系统的运行等级
**** killall 使用进程的名称来杀死一组进程
**** runlevel 打印当前Linux系统的运行等级
**** batch 在系统不繁忙的时候执行定时任务
**** ps 报告当前系统的进程状态
**** init init进程是所有Linux进程的父进程
**** crontab 提交和管理用户的需要周期性执行的任务
/var/spool/cron 
**** pkill 可以按照进程名杀死进程
**** atrm 删除待执行任务队列中的指定任务
**** atq 列出当前用户的at任务列表
**** at 在指定时间执行一个任务
at TIME HH:MM YYY-MM-DD /+ n {hours,days,weeks}
*** 用户和工作组管理
**** chage 修改帐号和密码的有效期限
**** id 显示用户的ID以及所属群组的ID
**** grpconv 用来开启群组的投影密码
**** pwunconv 用来关闭用户的投影密码
**** pwconv 用来开启用户的投影密码
**** nologin 拒绝用户登录系统
**** chpasswd 批量更新用户口令的工具
**** grpunconv 用来关闭群组的投影密码
**** grpck 用于验证组文件的完整性
**** groupdel 用于删除指定的工作组
**** chsh 用来更换登录系统时使用的shell
**** gpasswd Linux下工作组文件的管理工具
**** pwck 用来验证系统认证文件内容和格式的完整性
**** groupmod 更改群组识别码或名称
**** passwd 用于让用户可以更改自己的密码
**** chfn 用来改变finger命令显示的信息
**** newusers 用于批处理的方式一次创建多个命令
**** logname 用来显示用户名称
**** groups 用来打印指定用户所属的工作组
**** finger 用于查找并显示用户信息
**** su 用于切换当前用户身份到其他用户身份
**** usermod 用于修改用户的基本信息
**** groupadd 用于创建一个新的工作组
**** userdel 用于删除给定的用户以及与用户相关的文件
**** useradd 创建的新的系统用户
*** X-Windows
**** xclip 管理 X 粘贴板
**** xset 设置X-Window系统中的用户爱好的实用工具
**** xlsfonts 列出X Server使用的字体
**** xhost 制哪些X客户端能够在X服务器上显示
**** xlsatoms 列出X服务器内部所有定义的原子成分
**** xauth 显示和编辑被用于连接X服务器的认证信息
**** xlsclients 列出显示器中的客户端应用程序
**** xinit 是Linux下X-Window系统的初始化程序
**** startx 用来启动X Window
*** SELinux
**** restorecon 恢复文件的安全上下文
**** semanage 默认目录的安全上下文查询与修改
**** setsebool 修改SElinux策略内各项规则的布尔值
**** getsebool 查询SElinux策略内各项规则的布尔值
**** sesearch 查询SELinux策略的规则详情
**** seinfo 查询SELinux的策略提供多少相关规则
**** chcon 修改对象（文件）的安全上下文
*** 文件系统管理
**** repquota 报表的格式输出磁盘空间限制的状态
**** e2label 设置第二扩展文件系统的卷标
**** findfs 标签或UUID查找文件系统
**** resize2fs ext2/ext2文件系统重新设置大小
**** e2image 将处于危险状态的文件系统保存到文件中
**** tune2fs 调整或查看ext2/ext3文件系统的文件系统参数
**** sync 用于强制被改变的内容立刻写入磁盘
**** swapoff 关闭指定的交换空间
**** swapon 激活Linux系统中交换空间
**** quota 显示磁盘已使用的空间与限制
**** quotastats 显示系统当前的磁盘配额运行状态信息
**** edquota 用于编辑指定用户或工作组磁盘配额
**** quotaon 激活Linux内核中指定文件系统的磁盘配额功能
**** quotacheck 检查磁盘的使用空间与限制
**** quotaoff 关闭Linux内核中指定文件系统的磁盘配额功能
**** mkfs 用于在设备上创建Linux文件系统
**** mountpoint 用来判断指定的目录是否是加载点
**** umount 用于卸载已经加载的文件系统
**** e2fsck 用于检查第二扩展文件系统的完整性
**** dumpe2fs 用于打印“ext2/ext3”文件系统的超级块和快组信息
**** fsck 检查并且试图修复文件系统中的错误
**** mount 用于加载文件系统到指定的加载点
 mount  [-t vfstype] [-o options] device dir
 1.-t vfstype 文件系统类型
　　光盘或光盘镜像：iso9660
　　DOS fat16文件系统：msdos
　　Windows 9x fat32文件系统：vfat
　　Windows NT ntfs文件系统：ntfs
　　Mount Windows文件网络共享：smbfs
　　UNIX(LINUX) 文件网络共享：nfs
2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：
　　loop：用来把一个文件当成硬盘分区挂接上系统
　　ro：采用只读方式挂接设备
　　rw：采用读写方式挂接设备
　　iocharset：指定访问文件系统所用字符集,不能显示中文 iocharset=cp936
3.device 要挂接(mount)的设备。
4.dir设备在系统上的挂接点(mount point)。
sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览windows 共享文件夹
**** mke2fs 创建磁盘分区上的“etc2/etc3”文系统
*** 系统关机和重启
**** halt 关闭正在运行的Linux操作系统
**** ctrlaltdel 设置组合键Ctrl+Alt+Del的功能
**** reboot 重新启动正在运行的Linux操作系统
**** shutdown 用来执行系统关机的命令
shutdown [-cfFhknr (参数名称)] [-t 秒数] [时间][警告信息] 
**** poweroff 用来关闭计算机操作系统并且切断系统电源
** 网络管理
*** 网络应用
**** axel 多线程下载工具
**** jwhois whois 客户端服务
**** curl 利用URL规则在命令行下工作的文件传输工具
**** wget Linux系统下载文件工具
**** telnet 登录远程主机和管理
**** rexec 运程执行Linux系统下命令
**** rsh 连接远程主机并执行命令
**** rlogin 从当前终端登录到远程Linux主机
**** mail 命令行下发送和接收电子邮件
**** mailstat 显示到达的邮件状态
**** lynx 纯文本模式的网页浏览器
**** elm 纯文本邮件客户端程序
**** mailq 显示待发送的邮件队列
**** lftpget 调用lftp指令下载指定的文件
**** elinks 纯文本界面的WWW浏览器
**** ipcalc 简单的IP地址计算器
**** lftp 优秀的文件客户端程序
*** 高级网络
**** tcpreplay 将PCAP包重新发送，用于性能或者功能测试
**** pfctl PF防火墙的配置命令
**** iptraf 实时地监视网卡流量
**** ss 获取socket统计信息
**** nstat/rtacct 监视SNMP计数器和网络接口状态 
**** lnstat 显示Linux系统的网路状态
**** arptables 管理ARP包过滤规则表
**** arpd 收集免费ARP信息
**** tcpdump 一款sniffer工具
**** ip 网络配置工具
**** ip6tables-restore 还原ip6tables表
**** ip6tables-save 保存ip6tables表配置
**** iptables Linux上常用的防火墙软件
*** 网络测试
**** hping3 测试网络及主机的安全
**** iperf 网络性能测试工具
**** host 常用的分析域名查询工具
**** tracepath 追踪目的主机经过的路由信息
**** arpwatch 监听网络上ARP的记录
**** nslookup 查询域名DNS信息的工具
**** arping 通过发送ARP协议报文测试网络
**** nc 
**** 用来设置路由器 dig
**** 域名查询工具 arp
**** 显示和修改 
**** ping 测试主机之间网络的连通性
**** traceroute 显示数据包到主机间的路径
**** netstat 查看Linux中网络系统状态信息
-r: 路由
-i:接口列表
-t: tcp
-u:udp
-l:LISTEN
-p:PID
*** 网络安全
**** ssh-copy-id 把本地的ssh公钥文件安装到远程主机对应的账户下
**** ssh-agent ssh密钥管理器
**** ssh-add 把专用密钥添加到ssh-agent的高速缓存中
**** nmap 网络探测和安全审核
**** iptstate 显示iptables的工作状态
**** ssh-keygen 为ssh生成、管理和转换认证密钥
**** sftp-server sftp协议的服务器端程序
**** sshd openssh软件套件中的服务器守护进程
**** ssh-keyscan 收集主机公钥的使用工具
**** sftp 交互式的文件传输程序
**** ssh openssh套件中的客户端连接工具
*** 网络配置
**** mii-tool 配置网络设备协商方式的工具
**** ethtool 显示或修改以太网卡的配置信息
**** nisdomainname 显示主机NIS的域名
**** dhclient 动态获取或释放IP地址
**** domainname 显示和设置系统的NIS域名
**** ypdomainname 显示主机的NIS的域名
**** usernetctl 被允许时操作指定的网络接口
**** dnsdomainname 定义DNS系统中FQDN名称的域名
**** hostname 显示和设置系统的主机名
**** ifup 激活指定的网络接口
**** ifcfg 置Linux中的网络接口参数
**** ifconfig 配置和显示Linux系统网卡的网络参数;调试用的
sudo ifconfig eth0 down/up
**** ifdown 禁用指定的网络接口
**** route 显示并设置Linux中静态路由表

*** 网络服务器
**** mysqlimport 为MySQL服务器用命令行方式导入数据
**** ftpshut 在指定的时间关闭FTP服务器
**** ftpcount 显示目前已FTP登入的用户人数
**** exportfs 管理NFS共享文件系统列表
**** apachectl Apache服务器前端控制工具
**** ab Apache服务器的性能测试工具
**** squid squid服务器守护进程
**** mysql MySQL服务器客户端工具
**** sendmail 著名电子邮件服务器
**** mysqlshow 显示MySQL中数据库相关信息
**** smbpasswd samba用户和密码管理工具
  创建共享目录:
  mkdir /home/xxx/share   sudo chmod 777 /home/xxx/share  说明：xxx为你的ubuntu的用户名　　　  share你可以随便起个名字做为共享文件夹	
  修改现配置文件
  sudo gedit /etc/samba/smb.conf
:  在smb.conf最后添加
	    　[share]
	     path = /home/xxx/share      
	     available = yes
	     browseable = yes
	     public = yes
             writable = yes
	     valid users =myname
	     create mask = 0700
	     directory mask =0700
	     force user =nobody
	     force group = nogroup
	     sudo smbpasswd -a myname
: 说明：valid users = myname　这个myname是自己起的，后面在添加用户名时就是添加的这个
	     另外这个[share]名字也是可以随便起的，这个是你在windows下访问时显示的名字在windows下\\162.168.160.11\share
	     就可以访问linux下/home/god/code目录下的内容了    其中162.168.160.11是你linux的IP地址,用ifconfig就可以查看到
	     samba服务器配置

**** squidclient squid服务器的客户端管理工具
**** smbclient 交互方式访问samba服务器
**** showmount 显示NFS服务器加载的信息
**** nfsstat 列出NFS客户端和服务器的工作状态
**** mysqladmin MySQL服务器管理客户端
**** ftpwho 显示当前每个ftp会话信息
**** mysqldump MySQL数据库中备份工具
**** htdigest Apache服务器内置工具
**** htpasswd apache服务器创建密码认证文件
**** ftptop proftpd服务器的连接状态
** 软件 | 打印 | 开发 | 工具
*** 常用工具命令
**** pssh 批量管理执行
**** screen 用于命令行终端切换
# screen [-AmRvx -ls -wipe][-d <作业名称>][-h <行数>][-r <作业名称>][-s ][-S <作业名称>]
参数说明
-A 　将所有的视窗都调整为目前终端机的大小。
-d <作业名称> 　将指定的screen作业离线。
-h <行数> 　指定视窗的缓冲区行数。
-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-r <作业名称> 　恢复离线的screen作业。
-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s 　指定建立新视窗时，所要执行的shell。
-S <作业名称> 　指定screen作业的名称。
-v 　显示版本信息。
-x 　恢复之前离线的screen作业。
-ls或--list 　显示目前所有的screen作业。
-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。

四、常用screen参数

screen -S yourname -> 新建一个叫yourname的session
screen -ls -> 列出当前所有的session
screen -r yourname -> 回到yourname这个session
screen -d yourname -> 远程detach某个session
screen -d -r yourname -> 结束当前session并回到yourname这个session

在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。
C-a ? -> 显示所有键绑定信息
C-a c -> 创建一个新的运行shell的窗口并切换到该窗口
C-a n -> Next，切换到下一个 window 
C-a p -> Previous，切换到前一个 window 
C-a 0..9 -> 切换到第 0..9 个 window
Ctrl+a [Space] -> 由视窗0循序切换到视窗9
C-a C-a -> 在两个最近使用的 window 间切换 
C-a x -> 锁住当前的 window，需用用户密码解锁
C-a d -> detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 
C-a z -> 把当前session放到后台执行，用 shell 的 fg 命令则可回去。
C-a w -> 显示所有窗口列表
C-a t -> Time，显示当前时间，和系统的 load 
C-a k -> kill window，强行关闭当前的 window
C-a [ -> 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样
    C-b Backward，PageUp 
    C-f Forward，PageDown 
    H(大写) High，将光标移至左上角 
    L Low，将光标移至左下角 
    0 移到行首 
    $ 行末 
    w forward one word，以字为单位往前移 
    b backward one word，以字为单位往后移 
    Space 第一次按为标记区起点，第二次按为终点 
    Esc 结束 copy mode 
C-a ] -> Paste，把刚刚在 copy mode 选定的内容贴上  
**** speedtest-cli 命令行下测试服务器外网速度
**** clockdiff 检测两台linux主机的时间差
**** ntpdate 使用网络计时协议（NTP）设置日期和时间
**** rsync 远程数据同步工具
**** vdfuse VirtualBox软件挂载VDI分区文件工具
**** ngrep 方便的数据包匹配和显示工具
**** tempfile shell中给临时文件命名
**** xargs 给其他命令传递参数的一个过滤器
**** awk 文本和数据进行处理的编程语言
**** yes 重复打印指定字符串
**** date 显示或设置系统时间与日期
**** eog 显示图片
**** consoletype 输出已连接的终端类型
**** info Linux下info格式的帮助指令
**** hostid 用来打印当前主机的数字化标识
**** clear 清除当前屏幕终端上的任何信息
**** whoami 打印当前有效的用户名称
**** users 显示当前登录系统的所有用户
**** sleep 将目前动作延迟一段时间
**** md5sum 计算和校验文件报文摘要的工具程序
**** mesg 设置当前终端的写权限
**** mtools 显示mtools支持的指令
**** login 登录系统或切换用户身份
**** stty 修改终端命令行的相关设置
**** talk 让用户和其他用户聊天
**** man 查看Linux中的指令帮助
**** whatis 查询一个命令执行什么功能
**** write 向指定登录用户终端上发送信息
**** who 显示目前登录系统的用户信息
**** sum 计算文件的校验码和显示块数
**** wall 向系统当前所有打开的终端上输出信息
**** dircolors 置ls命令在显示目录或文件时所用的色彩
**** gpm 提供文字模式下的滑鼠事件处理
**** bc 算术操作精密运算工具
**** cal 显示当前日历或指定日期的日历
cal 1988
cal -m
**** cksum 检查文件的CRC是否正确

**** qemu Emulator
  [-fda fdb] Use file as floppy disk 0/1 image	     
**** at 
at 17:20 tomorrow /bin/date
at 23:59 23/1/1444 echo the hello!
*** 软件包管理
**** dnf 新一代的RPM软件包管理器
**** dpkg-reconfigure Debian Linux中重新配制一个已经安装的软件包
**** dpkg Debian Linux系统上安装、创建和管理软件包
**** apt-sortpkgs Debian Linux下对软件包索引文件进行排序的工具
**** apt-key 管理Debian Linux系统中的软件包密钥
**** aptitude Debian Linux系统中软件包管理工具
**** apt-get Debian Linux发行版中的APT软件包管理工具
**** ntsysv 集中管理系统的各种服务
**** chkconfig 检查或设置系统的各种服务
**** rpmsign 使用RPM软件包的签名管理工具
**** rpmdb 初始化和重建RPM数据库
**** yum 基于RPM的软件包管理器
**** dpkg-trigger Debian Linux下的软件包触发器
**** rpm RPM软件包的管理工具
**** rpmverify 验证已安装的RPM软件包的正确性
**** rpmquery 从RPM数据库中查询软件包信息
**** patch 为开放源代码软件安装补丁程序
**** rpm2cpio 将RPM软件包转换为cpio格式的文件
**** dpkg-statoverride Debian Linux中覆盖文件的所有权和模式
**** dpkg-preconfigure Debian Linux中软件包安装之前询问问题
**** dpkg-split Debian Linux中将大软件包分割成小包
**** dpkg-query Debian Linux中软件包的查询工具
*** 编程开发
**** gcc 基于C/C++的预处理器和编译器
-o：指定生成的输出文件,所以编译多个文件是,-o 没有意义；
-E：仅执行编译预处理； .i
-S：将C代码转换为汇编代码；.s
-wall：显示警告信息；
-c：仅执行编译操作，不进行连接操作。.o
***** 1. 预处理 gcc -E test.c -o test.i
-C:
-H:
-include:
***** 2. 编译为汇编代码   gcc -S test.i -o test.s
masm=intel	汇编代码 
-std 指定使用的语言标准
***** 3. gas  gcc -c test.s -o test.o
:-Wa,option
:-llibrary 连接名为library的库文件
:-L 指定额外路径
:-m32
***** 4. ld  gcc test.o -o test
:-lobjc 这个-l选项的特殊形式用于连接Objective C程序.
:-nostartfiles 不连接系统标准启动文件,而标准库文件仍然正常使用.
:-nostdlib 不连接系统标准启动文件和标准库文件.只把指定的文件传递给连接器.
:-static 在支持动态连接(dynamic linking)的系统上,阻止连接共享库.该选项在其他系统上无效.
:-shared 生成一个共享目标文件,他可以和其他目标文件连接产生可执行文件.只有部分系统支持该选项.
:-symbolic 建立共享目标文件的时候,把引用绑定到全局符号上.对所有无法解析的引用作出警
告(除非用连接编辑选项 `-Xlinker -z -Xlinker defs'取代).只有部分系统支持该选项.
:-u symbol 使连接器认为取消了symbol的符号定义,从而连接库模块以取得定义.你可以使用多
个 `-u'选项,各自跟上不同的符号,使得连接器调入附加的库模块.
: [-e ENTRY]|[--entry=ENTRY]	 使用 ENTRY (入口)标识符作为程序执行的开始端,而不是缺省入口.   
: -lAR	在连接文件列表中增加归档库文件AR.可以多次使用这个选项. 凡指定一项AR,ld 就会在路径列表中增加一项对libar.a的搜索.
: -LSEARCHDIR   这个选项将路径SEARCHDIR添加到路径列表, ld在这个列表中搜索归档库.
  可以多次使用这个选项.缺省的搜索路径集(不使用-L时)取决于ld使用的
  模拟模式(emulation)及其配置.在连接脚本中,可以用SEARCH_DIR命令指定路径. 
: -Tbss org
: -Tdata org
: -Ttext org
  把org作为输出文件的段起始地址 --- 特别是 --- bss,data,或text段.org必须是十六进制整数. 
: -X    删除 全部 临时的 局部符号. 大多数 目的文件 中, 这些 局部符	    号 的 名字 用 `L' 做 开头.
: -x    删除 全部 局部符号. 
: -m 指定仿真环境,这里要与gcc 的选项 -m32一致; -V显示 支持的仿真：本机支持   elf_x86_64   
  elf32_x86_64   elf_i386   i386linux   elf_l1om   elf_k1om   i386pep   i386pe
  LDFLAGS="-L/usr/lib64 -L/lib64" 全局常量
: 注意,如果连接器通过被编译器驱动来间接引用(比如gcc), 那所有的连接器命令行选项前必须加上前缀'-Wl'
  gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup 
: `-b INPUT-FORMAT'
  `--format=INPUT-FORMAT' [binary]
  'ld'可以被配置为支持多于一种的目标文件.缺省的格式是从环境变量'GNUTARGET'中得到的.
  你也可以从一个脚本中定义输入格式,使用的命令是'TARGET'. 
: `--oformat OUTPUT-FORMAT'	  指定输出目标文件的二进制格式.一般不需要指定,ld的缺省输出格式配置
  为/各个机器上最常用的/ 格式. output-format是一个 字符串,BFD库支持的格式名称:在操作系统一层了,如果是操作系统本身,加入此选项
: [`-N']|[`--omagic']
  把text和data节设置为可读写.同时,取消数据节的页对齐,同时,取消对共享库的连接.如果输出格式
  支持Unix风格的magic number, 把输出标志为'OMAGIC'. 
***** 5. 检错
: -Wall 产生尽可能多的警告信息
: -Werror GCC会在所有产生警告的地方停止编译
***** 6. 库文件连接 .a .so
: 包含文件 -I /usr/dirpath    
: 库   -L /dirpath   -llibname  不要.a 或.so 后缀
: 强制静态库 gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
静态库链接时搜索路径顺序：
1. ld会去找GCC命令中的参数-L
2. 再找gcc的环境变量LIBRARY_PATH
3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的

动态链接时、执行时搜索路径顺序:
1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib
有关环境变量：
LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径
LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径
***** 7. 调试
-g:
-gstabs:
-gcoff:
-gdwarf:
***** 8. 优化
-O0 不优化
-fcaller-saves: 
***** 9. 目标机选项(Target Option) 交叉编译
-b machine 
-V version 哪个版本的gcc
***** 10.配置相关选项(Configuration Dependent Option)
M680x0 选项
i386选项
***** 11.总体选项(Overall Option)
-x language
明确指出后面输入文件的语言为language (而不是从文件名后缀得到的默认选择).

***** 12.目录选项(DIRECTORY OPTION)
:-Idir 在头文件的搜索路径列表中添加dir 目录.
:-Ldir 在`-l'选项的搜索路径列表中添加dir目录.

***** 13.C 文件与 汇编文件编译
以下涉及到不同编译器对符号的处理问题。比如我们写个汇编文件，汇编后，汇编文件中的符号未变，但是当我们写个C文件再生成目标文件后，源文件中的符号前可能加了下划线，当两者之间发生引用关系时可能无法连接，此时我们会用到下面的命令。
: --change-leading-char
: --remove-leading-char
: --prefix-symbols=string
**** ldconfig 动态链接库管理命令
**** readelf 用于显示elf格式文件的信息
: -a       --all
***** elf header
描述了这个elf文件的一些信息，如数据格式是big-endian 或者little-endian
运行平台、section header 的个数等。
****** section headers是一个表，表中的每个条目描述了一个section，
如section在文件中的偏移，大小等。
****** section中就是elf文件中“真正”的信息了。

**** objcopy拷贝一个目标文件的内容到另一个目标文件中,bfdnamels是BFD库中描述的标准格式名
: --info 显示支持的architecture 与 目标文件格式
: -I bfdname或--input-target=bfdname  用来指明源文件的格式,取值elf32-little，elf32-big等，可用用objdump –i查看相应的信息
: -O bfdname 或--output-target=bfdname 输出的格式
#+BEGIN_SRC 
-O srec 产生S记录格式文件
-O binary 产生原始的二进制文件
#+END_SRC
: -R sectionname 从输出文件中删除掉所有名为sectionname的段
: -S 不从源文件中复制重定位信息和符号信息到目标文件中
: -g 不从源文件中复制调试符号到目标文件中
: -j sectionname 或--only-section=sectionname 只将由sectionname指定的section拷贝到输出文件
: -K symbolname 保留由symbolname指定的符号信息
: -N symbolname 去除掉由symbolname指定的符号信息

**** objdump 显示二进制文件信息
: -a|--archive-header 列出 archive头/列表用'ar tv'
: -d反汇编
: -S|--source
: -m MACHINE| --architecture=MACHINE
: -G|--stabs
**** pstack 显示每个进程的栈跟踪
**** indent 格式化C语言的源文件
**** gdb 功能强大的程序调试器
***** options gdb <program> [core]|[PID]
-d 指定远程调试时串行接口的线路速度
-batch 以批处理模式运行
-c 指定要分析的核心转储文件
-cd 指定工作目录
-d 指定搜索源文件的目录
-e 指定要执行的文件
-f 调试时以标准格式输出文件名和行号
-q 安静模式
-s 指定符号的文件名
-se 指定符号和要执行的文件名
-tty 设置标准输出和输入设备
-x 从指定的文件执行 gdb 命令
***** 常用的调试命令
shell <command>
make <make -args>

运行参数
set args 设定参数
show args 查看运行参数
运行环境
path<dir> 设定程序的运行路径。
show paths 查看程序的运行路径。
set environment varname[=value]设置环境变量。如:set env USER=hchen
show environment[varname]查看环境变量
工作目录
cd <dir>相当于 shell 的 cd 命令。
pwd 显示当前的工作目录。
程序的输入输出
info terminal 显示程序用到的终端的模式
使用重定向空值程序输出。如 run>outfile
tty 命令可以指定写输入输出的终端设备。如 tty /dev/ttyb
列出源码 ;l 3 （开始行） 根据本地文件,没有就列不出 
设置断点 ;b filename: <行号>;break +offset -offset 当前行号前后
b filename: <函数名称>;
b *<函数名称>;
b *<代码地址> 
break...if<condition>
调试程序 ;r 
继续执行 ;c
删除断点 ; clear <行号>
删除断点 ;  d <编号>
执行一行 ;    n /s
结束循环 ;   until
p $1 ($1为历史记录变量); 
p <数组名>显示数组元素;
p <*数组指针>显示数组int a[N]的特定值：
显示变量类型;    whatis p
显示各类信息   info b 显示断点信息
finish 退出函数
info r 寄存器信息
info local 当前函数中的局部变量信息;
info prog 显示被调试程序的执行状态
break *_start+1 由于 gnu 调试时忽略开始处断点, 需要在开始标签处执行一个空指令
print/d 显示十进制数字
print/t 显示二进制数字
print/x 显示 16 进制数字

x/FMT ADDRESS.
ADDRESS is an expression for the memory address to examine.
FMT is a repeat count followed by a format letter and a size letter.
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
  t(binary), f(float), a(address), i(instruction), c(char), s(string)
  and z(hex, zero padded on the left).
Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
The specified number of objects of the specified size are printed
according to the format.
7.0版本以上gdb的disas命令可以携带/m参数，让汇编与c源码同时显示：disas /m main



使用 x 命令可以查看特定内存的值:
x/nyz
其中 n 为要显示的字段数
y 时输出格式, 它可以是:
c 用于字符, d 用于十进制, x 用于 16 进制
z 是要显示的字段长度, 它可以是:
b 用于字节, h 用于 16 字节, w 用于 32 位字
如:
x/42cb 用于显示前 42 字节
print-stack      查看堆栈               
u start end      反汇编内存                       
trace on          反汇编每一条                    
trace-reg on    每执行一条打印cpu               
xp /32bx 0x90000  查询从0x90000开始的32个字节内容 
**** expr 一款表达式计算工具
**** test shell环境中测试条件表达式工具
**** php PHP语言的命令行接口
**** protoize GNU-C代码转换为ANSI-C代码
**** mktemp 创建临时文件供shell脚本使用
**** perl perl语言解释器
**** make GNU的工程化编译工具
**** ldd 打印程序或者库文件所依赖的共享库列表
**** nm 显示二进制目标文件的符号表
**** unprotoize 删除C语言源代码文件中的函数原型
**** gcov 测试程序的代码覆盖率的工具
*** 打印
**** reject 指示打印系统拒绝发往指定目标打印机的打印任务
**** lpadmin 配置CUPS套件中的打印机和类
**** cupsenable 启动指定的打印机
**** accept 指示打印系统接受发往指定目标打印机的打印任务
**** lpstat 显示CUPS中打印机的状态信息
**** cupsdisable 停止指定的打印机
**** lpc 命令行方式打印机控制程序
**** cancel 取消已存在的打印任务
**** lp 打印文件或修改排队的打印任务
**** lpq 显示打印队列中的打印任务的状态信息
**** eject 用来退出抽取式设备
**** lprm 删除打印队列中的打印任务
**** lpr 将文件发送给指定打印机进行打印
** 文件目录管理
*** 文件查找和比较
**** strings 在对象文件或二进制文件中查找可打印的字符串
**** diff 比较给定的两个文件的不同
**** cmp 比较两个文件是否有差异
**** diff3 比较3个文件不同的地方
**** locate/slocate 查找文件或目录
-n 至多显示n 个输出
-r 使用正则做寻找条件
-d 指定资料库的路径
**** which 查找并显示给定命令的绝对路径
**** find 在指定目录下查找文件
find pathname -options [-print -exec -ok ...]
  : -print： find命令将匹配的文件输出到标准输出。
  : -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
  : -ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。

  : -name   按照文件名查找文件。
  : -perm   按照文件权限来查找文件。
  : -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
  : -user   按照文件属主来查找文件。
  : -group  按照文件所属的组来查找文件。
  : -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距
  : 现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。
  : -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
  : -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
  : -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。
  : -type  查找某一类型的文件，诸如：
  + b - 块设备文件。
  + d - 目录。
  + c - 字符设备文件。
  + p - 管道文件。
  + l - 符号链接文件。
  + f - 普通文件。
  + -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
  + -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
  + -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。
  + -mount：在查找文件时不跨越文件系统mount点。
  + -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
  + -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。

另外,下面三个的区别:
  : -amin n   查找系统中最后N分钟访问的文件  -n n天以内;+n n天之前
  : -atime n  查找系统中最后n*24小时访问的文件
  :  -cmin n   查找系统中最后N分钟被改变文件状态的文件
  :  -ctime n  查找系统中最后n*24小时被改变文件状态的文件
  :  -mmin n   查找系统中最后N分钟被改变文件数据的文件
  :  -mtime n  查找系统中最后n*24小时被改变文件数据的文件
  : find  ./    -mtime    -1    -type f    -ok   ls -l    {} \;  
  : find .    -perm -007    -exec ls -l {} \;  

**** whereis 查找二进制程序、代码等相关文件路径
*** 文件内容查看
**** hexdump 显示文件十六进制格式
-c 每单元以字节为单位，显示出对应的ASCII码
-C 每单元以字节为单位，同时显示十六机制和ASCII码
**** od 输出文件的八进制、十六进制等格式编码的字节
**** cut 连接文件并打印到标准输出设备上
cut -cnum1-num2 filename  显示每行从开头算起 num1 到num2 的文字
**** tail 在屏幕上显示指定文件的末尾若干行
**** head 在屏幕上显示指定文件的开头若干行
-c  xx xx字节
-n 行
**** less 分屏上下翻页浏览文件内容
**** more 显示文件内容，每次显示一屏
more +20 filename 从第20行开始显示
*** 文件处理
**** iconv 转换文件的编码方式
**** nl 在Linux系统中计算文件内容行号
**** basename 打印目录或者文件的基本名称
**** unlink 系统调用函数unlink去删除指定的文件
**** pathchk 检查文件中不可移植的部分
**** touch 创建新的空文件
**** rename 用字符串替换的方式批量改变文件名
**** dd 复制文件并对原文件的内容进行转换和格式化处理
: `if=FILE'     Read from FILE instead of standard input.
: `of=FILE'     Write to FILE instead of standard output.  Unless `conv=notrunc' is given, `dd' truncates FILE to zero bytes (or the size specified with `seek=').
: ibs=BYTES 指定每次输入多少字节,默认512
: obs=BYTES 输出
: skip=N   跳过 ibs指定字节的N块东西,如果iflag=skip_bytes,则跳过N 字节,就跟ibs指定多少无关了
: seek=N 跳过obs指定字节的N块东西,如果oflag=seek_bytes,则跳过N 字节,就跟obs指定多少无关了
: count=N 复制 N 块 ibs指定的东西,如果iflag=skip_bytes,则...
: `conv=CONVERSION[,CONVERSION]...'转换
  ascii / ebcdic/ibm/block/lcase/notrunc/fsync
: iflag=FLAG[,FLAG]...
  append/cio/direct/sync/binary/text/skip_bytes/seek_bytes
  
**** dirname 去除文件名中的非目录部分
**** updatedb 创建或更新locate命令所必需的数据库文件
一般只会对系统目录创建索引
**** ln 用来为文件创件连接
**** cat 连接文件并打印到标准输出设备上
-n --number 输出行号
-b --number-nonblank 行不编号
*** 文件编辑
**** nano 字符终端文本编辑器
**** sed 功能强大的流式文本编辑器
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
-e<script>或--expression=<script>：以选项中的指定的script来处理输入的文本文件；
-f<script文件>或--file=<script文件>：以选项中指定的script文件来处理输入的文本文件；

***** sed命令
a\ 在当前行下面插入文本。
i\ 在当前行上面插入文本。
c\ 把选定的行改为新的文本。
d 删除，删除选择的行。
D 删除模板块的第一行。
s 替换指定字符 sed 's/aa/bb/' file 注意/ 符,用来分界
h 拷贝模板块的内容到内存中的缓冲区。
H 追加模板块的内容到内存中的缓冲区。
g 获得内存缓冲区的内容，并替代当前模板块中的文本。
G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l 列表不能打印字符的清单。
n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p 打印模板块的行。(显示两遍)
P(大写) 打印模板块的第一行。
q 退出Sed。
b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
r file 从file中读行。
t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w file 写并追加模板块到file末尾。  
W file 写并追加模板块的第一行到file末尾。  
! 表示后面的命令对所有没有被选定的行发生作用。  
= 打印当前行号码。  
# 把注释扩展到下一个换行符以前。  

sed替换标记
g 表示行内全面替换。  
p 表示打印行。  
w 表示把行写入一个文件。  
x 表示互换模板块中的文本和缓冲区中的文本。  
y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
\1 子串匹配标记
& 已匹配字符串标记

sed元字符集
^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
[* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
& 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
\< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。 

***** sed用法实例
替换操作：s命令

替换文本中的字符串：
sed 's/book/books/' file

-n选项和p命令一起使用表示只打印那些发生替换的行：
sed -n 's/test/TEST/p' file

直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换
为books：
sed -i 's/book/books/g' file

全面替换标记g
使用后缀 /g 标记会替换每一行中的所有匹配：

sed 's/book/books/g' file
当需要从第N处匹配开始替换时，可以使用 /Ng：

echo sksksksksksk | sed 's/sk/SK/2g'
skSKSKSKSKSK

定界符
以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定
界符：
sed 's:test:TEXT:g'
sed 's|test|TEXT|g'

定界符出现在样式内部时，需要进行转义：
sed 's/\/bin/\/usr\/local\/bin/g'

删除操作：d命令
删除空白行：
sed '/^$/d' file

删除文件的第2行：
sed '2d' file

删除文件的第2行到末尾所有行：
sed '2,$d' file

删除文件最后一行：

sed '$d' file

删除文件中所有开头是test的行：

sed '/^test/'d file

已匹配字符串标记&

正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之
前所匹配到的单词：

echo this is a test line | sed 's/\w\+/[&]/g'
[this] [is] [a] [test] [line]

所有以192.168.0.1开头的行都会被替换成它自已加localhost：

sed 's/^192.168.0.1/&localhost/' file
192.168.0.1localhost

子串匹配标记\1

匹配给定样式的其中一部分：

echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
this is 7 in a number

命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，\(..\)
用于匹配子串，对于匹配到的第一个子串就标记为 \1，依此类推匹
配到的第二个结果就是 \2，例如：

echo aaa BBB | sed 's/\([a-z]\+\) \([A-Z]\+\)/\2 \1/'
BBB aaa

love被标记为1，所有loveable会被替换成lovers，并打印出来：

sed -n 's/\(love\)able/\1rs/p' file

组合多个表达式

sed '表达式' | sed '表达式'

等价于：

sed '表达式; 表达式'

引用

sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字
符串，就需要使用双引号。

test=hello
echo hello WORLD | sed "s/$test/HELLO"
HELLO WORLD

选定行的范围：,（逗号）

所有在模板test和check所确定的范围内的行都被打印：

sed -n '/test/,/check/p' file

打印从第5行开始到第一个包含以test开始的行之间的所有行：

sed -n '5,/^test/p' file

对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：

sed '/test/,/west/s/$/aaa bbb/' file

多点编辑：e命令

-e选项允许在同一行里执行多条命令：

sed -e '1,5d' -e 's/test/check/' file

上面sed表达式的第一条命令删除1至5行，第二条命令用check替换
test。命令的执行顺序对结果有影响。如果两个命令都是替换命令
，那么第一个替换命令将影响第二个替换命令的结果。

和 -e 等价的命令是 --expression：

sed --expression='s/test/check/' --expression='/love/d' file

从文件读入：r命令

file里的内容被读进来，显示在与test匹配的行后面，如果匹配多
行，则file的内容将显示在所有匹配行的下面：

sed '/test/r file' filename

写入文件：w命令  

在example中所有包含test的行都被写入file里：

sed -n '/test/w file' example

追加（行下）：a\命令

将 this is a test line 追加到以test 开头的行后面：

sed '/^test/a\this is a test line' file

在 test.conf 文件第2行之后插入 this is a test line：

sed -i '2a\this is a test line' test.conf

插入（行上）：i\命令

将 this is a test line 追加到以test开头的行前面：

sed '/^test/i\this is a test line' file

在test.conf文件第5行之前插入this is a test line：

sed -i '5i\this is a test line' test.conf

下一个：n命令

如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变
为bb，并打印该行，然后继续：

sed '/test/{ n; s/aa/bb/; }' file

变形：y命令

把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使
用这个命令：

sed '1,10y/abcde/ABCDE/' file

退出：q命令

打印完第10行后，退出sed

sed '10q' file

保持和获取：h命令和G命令

在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓
冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将
打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。

sed -e '/test/h' -e '$G' file

在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将
其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的
意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它
放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾
。在这个例子中就是追加到最后一行。简单来说，任何包含test的
行都被复制并追加到该文件的末尾。

保持和互换：h命令和x命令

互换模式空间和保持缓冲区的内容。也就是把包含test与check的行
互换：

sed -e '/test/h' -e '/check/x' file

脚本scriptfile

sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名
。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空
白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行
为注释行，且不能跨行。

sed [options] -f scriptfile file(s)

打印奇数行或偶数行

方法1：

sed -n 'p;n' test.txt  #奇数行
sed -n 'n;p' test.txt  #偶数行

方法2：

sed -n '1~2p' test.txt  #奇数行
sed -n '2~2p' test.txt  #偶数行

打印匹配字符串的下一行

grep -A 1 SCC URFILE
sed -n '/SCC/{n;p}' URFILE
awk '/SCC/{getline; print}' URFILE
**** pico 功能强大全屏幕的文本编辑器
**** emacs 功能强大的全屏文本编辑器
***** emacs(选项)(参数)
+<行号>：启动emacs编辑器，并将光标移动到制定行号的行；
-q：启动emacs编辑器，而不加载初始化文件；
-u<用户>：启动emacs编辑器时，加载指定用户的初始化文件；
-t<文件>：启动emacs编辑器时，把指定的文件作为中端，不适用标准输入（stdin）与标准输出（stdout）；
-f<函数>：执行指定lisp（广泛应用于人工智能领域的编程语言）函数；
-l<lisp代码文件>：加载指定的lisp代码文件；
-batch：以批处理模式运行emacs编辑器。

M-r : 将光标移动到屏幕中间那行
M-e : 移到句尾
M-{ : 向上移动一段
C-left : 向后移动一个单词
C-down : 向后移动一段
M-x goto-line : 移动到某一行

Buffer 相关
C-x s : 保存所有未保存的buffer，会提示你是否需要保存

拷贝与粘贴
M-space (redefined): 设置mark; C-@ 是默认命令
C-x r k : 执行矩形区域的剪切 [范围是光标处到缓冲头的一个矩形],可以选择区块
C-x r y : 执行矩形区域的粘贴

窗口操作
C-x 5 1/2/3/0 : 对frame类似的操作
C-x > : 窗口内容左卷（这两个命令在垂直分割窗口后比较有用）

搜索和替换
M-% : 查询替换，也就是替换前会询问一下
M-x replace-string : 普通替换

Tags
M-! etags .c .h : 创建TAGS文件
M-. : 跳到tag所在位置
M-x list-tags : 列出tags

书签
C-x r m : 设置书签bookmark
C-x r b : 跳到bookmark处

帮助
C-h C-f : 查看一个函数的info，非常有用

其它
C-M-\ : 对选中区域，按照某种格式(比如C程序)进行格式化
C-x h : 全部选中
M-! : 执行外部shell命令
M-x shell : 模拟shell的buffer
M-x term : 模拟terminal, C-c k 关闭terminal
C-x C-q : 修改buffer的只读属性

C-x i 插入文件
C-/ 撤销

注释
多行注释 C-x r t
反注释	 C-x r k
关闭窗口 C-x 0
窗口移动 M-x windmove-left /right /down
替换windows换行M-x replace-string RET C-q C-m RET RET

调试
gdb –annotate=3 test
无论上面的那种情况，都出现了一个现象：程序的输出不能显示，只有在程序退出的时候才显示出来。
gdb-many-windows 切换单窗格/多窗格模式
gdb-restore-windows 恢复窗格布局	
***** Emacs 插件	
# ido, 类似于helm,和helm各有千秋我都用,五五开,
# imenu 显示当前文件函数列表,可以直接跳转到那去,完全可配置
# flymake 实时语法检查,通吃所有语言
# flyspell 拼写检查,爱死了,是我见过的所有拼写检查最强大,如果你知道如何配置.
****** emacs-w3m
	C-x C-w 保存
	q	关闭窗口
	Q	直接离开
	U	打开 URL
	C-x-k	关闭当前标签页
	G	在标签页中打开一个网址
	B	后退
	ESC I	图片另存为 
	=   	显示当前页面属性 
	N	前进
	R	刷新
	F   	提交表单 
	a	添加当前页到书签
	ESC a	添加该URL到书签
	v   显示书签
	E   编辑书签
	C-k 删除书签
	C-_ 撤消书签
	M   用外部浏览器打开链接
	C-c C-k	停止载入
    C-c C-p w3m-previous-buffer    
**** jed 主要用于编辑代码的编辑器
**** joe 强大的纯文本编辑器
**** ed 单行纯文本编辑器
**** ex 启动vim编辑器的ex编辑模式
**** vi 功能强大的纯文本编辑器
*** 目录基本操作
**** install 安装或升级软件或备份数据
**** tree 树状图列出目录的内容
**** popd 用于删除目录栈中的记录
**** pushd 将目录加入命令堆叠中
**** dirs 显示目录记录
**** rmdir 用来删除空目录
-p 子目录若空,一并删除
**** mkdir 用来创建目录
**** rm 用于删除给定的文件和目录
-i 删除前询问
-r 递归
-f 强制
**** pwd 绝对路径方式显示用户当前工作目录
**** ls 显示目录内容列表
-r 反序输出
-t 时间排序
-R 输出目录下文件
-F  在列出的档案名称后加一符号；例如可执行档则加 "*",  目录则加 "/" 
**** mv 用来对文件或目录重新命名

**** cp 将源文件或目录复制到目标文件或目录中
-a     尽可能将档案状态权限等资料都照原状予以复制。 
-r     若source中含有目录名则将目录下之档案亦皆依序拷贝至目的地。 
-f     若目的地已经有相同档名的档案存在则在复制前先予以删除再行复制。 
**** cd 切换用户当前工作目录
*** 文件权限属性设置
**** dos2unix 将DOS格式文本文件转换成Unix格式
**** setfacl 设置文件访问控制列表
**** umask 用来设置限制新建文件权限的掩码
**** lsattr 查看文件的第二扩展文件系统属性
**** chmod 用来变更文件或目录的权限
chmod [-cfvR] [--help] [--version] mode file... 
:[ugoa...][[+-=][rwxX]...][,...], u 
                       , 
    -c:若该档案权限确实已经更改才显示其更改动作 
    -f:若该档案权限无法被更改也不要显示错误讯息 
    -v:显示权限变更的详细资料 
    -R:对目前目录下的所有档案与子目录进行相同的权限变更 即以递回的方式逐个变更) 
chmod -R user:group filename
**** chown 用来变更文件或目录的拥有者或所属群组
**** chgrp 用来变更文件或目录的所属群组
**** chattr 用来改变文件属性
**** stat 用于显示文件的状态信息
**** file 用来探测给定文件的类型。
*** 文件过滤分割与合并
**** egrep 在文件内查找指定的字符串
**** fgrep 为文件搜索文字字符串
**** split 分割任意大小的文件
-b,--bytes=SIZE b k m 
-l,--lines=NUMBER 每一输出文件的行数
split filename backname
**** grep 强大的文本搜索工具
**** comm 两个文件之间的比较
**** printf 格式化并输出结果
**** expand 将文件的制表符转换为空白字符
**** spell 对文件进行拼写检查
**** pr 将文本文件转换成适合打印的格式
**** look 显示文件中以指定字符串开头的任意行
**** tac 将文件已行为单位的反序输出
**** wc 统计文件的字节数、字数、行数
**** fmt 读取文件后优化处理并输出
**** rev 将文件内容以字符为单位反序输出
**** diffstat 显示diff命令输出信息的柱状图
**** ispell 检查文件中出现的拼写错误
**** uniq 报告或忽略文件中的重复行
**** tee 把数据重定向到给定文件和屏幕上
**** paste 将多个文件按列队列合并
**** sort 将文件进行排序并输出
**** unexpand 将文件的空白字符转换为制表符
**** csplit 将一个大文件分割成小的碎片文件
**** fold 控制文件内容输出时所占用的屏幕宽度
**** join 两个文件中指定栏位内容相同的行连接起来
**** col 过滤控制字符
**** tr 将字符进行替换压缩和删除
**** colrm 删除文件中的指定列
*** 文件压缩与解压
**** lha 压缩或解压缩lzh格式文件
**** bzcmp 比较两个压缩包中的文件
**** bzcat 解压缩指定的.bz2文件
**** unarj 解压缩由arj命令创建的压缩包
**** zcat 显示压缩包中文件的内容
**** znew 将.Z压缩包重新转化为gzip命令压缩的.gz压缩包
**** zipsplit 将较大的zip压缩包分割成各个较小的压缩包
**** arj 用于创建和管理.arj压缩包
**** gzexe 用来压缩可执行文件
**** bzgrep 使用正则表达式搜索.bz2压缩包中文件
**** compress 使用Lempress-Ziv编码压缩数据文件
**** zfore 强制为gzip格式的压缩文件添加.gz后缀
**** bzless 增强.bz2压缩包查看器
**** bzmore 查看bzip2压缩过的文本文件的内容
**** zipinfo 用来列出压缩文件信息
**** unzip 用于解压缩由zip命令压缩的压缩包
**** bzip2recover 恢复被破坏的.bz2压缩包中的文件
**** tar Linux下的归档使用工具，用来打包和备份。
**** bunzip2 创一个bz2文件压缩包
**** gunzip 用来解压缩文件
**** bzdiff 直接比较两个.bz2压缩包中文件的不同
**** zip 可以用来解压缩文件
**** bzip2 将文件压缩成bz2格式
**** gzip 用来压缩文件
**** uncompress 用来解压.Z文件
*** 文件备份和恢复
**** cpio 用来建立、还原备份档的工具程序
**** restore 所进行的操作和dump指令相反
**** dump 用于备份ext2或者ext3文件系统
*** 文件传输
**** ftp 用来设置文件系统相关功能
**** tftp 在本机和tftp服务器之间使用TFTP协议传输文件
**** scp 加密的方式在本地主机和远程主机之间复制文件
**** ncftp 是增强的的FTP工具
**** rcp 使在两台Linux主机之间的文件复制操作更简单

** 硬件 | 监测 | 内核 | Shell
*** Shell内建命令


**** trap 指定在接收到信号后将要采取的动作
**** let 简单的计算器
**** seq 以指定增量从首数开始打印数字到尾数 sequential sequence
**** tput 通过terminfo数据库对终端会话进行初始化和操作
**** apropos 在 whatis 数据库中查找字符串
**** set 显示或设置shell特性及shell变量
**** command 调用并执行指定的命令
**** dris 显示和清空目录堆栈中的内容
**** fc 修改历史命令并执行
**** bind 显示或设置键盘按键与其相关的功能
**** readonly 定义只读shell变量或函数
**** read 从键盘读取变量值
**** bg 用于将作业放到后台运行
**** ulimit 控制shell程序的资源
**** enable 启动或关闭shell内建命令
**** declare 声明或显示shell变量
**** wait 等待进程执行完后返回
**** builtin 执行shell内部命令
**** shopt 显示和设置shell操作选项
**** exit 退出当前的shell
**** jobs 显示Linux中的任务列表及任务状态
**** help 显示帮助信息
    shell 内建的 可以用匹配模式,也就是正则
    help -s 命令名  仅简短信息
**** history 用于显示历史命令
**** logout 退出当前登录的Shell
**** export 设置或显示系统环境变量
**** exec 调用并执行指定的命令
**** env 显示系统中已存在的环境变量
**** unset 删除指定的shell变量或函数
**** kill 删除执行中的程序或工作
**** unalias 删除由alias设置的别名
**** type 显示指定命令的类型
**** fg 将后台作业放到前台终端运行
**** alias 用来设置指令的别名
**** echo 输出指定的字符串或者变量
-e 识别转义
-n 不输出新行
[*] 输出目录
*** 性能监测与优化
**** inotifywait 异步文件系统监控机制
**** nethogs 终端下的网络流量监控工具
**** ifstat 统计网络接口流量状态
**** dstat 通用的系统资源统计工具
**** ltrace 用来跟踪进程调用库函数的情况
**** iotop 用来监视磁盘I/O使用状况的工具
**** strace 跟踪系统调用和信号
**** fuser 使用文件或文件结构识别进程
**** lsof 显示Linux系统当前已打开的所有文件列表
**** tload 显示系统负载状况
**** time 统计给定命令所花费的总时间
**** vmstat 显示虚拟内存状态
**** sar 系统运行状态统计工具
**** mpstat 显示各个可用CPU的状态
**** iostat 监视系统输入输出设备和CPU的使用情况
**** free 显示内存的使用情况
**** uptime 查看Linux系统负载信息
**** top 显示或管理执行中的程序
*** 硬件管理
**** losetup 设定与控制循环（loop）设备
**** dmidecode 在Linux系统下获取有关硬件方面的信息
**** hwclock 显示与设定硬件时钟
**** cdrecord Linux系统下光盘刻录功能命令
**** setpci 查询和配置PCI设备的使用工具
**** lspci 显示当前主机的所有PCI总线信息
**** lsusb 显示本机的USB设备列表信息
**** arch 显示当前主机的硬件架构类型
**** volname 显示指定的ISO-9660格式的设备的卷名称
**** systool 显示基于总线、类和拓扑显示系统中设备的信息
*** 内核与模块管理
**** lsb_release 显示发行版本信息
**** sysctl 时动态地修改内核的运行参数
**** slabtop 实时显示内核slab内存缓存信息
**** kernelversion 打印当前内核的主版本号
**** get_module 获取Linux内核模块的详细信息
**** kexec 从当前正在运行的内核引导到一个新内核
**** dmesg 显示Linux系统启动信息
# 查看  一般看最后几行 tail
**** uname 显示Linux系统信息
**** depmod 分析可载入模块的相依性
**** bmodinfo 显示给定模块的详细信息
**** modprobe 自动处理可载入模块
***** 触摸板和小红点
关闭:sudo modprobe -r psmouse
开启:sudo modprobe  psmouse
只关闭触摸板: synclient touchpadoff=1
开启:synclient touchpadoff=0
**** rmmod 从运行的内核中移除指定的内核模块
**** insmod 将给定的模块加载到内核中
**** lsmod 显示已载入系统的模块
*** 磁盘管理
**** blkid 查看块设备的文件系统类型、LABEL、UUID等信息
**** du 显示每个文件和目录的磁盘使用空间
-Bk -Bm (多少K,兆)
**** lsblk 列出块设备信息
**** vgremove 用于用户删除LVM卷组
**** lvresize 调整逻辑卷空间大小
**** lvremove 删除指定LVM逻辑卷
**** lvreduce 收缩逻辑卷空间
**** pvs 输出物理卷信息报表
**** pvchange 修改物理卷属性
**** pvck 检测物理卷的LVM元数据的一致性
**** pvremove 删除一个存在的物理卷
**** lvextend 扩展逻辑卷空间
**** pvdisplay 显示物理卷的属性
**** lvdisplay 显示逻辑卷属性
**** pvscan 扫描系统中所有硬盘的物理卷列表
**** lvscan 扫描逻辑卷
**** lvcreate 用于创建LVM的逻辑卷
**** pvcreate 将物理硬盘分区初始化为物理卷
**** vgconvert 转换卷组元数据格式
**** blockdev 从命令行调用区块设备控制程序
**** mkswap 建立和设置SWAP交换分区
**** vgchange 修改卷组属性
**** mknod 创建字符设备文件和块设备文件
**** mkisofs 建立ISO 9660映像文件
**** mkinitrd 建立要载入ramdisk的映像文件
**** vgreduce 从卷组中删除物理卷
**** hdparm 显示与设定硬盘的参数
**** vgextend 向卷组中添加物理卷
**** partprobe 不重启的情况下重读分区
**** vgscan 扫描并显示系统中的卷组
**** vgcreate 用于创建LVM卷组
**** fdisk 查看磁盘使用情况和磁盘分区
-l 查看磁盘
**** badblocks 查找磁盘中损坏的区块
**** vgdisplay 显示LVM卷组的信息
**** mkbootdisk 可建立目前系统的启动盘
**** grub 多重引导程序grub的命令行shell工具
     查看分区信息 cat (hd0,6)/etc/fstab
     指定/boot所在分区 root (hd[0=n],y)
     指定Linux内核 kernel /boot/vmlinux-XX ro root=/dev/hdaX
     指定initrd文件 initrd /boot/initrdXX.img
     引导系统 boot
     menu.lst
     default=0   #默认启动哪个系统,从0开始,title 开头的是第0个系统
     timeout=5
     title Ubuntu
     root (hd0,6)
     splashimage=(hd0,6)/boot/grub/splash.xpm.gz #grub的背景画面,注释加 '#' /nosplash 没背景
     hiddenmenu # 隐藏grub菜单
     kernel XX
     initrd XX
     ---------
     title WinXP #第 1 个系统
**** convertquota 把老的配额文件转换为新的格式
**** lilo 安装核心载入开机管理程序
**** df 显示磁盘的相关信息
-ia i节点使用情况
**** parted 磁盘分区和分区大小调整工具

* Shell 编程
** 变量及声明, 不声明,默认是字符串类型;变量有两个属性,
赋值属性,这里是一个框 引用属性,这里是框里的内容,要加$
declare -i a=3
-a : 数组
-f: function
-i: integer
-r:readonly
-x:通过环境输出变量
** 逻辑判断
# TITLE shell 的逻辑判断式
| 功能     | 逻辑标识 | 表示意思                    |
|----------+----------+-----------------------------|
| 文件目录 | -f       | 文件是否存在                |
|          | -d       | 目录                        |
|          | -b       | block                       |
|          | -c       | character文件               |
|          | -S       | socket                      |
|          | -L       | 符号链接                    |
|          | -e       | 某个东西                    |
|----------+----------+-----------------------------|
| 程序     | -G       | 是否由GID所执行的程序所拥有 |
|          | -O       | UID                         |
|          | -p       | name pipe or FIFO           |
|----------+----------+-----------------------------|
| 文件属性 | -r       | 可读                        |
|          | -w       | 写                          |
|          | -x       | 执行                        |
|          | -s       | 非空白                      |
|          | -u       | SUID属性                    |
|          | -g       | SGID                        |
|----------+----------+-----------------------------|
| 文件间   | -nt      | 第一个比第二个新            |
|          | -ot      | 旧                          |
|          | -ef      | 同一文件(link之类)          |
|----------+----------+-----------------------------|
| 逻辑     | &&       | AND的意思                   |
|          | 两竖     | OR                          |
|----------+----------+-----------------------------|

** 运算符
= != > < -eq -ne -lt -gt -le -ge -a (and) -o (or) -z (空字符)
-n (非空)

** 条件判断
#+BEGIN_SRC bash
if [[ one && two ]];then
elif [[ && ]];then
else
fi
#+END_SRC
#+BEGIN_SRC bash
case 种类方式(string) in
   one)
       xx
       ;;
   two)
       xx
       ;;
     *)
       xx
       exit 1;
esac
#+END_SRC
#+BEGIN_SRC bash
for ((i=1;i<=100;i=i+1))
do
    xx
done

where []
do
done

until []
do
done
#+END_SRC
** 调试 sh [-nvx] scripts
-n:查询语法,不执行
-v:显示脚本内容,执行
-x:将有使用到的脚本显示,跟-v略有不同

** 例子
整数比较
-eq 等于,如:if [ "$a" -eq "$b" ]
-ne 不等于,如:if [ "$a" -ne "$b" ]
-gt 大于,如:if [ "$a" -gt "$b" ]
-ge 大于等于,如:if [ "$a" -ge "$b" ]
-lt 小于,如:if [ "$a" -lt "$b" ]
-le 小于等于,如:if [ "$a" -le "$b" ]
< 小于(需要双括号),如:(("$a" < "$b"))
<= 小于等于(需要双括号),如:(("$a" <= "$b"))
> 大于(需要双括号),如:(("$a" > "$b"))
>= 大于等于(需要双括号),如:(("$a" >= "$b"))

字符串比较
= 等于,如:if [ "$a" = "$b" ]
== 等于,如:if [ "$a" == "$b" ],与=等价
注意:==的功能在[[]]和[]中的行为是不同的,如下:

1 [[ $a == z* ]] # 如果$a以"z"开头(模式匹配)那么将为true
2 [[ $a == "z*" ]] # 如果$a等于z*(字符匹配),那么结果为true
3
4 [ $a == z* ] # File globbing 和word splitting将会发生
5 [ "$a" == "z*" ] # 如果$a等于z*(字符匹配),那么结果为true

一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.
但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.

!= 不等于,如:if [ "$a" != "$b" ]
这个操作符将在[[]]结构中使用模式匹配.
< 小于,在ASCII字母顺序下.如:
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]
注意:在[]结构中"<"需要被转义.
> 大于,在ASCII字母顺序下.如:
if [[ "$a" > "$b" ]]
if [ "$a" \> "$b" ]
注意:在[]结构中">"需要被转义.
具体参考Example 26-11来查看这个操作符应用的例子.
-z 字符串为"null".就是长度为0.
-n 字符串不为"null"

注意:

使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z
或者就是未用""引用的字符串本身,放到[]结构中。虽然一般情况下可
以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.

awk '{print $2}' class.txt | grep '^[0-9.]' > res

SHELL下的数字比较及计算

比较：

方法一： if [ ${A} -lt ${B} ]; then ...
这是最基本的比较方法，使用lt(小于),gt(大于),le(小于等于),ge(大于等于)，优点：还没发现；缺点：只能比较整数，使用lt,gt等不直
观

方法二： if ((${A} < ${B})) then ...
这是CShell风格比较，优点：不用使用lt,gt等难记的字符串；缺点：还是只能比较整数

方法三： if (echo ${A} ${B} | awk '!($1>$2){exit 1}') then ...
这是使用awk比较，优点：可以比较小数；缺点：表达式太复杂，难记

方法四： if (echo ${A} - ${B} | bc -q | grep -q "^-"); then ...
这是使用bc计算比较，优点：可以比较小数；缺点：表达式更复杂，难记

计算：
方法一：typeset C=$(expr ${A} + ${B});
SHELL中的基本工具，优点：方便检测变量是否为数字；缺点：只能计算整数，且只能计算加减法，不能计算乘除法

方法二：let "C=${A}+${B}"; 或 let "C=A+B"
内嵌命令计算，优点：能计算乘除法及位运算等；缺点：只能计算整数

方法三：typeset C=$((A+B))
CShell风格的计算，优点：能计算乘除法及位运算等，简介，编写方便；缺点：不能计算小数

方法四：typeset C=${echo ${A} ${B} | awk '{print $1+$2}')
使用awk计算，优点：能计算小数，可以实现多种计算方式，计算灵活；缺点：表达式太复杂

方法五：typeset C=${echo ${A} + ${B} | bc -q)
使用awk计算，优点：能计算小数，计算方式比awk还多，计算灵活；缺点：表达式太复杂，小数点后面的位数必须使用scale=N来设置，否
则可能会将结果截断为整数

特殊字符

符号使用
；一般情况我们输出完一个命令需要按一个回车，如果你想在一行执行多个命令，中间可以用；号分割 cd /home ; ls
\* 表示任意字符（正则）
? 任一个字符
[abc] 列表项之一
[^abc] 对于列表取非也可以使用范围 [a-z] [0-9] [A-Z](所有字符和数字)
{} 循环列表时用 touch_{1,2,3}时就会建立touch_1,touch_2,touch_3循环出这三个文件，也会用 echo ${ab}c
~ home目录cd ~ （普通通话进入的是/home目录下用户自己的家目录）
$ 提取变量值
`` $() 命令替换touch `date +%F_\`date +%T\`` touch $(date +%F_$(date +%T))
$[] 整数计算 echo $[2+3] - * / % 浮点数用 echo "scale=3; 10/3" | bc -l (bc用于计算的)
\ 转义后面的字符串 echo \\ 输出\ 转义特殊字符，为防止被SHELL解释bash中的特殊字符
"" '' 带空格串将空格视为串的一部分 echo "abc xyz" echo 'abc xyz'
`` 命令替换取命令的执行结果
$() 同上，但它弥补了``的嵌套缺陷
@ 无特殊含义
# 注释（一般编程都需要加注释，让其他团队队员对自己写的程序功能了解）
$ 变量取值
$() 命令替换
${} 变量名的范围
% 杀后台经常jobs号，取模运算(大家对取模应该并不陌生)
^ 取非和！雷同
& 用进程后台处理， &&用于逻辑与
\* 匹配任意字符串；计算乘法
() 子进程执行
- 减号，区间，cd - 回到上层目录，杀掉当前jobs

_ （下划线）无特殊含义
+ 加号；杀掉当前jobs（进程）
= 赋值
| 管道，|| 逻辑或
\ 转义当一些特殊符号如$是一个变量需要转义才不被bash解析
{} 命令列表 {ls;cd /;}
[] 字符通配符，[]也是用于测试命令
：空命令真值
；命令结束符
"" 软引 '' 硬引
< 输入重定向
> 输出重定向
>& 合并2和1输出
, 枚举分隔符
. 当前目录
/ 目录分隔符
? 单个字符
回车命令执行

这篇文章主要介绍了Linux Shell中的特殊符号和含义简明总结,本文汇总了包含了绝大部份的Shell特殊符号,对每一个符号的作用做了总
结,需要的朋友可以参考下

在Linux Shell中有很多的特殊符号，这对于我们写Shell脚本时要特别留意：一方面要知道这些特殊符号的用法，这些符号用好了可以达到
事半功倍的效果；但另一方面要避免这些特殊符号的过度使用而导致脚本难以调试、难以阅读。

这些特殊符号罗列出来大致如下：
复制代码代码如下:
# ; ;; . , / / ‘string'| ! $ ${} $? $$ $* “string”* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || && {xx,yy,zz,…}~ ~+ ~- &
/ + – %= == !=

输出/输入重导向：
复制代码代码如下:
> >> < << : > &> 2&> 2<>>& >&2

下面就逐一介绍这些特殊符号的含义和用法……

# 井号 (comments)
这几乎是个满场都有的符号。
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo “a = $a” # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo “a = $a” # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。

~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user
或者当成是路径的一部份：~/bin；~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd 的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs

; 分号 (Command separator)
在 shell 中，担任”连续指令”功能的符号就是”分号”。譬如以下的例子：cd ~/backup ; mkdir startup ; cp ~/.* startup/.

;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case “$fop” inhelp) echo “Usage: Command -help -version filename” ;;version) echo “version 0.1″ ;;esac

. 逗号 (dot)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regular expression 中，一个
dot 代表匹配一个字元。

‘string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量
替换。
heyyou=homeecho ‘$heyyou' # We get $heyyou

“string” 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho “$heyyou” # We get home
`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo “Today $fdv”
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。

, 逗点 (comma)
这个符号常运用在运算当中当做”区隔”用途。如下例
#!/bin/bashlet “t1 = ((a = 5 + 3, b = 7 – 1, c = 15 / 3))”echo “t1 = $t1, a = $a, b = $b”

/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let “num1 = ((a = 10 / 2, b = 25 / 5))”

\ 倒斜线 (escape)
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases 的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令
的最末端，表示指令连接下一行。
# type rm
rm is aliased to `rm -i'
# \rm .\*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home
# echo “Backup dir, \$bkdir = $bkdir”
Backup dir, $bkdir = /home
上例 echo 内的 \$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir 则会输出变数的内容 /home。

| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。

! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于”
if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
在规则表达式中她担任 “反逻辑” 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 …. a9 这几个文件的其他文件。

: 冒号
在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null > f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if 这类的做
法，基本上也可以处理，但都比不上上例的简洁与效率。
除了上述之外，还有一个地方必须使用冒号
PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla
在使用者自己的HOME 目录下的 .bash_profile 或任何功能相似的档案中，设定关于”路径”的场合中，我们都使用冒号，来做区隔。

? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。

\* 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 “乘法”。
let “fmult=2*3″
除了内建指令 let，还有一个关于运算的指令 expr，星号在这里也担任”乘法”的角色。不过在使用上得小心，他的前面必须加上escape 字
元。

\** 次方运算
两个星号在运算时代表 “次方” 的意思。
let “sus=2**3″echo “sus = $sus” # sus = 8

$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo “vrs = $vrs” # vrs = 123
另外，在 Regular Expressions 里被定义为 “行” 的最末端 (end-of-line)。这个常用在 grep、sed、awk 以及 vim(vi) 当中。

${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length}
${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/
string} ${parameter//pattern/string}

$*引用script 的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}…..
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo “$*”
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。

$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。
$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo “$#”

$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行
状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho “$?”$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script 会需要产生临时文件，用来存放必要的资料。而此
script 亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。
符号$$ 或许可以符合这种需求。它代表当前shell 的 PID。
echo “$HOSTNAME, $USER, $MAIL” > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果 script 执
行完毕后仍不加以清除，会产生其他问题。
() 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ; echo $vcgh)，指令群组
有一个特性，shell会以产生 subshell 来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e “/n $a /n”)echo $a# ./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape 字元才能使用的场合，如运算式。

(())
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let 指令要好许多。
#!/bin/bash(( a = 10 ))echo -e “inital value, a = $a/n”(( a++ ))echo “after a++, a = $a”

{} 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以”分号”做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e “/n $a /n”}echo $a# ./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 “函数” 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script 也
是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。
此外，大括号还有另一种用法，如下
{xx,yy,zz,…}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin, userB-data, userC-home, userC-bin, userC-data，这几个目
录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！

[] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ "$?" != 0 ]thenecho “Executes error”exit 1fi
这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。

[[]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与 && 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak < 9 ]]thenecho $akfi || 逻辑符号这个会时常看到，代表 or 逻辑的符号。 && 逻辑符号这
个也会常看到，代表 and 逻辑的符号。 & 后台工作单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 tar
cvfz data.tar.gz data > /dev/null &
/ 单字边界
这组符号在规则表达式中，被定义为”边界”的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there 的一部份。如果我们要必免这种情况，就得加上
“边界” 的符号
grep ‘/' FileA

+ 加号 (plus)
在运算式中，她用来表示 “加法”。
expr 1 + 2 + 3
此外在规则表达式中，用来表示”很多个”的前面字元的意思。
# grep '10/+9′ fileB109100910000910000931010009#这个符号在使用时，前面必须加上 escape 字元。

- 减号 (dash)
在运算式中，她用来表示 “减法”。
expr 10 – 2
此外也是系统指令的选项符号。
ls -expr 10 – 2
在 GNU 指令中，如果单独使用 – 符号，不加任何该加的文件名称时，代表”标准输入”的意思。这是 GNU 指令的共通选项。譬如下例
tar xpvf -
这里的 – 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到”上一次”工作目录。

% 除法 (Modulo)
在运算式中，用来表示 “除法”。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。
** i/o
read
** 命令行参数
$1 $2 $0 
** Shell 输入/输出重定向
command > file 	将输出重定向到 file。
command < file 	将输入重定向到 file。
command >> file 	将输出以追加的方式重定向到 file。
n > file 	将文件描述符为 n 的文件重定向到 file。
n >> file 	将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m 	将输出文件 m 和 n 合并。
n <& m 	将输入文件 m 和 n 合并。
<< tag 	将开始标记 tag 和结束标记 tag 之间的内容作为输入。
** Shell 文件包含
#+BEGIN_SRC 
. filename   # 注意点号(.)和文件名中间有一空格
或
source filename
#+END_SRC
*** 命令替换 $(locate XXX)= `command`
* ubuntu
** Unix 的诞生
Multics
 在Dennis Ritchie帮助下,Thompson 在PDP-7上用汇编语言重写了这个游戏
unix开始用汇编写的,太慢,后改用C语言
现在UNIX和Linux好像在同一公司了
*** Linux 历史 参考了UNIX
引入了GNU 工具
** Linux应用
1. 传统服务器 LAMP(Linux, Apache, MySQL, Perl/PHP/Python)
2. 大型数据库 Oracle/DB2/postgreSQL
*** 发行版
Debian 有测试版/stable(稳定版)和不稳定版
1.升级灵活 apt-get/dpkg 方式
apt-get update/dist-upgrade
2.支持 邮件列表可以得到开发人员的免费解答(不是普通人员哦)
3.错误跟踪
** ubuntu
*** 软件类型
    main restricted(受限的,无源码) universe(社区维护) multiverse(非自由)
*** 桌面系统
**** X-Window System->WM
*** 网络服务器     
*** X-window unix 系统 GUI ,理念挺先进的
X 是一种服务,就像TCP协议一样
X服务器和X客户机之间的通信可以通过网络进行
提供用户接口: 管理接口和应用接口
*** 窗口管理
**** 焦点策略
     focus-follows-mouse
     sloppy-fucus
     click-to-focus
**** 窗口部件
*** X 的实现原理
    一个X-window 包含多个Screen,而screen 则是一个实际的Monitor或是device.
**** /etc/X11/xorg.conf 配置文件,用于X.org server man xorg.conf
xorg.conf, xorg.conf.d - configuration files for Xorg X server
#+BEGIN_SRC 
Section "section名称"
选项名称   "选项值"
选项名称   "选项值"
选项名称   "选项值"
  ...
EndSection
#+END_SRC
Files          File pathnames
ServerFlags    Server flags
Module         Dynamic module loading
Extensions     Extension enabling
InputDevice    Input device description
InputClass     Input class description
Device         Graphics device description
VideoAdaptor   Xv video adaptor description
Monitor        Monitor description
Modes          Video modes descriptions
Screen         Screen configuration
ServerLayout   Overall layout
DRI            DRI-specific configuration
Vendor         Vendor-specific configuration

** gnome应用
gnome-screenshot gimp
** web服务     WWW, Mail Server, File Server, FTP
*** apache
/etc/init.d/apach2 start
/etc/apache2/apache2.conf
**** global environemt:全局环节参数设置
ServerRoot 服务器根目录,用于存放配置/出错/日志 默认 /etc/apache2
Timeout 超时时间 默认300
Listen 默认 80
**** main server;主服务器设置
ServerAdmin   管理员邮件地址 webmaster@localhost
servername    服务器主机名   localhost
DocumentRoot  网页路径   /var/www
DefaultTyte  不能识别的文件,则按此处理,一般显示 text/plain0
ErrorLog     错误日志位置 /var/log/apache2/error.log
**** virtual hosts:虚拟服务器设置 多个站点访问
配置段
<VirtualHost></VirtualHost>
NameVirtualHost 为一个基于域名的虚拟主机指定一个IP地址(和端口)
ServerName   服务器用于识别自己的主机名和端口号
***** 基于主机名:
#+BEGIN_SRC 
#确保Apache2 在监听80端口
Listen 80
#为虚拟主机在所有IP地址上监听
NameVirtualHost *:80

<VirtualHost *:80>
DocumentRoot /var/www/xxx
ServerName www.xxx.com
#你可以在这里添加其他配置
</VirtualHost>
<VirtualHost *:80>
DocumentRoot /var/www/yyy
ServerName www.yyy.com
#你可以在这里添加其他配置
</VirtualHost>
#+END_SRC 
***** 基于IP 
有两个IP地址,一个(123,20.30.40)用于主 serverdomain.com
另一个(123.20.30.50)用于构建两个或多个虚拟主机
#+BEGIN_SRC 
Listen 80

#"主服务器运行于: 123.20.30.40
ServerName server.domain.com
DocumentRoot /var/www/mainserver

#这是另外一个IP地址
NameVirtualHost 123.20.30.50

<VirtualHost 123.20.30.50>
DocumentRoot /var/www/domain1
ServerName www.domain.com
#你可以在这里添加其他配置
</VirtualHost>

<VirtualHost 123.20.30.50>
DocumentRoot /var/www/domain2
ServerName www.domain.com
#你可以在这里添加其他配置
</VirtualHost>
#+END_SRC

在不同的端口上运行不同的站点
#+BEGIN_SRC 
Listen 80
Listen 8080

NameVirtualHost 123.20.30.40:80
NameVirtualHost 123.20.30.40:8080

<VirtualHost 123.20.30.40:80>
DocumentRoot /var/www/domain-80
ServerName www.domain.com
</VirtualHost>

<VirtualHost 123.20.30.40:8080>
DocumentRoot /var/www/domain-8080
ServerName www.domain.com
#你可以在这里添加其他配置
</VirtualHost>

<VirtualHost 123.20.30.40:80>
DocumentRoot /var/www/otherdomain-80
ServerName www.domain.com
</VirtualHost>

<VirtualHost 123.20.30.40:8080>
DocumentRoot /var/www/otherdomain-8080
ServerName www.domain.com
#你可以在这里添加其他配置
</VirtualHost>

# 这里的ServerName什么意思?
#+END_SRC

** 软件包管理
*** dpkg
dpkg -i <package> 安装
dpkg -c <package> 列出内容
dpkg -l <package> 提取信息
dpkg -r <package> 移除以安装软件包
dpkg -P <package> 完全删除,包括配置文件
dpkg -L <package> 列出所有文件清单
*** apt-get apt-cache apt-cdrom
apt-cache showsrc <package> 查看软件信息
apt-get source <package> 获取源码
install /remove /update (更新列表)/upgrade(升级可用)/help
apt-cache search 'expression'
*** synaptic
*** 打包工具 checkinstall
** shell
*** terminals (不同的终端),终端特性文件
Linux一般vt100 或 linux
*** 有了图形后,就是xorg
出现了xterm 伪终端
*** 为了在终端运行程序,发明了shell
*** 开启远程登录服务openssh-server
*** 休眠 pm-hibernate

** 网络工具 man network
*** 设置IP,这里是网络IP,内部网,什么IP都行,只要不冲突
**** 静态IP 长期固定分配
给网卡设个静态IP
Hostname xxx
IP: 192.168.1.10
Netmask 255.255.255.255
Gateway 192.168.1.100
DNS IP 210.23.23.1
**** 动态IP DHCP网络分配的临时IP
**** 设置主机名 一般是网络名+主机名设定方法 
**** 设定DNS
**** host列表 主机名解析 
**** 网络设置 /etc/sysconfig/network 服务器上的网络配置
/etc/hostname 系统主机名称
/etc/rc.d/init.d/network restart
服务与端口映射 /etc/services
名字解析器 /etc/host.conf
** 服务管理
*** 整个系统服务 ps 
*** 网络服务
开启的网络服务 netstat -tulp
监听网络的服务 netstat -lnp
连接状态 netstat -anp

*** 启用 /etc/init.d/servername start stop restart 
*** 启动过程
BIOD
MBR(boot loader)
kernel loading
init program
initial script (/etc/rc.d/rc.sysint)
daemon start (/etc/rc.d/rc[0-6].d/*)
local setting (/etc/rc.d/rc.local)
*** 管理工具 chkconfig 
* git
** Git 工作流程
  * 克隆 Git 资源作为工作目录。
  * 在克隆的资源上添加或修改文件。
  * 如果其他人修改了，你可以更新资源。
  * 在提交前查看修改。
  * 提交修改。
  * 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交
[[../image/git1.png]]
** 配置
git config [--system,--global]
/etc/gitconfig | ~/.gitconfig
user.name = "用户名或者用户ID"
user.email = "邮箱"
git config --list 查看
*** 创建验证用的公钥
ssh-keygen -C 'you email address@gmail.com' -t rsa
: 会在用户目录 ~/.ssh/ 下建立相应的密钥文件
: 可以使用 ssh -v git@github.com 命令来测试链接是否畅通
*** 上传公钥
# Title 可以随便命名，Key 的内容拷贝自 ~/.ssh/id_rsa.pub 中的内容，完成后，可以再使用 ssh -v git@github.com 进行测试。
** 管理 工作区、暂存区和版本库
*** 创建一个版本库
git init <directory>
git clone git://git.kernel.org/pub/scm/git/git.git <directory>
git remote add origin git@github.com:hanyudeye/os.git
git push origin master
git push -u origin master
*** git tag
*** git branch
*** git checkout
*** 将修改存入暂存区
git add <modified files>/git add .
*** 暂存区删除文件
git rm --cached <file>
*** 删除工作区和暂存区文件
git rm <file>
*** 取消已缓存的内容
git reset HEAD
*** 暂存区全部或指定的文件替换工作区的文件。这个操作很危险
git checkout .
git checkout -- <file>
*** 重命名
git mv 命令做得所有事情就是 git rm --cached 命令的操作，重命
名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。
*** 用 HEAD 指向的 master 分支中的全部或者部分文件替换
git checkout HEAD .
git checkout HEAD <file>
*** 提交到版本库中
git commit -m "msg"
也可以将git add与git commit用一个指令完成
git commit -a -m "msg"
*** 远程同步
git push
*** 更新本地端的repo
git pull/git pull git://github.com/tom/test.git
*** 查看状态
git status
git status -s 简短信息
git remote -v 列出服务器地址
git diff   尚未缓存的改动：
git diff --cached   查看已缓存的改动：
git diff HEAD  查看已缓存的与未缓存的所有改动：
git diff --stat   显示摘要而非整个diff
 A: 你本地新增的文件（服务器上没有）.
C: 文件的一个新拷贝.
D: 你本地删除的文件（服务器上还在）.
M: 文件的内容或者mode被修改了.
R: 文件名被修改了。
T: 文件的类型被修改了。
U: 文件没有被合并(你需要完成合并才能进行提交)。
X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。
在man git diff-files中可以查到这些标志的说明
** Git 分支管理
*** 创建分支命令：
git branch (branchname)
*** 切换分支命令:
git checkout (branchname)
当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工
作目录的内容，所以多个分支不需要多个目录。
*** 合并分支命令:
git merge 
*** 列出分支基本命令：
git branch
*** 创建新分支并立即切换到该分支下，从而在该分支中操作
git checkout -b (newbranchname)
*** 删除分支命令：
git branch -d (branchname)
*** 把bug_fix这个branch和现在的branch合并
git merge bug_fix 
*** Git 查看提交历史
git log
git log --oneline 简洁--graph 拓扑图 '--reverse'逆向显示
 --author 指定用户日志
如果你要指定日期，可以执行几个选项：--since 和 --before，但
是你也可以用 --until 和 --after。
git show 可以看某次的变更
*** 查看远程分支
git branch -r # 查看远程branch
git checkout -b bug_fix_local bug_fix_remote #把本地端切换为远程的bug_fix_remote branch并命名为bug_fix_local
** .gitignore
*** 配置语法：
　　以斜杠“/”开头表示目录；
　　以星号“*”通配多个字符；
　　以问号“?”通配单个字符
　　以方括号“[]”包含单个字符的匹配列表；
　　以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；
规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；

* linux 系统调用
* 1、进入HTML模式

让Emacs进入HTML模式很简单，直接打开一个HTML文件即可，也可以使用 M-x html-mode指令。进入 HTML模时候，Emacs的菜单栏中会出现"HTML"和"SGML"菜单，仔细观摩一下。
Emacs提供了一个简单的HTML模板来缓解一些懒人因不愿过多输入代码的抱怨情绪，C-c C-t html，然后需要输入title内容回车，即可调入该模板。C-c C-v可以调出浏览器看看当前HTML代码的显示效果。M-x html-autoview-mode，可以实现在Emacs保存HTML文档之时打开浏览器查看文档显示效果。


Emacs HTML模式提供了标签之间的光标快速移动的键盘绑定：


    C-c C-f，光标移到其当前所在位置的下一个HTML标签位置
    C-c C-b，光标移到其当前所在位置的前一个HTML标签位置 


3、隐藏/显示HTML标记
当你觉得正在编写的HTML文档中无处不在的HTML标记破坏了文档的美感，可以试试C-c Tab，暂时将HTML标记隐藏起来，只显示你的文本内容。在HTML隐藏状态下继续编辑文档，Emacs会保护其隐藏的所有标记，所以你没有必要担心会不小心把它们给删掉了，而且当你的光标移动到一个被隐藏的标记位置上时，Emacs会在Mini-buffer中显示该标记名。
在HTML标记隐藏状态下，再次C-c Tab，即可将所有被隐藏的HTML标记重新显示出来。
4、HTML模式其它一些常用的键绑定
C-c 1～6，可以自动插入h1～h6的标题。譬如键入C-c 1，就会在当前位置自动插入h1标题。
C-c Enter，可以实现在光标位置插入段落标记。这个键绑定，我不是很喜欢。因为我习惯使用 … 风格的段落标记。但是可以先使用这个键绑定作出段落标记的前一半，然后使用C-c /将其封闭。对于其它未提供闭合功能的键绑定，都可以使用这种方法。
C-c C-c h，可以实现在光标位置插入超级连接标记。C-c C-c n可以实现在光标当前位置处插入一个anchor(锚标)，以备在文档其他位置建立跳转到该位置的超级链接。这两个键盘绑定，需要在Mini-buffer中输入超级连接地址或锚标名称。动手一试便知了。
C-c C-c u，在光标位置处插入无序列表标记。C-c C-c o，在光标当前位置插入有序列表标记。C-c C-c l，在当前位置插入一个列表项。与C-c C-c p一样，所插入的标记依然是不封闭的。
C-c C-c i，在光标位置插入图像引入标记，即，需要在Mini-buffer中指定图片的 URL。
C-c C-j，在光标位置处插入换行符
。C-c C-c -，在光标位置处插入水平线标记，即。
如果想看看某个标记的解释，可以将光标移到该标记上，C-c ?，在Mini-buffer中显示解释。
想知道更多一些的键绑定功能，可以C-c C-h，看看说明。
5、HTML模式中的特殊字符输入
在HTML中，已经被用作HTML标记的字符，如果要在HTML文本中将它们显示出来，直接键入是不行的。譬如我要在HTML页面中显示，浏览器会将它视为段落标记来处理。为了解决这个问题，我们可以C-c C-n ，再键入字母p，最后再C-c C-n >来实现。通过这个小例子，应该知道C-c C-n的功用了吧。对于其它字符，只要键盘上有的，但 HTML语言已经征用了的，都可以使用这个键绑定来输入。
对于键盘上没有的字符，譬如拉丁文－1中的字符，该如何输入呢？Emacs HTML模式提供了许多语言模式。使用键绑定C-c 8可以打开SGML name entity小模式，这个键绑定是以开关方式执行的，即再次键入C-c 8即可关闭这个该模式。打开 SGML name entity小模式后，键入C-x RET k，选择语言模式，我们要使用拉丁文－1，那么就可以键入 latin-1，回车即可进入拉丁文－1字符插入模式。在向HTML文档中插入拉丁文-1字符时，使用键绑定C-x 8为前缀。譬如，我要在文档中插入"&yen;"，只需要键入C-x 8 Y即可。此时，在HTML源文件中，会将&yen;显示为其字符实体，即"& yen"，而在Mini-buffer中会同时显示所插入的实际符号"&yen;"，此时只需执行一次Undo(C-x u或C-_)，就可以将Mini-buffer中的实际符号送入到源文件中了。
可以在HTML定义的标准字符表中查找你所需要的字符实体，这个字符表可以在网上搜一搜了。

* Linux 内核
** 进程管理(process management)
** timer(定时器)
** interrupt management
** memory management
** module management
** VFS layer
** file system
** device driver
** inter-process communication
** network management
** system init
* arch linux
** install
*** pre-installation
     need 800MB of diskspace ;network;
**** 1.1 verify the boot mode
  if exist the efivars directory,then UEFI motherboard boot
  ls /sys/firmware/efi/efivars
else the system is booted in BIOS(or CSM) mode
**** 1.2 set the keyboard layout
 default console keymap is US.
all: ls /usr/share/kbd/keymaps/**/*.map.gz
layout changed: loadkeys de-latin1
console fonts: /usr/share/kbd/consolefonts/
set font: setfont
**** 1.3 connect the Internet
default wired devices: dhcpcd
different network: systemd-networkd and netctl;first stop dhcpcd@interface.service
无线 wifi-menu
**** 1.4 update the system clock
timedatectl set-ntp true
check the service status: timedatectl status
timedatectl set-timezone Asia/Shanghai
**** 1.5 partition the disks
fdisk or parted for both MBR and GPT, or
gdisk for GPT only
display partitions: lsblk or fdisk -l
/(root) directory must be available
如果要LVM,disk encryption or RAID,现在就做
**** 1.6 format the partions
mkfs,mkswap
**** 1.7 Mount the file system
mount /dev/sda1 /mnt
mount /dev/XX /mnt/boot 100MB 够了
mount /dev/xxx /mnt/home
swapon /dev/xxx
*** Installation
**** 2.1 Select the mirrors
packages to be installed from the mirror servers,need downloaded.
defined in /etc/pacman.d/mirrorlist 
**** 2.2 Install the base packages
base package group: pacstrap /mnt base base-devel
ohter packages: append their names to pacstrap or pacman
*** Configure the system
**** 3.1 Fstab (-U or -L to define by UUID or labels)
     genfstab -U /mnt >> /mnt/etc/fstab
     check the resulting file in /mnt/etc/fstab
**** 3.2 Chroot
     arch-chroot /mnt
**** Time zone
list-timezones
set: ln -s /usr/share/zoneinfo/zone/subzone /etc/localtime
generate /etc/adjtime: hwclock --systohc --utc
**** Locale
uncomment en_US.UTF-8 UTF-8 and other needed localizations in
/etc/locale.gen,and generate them with:
# locale-gen
set the LANG variable 
# echo LANG=en_US.UTF-8 > /etc/locale.conf
if required,set the console keymap and font in vconsole.conf
**** Hostname
create:
# echo myhostname >/etc/hostname
add: /etc/hosts
127.0.1.1 myhostname.localdomain myhostname
**** Network configuration
For wireless configuration, install the iw,wpa_supplicant,and dialog packages, and firmware packages.
systemctl enable dhcpcd@enp2s0.service
**** Initramfs RAM磁盘
create a new initial RAM disk with:
# mkinitcpio -p linux
**** Root password
# passwd
**** Boot loader
pacman -S grub
grub-install /dev/sda
grub-mkconfig -o /boot/grub/grub.cfg
**** 用户
useradd -m -g users -G wheel -s /bin/bash ikke
passwd ikke

安装 sudo
pacman -S sudo
打开 /etc/sudoers 文件，找到 root ALL=(ALL) ALL 并依葫芦画瓢添加 ikke ALL=(ALL) ALL 即可。

*** Reboot
# exit 
# umount -R /mnt
# reboot
*** Post-installation
* 正则 最小单位是char
foo ——————字符串“foo”  
^foo ——————以“foo”开头的字符串  
foo$ ——————以“foo”结尾的字符串  
^foo$ ——————“foo”开头和结尾，（只能是他自己 ）  
[abc]—————— a 或者b 或者c  
[a-z] —————— a到z之间任意字母  
[^A-Z]——————除了 A-Z这些之外的字符  
(gif|jpg)——————“gif”或者 “jpeg”  
[a-z]+—————— 一个或者多个 a到z之间任意字母  
[0-9.-]—————— 0-9之间任意数字，或者 点 或者 横线  
^[a-zA-Z0-9_]{1,}$—————— 至少一个字母数字下划线  
([wx])([yz])—————— wy或wz或xy或xz  
[^A-Za-z0-9]—————— 字符数字之外的字符  
([A-Z]{3}|[0-9]{4})—————— 三个大写字母或者4个数字  

    \B 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。  
    \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。  
    \d 匹配一个数字字符。等价于 [0-9]。  
    \D 匹配一个非数字字符。等价于 [^0-9]。  
    \f 匹配一个换页符。等价于 \x0c 和 \cL。  
    \n 匹配一个换行符。等价于 \x0a 和 \cJ。  
    \r 匹配一个回车符。等价于 \x0d 和 \cM。  
    \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。  
    \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。  
    \t 匹配一个制表符。等价于 \x09 和 \cI。  
    \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。  
    \w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。  
    \W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。  
    \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。.  
    \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。  
    \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。  
    \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。  
    \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。  
    \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。  

 
 
    常用的正则表达式
    1、非负整数：”^\d+$”
    2、正整数：”^[0-9]*[1-9][0-9]*$”
    3、非正整数：”^((-\d+)|(0+))$”
    4、负整数：”^-[0-9]*[1-9][0-9]*$”
 
    5、整数：”^-?\d+$”

    6、非负浮点数：”^\d+(\.\d+)?$”

	7、正浮点数：”^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$”

    8、非正浮点数：”^((-\d+\.\d+)?)|(0+(\.0+)?))$”

    9、负浮点数：”^(-((正浮点数正则式)))$”

    10、英文字符串：”^[A-Za-z]+$”

    11、英文大写串：”^[A-Z]+$”

    12、英文小写串：”^[a-z]+$”

    13、英文字符数字串：”^[A-Za-z0-9]+$”

    14、英数字加下划线串：”^\w+$”

    15、E-mail地址：”^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$”

    16、URL：”^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$”

PHP 常用正则表达式整理
表单验证匹配
验证账号，字母开头，允许 5-16 字节，允许字母数字下划线：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
验证账号，不能为空，不能有空格，只能是英文字母：^\S+[a-z A-Z]$
验证账号，不能有空格，不能非数字：^\d+$
验证用户密码，以字母开头，长度在 6-18 之间：^[a-zA-Z]\w{5,17}$
验证是否含有 ^%&',;=?$\ 等字符：[^%&',;=?$\x22]+
匹配Email地址：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
匹配腾讯QQ号：[1-9][0-9]{4,}
匹配日期，只能是 2004-10-22 格式：^\d{4}\-\d{1,2}-\d{1,2}$
匹配国内电话号码：^\d{3}-\d{8}|\d{4}-\d{7,8}$
评注：匹配形式如 010-12345678 或 0571-12345678 或 0831-1234567
匹配中国邮政编码：^[1-9]\d{5}(?!\d)$
匹配身份证：\d{14}(\d{4}|(\d{3}[xX])|\d{1})
评注：中国的身份证为 15 位或 18 位
不能为空且二十字节以上：^[\s|\S]{20,}$
 
字符匹配
匹配由 26 个英文字母组成的字符串：^[A-Za-z]+$
匹配由 26 个大写英文字母组成的字符串：^[A-Z]+$
匹配由 26 个小写英文字母组成的字符串：^[a-z]+$
匹配由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$
匹配由数字、26个英文字母或者下划线组成的字符串：^\w+$
匹配空行：\n[\s| ]*\r 
匹配任何内容：[\s\S]* 
匹配中文字符：[\x80-\xff]+ 或者 [\xa1-\xff]+ 
只能输入汉字：^[\x80-\xff],{0,}$ 
匹配双字节字符(包括汉字在内)：[^\x00-\xff] 
匹配数字 
只能输入数字：^[0-9]*$ 
只能输入n位的数字：^\d{n}$
只能输入至少n位数字：^\d{n,}$ 
只能输入m-n位的数字：^\d{m,n}$ 
匹配正整数：^[1-9]\d*$
匹配负整数：^-[1-9]\d*$
匹配整数：^-?[1-9]\d*$
匹配非负整数（正整数 + 0）：^[1-9]\d*|0$
匹配非正整数（负整数 + 0）：^-[1-9]\d*|0$
匹配正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$
匹配负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$
匹配浮点数：^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$  
匹配非负浮点数（正浮点数 + 0）：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$  
匹配非正浮点数（负浮点数 + 0）：^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
 
其他  
匹配HTML标记的正则表达式（无法匹配嵌套标签）：<(\S*?)[^>]*>.*?</\1>|<.*? />  
匹配网址 URL ：[a-zA-z]+://[^\s]*   
匹配 IP 地址：((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)   
匹配完整域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?
 
提示
    上述正则表达式通常都加了 ^ 与 $ 来限定字符的起始和结束，如果需要匹配的内容包括在字符串当中，可能需要考虑去掉 ^ 和 $ 限定符。
    以上正则表达式仅供参考，使用时请检验后再使用s   
	

     

 

* shell高级编程例子
例子清单:  
2-1.  清除:清除/var/log 下的 log 文件  
2-2.  清除:一个改良的清除脚本  
2-3. cleanup:一个增强的和广义的删除 logfile 的脚本  
3-1.  代码块和 I/O 重定向  
3-2.  将一个代码块的结果保存到文件  
3-3.  在后台运行一个循环  
3-4.  备份最后一天所有修改的文件.  
4-1.  变量赋值和替换  
4-2.  一般的变量赋值  
4-3.  变量赋值,一般的和比较特殊的  
4-4.  整型还是 string?  
4-5.  位置参数  
4-6. wh,whois 节点名字查询  
4-7.  使用 shift  

----------------------- Page 8-----------------------

5-1. echo 一些诡异的变量  
5-2.  转义符  
6-1. exit/exit 状态  
6-2.  否定一个条件使用!  
7-1.  什么情况下为真?  
7-2.  几个等效命令 test,/usr/bin/test,[],和/usr/bin/[  
7-3.  算数测试使用(( ))  
7-4. test 死的链接文件  
7-5.  数字和字符串比较  
7-6.  测试字符串是否为 null  

7-7. zmore  
8-1.  最大公约数  
8-2.  使用算术操作符  
8-3.  使用&&和||进行混合状态的 test  
8-4.  数字常量的处理  
9-1. $IFS 和空白  
9-2.  时间输入  
9-3.  再来一个时间输入  

9-4. Timed read  
9-5.  我是 root?  
9-6. arglist:通过$*和$@列出所有的参数  
9-7.  不一致的$*和$@行为  
9-8.  当$IFS 为空时的$*和$@  
9-9.  下划线变量  
9-10.  在一个文本文件的段间插入空行  
9-11.  利用修改文件名,来转换图片格式  
9-12.  模仿 getopt 命令  
9-13.  提取字符串的一种可选的方法  
9-14.  使用参数替换和 error messages  
9-15.  参数替换和"usage"messages  
9-16.  变量长度  
9-17.  参数替换中的模式匹配  
9-18.  重命名文件扩展名  
9-19.  使用模式匹配来分析比较特殊的字符串  
9-20.  对字符串的前缀或后缀使用匹配模式  
9-21.  使用 declare 来指定变量的类型  
9-22.  间接引用  
9-23.  传递一个间接引用给 awk  
9-24.  产生随机数  
9-25.  从一副扑克牌中取出一张随机的牌  
9-26.  两个指定值之间的随机数  
9-27.  使用随机数来摇一个骰子  
9-28.  重新分配随机数种子  
9-29.  使用 awk 产生伪随机数  

----------------------- Page 9-----------------------

9-30. C 风格的变量处理  
10-1.  循环的一个简单例子  
10-2.  每个[list]元素带两个参数的 for 循环  
10-3.  文件信息:对包含在变量中的文件列表进行操作  
10-4.  在 for 循环中操作文件  
10-5.  在 for 循环中省略[list]  
10-6.  使用命令替换来产生 for 循环的[list]  
10-7.  对于二进制文件的一个 grep 替换  
10-8.  列出系统上的所有用户  
10-9.  在目录的所有文件中查找源字串  
10-10.  列出目录中所有的符号连接文件  
10-11.  将目录中的符号连接文件名保存到一个文件中  
10-12.  一个 C 风格的 for 循环  
10-13.  在 batch mode 中使用efax  
10-14.  简单的 while 循环  
10-15.  另一个while 循环  
10-16.  多条件的 while 循环  
10-17. C 风格的 while 循环  
10-18. until 循环  
10-19.  嵌套循环  
10-20. break 和 continue 命令在循环中的效果  
10-21.  多层循环的退出  
10-22.  多层循环的 continue  
10-23.  在实际的任务中使用"continue N"  
10-24.  使用 case  
10-25.  使用 case 来创建菜单  
10-26.  使用命令替换来产生 case 变量  
10-27.  简单字符串匹配  
10-28.  检查是否是字母输入  
10-29.  用 select 来创建菜单  
10-30.  用函数中 select 结构来创建菜单  
11-1.  一个 fork 出多个自己实例的脚本  

11-2. printf  
11-3.  使用 read,变量分配  
11-4.  当使用一个不带变量参数的 read 命令时,将会发生什么?  
11-5. read 命令的多行输入  
11-6.  检测方向键  
11-7.  通过文件重定向来使用 read  
11-8.  管道输出到 read 中的问题  
11-9.  修改当前的工作目录  
11-10.  用"let"命令来作算术操作.  
11-11.  显示 eval 命令的效果  
11-12.  强制登出(log-off)  
11-13.  另一个"rot13"的版本  

----------------------- Page 10-----------------------

11-14.  在 Perl 脚本中使用 eval 命令来强制变量替换  
11-15.  使用 set 来改变脚本的位置参数  
11-16.  重新分配位置参数  
11-17. Unset 一个变量  
11-18.  使用 export 命令传递一个变量到一个内嵌 awk 的脚本中  
11-19.  使用 getopts 命令来读取传递给脚本的选项/参数.  
11-20. "Including"一个数据文件  
11-21.  一个没什么用的,source 自身的脚本  
11-22. exec 的效果  
11-23.  一个 exec 自身的脚本  
11-24.  在继续处理之前,等待一个进程的结束  
11-25.  一个结束自身的脚本.  
12-1.  使用 ls 命令来创建一个烧录 CDR 的内容列表  

12-2. Hello or Good-bye  
12-3.  删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..  
12-4.  通过文件的  inode  号来删除文件  
12-5. Logfile:  使用  xargs  来监控系统  log  
12-6.  把当前目录下的文件拷贝到另一个文件中  
12-7.  通过名字 Kill 进程  
12-8.  使用 xargs 分析单词出现的频率  
12-9.  使用  expr  
12-10.  使用  date  命令  
12-11.  分析单词出现的频率  
12-12.  那个文件是脚本?  
12-13.  产生 10 进制随机数  
12-14.  使用  tail  命令来监控系统 log  
12-15.  在一个脚本中模仿  "grep"  的行为  
12-16.  在 1913 年的韦氏词典中查找定义  
12-17.  检查列表中单词的正确性  
12-18.  转换大写:  把一个文件的内容全部转换为大写.  
12-19.  转换小写:  将当前目录下的所有文全部转换为小写.  
12-20. Du: DOS  到  UNIX  文本文件的转换.  
12-21. rot13: rot13,  弱智加密.  

12-22. Generating "Crypto-Quote" Puzzles  
12-23.  格式化文件列表.  
12-24.  使用  column  来格式化目录列表  
12-25. nl:  一个自己计算行号的脚本.  
12-26. manview:  查看格式化的 man 页  
12-27.  使用  cpio  来拷贝一个目录树  
12-28.  解包一个  rpm  归档文件    
12-29.  从  C  文件中去掉注释  

12-30. Exploring /usr/X11R6/bin  
12-31.  一个"改进过"的  strings    命令  
12-32.  在一个脚本中使用  cmp  来比较 2 个文件.  

----------------------- Page 11-----------------------

    12-33. basename  和  dirname  
    12-34.  检查文件完整性    
    12-35. Uudecod  编码后的文件  
    12-36.  查找滥用的连接来报告垃圾邮件发送者  
    12-37.  分析一个垃圾邮件域  
    12-38.  获得一份股票报价  
    12-39.  更新  Fedora Core 4    
    12-40.  使用  ssh  
    12-41.  一个可以 mail 自己的脚本  
    12-42.  按月偿还贷款  
    12-43.  数制转换  
    12-44.  使用  "here document"  来调用  bc  
    12-45.  计算圆周率  
    12-46.  将 10 进制数字转换为 16 进制数字  
    12-47.  因子分解  
    12-48.  计算直角三角形的斜边  
    12-49.  使用  seq  来产生循环参数  
    12-50.  字母统计  
    12-51.  使用 getopt 来分析命令行选项  
    12-52.  一个拷贝自身的脚本  
    12-53.  练习 dd  
    12-54.  记录按键  
    12-55.  安全的删除一个文件  
    12-56.  文件名产生器  
    12-57.  将米转换为英里  
    12-58.  使用  m4  
    13-1.  设置一个新密码  
    13-2.  设置一个擦除字符  
    13-3.  关掉终端对于密码的 echo  
    13-4.  按键检测  

    13-5. Checking a remote server for identd<rojy bug>  
    13-6. pidof  帮助杀掉一个进程  
    13-7.  检查一个 CD 镜像  
    13-8.  在一个文件中创建文件系统  
    13-9.  添加一个新的硬盘驱动器  
    13-10.  使用 umask 来将输出文件隐藏起来  
    13-11. killall,  来自于  /etc/rc.d/init.d  
    14-1.  愚蠢的脚本策略  
    14-2.  从循环的输出中产生一个变量  
    14-3.  找 anagram(回文构词法,  可以将一个有意义的单词,  变换为 1 个或多个有意义的单词,  但 
是还是原来的子母集合)  
    16-1.  使用 exec 重定向标准输入  
    16-2.  使用 exec 来重定向 stdout  
    16-3.  使用 exec 在同一脚本中重定向 stdin 和 stdout  

----------------------- Page 12-----------------------

16-4.  避免子 shell  
16-5. while 循环的重定向  
16-6.  另一种while 循环的重定向  
16-7. until 循环重定向  
16-8. for 循环重定向  
16-9. for 循环重定向  loop (将标准输入和标准输出都重定向了)  
16-10.  重定向 if/then 测试结构  
16-11.  用于上面例子的"names.data"数据文件  
16-12.  记录日志事件  
17-1.  广播:  发送消息给每个登录上的用户  
17-2.  仿造文件:  创建一个两行的仿造文件  
17-3.  使用 cat 的多行消息  
17-4.  带有抑制 tab 功能的多行消息  
17-5.  使用参数替换的 here document  
17-6.  上传一个文件对到"Sunsite"的 incoming 目录  
17-7.  关闭参数替换  
17-8.  一个产生另外一个脚本的脚本  
17-9. Here documents 与函数  
17-10. "匿名" here Document  
17-11.  注释掉一段代码块    
17-12.  一个自文档化(self-documenting)的脚本  
17-13.  在一个文件的开头添加文本  
20-1.  子 shell 中的变量作用域  
20-2.  列出用户的配置文件  
20-3.  在子 shell 里进行串行处理  
21-1.  在受限的情况下运行脚本  
23-1.  简单函数  
23-2.  带着参数的函数  
23-3.  函数和被传给脚本的命令行参数  
23-4.  传递间接引用给函数  
23-5.  解除传递给函数的参数引用  
23-6.  再次尝试解除传递给函数的参数引用  
23-7.  两个数中的最大者  
23-8.  把数字转化成罗马数字  
23-9.  测试函数最大的返回值  
23-10.  比较两个大整数  
23-11.  用户名的真实名  
23-12.  局部变量的可见范围  
23-13.  用局部变量来递归  
23-14.  汉诺塔  
24-1.  脚本中的别名  
24-2. unalias:  设置和删除别名  
25-1.  使用"与列表(and list)"来测试命令行参数  
25-2.  用"与列表"的另一个命令行参数测试  

----------------------- Page 13-----------------------

25-3. "或列表"和"与列表"的结合使用  
26-1.  简单的数组用法  
26-2.  格式化一首诗  
26-3.  多种数组操作  
26-4.  用于数组的字符串操作符  
26-5.  将脚本的内容传给数组  
26-6.  一些数组专用的工具  
26-7.  关于空数组和空数组元素  
26-8.  初始化数组  
26-9.  复制和连接数组  
26-10.  关于连接数组的更多信息  
26-11.  一位老朋友:  冒泡排序  
26-12.  内嵌数组和间接引用  
26-13.  复杂数组应用: 埃拉托色尼素数筛子  
26-14.  模拟下推的堆栈  
26-15.  复杂的数组应用:  列出一种怪异的数学序列  
26-16.  模拟二维数组,并使它倾斜  
27-1.  利用/dev/tcp  来检修故障  
27-2.  搜索与一个 PID 相关的进程  
27-3.  网络连接状态  
28-1.  隐藏 cookie 而不再使用  
28-2.  用/dev/zero 创建一个交换临时文件  
28-3.  创建 ramdisk  
29-1.  一个错误的脚本  
29-2.  丢失关键字(keyword)  
29-3.  另一个错误脚本  
29-4.  用"assert"测试条件  
29-5.  捕捉  exit  
29-6.  在 Control-C 后清除垃圾  
29-7.  跟踪变量  
29-8.  运行多进程  (在多处理器的机器里)  
31-1.  数字和字符串比较是不相等同的  
31-2.  子 SHELL 缺陷  
31-3.  把 echo 的输出用管道输送给 read 命令  
33-1. shell  包装  
33-2.  稍微复杂一些的 shell 包装  
33-3.  写到日志文件的 shell 包装  
33-4.  包装 awk 的脚本  
33-5.  另一个包装 awk 的脚本  
33-6.  把 Perl 嵌入 Bash 脚本  
33-7. Bash  和  Perl  脚本联合使用  
33-8.  递归调用自己本身的(无用)脚本  
33-9.  递归调用自己本身的(有用)脚本  
33-10.  另一个递归调用自己本身的(有用)脚本  

----------------------- Page 14-----------------------

33-11.  一个  "彩色的"  地址资料库  
33-12.  画盒子  
33-13.  显示彩色文本  
33-14. "赛马"  游戏  
33-15.  返回值技巧  
33-16.  整型还是 string?  
33-17.  传递和返回数组  
33-18. anagrams 游戏  
33-19.  在 shell 脚本中调用的窗口部件  
34-1.  字符串扩展  
34-2.  间接变量引用  -  新方法  
34-3.  使用间接变量引用的简单数据库应用  
34-4.  用数组和其他的小技巧来处理四人随机打牌  

  
A-1. mailformat: Formatting an e-mail message  
A-2. rn: A simple-minded file rename utility  
A-3. blank-rename: renames filenames containing blanks  
A-4. encryptedpw: Uploading to an ftp site, using a locally encrypted password  
A-5. copy-cd: Copying a data CD  
A-6. Collatz series  
A-7. days-between: Calculate number of days between two dates  
A-8. Make a "dictionary"  
A-9. Soundex conversion  
A-10. "Game of Life"  
A-11. Data file for "Game of Life"  
A-12. behead: Removing mail and news message headers  
A-13. ftpget: Downloading files via ftp  
A-14. password: Generating random 8-character passwords  
A-15. fifo: Making daily backups, using named pipes  
A-16. Generating prime numbers using the modulo operator  
A-17. tree: Displaying a directory tree  
A-18. string functions: C-like string functions  
A-19. Directory information  
A-20. Object-oriented database  
A-21. Library of hash functions  
A-22. Colorizing text using hash functions  
A-23. Mounting USB keychain storage devices  
A-24. Preserving weblogs  
A-25. Protecting literal strings  
A-26. Unprotecting literal strings  
A-27. Spammer Identification  
A-28. Spammer Hunt  
A-29. Making wget easier to use  
A-30. A "podcasting" script  

----------------------- Page 15-----------------------

A-31. Basics Reviewed  
A-32. An expanded cd command  
C-1. Counting Letter Occurrences  
K-1. Sample .bashrc file  
L-1. VIEWDATA.BAT: DOS Batch File  
L-2. viewdata.sh: Shell Script Conversion of VIEWDATA.BAT  
P-1. Print the server environment  
  
