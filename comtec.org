编程就是在改变世界，语言是改变世界的工具，人是改变世界的主体。这里所说的世界是计算机世界。各种工具都在改变世界，当然你也可以一个人开发所有工具。
环境的概念:提供了不同的外部容器，而你怎么操作，就是创造力。
* 硬件
  处理器
  内存
  外存
  I/O
* 软件(处理具体的逻辑）
 os: (文件, 进程, 信号)输出长久保存, 多任务，任务交流之逻辑
 shell: 指令组合，连接, 调用(软件）命令(交互）能交互，交互的遍历性，语法的可读性。自然语言
 soft:具体软件
compile:各语法
 定义数据
  汇编	DW 512 
  c int var=5
  python var = 65
  定义方法
  汇编　jmp there add ax, bx
  ｃ　b=a+c
* 正则(字符串们的特点）
  特殊字符有
  \
  . 匹配任何单个字符，但nul除外。
  * 匹配在他之前的任何数目的单个字符,他会取最多的匹配。
  abcd abcccd abccd abccd
  ^ 匹配紧接着的正则表达式，在行或字符串的起始处

  gbcdef^geh 
  abcdef^geh 
  $ 匹配前面的正则表达式，在字符串或行结尾处。
  [] 匹配方括号内的任一字符。
  \{n,m\} 表示它前面的单个字符重新的次数
  abbbbbbbc
  abc
  abbc
  abbbc
  \( \) 将\( \) 之间的模式存储在特殊的“保留空间”，最多可以将9个独立的子模式
  abc edf 
  abcdefgdsgab
  abab
  abdcdlasabab
  \n 
  + 匹配前面正则表达式的一个或多个实例
  ? 匹配前面的零个或一个实例
  | 匹配于 | 前或后的表达式 |
  abc def
  acc dff

  此外，可用以在匹配及排序字符串数据时，将序列里的字符视为一个独立单位。
  字符集
  character class[: :] 将关键字组合括起来的posix 字符集。
  collating symbol 
  排序符号指的是将多字符序列视为一个单位 。他使用[. 与 .] 将字符组合括起来。排序符号在系统所使用的特定locale 上各有其定义。
  等价字符集 [= =] 扩住
  如[[:alpha:]!]匹配任一英文字符或惊叹号；在法文French的国际化中，或者在中文的同义词中 [[=一样=]] 跟完全，相同都是同一个意思。
  在这里应该是不能使用的。不知道搜索引擎能不能匹配。
  对于字符集
  [:alnum:]
  [:alpha:]
  [:digit:]
  [:lower:]
  [:print:]
  [:punct:]标点符号
  [:space:]空格符
  [:upper:]控制字符
  [:cntrl:]
  [:graph:][:xdigit:]
  以及字符集，这些是方括号表达式最后出现的组成部分。接下来，我们就要说明他们的构造方式
  为了匹配需要，某些成对的字符必须视为单个字符。像这样的成对字符，当他们与语言里的单个字符比较时，都有其排序的定义方式。
  例如，在。。就是词组差不多的意思。
  排序是指给予成组的排序顺序的操作。就是匹配一个词汇了哇
  [ab[.你好.]de]
  ab 你好 de 

  最后一个特殊组成部分：字符集，他表示字符的类别，例如数字，小写与大写字母、标点符号
  排序元素、等价字符集以及字符集，都仅在方括号表达式的方括号内认可，对于[:alpha:]这样的表达式，只有一层的化，仅匹配 : a l p h
  在方括号表达式中，所有的元字符 meta 都会失去其含义。要将]加入该集合，可以将它放在列表的最前面：[]*\.]
  若你需要右方括号与减号同时在列表中，请将右方括号放在第一个字符、减号放在最后一个字符 []*\.-]

  后向引用
  指的是“匹配于正则表达式匹配的先前的部分”。使用后向引用的步骤有两个。第一步是将子表达式包围在\( 与 \) 里；单个模式里可
  包括至多9个表达式
  下一步是在同一模式之后使用\digit,digit 是介于1至9的数字，指的是“匹配于第n个先前方括号内字表达式匹配成功的字符”。

  abcdcdab\ abcdeeecdab abcdddeeffcdab
  \([[:alpha:]_][[:alnum:]_]*\) = \1; 匹配简易的c/c++ 赋值语句
  \1 就是 第一个() 中的内容
  后向引用在寻找重复字以及匹配引号时特别有用
  \(["']\).*\1 匹配以单引号或双引号括起来的字，如'foo' 或"bar"

  在这种方法下，就无需担心是单引号或是双引号先找到。
  匹配多字符最简单的方法就是把他们一个一个列出来。

  \{n,m\} 的值介于0 至RE_DUP_MAX 之间。re_dup_max是POSIX定义的符号型常数，且可以通过getconf 命令取得。
  方式为 getconf RE_DUP_MAX ,在Linux 上是一个很大的数字，32767
  再介绍两个meta字符就完成这个bre的介绍了。他们是 ^ 和 $ 符号，他们指的是anchor,因为他们针对的是字符串的头部和尾部进行匹配。
  ^$ 表示空行 
  扩展文件里头时常包含空行或空白比较多
  cc -E foo.c | grep -v '^$' > foo.out 删除空行

  在扩展正则表达式里 [ ] \ - 都是有含义的，所以要用\ 转义
  ere 里没有向后引用，在ere里，\( 与\)匹配的是字面上的括号

  aaaaaaa
  区间表达 时，要查找5个a 或几个a 时 ，用 a{5,10},不要加反斜杠
  交替运算符 | ，可以用于匹配多个,用这个挺有用的

  扩展正则表达式 \< \> 表示匹配单词
  \<abc

  abc helabc acbc abcdef abcefg 
  虽然POSIX标准化的只有ex编辑器，但在所有商用unix 系统上，ed ex  以及vi 都支持单词匹配。
  另外还有额外的gnu 正则表达式运算符

  \w [[:alnum:]_]
  \W  

  一般来说，执行了文本查找，我们可能会进一步做替换来修改文本。此时用到的工具一般是 sed stream edtior . sed 的设计就是用来
  以批处理的方式，而不是交互的方式来编辑文件。当你知道要做好几个变更。 
  我们发现，在shell脚本里，sed 主要用于一些简单的文本替换，所以我们先从他开始。

  基本用法，你可能常会在管道中间，用sed 的替换 s 用法 
  sed 's/:.*//’ /etc/passwd | sort -u 删除重复的行

  为了编辑他的输入流，将结果生成到标准输出，而非以交互式编辑器的方式来编辑文件。虽然sed 的命令很多，通常只是作为管道的一部分，
  给 下一个程序做最终处理
  行为模式
  读取每个输入文件的每一行，加入没有文件的话，则是标准输入。以每一行来说，sed会执行每一个应用到输入行的editing command. 
  结果会写到标准输出（默认状态下，或是显示地使用p 命令及-n 选项） 。 
  在这里，/ 字符扮演定界符（delimiter)的角色，从而分割正则表达式与替代文本。在本例中，替代文本是空的，实际上会有效地删除匹配的文本，
  在处理文件名称时，通常会以标点符号字符作为定界符，因为在文件名中/ 是有特殊含义的。
  find /home/xx -type d  -print | sed 's;/home/tolstoy/;/home/lt/;'|修改名称，注意：这里使用的是分号作为定界符
  sed 's/^/mkdir /' | sh -x 
  上述脚本将/home/tolstoy 目录结构建立一份副本在/home/lt 下 这个脚本 使用了产生命令的手法，这是一个功能很强且很常见的技巧

  替换细节
  前面提到，定界符不光是/ 还可以是任何标点；对于这些特殊字符的替换，需要用到转义符。
  不过这么做让人很难看懂。看下面这个替换
  sed 's/\/home\/tolstoy\//\/home\/lt\//' 
  sed 's|/home/tolstoy/|/home/lt|' 这个就看的清楚了
  sed 's&/home/tolstoy/&/home/lt&' 这样就更清楚

  sed 也知道向后引用，他也认得正则表达式。他知道从这替换匹配的文本
  举个例子
  echo /home/tolstoy/ | sed 's;\(/home\)/tolstoy/;\1/lt/;'
  sed 将\1 替换为匹配与正则表达式的/home 部分。在这里，任何表达式都可以在括号，向后引用最多9个，不能多哦

  向后引用
  sed 's/\(ab\)/\1nimei\1/'
  有些其他字符在替代文本里也有特殊含义。 我们已经提过需要使用反斜杠转义定界符的情况
  还有 & 在替代文本的含义是，就像是代表这个匹配的不懂，并可以在后面追加字符
  sed 's/hello/& world/' 'hello !'
  在s 命令里以 g 结尾表示global，表示替代每个匹配。默认只会匹配第一个
  如果结尾跟数字，则表示为第 数字 次出现才匹配

  到目前，我们都是讲的一次替换一个，但一次替换多个也能实现。 就是使用-e 选项。 每个编辑命令使用一个 -e 
  sed -e 's/foo/bar/g' -e 's/chicken/cow/g' file.xml > myfile.xml

  不过，如果你有很多项目要编辑，这种形式很恐怖，将编辑命令全部放在脚本里，再搭配 -f 使用，会更好 
  cat fixup.sed
  s/foo/bar/g
  s/chicken/cow/g
  s/animal/horse/g

  以后只要修改文件就好了，这是对于修复bug来挺有用的。另外，POSIX标准也允许使用分号将不同的命令隔开
  sed 's/foo/bar/g; s/chicken/cow/g' myfile.xml > myfile2.xml

  sed 的工作方式是对于行来说的，每次读取一行，进行操作。

  sed -n '/hello/p' xx.file  这个有点像grep 的查找功能，显示匹配的一行 ，不做替换
  匹配特定的行，而不是每一行都作处理，现在我们就来学习sed 的这一功能。
  行编号，上面的有点笼统 ，最后一行 用 $l $p 表示
  有了行编号，就可以具体到哪一行了
  还可以取一个范围，也是由行编号来的，用逗号隔开。
  s 是替换命令 p 是打印命令
  sed '/foo/,/bar/ s/baz/quux/g' 仅替换范围内的行。这个范围并不是以行号来限定的，而是根据正文内容。挺有用的。
  像ed ex 或 vi 内的冒号命令，都认识此语法。当然，在emacs的evil模式下也是认得的。
  否定正则表达式
  有时，将命令应用于不匹配于特定模式的每一行，也很有用。在下面的例子来说明

  假如这一行没有这么一个东西，就把xx 改成yy
  /used/!s/new/used/g   将没有used 的每一行的new 改成used
  sed 还可以作为head 使用
  语法是 sed 3q file  打印头三行

  写的灵活点就是
  count=$1
  sed ${count}q $2
  q 要求sed马上离开，不再读取其他输入，或执行任何命令。
  了解行与字符串的差异是相当重要的。大部分简易程序都是处理输入数据的行，在这些情况下，不会有内嵌的换行字符出现在将要匹配的数据中。
  但字符串就不同了，他可能包括换行符，可能还有空字符。这种情况下，^ 与 $ 就无法匹配内嵌的换行字符。他们只是用来匹配字符串的开头
  和结尾。也就是在这种程序语言中，工具的含义发生了微妙变化。
  字段处理，一行表示一个记录。对于一行内分割字段的惯例，是用空格或制表符 空白
  或用特定的定界符

  使用cut 选定字段
  用法如下 
  cut -d : -f 1,5 /etc/passwd 取出第一段 和第五段内容
  cut -c list [file...] 以字符为主，执行剪下的操作。list为字符编号或一段范围的列表，以逗号隔开 如 1,2,5-10,34 剪下字符
  cut -f list [-d delim] [file...] field 剪下字段

  join 连接
  join [options ...] file1 file2
  以共同的一个键值，将已存储文件内的记录加以结合
  -1 field1
  -2 field2 标明要结合的字段，-1 field1指从file1中取出field1,-2 field2 是指从file2 中取出field2，字段编号自1开始，而非0
  -o file.field 输出file中的field 字段。
  -t separator 
  使用separator 作为输入字段分割字符，而非使用空白。

  这个有点难 
  现在讲到重点了，awk工具
  本节，我们介绍awk 的基本概念，随后，你看到这样的 单命令行程序 （one-liners) 就会比较了解了。
  模式与操作
  awk ‘program ' [file...]
  awk 读取命令行上所指定的各个文件，一次读取一行，在针对每一行，应用命令。awk 基本架构为
  pattern {action}
  pattern 可以是任何表达式，但在单命令行程序里，他通常是由斜括号扩起来的 ege。action 为awk语句 
  对于每条记录
  · [^abc...] 这个否定的字符序列匹配所有的字符除了 "abc...".
  · r* 这个匹配以"r" 开始的后面有 0 个或者多个字符的字符串。
  · r+ 这个匹配以"r" 开始的后面有一个或者多个字符的表达式。
  · r? 以"r" 开始后面有 0 个或者 1 个其他的字符。
  · r1|r2 匹配"r1"或者"r2"。
  · (r1|r2) 匹配"r1"或者 "r2"并且把它当作一个分类 正则表达式。

* 编译器技术
* 计算机网络(输入输出）
  电话交换（单任务）
  分组交换（多任务）
  tcp/ip分层
  打开端口？这里是虚拟端口
  客户端/服务器
  万维网：浏览器/服务器  浏览器充当排字机的功能。把浏览器比作一台简单的解释器，网页是一段简单的程序。
  (一个请求url字符串, 返回很多的数据）
  web 浏览器请求一个页面时,Web服务器会在发送实际页面内容前,先发送一些头信息(header)
  浏览器需要这些头信息解析随后的页面内容..(交流嘛)
  Content-Type:text/html (内容类型或MIME类型)
  MIME类型(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型,是描述消息内容类型的因特网标准。
  | jpeg       | image/jpeg               |
  | png        | image/png                |
  | javascript | application/x-javascript |
  | css        | text/css                 |
  | xhtml      | application/xhtml+xml(严格形式,但一般用宽松形式) |

  当浏览器渲染Web页面的时候,它会构造一个文档对象模型(DOM),用一个对象的集合表示
  页面上的HTML元素.除此还有window和document这些不和特定页面元素绑定的全局对象.
  对象有共有属性
  还有私有属性
  javascript:加入了语言的支持，更动态。可变。
  FTP:客户端/服务器
  ssh:客户端/服务器
  进程间通信
  请求富文本Http -> URL
  搜索引擎
  email ->基于www的电子邮件
  SMTP 局限于ascii,不能中文
  MIME 作了扩展，可以传输二进制
  防火墙：特殊编程的路由器
  音视频：RTSP
** 配置联网
   （1）IP地址
   （2）子网掩码
   （3）默认路由IP
   （4）域名服务IP
   或者用DHCP
* tcp/ip协议簇 
/考虑到不同的操作系统的差异，设备的差异/设计的消除彼此差异的成果
** 硬件层差异的消除 -》硬件层[硬件地址属性]
** 系统层差异的消除 -》应用层 (进程的概念加了端口号）
** 中间层没差异了 -》中间的通用功能 传输层(数据的转换）/网络层(IP地址的操作,转发)
   unix 的端口号设置文件 [[/etc/services][services]],因为有Tcp/Udp 两种类型，所以，每个服务有这两种分类
   ip(数字标定） 个体 与 大家，网段，主机 子网 (可以确认是不是内部）不是，就发送到网关(gateway)
   网关就是路由器
   tcpdump
* 资源
  LDP: Linux Documentation Project (http://www.tldp.org/)
  DDP: Debian Documentation Project (http://www.debian.org/doc/)
* linux 内核函数
  #include <unistd.h>
  早上听人说到某个程序的一部分是内核态，另一部分是用户态，需要怎么怎么。当时突然想知道，用户的程序可以直接调用内核函数吗？
  （现在突然发觉这问题有点可笑，若是可以随便调，那系统岂不是乱套了）从网上找到下面这篇文章，讲的还算透彻。
  现在自己的理解是，用户程序不可用直接调用内核函数，除非通过系统调用接口。如果想调用哪个内核函数（或自己写的内核函数），怎么办？增加一个系统调用就行了。
  原文如下：
  Linux系统调用
  顾名思意，系统调用说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，
  比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置系统时间等。
  从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。

  系统服务之所以需要通过系统调用提供给用户空间的根本原因是为了对系统“保护”，因为我们知道Linux的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用户用空间函数。比如我们熟悉的“hello world”程序（执行时）就是标准的户空间进程，它使用的打印函数printf就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。

  但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊”接口——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实的坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。

 

  Linux的系统调用

  对于现代操作系统，系统调用是一种内核与用户空间通讯的普遍手段，Linux系统也不例外。但是Linux系统的系统调用相比很多Unix和windows等系统具有一些独特之处，无处不体现出Linux的设计精髓——简洁和高效。

  Linux系统调用很多地方继承了Unix的系统调用（但不是全部），但Linux相比传统Unix的系统调用做了很多扬弃，它省去了许多Unix系统冗余的系统调用，仅仅保留了最基本和最有用的系统调用，所以Linux全部系统调用只有250个左右（而有些操作系统系统调用多达1000个以上）。 

  这些系统调用按照功能逻辑大致可分为“进程控制”、“文件系统控制”、“系统控制”、“存管管理”、“网络管理”、“socket控制”、“用户管理”、“进程间通信”几类，详细情况可参阅文章系统调用列表

  如果你想详细看看系统调用的说明，可以使用man 2 syscalls 命令查看，或干脆到 <内核源码目录>/include/asm-i386/unistd.h源文件种找到它们的原本。

  熟练了解和掌握上面这些系统调用是对系统程序员的必备要求，但对于一个开发内核者或内核开发者来[1]说死记硬背下这些调用还远远不够。如果你仅仅知道存在的调用而不知道为什么它们会存在，或只知道如何使用调用而不知道这些调用在系统中的主要用途，那么你离驾驭系统还有不小距离。

  要弥补这个鸿沟，第一，你必须明白系统调用在内核里的主要用途。虽然上面给出了数种分类，不过总的概括来讲系统调用主要在系统中的用途无非以下几类：

  l 控制硬件——系统调用往往作为硬件资源和用户空间的抽象接口，比如读写文件时用到的write/read调用。

  l 设置系统状态或读取内核数据——因为系统调用是用户空间和内核的唯一通讯手段[2]，所以用户设置系统状态，比如开/关某项内核服务（设置某个内核变量），或读取内核数据都必须通过系统调用。比如getpgid、getpriority、setpriority、sethostname

  l 进程管理——一系列调用接口是用来保证系统中进程能以多任务，在虚拟内存环境下得以运行。比如 fork、clone、execve、exit等

  第二，什么服务应该存在于内核；或者说什么功能应该实现在内核而不是在用户空间。这个问题并不没有明确的答案，有些服务你可以选择在内核完成，也可以在用户空间完成。选择在内核完成通常基于以下考虑：

  l 服务必须获得内核数据，比如一些服务必须获得中断或系统时间等内核数据。

  l 从安全角度考虑，在内核中提供的服务相比用户空间提供的毫无疑问更安全，很难被非法访问到。

  l 从效率考虑，在内核实现服务避免了和用户空间来回传递数据以及保护现场等步骤，因此效率往往要比实现在用户空间高许多。比如,httpd等服务。

  l 如果内核和用户空间都需要使用该服务，那么最好实现在内核空间，比如随机数产生。

  理解上述道理对掌握系统调用本质意义很大，希望网友们能从使用中多总结，多思考。

  

  系统调用、用户编程接口（API）、系统命令、和内核函数的关系

  系统调用并非直接和程序员或系统管理员打交道，它仅仅是一个通过软中断机制（我们后面讲述）向内核提交请求，获取内核服务的接口。而在实际使用中程序员调用的多是用户编程接口——API，而管理员使用的则多是系统命令。

  用户编程接口其实是一个函数定义，说明了如何获得一个给定的服务，比如read()、malloc()、free（）、abs()等。它有可能和系统调用形式上一致，比如read()接口就和read系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如malloc()、free（）内部利用brk( )系统调用来扩大或缩小进程的堆；或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用——因为它不必需要内核服务，如计算整数绝对值的abs（）接口。

  另外要补充的是Linux的用户编程接口遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。在Linux中（Unix也如此）这些API主要是通过C库（libc）实现的，它除了定义的一些标准的C函数外，一个很重要的任务就是提供了一套封装例程（wrapper routine）将系统调用在用户空间包装后供用户编程使用。

  不过封装并非必须的，如果你愿意直接调用，Linux内核也提供了一个syscall()函数来实现调用，我们看个例子来对比一下通过C库调用和直接调用的区别。


  #include <syscall.h>

  #include <unistd.h>

  #include <stdio.h>

  #include <sys/types.h>

  int main(void) {

  long ID1, ID2;

  /*-----------------------------*/

  /* 直接系统调用*/

  /* SYS_getpid (func no. is 20) */

  /*-----------------------------*/

  ID1 = syscall(SYS_getpid);

  printf ("syscall(SYS_getpid)=%ld/n", ID1);

  /*-----------------------------*/

  /* 使用"libc"封装的系统调用 */

  /* SYS_getpid (Func No. is 20) */

  /*-----------------------------*/

  ID2 = getpid();

  printf ("getpid()=%ld/n", ID2);

  return(0);

  }


  系统命令相对编程接口更高了一层，它是内部引用API的可执行程序，比如我们常用的系统命令ls、hostname等。Linux的系统命令格式遵循系统V的传统，多数放在/bin和/sbin下（相关内容可看看shell等章节）。

  有兴趣的话可以通过strace ls或strace hostname 命令查看一下它们用到的系统调用，你会发现诸如open、brk、fstat、ioctl 等系统调用被用在系统命令中。

  下一个需要解释一下的问题是内核函数和系统调用的关系，内核函数大家不要想像的过于复杂，其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求[3]。系统调用是一层用户进入内核的接口，它本身并非内核函数，进入内核后，不同的系统调用会找到对应到各自的内核函数——换个专业说法就叫：系统调用服务服务例程。实际对请求服务的是内核函数而非调用接口。

  比如系统调用 getpid实际就是调用内核函数sys_getpid。

  asmlinkage long sys_getpid(void)

  {

  return current->tpid;

  }

  Linux系统种存在许多的内核函数，有些是内核文件种自己使用的，有些则是可以export出来供内核其他部分共同使用的，具体情况自己决定。

  内核公开的内核函数——export出来的——可以使用命令ksyms 或 cat /proc/ksyms来查看。另外网上还有一本归纳分类内核函数的书叫作《The Linux Kernel API Book》，有兴趣的读者可以去看看。

  总而言之，从用户角度向内核看，依次是系统命令、编程接口、系统调用和内核函数。再讲述了系统调用实现后，我们会回过头来看看整个执行路径。

  系统调用实现

  Linux中实现系统调用利用了0x86体系结构中的软件中断[4]。软件中断和我们常说的中断(硬件中断)不同之处在于——它是通过软件指令触发而并非外设，也就是说又编程人员出发的一种异常，具体的讲就是调用int $0x80汇编指令，这条汇编指令将产生向量为128的编程异常。

  之所以系统调用需要借助异常实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数[5]，而我们在i386体系结构部分已经讲述过了进入内核——进入高特权级别——必须经过系统的门机制，这里异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3——向量3、into——向量4 、bound——向量5等异常指令进入内核，而其他异常用户空间程序无法利用，都是由系统使用的）。

  我们更详细的解释一下这个过程。int $0x80指令目的是产生一个编号为128的编程异常，这个编程异常对应的中断描述符表IDT中的第128项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（别和系统调用服务程序混淆,这个程序在entry.S文件中用汇编语言编写）。

  很显然所有的系统调用都会统一的转到这个地址，但Linux一共有2、3百个系统调用都从这里进入内核后又该如何派发它们到各自的服务程序去呢？别发昏，解决这个问题的方法非常简单：首先Linux为每个系统调用都进行了编号（0—NR_syscall），同时在内核中保存了一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调入通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80前把调用号装入eax寄存器实现的。这样系统调用处理程序一旦运行，就可以从eax中得到数据，然后再去系统调用表中寻找相应服务例程了。

  除了需要传递系统调用号以外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char * buf, size_t count)调用就需要传递文件描述符号fd和要写入的内容buf和写入字节数count等几个内容到内核。碰到这种情况，Linux会有6个寄存器使用来传递这些参数：eax (存放系统调用号)、 ebx、ecx、edx、esi及edi来存放这些额外的参数（以字母递增的顺序）。具体做法是在system_call( )中使用SAVE_ALL宏把这些寄存器的值保存在内核态堆栈中。



  有始便有终，当服务例程结束时，system_call( ) 从eax获得系统调用的返回值，并把这个返回值存放在曾保存用户态 eax寄存器栈单元的那个位置上。然后跳转到ret_from_sys_call( )，终止系统调用处理程序的执行。

  当进程恢复它在用户态的执行前，RESTORE_ALL宏会恢复用户进入内核前被保留到堆栈中的寄存器值。其中eax返回时会带回系统调用的返回码。（负数说明调用错误，0或正数说明正常完成）


  我们可以通过分析一下getpid系统调用的真是过程来将上述概念具体化，分析getpid系统调用一个办法是查看entry.s中的代码细节，逐步跟踪源码来分析运行过程，另外就是可借助一些内核调试工具，动态跟踪运行路径。

  假设我们的程序源文件名为getpid.c，内容是：

  #include <syscall.h>

  #include <unistd.h>

  #include <stdio.h>

  #include <sys/types.h>

  int main(void) {

  long ID;

  ID = getpid();

  printf ("getpid()=%ld/n", ID);

  return(0);

  }

  将其编译成名为getpid的执行文件”gcc –o getpid <路径>/getpid.c”, 我们使用KDB来产看它进入内核后的执行路径。

  l 激活KDB (按下pause键，当然你必须已经给内核打了KDB补丁);设置内核断点 “bp sys_getpid” ;退出kdb “go”;然后执行./getpid 。瞬间，进入内核调试状态,执行路径停止在断点sys_getpid处。

  l 在KDB>提示符下，执行bt命令观察堆栈，发现调用的嵌套路径，可以看到在sys_getpid是在内核函数system_call中被嵌套调用的。

  l 在KDB>提示符下，执行rd命令查看寄存器中的数值，可以看到eax中存放的getpid调用号——0x00000014(=20).

  l 在KDB>提示符下，执行ssb（或ss）命令跟踪内核代码执行路径,可以发现sys_getpid执行后，会返回system_call函数，然后接者转入ret_from_sys_call例程。（再往后还有些和调度有关其他例程，我们这里不说了它们了。）


  结合用户空间的执行路径，大致该程序可归结为一下几个步骤：

  1  该程序调用libc库的封装函数getpid。该封装函数中将系统调用号_NR_getpid（第20个）压入EAX寄存器，

  2  调用软中断 int 0x80 进入内核。

  （以下进入内核态）

  3  在内核中首先执行system_call，接着执行根据系统调用号在调用表中查找到对应的系统调用服务例程sys_getpid。

  4．执行sys_getpid服务例程。

  5．执行完毕后，转入ret_from_sys_call例程，系统调用中返回。


  内核调试是一个很有趣的话题，方法多种多样，我个人认为比较好用的是UML（user mode linux+gdb）和 KDB 这两个工具。尤其KDB对于调试小规模内核模块或查看内核运行路径很有效，对于它的使用方法可以看看Linux 内核调试器内幕这片文章。

  系统调用思考

  系统调用的内在过程并不复杂，我们不再多说了，下面这节我们主要就系统调用所涉及的一些重要问题作一些讨论和分析，希望这样能更有助了解系统调用的精髓。

  调用上下文分析

  系统调用虽说是要进入内核执行，但它并非一个纯粹意义上的内核例程。首先它是代表用户进程的，这点决定了虽然它会陷入内核执行，但是上下文仍然是处于进程上下文中，因此可以访问进程的许多信息（比如current结构——当前进程的控制结构），而且可以被其他进程抢占（在从系统调用返回时，由system_call函数判断是否该再调度），可以休眠，还可接收信号[6]等等。

  所有这些特点都涉及到了进程调度的问题，我们这里不做深究，只要大家明白系统调用完成后，再回到或者说把控制权交回到发起调用的用户进程前，内核会有一次调度。如果发现有优先级别更高的进程或当前进程的时间片用完，那么就会选择高优先级的进程或重新选择进程运行。除了再调度需要考虑外，再就是内核需要检查是否有挂起的信号，如果发现当前进程有挂起的信号，那么还需要先返回用户空间处理信号处理例程（处于用户空间），然后再回到内核，重新返回用户空间，有些麻烦但这个反复过程是必须的。


  调用性能问题

  系统调用需要从用户空间陷入内核空间，处理完后，又需要返回用户空间。其中除了系统调用服务例程的实际耗时外，陷入/返回过程和系统调用处理程序（查系统调用表、存储/恢复用户现场）也需要花销一些时间，这些时间加起来就是一个系统调用的响应速度。系统调用不比别的用户程序，它对性能要求很苛刻，因为它需要陷入内核执行，所以和其他内核程序一样要求代码简洁、执行迅速。幸好Linux具有令人难以置信的上下文切换速度，使得其进出内核都被优化得简洁高效；同时所有Linux系统调用处理程序和每个系统调用本身也都非常简洁。

  绝大多数情况下，Linux系统调用性能是可以接受的，但是对于一些对性能要求非常高的应用来说，它们虽然希望利用系统调用的服务，但却希望加快相应速度，避免陷入/返回和系统调用处理程序带来的花销，因此采用由内核直接调用系统调用服务例程，最好的例子就HTTPD——它为了避免上述开销，从内核调用socket等系统调用服务例程。


  什么时候添加系统调用

  系统调用是用户空间和内核空间交互的唯一手段，但是这并非时说要完成交互功能非要添加新系统调用不可。添加系统调用需要修改内核源代码、重新编译内核，因此如果想灵活的和内核交互信息，最好使用一下几种方法。

  l 编写字符驱动程序

  利用字符驱动程序可以完成和内核交互数据的功能。它最大的好处在于可以模块式加载，这样以来就避免了编译内核等手续，而且调用接口固定，容易操作。

  l 使用proc 文件系统

  利用proc文件系统修订系统状态是一种很常见的手段，比如通过修改proc文件系统下的系统参数配置文件（/proc/sys），我们可以直接在运行时动态更改内核参数；再如，通过下面这条指令：echo 1 > /proc/sys/net/ip_v4/ip_forward开启内核中控制IP转发的开关。类似的，还有许多内核选项可以直接通过proc文件系统进行查询和调整。

  l 使用虚拟文件系统

  有些内核开发者认为利用ioctl（）系统调用（字符设备驱动接口）往往会似的系统调用意义不明确，而且难控制。而将信息放入到proc文件系统中会使信息组织混乱，因此也不赞成过多使用。他们建议实现一种孤立的虚拟文件系统来代替ioctl()和/proc，因为文件系统接口清楚，而且便于用户空间访问，同时利用虚拟文件系统使得利用脚本执行系统管理任务更家方便、有效。



  实验部分


  代码功能介绍

  我们希望收集Linux系统运行时系统调用被执行的信息，既实时获取系统调用日志。这些日志信息将能以可读形式实时的返回给用户空间，以便用户观察或做近一步的日志分析（如入侵检测等）。

  所以简单的讲实验代码集需要完成以下几个基本功能：

  第一：记录系统调用日志，将其写入缓冲区（内核中），以便用户读取；

  第二：建立新的系统调用，以便将内核缓冲中的系统调用日志返回到用户空间。

  第三：循环利用系统调用，以便能动态实时返回系统调用日志。


  代码结构体系介绍

  基本函数

  代码功能一节介绍中的基本功能对应程序代码集中的三个子程序。它们分别是syscall_auydit、Sys_audit和auditd。接下来我们介绍代码具体结构。

  日志记录例程Syscall_audit

  syscall_audit该程序是一个内核态的服务例程，该例程负责记录系统调用的运行日志。

  记录系统调用日志的具体做法是在内核中修改系统调用处理程序system_call[7]，在其中需要监控的每个调用（在我们例子钟222个系统调用都监控了，当然你也可以根据自己需求有选择的监控）执行完毕后都插入一个日志记录指令，该指令会转去调用内核服务函数syscall_audit来记录该次调用的信息[8]。

  Syscall_audit内核服务例程会建立了一个内核缓冲区来存放被记录的函数。当搜集的数据量到达一定阀值时（比如设定为到达缓冲区总大小的%80，这样作可避免在丢失新调用），唤醒系统调用进程取回数据。否则继续搜集，这时系统调用程序会堵塞在一个等待队列上，直到被唤醒，也就是说如果缓冲区还没接近满时，系统调用会等待（被挂起）它被填充。

  系统调用Sys_audit

  由于系统调用是在内核中被执行，因此记录其执行日志也应该在内核态收集，所以我们需要利用一个新的系统调用来完成将内核信息带回到用户空间——sys_audit就是我们新填加的系统调用，它功能非常简单，就是从缓冲区中取数据返回用户空间。

  为了保证数据连续性，防止丢失。我们会建立一个内核缓冲区存放每刻搜集到的日志数据，并且当搜集的数据量到达一定阀值时（比如设定为到达缓冲区总大小的%80），系统调用进程就会被唤醒[9]，以取回数据。否则在日志搜集时，系统调用程序会堵塞在等待队列上，直到被唤醒，也就是说如果缓冲区还没接近满时，系统调用会等待它被填充。

  用户空间服务程序auditd

  不用多说，我们需要一个用户空间服务进程来不断的调用audit系统调用，取回系统中搜集到的的调用日志信息。要知道，长时间的调用日志序列对于分析入侵或系统行为等才有价值。


  把代码集成到内核中

  除了上面介绍的内容外，我们还需要一些辅助性，但却很必要的工作，这些工作将帮助我们将上述代码灵活地机结成一体，完成需要的功能。

  n 其一是修改entry.S汇编代码，该代码中含有系统调用表和系统调用入口代码system_call。我们首先需要在系统调用表中加入新的系统调用（名为sys_audit,223号。.long SYMBOL_NAME(sys_audit)）；下来在系统调用入口中加入跳转到日志记录服务例程中（跳转 “je auditsys”， 而auditsys代码段会真正调用系统调用记录例程syscall_audit）；

  n 其二是填加代码文件audit.c，该文件中包含syscall_audit与系统调用sys_audit两个函数体，我们这里只说包含函数体，而并非函数，是因为这里我们并不想把函数的实现在内核中写死，而是希望利用了函数指针，即做了两个钩子函数，来完成把具体函数实现放在模块中完成，以便能动态加载，方便调试（请见下一节介绍）。

  u 其三是修改i386_ksyms.c文件，再最后加入

  extern void (*my_audit)(int,int);

  EXPORT_SYMBOL(my_audit);

  extern int(*my_sysaudit)(unsigned char,unsigned char*,unsigned short,unsigned char);

  EXPORT_SYMBOL(my_sysaudit);

  ，这样做是为了导出内核符号表，以便能模块代码中能挂接上以上函数指针。

  n 其四是修改内核原代码目录下/kernel自目录下的Makefile文件，很简单，只需要在obj-y	:= 。。。。。最后加上audit.o，告诉编译内核是把audit.o编进去。


  关键代码解释

  我们的日志收集例程与取日志系统调用这两个关键函数的实现是放在内核模块中实现。其中有些需要解释的地方：

  1. 模块编程的必要原则，如初始化、注销等都应该实现，所不同的是我们在初始化与注销时会分别挂上或卸下[10]了两个钩子函数的实现。

  2. 我们系统调用日志记录采用了一个结构体：syscall_buf，它含有诸如系统调用号——syscall、进程ID——pid、调用程序名——comm[COMM_SIZE]等字段，共52字节；我们的内核缓冲区为audit_buf，它是一个可容纳100个syscall_buf的数组。

  3. 系统调用实现极简单，要做的仅仅是利用__copy_to_user[11]将内核缓冲中的日志数据取到用户空间。为了提高效率，在缓冲区未满时（未到%80的阀值时），系统调用会挂起等待wait_event_interruptible(buffer_wait, current_pos >= AUDIT_BUF_SIZE*8/10)；相应地当缓冲区收集快满时，则唤醒系统调用继续收集日志wake_up_interruptible(&buffer_wait)。

  4. 最后要补充说明一下，在auditd用户服务程序中调用我们新加的系统调用前必须利用宏_syscall4(int, audit, u8, type, u8 *, buf, u16, len, u8, reset)来“声明”该调用——展开成audit函数原形，以便进行格式转换和参数传递，否则系统不能识别。





  STEP BY STEP 

  下面具体讲述一下如何添加这个调用。

  1 修改entry.S ——在其中的添加audit调用，并且在system_call中加入搜集例程。（该函数位于<内核源代码>/arch/i386/kernel/下）

  2 添加audit.c文件到<内核源代码>/arch/i386/kernel/下——该文件中定义了

  sys_audit和syscall_audit 两个函数需要的钩子函数（my_audit和my_sysaudit），它们会在entry.S中被使用。

  3 修改<内核源代码>/arch/i386/kernel/i386-kysms.c文件，在其中导出my_audit与my_sysaudit两个钩子函数。因为只有在内核符号表里导出，才可被其他内核函数使用，也就是说才能在模块中被挂上。

  4 修改<内核源代码>/arch/i386/kernel/Makefile文件，将audit.c编译入内核。

  到这可以重新编译内核了，新内核已经加入了检测点了。下一步是编写模块来实现系统调用与内核搜集服务例程的功能了。

  1 编写名为audit的模块，其中除了加载、卸载模块函数以外主要实现了mod_sys_audit与mod_syscall_audit两个函数。它们会分别挂载到my_sysaudit和my_audit两个钩子上。

  2 编译后将模块加载 insmod audit.o。（你可通过dmesg查看是加载信息）

  3 修改/usr/include/asm/unistd.h ——在其中加入audit的系统调用号。这样用户空间才可找到audit系统调用了。

  4 最后，我们写一个用户deamon程序，来循环调用audit系统调用，并把搜集到的信息打印到屏幕上。


  [1]我们说的开发内核者指开发系统内核，比如开发驱动模块机制、开发系统调用机制；而内核开发者则是指在内核基础之上进行的开发，比如驱动开发、系统调用开发、文件系统开发、网络通讯协议开发等。我们杂志所关注的问题主要在内核开发层次，即利用内核提供的机制进行开发。


  [2]对Linux而言，系统调用是用户程序访问内核的唯一手段，无论是/proc方式或设备文件方式归根到底都是利用系统调用完成的。

  [3]内核编程相比用户程序编程有一些特点，简单的讲内核程序一般不能引用C库函数（除非你自己实现了，比如内核实现了不少C库种的String操作函数）；缺少内存保护措施；堆栈有限（因此调用嵌套不能过多）；而且由于调度关系，必须考虑内核执行路径的连续性，不能有长睡眠等行为。

  [4]软件中断虽然叫中断，但实际上属于异常（更准确说是陷阱）——CPU发出的中断——而且是由编程者触发的一种特殊异常。

  [5]系统调用过程可被理解成——由内核在核心态代表应用程序执行任务。

  [6]除了进程上下文外，Linux系统中还有另一种上下文——它被成为中断上下文。中断上下文不同于进程上下文，它代表中断执行，所以和进程是异步进行而且可以说毫不相干的。这种上下文中的程序，要避免睡眠因为无法被抢占。

  [7]System_call是个通用的系统调用服务程序，或说系统调用入口程序，因为任何一个系统调用都要经过system_call统一处理（查找系统调用表，跳转到相应调用的服务例程），所以任何一次系统调用的信息都可被syscall_audit记录下来。


  [8] 这里我们主要记录诸如调用时刻、调用者PID、程序名等信息，这些信息可从xtime或current这些全局变量处取得。

  [9] 这里需要利用等待队列，具体声明见DECLARE_WAIT_QUEUE_HEAD(buffer_wait)。


  [10] 所谓挂上或卸下其实就是将函数指针指向模块中实现的函数或指向空函数，但要知道这些函数指针一定是要导出到内核符号表中的，否则找不到。

  [11] 这是一个系统提供的内核函数，目的就是从内核向用户空间传递数据。

 

  顶
  1
  踩
  0
 
 
  上一篇mmap函数
  下一篇select函数
  相关文章推荐
  • 关于Linux系统调用，内核函数
  • Linux系统内核模块函数调用及命名空间
  • 几个重要的Linux系统内核文件介绍
  • linux系统调用，内核函数的关系
  • Linux系统调用-Printf从函数库到OS跟踪流程
  • 增加Linux系统调用——通过Hack增加内核模块
  • Linux系统调用及其实验（二）——内核态、用户态【转】
  • Linux系统调用的“三层皮”：API，中断服务程序，内核服务程序
  • linux系统2.6内核编译全过程
  • linux系统下的ioctl函数
  猜你在找
  深度学习基础与TensorFlow实践 【在线峰会】前端开发重点难点技术剖析与创新实践 【在线峰会】一天掌握物联网全栈开发之道 【在线峰会】如何高质高效的进行Android技术开发 机器学习40天精英计划 Python数据挖掘与分析速成班 微信小程序开发实战 JFinal极速开发企业实战 备战2017软考 系统集成项目管理工程师 学习套餐 Python大型网络爬虫项目开发实战（全套）
  查看评论

