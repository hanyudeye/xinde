* ex
#+begin_src sql
/* 启动 MySQL */
net start mysql

/* 连接与断开服务器 */
mysql -h 地址 -P 端口 -u 用户名 -p 密码

/* 跳过权限验证登录 MySQL */
mysqld --skip-grant-tables
-- 修改 root 密码
密码加密函数 password()
update mysql.user set password=password('root');

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 

/* 数据库操作 */ ------------------
-- 查看当前数据库
    select database();
-- 显示当前时间、用户名、数据库版本
    select now(), user(), version();
-- 创建库
    create database[ if not exists] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    show databases[ like 'pattern']
-- 查看当前库信息
    show create database 数据库名
-- 修改库的选项信息
    alter database 库名 选项信息
-- 删除库
    drop database[ if exists] 数据库名
        同时删除该数据库相关的目录及其目录内容

/* 表的操作 */ ------------------
-- 创建表
    create [temporary] table[ if not exists] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        temporary 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name    
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM 表文件含义：.frm 表定义，.MYD 表数据，.MYI 表索引
        InnoDB 表文件含义：.frm 表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 数据文件目录
        DATA DIRECTORY = '目录'
    -- 索引文件目录
        INDEX DIRECTORY = '目录'
    -- 表注释
        COMMENT = 'string'
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE 'pattern']
    SHOW TABLES FROM 表名
-- 查看表机构
    SHOW CREATE TABLE 表名    （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']
    SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        EG:    ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名    （可将表移动到另一个数据库）
        -- RENAME 可以交换两个表名
    -- 修改表的字段机构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段名        -- 增加字段
                AFTER 字段名            -- 表示增加在该字段名后面
                FIRST                -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)    -- 创建主键
            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
            ADD INDEX [索引名] (字段名)    -- 创建普通索引
            ADD 
            DROP[ COLUMN] 字段名        -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性        -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性        -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其 AUTO_INCREMENT 属性)
            DROP INDEX 索引名    -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键

-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...



/* 数据操作 */ ------------------
-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]

/* 字符集编码 */ ------------------
-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE 'character_set_%'    -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results        服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    set character_set_client = gbk;
    set character_set_results = gbk;
    set character_set_connection = gbk;
SET NAMES GBK;    -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']    查看所有字符集
    SHOW COLLATION [LIKE 'pattern']        查看所有校对集
    charset 字符集编码        设置字符集编码
    collate 校对集编码        设置校对集编码

/* 数据类型（列类型） */ ------------------
1. 数值类型
-- a. 整型 ----------
    类型            字节        范围（有符号位）
    tinyint        1 字节    -128 ~ 127        无符号位：0 ~ 255
    smallint    2 字节    -32768 ~ 32767
    mediumint    3 字节    -8388608 ~ 8388607
    int            4 字节
    bigint        8 字节

    int(M)    M 表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以 0 补填，zerofill 属性修改
        例：int(5)    插入一个数'123'，补填后为'00123'
    - 在满足要求的情况下，越小越好。
    - 1 表示 bool 值真，0表示 bool 值假。MySQL 没有布尔类型，通过整型 0 和 1 表示。常用 tinyint(1)表示布尔型。

-- b. 浮点型 ----------
    类型                字节        范围
    float(单精度)        4 字节
    double(双精度)    8 字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填 0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)        double(M, D)
        M 表示总位数，D表示小数位数。
        M 和 D 的大小会决定浮点数的范围。不同于整型的固定范围。
        M 既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c. 定点数 ----------
    decimal    -- 可变长度
    decimal(M, D)    M 也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每 9 位数字保存为 4 个字节。

2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    M 表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多 255 个字符，与编码无关。
    varchar,最多 65535 字符，与编码有关。
    一条有效记录最大不能超过 65535 个字节。
        utf8 最大为 21844 个字符，gbk 最大为 32766 个字符，latin1 最大为 65532 个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于 255 个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是 65532 字节，因为在 varchar 存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是 64432-1-2=65532 字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问 N 的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给 default 值

-- c. binary, varbinary ----------
    类似于 char 和 varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
    一般用整型保存时间戳，因为 PHP 可以很方便的将时间戳进行格式化。
    datetime    8 字节    日期及时间        1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3 字节    日期            1000-01-01 到 9999-12-31
    timestamp    4 字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3 字节    时间            -838:59:59 到 838:59:59
    year        1 字节    年份            1901 - 2155
    
datetime    “YYYY-MM-DD hh:mm:ss”
timestamp    “YY-MM-DD hh:mm:ss”
            “YYYYMMDDhhmmss”
            “YYMMDDhhmmss”
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        “YYYY-MM-DD”
            “YY-MM-DD”
            “YYYYMMDD”
            “YYMMDD”
            YYYYMMDD
            YYMMDD
time        “hh:mm:ss”
            “hhmmss”
            hhmmss
year        “YYYY”
            “YY”
            YYYY
            YY

4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为 65535.
    枚举值在保存时，以 2 个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从 1 开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL 值的索引是 NULL。
    空字符串错误值的索引值是 0。

-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set('男', '女', '无') );
    insert into tab values ('男, 女');
    最多可以有 64 个不同的成员。以 bigint 存储，共 8 个字节。采取位运算的形式。
    当创建表时，SET 成员值的尾部空格将自动被删除。

/* 选择类型 */
-- PHP 角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP 存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为 4 个字节的无符号 int，即 unsigned
    1) PHP 函数转换
        ip2long 可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
        利用 sprintf 函数格式化字符串
        sprintf("%u", ip2long('192.168.3.134'));
        然后用 long2ip 将整型转回 IP 字符串
    2) MySQL 函数转换(无符号整型，UNSIGNED)
        INET_ATON('127.0.0.1') 将 IP 转为整型
        INET_NTOA(2130706433) 将整型转为 IP
        



/* 列属性（列约束） */ ------------------
1. 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为 null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

2. unique 唯一索引（唯一约束）
    使得某字段的值也不能重复。
    
3. null 约束
    null 不是数据类型，是列的一个属性。
    表示当前列是否可以为 null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, 'val');
        -- 此时表示将第一个字段的值设为 null, 取决于该字段是否允许为 null
    
4. default 默认值属性
    当前字段的默认值。
    insert into tab values (default, 'val');    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time

5. auto_increment 自动增长约束
    自动增长必须为索引（主键或 unique）
    只能存在一个字段为自动增长。
    默认为 1 开始自动增长。可以通过表属性 auto_increment = x 进行设置，或 alter table tbl auto_increment = x;

6. comment 注释
    例：create table tab ( id int ) comment '注释内容';

7. foreign key 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表 t1 的 t1_id 外键关联到表 t2 的 id 字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定

    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。

    MySQL 中，可以对 InnoDB 引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为 null.前提是该外键列，没有 not null。

    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为 null。主表数据被更新（主键值更新），从表的外键被设置为 null。主表记录被删除，从表相关记录外键被设置成 null。但注意，要求该外键列，没有 not null 属性约束。
    3. restrict，拒绝父表删除和更新。

    注意，外键只被 InnoDB 存储引擎所支持。其他引擎是不支持的。


/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个 ID 字段作为主键
        - ID 主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除符合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。


/* select */ ------------------

select [all|distinct] select_expr from -> where -> group by [合计函数] -> having -> order by -> limit

a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;

b. from 子句
    用于标识查询来源。
    -- 可以为表起别名。使用 as 关键字。
        select * from tb1 as tt, tb2 as bb;
    -- from 子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        select * from tb1, tb2;

c. where 子句
    -- 从 from 获得的数据源中进行筛选。
    -- 整型 1 表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, <=>, <>, !=, <=, <, >=, >, !, &&, ||, 
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上 ture/false/unknown，检验某个值的真假
            <=>与<>功能相同，<=>可用于 null 比较

d. group by 子句, 分组子句
    group by 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC
    
    以下[合计函数]需配合 group by 使用：
    count 返回不同的非 NULL 值数目    count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非 NULL 值的字符串结果。组内字符串连接。

e. having 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行 WHERE 代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL 标准要求 HAVING 必须引用 GROUP BY 子句中的列或用于合计函数中的列。

f. order by 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

g. limit 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从 0 开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引 0 开始。limit 获取条数

h. distinct, all 选项
    distinct 去除重复记录
    默认为 all, 全部记录


/* UNION */ ------------------
    将多个 select 查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个 SELECT 查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各 select 查询的字段数量一样。
    每个 select 查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条 select 语句为准。


/* 子查询 */ ------------------
    - 子查询需用括号包裹。
-- from 型
    from 后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from 型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id>0) as subfrom where id>1;
-- where 型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where 子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回 1 或 0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。

    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()    不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。


/* 连接查询(join) */ ------------------
    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略 inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与 where 类似。也可以省略条件（表示条件永远为真）
    也可用 where 表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)

    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为 null 填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为 null 填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了 using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;

/* 导入导出 */ ------------------
select * into outfile 文件地址 [控制格式] from 表名;    -- 导出表数据
load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式];    -- 导入数据
    生成的数据默认的分隔符是制表符
    local 未指定，则数据文件必须在服务器上
    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields    控制字段格式
默认：fields terminated by '\t' enclosed by '' escaped by '\\'
    terminated by 'string'    -- 终止
    enclosed by 'char'        -- 包裹
    escaped by 'char'        -- 转义
    -- 示例：
        SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        LINES TERMINATED BY '\n'
        FROM test_table;
lines    控制行格式
默认：lines terminated by '\n'
    terminated by 'string'    -- 终止
    
/* insert */ ------------------
select 语句获得的数据可以用 insert 插入。

可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
    或者使用 set 语法。
    insert into tbl_name set field=value,...；

可以一次性使用多个值，采用(), (), ();的形式。
    insert into tbl_name values (), (), ();

可以在列值指定时，使用表达式。
    insert into tbl_name values (field_value, 10+10, now());
可以使用一个特殊值 default，表示该列使用默认值。
    insert into tbl_name values (field_value, default);

可以通过一个查询的结果，作为需要插入的值。
    insert into tbl_name select ...;

可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
    insert into tbl_name values/set/select on duplicate key update 字段=值, …;

/* delete */ ------------------
DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]

按照条件删除

指定删除的最多记录数。Limit

可以通过排序条件删除。order by + limit

支持多表删除，使用类似连接语法。
delete from 需要删除数据多表 1，表 2 using 表连接操作 条件。

/* truncate */ ------------------
TRUNCATE [TABLE] tbl_name
清空数据
删除重建表

区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置 auto_increment 的值。而 delete 不会
3，truncate 不知道删除了几条，而 delete 知道。
4，当被用于带分区的表时，truncate 会保留分区


/* 备份与还原 */ ------------------
备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。

-- 导出
1. 导出一张表
　　mysqldump -u 用户名 -p 密码 库名 表名 > 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u 用户名 -p 密码 库名 表 1 表 2 表 3 > 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u 用户名 -p 密码 库名 > 文件名(D:/a.sql)
4. 导出一个库 
　　mysqldump -u 用户名 -p 密码 -B 库名 > 文件名(D:/a.sql)

可以-w 携带备份条件

-- 导入
1. 在登录 mysql 的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u 用户名 -p 密码 库名 < 备份文件


/* 视图 */ ------------------
什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的 sql 语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用 select 语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过 ALGORITHM 指定。
    - column_list 如果存在，则数目必须等于 SELECT 语句检索的列数

-- 查看结构
    SHOW CREATE VIEW view_name 

-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...

-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement

-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构

-- 视图算法(ALGORITHM)
    MERGE        合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE    临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED    未定义(默认)，指的是 MySQL 自主去选择相应的算法。



/* 事务(transaction) */ ------------------
事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 
    - 支持连续 SQL 的集体成功或集体撤销。
    - 事务是数据库在数据晚自习方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB 被称为事务安全型引擎。

-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的 SQL 语句均被认作当前事务内的 SQL 语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。

-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。

-- 事务的原理
    利用 InnoDB 的自动提交(autocommit)特性完成。
    普通的 MySQL 执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要 commit 提交持久化数据操作。

-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套

-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点

-- InnoDB 自动提交特性设置
    SET autocommit = 0|1;    0 表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要 commit 提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与 START TRANSACTION 不同的是，
        SET autocommit 是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而 START TRANSACTION 记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)


/* 锁表 */
表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES


/* 触发器 */ ------------------
    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
    监听：记录的增加、修改、删除。

-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
    参数：
    trigger_time 是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
    trigger_event 指明了激活触发程序的语句的类型
        INSERT：将新行插入表时激活触发程序
        UPDATE：更改某一行时激活触发程序
        DELETE：从表中删除某一行时激活触发程序
    tbl_name：监听的表，必须是永久性的表，不能将触发程序与 TEMPORARY 表或视图关联起来。
    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用 BEGIN...END 复合语句结构

-- 删除
DROP TRIGGER [schema_name.]trigger_name

可以使用 old 和 new 代替旧的和新的数据
    更新操作，更新前是 old，更新后是 new.
    删除操作，只有 old.
    增加操作，只有 new.

-- 注意
    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。


-- 字符连接函数
concat(str1[, str2,...])

-- 分支语句
if 条件 then
    执行语句
elseif 条件 then
    执行语句
else
    执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
    SQL 语句
自定义结束符号

delimiter ;        -- 修改回原来的分号

-- 语句块包裹
begin
    语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
    如果没有重复记录，会触发 before insert, after insert;
    如果有重复记录并更新，会触发 before insert, before update, after update;
    如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert


/* SQL 编程 */ ------------------

--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value] 
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个 default 子句。值可以被指定为一个表达式，不需要为一个常数。如果没有 default 子句，初始值为 null。 

-- 赋值
    使用 set 和 select into 语句为变量赋值。

    - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用 select into 语句为变量初始化并赋值。这样要求 select 语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过 select 执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set 语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;

select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量名
为了避免 select 语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;

    - 变量被定义后，在整个会话周期都有效（登录到退出）


--// 控制结构 ----------
-- if 语句
if search_condition then 
    statement_list    
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;

-- case 语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END


-- while 循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];

- 如果需要在循环内提前终止 while 循环，则需要使用标签；标签需要成对出现。

    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环


--// 内置函数 ----------
-- 数值函数
abs(x)            -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)            -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)        -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)        -- m^n
sqrt(x)            -- 算术平方根
rand()            -- 随机数
truncate(x, d)    -- 截取 d 位小数

-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                    -- 当前日期
current_time();                    -- 当前时间
date('yyyy-mm-dd hh:ii:ss');    -- 获取日期部分
time('yyyy-mm-dd hh:ii:ss');    -- 获取时间部分
date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j');    -- 格式化时间
unix_timestamp();                -- 获得 unix 时间戳
from_unixtime();                -- 从时间戳获得时间

-- 字符串函数
length(string)            -- string 长度，字节
char_length(string)        -- string 的字符个数
substring(str, position [,length])        -- 从 str 的 position 开始,取 length 个字符
replace(str ,search_str ,replace_str)    -- 在 str 中用 replace_str 替换 search_str
instr(string ,substring)    -- 返回 substring 首次在 string 中出现的位置
concat(string [,...])    -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)            -- 转换成小写
left(string, length)    -- 从 string2 中的左边起取 length 个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position])    -- 同 instr,但可指定开始位置
lpad(string, length, pad)    -- 重复用 pad 加在 string 开头,直到字串长度为 length
ltrim(string)            -- 去除前端空格
repeat(string, count)    -- 重复 count 次
rpad(string, length, pad)    --在 str 后用 pad 补充,直到长度为 length
rtrim(string)            -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小

-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。

-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()

-- 其他常用函数
md5();
default();


--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体

    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用 db_name.funciton_name 的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由"参数名"和"参数类型"组成。多个参数用逗号隔开。
    - 函数体由多条可用的 mysql 语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。

-- 删除
    DROP FUNCTION [IF EXISTS] function_name;

-- 查看
    SHOW FUNCTION STATUS LIKE 'partten'
    SHOW CREATE FUNCTION function_name;

-- 修改
    ALTER FUNCTION function_name 函数选项


--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的 sql 组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过 call 执行。

-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体

参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型

注意，没有返回值。


/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中

-- 参数
IN|OUT|INOUT 参数名 数据类型
IN        输入：在调用过程中，将数据输入到过程体内部的参数
OUT        输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT    输入输出：既可输入，也可输出

-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END


/* 用户和权限管理 */ ------------------
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有 mysql 数据库的全局 CREATE USER 权限，或拥有 INSERT 权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 'user_name'@'192.168.1.1'
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略 PASSWORD 关键词。要把密码指定为由 PASSWORD()函数返回的混编值，需包含关键字 PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD('密码')    -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD('密码')    -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password']
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名    -- 撤销所有权限
-- 权限层级
-- 要使用 GRANT 或 REVOKE，您必须拥有 GRANT OPTION 权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和 REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name 和 REVOKE ALL ON db_name.tbl_name 只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用 REVOKE 时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除 GRANT OPTION 之外的所有简单权限
ALTER    -- 允许使用 ALTER TABLE
ALTER ROUTINE    -- 更改或取消已存储的子程序
CREATE    -- 允许使用 CREATE TABLE
CREATE ROUTINE    -- 创建已存储的子程序
CREATE TEMPORARY TABLES        -- 允许使用 CREATE TEMPORARY TABLE
CREATE USER        -- 允许使用 CREATE USER, DROP USER, RENAME USER 和 REVOKE ALL PRIVILEGES。
CREATE VIEW        -- 允许使用 CREATE VIEW
DELETE    -- 允许使用 DELETE
DROP    -- 允许使用 DROP TABLE
EXECUTE        -- 允许用户运行已存储的子程序
FILE    -- 允许使用 SELECT...INTO OUTFILE 和 LOAD DATA INFILE
INDEX     -- 允许使用 CREATE INDEX 和 DROP INDEX
INSERT    -- 允许使用 INSERT
LOCK TABLES        -- 允许对您拥有 SELECT 权限的表使用 LOCK TABLES
PROCESS     -- 允许使用 SHOW FULL PROCESSLIST
REFERENCES    -- 未被实施
RELOAD    -- 允许使用 FLUSH
REPLICATION CLIENT    -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE    -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT    -- 允许使用 SELECT
SHOW DATABASES    -- 显示所有数据库
SHOW VIEW    -- 允许使用 SHOW CREATE VIEW
SHUTDOWN    -- 允许使用 mysqladmin shutdown
SUPER    -- 允许使用 CHANGE MASTER, KILL, PURGE MASTER LOGS 和 SET GLOBAL 语句，mysqladmin debug 命令；允许您连接（一次），即使已达到 max_connections。
UPDATE    -- 允许使用 UPDATE
USAGE    -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限


/* 表维护 */
-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...


/* 杂项 */ ------------------
1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件 db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容        (标准 SQL 注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _    任意单个字符
    %    任意多个字符，甚至包括零字符
    单引号需要进行转义 \'
5. CMD 命令行内的语句结束符可以为 ";", "\G", "\g"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL 对大小写不敏感
7. 清除已有语句：\c
#+end_src

* f
** mysql
*** 索引
**** B+ Tree 原理
*****  数据结构
      B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

      B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

      在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻
      key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向
      节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。
*****  操作
   进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地
   在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，
   找出 key 所对应的 data。

   插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、
   合并、旋转等操作来维护平衡性。
***** 与红黑树的比较
   红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作
   为索引结构，主要有以下两个原因：

   （一）更少的查找次数

   平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。

   红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

   （二）利用磁盘预读特性

   为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。

   操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。
**** MySQL 索引

   索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
***** B+Tree 索引
      是大多数 MySQL 存储引擎的默认索引类型。

      因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

   除了用于查找，还可以用于排序和分组。

   可以指定多个列作为索引列，多个索引列共同组成键。

   适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

   InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整
   的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，
   所以一个表只能有一个聚簇索引。


   辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。
***** 哈希索引

   哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

   - 无法用于排序与分组；
   - 只支持精确查找，无法用于部分查找和范围查找。

   InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常
   频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索
   引的一些优点，比如快速的哈希查找。
***** 全文索引
      MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

   查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

   全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

   InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
***** 空间数据索引

   MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

   必须使用 GIS 相关的函数来维护数据。
**** 索引优化
***** 独立的列

   在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

   例如下面的查询不能使用 actor_id 列的索引：

   ```sql
   SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
   ```
***** 多列索引

   在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

   ```sql
   SELECT film_id, actor_ id FROM sakila.film_actor
   WHERE actor_id = 1 AND film_id = 1;
   ```
***** 索引列的顺序

   让选择性最强的索引列放在前面。

   索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有
   唯一的索引与其对应。选择性越高，查询效率也越高。

   例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

   ```sql
   SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
   COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
   COUNT(*)
   FROM payment;
   ```

   ```html
      staff_id_selectivity: 0.0001
   customer_id_selectivity: 0.0373
                  COUNT(*): 16049
   ```
***** 前缀索引

   对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

   对于前缀长度的选取需要根据索引选择性来确定。
***** 覆盖索引

   索引包含所有需要查询的字段的值。

   具有以下优点：

   - 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
   - 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
   - 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
**** 索引的优点

   - 大大减少了服务器需要扫描的数据行数。

   - 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以
     用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需
     要排序和分组，也就不需要创建临时表）。

   - 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
**** 索引的使用条件

   - 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；

   - 对于中到大型的表，索引就非常有效；

   - 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

*** 查询性能优化
**** 使用 Explain 进行分析

    Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

    比较重要的字段有：

    - select_type : 查询类型，有简单查询、联合查询、子查询等
    - key : 使用的索引
    - rows : 扫描的行数
**** 优化数据访问
***** 减少请求的数据量

    - 只返回必要的列：最好不要使用 SELECT * 语句。
    - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
    - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。
***** 减少服务器端扫描的行数

    最有效的方式是使用索引来覆盖查询。
**** 重构查询方式
*****  切分大查询

     一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

     ```sql
     DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
     ```

     ```sql
     rows_affected = 0
     do {
         rows_affected = do_query(
         "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
     } while rows_affected > 0
     ```
***** 分解大连接查询

     将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

     - 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
     - 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
     - 减少锁竞争；
     - 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
     - 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

     ```sql
     SELECT * FROM tab
     JOIN tag_post ON tag_post.tag_id=tag.id
     JOIN post ON tag_post.post_id=post.id
     WHERE tag.tag='mysql';
     ```

     ```sql
     SELECT * FROM tag WHERE tag='mysql';
     SELECT * FROM tag_post WHERE tag_id=1234;
     SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
     ```
** 存储引擎
*** InnoDB
     是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

     实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读
     隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

     主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

     内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

     支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
*** MyISAM

     设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

     提供了大量的特性，包括压缩表、空间数据索引等。

     不支持事务。

     不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则
     对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发
     插入（CONCURRENT INSERT）。

     可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

     如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引
     数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候
     才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者
     主机崩溃时会造成索引损坏，需要执行修复操作。
*** 比较

     - 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

     - 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

     - 外键：InnoDB 支持外键。

     - 备份：InnoDB 支持在线热备份。

     - 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

     - 其它特性：MyISAM 支持压缩表和空间数据索引。
**  数据类型
*** 整型

     TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

     INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。
*** 浮点数

     FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

     FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。
*** 字符串

     主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

     VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

     在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。
*** 时间和日期

     MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。
****  DATETIME

      能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。

      它与时区无关。

      默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。
****  TIMESTAMP

      和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

      它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

      MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

      默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

      应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。
** 切分
*** 水平切分

      水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

      当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
*** 垂直切分

      垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

      在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。
*** Sharding 策略

      - 哈希取模：hash(key) % N；
      - 范围：可以是 ID 范围也可以是时间范围；
      - 映射表：使用单独的一个数据库来存储映射关系。
**** Sharding 存在的问题
*****  事务问题

       使用分布式事务来解决，比如 XA 接口。
***** 连接

       可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。
*****  ID 唯一性

       - 使用全局唯一 ID（GUID）
       - 为每个分片指定一个 ID 范围
       - 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)
*** 复制
**** 主从复制

       主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

       -  **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
       -  **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。
       -  **SQL 线程** ：负责读取重放日志并重放其中的 SQL 语句。
**** 读写分离

       主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

       读写分离能提高性能的原因在于：

       - 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
       - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
       - 增加冗余，提高可用性。

       读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

** 时间戳
  常量 CURRENT_TIMESTAMP 

* Linux下Mysql常用命令总结
** 操作数据库的命令
*** 登录数据库
 #+BEGIN_EXAMPLE
      mysql  -hXX  -uXX  -pXX  -PXX
 #+END_EXAMPLE

 h代表localhost\\
 u代表用户名\\
 p代表密码\\
 P代表端口

*** 显示数据库
 #+BEGIN_EXAMPLE
 show databases;
 #+END_EXAMPLE

 注意，databases后面有一个s。

*** 创建数据库


 #+BEGIN_EXAMPLE
        create  database name;
 #+END_EXAMPLE

*** 选择数据库


 #+BEGIN_EXAMPLE
       use  databasename;
 #+END_EXAMPLE

*** 删除数据库


**** drop命令


 #+BEGIN_EXAMPLE
        drop  database name;
 #+END_EXAMPLE

 drop命令可以使用if exits选项判断数据库是否存在，存在即删除，不存在也不会报错。

 #+BEGIN_EXAMPLE
        drop  database  if  exists name;
 #+END_EXAMPLE

 要注意的是drop命令直接删除数据库，不进行提醒。\\
 如果需要在删除数据库前有提示，使用下面的语句：

 #+BEGIN_EXAMPLE
      mysqladmin   drop  database name;
 #+END_EXAMPLE

*** 查看当前使用的数据库

 #+BEGIN_EXAMPLE
        select  database
 #+END_EXAMPLE

*** 刷新数据库


 #+BEGIN_EXAMPLE
      flush privileges;
 #+END_EXAMPLE

*** 显示当前MYSQL版本和当前日期


 #+BEGIN_EXAMPLE
        select version(), current_date;
 #+END_EXAMPLE

** 备份数据库


*** mysqldump


*** mysqladmin

** 操作数据表的命令
*** 显示表
 #+BEGIN_EXAMPLE
        show tables;
 #+END_EXAMPLE

*** 显示具体的表结构
 #+BEGIN_EXAMPLE
      describe tablename;
 #+END_EXAMPLE

*** 建立


 #+BEGIN_EXAMPLE
      create table  ( ...);
 #+END_EXAMPLE

 复制数据表A建立数据表B包含两种形式

**** 1、不包含数据


 #+BEGIN_EXAMPLE
        create  table A  like B;
 #+END_EXAMPLE

**** 2、包含数据


 #+BEGIN_EXAMPLE
        create  table A  as  select *  from B;
 #+END_EXAMPLE

*** 添加

*** 修改
**** 重命名表
 #+BEGIN_EXAMPLE
        alter  table A rename B;
 #+END_EXAMPLE

*** 删除
*** 查询

** 对用户进行操作的命令


*** 授予权限


*** 取消权限
* 通用类型设计
  id  char(32)
 标题　varchar(100) 
 名称　VARCHAR(200) 
 描述　varchar(100)
 内容　varchar(1000) ／text

  用户信息
  身份证号　CHAR(18)
  卡的名称　VARCHAR(100)
  手机号 VARCHAR(11)
  地址url  VARCHAR(100)
  时间 DATE
