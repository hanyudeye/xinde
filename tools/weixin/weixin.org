* 小程序
** 小程序配置
*** 全局配置app.json
 #+BEGIN_EXAMPLE
     {
       "pages": [
         "pages/index/index",
         "pages/logs/index"
       ],
       "window": {
         "navigationBarTitleText": "Demo"
       },
       "tabBar": {
         "list": [{
           "pagePath": "pages/index/index",
           "text": "首页"
         }, {
           "pagePath": "pages/logs/index",
           "text": "日志"
         }]
       },
       "networkTimeout": {
         "request": 10000,
         "downloadFile": 10000
       },
       "debug": true,
       "navigateToMiniProgramAppIdList": [
         "wxe5f52902cf4de896"
       ]
     }
 #+END_EXAMPLE
*** 页面配置 .json
 #+BEGIN_EXAMPLE
     {
       "navigationBarBackgroundColor": "#ffffff",
       "navigationBarTextStyle": "black",
       "navigationBarTitleText": "微信接口功能演示",
       "backgroundColor": "#eeeeee",
       "backgroundTextStyle": "light"
     }
 #+END_EXAMPLE
*** sitemap.json 
  小程序根目录下的 =sitemap.json=文件用来配置小程序及其页面是否允许被微信索引。

  完整配置项说明请参考[[../reference/configuration/sitemap.html][小程序 sitemap 配置]]
  *例 1：*
  #+BEGIN_EXAMPLE
      {
        "rules":[{
          "action": "allow",
          "page": "*"
        }]
      }
  #+END_EXAMPLE

  所有页面都会被微信索引（默认情况）

  *例 2：*
  #+BEGIN_EXAMPLE
      {
        "rules":[{
          "action": "disallow",
          "page": "path/to/page"
        }]
      }
  #+END_EXAMPLE

  配置 =path/to/page= 页面不被索引，其余页面允许被索引

  *例 3：*
  #+BEGIN_EXAMPLE
      {
        "rules":[{
          "action": "allow",
          "page": "path/to/page"
        }, {
          "action": "disallow",
          "page": "*"
        }]
      }
  #+END_EXAMPLE

  配置 =path/to/page= 页面被索引，其余页面不被索引

  *例 4：*

  #+BEGIN_EXAMPLE
      {
        "rules":[{
          "action": "allow",
          "page": "path/to/page",
          "params": ["a", "b"],
          "matching": "inclusive"
        }, {
          "action": "allow",
          "page": "*"
        }]
      }
  #+END_EXAMPLE

  包含 =a 和 b= 参数的 =path/to/page=
  页面会被微信优先索引，其他页面都会被索引，例如：

  -  =path/to/page?a=1&b=2= => 优先被索引
  -  =path/to/page?a=1&b=2&c=3= => 优先被索引
  -  =path/to/page= => 被索引
  -  =path/to/page?a=1= => 被索引
  -  其他页面都会被索引

  *例 5：*

  #+BEGIN_EXAMPLE
      {
        "rules":[{
          "action": "allow",
          "page": "path/to/page",
          "params": ["a", "b"],
          "matching": "inclusive"
        }, {
          "action": "disallow",
          "page": "*"
        }, {
          "action": "allow",
          "page": "*"
        }]
      }
  #+END_EXAMPLE

  -  =path/to/page?a=1&b=2= => 优先被索引
  -  =path/to/page?a=1&b=2&c=3= => 优先被索引
  -  =path/to/page= => 不被索引
  -  =path/to/page?a=1= => 不被索引
  -  其他页面由于命中第二条规则，所以不会被索引
  -  由于优先级的问题，第三条规则是没有意义的

  *注：没有 sitemap.json 则默认所有页面都能被索引*

  *注：={"action": "allow", "page": "*"}=
  是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引*

**** [[index_u87.html#如何调试][#]] 如何调试
  当在小程序项目中设置了 =sitemap= 的配置文件（默认为
  =sitemap.json=）时,便可在开发者工具控制台上显示当前页面是否被索引的调试信息（
  最新版本的开发者工具支持索引提示）

  [[file:feed_0/article_30/images/img1_u12.png]]

  *注：=sitemap= 的索引提示是默认开启的，如需要关闭 =sitemap=
  的索引提示，可在小程序项目配置文件 =project.config.json= 的 =setting=
  中配置字段 =checkSiteMap= 为 =false=*

  *注: =sitemap= 文件内容最大为 5120 个 UTF8 字符*

** 框架
*** [[index_u88.html#逻辑层-App-Service][#]] 逻辑层 App Service
  小程序开发框架的逻辑层使用 =JavaScript= 引擎为小程序提供开发者=JavaScript= 代码
  的运行环境以及微信小程序的特有功能。

  逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

  开发者写的所有代码最终将会打包成一份 =JavaScript=
  文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似
  [[https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API][ServiceWorker<<>>]]，所以逻辑层也称之为
  App Service。

  在 =JavaScript= 的基础上，我们增加了一些功能，以方便小程序的开发：

  -  增加 =App= 和 =Page=方法，进行[[file:app.html][程序注册]]和[[file:page.html][页面注册]]。
  -  增加 =getApp= 和 =getCurrentPages= 方法，分别用来获取 =App=实例和当前页面栈。
  -  提供丰富的[[file:api.html][API]]，如微信用户数据，扫一扫，支付等微信特有能力。
  -  提供[[file:module.html#模块化][模块化]]能力，每个页面有独立的[[file:module.html#文件作用域][作用域]]。

  *注意：小程序框架的逻辑层并非运行在浏览器中，因此 =JavaScript= 在 web
  中一些能力都无法使用，如 =window=，=document= 等。*


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/]]

  \\
  \\




 













  --------------


 










**** [[index_u89.html#注册小程序][#]] 注册小程序


  
  

   每个小程序都需要在 =app.js= 中调用 =App=
   方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

   详细的参数含义和使用请参考 [[../../reference/api/App.html][App
   参考文档]] 。





   #+BEGIN_EXAMPLE
       // app.js
       App({
         onLaunch (options) {
           // Do something initial when launch.
         },
         onShow (options) {
           // Do something when show.
         },
         onHide () {
           // Do something when hide.
         },
         onError (msg) {
           console.log(msg)
         },
         globalData: 'I am global data'
       })
   #+END_EXAMPLE


 


   整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 =getApp=
   方法获取到全局唯一的 App 实例，获取 App 上的数据或调用开发者注册在 =App=
   上的函数。





   #+BEGIN_EXAMPLE
       // xxx.js
       const appInstance = getApp()
       console.log(appInstance.globalData) // I am global data
   #+END_EXAMPLE


 



 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html]]

   \\
   \\




 













   --------------


 










**** [[index_u51.html#注册页面][#]] 注册页面
   对于小程序中的每个页面，都需要在页面对应的 =js=
   文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

***** [[index_u51.html#使用-Page-构造器注册页面][#]] 使用 Page
   构造器注册页面
   简单的页面可以使用 =Page()= 进行构造。

   *代码示例：*

   #+BEGIN_EXAMPLE
       //index.js
       Page({
         data: {
           text: "This is page data."
         },
         onLoad: function(options) {
           // 页面创建时执行
         },
         onShow: function() {
           // 页面出现在前台时执行
         },
         onReady: function() {
           // 页面首次渲染完毕时执行
         },
         onHide: function() {
           // 页面从前台变为后台时执行
         },
         onUnload: function() {
           // 页面销毁时执行
         },
         onPullDownRefresh: function() {
           // 触发下拉刷新时执行
         },
         onReachBottom: function() {
           // 页面触底时执行
         },
         onShareAppMessage: function () {
           // 页面被用户分享时执行
         },
         onPageScroll: function() {
           // 页面滚动时执行
         },
         onResize: function() {
           // 页面尺寸变化时执行
         },
         onTabItemTap(item) {
           // tab 点击时执行
           console.log(item.index)
           console.log(item.pagePath)
           console.log(item.text)
         },
         // 事件响应函数
         viewTap: function() {
           this.setData({
             text: 'Set some data for updating view.'
           }, function() {
             // this is setData callback
           })
         },
         // 自由数据
         customData: {
           hi: 'MINA'
         }
       })
   #+END_EXAMPLE


 


   详细的参数含义和使用请参考 [[../../reference/api/Page.html][Page
   参考文档]] 。

***** [[index_u51.html#在页面中使用-behaviors][#]] 在页面中使用 behaviors


  
  

   #+BEGIN_QUOTE
     基础库 2.9.2 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
   #+END_QUOTE

   页面可以引用 behaviors 。 behaviors
   可以用来让多个页面有相同的数据字段和方法。





   #+BEGIN_EXAMPLE
       // my-behavior.js
       module.exports = Behavior({
         data: {
           sharedText: 'This is a piece of data shared between pages.'
         },
         methods: {
           sharedMethod: function() {
             this.data.sharedText === 'This is a piece of data shared between pages.'
           }
         }
       })
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // page-a.js
       var myBehavior = require('./my-behavior.js')
       Page({
         behaviors: [myBehavior],
         onLoad: function() {
           this.data.sharedText === 'This is a piece of data shared between pages.'
         }
       })
   #+END_EXAMPLE


 


   具体用法参见 [[../custom-component/behaviors.html][behaviors]] 。

***** [[index_u51.html#使用-Component-构造器构造页面][#]] 使用 Component
   构造器构造页面


  
  

   #+BEGIN_QUOTE
     基础库 1.6.3 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
   #+END_QUOTE

   =Page= 构造器适用于简单的页面。但对于复杂的页面， =Page=
   构造器可能并不好用。

   此时，可以使用 =Component= 构造器来构造页面。 =Component=
   构造器的主要区别是：方法需要放在 =methods: { }= 里面。

   *代码示例：*





   #+BEGIN_EXAMPLE
       Component({
         data: {
           text: "This is page data."
         },
         methods: {
           onLoad: function(options) {
             // 页面创建时执行
           },
           onPullDownRefresh: function() {
             // 下拉刷新时执行
           },
           // 事件响应函数
           viewTap: function() {
             // ...
           }
         }
       })
   #+END_EXAMPLE


 


   这种创建方式非常类似于 [[../custom-component][自定义组件]]
   ，可以像自定义组件一样使用 =behaviors= 等高级特性。

   具体细节请阅读 [[../custom-component/component.html][=Component=
   构造器]] 章节。


 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html]]

   \\
   \\




 













   --------------


 










***** [[index_u19.html#生命周期][#]] 生命周期


  
  

   *以下内容你不需要立马完全弄明白，不过以后它会有帮助。*

   下图说明了页面 =Page= 实例的生命周期。

   [[file:feed_0/article_36/images/img1_u18.png]]


 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html]]

   \\
   \\




 













   --------------


 










**** [[index_u17.html#页面路由][#]] 页面路由
   在小程序中所有页面的路由全部由框架进行管理。

****** [[index_u17.html#页面栈][#]] 页面栈
   框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下：

   | 路由方式     | 页面栈表现                          |
   |--------------+-------------------------------------|
   | 初始化       | 新页面入栈                          |
   | 打开新页面   | 新页面入栈                          |
   | 页面重定向   | 当前页面出栈，新页面入栈            |
   | 页面返回     | 页面不断出栈，直到目标返回页        |
   | Tab 切换     | 页面全部出栈，只留下新的 Tab 页面   |
   | 重加载       | 页面全部出栈，只留下新的页面        |

   开发者可以使用 =getCurrentPages()= 函数获取当前页面栈。

****** [[index_u17.html#路由方式][#]] 路由方式

   对于路由的触发方式以及页面生命周期函数如下：

   | 路由方式     | 触发时机                                                                               | 路由前页面   | 路由后页面           |
   |--------------+----------------------------------------------------------------------------------------+--------------+----------------------|
   | 初始化       | 小程序打开的第一个页面                                                                 |              | onLoad, onShow       |
   | 打开新页面   | 调用 API [[../../api/route/wx.navigateTo.html][wx.navigateTo]]\\                       | onHide       | onLoad, onShow       |
   |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="navigateTo"/>=]]     |              |                      |
   | 页面重定向   | 调用 API [[../../api/route/wx.redirectTo.html][wx.redirectTo]]\\                       | onUnload     | onLoad, onShow       |
   |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="redirectTo"/>=]]     |              |                      |
   | 页面返回     | 调用 API [[../../api/route/wx.navigateBack.html][wx.navigateBack]]\\                   | onUnload     | onShow               |
   |              | 使用组件[[../../component/navigator.html][=<navigator open-type="navigateBack">=]]\\   |              |                      |
   |              | 用户按左上角返回按钮                                                                   |              |                      |
   | Tab 切换     | 调用 API [[../../api/route/wx.switchTab.html][wx.switchTab]]\\                         |              | 各种情况请参考下表   |
   |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="switchTab"/>=]]\\    |              |                      |
   |              | 用户切换 Tab                                                                           |              |                      |
   | 重启动       | 调用 API [[../../api/route/wx.reLaunch.html][wx.reLaunch]]\\                           | onUnload     | onLoad, onShow       |
   |              | 使用组件 [[../../component/navigator.html][=<navigator open-type="reLaunch"/>=]]       |              |                      |


 


   Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A
   页面打开的页面，D 页面是从 C 页面打开的页面为例）：





   | 当前页面          | 路由后页面      | 触发的生命周期（按顺序）                             |
   |-------------------+-----------------+------------------------------------------------------|
   | A                 | A               | Nothing happend                                      |
   | A                 | B               | A.onHide(), B.onLoad(), B.onShow()                   |
   | A                 | B（再次打开）   | A.onHide(), B.onShow()                               |
   | C                 | A               | C.onUnload(), A.onShow()                             |
   | C                 | B               | C.onUnload(), B.onLoad(), B.onShow()                 |
   | D                 | B               | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()   |
   | D（从转发进入）   | A               | D.onUnload(), A.onLoad(), A.onShow()                 |
   | D（从转发进入）   | B               | D.onUnload(), B.onLoad(), B.onShow()                 |


 


   *Tips*:

   -  =navigateTo=, =redirectTo= 只能打开非 tabBar 页面。
   -  =switchTab= 只能打开 tabBar 页面。
   -  =reLaunch= 可以打开任意页面。
   -  页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有
      tabBar。
   -  调用页面路由带的参数可以在目标页面的=onLoad=中获取。


 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html]]

   \\
   \\




 













   --------------


 










***** [[index_u44.html#模块化][#]] 模块化


  
  

   可以将一些公共的代码抽离成为一个单独的 js
   文件，作为一个模块。模块只有通过
   [[../../reference/api/module.html][=module.exports=]] 或者 =exports=
   才能对外暴露接口。

   注意：

   -  =exports= 是 [[../../reference/api/module.html][=module.exports=]]
      的一个引用，因此在模块里边随意更改 =exports=
      的指向会造成未知的错误。所以更推荐开发者采用 =module.exports=
      来暴露模块接口，除非你已经清晰知道这两者的关系。
   -  小程序目前不支持直接引入 =node_modules= , 开发者需要使用到
      =node_modules=
      时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的
      [[../../devtools/npm.html][npm]] 功能。





   #+BEGIN_EXAMPLE
       // common.js
       function sayHello(name) {
         console.log(`Hello ${name} !`)
       }
       function sayGoodbye(name) {
         console.log(`Goodbye ${name} !`)
       }

       module.exports.sayHello = sayHello
       exports.sayGoodbye = sayGoodbye
   #+END_EXAMPLE


 


   在需要使用这些模块的文件中，使用 =require= 将公共代码引入





   #+BEGIN_EXAMPLE
       var common = require('common.js')
       Page({
         helloMINA: function() {
           common.sayHello('MINA')
         },
         goodbyeMINA: function() {
           common.sayGoodbye('MINA')
         }
       })
   #+END_EXAMPLE


 


****** [[index_u44.html#文件作用域][#]] 文件作用域


  
  

   在 JavaScript
   文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

   通过全局函数 =getApp= 可以获取全局的应用实例，如果需要全局的数据可以在
   =App()= 中设置，如：





   #+BEGIN_EXAMPLE
       // app.js
       App({
         globalData: 1
       })
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // a.js
       // The localValue can only be used in file a.js.
       var localValue = 'a'
       // Get the app instance.
       var app = getApp()
       // Get the global data and change it.
       app.globalData++
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // b.js
       // You can redefine localValue in file b.js, without interference with the localValue in a.js.
       var localValue = 'b'
       // If a.js it run before b.js, now the globalData shoule be 2.
       console.log(getApp().globalData)
   #+END_EXAMPLE


 



 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html]]

   \\
   \\




 













   --------------


 










**** [[index_u57.html#API][#]] API


  
  

   小程序开发框架提供丰富的微信原生
   API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考
   [[../../api/index.html][API 文档]]。

   通常，在小程序 API 有以下几种类型：

***** [[index_u57.html#事件监听-API][#]] 事件监听 API


  
  

   我们约定，以 =on= 开头的 API
   用来监听某个事件是否触发，如：[[../../api/network/websocket/wx.onSocketOpen.html][wx.onSocketOpen]]，[[../../api/device/compass/wx.onCompassChange.html][wx.onCompassChange]]
   等。

   这类 API
   接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

   *代码示例*





   #+BEGIN_EXAMPLE
       wx.onCompassChange(function (res) {
         console.log(res.direction)
       })
   #+END_EXAMPLE


 


***** [[index_u57.html#同步-API][#]] 同步 API


  
  

   我们约定，以 =Sync= 结尾的 API 都是同步 API， 如
   [[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]，[[../../api/base/system/system-info/wx.getSystemInfoSync.html][wx.getSystemInfoSync]]
   等。此外，也有一些其他的同步 API，如
   [[../../api/worker/wx.createWorker.html][wx.createWorker]]，[[../../api/media/background-audio/wx.getBackgroundAudioManager.html][wx.getBackgroundAudioManager]]
   等，详情参见 API 文档中的说明。

   同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

   *代码示例*





   #+BEGIN_EXAMPLE
       try {
         wx.setStorageSync('key', 'value')
       } catch (e) {
         console.error(e)
       }
   #+END_EXAMPLE


 


***** [[index_u57.html#异步-API][#]] 异步 API


  
  

   大多数 API 都是异步 API，如
   [[../../api/network/request/wx.request.html][wx.request]]，[[../../api/open-api/login/wx.login.html][wx.login]]
   等。这类 API 接口通常都接受一个 =Object=
   类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

   *Object 参数说明*





   | 参数名     | 类型       | 必填   | 说明                                               |
   |------------+------------+--------+----------------------------------------------------|
   | success    | function   | 否     | 接口调用成功的回调函数                             |
   | fail       | function   | 否     | 接口调用失败的回调函数                             |
   | complete   | function   | 否     | 接口调用结束的回调函数（调用成功、失败都会执行）   |
   | 其他       | Any        | -      | 接口定义的其他参数                                 |


 


   *回调函数的参数*

   =success=，=fail=，=complete= 函数调用时会传入一个 =Object=
   类型参数，包含以下字段：





   | 属性      | 类型     | 说明                                                                   |
   |-----------+----------+------------------------------------------------------------------------|
   | errMsg    | string   | 错误信息，如果调用成功返回 =${apiName}:ok=                             |
   | errCode   | number   | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 =0=。   |
   | 其他      | Any      | 接口返回的其他数据                                                     |


 


   异步 API 的执行结果需要通过 =Object=
   类型的参数中传入的对应回调函数获取。部分异步 API
   也会有返回值，可以用来实现更丰富的功能，如
   [[../../api/network/request/wx.request.html][wx.request]]，[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
   等。

   *代码示例*





   #+BEGIN_EXAMPLE
       wx.login({
         success(res) {
           console.log(res.code)
         }
       })
   #+END_EXAMPLE


 


***** [[index_u57.html#异步-API-返回-Promise][#]] 异步 API 返回 Promise


  
  

   基础库 [[../compatibility.html][2.10.2]] 版本起，异步 API 支持 callback
   & promise 两种调用方式。当接口参数 Object 对象中不包含
   success/fail/complete 时将默认返回
   promise，否则仍按回调方式执行，无返回值。

******* [[index_u57.html#注意事项][#]] 注意事项


  


   1. 部分接口如 =downloadFile=, =request=, =uploadFile=, =connectSocket=,
      =createCamera=（小游戏）本身就有返回值， 它们的 promisify
      需要开发者自行封装。
   2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail
      逻辑， 会报错提示 =Uncaught (in promise)=，开发者可通过 catch
      来进行捕获。
   3. [[../../api/base/app/app-event/wx.onUnhandledRejection.html][wx.onUnhandledRejection]]
      可以监听未处理的 Promise 拒绝事件。

   *代码示例*





   #+BEGIN_EXAMPLE
       // callback 形式调用
       wx.chooseImage({
         success(res) {
           console.log('res:', res)
         }
       })

       // promise 形式调用
       wx.chooseImage().then(res => console.log('res: ', res))
   #+END_EXAMPLE


 



 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html]]

   \\
   \\




 













   --------------


 










*** [[index_u61.html#视图层-View][#]] 视图层 View


  
  

  框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

  将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

  WXML(WeiXin Markup language) 用于描述页面的结构。

  WXS(WeiXin Script) 是小程序的一套脚本语言，结合
  =WXML=，可以构建出页面的结构。

  WXSS(WeiXin Style Sheet) 用于描述页面的样式。

  组件(Component)是视图的基本组成单元。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/]]

  \\
  \\




 













  --------------


 










**** [[index_u22.html#WXML][#]] WXML


  
  

   WXML（WeiXin Markup
   Language）是框架设计的一套标签语言，结合[[../../../component][基础组件]]、[[file:event.html][事件系统]]，可以构建出页面的结构。

   要完整了解 WXML 语法，请参考[[../../../reference/wxml][WXML 语法参考]]。

   用以下一些简单的例子来看看 WXML 具有什么能力：

****** [[index_u22.html#数据绑定][#]] 数据绑定


  
  





   #+BEGIN_EXAMPLE
       <!--wxml-->
       <view> {{message}} </view>
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // page.js
       Page({
         data: {
           message: 'Hello MINA!'
         }
       })
   #+END_EXAMPLE


 


****** [[index_u22.html#列表渲染][#]] 列表渲染


  
  





   #+BEGIN_EXAMPLE
       <!--wxml-->
       <view wx:for="{{array}}"> {{item}} </view>
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // page.js
       Page({
         data: {
           array: [1, 2, 3, 4, 5]
         }
       })
   #+END_EXAMPLE


 


****** [[index_u22.html#条件渲染][#]] 条件渲染


  
  





   #+BEGIN_EXAMPLE
       <!--wxml-->
       <view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
       <view wx:elif="{{view == 'APP'}}"> APP </view>
       <view wx:else="{{view == 'MINA'}}"> MINA </view>
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // page.js
       Page({
         data: {
           view: 'MINA'
         }
       })
   #+END_EXAMPLE


 


****** [[index_u22.html#模板][#]] 模板


  
  





   #+BEGIN_EXAMPLE
       <!--wxml-->
       <template name="staffName">
         <view>
           FirstName: {{firstName}}, LastName: {{lastName}}
         </view>
       </template>

       <template is="staffName" data="{{...staffA}}"></template>
       <template is="staffName" data="{{...staffB}}"></template>
       <template is="staffName" data="{{...staffC}}"></template>
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       // page.js
       Page({
         data: {
           staffA: {firstName: 'Hulk', lastName: 'Hu'},
           staffB: {firstName: 'Shang', lastName: 'You'},
           staffC: {firstName: 'Gideon', lastName: 'Lin'}
         }
       })
   #+END_EXAMPLE


 


   具体的能力以及使用方式在以下章节查看：

   [[../../../reference/wxml/data.html][数据绑定]]、[[../../../reference/wxml/list.html][列表渲染]]、[[../../../reference/wxml/conditional.html][条件渲染]]、[[../../../reference/wxml/template.html][模板]]、[[../../../reference/wxml/import.html][引用]]


 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/]]

   \\
   \\




 













   --------------


 










**** [[index_u96.html#WXSS][#]] WXSS


  
  

   WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

   WXSS 用来决定 WXML 的组件应该怎么显示。

   为了适应广大的前端开发者，WXSS 具有 CSS
   大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS
   进行了扩充以及修改。

   与 CSS 相比，WXSS 扩展的特性有：

   -  尺寸单位
   -  样式导入

****** [[index_u96.html#尺寸单位][#]] 尺寸单位


  
  

   -  rpx（responsive pixel）:
      可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6
      上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px =
      750 物理像素，1rpx = 0.5px = 1 物理像素。





   | 设备           | rpx 换算 px (屏幕宽度/750)   | px 换算 rpx (750/屏幕宽度)   |
   |----------------+----------------------------+----------------------------|
   | iPhone5        | 1rpx = 0.42px              | 1px = 2.34rpx              |
   | iPhone6        | 1rpx = 0.5px               | 1px = 2rpx                 |
   | iPhone6 Plus   | 1rpx = 0.552px             | 1px = 1.81rpx              |


 


   *建议：* 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。

   *注意：*
   在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

****** [[index_u96.html#样式导入][#]] 样式导入


  
  

   使用=@import=语句可以导入外联样式表，=@import=后跟需要导入的外联样式表的相对路径，用=;=表示语句结束。

   *示例代码：*





   #+BEGIN_EXAMPLE
       /** common.wxss **/
       .small-p {
         padding:5px;
       }
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       /** app.wxss **/
       @import "common.wxss";
       .middle-p {
         padding:15px;
       }
   #+END_EXAMPLE


 


****** [[index_u96.html#内联样式][#]] 内联样式


  
  

   框架组件上支持使用 style、class 属性来控制组件的样式。

   -  style：静态的样式统一写到 class 中。style
      接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style
      中，以免影响渲染速度。





   #+BEGIN_EXAMPLE
       <view style="color:{{color}};" />
   #+END_EXAMPLE


 


   -  class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上=.=，样式类名之间用空格分隔。





   #+BEGIN_EXAMPLE
       <view class="normal_view" />
   #+END_EXAMPLE


 


****** [[index_u96.html#选择器][#]] 选择器


  
  

   目前支持的选择器有：





   | 选择器             | 样例               | 样例描述                                         |
   |--------------------+--------------------+--------------------------------------------------|
   | .class             | =.intro=           | 选择所有拥有 class="intro" 的组件                |
   | #id                | =#firstname=       | 选择拥有 id="firstname" 的组件                   |
   | element            | =view=             | 选择所有 view 组件                               |
   | element, element   | =view, checkbox=   | 选择所有文档的 view 组件和所有的 checkbox 组件   |
   | ::after            | =view::after=      | 在 view 组件后边插入内容                         |
   | ::before           | =view::before=     | 在 view 组件前边插入内容                         |


 


****** [[index_u96.html#全局样式与局部样式][#]] 全局样式与局部样式


  
  

   定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss
   文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss
   中相同的选择器。


 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html]]

   \\
   \\




 













   --------------


 










**** [[index_u71.html#WXS][#]] WXS


  
  

   WXS（WeiXin Script）是小程序的一套脚本语言，结合
   =WXML=，可以构建出页面的结构。

****** [[index_u71.html#注意][#]] 注意


  
  

   1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
   2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript
      一致。
   3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他
      JavaScript 文件中定义的函数，也不能调用小程序提供的 API。
   4. WXS 函数不能作为组件的事件回调。
   5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript
      代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。

   以下是一些使用 WXS 的简单示例，要完整了解 WXS
   语法，请参考[[../../../reference/wxs][WXS 语法参考]]。

****** [[index_u71.html#页面渲染][#]] 页面渲染


  
  





   #+BEGIN_EXAMPLE
       <!--wxml-->
       <wxs module="m1">
       var msg = "hello world";

       module.exports.message = msg;
       </wxs>

       <view> {{m1.message}} </view>
   #+END_EXAMPLE


 


   页面输出：





   #+BEGIN_EXAMPLE
       hello world
   #+END_EXAMPLE


 


****** [[index_u71.html#数据处理][#]] 数据处理


  
  





   #+BEGIN_EXAMPLE
       // page.js
       Page({
         data: {
           array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
         }
       })
   #+END_EXAMPLE


 






   #+BEGIN_EXAMPLE
       <!--wxml-->
       <!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
       <wxs module="m1">
       var getMax = function(array) {
         var max = undefined;
         for (var i = 0; i < array.length; ++i) {
           max = max === undefined ?
             array[i] :
             (max >= array[i] ? max : array[i]);
         }
         return max;
       }

       module.exports.getMax = getMax;
       </wxs>

       <!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
       <view> {{m1.getMax(array)}} </view>
   #+END_EXAMPLE


 


   页面输出：





   #+BEGIN_EXAMPLE
       5
   #+END_EXAMPLE


 



 



 






   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/]]

   \\
   \\




 













   --------------


 










*** [[index_u100.html#事件][#]] 事件


  
  

**** [[index_u100.html#什么是事件][#]] 什么是事件


  
  

  -  事件是视图层到逻辑层的通讯方式。
  -  事件可以将用户的行为反馈到逻辑层进行处理。
  -  事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。
  -  事件对象可以携带额外信息，如 id, dataset, touches。

**** [[index_u100.html#事件的使用方式][#]] 事件的使用方式


  
  

  -  在组件中绑定一个事件处理函数。

  如=bindtap=，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。





  #+BEGIN_EXAMPLE
      <view id="tapTest" data-hi="Weixin" bindtap="tapName"> Click me! </view>
  #+END_EXAMPLE


 


  -  在相应的 Page 定义中写上相应的事件处理函数，参数是 event。





  #+BEGIN_EXAMPLE
      Page({
        tapName: function(event) {
          console.log(event)
        }
      })
  #+END_EXAMPLE


 


  -  可以看到 log 出来的信息大致如下：





  #+BEGIN_EXAMPLE
      {
        "type":"tap",
        "timeStamp":895,
        "target": {
          "id": "tapTest",
          "dataset":  {
            "hi":"Weixin"
          }
        },
        "currentTarget":  {
          "id": "tapTest",
          "dataset": {
            "hi":"Weixin"
          }
        },
        "detail": {
          "x":53,
          "y":14
        },
        "touches":[{
          "identifier":0,
          "pageX":53,
          "pageY":14,
          "clientX":53,
          "clientY":14
        }],
        "changedTouches":[{
          "identifier":0,
          "pageX":53,
          "pageY":14,
          "clientX":53,
          "clientY":14
        }]
      }
  #+END_EXAMPLE


 


**** [[index_u100.html#使用WXS函数响应事件][#]] 使用 WXS 函数响应事件


  
  

  #+BEGIN_QUOTE
    基础库 2.4.4
    开始支持，低版本需做[[../../compatibility.html][兼容处理]]。
  #+END_QUOTE

  从基础库版本=2.4.4=开始，支持使用 WXS 函数绑定事件，WXS 函数接受 2 个参数，第一个是 event，在原有的 event 的基础上加了=event.instance=对象，第二个参数是=ownerInstance=，和=event.instance=一样是一个=ComponentDescriptor=对象。具体使用如下：

  -  在组件中绑定和注册事件处理的 WXS 函数。





  #+BEGIN_EXAMPLE
      <wxs module="wxs" src="./test.wxs"></wxs>
      <view id="tapTest" data-hi="Weixin" bindtap="{{wxs.tapName}}"> Click me! </view>
      **注：绑定的WXS函数必须用{{}}括起来**
  #+END_EXAMPLE


 


  -  test.wxs 文件实现 tapName 函数





  #+BEGIN_EXAMPLE
      function tapName(event, ownerInstance) {
        console.log('tap Weixin', JSON.stringify(event))
      }
      module.exports = {
        tapName: tapName
      }
  #+END_EXAMPLE


 


  =ownerInstance=包含了一些方法，可以设置组件的样式和 class，具体包含的方法以及为什么要用 WXS 函数响应事件，请[[../interactive-animation.html][点击查看详情]]。

**** [[index_u100.html#事件详解][#]] 事件详解


  
  

***** [[index_u100.html#事件分类][#]] 事件分类


  
  

  事件分为冒泡事件和非冒泡事件：

  1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
  2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

  WXML 的冒泡事件列表：





  | 类型                 | 触发条件                                                                                 | 最低版本                               |
  |----------------------+------------------------------------------------------------------------------------------+----------------------------------------|
  | touchstart           | 手指触摸动作开始                                                                         |                                        |
  | touchmove            | 手指触摸后移动                                                                           |                                        |
  | touchcancel          | 手指触摸动作被打断，如来电提醒，弹窗                                                     |                                        |
  | touchend             | 手指触摸动作结束                                                                         |                                        |
  | tap                  | 手指触摸后马上离开                                                                       |                                        |
  | longpress            | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发   | [[../../compatibility.html][1.5.0]]    |
  | longtap              | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                                 |                                        |
  | transitionend        | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                |                                        |
  | animationstart       | 会在一个 WXSS animation 动画开始时触发                                                   |                                        |
  | animationiteration   | 会在一个 WXSS animation 一次迭代结束时触发                                               |                                        |
  | animationend         | 会在一个 WXSS animation 动画完成时触发                                                   |                                        |
  | touchforcechange     | 在支持 3D Touch 的 iPhone 设备，重按时会触发                                             | [[../../compatibility.html][1.9.90]]   |


 


  *注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如
  [[../../../component/form.html][form]]
  的=submit=事件，[[../../../component/input.html][input]]
  的=input=事件，[[../../../component/scroll-view.html][scroll-view]]
  的=scroll=事件，(详见各个[[../../../component][组件]])*

***** [[index_u100.html#普通事件绑定][#]] 普通事件绑定


  
  

  事件绑定的写法类似于组件的属性，如：





  #+BEGIN_EXAMPLE
      <view bindtap="handleTap">
          Click here!
      </view>
  #+END_EXAMPLE


 


  如果用户点击这个 view ，则页面的 =handleTap= 会被调用。

  事件绑定函数可以是一个数据绑定，如：





  #+BEGIN_EXAMPLE
      <view bindtap="{{ handlerName }}">
          Click here!
      </view>
  #+END_EXAMPLE


 


  此时，页面的 =this.data.handlerName=
  必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。

  自基础库版本 [[../../compatibility.html][1.5.0]]
  起，在大多数组件和自定义组件中， =bind=
  后可以紧跟一个冒号，其含义不变，如 =bind:tap= 。基础库版本
  [[../../compatibility.html][2.8.1]] 起，在所有组件中开始提供这个支持。

***** [[index_u100.html#绑定并阻止事件冒泡][#]] 绑定并阻止事件冒泡


  
  

  除 =bind= 外，也可以用 =catch= 来绑定事件。与 =bind= 不同， =catch=
  会阻止事件向上冒泡。

  例如在下边这个例子中，点击 inner view
  会先后调用=handleTap3=和=handleTap2=(因为 tap 事件会冒泡到 middle view，而
  middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view
  会触发=handleTap2=，点击 outer view 会触发=handleTap1=。





  #+BEGIN_EXAMPLE
      <view id="outer" bindtap="handleTap1">
        outer view
        <view id="middle" catchtap="handleTap2">
          middle view
          <view id="inner" bindtap="handleTap3">
            inner view
          </view>
        </view>
      </view>
  #+END_EXAMPLE


 


***** [[index_u100.html#互斥事件绑定][#]] 互斥事件绑定


  
  

  自基础库版本 [[../../compatibility.html][2.8.2]] 起，除 =bind= 和
  =catch= 外，还可以使用 =mut-bind= 来绑定事件。一个 =mut-bind=
  触发后，如果事件冒泡到其他节点上，其他节点上的 =mut-bind=
  绑定函数不会被触发，但 =bind= 绑定函数和 =catch= 绑定函数依旧会被触发。

  换而言之，所有 =mut-bind=
  是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 =bind= 和
  =catch= 的绑定效果。

  例如在下边这个例子中，点击 inner view 会先后调用 =handleTap3= 和
  =handleTap2= ，点击 middle view 会调用 =handleTap2= 和 =handleTap1= 。





  #+BEGIN_EXAMPLE
      <view id="outer" mut-bind:tap="handleTap1">
        outer view
        <view id="middle" bindtap="handleTap2">
          middle view
          <view id="inner" mut-bind:tap="handleTap3">
            inner view
          </view>
        </view>
      </view>
  #+END_EXAMPLE


 


***** [[index_u100.html#事件的捕获阶段][#]] 事件的捕获阶段


  
  

  自基础库版本 [[../../compatibility.html][1.5.0]]
  起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用=capture-bind=、=capture-catch=关键字，后者将中断捕获阶段和取消冒泡阶段。

  在下面的代码中，点击 inner view
  会先后调用=handleTap2=、=handleTap4=、=handleTap3=、=handleTap1=。





  #+BEGIN_EXAMPLE
      <view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
        outer view
        <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
          inner view
        </view>
      </view>
  #+END_EXAMPLE


 


  如果将上面代码中的第一个=capture-bind=改为=capture-catch=，将只触发=handleTap2=。





  #+BEGIN_EXAMPLE
      <view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2">
        outer view
        <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
          inner view
        </view>
      </view>
  #+END_EXAMPLE


 


***** [[index_u100.html#事件对象][#]] 事件对象


  
  

  如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

  *BaseEvent 基础事件对象属性列表：*





  | 属性                                               | 类型      | 说明                             | 基础库版本                            |
  |----------------------------------------------------+-----------+----------------------------------+---------------------------------------|
  | [[index_u100.html#type][type]]                     | String    | 事件类型                         |                                       |
  | [[index_u100.html#timeStamp][timeStamp]]           | Integer   | 事件生成时的时间戳               |                                       |
  | [[index_u100.html#target][target]]                 | Object    | 触发事件的组件的一些属性值集合   |                                       |
  | [[index_u100.html#currenttarget][currentTarget]]   | Object    | 当前组件的一些属性值集合         |                                       |
  | [[index_u100.html#mark][mark]]                     | Object    | 事件标记数据                     | [[../../compatibility.html][2.7.1]]   |


 


  *CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：*





  | 属性                                 | 类型     | 说明         |
  |--------------------------------------+----------+--------------|
  | [[index_u100.html#detail][detail]]   | Object   | 额外的信息   |


 


  *TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：*





  | 属性                                                 | 类型    | 说明                                           |
  |------------------------------------------------------+---------+------------------------------------------------|
  | [[index_u100.html#touches][touches]]                 | Array   | 触摸事件，当前停留在屏幕中的触摸点信息的数组   |
  | [[index_u100.html#changedTouches][changedTouches]]   | Array   | 触摸事件，当前变化的触摸点信息的数组           |


 


  *特殊事件： [[../../../component/canvas.html][canvas]]
  中的触摸事件不可冒泡，所以没有 currentTarget。*

***** [[index_u100.html#type][#]] type


  
  

  代表事件的类型。

***** [[index_u100.html#timeStamp][#]] timeStamp


  
  

  页面打开到触发事件所经过的毫秒数。

***** [[index_u100.html#target][#]] target


  
  

  触发事件的源组件。





  | 属性                                   | 类型     | 说明                                              |
  |----------------------------------------+----------+---------------------------------------------------|
  | id                                     | String   | 事件源组件的 id                                    |
  | [[index_u100.html#dataset][dataset]]   | Object   | 事件源组件上由=data-=开头的自定义属性组成的集合   |


 


***** [[index_u100.html#currentTarget][#]] currentTarget


  
  

  事件绑定的当前组件。





  | 属性                                   | 类型     | 说明                                            |
  |----------------------------------------+----------+-------------------------------------------------|
  | id                                     | String   | 当前组件的 id                                    |
  | [[index_u100.html#dataset][dataset]]   | Object   | 当前组件上由=data-=开头的自定义属性组成的集合   |


 


  *说明： target 和 currentTarget 可以参考上例中，点击 inner view
  时，=handleTap3= 收到的事件对象 target 和 currentTarget 都是 inner，而
  =handleTap2= 收到的事件对象 target 就是 inner，currentTarget 就是
  middle。*

***** [[index_u100.html#dataset][#]] dataset


  
  

  在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。

  在 WXML 中，这些自定义数据以 =data-= 开头，多个单词由连字符 =-=
  连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：

  -  =data-element-type= ，最终会呈现为
     =event.currentTarget.dataset.elementType= ；
  -  =data-elementType= ，最终会呈现为
     =event.currentTarget.dataset.elementtype= 。

  *示例：*





  #+BEGIN_EXAMPLE
      <view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"> DataSet Test </view>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Page({
        bindViewTap:function(event){
          event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法
          event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写
        }
      })
  #+END_EXAMPLE


 


***** [[index_u100.html#mark][#]] mark


  
  

  在基础库版本 [[../../compatibility.html][2.7.1]] 以上，可以使用 =mark=
  来识别具体触发事件的 target 节点。此外， =mark=
  还可以用于承载一些自定义数据（类似于 =dataset= ）。

  当事件触发时，事件冒泡路径上所有的 =mark=
  会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 =mark= 。）

  *代码示例：*

  [[https://developers.weixin.qq.com/s/boDQoKmu7M7G][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <view mark:myMark="last" bindtap="bindViewTap">
        <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮</button>
      </view>
  #+END_EXAMPLE


 


  在上述 WXML 中，如果按钮被点击，将触发 =bindViewTap= 和 =bindButtonTap=
  两个事件，事件携带的 =event.mark= 将包含 =myMark= 和 =anotherMark=
  两项。





  #+BEGIN_EXAMPLE
      Page({
        bindViewTap: function(e) {
          e.mark.myMark === "last" // true
          e.mark.anotherMark === "leaf" // true
        }
      })
  #+END_EXAMPLE


 


  =mark= 和 =dataset= 很相似，主要区别在于： =mark=
  会包含从触发事件的节点到根节点上所有的 =mark:= 属性值；而 =dataset=
  仅包含一个节点的 =data-= 属性值。

  细节注意事项：

  -  如果存在同名的 =mark= ，父节点的 =mark= 会被子节点覆盖。
  -  在自定义组件中接收事件时， =mark= 不包含自定义组件外的节点的 =mark=
     。
  -  不同于 =dataset= ，节点的 =mark= 不会做连字符和大小写转换。

***** [[index_u100.html#touches][#]] touches


  
  

  touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的
  touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。

****** [[index_u100.html#Touch-对象][#]] Touch 对象


  






  | 属性               | 类型     | 说明                                                                   |
  |--------------------+----------+------------------------------------------------------------------------|
  | identifier         | Number   | 触摸点的标识符                                                         |
  | pageX, pageY       | Number   | 距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴        |
  | clientX, clientY   | Number   | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴   |


 


****** [[index_u100.html#CanvasTouch-对象][#]] CanvasTouch 对象


  
 





  | 属性         | 类型     | 说明                                                                     | 特殊说明   |
  |--------------+----------+--------------------------------------------------------------------------+------------|
  | identifier   | Number   | 触摸点的标识符                                                           |            |
  | x, y         | Number   | 距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为 X 轴，纵向为 Y 轴   |            |


 


***** [[index_u100.html#changedTouches][#]] changedTouches


  
 

  changedTouches 数据格式同 touches。
  表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

***** [[index_u100.html#detail][#]] detail


  
 

  自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见[[../../../component][组件]]定义中各个事件的定义。

  点击事件的=detail= 带有的 x, y 同 pageX, pageY
  代表距离文档左上角的距离。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html]]

  \\
  \\




 













  --------------


 










**** [[index_u52.html#WXS响应事件][#]] WXS 响应事件


  
 

  #+BEGIN_QUOTE
    基础库 2.4.4 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

***** [[index_u52.html#背景][#]] 背景


  
 

  有频繁用户交互的效果在小程序上表现是比较卡顿的，例如页面有 2 个元素 A 和
  B，用户在 A 上做 touchmove 手势，要求 B
  也跟随移动，[[../../component/movable-view.html][movable-view]]
  就是一个典型的例子。一次 touchmove 事件的响应过程为：

  a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）

  b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B
  的位置

  一次 touchmove 的响应需要经过 2
  次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 setData
  渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。

***** [[index_u52.html#实现方案][#]] 实现方案


  
 

  本方案基本的思路是减少通信的次数，让事件在视图层（Webview）响应。小程序的框架分为视图层（Webview）和逻辑层（App
  Service），这样分层的目的是管控，开发者的代码只能运行在逻辑层（App
  Service），而这个思路就必须要让开发者的代码运行在视图层（Webview），如下图所示的流程：

  [[file:feed_0/article_45/images/img1_u3.png]]

  使用 [[file:wxs][WXS]]
  函数用来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件。WXS
  函数的除了纯逻辑的运算，还可以通过封装好的=ComponentDescriptor=
  实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class
  足够了。WXS 函数的例子如下：





  #+BEGIN_EXAMPLE
      var wxsFunction = function(event, ownerInstance) {
          var instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例
          instance.setStyle({
              "font-size": "14px" // 支持rpx
          })
          instance.getDataset()
          instance.setClass(className)
          // ...
          return false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault
      }
  #+END_EXAMPLE


 


  其中入参 =event= 是小程序[[file:wxml/event.html][事件对象]]基础上多了
  =event.instance= 来表示触发事件的组件的 =ComponentDescriptor=
  实例。=ownerInstance= 表示的是触发事件的组件所在的组件的
  =ComponentDescriptor=
  实例，如果触发事件的组件是在页面内的，=ownerInstance= 表示的是页面实例。

  =ComponentDescriptor=的定义如下：





  | 方法                             | 参数                             | 描述                                                                                                 | 最低版本                            |
  |----------------------------------+----------------------------------+------------------------------------------------------------------------------------------------------+-------------------------------------|
  | selectComponent                  | selector 对象                     | 返回组件的 =ComponentDescriptor= 实例。                                                              |                                     |
  | selectAllComponents              | selector 对象数组                 | 返回组件的 =ComponentDescriptor= 实例数组。                                                          |                                     |
  | setStyle                         | Object/string                    | 设置组件样式，支持=rpx=。设置的样式优先级比组件 wxml 里面定义的样式高。不能设置最顶层页面的样式。    |                                     |
  | addClass/removeClass/ hasClass   | string                           | 设置组件的 class。设置的 class 优先级比组件 wxml 里面定义的 class 高。不能设置最顶层页面的 class。   |                                     |
  | getDataset                       | 无                               | 返回当前组件/页面的 dataset 对象                                                                     |                                     |
  | callMethod                       | (funcName:string, args:object)   | 调用当前组件/页面在逻辑层（App Service）定义的函数。funcName 表示函数名称，args 表示函数的参数。       |                                     |
  | requestAnimationFrame            | Function                         | 和原生 =requestAnimationFrame= 一样。用于设置动画。                                                  |                                     |
  | getState                         | 无                               | 返回一个 object 对象，当有局部变量需要存储起来后续使用的时候用这个方法。                               |                                     |
  | triggerEvent                     | (eventName, detail)              | 和组件的[[../custom-component/events.html][triggerEvent]]一致。                                      |                                     |
  | getComputedStyle                 | Array.<string>                   | 参数与 [[../../api/wxml/NodesRef.fields.html][SelectorQuery]] 的 =computedStyle= 一致。              | [[../compatibility.html][2.11.2]]   |


 


  WXS
  运行在视图层（Webview），里面的逻辑毕竟能做的事件比较少，需要有一个机制和逻辑层（App
  Service）开发者的代码通信，上面的 =callMethod= 是 WXS
  里面调用逻辑层（App Service）开发者的代码的方法，而 =WxsPropObserver=
  是逻辑层（App Service）开发者的代码调用 WXS 逻辑的机制。

***** [[index_u52.html#使用方法][#]] 使用方法


  
 

  -  WXML 定义事件：





  #+BEGIN_EXAMPLE
      <wxs module="test" src="./test.wxs"></wxs>
      <view change:prop="{{test.propObserver}}" prop="{{propValue}}" bindtouchmove="{{test.touchmove}}" class="movable"></view>
  #+END_EXAMPLE


 


  上面的=change:prop=（属性前面带 change:前缀）是在 prop
  属性被设置的时候触发 WXS 函数，值必须用={{}}=括起来。类似 Component
  定义的 properties 里面的 observer
  属性，在=setData({propValue: newValue})=调用之后会触发。

  *注意*：WXS 函数必须用={{}}=括起来。当 prop 的值被设置 WXS
  函数就会触发，而不只是值发生改变，所以在页面初始化的时候会调用一次=WxsPropObserver=的函数。

  -  WXS 文件=test.wxs=里面定义并导出事件处理函数和属性改变触发的函数：





  #+BEGIN_EXAMPLE
      module.exports = {
          touchmove: function(event, instance) {
              console.log('log event', JSON.stringify(event))
          },
          propObserver: function(newValue, oldValue, ownerInstance, instance) {
              console.log('prop observer', newValue, oldValue)
          }
      }
  #+END_EXAMPLE


 


  更多示例请查看[[https://developers.weixin.qq.com/s/L1G0Dkmc7G8a][在开发者工具中预览效果<<>>]]

***** [[index_u52.html#Tips][#]] Tips


  
 

  1. 目前还不支持[[../../component/native-component.html][原生组件]]的事件、[[../../component/input.html][input]]和[[../../component/textarea.html][textarea]]组件的
     bindinput 事件
  2. 1.02.1901170 及以后版本的开发者工具上支持交互动画，最低版本基础库是 2.4.4
  3. 目前在 WXS 函数里面仅支持 console.log 方式打日志定位问题，注意连续的重复日志会被过滤掉。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html]]

  \\
  \\




 













  --------------


 










*** [[index_u5.html#简易双向绑定][#]] 简易双向绑定


  
 

  #+BEGIN_QUOTE
    基础库 2.9.3 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

**** [[index_u5.html#双向绑定语法][#]] 双向绑定语法


  
 

  在 WXML 中，普通的属性的绑定是单向的。例如：





  #+BEGIN_EXAMPLE
      <input value="{{value}}" />
  #+END_EXAMPLE


 


  如果使用 =this.setData({ value: 'leaf' })= 来更新 =value=
  ，=this.data.value= 和输入框的中显示的值都会被更新为 =leaf=
  ；但如果用户修改了输入框里的值，却不会同时改变 =this.data.value= 。

  如果需要在用户输入的同时改变 =this.data.value=
  ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 =model:= 前缀：





  #+BEGIN_EXAMPLE
      <input model:value="{{value}}" />
  #+END_EXAMPLE


 


  这样，如果输入框的值被改变了， =this.data.value= 也会同时改变。同时，
  WXML 中所有绑定了 =value= 的位置也会被一同更新，
  [[../custom-component/observer.html][数据监听器]] 也会被正常触发。

  [[https://developers.weixin.qq.com/s/8jXvobmV7vcj][在开发者工具中预览效果<<>>]]

  用于双向绑定的表达式有如下限制：

  1. 只能是一个单一字段的绑定，如





  #+BEGIN_EXAMPLE
      <input model:value="值为 {{value}}" />
      <input model:value="{{ a + b }}" />
  #+END_EXAMPLE


 


  都是非法的；

  2. 目前，尚不能 data 路径，如





  #+BEGIN_EXAMPLE
      <input model:value="{{ a.b }}" />
  #+END_EXAMPLE


 


  这样的表达式目前暂不支持。

**** [[index_u5.html#在自定义组件中传递双向绑定][#]]
  在自定义组件中传递双向绑定


  
 

  双向绑定同样可以使用在自定义组件上。如下的自定义组件：





  #+BEGIN_EXAMPLE
      // custom-component.js
      Component({
        properties: {
          myValue: String
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- custom-component.wxml -->
      <input model:value="{{myValue}}" />
  #+END_EXAMPLE


 


  这个自定义组件将自身的 =myValue= 属性双向绑定到了组件内输入框的 =value=
  属性上。这样，如果页面这样使用这个组件：





  #+BEGIN_EXAMPLE
      <custom-component model:my-value="{{pageValue}}" />
  #+END_EXAMPLE


 


  当输入框的值变更时，自定义组件的 =myValue= 属性会同时变更，这样，页面的
  =this.data.pageValue= 也会同时变更，页面 WXML 中所有绑定了 =pageValue=
  的位置也会被一同更新。

**** [[index_u5.html#在自定义组件中触发双向绑定更新][#]]
  在自定义组件中触发双向绑定更新


  
 

  自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData
  设置自身的属性。例如：





  #+BEGIN_EXAMPLE
      // custom-component.js
      Component({
        properties: {
          myValue: String
        },
        methods: {
          update: function() {
            // 更新 myValue
            this.setData({
              myValue: 'leaf'
            })
          }
        }
      })
  #+END_EXAMPLE


 


  如果页面这样使用这个组件：





  #+BEGIN_EXAMPLE
      <custom-component model:my-value="{{pageValue}}" />
  #+END_EXAMPLE


 


  当组件使用 =setData= 更新 =myValue= 时，页面的 =this.data.pageValue=
  也会同时变更，页面 WXML 中所有绑定了 =pageValue= 的位置也会被一同更新。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/two-way-bindings.html]]

  \\
  \\




 













  --------------


 










*** [[index_u56.html#基础组件][#]] 基础组件


  
 

  框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考[[../../component][组件文档]]。

  什么是组件：

  -  组件是视图层的基本组成单元。
  -  组件自带一些功能与微信风格一致的样式。
  -  一个组件通常包括 =开始标签= 和 =结束标签=，=属性=
     用来修饰这个组件，=内容= 在两个标签之内。





  #+BEGIN_EXAMPLE
      <tagname property="value">
      Content goes here ...
      </tagname>
  #+END_EXAMPLE


 


  *注意：所有组件与属性都是小写，以连字符=-=连接*

***** [[index_u56.html#属性类型][#]] 属性类型


  
 





  | 类型           | 描述             | 注解                                                                                         |
  |----------------+------------------+----------------------------------------------------------------------------------------------|
  | Boolean        | 布尔值           | 组件写上该属性，不管是什么值都被当作 =true=；只有组件上没有该属性时，属性值才为=false=。\\   |
  |                |                  | 如果属性值为变量，变量的值会被转换为 Boolean 类型                                              |
  | Number         | 数字             | =1=, =2.5=                                                                                   |
  | String         | 字符串           | ="string"=                                                                                   |
  | Array          | 数组             | =[ 1, "string" ]=                                                                            |
  | Object         | 对象             | ={ key: value }=                                                                             |
  | EventHandler   | 事件处理函数名   | ="handlerName"= 是 [[../app-service/page.html][Page]] 中定义的事件处理函数名                 |
  | Any            | 任意属性         |                                                                                              |


 


***** [[index_u56.html#公共属性][#]] 公共属性


  
 

  所有组件都有以下属性：





  | 属性名           | 类型           | 描述             | 注解                                       |
  |------------------+----------------+------------------+--------------------------------------------|
  | id               | String         | 组件的唯一标示   | 保持整个页面唯一                           |
  | class            | String         | 组件的样式类     | 在对应的 WXSS 中定义的样式类               |
  | style            | String         | 组件的内联样式   | 可以动态设置的内联样式                     |
  | hidden           | Boolean        | 组件是否显示     | 所有组件默认显示                           |
  | data-*           | Any            | 自定义属性       | 组件上触发的事件时，会发送给事件处理函数   |
  | bind* / catch*   | EventHandler   | 组件的事件       | 详见[[file:wxml/event.html][事件]]         |


 


***** [[index_u56.html#特殊属性][#]] 特殊属性


  
 

  几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个[[../../component][组件]]的定义。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/component.html]]

  \\
  \\




 













  --------------


 










*** [[index_u68.html#获取界面上的节点信息][#]] 获取界面上的节点信息


  
 

**** [[index_u68.html#WXML节点信息][#]] WXML 节点信息


  
 

  [[../../api/wxml/wx.createSelectorQuery.html][节点信息查询 API]]
  可以用于获取节点属性、样式、在界面上的位置等信息。

  最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

  *示例代码：*





  #+BEGIN_EXAMPLE
      const query = wx.createSelectorQuery()
      query.select('#the-id').boundingClientRect(function(res){
        res.top // #the-id 节点的上边界坐标（相对于显示区域）
      })
      query.selectViewport().scrollOffset(function(res){
        res.scrollTop // 显示区域的竖直滚动位置
      })
      query.exec()
  #+END_EXAMPLE


 


  上述示例中， =#the-id= 是一个节点选择器，与 CSS
  的选择器相近但略有区别，请参见
  [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]]
  的相关说明。

  在自定义组件或包含自定义组件的页面中，推荐使用
  =this.createSelectorQuery= 来代替
  [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
  ，这样可以确保在正确的范围内选择节点。

**** [[index_u68.html#WXML节点布局相交状态][#]] WXML 节点布局相交状态


  
 

  [[../../api/wxml/wx.createIntersectionObserver.html][节点布局相交状态
  API]]
  可用于监听两个或多个组件节点在布局位置上的相交状态。这一组 API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

  这一组 API 涉及的主要概念如下。

  -  参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的
     *交集* 作为参照区域。页面显示区域也可作为参照区域之一。
  -  目标节点：监听的目标，默认只能是一个节点（使用 =selectAll=
     选项时，可以同时监听多个节点）。
  -  相交区域：目标节点的布局区域与参照区域的相交区域。
  -  相交比例：相交区域占参照区域的比例。
  -  阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

  以下示例代码可以在目标节点（用选择器 =.target-class=
  指定）每次进入或离开页面显示区域时，触发回调函数。

  *示例代码：*





  #+BEGIN_EXAMPLE
      Page({
        onLoad: function(){
          wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
            res.id // 目标节点 id
            res.dataset // 目标节点 dataset
            res.intersectionRatio // 相交区域占目标节点的布局区域的比例
            res.intersectionRect // 相交区域
            res.intersectionRect.left // 相交区域的左边界坐标
            res.intersectionRect.top // 相交区域的上边界坐标
            res.intersectionRect.width // 相交区域的宽度
            res.intersectionRect.height // 相交区域的高度
          })
        }
      })
  #+END_EXAMPLE


 


  以下示例代码可以在目标节点（用选择器 =.target-class=
  指定）与参照节点（用选择器 =.relative-class=
  指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的 20%和 50%时，触发回调函数。

  *示例代码：*





  #+BEGIN_EXAMPLE
      Page({
        onLoad: function(){
          wx.createIntersectionObserver(this, {
            thresholds: [0.2, 0.5]
          }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
            res.intersectionRatio // 相交区域占目标节点的布局区域的比例
            res.intersectionRect // 相交区域
            res.intersectionRect.left // 相交区域的左边界坐标
            res.intersectionRect.top // 相交区域的上边界坐标
            res.intersectionRect.width // 相交区域的宽度
            res.intersectionRect.height // 相交区域的高度
          })
        }
      })
  #+END_EXAMPLE


 


  注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是“布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中
  overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。

  在自定义组件或包含自定义组件的页面中，推荐使用
  =this.createIntersectionObserver= 来代替
  [[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]
  ，这样可以确保在正确的范围内选择节点。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html]]

  \\
  \\




 













  --------------


 










*** [[index_u26.html#响应显示区域变化][#]] 响应显示区域变化


  
 

**** [[index_u26.html#显示区域尺寸][#]] 显示区域尺寸


  
 

  显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

***** [[index_u26.html#在手机上启用屏幕旋转支持][#]]
  在手机上启用屏幕旋转支持


  
 

  从小程序基础库版本 [[../compatibility.html][2.4.0]]
  开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在
  =app.json= 的 =window= 段中设置 ="pageOrientation": "auto"= ，或在页面
  json 文件中配置 ="pageOrientation": "auto"= 。

  以下是在单个页面 json 文件中启用屏幕旋转的示例。

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "pageOrientation": "auto"
      }
  #+END_EXAMPLE


 


  如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

  从小程序基础库版本 [[../compatibility.html][2.5.0]] 开始，
  =pageOrientation= 还可以被设置为 =landscape= ，表示固定为横屏显示。

***** [[index_u26.html#在-iPad-上启用屏幕旋转支持][#]] 在 iPad
  上启用屏幕旋转支持


  
 

  从小程序基础库版本 [[../compatibility.html][2.3.0]] 开始，在 iPad
  上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在
  =app.json= 中添加 ="resizable": true= 。

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "resizable": true
      }
  #+END_EXAMPLE


 


  如果小程序添加了上述声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。注意：在
  iPad 上不能单独配置某个页面是否支持屏幕旋转。

**** [[index_u26.html#Media-Query][#]] Media Query


  
 

  有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 media
  query 来解决大多数问题。

  *代码示例：*





  #+BEGIN_EXAMPLE
      .my-class {
        width: 40px;
      }

      @media (min-width: 480px) {
        /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
        .my-class {
          width: 200px;
        }
      }
  #+END_EXAMPLE


 


  在 WXML 中，可以使用 [[../../component/match-media.html][match-media]]
  组件来根据 media query 匹配状态展示、隐藏节点。

  此外，可以在页面或者自定义组件 JS 中使用
  =this.createMediaQueryObserver()= 方法来创建一个
  [[../../api/wxml/MediaQueryObserver.html][=MediaQueryObserver=]]
  对象，用于监听指定的 media query 的匹配状态。

  [[https://developers.weixin.qq.com/s/TtFaFjmb7aiy][在开发者工具中预览效果<<>>]]

**** [[index_u26.html#屏幕旋转事件][#]] 屏幕旋转事件


  
 

  有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js
  作为辅助。

  在 js 中读取页面的显示区域尺寸，可以使用
  [[../../api/wxml/SelectorQuery.selectViewport.html][selectorQuery.selectViewport]]
  。

  页面尺寸发生改变的事件，可以使用页面的 =onResize=
  来监听。对于自定义组件，可以使用 resize
  生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本
  [[../compatibility.html][2.4.0]] 开始支持。）

  *代码示例：*





  #+BEGIN_EXAMPLE
      Page({
        onResize(res) {
          res.size.windowWidth // 新的显示区域宽度
          res.size.windowHeight // 新的显示区域高度
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Component({
        pageLifetimes: {
          resize(res) {
            res.size.windowWidth // 新的显示区域宽度
            res.size.windowHeight // 新的显示区域高度
          }
        }
      })
  #+END_EXAMPLE


 


  此外，还可以使用
  [[../../api/ui/window/wx.onWindowResize.html][wx.onWindowResize]]
  来监听（但这不是推荐的方式）。

  *Bug & tips:*

  -  Bug： Android 微信版本 6.7.3 中， =live-pusher=
     组件在屏幕旋转时方向异常。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html]]

  \\
  \\




 













  --------------


 










*** [[index_u59.html#动画][#]] 动画


  
 

**** [[index_u59.html#界面动画的常见方式][#]] 界面动画的常见方式


  
 

  在小程序中，通常可以使用
  [[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions][CSS
  渐变<<>>]] 和
  [[https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations][CSS
  动画<<>>]] 来创建简易的界面动画。

  [[https://developers.weixin.qq.com/s/oHKxDPm47h5k][在开发者工具中预览效果<<>>]]

  动画过程中，可以使用 =bindtransitionend= =bindanimationstart=
  =bindanimationiteration= =bindanimationend= 来监听动画事件。





  | 事件名               | 含义                                                                                                 |
  |----------------------+------------------------------------------------------------------------------------------------------|
  | transitionend        | CSS 渐变结束或 [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]] 结束一个阶段   |
  | animationstart       | CSS 动画开始                                                                                         |
  | animationiteration   | CSS 动画结束一个阶段                                                                                 |
  | animationend         | CSS 动画结束                                                                                         |


 


  注意：这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。

  同时，还可以使用
  [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]
  接口来动态创建简易的动画效果。（新版小程序基础库中推荐使用下述的关键帧动画接口代替。）

**** [[index_u59.html#关键帧动画][#]] 关键帧动画


  
 

  #+BEGIN_QUOTE
    基础库 2.9.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  从小程序基础库 [[../compatibility.html][2.9.0]]
  开始支持一种更友好的动画创建方式，用于代替旧的
  [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]
  。它具有更好的性能和更可控的接口。

  在页面或自定义组件中，当需要进行关键帧动画时，可以使用 =this.animate=
  接口：





  #+BEGIN_EXAMPLE
      this.animate(selector, keyframes, duration, callback)
  #+END_EXAMPLE


 


  *参数说明*





  | 属性        | 类型       | 默认值   | 必填   | 说明                                                                                           |
  |-------------+------------+----------+--------+------------------------------------------------------------------------------------------------|
  | selector    | String     |          | 是     | 选择器（同 [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]] 的选择器格式）   |
  | keyframes   | Array      |          | 是     | 关键帧信息                                                                                     |
  | duration    | Number     |          | 是     | 动画持续时长（毫秒为单位）                                                                     |
  | callback    | function   |          | 否     | 动画完成后的回调函数                                                                           |


 


  *keyframes 中对象的结构*





  | 属性              | 类型            | 默认值   | 必填                                | 说明                                      |
  |-------------------+-----------------+----------+-------------------------------------+-------------------------------------------|
  | offset            | Number          |          | 否                                  | 关键帧的偏移，范围[0-1]                   |
  | ease              | String          | linear   | 否                                  | 动画缓动函数                              |
  | transformOrigin   | String          | 否       | 基点位置，即 CSS transform-origin   |                                           |
  | backgroundColor   | String          |          | 否                                  | 背景颜色，即 CSS background-color         |
  | bottom            | Number/String   |          | 否                                  | 底边位置，即 CSS bottom                   |
  | height            | Number/String   |          | 否                                  | 高度，即 CSS height                       |
  | left              | Number/String   |          | 否                                  | 左边位置，即 CSS left                     |
  | width             | Number/String   |          | 否                                  | 宽度，即 CSS width                        |
  | opacity           | Number          |          | 否                                  | 不透明度，即 CSS opacity                  |
  | right             | Number          |          | 否                                  | 右边位置，即 CSS right                    |
  | top               | Number/String   |          | 否                                  | 顶边位置，即 CSS top                      |
  | matrix            | Array           |          | 否                                  | 变换矩阵，即 CSS transform matrix         |
  | matrix3d          | Array           |          | 否                                  | 三维变换矩阵，即 CSS transform matrix3d   |
  | rotate            | Number          |          | 否                                  | 旋转，即 CSS transform rotate             |
  | rotate3d          | Array           |          | 否                                  | 三维旋转，即 CSS transform rotate3d       |
  | rotateX           | Number          |          | 否                                  | X 方向旋转，即 CSS transform rotateX      |
  | rotateY           | Number          |          | 否                                  | Y 方向旋转，即 CSS transform rotateY      |
  | rotateZ           | Number          |          | 否                                  | Z 方向旋转，即 CSS transform rotateZ      |
  | scale             | Array           |          | 否                                  | 缩放，即 CSS transform scale              |
  | scale3d           | Array           |          | 否                                  | 三维缩放，即 CSS transform scale3d        |
  | scaleX            | Number          |          | 否                                  | X 方向缩放，即 CSS transform scaleX       |
  | scaleY            | Number          |          | 否                                  | Y 方向缩放，即 CSS transform scaleY       |
  | scaleZ            | Number          |          | 否                                  | Z 方向缩放，即 CSS transform scaleZ       |
  | skew              | Array           |          | 否                                  | 倾斜，即 CSS transform skew               |
  | skewX             | Number          |          | 否                                  | X 方向倾斜，即 CSS transform skewX        |
  | skewY             | Number          |          | 否                                  | Y 方向倾斜，即 CSS transform skewY        |
  | translate         | Array           |          | 否                                  | 位移，即 CSS transform translate          |
  | translate3d       | Array           |          | 否                                  | 三维位移，即 CSS transform translate3d    |
  | translateX        | Number          |          | 否                                  | X 方向位移，即 CSS transform translateX   |
  | translateY        | Number          |          | 否                                  | Y 方向位移，即 CSS transform translateY   |
  | translateZ        | Number          |          | 否                                  | Z 方向位移，即 CSS transform translateZ   |


 


**** [[index_u59.html#示例代码][#]] 示例代码


  
 

  [[https://developers.weixin.qq.com/s/P73kJ7mi7UcA][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
        this.animate('#container', [
          { opacity: 1.0, rotate: 0, backgroundColor: '#FF0000' },
          { opacity: 0.5, rotate: 45, backgroundColor: '#00FF00'},
          { opacity: 0.0, rotate: 90, backgroundColor: '#FF0000' },
          ], 5000, function () {
            this.clearAnimation('#container', { opacity: true, rotate: true }, function () {
              console.log("清除了#container上的opacity和rotate属性")
            })
        }.bind(this))

        this.animate('.block', [
          { scale: [1, 1], rotate: 0, ease: 'ease-out'  },
          { scale: [1.5, 1.5], rotate: 45, ease: 'ease-in', offset: 0.9},
          { scale: [2, 2], rotate: 90 },
        ], 5000, function () {
          this.clearAnimation('.block', function () {
            console.log("清除了.block上的所有动画属性")
          })
        }.bind(this))
  #+END_EXAMPLE


 


  调用 animate API
  后会在节点上新增一些样式属性覆盖掉原有的对应样式。如果需要清除这些样式，可在该节点上的动画全部执行完毕后使用
  =this.clearAnimation= 清除这些属性。





  #+BEGIN_EXAMPLE
      this.clearAnimation(selector, options, callback)
  #+END_EXAMPLE


 


  *参数说明*





  | 属性       | 类型       | 默认值   | 必填   | 说明                                                                                           |
  |------------+------------+----------+--------+------------------------------------------------------------------------------------------------|
  | selector   | String     |          | 是     | 选择器（同 [[../../api/wxml/SelectorQuery.select.html][SelectorQuery.select]] 的选择器格式）   |
  | options    | Object     |          | 否     | 需要清除的属性，不填写则全部清除                                                               |
  | callback   | Function   |          | 否     | 清除完成后的回调函数                                                                           |


 


**** [[index_u59.html#滚动驱动的动画][#]] 滚动驱动的动画


  
 

  我们发现，根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库
  [[../compatibility.html][2.9.0]] 开始支持一种由滚动驱动的动画机制。

  基于上述的关键帧动画接口，新增一个 =ScrollTimeline=
  的参数，用来绑定滚动元素（目前只支持 scroll-view）。接口定义如下：





  #+BEGIN_EXAMPLE
      this.animate(selector, keyframes, duration, ScrollTimeline)
  #+END_EXAMPLE


 


  *ScrollTimeline 中对象的结构*





  | 属性                | 类型     | 默认值     | 必填   | 说明                                                                                              |
  |---------------------+----------+------------+--------+---------------------------------------------------------------------------------------------------|
  | scrollSource        | String   |            | 是     | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度                          |
  | orientation         | String   | vertical   | 否     | 指定滚动的方向。有效值为 horizontal 或 vertical                                                   |
  | startScrollOffset   | Number   |            | 是     | 指定开始驱动动画进度的滚动偏移量，单位 px                                                         |
  | endScrollOffset     | Number   |            | 是     | 指定停止驱动动画进度的滚动偏移量，单位 px                                                         |
  | timeRange           | Number   |            | 是     | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms   |


 


**** [[index_u59.html#示例代码-2][#]] 示例代码


  
 

  [[https://developers.weixin.qq.com/s/994o8jmY7FcQ][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
        this.animate('.avatar', [{
          borderRadius: '0',
          borderColor: 'red',
          transform: 'scale(1) translateY(-20px)',
          offset: 0,
        }, {
          borderRadius: '25%',
          borderColor: 'blue',
          transform: 'scale(.65) translateY(-20px)',
          offset: .5,
        }, {
          borderRadius: '50%',
          borderColor: 'blue',
          transform: `scale(.3) translateY(-20px)`,
          offset: 1
        }], 2000, {
          scrollSource: '#scroller',
          timeRange: 2000,
          startScrollOffset: 0,
          endScrollOffset: 85,
        })

        this.animate('.search_input', [{
          opacity: '0',
          width: '0%',
        }, {
          opacity: '1',
          width: '100%',
        }], 1000, {
          scrollSource: '#scroller',
          timeRange: 1000,
          startScrollOffset: 120,
          endScrollOffset: 252
        })
  #+END_EXAMPLE


 


**** [[index_u59.html#高级的动画方式][#]] 高级的动画方式


  
 

  在一些复杂场景下，上述的动画方法可能并不适用。

  [[file:interactive-animation.html][WXS 响应事件]] 的方式可以通过使用 WXS
  来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style
  属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

  连续使用 setData
  来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的
  setData 改为 [[../custom-component][自定义组件]] 中的 setData
  来提升性能。下面的例子是使用 setData 来实现秒表动画的示例。

  [[https://developers.weixin.qq.com/s/cRTvdPmO7d5T][在开发者工具中预览效果<<>>]]


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html]]

  \\
  \\




 













  --------------


 










*** [[index_u95.html#初始渲染缓存][#]] 初始渲染缓存


  
 

  #+BEGIN_QUOTE
    基础库 2.11.1
    开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

**** [[index_u95.html#初始渲染缓存工作原理][#]] 初始渲染缓存工作原理


  
 

  小程序页面的初始化分为两个部分。

  -  逻辑层初始化：载入必需的小程序代码、初始化页面 this
     对象（也包括它涉及到的所有自定义组件的 this
     对象）、将相关数据发送给视图层。
  -  视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。

  在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

  启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始
  data
  的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

  -  在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
  -  在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
  -  如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

  利用初始渲染缓存，可以：

  -  快速展示出页面中永远不会变的部分，如导航栏；
  -  预先展示一个骨架页，提升用户体验；
  -  展示自定义的加载提示；
  -  提前展示广告，等等。

**** [[index_u95.html#支持的组件][#]] 支持的组件


  
 

  在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

  目前支持的内置组件：

  -  =<view />=
  -  =<text />=
  -  =<button />=
  -  =<image />=
  -  =<scroll-view />=
  -  =<rich-text />=

  自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**** [[index_u95.html#静态初始渲染缓存][#]] 静态初始渲染缓存


  
 

  若想启用初始渲染缓存，最简单的方法是在页面的 =json= 文件中添加配置项
  ="initialRenderingCache": "static"= ：





  #+BEGIN_EXAMPLE
      {
        "initialRenderingCache": "static"
      }
  #+END_EXAMPLE


 


  如果想要对所有页面启用，可以在 =app.json= 的 =window=
  配置段中添加这个配置：





  #+BEGIN_EXAMPLE
      {
        "window": {
          "initialRenderingCache": "static"
        }
      }
  #+END_EXAMPLE


 


  添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

  注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML
  上的结果，不包含任何 setData 的结果。

  例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 =loading=
  数据字段控制：





  #+BEGIN_EXAMPLE
      <view wx:if="{{loading}}">正在加载</view>
  #+END_EXAMPLE


 


  这种情况下， =loading= 应当在 =data= 中指定为 =true= ，如：





  #+BEGIN_EXAMPLE
      // 正确的做法
      Page({
        data: {
          loading: true
        }
      })
  #+END_EXAMPLE


 


  而不能通过 =setData= 将 =loading= 置为 =true= ：





  #+BEGIN_EXAMPLE
      // 错误的做法！不要这么做！
      Page({
        data: {},
        onLoad: function() {
          this.setData({
            loading: true
          })
        }
      })
  #+END_EXAMPLE


 


  换而言之，这种做法只包含页面 =data= 的渲染结果，即页面的纯静态成分。

**** [[index_u95.html#在初始渲染缓存中添加动态内容][#]]
  在初始渲染缓存中添加动态内容


  
 

  有些场景中，只是页面 =data=
  的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片
  URL 等。

  这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置
  ="initialRenderingCache": "dynamic"= ：





  #+BEGIN_EXAMPLE
      {
        "initialRenderingCache": "dynamic"
      }
  #+END_EXAMPLE


 


  此时，初始渲染缓存不会被自动启用，还需要在页面中调用
  =this.setInitialRenderingCache(dynamicData)= 才能启用。其中，
  =dynamicData= 是一组数据，与 =data= 一起参与页面 WXML 渲染。





  #+BEGIN_EXAMPLE
      Page({
        data: {
          loading: true
        },
        onReady: function() {
          this.setInitialRenderingCache({
            loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
          })
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <view wx:if="{{loading}}">{{loadingHint}}</view>
  #+END_EXAMPLE


 


  从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用
  =this.setInitialRenderingCache=
  ，如果在一个页面内多次调用，仅最后一次调用生效。

  注意：

  -  =this.setInitialRenderingCache= 调用时机不能早于 =Page= 的 =onReady=
     或 =Component= 的 =ready= 生命周期，否则可能对性能有负面影响。
  -  如果想禁用初始渲染缓存，调用 =this.setInitialRenderingCache(null)= 。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html]]

  \\
  \\




 













  --------------


 








** 运行时
*** [[index_u99.html#小程序的运行环境][#]] 小程序的运行环境


  
 

  微信小程序运行在多种平台上：iOS（iPhone/iPad）微信客户端、Android
  微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

  各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

  -  在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore
     中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；

  -  在 Android 上，小程序逻辑层的 javascript 代码运行在
     [[https://developers.google.com/v8/][V8<<>>]] 中，视图层是由自研 XWeb
     引擎基于 Mobile Chrome 内核来渲染的；

  -  在 开发工具上，小程序逻辑层的 javascript 代码是运行在
     [[https://nwjs.io/][NW.js<<>>]] 中，视图层是由 Chromium Webview
     来渲染的。

***** [[index_u99.html#平台差异][#]] 平台差异


  
 

  尽管各运行环境是十分相似的，但是还是有些许区别：

  -  =JavaScript= 语法和 API 支持不一致：语法上开发者可以通过开启 =ES6= 转
     =ES5=
     的功能来规避（[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5][详情<<>>]]）；此外，小程序基础库内置了必要的 Polyfill，来弥补 API 的差异（[[file:js-support.html][详情]])。

  -  =WXSS=
     渲染表现不一致：尽管可以通过开启[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#%E6%A0%B7%E5%BC%8F%E8%A1%A5%E5%85%A8][样式补全<<>>]]来规避大部分的问题，还是建议开发者需要在
     iOS 和 Android 上分别检查小程序的真实表现。

  *开发者工具仅供调试使用，最终的表现以客户端为准。*


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html]]

  \\
  \\




 













  --------------


 










*** [[index_u23.html#小程序的运行环境][#]] 小程序的运行环境


  
 

  微信小程序运行在多种平台上：iOS（iPhone/iPad）微信客户端、Android
  微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

  各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

  -  在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore
     中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；

  -  在 Android 上，小程序逻辑层的 javascript 代码运行在
     [[https://developers.google.com/v8/][V8<<>>]] 中，视图层是由自研 XWeb
     引擎基于 Mobile Chrome 内核来渲染的；

  -  在 开发工具上，小程序逻辑层的 javascript 代码是运行在
     [[https://nwjs.io/][NW.js<<>>]] 中，视图层是由 Chromium Webview
     来渲染的。

***** [[index_u23.html#平台差异][#]] 平台差异


  
 

  尽管各运行环境是十分相似的，但是还是有些许区别：

  -  =JavaScript= 语法和 API 支持不一致：语法上开发者可以通过开启 =ES6= 转
     =ES5=
     的功能来规避（[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5][详情<<>>]]）；此外，小程序基础库内置了必要的 Polyfill，来弥补 API 的差异（[[file:js-support.html][详情]])。

  -  =WXSS=
     渲染表现不一致：尽管可以通过开启[[https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#%E6%A0%B7%E5%BC%8F%E8%A1%A5%E5%85%A8][样式补全<<>>]]来规避大部分的问题，还是建议开发者需要在
     iOS 和 Android 上分别检查小程序的真实表现。

  *开发者工具仅供调试使用，最终的表现以客户端为准。*


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html]]

  \\
  \\




 













  --------------


 










*** [[index_u2.html#JavaScript-支持情况][#]] JavaScript 支持情况


  
 

**** [[index_u2.html#运行限制][#]] 运行限制


  
 

  基于安全考虑，小程序中不支持动态执行 JS 代码，即：

  -  不支持使用 =eval= 执行 JS 代码
  -  不支持使用 =new Function= 创建函数

**** [[index_u2.html#客户端-ES6-API-支持情况][#]] 客户端 ES6 API 支持情况


  
 

  微信小程序已经支持了绝大部分的 ES6 API，已支持的 API
  如下（部分 API 依赖系统版本）：









  | String                 | iOS10+   | Android   |
  |------------------------+----------+-----------|
  | codePointAt            |          |           |
  | normalize              |          |           |
  | includes               |          |           |
  | startsWith             |          |           |
  | endsWith               |          |           |
  | repeat                 |          |           |
  | String.fromCodePoint   |          |           |


 






  | Array        | iOS10+   | Android   |
  |--------------+----------+-----------|
  | copyWithin   |          |           |
  | find         |          |           |
  | findIndex    |          |           |
  | fill         |          |           |
  | entries      |          |           |
  | keys         |          |           |
  | values       |          | ✘         |
  | includes     |          |           |
  | Array.from   |          |           |
  | Array.of     |          |           |


 






  | Number          | iOS10+   | Android   |
  |-----------------+----------+-----------|
  | isFinite        |          |           |
  | isNaN           |          |           |
  | parseInt        |          |           |
  | parseFloat      |          |           |
  | isInteger       |          |           |
  | EPSILON         |          |           |
  | isSafeInteger   |          |           |


 






  | Math     | iOS10+   | Android   |
  |----------+----------+-----------|
  | trunc    |          |           |
  | sign     |          |           |
  | cbrt     |          |           |
  | clz32    |          |           |
  | imul     |          |           |
  | fround   |          |           |
  | hypot    |          |           |
  | expm1    |          |           |
  | log1p    |          |           |
  | log10    |          |           |
  | log2     |          |           |
  | sinh     |          |           |
  | cosh     |          |           |
  | tanh     |          |           |
  | asinh    |          |           |
  | acosh    |          |           |
  | atanh    |          |           |


 






  | Object                     | iOS10+   | Android   |
  |----------------------------+----------+-----------|
  | is                         |          |           |
  | assign                     |          |           |
  | getOwnPropertyDescriptor   |          |           |
  | keys                       |          |           |
  | getOwnPropertyNames        |          |           |
  | getOwnPropertySymbols      |          |           |


 






  | Other     | iOS10+   | Android   |
  |-----------+----------+-----------|
  | Symbol    |          |           |
  | Set       |          |           |
  | Map       |          |           |
  | Proxy     |          | ✘         |
  | Reflect   |          |           |
  | Promise   |          |           |


 



 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html]]

  \\
  \\




 













  --------------


 










**** [[index_u81.html#小程序运行机制][#]] 小程序运行机制


  
 

***** [[index_u81.html#前台-后台状态][#]] 前台/后台状态


  
 

  小程序启动后，界面被展示给用户，此时小程序处于*前台*状态。

  当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home
  键离开微信时，小程序并没有完全终止运行，而是进入了*后台*状态，小程序还可以运行一小段时间。

  当用户再次进入微信或再次打开小程序，小程序又会从后台进入*前台*。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被*销毁*，即完全终止运行。

***** [[index_u81.html#小程序启动][#]] 小程序启动


  
 

  这样，小程序启动可以分为两种情况，一种是*冷启动*，一种是*热启动*。

  -  冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
  -  热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

***** [[index_u81.html#小程序销毁时机][#]] 小程序销毁时机


  
 

  通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：

  -  当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。
  -  当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。

     -  在 iOS
        上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户
        「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。
     -  建议小程序在必要时使用
        [[../../api/device/performance/wx.onMemoryWarning.html][wx.onMemoryWarning]]
        监听内存告警事件，进行必要的内存清理。

  #+BEGIN_QUOTE
    基础库 1.1.0 及以上，1.4.0 以下版本：
    当用户从扫一扫、转发等入口（[[../app-service/scene.html][场景值]]为 1007,
    1008, 1011,
    1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。
  #+END_QUOTE

***** [[index_u81.html#启动场景分类][#]] 启动场景分类


  
 

  用户打开小程序时，场景可分为以下 A、B 两类：

  A. 保留上次的浏览状态。[[../app-service/scene.html][场景值]]有以下几项：





  | 场景值 ID   | 说明                                                                                                     |
  |------------+----------------------------------------------------------------------------------------------------------|
  | 1001       | 发现栏小程序主入口，「最近使用」列表（基础库 2.2.4 版本起包含「我的小程序」列表）                          |
  | 1003       | 星标小程序列表                                                                                           |
  | 1023       | 系统桌面小图标打开小程序                                                                                 |
  | 1038       | 从其他小程序返回小程序                                                                                   |
  | 1056       | 聊天顶部音乐播放器右上角菜单，打开小程序                                                                 |
  | 1080       | 客服会话菜单小程序入口，打开小程序                                                                       |
  | 1083       | 公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）                                            |
  | 1089       | 聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库 2.2.4 版本起包含「我的小程序」栏）   |
  | 1090       | 长按小程序右上角菜单，打开小程序                                                                         |
  | 1103       | 发现-小程序主入口我的小程序，打开小程序                                                                  |
  | 1104       | 聊天主界面下拉，从我的小程序，打开小程序                                                                 |
  | 1113       | 安卓手机负一屏，打开小程序                                                                               |
  | 1114       | 安卓手机侧边栏，打开小程序                                                                               |
  | 1117       | 后台运行小程序的管理页中，打开小程序                                                                     |


 


  -  若进入的场景中带有 path，则每次打开小程序时都进入对应的 path 页面
  -  若进入的场景中不带 path：

     1. 若小程序是热启动，则保留原来状态
     2. 若小程序是冷启动，则遵循下一节的重启策略，可能是首页或上次退出的页面

  B. relaunch 到指定页或首页

  包括除 A 类外的其他场景

  -  若进入的场景中带有 path，则每次点击时都进入对应的 path 页面
  -  若进入的场景中不带 path，则每次进入都打开首页

***** [[index_u81.html#A-类场景的重新启动策略][#]] A 类场景的重新启动策略


  
 

  #+BEGIN_QUOTE
    基础库 2.8.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  小程序被销毁后，下次冷启动如果属于 B 类场景，将会进入特定的页面。

  下次冷启动如果属于 A
  类场景，默认情况下将会进入小程序的首页。在页面对应的 json
  文件中（也可以全局配置在 app.json 的 window 段中），指定
  =restartStrategy=
  配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A
  类场景的冷启动可以回到这个页面。

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "restartStrategy": "homePage"
      }
  #+END_EXAMPLE


 


  =restartStrategy= 可选值：





  | 可选值                  | 含义                                                                                            |
  |-------------------------+-------------------------------------------------------------------------------------------------|
  | homePage                | （默认值）如果从这个页面退出小程序，下次将从首页冷启动                                          |
  | homePageAndLatestPage   | 如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）   |


 


  注意：即使不配置为 =homePage=
  ，小程序如果退出过久（当前默认一天时间，可以使用*退出状态*来调整），下次冷启动时也将不再遵循
  =restartStrategy= 的配置，而是直接从首页冷启动。

  无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox
  的勾选状态等都不会还原。如果需要还原或部分还原，需要利用*退出状态*。

***** [[index_u81.html#退出状态][#]] 退出状态


  
 

  每当小程序可能被销毁之前，页面回调函数 =onSaveExitState=
  会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过
  =exitState= 获得这些已保存数据。

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "restartStrategy": "homePageAndLatestPage"
      }
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Page({
        onLoad: function() {
          var prevExitState = this.exitState // 尝试获得上一次退出前 onSaveExitState 保存的数据
          if (prevExitState !== undefined) { // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
            prevExitState.myDataField === 'myData' 
          }
        },
        onSaveExitState: function() {
          var exitState = { myDataField: 'myData' } // 需要保存的数据
          return {
            data: exitState,
            expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻
          }
        }
      })
  #+END_EXAMPLE


 


  =onSaveExitState= 返回值可以包含两项：





  | 字段名            | 类型     | 含义                                                                         |
  |-------------------+----------+------------------------------------------------------------------------------|
  | data              | Any      | 需要保存的数据（只能是 JSON 兼容的数据）                                     |
  | expireTimeStamp   | Number   | 超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)   |


 


  一个更完整的示例：[[https://developers.weixin.qq.com/s/ELP5uTmN7E8l][在开发者工具中预览效果<<>>]]

  注意事项：

  -  如果超过 =expireTimeStamp= ，保存的数据将被丢弃，且冷启动时不遵循
     =restartStrategy= 的配置，而是直接从首页冷启动。
  -  =expireTimeStamp= 有可能被自动提前，如微信客户端需要清理数据的时候。
  -  在小程序存活期间， =onSaveExitState=
     可能会被多次调用，此时以最后一次的调用结果作为最终结果。
  -  在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循
     =restartStrategy= 的配置，而是直接从首页冷启动。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html]]

  \\
  \\




 













  --------------


 










**** [[index_u13.html#小程序更新机制][#]] 小程序更新机制


  
 

***** [[index_u13.html#未启动时更新][#]] 未启动时更新


  
 

  开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后
  24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。

***** [[index_u13.html#启动时更新][#]] 启动时更新


  
 

  小程序每次*冷启动*时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

  如果需要马上应用最新版本，可以使用
  [[../../api/base/update/wx.getUpdateManager.html][wx.getUpdateManager]]
  API 进行处理。





  #+BEGIN_EXAMPLE
      const updateManager = wx.getUpdateManager()

      updateManager.onCheckForUpdate(function (res) {
        // 请求完新版本信息的回调
        console.log(res.hasUpdate)
      })

      updateManager.onUpdateReady(function () {
        wx.showModal({
          title: '更新提示',
          content: '新版本已经准备好，是否重启应用？',
          success(res) {
            if (res.confirm) {
              // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
              updateManager.applyUpdate()
            }
          }
        })
      })

      updateManager.onUpdateFailed(function () {
        // 新版本下载失败
      })
  #+END_EXAMPLE


 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html]]

  \\
  \\




 













  --------------


 








** 自定义组件
 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以
 将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件
 非常相似。

**** [[index_u7.html#创建自定义组件][#]] 创建自定义组件


  
 

 类似于页面，一个自定义组件由 =json= =wxml= =wxss= =js=
 4 个文件组成。要编写一个自定义组件，首先需要在 =json=
 文件中进行自定义组件声明（将 =component= 字段设为 =true=
 可将这一组文件设为自定义组件）：





 #+BEGIN_EXAMPLE
     {
       "component": true
     }
 #+END_EXAMPLE


 


 同时，还要在 =wxml= 文件中编写组件模板，在 =wxss=
 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见
 [[file:wxml-wxss.html][组件模板和样式]] 。

 *代码示例：*





 #+BEGIN_EXAMPLE
     <!-- 这是自定义组件的内部WXML结构 -->
     <view class="inner">
       {{innerText}}
     </view>
     <slot></slot>
 #+END_EXAMPLE


 






 #+BEGIN_EXAMPLE
     /* 这里的样式只应用于这个自定义组件 */
     .inner {
       color: red;
     }
 #+END_EXAMPLE


 


 *注意：在组件 wxss 中不应使用 ID 选择器、属性选择器和标签名选择器。*

 在自定义组件的 =js= 文件中，需要使用 =Component()=
 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

 组件的属性值和内部数据将被用于组件 =wxml=
 的渲染，其中，属性值是可由组件外部传入的。更多细节参见
 [[file:component.html][Component构造器]] 。

 *代码示例：*





 #+BEGIN_EXAMPLE
     Component({
       properties: {
         // 这里定义了innerText属性，属性值可以在组件使用时指定
         innerText: {
           type: String,
           value: 'default value',
         }
       },
       data: {
         // 这里是一些组件内部数据
         someData: {}
       },
       methods: {
         // 这里是一个自定义方法
         customMethod: function(){}
       }
     })
 #+END_EXAMPLE


 


**** [[index_u7.html#使用自定义组件][#]] 使用自定义组件


  
 

 使用已注册的自定义组件前，首先要在页面的 =json=
 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：





 #+BEGIN_EXAMPLE
     {
       "usingComponents": {
         "component-tag-name": "path/to/the/custom/component"
       }
     }
 #+END_EXAMPLE


 


 这样，在页面的 =wxml=
 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

 #+BEGIN_QUOTE
   开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明
   usingComponents
   字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。
 #+END_QUOTE

 *代码示例：*

 [[https://developers.weixin.qq.com/s/OMfVAKmZ6KZT][在开发者工具中预览效果<<>>]]





 #+BEGIN_EXAMPLE
     <view>
       <!-- 以下是对一个自定义组件的引用 -->
       <component-tag-name inner-text="Some text"></component-tag-name>
     </view>
 #+END_EXAMPLE


 


 自定义组件的 =wxml= 节点结构在与数据结合之后，将被插入到引用位置内。

**** [[index_u7.html#细节注意事项][#]] 细节注意事项


  
 

 一些需要注意的细节：

 -  因为 WXML
    节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
 -  自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用
    =usingComponents= 字段）。
 -  自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

 注意，是否在页面文件中使用 =usingComponents= 会使得页面的 =this=
 对象的原型稍有差异，包括：

 -  使用 =usingComponents= 页面的原型与不使用时不一致，即
    =Object.getPrototypeOf(this)= 结果不同。
 -  使用 =usingComponents= 时会多一些方法，如 =selectComponent= 。
 -  出于性能考虑，使用 =usingComponents= 时， =setData=
    内容不会被直接深复制，即 =this.setData({ field: obj })= 后
    =this.data.field === obj= 。（深复制会在这个值被组件间传递时发生。）

 如果页面比较复杂，新增或删除 =usingComponents=
 定义段时建议重新测试一下。


 



 






 --------------


 [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/]]

 \\
 \\




 













 --------------


 










*** [[index_u90.html#组件模板和样式][#]] 组件模板和样式


  
 

  类似于页面，自定义组件拥有自己的 =wxml= 模板和 =wxss= 样式。

***** [[index_u90.html#组件模板][#]] 组件模板


  
 

  组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

  在组件模板中可以提供一个 =<slot>= 节点，用于承载组件引用时提供的子节点。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/1udXLnmi6KY2][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <!-- 组件模板 -->
      <view class="wrapper">
        <view>这里是组件的内部节点</view>
        <slot></slot>
      </view>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- 引用组件的页面模板 -->
      <view>
        <component-tag-name>
          <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
          <view>这里是插入到组件slot中的内容</view>
        </component-tag-name>
      </view>
  #+END_EXAMPLE


 


  注意，在模板中引用到的自定义组件及其对应的节点名需要在 =json=
  文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为[[file:generics.html][抽象节点]]。

***** [[index_u90.html#模板数据绑定][#]] 模板数据绑定


  
 

  与普通的 WXML
  模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/8ZhcXBme7djX][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <!-- 引用组件的页面模板 -->
      <view>
        <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
          <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
          <view>这里是插入到组件slot中的内容</view>
        </component-tag-name>
      </view>
  #+END_EXAMPLE


 


  在以上例子中，组件的属性 =propA= 和 =propB=
  将收到页面传递的数据。页面可以通过 =setData= 来改变绑定的数据字段。

  注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本
  [[../compatibility.html][2.0.9]]
  开始，还可以在数据中包含函数（但这些函数不能在 WXML
  中直接调用，只能传递给子组件）。

***** [[index_u90.html#组件-wxml-的-slot][#]] 组件 wxml 的 slot


  
 

  在组件的 wxml 中可以包含 =slot= 节点，用于承载组件使用者提供的 wxml
  结构。

  默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot
  时，可以在组件 js 中声明启用。





  #+BEGIN_EXAMPLE
      Component({
        options: {
          multipleSlots: true // 在组件定义时的选项中启用多slot支持
        },
        properties: { /* ... */ },
        methods: { /* ... */ }
      })
  #+END_EXAMPLE


 


  此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 =name= 来区分。





  #+BEGIN_EXAMPLE
      <!-- 组件模板 -->
      <view class="wrapper">
        <slot name="before"></slot>
        <view>这里是组件的内部细节</view>
        <slot name="after"></slot>
      </view>
  #+END_EXAMPLE


 


  使用时，用 =slot= 属性来将节点插入到不同的 slot 上。





  #+BEGIN_EXAMPLE
      <!-- 引用组件的页面模板 -->
      <view>
        <component-tag-name>
          <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
          <view slot="before">这里是插入到组件slot name="before"中的内容</view>
          <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
          <view slot="after">这里是插入到组件slot name="after"中的内容</view>
        </component-tag-name>
      </view>
  #+END_EXAMPLE


 


***** [[index_u90.html#组件样式][#]] 组件样式


  
 

  组件对应 =wxss=
  文件的样式，只对组件 wxml 内的节点生效。编写组件样式时，需要注意以下几点：

  -  组件和引用组件的页面不能使用 id 选择器（=#a=）、属性选择器（=[a]=）和标签名选择器，请改用 class 选择器。
  -  组件和引用组件的页面中使用后代选择器（=.a .b=）在一些极端情况下会有非预期的表现，如遇，请避免使用。
  -  子元素选择器（=.a>.b=）只能用于 =view=
     组件与其子节点之间，用于其他组件可能导致非预期的情况。
  -  继承样式，如 =font= 、 =color= ，会从组件外继承到组件内。
  -  除继承样式外， =app.wxss=
     中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。





  #+BEGIN_EXAMPLE
      #a { } /* 在组件中不能使用 */
      [a] { } /* 在组件中不能使用 */
      button { } /* 在组件中不能使用 */
      .a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */
  #+END_EXAMPLE


 


  除此以外，组件可以指定它所在节点的默认样式，使用 =:host=
  选择器（需要包含基础库 [[../compatibility.html][1.7.2]]
  或更高版本的开发者工具支持）。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/jAgvwKm16bZD][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      /* 组件 custom-component.wxss */
      :host {
        color: yellow;
      }
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- 页面的 WXML -->
      <custom-component>这段文本是黄色的</custom-component>
  #+END_EXAMPLE


 


***** [[index_u90.html#组件样式隔离][#]] 组件样式隔离


  
 

  默认情况下，自定义组件的样式只受到自定义组件 wxss
  的影响。除非以下两种情况：

  -  =app.wxss= 或页面的 =wxss=
     中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
  -  指定特殊的样式隔离选项 =styleIsolation= 。





  #+BEGIN_EXAMPLE
      Component({
        options: {
          styleIsolation: 'isolated'
        }
      })
  #+END_EXAMPLE


 


  [[https://developers.weixin.qq.com/s/xPQhJcm37e7h][在开发者工具中预览效果<<>>]]

  =styleIsolation= 选项从基础库版本 [[../compatibility.html][2.6.5]]
  开始支持。它支持以下取值：

  -  =isolated= 表示启用样式隔离，在自定义组件内外，使用 class
     指定的样式将不会相互影响（一般情况下的默认值）；
  -  =apply-shared= 表示页面 wxss 样式将影响到自定义组件，但自定义组件
     wxss 中指定的样式不会影响页面；
  -  =shared= 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss
     中指定的样式也会影响页面和其他设置了 =apply-shared= 或 =shared=
     的自定义组件。（这个选项在插件中不可用。）

  *使用后两者时，请务必注意组件间样式的相互影响。*

  如果这个 [[file:component.html][Component 构造器用于构造页面]]
  ，则默认值为 =shared= ，且还有以下几个额外的样式隔离选项可用：

  -  =page-isolated= 表示在这个页面禁用 app.wxss ，同时，页面的 wxss
     不会影响到其他自定义组件；
  -  =page-apply-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
     样式不会影响到其他自定义组件，但设为 =shared=
     的自定义组件会影响到页面；
  -  =page-shared= 表示在这个页面禁用 app.wxss ，同时，页面 wxss
     样式会影响到其他设为 =apply-shared= 或 =shared=
     的自定义组件，也会受到设为 =shared= 的自定义组件的影响。

  从小程序基础库版本 [[../compatibility.html][2.10.1]]
  开始，也可以在页面或自定义组件的 json 文件中配置 =styleIsolation=
  （这样就不需在 js 文件的 =options= 中再配置）。例如：





  #+BEGIN_EXAMPLE
      {
        "styleIsolation": "isolated"
      }
  #+END_EXAMPLE


 


  此外，小程序基础库版本 [[../compatibility.html][2.2.3]] 以上支持
  =addGlobalClass= 选项，即在 =Component= 的 =options= 中设置
  =addGlobalClass: true= 。 这个选项等价于设置
  =styleIsolation: apply-shared= ，但设置了 =styleIsolation=
  选项后这个选项会失效。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/VkTd7Fm37ggl][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      /* 组件 custom-component.js */
      Component({
        options: {
          addGlobalClass: true,
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- 组件 custom-component.wxml -->
      <text class="red-text">这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      /* app.wxss */
      .red-text {
        color: red;
      }
  #+END_EXAMPLE


 


***** [[index_u90.html#外部样式类][#]] 外部样式类


  
 

  #+BEGIN_QUOTE
    基础库 1.9.90
    开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  有时，组件希望接受外部传入的样式类。此时可以在 =Component= 中用
  =externalClasses= 定义段定义若干个外部样式类。

  这个特性可以用于实现类似于 =view= 组件的 =hover-class=
  属性：页面可以提供一个样式类，赋予 =view= 的 =hover-class=
  ，这个样式类本身写在页面中而非 =view= 组件的实现中。

  *注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。*

  *代码示例：*





  #+BEGIN_EXAMPLE
      /* 组件 custom-component.js */
      Component({
        externalClasses: ['my-class']
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- 组件 custom-component.wxml -->
      <custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
  #+END_EXAMPLE


 


  这样，组件的使用者可以指定这个样式类对应的 class
  ，就像使用普通属性一样。在 [[../compatibility.html][2.7.1]]
  之后，可以指定多个对应的 class 。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/rbgNNKmE6bZK][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <!-- 页面的 WXML -->
      <custom-component my-class="red-text" />
      <custom-component my-class="large-text" />
      <!-- 以下写法需要基础库版本 2.7.1 以上 -->
      <custom-component my-class="red-text large-text" />
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      .red-text {
        color: red;
      }
      .large-text {
        font-size: 1.5em;
      }
  #+END_EXAMPLE


 


***** [[index_u90.html#引用页面或父组件的样式][#]] 引用页面或父组件的样式


  
 

  #+BEGIN_QUOTE
    基础库 2.9.2 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  即使启用了样式隔离 =isolated=
  ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

  例如，如果在页面 wxss 中定义了：





  #+BEGIN_EXAMPLE
      .blue-text {
        color: blue;
      }
  #+END_EXAMPLE


 


  在这个组件中可以使用 =~= 来引用这个类的样式：





  #+BEGIN_EXAMPLE
      <view class="~blue-text"> 这段文本是蓝色的 </view>
  #+END_EXAMPLE


 


  如果在一个组件的父组件 wxss 中定义了：





  #+BEGIN_EXAMPLE
      .red-text {
        color: red;
      }
  #+END_EXAMPLE


 


  在这个组件中可以使用 =^= 来引用这个类的样式：





  #+BEGIN_EXAMPLE
      <view class="^red-text"> 这段文本是红色的 </view>
  #+END_EXAMPLE


 


  也可以连续使用多个 =^= 来引用祖先组件中的样式。

  *注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。*

***** [[index_u90.html#虚拟化组件节点][#]] 虚拟化组件节点


  
 

  #+BEGIN_QUOTE
    基础库 2.11.2
    开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置
  =class= =style= 、动画、 flex 布局等，就如同普通的 view 组件节点一样。





  #+BEGIN_EXAMPLE
      <!-- 页面的 WXML -->
      <view style="display: flex">
        <!-- 默认情况下，这是一个普通的节点 -->
        <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>
      </view>
  #+END_EXAMPLE


 


  但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex
  布局等，而是希望自定义组件内部的第一层节点能够响应 flex
  布局或者样式由自定义组件本身完全决定。

  这种情况下，可以将这个自定义组件设置为“虚拟的”：





  #+BEGIN_EXAMPLE
      Component({
        options: {
          virtualHost: true
        },
        properties: {
          style: { // 定义 style 属性可以拿到 style 属性上设置的值
            type: String,
          }
        },
        externalClasses: ['class'], // 可以将 class 设为 externalClasses
      })
  #+END_EXAMPLE


 


  这样，可以将 flex 放入自定义组件内：





  #+BEGIN_EXAMPLE
      <!-- 页面的 WXML -->
      <view style="display: flex">
        <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
        <custom-component style="color: blue">不是蓝色的</custom-component>
      </view>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- custom-component.wxml -->
      <view style="flex: 1">
        满宽的
        <slot></slot>
      </view>
  #+END_EXAMPLE


 


  需要注意的是，自定义组件节点上的 =class= =style=
  和动画将不再生效，但仍可以：

  -  将 style 定义成 =properties= 属性来获取 style 上设置的值；
  -  将 class 定义成 =externalClasses= 外部样式类使得自定义组件 wxml
     可以使用 class 值。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/AlV9fEmF7Dh8][在开发者工具中预览效果<<>>]]


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html]]

  \\
  \\




 













  --------------


 










*** [[index_u72.html#Component-构造器][#]] Component 构造器


  
 

  =Component= 构造器可用于定义组件，调用 =Component=
  构造器时可以指定组件的属性、数据、方法等。

  详细的参数含义和使用请参考
  [[../../reference/api/Component.html][Component 参考文档]]。





  #+BEGIN_EXAMPLE
      Component({

        behaviors: [],

        properties: {
          myProperty: { // 属性名
            type: String,
            value: ''
          },
          myProperty2: String // 简化的定义方式
        },
      
        data: {}, // 私有数据，可用于模板渲染

        lifetimes: {
          // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
          attached: function () { },
          moved: function () { },
          detached: function () { },
        },

        // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
        attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
        ready: function() { },

        pageLifetimes: {
          // 组件所在页面的生命周期函数
          show: function () { },
          hide: function () { },
          resize: function () { },
        },

        methods: {
          onMyButtonTap: function(){
            this.setData({
              // 更新属性和数据的方法与更新页面数据的方法类似
            })
          },
          // 内部方法建议以下划线开头
          _myPrivateMethod: function(){
            // 这里将 data.A[0].B 设为 'myPrivateData'
            this.setData({
              'A[0].B': 'myPrivateData'
            })
          },
          _propertyChange: function(newVal, oldVal) {

          }
        }

      })
  #+END_EXAMPLE


 


**** [[index_u72.html#使用-Component-构造器构造页面][#]] 使用 Component
  构造器构造页面


  
 

  事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用
  =Component=
  构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json
  文件中包含 =usingComponents= 定义段。

  此时，组件的属性可以用于接收页面的参数，如访问页面
  =/pages/index/index?paramA=123&paramB=xyz= ，如果声明有属性 =paramA= 或
  =paramB= ，则它们会被赋值为 =123= 或 =xyz= 。

  页面的生命周期方法（即 =on= 开头的方法），应写在 =methods= 定义段中。

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "usingComponents": {}
      }
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Component({

        properties: {
          paramA: Number,
          paramB: String,
        },

        methods: {
          onLoad: function() {
            this.data.paramA // 页面参数 paramA 的值
            this.data.paramB // 页面参数 paramB 的值
          }
        }

      })
  #+END_EXAMPLE


 


  使用 =Component= 构造器来构造页面的一个好处是可以使用 =behaviors=
  来提取所有页面中公用的代码段。

  例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到
  =behaviors= 中。

  *代码示例：*





  #+BEGIN_EXAMPLE
      // page-common-behavior.js
      module.exports = Behavior({
        attached: function() {
          // 页面创建时执行
          console.info('Page loaded!')
        },
        detached: function() {
          // 页面销毁时执行
          console.info('Page unloaded!')
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 页面 A
      var pageCommonBehavior = require('./page-common-behavior')
      Component({
        behaviors: [pageCommonBehavior],
        data: { /* ... */ },
        methods: { /* ... */ },
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 页面 B
      var pageCommonBehavior = require('./page-common-behavior')
      Component({
        behaviors: [pageCommonBehavior],
        data: { /* ... */ },
        methods: { /* ... */ },
      })
  #+END_EXAMPLE


 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html]]

  \\
  \\




 













  --------------


 










*** [[index_u65.html#组件间通信与事件][#]] 组件间通信与事件


  
 

**** [[index_u65.html#组件间通信][#]] 组件间通信


  
 

  组件间的基本通信方式有以下几种。

  -  WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON
     兼容数据（自基础库版本 [[../compatibility.html][2.0.9]]
     开始，还可以在数据中包含函数）。具体在
     [[file:wxml-wxss.html][组件模板和样式]] 章节中介绍。
  -  事件：用于子组件向父组件传递数据，可以传递任意数据。
  -  如果以上两种方式不足以满足需要，父组件还可以通过
     =this.selectComponent=
     方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

**** [[index_u65.html#监听事件][#]] 监听事件


  
 

  事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见
  [[../view/wxml/event.html][事件]] 。

  监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

  *代码示例：*





  #+BEGIN_EXAMPLE
      <!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->
      <component-tag-name bindmyevent="onMyEvent" />
      <!-- 或者可以写成 -->
      <component-tag-name bind:myevent="onMyEvent" />
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Page({
        onMyEvent: function(e){
          e.detail // 自定义组件触发事件时提供的detail对象
        }
      })
  #+END_EXAMPLE


 


**** [[index_u65.html#触发事件][#]] 触发事件


  
 

  自定义组件触发事件时，需要使用 =triggerEvent=
  方法，指定事件名、detail 对象和事件选项：

  *代码示例：*

  [[https://developers.weixin.qq.com/s/DFfYSKmI6vZD][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <!-- 在自定义组件中 -->
      <button bindtap="onTap">点击这个按钮将触发“myevent”事件</button>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      Component({
        properties: {},
        methods: {
          onTap: function(){
            var myEventDetail = {} // detail对象，提供给事件监听函数
            var myEventOption = {} // 触发事件的选项
            this.triggerEvent('myevent', myEventDetail, myEventOption)
          }
        }
      })
  #+END_EXAMPLE


 


  触发事件的选项包括：





  | 选项名         | 类型      | 是否必填   | 默认值   | 描述                                                                                              |
  |----------------+-----------+------------+----------+---------------------------------------------------------------------------------------------------|
  | bubbles        | Boolean   | 否         | false    | 事件是否冒泡                                                                                      |
  | composed       | Boolean   | 否         | false    | 事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部   |
  | capturePhase   | Boolean   | 否         | false    | 事件是否拥有捕获阶段                                                                              |


 


  关于冒泡和捕获阶段的概念，请阅读 [[../view/wxml/event.html][事件]]
  章节中的相关说明。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/UGfljKm66zZ1][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // 页面 page.wxml
      <another-component bindcustomevent="pageEventListener1">
        <my-component bindcustomevent="pageEventListener2"></my-component>
      </another-component>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 组件 another-component.wxml
      <view bindcustomevent="anotherEventListener">
        <slot />
      </view>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 组件 my-component.wxml
      <view bindcustomevent="myEventListener">
        <slot />
      </view>
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 组件 my-component.js
      Component({
        methods: {
          onTap: function(){
            this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
            this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
            this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
          }
        }
      })
  #+END_EXAMPLE


 


**** [[index_u65.html#获取组件实例][#]] 获取组件实例


  
 

  可在父组件里调用 =this.selectComponent=
  ，获取子组件的实例对象。（插件的自定义组件将返回 =null=）

  调用时需要传入一个匹配选择器
  =selector=，如：=this.selectComponent(".my-component")=。

  =selector= 详细语法可查看
  [[../../api/wxml/SelectorQuery.select.html][selector 语法参考文档]]。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/oQ64sFmm7rhD][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // 父组件
      Page({
        data: {},
        getChildComponent: function () {
          const child = this.selectComponent('.my-component');
          console.log(child)
        }
      })
  #+END_EXAMPLE


 


  在上例中，父组件将会获取 =class= 为 =my-component=
  的子组件实例对象，即子组件的 =this= 。

  若需要自定义 =selectComponent= 返回的数据，可使用内置 =behavior=:
  =wx://component-export=

  从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

  使自定义组件中支持 =export= 定义段，这个定义段可以用于指定组件被
  =selectComponent= 调用时的返回值。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/ZtosuRmK741Y][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // 自定义组件 my-component 内部
      Component({
        behaviors: ['wx://component-export'],
        export() {
          return { myField: 'myValue' }
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <!-- 使用自定义组件时 -->
      <my-component id="the-id" />
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // 父组件调用
      const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
  #+END_EXAMPLE


 


  在上例中，父组件获取 =id= 为 =the-id= 的子组件实例的时候，得到的是对象
  ={ myField: 'myValue' }= 。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html]]

  \\
  \\




 













  --------------


 










*** [[index_u94.html#组件生命周期][#]] 组件生命周期


  
 

  组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

  其中，最重要的生命周期是 =created= =attached= =detached=
  ，包含一个组件实例生命流程的最主要时间点。

  -  组件实例刚刚被创建好时， =created= 生命周期被触发。此时，组件数据
     =this.data= 就是在 =Component= 构造器中定义的数据 =data= 。
     *此时还不能调用 =setData= 。*
     通常情况下，这个生命周期只应该用于给组件 =this=
     添加一些自定义属性字段。
  -  在组件完全初始化完毕、进入页面节点树后， =attached=
     生命周期被触发。此时， =this.data=
     已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
  -  在组件离开页面节点树后， =detached=
     生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则
     =detached= 会被触发。

**** [[index_u94.html#定义生命周期方法][#]] 定义生命周期方法


  
 

  生命周期方法可以直接定义在 =Component= 构造器的第一级参数中。

  自小程序基础库版本 [[../compatibility.html][2.2.3]]
  起，组件的的生命周期也可以在 =lifetimes=
  字段内进行声明（这是推荐的方式，其优先级最高）。

  *代码示例：*





  #+BEGIN_EXAMPLE
      Component({
        lifetimes: {
          attached: function() {
            // 在组件实例进入页面节点树时执行
          },
          detached: function() {
            // 在组件实例被从页面节点树移除时执行
          },
        },
        // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
        attached: function() {
          // 在组件实例进入页面节点树时执行
        },
        detached: function() {
          // 在组件实例被从页面节点树移除时执行
        },
        // ...
      })
  #+END_EXAMPLE


 


  在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors
  中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个
  behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

  可用的全部生命周期如下表所示。





  | 生命周期   | 参数             | 描述                                       | 最低版本                           |
  |------------+------------------+--------------------------------------------+------------------------------------|
  | created    | 无               | 在组件实例刚刚被创建时执行                 | [[../compatibility.html][1.6.3]]   |
  | attached   | 无               | 在组件实例进入页面节点树时执行             | [[../compatibility.html][1.6.3]]   |
  | ready      | 无               | 在组件在视图层布局完成后执行               | [[../compatibility.html][1.6.3]]   |
  | moved      | 无               | 在组件实例被移动到节点树另一个位置时执行   | [[../compatibility.html][1.6.3]]   |
  | detached   | 无               | 在组件实例被从页面节点树移除时执行         | [[../compatibility.html][1.6.3]]   |
  | error      | =Object Error=   | 每当组件方法抛出错误时执行                 | [[../compatibility.html][2.4.1]]   |


 


**** [[index_u94.html#组件所在页面的生命周期][#]] 组件所在页面的生命周期


  
 

  还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在
  =pageLifetimes= 定义段中定义。其中可用的生命周期包括：





  | 生命周期   | 参数            | 描述                           | 最低版本                           |
  |------------+-----------------+--------------------------------+------------------------------------|
  | show       | 无              | 组件所在的页面被展示时执行     | [[../compatibility.html][2.2.3]]   |
  | hide       | 无              | 组件所在的页面被隐藏时执行     | [[../compatibility.html][2.2.3]]   |
  | resize     | =Object Size=   | 组件所在的页面尺寸变化时执行   | [[../compatibility.html][2.4.0]]   |


 


  *代码示例：*





  #+BEGIN_EXAMPLE
      Component({
        pageLifetimes: {
          show: function() {
            // 页面被展示
          },
          hide: function() {
            // 页面被隐藏
          },
          resize: function(size) {
            // 页面尺寸变化
          }
        }
      })
  #+END_EXAMPLE


 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html]]

  \\
  \\




 













  --------------


 










*** [[index_u79.html#behaviors][#]] behaviors


  
 

  =behaviors= 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins”
  或 “traits”。

  每个 =behavior=
  可以包含一组属性、数据、生命周期函数和方法。*组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。*
  每个组件可以引用多个 =behavior= ，=behavior= 也可以引用其它 =behavior=
  。

  详细的参数含义和使用请参考 [[../../reference/api/Behavior.html][Behavior
  参考文档]]。

**** [[index_u79.html#组件中使用][#]] 组件中使用


  
 

  组件引用时，在 =behaviors= 定义段中将它们逐个列出即可。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/Yq4RqCm87thO][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // my-component.js
      var myBehavior = require('my-behavior')
      Component({
        behaviors: [myBehavior],
        properties: {
          myProperty: {
            type: String
          }
        },
        data: {
          myData: 'my-component-data'
        },
        created: function () {
          console.log('[my-component] created')
        },
        attached: function () { 
          console.log('[my-component] attached')
        },
        ready: function () {
          console.log('[my-component] ready')
        },
        methods: {
          myMethod: function () {
            console.log('[my-component] log by myMethod')
          },
        }
      })
  #+END_EXAMPLE


 


  在上例中， =my-component= 组件定义中加入了 =my-behavior=，

  而 =my-behavior= 结构为：

  -  属性：=myBehaviorProperty=
  -  数据字段：=myBehaviorData=
  -  方法：=myBehaviorMethod=
  -  生命周期函数：=attached=、=created=、=ready=

  这将使 =my-component= 最终结构为：

  -  属性：=myBehaviorProperty=、=myProperty=
  -  数据字段：=myBehaviorData=、=myData=
  -  方法：=myBehaviorMethod=、=myMethod=
  -  生命周期函数：=attached=、=created=、=ready=

  当组件触发生命周期时，上例生命周期函数执行顺序为：

  1. =[my-behavior] created=
  2. =[my-component] created=
  3. =[my-behavior] attached=
  4. =[my-component] attached=
  5. =[my-behavior] ready=
  6. =[my-component] ready=

  详细规则参考 *同名字段的覆盖和组合规则*。

**** [[index_u79.html#同名字段的覆盖和组合规则][#]]
  同名字段的覆盖和组合规则


  
 

  组件和它引用的 =behavior=
  中可以包含同名的字段，对这些字段的处理方法如下：

  -  如果有同名的属性 (properties) 或方法 (methods)：

     1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 =behavior=
        中的同名属性或方法；
     2. 若组件本身无这个属性或方法，则在组件的 =behaviors=
        字段中定义靠后的 =behavior=
        的属性或方法会覆盖靠前的同名属性或方法；
     3. 在 2 的基础上，若存在嵌套引用 =behavior=
        的情况，则规则为：=父 behavior= 覆盖 =子 behavior=
        中的同名属性或方法。

  -  如果有同名的数据字段 (data)：

     -  若同名的数据字段都是对象类型，会进行对象合并；
     -  其余情况会进行数据覆盖，覆盖规则为：组件 > =父 behavior= >
        =子 behavior= 、 =靠后的 behavior= >
        =靠前的 behavior=。（优先级高的覆盖优先级低的，最大的为优先级最高）

  -  生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：

     -  对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
     -  对于同种生命周期函数，遵循如下规则：

        -  =behavior= 优先于组件执行；
        -  =子 behavior= 优先于 =父 behavior= 执行；
        -  =靠前的 behavior= 优先于 =靠后的 behavior= 执行；

     -  如果同一个 =behavior=
        被一个组件多次引用，它定义的生命周期函数只会被执行一次。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/CI5omDmT7khB][在开发者工具中预览效果<<>>]]

**** [[index_u79.html#内置-behaviors][#]] 内置 behaviors


  
 

  自定义组件可以通过引用内置的 =behavior= 来获得内置组件的一些行为。





  #+BEGIN_EXAMPLE
      Component({
        behaviors: ['wx://form-field']
      })
  #+END_EXAMPLE


 


  在上例中， =wx://form-field= 代表一个内置 =behavior=
  ，它使得这个自定义组件有类似于表单控件的行为。

  内置 =behavior=
  往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的
  =type= 或添加 =observer= 。

***** [[index_u79.html#wx-form-field][#]] wx://form-field


  
 

  使自定义组件有类似于表单控件的行为。 form
  组件可以识别这些自定义组件，并在 submit
  事件中返回组件的字段名及其对应字段值。

  详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-form-field-group][#]] wx://form-field-group


  
 

  从基础库版本 [[../compatibility.html][2.10.2]] 开始提供支持。

  使 form 组件可以识别到这个自定义组件内部的所有表单控件。

  详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-form-field-button][#]] wx://form-field-button


  
 

  从基础库版本 [[../compatibility.html][2.10.3]] 开始提供支持。

  使 form 组件可以识别到这个自定义组件内部的 button
  。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form
  接受。

  详细用法以及代码示例可见：[[../../component/form][form 组件参考文档]]

***** [[index_u79.html#wx-component-export][#]] wx://component-export


  
 

  从基础库版本 [[../compatibility.html][2.2.3]] 开始提供支持。

  使自定义组件支持 =export= 定义段。这个定义段可以用于指定组件被
  =selectComponent= 调用时的返回值。

  详细用法以及代码示例可见：[[file:events][selectComponent 参考文档]]


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html]]

  \\
  \\




 













  --------------


 










*** [[index_u80.html#组件间关系][#]] 组件间关系


  
 

**** [[index_u80.html#定义和使用组件间关系][#]] 定义和使用组件间关系


  
 

  有时需要实现这样的组件：





  #+BEGIN_EXAMPLE
      <custom-ul>
        <custom-li> item 1 </custom-li>
        <custom-li> item 2 </custom-li>
      </custom-ul>
  #+END_EXAMPLE


 


  这个例子中， =custom-ul= 和 =custom-li=
  都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入
  =relations= 定义段，可以解决这样的问题。示例：

  [[https://developers.weixin.qq.com/s/0kfvzKm56NZy][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // path/to/custom-ul.js
      Component({
        relations: {
          './custom-li': {
            type: 'child', // 关联的目标节点应为子节点
            linked: function(target) {
              // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
            },
            linkChanged: function(target) {
              // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
            },
            unlinked: function(target) {
              // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
            }
          }
        },
        methods: {
          _getAllLi: function(){
            // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
            var nodes = this.getRelationNodes('path/to/custom-li')
          }
        },
        ready: function(){
          this._getAllLi()
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // path/to/custom-li.js
      Component({
        relations: {
          './custom-ul': {
            type: 'parent', // 关联的目标节点应为父节点
            linked: function(target) {
              // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
            },
            linkChanged: function(target) {
              // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
            },
            unlinked: function(target) {
              // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
            }
          }
        }
      })
  #+END_EXAMPLE


 


  *注意：必须在两个组件定义中都加入 relations 定义，否则不会生效。*

**** [[index_u80.html#关联一类组件][#]] 关联一类组件


  
 

  [[https://developers.weixin.qq.com/s/LFEVaqmh6zYU][在开发者工具中预览效果<<>>]]

  有时，需要关联的是一类组件，如：





  #+BEGIN_EXAMPLE
      <custom-form>
        <view>
          input
          <custom-input></custom-input>
        </view>
        <custom-submit> submit </custom-submit>
      </custom-form>
  #+END_EXAMPLE


 


  =custom-form= 组件想要关联 =custom-input= 和 =custom-submit=
  两个组件。此时，如果这两个组件都有同一个 behavior：





  #+BEGIN_EXAMPLE
      // path/to/custom-form-controls.js
      module.exports = Behavior({
        // ...
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // path/to/custom-input.js
      var customFormControls = require('./custom-form-controls')
      Component({
        behaviors: [customFormControls],
        relations: {
          './custom-form': {
            type: 'ancestor', // 关联的目标节点应为祖先节点
          }
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      // path/to/custom-submit.js
      var customFormControls = require('./custom-form-controls')
      Component({
        behaviors: [customFormControls],
        relations: {
          './custom-form': {
            type: 'ancestor', // 关联的目标节点应为祖先节点
          }
        }
      })
  #+END_EXAMPLE


 


  则在 =relations=
  关系定义中，可使用这个 behavior 来代替组件路径作为关联的目标节点：





  #+BEGIN_EXAMPLE
      // path/to/custom-form.js
      var customFormControls = require('./custom-form-controls')
      Component({
        relations: {
          'customFormControls': {
            type: 'descendant', // 关联的目标节点应为子孙节点
            target: customFormControls
          }
        }
      })
  #+END_EXAMPLE


 


**** [[index_u80.html#relations-定义段][#]] relations 定义段


  
 

  =relations= 定义段包含目标组件路径及其对应选项，可包含的选项见下表。





  | 选项          | 类型       | 是否必填   | 描述                                                                                                   |
  |---------------+------------+------------+--------------------------------------------------------------------------------------------------------|
  | type          | String     | 是         | 目标组件的相对关系，可选的值为 =parent= 、 =child= 、 =ancestor= 、 =descendant=                       |
  | linked        | Function   | 否         | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件 attached 生命周期之后                 |
  | linkChanged   | Function   | 否         | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件 moved 生命周期之后                  |
  | unlinked      | Function   | 否         | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件 detached 生命周期之后                       |



 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html]]

  \\
  \\




 













  --------------


 










*** [[index_u35.html#数据监听器][#]] 数据监听器


  
 

  数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本
  [[../compatibility.html][2.6.1]] 开始支持。

**** [[index_u35.html#使用数据监听器][#]] 使用数据监听器


  
 

  有时，在一些数据字段被 setData 设置时，需要执行一些操作。

  例如， =this.data.sum= 永远是 =this.data.numberA= 与 =this.data.numberB=
  的和。此时，可以使用数据监听器进行如下实现。





  #+BEGIN_EXAMPLE
      Component({
        attached: function() {
          this.setData({
            numberA: 1,
            numberB: 2,
          })
        },
        observers: {
          'numberA, numberB': function(numberA, numberB) {
            // 在 numberA 或者 numberB 被设置时，执行这个函数
            this.setData({
              sum: numberA + numberB
            })
          }
        }
      })
  #+END_EXAMPLE


 


  [[https://developers.weixin.qq.com/s/FUZF9ams7g6N][在开发者工具中预览效果<<>>]]

**** [[index_u35.html#监听字段语法][#]] 监听字段语法


  
 

  数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData
  最多触发每个监听器一次。

  同时，监听器可以监听子数据字段，如下例所示。





  #+BEGIN_EXAMPLE
      Component({
        observers: {
          'some.subfield': function(subfield) {
            // 使用 setData 设置 this.data.some.subfield 时触发
            // （除此以外，使用 setData 设置 this.data.some 也会触发）
            subfield === this.data.some.subfield
          },
          'arr[12]': function(arr12) {
            // 使用 setData 设置 this.data.arr[12] 时触发
            // （除此以外，使用 setData 设置 this.data.arr 也会触发）
            arr12 === this.data.arr[12]
          },
        }
      })
  #+END_EXAMPLE


 


  如果需要监听所有子数据字段的变化，可以使用通配符 =**= 。





  #+BEGIN_EXAMPLE
      Component({
        observers: {
          'some.field.**': function(field) {
            // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
            // （除此以外，使用 setData 设置 this.data.some 也会触发）
            field === this.data.some.field
          },
        },
        attached: function() {
          // 这样会触发上面的 observer
          this.setData({
            'some.field': { /* ... */ }
          })
          // 这样也会触发上面的 observer
          this.setData({
            'some.field.xxx': { /* ... */ }
          })
          // 这样还是会触发上面的 observer
          this.setData({
            'some': { /* ... */ }
          })
        }
      })
  #+END_EXAMPLE


 


  特别地，仅使用通配符 =**= 可以监听全部 setData 。





  #+BEGIN_EXAMPLE
      Component({
        observers: {
          '**': function() {
            // 每次 setData 都触发
          },
        },
      })
  #+END_EXAMPLE


 


  *Bugs & Tips:*

  -  数据监听器监听的是 setData
     涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
  -  如果在数据监听器函数中使用 setData
     设置本身监听的数据字段，可能会导致死循环，需要特别留意。
  -  数据监听器和属性的 observer
     相比，数据监听器更强大且通常具有更好的性能。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html]]

  \\
  \\




 













  --------------


 










*** [[index_u48.html#纯数据字段][#]] 纯数据字段


  
 

  纯数据字段是一些不用于界面渲染的 data
  字段，可以用于提升页面更新性能。从小程序基础库版本
  [[../compatibility.html][2.8.2]] 开始支持。

**** [[index_u48.html#组件数据中的纯数据字段][#]] 组件数据中的纯数据字段


  
 

  有些情况下，某些 =data= 中的字段（包括 =setData=
  设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

  此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在
  =this.data= 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

  指定“纯数据字段”的方法是在 =Component= 构造器的 =options= 定义段中指定
  =pureDataPattern=
  为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

  [[https://developers.weixin.qq.com/s/DKWiBXmb7jaB][在开发者工具中预览效果<<>>]]

  *代码示例：*





  #+BEGIN_EXAMPLE
      Component({
        options: {
          pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
        },
        data: {
          a: true, // 普通数据字段
          _b: true, // 纯数据字段
        },
        methods: {
          myMethod() {
            this.data._b // 纯数据字段可以在 this.data 中获取
            this.setData({
              c: true, // 普通数据字段
              _d: true, // 纯数据字段
            })
          }
        }
      })
  #+END_EXAMPLE


 


  上述组件中的纯数据字段不会被应用到 WXML 上：





  #+BEGIN_EXAMPLE
      <view wx:if="{{a}}"> 这行会被展示 </view>
      <view wx:if="{{_b}}"> 这行不会被展示 </view>
  #+END_EXAMPLE


 


**** [[index_u48.html#组件属性中的纯数据字段][#]] 组件属性中的纯数据字段


  
 

  属性也可以被指定为纯数据字段（遵循 =pureDataPattern= 的正则表达式）。

  属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的
  WXML 中。

  *代码示例：*





  #+BEGIN_EXAMPLE
      Component({
        options: {
          pureDataPattern: /^_/
        },
        properties: {
          a: Boolean,
          _b: {
            type: Boolean,
            observer() {
              // 不要这样做！这个 observer 永远不会被触发
            }
          },
        }
      })
  #+END_EXAMPLE


 


  注意：属性中的纯数据字段的属性 observer
  永远不会触发！如果想要监听属性值变化，使用
  [[file:observer.html][数据监听器]] 代替。

  从小程序基础库版本 [[../compatibility.html][2.10.1]]
  开始，也可以在页面或自定义组件的 json 文件中配置 =pureDataPattern=
  （这样就不需在 js 文件的 =options=
  中再配置）。此时，其值应当写成字符串形式：





  #+BEGIN_EXAMPLE
      {
        "pureDataPattern": "^_"
      }
  #+END_EXAMPLE


 


**** [[index_u48.html#使用数据监听器监听纯数据字段][#]]
  使用数据监听器监听纯数据字段


  
 

  [[file:observer.html][数据监听器]]
  可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

  下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

  [[https://developers.weixin.qq.com/s/fcWA1Xmd7tak][在开发者工具中预览效果<<>>]]

  *代码示例：*





  #+BEGIN_EXAMPLE
      Component({
        options: {
          pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
        },
        properties: {
          timestamp: Number,
        },
        observers: {
          timestamp: function () {
            // timestamp 被设置时，将它展示为可读时间字符串
            var timeString = new Date(this.data.timestamp).toLocaleString()
            this.setData({
              timeString: timeString
            })
          }
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <view>{{timeString}}</view>
  #+END_EXAMPLE


 



 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html]]

  \\
  \\




 













  --------------


 










*** [[index_u28.html#抽象节点][#]] 抽象节点


  
 

  这个特性自小程序基础库版本 [[../compatibility.html][1.9.6]] 开始支持。

**** [[index_u28.html#在组件中使用抽象节点][#]] 在组件中使用抽象节点


  
 

  有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

  例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的
  wxml 可以这样编写：

  *代码示例：*

  [[https://developers.weixin.qq.com/s/ztPzoImW7E7P][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      <!-- selectable-group.wxml -->
      <view wx:for="{{labels}}">
        <label>
          <selectable disabled="{{false}}"></selectable>
          {{item}}
        </label>
      </view>
  #+END_EXAMPLE


 


  其中，“selectable”不是任何在 json 文件的 =usingComponents=
  字段中声明的组件，而是一个抽象节点。它需要在 =componentGenerics=
  字段中声明：





  #+BEGIN_EXAMPLE
      {
        "componentGenerics": {
          "selectable": true
        }
      }
  #+END_EXAMPLE


 


**** [[index_u28.html#使用包含抽象节点的组件][#]] 使用包含抽象节点的组件


  
 

  在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件：





  #+BEGIN_EXAMPLE
      <selectable-group generic:selectable="custom-radio" />
  #+END_EXAMPLE


 


  这样，在生成这个 selectable-group
  组件的实例时，“selectable”节点会生成“custom-radio”组件实例。类似地，如果这样使用：





  #+BEGIN_EXAMPLE
      <selectable-group generic:selectable="custom-checkbox" />
  #+END_EXAMPLE


 


  “selectable”节点则会生成“custom-checkbox”组件实例。

  注意：上述的 =custom-radio= 和 =custom-checkbox= 需要包含在这个 wxml
  对应 json 文件的 =usingComponents= 定义段中。





  #+BEGIN_EXAMPLE
      {
        "usingComponents": {
          "custom-radio": "path/to/custom/radio",
          "custom-checkbox": "path/to/custom/checkbox"
        }
      }
  #+END_EXAMPLE


 


**** [[index_u28.html#抽象节点的默认组件][#]] 抽象节点的默认组件


  
 

  抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在
  =componentGenerics= 字段中指定：





  #+BEGIN_EXAMPLE
      {
        "componentGenerics": {
          "selectable": {
            "default": "path/to/default/component"
          }
        }
      }
  #+END_EXAMPLE


 


  *Tips:*

  -  节点的 generic 引用 =generic:xxx="yyy"= 中，值 =yyy=
     只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/generics.html]]

  \\
  \\




 













  --------------


 










*** [[index_u8.html#自定义组件扩展][#]] 自定义组件扩展


  
 

  为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本
  [[../compatibility.html][2.2.3]] 开始支持。

**** [[index_u8.html#扩展后的效果][#]] 扩展后的效果


  
 

  为了更好的理解扩展后的效果，先举一个例子：

  [[https://developers.weixin.qq.com/s/STePQRmH7Q5H][在开发者工具中预览效果<<>>]]





  #+BEGIN_EXAMPLE
      // behavior.js
      module.exports = Behavior({
        definitionFilter(defFields) {
          defFields.data.from = 'behavior'
        },
      })

      // component.js
      Component({
        data: {
          from: 'component'
        },
        behaviors: [require('behavior.js')],
        ready() {
          console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
        }
      })
  #+END_EXAMPLE


 


  通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，上述例子就是修改了自定义组件中的
  =data= 定义段里的内容。

**** [[index_u8.html#使用扩展][#]] 使用扩展


  
 

  =Behavior()= 构造器提供了新的定义段 =definitionFilter=
  ，用于支持自定义组件扩展。 =definitionFilter=
  是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的
  component/behavior 的定义对象，第二个参数是该 behavior 所使用的 behavior
  的 =definitionFilter= 函数列表。

  以下举个例子来说明：





  #+BEGIN_EXAMPLE
      // behavior3.js
      module.exports = Behavior({
          definitionFilter(defFields, definitionFilterArr) {},
      })

      // behavior2.js
      module.exports = Behavior({
        behaviors: [require('behavior3.js')],
        definitionFilter(defFields, definitionFilterArr) {
          // definitionFilterArr[0](defFields)
        },
      })

      // behavior1.js
      module.exports = Behavior({
        behaviors: [require('behavior2.js')],
        definitionFilter(defFields, definitionFilterArr) {},
      })

      // component.js
      Component({
        behaviors: [require('behavior1.js')],
      })
  #+END_EXAMPLE


 


  上述代码中声明了 1 个自定义组件和 3 个 behavior，每个 behavior 都使用了
  =definitionFilter= 定义段。那么按照声明的顺序会有如下事情发生：

  1. 当进行 behavior2 的声明时就会调用 behavior3 的 =definitionFilter=
     函数，其中 =defFields= 参数是 behavior2 的定义段，
     =definitionFilterArr= 参数即为空数组，因为 behavior3 没有使用其他的
     behavior 。
  2. 当进行 behavior1 的声明时就会调用 behavior2 的 =definitionFilter=
     函数，其中 =defFields= 参数是 behavior1 的定义段，
     =definitionFilterArr=
     参数是一个长度为 1 的数组，=definitionFilterArr[0]= 即为 behavior3 的
     =definitionFilter= 函数，因为 behavior2 使用了
     behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用
     behavior3 的 =definitionFilter= 函数，如果需要调用，在此处补充代码
     =definitionFilterArr[0](defFields)= 即可，=definitionFilterArr=
     参数会由基础库补充传入。
  3. 同理，在进行 component 的声明时就会调用 behavior1 的
     =definitionFilter= 函数。

  简单概括，=definitionFilter= 函数可以理解为当 A 使用了 B 时，A
  声明就会调用 B 的 =definitionFilter= 函数并传入 A 的定义对象让 B
  去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和
  D 的 =definitionFilter= 函数去过滤 A 的定义对象。

  *代码示例：*

  [[https://developers.weixin.qq.com/s/WaqPbxmN7E1j][在开发者工具中预览效果<<>>]]

**** [[index_u8.html#真实案例][#]] 真实案例


  
 

  下面利用扩展简单实现自定义组件的计算属性功能:





  #+BEGIN_EXAMPLE
      // behavior.js
      module.exports = Behavior({
        lifetimes: {
          created() {
            this._originalSetData = this.setData // 原始 setData
            this.setData = this._setData // 封装后的 setData
          }
        },
        definitionFilter(defFields) {
          const computed = defFields.computed || {}
          const computedKeys = Object.keys(computed)
          const computedCache = {}

          // 计算 computed
          const calcComputed = (scope, insertToData) => {
            const needUpdate = {}
            const data = defFields.data = defFields.data || {}

            for (let key of computedKeys) {
              const value = computed[key].call(scope) // 计算新值
              if (computedCache[key] !== value) needUpdate[key] = computedCache[key] = value
              if (insertToData) data[key] = needUpdate[key] // 直接插入到 data 中，初始化时才需要的操作
            }

            return needUpdate
          }

          // 重写 setData 方法
          defFields.methods = defFields.methods || {}
          defFields.methods._setData = function (data, callback) {
            const originalSetData = this._originalSetData // 原始 setData
            originalSetData.call(this, data, callback) // 做 data 的 setData
            const needUpdate = calcComputed(this) // 计算 computed
            originalSetData.call(this, needUpdate) // 做 computed 的 setData
          }

          // 初始化 computed
          calcComputed(defFields, true) // 计算 computed
        }
      })
  #+END_EXAMPLE


 


  在组件中使用：





  #+BEGIN_EXAMPLE
      const beh = require('./behavior.js')
      Component({
        behaviors: [beh],
        data: {
          a: 0,
        },
        computed: {
          b() {
            return this.data.a + 100
          },
        },
        methods: {
          onTap() {
            this.setData({
              a: ++this.data.a,
            })
          }
        }
      })
  #+END_EXAMPLE


 






  #+BEGIN_EXAMPLE
      <view>data: {{a}}</view>
      <view>computed: {{b}}</view>
      <button bindtap="onTap">click</button>
  #+END_EXAMPLE


 


  实现原理很简单，对已有的 setData 进行二次封装，在每次 setData
  的时候计算出 computed 里各字段的值，然后设到 data
  中，已达到计算属性的效果。

  #+BEGIN_QUOTE
    此实现只是作为一个简单案例来展示，请勿直接在生产环境中使用。
  #+END_QUOTE

**** [[index_u8.html#官方扩展包][#]] 官方扩展包


  
 

  -  [[https://github.com/wechat-miniprogram/computed][computed<<>>]]


 



 






  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html]]

  \\
  \\




 













  --------------


 










*** [[index_u83.html#开发第三方自定义组件][#]] 开发第三方自定义组件


  
 

  小程序从基础库版本 [[../compatibility.html][2.2.1]] 开始支持使用 npm
  安装第三方包，因此也支持开发和使用第三方自定义组件包。关于 npm
  功能的详情可先阅读[相关文档]((npm 支持))。

**** [[index_u83.html#准备][#]] 准备


  
 

  开发一个开源的自定义组件包给他人使用，首先需要明确他人是要如何使用这个包的，如果只是拷贝小程序目录下直接使用的话，可以跳过此文档。此文档中后续内容是以
  npm 管理自定义组件包的前提下进行说明的。

  在开发之前，要求开发者具有基础的 node.js 和 npm
  相关的知识，同时需要准备好支持 npm
  功能的开发者工具，[[../../devtools/download.html][点此下载]]。

**** [[index_u83.html#下载模板][#]] 下载模板


  
 

  为了方便开发者能够快速搭建好一个可用于开发、调试、测试的自定义组件包项目，官方提供了一个[[https://github.com/wechat-miniprogram/miniprogram-custom-component][项目模板<<>>]]，下载使用模板的方式有三种：

  -  直接从 github 上下载 zip 文件并解压。
  -  直接将 github 上的仓库 clone 下来。
  -  使用官方提供的命令行工具初始化项目，下面会进行介绍。

  项目模板中的构建是基于 gulp + webpack
  来执行的，支持开发、构建、测试等命令，详情可参阅项目模板的
  [[https://github.com/wechat-miniprogram/miniprogram-custom-component/blob/master/README.md][README.md<<>>]]
  文件。

**** [[index_u83.html#命令行工具][#]] 命令行工具
   
  
 


  官方提供了[[https://github.com/wechat-miniprogram/miniprogram-cli][命令行工具<<>>]]，用于快速初始化一个项目。执行如下命令安装命令行工具：





  #+BEGIN_EXAMPLE
      npm install -g @wechat-miniprogram/miniprogram-cli
  #+END_EXAMPLE





  然后新建一个空目录作为项目根目录，在此根目录下执行：





  #+BEGIN_EXAMPLE
      miniprogram init --type custom-component
  #+END_EXAMPLE





  命令执行完毕后会发现项目根目录下生成了许多文件，这是根据官方的[[https://github.com/wechat-miniprogram/miniprogram-custom-component][项目模板<<>>]]生成的完整项目，之后开发者可直接在此之上进行开发修改。

  命令行工具的更多用法可以查看 github 仓库上的
  [[https://github.com/wechat-miniprogram/miniprogram-cli/blob/master/README.md][README.md<<>>]]
  文件。

  #+BEGIN_QUOTE
    PS：第一次使用 =miniprogram init= 初始化项目会去 github
    上拉取模板，因此需要保证网络畅通。
  #+END_QUOTE

**** [[index_u83.html#测试工具][#]] 测试工具
  
  
 


  针对自定义组件的单元测试，可参阅文档[[file:unit-test.html][单元测试]]。

**** [[index_u83.html#自定义组件示例][#]] 自定义组件示例
  
  
 


  以下为官方提供的自定义组件，可以参考并使用：

  -  [[https://github.com/wechat-miniprogram/weui-miniprogram][weui-miniprogram<<>>]]
  -  [[https://github.com/wechat-miniprogram/recycle-view][recycle-view<<>>]]

**** [[index_u83.html#自定义组件扩展示例][#]] 自定义组件扩展示例
  
  
 


  以下为官方提供的自定义组件扩展，可以参考并使用：

  -  [[https://github.com/wechat-miniprogram/computed][computed<<>>]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/trdparty.html]]

  \\
  \\







  <<index.html>>










  --------------













*** [[index.html#单元测试][#]] 单元测试
  
  
 


  在编写高质量的自定义组件过程中，单元测试是永远避不开的一个话题。完善的测试用例是提高自定义组件可用性的保证，同时测试代码覆盖率也是必不可少的一个环节。小程序从基础库版本
  [[../compatibility.html][2.2.1]] 开始拥抱开源，支持使用 npm
  安装自定义组件，那针对自定义组件的单元测试也是必须支持的。

  以下就来介绍如何对自定义组件进行单元测试。

**** [[index.html#测试框架][#]] 测试框架
  
  
 


  现在市面上流行的测试框架均可使用，只要它能兼顾 nodejs 端和 dom
  环境。因为我们需要依赖到 nodejs 的一些库来完善测试环境，同时 dom
  环境也是必须的，因为我们需要建成完整的 dom
  树结构，才能更好的模拟自定义组件的运行。例如可以选用 mocha + jsdom
  的组合，亦可选用 jest，下述例子选用 jest 作为测试框架来说明。

**** [[index.html#自定义组件测试工具集][#]] 自定义组件测试工具集
  
  
 


  小程序的运行环境比较特殊，不同于常见的浏览器环境，它采用的是双线程的架构。而在进行单元测试时，我们并不需要用到这样复杂的架构带来的利好，我们进行的是功能测试而无需苛求性能、安全等因素，因此我们提供了一个测试工具集以支持自定义组件在
  nodejs 单线程中也能运行起来。

  我们先安装一下测试工具集------[[https://github.com/wechat-miniprogram/miniprogram-simulate][miniprogram-simulate<<>>]]：





  #+BEGIN_EXAMPLE
      npm i --save-dev miniprogram-simulate
  #+END_EXAMPLE





**** [[index.html#编写测试用例][#]] 编写测试用例
  
  
 


  假设我们有如下自定义组件：





  #+BEGIN_EXAMPLE
      <!-- /components/index.wmxl -->
      <view class="index">{{prop}}</view>
  #+END_EXAMPLE









  #+BEGIN_EXAMPLE
      // /components/index.js
      Component({
        properties: {
          prop: {
            type: String,
            value: 'index.properties'
          },
        },
      })
  #+END_EXAMPLE









  #+BEGIN_EXAMPLE
      /* /components/index.wxss */
      .index {
        color: green;
      }
  #+END_EXAMPLE





  我们想要测试渲染的结果，可以按照如下方式编写测试用例：





  #+BEGIN_EXAMPLE
      // /test/components/index.test.js
      const simulate = require('miniprogram-simulate')

      test('components/index', () => {
          const id = simulate.load('/components/index') // 此处必须传入绝对路径
          const comp = simulate.render(id) // 渲染成自定义组件树实例

          const parent = document.createElement('parent-wrapper') // 创建父亲节点
          comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子

          const view = comp.querySelector('.index') // 获取子组件 view
          expect(view.dom.innerHTML).toBe('index.properties') // 测试渲染结果
          expect(window.getComputedStyle(view.dom).color).toBe('green') // 测试渲染结果
      })
  #+END_EXAMPLE





  #+BEGIN_QUOTE
    PS：测试工具集中的 wx
    对象和内置组件都不会实现真正的功能，如果需要测试一些特殊场景的话，可以自行覆盖掉测试工具集中的
    api 接口和内置组件。

    PS：目前因为有部分自定义组件功能仍未支持（如抽象节点等），故测试工具暂无法全部覆盖自定义组件的特性，后续会继续完善。
  #+END_QUOTE

  测试工具集中提供了一些方便测试的接口，比如：

  -  模拟 touch 事件、自定义事件触发
  -  选取子节点
  -  更新自定义组件数据
  -  触发生命周期
  -  ...

  更多详细的用法可以参阅
  [[https://github.com/wechat-miniprogram/miniprogram-simulate][github
  仓库<<>>]]上的文档。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html]]

  \\
  \\


















  --------------













*** [[index_u11.html#获取更新性能统计信息][#]] 获取更新性能统计信息
  
  
 


  #+BEGIN_QUOTE
    基础库 2.12.0
    开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  如果想要知道 setData
  引发界面更新的开销，可以使用更新性能统计信息接口。它将返回每次更新中主要更新步骤发生的时间戳，可以用来大体上估计自定义组件（或页面）更新性能。例如：





  #+BEGIN_EXAMPLE
      Component({
        attached() { // 调用时机不能早于 attached
          this.setUpdatePerformanceListener({withDataPaths: true}, (res) => {
            console.log(res)
          })
        }
      })
  #+END_EXAMPLE





  =setUpdatePerformanceListener= 方法接受一个 =options= 对象和回调函数
  =listener= 作为参数。

  其中， =options= 对象包含以下字段：





  | 字段            | 类型      | 说明                           |
  |-----------------+-----------+--------------------------------|
  | withDataPaths   | Boolean   | 是否返回变更的 data 字段信息   |





  =listeners= 返回携带一个 =res= 对象，表示一次由 setData 引发的
  *更新过程* 。根据 setData 调用时机的不同，更新过程大体可以分为三类：

  1. *基本更新* ，它有一个唯一的 =updateProcessId= ；
  2. *子更新* ，它是另一个基本更新的一个子步骤，也有唯一的
     =updateProcessId= ，但还有一个 =parentUpdateProcessId= ；
  3. *被合并更新*
     ，它被合并到了另一个基本更新或子更新过程中，无法被独立统计。

  每次成功的 setData 调用都会产生一个更新过程，使得 =listener=
  回调一次。不过 setData
  究竟触发了哪类更新过程很难判断，更新性能好坏与其具体是哪类更新也没有必然联系，只是它们的返回值参数有所不同。

  =res= 中包含以下字段：





  | 字段                    | 类型      | 说明                                                                       |
  |-------------------------+-----------+----------------------------------------------------------------------------|
  | updateProcessId         | Number    | 此次更新过程的 ID                                                          |
  | parentUpdateProcessId   | Number    | 对于子更新，返回它所属的更新过程 ID                                        |
  | isMergedUpdate          | Boolean   | 是否是被合并更新，如果是，则 =updateProcessId= 表示被合并到的更新过程 ID   |
  | dataPaths               | Array     | 此次更新的 data 字段信息，只有 =withDataPaths= 设为 =true= 时才会返回      |
  | pendingStartTimestamp   | Number    | 此次更新进入等待队列时的时间戳                                             |
  | updateStartTimestamp    | Number    | 更新运算开始时的时间戳                                                     |
  | updateEndTimestamp      | Number    | 更新运算结束时的时间戳                                                     |





  说明：

  -  =setUpdatePerformanceListener= 只会激活当前组件或页面的统计，
     =parentUpdateProcessId= 有可能是其他组件或者页面的更新过程 ID
     而未被统计回调，如果想要知道页面内所有的更新过程，需要在所有组件中都调用
     =setUpdatePerformanceListener= ；
  -  统计本身有一点点开销，如果想要禁用统计，调用
     =setUpdatePerformanceListener= 时传入第二个参数 =listener= 为 =null=
     即可。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/update-perf-stat.html]]

  \\
  \\


















  --------------












** 插件
  
  
 


 插件的开发和使用自小程序基础库版本 [[../compatibility.html][1.9.6]]
 开始支持。（如果插件包含页面，则需要基础库版本
 [[../compatibility.html][2.1.0]] 。）

 插件是对一组 js
 接口、[[../custom-component][自定义组件]]或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。

 插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。

 相对于普通 js 文件或自定义组件，插件拥有更强的独立性，拥有独立的 API
 接口、域名列表等，但同时会受到一些限制，如[[file:api-limit.html][一些
 API
 无法调用或功能受限]]。还有个别特殊的接口，虽然插件不能直接调用，但可以使用
 [[file:functional-pages.html][插件功能页]] 来间接实现。

 同时，框架会对小程序和小程序使用的每个插件进行数据安全保护，保证它们之间不能窃取其他任何一方的数据（除非数据被主动传递给另一方）。

 对于插件开发者，请阅读[[file:development.html][开发插件]]章节；对于插件使用者，请阅读[[file:using.html][使用插件]]章节。













 --------------


 [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/]]

 \\
 \\


















 --------------













*** [[index_u25.html#开发插件][#]] 开发插件
  
  
 


  开发插件前，请阅读了解[[https://developers.weixin.qq.com/miniprogram/introduction/plugin.html][《小程序插件接入指南》<<>>]]了解开通流程及开放范围，并开通插件功能。如果未开通插件功能，将无法上传插件。

**** [[index_u25.html#创建插件项目][#]] 创建插件项目
  
  
 


  插件类型的项目可以在开发者工具中直接创建。[[../../devtools/plugin.html][详情]]

  [[file:feed_0/article_72/images/img1_u16.png]]

  新建插件类型的项目后，如果创建示例项目，则项目中将包含三个目录：

  -  =plugin= 目录：插件代码目录。
  -  =miniprogram= 目录：放置一个小程序，用于调试插件。
  -  =doc= 目录：用于放置插件开发文档。

  =miniprogram=
  目录内容可以当成普通小程序来编写，用于插件调试、预览和审核。下面的内容主要介绍
  =plugin= 中的插件代码及 =doc= 中的插件开发文档。

  我们提供了[[https://developers.weixin.qq.com/s/NrPCBmmT7B1B][一个可以直接在微信开发者工具中查看的完整插件示例<<>>]]，开发者可以和本文互相对照以便理解。请注意：

  1. 由于插件需要 appid 才能工作，请填入一个 appid；
  2. 由于当前代码片段的限制，打开该示例后请 *手动将 appid 填写到
     =miniprogram/app.json= 中（如下图）使示例正常运行。*

  [[file:feed_0/article_72/images/img2_u5.png]]

**** [[index_u25.html#插件目录结构][#]] 插件目录结构
  
  
 


  一个插件可以包含若干个自定义组件、页面，和一组 js
  接口。插件的目录内容如下：





  #+BEGIN_EXAMPLE
      plugin
      ├── components
      │   ├── hello-component.js   // 插件提供的自定义组件（可以有多个）
      │   ├── hello-component.json
      │   ├── hello-component.wxml
      │   └── hello-component.wxss
      ├── pages
      │   ├── hello-page.js        // 插件提供的页面（可以有多个，自小程序基础库版本 2.1.0 开始支持）
      │   ├── hello-page.json
      │   ├── hello-page.wxml
      │   └── hello-page.wxss
      ├── index.js                 // 插件的 js 接口
      └── plugin.json              // 插件配置文件
  #+END_EXAMPLE





**** [[index_u25.html#插件配置文件][#]] 插件配置文件
  
  
 


  向使用者小程序开放的所有自定义组件、页面和 js 接口都必须在插件配置文件
  =plugin.json= 列出，格式如下：

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "publicComponents": {
          "hello-component": "components/hello-component"
        },
        "pages": {
          "hello-page": "pages/hello-page"
        },
        "main": "index.js"
      }
  #+END_EXAMPLE





  这个配置文件将向使用者小程序开放一个自定义组件
  =hello-component=，一个页面 =hello-page= 和 =index.js= 下导出的所有 js
  接口。

**** [[index_u25.html#进行插件开发][#]] 进行插件开发
  
  
 


  请注意：在插件开发中，只有[[file:api-limit.html][部分接口]]可以直接调用；另外还有部分能力（如
  获取用户信息 和 发起支付
  等）可以通过[[file:functional-pages.html][插件功能页]]的方式使用。

***** [[index_u25.html#自定义组件][#]] 自定义组件
  
  
 


  插件可以定义若干个自定义组件，这些自定义组件都可以在插件内相互引用。但提供给使用者小程序使用的自定义组件必须在配置文件的
  =publicComponents= 段中列出（参考上文）。

  除去接口限制以外，自定义组件的编写和组织方式与一般的自定义组件相同，每个自定义组件由
  =wxml=, =wxss=, =js= 和 =json=
  四个文件组成。具体可以参考[[https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/][自定义组件的文档<<>>]]。

***** [[index_u25.html#页面][#]] 页面
  
  
 


  插件从小程序基础库版本 [[../compatibility.html][2.1.0]]
  开始支持页面。插件可以定义若干个插件页面，可以从本插件的自定义组件、其他页面中跳转，或从使用者小程序中跳转。所有页面必须在配置文件的
  =pages= 段中列出（参考上文）。

  除去接口限制以外，插件的页面编写和组织方式与一般的页面相同，每个页面由
  =wxml=, =wxss=, =js= 和 =json=
  四个文件组成。具体可以参考其他关于页面的文档。

  插件执行页面跳转的时候，可以使用 =navigator=
  组件。当插件跳转到自身页面时， =url=
  应设置为这样的形式：=plugin-private://PLUGIN_APPID/PATH/TO/PAGE=
  。需要跳转到其他插件时，也可以这样设置 =url= 。

  *代码示例：*





  #+BEGIN_EXAMPLE
      <navigator url="plugin-private://wxidxxxxxxxxxxxxxx/pages/hello-page">
        Go to pages/hello-page!
      </navigator>
  #+END_EXAMPLE





  自基础库版本 [[../compatibility.html][2.2.2]]
  开始，在插件自身的页面中，插件还可以调用
  [[../../api/route/wx.navigateTo.html][wx.navigateTo]] 来进行页面跳转，
  =url= 格式与使用 =navigator= 组件时相仿。

***** [[index_u25.html#接口][#]] 接口
  
  
 


  插件可以在接口文件（在配置文件中指定，详情见上文）中 export 一些 js
  接口，供插件的使用者调用，如：

  *代码示例：*





  #+BEGIN_EXAMPLE
      module.exports = {
        hello: function() {
          console.log('Hello plugin!')
        }
      }
  #+END_EXAMPLE





***** [[index_u25.html#获取小程序导出][#]] 获取小程序导出
  
  
 


  #+BEGIN_QUOTE
    [[https://developers.weixin.qq.com/s/GbXmMLml7vjC][在开发者工具中预览效果<<>>]]，需要手动填写一下
    =miniprogram/app.json= 中的插件 AppID
  #+END_QUOTE

  从基础库 [[../compatibility.html][2.11.1]] 起，在插件中有全局函数
  =requireMiniProgram=，可以获取由使用者小程序导出的内容。

  例如，使用者小程序做了如下导出：





  #+BEGIN_EXAMPLE
      // 使用者小程序
      module.exports = {
        greeting() {
          return 'Greetings from Weixin MiniProgram!';
        }
      }
  #+END_EXAMPLE





  那么在插件中，可以这样获得内容：





  #+BEGIN_EXAMPLE
      // 插件
      const miniProgramExports = requireMiniProgram();
      miniProgramExports.greeting(); // 'Greetings from Weixin MiniProgram!'
  #+END_EXAMPLE





  另外也可以 [[file:using.html#导出到插件][参考使用者小程序的相关文档]]

***** [[index_u25.html#引用小程序的自定义组件][#]] 引用小程序的自定义组件
  
  
 


  #+BEGIN_QUOTE
    [[https://developers.weixin.qq.com/s/QRRovLmu7Xjm][在开发者工具中预览效果<<>>]]，需要手动填写一下
    =miniprogram/app.json= 中的插件 AppID
  #+END_QUOTE

  有时，插件可能需要在页面或者自定义组件中，将一部分区域交给使用的小程序来渲染，因此需要能够引用小程序的自定义组件。但由于插件中不能直接指定小程序的自定义组件路径，因此无法直接通过
  =usingComponents= 的方式来引用。这里介绍通过
  [[../custom-component/generics.html][抽象节点（generics）]]
  来实现引用的方式。

  如果是插件自定义组件（例如 =plugin-view=），那么我们可以通过声明一个
  generic：





  #+BEGIN_EXAMPLE
      // plugin/components/plugin-view.json
      { "componentGenerics": { "mp-view": true } }
  #+END_EXAMPLE





  并在希望显示小程序组件的位置引用：





  #+BEGIN_EXAMPLE
      <!-- plugin/components/plugin-view.wxml -->
      <view>小程序组件：</view>
      <mp-view /><!-- 这里是一个小程序自定义组件 -->
  #+END_EXAMPLE





  在小程序中引用 =plugin-view= 时，就可以传递组件给插件进行渲染了：





  #+BEGIN_EXAMPLE
      <!-- miniprogram/page/index.wxml -->
      <plugin-view generic:mp-view="comp-from-miniprogram" />
  #+END_EXAMPLE





  如果是插件页，插件页本身就是一个页面顶层组件，小程序不会引用它，无法通过
  =generic:xxx=""= 的方式来指定抽象节点实现；因此，从基础库
  [[../compatibility.html][2.12.2]]
  起，小程序可以在插件的配置里为插件页指定抽象节点实现。例如插件页面名为
  =plugin-index=，则可以：





  #+BEGIN_EXAMPLE
      {
        "myPlugin": {
          "provider": "wxAPPID",
          "version": "1.0.0",
          "genericsImplementation": {
            "plugin-index": {
              "mp-view": "components/comp-from-miniprogram"
            }
          }
        }
      }
  #+END_EXAMPLE





  另外也可以
  [[file:using.html#为插件提供自定义组件][参考使用者小程序的相关文档]]

**** [[index_u25.html#预览、上传和发布][#]] 预览、上传和发布
  
  
 


  插件可以像小程序一样预览和上传，但插件没有体验版。

  插件会同时有多个线上版本，由使用插件的小程序决定具体使用的版本号。

  手机预览和提审插件时，会使用一个特殊的小程序来套用项目中 =miniprogram=
  文件夹下的小程序，从而预览插件。

  -  （建议的方式）如果当前开发者有[[../../devtools/sandbox.html][测试号]]，则会使用这个测试号；在测试号的设置页中可以看到测试号的
     =appid= 、 =appsecret= 并设置域名列表。
  -  否则，将使用“插件开发助手”，它具有一个特定的 =appid= 。

**** [[index_u25.html#在开发版小程序中测试][#]] 在开发版小程序中测试
  
  
 


  通常情况下，可以将 =miniprogram=
  下的代码当做使用插件的小程序代码，来进行插件的调试和测试。

  但有时，需要将插件的代码放在实际运行的小程序中进行调试、测试。此时，可以使用开发版的小程序直接引用开发版插件。方法如下：

  1. 在开发者工具的插件项目中上传插件，此时，在上传成功的通知信息中将包含这次上传获得的插件开发版
     ID （一个英文、数字组成的随机字符串）；
  2. 点击开发者工具右下角的通知按钮，可以打开通知栏，看到新生成的 ID ；
  3. 在使用这个插件的任意小程序项目中，可以将插件 version 设置为
     ="version": "dev-[开发版ID]"= 的形式，如
     ="version": "dev-abcdef0123456789abcdef0123456789"= ；
  4. 这样就会引用到这次上传的开发版插件；
  5. 注意，再次上传插件时， ID 可能会改变。

  如果开发版小程序引用了开发版插件，此时这个小程序就不能上传发布了。必须要将插件版本设为正式版本之后，小程序才可以正常上传、发布。

**** [[index_u25.html#插件开发文档][#]] 插件开发文档
  
  
 


  在使用者小程序使用插件时，插件代码并不可见。因此，除了插件代码，我们还支持插件开发者上传一份插件开发文档。这份开发文档将展示在插件详情页，供其他开发者在浏览插件和使用插件时进行阅读和参考。插件开发者应在插件开发文档中对插件提供的自定义组件、页面、接口等进行必要的描述和解释，方便使用者小程序正确使用插件。

  插件开发文档必须放置在插件项目根目录中的 =doc= 目录下，目录结构如下：





  #+BEGIN_EXAMPLE
      doc
      ├── README.md   // 插件文档，应为 markdown 格式
      └── picture.jpg // 其他资源文件，仅支持图片
  #+END_EXAMPLE





  其中，=README.md= 的编写有一定的 *限制条件*，具体来说：

  1. 引用到的图片资源不能是网络图片，且必须放在这个目录下；
  2. 文档中的链接只能链接到：

     -  微信开发者社区（developers.weixin.qq.com）
     -  微信公众平台（mp.weixin.qq.com）
     -  GitHub（github.com）

  编辑 =README.md= 之后，可以在开发者工具左侧资源管理器的文件栏中右键单击
  =README.md=，并选择上传文档。发布上传文档后，文档不会立刻发布。此时可以使用帐号和密码登录
  [[https://mp.weixin.qq.com][管理后台<<>>]] ，在 小程序插件 > 基本设置
  中预览、发布插件文档。

**** [[index_u25.html#其他注意事项][#]] 其他注意事项
  
  
 


***** [[index_u25.html#插件间互相调用][#]] 插件间互相调用
  
  
 


  插件不能直接引用其他插件。但如果小程序引用了多个插件，插件之间是可以互相调用的。

  一个插件调用另一个插件的方法，与插件调用自身的方法类似。可以使用
  =plugin-private://APPID= 访问插件的自定义组件、页面（暂不能使用
  =plugin://= ）。

  对于 js 接口，可使用 =requirePlugin= ，但目前尚不能在文件一开头就使用
  requirePlugin ，因为被依赖的插件可能还没有初始化，请考虑在更晚的时机调用
  =requirePlugin= ，如接口被实际调用时、组件 attached
  时。（未来会修复这个问题。）

***** [[index_u25.html#插件请求签名][#]] 插件请求签名
  
  
 


  插件在使用 [[../../api/network/request/wx.request.html][wx.request]] 等
  API 发送网络请求时，将会额外携带一个签名 =HostSign=
  ，用于验证请求来源于小程序插件。这个签名位于请求头中，形如：





  #+BEGIN_EXAMPLE
      X-WECHAT-HOSTSIGN: {"noncestr":"NONCESTR", "timestamp":"TIMESTAMP", "signature":"SIGNATURE"}
  #+END_EXAMPLE





  其中， =NONCESTR= 是一个随机字符串， =TIMESTAMP= 是生成这个随机字符串和
  =SIGNATURE= 的 UNIX 时间戳。它们是用于计算签名 =SIGNATRUE=
  的参数，签名算法为：





  #+BEGIN_EXAMPLE
      SIGNATURE = sha1([APPID, NONCESTR, TIMESTAMP, TOKEN].sort().join(''))
  #+END_EXAMPLE





  其中，=APPID= 是 *所在小程序* 的 AppId （可以从请求头的 =referrer=
  中获得）；=TOKEN= 是插件 Token，可以在小程序插件基本设置中找到。

  网络请求的 referer 格式固定为
  https://servicewechat.com/{appid}/{version}/page-frame.html，其中
  {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0
  表示为开发版、体验版以及审核版本，版本号为 devtools
  表示为开发者工具，其余为正式版本。

  插件开发者可以在服务器上按以下步骤校验签名：

  1. =sort= 对 =APPID= =NONCESTR= =TIMESTAMP= =TOKEN=
     四个值表示成字符串形式，按照字典序排序（同 JavaScript 数组的 sort
     方法）；
  2. =join= 将排好序的四个字符串直接连接在一起；
  3. 对连接结果使用 =sha1= 算法，其结果即 =SIGNATURE= 。

  自基础库版本 [[../compatibility.html][2.0.7]]
  开始，在小程序运行期间，若网络状况正常， =NONCESTR= 和 =TIMESTAMP= 会每
  10 分钟变更一次。如有必要，可以通过判断 =TIMESTAMP=
  来确定当前签名是否依旧有效。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html]]

  \\
  \\


















  --------------













*** [[index_u14.html#使用插件][#]] 使用插件
  
  
 


**** [[index_u14.html#添加插件][#]] 添加插件
  
  
 


  在使用插件前，首先要在小程序管理后台的“设置-第三方服务-插件管理”中添加插件。开发者可登录小程序管理后台，通过
  appid
  查找插件并添加。如果插件无需申请，添加后可直接使用；否则需要申请并等待插件开发者通过后，方可在小程序中使用相应的插件。

**** [[index_u14.html#引入插件代码包][#]] 引入插件代码包
  
  
 


  使用插件前，使用者要在 =app.json= 中声明需要使用的插件，例如：

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "plugins": {
          "myPlugin": {
            "version": "1.0.0",
            "provider": "wxidxxxxxxxxxxxxxxxx"
          }
        }
      }
  #+END_EXAMPLE





  如上例所示， =plugins=
  定义段中可以包含多个插件声明，每个插件声明以一个使用者自定义的插件引用名作为标识，并指明插件的
  appid 和需要使用的版本号。其中，引用名（如上例中的
  =myPlugin=）由使用者自定义，无需和插件开发者保持一致或与开发者协调。在后续的插件使用中，该引用名将被用于表示该插件。

**** [[index_u14.html#在分包内引入插件代码包][#]] 在分包内引入插件代码包
  
  
 


  如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如：





  #+BEGIN_EXAMPLE
      {
        "subpackages": [
          {
            "root": "packageA",
            "pages": [
              "pages/cat",
              "pages/dog"
            ],
            "plugins": {
              "myPlugin": {
                "version": "1.0.0",
                "provider": "wxidxxxxxxxxxxxxxxxx"
              }
            }
          }
        ]
      }
  #+END_EXAMPLE





  在分包内使用插件有如下限制：

  -  仅能在这个分包内使用该插件；
  -  同一个插件不能被多个分包同时引用；
  -  如果基础库版本低于 2.9.0
     ，不能从分包外的页面直接跳入分包内的插件页面，需要先跳入分包内的非插件页面、再跳入同一分包内的插件页面。

**** [[index_u14.html#使用插件-2][#]] 使用插件
  
  
 


  使用插件时，插件的代码对于使用者来说是不可见的。为了正确使用插件，使用者应查看插件详情页面中的“开发文档”一节，阅读由插件开发者提供的插件开发文档，通过文档来明确插件提供的自定义组件、页面名称及提供的
  js 接口规范等。

***** [[index_u14.html#自定义组件][#]] 自定义组件
  
  
 


  使用插件提供的自定义组件，和[[../custom-component][使用普通自定义组件]]的方式相仿。在
  =json= 文件定义需要引入的自定义组件时，使用 =plugin://=
  协议指明插件的引用名和自定义组件名，例如：

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "usingComponents": {
          "hello-component": "plugin://myPlugin/hello-component"
        }
      }
  #+END_EXAMPLE





  出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：

  -  默认情况下，页面中的 =this.selectComponent=
     接口无法获得插件的自定义组件实例对象；
  -  [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]
     等接口的 =>>>= 选择器无法选入插件内部。

***** [[index_u14.html#页面][#]] 页面
  
  
 


  插件的页面从小程序基础库版本 [[../compatibility.html][2.1.0]] 开始支持。

  需要跳转到插件页面时，=url= 使用 =plugin://= 前缀，形如
  =plugin://PLUGIN_NAME/PLUGIN_PAGE=， 如：

  *代码示例：*





  #+BEGIN_EXAMPLE
      <navigator url="plugin://myPlugin/hello-page">
        Go to pages/hello-page!
      </navigator>
  #+END_EXAMPLE





***** [[index_u14.html#js-接口][#]] js 接口
  
  
 


  使用插件的 js 接口时，可以使用 =requirePlugin=
  方法。例如，插件提供一个名为 =hello= 的方法和一个名为 =world=
  的变量，则可以像下面这样调用：





  #+BEGIN_EXAMPLE
      var myPluginInterface = requirePlugin('myPlugin');

      myPluginInterface.hello();
      var myWorld = myPluginInterface.world;
  #+END_EXAMPLE





***** [[index_u14.html#导出到插件][#]] 导出到插件
  
  
 


  #+BEGIN_QUOTE
    [[https://developers.weixin.qq.com/s/GbXmMLml7vjC][在开发者工具中预览效果<<>>]]，需要手动填写一下
    =miniprogram/app.json= 中的插件 AppID
  #+END_QUOTE

  从基础库 [[../compatibility.html][2.11.1]]
  起，使用插件的小程序可以导出一些内容，供插件获取。具体来说，在声明使用插件时，可以通过
  =export= 字段来指定一个文件，如：





  #+BEGIN_EXAMPLE
      {
        "myPlugin": {
          "version": "1.0.0",
          "provider": "wxidxxxxxxxxxxxxxxxx",
          "export": "index.js"
        }
      }
  #+END_EXAMPLE





  则该文件（上面的例子里是
  =index.js=）导出的内容可以被这个插件用全局函数获得。例如，在上面的文件中，使用插件的小程序做了如下导出：





  #+BEGIN_EXAMPLE
      // index.js
      module.exports = { whoami: 'Wechat MiniProgram' }
  #+END_EXAMPLE





  那么插件就可以获得上面导出的内容：





  #+BEGIN_EXAMPLE
      // plugin
      requireMiniProgram().whoami // 'Wechat MiniProgram'
  #+END_EXAMPLE





  具体导出什么内容，可以阅读插件开发文档，和插件的开发者做好约定。

  当插件在分包中时，这个特性也可以使用，但指定的文件的路径是相对于分包的。例如在
  =root: packageA= 的分包中指定了
  =export: exports/plugin.js=，那么被指定的文件在文件系统上应该是
  =/packageA/exports/plugin.js=。

  使用的多个插件的导出互不影响，两个插件可以导出同一个文件，也可以是不同的文件。但导出同一个文件时，如果一个插件对导出内容做了修改，那么另一个插件也会被影响，请注意这一点。

  *请谨慎导出 wx 对象或某个具体的 wx
  API，这将使插件可以以使用者小程序的身份调用 API。*

  另外也可以
  [[file:development.html#获取小程序导出][参考开发插件的相关文档]]

***** [[index_u14.html#为插件提供自定义组件][#]] 为插件提供自定义组件
  
  
 


  #+BEGIN_QUOTE
    [[https://developers.weixin.qq.com/s/QRRovLmu7Xjm][在开发者工具中预览效果<<>>]]，需要手动填写一下
    =miniprogram/app.json= 中的插件 AppID
  #+END_QUOTE

  有时，插件可能会在页面或者自定义组件中，将一部分区域交给使用的小程序来渲染，因此需要使用的小程序提供一个自定义组件。但由于插件中不能直接指定小程序的自定义组件路径，因此需要通过为插件指定
  [[../custom-component/generics.html][抽象节点（generics）]]
  的方式来提供。

  如果是插件的自定义组件需要指定抽象节点实现，可以在引用时指定：





  #+BEGIN_EXAMPLE
      <!-- miniprogram/page/index.wxml -->
      <plugin-view generic:mp-view="comp-from-miniprogram" />
  #+END_EXAMPLE





  从基础库 [[../compatibility.html][2.12.2]]
  起，可以通过配置项为插件页面指定抽象组件实现。例如，要给插件名为
  =plugin-index= 的页面中的抽象节点 =mp-view= 指定小程序的自定义组件
  =components/comp-from-miniprogram= 作为实现的话：





  #+BEGIN_EXAMPLE
      {
        "myPlugin": {
          "provider": "wxAPPID",
          "version": "1.0.0",
          "genericsImplementation": {
            "plugin-index": {
              "mp-view": "components/comp-from-miniprogram"
            }
          }
        }
      }
  #+END_EXAMPLE





  另外也可以
  [[file:development.html#引用小程序的自定义组件][参考开发插件的相关文档]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html]]

  \\
  \\


















  --------------













*** [[index_u50.html#插件调用-API-的限制][#]] 插件调用 API 的限制
  
  
 


  插件可以调用的 API 与小程序不同，主要有两个区别：

  -  插件的请求域名列表与小程序相互独立；
  -  一些 API 不允许插件调用（这些函数不存在于 =wx= 对象下）。

  有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考[[file:functional-pages.html][插件功能页]]。

  目前，允许插件调用的 API 及其对应版本要求如下：

***** [[index_u50.html#基础][#]] 基础
  
  
 






  | API                                                                      | 最低版本   | 备注   |
  |--------------------------------------------------------------------------+------------+--------|
  | [[../../api/base/wx.arrayBufferToBase64.html][wx.arrayBufferToBase64]]   |            |        |
  | [[../../api/base/wx.base64ToArrayBuffer.html][wx.base64ToArrayBuffer]]   |            |        |





***** [[index_u50.html#发起请求][#]] 发起请求
  
  
 






  | API                                                         | 最低版本                           | 备注   |
  |-------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/network/request/wx.request.html][wx.request]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#上传、下载][#]] 上传、下载
  
  
 






  | API                                                                    | 最低版本                           | 备注   |
  |------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]         | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#WebSocket][#]] WebSocket
  
  
 






  | API                                                                       | 最低版本                           | 备注   |
  |---------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#图片][#]] 图片
  
  
 






  | API                                                                                   | 最低版本                           | 备注   |
  |---------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/image/wx.previewImage.html][wx.previewImage]]                       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/image/wx.chooseImage.html][wx.chooseImage]]                         | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/image/wx.getImageInfo.html][wx.getImageInfo]]                       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/image/wx.saveImageToPhotosAlbum.html][wx.saveImageToPhotosAlbum]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#录音][#]] 录音
  
  
 






  | API                                                                | 最低版本                           | 备注   |
  |--------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/recorder/wx.startRecord.html][wx.startRecord]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/recorder/wx.stopRecord.html][wx.stopRecord]]     | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#实时音视频][#]] 实时音视频
  
  
 






  | API                                                                                    | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/live/wx.createLivePlayerContext.html][wx.createLivePlayerContext]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/live/wx.createLivePusherContext.html][wx.createLivePusherContext]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#录音管理][#]] 录音管理
  
  
 






  | API                                                                              | 最低版本                            | 备注   |
  |----------------------------------------------------------------------------------+-------------------------------------+--------|
  | [[../../api/media/recorder/wx.getRecorderManager.html][wx.getRecorderManager]]   | [[../compatibility.html][1.9.94]]   |        |





***** [[index_u50.html#音频播放控制][#]] 音频播放控制
  
  
 






  | API                                                           | 最低版本                           | 备注   |
  |---------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/audio/wx.pauseVoice.html][wx.pauseVoice]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/audio/wx.playVoice.html][wx.playVoice]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/audio/wx.stopVoice.html][wx.stopVoice]]     | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#音乐播放控制][#]] 音乐播放控制
  
  
 






  | API                                                                                                            | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/background-audio/wx.onBackgroundAudioPlay.html][wx.onBackgroundAudioPlay]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.getBackgroundAudioPlayerState.html][wx.getBackgroundAudioPlayerState]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.onBackgroundAudioStop.html][wx.onBackgroundAudioStop]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.stopBackgroundAudio.html][wx.stopBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.onBackgroundAudioPause.html][wx.onBackgroundAudioPause]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.seekBackgroundAudio.html][wx.seekBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.playBackgroundAudio.html][wx.playBackgroundAudio]]                       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/background-audio/wx.pauseBackgroundAudio.html][wx.pauseBackgroundAudio]]                     | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#背景音频播放管理][#]] 背景音频播放管理
  
  
 






  | API                                                                                                    | 最低版本                           | 备注   |
  |--------------------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/background-audio/wx.getBackgroundAudioManager.html][wx.getBackgroundAudioManager]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#音频组件控制][#]] 音频组件控制
  
  
 






  | API                                                                                     | 最低版本                           | 备注   |
  |-----------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/audio/wx.createInnerAudioContext.html][wx.createInnerAudioContext]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/audio/wx.createAudioContext.html][wx.createAudioContext]]             | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#视频][#]] 视频
  
  
 






  | API                                                                                   | 最低版本                           | 备注   |
  |---------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/video/wx.chooseVideo.html][wx.chooseVideo]]                         | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/media/video/wx.saveVideoToPhotosAlbum.html][wx.saveVideoToPhotosAlbum]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#视频组件控制][#]] 视频组件控制
  
  
 






  | API                                                                           | 最低版本                           | 备注   |
  |-------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/video/wx.createVideoContext.html][wx.createVideoContext]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#相机组件控制][#]] 相机组件控制
  
  
 






  | API                                                                              | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/camera/wx.createCameraContext.html][wx.createCameraContext]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#数据缓存][#]] 数据缓存
  
  
 






  | API                                                                     | 最低版本                           | 备注   |
  |-------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/storage/wx.setStorage.html][wx.setStorage]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/storage/wx.getStorage.html][wx.getStorage]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/storage/wx.removeStorage.html][wx.removeStorage]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]         | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/storage/wx.getStorageSync.html][wx.getStorageSync]]         | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/storage/wx.removeStorageSync.html][wx.removeStorageSync]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#获取位置][#]] 获取位置
  
  
 






  | API                                                                          | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/location/wx.getLocation.html][wx.getLocation]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/location/wx.chooseLocation.html][wx.chooseLocation]]             | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/location/wx.onLocationChange.html][wx.onLocationChange]]         | [[../compatibility.html][2.8.0]]   |        |
  | [[../../api/location/wx.offLocationChange.html][wx.offLocationChange]]       | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/location/wx.stopLocationUpdate.html][wx.stopLocationUpdate]]     | [[../compatibility.html][2.8.0]]   |        |
  | [[../../api/location/wx.startLocationUpdate.html][wx.startLocationUpdate]]   | [[../compatibility.html][2.8.0]]   |        |





***** [[index_u50.html#查看位置][#]] 查看位置
  
  
 






  | API                                                            | 最低版本                           | 备注   |
  |----------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/location/wx.openLocation.html][wx.openLocation]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#地图组件控制][#]] 地图组件控制
  
  
 






  | API                                                                     | 最低版本                           | 备注   |
  |-------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/media/map/wx.createMapContext.html][wx.createMapContext]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#系统信息][#]] 系统信息
  
  
 






  | API                                                                                     | 最低版本                           | 备注   |
  |-----------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/base/system/system-info/wx.getSystemInfoSync.html][wx.getSystemInfoSync]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/base/system/system-info/wx.getSystemInfo.html][wx.getSystemInfo]]           | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#屏幕亮度][#]] 屏幕亮度
  
  
 






  | API                                                                               | 最低版本                           | 备注   |
  |-----------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/screen/wx.setKeepScreenOn.html][wx.setKeepScreenOn]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/screen/wx.setScreenBrightness.html][wx.setScreenBrightness]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/screen/wx.getScreenBrightness.html][wx.getScreenBrightness]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#用户截屏事件][#]] 用户截屏事件
  
  
 






  | API                                                                                 | 最低版本                           | 备注                 |
  |-------------------------------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/device/screen/wx.onUserCaptureScreen.html][wx.onUserCaptureScreen]]     | [[../compatibility.html][1.9.6]]   | 仅限插件页面中调用   |
  | [[../../api/device/screen/wx.offUserCaptureScreen.html][wx.offUserCaptureScreen]]   | [[../compatibility.html][2.9.1]]   | 仅限插件页面中调用   |





***** [[index_u50.html#振动][#]] 振动
  
  
 






  | API                                                                  | 最低版本                           | 备注   |
  |----------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/vibrate/wx.vibrateLong.html][wx.vibrateLong]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/vibrate/wx.vibrateShort.html][wx.vibrateShort]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#手机联系人][#]] 手机联系人
  
  
 






  | API                                                                        | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/contact/wx.addPhoneContact.html][wx.addPhoneContact]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#NFC][#]] NFC
  
  
 






  | API                                                                  | 最低版本                           | 备注   |
  |----------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/nfc/wx.sendHCEMessage.html][wx.sendHCEMessage]]   | [[../compatibility.html][2.1.0]]   |        |
  | [[../../api/device/nfc/wx.stopHCE.html][wx.stopHCE]]                 | [[../compatibility.html][2.1.0]]   |        |
  | [[../../api/device/nfc/wx.onHCEMessage.html][wx.onHCEMessage]]       | [[../compatibility.html][2.1.0]]   |        |
  | [[../../api/device/nfc/wx.offHCEMessage.html][wx.offHCEMessage]]     | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/nfc/wx.startHCE.html][wx.startHCE]]               | [[../compatibility.html][2.1.0]]   |        |
  | [[../../api/device/nfc/wx.getHCEState.html][wx.getHCEState]]         | [[../compatibility.html][2.1.0]]   |        |





***** [[index_u50.html#网络状态][#]] 网络状态
  
  
 






  | API                                                                                      | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/network/wx.onNetworkStatusChange.html][wx.onNetworkStatusChange]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/network/wx.offNetworkStatusChange.html][wx.offNetworkStatusChange]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/network/wx.getNetworkType.html][wx.getNetworkType]]                   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#加速度计][#]] 加速度计
  
  
 






  | API                                                                                            | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/accelerometer/wx.startAccelerometer.html][wx.startAccelerometer]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/accelerometer/wx.stopAccelerometer.html][wx.stopAccelerometer]]             | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/accelerometer/wx.onAccelerometerChange.html][wx.onAccelerometerChange]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/accelerometer/wx.offAccelerometerChange.html][wx.offAccelerometerChange]]   | [[../compatibility.html][2.9.1]]   |        |





***** [[index_u50.html#设备方向][#]] 设备方向
  
  
 






  | API                                                                                             | 最低版本                           | 备注   |
  |-------------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/motion/wx.startDeviceMotionListening.html][wx.startDeviceMotionListening]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/motion/wx.stopDeviceMotionListening.html][wx.stopDeviceMotionListening]]     | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/motion/wx.offDeviceMotionChange.html][wx.offDeviceMotionChange]]             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/motion/wx.onDeviceMotionChange.html][wx.onDeviceMotionChange]]               | [[../compatibility.html][2.9.1]]   |        |





***** [[index_u50.html#陀螺仪][#]] 陀螺仪
  
  
 






  | API                                                                                | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/gyroscope/wx.startGyroscope.html][wx.startGyroscope]]           | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/gyroscope/wx.stopGyroscope.html][wx.stopGyroscope]]             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/gyroscope/wx.offGyroscopeChange.html][wx.offGyroscopeChange]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/gyroscope/wx.onGyroscopeChange.html][wx.onGyroscopeChange]]     | [[../compatibility.html][2.9.1]]   |        |





***** [[index_u50.html#罗盘][#]] 罗盘
  
  
 






  | API                                                                          | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/compass/wx.onCompassChange.html][wx.onCompassChange]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/compass/wx.offCompassChange.html][wx.offCompassChange]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/compass/wx.stopCompass.html][wx.stopCompass]]             | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/compass/wx.startCompass.html][wx.startCompass]]           | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#拨打电话][#]] 拨打电话
  
  
 






  | API                                                                  | 最低版本                           | 备注   |
  |----------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/phone/wx.makePhoneCall.html][wx.makePhoneCall]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#扫码][#]] 扫码
  
  
 






  | API                                                       | 最低版本                           | 备注   |
  |-----------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/scan/wx.scanCode.html][wx.scanCode]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#剪贴板][#]] 剪贴板
  
  
 






  | API                                                                            | 最低版本                           | 备注   |
  |--------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/clipboard/wx.setClipboardData.html][wx.setClipboardData]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/clipboard/wx.getClipboardData.html][wx.getClipboardData]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#蓝牙][#]] 蓝牙
  
  
 






  | API                                                                                                                    | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/bluetooth-ble/wx.writeBLECharacteristicValue.html][wx.writeBLECharacteristicValue]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.startBluetoothDevicesDiscovery.html][wx.startBluetoothDevicesDiscovery]]               | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.getConnectedBluetoothDevices.html][wx.getConnectedBluetoothDevices]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.notifyBLECharacteristicValueChange.html][wx.notifyBLECharacteristicValueChange]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.onBluetoothDeviceFound.html][wx.onBluetoothDeviceFound]]                               | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.offBluetoothDeviceFound.html][wx.offBluetoothDeviceFound]]                             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/bluetooth-ble/wx.readBLECharacteristicValue.html][wx.readBLECharacteristicValue]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.openBluetoothAdapter.html][wx.openBluetoothAdapter]]                                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.getBLEDeviceCharacteristics.html][wx.getBLEDeviceCharacteristics]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.stopBluetoothDevicesDiscovery.html][wx.stopBluetoothDevicesDiscovery]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.onBLEConnectionStateChange.html][wx.onBLEConnectionStateChange]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.getBluetoothDevices.html][wx.getBluetoothDevices]]                                     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.getBluetoothAdapterState.html][wx.getBluetoothAdapterState]]                           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.onBluetoothAdapterStateChange.html][wx.onBluetoothAdapterStateChange]]                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.offBluetoothAdapterStateChange.html][wx.offBluetoothAdapterStateChange]]               | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/bluetooth-ble/wx.getBLEDeviceServices.html][wx.getBLEDeviceServices]]                               | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.onBLECharacteristicValueChange.html][wx.onBLECharacteristicValueChange]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.offBLECharacteristicValueChange.html][wx.offBLECharacteristicValueChange]]         | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/bluetooth-ble/wx.createBLEConnection.html][wx.createBLEConnection]]                                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth/wx.closeBluetoothAdapter.html][wx.closeBluetoothAdapter]]                                 | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.closeBLEConnection.html][wx.closeBLEConnection]]                                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.notifyBLECharacteristicValueChange.html][wx.notifyBLECharacteristicValueChange]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.onBLEConnectionStateChange.html][wx.onBLEConnectionStateChange]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/bluetooth-ble/wx.offBLEConnectionStateChange.html][wx.offBLEConnectionStateChange]]                 | [[../compatibility.html][2.9.1]]   |        |





***** [[index_u50.html#iBeacon][#]] iBeacon
  
  
 






  | API                                                                                      | 最低版本                           | 备注   |
  |------------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/ibeacon/wx.getBeacons.html][wx.getBeacons]]                           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/ibeacon/wx.startBeaconDiscovery.html][wx.startBeaconDiscovery]]       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/ibeacon/wx.onBeaconServiceChange.html][wx.onBeaconServiceChange]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/ibeacon/wx.offBeaconServiceChange.html][wx.offBeaconServiceChange]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/ibeacon/wx.onBeaconUpdate.html][wx.onBeaconUpdate]]                   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/device/ibeacon/wx.offBeaconUpdate.html][wx.offBeaconUpdate]]                 | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/ibeacon/wx.stopBeaconDiscovery.html][wx.stopBeaconDiscovery]]         | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#Wi-Fi][#]] Wi-Fi
  
  
 






  | API                                                                       | 最低版本                           | 备注   |
  |---------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/device/wifi/wx.connectWifi.html][wx.connectWifi]]             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.getConnectedWifi.html][wx.getConnectedWifi]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.getWifiList.html][wx.getWifiList]]             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.offGetWifiList.html][wx.offGetWifiList]]       | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.offWifiConnected.html][wx.offWifiConnected]]   | [[../compatibility.html][2.9.1]]   |        |
  | [[file:%28wx.onEvaluateWifi%29][wx.onEvaluateWifi]]                       | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.onGetWifiList.html][wx.onGetWifiList]]         | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.onWifiConnected.html][wx.onWifiConnected]]     | [[../compatibility.html][2.9.1]]   |        |
  | [[file:%28wx.presetWifiList%29][wx.presetWifiList]]                       | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.setWifiList.html][wx.setWifiList]]             | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.startWifi.html][wx.startWifi]]                 | [[../compatibility.html][2.9.1]]   |        |
  | [[../../api/device/wifi/wx.stopWifi.html][wx.stopWifi]]                   | [[../compatibility.html][2.9.1]]   |        |





***** [[index_u50.html#交互反馈][#]] 交互反馈
  
  
 






  | API                                                                        | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/ui/interaction/wx.hideLoading.html][wx.hideLoading]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/ui/interaction/wx.showActionSheet.html][wx.showActionSheet]]   | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/ui/interaction/wx.showLoading.html][wx.showLoading]]           | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/ui/interaction/wx.hideToast.html][wx.hideToast]]               | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/ui/interaction/wx.showToast.html][wx.showToast]]               | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/ui/interaction/wx.showModal.html][wx.showModal]]               | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#设置导航条][#]] 设置导航条
  
  
 






  | API                                                                                             | 最低版本                           | 备注                 |
  |-------------------------------------------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/ui/navigation-bar/wx.showNavigationBarLoading.html][wx.showNavigationBarLoading]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/ui/navigation-bar/wx.hideNavigationBarLoading.html][wx.hideNavigationBarLoading]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/ui/navigation-bar/wx.setNavigationBarColor.html][wx.setNavigationBarColor]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/ui/navigation-bar/wx.setNavigationBarTitle.html][wx.setNavigationBarTitle]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |





***** [[index_u50.html#背景][#]] 背景
  
  
 






  | API                                                                                     | 最低版本                           | 备注                 |
  |-----------------------------------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/ui/background/wx.setBackgroundColor.html][wx.setBackgroundColor]]           | [[../compatibility.html][2.4.0]]   | 仅限插件页面中调用   |
  | [[../../api/ui/background/wx.setBackgroundTextStyle.html][wx.setBackgroundTextStyle]]   | [[../compatibility.html][2.4.0]]   | 仅限插件页面中调用   |





***** [[index_u50.html#WXML节点信息][#]] WXML 节点信息
  
  
 






  | API                                                                      | 最低版本                           | 备注   |
  |--------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/wxml/wx.createSelectorQuery.html][wx.createSelectorQuery]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#WXML节点布局相交状态][#]] WXML 节点布局相交状态
  
  
 






  | API                                                                                    | 最低版本                           | 备注   |
  |----------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/wxml/wx.createIntersectionObserver.html][wx.createIntersectionObserver]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#导航][#]] 导航
  
  
 






  | API                                                         | 最低版本                           | 备注                 |
  |-------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/route/wx.navigateBack.html][wx.navigateBack]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/route/wx.navigateTo.html][wx.navigateTo]]       | [[../compatibility.html][2.2.2]]   | 仅限插件页面中调用   |
  | [[../../api/route/wx.redirectTo.html][wx.redirectTo]]       | [[../compatibility.html][2.2.2]]   | 仅限插件页面中调用   |
  | [[../../api/route/wx.switchTab.html][wx.switchTab]]         | [[../compatibility.html][2.3.1]]   | 仅限插件页面中调用   |
  | [[../../api/route/wx.reLaunch.html][wx.reLaunch]]           | [[../compatibility.html][2.3.1]]   | 仅限插件页面中调用   |





***** [[index_u50.html#动画][#]] 动画
  
  
 






  | API                                                                      | 最低版本                           | 备注   |
  |--------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/ui/animation/wx.createAnimation.html][wx.createAnimation]]   | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#位置][#]] 位置
  
  
 






  | API                                                             | 最低版本                           | 备注                 |
  |-----------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/ui/scroll/wx.pageScrollTo.html][wx.pageScrollTo]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |





***** [[index_u50.html#绘图][#]] 绘图
  
  
 






  | API                                                                            | 最低版本                           | 备注   |
  |--------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/canvas/wx.createOffscreenCanvas.html][wx.createOffscreenCanvas]]   | [[../compatibility.html][2.7.1]]   |        |
  | [[../../api/canvas/wx.canvasPutImageData.html][wx.canvasPutImageData]]         | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/canvas/wx.canvasToTempFilePath.html][wx.canvasToTempFilePath]]     | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/canvas/wx.createCanvasContext.html][wx.createCanvasContext]]       | [[../compatibility.html][1.9.6]]   |        |
  | [[../../api/canvas/wx.canvasGetImageData.html][wx.canvasGetImageData]]         | [[../compatibility.html][1.9.6]]   |        |





***** [[index_u50.html#下拉刷新][#]] 下拉刷新
  
  
 






  | API                                                                                        | 最低版本                           | 备注                 |
  |--------------------------------------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/ui/pull-down-refresh/wx.stopPullDownRefresh.html][wx.stopPullDownRefresh]]     | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/ui/pull-down-refresh/wx.startPullDownRefresh.html][wx.startPullDownRefresh]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |





***** [[index_u50.html#当前帐号信息][#]] 当前帐号信息
  
  
 






  | API                                                                                     | 最低版本                           | 备注   |
  |-----------------------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/open-api/account-info/wx.getAccountInfoSync.html][wx.getAccountInfoSync]]   | [[../compatibility.html][2.2.2]]   |        |





***** [[index_u50.html#转发][#]] 转发
  
  
 






  | API                                                               | 最低版本                           | 备注                 |
  |-------------------------------------------------------------------+------------------------------------+----------------------|
  | [[../../api/share/wx.hideShareMenu.html][wx.hideShareMenu]]       | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/share/wx.getShareInfo.html][wx.getShareInfo]]         | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/share/wx.showShareMenu.html][wx.showShareMenu]]       | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |
  | [[../../api/share/wx.updateShareMenu.html][wx.updateShareMenu]]   | [[../compatibility.html][2.1.0]]   | 仅限插件页面中调用   |





***** [[index_u50.html#其他][#]] 其他
  
  
 






  | API                                                                                | 最低版本                            | 备注         |
  |------------------------------------------------------------------------------------+-------------------------------------+--------------|
  | [[../../api/open-api/setting/wx.getSetting.html][wx.getSetting]]                   | [[../compatibility.html][2.6.3]]    |              |
  | [[../../api/open-api/setting/wx.openSetting.html][wx.openSetting]]                 | [[../compatibility.html][2.10.3]]   |              |
  | [[../../api/open-api/data-analysis/wx.reportAnalytics.html][wx.reportAnalytics]]   | [[../compatibility.html][1.9.6]]    | 见下方备注   |





***** [[index_u50.html#登录和获取用户信息][#]] 登录和获取用户信息
  
  
 


  *这一组接口仅限在用户信息功能页中获得用户授权之后调用。否则将返回 fail
  。详见 [[file:functional-pages/user-info.html][用户信息功能页]] 。*





  | API                                                                    | 最低版本                           | 备注   |
  |------------------------------------------------------------------------+------------------------------------+--------|
  | [[../../api/open-api/login/wx.login.html][wx.login]]                   | [[../compatibility.html][2.3.1]]   |        |
  | [[../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]   | [[../compatibility.html][2.3.1]]   |        |





****** [[index_u50.html#Bugs-Tips][#]] Bugs & Tips
 
  
 


  -  [[../../api/open-api/data-analysis/wx.reportAnalytics.html][wx.reportAnalytics]]
     可以被正常调用，但目前不会进行统计展示。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html]]

  \\
  \\


















  --------------













*** [[index_u62.html#插件使用组件的限制][#]] 插件使用组件的限制
  
  
 


  在插件开发中，以下组件不能在插件页面中使用：

  -  开放能力（open-type）为以下之一的
     [[../../component/button.html][button]]：

     -  contact（打开客服会话）
     -  getPhoneNumber（获取用户手机号）
     -  getUserInfo（获取用户信息）

  -  [[../../component/open-data.html][open-data]]
  -  [[../../component/web-view.html][web-view]]

  以下组件的使用对基础库版本有要求：

  -  [[../../component/navigator.html][navigator]] 需要基础库版本
     [[../compatibility.html][2.1.0]]
  -  [[../../component/live-player.html][live-player]] 和
     [[../../component/live-pusher.html][live-pusher]] 需要基础库版本
     [[../compatibility.html][2.3.0]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/component-limit.html]]

  \\
  \\


















  --------------













*** [[index_u43.html#插件功能页][#]] 插件功能页
  
  
 


  插件功能页从小程序基础库版本 [[../compatibility.html][2.1.0]] 开始支持。

  某些接口不能在插件中直接调用（如
  [[../../api/open-api/login/wx.login.html][wx.login]]），但插件开发者可以使用插件功能页的方式来实现功能。目前，插件功能页包括：

  -  获取用户信息，包括 =openid= 和昵称等（相当于
     [[../../api/open-api/login/wx.login.html][wx.login]] 和
     [[../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
     的功能），详见[[file:functional-pages/user-info.html][用户信息功能页]]；
  -  支付（相当于
     [[../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]），详见[[file:functional-pages/request-payment.html][支付功能页]]；
  -  获取收货地址（相当于
     [[../../api/open-api/address/wx.chooseAddress.html][wx.chooseAddress]]），详见[[file:functional-pages/choose-address.html][收货地址功能页]]。

  要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  组件跳转到插件功能页，从而实现对应的功能。详情请参考下文。

****** [[index_u43.html#插件所有者小程序][#]] 插件所有者小程序
  
  
 


  开始开发之前，我们需要知道，插件功能页是指 *插件所有者小程序*
  中的一个特殊页面。

  *插件所有者小程序*，指的是与插件 AppID
  相同的小程序。例如，“小程序示例”小程序开发了一个“小程序示例插件”，那么无论这个插件被哪个小程序使用，这个插件的
  *插件所有者小程序* 都是“小程序示例”。下文中会继续使用 *插件所有者小程序*
  这个说法。

****** [[index_u43.html#插件所有者小程序开发方法][#]]
  插件所有者小程序开发方法
  
  
 


  通常，在开始使用插件功能页的时候，需要开启两个开发者工具窗口，其中一个打开插件项目，另一个打开插件所有者小程序的小程序项目。例如，一个打开“小程序示例插件”项目，另一个打开“小程序示例”项目。

  这两个窗口，前者用于编辑插件，后者用于编辑插件所有者小程序。下文中所有需要编辑插件所有者小程序的内容，都是在后者中进行。

**** [[index_u43.html#激活功能页特性][#]] 激活功能页特性
  
  
 


  要在插件中调用插件功能页，需要先激活插件所有者小程序的功能页特性。具体来说，在插件所有者小程序的
  =app.json= 文件中添加 =functionalPages= 定义段，并令其值为 =true=
  ，例如：

  *代码示例：*





  #+BEGIN_EXAMPLE
      {
        "functionalPages": {
          "independent": true
        }
      }
  #+END_EXAMPLE





  目前，兼容旧式写法：





  #+BEGIN_EXAMPLE
      {
        "functionalPages": true
      }
  #+END_EXAMPLE





  旧式写法将在未来将被移除支持，未来将不能编译上传。

  这两种写法的区别在于，新式的写法 ="independent": true=
  会使得插件功能页的代码独立于其他代码，这意味着插件功能页可以被独立下载、加载，具有更好的性能表现。
  但也同时使得插件功能页目录 =functional-pages/=
  （支付功能页会使用其中的文件）不能 require
  这个目录以外的文件（反之亦然：这个目录以外的文件也不能调用这个目录内的）。

  注意，新增或改变这个字段时，需要这个小程序发布新版本，才能在正式环境中使用插件功能页。

**** [[index_u43.html#跳转到功能页][#]] 跳转到功能页
  
  
 


  功能页不能使用 [[../../api/route/wx.navigateTo.html][wx.navigateTo]]
  来进行跳转，而是需要一个名为
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  的组件。以获取用户信息为例，可以在插件中放置如下的
  [[../../component/functional-page-navigator.html][functional-page-navigator]]：

  *代码示例：*





  #+BEGIN_EXAMPLE
      <functional-page-navigator name="loginAndGetUserInfo" args="" version="develop" bind:success="loginSuccess">
        <button>登录到插件</button>
      </functional-page-navigator>
  #+END_EXAMPLE





  用户在点击这个 =navigator=
  时，会自动跳转到插件所有者小程序的对应功能页。功能页会提示用户进行登录或其他相应的操作。操作结果会以组件事件的方式返回。

  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  的参数和详细使用方法可以参考[[../../component/functional-page-navigator.html][组件说明]]
  。

  从小程序基础库版本 [[../compatibility.html][2.4.0]]
  开始，支持插件所有者小程序跳转到自己的功能页。在基础库版本低于
  [[../compatibility.html][2.4.0]] 时，点击跳转到自己的功能页的
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  将没有任何反应。

**** [[index_u43.html#真机开发测试的常规步骤][#]] 真机开发测试的常规步骤
  
  
 


  目前，功能页的跳转目前不支持在开发者工具中调试，请在真机上测试。初次进行真机开发测试时，通常步骤如下：

  1. 在开发者工具上打开插件所有者小程序项目，并点击“预览”；
  2. 用测试用的真机扫一下预览二维码，此时会进入插件所有者小程序，进入后就可以直接退出这个小程序；
  3. 在开发者工具上打开插件项目，将插件中
     [[../../component/functional-page-navigator.html][functional-page-navigator]]
     中的 =version= 属性设置为 =develop=；
  4. 点击预览可以生成插件预览二维码，用测试用的真机扫码即可预览功能页；如果更改了插件代码，重新生成并扫描插件的预览二维码即可；
  5. 如果过了一段时间之后，跳转功能页时出现“开发版已过期”这样的提示，从第 1 步开始重试一次。

  *注意*：=functional-page-navigator= 的 =version=develop=
  仅用于调试，因此在插件提审前，需要：

  1. 确保已发布设置了 ="functionalPages": true= 的插件所有者小程序；
  2. 确保所有的 =functional-page-navigator= 组件属性设置为
     =version="release"= 。

**** [[index_u43.html#功能页常见问题-FAQ][#]] 功能页常见问题 FAQ
  
  
 


****** [[index_u43.html#如何正确编辑插件所有者小程序？][#]]
  如何正确编辑插件所有者小程序？
  
  
 


  -  应该在开发者工具的“小程序”类型项目中编辑，而不是在“插件”类型的项目中编辑。比如，“小程序示例插件”的所有者小程序是“小程序示例”，它们的
     AppID 都是 =wxidxxxxxxxxxxxxxx=
     ，如果是初次开发“小程序示例”小程序，可以在开发者工具中创建一个小程序项目，其
     AppID 为 =wxidxxxxxxxxxxxxxx=
     ；如果之前开发过“小程序示例”小程序，直接打开之前的小程序项目即可。

****** [[index_u43.html#点击-functional-page-navigator-之后没有任何反应。][#]]
  点击
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  之后没有任何反应。
  
  
 


  -  请检查引用插件的小程序和插件本身是不是同一个 AppID
     ，如果是，跳转到自己的功能页需要基础库
     [[../compatibility.html][2.4.0]] 支持，否则使用
     [[../../component/functional-page-navigator.html][functional-page-navigator]]
     不会有任何反应。

****** [[index_u43.html#点击-functional-page-navigator-之后，展示了一个页面提示“页面不存在”。][#]]
  点击
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  之后，展示了一个页面提示“页面不存在”。
  
  
 


  -  这种情况是因为插件所有者小程序没有正确设置 ="functionalPages": true=
     。如果 =functional-page-navigator= 的 =version="develop"=
     ，这部手机需要扫码并进入插件所有者小程序一次；如果
     =version="release"= ，请确保包含 ="functionalPages": true=
     的插件所有者小程序已被发布。

****** [[index_u43.html#点击-functional-page-navigator-version-develop-之后，弹窗提示“小程序开发版已过期”。][#]]
  点击 =<functional-page-navigator version="develop">=
  之后，弹窗提示“小程序开发版已过期”。
  
  
 


  -  遇到这种情况，重新扫码并进入插件所有者小程序一次即可。

****** [[index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，展示了一个页面提示“该功能无法使用”。][#]]
  点击 =<functional-page-navigator name="requestPayment">=
  之后，展示了一个页面提示“该功能无法使用”。
  
  
 


  -  在使用插件功能页时，小程序不能是个人小程序，同时，插件也需要额外的步骤申请开通插件支付权限（位于
     [[https://mp.weixin.qq.com][管理后台<<>>]] -> 小程序插件 -> 基本设置
     -> 支付能力 ）。

****** [[index_u43.html#点击-functional-page-navigator-name-requestPayment-之后，点击页面中的“支付”按钮，立刻退出了支付功能页。][#]]
  点击 =<functional-page-navigator name="requestPayment">=
  之后，点击页面中的“支付”按钮，立刻退出了支付功能页。
  
  
 


  -  这通常是因为没有找到功能页函数 =beforeRequestPayment=
     ，请检查插件所有者小程序的 =functional-pages/request-payment.js=
     文件和其中的 =beforeRequestPayment= 函数是否存在。

****** [[index_u43.html#点击-functional-page-navigator-之后，展示了一个仅有返回按钮的页面。][#]]
  点击
  [[../../component/functional-page-navigator.html][functional-page-navigator]]
  之后，展示了一个仅有返回按钮的页面。
  
  
 


  -  请检查
     [[../../component/functional-page-navigator.html][functional-page-navigator]]
     的 =name= 属性是否被正确设置。

****** [[index_u43.html#开发版可以正常跳转，但审核反馈不能跳转。][#]]
  开发版可以正常跳转，但审核反馈不能跳转。
  
  
 


  -  请发布设置了 ="functionalPages": true= 的插件所有者小程序，且所有的
     =functional-page-navigator= 组件属性设置为 =version="release"= 。

****** [[index_u43.html#Bugs-Tips][#]] Bugs & Tips
  
  
 


  -  功能页是插件所有者小程序中的一个特殊页面，开发者不能自定义这个页面的外观。
  -  插件所有者小程序本身也可以引用这个插件，此时，=functional-page-navigator=
     组件的 =version=
     属性将不会生效，而是取决于当前运行的插件所有者小程序的版本。
  -  [[../../component/functional-page-navigator.html][functional-page-navigator]]
     可以在开发者工具中使用，但功能页的跳转目前不支持在开发者工具中调试，请在真机上测试。
  -  Bug：在微信版本 6.6.7 中，功能页被拉起时会触发 App
     的部分生命周期并使得功能页启动时间变得比较长。在后续的微信版本中这一行为会发生变更，使
     App 生命周期不再被触发。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages.html]]

  \\
  \\


















  --------------













**** [[index_u34.html#用户信息功能页][#]] 用户信息功能页
  
  
 


   用户信息功能页用于帮助插件获取用户信息，包括 =openid= 和昵称等，相当于
   [[../../../api/open-api/login/wx.login.html][wx.login]] 和
   [[../../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
   的功能。

   此外，自基础库版本 [[../../compatibility.html][2.3.1]]
   起，用户在这个功能页中授权之后，插件就可以直接调用
   [[../../../api/open-api/login/wx.login.html][wx.login]] 和
   [[../../../api/open-api/user-info/wx.getUserInfo.html][wx.getUserInfo]]
   。无需再次进入功能页获取用户信息。自基础库版本
   [[../../compatibility.html][2.6.3]] 起，可以使用
   [[../../../api/open-api/setting/wx.getSetting.html][wx.getSetting]]
   来查询用户是否授权过。

***** [[index_u34.html#调用参数][#]] 调用参数
  
  
 


   用户信息功能页使用
   [[../../../component/functional-page-navigator.html][functional-page-navigator]]
   进行跳转时，对应的参数 name 应为固定值 =loginAndGetUserInfo=，其余参数与
   [[https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject][wx.getUserInfo<<>>]]
   相同，具体来说：

   *args 参数说明：*





   | 参数名            | 类型      | 必填   | 说明                                                                            |
   |-------------------+-----------+--------+---------------------------------------------------------------------------------|
   | withCredentials   | Boolean   | 否     | 是否带上登录态信息                                                              |
   | lang              | String    | 否     | 指定返回用户信息的语言，zh\_CN 简体中文，zh\_TW 繁体中文，en 英文。默认为 en。   |
   | timeout           | Number    | 否     | 超时时间，单位 ms                                                               |





   *注：当 withCredentials 为 true 时，返回的数据会包含 encryptedData, iv
   等敏感信息。*

   *bindsuccess 返回参数说明：*





   | 参数            | 类型     | 说明                                                                                                                                                                                |
   |-----------------+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | code            | String   | 同 [[../../../api/open-api/login/wx.login.html][wx.login]] 获得的用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 api，使用 code 换取 openid 和 session\_key 等信息   |
   | errMsg          | String   | 调用结果                                                                                                                                                                            |
   | userInfo        | OBJECT   | 用户信息对象，不包含 openid 等敏感信息                                                                                                                                              |
   | rawData         | String   | 不包括敏感信息的原始数据字符串，用于计算签名。                                                                                                                                      |
   | signature       | String   | 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，参考文档 [[../../open-ability/signature.html][signature]]。                                                         |
   | encryptedData   | String   | 包括敏感数据在内的完整用户信息的加密数据，详细见[[../../open-ability/signature.html][加密数据解密算法]]                                                                             |
   | iv              | String   | 加密算法的初始向量，详细见[[../../open-ability/signature.html][加密数据解密算法]]                                                                                                   |





   *userInfo 参数说明：*





   | 参数        | 类型     | 说明                                                                                                                                                            |
   |-------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | nickName    | String   | 用户昵称                                                                                                                                                        |
   | avatarUrl   | String   | 用户头像，最后一个数值代表正方形头像大小（有 0、46、64、96、132 数值可选，0代表 132*132 正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像 URL 将失效。   |
   | gender      | String   | 用户的性别，值为 1 时是男性，值为 2 时是女性，值为 0 时是未知                                                                                                         |
   | city        | String   | 用户所在城市                                                                                                                                                    |
   | province    | String   | 用户所在省份                                                                                                                                                    |
   | country     | String   | 用户所在国家                                                                                                                                                    |
   | language    | String   | 用户的语言，简体中文为 zh\_CN                                                                                                                                    |





   *代码示例：*





   #+BEGIN_EXAMPLE
       <!--plugin/components/hello-component.wxml-->
         <functional-page-navigator
           name="loginAndGetUserInfo"
           args="{{ args }}"
           version="develop"
           bind:success="loginSuccess"
           bind:fail="loginFail"
         >
           <button class="login">登录到插件</button>
         </functional-page-navigator>
   #+END_EXAMPLE









   #+BEGIN_EXAMPLE
       // plugin/components/hello-component.js
       Component({
         properties: {},
         data: {
           args: {
             withCredentials: true,
             lang: 'zh_CN'
           }
         },
         methods: {
           loginSuccess: function (res) {
             console.log(res.detail);
           },
           loginFail: function (res) {
             console.log(res);
           }
         }
       });
   #+END_EXAMPLE





   用户点击该 =navigator= 后，将跳转到如下的用户信息功能页：

   [[file:feed_0/article_77/images/img1_u2.png]]

   [[https://developers.weixin.qq.com/s/Uof4Iomt731Z][在微信开发者工具中查看示例<<>>]]：

   1. 由于插件需要 appid 才能工作，请填入一个 appid；
   2. 由于当前代码片段的限制，打开该示例后请 *手动将 appid 填写到
      =miniprogram/app.json= 中（如下图）使示例正常运行。*

   [[file:feed_0/article_72/images/img2_u5.png]]













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/user-info.html]]

   \\
   \\


















   --------------













**** [[index_u24.html#支付功能页][#]] 支付功能页
  
  
 


   支付功能页用于帮助插件完成支付，相当于
   [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]
   的功能。

   需要注意的是：插件使用支付功能，需要进行额外的权限申请，申请位置位于[[https://mp.weixin.qq.com][管理后台<<>>]]的“小程序插件
   -> 基本设置 ->
   支付能力”设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。

***** [[index_u24.html#调用参数][#]] 调用参数
  
  
 


   支付功能页使用
   [[../../../component/functional-page-navigator.html][functional-page-navigator]]
   进行跳转时，对应的参数 name 应为固定值 =requestPayment=，其他参数如下：

   *args 参数说明：*





   | 参数名         | 类型     | 必填   | 说明                                           |
   |----------------+----------+--------+------------------------------------------------|
   | fee            | Number   | 是     | 需要显示在页面中的金额，单位为分               |
   | paymentArgs    | Object   | 否     | 任意数据，传递给功能页中的响应函数             |
   | currencyType   | String   | 否     | 需要显示在页面中的货币符号的代码，默认为 CNY   |





   *currencyType 的合法值：*





   | 值    | 说明            | 最低版本   |
   |-------+-----------------+------------|
   | CNY   | 货币符号 ¥      |            |
   | USD   | 货币符号 US$    |            |
   | JPY   | 货币符号 J¥     |            |
   | EUR   | 货币符号 €      |            |
   | HKD   | 货币符号 HK$    |            |
   | GBP   | 货币符号 ￡      |            |
   | AUD   | 货币符号 A$     |            |
   | MOP   | 货币符号 MOP$   |            |
   | KRW   | 货币符号 ₩      |            |





   *代码示例：*





   #+BEGIN_EXAMPLE
       <!-- plugin/components/pay.wxml -->
       <!-- 上线时，version 应改为 "release"，并确保插件所有者小程序已经发布 -->
       <functional-page-navigator
         version="develop"
         name="requestPayment"
         args="{{ args }}"
         bind:success="paymentSuccess"
         bind:fail="paymentFailed"
       >
         <button class="payment-button">支付 0.01 元</button>
       </functional-page-navigator>
   #+END_EXAMPLE









   #+BEGIN_EXAMPLE
       // plugin/components/pay.js
       Component({
         data: {
           args: {
             fee: 1,             // 支付金额，单位为分
             paymentArgs: 'A', // 将传递到功能页函数的自定义参数
             currencyType: 'USD' // 货币符号，页面显示货币简写 US$ 
           }
         },
         methods: {
           // 支付成功的回调接口
           paymentSuccess: function (e) {
             console.log(e);
             e.detail.extraData.timeStamp // 用 extraData 传递数据，详见下面功能页函数代码
           },
           // 支付失败的回调接口
           paymentFailed: function (e) {
             console.log(e);
           }
         }
       })
   #+END_EXAMPLE





   用户点击该 =navigator= 后，将跳转到如下的支付功能页：

   [[file:feed_0/article_78/images/img1_u21.png]]

***** [[index_u24.html#配置功能页函数][#]] 配置功能页函数
  
  
 


   支付功能页需要插件开发者在插件所有者小程序中提供一个函数来响应插件中的支付调用。即，在插件中跳转到支付功能页时，这个函数就会在合适的时机被调用，来帮助完成支付。如果不提供功能页函数，功能页调用将通过
   =fail= 事件返回失败。

   支付功能页函数应以导出函数的形式提供在插件所有者小程序的根目录下的
   =functional-pages/request-payment.js= 文件中，名为
   =beforeRequestPayment=。该函数应接收两个参数：





   | 参数名        | 类型       | 说明                                                                                                                                                   |
   |---------------+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
   | paymentArgs   | Object     | 即通过 [[../../../component/functional-page-navigator.html][functional-page-navigator]] 的 =arg= 参数中的 =paymentArgs= 字段传递到功能页的自定义数据   |
   | callback      | Function   | 回调函数，调用该函数后，小程序将发起支付（类似于 [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]）                         |





   *callback 函数的参数：*





   | 参数名               | 类型     | 说明                                                                                                       |
   |----------------------+----------+------------------------------------------------------------------------------------------------------------|
   | error                | Object   | 失败信息，若无失败，应返回 =null=                                                                          |
   | requestPaymentArgs   | Object   | 支付参数，用于调用 [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]，参数如下   |





   *reqeustPaymentArgs 的参数：*

   用于发起支付，和
   [[../../../api/open-api/payment/wx.requestPayment.html][wx.requestPayment]]
   的参数相同，但没有回调函数（=success=, =fail=, =complete=）：





   | 参数        | 类型     | 必填   | 说明                                                                                                                                                        |
   |-------------+----------+--------+-------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | timeStamp   | String   | 是     | 时间戳从 1970 年 1 月 1 日 00:00:00 至今的秒数,即当前的时间                                                                                                         |
   | nonceStr    | String   | 是     | 随机字符串，长度为 32 个字符以下。                                                                                                                            |
   | package     | String   | 是     | 统一下单接口返回的 prepay\_id 参数值，提交格式如：prepay\_id=***                                                                                            |
   | signType    | String   | 是     | 签名算法，暂支持 MD5                                                                                                                                        |
   | paySign     | String   | 是     | 签名,具体签名方案参见[[https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3][小程序支付接口文档<<>>]];                                |
   | extraData   | any      | 否     | 由开发者决定的自定义数据段，该字段将被无修改地透传到支付成功的回调参数中，具体见代码示例中的使用方法。基础库 [[../../compatibility.html][2.9.1]] 开始支持   |





   了解更多信息，请查看[[https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&index=1][微信支付接口文档<<>>]]

   *功能页函数代码示例：*





   #+BEGIN_EXAMPLE
       // functional-pages/request-payment.js
       exports.beforeRequestPayment = function (paymentArgs, callback) {
         // 注意：
         // 功能页函数（这个函数）不应 require 其他非 functional-pages 目录中的文件，
         // 其他非 functional-pages 目录中的文件也不应 require 这个目录中的文件，
         // 这样的 require 调用在未来将不被支持。
         //
         // 同在 functional-pages 中的文件可以 require
         var getOpenIdURL = require('./URL').getOpenIdURL;
         var paymentURL = require('./URL').paymentURL;

         // 自定义的参数，此处应为从插件传递过来的 'A'
         var customArgument = paymentArgs.customArgument;

         // 第一步：调用 wx.login 方法获取 code，然后在服务端调用微信接口使用 code 换取下单用户的 openId
         // 具体文档参考 https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=20161230#wxloginobject
         wx.login({
           success: function (data) {
             wx.request({
               url: getOpenIdURL,
               data: { code: data.code },
               success: function (res) {
                 // 拉取用户 openid 成功
                 // 第二步：在服务端调用支付统一下单，返回支付参数。这里的开发和普通的 wx.requestPayment 相同
                 // 文档可以参考 https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_4&index=3
                 wx.request({
                   url: paymentURL,
                   data: { openid: res.data.openid },
                   method: 'POST',
                   success: function (res) {
                     console.log('unified order success, response is:', res);
                     var payargs = res.data.payargs;
                     // 第三步：调用回调函数 callback 进行支付
                     // 在 callback 中需要返回两个参数： err 和 requestPaymentArgs：
                     // err 应为 null （或者一些失败信息）；
                     // requestPaymentArgs 将被用于调用 wx.requestPayment，除了 success/fail/complete 不被支持外，
                     // 应与 wx.requestPayment 参数相同。
                     var error = null;
                     var requestPaymentArgs = {
                       timeStamp: payargs.timeStamp,
                       nonceStr: payargs.nonceStr,
                       package: payargs.package,
                       signType: payargs.signType,
                       paySign: payargs.paySign,
                       extraData: { // 用 extraData 传递自定义数据
                         timeStamp: payargs.timeStamp
                       },
                     };
                     callback(error, requestPaymentArgs);
                   }
                 });
               },
               fail: function (res) {
                 console.log('拉取用户openid失败，将无法正常使用开放接口等服务', res);
                 // callback 第一个参数为错误信息，返回错误信息
                 callback(res);
               }
             });
           },
           fail: function (err) {
             console.log('wx.login 接口调用失败，将无法正常使用开放接口等服务', err)
             // callback 第一个参数为错误信息，返回错误信息
             callback(err);
           }
         });
       }
   #+END_EXAMPLE





   *注意：功能页函数不应 =require= 其他非 =functional-pages=
   目录中的文件，其他非 =functional-pages= 目录中的文件也不应 =require=
   这个目录中的文件。这样的 =require= 调用在未来将不被支持。*

   *这个目录和文件应当被放置在插件所有者小程序代码中（而非插件代码中），它是插件所有者小程序的一部分（而非插件的一部分）。*
   如果需要新增或更改这段代码，需要发布插件所有者小程序，才能在正式版中生效；需要重新预览插件所有者小程序，才能在开发版中生效。













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/request-payment.html]]

   \\
   \\


















   --------------













**** [[index_u85.html#收货地址功能页][#]] 收货地址功能页
  
  
 


   收货地址功能页用于展示用户的收货地址列表，用户可以选择其中的收货地址。自基础库版本
   [[../../compatibility.html][2.4.0]] 开始支持。

***** [[index_u85.html#调用参数][#]] 调用参数
  
  
 


   用户信息功能页使用
   [[../../../component/functional-page-navigator.html][functional-page-navigator]]
   进行跳转时，对应的参数 name 应为固定值 =chooseAddress= ，返回参数与
   [[../../../api/open-api/address/wx.chooseAddress.html][wx.chooseAddress]]
   相同。

   *bindsuccess 返回参数说明：*





   | 属性           | 类型     | 说明                     | 最低版本   |
   |----------------+----------+--------------------------+------------|
   | userName       | string   | 收货人姓名               |            |
   | postalCode     | string   | 邮编                     |            |
   | provinceName   | string   | 国标收货地址第一级地址   |            |
   | cityName       | string   | 国标收货地址第一级地址   |            |
   | countyName     | string   | 国标收货地址第一级地址   |            |
   | detailInfo     | string   | 详细收货地址信息         |            |
   | nationalCode   | string   | 收货地址国家码           |            |
   | telNumber      | string   | 收货人手机号码           |            |
   | errMsg         | string   | 错误信息                 |            |





   *代码示例：*





   #+BEGIN_EXAMPLE
       <!--plugin/components/hello-component.wxml-->
         <functional-page-navigator
           name="chooseAddress"
           version="develop"
           bind:success="onSuccess"
           bind:fail="onFail"
         >
           <button>选择收货地址</button>
         </functional-page-navigator>
   #+END_EXAMPLE









   #+BEGIN_EXAMPLE
       // plugin/components/hello-component.js
       Component({
         methods: {
           onSuccess: function (res) {
             console.log(res.detail);
           },
           onFail: function (res) {
             console.log(res);
           }
         }
       });
   #+END_EXAMPLE

















   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/choose-address.html]]

   \\
   \\


















   --------------













***** [[index_u47.html#网络][#]] 网络
  
  
 


   在小程序/小游戏中使用网络相关的 API
   时，需要注意下列问题，请开发者提前了解。

****** [[index_u47.html#_1-服务器域名配置][#]] 1. 服务器域名配置
  
  
 


   每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
   HTTPS
   请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
   和 WebSocket
   通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

   从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
   *不允许与本机 IP 通信*。

   从 2.7.0 开始，提供了 UDP
   通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

******* [[index_u47.html#配置流程][#]] 配置流程
  
  
 


   服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
   中进行配置，配置时需要注意：

   -  域名只支持 =https=
      ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
      和 =wss=
      ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
      协议；
   -  域名不能使用 IP
      地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
      IP 除外）或 localhost；
   -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
      https://myserver.com:8080 发起请求。如果向
      https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
   -  如果不配置端口。如 https://myserver.com，那么请求的 URL
      中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
      https://myserver.com:443 请求则会失败。
   -  域名必须经过 ICP 备案；
   -  *出于安全考虑，=api.weixin.qq.com=
      不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
      AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
      接口获取 =access_token=，并调用相关 API；
   -  对于每个接口，分别可以配置最多 20 个域名。
   -  不支持配置父域名，使用子域名。

****** [[index_u47.html#_2-网络请求][#]] 2. 网络请求
  
  
 


******* [[index_u47.html#超时时间][#]] 超时时间
  
  
 


   -  默认超时时间和最大超时时间都是 *60s*；
   -  超时时间可以在 =app.json= 或 =game.json= 中通过
      [[../config.html][=networktimeout=]] 配置。

******* [[index_u47.html#使用限制][#]] 使用限制
  
  
 


   -  网络请求的 =referer= header 不可设置。其格式固定为
      =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
      ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
      =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
      表示为开发者工具，其余为正式版本；
   -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
      的最大并发限制是 *10* 个；
   -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
      的最大并发限制是 *5* 个。
   -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
      =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

******* [[index_u47.html#返回值编码][#]] 返回值编码
  
  
 


   -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
      编码，小程序会尝试进行转换，但是会有转换失败的可能。
   -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

******* [[index_u47.html#回调函数][#]] 回调函数
  
  
 


   -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
      =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

****** [[index_u47.html#_3-常见问题][#]] 3. 常见问题
  
  
 


******* [[index_u47.html#HTTPS-证书][#]] HTTPS 证书
  
  
 


   *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
   HTTPS
   证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

   对证书要求如下：

   -  HTTPS 证书必须有效；

      -  证书必须被系统信任，即根证书被已系统内置
      -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
      -  证书必须在有效期内
      -  证书的信任链必需完整（需要服务器配置）

   -  =iOS= 不支持自签名证书;
   -  =iOS= 下证书必须满足苹果
      [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
      Transport Security (ATS)<<>>]] 的要求;
   -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
      1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
   -  部分 CA
      可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

      -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
         56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

   #+BEGIN_QUOTE
     证书有效性可以使用 =openssl s_client -connect example.com:443=
     命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
   #+END_QUOTE

   *除了网络请求 API 外，小程序中其他 =HTTPS=
   请求如果出现异常，也请按上述流程进行检查。如 https
   的图片无法加载、音视频无法播放等。*

******* [[index_u47.html#跳过域名校验][#]] 跳过域名校验
  
  
 


   在微信开发者工具中，可以临时开启
   =开发环境不校验请求域名、TLS版本及HTTPS证书=
   选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

   *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

   #+BEGIN_QUOTE
     如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
     的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
   #+END_QUOTE













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

   \\
   \\


















   --------------













***** [[index_u98.html#网络][#]] 网络
  
  
 


   在小程序/小游戏中使用网络相关的 API
   时，需要注意下列问题，请开发者提前了解。

****** [[index_u98.html#_1-服务器域名配置][#]] 1. 服务器域名配置
  
  
 


   每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
   HTTPS
   请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
   和 WebSocket
   通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

   从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
   *不允许与本机 IP 通信*。

   从 2.7.0 开始，提供了 UDP
   通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

******* [[index_u98.html#配置流程][#]] 配置流程
  
  
 


   服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
   中进行配置，配置时需要注意：

   -  域名只支持 =https=
      ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
      和 =wss=
      ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
      协议；
   -  域名不能使用 IP
      地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
      IP 除外）或 localhost；
   -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
      https://myserver.com:8080 发起请求。如果向
      https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
   -  如果不配置端口。如 https://myserver.com，那么请求的 URL
      中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
      https://myserver.com:443 请求则会失败。
   -  域名必须经过 ICP 备案；
   -  *出于安全考虑，=api.weixin.qq.com=
      不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
      AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
      接口获取 =access_token=，并调用相关 API；
   -  对于每个接口，分别可以配置最多 20 个域名。
   -  不支持配置父域名，使用子域名。

****** [[index_u98.html#_2-网络请求][#]] 2. 网络请求
  
  
 


******* [[index_u98.html#超时时间][#]] 超时时间
  
  
 


   -  默认超时时间和最大超时时间都是 *60s*；
   -  超时时间可以在 =app.json= 或 =game.json= 中通过
      [[../config.html][=networktimeout=]] 配置。

******* [[index_u98.html#使用限制][#]] 使用限制
  
  
 


   -  网络请求的 =referer= header 不可设置。其格式固定为
      =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
      ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
      =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
      表示为开发者工具，其余为正式版本；
   -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
      的最大并发限制是 *10* 个；
   -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
      的最大并发限制是 *5* 个。
   -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
      =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

******* [[index_u98.html#返回值编码][#]] 返回值编码
  
  
 


   -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
      编码，小程序会尝试进行转换，但是会有转换失败的可能。
   -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

******* [[index_u98.html#回调函数][#]] 回调函数
  
  
 


   -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
      =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

****** [[index_u98.html#_3-常见问题][#]] 3. 常见问题
  
  
 


******* [[index_u98.html#HTTPS-证书][#]] HTTPS 证书
  
  
 


   *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
   HTTPS
   证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

   对证书要求如下：

   -  HTTPS 证书必须有效；

      -  证书必须被系统信任，即根证书被已系统内置
      -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
      -  证书必须在有效期内
      -  证书的信任链必需完整（需要服务器配置）

   -  =iOS= 不支持自签名证书;
   -  =iOS= 下证书必须满足苹果
      [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
      Transport Security (ATS)<<>>]] 的要求;
   -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
      1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
   -  部分 CA
      可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

      -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
         56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

   #+BEGIN_QUOTE
     证书有效性可以使用 =openssl s_client -connect example.com:443=
     命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
   #+END_QUOTE

   *除了网络请求 API 外，小程序中其他 =HTTPS=
   请求如果出现异常，也请按上述流程进行检查。如 https
   的图片无法加载、音视频无法播放等。*

******* [[index_u98.html#跳过域名校验][#]] 跳过域名校验
  
  
 


   在微信开发者工具中，可以临时开启
   =开发环境不校验请求域名、TLS版本及HTTPS证书=
   选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

   *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

   #+BEGIN_QUOTE
     如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
     的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
   #+END_QUOTE













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

   \\
   \\


















   --------------













***** [[index_u29.html#网络][#]] 网络
  
  
 


   在小程序/小游戏中使用网络相关的 API
   时，需要注意下列问题，请开发者提前了解。

****** [[index_u29.html#_1-服务器域名配置][#]] 1. 服务器域名配置
  
  
 


   每个微信小程序需要事先设置通讯域名，小程序*只可以跟指定的域名进行网络通信*。包括普通
   HTTPS
   请求（[[../../api/network/request/wx.request.html][wx.request]]）、上传文件（[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]）、下载文件（[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
   和 WebSocket
   通信（[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]）。

   从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意
   *不允许与本机 IP 通信*。

   从 2.7.0 开始，提供了 UDP
   通信（[[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]])。

******* [[index_u29.html#配置流程][#]] 配置流程
  
  
 


   服务器域名请在 「小程序后台-开发-开发设置-服务器域名」
   中进行配置，配置时需要注意：

   -  域名只支持 =https=
      ([[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]])
      和 =wss=
      ([[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]])
      协议；
   -  域名不能使用 IP
      地址（小程序的[[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html][局域网<<>>]]
      IP 除外）或 localhost；
   -  可以配置端口，如 https://myserver.com:8080，但是配置后只能向
      https://myserver.com:8080 发起请求。如果向
      https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
   -  如果不配置端口。如 https://myserver.com，那么请求的 URL
      中也不能包含端口，甚至是默认的 443 端口也不可以。如果向
      https://myserver.com:443 请求则会失败。
   -  域名必须经过 ICP 备案；
   -  *出于安全考虑，=api.weixin.qq.com=
      不能被配置为服务器域名，相关 API 也不能在小程序内调用。* 开发者应将
      AppSecret 保存到后台服务器中，通过服务器使用 =getAccessToken=
      接口获取 =access_token=，并调用相关 API；
   -  对于每个接口，分别可以配置最多 20 个域名。
   -  不支持配置父域名，使用子域名。

****** [[index_u29.html#_2-网络请求][#]] 2. 网络请求
  
  
 


******* [[index_u29.html#超时时间][#]] 超时时间
  
  
 


   -  默认超时时间和最大超时时间都是 *60s*；
   -  超时时间可以在 =app.json= 或 =game.json= 中通过
      [[../config.html][=networktimeout=]] 配置。

******* [[index_u29.html#使用限制][#]] 使用限制
  
  
 


   -  网络请求的 =referer= header 不可设置。其格式固定为
      =https://servicewechat.com/{appid}/{version}/page-frame.html=，其中
      ={appid}= 为小程序的 appid，={version}= 为小程序的版本号，版本号为
      =0= 表示为开发版、体验版以及审核版本，版本号为 =devtools=
      表示为开发者工具，其余为正式版本；
   -  [[../../api/network/request/wx.request.html][wx.request]]、[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]、[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
      的最大并发限制是 *10* 个；
   -  [[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]
      的最大并发限制是 *5* 个。
   -  小程序进入后台运行后，如果 *5s* 内网络请求没有结束，会回调错误信息
      =fail interrupted=；在回到前台之前，网络请求接口调用都会无法调用。

******* [[index_u29.html#返回值编码][#]] 返回值编码
  
  
 


   -  建议服务器返回值使用 *UTF-8* 编码。对于非 UTF-8
      编码，小程序会尝试进行转换，但是会有转换失败的可能。
   -  小程序会自动对 BOM 头进行过滤（只过滤一个 BOM 头）。

******* [[index_u29.html#回调函数][#]] 回调函数
  
  
 


   -  *只要成功接收到服务器返回，无论 =statusCode= 是多少，都会进入
      =success= 回调。请开发者根据业务逻辑对返回值进行判断。*

****** [[index_u29.html#_3-常见问题][#]] 3. 常见问题
  
  
 


******* [[index_u29.html#HTTPS-证书][#]] HTTPS 证书
  
  
 


   *小程序必须使用 HTTPS/WSS 发起网络请求*。请求时系统会对服务器域名使用的
   HTTPS
   证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。

   对证书要求如下：

   -  HTTPS 证书必须有效；

      -  证书必须被系统信任，即根证书被已系统内置
      -  部署 SSL 证书的网站域名必须与证书颁发的域名一致
      -  证书必须在有效期内
      -  证书的信任链必需完整（需要服务器配置）

   -  =iOS= 不支持自签名证书;
   -  =iOS= 下证书必须满足苹果
      [[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33][App
      Transport Security (ATS)<<>>]] 的要求;
   -  TLS 必须支持 1.2 及以上版本。部分旧 =Android= 机型还未支持 TLS
      1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
   -  部分 CA
      可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。

      -  [[https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a][Chrome
         56/57 内核对 WoSign、StartCom 证书限制周知<<>>]]

   #+BEGIN_QUOTE
     证书有效性可以使用 =openssl s_client -connect example.com:443=
     命令验证，也可以使用其他[[https://myssl.com/ssl.html][在线工具<<>>]]。
   #+END_QUOTE

   *除了网络请求 API 外，小程序中其他 =HTTPS=
   请求如果出现异常，也请按上述流程进行检查。如 https
   的图片无法加载、音视频无法播放等。*

******* [[index_u29.html#跳过域名校验][#]] 跳过域名校验
  
  
 


   在微信开发者工具中，可以临时开启
   =开发环境不校验请求域名、TLS版本及HTTPS证书=
   选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。

   *在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。*

   #+BEGIN_QUOTE
     如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求”
     的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。
   #+END_QUOTE













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html]]

   \\
   \\


















   --------------













***** [[index_u92.html#局域网通信][#]] 局域网通信
  
  
 


   基础库 2.4.0 提供了
   [[../../api/network/mdns/wx.startLocalServiceDiscovery.html][wx.startLocalServiceDiscovery]]
   等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。
   [[../../api/network/request/wx.request.html][wx.request]]/[[../../api/network/websocket/wx.connectSocket.html][wx.connectSocket]]/[[../../api/network/upload/wx.uploadFile.html][wx.uploadFile]]/[[../../api/network/download/wx.downloadFile.html][wx.downloadFile]]
   的 url 参数允许为 =${IP}:${PORT}/${PATH}= 的格式，当且仅当 IP 与手机 IP
   处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个
   wifi 下）时，请求/连接才会成功。

   在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用
   http/ws。





   #+BEGIN_EXAMPLE
       wx.request({
         url: 'http://10.9.176.40:828'
         // 省略其他参数
       })

       wx.connectSocket({
         url: 'ws://10.9.176.42:828'
         // 省略其他参数
       })
   #+END_EXAMPLE





   基础库 2.7.0 开始，提供了
   [[../../api/network/udp/wx.createUDPSocket.html][wx.createUDPSocket]]
   接口用于进行 UDP 通信。通信规则同上，仅允许同一局域网下的非本机 IP。

****** [[index_u92.html#mDNS][#]] mDNS
  
  
 


   目前小程序只支持通过 mDNS 协议获取局域网内其他设备的 IP。iOS 上 mDNS API
   的实现基于
   [[https://developer.apple.com/bonjour/][Bonjour<<>>]]，Android
   上则是基于
   [[https://developer.android.com/training/connect-devices-wirelessly/nsd][Android
   系统接口<<>>]]。

   *serviceType*

   发起 mDNS 服务搜索
   [[../../api/network/mdns/wx.startLocalServiceDiscovery.html][wx.startLocalServiceDiscovery]]
   的接口有 serviceType 参数，指定要搜索的服务类型。

   serviceType 的格式和规范，iOS
   [[https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/NetServices/Articles/domainnames.html][Bonjour
   Overview<<>>]] 在 *Bonjour Names for Existing Service Types* 有提及。

   [[file:feed_0/article_83/images/img1_u26.png]]

   [[https://developer.android.com/training/connect-devices-wirelessly/nsd][Android
   文档<<>>]] 对此也有提及。

   [[file:feed_0/article_83/images/img2_u4.png]]













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html]]

   \\
   \\


















   --------------













***** [[index_u76.html#存储][#]] 存储
  
  
 


   每个微信小程序都可以有自己的本地缓存，可以通过
   [[../../api/storage/wx.setStorage.html][wx.setStorage]]/[[../../api/storage/wx.setStorageSync.html][wx.setStorageSync]]、[[../../api/storage/wx.getStorage.html][wx.getStorage]]/[[../../api/storage/wx.getStorageSync.html][wx.getStorageSync]]、[[../../api/storage/wx.clearStorage.html][wx.clearStorage]]/[[../../api/storage/wx.clearStorageSync.html][wx.clearStorageSync]]，[[../../api/storage/wx.removeStorage.html][wx.removeStorage]]/[[../../api/storage/wx.removeStorageSync.html][wx.removeStorageSync]]
   对本地缓存进行读写和清理。

****** [[index_u76.html#隔离策略][#]] 隔离策略
  
  
 


   同一个微信用户，同一个小程序 storage 上限为 10MB。storage
   以用户维度隔离，同一台设备上，A 用户无法读取到 B
   用户的数据；不同小程序之间也无法互相读写数据。

****** [[index_u76.html#清理策略][#]] 清理策略
  
  
 


   本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html]]

   \\
   \\


















   --------------













***** [[index_u31.html#文件系统][#]] 文件系统
  
  
 


   文件系统是小程序提供的一套以小程序和用户维度隔离的存储以及一套相应的管理接口。通过
   [[../../api/file/wx.getFileSystemManager.html][wx.getFileSystemManager()]]
   可以获取到全局唯一的文件系统管理器，所有文件系统的管理操作通过
   [[../../api/file/FileSystemManager.html][FileSystemManager]] 来调用。





   #+BEGIN_EXAMPLE
       var fs = wx.getFileSystemManager()
   #+END_EXAMPLE





   文件主要分为两大类：

   -  代码包文件：代码包文件指的是在项目目录中添加的文件。
   -  本地文件：通过调用接口本地产生，或通过网络下载下来，存储到本地的文件。

   其中本地文件又分为三种：

   1. 本地临时文件：临时产生，随时会被回收的文件。不限制存储大小。
   2. 本地缓存文件：小程序通过接口把本地临时文件缓存后产生的文件，不能自定义目录和文件名。跟本地用户文件共计，小程序（含小游戏）最多可存储
      200MB。
   3. 本地用户文件：小程序通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名。跟本地缓存文件共计，小程序（含小游戏）最多可存储
      200MB。

****** [[index_u31.html#代码包文件][#]] 代码包文件
  
  
 


   由于代码包文件大小限制，代码包文件适用于放置首次加载时需要的文件，对于内容较大或需要动态替换的文件，不推荐用添加到代码包中，推荐在小游戏启动之后再用下载接口下载到本地。

******* [[index_u31.html#访问代码包文件][#]] 访问代码包文件
 
  
 


   代码包文件的访问方式是从项目根目录开始写文件路径，不支持相对路径的写法。如：=/a/b/c=、=a/b/c=
   都是合法的，=./a/b/c= =../a/b/c= 则不合法。
   [[file:feed_0/article_85/images/img1_u10.png]]

******* [[index_u31.html#修改代码包文件][#]] 修改代码包文件
 
  
 


   代码包内的文件无法在运行后动态修改或删除，修改代码包文件需要重新发布版本。

****** [[index_u31.html#本地文件][#]] 本地文件
 
  
 


   本地文件指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户维度隔离。即同一台手机，每个微信用户不能访问到其他登录用户的文件，同一个用户不同
   appId 之间的文件也不能互相访问。
   [[file:feed_0/article_85/images/img2_u9.png]]

   本地文件的文件路径均为以下格式：





   #+BEGIN_EXAMPLE
       {{协议名}}://文件路径
   #+END_EXAMPLE





   #+BEGIN_QUOTE
     其中，协议名在 iOS/Android 客户端为 ="wxfile"=，在开发者工具上为
     ="http"=，开发者无需关注这个差异，也不应在代码中去硬编码完整文件路径。
   #+END_QUOTE

******* [[index_u31.html#本地临时文件][#]] 本地临时文件
 
  
 


   本地临时文件只能通过调用特定接口产生，不能直接写入内容。本地临时文件产生后，仅在当前生命周期内有效，重启之后即不可用。因此，*不可把本地临时文件路径存储起来下次使用*。如果需要下次在使用，可通过
   [[../../api/file/FileSystemManager.saveFile.html][FileSystemManager.saveFile()]]
   或
   [[../../api/file/FileSystemManager.copyFile.html][FileSystemManager.copyFile()]]
   接口把本地临时文件转换成本地缓存文件或本地用户文件。

******** [[index_u31.html#示例][#]] 示例
 
  
 






   #+BEGIN_EXAMPLE
       wx.chooseImage({
         success: function (res) {

         }
       })
   #+END_EXAMPLE





******* [[index_u31.html#本地缓存文件][#]] 本地缓存文件
 
  
 


   本地缓存文件只能通过调用特定接口产生，不能直接写入内容。本地缓存文件产生后，重启之后仍可用。本地缓存文件只能通过
   [[../../api/file/FileSystemManager.saveFile.html][FileSystemManager.saveFile()]]
   接口将本地临时文件保存获得。

******** [[index_u31.html#示例-2][#]] 示例
 
  
 






   #+BEGIN_EXAMPLE
       fs.saveFile({
         tempFilePath: '', // 传入一个本地临时文件路径
         success(res) {
           console.log(res.savedFilePath) // res.savedFilePath 为一个本地缓存文件路径
         }
       })
   #+END_EXAMPLE





   *注意：本地缓存文件是最初的设计，=1.7.0=
   版本开始，提供了功能更完整的本地用户文件，可以完全覆盖本地缓存文件的功能，如果不需要兼容低于
   =1.7.0= 版本，可以不使用本地缓存文件。*

******* [[index_u31.html#本地用户文件][#]] 本地用户文件
 
  
 


   本地用户文件是从 =1.7.0=
   版本开始新增的概念。我们提供了一个用户文件目录给开发者，开发者对这个目录有完全自由的读写权限。通过
   =wx.env.USER_DATA_PATH= 可以获取到这个目录的路径。

******** [[index_u31.html#示例-3][#]] 示例
 
  
 






   #+BEGIN_EXAMPLE
       // 在本地用户文件目录下创建一个文件 hello.txt，写入内容 "hello, world"
       const fs = wx.getFileSystemManager()
       fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'hello, world', 'utf8')
   #+END_EXAMPLE





****** [[index_u31.html#读写权限][#]] 读写权限
  
  
 






   | 接口、组件     | 读   | 写   |
   |----------------+------+------|
   | 代码包文件     | 有   | 无   |
   | 本地临时文件   | 有   | 无   |
   | 本地缓存文件   | 有   | 无   |
   | 本地用户文件   | 有   | 有   |





****** [[index_u31.html#清理策略][#]] 清理策略
  
  
 


   -  本地临时文件只保证在小程序当前生命周期内，一旦小程序被关闭就可能被清理，即下次冷启动不保证可用。
   -  本地缓存文件和本地用户文件的清理时机跟代码包一样，只有在代码包被清理的时会被清理。













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html]]

   \\
   \\


















   --------------













***** [[index_u37.html#Canvas-画布][#]] Canvas 画布
  
  
 


   所有在 [[../../component/canvas.html][canvas]] 中的画图必须用 JavaScript
   完成：

   WXML：（我们在接下来的例子中如无特殊声明都会用这个 WXML
   为模板，不再重复）





   #+BEGIN_EXAMPLE
       <canvas canvas-id="myCanvas" style="border: 1px solid;"/>
   #+END_EXAMPLE





   JS：（我们在接下来的例子中会将 JS 放在 onLoad 中）





   #+BEGIN_EXAMPLE
       const ctx = wx.createCanvasContext('myCanvas')
       ctx.setFillStyle('red')
       ctx.fillRect(10, 10, 150, 75)
       ctx.draw()
   #+END_EXAMPLE





   *第一步：创建一个 Canvas 绘图上下文*

   首先，我们需要创建一个 Canvas 绘图上下文
   [[../../api/canvas/CanvasContext.html][CanvasContext]]。

   CanvasContext 是小程序内建的一个对象，有一些绘图的方法：





   #+BEGIN_EXAMPLE
       const ctx = wx.createCanvasContext('myCanvas')
   #+END_EXAMPLE





   *第二步：使用 Canvas 绘图上下文进行绘图描述*

   接着，我们来描述要在 Canvas 中绘制什么内容。

   设置绘图上下文的填充色为红色：





   #+BEGIN_EXAMPLE
       ctx.setFillStyle('red')
   #+END_EXAMPLE





   用 =fillRect(x, y, width, height)=
   方法画一个矩形，填充为刚刚设置的红色：





   #+BEGIN_EXAMPLE
       ctx.fillRect(10, 10, 150, 75)
   #+END_EXAMPLE





   *第三步：画图*

   告诉 [[../../component/canvas.html][canvas]]
   组件你要将刚刚的描述绘制上去：





   #+BEGIN_EXAMPLE
       ctx.draw()
   #+END_EXAMPLE





   *结果：*

   [[file:feed_0/article_86/images/img1_u13.png]]

***** [[index_u37.html#坐标系][#]] 坐标系
  
  
 


   canvas 是在一个二维的网格当中。左上角的坐标为=(0, 0)=。

   在上一节，我们用了这个方法 =fillRect(0, 0, 150, 75)=。

   它的含义为：从左上角=(0, 0)=开始，画一个=150 x 75=px 的矩形。

   *代码示例*

   我们可以在 [[../../component/canvas.html][canvas]]
   中加上一些事件，来观测它的坐标系





   #+BEGIN_EXAMPLE
       <canvas canvas-id="myCanvas"
         style="margin: 5px; border:1px solid #d3d3d3;"
         bindtouchstart="start"
         bindtouchmove="move"
         bindtouchend="end"/>

       <view hidden="{{hidden}}">
         Coordinates: ({{x}}, {{y}})
       </view>
   #+END_EXAMPLE









   #+BEGIN_EXAMPLE
       Page({
         data: {
           x: 0,
           y: 0,
           hidden: true
         },
         start (e) {
           this.setData({
             hidden: false,
             x: e.touches[0].x,
             y: e.touches[0].y
           })
         },
         move (e) {
           this.setData({
             x: e.touches[0].x,
             y: e.touches[0].y
           })
         },
         end (e) {
           this.setData({
             hidden: true
           })
         }
       })
   #+END_EXAMPLE





   当你把手指放到 canvas 中，就会在下边显示出触碰点的坐标：

   [[file:feed_0/article_86/images/img2_u3.png]]

***** [[index_u37.html#渐变][#]] 渐变
  
  
 


   渐变能用于填充一个矩形，圆，线，文字等。填充色可以不固定为固定的一种颜色。

   我们提供了两种颜色渐变的方式：

   -  [[../../api/canvas/CanvasContext.createLinearGradient.html][=createLinearGradient(x, y, x1, y1)=]]
      创建一个线性的渐变
   -  [[../../api/canvas/CanvasContext.createCircularGradient.html][=createCircularGradient(x, y, r)=]]
      创建一个从圆心开始的渐变

   一旦我们创建了一个渐变对象，我们必须添加两个颜色渐变点。

   [[../../api/canvas/CanvasGradient.addColorStop.html][=addColorStop(position, color)=]]
   方法用于指定颜色渐变点的位置和颜色，位置必须位于 0 到 1 之间。

   可以用[[../../api/canvas/CanvasContext.setFillStyle.html][=setFillStyle=]]
   和
   [[../../api/canvas/CanvasContext.setStrokeStyle.html][=setStrokeStyle=]]
   方法设置渐变，然后进行画图描述。

   *使用 =createLinearGradient()=*





   #+BEGIN_EXAMPLE
       const ctx = wx.createCanvasContext('myCanvas')

       // Create linear gradient
       const grd = ctx.createLinearGradient(0, 0, 200, 0)
       grd.addColorStop(0, 'red')
       grd.addColorStop(1, 'white')

       // Fill with gradient
       ctx.setFillStyle(grd)
       ctx.fillRect(10, 10, 150, 80)
       ctx.draw()
   #+END_EXAMPLE





   [[file:feed_0/article_86/images/img3_u10.png]]

   *使用 =createCircularGradient()=*





   #+BEGIN_EXAMPLE
       const ctx = wx.createCanvasContext('myCanvas')

       // Create circular gradient
       const grd = ctx.createCircularGradient(75, 50, 50)
       grd.addColorStop(0, 'red')
       grd.addColorStop(1, 'white')

       // Fill with gradient
       ctx.setFillStyle(grd)
       ctx.fillRect(10, 10, 150, 80)
       ctx.draw()
   #+END_EXAMPLE





   [[file:feed_0/article_86/images/img4_u4.png]]













   --------------


   [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/canvas.html]]

   \\
   \\


















   --------------











** 基础能力  
*** [[index_u32.html#分包加载][#]] 分包加载
  某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。

  在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个*主包*。所谓的主包，即放置默认启动页面/TabBar
  页面，以及一些所有分包都需用到公共资源/JS
  脚本；而*分包*则是根据开发者的配置进行划分。

  在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。

  目前小程序分包大小有以下限制：

  -  整个小程序所有分包大小不超过 16M
  -  单个分包/主包大小不能超过 2M

  对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。

  具体使用方法请参考：

  -  [[file:subpackages/basic.html][使用分包]]
  -  [[file:subpackages/independent.html][独立分包]]
  -  [[file:subpackages/preload.html][分包预下载]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html]]

  \\
  \\


















  --------------












*** [[index_u1.html#使用分包][#]] 使用分包
  
  
 


***** [[index_u1.html#配置方法][#]] 配置方法
  
  
 


  假设支持分包的小程序目录结构如下：





  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── app.wxss
      ├── packageA
      │   └── pages
      │       ├── cat
      │       └── dog
      ├── packageB
      │   └── pages
      │       ├── apple
      │       └── banana
      ├── pages
      │   ├── index
      │   └── logs
      └── utils
  #+END_EXAMPLE





  开发者通过在 app.json =subpackages= 字段声明项目分包结构：

  #+BEGIN_QUOTE
    写成 subPackages 也支持。
  #+END_QUOTE





  #+BEGIN_EXAMPLE
      {
        "pages":[
          "pages/index",
          "pages/logs"
        ],
        "subpackages": [
          {
            "root": "packageA",
            "pages": [
              "pages/cat",
              "pages/dog"
            ]
          }, {
            "root": "packageB",
            "name": "pack2",
            "pages": [
              "pages/apple",
              "pages/banana"
            ]
          }
        ]
      }
  #+END_EXAMPLE





  =subpackages= 中，每个分包的配置有以下几项：





  | 字段          | 类型          | 说明                                                    |
  |---------------+---------------+---------------------------------------------------------|
  | root          | String        | 分包根目录                                              |
  | name          | String        | 分包别名，[[file:preload.html][分包预下载]]时可以使用   |
  | pages         | StringArray   | 分包页面路径，相对与分包根目录                          |
  | independent   | Boolean       | 分包是否是[[file:independent.html][独立分包]]           |





***** [[index_u1.html#打包原则][#]] 打包原则
  
  
 


  -  声明 =subpackages= 后，将按 =subpackages=
     配置路径进行打包，=subpackages= 配置路径外的目录将被打包到
     app（主包） 中
  -  app（主包）也可以有自己的 pages（即最外层的 pages 字段）
  -  =subpackage= 的根目录不能是另外一个 =subpackage= 内的子目录
  -  =tabBar= 页面必须在 app（主包）内

***** [[index_u1.html#引用原则][#]] 引用原则
  
  
 


  -  =packageA= 无法 require =packageB= JS 文件，但可以 require
     =app=、自己 package 内的 JS 文件
  -  =packageA= 无法 import =packageB= 的 template，但可以 require
     =app=、自己 package 内的 template
  -  =packageA= 无法使用 =packageB= 的资源，但可以使用 =app=、自己 package
     内的资源

***** [[index_u1.html#低版本兼容][#]] 低版本兼容
  
  
 


  由微信后台编译来处理旧版本客户端的兼容，后台会编译两份代码包，一份是分包后代码，另外一份是整包的兼容代码。
  新客户端用分包，老客户端还是用的整包，完整包会把各个 =subpackage=
  里面的路径放到 pages 中。

***** [[index_u1.html#示例项目][#]] 示例项目
  
  
 


  [[https://res.wx.qq.com/wxdoc/dist/assets/media/demo-subpackages.b42a3adb.zip][下载
  小程序示例（分包加载版）源码]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html]]

  \\
  \\


















  --------------













*** [[index_u60.html#独立分包][#]] 独立分包
  
  
 


  #+BEGIN_QUOTE
    微信客户端 6.7.2，基础库 [[../compatibility.html][2.3.0]]
    及以上版本开始支持。开发者工具请使用 1.02.1808300
    及以上版本，可[[../../devtools/download.html][点此下载]]。
  #+END_QUOTE

  独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。

  开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。

  一个小程序中可以有多个独立分包。

  #+BEGIN_QUOTE
    小游戏在基础库 v2.12.2 开始支持独立分包，详见
    [[https://developers.weixin.qq.com/minigame/dev/guide/base-ability/independent-sub-packages.html][小游戏独立分包指南<<>>]]。
  #+END_QUOTE

***** [[index_u60.html#配置方法][#]] 配置方法
  
  
 


  假设小程序目录结构如下：





  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── app.wxss
      ├── moduleA
      │   └── pages
      │       ├── rabbit
      │       └── squirrel
      ├── moduleB
      │   └── pages
      │       ├── pear
      │       └── pineapple
      ├── pages
      │   ├── index
      │   └── logs
      └── utils
  #+END_EXAMPLE





  开发者通过在=app.json=的=subpackages=字段中对应的分包配置项中定义=independent=字段声明对应分包为独立分包。





  #+BEGIN_EXAMPLE
      {
        "pages": [
          "pages/index",
          "pages/logs"
        ],
        "subpackages": [
          {
            "root": "moduleA",
            "pages": [
              "pages/rabbit",
              "pages/squirrel"
            ]
          }, {
            "root": "moduleB",
            "pages": [
              "pages/pear",
              "pages/pineapple"
            ],
            "independent": true
          }
        ]
      }
  #+END_EXAMPLE





***** [[index_u60.html#限制][#]] 限制
  
  
 


  独立分包属于分包的一种。普通分包的所有限制都对独立分包有效。独立分包中插件、自定义组件的处理方式同普通分包。

  此外，使用独立分包时要注意：

  -  *独立分包中不能依赖主包和其他分包中的内容*，包括 js 文件、template、wxss、自定义组件、插件等。主包中的=app.wxss=对独立分包无效，应避免在独立分包页面中使用
     =app.wxss= 中的样式；
  -  =App= 只能在主包内定义，独立分包中不能定义
     =App=，会造成无法预期的行为；
  -  独立分包中暂时不支持使用插件。

***** [[index_u60.html#注意事项][#]] 注意事项
  
  
 


****** [[index_u60.html#（1）关于-getApp][#]] （1）关于 =getApp()=
  
  
 


  与普通分包不同，独立分包运行时，=App= 并不一定被注册，因此 =getApp()=
  也不一定可以获得 =App= 对象：

  -  当用户从独立分包页面启动小程序时，主包不存在，=App=也不存在，此时调用
     =getApp()= 获取到的是 =undefined=。
     当用户进入普通分包或主包内页面时，主包才会被下载，=App= 才会被注册。
  -  当用户是从普通分包或主包内页面跳转到独立分包页面时，主包已经存在，此时调用
     =getApp()= 可以获取到真正的 =App=。

  由于这一限制，开发者无法通过 =App=
  对象实现独立分包和小程序其他部分的全局变量共享。

  为了在独立分包中满足这一需求，基础库 [[../compatibility.html][2.2.4]]
  版本开始 =getApp=支持 [=allowDefault=]参数，在 =App=
  未定义时返回一个默认实现。当主包加载，=App=
  被注册时，默认实现中定义的属性会被覆盖合并到真正的 =App= 中。

  *示例代码：*

  -  独立分包中





  #+BEGIN_EXAMPLE
      const app = getApp({allowDefault: true}) // {}
      app.data = 456
      app.global = {}
  #+END_EXAMPLE





  -  app.js 中





  #+BEGIN_EXAMPLE
      App({
        data: 123,
        other: 'hello'
      })

      console.log(getApp()) // {global: {}, data: 456, other: 'hello'}
  #+END_EXAMPLE





****** [[index_u60.html#（2）关于-App-生命周期][#]] （2）关于 =App=
  生命周期
  
  
 


  当从独立分包启动小程序时，主包中 =App= 的 =onLaunch= 和首次 =onShow=
  会在从独立分包页面首次进入主包或其他普通分包页面时调用。

  由于独立分包中无法定义 =App=，小程序生命周期的监听可以使用
  [[../../api/base/app/app-event/wx.onAppShow.html][wx.onAppShow]]，[[../../api/base/app/app-event/wx.onAppHide.html][wx.onAppHide]]
  完成。=App= 上的其他事件可以使用
  [[../../api/base/app/app-event/wx.onError.html][wx.onError]]，[[../../api/base/app/app-event/wx.onPageNotFound.html][wx.onPageNotFound]]
  监听。

***** [[index_u60.html#低版本兼容][#]] 低版本兼容
  
  
 


  在低于 6.7.2 版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。

  *注意：在兼容模式下，主包中的 =app.wxss=
  可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用
  =app.wxss= 中的样式。*













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html]]

  \\
  \\


















  --------------













*** [[index_u30.html#分包预下载][#]] 分包预下载
  
  
 


  #+BEGIN_QUOTE
    基础库 2.3.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
    开发者工具请使用 1.02.1808300
    及以上版本，可[[../../devtools/download.html][点此下载]]。
  #+END_QUOTE

  开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于[[file:independent.html][独立分包]]，也可以预下载主包。

  *分包预下载目前只支持通过配置方式使用，暂不支持通过调用 API 完成。*

  #+BEGIN_QUOTE
    vConsole
    里有=preloadSubpackages=开头的日志信息，可以用来验证预下载的情况。
  #+END_QUOTE

***** [[index_u30.html#配置方法][#]] 配置方法
  
  
 


  预下载分包行为在进入某个页面时触发，通过在 =app.json= 增加 =preloadRule=
  配置来控制。





  #+BEGIN_EXAMPLE
      {
        "pages": ["pages/index"],
        "subpackages": [
          {
            "root": "important",
            "pages": ["index"],
          },
          {
            "root": "sub1",
            "pages": ["index"],
          },
          {
            "name": "hello",
            "root": "path/to",
            "pages": ["index"]
          },
          {
            "root": "sub3",
            "pages": ["index"]
          },
          {
            "root": "indep",
            "pages": ["index"],
            "independent": true
          }
        ],
        "preloadRule": {
          "pages/index": {
            "network": "all",
            "packages": ["important"]
          },
          "sub1/index": {
            "packages": ["hello", "sub3"]
          },
          "sub3/index": {
            "packages": ["path/to"]
          },
          "indep/index": {
            "packages": ["__APP__"]
          }
        }
      }
  #+END_EXAMPLE





  =preloadRule= 中，=key= 是页面路径，=value=
  是进入此页面的预下载配置，每个配置有以下几项：





  | 字段       | 类型          | 必填   | 默认值   | 说明                                                            |
  |------------+---------------+--------+----------+-----------------------------------------------------------------|
  | packages   | StringArray   | 是     | 无       | 进入页面后预下载分包的 =root= 或 =name=。=__APP__= 表示主包。   |
  | network    | String        | 否     | wifi     | 在指定网络下预下载，可选值为：\\                                |
  |            |               |        |          | =all=: 不限网络\\                                               |
  |            |               |        |          | =wifi=: 仅 wifi 下预下载                                          |





***** [[index_u30.html#限制][#]] 限制
  
  
 


  同一个分包中的页面享有共同的预下载大小限额
  2M，限额会在工具中打包时校验。

  如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M
  的分包，B中最多只能预下载总大小 1.5M 的分包。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html]]

  \\
  \\


















  --------------













**** [[index_u55.html#多线程-Worker][#]] 多线程 Worker
  
  
 


  一些异步处理的任务，可以放置于 Worker
  中运行，待运行结束后，再把结果返回到小程序主线程。Worker
  运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法。

  Worker 与主线程之间的数据传输，双方使用
  [[../api/worker/Worker.postMessage.html][Worker.postMessage()]]
  来发送数据，[[../api/worker/Worker.onMessage.html][Worker.onMessage()]]
  来接收数据，传输的数据并不是直接共享，而是被复制的。

**** [[index_u55.html#使用流程][#]] 使用流程
  
  
 


  [[https://developers.weixin.qq.com/s/akaQknmy6ZY6][在开发者工具中预览效果<<>>]]

***** [[index_u55.html#_1-配置-Worker-信息][#]] 1. 配置 Worker 信息
  
  
 


  在 =app.json= 中可配置 =Worker=
  代码放置的目录，目录下的代码将被打包成一个文件：

  配置示例：





  #+BEGIN_EXAMPLE
      {
        "workers": "workers"
      }
  #+END_EXAMPLE





***** [[index_u55.html#_2-添加-Worker-代码文件][#]] 2. 添加 Worker
  代码文件
  
  
 


  根据步骤 1 中的配置，在代码目录下新建以下两个入口文件：





  #+BEGIN_EXAMPLE
      workers/request/index.js
      workers/request/utils.js
      workers/response/index.js
  #+END_EXAMPLE





  添加后，目录结构如下：





  #+BEGIN_EXAMPLE
      ├── app.js
      ├── app.json
      ├── project.config.json
      └── workers
          ├── request
          │   ├── index.js
          │   └── utils.js
          └── response
              └── index.js
  #+END_EXAMPLE





***** [[index_u55.html#_3-编写-Worker-代码][#]] 3. 编写 Worker 代码
  
  
 


  在 =workers/request/index.js= 编写 Worker 响应代码





  #+BEGIN_EXAMPLE
      const utils = require('./utils')

      // 在 Worker 线程执行上下文会全局暴露一个 worker 对象，直接调用 worker.onMessage/postMessage 即可
      worker.onMessage(function (res) {
        console.log(res)
      })
  #+END_EXAMPLE





***** [[index_u55.html#_4-在主线程中初始化-Worker][#]] 4. 在主线程中初始化
  Worker
  
  
 


  在主线程的代码 app.js 中初始化 Worker





  #+BEGIN_EXAMPLE
      const worker = wx.createWorker('workers/request/index.js') // 文件名指定 worker 的入口文件路径，绝对路径
  #+END_EXAMPLE





***** [[index_u55.html#_5-主线程向-Worker-发送消息][#]] 5. 主线程向 Worker
  发送消息
  
  
 






  #+BEGIN_EXAMPLE
      worker.postMessage({
        msg: 'hello worker'
      })
  #+END_EXAMPLE





  worker 对象的其它接口请看
  [[../api/worker/wx.createWorker.html][worker接口说明]]

***** [[index_u55.html#注意事项][#]] 注意事项
  
  
 


  1. Worker 最大并发数量限制为 1 个，创建下一个前请用
     [[../api/worker/Worker.terminate.html][Worker.terminate()]] 结束当前
     Worker
  2. Worker 内代码只能 require 指定 Worker 路径内的文件，无法引用其它路径
  3. Worker 的入口文件由
     [[../api/worker/wx.createWorker.html][wx.createWorker()]]
     时指定，开发者可动态指定 Worker 入口文件
  4. Worker 内不支持 =wx= 系列的 API
  5. Workers 之间不支持发送消息













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/workers.html]]

  \\
  \\


















  --------------













**** [[index_u27.html#后端-API][#]] 后端 API
  
  
 


  小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的
  API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如
  =getAccessToken=，=code2Session= 等。详细介绍请参考
  [[../../api/index.html][API 文档]]。

***** [[index_u27.html#access-token][#]] access\_token
  
  
 


  =access_token=
  是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过
  =getAccessToken= 接口获取并进行妥善保存。

  为了 =access_token= 的安全性，*后端 API 不能直接在小程序内通过
  [[../../api/network/request/wx.request.html][wx.request]] 调用*，即
  =api.weixin.qq.com=
  不能被配置为服务器域名。开发者应在后端服务器使用=getAccessToken=获取
  =access_token=，并调用相关 API；

***** [[index_u27.html#请求参数说明][#]] 请求参数说明
  
  
 


  -  对于 GET 请求，请求参数应以 QueryString 的形式写在 URL 中。
  -  对于 POST 请求，部分参数需以 QueryString 的形式写在 URL 中（一般只有
     =access_token=，如有额外参数会在文档里的 URL
     中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的
     body 中。

***** [[index_u27.html#返回参数说明][#]] 返回参数说明
  
  
 


  *注意：当 API 调用成功时，部分接口不会返回 errcode 和
  errmsg，只有调用失败时才会返回。*













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html]]

  \\
  \\


















  --------------













**** [[index_u77.html#后端-API][#]] 后端 API
  
  
 


  小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的
  API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如
  =getAccessToken=，=code2Session= 等。详细介绍请参考
  [[../../api/index.html][API 文档]]。

***** [[index_u77.html#access-token][#]] access\_token
  
  
 


  =access_token=
  是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过
  =getAccessToken= 接口获取并进行妥善保存。

  为了 =access_token= 的安全性，*后端 API 不能直接在小程序内通过
  [[../../api/network/request/wx.request.html][wx.request]] 调用*，即
  =api.weixin.qq.com=
  不能被配置为服务器域名。开发者应在后端服务器使用=getAccessToken=获取
  =access_token=，并调用相关 API；

***** [[index_u77.html#请求参数说明][#]] 请求参数说明
  
  
 


  -  对于 GET 请求，请求参数应以 QueryString 的形式写在 URL 中。
  -  对于 POST 请求，部分参数需以 QueryString 的形式写在 URL 中（一般只有
     =access_token=，如有额外参数会在文档里的 URL
     中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的
     body 中。

***** [[index_u77.html#返回参数说明][#]] 返回参数说明
  
  
 


  *注意：当 API 调用成功时，部分接口不会返回 errcode 和
  errmsg，只有调用失败时才会返回。*













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html]]

  \\
  \\


















  --------------













**** [[index_u42.html#消息推送][#]] 消息推送
  
  
 


  接入微信小程序消息推送服务，可以两种方式选择其一：

  1. [[index_u42.html#option-url][开发者服务器接收消息推送]]
  2. [[index_u42.html#option-cloud][云函数接收消息推送]]

***** [[index_u42.html#开发者服务器接收消息推送][#]]
  开发者服务器接收消息推送
  
  
 




  开发者需要按照如下步骤完成：

  1. 填写服务器配置
  2. 验证服务器地址的有效性
  3. 据接口文档实现业务逻辑，接收消息和事件

****** [[index_u42.html#第一步：填写服务器配置][#]] 第一步：填写服务器配置
  
  
 


  登录[[https://mp.weixin.qq.com/][小程序后台<<>>]]后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token）
  和 消息加密密钥（EncodingAESKey）等信息。

  -  URL: 开发者用来接收微信消息和事件的接口 URL。开发者所填写的 URL 必须以
     http:// 或 https:// 开头，分别支持 80 端口和 443 端口。
  -  Token: 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL
     中包含的 Token 进行比对，从而验证安全性）。
  -  EncodingAESKey: 由开发者手动填写或随机生成，将用作消息体加解密密钥。

  同时，开发者可选择消息加解密方式：明文模式（默认）、兼容模式和安全模式。可以选择消息数据格式：XML
  格式（默认）或 JSON 格式。

  [[file:feed_0/article_94/images/img1_u4.png]]

  模式的选择与服务器配置在提交后都会立即生效，请开发者谨慎填写及选择。切换加密方式和数据格式需要提前配置好相关代码，详情请参考
  [[https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN][消息加解密说明<<>>]]。

****** [[index_u42.html#第二步：验证消息的确来自微信服务器][#]]
  第二步：验证消息的确来自微信服务器
  
  
 


  开发者提交信息后，微信服务器将发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带参数如下表所示：





  | 参数        | 描述                                                                                     |
  |-------------+------------------------------------------------------------------------------------------|
  | signature   | 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数。   |
  | timestamp   | 时间戳                                                                                   |
  | nonce       | 随机数                                                                                   |
  | echostr     | 随机字符串                                                                               |





  开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次
  GET 请求来自微信服务器，请原样返回 echostr
  参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

  1. 将 token、timestamp、nonce 三个参数进行字典序排序
  2. 将三个参数字符串拼接成一个字符串进行 sha1 加密
  3. 开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信

  验证 URL 有效性成功后即接入生效，成为开发者。

  检验 signature 的 PHP 示例代码：





  #+BEGIN_EXAMPLE
      private function checkSignature()
      {
          $signature = $_GET["signature"];
          $timestamp = $_GET["timestamp"];
          $nonce = $_GET["nonce"];

          $token = TOKEN;
          $tmpArr = array($token, $timestamp, $nonce);
          sort($tmpArr, SORT_STRING);
          $tmpStr = implode( $tmpArr );
          $tmpStr = sha1( $tmpStr );

          if ($tmpStr == $signature ) {
              return true;
          } else {
              return false;
          }
      }
  #+END_EXAMPLE





  PHP 示例代码下载：[[https://wximg.gtimg.com/shake_tv/mpwiki/cryptoDemo.zip][下载<<>>]]

****** [[index_u42.html#第三步：接收消息和事件][#]] 第三步：接收消息和事件
  
  
 


  当某些特定的用户操作引发事件推送时（如用户向小程序客服发送消息、或者进入会话等情况），微信服务器会将消息（或事件）的数据包以
  POST 请求发送到开发者配置的 URL，开发者可以依据自身业务逻辑进行响应。

  微信服务器在将用户的消息发给开发者服务器地址后，微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。如果在调试中，发现用户无法收到响应的消息，可以检查是否消息处理超时。关于重试的消息排重，有
  msgid 的消息推荐使用 msgid 排重。事件类型消息推荐使用 FromUserName +
  CreateTime 排重。

  服务器收到请求必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试，否则，将出现严重的错误提示。详见下面说明：

  1. 直接回复 success（推荐方式）
  2. 直接回复空串（指字节长度为 0 的空字符串，而不是结构体中 content 字段的内容为空）
  3. 若接口文档有指定返回内容，应按文档说明返回

  对于客服消息，一旦遇到以下情况，微信会在小程序会话中向用户下发系统提示“该小程序客服暂时无法提供服务，请稍后再试”：

  1. 开发者在 5 秒内未回复任何内容
  2. 开发者回复了异常数据

  如果开发者希望增强安全性，可以在开发者中心处开启消息加密，这样，用户发给小程序的消息以及小程序被动回复用户消息都会继续加密，详见[[https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN][消息加解密说明<<>>]]。



***** [[index_u42.html#云函数接收消息推送][#]] 云函数接收消息推送
  
  
 


  #+BEGIN_QUOTE
    需开发者工具版本至少 =1.02.1906252=
  #+END_QUOTE

  开通了[[https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html][云开发<<>>]]的小程序可以使用云函数接收消息推送，目前仅支持客服消息推送。

  接入步骤如下：

  1. 开发者工具中填写配置并上传
  2. 云函数中处理消息

****** [[index_u42.html#第一步：开发者工具云开发控制台中增加配置][#]]
  第一步：开发者工具云开发控制台中增加配置
  
  
 


  打开云开发控制台，到设置 tab 中选择全局设置 -
  添加消息推送配置。消息类型对应收包的 =MsgType=，事件类型对应收包的
  =Event=，同一个 =<消息类型, 事件类型>=
  二元组只能推到一个环境的一个云函数。例如客服消息文本消息对应的就是消息类型为
  =text=，事件类型为空。具体值请查看各个消息的消息格式。

****** [[index_u42.html#第二步：云函数中处理消息][#]]
  第二步：云函数中处理消息
  
  
 


  云函数被触发时，其 =event= 参数即是接口所定义的 JSON 结构的对象（统一
  =JSON= 格式，不支持 =XML= 格式）。

  以客服消息为例，接收到客服消息推送时，=event= 结构如下：





  #+BEGIN_EXAMPLE
      {
        "FromUserName": "ohl4L0Rnhq7vmmbT_DaNQa4ePaz0",
        "ToUserName": "wx3d289323f5900f8e",
        "Content": "测试",
        "CreateTime": 1555684067,
        "MsgId": "49d72d67b16d115e7935ac386f2f0fa41535298877_1555684067",
        "MsgType": "text"
      }
  #+END_EXAMPLE





  此时可调用客服消息[[../../api-backend/open-api/customer-message/customerServiceMessage.send.html][发送]]接口回复消息，一个简单的接收到消息后统一回复
  “收到” 的示例如下：





  #+BEGIN_EXAMPLE
      // 云函数入口文件
      const cloud = require('wx-server-sdk')

      cloud.init()

      // 云函数入口函数
      exports.main = async (event, context) => {
        const wxContext = cloud.getWXContext()
      
        await cloud.openapi.customerServiceMessage.send({
          touser: wxContext.OPENID,
          msgtype: 'text',
          text: {
            content: '收到',
          },
        })

        return 'success'
      }
  #+END_EXAMPLE

















  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html]]

  \\
  \\


















  --------------













**** [[index_u16.html#自定义-tabBar][#]] 自定义 tabBar
  
  
 


  #+BEGIN_QUOTE
    基础库 2.5.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  自定义 tabBar 可以让开发者更加灵活地设置 tabBar
  样式，以满足更多个性化的场景。

  在自定义 tabBar 模式下

  -  为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar
     的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染。
  -  此时需要开发者提供一个自定义组件来渲染 tabBar，所有 tabBar
     的样式都由该自定义组件渲染。推荐用 fixed 在底部的
     [[../../component/cover-view.html][cover-view]] +
     [[../../component/cover-image.html][cover-image]]
     组件渲染样式，以保证 tabBar 层级相对较高。
  -  与 tabBar 样式相关的接口，如
     [[../../api/ui/tab-bar/wx.setTabBarItem.html][wx.setTabBarItem]]
     等将失效。
  -  *每个 tab 页下的自定义 tabBar 组件实例是不同的*，可通过自定义组件下的
     =getTabBar= 接口，获取当前页面的自定义 tabBar 组件实例。

  *注意：如需实现 tab 选中态，要在当前页面下，通过 =getTabBar=
  接口获取组件实例，并调用 setData 更新选中态。可参考底部的代码示例。*

***** [[index_u16.html#使用流程][#]] 使用流程
  
  
 


****** [[index_u16.html#_1-配置信息][#]] 1. 配置信息
  
  
 


  -  在 =app.json= 中的 =tabBar= 项指定 =custom= 字段，同时其余 =tabBar=
     相关配置也补充完整。
  -  所有 tab 页的 json 里需声明 =usingComponents= 项，也可以在 =app.json=
     全局开启。

  示例：





  #+BEGIN_EXAMPLE
      {
        "tabBar": {
          "custom": true,
          "color": "#000000",
          "selectedColor": "#000000",
          "backgroundColor": "#000000",
          "list": [{
            "pagePath": "page/component/index",
            "text": "组件"
          }, {
            "pagePath": "page/API/index",
            "text": "接口"
          }]
        },
        "usingComponents": {}
      }
  #+END_EXAMPLE





***** [[index_u16.html#_2-添加-tabBar-代码文件][#]] 2. 添加 tabBar
  代码文件
  
  
 


  在代码根目录下添加入口文件:





  #+BEGIN_EXAMPLE
      custom-tab-bar/index.js
      custom-tab-bar/index.json
      custom-tab-bar/index.wxml
      custom-tab-bar/index.wxss
  #+END_EXAMPLE





****** [[index_u16.html#_3-编写-tabBar-代码][#]] 3. 编写 tabBar 代码
  
  
 


  用自定义组件的方式编写即可，该自定义组件完全接管 tabBar
  的渲染。另外，自定义组件新增 =getTabBar= 接口，可获取当前页面下的自定义
  tabBar 组件实例。

***** [[index_u16.html#示例代码][#]] 示例代码
  
  
 


  [[https://developers.weixin.qq.com/s/jiSARvmF7i55][在开发者工具中预览效果<<>>]]













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html]]

  \\
  \\


















  --------------













**** [[index_u75.html#周期性更新][#]] 周期性更新
  
  
 


  #+BEGIN_QUOTE
    基础库 2.8.0 开始支持，低版本需做[[../compatibility.html][兼容处理]]。
  #+END_QUOTE

  #+BEGIN_QUOTE
    生效条件：用户七天内使用过的小程序
  #+END_QUOTE

  周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。

***** [[index_u75.html#使用流程][#]] 使用流程
  
  
 


****** [[index_u75.html#_1-配置数据下载地址][#]] 1. 配置数据下载地址
 
  
 


  登录小程序 MP 管理后台，进入设置 -> 开发设置 ->
  数据周期性更新，点击开启，填写数据下载地址。

  [[file:feed_0/article_96/images/img1_u9.png]]
****** [[index_u75.html#_2-设置-TOKEN][#]] 2. 设置 TOKEN
 
  
 


  第一次启动小程序时，调用
  [[../../api/storage/background-fetch/wx.setBackgroundFetchToken.html][wx.setBackgroundFetchToken()]]
  设置一个 TOKEN
  字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

  示例：





  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.setBackgroundFetchToken({
            token: 'xxx'
          })
        }
      })
  #+END_EXAMPLE





****** [[index_u75.html#_3-微信客户端定期拉取数据][#]] 3.
  微信客户端定期拉取数据
 
  
 


  微信客户端会在一定的网络条件下，每隔 12
  小时（以上一次成功更新的时间为准）向配置的数据下载地址发起一个 HTTP GET
  请求，其中包含的 query 参数如下，数据获取到后会将整个 HTTP body
  缓存到本地。





  | 参数        | 类型     | 说明                               |
  |-------------+----------+------------------------------------|
  | appid       | String   | 小程序标识                         |
  | token       | String   | 前面设置的 TOKEN                   |
  | timestamp   | Number   | 时间戳，微信客户端发起请求的时间   |





  #+BEGIN_QUOTE
    query 参数会使用 urlencode 处理
  #+END_QUOTE

  #+BEGIN_QUOTE
    开发者服务器接口返回的数据类型应为字符串，且大小应不超过
    =256KB=，否则将无法缓存数据
  #+END_QUOTE

****** [[index_u75.html#_4-读取数据][#]] 4. 读取数据
 
  
 


  用户启动小程序时，调用
  [[../../api/storage/background-fetch/wx.getBackgroundFetchData.html][wx.getBackgroundFetchData()]]
  获取已缓存到本地的数据。

  示例：





  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.getBackgroundFetchData({
            fetchType: 'periodic',
            success(res) {
              console.log(res.fetchedData) // 缓存数据
              console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
            }
          })
        }
      })
  #+END_EXAMPLE





***** [[index_u75.html#调试方法][#]] 调试方法
 
  
 


  由于微信客户端每隔 12
  个小时才会发起一次请求，调试周期性更新功能会显得不太方便。
  因此为了方便调试周期性数据，工具提供了下面的调试能力给到开发者，具体可查看[[../../devtools/periodic-data.html][周期性数据调试]]。













  --------------


  [[https://developers.weixin.qq.com/miniprogram/dev/framework/ability/background-fetch.html]]

  \\
  \\


















  --------------













**** [[index_u74.html#数据预拉取][#]] 数据预拉取
 
  
 


  预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度
  。

***** [[index_u74.html#使用流程][#]] 使用流程
 
  
 


****** [[index_u74.html#_1-配置数据下载地址][#]] 1. 配置数据下载地址
 
  
 


  登录小程序 MP 管理后台，进入设置 -> 开发设置 ->
  数据预加载，点击开启，填写数据下载地址，只支持 HTTPS 。

  [[file:feed_0/article_97/images/img1_u8.png]]
****** [[index_u74.html#_2-设置-TOKEN][#]] 2. 设置 TOKEN
 
  
 


  第一次启动小程序时，调用
  [[../../api/storage/background-fetch/wx.setBackgroundFetchToken.html][wx.setBackgroundFetchToken()]]
  设置一个 TOKEN
  字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

  示例：





  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.setBackgroundFetchToken({
            token: 'xxx'
          })
        }
      })
  #+END_EXAMPLE





****** [[index_u74.html#_3-微信客户端提前拉取数据][#]] 3.
  微信客户端提前拉取数据
 
  
 


  当用户打开小程序时，微信服务器将向开发者服务器（上面配置的数据下载地址）发起一个
  HTTP GET 请求，其中包含的 query 参数如下，数据获取到后会将整个 HTTP body
  缓存到本地。





  | 参数        | 类型     | 必填   | 说明                                                                                                    |
  |-------------+----------+--------+---------------------------------------------------------------------------------------------------------|
  | appid       | String   | 是     | 小程序标识。                                                                                            |
  | token       | String   | 否     | 前面设置的 TOKEN。                                                                                      |
  | code        | String   | 否     | 用户登录凭证，未设置 TOKEN 时由微信侧预生成，可在开发者后台调用 auth.code2Session，换取 openid 等信息。   |
  | timestamp   | Number   | 是     | 时间戳，微信客户端发起请求的时间                                                                        |
  | path        | String   | 否     | 打开小程序的路径。                                                                                      |
  | query       | String   | 否     | 打开小程序的 query。                                                                                     |
  | scene       | Number   | 否     | 打开小程序的场景值。                                                                                    |





  #+BEGIN_QUOTE
    query 参数会使用 urlencode 处理
  #+END_QUOTE

  #+BEGIN_QUOTE
    token 和 code 只会存在一个，用于标识用户身份。
  #+END_QUOTE

  #+BEGIN_QUOTE
    开发者服务器接口返回的数据类型应为字符串，且大小应不超过
    =256KB=，否则将无法缓存数据
  #+END_QUOTE

****** [[index_u74.html#_4-读取数据][#]] 4. 读取数据
 
  
 


  用户启动小程序时，调用
  [[../../api/storage/background-fetch/wx.getBackgroundFetchData.html][wx.getBackgroundFetchData()]]
  获取已缓存到本地的数据。

  示例：





  #+BEGIN_EXAMPLE
      App({
        onLaunch() {
          wx.getBackgroundFetchData({
            fetchType: 'pre',
            success(res) {
              console.log(res.fetchedData) // 缓存数据
              console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
              console.log(res.path) // 页面路径
              console.log(res.query) // query 参数
              console.log(res.scene) // 场景值
            }
          })
        }
      })
  #+END_EXAMPLE




  
