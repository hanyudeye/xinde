* #+AUTHOR: wuming
#+DATE: 2016-12-28
#+TITLE: 做学问,做生活,要有研究精神,不要浑浑噩噩
人活着，每天都要跟以前的自己比较，看进步了没有。历史，自己的人生。
编程的本质是建立某种抽象，而那种抽象只在某种环境下才有效！
信任某种物质的存在，信任有物质。并且信任物质有某种用途。信任的另一面就是接受。信仰自己的哲学，真理。 

* 人的本质是适应环境，如果不适应，就改造它，如果不改造，那就逃离那个环境，如果不行，就会毁灭。
* 人生不像函数吗？多接口，我们要完善自己的接口，不要有bug
* Peter Norvig：自学编程，十年磨一剑
你想当程序员么？
下面是我列举的程序员成功“食谱”

●沉醉于编程，编程是为了兴趣。保持这种充满兴趣的感觉，以便于你能将其投入到你的10年/10000小时的编程时间中。
●程序. 最好的学习方式是“在实践中学习”。更技术一些地说：“一个人在某个专业领域方面能够达到最高水平，
并不是因为这个人经验增长了以后而自动获得的，而是这个人为了进步所做出了专门的努力之后产生的结果。”
“最有效的学习包括如下几个要素：明确并且难度适当的任务，适应学习者个人情况，及时的信息反馈，有重新开始和改正错误的机会）
●同其他程序员交流，多阅读其他人写的程序。这些远比你看书或者上培训班重要
●如果你愿意的话，就选择去读一个计算机科学专业吧（当然你还可以去念这个专业的研究生）。如果你能做到这点，
那么你就有机会找到一些需要计算机学位认证的工作，也会让你对这个行业有更深的理解。不过，如果你不是上学的料，
那么你可以（当然需要有足够的毅力）靠自己学习，或者通过工作来积累经验。无论你采用哪种途径，光依靠书本是远远不够的。
“如果说仅仅靠学习油画和调色技术无法创造出顶尖的画家的话，那么光学习计算机科学课程更不能造就顶尖的程序员。”，
Eric Raymond这样说过，他著有《新黑客字典》一书。我所聘用过的最好的程序员仅仅只有高中文凭; 他写了很多伟大的软件，
他有他自己的新闻组，并且通过股权赚够了钱，还开了家属于自己的夜店。（作者说的这个人是Jamie Zawinski，
他是网景浏览器（Netscape）的早期开发这者之一，也是开源项目Mozilla和XEmacs的主要贡献者，他开了一家叫做DNA_lounge的夜店，位于旧金山的SoMa区——译者注）
●与其他程序员一起做项目。在某些项目中要尽量做到最好，在某些项目中却别做那么好。当你是最好的时候，你的领导能力就会得到锻炼，
并激发你高瞻远瞩的视野。当你做得不好的时候，你就能知道你的领导怎么做事，以及他们不喜欢哪些事（因为领导总是把那些他们不爱做的杂事丢给他们认为不得力的人去做）
●尝试跟随其他程序员一起做项目。尝试去理解其他人所写的代码。看看如果你无法找到代码的作者本人的情况下，理解和修正他写的代码需要花费什么样的代价。
同时也思考，如何规划你自己的程序代码，让它们更容易被其他人理解和维护。
●至少学习半打编程语言。包括一种支持类抽象的语言（例如Java或者C++），一种支持函数抽象的语言（例如Lisp或者ML）,一种支持语法抽象的语言（例如Lisp）,
一种支持声明式编程的语言（例如Prolog或者C++模板），一种支持协同程序的语言（例如Icon或者Scheme）,一种支持平行并发编程的语言（例如Sial）
●牢记“计算机科学”中包含着“计算机”这个词。了解计算机需要花多长的时间执行一条指令，花多长时间从内存中获取一个字(word)
（包括缓存命中和不命中两种情况），如果连续从磁盘中获取数据，时间消耗如何？以及需要花多少时间才能再磁盘上定位一个新的位置？
●尽量参与语言的标准化过程。往大了说，你可以试着加入ANSI C++委员会这样的专业组织，往小了讲，你也可以从自己的代码规范入手，
限定代码缩进是需要2个空格宽还是4个空格宽。无论采用哪种方式，你都需要了解其他人对于语言的喜好，以及他们的喜好的程度，甚至你要知道他们为什么产生这样的喜好的原因。
●有良好的意识，能尽快适应语言标准化的成果。

Fred Brooks所著的著名的论文《No Silver Bullets| 没有银弹》里向我们揭示了发现和培养软件设计人才的三步骤：
1.有组织地辨认顶尖的软件设计人才，越早越好
2.安排一个职业导师，为其职业前景指点迷津，并谨慎对待自己的职业履历
3.为成长中的设计师们提供机会，让他们能够互相激发促进。
即使一部分人已经具备了成为优秀软件设计人员的潜质，也需要经历工作的慢慢琢磨，方可展现才华。Alan Perlis则说得更加直接：
“任何人都可以被‘教’成一个雕塑匠，但米开朗基罗则被‘教’如何不要成为一个雕塑匠，因为他要做的是雕塑大师，。这个道理放到编程大师身上同样管用。”
Perlis认为，伟大的软件开发人员都有一种内在的特质，这种特质往往比他们所接受的训练更重要。但是这些特质是从哪里来的呢？是与生俱来的？
还是通过后天勤奋而来？正如Auguste Gusteau（动画电影《料理鼠王》里的幻象大厨）所说，“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”
我很情愿地说，将你生命中的大部分时间花在审慎地练习和提高上，这很重要！但是“无所畏惧”的精神，才是将促使这些练习成果凝聚成形的途径。
或者，就像是《料理鼠王》里那个与Gusteau作对的刻薄的美食评论家Anton Ego说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家在成名前可能是任何人。”
所以尽管去书店大买Java/Ruby/Javascript/PHP书籍吧；你也许会发现他们真的挺管用。但是这样做不会改变你的人生，也不会让你在整体经验上有什么提高。
24小时，几天，几周，做一个真正的程序员？光靠读书可读不出来。你尝试过连续24个月不懈努力提高自己么？呵呵，如果你做到了，好吧，那么你开始上路了……

* 编程的本质是闭着眼睛把程序抄一遍。
简单的生活：应该做的，家事，孝敬，运动，工作，学习。
不应该做的，过分游戏，网页，视频。
人，一个环境中的人，一个有着心理活动的人，一个有着家庭使命民族使命的人，一个有着利益需求的人，也是一个妄想脱世的人，一个复杂着的人。
在人的世界里，有富人，有穷人，有好人，有坏人,有特权阶层，有劳苦人民,有勤劳的人，有懒惰的人,有学生，有老师，有社会青年，有农民工。
有金碧辉煌的别墅，有摇摇欲坠的蓬屋。有麻木嘲笑的人，无动于衷的人，也有热心的人，明大理的人。
面对这五花八门的人，对于恶人要更恶，善人要真诚,挑事之人要善心。
人的社会结构,组织，团体，工业，商业，农业，服务业，有序的发展。劳动，金钱。
这个世界上有狮子，有老虎，有计算机。只是因为有，那么，如果有一头大象，你该怎么办？
一切幻想都是虚妄，要干就干实事。
当烦躁时，应该想到语言，计算机都是人发明的，人对计算机是有感情的。
程序就是编写一个变化过程，这就是本质。外部资源的变化。
当烦躁或郁闷时，就拼命工作，就没有时间抑郁了。
你为什么要忧郁呢？或者一天，会笑，看的见都是你乐观的理由呀！
面对难题忧郁，为什么不能这么想(呀，我居然碰到难题了，不容易呀！看看它难在哪里）
Edebug 调试器
edebug-set-mode
edebug-temp-display-freq-count
* 遗忘的本质是你学到的如果全部遗忘的话就是白操心。
* 人在大多情况下是潜意识在起作用。
* Linux kernel
* 我们是自己生活的主角
固执
* 哲理
1. 读书没有捷径，只能定定心心，不能求快，干其它事可以快，读书不行。读书！慢，还要多想。
2. 思维：联想；创造性思维；图像；
3. 看到一本书不能排斥，首先应想到作者付出多少的思维心血，然后要想到作者的思路来源。
4. 学渣和学霸的区别是，学渣一有挫折攻克不了就会放弃，而学霸会和挫折死抗到底，最后和真理做朋友。所以，朋友，不要轻言放弃。
5. 有这么一个世界，堪称世外桃源一样。这里有着鸣奏优美乐章的乐师;有着善作山水画的画师；也有研究数学的数学爱好者；有着不畏
艰辛传递资源的蚂蚁工；他还会通过那唯一的一架飞机平台与外面进行通信。这就是计算机的世界。
6. 有时为难，有时烦躁，有时想放肆，有时想邪恶。光光明明做人，要这些污点在身上干嘛！做个纯洁的自己。
7. 历史，名人这些意识，对人的帮助在哪里？有用处吗？
事物发展的规律，发展方向，提前作出判断。和避免犯同样的错误。
8. 人会疑惑，历史也会疑惑，但历史不相信疑惑，只会摆出疑惑的事实。
9. 当人在读书的时候，信息通过感官传到大脑的时候，大脑在干什么。
根其他信息进行参照。所以最好要把信息本质化，压缩成精华，那样便于参照，因为真理是很少的，也是很好理解的。
10. 真理很少多变，而感情和观念是易变的。
11. 人类在认识了事物规律后，就开始利用规律，作出一些创造。
12. 即使不知道也没什么，敢于提出不知道的问题，比如天是什么？
13. 文化，包括书，音乐，影视，只是一种意识，多变的不一定正确的。
14. 人是怎么组成的？提示：细胞。 
15. 二进制是表示文化的一种语言，就像自然语言一样！只是这种语言很难看懂，只有计算机能看懂。
16. 
* 心学
无善无恶心之体，有善有恶意之动。知善知恶是良知，为善去恶是格物。
* 格言
人的磁场很奇怪，你不感恩，就不顺利；你不承担责任，就不成长；你不付出，就得不到；你没有爱心，就没有人爱你。如此一来，便得出人生的规律：感恩=顺利，责任=成长，付出=得到，爱心=快乐。原来生活如此简单，你希望自己好运，就祝福别人好运。一切美好，皆源于一颗感恩的心。
 
* 客观存在
* 大脑研究
** 清醒与混浊
** 左右脑
** 思维
** 记忆
** 负面情绪与正面情绪
** 想象

* 语言研究
** 英语
*** 英语名词
*** 英语动词
* 数学
(数 (常量 变量))
(关系 (数 数))
(函数 (实数..))
(实数 （正整数 负整数 小数 分数))
(表示 (实数) (数轴(点)))
(连续性 (实数) (数轴 直线))
(集合 (数集 有理数集 生物集...) )
(绝对值 (实数))
(邻域 范围)
(表示法 (函数) (公式法 图像法 表格法))
(属性 (有界性 单调性 奇偶性 周期性))
(and 反函数  符合函数)
(初等函数 常值函数 幂函数 指数函数 对数函数 三角函数 反三角函数)
(非初等函数 分段函数 ...)
(数列 极限)
(极限 收敛数列 有界)
(数列极限的运算法则 同算数法则)
(性质 级数 收敛(有极限) 发散(无极限))
(函数极限)

* 我在考虑编程的时候过于注重形式,去关系他为什么有那种功能,
而不是关心他能做些什么,跟学习数学一点也不一样.编程的本质是编,
而不是关心他语法的来历
* shell script 
* 离散数学
逻辑
       This tutorial explains how to import a new project into
       Git, make changes to it, and share changes with other
       developers.

       If you are instead primarily interested in using Git to
       fetch a project, for example, to test the latest version,
       you may prefer to start with the first two chapters of The
       Git User’s Manual[1].

       First, note that you can get documentation for a command
       such as git log --graph with:

           $ man git-log
       or:
           $ git help log

       With the latter, you can use the manual viewer of your
       choice; see git-help(1) for more information.

       It is a good idea to introduce yourself to Git with your
       name and public email address before doing any operation.
       The easiest way to do so is:

           $ git config --global user.name "Your Name Comes Here"
           $ git config --global user.email you@yourdomain.example.com

IMPORTING A NEW PROJECT
       Assume you have a tarball project.tar.gz with your initial
       work. You can place it under Git revision control as
       follows.

           $ tar xzf project.tar.gz
           $ cd project
           $ git init

       Git will reply

           Initialized empty Git repository in .git/

       You’ve now initialized the working directory—you may notice
       a new directory created, named ".git".

       Next, tell Git to take a snapshot of the contents of all
       files under the current directory (note the .), with git
       add:

           $ git add .

       This snapshot is now stored in a temporary staging area
       which Git calls the "index". You can permanently store the
       contents of the index in the repository with git commit:

           $ git commit

       This will prompt you for a commit message. You’ve now
       stored the first version of your project in Git.

MAKING CHANGES
       Modify some files, then add their updated contents to the
       index:

           $ git add file1 file2 file3

       You are now ready to commit. You can see what is about to
       be committed using git diff with the --cached option:

           $ git diff --cached

       (Without --cached, git diff will show you any changes that
       you’ve made but not yet added to the index.) You can also
       get a brief summary of the situation with git status:

           $ git status
           On branch master
           Changes to be committed:
           Your branch is up-to-date with 'origin/master'.
             (use "git reset HEAD <file>..." to unstage)

                   modified:   file1
                   modified:   file2
                   modified:   file3

       If you need to make any further adjustments, do so now, and
       then add any newly modified content to the index. Finally,
       commit your changes with:

           $ git commit

       This will again prompt you for a message describing the
       change, and then record a new version of the project.

       Alternatively, instead of running git add beforehand, you
       can use

           $ git commit -a

       which will automatically notice any modified (but not new)
       files, add them to the index, and commit, all in one step.

       A note on commit messages: Though not required, it’s a good
       idea to begin the commit message with a single short (less
       than 50 character) line summarizing the change, followed by
       a blank line and then a more thorough description. The text
       up to the first blank line in a commit message is treated
       as the commit title, and that title is used throughout Git.
       For example, git-format-patch(1) turns a commit into email,
       and it uses the title on the Subject line and the rest of
       the commit in the body.

GIT TRACKS CONTENT NOT FILES
       Many revision control systems provide an add command that
       tells the system to start tracking changes to a new file.
       Git’s add command does something simpler and more powerful:
       git add is used both for new and newly modified files, and
       in both cases it takes a snapshot of the given files and
       stages that content in the index, ready for inclusion in
       the next commit.

VIEWING PROJECT HISTORY
       At any point you can view the history of your changes using

           $ git log

       If you also want to see complete diffs at each step, use

           $ git log -p

       Often the overview of the change is useful to get a feel of
       each step

           $ git log --stat --summary

MANAGING BRANCHES
       A single Git repository can maintain multiple branches of
       development. To create a new branch named "experimental",
       use

           $ git branch experimental

       If you now run

           $ git branch

       you’ll get a list of all existing branches:

             experimental
           * master

       The "experimental" branch is the one you just created, and
       the "master" branch is a default branch that was created
       for you automatically. The asterisk marks the branch you
       are currently on; type

           $ git checkout experimental

       to switch to the experimental branch. Now edit a file,
       commit the change, and switch back to the master branch:

           (edit file)
           $ git commit -a
           $ git checkout master

       Check that the change you made is no longer visible, since
       it was made on the experimental branch and you’re back on
       the master branch.

       You can make a different change on the master branch:

           (edit file)
           $ git commit -a

       at this point the two branches have diverged, with
       different changes made in each. To merge the changes made
       in experimental into master, run

           $ git merge experimental

       If the changes don’t conflict, you’re done. If there are
       conflicts, markers will be left in the problematic files
       showing the conflict;

           $ git diff

       will show this. Once you’ve edited the files to resolve the
       conflicts,

           $ git commit -a

       will commit the result of the merge. Finally,

           $ gitk

       will show a nice graphical representation of the resulting
       history.

       At this point you could delete the experimental branch with

           $ git branch -d experimental

       This command ensures that the changes in the experimental
       branch are already in the current branch.

       If you develop on a branch crazy-idea, then regret it, you
       can always delete the branch with

           $ git branch -D crazy-idea

       Branches are cheap and easy, so this is a good way to try
       something out.

USING GIT FOR COLLABORATION
       Suppose that Alice has started a new project with a Git
       repository in /home/alice/project, and that Bob, who has a
       home directory on the same machine, wants to contribute.

       Bob begins with:

           bob$ git clone /home/alice/project myrepo

       This creates a new directory "myrepo" containing a clone of
       Alice’s repository. The clone is on an equal footing with
       the original project, possessing its own copy of the
       original project’s history.

       Bob then makes some changes and commits them:

           (edit files)
           bob$ git commit -a
           (repeat as necessary)

       When he’s ready, he tells Alice to pull changes from the
       repository at /home/bob/myrepo. She does this with:

           alice$ cd /home/alice/project
           alice$ git pull /home/bob/myrepo master

       This merges the changes from Bob’s "master" branch into
       Alice’s current branch. If Alice has made her own changes
       in the meantime, then she may need to manually fix any
       conflicts.

       The "pull" command thus performs two operations: it fetches
       changes from a remote branch, then merges them into the
       current branch.

       Note that in general, Alice would want her local changes
       committed before initiating this "pull". If Bob’s work
       conflicts with what Alice did since their histories forked,
       Alice will use her working tree and the index to resolve
       conflicts, and existing local changes will interfere with
       the conflict resolution process (Git will still perform the
       fetch but will refuse to merge --- Alice will have to get
       rid of her local changes in some way and pull again when
       this happens).

       Alice can peek at what Bob did without merging first, using
       the "fetch" command; this allows Alice to inspect what Bob
       did, using a special symbol "FETCH_HEAD", in order to
       determine if he has anything worth pulling, like this:

           alice$ git fetch /home/bob/myrepo master
           alice$ git log -p HEAD..FETCH_HEAD

       This operation is safe even if Alice has uncommitted local
       changes. The range notation "HEAD..FETCH_HEAD" means "show
       everything that is reachable from the FETCH_HEAD but
       exclude anything that is reachable from HEAD". Alice
       already knows everything that leads to her current state
       (HEAD), and reviews what Bob has in his state (FETCH_HEAD)
       that she has not seen with this command.

       If Alice wants to visualize what Bob did since their
       histories forked she can issue the following command:

           $ gitk HEAD..FETCH_HEAD

       This uses the same two-dot range notation we saw earlier
       with git log.

       Alice may want to view what both of them did since they
       forked. She can use three-dot form instead of the two-dot
       form:

           $ gitk HEAD...FETCH_HEAD

       This means "show everything that is reachable from either
       one, but exclude anything that is reachable from both of
       them".

       Please note that these range notation can be used with both
       gitk and "git log".

       After inspecting what Bob did, if there is nothing urgent,
       Alice may decide to continue working without pulling from
       Bob. If Bob’s history does have something Alice would
       immediately need, Alice may choose to stash her
       work-in-progress first, do a "pull", and then finally
       unstash her work-in-progress on top of the resulting
       history.

       When you are working in a small closely knit group, it is
       not unusual to interact with the same repository over and
       over again. By defining remote repository shorthand, you
       can make it easier:

           alice$ git remote add bob /home/bob/myrepo

       With this, Alice can perform the first part of the "pull"
       operation alone using the git fetch command without merging
       them with her own branch, using:

           alice$ git fetch bob

       Unlike the longhand form, when Alice fetches from Bob using
       a remote repository shorthand set up with git remote, what
       was fetched is stored in a remote-tracking branch, in this
       case bob/master. So after this:

           alice$ git log -p master..bob/master

       shows a list of all the changes that Bob made since he
       branched from Alice’s master branch.

       After examining those changes, Alice could merge the
       changes into her master branch:

           alice$ git merge bob/master

       This merge can also be done by pulling from her own
       remote-tracking branch, like this:

           alice$ git pull . remotes/bob/master

       Note that git pull always merges into the current branch,
       regardless of what else is given on the command line.

       Later, Bob can update his repo with Alice’s latest changes
       using

           bob$ git pull

       Note that he doesn’t need to give the path to Alice’s
       repository; when Bob cloned Alice’s repository, Git stored
       the location of her repository in the repository
       configuration, and that location is used for pulls:

           bob$ git config --get remote.origin.url
           /home/alice/project

       (The complete configuration created by git clone is visible
       using git config -l, and the git-config(1) man page
       explains the meaning of each option.)

       Git also keeps a pristine copy of Alice’s master branch
       under the name "origin/master":

           bob$ git branch -r
             origin/master

       If Bob later decides to work from a different host, he can
       still perform clones and pulls using the ssh protocol:

           bob$ git clone alice.org:/home/alice/project myrepo

       Alternatively, Git has a native protocol, or can use rsync
       or http; see git-pull(1) for details.

       Git can also be used in a CVS-like mode, with a central
       repository that various users push changes to; see git-
       push(1) and gitcvs-migration(7).

EXPLORING HISTORY
       Git history is represented as a series of interrelated
       commits. We have already seen that the git log command can
       list those commits. Note that first line of each git log
       entry also gives a name for the commit:

           $ git log
           commit c82a22c39cbc32576f64f5c6b3f24b99ea8149c7
           Author: Junio C Hamano <junkio@cox.net>
           Date:   Tue May 16 17:18:22 2006 -0700

               merge-base: Clarify the comments on post processing.

       We can give this name to git show to see the details about
       this commit.

           $ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7

       But there are other ways to refer to commits. You can use
       any initial part of the name that is long enough to
       uniquely identify the commit:

           $ git show c82a22c39c   # the first few characters of the name are
                                   # usually enough
           $ git show HEAD         # the tip of the current branch
           $ git show experimental # the tip of the "experimental" branch

       Every commit usually has one "parent" commit which points
       to the previous state of the project:

           $ git show HEAD^  # to see the parent of HEAD
           $ git show HEAD^^ # to see the grandparent of HEAD
           $ git show HEAD~4 # to see the great-great grandparent of HEAD

       Note that merge commits may have more than one parent:

           $ git show HEAD^1 # show the first parent of HEAD (same as HEAD^)
           $ git show HEAD^2 # show the second parent of HEAD

       You can also give commits names of your own; after running

           $ git tag v2.5 1b2e1d63ff

       you can refer to 1b2e1d63ff by the name "v2.5". If you
       intend to share this name with other people (for example,
       to identify a release version), you should create a "tag"
       object, and perhaps sign it; see git-tag(1) for details.

       Any Git command that needs to know a commit can take any of
       these names. For example:

           $ git diff v2.5 HEAD     # compare the current HEAD to v2.5
           $ git branch stable v2.5 # start a new branch named "stable" based
                                    # at v2.5
           $ git reset --hard HEAD^ # reset your current branch and working
                                    # directory to its state at HEAD^

       Be careful with that last command: in addition to losing
       any changes in the working directory, it will also remove
       all later commits from this branch. If this branch is the
       only branch containing those commits, they will be lost.
       Also, don’t use git reset on a publicly-visible branch that
       other developers pull from, as it will force needless
       merges on other developers to clean up the history. If you
       need to undo changes that you have pushed, use git revert
       instead.

       The git grep command can search for strings in any version
       of your project, so

           $ git grep "hello" v2.5

       searches for all occurrences of "hello" in v2.5.

       If you leave out the commit name, git grep will search any
       of the files it manages in your current directory. So

           $ git grep "hello"

       is a quick way to search just the files that are tracked by
       Git.

       Many Git commands also take sets of commits, which can be
       specified in a number of ways. Here are some examples with
       git log:

           $ git log v2.5..v2.6            # commits between v2.5 and v2.6
           $ git log v2.5..                # commits since v2.5
           $ git log --since="2 weeks ago" # commits from the last 2 weeks
           $ git log v2.5.. Makefile       # commits since v2.5 which modify
                                           # Makefile

       You can also give git log a "range" of commits where the
       first is not necessarily an ancestor of the second; for
       example, if the tips of the branches "stable" and "master"
       diverged from a common commit some time ago, then

           $ git log stable..master

       will list commits made in the master branch but not in the
       stable branch, while

           $ git log master..stable

       will show the list of commits made on the stable branch but
       not the master branch.

       The git log command has a weakness: it must present commits
       in a list. When the history has lines of development that
       diverged and then merged back together, the order in which
       git log presents those commits is meaningless.

       Most projects with multiple contributors (such as the Linux
       kernel, or Git itself) have frequent merges, and gitk does
       a better job of visualizing their history. For example,

           $ gitk --since="2 weeks ago" drivers/

       allows you to browse any commits from the last 2 weeks of
       commits that modified files under the "drivers" directory.
       (Note: you can adjust gitk’s fonts by holding down the
       control key while pressing "-" or "+".)

       Finally, most commands that take filenames will optionally
       allow you to precede any filename by a commit, to specify a
       particular version of the file:

           $ git diff v2.5:Makefile HEAD:Makefile.in

       You can also use git show to see any such file:

           $ git show v2.5:Makefile

NEXT STEPS
       This tutorial should be enough to perform basic distributed
       revision control for your projects. However, to fully
       understand the depth and power of Git you need to
       understand two simple ideas on which it is based:

       ·   The object database is the rather elegant system used
           to store the history of your project—files,
           directories, and commits.

       ·   The index file is a cache of the state of a directory
           tree, used to create commits, check out working
           directories, and hold the various trees involved in a
           merge.

       Part two of this tutorial explains the object database, the
       index file, and a few other odds and ends that you’ll need
       to make the most of Git. You can find it at
       gittutorial-2(7).

       If you don’t want to continue with that right away, a few
       other digressions that may be interesting at this point
       are:

       ·   git-format-patch(1), git-am(1): These convert series of
           git commits into emailed patches, and vice versa,
           useful for projects such as the Linux kernel which rely
           heavily on emailed patches.

       ·   git-bisect(1): When there is a regression in your
           project, one way to track down the bug is by searching
           through the history to find the exact commit that’s to
           blame. Git bisect can help you perform a binary search
           for that commit. It is smart enough to perform a
           close-to-optimal search even in the case of complex
           non-linear history with lots of merged branches.

       ·   gitworkflows(7): Gives an overview of recommended
           workflows.

       ·   giteveryday(7): Everyday Git with 20 Commands Or So.

       ·   gitcvs-migration(7): Git for CVS users.

SEE ALSO
       gittutorial-2(7), gitcvs-migration(7), gitcore-tutorial(7),
       gitglossary(7), git-help(1), gitworkflows(7),
       giteveryday(7), The Git User’s Manual[1]

GIT
       Part of the git(1) suite.

NOTES
        1. The Git User’s Manual
           file:///usr/share/doc/git/html/user-manual.html

Git 2.7.4                   03/23/2016              GITTUTORIAL(7)
* 点子
本文讲宅在家里赚小钱的一些体会——我靠这些养活一家人。
目前据我观察和实践，“宅钱”有几种模式。
大家谈的很多的两种——当站长和开发共享软件就不提了。这里谈下其它途径：
（0）当站长和开发共享软件
（1）第一种是平台+定制，典型的是 ucenter home, supersite, dz 的定制和集成，这类活比较多，一般金额5000-20000。.Net下主要是dnn的定制，主要是国外项目。再如，火车头规则定制，这个便宜。
这些本人没尝试过——主要是php的，.net国内的少。
（2）第二种是平台+装修，比如，cms系统的装修，淘宝网店的装修，价格在千元上下。淘宝网店装修成品的话，一般卖几十到一二百元，有的专门搞淘宝装修的工作室，一年收入几十万。
（3）第三种是平台+产品，比如，iphone平台，以及mmarket平台。这方面，本人没尝试过，只是关注。javaeye上有几个家伙做iphone上的开发，
一个哥们目标市场定的非常明确——iphone下日本人需要的软件，这哥们第一个月收入1W，后来的不清楚。
（4）第四种是简单任务外包。简单任务外包主要是为了降低成本或者缩短项目周期。据我的观察，以降低成本的为主。国内这种任务，折算成时间收入，大致是2000-6000一月（我的估计值），也有高的，也有低的。
（5）第五种是困难任务外包。困难的任务外包主要是解决技术难题，很多企业都没有牛人，或者有牛人，术业有专攻，有解决不了的问题，外包一下。
估算一下，基本上能达到5000-30000一月。问题是其一数量不多，其二有技术风险，算期望值下来，每月收入也比上面第四种高不了多少。
现在手中有需求，需求非常简单，就是识别图片上的对象，要求识别率高，如果将项目预算除以开发时间，大致是 50000/月。但是，开发成功率不高，未必有20%。
第四种活是你干的时间越长钱越多，第五种活是你干的时间越短钱越多——客户巴不得你一天干完呢。
我目前第五种结合第四种过日子。
谈谈体会：一、收入 不要小瞧外包网站上的项目价格比较低，实际上投入去做的话，收入和上班差不多。但是，再向上，月收入要上万是相当的难
二、信用 信用很重要，大家都知道，不多说了
三、细分 细分很重要。细分就是你只做这一块，你就比别人有优势，当你哗啦哗啦列出案例，客户一下子就认定你了。
你如果不细分的话，啥都做一点，啥都不多，对比你的竞争对手就没有优势了。只做自己有优势的。这里有我最大的教训。
我以前搞过管理、搞过技术、搞过写作，三分兵力，结果都能过日子，但都过不了好日子。
现在在家里做宅男赚钱，有一段时间我想扩大收入，多涉及了几个自己不擅长的领域（Web开发），结果收入没扩大反而缩小了。
Web 开发人多，价格压得低，自己不擅长，开发效率又低，收入自然不高。非常赞同吉日兄的只做XXXX。只做一点，做到老大。
永远记住太祖评价诸葛亮的话：其始误于隆中对，千里之遥而二分兵力。其终则关羽、刘备、诸葛亮三分兵力，安能不败！
和吉日兄不同，俺没有工作，只做一点，活太少，不够养家糊口。所以定了3个方向——协议分析、网络推广、图像处理，
但三体合一（哈哈，最开始搞图像处理是因为要搞定验证码，搞协议分析也是为了推广。别骂哥，哥要过日子 。。。。。。）
四、平台 平台相当重要。做（1）-（3），你得熟悉所涉及到的平台和主要的定制需求。做（4）-（5），你也得有自己的平台，才能收入高。
否则，只是苦力收入。（btw. 顺便提一句，我认为金色海洋那种什么自然架构是我这里所说的平台，是方便为自己定制的平台，而不是为广泛的程序员制作的普适框架。）
我的其他尝试：
自从离开北京，回到我这个四线城市，我取得的最好的月收也只是1W。因为这种活，基本属于苦力活。你没有关系，又没有扎根一个行业（扎根一个行业的话就没法宅了），
想取得更高的收入，无法做到。而我又想突破这个收入，所以我做过或正在尝试以下尝试：
（2）规模化（已失败）——招聘人，组织开发项目（俺接小项目还挺好接的，基本随便接接就够干好一阵子）——失败。本地严重缺乏人才，自己培养浪费时间。而我又想保持目前这种生活方式。
（3）专业化——在某一两个领域做到国内顶尖乃至国际顶尖——努力中。目前协议分析在国内处于前列，现在在努力图像理解——哥的最好伙伴是电脑，哥得让电脑具备最大的能力——bot技术和机器智能是好帮手。
（4）平台化——一是网站平台，二是技术平台。技术平台在逐步完善，网站平台还没时间搞。三是第三方平台，比如mm平台，淘宝平台，这个还在观察，没找到一个好的切入点。
（5）服务化——简单说，就是“哥不提供产品，只提供服务”。比如说，验证码识别，提供一个接口，你传一个图片，给你识别传一个结果回去，识别一张一分钱或者半分钱。
既要能入世赚人民币，又要能出世逍遥自在，难啊！！

* 物质世界
** 变化 (灵魂,变化不同决定了是什么物质)
*** 相对(规律,逻辑)
*** 绝对
** 联系  蝴蝶效应
** 时间 (未解之谜) 有没快慢一说
盛年不重来，一日难再晨，及时当勉励，岁月不待人。
*** 时间管理方法
**** GTD 
收集
删选
计划
执行
回顾
**** 四象限法
**** 番茄工作法
: 人们在潜意识的时间多一些，有时不知道目的在哪里
** 意识 表面与深入
对「快速」的期望是「放松」的天敌。
心里一发慌，当然更睡不着。越追求，越得不到，这根本就是一个恶性循环。
创造(输出)
吸收(输入) 

* Need do
1.系统化的学习
2.抓住垃圾时间
3.调整心态(宽容)
4.本质而不是表象
5.认真看书
6.多思考
7.把空闲的时间用在编程上,当看不下文档的时候
* Not do
1.东瞧西看
2.浪费时间
3.心态不正
4.少看论坛多看源码
5.别看太快
6.别囫囵吞枣
7.编程了,就没有时间瞎抱怨了,或者改写文档
* math
** 自然数
** 复数
** 集合
** 算术
** 数论
*** 素数
*** 同余
** 代数
*** 微积分
** 几何(空间)
*** 拓扑
* 提神
首先保证晚上的睡眠，具体多长时间因人而异。
然后重点来了：吃完午饭火速找个安静的地方完全放松地打个盹，10~20分钟，哪怕半小时后天塌了也要完全放松。醒过来就又是一条好汉了。 
* 学不下去时，我用类比法自救
* 哈佛幸福课
** 积极的环境能改变人
** 过犹不及
** 幸福与幽默
** 收获交流
** 完美主义
** 自尊与自我实现
** 爱情与自尊
** 享受过程
** 写日记
** 睡眠
** 感激
** 环境的力量
** 逆境还是机遇
** 乐观主义
** 积极情绪
** 运动与冥想
** 如何去改变
** 养成良好习惯
** 面对压力
* 经济学
	人/物/时间
	趋势是发展,并且是客观的(需求发展)
	收入与付出(对生活有很大的影响)
	需求判断与真实需求 (经济问题)
	欲望
	竞争
	口红效应->没大钱只能买小钱
	纳什均衡
* 学习方法
学习学不进去的时候怎么办?
不管学霸还是学渣都有学不进去习的时候这时候你们都是怎么逼自己的还是干脆就不学了

1392 人赞同
我来给个方法论回答
我试过无数方法，解决学不下去的问题。
先整理几个失败的方法：
1，学不下去就不学：喝茶，喝咖啡，静坐，冥想，听音乐，网上看各种励志鸡汤，制定学习计划。通通无效。冥想半天睡着了，喝着咖啡就开始吃零食
了；听听音乐就顺便看了个电影，看着励志鸡汤就顺路看上了知乎。。。结果是一天一天又一天，继续荒废。

2，能占用的时间都占用，剩下的学习。就是所谓的逆序时间管理。把玩的时间都安排好，剩下可怜的几个小时学习。可玩的事情太多啊！玩着玩着心就
野了，更没法低头学习。

3，什么都不干：关手机，断网线，坐在桌前先呆5分钟。结果要不是百无聊赖不知不觉又玩上了，要不就是睡着了，或者一个人静默的胡思乱想。

4，先干点安静的事情：书法，画画，写日记。看窗外。我只能说，呵呵。人在拖延的时候，所有无聊的事情都拥有巨大的吸引力。我曾经静心练书法，
然后练着练着，觉得笔不好，然后就上网shopping 买笔去了。。。看看窗外，看到一只猫，就出去抓猫去了。还顺路拎回家只小猫，于是接下来的N天都
忙着养猫了。

我是长期抗争，屡败屡战。把吃不到奶的劲都使出来了，浑身上下能用的不能用的全都动员了一圈，才培养了一个脆弱的支持体系，维护我少得可怜的意
志力。

我有一个思想轨道论。人每一次的思想支配行为，都是在强化一条轨道。时间长了，要脱离轨道很难。天天在外头跑来跑去，就觉得家里呆不住。天天宅
在家里，就懒得去外面。早起的人恒早起，都是这个原理。人的精神状态，学习状态，懒惰程度，全有自己的轨道。玩三消/扫雷/纸牌类简单游戏的时候
，明明没啥瘾，甚至觉得有点无聊，可还是一局一局的玩下去，在那种时刻可以明显感受到”心流“ 在固定的轨道上涌动。”学不下去“的时候，就要给自
己打破现有的懒散轨道，铺一条”学习“轨道。

怎么”打破“现有轨道呢？分为环境和身体。环境包括：改变居住环境；改变学习环境；参加学习小组/课程；找学习伙伴，等等。身体包括：开始早起，
开始运动，规律作息和三餐。尤其我想强调一下运动对激发精神活力的作用。跑吧，小伙伴们。效果立竿见影。我自己有强烈的感觉，当成天宅在家里的
时候，身体的状态是懒散的，内敛的，肢体不会大舒大展，精神也是懒散的，专注细节的。跑起来之后，肢体舒展，环境改变，精神也被激活。瑜伽，跳
操，仰卧起坐之类固定在某地的运动都不行。

现有懒散的轨道打破之后，就要给自己铺设一条学习的轨道。这个过程挺难的。如果思想是河流，它已经在我们惰性的河床上流了太久。现在我们把它带
到学习的平原上，刚开始只能徒劳的浅浅划下痕迹，很容易散漫，很容易惯性的又回到原来。这时候就要用意志力给自己设限，约束河流往学习的方向走
。我用的是纸笔。字很烂，就是给大家一个参考：

高亮区是我对时间的记录。几点几分，接下来的时间我打算干什么。几点几分结束。用了多少时间。这可以约束自己的思想，也可以激发思维的主动性：
接下来5分钟我要做某某事。我用这个方法一直监督自己的思想，防止出轨。

还有一种学不下去的情况，就是思路卡住了，接下来遇到困难。通常的建议是暂停，干点别的事，再回来。可惜我要是干上别的事就回不来了。所以没办
法，只能死磕：

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

我就是坐在那里，各种吐槽，各种画小人诅咒，各种抱怨。做大量的无用功。但是都用纸笔记下来--要是光用脑子想，很快就控制不住想玩了。我就是写
写写，全是和学习有关的事情，然后在某一个点，突然灵光毕现，豁然开朗。

所以总结一下，学不下去的时候怎么办？早起，好好吃饭。收拾屋子，重新摆放家具位置，拿书到图书馆去。图书馆学不下去的，换个位置。换到咖啡店
去。换到教室去。下午出去跑圈。找个秒表，整个本，一分一秒的趴桌子上死磕。那种大学图书馆常见到的，拿张小桌布，抱个小水壶，听着音乐再啃个
水果，真的不是学习啊同学。

453 赞同反对
【看完不点赞小朋友真是太不可爱了】
补充几点：
1:我所说的“学不下去就逼着自己学”并不是说要死磕到底，而是在休息之后觉得状态恢复了一些时继续投入学习。
举个栗子，晚上八点钟的时候，你写数学题时脑袋发胀，不会写，写不下去了。这时候出去休息你有了两个选择：1，玩二十分钟之后，觉得放松了继续
回去写。2，玩个三四个小时继续回去写。
我的话我选选择一，玩个三四个小时之后十一二点钟了吧，这个时候就应该犯困了，多数人应该更写不下去了。还有整个学习计划就被彻底打乱了。
2:该困告的时候就应该果断立刻马上的去困告告，身体上革命的本钱，熬夜伤身啊少年。
=================以上2月1日早9:30更新=============
(*◑∇◑)☞【重要的事说三遍！】鸡汤喝多了会中毒！鸡汤喝多了会中毒！鸡汤喝多了会中毒！☜(◐∇◐*)
曾经有一段时间疯狂的迷恋各种正能量文字，看完之后真的挺振奋的，那种酸爽简直无法和深夜写作业比！但是那些喷鸡汤的真的想对他们说，暂时的振
奋就暂时的振奋，能让我埋头学习就是好鸡汤，好东西。那段时间，恩，怎么说，我成绩掉的比较严重的时候，让我重新回到前几名的、让我熬过那段时
间一直逼着我学习的就是那一些鸡汤。
然后现在。。。我看那些鸡汤再也没有感觉了，那段正能量文字满天飞的日子也过去了，我现在基本能知道的都是我以前看过的，还有什么刘同卢思浩那
些我从最开始看就觉得没什么感觉，刘同可以当做故事看或者人生感悟看，至于卢思浩。。你们愿意看你们开心就好。
所以！这次告诉你们两个东西！
1:鸡汤喝多了会中毒！给你那些正能量的东西总有一天会用完，接下来的路就要靠自己坚持下去！
2:在低谷的时候正能量文字是真的可以陪你挺过去！但是它是不能用多久而且可以第二次没用。☜(=σωσ=☜)

重要的事说三遍！点赞（上面说过一遍）点赞！
曾经在知乎里看到一句话：如果你不想学、学不进去了那就不学了，那你什么时候学？看到问题里有一个话题：熬夜。( ･ิϖ･ิ)っ这里想说起一些关于自己
的经历和感受。我家在城乡结合部，一个略老旧的社区里，社区里年轻人大多已经搬走，剩下的大部分是退休的老人和在孙女孙子的大妈（这段是废话，
可不看），自然而然广场舞的骚扰肯定少不了。←_←也不知道你们对于那种一整个晚上都在循环听大喇叭放：终于你做了别人的小三～的感觉是什么样子
。
后来我为了逃避这种精神污染，开始插耳机，可是呢，我发现一个问题——终于你做了别人的小三这十个字还是无法被音乐掩盖。【黑喂狗跟我唱终于你做
了别人的小三～】
放暑假了，我妈就开始放养我了。在最后几天刷作业的时候，我发现白天我根本无法放下手机安心写作业，无奈只好认命半夜刷作业。好家伙，半夜刷作
业跟打了鸡血似的，又精神又没有口水歌。（上课期间，不推荐半夜刷作业，因为这样貌似越刷越困。）从此之后半夜刷作业的日子一发不可收拾。
(๑òωó๑) 可是你知道后果是什么吗？恩？这个人脸色不好，脾气暴躁，这特么还胖了，胖了就算了，痘痘爆发，白天看什么都看不进。
好了，上面一段其实可以都不看，看这一句就好：上学期间千万不要熬夜写作业，早起补作业都好一点。熬夜之后你第二天晚上写作业更没精神更学不进
去，很烦躁脑子一片混沌啊有木有？？？！如果习惯熬夜的话，那就星期五晚点睡，不要写作业了，该玩就玩，第二天睡个懒觉，下午乖乖写作业。
2，学不进去的时候要逼着自己学。
如果不是精力的原因，那你要训练一下自己的毅力了？是不是觉得一到写作业的时候就发现指甲要剪了？这本小说居然挺好看的？好像我微博上有人评论
？我去看看热门微博？
乖乖，那我问你，那你准备什么时候学？玩够了再学？按照你这样说，当你打开热门微博的时候就会一条条看，再看看评论，好不容易翻完了你有手贱去
刷新关注去了，然后顺着顺着你就玩到了半夜。哦，半夜了啊，要写作业了啊？然后你就熬夜，熬夜写作业之后第二天继续学不进去，学不进去了我就玩
玩吧，之后你又点开了热门微博。。。。
很负责任的说，玩不够的。
再送你一句话：当你决定出发的时候，最困难的地方就已经度过了，所以，何不执行下去？
泡完脚，闭眼！困高！
如果明天题主看到了这个答案，拜托提醒我一下我明天起床洗头发，谢谢。

410 赞同反对
[da8e974dc_] 知乎用户我是机器鼓励师
“操，不可能不行啊，再看一遍！”
“既然这个世界上有别人能搞得定，我也一定可以搞定的，再来！”
“尼玛！终于明白了！操！我果然是天才”

最近在备考，一共六本厚厚的专业书可真是挑战。开始的时候是真的看不进去，毕竟放假了看专业书籍对我来说太残忍了，很烦躁，效率很低。在微博上
看到了清华陈吉宁校长的毕业典礼讲话，里面举了《Outliers》中的例子：无论是小提琴还是钢琴专业的学生，他们… 显示全部
最近在备考，一共六本厚厚的专业书可真是挑战。开始的时候是真的看不进去，毕竟放假了看专业书籍对我来说太残忍了，很烦躁，效率很低。
在微博上看到了清华陈吉宁校长的毕业典礼讲话，里面举了《Outliers》中的例子：无论是小提琴还是钢琴专业的学生，他们从5岁左右开始学琴，到20
岁时，那些具有成为世界级独奏家潜质的学生都至少练习了10000小时，那些被认为比较优秀的学生都至少练习了8000小时，而那些被认为将来只能成为
一名音乐辅导老师的学生只练习了4000小时。这就是所谓的“10000小时法则”。
之前也听过什么一件事只要做满多少多少小时，你就可以精通这件事，这次临近考试，我就打算实践一下，给自己的学习时间计个时。我使用手机秒表计
的时，当我按“开始”的一刹那，就感觉战斗开始了！过一会会看一下手机，啊呀，看了45分钟了，再过一小会就一个小时了！哈哈真开心。~然后不知不
觉地多看了30分钟，休息的时候停止计时，等调整好再计时开始，以此类推。看到秒表上的数字不断累积，秒位数字飞快地闪着，然后从秒到分最后累积
到小时，感觉是对自己刚才的精力集中做了一个很直观的量化，虽然离前面提到的4000小时还有很长的距离，但是方向却很明朗，而且也有一个结果在那
里放着，就算最后不是最好，但也绝对不会是最差。如果累计到了会不会真的发生奇迹呢，打心眼里期待这次实验的结果啊。
一天下来，我累计学习了6：56：47，这七个小时度过地都很高效，这种事在假期发生，这对我来说简直是奇迹啊。。。。太惭愧了。更让人开心的是，
明天我会继续在这个时间上累计计时，正在向着4000撒欢狂奔~

我觉得很多时候不能专心做事的原因，是因为较短的时间内很看到这件事给自己带来的有形的收益，随之而来的浮躁情绪，伴着懒惰的天性，便总会感觉
自己徘徊在原地。就算你进步了，你在学习过程中的不专心也会让你产生一种愧疚，会让你怀疑自己，否定自己的进步。数字上的量化会很直观地告诉你
，你前进了多少，离4000小时还有多远。

喜欢做各种方面的实验，就是因为好奇看到的说法到底是真的假的~哈哈哈！

时间久了，有了完整做一件事情的习惯再回头看这个答案，还是觉得这样的开始挺可爱的~


 青禾学医的小白，即将去医院实习~


我在二戰考研的時候，一邊工作，一邊學習。經常有學不下去的時候，忙了一天擠著公交吃完飯后居然還得刻苦學習，總覺得特別心酸。我總問自己，憑
什麼妳就得折騰，就不能在一個地方安心工作，別人都過得挺好，妳為什麼要拼命過得不好。
因為不甘心啊。因為沒有經歷過，不曾看到過，未能努力過，那些痛苦總會在我荒廢了一天后深夜折磨我，夜不能寐。
所以我得學習，哪怕多看了一張紙，多記住一句話，也比昨天的我要多前進一步。我並沒有卓越的天賦可以過目不忘，也沒有優越的家境供我衣食無憂，
我只能靠自己。努力，是最簡單也是最難的事。對於未來，我能做的也只有拼盡全力而已。
每當我學不進去的時候，我都會這樣想想，然後繼續翻書。
希望二戰順利。


没有不学这个选项，ABCD都是学。


如果是感觉浮躁，心神不定，告诉自己再坚持5分钟，如果5分钟后还不进入状态，建议休息一会。如果是觉得大脑迟钝，集中不了注意力，这时候需要换
换脑子，站起来动一动，吃点东西，喝点水，再学。这时候可以换一样科目。有时候觉得东西多，压力大，怎么学也… 显示全部
如果是感觉浮躁，心神不定，告诉自己再坚持5分钟，如果5分钟后还不进入状态，建议休息一会。
如果是觉得大脑迟钝，集中不了注意力，这时候需要换换脑子，站起来动一动，吃点东西，喝点水，再学。这时候可以换一样科目。
有时候觉得东西多，压力大，怎么学也学不完干脆不学时。制定计划，定下最重要的几个目标，目标越少越好，帮助自己朝一个方向努力。
随时想到要做的事（和学习无关），找张纸或本子随后记下来，一会儿再办。
把手机关机，放到别的房间。想想自己是为了什么在学习，努力必然是痛苦的，但现在的短期的痛苦是为了避免以后更大的痛苦。
骚年，加油，我也常常要克服这种情况= =。。


 征途是星辰与大海大学开始运动。越运动越努力

逼自己学，逼着逼着就适应了。
逼自己跑，跑着跑着就能跑了。
逼自己变，变着变着就成功了。


排名第一的回答提到，关键是心思要在学习上。那么如何集中心思到学习上？关键是引起学习的兴趣。这方面我的一个方法，就是提问题。把学习内容变
成一个个问题提出来，然后学习的过程，就是去钻研解决这些问题的方法。这样做的好处是因为，问题容易引起大脑… 显示全部
排名第一的回答提到，关键是心思要在学习上。那么如何集中心思到学习上？
关键是引起学习的兴趣。
这方面我的一个方法，就是提问题。把学习内容变成一个个问题提出来，然后学习的过程，就是去钻研解决这些问题的方法。这样做的好处是因为，问题
容易引起大脑的兴趣，大脑的一个特点是想把未完成的问题解决掉，没有解决的时候就会一直去想，甚至吃饭想，睡觉想，这个时候其他的诱惑都弱爆了
，就是钻研这个问题才是最有意思的事。
这个方法尤其适合对于感兴趣的内容钻研性的学习，而且往往能体会到钻研的乐趣和进步的感觉。
** 心理活动(大脑活动而不是心)
*** 感觉
感觉器官（5官+皮肤）接收外在刺激把刺激传给大脑的过程 。这个过程是潜意识下的我们是意识不到的
**** 视觉
**** 听觉
**** 其他
***** 嗅觉
***** 味觉
***** 触觉 动觉
***** 肤觉
*** 知觉
而知觉是潜意识把这些刺激通过我们的大脑神经加工过以后把信息送入我们的意识里
*** 心理,意识
**** 睡眠与梦
**** 其他状态
***** 清醒梦境
***** 催眠
***** 冥想
***** 幻觉
***** 宗教狂热
*** 智力
*** 动机
*** 人格
*** 心理障碍
**** 恐惧
一自己有信心、二找到陪同治疗的人、三找到好医生
*** 心理治疗

*** 社会影响
*** 社会心理学

** 行为活动
*** 学习    
*** 记忆
*** 目标
感觉，这种最虚无缥缈的东西，才是一个人活下来的动力。由此，要找到人生的目标，
一定要先从回忆你最美好的感觉开始。是和家人在一起的时光，还是在户外呼吸到新鲜的空气，
是团队协作攻克一个个难题，还是通过自己的研究得出一个有价值的结论。在这一过程中，
切记抛弃道德观念的束缚，喜欢慵懒的躺在沙发上与喜欢成为沙场点兵的商业巨子之间，没有好坏没有优劣

*** 人的发展
五岁时，妈妈告诉我，人生的关键在于快乐。上学后，人们问我长大了要做什么，我写下“快乐”。
他们告诉我，我理解错了题目，我告诉他们，他们理解错了人生。——约翰·列侬

** 心灵鸡汤
*** 心小,任何小事都是障碍
*** 天下只有三种事：我的事，他的事，老天的事。抱怨自己的人，应该试着学习接纳自己；抱怨他人的人，应该试着把抱怨转成请求；抱怨老天的人，请试着用祈祷的方式来诉求你的愿望。
*** 一本书，一只手环，改变爱抱怨的你，成就不抱怨的世界。
*** 养成能力的四个阶段是：
　　1.无意识的无能：
　　2.有意识的无能；
　　3.有意识的有能；
　　4.无意识的有能 。
*** 永远不要找别人要安全感
*** 信心
信心不仅来源于自身的实力，也来源于自身的气质，更来源于自身的锻炼，展示自身信心的方法首先要从外在做起，当你在众人面前的时候，你要学会微笑，你地言谈举止特别重要，不是要你一副盛气凌人的样子，而是学会不卑。关键在于你地内心，你如果内心里面充满了自信，你就会自然而然的流露出来。积极地自我暗示也非常重要。你要告诉自己，你不要和别人比，你就和昨天的自己比，今天你是否比昨天更懂得微笑，更加信心满满，更加的开朗活泼，更加自信幽默。
每天都要进行自我暗示，努力告诉自己，你要比别人做的更好，让别人去佩服你，更不是去嫉妒你。
** 前进方向
 目标
独立思维
实践测试成长 交互的是自己
技术 操控的是机器
交流 交互的是人
家庭 父母
思考
思考 具体
思考 要什么 不要什么
工作: 服务行业; 服务工具; 工具完美 
网页完美
视觉/操控/功能
我这样思考之后的结果是：1.发现自己需要一个稳定的家庭，我还喜欢小孩子 2. 我很想证明自己 3. 我不喜欢做别人做滥了的事，我喜欢创新，我总有新点子 4. 我擅长并热衷揣测别人的心思，我观察非常仔细 5.我不喜欢单兵作战，我喜欢和兄弟们一起打拼。如果你仔细思考了，你应该和我一样，得到几条你想要的感觉。

之后，以你的感觉为目标，建立自己的坐标系，落实到自己的生活和工作中去。曾经我觉得只要自己努力，什么工作都能做好，但实际做的时候，总觉得不称心，不如意。但我建立自己的坐标之后，我就开始找一份可以集合以上345点的工作，它就是marketing，而我可以为他付出120%的精力。

如果明天我将死去！
（现在是晚上，好像有点可悲，没关系，惊天地泣鬼神的事情发生在暗夜是不错的选择）
你需要近一步确定自己的方向。先告诉我你现在感觉累吗？记住，不要在身体觉得累的时候进行人生的思考，觉得自己一事无成的时候就先滚上床睡觉去吧。睡一觉充电去，明天四点我在知乎等你。如果你现在正在感到自己将进行脱胎换骨的兴奋，再也没有比现在更好哦的了。那我们就继续
接下来要做的是，把浪费你时间的东西或人从生活中剔除。
比如qq上闲聊的人
比如天天找你吃喝的朋友（如果这是你的人生目标或快乐的事，那就……）
比如镜子
比如游戏
首先学会克制自己，很小的事情就可以。例如
今天不吃晚饭
今天不吃肉
想说的一句话忍住不说
想要夹得菜不去夹它
嘘嘘到一半憋住
装一个生鸡蛋一天不让它碎了
这都是小事，但慢慢锻炼过后，你会在大事上也会有良好的控制力。
然后学会坚持。
每天给心爱的人准时发一条短信
每天扎马步两分钟
每天喝八杯水
每天对三个陌生人微笑
每天写一句话
每天上知乎^ ^
接下来回顾以上
1.确定目标
2.制定计划
3.实施计划
这是件令人激动的事情，但最重要的是勇敢的去实施。有对梦想负责的勇气。你要告诉自己，不论结果成功失败，我都不在乎，我不是为了做这件事而去做。在实现的过程中，一边制定新计划，一边进行修改。这样你可以会保持兴奋，反复循环，乐此不彼。我不知道你的目标是什么，但是我奉劝你活着不能眼里只有目标。比如你要挣五百万，然后就像个骡子一样的早出晚归只是为了挣钱而挣钱。人不是野兽。要时而慢下来，接触大自然，看看自己走歪了没有。不要着急成功，完成目标。我相信，你的人生还很长，如果早早的得到万人赞赏，你会变得傲慢忘记了最单纯的目标，这种目标对于人生的意义没什么意义。如果你不去炫耀的过去，将会不迷失在自己的世界。
改变思想比学习技术更重要。
-------------尼采 
