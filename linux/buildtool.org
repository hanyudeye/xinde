#+TITLE: 编程工具
#+DESCRIPTION: 编程工具
#+TAGS: 编程工具
#+CATEGORIES: 软件使用

* 编译器(解释器)
** 预处理 (-E)
   识别高级语言源文件( c , cpp ..)中的预处理指令
*** 一些常量
    __DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
    __TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
    __FILE__	这会包含当前文件名，一个字符串常量。
    __LINE__	这会包含当前行号，一个十进制常量。
    __STDC__	当编译器以 ANSI 标准编译时，则定义为 1。
*** 一些运算符
**** 宏延续运算符（\）
**** 字符串常量化运算符（#）
     在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符
     （#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

     #+begin_src c
       #include <stdio.h>

       #define  message_for(a, b)                      \
         printf(#a " and " #b ": We love you!\n")

       int main(void)
       {
         message_for(Carole, Debra);
         return 0;
       }

     #+end_src
**** 标记粘贴运算符（##）
     #+begin_src c
       #include <stdio.h>
       #define tokenpaster(n) printf ("token" #n " = %d", token##n)

       int main(void)
       {
         int token34 = 40;

         tokenpaster(34);
         return 0;
       }
     #+end_src
     当上面的代码被编译和执行时，它会产生下列结果：
     token34 = 40
   
     这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

     printf ("token34 = %d", token34);
 
     这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运
     算符（#）和标记粘贴运算符（##）。
**** defined() 运算符
     预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用
     #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未
     定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：

     #+begin_src c
       #include <stdio.h>

       #if !defined (MESSAGE)
       #define MESSAGE "You wish!"
       #endif

       int main(void)
       {
         printf("Here is the message: %s\n", MESSAGE);  
         return 0;
       }
     #+end_src
   
     当上面的代码被编译和执行时，它会产生下列结果：
     Here is the message: You wish!
**** 参数化的宏
     CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个
     数的平方：

     #+begin_src c
       int square(int x) {
         return x * x;
       }
     #+end_src
   
     我们可以使用宏重写上面的代码，如下：

     #define square(x) ((x) * (x))
 
     在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必
     须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

     #+begin_src c
       #include <stdio.h>

       #define MAX(x,y) ((x) > (y) ? (x) : (y))

       int main(void)
       {
         printf("Max between 20 and 10 is %d\n", MAX(10, 20));  
         return 0;
       }
     #+end_src
     当上面的代码被编译和执行时，它会产生下列结果：
     Max between 20 and 10 is 20
*** 一些命令
    #define	定义宏
    #include	把源代码嵌入到当前文件
    #undef	取消已定义的宏
    #ifdef	如果宏已经定义，则返回真
    #ifndef	如果宏没有定义，则返回真
    #if	如果给定条件为真，则编译下面代码
    #else	#if 的替代方案
    #elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
    #endif	结束一个 #if……#else 条件编译块
    #error	当遇到标准错误时，输出错误消息
    #pragma	使用标准化方法，向编译器发布特殊的命令到编译器中
** 编译 (-S)
   把预处理后的文件编译成汇编文件
*** c
    -O: 优化等级
    -m32/-m64: 机器机型
** 汇编 (-c)
   汇编 *程序* 或者 *库* 到 *目标文件*
   
    #+begin_src sh
      gcc -c $(src) -m32 -o $(obj)

      as --gstabs asm.S -o asm.o 
    #+end_src
    
** 链接 
   链接到 *执行文件*
   
   #+begin_src sh
   gcc -m32 data.o -o data
   
   ld -m elf_i386 -o
   ld --oformat binary -N -Ttext 0x7c00 -o $@ $<
   #+end_src
   
   显示架构列表  ld -V 

** 其他选项
*** 调试 
    --gstabs
*** 检错
    -Wall
    -Werror (警告当成错误)
*** 优化 O
*** 指定另外的包含路径 
    –I
*** 指定链接路径
    gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test
*** 强制使用静态库
    gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test
* 其他工具       
** 文件转换和拷贝[ dd ] 
   #+begin_src sh
	 dd if=boot of=boot.img bs=512 count=1
   #+end_src
   
   | bs=<字节数>    | 将输入与输出设成指定的字节数   |
   | cbs=<字节数>   | 转换时，每次只转换指定的字节数 |
   | conv=<关键字>  | 指定文件转换的方式             |
   | count=<区块数> | 仅读取指定的区块数             |
   | ibs=<字节数>   | 每次读取的字节数               |
   | obs=<字节数>   | 每次输出的字节数               |
   | of=<文件>      | 输出到文件                     |
   | seek=<区块数>  | 一开始输出时，跳过指定的区块数 |
   | skip=<区块数>  | 一开始读取时，跳过指定的区块数 |

** 模拟器[ qemu ]
   #+begin_src sh
     qemu-system-x86_64 -hda archlinux.vmdk -boot d -cdrom /home/wuming/soft/tar/archlinux-2017.03.01-dual.iso -m 512
   #+end_src
   
** 查看程序依赖库[ ldd ] 
** 归档[ ar ] 
** lsof 
   lsof（list open files）是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。

   lsof 打开的文件可以是：

   普通文件
   目录
   网络文件系统的文件
   字符或设备文件
   (函数)共享库
   管道，命名管道
   符号链接
   网络文件（例如：NFS file、网络 socket，unix 域名 socket）
   还有其它类型的文件，等等
   3.1. 命令参数
   -a 列出打开文件存在的进程
   -c<进程名> 列出指定进程所打开的文件
   -g 列出 GID 号进程详情
   -d<文件号> 列出占用该文件号的进程
   +d<目录> 列出目录下被打开的文件
   +D<目录> 递归列出目录下被打开的文件
   -n<目录> 列出使用 NFS 的文件
   -i<条件> 列出符合条件的进程。（4、6、协议、:端口、 @ip）
   -p<进程号> 列出指定进程号所打开的文件
   -u 列出 UID 号进程详情
   -h 显示帮助信息
   -v 显示版本信息
** ps
  linux 上进程有 5 种状态:
   运行(正在运行或在运行队列中等待)
   中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
   不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
   僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)
   停止(进程收到 SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 信号后停止运行运行)
   
   ps 工具标识进程的 5 种状态码:
   D 不可中断 uninterruptible sleep (usually IO)
   R 运行 runnable (on run queue)
   S 中断 sleeping
   T 停止 traced or stopped
   Z 僵死 a defunct (”zombie”) process
   4.1. 命令参数
   a 显示所有进程
   -a 显示同一终端下的所有程序
   -A 显示所有进程
   c 显示进程的真实名称
   -N 反向选择
   -e 等于“-A”
   e 显示环境变量
   f 显示程序间的关系
   -H 显示树状结构
   r 显示当前终端的进程
   T 显示当前终端的所有程序
   u 指定用户的所有进程
   -au 显示较详细的资讯
   -aux 显示所有包含其他使用者的行程
   -C<命令> 列出指定命令的状况
   –lines<行数> 每页显示的行数
   –width<字符数> 每页显示的字符数
   –help 显示帮助信息
   –version 显示版本显示
   4.2. 输出列的含义
   F 代表这个程序的旗标 (flag)，4 代表使用者为 super user
   S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍
   UID 程序被该 UID 所拥有
   PID 进程的 ID
   PPID 则是其上级父程序的 ID
   C CPU 使用的资源百分比
   PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍
   NI 这个是 Nice 值，在下一小节我们会持续介绍
   ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running 的程序，一般就是 “-“
   SZ 使用掉的内存大小
   WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作
   TTY 登入者的终端机位置
   TIME 使用掉的 CPU 时间。
   CMD 所下达的指令为何
** strace
   strace 常用来跟踪进程执行时的系统调用和所接收的信号。 在 Linux 世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace 可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。

   6.1. 输出参数含义
   每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。

   $strace cat /dev/null
   execve("/bin/cat", ["cat", "/dev/null"], [/* 22 vars */]) = 0
   brk(0)                                  = 0xab1000
   access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
   mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000
   access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
   ...
   6.2. 参数
   -c 统计每一系统调用的所执行的时间,次数和出错的次数等.
   -d 输出 strace 关于标准错误的调试信息.
   -f 跟踪由 fork 调用所产生的子进程.
   -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的 filename.pid 中,pid 是各进程的进程号.
   -F 尝试跟踪 vfork 调用.在-f 时,vfork 不被跟踪.
   -h 输出简要的帮助信息.
   -i 输出系统调用的入口指针.
   -q 禁止输出关于脱离的消息.
   -r 打印出相对时间关于,,每一个系统调用.
   -t 在输出中的每一行前加上时间信息.
   -tt 在输出中的每一行前加上时间信息,微秒级.
   -ttt 微秒级输出,以秒了表示时间.
   -T 显示每一调用所耗的时间.
   -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.
   -V 输出 strace 的版本信息.
   -x 以十六进制形式输出非标准字符串
   -xx 所有字符串以十六进制形式输出.
   -a column
   设置返回值的输出位置.默认 为 40.
   -e expr
   指定一个表达式,用来控制如何跟踪.格式如下:
   [qualifier=][!]value1[,value2]...
   qualifier 只能是 trace,abbrev,verbose,raw,signal,read,write 其中之一.value 是用来限定的符号或数字.默认的 qualifier 是 trace.感叹号是否定符号.例如:
   -eopen 等价于 -e trace=open,表示只跟踪 open 调用.而-etrace!=open 表示跟踪除了 open 以外的其他调用.有两个特殊的符号 all 和 none.
   注意有些 shell 使用!来执行历史记录里的命令,所以要使用\\.
   -e trace=set
   只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write 表示只跟踪这四个系统调用.默认的为 set=all.
   -e trace=file
   只跟踪有关文件操作的系统调用.
   -e trace=process
   只跟踪有关进程控制的系统调用.
   -e trace=network
   跟踪与网络有关的所有系统调用.
   -e strace=signal
   跟踪所有与系统信号有关的 系统调用
   -e trace=ipc
   跟踪所有与进程通讯有关的系统调用
   -e abbrev=set
   设定 strace 输出的系统调用的结果集.-v 等与 abbrev=none.默认为 abbrev=all.
   -e raw=set
   将指 定的系统调用的参数以十六进制显示.
   -e signal=set
   指定跟踪的系统信号.默认为 all.如 signal=!SIGIO(或者 signal=!io),表示不跟踪 SIGIO 信号.
   -e read=set
   输出从指定文件中读出 的数据.例如:
   -e read=3,5
   -e write=set
   输出写入到指定文件中的数据.
   -o filename
   将 strace 的输出写入文件 filename
   -p pid
   跟踪指定的进程 pid.
   -s strsize
   指定输出的字符串的最大长度.默认为 32.文件名一直全部输出.
   -u username
   以 username 的 UID 和 GID 执行被跟踪的命令
   6.3. 命令实例
   跟踪可执行程序
   strace -f -F -o ~/straceout.txt myserver
   -f -F 选项告诉 strace 同时跟踪 fork 和 vfork 出来的进程，-o 选项把所有 strace 输出写到~/straceout.txt 里 面，myserver 是要启动和调试的程序。

   跟踪服务程序
   strace -o output.txt -T -tt -e trace=all -p 28979
   跟踪 28979 进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在 output.txt 文件里面。
** elf 文件分析 [ readelf ] 
   这个工具和 objdump 命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖
   BFD 库(BFD 库是一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的
   目标文件）；

   ELF 文件类型
   ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF 是构成众多 xNIX 系统的基础之一。
   ELF 文件有三种类型：

   可重定位的对象文件(Relocatable file)
   由汇编器汇编生成的 .o 文件
   可执行的对象文件(Executable file)
   可执行应用程序
   可被共享的对象文件(Shared object file)
   动态库文件，也即 .so 文件
   .text section 里装载了可执行代码；
   .data section 里面装载了被初始化的数据；
   .bss section 里面装载了未被初始化的数据；
   以 .rec 打头的 sections 里面装载了重定位条目；
   .symtab 或者 .dynsym section 里面装载了符号信息；
   .strtab 或者 .dynstr section 里面装载了字符串信息；
   13.1. 参数说明
   -a –all 全部 Equivalent to: -h -l -S -s -r -d -V -A -I

   -h –file-header 文件头 Display the ELF file header

   -l –program-headers 程序 Display the program headers

   –segments An alias for –program-headers

   -S –section-headers 段头 Display the sections’ header

   --sections	
   An alias for –section-headers

   -e –headers 全部头 Equivalent to: -h -l -S

   -s –syms 符号表 Display the symbol table

   --symbols	
   An alias for –syms

   -n –notes 内核注释 Display the core notes (if present)

   -r –relocs 重定位 Display the relocations (if present)

   -u –unwind Display the unwind info (if present)

   -d –dynamic 动态段 Display the dynamic segment (if present)

   -V –version-info 版本 Display the version sections (if present)

   -A –arch-specific CPU 构架 Display architecture specific information (if any).

   -D –use-dynamic 动态段 Use the dynamic section info when displaying symbols

   -x –hex-dump=<number> 显示 段内内容 Dump the contents of section <number>

   -w[liaprmfFso] or

   -I –histogram Display histogram of bucket list lengths

   -W –wide 宽行输出 Allow output width to exceed 80 characters

   -H –help Display this information

   -v –version Display the version number of readelf

   13.2. 示例
   想知道一个应用程序的可运行的架构平台:

   $readelf -h main| grep Machine
   -h 选项将显示文件头的概要信息，从里面可以看到，有很多有用的信息：

   $readelf -h main
   ELF Header:
   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF64
   Data:                              2 s complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   Machine:                           Advanced Micro Devices X86-64
   Version:                           0x1
   Entry point address:               0x400790
   Start of program headers:          64 (bytes into file)
   Start of section headers:          5224 (bytes into file)
   Flags:                             0x0
   Size of this header:               64 (bytes)
   Size of program headers:           56 (bytes)
   Number of program headers:         8
   Size of section headers:           64 (bytes)
   Number of section headers:         29
   Section header string table index: 26
   一个编译好的应用程序，想知道其编译时是否使用了-g 选项（加入调试信息）:

   $readelf -S main| grep debug
   用-S 选项是显示所有段信息；如果编译时使用了-g 选项，则会有 debug 段;

   查看.o 文件是否编入了调试信息（编译的时候是否加了-g):

   $readelf -S Shpos.o | grep debug
   13.3. 完整输出
   readelf 输出的完整内容:

   $readelf -all a.out
   ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF32
   Data:                              2's complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   Machine:                           Intel 80386
   Version:                           0x1
   Entry point address:               0x8048330
   Start of program headers:          52 (bytes into file)
   Start of section headers:          4412 (bytes into file)
   Flags:                             0x0
   Size of this header:               52 (bytes)
   Size of program headers:           32 (bytes)
   Number of program headers:         9
   Size of section headers:           40 (bytes)
   Number of section headers:         30
   Section header string table index: 27

   Section Headers:
   [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
   [ 0]                   NULL            00000000 000000 000000 00      0   0  0
   [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
   [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
   [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
   [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
   [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
   [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
   [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
   [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
   [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
   [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
   [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4
   [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16
   [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16
   [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4
   [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4
   [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4
   [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4
   [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
   [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4
   [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4
   [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4
   [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
   [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
   [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
   [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
   [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1
   [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1
   [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4
   [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1
   Key to Flags:
   W (write), A (alloc), X (execute), M (merge), S (strings)
   I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
   O (extra OS processing required) o (OS specific), p (processor specific)

   There are no section groups in this file.

   Program Headers:
   Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
   PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
   INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
   [Requesting program interpreter: /lib/ld-linux.so.2]
   LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000
   LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000
   DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4
   NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
   GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4
   GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
   GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1

   Section to Segment mapping:
   Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06     .eh_frame_hdr
   07
   08     .ctors .dtors .jcr .dynamic .got

   Dynamic section at offset 0xf28 contains 20 entries:
   Tag        Type                         Name/Value
   0x00000001 (NEEDED)                     Shared library: [libc.so.6]
   0x0000000c (INIT)                       0x80482b4
   0x0000000d (FINI)                       0x80484bc
   0x6ffffef5 (GNU_HASH)                   0x80481ac
   0x00000005 (STRTAB)                     0x804821c
   0x00000006 (SYMTAB)                     0x80481cc
   0x0000000a (STRSZ)                      76 (bytes)
   0x0000000b (SYMENT)                     16 (bytes)
   0x00000015 (DEBUG)                      0x0
   0x00000003 (PLTGOT)                     0x8049ff4
   0x00000002 (PLTRELSZ)                   24 (bytes)
   0x00000014 (PLTREL)                     REL
   0x00000017 (JMPREL)                     0x804829c
   0x00000011 (REL)                        0x8048294
   0x00000012 (RELSZ)                      8 (bytes)
   0x00000013 (RELENT)                     8 (bytes)
   0x6ffffffe (VERNEED)                    0x8048274
   0x6fffffff (VERNEEDNUM)                 1
   0x6ffffff0 (VERSYM)                     0x8048268
   0x00000000 (NULL)                       0x0

   Relocation section '.rel.dyn' at offset 0x294 contains 1 entries:
   Offset     Info    Type            Sym.Value  Sym. Name
   08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

   Relocation section '.rel.plt' at offset 0x29c contains 3 entries:
   Offset     Info    Type            Sym.Value  Sym. Name
   0804a000  00000107 R_386_JUMP_SLOT   00000000   printf
   0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
   0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main

   There are no unwind sections in this file.

   Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
   0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
   1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
   2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
   3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
   4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used

   Symbol table '.symtab' contains 65 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
   0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
   1: 08048154     0 SECTION LOCAL  DEFAULT    1
   2: 08048168     0 SECTION LOCAL  DEFAULT    2
   3: 08048188     0 SECTION LOCAL  DEFAULT    3
   4: 080481ac     0 SECTION LOCAL  DEFAULT    4
   5: 080481cc     0 SECTION LOCAL  DEFAULT    5
   6: 0804821c     0 SECTION LOCAL  DEFAULT    6
   7: 08048268     0 SECTION LOCAL  DEFAULT    7
   8: 08048274     0 SECTION LOCAL  DEFAULT    8
   9: 08048294     0 SECTION LOCAL  DEFAULT    9
   10: 0804829c     0 SECTION LOCAL  DEFAULT   10
   11: 080482b4     0 SECTION LOCAL  DEFAULT   11
   12: 080482f0     0 SECTION LOCAL  DEFAULT   12
   13: 08048330     0 SECTION LOCAL  DEFAULT   13
   14: 080484bc     0 SECTION LOCAL  DEFAULT   14
   15: 080484d8     0 SECTION LOCAL  DEFAULT   15
   16: 080484ec     0 SECTION LOCAL  DEFAULT   16
   17: 08048520     0 SECTION LOCAL  DEFAULT   17
   18: 08049f14     0 SECTION LOCAL  DEFAULT   18
   19: 08049f1c     0 SECTION LOCAL  DEFAULT   19
   20: 08049f24     0 SECTION LOCAL  DEFAULT   20
   21: 08049f28     0 SECTION LOCAL  DEFAULT   21
   22: 08049ff0     0 SECTION LOCAL  DEFAULT   22
   23: 08049ff4     0 SECTION LOCAL  DEFAULT   23
   24: 0804a00c     0 SECTION LOCAL  DEFAULT   24
   25: 0804a014     0 SECTION LOCAL  DEFAULT   25
   26: 00000000     0 SECTION LOCAL  DEFAULT   26
   27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
   28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__
   29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__
   30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__
   31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux
   32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086
   33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088
   34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy
   35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
   36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__
   37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__
   38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__
   39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux
   40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
   41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end
   42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC
   43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start
   44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_
   45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini
   46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx
   47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start
   48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0
   49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
   50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini
   51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__
   52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start
   53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
   54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle
   55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
   56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
   57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init
   58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end
   59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start
   60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw
   61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
   62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main
   63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
   64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init

   Histogram for `.gnu.hash' bucket list length (total of 2 buckets):
   Length  Number     % of total  Coverage
   0  1          ( 50.0%)
   1  1          ( 50.0%)    100.0%

   Version symbols section '.gnu.version' contains 5 entries:
   Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)
   000:   0 (*local*)       2 (GLIBC_2.0)     0 (*local*)       2 (GLIBC_2.0)
   004:   1 (*global*)

   Version needs section '.gnu.version_r' contains 1 entries:
   Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)
   000000: Version: 1  File: libc.so.6  Cnt: 1
   0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2

   Notes at offset 0x00000168 with length 0x00000020:
   Owner                 Data size   Description
   GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)
   OS: Linux, ABI: 2.6.15

   Notes at offset 0x00000188 with length 0x00000024:
   Owner                 Data size   Description
   GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)
   Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65
** readelf 
** free
   free 工具用来查看系统可用内存:

   /opt/app/tdev1$free
   total       used       free     shared    buffers     cached
   Mem:       8175320    6159248    2016072          0     310208    5243680
   -/+ buffers/cache:     605360    7569960
   Swap:      6881272      16196    6865076
   解释一下 Linux 上 free 命令的输出。

   下面是 free 的运行结果，一共有 4 行。为了方便说明，我加上了列号。这样可以把 free 的输出看成一个二维数组 FO(Free Output)。例如:

   FO[2][1] = 24677460
   FO[3][2] = 10321516

   1          2          3          4          5          6
   1              total       used       free     shared    buffers     cached
   2 Mem:      24677460   23276064    1401396          0     870540   12084008
   3 -/+ buffers/cache:   10321516   14355944
   4 Swap:     25151484     224188   24927296
   free 的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。

   free 输出地第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。

   　　第一行的输出时从操作系统（OS）来看的。也就是说，从 OS 的角度来看，计算机上一共有:

   24677460KB（缺省时 free 的单位为 KB）物理内存，即 FO[2][1]； 在这些物理内存中有 23276064KB（即 FO[2][2]）被使用了； 还用 1401396KB（即 FO[2][3]）是可用的；

   这里得到第一个等式：

   FO[2][1] = FO[2][2] + FO[2][3]

   FO[2][4]表示被几个进程共享的内存的，现在已经 deprecated，其值总是 0（当然在一些系统上也可能不是 0，主要取决于 free 命令是怎么实现的）。

   FO[2][5]表示被 OS buffer 住的内存。FO[2][6]表示被 OS cache 的内存。在有些时候 buffer 和 cache 这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:

   A buffer is something that has yet to be "written" to disk.
   A cache is something that has been "read" from the disk and stored for later use.
   也就是说 buffer 是用于存放要输出到 disk（块设备）的数据的，而 cache 是存放从 disk 上读出的数据。这二者是为了提高 IO 性能的，并由 OS 管理。

   Linux 和其他成熟的操作系统（例如 windows），为了提高 IO read 的性能，总是要多 cache 一些数据，这也就是为什么 FO[2][6]（cached memory）比较大，而 FO[2][3]比较小的原因。我们可以做一个简单的测试:

   释放掉被系统 cache 占用的数据:

   echo 3>/proc/sys/vm/drop_caches
   读一个大文件，并记录时间；
   关闭该文件；
   重读这个大文件，并记录时间；
   第二次读应该比第一次快很多。原来我做过一个 BerkeleyDB 的读操作，大概要读 5G 的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快 9 倍左右。

   free 输出的第二行是从一个应用程序的角度看系统内存的使用情况。

   对于 FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；
   对于 FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；
   因为被系统 cache 和 buffer 占用的内存可以被快速回收，所以通常 FO[3][3]比 FO[2][3]会大很多。

   这里还用两个等式:

   FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
   FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
   这二者都不难理解。

   free 命令由 procps.*.rpm 提供（在 Redhat 系列的 OS 上）。free 命令的所有输出值都是从/proc/meminfo 中读出的。

   在系统上可能有 meminfo(2)这个函数，它就是为了解析/proc/meminfo 的。procps 这个包自己实现了 meminfo()这个函数。可以下载一个 procps 的 tar 包看看具体实现，现在最新版式 3.2.8。
** 目标文件格式分析[ nm ] 
   nm 用来显示二进制目标文件的符号表。
    
   语法
   nm(选项)(参数)
   选项
   -A：每个符号前显示文件名；
   -D：显示动态符号；
   -g：仅显示外部符号；
   -r：反序显示符号表。

   对于每一个符号来说，其类型如果是小写的，则表明该符号是 local 的；大写则表明
   该符号是 global(external)的。

   A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。
   B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局 static int test。则该符号 test 的类型为 b，位于 bss section 中。其值表示该符号在 bss 段中的偏移。一般而言，bss 段分配于 RAM 中。
   C 该符号为 common。common symbol 是未初始话数据段。该符号没有包含于一个普通 section 中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个 c 文件中，定义 int test，并且该符号在别的地方会被引用，则该符号类型即为 C。否则其类型为 B。
   D 该符号位于初始化数据段中。一般来说，分配到 data section 中。
   例如：定义全局 int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，会分配到初始化数据段中。
   G 该符号也位于初始化数据段中。主要用于 small object 提高访问 small data object 的一种方式。
   I 该符号是对另一个符号的间接引用。
   N 该符号是一个 debugging 符号。
   R 该符号位于只读数据区。
   例如定义全局 const int test[] = {123, 123};则 test 就是一个只读数据区的符号。
   值得注意的是，如果在一个函数中定义 const char *test = “abc”, const char test_int = 3。使用 nm 都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test 在 rodata section 中，大小为 4。
   S 符号位于非初始化数据区，用于 small object。
   T 该符号位于代码区 text section。
   U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。
   例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是 T。但是对于全局变量来说，在定义它的文件中，其符号类型为 C，在使用它的文件中，其类型为 U。
   V 该符号是一个 weak object。
   W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.
   ? 该符号类型没有定义
   库或对象名 如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。

   15.3. 示例
   寻找特殊标识
   有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用 nm 和 objdump、readelf 命令来查看程序的符号表；所有这些命令做的工作基本一样；

   比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用:

   nm -uCA *.o | grep foo
   -u 选项限制了每个目标文件中未定义标识符的输出。-A 选项用于显示每个标识符的文件名信息；对于 C++代码，常用的还有-C 选项，它也为解码这些标识符；

   注解

   objdump、readld 命令可以完成同样的任务。等效命令为： $objdump -t $readelf -s

   列出 a.out 对象文件的静态和外部符:

   $nm -e a.out
   以十六进制显示符号大小和值并且按值排序符号:

   $nm -xv a.out
   显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象:

   $nm -X64 /usr/lib/libc.a
** 显示 obj 信息[ objdump ]
** 构建工具[ make ]
	 ld --oformat binary -N -Ttext 0x7c00 -o $@ $<
   $@ 目标
   $<  依赖

   #+begin_src makefile
     ROOT=b
     SRC=$(ROOT).S
     OBJ=$(ROOT).o
     OUT=$(ROOT).out

     run:$(OUT	)
     qemu-system-i386  $<
     $(OUT):$(OBJ)
     ld --oformat binary -Ttext 0x7c00 -o $@ $<
     $(OBJ):$(SRC)
     as -o $@ $<
   #+end_src
** od 以其他进制输出文件
* 调试器
** gdb 
*** 调试选项    
    调试 $gdb <program>
    转储调试
    $gdb <program> <core dump file>
    $gdb program core.11127

    调试服务
    $gdb <program> <PID>
    $gdb hello 11127
*** 设置断点
    break n（简写 b n）:在第 n 行处设置断点
    b fn1 if a＞b：条件断点设置
    break func（break 缩写为 b）：在函数 func()的入口处设置断点，如：break cb_button
    delete 断点号 n：删除第 n 个断点
    disable 断点号 n：暂停第 n 个断点
    enable 断点号 n：开启第 n 个断点
    clear 行号 n：清除第 n 行的断点
    info b（info breakpoints） ：显示当前程序的断点设置情况
    delete breakpoints：清除所有断点：
*** 常用命令
    break 加断点
    run 运行
    next 单步运行
    info registers 显示所有寄存器的值
    print 显示特定寄存器的值
    print /d 显示十进制的值
    print /t 显示二进制的值
    print /x 显示十六进制的值
    
    x 显示特定内存地址的内容 x /nyz  &address
    - n 是要显示的字段数
    - y 是输出格式
      - c 用于字符
      - d 十进制
      - x 十六进制
    - z 是要显示的字段长度
      - b 字节 8 位
      - h 16 位
      - w 32 位字
*** 查看源代码
    list：简记为 l，其作用就是列出程序的源代码，默认每次显示 10 行。
    list 行号：将显示当前文件以“行号”为中心的前后 10 行代码，如：list 12
    list 函数名：将显示“函数名”所在函数的源代码，如：list main
    list：不带参数，将接着上一次 list 命令的，输出下边的内容。
*** 打印表达式
    print 表达式：简记为 p，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试 C 语言的程序，那么“表达式”可以是任何 C 语言的有效表达式，包括数字，变量甚至是函数调用。
    print a：将显示整数 a 的值
    print ++a：将把 a 中的值加 1,并显示出来
    print name：将显示字符串 name 的值
    print gdb_test(22)：将以整数 22 作为参数调用 gdb_test() 函数
    print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数
    display 表达式：在单步运行时将非常有用，使用 display 命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如：display a
    watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb 将强行终止正在被调试的程序。如：watch a
    whatis：查询变量或函数
    info function： 查询函数
    info locals： 显示当前堆栈页的所有变量
*** 查询运行信息
    where/bt：当前运行的堆栈列表；
    bt backtrace 显示当前调用堆栈
    up/down 改变堆栈显示的深度
    set args 参数:指定运行时的参数
    show args：查看设置好的参数
    info program： 来查看程序的是否在运行，进程号，被暂停的原因。
*** 分割窗口
    layout：用于分割窗口，可以一边查看代码，一边测试：
    layout src：显示源代码窗口
    layout asm：显示反汇编窗口
    layout regs：显示源代码/反汇编和 CPU 寄存器窗口
    layout split：显示源代码和反汇编窗口
* ld script
** 基本
   #+begin_verse
SECTIONS
{
    ... 
    secname start BLOCK(align)(NOLOAD) : AT(ldadr)
    { contents } >region :phdr =fill
    ...
}
   #+end_verse

   secname：段名，用以命名此段
    
   contents：决定哪些内容放在本段，可以是整个目标文件 (.o)，也可以是目标文件中
   的某段（代码段、数据段等）
    
   start：是段的重定位地址，即本段运行的地址。如果代码中有位置无关指令，程序运
   行时这个段必须放在这个地址上。start 可以用任意一种描述地址的符号来描述。

   BLOCK(align) 指定块对齐。比如，前一个段从 0x30000000 到 0x300003F1，此处标记
   ALIGN(4)，表示此处最小占用 4Bytes，即使下一个段是紧挨这个段，那么下一个段的
   起始地址（也就是运行地址）为 0x300003F4。

   NOLOAD：告诉加载器程序运行时不加载该段到内存。

   AT(ldadr)：定义本段存储（加载）的地址，如果不使用这个选项，则加载地址等于运
   行地址，通过这个选项可以控制各段分别保存于输出文件中不同的位置。

** 实例
   #+begin_verse
    SECTIONS 
{
    first 0x00000000 : { head.o init.o }
    second 0x30000000 : AT(4096) { main.o }
}
   #+end_verse

   head.o 放在 0x00000000 地址开始处，init.o 放在 head.o 后面，他们的运行地址也
   是 0x00000000，即存储和运行地址相同（没有 AT 指定）；

   main.o 放在 4096（0x1000，是 AT 指定的，存储地址）开始处，但它的运行地址在
   0x30000000，运行之前需要从 0x1000（加载地址处）复制到 0x30000000（运行地址
   处），此过程也就需要读取 flash，把程序拷贝到相应位置才能运行。这就是存储地址
   和运行地址的不同，称为加载时域和运行时域，可以在. lds 连接脚本文件中分别指定。
** 链接 
   - Tfilename 来调用文件，如 ld -Tnand.lds x.o y.o -o xy.o
   - Ttext 指定链接地址，如 ld -Ttext 0x30000000 x.o y.o -o xy.o
