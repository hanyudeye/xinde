#+TITLE: Gnu/Linux 系统简介
#+DESCRIPTION: linux 系统简介
#+TAGS: linux,os
#+CATEGORIES: 软件使用
#+DATE: <2019-07-13 11:34:07>

* linux
** 简介 
   #+begin_verse
   *LINUX* ，是托瓦兹创造的 类 *UNIX* 的操作系统(管家程序)。
   其实 *linux* 只是一个内核，配上 *GNU* 管理工具才能具备那么多管理功能。
   我们讲的不是内核，是发行版那种的，有很多工具的，还有图形界面。
   #+end_verse
   
   #+HTML: <!-- more -->
   #+begin_quote
   #+begin_verse
   *Gnu/Linux* 才能作为操作系统，才拥有操作系统的管理功能。
   *Gnu* 是 大神 *理查德·马修·斯托曼* 发起 类 *UNIX* 计划，就是 *操作系统* 目前还没完善,其他工具倒是挺好用的。
   #+end_verse
   #+end_quote
** 基本概念
   #+begin_quote
   作为管家，操作系统要把 *晦涩* 的硬件做一个 *抽象* 。 
   #+end_quote
   
   #+begin_verse
   *文件*: 抽象硬盘光盘等存储设备，软件和数据都是文件的方式存储。
   *进程*: 进程是 *程序文件* 在内存的 *拷贝* 及其他信息。
   *设备* : 设备就是设备，但有自己的一套命名方式
   *基本输入输出* : 基本输入就是 *键盘*, 基本输出是 *显示屏* ，特指这俩设备。
   #+end_verse
   
** 登录   
   #+begin_quote
   嘿，不是我电脑不给我用，要登录，管的够严的啊 
   #+end_quote
   
   #+begin_verse
   登录  su
   登出 logout
   建用户 useradd
   设置密码 passwd
   设置用户属性  usermod
   #+end_verse
   
** 基本信息
   #+begin_quote
   基本信息写在文件里了，有些要用命令看，阁下请自便吧。
   #+end_quote
   #+begin_src shell -n
     cat /etc/redhat-release # CentOS 查看系统信息
     uname -a                # 查看内核/操作系统/CPU 信息
     head -n 1 /etc/issue    # 查看操作系统版本
     cat /proc/cpuinfo       # 查看 CPU 信息
     hostname                # 查看计算机名
     lspci -tv               # 列出所有 PCI 设备
     lsusb -tv               # 列出所有 USB 设备
     lsmod                   # 列出加载的内核模块
     free -m                # 查看内存使用量和交换区使用量
     df -h                  # 查看各分区使用情况
     du -sh <目录名>        # 查看指定目录的大小
     grep MemTotal /proc/meminfo   # 查看内存总量
     grep MemFree /proc/meminfo    # 查看空闲内存量
     uptime                 # 查看系统运行时间、用户数、负载
     cat /proc/loadavg      # 查看系统负载
     # 查看内存的插槽数，已经使用多少插槽。每条内存多大，已使用内存多大
     dmidecode|grep -P -A5 "Memory\s+Device"|grep Size|grep -v Range 

   #+end_src
   #+begin_src sh -n
     date #打印或设置系统日期和时间
     arch  #打印机硬件名称 
     nproc #打印可用处理器的数量
     hostid #打印数字主机标识符 
   #+end_src
** 进程管理和调度
   #+begin_quote
   进程是执行着的程序，一般有好多。
   进程间能够通信,像那些聊天程序。
   #+end_quote

   #+begin_verse
   显示进程列表 ps 
   通过 *PID* 给进程发信号 kill 
   显示 *信号* 列表 kill -l
   通过 *进程名* 查找进程 pgrep
   通过 *进程名* 给进程发信号 pkill (找几个发几个)
   #+end_verse

*** 进程属性
    | UID         | 用户 ID                                 |
    | PID         | 进程 ID                                 |
    | PPID        | 父进程 ID                               |
    | C           | CPU 占用率                              |
    | STIME       | 开始时间                                |
    | TTY         | 开始此进程的 TTY----终端设备            |
    | TIME        | 此进程运行的总时间                      |
    | CMD         | 命令名                                  |
    | %CPU | 进程占用 CPU 百分比                       |
    | %MEM        | 进程占用内存百分比                      |
    | VSZ         | 虚拟内存占用大小 单位：kb（killobytes） |
    | RSS         | 实际内存占用大小 单位：kb（killobytes） |
    | STAT        | 进程状态                                |
    | START       | 进程启动时刻                            |
*** 进程状态
    
    #+begin_verse
    R (TASK_RUNNING)，可执行状态。
    S (TASK_INTERRUPTIBLE)，可中断的睡眠状态
    D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态
    #+end_verse
    
*** 进程优先级 
*** 进程间通信和同步
    #+begin_quote
    程序间发消息的方式 
    #+end_quote
    
**** 信号 [signals,SIGxxxx]
**** pipes 
**** sockets
**** file locking
**** message queues
**** semaphores
**** shared memory
** 内存管理
   进程要用到内存，资源也要用到内存，如何处理?硬件提供了分段分页的支持。
   #+begin_quote
   这些是 *linux* 内核控制的，不用我们处理
   #+end_quote
   
   显示内存信息 
   #+begin_src sh
     free
   #+end_src

** 磁盘和分区
   #+begin_quote
   #+begin_verse
   一块磁盘作为一个设备也行，就是你要格式化的时候就要整个格式化，分个区，作为多个设备不是更好吗？
   设备命名 
   IDE 磁盘：/dev/hd[a-d]
   SATA/SCSI/SAS 磁盘：/dev/sd[a-p]
   #+end_verse
   #+end_quote

   #+begin_src sh -n
     df #显示分区信息 
     mount | column -t      # 查看挂接的分区状态
     fdisk -l               # 查看所有分区
     swapon -s              # 查看所有交换分区
     hdparm -i /dev/hda     # 查看磁盘参数(仅适用于 IDE 设备)
     dmesg | grep IDE       # 查看启动时 IDE 设备检测状况
   #+end_src

** 文件系统
   #+begin_quote
   分完区，就能进行文件系统格式化了，存文件都有很多种方式，哈。
   #+end_quote
   
   | 创建文件系统     | mkfs -V -t msdos -c /dev/hda5                                                                         |
   | 更新分区表信息   | partprobe                                                                                             |
   | 加载分区         | mount                                                                                                 |
   | 加载 smb         | sudo mount -t smbfs -o username=user,password='' //10.0.1.1/windowsshare /mnt 浏览 windows 共享文件夹 |
   | 自动加载配置文件 | fstab                                                                                                 |
   | 卸载分区         | umount                                                                                                |
   | 列出文件         | ls                                                                                                    |
   | 编辑文件         | vim                                                                                                   |

** 交换分区文件系统
   #+begin_quote
   交换分区文件系统的操作要分开
   #+end_quote
   
   #+begin_verse
   创建 Linux 交换分区 mkswap
   启用交换分区： # swapon -s
   禁用交换分区： # swapoff /dev/sda7
   用新 UUID 重新创建交换分区： # mkswap -U random /dev/sda7
   激活交换分区: # swapon /dev/sda7
   #+end_verse

** 模块
   #+begin_quote
   相当于 *linux* 内核并不想把非必须的包含在里面，而是以 *模块* 的形式 ，想用自己加载。
   #+end_quote
   #+begin_verse
     rmmod 从运行的内核中移除指定的内核模块
     insmod 将给定的模块加载到内核中
     lsmod 显示已载入系统的模块
   #+end_verse
     
** 设备
   #+begin_quote
   #+begin_verse
   计算机使用的设备大体归于三类 ：  块设备,字符设备 ,网络设备 ,还有一些目录设备，链接
   块设备和字符设备因为其区别，操作应该是不一样的，操作系统抽象成同样的使用方法了 open()、close()、read()、write()
   设备以文件的形式显示，但不能以文件的读写方式操作。
   网络设备面向数据包的接收和发送而设计，它并不对应于文件系统的节点，内核与网络设备的通信和内核与字符设备、块设备的通行方式完全不同
   #+end_verse
   #+end_quote
*** 字符设备  
    #+begin_verse
    /dev/zero
    /dev/random  随机数,慢，精确
    /dev/urandom 系统随机，块，随机少
    #+end_verse
*** 块设备
*** 网络设备

** 网络管理
   #+begin_quote
   对 *联机* 的操作。
   #+end_quote
   #+begin_verse
   rounte -n 查看本机路由表
   netstat -lntp 查看所有监听端口
   netstat -antp 查看所有已建立的连接
   ifconfig 查看所有网络接口的属性 
   iptables -L 查看 iptables 防火墙 
   #+end_verse
** 系统调用 
** 数据同步
** 任务 
   #+begin_quote
   这是 *shell* 里的概念，因为前端一次只能操作一个程序
   #+end_quote
   任务放在前、后台 fg bg jobs 
   
   周期任务 crontab
   #+begin_verse 
      * * * * *                  # 每隔一分钟执行一次任务  
      0 * * * *                  # 每小时的 0 点执行一次任务，比如 6:00，10:00  
      6,10 * 2 * *            # 每个月 2 号，每小时的 6 分和 10 分执行一次任务  
      0 * * * *                  # 每小时的 0 点执行一次任务，比如 6:00，10:00  
      6,10 * 2 * *            # 每个月 2 号，每小时的 6 分和 10 分执行一次任务  
   #+end_verse

** 帮助文档    
   #+begin_quote
   有些东西不会可以查看文档，如果还不会可以上网查。
   #+end_quote
   #+begin_verse
   man [manual]  简单文档
   info 详细文档
   #+end_verse
   
* 发行版
** 软件包管理工具
   两类，一类 *redhat* 系 ,一类 *debian* 系
   - deb 包
     - 数据包，包含实际安装的程序数据，文件名为 data.tar.XXX；
     - 安装信息及控制脚本包，包含 deb 的安装说明，标识，脚本等，文件名为 control.tar.gz；
     - 最后一个是 deb 文件的一些二进制数据，包括文件头等信息，一般看不到

** 字体
   安装
    #+begin_src sh -n
    sudo mv Monaco.ttf /usr/share/fonts/custom
    sudo chmod 744 /usr/share/fonts/custom/Monaco.ttf

    sudo mkfontscale  #生成核心字体信息
    sudo mkfontdir
    sudo fc-cache -fv
    #+end_src
    
    显示已安装的字体
    #+begin_src sh
      fc-list
    #+end_src
    
** 用户目录配置
   ~/.config/user-dirs.dirs
** 压缩解压
*** unar
    解压缩，中文不会乱码
    
* 启动过程
** 引导程序载入内核
   引导扇区的 Grub 读入 /boot 目录下的内核文件
** init process  (初始化)
   调用配置： /etc/inittab, /etc/init/*.conf
** 系统初始化
   /etc/rc.d/init.d/
** 建立终端 
   1:2345:respawn:/sbin/mingetty tty1
   2:2345:respawn:/sbin/mingetty tty2
** 用户登录系统
   #+begin_verse
   （1）命令行登录
   （2）ssh 登录
   （3）图形界面登录
   #+end_verse
   
** 图形模式与文字模式切换
   Ctrl + Alt + F1 ~ F6
** 关机
   正确的关机流程为：sync > shutdown > reboot > halt
   关机指令为：shutdown -h +10 10 分钟后
* 图形工具
** Xcompmgr  
   Xcompmgr 是一个简单的混合窗口管理器，可以实现阴影、原生窗口透明（配合 transset 工具）等特效
** mate-power-manager
   MATE 桌面的电源管理工具
** Redshift
   根据您周围的环境调整屏幕的色温。如果您晚上在屏幕前工作，这可能会帮助您减少眼睛受伤
