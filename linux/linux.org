#+TITLE: linux 系统使用简介
#+DESCRIPTION: linux 系统使用简介
#+TAGS: linux,os
#+CATEGORIES: 软件使用
#+DATE: <2019-06-07 07:29:28>

* linux
** 启动过程
*** 引导程序载入内核
    引导扇区的 Grub 读入 /boot 目录下的内核文件
*** init process  (初始化)
    调用配置： /etc/inittab, /etc/init/*.conf
*** 系统初始化
    在 init 的配置文件中有这么一行：si::sysinit:/etc/rc.d/rc.sysinit　它调用执行
    了/etc/rc.d/rc.sysinit l5:5:wait:/etc/rc.d/rc 5 这一行表示以 5 为参数运行
    /etc/rc.d/rc，/etc/rc.d/rc 是一个 Shell 脚本，它接受 5 作为参数，去执行
    /etc/rc.d/rc5.d/目录下的所有的 rc 启动脚本，/etc/rc.d/rc5.d/目录中的这些启动
    脚本实际上都是一些连接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际
    上都是放在/etc/rc.d/init.d/目录下。
*** 建立终端 
    1:2345:respawn:/sbin/mingetty tty1
    2:2345:respawn:/sbin/mingetty tty2
    3:2345:respawn:/sbin/mingetty tty3
    4:2345:respawn:/sbin/mingetty tty4
    5:2345:respawn:/sbin/mingetty tty5
    6:2345:respawn:/sbin/mingetty tty6
*** 用户登录系统
    （1）命令行登录
    （2）ssh 登录
    （3）图形界面登录
*** 图形模式与文字模式切换
    Ctrl + Alt + F1 ~ F6
*** 关机
    正确的关机流程为：sync > shutdown > reboot > halt
    关机指令为：shutdown -h +10 10 分钟后
** 日志
    var/log/
** Date and Time
*** Real time(1970,1,1,UTC) 
*** Process time(CPU 时间)
** 进程 [ fork ]
*** 特权级 [ 继承 ]
*** 守护进程 (demo,常驻进程)
    httpd, syslogd
*** 环境 list [ 环境变量 ]
    shell 中用 export 输出环境变量
    
    c 中 
   访问  char ** environ
*** 资源使用
*** 内存映射 [ mmap,虚拟内存 ]
    执行文件代码段初始化    
    分配新的 (zero-filled) 内存
    memory-mapped I/O
    进程通信 (shared mapping 共享内存)
*** 进程间通信和同步
**** 信号 [signals,SIGxxxx,整数]
     shell 中   
     中断信号 Control-C
     发送信号 kill

**** pipes 
**** sockets
**** file locking
**** message queues
**** semaphores
**** shared memory
*** 线程 ( Threads )
*** Process Groups and Shell Job Control [进程组中每个进程的进程组标示相同]
    $ ls -l | sort -k5n | less
*** 会话，控制终端和控制进程 [ 一个终端创建一个会话 ]
*** 伪终端( Pseudoterminals )
*** The /proc File System (进程印象)

** 静态和共享库 
*** 静态库 (也称归档 arthives) [ 结构化的 object 模块] 
    linker  添加到 执行文件中
*** 共享库 [ 动态链接器调用 ]
    可执行文件  加入一条 记录
* linux 操作系统 
  linux 操作系统 一般是学习 linux 内核  + 应用程序 的过程 
  linux 一般以发行版的形式安装，方便简单。
** 磁盘操作
  本机设备都放在 /dev/ 这个目录下
  磁盘设备放在 /dev/sd* 文件名下
  分区类型，分为 msdos(MBR) 和 GPT 两种
  MBR 是为了兼容 windows,它把开机程序和，分区信息都放在第一个扇区。
  如果是扩展分区类型的分区，在在目的分区的第一扇区划出多个扩展分区子分区。
  扩展分区最多一个。

  
  GUID partition table(  GPT 磁盘分区表 ), 把扇区定义为逻辑区块地址（Logical Block Address, LBA）
  GPT 使用了 34 个 LBA 区块来纪录分区信息,并且磁盘最后的 34 个 LBA 用来作备份。
  LBA0 （MBR 相容区块）
  LBA1 （GPT 表头纪录）
  LBA2-33 （实际纪录分区信息处）
  

  开机的检测程序分为 BIOS 和 UEFI
  BIOS 会调用操作系统设置的 MBR/GPT(LBA0) 的启动程序,跟操作系统有关。
  
  linux 会多一个 boot loader 来选择多个系统中的一个。
  
 UEFI（Unified Extensible Firmware Interface）,相当于一个小操作系统，可以进行配置，所以如果要安装 linux,就要关闭 安全启动（secure boot )这一选项.  
 : 微软专用
** 文件权限与目录配置
   因为系统是多用户的，所以文件有了所属问题，其他用户对文件的权限由文件所有者所给予。
   改变文件所有者,chown
   改变文件所属组 chgrp
   改变文件权限 chmod
   添加组  addgroup
   
   文件的节点属性由文件系统决定。
** 文件目录管理
   显示目录中的文件，可以用命令 ls
   文件内容拷贝 cp
   文件名字变更 mv
   删除文件 rm
   
   文件内容查询 
   由第一行开始显示文件内容 cat
   从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ tac
   显示的时候，顺道输出行号！ nl 
   more 一页一页的显示文件内容
   less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
   head 只看头几行
   tail 只看尾巴几行
   od 以二进制的方式读取文件内容！
   
   设置文件隐藏属性 chattr
   
   查找指令或文件
   查找可执行文件 which
   查找文件或程序 whereis 
   查找本地信息 locale
   查找文件 find find /etc -name '*httpd*'
** 文件系统 
   分区后，要进行分区格式化，以便存放文件。
   最新的技术，可以将一个分区格式化为多个文件系统( 例如 LVM )，也能将多个分区合并为一个文件系统(LVM, RAID)。
   inode 存放文件权限与属性, data block 存放实际数据 ,superblock 记录文件系统整体信息。

   显示被格式化的设备 blkid
   超级块的详细信息  dumpe2fs /dev/vda5

   列出文件系统的信息 df
   评估文件系统使用量  du

   列出磁盘的分区表类型与分区信息 parted (parted device_name print)
   磁盘分区： gdisk/fdisk
   
   开机挂载 /etc/fstab
   
   挂载交换文件 swapon /dev/vda6
   使用文件创建交换文件 mkswap
** 文件压缩技术
   压缩率有小到大 为 compress > gzip > bzip > xz, 但耗时久

   光盘写入工具
   创建镜像文件  mkisofs
** 账号与群组
   每个用户都有一个用户标示 UID
   同样每个组有一个数字表示  GID 
   id 可以显示用户信息  

   创建新用户，useradd
   删除用户 userdel
   修改用户属性 usermod

   获取文件属性 getfacl
   设置文件属性 setfacl

   切换到超级管理员权限运行 sudo 
   权限文件配置 /etc/sudoers

   查询使用者
   w
   who
   lastlog

   使用者对谈： write, mesg, wall
   
   使用者邮件信箱： mail
   mail -s "nice to meet you" vbird1
** 工作调度 cront
** 磁盘配额
   quota
** 系统服务
   service
** 软件安装 
** X Window 
** 编译内核
** 模块
 /lib/modules/$(uname -r)/kernel/
* 设备
** 字符设备  
   /dev/zero
   /dev/random  随机数,慢，精确
   /dev/urandom 系统随机，块，随机少

* 排查错误
tac /var/log/syslog |grep -i error | less



** Linux 系统日志 
在 ~/var/log~ 文件夹下

/var/log/syslog 或 /var/log/messages 存储所有的全局系统活动数据，包括开机信息。
基于 Debian 的系统如 Ubuntu 在 /var/log/syslog 中存储它们，而基于 RedHat 的系统
如 RHEL 或 CentOS 则在 /var/log/messages 中存储它们。


#+begin_quote
/var/log/auth.log 或 /var/log/secure 存储来自可插拔认证模块(PAM)的日志，包括成功的登录，失败的登录尝试和认证方式。
Ubuntu 和 Debian 在 /var/log/auth.log 中存储认证信息，而 RedHat 和 CentOS 则在 /var/log/secure 中存储该信息。

/var/log/kern 存储内核的错误和警告数据，这对于排除与定制内核相关的故障尤为实用。
/var/log/cron 存储有关 cron 作业的信息。使用这个数据来确保你的 cron 作业正成功地运行着。
Digital Ocean 有一个关于这些文件的完整教程，介绍了 rsyslog 如何在常见的发行版本如 RedHat 和 CentOS 中创建它们。
#+end_quote

#+begin_quote
应用程序也会在这个目录中写入日志文件。例如像 Apache，Nginx，MySQL 等常见的服务器
程序可以在这个目录中写入日志文件。其中一些日志文件由应用程序自己创建，其他的则通
过 syslog (具体见下文)来创建。
#+end_quote



*** 什么是 Syslog？
    Linux 系统日志文件是如何创建的呢？答案是通过 syslog 守护程序，它在 syslog 套接字 /dev/log 上监听日志信息，然后将它们写入适当的日志文件中。

    单词“syslog” 代表几个意思，并经常被用来简称如下的几个名称之一：

#+begin_verse
Syslog 守护进程 — 一个用来接收、处理和发送 syslog 信息的程序。它可以远程发送 syslog 到一个集中式的服务器或写入到一个本地文件。常见的例子包括 rsyslogd 和 syslog-ng。在这种使用方式中，人们常说“发送到 syslog”。
Syslog 协议 — 一个指定日志如何通过网络来传送的传输协议和一个针对 syslog 信息(具体见下文) 的数据格式的定义。它在 RFC-5424 中被正式定义。对于文本日志，标准的端口是 514，对于加密日志，端口是 6514。在这种使用方式中，人们常说“通过 syslog 传送”。
Syslog 信息 — syslog 格式的日志信息或事件，它包括一个带有几个标准字段的消息头。在这种使用方式中，人们常说“发送 syslog”。
Syslog 信息或事件包括一个带有几个标准字段的消息头，可以使分析和路由更方便。它们包括时间戳、应用程序的名称、在系统中信息来源的分类或位置、以及事件的优先级。
#+end_verse

下面展示的是一个包含 syslog 消息头的日志信息，它来自于控制着到该系统的远程登录的 sshd 守护进程，这个信息描述的是一次失败的登录尝试：

#+begin_verse
<34>1 2003-10-11T22:14:15.003Z server1.com sshd - - pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=10.0.2.2
#+end_verse

Syslog 格式和字段

每条 syslog 信息包含一个带有字段的信息头，这些字段是结构化的数据，使得分析和路由
事件更加容易。下面是我们使用的用来产生上面的 syslog 例子的格式，你可以将每个值匹
配到一个特定的字段的名称上。

#+begin_verse
<%pri%>%protocol-version% %timestamp:::date-rfc3339% %HOSTNAME% %app-name% %procid% %msgid% %msg%n
#+end_verse

下面，你将看到一些在查找或排错时最常使用的 syslog 字段：
时间戳
时间戳 (上面的例子为 2003-10-11T22:14:15.003Z) 暗示了在系统中发送该信息的时间和日期。这个时间在另一系统上接收该信息时可能会有所不同。上面例子中的时间戳可以分解为：

2003-10-11 年，月，日。
T 为时间戳的必需元素，它将日期和时间分隔开。
22:14:15.003 是 24 小时制的时间，包括进入下一秒的毫秒数(003)。
Z 是一个可选元素，指的是 UTC 时间，除了 Z，这个例子还可以包括一个偏移量，例如 -08:00，这意味着时间从 UTC 偏移 8 小时，即 PST 时间。
主机名
主机名 字段(在上面的例子中对应 server1.com) 指的是主机的名称或发送信息的系统.

应用名
应用名 字段(在上面的例子中对应 sshd:auth) 指的是发送信息的程序的名称.

优先级
优先级字段或缩写为 pri (在上面的例子中对应 ) 告诉我们这个事件有多紧急或多严峻。它由两个数字字段组成：设备字段和紧急性字段。紧急性字段从代表 debug 类事件的数字 7 一直到代表紧急事件的数字 0 。设备字段描述了哪个进程创建了该事件。它从代表内核信息的数字 0 到代表本地应用使用的 23 。

Pri 有两种输出方式。第一种是以一个单独的数字表示，可以这样计算：先用设备字段的值乘以 8，再加上紧急性字段的值：(设备字段)(8) + (紧急性字段)。第二种是 pri 文本，将以“设备字段.紧急性字段” 的字符串格式输出。后一种格式更方便阅读和搜索，但占据更多的存储空间。

在 Linux 中使用日志来排错
登录失败原因

如果你想检查你的系统是否安全，你可以在验证日志中检查登录失败的和登录成功但可疑的用户。当有人通过不正当或无效的凭据来登录时会出现认证失败，这通常发生在使用 SSH 进行远程登录或 su 到本地其他用户来进行访问权时。这些是由插入式验证模块（PAM）来记录的。在你的日志中会看到像 Failed password 和 user unknown 这样的字符串。而成功认证记录则会包括像 Accepted password 和 session opened 这样的字符串。

失败的例子:
#+begin_verse
pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=10.0.2.2
Failed password for invalid user hoover from 10.0.2.2 port 4791 ssh2
pam_unix(sshd:auth): check pass; user unknown
PAM service(sshd) ignoring max retries; 6 > 3
#+end_verse

成功的例子：
#+begin_verse

Accepted password for hoover from 10.0.2.2 port 4792 ssh2
pam_unix(sshd:session): session opened for user hoover by (uid=0)
pam_unix(sshd:session): session closed for user hoover
#+end_verse

你可以使用 grep 来查找哪些用户失败登录的次数最多。这些都是潜在的攻击者正在尝试和访问失败的账户。这是一个在 ubuntu 系统上的例子。

复制代码代码如下:

$ grep "invalid user" /var/log/auth.log | cut -d ' ' -f 10 | sort | uniq -c | sort -nr
23 oracle
18 postgres
17 nagios
10 zabbix
6 test

由于没有标准格式，所以你需要为每个应用程序的日志使用不同的命令。日志管理系统，可以自动分析日志，将它们有效的归类，帮助你提取关键字，如用户名。
日志管理系统可以使用自动解析功能从 Linux 日志中提取用户名。这使你可以看到用户的信息，并能通过点击过滤。在下面这个例子中，我们可以看到，root 用户登录了 2700 次之多，因为我们筛选的日志仅显示 root 用户的尝试登录记录。

日志管理系统也可以让你以时间为做坐标轴的图表来查看，使你更容易发现异常。如果有人在几分钟内登录失败一次或两次，它可能是一个真正的用户而忘记了密码。但是，如果有几百个失败的登录并且使用的都是不同的用户名，它更可能是在试图攻击系统。在这里，你可以看到在 3 月 12 日，有人试图登录 Nagios 几百次。这显然​​不是一个合法的系统用户。

重启的原因
有时候，一台服务器由于系统崩溃或重启而宕机。你怎么知道它何时发生，是谁做的？

关机命令
如果有人手动运行 shutdown 命令，你可以在验证日志文件中看到它。在这里，你可以看到，有人从 IP 50.0.134.125 上作为 ubuntu 的用户远程登录了，然后关闭了系统。


复制代码代码如下:

Mar 19 18:36:41 ip-172-31-11-231 sshd[23437]: Accepted publickey for ubuntu from 50.0.134.125 port 52538 ssh
Mar 19 18:36:41 ip-172-31-11-231 23437]:sshd[ pam_unix(sshd:session): session opened for user ubuntu by (uid=0)
Mar 19 18:37:09 ip-172-31-11-231 sudo: ubuntu : TTY=pts/1 ; PWD=/home/ubuntu ; USER=root ; COMMAND=/sbin/shutdown -r now

内核初始化
如果你想看看服务器重新启动的所有原因（包括崩溃），你可以从内核初始化日志中寻找。你需要搜索内核类（kernel）和 cpu 初始化（Initializing）的信息。

复制代码代码如下:

Mar 19 18:39:30 ip-172-31-11-231 kernel: [ 0.000000] Initializing cgroup subsys cpuset
Mar 19 18:39:30 ip-172-31-11-231 kernel: [ 0.000000] Initializing cgroup subsys cpu
Mar 19 18:39:30 ip-172-31-11-231 kernel: [ 0.000000] Linux version 3.8.0-44-generic (buildd@tipua) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #66~precise1-Ubuntu SMP Tue Jul 15 04:01:04 UTC 2014 (Ubuntu 3.8.0-44.66~precise1-generic 3.8.13.25)

检测内存问题
有很多原因可能导致服务器崩溃，但一个常见的原因是内存用尽。
当你系统的内存不足时，进程会被杀死，通常会杀死使用最多资源的进程。当系统使用了所有内存，而新的或现有的进程试图使用更多的内存时就会出现错误。在你的日志文件查找像 Out of Memory 这样的字符串或类似 kill 这样的内核警告信息。这些信息表明系统故意杀死进程或应用程序，而不是允许进程崩溃。

例如:


复制代码代码如下:

[33238.178288] Out of memory: Kill process 6230 (firefox) score 53 or sacrifice child
[29923450.995084] select 5230 (docker), adj 0, size 708, to kill

你可以使用像 grep 这样的工具找到这些日志。这个例子是在 ubuntu 中:

复制代码代码如下:

$ grep “Out of memory” /var/log/syslog
[33238.178288] Out of memory: Kill process 6230 (firefox) score 53 or sacrifice child

请记住，grep 也要使用内存，所以只是运行 grep 也可能导致内存不足的错误。这是另一个你应该中央化存储日志的原因！
定时任务错误日志
cron 守护程序是一个调度器，可以在指定的日期和时间运行进程。如果进程运行失败或无法完成，那么 cron 的错误出现在你的日志文件中。具体取决于你的发行版，你可以在 /var/log/cron，/var/log/messages，和 /var/log/syslog 几个位置找到这个日志。cron 任务失败原因有很多。通常情况下，问题出在进程中而不是 cron 守护进程本身。

默认情况下，cron 任务的输出会通过 postfix 发送电子邮件。这是一个显示了该邮件已经发送的日志。不幸的是，你不能在这里看到邮件的内容。


复制代码代码如下:

Mar 13 16:35:01 PSQ110 postfix/pickup[15158]: C3EDC5800B4: uid=1001 from=<hoover>
Mar 13 16:35:01 PSQ110 postfix/cleanup[15727]: C3EDC5800B4: message-id=<20150310110501.C3EDC5800B4@PSQ110>
Mar 13 16:35:01 PSQ110 postfix/qmgr[15159]: C3EDC5800B4: from=<hoover@loggly.com>, size=607, nrcpt=1 (queue active)
Mar 13 16:35:05 PSQ110 postfix/smtp[15729]: C3EDC5800B4: to=<hoover@loggly.com>, relay=gmail-smtp-in.l.google.com[74.125.130.26]:25, delay=4.1, delays=0.26/0/2.2/1.7, dsn=2.0.0, status=sent (250 2.0.0 OK 1425985505 f16si501651pdj.5 - gsmtp)

你可以考虑将 cron 的标准输出记录到日志中，以帮助你定位问题。这是一个你怎样使用 logger 命令重定向 cron 标准输出到 syslog 的例子。用你的脚本来代替 echo 命令，helloCron 可以设置为任何你想要的应用程序的名字。
*/5 * * * * echo ‘Hello World’ 2>&1 | /usr/bin/logger -t helloCron
它创建的日志条目：


复制代码代码如下:

Apr 28 22:20:01 ip-172-31-11-231 CRON[15296]: (ubuntu) CMD (echo 'Hello World!' 2>&1 | /usr/bin/logger -t helloCron)
Apr 28 22:20:01 ip-172-31-11-231 helloCron: Hello World!

每个 cron 任务将根据任务的具体类型以及如何输出数据来记录不同的日志。
希望在日志中有问题根源的线索，也可以根据需要添加额外的日志记录。
* Linux 日志删除与恢复
Linux 日志删除
Linux 的系统日志一般位于/var/log 目录内
以下为常见系统日志：

–

lastlog ：纪录最近几次成功登录的事件和最后一次不成功的登录
utmp ：纪录当前登录的每个用户
wtmp： 一个用户每次登录进入和退出时间的永久纪录
messages： 从 syslog 中记录信息（有的链接到 syslog 文件）
sudolog：纪录使用 sudo 发出的命令
sulog：纪录使用 su 命令的使用
syslog：从 syslog 中记录信息（通常链接到 messages 文件）
acct 或 pacct：记录每个用户使用的命令记录
history 日志：这个文件保存了用户最近输入命令的记录

–

日志系统使用 logrotate 来进行自动清除以防止日志文件过大 在/etc/logrotate.conf logrotate.d 中
rotate 为转存次数

直接删除使用 rm
删除一定天数前的日志文件。输入命令：

find /var/log -mtime +3 -name “*.log” -exec rm -rf {} ;
该命令将/var/log/目录下所有 3 天前带“.log”的文件删除。

Tips:
find 命令的使用:

-mtime -n +n

按照文件的更改时间来查找文件，-n 表示 n 天以内，+n 表示 n 天以前

“ *.log”

匹配希望查找的数据类型

-exec

find 命令对匹配的文件执行该参数所给出的 shell 命令。相应命令的形式为’command’ { } ;

脚本删除
cat /dev/null > /var/log/lastlog

cat /dev/null 可以看作一个”黑洞”. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到.

因此可以使用此命令构建删除脚本: clear_log.sh

1
2
3
#!/bin/sh
cat /dev/null > /var/log/lastlog
...
清除 history
history -c

简单清除 history 很容易被发现，因此需要按需删除记录在 bash_history 中的内容

应用日志同上
Linux 日志恢复
原理： 当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。

-

要将日志恢复，首先要确保日志进程未停止运行，利用 lsof 命令找到该进程，利用进程标识符和文件描述符，使用 cat 命令将内容重写到日志文件，然后重启日志记录服务。

lsof 的使用
List Open Files 一个非常实用的系统级的监控、诊断工具
是有着最多开关的 Linux/Unix 命令之一

lsof 直接输入

列出活跃进程的所有打开文件

1
2
3
4
5
6
7
8
COMMAND    PID  TID             USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
systemd      1                  root  cwd       DIR               8,20      4096          2 /
systemd      1                  root  rtd       DIR               8,20      4096          2 /
systemd      1                  root  txt       REG               8,20   1690360     925307 /lib/systemd/systemd
systemd      1                  root  mem       REG               8,20   1354616    1088074 /lib/x86_64-linux-gnu/libm-2.26.so
systemd      1                  root  mem       REG               8,20    121016    1050521 /lib/x86_64-linux-gnu/libudev.so.1.6.8
systemd      1                  root  mem       REG               8,20     84032    1050539 /lib/x86_64-linux-gnu/libgpg-error.so.0.22.0
systemd      1                  root  mem       REG               8,20     18832    1050740 /lib/x86_64-linux-gnu/libattr.so.1.1.0
信息如下
COMMAND | 进程的名称
PID | 进程标识符
USER | 进程所有者
FD | 文件描述符，应用程序通过文件描述符识别该文件。如 cwd、txt 等
TYPE | 文件类型，如 DIR、REG 等
DEVICE | 指定磁盘的名称
SIZE | 文件的大小
NODE | 索引节点（文件在磁盘上的标识）
NAME | 打开文件的确切名称

-i

显示所有网络连接

filename

显示开启 filename 文件的进程

-c processname

显示该进程打开的文件

-c -p pid

显示该进程号对应的进程打开的文件

-d dir

显示该目录下被打开的文件

-D dir

同上 迭代显示目录下所有文件夹

wc 命令的使用
wc 的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出

-c

统计字节数

-l

统计行数

-m

统计字符数，不能与 -c 标志一起使用

-w

统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串

–version

显示版本信息

Tips：
查看文件大小的几种方式

stat filepath

时间、大小均显示，较详细

wc -c filename

只适用于文件，显示结果为字节数，无单位

du -b/-h -filepath

b 表示字节数 无单位
h 表示更友好的形式 有单位

ls -lh filepath

h 代表 human 对人更友好

Linux 内核中提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc 文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。

/proc/N/fd

N 为进程 Pid ，该文件夹中包含进程相关的所有的文件描述符

/proc/N/status

进程的状态

查看日志情况
使用 lsof 命令查看目前打开丢失日志的进程
如 lsof | grep /var/log/syslog ，便可得到相应信息 COMMAND、PID、FD
使用 wc 命令查看日志情况
如 wc -l /proc/1/fd/1 可查看在内存中的日志记录
重写日志
cat /proc/1/fd/1 > /var/log/syslog

重启服务
对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用。

